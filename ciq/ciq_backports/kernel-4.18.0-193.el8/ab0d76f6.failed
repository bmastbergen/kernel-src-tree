nl80211: use policy range validation where applicable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit ab0d76f6823cc3a4e277c888abd344e3b977e279
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ab0d76f6.failed

Many range checks can be done in the policy, move them
there. A few in mesh are added in the code (taken out of
the macros) because they don't fit into the s16 range in
the policy validation.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit ab0d76f6823cc3a4e277c888abd344e3b977e279)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 4e1c052bca2e,3e368c3f1df2..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -317,9 -258,8 +319,14 @@@ const struct nla_policy nl80211_policy[
  	[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },
  	[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,
  					       .len = NL80211_MAX_SUPP_RATES },
++<<<<<<< HEAD
 +	[NL80211_ATTR_STA_PLINK_ACTION] = { .type = NLA_U8 },
 +	[NL80211_ATTR_STA_TX_POWER_SETTING] = { .type = NLA_S16 },
 +	[NL80211_ATTR_STA_TX_POWER] = { .type = NLA_S16 },
++=======
+ 	[NL80211_ATTR_STA_PLINK_ACTION] =
+ 		NLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_ACTIONS - 1),
++>>>>>>> ab0d76f6823c (nl80211: use policy range validation where applicable)
  	[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },
  	[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },
  	[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,
@@@ -3447,13 -3223,11 +3458,10 @@@ static int nl80211_new_interface(struc
  	if (!info->attrs[NL80211_ATTR_IFNAME])
  		return -EINVAL;
  
- 	if (info->attrs[NL80211_ATTR_IFTYPE]) {
+ 	if (info->attrs[NL80211_ATTR_IFTYPE])
  		type = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);
- 		if (type > NL80211_IFTYPE_MAX)
- 			return -EINVAL;
- 	}
  
 -	if (!rdev->ops->add_virtual_intf ||
 -	    !(rdev->wiphy.interface_modes & (1 << type)))
 +	if (!rdev->ops->add_virtual_intf)
  		return -EOPNOTSUPP;
  
  	if ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||
@@@ -5764,26 -5432,10 +5730,23 @@@ static int nl80211_new_station(struct s
  			nla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);
  	}
  
- 	if (info->attrs[NL80211_ATTR_STA_PLINK_ACTION]) {
+ 	if (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])
  		params.plink_action =
  			nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);
- 		if (params.plink_action >= NUM_NL80211_PLINK_ACTIONS)
- 			return -EINVAL;
- 	}
  
 +	if (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])
 +		params.airtime_weight =
 +			nla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);
 +
 +	if (params.airtime_weight &&
 +	    !wiphy_ext_feature_isset(&rdev->wiphy,
 +				     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
 +		return -EOPNOTSUPP;
 +
 +	err = nl80211_parse_sta_txpower_setting(info, &params);
 +	if (err)
 +		return err;
 +
  	err = nl80211_parse_sta_channel_info(info, &params);
  	if (err)
  		return err;
@@@ -6494,36 -6134,51 +6453,52 @@@ static int nl80211_get_mesh_config(stru
  	return -ENOBUFS;
  }
  
- static const struct nla_policy nl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {
- 	[NL80211_MESHCONF_RETRY_TIMEOUT] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_CONFIRM_TIMEOUT] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_HOLDING_TIMEOUT] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_MAX_PEER_LINKS] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_MAX_RETRIES] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_TTL] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_ELEMENT_TTL] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] = { .type = NLA_U32 },
+ static const struct nla_policy
+ nl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {
+ 	[NL80211_MESHCONF_RETRY_TIMEOUT] =
+ 		NLA_POLICY_RANGE(NLA_U16, 1, 255),
+ 	[NL80211_MESHCONF_CONFIRM_TIMEOUT] =
+ 		NLA_POLICY_RANGE(NLA_U16, 1, 255),
+ 	[NL80211_MESHCONF_HOLDING_TIMEOUT] =
+ 		NLA_POLICY_RANGE(NLA_U16, 1, 255),
+ 	[NL80211_MESHCONF_MAX_PEER_LINKS] =
+ 		NLA_POLICY_RANGE(NLA_U16, 0, 255),
+ 	[NL80211_MESHCONF_MAX_RETRIES] = NLA_POLICY_MAX(NLA_U8, 16),
+ 	[NL80211_MESHCONF_TTL] = NLA_POLICY_MIN(NLA_U8, 1),
+ 	[NL80211_MESHCONF_ELEMENT_TTL] = NLA_POLICY_MIN(NLA_U8, 1),
+ 	[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = NLA_POLICY_MAX(NLA_U8, 1),
+ 	[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] =
+ 		NLA_POLICY_RANGE(NLA_U32, 1, 255),
  	[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },
  	[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },
- 	[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = { .type = NLA_U16 },
+ 	[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = NLA_POLICY_MIN(NLA_U16, 1),
  	[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },
- 	[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_HWMP_ROOTMODE] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_HWMP_RANN_INTERVAL] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_FORWARDING] = { .type = NLA_U8 },
- 	[NL80211_MESHCONF_RSSI_THRESHOLD] = { .type = NLA_U32 },
+ 	[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] =
+ 		NLA_POLICY_MIN(NLA_U16, 1),
+ 	[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] =
+ 		NLA_POLICY_MIN(NLA_U16, 1),
+ 	[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] =
+ 		NLA_POLICY_MIN(NLA_U16, 1),
+ 	[NL80211_MESHCONF_HWMP_ROOTMODE] = NLA_POLICY_MAX(NLA_U8, 4),
+ 	[NL80211_MESHCONF_HWMP_RANN_INTERVAL] =
+ 		NLA_POLICY_MIN(NLA_U16, 1),
+ 	[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = NLA_POLICY_MAX(NLA_U8, 1),
+ 	[NL80211_MESHCONF_FORWARDING] = NLA_POLICY_MAX(NLA_U8, 1),
+ 	[NL80211_MESHCONF_RSSI_THRESHOLD] =
+ 		NLA_POLICY_RANGE(NLA_S32, -255, 0),
  	[NL80211_MESHCONF_HT_OPMODE] = { .type = NLA_U16 },
  	[NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT] = { .type = NLA_U32 },
- 	[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] = { .type = NLA_U16 },
- 	[NL80211_MESHCONF_POWER_MODE] = { .type = NLA_U32 },
+ 	[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] =
+ 		NLA_POLICY_MIN(NLA_U16, 1),
+ 	[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] =
+ 		NLA_POLICY_MIN(NLA_U16, 1),
+ 	[NL80211_MESHCONF_POWER_MODE] =
+ 		NLA_POLICY_RANGE(NLA_U32,
+ 				 NL80211_MESH_POWER_ACTIVE,
+ 				 NL80211_MESH_POWER_MAX),
  	[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },
  	[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },
 +	[NL80211_MESHCONF_CONNECTED_TO_GATE] = { .type = NLA_U8 },
  };
  
  static const struct nla_policy
@@@ -6623,79 -6222,73 +6540,87 @@@ do {									
  	BUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);
  
  	/* Fill in the params struct */
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, 1, 255,
- 				  mask, NL80211_MESHCONF_RETRY_TIMEOUT,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, 1, 255,
- 				  mask, NL80211_MESHCONF_CONFIRM_TIMEOUT,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, 1, 255,
- 				  mask, NL80211_MESHCONF_HOLDING_TIMEOUT,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, 0, 255,
- 				  mask, NL80211_MESHCONF_MAX_PEER_LINKS,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, 0, 16,
- 				  mask, NL80211_MESHCONF_MAX_RETRIES,
- 				  nl80211_check_u8);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, 1, 255,
- 				  mask, NL80211_MESHCONF_TTL, nl80211_check_u8);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, 1, 255,
- 				  mask, NL80211_MESHCONF_ELEMENT_TTL,
- 				  nl80211_check_u8);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, 0, 1,
- 				  mask, NL80211_MESHCONF_AUTO_OPEN_PLINKS,
- 				  nl80211_check_bool);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, mask,
+ 				  NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, mask,
+ 				  NL80211_MESHCONF_CONFIRM_TIMEOUT,
+ 				  nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, mask,
+ 				  NL80211_MESHCONF_HOLDING_TIMEOUT,
+ 				  nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, mask,
+ 				  NL80211_MESHCONF_MAX_PEER_LINKS,
+ 				  nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, mask,
+ 				  NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, mask,
+ 				  NL80211_MESHCONF_TTL, nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, mask,
+ 				  NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, mask,
+ 				  NL80211_MESHCONF_AUTO_OPEN_PLINKS,
+ 				  nla_get_u8);
  	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNbrOffsetMaxNeighbor,
- 				  1, 255, mask,
+ 				  mask,
  				  NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,
- 				  nl80211_check_u32);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, 0, 255,
- 				  mask, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
- 				  nl80211_check_u8);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, 1, 65535,
- 				  mask, NL80211_MESHCONF_PATH_REFRESH_TIME,
- 				  nl80211_check_u32);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, 1, 65535,
- 				  mask, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
- 				  nl80211_check_u16);
+ 				  nla_get_u32);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, mask,
+ 				  NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
+ 				  nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, mask,
+ 				  NL80211_MESHCONF_PATH_REFRESH_TIME,
+ 				  nla_get_u32);
+ 	if (mask & BIT(NL80211_MESHCONF_PATH_REFRESH_TIME) &&
+ 	    (cfg->path_refresh_time < 1 || cfg->path_refresh_time > 65535))
+ 		return -EINVAL;
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, mask,
+ 				  NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
+ 				  nla_get_u16);
  	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,
- 				  1, 65535, mask,
+ 				  mask,
  				  NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
- 				  nl80211_check_u32);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval,
- 				  1, 65535, mask,
+ 				  nla_get_u32);
+ 	if (mask & BIT(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT) &&
+ 	    (cfg->dot11MeshHWMPactivePathTimeout < 1 ||
+ 	     cfg->dot11MeshHWMPactivePathTimeout > 65535))
+ 		return -EINVAL;
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval, mask,
  				  NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval,
- 				  1, 65535, mask,
+ 				  nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval, mask,
  				  NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,
- 				  nl80211_check_u16);
+ 				  nla_get_u16);
  	FILL_IN_MESH_PARAM_IF_SET(tb, cfg,
- 				  dot11MeshHWMPnetDiameterTraversalTime,
- 				  1, 65535, mask,
+ 				  dot11MeshHWMPnetDiameterTraversalTime, mask,
  				  NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, 0, 4,
- 				  mask, NL80211_MESHCONF_HWMP_ROOTMODE,
- 				  nl80211_check_u8);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, 1, 65535,
- 				  mask, NL80211_MESHCONF_HWMP_RANN_INTERVAL,
- 				  nl80211_check_u16);
- 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg,
- 				  dot11MeshGateAnnouncementProtocol, 0, 1,
+ 				  nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, mask,
+ 				  NL80211_MESHCONF_HWMP_ROOTMODE, nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, mask,
+ 				  NL80211_MESHCONF_HWMP_RANN_INTERVAL,
+ 				  nla_get_u16);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshGateAnnouncementProtocol,
  				  mask, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,
++<<<<<<< HEAD
 +				  nl80211_check_bool);
 +	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, 0, 1,
 +				  mask, NL80211_MESHCONF_FORWARDING,
 +				  nl80211_check_bool);
 +	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, -255, 0,
 +				  mask, NL80211_MESHCONF_RSSI_THRESHOLD,
 +				  nl80211_check_s32);
 +	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToMeshGate,
 +				  1, 255, mask,
 +				  NL80211_MESHCONF_CONNECTED_TO_GATE,
 +				  nl80211_check_bool);
++=======
+ 				  nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, mask,
+ 				  NL80211_MESHCONF_FORWARDING, nla_get_u8);
+ 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, mask,
+ 				  NL80211_MESHCONF_RSSI_THRESHOLD,
+ 				  nla_get_s32);
++>>>>>>> ab0d76f6823c (nl80211: use policy range validation where applicable)
  	/*
  	 * Check HT operation mode based on
  	 * IEEE 802.11-2016 9.4.2.57 HT Operation element.
* Unmerged path net/wireless/nl80211.c
