drivers/base/memory.c: get rid of find_memory_block_hinted()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [base] base/memory.c: get rid of find_memory_block_hinted() (Baoquan He) [1724969]
Rebuild_FUZZ: 92.86%
commit-author David Hildenbrand <david@redhat.com>
commit dd625285910d3cff535fa76355e49949513918a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/dd625285.failed

No longer needed, let's remove it.  Also, drop the "hint" parameter
completely from "find_memory_block_by_id", as nobody needs it anymore.

[david@redhat.com: v3]
  Link: http://lkml.kernel.org/r/20190620183139.4352-7-david@redhat.com
[david@redhat.com: handle zero-length walks]
  Link: http://lkml.kernel.org/r/1c2edc22-afd7-2211-c4c7-40e54e5007e8@redhat.com
Link: http://lkml.kernel.org/r/20190614100114.311-7-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Qian Cai <cai@lca.pw>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Andrew Banman <andrew.banman@hpe.com>
	Cc: Mike Travis <mike.travis@hpe.com>
	Cc: Oscar Salvador <osalvador@suse.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Wei Yang <richard.weiyang@gmail.com>
	Cc: Arun KS <arunks@codeaurora.org>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dd625285910d3cff535fa76355e49949513918a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/memory.c
diff --cc drivers/base/memory.c
index 25064c825e5c,20c39d1bcef8..000000000000
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@@ -577,23 -588,13 +577,33 @@@ int __weak arch_get_memory_phys_device(
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * A reference for the returned object is held and the reference for the
 + * hinted object is released.
 + */
 +struct memory_block *find_memory_block_hinted(struct mem_section *section,
 +					      struct memory_block *hint)
 +{
 +	int block_id = base_memory_block_id(__section_nr(section));
 +	struct device *hintdev = hint ? &hint->dev : NULL;
 +	struct device *dev;
 +
 +	dev = subsys_find_device_by_id(&memory_subsys, block_id, hintdev);
 +	if (hint)
 +		put_device(&hint->dev);
 +	if (!dev)
 +		return NULL;
 +	return to_memory_block(dev);
++=======
+ /* A reference for the returned memory block device is acquired. */
+ static struct memory_block *find_memory_block_by_id(unsigned long block_id)
+ {
+ 	struct device *dev;
+ 
+ 	dev = subsys_find_device_by_id(&memory_subsys, block_id, NULL);
+ 	return dev ? to_memory_block(dev) : NULL;
++>>>>>>> dd625285910d (drivers/base/memory.c: get rid of find_memory_block_hinted())
  }
  
  /*
@@@ -657,6 -660,11 +669,14 @@@ static int init_memory_block(struct mem
  	unsigned long start_pfn;
  	int ret = 0;
  
++<<<<<<< HEAD
++=======
+ 	mem = find_memory_block_by_id(block_id);
+ 	if (mem) {
+ 		put_device(&mem->dev);
+ 		return -EEXIST;
+ 	}
++>>>>>>> dd625285910d (drivers/base/memory.c: get rid of find_memory_block_hinted())
  	mem = kzalloc(sizeof(*mem), GFP_KERNEL);
  	if (!mem)
  		return -ENOMEM;
@@@ -733,35 -712,70 +753,85 @@@ unregister_memory(struct memory_block *
  	device_unregister(&memory->dev);
  }
  
 -/*
 - * Create memory block devices for the given memory area. Start and size
 - * have to be aligned to memory block granularity. Memory block devices
 - * will be initialized as offline.
 - */
 -int create_memory_block_devices(unsigned long start, unsigned long size)
 +void unregister_memory_section(struct mem_section *section)
  {
 -	const unsigned long start_block_id = pfn_to_block_id(PFN_DOWN(start));
 -	unsigned long end_block_id = pfn_to_block_id(PFN_DOWN(start + size));
  	struct memory_block *mem;
 -	unsigned long block_id;
 -	int ret = 0;
  
++<<<<<<< HEAD
 +	if (WARN_ON_ONCE(!present_section(section)))
 +		return;
 +
 +	mutex_lock(&mem_sysfs_mutex);
 +
 +	/*
 +	 * Some users of the memory hotplug do not want/need memblock to
 +	 * track all sections. Skip over those.
 +	 */
 +	mem = find_memory_block(section);
 +	if (!mem)
 +		goto out_unlock;
 +
 +	unregister_mem_sect_under_nodes(mem, __section_nr(section));
 +
 +	mem->section_count--;
 +	if (mem->section_count == 0)
++=======
+ 	if (WARN_ON_ONCE(!IS_ALIGNED(start, memory_block_size_bytes()) ||
+ 			 !IS_ALIGNED(size, memory_block_size_bytes())))
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&mem_sysfs_mutex);
+ 	for (block_id = start_block_id; block_id != end_block_id; block_id++) {
+ 		ret = init_memory_block(&mem, block_id, MEM_OFFLINE);
+ 		if (ret)
+ 			break;
+ 		mem->section_count = sections_per_block;
+ 	}
+ 	if (ret) {
+ 		end_block_id = block_id;
+ 		for (block_id = start_block_id; block_id != end_block_id;
+ 		     block_id++) {
+ 			mem = find_memory_block_by_id(block_id);
+ 			mem->section_count = 0;
+ 			unregister_memory(mem);
+ 		}
+ 	}
+ 	mutex_unlock(&mem_sysfs_mutex);
+ 	return ret;
+ }
+ 
+ /*
+  * Remove memory block devices for the given memory area. Start and size
+  * have to be aligned to memory block granularity. Memory block devices
+  * have to be offline.
+  */
+ void remove_memory_block_devices(unsigned long start, unsigned long size)
+ {
+ 	const unsigned long start_block_id = pfn_to_block_id(PFN_DOWN(start));
+ 	const unsigned long end_block_id = pfn_to_block_id(PFN_DOWN(start + size));
+ 	struct memory_block *mem;
+ 	unsigned long block_id;
+ 
+ 	if (WARN_ON_ONCE(!IS_ALIGNED(start, memory_block_size_bytes()) ||
+ 			 !IS_ALIGNED(size, memory_block_size_bytes())))
+ 		return;
+ 
+ 	mutex_lock(&mem_sysfs_mutex);
+ 	for (block_id = start_block_id; block_id != end_block_id; block_id++) {
+ 		mem = find_memory_block_by_id(block_id);
+ 		if (WARN_ON_ONCE(!mem))
+ 			continue;
+ 		mem->section_count = 0;
+ 		unregister_memory_block_under_nodes(mem);
++>>>>>>> dd625285910d (drivers/base/memory.c: get rid of find_memory_block_hinted())
  		unregister_memory(mem);
 -	}
 +	else
 +		put_device(&mem->dev);
 +
 +out_unlock:
  	mutex_unlock(&mem_sysfs_mutex);
  }
 +#endif /* CONFIG_MEMORY_HOTREMOVE */
  
  /* return true if the memory block is offlined, otherwise, return false */
  bool is_memblock_offlined(struct memory_block *mem)
@@@ -827,3 -841,43 +897,46 @@@ out
  		printk(KERN_ERR "%s() failed: %d\n", __func__, ret);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * walk_memory_blocks - walk through all present memory blocks overlapped
+  *			by the range [start, start + size)
+  *
+  * @start: start address of the memory range
+  * @size: size of the memory range
+  * @arg: argument passed to func
+  * @func: callback for each memory section walked
+  *
+  * This function walks through all present memory blocks overlapped by the
+  * range [start, start + size), calling func on each memory block.
+  *
+  * In case func() returns an error, walking is aborted and the error is
+  * returned.
+  */
+ int walk_memory_blocks(unsigned long start, unsigned long size,
+ 		       void *arg, walk_memory_blocks_func_t func)
+ {
+ 	const unsigned long start_block_id = phys_to_block_id(start);
+ 	const unsigned long end_block_id = phys_to_block_id(start + size - 1);
+ 	struct memory_block *mem;
+ 	unsigned long block_id;
+ 	int ret = 0;
+ 
+ 	if (!size)
+ 		return 0;
+ 
+ 	for (block_id = start_block_id; block_id <= end_block_id; block_id++) {
+ 		mem = find_memory_block_by_id(block_id);
+ 		if (!mem)
+ 			continue;
+ 
+ 		ret = func(mem, arg);
+ 		put_device(&mem->dev);
+ 		if (ret)
+ 			break;
+ 	}
+ 	return ret;
+ }
++>>>>>>> dd625285910d (drivers/base/memory.c: get rid of find_memory_block_hinted())
* Unmerged path drivers/base/memory.c
diff --git a/include/linux/memory.h b/include/linux/memory.h
index e1dc1bb2b787..a589b7bb4604 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -118,8 +118,6 @@ extern void unregister_memory_section(struct mem_section *);
 extern int memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);
-extern struct memory_block *find_memory_block_hinted(struct mem_section *,
-							struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
