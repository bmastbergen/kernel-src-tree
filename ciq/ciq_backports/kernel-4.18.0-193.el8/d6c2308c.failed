bpf: verifier: randomize high 32-bit when BPF_F_TEST_RND_HI32 is set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jiong Wang <jiong.wang@netronome.com>
commit d6c2308c742a655f4598364ab331959639aae166
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d6c2308c.failed

This patch randomizes high 32-bit of a definition when BPF_F_TEST_RND_HI32
is set.

	Suggested-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Jiong Wang <jiong.wang@netronome.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit d6c2308c742a655f4598364ab331959639aae166)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 75ea2294b3b5,2778417e6e0c..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -7526,6 -7640,84 +7526,87 @@@ static int opt_remove_nops(struct bpf_v
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int opt_subreg_zext_lo32_rnd_hi32(struct bpf_verifier_env *env,
+ 					 const union bpf_attr *attr)
+ {
+ 	struct bpf_insn *patch, zext_patch[2], rnd_hi32_patch[4];
+ 	struct bpf_insn_aux_data *aux = env->insn_aux_data;
+ 	int i, patch_len, delta = 0, len = env->prog->len;
+ 	struct bpf_insn *insns = env->prog->insnsi;
+ 	struct bpf_prog *new_prog;
+ 	bool rnd_hi32;
+ 
+ 	rnd_hi32 = attr->prog_flags & BPF_F_TEST_RND_HI32;
+ 	zext_patch[1] = BPF_ZEXT_REG(0);
+ 	rnd_hi32_patch[1] = BPF_ALU64_IMM(BPF_MOV, BPF_REG_AX, 0);
+ 	rnd_hi32_patch[2] = BPF_ALU64_IMM(BPF_LSH, BPF_REG_AX, 32);
+ 	rnd_hi32_patch[3] = BPF_ALU64_REG(BPF_OR, 0, BPF_REG_AX);
+ 	for (i = 0; i < len; i++) {
+ 		int adj_idx = i + delta;
+ 		struct bpf_insn insn;
+ 
+ 		insn = insns[adj_idx];
+ 		if (!aux[adj_idx].zext_dst) {
+ 			u8 code, class;
+ 			u32 imm_rnd;
+ 
+ 			if (!rnd_hi32)
+ 				continue;
+ 
+ 			code = insn.code;
+ 			class = BPF_CLASS(code);
+ 			if (insn_no_def(&insn))
+ 				continue;
+ 
+ 			/* NOTE: arg "reg" (the fourth one) is only used for
+ 			 *       BPF_STX which has been ruled out in above
+ 			 *       check, it is safe to pass NULL here.
+ 			 */
+ 			if (is_reg64(env, &insn, insn.dst_reg, NULL, DST_OP)) {
+ 				if (class == BPF_LD &&
+ 				    BPF_MODE(code) == BPF_IMM)
+ 					i++;
+ 				continue;
+ 			}
+ 
+ 			/* ctx load could be transformed into wider load. */
+ 			if (class == BPF_LDX &&
+ 			    aux[adj_idx].ptr_type == PTR_TO_CTX)
+ 				continue;
+ 
+ 			imm_rnd = get_random_int();
+ 			rnd_hi32_patch[0] = insn;
+ 			rnd_hi32_patch[1].imm = imm_rnd;
+ 			rnd_hi32_patch[3].dst_reg = insn.dst_reg;
+ 			patch = rnd_hi32_patch;
+ 			patch_len = 4;
+ 			goto apply_patch_buffer;
+ 		}
+ 
+ 		if (!bpf_jit_needs_zext())
+ 			continue;
+ 
+ 		zext_patch[0] = insn;
+ 		zext_patch[1].dst_reg = insn.dst_reg;
+ 		zext_patch[1].src_reg = insn.dst_reg;
+ 		patch = zext_patch;
+ 		patch_len = 2;
+ apply_patch_buffer:
+ 		new_prog = bpf_patch_insn_data(env, adj_idx, patch, patch_len);
+ 		if (!new_prog)
+ 			return -ENOMEM;
+ 		env->prog = new_prog;
+ 		insns = new_prog->insnsi;
+ 		aux = env->insn_aux_data;
+ 		delta += patch_len - 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d6c2308c742a (bpf: verifier: randomize high 32-bit when BPF_F_TEST_RND_HI32 is set)
  /* convert load instructions that access fields of a context type into a
   * sequence of instructions that access fields of the underlying structure:
   *     struct __sk_buff    -> struct sk_buff
@@@ -8371,6 -8568,15 +8452,18 @@@ skip_full_check
  	if (ret == 0)
  		ret = fixup_bpf_calls(env);
  
++<<<<<<< HEAD
++=======
+ 	/* do 32-bit optimization after insn patching has done so those patched
+ 	 * insns could be handled correctly.
+ 	 */
+ 	if (ret == 0 && !bpf_prog_is_dev_bound(env->prog->aux)) {
+ 		ret = opt_subreg_zext_lo32_rnd_hi32(env, attr);
+ 		env->prog->aux->verifier_zext = bpf_jit_needs_zext() ? !ret
+ 								     : false;
+ 	}
+ 
++>>>>>>> d6c2308c742a (bpf: verifier: randomize high 32-bit when BPF_F_TEST_RND_HI32 is set)
  	if (ret == 0)
  		ret = fixup_call_args(env);
  
* Unmerged path kernel/bpf/verifier.c
