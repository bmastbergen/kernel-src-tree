mac80211: IEEE 802.11 Extended Key ID support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Alexander Wetzel <alexander@wetzel-home.de>
commit 96fc6efb9ad9d0cd8cbb4462f0eb2a07092649e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/96fc6efb.failed

Add support for Extended Key ID as defined in IEEE 802.11-2016.

 - Implement the nl80211 API for Extended Key ID
 - Extend mac80211 API to allow drivers to support Extended Key ID
 - Enable Extended Key ID by default for drivers only supporting SW
   crypto (e.g. mac80211_hwsim)
 - Allow unicast Tx usage to be supressed (IEEE80211_KEY_FLAG_NO_AUTO_TX)
 - Select the decryption key based on the MPDU keyid
 - Enforce existing assumptions in the code that rekeys don't change the
   cipher

	Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
[remove module parameter]
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 96fc6efb9ad9d0cd8cbb4462f0eb2a07092649e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/mac80211.h
#	net/mac80211/cfg.c
#	net/mac80211/key.c
#	net/mac80211/main.c
diff --cc include/net/mac80211.h
index 12cc1c1a65f8,c10abca55fde..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -1703,9 -1698,6 +1703,12 @@@ struct wireless_dev *ieee80211_vif_to_w
   *	a TKIP key if it only requires MIC space. Do not set together with
   *	@IEEE80211_KEY_FLAG_GENERATE_MMIC on the same key.
   * @IEEE80211_KEY_FLAG_NO_AUTO_TX: Key needs explicit Tx activation.
++<<<<<<< HEAD
 + * @IEEE80211_KEY_FLAG_GENERATE_MMIE: This flag should be set by the driver
 + *	for a AES_CMAC key to indicate that it requires sequence number
 + *	generation only
++=======
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
   */
  enum ieee80211_key_flags {
  	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT	= BIT(0),
@@@ -1718,7 -1710,6 +1721,10 @@@
  	IEEE80211_KEY_FLAG_RESERVE_TAILROOM	= BIT(7),
  	IEEE80211_KEY_FLAG_PUT_MIC_SPACE	= BIT(8),
  	IEEE80211_KEY_FLAG_NO_AUTO_TX		= BIT(9),
++<<<<<<< HEAD
 +	IEEE80211_KEY_FLAG_GENERATE_MMIE	= BIT(10),
++=======
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  };
  
  /**
diff --cc net/mac80211/cfg.c
index 1163b3e246ee,14bbb7e8ad0e..000000000000
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@@ -351,7 -351,6 +351,10 @@@ static int ieee80211_set_noack_map(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +#if 0 /* Not in RHEL */
++=======
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  static int ieee80211_set_tx(struct ieee80211_sub_if_data *sdata,
  			    const u8 *mac_addr, u8 key_idx)
  {
@@@ -381,7 -380,6 +384,10 @@@
  	mutex_unlock(&local->key_mtx);
  	return ret;
  }
++<<<<<<< HEAD
 +#endif
++=======
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  
  static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
  			     u8 key_idx, bool pairwise, const u8 *mac_addr,
@@@ -397,10 -395,8 +403,15 @@@
  	if (!ieee80211_sdata_running(sdata))
  		return -ENETDOWN;
  
++<<<<<<< HEAD
 +#if 0 /* Not in RHEL */
  	if (pairwise && params->mode == NL80211_KEY_SET_TX)
  		return ieee80211_set_tx(sdata, mac_addr, key_idx);
 +#endif
++=======
++	if (pairwise && params->mode == NL80211_KEY_SET_TX)
++		return ieee80211_set_tx(sdata, mac_addr, key_idx);
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  
  	/* reject WEP and TKIP keys if WEP failed to initialize */
  	switch (params->cipher) {
@@@ -432,10 -429,8 +443,15 @@@
  	if (pairwise)
  		key->conf.flags |= IEEE80211_KEY_FLAG_PAIRWISE;
  
++<<<<<<< HEAD
 +#if 0 /* Not in RHEL */
  	if (params->mode == NL80211_KEY_NO_TX)
  		key->conf.flags |= IEEE80211_KEY_FLAG_NO_AUTO_TX;
 +#endif
++=======
++	if (params->mode == NL80211_KEY_NO_TX)
++		key->conf.flags |= IEEE80211_KEY_FLAG_NO_AUTO_TX;
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  
  	mutex_lock(&local->sta_mtx);
  
diff --cc net/mac80211/key.c
index 157ff5f890d2,42d52cded4c1..000000000000
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@@ -265,9 -269,11 +265,17 @@@ int ieee80211_set_tx_key(struct ieee802
  {
  	struct sta_info *sta = key->sta;
  	struct ieee80211_local *local = key->local;
++<<<<<<< HEAD
 +
 +	assert_key_lock(local);
 +
++=======
+ 	struct ieee80211_key *old;
+ 
+ 	assert_key_lock(local);
+ 
+ 	old = key_mtx_dereference(local, sta->ptk[sta->ptk_idx]);
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  	sta->ptk_idx = key->conf.keyidx;
  	ieee80211_check_fast_xmit(sta);
  
diff --cc net/mac80211/main.c
index 5c2878092f39,5d6b93050c0b..000000000000
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@@ -1048,23 -1051,10 +1048,30 @@@ int ieee80211_register_hw(struct ieee80
  		}
  	}
  
++<<<<<<< HEAD
 +#if 0  /* Not in RHEL */
 +	/* Enable Extended Key IDs when driver allowed it, or when it
 +	 * supports neither HW crypto nor A-MPDUs
 +	 */
 +	if ((!local->ops->set_key &&
 +	     !ieee80211_hw_check(hw, AMPDU_AGGREGATION)) ||
 +	    ieee80211_hw_check(&local->hw, EXT_KEY_ID_NATIVE))
 +		wiphy_ext_feature_set(local->hw.wiphy,
 +				      NL80211_EXT_FEATURE_EXT_KEY_ID);
 +#endif
 +
 +	/* Mac80211 and therefore all cards only using SW crypto are able to
 +	 * handle PTK rekeys correctly
 +	 */
 +	if (!local->ops->set_key)
 +		wiphy_ext_feature_set(local->hw.wiphy,
 +				      NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
++=======
+ 	if (!local->ops->set_key ||
+ 	    ieee80211_hw_check(&local->hw, EXT_KEY_ID_NATIVE))
+ 		wiphy_ext_feature_set(local->hw.wiphy,
+ 				      NL80211_EXT_FEATURE_EXT_KEY_ID);
++>>>>>>> 96fc6efb9ad9 (mac80211: IEEE 802.11 Extended Key ID support)
  
  	/*
  	 * Calculate scan IE length -- we need this to alloc
* Unmerged path include/net/mac80211.h
* Unmerged path net/mac80211/cfg.c
* Unmerged path net/mac80211/key.c
* Unmerged path net/mac80211/main.c
