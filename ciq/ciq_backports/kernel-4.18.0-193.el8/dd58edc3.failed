net/mlx5e: Extend mod header entry with reference counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Extend mod header entry with reference counter (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 96.36%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit dd58edc328cec1a0d837f3f2f41e9955ec623e3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/dd58edc3.failed

List of flows attached to mod header entry is used as implicit reference
counter (mod header entry is deallocated when list becomes free) and as a
mechanism to obtain mod header entry that flow is attached to (through list
head). This is not safe when concurrent modification of list of flows
attached to mod header entry is possible. Proper atomic reference counter
is required to support concurrent access.

As a preparation for extending mod header with reference counting, extract
code that lookups and deletes mod header entry into standalone put/get
helpers. In order to remove this dependency on external locking, extend mod
header entry with reference counter to manage its lifetime and extend flow
structure with direct pointer to mod header entry that flow is attached to.

To remove code duplication between legacy and switchdev mode
implementations that both support mod_hdr functionality, store mod_hdr
table in dedicated structure used by both fdb and kernel namespaces. New
table structure is extended with table lock by one of the following patches
in this series. Implement helper function to get correct mod_hdr table
depending on flow namespace.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit dd58edc328cec1a0d837f3f2f41e9955ec623e3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index eb70ada89b09,ca2161b42c7f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@@ -14,7 -16,8 +14,12 @@@ struct mlx5e_tc_table 
  
  	struct rhashtable               ht;
  
++<<<<<<< HEAD
 +	DECLARE_HASHTABLE(mod_hdr_tbl, 8);
++=======
+ 	struct mod_hdr_tbl mod_hdr;
+ 	struct mutex hairpin_tbl_lock; /* protects hairpin_tbl */
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  	DECLARE_HASHTABLE(hairpin_tbl, 8);
  
  	struct notifier_block     netdevice_nb;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c033e0d4fc59,fe1b04aa910a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -117,7 -119,9 +117,8 @@@ struct mlx5e_tc_flow 
  	 */
  	struct encap_flow_item encaps[MLX5_MAX_FLOW_FWD_VPORTS];
  	struct mlx5e_tc_flow    *peer_flow;
+ 	struct mlx5e_mod_hdr_entry *mh; /* attached mod header instance */
  	struct list_head	mod_hdr; /* flows sharing the same mod hdr ID */
 -	struct mlx5e_hairpin_entry *hpe; /* attached hairpin instance */
  	struct list_head	hairpin; /* flows sharing the same hairpin */
  	struct list_head	peer;    /* flows with peer flow */
  	struct list_head	unready; /* flows not ready to be offloaded (e.g due to missing route) */
@@@ -204,11 -328,11 +244,12 @@@ static int mlx5e_attach_mod_hdr(struct 
  				struct mlx5e_tc_flow *flow,
  				struct mlx5e_tc_flow_parse_attr *parse_attr)
  {
- 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 	bool is_eswitch_flow = mlx5e_is_eswitch_flow(flow);
  	int num_actions, actions_size, namespace, err;
  	struct mlx5e_mod_hdr_entry *mh;
+ 	struct mod_hdr_tbl *tbl;
  	struct mod_hdr_key key;
 +	bool found = false;
  	u32 hash_key;
  
  	num_actions  = parse_attr->num_mod_hdr_actions;
@@@ -219,27 -343,12 +260,34 @@@
  
  	hash_key = hash_mod_hdr_info(&key);
  
++<<<<<<< HEAD
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH) {
 +		namespace = MLX5_FLOW_NAMESPACE_FDB;
 +		hash_for_each_possible(esw->offloads.mod_hdr_tbl, mh,
 +				       mod_hdr_hlist, hash_key) {
 +			if (!cmp_mod_hdr_info(&mh->key, &key)) {
 +				found = true;
 +				break;
 +			}
 +		}
 +	} else {
 +		namespace = MLX5_FLOW_NAMESPACE_KERNEL;
 +		hash_for_each_possible(priv->fs.tc.mod_hdr_tbl, mh,
 +				       mod_hdr_hlist, hash_key) {
 +			if (!cmp_mod_hdr_info(&mh->key, &key)) {
 +				found = true;
 +				break;
 +			}
 +		}
 +	}
++=======
+ 	namespace = is_eswitch_flow ?
+ 		MLX5_FLOW_NAMESPACE_FDB : MLX5_FLOW_NAMESPACE_KERNEL;
+ 	tbl = get_mod_hdr_table(priv, namespace);
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  
- 	if (found)
+ 	mh = mlx5e_mod_hdr_get(tbl, &key, hash_key);
+ 	if (mh)
  		goto attach_flow;
  
  	mh = kzalloc(sizeof(*mh) + actions_size, GFP_KERNEL);
@@@ -258,14 -368,12 +307,19 @@@
  	if (err)
  		goto out_err;
  
++<<<<<<< HEAD
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH)
 +		hash_add(esw->offloads.mod_hdr_tbl, &mh->mod_hdr_hlist, hash_key);
 +	else
 +		hash_add(priv->fs.tc.mod_hdr_tbl, &mh->mod_hdr_hlist, hash_key);
++=======
+ 	hash_add(tbl->hlist, &mh->mod_hdr_hlist, hash_key);
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  
  attach_flow:
+ 	flow->mh = mh;
  	list_add(&flow->mod_hdr, &mh->flows);
 -	if (is_eswitch_flow)
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH)
  		flow->esw_attr->mod_hdr_id = mh->mod_hdr_id;
  	else
  		flow->nic_attr->mod_hdr_id = mh->mod_hdr_id;
@@@ -280,7 -388,9 +334,13 @@@ out_err
  static void mlx5e_detach_mod_hdr(struct mlx5e_priv *priv,
  				 struct mlx5e_tc_flow *flow)
  {
++<<<<<<< HEAD
 +	struct list_head *next = flow->mod_hdr.next;
++=======
+ 	/* flow wasn't fully initialized */
+ 	if (!flow->mh)
+ 		return;
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  
  	list_del(&flow->mod_hdr);
  
@@@ -3460,7 -3857,9 +3513,13 @@@ int mlx5e_tc_nic_init(struct mlx5e_pri
  	struct mlx5e_tc_table *tc = &priv->fs.tc;
  	int err;
  
++<<<<<<< HEAD
 +	hash_init(tc->mod_hdr_tbl);
++=======
+ 	mutex_init(&tc->t_lock);
+ 	hash_init(tc->mod_hdr.hlist);
+ 	mutex_init(&tc->hairpin_tbl_lock);
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  	hash_init(tc->hairpin_tbl);
  
  	err = rhashtable_init(&tc->ht, &tc_ht_params);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index be195cce77a4,5ce3c81e3083..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1868,13 -2000,12 +1868,18 @@@ int mlx5_eswitch_init(struct mlx5_core_
  		goto abort;
  
  	hash_init(esw->offloads.encap_tbl);
++<<<<<<< HEAD
 +	hash_init(esw->offloads.mod_hdr_tbl);
++=======
+ 	hash_init(esw->offloads.mod_hdr.hlist);
+ 	atomic64_set(&esw->offloads.num_flows, 0);
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  	mutex_init(&esw->state_lock);
  
 -	mlx5_esw_for_all_vports(esw, i, vport) {
 -		vport->vport = mlx5_eswitch_index_to_vport_num(esw, i);
 +	for (vport_num = 0; vport_num < total_vports; vport_num++) {
 +		struct mlx5_vport *vport = &esw->vports[vport_num];
 +
 +		vport->vport = vport_num;
  		vport->info.link_state = MLX5_VPORT_ADMIN_STATE_AUTO;
  		vport->dev = dev;
  		INIT_WORK(&vport->vport_change_handler,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index af9a875f1cf1,fd63ba4ed0da..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -173,9 -182,12 +173,16 @@@ struct mlx5_esw_offload 
  	struct list_head peer_flows;
  	struct mutex peer_mutex;
  	DECLARE_HASHTABLE(encap_tbl, 8);
++<<<<<<< HEAD
 +	DECLARE_HASHTABLE(mod_hdr_tbl, 8);
++=======
+ 	struct mod_hdr_tbl mod_hdr;
+ 	DECLARE_HASHTABLE(termtbl_tbl, 8);
+ 	struct mutex termtbl_mutex; /* protects termtbl hash */
+ 	const struct mlx5_eswitch_rep_ops *rep_ops[NUM_REP_TYPES];
++>>>>>>> dd58edc328ce (net/mlx5e: Extend mod header entry with reference counter)
  	u8 inline_mode;
 -	atomic64_t num_flows;
 +	u64 num_flows;
  	enum devlink_eswitch_encap_mode encap;
  };
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index 8f2806f456c6..1b52e8ac68c4 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -126,6 +126,10 @@ struct mlx5_flow_destination {
 	};
 };
 
+struct mod_hdr_tbl {
+	DECLARE_HASHTABLE(hlist, 8);
+};
+
 struct mlx5_flow_namespace *
 mlx5_get_fdb_sub_ns(struct mlx5_core_dev *dev, int n);
 struct mlx5_flow_namespace *
