xprtrdma: Eliminate struct rpcrdma_create_data_internal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 86c4ccd9b92ba6541fc4734e82f87139deea0470
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/86c4ccd9.failed

Clean up.

Move the remaining field in rpcrdma_create_data_internal so the
structure can be removed.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 86c4ccd9b92ba6541fc4734e82f87139deea0470)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/transport.c
#	net/sunrpc/xprtrdma/verbs.c
#	net/sunrpc/xprtrdma/xprt_rdma.h
diff --cc net/sunrpc/xprtrdma/transport.c
index 189afd4026fc,1f73a6a7e43c..000000000000
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@@ -68,9 -68,9 +68,9 @@@
   * tunables
   */
  
- static unsigned int xprt_rdma_slot_table_entries = RPCRDMA_DEF_SLOT_TABLE;
+ unsigned int xprt_rdma_slot_table_entries = RPCRDMA_DEF_SLOT_TABLE;
  unsigned int xprt_rdma_max_inline_read = RPCRDMA_DEF_INLINE;
 -unsigned int xprt_rdma_max_inline_write = RPCRDMA_DEF_INLINE;
 +static unsigned int xprt_rdma_max_inline_write = RPCRDMA_DEF_INLINE;
  unsigned int xprt_rdma_memreg_strategy		= RPCRDMA_FRWR;
  int xprt_rdma_pad_optimize;
  
@@@ -349,19 -347,7 +347,21 @@@ xprt_setup_rdma(struct xprt_create *arg
  		xprt_set_bound(xprt);
  	xprt_rdma_format_addresses(xprt, sap);
  
++<<<<<<< HEAD
 +	cdata.max_requests = xprt_rdma_slot_table_entries;
 +	cdata.inline_wsize = xprt_rdma_max_inline_write;
 +	cdata.inline_rsize = xprt_rdma_max_inline_read;
 +
 +	/*
 +	 * Create new transport instance, which includes initialized
 +	 *  o ia
 +	 *  o endpoint
 +	 *  o buffers
 +	 */
 +
++=======
++>>>>>>> 86c4ccd9b92b (xprtrdma: Eliminate struct rpcrdma_create_data_internal)
  	new_xprt = rpcx_to_rdmax(xprt);
- 
  	rc = rpcrdma_ia_open(new_xprt);
  	if (rc)
  		goto out1;
diff --cc net/sunrpc/xprtrdma/verbs.c
index 4b69d5e2e3f7,0d0c3356f34e..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -488,6 -491,10 +491,13 @@@ int rpcrdma_ep_create(struct rpcrdma_xp
  	unsigned int max_sge;
  	int rc;
  
++<<<<<<< HEAD
++=======
+ 	ep->rep_max_requests = xprt_rdma_slot_table_entries;
+ 	ep->rep_inline_send = xprt_rdma_max_inline_write;
+ 	ep->rep_inline_recv = xprt_rdma_max_inline_read;
+ 
++>>>>>>> 86c4ccd9b92b (xprtrdma: Eliminate struct rpcrdma_create_data_internal)
  	max_sge = min_t(unsigned int, ia->ri_id->device->attrs.max_send_sge,
  			RPCRDMA_MAX_SEND_SGES);
  	if (max_sge < RPCRDMA_MIN_SEND_SGES) {
diff --cc net/sunrpc/xprtrdma/xprt_rdma.h
index d2fe3ed9ca67,9e98ee0cd937..000000000000
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@@ -97,6 -97,9 +97,12 @@@ struct rpcrdma_ep 
  	wait_queue_head_t 	rep_connect_wait;
  	struct rpcrdma_connect_private	rep_cm_private;
  	struct rdma_conn_param	rep_remote_cma;
++<<<<<<< HEAD
++=======
+ 	unsigned int		rep_max_requests;	/* set by /proc */
+ 	unsigned int		rep_inline_send;	/* negotiated */
+ 	unsigned int		rep_inline_recv;	/* negotiated */
++>>>>>>> 86c4ccd9b92b (xprtrdma: Eliminate struct rpcrdma_create_data_internal)
  	int			rep_receive_count;
  };
  
@@@ -412,18 -415,6 +418,21 @@@ enum 
  };
  
  /*
++<<<<<<< HEAD
 + * Internal structure for transport instance creation. This
 + * exists primarily for modularity.
 + *
 + * This data should be set with mount options
 + */
 +struct rpcrdma_create_data_internal {
 +	unsigned int	max_requests;	/* max requests (slots) in flight */
 +	unsigned int	inline_rsize;	/* max non-rdma read data payload */
 +	unsigned int	inline_wsize;	/* max non-rdma write data payload */
 +};
 +
 +/*
++=======
++>>>>>>> 86c4ccd9b92b (xprtrdma: Eliminate struct rpcrdma_create_data_internal)
   * Statistics for RPCRDMA
   */
  struct rpcrdma_stats {
@@@ -630,7 -617,9 +635,8 @@@ static inline void rpcrdma_set_xdrlen(s
  
  /* RPC/RDMA module init - xprtrdma/transport.c
   */
+ extern unsigned int xprt_rdma_slot_table_entries;
  extern unsigned int xprt_rdma_max_inline_read;
 -extern unsigned int xprt_rdma_max_inline_write;
  void xprt_rdma_format_addresses(struct rpc_xprt *xprt, struct sockaddr *sap);
  void xprt_rdma_free_addresses(struct rpc_xprt *xprt);
  void xprt_rdma_close(struct rpc_xprt *xprt);
diff --git a/net/sunrpc/xprtrdma/frwr_ops.c b/net/sunrpc/xprtrdma/frwr_ops.c
index 7cd27184ecd1..1d369b65e845 100644
--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@ -194,12 +194,11 @@ int frwr_init_mr(struct rpcrdma_ia *ia, struct rpcrdma_mr *mr)
  * frwr_open - Prepare an endpoint for use with FRWR
  * @ia: interface adapter this endpoint will use
  * @ep: endpoint to prepare
- * @cdata: transport parameters
  *
  * On success, sets:
  *	ep->rep_attr.cap.max_send_wr
  *	ep->rep_attr.cap.max_recv_wr
- *	cdata->max_requests
+ *	ep->rep_max_requests
  *	ia->ri_max_segs
  *
  * And these FRWR-related fields:
@@ -208,8 +207,7 @@ int frwr_init_mr(struct rpcrdma_ia *ia, struct rpcrdma_mr *mr)
  *
  * On failure, a negative errno is returned.
  */
-int frwr_open(struct rpcrdma_ia *ia, struct rpcrdma_ep *ep,
-	      struct rpcrdma_create_data_internal *cdata)
+int frwr_open(struct rpcrdma_ia *ia, struct rpcrdma_ep *ep)
 {
 	struct ib_device_attr *attrs = &ia->ri_id->device->attrs;
 	int max_qp_wr, depth, delta;
@@ -258,19 +256,18 @@ int frwr_open(struct rpcrdma_ia *ia, struct rpcrdma_ep *ep,
 	max_qp_wr -= 1;
 	if (max_qp_wr < RPCRDMA_MIN_SLOT_TABLE)
 		return -ENOMEM;
-	if (cdata->max_requests > max_qp_wr)
-		cdata->max_requests = max_qp_wr;
-	ep->rep_attr.cap.max_send_wr = cdata->max_requests * depth;
+	if (ep->rep_max_requests > max_qp_wr)
+		ep->rep_max_requests = max_qp_wr;
+	ep->rep_attr.cap.max_send_wr = ep->rep_max_requests * depth;
 	if (ep->rep_attr.cap.max_send_wr > max_qp_wr) {
-		cdata->max_requests = max_qp_wr / depth;
-		if (!cdata->max_requests)
+		ep->rep_max_requests = max_qp_wr / depth;
+		if (!ep->rep_max_requests)
 			return -EINVAL;
-		ep->rep_attr.cap.max_send_wr = cdata->max_requests *
-					       depth;
+		ep->rep_attr.cap.max_send_wr = ep->rep_max_requests * depth;
 	}
 	ep->rep_attr.cap.max_send_wr += RPCRDMA_BACKWARD_WRS;
 	ep->rep_attr.cap.max_send_wr += 1; /* for ib_drain_sq */
-	ep->rep_attr.cap.max_recv_wr = cdata->max_requests;
+	ep->rep_attr.cap.max_recv_wr = ep->rep_max_requests;
 	ep->rep_attr.cap.max_recv_wr += RPCRDMA_BACKWARD_WRS;
 	ep->rep_attr.cap.max_recv_wr += 1; /* for ib_drain_rq */
 
* Unmerged path net/sunrpc/xprtrdma/transport.c
* Unmerged path net/sunrpc/xprtrdma/verbs.c
* Unmerged path net/sunrpc/xprtrdma/xprt_rdma.h
