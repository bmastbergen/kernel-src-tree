kvm: selftests: introduce aarch64_vcpu_add_default

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrew Jones <drjones@redhat.com>
commit fb89f4ea7feb1e605f8f405d256c56d8ad69125c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/fb89f4ea.failed

This is the same as vm_vcpu_add_default, but it also takes a
kvm_vcpu_init struct pointer.

	Signed-off-by: Andrew Jones <drjones@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fb89f4ea7feb1e605f8f405d256c56d8ad69125c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/include/aarch64/processor.h
#	tools/testing/selftests/kvm/lib/aarch64/processor.c
diff --cc tools/testing/selftests/kvm/include/aarch64/processor.h
index 9ef2ab1a0c08,b7fa0c8551db..000000000000
--- a/tools/testing/selftests/kvm/include/aarch64/processor.h
+++ b/tools/testing/selftests/kvm/include/aarch64/processor.h
@@@ -52,4 -52,8 +52,11 @@@ static inline void set_reg(struct kvm_v
  	vcpu_ioctl(vm, vcpuid, KVM_SET_ONE_REG, &reg);
  }
  
++<<<<<<< HEAD
++=======
+ void aarch64_vcpu_setup(struct kvm_vm *vm, int vcpuid, struct kvm_vcpu_init *init);
+ void aarch64_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid,
+ 			      struct kvm_vcpu_init *init, void *guest_code);
+ 
++>>>>>>> fb89f4ea7feb (kvm: selftests: introduce aarch64_vcpu_add_default)
  #endif /* SELFTEST_KVM_PROCESSOR_H */
diff --cc tools/testing/selftests/kvm/lib/aarch64/processor.c
index c278e2f68b10,af2023d818a5..000000000000
--- a/tools/testing/selftests/kvm/lib/aarch64/processor.c
+++ b/tools/testing/selftests/kvm/lib/aarch64/processor.c
@@@ -316,3 -309,24 +316,27 @@@ void vcpu_dump(FILE *stream, struct kvm
  	fprintf(stream, "%*spstate: 0x%.16lx pc: 0x%.16lx\n",
  		indent, "", pstate, pc);
  }
++<<<<<<< HEAD
++=======
+ 
+ void aarch64_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid,
+ 			      struct kvm_vcpu_init *init, void *guest_code)
+ {
+ 	size_t stack_size = vm->page_size == 4096 ?
+ 					DEFAULT_STACK_PGS * vm->page_size :
+ 					vm->page_size;
+ 	uint64_t stack_vaddr = vm_vaddr_alloc(vm, stack_size,
+ 					DEFAULT_ARM64_GUEST_STACK_VADDR_MIN, 0, 0);
+ 
+ 	vm_vcpu_add(vm, vcpuid);
+ 	aarch64_vcpu_setup(vm, vcpuid, init);
+ 
+ 	set_reg(vm, vcpuid, ARM64_CORE_REG(sp_el1), stack_vaddr + stack_size);
+ 	set_reg(vm, vcpuid, ARM64_CORE_REG(regs.pc), (uint64_t)guest_code);
+ }
+ 
+ void vm_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid, void *guest_code)
+ {
+ 	aarch64_vcpu_add_default(vm, vcpuid, NULL, guest_code);
+ }
++>>>>>>> fb89f4ea7feb (kvm: selftests: introduce aarch64_vcpu_add_default)
* Unmerged path tools/testing/selftests/kvm/include/aarch64/processor.h
* Unmerged path tools/testing/selftests/kvm/lib/aarch64/processor.c
