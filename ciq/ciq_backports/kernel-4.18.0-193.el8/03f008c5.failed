crypto: ccp - Verify access to device registers before initializing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Hook, Gary <Gary.Hook@amd.com>
commit 03f008c52b76114b83483de2cf15ed36fc34930c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/03f008c5.failed

Check early whether device registers can be accessed. Some BIOSes have
a broken security policy that prevents access to the device registers,
and return values from ioread() can be misinterpreted. If a read of
a feature register returns a -1, we may not be able to access
any device register, so report the problem and suggestion, and return.

For the PSP, the feature register is checked. For the CCP, the queue
register is checked.

	Signed-off-by: Gary R Hook <gary.hook@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 03f008c52b76114b83483de2cf15ed36fc34930c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-dev-v5.c
diff --cc drivers/crypto/ccp/ccp-dev-v5.c
index c7d9e33dfe55,82ac4c14c04c..000000000000
--- a/drivers/crypto/ccp/ccp-dev-v5.c
+++ b/drivers/crypto/ccp/ccp-dev-v5.c
@@@ -792,8 -789,19 +792,24 @@@ static int ccp5_init(struct ccp_device 
  
  	/* Find available queues */
  	qmr = ioread32(ccp->io_regs + Q_MASK_REG);
++<<<<<<< HEAD
 +	for (i = 0; i < MAX_HW_QUEUES; i++) {
 +
++=======
+ 	/*
+ 	 * Check for a access to the registers.  If this read returns
+ 	 * 0xffffffff, it's likely that the system is running a broken
+ 	 * BIOS which disallows access to the device. Stop here and fail
+ 	 * the initialization (but not the load, as the PSP could get
+ 	 * properly initialized).
+ 	 */
+ 	if (qmr == 0xffffffff) {
+ 		dev_notice(dev, "ccp: unable to access the device: you might be running a broken BIOS.\n");
+ 		return 1;
+ 	}
+ 
+ 	for (i = 0; (i < MAX_HW_QUEUES) && (ccp->cmd_q_count < ccp->max_q_count); i++) {
++>>>>>>> 03f008c52b76 (crypto: ccp - Verify access to device registers before initializing)
  		if (!(qmr & (1 << i)))
  			continue;
  
* Unmerged path drivers/crypto/ccp/ccp-dev-v5.c
diff --git a/drivers/crypto/ccp/psp-dev.c b/drivers/crypto/ccp/psp-dev.c
index 1b19ab2e0b37..02c4be197605 100644
--- a/drivers/crypto/ccp/psp-dev.c
+++ b/drivers/crypto/ccp/psp-dev.c
@@ -938,8 +938,22 @@ static int sev_misc_init(struct psp_device *psp)
 
 static int psp_check_sev_support(struct psp_device *psp)
 {
-	/* Check if device supports SEV feature */
-	if (!(ioread32(psp->io_regs + psp->vdata->feature_reg) & 1)) {
+	unsigned int val = ioread32(psp->io_regs + psp->vdata->feature_reg);
+
+	/*
+	 * Check for a access to the registers.  If this read returns
+	 * 0xffffffff, it's likely that the system is running a broken
+	 * BIOS which disallows access to the device. Stop here and
+	 * fail the PSP initialization (but not the load, as the CCP
+	 * could get properly initialized).
+	 */
+	if (val == 0xffffffff) {
+		dev_notice(psp->dev, "psp: unable to access the device: you might be running a broken BIOS.\n");
+		return -ENODEV;
+	}
+
+	if (!(val & 1)) {
+		/* Device does not support the SEV feature */
 		dev_dbg(psp->dev, "psp does not support SEV\n");
 		return -ENODEV;
 	}
