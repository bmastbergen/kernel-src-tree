fuse: export fuse_end_request()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stefan Hajnoczi <stefanha@redhat.com>
commit 04ec5af0776e9baefed59891f12adbcb5fa71a23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/04ec5af0.failed

virtio-fs will need to complete requests from outside fs/fuse/dev.c.  Make
the symbol visible.

	Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 04ec5af0776e9baefed59891f12adbcb5fa71a23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/fuse_i.h
diff --cc fs/fuse/fuse_i.h
index ca17b390a697,5c50d3da1b0d..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -861,10 -830,9 +861,16 @@@ int fuse_simple_background(struct fuse_
  			   gfp_t gfp_flags);
  
  /**
++<<<<<<< HEAD
 + * Send a request in the background
 + */
 +void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 +bool fuse_request_queue_background(struct fuse_conn *fc, struct fuse_req *req);
++=======
+  * End a finished request
+  */
+ void fuse_request_end(struct fuse_conn *fc, struct fuse_req *req);
++>>>>>>> 04ec5af0776e (fuse: export fuse_end_request())
  
  /* Abort all requests */
  void fuse_abort_conn(struct fuse_conn *fc);
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index db57d925ee92..4e25422a5247 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -333,7 +333,7 @@ static void flush_bg_queue(struct fuse_conn *fc)
  * the 'end' callback is called if given, else the reference to the
  * request is released
  */
-static void request_end(struct fuse_conn *fc, struct fuse_req *req)
+void fuse_request_end(struct fuse_conn *fc, struct fuse_req *req)
 {
 	struct fuse_iqueue *fiq = &fc->iq;
 	bool async = req->args->end;
@@ -387,6 +387,7 @@ static void request_end(struct fuse_conn *fc, struct fuse_req *req)
 put_request:
 	fuse_put_request(fc, req);
 }
+EXPORT_SYMBOL_GPL(fuse_request_end);
 
 static int queue_interrupt(struct fuse_iqueue *fiq, struct fuse_req *req)
 {
@@ -474,12 +475,12 @@ static void __fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)
 		req->in.h.unique = fuse_get_unique(fiq);
 		queue_request(fiq, req);
 		/* acquire extra reference, since request is still needed
-		   after request_end() */
+		   after fuse_request_end() */
 		__fuse_get_request(req);
 		spin_unlock(&fiq->lock);
 
 		request_wait_answer(fc, req);
-		/* Pairs with smp_wmb() in request_end() */
+		/* Pairs with smp_wmb() in fuse_request_end() */
 		smp_rmb();
 	}
 }
@@ -1250,7 +1251,7 @@ __releases(fiq->lock)
  * the pending list and copies request data to userspace buffer.  If
  * no reply is needed (FORGET) or request has been aborted or there
  * was an error during the copying then it's finished by calling
- * request_end().  Otherwise add it to the processing list, and set
+ * fuse_request_end().  Otherwise add it to the processing list, and set
  * the 'sent' flag.
  */
 static ssize_t fuse_dev_do_read(struct fuse_dev *fud, struct file *file,
@@ -1331,7 +1332,7 @@ static ssize_t fuse_dev_do_read(struct fuse_dev *fud, struct file *file,
 		/* SETXATTR is special, since it may contain too large data */
 		if (args->opcode == FUSE_SETXATTR)
 			req->out.h.error = -E2BIG;
-		request_end(fc, req);
+		fuse_request_end(fc, req);
 		goto restart;
 	}
 	spin_lock(&fpq->lock);
@@ -1374,7 +1375,7 @@ static ssize_t fuse_dev_do_read(struct fuse_dev *fud, struct file *file,
 	if (!test_bit(FR_PRIVATE, &req->flags))
 		list_del_init(&req->list);
 	spin_unlock(&fpq->lock);
-	request_end(fc, req);
+	fuse_request_end(fc, req);
 	return err;
 
  err_unlock:
@@ -1898,7 +1899,7 @@ static int copy_out_args(struct fuse_copy_state *cs, struct fuse_args *args,
  * the write buffer.  The request is then searched on the processing
  * list by the unique ID found in the header.  If found, then remove
  * it from the list and copy the rest of the buffer to the request.
- * The request is finished by calling request_end()
+ * The request is finished by calling fuse_request_end().
  */
 static ssize_t fuse_dev_do_write(struct fuse_dev *fud,
 				 struct fuse_copy_state *cs, size_t nbytes)
@@ -1988,7 +1989,7 @@ static ssize_t fuse_dev_do_write(struct fuse_dev *fud,
 		list_del_init(&req->list);
 	spin_unlock(&fpq->lock);
 
-	request_end(fc, req);
+	fuse_request_end(fc, req);
 out:
 	return err ? err : nbytes;
 
@@ -2128,7 +2129,7 @@ static void end_requests(struct fuse_conn *fc, struct list_head *head)
 		req->out.h.error = -ECONNABORTED;
 		clear_bit(FR_SENT, &req->flags);
 		list_del_init(&req->list);
-		request_end(fc, req);
+		fuse_request_end(fc, req);
 	}
 }
 
* Unmerged path fs/fuse/fuse_i.h
