net_sched: sch_fq: properly set sk->sk_pacing_status

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Eric Dumazet <edumazet@google.com>
commit bb3d0b8bf5be61ab1d6f472c43cbf34de17e796b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/bb3d0b8b.failed

If fq_classify() recycles a struct fq_flow because
a socket structure has been reallocated, we do not
set sk->sk_pacing_status immediately, but later if the
flow becomes detached.

This means that any flow requiring pacing (BBR, or SO_MAX_PACING_RATE)
might fallback to TCP internal pacing, which requires a per-socket
high resolution timer, and therefore more cpu cycles.

Fixes: 218af599fa63 ("tcp: internal implementation for pacing")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Soheil Hassas Yeganeh <soheil@google.com>
	Cc: Neal Cardwell <ncardwell@google.com>
	Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bb3d0b8bf5be61ab1d6f472c43cbf34de17e796b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_fq.c
diff --cc net/sched/sch_fq.c
index b27ba36a269c,ff4c5e9d0d77..000000000000
--- a/net/sched/sch_fq.c
+++ b/net/sched/sch_fq.c
@@@ -297,10 -321,16 +300,18 @@@ static struct fq_flow *fq_classify(stru
  		q->stat_allocation_errors++;
  		return &q->internal;
  	}
 -	/* f->t_root is already zeroed after kmem_cache_zalloc() */
 -
  	fq_flow_set_detached(f);
  	f->sk = sk;
++<<<<<<< HEAD
 +	if (skb->sk)
++=======
+ 	if (skb->sk == sk) {
++>>>>>>> bb3d0b8bf5be (net_sched: sch_fq: properly set sk->sk_pacing_status)
  		f->socket_hash = sk->sk_hash;
+ 		if (q->rate_enable)
+ 			smp_store_release(&sk->sk_pacing_status,
+ 					  SK_PACING_FQ);
+ 	}
  	f->credit = q->initial_quantum;
  
  	rb_link_node(&f->fq_node, parent, p);
@@@ -401,12 -433,8 +412,10 @@@ static int fq_enqueue(struct sk_buff *s
  	}
  
  	f->qlen++;
 +	if (skb_is_retransmit(skb))
 +		q->stat_tcp_retrans++;
  	qdisc_qstats_backlog_inc(sch, skb);
  	if (fq_flow_is_detached(f)) {
- 		struct sock *sk = skb->sk;
- 
  		fq_flow_add_tail(&q->new_flows, f);
  		if (time_after(jiffies, f->age + q->flow_refill_delay))
  			f->credit = max_t(u32, f->credit, q->quantum);
* Unmerged path net/sched/sch_fq.c
