PCI/PM: Remove unused pci_driver.suspend_late() hook

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 1a1daf097e21e544dd3e7c0ff620d78a9795fbf2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/1a1daf09.failed

The struct pci_driver.suspend_late() hook is one of the legacy PCI power
management callbacks, and there are no remaining users of it.  Remove it.

Link: https://lore.kernel.org/r/20191101204558.210235-7-helgaas@kernel.org
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1a1daf097e21e544dd3e7c0ff620d78a9795fbf2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/power/pci.txt
#	drivers/pci/pci-driver.c
#	include/linux/pci.h
diff --cc Documentation/power/pci.txt
index 8eaf9ee24d43,0924d29636ad..000000000000
--- a/Documentation/power/pci.txt
+++ b/Documentation/power/pci.txt
@@@ -677,12 -691,12 +677,21 @@@ controlling the runtime power managemen
  
  At the time of this writing there are two ways to define power management
  callbacks for a PCI device driver, the recommended one, based on using a
++<<<<<<< HEAD:Documentation/power/pci.txt
 +dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and the
 +"legacy" one, in which the .suspend(), .suspend_late(), .resume_early(), and
 +.resume() callbacks from struct pci_driver are used.  The legacy approach,
 +however, doesn't allow one to define runtime power management callbacks and is
 +not really suitable for any new drivers.  Therefore it is not covered by this
 +document (refer to the source code to learn more about it).
++=======
+ dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and
+ the "legacy" one, in which the .suspend() and .resume() callbacks from struct
+ pci_driver are used.  The legacy approach, however, doesn't allow one to define
+ runtime power management callbacks and is not really suitable for any new
+ drivers.  Therefore it is not covered by this document (refer to the source code
+ to learn more about it).
++>>>>>>> 1a1daf097e21 (PCI/PM: Remove unused pci_driver.suspend_late() hook):Documentation/power/pci.rst
  
  It is recommended that all PCI device drivers define a struct dev_pm_ops object
  containing pointers to power management (PM) callbacks that will be executed by
diff --cc drivers/pci/pci-driver.c
index e6614ab5ceca,e89fd90eaa93..000000000000
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@@ -628,25 -599,6 +628,28 @@@ static int pci_legacy_suspend(struct de
  static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
  {
  	struct pci_dev *pci_dev = to_pci_dev(dev);
++<<<<<<< HEAD
 +	struct pci_driver *drv = pci_dev->driver;
 +
 +	if (drv && drv->suspend_late) {
 +		pci_power_t prev = pci_dev->current_state;
 +		int error;
 +
 +		error = drv->suspend_late(pci_dev, state);
 +		suspend_report_result(drv->suspend_late, error);
 +		if (error)
 +			return error;
 +
 +		if (!pci_dev->state_saved && pci_dev->current_state != PCI_D0
 +		    && pci_dev->current_state != PCI_UNKNOWN) {
 +			WARN_ONCE(pci_dev->current_state != prev,
 +				"PCI PM: Device state not saved by %pF\n",
 +				drv->suspend_late);
 +			goto Fixup;
 +		}
 +	}
++=======
++>>>>>>> 1a1daf097e21 (PCI/PM: Remove unused pci_driver.suspend_late() hook)
  
  	if (!pci_dev->state_saved)
  		pci_save_state(pci_dev);
@@@ -691,8 -633,7 +693,12 @@@ static void pci_pm_default_suspend(stru
  static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
  {
  	struct pci_driver *drv = pci_dev->driver;
++<<<<<<< HEAD
 +	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume
 +		|| drv->resume_early);
++=======
+ 	bool ret = drv && (drv->suspend || drv->resume);
++>>>>>>> 1a1daf097e21 (PCI/PM: Remove unused pci_driver.suspend_late() hook)
  
  	/*
  	 * Legacy PM support is used by default, so warn if the new framework is
diff --cc include/linux/pci.h
index 906f59ad2896,9b0e35e09874..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -808,6 -778,48 +808,51 @@@ struct pci_error_handlers 
  
  
  struct module;
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * struct pci_driver - PCI driver structure
+  * @node:	List of driver structures.
+  * @name:	Driver name.
+  * @id_table:	Pointer to table of device IDs the driver is
+  *		interested in.  Most drivers should export this
+  *		table using MODULE_DEVICE_TABLE(pci,...).
+  * @probe:	This probing function gets called (during execution
+  *		of pci_register_driver() for already existing
+  *		devices or later if a new device gets inserted) for
+  *		all PCI devices which match the ID table and are not
+  *		"owned" by the other drivers yet. This function gets
+  *		passed a "struct pci_dev \*" for each device whose
+  *		entry in the ID table matches the device. The probe
+  *		function returns zero when the driver chooses to
+  *		take "ownership" of the device or an error code
+  *		(negative number) otherwise.
+  *		The probe function always gets called from process
+  *		context, so it can sleep.
+  * @remove:	The remove() function gets called whenever a device
+  *		being handled by this driver is removed (either during
+  *		deregistration of the driver or when it's manually
+  *		pulled out of a hot-pluggable slot).
+  *		The remove function always gets called from process
+  *		context, so it can sleep.
+  * @suspend:	Put device into low power state.
+  * @resume:	Wake device from low power state.
+  *		(Please see Documentation/power/pci.rst for descriptions
+  *		of PCI Power Management and the related functions.)
+  * @shutdown:	Hook into reboot_notifier_list (kernel/sys.c).
+  *		Intended to stop any idling DMA operations.
+  *		Useful for enabling wake-on-lan (NIC) or changing
+  *		the power state of a device before reboot.
+  *		e.g. drivers/net/e100.c.
+  * @sriov_configure: Optional driver callback to allow configuration of
+  *		number of VFs to enable via sysfs "sriov_numvfs" file.
+  * @err_handler: See Documentation/PCI/pci-error-recovery.rst
+  * @groups:	Sysfs attribute groups.
+  * @driver:	Driver model structure.
+  * @dynids:	List of dynamically added device IDs.
+  */
++>>>>>>> 1a1daf097e21 (PCI/PM: Remove unused pci_driver.suspend_late() hook)
  struct pci_driver {
  	struct list_head	node;
  	const char		*name;
@@@ -815,8 -827,6 +860,11 @@@
  	int  (*probe)(struct pci_dev *dev, const struct pci_device_id *id);	/* New device inserted */
  	void (*remove)(struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug capable driver) */
  	int  (*suspend)(struct pci_dev *dev, pm_message_t state);	/* Device suspended */
++<<<<<<< HEAD
 +	int  (*suspend_late)(struct pci_dev *dev, pm_message_t state);
 +	int  (*resume_early)(struct pci_dev *dev);
++=======
++>>>>>>> 1a1daf097e21 (PCI/PM: Remove unused pci_driver.suspend_late() hook)
  	int  (*resume)(struct pci_dev *dev);	/* Device woken up */
  	void (*shutdown)(struct pci_dev *dev);
  	int  (*sriov_configure)(struct pci_dev *dev, int num_vfs); /* On PF */
* Unmerged path Documentation/power/pci.txt
* Unmerged path drivers/pci/pci-driver.c
* Unmerged path include/linux/pci.h
