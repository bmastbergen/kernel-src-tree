mm: remove the struct hmm_device infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] remove the struct hmm_device infrastructure (Jerome Glisse) [1498655 1597758]
Rebuild_FUZZ: 95.56%
commit-author Christoph Hellwig <hch@lst.de>
commit 07ec38917e68f0114b9c8aeeb1c584b5e73e4dd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/07ec3891.failed

This code is a trivial wrapper around device model helpers, which
should have been integrated into the driver device model usage from
the start.  Assuming it actually had users, which it never had since
the code was added more than 1 1/2 years ago.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: John Hubbard <jhubbard@nvidia.com>
	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 07ec38917e68f0114b9c8aeeb1c584b5e73e4dd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hmm.c
diff --cc mm/hmm.c
index 2387f409704a,00cc642b3d7e..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -1149,85 -1527,5 +1149,89 @@@ struct hmm_devmem *hmm_devmem_add_resou
  		return result;
  	return devmem;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(hmm_devmem_add_resource);
 +
 +/*
 + * A device driver that wants to handle multiple devices memory through a
 + * single fake device can use hmm_device to do so. This is purely a helper
 + * and it is not needed to make use of any HMM functionality.
 + */
 +#define HMM_DEVICE_MAX 256
 +
 +static DECLARE_BITMAP(hmm_device_mask, HMM_DEVICE_MAX);
 +static DEFINE_SPINLOCK(hmm_device_lock);
 +static struct class *hmm_device_class;
 +static dev_t hmm_device_devt;
 +
 +static void hmm_device_release(struct device *device)
 +{
 +	struct hmm_device *hmm_device;
 +
 +	hmm_device = container_of(device, struct hmm_device, device);
 +	spin_lock(&hmm_device_lock);
 +	clear_bit(hmm_device->minor, hmm_device_mask);
 +	spin_unlock(&hmm_device_lock);
 +
 +	kfree(hmm_device);
 +}
 +
 +struct hmm_device *hmm_device_new(void *drvdata)
 +{
 +	struct hmm_device *hmm_device;
 +
 +	hmm_device = kzalloc(sizeof(*hmm_device), GFP_KERNEL);
 +	if (!hmm_device)
 +		return ERR_PTR(-ENOMEM);
 +
 +	spin_lock(&hmm_device_lock);
 +	hmm_device->minor = find_first_zero_bit(hmm_device_mask, HMM_DEVICE_MAX);
 +	if (hmm_device->minor >= HMM_DEVICE_MAX) {
 +		spin_unlock(&hmm_device_lock);
 +		kfree(hmm_device);
 +		return ERR_PTR(-EBUSY);
 +	}
 +	set_bit(hmm_device->minor, hmm_device_mask);
 +	spin_unlock(&hmm_device_lock);
 +
 +	dev_set_name(&hmm_device->device, "hmm_device%d", hmm_device->minor);
 +	hmm_device->device.devt = MKDEV(MAJOR(hmm_device_devt),
 +					hmm_device->minor);
 +	hmm_device->device.release = hmm_device_release;
 +	dev_set_drvdata(&hmm_device->device, drvdata);
 +	hmm_device->device.class = hmm_device_class;
 +	device_initialize(&hmm_device->device);
 +
 +	return hmm_device;
 +}
 +EXPORT_SYMBOL(hmm_device_new);
 +
 +void hmm_device_put(struct hmm_device *hmm_device)
 +{
 +	put_device(&hmm_device->device);
 +}
 +EXPORT_SYMBOL(hmm_device_put);
 +
 +static int __init hmm_init(void)
 +{
 +	int ret;
 +
 +	ret = alloc_chrdev_region(&hmm_device_devt, 0,
 +				  HMM_DEVICE_MAX,
 +				  "hmm_device");
 +	if (ret)
 +		return ret;
 +
 +	hmm_device_class = class_create(THIS_MODULE, "hmm_device");
 +	if (IS_ERR(hmm_device_class)) {
 +		unregister_chrdev_region(hmm_device_devt, HMM_DEVICE_MAX);
 +		return PTR_ERR(hmm_device_class);
 +	}
 +	return 0;
 +}
 +
 +device_initcall(hmm_init);
++=======
+ EXPORT_SYMBOL_GPL(hmm_devmem_add_resource);
++>>>>>>> 07ec38917e68 (mm: remove the struct hmm_device infrastructure)
  #endif /* CONFIG_DEVICE_PRIVATE || CONFIG_DEVICE_PUBLIC */
diff --git a/include/linux/hmm.h b/include/linux/hmm.h
index 2f68a486cc0d..43aca82efa31 100644
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@ -570,26 +570,6 @@ static inline unsigned long hmm_devmem_page_get_drvdata(const struct page *page)
 {
 	return page->hmm_data;
 }
-
-
-/*
- * struct hmm_device - fake device to hang device memory onto
- *
- * @device: device struct
- * @minor: device minor number
- */
-struct hmm_device {
-	struct device		device;
-	unsigned int		minor;
-};
-
-/*
- * A device driver that wants to handle multiple devices memory through a
- * single fake device can use hmm_device to do so. This is purely a helper and
- * it is not strictly needed, in order to make use of any HMM functionality.
- */
-struct hmm_device *hmm_device_new(void *drvdata);
-void hmm_device_put(struct hmm_device *hmm_device);
 #endif /* CONFIG_DEVICE_PRIVATE || CONFIG_DEVICE_PUBLIC */
 #else /* IS_ENABLED(CONFIG_HMM) */
 static inline void hmm_mm_destroy(struct mm_struct *mm) {}
* Unmerged path mm/hmm.c
