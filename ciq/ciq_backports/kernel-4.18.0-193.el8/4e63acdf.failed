bpf: Introduce bpf_sysctl_{get,set}_new_value helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [kernel] bpf: Introduce bpf_sysctl_{get, set}_new_value helpers (Yauheni Kaliuta) [1747615]
Rebuild_FUZZ: 99.07%
commit-author Andrey Ignatov <rdna@fb.com>
commit 4e63acdff864654cee0ac5aaeda3913798ee78f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4e63acdf.failed

Add helpers to work with new value being written to sysctl by user
space.

bpf_sysctl_get_new_value() copies value being written to sysctl into
provided buffer.

bpf_sysctl_set_new_value() overrides new value being written by user
space with a one from provided buffer. Buffer should contain string
representation of the value, similar to what can be seen in /proc/sys/.

Both helpers can be used only on sysctl write.

File position matters and can be managed by an interface that will be
introduced separately. E.g. if user space calls sys_write to a file in
/proc/sys/ at file position = X, where X > 0, then the value set by
bpf_sysctl_set_new_value() will be written starting from X. If program
wants to override whole value with specified buffer, file position has
to be set to zero.

Documentation for the new helpers is provided in bpf.h UAPI.

	Signed-off-by: Andrey Ignatov <rdna@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 4e63acdff864654cee0ac5aaeda3913798ee78f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/proc_sysctl.c
#	include/linux/bpf-cgroup.h
#	include/linux/filter.h
#	include/uapi/linux/bpf.h
#	kernel/bpf/cgroup.c
diff --cc fs/proc/proc_sysctl.c
index 89921a0d2ebb,023101c6f0d7..000000000000
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@@ -589,11 -589,27 +589,30 @@@ static ssize_t proc_sys_call_handler(st
  	if (!table->proc_handler)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	error = BPF_CGROUP_RUN_PROG_SYSCTL(head, table, write, buf, &count,
+ 					   &new_buf);
+ 	if (error)
+ 		goto out;
+ 
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
  	/* careful: calling conventions are nasty here */
- 	res = count;
- 	error = table->proc_handler(table, write, buf, &res, ppos);
+ 	if (new_buf) {
+ 		mm_segment_t old_fs;
+ 
+ 		old_fs = get_fs();
+ 		set_fs(KERNEL_DS);
+ 		error = table->proc_handler(table, write, (void __user *)new_buf,
+ 					    &count, ppos);
+ 		set_fs(old_fs);
+ 		kfree(new_buf);
+ 	} else {
+ 		error = table->proc_handler(table, write, buf, &count, ppos);
+ 	}
+ 
  	if (!error)
- 		error = res;
+ 		error = count;
  out:
  	sysctl_head_finish(head);
  
diff --cc include/linux/bpf-cgroup.h
index 14647819f7e6,1e97271f9a10..000000000000
--- a/include/linux/bpf-cgroup.h
+++ b/include/linux/bpf-cgroup.h
@@@ -150,6 -111,11 +150,14 @@@ int __cgroup_bpf_run_filter_sock_ops(st
  int __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,
  				      short access, enum bpf_attach_type type);
  
++<<<<<<< HEAD
++=======
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   void __user *buf, size_t *pcount,
+ 				   void **new_buf, enum bpf_attach_type type);
+ 
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
  static inline enum bpf_cgroup_storage_type cgroup_storage_type(
  	struct bpf_map *map)
  {
@@@ -294,6 -260,18 +302,21 @@@ int bpf_percpu_cgroup_storage_update(st
  									      \
  	__ret;								      \
  })
++<<<<<<< HEAD
++=======
+ 
+ 
+ #define BPF_CGROUP_RUN_PROG_SYSCTL(head, table, write, buf, count, nbuf)       \
+ ({									       \
+ 	int __ret = 0;							       \
+ 	if (cgroup_bpf_enabled)						       \
+ 		__ret = __cgroup_bpf_run_filter_sysctl(head, table, write,     \
+ 						       buf, count, nbuf,       \
+ 						       BPF_CGROUP_SYSCTL);     \
+ 	__ret;								       \
+ })
+ 
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
  int cgroup_bpf_prog_attach(const union bpf_attr *attr,
  			   enum bpf_prog_type ptype, struct bpf_prog *prog);
  int cgroup_bpf_prog_detach(const union bpf_attr *attr,
@@@ -362,6 -340,7 +385,10 @@@ static inline int bpf_percpu_cgroup_sto
  #define BPF_CGROUP_RUN_PROG_UDP6_SENDMSG_LOCK(sk, uaddr, t_ctx) ({ 0; })
  #define BPF_CGROUP_RUN_PROG_SOCK_OPS(sock_ops) ({ 0; })
  #define BPF_CGROUP_RUN_PROG_DEVICE_CGROUP(type,major,minor,access) ({ 0; })
++<<<<<<< HEAD
++=======
+ #define BPF_CGROUP_RUN_PROG_SYSCTL(head,table,write,buf,count,nbuf) ({ 0; })
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
  
  #define for_each_cgroup_storage_type(stype) for (; false; )
  
diff --cc include/linux/filter.h
index f32b3eca5a04,a23653f9460c..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -1152,4 -1179,15 +1152,18 @@@ struct bpf_sock_ops_kern 
  					 */
  };
  
++<<<<<<< HEAD
++=======
+ struct bpf_sysctl_kern {
+ 	struct ctl_table_header *head;
+ 	struct ctl_table *table;
+ 	void *cur_val;
+ 	size_t cur_len;
+ 	void *new_val;
+ 	size_t new_len;
+ 	int new_updated;
+ 	int write;
+ };
+ 
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
  #endif /* __LINUX_FILTER_H__ */
diff --cc include/uapi/linux/bpf.h
index 6d4bc9ebe78a,547b8258d731..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2463,11 -2469,112 +2463,115 @@@ union bpf_attr 
   *
   * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
   *	Description
 - *		Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
 - *		**bpf_sk_release**\ () is unnecessary and not allowed.
 + *		Return a **struct bpf_sock** pointer in TCP_LISTEN state.
 + *		bpf_sk_release() is unnecessary and not allowed.
   *	Return
 - *		A **struct bpf_sock** pointer on success, or **NULL** in
 + *		A **struct bpf_sock** pointer on success, or NULL in
   *		case of failure.
++<<<<<<< HEAD
++=======
+  *
+  * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		This function is identical to bpf_sk_lookup_tcp, except that it
+  *		also returns timewait or request sockets. Use bpf_sk_fullsock
+  *		or bpf_tcp_socket to access the full structure.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * int bpf_tcp_check_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  * 	Description
+  * 		Check whether iph and th contain a valid SYN cookie ACK for
+  * 		the listening socket in sk.
+  *
+  * 		iph points to the start of the IPv4 or IPv6 header, while
+  * 		iph_len contains sizeof(struct iphdr) or sizeof(struct ip6hdr).
+  *
+  * 		th points to the start of the TCP header, while th_len contains
+  * 		sizeof(struct tcphdr).
+  *
+  * 	Return
+  * 		0 if iph and th are a valid SYN cookie ACK, or a negative error
+  * 		otherwise.
+  *
+  * int bpf_sysctl_get_name(struct bpf_sysctl *ctx, char *buf, size_t buf_len, u64 flags)
+  *	Description
+  *		Get name of sysctl in /proc/sys/ and copy it into provided by
+  *		program buffer *buf* of size *buf_len*.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *
+  *		If *flags* is zero, full name (e.g. "net/ipv4/tcp_mem") is
+  *		copied. Use **BPF_F_SYSCTL_BASE_NAME** flag to copy base name
+  *		only (e.g. "tcp_mem").
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  * int bpf_sysctl_get_current_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get current value of sysctl as it is presented in /proc/sys
+  *		(incl. newline, etc), and copy it as a string into provided
+  *		by program buffer *buf* of size *buf_len*.
+  *
+  *		The whole value is copied, no matter what file position user
+  *		space issued e.g. sys_read at.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if current value was unavailable, e.g. because
+  *		sysctl is uninitialized and read returns -EIO for it.
+  *
+  * int bpf_sysctl_get_new_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get new value being written by user space to sysctl (before
+  *		the actual write happens) and copy it as a string into
+  *		provided by program buffer *buf* of size *buf_len*.
+  *
+  *		User space may write new value at file position > 0.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_sysctl_set_new_value(struct bpf_sysctl *ctx, const char *buf, size_t buf_len)
+  *	Description
+  *		Override new value being written by user space to sysctl with
+  *		value provided by program in buffer *buf* of size *buf_len*.
+  *
+  *		*buf* should contain a string in same form as provided by user
+  *		space on sysctl write.
+  *
+  *		User space may write new value at file position > 0. To override
+  *		the whole sysctl value file position should be set to zero.
+  *	Return
+  *		0 on success.
+  *
+  *		**-E2BIG** if the *buf_len* is too big.
+  *
+  *		**-EINVAL** if sysctl is being read.
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -2568,7 -2675,13 +2672,17 @@@
  	FN(sk_fullsock),		\
  	FN(tcp_sock),			\
  	FN(skb_ecn_set_ce),		\
++<<<<<<< HEAD
 +	FN(get_listener_sock),
++=======
+ 	FN(get_listener_sock),		\
+ 	FN(skc_lookup_tcp),		\
+ 	FN(tcp_check_syncookie),	\
+ 	FN(sysctl_get_name),		\
+ 	FN(sysctl_get_current_value),	\
+ 	FN(sysctl_get_new_value),	\
+ 	FN(sysctl_set_new_value),
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
   * function eBPF program intends to call
diff --cc kernel/bpf/cgroup.c
index 7d9c426bf2c7,ba4e21986760..000000000000
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@@ -811,3 -771,304 +811,307 @@@ const struct bpf_verifier_ops cg_dev_ve
  	.get_func_proto		= cgroup_dev_func_proto,
  	.is_valid_access	= cgroup_dev_is_valid_access,
  };
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * __cgroup_bpf_run_filter_sysctl - Run a program on sysctl
+  *
+  * @head: sysctl table header
+  * @table: sysctl table
+  * @write: sysctl is being read (= 0) or written (= 1)
+  * @buf: pointer to buffer passed by user space
+  * @pcount: value-result argument: value is size of buffer pointed to by @buf,
+  *	result is size of @new_buf if program set new value, initial value
+  *	otherwise
+  * @new_buf: pointer to pointer to new buffer that will be allocated if program
+  *	overrides new value provided by user space on sysctl write
+  *	NOTE: it's caller responsibility to free *new_buf if it was set
+  * @type: type of program to be executed
+  *
+  * Program is run when sysctl is being accessed, either read or written, and
+  * can allow or deny such access.
+  *
+  * This function will return %-EPERM if an attached program is found and
+  * returned value != 1 during execution. In all other cases 0 is returned.
+  */
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   void __user *buf, size_t *pcount,
+ 				   void **new_buf, enum bpf_attach_type type)
+ {
+ 	struct bpf_sysctl_kern ctx = {
+ 		.head = head,
+ 		.table = table,
+ 		.write = write,
+ 		.cur_val = NULL,
+ 		.cur_len = PAGE_SIZE,
+ 		.new_val = NULL,
+ 		.new_len = 0,
+ 		.new_updated = 0,
+ 	};
+ 	struct cgroup *cgrp;
+ 	int ret;
+ 
+ 	ctx.cur_val = kmalloc_track_caller(ctx.cur_len, GFP_KERNEL);
+ 	if (ctx.cur_val) {
+ 		mm_segment_t old_fs;
+ 		loff_t pos = 0;
+ 
+ 		old_fs = get_fs();
+ 		set_fs(KERNEL_DS);
+ 		if (table->proc_handler(table, 0, (void __user *)ctx.cur_val,
+ 					&ctx.cur_len, &pos)) {
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.cur_len = 0;
+ 		}
+ 		set_fs(old_fs);
+ 	} else {
+ 		/* Let BPF program decide how to proceed. */
+ 		ctx.cur_len = 0;
+ 	}
+ 
+ 	if (write && buf && *pcount) {
+ 		/* BPF program should be able to override new value with a
+ 		 * buffer bigger than provided by user.
+ 		 */
+ 		ctx.new_val = kmalloc_track_caller(PAGE_SIZE, GFP_KERNEL);
+ 		ctx.new_len = min(PAGE_SIZE, *pcount);
+ 		if (!ctx.new_val ||
+ 		    copy_from_user(ctx.new_val, buf, ctx.new_len))
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.new_len = 0;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	cgrp = task_dfl_cgroup(current);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);
+ 	rcu_read_unlock();
+ 
+ 	kfree(ctx.cur_val);
+ 
+ 	if (ret == 1 && ctx.new_updated) {
+ 		*new_buf = ctx.new_val;
+ 		*pcount = ctx.new_len;
+ 	} else {
+ 		kfree(ctx.new_val);
+ 	}
+ 
+ 	return ret == 1 ? 0 : -EPERM;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_sysctl);
+ 
+ static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,
+ 			      size_t *lenp)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (dir->header.parent) {
+ 		tmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);
+ 	if (ret < 0)
+ 		return ret;
+ 	*bufp += ret;
+ 	*lenp -= ret;
+ 	ret += tmp_ret;
+ 
+ 	/* Avoid leading slash. */
+ 	if (!ret)
+ 		return ret;
+ 
+ 	tmp_ret = strscpy(*bufp, "/", *lenp);
+ 	if (tmp_ret < 0)
+ 		return tmp_ret;
+ 	*bufp += tmp_ret;
+ 	*lenp -= tmp_ret;
+ 
+ 	return ret + tmp_ret;
+ }
+ 
+ BPF_CALL_4(bpf_sysctl_get_name, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len, u64, flags)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (!(flags & BPF_F_SYSCTL_BASE_NAME)) {
+ 		if (!ctx->head)
+ 			return -EINVAL;
+ 		tmp_ret = sysctl_cpy_dir(ctx->head->parent, &buf, &buf_len);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(buf, ctx->table->procname, buf_len);
+ 
+ 	return ret < 0 ? ret : tmp_ret + ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_name_proto = {
+ 	.func		= bpf_sysctl_get_name,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ static int copy_sysctl_value(char *dst, size_t dst_len, char *src,
+ 			     size_t src_len)
+ {
+ 	if (!dst)
+ 		return -EINVAL;
+ 
+ 	if (!dst_len)
+ 		return -E2BIG;
+ 
+ 	if (!src || !src_len) {
+ 		memset(dst, 0, dst_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	memcpy(dst, src, min(dst_len, src_len));
+ 
+ 	if (dst_len > src_len) {
+ 		memset(dst + src_len, '\0', dst_len - src_len);
+ 		return src_len;
+ 	}
+ 
+ 	dst[dst_len - 1] = '\0';
+ 
+ 	return -E2BIG;
+ }
+ 
+ BPF_CALL_3(bpf_sysctl_get_current_value, struct bpf_sysctl_kern *, ctx,
+ 	   char *, buf, size_t, buf_len)
+ {
+ 	return copy_sysctl_value(buf, buf_len, ctx->cur_val, ctx->cur_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_current_value_proto = {
+ 	.func		= bpf_sysctl_get_current_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_get_new_value, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len)
+ {
+ 	if (!ctx->write) {
+ 		if (buf && buf_len)
+ 			memset(buf, '\0', buf_len);
+ 		return -EINVAL;
+ 	}
+ 	return copy_sysctl_value(buf, buf_len, ctx->new_val, ctx->new_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_new_value_proto = {
+ 	.func		= bpf_sysctl_get_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_set_new_value, struct bpf_sysctl_kern *, ctx,
+ 	   const char *, buf, size_t, buf_len)
+ {
+ 	if (!ctx->write || !ctx->new_val || !ctx->new_len || !buf || !buf_len)
+ 		return -EINVAL;
+ 
+ 	if (buf_len > PAGE_SIZE - 1)
+ 		return -E2BIG;
+ 
+ 	memcpy(ctx->new_val, buf, buf_len);
+ 	ctx->new_len = buf_len;
+ 	ctx->new_updated = 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_set_new_value_proto = {
+ 	.func		= bpf_sysctl_set_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ sysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_sysctl_get_name:
+ 		return &bpf_sysctl_get_name_proto;
+ 	case BPF_FUNC_sysctl_get_current_value:
+ 		return &bpf_sysctl_get_current_value_proto;
+ 	case BPF_FUNC_sysctl_get_new_value:
+ 		return &bpf_sysctl_get_new_value_proto;
+ 	case BPF_FUNC_sysctl_set_new_value:
+ 		return &bpf_sysctl_set_new_value_proto;
+ 	default:
+ 		return cgroup_base_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off + size > sizeof(struct bpf_sysctl) ||
+ 	    off % size || type != BPF_READ)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		bpf_ctx_record_field_size(info, size_default);
+ 		return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static u32 sysctl_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct bpf_sysctl_kern, write,
+ 				       FIELD_SIZEOF(struct bpf_sysctl_kern,
+ 						    write),
+ 				       target_size));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ const struct bpf_verifier_ops cg_sysctl_verifier_ops = {
+ 	.get_func_proto		= sysctl_func_proto,
+ 	.is_valid_access	= sysctl_is_valid_access,
+ 	.convert_ctx_access	= sysctl_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sysctl_prog_ops = {
+ };
++>>>>>>> 4e63acdff864 (bpf: Introduce bpf_sysctl_{get,set}_new_value helpers)
* Unmerged path fs/proc/proc_sysctl.c
* Unmerged path include/linux/bpf-cgroup.h
* Unmerged path include/linux/filter.h
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/cgroup.c
