RDMA/core: Clear out the udata before error unwind

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 6875cb175ca7e0c24aa4460ac2b3257fdf662832
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6875cb17.failed

The core code should not pass a udata to the driver destroy function that
contains the input from the create command. Otherwise the driver will
attempt to interpret the create udata as destroy udata, and at least in
the case of EFA, will leak resources.

Zero this stuff out before invoking destroy.

	Reported-by: Leon Romanovsky <leonro@mellanox.com>
Fixes: c4367a26357b ("IB: Pass uverbs_attr_bundle down ib_x destroy path")
	Reviewed-by: Gal Pressman <galpress@amazon.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6875cb175ca7e0c24aa4460ac2b3257fdf662832)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 9b4e1de5a2a0,a9b32ebb9beb..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -174,8 -174,19 +174,19 @@@ static int uverbs_request_finish(struc
  	return 0;
  }
  
+ /*
+  * When calling a destroy function during an error unwind we need to pass in
+  * the udata that is sanitized of all user arguments. Ie from the driver
+  * perspective it looks like no udata was passed.
+  */
+ struct ib_udata *uverbs_get_cleared_udata(struct uverbs_attr_bundle *attrs)
+ {
+ 	attrs->driver_udata = (struct ib_udata){};
+ 	return &attrs->driver_udata;
+ }
+ 
  static struct ib_uverbs_completion_event_file *
 -_ib_uverbs_lookup_comp_file(s32 fd, struct uverbs_attr_bundle *attrs)
 +_ib_uverbs_lookup_comp_file(s32 fd, const struct uverbs_attr_bundle *attrs)
  {
  	struct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,
  					       fd, attrs);
@@@ -428,13 -449,15 +439,20 @@@ static int ib_uverbs_alloc_pd(struct uv
  	if (ret)
  		goto err_copy;
  
 -	return uobj_alloc_commit(uobj, attrs);
 +	return uobj_alloc_commit(uobj);
  
  err_copy:
++<<<<<<< HEAD
 +	ib_dealloc_pd(pd);
 +
++=======
+ 	ib_dealloc_pd_user(pd, uverbs_get_cleared_udata(attrs));
+ 	pd = NULL;
+ err_alloc:
+ 	kfree(pd);
++>>>>>>> 6875cb175ca7 (RDMA/core: Clear out the udata before error unwind)
  err:
 -	uobj_alloc_abort(uobj, attrs);
 +	uobj_alloc_abort(uobj);
  	return ret;
  }
  
@@@ -633,10 -655,10 +651,14 @@@ err_copy
  	}
  
  err_dealloc_xrcd:
++<<<<<<< HEAD
 +	ib_dealloc_xrcd(xrcd);
++=======
+ 	ib_dealloc_xrcd(xrcd, uverbs_get_cleared_udata(attrs));
++>>>>>>> 6875cb175ca7 (RDMA/core: Clear out the udata before error unwind)
  
  err:
 -	uobj_alloc_abort(&obj->uobject, attrs);
 +	uobj_alloc_abort(&obj->uobject);
  
  err_tree_mutex_unlock:
  	if (f.file)
@@@ -753,10 -775,10 +775,14 @@@ static int ib_uverbs_reg_mr(struct uver
  
  	uobj_put_obj_read(pd);
  
 -	return uobj_alloc_commit(uobj, attrs);
 +	return uobj_alloc_commit(uobj);
  
  err_copy:
++<<<<<<< HEAD
 +	ib_dereg_mr(mr);
++=======
+ 	ib_dereg_mr_user(mr, uverbs_get_cleared_udata(attrs));
++>>>>>>> 6875cb175ca7 (RDMA/core: Clear out the udata before error unwind)
  
  err_put:
  	uobj_put_obj_read(pd);
@@@ -2951,10 -2972,10 +2977,14 @@@ static int ib_uverbs_ex_create_wq(struc
  
  	uobj_put_obj_read(pd);
  	uobj_put_obj_read(cq);
 -	return uobj_alloc_commit(&obj->uevent.uobject, attrs);
 +	return uobj_alloc_commit(&obj->uevent.uobject);
  
  err_copy:
++<<<<<<< HEAD
 +	ib_destroy_wq(wq);
++=======
+ 	ib_destroy_wq(wq, uverbs_get_cleared_udata(attrs));
++>>>>>>> 6875cb175ca7 (RDMA/core: Clear out the udata before error unwind)
  err_put_cq:
  	uobj_put_obj_read(cq);
  err_put_pd:
@@@ -3447,11 -3472,13 +3477,15 @@@ static int __uverbs_create_xsrq(struct 
  		uobj_put_obj_read(attr.ext.cq);
  
  	uobj_put_obj_read(pd);
 -	return uobj_alloc_commit(&obj->uevent.uobject, attrs);
 +	return uobj_alloc_commit(&obj->uevent.uobject);
  
  err_copy:
++<<<<<<< HEAD
 +	ib_destroy_srq(srq);
++=======
+ 	ib_destroy_srq_user(srq, uverbs_get_cleared_udata(attrs));
++>>>>>>> 6875cb175ca7 (RDMA/core: Clear out the udata before error unwind)
  
 -err_free:
 -	kfree(srq);
  err_put:
  	uobj_put_obj_read(pd);
  
diff --cc drivers/infiniband/core/uverbs_std_types_mr.c
index 3b4bf6370333,997f7a3a558a..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_mr.c
+++ b/drivers/infiniband/core/uverbs_std_types_mr.c
@@@ -146,7 -148,7 +146,11 @@@ static int UVERBS_HANDLER(UVERBS_METHOD
  	return 0;
  
  err_dereg:
++<<<<<<< HEAD
 +	ib_dereg_mr(mr);
++=======
+ 	ib_dereg_mr_user(mr, uverbs_get_cleared_udata(attrs));
++>>>>>>> 6875cb175ca7 (RDMA/core: Clear out the udata before error unwind)
  
  	return ret;
  }
diff --git a/drivers/infiniband/core/rdma_core.h b/drivers/infiniband/core/rdma_core.h
index 69f8db66925e..53f37247bae9 100644
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@ -111,6 +111,8 @@ int uverbs_output_written(const struct uverbs_attr_bundle *bundle, size_t idx);
 void setup_ufile_idr_uobject(struct ib_uverbs_file *ufile);
 void release_ufile_idr_uobject(struct ib_uverbs_file *ufile);
 
+struct ib_udata *uverbs_get_cleared_udata(struct uverbs_attr_bundle *attrs);
+
 /*
  * This is the runtime description of the uverbs API, used by the syscall
  * machinery to validate and dispatch calls.
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
