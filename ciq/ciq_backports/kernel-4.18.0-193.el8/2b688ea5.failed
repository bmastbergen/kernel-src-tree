net/mlx5: Add flow steering actions to fs_cmd shim layer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Add flow steering actions to fs_cmd shim layer (Alaa Hleihel) [1760284 1724327 1724336]
Rebuild_FUZZ: 96.30%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 2b688ea5efdee2868ed23eddfdbe27dbd232edac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2b688ea5.failed

Add flow steering actions: modify header and packet reformat
to the fs_cmd shim layer. This allows each namespace to define
possibly different functionality for alloc/dealloc action commands.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 2b688ea5efdee2868ed23eddfdbe27dbd232edac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 6fc81c2f5fcb,30d26eba75a3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -180,7 -201,11 +180,15 @@@ struct mlx5e_mod_hdr_entry 
  
  	struct mod_hdr_key key;
  
++<<<<<<< HEAD
 +	u32 mod_hdr_id;
++=======
+ 	struct mlx5_modify_hdr *modify_hdr;
+ 
+ 	refcount_t refcnt;
+ 	struct completion res_ready;
+ 	int compl_result;
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  };
  
  #define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)
@@@ -200,6 -296,54 +208,57 @@@ static inline int cmp_mod_hdr_info(stru
  	return memcmp(a->actions, b->actions, a->num_actions * MLX5_MH_ACT_SZ);
  }
  
++<<<<<<< HEAD
++=======
+ static struct mod_hdr_tbl *
+ get_mod_hdr_table(struct mlx5e_priv *priv, int namespace)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 
+ 	return namespace == MLX5_FLOW_NAMESPACE_FDB ? &esw->offloads.mod_hdr :
+ 		&priv->fs.tc.mod_hdr;
+ }
+ 
+ static struct mlx5e_mod_hdr_entry *
+ mlx5e_mod_hdr_get(struct mod_hdr_tbl *tbl, struct mod_hdr_key *key, u32 hash_key)
+ {
+ 	struct mlx5e_mod_hdr_entry *mh, *found = NULL;
+ 
+ 	hash_for_each_possible(tbl->hlist, mh, mod_hdr_hlist, hash_key) {
+ 		if (!cmp_mod_hdr_info(&mh->key, key)) {
+ 			refcount_inc(&mh->refcnt);
+ 			found = mh;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return found;
+ }
+ 
+ static void mlx5e_mod_hdr_put(struct mlx5e_priv *priv,
+ 			      struct mlx5e_mod_hdr_entry *mh,
+ 			      int namespace)
+ {
+ 	struct mod_hdr_tbl *tbl = get_mod_hdr_table(priv, namespace);
+ 
+ 	if (!refcount_dec_and_mutex_lock(&mh->refcnt, &tbl->lock))
+ 		return;
+ 	hash_del(&mh->mod_hdr_hlist);
+ 	mutex_unlock(&tbl->lock);
+ 
+ 	WARN_ON(!list_empty(&mh->flows));
+ 	if (mh->compl_result > 0)
+ 		mlx5_modify_header_dealloc(priv->mdev, mh->modify_hdr);
+ 
+ 	kfree(mh);
+ }
+ 
+ static int get_flow_name_space(struct mlx5e_tc_flow *flow)
+ {
+ 	return mlx5e_is_eswitch_flow(flow) ?
+ 		MLX5_FLOW_NAMESPACE_FDB : MLX5_FLOW_NAMESPACE_KERNEL;
+ }
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  static int mlx5e_attach_mod_hdr(struct mlx5e_priv *priv,
  				struct mlx5e_tc_flow *flow,
  				struct mlx5e_tc_flow_parse_attr *parse_attr)
@@@ -249,26 -387,34 +308,45 @@@
  	mh->key.actions = (void *)mh + sizeof(*mh);
  	memcpy(mh->key.actions, key.actions, actions_size);
  	mh->key.num_actions = num_actions;
 -	spin_lock_init(&mh->flows_lock);
  	INIT_LIST_HEAD(&mh->flows);
 -	refcount_set(&mh->refcnt, 1);
 -	init_completion(&mh->res_ready);
  
 -	hash_add(tbl->hlist, &mh->mod_hdr_hlist, hash_key);
 -	mutex_unlock(&tbl->lock);
++<<<<<<< HEAD
 +	err = mlx5_modify_header_alloc(priv->mdev, namespace,
 +				       mh->key.num_actions,
 +				       mh->key.actions,
 +				       &mh->mod_hdr_id);
 +	if (err)
 +		goto out_err;
  
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH)
 +		hash_add(esw->offloads.mod_hdr_tbl, &mh->mod_hdr_hlist, hash_key);
 +	else
 +		hash_add(priv->fs.tc.mod_hdr_tbl, &mh->mod_hdr_hlist, hash_key);
++=======
+ 	mh->modify_hdr = mlx5_modify_header_alloc(priv->mdev, namespace,
+ 						  mh->key.num_actions,
+ 						  mh->key.actions);
+ 	if (IS_ERR(mh->modify_hdr)) {
+ 		err = PTR_ERR(mh->modify_hdr);
+ 		mh->compl_result = err;
+ 		goto alloc_header_err;
+ 	}
+ 	mh->compl_result = 1;
+ 	complete_all(&mh->res_ready);
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  
  attach_flow:
 -	flow->mh = mh;
 -	spin_lock(&mh->flows_lock);
  	list_add(&flow->mod_hdr, &mh->flows);
++<<<<<<< HEAD
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH)
 +		flow->esw_attr->mod_hdr_id = mh->mod_hdr_id;
++=======
+ 	spin_unlock(&mh->flows_lock);
+ 	if (mlx5e_is_eswitch_flow(flow))
+ 		flow->esw_attr->modify_hdr = mh->modify_hdr;
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  	else
- 		flow->nic_attr->mod_hdr_id = mh->mod_hdr_id;
+ 		flow->nic_attr->modify_hdr = mh->modify_hdr;
  
  	return 0;
  
@@@ -766,12 -946,13 +843,12 @@@ mlx5e_tc_add_nic_flow(struct mlx5e_pri
  
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {
  		err = mlx5e_attach_mod_hdr(priv, flow, parse_attr);
- 		flow_act.modify_id = attr->mod_hdr_id;
+ 		flow_act.modify_hdr = attr->modify_hdr;
  		kfree(parse_attr->mod_hdr_actions);
  		if (err)
 -			return err;
 +			goto err_create_mod_hdr_id;
  	}
  
 -	mutex_lock(&priv->fs.tc.t_lock);
  	if (IS_ERR_OR_NULL(priv->fs.tc.t)) {
  		int tc_grp_size, tc_tbl_size;
  		u32 max_flow_counter;
@@@ -1150,8 -1324,8 +1226,13 @@@ void mlx5e_tc_encap_flows_add(struct ml
  		esw_attr = flow->esw_attr;
  		spec = &esw_attr->parse_attr->spec;
  
++<<<<<<< HEAD
 +		esw_attr->dests[efi->index].encap_id = e->encap_id;
 +		esw_attr->dests[efi->index].flags |= MLX5_ESW_DEST_ENCAP_VALID;
++=======
+ 		esw_attr->dests[flow->tmp_efi_index].pkt_reformat = e->pkt_reformat;
+ 		esw_attr->dests[flow->tmp_efi_index].flags |= MLX5_ESW_DEST_ENCAP_VALID;
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  		/* Flow can be associated with multiple encap entries.
  		 * Before offloading the flow verify that all of them have
  		 * a valid neighbour.
@@@ -1295,12 -1559,46 +1376,16 @@@ static void mlx5e_detach_encap(struct m
  		mlx5e_rep_encap_entry_detach(netdev_priv(e->out_dev), e);
  
  		if (e->flags & MLX5_ENCAP_ENTRY_VALID)
 -			mlx5_packet_reformat_dealloc(priv->mdev, e->pkt_reformat);
 -	}
++<<<<<<< HEAD
 +			mlx5_packet_reformat_dealloc(priv->mdev, e->encap_id);
  
 -	kfree(e->encap_header);
 -	kfree_rcu(e, rcu);
 -}
 -
 -void mlx5e_encap_put(struct mlx5e_priv *priv, struct mlx5e_encap_entry *e)
 -{
 -	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -
 -	if (!refcount_dec_and_mutex_lock(&e->refcnt, &esw->offloads.encap_tbl_lock))
 -		return;
 -	hash_del_rcu(&e->encap_hlist);
 -	mutex_unlock(&esw->offloads.encap_tbl_lock);
 -
 -	mlx5e_encap_dealloc(priv, e);
 -}
 -
 -static void mlx5e_detach_encap(struct mlx5e_priv *priv,
 -			       struct mlx5e_tc_flow *flow, int out_index)
 -{
 -	struct mlx5e_encap_entry *e = flow->encaps[out_index].e;
 -	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -
 -	/* flow wasn't fully initialized */
 -	if (!e)
 -		return;
 -
 -	mutex_lock(&esw->offloads.encap_tbl_lock);
 -	list_del(&flow->encaps[out_index].list);
 -	flow->encaps[out_index].e = NULL;
 -	if (!refcount_dec_and_test(&e->refcnt)) {
 -		mutex_unlock(&esw->offloads.encap_tbl_lock);
 -		return;
 +		hash_del_rcu(&e->encap_hlist);
 +		kfree(e->encap_header);
 +		kfree(e);
++=======
++			mlx5_packet_reformat_dealloc(priv->mdev, e->pkt_reformat);
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  	}
 -	hash_del_rcu(&e->encap_hlist);
 -	mutex_unlock(&esw->offloads.encap_tbl_lock);
 -
 -	mlx5e_encap_dealloc(priv, e);
  }
  
  static void __mlx5e_tc_del_fdb_peer_flow(struct mlx5e_tc_flow *flow)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index af9a875f1cf1,4f70202db6af..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -69,6 -69,8 +69,11 @@@ struct vport_ingress 
  	struct mlx5_flow_group *allow_spoofchk_only_grp;
  	struct mlx5_flow_group *allow_untagged_only_grp;
  	struct mlx5_flow_group *drop_grp;
++<<<<<<< HEAD
++=======
+ 	struct mlx5_modify_hdr   *modify_metadata;
+ 	struct mlx5_flow_handle  *modify_metadata_rule;
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  	struct mlx5_flow_handle  *allow_rule;
  	struct mlx5_flow_handle  *drop_rule;
  	struct mlx5_fc           *drop_counter;
@@@ -329,12 -385,13 +334,21 @@@ struct mlx5_esw_flow_attr 
  	struct {
  		u32 flags;
  		struct mlx5_eswitch_rep *rep;
+ 		struct mlx5_pkt_reformat *pkt_reformat;
  		struct mlx5_core_dev *mdev;
++<<<<<<< HEAD
 +		u32 encap_id;
 +	} dests[MLX5_MAX_FLOW_FWD_VPORTS];
 +	u32	mod_hdr_id;
 +	u8	match_level;
 +	u8	tunnel_match_level;
++=======
+ 		struct mlx5_termtbl_handle *termtbl;
+ 	} dests[MLX5_MAX_FLOW_FWD_VPORTS];
+ 	struct  mlx5_modify_hdr *modify_hdr;
+ 	u8	inner_match_level;
+ 	u8	outer_match_level;
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  	struct mlx5_fc *counter;
  	u32	chain;
  	u16	prio;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,bee67ff58137..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -146,32 -205,15 +146,32 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  		i++;
  	}
  
 -	mlx5_eswitch_set_rule_source_port(esw, spec, attr);
 +	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
 +	MLX5_SET(fte_match_set_misc, misc, source_port, attr->in_rep->vport);
 +
 +	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
 +		MLX5_SET(fte_match_set_misc, misc,
 +			 source_eswitch_owner_vhca_id,
 +			 MLX5_CAP_GEN(attr->in_mdev, vhca_id));
  
 -	if (attr->outer_match_level != MLX5_MATCH_NONE)
 +	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
 +	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
 +	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
 +		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
 +				 source_eswitch_owner_vhca_id);
 +
 +	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;
 +	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP) {
 +		if (attr->tunnel_match_level != MLX5_MATCH_NONE)
 +			spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
 +		if (attr->match_level != MLX5_MATCH_NONE)
 +			spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
 +	} else if (attr->match_level != MLX5_MATCH_NONE) {
  		spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
 -	if (attr->inner_match_level != MLX5_MATCH_NONE)
 -		spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
 +	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
- 		flow_act.modify_id = attr->mod_hdr_id;
+ 		flow_act.modify_hdr = attr->modify_hdr;
  
  	fdb = esw_get_prio_table(esw, attr->chain, attr->prio, !!split);
  	if (IS_ERR(fdb)) {
@@@ -1441,6 -1731,12 +1441,15 @@@ static int esw_vport_ingress_prio_tag_c
  	flow_act.vlan[0].ethtype = ETH_P_8021Q;
  	flow_act.vlan[0].vid = 0;
  	flow_act.vlan[0].prio = 0;
++<<<<<<< HEAD
++=======
+ 
+ 	if (vport->ingress.modify_metadata_rule) {
+ 		flow_act.action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+ 		flow_act.modify_hdr = vport->ingress.modify_metadata;
+ 	}
+ 
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  	vport->ingress.allow_rule =
  		mlx5_add_flow_rules(vport->ingress.acl, spec,
  				    &flow_act, NULL, 0);
@@@ -1461,6 -1757,60 +1470,63 @@@ out_no_mem
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int esw_vport_add_ingress_acl_modify_metadata(struct mlx5_eswitch *esw,
+ 						     struct mlx5_vport *vport)
+ {
+ 	u8 action[MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)] = {};
+ 	static const struct mlx5_flow_spec spec = {};
+ 	struct mlx5_flow_act flow_act = {};
+ 	int err = 0;
+ 
+ 	MLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);
+ 	MLX5_SET(set_action_in, action, field, MLX5_ACTION_IN_FIELD_METADATA_REG_C_0);
+ 	MLX5_SET(set_action_in, action, data,
+ 		 mlx5_eswitch_get_vport_metadata_for_match(esw, vport->vport));
+ 
+ 	vport->ingress.modify_metadata =
+ 		mlx5_modify_header_alloc(esw->dev, MLX5_FLOW_NAMESPACE_ESW_INGRESS,
+ 					 1, action);
+ 	if (IS_ERR(vport->ingress.modify_metadata)) {
+ 		err = PTR_ERR(vport->ingress.modify_metadata);
+ 		esw_warn(esw->dev,
+ 			 "failed to alloc modify header for vport %d ingress acl (%d)\n",
+ 			 vport->vport, err);
+ 		return err;
+ 	}
+ 
+ 	flow_act.action = MLX5_FLOW_CONTEXT_ACTION_MOD_HDR | MLX5_FLOW_CONTEXT_ACTION_ALLOW;
+ 	flow_act.modify_hdr = vport->ingress.modify_metadata;
+ 	vport->ingress.modify_metadata_rule = mlx5_add_flow_rules(vport->ingress.acl,
+ 								  &spec, &flow_act, NULL, 0);
+ 	if (IS_ERR(vport->ingress.modify_metadata_rule)) {
+ 		err = PTR_ERR(vport->ingress.modify_metadata_rule);
+ 		esw_warn(esw->dev,
+ 			 "failed to add setting metadata rule for vport %d ingress acl, err(%d)\n",
+ 			 vport->vport, err);
+ 		vport->ingress.modify_metadata_rule = NULL;
+ 		goto out;
+ 	}
+ 
+ out:
+ 	if (err)
+ 		mlx5_modify_header_dealloc(esw->dev, vport->ingress.modify_metadata);
+ 	return err;
+ }
+ 
+ void esw_vport_del_ingress_acl_modify_metadata(struct mlx5_eswitch *esw,
+ 					       struct mlx5_vport *vport)
+ {
+ 	if (vport->ingress.modify_metadata_rule) {
+ 		mlx5_del_flow_rules(vport->ingress.modify_metadata_rule);
+ 		mlx5_modify_header_dealloc(esw->dev, vport->ingress.modify_metadata);
+ 
+ 		vport->ingress.modify_metadata_rule = NULL;
+ 	}
+ }
+ 
++>>>>>>> 2b688ea5efde (net/mlx5: Add flow steering actions to fs_cmd shim layer)
  static int esw_vport_egress_prio_tag_config(struct mlx5_eswitch *esw,
  					    struct mlx5_vport *vport)
  {
diff --git a/drivers/infiniband/hw/mlx5/flow.c b/drivers/infiniband/hw/mlx5/flow.c
index 062163e1177a..64d77f5c3d94 100644
--- a/drivers/infiniband/hw/mlx5/flow.c
+++ b/drivers/infiniband/hw/mlx5/flow.c
@@ -321,11 +321,11 @@ void mlx5_ib_destroy_flow_action_raw(struct mlx5_ib_flow_action *maction)
 	switch (maction->flow_action_raw.sub_type) {
 	case MLX5_IB_FLOW_ACTION_MODIFY_HEADER:
 		mlx5_modify_header_dealloc(maction->flow_action_raw.dev->mdev,
-					   maction->flow_action_raw.action_id);
+					   maction->flow_action_raw.modify_hdr);
 		break;
 	case MLX5_IB_FLOW_ACTION_PACKET_REFORMAT:
 		mlx5_packet_reformat_dealloc(maction->flow_action_raw.dev->mdev,
-			maction->flow_action_raw.action_id);
+					     maction->flow_action_raw.pkt_reformat);
 		break;
 	case MLX5_IB_FLOW_ACTION_DECAP:
 		break;
@@ -351,10 +351,11 @@ mlx5_ib_create_modify_header(struct mlx5_ib_dev *dev,
 	if (!maction)
 		return ERR_PTR(-ENOMEM);
 
-	ret = mlx5_modify_header_alloc(dev->mdev, namespace, num_actions, in,
-				       &maction->flow_action_raw.action_id);
+	maction->flow_action_raw.modify_hdr =
+		mlx5_modify_header_alloc(dev->mdev, namespace, num_actions, in);
 
-	if (ret) {
+	if (IS_ERR(maction->flow_action_raw.modify_hdr)) {
+		ret = PTR_ERR(maction->flow_action_raw.modify_hdr);
 		kfree(maction);
 		return ERR_PTR(ret);
 	}
@@ -478,11 +479,13 @@ static int mlx5_ib_flow_action_create_packet_reformat_ctx(
 	if (ret)
 		return ret;
 
-	ret = mlx5_packet_reformat_alloc(dev->mdev, prm_prt, len,
-					 in, namespace,
-					 &maction->flow_action_raw.action_id);
-	if (ret)
+	maction->flow_action_raw.pkt_reformat =
+		mlx5_packet_reformat_alloc(dev->mdev, prm_prt, len,
+					   in, namespace);
+	if (IS_ERR(maction->flow_action_raw.pkt_reformat)) {
+		ret = PTR_ERR(maction->flow_action_raw.pkt_reformat);
 		return ret;
+	}
 
 	maction->flow_action_raw.sub_type =
 		MLX5_IB_FLOW_ACTION_PACKET_REFORMAT;
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 30c3472ce233..44a50a3a2cd9 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -2546,7 +2546,8 @@ int parse_flow_flow_action(struct mlx5_ib_flow_action *maction,
 			if (action->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
 				return -EINVAL;
 			action->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
-			action->modify_id = maction->flow_action_raw.action_id;
+			action->modify_hdr =
+				maction->flow_action_raw.modify_hdr;
 			return 0;
 		}
 		if (maction->flow_action_raw.sub_type ==
@@ -2563,8 +2564,8 @@ int parse_flow_flow_action(struct mlx5_ib_flow_action *maction,
 				return -EINVAL;
 			action->action |=
 				MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
-			action->reformat_id =
-				maction->flow_action_raw.action_id;
+			action->pkt_reformat =
+				maction->flow_action_raw.pkt_reformat;
 			return 0;
 		}
 		/* fall through */
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 4c2d9432d3fc..884d1829023e 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -844,7 +844,10 @@ struct mlx5_ib_flow_action {
 		struct {
 			struct mlx5_ib_dev *dev;
 			u32 sub_type;
-			u32 action_id;
+			union {
+				struct mlx5_modify_hdr *modify_hdr;
+				struct mlx5_pkt_reformat *pkt_reformat;
+			};
 		} flow_action_raw;
 	};
 };
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
index e0d4d2f5935e..a54981560b50 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
@@ -293,14 +293,14 @@ int mlx5e_tc_tun_create_header_ipv4(struct mlx5e_priv *priv,
 		 */
 		goto out;
 	}
-
-	err = mlx5_packet_reformat_alloc(priv->mdev,
-					 e->reformat_type,
-					 ipv4_encap_size, encap_header,
-					 MLX5_FLOW_NAMESPACE_FDB,
-					 &e->encap_id);
-	if (err)
+	e->pkt_reformat = mlx5_packet_reformat_alloc(priv->mdev,
+						     e->reformat_type,
+						     ipv4_encap_size, encap_header,
+						     MLX5_FLOW_NAMESPACE_FDB);
+	if (IS_ERR(e->pkt_reformat)) {
+		err = PTR_ERR(e->pkt_reformat);
 		goto destroy_neigh_entry;
+	}
 
 	e->flags |= MLX5_ENCAP_ENTRY_VALID;
 	mlx5e_rep_queue_neigh_stats_work(netdev_priv(out_dev));
@@ -409,13 +409,14 @@ int mlx5e_tc_tun_create_header_ipv6(struct mlx5e_priv *priv,
 		goto out;
 	}
 
-	err = mlx5_packet_reformat_alloc(priv->mdev,
-					 e->reformat_type,
-					 ipv6_encap_size, encap_header,
-					 MLX5_FLOW_NAMESPACE_FDB,
-					 &e->encap_id);
-	if (err)
+	e->pkt_reformat = mlx5_packet_reformat_alloc(priv->mdev,
+						     e->reformat_type,
+						     ipv6_encap_size, encap_header,
+						     MLX5_FLOW_NAMESPACE_FDB);
+	if (IS_ERR(e->pkt_reformat)) {
+		err = PTR_ERR(e->pkt_reformat);
 		goto destroy_neigh_entry;
+	}
 
 	e->flags |= MLX5_ENCAP_ENTRY_VALID;
 	mlx5e_rep_queue_neigh_stats_work(netdev_priv(out_dev));
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 6cf6542d1e86..08578218a8a1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -155,7 +155,7 @@ struct mlx5e_encap_entry {
 	 */
 	struct hlist_node encap_hlist;
 	struct list_head flows;
-	u32 encap_id;
+	struct mlx5_pkt_reformat *pkt_reformat;
 	const struct ip_tunnel_info *tun_info;
 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index b84a225bbe86..a55e6fca9c67 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@ -107,6 +107,34 @@ static int mlx5_cmd_stub_delete_fte(struct mlx5_flow_root_namespace *ns,
 	return 0;
 }
 
+static int mlx5_cmd_stub_packet_reformat_alloc(struct mlx5_flow_root_namespace *ns,
+					       int reformat_type,
+					       size_t size,
+					       void *reformat_data,
+					       enum mlx5_flow_namespace_type namespace,
+					       struct mlx5_pkt_reformat *pkt_reformat)
+{
+	return 0;
+}
+
+static void mlx5_cmd_stub_packet_reformat_dealloc(struct mlx5_flow_root_namespace *ns,
+						  struct mlx5_pkt_reformat *pkt_reformat)
+{
+}
+
+static int mlx5_cmd_stub_modify_header_alloc(struct mlx5_flow_root_namespace *ns,
+					     u8 namespace, u8 num_actions,
+					     void *modify_actions,
+					     struct mlx5_modify_hdr *modify_hdr)
+{
+	return 0;
+}
+
+static void mlx5_cmd_stub_modify_header_dealloc(struct mlx5_flow_root_namespace *ns,
+						struct mlx5_modify_hdr *modify_hdr)
+{
+}
+
 static int mlx5_cmd_update_root_ft(struct mlx5_flow_root_namespace *ns,
 				   struct mlx5_flow_table *ft, u32 underlay_qpn,
 				   bool disconnect)
@@ -412,11 +440,13 @@ static int mlx5_cmd_set_fte(struct mlx5_core_dev *dev,
 	} else {
 		MLX5_SET(flow_context, in_flow_context, action,
 			 fte->action.action);
-		MLX5_SET(flow_context, in_flow_context, packet_reformat_id,
-			 fte->action.reformat_id);
+		if (fte->action.pkt_reformat)
+			MLX5_SET(flow_context, in_flow_context, packet_reformat_id,
+				 fte->action.pkt_reformat->id);
 	}
-	MLX5_SET(flow_context, in_flow_context, modify_header_id,
-		 fte->action.modify_id);
+	if (fte->action.modify_hdr)
+		MLX5_SET(flow_context, in_flow_context, modify_header_id,
+			 fte->action.modify_hdr->id);
 
 	vlan = MLX5_ADDR_OF(flow_context, in_flow_context, push_vlan);
 
@@ -468,7 +498,7 @@ static int mlx5_cmd_set_fte(struct mlx5_core_dev *dev,
 						    MLX5_FLOW_DEST_VPORT_REFORMAT_ID));
 					MLX5_SET(extended_dest_format, in_dests,
 						 packet_reformat_id,
-						 dst->dest_attr.vport.reformat_id);
+						 dst->dest_attr.vport.pkt_reformat->id);
 				}
 				break;
 			default:
@@ -643,14 +673,15 @@ int mlx5_cmd_fc_bulk_query(struct mlx5_core_dev *dev, u32 base_id, int bulk_len,
 	return mlx5_cmd_exec(dev, in, sizeof(in), out, outlen);
 }
 
-int mlx5_packet_reformat_alloc(struct mlx5_core_dev *dev,
-			       int reformat_type,
-			       size_t size,
-			       void *reformat_data,
-			       enum mlx5_flow_namespace_type namespace,
-			       u32 *packet_reformat_id)
+static int mlx5_cmd_packet_reformat_alloc(struct mlx5_flow_root_namespace *ns,
+					  int reformat_type,
+					  size_t size,
+					  void *reformat_data,
+					  enum mlx5_flow_namespace_type namespace,
+					  struct mlx5_pkt_reformat *pkt_reformat)
 {
 	u32 out[MLX5_ST_SZ_DW(alloc_packet_reformat_context_out)];
+	struct mlx5_core_dev *dev = ns->dev;
 	void *packet_reformat_context_in;
 	int max_encap_size;
 	void *reformat;
@@ -693,35 +724,36 @@ int mlx5_packet_reformat_alloc(struct mlx5_core_dev *dev,
 	memset(out, 0, sizeof(out));
 	err = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));
 
-	*packet_reformat_id = MLX5_GET(alloc_packet_reformat_context_out,
-				       out, packet_reformat_id);
+	pkt_reformat->id = MLX5_GET(alloc_packet_reformat_context_out,
+				    out, packet_reformat_id);
 	kfree(in);
 	return err;
 }
-EXPORT_SYMBOL(mlx5_packet_reformat_alloc);
 
-void mlx5_packet_reformat_dealloc(struct mlx5_core_dev *dev,
-				  u32 packet_reformat_id)
+static void mlx5_cmd_packet_reformat_dealloc(struct mlx5_flow_root_namespace *ns,
+					     struct mlx5_pkt_reformat *pkt_reformat)
 {
 	u32 in[MLX5_ST_SZ_DW(dealloc_packet_reformat_context_in)];
 	u32 out[MLX5_ST_SZ_DW(dealloc_packet_reformat_context_out)];
+	struct mlx5_core_dev *dev = ns->dev;
 
 	memset(in, 0, sizeof(in));
 	MLX5_SET(dealloc_packet_reformat_context_in, in, opcode,
 		 MLX5_CMD_OP_DEALLOC_PACKET_REFORMAT_CONTEXT);
 	MLX5_SET(dealloc_packet_reformat_context_in, in, packet_reformat_id,
-		 packet_reformat_id);
+		 pkt_reformat->id);
 
 	mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
 }
-EXPORT_SYMBOL(mlx5_packet_reformat_dealloc);
 
-int mlx5_modify_header_alloc(struct mlx5_core_dev *dev,
-			     u8 namespace, u8 num_actions,
-			     void *modify_actions, u32 *modify_header_id)
+static int mlx5_cmd_modify_header_alloc(struct mlx5_flow_root_namespace *ns,
+					u8 namespace, u8 num_actions,
+					void *modify_actions,
+					struct mlx5_modify_hdr *modify_hdr)
 {
 	u32 out[MLX5_ST_SZ_DW(alloc_modify_header_context_out)];
 	int max_actions, actions_size, inlen, err;
+	struct mlx5_core_dev *dev = ns->dev;
 	void *actions_in;
 	u8 table_type;
 	u32 *in;
@@ -772,26 +804,26 @@ int mlx5_modify_header_alloc(struct mlx5_core_dev *dev,
 	memset(out, 0, sizeof(out));
 	err = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));
 
-	*modify_header_id = MLX5_GET(alloc_modify_header_context_out, out, modify_header_id);
+	modify_hdr->id = MLX5_GET(alloc_modify_header_context_out, out, modify_header_id);
 	kfree(in);
 	return err;
 }
-EXPORT_SYMBOL(mlx5_modify_header_alloc);
 
-void mlx5_modify_header_dealloc(struct mlx5_core_dev *dev, u32 modify_header_id)
+static void mlx5_cmd_modify_header_dealloc(struct mlx5_flow_root_namespace *ns,
+					   struct mlx5_modify_hdr *modify_hdr)
 {
 	u32 in[MLX5_ST_SZ_DW(dealloc_modify_header_context_in)];
 	u32 out[MLX5_ST_SZ_DW(dealloc_modify_header_context_out)];
+	struct mlx5_core_dev *dev = ns->dev;
 
 	memset(in, 0, sizeof(in));
 	MLX5_SET(dealloc_modify_header_context_in, in, opcode,
 		 MLX5_CMD_OP_DEALLOC_MODIFY_HEADER_CONTEXT);
 	MLX5_SET(dealloc_modify_header_context_in, in, modify_header_id,
-		 modify_header_id);
+		 modify_hdr->id);
 
 	mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
 }
-EXPORT_SYMBOL(mlx5_modify_header_dealloc);
 
 static const struct mlx5_flow_cmds mlx5_flow_cmds = {
 	.create_flow_table = mlx5_cmd_create_flow_table,
@@ -803,6 +835,10 @@ static const struct mlx5_flow_cmds mlx5_flow_cmds = {
 	.update_fte = mlx5_cmd_update_fte,
 	.delete_fte = mlx5_cmd_delete_fte,
 	.update_root_ft = mlx5_cmd_update_root_ft,
+	.packet_reformat_alloc = mlx5_cmd_packet_reformat_alloc,
+	.packet_reformat_dealloc = mlx5_cmd_packet_reformat_dealloc,
+	.modify_header_alloc = mlx5_cmd_modify_header_alloc,
+	.modify_header_dealloc = mlx5_cmd_modify_header_dealloc
 };
 
 static const struct mlx5_flow_cmds mlx5_flow_cmd_stubs = {
@@ -815,6 +851,10 @@ static const struct mlx5_flow_cmds mlx5_flow_cmd_stubs = {
 	.update_fte = mlx5_cmd_stub_update_fte,
 	.delete_fte = mlx5_cmd_stub_delete_fte,
 	.update_root_ft = mlx5_cmd_stub_update_root_ft,
+	.packet_reformat_alloc = mlx5_cmd_stub_packet_reformat_alloc,
+	.packet_reformat_dealloc = mlx5_cmd_stub_packet_reformat_dealloc,
+	.modify_header_alloc = mlx5_cmd_stub_modify_header_alloc,
+	.modify_header_dealloc = mlx5_cmd_stub_modify_header_dealloc
 };
 
 static const struct mlx5_flow_cmds *mlx5_fs_cmd_get_fw_cmds(void)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
index bc4606306009..3268654d6748 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
@@ -75,6 +75,24 @@ struct mlx5_flow_cmds {
 			      struct mlx5_flow_table *ft,
 			      u32 underlay_qpn,
 			      bool disconnect);
+
+	int (*packet_reformat_alloc)(struct mlx5_flow_root_namespace *ns,
+				     int reformat_type,
+				     size_t size,
+				     void *reformat_data,
+				     enum mlx5_flow_namespace_type namespace,
+				     struct mlx5_pkt_reformat *pkt_reformat);
+
+	void (*packet_reformat_dealloc)(struct mlx5_flow_root_namespace *ns,
+					struct mlx5_pkt_reformat *pkt_reformat);
+
+	int (*modify_header_alloc)(struct mlx5_flow_root_namespace *ns,
+				   u8 namespace, u8 num_actions,
+				   void *modify_actions,
+				   struct mlx5_modify_hdr *modify_hdr);
+
+	void (*modify_header_dealloc)(struct mlx5_flow_root_namespace *ns,
+				      struct mlx5_modify_hdr *modify_hdr);
 };
 
 int mlx5_cmd_fc_alloc(struct mlx5_core_dev *dev, u32 *id);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 585e7adcbf99..659da1a947a3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -1384,7 +1384,8 @@ static bool mlx5_flow_dests_cmp(struct mlx5_flow_destination *d1,
 		     ((d1->vport.flags & MLX5_FLOW_DEST_VPORT_VHCA_ID) ?
 		      (d1->vport.vhca_id == d2->vport.vhca_id) : true) &&
 		     ((d1->vport.flags & MLX5_FLOW_DEST_VPORT_REFORMAT_ID) ?
-		      (d1->vport.reformat_id == d2->vport.reformat_id) : true)) ||
+		      (d1->vport.pkt_reformat->id ==
+		       d2->vport.pkt_reformat->id) : true)) ||
 		    (d1->type == MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE &&
 		     d1->ft == d2->ft) ||
 		    (d1->type == MLX5_FLOW_DESTINATION_TYPE_TIR &&
@@ -2842,3 +2843,105 @@ int mlx5_fs_remove_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn)
 	return err;
 }
 EXPORT_SYMBOL(mlx5_fs_remove_rx_underlay_qpn);
+
+static struct mlx5_flow_root_namespace
+*get_root_namespace(struct mlx5_core_dev *dev, enum mlx5_flow_namespace_type ns_type)
+{
+	struct mlx5_flow_namespace *ns;
+
+	if (ns_type == MLX5_FLOW_NAMESPACE_ESW_EGRESS ||
+	    ns_type == MLX5_FLOW_NAMESPACE_ESW_INGRESS)
+		ns = mlx5_get_flow_vport_acl_namespace(dev, ns_type, 0);
+	else
+		ns = mlx5_get_flow_namespace(dev, ns_type);
+	if (!ns)
+		return NULL;
+
+	return find_root(&ns->node);
+}
+
+struct mlx5_modify_hdr *mlx5_modify_header_alloc(struct mlx5_core_dev *dev,
+						 u8 ns_type, u8 num_actions,
+						 void *modify_actions)
+{
+	struct mlx5_flow_root_namespace *root;
+	struct mlx5_modify_hdr *modify_hdr;
+	int err;
+
+	root = get_root_namespace(dev, ns_type);
+	if (!root)
+		return ERR_PTR(-EOPNOTSUPP);
+
+	modify_hdr = kzalloc(sizeof(*modify_hdr), GFP_KERNEL);
+	if (!modify_hdr)
+		return ERR_PTR(-ENOMEM);
+
+	modify_hdr->ns_type = ns_type;
+	err = root->cmds->modify_header_alloc(root, ns_type, num_actions,
+					      modify_actions, modify_hdr);
+	if (err) {
+		kfree(modify_hdr);
+		return ERR_PTR(err);
+	}
+
+	return modify_hdr;
+}
+EXPORT_SYMBOL(mlx5_modify_header_alloc);
+
+void mlx5_modify_header_dealloc(struct mlx5_core_dev *dev,
+				struct mlx5_modify_hdr *modify_hdr)
+{
+	struct mlx5_flow_root_namespace *root;
+
+	root = get_root_namespace(dev, modify_hdr->ns_type);
+	if (WARN_ON(!root))
+		return;
+	root->cmds->modify_header_dealloc(root, modify_hdr);
+	kfree(modify_hdr);
+}
+EXPORT_SYMBOL(mlx5_modify_header_dealloc);
+
+struct mlx5_pkt_reformat *mlx5_packet_reformat_alloc(struct mlx5_core_dev *dev,
+						     int reformat_type,
+						     size_t size,
+						     void *reformat_data,
+						     enum mlx5_flow_namespace_type ns_type)
+{
+	struct mlx5_pkt_reformat *pkt_reformat;
+	struct mlx5_flow_root_namespace *root;
+	int err;
+
+	root = get_root_namespace(dev, ns_type);
+	if (!root)
+		return ERR_PTR(-EOPNOTSUPP);
+
+	pkt_reformat = kzalloc(sizeof(*pkt_reformat), GFP_KERNEL);
+	if (!pkt_reformat)
+		return ERR_PTR(-ENOMEM);
+
+	pkt_reformat->ns_type = ns_type;
+	pkt_reformat->reformat_type = reformat_type;
+	err = root->cmds->packet_reformat_alloc(root, reformat_type, size,
+						reformat_data, ns_type,
+						pkt_reformat);
+	if (err) {
+		kfree(pkt_reformat);
+		return ERR_PTR(err);
+	}
+
+	return pkt_reformat;
+}
+EXPORT_SYMBOL(mlx5_packet_reformat_alloc);
+
+void mlx5_packet_reformat_dealloc(struct mlx5_core_dev *dev,
+				  struct mlx5_pkt_reformat *pkt_reformat)
+{
+	struct mlx5_flow_root_namespace *root;
+
+	root = get_root_namespace(dev, pkt_reformat->ns_type);
+	if (WARN_ON(!root))
+		return;
+	root->cmds->packet_reformat_dealloc(root, pkt_reformat);
+	kfree(pkt_reformat);
+}
+EXPORT_SYMBOL(mlx5_packet_reformat_dealloc);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index c1252d6be0ef..9460409e38f9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@ -38,6 +38,17 @@
 #include <linux/rhashtable.h>
 #include <linux/llist.h>
 
+struct mlx5_modify_hdr {
+	enum mlx5_flow_namespace_type ns_type;
+	u32 id;
+};
+
+struct mlx5_pkt_reformat {
+	enum mlx5_flow_namespace_type ns_type;
+	int reformat_type; /* from mlx5_ifc */
+	u32 id;
+};
+
 /* FS_TYPE_PRIO_CHAINS is a PRIO that will have namespaces only,
  * and those are in parallel to one another when going over them to connect
  * a new flow table. Meaning the last flow table in a TYPE_PRIO prio in one
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index 8f2806f456c6..d8ce2ca53b1d 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -83,6 +83,8 @@ enum {
 	FDB_SLOW_PATH,
 };
 
+struct mlx5_pkt_reformat;
+struct mlx5_modify_hdr;
 struct mlx5_flow_table;
 struct mlx5_flow_group;
 struct mlx5_flow_namespace;
@@ -120,7 +122,7 @@ struct mlx5_flow_destination {
 		struct {
 			u16		num;
 			u16		vhca_id;
-			u32		reformat_id;
+			struct mlx5_pkt_reformat *pkt_reformat;
 			u8		flags;
 		} vport;
 	};
@@ -189,8 +191,8 @@ enum {
 
 struct mlx5_flow_act {
 	u32 action;
-	u32 reformat_id;
-	u32 modify_id;
+	struct mlx5_modify_hdr  *modify_hdr;
+	struct mlx5_pkt_reformat *pkt_reformat;
 	uintptr_t esp_id;
 	u32 flags;
 	struct mlx5_fs_vlan vlan[MLX5_FS_VLAN_DEPTH];
@@ -199,8 +201,6 @@ struct mlx5_flow_act {
 
 #define MLX5_DECLARE_FLOW_ACT(name) \
 	struct mlx5_flow_act name = { .action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\
-				      .reformat_id = 0, \
-				      .modify_id = 0, \
 				      .flags =  0, }
 
 /* Single destination per rule.
@@ -230,19 +230,18 @@ u32 mlx5_fc_id(struct mlx5_fc *counter);
 int mlx5_fs_add_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn);
 int mlx5_fs_remove_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn);
 
-int mlx5_modify_header_alloc(struct mlx5_core_dev *dev,
-			     u8 namespace, u8 num_actions,
-			     void *modify_actions, u32 *modify_header_id);
+struct mlx5_modify_hdr *mlx5_modify_header_alloc(struct mlx5_core_dev *dev,
+						 u8 ns_type, u8 num_actions,
+						 void *modify_actions);
 void mlx5_modify_header_dealloc(struct mlx5_core_dev *dev,
-				u32 modify_header_id);
-
-int mlx5_packet_reformat_alloc(struct mlx5_core_dev *dev,
-			       int reformat_type,
-			       size_t size,
-			       void *reformat_data,
-			       enum mlx5_flow_namespace_type namespace,
-			       u32 *packet_reformat_id);
+				struct mlx5_modify_hdr *modify_hdr);
+
+struct mlx5_pkt_reformat *mlx5_packet_reformat_alloc(struct mlx5_core_dev *dev,
+						     int reformat_type,
+						     size_t size,
+						     void *reformat_data,
+						     enum mlx5_flow_namespace_type ns_type);
 void mlx5_packet_reformat_dealloc(struct mlx5_core_dev *dev,
-				  u32 packet_reformat_id);
+				  struct mlx5_pkt_reformat *reformat);
 
 #endif
