PCI/PM: Fold __pci_start_power_transition() into its caller

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit dc2256b0735d03664a92a6cb94ea4e564dfa237b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/dc2256b0.failed

Because pci_power_up() has become the only caller of
__pci_start_power_transition(), there is no need for the latter to
be a separate function any more, so fold it into the former, drop a
redundant check and reduce the number of lines of code somewhat.

Code rearrangement, no intentional functional impact.

Link: https://lore.kernel.org/r/3458080.lsoDbfkST9@kreacher
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit dc2256b0735d03664a92a6cb94ea4e564dfa237b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci.c
diff --cc drivers/pci/pci.c
index 371c0cd17730,56bc79e33286..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -998,33 -1003,31 +998,61 @@@ void pci_wakeup_bus(struct pci_bus *bus
  }
  
  /**
++<<<<<<< HEAD
 + * __pci_start_power_transition - Start power transition of a PCI device
 + * @dev: PCI device to handle.
 + * @state: State to put the device into.
 + */
 +static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 +{
 +	if (state == PCI_D0) {
 +		pci_platform_power_transition(dev, PCI_D0);
 +		/*
 +		 * Mandatory power management transition delays, see
 +		 * PCI Express Base Specification Revision 2.0 Section
 +		 * 6.6.1: Conventional Reset.  Do not delay for
 +		 * devices powered on/off by corresponding bridge,
 +		 * because have already delayed for the bridge.
 +		 */
 +		if (dev->runtime_d3cold) {
 +			if (dev->d3cold_delay && !dev->imm_ready)
 +				msleep(dev->d3cold_delay);
 +			/*
 +			 * When powering on a bridge from D3cold, the
 +			 * whole hierarchy may be powered on into
 +			 * D0uninitialized state, resume them to give
 +			 * them a chance to suspend again
 +			 */
 +			pci_wakeup_bus(dev->subordinate);
 +		}
 +	}
++=======
+  * pci_power_up - Put the given device into D0
+  * @dev: PCI device to power up
+  */
+ int pci_power_up(struct pci_dev *dev)
+ {
+ 	pci_platform_power_transition(dev, PCI_D0);
+ 
+ 	/*
+ 	 * Mandatory power management transition delays, see PCI Express Base
+ 	 * Specification Revision 2.0 Section 6.6.1: Conventional Reset.  Do not
+ 	 * delay for devices powered on/off by corresponding bridge, because
+ 	 * have already delayed for the bridge.
+ 	 */
+ 	if (dev->runtime_d3cold) {
+ 		if (dev->d3cold_delay && !dev->imm_ready)
+ 			msleep(dev->d3cold_delay);
+ 		/*
+ 		 * When powering on a bridge from D3cold, the whole hierarchy
+ 		 * may be powered on into D0uninitialized state, resume them to
+ 		 * give them a chance to suspend again
+ 		 */
+ 		pci_wakeup_bus(dev->subordinate);
+ 	}
+ 
+ 	return pci_raw_set_power_state(dev, PCI_D0);
++>>>>>>> dc2256b0735d (PCI/PM: Fold __pci_start_power_transition() into its caller)
  }
  
  /**
* Unmerged path drivers/pci/pci.c
