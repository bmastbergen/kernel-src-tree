net: phy: icplus: keep all ip101a_g functions together

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] phy: icplus: keep all ip101a_g functions together (Petr Oros) [1772010]
Rebuild_FUZZ: 95.15%
commit-author Martin Blumenstingl <martin.blumenstingl@googlemail.com>
commit 034289b2d7cf29c8ddb79cf73d4886edabcff05e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/034289b2.failed

This simply moves ip101a_g_config_init right above
ip101a_g_config_intr so all functions for the ICPlus IP101A/G PHYs are
grouped together.
No functional changes.

	Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 034289b2d7cf29c8ddb79cf73d4886edabcff05e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/icplus.c
diff --cc drivers/net/phy/icplus.c
index 791587a49215,3d3e9134c762..000000000000
--- a/drivers/net/phy/icplus.c
+++ b/drivers/net/phy/icplus.c
@@@ -162,26 -162,6 +162,29 @@@ static int ip1001_config_init(struct ph
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int ip101a_g_config_init(struct phy_device *phydev)
 +{
 +	int c;
 +
 +	c = ip1xx_reset(phydev);
 +	if (c < 0)
 +		return c;
 +
 +	/* INTR pin used: speed/link/duplex will cause an interrupt */
 +	c = phy_write(phydev, IP101A_G_IRQ_CONF_STATUS, IP101A_G_IRQ_DEFAULT);
 +	if (c < 0)
 +		return c;
 +
 +	/* Enable Auto Power Saving mode */
 +	c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
 +	c |= IP101A_G_APS_ON;
 +
 +	return phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
 +}
 +
++=======
++>>>>>>> 034289b2d7cf (net: phy: icplus: keep all ip101a_g functions together)
  static int ip175c_read_status(struct phy_device *phydev)
  {
  	if (phydev->mdio.addr == 4) /* WAN port */
@@@ -201,6 -181,34 +204,37 @@@ static int ip175c_config_aneg(struct ph
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ip101a_g_config_init(struct phy_device *phydev)
+ {
+ 	int c;
+ 
+ 	c = ip1xx_reset(phydev);
+ 	if (c < 0)
+ 		return c;
+ 
+ 	/* Enable Auto Power Saving mode */
+ 	c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
+ 	c |= IP101A_G_APS_ON;
+ 
+ 	return phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
+ }
+ 
+ static int ip101a_g_config_intr(struct phy_device *phydev)
+ {
+ 	u16 val;
+ 
+ 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+ 		/* INTR pin used: Speed/link/duplex will cause an interrupt */
+ 		val = IP101A_G_IRQ_PIN_USED;
+ 	else
+ 		val = IP101A_G_NO_IRQ;
+ 
+ 	return phy_write(phydev, IP101A_G_IRQ_CONF_STATUS, val);
+ }
+ 
++>>>>>>> 034289b2d7cf (net: phy: icplus: keep all ip101a_g functions together)
  static int ip101a_g_ack_interrupt(struct phy_device *phydev)
  {
  	int err = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
* Unmerged path drivers/net/phy/icplus.c
