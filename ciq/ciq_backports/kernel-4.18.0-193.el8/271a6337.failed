selftests: bpf: break up test_progs - spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 271a6337cbaedfa9b93006326d0ecc28fd3dc71c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/271a6337.failed

Move spinlock prog tests into separate files.

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 271a6337cbaedfa9b93006326d0ecc28fd3dc71c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_progs.c
#	tools/testing/selftests/bpf/test_progs.h
diff --cc tools/testing/selftests/bpf/test_progs.c
index da24416535c6,e97b5b0eaf27..000000000000
--- a/tools/testing/selftests/bpf/test_progs.c
+++ b/tools/testing/selftests/bpf/test_progs.c
@@@ -1995,6 -829,63 +1995,66 @@@ static void test_flow_dissector(void
  	bpf_object__close(obj);
  }
  
++<<<<<<< HEAD
++=======
+ void *spin_lock_thread(void *arg)
+ {
+ 	__u32 duration, retval;
+ 	int err, prog_fd = *(u32 *) arg;
+ 
+ 	err = bpf_prog_test_run(prog_fd, 10000, &pkt_v4, sizeof(pkt_v4),
+ 				NULL, NULL, &retval, &duration);
+ 	CHECK(err || retval, "",
+ 	      "err %d errno %d retval %d duration %d\n",
+ 	      err, errno, retval, duration);
+ 	pthread_exit(arg);
+ }
+ 
+ static void sigalrm_handler(int s) {}
+ static struct sigaction sigalrm_action = {
+ 	.sa_handler = sigalrm_handler,
+ };
+ 
+ static void test_signal_pending(enum bpf_prog_type prog_type)
+ {
+ 	struct bpf_insn prog[4096];
+ 	struct itimerval timeo = {
+ 		.it_value.tv_usec = 100000, /* 100ms */
+ 	};
+ 	__u32 duration, retval;
+ 	int prog_fd;
+ 	int err;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(prog); i++)
+ 		prog[i] = BPF_ALU64_IMM(BPF_MOV, BPF_REG_0, 0);
+ 	prog[ARRAY_SIZE(prog) - 1] = BPF_EXIT_INSN();
+ 
+ 	prog_fd = bpf_load_program(prog_type, prog, ARRAY_SIZE(prog),
+ 				   "GPL", 0, NULL, 0);
+ 	CHECK(prog_fd < 0, "test-run", "errno %d\n", errno);
+ 
+ 	err = sigaction(SIGALRM, &sigalrm_action, NULL);
+ 	CHECK(err, "test-run-signal-sigaction", "errno %d\n", errno);
+ 
+ 	err = setitimer(ITIMER_REAL, &timeo, NULL);
+ 	CHECK(err, "test-run-signal-timer", "errno %d\n", errno);
+ 
+ 	err = bpf_prog_test_run(prog_fd, 0xffffffff, &pkt_v4, sizeof(pkt_v4),
+ 				NULL, NULL, &retval, &duration);
+ 	CHECK(duration > 500000000, /* 500ms */
+ 	      "test-run-signal-duration",
+ 	      "duration %dns > 500ms\n",
+ 	      duration);
+ 
+ 	signal(SIGALRM, SIG_DFL);
+ }
+ 
+ #define DECLARE
+ #include <prog_tests/tests.h>
+ #undef DECLARE
+ 
++>>>>>>> 271a6337cbae (selftests: bpf: break up test_progs - spinlock)
  int main(void)
  {
  	srand(time(NULL));
@@@ -2023,6 -904,8 +2083,11 @@@
  	test_queue_stack_map(QUEUE);
  	test_queue_stack_map(STACK);
  	test_flow_dissector();
++<<<<<<< HEAD
++=======
+ 	test_signal_pending(BPF_PROG_TYPE_SOCKET_FILTER);
+ 	test_signal_pending(BPF_PROG_TYPE_FLOW_DISSECTOR);
++>>>>>>> 271a6337cbae (selftests: bpf: break up test_progs - spinlock)
  
  	printf("Summary: %d PASSED, %d FAILED\n", pass_cnt, error_cnt);
  	return error_cnt ? EXIT_FAILURE : EXIT_SUCCESS;
* Unmerged path tools/testing/selftests/bpf/test_progs.h
diff --git a/tools/testing/selftests/bpf/prog_tests/map_lock.c b/tools/testing/selftests/bpf/prog_tests/map_lock.c
new file mode 100644
index 000000000000..90f8a206340a
--- /dev/null
+++ b/tools/testing/selftests/bpf/prog_tests/map_lock.c
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <test_progs.h>
+
+static void *parallel_map_access(void *arg)
+{
+	int err, map_fd = *(u32 *) arg;
+	int vars[17], i, j, rnd, key = 0;
+
+	for (i = 0; i < 10000; i++) {
+		err = bpf_map_lookup_elem_flags(map_fd, &key, vars, BPF_F_LOCK);
+		if (err) {
+			printf("lookup failed\n");
+			error_cnt++;
+			goto out;
+		}
+		if (vars[0] != 0) {
+			printf("lookup #%d var[0]=%d\n", i, vars[0]);
+			error_cnt++;
+			goto out;
+		}
+		rnd = vars[1];
+		for (j = 2; j < 17; j++) {
+			if (vars[j] == rnd)
+				continue;
+			printf("lookup #%d var[1]=%d var[%d]=%d\n",
+			       i, rnd, j, vars[j]);
+			error_cnt++;
+			goto out;
+		}
+	}
+out:
+	pthread_exit(arg);
+}
+
+void test_map_lock(void)
+{
+	const char *file = "./test_map_lock.o";
+	int prog_fd, map_fd[2], vars[17] = {};
+	pthread_t thread_id[6];
+	struct bpf_object *obj;
+	int err = 0, key = 0, i;
+	void *ret;
+
+	err = bpf_prog_load(file, BPF_PROG_TYPE_CGROUP_SKB, &obj, &prog_fd);
+	if (err) {
+		printf("test_map_lock:bpf_prog_load errno %d\n", errno);
+		goto close_prog;
+	}
+	map_fd[0] = bpf_find_map(__func__, obj, "hash_map");
+	if (map_fd[0] < 0)
+		goto close_prog;
+	map_fd[1] = bpf_find_map(__func__, obj, "array_map");
+	if (map_fd[1] < 0)
+		goto close_prog;
+
+	bpf_map_update_elem(map_fd[0], &key, vars, BPF_F_LOCK);
+
+	for (i = 0; i < 4; i++)
+		assert(pthread_create(&thread_id[i], NULL,
+				      &spin_lock_thread, &prog_fd) == 0);
+	for (i = 4; i < 6; i++)
+		assert(pthread_create(&thread_id[i], NULL,
+				      &parallel_map_access, &map_fd[i - 4]) == 0);
+	for (i = 0; i < 4; i++)
+		assert(pthread_join(thread_id[i], &ret) == 0 &&
+		       ret == (void *)&prog_fd);
+	for (i = 4; i < 6; i++)
+		assert(pthread_join(thread_id[i], &ret) == 0 &&
+		       ret == (void *)&map_fd[i - 4]);
+	goto close_prog_noerr;
+close_prog:
+	error_cnt++;
+close_prog_noerr:
+	bpf_object__close(obj);
+}
diff --git a/tools/testing/selftests/bpf/prog_tests/spinlock.c b/tools/testing/selftests/bpf/prog_tests/spinlock.c
new file mode 100644
index 000000000000..9a573a9675d7
--- /dev/null
+++ b/tools/testing/selftests/bpf/prog_tests/spinlock.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <test_progs.h>
+
+void test_spinlock(void)
+{
+	const char *file = "./test_spin_lock.o";
+	pthread_t thread_id[4];
+	struct bpf_object *obj;
+	int prog_fd;
+	int err = 0, i;
+	void *ret;
+
+	err = bpf_prog_load(file, BPF_PROG_TYPE_CGROUP_SKB, &obj, &prog_fd);
+	if (err) {
+		printf("test_spin_lock:bpf_prog_load errno %d\n", errno);
+		goto close_prog;
+	}
+	for (i = 0; i < 4; i++)
+		assert(pthread_create(&thread_id[i], NULL,
+				      &spin_lock_thread, &prog_fd) == 0);
+	for (i = 0; i < 4; i++)
+		assert(pthread_join(thread_id[i], &ret) == 0 &&
+		       ret == (void *)&prog_fd);
+	goto close_prog_noerr;
+close_prog:
+	error_cnt++;
+close_prog_noerr:
+	bpf_object__close(obj);
+}
* Unmerged path tools/testing/selftests/bpf/test_progs.c
* Unmerged path tools/testing/selftests/bpf/test_progs.h
