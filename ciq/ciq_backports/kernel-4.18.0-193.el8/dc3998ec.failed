mac80211: AMPDU handling for rekeys with Extended Key ID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Alexander Wetzel <alexander@wetzel-home.de>
commit dc3998ec5cf2d377f2e85ba16b6a15affec98a0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/dc3998ec.failed

Extended Key ID allows A-MPDU sessions while rekeying as long as each
A-MPDU aggregates only MPDUs with one keyid together.

Drivers able to segregate MPDUs accordingly can tell mac80211 to not
stop A-MPDU sessions when rekeying by setting the new flag
IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT.

	Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
Link: https://lore.kernel.org/r/20190629195015.19680-3-alexander@wetzel-home.de
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit dc3998ec5cf2d377f2e85ba16b6a15affec98a0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/mac80211.h
#	net/mac80211/debugfs.c
#	net/mac80211/key.c
diff --cc include/net/mac80211.h
index b47436ca5fea,0187d84031fc..000000000000
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@@ -2273,11 -2268,9 +2273,17 @@@ struct ieee80211_txq 
   * @IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID: Hardware supports multi BSSID
   *	only for HE APs. Applies if @IEEE80211_HW_SUPPORTS_MULTI_BSSID is set.
   *
++<<<<<<< HEAD
 + * @IEEE80211_HW_EXT_KEY_ID_NATIVE: Driver and hardware are supporting Extended
 + *	Key ID and can handle two unicast keys per station for Rx and Tx.
 + *
 + * @IEEE80211_HW_NO_AMPDU_KEYBORDER_SUPPORT: The card/driver can't handle
 + *	active Tx A-MPDU sessions with Extended Key IDs during rekey.
++=======
+  * @IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT: The card and driver is only
+  *	aggregating MPDUs with the same keyid, allowing mac80211 to keep Tx
+  *	A-MPDU sessions active while rekeying with Extended Key ID.
++>>>>>>> dc3998ec5cf2 (mac80211: AMPDU handling for rekeys with Extended Key ID)
   *
   * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
   */
@@@ -2330,8 -2323,7 +2336,12 @@@ enum ieee80211_hw_flags 
  	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,
  	IEEE80211_HW_SUPPORTS_MULTI_BSSID,
  	IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,
++<<<<<<< HEAD
 +	IEEE80211_HW_EXT_KEY_ID_NATIVE,
 +	IEEE80211_HW_NO_AMPDU_KEYBORDER_SUPPORT,
++=======
+ 	IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT,
++>>>>>>> dc3998ec5cf2 (mac80211: AMPDU handling for rekeys with Extended Key ID)
  
  	/* keep last, obviously */
  	NUM_IEEE80211_HW_FLAGS
diff --cc net/mac80211/debugfs.c
index 2e7f75938c51,568b3b276931..000000000000
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@@ -271,8 -271,7 +271,12 @@@ static const char *hw_flag_names[] = 
  	FLAG(TX_STATUS_NO_AMPDU_LEN),
  	FLAG(SUPPORTS_MULTI_BSSID),
  	FLAG(SUPPORTS_ONLY_HE_MULTI_BSSID),
++<<<<<<< HEAD
 +	FLAG(EXT_KEY_ID_NATIVE),
 +	FLAG(NO_AMPDU_KEYBORDER_SUPPORT),
++=======
+ 	FLAG(AMPDU_KEYBORDER_SUPPORT),
++>>>>>>> dc3998ec5cf2 (mac80211: AMPDU handling for rekeys with Extended Key ID)
  #undef FLAG
  };
  
diff --cc net/mac80211/key.c
index dd60f6428049,7dfee848abac..000000000000
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@@ -270,7 -270,7 +270,11 @@@ int ieee80211_set_tx_key(struct ieee802
  
  	sta->ptk_idx = key->conf.keyidx;
  
++<<<<<<< HEAD
 +	if (ieee80211_hw_check(&local->hw, NO_AMPDU_KEYBORDER_SUPPORT))
++=======
+ 	if (!ieee80211_hw_check(&local->hw, AMPDU_KEYBORDER_SUPPORT))
++>>>>>>> dc3998ec5cf2 (mac80211: AMPDU handling for rekeys with Extended Key ID)
  		clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
  	ieee80211_check_fast_xmit(sta);
  
@@@ -290,15 -290,15 +294,27 @@@ static void ieee80211_pairwise_rekey(st
  		/* Extended Key ID key install, initial one or rekey */
  
  		if (sta->ptk_idx != INVALID_PTK_KEYIDX &&
++<<<<<<< HEAD
 +		    ieee80211_hw_check(&local->hw,
 +				       NO_AMPDU_KEYBORDER_SUPPORT)) {
 +			/* Aggregation Sessions with Extended Key ID must not
 +			 * mix MPDUs with different keyIDs within one A-MPDU.
 +			 * Tear down any running Tx aggregation and all new
 +			 * Rx/Tx aggregation request during rekey if the driver
 +			 * asks us to do so. (Blocking Tx only would be
 +			 * sufficient but WLAN_STA_BLOCK_BA gets the job done
 +			 * for the few ms we need it.)
++=======
+ 		    !ieee80211_hw_check(&local->hw, AMPDU_KEYBORDER_SUPPORT)) {
+ 			/* Aggregation Sessions with Extended Key ID must not
+ 			 * mix MPDUs with different keyIDs within one A-MPDU.
+ 			 * Tear down running Tx aggregation sessions and block
+ 			 * new Rx/Tx aggregation requests during rekey to
+ 			 * ensure there are no A-MPDUs when the driver is not
+ 			 * supporting A-MPDU key borders. (Blocking Tx only
+ 			 * would be sufficient but WLAN_STA_BLOCK_BA gets the
+ 			 * job done for the few ms we need it.)
++>>>>>>> dc3998ec5cf2 (mac80211: AMPDU handling for rekeys with Extended Key ID)
  			 */
  			set_sta_flag(sta, WLAN_STA_BLOCK_BA);
  			mutex_lock(&sta->ampdu_mlme.mtx);
* Unmerged path include/net/mac80211.h
* Unmerged path net/mac80211/debugfs.c
* Unmerged path net/mac80211/key.c
