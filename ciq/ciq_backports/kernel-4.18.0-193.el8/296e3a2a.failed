IB/mlx5: Prevent concurrent MR updates during invalidation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Moni Shoua <monis@mellanox.com>
commit 296e3a2aad09d328f22e54655c3d736033fe1ae8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/296e3a2a.failed

The device requires that memory registration work requests that update the
address translation table of a MR will be fenced if posted together.  This
scenario can happen when address ranges are invalidated by the mmu in
separate concurrent calls to the invalidation callback.

We prefer to block concurrent address updates for a single MR over fencing
since making the decision if a WQE needs fencing will be more expensive
and fencing all WQEs is a too radical choice.

Further, it isn't clear that this code can even run safely concurrently,
so a lock is a safer choice.

Fixes: b4cfe447d47b ("IB/mlx5: Implement on demand paging by adding support for MMU notifiers")
Link: https://lore.kernel.org/r/20190723065733.4899-8-leon@kernel.org
	Signed-off-by: Moni Shoua <monis@mellanox.com>
	Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 296e3a2aad09d328f22e54655c3d736033fe1ae8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/odp.c
diff --cc drivers/infiniband/hw/mlx5/odp.c
index 1856795fa440,81da82050d05..000000000000
--- a/drivers/infiniband/hw/mlx5/odp.c
+++ b/drivers/infiniband/hw/mlx5/odp.c
@@@ -248,9 -246,9 +248,15 @@@ void mlx5_ib_invalidate_range(struct ib
  	 * overwrite the same MTTs.  Concurent invalidations might race us,
  	 * but they will write 0s as well, so no difference in the end result.
  	 */
++<<<<<<< HEAD
 +
 +	for (addr = start; addr < end; addr += BIT(umem->page_shift)) {
 +		idx = (addr - ib_umem_start(umem)) >> umem->page_shift;
++=======
+ 	mutex_lock(&umem_odp->umem_mutex);
+ 	for (addr = start; addr < end; addr += BIT(umem_odp->page_shift)) {
+ 		idx = (addr - ib_umem_start(umem_odp)) >> umem_odp->page_shift;
++>>>>>>> 296e3a2aad09 (IB/mlx5: Prevent concurrent MR updates during invalidation)
  		/*
  		 * Strive to write the MTTs in chunks, but avoid overwriting
  		 * non-existing MTTs. The huristic here can be improved to
* Unmerged path drivers/infiniband/hw/mlx5/odp.c
