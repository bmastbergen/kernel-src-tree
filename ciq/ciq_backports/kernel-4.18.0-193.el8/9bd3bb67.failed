mm/nvdimm: add is_ioremap_addr and use that to check ioremap address

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
commit 9bd3bb6703d8c0a5fb8aec8e3287bd55b7341dcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9bd3bb67.failed

Architectures like powerpc use different address range to map ioremap
and vmalloc range.  The memunmap() check used by the nvdimm layer was
wrongly using is_vmalloc_addr() to check for ioremap range which fails
for ppc64.  This result in ppc64 not freeing the ioremap mapping.  The
side effect of this is an unbind failure during module unload with
papr_scm nvdimm driver

Link: http://lkml.kernel.org/r/20190701134038.14165-1-aneesh.kumar@linux.ibm.com
	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
Fixes: b5beae5e224f ("powerpc/pseries: Add driver for PAPR SCM regions")
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9bd3bb6703d8c0a5fb8aec8e3287bd55b7341dcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/pgtable.h
diff --cc arch/powerpc/include/asm/pgtable.h
index 9bafb38e959e,64145751b2fd..000000000000
--- a/arch/powerpc/include/asm/pgtable.h
+++ b/arch/powerpc/include/asm/pgtable.h
@@@ -80,6 -105,55 +80,58 @@@ void mark_initmem_nx(void)
  static inline void mark_initmem_nx(void) { }
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC_DEBUG_WX
+ void ptdump_check_wx(void);
+ #else
+ static inline void ptdump_check_wx(void) { }
+ #endif
+ 
+ /*
+  * When used, PTE_FRAG_NR is defined in subarch pgtable.h
+  * so we are sure it is included when arriving here.
+  */
+ #ifdef PTE_FRAG_NR
+ static inline void *pte_frag_get(mm_context_t *ctx)
+ {
+ 	return ctx->pte_frag;
+ }
+ 
+ static inline void pte_frag_set(mm_context_t *ctx, void *p)
+ {
+ 	ctx->pte_frag = p;
+ }
+ #else
+ #define PTE_FRAG_NR		1
+ #define PTE_FRAG_SIZE_SHIFT	PAGE_SHIFT
+ #define PTE_FRAG_SIZE		(1UL << PTE_FRAG_SIZE_SHIFT)
+ 
+ static inline void *pte_frag_get(mm_context_t *ctx)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void pte_frag_set(mm_context_t *ctx, void *p)
+ {
+ }
+ #endif
+ 
+ #ifdef CONFIG_PPC64
+ #define is_ioremap_addr is_ioremap_addr
+ static inline bool is_ioremap_addr(const void *x)
+ {
+ #ifdef CONFIG_MMU
+ 	unsigned long addr = (unsigned long)x;
+ 
+ 	return addr >= IOREMAP_BASE && addr < IOREMAP_END;
+ #else
+ 	return false;
+ #endif
+ }
+ #endif /* CONFIG_PPC64 */
+ 
++>>>>>>> 9bd3bb6703d8 (mm/nvdimm: add is_ioremap_addr and use that to check ioremap address)
  #endif /* __ASSEMBLY__ */
  
  #endif /* _ASM_POWERPC_PGTABLE_H */
* Unmerged path arch/powerpc/include/asm/pgtable.h
diff --git a/include/linux/mm.h b/include/linux/mm.h
index d0cd419aec89..99d8941a6c54 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -568,6 +568,11 @@ static inline bool is_vmalloc_addr(const void *x)
 	return false;
 #endif
 }
+
+#ifndef is_ioremap_addr
+#define is_ioremap_addr(x) is_vmalloc_addr(x)
+#endif
+
 #ifdef CONFIG_MMU
 extern int is_vmalloc_or_module_addr(const void *x);
 #else
diff --git a/kernel/iomem.c b/kernel/iomem.c
index f7525e14ebc6..98950b84c50c 100644
--- a/kernel/iomem.c
+++ b/kernel/iomem.c
@@ -121,7 +121,7 @@ EXPORT_SYMBOL(memremap);
 
 void memunmap(void *addr)
 {
-	if (is_vmalloc_addr(addr))
+	if (is_ioremap_addr(addr))
 		iounmap((void __iomem *) addr);
 }
 EXPORT_SYMBOL(memunmap);
