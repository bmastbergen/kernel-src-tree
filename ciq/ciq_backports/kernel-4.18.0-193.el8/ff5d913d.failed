ceph: return -EIO if read/write against filp that lost file locks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Yan, Zheng <zyan@redhat.com>
commit ff5d913dfc7142974eb1694d5fd6284658e46bc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ff5d913d.failed

After mds evicts session, file locks get lost sliently. It's not safe to
let programs continue to do read/write.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit ff5d913dfc7142974eb1694d5fd6284658e46bc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index 25654e58a962,102192c90edd..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -2570,10 -2570,15 +2570,20 @@@ static void __take_cap_refs(struct ceph
   *
   * FIXME: how does a 0 return differ from -EAGAIN?
   */
++<<<<<<< HEAD
 +static int try_get_cap_refs(struct ceph_inode_info *ci, int need, int want,
 +			    loff_t endoff, bool nonblock, int *got)
++=======
+ enum {
+ 	NON_BLOCKING	= 1,
+ 	CHECK_FILELOCK	= 2,
+ };
+ 
+ static int try_get_cap_refs(struct inode *inode, int need, int want,
+ 			    loff_t endoff, int flags, int *got)
++>>>>>>> ff5d913dfc71 (ceph: return -EIO if read/write against filp that lost file locks)
  {
 -	struct ceph_inode_info *ci = ceph_inode(inode);
 +	struct inode *inode = &ci->vfs_inode;
  	struct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;
  	int ret = 0;
  	int have, implemented;
@@@ -2752,7 -2764,8 +2769,12 @@@ int ceph_try_get_caps(struct ceph_inode
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	ret = try_get_cap_refs(ci, need, want, 0, nonblock, got);
++=======
+ 	ret = try_get_cap_refs(inode, need, want, 0,
+ 			       (nonblock ? NON_BLOCKING : 0), got);
++>>>>>>> ff5d913dfc71 (ceph: return -EIO if read/write against filp that lost file locks)
  	return ret == -EAGAIN ? 0 : ret;
  }
  
@@@ -2761,30 -2774,35 +2783,49 @@@
   * due to a small max_size, make sure we check_max_size (and possibly
   * ask the mds) so we don't get hung up indefinitely.
   */
 -int ceph_get_caps(struct file *filp, int need, int want,
 +int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,
  		  loff_t endoff, int *got, struct page **pinned_page)
  {
++<<<<<<< HEAD
 +	int _got, ret;
++=======
+ 	struct ceph_file_info *fi = filp->private_data;
+ 	struct inode *inode = file_inode(filp);
+ 	struct ceph_inode_info *ci = ceph_inode(inode);
+ 	int ret, _got, flags;
++>>>>>>> ff5d913dfc71 (ceph: return -EIO if read/write against filp that lost file locks)
  
 -	ret = ceph_pool_perm_check(inode, need);
 +	ret = ceph_pool_perm_check(ci, need);
  	if (ret < 0)
  		return ret;
  
  	while (true) {
  		if (endoff > 0)
 -			check_max_size(inode, endoff);
 +			check_max_size(&ci->vfs_inode, endoff);
  
+ 		flags = atomic_read(&fi->num_locks) ? CHECK_FILELOCK : 0;
  		_got = 0;
++<<<<<<< HEAD
 +		ret = try_get_cap_refs(ci, need, want, endoff,
 +				       false, &_got);
++=======
+ 		ret = try_get_cap_refs(inode, need, want, endoff,
+ 				       flags, &_got);
++>>>>>>> ff5d913dfc71 (ceph: return -EIO if read/write against filp that lost file locks)
  		if (ret == -EAGAIN)
  			continue;
  		if (!ret) {
  			DEFINE_WAIT_FUNC(wait, woken_wake_function);
  			add_wait_queue(&ci->i_cap_wq, &wait);
  
++<<<<<<< HEAD
 +			while (!(ret = try_get_cap_refs(ci, need, want, endoff,
 +							true, &_got))) {
++=======
+ 			flags |= NON_BLOCKING;
+ 			while (!(ret = try_get_cap_refs(inode, need, want,
+ 							endoff, flags, &_got))) {
++>>>>>>> ff5d913dfc71 (ceph: return -EIO if read/write against filp that lost file locks)
  				if (signal_pending(current)) {
  					ret = -ERESTARTSYS;
  					break;
* Unmerged path fs/ceph/caps.c
diff --git a/fs/ceph/locks.c b/fs/ceph/locks.c
index 5083e238ad15..544e9e85b120 100644
--- a/fs/ceph/locks.c
+++ b/fs/ceph/locks.c
@@ -32,14 +32,18 @@ void __init ceph_flock_init(void)
 
 static void ceph_fl_copy_lock(struct file_lock *dst, struct file_lock *src)
 {
-	struct inode *inode = file_inode(src->fl_file);
+	struct ceph_file_info *fi = dst->fl_file->private_data;
+	struct inode *inode = file_inode(dst->fl_file);
 	atomic_inc(&ceph_inode(inode)->i_filelock_ref);
+	atomic_inc(&fi->num_locks);
 }
 
 static void ceph_fl_release_lock(struct file_lock *fl)
 {
+	struct ceph_file_info *fi = fl->fl_file->private_data;
 	struct inode *inode = file_inode(fl->fl_file);
 	struct ceph_inode_info *ci = ceph_inode(inode);
+	atomic_dec(&fi->num_locks);
 	if (atomic_dec_and_test(&ci->i_filelock_ref)) {
 		/* clear error when all locks are released */
 		spin_lock(&ci->i_ceph_lock);
@@ -73,7 +77,7 @@ static int ceph_lock_message(u8 lock_type, u16 operation, struct inode *inode,
 		 * window. Caller function will decrease the counter.
 		 */
 		fl->fl_ops = &ceph_fl_lock_ops;
-		atomic_inc(&ceph_inode(inode)->i_filelock_ref);
+		fl->fl_ops->fl_copy_lock(fl, NULL);
 	}
 
 	if (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index 146f2cee5024..a5d2de2e0e0b 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -704,6 +704,7 @@ struct ceph_file_info {
 	struct list_head rw_contexts;
 
 	errseq_t meta_err;
+	atomic_t num_locks;
 };
 
 struct ceph_dir_file_info {
