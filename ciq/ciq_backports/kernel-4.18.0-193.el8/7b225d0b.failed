netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 7b225d0b5c6dda5fefab578175f210c6fc7e389a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7b225d0b.failed

Add NFTA_SET_ELEM_KEY_END attribute to convey the closing element of the
interval between kernel and userspace.

This patch also adds the NFT_SET_EXT_KEY_END extension to store the
closing element value in this interval.

v4: No changes
v3: New patch

[sbrivio: refactor error paths and labels; add corresponding
  nft_set_ext_type for new key; rebase]
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 7b225d0b5c6dda5fefab578175f210c6fc7e389a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
diff --cc include/net/netfilter/nf_tables.h
index 0d548834982e,504c0aa93805..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -628,8 -667,8 +640,13 @@@ static inline struct nft_object **nft_s
  
  void *nft_set_elem_init(const struct nft_set *set,
  			const struct nft_set_ext_tmpl *tmpl,
++<<<<<<< HEAD
 +			const u32 *key, const u32 *data,
 +			u64 timeout, gfp_t gfp);
++=======
+ 			const u32 *key, const u32 *key_end, const u32 *data,
+ 			u64 timeout, u64 expiration, gfp_t gfp);
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  void nft_set_elem_destroy(const struct nft_set *set, void *elem,
  			  bool destroy_expr);
  
diff --cc net/netfilter/nf_tables_api.c
index 04c95168b032,5f645a85538a..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3753,7 -4233,10 +3756,13 @@@ static const struct nla_policy nft_set_
  	[NFTA_SET_ELEM_USERDATA]	= { .type = NLA_BINARY,
  					    .len = NFT_USERDATA_MAXLEN },
  	[NFTA_SET_ELEM_EXPR]		= { .type = NLA_NESTED },
++<<<<<<< HEAD
 +	[NFTA_SET_ELEM_OBJREF]		= { .type = NLA_STRING },
++=======
+ 	[NFTA_SET_ELEM_OBJREF]		= { .type = NLA_STRING,
+ 					    .len = NFT_OBJ_MAXNAMELEN - 1 },
+ 	[NFTA_SET_ELEM_KEY_END]		= { .type = NLA_NESTED },
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  };
  
  static const struct nla_policy nft_set_elem_list_policy[NFTA_SET_ELEM_LIST_MAX + 1] = {
@@@ -4073,10 -4578,11 +4087,18 @@@ static int nft_get_set_elem(struct nft_
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	err = -EINVAL;
 +	if (desc.type != NFT_DATA_VALUE || desc.len != set->klen) {
 +		nft_data_release(&elem.key.val, desc.type);
 +		return err;
++=======
+ 	if (nla[NFTA_SET_ELEM_KEY_END]) {
+ 		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
+ 					    nla[NFTA_SET_ELEM_KEY_END]);
+ 		if (err < 0)
+ 			return err;
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  	}
  
  	priv = set->ops->get(ctx->net, set, &elem, flags);
@@@ -4204,8 -4710,8 +4226,13 @@@ static struct nft_trans *nft_trans_elem
  
  void *nft_set_elem_init(const struct nft_set *set,
  			const struct nft_set_ext_tmpl *tmpl,
++<<<<<<< HEAD
 +			const u32 *key, const u32 *data,
 +			u64 timeout, gfp_t gfp)
++=======
+ 			const u32 *key, const u32 *key_end,
+ 			const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  {
  	struct nft_set_ext *ext;
  	void *elem;
@@@ -4218,11 -4724,15 +4245,13 @@@
  	nft_set_ext_init(ext, tmpl);
  
  	memcpy(nft_set_ext_key(ext), key, set->klen);
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))
+ 		memcpy(nft_set_ext_key_end(ext), key_end, set->klen);
  	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
  		memcpy(nft_set_ext_data(ext), data, set->dlen);
 -	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {
 -		*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;
 -		if (expiration == 0)
 -			*nft_set_ext_expiration(ext) += timeout;
 -	}
 +	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION))
 +		*nft_set_ext_expiration(ext) =
 +			get_jiffies_64() + timeout;
  	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))
  		*nft_set_ext_timeout(ext) = timeout;
  
@@@ -4336,15 -4847,32 +4365,31 @@@ static int nft_add_set_elem(struct nft_
  		timeout = set->timeout;
  	}
  
 -	expiration = 0;
 -	if (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {
 -		if (!(set->flags & NFT_SET_TIMEOUT))
 -			return -EINVAL;
 -		err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],
 -					    &expiration);
 -		if (err)
 -			return err;
 -	}
 -
 -	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 -				    nla[NFTA_SET_ELEM_KEY]);
 +	err = nft_data_init(ctx, &elem.key.val, sizeof(elem.key), &d1,
 +			    nla[NFTA_SET_ELEM_KEY]);
  	if (err < 0)
++<<<<<<< HEAD
 +		goto err1;
 +	err = -EINVAL;
 +	if (d1.type != NFT_DATA_VALUE || d1.len != set->klen)
 +		goto err2;
 +
 +	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, d1.len);
++=======
+ 		return err;
+ 
+ 	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
+ 
+ 	if (nla[NFTA_SET_ELEM_KEY_END]) {
+ 		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
+ 					    nla[NFTA_SET_ELEM_KEY_END]);
+ 		if (err < 0)
+ 			goto err_parse_key;
+ 
+ 		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);
+ 	}
+ 
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  	if (timeout > 0) {
  		nft_set_ext_add(&tmpl, NFT_SET_EXT_EXPIRATION);
  		if (timeout != set->timeout)
@@@ -4367,14 -4895,14 +4412,19 @@@
  	}
  
  	if (nla[NFTA_SET_ELEM_DATA] != NULL) {
 -		err = nft_data_init(ctx, &data, sizeof(data), &desc,
 +		err = nft_data_init(ctx, &data, sizeof(data), &d2,
  				    nla[NFTA_SET_ELEM_DATA]);
  		if (err < 0)
- 			goto err2;
+ 			goto err_parse_key_end;
  
  		err = -EINVAL;
++<<<<<<< HEAD
 +		if (set->dtype != NFT_DATA_VERDICT && d2.len != set->dlen)
 +			goto err3;
++=======
+ 		if (set->dtype != NFT_DATA_VERDICT && desc.len != set->dlen)
+ 			goto err_parse_data;
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  
  		dreg = nft_type_to_reg(set->dtype);
  		list_for_each_entry(binding, &set->bindings, list) {
@@@ -4390,11 -4918,11 +4440,11 @@@
  
  			err = nft_validate_register_store(&bind_ctx, dreg,
  							  &data,
 -							  desc.type, desc.len);
 +							  d2.type, d2.len);
  			if (err < 0)
- 				goto err3;
+ 				goto err_parse_data;
  
 -			if (desc.type == NFT_DATA_VERDICT &&
 +			if (d2.type == NFT_DATA_VERDICT &&
  			    (data.verdict.code == NFT_GOTO ||
  			     data.verdict.code == NFT_JUMP))
  				nft_validate_state_update(ctx->net,
@@@ -4417,10 -4945,11 +4467,16 @@@
  	}
  
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data, data.data,
 +				      timeout, GFP_KERNEL);
++=======
+ 	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,
+ 				      elem.key_end.val.data, data.data,
+ 				      timeout, expiration, GFP_KERNEL);
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  	if (elem.priv == NULL)
- 		goto err3;
+ 		goto err_parse_data;
  
  	ext = nft_set_elem_ext(set, elem.priv);
  	if (flags)
@@@ -4482,12 -5011,14 +4538,21 @@@ err_trans
  	if (obj)
  		obj->use--;
  	kfree(elem.priv);
- err3:
+ err_parse_data:
  	if (nla[NFTA_SET_ELEM_DATA] != NULL)
++<<<<<<< HEAD
 +		nft_data_release(&data, d2.type);
 +err2:
 +	nft_data_release(&elem.key.val, d1.type);
 +err1:
++=======
+ 		nft_data_release(&data, desc.type);
+ err_parse_key_end:
+ 	nft_data_release(&elem.key_end.val, NFT_DATA_VALUE);
+ err_parse_key:
+ 	nft_data_release(&elem.key.val, NFT_DATA_VALUE);
+ 
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  	return err;
  }
  
@@@ -4607,22 -5136,28 +4672,36 @@@ static int nft_del_setelem(struct nft_c
  	if (flags != 0)
  		nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
  
 -	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 -				    nla[NFTA_SET_ELEM_KEY]);
 +	err = nft_data_init(ctx, &elem.key.val, sizeof(elem.key), &desc,
 +			    nla[NFTA_SET_ELEM_KEY]);
  	if (err < 0)
 -		return err;
 +		goto err1;
  
 -	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
 +	err = -EINVAL;
 +	if (desc.type != NFT_DATA_VALUE || desc.len != set->klen)
 +		goto err2;
 +
 +	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, desc.len);
  
+ 	if (nla[NFTA_SET_ELEM_KEY_END]) {
+ 		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
+ 					    nla[NFTA_SET_ELEM_KEY_END]);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);
+ 	}
+ 
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data, NULL, 0,
++=======
+ 	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,
+ 				      elem.key_end.val.data, NULL, 0, 0,
++>>>>>>> 7b225d0b5c6d (netfilter: nf_tables: add NFTA_SET_ELEM_KEY_END attribute)
  				      GFP_KERNEL);
  	if (elem.priv == NULL)
 -		goto fail_elem;
 +		goto err2;
  
  	ext = nft_set_elem_ext(set, elem.priv);
  	if (flags)
* Unmerged path include/net/netfilter/nf_tables.h
diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
index acbdaf82bbae..4e63c9bbcf8f 100644
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@ -365,6 +365,7 @@ enum nft_set_elem_flags {
  * @NFTA_SET_ELEM_USERDATA: user data (NLA_BINARY)
  * @NFTA_SET_ELEM_EXPR: expression (NLA_NESTED: nft_expr_attributes)
  * @NFTA_SET_ELEM_OBJREF: stateful object reference (NLA_STRING)
+ * @NFTA_SET_ELEM_KEY_END: closing key value (NLA_NESTED: nft_data)
  */
 enum nft_set_elem_attributes {
 	NFTA_SET_ELEM_UNSPEC,
@@ -377,6 +378,7 @@ enum nft_set_elem_attributes {
 	NFTA_SET_ELEM_EXPR,
 	NFTA_SET_ELEM_PAD,
 	NFTA_SET_ELEM_OBJREF,
+	NFTA_SET_ELEM_KEY_END,
 	__NFTA_SET_ELEM_MAX
 };
 #define NFTA_SET_ELEM_MAX	(__NFTA_SET_ELEM_MAX - 1)
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_dynset.c b/net/netfilter/nft_dynset.c
index 27d7e4598ab6..9b6f3042c6b0 100644
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@ -41,7 +41,7 @@ static void *nft_dynset_new(struct nft_set *set, const struct nft_expr *expr,
 
 	timeout = priv->timeout ? : set->timeout;
 	elem = nft_set_elem_init(set, &priv->tmpl,
-				 &regs->data[priv->sreg_key],
+				 &regs->data[priv->sreg_key], NULL,
 				 &regs->data[priv->sreg_data],
 				 timeout, GFP_ATOMIC);
 	if (elem == NULL)
