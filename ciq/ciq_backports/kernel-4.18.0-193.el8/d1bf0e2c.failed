net/mlx5: Report devlink health on FW issues

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Report devlink health on FW issues (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 95.24%
commit-author Moshe Shemesh <moshe@mellanox.com>
commit d1bf0e2cc4a6e66c2bff48176b8b2930098468ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d1bf0e2c.failed

Use devlink_health_report() to report any symptom of FW issue as FW
counter miss or new health syndrome.
The FW issues detected in mlx5 during poll_health which is called in
timer atomic context and so health work queue is used to schedule the
reports.

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d1bf0e2cc4a6e66c2bff48176b8b2930098468ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index fa1691ba661a,5e876f1de114..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -259,6 -406,138 +259,141 @@@ mlx5_fw_reporter_diagnose(struct devlin
  	return devlink_fmsg_string_pair_put(fmsg, "Description", hsynd_str(synd));
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5_fw_reporter_ctx {
+ 	u8 err_synd;
+ 	int miss_counter;
+ };
+ 
+ static int
+ mlx5_fw_reporter_ctx_pairs_put(struct devlink_fmsg *fmsg,
+ 			       struct mlx5_fw_reporter_ctx *fw_reporter_ctx)
+ {
+ 	int err;
+ 
+ 	err = devlink_fmsg_u8_pair_put(fmsg, "syndrome",
+ 				       fw_reporter_ctx->err_synd);
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u32_pair_put(fmsg, "fw_miss_counter",
+ 					fw_reporter_ctx->miss_counter);
+ 	if (err)
+ 		return err;
+ 	return 0;
+ }
+ 
+ static int
+ mlx5_fw_reporter_heath_buffer_data_put(struct mlx5_core_dev *dev,
+ 				       struct devlink_fmsg *fmsg)
+ {
+ 	struct mlx5_core_health *health = &dev->priv.health;
+ 	struct health_buffer __iomem *h = health->health;
+ 	int err;
+ 	int i;
+ 
+ 	if (!ioread8(&h->synd))
+ 		return 0;
+ 
+ 	err = devlink_fmsg_pair_nest_start(fmsg, "health buffer");
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_obj_nest_start(fmsg);
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_arr_pair_nest_start(fmsg, "assert_var");
+ 	if (err)
+ 		return err;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(h->assert_var); i++) {
+ 		err = devlink_fmsg_u32_put(fmsg, ioread32be(h->assert_var + i));
+ 		if (err)
+ 			return err;
+ 	}
+ 	err = devlink_fmsg_arr_pair_nest_end(fmsg);
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u32_pair_put(fmsg, "assert_exit_ptr",
+ 					ioread32be(&h->assert_exit_ptr));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u32_pair_put(fmsg, "assert_callra",
+ 					ioread32be(&h->assert_callra));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u32_pair_put(fmsg, "hw_id", ioread32be(&h->hw_id));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u8_pair_put(fmsg, "irisc_index",
+ 				       ioread8(&h->irisc_index));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u8_pair_put(fmsg, "synd", ioread8(&h->synd));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u32_pair_put(fmsg, "ext_synd",
+ 					ioread16be(&h->ext_synd));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_u32_pair_put(fmsg, "raw_fw_ver",
+ 					ioread32be(&h->fw_ver));
+ 	if (err)
+ 		return err;
+ 	err = devlink_fmsg_obj_nest_end(fmsg);
+ 	if (err)
+ 		return err;
+ 	return devlink_fmsg_pair_nest_end(fmsg);
+ }
+ 
+ static int
+ mlx5_fw_reporter_dump(struct devlink_health_reporter *reporter,
+ 		      struct devlink_fmsg *fmsg, void *priv_ctx)
+ {
+ 	struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);
+ 	int err;
+ 
+ 	err = mlx5_fw_tracer_trigger_core_dump_general(dev);
+ 	if (err)
+ 		return err;
+ 
+ 	if (priv_ctx) {
+ 		struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;
+ 
+ 		err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	err = mlx5_fw_reporter_heath_buffer_data_put(dev, fmsg);
+ 	if (err)
+ 		return err;
+ 	return mlx5_fw_tracer_get_saved_traces_objects(dev->tracer, fmsg);
+ }
+ 
+ static void mlx5_fw_reporter_err_work(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reporter_ctx fw_reporter_ctx;
+ 	struct mlx5_core_health *health;
+ 
+ 	health = container_of(work, struct mlx5_core_health, report_work);
+ 
+ 	if (IS_ERR_OR_NULL(health->fw_reporter))
+ 		return;
+ 
+ 	fw_reporter_ctx.err_synd = health->synd;
+ 	fw_reporter_ctx.miss_counter = health->miss_counter;
+ 	if (fw_reporter_ctx.err_synd) {
+ 		devlink_health_report(health->fw_reporter,
+ 				      "FW syndrom reported", &fw_reporter_ctx);
+ 		return;
+ 	}
+ 	if (fw_reporter_ctx.miss_counter)
+ 		devlink_health_report(health->fw_reporter,
+ 				      "FW miss counter reported",
+ 				      &fw_reporter_ctx);
+ }
+ 
++>>>>>>> d1bf0e2cc4a6 (net/mlx5: Report devlink health on FW issues)
  static const struct devlink_health_reporter_ops mlx5_fw_reporter_ops = {
  		.name = "fw",
  		.diagnose = mlx5_fw_reporter_diagnose,
@@@ -316,6 -595,9 +451,12 @@@ static void poll_health(struct timer_li
  {
  	struct mlx5_core_dev *dev = from_timer(dev, t, priv.health.timer);
  	struct mlx5_core_health *health = &dev->priv.health;
++<<<<<<< HEAD
++=======
+ 	struct health_buffer __iomem *h = health->health;
+ 	u32 fatal_error;
+ 	u8 prev_synd;
++>>>>>>> d1bf0e2cc4a6 (net/mlx5: Report devlink health on FW issues)
  	u32 count;
  
  	if (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)
@@@ -329,12 -611,21 +470,26 @@@
  
  	health->prev = count;
  	if (health->miss_counter == MAX_MISSES) {
 -		mlx5_core_err(dev, "device's health compromised - reached miss count\n");
 +		dev_err(&dev->pdev->dev, "device's health compromised - reached miss count\n");
  		print_health_info(dev);
+ 		queue_work(health->wq, &health->report_work);
  	}
  
++<<<<<<< HEAD
 +	if (in_fatal(dev) && !health->sick) {
 +		health->sick = true;
++=======
+ 	prev_synd = health->synd;
+ 	health->synd = ioread8(&h->synd);
+ 	if (health->synd && health->synd != prev_synd)
+ 		queue_work(health->wq, &health->report_work);
+ 
+ 	fatal_error = check_fatal_sensors(dev);
+ 
+ 	if (fatal_error && !health->fatal_error) {
+ 		mlx5_core_err(dev, "Fatal error %u detected\n", fatal_error);
+ 		dev->priv.health.fatal_error = fatal_error;
++>>>>>>> d1bf0e2cc4a6 (net/mlx5: Report devlink health on FW issues)
  		print_health_info(dev);
  		mlx5_trigger_health_work(dev);
  	}
@@@ -380,9 -669,8 +535,13 @@@ void mlx5_drain_health_wq(struct mlx5_c
  
  	spin_lock_irqsave(&health->wq_lock, flags);
  	set_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);
 +	set_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags);
  	spin_unlock_irqrestore(&health->wq_lock, flags);
++<<<<<<< HEAD
 +	cancel_delayed_work_sync(&health->recover_work);
++=======
+ 	cancel_work_sync(&health->report_work);
++>>>>>>> d1bf0e2cc4a6 (net/mlx5: Report devlink health on FW issues)
  	cancel_work_sync(&health->work);
  }
  
@@@ -423,7 -707,7 +582,11 @@@ int mlx5_health_init(struct mlx5_core_d
  		return -ENOMEM;
  	spin_lock_init(&health->wq_lock);
  	INIT_WORK(&health->work, health_care);
++<<<<<<< HEAD
 +	INIT_DELAYED_WORK(&health->recover_work, health_recover);
++=======
+ 	INIT_WORK(&health->report_work, mlx5_fw_reporter_err_work);
++>>>>>>> d1bf0e2cc4a6 (net/mlx5: Report devlink health on FW issues)
  
  	mlx5_fw_reporter_create(dev);
  
diff --cc include/linux/mlx5/driver.h
index a8a8d169f681,1931a4080d78..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -436,7 -435,9 +436,13 @@@ struct mlx5_core_health 
  	struct timer_list		timer;
  	u32				prev;
  	int				miss_counter;
++<<<<<<< HEAD
 +	bool				sick;
++=======
+ 	u8				synd;
+ 	u32				fatal_error;
+ 	u32				crdump_size;
++>>>>>>> d1bf0e2cc4a6 (net/mlx5: Report devlink health on FW issues)
  	/* wq spinlock to synchronize draining */
  	spinlock_t			wq_lock;
  	struct workqueue_struct	       *wq;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
* Unmerged path include/linux/mlx5/driver.h
