cpu/SMT: create and export cpu_smt_possible()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit e1572f1d08be57a5412a464cff0712a23cd0b73e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e1572f1d.failed

KVM needs to know if SMT is theoretically possible, this means it is
supported and not forcefully disabled ('nosmt=force'). Create and
export cpu_smt_possible() answering this question.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e1572f1d08be57a5412a464cff0712a23cd0b73e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpu.h
diff --cc include/linux/cpu.h
index 6cfffca81e56,d0633ebdaa9c..000000000000
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@@ -200,10 -201,16 +200,22 @@@ enum cpuhp_smt_control 
  extern enum cpuhp_smt_control cpu_smt_control;
  extern void cpu_smt_disable(bool force);
  extern void cpu_smt_check_topology(void);
++<<<<<<< HEAD
++=======
+ extern bool cpu_smt_possible(void);
+ extern int cpuhp_smt_enable(void);
+ extern int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval);
++>>>>>>> e1572f1d08be (cpu/SMT: create and export cpu_smt_possible())
  #else
 -# define cpu_smt_control		(CPU_SMT_NOT_IMPLEMENTED)
 +# define cpu_smt_control		(CPU_SMT_NOT_SUPPORTED)
  static inline void cpu_smt_disable(bool force) { }
  static inline void cpu_smt_check_topology(void) { }
++<<<<<<< HEAD
++=======
+ static inline bool cpu_smt_possible(void) { return false; }
+ static inline int cpuhp_smt_enable(void) { return 0; }
+ static inline int cpuhp_smt_disable(enum cpuhp_smt_control ctrlval) { return 0; }
++>>>>>>> e1572f1d08be (cpu/SMT: create and export cpu_smt_possible())
  #endif
  
  /*
* Unmerged path include/linux/cpu.h
diff --git a/kernel/cpu.c b/kernel/cpu.c
index b0f6c3eacd7b..0043786856d5 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -371,8 +371,7 @@ enum cpuhp_smt_control cpu_smt_control __read_mostly = CPU_SMT_ENABLED;
 
 void __init cpu_smt_disable(bool force)
 {
-	if (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||
-		cpu_smt_control == CPU_SMT_NOT_SUPPORTED)
+	if (!cpu_smt_possible())
 		return;
 
 	if (force) {
@@ -416,6 +415,14 @@ static inline bool cpu_smt_allowed(unsigned int cpu)
 	 */
 	return !per_cpu(cpuhp_state, cpu).booted_once;
 }
+
+/* Returns true if SMT is not supported of forcefully (irreversibly) disabled */
+bool cpu_smt_possible(void)
+{
+	return cpu_smt_control != CPU_SMT_FORCE_DISABLED &&
+		cpu_smt_control != CPU_SMT_NOT_SUPPORTED;
+}
+EXPORT_SYMBOL_GPL(cpu_smt_possible);
 #else
 static inline bool cpu_smt_allowed(unsigned int cpu) { return true; }
 #endif
