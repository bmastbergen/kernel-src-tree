bpf: Introduce bpf_sysctl_get_name helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrey Ignatov <rdna@fb.com>
commit 808649fb787d918a48a360a668ee4ee9023f0c11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/808649fb.failed

Add bpf_sysctl_get_name() helper to copy sysctl name (/proc/sys/ entry)
into provided by BPF_PROG_TYPE_CGROUP_SYSCTL program buffer.

By default full name (w/o /proc/sys/) is copied, e.g. "net/ipv4/tcp_mem".

If BPF_F_SYSCTL_BASE_NAME flag is set, only base name will be copied,
e.g. "tcp_mem".

Documentation for the new helper is provided in bpf.h UAPI.

	Signed-off-by: Andrey Ignatov <rdna@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 808649fb787d918a48a360a668ee4ee9023f0c11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/cgroup.c
diff --cc include/uapi/linux/bpf.h
index 6d4bc9ebe78a,9c8a2f3ccb9b..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2463,11 -2469,59 +2463,62 @@@ union bpf_attr 
   *
   * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
   *	Description
 - *		Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
 - *		**bpf_sk_release**\ () is unnecessary and not allowed.
 + *		Return a **struct bpf_sock** pointer in TCP_LISTEN state.
 + *		bpf_sk_release() is unnecessary and not allowed.
   *	Return
 - *		A **struct bpf_sock** pointer on success, or **NULL** in
 + *		A **struct bpf_sock** pointer on success, or NULL in
   *		case of failure.
++<<<<<<< HEAD
++=======
+  *
+  * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		This function is identical to bpf_sk_lookup_tcp, except that it
+  *		also returns timewait or request sockets. Use bpf_sk_fullsock
+  *		or bpf_tcp_socket to access the full structure.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * int bpf_tcp_check_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  * 	Description
+  * 		Check whether iph and th contain a valid SYN cookie ACK for
+  * 		the listening socket in sk.
+  *
+  * 		iph points to the start of the IPv4 or IPv6 header, while
+  * 		iph_len contains sizeof(struct iphdr) or sizeof(struct ip6hdr).
+  *
+  * 		th points to the start of the TCP header, while th_len contains
+  * 		sizeof(struct tcphdr).
+  *
+  * 	Return
+  * 		0 if iph and th are a valid SYN cookie ACK, or a negative error
+  * 		otherwise.
+  *
+  * int bpf_sysctl_get_name(struct bpf_sysctl *ctx, char *buf, size_t buf_len, u64 flags)
+  *	Description
+  *		Get name of sysctl in /proc/sys/ and copy it into provided by
+  *		program buffer *buf* of size *buf_len*.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *
+  *		If *flags* is zero, full name (e.g. "net/ipv4/tcp_mem") is
+  *		copied. Use **BPF_F_SYSCTL_BASE_NAME** flag to copy base name
+  *		only (e.g. "tcp_mem").
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
++>>>>>>> 808649fb787d (bpf: Introduce bpf_sysctl_get_name helper)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -2568,7 -2622,10 +2619,14 @@@
  	FN(sk_fullsock),		\
  	FN(tcp_sock),			\
  	FN(skb_ecn_set_ce),		\
++<<<<<<< HEAD
 +	FN(get_listener_sock),
++=======
+ 	FN(get_listener_sock),		\
+ 	FN(skc_lookup_tcp),		\
+ 	FN(tcp_check_syncookie),	\
+ 	FN(sysctl_get_name),
++>>>>>>> 808649fb787d (bpf: Introduce bpf_sysctl_get_name helper)
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
   * function eBPF program intends to call
diff --cc kernel/bpf/cgroup.c
index 7d9c426bf2c7,a68387043244..000000000000
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@@ -11,7 -11,10 +11,12 @@@
  #include <linux/kernel.h>
  #include <linux/atomic.h>
  #include <linux/cgroup.h>
 -#include <linux/filter.h>
  #include <linux/slab.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sysctl.h>
+ #include <linux/string.h>
++>>>>>>> 808649fb787d (bpf: Introduce bpf_sysctl_get_name helper)
  #include <linux/bpf.h>
  #include <linux/bpf-cgroup.h>
  #include <net/sock.h>
@@@ -811,3 -771,160 +816,163 @@@ const struct bpf_verifier_ops cg_dev_ve
  	.get_func_proto		= cgroup_dev_func_proto,
  	.is_valid_access	= cgroup_dev_is_valid_access,
  };
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * __cgroup_bpf_run_filter_sysctl - Run a program on sysctl
+  *
+  * @head: sysctl table header
+  * @table: sysctl table
+  * @write: sysctl is being read (= 0) or written (= 1)
+  * @type: type of program to be executed
+  *
+  * Program is run when sysctl is being accessed, either read or written, and
+  * can allow or deny such access.
+  *
+  * This function will return %-EPERM if an attached program is found and
+  * returned value != 1 during execution. In all other cases 0 is returned.
+  */
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   enum bpf_attach_type type)
+ {
+ 	struct bpf_sysctl_kern ctx = {
+ 		.head = head,
+ 		.table = table,
+ 		.write = write,
+ 	};
+ 	struct cgroup *cgrp;
+ 	int ret;
+ 
+ 	rcu_read_lock();
+ 	cgrp = task_dfl_cgroup(current);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);
+ 	rcu_read_unlock();
+ 
+ 	return ret == 1 ? 0 : -EPERM;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_sysctl);
+ 
+ static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,
+ 			      size_t *lenp)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (dir->header.parent) {
+ 		tmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);
+ 	if (ret < 0)
+ 		return ret;
+ 	*bufp += ret;
+ 	*lenp -= ret;
+ 	ret += tmp_ret;
+ 
+ 	/* Avoid leading slash. */
+ 	if (!ret)
+ 		return ret;
+ 
+ 	tmp_ret = strscpy(*bufp, "/", *lenp);
+ 	if (tmp_ret < 0)
+ 		return tmp_ret;
+ 	*bufp += tmp_ret;
+ 	*lenp -= tmp_ret;
+ 
+ 	return ret + tmp_ret;
+ }
+ 
+ BPF_CALL_4(bpf_sysctl_get_name, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len, u64, flags)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (!(flags & BPF_F_SYSCTL_BASE_NAME)) {
+ 		if (!ctx->head)
+ 			return -EINVAL;
+ 		tmp_ret = sysctl_cpy_dir(ctx->head->parent, &buf, &buf_len);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(buf, ctx->table->procname, buf_len);
+ 
+ 	return ret < 0 ? ret : tmp_ret + ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_name_proto = {
+ 	.func		= bpf_sysctl_get_name,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ static const struct bpf_func_proto *
+ sysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_sysctl_get_name:
+ 		return &bpf_sysctl_get_name_proto;
+ 	default:
+ 		return cgroup_base_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off + size > sizeof(struct bpf_sysctl) ||
+ 	    off % size || type != BPF_READ)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		bpf_ctx_record_field_size(info, size_default);
+ 		return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static u32 sysctl_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct bpf_sysctl_kern, write,
+ 				       FIELD_SIZEOF(struct bpf_sysctl_kern,
+ 						    write),
+ 				       target_size));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ const struct bpf_verifier_ops cg_sysctl_verifier_ops = {
+ 	.get_func_proto		= sysctl_func_proto,
+ 	.is_valid_access	= sysctl_is_valid_access,
+ 	.convert_ctx_access	= sysctl_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sysctl_prog_ops = {
+ };
++>>>>>>> 808649fb787d (bpf: Introduce bpf_sysctl_get_name helper)
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/cgroup.c
