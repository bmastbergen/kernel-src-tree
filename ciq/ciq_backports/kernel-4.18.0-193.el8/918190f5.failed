net: sched: flower: don't take rtnl lock for cls hw offloads API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] sched: flower: don't take rtnl lock for cls hw offloads API (Ivan Vecera) [1739606]
Rebuild_FUZZ: 95.93%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 918190f50eb630032ca0fb21f14f2e9c5c325626
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/918190f5.failed

Don't manually take rtnl lock in flower classifier before calling cls
hardware offloads API. Instead, pass rtnl lock status via 'rtnl_held'
parameter.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 918190f50eb630032ca0fb21f14f2e9c5c325626)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index 3eb4f57be10d,74221e3351c3..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -384,27 -407,28 +384,41 @@@ static void fl_destroy_filter_work(stru
  }
  
  static void fl_hw_destroy_filter(struct tcf_proto *tp, struct cls_fl_filter *f,
 -				 bool rtnl_held, struct netlink_ext_ack *extack)
 +				 struct netlink_ext_ack *extack)
  {
 +	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
++<<<<<<< HEAD
++=======
+ 	struct flow_cls_offload cls_flower = {};
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  
  	tc_cls_common_offload_init(&cls_flower.common, tp, f->flags, extack);
 -	cls_flower.command = FLOW_CLS_DESTROY;
 +	cls_flower.command = TC_CLSFLOWER_DESTROY;
  	cls_flower.cookie = (unsigned long) f;
  
++<<<<<<< HEAD
 +	tc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, false);
 +	tcf_block_offload_dec(block, &f->flags);
++=======
+ 	tc_setup_cb_destroy(block, tp, TC_SETUP_CLSFLOWER, &cls_flower, false,
+ 			    &f->flags, &f->in_hw_count, rtnl_held);
+ 
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  }
  
  static int fl_hw_replace_filter(struct tcf_proto *tp,
 -				struct cls_fl_filter *f, bool rtnl_held,
 +				struct cls_fl_filter *f,
  				struct netlink_ext_ack *extack)
  {
 +	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
 -	struct flow_cls_offload cls_flower = {};
  	bool skip_sw = tc_skip_sw(f->flags);
++<<<<<<< HEAD
 +	int err;
++=======
+ 	int err = 0;
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  
  	cls_flower.rule = flow_rule_alloc(tcf_exts_num_actions(&f->exts));
  	if (!cls_flower.rule)
@@@ -418,7 -442,8 +432,12 @@@
  	cls_flower.rule->match.key = &f->mkey;
  	cls_flower.classid = f->res.classid;
  
++<<<<<<< HEAD
 +	err = tc_setup_flow_action(&cls_flower.rule->action, &f->exts);
++=======
+ 	err = tc_setup_flow_action(&cls_flower.rule->action, &f->exts,
+ 				   rtnl_held);
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  	if (err) {
  		kfree(cls_flower.rule);
  		if (skip_sw) {
@@@ -428,15 -453,14 +447,26 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	err = tc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, skip_sw);
 +	kfree(cls_flower.rule);
 +
 +	if (err < 0) {
 +		fl_hw_destroy_filter(tp, f, NULL);
 +		return err;
 +	} else if (err > 0) {
 +		f->in_hw_count = err;
 +		tcf_block_offload_inc(block, &f->flags);
++=======
+ 	err = tc_setup_cb_add(block, tp, TC_SETUP_CLSFLOWER, &cls_flower,
+ 			      skip_sw, &f->flags, &f->in_hw_count, rtnl_held);
+ 	tc_cleanup_flow_action(&cls_flower.rule->action);
+ 	kfree(cls_flower.rule);
+ 
+ 	if (err) {
+ 		fl_hw_destroy_filter(tp, f, rtnl_held, NULL);
+ 		return err;
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  	}
  
  	if (skip_sw && !(f->flags & TCA_CLS_FLAGS_IN_HW))
@@@ -445,17 -469,19 +475,26 @@@
  	return 0;
  }
  
 -static void fl_hw_update_stats(struct tcf_proto *tp, struct cls_fl_filter *f,
 -			       bool rtnl_held)
 +static void fl_hw_update_stats(struct tcf_proto *tp, struct cls_fl_filter *f)
  {
 +	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
++<<<<<<< HEAD
++=======
+ 	struct flow_cls_offload cls_flower = {};
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  
  	tc_cls_common_offload_init(&cls_flower.common, tp, f->flags, NULL);
 -	cls_flower.command = FLOW_CLS_STATS;
 +	cls_flower.command = TC_CLSFLOWER_STATS;
  	cls_flower.cookie = (unsigned long) f;
  	cls_flower.classid = f->res.classid;
  
++<<<<<<< HEAD
 +	tc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, false);
++=======
+ 	tc_setup_cb_call(block, TC_SETUP_CLSFLOWER, &cls_flower, false,
+ 			 rtnl_held);
++>>>>>>> 918190f50eb6 (net: sched: flower: don't take rtnl lock for cls hw offloads API)
  
  	tcf_exts_stats_update(&f->exts, cls_flower.stats.bytes,
  			      cls_flower.stats.pkts,
* Unmerged path net/sched/cls_flower.c
