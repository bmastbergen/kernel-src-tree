arm64: errata: Add workaround for Cortex-A76 erratum #1463225

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Will Deacon <will.deacon@arm.com>
commit 969f5ea627570e91c9d54403287ee3ed657f58fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/969f5ea6.failed

Revisions of the Cortex-A76 CPU prior to r4p0 are affected by an erratum
that can prevent interrupts from being taken when single-stepping.

This patch implements a software workaround to prevent userspace from
effectively being able to disable interrupts.

	Cc: <stable@vger.kernel.org>
	Cc: Marc Zyngier <marc.zyngier@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit 969f5ea627570e91c9d54403287ee3ed657f58fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/arm64/silicon-errata.txt
#	arch/arm64/Kconfig
#	arch/arm64/include/asm/cpucaps.h
#	arch/arm64/kernel/cpu_errata.c
#	arch/arm64/mm/fault.c
diff --cc Documentation/arm64/silicon-errata.txt
index e311dab9df6a,b29a32805ad0..000000000000
--- a/Documentation/arm64/silicon-errata.txt
+++ b/Documentation/arm64/silicon-errata.txt
@@@ -58,6 -60,9 +58,12 @@@ stable kernels
  | ARM            | Cortex-A55      | #1024718        | ARM64_ERRATUM_1024718       |
  | ARM            | Cortex-A76      | #1188873        | ARM64_ERRATUM_1188873       |
  | ARM            | Cortex-A76      | #1165522        | ARM64_ERRATUM_1165522       |
++<<<<<<< HEAD
++=======
+ | ARM            | Cortex-A76      | #1286807        | ARM64_ERRATUM_1286807       |
+ | ARM            | Neoverse-N1     | #1188873        | ARM64_ERRATUM_1188873       |
+ | ARM            | Cortex-A76      | #1463225        | ARM64_ERRATUM_1463225       |
++>>>>>>> 969f5ea62757 (arm64: errata: Add workaround for Cortex-A76 erratum #1463225)
  | ARM            | MMU-500         | #841119,#826419 | N/A                         |
  |                |                 |                 |                             |
  | Cavium         | ThunderX ITS    | #22375, #24313  | CAVIUM_ERRATUM_22375        |
diff --cc arch/arm64/Kconfig
index a2ff4c9fea5e,5d99f492869b..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -525,6 -502,42 +525,45 @@@ config ARM64_ERRATUM_116552
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
++=======
+ config ARM64_ERRATUM_1286807
+ 	bool "Cortex-A76: Modification of the translation table for a virtual address might lead to read-after-read ordering violation"
+ 	default y
+ 	select ARM64_WORKAROUND_REPEAT_TLBI
+ 	help
+ 	  This option adds a workaround for ARM Cortex-A76 erratum 1286807.
+ 
+ 	  On the affected Cortex-A76 cores (r0p0 to r3p0), if a virtual
+ 	  address for a cacheable mapping of a location is being
+ 	  accessed by a core while another core is remapping the virtual
+ 	  address to a new physical page using the recommended
+ 	  break-before-make sequence, then under very rare circumstances
+ 	  TLBI+DSB completes before a read using the translation being
+ 	  invalidated has been observed by other observers. The
+ 	  workaround repeats the TLBI+DSB operation.
+ 
+ 	  If unsure, say Y.
+ 
+ config ARM64_ERRATUM_1463225
+ 	bool "Cortex-A76: Software Step might prevent interrupt recognition"
+ 	default y
+ 	help
+ 	  This option adds a workaround for Arm Cortex-A76 erratum 1463225.
+ 
+ 	  On the affected Cortex-A76 cores (r0p0 to r3p1), software stepping
+ 	  of a system call instruction (SVC) can prevent recognition of
+ 	  subsequent interrupts when software stepping is disabled in the
+ 	  exception handler of the system call and either kernel debugging
+ 	  is enabled or VHE is in use.
+ 
+ 	  Work around the erratum by triggering a dummy step exception
+ 	  when handling a system call from a task that is being stepped
+ 	  in a VHE configuration of the kernel.
+ 
+ 	  If unsure, say Y.
+ 
++>>>>>>> 969f5ea62757 (arm64: errata: Add workaround for Cortex-A76 erratum #1463225)
  config CAVIUM_ERRATUM_22375
  	bool "Cavium erratum 22375, 24313"
  	default y
diff --cc arch/arm64/include/asm/cpucaps.h
index 1a8df16d556c,73faee64e498..000000000000
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@@ -51,11 -51,19 +51,24 @@@
  #define ARM64_SSBD				30
  #define ARM64_MISMATCHED_CACHE_TYPE		31
  #define ARM64_HAS_STAGE2_FWB			32
 -#define ARM64_HAS_CRC32				33
 +#define ARM64_WORKAROUND_1188873		33
  #define ARM64_SSBS				34
 -#define ARM64_WORKAROUND_1188873		35
 +#define ARM64_WORKAROUND_1165522		35
  #define ARM64_HAS_SB				36
++<<<<<<< HEAD
 +
 +#define ARM64_NCAPS				37
++=======
+ #define ARM64_WORKAROUND_1165522		37
+ #define ARM64_HAS_ADDRESS_AUTH_ARCH		38
+ #define ARM64_HAS_ADDRESS_AUTH_IMP_DEF		39
+ #define ARM64_HAS_GENERIC_AUTH_ARCH		40
+ #define ARM64_HAS_GENERIC_AUTH_IMP_DEF		41
+ #define ARM64_HAS_IRQ_PRIO_MASKING		42
+ #define ARM64_HAS_DCPODP			43
+ #define ARM64_WORKAROUND_1463225		44
+ 
+ #define ARM64_NCAPS				45
++>>>>>>> 969f5ea62757 (arm64: errata: Add workaround for Cortex-A76 erratum #1463225)
  
  #endif /* __ASM_CPUCAPS_H */
diff --cc arch/arm64/kernel/cpu_errata.c
index feeb8962a8d8,ac6432bfc1e4..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -502,6 -502,28 +502,31 @@@ static const struct midr_range arm64_ss
  	{},
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_1463225
+ DEFINE_PER_CPU(int, __in_cortex_a76_erratum_1463225_wa);
+ 
+ static bool
+ has_cortex_a76_erratum_1463225(const struct arm64_cpu_capabilities *entry,
+ 			       int scope)
+ {
+ 	u32 midr = read_cpuid_id();
+ 	/* Cortex-A76 r0p0 - r3p1 */
+ 	struct midr_range range = MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 3, 1);
+ 
+ 	WARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());
+ 	return is_midr_in_range(midr, &range) && is_kernel_in_hyp_mode();
+ }
+ #endif
+ 
+ static void __maybe_unused
+ cpu_enable_cache_maint_trap(const struct arm64_cpu_capabilities *__unused)
+ {
+ 	sysreg_clear_set(sctlr_el1, SCTLR_EL1_UCI, 0);
+ }
+ 
++>>>>>>> 969f5ea62757 (arm64: errata: Add workaround for Cortex-A76 erratum #1463225)
  #define CAP_MIDR_RANGE(model, v_min, r_min, v_max, r_max)	\
  	.matches = is_affected_midr_range,			\
  	.midr_range = MIDR_RANGE(model, v_min, r_min, v_max, r_max)
diff --cc arch/arm64/mm/fault.c
index 5f54dab9cfab,9a84a4071561..000000000000
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@@ -805,13 -810,46 +805,52 @@@ void __init hook_debug_fault_code(int n
  	debug_fault_info[nr].name	= name;
  }
  
++<<<<<<< HEAD
 +asmlinkage int __exception do_debug_exception(unsigned long addr,
 +					      unsigned int esr,
 +					      struct pt_regs *regs)
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_1463225
+ DECLARE_PER_CPU(int, __in_cortex_a76_erratum_1463225_wa);
+ 
+ static int __exception
+ cortex_a76_erratum_1463225_debug_handler(struct pt_regs *regs)
+ {
+ 	if (user_mode(regs))
+ 		return 0;
+ 
+ 	if (!__this_cpu_read(__in_cortex_a76_erratum_1463225_wa))
+ 		return 0;
+ 
+ 	/*
+ 	 * We've taken a dummy step exception from the kernel to ensure
+ 	 * that interrupts are re-enabled on the syscall path. Return back
+ 	 * to cortex_a76_erratum_1463225_svc_handler() with debug exceptions
+ 	 * masked so that we can safely restore the mdscr and get on with
+ 	 * handling the syscall.
+ 	 */
+ 	regs->pstate |= PSR_D_BIT;
+ 	return 1;
+ }
+ #else
+ static int __exception
+ cortex_a76_erratum_1463225_debug_handler(struct pt_regs *regs)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_ARM64_ERRATUM_1463225 */
+ 
+ asmlinkage void __exception do_debug_exception(unsigned long addr_if_watchpoint,
+ 					       unsigned int esr,
+ 					       struct pt_regs *regs)
++>>>>>>> 969f5ea62757 (arm64: errata: Add workaround for Cortex-A76 erratum #1463225)
  {
 -	const struct fault_info *inf = esr_to_debug_fault_info(esr);
 -	unsigned long pc = instruction_pointer(regs);
 +	const struct fault_info *inf = debug_fault_info + DBG_ESR_EVT(esr);
 +	int rv;
  
+ 	if (cortex_a76_erratum_1463225_debug_handler(regs))
+ 		return;
+ 
  	/*
  	 * Tell lockdep we disabled irqs in entry.S. Do nothing if they were
  	 * already disabled to preserve the last enabled/disabled addresses.
* Unmerged path Documentation/arm64/silicon-errata.txt
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/include/asm/cpucaps.h
* Unmerged path arch/arm64/kernel/cpu_errata.c
diff --git a/arch/arm64/kernel/syscall.c b/arch/arm64/kernel/syscall.c
index 032d22312881..646c687a2ea6 100644
--- a/arch/arm64/kernel/syscall.c
+++ b/arch/arm64/kernel/syscall.c
@@ -8,6 +8,7 @@
 #include <linux/syscalls.h>
 
 #include <asm/daifflags.h>
+#include <asm/debug-monitors.h>
 #include <asm/fpsimd.h>
 #include <asm/syscall.h>
 #include <asm/thread_info.h>
@@ -61,6 +62,35 @@ static inline bool has_syscall_work(unsigned long flags)
 int syscall_trace_enter(struct pt_regs *regs);
 void syscall_trace_exit(struct pt_regs *regs);
 
+#ifdef CONFIG_ARM64_ERRATUM_1463225
+DECLARE_PER_CPU(int, __in_cortex_a76_erratum_1463225_wa);
+
+static void cortex_a76_erratum_1463225_svc_handler(void)
+{
+	u32 reg, val;
+
+	if (!unlikely(test_thread_flag(TIF_SINGLESTEP)))
+		return;
+
+	if (!unlikely(this_cpu_has_cap(ARM64_WORKAROUND_1463225)))
+		return;
+
+	__this_cpu_write(__in_cortex_a76_erratum_1463225_wa, 1);
+	reg = read_sysreg(mdscr_el1);
+	val = reg | DBG_MDSCR_SS | DBG_MDSCR_KDE;
+	write_sysreg(val, mdscr_el1);
+	asm volatile("msr daifclr, #8");
+	isb();
+
+	/* We will have taken a single-step exception by this point */
+
+	write_sysreg(reg, mdscr_el1);
+	__this_cpu_write(__in_cortex_a76_erratum_1463225_wa, 0);
+}
+#else
+static void cortex_a76_erratum_1463225_svc_handler(void) { }
+#endif /* CONFIG_ARM64_ERRATUM_1463225 */
+
 static void el0_svc_common(struct pt_regs *regs, int scno, int sc_nr,
 			   const syscall_fn_t syscall_table[])
 {
@@ -69,6 +99,7 @@ static void el0_svc_common(struct pt_regs *regs, int scno, int sc_nr,
 	regs->orig_x0 = regs->regs[0];
 	regs->syscallno = scno;
 
+	cortex_a76_erratum_1463225_svc_handler();
 	local_daif_restore(DAIF_PROCCTX);
 	user_exit();
 
* Unmerged path arch/arm64/mm/fault.c
