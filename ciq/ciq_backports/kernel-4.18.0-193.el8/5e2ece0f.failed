ALSA: firewire-lib: code refactoring to process PCM substream

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 5e2ece0fdceb02f6c47f53bef309395701a65393
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5e2ece0f.failed

This is code refactoring to separate PCM substream processing from packet
queueing.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 5e2ece0fdceb02f6c47f53bef309395701a65393)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/amdtp-stream.c
diff --cc sound/firewire/amdtp-stream.c
index 51ab268a7513,99b89bd70bc5..000000000000
--- a/sound/firewire/amdtp-stream.c
+++ b/sound/firewire/amdtp-stream.c
@@@ -706,38 -772,42 +706,61 @@@ static void out_stream_callback(struct 
  	if (s->packet_index < 0)
  		return;
  
 -	generate_ideal_pkt_descs(s, s->pkt_descs, ctx_header, packets);
 -
  	for (i = 0; i < packets; ++i) {
++<<<<<<< HEAD
 +		u32 cycle;
++=======
+ 		const struct pkt_desc *desc = s->pkt_descs + i;
+ 		struct snd_pcm_substream *pcm;
+ 		unsigned int pcm_frames;
+ 
+ 		pcm_frames = s->process_data_blocks(s, desc->ctx_payload,
+ 				desc->data_blocks, desc->data_block_counter);
+ 
+ 		pcm = READ_ONCE(s->pcm);
+ 		if (pcm && pcm_frames > 0)
+ 			update_pcm_pointers(s, pcm, pcm_frames);
+ 	}
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = s->pkt_descs + i;
++>>>>>>> 5e2ece0fdceb (ALSA: firewire-lib: code refactoring to process PCM substream)
  		unsigned int syt;
 +		unsigned int data_blocks;
 +		__be32 *buffer;
 +		unsigned int pcm_frames;
  		struct {
  			struct fw_iso_packet params;
  			__be32 header[IT_PKT_HEADER_SIZE_CIP / sizeof(__be32)];
  		} template = { {0}, {0} };
++<<<<<<< HEAD
 +		struct snd_pcm_substream *pcm;
  
 -		if (s->ctx_data.rx.syt_override < 0)
 -			syt = desc->syt;
 -		else
 -			syt = s->ctx_data.rx.syt_override;
 +		cycle = compute_it_cycle(*ctx_header);
 +		syt = calculate_syt(s, cycle);
 +		data_blocks = calculate_data_blocks(s, syt);
 +		buffer = s->buffer.packets[s->packet_index].buffer;
 +		pcm_frames = s->process_data_blocks(s, buffer, data_blocks,
 +						    &syt);
++=======
++>>>>>>> 5e2ece0fdceb (ALSA: firewire-lib: code refactoring to process PCM substream)
  
 -		build_it_pkt_header(s, desc->cycle, &template.params,
 -				    desc->data_blocks, desc->data_block_counter,
 +		build_it_pkt_header(s, cycle, &template.params, data_blocks,
  				    syt, i);
  
  		if (queue_out_packet(s, &template.params) < 0) {
  			cancel_stream(s);
  			return;
  		}
++<<<<<<< HEAD
 +
 +		pcm = READ_ONCE(s->pcm);
 +		if (pcm && pcm_frames > 0)
 +			update_pcm_pointers(s, pcm, pcm_frames);
 +
 +		++ctx_header;
++=======
++>>>>>>> 5e2ece0fdceb (ALSA: firewire-lib: code refactoring to process PCM substream)
  	}
  
  	fw_iso_context_queue_flush(s->context);
@@@ -757,48 -829,35 +780,81 @@@ static void in_stream_callback(struct f
  	// The number of packets in buffer.
  	packets = header_length / s->ctx_data.tx.ctx_header_size;
  
++<<<<<<< HEAD
 +	for (i = 0; i < packets; i++) {
 +		u32 cycle;
 +		unsigned int payload_length;
 +		unsigned int data_blocks;
 +		unsigned int syt;
 +		__be32 *buffer;
 +		unsigned int pcm_frames = 0;
 +		struct fw_iso_packet params = {0};
 +		struct snd_pcm_substream *pcm;
 +		int err;
 +
 +		cycle = compute_cycle_count(ctx_header[1]);
 +		err = parse_ir_ctx_header(s, cycle, ctx_header, &payload_length,
 +					  &data_blocks, &syt, i);
 +		if (err < 0 && err != -EAGAIN)
 +			break;
 +
 +		if (err >= 0) {
 +			buffer = s->buffer.packets[s->packet_index].buffer;
 +			pcm_frames = s->process_data_blocks(s, buffer,
 +							    data_blocks, &syt);
 +
 +			if (!(s->flags & CIP_DBC_IS_END_EVENT)) {
 +				s->data_block_counter += data_blocks;
 +				s->data_block_counter &= 0xff;
 +			}
++=======
+ 	err = generate_device_pkt_descs(s, s->pkt_descs, ctx_header, packets);
+ 	if (err < 0) {
+ 		if (err != -EAGAIN) {
+ 			cancel_stream(s);
+ 			return;
+ 		}
+ 	} else {
+ 		for (i = 0; i < packets; ++i) {
+ 			const struct pkt_desc *desc = s->pkt_descs;
+ 			struct snd_pcm_substream *pcm;
+ 			unsigned int pcm_frames;
+ 
+ 			pcm_frames = s->process_data_blocks(s,
+ 					desc->ctx_payload, desc->data_blocks,
+ 					desc->data_block_counter);
+ 
+ 			pcm = READ_ONCE(s->pcm);
+ 			if (pcm && pcm_frames > 0)
+ 				update_pcm_pointers(s, pcm, pcm_frames);
++>>>>>>> 5e2ece0fdceb (ALSA: firewire-lib: code refactoring to process PCM substream)
  		}
+ 	}
  
+ 	for (i = 0; i < packets; ++i) {
+ 		struct fw_iso_packet params = {0};
+ 
++<<<<<<< HEAD
 +		if (queue_in_packet(s, &params) < 0)
 +			break;
 +
 +		pcm = READ_ONCE(s->pcm);
 +		if (pcm && pcm_frames > 0)
 +			update_pcm_pointers(s, pcm, pcm_frames);
 +
 +		ctx_header += s->ctx_data.tx.ctx_header_size / sizeof(*ctx_header);
 +	}
 +
 +	/* Queueing error or detecting invalid payload. */
 +	if (i < packets) {
 +		cancel_stream(s);
 +		return;
++=======
+ 		if (queue_in_packet(s, &params) < 0) {
+ 			cancel_stream(s);
+ 			return;
+ 		}
++>>>>>>> 5e2ece0fdceb (ALSA: firewire-lib: code refactoring to process PCM substream)
  	}
  
  	fw_iso_context_queue_flush(s->context);
* Unmerged path sound/firewire/amdtp-stream.c
