net/mlx5: LAG, Use affinity type enumerators

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: LAG, Use affinity type enumerators (Mohammad Heib) [1776921]
Rebuild_FUZZ: 95.24%
commit-author Erez Alfasi <ereza@mellanox.com>
commit 1cdc14e9d134a48d86673fd75a6abcbe0e58a29c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/1cdc14e9.failed

Instead of using explicit indexes, simply use affinity
type enumerators to make the code more readable.

Fixes: 544fe7c2e654 ("net/mlx5e: Activate HW multipath and handle port affinity based on FIB events")
	Signed-off-by: Erez Alfasi <ereza@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 1cdc14e9d134a48d86673fd75a6abcbe0e58a29c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
index 5633f8572800,b70afa310ad2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
@@@ -50,27 -53,27 +51,47 @@@ static void mlx5_lag_set_port_affinity(
  		return;
  
  	switch (port) {
++<<<<<<< HEAD
 +	case 0:
 +		tracker.netdev_state[0].tx_enabled = true;
 +		tracker.netdev_state[1].tx_enabled = true;
 +		tracker.netdev_state[0].link_up = true;
 +		tracker.netdev_state[1].link_up = true;
 +		break;
 +	case 1:
 +		tracker.netdev_state[0].tx_enabled = true;
 +		tracker.netdev_state[0].link_up = true;
 +		tracker.netdev_state[1].tx_enabled = false;
 +		tracker.netdev_state[1].link_up = false;
 +		break;
 +	case 2:
 +		tracker.netdev_state[0].tx_enabled = false;
 +		tracker.netdev_state[0].link_up = false;
 +		tracker.netdev_state[1].tx_enabled = true;
 +		tracker.netdev_state[1].link_up = true;
++=======
+ 	case MLX5_LAG_NORMAL_AFFINITY:
+ 		tracker.netdev_state[MLX5_LAG_P1].tx_enabled = true;
+ 		tracker.netdev_state[MLX5_LAG_P2].tx_enabled = true;
+ 		tracker.netdev_state[MLX5_LAG_P1].link_up = true;
+ 		tracker.netdev_state[MLX5_LAG_P2].link_up = true;
+ 		break;
+ 	case MLX5_LAG_P1_AFFINITY:
+ 		tracker.netdev_state[MLX5_LAG_P1].tx_enabled = true;
+ 		tracker.netdev_state[MLX5_LAG_P1].link_up = true;
+ 		tracker.netdev_state[MLX5_LAG_P2].tx_enabled = false;
+ 		tracker.netdev_state[MLX5_LAG_P2].link_up = false;
+ 		break;
+ 	case MLX5_LAG_P2_AFFINITY:
+ 		tracker.netdev_state[MLX5_LAG_P1].tx_enabled = false;
+ 		tracker.netdev_state[MLX5_LAG_P1].link_up = false;
+ 		tracker.netdev_state[MLX5_LAG_P2].tx_enabled = true;
+ 		tracker.netdev_state[MLX5_LAG_P2].link_up = true;
++>>>>>>> 1cdc14e9d134 (net/mlx5: LAG, Use affinity type enumerators)
  		break;
  	default:
 -		mlx5_core_warn(ldev->pf[MLX5_LAG_P1].dev,
 -			       "Invalid affinity port %d", port);
 +		mlx5_core_warn(ldev->pf[0].dev, "Invalid affinity port %d",
 +			       port);
  		return;
  	}
  
@@@ -174,8 -184,8 +195,13 @@@ static void mlx5_lag_fib_nexthop_event(
  			mlx5_lag_set_port_affinity(ldev, i);
  		}
  	} else if (event == FIB_EVENT_NH_ADD &&
++<<<<<<< HEAD
 +		   fi->fib_nhs == 2) {
 +		mlx5_lag_set_port_affinity(ldev, 0);
++=======
+ 		   fib_info_num_path(fi) == 2) {
+ 		mlx5_lag_set_port_affinity(ldev, MLX5_LAG_NORMAL_AFFINITY);
++>>>>>>> 1cdc14e9d134 (net/mlx5: LAG, Use affinity type enumerators)
  	}
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
index 6d14b1100be9..79be89e9c7a4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
@@ -7,6 +7,12 @@
 #include "lag.h"
 #include "mlx5_core.h"
 
+enum mlx5_lag_port_affinity {
+	MLX5_LAG_NORMAL_AFFINITY,
+	MLX5_LAG_P1_AFFINITY,
+	MLX5_LAG_P2_AFFINITY,
+};
+
 struct lag_mp {
 	struct notifier_block     fib_nb;
 	struct fib_info           *mfi; /* used in tracking fib events */
