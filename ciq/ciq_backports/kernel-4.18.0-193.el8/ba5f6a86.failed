tipc: update replicast capability for broadcast send link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Hoang Le <hoang.h.le@dektech.com.au>
commit ba5f6a8617f4cd8e77da0a190b9647065014eade
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ba5f6a86.failed

When setting up a cluster with non-replicast/replicast capability
supported. This capability will be disabled for broadcast send link
in order to be backwards compatible.

However, when these non-support nodes left and be removed out the cluster.
We don't update this capability on broadcast send link. Then, some of
features that based on this capability will also disabling as unexpected.

In this commit, we make sure the broadcast send link capabilities will
be re-calculated as soon as a node removed/rejoined a cluster.

	Acked-by: Jon Maloy <jon.maloy@ericsson.com>
	Signed-off-by: Hoang Le <hoang.h.le@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ba5f6a8617f4cd8e77da0a190b9647065014eade)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/node.c
diff --cc net/tipc/node.c
index 20f06bf18c7d,ab04e00cb95b..000000000000
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@@ -389,6 -495,10 +389,13 @@@ static struct tipc_node *tipc_node_crea
  		list_for_each_entry_rcu(temp_node, &tn->node_list, list) {
  			tn->capabilities &= temp_node->capabilities;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		tipc_bcast_toggle_rcast(net,
+ 					(tn->capabilities & TIPC_BCAST_RCAST));
+ 
++>>>>>>> ba5f6a8617f4 (tipc: update replicast capability for broadcast send link)
  		goto exit;
  	}
  	n = kzalloc(sizeof(*n), GFP_ATOMIC);
diff --git a/net/tipc/bcast.c b/net/tipc/bcast.c
index 1336f3cdad38..24633ceb7ff7 100644
--- a/net/tipc/bcast.c
+++ b/net/tipc/bcast.c
@@ -87,9 +87,9 @@ int tipc_bcast_get_mtu(struct net *net)
 	return tipc_link_mtu(tipc_bc_sndlink(net)) - INT_H_SIZE;
 }
 
-void tipc_bcast_disable_rcast(struct net *net)
+void tipc_bcast_toggle_rcast(struct net *net, bool supp)
 {
-	tipc_bc_base(net)->rcast_support = false;
+	tipc_bc_base(net)->rcast_support = supp;
 }
 
 static void tipc_bcbase_calc_bc_threshold(struct net *net)
diff --git a/net/tipc/bcast.h b/net/tipc/bcast.h
index dadad953e2be..9e847d9617d3 100644
--- a/net/tipc/bcast.h
+++ b/net/tipc/bcast.h
@@ -85,7 +85,7 @@ void tipc_bcast_remove_peer(struct net *net, struct tipc_link *rcv_bcl);
 void tipc_bcast_inc_bearer_dst_cnt(struct net *net, int bearer_id);
 void tipc_bcast_dec_bearer_dst_cnt(struct net *net, int bearer_id);
 int  tipc_bcast_get_mtu(struct net *net);
-void tipc_bcast_disable_rcast(struct net *net);
+void tipc_bcast_toggle_rcast(struct net *net, bool supp);
 int tipc_mcast_xmit(struct net *net, struct sk_buff_head *pkts,
 		    struct tipc_mc_method *method, struct tipc_nlist *dests,
 		    u16 *cong_link_cnt);
diff --git a/net/tipc/link.c b/net/tipc/link.c
index 4308f59d1174..33a471519a04 100644
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@ -540,7 +540,7 @@ bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 
 	/* Disable replicast if even a single peer doesn't support it */
 	if (link_is_bc_rcvlink(l) && !(peer_caps & TIPC_BCAST_RCAST))
-		tipc_bcast_disable_rcast(net);
+		tipc_bcast_toggle_rcast(net, false);
 
 	return true;
 }
* Unmerged path net/tipc/node.c
