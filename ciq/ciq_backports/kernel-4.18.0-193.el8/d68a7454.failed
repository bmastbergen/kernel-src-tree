drm/amd/display: Clear FEC_READY shadow register if DPCD write fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Nikola Cornij <nikola.cornij@amd.com>
commit d68a74541735e030dea56f72746cd26d19986f41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d68a7454.failed

[why]
As a fail-safe, in case 'set FEC_READY' DPCD write fails, a HW shadow
register should be cleared and the internal FEC stat should be set to
'not ready'. This is to make sure HW settings will be consistent with
FEC_READY state on the RX.

	Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
	Reviewed-by: Joshua Aberback <Joshua.Aberback@amd.com>
	Acked-by: Chris Park <Chris.Park@amd.com>
	Acked-by: Leo Li <sunpeng.li@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit d68a74541735e030dea56f72746cd26d19986f41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
diff --cc drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 6809932e80be,b512fecae061..000000000000
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@@ -2786,3 -3147,69 +2786,72 @@@ void dp_enable_mst_on_sink(struct dc_li
  
  	core_link_write_dpcd(link, DP_MSTM_CTRL, &mstmCntl, 1);
  }
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+ void dp_set_fec_ready(struct dc_link *link, bool ready)
+ {
+ 	/* FEC has to be "set ready" before the link training.
+ 	 * The policy is to always train with FEC
+ 	 * if the sink supports it and leave it enabled on link.
+ 	 * If FEC is not supported, disable it.
+ 	 */
+ 	struct link_encoder *link_enc = link->link_enc;
+ 	uint8_t fec_config = 0;
+ 
+ 	if (link->dc->debug.disable_fec ||
+ 			IS_FPGA_MAXIMUS_DC(link->ctx->dce_environment))
+ 		return;
+ 
+ 	if (link_enc->funcs->fec_set_ready &&
+ 			link->dpcd_caps.fec_cap.bits.FEC_CAPABLE) {
+ 		if (ready) {
+ 			fec_config = 1;
+ 			if (core_link_write_dpcd(link,
+ 					DP_FEC_CONFIGURATION,
+ 					&fec_config,
+ 					sizeof(fec_config)) == DC_OK) {
+ 				link_enc->funcs->fec_set_ready(link_enc, true);
+ 				link->fec_state = dc_link_fec_ready;
+ 			} else {
+ 				link->link_enc->funcs->fec_set_ready(link->link_enc, false);
+ 				link->fec_state = dc_link_fec_not_ready;
+ 				dm_error("dpcd write failed to set fec_ready");
+ 			}
+ 		} else if (link->fec_state == dc_link_fec_ready) {
+ 			fec_config = 0;
+ 			core_link_write_dpcd(link,
+ 					DP_FEC_CONFIGURATION,
+ 					&fec_config,
+ 					sizeof(fec_config));
+ 			link->link_enc->funcs->fec_set_ready(
+ 					link->link_enc, false);
+ 			link->fec_state = dc_link_fec_not_ready;
+ 		}
+ 	}
+ }
+ 
+ void dp_set_fec_enable(struct dc_link *link, bool enable)
+ {
+ 	struct link_encoder *link_enc = link->link_enc;
+ 
+ 	if (link->dc->debug.disable_fec ||
+ 			IS_FPGA_MAXIMUS_DC(link->ctx->dce_environment))
+ 		return;
+ 
+ 	if (link_enc->funcs->fec_set_enable &&
+ 			link->dpcd_caps.fec_cap.bits.FEC_CAPABLE) {
+ 		if (link->fec_state == dc_link_fec_ready && enable) {
+ 			msleep(1);
+ 			link_enc->funcs->fec_set_enable(link_enc, true);
+ 			link->fec_state = dc_link_fec_enabled;
+ 		} else if (link->fec_state == dc_link_fec_enabled && !enable) {
+ 			link_enc->funcs->fec_set_enable(link_enc, false);
+ 			link->fec_state = dc_link_fec_ready;
+ 		}
+ 	}
+ }
+ #endif
+ 
++>>>>>>> d68a74541735 (drm/amd/display: Clear FEC_READY shadow register if DPCD write fails)
* Unmerged path drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
