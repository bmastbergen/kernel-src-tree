s390/qeth: move cast type selection into fill_header()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit eca1d5c22da19abf14d27f599e787dc98b1702a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/eca1d5c2.failed

The cast type currently gets selected in .ndo_start_xmit, and is then
piped through several layers until it's stored into the HW header.
Push the selection down into qeth_l?_fill_header() to (1) reduce the
number of xmit-wide parameters, and (2) merge the two route validation
checks into just one.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eca1d5c22da19abf14d27f599e787dc98b1702a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core.h
index be5bec70fa99,c7ee07ce3615..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -1015,10 -1040,10 +1015,17 @@@ int qeth_stop(struct net_device *dev)
  
  int qeth_vm_request_mac(struct qeth_card *card);
  int qeth_xmit(struct qeth_card *card, struct sk_buff *skb,
++<<<<<<< HEAD
 +	      struct qeth_qdio_out_q *queue, int ipv, int cast_type,
 +	      void (*fill_header)(struct qeth_card *card, struct qeth_hdr *hdr,
 +				  struct sk_buff *skb, int ipv, int cast_type,
 +				  unsigned int data_len));
++=======
+ 	      struct qeth_qdio_out_q *queue, int ipv,
+ 	      void (*fill_header)(struct qeth_qdio_out_q *queue,
+ 				  struct qeth_hdr *hdr, struct sk_buff *skb,
+ 				  int ipv, unsigned int data_len));
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  
  /* exports for OSN */
  int qeth_osn_assist(struct net_device *, void *, int);
diff --cc drivers/s390/net/qeth_core_main.c
index 1455a66d3724,4d0caeebc802..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4044,10 -3908,10 +4044,17 @@@ static void qeth_fill_tso_ext(struct qe
  }
  
  int qeth_xmit(struct qeth_card *card, struct sk_buff *skb,
++<<<<<<< HEAD
 +	      struct qeth_qdio_out_q *queue, int ipv, int cast_type,
 +	      void (*fill_header)(struct qeth_card *card, struct qeth_hdr *hdr,
 +				  struct sk_buff *skb, int ipv, int cast_type,
 +				  unsigned int data_len))
++=======
+ 	      struct qeth_qdio_out_q *queue, int ipv,
+ 	      void (*fill_header)(struct qeth_qdio_out_q *queue,
+ 				  struct qeth_hdr *hdr, struct sk_buff *skb,
+ 				  int ipv, unsigned int data_len))
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  {
  	unsigned int proto_len, hw_hdr_len;
  	unsigned int frame_len = skb->len;
@@@ -4081,7 -3945,7 +4088,11 @@@
  		data_offset = push_len + proto_len;
  	}
  	memset(hdr, 0, hw_hdr_len);
++<<<<<<< HEAD
 +	fill_header(card, hdr, skb, ipv, cast_type, frame_len);
++=======
+ 	fill_header(queue, hdr, skb, ipv, frame_len);
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  	if (is_tso)
  		qeth_fill_tso_ext((struct qeth_hdr_tso *) hdr,
  				  frame_len - proto_len, skb, proto_len);
diff --cc drivers/s390/net/qeth_l2_main.c
index 26cbbcb6463c,fd64bc3f4062..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -160,24 -160,13 +160,31 @@@ static void qeth_l2_del_all_macs(struc
  		hash_del(&mac->hnode);
  		kfree(mac);
  	}
 +	spin_unlock_bh(&card->mclock);
  }
  
++<<<<<<< HEAD
 +static int qeth_l2_get_cast_type(struct qeth_card *card, struct sk_buff *skb)
 +{
 +	if (card->info.type == QETH_CARD_TYPE_OSN)
 +		return RTN_UNICAST;
 +	if (is_broadcast_ether_addr(skb->data))
 +		return RTN_BROADCAST;
 +	if (is_multicast_ether_addr(skb->data))
 +		return RTN_MULTICAST;
 +	return RTN_UNICAST;
 +}
 +
 +static void qeth_l2_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,
 +				struct sk_buff *skb, int ipv, int cast_type,
 +				unsigned int data_len)
++=======
+ static void qeth_l2_fill_header(struct qeth_qdio_out_q *queue,
+ 				struct qeth_hdr *hdr, struct sk_buff *skb,
+ 				int ipv, unsigned int data_len)
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  {
+ 	int cast_type = qeth_get_ether_cast_type(skb);
  	struct vlan_ethhdr *veth = vlan_eth_hdr(skb);
  
  	hdr->hdr.l2.pkt_length = data_len;
@@@ -618,7 -598,7 +625,11 @@@ static netdev_tx_t qeth_l2_hard_start_x
  	if (IS_OSN(card))
  		rc = qeth_l2_xmit_osn(card, skb, queue);
  	else
++<<<<<<< HEAD
 +		rc = qeth_xmit(card, skb, queue, ipv, cast_type,
++=======
+ 		rc = qeth_xmit(card, skb, queue, qeth_get_ip_version(skb),
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  			       qeth_l2_fill_header);
  
  	if (!rc) {
diff --cc drivers/s390/net/qeth_l3_main.c
index 0e3a2d122884,2dd99f103671..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1931,12 -1937,15 +1931,24 @@@ static u8 qeth_l3_cast_type_to_flag(in
  	return QETH_CAST_UNICAST;
  }
  
++<<<<<<< HEAD
 +static void qeth_l3_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,
 +				struct sk_buff *skb, int ipv, int cast_type,
 +				unsigned int data_len)
 +{
 +	struct qeth_hdr_layer3 *l3_hdr = &hdr->hdr.l3;
 +	struct vlan_ethhdr *veth = vlan_eth_hdr(skb);
++=======
+ static void qeth_l3_fill_header(struct qeth_qdio_out_q *queue,
+ 				struct qeth_hdr *hdr, struct sk_buff *skb,
+ 				int ipv, unsigned int data_len)
+ {
+ 	struct qeth_hdr_layer3 *l3_hdr = &hdr->hdr.l3;
+ 	struct vlan_ethhdr *veth = vlan_eth_hdr(skb);
+ 	struct qeth_card *card = queue->card;
+ 	struct dst_entry *dst;
+ 	int cast_type;
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  
  	hdr->hdr.l3.length = data_len;
  
@@@ -1974,24 -1982,23 +1986,32 @@@
  		hdr->hdr.l3.vlan_id = ntohs(veth->h_vlan_TCI);
  	}
  
- 	l3_hdr->flags = qeth_l3_cast_type_to_flag(cast_type);
+ 	rcu_read_lock();
++<<<<<<< HEAD
++=======
+ 	dst = qeth_dst_check_rcu(skb, ipv);
  
- 	/* OSA only: */
- 	if (!ipv) {
- 		l3_hdr->flags |= QETH_HDR_PASSTHRU;
- 		return;
- 	}
+ 	if (IS_IQD(card) && skb_get_queue_mapping(skb) != QETH_IQD_MCAST_TXQ)
+ 		cast_type = RTN_UNICAST;
+ 	else
+ 		cast_type = qeth_l3_get_cast_type_rcu(skb, dst, ipv);
+ 	l3_hdr->flags |= qeth_l3_cast_type_to_flag(cast_type);
  
- 	rcu_read_lock();
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  	if (ipv == 4) {
 -		struct rtable *rt = (struct rtable *) dst;
 +		struct rtable *rt = skb_rtable(skb);
  
  		*((__be32 *) &hdr->hdr.l3.next_hop.ipv4.addr) = (rt) ?
  				rt_nexthop(rt, ip_hdr(skb)->daddr) :
  				ip_hdr(skb)->daddr;
++<<<<<<< HEAD
 +	} else {
 +		/* IPv6 */
 +		const struct rt6_info *rt = skb_rt6_info(skb);
++=======
+ 	} else if (ipv == 6) {
+ 		struct rt6_info *rt = (struct rt6_info *) dst;
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  
  		if (rt && !ipv6_addr_any(&rt->rt6i_gateway))
  			l3_hdr->next_hop.ipv6_addr = rt->rt6i_gateway;
@@@ -2020,9 -2030,8 +2043,9 @@@ static void qeth_l3_fixup_headers(struc
  }
  
  static int qeth_l3_xmit(struct qeth_card *card, struct sk_buff *skb,
- 			struct qeth_qdio_out_q *queue, int ipv, int cast_type)
+ 			struct qeth_qdio_out_q *queue, int ipv)
  {
 +	unsigned char eth_hdr[ETH_HLEN];
  	unsigned int hw_hdr_len;
  	int rc;
  
@@@ -2036,13 -2044,7 +2059,17 @@@
  	skb_pull(skb, ETH_HLEN);
  
  	qeth_l3_fixup_headers(skb);
++<<<<<<< HEAD
 +	rc = qeth_xmit(card, skb, queue, ipv, cast_type, qeth_l3_fill_header);
 +	if (rc == -EBUSY) {
 +		/* roll back to ETH header */
 +		skb_push(skb, ETH_HLEN);
 +		skb_copy_to_linear_data(skb, eth_hdr, ETH_HLEN);
 +	}
 +	return rc;
++=======
+ 	return qeth_xmit(card, skb, queue, ipv, qeth_l3_fill_header);
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  }
  
  static netdev_tx_t qeth_l3_hard_start_xmit(struct sk_buff *skb,
@@@ -2062,38 -2066,28 +2089,43 @@@
  		    (card->options.cq == QETH_CQ_ENABLED &&
  		     skb->protocol != htons(ETH_P_AF_IUCV)))
  			goto tx_drop;
++<<<<<<< HEAD
 +	}
 +
 +	if (card->state != CARD_STATE_UP) {
 +		card->stats.tx_carrier_errors++;
 +		goto tx_drop;
++=======
+ 	} else {
+ 		queue = card->qdio.out_qs[txq];
++>>>>>>> eca1d5c22da1 (s390/qeth: move cast type selection into fill_header())
  	}
  
- 	if (cast_type == RTN_BROADCAST && !card->info.broadcast_capable)
+ 	if (!(dev->flags & IFF_BROADCAST) &&
+ 	    qeth_l3_get_cast_type(skb) == RTN_BROADCAST)
  		goto tx_drop;
  
 +	queue = qeth_get_tx_queue(card, skb, ipv, cast_type);
 +	netif_stop_queue(dev);
 +
  	if (ipv == 4 || IS_IQD(card))
- 		rc = qeth_l3_xmit(card, skb, queue, ipv, cast_type);
+ 		rc = qeth_l3_xmit(card, skb, queue, ipv);
  	else
- 		rc = qeth_xmit(card, skb, queue, ipv, cast_type,
- 			       qeth_l3_fill_header);
+ 		rc = qeth_xmit(card, skb, queue, ipv, qeth_l3_fill_header);
  
  	if (!rc) {
 -		QETH_TXQ_STAT_INC(queue, tx_packets);
 -		QETH_TXQ_STAT_ADD(queue, tx_bytes, tx_bytes);
 +		card->stats.tx_packets++;
 +		card->stats.tx_bytes += tx_bytes;
 +		netif_wake_queue(dev);
  		return NETDEV_TX_OK;
 -	}
 +	} else if (rc == -EBUSY) {
 +		return NETDEV_TX_BUSY;
 +	} /* else fall through */
  
  tx_drop:
 -	QETH_TXQ_STAT_INC(queue, tx_dropped);
 +	card->stats.tx_dropped++;
  	kfree_skb(skb);
 +	netif_wake_queue(dev);
  	return NETDEV_TX_OK;
  }
  
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
