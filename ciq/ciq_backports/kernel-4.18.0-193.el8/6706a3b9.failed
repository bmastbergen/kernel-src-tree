net/mlx5: E-Switch, Honor eswitch functions changed event cap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Honor eswitch functions changed event cap (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 96.61%
commit-author Vu Pham <vuhuong@mellanox.com>
commit 6706a3b94f890145ca09797f748d2b30e1414fd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6706a3b9.failed

Whenever device supports eswitch functions changed event, honor
such device setting. Do not limit it to ECPF.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6706a3b94f890145ca09797f748d2b30e1414fd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eq.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	include/linux/mlx5/mlx5_ifc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eq.c
index 23883d1fa22f,5e9319d3d90c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
@@@ -533,8 -533,9 +533,14 @@@ static u64 gather_async_events_mask(str
  	if (MLX5_CAP_GEN(dev, max_num_of_monitor_counters))
  		async_event_mask |= (1ull << MLX5_EVENT_TYPE_MONITOR_COUNTER);
  
++<<<<<<< HEAD
 +	if (mlx5_core_is_ecpf_esw_manager(dev))
 +		async_event_mask |= (1ull << MLX5_EVENT_TYPE_HOST_PARAMS_CHANGE);
++=======
+ 	if (mlx5_eswitch_is_funcs_handler(dev))
+ 		async_event_mask |=
+ 			(1ull << MLX5_EVENT_TYPE_ESW_FUNCTIONS_CHANGED);
++>>>>>>> 6706a3b94f89 (net/mlx5: E-Switch, Honor eswitch functions changed event cap)
  
  	return async_event_mask;
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 14d8d502a0a3,b524813cccac..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -385,6 -399,64 +385,67 @@@ bool mlx5_esw_multipath_prereq(struct m
  #define esw_debug(dev, format, ...)				\
  	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
  
++<<<<<<< HEAD
++=======
+ /* The returned number is valid only when the dev is eswitch manager. */
+ static inline u16 mlx5_eswitch_manager_vport(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_core_is_ecpf_esw_manager(dev) ?
+ 		MLX5_VPORT_ECPF : MLX5_VPORT_PF;
+ }
+ 
+ static inline bool mlx5_eswitch_is_funcs_handler(struct mlx5_core_dev *dev)
+ {
+ 	/* Ideally device should have the functions changed supported
+ 	 * capability regardless of it being ECPF or PF wherever such
+ 	 * event should be processed such as on eswitch manager device.
+ 	 * However, some ECPF based device might not have this capability
+ 	 * set. Hence OR for ECPF check to cover such device.
+ 	 */
+ 	return MLX5_CAP_ESW(dev, esw_functions_changed) ||
+ 	       mlx5_core_is_ecpf_esw_manager(dev);
+ }
+ 
+ static inline int mlx5_eswitch_uplink_idx(struct mlx5_eswitch *esw)
+ {
+ 	/* Uplink always locate at the last element of the array.*/
+ 	return esw->total_vports - 1;
+ }
+ 
+ static inline int mlx5_eswitch_ecpf_idx(struct mlx5_eswitch *esw)
+ {
+ 	return esw->total_vports - 2;
+ }
+ 
+ static inline int mlx5_eswitch_vport_num_to_index(struct mlx5_eswitch *esw,
+ 						  u16 vport_num)
+ {
+ 	if (vport_num == MLX5_VPORT_ECPF) {
+ 		if (!mlx5_ecpf_vport_exists(esw->dev))
+ 			esw_warn(esw->dev, "ECPF vport doesn't exist!\n");
+ 		return mlx5_eswitch_ecpf_idx(esw);
+ 	}
+ 
+ 	if (vport_num == MLX5_VPORT_UPLINK)
+ 		return mlx5_eswitch_uplink_idx(esw);
+ 
+ 	return vport_num;
+ }
+ 
+ static inline int mlx5_eswitch_index_to_vport_num(struct mlx5_eswitch *esw,
+ 						  int index)
+ {
+ 	if (index == mlx5_eswitch_ecpf_idx(esw) &&
+ 	    mlx5_ecpf_vport_exists(esw->dev))
+ 		return MLX5_VPORT_ECPF;
+ 
+ 	if (index == mlx5_eswitch_uplink_idx(esw))
+ 		return MLX5_VPORT_UPLINK;
+ 
+ 	return index;
+ }
+ 
++>>>>>>> 6706a3b94f89 (net/mlx5: E-Switch, Honor eswitch functions changed event cap)
  /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
  void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 5d30117c7129,05cb2fffd887..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1603,7 -1781,81 +1603,85 @@@ static void esw_offloads_steering_clean
  		esw_prio_tag_acls_cleanup(esw);
  }
  
++<<<<<<< HEAD
 +int esw_offloads_init(struct mlx5_eswitch *esw, int nvports)
++=======
+ static void esw_functions_changed_event_handler(struct work_struct *work)
+ {
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 	u16 num_vfs = 0;
+ 	int err;
+ 
+ 	host_work = container_of(work, struct mlx5_host_work, work);
+ 	esw = host_work->esw;
+ 
+ 	err = mlx5_esw_query_functions(esw->dev, &num_vfs);
+ 	if (err || num_vfs == esw->esw_funcs.num_vfs)
+ 		goto out;
+ 
+ 	/* Number of VFs can only change from "0 to x" or "x to 0". */
+ 	if (esw->esw_funcs.num_vfs > 0) {
+ 		esw_offloads_unload_vf_reps(esw, esw->esw_funcs.num_vfs);
+ 	} else {
+ 		err = esw_offloads_load_vf_reps(esw, num_vfs);
+ 
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	esw->esw_funcs.num_vfs = num_vfs;
+ 
+ out:
+ 	kfree(host_work);
+ }
+ 
+ static int esw_functions_changed_event(struct notifier_block *nb,
+ 				       unsigned long type, void *data)
+ {
+ 	struct mlx5_esw_functions *esw_funcs;
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 
+ 	host_work = kzalloc(sizeof(*host_work), GFP_ATOMIC);
+ 	if (!host_work)
+ 		return NOTIFY_DONE;
+ 
+ 	esw_funcs = mlx5_nb_cof(nb, struct mlx5_esw_functions, nb);
+ 	esw = container_of(esw_funcs, struct mlx5_eswitch, esw_funcs);
+ 
+ 	host_work->esw = esw;
+ 
+ 	INIT_WORK(&host_work->work, esw_functions_changed_event_handler);
+ 	queue_work(esw->work_queue, &host_work->work);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static void esw_functions_changed_event_init(struct mlx5_eswitch *esw,
+ 					     u16 vf_nvports)
+ {
+ 	if (!mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		return;
+ 
+ 	MLX5_NB_INIT(&esw->esw_funcs.nb, esw_functions_changed_event,
+ 		     ESW_FUNCTIONS_CHANGED);
+ 	mlx5_eq_notifier_register(esw->dev, &esw->esw_funcs.nb);
+ 	esw->esw_funcs.num_vfs = vf_nvports;
+ }
+ 
+ static void esw_functions_changed_event_cleanup(struct mlx5_eswitch *esw)
+ {
+ 	if (!mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		return;
+ 
+ 	mlx5_eq_notifier_unregister(esw->dev, &esw->esw_funcs.nb);
+ 	flush_workqueue(esw->work_queue);
+ }
+ 
+ int esw_offloads_init(struct mlx5_eswitch *esw, int vf_nvports,
+ 		      int total_nvports)
++>>>>>>> 6706a3b94f89 (net/mlx5: E-Switch, Honor eswitch functions changed event cap)
  {
  	int err;
  
@@@ -1644,10 -1899,20 +1722,23 @@@ static int esw_offloads_stop(struct mlx
  	return err;
  }
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw)
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
  {
++<<<<<<< HEAD
++=======
+ 	u16 num_vfs;
+ 
+ 	esw_functions_changed_event_cleanup(esw);
+ 
+ 	if (mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		num_vfs = esw->esw_funcs.num_vfs;
+ 	else
+ 		num_vfs = esw->dev->priv.sriov.num_vfs;
+ 
+ 	mlx5_rdma_disable_roce(esw->dev);
++>>>>>>> 6706a3b94f89 (net/mlx5: E-Switch, Honor eswitch functions changed event cap)
  	esw_offloads_devcom_cleanup(esw);
 -	esw_offloads_unload_all_reps(esw, num_vfs);
 +	esw_offloads_unload_reps(esw, nvports);
  	esw_offloads_steering_cleanup(esw);
  }
  
diff --cc include/linux/mlx5/mlx5_ifc.h
index 4c1b5622ece1,6513b985c5e9..000000000000
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@@ -665,7 -665,10 +665,14 @@@ struct mlx5_ifc_e_switch_cap_bits 
  	u8         vport_svlan_insert[0x1];
  	u8         vport_cvlan_insert_if_not_exist[0x1];
  	u8         vport_cvlan_insert_overwrite[0x1];
++<<<<<<< HEAD
 +	u8         reserved_at_5[0x17];
++=======
+ 	u8         reserved_at_5[0x14];
+ 	u8         esw_functions_changed[0x1];
+ 	u8         reserved_at_1a[0x1];
+ 	u8         ecpf_vport_exists[0x1];
++>>>>>>> 6706a3b94f89 (net/mlx5: E-Switch, Honor eswitch functions changed event cap)
  	u8         counter_eswitch_affinity[0x1];
  	u8         merged_eswitch[0x1];
  	u8         nic_vport_node_guid_modify[0x1];
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eq.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path include/linux/mlx5/mlx5_ifc.h
