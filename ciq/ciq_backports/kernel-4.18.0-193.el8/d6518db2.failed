net/mlx5: E-Switch, Use vport index when init rep

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Use vport index when init rep (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 95.74%
commit-author Bodong Wang <bodong@mellanox.com>
commit d6518db278ed64561aa58f74ef5f3ee2f9dbe546
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d6518db2.failed

Driver is referring to the array index when doing rep initialization,
using vport is confusing as it's normally interpreted as vport number.

This patch doesn't change any functionality.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d6518db278ed64561aa58f74ef5f3ee2f9dbe546)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,bc639a846714..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1208,10 -1397,9 +1208,15 @@@ int esw_offloads_init_reps(struct mlx5_
  {
  	int total_vports = MLX5_TOTAL_VPORTS(esw->dev);
  	struct mlx5_core_dev *dev = esw->dev;
 +	struct mlx5_esw_offload *offloads;
  	struct mlx5_eswitch_rep *rep;
++<<<<<<< HEAD
 +	u8 hw_id[ETH_ALEN];
 +	int vport;
++=======
+ 	u8 hw_id[ETH_ALEN], rep_type;
+ 	int vport_index;
++>>>>>>> d6518db278ed (net/mlx5: E-Switch, Use vport index when init rep)
  
  	esw->offloads.vport_reps = kcalloc(total_vports,
  					   sizeof(struct mlx5_eswitch_rep),
@@@ -1219,37 -1407,57 +1224,42 @@@
  	if (!esw->offloads.vport_reps)
  		return -ENOMEM;
  
 +	offloads = &esw->offloads;
  	mlx5_query_nic_vport_mac_address(dev, 0, hw_id);
  
++<<<<<<< HEAD
 +	for (vport = 0; vport < total_vfs; vport++) {
 +		rep = &offloads->vport_reps[vport];
 +
 +		rep->vport = vport;
++=======
+ 	mlx5_esw_for_all_reps(esw, vport_index, rep) {
+ 		rep->vport = mlx5_eswitch_index_to_vport_num(esw, vport_index);
++>>>>>>> d6518db278ed (net/mlx5: E-Switch, Use vport index when init rep)
  		ether_addr_copy(rep->hw_id, hw_id);
 -
 -		for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
 -			atomic_set(&rep->rep_data[rep_type].state,
 -				   REP_UNREGISTERED);
  	}
  
 -	return 0;
 -}
 +	offloads->vport_reps[0].vport = FDB_UPLINK_VPORT;
  
 -static void __esw_offloads_unload_rep(struct mlx5_eswitch *esw,
 -				      struct mlx5_eswitch_rep *rep, u8 rep_type)
 -{
 -	if (atomic_cmpxchg(&rep->rep_data[rep_type].state,
 -			   REP_LOADED, REP_REGISTERED) == REP_LOADED)
 -		esw->offloads.rep_ops[rep_type]->unload(rep);
 +	return 0;
  }
  
 -static void __unload_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
 +static void esw_offloads_unload_reps_type(struct mlx5_eswitch *esw, int nvports,
 +					  u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 +	int vport;
  
 -	if (mlx5_ecpf_vport_exists(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -	}
 +	for (vport = nvports - 1; vport >= 0; vport--) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
  
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 +		rep->rep_if[rep_type].unload(rep);
  	}
 -
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	__esw_offloads_unload_rep(esw, rep, rep_type);
  }
  
 -static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 -				   u8 rep_type)
 -{
 -	struct mlx5_eswitch_rep *rep;
 -	int i;
 -
 -	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -}
 -
 -static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
 +static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
  {
  	u8 rep_type = NUM_REP_TYPES;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
