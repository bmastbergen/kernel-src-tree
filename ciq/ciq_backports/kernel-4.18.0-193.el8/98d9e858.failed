KVM: nVMX: Return -EINVAL when signaling failure in pre-VM-Entry helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 98d9e858fa966bd7132cc21d65e4c89a97f4fe2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/98d9e858.failed

Convert all top-level nested VM-Enter consistency check functions to
return 0/-EINVAL instead of failure codes, since now they can only
ever return one failure code.

This also does not give the false impression that failure information is
always consumed and/or relevant, e.g. vmx_set_nested_state() only
cares whether or not the checks were successful.

nested_check_host_control_regs() can also now be inlined into its caller,
nested_vmx_check_host_state, since the two have effectively become the
same function.

Based on a patch by Sean Christopherson.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 98d9e858fa966bd7132cc21d65e4c89a97f4fe2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/vmx/nested.c
index 399b57dcff98,56c22e5c96c3..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -2608,11 -2589,19 +2608,27 @@@ static int nested_check_vm_entry_contro
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * Checks related to Host Control Registers and MSRs
 + */
 +static int nested_check_host_control_regs(struct kvm_vcpu *vcpu,
 +                                          struct vmcs12 *vmcs12)
++=======
+ static int nested_vmx_check_controls(struct kvm_vcpu *vcpu,
+ 				     struct vmcs12 *vmcs12)
+ {
+ 	if (nested_check_vm_execution_controls(vcpu, vmcs12) ||
+ 	    nested_check_vm_exit_controls(vcpu, vmcs12) ||
+ 	    nested_check_vm_entry_controls(vcpu, vmcs12))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int nested_vmx_check_host_state(struct kvm_vcpu *vcpu,
+ 				       struct vmcs12 *vmcs12)
++>>>>>>> 98d9e858fa96 (KVM: nVMX: Return -EINVAL when signaling failure in pre-VM-Entry helpers)
  {
  	bool ia32e;
  
@@@ -2647,20 -2636,6 +2663,23 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nested_vmx_check_vmentry_prereqs(struct kvm_vcpu *vcpu,
 +					    struct vmcs12 *vmcs12)
 +{
 +	if (nested_check_vm_execution_controls(vcpu, vmcs12) ||
 +	    nested_check_vm_exit_controls(vcpu, vmcs12) ||
 +	    nested_check_vm_entry_controls(vcpu, vmcs12))
 +		return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
 +
 +	if (nested_check_host_control_regs(vcpu, vmcs12))
 +		return VMXERR_ENTRY_INVALID_HOST_STATE_FIELD;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 98d9e858fa96 (KVM: nVMX: Return -EINVAL when signaling failure in pre-VM-Entry helpers)
  static int nested_vmx_check_vmcs_link_ptr(struct kvm_vcpu *vcpu,
  					  struct vmcs12 *vmcs12)
  {
@@@ -3172,9 -3147,11 +3191,17 @@@ static int nested_vmx_run(struct kvm_vc
  			launch ? VMXERR_VMLAUNCH_NONCLEAR_VMCS
  			       : VMXERR_VMRESUME_NONLAUNCHED_VMCS);
  
++<<<<<<< HEAD
 +	ret = nested_vmx_check_vmentry_prereqs(vcpu, vmcs12);
 +	if (ret)
 +		return nested_vmx_failValid(vcpu, ret);
++=======
+ 	if (nested_vmx_check_controls(vcpu, vmcs12))
+ 		return nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
+ 
+ 	if (nested_vmx_check_host_state(vcpu, vmcs12))
+ 		return nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
++>>>>>>> 98d9e858fa96 (KVM: nVMX: Return -EINVAL when signaling failure in pre-VM-Entry helpers)
  
  	/*
  	 * We're finally done with prerequisite checking, and can start with
* Unmerged path arch/x86/kvm/vmx/nested.c
