libnvdimm/pfn_dev: Add a build check to make sure we notice when struct page size change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
commit e96f0bf2ec92da2bc9c11b0d69e9086f076e7f0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e96f0bf2.failed

Namespaces created with PFN_MODE_PMEM mode stores struct page in the reserve
block area. We need to make sure we account for the right struct page
size while doing this. Instead of directly depending on sizeof(struct page)
which can change based on different kernel config option, use the max struct
page size (64) while calculating the reserve block area. This makes sure pmem
device can be used across kernels built with different configs.

If the above assumption of max struct page size change, we need to update the
reserve block allocation space for new namespaces created.

	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
Link: https://lore.kernel.org/r/20190905154603.10349-4-aneesh.kumar@linux.ibm.com
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit e96f0bf2ec92da2bc9c11b0d69e9086f076e7f0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/pfn_devs.c
diff --cc drivers/nvdimm/pfn_devs.c
index 8762ec764857,cd120feb9213..000000000000
--- a/drivers/nvdimm/pfn_devs.c
+++ b/drivers/nvdimm/pfn_devs.c
@@@ -752,11 -701,18 +752,23 @@@ static int nd_pfn_init(struct nd_pfn *n
  		 * The altmap should be padded out to the block size used
  		 * when populating the vmemmap. This *should* be equal to
  		 * PMD_SIZE for most architectures.
+ 		 *
+ 		 * Also make sure size of struct page is less than 64. We
+ 		 * want to make sure we use large enough size here so that
+ 		 * we don't have a dynamic reserve space depending on
+ 		 * struct page size. But we also want to make sure we notice
+ 		 * when we end up adding new elements to struct page.
  		 */
++<<<<<<< HEAD
 +		offset = ALIGN(start + reserve + 64 * npfns,
 +				max(nd_pfn->align, PMD_SIZE)) - start;
++=======
+ 		BUILD_BUG_ON(sizeof(struct page) > MAX_STRUCT_PAGE_SIZE);
+ 		offset = ALIGN(start + SZ_8K + MAX_STRUCT_PAGE_SIZE * npfns, align)
+ 			- start;
++>>>>>>> e96f0bf2ec92 (libnvdimm/pfn_dev: Add a build check to make sure we notice when struct page size change)
  	} else if (nd_pfn->mode == PFN_MODE_RAM)
 -		offset = ALIGN(start + SZ_8K, align) - start;
 +		offset = ALIGN(start + reserve, nd_pfn->align) - start;
  	else
  		return -ENXIO;
  
diff --git a/drivers/nvdimm/nd.h b/drivers/nvdimm/nd.h
index 01bd5c5217b9..911b6830b026 100644
--- a/drivers/nvdimm/nd.h
+++ b/drivers/nvdimm/nd.h
@@ -374,6 +374,10 @@ unsigned int pmem_sector_size(struct nd_namespace_common *ndns);
 void nvdimm_badblocks_populate(struct nd_region *nd_region,
 		struct badblocks *bb, const struct resource *res);
 #if IS_ENABLED(CONFIG_ND_CLAIM)
+
+/* max struct page size independent of kernel config */
+#define MAX_STRUCT_PAGE_SIZE 64
+
 int nvdimm_setup_pfn(struct nd_pfn *nd_pfn, struct dev_pagemap *pgmap);
 int devm_nsio_enable(struct device *dev, struct nd_namespace_io *nsio);
 void devm_nsio_disable(struct device *dev, struct nd_namespace_io *nsio);
* Unmerged path drivers/nvdimm/pfn_devs.c
