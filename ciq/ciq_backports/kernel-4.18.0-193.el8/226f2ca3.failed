net/mlx5e: Change flow flags type to unsigned long

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Change flow flags type to unsigned long (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 95.83%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 226f2ca3075ab20abf69c68235e8ba9ac2dab596
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/226f2ca3.failed

To remove dependency on rtnl lock and allow concurrent modification of
'flags' field of tc flow structure, change flow flag type to unsigned long
and use atomic bit ops for reading and changing the flags. Implement
auxiliary functions for setting, resetting and getting specific flag, and
for checking most often used flag values.

Always set flags with smp_mb__before_atomic() to ensure that all
mlx5e_tc_flow are updated before concurrent readers can read new flags
value. Rearrange all code paths to actually set flow->rule[] pointers
before setting the OFFLOADED flag. On read side, use smp_mb__after_atomic()
when accessing flags to ensure that offload-related flow fields are only
read after the flags.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 226f2ca3075ab20abf69c68235e8ba9ac2dab596)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 50379aaf9f9f,b2618dd6dd10..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3325,17 -3428,17 +3325,22 @@@ out
  
  #ifdef CONFIG_MLX5_ESWITCH
  static int mlx5e_setup_tc_cls_flower(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +				     struct tc_cls_flower_offload *cls_flower,
 +				     int flags)
++=======
+ 				     struct flow_cls_offload *cls_flower,
+ 				     unsigned long flags)
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  {
  	switch (cls_flower->command) {
 -	case FLOW_CLS_REPLACE:
 +	case TC_CLSFLOWER_REPLACE:
  		return mlx5e_configure_flower(priv->netdev, priv, cls_flower,
  					      flags);
 -	case FLOW_CLS_DESTROY:
 +	case TC_CLSFLOWER_DESTROY:
  		return mlx5e_delete_flower(priv->netdev, priv, cls_flower,
  					   flags);
 -	case FLOW_CLS_STATS:
 +	case TC_CLSFLOWER_STATS:
  		return mlx5e_stats_flower(priv->netdev, priv, cls_flower,
  					  flags);
  	default:
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index f8b0a7e3a895,241157b699df..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -185,6 -186,66 +185,69 @@@ struct mlx5e_mod_hdr_entry 
  
  #define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_tc_del_flow(struct mlx5e_priv *priv,
+ 			      struct mlx5e_tc_flow *flow);
+ 
+ static struct mlx5e_tc_flow *mlx5e_flow_get(struct mlx5e_tc_flow *flow)
+ {
+ 	if (!flow || !refcount_inc_not_zero(&flow->refcnt))
+ 		return ERR_PTR(-EINVAL);
+ 	return flow;
+ }
+ 
+ static void mlx5e_flow_put(struct mlx5e_priv *priv,
+ 			   struct mlx5e_tc_flow *flow)
+ {
+ 	if (refcount_dec_and_test(&flow->refcnt)) {
+ 		mlx5e_tc_del_flow(priv, flow);
+ 		kfree(flow);
+ 	}
+ }
+ 
+ static void __flow_flag_set(struct mlx5e_tc_flow *flow, unsigned long flag)
+ {
+ 	/* Complete all memory stores before setting bit. */
+ 	smp_mb__before_atomic();
+ 	set_bit(flag, &flow->flags);
+ }
+ 
+ #define flow_flag_set(flow, flag) __flow_flag_set(flow, MLX5E_TC_FLOW_FLAG_##flag)
+ 
+ static void __flow_flag_clear(struct mlx5e_tc_flow *flow, unsigned long flag)
+ {
+ 	/* Complete all memory stores before clearing bit. */
+ 	smp_mb__before_atomic();
+ 	clear_bit(flag, &flow->flags);
+ }
+ 
+ #define flow_flag_clear(flow, flag) __flow_flag_clear(flow, \
+ 						      MLX5E_TC_FLOW_FLAG_##flag)
+ 
+ static bool __flow_flag_test(struct mlx5e_tc_flow *flow, unsigned long flag)
+ {
+ 	bool ret = test_bit(flag, &flow->flags);
+ 
+ 	/* Read fields of flow structure only after checking flags. */
+ 	smp_mb__after_atomic();
+ 	return ret;
+ }
+ 
+ #define flow_flag_test(flow, flag) __flow_flag_test(flow, \
+ 						    MLX5E_TC_FLOW_FLAG_##flag)
+ 
+ static bool mlx5e_is_eswitch_flow(struct mlx5e_tc_flow *flow)
+ {
+ 	return flow_flag_test(flow, ESWITCH);
+ }
+ 
+ static bool mlx5e_is_offloaded_flow(struct mlx5e_tc_flow *flow)
+ {
+ 	return flow_flag_test(flow, OFFLOADED);
+ }
+ 
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  static inline u32 hash_mod_hdr_info(struct mod_hdr_key *key)
  {
  	return jhash(key->actions,
@@@ -733,12 -803,12 +797,19 @@@ mlx5e_tc_add_nic_flow(struct mlx5e_pri
  	flow_context->flags |= FLOW_CONTEXT_HAS_TAG;
  	flow_context->flow_tag = attr->flow_tag;
  
- 	if (flow->flags & MLX5E_TC_FLOW_HAIRPIN) {
+ 	if (flow_flag_test(flow, HAIRPIN)) {
  		err = mlx5e_hairpin_flow_add(priv, flow, parse_attr, extack);
++<<<<<<< HEAD
 +		if (err) {
 +			goto err_add_hairpin_flow;
 +		}
 +		if (flow->flags & MLX5E_TC_FLOW_HAIRPIN_RSS) {
++=======
+ 		if (err)
+ 			return err;
+ 
+ 		if (flow_flag_test(flow, HAIRPIN_RSS)) {
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  			dest[dest_ix].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
  			dest[dest_ix].ft = attr->hairpin_ft;
  		} else {
@@@ -839,10 -887,11 +910,10 @@@ static void mlx5e_tc_del_nic_flow(struc
  	struct mlx5_fc *counter = NULL;
  
  	counter = attr->counter;
 -	if (!IS_ERR_OR_NULL(flow->rule[0]))
 -		mlx5_del_flow_rules(flow->rule[0]);
 +	mlx5_del_flow_rules(flow->rule[0]);
  	mlx5_fc_destroy(priv->mdev, counter);
  
- 	if (!mlx5e_tc_num_filters(priv, MLX5E_TC_NIC_OFFLOAD)  && priv->fs.tc.t) {
+ 	if (!mlx5e_tc_num_filters(priv, MLX5_TC_FLAG(NIC_OFFLOAD)) && priv->fs.tc.t) {
  		mlx5_destroy_flow_table(priv->fs.tc.t);
  		priv->fs.tc.t = NULL;
  	}
@@@ -1044,27 -1088,12 +1114,34 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  		flow->rule[0] = mlx5e_tc_offload_fdb_rules(esw, flow, &parse_attr->spec, attr);
  	}
  
++<<<<<<< HEAD
 +	if (IS_ERR(flow->rule[0])) {
 +		err = PTR_ERR(flow->rule[0]);
 +		goto err_add_rule;
 +	}
++=======
+ 	if (IS_ERR(flow->rule[0]))
+ 		return PTR_ERR(flow->rule[0]);
+ 	else
+ 		flow_flag_set(flow, OFFLOADED);
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  
  	return 0;
 +
 +err_add_rule:
 +	mlx5_fc_destroy(attr->counter_dev, counter);
 +err_create_counter:
 +	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
 +		mlx5e_detach_mod_hdr(priv, flow);
 +err_mod_hdr:
 +	mlx5_eswitch_del_vlan_action(esw, attr);
 +err_add_vlan:
 +	for (out_index = 0; out_index < MLX5_MAX_FLOW_FWD_VPORTS; out_index++)
 +		if (attr->dests[out_index].flags & MLX5_ESW_DEST_ENCAP)
 +			mlx5e_detach_encap(priv, flow, out_index);
 +err_attach_encap:
 +err_max_prio_chain:
 +	return err;
  }
  
  static bool mlx5_flow_has_geneve_opt(struct mlx5e_tc_flow *flow)
@@@ -1177,8 -1209,12 +1254,15 @@@ void mlx5e_tc_encap_flows_add(struct ml
  		}
  
  		mlx5e_tc_unoffload_from_slow_path(esw, flow, &slow_attr);
- 		flow->flags |= MLX5E_TC_FLOW_OFFLOADED; /* was unset when slow path rule removed */
  		flow->rule[0] = rule;
++<<<<<<< HEAD
++=======
+ 		/* was unset when slow path rule removed */
+ 		flow_flag_set(flow, OFFLOADED);
+ 
+ loop_cont:
+ 		mlx5e_flow_put(priv, flow);
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  	}
  }
  
@@@ -1210,8 -1249,12 +1294,15 @@@ void mlx5e_tc_encap_flows_del(struct ml
  		}
  
  		mlx5e_tc_unoffload_fdb_rules(esw, flow, flow->esw_attr);
- 		flow->flags |= MLX5E_TC_FLOW_OFFLOADED; /* was unset when fast path rule removed */
  		flow->rule[0] = rule;
++<<<<<<< HEAD
++=======
+ 		/* was unset when fast path rule removed */
+ 		flow_flag_set(flow, OFFLOADED);
+ 
+ loop_cont:
+ 		mlx5e_flow_put(priv, flow);
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  	}
  
  	/* we know that the encap is valid */
@@@ -1248,16 -1291,20 +1339,23 @@@ void mlx5e_tc_update_neigh_used_value(s
  		return;
  
  	list_for_each_entry(e, &nhe->encap_list, encap_list) {
 -		struct encap_flow_item *efi, *tmp;
 +		struct encap_flow_item *efi;
  		if (!(e->flags & MLX5_ENCAP_ENTRY_VALID))
  			continue;
 -		list_for_each_entry_safe(efi, tmp, &e->flows, list) {
 +		list_for_each_entry(efi, &e->flows, list) {
  			flow = container_of(efi, struct mlx5e_tc_flow,
  					    encaps[efi->index]);
++<<<<<<< HEAD
 +			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
++=======
+ 			if (IS_ERR(mlx5e_flow_get(flow)))
+ 				continue;
+ 
+ 			if (mlx5e_is_offloaded_flow(flow)) {
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  				counter = mlx5e_tc_get_counter(flow);
 -				mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
 +				lastuse = mlx5_fc_query_lastuse(counter);
  				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
 -					mlx5e_flow_put(netdev_priv(e->out_dev), flow);
  					neigh_used = true;
  					break;
  				}
@@@ -1841,9 -1895,10 +1940,10 @@@ static int parse_cls_flower(struct mlx5
  
  	err = __parse_cls_flower(priv, spec, f, filter_dev, &match_level, &tunnel_match_level);
  
- 	if (!err && (flow->flags & MLX5E_TC_FLOW_ESWITCH)) {
+ 	is_eswitch_flow = mlx5e_is_eswitch_flow(flow);
+ 	if (!err && is_eswitch_flow) {
  		rep = rpriv->rep;
 -		if (rep->vport != MLX5_VPORT_UPLINK &&
 +		if (rep->vport != FDB_UPLINK_VPORT &&
  		    (esw->offloads.inline_mode != MLX5_INLINE_MODE_NONE &&
  		    esw->offloads.inline_mode < match_level)) {
  			NL_SET_ERR_MSG_MOD(extack,
@@@ -2997,8 -3152,8 +3098,13 @@@ static struct rhashtable *get_tc_ht(str
  static bool is_peer_flow_needed(struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
++<<<<<<< HEAD
 +	bool is_rep_ingress = attr->in_rep->vport != FDB_UPLINK_VPORT &&
 +			      flow->flags & MLX5E_TC_FLOW_INGRESS;
++=======
+ 	bool is_rep_ingress = attr->in_rep->vport != MLX5_VPORT_UPLINK &&
+ 		flow_flag_test(flow, INGRESS);
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  	bool act_is_encap = !!(attr->action &
  			       MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT);
  	bool esw_paired = mlx5_devcom_is_paired(attr->in_mdev->priv.devcom,
@@@ -3017,7 -3172,7 +3123,11 @@@
  
  static int
  mlx5e_alloc_flow(struct mlx5e_priv *priv, int attr_size,
++<<<<<<< HEAD
 +		 struct tc_cls_flower_offload *f, u16 flow_flags,
++=======
+ 		 struct flow_cls_offload *f, unsigned long flow_flags,
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  		 struct mlx5e_tc_flow_parse_attr **__parse_attr,
  		 struct mlx5e_tc_flow **__flow)
  {
@@@ -3073,8 -3233,8 +3183,13 @@@ mlx5e_flow_esw_attr_init(struct mlx5_es
  
  static struct mlx5e_tc_flow *
  __mlx5e_add_fdb_flow(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +		     struct tc_cls_flower_offload *f,
 +		     u16 flow_flags,
++=======
+ 		     struct flow_cls_offload *f,
+ 		     unsigned long flow_flags,
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  		     struct net_device *filter_dev,
  		     struct mlx5_eswitch_rep *in_rep,
  		     struct mlx5_core_dev *in_mdev)
@@@ -3123,9 -3282,9 +3238,9 @@@ out
  	return ERR_PTR(err);
  }
  
 -static int mlx5e_tc_add_fdb_peer_flow(struct flow_cls_offload *f,
 +static int mlx5e_tc_add_fdb_peer_flow(struct tc_cls_flower_offload *f,
  				      struct mlx5e_tc_flow *flow,
- 				      u16 flow_flags)
+ 				      unsigned long flow_flags)
  {
  	struct mlx5e_priv *priv = flow->priv, *peer_priv;
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch, *peer_esw;
@@@ -3175,8 -3334,8 +3290,13 @@@ out
  
  static int
  mlx5e_add_fdb_flow(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +		   struct tc_cls_flower_offload *f,
 +		   u16 flow_flags,
++=======
+ 		   struct flow_cls_offload *f,
+ 		   unsigned long flow_flags,
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  		   struct net_device *filter_dev,
  		   struct mlx5e_tc_flow **__flow)
  {
@@@ -3209,8 -3368,8 +3329,13 @@@ out
  
  static int
  mlx5e_add_nic_flow(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +		   struct tc_cls_flower_offload *f,
 +		   u16 flow_flags,
++=======
+ 		   struct flow_cls_offload *f,
+ 		   unsigned long flow_flags,
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  		   struct net_device *filter_dev,
  		   struct mlx5e_tc_flow **__flow)
  {
@@@ -3260,8 -3419,8 +3385,13 @@@ out
  
  static int
  mlx5e_tc_add_flow(struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +		  struct tc_cls_flower_offload *f,
 +		  int flags,
++=======
+ 		  struct flow_cls_offload *f,
+ 		  unsigned long flags,
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  		  struct net_device *filter_dev,
  		  struct mlx5e_tc_flow **flow)
  {
@@@ -3285,7 -3444,7 +3415,11 @@@
  }
  
  int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +			   struct tc_cls_flower_offload *f, int flags)
++=======
+ 			   struct flow_cls_offload *f, unsigned long flags)
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  {
  	struct netlink_ext_ack *extack = f->common.extack;
  	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
@@@ -3332,7 -3488,7 +3464,11 @@@ static bool same_flow_direction(struct 
  }
  
  int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +			struct tc_cls_flower_offload *f, int flags)
++=======
+ 			struct flow_cls_offload *f, unsigned long flags)
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  {
  	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
  	struct mlx5e_tc_flow *flow;
@@@ -3351,7 -3505,7 +3487,11 @@@
  }
  
  int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +		       struct tc_cls_flower_offload *f, int flags)
++=======
+ 		       struct flow_cls_offload *f, unsigned long flags)
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  {
  	struct mlx5_devcom *devcom = priv->mdev->priv.devcom;
  	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
@@@ -3361,15 -3515,22 +3501,15 @@@
  	u64 lastuse = 0;
  	u64 packets = 0;
  	u64 bytes = 0;
 -	int err = 0;
 -
 -	flow = mlx5e_flow_get(rhashtable_lookup_fast(tc_ht, &f->cookie,
 -						     tc_ht_params));
 -	if (IS_ERR(flow))
 -		return PTR_ERR(flow);
  
 -	if (!same_flow_direction(flow, flags)) {
 -		err = -EINVAL;
 -		goto errout;
 -	}
 +	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
 +	if (!flow || !same_flow_direction(flow, flags))
 +		return -EINVAL;
  
- 	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 	if (mlx5e_is_offloaded_flow(flow)) {
  		counter = mlx5e_tc_get_counter(flow);
  		if (!counter)
 -			goto errout;
 +			return 0;
  
  		mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
  	}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index f62e81902d27,1cb66bf76997..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -54,12 -56,12 +56,21 @@@ int mlx5e_tc_esw_init(struct rhashtabl
  void mlx5e_tc_esw_cleanup(struct rhashtable *tc_ht);
  
  int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
++<<<<<<< HEAD
 +			   struct tc_cls_flower_offload *f, int flags);
 +int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
 +			struct tc_cls_flower_offload *f, int flags);
 +
 +int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
 +		       struct tc_cls_flower_offload *f, int flags);
++=======
+ 			   struct flow_cls_offload *f, unsigned long flags);
+ int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
+ 			struct flow_cls_offload *f, unsigned long flags);
+ 
+ int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
+ 		       struct flow_cls_offload *f, unsigned long flags);
++>>>>>>> 226f2ca3075a (net/mlx5e: Change flow flags type to unsigned long)
  
  struct mlx5e_encap_entry;
  void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1ddcc10576ec..66f9b45144c7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -685,8 +685,8 @@ mlx5e_rep_indr_offload(struct net_device *netdev,
 		       struct tc_cls_flower_offload *flower,
 		       struct mlx5e_rep_indr_block_priv *indr_priv)
 {
+	unsigned long flags = MLX5_TC_FLAG(EGRESS) | MLX5_TC_FLAG(ESW_OFFLOAD);
 	struct mlx5e_priv *priv = netdev_priv(indr_priv->rpriv->netdev);
-	int flags = MLX5E_TC_EGRESS | MLX5E_TC_ESW_OFFLOAD;
 	int err = 0;
 
 	switch (flower->command) {
@@ -1194,12 +1194,12 @@ mlx5e_rep_setup_tc_cls_flower(struct mlx5e_priv *priv,
 static int mlx5e_rep_setup_tc_cb(enum tc_setup_type type, void *type_data,
 				 void *cb_priv)
 {
+	unsigned long flags = MLX5_TC_FLAG(INGRESS) | MLX5_TC_FLAG(ESW_OFFLOAD);
 	struct mlx5e_priv *priv = cb_priv;
 
 	switch (type) {
 	case TC_SETUP_CLSFLOWER:
-		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS |
-						     MLX5E_TC_ESW_OFFLOAD);
+		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, flags);
 	default:
 		return -EOPNOTSUPP;
 	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
