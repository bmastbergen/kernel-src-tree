selftests/bpf: make sure signal interrupts BPF_PROG_TEST_RUN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 740f8a6572213a677c7916b12a11d831373722ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/740f8a65.failed

Simple test that I used to reproduce the issue in the previous commit:
Do BPF_PROG_TEST_RUN with max iterations, each program is 4096 simple
move instructions. File alarm in 0.1 second and check that
bpf_prog_test_run is interrupted (i.e. test doesn't hang).

Note: reposting this for bpf-next to avoid linux-next conflict. In this
version I test both BPF_PROG_TYPE_SOCKET_FILTER (which uses generic
bpf_test_run implementation) and BPF_PROG_TYPE_FLOW_DISSECTOR (which has
it own loop with preempt handling in bpf_prog_test_run_flow_dissector).

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 740f8a6572213a677c7916b12a11d831373722ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_progs.c
diff --cc tools/testing/selftests/bpf/test_progs.c
index 07492da31eba,c59d2e015d16..000000000000
--- a/tools/testing/selftests/bpf/test_progs.c
+++ b/tools/testing/selftests/bpf/test_progs.c
@@@ -28,8 -29,9 +29,9 @@@ typedef __u16 __sum16
  #include <sys/ioctl.h>
  #include <sys/wait.h>
  #include <sys/types.h>
+ #include <sys/time.h>
  #include <fcntl.h>
 -#include <pthread.h>
 +
  #include <linux/bpf.h>
  #include <linux/err.h>
  #include <bpf/bpf.h>
@@@ -1995,6 -1997,159 +1997,162 @@@ static void test_flow_dissector(void
  	bpf_object__close(obj);
  }
  
++<<<<<<< HEAD
++=======
+ static void *test_spin_lock(void *arg)
+ {
+ 	__u32 duration, retval;
+ 	int err, prog_fd = *(u32 *) arg;
+ 
+ 	err = bpf_prog_test_run(prog_fd, 10000, &pkt_v4, sizeof(pkt_v4),
+ 				NULL, NULL, &retval, &duration);
+ 	CHECK(err || retval, "",
+ 	      "err %d errno %d retval %d duration %d\n",
+ 	      err, errno, retval, duration);
+ 	pthread_exit(arg);
+ }
+ 
+ static void test_spinlock(void)
+ {
+ 	const char *file = "./test_spin_lock.o";
+ 	pthread_t thread_id[4];
+ 	struct bpf_object *obj;
+ 	int prog_fd;
+ 	int err = 0, i;
+ 	void *ret;
+ 
+ 	err = bpf_prog_load(file, BPF_PROG_TYPE_CGROUP_SKB, &obj, &prog_fd);
+ 	if (err) {
+ 		printf("test_spin_lock:bpf_prog_load errno %d\n", errno);
+ 		goto close_prog;
+ 	}
+ 	for (i = 0; i < 4; i++)
+ 		assert(pthread_create(&thread_id[i], NULL,
+ 				      &test_spin_lock, &prog_fd) == 0);
+ 	for (i = 0; i < 4; i++)
+ 		assert(pthread_join(thread_id[i], &ret) == 0 &&
+ 		       ret == (void *)&prog_fd);
+ 	goto close_prog_noerr;
+ close_prog:
+ 	error_cnt++;
+ close_prog_noerr:
+ 	bpf_object__close(obj);
+ }
+ 
+ static void *parallel_map_access(void *arg)
+ {
+ 	int err, map_fd = *(u32 *) arg;
+ 	int vars[17], i, j, rnd, key = 0;
+ 
+ 	for (i = 0; i < 10000; i++) {
+ 		err = bpf_map_lookup_elem_flags(map_fd, &key, vars, BPF_F_LOCK);
+ 		if (err) {
+ 			printf("lookup failed\n");
+ 			error_cnt++;
+ 			goto out;
+ 		}
+ 		if (vars[0] != 0) {
+ 			printf("lookup #%d var[0]=%d\n", i, vars[0]);
+ 			error_cnt++;
+ 			goto out;
+ 		}
+ 		rnd = vars[1];
+ 		for (j = 2; j < 17; j++) {
+ 			if (vars[j] == rnd)
+ 				continue;
+ 			printf("lookup #%d var[1]=%d var[%d]=%d\n",
+ 			       i, rnd, j, vars[j]);
+ 			error_cnt++;
+ 			goto out;
+ 		}
+ 	}
+ out:
+ 	pthread_exit(arg);
+ }
+ 
+ static void test_map_lock(void)
+ {
+ 	const char *file = "./test_map_lock.o";
+ 	int prog_fd, map_fd[2], vars[17] = {};
+ 	pthread_t thread_id[6];
+ 	struct bpf_object *obj;
+ 	int err = 0, key = 0, i;
+ 	void *ret;
+ 
+ 	err = bpf_prog_load(file, BPF_PROG_TYPE_CGROUP_SKB, &obj, &prog_fd);
+ 	if (err) {
+ 		printf("test_map_lock:bpf_prog_load errno %d\n", errno);
+ 		goto close_prog;
+ 	}
+ 	map_fd[0] = bpf_find_map(__func__, obj, "hash_map");
+ 	if (map_fd[0] < 0)
+ 		goto close_prog;
+ 	map_fd[1] = bpf_find_map(__func__, obj, "array_map");
+ 	if (map_fd[1] < 0)
+ 		goto close_prog;
+ 
+ 	bpf_map_update_elem(map_fd[0], &key, vars, BPF_F_LOCK);
+ 
+ 	for (i = 0; i < 4; i++)
+ 		assert(pthread_create(&thread_id[i], NULL,
+ 				      &test_spin_lock, &prog_fd) == 0);
+ 	for (i = 4; i < 6; i++)
+ 		assert(pthread_create(&thread_id[i], NULL,
+ 				      &parallel_map_access, &map_fd[i - 4]) == 0);
+ 	for (i = 0; i < 4; i++)
+ 		assert(pthread_join(thread_id[i], &ret) == 0 &&
+ 		       ret == (void *)&prog_fd);
+ 	for (i = 4; i < 6; i++)
+ 		assert(pthread_join(thread_id[i], &ret) == 0 &&
+ 		       ret == (void *)&map_fd[i - 4]);
+ 	goto close_prog_noerr;
+ close_prog:
+ 	error_cnt++;
+ close_prog_noerr:
+ 	bpf_object__close(obj);
+ }
+ 
+ static void sigalrm_handler(int s) {}
+ static struct sigaction sigalrm_action = {
+ 	.sa_handler = sigalrm_handler,
+ };
+ 
+ static void test_signal_pending(enum bpf_prog_type prog_type)
+ {
+ 	struct bpf_insn prog[4096];
+ 	struct itimerval timeo = {
+ 		.it_value.tv_usec = 100000, /* 100ms */
+ 	};
+ 	__u32 duration, retval;
+ 	int prog_fd;
+ 	int err;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(prog); i++)
+ 		prog[i] = BPF_ALU64_IMM(BPF_MOV, BPF_REG_0, 0);
+ 	prog[ARRAY_SIZE(prog) - 1] = BPF_EXIT_INSN();
+ 
+ 	prog_fd = bpf_load_program(prog_type, prog, ARRAY_SIZE(prog),
+ 				   "GPL", 0, NULL, 0);
+ 	CHECK(prog_fd < 0, "test-run", "errno %d\n", errno);
+ 
+ 	err = sigaction(SIGALRM, &sigalrm_action, NULL);
+ 	CHECK(err, "test-run-signal-sigaction", "errno %d\n", errno);
+ 
+ 	err = setitimer(ITIMER_REAL, &timeo, NULL);
+ 	CHECK(err, "test-run-signal-timer", "errno %d\n", errno);
+ 
+ 	err = bpf_prog_test_run(prog_fd, 0xffffffff, &pkt_v4, sizeof(pkt_v4),
+ 				NULL, NULL, &retval, &duration);
+ 	CHECK(duration > 500000000, /* 500ms */
+ 	      "test-run-signal-duration",
+ 	      "duration %dns > 500ms\n",
+ 	      duration);
+ 
+ 	signal(SIGALRM, SIG_DFL);
+ }
+ 
++>>>>>>> 740f8a657221 (selftests/bpf: make sure signal interrupts BPF_PROG_TEST_RUN)
  int main(void)
  {
  	srand(time(NULL));
@@@ -2023,6 -2178,10 +2181,13 @@@
  	test_queue_stack_map(QUEUE);
  	test_queue_stack_map(STACK);
  	test_flow_dissector();
++<<<<<<< HEAD
++=======
+ 	test_spinlock();
+ 	test_map_lock();
+ 	test_signal_pending(BPF_PROG_TYPE_SOCKET_FILTER);
+ 	test_signal_pending(BPF_PROG_TYPE_FLOW_DISSECTOR);
++>>>>>>> 740f8a657221 (selftests/bpf: make sure signal interrupts BPF_PROG_TEST_RUN)
  
  	printf("Summary: %d PASSED, %d FAILED\n", pass_cnt, error_cnt);
  	return error_cnt ? EXIT_FAILURE : EXIT_SUCCESS;
* Unmerged path tools/testing/selftests/bpf/test_progs.c
