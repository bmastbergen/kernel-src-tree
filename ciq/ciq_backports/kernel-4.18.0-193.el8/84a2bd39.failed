fs/namei.c: keep track of nd->root refcount status

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [fs] namei.c: keep track of nd->root refcount status (Richard Guy Briggs) [1716002]
Rebuild_FUZZ: 96.91%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 84a2bd39405ffd5fa6d6d77e408c5b9210da98de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/84a2bd39.failed

The rules for nd->root are messy:
	* if we have LOOKUP_ROOT, it doesn't contribute to refcounts
	* if we have LOOKUP_RCU, it doesn't contribute to refcounts
	* if nd->root.mnt is NULL, it doesn't contribute to refcounts
	* otherwise it does contribute

terminate_walk() needs to drop the references if they are contributing.
So everything else should be careful not to confuse it, leading to
rather convoluted code.

It's easier to keep track of whether we'd grabbed the reference(s)
explicitly.  Use a new flag for that.  Don't bother with zeroing
nd->root.mnt on unlazy failures and in terminate_walk - it's not
needed anymore (terminate_walk() won't care and the next path_init()
will zero nd->root in !LOOKUP_ROOT case anyway).

Resulting rules for nd->root refcounts are much simpler: they are
contributing iff LOOKUP_ROOT_GRABBED is set in nd->flags.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 84a2bd39405ffd5fa6d6d77e408c5b9210da98de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/namei.h
diff --cc include/linux/namei.h
index a4801bc420cc,397a08ade6a2..000000000000
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@@ -16,39 -16,28 +16,43 @@@ enum { MAX_NESTED_LINKS = 8 }
   */
  enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  
 -/* pathwalk mode */
 -#define LOOKUP_FOLLOW		0x0001	/* follow links at the end */
 -#define LOOKUP_DIRECTORY	0x0002	/* require a directory */
 -#define LOOKUP_AUTOMOUNT	0x0004  /* force terminal automount */
 -#define LOOKUP_EMPTY		0x4000	/* accept empty path [user_... only] */
 -#define LOOKUP_DOWN		0x8000	/* follow mounts in the starting point */
 -
 -#define LOOKUP_REVAL		0x0020	/* tell ->d_revalidate() to trust no cache */
 -#define LOOKUP_RCU		0x0040	/* RCU pathwalk mode; semi-internal */
 -
 -/* These tell filesystem methods that we are dealing with the final component... */
 -#define LOOKUP_OPEN		0x0100	/* ... in open */
 -#define LOOKUP_CREATE		0x0200	/* ... in object creation */
 -#define LOOKUP_EXCL		0x0400	/* ... in exclusive creation */
 -#define LOOKUP_RENAME_TARGET	0x0800	/* ... in destination of rename() */
 -
 -/* internal use only */
 +/*
 + * The bitmask for a lookup event:
 + *  - follow links at the end
 + *  - require a directory
 + *  - ending slashes ok even for nonexistent files
 + *  - internal "there are more path components" flag
 + *  - dentry cache is untrusted; force a real lookup
 + *  - suppress terminal automount
 + *  - skip revalidation
 + *  - don't fetch xattrs on audit_inode
 + */
 +#define LOOKUP_FOLLOW		0x0001
 +#define LOOKUP_DIRECTORY	0x0002
 +#define LOOKUP_AUTOMOUNT	0x0004
 +
  #define LOOKUP_PARENT		0x0010
 +#define LOOKUP_REVAL		0x0020
 +#define LOOKUP_RCU		0x0040
  #define LOOKUP_NO_REVAL		0x0080
 +#define LOOKUP_NO_EVAL		0x0100
 +
 +/*
 + * Intent data
 + */
 +#define LOOKUP_OPEN		0x0100
 +#define LOOKUP_CREATE		0x0200
 +#define LOOKUP_EXCL		0x0400
 +#define LOOKUP_RENAME_TARGET	0x0800
 +
  #define LOOKUP_JUMPED		0x1000
  #define LOOKUP_ROOT		0x2000
++<<<<<<< HEAD
 +#define LOOKUP_EMPTY		0x4000
 +#define LOOKUP_DOWN		0x8000
++=======
+ #define LOOKUP_ROOT_GRABBED	0x0008
++>>>>>>> 84a2bd39405f (fs/namei.c: keep track of nd->root refcount status)
  
  extern int path_pts(struct path *path);
  
diff --git a/fs/namei.c b/fs/namei.c
index 5e23e56426d9..54f98be2da18 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -598,14 +598,12 @@ static void terminate_walk(struct nameidata *nd)
 		path_put(&nd->path);
 		for (i = 0; i < nd->depth; i++)
 			path_put(&nd->stack[i].link);
-		if (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {
+		if (nd->flags & LOOKUP_ROOT_GRABBED) {
 			path_put(&nd->root);
-			nd->root.mnt = NULL;
+			nd->flags &= ~LOOKUP_ROOT_GRABBED;
 		}
 	} else {
 		nd->flags &= ~LOOKUP_RCU;
-		if (!(nd->flags & LOOKUP_ROOT))
-			nd->root.mnt = NULL;
 		rcu_read_unlock();
 	}
 	nd->depth = 0;
@@ -647,6 +645,7 @@ static bool legitimize_root(struct nameidata *nd)
 {
 	if (!nd->root.mnt || (nd->flags & LOOKUP_ROOT))
 		return true;
+	nd->flags |= LOOKUP_ROOT_GRABBED;
 	return legitimize_path(nd, &nd->root, nd->root_seq);
 }
 
@@ -680,21 +679,18 @@ static int unlazy_walk(struct nameidata *nd)
 
 	nd->flags &= ~LOOKUP_RCU;
 	if (unlikely(!legitimize_links(nd)))
-		goto out2;
-	if (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))
 		goto out1;
+	if (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))
+		goto out;
 	if (unlikely(!legitimize_root(nd)))
 		goto out;
 	rcu_read_unlock();
 	BUG_ON(nd->inode != parent->d_inode);
 	return 0;
 
-out2:
+out1:
 	nd->path.mnt = NULL;
 	nd->path.dentry = NULL;
-out1:
-	if (!(nd->flags & LOOKUP_ROOT))
-		nd->root.mnt = NULL;
 out:
 	rcu_read_unlock();
 	return -ECHILD;
@@ -734,21 +730,14 @@ static int unlazy_child(struct nameidata *nd, struct dentry *dentry, unsigned se
 	 */
 	if (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))
 		goto out;
-	if (unlikely(read_seqcount_retry(&dentry->d_seq, seq))) {
-		rcu_read_unlock();
-		dput(dentry);
-		goto drop_root_mnt;
-	}
+	if (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))
+		goto out_dput;
 	/*
 	 * Sequence counts matched. Now make sure that the root is
 	 * still valid and get it if required.
 	 */
-	if (unlikely(!legitimize_root(nd))) {
-		rcu_read_unlock();
-		dput(dentry);
-		return -ECHILD;
-	}
-
+	if (unlikely(!legitimize_root(nd)))
+		goto out_dput;
 	rcu_read_unlock();
 	return 0;
 
@@ -758,9 +747,10 @@ static int unlazy_child(struct nameidata *nd, struct dentry *dentry, unsigned se
 	nd->path.dentry = NULL;
 out:
 	rcu_read_unlock();
-drop_root_mnt:
-	if (!(nd->flags & LOOKUP_ROOT))
-		nd->root.mnt = NULL;
+	return -ECHILD;
+out_dput:
+	rcu_read_unlock();
+	dput(dentry);
 	return -ECHILD;
 }
 
@@ -824,6 +814,7 @@ static void set_root(struct nameidata *nd)
 		} while (read_seqcount_retry(&fs->seq, seq));
 	} else {
 		get_fs_root(fs, &nd->root);
+		nd->flags |= LOOKUP_ROOT_GRABBED;
 	}
 }
 
@@ -1699,8 +1690,6 @@ static int pick_link(struct nameidata *nd, struct path *link,
 				nd->flags &= ~LOOKUP_RCU;
 				nd->path.mnt = NULL;
 				nd->path.dentry = NULL;
-				if (!(nd->flags & LOOKUP_ROOT))
-					nd->root.mnt = NULL;
 				rcu_read_unlock();
 			} else if (likely(unlazy_walk(nd)) == 0)
 				error = nd_alloc_stack(nd);
* Unmerged path include/linux/namei.h
