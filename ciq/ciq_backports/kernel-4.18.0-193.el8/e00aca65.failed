libbpf: Make DECLARE_LIBBPF_OPTS macro strictly a variable declaration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit e00aca65e646da08f8dce31c9b89f11dab76198c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e00aca65.failed

LIBBPF_OPTS is implemented as a mix of field declaration and memset
+ assignment. This makes it neither variable declaration nor purely
statements, which is a problem, because you can't mix it with either
other variable declarations nor other function statements, because C90
compiler mode emits warning on mixing all that together.

This patch changes LIBBPF_OPTS into a strictly declaration of variable
and solves this problem, as can be seen in case of bpftool, which
previously would emit compiler warning, if done this way (LIBBPF_OPTS as
part of function variables declaration block).

This patch also renames LIBBPF_OPTS into DECLARE_LIBBPF_OPTS to follow
kernel convention for similar macros more closely.

v1->v2:
- rename LIBBPF_OPTS into DECLARE_LIBBPF_OPTS (Jakub Sitnicki).

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
Link: https://lore.kernel.org/bpf/20191022172100.3281465-1-andriin@fb.com
(cherry picked from commit e00aca65e646da08f8dce31c9b89f11dab76198c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
#	tools/testing/selftests/bpf/prog_tests/attach_probe.c
#	tools/testing/selftests/bpf/prog_tests/core_reloc.c
#	tools/testing/selftests/bpf/prog_tests/reference_tracking.c
diff --cc tools/lib/bpf/libbpf.c
index f4c01aa6f359,8b4d765c422b..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -2733,9 -3675,13 +2733,16 @@@ out
  	return ERR_PTR(err);
  }
  
 -static struct bpf_object *
 -__bpf_object__open_xattr(struct bpf_object_open_attr *attr, int flags)
 +struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 +					    int flags)
  {
++<<<<<<< HEAD
++=======
+ 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts,
+ 		.relaxed_maps = flags & MAPS_RELAX_COMPAT,
+ 	);
+ 
++>>>>>>> e00aca65e646 (libbpf: Make DECLARE_LIBBPF_OPTS macro strictly a variable declaration)
  	/* param validation */
  	if (!attr->file)
  		return NULL;
@@@ -2762,25 -3705,42 +2769,55 @@@ struct bpf_object *bpf_object__open(con
  	return bpf_object__open_xattr(&attr);
  }
  
 -struct bpf_object *
 -bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts)
 +struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 +					   size_t obj_buf_sz,
 +					   const char *name)
  {
 -	if (!path)
 -		return ERR_PTR(-EINVAL);
 +	char tmp_name[64];
  
++<<<<<<< HEAD
 +	/* param validation */
 +	if (!obj_buf || obj_buf_sz <= 0)
++=======
+ 	pr_debug("loading %s\n", path);
+ 
+ 	return __bpf_object__open(path, NULL, 0, opts);
+ }
+ 
+ struct bpf_object *
+ bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
+ 		     struct bpf_object_open_opts *opts)
+ {
+ 	if (!obj_buf || obj_buf_sz == 0)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return __bpf_object__open(NULL, obj_buf, obj_buf_sz, opts);
+ }
+ 
+ struct bpf_object *
+ bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
+ 			const char *name)
+ {
+ 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts,
+ 		.object_name = name,
+ 		/* wrong default, but backwards-compatible */
+ 		.relaxed_maps = true,
+ 	);
+ 
+ 	/* returning NULL is wrong, but backwards-compatible */
+ 	if (!obj_buf || obj_buf_sz == 0)
++>>>>>>> e00aca65e646 (libbpf: Make DECLARE_LIBBPF_OPTS macro strictly a variable declaration)
  		return NULL;
  
 -	return bpf_object__open_mem(obj_buf, obj_buf_sz, &opts);
 +	if (!name) {
 +		snprintf(tmp_name, sizeof(tmp_name), "%lx-%lx",
 +			 (unsigned long)obj_buf,
 +			 (unsigned long)obj_buf_sz);
 +		name = tmp_name;
 +	}
 +	pr_debug("loading object '%s' from buffer\n", name);
 +
 +	return __bpf_object__open(name, obj_buf, obj_buf_sz, true, true);
  }
  
  int bpf_object__unload(struct bpf_object *obj)
diff --cc tools/lib/bpf/libbpf.h
index 8a9d462a6f6d,c63e2ff84abc..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -67,14 -67,59 +67,56 @@@ struct bpf_object_open_attr 
  	enum bpf_prog_type prog_type;
  };
  
++<<<<<<< HEAD
++=======
+ /* Helper macro to declare and initialize libbpf options struct
+  *
+  * This dance with uninitialized declaration, followed by memset to zero,
+  * followed by assignment using compound literal syntax is done to preserve
+  * ability to use a nice struct field initialization syntax and **hopefully**
+  * have all the padding bytes initialized to zero. It's not guaranteed though,
+  * when copying literal, that compiler won't copy garbage in literal's padding
+  * bytes, but that's the best way I've found and it seems to work in practice.
+  *
+  * Macro declares opts struct of given type and name, zero-initializes,
+  * including any extra padding, it with memset() and then assigns initial
+  * values provided by users in struct initializer-syntax as varargs.
+  */
+ #define DECLARE_LIBBPF_OPTS(TYPE, NAME, ...)				    \
+ 	struct TYPE NAME = ({ 						    \
+ 		memset(&NAME, 0, sizeof(struct TYPE));			    \
+ 		(struct TYPE) {						    \
+ 			.sz = sizeof(struct TYPE),			    \
+ 			__VA_ARGS__					    \
+ 		};							    \
+ 	})
+ 
+ struct bpf_object_open_opts {
+ 	/* size of this struct, for forward/backward compatiblity */
+ 	size_t sz;
+ 	/* object name override, if provided:
+ 	 * - for object open from file, this will override setting object
+ 	 *   name from file path's base name;
+ 	 * - for object open from memory buffer, this will specify an object
+ 	 *   name and will override default "<addr>-<buf-size>" name;
+ 	 */
+ 	const char *object_name;
+ 	/* parse map definitions non-strictly, allowing extra attributes/data */
+ 	bool relaxed_maps;
+ 	/* process CO-RE relocations non-strictly, allowing them to fail */
+ 	bool relaxed_core_relocs;
+ };
+ #define bpf_object_open_opts__last_field relaxed_core_relocs
+ 
++>>>>>>> e00aca65e646 (libbpf: Make DECLARE_LIBBPF_OPTS macro strictly a variable declaration)
  LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
  LIBBPF_API struct bpf_object *
 -bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts);
 -LIBBPF_API struct bpf_object *
 -bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
 -		     struct bpf_object_open_opts *opts);
 -
 -/* deprecated bpf_object__open variants */
 -LIBBPF_API struct bpf_object *
 -bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
 -			const char *name);
 -LIBBPF_API struct bpf_object *
  bpf_object__open_xattr(struct bpf_object_open_attr *attr);
 -
 +struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 +					    int flags);
 +LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 +						      size_t obj_buf_sz,
 +						      const char *name);
  int bpf_object__section_size(const struct bpf_object *obj, const char *name,
  			     __u32 *size);
  int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
* Unmerged path tools/testing/selftests/bpf/prog_tests/attach_probe.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/core_reloc.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/reference_tracking.c
diff --git a/tools/bpf/bpftool/prog.c b/tools/bpf/bpftool/prog.c
index e1d523dbfa8e..10a2ec650fbc 100644
--- a/tools/bpf/bpftool/prog.c
+++ b/tools/bpf/bpftool/prog.c
@@ -1231,8 +1231,11 @@ static int do_run(int argc, char **argv)
 
 static int load_with_options(int argc, char **argv, bool first_prog_only)
 {
-	struct bpf_object_load_attr load_attr = { 0 };
 	enum bpf_prog_type common_prog_type = BPF_PROG_TYPE_UNSPEC;
+	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, open_opts,
+		.relaxed_maps = relaxed_maps,
+	);
+	struct bpf_object_load_attr load_attr = { 0 };
 	enum bpf_attach_type expected_attach_type;
 	struct map_replace *map_replace = NULL;
 	struct bpf_program *prog = NULL, *pos;
@@ -1246,9 +1249,6 @@ static int load_with_options(int argc, char **argv, bool first_prog_only)
 	const char *file;
 	int idx, err;
 
-	LIBBPF_OPTS(bpf_object_open_opts, open_opts,
-		.relaxed_maps = relaxed_maps,
-	);
 
 	if (!REQ_ARGS(2))
 		return -1;
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
* Unmerged path tools/testing/selftests/bpf/prog_tests/attach_probe.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/core_reloc.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/reference_tracking.c
