l2tp: fix reading optional fields of L2TPv3

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jacob Wen <jian.w.wen@oracle.com>
commit 4522a70db7aa5e77526a4079628578599821b193
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4522a70d.failed

Use pskb_may_pull() to make sure the optional fields are in skb linear
parts, so we can safely read them later.

It's easy to reproduce the issue with a net driver that supports paged
skb data. Just create a L2TPv3 over IP tunnel and then generates some
network traffic.
Once reproduced, rx err in /sys/kernel/debug/l2tp/tunnels will increase.

Changes in v4:
1. s/l2tp_v3_pull_opt/l2tp_v3_ensure_opt_in_linear/
2. s/tunnel->version != L2TP_HDR_VER_2/tunnel->version == L2TP_HDR_VER_3/
3. Add 'Fixes' in commit messages.

Changes in v3:
1. To keep consistency, move the code out of l2tp_recv_common.
2. Use "net" instead of "net-next", since this is a bug fix.

Changes in v2:
1. Only fix L2TPv3 to make code simple.
   To fix both L2TPv3 and L2TPv2, we'd better refactor l2tp_recv_common.
   It's complicated to do so.
2. Reloading pointers after pskb_may_pull

Fixes: f7faffa3ff8e ("l2tp: Add L2TPv3 protocol support")
Fixes: 0d76751fad77 ("l2tp: Add L2TPv3 IP encapsulation (no UDP) support")
Fixes: a32e0eec7042 ("l2tp: introduce L2TPv3 IP encapsulation support for IPv6")
	Signed-off-by: Jacob Wen <jian.w.wen@oracle.com>
	Acked-by: Guillaume Nault <gnault@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4522a70db7aa5e77526a4079628578599821b193)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_core.h
diff --cc net/l2tp/l2tp_core.h
index fe2ba54d900d,b2ce90260c35..000000000000
--- a/net/l2tp/l2tp_core.h
+++ b/net/l2tp/l2tp_core.h
@@@ -287,6 -271,56 +287,59 @@@ static inline int l2tp_get_l2specific_l
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline u32 l2tp_tunnel_dst_mtu(const struct l2tp_tunnel *tunnel)
+ {
+ 	struct dst_entry *dst;
+ 	u32 mtu;
+ 
+ 	dst = sk_dst_get(tunnel->sock);
+ 	if (!dst)
+ 		return 0;
+ 
+ 	mtu = dst_mtu(dst);
+ 	dst_release(dst);
+ 
+ 	return mtu;
+ }
+ 
+ #ifdef CONFIG_XFRM
+ static inline bool l2tp_tunnel_uses_xfrm(const struct l2tp_tunnel *tunnel)
+ {
+ 	struct sock *sk = tunnel->sock;
+ 
+ 	return sk && (rcu_access_pointer(sk->sk_policy[0]) ||
+ 		      rcu_access_pointer(sk->sk_policy[1]));
+ }
+ #else
+ static inline bool l2tp_tunnel_uses_xfrm(const struct l2tp_tunnel *tunnel)
+ {
+ 	return false;
+ }
+ #endif
+ 
+ static inline int l2tp_v3_ensure_opt_in_linear(struct l2tp_session *session, struct sk_buff *skb,
+ 					       unsigned char **ptr, unsigned char **optr)
+ {
+ 	int opt_len = session->peer_cookie_len + l2tp_get_l2specific_len(session);
+ 
+ 	if (opt_len > 0) {
+ 		int off = *ptr - *optr;
+ 
+ 		if (!pskb_may_pull(skb, off + opt_len))
+ 			return -1;
+ 
+ 		if (skb->data != *optr) {
+ 			*optr = skb->data;
+ 			*ptr = skb->data + off;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4522a70db7aa (l2tp: fix reading optional fields of L2TPv3)
  #define l2tp_printk(ptr, type, func, fmt, ...)				\
  do {									\
  	if (((ptr)->debug) & (type))					\
diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
index 0d4c16f21f39..653f9e140b98 100644
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@ -885,6 +885,10 @@ static int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb)
 		goto error;
 	}
 
+	if (tunnel->version == L2TP_HDR_VER_3 &&
+	    l2tp_v3_ensure_opt_in_linear(session, skb, &ptr, &optr))
+		goto error;
+
 	l2tp_recv_common(session, skb, ptr, optr, hdrflags, length);
 	l2tp_session_dec_refcount(session);
 
* Unmerged path net/l2tp/l2tp_core.h
diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c
index 0bc39cc20a3f..fe9f5d2af8e2 100644
--- a/net/l2tp/l2tp_ip.c
+++ b/net/l2tp/l2tp_ip.c
@@ -165,6 +165,9 @@ static int l2tp_ip_recv(struct sk_buff *skb)
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);
 	}
 
+	if (l2tp_v3_ensure_opt_in_linear(session, skb, &ptr, &optr))
+		goto discard_sess;
+
 	l2tp_recv_common(session, skb, ptr, optr, 0, skb->len);
 	l2tp_session_dec_refcount(session);
 
diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c
index a89f8a98ec14..abe612ea8d44 100644
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@ -178,6 +178,9 @@ static int l2tp_ip6_recv(struct sk_buff *skb)
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);
 	}
 
+	if (l2tp_v3_ensure_opt_in_linear(session, skb, &ptr, &optr))
+		goto discard_sess;
+
 	l2tp_recv_common(session, skb, ptr, optr, 0, skb->len);
 	l2tp_session_dec_refcount(session);
 
