net/mlx5e: Protect hairpin entry flows list with spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Protect hairpin entry flows list with spinlock (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 96.36%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 73edca736e581a685c98d3928b4cc029932d2d5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/73edca73.failed

To remove dependency on rtnl lock, extend hairpin entry with spinlock and
use it to protect list of flows attached to hairpin entry from concurrent
modifications.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 73edca736e581a685c98d3928b4cc029932d2d5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c033e0d4fc59,0abfa9b3ec54..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -680,7 -784,10 +683,13 @@@ attach_flow
  	} else {
  		flow->nic_attr->hairpin_tirn = hpe->hp->tirn;
  	}
++<<<<<<< HEAD
++=======
+ 	flow->hpe = hpe;
+ 	spin_lock(&hpe->flows_lock);
++>>>>>>> 73edca736e58 (net/mlx5e: Protect hairpin entry flows list with spinlock)
  	list_add(&flow->hairpin, &hpe->flows);
+ 	spin_unlock(&hpe->flows_lock);
  
  	return 0;
  
@@@ -692,23 -799,16 +701,31 @@@ create_hairpin_err
  static void mlx5e_hairpin_flow_del(struct mlx5e_priv *priv,
  				   struct mlx5e_tc_flow *flow)
  {
 -	/* flow wasn't fully initialized */
 -	if (!flow->hpe)
 -		return;
 +	struct list_head *next = flow->hairpin.next;
  
+ 	spin_lock(&flow->hpe->flows_lock);
  	list_del(&flow->hairpin);
++<<<<<<< HEAD
 +
 +	/* no more hairpin flows for us, release the hairpin pair */
 +	if (list_empty(next)) {
 +		struct mlx5e_hairpin_entry *hpe;
 +
 +		hpe = list_entry(next, struct mlx5e_hairpin_entry, flows);
 +
 +		netdev_dbg(priv->netdev, "del hairpin: peer %s\n",
 +			   hpe->hp->pair->peer_mdev->priv.name);
 +
 +		mlx5e_hairpin_destroy(hpe->hp);
 +		hash_del(&hpe->hairpin_hlist);
 +		kfree(hpe);
 +	}
++=======
+ 	spin_unlock(&flow->hpe->flows_lock);
+ 
+ 	mlx5e_hairpin_put(priv, flow->hpe);
+ 	flow->hpe = NULL;
++>>>>>>> 73edca736e58 (net/mlx5e: Protect hairpin entry flows list with spinlock)
  }
  
  static int
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
