KVM/nVMX: Use kvm_vcpu_map for accessing the enlightened VMCS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author KarimAllah Ahmed <karahmed@amazon.de>
commit dee9c0493108b36e89d289c8fd6f4c90321d0d5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/dee9c049.failed

Use kvm_vcpu_map for accessing the enlightened VMCS since using
kvm_vcpu_gpa_to_page() and kmap() will only work for guest memory that has
a "struct page".

	Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dee9c0493108b36e89d289c8fd6f4c90321d0d5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/vmx/nested.c
index 2eb02eaaa147,52347dcc252c..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -1802,13 -1784,11 +1800,18 @@@ static int nested_vmx_handle_enlightene
  
  		nested_release_evmcs(vcpu);
  
++<<<<<<< HEAD
 +		vmx->nested.hv_evmcs_page = kvm_vcpu_gpa_to_page(
 +			vcpu, evmcs_gpa);
 +
 +		if (unlikely(is_error_page(vmx->nested.hv_evmcs_page)))
++=======
+ 		if (kvm_vcpu_map(vcpu, gpa_to_gfn(assist_page.current_nested_vmcs),
+ 				 &vmx->nested.hv_evmcs_map))
++>>>>>>> dee9c0493108 (KVM/nVMX: Use kvm_vcpu_map for accessing the enlightened VMCS)
  			return 0;
  
- 		vmx->nested.hv_evmcs = kmap(vmx->nested.hv_evmcs_page);
+ 		vmx->nested.hv_evmcs = vmx->nested.hv_evmcs_map.hva;
  
  		/*
  		 * Currently, KVM only supports eVMCS version 1
@@@ -4373,18 -4346,10 +4376,25 @@@ static int handle_vmclear(struct kvm_vc
  		return nested_vmx_failValid(vcpu,
  			VMXERR_VMCLEAR_VMXON_POINTER);
  
++<<<<<<< HEAD
 +	/*
 +	 * When Enlightened VMEntry is enabled on the calling CPU we treat
 +	 * memory area pointer by vmptr as Enlightened VMCS (as there's no good
 +	 * way to distinguish it from VMCS12) and we must not corrupt it by
 +	 * writing to the non-existent 'launch_state' field. The area doesn't
 +	 * have to be the currently active EVMCS on the calling CPU and there's
 +	 * nothing KVM has to do to transition it from 'active' to 'non-active'
 +	 * state. It is possible that the area will stay mapped as
 +	 * vmx->nested.hv_evmcs but this shouldn't be a problem.
 +	 */
 +	if (likely(!vmx->nested.enlightened_vmcs_enabled ||
 +		   !nested_enlightened_vmentry(vcpu, &evmcs_gpa))) {
++=======
+ 	if (vmx->nested.hv_evmcs_map.hva) {
+ 		if (vmptr == vmx->nested.hv_evmcs_vmptr)
+ 			nested_release_evmcs(vcpu);
+ 	} else {
++>>>>>>> dee9c0493108 (KVM/nVMX: Use kvm_vcpu_map for accessing the enlightened VMCS)
  		if (vmptr == vmx->nested.current_vmptr)
  			nested_release_vmcs12(vcpu);
  
* Unmerged path arch/x86/kvm/vmx/nested.c
diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.h
index c0ff305d59f7..63d37ccce3dc 100644
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@ -172,7 +172,7 @@ struct nested_vmx {
 	} smm;
 
 	gpa_t hv_evmcs_vmptr;
-	struct page *hv_evmcs_page;
+	struct kvm_host_map hv_evmcs_map;
 	struct hv_enlightened_vmcs *hv_evmcs;
 };
 
