IB/mlx5: Implement DEVX dispatching event

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 5ec9d8ee87c627a2c981d871e41f6e2a942f53fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5ec9d8ee.failed

Implement DEVX dispatching event by looking up for the applicable
subscriptions for the reported event and using their target fd to
signal/set the event.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 5ec9d8ee87c627a2c981d871e41f6e2a942f53fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	include/uapi/rdma/mlx5_user_ioctl_verbs.h
diff --cc drivers/infiniband/hw/mlx5/devx.c
index b9841ad6052e,867b9778c063..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -22,6 -24,68 +22,71 @@@ enum devx_obj_flags 
  	DEVX_OBJ_FLAGS_DCT = 1 << 1,
  };
  
++<<<<<<< HEAD
++=======
+ struct devx_async_data {
+ 	struct mlx5_ib_dev *mdev;
+ 	struct list_head list;
+ 	struct ib_uobject *fd_uobj;
+ 	struct mlx5_async_work cb_work;
+ 	u16 cmd_out_len;
+ 	/* must be last field in this structure */
+ 	struct mlx5_ib_uapi_devx_async_cmd_hdr hdr;
+ };
+ 
+ struct devx_async_event_data {
+ 	struct list_head list; /* headed in ev_file->event_list */
+ 	struct mlx5_ib_uapi_devx_async_event_hdr hdr;
+ };
+ 
+ /* first level XA value data structure */
+ struct devx_event {
+ 	struct xarray object_ids; /* second XA level, Key = object id */
+ 	struct list_head unaffiliated_list;
+ };
+ 
+ /* second level XA value data structure */
+ struct devx_obj_event {
+ 	struct rcu_head rcu;
+ 	struct list_head obj_sub_list;
+ };
+ 
+ struct devx_event_subscription {
+ 	struct list_head file_list; /* headed in ev_file->
+ 				     * subscribed_events_list
+ 				     */
+ 	struct list_head xa_list; /* headed in devx_event->unaffiliated_list or
+ 				   * devx_obj_event->obj_sub_list
+ 				   */
+ 	struct list_head obj_list; /* headed in devx_object */
+ 	struct list_head event_list; /* headed in ev_file->event_list or in
+ 				      * temp list via subscription
+ 				      */
+ 
+ 	u8 is_cleaned:1;
+ 	u32 xa_key_level1;
+ 	u32 xa_key_level2;
+ 	struct rcu_head	rcu;
+ 	u64 cookie;
+ 	struct devx_async_event_file *ev_file;
+ 	struct file *filp; /* Upon hot unplug we need a direct access to */
+ 	struct eventfd_ctx *eventfd;
+ };
+ 
+ struct devx_async_event_file {
+ 	struct ib_uobject uobj;
+ 	/* Head of events that are subscribed to this FD */
+ 	struct list_head subscribed_events_list;
+ 	spinlock_t lock;
+ 	wait_queue_head_t poll_wait;
+ 	struct list_head event_list;
+ 	struct mlx5_ib_dev *dev;
+ 	u8 omit_data:1;
+ 	u8 is_overflow_err:1;
+ 	u8 is_destroyed:1;
+ };
+ 
++>>>>>>> 5ec9d8ee87c6 (IB/mlx5: Implement DEVX dispatching event)
  #define MLX5_MAX_DESTROY_INBOX_SIZE_DW MLX5_ST_SZ_DW(delete_fte_in)
  struct devx_obj {
  	struct mlx5_core_dev	*mdev;
@@@ -138,6 -203,127 +203,130 @@@ bool mlx5_ib_devx_is_flow_counter(void 
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static bool is_legacy_unaffiliated_event_num(u16 event_num)
+ {
+ 	switch (event_num) {
+ 	case MLX5_EVENT_TYPE_PORT_CHANGE:
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static bool is_legacy_obj_event_num(u16 event_num)
+ {
+ 	switch (event_num) {
+ 	case MLX5_EVENT_TYPE_PATH_MIG:
+ 	case MLX5_EVENT_TYPE_COMM_EST:
+ 	case MLX5_EVENT_TYPE_SQ_DRAINED:
+ 	case MLX5_EVENT_TYPE_SRQ_LAST_WQE:
+ 	case MLX5_EVENT_TYPE_SRQ_RQ_LIMIT:
+ 	case MLX5_EVENT_TYPE_CQ_ERROR:
+ 	case MLX5_EVENT_TYPE_WQ_CATAS_ERROR:
+ 	case MLX5_EVENT_TYPE_PATH_MIG_FAILED:
+ 	case MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:
+ 	case MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:
+ 	case MLX5_EVENT_TYPE_SRQ_CATAS_ERROR:
+ 	case MLX5_EVENT_TYPE_DCT_DRAINED:
+ 	case MLX5_EVENT_TYPE_COMP:
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static u16 get_legacy_obj_type(u16 opcode)
+ {
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_CREATE_RQ:
+ 		return MLX5_EVENT_QUEUE_TYPE_RQ;
+ 	case MLX5_CMD_OP_CREATE_QP:
+ 		return MLX5_EVENT_QUEUE_TYPE_QP;
+ 	case MLX5_CMD_OP_CREATE_SQ:
+ 		return MLX5_EVENT_QUEUE_TYPE_SQ;
+ 	case MLX5_CMD_OP_CREATE_DCT:
+ 		return MLX5_EVENT_QUEUE_TYPE_DCT;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static u16 get_dec_obj_type(struct devx_obj *obj, u16 event_num)
+ {
+ 	u16 opcode;
+ 
+ 	opcode = (obj->obj_id >> 32) & 0xffff;
+ 
+ 	if (is_legacy_obj_event_num(event_num))
+ 		return get_legacy_obj_type(opcode);
+ 
+ 	switch (opcode) {
+ 	case MLX5_CMD_OP_CREATE_GENERAL_OBJECT:
+ 		return (obj->obj_id >> 48);
+ 	case MLX5_CMD_OP_CREATE_RQ:
+ 		return MLX5_OBJ_TYPE_RQ;
+ 	case MLX5_CMD_OP_CREATE_QP:
+ 		return MLX5_OBJ_TYPE_QP;
+ 	case MLX5_CMD_OP_CREATE_SQ:
+ 		return MLX5_OBJ_TYPE_SQ;
+ 	case MLX5_CMD_OP_CREATE_DCT:
+ 		return MLX5_OBJ_TYPE_DCT;
+ 	case MLX5_CMD_OP_CREATE_TIR:
+ 		return MLX5_OBJ_TYPE_TIR;
+ 	case MLX5_CMD_OP_CREATE_TIS:
+ 		return MLX5_OBJ_TYPE_TIS;
+ 	case MLX5_CMD_OP_CREATE_PSV:
+ 		return MLX5_OBJ_TYPE_PSV;
+ 	case MLX5_OBJ_TYPE_MKEY:
+ 		return MLX5_OBJ_TYPE_MKEY;
+ 	case MLX5_CMD_OP_CREATE_RMP:
+ 		return MLX5_OBJ_TYPE_RMP;
+ 	case MLX5_CMD_OP_CREATE_XRC_SRQ:
+ 		return MLX5_OBJ_TYPE_XRC_SRQ;
+ 	case MLX5_CMD_OP_CREATE_XRQ:
+ 		return MLX5_OBJ_TYPE_XRQ;
+ 	case MLX5_CMD_OP_CREATE_RQT:
+ 		return MLX5_OBJ_TYPE_RQT;
+ 	case MLX5_CMD_OP_ALLOC_FLOW_COUNTER:
+ 		return MLX5_OBJ_TYPE_FLOW_COUNTER;
+ 	case MLX5_CMD_OP_CREATE_CQ:
+ 		return MLX5_OBJ_TYPE_CQ;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static u16 get_event_obj_type(unsigned long event_type, struct mlx5_eqe *eqe)
+ {
+ 	switch (event_type) {
+ 	case MLX5_EVENT_TYPE_WQ_CATAS_ERROR:
+ 	case MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:
+ 	case MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:
+ 	case MLX5_EVENT_TYPE_SRQ_LAST_WQE:
+ 	case MLX5_EVENT_TYPE_PATH_MIG:
+ 	case MLX5_EVENT_TYPE_PATH_MIG_FAILED:
+ 	case MLX5_EVENT_TYPE_COMM_EST:
+ 	case MLX5_EVENT_TYPE_SQ_DRAINED:
+ 	case MLX5_EVENT_TYPE_SRQ_RQ_LIMIT:
+ 	case MLX5_EVENT_TYPE_SRQ_CATAS_ERROR:
+ 		return eqe->data.qp_srq.type;
+ 	case MLX5_EVENT_TYPE_CQ_ERROR:
+ 		return 0;
+ 	case MLX5_EVENT_TYPE_DCT_DRAINED:
+ 		return MLX5_EVENT_QUEUE_TYPE_DCT;
+ 	default:
+ 		return MLX5_GET(affiliated_event_header, &eqe->data, obj_type);
+ 	}
+ }
+ 
+ static u32 get_dec_obj_id(u64 obj_id)
+ {
+ 	return (obj_id & 0xffffffff);
+ }
+ 
++>>>>>>> 5ec9d8ee87c6 (IB/mlx5: Implement DEVX dispatching event)
  /*
   * As the obj_id in the firmware is not globally unique the object type
   * must be considered upon checking for a valid object id.
@@@ -1486,6 -2191,203 +1675,206 @@@ static int devx_umem_cleanup(struct ib_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool is_unaffiliated_event(struct mlx5_core_dev *dev,
+ 				  unsigned long event_type)
+ {
+ 	__be64 *unaff_events;
+ 	int mask_entry;
+ 	int mask_bit;
+ 
+ 	if (!MLX5_CAP_GEN(dev, event_cap))
+ 		return is_legacy_unaffiliated_event_num(event_type);
+ 
+ 	unaff_events = MLX5_CAP_DEV_EVENT(dev,
+ 					  user_unaffiliated_events);
+ 	WARN_ON(event_type > MAX_SUPP_EVENT_NUM);
+ 
+ 	mask_entry = event_type / 64;
+ 	mask_bit = event_type % 64;
+ 
+ 	if (!(be64_to_cpu(unaff_events[mask_entry]) & (1ull << mask_bit)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static u32 devx_get_obj_id_from_event(unsigned long event_type, void *data)
+ {
+ 	struct mlx5_eqe *eqe = data;
+ 	u32 obj_id = 0;
+ 
+ 	switch (event_type) {
+ 	case MLX5_EVENT_TYPE_SRQ_CATAS_ERROR:
+ 	case MLX5_EVENT_TYPE_SRQ_RQ_LIMIT:
+ 	case MLX5_EVENT_TYPE_PATH_MIG:
+ 	case MLX5_EVENT_TYPE_COMM_EST:
+ 	case MLX5_EVENT_TYPE_SQ_DRAINED:
+ 	case MLX5_EVENT_TYPE_SRQ_LAST_WQE:
+ 	case MLX5_EVENT_TYPE_WQ_CATAS_ERROR:
+ 	case MLX5_EVENT_TYPE_PATH_MIG_FAILED:
+ 	case MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:
+ 	case MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:
+ 		obj_id = be32_to_cpu(eqe->data.qp_srq.qp_srq_n) & 0xffffff;
+ 		break;
+ 	case MLX5_EVENT_TYPE_DCT_DRAINED:
+ 		obj_id = be32_to_cpu(eqe->data.dct.dctn) & 0xffffff;
+ 		break;
+ 	case MLX5_EVENT_TYPE_CQ_ERROR:
+ 		obj_id = be32_to_cpu(eqe->data.cq_err.cqn) & 0xffffff;
+ 		break;
+ 	default:
+ 		obj_id = MLX5_GET(affiliated_event_header, &eqe->data, obj_id);
+ 		break;
+ 	}
+ 
+ 	return obj_id;
+ }
+ 
+ static int deliver_event(struct devx_event_subscription *event_sub,
+ 			 const void *data)
+ {
+ 	struct devx_async_event_file *ev_file;
+ 	struct devx_async_event_data *event_data;
+ 	unsigned long flags;
+ 
+ 	ev_file = event_sub->ev_file;
+ 
+ 	if (ev_file->omit_data) {
+ 		spin_lock_irqsave(&ev_file->lock, flags);
+ 		if (!list_empty(&event_sub->event_list)) {
+ 			spin_unlock_irqrestore(&ev_file->lock, flags);
+ 			return 0;
+ 		}
+ 
+ 		list_add_tail(&event_sub->event_list, &ev_file->event_list);
+ 		spin_unlock_irqrestore(&ev_file->lock, flags);
+ 		wake_up_interruptible(&ev_file->poll_wait);
+ 		return 0;
+ 	}
+ 
+ 	event_data = kzalloc(sizeof(*event_data) + sizeof(struct mlx5_eqe),
+ 			     GFP_ATOMIC);
+ 	if (!event_data) {
+ 		spin_lock_irqsave(&ev_file->lock, flags);
+ 		ev_file->is_overflow_err = 1;
+ 		spin_unlock_irqrestore(&ev_file->lock, flags);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	event_data->hdr.cookie = event_sub->cookie;
+ 	memcpy(event_data->hdr.out_data, data, sizeof(struct mlx5_eqe));
+ 
+ 	spin_lock_irqsave(&ev_file->lock, flags);
+ 	list_add_tail(&event_data->list, &ev_file->event_list);
+ 	spin_unlock_irqrestore(&ev_file->lock, flags);
+ 	wake_up_interruptible(&ev_file->poll_wait);
+ 
+ 	return 0;
+ }
+ 
+ static void dispatch_event_fd(struct list_head *fd_list,
+ 			      const void *data)
+ {
+ 	struct devx_event_subscription *item;
+ 
+ 	list_for_each_entry_rcu(item, fd_list, xa_list) {
+ 		if (!get_file_rcu(item->filp))
+ 			continue;
+ 
+ 		if (item->eventfd) {
+ 			eventfd_signal(item->eventfd, 1);
+ 			fput(item->filp);
+ 			continue;
+ 		}
+ 
+ 		deliver_event(item, data);
+ 		fput(item->filp);
+ 	}
+ }
+ 
+ static int devx_event_notifier(struct notifier_block *nb,
+ 			       unsigned long event_type, void *data)
+ {
+ 	struct mlx5_devx_event_table *table;
+ 	struct mlx5_ib_dev *dev;
+ 	struct devx_event *event;
+ 	struct devx_obj_event *obj_event;
+ 	u16 obj_type = 0;
+ 	bool is_unaffiliated;
+ 	u32 obj_id;
+ 
+ 	/* Explicit filtering to kernel events which may occur frequently */
+ 	if (event_type == MLX5_EVENT_TYPE_CMD ||
+ 	    event_type == MLX5_EVENT_TYPE_PAGE_REQUEST)
+ 		return NOTIFY_OK;
+ 
+ 	table = container_of(nb, struct mlx5_devx_event_table, devx_nb.nb);
+ 	dev = container_of(table, struct mlx5_ib_dev, devx_event_table);
+ 	is_unaffiliated = is_unaffiliated_event(dev->mdev, event_type);
+ 
+ 	if (!is_unaffiliated)
+ 		obj_type = get_event_obj_type(event_type, data);
+ 
+ 	rcu_read_lock();
+ 	event = xa_load(&table->event_xa, event_type | (obj_type << 16));
+ 	if (!event) {
+ 		rcu_read_unlock();
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	if (is_unaffiliated) {
+ 		dispatch_event_fd(&event->unaffiliated_list, data);
+ 		rcu_read_unlock();
+ 		return NOTIFY_OK;
+ 	}
+ 
+ 	obj_id = devx_get_obj_id_from_event(event_type, data);
+ 	obj_event = xa_load(&event->object_ids, obj_id);
+ 	if (!obj_event) {
+ 		rcu_read_unlock();
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	dispatch_event_fd(&obj_event->obj_sub_list, data);
+ 
+ 	rcu_read_unlock();
+ 	return NOTIFY_OK;
+ }
+ 
+ void mlx5_ib_devx_init_event_table(struct mlx5_ib_dev *dev)
+ {
+ 	struct mlx5_devx_event_table *table = &dev->devx_event_table;
+ 
+ 	xa_init(&table->event_xa);
+ 	mutex_init(&table->event_xa_lock);
+ 	MLX5_NB_INIT(&table->devx_nb, devx_event_notifier, NOTIFY_ANY);
+ 	mlx5_eq_notifier_register(dev->mdev, &table->devx_nb);
+ }
+ 
+ void mlx5_ib_devx_cleanup_event_table(struct mlx5_ib_dev *dev)
+ {
+ 	struct mlx5_devx_event_table *table = &dev->devx_event_table;
+ 	struct devx_event_subscription *sub, *tmp;
+ 	struct devx_event *event;
+ 	void *entry;
+ 	unsigned long id;
+ 
+ 	mlx5_eq_notifier_unregister(dev->mdev, &table->devx_nb);
+ 	mutex_lock(&dev->devx_event_table.event_xa_lock);
+ 	xa_for_each(&table->event_xa, id, entry) {
+ 		event = entry;
+ 		list_for_each_entry_safe(sub, tmp, &event->unaffiliated_list,
+ 					 xa_list)
+ 			devx_cleanup_subscription(dev, sub);
+ 		kfree(entry);
+ 	}
+ 	mutex_unlock(&dev->devx_event_table.event_xa_lock);
+ 	xa_destroy(&table->event_xa);
+ }
+ 
++>>>>>>> 5ec9d8ee87c6 (IB/mlx5: Implement DEVX dispatching event)
  static ssize_t devx_async_cmd_event_read(struct file *filp, char __user *buf,
  					 size_t count, loff_t *pos)
  {
@@@ -1565,9 -2486,180 +1954,186 @@@ static const struct file_operations dev
  	.llseek	 = no_llseek,
  };
  
++<<<<<<< HEAD
++static int devx_hot_unplug_async_cmd_event_file(struct ib_uobject *uobj,
++						   enum rdma_remove_reason why)
++{
++=======
+ static ssize_t devx_async_event_read(struct file *filp, char __user *buf,
+ 				     size_t count, loff_t *pos)
+ {
+ 	struct devx_async_event_file *ev_file = filp->private_data;
+ 	struct devx_event_subscription *event_sub;
+ 	struct devx_async_event_data *uninitialized_var(event);
+ 	int ret = 0;
+ 	size_t eventsz;
+ 	bool omit_data;
+ 	void *event_data;
+ 
+ 	omit_data = ev_file->omit_data;
+ 
+ 	spin_lock_irq(&ev_file->lock);
+ 
+ 	if (ev_file->is_overflow_err) {
+ 		ev_file->is_overflow_err = 0;
+ 		spin_unlock_irq(&ev_file->lock);
+ 		return -EOVERFLOW;
+ 	}
+ 
+ 	if (ev_file->is_destroyed) {
+ 		spin_unlock_irq(&ev_file->lock);
+ 		return -EIO;
+ 	}
+ 
+ 	while (list_empty(&ev_file->event_list)) {
+ 		spin_unlock_irq(&ev_file->lock);
+ 
+ 		if (filp->f_flags & O_NONBLOCK)
+ 			return -EAGAIN;
+ 
+ 		if (wait_event_interruptible(ev_file->poll_wait,
+ 			    (!list_empty(&ev_file->event_list) ||
+ 			     ev_file->is_destroyed))) {
+ 			return -ERESTARTSYS;
+ 		}
+ 
+ 		spin_lock_irq(&ev_file->lock);
+ 		if (ev_file->is_destroyed) {
+ 			spin_unlock_irq(&ev_file->lock);
+ 			return -EIO;
+ 		}
+ 	}
+ 
+ 	if (omit_data) {
+ 		event_sub = list_first_entry(&ev_file->event_list,
+ 					struct devx_event_subscription,
+ 					event_list);
+ 		eventsz = sizeof(event_sub->cookie);
+ 		event_data = &event_sub->cookie;
+ 	} else {
+ 		event = list_first_entry(&ev_file->event_list,
+ 				      struct devx_async_event_data, list);
+ 		eventsz = sizeof(struct mlx5_eqe) +
+ 			sizeof(struct mlx5_ib_uapi_devx_async_event_hdr);
+ 		event_data = &event->hdr;
+ 	}
+ 
+ 	if (eventsz > count) {
+ 		spin_unlock_irq(&ev_file->lock);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (omit_data)
+ 		list_del_init(&event_sub->event_list);
+ 	else
+ 		list_del(&event->list);
+ 
+ 	spin_unlock_irq(&ev_file->lock);
+ 
+ 	if (copy_to_user(buf, event_data, eventsz))
+ 		/* This points to an application issue, not a kernel concern */
+ 		ret = -EFAULT;
+ 	else
+ 		ret = eventsz;
+ 
+ 	if (!omit_data)
+ 		kfree(event);
+ 	return ret;
+ }
+ 
+ static __poll_t devx_async_event_poll(struct file *filp,
+ 				      struct poll_table_struct *wait)
+ {
+ 	struct devx_async_event_file *ev_file = filp->private_data;
+ 	__poll_t pollflags = 0;
+ 
+ 	poll_wait(filp, &ev_file->poll_wait, wait);
+ 
+ 	spin_lock_irq(&ev_file->lock);
+ 	if (ev_file->is_destroyed)
+ 		pollflags = EPOLLIN | EPOLLRDNORM | EPOLLRDHUP;
+ 	else if (!list_empty(&ev_file->event_list))
+ 		pollflags = EPOLLIN | EPOLLRDNORM;
+ 	spin_unlock_irq(&ev_file->lock);
+ 
+ 	return pollflags;
+ }
+ 
+ static int devx_async_event_close(struct inode *inode, struct file *filp)
+ {
+ 	struct devx_async_event_file *ev_file = filp->private_data;
+ 	struct devx_event_subscription *event_sub, *event_sub_tmp;
+ 	struct devx_async_event_data *entry, *tmp;
+ 
+ 	mutex_lock(&ev_file->dev->devx_event_table.event_xa_lock);
+ 	/* delete the subscriptions which are related to this FD */
+ 	list_for_each_entry_safe(event_sub, event_sub_tmp,
+ 				 &ev_file->subscribed_events_list, file_list) {
+ 		devx_cleanup_subscription(ev_file->dev, event_sub);
+ 		if (event_sub->eventfd)
+ 			eventfd_ctx_put(event_sub->eventfd);
+ 
+ 		list_del_rcu(&event_sub->file_list);
+ 		/* subscription may not be used by the read API any more */
+ 		kfree_rcu(event_sub, rcu);
+ 	}
+ 
+ 	mutex_unlock(&ev_file->dev->devx_event_table.event_xa_lock);
+ 
+ 	/* free the pending events allocation */
+ 	if (!ev_file->omit_data) {
+ 		spin_lock_irq(&ev_file->lock);
+ 		list_for_each_entry_safe(entry, tmp,
+ 					 &ev_file->event_list, list)
+ 			kfree(entry); /* read can't come any more */
+ 		spin_unlock_irq(&ev_file->lock);
+ 	}
+ 
+ 	uverbs_close_fd(filp);
+ 	put_device(&ev_file->dev->ib_dev.dev);
+ 	return 0;
+ }
+ 
+ static const struct file_operations devx_async_event_fops = {
+ 	.owner	 = THIS_MODULE,
+ 	.read	 = devx_async_event_read,
+ 	.poll    = devx_async_event_poll,
+ 	.release = devx_async_event_close,
+ 	.llseek	 = no_llseek,
+ };
+ 
  static int devx_hot_unplug_async_cmd_event_file(struct ib_uobject *uobj,
  						   enum rdma_remove_reason why)
  {
+ 	struct devx_async_cmd_event_file *comp_ev_file =
+ 		container_of(uobj, struct devx_async_cmd_event_file,
+ 			     uobj);
+ 	struct devx_async_event_queue *ev_queue = &comp_ev_file->ev_queue;
+ 
+ 	spin_lock_irq(&ev_queue->lock);
+ 	ev_queue->is_destroyed = 1;
+ 	spin_unlock_irq(&ev_queue->lock);
+ 
+ 	if (why == RDMA_REMOVE_DRIVER_REMOVE)
+ 		wake_up_interruptible(&ev_queue->poll_wait);
+ 
+ 	mlx5_cmd_cleanup_async_ctx(&comp_ev_file->async_ctx);
+ 	return 0;
+ };
+ 
+ static int devx_hot_unplug_async_event_file(struct ib_uobject *uobj,
+ 					    enum rdma_remove_reason why)
+ {
+ 	struct devx_async_event_file *ev_file =
+ 		container_of(uobj, struct devx_async_event_file,
+ 			     uobj);
+ 
+ 	spin_lock_irq(&ev_file->lock);
+ 	ev_file->is_destroyed = 1;
+ 	spin_unlock_irq(&ev_file->lock);
+ 
+ 	wake_up_interruptible(&ev_file->poll_wait);
++>>>>>>> 5ec9d8ee87c6 (IB/mlx5: Implement DEVX dispatching event)
  	return 0;
  };
  
diff --cc include/uapi/rdma/mlx5_user_ioctl_verbs.h
index 173ec938ff3a,7e9900b0e746..000000000000
--- a/include/uapi/rdma/mlx5_user_ioctl_verbs.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_verbs.h
@@@ -52,5 -52,25 +52,28 @@@ enum mlx5_ib_uapi_flow_action_packet_re
  	MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L3_TUNNEL = 0x3,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ib_uapi_devx_async_cmd_hdr {
+ 	__aligned_u64	wr_id;
+ 	__u8		out_data[];
+ };
+ 
+ enum mlx5_ib_uapi_dm_type {
+ 	MLX5_IB_UAPI_DM_TYPE_MEMIC,
+ 	MLX5_IB_UAPI_DM_TYPE_STEERING_SW_ICM,
+ 	MLX5_IB_UAPI_DM_TYPE_HEADER_MODIFY_SW_ICM,
+ };
+ 
+ enum mlx5_ib_uapi_devx_create_event_channel_flags {
+ 	MLX5_IB_UAPI_DEVX_CR_EV_CH_FLAGS_OMIT_DATA = 1 << 0,
+ };
+ 
+ struct mlx5_ib_uapi_devx_async_event_hdr {
+ 	__aligned_u64	cookie;
+ 	__u8		out_data[];
+ };
+ 
++>>>>>>> 5ec9d8ee87c6 (IB/mlx5: Implement DEVX dispatching event)
  #endif
  
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path include/uapi/rdma/mlx5_user_ioctl_verbs.h
