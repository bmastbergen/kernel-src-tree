net/mlx5: E-Switch, Correct type to u16 for vport_num and int for vport_index

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Correct type to u16 for vport_num and int for vport_index (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 97.33%
commit-author Parav Pandit <parav@mellanox.com>
commit 02f3afd97556017872a2d01d03d4ce66f8421a65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/02f3afd9.failed

To avoid any ambiguity between vport index and vport number,
rename functions that had vport, to vport_num or vport_index appropriately.

vport_num is u16 hence change mlx5_eswitch_index_to_vport_num() return
type to u16.

vport_index is an int in vport array. Hence change input type of vport
index in mlx5_eswitch_index_to_vport_num() to int.

Correct multiple eswitch representor interfaces use type u16 of
rep->vport as type int vport_index.

Send vport FW commands with correct eswitch u16 vport_num instead
host int vport_index.

Fixes: 5ae5162066d8 ("net/mlx5: E-Switch, Assign a different position for uplink rep and vport")
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Vu Pham <vuhuong@mellanox.com>
	Reviewed-by: Bodong Wang <bodong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 02f3afd97556017872a2d01d03d4ce66f8421a65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/ib_rep.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/infiniband/hw/mlx5/ib_rep.h
index 2ba73636a2fb,8336e0517a5c..000000000000
--- a/drivers/infiniband/hw/mlx5/ib_rep.h
+++ b/drivers/infiniband/hw/mlx5/ib_rep.h
@@@ -10,18 -10,21 +10,27 @@@
  #include "mlx5_ib.h"
  
  #ifdef CONFIG_MLX5_ESWITCH
 -extern const struct mlx5_ib_profile uplink_rep_profile;
 -
  u8 mlx5_ib_eswitch_mode(struct mlx5_eswitch *esw);
  struct mlx5_ib_dev *mlx5_ib_get_rep_ibdev(struct mlx5_eswitch *esw,
- 					  int vport_index);
+ 					  u16 vport_num);
  struct mlx5_ib_dev *mlx5_ib_get_uplink_ibdev(struct mlx5_eswitch *esw);
  struct mlx5_eswitch_rep *mlx5_ib_vport_rep(struct mlx5_eswitch *esw,
++<<<<<<< HEAD
 +					   int vport_index);
 +void mlx5_ib_register_vport_reps(struct mlx5_ib_dev *dev);
 +void mlx5_ib_unregister_vport_reps(struct mlx5_ib_dev *dev);
 +int create_flow_rule_vport_sq(struct mlx5_ib_dev *dev,
 +			      struct mlx5_ib_sq *sq);
++=======
+ 					   u16 vport_num);
+ void mlx5_ib_register_vport_reps(struct mlx5_core_dev *mdev);
+ void mlx5_ib_unregister_vport_reps(struct mlx5_core_dev *mdev);
+ struct mlx5_flow_handle *create_flow_rule_vport_sq(struct mlx5_ib_dev *dev,
+ 						   struct mlx5_ib_sq *sq,
+ 						   u16 port);
++>>>>>>> 02f3afd97556 (net/mlx5: E-Switch, Correct type to u16 for vport_num and int for vport_index)
  struct net_device *mlx5_ib_get_rep_netdev(struct mlx5_eswitch *esw,
- 					  int vport_index);
+ 					  u16 vport_num);
  #else /* CONFIG_MLX5_ESWITCH */
  static inline u8 mlx5_ib_eswitch_mode(struct mlx5_eswitch *esw)
  {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 881a0621eae0,6a921e24cd5e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1515,9 -1526,9 +1515,9 @@@ static void node_guid_gen_from_mac(u64 
  static void esw_apply_vport_conf(struct mlx5_eswitch *esw,
  				 struct mlx5_vport *vport)
  {
- 	int vport_num = vport->vport;
+ 	u16 vport_num = vport->vport;
  
 -	if (esw->manager_vport == vport_num)
 +	if (!vport_num)
  		return;
  
  	mlx5_modify_vport_admin_state(esw->dev,
@@@ -1864,12 -1914,10 +1864,12 @@@ void mlx5_eswitch_cleanup(struct mlx5_e
  }
  
  /* Vport Administration */
 +#define LEGAL_VPORT(esw, vport) (vport >= 0 && vport < esw->total_vports)
 +
  int mlx5_eswitch_set_vport_mac(struct mlx5_eswitch *esw,
- 			       int vport, u8 mac[ETH_ALEN])
+ 			       u16 vport, u8 mac[ETH_ALEN])
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
  	u64 node_guid;
  	int err = 0;
  
@@@ -1912,9 -1959,9 +1912,9 @@@ unlock
  }
  
  int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,
- 				 int vport, int link_state)
+ 				 u16 vport, int link_state)
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
  	int err = 0;
  
  	if (!ESW_ALLOWED(esw))
@@@ -1943,16 -1989,12 +1943,16 @@@ unlock
  }
  
  int mlx5_eswitch_get_vport_config(struct mlx5_eswitch *esw,
- 				  int vport, struct ifla_vf_info *ivi)
+ 				  u16 vport, struct ifla_vf_info *ivi)
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
 +
 +	if (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager))
 +		return -EPERM;
 +	if (!LEGAL_VPORT(esw, vport))
 +		return -EINVAL;
  
 -	if (IS_ERR(evport))
 -		return PTR_ERR(evport);
 +	evport = &esw->vports[vport];
  
  	memset(ivi, 0, sizeof(*ivi));
  	ivi->vf = vport - 1;
@@@ -1972,9 -2014,9 +1972,9 @@@
  }
  
  int __mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,
- 				  int vport, u16 vlan, u8 qos, u8 set_flags)
+ 				  u16 vport, u16 vlan, u8 qos, u8 set_flags)
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
  	int err = 0;
  
  	if (!ESW_ALLOWED(esw))
@@@ -2015,9 -2058,9 +2015,9 @@@ int mlx5_eswitch_set_vport_vlan(struct 
  }
  
  int mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,
- 				    int vport, bool spoofchk)
+ 				    u16 vport, bool spoofchk)
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
  	bool pschk;
  	int err = 0;
  
@@@ -2166,9 -2208,9 +2166,9 @@@ out
  }
  
  int mlx5_eswitch_set_vport_trust(struct mlx5_eswitch *esw,
- 				 int vport, bool setting)
+ 				 u16 vport, bool setting)
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
  
  	if (!ESW_ALLOWED(esw))
  		return -EPERM;
@@@ -2239,10 -2278,10 +2239,10 @@@ static int normalize_vports_min_rate(st
  	return 0;
  }
  
- int mlx5_eswitch_set_vport_rate(struct mlx5_eswitch *esw, int vport,
+ int mlx5_eswitch_set_vport_rate(struct mlx5_eswitch *esw, u16 vport,
  				u32 max_rate, u32 min_rate)
  {
 -	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
 +	struct mlx5_vport *evport;
  	u32 fw_max_bw_share;
  	u32 previous_min_rate;
  	u32 divider;
@@@ -2331,9 -2368,10 +2331,13 @@@ static int mlx5_eswitch_query_vport_dro
  }
  
  int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,
++<<<<<<< HEAD
 +				 int vport,
++=======
+ 				 u16 vport_num,
++>>>>>>> 02f3afd97556 (net/mlx5: E-Switch, Correct type to u16 for vport_num and int for vport_index)
  				 struct ifla_vf_stats *vf_stats)
  {
 -	struct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);
  	int outlen = MLX5_ST_SZ_BYTES(query_vport_counter_out);
  	u32 in[MLX5_ST_SZ_DW(query_vport_counter_in)] = {0};
  	struct mlx5_vport_drop_stats stats = {0};
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 14d8d502a0a3,d043d6f9797d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -385,6 -397,52 +385,55 @@@ bool mlx5_esw_multipath_prereq(struct m
  #define esw_debug(dev, format, ...)				\
  	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
  
++<<<<<<< HEAD
++=======
+ /* The returned number is valid only when the dev is eswitch manager. */
+ static inline u16 mlx5_eswitch_manager_vport(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_core_is_ecpf_esw_manager(dev) ?
+ 		MLX5_VPORT_ECPF : MLX5_VPORT_PF;
+ }
+ 
+ static inline int mlx5_eswitch_uplink_idx(struct mlx5_eswitch *esw)
+ {
+ 	/* Uplink always locate at the last element of the array.*/
+ 	return esw->total_vports - 1;
+ }
+ 
+ static inline int mlx5_eswitch_ecpf_idx(struct mlx5_eswitch *esw)
+ {
+ 	return esw->total_vports - 2;
+ }
+ 
+ static inline int mlx5_eswitch_vport_num_to_index(struct mlx5_eswitch *esw,
+ 						  u16 vport_num)
+ {
+ 	if (vport_num == MLX5_VPORT_ECPF) {
+ 		if (!mlx5_ecpf_vport_exists(esw->dev))
+ 			esw_warn(esw->dev, "ECPF vport doesn't exist!\n");
+ 		return mlx5_eswitch_ecpf_idx(esw);
+ 	}
+ 
+ 	if (vport_num == MLX5_VPORT_UPLINK)
+ 		return mlx5_eswitch_uplink_idx(esw);
+ 
+ 	return vport_num;
+ }
+ 
+ static inline u16 mlx5_eswitch_index_to_vport_num(struct mlx5_eswitch *esw,
+ 						  int index)
+ {
+ 	if (index == mlx5_eswitch_ecpf_idx(esw) &&
+ 	    mlx5_ecpf_vport_exists(esw->dev))
+ 		return MLX5_VPORT_ECPF;
+ 
+ 	if (index == mlx5_eswitch_uplink_idx(esw))
+ 		return MLX5_VPORT_UPLINK;
+ 
+ 	return index;
+ }
+ 
++>>>>>>> 02f3afd97556 (net/mlx5: E-Switch, Correct type to u16 for vport_num and int for vport_index)
  /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
  void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 5d30117c7129,2060456ddcd0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -49,6 -52,17 +49,20 @@@
  #define fdb_prio_table(esw, chain, prio, level) \
  	(esw)->fdb_table.offloads.fdb_prio[(chain)][(prio)][(level)]
  
++<<<<<<< HEAD
++=======
+ #define UPLINK_REP_INDEX 0
+ 
+ static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
+ 						     u16 vport_num)
+ {
+ 	int idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	WARN_ON(idx > esw->total_vports - 1);
+ 	return &esw->offloads.vport_reps[idx];
+ }
+ 
++>>>>>>> 02f3afd97556 (net/mlx5: E-Switch, Correct type to u16 for vport_num and int for vport_index)
  static struct mlx5_flow_table *
  esw_get_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
  static void
@@@ -1995,18 -2244,14 +2010,18 @@@ void *mlx5_eswitch_get_uplink_priv(stru
  }
  
  void *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,
- 				 int vport,
+ 				 u16 vport,
  				 u8 rep_type)
  {
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
  
 -	rep = mlx5_eswitch_get_rep(esw, vport);
 +	if (vport == FDB_UPLINK_VPORT)
 +		vport = UPLINK_REP_INDEX;
 +
 +	rep = &offloads->vport_reps[vport];
  
 -	if (atomic_read(&rep->rep_if[rep_type].state) == REP_LOADED &&
 +	if (rep->rep_if[rep_type].valid &&
  	    rep->rep_if[rep_type].get_proto_dev)
  		return rep->rep_if[rep_type].get_proto_dev(rep);
  	return NULL;
@@@ -2020,8 -2265,8 +2035,8 @@@ void *mlx5_eswitch_uplink_get_proto_dev
  EXPORT_SYMBOL(mlx5_eswitch_uplink_get_proto_dev);
  
  struct mlx5_eswitch_rep *mlx5_eswitch_vport_rep(struct mlx5_eswitch *esw,
- 						int vport)
+ 						u16 vport)
  {
 -	return mlx5_eswitch_get_rep(esw, vport);
 +	return &esw->offloads.vport_reps[vport];
  }
  EXPORT_SYMBOL(mlx5_eswitch_vport_rep);
diff --git a/drivers/infiniband/hw/mlx5/ib_rep.c b/drivers/infiniband/hw/mlx5/ib_rep.c
index 95ac97af6166..0ecab36e3f97 100644
--- a/drivers/infiniband/hw/mlx5/ib_rep.c
+++ b/drivers/infiniband/hw/mlx5/ib_rep.c
@@ -162,15 +162,15 @@ u8 mlx5_ib_eswitch_mode(struct mlx5_eswitch *esw)
 }
 
 struct mlx5_ib_dev *mlx5_ib_get_rep_ibdev(struct mlx5_eswitch *esw,
-					  int vport_index)
+					  u16 vport_num)
 {
-	return mlx5_eswitch_get_proto_dev(esw, vport_index, REP_IB);
+	return mlx5_eswitch_get_proto_dev(esw, vport_num, REP_IB);
 }
 
 struct net_device *mlx5_ib_get_rep_netdev(struct mlx5_eswitch *esw,
-					  int vport_index)
+					  u16 vport_num)
 {
-	return mlx5_eswitch_get_proto_dev(esw, vport_index, REP_ETH);
+	return mlx5_eswitch_get_proto_dev(esw, vport_num, REP_ETH);
 }
 
 struct mlx5_ib_dev *mlx5_ib_get_uplink_ibdev(struct mlx5_eswitch *esw)
@@ -178,9 +178,10 @@ struct mlx5_ib_dev *mlx5_ib_get_uplink_ibdev(struct mlx5_eswitch *esw)
 	return mlx5_eswitch_uplink_get_proto_dev(esw, REP_IB);
 }
 
-struct mlx5_eswitch_rep *mlx5_ib_vport_rep(struct mlx5_eswitch *esw, int vport)
+struct mlx5_eswitch_rep *mlx5_ib_vport_rep(struct mlx5_eswitch *esw,
+					   u16 vport_num)
 {
-	return mlx5_eswitch_vport_rep(esw, vport);
+	return mlx5_eswitch_vport_rep(esw, vport_num);
 }
 
 int create_flow_rule_vport_sq(struct mlx5_ib_dev *dev,
* Unmerged path drivers/infiniband/hw/mlx5/ib_rep.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index fab5121ffb8f..d14aa95897c7 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -48,13 +48,13 @@ void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 				       int vport_index,
 				       u8 rep_type);
 void *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,
-				 int vport,
+				 u16 vport_num,
 				 u8 rep_type);
 struct mlx5_eswitch_rep *mlx5_eswitch_vport_rep(struct mlx5_eswitch *esw,
-						int vport);
+						u16 vport_num);
 void *mlx5_eswitch_uplink_get_proto_dev(struct mlx5_eswitch *esw, u8 rep_type);
 u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw);
 struct mlx5_flow_handle *
 mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *esw,
-				    int vport, u32 sqn);
+				    u16 vport_num, u32 sqn);
 #endif
