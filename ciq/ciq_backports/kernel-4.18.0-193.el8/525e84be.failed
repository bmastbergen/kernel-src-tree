net/mlx5e: Eswitch, change offloads num_flows type to atomic64

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Eswitch, change offloads num_flows type to atomic64 (Alaa Hleihel) [1663231 1724327 1724336]
Rebuild_FUZZ: 96.67%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 525e84bea52be145b0ae863ff8d242ce273e3bc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/525e84be.failed

Eswitch implements its own locking by means of state_lock mutex and
multiple fine-grained lock in containing data structures, and is supposed
to not rely on rtnl lock. However, eswitch offloads num_flows type is a
regular long long integer and cannot be modified concurrently. This is an
implicit assumptions that mlx5 tc is serialized (by rtnl lock or any other
means). In order to remove implicit dependency on rtnl lock, change
num_flows type to atomic64 to allow concurrent modifications.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 525e84bea52be145b0ae863ff8d242ce273e3bc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,244ad1893691..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -281,9 -316,17 +281,20 @@@ __mlx5_eswitch_del_rule(struct mlx5_esw
  			bool fwd_rule)
  {
  	bool split = (attr->split_count > 0);
 -	int i;
  
  	mlx5_del_flow_rules(rule);
++<<<<<<< HEAD
 +	esw->offloads.num_flows--;
++=======
+ 
+ 	/* unref the term table */
+ 	for (i = 0; i < MLX5_MAX_FLOW_FWD_VPORTS; i++) {
+ 		if (attr->dests[i].termtbl)
+ 			mlx5_eswitch_termtbl_put(esw, attr->dests[i].termtbl);
+ 	}
+ 
+ 	atomic64_dec(&esw->offloads.num_flows);
++>>>>>>> 525e84bea52b (net/mlx5e: Eswitch, change offloads num_flows type to atomic64)
  
  	if (fwd_rule)  {
  		esw_put_prio_table(esw, attr->chain, attr->prio, 1);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index f4a0b22e3987..be4eccb2b07d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1840,6 +1840,7 @@ int mlx5_eswitch_init(struct mlx5_core_dev *dev)
 
 	hash_init(esw->offloads.encap_tbl);
 	hash_init(esw->offloads.mod_hdr_tbl);
+	atomic64_set(&esw->offloads.num_flows, 0);
 	mutex_init(&esw->state_lock);
 
 	for (vport_num = 0; vport_num < total_vports; vport_num++) {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index af9a875f1cf1..a9cb75f55c5e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -35,6 +35,7 @@
 
 #include <linux/if_ether.h>
 #include <linux/if_link.h>
+#include <linux/atomic.h>
 #include <net/devlink.h>
 #include <linux/mlx5/device.h>
 #include <linux/mlx5/eswitch.h>
@@ -175,7 +176,7 @@ struct mlx5_esw_offload {
 	DECLARE_HASHTABLE(encap_tbl, 8);
 	DECLARE_HASHTABLE(mod_hdr_tbl, 8);
 	u8 inline_mode;
-	u64 num_flows;
+	atomic64_t num_flows;
 	enum devlink_eswitch_encap_mode encap;
 };
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
