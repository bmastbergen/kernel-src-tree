bnxt_en: Call bnxt_ulp_stop()/bnxt_ulp_start() during error recovery.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Call bnxt_ulp_stop()/bnxt_ulp_start() during error recovery (Jonathan Toppins) [1773724]
Rebuild_FUZZ: 99.27%
commit-author Vasundhara Volam <vasundhara-v.volam@broadcom.com>
commit f3a6d206c25ad9490f3a3c6d62baba9504227a75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f3a6d206.failed

Notify the RDMA driver by calling the bnxt_ulp_stop()/bnxt_ulp_start()
hooks during error recovery.  The current ULP IRQ start/stop
sequence in error recovery (which is insufficient) is replaced with the
full reset sequence when we call bnxt_ulp_stop()/bnxt_ulp_start().

	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f3a6d206c25ad9490f3a3c6d62baba9504227a75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index a4a1bf21c621,a8a2a6f79b6f..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -8341,26 -8742,59 +8341,52 @@@ static int bnxt_hwrm_if_change(struct b
  		req.flags = cpu_to_le32(FUNC_DRV_IF_CHANGE_REQ_FLAGS_UP);
  	mutex_lock(&bp->hwrm_cmd_lock);
  	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
 -	if (!rc)
 -		flags = le32_to_cpu(resp->flags);
 -	mutex_unlock(&bp->hwrm_cmd_lock);
 -	if (rc)
 -		return rc;
 -
 -	if (!up)
 -		return 0;
 -
 -	if (flags & FUNC_DRV_IF_CHANGE_RESP_FLAGS_RESC_CHANGE)
 +	if (!rc && (resp->flags &
 +		    cpu_to_le32(FUNC_DRV_IF_CHANGE_RESP_FLAGS_RESC_CHANGE)))
  		resc_reinit = true;
 -	if (flags & FUNC_DRV_IF_CHANGE_RESP_FLAGS_HOT_FW_RESET_DONE)
 -		fw_reset = true;
 +	mutex_unlock(&bp->hwrm_cmd_lock);
  
++<<<<<<< HEAD
 +	if (up && resc_reinit && BNXT_NEW_RM(bp)) {
 +		struct bnxt_hw_resc *hw_resc = &bp->hw_resc;
++=======
+ 	if (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state) && !fw_reset) {
+ 		netdev_err(bp->dev, "RESET_DONE not set during FW reset.\n");
+ 		return -ENODEV;
+ 	}
+ 	if (resc_reinit || fw_reset) {
+ 		if (fw_reset) {
+ 			if (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 				bnxt_ulp_stop(bp);
+ 			rc = bnxt_fw_init_one(bp);
+ 			if (rc) {
+ 				set_bit(BNXT_STATE_ABORT_ERR, &bp->state);
+ 				return rc;
+ 			}
+ 			bnxt_clear_int_mode(bp);
+ 			rc = bnxt_init_int_mode(bp);
+ 			if (rc) {
+ 				netdev_err(bp->dev, "init int mode failed\n");
+ 				return rc;
+ 			}
+ 			set_bit(BNXT_STATE_FW_RESET_DET, &bp->state);
+ 		}
+ 		if (BNXT_NEW_RM(bp)) {
+ 			struct bnxt_hw_resc *hw_resc = &bp->hw_resc;
++>>>>>>> f3a6d206c25a (bnxt_en: Call bnxt_ulp_stop()/bnxt_ulp_start() during error recovery.)
  
 -			rc = bnxt_hwrm_func_resc_qcaps(bp, true);
 -			hw_resc->resv_cp_rings = 0;
 -			hw_resc->resv_stat_ctxs = 0;
 -			hw_resc->resv_irqs = 0;
 -			hw_resc->resv_tx_rings = 0;
 -			hw_resc->resv_rx_rings = 0;
 -			hw_resc->resv_hw_ring_grps = 0;
 -			hw_resc->resv_vnics = 0;
 -			if (!fw_reset) {
 -				bp->tx_nr_rings = 0;
 -				bp->rx_nr_rings = 0;
 -			}
 -		}
 +		rc = bnxt_hwrm_func_resc_qcaps(bp, true);
 +		hw_resc->resv_cp_rings = 0;
 +		hw_resc->resv_stat_ctxs = 0;
 +		hw_resc->resv_irqs = 0;
 +		hw_resc->resv_tx_rings = 0;
 +		hw_resc->resv_rx_rings = 0;
 +		hw_resc->resv_hw_ring_grps = 0;
 +		hw_resc->resv_vnics = 0;
 +		bp->tx_nr_rings = 0;
 +		bp->rx_nr_rings = 0;
  	}
 -	return 0;
 +	return rc;
  }
  
  static int bnxt_hwrm_port_led_qcaps(struct bnxt *bp)
@@@ -8775,12 -9214,31 +8801,29 @@@ static int bnxt_open(struct net_device 
  	struct bnxt *bp = netdev_priv(dev);
  	int rc;
  
 -	if (test_bit(BNXT_STATE_ABORT_ERR, &bp->state)) {
 -		netdev_err(bp->dev, "A previous firmware reset did not complete, aborting\n");
 -		return -ENODEV;
 -	}
 -
 -	rc = bnxt_hwrm_if_change(bp, true);
 -	if (rc)
 -		return rc;
 +	bnxt_hwrm_if_change(bp, true);
  	rc = __bnxt_open_nic(bp, true, true);
 -	if (rc) {
 +	if (rc)
  		bnxt_hwrm_if_change(bp, false);
++<<<<<<< HEAD
 +
 +	bnxt_hwmon_open(bp);
++=======
+ 	} else {
+ 		if (test_and_clear_bit(BNXT_STATE_FW_RESET_DET, &bp->state)) {
+ 			if (BNXT_PF(bp)) {
+ 				struct bnxt_pf_info *pf = &bp->pf;
+ 				int n = pf->active_vfs;
+ 
+ 				if (n)
+ 					bnxt_cfg_hw_sriov(bp, &n, true);
+ 			}
+ 			if (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 				bnxt_ulp_start(bp, 0);
+ 		}
+ 		bnxt_hwmon_open(bp);
+ 	}
++>>>>>>> f3a6d206c25a (bnxt_en: Call bnxt_ulp_stop()/bnxt_ulp_start() during error recovery.)
  
  	return rc;
  }
@@@ -9542,6 -10054,138 +9585,141 @@@ static void bnxt_reset(struct bnxt *bp
  	bnxt_rtnl_unlock_sp(bp);
  }
  
++<<<<<<< HEAD
++=======
+ static void bnxt_fw_reset_close(struct bnxt *bp)
+ {
+ 	bnxt_ulp_stop(bp);
+ 	__bnxt_close_nic(bp, true, false);
+ 	bnxt_clear_int_mode(bp);
+ 	bnxt_hwrm_func_drv_unrgtr(bp);
+ 	bnxt_free_ctx_mem(bp);
+ 	kfree(bp->ctx);
+ 	bp->ctx = NULL;
+ }
+ 
+ static bool is_bnxt_fw_ok(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	bool no_heartbeat = false, has_reset = false;
+ 	u32 val;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);
+ 	if (val == fw_health->last_fw_heartbeat)
+ 		no_heartbeat = true;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
+ 	if (val != fw_health->last_fw_reset_cnt)
+ 		has_reset = true;
+ 
+ 	if (!no_heartbeat && has_reset)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* rtnl_lock is acquired before calling this function */
+ static void bnxt_force_fw_reset(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 wait_dsecs;
+ 
+ 	if (!test_bit(BNXT_STATE_OPEN, &bp->state) ||
+ 	    test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 		return;
+ 
+ 	set_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 	bnxt_fw_reset_close(bp);
+ 	wait_dsecs = fw_health->master_func_wait_dsecs;
+ 	if (fw_health->master) {
+ 		if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU)
+ 			wait_dsecs = 0;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;
+ 	} else {
+ 		bp->fw_reset_timestamp = jiffies + wait_dsecs * HZ / 10;
+ 		wait_dsecs = fw_health->normal_func_wait_dsecs;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 	}
+ 
+ 	bp->fw_reset_min_dsecs = fw_health->post_reset_wait_dsecs;
+ 	bp->fw_reset_max_dsecs = fw_health->post_reset_max_wait_dsecs;
+ 	bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ }
+ 
+ void bnxt_fw_exception(struct bnxt *bp)
+ {
+ 	set_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
+ 	bnxt_rtnl_lock_sp(bp);
+ 	bnxt_force_fw_reset(bp);
+ 	bnxt_rtnl_unlock_sp(bp);
+ }
+ 
+ /* Returns the number of registered VFs, or 1 if VF configuration is pending, or
+  * < 0 on error.
+  */
+ static int bnxt_get_registered_vfs(struct bnxt *bp)
+ {
+ #ifdef CONFIG_BNXT_SRIOV
+ 	int rc;
+ 
+ 	if (!BNXT_PF(bp))
+ 		return 0;
+ 
+ 	rc = bnxt_hwrm_func_qcfg(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "func_qcfg cmd failed, rc = %d\n", rc);
+ 		return rc;
+ 	}
+ 	if (bp->pf.registered_vfs)
+ 		return bp->pf.registered_vfs;
+ 	if (bp->sriov_cfg)
+ 		return 1;
+ #endif
+ 	return 0;
+ }
+ 
+ void bnxt_fw_reset(struct bnxt *bp)
+ {
+ 	bnxt_rtnl_lock_sp(bp);
+ 	if (test_bit(BNXT_STATE_OPEN, &bp->state) &&
+ 	    !test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {
+ 		int n = 0, tmo;
+ 
+ 		set_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 		if (bp->pf.active_vfs &&
+ 		    !test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))
+ 			n = bnxt_get_registered_vfs(bp);
+ 		if (n < 0) {
+ 			netdev_err(bp->dev, "Firmware reset aborted, rc = %d\n",
+ 				   n);
+ 			clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 			dev_close(bp->dev);
+ 			goto fw_reset_exit;
+ 		} else if (n > 0) {
+ 			u16 vf_tmo_dsecs = n * 10;
+ 
+ 			if (bp->fw_reset_max_dsecs < vf_tmo_dsecs)
+ 				bp->fw_reset_max_dsecs = vf_tmo_dsecs;
+ 			bp->fw_reset_state =
+ 				BNXT_FW_RESET_STATE_POLL_VF;
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			goto fw_reset_exit;
+ 		}
+ 		bnxt_fw_reset_close(bp);
+ 		if (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;
+ 			tmo = HZ / 10;
+ 		} else {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			tmo = bp->fw_reset_min_dsecs * HZ / 10;
+ 		}
+ 		bnxt_queue_fw_reset_work(bp, tmo);
+ 	}
+ fw_reset_exit:
+ 	bnxt_rtnl_unlock_sp(bp);
+ }
+ 
++>>>>>>> f3a6d206c25a (bnxt_en: Call bnxt_ulp_stop()/bnxt_ulp_start() during error recovery.)
  static void bnxt_chk_missed_irq(struct bnxt *bp)
  {
  	int i;
@@@ -9766,6 -10419,345 +9944,348 @@@ static void bnxt_init_dflt_coal(struct 
  	bp->stats_coal_ticks = BNXT_DEF_STATS_COAL_TICKS;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_fw_init_one_p1(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	bp->fw_cap = 0;
+ 	rc = bnxt_hwrm_ver_get(bp);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (bp->fw_cap & BNXT_FW_CAP_KONG_MB_CHNL) {
+ 		rc = bnxt_alloc_kong_hwrm_resources(bp);
+ 		if (rc)
+ 			bp->fw_cap &= ~BNXT_FW_CAP_KONG_MB_CHNL;
+ 	}
+ 
+ 	if ((bp->fw_cap & BNXT_FW_CAP_SHORT_CMD) ||
+ 	    bp->hwrm_max_ext_req_len > BNXT_HWRM_MAX_REQ_LEN) {
+ 		rc = bnxt_alloc_hwrm_short_cmd_req(bp);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 	rc = bnxt_hwrm_func_reset(bp);
+ 	if (rc)
+ 		return -ENODEV;
+ 
+ 	bnxt_hwrm_fw_set_time(bp);
+ 	return 0;
+ }
+ 
+ static int bnxt_fw_init_one_p2(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	/* Get the MAX capabilities for this function */
+ 	rc = bnxt_hwrm_func_qcaps(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "hwrm query capability failure rc: %x\n",
+ 			   rc);
+ 		return -ENODEV;
+ 	}
+ 
+ 	rc = bnxt_hwrm_cfa_adv_flow_mgnt_qcaps(bp);
+ 	if (rc)
+ 		netdev_warn(bp->dev, "hwrm query adv flow mgnt failure rc: %d\n",
+ 			    rc);
+ 
+ 	rc = bnxt_hwrm_error_recovery_qcfg(bp);
+ 	if (rc)
+ 		netdev_warn(bp->dev, "hwrm query error recovery failure rc: %d\n",
+ 			    rc);
+ 
+ 	rc = bnxt_hwrm_func_drv_rgtr(bp);
+ 	if (rc)
+ 		return -ENODEV;
+ 
+ 	rc = bnxt_hwrm_func_rgtr_async_events(bp, NULL, 0);
+ 	if (rc)
+ 		return -ENODEV;
+ 
+ 	bnxt_hwrm_func_qcfg(bp);
+ 	bnxt_hwrm_vnic_qcaps(bp);
+ 	bnxt_hwrm_port_led_qcaps(bp);
+ 	bnxt_ethtool_init(bp);
+ 	bnxt_dcb_init(bp);
+ 	return 0;
+ }
+ 
+ static void bnxt_set_dflt_rss_hash_type(struct bnxt *bp)
+ {
+ 	bp->flags &= ~BNXT_FLAG_UDP_RSS_CAP;
+ 	bp->rss_hash_cfg = VNIC_RSS_CFG_REQ_HASH_TYPE_IPV4 |
+ 			   VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV4 |
+ 			   VNIC_RSS_CFG_REQ_HASH_TYPE_IPV6 |
+ 			   VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV6;
+ 	if (BNXT_CHIP_P4(bp) && bp->hwrm_spec_code >= 0x10501) {
+ 		bp->flags |= BNXT_FLAG_UDP_RSS_CAP;
+ 		bp->rss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4 |
+ 				    VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6;
+ 	}
+ }
+ 
+ static void bnxt_set_dflt_rfs(struct bnxt *bp)
+ {
+ 	struct net_device *dev = bp->dev;
+ 
+ 	dev->hw_features &= ~NETIF_F_NTUPLE;
+ 	dev->features &= ~NETIF_F_NTUPLE;
+ 	bp->flags &= ~BNXT_FLAG_RFS;
+ 	if (bnxt_rfs_supported(bp)) {
+ 		dev->hw_features |= NETIF_F_NTUPLE;
+ 		if (bnxt_rfs_capable(bp)) {
+ 			bp->flags |= BNXT_FLAG_RFS;
+ 			dev->features |= NETIF_F_NTUPLE;
+ 		}
+ 	}
+ }
+ 
+ static void bnxt_fw_init_one_p3(struct bnxt *bp)
+ {
+ 	struct pci_dev *pdev = bp->pdev;
+ 
+ 	bnxt_set_dflt_rss_hash_type(bp);
+ 	bnxt_set_dflt_rfs(bp);
+ 
+ 	bnxt_get_wol_settings(bp);
+ 	if (bp->flags & BNXT_FLAG_WOL_CAP)
+ 		device_set_wakeup_enable(&pdev->dev, bp->wol);
+ 	else
+ 		device_set_wakeup_capable(&pdev->dev, false);
+ 
+ 	bnxt_hwrm_set_cache_line_size(bp, cache_line_size());
+ 	bnxt_hwrm_coal_params_qcaps(bp);
+ }
+ 
+ static int bnxt_fw_init_one(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	rc = bnxt_fw_init_one_p1(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "Firmware init phase 1 failed\n");
+ 		return rc;
+ 	}
+ 	rc = bnxt_fw_init_one_p2(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "Firmware init phase 2 failed\n");
+ 		return rc;
+ 	}
+ 	rc = bnxt_approve_mac(bp, bp->dev->dev_addr, false);
+ 	if (rc)
+ 		return rc;
+ 	bnxt_fw_init_one_p3(bp);
+ 	return 0;
+ }
+ 
+ static void bnxt_fw_reset_writel(struct bnxt *bp, int reg_idx)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 reg = fw_health->fw_reset_seq_regs[reg_idx];
+ 	u32 val = fw_health->fw_reset_seq_vals[reg_idx];
+ 	u32 reg_type, reg_off, delay_msecs;
+ 
+ 	delay_msecs = fw_health->fw_reset_seq_delay_msec[reg_idx];
+ 	reg_type = BNXT_FW_HEALTH_REG_TYPE(reg);
+ 	reg_off = BNXT_FW_HEALTH_REG_OFF(reg);
+ 	switch (reg_type) {
+ 	case BNXT_FW_HEALTH_REG_TYPE_CFG:
+ 		pci_write_config_dword(bp->pdev, reg_off, val);
+ 		break;
+ 	case BNXT_FW_HEALTH_REG_TYPE_GRC:
+ 		writel(reg_off & BNXT_GRC_BASE_MASK,
+ 		       bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT + 4);
+ 		reg_off = (reg_off & BNXT_GRC_OFFSET_MASK) + 0x2000;
+ 		/* fall through */
+ 	case BNXT_FW_HEALTH_REG_TYPE_BAR0:
+ 		writel(val, bp->bar0 + reg_off);
+ 		break;
+ 	case BNXT_FW_HEALTH_REG_TYPE_BAR1:
+ 		writel(val, bp->bar1 + reg_off);
+ 		break;
+ 	}
+ 	if (delay_msecs) {
+ 		pci_read_config_dword(bp->pdev, 0, &val);
+ 		msleep(delay_msecs);
+ 	}
+ }
+ 
+ static void bnxt_reset_all(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	int i, rc;
+ 
+ 	if (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {
+ #ifdef CONFIG_TEE_BNXT_FW
+ 		rc = tee_bnxt_fw_load();
+ 		if (rc)
+ 			netdev_err(bp->dev, "Unable to reset FW rc=%d\n", rc);
+ 		bp->fw_reset_timestamp = jiffies;
+ #endif
+ 		return;
+ 	}
+ 
+ 	if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_HOST) {
+ 		for (i = 0; i < fw_health->fw_reset_seq_cnt; i++)
+ 			bnxt_fw_reset_writel(bp, i);
+ 	} else if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU) {
+ 		struct hwrm_fw_reset_input req = {0};
+ 
+ 		bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FW_RESET, -1, -1);
+ 		req.resp_addr = cpu_to_le64(bp->hwrm_cmd_kong_resp_dma_addr);
+ 		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP;
+ 		req.selfrst_status = FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP;
+ 		req.flags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;
+ 		rc = hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 		if (rc)
+ 			netdev_warn(bp->dev, "Unable to reset FW rc=%d\n", rc);
+ 	}
+ 	bp->fw_reset_timestamp = jiffies;
+ }
+ 
+ static void bnxt_fw_reset_task(struct work_struct *work)
+ {
+ 	struct bnxt *bp = container_of(work, struct bnxt, fw_reset_task.work);
+ 	int rc;
+ 
+ 	if (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {
+ 		netdev_err(bp->dev, "bnxt_fw_reset_task() called when not in fw reset mode!\n");
+ 		return;
+ 	}
+ 
+ 	switch (bp->fw_reset_state) {
+ 	case BNXT_FW_RESET_STATE_POLL_VF: {
+ 		int n = bnxt_get_registered_vfs(bp);
+ 		int tmo;
+ 
+ 		if (n < 0) {
+ 			netdev_err(bp->dev, "Firmware reset aborted, subsequent func_qcfg cmd failed, rc = %d, %d msecs since reset timestamp\n",
+ 				   n, jiffies_to_msecs(jiffies -
+ 				   bp->fw_reset_timestamp));
+ 			goto fw_reset_abort;
+ 		} else if (n > 0) {
+ 			if (time_after(jiffies, bp->fw_reset_timestamp +
+ 				       (bp->fw_reset_max_dsecs * HZ / 10))) {
+ 				clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 				bp->fw_reset_state = 0;
+ 				netdev_err(bp->dev, "Firmware reset aborted, bnxt_get_registered_vfs() returns %d\n",
+ 					   n);
+ 				return;
+ 			}
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			return;
+ 		}
+ 		bp->fw_reset_timestamp = jiffies;
+ 		rtnl_lock();
+ 		bnxt_fw_reset_close(bp);
+ 		if (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;
+ 			tmo = HZ / 10;
+ 		} else {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			tmo = bp->fw_reset_min_dsecs * HZ / 10;
+ 		}
+ 		rtnl_unlock();
+ 		bnxt_queue_fw_reset_work(bp, tmo);
+ 		return;
+ 	}
+ 	case BNXT_FW_RESET_STATE_POLL_FW_DOWN: {
+ 		u32 val;
+ 
+ 		val = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
+ 		if (!(val & BNXT_FW_STATUS_SHUTDOWN) &&
+ 		    !time_after(jiffies, bp->fw_reset_timestamp +
+ 		    (bp->fw_reset_max_dsecs * HZ / 10))) {
+ 			bnxt_queue_fw_reset_work(bp, HZ / 5);
+ 			return;
+ 		}
+ 
+ 		if (!bp->fw_health->master) {
+ 			u32 wait_dsecs = bp->fw_health->normal_func_wait_dsecs;
+ 
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ 			return;
+ 		}
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;
+ 	}
+ 	/* fall through */
+ 	case BNXT_FW_RESET_STATE_RESET_FW: {
+ 		u32 wait_dsecs = bp->fw_health->post_reset_wait_dsecs;
+ 
+ 		bnxt_reset_all(bp);
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 		bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ 		return;
+ 	}
+ 	case BNXT_FW_RESET_STATE_ENABLE_DEV:
+ 		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) &&
+ 		    bp->fw_health) {
+ 			u32 val;
+ 
+ 			val = bnxt_fw_health_readl(bp,
+ 						   BNXT_FW_RESET_INPROG_REG);
+ 			if (val)
+ 				netdev_warn(bp->dev, "FW reset inprog %x after min wait time.\n",
+ 					    val);
+ 		}
+ 		clear_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
+ 		if (pci_enable_device(bp->pdev)) {
+ 			netdev_err(bp->dev, "Cannot re-enable PCI device\n");
+ 			goto fw_reset_abort;
+ 		}
+ 		pci_set_master(bp->pdev);
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW;
+ 		/* fall through */
+ 	case BNXT_FW_RESET_STATE_POLL_FW:
+ 		bp->hwrm_cmd_timeout = SHORT_HWRM_CMD_TIMEOUT;
+ 		rc = __bnxt_hwrm_ver_get(bp, true);
+ 		if (rc) {
+ 			if (time_after(jiffies, bp->fw_reset_timestamp +
+ 				       (bp->fw_reset_max_dsecs * HZ / 10))) {
+ 				netdev_err(bp->dev, "Firmware reset aborted\n");
+ 				goto fw_reset_abort;
+ 			}
+ 			bnxt_queue_fw_reset_work(bp, HZ / 5);
+ 			return;
+ 		}
+ 		bp->hwrm_cmd_timeout = DFLT_HWRM_CMD_TIMEOUT;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_OPENING;
+ 		/* fall through */
+ 	case BNXT_FW_RESET_STATE_OPENING:
+ 		while (!rtnl_trylock()) {
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			return;
+ 		}
+ 		rc = bnxt_open(bp->dev);
+ 		if (rc) {
+ 			netdev_err(bp->dev, "bnxt_open_nic() failed\n");
+ 			clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 			dev_close(bp->dev);
+ 		}
+ 
+ 		bp->fw_reset_state = 0;
+ 		/* Make sure fw_reset_state is 0 before clearing the flag */
+ 		smp_mb__before_atomic();
+ 		clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 		bnxt_ulp_start(bp, rc);
+ 		rtnl_unlock();
+ 		break;
+ 	}
+ 	return;
+ 
+ fw_reset_abort:
+ 	clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 	bp->fw_reset_state = 0;
+ 	rtnl_lock();
+ 	dev_close(bp->dev);
+ 	rtnl_unlock();
+ }
+ 
++>>>>>>> f3a6d206c25a (bnxt_en: Call bnxt_ulp_stop()/bnxt_ulp_start() during error recovery.)
  static int bnxt_init_board(struct pci_dev *pdev, struct net_device *dev)
  {
  	int rc;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
