net/mlx5: E-Switch, Support load/unload reps of specific vport types

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Support load/unload reps of specific vport types (Alaa Hleihel) [1724333]
Rebuild_FUZZ: 96.97%
commit-author Bodong Wang <bodong@mellanox.com>
commit 29d9fd7d5a667b120f8228da3d8a8d1b2382538d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/29d9fd7d.failed

Currently the driver loads and unloads all reps in an unbreakable
group. However, with ECPF, the reps of special vports such as uplink
and host PF should always be loaded in switchdev mode where the reps
for VFs will be loaded on-demand and unloaded on no-demand. This is
a pre-step for that change.

This patch doesn't change any functionality.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 29d9fd7d5a667b120f8228da3d8a8d1b2382538d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a13e7b20a794,7131d41796fb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1238,50 -1281,142 +1238,174 @@@ int esw_offloads_init_reps(struct mlx5_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void esw_offloads_unload_reps_type(struct mlx5_eswitch *esw, int nvports,
 +					  u8 rep_type)
 +{
 +	struct mlx5_eswitch_rep *rep;
 +	int vport;
 +
 +	for (vport = nvports - 1; vport >= 0; vport--) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
++=======
+ static void __esw_offloads_unload_rep(struct mlx5_eswitch *esw,
+ 				      struct mlx5_eswitch_rep *rep, u8 rep_type)
+ {
+ 	if (rep->rep_if[rep_type].state != REP_LOADED)
+ 		return;
+ 
+ 	rep->rep_if[rep_type].unload(rep);
+ 	rep->rep_if[rep_type].state = REP_REGISTERED;
+ }
+ 
+ static void __unload_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
+ {
+ 	struct mlx5_eswitch_rep *rep;
++>>>>>>> 29d9fd7d5a66 (net/mlx5: E-Switch, Support load/unload reps of specific vport types)
  
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	__esw_offloads_unload_rep(esw, rep, rep_type);
 +		rep->rep_if[rep_type].unload(rep);
 +	}
  }
  
- static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
+ static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
+ 				   u8 rep_type)
+ {
+ 	struct mlx5_eswitch_rep *rep;
+ 	int i;
+ 
+ 	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
+ 		__esw_offloads_unload_rep(esw, rep, rep_type);
+ }
+ 
+ static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
  {
  	u8 rep_type = NUM_REP_TYPES;
  
  	while (rep_type-- > 0)
- 		esw_offloads_unload_reps_type(esw, nvports, rep_type);
+ 		__unload_reps_vf_vport(esw, nvports, rep_type);
  }
  
+ static void __unload_reps_all_vport(struct mlx5_eswitch *esw, int nvports,
+ 				    u8 rep_type)
+ {
+ 	__unload_reps_vf_vport(esw, nvports, rep_type);
+ 
+ 	/* Special vports must be the last to unload. */
+ 	__unload_reps_special_vport(esw, rep_type);
+ }
+ 
+ static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw, int nvports)
+ {
+ 	u8 rep_type = NUM_REP_TYPES;
+ 
+ 	while (rep_type-- > 0)
+ 		__unload_reps_all_vport(esw, nvports, rep_type);
+ }
+ 
++<<<<<<< HEAD
 +static int esw_offloads_load_reps_type(struct mlx5_eswitch *esw, int nvports,
 +				       u8 rep_type)
++=======
+ static int __esw_offloads_load_rep(struct mlx5_eswitch *esw,
+ 				   struct mlx5_eswitch_rep *rep, u8 rep_type)
+ {
+ 	int err = 0;
+ 
+ 	if (rep->rep_if[rep_type].state != REP_REGISTERED)
+ 		return 0;
+ 
+ 	err = rep->rep_if[rep_type].load(esw->dev, rep);
+ 	if (err)
+ 		return err;
+ 
+ 	rep->rep_if[rep_type].state = REP_LOADED;
+ 
+ 	return 0;
+ }
+ 
+ static int __load_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
++>>>>>>> 29d9fd7d5a66 (net/mlx5: E-Switch, Support load/unload reps of specific vport types)
  {
  	struct mlx5_eswitch_rep *rep;
- 	int vport;
  	int err;
  
++<<<<<<< HEAD
 +	for (vport = 0; vport < nvports; vport++) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
 +
 +		err = rep->rep_if[rep_type].load(esw->dev, rep);
++=======
+ 	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
+ 	err = __esw_offloads_load_rep(esw, rep, rep_type);
+ 	return err;
+ }
+ 
+ static int __load_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
+ 				u8 rep_type)
+ {
+ 	struct mlx5_eswitch_rep *rep;
+ 	int err, i;
+ 
+ 	mlx5_esw_for_each_vf_rep(esw, i, rep, nvports) {
+ 		err = __esw_offloads_load_rep(esw, rep, rep_type);
++>>>>>>> 29d9fd7d5a66 (net/mlx5: E-Switch, Support load/unload reps of specific vport types)
  		if (err)
- 			goto err_reps;
+ 			goto err_vf;
  	}
  
  	return 0;
  
++<<<<<<< HEAD
 +err_reps:
 +	esw_offloads_unload_reps_type(esw, vport, rep_type);
++=======
+ err_vf:
+ 	__unload_reps_vf_vport(esw, --i, rep_type);
++>>>>>>> 29d9fd7d5a66 (net/mlx5: E-Switch, Support load/unload reps of specific vport types)
+ 	return err;
+ }
+ 
+ static int esw_offloads_load_vf_reps(struct mlx5_eswitch *esw, int nvports)
+ {
+ 	u8 rep_type = 0;
+ 	int err;
+ 
+ 	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++) {
+ 		err = __load_reps_vf_vport(esw, nvports, rep_type);
+ 		if (err)
+ 			goto err_reps;
+ 	}
+ 
+ 	return err;
+ 
+ err_reps:
+ 	while (rep_type-- > 0)
+ 		__unload_reps_vf_vport(esw, nvports, rep_type);
+ 	return err;
+ }
+ 
+ static int __load_reps_all_vport(struct mlx5_eswitch *esw, int nvports,
+ 				 u8 rep_type)
+ {
+ 	int err;
+ 
+ 	/* Special vports must be loaded first. */
+ 	err = __load_reps_special_vport(esw, rep_type);
+ 	if (err)
+ 		return err;
+ 
+ 	err = __load_reps_vf_vport(esw, nvports, rep_type);
+ 	if (err)
+ 		goto err_vfs;
+ 
+ 	return 0;
+ 
+ err_vfs:
+ 	__unload_reps_special_vport(esw, rep_type);
  	return err;
  }
  
@@@ -1447,7 -1585,7 +1571,11 @@@ int esw_offloads_init(struct mlx5_eswit
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	err = esw_offloads_load_reps(esw, nvports);
++=======
+ 	err = esw_offloads_load_all_reps(esw, vf_nvports);
++>>>>>>> 29d9fd7d5a66 (net/mlx5: E-Switch, Support load/unload reps of specific vport types)
  	if (err)
  		goto err_reps;
  
@@@ -1478,10 -1616,12 +1606,14 @@@ static int esw_offloads_stop(struct mlx
  	return err;
  }
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw)
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
  {
 -	u16 num_vfs = esw->dev->priv.sriov.num_vfs;
 -
  	esw_offloads_devcom_cleanup(esw);
++<<<<<<< HEAD
 +	esw_offloads_unload_reps(esw, nvports);
++=======
+ 	esw_offloads_unload_all_reps(esw, num_vfs);
++>>>>>>> 29d9fd7d5a66 (net/mlx5: E-Switch, Support load/unload reps of specific vport types)
  	esw_offloads_steering_cleanup(esw);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
