ASoC: soc-core: support snd_soc_dai_link_component for aux_dev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: soc-core: support snd_soc_dai_link_component for aux_dev (Jaroslav Kysela) [1738610]
Rebuild_FUZZ: 95.38%
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit 3dc29b8b2062075602c7aff1514a120b4ed0187f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3dc29b8b.failed

To find aux_dev, ASoC is using .name, codec_name, codec_of_node.
Here, .name is used to fallback in case of no codec.

But, we already have this kind of component finding method by
snd_soc_dai_link_component and soc_find_component().
We shouldn't have duplicated implementation to do same things.
This patch adds snd_soc_dai_link_component support to finding aux_dev.

Now, no driver is using only .name.
All drivers are using codec_name and/or codec_of_node.
This means no driver is finding component from .name so far.
(Actually almost all drivers are using .name as just "device name",
 not for finding component...)

This patch
1) add snd_soc_dai_link_component support for aux_dev. legacy style will
   be removed if all drivers are switched to new style.
2) try to find component via snd_soc_dai_link_component.
   Then, it doesn't try to find via .name, because no driver is using
   it so far.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Link: https://lore.kernel.org/r/87y3046wcf.wl-kuninori.morimoto.gx@renesas.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 3dc29b8b2062075602c7aff1514a120b4ed0187f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/soc-core.c
diff --cc sound/soc/soc-core.c
index c0c23b90247e,56b99e340dda..000000000000
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@@ -1645,74 -1509,50 +1645,91 @@@ static int soc_probe_link_dais(struct s
  			num = rtd->dai_link->id;
  	}
  
 -	/* create compress_device if possible */
 -	ret = snd_soc_dai_compress_new(cpu_dai, rtd, num);
 -	if (ret != -ENOTSUPP) {
 -		if (ret < 0)
 +	if (cpu_dai->driver->compress_new) {
 +		/* create compress_device" */
 +		ret = cpu_dai->driver->compress_new(rtd, num);
 +		if (ret < 0) {
  			dev_err(card->dev, "ASoC: can't create compress %s\n",
  					 dai_link->stream_name);
 -		return ret;
 +			return ret;
 +		}
 +	} else if (!dai_link->params) {
 +		/* create the pcm */
 +		ret = soc_new_pcm(rtd, num);
 +		if (ret < 0) {
 +			dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 +				dai_link->stream_name, ret);
 +			return ret;
 +		}
 +		ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
 +		if (ret < 0)
 +			return ret;
 +		ret = soc_link_dai_pcm_new(rtd->codec_dais,
 +					   rtd->num_codecs, rtd);
 +		if (ret < 0)
 +			return ret;
 +	} else {
 +		INIT_DELAYED_WORK(&rtd->delayed_work,
 +				  codec2codec_close_delayed_work);
  	}
  
 -	/* create the pcm */
 -	ret = soc_new_pcm(rtd, num);
 -	if (ret < 0) {
 -		dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 -			dai_link->stream_name, ret);
 -		return ret;
 -	}
 -	ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
 -	if (ret < 0)
 -		return ret;
 -	ret = soc_link_dai_pcm_new(rtd->codec_dais,
 -				   rtd->num_codecs, rtd);
 -	return ret;
 +	return 0;
  }
  
 -static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 +static int soc_bind_aux_dev(struct snd_soc_card *card,
 +			    struct snd_soc_aux_dev *aux_dev)
  {
 -	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
  	struct snd_soc_component *component;
++<<<<<<< HEAD
 +	const char *name;
 +	struct device_node *codec_of_node;
 +
 +	if (aux_dev->codec_of_node || aux_dev->codec_name) {
 +		/* codecs, usually analog devices */
 +		name = aux_dev->codec_name;
 +		codec_of_node = aux_dev->codec_of_node;
 +		component = soc_find_component(codec_of_node, name);
 +		if (!component) {
 +			if (codec_of_node)
 +				name = of_node_full_name(codec_of_node);
 +			goto err_defer;
 +		}
 +	} else if (aux_dev->name) {
 +		/* generic components */
 +		name = aux_dev->name;
 +		component = soc_find_component(NULL, name);
 +		if (!component)
 +			goto err_defer;
 +	} else {
 +		dev_err(card->dev, "ASoC: Invalid auxiliary device\n");
 +		return -EINVAL;
 +	}
++=======
+ 
+ 	/* remove me */
+ 	if (aux_dev->codec_name)
+ 		aux_dev->dlc.name = aux_dev->codec_name;
+ 	if (aux_dev->codec_of_node)
+ 		aux_dev->dlc.of_node = aux_dev->codec_of_node;
+ 
+ 	/* codecs, usually analog devices */
+ 	component = soc_find_component(&aux_dev->dlc);
+ 	if (!component)
+ 		return -EPROBE_DEFER;
++>>>>>>> 3dc29b8b2062 (ASoC: soc-core: support snd_soc_dai_link_component for aux_dev)
  
  	component->init = aux_dev->init;
 +	/* see for_each_card_auxs */
  	list_add(&component->card_aux_list, &card->aux_comp_list);
  
  	return 0;
++<<<<<<< HEAD
 +
 +err_defer:
 +	dev_err(card->dev, "ASoC: %s not registered\n", name);
 +	return -EPROBE_DEFER;
++=======
++>>>>>>> 3dc29b8b2062 (ASoC: soc-core: support snd_soc_dai_link_component for aux_dev)
  }
  
  static int soc_probe_aux_devices(struct snd_soc_card *card)
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 8387b011d9c9..aec1df4c24fe 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -1127,6 +1127,7 @@ struct snd_soc_dai_link {
 #define COMP_CPU(_dai)			{ .dai_name = _dai, }
 #define COMP_CODEC(_name, _dai)		{ .name = _name, .dai_name = _dai, }
 #define COMP_PLATFORM(_name)		{ .name = _name }
+#define COMP_AUX(_name)			{ .name = _name }
 #define COMP_DUMMY()			{ .name = "snd-soc-dummy", .dai_name = "snd-soc-dummy-dai", }
 
 extern struct snd_soc_dai_link_component null_dailink_component[0];
@@ -1157,6 +1158,12 @@ struct snd_soc_aux_dev {
 	const char *codec_name;
 	struct device_node *codec_of_node;
 
+	/*
+	 * name, codec_name, codec_of_node will be replaced
+	 * into dlc. don't use both in the same time
+	 */
+	struct snd_soc_dai_link_component dlc;
+
 	/* codec/machine specific init - e.g. add machine controls */
 	int (*init)(struct snd_soc_component *component);
 };
* Unmerged path sound/soc/soc-core.c
