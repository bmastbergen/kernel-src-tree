driver core: allow stopping deferred probe after init

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Rob Herring <robh@kernel.org>
commit 25b4e70dcce92168eab4d8113817bb4dd130ebd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/25b4e70d.failed

Deferred probe will currently wait forever on dependent devices to probe,
but sometimes a driver will never exist. It's also not always critical for
a driver to exist. Platforms can rely on default configuration from the
bootloader or reset defaults for things such as pinctrl and power domains.
This is often the case with initial platform support until various drivers
get enabled. There's at least 2 scenarios where deferred probe can render
a platform broken. Both involve using a DT which has more devices and
dependencies than the kernel supports. The 1st case is a driver may be
disabled in the kernel config. The 2nd case is the kernel version may
simply not have the dependent driver. This can happen if using a newer DT
(provided by firmware perhaps) with a stable kernel version. Deferred
probe issues can be difficult to debug especially if the console has
dependencies or userspace fails to boot to a shell.

There are also cases like IOMMUs where only built-in drivers are
supported, so deferring probe after initcalls is not needed. The IOMMU
subsystem implemented its own mechanism to handle this using OF_DECLARE
linker sections.

This commit adds makes ending deferred probe conditional on initcalls
being completed or a debug timeout. Subsystems or drivers may opt-in by
calling driver_deferred_probe_check_init_done() instead of
unconditionally returning -EPROBE_DEFER. They may use additional
information from DT or kernel's config to decide whether to continue to
defer probe or not.

The timeout mechanism is intended for debug purposes and WARNs loudly.
The remaining deferred probe pending list will also be dumped after the
timeout. Not that this timeout won't work for the console which needs
to be enabled before userspace starts. However, if the console's
dependencies are resolved, then the kernel log will be printed (as
opposed to no output).

	Cc: Alexander Graf <agraf@suse.de>
	Signed-off-by: Rob Herring <robh@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 25b4e70dcce92168eab4d8113817bb4dd130ebd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
diff --cc drivers/base/dd.c
index e542ffec3960,fb62f1be40d3..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -53,6 -54,7 +53,10 @@@ static DEFINE_MUTEX(deferred_probe_mute
  static LIST_HEAD(deferred_probe_pending_list);
  static LIST_HEAD(deferred_probe_active_list);
  static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
++<<<<<<< HEAD
++=======
+ static struct dentry *deferred_devices;
++>>>>>>> 25b4e70dcce9 (driver core: allow stopping deferred probe after init)
  static bool initcalls_done;
  
  /*
@@@ -224,6 -202,69 +228,72 @@@ void device_unblock_probing(void
  	driver_deferred_probe_trigger();
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * deferred_devs_show() - Show the devices in the deferred probe pending list.
+  */
+ static int deferred_devs_show(struct seq_file *s, void *data)
+ {
+ 	struct device_private *curr;
+ 
+ 	mutex_lock(&deferred_probe_mutex);
+ 
+ 	list_for_each_entry(curr, &deferred_probe_pending_list, deferred_probe)
+ 		seq_printf(s, "%s\n", dev_name(curr->device));
+ 
+ 	mutex_unlock(&deferred_probe_mutex);
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(deferred_devs);
+ 
+ static int deferred_probe_timeout = -1;
+ static int __init deferred_probe_timeout_setup(char *str)
+ {
+ 	deferred_probe_timeout = simple_strtol(str, NULL, 10);
+ 	return 1;
+ }
+ __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
+ 
+ /**
+  * driver_deferred_probe_check_state() - Check deferred probe state
+  * @dev: device to check
+  *
+  * Returns -ENODEV if init is done and all built-in drivers have had a chance
+  * to probe (i.e. initcalls are done), -ETIMEDOUT if deferred probe debug
+  * timeout has expired, or -EPROBE_DEFER if none of those conditions are met.
+  *
+  * Drivers or subsystems can opt-in to calling this function instead of directly
+  * returning -EPROBE_DEFER.
+  */
+ int driver_deferred_probe_check_state(struct device *dev)
+ {
+ 	if (initcalls_done) {
+ 		if (!deferred_probe_timeout) {
+ 			dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+ 			return -ETIMEDOUT;
+ 		}
+ 		dev_warn(dev, "ignoring dependency for device, assuming no driver");
+ 		return -ENODEV;
+ 	}
+ 	return -EPROBE_DEFER;
+ }
+ 
+ static void deferred_probe_timeout_work_func(struct work_struct *work)
+ {
+ 	struct device_private *private, *p;
+ 
+ 	deferred_probe_timeout = 0;
+ 	driver_deferred_probe_trigger();
+ 	flush_work(&deferred_probe_work);
+ 
+ 	list_for_each_entry_safe(private, p, &deferred_probe_pending_list, deferred_probe)
+ 		dev_info(private->device, "deferred probe pending");
+ }
+ static DECLARE_DELAYED_WORK(deferred_probe_timeout_work, deferred_probe_timeout_work_func);
+ 
++>>>>>>> 25b4e70dcce9 (driver core: allow stopping deferred probe after init)
  /**
   * deferred_probe_initcall() - Enable probing of deferred devices
   *
@@@ -238,6 -282,18 +308,21 @@@ static int deferred_probe_initcall(void
  	/* Sort as many dependencies as possible before exiting initcalls */
  	flush_work(&deferred_probe_work);
  	initcalls_done = true;
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Trigger deferred probe again, this time we won't defer anything
+ 	 * that is optional
+ 	 */
+ 	driver_deferred_probe_trigger();
+ 	flush_work(&deferred_probe_work);
+ 
+ 	if (deferred_probe_timeout > 0) {
+ 		schedule_delayed_work(&deferred_probe_timeout_work,
+ 			deferred_probe_timeout * HZ);
+ 	}
++>>>>>>> 25b4e70dcce9 (driver core: allow stopping deferred probe after init)
  	return 0;
  }
  late_initcall(deferred_probe_initcall);
diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 96ca2e504d87..aa1b6175521c 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -819,6 +819,15 @@
 			Defaults to the default architecture's huge page size
 			if not specified.
 
+	deferred_probe_timeout=
+			[KNL] Debugging option to set a timeout in seconds for
+			deferred probe to give up waiting on dependencies to
+			probe. Only specific dependencies (subsystems or
+			drivers) that have opted in will be ignored. A timeout of 0
+			will timeout at the end of initcalls. This option will also
+			dump out devices still on the deferred probe list after
+			retrying.
+
 	dhash_entries=	[KNL]
 			Set number of hash buckets for dentry cache.
 
* Unmerged path drivers/base/dd.c
diff --git a/include/linux/device.h b/include/linux/device.h
index 6eab71e749c7..e60a520fa7bf 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -353,6 +353,8 @@ struct device *driver_find_device(struct device_driver *drv,
 				  struct device *start, void *data,
 				  int (*match)(struct device *dev, void *data));
 
+int driver_deferred_probe_check_state(struct device *dev);
+
 /**
  * struct subsys_interface - interfaces to device functions
  * @name:       name of the device function
