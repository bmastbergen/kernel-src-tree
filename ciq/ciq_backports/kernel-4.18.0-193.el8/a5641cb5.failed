net/mlx5: E-Switch, Add match on vport metadata for rule in slow path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Add match on vport metadata for rule in slow path (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 97.01%
commit-author Jianbo Liu <jianbol@mellanox.com>
commit a5641cb524cd023c5fafbe41891c8ec510b65f3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a5641cb5.failed

In slow path, packet that not matched by any offloaded rule is
forwarded to eswitch vport manager for further processing.
Add matching on metadata for peer miss rules in FDB, and rules which
forward packet to correct representor in esw manager NIC_RX table.

	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a5641cb524cd023c5fafbe41891c8ec510b65f3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,94b55d0bdda9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -543,26 -574,90 +543,94 @@@ void mlx5_eswitch_del_send_to_vport_rul
  	mlx5_del_flow_rules(rule);
  }
  
++<<<<<<< HEAD
 +static void peer_miss_rules_setup(struct mlx5_core_dev *peer_dev,
++=======
+ static int mlx5_eswitch_enable_passing_vport_metadata(struct mlx5_eswitch *esw)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(query_esw_vport_context_out)] = {};
+ 	u32 in[MLX5_ST_SZ_DW(modify_esw_vport_context_in)] = {};
+ 	u8 fdb_to_vport_reg_c_id;
+ 	int err;
+ 
+ 	err = mlx5_eswitch_query_esw_vport_context(esw, esw->manager_vport,
+ 						   out, sizeof(out));
+ 	if (err)
+ 		return err;
+ 
+ 	fdb_to_vport_reg_c_id = MLX5_GET(query_esw_vport_context_out, out,
+ 					 esw_vport_context.fdb_to_vport_reg_c_id);
+ 
+ 	fdb_to_vport_reg_c_id |= MLX5_FDB_TO_VPORT_REG_C_0;
+ 	MLX5_SET(modify_esw_vport_context_in, in,
+ 		 esw_vport_context.fdb_to_vport_reg_c_id, fdb_to_vport_reg_c_id);
+ 
+ 	MLX5_SET(modify_esw_vport_context_in, in,
+ 		 field_select.fdb_to_vport_reg_c_id, 1);
+ 
+ 	return mlx5_eswitch_modify_esw_vport_context(esw, esw->manager_vport,
+ 						     in, sizeof(in));
+ }
+ 
+ static int mlx5_eswitch_disable_passing_vport_metadata(struct mlx5_eswitch *esw)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(query_esw_vport_context_out)] = {};
+ 	u32 in[MLX5_ST_SZ_DW(modify_esw_vport_context_in)] = {};
+ 	u8 fdb_to_vport_reg_c_id;
+ 	int err;
+ 
+ 	err = mlx5_eswitch_query_esw_vport_context(esw, esw->manager_vport,
+ 						   out, sizeof(out));
+ 	if (err)
+ 		return err;
+ 
+ 	fdb_to_vport_reg_c_id = MLX5_GET(query_esw_vport_context_out, out,
+ 					 esw_vport_context.fdb_to_vport_reg_c_id);
+ 
+ 	fdb_to_vport_reg_c_id &= ~MLX5_FDB_TO_VPORT_REG_C_0;
+ 
+ 	MLX5_SET(modify_esw_vport_context_in, in,
+ 		 esw_vport_context.fdb_to_vport_reg_c_id, fdb_to_vport_reg_c_id);
+ 
+ 	MLX5_SET(modify_esw_vport_context_in, in,
+ 		 field_select.fdb_to_vport_reg_c_id, 1);
+ 
+ 	return mlx5_eswitch_modify_esw_vport_context(esw, esw->manager_vport,
+ 						     in, sizeof(in));
+ }
+ 
+ static void peer_miss_rules_setup(struct mlx5_eswitch *esw,
+ 				  struct mlx5_core_dev *peer_dev,
++>>>>>>> a5641cb524cd (net/mlx5: E-Switch, Add match on vport metadata for rule in slow path)
  				  struct mlx5_flow_spec *spec,
  				  struct mlx5_flow_destination *dest)
  {
- 	void *misc = MLX5_ADDR_OF(fte_match_param, spec->match_value,
- 				  misc_parameters);
+ 	void *misc;
  
- 	MLX5_SET(fte_match_set_misc, misc, source_eswitch_owner_vhca_id,
- 		 MLX5_CAP_GEN(peer_dev, vhca_id));
+ 	if (mlx5_eswitch_vport_match_metadata_enabled(esw)) {
+ 		misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
+ 				    misc_parameters_2);
+ 		MLX5_SET_TO_ONES(fte_match_set_misc2, misc, metadata_reg_c_0);
  
- 	spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+ 		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;
+ 	} else {
+ 		misc = MLX5_ADDR_OF(fte_match_param, spec->match_value,
+ 				    misc_parameters);
  
- 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
- 			    misc_parameters);
- 	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
- 	MLX5_SET_TO_ONES(fte_match_set_misc, misc,
- 			 source_eswitch_owner_vhca_id);
+ 		MLX5_SET(fte_match_set_misc, misc, source_eswitch_owner_vhca_id,
+ 			 MLX5_CAP_GEN(peer_dev, vhca_id));
+ 
+ 		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+ 
+ 		misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
+ 				    misc_parameters);
+ 		MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
+ 		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
+ 				 source_eswitch_owner_vhca_id);
+ 	}
  
  	dest->type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 -	dest->vport.num = peer_dev->priv.eswitch->manager_vport;
 +	dest->vport.num = 0;
  	dest->vport.vhca_id = MLX5_CAP_GEN(peer_dev, vhca_id);
  	dest->vport.flags |= MLX5_FLOW_DEST_VPORT_VHCA_ID;
  }
@@@ -596,8 -711,35 +684,40 @@@ static int esw_add_fdb_peer_miss_rules(
  	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value,
  			    misc_parameters);
  
++<<<<<<< HEAD
 +	for (i = 1; i < nvports; i++) {
 +		MLX5_SET(fte_match_set_misc, misc, source_port, i);
++=======
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		esw_set_peer_miss_rule_source_port(esw, peer_dev->priv.eswitch,
+ 						   spec, MLX5_VPORT_PF);
+ 
+ 		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 					   spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow)) {
+ 			err = PTR_ERR(flow);
+ 			goto add_pf_flow_err;
+ 		}
+ 		flows[MLX5_VPORT_PF] = flow;
+ 	}
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		MLX5_SET(fte_match_set_misc, misc, source_port, MLX5_VPORT_ECPF);
+ 		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 					   spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow)) {
+ 			err = PTR_ERR(flow);
+ 			goto add_ecpf_flow_err;
+ 		}
+ 		flows[mlx5_eswitch_ecpf_idx(esw)] = flow;
+ 	}
+ 
+ 	mlx5_esw_for_each_vf_vport_num(esw, i, mlx5_core_max_vfs(esw->dev)) {
+ 		esw_set_peer_miss_rule_source_port(esw,
+ 						   peer_dev->priv.eswitch,
+ 						   spec, i);
+ 
++>>>>>>> a5641cb524cd (net/mlx5: E-Switch, Add match on vport metadata for rule in slow path)
  		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
  					   spec, &flow_act, &dest, 1);
  		if (IS_ERR(flow)) {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
