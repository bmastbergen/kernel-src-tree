PM / Domains: Search for the CPU device outside the genpd lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit b24e196586fecafed1c3cff9b2f87c1a64138ade
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b24e1965.failed

While attaching/detaching a device to a PM domain (genpd) with
GENPD_FLAG_CPU_DOMAIN set, genpd iterates the cpu_possible_mask to
check whether or not the device corresponds to a CPU. This iteration
is done while holding the genpd's lock, which is unnecessary.

Avoid the locking by restructuring the corresponding code a bit.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b24e196586fecafed1c3cff9b2f87c1a64138ade)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/domain.c
diff --cc drivers/base/power/domain.c
index ae411ec1ee12,da1c99178943..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -1452,11 -1450,59 +1452,64 @@@ static void genpd_free_dev_data(struct 
  	dev_pm_put_subsys_data(dev);
  }
  
++<<<<<<< HEAD
 +static int genpd_add_device(struct generic_pm_domain *genpd, struct device *dev,
 +			    struct gpd_timing_data *td)
++=======
+ static void genpd_update_cpumask(struct generic_pm_domain *genpd,
+ 				 int cpu, bool set, unsigned int depth)
+ {
+ 	struct gpd_link *link;
+ 
+ 	if (!genpd_is_cpu_domain(genpd))
+ 		return;
+ 
+ 	list_for_each_entry(link, &genpd->slave_links, slave_node) {
+ 		struct generic_pm_domain *master = link->master;
+ 
+ 		genpd_lock_nested(master, depth + 1);
+ 		genpd_update_cpumask(master, cpu, set, depth + 1);
+ 		genpd_unlock(master);
+ 	}
+ 
+ 	if (set)
+ 		cpumask_set_cpu(cpu, genpd->cpus);
+ 	else
+ 		cpumask_clear_cpu(cpu, genpd->cpus);
+ }
+ 
+ static void genpd_set_cpumask(struct generic_pm_domain *genpd, int cpu)
+ {
+ 	if (cpu >= 0)
+ 		genpd_update_cpumask(genpd, cpu, true, 0);
+ }
+ 
+ static void genpd_clear_cpumask(struct generic_pm_domain *genpd, int cpu)
+ {
+ 	if (cpu >= 0)
+ 		genpd_update_cpumask(genpd, cpu, false, 0);
+ }
+ 
+ static int genpd_get_cpu(struct generic_pm_domain *genpd, struct device *dev)
+ {
+ 	int cpu;
+ 
+ 	if (!genpd_is_cpu_domain(genpd))
+ 		return -1;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		if (get_cpu_device(cpu) == dev)
+ 			return cpu;
+ 	}
+ 
+ 	return -1;
+ }
+ 
+ static int genpd_add_device(struct generic_pm_domain *genpd, struct device *dev)
++>>>>>>> b24e196586fe (PM / Domains: Search for the CPU device outside the genpd lock)
  {
  	struct generic_pm_domain_data *gpd_data;
- 	int ret;
+ 	int ret, cpu;
  
  	dev_dbg(dev, "%s()\n", __func__);
  
@@@ -1473,6 -1521,7 +1528,10 @@@
  
  	genpd_lock(genpd);
  
++<<<<<<< HEAD
++=======
+ 	genpd_set_cpumask(genpd, cpu);
++>>>>>>> b24e196586fe (PM / Domains: Search for the CPU device outside the genpd lock)
  	dev_pm_domain_set(dev, &genpd->domain);
  
  	genpd->device_count++;
@@@ -1530,6 -1580,7 +1590,10 @@@ static int genpd_remove_device(struct g
  	genpd->device_count--;
  	genpd->max_off_time_changed = true;
  
++<<<<<<< HEAD
++=======
+ 	genpd_clear_cpumask(genpd, cpu);
++>>>>>>> b24e196586fe (PM / Domains: Search for the CPU device outside the genpd lock)
  	dev_pm_domain_set(dev, NULL);
  
  	list_del_init(&pdd->list_node);
* Unmerged path drivers/base/power/domain.c
