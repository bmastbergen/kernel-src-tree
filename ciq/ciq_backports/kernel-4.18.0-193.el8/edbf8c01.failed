bpf: add skc_lookup_tcp helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit edbf8c01de5a104a71ed6df2bf6421ceb2836a8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/edbf8c01.failed

Allow looking up a sock_common. This gives eBPF programs
access to timewait and request sockets.

	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit edbf8c01de5a104a71ed6df2bf6421ceb2836a8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/filter.c
diff --cc net/core/filter.c
index 078fd98b7523,b6d83ba97621..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -5208,25 -5192,27 +5208,42 @@@ __bpf_skc_lookup(struct sk_buff *skb, s
  		put_net(net);
  	}
  
++<<<<<<< HEAD
 +	if (sk) {
 +		sk = sk_to_full_sk(sk);
 +		/* RHEL note: when backporting edbf8c01de5a1, do not forget
 +		 * the other part of the fix below (commit f7355a6c0497,
 +		 * which was only partially backported).
 +		 */
 +		if (!sk_fullsock(sk)) {
 +			if (!sock_flag(sk, SOCK_RCU_FREE))
 +				sock_gen_put(sk);
 +			return (unsigned long) NULL;
 +		}
 +	}
++=======
++>>>>>>> edbf8c01de5a (bpf: add skc_lookup_tcp helper)
  out:
- 	return (unsigned long) sk;
+ 	return sk;
  }
  
- static unsigned long
- bpf_sk_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
- 	      u8 proto, u64 netns_id, u64 flags)
+ static struct sock *
+ __bpf_sk_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
+ 		struct net *caller_net, u32 ifindex, u8 proto, u64 netns_id,
+ 		u64 flags)
+ {
+ 	struct sock *sk = __bpf_skc_lookup(skb, tuple, len, caller_net,
+ 					   ifindex, proto, netns_id, flags);
+ 
+ 	if (sk)
+ 		sk = sk_to_full_sk(sk);
+ 
+ 	return sk;
+ }
+ 
+ static struct sock *
+ bpf_skc_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
+ 	       u8 proto, u64 netns_id, u64 flags)
  {
  	struct net *caller_net;
  	int ifindex;
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index 86e8127cdce4..a9b937423ec7 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -2438,6 +2438,23 @@ union bpf_attr {
  *	Return
  *		A **struct bpf_sock** pointer on success, or NULL in
  *		case of failure.
+ *
+ * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+ *	Description
+ *		Look for TCP socket matching *tuple*, optionally in a child
+ *		network namespace *netns*. The return value must be checked,
+ *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+ *
+ *		This function is identical to bpf_sk_lookup_tcp, except that it
+ *		also returns timewait or request sockets. Use bpf_sk_fullsock
+ *		or bpf_tcp_socket to access the full structure.
+ *
+ *		This helper is available only if the kernel was compiled with
+ *		**CONFIG_NET** configuration option.
+ *	Return
+ *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+ *		For sockets with reuseport option, the **struct bpf_sock**
+ *		result is from **reuse->socks**\ [] using the hash of the tuple.
  */
 #define __BPF_FUNC_MAPPER(FN)		\
 	FN(unspec),			\
@@ -2538,7 +2555,8 @@ union bpf_attr {
 	FN(sk_fullsock),		\
 	FN(tcp_sock),			\
 	FN(skb_ecn_set_ce),		\
-	FN(get_listener_sock),
+	FN(get_listener_sock),		\
+	FN(skc_lookup_tcp),
 
 /* integer value in 'imm' field of BPF_CALL instruction selects which helper
  * function eBPF program intends to call
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index a7b644b5f803..e2fd262b22bf 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -369,7 +369,8 @@ static bool is_release_function(enum bpf_func_id func_id)
 static bool is_acquire_function(enum bpf_func_id func_id)
 {
 	return func_id == BPF_FUNC_sk_lookup_tcp ||
-		func_id == BPF_FUNC_sk_lookup_udp;
+		func_id == BPF_FUNC_sk_lookup_udp ||
+		func_id == BPF_FUNC_skc_lookup_tcp;
 }
 
 static bool is_ptr_cast_function(enum bpf_func_id func_id)
* Unmerged path net/core/filter.c
