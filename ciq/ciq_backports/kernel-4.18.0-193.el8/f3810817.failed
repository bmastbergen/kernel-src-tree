perf diff: Link same basic blocks among different data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jin Yao <yao.jin@linux.intel.com>
commit f3810817b20645ffae809feb30e9fe260fbd6c4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f3810817.failed

The target is to compare the performance difference (cycles diff) for
the same basic blocks in different data files.

The same basic block means same function, same start address and same
end address. This patch finds the same basic blocks from different data
files and link them together and resort by the cycles diff.

 v3:
 ---
 The block stuffs are maintained by new structure 'block_hist',
 so this patch is update accordingly.

 v2:
 ---
 Since now the basic block hists is changed to per symbol,
 the patch only links the basic block hists for the same
 symbol in different data files.

	Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
	Reviewed-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jin Yao <yao.jin@intel.com>
	Cc: Kan Liang <kan.liang@linux.intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1561713784-30533-6-git-send-email-yao.jin@linux.intel.com
[ sym->name is an array, not a pointer, so no need to check it for NULL, fixes de build in some distros ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit f3810817b20645ffae809feb30e9fe260fbd6c4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-diff.c
diff --cc tools/perf/builtin-diff.c
index a7e04202955c,fafb7b3f58fb..000000000000
--- a/tools/perf/builtin-diff.c
+++ b/tools/perf/builtin-diff.c
@@@ -475,6 -520,203 +475,206 @@@ static void hists__baseline_only(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int64_t block_cmp(struct perf_hpp_fmt *fmt __maybe_unused,
+ 			 struct hist_entry *left, struct hist_entry *right)
+ {
+ 	struct block_info *bi_l = left->block_info;
+ 	struct block_info *bi_r = right->block_info;
+ 	int cmp;
+ 
+ 	if (!bi_l->sym || !bi_r->sym) {
+ 		if (!bi_l->sym && !bi_r->sym)
+ 			return 0;
+ 		else if (!bi_l->sym)
+ 			return -1;
+ 		else
+ 			return 1;
+ 	}
+ 
+ 	if (bi_l->sym == bi_r->sym) {
+ 		if (bi_l->start == bi_r->start) {
+ 			if (bi_l->end == bi_r->end)
+ 				return 0;
+ 			else
+ 				return (int64_t)(bi_r->end - bi_l->end);
+ 		} else
+ 			return (int64_t)(bi_r->start - bi_l->start);
+ 	} else {
+ 		cmp = strcmp(bi_l->sym->name, bi_r->sym->name);
+ 		return cmp;
+ 	}
+ 
+ 	if (bi_l->sym->start != bi_r->sym->start)
+ 		return (int64_t)(bi_r->sym->start - bi_l->sym->start);
+ 
+ 	return (int64_t)(bi_r->sym->end - bi_l->sym->end);
+ }
+ 
+ static int64_t block_cycles_diff_cmp(struct hist_entry *left,
+ 				     struct hist_entry *right)
+ {
+ 	bool pairs_left  = hist_entry__has_pairs(left);
+ 	bool pairs_right = hist_entry__has_pairs(right);
+ 	s64 l, r;
+ 
+ 	if (!pairs_left && !pairs_right)
+ 		return 0;
+ 
+ 	l = labs(left->diff.cycles);
+ 	r = labs(right->diff.cycles);
+ 	return r - l;
+ }
+ 
+ static int64_t block_sort(struct perf_hpp_fmt *fmt __maybe_unused,
+ 			  struct hist_entry *left, struct hist_entry *right)
+ {
+ 	return block_cycles_diff_cmp(right, left);
+ }
+ 
+ static void init_block_hist(struct block_hist *bh)
+ {
+ 	__hists__init(&bh->block_hists, &bh->block_list);
+ 	perf_hpp_list__init(&bh->block_list);
+ 
+ 	INIT_LIST_HEAD(&bh->block_fmt.list);
+ 	INIT_LIST_HEAD(&bh->block_fmt.sort_list);
+ 	bh->block_fmt.cmp = block_cmp;
+ 	bh->block_fmt.sort = block_sort;
+ 	perf_hpp_list__register_sort_field(&bh->block_list,
+ 					   &bh->block_fmt);
+ 	bh->valid = true;
+ }
+ 
+ static void init_block_info(struct block_info *bi, struct symbol *sym,
+ 			    struct cyc_hist *ch, int offset)
+ {
+ 	bi->sym = sym;
+ 	bi->start = ch->start;
+ 	bi->end = offset;
+ 	bi->cycles = ch->cycles;
+ 	bi->cycles_aggr = ch->cycles_aggr;
+ 	bi->num = ch->num;
+ 	bi->num_aggr = ch->num_aggr;
+ }
+ 
+ static int process_block_per_sym(struct hist_entry *he)
+ {
+ 	struct annotation *notes;
+ 	struct cyc_hist *ch;
+ 	struct block_hist *bh;
+ 
+ 	if (!he->ms.map || !he->ms.sym)
+ 		return 0;
+ 
+ 	notes = symbol__annotation(he->ms.sym);
+ 	if (!notes || !notes->src || !notes->src->cycles_hist)
+ 		return 0;
+ 
+ 	bh = container_of(he, struct block_hist, he);
+ 	init_block_hist(bh);
+ 
+ 	ch = notes->src->cycles_hist;
+ 	for (unsigned int i = 0; i < symbol__size(he->ms.sym); i++) {
+ 		if (ch[i].num_aggr) {
+ 			struct block_info *bi;
+ 			struct hist_entry *he_block;
+ 
+ 			bi = block_info__new();
+ 			if (!bi)
+ 				return -1;
+ 
+ 			init_block_info(bi, he->ms.sym, &ch[i], i);
+ 			he_block = hists__add_entry_block(&bh->block_hists,
+ 							  &dummy_al, bi);
+ 			if (!he_block) {
+ 				block_info__put(bi);
+ 				return -1;
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int block_pair_cmp(struct hist_entry *a, struct hist_entry *b)
+ {
+ 	struct block_info *bi_a = a->block_info;
+ 	struct block_info *bi_b = b->block_info;
+ 	int cmp;
+ 
+ 	if (!bi_a->sym || !bi_b->sym)
+ 		return -1;
+ 
+ 	cmp = strcmp(bi_a->sym->name, bi_b->sym->name);
+ 
+ 	if ((!cmp) && (bi_a->start == bi_b->start) && (bi_a->end == bi_b->end))
+ 		return 0;
+ 
+ 	return -1;
+ }
+ 
+ static struct hist_entry *get_block_pair(struct hist_entry *he,
+ 					 struct hists *hists_pair)
+ {
+ 	struct rb_root_cached *root = hists_pair->entries_in;
+ 	struct rb_node *next = rb_first_cached(root);
+ 	int cmp;
+ 
+ 	while (next != NULL) {
+ 		struct hist_entry *he_pair = rb_entry(next, struct hist_entry,
+ 						      rb_node_in);
+ 
+ 		next = rb_next(&he_pair->rb_node_in);
+ 
+ 		cmp = block_pair_cmp(he_pair, he);
+ 		if (!cmp)
+ 			return he_pair;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void compute_cycles_diff(struct hist_entry *he,
+ 				struct hist_entry *pair)
+ {
+ 	pair->diff.computed = true;
+ 	if (pair->block_info->num && he->block_info->num) {
+ 		pair->diff.cycles =
+ 			pair->block_info->cycles_aggr / pair->block_info->num_aggr -
+ 			he->block_info->cycles_aggr / he->block_info->num_aggr;
+ 	}
+ }
+ 
+ static void block_hists_match(struct hists *hists_base,
+ 			      struct hists *hists_pair)
+ {
+ 	struct rb_root_cached *root = hists_base->entries_in;
+ 	struct rb_node *next = rb_first_cached(root);
+ 
+ 	while (next != NULL) {
+ 		struct hist_entry *he = rb_entry(next, struct hist_entry,
+ 						 rb_node_in);
+ 		struct hist_entry *pair = get_block_pair(he, hists_pair);
+ 
+ 		next = rb_next(&he->rb_node_in);
+ 
+ 		if (pair) {
+ 			hist_entry__add_pair(pair, he);
+ 			compute_cycles_diff(he, pair);
+ 		}
+ 	}
+ }
+ 
+ static int filter_cb(struct hist_entry *he, void *arg __maybe_unused)
+ {
+ 	/* Skip the calculation of column length in output_resort */
+ 	he->filtered = true;
+ 	return 0;
+ }
+ 
++>>>>>>> f3810817b206 (perf diff: Link same basic blocks among different data)
  static void hists__precompute(struct hists *hists)
  {
  	struct rb_root_cached *root;
@@@ -510,6 -756,19 +711,22 @@@
  			case COMPUTE_WEIGHTED_DIFF:
  				compute_wdiff(he, pair);
  				break;
++<<<<<<< HEAD
++=======
+ 			case COMPUTE_CYCLES:
+ 				process_block_per_sym(pair);
+ 				bh = container_of(he, struct block_hist, he);
+ 				pair_bh = container_of(pair, struct block_hist,
+ 						       he);
+ 
+ 				if (bh->valid && pair_bh->valid) {
+ 					block_hists_match(&bh->block_hists,
+ 							  &pair_bh->block_hists);
+ 					hists__output_resort_cb(&pair_bh->block_hists,
+ 								NULL, filter_cb);
+ 				}
+ 				break;
++>>>>>>> f3810817b206 (perf diff: Link same basic blocks among different data)
  			default:
  				BUG_ON(1);
  			}
* Unmerged path tools/perf/builtin-diff.c
