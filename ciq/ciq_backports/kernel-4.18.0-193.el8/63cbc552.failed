net/mlx5: Handle SW reset of FW in error flow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Handle SW reset of FW in error flow (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 95.35%
commit-author Feras Daoud <ferasda@mellanox.com>
commit 63cbc552eebf08818af2025aef4589a48ef849c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/63cbc552.failed

New mlx5 adapters allow the driver to reset the FW in the event of an
error, this action called "SW Reset". When an SW reset is issued on any
PF all PFs enter reset state which is a recoverable condition. The
existing recovery flow was designed to allow the recovery of a VF after
a PF driver reload. This patch adds the sw reset to the NIC states
as a preparation for sw reset handling.

When a software reset is issued the following occurs:
1. The NIC interface mode is set to 7 while the reset is in progress.
2. Once the reset completes the NIC interface mode is set to 1.

	Signed-off-by: Feras Daoud <ferasda@mellanox.com>
	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
	Reviewed-by: Alex Vesker <valex@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 63cbc552eebf08818af2025aef4589a48ef849c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	include/linux/mlx5/driver.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index bff749be0582,737e6d550775..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -137,34 -151,10 +151,36 @@@ static void mlx5_handle_bad_state(struc
  	mlx5_disable_device(dev);
  }
  
++<<<<<<< HEAD
 +static void health_recover(struct work_struct *work)
 +{
 +	struct mlx5_core_health *health;
 +	struct delayed_work *dwork;
 +	struct mlx5_core_dev *dev;
 +	struct mlx5_priv *priv;
 +	u8 nic_state;
 +
 +	dwork = container_of(work, struct delayed_work, work);
 +	health = container_of(dwork, struct mlx5_core_health, recover_work);
 +	priv = container_of(health, struct mlx5_priv, health);
 +	dev = container_of(priv, struct mlx5_core_dev, priv);
 +
 +	nic_state = mlx5_get_nic_state(dev);
 +	if (nic_state == MLX5_NIC_IFC_INVALID) {
 +		dev_err(&dev->pdev->dev, "health recovery flow aborted since the nic state is invalid\n");
 +		return;
 +	}
 +
 +	dev_err(&dev->pdev->dev, "starting health recovery flow\n");
 +	mlx5_recover_device(dev);
 +}
 +
++=======
++>>>>>>> 63cbc552eebf (net/mlx5: Handle SW reset of FW in error flow)
  /* How much time to wait until health resetting the driver (in msecs) */
- #define MLX5_RECOVERY_DELAY_MSECS 60000
+ #define MLX5_RECOVERY_WAIT_MSECS 60000
  static void health_care(struct work_struct *work)
  {
- 	unsigned long recover_delay = msecs_to_jiffies(MLX5_RECOVERY_DELAY_MSECS);
  	struct mlx5_core_health *health;
  	struct mlx5_core_dev *dev;
  	struct mlx5_priv *priv;
@@@ -176,13 -166,18 +192,28 @@@
  	mlx5_core_warn(dev, "handling bad device here\n");
  	mlx5_handle_bad_state(dev);
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&health->wq_lock, flags);
 +	if (!test_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags))
 +		schedule_delayed_work(&health->recover_work, recover_delay);
 +	else
 +		dev_err(&dev->pdev->dev,
 +			"new health works are not permitted at this stage\n");
 +	spin_unlock_irqrestore(&health->wq_lock, flags);
++=======
+ 	end = jiffies + msecs_to_jiffies(MLX5_RECOVERY_WAIT_MSECS);
+ 	while (sensor_pci_not_working(dev)) {
+ 		if (time_after(jiffies, end)) {
+ 			mlx5_core_err(dev,
+ 				      "health recovery flow aborted, PCI reads still not working\n");
+ 			return;
+ 		}
+ 		msleep(100);
+ 	}
+ 
+ 	mlx5_core_err(dev, "starting health recovery flow\n");
+ 	mlx5_recover_device(dev);
++>>>>>>> 63cbc552eebf (net/mlx5: Handle SW reset of FW in error flow)
  }
  
  static const char *hsynd_str(u8 synd)
@@@ -340,16 -339,11 +372,23 @@@ void mlx5_drain_health_wq(struct mlx5_c
  	cancel_work_sync(&health->work);
  }
  
++<<<<<<< HEAD
 +void mlx5_drain_health_recovery(struct mlx5_core_dev *dev)
 +{
 +	struct mlx5_core_health *health = &dev->priv.health;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&health->wq_lock, flags);
 +	set_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags);
 +	spin_unlock_irqrestore(&health->wq_lock, flags);
 +	cancel_delayed_work_sync(&dev->priv.health.recover_work);
++=======
+ void mlx5_health_flush(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_core_health *health = &dev->priv.health;
+ 
+ 	flush_workqueue(health->wq);
++>>>>>>> 63cbc552eebf (net/mlx5: Handle SW reset of FW in error flow)
  }
  
  void mlx5_health_cleanup(struct mlx5_core_dev *dev)
diff --cc include/linux/mlx5/driver.h
index 655e39273378,cc7fd8e62844..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -436,6 -435,8 +436,11 @@@ struct mlx5_core_health 
  	u32				prev;
  	int				miss_counter;
  	bool				sick;
++<<<<<<< HEAD
++=======
+ 	u32				fatal_error;
+ 	u32				crdump_size;
++>>>>>>> 63cbc552eebf (net/mlx5: Handle SW reset of FW in error flow)
  	/* wq spinlock to synchronize draining */
  	spinlock_t			wq_lock;
  	struct workqueue_struct	       *wq;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
index 4382ef85488c..840ec945ccba 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
@@ -64,7 +64,7 @@ static int mlx5e_test_health_info(struct mlx5e_priv *priv)
 {
 	struct mlx5_core_health *health = &priv->mdev->priv.health;
 
-	return health->sick ? 1 : 0;
+	return health->fatal_error ? 1 : 0;
 }
 
 static int mlx5e_test_link_state(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index ea5e5990b832..e743297d0dc0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -1208,7 +1208,7 @@ static int mlx5_unload_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,
 	int err = 0;
 
 	if (cleanup)
-		mlx5_drain_health_recovery(dev);
+		mlx5_drain_health_wq(dev);
 
 	mutex_lock(&dev->intf_state_mutex);
 	if (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 8213c994e205..523874495352 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -208,7 +208,7 @@ enum {
 	MLX5_NIC_IFC_FULL		= 0,
 	MLX5_NIC_IFC_DISABLED		= 1,
 	MLX5_NIC_IFC_NO_DRAM_NIC	= 2,
-	MLX5_NIC_IFC_INVALID		= 3
+	MLX5_NIC_IFC_SW_RESET		= 7
 };
 
 u8 mlx5_get_nic_state(struct mlx5_core_dev *dev);
* Unmerged path include/linux/mlx5/driver.h
