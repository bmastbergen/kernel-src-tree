perf augmented_raw_syscalls: Move the probe_read_str to a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 0c95a7ff76fb1c5bb614e6ee438fce06d1b957c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0c95a7ff.failed

One more step into copying multiple filenames to support syscalls like
rename*.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Luis Cláudio Gonçalves <lclaudio@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-xdqtjexdyp81oomm1rkzeifl@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 0c95a7ff76fb1c5bb614e6ee438fce06d1b957c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/examples/bpf/augmented_raw_syscalls.c
diff --cc tools/perf/examples/bpf/augmented_raw_syscalls.c
index b292e763f3c7,356513e81ec1..000000000000
--- a/tools/perf/examples/bpf/augmented_raw_syscalls.c
+++ b/tools/perf/examples/bpf/augmented_raw_syscalls.c
@@@ -131,7 -80,7 +147,11 @@@ SEC("raw_syscalls:sys_enter"
  int sys_enter(struct syscall_enter_args *args)
  {
  	struct augmented_args_filename *augmented_args;
++<<<<<<< HEAD
 +	unsigned int len = sizeof(*augmented_args);
++=======
+ 	unsigned int len, filename_len;
++>>>>>>> 0c95a7ff76fb (perf augmented_raw_syscalls: Move the probe_read_str to a separate function)
  	const void *filename_arg = NULL;
  	struct syscall *syscall;
  	int key = 0;
@@@ -189,98 -138,67 +209,145 @@@
  	 * 	 after the ctx memory access to prevent their down stream merging.
  	 */
  	/*
 -	 * For now copy just the first string arg, we need to improve the protocol
 -	 * and have more than one.
 +	 * This table of what args are strings will be provided by userspace,
 +	 * in the syscalls map, i.e. we will already have to do the lookup to
 +	 * see if this specific syscall is filtered, so we can as well get more
 +	 * info about what syscall args are strings or pointers, and how many
 +	 * bytes to copy, per arg, etc.
  	 *
 -	 * Using the unrolled loop is not working, only when we do it manually,
 -	 * check this out later...
 -
 -	u8 arg;
 -#pragma clang loop unroll(full)
 -	for (arg = 0; arg < 6; ++arg) {
 -		if (syscall->string_args_len[arg] != 0) {
 -			filename_len = syscall->string_args_len[arg];
 -			filename_arg = (const void *)args->args[arg];
 +	 * For now hard code it, till we have all the basic mechanisms in place
 +	 * to automate everything and make the kernel part be completely driven
 +	 * by information obtained in userspace for each kernel version and
 +	 * processor architecture, making the kernel part the same no matter what
 +	 * kernel version or processor architecture it runs on.
 +	 */
 +	switch (augmented_args->args.syscall_nr) {
 +	case SYS_ACCT:
 +	case SYS_ADD_KEY:
 +	case SYS_CHDIR:
 +	case SYS_CHMOD:
 +	case SYS_CHOWN:
 +	case SYS_CHROOT:
 +	case SYS_CREAT:
 +	case SYS_DELETE_MODULE:
 +	case SYS_EXECVE:
 +	case SYS_GETXATTR:
 +	case SYS_LCHOWN:
 +	case SYS_LGETXATTR:
 +	case SYS_LINK:
 +	case SYS_LISTXATTR:
 +	case SYS_LLISTXATTR:
 +	case SYS_LREMOVEXATTR:
 +	case SYS_LSETXATTR:
 +	case SYS_LSTAT:
 +	case SYS_MEMFD_CREATE:
 +	case SYS_MKDIR:
 +	case SYS_MKNOD:
 +	case SYS_MQ_OPEN:
 +	case SYS_MQ_UNLINK:
 +	case SYS_PIVOT_ROOT:
 +	case SYS_READLINK:
 +	case SYS_REMOVEXATTR:
 +	case SYS_RENAME:
 +	case SYS_REQUEST_KEY:
 +	case SYS_RMDIR:
 +	case SYS_SETXATTR:
 +	case SYS_STAT:
 +	case SYS_STATFS:
 +	case SYS_SWAPOFF:
 +	case SYS_SWAPON:
 +	case SYS_SYMLINK:
 +	case SYS_SYMLINKAT:
 +	case SYS_TRUNCATE:
 +	case SYS_UNLINK:
 +	case SYS_ACCESS:
 +	case SYS_OPEN:	 filename_arg = (const void *)args->args[0];
  			__asm__ __volatile__("": : :"memory");
 -			break;
 -		}
 +			 break;
 +	case SYS_EXECVEAT:
 +	case SYS_FACCESSAT:
 +	case SYS_FCHMODAT:
 +	case SYS_FCHOWNAT:
 +	case SYS_FGETXATTR:
 +	case SYS_FINIT_MODULE:
 +	case SYS_FREMOVEXATTR:
 +	case SYS_FSETXATTR:
 +	case SYS_FUTIMESAT:
 +	case SYS_INOTIFY_ADD_WATCH:
 +	case SYS_LINKAT:
 +	case SYS_MKDIRAT:
 +	case SYS_MKNODAT:
 +	case SYS_MQ_TIMEDSEND:
 +	case SYS_NAME_TO_HANDLE_AT:
 +	case SYS_NEWFSTATAT:
 +	case SYS_PWRITE64:
 +	case SYS_QUOTACTL:
 +	case SYS_READLINKAT:
 +	case SYS_RENAMEAT:
 +	case SYS_RENAMEAT2:
 +	case SYS_STATX:
 +	case SYS_UNLINKAT:
 +	case SYS_UTIMENSAT:
 +	case SYS_OPENAT: filename_arg = (const void *)args->args[1];
 +			 break;
  	}
  
++<<<<<<< HEAD
 +	if (filename_arg != NULL) {
 +		augmented_args->filename.reserved = 0;
 +		augmented_args->filename.size = probe_read_str(&augmented_args->filename.value,
 +							      sizeof(augmented_args->filename.value),
 +							      filename_arg);
 +		if (augmented_args->filename.size < sizeof(augmented_args->filename.value)) {
 +			len -= sizeof(augmented_args->filename.value) - augmented_args->filename.size;
 +			len &= sizeof(augmented_args->filename.value) - 1;
 +		}
++=======
+ 	verifier log:
+ 
+ ; if (syscall->string_args_len[arg] != 0) {
+ 37: (69) r3 = *(u16 *)(r0 +2)
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1_w=inv0 R2_w=map_value(id=0,off=2,ks=4,vs=14,imm=0) R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ ; if (syscall->string_args_len[arg] != 0) {
+ 38: (55) if r3 != 0x0 goto pc+5
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1=inv0 R2=map_value(id=0,off=2,ks=4,vs=14,imm=0) R3=inv0 R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ 39: (b7) r1 = 1
+ ; if (syscall->string_args_len[arg] != 0) {
+ 40: (bf) r2 = r0
+ 41: (07) r2 += 4
+ 42: (69) r3 = *(u16 *)(r0 +4)
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1_w=inv1 R2_w=map_value(id=0,off=4,ks=4,vs=14,imm=0) R3_w=inv0 R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ ; if (syscall->string_args_len[arg] != 0) {
+ 43: (15) if r3 == 0x0 goto pc+32
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1=inv1 R2=map_value(id=0,off=4,ks=4,vs=14,imm=0) R3=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff)) R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ ; filename_arg = (const void *)args->args[arg];
+ 44: (67) r1 <<= 3
+ 45: (bf) r3 = r6
+ 46: (0f) r3 += r1
+ 47: (b7) r5 = 64
+ 48: (79) r3 = *(u64 *)(r3 +16)
+ dereference of modified ctx ptr R3 off=8 disallowed
+ processed 46 insns (limit 1000000) max_states_per_insn 0 total_states 12 peak_states 12 mark_read 7
+ 	*/
+ 
+ #define __loop_iter(arg) \
+ 	if (syscall->string_args_len[arg] != 0) { \
+ 		filename_len = syscall->string_args_len[arg]; \
+ 		filename_arg = (const void *)args->args[arg];
+ #define loop_iter_first() __loop_iter(0); }
+ #define loop_iter(arg) else __loop_iter(arg); }
+ #define loop_iter_last(arg) else __loop_iter(arg); __asm__ __volatile__("": : :"memory"); }
+ 
+ 	loop_iter_first()
+ 	loop_iter(1)
+ 	loop_iter(2)
+ 	loop_iter(3)
+ 	loop_iter(4)
+ 	loop_iter_last(5)
+ 
+ 	if (filename_arg != NULL && filename_len <= sizeof(augmented_args->filename.value)) {
+ 		len = augmented_args__read_filename(augmented_args, filename_arg, filename_len);
++>>>>>>> 0c95a7ff76fb (perf augmented_raw_syscalls: Move the probe_read_str to a separate function)
  	} else {
  		len = sizeof(augmented_args->args);
  	}
* Unmerged path tools/perf/examples/bpf/augmented_raw_syscalls.c
