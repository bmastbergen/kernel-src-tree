s390/qeth: extract helper for route validation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 980f4568fa32736b1dec69db2cc7c947b767e52e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/980f4568.failed

As follow-up to commit 0cd6783d3c7d ("s390/qeth: check dst entry before use"),
consolidate the dst_check() logic into a single helper and add a wrapper
around the cast type selection.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 980f4568fa32736b1dec69db2cc7c947b767e52e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core.h
index be5bec70fa99,d354b39cdf4b..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -862,6 -869,27 +864,30 @@@ static inline int qeth_get_ip_version(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline int qeth_get_ether_cast_type(struct sk_buff *skb)
+ {
+ 	u8 *addr = eth_hdr(skb)->h_dest;
+ 
+ 	if (is_multicast_ether_addr(addr))
+ 		return is_broadcast_ether_addr(addr) ? RTN_BROADCAST :
+ 						       RTN_MULTICAST;
+ 	return RTN_UNICAST;
+ }
+ 
+ static inline struct dst_entry *qeth_dst_check_rcu(struct sk_buff *skb, int ipv)
+ {
+ 	struct dst_entry *dst = skb_dst(skb);
+ 	struct rt6_info *rt;
+ 
+ 	rt = (struct rt6_info *) dst;
+ 	if (dst)
+ 		dst = dst_check(dst, (ipv == 6) ? rt6_get_cookie(rt) : 0);
+ 	return dst;
+ }
+ 
++>>>>>>> 980f4568fa32 (s390/qeth: extract helper for route validation)
  static inline void qeth_rx_csum(struct qeth_card *card, struct sk_buff *skb,
  				u8 flags)
  {
diff --cc drivers/s390/net/qeth_l3_main.c
index 0e3a2d122884,5bf5129ddcd4..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1876,15 -1877,14 +1875,21 @@@ static int qeth_l3_do_ioctl(struct net_
  	return rc;
  }
  
- static int qeth_l3_get_cast_type(struct sk_buff *skb)
+ static int qeth_l3_get_cast_type_rcu(struct sk_buff *skb, struct dst_entry *dst,
+ 				     int ipv)
  {
  	struct neighbour *n = NULL;
- 	struct dst_entry *dst;
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	dst = skb_dst(skb);
 +	if (dst)
 +		n = dst_neigh_lookup_skb(dst, skb);
++=======
+ 	if (dst)
+ 		n = dst_neigh_lookup_skb(dst, skb);
+ 
++>>>>>>> 980f4568fa32 (s390/qeth: extract helper for route validation)
  	if (n) {
  		int cast_type = n->type;
  
@@@ -1896,10 -1895,9 +1900,9 @@@
  			return cast_type;
  		return RTN_UNICAST;
  	}
- 	rcu_read_unlock();
  
  	/* no neighbour (eg AF_PACKET), fall back to target's IP address ... */
 -	switch (ipv) {
 +	switch (qeth_get_ip_version(skb)) {
  	case 4:
  		if (ipv4_is_lbcast(ip_hdr(skb)->daddr))
  			return RTN_BROADCAST;
@@@ -1983,15 -1990,17 +2000,26 @@@ static void qeth_l3_fill_header(struct 
  	}
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	if (ipv == 4) {
 +		struct rtable *rt = skb_rtable(skb);
++=======
+ 	dst = qeth_dst_check_rcu(skb, ipv);
+ 
+ 	if (ipv == 4) {
+ 		struct rtable *rt = (struct rtable *) dst;
++>>>>>>> 980f4568fa32 (s390/qeth: extract helper for route validation)
  
  		*((__be32 *) &hdr->hdr.l3.next_hop.ipv4.addr) = (rt) ?
  				rt_nexthop(rt, ip_hdr(skb)->daddr) :
  				ip_hdr(skb)->daddr;
  	} else {
  		/* IPv6 */
++<<<<<<< HEAD
 +		const struct rt6_info *rt = skb_rt6_info(skb);
++=======
+ 		struct rt6_info *rt = (struct rt6_info *) dst;
++>>>>>>> 980f4568fa32 (s390/qeth: extract helper for route validation)
  
  		if (rt && !ipv6_addr_any(&rt->rt6i_gateway))
  			l3_hdr->next_hop.ipv6_addr = rt->rt6i_gateway;
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_l3_main.c
