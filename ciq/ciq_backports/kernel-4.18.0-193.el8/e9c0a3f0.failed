mm/sparsemem: convert kmalloc_section_memmap() to populate_section_memmap()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] sparsemem: convert kmalloc_section_memmap() to populate_section_memmap() (Baoquan He) [1724969]
Rebuild_FUZZ: 97.96%
commit-author Dan Williams <dan.j.williams@intel.com>
commit e9c0a3f05477e18d2dae816cb61b62be1b7e90d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e9c0a3f0.failed

Allow sub-section sized ranges to be added to the memmap.

populate_section_memmap() takes an explict pfn range rather than
assuming a full section, and those parameters are plumbed all the way
through to vmmemap_populate().  There should be no sub-section usage in
current deployments.  New warnings are added to clarify which memmap
allocation paths are sub-section capable.

Link: http://lkml.kernel.org/r/156092352058.979959.6551283472062305149.stgit@dwillia2-desk3.amr.corp.intel.com
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
	Tested-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>	[ppc64]
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: Jane Chu <jane.chu@oracle.com>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Jérôme Glisse <jglisse@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Toshi Kani <toshi.kani@hpe.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Wei Yang <richardw.yang@linux.intel.com>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e9c0a3f05477e18d2dae816cb61b62be1b7e90d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/sparse.c
diff --cc mm/sparse.c
index 02b5de3161a3,6b01022e23a9..000000000000
--- a/mm/sparse.c
+++ b/mm/sparse.c
@@@ -584,9 -649,9 +587,10 @@@ static void free_map_bootmem(struct pag
  
  	vmemmap_free(start, end, NULL);
  }
 +#endif /* CONFIG_MEMORY_HOTREMOVE */
  #else
- static struct page *__kmalloc_section_memmap(void)
+ struct page *populate_section_memmap(unsigned long pfn,
+ 		unsigned long nr_pages, int nid, struct vmem_altmap *altmap)
  {
  	struct page *page, *ret;
  	unsigned long memmap_size = sizeof(struct page) * PAGES_PER_SECTION;
@@@ -686,12 -745,13 +686,19 @@@ int __meminit sparse_add_one_section(in
  	if (ret < 0 && ret != -EEXIST)
  		return ret;
  	ret = 0;
- 	memmap = kmalloc_section_memmap(section_nr, nid, altmap);
+ 	memmap = populate_section_memmap(start_pfn, PAGES_PER_SECTION, nid,
+ 			altmap);
  	if (!memmap)
  		return -ENOMEM;
++<<<<<<< HEAD
 +	usemap = __kmalloc_section_usemap();
 +	if (!usemap) {
 +		__kfree_section_memmap(memmap, altmap);
++=======
+ 	usage = kzalloc(mem_section_usage_size(), GFP_KERNEL);
+ 	if (!usage) {
+ 		depopulate_section_memmap(start_pfn, PAGES_PER_SECTION, altmap);
++>>>>>>> e9c0a3f05477 (mm/sparsemem: convert kmalloc_section_memmap() to populate_section_memmap())
  		return -ENOMEM;
  	}
  
@@@ -713,8 -773,8 +720,13 @@@
  
  out:
  	if (ret < 0) {
++<<<<<<< HEAD
 +		kfree(usemap);
 +		__kfree_section_memmap(memmap, altmap);
++=======
+ 		kfree(usage);
+ 		depopulate_section_memmap(start_pfn, PAGES_PER_SECTION, altmap);
++>>>>>>> e9c0a3f05477 (mm/sparsemem: convert kmalloc_section_memmap() to populate_section_memmap())
  	}
  	return ret;
  }
@@@ -741,22 -809,20 +753,28 @@@ static inline void clear_hwpoisoned_pag
  }
  #endif
  
++<<<<<<< HEAD
 +static void free_section_usemap(struct page *memmap, unsigned long *usemap,
 +		struct vmem_altmap *altmap)
++=======
+ static void free_section_usage(struct mem_section *ms, struct page *memmap,
+ 		struct mem_section_usage *usage, unsigned long pfn,
+ 		unsigned long nr_pages, struct vmem_altmap *altmap)
++>>>>>>> e9c0a3f05477 (mm/sparsemem: convert kmalloc_section_memmap() to populate_section_memmap())
  {
 -	if (!usage)
 +	struct page *usemap_page;
 +
 +	if (!usemap)
  		return;
  
 +	usemap_page = virt_to_page(usemap);
  	/*
  	 * Check to see if allocation came from hot-plug-add
  	 */
 -	if (!early_section(ms)) {
 -		kfree(usage);
 +	if (PageSlab(usemap_page) || PageCompound(usemap_page)) {
 +		kfree(usemap);
  		if (memmap)
- 			__kfree_section_memmap(memmap, altmap);
+ 			depopulate_section_memmap(pfn, nr_pages, altmap);
  		return;
  	}
  
@@@ -785,7 -851,8 +803,13 @@@ void sparse_remove_one_section(struct m
  
  	clear_hwpoisoned_pages(memmap + map_offset,
  			PAGES_PER_SECTION - map_offset);
++<<<<<<< HEAD
 +	free_section_usemap(memmap, usemap, altmap);
++=======
+ 	free_section_usage(ms, memmap, usage,
+ 			section_nr_to_pfn(__section_nr(ms)),
+ 			PAGES_PER_SECTION, altmap);
++>>>>>>> e9c0a3f05477 (mm/sparsemem: convert kmalloc_section_memmap() to populate_section_memmap())
  }
 +#endif /* CONFIG_MEMORY_HOTREMOVE */
  #endif /* CONFIG_MEMORY_HOTPLUG */
diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c
index df54e352638e..949286035dd4 100644
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@ -1536,7 +1536,9 @@ int __meminit vmemmap_populate(unsigned long start, unsigned long end, int node,
 {
 	int err;
 
-	if (boot_cpu_has(X86_FEATURE_PSE))
+	if (end - start < PAGES_PER_SECTION * sizeof(struct page))
+		err = vmemmap_populate_basepages(start, end, node);
+	else if (boot_cpu_has(X86_FEATURE_PSE))
 		err = vmemmap_populate_hugepages(start, end, node, altmap);
 	else if (altmap) {
 		pr_err_once("%s: no cpu support for altmap allocations\n",
diff --git a/include/linux/mm.h b/include/linux/mm.h
index d0cd419aec89..5fdfdbb22924 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2734,8 +2734,8 @@ const char * arch_vma_name(struct vm_area_struct *vma);
 void print_vma_addr(char *prefix, unsigned long rip);
 
 void *sparse_buffer_alloc(unsigned long size);
-struct page *sparse_mem_map_populate(unsigned long pnum, int nid,
-		struct vmem_altmap *altmap);
+struct page * __populate_section_memmap(unsigned long pfn,
+		unsigned long nr_pages, int nid, struct vmem_altmap *altmap);
 pgd_t *vmemmap_pgd_populate(unsigned long addr, int node);
 p4d_t *vmemmap_p4d_populate(pgd_t *pgd, unsigned long addr, int node);
 pud_t *vmemmap_pud_populate(p4d_t *p4d, unsigned long addr, int node);
diff --git a/mm/sparse-vmemmap.c b/mm/sparse-vmemmap.c
index 8301293331a2..560f92e52b56 100644
--- a/mm/sparse-vmemmap.c
+++ b/mm/sparse-vmemmap.c
@@ -245,19 +245,26 @@ int __meminit vmemmap_populate_basepages(unsigned long start,
 	return 0;
 }
 
-struct page * __meminit sparse_mem_map_populate(unsigned long pnum, int nid,
-		struct vmem_altmap *altmap)
+struct page * __meminit __populate_section_memmap(unsigned long pfn,
+		unsigned long nr_pages, int nid, struct vmem_altmap *altmap)
 {
 	unsigned long start;
 	unsigned long end;
-	struct page *map;
 
-	map = pfn_to_page(pnum * PAGES_PER_SECTION);
-	start = (unsigned long)map;
-	end = (unsigned long)(map + PAGES_PER_SECTION);
+	/*
+	 * The minimum granularity of memmap extensions is
+	 * PAGES_PER_SUBSECTION as allocations are tracked in the
+	 * 'subsection_map' bitmap of the section.
+	 */
+	end = ALIGN(pfn + nr_pages, PAGES_PER_SUBSECTION);
+	pfn &= PAGE_SUBSECTION_MASK;
+	nr_pages = end - pfn;
+
+	start = (unsigned long) pfn_to_page(pfn);
+	end = start + nr_pages * sizeof(struct page);
 
 	if (vmemmap_populate(start, end, nid, altmap))
 		return NULL;
 
-	return map;
+	return pfn_to_page(pfn);
 }
* Unmerged path mm/sparse.c
