xprtrdma: Add unique trace points for posting Local Invalidate WRs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 4b93dab36f28e673725e5e6123ebfccf7697f96a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4b93dab3.failed

When adding frwr_unmap_async way back when, I re-used the existing
trace_xprtrdma_post_send() trace point to record the return code
of ib_post_send.

Unfortunately there are some cases where re-using that trace point
causes a crash. Instead, construct a trace point specific to posting
Local Invalidate WRs that will always be safe to use in that context,
and will act as a trace log eye-catcher for Local Invalidation.

Fixes: 847568942f93 ("xprtrdma: Remove fr_state")
Fixes: d8099feda483 ("xprtrdma: Reduce context switching due ... ")
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Bill Baker <bill.baker@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 4b93dab36f28e673725e5e6123ebfccf7697f96a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/frwr_ops.c
diff --cc net/sunrpc/xprtrdma/frwr_ops.c
index 4f4311900f93,9901a811f598..000000000000
--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@@ -581,30 -568,21 +581,40 @@@ void frwr_unmap_sync(struct rpcrdma_xpr
  	 * replaces the QP. The RPC reply handler won't call us
  	 * unless ri_id->qp is a valid pointer.
  	 */
 +	r_xprt->rx_stats.local_inv_needed++;
  	bad_wr = NULL;
++<<<<<<< HEAD
 +	rc = ib_post_send(ia->ri_id->qp, first, &bad_wr);
++=======
+ 	rc = ib_post_send(r_xprt->rx_ia.ri_id->qp, first, &bad_wr);
+ 
+ 	/* The final LOCAL_INV WR in the chain is supposed to
+ 	 * do the wake. If it was never posted, the wake will
+ 	 * not happen, so don't wait in that case.
+ 	 */
++>>>>>>> 4b93dab36f28 (xprtrdma: Add unique trace points for posting Local Invalidate WRs)
  	if (bad_wr != first)
  		wait_for_completion(&frwr->fr_linv_done);
 -	if (!rc)
 -		return;
 +	if (rc)
 +		goto out_release;
  
 -	/* Recycle MRs in the LOCAL_INV chain that did not get posted.
 +	/* ORDER: Now DMA unmap all of the MRs, and return
 +	 * them to the free MR list.
 +	 */
 +unmap:
 +	while (!list_empty(mrs)) {
 +		mr = rpcrdma_mr_pop(mrs);
 +		rpcrdma_mr_unmap_and_put(mr);
 +	}
 +	return;
 +
 +out_release:
 +	pr_err("rpcrdma: FRWR invalidate ib_post_send returned %i\n", rc);
 +
 +	/* Unmap and release the MRs in the LOCAL_INV WRs that did not
 +	 * get posted.
  	 */
+ 	trace_xprtrdma_post_linv(req, rc);
  	while (bad_wr) {
  		frwr = container_of(bad_wr, struct rpcrdma_frwr,
  				    fr_invwr);
@@@ -615,3 -593,103 +625,106 @@@
  		rpcrdma_mr_recycle(mr);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * frwr_wc_localinv_done - Invoked by RDMA provider for a signaled LOCAL_INV WC
+  * @cq:	completion queue (ignored)
+  * @wc:	completed WR
+  *
+  */
+ static void frwr_wc_localinv_done(struct ib_cq *cq, struct ib_wc *wc)
+ {
+ 	struct ib_cqe *cqe = wc->wr_cqe;
+ 	struct rpcrdma_frwr *frwr =
+ 		container_of(cqe, struct rpcrdma_frwr, fr_cqe);
+ 	struct rpcrdma_mr *mr = container_of(frwr, struct rpcrdma_mr, frwr);
+ 	struct rpcrdma_rep *rep = mr->mr_req->rl_reply;
+ 
+ 	/* WARNING: Only wr_cqe and status are reliable at this point */
+ 	trace_xprtrdma_wc_li_done(wc, frwr);
+ 	__frwr_release_mr(wc, mr);
+ 
+ 	/* Ensure @rep is generated before __frwr_release_mr */
+ 	smp_rmb();
+ 	rpcrdma_complete_rqst(rep);
+ }
+ 
+ /**
+  * frwr_unmap_async - invalidate memory regions that were registered for @req
+  * @r_xprt: controlling transport instance
+  * @req: rpcrdma_req with a non-empty list of MRs to process
+  *
+  * This guarantees that registered MRs are properly fenced from the
+  * server before the RPC consumer accesses the data in them. It also
+  * ensures proper Send flow control: waking the next RPC waits until
+  * this RPC has relinquished all its Send Queue entries.
+  */
+ void frwr_unmap_async(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)
+ {
+ 	struct ib_send_wr *first, *last, **prev;
+ 	const struct ib_send_wr *bad_wr;
+ 	struct rpcrdma_frwr *frwr;
+ 	struct rpcrdma_mr *mr;
+ 	int rc;
+ 
+ 	/* Chain the LOCAL_INV Work Requests and post them with
+ 	 * a single ib_post_send() call.
+ 	 */
+ 	frwr = NULL;
+ 	prev = &first;
+ 	while ((mr = rpcrdma_mr_pop(&req->rl_registered))) {
+ 
+ 		trace_xprtrdma_mr_localinv(mr);
+ 		r_xprt->rx_stats.local_inv_needed++;
+ 
+ 		frwr = &mr->frwr;
+ 		frwr->fr_cqe.done = frwr_wc_localinv;
+ 		last = &frwr->fr_invwr;
+ 		last->next = NULL;
+ 		last->wr_cqe = &frwr->fr_cqe;
+ 		last->sg_list = NULL;
+ 		last->num_sge = 0;
+ 		last->opcode = IB_WR_LOCAL_INV;
+ 		last->send_flags = IB_SEND_SIGNALED;
+ 		last->ex.invalidate_rkey = mr->mr_handle;
+ 
+ 		*prev = last;
+ 		prev = &last->next;
+ 	}
+ 
+ 	/* Strong send queue ordering guarantees that when the
+ 	 * last WR in the chain completes, all WRs in the chain
+ 	 * are complete. The last completion will wake up the
+ 	 * RPC waiter.
+ 	 */
+ 	frwr->fr_cqe.done = frwr_wc_localinv_done;
+ 
+ 	/* Transport disconnect drains the receive CQ before it
+ 	 * replaces the QP. The RPC reply handler won't call us
+ 	 * unless ri_id->qp is a valid pointer.
+ 	 */
+ 	bad_wr = NULL;
+ 	rc = ib_post_send(r_xprt->rx_ia.ri_id->qp, first, &bad_wr);
+ 	if (!rc)
+ 		return;
+ 
+ 	/* Recycle MRs in the LOCAL_INV chain that did not get posted.
+ 	 */
+ 	trace_xprtrdma_post_linv(req, rc);
+ 	while (bad_wr) {
+ 		frwr = container_of(bad_wr, struct rpcrdma_frwr, fr_invwr);
+ 		mr = container_of(frwr, struct rpcrdma_mr, frwr);
+ 		bad_wr = bad_wr->next;
+ 
+ 		rpcrdma_mr_recycle(mr);
+ 	}
+ 
+ 	/* The final LOCAL_INV WR in the chain is supposed to
+ 	 * do the wake. If it was never posted, the wake will
+ 	 * not happen, so wake here in that case.
+ 	 */
+ 	rpcrdma_complete_rqst(req->rl_reply);
+ }
++>>>>>>> 4b93dab36f28 (xprtrdma: Add unique trace points for posting Local Invalidate WRs)
diff --git a/include/trace/events/rpcrdma.h b/include/trace/events/rpcrdma.h
index bfa903f6b855..5c0c6e784821 100644
--- a/include/trace/events/rpcrdma.h
+++ b/include/trace/events/rpcrdma.h
@@ -622,6 +622,31 @@ TRACE_EVENT(xprtrdma_post_recvs,
 	)
 );
 
+TRACE_EVENT(xprtrdma_post_linv,
+	TP_PROTO(
+		const struct rpcrdma_req *req,
+		int status
+	),
+
+	TP_ARGS(req, status),
+
+	TP_STRUCT__entry(
+		__field(const void *, req)
+		__field(int, status)
+		__field(u32, xid)
+	),
+
+	TP_fast_assign(
+		__entry->req = req;
+		__entry->status = status;
+		__entry->xid = be32_to_cpu(req->rl_slot.rq_xid);
+	),
+
+	TP_printk("req=%p xid=0x%08x status=%d",
+		__entry->req, __entry->xid, __entry->status
+	)
+);
+
 /**
  ** Completion events
  **/
* Unmerged path net/sunrpc/xprtrdma/frwr_ops.c
