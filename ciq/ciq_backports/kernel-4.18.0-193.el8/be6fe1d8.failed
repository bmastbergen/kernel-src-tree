devlink: require non-NULL ops for devlink instances

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit be6fe1d8e1023bd80e122fa5eeeaff2ce66e9247
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/be6fe1d8.failed

Commit 76726ccb7f46 ("devlink: add flash update command") and
commit 2d8dc5bbf4e7 ("devlink: Add support for reload")
access devlink ops without NULL-checking. There is, however, no
driver which would pass in NULL ops, so let's just make that
a requirement. Remove the now unnecessary NULL-checking.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit be6fe1d8e1023bd80e122fa5eeeaff2ce66e9247)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index 697c7c3684df,a49dee67e66f..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -6451,55 -6424,49 +6447,72 @@@ free_msg
  void devlink_compat_running_version(struct net_device *dev,
  				    char *buf, size_t len)
  {
 +	struct devlink_port *devlink_port;
  	struct devlink *devlink;
  
 -	dev_hold(dev);
 -	rtnl_unlock();
 -
  	mutex_lock(&devlink_mutex);
++<<<<<<< HEAD
 +	list_for_each_entry(devlink, &devlink_list, list) {
 +		mutex_lock(&devlink->lock);
 +		list_for_each_entry(devlink_port, &devlink->port_list, list) {
 +			if (devlink_port->type == DEVLINK_PORT_TYPE_ETH &&
 +			    devlink_port->type_dev == dev) {
 +				__devlink_compat_running_version(devlink,
 +								 buf, len);
 +				mutex_unlock(&devlink->lock);
 +				goto out;
 +			}
 +		}
 +		mutex_unlock(&devlink->lock);
 +	}
 +out:
++=======
+ 	devlink = netdev_to_devlink(dev);
+ 	if (!devlink || !devlink->ops->info_get)
+ 		goto unlock_list;
+ 
+ 	mutex_lock(&devlink->lock);
+ 	__devlink_compat_running_version(devlink, buf, len);
+ 	mutex_unlock(&devlink->lock);
+ unlock_list:
++>>>>>>> be6fe1d8e102 (devlink: require non-NULL ops for devlink instances)
  	mutex_unlock(&devlink_mutex);
 -
 -	rtnl_lock();
 -	dev_put(dev);
  }
  
  int devlink_compat_flash_update(struct net_device *dev, const char *file_name)
  {
 +	struct devlink_port *devlink_port;
  	struct devlink *devlink;
 -	int ret = -EOPNOTSUPP;
 -
 -	dev_hold(dev);
 -	rtnl_unlock();
  
  	mutex_lock(&devlink_mutex);
++<<<<<<< HEAD
 +	list_for_each_entry(devlink, &devlink_list, list) {
 +		mutex_lock(&devlink->lock);
 +		list_for_each_entry(devlink_port, &devlink->port_list, list) {
 +			int ret = -EOPNOTSUPP;
++=======
+ 	devlink = netdev_to_devlink(dev);
+ 	if (!devlink || !devlink->ops->flash_update)
+ 		goto unlock_list;
++>>>>>>> be6fe1d8e102 (devlink: require non-NULL ops for devlink instances)
  
 -	mutex_lock(&devlink->lock);
 -	ret = devlink->ops->flash_update(devlink, file_name, NULL, NULL);
 -	mutex_unlock(&devlink->lock);
 -unlock_list:
 -	mutex_unlock(&devlink_mutex);
 +			if (devlink_port->type != DEVLINK_PORT_TYPE_ETH ||
 +			    devlink_port->type_dev != dev)
 +				continue;
  
 -	rtnl_lock();
 -	dev_put(dev);
 +			mutex_unlock(&devlink_mutex);
 +			if (devlink->ops->flash_update)
 +				ret = devlink->ops->flash_update(devlink,
 +								 file_name,
 +								 NULL, NULL);
 +			mutex_unlock(&devlink->lock);
 +			return ret;
 +		}
 +		mutex_unlock(&devlink->lock);
 +	}
 +	mutex_unlock(&devlink_mutex);
  
 -	return ret;
 +	return -EOPNOTSUPP;
  }
  
  static int __init devlink_init(void)
* Unmerged path net/core/devlink.c
