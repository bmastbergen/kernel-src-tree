xfs: clear BAD_SUMMARY if unmounting an unhealthy filesystem

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 519841c207de9926418d2f39e162097088478781
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/519841c2.failed

If we know the filesystem metadata isn't healthy during unmount, we want
to encourage the administrator to run xfs_repair right away.  We can't
do this if BAD_SUMMARY will cause an unclean log unmount to force
summary recalculation, so turn it off if the fs is bad.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit 519841c207de9926418d2f39e162097088478781)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_health.h
#	fs/xfs/xfs_health.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_trace.h
index a8c32206e147,2464ea351f83..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -3362,6 -3362,160 +3362,163 @@@ DEFINE_TRANS_EVENT(xfs_trans_roll)
  DEFINE_TRANS_EVENT(xfs_trans_add_item);
  DEFINE_TRANS_EVENT(xfs_trans_free_items);
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(xfs_iunlink_update_bucket,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, unsigned int bucket,
+ 		 xfs_agino_t old_ptr, xfs_agino_t new_ptr),
+ 	TP_ARGS(mp, agno, bucket, old_ptr, new_ptr),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(unsigned int, bucket)
+ 		__field(xfs_agino_t, old_ptr)
+ 		__field(xfs_agino_t, new_ptr)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->bucket = bucket;
+ 		__entry->old_ptr = old_ptr;
+ 		__entry->new_ptr = new_ptr;
+ 	),
+ 	TP_printk("dev %d:%d agno %u bucket %u old 0x%x new 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->bucket,
+ 		  __entry->old_ptr,
+ 		  __entry->new_ptr)
+ );
+ 
+ TRACE_EVENT(xfs_iunlink_update_dinode,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, xfs_agino_t agino,
+ 		 xfs_agino_t old_ptr, xfs_agino_t new_ptr),
+ 	TP_ARGS(mp, agno, agino, old_ptr, new_ptr),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agino_t, agino)
+ 		__field(xfs_agino_t, old_ptr)
+ 		__field(xfs_agino_t, new_ptr)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agino = agino;
+ 		__entry->old_ptr = old_ptr;
+ 		__entry->new_ptr = new_ptr;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agino 0x%x old 0x%x new 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agino,
+ 		  __entry->old_ptr,
+ 		  __entry->new_ptr)
+ );
+ 
+ DECLARE_EVENT_CLASS(xfs_ag_inode_class,
+ 	TP_PROTO(struct xfs_inode *ip),
+ 	TP_ARGS(ip),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agino_t, agino)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+ 		__entry->agno = XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino);
+ 		__entry->agino = XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino);
+ 	),
+ 	TP_printk("dev %d:%d agno %u agino %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno, __entry->agino)
+ )
+ 
+ #define DEFINE_AGINODE_EVENT(name) \
+ DEFINE_EVENT(xfs_ag_inode_class, name, \
+ 	TP_PROTO(struct xfs_inode *ip), \
+ 	TP_ARGS(ip))
+ DEFINE_AGINODE_EVENT(xfs_iunlink);
+ DEFINE_AGINODE_EVENT(xfs_iunlink_remove);
+ DEFINE_AG_EVENT(xfs_iunlink_map_prev_fallback);
+ 
+ DECLARE_EVENT_CLASS(xfs_fs_corrupt_class,
+ 	TP_PROTO(struct xfs_mount *mp, unsigned int flags),
+ 	TP_ARGS(mp, flags),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(unsigned int, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->flags = flags;
+ 	),
+ 	TP_printk("dev %d:%d flags 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->flags)
+ );
+ #define DEFINE_FS_CORRUPT_EVENT(name)	\
+ DEFINE_EVENT(xfs_fs_corrupt_class, name,	\
+ 	TP_PROTO(struct xfs_mount *mp, unsigned int flags), \
+ 	TP_ARGS(mp, flags))
+ DEFINE_FS_CORRUPT_EVENT(xfs_fs_mark_sick);
+ DEFINE_FS_CORRUPT_EVENT(xfs_fs_mark_healthy);
+ DEFINE_FS_CORRUPT_EVENT(xfs_fs_unfixed_corruption);
+ DEFINE_FS_CORRUPT_EVENT(xfs_rt_mark_sick);
+ DEFINE_FS_CORRUPT_EVENT(xfs_rt_mark_healthy);
+ DEFINE_FS_CORRUPT_EVENT(xfs_rt_unfixed_corruption);
+ 
+ DECLARE_EVENT_CLASS(xfs_ag_corrupt_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, unsigned int flags),
+ 	TP_ARGS(mp, agno, flags),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(unsigned int, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->flags = flags;
+ 	),
+ 	TP_printk("dev %d:%d agno %u flags 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno, __entry->flags)
+ );
+ #define DEFINE_AG_CORRUPT_EVENT(name)	\
+ DEFINE_EVENT(xfs_ag_corrupt_class, name,	\
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 unsigned int flags), \
+ 	TP_ARGS(mp, agno, flags))
+ DEFINE_AG_CORRUPT_EVENT(xfs_ag_mark_sick);
+ DEFINE_AG_CORRUPT_EVENT(xfs_ag_mark_healthy);
+ DEFINE_AG_CORRUPT_EVENT(xfs_ag_unfixed_corruption);
+ 
+ DECLARE_EVENT_CLASS(xfs_inode_corrupt_class,
+ 	TP_PROTO(struct xfs_inode *ip, unsigned int flags),
+ 	TP_ARGS(ip, flags),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, ino)
+ 		__field(unsigned int, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = ip->i_mount->m_super->s_dev;
+ 		__entry->ino = ip->i_ino;
+ 		__entry->flags = flags;
+ 	),
+ 	TP_printk("dev %d:%d ino 0x%llx flags 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->ino, __entry->flags)
+ );
+ #define DEFINE_INODE_CORRUPT_EVENT(name)	\
+ DEFINE_EVENT(xfs_inode_corrupt_class, name,	\
+ 	TP_PROTO(struct xfs_inode *ip, unsigned int flags), \
+ 	TP_ARGS(ip, flags))
+ DEFINE_INODE_CORRUPT_EVENT(xfs_inode_mark_sick);
+ DEFINE_INODE_CORRUPT_EVENT(xfs_inode_mark_healthy);
+ 
++>>>>>>> 519841c207de (xfs: clear BAD_SUMMARY if unmounting an unhealthy filesystem)
  #endif /* _TRACE_XFS_H */
  
  #undef TRACE_INCLUDE_PATH
* Unmerged path fs/xfs/libxfs/xfs_health.h
* Unmerged path fs/xfs/xfs_health.c
* Unmerged path fs/xfs/libxfs/xfs_health.h
* Unmerged path fs/xfs/xfs_health.c
diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index 8b9215b491a4..dafcfa991a4c 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -1064,6 +1064,7 @@ xfs_mountfs(
 	 */
 	cancel_delayed_work_sync(&mp->m_reclaim_work);
 	xfs_reclaim_inodes(mp, SYNC_WAIT);
+	xfs_health_unmount(mp);
  out_log_dealloc:
 	mp->m_flags |= XFS_MOUNT_UNMOUNTING;
 	xfs_log_mount_cancel(mp);
@@ -1146,6 +1147,7 @@ xfs_unmountfs(
 	 */
 	cancel_delayed_work_sync(&mp->m_reclaim_work);
 	xfs_reclaim_inodes(mp, SYNC_WAIT);
+	xfs_health_unmount(mp);
 
 	xfs_qm_unmount(mp);
 
* Unmerged path fs/xfs/xfs_trace.h
