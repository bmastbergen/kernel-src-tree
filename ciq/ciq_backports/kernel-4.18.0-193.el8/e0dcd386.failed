net: devlink: don't take devlink_mutex for devlink_compat_*

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] devlink: don't take devlink_mutex for devlink_compat_* (Petr Oros) [1737527]
Rebuild_FUZZ: 95.58%
commit-author Jiri Pirko <jiri@mellanox.com>
commit e0dcd386d1fc6ed9e90d76dfdf533287555d79d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e0dcd386.failed

The netdevice is guaranteed to not disappear so we can rely that
devlink_port and devlink won't disappear as well. No need to take
devlink_mutex so don't take it here.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e0dcd386d1fc6ed9e90d76dfdf533287555d79d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index 9b659b554b33,65c1cf4a5764..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -6451,55 -6402,47 +6451,95 @@@ free_msg
  void devlink_compat_running_version(struct net_device *dev,
  				    char *buf, size_t len)
  {
 +	struct devlink_port *devlink_port;
  	struct devlink *devlink;
  
++<<<<<<< HEAD
 +	mutex_lock(&devlink_mutex);
 +	list_for_each_entry(devlink, &devlink_list, list) {
 +		mutex_lock(&devlink->lock);
 +		list_for_each_entry(devlink_port, &devlink->port_list, list) {
 +			if (devlink_port->type == DEVLINK_PORT_TYPE_ETH &&
 +			    devlink_port->type_dev == dev) {
 +				__devlink_compat_running_version(devlink,
 +								 buf, len);
 +				mutex_unlock(&devlink->lock);
 +				goto out;
 +			}
 +		}
 +		mutex_unlock(&devlink->lock);
 +	}
 +out:
 +	mutex_unlock(&devlink_mutex);
++=======
+ 	dev_hold(dev);
+ 	rtnl_unlock();
+ 
+ 	devlink = netdev_to_devlink(dev);
+ 	if (!devlink || !devlink->ops->info_get)
+ 		goto out;
+ 
+ 	mutex_lock(&devlink->lock);
+ 	__devlink_compat_running_version(devlink, buf, len);
+ 	mutex_unlock(&devlink->lock);
+ 
+ out:
+ 	rtnl_lock();
+ 	dev_put(dev);
++>>>>>>> e0dcd386d1fc (net: devlink: don't take devlink_mutex for devlink_compat_*)
  }
  
  int devlink_compat_flash_update(struct net_device *dev, const char *file_name)
  {
 +	struct devlink_port *devlink_port;
  	struct devlink *devlink;
++<<<<<<< HEAD
 +
 +	mutex_lock(&devlink_mutex);
 +	list_for_each_entry(devlink, &devlink_list, list) {
 +		mutex_lock(&devlink->lock);
 +		list_for_each_entry(devlink_port, &devlink->port_list, list) {
 +			int ret = -EOPNOTSUPP;
 +
 +			if (devlink_port->type != DEVLINK_PORT_TYPE_ETH ||
 +			    devlink_port->type_dev != dev)
 +				continue;
 +
 +			mutex_unlock(&devlink_mutex);
 +			if (devlink->ops->flash_update)
 +				ret = devlink->ops->flash_update(devlink,
 +								 file_name,
 +								 NULL, NULL);
 +			mutex_unlock(&devlink->lock);
 +			return ret;
 +		}
 +		mutex_unlock(&devlink->lock);
 +	}
 +	mutex_unlock(&devlink_mutex);
 +
 +	return -EOPNOTSUPP;
++=======
+ 	int ret;
+ 
+ 	dev_hold(dev);
+ 	rtnl_unlock();
+ 
+ 	devlink = netdev_to_devlink(dev);
+ 	if (!devlink || !devlink->ops->flash_update) {
+ 		ret = -EOPNOTSUPP;
+ 		goto out;
+ 	}
+ 
+ 	mutex_lock(&devlink->lock);
+ 	ret = devlink->ops->flash_update(devlink, file_name, NULL, NULL);
+ 	mutex_unlock(&devlink->lock);
+ 
+ out:
+ 	rtnl_lock();
+ 	dev_put(dev);
+ 
+ 	return ret;
++>>>>>>> e0dcd386d1fc (net: devlink: don't take devlink_mutex for devlink_compat_*)
  }
  
  static int __init devlink_init(void)
* Unmerged path net/core/devlink.c
