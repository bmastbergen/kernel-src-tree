SUNRPC: Check whether the task was transmitted before rebind/reconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 03e51d32da995030a16697038232171807eeb0f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/03e51d32.failed

Before initiating transport actions that require putting the task to sleep,
such as rebinding or reconnecting, we should check whether or not the task
was already transmitted.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 03e51d32da995030a16697038232171807eeb0f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 6bd26eab15c9,67c955d8b21b..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1745,23 -1759,76 +1745,41 @@@ rpc_xdr_encode(struct rpc_task *task
  		     req->rq_rbuffer,
  		     req->rq_rcvsize);
  
 -	req->rq_snd_buf.head[0].iov_len = 0;
 -	xdr_init_encode(&xdr, &req->rq_snd_buf,
 -			req->rq_snd_buf.head[0].iov_base, req);
 -	if (rpc_encode_header(task, &xdr))
 +	p = rpc_encode_header(task);
 +	if (p == NULL) {
 +		printk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");
 +		rpc_exit(task, -EIO);
  		return;
 +	}
  
 -	task->tk_status = rpcauth_wrap_req(task, &xdr);
 -}
 -
 -/*
 - * 3.	Encode arguments of an RPC call
 - */
 -static void
 -call_encode(struct rpc_task *task)
 -{
 -	if (!rpc_task_need_encode(task))
 -		goto out;
 -	dprint_status(task);
 -	/* Encode here so that rpcsec_gss can use correct sequence number. */
 -	rpc_xdr_encode(task);
 -	/* Did the encode result in an error condition? */
 -	if (task->tk_status != 0) {
 -		/* Was the error nonfatal? */
 -		switch (task->tk_status) {
 -		case -EAGAIN:
 -		case -ENOMEM:
 -			rpc_delay(task, HZ >> 4);
 -			break;
 -		case -EKEYEXPIRED:
 -			task->tk_action = call_refresh;
 -			break;
 -		default:
 -			rpc_exit(task, task->tk_status);
 -		}
 +	encode = task->tk_msg.rpc_proc->p_encode;
 +	if (encode == NULL)
  		return;
 -	} else {
 -		xprt_request_prepare(task->tk_rqstp);
 -	}
  
 -	/* Add task to reply queue before transmission to avoid races */
 -	if (rpc_reply_expected(task))
 -		xprt_request_enqueue_receive(task);
 -	xprt_request_enqueue_transmit(task);
 -out:
 -	task->tk_action = call_transmit;
 -	/* Check that the connection is OK */
 -	if (!xprt_bound(task->tk_xprt))
 -		task->tk_action = call_bind;
 -	else if (!xprt_connected(task->tk_xprt))
 -		task->tk_action = call_connect;
 +	task->tk_status = rpcauth_wrap_req(task, encode, req, p,
 +			task->tk_msg.rpc_argp);
 +	if (task->tk_status == 0)
 +		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
  }
  
+ /*
+  * Helpers to check if the task was already transmitted, and
+  * to take action when that is the case.
+  */
+ static bool
+ rpc_task_transmitted(struct rpc_task *task)
+ {
+ 	return !test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
+ }
+ 
+ static void
+ rpc_task_handle_transmitted(struct rpc_task *task)
+ {
+ 	xprt_end_transmit(task);
+ 	task->tk_action = call_transmit_status;
+ 	call_transmit_status(task);
+ }
+ 
  /*
   * 4.	Get the server port number if not yet set
   */
@@@ -1948,7 -2032,10 +1979,14 @@@ call_connect_status(struct rpc_task *ta
  static void
  call_transmit(struct rpc_task *task)
  {
++<<<<<<< HEAD
 +	int is_retrans = RPC_WAS_SENT(task);
++=======
+ 	if (rpc_task_transmitted(task)) {
+ 		rpc_task_handle_transmitted(task);
+ 		return;
+ 	}
++>>>>>>> 03e51d32da99 (SUNRPC: Check whether the task was transmitted before rebind/reconnect)
  
  	dprint_status(task);
  
* Unmerged path net/sunrpc/clnt.c
