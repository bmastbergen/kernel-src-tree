RDMA/nldev: Add resource tracker doit callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit c5dfe0ea6ffa1c568b311c60266484a3316bb085
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c5dfe0ea.failed

Implement doit callbacks and ensure that users won't provide port values
on resource entry allocated in per-device mode needed for .doit callback.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit c5dfe0ea6ffa1c568b311c60266484a3316bb085)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
diff --cc drivers/infiniband/core/nldev.c
index efccd8e0fb77,0cd95f80f7b4..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -365,9 -373,8 +365,8 @@@ static int fill_res_qp_entry(struct sk_
  			     struct rdma_restrack_entry *res, uint32_t port)
  {
  	struct ib_qp *qp = container_of(res, struct ib_qp, res);
 -	struct ib_device *dev = qp->device;
 +	struct rdma_restrack_root *resroot = &qp->device->res;
  	struct ib_qp_init_attr qp_init_attr;
- 	struct nlattr *entry_attr;
  	struct ib_qp_attr qp_attr;
  	int ret;
  
@@@ -415,16 -418,12 +410,12 @@@
  	if (fill_res_name_pid(msg, res))
  		goto err;
  
 -	if (fill_res_entry(dev, msg, res))
 +	if (resroot->fill_res_entry(msg, res))
  		goto err;
  
- 	nla_nest_end(msg, entry_attr);
  	return 0;
  
- err:
- 	nla_nest_cancel(msg, entry_attr);
- out:
- 	return -EMSGSIZE;
+ err:	return -EMSGSIZE;
  }
  
  static int fill_res_cm_id_entry(struct sk_buff *msg, bool has_cap_net_admin,
@@@ -432,9 -431,8 +423,8 @@@
  {
  	struct rdma_id_private *id_priv =
  				container_of(res, struct rdma_id_private, res);
 -	struct ib_device *dev = id_priv->id.device;
 +	struct rdma_restrack_root *resroot = &id_priv->id.device->res;
  	struct rdma_cm_id *cm_id = &id_priv->id;
- 	struct nlattr *entry_attr;
  
  	if (port && port != cm_id->port_num)
  		return 0;
@@@ -474,28 -468,19 +460,28 @@@
  	if (fill_res_name_pid(msg, res))
  		goto err;
  
 -	if (fill_res_entry(dev, msg, res))
 +	if (resroot->fill_res_entry(msg, res))
  		goto err;
  
- 	nla_nest_end(msg, entry_attr);
  	return 0;
  
- err:
- 	nla_nest_cancel(msg, entry_attr);
- out:
- 	return -EMSGSIZE;
+ err: return -EMSGSIZE;
  }
  
  static int fill_res_cq_entry(struct sk_buff *msg, bool has_cap_net_admin,
  			     struct rdma_restrack_entry *res, uint32_t port)
  {
  	struct ib_cq *cq = container_of(res, struct ib_cq, res);
++<<<<<<< HEAD
 +	struct rdma_restrack_root *resroot = &cq->device->res;
 +	struct nlattr *entry_attr;
 +
 +	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_CQ_ENTRY);
 +	if (!entry_attr)
 +		goto out;
++=======
+ 	struct ib_device *dev = cq->device;
++>>>>>>> c5dfe0ea6ffa (RDMA/nldev: Add resource tracker doit callback)
  
  	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQE, cq->cqe))
  		goto err;
@@@ -511,28 -496,19 +497,28 @@@
  	if (fill_res_name_pid(msg, res))
  		goto err;
  
 -	if (fill_res_entry(dev, msg, res))
 +	if (resroot->fill_res_entry(msg, res))
  		goto err;
  
- 	nla_nest_end(msg, entry_attr);
  	return 0;
  
- err:
- 	nla_nest_cancel(msg, entry_attr);
- out:
- 	return -EMSGSIZE;
+ err:	return -EMSGSIZE;
  }
  
  static int fill_res_mr_entry(struct sk_buff *msg, bool has_cap_net_admin,
  			     struct rdma_restrack_entry *res, uint32_t port)
  {
  	struct ib_mr *mr = container_of(res, struct ib_mr, res);
++<<<<<<< HEAD
 +	struct rdma_restrack_root *resroot = &mr->pd->device->res;
 +	struct nlattr *entry_attr;
 +
 +	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_MR_ENTRY);
 +	if (!entry_attr)
 +		goto out;
++=======
+ 	struct ib_device *dev = mr->pd->device;
++>>>>>>> c5dfe0ea6ffa (RDMA/nldev: Add resource tracker doit callback)
  
  	if (has_cap_net_admin) {
  		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RKEY, mr->rkey))
@@@ -548,28 -524,19 +534,28 @@@
  	if (fill_res_name_pid(msg, res))
  		goto err;
  
 -	if (fill_res_entry(dev, msg, res))
 +	if (resroot->fill_res_entry(msg, res))
  		goto err;
  
- 	nla_nest_end(msg, entry_attr);
  	return 0;
  
- err:
- 	nla_nest_cancel(msg, entry_attr);
- out:
- 	return -EMSGSIZE;
+ err:	return -EMSGSIZE;
  }
  
  static int fill_res_pd_entry(struct sk_buff *msg, bool has_cap_net_admin,
  			     struct rdma_restrack_entry *res, uint32_t port)
  {
  	struct ib_pd *pd = container_of(res, struct ib_pd, res);
++<<<<<<< HEAD
 +	struct rdma_restrack_root *resroot = &pd->device->res;
 +	struct nlattr *entry_attr;
 +
 +	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_PD_ENTRY);
 +	if (!entry_attr)
 +		goto out;
++=======
+ 	struct ib_device *dev = pd->device;
++>>>>>>> c5dfe0ea6ffa (RDMA/nldev: Add resource tracker doit callback)
  
  	if (has_cap_net_admin) {
  		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY,
@@@ -587,16 -554,12 +573,12 @@@
  	if (fill_res_name_pid(msg, res))
  		goto err;
  
 -	if (fill_res_entry(dev, msg, res))
 +	if (resroot->fill_res_entry(msg, res))
  		goto err;
  
- 	nla_nest_end(msg, entry_attr);
  	return 0;
  
- err:
- 	nla_nest_cancel(msg, entry_attr);
- out:
- 	return -EMSGSIZE;
+ err:	return -EMSGSIZE;
  }
  
  static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,
@@@ -1038,15 -1114,15 +1127,20 @@@ static int res_get_common_dumpit(struc
  		 */
  		rdma_restrack_put(res);
  
+ 		if (ret)
+ 			nla_nest_cancel(skb, entry_attr);
  		if (ret == -EMSGSIZE)
 +			/*
 +			 * There is a chance to optimize here.
 +			 * It can be done by using list_prepare_entry
 +			 * and list_for_each_entry_continue afterwards.
 +			 */
  			break;
+ 		if (ret == -EAGAIN)
+ 			goto next;
  		if (ret)
  			goto res_err;
+ 		nla_nest_end(skb, entry_attr);
  next:		idx++;
  	}
  	up_read(&device->res.rwsem);
* Unmerged path drivers/infiniband/core/nldev.c
