IB/{rdmavt, hfi1, qib}: Add a counter for credit waits

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Kaike Wan <kaike.wan@intel.com>
commit 7199435414868bd656284349edc1a1f528fe3662
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/71994354.failed

This patch adds a counter for credit waits to assist field debugging.

Link: https://lore.kernel.org/r/20190911113047.126040.10857.stgit@awfm-01.aw.intel.com
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Kaike Wan <kaike.wan@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 7199435414868bd656284349edc1a1f528fe3662)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/rdma/rdmavt_qp.h
diff --cc include/rdma/rdmavt_qp.h
index 85544777587d,b550ae89bf85..000000000000
--- a/include/rdma/rdmavt_qp.h
+++ b/include/rdma/rdmavt_qp.h
@@@ -819,6 -926,88 +819,91 @@@ struct rvt_qp_iter 
  	int n;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * ib_cq_tail - Return tail index of cq buffer
+  * @send_cq - The cq for send
+  *
+  * This is called in qp_iter_print to get tail
+  * of cq buffer.
+  */
+ static inline u32 ib_cq_tail(struct ib_cq *send_cq)
+ {
+ 	struct rvt_cq *cq = ibcq_to_rvtcq(send_cq);
+ 
+ 	return ibcq_to_rvtcq(send_cq)->ip ?
+ 	       RDMA_READ_UAPI_ATOMIC(cq->queue->tail) :
+ 	       ibcq_to_rvtcq(send_cq)->kqueue->tail;
+ }
+ 
+ /**
+  * ib_cq_head - Return head index of cq buffer
+  * @send_cq - The cq for send
+  *
+  * This is called in qp_iter_print to get head
+  * of cq buffer.
+  */
+ static inline u32 ib_cq_head(struct ib_cq *send_cq)
+ {
+ 	struct rvt_cq *cq = ibcq_to_rvtcq(send_cq);
+ 
+ 	return ibcq_to_rvtcq(send_cq)->ip ?
+ 	       RDMA_READ_UAPI_ATOMIC(cq->queue->head) :
+ 	       ibcq_to_rvtcq(send_cq)->kqueue->head;
+ }
+ 
+ /**
+  * rvt_free_rq - free memory allocated for rvt_rq struct
+  * @rvt_rq: request queue data structure
+  *
+  * This function should only be called if the rvt_mmap_info()
+  * has not succeeded.
+  */
+ static inline void rvt_free_rq(struct rvt_rq *rq)
+ {
+ 	kvfree(rq->kwq);
+ 	rq->kwq = NULL;
+ 	vfree(rq->wq);
+ 	rq->wq = NULL;
+ }
+ 
+ /**
+  * rvt_to_iport - Get the ibport pointer
+  * @qp: the qp pointer
+  *
+  * This function returns the ibport pointer from the qp pointer.
+  */
+ static inline struct rvt_ibport *rvt_to_iport(struct rvt_qp *qp)
+ {
+ 	struct rvt_dev_info *rdi = ib_to_rvt(qp->ibqp.device);
+ 
+ 	return rdi->ports[qp->port_num - 1];
+ }
+ 
+ /**
+  * rvt_rc_credit_avail - Check if there are enough RC credits for the request
+  * @qp: the qp
+  * @wqe: the request
+  *
+  * This function returns false when there are not enough credits for the given
+  * request and true otherwise.
+  */
+ static inline bool rvt_rc_credit_avail(struct rvt_qp *qp, struct rvt_swqe *wqe)
+ {
+ 	lockdep_assert_held(&qp->s_lock);
+ 	if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT) &&
+ 	    rvt_cmp_msn(wqe->ssn, qp->s_lsn + 1) > 0) {
+ 		struct rvt_ibport *rvp = rvt_to_iport(qp);
+ 
+ 		qp->s_flags |= RVT_S_WAIT_SSN_CREDIT;
+ 		rvp->n_rc_crwaits++;
+ 		return false;
+ 	}
+ 	return true;
+ }
+ 
++>>>>>>> 719943541486 (IB/{rdmavt, hfi1, qib}: Add a counter for credit waits)
  struct rvt_qp_iter *rvt_qp_iter_init(struct rvt_dev_info *rdi,
  				     u64 v,
  				     void (*cb)(struct rvt_qp *qp, u64 v));
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index 5511edd943c3..d2fe1cbbf3b7 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -4101,6 +4101,7 @@ def_access_ibp_counter(rc_dupreq);
 def_access_ibp_counter(rdma_seq);
 def_access_ibp_counter(unaligned);
 def_access_ibp_counter(seq_naks);
+def_access_ibp_counter(rc_crwaits);
 
 static struct cntr_entry dev_cntrs[DEV_CNTR_LAST] = {
 [C_RCV_OVF] = RXE32_DEV_CNTR_ELEM(RcvOverflow, RCV_BUF_OVFL_CNT, CNTR_SYNTH),
@@ -5119,6 +5120,7 @@ static struct cntr_entry port_cntrs[PORT_CNTR_LAST] = {
 [C_SW_IBP_RDMA_SEQ] = SW_IBP_CNTR(RdmaSeq, rdma_seq),
 [C_SW_IBP_UNALIGNED] = SW_IBP_CNTR(Unaligned, unaligned),
 [C_SW_IBP_SEQ_NAK] = SW_IBP_CNTR(SeqNak, seq_naks),
+[C_SW_IBP_RC_CRWAITS] = SW_IBP_CNTR(RcCrWait, rc_crwaits),
 [C_SW_CPU_RC_ACKS] = CNTR_ELEM("RcAcks", 0, 0, CNTR_NORMAL,
 			       access_sw_cpu_rc_acks),
 [C_SW_CPU_RC_QACKS] = CNTR_ELEM("RcQacks", 0, 0, CNTR_NORMAL,
diff --git a/drivers/infiniband/hw/hfi1/chip.h b/drivers/infiniband/hw/hfi1/chip.h
index b76cf81f927f..4ca5ac8d7e9e 100644
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@ -1245,6 +1245,7 @@ enum {
 	C_SW_IBP_RDMA_SEQ,
 	C_SW_IBP_UNALIGNED,
 	C_SW_IBP_SEQ_NAK,
+	C_SW_IBP_RC_CRWAITS,
 	C_SW_CPU_RC_ACKS,
 	C_SW_CPU_RC_QACKS,
 	C_SW_CPU_RC_DELAYED_COMP,
diff --git a/drivers/infiniband/hw/hfi1/rc.c b/drivers/infiniband/hw/hfi1/rc.c
index d48c63ca1253..9c82c0cfbd21 100644
--- a/drivers/infiniband/hw/hfi1/rc.c
+++ b/drivers/infiniband/hw/hfi1/rc.c
@@ -595,11 +595,8 @@ int hfi1_make_rc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)
 		case IB_WR_SEND_WITH_IMM:
 		case IB_WR_SEND_WITH_INV:
 			/* If no credit, return. */
-			if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT) &&
-			    rvt_cmp_msn(wqe->ssn, qp->s_lsn + 1) > 0) {
-				qp->s_flags |= RVT_S_WAIT_SSN_CREDIT;
+			if (!rvt_rc_credit_avail(qp, wqe))
 				goto bail;
-			}
 			if (len > pmtu) {
 				qp->s_state = OP(SEND_FIRST);
 				len = pmtu;
@@ -632,11 +629,8 @@ int hfi1_make_rc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)
 			goto no_flow_control;
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			/* If no credit, return. */
-			if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT) &&
-			    rvt_cmp_msn(wqe->ssn, qp->s_lsn + 1) > 0) {
-				qp->s_flags |= RVT_S_WAIT_SSN_CREDIT;
+			if (!rvt_rc_credit_avail(qp, wqe))
 				goto bail;
-			}
 no_flow_control:
 			put_ib_reth_vaddr(
 				wqe->rdma_wr.remote_addr,
diff --git a/drivers/infiniband/hw/qib/qib_rc.c b/drivers/infiniband/hw/qib/qib_rc.c
index 8d9a94d6f685..48df759755f1 100644
--- a/drivers/infiniband/hw/qib/qib_rc.c
+++ b/drivers/infiniband/hw/qib/qib_rc.c
@@ -313,11 +313,8 @@ int qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)
 		case IB_WR_SEND:
 		case IB_WR_SEND_WITH_IMM:
 			/* If no credit, return. */
-			if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT) &&
-			    rvt_cmp_msn(wqe->ssn, qp->s_lsn + 1) > 0) {
-				qp->s_flags |= RVT_S_WAIT_SSN_CREDIT;
+			if (!rvt_rc_credit_avail(qp, wqe))
 				goto bail;
-			}
 			if (len > pmtu) {
 				qp->s_state = OP(SEND_FIRST);
 				len = pmtu;
@@ -344,11 +341,8 @@ int qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)
 			goto no_flow_control;
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			/* If no credit, return. */
-			if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT) &&
-			    rvt_cmp_msn(wqe->ssn, qp->s_lsn + 1) > 0) {
-				qp->s_flags |= RVT_S_WAIT_SSN_CREDIT;
+			if (!rvt_rc_credit_avail(qp, wqe))
 				goto bail;
-			}
 no_flow_control:
 			ohdr->u.rc.reth.vaddr =
 				cpu_to_be64(wqe->rdma_wr.remote_addr);
diff --git a/drivers/infiniband/hw/qib/qib_sysfs.c b/drivers/infiniband/hw/qib/qib_sysfs.c
index 905206a0c2d5..3926be78036e 100644
--- a/drivers/infiniband/hw/qib/qib_sysfs.c
+++ b/drivers/infiniband/hw/qib/qib_sysfs.c
@@ -436,6 +436,7 @@ QIB_DIAGC_ATTR(dmawait);
 QIB_DIAGC_ATTR(unaligned);
 QIB_DIAGC_ATTR(rc_dupreq);
 QIB_DIAGC_ATTR(rc_seqnak);
+QIB_DIAGC_ATTR(rc_crwaits);
 
 static struct attribute *diagc_default_attributes[] = {
 	&qib_diagc_attr_rc_resends.attr,
@@ -453,6 +454,7 @@ static struct attribute *diagc_default_attributes[] = {
 	&qib_diagc_attr_unaligned.attr,
 	&qib_diagc_attr_rc_dupreq.attr,
 	&qib_diagc_attr_rc_seqnak.attr,
+	&qib_diagc_attr_rc_crwaits.attr,
 	NULL
 };
 
diff --git a/include/rdma/rdma_vt.h b/include/rdma/rdma_vt.h
index 5572d86b7a19..387d8c5fe42e 100644
--- a/include/rdma/rdma_vt.h
+++ b/include/rdma/rdma_vt.h
@@ -116,6 +116,7 @@ struct rvt_ibport {
 	u64 n_unaligned;
 	u64 n_rc_dupreq;
 	u64 n_rc_seqnak;
+	u64 n_rc_crwaits;
 	u16 pkey_violations;
 	u16 qkey_violations;
 	u16 mkey_violations;
* Unmerged path include/rdma/rdmavt_qp.h
