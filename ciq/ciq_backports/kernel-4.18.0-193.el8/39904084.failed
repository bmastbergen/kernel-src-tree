bpf: add helper to check for a valid SYN cookie

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit 399040847084a69f345e0a52fd62f04654e0fce3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/39904084.failed

Using bpf_skc_lookup_tcp it's possible to ascertain whether a packet
belongs to a known connection. However, there is one corner case: no
sockets are created if SYN cookies are active. This means that the final
ACK in the 3WHS is misclassified.

Using the helper, we can look up the listening socket via
bpf_skc_lookup_tcp and then check whether a packet is a valid SYN
cookie ACK.

	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 399040847084a69f345e0a52fd62f04654e0fce3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	net/core/filter.c
diff --cc include/uapi/linux/bpf.h
index 86e8127cdce4,3c04410137d9..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2433,11 -2426,43 +2433,46 @@@ union bpf_attr 
   *
   * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
   *	Description
 - *		Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
 - *		**bpf_sk_release**\ () is unnecessary and not allowed.
 + *		Return a **struct bpf_sock** pointer in TCP_LISTEN state.
 + *		bpf_sk_release() is unnecessary and not allowed.
   *	Return
 - *		A **struct bpf_sock** pointer on success, or **NULL** in
 + *		A **struct bpf_sock** pointer on success, or NULL in
   *		case of failure.
++<<<<<<< HEAD
++=======
+  *
+  * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		This function is identical to bpf_sk_lookup_tcp, except that it
+  *		also returns timewait or request sockets. Use bpf_sk_fullsock
+  *		or bpf_tcp_socket to access the full structure.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from **reuse->socks**\ [] using the hash of the tuple.
+  *
+  * int bpf_tcp_check_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  * 	Description
+  * 		Check whether iph and th contain a valid SYN cookie ACK for
+  * 		the listening socket in sk.
+  *
+  * 		iph points to the start of the IPv4 or IPv6 header, while
+  * 		iph_len contains sizeof(struct iphdr) or sizeof(struct ip6hdr).
+  *
+  * 		th points to the start of the TCP header, while th_len contains
+  * 		sizeof(struct tcphdr).
+  *
+  * 	Return
+  * 		0 if iph and th are a valid SYN cookie ACK, or a negative error
+  * 		otherwise.
++>>>>>>> 399040847084 (bpf: add helper to check for a valid SYN cookie)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -2538,7 -2563,9 +2573,13 @@@
  	FN(sk_fullsock),		\
  	FN(tcp_sock),			\
  	FN(skb_ecn_set_ce),		\
++<<<<<<< HEAD
 +	FN(get_listener_sock),
++=======
+ 	FN(get_listener_sock),		\
+ 	FN(skc_lookup_tcp),		\
+ 	FN(tcp_check_syncookie),
++>>>>>>> 399040847084 (bpf: add helper to check for a valid SYN cookie)
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
   * function eBPF program intends to call
diff --cc net/core/filter.c
index 078fd98b7523,d2511fe46db3..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -5745,6 -5881,10 +5813,13 @@@ tc_cls_act_func_proto(enum bpf_func_id 
  		return &bpf_tcp_sock_proto;
  	case BPF_FUNC_get_listener_sock:
  		return &bpf_get_listener_sock_proto;
++<<<<<<< HEAD
++=======
+ 	case BPF_FUNC_skc_lookup_tcp:
+ 		return &bpf_skc_lookup_tcp_proto;
+ 	case BPF_FUNC_tcp_check_syncookie:
+ 		return &bpf_tcp_check_syncookie_proto;
++>>>>>>> 399040847084 (bpf: add helper to check for a valid SYN cookie)
  #endif
  	default:
  		return bpf_base_func_proto(func_id);
@@@ -5780,6 -5920,10 +5855,13 @@@ xdp_func_proto(enum bpf_func_id func_id
  		return &bpf_xdp_sk_lookup_tcp_proto;
  	case BPF_FUNC_sk_release:
  		return &bpf_sk_release_proto;
++<<<<<<< HEAD
++=======
+ 	case BPF_FUNC_skc_lookup_tcp:
+ 		return &bpf_xdp_skc_lookup_tcp_proto;
+ 	case BPF_FUNC_tcp_check_syncookie:
+ 		return &bpf_tcp_check_syncookie_proto;
++>>>>>>> 399040847084 (bpf: add helper to check for a valid SYN cookie)
  #endif
  	default:
  		return bpf_base_func_proto(func_id);
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path net/core/filter.c
