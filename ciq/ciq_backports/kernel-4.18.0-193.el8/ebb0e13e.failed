powerpc/ptrace: Mitigate potential Spectre v1

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [powerpc] ptrace: Mitigate potential Spectre v1 (Vladis Dronov) [1778898]
Rebuild_FUZZ: 90.24%
commit-author Breno Leitao <leitao@debian.org>
commit ebb0e13ead2ddc186a80b1b0235deeefc5a1a667
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ebb0e13e.failed

'regno' is directly controlled by user space, hence leading to a potential
exploitation of the Spectre variant 1 vulnerability.

On PTRACE_SETREGS and PTRACE_GETREGS requests, user space passes the
register number that would be read or written. This register number is
called 'regno' which is part of the 'addr' syscall parameter.

This 'regno' value is checked against the maximum pt_regs structure size,
and then used to dereference it, which matches the initial part of a
Spectre v1 (and Spectre v1.1) attack. The dereferenced value, then,
is returned to userspace in the GETREGS case.

This patch sanitizes 'regno' before using it to dereference pt_reg.

Notice that given that speculation windows are large, the policy is
to kill the speculation on the first load and not worry if it can be
completed with a dependent load/store [1].

[1] https://marc.info/?l=linux-kernel&m=152449131114778&w=2

	Signed-off-by: Breno Leitao <leitao@debian.org>
	Acked-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit ebb0e13ead2ddc186a80b1b0235deeefc5a1a667)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/ptrace.c
diff --cc arch/powerpc/kernel/ptrace.c
index 9667666eb18e,7535f89e08cd..000000000000
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@@ -297,7 -300,9 +300,13 @@@ int ptrace_get_reg(struct task_struct *
  	}
  #endif
  
++<<<<<<< HEAD
 +	if (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {
++=======
+ 	regs_max = sizeof(struct user_pt_regs) / sizeof(unsigned long);
+ 	if (regno < regs_max) {
+ 		regno = array_index_nospec(regno, regs_max);
++>>>>>>> ebb0e13ead2d (powerpc/ptrace: Mitigate potential Spectre v1)
  		*data = ((unsigned long *)task->thread.regs)[regno];
  		return 0;
  	}
* Unmerged path arch/powerpc/kernel/ptrace.c
