s390/qeth: don't keep statistics for tx timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 333ef9d1d5fb68b5f53c5f7f3ceafb65a8a6ff7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/333ef9d1.failed

struct netdev_queue contains a counter for tx timeouts, which gets
updated by dev_watchdog(). So let's not attempt to maintain our own
statistics, in particular not by overloading the skb-error counter.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 333ef9d1d5fb68b5f53c5f7f3ceafb65a8a6ff7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core.h
index 3f448d239de7,730930135aba..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -472,6 -445,47 +472,50 @@@ enum qeth_out_q_states 
         QETH_OUT_Q_LOCKED_FLUSH,
  };
  
++<<<<<<< HEAD
++=======
+ #define QETH_CARD_STAT_ADD(_c, _stat, _val)	((_c)->stats._stat += (_val))
+ #define QETH_CARD_STAT_INC(_c, _stat)		QETH_CARD_STAT_ADD(_c, _stat, 1)
+ 
+ #define QETH_TXQ_STAT_ADD(_q, _stat, _val)	((_q)->stats._stat += (_val))
+ #define QETH_TXQ_STAT_INC(_q, _stat)		QETH_TXQ_STAT_ADD(_q, _stat, 1)
+ 
+ struct qeth_card_stats {
+ 	u64 rx_bufs;
+ 	u64 rx_skb_csum;
+ 	u64 rx_sg_skbs;
+ 	u64 rx_sg_frags;
+ 	u64 rx_sg_alloc_page;
+ 
+ 	/* rtnl_link_stats64 */
+ 	u64 rx_packets;
+ 	u64 rx_bytes;
+ 	u64 rx_errors;
+ 	u64 rx_dropped;
+ 	u64 rx_multicast;
+ };
+ 
+ struct qeth_out_q_stats {
+ 	u64 bufs;
+ 	u64 bufs_pack;
+ 	u64 buf_elements;
+ 	u64 skbs_pack;
+ 	u64 skbs_sg;
+ 	u64 skbs_csum;
+ 	u64 skbs_tso;
+ 	u64 skbs_linearized;
+ 	u64 skbs_linearized_fail;
+ 	u64 tso_bytes;
+ 	u64 packing_mode_switch;
+ 
+ 	/* rtnl_link_stats64 */
+ 	u64 tx_packets;
+ 	u64 tx_bytes;
+ 	u64 tx_errors;
+ 	u64 tx_dropped;
+ };
+ 
++>>>>>>> 333ef9d1d5fb (s390/qeth: don't keep statistics for tx timeout)
  struct qeth_qdio_out_q {
  	struct qdio_buffer *qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];
  	struct qeth_qdio_out_buffer *bufs[QDIO_MAX_BUFFERS_PER_Q];
diff --cc drivers/s390/net/qeth_core_main.c
index 67e5e3d26068,09ed9e04f4ca..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4372,7 -4340,6 +4372,10 @@@ void qeth_tx_timeout(struct net_device 
  
  	card = dev->ml_priv;
  	QETH_CARD_TEXT(card, 4, "txtimeo");
++<<<<<<< HEAD
 +	card->stats.tx_errors++;
++=======
++>>>>>>> 333ef9d1d5fb (s390/qeth: don't keep statistics for tx timeout)
  	qeth_schedule_recovery(card);
  }
  EXPORT_SYMBOL_GPL(qeth_tx_timeout);
@@@ -6211,6 -6178,31 +6214,34 @@@ netdev_features_t qeth_features_check(s
  }
  EXPORT_SYMBOL_GPL(qeth_features_check);
  
++<<<<<<< HEAD
++=======
+ void qeth_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+ {
+ 	struct qeth_card *card = dev->ml_priv;
+ 	struct qeth_qdio_out_q *queue;
+ 	unsigned int i;
+ 
+ 	QETH_CARD_TEXT(card, 5, "getstat");
+ 
+ 	stats->rx_packets = card->stats.rx_packets;
+ 	stats->rx_bytes = card->stats.rx_bytes;
+ 	stats->rx_errors = card->stats.rx_errors;
+ 	stats->rx_dropped = card->stats.rx_dropped;
+ 	stats->multicast = card->stats.rx_multicast;
+ 
+ 	for (i = 0; i < card->qdio.no_out_queues; i++) {
+ 		queue = card->qdio.out_qs[i];
+ 
+ 		stats->tx_packets += queue->stats.tx_packets;
+ 		stats->tx_bytes += queue->stats.tx_bytes;
+ 		stats->tx_errors += queue->stats.tx_errors;
+ 		stats->tx_dropped += queue->stats.tx_dropped;
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(qeth_get_stats64);
+ 
++>>>>>>> 333ef9d1d5fb (s390/qeth: don't keep statistics for tx timeout)
  int qeth_open(struct net_device *dev)
  {
  	struct qeth_card *card = dev->ml_priv;
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
