ACPI: no need to check return value of debugfs_create functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 9ec6dbfbdc0ade855e6bc1da66e263e0d926697c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9ec6dbfb.failed

When calling debugfs functions, there is no need to ever check the
return value.  The function can work or not, but the code logic should
never do something different based on this.

	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 9ec6dbfbdc0ade855e6bc1da66e263e0d926697c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/apei/einj.c
diff --cc drivers/acpi/apei/einj.c
index 6119da1aea4e,c42299e048e4..000000000000
--- a/drivers/acpi/apei/einj.c
+++ b/drivers/acpi/apei/einj.c
@@@ -706,27 -706,13 +705,32 @@@ static int __init einj_init(void
  
  	rc = -ENOMEM;
  	einj_debug_dir = debugfs_create_dir("einj", apei_get_debugfs_dir());
- 	if (!einj_debug_dir) {
- 		pr_err("Error creating debugfs node.\n");
- 		goto err_cleanup;
- 	}
  
++<<<<<<< HEAD
 +	fentry = debugfs_create_file("available_error_type", S_IRUSR,
 +				     einj_debug_dir, NULL,
 +				     &available_error_type_fops);
 +	if (!fentry)
 +		goto err_cleanup;
 +
 +	fentry = debugfs_create_file_unsafe("error_type", 0600,
 +					    einj_debug_dir, NULL,
 +					    &error_type_fops);
 +	if (!fentry)
 +		goto err_cleanup;
 +	fentry = debugfs_create_file_unsafe("error_inject", 0200,
 +					    einj_debug_dir, NULL,
 +					    &error_inject_fops);
 +	if (!fentry)
 +		goto err_cleanup;
++=======
+ 	debugfs_create_file("available_error_type", S_IRUSR, einj_debug_dir,
+ 			    NULL, &available_error_type_fops);
+ 	debugfs_create_file("error_type", S_IRUSR | S_IWUSR, einj_debug_dir,
+ 			    NULL, &error_type_fops);
+ 	debugfs_create_file("error_inject", S_IWUSR, einj_debug_dir,
+ 			    NULL, &error_inject_fops);
++>>>>>>> 9ec6dbfbdc0a (ACPI: no need to check return value of debugfs_create functions)
  
  	apei_resources_init(&einj_resources);
  	einj_exec_ctx_init(&ctx);
diff --git a/drivers/acpi/acpi_dbg.c b/drivers/acpi/acpi_dbg.c
index a2dcd62ea32f..f3bca448b305 100644
--- a/drivers/acpi/acpi_dbg.c
+++ b/drivers/acpi/acpi_dbg.c
@@ -752,11 +752,6 @@ int __init acpi_aml_init(void)
 {
 	int ret = 0;
 
-	if (!acpi_debugfs_dir) {
-		ret = -ENOENT;
-		goto err_exit;
-	}
-
 	/* Initialize AML IO interface */
 	mutex_init(&acpi_aml_io.lock);
 	init_waitqueue_head(&acpi_aml_io.wait);
@@ -766,10 +761,6 @@ int __init acpi_aml_init(void)
 					      S_IFREG | S_IRUGO | S_IWUSR,
 					      acpi_debugfs_dir, NULL,
 					      &acpi_aml_operations);
-	if (acpi_aml_dentry == NULL) {
-		ret = -ENODEV;
-		goto err_exit;
-	}
 	ret = acpi_register_debugger(THIS_MODULE, &acpi_aml_debugger);
 	if (ret)
 		goto err_fs;
@@ -788,10 +779,8 @@ void __exit acpi_aml_exit(void)
 {
 	if (acpi_aml_initialized) {
 		acpi_unregister_debugger(&acpi_aml_debugger);
-		if (acpi_aml_dentry) {
-			debugfs_remove(acpi_aml_dentry);
-			acpi_aml_dentry = NULL;
-		}
+		debugfs_remove(acpi_aml_dentry);
+		acpi_aml_dentry = NULL;
 		acpi_aml_initialized = false;
 	}
 }
* Unmerged path drivers/acpi/apei/einj.c
diff --git a/drivers/acpi/custom_method.c b/drivers/acpi/custom_method.c
index ac8a90dc7096..af1d161f188f 100644
--- a/drivers/acpi/custom_method.c
+++ b/drivers/acpi/custom_method.c
@@ -82,14 +82,8 @@ static const struct file_operations cm_fops = {
 
 static int __init acpi_custom_method_init(void)
 {
-	if (acpi_debugfs_dir == NULL)
-		return -ENOENT;
-
 	cm_dentry = debugfs_create_file("custom_method", S_IWUSR,
 					acpi_debugfs_dir, NULL, &cm_fops);
-	if (cm_dentry == NULL)
-		return -ENODEV;
-
 	return 0;
 }
 
diff --git a/drivers/acpi/ec_sys.c b/drivers/acpi/ec_sys.c
index dd70d6c2bca0..23faa66ea772 100644
--- a/drivers/acpi/ec_sys.c
+++ b/drivers/acpi/ec_sys.c
@@ -108,52 +108,32 @@ static const struct file_operations acpi_ec_io_ops = {
 	.llseek = default_llseek,
 };
 
-static int acpi_ec_add_debugfs(struct acpi_ec *ec, unsigned int ec_device_count)
+static void acpi_ec_add_debugfs(struct acpi_ec *ec, unsigned int ec_device_count)
 {
 	struct dentry *dev_dir;
 	char name[64];
 	umode_t mode = 0400;
 
-	if (ec_device_count == 0) {
+	if (ec_device_count == 0)
 		acpi_ec_debugfs_dir = debugfs_create_dir("ec", NULL);
-		if (!acpi_ec_debugfs_dir)
-			return -ENOMEM;
-	}
 
 	sprintf(name, "ec%u", ec_device_count);
 	dev_dir = debugfs_create_dir(name, acpi_ec_debugfs_dir);
-	if (!dev_dir) {
-		if (ec_device_count != 0)
-			goto error;
-		return -ENOMEM;
-	}
 
-	if (!debugfs_create_x32("gpe", 0444, dev_dir, &first_ec->gpe))
-		goto error;
-	if (!debugfs_create_bool("use_global_lock", 0444, dev_dir,
-				 &first_ec->global_lock))
-		goto error;
+	debugfs_create_x32("gpe", 0444, dev_dir, &first_ec->gpe);
+	debugfs_create_bool("use_global_lock", 0444, dev_dir,
+			    &first_ec->global_lock);
 
 	if (write_support)
 		mode = 0600;
-	if (!debugfs_create_file("io", mode, dev_dir, ec, &acpi_ec_io_ops))
-		goto error;
-
-	return 0;
-
-error:
-	debugfs_remove_recursive(acpi_ec_debugfs_dir);
-	return -ENOMEM;
+	debugfs_create_file("io", mode, dev_dir, ec, &acpi_ec_io_ops);
 }
 
 static int __init acpi_ec_sys_init(void)
 {
-	int err = 0;
 	if (first_ec)
-		err = acpi_ec_add_debugfs(first_ec, 0);
-	else
-		err = -ENODEV;
-	return err;
+		acpi_ec_add_debugfs(first_ec, 0);
+	return 0;
 }
 
 static void __exit acpi_ec_sys_exit(void)
