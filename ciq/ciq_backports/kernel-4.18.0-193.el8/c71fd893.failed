locking/rwsem: Make owner available even if !CONFIG_RWSEM_SPIN_ON_OWNER

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Waiman Long <longman@redhat.com>
commit c71fd893f614f205dbc050d60299cc5496491c19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c71fd893.failed

The owner field in the rw_semaphore structure is used primarily for
optimistic spinning. However, identifying the rwsem owner can also be
helpful in debugging as well as tracing locking related issues when
analyzing crash dump. The owner field may also store state information
that can be important to the operation of the rwsem.

So the owner field is now made a permanent member of the rw_semaphore
structure irrespective of CONFIG_RWSEM_SPIN_ON_OWNER.

	Signed-off-by: Waiman Long <longman@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: huang ying <huang.ying.caritas@gmail.com>
Link: https://lkml.kernel.org/r/20190520205918.22251-2-longman@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c71fd893f614f205dbc050d60299cc5496491c19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rwsem.h
diff --cc include/linux/rwsem.h
index b44e533235c7,148983e21d47..000000000000
--- a/include/linux/rwsem.h
+++ b/include/linux/rwsem.h
@@@ -20,21 -20,30 +20,29 @@@
  #include <linux/osq_lock.h>
  #endif
  
 -/*
 - * For an uncontended rwsem, count and owner are the only fields a task
 - * needs to touch when acquiring the rwsem. So they are put next to each
 - * other to increase the chance that they will share the same cacheline.
 - *
 - * In a contended rwsem, the owner is likely the most frequently accessed
 - * field in the structure as the optimistic waiter that holds the osq lock
 - * will spin on owner. For an embedded rwsem, other hot fields in the
 - * containing structure should be moved further away from the rwsem to
 - * reduce the chance that they will share the same cacheline causing
 - * cacheline bouncing problem.
 - */
 +struct rw_semaphore;
 +
 +/* All arch specific implementations share the same struct */
  struct rw_semaphore {
  	atomic_long_t count;
++<<<<<<< HEAD
 +	struct list_head wait_list;
 +	raw_spinlock_t wait_lock;
 +#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
 +	struct optimistic_spin_queue osq; /* spinner MCS lock */
++=======
++>>>>>>> c71fd893f614 (locking/rwsem: Make owner available even if !CONFIG_RWSEM_SPIN_ON_OWNER)
  	/*
- 	 * Write owner. Used as a speculative check to see
- 	 * if the owner is running on the cpu.
+ 	 * Write owner or one of the read owners. Can be used as a
+ 	 * speculative check to see if the owner is running on the cpu.
  	 */
  	struct task_struct *owner;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_RWSEM_SPIN_ON_OWNER
+ 	struct optimistic_spin_queue osq; /* spinner MCS lock */
++>>>>>>> c71fd893f614 (locking/rwsem: Make owner available even if !CONFIG_RWSEM_SPIN_ON_OWNER)
  #endif
 -	raw_spinlock_t wait_lock;
 -	struct list_head wait_list;
  #ifdef CONFIG_DEBUG_LOCK_ALLOC
  	struct lockdep_map	dep_map;
  #endif
* Unmerged path include/linux/rwsem.h
diff --git a/kernel/locking/rwsem-xadd.c b/kernel/locking/rwsem-xadd.c
index 397dedc58432..9d44c32fb664 100644
--- a/kernel/locking/rwsem-xadd.c
+++ b/kernel/locking/rwsem-xadd.c
@@ -86,8 +86,8 @@ void __init_rwsem(struct rw_semaphore *sem, const char *name,
 	atomic_long_set(&sem->count, RWSEM_UNLOCKED_VALUE);
 	raw_spin_lock_init(&sem->wait_lock);
 	INIT_LIST_HEAD(&sem->wait_list);
-#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
 	sem->owner = NULL;
+#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
 	osq_lock_init(&sem->osq);
 #endif
 }
diff --git a/kernel/locking/rwsem.h b/kernel/locking/rwsem.h
index 64877f5294e3..eb9c8534299b 100644
--- a/kernel/locking/rwsem.h
+++ b/kernel/locking/rwsem.h
@@ -61,7 +61,6 @@
 #define RWSEM_ACTIVE_READ_BIAS		RWSEM_ACTIVE_BIAS
 #define RWSEM_ACTIVE_WRITE_BIAS		(RWSEM_WAITING_BIAS + RWSEM_ACTIVE_BIAS)
 
-#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
 /*
  * All writes to owner are protected by WRITE_ONCE() to make sure that
  * store tearing can't happen as optimistic spinners may read and use
@@ -126,7 +125,6 @@ static inline bool rwsem_has_anonymous_owner(struct task_struct *owner)
  * real owner or one of the real owners. The only exception is when the
  * unlock is done by up_read_non_owner().
  */
-#define rwsem_clear_reader_owned rwsem_clear_reader_owned
 static inline void rwsem_clear_reader_owned(struct rw_semaphore *sem)
 {
 	unsigned long val = (unsigned long)current | RWSEM_READER_OWNED
@@ -135,28 +133,7 @@ static inline void rwsem_clear_reader_owned(struct rw_semaphore *sem)
 		cmpxchg_relaxed((unsigned long *)&sem->owner, val,
 				RWSEM_READER_OWNED | RWSEM_ANONYMOUSLY_OWNED);
 }
-#endif
-
 #else
-static inline void rwsem_set_owner(struct rw_semaphore *sem)
-{
-}
-
-static inline void rwsem_clear_owner(struct rw_semaphore *sem)
-{
-}
-
-static inline void __rwsem_set_reader_owned(struct rw_semaphore *sem,
-					   struct task_struct *owner)
-{
-}
-
-static inline void rwsem_set_reader_owned(struct rw_semaphore *sem)
-{
-}
-#endif
-
-#ifndef rwsem_clear_reader_owned
 static inline void rwsem_clear_reader_owned(struct rw_semaphore *sem)
 {
 }
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index e75d8d876da6..0ba9aa9aeaae 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1057,7 +1057,7 @@ config PROVE_LOCKING
 	select DEBUG_SPINLOCK
 	select DEBUG_MUTEXES
 	select DEBUG_RT_MUTEXES if RT_MUTEXES
-	select DEBUG_RWSEMS if RWSEM_SPIN_ON_OWNER
+	select DEBUG_RWSEMS
 	select DEBUG_WW_MUTEX_SLOWPATH
 	select DEBUG_LOCK_ALLOC
 	select TRACE_IRQFLAGS
@@ -1161,10 +1161,10 @@ config DEBUG_WW_MUTEX_SLOWPATH
 
 config DEBUG_RWSEMS
 	bool "RW Semaphore debugging: basic checks"
-	depends on DEBUG_KERNEL && RWSEM_SPIN_ON_OWNER
+	depends on DEBUG_KERNEL
 	help
-	  This debugging feature allows mismatched rw semaphore locks and unlocks
-	  to be detected and reported.
+	  This debugging feature allows mismatched rw semaphore locks
+	  and unlocks to be detected and reported.
 
 config DEBUG_LOCK_ALLOC
 	bool "Lock debugging: detect incorrect freeing of live locks"
