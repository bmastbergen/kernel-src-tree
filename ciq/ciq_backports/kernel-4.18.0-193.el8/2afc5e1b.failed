IB/mlx5: Introduce MLX5_IB_OBJECT_DEVX_ASYNC_EVENT_FD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 2afc5e1b9c340ff20848c8dd8fb60342617bce52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2afc5e1b.failed

Introduce MLX5_IB_OBJECT_DEVX_ASYNC_EVENT_FD and its initial
implementation.

This object is from type class FD and will be used to read DEVX
async events.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 2afc5e1b9c340ff20848c8dd8fb60342617bce52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	include/uapi/rdma/mlx5_user_ioctl_verbs.h
diff --cc drivers/infiniband/hw/mlx5/devx.c
index b9841ad6052e,ed01523f0f02..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -22,6 -23,27 +22,30 @@@ enum devx_obj_flags 
  	DEVX_OBJ_FLAGS_DCT = 1 << 1,
  };
  
++<<<<<<< HEAD
++=======
+ struct devx_async_data {
+ 	struct mlx5_ib_dev *mdev;
+ 	struct list_head list;
+ 	struct ib_uobject *fd_uobj;
+ 	struct mlx5_async_work cb_work;
+ 	u16 cmd_out_len;
+ 	/* must be last field in this structure */
+ 	struct mlx5_ib_uapi_devx_async_cmd_hdr hdr;
+ };
+ 
+ struct devx_async_event_file {
+ 	struct ib_uobject uobj;
+ 	/* Head of events that are subscribed to this FD */
+ 	struct list_head subscribed_events_list;
+ 	spinlock_t lock;
+ 	wait_queue_head_t poll_wait;
+ 	struct list_head event_list;
+ 	struct mlx5_ib_dev *dev;
+ 	u8 omit_data:1;
+ };
+ 
++>>>>>>> 2afc5e1b9c34 (IB/mlx5: Introduce MLX5_IB_OBJECT_DEVX_ASYNC_EVENT_FD)
  #define MLX5_MAX_DESTROY_INBOX_SIZE_DW MLX5_ST_SZ_DW(delete_fte_in)
  struct devx_obj {
  	struct mlx5_core_dev	*mdev;
@@@ -1341,6 -1375,147 +1365,149 @@@ static int UVERBS_HANDLER(MLX5_IB_METHO
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_ASYNC_EVENT_FD_ALLOC)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(
+ 		attrs, MLX5_IB_ATTR_DEVX_ASYNC_EVENT_FD_ALLOC_HANDLE);
+ 	struct devx_async_event_file *ev_file;
+ 	struct mlx5_ib_ucontext *c = rdma_udata_to_drv_context(
+ 		&attrs->driver_udata, struct mlx5_ib_ucontext, ibucontext);
+ 	struct mlx5_ib_dev *dev = to_mdev(c->ibucontext.device);
+ 	u32 flags;
+ 	int err;
+ 
+ 	err = uverbs_get_flags32(&flags, attrs,
+ 		MLX5_IB_ATTR_DEVX_ASYNC_EVENT_FD_ALLOC_FLAGS,
+ 		MLX5_IB_UAPI_DEVX_CR_EV_CH_FLAGS_OMIT_DATA);
+ 
+ 	if (err)
+ 		return err;
+ 
+ 	ev_file = container_of(uobj, struct devx_async_event_file,
+ 			       uobj);
+ 	spin_lock_init(&ev_file->lock);
+ 	INIT_LIST_HEAD(&ev_file->event_list);
+ 	init_waitqueue_head(&ev_file->poll_wait);
+ 	if (flags & MLX5_IB_UAPI_DEVX_CR_EV_CH_FLAGS_OMIT_DATA)
+ 		ev_file->omit_data = 1;
+ 	INIT_LIST_HEAD(&ev_file->subscribed_events_list);
+ 	ev_file->dev = dev;
+ 	return 0;
+ }
+ 
+ static void devx_query_callback(int status, struct mlx5_async_work *context)
+ {
+ 	struct devx_async_data *async_data =
+ 		container_of(context, struct devx_async_data, cb_work);
+ 	struct ib_uobject *fd_uobj = async_data->fd_uobj;
+ 	struct devx_async_cmd_event_file *ev_file;
+ 	struct devx_async_event_queue *ev_queue;
+ 	unsigned long flags;
+ 
+ 	ev_file = container_of(fd_uobj, struct devx_async_cmd_event_file,
+ 			       uobj);
+ 	ev_queue = &ev_file->ev_queue;
+ 
+ 	spin_lock_irqsave(&ev_queue->lock, flags);
+ 	list_add_tail(&async_data->list, &ev_queue->event_list);
+ 	spin_unlock_irqrestore(&ev_queue->lock, flags);
+ 
+ 	wake_up_interruptible(&ev_queue->poll_wait);
+ 	fput(fd_uobj->object);
+ }
+ 
+ #define MAX_ASYNC_BYTES_IN_USE (1024 * 1024) /* 1MB */
+ 
+ static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_ASYNC_QUERY)(
+ 	struct uverbs_attr_bundle *attrs)
+ {
+ 	void *cmd_in = uverbs_attr_get_alloced_ptr(attrs,
+ 				MLX5_IB_ATTR_DEVX_OBJ_QUERY_ASYNC_CMD_IN);
+ 	struct ib_uobject *uobj = uverbs_attr_get_uobject(
+ 				attrs,
+ 				MLX5_IB_ATTR_DEVX_OBJ_QUERY_ASYNC_HANDLE);
+ 	u16 cmd_out_len;
+ 	struct mlx5_ib_ucontext *c = rdma_udata_to_drv_context(
+ 		&attrs->driver_udata, struct mlx5_ib_ucontext, ibucontext);
+ 	struct ib_uobject *fd_uobj;
+ 	int err;
+ 	int uid;
+ 	struct mlx5_ib_dev *mdev = to_mdev(c->ibucontext.device);
+ 	struct devx_async_cmd_event_file *ev_file;
+ 	struct devx_async_data *async_data;
+ 
+ 	uid = devx_get_uid(c, cmd_in);
+ 	if (uid < 0)
+ 		return uid;
+ 
+ 	if (!devx_is_obj_query_cmd(cmd_in))
+ 		return -EINVAL;
+ 
+ 	err = uverbs_get_const(&cmd_out_len, attrs,
+ 			       MLX5_IB_ATTR_DEVX_OBJ_QUERY_ASYNC_OUT_LEN);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!devx_is_valid_obj_id(attrs, uobj, cmd_in))
+ 		return -EINVAL;
+ 
+ 	fd_uobj = uverbs_attr_get_uobject(attrs,
+ 				MLX5_IB_ATTR_DEVX_OBJ_QUERY_ASYNC_FD);
+ 	if (IS_ERR(fd_uobj))
+ 		return PTR_ERR(fd_uobj);
+ 
+ 	ev_file = container_of(fd_uobj, struct devx_async_cmd_event_file,
+ 			       uobj);
+ 
+ 	if (atomic_add_return(cmd_out_len, &ev_file->ev_queue.bytes_in_use) >
+ 			MAX_ASYNC_BYTES_IN_USE) {
+ 		atomic_sub(cmd_out_len, &ev_file->ev_queue.bytes_in_use);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	async_data = kvzalloc(struct_size(async_data, hdr.out_data,
+ 					  cmd_out_len), GFP_KERNEL);
+ 	if (!async_data) {
+ 		err = -ENOMEM;
+ 		goto sub_bytes;
+ 	}
+ 
+ 	err = uverbs_copy_from(&async_data->hdr.wr_id, attrs,
+ 			       MLX5_IB_ATTR_DEVX_OBJ_QUERY_ASYNC_WR_ID);
+ 	if (err)
+ 		goto free_async;
+ 
+ 	async_data->cmd_out_len = cmd_out_len;
+ 	async_data->mdev = mdev;
+ 	async_data->fd_uobj = fd_uobj;
+ 
+ 	get_file(fd_uobj->object);
+ 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, uid);
+ 	err = mlx5_cmd_exec_cb(&ev_file->async_ctx, cmd_in,
+ 		    uverbs_attr_get_len(attrs,
+ 				MLX5_IB_ATTR_DEVX_OBJ_QUERY_ASYNC_CMD_IN),
+ 		    async_data->hdr.out_data,
+ 		    async_data->cmd_out_len,
+ 		    devx_query_callback, &async_data->cb_work);
+ 
+ 	if (err)
+ 		goto cb_err;
+ 
+ 	return 0;
+ 
+ cb_err:
+ 	fput(fd_uobj->object);
+ free_async:
+ 	kvfree(async_data);
+ sub_bytes:
+ 	atomic_sub(cmd_out_len, &ev_file->ev_queue.bytes_in_use);
+ 	return err;
+ }
+ 
++>>>>>>> 2afc5e1b9c34 (IB/mlx5: Introduce MLX5_IB_OBJECT_DEVX_ASYNC_EVENT_FD)
  static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
  			 struct uverbs_attr_bundle *attrs,
  			 struct devx_umem *obj)
diff --cc include/uapi/rdma/mlx5_user_ioctl_verbs.h
index 173ec938ff3a,b44691315d39..000000000000
--- a/include/uapi/rdma/mlx5_user_ioctl_verbs.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_verbs.h
@@@ -52,5 -52,20 +52,23 @@@ enum mlx5_ib_uapi_flow_action_packet_re
  	MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L3_TUNNEL = 0x3,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ib_uapi_devx_async_cmd_hdr {
+ 	__aligned_u64	wr_id;
+ 	__u8		out_data[];
+ };
+ 
+ enum mlx5_ib_uapi_dm_type {
+ 	MLX5_IB_UAPI_DM_TYPE_MEMIC,
+ 	MLX5_IB_UAPI_DM_TYPE_STEERING_SW_ICM,
+ 	MLX5_IB_UAPI_DM_TYPE_HEADER_MODIFY_SW_ICM,
+ };
+ 
+ enum mlx5_ib_uapi_devx_create_event_channel_flags {
+ 	MLX5_IB_UAPI_DEVX_CR_EV_CH_FLAGS_OMIT_DATA = 1 << 0,
+ };
+ 
++>>>>>>> 2afc5e1b9c34 (IB/mlx5: Introduce MLX5_IB_OBJECT_DEVX_ASYNC_EVENT_FD)
  #endif
  
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
diff --git a/include/uapi/rdma/mlx5_user_ioctl_cmds.h b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
index 1a1890885f56..1e31cb30565f 100644
--- a/include/uapi/rdma/mlx5_user_ioctl_cmds.h
+++ b/include/uapi/rdma/mlx5_user_ioctl_cmds.h
@@ -117,16 +117,26 @@ enum mlx5_ib_devx_async_cmd_fd_alloc_attrs {
 	MLX5_IB_ATTR_DEVX_ASYNC_CMD_FD_ALLOC_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
 };
 
+enum mlx5_ib_devx_async_event_fd_alloc_attrs {
+	MLX5_IB_ATTR_DEVX_ASYNC_EVENT_FD_ALLOC_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+	MLX5_IB_ATTR_DEVX_ASYNC_EVENT_FD_ALLOC_FLAGS,
+};
+
 enum mlx5_ib_devx_async_cmd_fd_methods {
 	MLX5_IB_METHOD_DEVX_ASYNC_CMD_FD_ALLOC = (1U << UVERBS_ID_NS_SHIFT),
 };
 
+enum mlx5_ib_devx_async_event_fd_methods {
+	MLX5_IB_METHOD_DEVX_ASYNC_EVENT_FD_ALLOC = (1U << UVERBS_ID_NS_SHIFT),
+};
+
 enum mlx5_ib_objects {
 	MLX5_IB_OBJECT_DEVX = (1U << UVERBS_ID_NS_SHIFT),
 	MLX5_IB_OBJECT_DEVX_OBJ,
 	MLX5_IB_OBJECT_DEVX_UMEM,
 	MLX5_IB_OBJECT_FLOW_MATCHER,
 	MLX5_IB_OBJECT_DEVX_ASYNC_CMD_FD,
+	MLX5_IB_OBJECT_DEVX_ASYNC_EVENT_FD,
 };
 
 enum mlx5_ib_flow_matcher_create_attrs {
* Unmerged path include/uapi/rdma/mlx5_user_ioctl_verbs.h
