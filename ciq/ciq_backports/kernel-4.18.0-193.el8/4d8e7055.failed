fsnotify: fix unlink performance regression

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Amir Goldstein <amir73il@gmail.com>
commit 4d8e7055a4058ee191296699803c5090e14f0dff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4d8e7055.failed

__fsnotify_parent() has an optimization in place to avoid unneeded
take_dentry_name_snapshot().  When fsnotify_nameremove() was changed
not to call __fsnotify_parent(), we left out the optimization.
Kernel test robot reported a 5% performance regression in concurrent
unlink() workload.

	Reported-by: kernel test robot <rong.a.chen@intel.com>
Link: https://lore.kernel.org/lkml/20190505062153.GG29809@shao2-debian/
Link: https://lore.kernel.org/linux-fsdevel/20190104090357.GD22409@quack2.suse.cz/
Fixes: 5f02a8776384 ("fsnotify: annotate directory entry modification events")
CC: stable@vger.kernel.org
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 4d8e7055a4058ee191296699803c5090e14f0dff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fsnotify.h
#	include/linux/fsnotify_backend.h
diff --cc include/linux/fsnotify.h
index 0c0ef3078a22,e30d6132c633..000000000000
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@@ -152,39 -152,6 +152,42 @@@ static inline void fsnotify_vfsmount_de
  }
  
  /*
++<<<<<<< HEAD
 + * fsnotify_nameremove - a filename was removed from a directory
 + *
 + * This is mostly called under parent vfs inode lock so name and
 + * dentry->d_parent should be stable. However there are some corner cases where
 + * inode lock is not held. So to be on the safe side and be reselient to future
 + * callers and out of tree users of d_delete(), we do not assume that d_parent
 + * and d_name are stable and we use dget_parent() and
 + * take_dentry_name_snapshot() to grab stable references.
 + */
 +static inline void fsnotify_nameremove(struct dentry *dentry, int isdir)
 +{
 +	struct dentry *parent;
 +	struct name_snapshot name;
 +	__u32 mask = FS_DELETE;
 +
 +	/* d_delete() of pseudo inode? (e.g. __ns_get_path() playing tricks) */
 +	if (IS_ROOT(dentry))
 +		return;
 +
 +	if (isdir)
 +		mask |= FS_ISDIR;
 +
 +	parent = dget_parent(dentry);
 +	take_dentry_name_snapshot(&name, dentry);
 +
 +	fsnotify(d_inode(parent), mask, d_inode(dentry), FSNOTIFY_EVENT_INODE,
 +		 &name.name, 0);
 +
 +	release_dentry_name_snapshot(&name);
 +	dput(parent);
 +}
 +
 +/*
++=======
++>>>>>>> 4d8e7055a405 (fsnotify: fix unlink performance regression)
   * fsnotify_inoderemove - an inode is going away
   */
  static inline void fsnotify_inoderemove(struct inode *inode)
diff --cc include/linux/fsnotify_backend.h
index 6f35323113ce,094b38f2d9a1..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -345,6 -354,8 +345,11 @@@ extern int fsnotify(struct inode *to_te
  extern int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask);
  extern void __fsnotify_inode_delete(struct inode *inode);
  extern void __fsnotify_vfsmount_delete(struct vfsmount *mnt);
++<<<<<<< HEAD
++=======
+ extern void fsnotify_sb_delete(struct super_block *sb);
+ extern void fsnotify_nameremove(struct dentry *dentry, int isdir);
++>>>>>>> 4d8e7055a405 (fsnotify: fix unlink performance regression)
  extern u32 fsnotify_get_cookie(void);
  
  static inline int fsnotify_inode_watches_children(struct inode *inode)
@@@ -494,6 -522,12 +499,15 @@@ static inline void __fsnotify_inode_del
  static inline void __fsnotify_vfsmount_delete(struct vfsmount *mnt)
  {}
  
++<<<<<<< HEAD
++=======
+ static inline void fsnotify_sb_delete(struct super_block *sb)
+ {}
+ 
+ static inline void fsnotify_nameremove(struct dentry *dentry, int isdir)
+ {}
+ 
++>>>>>>> 4d8e7055a405 (fsnotify: fix unlink performance regression)
  static inline void fsnotify_update_flags(struct dentry *dentry)
  {}
  
diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.c
index c0d1562fefa3..22899b53462a 100644
--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@ -101,6 +101,47 @@ void fsnotify_unmount_inodes(struct super_block *sb)
 		       !atomic_long_read(&sb->s_fsnotify_inode_refs));
 }
 
+/*
+ * fsnotify_nameremove - a filename was removed from a directory
+ *
+ * This is mostly called under parent vfs inode lock so name and
+ * dentry->d_parent should be stable. However there are some corner cases where
+ * inode lock is not held. So to be on the safe side and be reselient to future
+ * callers and out of tree users of d_delete(), we do not assume that d_parent
+ * and d_name are stable and we use dget_parent() and
+ * take_dentry_name_snapshot() to grab stable references.
+ */
+void fsnotify_nameremove(struct dentry *dentry, int isdir)
+{
+	struct dentry *parent;
+	struct name_snapshot name;
+	__u32 mask = FS_DELETE;
+
+	/* d_delete() of pseudo inode? (e.g. __ns_get_path() playing tricks) */
+	if (IS_ROOT(dentry))
+		return;
+
+	if (isdir)
+		mask |= FS_ISDIR;
+
+	parent = dget_parent(dentry);
+	/* Avoid unneeded take_dentry_name_snapshot() */
+	if (!(d_inode(parent)->i_fsnotify_mask & FS_DELETE) &&
+	    !(dentry->d_sb->s_fsnotify_mask & FS_DELETE))
+		goto out_dput;
+
+	take_dentry_name_snapshot(&name, dentry);
+
+	fsnotify(d_inode(parent), mask, d_inode(dentry), FSNOTIFY_EVENT_INODE,
+		 name.name, 0);
+
+	release_dentry_name_snapshot(&name);
+
+out_dput:
+	dput(parent);
+}
+EXPORT_SYMBOL(fsnotify_nameremove);
+
 /*
  * Given an inode, first check if we care what happens to our children.  Inotify
  * and dnotify both tell their parents about events.  If we care about any event
* Unmerged path include/linux/fsnotify.h
* Unmerged path include/linux/fsnotify_backend.h
