net: flow_offload: add flow_block structure and use it

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] flow_offload: add flow_block structure and use it (Ivan Vecera) [1737890]
Rebuild_FUZZ: 95.15%
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 14bfb13f0ed525ed117b5d1f3e77e7c0a6be15de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/14bfb13f.failed

This object stores the flow block callbacks that are attached to this
block. Update flow_block_cb_lookup() to take this new object.

This patch restores the block sharing feature.

Fixes: da3eeb904ff4 ("net: flow_offload: add list handling functions")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 14bfb13f0ed525ed117b5d1f3e77e7c0a6be15de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
#	drivers/net/ethernet/mscc/ocelot_flower.c
#	drivers/net/ethernet/mscc/ocelot_tc.c
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
#	include/net/flow_offload.h
#	include/net/netfilter/nf_tables.h
#	net/core/flow_offload.c
#	net/dsa/slave.c
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nf_tables_offload.c
#	net/sched/cls_api.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index d4d2e9fb17fa,7f747cb1a4f4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -754,12 -752,14 +754,20 @@@ mlx5e_rep_indr_setup_tc_block(struct ne
  		if (!indr_priv)
  			return -ENOENT;
  
++<<<<<<< HEAD
 +		tcf_block_cb_unregister(f->block,
 +					mlx5e_rep_indr_setup_block_cb,
 +					indr_priv);
 +		list_del(&indr_priv->list);
 +		kfree(indr_priv);
++=======
+ 		block_cb = flow_block_cb_lookup(f->block,
+ 						mlx5e_rep_indr_setup_block_cb,
+ 						indr_priv);
+ 		if (!block_cb)
+ 			return -ENOENT;
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  
 -		flow_block_cb_remove(block_cb, f);
 -		list_del(&block_cb->driver_list);
  		return 0;
  	default:
  		return -EOPNOTSUPP;
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index e43d1c130eea,650638152bbc..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -1531,19 -1600,22 +1531,25 @@@ mlxsw_sp_setup_tc_block_flower_bind(str
  {
  	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
  	struct mlxsw_sp_acl_block *acl_block;
 -	struct flow_block_cb *block_cb;
 -	bool register_block = false;
 +	struct tcf_block_cb *block_cb;
  	int err;
  
++<<<<<<< HEAD
 +	block_cb = tcf_block_cb_lookup(block, mlxsw_sp_setup_tc_block_cb_flower,
 +				       mlxsw_sp);
++=======
+ 	block_cb = flow_block_cb_lookup(f->block,
+ 					mlxsw_sp_setup_tc_block_cb_flower,
+ 					mlxsw_sp);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  	if (!block_cb) {
 -		acl_block = mlxsw_sp_acl_block_create(mlxsw_sp, f->net);
 +		acl_block = mlxsw_sp_acl_block_create(mlxsw_sp, block->net);
  		if (!acl_block)
  			return -ENOMEM;
 -		block_cb = flow_block_cb_alloc(mlxsw_sp_setup_tc_block_cb_flower,
 -					       mlxsw_sp, acl_block,
 -					       mlxsw_sp_tc_block_flower_release);
 +		block_cb = __tcf_block_cb_register(block,
 +						   mlxsw_sp_setup_tc_block_cb_flower,
 +						   mlxsw_sp, acl_block, extack);
  		if (IS_ERR(block_cb)) {
 -			mlxsw_sp_acl_block_destroy(acl_block);
  			err = PTR_ERR(block_cb);
  			goto err_cb_register;
  		}
@@@ -1578,11 -1654,12 +1584,17 @@@ mlxsw_sp_setup_tc_block_flower_unbind(s
  {
  	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
  	struct mlxsw_sp_acl_block *acl_block;
 -	struct flow_block_cb *block_cb;
 +	struct tcf_block_cb *block_cb;
  	int err;
  
++<<<<<<< HEAD
 +	block_cb = tcf_block_cb_lookup(block, mlxsw_sp_setup_tc_block_cb_flower,
 +				       mlxsw_sp);
++=======
+ 	block_cb = flow_block_cb_lookup(f->block,
+ 					mlxsw_sp_setup_tc_block_cb_flower,
+ 					mlxsw_sp);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  	if (!block_cb)
  		return;
  
@@@ -1617,24 -1695,36 +1629,34 @@@ static int mlxsw_sp_setup_tc_block(stru
  		return -EOPNOTSUPP;
  	}
  
 -	f->driver_block_list = &mlxsw_sp_block_cb_list;
 -
  	switch (f->command) {
 -	case FLOW_BLOCK_BIND:
 -		if (flow_block_cb_is_busy(cb, mlxsw_sp_port,
 -					  &mlxsw_sp_block_cb_list))
 -			return -EBUSY;
 -
 -		block_cb = flow_block_cb_alloc(cb, mlxsw_sp_port,
 -					       mlxsw_sp_port, NULL);
 -		if (IS_ERR(block_cb))
 -			return PTR_ERR(block_cb);
 -		err = mlxsw_sp_setup_tc_block_flower_bind(mlxsw_sp_port, f,
 -							  ingress);
 +	case TC_BLOCK_BIND:
 +		err = tcf_block_cb_register(f->block, cb, mlxsw_sp_port,
 +					    mlxsw_sp_port, f->extack);
 +		if (err)
 +			return err;
 +		err = mlxsw_sp_setup_tc_block_flower_bind(mlxsw_sp_port,
 +							  f->block, ingress,
 +							  f->extack);
  		if (err) {
 -			flow_block_cb_free(block_cb);
 +			tcf_block_cb_unregister(f->block, cb, mlxsw_sp_port);
  			return err;
  		}
 -		flow_block_cb_add(block_cb, f);
 -		list_add_tail(&block_cb->driver_list, &mlxsw_sp_block_cb_list);
  		return 0;
 -	case FLOW_BLOCK_UNBIND:
 +	case TC_BLOCK_UNBIND:
  		mlxsw_sp_setup_tc_block_flower_unbind(mlxsw_sp_port,
++<<<<<<< HEAD
 +						      f->block, ingress);
 +		tcf_block_cb_unregister(f->block, cb, mlxsw_sp_port);
++=======
+ 						      f, ingress);
+ 		block_cb = flow_block_cb_lookup(f->block, cb, mlxsw_sp_port);
+ 		if (!block_cb)
+ 			return -ENOENT;
+ 
+ 		flow_block_cb_remove(block_cb, f);
+ 		list_del(&block_cb->driver_list);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  		return 0;
  	default:
  		return -EOPNOTSUPP;
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index bdd551f36cb7,e209f150c5f2..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -599,23 -1296,45 +599,48 @@@ static int nfp_flower_setup_tc_block_cb
  	}
  }
  
 -static LIST_HEAD(nfp_block_cb_list);
 -
  static int nfp_flower_setup_tc_block(struct net_device *netdev,
 -				     struct flow_block_offload *f)
 +				     struct tc_block_offload *f)
  {
  	struct nfp_repr *repr = netdev_priv(netdev);
 -	struct nfp_flower_repr_priv *repr_priv;
 -	struct flow_block_cb *block_cb;
  
 -	if (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
 +	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
  		return -EOPNOTSUPP;
  
 -	repr_priv = repr->app_priv;
 -	repr_priv->block_shared = f->block_shared;
 -	f->driver_block_list = &nfp_block_cb_list;
 -
  	switch (f->command) {
++<<<<<<< HEAD
 +	case TC_BLOCK_BIND:
 +		return tcf_block_cb_register(f->block,
 +					     nfp_flower_setup_tc_block_cb,
 +					     repr, repr, f->extack);
 +	case TC_BLOCK_UNBIND:
 +		tcf_block_cb_unregister(f->block,
 +					nfp_flower_setup_tc_block_cb,
 +					repr);
++=======
+ 	case FLOW_BLOCK_BIND:
+ 		if (flow_block_cb_is_busy(nfp_flower_setup_tc_block_cb, repr,
+ 					  &nfp_block_cb_list))
+ 			return -EBUSY;
+ 
+ 		block_cb = flow_block_cb_alloc(nfp_flower_setup_tc_block_cb,
+ 					       repr, repr, NULL);
+ 		if (IS_ERR(block_cb))
+ 			return PTR_ERR(block_cb);
+ 
+ 		flow_block_cb_add(block_cb, f);
+ 		list_add_tail(&block_cb->driver_list, &nfp_block_cb_list);
+ 		return 0;
+ 	case FLOW_BLOCK_UNBIND:
+ 		block_cb = flow_block_cb_lookup(f->block,
+ 						nfp_flower_setup_tc_block_cb,
+ 						repr);
+ 		if (!block_cb)
+ 			return -ENOENT;
+ 
+ 		flow_block_cb_remove(block_cb, f);
+ 		list_del(&block_cb->driver_list);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  		return 0;
  	default:
  		return -EOPNOTSUPP;
@@@ -709,12 -1441,14 +734,20 @@@ nfp_flower_setup_indr_tc_block(struct n
  		if (!cb_priv)
  			return -ENOENT;
  
++<<<<<<< HEAD
 +		tcf_block_cb_unregister(f->block,
 +					nfp_flower_setup_indr_block_cb,
 +					cb_priv);
 +		list_del(&cb_priv->list);
 +		kfree(cb_priv);
++=======
+ 		block_cb = flow_block_cb_lookup(f->block,
+ 						nfp_flower_setup_indr_block_cb,
+ 						cb_priv);
+ 		if (!block_cb)
+ 			return -ENOENT;
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  
 -		flow_block_cb_remove(block_cb, f);
 -		list_del(&block_cb->driver_list);
  		return 0;
  	default:
  		return -EOPNOTSUPP;
diff --cc include/net/flow_offload.h
index 36127c1858a4,b16d21636d69..000000000000
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@@ -232,4 -238,113 +232,116 @@@ static inline void flow_stats_update(st
  	flow_stats->lastused	= max_t(u64, flow_stats->lastused, lastused);
  }
  
++<<<<<<< HEAD
++=======
+ enum flow_block_command {
+ 	FLOW_BLOCK_BIND,
+ 	FLOW_BLOCK_UNBIND,
+ };
+ 
+ enum flow_block_binder_type {
+ 	FLOW_BLOCK_BINDER_TYPE_UNSPEC,
+ 	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS,
+ 	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS,
+ };
+ 
+ struct flow_block {
+ 	struct list_head cb_list;
+ };
+ 
+ struct netlink_ext_ack;
+ 
+ struct flow_block_offload {
+ 	enum flow_block_command command;
+ 	enum flow_block_binder_type binder_type;
+ 	bool block_shared;
+ 	struct net *net;
+ 	struct flow_block *block;
+ 	struct list_head cb_list;
+ 	struct list_head *driver_block_list;
+ 	struct netlink_ext_ack *extack;
+ };
+ 
+ enum tc_setup_type;
+ typedef int flow_setup_cb_t(enum tc_setup_type type, void *type_data,
+ 			    void *cb_priv);
+ 
+ struct flow_block_cb {
+ 	struct list_head	driver_list;
+ 	struct list_head	list;
+ 	flow_setup_cb_t		*cb;
+ 	void			*cb_ident;
+ 	void			*cb_priv;
+ 	void			(*release)(void *cb_priv);
+ 	unsigned int		refcnt;
+ };
+ 
+ struct flow_block_cb *flow_block_cb_alloc(flow_setup_cb_t *cb,
+ 					  void *cb_ident, void *cb_priv,
+ 					  void (*release)(void *cb_priv));
+ void flow_block_cb_free(struct flow_block_cb *block_cb);
+ 
+ struct flow_block_cb *flow_block_cb_lookup(struct flow_block *block,
+ 					   flow_setup_cb_t *cb, void *cb_ident);
+ 
+ void *flow_block_cb_priv(struct flow_block_cb *block_cb);
+ void flow_block_cb_incref(struct flow_block_cb *block_cb);
+ unsigned int flow_block_cb_decref(struct flow_block_cb *block_cb);
+ 
+ static inline void flow_block_cb_add(struct flow_block_cb *block_cb,
+ 				     struct flow_block_offload *offload)
+ {
+ 	list_add_tail(&block_cb->list, &offload->cb_list);
+ }
+ 
+ static inline void flow_block_cb_remove(struct flow_block_cb *block_cb,
+ 					struct flow_block_offload *offload)
+ {
+ 	list_move(&block_cb->list, &offload->cb_list);
+ }
+ 
+ bool flow_block_cb_is_busy(flow_setup_cb_t *cb, void *cb_ident,
+ 			   struct list_head *driver_block_list);
+ 
+ int flow_block_cb_setup_simple(struct flow_block_offload *f,
+ 			       struct list_head *driver_list,
+ 			       flow_setup_cb_t *cb,
+ 			       void *cb_ident, void *cb_priv, bool ingress_only);
+ 
+ enum flow_cls_command {
+ 	FLOW_CLS_REPLACE,
+ 	FLOW_CLS_DESTROY,
+ 	FLOW_CLS_STATS,
+ 	FLOW_CLS_TMPLT_CREATE,
+ 	FLOW_CLS_TMPLT_DESTROY,
+ };
+ 
+ struct flow_cls_common_offload {
+ 	u32 chain_index;
+ 	__be16 protocol;
+ 	u32 prio;
+ 	struct netlink_ext_ack *extack;
+ };
+ 
+ struct flow_cls_offload {
+ 	struct flow_cls_common_offload common;
+ 	enum flow_cls_command command;
+ 	unsigned long cookie;
+ 	struct flow_rule *rule;
+ 	struct flow_stats stats;
+ 	u32 classid;
+ };
+ 
+ static inline struct flow_rule *
+ flow_cls_offload_flow_rule(struct flow_cls_offload *flow_cmd)
+ {
+ 	return flow_cmd->rule;
+ }
+ 
+ static inline void flow_block_init(struct flow_block *flow_block)
+ {
+ 	INIT_LIST_HEAD(&flow_block->cb_list);
+ }
+ 
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  #endif /* _NET_FLOW_OFFLOAD_H */
diff --cc include/net/netfilter/nf_tables.h
index 0d548834982e,9b624566b82d..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -12,7 -11,10 +12,8 @@@
  #include <linux/rhashtable.h>
  #include <net/netfilter/nf_flow_table.h>
  #include <net/netlink.h>
+ #include <net/flow_offload.h>
  
 -struct module;
 -
  #define NFT_JUMP_STACK_SIZE	16
  
  struct nft_pktinfo {
@@@ -939,6 -952,7 +940,10 @@@ struct nft_stats 
   *	@stats: per-cpu chain stats
   *	@chain: the chain
   *	@dev_name: device name that this base chain is attached to (if any)
++<<<<<<< HEAD
++=======
+  *	@flow_block: flow block (for hardware offload)
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
   */
  struct nft_base_chain {
  	struct nf_hook_ops		ops;
@@@ -948,6 -962,7 +953,10 @@@
  	struct nft_stats __percpu	*stats;
  	struct nft_chain		chain;
  	char 				dev_name[IFNAMSIZ];
++<<<<<<< HEAD
++=======
+ 	struct flow_block		flow_block;
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  };
  
  static inline struct nft_base_chain *nft_base_chain(const struct nft_chain *chain)
diff --cc net/core/flow_offload.c
index fd722fcdcd91,d63b970784dc..000000000000
--- a/net/core/flow_offload.c
+++ b/net/core/flow_offload.c
@@@ -165,3 -164,119 +165,122 @@@ void flow_rule_match_enc_opts(const str
  	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_OPTS, out);
  }
  EXPORT_SYMBOL(flow_rule_match_enc_opts);
++<<<<<<< HEAD
++=======
+ 
+ struct flow_block_cb *flow_block_cb_alloc(flow_setup_cb_t *cb,
+ 					  void *cb_ident, void *cb_priv,
+ 					  void (*release)(void *cb_priv))
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	block_cb = kzalloc(sizeof(*block_cb), GFP_KERNEL);
+ 	if (!block_cb)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	block_cb->cb = cb;
+ 	block_cb->cb_ident = cb_ident;
+ 	block_cb->cb_priv = cb_priv;
+ 	block_cb->release = release;
+ 
+ 	return block_cb;
+ }
+ EXPORT_SYMBOL(flow_block_cb_alloc);
+ 
+ void flow_block_cb_free(struct flow_block_cb *block_cb)
+ {
+ 	if (block_cb->release)
+ 		block_cb->release(block_cb->cb_priv);
+ 
+ 	kfree(block_cb);
+ }
+ EXPORT_SYMBOL(flow_block_cb_free);
+ 
+ struct flow_block_cb *flow_block_cb_lookup(struct flow_block *block,
+ 					   flow_setup_cb_t *cb, void *cb_ident)
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	list_for_each_entry(block_cb, &block->cb_list, list) {
+ 		if (block_cb->cb == cb &&
+ 		    block_cb->cb_ident == cb_ident)
+ 			return block_cb;
+ 	}
+ 
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(flow_block_cb_lookup);
+ 
+ void *flow_block_cb_priv(struct flow_block_cb *block_cb)
+ {
+ 	return block_cb->cb_priv;
+ }
+ EXPORT_SYMBOL(flow_block_cb_priv);
+ 
+ void flow_block_cb_incref(struct flow_block_cb *block_cb)
+ {
+ 	block_cb->refcnt++;
+ }
+ EXPORT_SYMBOL(flow_block_cb_incref);
+ 
+ unsigned int flow_block_cb_decref(struct flow_block_cb *block_cb)
+ {
+ 	return --block_cb->refcnt;
+ }
+ EXPORT_SYMBOL(flow_block_cb_decref);
+ 
+ bool flow_block_cb_is_busy(flow_setup_cb_t *cb, void *cb_ident,
+ 			   struct list_head *driver_block_list)
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	list_for_each_entry(block_cb, driver_block_list, driver_list) {
+ 		if (block_cb->cb == cb &&
+ 		    block_cb->cb_ident == cb_ident)
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL(flow_block_cb_is_busy);
+ 
+ int flow_block_cb_setup_simple(struct flow_block_offload *f,
+ 			       struct list_head *driver_block_list,
+ 			       flow_setup_cb_t *cb,
+ 			       void *cb_ident, void *cb_priv,
+ 			       bool ingress_only)
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	if (ingress_only &&
+ 	    f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	f->driver_block_list = driver_block_list;
+ 
+ 	switch (f->command) {
+ 	case FLOW_BLOCK_BIND:
+ 		if (flow_block_cb_is_busy(cb, cb_ident, driver_block_list))
+ 			return -EBUSY;
+ 
+ 		block_cb = flow_block_cb_alloc(cb, cb_ident, cb_priv, NULL);
+ 		if (IS_ERR(block_cb))
+ 			return PTR_ERR(block_cb);
+ 
+ 		flow_block_cb_add(block_cb, f);
+ 		list_add_tail(&block_cb->driver_list, driver_block_list);
+ 		return 0;
+ 	case FLOW_BLOCK_UNBIND:
+ 		block_cb = flow_block_cb_lookup(f->block, cb, cb_ident);
+ 		if (!block_cb)
+ 			return -ENOENT;
+ 
+ 		flow_block_cb_remove(block_cb, f);
+ 		list_del(&block_cb->driver_list);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ EXPORT_SYMBOL(flow_block_cb_setup_simple);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
diff --cc net/dsa/slave.c
index 5e192d3878a2,33f41178afcc..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -894,11 -960,27 +894,32 @@@ static int dsa_slave_setup_tc_block(str
  	else
  		return -EOPNOTSUPP;
  
 -	f->driver_block_list = &dsa_slave_block_cb_list;
 -
  	switch (f->command) {
++<<<<<<< HEAD
 +	case TC_BLOCK_BIND:
 +		return tcf_block_cb_register(f->block, cb, dev, dev, f->extack);
 +	case TC_BLOCK_UNBIND:
 +		tcf_block_cb_unregister(f->block, cb, dev);
++=======
+ 	case FLOW_BLOCK_BIND:
+ 		if (flow_block_cb_is_busy(cb, dev, &dsa_slave_block_cb_list))
+ 			return -EBUSY;
+ 
+ 		block_cb = flow_block_cb_alloc(cb, dev, dev, NULL);
+ 		if (IS_ERR(block_cb))
+ 			return PTR_ERR(block_cb);
+ 
+ 		flow_block_cb_add(block_cb, f);
+ 		list_add_tail(&block_cb->driver_list, &dsa_slave_block_cb_list);
+ 		return 0;
+ 	case FLOW_BLOCK_UNBIND:
+ 		block_cb = flow_block_cb_lookup(f->block, cb, dev);
+ 		if (!block_cb)
+ 			return -ENOENT;
+ 
+ 		flow_block_cb_remove(block_cb, f);
+ 		list_del(&block_cb->driver_list);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  		return 0;
  	default:
  		return -EOPNOTSUPP;
diff --cc net/netfilter/nf_tables_api.c
index 244f61593914,605a7cfe7ca7..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1582,8 -1660,9 +1582,14 @@@ static int nf_tables_addchain(struct nf
  		ops->hook	= hook.type->hooks[ops->hooknum];
  		ops->dev	= hook.dev;
  
++<<<<<<< HEAD
 +		chain->flags |= NFT_BASE_CHAIN;
 +		basechain->policy = policy;
++=======
+ 		chain->flags |= NFT_BASE_CHAIN | flags;
+ 		basechain->policy = NF_ACCEPT;
+ 		flow_block_init(&basechain->flow_block);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  	} else {
  		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
  		if (chain == NULL)
diff --cc net/sched/cls_api.c
index 51cea3b125f9,15796fd47fda..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -774,10 -773,12 +776,16 @@@ static void tc_indr_block_call(struct t
  {
  	struct tc_indr_block_cb *indr_block_cb;
  	struct tc_indr_block_dev *indr_dev;
 -	struct flow_block_offload bo = {
 +	struct tc_block_offload bo = {
  		.command	= command,
  		.binder_type	= ei->binder_type,
++<<<<<<< HEAD
 +		.block		= block,
++=======
+ 		.net		= dev_net(dev),
+ 		.block		= &block->flow_block,
+ 		.block_shared	= tcf_block_shared(block),
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  		.extack		= extack,
  	};
  	INIT_LIST_HEAD(&bo.cb_list);
@@@ -803,15 -804,17 +811,20 @@@ static bool tcf_block_offload_in_use(st
  static int tcf_block_offload_cmd(struct tcf_block *block,
  				 struct net_device *dev,
  				 struct tcf_block_ext_info *ei,
 -				 enum flow_block_command command,
 +				 enum tc_block_command command,
  				 struct netlink_ext_ack *extack)
  {
 -	struct flow_block_offload bo = {};
 +	struct tc_block_offload bo = {};
  	int err;
  
 -	bo.net = dev_net(dev);
  	bo.command = command;
  	bo.binder_type = ei->binder_type;
++<<<<<<< HEAD
 +	bo.block = block;
++=======
+ 	bo.block = &block->flow_block;
+ 	bo.block_shared = tcf_block_shared(block);
++>>>>>>> 14bfb13f0ed5 (net: flow_offload: add flow_block structure and use it)
  	bo.extack = extack;
  	INIT_LIST_HEAD(&bo.cb_list);
  
* Unmerged path drivers/net/ethernet/mscc/ocelot_flower.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_tc.c
* Unmerged path net/netfilter/nf_tables_offload.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_flower.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_tc.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
* Unmerged path include/net/flow_offload.h
* Unmerged path include/net/netfilter/nf_tables.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 13911b10ed82..a07531c0596e 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -404,7 +404,7 @@ struct tcf_block {
 	refcount_t refcnt;
 	struct net *net;
 	struct Qdisc *q;
-	struct list_head cb_list;
+	struct flow_block flow_block;
 	struct list_head owner_list;
 	bool keep_dst;
 	unsigned int offloadcnt; /* Number of oddloaded filters */
* Unmerged path net/core/flow_offload.c
* Unmerged path net/dsa/slave.c
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nf_tables_offload.c
* Unmerged path net/sched/cls_api.c
