KVM: PPC: Book3S HV: Flush link stack on guest exit to host kernel

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit af2e8c68b9c5403f77096969c516f742f5bb29e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/af2e8c68.failed

On some systems that are vulnerable to Spectre v2, it is up to
software to flush the link stack (return address stack), in order to
protect against Spectre-RSB.

When exiting from a guest we do some house keeping and then
potentially exit to C code which is several stack frames deep in the
host kernel. We will then execute a series of returns without
preceeding calls, opening up the possiblity that the guest could have
poisoned the link stack, and direct speculative execution of the host
to a gadget of some sort.

To prevent this we add a flush of the link stack on exit from a guest.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit af2e8c68b9c5403f77096969c516f742f5bb29e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/asm-prototypes.h
#	arch/powerpc/kernel/security.c
diff --cc arch/powerpc/include/asm/asm-prototypes.h
index 0e6f7a839bcf,d84d1417ddb6..000000000000
--- a/arch/powerpc/include/asm/asm-prototypes.h
+++ b/arch/powerpc/include/asm/asm-prototypes.h
@@@ -141,6 -149,16 +141,19 @@@ struct kvm_vcpu
  void _kvmppc_restore_tm_pr(struct kvm_vcpu *vcpu, u64 guest_msr);
  void _kvmppc_save_tm_pr(struct kvm_vcpu *vcpu, u64 guest_msr);
  
++<<<<<<< HEAD
++=======
+ /* Patch sites */
+ extern s32 patch__call_flush_count_cache;
+ extern s32 patch__flush_count_cache_return;
+ extern s32 patch__flush_link_stack_return;
+ extern s32 patch__call_kvm_flush_link_stack;
+ extern s32 patch__memset_nocache, patch__memcpy_nocache;
+ 
+ extern long flush_count_cache;
+ extern long kvm_flush_link_stack;
+ 
++>>>>>>> af2e8c68b9c5 (KVM: PPC: Book3S HV: Flush link stack on guest exit to host kernel)
  #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
  void kvmppc_save_tm_hv(struct kvm_vcpu *vcpu, u64 msr, bool preserve_nv);
  void kvmppc_restore_tm_hv(struct kvm_vcpu *vcpu, u64 msr, bool preserve_nv);
diff --cc arch/powerpc/kernel/security.c
index d465307cccdd,bd91dceb7010..000000000000
--- a/arch/powerpc/kernel/security.c
+++ b/arch/powerpc/kernel/security.c
@@@ -341,18 -386,49 +341,46 @@@ static __init int stf_barrier_debugfs_i
  device_initcall(stf_barrier_debugfs_init);
  #endif /* CONFIG_DEBUG_FS */
  
 -static void no_count_cache_flush(void)
 -{
 -	count_cache_flush_type = COUNT_CACHE_FLUSH_NONE;
 -	pr_info("count-cache-flush: software flush disabled.\n");
 -}
 -
  static void toggle_count_cache_flush(bool enable)
  {
 -	if (!security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE) &&
 -	    !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK))
 -		enable = false;
 -
 -	if (!enable) {
 +	if (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {
  		patch_instruction_site(&patch__call_flush_count_cache, PPC_INST_NOP);
++<<<<<<< HEAD
 +		count_cache_flush_type = COUNT_CACHE_FLUSH_NONE;
 +		pr_info("count-cache-flush: software flush disabled.\n");
++=======
+ #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
+ 		patch_instruction_site(&patch__call_kvm_flush_link_stack, PPC_INST_NOP);
+ #endif
+ 		pr_info("link-stack-flush: software flush disabled.\n");
+ 		link_stack_flush_enabled = false;
+ 		no_count_cache_flush();
++>>>>>>> af2e8c68b9c5 (KVM: PPC: Book3S HV: Flush link stack on guest exit to host kernel)
  		return;
  	}
  
  	patch_branch_site(&patch__call_flush_count_cache,
  			  (u64)&flush_count_cache, BRANCH_SET_LINK);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
+ 	// This enables the branch from guest_exit_cont to kvm_flush_link_stack
+ 	patch_branch_site(&patch__call_kvm_flush_link_stack,
+ 			  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);
+ #endif
+ 
+ 	pr_info("link-stack-flush: software flush enabled.\n");
+ 	link_stack_flush_enabled = true;
+ 
+ 	// If we just need to flush the link stack, patch an early return
+ 	if (!security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {
+ 		patch_instruction_site(&patch__flush_link_stack_return, PPC_INST_BLR);
+ 		no_count_cache_flush();
+ 		return;
+ 	}
+ 
++>>>>>>> af2e8c68b9c5 (KVM: PPC: Book3S HV: Flush link stack on guest exit to host kernel)
  	if (!security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {
  		count_cache_flush_type = COUNT_CACHE_FLUSH_SW;
  		pr_info("count-cache-flush: full software flush sequence enabled.\n");
* Unmerged path arch/powerpc/include/asm/asm-prototypes.h
* Unmerged path arch/powerpc/kernel/security.c
diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
index bfc3c584b8f4..5fc8f6fed9ca 100644
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@ -18,6 +18,7 @@
  */
 
 #include <asm/ppc_asm.h>
+#include <asm/code-patching-asm.h>
 #include <asm/kvm_asm.h>
 #include <asm/reg.h>
 #include <asm/mmu.h>
@@ -1450,6 +1451,13 @@ guest_exit_cont:		/* r9 = vcpu, r12 = trap, r13 = paca */
 1:
 #endif /* CONFIG_KVM_XICS */
 
+	/*
+	 * Possibly flush the link stack here, before we do a blr in
+	 * guest_exit_short_path.
+	 */
+1:	nop
+	patch_site 1b patch__call_kvm_flush_link_stack
+
 	/* If we came in through the P9 short path, go back out to C now */
 	lwz	r0, STACK_SLOT_SHORT_PATH(r1)
 	cmpwi	r0, 0
@@ -1925,6 +1933,28 @@ END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)
 	mtlr	r0
 	blr
 
+.balign 32
+.global kvm_flush_link_stack
+kvm_flush_link_stack:
+	/* Save LR into r0 */
+	mflr	r0
+
+	/* Flush the link stack. On Power8 it's up to 32 entries in size. */
+	.rept 32
+	bl	.+4
+	.endr
+
+	/* And on Power9 it's up to 64. */
+BEGIN_FTR_SECTION
+	.rept 32
+	bl	.+4
+	.endr
+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)
+
+	/* Restore LR */
+	mtlr	r0
+	blr
+
 kvmppc_guest_external:
 	/* External interrupt, first check for host_ipi. If this is
 	 * set, we know the host wants us out so let's do it now
