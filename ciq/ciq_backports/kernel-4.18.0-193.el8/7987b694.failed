SUNRPC: Fix a use after free when a server rejects the RPCSEC_GSS credential

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 7987b694ade8cc465ce10fb3dceaa614f13ceaf3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7987b694.failed

The addition of rpc_check_timeout() to call_decode causes an Oops
when the RPCSEC_GSS credential is rejected.
The reason is that rpc_decode_header() will call xprt_release() in
order to free task->tk_rqstp, which is needed by rpc_check_timeout()
to check whether or not we should exit due to a soft timeout.

The fix is to move the call to xprt_release() into call_decode() so
we can perform it after rpc_check_timeout().

	Reported-by: Olga Kornievskaia <olga.kornievskaia@gmail.com>
	Reported-by: Nick Bowler <nbowler@draconx.ca>
Fixes: cea57789e408 ("SUNRPC: Clean up")
	Cc: stable@vger.kernel.org # v5.1+
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 7987b694ade8cc465ce10fb3dceaa614f13ceaf3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 4c9385209a04,627a87a71f8b..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2292,39 -2415,32 +2292,68 @@@ call_decode(struct rpc_task *task
  	WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
  				sizeof(req->rq_rcv_buf)) != 0);
  
++<<<<<<< HEAD
 +	if (req->rq_rcv_buf.len < 12) {
 +		if (!RPC_IS_SOFT(task)) {
 +			task->tk_action = call_bind;
 +			goto out_retry;
 +		}
 +		dprintk("RPC:       %s: too small RPC reply size (%d bytes)\n",
 +				clnt->cl_program->name, task->tk_status);
 +		task->tk_action = call_timeout;
 +		goto out_retry;
 +	}
 +
 +	p = rpc_verify_header(task);
 +	if (IS_ERR(p)) {
 +		if (p == ERR_PTR(-EAGAIN))
 +			goto out_retry;
 +		return;
 +	}
 +	task->tk_action = rpc_exit_task;
 +
 +	task->tk_status = rpcauth_unwrap_resp(task, decode, req, p,
 +					      task->tk_msg.rpc_resp);
 +
 +	dprintk("RPC: %5u call_decode result %d\n", task->tk_pid,
 +			task->tk_status);
 +	return;
 +out_retry:
 +	task->tk_status = 0;
 +	/* Note: rpc_verify_header() may have freed the RPC slot */
 +	if (task->tk_rqstp == req) {
 +		req->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;
 +		if (task->tk_client->cl_discrtry)
 +			xprt_conditional_disconnect(req->rq_xprt,
 +					req->rq_connect_cookie);
++=======
+ 	xdr_init_decode(&xdr, &req->rq_rcv_buf,
+ 			req->rq_rcv_buf.head[0].iov_base, req);
+ 	switch (rpc_decode_header(task, &xdr)) {
+ 	case 0:
+ 		task->tk_action = rpc_exit_task;
+ 		task->tk_status = rpcauth_unwrap_resp(task, &xdr);
+ 		dprintk("RPC: %5u %s result %d\n",
+ 			task->tk_pid, __func__, task->tk_status);
+ 		return;
+ 	case -EAGAIN:
+ 		task->tk_status = 0;
+ 		xdr_free_bvec(&req->rq_rcv_buf);
+ 		req->rq_reply_bytes_recvd = 0;
+ 		req->rq_rcv_buf.len = 0;
+ 		if (task->tk_client->cl_discrtry)
+ 			xprt_conditional_disconnect(req->rq_xprt,
+ 						    req->rq_connect_cookie);
+ 		task->tk_action = call_encode;
+ 		rpc_check_timeout(task);
+ 		break;
+ 	case -EKEYREJECTED:
+ 		task->tk_action = call_reserve;
+ 		rpc_check_timeout(task);
+ 		rpcauth_invalcred(task);
+ 		/* Ensure we obtain a new XID if we retry! */
+ 		xprt_release(task);
++>>>>>>> 7987b694ade8 (SUNRPC: Fix a use after free when a server rejects the RPCSEC_GSS credential)
  	}
  }
  
@@@ -2499,13 -2537,64 +2528,68 @@@ out_retry
  	}
  out_err:
  	rpc_exit(task, error);
 -	return error;
 -
 -out_unparsable:
 -	trace_rpc__unparsable(task);
 -	error = -EIO;
 +	dprintk("RPC: %5u %s: call failed with error %d\n", task->tk_pid,
 +			__func__, error);
 +	return ERR_PTR(error);
 +out_overflow:
 +	dprintk("RPC: %5u %s: server reply was truncated.\n", task->tk_pid,
 +			__func__);
  	goto out_garbage;
++<<<<<<< HEAD
++=======
+ 
+ out_verifier:
+ 	trace_rpc_bad_verifier(task);
+ 	goto out_garbage;
+ 
+ out_msg_denied:
+ 	error = -EACCES;
+ 	p = xdr_inline_decode(xdr, sizeof(*p));
+ 	if (!p)
+ 		goto out_unparsable;
+ 	switch (*p++) {
+ 	case rpc_auth_error:
+ 		break;
+ 	case rpc_mismatch:
+ 		trace_rpc__mismatch(task);
+ 		error = -EPROTONOSUPPORT;
+ 		goto out_err;
+ 	default:
+ 		goto out_unparsable;
+ 	}
+ 
+ 	p = xdr_inline_decode(xdr, sizeof(*p));
+ 	if (!p)
+ 		goto out_unparsable;
+ 	switch (*p++) {
+ 	case rpc_autherr_rejectedcred:
+ 	case rpc_autherr_rejectedverf:
+ 	case rpcsec_gsserr_credproblem:
+ 	case rpcsec_gsserr_ctxproblem:
+ 		if (!task->tk_cred_retry)
+ 			break;
+ 		task->tk_cred_retry--;
+ 		trace_rpc__stale_creds(task);
+ 		return -EKEYREJECTED;
+ 	case rpc_autherr_badcred:
+ 	case rpc_autherr_badverf:
+ 		/* possibly garbled cred/verf? */
+ 		if (!task->tk_garb_retry)
+ 			break;
+ 		task->tk_garb_retry--;
+ 		trace_rpc__bad_creds(task);
+ 		task->tk_action = call_encode;
+ 		return -EAGAIN;
+ 	case rpc_autherr_tooweak:
+ 		trace_rpc__auth_tooweak(task);
+ 		pr_warn("RPC: server %s requires stronger authentication.\n",
+ 			task->tk_xprt->servername);
+ 		break;
+ 	default:
+ 		goto out_unparsable;
+ 	}
+ 	goto out_err;
++>>>>>>> 7987b694ade8 (SUNRPC: Fix a use after free when a server rejects the RPCSEC_GSS credential)
  }
  
  static void rpcproc_encode_null(struct rpc_rqst *rqstp, struct xdr_stream *xdr,
* Unmerged path net/sunrpc/clnt.c
