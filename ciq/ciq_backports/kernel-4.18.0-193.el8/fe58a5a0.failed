net/tls: rename handle_device_resync()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] tls: rename handle_device_resync() (Sabrina Dubroca) [1760375]
Rebuild_FUZZ: 94.44%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit fe58a5a02cd9f49d5868539b4146ec1e5e5176e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/fe58a5a0.failed

handle_device_resync() doesn't describe the function very well.
The function checks if resync should be issued upon parsing of
a new record.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fe58a5a02cd9f49d5868539b4146ec1e5e5176e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tls.h
#	net/tls/tls_device.c
#	net/tls/tls_sw.c
diff --cc include/net/tls.h
index 654ae56c8ae2,1c512da5e4f4..000000000000
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@@ -584,6 -608,6 +584,10 @@@ int tls_sw_fallback_init(struct sock *s
  int tls_set_device_offload_rx(struct sock *sk, struct tls_context *ctx);
  
  void tls_device_offload_cleanup_rx(struct sock *sk);
++<<<<<<< HEAD
 +void handle_device_resync(struct sock *sk, u32 seq, u64 rcd_sn);
++=======
+ void tls_device_rx_resync_new_rec(struct sock *sk, u32 seq);
++>>>>>>> fe58a5a02cd9 (net/tls: rename handle_device_resync())
  
  #endif /* _TLS_OFFLOAD_H */
diff --cc net/tls/tls_device.c
index 330d54f9f11e,0ecfa0ee415d..000000000000
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@@ -563,7 -563,7 +563,11 @@@ static void tls_device_resync_rx(struc
  	clear_bit_unlock(TLS_RX_SYNC_RUNNING, &tls_ctx->flags);
  }
  
++<<<<<<< HEAD
 +void handle_device_resync(struct sock *sk, u32 seq, u64 rcd_sn)
++=======
+ void tls_device_rx_resync_new_rec(struct sock *sk, u32 seq)
++>>>>>>> fe58a5a02cd9 (net/tls: rename handle_device_resync())
  {
  	struct tls_context *tls_ctx = tls_get_ctx(sk);
  	struct tls_offload_context_rx *rx_ctx;
diff --cc net/tls/tls_sw.c
index ce27aa31184f,bc3a1b188d4a..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -2015,8 -2015,8 +2015,13 @@@ static int tls_read_size(struct strpars
  		goto read_failure;
  	}
  #ifdef CONFIG_TLS_DEVICE
++<<<<<<< HEAD
 +	handle_device_resync(strp->sk, TCP_SKB_CB(skb)->seq + rxm->offset,
 +			     *(u64*)tls_ctx->rx.rec_seq);
++=======
+ 	tls_device_rx_resync_new_rec(strp->sk,
+ 				     TCP_SKB_CB(skb)->seq + rxm->offset);
++>>>>>>> fe58a5a02cd9 (net/tls: rename handle_device_resync())
  #endif
  	return data_len + TLS_HEADER_SIZE;
  
* Unmerged path include/net/tls.h
* Unmerged path net/tls/tls_device.c
* Unmerged path net/tls/tls_sw.c
