SUNRPC: Add trace event that reports reply page vector alignment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 7be9cea3600ba24f45733f823cb4ecb5a40f5db7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7be9cea3.failed

We don't want READ payloads that are partially in the head iovec and
in the page buffer because this requires pull-up, which can be
expensive.

The NFS/RPC client tries hard to predict the size of the head iovec
so that the incoming READ data payload lands only in the page
vector, but it doesn't always get it right. To help diagnose such
problems, add a trace point in the logic that decodes READ-like
operations that reports whether pull-up is being done.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 7be9cea3600ba24f45733f823cb4ecb5a40f5db7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/sunrpc.h
diff --cc include/trace/events/sunrpc.h
index 42376a2afcb8,627650800676..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -254,6 -254,132 +254,135 @@@ TRACE_EVENT(rpc_stats_latency
  		__entry->backlog, __entry->rtt, __entry->execute)
  );
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(rpc_xdr_overflow,
+ 	TP_PROTO(
+ 		const struct xdr_stream *xdr,
+ 		size_t requested
+ 	),
+ 
+ 	TP_ARGS(xdr, requested),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(unsigned int, task_id)
+ 		__field(unsigned int, client_id)
+ 		__field(int, version)
+ 		__field(size_t, requested)
+ 		__field(const void *, end)
+ 		__field(const void *, p)
+ 		__field(const void *, head_base)
+ 		__field(size_t, head_len)
+ 		__field(const void *, tail_base)
+ 		__field(size_t, tail_len)
+ 		__field(unsigned int, page_len)
+ 		__field(unsigned int, len)
+ 		__string(progname,
+ 			 xdr->rqst->rq_task->tk_client->cl_program->name)
+ 		__string(procedure,
+ 			 xdr->rqst->rq_task->tk_msg.rpc_proc->p_name)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		if (xdr->rqst) {
+ 			const struct rpc_task *task = xdr->rqst->rq_task;
+ 
+ 			__entry->task_id = task->tk_pid;
+ 			__entry->client_id = task->tk_client->cl_clid;
+ 			__assign_str(progname,
+ 				     task->tk_client->cl_program->name)
+ 			__entry->version = task->tk_client->cl_vers;
+ 			__assign_str(procedure, task->tk_msg.rpc_proc->p_name)
+ 		} else {
+ 			__entry->task_id = 0;
+ 			__entry->client_id = 0;
+ 			__assign_str(progname, "unknown")
+ 			__entry->version = 0;
+ 			__assign_str(procedure, "unknown")
+ 		}
+ 		__entry->requested = requested;
+ 		__entry->end = xdr->end;
+ 		__entry->p = xdr->p;
+ 		__entry->head_base = xdr->buf->head[0].iov_base,
+ 		__entry->head_len = xdr->buf->head[0].iov_len,
+ 		__entry->page_len = xdr->buf->page_len,
+ 		__entry->tail_base = xdr->buf->tail[0].iov_base,
+ 		__entry->tail_len = xdr->buf->tail[0].iov_len,
+ 		__entry->len = xdr->buf->len;
+ 	),
+ 
+ 	TP_printk(
+ 		"task:%u@%u %sv%d %s requested=%zu p=%p end=%p xdr=[%p,%zu]/%u/[%p,%zu]/%u\n",
+ 		__entry->task_id, __entry->client_id,
+ 		__get_str(progname), __entry->version, __get_str(procedure),
+ 		__entry->requested, __entry->p, __entry->end,
+ 		__entry->head_base, __entry->head_len,
+ 		__entry->page_len,
+ 		__entry->tail_base, __entry->tail_len,
+ 		__entry->len
+ 	)
+ );
+ 
+ TRACE_EVENT(rpc_xdr_alignment,
+ 	TP_PROTO(
+ 		const struct xdr_stream *xdr,
+ 		size_t offset,
+ 		unsigned int copied
+ 	),
+ 
+ 	TP_ARGS(xdr, offset, copied),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(unsigned int, task_id)
+ 		__field(unsigned int, client_id)
+ 		__field(int, version)
+ 		__field(size_t, offset)
+ 		__field(unsigned int, copied)
+ 		__field(const void *, head_base)
+ 		__field(size_t, head_len)
+ 		__field(const void *, tail_base)
+ 		__field(size_t, tail_len)
+ 		__field(unsigned int, page_len)
+ 		__field(unsigned int, len)
+ 		__string(progname,
+ 			 xdr->rqst->rq_task->tk_client->cl_program->name)
+ 		__string(procedure,
+ 			 xdr->rqst->rq_task->tk_msg.rpc_proc->p_name)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		const struct rpc_task *task = xdr->rqst->rq_task;
+ 
+ 		__entry->task_id = task->tk_pid;
+ 		__entry->client_id = task->tk_client->cl_clid;
+ 		__assign_str(progname,
+ 			     task->tk_client->cl_program->name)
+ 		__entry->version = task->tk_client->cl_vers;
+ 		__assign_str(procedure, task->tk_msg.rpc_proc->p_name)
+ 
+ 		__entry->offset = offset;
+ 		__entry->copied = copied;
+ 		__entry->head_base = xdr->buf->head[0].iov_base,
+ 		__entry->head_len = xdr->buf->head[0].iov_len,
+ 		__entry->page_len = xdr->buf->page_len,
+ 		__entry->tail_base = xdr->buf->tail[0].iov_base,
+ 		__entry->tail_len = xdr->buf->tail[0].iov_len,
+ 		__entry->len = xdr->buf->len;
+ 	),
+ 
+ 	TP_printk(
+ 		"task:%u@%u %sv%d %s offset=%zu copied=%u xdr=[%p,%zu]/%u/[%p,%zu]/%u\n",
+ 		__entry->task_id, __entry->client_id,
+ 		__get_str(progname), __entry->version, __get_str(procedure),
+ 		__entry->offset, __entry->copied,
+ 		__entry->head_base, __entry->head_len,
+ 		__entry->page_len,
+ 		__entry->tail_base, __entry->tail_len,
+ 		__entry->len
+ 	)
+ );
+ 
++>>>>>>> 7be9cea3600b (SUNRPC: Add trace event that reports reply page vector alignment)
  /*
   * First define the enums in the below macros to be exported to userspace
   * via TRACE_DEFINE_ENUM().
* Unmerged path include/trace/events/sunrpc.h
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index bef00b60a603..3b9812dc9905 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -312,13 +312,15 @@ EXPORT_SYMBOL_GPL(_copy_from_pages);
  * 'len' bytes. The extra data is not lost, but is instead
  * moved into the inlined pages and/or the tail.
  */
-static void
+static unsigned int
 xdr_shrink_bufhead(struct xdr_buf *buf, size_t len)
 {
 	struct kvec *head, *tail;
 	size_t copy, offs;
 	unsigned int pglen = buf->page_len;
+	unsigned int result;
 
+	result = 0;
 	tail = buf->tail;
 	head = buf->head;
 
@@ -332,6 +334,7 @@ xdr_shrink_bufhead(struct xdr_buf *buf, size_t len)
 			copy = tail->iov_len - len;
 			memmove((char *)tail->iov_base + len,
 					tail->iov_base, copy);
+			result += copy;
 		}
 		/* Copy from the inlined pages into the tail */
 		copy = len;
@@ -342,11 +345,13 @@ xdr_shrink_bufhead(struct xdr_buf *buf, size_t len)
 			copy = 0;
 		else if (copy > tail->iov_len - offs)
 			copy = tail->iov_len - offs;
-		if (copy != 0)
+		if (copy != 0) {
 			_copy_from_pages((char *)tail->iov_base + offs,
 					buf->pages,
 					buf->page_base + pglen + offs - len,
 					copy);
+			result += copy;
+		}
 		/* Do we also need to copy data from the head into the tail ? */
 		if (len > pglen) {
 			offs = copy = len - pglen;
@@ -356,6 +361,7 @@ xdr_shrink_bufhead(struct xdr_buf *buf, size_t len)
 					(char *)head->iov_base +
 					head->iov_len - offs,
 					copy);
+			result += copy;
 		}
 	}
 	/* Now handle pages */
@@ -371,12 +377,15 @@ xdr_shrink_bufhead(struct xdr_buf *buf, size_t len)
 		_copy_to_pages(buf->pages, buf->page_base,
 				(char *)head->iov_base + head->iov_len - len,
 				copy);
+		result += copy;
 	}
 	head->iov_len -= len;
 	buf->buflen -= len;
 	/* Have we truncated the message? */
 	if (buf->len > buf->buflen)
 		buf->len = buf->buflen;
+
+	return result;
 }
 
 /**
@@ -388,14 +397,16 @@ xdr_shrink_bufhead(struct xdr_buf *buf, size_t len)
  * 'len' bytes. The extra data is not lost, but is instead
  * moved into the tail.
  */
-static void
+static unsigned int
 xdr_shrink_pagelen(struct xdr_buf *buf, size_t len)
 {
 	struct kvec *tail;
 	size_t copy;
 	unsigned int pglen = buf->page_len;
 	unsigned int tailbuf_len;
+	unsigned int result;
 
+	result = 0;
 	tail = buf->tail;
 	BUG_ON (len > pglen);
 
@@ -413,18 +424,22 @@ xdr_shrink_pagelen(struct xdr_buf *buf, size_t len)
 		if (tail->iov_len > len) {
 			char *p = (char *)tail->iov_base + len;
 			memmove(p, tail->iov_base, tail->iov_len - len);
+			result += tail->iov_len - len;
 		} else
 			copy = tail->iov_len;
 		/* Copy from the inlined pages into the tail */
 		_copy_from_pages((char *)tail->iov_base,
 				buf->pages, buf->page_base + pglen - len,
 				copy);
+		result += copy;
 	}
 	buf->page_len -= len;
 	buf->buflen -= len;
 	/* Have we truncated the message? */
 	if (buf->len > buf->buflen)
 		buf->len = buf->buflen;
+
+	return result;
 }
 
 void
@@ -915,13 +930,17 @@ static unsigned int xdr_align_pages(struct xdr_stream *xdr, unsigned int len)
 	struct kvec *iov;
 	unsigned int nwords = XDR_QUADLEN(len);
 	unsigned int cur = xdr_stream_pos(xdr);
+	unsigned int copied, offset;
 
 	if (xdr->nwords == 0)
 		return 0;
+
 	/* Realign pages to current pointer position */
-	iov  = buf->head;
+	iov = buf->head;
 	if (iov->iov_len > cur) {
-		xdr_shrink_bufhead(buf, iov->iov_len - cur);
+		offset = iov->iov_len - cur;
+		copied = xdr_shrink_bufhead(buf, offset);
+		trace_rpc_xdr_alignment(xdr, offset, copied);
 		xdr->nwords = XDR_QUADLEN(buf->len - cur);
 	}
 
@@ -933,7 +952,9 @@ static unsigned int xdr_align_pages(struct xdr_stream *xdr, unsigned int len)
 		len = buf->page_len;
 	else if (nwords < xdr->nwords) {
 		/* Truncate page data and move it into the tail */
-		xdr_shrink_pagelen(buf, buf->page_len - len);
+		offset = buf->page_len - len;
+		copied = xdr_shrink_pagelen(buf, offset);
+		trace_rpc_xdr_alignment(xdr, offset, copied);
 		xdr->nwords = XDR_QUADLEN(buf->len - cur);
 	}
 	return len;
