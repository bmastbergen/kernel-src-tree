kvm: selftests: introduce aarch64_vcpu_setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrew Jones <drjones@redhat.com>
commit f5dd4ccf5552d71a817d0ec97481e4a71425a038
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f5dd4ccf.failed

This allows aarch64 tests to run on more targets, such as the Arm
simulator that doesn't like KVM_ARM_TARGET_GENERIC_V8. And it also
allows aarch64 tests to provide vcpu features in struct kvm_vcpu_init.
Additionally it drops the unused memslot parameters.

	Signed-off-by: Andrew Jones <drjones@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f5dd4ccf5552d71a817d0ec97481e4a71425a038)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/aarch64/processor.c
diff --cc tools/testing/selftests/kvm/lib/aarch64/processor.c
index c278e2f68b10,4b0759ab7cc7..000000000000
--- a/tools/testing/selftests/kvm/lib/aarch64/processor.c
+++ b/tools/testing/selftests/kvm/lib/aarch64/processor.c
@@@ -235,28 -235,21 +235,39 @@@ struct kvm_vm *vm_create_default(uint32
  	return vm;
  }
  
++<<<<<<< HEAD
 +void vm_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid, void *guest_code)
 +{
 +	size_t stack_size = vm->page_size == 4096 ?
 +					DEFAULT_STACK_PGS * vm->page_size :
 +					vm->page_size;
 +	uint64_t stack_vaddr = vm_vaddr_alloc(vm, stack_size,
 +					DEFAULT_ARM64_GUEST_STACK_VADDR_MIN, 0, 0);
 +
 +	vm_vcpu_add(vm, vcpuid, 0, 0);
 +
 +	set_reg(vm, vcpuid, ARM64_CORE_REG(sp_el1), stack_vaddr + stack_size);
 +	set_reg(vm, vcpuid, ARM64_CORE_REG(regs.pc), (uint64_t)guest_code);
 +}
 +
 +void vcpu_setup(struct kvm_vm *vm, int vcpuid, int pgd_memslot, int gdt_memslot)
++=======
+ void aarch64_vcpu_setup(struct kvm_vm *vm, int vcpuid, struct kvm_vcpu_init *init)
++>>>>>>> f5dd4ccf5552 (kvm: selftests: introduce aarch64_vcpu_setup)
  {
- 	struct kvm_vcpu_init init;
+ 	struct kvm_vcpu_init default_init = { .target = -1, };
  	uint64_t sctlr_el1, tcr_el1;
  
- 	memset(&init, 0, sizeof(init));
- 	init.target = KVM_ARM_TARGET_GENERIC_V8;
- 	vcpu_ioctl(vm, vcpuid, KVM_ARM_VCPU_INIT, &init);
+ 	if (!init)
+ 		init = &default_init;
+ 
+ 	if (init->target == -1) {
+ 		struct kvm_vcpu_init preferred;
+ 		vm_ioctl(vm, KVM_ARM_PREFERRED_TARGET, &preferred);
+ 		init->target = preferred.target;
+ 	}
+ 
+ 	vcpu_ioctl(vm, vcpuid, KVM_ARM_VCPU_INIT, init);
  
  	/*
  	 * Enable FP/ASIMD to avoid trapping when accessing Q0-Q15
@@@ -316,3 -309,19 +327,22 @@@ void vcpu_dump(FILE *stream, struct kvm
  	fprintf(stream, "%*spstate: 0x%.16lx pc: 0x%.16lx\n",
  		indent, "", pstate, pc);
  }
++<<<<<<< HEAD
++=======
+ 
+ void vm_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid, void *guest_code)
+ {
+ 	size_t stack_size = vm->page_size == 4096 ?
+ 					DEFAULT_STACK_PGS * vm->page_size :
+ 					vm->page_size;
+ 	uint64_t stack_vaddr = vm_vaddr_alloc(vm, stack_size,
+ 					DEFAULT_ARM64_GUEST_STACK_VADDR_MIN, 0, 0);
+ 
+ 	vm_vcpu_add(vm, vcpuid);
+ 	aarch64_vcpu_setup(vm, vcpuid, NULL);
+ 
+ 	set_reg(vm, vcpuid, ARM64_CORE_REG(sp_el1), stack_vaddr + stack_size);
+ 	set_reg(vm, vcpuid, ARM64_CORE_REG(regs.pc), (uint64_t)guest_code);
+ }
+ 
++>>>>>>> f5dd4ccf5552 (kvm: selftests: introduce aarch64_vcpu_setup)
diff --git a/tools/testing/selftests/kvm/include/aarch64/processor.h b/tools/testing/selftests/kvm/include/aarch64/processor.h
index 9ef2ab1a0c08..37f8129e1ea9 100644
--- a/tools/testing/selftests/kvm/include/aarch64/processor.h
+++ b/tools/testing/selftests/kvm/include/aarch64/processor.h
@@ -52,4 +52,6 @@ static inline void set_reg(struct kvm_vm *vm, uint32_t vcpuid, uint64_t id, uint
 	vcpu_ioctl(vm, vcpuid, KVM_SET_ONE_REG, &reg);
 }
 
+void aarch64_vcpu_setup(struct kvm_vm *vm, int vcpuid, struct kvm_vcpu_init *init);
+
 #endif /* SELFTEST_KVM_PROCESSOR_H */
* Unmerged path tools/testing/selftests/kvm/lib/aarch64/processor.c
