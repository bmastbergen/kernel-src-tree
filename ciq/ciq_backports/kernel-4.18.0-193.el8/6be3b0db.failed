xfrm: policy: add inexact policy search tree infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit 6be3b0db6db82cf056a72cc18042048edd27f8ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6be3b0db.failed

At this time inexact policies are all searched in-order until the first
match is found.  After removal of the flow cache, this resolution has
to be performed for every packetm resulting in major slowdown when
number of inexact policies is high.

This adds infrastructure to later sort inexact policies into a tree.
This only introduces a single class: any:any.

Next patch will add a search tree to pre-sort policies that
have a fixed daddr/prefixlen, so in this patch the any:any class
will still be used for all policies.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 6be3b0db6db82cf056a72cc18042048edd27f8ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,4eb12e9b40c2..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -45,6 -46,37 +45,40 @@@ struct xfrm_flo 
  	u8 flags;
  };
  
++<<<<<<< HEAD
++=======
+ /* prefixes smaller than this are stored in lists, not trees. */
+ #define INEXACT_PREFIXLEN_IPV4	16
+ #define INEXACT_PREFIXLEN_IPV6	48
+ struct xfrm_pol_inexact_key {
+ 	possible_net_t net;
+ 	u32 if_id;
+ 	u16 family;
+ 	u8 dir, type;
+ };
+ 
+ struct xfrm_pol_inexact_bin {
+ 	struct xfrm_pol_inexact_key k;
+ 	struct rhash_head head;
+ 	/* list containing '*:*' policies */
+ 	struct hlist_head hhead;
+ 
+ 	/* slow path below */
+ 	struct list_head inexact_bins;
+ 	struct rcu_head rcu;
+ };
+ 
+ enum xfrm_pol_inexact_candidate_type {
+ 	XFRM_POL_CAND_ANY,
+ 
+ 	XFRM_POL_CAND_MAX,
+ };
+ 
+ struct xfrm_pol_inexact_candidates {
+ 	struct hlist_head *res[XFRM_POL_CAND_MAX];
+ };
+ 
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  static DEFINE_SPINLOCK(xfrm_if_cb_lock);
  static struct xfrm_if_cb const __rcu *xfrm_if_cb __read_mostly;
  
@@@ -64,6 -99,25 +98,28 @@@ static void __xfrm_policy_link(struct x
  static struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,
  						int dir);
  
++<<<<<<< HEAD
++=======
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family, u8 dir,
+ 			   u32 if_id);
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup_rcu(struct net *net,
+ 			       u8 type, u16 family, u8 dir, u32 if_id);
+ static struct xfrm_policy *
+ xfrm_policy_insert_list(struct hlist_head *chain, struct xfrm_policy *policy,
+ 			bool excl);
+ static void xfrm_policy_insert_inexact_list(struct hlist_head *chain,
+ 					    struct xfrm_policy *policy);
+ 
+ static bool
+ xfrm_policy_find_inexact_candidates(struct xfrm_pol_inexact_candidates *cand,
+ 				    struct xfrm_pol_inexact_bin *b,
+ 				    const xfrm_address_t *saddr,
+ 				    const xfrm_address_t *daddr);
+ 
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  static inline bool xfrm_pol_hold_rcu(struct xfrm_policy *policy)
  {
  	return refcount_inc_not_zero(&policy->refcnt);
@@@ -560,6 -618,166 +616,169 @@@ static void xfrm_hash_resize(struct wor
  	mutex_unlock(&hash_resize_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ static void xfrm_hash_reset_inexact_table(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *b;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry(b, &net->xfrm.inexact_bins, inexact_bins)
+ 		INIT_HLIST_HEAD(&b->hhead);
+ }
+ 
+ /* Make sure *pol can be inserted into fastbin.
+  * Useful to check that later insert requests will be sucessful
+  * (provided xfrm_policy_lock is held throughout).
+  */
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_alloc_bin(const struct xfrm_policy *pol, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *prev;
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = pol->family,
+ 		.type = pol->type,
+ 		.dir = dir,
+ 		.if_id = pol->if_id,
+ 	};
+ 	struct net *net = xp_net(pol);
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	write_pnet(&k.net, net);
+ 	bin = rhashtable_lookup_fast(&xfrm_policy_inexact_table, &k,
+ 				     xfrm_pol_inexact_params);
+ 	if (bin)
+ 		return bin;
+ 
+ 	bin = kzalloc(sizeof(*bin), GFP_ATOMIC);
+ 	if (!bin)
+ 		return NULL;
+ 
+ 	bin->k = k;
+ 	INIT_HLIST_HEAD(&bin->hhead);
+ 
+ 	prev = rhashtable_lookup_get_insert_key(&xfrm_policy_inexact_table,
+ 						&bin->k, &bin->head,
+ 						xfrm_pol_inexact_params);
+ 	if (!prev) {
+ 		list_add(&bin->inexact_bins, &net->xfrm.inexact_bins);
+ 		return bin;
+ 	}
+ 
+ 	kfree(bin);
+ 
+ 	return IS_ERR(prev) ? NULL : prev;
+ }
+ 
+ static bool xfrm_pol_inexact_addr_use_any_list(const xfrm_address_t *addr,
+ 					       int family, u8 prefixlen)
+ {
+ 	if (xfrm_addr_any(addr, family))
+ 		return true;
+ 
+ 	if (family == AF_INET6 && prefixlen < INEXACT_PREFIXLEN_IPV6)
+ 		return true;
+ 
+ 	if (family == AF_INET && prefixlen < INEXACT_PREFIXLEN_IPV4)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool
+ xfrm_policy_inexact_insert_use_any_list(const struct xfrm_policy *policy)
+ {
+ 	const xfrm_address_t *addr;
+ 	bool saddr_any, daddr_any;
+ 	u8 prefixlen;
+ 
+ 	addr = &policy->selector.saddr;
+ 	prefixlen = policy->selector.prefixlen_s;
+ 
+ 	saddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	addr = &policy->selector.daddr;
+ 	prefixlen = policy->selector.prefixlen_d;
+ 	daddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	return saddr_any && daddr_any;
+ }
+ 
+ static void __xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b, bool net_exit)
+ {
+ 	if (!hlist_empty(&b->hhead)) {
+ 		WARN_ON_ONCE(net_exit);
+ 		return;
+ 	}
+ 
+ 	if (rhashtable_remove_fast(&xfrm_policy_inexact_table, &b->head,
+ 				   xfrm_pol_inexact_params) == 0) {
+ 		list_del(&b->inexact_bins);
+ 		kfree_rcu(b, rcu);
+ 	}
+ }
+ 
+ static void xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b)
+ {
+ 	struct net *net = read_pnet(&b->k.net);
+ 
+ 	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
+ 	__xfrm_policy_inexact_prune_bin(b, false);
+ 	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ }
+ 
+ static void __xfrm_policy_inexact_flush(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *t;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry_safe(bin, t, &net->xfrm.inexact_bins, inexact_bins)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_inexact_insert(struct xfrm_policy *policy, u8 dir, int excl)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 	struct xfrm_policy *delpol;
+ 	struct hlist_head *chain;
+ 	struct net *net;
+ 
+ 	bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 	if (!bin)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	if (xfrm_policy_inexact_insert_use_any_list(policy)) {
+ 		chain = &bin->hhead;
+ 		goto insert_to_list;
+ 	}
+ 
+ 	chain = &bin->hhead;
+ insert_to_list:
+ 	delpol = xfrm_policy_insert_list(chain, policy, excl);
+ 	if (delpol && excl) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-EEXIST);
+ 	}
+ 
+ 	chain = &net->xfrm.policy_inexact[dir];
+ 	xfrm_policy_insert_inexact_list(chain, policy);
+ 
+ 	if (delpol)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 
+ 	return delpol;
+ }
+ 
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  static void xfrm_hash_rebuild(struct work_struct *work)
  {
  	struct net *net = container_of(work, struct net,
@@@ -588,9 -806,48 +807,50 @@@
  	} while (read_seqretry(&net->xfrm.policy_hthresh.lock, seq));
  
  	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
++<<<<<<< HEAD
 +	write_seqcount_begin(&xfrm_policy_hash_generation);
++=======
+ 
+ 	/* make sure that we can insert the indirect policies again before
+ 	 * we start with destructive action.
+ 	 */
+ 	list_for_each_entry(policy, &net->xfrm.policy_all, walk.all) {
+ 		struct xfrm_pol_inexact_bin *bin;
+ 		u8 dbits, sbits;
+ 
+ 		dir = xfrm_policy_id2dir(policy->index);
+ 		if (policy->walk.dead || dir >= XFRM_POLICY_MAX)
+ 			continue;
+ 
+ 		if ((dir & XFRM_POLICY_MASK) == XFRM_POLICY_OUT) {
+ 			if (policy->family == AF_INET) {
+ 				dbits = rbits4;
+ 				sbits = lbits4;
+ 			} else {
+ 				dbits = rbits6;
+ 				sbits = lbits6;
+ 			}
+ 		} else {
+ 			if (policy->family == AF_INET) {
+ 				dbits = lbits4;
+ 				sbits = rbits4;
+ 			} else {
+ 				dbits = lbits6;
+ 				sbits = rbits6;
+ 			}
+ 		}
+ 
+ 		if (policy->selector.prefixlen_d < dbits ||
+ 		    policy->selector.prefixlen_s < sbits)
+ 			continue;
+ 
+ 		bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 		if (!bin)
+ 			goto out_unlock;
+ 	}
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  
  	/* reset the bydst and inexact table in all directions */
 -	xfrm_hash_reset_inexact_table(net);
 -
  	for (dir = 0; dir < XFRM_POLICY_MAX; dir++) {
  		INIT_HLIST_HEAD(&net->xfrm.policy_inexact[dir]);
  		hmask = net->xfrm.policy_bydst[dir].hmask;
@@@ -637,7 -899,8 +897,12 @@@
  			hlist_add_head_rcu(&policy->bydst, chain);
  	}
  
++<<<<<<< HEAD
 +	write_seqcount_end(&xfrm_policy_hash_generation);
++=======
+ out_unlock:
+ 	__xfrm_policy_inexact_flush(net);
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
  
  	mutex_unlock(&hash_resize_mutex);
@@@ -741,6 -1004,91 +1006,94 @@@ static bool xfrm_policy_mark_match(stru
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static u32 xfrm_pol_bin_key(const void *data, u32 len, u32 seed)
+ {
+ 	const struct xfrm_pol_inexact_key *k = data;
+ 	u32 a = k->type << 24 | k->dir << 16 | k->family;
+ 
+ 	return jhash_3words(a, k->if_id, net_hash_mix(read_pnet(&k->net)),
+ 			    seed);
+ }
+ 
+ static u32 xfrm_pol_bin_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct xfrm_pol_inexact_bin *b = data;
+ 
+ 	return xfrm_pol_bin_key(&b->k, 0, seed);
+ }
+ 
+ static int xfrm_pol_bin_cmp(struct rhashtable_compare_arg *arg,
+ 			    const void *ptr)
+ {
+ 	const struct xfrm_pol_inexact_key *key = arg->key;
+ 	const struct xfrm_pol_inexact_bin *b = ptr;
+ 	int ret;
+ 
+ 	if (!net_eq(read_pnet(&b->k.net), read_pnet(&key->net)))
+ 		return -1;
+ 
+ 	ret = b->k.dir ^ key->dir;
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = b->k.type ^ key->type;
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = b->k.family ^ key->family;
+ 	if (ret)
+ 		return ret;
+ 
+ 	return b->k.if_id ^ key->if_id;
+ }
+ 
+ static const struct rhashtable_params xfrm_pol_inexact_params = {
+ 	.head_offset		= offsetof(struct xfrm_pol_inexact_bin, head),
+ 	.hashfn			= xfrm_pol_bin_key,
+ 	.obj_hashfn		= xfrm_pol_bin_obj,
+ 	.obj_cmpfn		= xfrm_pol_bin_cmp,
+ 	.automatic_shrinking	= true,
+ };
+ 
+ static void xfrm_policy_insert_inexact_list(struct hlist_head *chain,
+ 					    struct xfrm_policy *policy)
+ {
+ 	struct xfrm_policy *pol, *delpol = NULL;
+ 	struct hlist_node *newpos = NULL;
+ 	int i = 0;
+ 
+ 	hlist_for_each_entry(pol, chain, bydst_inexact_list) {
+ 		if (pol->type == policy->type &&
+ 		    pol->if_id == policy->if_id &&
+ 		    !selector_cmp(&pol->selector, &policy->selector) &&
+ 		    xfrm_policy_mark_match(policy, pol) &&
+ 		    xfrm_sec_ctx_match(pol->security, policy->security) &&
+ 		    !WARN_ON(delpol)) {
+ 			delpol = pol;
+ 			if (policy->priority > pol->priority)
+ 				continue;
+ 		} else if (policy->priority >= pol->priority) {
+ 			newpos = &pol->bydst_inexact_list;
+ 			continue;
+ 		}
+ 		if (delpol)
+ 			break;
+ 	}
+ 
+ 	if (newpos)
+ 		hlist_add_behind_rcu(&policy->bydst_inexact_list, newpos);
+ 	else
+ 		hlist_add_head_rcu(&policy->bydst_inexact_list, chain);
+ 
+ 	hlist_for_each_entry(pol, chain, bydst_inexact_list) {
+ 		pol->pos = i;
+ 		i++;
+ 	}
+ }
+ 
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  static struct xfrm_policy *xfrm_policy_insert_list(struct hlist_head *chain,
  						   struct xfrm_policy *policy,
  						   bool excl)
@@@ -835,28 -1206,50 +1211,71 @@@ struct xfrm_policy *xfrm_policy_bysel_c
  	*err = 0;
  	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
  	chain = policy_hash_bysel(net, sel, sel->family, dir);
++<<<<<<< HEAD
 +	if (!chain)
 +		chain = &net->xfrm.policy_inexact[dir];
 +	ret = NULL;
 +	hlist_for_each_entry(pol, chain, bydst) {
 +		if (pol->type == type &&
 +		    pol->if_id == if_id &&
 +		    (mark & pol->mark.m) == pol->mark.v &&
 +		    !selector_cmp(sel, &pol->selector) &&
 +		    xfrm_sec_ctx_match(ctx, pol->security)) {
 +			xfrm_pol_hold(pol);
 +			if (delete) {
 +				*err = security_xfrm_policy_delete(
 +								pol->security);
 +				if (*err) {
 +					spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
 +					return pol;
 +				}
 +				__xfrm_policy_unlink(pol, dir);
++=======
+ 	if (!chain) {
+ 		struct xfrm_pol_inexact_candidates cand;
+ 		int i;
+ 
+ 		bin = xfrm_policy_inexact_lookup(net, type,
+ 						 sel->family, dir, if_id);
+ 		if (!bin) {
+ 			spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 			return NULL;
+ 		}
+ 
+ 		if (!xfrm_policy_find_inexact_candidates(&cand, bin,
+ 							 &sel->saddr,
+ 							 &sel->daddr)) {
+ 			spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 			return NULL;
+ 		}
+ 
+ 		pol = NULL;
+ 		for (i = 0; i < ARRAY_SIZE(cand.res); i++) {
+ 			struct xfrm_policy *tmp;
+ 
+ 			tmp = __xfrm_policy_bysel_ctx(cand.res[i], mark,
+ 						      if_id, type, dir,
+ 						      sel, ctx);
+ 			if (tmp && pol && tmp->pos < pol->pos)
+ 				pol = tmp;
+ 		}
+ 	} else {
+ 		pol = __xfrm_policy_bysel_ctx(chain, mark, if_id, type, dir,
+ 					      sel, ctx);
+ 	}
+ 
+ 	if (pol) {
+ 		xfrm_pol_hold(pol);
+ 		if (delete) {
+ 			*err = security_xfrm_policy_delete(pol->security);
+ 			if (*err) {
+ 				spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 				return pol;
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  			}
- 			ret = pol;
- 			break;
+ 			__xfrm_policy_unlink(pol, dir);
  		}
+ 		ret = pol;
  	}
  	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
  
@@@ -1066,14 -1462,125 +1487,133 @@@ static int xfrm_policy_match(const stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ xfrm_policy_find_inexact_candidates(struct xfrm_pol_inexact_candidates *cand,
+ 				    struct xfrm_pol_inexact_bin *b,
+ 				    const xfrm_address_t *saddr,
+ 				    const xfrm_address_t *daddr)
+ {
+ 	if (!b)
+ 		return false;
+ 
+ 	memset(cand, 0, sizeof(*cand));
+ 	cand->res[XFRM_POL_CAND_ANY] = &b->hhead;
+ 	return true;
+ }
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup_rcu(struct net *net, u8 type, u16 family,
+ 			       u8 dir, u32 if_id)
+ {
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = family,
+ 		.type = type,
+ 		.dir = dir,
+ 		.if_id = if_id,
+ 	};
+ 
+ 	write_pnet(&k.net, net);
+ 
+ 	return rhashtable_lookup(&xfrm_policy_inexact_table, &k,
+ 				 xfrm_pol_inexact_params);
+ }
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family,
+ 			   u8 dir, u32 if_id)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	rcu_read_lock();
+ 	bin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);
+ 	rcu_read_unlock();
+ 
+ 	return bin;
+ }
+ 
+ static struct xfrm_policy *
+ __xfrm_policy_eval_candidates(struct hlist_head *chain,
+ 			      struct xfrm_policy *prefer,
+ 			      const struct flowi *fl,
+ 			      u8 type, u16 family, int dir, u32 if_id)
+ {
+ 	u32 priority = prefer ? prefer->priority : ~0u;
+ 	struct xfrm_policy *pol;
+ 
+ 	if (!chain)
+ 		return NULL;
+ 
+ 	hlist_for_each_entry_rcu(pol, chain, bydst) {
+ 		int err;
+ 
+ 		if (pol->priority > priority)
+ 			break;
+ 
+ 		err = xfrm_policy_match(pol, fl, type, family, dir, if_id);
+ 		if (err) {
+ 			if (err != -ESRCH)
+ 				return ERR_PTR(err);
+ 
+ 			continue;
+ 		}
+ 
+ 		if (prefer) {
+ 			/* matches.  Is it older than *prefer? */
+ 			if (pol->priority == priority &&
+ 			    prefer->pos < pol->pos)
+ 				return prefer;
+ 		}
+ 
+ 		return pol;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_eval_candidates(struct xfrm_pol_inexact_candidates *cand,
+ 			    struct xfrm_policy *prefer,
+ 			    const struct flowi *fl,
+ 			    u8 type, u16 family, int dir, u32 if_id)
+ {
+ 	struct xfrm_policy *tmp;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(cand->res); i++) {
+ 		tmp = __xfrm_policy_eval_candidates(cand->res[i],
+ 						    prefer,
+ 						    fl, type, family, dir,
+ 						    if_id);
+ 		if (!tmp)
+ 			continue;
+ 
+ 		if (IS_ERR(tmp))
+ 			return tmp;
+ 		prefer = tmp;
+ 	}
+ 
+ 	return prefer;
+ }
+ 
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  static struct xfrm_policy *xfrm_policy_lookup_bytype(struct net *net, u8 type,
  						     const struct flowi *fl,
  						     u16 family, u8 dir,
  						     u32 if_id)
  {
++<<<<<<< HEAD
 +	int err;
++=======
+ 	struct xfrm_pol_inexact_candidates cand;
+ 	const xfrm_address_t *daddr, *saddr;
+ 	struct xfrm_pol_inexact_bin *bin;
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  	struct xfrm_policy *pol, *ret;
 +	const xfrm_address_t *daddr, *saddr;
  	struct hlist_head *chain;
  	unsigned int sequence;
  	u32 priority;
@@@ -1107,25 -1615,20 +1647,26 @@@
  			break;
  		}
  	}
++<<<<<<< HEAD
 +	chain = &net->xfrm.policy_inexact[dir];
 +	hlist_for_each_entry_rcu(pol, chain, bydst) {
 +		if ((pol->priority >= priority) && ret)
 +			break;
- 
- 		err = xfrm_policy_match(pol, fl, type, family, dir, if_id);
- 		if (err) {
- 			if (err == -ESRCH)
- 				continue;
- 			else {
- 				ret = ERR_PTR(err);
- 				goto fail;
- 			}
- 		} else {
- 			ret = pol;
- 			break;
- 		}
++=======
+ 	bin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);
+ 	if (!bin || !xfrm_policy_find_inexact_candidates(&cand, bin, saddr,
+ 							 daddr))
+ 		goto skip_inexact;
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
+ 
+ 	pol = xfrm_policy_eval_candidates(&cand, ret, fl, type,
+ 					  family, dir, if_id);
+ 	if (pol) {
+ 		ret = pol;
+ 		if (IS_ERR(pol))
+ 			goto fail;
  	}
  
 -skip_inexact:
  	if (read_seqcount_retry(&xfrm_policy_hash_generation, sequence))
  		goto retry;
  
@@@ -2859,6 -3362,7 +3400,10 @@@ out_byidx
  
  static void xfrm_policy_fini(struct net *net)
  {
++<<<<<<< HEAD
++=======
+ 	struct xfrm_pol_inexact_bin *b, *t;
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  	unsigned int sz;
  	int dir;
  
@@@ -2884,6 -3388,11 +3429,14 @@@
  	sz = (net->xfrm.policy_idx_hmask + 1) * sizeof(struct hlist_head);
  	WARN_ON(!hlist_empty(net->xfrm.policy_byidx));
  	xfrm_hash_free(net->xfrm.policy_byidx, sz);
++<<<<<<< HEAD
++=======
+ 
+ 	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
+ 	list_for_each_entry_safe(b, t, &net->xfrm.inexact_bins, inexact_bins)
+ 		__xfrm_policy_inexact_prune_bin(b, true);
+ 	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
++>>>>>>> 6be3b0db6db8 (xfrm: policy: add inexact policy search tree infrastructure)
  }
  
  static int __net_init xfrm_net_init(struct net *net)
diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index f1d2173cbfda..e611dc03fecf 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -589,6 +589,7 @@ struct xfrm_policy {
 	/* This lock only affects elements except for entry. */
 	rwlock_t		lock;
 	refcount_t		refcnt;
+	u32			pos;
 	struct timer_list	timer;
 
 	atomic_t		genid;
* Unmerged path net/xfrm/xfrm_policy.c
