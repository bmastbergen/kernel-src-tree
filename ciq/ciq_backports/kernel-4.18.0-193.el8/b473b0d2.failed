devlink: create a special NDO for getting the devlink instance

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit b473b0d23529cde6c825a592c035e9d910b19e21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b473b0d2.failed

Instead of iterating over all devlink ports add a NDO which
will return the devlink instance from the driver.

v2: add the netdev_to_devlink() helper (Michal)
v3: check that devlink has ops (Florian)
v4: hold devlink_mutex (Jiri)

	Suggested-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b473b0d23529cde6c825a592c035e9d910b19e21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index 17227e3008a8,58e83bd7a861..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -995,8 -941,7 +995,12 @@@ struct dev_ifalias 
  	char ifalias[];
  };
  
++<<<<<<< HEAD
 +struct net_device_ops_extended_rh {
 +};
++=======
+ struct devlink;
++>>>>>>> b473b0d23529 (devlink: create a special NDO for getting the devlink instance)
  
  /*
   * This structure defines the management hooks for network devices.
@@@ -1499,63 -1446,14 +1507,70 @@@ struct net_device_ops 
  						       struct sk_buff *skb);
  	void			(*ndo_set_rx_headroom)(struct net_device *dev,
  						       int needed_headroom);
 -	int			(*ndo_bpf)(struct net_device *dev,
 -					   struct netdev_bpf *bpf);
 -	int			(*ndo_xdp_xmit)(struct net_device *dev, int n,
 +	RH_KABI_EXCLUDE(int	(*ndo_bpf)(struct net_device *dev,
 +					   struct netdev_bpf *bpf))
 +	RH_KABI_EXCLUDE(int	(*ndo_xdp_xmit)(struct net_device *dev, int n,
  						struct xdp_frame **xdp,
++<<<<<<< HEAD
 +						u32 flags))
 +	RH_KABI_EXCLUDE(int	(*ndo_xsk_async_xmit)(struct net_device *dev,
 +						      u32 queue_id))
 +
 +	RH_KABI_USE(1, int	(*ndo_get_port_parent_id)(struct net_device *dev,
 +							  struct netdev_phys_item_id *ppid))
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
 +	RH_KABI_RESERVE(5)
 +	RH_KABI_RESERVE(6)
 +	RH_KABI_RESERVE(7)
 +	RH_KABI_RESERVE(8)
 +	RH_KABI_RESERVE(9)
 +	RH_KABI_RESERVE(10)
 +	RH_KABI_RESERVE(11)
 +	RH_KABI_RESERVE(12)
 +	RH_KABI_RESERVE(13)
 +	RH_KABI_RESERVE(14)
 +	RH_KABI_RESERVE(15)
 +	RH_KABI_RESERVE(16)
 +	RH_KABI_RESERVE(17)
 +	RH_KABI_RESERVE(18)
 +	RH_KABI_RESERVE(19)
 +	RH_KABI_RESERVE(20)
 +	RH_KABI_RESERVE(21)
 +	RH_KABI_RESERVE(22)
 +	RH_KABI_RESERVE(23)
 +	RH_KABI_RESERVE(24)
 +	RH_KABI_RESERVE(25)
 +	RH_KABI_RESERVE(26)
 +	RH_KABI_RESERVE(27)
 +	RH_KABI_RESERVE(28)
 +	RH_KABI_RESERVE(29)
 +	RH_KABI_RESERVE(30)
 +	RH_KABI_RESERVE(31)
 +	RH_KABI_RESERVE(32)
 +	RH_KABI_RESERVE(33)
 +	RH_KABI_RESERVE(34)
 +	RH_KABI_RESERVE(35)
 +	RH_KABI_RESERVE(36)
 +	RH_KABI_RESERVE(37)
 +	RH_KABI_RESERVE(38)
 +	RH_KABI_RESERVE(39)
 +	RH_KABI_RESERVE(40)
 +	RH_KABI_RESERVE(41)
 +	RH_KABI_RESERVE(42)
 +	RH_KABI_RESERVE(43)
 +	RH_KABI_RESERVE(44)
 +	RH_KABI_RESERVE(45)
 +	RH_KABI_RESERVE(46)
 +	RH_KABI_RESERVE(47)
 +	RH_KABI_SIZE_AND_EXTEND(net_device_ops_extended)
++=======
+ 						u32 flags);
+ 	int			(*ndo_xsk_async_xmit)(struct net_device *dev,
+ 						      u32 queue_id);
+ 	struct devlink *	(*ndo_get_devlink)(struct net_device *dev);
++>>>>>>> b473b0d23529 (devlink: create a special NDO for getting the devlink instance)
  };
  
  /**
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/devlink.h b/include/net/devlink.h
index 8bf1e1e1d3f3..63de99e09f04 100644
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@ -543,6 +543,15 @@ static inline struct devlink *priv_to_devlink(void *priv)
 	return container_of(priv, struct devlink, priv);
 }
 
+static inline struct devlink *netdev_to_devlink(struct net_device *dev)
+{
+#if IS_ENABLED(CONFIG_NET_DEVLINK)
+	if (dev->netdev_ops->ndo_get_devlink)
+		return dev->netdev_ops->ndo_get_devlink(dev);
+#endif
+	return NULL;
+}
+
 struct ib_device;
 
 #if IS_ENABLED(CONFIG_NET_DEVLINK)
diff --git a/net/core/devlink.c b/net/core/devlink.c
index 697c7c3684df..f642e918845d 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -6417,9 +6417,6 @@ static void __devlink_compat_running_version(struct devlink *devlink,
 	struct sk_buff *msg;
 	int rem, err;
 
-	if (!devlink->ops->info_get)
-		return;
-
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg)
 		return;
@@ -6451,55 +6448,36 @@ static void __devlink_compat_running_version(struct devlink *devlink,
 void devlink_compat_running_version(struct net_device *dev,
 				    char *buf, size_t len)
 {
-	struct devlink_port *devlink_port;
 	struct devlink *devlink;
 
 	mutex_lock(&devlink_mutex);
-	list_for_each_entry(devlink, &devlink_list, list) {
-		mutex_lock(&devlink->lock);
-		list_for_each_entry(devlink_port, &devlink->port_list, list) {
-			if (devlink_port->type == DEVLINK_PORT_TYPE_ETH &&
-			    devlink_port->type_dev == dev) {
-				__devlink_compat_running_version(devlink,
-								 buf, len);
-				mutex_unlock(&devlink->lock);
-				goto out;
-			}
-		}
-		mutex_unlock(&devlink->lock);
-	}
-out:
+	devlink = netdev_to_devlink(dev);
+	if (!devlink || !devlink->ops || !devlink->ops->info_get)
+		goto unlock_list;
+
+	mutex_lock(&devlink->lock);
+	__devlink_compat_running_version(devlink, buf, len);
+	mutex_unlock(&devlink->lock);
+unlock_list:
 	mutex_unlock(&devlink_mutex);
 }
 
 int devlink_compat_flash_update(struct net_device *dev, const char *file_name)
 {
-	struct devlink_port *devlink_port;
 	struct devlink *devlink;
+	int ret = -EOPNOTSUPP;
 
 	mutex_lock(&devlink_mutex);
-	list_for_each_entry(devlink, &devlink_list, list) {
-		mutex_lock(&devlink->lock);
-		list_for_each_entry(devlink_port, &devlink->port_list, list) {
-			int ret = -EOPNOTSUPP;
-
-			if (devlink_port->type != DEVLINK_PORT_TYPE_ETH ||
-			    devlink_port->type_dev != dev)
-				continue;
+	devlink = netdev_to_devlink(dev);
+	if (!devlink || !devlink->ops || !devlink->ops->flash_update)
+		goto unlock_list;
 
-			mutex_unlock(&devlink_mutex);
-			if (devlink->ops->flash_update)
-				ret = devlink->ops->flash_update(devlink,
-								 file_name,
-								 NULL, NULL);
-			mutex_unlock(&devlink->lock);
-			return ret;
-		}
-		mutex_unlock(&devlink->lock);
-	}
+	mutex_lock(&devlink->lock);
+	ret = devlink->ops->flash_update(devlink, file_name, NULL, NULL);
+	mutex_unlock(&devlink->lock);
+unlock_list:
 	mutex_unlock(&devlink_mutex);
-
-	return -EOPNOTSUPP;
+	return ret;
 }
 
 static int __init devlink_init(void)
