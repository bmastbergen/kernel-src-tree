dax: Convert dax_lock_mapping_entry to XArray

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 9f32d221301c3e754b24c77ab11bf793b19f51b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9f32d221.failed

Instead of always retrying when we slept, only retry if the page has
moved.

	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit 9f32d221301c3e754b24c77ab11bf793b19f51b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index 29113658577c,fc2745ca3308..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -523,37 -516,29 +517,43 @@@ bool dax_lock_mapping_entry(struct pag
  		 * otherwise we would not have a valid pfn_to_page()
  		 * translation.
  		 */
- 		inode = mapping->host;
- 		if (S_ISCHR(inode->i_mode)) {
- 			did_lock = true;
- 			break;
- 		}
+ 		if (S_ISCHR(mapping->host->i_mode))
+ 			return true;
  
- 		xa_lock_irq(&mapping->i_pages);
+ 		xas.xa = &mapping->i_pages;
+ 		xas_lock_irq(&xas);
  		if (mapping != page->mapping) {
- 			xa_unlock_irq(&mapping->i_pages);
+ 			xas_unlock_irq(&xas);
  			continue;
  		}
++<<<<<<< HEAD
 +		index = page->index;
 +
 +		entry = __get_unlocked_mapping_entry(mapping, index, &slot,
 +				entry_wait_revalidate);
 +		if (!entry) {
 +			xa_unlock_irq(&mapping->i_pages);
 +			break;
 +		} else if (IS_ERR(entry)) {
 +			xa_unlock_irq(&mapping->i_pages);
 +			WARN_ON_ONCE(PTR_ERR(entry) != -EAGAIN);
 +			continue;
++=======
+ 		xas_set(&xas, page->index);
+ 		entry = xas_load(&xas);
+ 		if (dax_is_locked(entry)) {
+ 			entry = get_unlocked_entry(&xas);
+ 			/* Did the page move while we slept? */
+ 			if (dax_to_pfn(entry) != page_to_pfn(page)) {
+ 				xas_unlock_irq(&xas);
+ 				continue;
+ 			}
++>>>>>>> 9f32d221301c (dax: Convert dax_lock_mapping_entry to XArray)
  		}
- 		lock_slot(mapping, slot);
- 		did_lock = true;
- 		xa_unlock_irq(&mapping->i_pages);
- 		break;
+ 		dax_lock_entry(&xas, entry);
+ 		xas_unlock_irq(&xas);
+ 		return true;
  	}
- 	rcu_read_unlock();
- 
- 	return did_lock;
  }
  
  void dax_unlock_mapping_entry(struct page *page)
* Unmerged path fs/dax.c
