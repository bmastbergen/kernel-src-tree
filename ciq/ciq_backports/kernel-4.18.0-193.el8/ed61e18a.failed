PM / Domains: Add GENPD_FLAG_RPM_ALWAYS_ON flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Leonard Crestez <leonard.crestez@nxp.com>
commit ed61e18a4b4e445ae8622a4faec6a259601cc4a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ed61e18a.failed

This is for power domains which can only be powered off for suspend but
not as part of runtime PM.

	Suggested-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ed61e18a4b4e445ae8622a4faec6a259601cc4a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/domain.c
#	include/linux/pm_domain.h
diff --cc drivers/base/power/domain.c
index ae411ec1ee12,a887575fafa9..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -128,6 -129,8 +128,11 @@@ static const struct genpd_lock_ops genp
  #define genpd_is_irq_safe(genpd)	(genpd->flags & GENPD_FLAG_IRQ_SAFE)
  #define genpd_is_always_on(genpd)	(genpd->flags & GENPD_FLAG_ALWAYS_ON)
  #define genpd_is_active_wakeup(genpd)	(genpd->flags & GENPD_FLAG_ACTIVE_WAKEUP)
++<<<<<<< HEAD
++=======
+ #define genpd_is_cpu_domain(genpd)	(genpd->flags & GENPD_FLAG_CPU_DOMAIN)
+ #define genpd_is_rpm_always_on(genpd)	(genpd->flags & GENPD_FLAG_RPM_ALWAYS_ON)
++>>>>>>> ed61e18a4b4e (PM / Domains: Add GENPD_FLAG_RPM_ALWAYS_ON flag)
  
  static inline bool irq_safe_dev_in_no_sleep_domain(struct device *dev,
  		const struct generic_pm_domain *genpd)
@@@ -1763,9 -1817,14 +1770,10 @@@ int pm_genpd_init(struct generic_pm_dom
  	}
  
  	/* Always-on domains must be powered on at initialization. */
- 	if (genpd_is_always_on(genpd) && !genpd_status_on(genpd))
+ 	if ((genpd_is_always_on(genpd) || genpd_is_rpm_always_on(genpd)) &&
+ 			!genpd_status_on(genpd))
  		return -EINVAL;
  
 -	if (genpd_is_cpu_domain(genpd) &&
 -	    !zalloc_cpumask_var(&genpd->cpus, GFP_KERNEL))
 -		return -ENOMEM;
 -
  	/* Use only one "off" state if there were no states declared */
  	if (genpd->state_count == 0) {
  		ret = genpd_set_default_power_state(genpd);
diff --cc include/linux/pm_domain.h
index 4cccffdf912a,b21f35f0ee2e..000000000000
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@@ -42,11 -43,26 +42,32 @@@
   * GENPD_FLAG_ACTIVE_WAKEUP:	Instructs genpd to keep the PM domain powered
   *				on, in case any of its attached devices is used
   *				in the wakeup path to serve system wakeups.
++<<<<<<< HEAD
++=======
+  *
+  * GENPD_FLAG_CPU_DOMAIN:	Instructs genpd that it should expect to get
+  *				devices attached, which may belong to CPUs or
+  *				possibly have subdomains with CPUs attached.
+  *				This flag enables the genpd backend driver to
+  *				deploy idle power management support for CPUs
+  *				and groups of CPUs. Note that, the backend
+  *				driver must then comply with the so called,
+  *				last-man-standing algorithm, for the CPUs in the
+  *				PM domain.
+  *
+  * GENPD_FLAG_RPM_ALWAYS_ON:	Instructs genpd to always keep the PM domain
+  *				powered on except for system suspend.
++>>>>>>> ed61e18a4b4e (PM / Domains: Add GENPD_FLAG_RPM_ALWAYS_ON flag)
   */
  #define GENPD_FLAG_PM_CLK	 (1U << 0)
  #define GENPD_FLAG_IRQ_SAFE	 (1U << 1)
  #define GENPD_FLAG_ALWAYS_ON	 (1U << 2)
  #define GENPD_FLAG_ACTIVE_WAKEUP (1U << 3)
++<<<<<<< HEAD
++=======
+ #define GENPD_FLAG_CPU_DOMAIN	 (1U << 4)
+ #define GENPD_FLAG_RPM_ALWAYS_ON (1U << 5)
++>>>>>>> ed61e18a4b4e (PM / Domains: Add GENPD_FLAG_RPM_ALWAYS_ON flag)
  
  enum gpd_status {
  	GPD_STATE_ACTIVE = 0,	/* PM domain is active */
* Unmerged path drivers/base/power/domain.c
* Unmerged path include/linux/pm_domain.h
