net: phy: aquantia: add suspend / resume callbacks for AQR107 family

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] phy: aquantia: add suspend / resume callbacks for AQR107 family (Petr Oros) [1772010]
Rebuild_FUZZ: 96.18%
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit ac9e81c230eb4b5f849768379aff9c1d4f1dccea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ac9e81c2.failed

Add suspend / resume callbacks for AQR107 family. Suspend powers down
the complete chip except MDIO and internal CPU.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac9e81c230eb4b5f849768379aff9c1d4f1dccea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/aquantia_main.c
diff --cc drivers/net/phy/aquantia_main.c
index 3d4b30e24149,be5204a1fd13..000000000000
--- a/drivers/net/phy/aquantia_main.c
+++ b/drivers/net/phy/aquantia_main.c
@@@ -157,6 -195,301 +157,304 @@@ static int aqr_read_status(struct phy_d
  	return genphy_c45_read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ static int aqr107_read_downshift_event(struct phy_device *phydev)
+ {
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_INT_STATUS1);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	return !!(val & MDIO_AN_TX_VEND_INT_STATUS1_DOWNSHIFT);
+ }
+ 
+ static int aqr107_read_rate(struct phy_device *phydev)
+ {
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_STATUS1);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	switch (FIELD_GET(MDIO_AN_TX_VEND_STATUS1_RATE_MASK, val)) {
+ 	case MDIO_AN_TX_VEND_STATUS1_10BASET:
+ 		phydev->speed = SPEED_10;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_100BASETX:
+ 		phydev->speed = SPEED_100;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_1000BASET:
+ 		phydev->speed = SPEED_1000;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_2500BASET:
+ 		phydev->speed = SPEED_2500;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_5000BASET:
+ 		phydev->speed = SPEED_5000;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_10GBASET:
+ 		phydev->speed = SPEED_10000;
+ 		break;
+ 	default:
+ 		phydev->speed = SPEED_UNKNOWN;
+ 		break;
+ 	}
+ 
+ 	if (val & MDIO_AN_TX_VEND_STATUS1_FULL_DUPLEX)
+ 		phydev->duplex = DUPLEX_FULL;
+ 	else
+ 		phydev->duplex = DUPLEX_HALF;
+ 
+ 	return 0;
+ }
+ 
+ static int aqr107_read_status(struct phy_device *phydev)
+ {
+ 	int val, ret;
+ 
+ 	ret = aqr_read_status(phydev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!phydev->link || phydev->autoneg == AUTONEG_DISABLE)
+ 		return 0;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_PHYXS_VEND_IF_STATUS);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	switch (FIELD_GET(MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK, val)) {
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_KR:
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_XFI:
+ 		phydev->interface = PHY_INTERFACE_MODE_10GKR;
+ 		break;
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_SGMII:
+ 		phydev->interface = PHY_INTERFACE_MODE_SGMII;
+ 		break;
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_OCSGMII:
+ 		phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+ 		break;
+ 	default:
+ 		phydev->interface = PHY_INTERFACE_MODE_NA;
+ 		break;
+ 	}
+ 
+ 	val = aqr107_read_downshift_event(phydev);
+ 	if (val <= 0)
+ 		return val;
+ 
+ 	phydev_warn(phydev, "Downshift occurred! Cabling may be defective.\n");
+ 
+ 	/* Read downshifted rate from vendor register */
+ 	return aqr107_read_rate(phydev);
+ }
+ 
+ static int aqr107_get_downshift(struct phy_device *phydev, u8 *data)
+ {
+ 	int val, cnt, enable;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	enable = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_EN, val);
+ 	cnt = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);
+ 
+ 	*data = enable && cnt ? cnt : DOWNSHIFT_DEV_DISABLE;
+ 
+ 	return 0;
+ }
+ 
+ static int aqr107_set_downshift(struct phy_device *phydev, u8 cnt)
+ {
+ 	int val = 0;
+ 
+ 	if (!FIELD_FIT(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt))
+ 		return -E2BIG;
+ 
+ 	if (cnt != DOWNSHIFT_DEV_DISABLE) {
+ 		val = MDIO_AN_VEND_PROV_DOWNSHIFT_EN;
+ 		val |= FIELD_PREP(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt);
+ 	}
+ 
+ 	return phy_modify_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV,
+ 			      MDIO_AN_VEND_PROV_DOWNSHIFT_EN |
+ 			      MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);
+ }
+ 
+ static int aqr107_get_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, void *data)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		return aqr107_get_downshift(phydev, data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int aqr107_set_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, const void *data)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		return aqr107_set_downshift(phydev, *(const u8 *)data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ /* If we configure settings whilst firmware is still initializing the chip,
+  * then these settings may be overwritten. Therefore make sure chip
+  * initialization has completed. Use presence of the firmware ID as
+  * indicator for initialization having completed.
+  * The chip also provides a "reset completed" bit, but it's cleared after
+  * read. Therefore function would time out if called again.
+  */
+ static int aqr107_wait_reset_complete(struct phy_device *phydev)
+ {
+ 	int val, retries = 100;
+ 
+ 	do {
+ 		val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);
+ 		if (val < 0)
+ 			return val;
+ 		msleep(20);
+ 	} while (!val && --retries);
+ 
+ 	return val ? 0 : -ETIMEDOUT;
+ }
+ 
+ static void aqr107_chip_info(struct phy_device *phydev)
+ {
+ 	u8 fw_major, fw_minor, build_id, prov_id;
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);
+ 	if (val < 0)
+ 		return;
+ 
+ 	fw_major = FIELD_GET(VEND1_GLOBAL_FW_ID_MAJOR, val);
+ 	fw_minor = FIELD_GET(VEND1_GLOBAL_FW_ID_MINOR, val);
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT1);
+ 	if (val < 0)
+ 		return;
+ 
+ 	build_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_FW_BUILD_ID, val);
+ 	prov_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_PROV_ID, val);
+ 
+ 	phydev_dbg(phydev, "FW %u.%u, Build %u, Provisioning %u\n",
+ 		   fw_major, fw_minor, build_id, prov_id);
+ }
+ 
+ static int aqr107_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Check that the PHY interface type is compatible */
+ 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_10GKR)
+ 		return -ENODEV;
+ 
+ 	ret = aqr107_wait_reset_complete(phydev);
+ 	if (!ret)
+ 		aqr107_chip_info(phydev);
+ 
+ 	/* ensure that a latched downshift event is cleared */
+ 	aqr107_read_downshift_event(phydev);
+ 
+ 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+ }
+ 
+ static int aqcs109_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Check that the PHY interface type is compatible */
+ 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX)
+ 		return -ENODEV;
+ 
+ 	ret = aqr107_wait_reset_complete(phydev);
+ 	if (!ret)
+ 		aqr107_chip_info(phydev);
+ 
+ 	/* AQCS109 belongs to a chip family partially supporting 10G and 5G.
+ 	 * PMA speed ability bits are the same for all members of the family,
+ 	 * AQCS109 however supports speeds up to 2.5G only.
+ 	 */
+ 	ret = phy_set_max_speed(phydev, SPEED_2500);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* ensure that a latched downshift event is cleared */
+ 	aqr107_read_downshift_event(phydev);
+ 
+ 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+ }
+ 
+ static void aqr107_link_change_notify(struct phy_device *phydev)
+ {
+ 	u8 fw_major, fw_minor;
+ 	bool downshift, short_reach, afr;
+ 	int mode, val;
+ 
+ 	if (phydev->state != PHY_RUNNING || phydev->autoneg == AUTONEG_DISABLE)
+ 		return;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT1);
+ 	/* call failed or link partner is no Aquantia PHY */
+ 	if (val < 0 || !(val & MDIO_AN_RX_LP_STAT1_AQ_PHY))
+ 		return;
+ 
+ 	short_reach = val & MDIO_AN_RX_LP_STAT1_SHORT_REACH;
+ 	downshift = val & MDIO_AN_RX_LP_STAT1_AQRATE_DOWNSHIFT;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT4);
+ 	if (val < 0)
+ 		return;
+ 
+ 	fw_major = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MAJOR, val);
+ 	fw_minor = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MINOR, val);
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_VEND_STAT3);
+ 	if (val < 0)
+ 		return;
+ 
+ 	afr = val & MDIO_AN_RX_VEND_STAT3_AFR;
+ 
+ 	phydev_dbg(phydev, "Link partner is Aquantia PHY, FW %u.%u%s%s%s\n",
+ 		   fw_major, fw_minor,
+ 		   short_reach ? ", short reach mode" : "",
+ 		   downshift ? ", fast-retrain downshift advertised" : "",
+ 		   afr ? ", fast reframe advertised" : "");
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT9);
+ 	if (val < 0)
+ 		return;
+ 
+ 	mode = FIELD_GET(VEND1_GLOBAL_RSVD_STAT9_MODE, val);
+ 	if (mode == VEND1_GLOBAL_RSVD_STAT9_1000BT2)
+ 		phydev_info(phydev, "Aquantia 1000Base-T2 mode active\n");
+ }
+ 
+ static int aqr107_suspend(struct phy_device *phydev)
+ {
+ 	return phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MDIO_CTRL1,
+ 				MDIO_CTRL1_LPOWER);
+ }
+ 
+ static int aqr107_resume(struct phy_device *phydev)
+ {
+ 	return phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MDIO_CTRL1,
+ 				  MDIO_CTRL1_LPOWER);
+ }
+ 
++>>>>>>> ac9e81c230eb (net: phy: aquantia: add suspend / resume callbacks for AQR107 family)
  static struct phy_driver aqr_driver[] = {
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQ1202),
@@@ -211,7 -538,15 +509,16 @@@
  	.config_aneg    = aqr_config_aneg,
  	.config_intr	= aqr_config_intr,
  	.ack_interrupt	= aqr_ack_interrupt,
++<<<<<<< HEAD
 +	.read_status	= aqr_read_status,
++=======
+ 	.read_status	= aqr107_read_status,
+ 	.get_tunable    = aqr107_get_tunable,
+ 	.set_tunable    = aqr107_set_tunable,
+ 	.suspend	= aqr107_suspend,
+ 	.resume		= aqr107_resume,
+ 	.link_change_notify = aqr107_link_change_notify,
++>>>>>>> ac9e81c230eb (net: phy: aquantia: add suspend / resume callbacks for AQR107 family)
  },
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQCS109),
@@@ -221,7 -555,15 +528,16 @@@
  	.config_aneg    = aqr_config_aneg,
  	.config_intr	= aqr_config_intr,
  	.ack_interrupt	= aqr_ack_interrupt,
++<<<<<<< HEAD
 +	.read_status	= aqr_read_status,
++=======
+ 	.read_status	= aqr107_read_status,
+ 	.get_tunable    = aqr107_get_tunable,
+ 	.set_tunable    = aqr107_set_tunable,
+ 	.suspend	= aqr107_suspend,
+ 	.resume		= aqr107_resume,
+ 	.link_change_notify = aqr107_link_change_notify,
++>>>>>>> ac9e81c230eb (net: phy: aquantia: add suspend / resume callbacks for AQR107 family)
  },
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQR405),
* Unmerged path drivers/net/phy/aquantia_main.c
