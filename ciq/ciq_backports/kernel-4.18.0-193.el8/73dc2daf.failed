s390/qeth: add TX multiqueue support for OSA devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 73dc2daf110f4a4e777003b22dda09bb40948fc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/73dc2daf.failed

This adds trivial support for multiple TX queues on OSA-style devices
(both real HW and z/VM NICs). For now we expose the driver's existing
QoS mechanism via .ndo_select_queue, and adjust the number of available
TX queues when qeth_update_from_chp_desc() detects that the
HW configuration has changed.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 73dc2daf110f4a4e777003b22dda09bb40948fc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core.h
index 3f448d239de7,4989dc7b58c1..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -915,18 -942,7 +915,22 @@@ static inline int qeth_send_simple_seta
  						 data, QETH_PROT_IPV6);
  }
  
++<<<<<<< HEAD
 +int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb,
 +			    int ipv);
 +static inline struct qeth_qdio_out_q *qeth_get_tx_queue(struct qeth_card *card,
 +							struct sk_buff *skb,
 +							int ipv, int cast_type)
 +{
 +	if (IS_IQD(card) && cast_type != RTN_UNICAST)
 +		return card->qdio.out_qs[card->qdio.no_out_queues - 1];
 +	if (!card->qdio.do_prio_queueing)
 +		return card->qdio.out_qs[card->qdio.default_out_queue];
 +	return card->qdio.out_qs[qeth_get_priority_queue(card, skb, ipv)];
 +}
++=======
+ int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb);
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  
  extern struct qeth_discipline qeth_l2_discipline;
  extern struct qeth_discipline qeth_l3_discipline;
diff --cc drivers/s390/net/qeth_core_main.c
index 67e5e3d26068,6640616a8439..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -3611,7 -3590,8 +3604,12 @@@ static void qeth_qdio_output_handler(st
  	if (card->info.type != QETH_CARD_TYPE_IQD)
  		qeth_check_outbound_queue(queue);
  
++<<<<<<< HEAD
 +	netif_wake_queue(queue->card->dev);
++=======
+ 	txq = IS_IQD(card) ? qeth_iqd_translate_txq(dev, __queue) : __queue;
+ 	netif_wake_subqueue(dev, txq);
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  }
  
  /* We cannot use outbound queue 3 for unicast packets on HiperSockets */
@@@ -5590,8 -5552,12 +5587,11 @@@ static struct net_device *qeth_alloc_ne
  
  	switch (card->info.type) {
  	case QETH_CARD_TYPE_IQD:
 -		dev = alloc_netdev_mqs(0, "hsi%d", NET_NAME_UNKNOWN,
 -				       ether_setup, QETH_MAX_QUEUES, 1);
 +		dev = alloc_netdev(0, "hsi%d", NET_NAME_UNKNOWN, ether_setup);
  		break;
+ 	case QETH_CARD_TYPE_OSM:
+ 		dev = alloc_etherdev(0);
+ 		break;
  	case QETH_CARD_TYPE_OSN:
  		dev = alloc_netdev(0, "osn%d", NET_NAME_UNKNOWN, ether_setup);
  		break;
diff --cc drivers/s390/net/qeth_l2_main.c
index ce5ce6ebbf1e,7381917f76dd..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -607,30 -601,28 +607,46 @@@ static netdev_tx_t qeth_l2_hard_start_x
  					   struct net_device *dev)
  {
  	struct qeth_card *card = dev->ml_priv;
++<<<<<<< HEAD
 +	int cast_type = qeth_l2_get_cast_type(card, skb);
 +	int ipv = qeth_get_ip_version(skb);
++=======
+ 	u16 txq = skb_get_queue_mapping(skb);
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  	struct qeth_qdio_out_q *queue;
  	int tx_bytes = skb->len;
  	int rc;
  
++<<<<<<< HEAD
 +	if (card->state != CARD_STATE_UP) {
 +		card->stats.tx_carrier_errors++;
 +		goto tx_drop;
 +	}
++=======
+ 	if (IS_IQD(card))
+ 		queue = card->qdio.out_qs[qeth_iqd_translate_txq(dev, txq)];
+ 	else
+ 		queue = card->qdio.out_qs[txq];
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  
 -	netif_stop_subqueue(dev, txq);
 +	queue = qeth_get_tx_queue(card, skb, ipv, cast_type);
 +	netif_stop_queue(dev);
  
  	if (IS_OSN(card))
  		rc = qeth_l2_xmit_osn(card, skb, queue);
  	else
++<<<<<<< HEAD
 +		rc = qeth_xmit(card, skb, queue, ipv, cast_type,
 +			       qeth_l2_fill_header);
++=======
+ 		rc = qeth_xmit(card, skb, queue, qeth_get_ip_version(skb),
+ 			       qeth_l2_get_cast_type(skb), qeth_l2_fill_header);
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  
  	if (!rc) {
 -		QETH_TXQ_STAT_INC(queue, tx_packets);
 -		QETH_TXQ_STAT_ADD(queue, tx_bytes, tx_bytes);
 -		netif_wake_subqueue(dev, txq);
 +		card->stats.tx_packets++;
 +		card->stats.tx_bytes += tx_bytes;
 +		netif_wake_queue(dev);
  		return NETDEV_TX_OK;
  	} else if (rc == -EBUSY) {
  		return NETDEV_TX_BUSY;
@@@ -643,6 -634,18 +659,21 @@@ tx_drop
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static u16 qeth_l2_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 				struct net_device *sb_dev)
+ {
+ 	struct qeth_card *card = dev->ml_priv;
+ 
+ 	if (IS_IQD(card))
+ 		return qeth_iqd_select_queue(dev, skb,
+ 					     qeth_l2_get_cast_type(skb),
+ 					     sb_dev);
+ 	return qeth_get_priority_queue(card, skb);
+ }
+ 
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  static const struct device_type qeth_l2_devtype = {
  	.name = "qeth_layer2",
  	.groups = qeth_l2_attr_groups,
diff --cc drivers/s390/net/qeth_l3_main.c
index f13c93b498de,65244da4f415..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -2073,11 -2078,14 +2073,21 @@@ static netdev_tx_t qeth_l3_hard_start_x
  		    (card->options.cq == QETH_CQ_ENABLED &&
  		     skb->protocol != htons(ETH_P_AF_IUCV)))
  			goto tx_drop;
 +	}
  
++<<<<<<< HEAD
 +	if (card->state != CARD_STATE_UP) {
 +		card->stats.tx_carrier_errors++;
 +		goto tx_drop;
++=======
+ 		if (txq == QETH_IQD_MCAST_TXQ)
+ 			cast_type = qeth_l3_get_cast_type(skb);
+ 		else
+ 			cast_type = RTN_UNICAST;
+ 	} else {
+ 		queue = card->qdio.out_qs[txq];
+ 		cast_type = qeth_l3_get_cast_type(skb);
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  	}
  
  	if (cast_type == RTN_BROADCAST && !card->info.broadcast_capable)
@@@ -2141,6 -2155,21 +2151,24 @@@ static netdev_features_t qeth_l3_osa_fe
  	return qeth_features_check(skb, dev, features);
  }
  
++<<<<<<< HEAD
++=======
+ static u16 qeth_l3_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 				    struct net_device *sb_dev)
+ {
+ 	return qeth_iqd_select_queue(dev, skb, qeth_l3_get_cast_type(skb),
+ 				     sb_dev);
+ }
+ 
+ static u16 qeth_l3_osa_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 				    struct net_device *sb_dev)
+ {
+ 	struct qeth_card *card = dev->ml_priv;
+ 
+ 	return qeth_get_priority_queue(card, skb);
+ }
+ 
++>>>>>>> 73dc2daf110f (s390/qeth: add TX multiqueue support for OSA devices)
  static const struct net_device_ops qeth_l3_netdev_ops = {
  	.ndo_open		= qeth_open,
  	.ndo_stop		= qeth_stop,
@@@ -2159,9 -2189,10 +2187,10 @@@
  static const struct net_device_ops qeth_l3_osa_netdev_ops = {
  	.ndo_open		= qeth_open,
  	.ndo_stop		= qeth_stop,
 -	.ndo_get_stats64	= qeth_get_stats64,
 +	.ndo_get_stats		= qeth_get_stats,
  	.ndo_start_xmit		= qeth_l3_hard_start_xmit,
  	.ndo_features_check	= qeth_l3_osa_features_check,
+ 	.ndo_select_queue	= qeth_l3_osa_select_queue,
  	.ndo_validate_addr	= eth_validate_addr,
  	.ndo_set_rx_mode	= qeth_l3_set_rx_mode,
  	.ndo_do_ioctl		= qeth_do_ioctl,
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
