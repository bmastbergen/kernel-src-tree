mm/hmm: Remove racy protection against double-unregistration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] hmm: Remove racy protection against double-unregistration (Jerome Glisse) [1498655 1597758]
Rebuild_FUZZ: 97.44%
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 187229c2ddd12a5bb5cd6bb3fbef9ecbc6eead92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/187229c2.failed

No other register/unregister kernel API attempts to provide this kind of
protection as it is inherently racy, so just drop it.

Callers should provide their own protection, and it appears nouveau
already does.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Jérôme Glisse <jglisse@redhat.com>
	Reviewed-by: John Hubbard <jhubbard@nvidia.com>
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Philip Yang <Philip.Yang@amd.com>
(cherry picked from commit 187229c2ddd12a5bb5cd6bb3fbef9ecbc6eead92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hmm.c
diff --cc mm/hmm.c
index 2387f409704a,2ef14b2b5505..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -266,33 -276,12 +266,42 @@@ EXPORT_SYMBOL(hmm_mirror_register)
   */
  void hmm_mirror_unregister(struct hmm_mirror *mirror)
  {
++<<<<<<< HEAD
 +	bool should_unregister = false;
 +	struct mm_struct *mm;
 +	struct hmm *hmm;
 +
 +	if (mirror->hmm == NULL)
 +		return;
++=======
+ 	struct hmm *hmm = mirror->hmm;
++>>>>>>> 187229c2ddd1 (mm/hmm: Remove racy protection against double-unregistration)
  
 +	hmm = mirror->hmm;
  	down_write(&hmm->mirrors_sem);
  	list_del_init(&mirror->list);
++<<<<<<< HEAD
 +	should_unregister = list_empty(&hmm->mirrors);
 +	mirror->hmm = NULL;
 +	mm = hmm->mm;
 +	hmm->mm = NULL;
 +	up_write(&hmm->mirrors_sem);
 +
 +	if (!should_unregister || mm == NULL)
 +		return;
 +
 +	mmu_notifier_unregister_no_release(&hmm->mmu_notifier, mm);
 +
 +	spin_lock(&mm->page_table_lock);
 +	if (mm->hmm == hmm)
 +		mm->hmm = NULL;
 +	spin_unlock(&mm->page_table_lock);
 +
 +	kfree(hmm);
++=======
+ 	up_write(&hmm->mirrors_sem);
+ 	hmm_put(hmm);
++>>>>>>> 187229c2ddd1 (mm/hmm: Remove racy protection against double-unregistration)
  }
  EXPORT_SYMBOL(hmm_mirror_unregister);
  
* Unmerged path mm/hmm.c
