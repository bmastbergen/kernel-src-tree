xfrm: policy: store inexact policies in a tree ordered by destination address

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit 9cf545ebd591da673bb6b6c88150212ad83567a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9cf545eb.failed

This adds inexact lists per destination network, stored in a search tree.

Inexact lookups now return two 'candidate lists', the 'any' policies
('any' destionations), and a list of policies that share same
daddr/prefix.

Next patch will add a second search tree for 'saddr:any' policies
so we can avoid placing those on the 'any:any' list too.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 9cf545ebd591da673bb6b6c88150212ad83567a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,81447d5d02e6..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -45,6 -46,74 +45,77 @@@ struct xfrm_flo 
  	u8 flags;
  };
  
++<<<<<<< HEAD
++=======
+ /* prefixes smaller than this are stored in lists, not trees. */
+ #define INEXACT_PREFIXLEN_IPV4	16
+ #define INEXACT_PREFIXLEN_IPV6	48
+ 
+ struct xfrm_pol_inexact_node {
+ 	struct rb_node node;
+ 	union {
+ 		xfrm_address_t addr;
+ 		struct rcu_head rcu;
+ 	};
+ 	u8 prefixlen;
+ 
+ 	/* the policies matching this node, can be empty list */
+ 	struct hlist_head hhead;
+ };
+ 
+ /* xfrm inexact policy search tree:
+  * xfrm_pol_inexact_bin = hash(dir,type,family,if_id);
+  *  |
+  * +---- root_d: sorted by daddr:prefix
+  * |                 |
+  * |        xfrm_pol_inexact_node
+  * |                 |
+  * |                 +- coarse policies and all any:daddr policies
+  * |
+  * +---- coarse policies and all any:any policies
+  *
+  * Lookups return two candidate lists:
+  * 1. any:any list from top-level xfrm_pol_inexact_bin
+  * 2. any:daddr list from daddr tree
+  *
+  * This result set then needs to be searched for the policy with
+  * the lowest priority.  If two results have same prio, youngest one wins.
+  */
+ 
+ struct xfrm_pol_inexact_key {
+ 	possible_net_t net;
+ 	u32 if_id;
+ 	u16 family;
+ 	u8 dir, type;
+ };
+ 
+ struct xfrm_pol_inexact_bin {
+ 	struct xfrm_pol_inexact_key k;
+ 	struct rhash_head head;
+ 	/* list containing '*:*' policies */
+ 	struct hlist_head hhead;
+ 
+ 	seqcount_t count;
+ 	/* tree sorted by daddr/prefix */
+ 	struct rb_root root_d;
+ 
+ 	/* slow path below */
+ 	struct list_head inexact_bins;
+ 	struct rcu_head rcu;
+ };
+ 
+ enum xfrm_pol_inexact_candidate_type {
+ 	XFRM_POL_CAND_DADDR,
+ 	XFRM_POL_CAND_ANY,
+ 
+ 	XFRM_POL_CAND_MAX,
+ };
+ 
+ struct xfrm_pol_inexact_candidates {
+ 	struct hlist_head *res[XFRM_POL_CAND_MAX];
+ };
+ 
++>>>>>>> 9cf545ebd591 (xfrm: policy: store inexact policies in a tree ordered by destination address)
  static DEFINE_SPINLOCK(xfrm_if_cb_lock);
  static struct xfrm_if_cb const __rcu *xfrm_if_cb __read_mostly;
  
@@@ -560,6 -655,400 +631,403 @@@ static void xfrm_hash_resize(struct wor
  	mutex_unlock(&hash_resize_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ static void xfrm_hash_reset_inexact_table(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *b;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry(b, &net->xfrm.inexact_bins, inexact_bins)
+ 		INIT_HLIST_HEAD(&b->hhead);
+ }
+ 
+ /* Make sure *pol can be inserted into fastbin.
+  * Useful to check that later insert requests will be sucessful
+  * (provided xfrm_policy_lock is held throughout).
+  */
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_alloc_bin(const struct xfrm_policy *pol, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *prev;
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = pol->family,
+ 		.type = pol->type,
+ 		.dir = dir,
+ 		.if_id = pol->if_id,
+ 	};
+ 	struct net *net = xp_net(pol);
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	write_pnet(&k.net, net);
+ 	bin = rhashtable_lookup_fast(&xfrm_policy_inexact_table, &k,
+ 				     xfrm_pol_inexact_params);
+ 	if (bin)
+ 		return bin;
+ 
+ 	bin = kzalloc(sizeof(*bin), GFP_ATOMIC);
+ 	if (!bin)
+ 		return NULL;
+ 
+ 	bin->k = k;
+ 	INIT_HLIST_HEAD(&bin->hhead);
+ 	bin->root_d = RB_ROOT;
+ 	seqcount_init(&bin->count);
+ 
+ 	prev = rhashtable_lookup_get_insert_key(&xfrm_policy_inexact_table,
+ 						&bin->k, &bin->head,
+ 						xfrm_pol_inexact_params);
+ 	if (!prev) {
+ 		list_add(&bin->inexact_bins, &net->xfrm.inexact_bins);
+ 		return bin;
+ 	}
+ 
+ 	kfree(bin);
+ 
+ 	return IS_ERR(prev) ? NULL : prev;
+ }
+ 
+ static bool xfrm_pol_inexact_addr_use_any_list(const xfrm_address_t *addr,
+ 					       int family, u8 prefixlen)
+ {
+ 	if (xfrm_addr_any(addr, family))
+ 		return true;
+ 
+ 	if (family == AF_INET6 && prefixlen < INEXACT_PREFIXLEN_IPV6)
+ 		return true;
+ 
+ 	if (family == AF_INET && prefixlen < INEXACT_PREFIXLEN_IPV4)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool
+ xfrm_policy_inexact_insert_use_any_list(const struct xfrm_policy *policy)
+ {
+ 	const xfrm_address_t *addr;
+ 	bool saddr_any, daddr_any;
+ 	u8 prefixlen;
+ 
+ 	addr = &policy->selector.saddr;
+ 	prefixlen = policy->selector.prefixlen_s;
+ 
+ 	saddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	addr = &policy->selector.daddr;
+ 	prefixlen = policy->selector.prefixlen_d;
+ 	daddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	return saddr_any && daddr_any;
+ }
+ 
+ static void xfrm_pol_inexact_node_init(struct xfrm_pol_inexact_node *node,
+ 				       const xfrm_address_t *addr, u8 prefixlen)
+ {
+ 	node->addr = *addr;
+ 	node->prefixlen = prefixlen;
+ }
+ 
+ static struct xfrm_pol_inexact_node *
+ xfrm_pol_inexact_node_alloc(const xfrm_address_t *addr, u8 prefixlen)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 
+ 	node = kzalloc(sizeof(*node), GFP_ATOMIC);
+ 	if (node)
+ 		xfrm_pol_inexact_node_init(node, addr, prefixlen);
+ 
+ 	return node;
+ }
+ 
+ static int xfrm_policy_addr_delta(const xfrm_address_t *a,
+ 				  const xfrm_address_t *b,
+ 				  u8 prefixlen, u16 family)
+ {
+ 	unsigned int pdw, pbi;
+ 	int delta = 0;
+ 
+ 	switch (family) {
+ 	case AF_INET:
+ 		if (sizeof(long) == 4 && prefixlen == 0)
+ 			return ntohl(a->a4) - ntohl(b->a4);
+ 		return (ntohl(a->a4) & ((~0UL << (32 - prefixlen)))) -
+ 		       (ntohl(b->a4) & ((~0UL << (32 - prefixlen))));
+ 	case AF_INET6:
+ 		pdw = prefixlen >> 5;
+ 		pbi = prefixlen & 0x1f;
+ 
+ 		if (pdw) {
+ 			delta = memcmp(a->a6, b->a6, pdw << 2);
+ 			if (delta)
+ 				return delta;
+ 		}
+ 		if (pbi) {
+ 			u32 mask = ~0u << (32 - pbi);
+ 
+ 			delta = (ntohl(a->a6[pdw]) & mask) -
+ 				(ntohl(b->a6[pdw]) & mask);
+ 		}
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return delta;
+ }
+ 
+ static void xfrm_policy_inexact_list_reinsert(struct net *net,
+ 					      struct xfrm_pol_inexact_node *n,
+ 					      u16 family)
+ {
+ 	struct hlist_node *newpos = NULL;
+ 	struct xfrm_policy *policy, *p;
+ 
+ 	list_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {
+ 		if (!policy->bydst_reinsert)
+ 			continue;
+ 
+ 		WARN_ON_ONCE(policy->family != family);
+ 
+ 		policy->bydst_reinsert = false;
+ 		hlist_for_each_entry(p, &n->hhead, bydst) {
+ 			if (policy->priority >= p->priority)
+ 				newpos = &p->bydst;
+ 			else
+ 				break;
+ 		}
+ 
+ 		if (newpos)
+ 			hlist_add_behind(&policy->bydst, newpos);
+ 		else
+ 			hlist_add_head(&policy->bydst, &n->hhead);
+ 	}
+ }
+ 
+ /* merge nodes v and n */
+ static void xfrm_policy_inexact_node_merge(struct net *net,
+ 					   struct xfrm_pol_inexact_node *v,
+ 					   struct xfrm_pol_inexact_node *n,
+ 					   u16 family)
+ {
+ 	struct xfrm_policy *tmp;
+ 
+ 	hlist_for_each_entry(tmp, &v->hhead, bydst)
+ 		tmp->bydst_reinsert = true;
+ 	hlist_for_each_entry(tmp, &n->hhead, bydst)
+ 		tmp->bydst_reinsert = true;
+ 
+ 	INIT_HLIST_HEAD(&n->hhead);
+ 	xfrm_policy_inexact_list_reinsert(net, n, family);
+ }
+ 
+ static struct xfrm_pol_inexact_node *
+ xfrm_policy_inexact_insert_node(struct net *net,
+ 				struct rb_root *root,
+ 				xfrm_address_t *addr,
+ 				u16 family, u8 prefixlen, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_node *cached = NULL;
+ 	struct rb_node **p, *parent = NULL;
+ 	struct xfrm_pol_inexact_node *node;
+ 
+ 	p = &root->rb_node;
+ 	while (*p) {
+ 		int delta;
+ 
+ 		parent = *p;
+ 		node = rb_entry(*p, struct xfrm_pol_inexact_node, node);
+ 
+ 		delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 					       node->prefixlen,
+ 					       family);
+ 		if (delta == 0 && prefixlen >= node->prefixlen) {
+ 			WARN_ON_ONCE(cached); /* ipsec policies got lost */
+ 			return node;
+ 		}
+ 
+ 		if (delta < 0)
+ 			p = &parent->rb_left;
+ 		else
+ 			p = &parent->rb_right;
+ 
+ 		if (prefixlen < node->prefixlen) {
+ 			delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 						       prefixlen,
+ 						       family);
+ 			if (delta)
+ 				continue;
+ 
+ 			/* This node is a subnet of the new prefix. It needs
+ 			 * to be removed and re-inserted with the smaller
+ 			 * prefix and all nodes that are now also covered
+ 			 * by the reduced prefixlen.
+ 			 */
+ 			rb_erase(&node->node, root);
+ 
+ 			if (!cached) {
+ 				xfrm_pol_inexact_node_init(node, addr,
+ 							   prefixlen);
+ 				cached = node;
+ 			} else {
+ 				/* This node also falls within the new
+ 				 * prefixlen. Merge the to-be-reinserted
+ 				 * node and this one.
+ 				 */
+ 				xfrm_policy_inexact_node_merge(net, node,
+ 							       cached, family);
+ 				kfree_rcu(node, rcu);
+ 			}
+ 
+ 			/* restart */
+ 			p = &root->rb_node;
+ 			parent = NULL;
+ 		}
+ 	}
+ 
+ 	node = cached;
+ 	if (!node) {
+ 		node = xfrm_pol_inexact_node_alloc(addr, prefixlen);
+ 		if (!node)
+ 			return NULL;
+ 	}
+ 
+ 	rb_link_node_rcu(&node->node, parent, p);
+ 	rb_insert_color(&node->node, root);
+ 
+ 	return node;
+ }
+ 
+ static void xfrm_policy_inexact_gc_tree(struct rb_root *r, bool rm)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 	struct rb_node *rn = rb_first(r);
+ 
+ 	while (rn) {
+ 		node = rb_entry(rn, struct xfrm_pol_inexact_node, node);
+ 
+ 		rn = rb_next(rn);
+ 
+ 		if (!hlist_empty(&node->hhead)) {
+ 			WARN_ON_ONCE(rm);
+ 			continue;
+ 		}
+ 
+ 		rb_erase(&node->node, r);
+ 		kfree_rcu(node, rcu);
+ 	}
+ }
+ 
+ static void __xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b, bool net_exit)
+ {
+ 	write_seqcount_begin(&b->count);
+ 	xfrm_policy_inexact_gc_tree(&b->root_d, net_exit);
+ 	write_seqcount_end(&b->count);
+ 
+ 	if (!RB_EMPTY_ROOT(&b->root_d) ||
+ 	    !hlist_empty(&b->hhead)) {
+ 		WARN_ON_ONCE(net_exit);
+ 		return;
+ 	}
+ 
+ 	if (rhashtable_remove_fast(&xfrm_policy_inexact_table, &b->head,
+ 				   xfrm_pol_inexact_params) == 0) {
+ 		list_del(&b->inexact_bins);
+ 		kfree_rcu(b, rcu);
+ 	}
+ }
+ 
+ static void xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b)
+ {
+ 	struct net *net = read_pnet(&b->k.net);
+ 
+ 	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
+ 	__xfrm_policy_inexact_prune_bin(b, false);
+ 	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ }
+ 
+ static void __xfrm_policy_inexact_flush(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *t;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry_safe(bin, t, &net->xfrm.inexact_bins, inexact_bins)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ }
+ 
+ static struct hlist_head *
+ xfrm_policy_inexact_alloc_chain(struct xfrm_pol_inexact_bin *bin,
+ 				struct xfrm_policy *policy, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_node *n;
+ 	struct net *net;
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	if (xfrm_policy_inexact_insert_use_any_list(policy))
+ 		return &bin->hhead;
+ 
+ 	if (xfrm_pol_inexact_addr_use_any_list(&policy->selector.daddr,
+ 					       policy->family,
+ 					       policy->selector.prefixlen_d))
+ 		return &bin->hhead;
+ 
+ 	/* daddr is fixed */
+ 	write_seqcount_begin(&bin->count);
+ 	n = xfrm_policy_inexact_insert_node(net,
+ 					    &bin->root_d,
+ 					    &policy->selector.daddr,
+ 					    policy->family,
+ 					    policy->selector.prefixlen_d, dir);
+ 	write_seqcount_end(&bin->count);
+ 	if (!n)
+ 		return NULL;
+ 	return &n->hhead;
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_inexact_insert(struct xfrm_policy *policy, u8 dir, int excl)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 	struct xfrm_policy *delpol;
+ 	struct hlist_head *chain;
+ 	struct net *net;
+ 
+ 	bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 	if (!bin)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	chain = xfrm_policy_inexact_alloc_chain(bin, policy, dir);
+ 	if (!chain) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	delpol = xfrm_policy_insert_list(chain, policy, excl);
+ 	if (delpol && excl) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-EEXIST);
+ 	}
+ 
+ 	chain = &net->xfrm.policy_inexact[dir];
+ 	xfrm_policy_insert_inexact_list(chain, policy);
+ 
+ 	if (delpol)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 
+ 	return delpol;
+ }
+ 
++>>>>>>> 9cf545ebd591 (xfrm: policy: store inexact policies in a tree ordered by destination address)
  static void xfrm_hash_rebuild(struct work_struct *work)
  {
  	struct net *net = container_of(work, struct net,
@@@ -588,9 -1077,51 +1056,53 @@@
  	} while (read_seqretry(&net->xfrm.policy_hthresh.lock, seq));
  
  	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
++<<<<<<< HEAD
 +	write_seqcount_begin(&xfrm_policy_hash_generation);
++=======
+ 
+ 	/* make sure that we can insert the indirect policies again before
+ 	 * we start with destructive action.
+ 	 */
+ 	list_for_each_entry(policy, &net->xfrm.policy_all, walk.all) {
+ 		struct xfrm_pol_inexact_bin *bin;
+ 		u8 dbits, sbits;
+ 
+ 		dir = xfrm_policy_id2dir(policy->index);
+ 		if (policy->walk.dead || dir >= XFRM_POLICY_MAX)
+ 			continue;
+ 
+ 		if ((dir & XFRM_POLICY_MASK) == XFRM_POLICY_OUT) {
+ 			if (policy->family == AF_INET) {
+ 				dbits = rbits4;
+ 				sbits = lbits4;
+ 			} else {
+ 				dbits = rbits6;
+ 				sbits = lbits6;
+ 			}
+ 		} else {
+ 			if (policy->family == AF_INET) {
+ 				dbits = lbits4;
+ 				sbits = rbits4;
+ 			} else {
+ 				dbits = lbits6;
+ 				sbits = rbits6;
+ 			}
+ 		}
+ 
+ 		if (policy->selector.prefixlen_d < dbits ||
+ 		    policy->selector.prefixlen_s < sbits)
+ 			continue;
+ 
+ 		bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 		if (!bin)
+ 			goto out_unlock;
+ 
+ 		if (!xfrm_policy_inexact_alloc_chain(bin, policy, dir))
+ 			goto out_unlock;
+ 	}
++>>>>>>> 9cf545ebd591 (xfrm: policy: store inexact policies in a tree ordered by destination address)
  
  	/* reset the bydst and inexact table in all directions */
 -	xfrm_hash_reset_inexact_table(net);
 -
  	for (dir = 0; dir < XFRM_POLICY_MAX; dir++) {
  		INIT_HLIST_HEAD(&net->xfrm.policy_inexact[dir]);
  		hmask = net->xfrm.policy_bydst[dir].hmask;
@@@ -1066,6 -1736,163 +1578,166 @@@ static int xfrm_policy_match(const stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static struct xfrm_pol_inexact_node *
+ xfrm_policy_lookup_inexact_addr(const struct rb_root *r,
+ 				seqcount_t *count,
+ 				const xfrm_address_t *addr, u16 family)
+ {
+ 	const struct rb_node *parent;
+ 	int seq;
+ 
+ again:
+ 	seq = read_seqcount_begin(count);
+ 
+ 	parent = rcu_dereference_raw(r->rb_node);
+ 	while (parent) {
+ 		struct xfrm_pol_inexact_node *node;
+ 		int delta;
+ 
+ 		node = rb_entry(parent, struct xfrm_pol_inexact_node, node);
+ 
+ 		delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 					       node->prefixlen, family);
+ 		if (delta < 0) {
+ 			parent = rcu_dereference_raw(parent->rb_left);
+ 			continue;
+ 		} else if (delta > 0) {
+ 			parent = rcu_dereference_raw(parent->rb_right);
+ 			continue;
+ 		}
+ 
+ 		return node;
+ 	}
+ 
+ 	if (read_seqcount_retry(count, seq))
+ 		goto again;
+ 
+ 	return NULL;
+ }
+ 
+ static bool
+ xfrm_policy_find_inexact_candidates(struct xfrm_pol_inexact_candidates *cand,
+ 				    struct xfrm_pol_inexact_bin *b,
+ 				    const xfrm_address_t *saddr,
+ 				    const xfrm_address_t *daddr)
+ {
+ 	struct xfrm_pol_inexact_node *n;
+ 	u16 family;
+ 
+ 	if (!b)
+ 		return false;
+ 
+ 	family = b->k.family;
+ 	memset(cand, 0, sizeof(*cand));
+ 	cand->res[XFRM_POL_CAND_ANY] = &b->hhead;
+ 
+ 	n = xfrm_policy_lookup_inexact_addr(&b->root_d, &b->count, daddr,
+ 					    family);
+ 	if (n)
+ 		cand->res[XFRM_POL_CAND_DADDR] = &n->hhead;
+ 
+ 	return true;
+ }
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup_rcu(struct net *net, u8 type, u16 family,
+ 			       u8 dir, u32 if_id)
+ {
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = family,
+ 		.type = type,
+ 		.dir = dir,
+ 		.if_id = if_id,
+ 	};
+ 
+ 	write_pnet(&k.net, net);
+ 
+ 	return rhashtable_lookup(&xfrm_policy_inexact_table, &k,
+ 				 xfrm_pol_inexact_params);
+ }
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family,
+ 			   u8 dir, u32 if_id)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	rcu_read_lock();
+ 	bin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);
+ 	rcu_read_unlock();
+ 
+ 	return bin;
+ }
+ 
+ static struct xfrm_policy *
+ __xfrm_policy_eval_candidates(struct hlist_head *chain,
+ 			      struct xfrm_policy *prefer,
+ 			      const struct flowi *fl,
+ 			      u8 type, u16 family, int dir, u32 if_id)
+ {
+ 	u32 priority = prefer ? prefer->priority : ~0u;
+ 	struct xfrm_policy *pol;
+ 
+ 	if (!chain)
+ 		return NULL;
+ 
+ 	hlist_for_each_entry_rcu(pol, chain, bydst) {
+ 		int err;
+ 
+ 		if (pol->priority > priority)
+ 			break;
+ 
+ 		err = xfrm_policy_match(pol, fl, type, family, dir, if_id);
+ 		if (err) {
+ 			if (err != -ESRCH)
+ 				return ERR_PTR(err);
+ 
+ 			continue;
+ 		}
+ 
+ 		if (prefer) {
+ 			/* matches.  Is it older than *prefer? */
+ 			if (pol->priority == priority &&
+ 			    prefer->pos < pol->pos)
+ 				return prefer;
+ 		}
+ 
+ 		return pol;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_eval_candidates(struct xfrm_pol_inexact_candidates *cand,
+ 			    struct xfrm_policy *prefer,
+ 			    const struct flowi *fl,
+ 			    u8 type, u16 family, int dir, u32 if_id)
+ {
+ 	struct xfrm_policy *tmp;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(cand->res); i++) {
+ 		tmp = __xfrm_policy_eval_candidates(cand->res[i],
+ 						    prefer,
+ 						    fl, type, family, dir,
+ 						    if_id);
+ 		if (!tmp)
+ 			continue;
+ 
+ 		if (IS_ERR(tmp))
+ 			return tmp;
+ 		prefer = tmp;
+ 	}
+ 
+ 	return prefer;
+ }
+ 
++>>>>>>> 9cf545ebd591 (xfrm: policy: store inexact policies in a tree ordered by destination address)
  static struct xfrm_policy *xfrm_policy_lookup_bytype(struct net *net, u8 type,
  						     const struct flowi *fl,
  						     u16 family, u8 dir,
diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index f1d2173cbfda..45fdd1e52cbf 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -600,6 +600,7 @@ struct xfrm_policy {
 	struct xfrm_lifetime_cur curlft;
 	struct xfrm_policy_walk_entry walk;
 	struct xfrm_policy_queue polq;
+	bool                    bydst_reinsert;
 	u8			type;
 	u8			action;
 	u8			flags;
* Unmerged path net/xfrm/xfrm_policy.c
