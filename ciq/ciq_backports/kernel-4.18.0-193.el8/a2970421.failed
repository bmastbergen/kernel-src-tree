stacktrace: Constify 'entries' arguments

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit a2970421640bd9b6a78f2685d7750a791abdfd4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a2970421.failed

Make it clear to humans and to the compiler that the stack trace
('entries') arguments are not modified.

	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Will Deacon <will.deacon@arm.com>
Link: https://lkml.kernel.org/r/20190722182443.216015-3-bvanassche@acm.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a2970421640bd9b6a78f2685d7750a791abdfd4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/stacktrace.h
#	kernel/stacktrace.c
diff --cc include/linux/stacktrace.h
index 619c968fe5a6,83bd8cb475d7..000000000000
--- a/include/linux/stacktrace.h
+++ b/include/linux/stacktrace.h
@@@ -9,6 -9,58 +9,61 @@@ struct task_struct
  struct pt_regs;
  
  #ifdef CONFIG_STACKTRACE
++<<<<<<< HEAD
++=======
+ void stack_trace_print(const unsigned long *trace, unsigned int nr_entries,
+ 		       int spaces);
+ int stack_trace_snprint(char *buf, size_t size, const unsigned long *entries,
+ 			unsigned int nr_entries, int spaces);
+ unsigned int stack_trace_save(unsigned long *store, unsigned int size,
+ 			      unsigned int skipnr);
+ unsigned int stack_trace_save_tsk(struct task_struct *task,
+ 				  unsigned long *store, unsigned int size,
+ 				  unsigned int skipnr);
+ unsigned int stack_trace_save_regs(struct pt_regs *regs, unsigned long *store,
+ 				   unsigned int size, unsigned int skipnr);
+ unsigned int stack_trace_save_user(unsigned long *store, unsigned int size);
+ 
+ /* Internal interfaces. Do not use in generic code */
+ #ifdef CONFIG_ARCH_STACKWALK
+ 
+ /**
+  * stack_trace_consume_fn - Callback for arch_stack_walk()
+  * @cookie:	Caller supplied pointer handed back by arch_stack_walk()
+  * @addr:	The stack entry address to consume
+  * @reliable:	True when the stack entry is reliable. Required by
+  *		some printk based consumers.
+  *
+  * Return:	True, if the entry was consumed or skipped
+  *		False, if there is no space left to store
+  */
+ typedef bool (*stack_trace_consume_fn)(void *cookie, unsigned long addr,
+ 				       bool reliable);
+ /**
+  * arch_stack_walk - Architecture specific function to walk the stack
+  * @consume_entry:	Callback which is invoked by the architecture code for
+  *			each entry.
+  * @cookie:		Caller supplied pointer which is handed back to
+  *			@consume_entry
+  * @task:		Pointer to a task struct, can be NULL
+  * @regs:		Pointer to registers, can be NULL
+  *
+  * ============ ======= ============================================
+  * task	        regs
+  * ============ ======= ============================================
+  * task		NULL	Stack trace from task (can be current)
+  * current	regs	Stack trace starting on regs->stackpointer
+  * ============ ======= ============================================
+  */
+ void arch_stack_walk(stack_trace_consume_fn consume_entry, void *cookie,
+ 		     struct task_struct *task, struct pt_regs *regs);
+ int arch_stack_walk_reliable(stack_trace_consume_fn consume_entry, void *cookie,
+ 			     struct task_struct *task);
+ void arch_stack_walk_user(stack_trace_consume_fn consume_entry, void *cookie,
+ 			  const struct pt_regs *regs);
+ 
+ #else /* CONFIG_ARCH_STACKWALK */
++>>>>>>> a2970421640b (stacktrace: Constify 'entries' arguments)
  struct stack_trace {
  	unsigned int nr_entries, max_entries;
  	unsigned long *entries;
diff --cc kernel/stacktrace.c
index f8edee9c792d,6d1f68b7e528..000000000000
--- a/kernel/stacktrace.c
+++ b/kernel/stacktrace.c
@@@ -11,35 -14,48 +11,61 @@@
  #include <linux/kallsyms.h>
  #include <linux/stacktrace.h>
  
++<<<<<<< HEAD
 +void print_stack_trace(struct stack_trace *trace, int spaces)
++=======
+ /**
+  * stack_trace_print - Print the entries in the stack trace
+  * @entries:	Pointer to storage array
+  * @nr_entries:	Number of entries in the storage array
+  * @spaces:	Number of leading spaces to print
+  */
+ void stack_trace_print(const unsigned long *entries, unsigned int nr_entries,
+ 		       int spaces)
++>>>>>>> a2970421640b (stacktrace: Constify 'entries' arguments)
  {
 -	unsigned int i;
 +	int i;
  
 -	if (WARN_ON(!entries))
 +	if (WARN_ON(!trace->entries))
  		return;
  
 -	for (i = 0; i < nr_entries; i++)
 -		printk("%*c%pS\n", 1 + spaces, ' ', (void *)entries[i]);
 +	for (i = 0; i < trace->nr_entries; i++)
 +		printk("%*c%pS\n", 1 + spaces, ' ', (void *)trace->entries[i]);
  }
 -EXPORT_SYMBOL_GPL(stack_trace_print);
 +EXPORT_SYMBOL_GPL(print_stack_trace);
  
++<<<<<<< HEAD
 +int snprint_stack_trace(char *buf, size_t size,
 +			struct stack_trace *trace, int spaces)
++=======
+ /**
+  * stack_trace_snprint - Print the entries in the stack trace into a buffer
+  * @buf:	Pointer to the print buffer
+  * @size:	Size of the print buffer
+  * @entries:	Pointer to storage array
+  * @nr_entries:	Number of entries in the storage array
+  * @spaces:	Number of leading spaces to print
+  *
+  * Return: Number of bytes printed.
+  */
+ int stack_trace_snprint(char *buf, size_t size, const unsigned long *entries,
+ 			unsigned int nr_entries, int spaces)
++>>>>>>> a2970421640b (stacktrace: Constify 'entries' arguments)
  {
 -	unsigned int generated, i, total = 0;
 +	int i;
 +	int generated;
 +	int total = 0;
  
 -	if (WARN_ON(!entries))
 +	if (WARN_ON(!trace->entries))
  		return 0;
  
 -	for (i = 0; i < nr_entries && size; i++) {
 +	for (i = 0; i < trace->nr_entries; i++) {
  		generated = snprintf(buf, size, "%*c%pS\n", 1 + spaces, ' ',
 -				     (void *)entries[i]);
 +				     (void *)trace->entries[i]);
  
  		total += generated;
 +
 +		/* Assume that generated isn't a negative number */
  		if (generated >= size) {
  			buf += size;
  			size = 0;
* Unmerged path include/linux/stacktrace.h
* Unmerged path kernel/stacktrace.c
