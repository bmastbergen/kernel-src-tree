powerpc/mce: Handle UE event for memcpy_mcsafe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Balbir Singh <bsingharora@gmail.com>
commit 895e3dceeb97855dc9990136cbb80a842fe581aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/895e3dce.failed

If we take a UE on one of the instructions with a fixup entry, set nip
to continue execution at the fixup entry. Stop processing the event
further or print it.

Co-developed-by: Reza Arbab <arbab@linux.ibm.com>
	Signed-off-by: Reza Arbab <arbab@linux.ibm.com>
	Signed-off-by: Balbir Singh <bsingharora@gmail.com>
	Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
	Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Santosh Sivaraj <santosh@fossix.org>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190820081352.8641-6-santosh@fossix.org
(cherry picked from commit 895e3dceeb97855dc9990136cbb80a842fe581aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/mce.h
diff --cc arch/powerpc/include/asm/mce.h
index ad47fa865324,19a33707d5ef..000000000000
--- a/arch/powerpc/include/asm/mce.h
+++ b/arch/powerpc/include/asm/mce.h
@@@ -110,25 -105,28 +110,35 @@@ enum MCE_LinkErrorType 
  };
  
  struct machine_check_event {
 -	enum MCE_Version	version:8;
 -	u8			in_use;
 -	enum MCE_Severity	severity:8;
 -	enum MCE_Initiator	initiator:8;
 -	enum MCE_ErrorType	error_type:8;
 -	enum MCE_ErrorClass	error_class:8;
 -	enum MCE_Disposition	disposition:8;
 -	bool			sync_error;
 -	u16			cpu;
 -	u64			gpr3;
 -	u64			srr0;
 -	u64			srr1;
 -	union {
 +	enum MCE_Version	version:8;	/* 0x00 */
 +	uint8_t			in_use;		/* 0x01 */
 +	enum MCE_Severity	severity:8;	/* 0x02 */
 +	enum MCE_Initiator	initiator:8;	/* 0x03 */
 +	enum MCE_ErrorType	error_type:8;	/* 0x04 */
 +	enum MCE_Disposition	disposition:8;	/* 0x05 */
 +	uint8_t			reserved_1[2];	/* 0x06 */
 +	uint64_t		gpr3;		/* 0x08 */
 +	uint64_t		srr0;		/* 0x10 */
 +	uint64_t		srr1;		/* 0x18 */
 +	union {					/* 0x20 */
  		struct {
  			enum MCE_UeErrorType ue_error_type:8;
++<<<<<<< HEAD
 +			uint8_t		effective_address_provided;
 +			uint8_t		physical_address_provided;
 +			uint8_t		reserved_1[5];
 +			uint64_t	effective_address;
 +			uint64_t	physical_address;
 +			uint8_t		reserved_2[8];
++=======
+ 			u8		effective_address_provided;
+ 			u8		physical_address_provided;
+ 			u8		ignore_event;
+ 			u8		reserved_1[4];
+ 			u64		effective_address;
+ 			u64		physical_address;
+ 			u8		reserved_2[8];
++>>>>>>> 895e3dceeb97 (powerpc/mce: Handle UE event for memcpy_mcsafe)
  		} ue_error;
  
  		struct {
@@@ -194,6 -192,9 +204,12 @@@ struct mce_error_info 
  	} u;
  	enum MCE_Severity	severity:8;
  	enum MCE_Initiator	initiator:8;
++<<<<<<< HEAD
++=======
+ 	enum MCE_ErrorClass	error_class:8;
+ 	bool			sync_error;
+ 	bool			ignore_event;
++>>>>>>> 895e3dceeb97 (powerpc/mce: Handle UE event for memcpy_mcsafe)
  };
  
  #define MAX_MC_EVT	100
* Unmerged path arch/powerpc/include/asm/mce.h
diff --git a/arch/powerpc/kernel/mce.c b/arch/powerpc/kernel/mce.c
index f4a253a9d15c..599c6860d12b 100644
--- a/arch/powerpc/kernel/mce.c
+++ b/arch/powerpc/kernel/mce.c
@@ -158,6 +158,7 @@ void save_mce_event(struct pt_regs *regs, long handled,
 		if (phys_addr != ULONG_MAX) {
 			mce->u.ue_error.physical_address_provided = true;
 			mce->u.ue_error.physical_address = phys_addr;
+			mce->u.ue_error.ignore_event = mce_err->ignore_event;
 			machine_check_ue_event(mce);
 		}
 	}
@@ -275,8 +276,17 @@ static void machine_process_ue_event(struct work_struct *work)
 		/*
 		 * This should probably queued elsewhere, but
 		 * oh! well
+		 *
+		 * Don't report this machine check because the caller has a
+		 * asked us to ignore the event, it has a fixup handler which
+		 * will do the appropriate error handling and reporting.
 		 */
 		if (evt->error_type == MCE_ERROR_TYPE_UE) {
+			if (evt->u.ue_error.ignore_event) {
+				__this_cpu_dec(mce_ue_count);
+				continue;
+			}
+
 			if (evt->u.ue_error.physical_address_provided) {
 				unsigned long pfn;
 
@@ -310,6 +320,12 @@ static void machine_check_process_queued_event(struct irq_work *work)
 	while (__this_cpu_read(mce_queue_count) > 0) {
 		index = __this_cpu_read(mce_queue_count) - 1;
 		evt = this_cpu_ptr(&mce_event_queue[index]);
+
+		if (evt->error_type == MCE_ERROR_TYPE_UE &&
+		    evt->u.ue_error.ignore_event) {
+			__this_cpu_dec(mce_queue_count);
+			continue;
+		}
 		machine_check_print_event_info(evt, false, false);
 		__this_cpu_dec(mce_queue_count);
 	}
diff --git a/arch/powerpc/kernel/mce_power.c b/arch/powerpc/kernel/mce_power.c
index f59bbf676222..d8ca2b56a519 100644
--- a/arch/powerpc/kernel/mce_power.c
+++ b/arch/powerpc/kernel/mce_power.c
@@ -24,6 +24,7 @@
 
 #include <linux/types.h>
 #include <linux/ptrace.h>
+#include <linux/extable.h>
 #include <asm/mmu.h>
 #include <asm/mce.h>
 #include <asm/machdep.h>
@@ -31,6 +32,7 @@
 #include <asm/pte-walk.h>
 #include <asm/sstep.h>
 #include <asm/exception-64s.h>
+#include <asm/extable.h>
 
 /*
  * Convert an address related to an mm to a PFN. NOTE: we are in real
@@ -545,9 +547,18 @@ static int mce_handle_derror(struct pt_regs *regs,
 	return 0;
 }
 
-static long mce_handle_ue_error(struct pt_regs *regs)
+static long mce_handle_ue_error(struct pt_regs *regs,
+				struct mce_error_info *mce_err)
 {
 	long handled = 0;
+	const struct exception_table_entry *entry;
+
+	entry = search_kernel_exception_table(regs->nip);
+	if (entry) {
+		mce_err->ignore_event = true;
+		regs->nip = extable_fixup(entry);
+		return 1;
+	}
 
 	/*
 	 * On specific SCOM read via MMIO we may get a machine check
@@ -580,7 +591,7 @@ static long mce_handle_error(struct pt_regs *regs,
 				&phys_addr);
 
 	if (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)
-		handled = mce_handle_ue_error(regs);
+		handled = mce_handle_ue_error(regs, &mce_err);
 
 	save_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);
 
