mm/memmap_init: update variable name in memmap_init_zone

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] memmap_init: update variable name in memmap_init_zone (Christoph von Recklinghausen) [1766491]
Rebuild_FUZZ: 97.25%
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
commit 1f8d75c1b7dc62f017c542ca99e7da4a0839fb1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/1f8d75c1.failed

Patch series "mm/memory_hotplug: Shrink zones before removing memory", v6.

This series fixes the access of uninitialized memmaps when shrinking
zones/nodes and when removing memory.  Also, it contains all fixes for
crashes that can be triggered when removing certain namespace using
memunmap_pages() - ZONE_DEVICE, reported by Aneesh.

We stop trying to shrink ZONE_DEVICE, as it's buggy, fixing it would be
more involved (we don't have SECTION_IS_ONLINE as an indicator), and
shrinking is only of limited use (set_zone_contiguous() cannot detect the
ZONE_DEVICE as contiguous).

We continue shrinking !ZONE_DEVICE zones, however, I reduced the amount of
code to a minimum.  Shrinking is especially necessary to keep
zone->contiguous set where possible, especially, on memory unplug of DIMMs
at zone boundaries.

--------------------------------------------------------------------------

Zones are now properly shrunk when offlining memory blocks or when
onlining failed.  This allows to properly shrink zones on memory unplug
even if the separate memory blocks of a DIMM were onlined to different
zones or re-onlined to a different zone after offlining.

Example:

:/# cat /proc/zoneinfo
Node 1, zone  Movable
        spanned  0
        present  0
        managed  0
:/# echo "online_movable" > /sys/devices/system/memory/memory41/state
:/# echo "online_movable" > /sys/devices/system/memory/memory43/state
:/# cat /proc/zoneinfo
Node 1, zone  Movable
        spanned  98304
        present  65536
        managed  65536
:/# echo 0 > /sys/devices/system/memory/memory43/online
:/# cat /proc/zoneinfo
Node 1, zone  Movable
        spanned  32768
        present  32768
        managed  32768
:/# echo 0 > /sys/devices/system/memory/memory41/online
:/# cat /proc/zoneinfo
Node 1, zone  Movable
        spanned  0
        present  0
        managed  0

This patch (of 6):

The third argument is actually number of pages.  Change the variable name
from size to nr_pages to indicate this better.

No functional change in this patch.

Link: http://lkml.kernel.org/r/20191006085646.5768-3-david@redhat.com
	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Pankaj Gupta <pagupta@redhat.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
	Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.ibm.com>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1f8d75c1b7dc62f017c542ca99e7da4a0839fb1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 408ce1a15e62,3c4eb750a199..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -5596,11 -5946,12 +5596,11 @@@ not_early
  #ifdef CONFIG_ZONE_DEVICE
  void __ref memmap_init_zone_device(struct zone *zone,
  				   unsigned long start_pfn,
- 				   unsigned long size,
+ 				   unsigned long nr_pages,
  				   struct dev_pagemap *pgmap)
  {
- 	unsigned long pfn, end_pfn = start_pfn + size;
+ 	unsigned long pfn, end_pfn = start_pfn + nr_pages;
  	struct pglist_data *pgdat = zone->zone_pgdat;
 -	struct vmem_altmap *altmap = pgmap_altmap(pgmap);
  	unsigned long zone_idx = zone_idx(zone);
  	unsigned long start = jiffies;
  	int nid = pgdat->node_id;
@@@ -5613,11 -5964,9 +5613,11 @@@
  	 * of the pages reserved for the memmap, so we can just jump to
  	 * the end of that region and start processing the device pages.
  	 */
 -	if (altmap) {
 +	if (pgmap->altmap_valid) {
 +		struct vmem_altmap *altmap = &pgmap->altmap;
 +
  		start_pfn = altmap->base_pfn + vmem_altmap_offset(altmap);
- 		size = end_pfn - start_pfn;
+ 		nr_pages = end_pfn - start_pfn;
  	}
  
  	for (pfn = start_pfn; pfn < end_pfn; pfn++) {
@@@ -5663,8 -6012,8 +5663,13 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	pr_info("%s initialised, %lu pages in %ums\n", dev_name(pgmap->dev),
 +		size, jiffies_to_msecs(jiffies - start));
++=======
+ 	pr_info("%s initialised %lu pages in %ums\n", __func__,
+ 		nr_pages, jiffies_to_msecs(jiffies - start));
++>>>>>>> 1f8d75c1b7dc (mm/memmap_init: update variable name in memmap_init_zone)
  }
  
  #endif
* Unmerged path mm/page_alloc.c
