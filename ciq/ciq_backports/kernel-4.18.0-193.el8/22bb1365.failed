IB/hfi1: Use a common pad buffer for 9B and 16B packets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Mike Marciniszyn <mike.marciniszyn@intel.com>
commit 22bb13653410424d9fce8d447506a41f8292f22f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/22bb1365.failed

There is no reason for a different pad buffer for the two
packet types.

Expand the current buffer allocation to allow for both
packet types.

Fixes: f8195f3b14a0 ("IB/hfi1: Eliminate allocation while atomic")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Reviewed-by: Kaike Wan <kaike.wan@intel.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
Link: https://lore.kernel.org/r/20191004204934.26838.13099.stgit@awfm-01.aw.intel.com
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 22bb13653410424d9fce8d447506a41f8292f22f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/sdma.c
diff --cc drivers/infiniband/hw/hfi1/sdma.c
index 96103d2381f9,c61b6022575e..000000000000
--- a/drivers/infiniband/hw/hfi1/sdma.c
+++ b/drivers/infiniband/hw/hfi1/sdma.c
@@@ -1497,12 -1492,8 +1498,17 @@@ int sdma_init(struct hfi1_devdata *dd, 
  	}
  
  	/* Allocate memory for pad */
++<<<<<<< HEAD
 +	dd->sdma_pad_dma = dma_zalloc_coherent(
 +		&dd->pcidev->dev,
 +		sizeof(u32),
 +		&dd->sdma_pad_phys,
 +		GFP_KERNEL
 +	);
++=======
+ 	dd->sdma_pad_dma = dma_alloc_coherent(&dd->pcidev->dev, SDMA_PAD,
+ 					      &dd->sdma_pad_phys, GFP_KERNEL);
++>>>>>>> 22bb13653410 (IB/hfi1: Use a common pad buffer for 9B and 16B packets)
  	if (!dd->sdma_pad_dma) {
  		dd_dev_err(dd, "failed to allocate SendDMA pad memory\n");
  		goto bail;
* Unmerged path drivers/infiniband/hw/hfi1/sdma.c
diff --git a/drivers/infiniband/hw/hfi1/verbs.c b/drivers/infiniband/hw/hfi1/verbs.c
index edcef3d70a2e..2b38a7da7af0 100644
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@ -147,9 +147,6 @@ static int pio_wait(struct rvt_qp *qp,
 /* Length of buffer to create verbs txreq cache name */
 #define TXREQ_NAME_LEN 24
 
-/* 16B trailing buffer */
-static const u8 trail_buf[MAX_16B_PADDING];
-
 static uint wss_threshold = 80;
 module_param(wss_threshold, uint, S_IRUGO);
 MODULE_PARM_DESC(wss_threshold, "Percentage (1-100) of LLC to use as a threshold for a cacheless copy");
@@ -820,8 +817,8 @@ static int build_verbs_tx_desc(
 
 	/* add icrc, lt byte, and padding to flit */
 	if (extra_bytes)
-		ret = sdma_txadd_kvaddr(sde->dd, &tx->txreq,
-					(void *)trail_buf, extra_bytes);
+		ret = sdma_txadd_daddr(sde->dd, &tx->txreq,
+				       sde->dd->sdma_pad_phys, extra_bytes);
 
 bail_txadd:
 	return ret;
@@ -1089,7 +1086,8 @@ int hfi1_verbs_send_pio(struct rvt_qp *qp, struct hfi1_pkt_state *ps,
 		}
 		/* add icrc, lt byte, and padding to flit */
 		if (extra_bytes)
-			seg_pio_copy_mid(pbuf, trail_buf, extra_bytes);
+			seg_pio_copy_mid(pbuf, ppd->dd->sdma_pad_dma,
+					 extra_bytes);
 
 		seg_pio_copy_end(pbuf);
 	}
