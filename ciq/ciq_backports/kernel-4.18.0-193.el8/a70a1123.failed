perf bpf: Save BTF information as headers to perf.data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Song Liu <songliubraving@fb.com>
commit a70a1123174ab592c5fa8ecf09f9fad9b335b872
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a70a1123.failed

This patch enables 'perf record' to save BTF information as headers to
perf.data.

A new header type HEADER_BPF_BTF is introduced for this data.

Committer testing:

As root, being on the kernel sources top level directory, run:

    # perf trace -e tools/perf/examples/bpf/augmented_raw_syscalls.c -e *msg

Just to compile and load a BPF program that attaches to the
raw_syscalls:sys_{enter,exit} tracepoints to trace the syscalls ending
in "msg" (recvmsg, sendmsg, recvmmsg, sendmmsg, etc).

Make sure you have a recent enough clang, say version 9, to get the
BTF ELF sections needed for this testing:

  # clang --version | head -1
  clang version 9.0.0 (https://git.llvm.org/git/clang.git/ 7906282d3afec5dfdc2b27943fd6c0309086c507) (https://git.llvm.org/git/llvm.git/ a1b5de1ff8ae8bc79dc8e86e1f82565229bd0500)
  # readelf -SW tools/perf/examples/bpf/augmented_raw_syscalls.o | grep BTF
    [22] .BTF              PROGBITS        0000000000000000 000ede 000b0e 00      0   0  1
    [23] .BTF.ext          PROGBITS        0000000000000000 0019ec 0002a0 00      0   0  1
    [24] .rel.BTF.ext      REL             0000000000000000 002fa8 000270 10     30  23  8

Then do a systemwide perf record session for a few seconds:

  # perf record -a sleep 2s

Then look at:

  # perf report --header-only | grep b[pt]f
  # event : name = cycles:ppp, , id = { 1116204, 1116205, 1116206, 1116207, 1116208, 1116209, 1116210, 1116211 }, size = 112, { sample_period, sample_freq } = 4000, sample_type = IP|TID|TIME|PERIOD, read_format = ID, disabled = 1, inherit = 1, mmap = 1, comm = 1, freq = 1, enable_on_exec = 1, task = 1, precise_ip = 3, sample_id_all = 1, exclude_guest = 1, mmap2 = 1, comm_exec = 1, ksymbol = 1, bpf_event = 1
  # bpf_prog_info of id 13
  # bpf_prog_info of id 14
  # bpf_prog_info of id 15
  # bpf_prog_info of id 16
  # bpf_prog_info of id 17
  # bpf_prog_info of id 18
  # bpf_prog_info of id 21
  # bpf_prog_info of id 22
  # bpf_prog_info of id 51
  # bpf_prog_info of id 52
  # btf info of id 8
  #

We need to show more info about these BPF and BTF entries , but that can
be done later.

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Reviewed-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stanislav Fomichev <sdf@google.com>
	Cc: kernel-team@fb.com
Link: http://lkml.kernel.org/r/20190312053051.2690567-10-songliubraving@fb.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a70a1123174ab592c5fa8ecf09f9fad9b335b872)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/header.c
#	tools/perf/util/header.h
diff --cc tools/perf/util/header.c
index 5b16579df3db,01dda2f65d36..000000000000
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@@ -1085,6 -878,89 +1085,92 @@@ static int write_dir_format(struct feat
  	return do_write(ff, &data->dir.version, sizeof(data->dir.version));
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef HAVE_LIBBPF_SUPPORT
+ static int write_bpf_prog_info(struct feat_fd *ff,
+ 			       struct perf_evlist *evlist __maybe_unused)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	struct rb_root *root;
+ 	struct rb_node *next;
+ 	int ret;
+ 
+ 	down_read(&env->bpf_progs.lock);
+ 
+ 	ret = do_write(ff, &env->bpf_progs.infos_cnt,
+ 		       sizeof(env->bpf_progs.infos_cnt));
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	root = &env->bpf_progs.infos;
+ 	next = rb_first(root);
+ 	while (next) {
+ 		struct bpf_prog_info_node *node;
+ 		size_t len;
+ 
+ 		node = rb_entry(next, struct bpf_prog_info_node, rb_node);
+ 		next = rb_next(&node->rb_node);
+ 		len = sizeof(struct bpf_prog_info_linear) +
+ 			node->info_linear->data_len;
+ 
+ 		/* before writing to file, translate address to offset */
+ 		bpf_program__bpil_addr_to_offs(node->info_linear);
+ 		ret = do_write(ff, node->info_linear, len);
+ 		/*
+ 		 * translate back to address even when do_write() fails,
+ 		 * so that this function never changes the data.
+ 		 */
+ 		bpf_program__bpil_offs_to_addr(node->info_linear);
+ 		if (ret < 0)
+ 			goto out;
+ 	}
+ out:
+ 	up_read(&env->bpf_progs.lock);
+ 	return ret;
+ }
+ #else // HAVE_LIBBPF_SUPPORT
+ static int write_bpf_prog_info(struct feat_fd *ff __maybe_unused,
+ 			       struct perf_evlist *evlist __maybe_unused)
+ {
+ 	return 0;
+ }
+ #endif // HAVE_LIBBPF_SUPPORT
+ 
+ static int write_bpf_btf(struct feat_fd *ff,
+ 			 struct perf_evlist *evlist __maybe_unused)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	struct rb_root *root;
+ 	struct rb_node *next;
+ 	int ret;
+ 
+ 	down_read(&env->bpf_progs.lock);
+ 
+ 	ret = do_write(ff, &env->bpf_progs.btfs_cnt,
+ 		       sizeof(env->bpf_progs.btfs_cnt));
+ 
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	root = &env->bpf_progs.btfs;
+ 	next = rb_first(root);
+ 	while (next) {
+ 		struct btf_node *node;
+ 
+ 		node = rb_entry(next, struct btf_node, rb_node);
+ 		next = rb_next(&node->rb_node);
+ 		ret = do_write(ff, &node->id,
+ 			       sizeof(u32) * 2 + node->data_size);
+ 		if (ret < 0)
+ 			goto out;
+ 	}
+ out:
+ 	up_read(&env->bpf_progs.lock);
+ 	return ret;
+ }
+ 
++>>>>>>> a70a1123174a (perf bpf: Save BTF information as headers to perf.data)
  static int cpu_cache_level__sort(const void *a, const void *b)
  {
  	struct cpu_cache_level *cache_a = (struct cpu_cache_level *)a;
@@@ -1577,6 -1452,51 +1663,54 @@@ static void print_dir_format(struct fea
  	fprintf(fp, "# directory data version : %"PRIu64"\n", data->dir.version);
  }
  
++<<<<<<< HEAD
++=======
+ static void print_bpf_prog_info(struct feat_fd *ff, FILE *fp)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	struct rb_root *root;
+ 	struct rb_node *next;
+ 
+ 	down_read(&env->bpf_progs.lock);
+ 
+ 	root = &env->bpf_progs.infos;
+ 	next = rb_first(root);
+ 
+ 	while (next) {
+ 		struct bpf_prog_info_node *node;
+ 
+ 		node = rb_entry(next, struct bpf_prog_info_node, rb_node);
+ 		next = rb_next(&node->rb_node);
+ 		fprintf(fp, "# bpf_prog_info of id %u\n",
+ 			node->info_linear->info.id);
+ 	}
+ 
+ 	up_read(&env->bpf_progs.lock);
+ }
+ 
+ static void print_bpf_btf(struct feat_fd *ff, FILE *fp)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	struct rb_root *root;
+ 	struct rb_node *next;
+ 
+ 	down_read(&env->bpf_progs.lock);
+ 
+ 	root = &env->bpf_progs.btfs;
+ 	next = rb_first(root);
+ 
+ 	while (next) {
+ 		struct btf_node *node;
+ 
+ 		node = rb_entry(next, struct btf_node, rb_node);
+ 		next = rb_next(&node->rb_node);
+ 		fprintf(fp, "# btf info of id %u\n", node->id);
+ 	}
+ 
+ 	up_read(&env->bpf_progs.lock);
+ }
+ 
++>>>>>>> a70a1123174a (perf bpf: Save BTF information as headers to perf.data)
  static void free_event_desc(struct perf_evsel *events)
  {
  	struct perf_evsel *evsel;
@@@ -2624,6 -2544,124 +2758,127 @@@ static int process_dir_format(struct fe
  	return do_read_u64(ff, &data->dir.version);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef HAVE_LIBBPF_SUPPORT
+ static int process_bpf_prog_info(struct feat_fd *ff, void *data __maybe_unused)
+ {
+ 	struct bpf_prog_info_linear *info_linear;
+ 	struct bpf_prog_info_node *info_node;
+ 	struct perf_env *env = &ff->ph->env;
+ 	u32 count, i;
+ 	int err = -1;
+ 
+ 	if (ff->ph->needs_swap) {
+ 		pr_warning("interpreting bpf_prog_info from systems with endianity is not yet supported\n");
+ 		return 0;
+ 	}
+ 
+ 	if (do_read_u32(ff, &count))
+ 		return -1;
+ 
+ 	down_write(&env->bpf_progs.lock);
+ 
+ 	for (i = 0; i < count; ++i) {
+ 		u32 info_len, data_len;
+ 
+ 		info_linear = NULL;
+ 		info_node = NULL;
+ 		if (do_read_u32(ff, &info_len))
+ 			goto out;
+ 		if (do_read_u32(ff, &data_len))
+ 			goto out;
+ 
+ 		if (info_len > sizeof(struct bpf_prog_info)) {
+ 			pr_warning("detected invalid bpf_prog_info\n");
+ 			goto out;
+ 		}
+ 
+ 		info_linear = malloc(sizeof(struct bpf_prog_info_linear) +
+ 				     data_len);
+ 		if (!info_linear)
+ 			goto out;
+ 		info_linear->info_len = sizeof(struct bpf_prog_info);
+ 		info_linear->data_len = data_len;
+ 		if (do_read_u64(ff, (u64 *)(&info_linear->arrays)))
+ 			goto out;
+ 		if (__do_read(ff, &info_linear->info, info_len))
+ 			goto out;
+ 		if (info_len < sizeof(struct bpf_prog_info))
+ 			memset(((void *)(&info_linear->info)) + info_len, 0,
+ 			       sizeof(struct bpf_prog_info) - info_len);
+ 
+ 		if (__do_read(ff, info_linear->data, data_len))
+ 			goto out;
+ 
+ 		info_node = malloc(sizeof(struct bpf_prog_info_node));
+ 		if (!info_node)
+ 			goto out;
+ 
+ 		/* after reading from file, translate offset to address */
+ 		bpf_program__bpil_offs_to_addr(info_linear);
+ 		info_node->info_linear = info_linear;
+ 		perf_env__insert_bpf_prog_info(env, info_node);
+ 	}
+ 
+ 	return 0;
+ out:
+ 	free(info_linear);
+ 	free(info_node);
+ 	up_write(&env->bpf_progs.lock);
+ 	return err;
+ }
+ #else // HAVE_LIBBPF_SUPPORT
+ static int process_bpf_prog_info(struct feat_fd *ff __maybe_unused, void *data __maybe_unused)
+ {
+ 	return 0;
+ }
+ #endif // HAVE_LIBBPF_SUPPORT
+ 
+ static int process_bpf_btf(struct feat_fd *ff, void *data __maybe_unused)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	u32 count, i;
+ 
+ 	if (ff->ph->needs_swap) {
+ 		pr_warning("interpreting btf from systems with endianity is not yet supported\n");
+ 		return 0;
+ 	}
+ 
+ 	if (do_read_u32(ff, &count))
+ 		return -1;
+ 
+ 	down_write(&env->bpf_progs.lock);
+ 
+ 	for (i = 0; i < count; ++i) {
+ 		struct btf_node *node;
+ 		u32 id, data_size;
+ 
+ 		if (do_read_u32(ff, &id))
+ 			return -1;
+ 		if (do_read_u32(ff, &data_size))
+ 			return -1;
+ 
+ 		node = malloc(sizeof(struct btf_node) + data_size);
+ 		if (!node)
+ 			return -1;
+ 
+ 		node->id = id;
+ 		node->data_size = data_size;
+ 
+ 		if (__do_read(ff, node->data, data_size)) {
+ 			free(node);
+ 			return -1;
+ 		}
+ 
+ 		perf_env__insert_btf(env, node);
+ 	}
+ 
+ 	up_write(&env->bpf_progs.lock);
+ 	return 0;
+ }
+ 
++>>>>>>> a70a1123174a (perf bpf: Save BTF information as headers to perf.data)
  struct feature_ops {
  	int (*write)(struct feat_fd *ff, struct perf_evlist *evlist);
  	void (*print)(struct feat_fd *ff, FILE *fp);
@@@ -2684,7 -2722,9 +2939,13 @@@ static const struct feature_ops feat_op
  	FEAT_OPR(SAMPLE_TIME,	sample_time,	false),
  	FEAT_OPR(MEM_TOPOLOGY,	mem_topology,	true),
  	FEAT_OPR(CLOCKID,	clockid,	false),
++<<<<<<< HEAD
 +	FEAT_OPN(DIR_FORMAT,	dir_format,	false)
++=======
+ 	FEAT_OPN(DIR_FORMAT,	dir_format,	false),
+ 	FEAT_OPR(BPF_PROG_INFO, bpf_prog_info,  false),
+ 	FEAT_OPR(BPF_BTF,       bpf_btf,        false),
++>>>>>>> a70a1123174a (perf bpf: Save BTF information as headers to perf.data)
  };
  
  struct header_print_data {
diff --cc tools/perf/util/header.h
index 6a231340238d,386da49e1bfa..000000000000
--- a/tools/perf/util/header.h
+++ b/tools/perf/util/header.h
@@@ -40,6 -40,8 +40,11 @@@ enum 
  	HEADER_MEM_TOPOLOGY,
  	HEADER_CLOCKID,
  	HEADER_DIR_FORMAT,
++<<<<<<< HEAD
++=======
+ 	HEADER_BPF_PROG_INFO,
+ 	HEADER_BPF_BTF,
++>>>>>>> a70a1123174a (perf bpf: Save BTF information as headers to perf.data)
  	HEADER_LAST_FEATURE,
  	HEADER_FEAT_BITS	= 256,
  };
* Unmerged path tools/perf/util/header.c
* Unmerged path tools/perf/util/header.h
