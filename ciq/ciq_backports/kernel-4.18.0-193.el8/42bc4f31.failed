HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [hid] logitech-hidpp: add support for HID++ 1.0 consumer keys reports (Benjamin Tissoires) [1740778]
Rebuild_FUZZ: 96.18%
commit-author Hans de Goede <hdegoede@redhat.com>
commit 42bc4f3129e6565567ee63116850c530dc561aa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/42bc4f31.failed

All Logitech 27 MHz keyboards and also the MX5000 bluetooth keyboard use
Logitech custom usages of 0x10xx in the consumer page. The descriptor for
the consumer input-report only declares usages up to 652, so we end up
dropping all the input-reports reporting 0x10xx usages without reporting
events for these to userspace.

This commit adds a descriptor_fixup function for this which changes the
usage and logical maximum to 0x107f. Mapping these usages to something
other then KEY_UNKNOWN is left to userspace (hwdb). Note:
1. The old descriptor_fixup for this in hid-lg.c used a maximimum of 0x104d
   this is not high enough, the S520 keyboard battery key sends 0x106f.
2. The descriptor_fixup is flexible so that it works with both the kbd-
   desc. passed by the logitech-dj code and with bluetooth descriptors.

The descriptor_fixup makes most keys work on 27 MHz keyboards, but it is
not enough to get all keys to work on 27 MHz keyboards and just the fixup
is not enough to get the MX5000 to generate 0x10xx events:

1) The LX501 and MX3000 27 MHz kbds both have a button labelled "media"
(called "Media Player" by SetPoint) and a button with a remote-control
symbol ("Media Life" in SetPoint) which both send an identical consumer
usage-page code (0x0183) making the 2 buttons indistinguishable,
switching to HID++ 1.0 consumer keys reports makes the remote-control
symbol button generate a 0x10xx Logitech specific code instead.

2) The MX5000 Bluetooth keyboard has 11 keys which report 0x10xx consumer
page usages, but unlike 27 MHz devices which happily send 0x10xx codes in
their normal consumer-page input-report, the MX5000 honors the maximum of
652 from its descriptor and sends a 0x0000 code (so release) whenever these
keys are pressed. When switching to HID++ sub-id 0x03 HID++ 1.0 consumer
keys reports these 0x10xx codes do get properly reported.

This commit adds support for HID++ 1.0 consumer keys reports and enables
this for all 27 MHz keyboards and for the MX5000.

	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
(cherry picked from commit 42bc4f3129e6565567ee63116850c530dc561aa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-logitech-hidpp.c
diff --cc drivers/hid/hid-logitech-hidpp.c
index 844711d5f9a8,72fc9c0566db..000000000000
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@@ -50,7 -51,11 +50,15 @@@ MODULE_PARM_DESC(disable_tap_to_click
  
  #define HIDPP_REPORT_SHORT_LENGTH		7
  #define HIDPP_REPORT_LONG_LENGTH		20
++<<<<<<< HEAD
 +#define HIDPP_REPORT_VERY_LONG_LENGTH		64
++=======
+ #define HIDPP_REPORT_VERY_LONG_MAX_LENGTH	64
+ 
+ #define HIDPP_SUB_ID_CONSUMER_VENDOR_KEYS	0x03
+ #define HIDPP_SUB_ID_ROLLER			0x05
+ #define HIDPP_SUB_ID_MOUSE_EXTRA_BTNS		0x06
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  
  #define HIDPP_QUIRK_CLASS_WTP			BIT(0)
  #define HIDPP_QUIRK_CLASS_M560			BIT(1)
@@@ -67,6 -72,13 +75,16 @@@
  #define HIDPP_QUIRK_HI_RES_SCROLL_1P0		BIT(26)
  #define HIDPP_QUIRK_HI_RES_SCROLL_X2120		BIT(27)
  #define HIDPP_QUIRK_HI_RES_SCROLL_X2121		BIT(28)
++<<<<<<< HEAD
++=======
+ #define HIDPP_QUIRK_HIDPP_WHEELS		BIT(29)
+ #define HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS	BIT(30)
+ #define HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS	BIT(31)
+ 
+ /* These are just aliases for now */
+ #define HIDPP_QUIRK_KBD_SCROLL_WHEEL HIDPP_QUIRK_HIDPP_WHEELS
+ #define HIDPP_QUIRK_KBD_ZOOM_WHEEL   HIDPP_QUIRK_HIDPP_WHEELS
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  
  /* Convenience constant to check for any high-res support. */
  #define HIDPP_QUIRK_HI_RES_SCROLL	(HIDPP_QUIRK_HI_RES_SCROLL_1P0 | \
@@@ -2677,6 -2750,175 +2695,178 @@@ static int g920_get_config(struct hidpp
  }
  
  /* -------------------------------------------------------------------------- */
++<<<<<<< HEAD
++=======
+ /* HID++1.0 devices which use HID++ reports for their wheels                  */
+ /* -------------------------------------------------------------------------- */
+ static int hidpp10_wheel_connect(struct hidpp_device *hidpp)
+ {
+ 	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
+ 			HIDPP_ENABLE_WHEEL_REPORT | HIDPP_ENABLE_HWHEEL_REPORT,
+ 			HIDPP_ENABLE_WHEEL_REPORT | HIDPP_ENABLE_HWHEEL_REPORT);
+ }
+ 
+ static int hidpp10_wheel_raw_event(struct hidpp_device *hidpp,
+ 				   u8 *data, int size)
+ {
+ 	s8 value, hvalue;
+ 
+ 	if (!hidpp->input)
+ 		return -EINVAL;
+ 
+ 	if (size < 7)
+ 		return 0;
+ 
+ 	if (data[0] != REPORT_ID_HIDPP_SHORT || data[2] != HIDPP_SUB_ID_ROLLER)
+ 		return 0;
+ 
+ 	value = data[3];
+ 	hvalue = data[4];
+ 
+ 	input_report_rel(hidpp->input, REL_WHEEL, value);
+ 	input_report_rel(hidpp->input, REL_WHEEL_HI_RES, value * 120);
+ 	input_report_rel(hidpp->input, REL_HWHEEL, hvalue);
+ 	input_report_rel(hidpp->input, REL_HWHEEL_HI_RES, hvalue * 120);
+ 	input_sync(hidpp->input);
+ 
+ 	return 1;
+ }
+ 
+ static void hidpp10_wheel_populate_input(struct hidpp_device *hidpp,
+ 					 struct input_dev *input_dev)
+ {
+ 	__set_bit(EV_REL, input_dev->evbit);
+ 	__set_bit(REL_WHEEL, input_dev->relbit);
+ 	__set_bit(REL_WHEEL_HI_RES, input_dev->relbit);
+ 	__set_bit(REL_HWHEEL, input_dev->relbit);
+ 	__set_bit(REL_HWHEEL_HI_RES, input_dev->relbit);
+ }
+ 
+ /* -------------------------------------------------------------------------- */
+ /* HID++1.0 mice which use HID++ reports for extra mouse buttons              */
+ /* -------------------------------------------------------------------------- */
+ static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
+ {
+ 	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
+ 				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
+ 				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
+ }
+ 
+ static int hidpp10_extra_mouse_buttons_raw_event(struct hidpp_device *hidpp,
+ 				    u8 *data, int size)
+ {
+ 	int i;
+ 
+ 	if (!hidpp->input)
+ 		return -EINVAL;
+ 
+ 	if (size < 7)
+ 		return 0;
+ 
+ 	if (data[0] != REPORT_ID_HIDPP_SHORT ||
+ 	    data[2] != HIDPP_SUB_ID_MOUSE_EXTRA_BTNS)
+ 		return 0;
+ 
+ 	/*
+ 	 * Buttons are either delivered through the regular mouse report *or*
+ 	 * through the extra buttons report. At least for button 6 how it is
+ 	 * delivered differs per receiver firmware version. Even receivers with
+ 	 * the same usb-id show different behavior, so we handle both cases.
+ 	 */
+ 	for (i = 0; i < 8; i++)
+ 		input_report_key(hidpp->input, BTN_MOUSE + i,
+ 				 (data[3] & (1 << i)));
+ 
+ 	/* Some mice report events on button 9+, use BTN_MISC */
+ 	for (i = 0; i < 8; i++)
+ 		input_report_key(hidpp->input, BTN_MISC + i,
+ 				 (data[4] & (1 << i)));
+ 
+ 	input_sync(hidpp->input);
+ 	return 1;
+ }
+ 
+ static void hidpp10_extra_mouse_buttons_populate_input(
+ 			struct hidpp_device *hidpp, struct input_dev *input_dev)
+ {
+ 	/* BTN_MOUSE - BTN_MOUSE+7 are set already by the descriptor */
+ 	__set_bit(BTN_0, input_dev->keybit);
+ 	__set_bit(BTN_1, input_dev->keybit);
+ 	__set_bit(BTN_2, input_dev->keybit);
+ 	__set_bit(BTN_3, input_dev->keybit);
+ 	__set_bit(BTN_4, input_dev->keybit);
+ 	__set_bit(BTN_5, input_dev->keybit);
+ 	__set_bit(BTN_6, input_dev->keybit);
+ 	__set_bit(BTN_7, input_dev->keybit);
+ }
+ 
+ /* -------------------------------------------------------------------------- */
+ /* HID++1.0 kbds which only report 0x10xx consumer usages through sub-id 0x03 */
+ /* -------------------------------------------------------------------------- */
+ 
+ /* Find the consumer-page input report desc and change Maximums to 0x107f */
+ static u8 *hidpp10_consumer_keys_report_fixup(struct hidpp_device *hidpp,
+ 					      u8 *_rdesc, unsigned int *rsize)
+ {
+ 	/* Note 0 terminated so we can use strnstr to search for this. */
+ 	const char consumer_rdesc_start[] = {
+ 		0x05, 0x0C,	/* USAGE_PAGE (Consumer Devices)       */
+ 		0x09, 0x01,	/* USAGE (Consumer Control)            */
+ 		0xA1, 0x01,	/* COLLECTION (Application)            */
+ 		0x85, 0x03,	/* REPORT_ID = 3                       */
+ 		0x75, 0x10,	/* REPORT_SIZE (16)                    */
+ 		0x95, 0x02,	/* REPORT_COUNT (2)                    */
+ 		0x15, 0x01,	/* LOGICAL_MIN (1)                     */
+ 		0x26, 0x00	/* LOGICAL_MAX (...                    */
+ 	};
+ 	char *consumer_rdesc, *rdesc = (char *)_rdesc;
+ 	unsigned int size;
+ 
+ 	consumer_rdesc = strnstr(rdesc, consumer_rdesc_start, *rsize);
+ 	size = *rsize - (consumer_rdesc - rdesc);
+ 	if (consumer_rdesc && size >= 25) {
+ 		consumer_rdesc[15] = 0x7f;
+ 		consumer_rdesc[16] = 0x10;
+ 		consumer_rdesc[20] = 0x7f;
+ 		consumer_rdesc[21] = 0x10;
+ 	}
+ 	return _rdesc;
+ }
+ 
+ static int hidpp10_consumer_keys_connect(struct hidpp_device *hidpp)
+ {
+ 	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
+ 				    HIDPP_ENABLE_CONSUMER_REPORT,
+ 				    HIDPP_ENABLE_CONSUMER_REPORT);
+ }
+ 
+ static int hidpp10_consumer_keys_raw_event(struct hidpp_device *hidpp,
+ 					   u8 *data, int size)
+ {
+ 	u8 consumer_report[5];
+ 
+ 	if (size < 7)
+ 		return 0;
+ 
+ 	if (data[0] != REPORT_ID_HIDPP_SHORT ||
+ 	    data[2] != HIDPP_SUB_ID_CONSUMER_VENDOR_KEYS)
+ 		return 0;
+ 
+ 	/*
+ 	 * Build a normal consumer report (3) out of the data, this detour
+ 	 * is necessary to get some keyboards to report their 0x10xx usages.
+ 	 */
+ 	consumer_report[0] = 0x03;
+ 	memcpy(&consumer_report[1], &data[3], 4);
+ 	/* We are called from atomic context */
+ 	hid_report_raw_event(hidpp->hid_dev, HID_INPUT_REPORT,
+ 			     consumer_report, 5, 1);
+ 
+ 	return 1;
+ }
+ 
+ /* -------------------------------------------------------------------------- */
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  /* High-resolution scroll wheels                                              */
  /* -------------------------------------------------------------------------- */
  
@@@ -2861,6 -3095,24 +3067,27 @@@ static int hidpp_raw_hidpp_event(struc
  			return ret;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (hidpp->quirks & HIDPP_QUIRK_HIDPP_WHEELS) {
+ 		ret = hidpp10_wheel_raw_event(hidpp, data, size);
+ 		if (ret != 0)
+ 			return ret;
+ 	}
+ 
+ 	if (hidpp->quirks & HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS) {
+ 		ret = hidpp10_extra_mouse_buttons_raw_event(hidpp, data, size);
+ 		if (ret != 0)
+ 			return ret;
+ 	}
+ 
+ 	if (hidpp->quirks & HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS) {
+ 		ret = hidpp10_consumer_keys_raw_event(hidpp, data, size);
+ 		if (ret != 0)
+ 			return ret;
+ 	}
+ 
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  	return 0;
  }
  
@@@ -3100,6 -3360,24 +3327,27 @@@ static void hidpp_connect_event(struct 
  			return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (hidpp->quirks & HIDPP_QUIRK_HIDPP_WHEELS) {
+ 		ret = hidpp10_wheel_connect(hidpp);
+ 		if (ret)
+ 			return;
+ 	}
+ 
+ 	if (hidpp->quirks & HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS) {
+ 		ret = hidpp10_extra_mouse_buttons_connect(hidpp);
+ 		if (ret)
+ 			return;
+ 	}
+ 
+ 	if (hidpp->quirks & HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS) {
+ 		ret = hidpp10_consumer_keys_connect(hidpp);
+ 		if (ret)
+ 			return;
+ 	}
+ 
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  	/* the device is already connected, we can ask for its name and
  	 * protocol */
  	if (!hidpp->protocol_major) {
@@@ -3178,20 -3510,48 +3426,57 @@@ static int hidpp_probe(struct hid_devic
  	bool connected;
  	unsigned int connect_mask = HID_CONNECT_DEFAULT;
  
++<<<<<<< HEAD
 +	hidpp = devm_kzalloc(&hdev->dev, sizeof(struct hidpp_device),
 +			GFP_KERNEL);
++=======
+ 	/* report_fixup needs drvdata to be set before we call hid_parse */
+ 	hidpp = devm_kzalloc(&hdev->dev, sizeof(*hidpp), GFP_KERNEL);
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  	if (!hidpp)
  		return -ENOMEM;
  
  	hidpp->hid_dev = hdev;
  	hidpp->name = hdev->name;
++<<<<<<< HEAD
 +	hid_set_drvdata(hdev, hidpp);
 +
 +	hidpp->quirks = id->driver_data;
++=======
+ 	hidpp->quirks = id->driver_data;
+ 	hid_set_drvdata(hdev, hidpp);
+ 
+ 	ret = hid_parse(hdev);
+ 	if (ret) {
+ 		hid_err(hdev, "%s:parse failed\n", __func__);
+ 		return ret;
+ 	}
+ 
+ 	/*
+ 	 * Make sure the device is HID++ capable, otherwise treat as generic HID
+ 	 */
+ 	if (!hidpp_validate_device(hdev)) {
+ 		hid_set_drvdata(hdev, NULL);
+ 		devm_kfree(&hdev->dev, hidpp);
+ 		return hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+ 	}
 -
 -	hidpp->very_long_report_length =
 -		hidpp_get_report_length(hdev, REPORT_ID_HIDPP_VERY_LONG);
 -	if (hidpp->very_long_report_length > HIDPP_REPORT_VERY_LONG_MAX_LENGTH)
 -		hidpp->very_long_report_length = HIDPP_REPORT_VERY_LONG_MAX_LENGTH;
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  
  	if (id->group == HID_GROUP_LOGITECH_DJ_DEVICE)
  		hidpp->quirks |= HIDPP_QUIRK_UNIFYING;
  
++<<<<<<< HEAD
++=======
+ 	if (id->group == HID_GROUP_LOGITECH_27MHZ_DEVICE &&
+ 	    hidpp_application_equals(hdev, HID_GD_MOUSE))
+ 		hidpp->quirks |= HIDPP_QUIRK_HIDPP_WHEELS |
+ 				 HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS;
+ 
+ 	if (id->group == HID_GROUP_LOGITECH_27MHZ_DEVICE &&
+ 	    hidpp_application_equals(hdev, HID_GD_KEYBOARD))
+ 		hidpp->quirks |= HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS;
+ 
++>>>>>>> 42bc4f3129e6 (HID: logitech-hidpp: add support for HID++ 1.0 consumer keys reports)
  	if (disable_raw_mode) {
  		hidpp->quirks &= ~HIDPP_QUIRK_CLASS_WTP;
  		hidpp->quirks &= ~HIDPP_QUIRK_NO_HIDINPUT;
@@@ -3379,8 -3735,31 +3667,12 @@@ static const struct hid_device_id hidpp
  
  	{ LDJ_DEVICE(HID_ANY_ID) },
  
 -	{ /* Keyboard LX501 (Y-RR53) */
 -	  L27MHZ_DEVICE(0x0049),
 -	  .driver_data = HIDPP_QUIRK_KBD_ZOOM_WHEEL },
 -	{ /* Keyboard MX3000 (Y-RAM74) */
 -	  L27MHZ_DEVICE(0x0057),
 -	  .driver_data = HIDPP_QUIRK_KBD_SCROLL_WHEEL },
 -	{ /* Keyboard MX3200 (Y-RAV80) */
 -	  L27MHZ_DEVICE(0x005c),
 -	  .driver_data = HIDPP_QUIRK_KBD_ZOOM_WHEEL },
 -
 -	{ L27MHZ_DEVICE(HID_ANY_ID) },
 -
 -	{ /* Logitech G403 Gaming Mouse over USB */
 -	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC082) },
 -	{ /* Logitech G700 Gaming Mouse over USB */
 -	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC06B) },
 -	{ /* Logitech G900 Gaming Mouse over USB */
 -	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC081) },
 -	{ /* Logitech G920 Wheel over USB */
 -	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G920_WHEEL),
 +	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G920_WHEEL),
  		.driver_data = HIDPP_QUIRK_CLASS_G920 | HIDPP_QUIRK_FORCE_OUTPUT_REPORTS},
+ 
+ 	{ /* MX5000 keyboard over Bluetooth */
+ 	  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb305),
+ 	  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },
  	{}
  };
  
* Unmerged path drivers/hid/hid-logitech-hidpp.c
