ASoC: Intel: Skylake: Remove memory available check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: Intel: Skylake: Remove memory available check (Jaroslav Kysela) [1738610]
Rebuild_FUZZ: 94.44%
commit-author Cezary Rojewski <cezary.rojewski@intel.com>
commit e5c29dc5221c328b6e54c5b2aba1feca4003c051
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e5c29dc5.failed

Current memory availability check is a stub, while actual memory
management takes place in firmware. Leave this task to firmware entirely
and remove redundant code.

	Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
Link: https://lore.kernel.org/r/20190723145854.8527-5-cezary.rojewski@intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit e5c29dc5221c328b6e54c5b2aba1feca4003c051)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/intel/skylake/skl-topology.c
#	sound/soc/intel/skylake/skl.h
diff --cc sound/soc/intel/skylake/skl-topology.c
index c1a64d6597c2,53a024c0464d..000000000000
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@@ -110,102 -109,7 +110,106 @@@ static int is_skl_dsp_widget_type(struc
  	}
  }
  
++<<<<<<< HEAD
 +/*
 + * Each pipelines needs memory to be allocated. Check if we have free memory
 + * from available pool.
 + */
 +static bool skl_is_pipe_mem_avail(struct skl *skl,
 +				struct skl_module_cfg *mconfig)
 +{
 +	struct skl_sst *ctx = skl->skl_sst;
 +
 +	if (skl->resource.mem + mconfig->pipe->memory_pages >
 +				skl->resource.max_mem) {
 +		dev_err(ctx->dev,
 +				"%s: module_id %d instance %d\n", __func__,
 +				mconfig->id.module_id,
 +				mconfig->id.instance_id);
 +		dev_err(ctx->dev,
 +				"exceeds ppl memory available %d mem %d\n",
 +				skl->resource.max_mem, skl->resource.mem);
 +		return false;
 +	} else {
 +		return true;
 +	}
 +}
 +
 +/*
 + * Add the mem to the mem pool. This is freed when pipe is deleted.
 + * Note: DSP does actual memory management we only keep track for complete
 + * pool
 + */
 +static void skl_tplg_alloc_pipe_mem(struct skl *skl,
 +				struct skl_module_cfg *mconfig)
 +{
 +	skl->resource.mem += mconfig->pipe->memory_pages;
 +}
 +
 +/*
 + * Pipeline needs needs DSP CPU resources for computation, this is
 + * quantified in MCPS (Million Clocks Per Second) required for module/pipe
 + *
 + * Each pipelines needs mcps to be allocated. Check if we have mcps for this
 + * pipe.
 + */
 +
 +static bool skl_is_pipe_mcps_avail(struct skl *skl,
 +				struct skl_module_cfg *mconfig)
 +{
 +	struct skl_sst *ctx = skl->skl_sst;
 +	u8 res_idx = mconfig->res_idx;
 +	struct skl_module_res *res = &mconfig->module->resources[res_idx];
 +
 +	if (skl->resource.mcps + res->cps > skl->resource.max_mcps) {
 +		dev_err(ctx->dev,
 +			"%s: module_id %d instance %d\n", __func__,
 +			mconfig->id.module_id, mconfig->id.instance_id);
 +		dev_err(ctx->dev,
 +			"exceeds ppl mcps available %d > mem %d\n",
 +			skl->resource.max_mcps, skl->resource.mcps);
 +		return false;
 +	} else {
 +		return true;
 +	}
 +}
 +
 +static void skl_tplg_alloc_pipe_mcps(struct skl *skl,
 +				struct skl_module_cfg *mconfig)
 +{
 +	u8 res_idx = mconfig->res_idx;
 +	struct skl_module_res *res = &mconfig->module->resources[res_idx];
 +
 +	skl->resource.mcps += res->cps;
 +}
 +
 +/*
 + * Free the mcps when tearing down
 + */
 +static void
 +skl_tplg_free_pipe_mcps(struct skl *skl, struct skl_module_cfg *mconfig)
 +{
 +	u8 res_idx = mconfig->res_idx;
 +	struct skl_module_res *res = &mconfig->module->resources[res_idx];
 +
 +	skl->resource.mcps -= res->cps;
 +}
 +
 +/*
 + * Free the memory when tearing down
 + */
 +static void
 +skl_tplg_free_pipe_mem(struct skl *skl, struct skl_module_cfg *mconfig)
 +{
 +	skl->resource.mem -= mconfig->pipe->memory_pages;
 +}
 +
 +
 +static void skl_dump_mconfig(struct skl_sst *ctx,
 +					struct skl_module_cfg *mcfg)
++=======
+ static void skl_dump_mconfig(struct skl_dev *skl, struct skl_module_cfg *mcfg)
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  {
  	struct skl_module_iface *iface = &mcfg->module->formats[0];
  
@@@ -761,13 -656,6 +764,16 @@@ static int skl_tplg_mixer_dapm_pre_pmu_
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	/* check resource available */
 +	if (!skl_is_pipe_mcps_avail(skl, mconfig))
 +		return -EBUSY;
 +
 +	if (!skl_is_pipe_mem_avail(skl, mconfig))
 +		return -ENOMEM;
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  	/*
  	 * Create a list of modules for pipe.
  	 * This list contains modules from source to sink
@@@ -776,9 -664,6 +782,12 @@@
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	skl_tplg_alloc_pipe_mem(skl, mconfig);
 +	skl_tplg_alloc_pipe_mcps(skl, mconfig);
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  	/* Init all pipe modules from source to sink */
  	ret = skl_tplg_init_pipe_modules(skl, s_pipe);
  	if (ret < 0)
@@@ -1274,8 -1158,6 +1283,11 @@@ static int skl_tplg_mixer_dapm_pre_pmd_
  
  /*
   * in the Post-PMD event of mixer we need to do following:
++<<<<<<< HEAD
 + *   - Free the mcps used
 + *   - Free the mem used
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
   *   - Unbind the modules within the pipeline
   *   - Delete the pipeline (modules are not required to be explicitly
   *     deleted, pipeline delete is enough here
@@@ -1293,9 -1174,6 +1305,12 @@@ static int skl_tplg_mixer_dapm_post_pmd
  	if (s_pipe->state == SKL_PIPE_INVALID)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	skl_tplg_free_pipe_mcps(skl, mconfig);
 +	skl_tplg_free_pipe_mem(skl, mconfig);
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  	list_for_each_entry(w_module, &s_pipe->w_list, node) {
  		if (list_empty(&skl->bind_list))
  			break;
@@@ -2993,11 -2869,8 +3008,14 @@@ void skl_cleanup_resources(struct skl *
  	if (!card || !card->instantiated)
  		return;
  
++<<<<<<< HEAD
 +	skl->resource.mem = 0;
 +	skl->resource.mcps = 0;
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  	list_for_each_entry(w, &card->widgets, list) {
 -		if (is_skl_dsp_widget_type(w, skl->dev) && w->priv != NULL)
 +		if (is_skl_dsp_widget_type(w, ctx->dev) && w->priv != NULL)
  			skl_clear_pin_config(soc_component, w);
  	}
  
@@@ -3692,10 -3565,6 +3710,13 @@@ static void skl_tplg_set_pipe_type(stru
  		pipe->passthru = false;
  }
  
++<<<<<<< HEAD
 +/* This will be read from topology manifest, currently defined here */
 +#define SKL_MAX_MCPS 30000000
 +#define SKL_FW_MAX_MEM 1000000
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  /*
   * SKL topology init routine
   */
@@@ -3730,9 -3599,6 +3751,12 @@@ int skl_tplg_init(struct snd_soc_compon
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	skl->resource.max_mcps = SKL_MAX_MCPS;
 +	skl->resource.max_mem = SKL_FW_MAX_MEM;
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  	skl->tplg = fw;
  	ret = skl_tplg_create_pipe_widget_list(component);
  	if (ret < 0)
diff --cc sound/soc/intel/skylake/skl.h
index 1418dc74dcbe,600a61f79b0a..000000000000
--- a/sound/soc/intel/skylake/skl.h
+++ b/sound/soc/intel/skylake/skl.h
@@@ -36,15 -38,9 +36,18 @@@
  #define DMA_TRANSMITION_START	2
  #define DMA_TRANSMITION_STOP	3
  
 -#define AZX_VS_EM2_DUM			BIT(23)
  #define AZX_REG_VS_EM2_L1SEN		BIT(13)
  
++<<<<<<< HEAD
 +struct skl_dsp_resource {
 +	u32 max_mcps;
 +	u32 max_mem;
 +	u32 mcps;
 +	u32 mem;
 +};
 +
++=======
++>>>>>>> e5c29dc5221c (ASoC: Intel: Skylake: Remove memory available check)
  struct skl_debug;
  
  struct skl_astate_param {
@@@ -73,9 -69,7 +76,8 @@@ struct skl 
  	struct snd_soc_dai_driver *dais;
  
  	struct nhlt_acpi_table *nhlt; /* nhlt ptr */
 +	struct skl_sst *skl_sst; /* sst skl ctx */
  
- 	struct skl_dsp_resource resource;
  	struct list_head ppl_list;
  	struct list_head bind_list;
  
* Unmerged path sound/soc/intel/skylake/skl-topology.c
* Unmerged path sound/soc/intel/skylake/skl.h
