SUNRPC: Fix up RPC back channel transmission

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 477687e1116ad16180caf8633dd830b296a5ce73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/477687e1.failed

Now that transmissions happen through a queue, we require the RPC tasks
to handle error conditions that may have been set while they were
sleeping. The back channel does not currently do this, but assumes
that any error condition happens during its own call to xprt_transmit().

The solution is to ensure that the back channel splits out the
error handling just like the forward channel does.

Fixes: 89f90fe1ad8b ("SUNRPC: Allow calls to xprt_transmit() to drain...")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 477687e1116ad16180caf8633dd830b296a5ce73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 53c6c503223a,b9558e10c6c1..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1149,17 -1151,9 +1148,17 @@@ struct rpc_task *rpc_run_bc_task(struc
  	 * Create an rpc_task to send the data
  	 */
  	task = rpc_new_task(&task_setup_data);
 -	xprt_init_bc_request(req, task);
 +	task->tk_rqstp = req;
 +
 +	/*
 +	 * Set up the xdr_buf length.
 +	 * This also indicates that the buffer is XDR encoded already.
 +	 */
 +	xbufp->len = xbufp->head[0].iov_len + xbufp->page_len +
 +			xbufp->tail[0].iov_len;
 +	set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
  
- 	task->tk_action = call_bc_transmit;
+ 	task->tk_action = call_bc_encode;
  	atomic_inc(&task->tk_count);
  	WARN_ON_ONCE(atomic_read(&task->tk_count) != 2);
  	rpc_execute(task);
@@@ -2062,24 -2116,8 +2084,28 @@@ call_bc_transmit_status(struct rpc_tas
  {
  	struct rpc_rqst *req = task->tk_rqstp;
  
++<<<<<<< HEAD
 +	if (!xprt_prepare_transmit(task))
 +		goto out_retry;
 +
 +	if (task->tk_status < 0) {
 +		printk(KERN_NOTICE "RPC: Could not send backchannel reply "
 +			"error: %d\n", task->tk_status);
 +		goto out_done;
 +	}
 +	if (req->rq_connect_cookie != req->rq_xprt->connect_cookie)
 +		req->rq_bytes_sent = 0;
 +
 +	xprt_transmit(task);
 +
 +	if (task->tk_status == -EAGAIN)
 +		goto out_nospace;
 +
 +	xprt_end_transmit(task);
++=======
++>>>>>>> 477687e1116a (SUNRPC: Fix up RPC back channel transmission)
  	dprint_status(task);
+ 
  	switch (task->tk_status) {
  	case 0:
  		/* Success */
@@@ -2093,6 -2131,14 +2119,17 @@@
  	case -ENOTCONN:
  	case -EPIPE:
  		break;
++<<<<<<< HEAD
++=======
+ 	case -ENOBUFS:
+ 		rpc_delay(task, HZ>>2);
+ 		/* fall through */
+ 	case -EBADSLT:
+ 	case -EAGAIN:
+ 		task->tk_status = 0;
+ 		task->tk_action = call_bc_transmit;
+ 		return;
++>>>>>>> 477687e1116a (SUNRPC: Fix up RPC back channel transmission)
  	case -ETIMEDOUT:
  		/*
  		 * Problem reaching the server.  Disconnect and let the
@@@ -2116,14 -2161,7 +2152,18 @@@
  			"error: %d\n", task->tk_status);
  		break;
  	}
++<<<<<<< HEAD
 +	rpc_wake_up_queued_task(&req->rq_xprt->pending, task);
 +out_done:
 +	task->tk_action = rpc_exit_task;
 +	return;
 +out_nospace:
 +	req->rq_connect_cookie = req->rq_xprt->connect_cookie;
 +out_retry:
 +	task->tk_status = 0;
++=======
+ 	task->tk_action = rpc_exit_task;
++>>>>>>> 477687e1116a (SUNRPC: Fix up RPC back channel transmission)
  }
  #endif /* CONFIG_SUNRPC_BACKCHANNEL */
  
* Unmerged path net/sunrpc/clnt.c
