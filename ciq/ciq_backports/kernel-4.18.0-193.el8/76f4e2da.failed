arm64: kexec: always reset to EL2 if present

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit 76f4e2da45b44bf70f61c28fcbc91668492463e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/76f4e2da.failed

Currently machine_kexec() doesn't reset to EL2 in the case of a
crashdump kernel. This leaves potentially dodgy state active at EL2, and
means that if the crashdump kernel attempts to online secondary CPUs,
these will be booted as mismatched ELs.

Let's reset to EL2, as we do in all other cases, and simplify things. If
EL2 state is corrupt, things are already sufficiently bad that kdump is
unlikely to work, and it's best-effort regardless.

	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: James Morse <james.morse@arm.com>
	Acked-by: Marc Zyngier <marc.zyngier@arm.com>
	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit 76f4e2da45b44bf70f61c28fcbc91668492463e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/machine_kexec.c
diff --cc arch/arm64/kernel/machine_kexec.c
index 5cfab7f4b527,f62effc6e064..000000000000
--- a/arch/arm64/kernel/machine_kexec.c
+++ b/arch/arm64/kernel/machine_kexec.c
@@@ -212,19 -205,9 +212,23 @@@ void machine_kexec(struct kimage *kimag
  	 * uses physical addressing to relocate the new image to its final
  	 * position and transfers control to the image entry point when the
  	 * relocation is complete.
 +	 * In kexec case, kimage->start points to purgatory assuming that
 +	 * kernel entry and dtb address are embedded in purgatory by
 +	 * userspace (kexec-tools).
 +	 * In kexec_file case, the kernel starts directly without purgatory.
  	 */
  
++<<<<<<< HEAD
 +	cpu_soft_restart(kimage != kexec_crash_image,
 +		reboot_code_buffer_phys, kimage->head, kimage->start,
 +#ifdef CONFIG_KEXEC_FILE
 +						kimage->arch.dtb_mem);
 +#else
 +						0);
 +#endif
++=======
+ 	cpu_soft_restart(reboot_code_buffer_phys, kimage->head, kimage->start, 0);
++>>>>>>> 76f4e2da45b4 (arm64: kexec: always reset to EL2 if present)
  
  	BUG(); /* Should never get here. */
  }
diff --git a/arch/arm64/kernel/cpu-reset.h b/arch/arm64/kernel/cpu-reset.h
index 6c2b1b4f57c9..fad90e4935fb 100644
--- a/arch/arm64/kernel/cpu-reset.h
+++ b/arch/arm64/kernel/cpu-reset.h
@@ -16,13 +16,14 @@
 void __cpu_soft_restart(unsigned long el2_switch, unsigned long entry,
 	unsigned long arg0, unsigned long arg1, unsigned long arg2);
 
-static inline void __noreturn cpu_soft_restart(unsigned long el2_switch,
-	unsigned long entry, unsigned long arg0, unsigned long arg1,
-	unsigned long arg2)
+static inline void __noreturn cpu_soft_restart(unsigned long entry,
+					       unsigned long arg0,
+					       unsigned long arg1,
+					       unsigned long arg2)
 {
 	typeof(__cpu_soft_restart) *restart;
 
-	el2_switch = el2_switch && !is_kernel_in_hyp_mode() &&
+	unsigned long el2_switch = !is_kernel_in_hyp_mode() &&
 		is_hyp_mode_available();
 	restart = (void *)__pa_symbol(__cpu_soft_restart);
 
* Unmerged path arch/arm64/kernel/machine_kexec.c
