net/mlx5e: Extend tc flow struct with reference counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Extend tc flow struct with reference counter (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 96.23%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 5a7e5bcb663d46d9cfe7d86d5a8ede91338275cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5a7e5bcb.failed

With new classifier type that doesn't require rtnl lock, following
invariant holds:
 - Filter with specified cookie created only once.
 - Filter with specified cookie deleted only once.
 - Stats updates can be performed in parallel to each other.

Extend tc flow with rcu and reference counter. To protect from concurrent
delete, get reference to tc flow when:
 - Reading flow stats.
 - Accessing flow in neigh update handler.
 - Accessing flow in neigh update used value handler.

Only free flow when reference counter reached zero. Modify flow cleanup to
account for flows that could be not fully initialized by checking if flow
is actually in the list of corresponding mod_hdr, hairpin and encap
entries. Don't cleanup flow directly in case of error to allow concurrent
neigh update (neigh update will be modified to always take reference to
flow when using it).

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 5a7e5bcb663d46d9cfe7d86d5a8ede91338275cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index f8b0a7e3a895,e2b87f723819..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -38,7 -38,7 +38,11 @@@
  #include <linux/mlx5/fs.h>
  #include <linux/mlx5/device.h>
  #include <linux/rhashtable.h>
++<<<<<<< HEAD
 +#include <net/switchdev.h>
++=======
+ #include <linux/refcount.h>
++>>>>>>> 5a7e5bcb663d (net/mlx5e: Extend tc flow struct with reference counter)
  #include <net/tc_act/tc_mirred.h>
  #include <net/tc_act/tc_vlan.h>
  #include <net/tc_act/tc_tunnel_key.h>
@@@ -1248,16 -1246,20 +1249,20 @@@ void mlx5e_tc_update_neigh_used_value(s
  		return;
  
  	list_for_each_entry(e, &nhe->encap_list, encap_list) {
- 		struct encap_flow_item *efi;
+ 		struct encap_flow_item *efi, *tmp;
  		if (!(e->flags & MLX5_ENCAP_ENTRY_VALID))
  			continue;
- 		list_for_each_entry(efi, &e->flows, list) {
+ 		list_for_each_entry_safe(efi, tmp, &e->flows, list) {
  			flow = container_of(efi, struct mlx5e_tc_flow,
  					    encaps[efi->index]);
+ 			if (IS_ERR(mlx5e_flow_get(flow)))
+ 				continue;
+ 
  			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
  				counter = mlx5e_tc_get_counter(flow);
 -				mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
 +				lastuse = mlx5_fc_query_lastuse(counter);
  				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
+ 					mlx5e_flow_put(netdev_priv(e->out_dev), flow);
  					neigh_used = true;
  					break;
  				}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
