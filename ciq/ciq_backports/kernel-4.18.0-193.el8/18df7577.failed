efi/memreserve: deal with memreserve entries in unmapped memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit 18df7577adae6c6c778bf774b3aebcacbc1fb439
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/18df7577.failed

Ensure that the EFI memreserve entries can be accessed, even if they
are located in memory that the kernel (e.g., a crashkernel) omits from
the linear map.

Fixes: 80424b02d42b ("efi: Reduce the amount of memblock reservations ...")
	Cc: <stable@vger.kernel.org> # 5.0+
	Reported-by: Jonathan Richardson <jonathan.richardson@broadcom.com>
	Reviewed-by: Jonathan Richardson <jonathan.richardson@broadcom.com>
	Tested-by: Jonathan Richardson <jonathan.richardson@broadcom.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
(cherry picked from commit 18df7577adae6c6c778bf774b3aebcacbc1fb439)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
diff --cc drivers/firmware/efi/efi.c
index b6e569a9a368,4b7cf7bc0ded..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -1013,8 -1009,8 +1013,13 @@@ int __ref efi_mem_reserve_persistent(ph
  
  	/* first try to find a slot in an existing linked list entry */
  	for (prsv = efi_memreserve_root->next; prsv; prsv = rsv->next) {
++<<<<<<< HEAD
 +		rsv = __va(prsv);
 +		index = __atomic_add_unless(&rsv->count, 1, rsv->size);
++=======
+ 		rsv = memremap(prsv, sizeof(*rsv), MEMREMAP_WB);
+ 		index = atomic_fetch_add_unless(&rsv->count, 1, rsv->size);
++>>>>>>> 18df7577adae (efi/memreserve: deal with memreserve entries in unmapped memory)
  		if (index < rsv->size) {
  			rsv->entry[index].base = addr;
  			rsv->entry[index].size = size;
* Unmerged path drivers/firmware/efi/efi.c
