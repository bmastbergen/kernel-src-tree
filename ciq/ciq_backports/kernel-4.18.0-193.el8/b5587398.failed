selftests/bpf: test BPF_SOCK_OPS_RTT_CB

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit b55873984dab0eda6db00d19db4c43dce5c11d98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b5587398.failed

Make sure the callback is invoked for syn-ack and data packet.

	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Priyaranjan Jha <priyarjha@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Soheil Hassas Yeganeh <soheil@google.com>
	Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit b55873984dab0eda6db00d19db4c43dce5c11d98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/Makefile
#	tools/testing/selftests/bpf/tcp_rtt.c
diff --cc tools/testing/selftests/bpf/Makefile
index 9bfa8b025d92,2620406a53ec..000000000000
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@@ -22,24 -23,24 +22,32 @@@ $(TEST_CUSTOM_PROGS): $(OUTPUT)/%: %.
  # Order correspond to 'make run_tests' order
  TEST_GEN_PROGS = test_verifier test_tag test_maps test_lru_map test_lpm_map test_progs \
  	test_align test_verifier_log test_dev_cgroup test_tcpbpf_user \
++<<<<<<< HEAD
 +	test_sock test_btf test_sockmap test_lirc_mode2_user get_cgroup_id_user \
 +	test_socket_cookie test_cgroup_storage test_select_reuseport test_section_names \
 +	test_netcnt test_tcpnotify_user
++=======
+ 	test_sock test_btf test_sockmap get_cgroup_id_user test_socket_cookie \
+ 	test_cgroup_storage test_select_reuseport test_section_names \
+ 	test_netcnt test_tcpnotify_user test_sock_fields test_sysctl test_hashmap \
+ 	test_btf_dump test_cgroup_attach xdping test_sockopt test_sockopt_sk \
+ 	test_sockopt_multi test_tcp_rtt
 -
 -BPF_OBJ_FILES = $(patsubst %.c,%.o, $(notdir $(wildcard progs/*.c)))
 -TEST_GEN_FILES = $(BPF_OBJ_FILES)
 -
 -# Also test sub-register code-gen if LLVM has eBPF v3 processor support which
 -# contains both ALU32 and JMP32 instructions.
 -SUBREG_CODEGEN := $(shell echo "int cal(int a) { return a > 0; }" | \
 -			$(CLANG) -target bpf -O2 -emit-llvm -S -x c - -o - | \
 -			$(LLC) -mattr=+alu32 -mcpu=v3 2>&1 | \
 -			grep 'if w')
 -ifneq ($(SUBREG_CODEGEN),)
 -TEST_GEN_FILES += $(patsubst %.o,alu32/%.o, $(BPF_OBJ_FILES))
 -endif
++>>>>>>> b55873984dab (selftests/bpf: test BPF_SOCK_OPS_RTT_CB)
 +
 +TEST_GEN_FILES = test_pkt_access.o test_xdp.o test_l4lb.o test_tcp_estats.o test_obj_id.o \
 +	test_pkt_md_access.o test_xdp_redirect.o test_xdp_meta.o sockmap_parse_prog.o     \
 +	sockmap_verdict_prog.o dev_cgroup.o sample_ret0.o test_tracepoint.o \
 +	test_l4lb_noinline.o test_xdp_noinline.o test_stacktrace_map.o \
 +	test_tcpnotify_kern.o \
 +	sample_map_ret0.o test_tcpbpf_kern.o test_stacktrace_build_id.o \
 +	sockmap_tcp_msg_prog.o connect4_prog.o connect6_prog.o test_adjust_tail.o \
 +	test_btf_haskv.o test_btf_nokv.o test_sockmap_kern.o test_tunnel_kern.o \
 +	test_get_stack_rawtp.o test_sockmap_kern.o test_sockhash_kern.o \
 +	test_lwt_seg6local.o sendmsg4_prog.o sendmsg6_prog.o test_lirc_mode2_kern.o \
 +	get_cgroup_id_kern.o socket_cookie_prog.o test_select_reuseport_kern.o \
 +	test_skb_cgroup_id_kern.o bpf_flow.o netcnt_prog.o \
 +	test_sk_lookup_kern.o test_xdp_vlan.o test_queue_map.o test_stack_map.o \
 +	xdp_dummy.o test_map_in_map.o
  
  # Order correspond to 'make run_tests' order
  TEST_PROGS := test_kmod.sh \
@@@ -85,6 -101,13 +93,16 @@@ $(OUTPUT)/test_progs: trace_helpers.
  $(OUTPUT)/get_cgroup_id_user: cgroup_helpers.c
  $(OUTPUT)/test_cgroup_storage: cgroup_helpers.c
  $(OUTPUT)/test_netcnt: cgroup_helpers.c
++<<<<<<< HEAD
++=======
+ $(OUTPUT)/test_sock_fields: cgroup_helpers.c
+ $(OUTPUT)/test_sysctl: cgroup_helpers.c
+ $(OUTPUT)/test_cgroup_attach: cgroup_helpers.c
+ $(OUTPUT)/test_sockopt: cgroup_helpers.c
+ $(OUTPUT)/test_sockopt_sk: cgroup_helpers.c
+ $(OUTPUT)/test_sockopt_multi: cgroup_helpers.c
+ $(OUTPUT)/test_tcp_rtt: cgroup_helpers.c
++>>>>>>> b55873984dab (selftests/bpf: test BPF_SOCK_OPS_RTT_CB)
  
  .PHONY: force
  
* Unmerged path tools/testing/selftests/bpf/tcp_rtt.c
* Unmerged path tools/testing/selftests/bpf/Makefile
* Unmerged path tools/testing/selftests/bpf/tcp_rtt.c
diff --git a/tools/testing/selftests/bpf/test_tcp_rtt.c b/tools/testing/selftests/bpf/test_tcp_rtt.c
new file mode 100644
index 000000000000..90c3862f74a8
--- /dev/null
+++ b/tools/testing/selftests/bpf/test_tcp_rtt.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <error.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <pthread.h>
+
+#include <linux/filter.h>
+#include <bpf/bpf.h>
+#include <bpf/libbpf.h>
+
+#include "bpf_rlimit.h"
+#include "bpf_util.h"
+#include "cgroup_helpers.h"
+
+#define CG_PATH                                "/tcp_rtt"
+
+struct tcp_rtt_storage {
+	__u32 invoked;
+	__u32 dsack_dups;
+	__u32 delivered;
+	__u32 delivered_ce;
+	__u32 icsk_retransmits;
+};
+
+static void send_byte(int fd)
+{
+	char b = 0x55;
+
+	if (write(fd, &b, sizeof(b)) != 1)
+		error(1, errno, "Failed to send single byte");
+}
+
+static int verify_sk(int map_fd, int client_fd, const char *msg, __u32 invoked,
+		     __u32 dsack_dups, __u32 delivered, __u32 delivered_ce,
+		     __u32 icsk_retransmits)
+{
+	int err = 0;
+	struct tcp_rtt_storage val;
+
+	if (bpf_map_lookup_elem(map_fd, &client_fd, &val) < 0)
+		error(1, errno, "Failed to read socket storage");
+
+	if (val.invoked != invoked) {
+		log_err("%s: unexpected bpf_tcp_sock.invoked %d != %d",
+			msg, val.invoked, invoked);
+		err++;
+	}
+
+	if (val.dsack_dups != dsack_dups) {
+		log_err("%s: unexpected bpf_tcp_sock.dsack_dups %d != %d",
+			msg, val.dsack_dups, dsack_dups);
+		err++;
+	}
+
+	if (val.delivered != delivered) {
+		log_err("%s: unexpected bpf_tcp_sock.delivered %d != %d",
+			msg, val.delivered, delivered);
+		err++;
+	}
+
+	if (val.delivered_ce != delivered_ce) {
+		log_err("%s: unexpected bpf_tcp_sock.delivered_ce %d != %d",
+			msg, val.delivered_ce, delivered_ce);
+		err++;
+	}
+
+	if (val.icsk_retransmits != icsk_retransmits) {
+		log_err("%s: unexpected bpf_tcp_sock.icsk_retransmits %d != %d",
+			msg, val.icsk_retransmits, icsk_retransmits);
+		err++;
+	}
+
+	return err;
+}
+
+static int connect_to_server(int server_fd)
+{
+	struct sockaddr_storage addr;
+	socklen_t len = sizeof(addr);
+	int fd;
+
+	fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (fd < 0) {
+		log_err("Failed to create client socket");
+		return -1;
+	}
+
+	if (getsockname(server_fd, (struct sockaddr *)&addr, &len)) {
+		log_err("Failed to get server addr");
+		goto out;
+	}
+
+	if (connect(fd, (const struct sockaddr *)&addr, len) < 0) {
+		log_err("Fail to connect to server");
+		goto out;
+	}
+
+	return fd;
+
+out:
+	close(fd);
+	return -1;
+}
+
+static int run_test(int cgroup_fd, int server_fd)
+{
+	struct bpf_prog_load_attr attr = {
+		.prog_type = BPF_PROG_TYPE_SOCK_OPS,
+		.file = "./tcp_rtt.o",
+		.expected_attach_type = BPF_CGROUP_SOCK_OPS,
+	};
+	struct bpf_object *obj;
+	struct bpf_map *map;
+	int client_fd;
+	int prog_fd;
+	int map_fd;
+	int err;
+
+	err = bpf_prog_load_xattr(&attr, &obj, &prog_fd);
+	if (err) {
+		log_err("Failed to load BPF object");
+		return -1;
+	}
+
+	map = bpf_map__next(NULL, obj);
+	map_fd = bpf_map__fd(map);
+
+	err = bpf_prog_attach(prog_fd, cgroup_fd, BPF_CGROUP_SOCK_OPS, 0);
+	if (err) {
+		log_err("Failed to attach BPF program");
+		goto close_bpf_object;
+	}
+
+	client_fd = connect_to_server(server_fd);
+	if (client_fd < 0) {
+		err = -1;
+		goto close_bpf_object;
+	}
+
+	err += verify_sk(map_fd, client_fd, "syn-ack",
+			 /*invoked=*/1,
+			 /*dsack_dups=*/0,
+			 /*delivered=*/1,
+			 /*delivered_ce=*/0,
+			 /*icsk_retransmits=*/0);
+
+	send_byte(client_fd);
+
+	err += verify_sk(map_fd, client_fd, "first payload byte",
+			 /*invoked=*/2,
+			 /*dsack_dups=*/0,
+			 /*delivered=*/2,
+			 /*delivered_ce=*/0,
+			 /*icsk_retransmits=*/0);
+
+	close(client_fd);
+
+close_bpf_object:
+	bpf_object__close(obj);
+	return err;
+}
+
+static int start_server(void)
+{
+	struct sockaddr_in addr = {
+		.sin_family = AF_INET,
+		.sin_addr.s_addr = htonl(INADDR_LOOPBACK),
+	};
+	int fd;
+
+	fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (fd < 0) {
+		log_err("Failed to create server socket");
+		return -1;
+	}
+
+	if (bind(fd, (const struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		log_err("Failed to bind socket");
+		close(fd);
+		return -1;
+	}
+
+	return fd;
+}
+
+static void *server_thread(void *arg)
+{
+	struct sockaddr_storage addr;
+	socklen_t len = sizeof(addr);
+	int fd = *(int *)arg;
+	int client_fd;
+
+	if (listen(fd, 1) < 0)
+		error(1, errno, "Failed to listed on socket");
+
+	client_fd = accept(fd, (struct sockaddr *)&addr, &len);
+	if (client_fd < 0)
+		error(1, errno, "Failed to accept client");
+
+	/* Wait for the next connection (that never arrives)
+	 * to keep this thread alive to prevent calling
+	 * close() on client_fd.
+	 */
+	if (accept(fd, (struct sockaddr *)&addr, &len) >= 0)
+		error(1, errno, "Unexpected success in second accept");
+
+	close(client_fd);
+
+	return NULL;
+}
+
+int main(int args, char **argv)
+{
+	int server_fd, cgroup_fd;
+	int err = EXIT_SUCCESS;
+	pthread_t tid;
+
+	if (setup_cgroup_environment())
+		goto cleanup_obj;
+
+	cgroup_fd = create_and_get_cgroup(CG_PATH);
+	if (cgroup_fd < 0)
+		goto cleanup_cgroup_env;
+
+	if (join_cgroup(CG_PATH))
+		goto cleanup_cgroup;
+
+	server_fd = start_server();
+	if (server_fd < 0) {
+		err = EXIT_FAILURE;
+		goto cleanup_cgroup;
+	}
+
+	pthread_create(&tid, NULL, server_thread, (void *)&server_fd);
+
+	if (run_test(cgroup_fd, server_fd))
+		err = EXIT_FAILURE;
+
+	close(server_fd);
+
+	printf("test_sockopt_sk: %s\n",
+	       err == EXIT_SUCCESS ? "PASSED" : "FAILED");
+
+cleanup_cgroup:
+	close(cgroup_fd);
+cleanup_cgroup_env:
+	cleanup_cgroup_environment();
+cleanup_obj:
+	return err;
+}
