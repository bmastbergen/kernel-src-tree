drm/amdgpu: add invalidate semaphore limit for SRIOV and picasso in gmc9

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author changzhu <Changfeng.Zhu@amd.com>
commit 90f6452ca58d436de4f69b423ecd75a109aa9766
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/90f6452c.failed

It may fail to load guest driver in round 2 or cause Xstart problem
when using invalidate semaphore for SRIOV or picasso. So it needs avoid
using invalidate semaphore for SRIOV and picasso.

	Signed-off-by: changzhu <Changfeng.Zhu@amd.com>
	Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
	Reviewed-by: Huang Rui <ray.huang@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 90f6452ca58d436de4f69b423ecd75a109aa9766)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
diff --cc drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index c0446af00cdd,a5b68b5e452f..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
@@@ -391,44 -450,86 +409,98 @@@ static bool gmc_v9_0_use_invalidate_sem
   *
   * Flush the TLB for the requested page table using certain type.
   */
 -static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
 -					uint32_t vmhub, uint32_t flush_type)
 +static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev,
 +				uint32_t vmid, uint32_t flush_type)
  {
+ 	bool use_semaphore = gmc_v9_0_use_invalidate_semaphore(adev, vmhub);
  	const unsigned eng = 17;
 -	u32 j, tmp;
 -	struct amdgpu_vmhub *hub;
 -
 -	BUG_ON(vmhub >= adev->num_vmhubs);
 +	unsigned i, j;
  
 -	hub = &adev->vmhub[vmhub];
 -	tmp = gmc_v9_0_get_invalidate_req(vmid, flush_type);
 +	for (i = 0; i < AMDGPU_MAX_VMHUBS; ++i) {
 +		struct amdgpu_vmhub *hub = &adev->vmhub[i];
 +		u32 tmp = gmc_v9_0_get_invalidate_req(vmid, flush_type);
  
 -	/* This is necessary for a HW workaround under SRIOV as well
 -	 * as GFXOFF under bare metal
 -	 */
 -	if (adev->gfx.kiq.ring.sched.ready &&
 -			(amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev)) &&
 -			!adev->in_gpu_reset) {
 -		uint32_t req = hub->vm_inv_eng0_req + eng;
 -		uint32_t ack = hub->vm_inv_eng0_ack + eng;
 +		/* This is necessary for a HW workaround under SRIOV as well
 +		 * as GFXOFF under bare metal
 +		 */
 +		if (adev->gfx.kiq.ring.sched.ready &&
 +		    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev)) &&
 +		    !adev->in_gpu_reset) {
 +			uint32_t req = hub->vm_inv_eng0_req + eng;
 +			uint32_t ack = hub->vm_inv_eng0_ack + eng;
 +
 +			amdgpu_virt_kiq_reg_write_reg_wait(adev, req, ack, tmp,
 +							   1 << vmid);
 +			continue;
 +		}
  
++<<<<<<< HEAD
 +		spin_lock(&adev->gmc.invalidate_lock);
 +		WREG32_NO_KIQ(hub->vm_inv_eng0_req + eng, tmp);
++=======
+ 		amdgpu_virt_kiq_reg_write_reg_wait(adev, req, ack, tmp,
+ 				1 << vmid);
+ 		return;
+ 	}
+ 
+ 	spin_lock(&adev->gmc.invalidate_lock);
+ 
+ 	/*
+ 	 * It may lose gpuvm invalidate acknowldege state across power-gating
+ 	 * off cycle, add semaphore acquire before invalidation and semaphore
+ 	 * release after invalidation to avoid entering power gated state
+ 	 * to WA the Issue
+ 	 */
+ 
+ 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
+ 	if (use_semaphore) {
++>>>>>>> 90f6452ca58d (drm/amdgpu: add invalidate semaphore limit for SRIOV and picasso in gmc9)
  		for (j = 0; j < adev->usec_timeout; j++) {
 -			/* a read return value of 1 means semaphore acuqire */
 -			tmp = RREG32_NO_KIQ(hub->vm_inv_eng0_sem + eng);
 -			if (tmp & 0x1)
 +			tmp = RREG32_NO_KIQ(hub->vm_inv_eng0_ack + eng);
 +			if (tmp & (1 << vmid))
  				break;
  			udelay(1);
  		}
 +		spin_unlock(&adev->gmc.invalidate_lock);
 +		if (j < adev->usec_timeout)
 +			continue;
  
 -		if (j >= adev->usec_timeout)
 -			DRM_ERROR("Timeout waiting for sem acquire in VM flush!\n");
 +		DRM_ERROR("Timeout waiting for VM flush ACK!\n");
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	WREG32_NO_KIQ(hub->vm_inv_eng0_req + eng, tmp);
+ 
+ 	/*
+ 	 * Issue a dummy read to wait for the ACK register to be cleared
+ 	 * to avoid a false ACK due to the new fast GRBM interface.
+ 	 */
+ 	if (vmhub == AMDGPU_GFXHUB_0)
+ 		RREG32_NO_KIQ(hub->vm_inv_eng0_req + eng);
+ 
+ 	for (j = 0; j < adev->usec_timeout; j++) {
+ 		tmp = RREG32_NO_KIQ(hub->vm_inv_eng0_ack + eng);
+ 		if (tmp & (1 << vmid))
+ 			break;
+ 		udelay(1);
+ 	}
+ 
+ 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
+ 	if (use_semaphore)
+ 		/*
+ 		 * add semaphore release after invalidation,
+ 		 * write with 0 means semaphore release
+ 		 */
+ 		WREG32_NO_KIQ(hub->vm_inv_eng0_sem + eng, 0);
+ 
+ 	spin_unlock(&adev->gmc.invalidate_lock);
+ 
+ 	if (j < adev->usec_timeout)
+ 		return;
+ 
+ 	DRM_ERROR("Timeout waiting for VM flush ACK!\n");
++>>>>>>> 90f6452ca58d (drm/amdgpu: add invalidate semaphore limit for SRIOV and picasso in gmc9)
  }
  
  static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
@@@ -439,6 -541,19 +512,22 @@@
  	uint32_t req = gmc_v9_0_get_invalidate_req(vmid, 0);
  	unsigned eng = ring->vm_inv_eng;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * It may lose gpuvm invalidate acknowldege state across power-gating
+ 	 * off cycle, add semaphore acquire before invalidation and semaphore
+ 	 * release after invalidation to avoid entering power gated state
+ 	 * to WA the Issue
+ 	 */
+ 
+ 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
+ 	if (use_semaphore)
+ 		/* a read return value of 1 means semaphore acuqire */
+ 		amdgpu_ring_emit_reg_wait(ring,
+ 					  hub->vm_inv_eng0_sem + eng, 0x1, 0x1);
+ 
++>>>>>>> 90f6452ca58d (drm/amdgpu: add invalidate semaphore limit for SRIOV and picasso in gmc9)
  	amdgpu_ring_emit_wreg(ring, hub->ctx0_ptb_addr_lo32 + (2 * vmid),
  			      lower_32_bits(pd_addr));
  
@@@ -449,6 -564,14 +538,17 @@@
  					    hub->vm_inv_eng0_ack + eng,
  					    req, 1 << vmid);
  
++<<<<<<< HEAD
++=======
+ 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
+ 	if (use_semaphore)
+ 		/*
+ 		 * add semaphore release after invalidation,
+ 		 * write with 0 means semaphore release
+ 		 */
+ 		amdgpu_ring_emit_wreg(ring, hub->vm_inv_eng0_sem + eng, 0);
+ 
++>>>>>>> 90f6452ca58d (drm/amdgpu: add invalidate semaphore limit for SRIOV and picasso in gmc9)
  	return pd_addr;
  }
  
* Unmerged path drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
