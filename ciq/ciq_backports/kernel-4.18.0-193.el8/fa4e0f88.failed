net/sched: fix corrupted L2 header with MPLS 'push' and 'pop' actions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] sched: fix corrupted L2 header with MPLS 'push' and 'pop' actions (Ivan Vecera) [1737820]
Rebuild_FUZZ: 97.01%
commit-author Davide Caratti <dcaratti@redhat.com>
commit fa4e0f8855fcba600e0be2575ee29c69166f74bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/fa4e0f88.failed

the following script:

 # tc qdisc add dev eth0 clsact
 # tc filter add dev eth0 egress protocol ip matchall \
 > action mpls push protocol mpls_uc label 0x355aa bos 1

causes corruption of all IP packets transmitted by eth0. On TC egress, we
can't rely on the value of skb->mac_len, because it's 0 and a MPLS 'push'
operation will result in an overwrite of the first 4 octets in the packet
L2 header (e.g. the Destination Address if eth0 is an Ethernet); the same
error pattern is present also in the MPLS 'pop' operation. Fix this error
in act_mpls data plane, computing 'mac_len' as the difference between the
network header and the mac header (when not at TC ingress), and use it in
MPLS 'push'/'pop' core functions.

v2: unbreak 'make htmldocs' because of missing documentation of 'mac_len'
    in skb_mpls_pop(), reported by kbuild test robot

CC: Lorenzo Bianconi <lorenzo@kernel.org>
Fixes: 2a2ea50870ba ("net: sched: add mpls manipulation actions to TC")
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Acked-by: John Hurley <john.hurley@netronome.com>
	Signed-off-by: Davide Caratti <dcaratti@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fa4e0f8855fcba600e0be2575ee29c69166f74bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/skbuff.c
#	net/openvswitch/actions.c
#	net/sched/act_mpls.c
diff --cc include/linux/skbuff.h
index 0678e9ef412a,7914fdaf4226..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3417,7 -3510,11 +3417,15 @@@ int skb_ensure_writable(struct sk_buff 
  int __skb_vlan_pop(struct sk_buff *skb, u16 *vlan_tci);
  int skb_vlan_pop(struct sk_buff *skb);
  int skb_vlan_push(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci);
++<<<<<<< HEAD
 +int skb_mpls_push(struct sk_buff *skb, __be32 mpls_lse, __be16 mpls_proto);
++=======
+ int skb_mpls_push(struct sk_buff *skb, __be32 mpls_lse, __be16 mpls_proto,
+ 		  int mac_len);
+ int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto, int mac_len);
+ int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse);
+ int skb_mpls_dec_ttl(struct sk_buff *skb);
++>>>>>>> fa4e0f8855fc (net/sched: fix corrupted L2 header with MPLS 'push' and 'pop' actions)
  struct sk_buff *pskb_extract(struct sk_buff *skb, int off, int to_copy,
  			     gfp_t gfp);
  
diff --cc net/core/skbuff.c
index 20259cd3ce3e,867e61df00db..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -5309,6 -5524,111 +5311,114 @@@ int skb_mpls_push(struct sk_buff *skb, 
  EXPORT_SYMBOL_GPL(skb_mpls_push);
  
  /**
++<<<<<<< HEAD
++=======
+  * skb_mpls_pop() - pop the outermost MPLS header
+  *
+  * @skb: buffer
+  * @next_proto: ethertype of header after popped MPLS header
+  * @mac_len: length of the MAC header
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto, int mac_len)
+ {
+ 	int err;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return 0;
+ 
+ 	err = skb_ensure_writable(skb, mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	skb_postpull_rcsum(skb, mpls_hdr(skb), MPLS_HLEN);
+ 	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
+ 		mac_len);
+ 
+ 	__skb_pull(skb, MPLS_HLEN);
+ 	skb_reset_mac_header(skb);
+ 	skb_set_network_header(skb, mac_len);
+ 
+ 	if (skb->dev && skb->dev->type == ARPHRD_ETHER) {
+ 		struct ethhdr *hdr;
+ 
+ 		/* use mpls_hdr() to get ethertype to account for VLANs. */
+ 		hdr = (struct ethhdr *)((void *)mpls_hdr(skb) - ETH_HLEN);
+ 		skb_mod_eth_type(skb, hdr, next_proto);
+ 	}
+ 	skb->protocol = next_proto;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_pop);
+ 
+ /**
+  * skb_mpls_update_lse() - modify outermost MPLS header and update csum
+  *
+  * @skb: buffer
+  * @mpls_lse: new MPLS label stack entry to update to
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse)
+ {
+ 	int err;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return -EINVAL;
+ 
+ 	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+ 		__be32 diff[] = { ~mpls_hdr(skb)->label_stack_entry, mpls_lse };
+ 
+ 		skb->csum = csum_partial((char *)diff, sizeof(diff), skb->csum);
+ 	}
+ 
+ 	mpls_hdr(skb)->label_stack_entry = mpls_lse;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_update_lse);
+ 
+ /**
+  * skb_mpls_dec_ttl() - decrement the TTL of the outermost MPLS header
+  *
+  * @skb: buffer
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_dec_ttl(struct sk_buff *skb)
+ {
+ 	u32 lse;
+ 	u8 ttl;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return -EINVAL;
+ 
+ 	lse = be32_to_cpu(mpls_hdr(skb)->label_stack_entry);
+ 	ttl = (lse & MPLS_LS_TTL_MASK) >> MPLS_LS_TTL_SHIFT;
+ 	if (!--ttl)
+ 		return -EINVAL;
+ 
+ 	lse &= ~MPLS_LS_TTL_MASK;
+ 	lse |= ttl << MPLS_LS_TTL_SHIFT;
+ 
+ 	return skb_mpls_update_lse(skb, cpu_to_be32(lse));
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_dec_ttl);
+ 
+ /**
++>>>>>>> fa4e0f8855fc (net/sched: fix corrupted L2 header with MPLS 'push' and 'pop' actions)
   * alloc_skb_with_frags - allocate skb with page frags
   *
   * @header_len: size of linear part
diff --cc net/openvswitch/actions.c
index c45ff6be42d0,1c77f520f474..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -199,31 -179,10 +200,36 @@@ static int pop_mpls(struct sk_buff *skb
  {
  	int err;
  
++<<<<<<< HEAD
 +	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
 +	if (unlikely(err))
++=======
+ 	err = skb_mpls_pop(skb, ethertype, skb->mac_len);
+ 	if (err)
++>>>>>>> fa4e0f8855fc (net/sched: fix corrupted L2 header with MPLS 'push' and 'pop' actions)
  		return err;
  
 +	skb_postpull_rcsum(skb, mpls_hdr(skb), MPLS_HLEN);
 +
 +	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
 +		skb->mac_len);
 +
 +	__skb_pull(skb, MPLS_HLEN);
 +	skb_reset_mac_header(skb);
 +	skb_set_network_header(skb, skb->mac_len);
 +
 +	if (ovs_key_mac_proto(key) == MAC_PROTO_ETHERNET) {
 +		struct ethhdr *hdr;
 +
 +		/* mpls_hdr() is used to locate the ethertype field correctly in the
 +		 * presence of VLAN tags.
 +		 */
 +		hdr = (struct ethhdr *)((void *)mpls_hdr(skb) - ETH_HLEN);
 +		update_ethertype(skb, hdr, ethertype);
 +	}
 +	if (eth_p_mpls(skb->protocol))
 +		skb->protocol = ethertype;
 +
  	invalidate_flow_key(key);
  	return 0;
  }
* Unmerged path net/sched/act_mpls.c
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/skbuff.c
* Unmerged path net/openvswitch/actions.c
* Unmerged path net/sched/act_mpls.c
