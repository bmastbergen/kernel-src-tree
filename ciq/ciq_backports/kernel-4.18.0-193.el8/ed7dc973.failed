SUNRPC: Prevent thundering herd when the socket is not connected

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit ed7dc973bd91da234d93aff6d033a5206a6c9885
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ed7dc973.failed

If the socket is not connected, then we want to initiate a reconnect
rather that trying to transmit requests. If there is a large number
of requests queued and waiting for the lock in call_transmit(),
then it can take a while for one of the to loop back and retake
the lock in call_connect.

Fixes: 89f90fe1ad8b ("SUNRPC: Allow calls to xprt_transmit() to drain...")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit ed7dc973bd91da234d93aff6d033a5206a6c9885)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 53c6c503223a,7ab4da342ab5..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1748,21 -1763,56 +1748,35 @@@ rpc_xdr_encode(struct rpc_task *task
  		     req->rq_rbuffer,
  		     req->rq_rcvsize);
  
 -	req->rq_snd_buf.head[0].iov_len = 0;
 -	xdr_init_encode(&xdr, &req->rq_snd_buf,
 -			req->rq_snd_buf.head[0].iov_base, req);
 -	if (rpc_encode_header(task, &xdr))
 +	p = rpc_encode_header(task);
 +	if (p == NULL) {
 +		printk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");
 +		rpc_exit(task, -EIO);
  		return;
 +	}
  
 -	task->tk_status = rpcauth_wrap_req(task, &xdr);
 -}
 -
 -/*
 - * 3.	Encode arguments of an RPC call
 - */
 -static void
 -call_encode(struct rpc_task *task)
 -{
 -	if (!rpc_task_need_encode(task))
 -		goto out;
 -	dprint_status(task);
 -	/* Encode here so that rpcsec_gss can use correct sequence number. */
 -	rpc_xdr_encode(task);
 -	/* Did the encode result in an error condition? */
 -	if (task->tk_status != 0) {
 -		/* Was the error nonfatal? */
 -		switch (task->tk_status) {
 -		case -EAGAIN:
 -		case -ENOMEM:
 -			rpc_delay(task, HZ >> 4);
 -			break;
 -		case -EKEYEXPIRED:
 -			task->tk_action = call_refresh;
 -			break;
 -		default:
 -			rpc_exit(task, task->tk_status);
 -		}
++<<<<<<< HEAD
 +	encode = task->tk_msg.rpc_proc->p_encode;
 +	if (encode == NULL)
  		return;
 -	} else {
 -		xprt_request_prepare(task->tk_rqstp);
 -	}
  
 +	task->tk_status = rpcauth_wrap_req(task, encode, req, p,
 +			task->tk_msg.rpc_argp);
 +	if (task->tk_status == 0)
 +		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
++=======
+ 	/* Add task to reply queue before transmission to avoid races */
+ 	if (rpc_reply_expected(task))
+ 		xprt_request_enqueue_receive(task);
+ 	xprt_request_enqueue_transmit(task);
+ out:
+ 	task->tk_action = call_transmit;
+ 	/* Check that the connection is OK */
+ 	if (!xprt_bound(task->tk_xprt))
+ 		task->tk_action = call_bind;
+ 	else if (!xprt_connected(task->tk_xprt))
+ 		task->tk_action = call_connect;
++>>>>>>> ed7dc973bd91 (SUNRPC: Prevent thundering herd when the socket is not connected)
  }
  
  /*
@@@ -1956,35 -2005,19 +1970,51 @@@ call_transmit(struct rpc_task *task
  	dprint_status(task);
  
  	task->tk_action = call_transmit_status;
++<<<<<<< HEAD
 +	/* Encode here so that rpcsec_gss can use correct sequence number. */
 +	if (rpc_task_need_encode(task)) {
 +		rpc_xdr_encode(task);
 +		/* Did the encode result in an error condition? */
 +		if (task->tk_status != 0) {
 +			/* Was the error nonfatal? */
 +			if (task->tk_status == -EAGAIN)
 +				rpc_delay(task, HZ >> 4);
 +			else
 +				rpc_exit(task, task->tk_status);
 +			return;
 +		}
 +	}
 +	if (!xprt_prepare_transmit(task))
 +		return;
 +	xprt_transmit(task);
 +	if (task->tk_status < 0)
 +		return;
 +	if (is_retrans)
 +		task->tk_client->cl_stats->rpcretrans++;
 +	/*
 +	 * On success, ensure that we call xprt_end_transmit() before sleeping
 +	 * in order to allow access to the socket to other RPC requests.
 +	 */
 +	call_transmit_status(task);
 +	if (rpc_reply_expected(task))
 +		return;
 +	task->tk_action = rpc_exit_task;
 +	rpc_wake_up_queued_task(&task->tk_rqstp->rq_xprt->pending, task);
++=======
+ 	if (test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate)) {
+ 		if (!xprt_prepare_transmit(task))
+ 			return;
+ 		task->tk_status = 0;
+ 		if (test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate)) {
+ 			if (!xprt_connected(task->tk_xprt)) {
+ 				task->tk_status = -ENOTCONN;
+ 				return;
+ 			}
+ 			xprt_transmit(task);
+ 		}
+ 	}
+ 	xprt_end_transmit(task);
++>>>>>>> ed7dc973bd91 (SUNRPC: Prevent thundering herd when the socket is not connected)
  }
  
  /*
* Unmerged path net/sunrpc/clnt.c
