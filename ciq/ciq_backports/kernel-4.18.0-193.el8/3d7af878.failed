nl80211: use netlink policy validation function for elements

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 3d7af878357acd9e37fc156928106f1a969c8942
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3d7af878.failed

Instead of open-coding a lot of calls to is_valid_ie_attr(),
add this validation directly to the policy, now that we can.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 3d7af878357acd9e37fc156928106f1a969c8942)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 4e1c052bca2e,758bb069d000..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -205,9 -200,37 +205,39 @@@ cfg80211_get_dev_from_info(struct net *
  	return __cfg80211_rdev_from_attrs(netns, info->attrs);
  }
  
+ static int validate_ie_attr(const struct nlattr *attr,
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	const u8 *pos;
+ 	int len;
+ 
+ 	pos = nla_data(attr);
+ 	len = nla_len(attr);
+ 
+ 	while (len) {
+ 		u8 elemlen;
+ 
+ 		if (len < 2)
+ 			goto error;
+ 		len -= 2;
+ 
+ 		elemlen = pos[1];
+ 		if (elemlen > len)
+ 			goto error;
+ 
+ 		len -= elemlen;
+ 		pos += 2 + elemlen;
+ 	}
+ 
+ 	return 0;
+ error:
+ 	NL_SET_ERR_MSG_ATTR(extack, attr, "malformed information elements");
+ 	return -EINVAL;
+ }
+ 
  /* policy for the attributes */
 +
 +#if 0 /* Not in RHEL */
  static const struct nla_policy
  nl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {
  	[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },
@@@ -310,9 -280,11 +340,17 @@@ const struct nla_policy nl80211_policy[
  	[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },
  	[NL80211_ATTR_BEACON_HEAD] = { .type = NLA_BINARY,
  				       .len = IEEE80211_MAX_DATA_LEN },
++<<<<<<< HEAD
 +	[NL80211_ATTR_BEACON_TAIL] = { .type = NLA_BINARY,
 +				       .len = IEEE80211_MAX_DATA_LEN },
 +	[NL80211_ATTR_STA_AID] = { .type = NLA_U16 },
++=======
+ 	[NL80211_ATTR_BEACON_TAIL] =
+ 		NLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,
+ 				       IEEE80211_MAX_DATA_LEN),
+ 	[NL80211_ATTR_STA_AID] =
+ 		NLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),
++>>>>>>> 3d7af878357a (nl80211: use netlink policy validation function for elements)
  	[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },
  	[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },
  	[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,
@@@ -390,11 -369,16 +429,24 @@@
  	[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },
  	[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },
  	[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },
++<<<<<<< HEAD
 +	[NL80211_ATTR_HIDDEN_SSID] = { .type = NLA_U32 },
 +	[NL80211_ATTR_IE_PROBE_RESP] = { .type = NLA_BINARY,
 +					 .len = IEEE80211_MAX_DATA_LEN },
 +	[NL80211_ATTR_IE_ASSOC_RESP] = { .type = NLA_BINARY,
 +					 .len = IEEE80211_MAX_DATA_LEN },
++=======
+ 	[NL80211_ATTR_HIDDEN_SSID] =
+ 		NLA_POLICY_RANGE(NLA_U32,
+ 				 NL80211_HIDDEN_SSID_NOT_IN_USE,
+ 				 NL80211_HIDDEN_SSID_ZERO_CONTENTS),
+ 	[NL80211_ATTR_IE_PROBE_RESP] =
+ 		NLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,
+ 				       IEEE80211_MAX_DATA_LEN),
+ 	[NL80211_ATTR_IE_ASSOC_RESP] =
+ 		NLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,
+ 				       IEEE80211_MAX_DATA_LEN),
++>>>>>>> 3d7af878357a (nl80211: use netlink policy validation function for elements)
  	[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },
  	[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },
  	[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },
@@@ -709,39 -683,9 +761,9 @@@ int nl80211_prepare_wdev_dump(struct ne
  	return 0;
  }
  
- /* IE validation */
- static bool is_valid_ie_attr(const struct nlattr *attr)
- {
- 	const u8 *pos;
- 	int len;
- 
- 	if (!attr)
- 		return true;
- 
- 	pos = nla_data(attr);
- 	len = nla_len(attr);
- 
- 	while (len) {
- 		u8 elemlen;
- 
- 		if (len < 2)
- 			return false;
- 		len -= 2;
- 
- 		elemlen = pos[1];
- 		if (elemlen > len)
- 			return false;
- 
- 		len -= elemlen;
- 		pos += 2 + elemlen;
- 	}
- 
- 	return true;
- }
- 
  /* message building helper */
 -static inline void *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,
 -				   int flags, u8 cmd)
 +void *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,
 +		     int flags, u8 cmd)
  {
  	/* since there is no private header just add the generic one */
  	return genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);
* Unmerged path net/wireless/nl80211.c
