net: flow_offload: rename tc_setup_cb_t to flow_setup_cb_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] flow_offload: rename tc_setup_cb_t to flow_setup_cb_t (Ivan Vecera) [1737890]
Rebuild_FUZZ: 95.50%
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit a7323311515d488b7714bb7504a1d50fabb0bfcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a7323311.failed

Rename this type definition and adapt users.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a7323311515d488b7714bb7504a1d50fabb0bfcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
#	drivers/net/ethernet/mscc/ocelot_tc.c
#	include/net/flow_offload.h
#	include/net/pkt_cls.h
#	net/core/flow_offload.c
#	net/dsa/slave.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index e43d1c130eea,51cd0b6f1f3e..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -1601,9 -1676,10 +1601,14 @@@ mlxsw_sp_setup_tc_block_flower_unbind(s
  }
  
  static int mlxsw_sp_setup_tc_block(struct mlxsw_sp_port *mlxsw_sp_port,
 -				   struct flow_block_offload *f)
 +				   struct tc_block_offload *f)
  {
++<<<<<<< HEAD
 +	tc_setup_cb_t *cb;
++=======
+ 	struct flow_block_cb *block_cb;
+ 	flow_setup_cb_t *cb;
++>>>>>>> a7323311515d (net: flow_offload: rename tc_setup_cb_t to flow_setup_cb_t)
  	bool ingress;
  	int err;
  
diff --cc include/net/flow_offload.h
index 36127c1858a4,23b299235baf..000000000000
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@@ -232,4 -238,103 +233,106 @@@ static inline void flow_stats_update(st
  	flow_stats->lastused	= max_t(u64, flow_stats->lastused, lastused);
  }
  
++<<<<<<< HEAD
++=======
+ enum flow_block_command {
+ 	FLOW_BLOCK_BIND,
+ 	FLOW_BLOCK_UNBIND,
+ };
+ 
+ enum flow_block_binder_type {
+ 	FLOW_BLOCK_BINDER_TYPE_UNSPEC,
+ 	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS,
+ 	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS,
+ };
+ 
+ struct netlink_ext_ack;
+ 
+ struct flow_block_offload {
+ 	enum flow_block_command command;
+ 	enum flow_block_binder_type binder_type;
+ 	bool block_shared;
+ 	struct net *net;
+ 	struct list_head cb_list;
+ 	struct list_head *driver_block_list;
+ 	struct netlink_ext_ack *extack;
+ };
+ 
+ enum tc_setup_type;
+ typedef int flow_setup_cb_t(enum tc_setup_type type, void *type_data,
+ 			    void *cb_priv);
+ 
+ struct flow_block_cb {
+ 	struct list_head	driver_list;
+ 	struct list_head	list;
+ 	flow_setup_cb_t		*cb;
+ 	void			*cb_ident;
+ 	void			*cb_priv;
+ 	void			(*release)(void *cb_priv);
+ 	unsigned int		refcnt;
+ };
+ 
+ struct flow_block_cb *flow_block_cb_alloc(flow_setup_cb_t *cb,
+ 					  void *cb_ident, void *cb_priv,
+ 					  void (*release)(void *cb_priv));
+ void flow_block_cb_free(struct flow_block_cb *block_cb);
+ 
+ struct flow_block_cb *flow_block_cb_lookup(struct flow_block_offload *offload,
+ 					   flow_setup_cb_t *cb, void *cb_ident);
+ 
+ void *flow_block_cb_priv(struct flow_block_cb *block_cb);
+ void flow_block_cb_incref(struct flow_block_cb *block_cb);
+ unsigned int flow_block_cb_decref(struct flow_block_cb *block_cb);
+ 
+ static inline void flow_block_cb_add(struct flow_block_cb *block_cb,
+ 				     struct flow_block_offload *offload)
+ {
+ 	list_add_tail(&block_cb->list, &offload->cb_list);
+ }
+ 
+ static inline void flow_block_cb_remove(struct flow_block_cb *block_cb,
+ 					struct flow_block_offload *offload)
+ {
+ 	list_move(&block_cb->list, &offload->cb_list);
+ }
+ 
+ bool flow_block_cb_is_busy(flow_setup_cb_t *cb, void *cb_ident,
+ 			   struct list_head *driver_block_list);
+ 
+ int flow_block_cb_setup_simple(struct flow_block_offload *f,
+ 			       struct list_head *driver_list,
+ 			       flow_setup_cb_t *cb,
+ 			       void *cb_ident, void *cb_priv, bool ingress_only);
+ 
+ enum flow_cls_command {
+ 	FLOW_CLS_REPLACE,
+ 	FLOW_CLS_DESTROY,
+ 	FLOW_CLS_STATS,
+ 	FLOW_CLS_TMPLT_CREATE,
+ 	FLOW_CLS_TMPLT_DESTROY,
+ };
+ 
+ struct flow_cls_common_offload {
+ 	u32 chain_index;
+ 	__be16 protocol;
+ 	u32 prio;
+ 	struct netlink_ext_ack *extack;
+ };
+ 
+ struct flow_cls_offload {
+ 	struct flow_cls_common_offload common;
+ 	enum flow_cls_command command;
+ 	unsigned long cookie;
+ 	struct flow_rule *rule;
+ 	struct flow_stats stats;
+ 	u32 classid;
+ };
+ 
+ static inline struct flow_rule *
+ flow_cls_offload_flow_rule(struct flow_cls_offload *flow_cmd)
+ {
+ 	return flow_cmd->rule;
+ }
+ 
++>>>>>>> a7323311515d (net: flow_offload: rename tc_setup_cb_t to flow_setup_cb_t)
  #endif /* _NET_FLOW_OFFLOAD_H */
diff --cc include/net/pkt_cls.h
index 835bbad70a4b,e429809ca90d..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -6,7 -6,7 +6,11 @@@
  #include <linux/workqueue.h>
  #include <net/sch_generic.h>
  #include <net/act_api.h>
++<<<<<<< HEAD
 +#include <net/flow_offload.h>
++=======
+ #include <net/net_namespace.h>
++>>>>>>> a7323311515d (net: flow_offload: rename tc_setup_cb_t to flow_setup_cb_t)
  
  /* TC action not accessible from user space */
  #define TC_ACT_CONSUMED		(TC_ACT_VALUE_MAX + 1)
diff --cc net/core/flow_offload.c
index fd722fcdcd91,a800fa78d96c..000000000000
--- a/net/core/flow_offload.c
+++ b/net/core/flow_offload.c
@@@ -165,3 -164,119 +165,122 @@@ void flow_rule_match_enc_opts(const str
  	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_OPTS, out);
  }
  EXPORT_SYMBOL(flow_rule_match_enc_opts);
++<<<<<<< HEAD
++=======
+ 
+ struct flow_block_cb *flow_block_cb_alloc(flow_setup_cb_t *cb,
+ 					  void *cb_ident, void *cb_priv,
+ 					  void (*release)(void *cb_priv))
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	block_cb = kzalloc(sizeof(*block_cb), GFP_KERNEL);
+ 	if (!block_cb)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	block_cb->cb = cb;
+ 	block_cb->cb_ident = cb_ident;
+ 	block_cb->cb_priv = cb_priv;
+ 	block_cb->release = release;
+ 
+ 	return block_cb;
+ }
+ EXPORT_SYMBOL(flow_block_cb_alloc);
+ 
+ void flow_block_cb_free(struct flow_block_cb *block_cb)
+ {
+ 	if (block_cb->release)
+ 		block_cb->release(block_cb->cb_priv);
+ 
+ 	kfree(block_cb);
+ }
+ EXPORT_SYMBOL(flow_block_cb_free);
+ 
+ struct flow_block_cb *flow_block_cb_lookup(struct flow_block_offload *f,
+ 					   flow_setup_cb_t *cb, void *cb_ident)
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	list_for_each_entry(block_cb, f->driver_block_list, driver_list) {
+ 		if (block_cb->cb == cb &&
+ 		    block_cb->cb_ident == cb_ident)
+ 			return block_cb;
+ 	}
+ 
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(flow_block_cb_lookup);
+ 
+ void *flow_block_cb_priv(struct flow_block_cb *block_cb)
+ {
+ 	return block_cb->cb_priv;
+ }
+ EXPORT_SYMBOL(flow_block_cb_priv);
+ 
+ void flow_block_cb_incref(struct flow_block_cb *block_cb)
+ {
+ 	block_cb->refcnt++;
+ }
+ EXPORT_SYMBOL(flow_block_cb_incref);
+ 
+ unsigned int flow_block_cb_decref(struct flow_block_cb *block_cb)
+ {
+ 	return --block_cb->refcnt;
+ }
+ EXPORT_SYMBOL(flow_block_cb_decref);
+ 
+ bool flow_block_cb_is_busy(flow_setup_cb_t *cb, void *cb_ident,
+ 			   struct list_head *driver_block_list)
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	list_for_each_entry(block_cb, driver_block_list, driver_list) {
+ 		if (block_cb->cb == cb &&
+ 		    block_cb->cb_ident == cb_ident)
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL(flow_block_cb_is_busy);
+ 
+ int flow_block_cb_setup_simple(struct flow_block_offload *f,
+ 			       struct list_head *driver_block_list,
+ 			       flow_setup_cb_t *cb,
+ 			       void *cb_ident, void *cb_priv,
+ 			       bool ingress_only)
+ {
+ 	struct flow_block_cb *block_cb;
+ 
+ 	if (ingress_only &&
+ 	    f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	f->driver_block_list = driver_block_list;
+ 
+ 	switch (f->command) {
+ 	case FLOW_BLOCK_BIND:
+ 		if (flow_block_cb_is_busy(cb, cb_ident, driver_block_list))
+ 			return -EBUSY;
+ 
+ 		block_cb = flow_block_cb_alloc(cb, cb_ident, cb_priv, NULL);
+ 		if (IS_ERR(block_cb))
+ 			return PTR_ERR(block_cb);
+ 
+ 		flow_block_cb_add(block_cb, f);
+ 		list_add_tail(&block_cb->driver_list, driver_block_list);
+ 		return 0;
+ 	case FLOW_BLOCK_UNBIND:
+ 		block_cb = flow_block_cb_lookup(f, cb, cb_ident);
+ 		if (!block_cb)
+ 			return -ENOENT;
+ 
+ 		flow_block_cb_remove(block_cb, f);
+ 		list_del(&block_cb->driver_list);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ EXPORT_SYMBOL(flow_block_cb_setup_simple);
++>>>>>>> a7323311515d (net: flow_offload: rename tc_setup_cb_t to flow_setup_cb_t)
diff --cc net/dsa/slave.c
index 5e192d3878a2,d697a64fb564..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -882,14 -945,17 +882,19 @@@ static int dsa_slave_setup_tc_block_cb_
  	return dsa_slave_setup_tc_block_cb(type, type_data, cb_priv, false);
  }
  
 -static LIST_HEAD(dsa_slave_block_cb_list);
 -
  static int dsa_slave_setup_tc_block(struct net_device *dev,
 -				    struct flow_block_offload *f)
 +				    struct tc_block_offload *f)
  {
++<<<<<<< HEAD
 +	tc_setup_cb_t *cb;
++=======
+ 	struct flow_block_cb *block_cb;
+ 	flow_setup_cb_t *cb;
++>>>>>>> a7323311515d (net: flow_offload: rename tc_setup_cb_t to flow_setup_cb_t)
  
 -	if (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
 +	if (f->binder_type == TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
  		cb = dsa_slave_setup_tc_block_cb_ig;
 -	else if (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS)
 +	else if (f->binder_type == TCF_BLOCK_BINDER_TYPE_CLSACT_EGRESS)
  		cb = dsa_slave_setup_tc_block_cb_eg;
  	else
  		return -EOPNOTSUPP;
* Unmerged path drivers/net/ethernet/mscc/ocelot_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_tc.c
* Unmerged path include/net/flow_offload.h
* Unmerged path include/net/pkt_cls.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 13911b10ed82..cf13220796d0 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -15,6 +15,7 @@
 #include <linux/mutex.h>
 #include <net/gen_stats.h>
 #include <net/rtnetlink.h>
+#include <net/flow_offload.h>
 
 struct Qdisc_ops;
 struct qdisc_walker;
@@ -22,9 +23,6 @@ struct tcf_walker;
 struct module;
 struct bpf_flow_keys;
 
-typedef int tc_setup_cb_t(enum tc_setup_type type,
-			  void *type_data, void *cb_priv);
-
 typedef int tc_indr_block_bind_cb_t(struct net_device *dev, void *cb_priv,
 				    enum tc_setup_type type, void *type_data);
 
@@ -313,7 +311,7 @@ struct tcf_proto_ops {
 	void			(*walk)(struct tcf_proto *tp,
 					struct tcf_walker *arg, bool rtnl_held);
 	int			(*reoffload)(struct tcf_proto *tp, bool add,
-					     tc_setup_cb_t *cb, void *cb_priv,
+					     flow_setup_cb_t *cb, void *cb_priv,
 					     struct netlink_ext_ack *extack);
 	void			(*bind_class)(void *, u32, unsigned long);
 	void *			(*tmplt_create)(struct net *net,
* Unmerged path net/core/flow_offload.c
* Unmerged path net/dsa/slave.c
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index 51cea3b125f9..73961fa9a094 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -1552,7 +1552,7 @@ unsigned int tcf_block_cb_decref(struct tcf_block_cb *block_cb)
 EXPORT_SYMBOL(tcf_block_cb_decref);
 
 static int
-tcf_block_playback_offloads(struct tcf_block *block, tc_setup_cb_t *cb,
+tcf_block_playback_offloads(struct tcf_block *block, flow_setup_cb_t *cb,
 			    void *cb_priv, bool add, bool offload_in_use,
 			    struct netlink_ext_ack *extack)
 {
diff --git a/net/sched/cls_bpf.c b/net/sched/cls_bpf.c
index ff1deece0104..239c78d730c2 100644
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@ -659,7 +659,7 @@ static void cls_bpf_walk(struct tcf_proto *tp, struct tcf_walker *arg,
 	}
 }
 
-static int cls_bpf_reoffload(struct tcf_proto *tp, bool add, tc_setup_cb_t *cb,
+static int cls_bpf_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,
 			     void *cb_priv, struct netlink_ext_ack *extack)
 {
 	struct cls_bpf_head *head = rtnl_dereference(tp->root);
diff --git a/net/sched/cls_flower.c b/net/sched/cls_flower.c
index 3eb4f57be10d..d080d02ce915 100644
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@ -1623,7 +1623,7 @@ static void fl_walk(struct tcf_proto *tp, struct tcf_walker *arg,
 	}
 }
 
-static int fl_reoffload(struct tcf_proto *tp, bool add, tc_setup_cb_t *cb,
+static int fl_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,
 			void *cb_priv, struct netlink_ext_ack *extack)
 {
 	struct cls_fl_head *head = fl_head_dereference(tp);
diff --git a/net/sched/cls_matchall.c b/net/sched/cls_matchall.c
index 297b15dae9b8..54ccfe3e3e10 100644
--- a/net/sched/cls_matchall.c
+++ b/net/sched/cls_matchall.c
@@ -281,7 +281,7 @@ static void mall_walk(struct tcf_proto *tp, struct tcf_walker *arg,
 	arg->count++;
 }
 
-static int mall_reoffload(struct tcf_proto *tp, bool add, tc_setup_cb_t *cb,
+static int mall_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,
 			  void *cb_priv, struct netlink_ext_ack *extack)
 {
 	struct cls_mall_head *head = rtnl_dereference(tp->root);
diff --git a/net/sched/cls_u32.c b/net/sched/cls_u32.c
index b0858cec6fae..745c9b5aa426 100644
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@ -1166,7 +1166,7 @@ static void u32_walk(struct tcf_proto *tp, struct tcf_walker *arg,
 }
 
 static int u32_reoffload_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht,
-			       bool add, tc_setup_cb_t *cb, void *cb_priv,
+			       bool add, flow_setup_cb_t *cb, void *cb_priv,
 			       struct netlink_ext_ack *extack)
 {
 	struct tc_cls_u32_offload cls_u32 = {};
@@ -1186,7 +1186,7 @@ static int u32_reoffload_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht,
 }
 
 static int u32_reoffload_knode(struct tcf_proto *tp, struct tc_u_knode *n,
-			       bool add, tc_setup_cb_t *cb, void *cb_priv,
+			       bool add, flow_setup_cb_t *cb, void *cb_priv,
 			       struct netlink_ext_ack *extack)
 {
 	struct tc_u_hnode *ht = rtnl_dereference(n->ht_down);
@@ -1227,7 +1227,7 @@ static int u32_reoffload_knode(struct tcf_proto *tp, struct tc_u_knode *n,
 	return 0;
 }
 
-static int u32_reoffload(struct tcf_proto *tp, bool add, tc_setup_cb_t *cb,
+static int u32_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,
 			 void *cb_priv, struct netlink_ext_ack *extack)
 {
 	struct tc_u_common *tp_c = tp->data;
