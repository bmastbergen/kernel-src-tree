drm/nouveau/kms/nv50-: Store the bpc we're using in nv50_head_atom

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Lyude Paul <lyude@redhat.com>
commit ac2d9275f371346922b31a388bbaa6a54f1154a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ac2d9275.failed

In order to be able to use bpc values that are different from what the
connector reports, we want to be able to store the bpc value we decide
on using for an atomic state in nv50_head_atom and refer to that instead
of simply using the value that the connector reports throughout the
whole atomic check phase and commit phase. This will let us (eventually)
implement the max bpc connector property, and will also be needed for
limiting the bpc we use on MST displays to 8 in the next commit.

	Signed-off-by: Lyude Paul <lyude@redhat.com>
Fixes: 232c9eec417a ("drm/nouveau: Use atomic VCPI helpers for MST")
	Cc: Ben Skeggs <bskeggs@redhat.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: David Airlie <airlied@redhat.com>
	Cc: Jerry Zuo <Jerry.Zuo@amd.com>
	Cc: Harry Wentland <harry.wentland@amd.com>
	Cc: Juston Li <juston.li@intel.com>
	Cc: Sean Paul <seanpaul@chromium.org>
	Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Cc: <stable@vger.kernel.org> # v5.1+
	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit ac2d9275f371346922b31a388bbaa6a54f1154a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index 5216b642fff4,93665aecce57..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -765,34 -780,49 +775,58 @@@ nv50_msto_atomic_check(struct drm_encod
  	struct nv50_mstm *mstm = mstc->mstm;
  	struct nv50_head_atom *asyh = nv50_head_atom(crtc_state);
  	int slots;
 -	int ret;
  
 -	ret = nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,
 -					  mstc->native);
 -	if (ret)
 -		return ret;
 +	if (crtc_state->mode_changed || crtc_state->connectors_changed) {
 +		/*
 +		 * When restoring duplicated states, we need to make sure that
 +		 * the bw remains the same and avoid recalculating it, as the
 +		 * connector's bpc may have changed after the state was
 +		 * duplicated
 +		 */
 +		if (!state->duplicated) {
 +			const int bpp = connector->display_info.bpc * 3;
 +			const int clock = crtc_state->adjusted_mode.clock;
  
 -	if (!crtc_state->mode_changed && !crtc_state->connectors_changed)
 -		return 0;
 +			asyh->dp.pbn = drm_dp_calc_pbn_mode(bpp, clock);
 +		}
  
++<<<<<<< HEAD
 +		slots = drm_dp_atomic_find_vcpi_slots(state, &mstm->mgr,
 +						      mstc->port,
 +						      asyh->dp.pbn);
 +		if (slots < 0)
 +			return slots;
 +
 +		asyh->dp.tu = slots;
++=======
+ 	/*
+ 	 * When restoring duplicated states, we need to make sure that the bw
+ 	 * remains the same and avoid recalculating it, as the connector's bpc
+ 	 * may have changed after the state was duplicated
+ 	 */
+ 	if (!state->duplicated) {
+ 		const int clock = crtc_state->adjusted_mode.clock;
+ 
+ 		asyh->or.bpc = connector->display_info.bpc;
+ 		asyh->dp.pbn = drm_dp_calc_pbn_mode(clock, asyh->or.bpc * 3);
++>>>>>>> ac2d9275f371 (drm/nouveau/kms/nv50-: Store the bpc we're using in nv50_head_atom)
  	}
  
 -	slots = drm_dp_atomic_find_vcpi_slots(state, &mstm->mgr, mstc->port,
 -					      asyh->dp.pbn);
 -	if (slots < 0)
 -		return slots;
 -
 -	asyh->dp.tu = slots;
 -
 -	return 0;
 +	return nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,
 +					   mstc->native);
  }
  
+ static u8
+ nv50_dp_bpc_to_depth(unsigned int bpc)
+ {
+ 	switch (bpc) {
+ 	case  6: return 0x2;
+ 	case  8: return 0x5;
+ 	case 10: /* fall-through */
+ 	default: return 0x6;
+ 	}
+ }
+ 
  static void
  nv50_msto_enable(struct drm_encoder *encoder)
  {
diff --git a/drivers/gpu/drm/nouveau/dispnv50/atom.h b/drivers/gpu/drm/nouveau/dispnv50/atom.h
index b5fae5ab3fa8..01dab7ac101b 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/atom.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/atom.h
@@ -114,6 +114,7 @@ struct nv50_head_atom {
 		u8 nhsync:1;
 		u8 nvsync:1;
 		u8 depth:4;
+		u8 bpc;
 	} or;
 
 	/* Currently only used for MST */
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --git a/drivers/gpu/drm/nouveau/dispnv50/head.c b/drivers/gpu/drm/nouveau/dispnv50/head.c
index 06ee23823a68..80fa31119e79 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/head.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/head.c
@@ -81,18 +81,17 @@ nv50_head_atomic_check_dither(struct nv50_head_atom *armh,
 			      struct nv50_head_atom *asyh,
 			      struct nouveau_conn_atom *asyc)
 {
-	struct drm_connector *connector = asyc->state.connector;
 	u32 mode = 0x00;
 
 	if (asyc->dither.mode == DITHERING_MODE_AUTO) {
-		if (asyh->base.depth > connector->display_info.bpc * 3)
+		if (asyh->base.depth > asyh->or.bpc * 3)
 			mode = DITHERING_MODE_DYNAMIC2X2;
 	} else {
 		mode = asyc->dither.mode;
 	}
 
 	if (asyc->dither.depth == DITHERING_DEPTH_AUTO) {
-		if (connector->display_info.bpc >= 8)
+		if (asyh->or.bpc >= 8)
 			mode |= DITHERING_DEPTH_8BPC;
 	} else {
 		mode |= asyc->dither.depth;
