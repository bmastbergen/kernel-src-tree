dax: Fix dax_unlock_mapping_entry for PMD pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit fda490d39fc0668d92e170d95c11e35a010019aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/fda490d3.failed

Device DAX PMD pages do not set the PageHead bit for compound pages.
Fix for now by retrieving the PMD bit from the entry, but eventually we
will be passed the page size by the caller.

	Reported-by: Dan Williams <dan.j.williams@intel.com>
Fixes: 9f32d221301c ("dax: Convert dax_lock_mapping_entry to XArray")
	Signed-off-by: Matthew Wilcox <willy@infradead.org>
(cherry picked from commit fda490d39fc0668d92e170d95c11e35a010019aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index b89ab8b5e700,5426252375f6..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -94,10 -93,9 +94,14 @@@ static unsigned long dax_to_pfn(void *e
  	return xa_to_value(entry) >> DAX_SHIFT;
  }
  
 -static void *dax_make_entry(pfn_t pfn, unsigned long flags)
 +static void *dax_make_locked(unsigned long pfn, unsigned long flags)
  {
++<<<<<<< HEAD
 +	return xa_mk_value(flags | ((unsigned long)pfn << DAX_SHIFT) |
 +			DAX_LOCKED);
++=======
+ 	return xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));
++>>>>>>> fda490d39fc0 (dax: Fix dax_unlock_mapping_entry for PMD pages)
  }
  
  static bool dax_is_locked(void *entry)
@@@ -560,12 -406,17 +564,25 @@@ bool dax_lock_mapping_entry(struct pag
  void dax_unlock_mapping_entry(struct page *page)
  {
  	struct address_space *mapping = page->mapping;
++<<<<<<< HEAD
 +	struct inode *inode = mapping->host;
++=======
+ 	XA_STATE(xas, &mapping->i_pages, page->index);
+ 	void *entry;
++>>>>>>> fda490d39fc0 (dax: Fix dax_unlock_mapping_entry for PMD pages)
  
 -	if (S_ISCHR(mapping->host->i_mode))
 +	if (S_ISCHR(inode->i_mode))
  		return;
  
++<<<<<<< HEAD
 +	unlock_mapping_entry(mapping, page->index);
++=======
+ 	rcu_read_lock();
+ 	entry = xas_load(&xas);
+ 	rcu_read_unlock();
+ 	entry = dax_make_entry(page_to_pfn_t(page), dax_is_pmd_entry(entry));
+ 	dax_unlock_entry(&xas, entry);
++>>>>>>> fda490d39fc0 (dax: Fix dax_unlock_mapping_entry for PMD pages)
  }
  
  /*
* Unmerged path fs/dax.c
