dax: Check page->mapping isn't NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit c93db7bb6ef3251e0ea48ade311d3e9942748e1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c93db7bb.failed

If we race with inode destroy, it's possible for page->mapping to be
NULL before we even enter this routine, as well as after having slept
waiting for the dax entry to become unlocked.

Fixes: c2a7d2a11552 ("filesystem-dax: Introduce dax_lock_mapping_entry()")
	Cc: <stable@vger.kernel.org>
	Reported-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Matthew Wilcox <willy@infradead.org>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit c93db7bb6ef3251e0ea48ade311d3e9942748e1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index b89ab8b5e700,e69fc231833b..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -489,32 -346,26 +489,37 @@@ static struct page *dax_busy_page(void 
  	return NULL;
  }
  
 -/*
 - * dax_lock_mapping_entry - Lock the DAX entry corresponding to a page
 - * @page: The page whose entry we want to lock
 - *
 - * Context: Process context.
 - * Return: %true if the entry was locked or does not need to be locked.
 - */
 +static bool entry_wait_revalidate(void)
 +{
 +	rcu_read_unlock();
 +	schedule();
 +	rcu_read_lock();
 +
 +	/*
 +	 * Tell __get_unlocked_mapping_entry() to take a break, we need
 +	 * to revalidate page->mapping after dropping locks
 +	 */
 +	return true;
 +}
 +
  bool dax_lock_mapping_entry(struct page *page)
  {
 -	XA_STATE(xas, NULL, 0);
 -	void *entry;
 -	bool locked;
 +	pgoff_t index;
 +	struct inode *inode;
 +	bool did_lock = false;
 +	void *entry = NULL, **slot;
 +	struct address_space *mapping;
  
 -	/* Ensure page->mapping isn't freed while we look at it */
  	rcu_read_lock();
  	for (;;) {
 -		struct address_space *mapping = READ_ONCE(page->mapping);
 +		mapping = READ_ONCE(page->mapping);
  
++<<<<<<< HEAD
 +		if (!dax_mapping(mapping))
++=======
+ 		locked = false;
+ 		if (!mapping || !dax_mapping(mapping))
++>>>>>>> c93db7bb6ef3 (dax: Check page->mapping isn't NULL)
  			break;
  
  		/*
* Unmerged path fs/dax.c
