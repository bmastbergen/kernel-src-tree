perf tools: Add cpu_topology object

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 5135d5efcbb439c2acb20d6197dd57af3a456e76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5135d5ef.failed

Make struct cpu_topo global and rename it to 'struct cpu_topology', so
that it can be used from the 'perf record' command in the following
patches.

Add the following interface functions to load/free cpu topology details:

  struct cpu_topology *cpu_topology__new(void);
  void cpu_topology__delete(struct cpu_topology *tp);

Move it to a separate source file cputopo.c together with numa related
object in the following patches.

No functional change, the new interface will be used in upcoming changes.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20190219095815.15931-3-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 5135d5efcbb439c2acb20d6197dd57af3a456e76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/Build
diff --cc tools/perf/util/Build
index c4cd5217b90e,3008d49fa587..000000000000
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@@ -1,125 -1,127 +1,225 @@@
++<<<<<<< HEAD
 +libperf-y += annotate.o
 +libperf-y += block-range.o
 +libperf-y += build-id.o
 +libperf-y += config.o
 +libperf-y += ctype.o
 +libperf-y += db-export.o
 +libperf-y += env.o
 +libperf-y += event.o
 +libperf-y += evlist.o
 +libperf-y += evsel.o
 +libperf-y += evsel_fprintf.o
 +libperf-y += find_bit.o
 +libperf-y += kallsyms.o
 +libperf-y += levenshtein.o
 +libperf-y += llvm-utils.o
 +libperf-y += mmap.o
 +libperf-y += memswap.o
 +libperf-y += parse-events.o
 +libperf-y += perf_regs.o
 +libperf-y += path.o
 +libperf-y += print_binary.o
 +libperf-y += rbtree.o
 +libperf-y += libstring.o
 +libperf-y += bitmap.o
 +libperf-y += hweight.o
 +libperf-y += smt.o
 +libperf-y += strbuf.o
 +libperf-y += string.o
 +libperf-y += strlist.o
 +libperf-y += strfilter.o
 +libperf-y += top.o
 +libperf-y += usage.o
 +libperf-y += dso.o
 +libperf-y += symbol.o
 +libperf-y += symbol_fprintf.o
 +libperf-y += color.o
 +libperf-y += color_config.o
 +libperf-y += metricgroup.o
 +libperf-y += header.o
 +libperf-y += callchain.o
 +libperf-y += values.o
 +libperf-y += debug.o
 +libperf-y += machine.o
 +libperf-y += map.o
 +libperf-y += pstack.o
 +libperf-y += session.o
 +libperf-y += sample-raw.o
 +libperf-y += s390-sample-raw.o
 +libperf-$(CONFIG_TRACE) += syscalltbl.o
 +libperf-y += ordered-events.o
 +libperf-y += namespaces.o
 +libperf-y += comm.o
 +libperf-y += thread.o
 +libperf-y += thread_map.o
 +libperf-y += trace-event-parse.o
 +libperf-y += parse-events-flex.o
 +libperf-y += parse-events-bison.o
 +libperf-y += pmu.o
 +libperf-y += pmu-flex.o
 +libperf-y += pmu-bison.o
 +libperf-y += trace-event-read.o
 +libperf-y += trace-event-info.o
 +libperf-y += trace-event-scripting.o
 +libperf-y += trace-event.o
 +libperf-y += svghelper.o
 +libperf-y += sort.o
 +libperf-y += hist.o
 +libperf-y += util.o
 +libperf-y += xyarray.o
 +libperf-y += cpumap.o
 +libperf-y += cgroup.o
 +libperf-y += target.o
 +libperf-y += rblist.o
 +libperf-y += intlist.o
 +libperf-y += vdso.o
 +libperf-y += counts.o
 +libperf-y += stat.o
 +libperf-y += stat-shadow.o
 +libperf-y += stat-display.o
 +libperf-y += record.o
 +libperf-y += srcline.o
 +libperf-y += srccode.o
 +libperf-y += data.o
 +libperf-y += tsc.o
 +libperf-y += cloexec.o
 +libperf-y += call-path.o
 +libperf-y += rwsem.o
 +libperf-y += thread-stack.o
 +libperf-$(CONFIG_AUXTRACE) += auxtrace.o
 +libperf-$(CONFIG_AUXTRACE) += intel-pt-decoder/
 +libperf-$(CONFIG_AUXTRACE) += intel-pt.o
 +libperf-$(CONFIG_AUXTRACE) += intel-bts.o
 +libperf-$(CONFIG_AUXTRACE) += arm-spe.o
 +libperf-$(CONFIG_AUXTRACE) += arm-spe-pkt-decoder.o
 +libperf-$(CONFIG_AUXTRACE) += s390-cpumsf.o
++=======
+ perf-y += annotate.o
+ perf-y += block-range.o
+ perf-y += build-id.o
+ perf-y += config.o
+ perf-y += ctype.o
+ perf-y += db-export.o
+ perf-y += env.o
+ perf-y += event.o
+ perf-y += evlist.o
+ perf-y += evsel.o
+ perf-y += evsel_fprintf.o
+ perf-y += find_bit.o
+ perf-y += get_current_dir_name.o
+ perf-y += kallsyms.o
+ perf-y += levenshtein.o
+ perf-y += llvm-utils.o
+ perf-y += mmap.o
+ perf-y += memswap.o
+ perf-y += parse-events.o
+ perf-y += perf_regs.o
+ perf-y += path.o
+ perf-y += print_binary.o
+ perf-y += rbtree.o
+ perf-y += libstring.o
+ perf-y += bitmap.o
+ perf-y += hweight.o
+ perf-y += smt.o
+ perf-y += strbuf.o
+ perf-y += string.o
+ perf-y += strlist.o
+ perf-y += strfilter.o
+ perf-y += top.o
+ perf-y += usage.o
+ perf-y += dso.o
+ perf-y += symbol.o
+ perf-y += symbol_fprintf.o
+ perf-y += color.o
+ perf-y += color_config.o
+ perf-y += metricgroup.o
+ perf-y += header.o
+ perf-y += callchain.o
+ perf-y += values.o
+ perf-y += debug.o
+ perf-y += machine.o
+ perf-y += map.o
+ perf-y += pstack.o
+ perf-y += session.o
+ perf-y += sample-raw.o
+ perf-y += s390-sample-raw.o
+ perf-$(CONFIG_TRACE) += syscalltbl.o
+ perf-y += ordered-events.o
+ perf-y += namespaces.o
+ perf-y += comm.o
+ perf-y += thread.o
+ perf-y += thread_map.o
+ perf-y += trace-event-parse.o
+ perf-y += parse-events-flex.o
+ perf-y += parse-events-bison.o
+ perf-y += pmu.o
+ perf-y += pmu-flex.o
+ perf-y += pmu-bison.o
+ perf-y += trace-event-read.o
+ perf-y += trace-event-info.o
+ perf-y += trace-event-scripting.o
+ perf-y += trace-event.o
+ perf-y += svghelper.o
+ perf-y += sort.o
+ perf-y += hist.o
+ perf-y += util.o
+ perf-y += xyarray.o
+ perf-y += cpumap.o
+ perf-y += cputopo.o
+ perf-y += cgroup.o
+ perf-y += target.o
+ perf-y += rblist.o
+ perf-y += intlist.o
+ perf-y += vdso.o
+ perf-y += counts.o
+ perf-y += stat.o
+ perf-y += stat-shadow.o
+ perf-y += stat-display.o
+ perf-y += record.o
+ perf-y += srcline.o
+ perf-y += srccode.o
+ perf-y += data.o
+ perf-y += tsc.o
+ perf-y += cloexec.o
+ perf-y += call-path.o
+ perf-y += rwsem.o
+ perf-y += thread-stack.o
+ perf-$(CONFIG_AUXTRACE) += auxtrace.o
+ perf-$(CONFIG_AUXTRACE) += intel-pt-decoder/
+ perf-$(CONFIG_AUXTRACE) += intel-pt.o
+ perf-$(CONFIG_AUXTRACE) += intel-bts.o
+ perf-$(CONFIG_AUXTRACE) += arm-spe.o
+ perf-$(CONFIG_AUXTRACE) += arm-spe-pkt-decoder.o
+ perf-$(CONFIG_AUXTRACE) += s390-cpumsf.o
++>>>>>>> 5135d5efcbb4 (perf tools: Add cpu_topology object)
  
  ifdef CONFIG_LIBOPENCSD
 -perf-$(CONFIG_AUXTRACE) += cs-etm.o
 -perf-$(CONFIG_AUXTRACE) += cs-etm-decoder/
 +libperf-$(CONFIG_AUXTRACE) += cs-etm.o
 +libperf-$(CONFIG_AUXTRACE) += cs-etm-decoder/
  endif
  
 -perf-y += parse-branch-options.o
 -perf-y += dump-insn.o
 -perf-y += parse-regs-options.o
 -perf-y += term.o
 -perf-y += help-unknown-cmd.o
 -perf-y += mem-events.o
 -perf-y += vsprintf.o
 -perf-y += units.o
 -perf-y += time-utils.o
 -perf-y += expr-bison.o
 -perf-y += branch.o
 -perf-y += mem2node.o
 -
 -perf-$(CONFIG_LIBBPF) += bpf-loader.o
 -perf-$(CONFIG_BPF_PROLOGUE) += bpf-prologue.o
 -perf-$(CONFIG_LIBELF) += symbol-elf.o
 -perf-$(CONFIG_LIBELF) += probe-file.o
 -perf-$(CONFIG_LIBELF) += probe-event.o
 +libperf-y += parse-branch-options.o
 +libperf-y += dump-insn.o
 +libperf-y += parse-regs-options.o
 +libperf-y += term.o
 +libperf-y += help-unknown-cmd.o
 +libperf-y += mem-events.o
 +libperf-y += vsprintf.o
 +libperf-y += units.o
 +libperf-y += time-utils.o
 +libperf-y += expr-bison.o
 +libperf-y += branch.o
 +libperf-y += mem2node.o
 +
 +libperf-$(CONFIG_LIBBPF) += bpf-loader.o
 +libperf-$(CONFIG_BPF_PROLOGUE) += bpf-prologue.o
 +libperf-$(CONFIG_LIBELF) += symbol-elf.o
 +libperf-$(CONFIG_LIBELF) += probe-file.o
 +libperf-$(CONFIG_LIBELF) += probe-event.o
  
  ifndef CONFIG_LIBELF
 -perf-y += symbol-minimal.o
 +libperf-y += symbol-minimal.o
  endif
  
  ifndef CONFIG_SETNS
* Unmerged path tools/perf/util/Build
diff --git a/tools/perf/util/cputopo.c b/tools/perf/util/cputopo.c
new file mode 100644
index 000000000000..84470ed4e707
--- /dev/null
+++ b/tools/perf/util/cputopo.c
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <sys/param.h>
+
+#include "cputopo.h"
+#include "cpumap.h"
+#include "util.h"
+
+
+#define CORE_SIB_FMT \
+	"/sys/devices/system/cpu/cpu%d/topology/core_siblings_list"
+#define THRD_SIB_FMT \
+	"/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list"
+
+static int build_cpu_topology(struct cpu_topology *tp, int cpu)
+{
+	FILE *fp;
+	char filename[MAXPATHLEN];
+	char *buf = NULL, *p;
+	size_t len = 0;
+	ssize_t sret;
+	u32 i = 0;
+	int ret = -1;
+
+	sprintf(filename, CORE_SIB_FMT, cpu);
+	fp = fopen(filename, "r");
+	if (!fp)
+		goto try_threads;
+
+	sret = getline(&buf, &len, fp);
+	fclose(fp);
+	if (sret <= 0)
+		goto try_threads;
+
+	p = strchr(buf, '\n');
+	if (p)
+		*p = '\0';
+
+	for (i = 0; i < tp->core_sib; i++) {
+		if (!strcmp(buf, tp->core_siblings[i]))
+			break;
+	}
+	if (i == tp->core_sib) {
+		tp->core_siblings[i] = buf;
+		tp->core_sib++;
+		buf = NULL;
+		len = 0;
+	}
+	ret = 0;
+
+try_threads:
+	sprintf(filename, THRD_SIB_FMT, cpu);
+	fp = fopen(filename, "r");
+	if (!fp)
+		goto done;
+
+	if (getline(&buf, &len, fp) <= 0)
+		goto done;
+
+	p = strchr(buf, '\n');
+	if (p)
+		*p = '\0';
+
+	for (i = 0; i < tp->thread_sib; i++) {
+		if (!strcmp(buf, tp->thread_siblings[i]))
+			break;
+	}
+	if (i == tp->thread_sib) {
+		tp->thread_siblings[i] = buf;
+		tp->thread_sib++;
+		buf = NULL;
+	}
+	ret = 0;
+done:
+	if (fp)
+		fclose(fp);
+	free(buf);
+	return ret;
+}
+
+void cpu_topology__delete(struct cpu_topology *tp)
+{
+	u32 i;
+
+	if (!tp)
+		return;
+
+	for (i = 0 ; i < tp->core_sib; i++)
+		zfree(&tp->core_siblings[i]);
+
+	for (i = 0 ; i < tp->thread_sib; i++)
+		zfree(&tp->thread_siblings[i]);
+
+	free(tp);
+}
+
+struct cpu_topology *cpu_topology__new(void)
+{
+	struct cpu_topology *tp = NULL;
+	void *addr;
+	u32 nr, i;
+	size_t sz;
+	long ncpus;
+	int ret = -1;
+	struct cpu_map *map;
+
+	ncpus = cpu__max_present_cpu();
+
+	/* build online CPU map */
+	map = cpu_map__new(NULL);
+	if (map == NULL) {
+		pr_debug("failed to get system cpumap\n");
+		return NULL;
+	}
+
+	nr = (u32)(ncpus & UINT_MAX);
+
+	sz = nr * sizeof(char *);
+	addr = calloc(1, sizeof(*tp) + 2 * sz);
+	if (!addr)
+		goto out_free;
+
+	tp = addr;
+	addr += sizeof(*tp);
+	tp->core_siblings = addr;
+	addr += sz;
+	tp->thread_siblings = addr;
+
+	for (i = 0; i < nr; i++) {
+		if (!cpu_map__has(map, i))
+			continue;
+
+		ret = build_cpu_topology(tp, i);
+		if (ret < 0)
+			break;
+	}
+
+out_free:
+	cpu_map__put(map);
+	if (ret) {
+		cpu_topology__delete(tp);
+		tp = NULL;
+	}
+	return tp;
+}
diff --git a/tools/perf/util/cputopo.h b/tools/perf/util/cputopo.h
new file mode 100644
index 000000000000..4b5f4112b6f8
--- /dev/null
+++ b/tools/perf/util/cputopo.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __PERF_CPUTOPO_H
+#define __PERF_CPUTOPO_H
+
+#include <linux/types.h>
+
+struct cpu_topology {
+	u32	  core_sib;
+	u32	  thread_sib;
+	char	**core_siblings;
+	char	**thread_siblings;
+};
+
+struct cpu_topology *cpu_topology__new(void);
+void cpu_topology__delete(struct cpu_topology *tp);
+
+#endif /* __PERF_CPUTOPO_H */
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index 9c53d6e735e1..e4685f24f755 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -39,6 +39,7 @@
 #include "tool.h"
 #include "time-utils.h"
 #include "units.h"
+#include "cputopo.h"
 
 #include "sane_ctype.h"
 
@@ -557,158 +558,15 @@ static int write_cmdline(struct feat_fd *ff,
 	return 0;
 }
 
-#define CORE_SIB_FMT \
-	"/sys/devices/system/cpu/cpu%d/topology/core_siblings_list"
-#define THRD_SIB_FMT \
-	"/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list"
-
-struct cpu_topo {
-	u32 core_sib;
-	u32 thread_sib;
-	char **core_siblings;
-	char **thread_siblings;
-};
-
-static int build_cpu_topo(struct cpu_topo *tp, int cpu)
-{
-	FILE *fp;
-	char filename[MAXPATHLEN];
-	char *buf = NULL, *p;
-	size_t len = 0;
-	ssize_t sret;
-	u32 i = 0;
-	int ret = -1;
-
-	sprintf(filename, CORE_SIB_FMT, cpu);
-	fp = fopen(filename, "r");
-	if (!fp)
-		goto try_threads;
-
-	sret = getline(&buf, &len, fp);
-	fclose(fp);
-	if (sret <= 0)
-		goto try_threads;
-
-	p = strchr(buf, '\n');
-	if (p)
-		*p = '\0';
-
-	for (i = 0; i < tp->core_sib; i++) {
-		if (!strcmp(buf, tp->core_siblings[i]))
-			break;
-	}
-	if (i == tp->core_sib) {
-		tp->core_siblings[i] = buf;
-		tp->core_sib++;
-		buf = NULL;
-		len = 0;
-	}
-	ret = 0;
-
-try_threads:
-	sprintf(filename, THRD_SIB_FMT, cpu);
-	fp = fopen(filename, "r");
-	if (!fp)
-		goto done;
-
-	if (getline(&buf, &len, fp) <= 0)
-		goto done;
-
-	p = strchr(buf, '\n');
-	if (p)
-		*p = '\0';
-
-	for (i = 0; i < tp->thread_sib; i++) {
-		if (!strcmp(buf, tp->thread_siblings[i]))
-			break;
-	}
-	if (i == tp->thread_sib) {
-		tp->thread_siblings[i] = buf;
-		tp->thread_sib++;
-		buf = NULL;
-	}
-	ret = 0;
-done:
-	if(fp)
-		fclose(fp);
-	free(buf);
-	return ret;
-}
-
-static void free_cpu_topo(struct cpu_topo *tp)
-{
-	u32 i;
-
-	if (!tp)
-		return;
-
-	for (i = 0 ; i < tp->core_sib; i++)
-		zfree(&tp->core_siblings[i]);
-
-	for (i = 0 ; i < tp->thread_sib; i++)
-		zfree(&tp->thread_siblings[i]);
-
-	free(tp);
-}
-
-static struct cpu_topo *build_cpu_topology(void)
-{
-	struct cpu_topo *tp = NULL;
-	void *addr;
-	u32 nr, i;
-	size_t sz;
-	long ncpus;
-	int ret = -1;
-	struct cpu_map *map;
-
-	ncpus = cpu__max_present_cpu();
-
-	/* build online CPU map */
-	map = cpu_map__new(NULL);
-	if (map == NULL) {
-		pr_debug("failed to get system cpumap\n");
-		return NULL;
-	}
-
-	nr = (u32)(ncpus & UINT_MAX);
-
-	sz = nr * sizeof(char *);
-	addr = calloc(1, sizeof(*tp) + 2 * sz);
-	if (!addr)
-		goto out_free;
-
-	tp = addr;
-	addr += sizeof(*tp);
-	tp->core_siblings = addr;
-	addr += sz;
-	tp->thread_siblings = addr;
-
-	for (i = 0; i < nr; i++) {
-		if (!cpu_map__has(map, i))
-			continue;
-
-		ret = build_cpu_topo(tp, i);
-		if (ret < 0)
-			break;
-	}
-
-out_free:
-	cpu_map__put(map);
-	if (ret) {
-		free_cpu_topo(tp);
-		tp = NULL;
-	}
-	return tp;
-}
 
 static int write_cpu_topology(struct feat_fd *ff,
 			      struct perf_evlist *evlist __maybe_unused)
 {
-	struct cpu_topo *tp;
+	struct cpu_topology *tp;
 	u32 i;
 	int ret, j;
 
-	tp = build_cpu_topology();
+	tp = cpu_topology__new();
 	if (!tp)
 		return -1;
 
@@ -746,7 +604,7 @@ static int write_cpu_topology(struct feat_fd *ff,
 			return ret;
 	}
 done:
-	free_cpu_topo(tp);
+	cpu_topology__delete(tp);
 	return ret;
 }
 
