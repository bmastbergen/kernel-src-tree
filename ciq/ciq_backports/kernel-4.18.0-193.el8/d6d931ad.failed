fuse: use kvmalloc to allocate array of pipe_buffer structs.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrey Ryabinin <aryabinin@virtuozzo.com>
commit d6d931adce1193ef54d06fa9bbf58e5780ca516c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d6d931ad.failed

The amount of pipe->buffers is basically controlled by userspace by
fcntl(... F_SETPIPE_SZ ...) so it could be large. High order allocations
could be slow (if memory is heavily fragmented) or may fail if the order
is larger than PAGE_ALLOC_COSTLY_ORDER.

Since the 'bufs' doesn't need to be physically contiguous, use
the kvmalloc_array() to allocate memory. If high order
page isn't available, the kvamalloc*() will fallback to 0-order.

	Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit d6d931adce1193ef54d06fa9bbf58e5780ca516c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index afc6e275adaa,1050c1cc22fe..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -2032,13 -2013,11 +2032,18 @@@ static ssize_t fuse_dev_splice_write(st
  
  	ret = fuse_dev_do_write(fud, &cs, len);
  
 +	pipe_lock(pipe);
 +out_free:
  	for (idx = 0; idx < nbuf; idx++)
  		pipe_buf_release(pipe, &bufs[idx]);
 +	pipe_unlock(pipe);
  
++<<<<<<< HEAD
 +	kfree(bufs);
++=======
+ out:
+ 	kvfree(bufs);
++>>>>>>> d6d931adce11 (fuse: use kvmalloc to allocate array of pipe_buffer structs.)
  	return ret;
  }
  
* Unmerged path fs/fuse/dev.c
