net: skmsg: fix TLS 1.3 crash with full sk_msg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] skmsg: fix TLS 1.3 crash with full sk_msg (Sabrina Dubroca) [1798179]
Rebuild_FUZZ: 94.25%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 031097d9e079e40dce401031d1012e83d80eaf01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/031097d9.failed

TLS 1.3 started using the entry at the end of the SG array
for chaining-in the single byte content type entry. This mostly
works:

[ E E E E E E . . ]
  ^           ^
   start       end

                 E < content type
               /
[ E E E E E E C . ]
  ^           ^
   start       end

(Where E denotes a populated SG entry; C denotes a chaining entry.)

If the array is full, however, the end will point to the start:

[ E E E E E E E E ]
  ^
   start
   end

And we end up overwriting the start:

    E < content type
   /
[ C E E E E E E E ]
  ^
   start
   end

The sg array is supposed to be a circular buffer with start and
end markers pointing anywhere. In case where start > end
(i.e. the circular buffer has "wrapped") there is an extra entry
reserved at the end to chain the two halves together.

[ E E E E E E . . l ]

(Where l is the reserved entry for "looping" back to front.

As suggested by John, let's reserve another entry for chaining
SG entries after the main circular buffer. Note that this entry
has to be pointed to by the end entry so its position is not fixed.

Examples of full messages:

[ E E E E E E E E . l ]
  ^               ^
   start           end

   <---------------.
[ E E . E E E E E E l ]
      ^ ^
   end   start

Now the end will always point to an unused entry, so TLS 1.3
can always use it.

Fixes: 130b392c6cd6 ("net: tls: Add tls 1.3 support")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 031097d9e079e40dce401031d1012e83d80eaf01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skmsg.h
diff --cc include/linux/skmsg.h
index 4afabf2d2a42,ef7031f8a304..000000000000
--- a/include/linux/skmsg.h
+++ b/include/linux/skmsg.h
@@@ -28,13 -29,16 +29,26 @@@ struct sk_msg_sg 
  	u32				end;
  	u32				size;
  	u32				copybreak;
++<<<<<<< HEAD
 +	bool				copy[MAX_MSG_FRAGS];
 +	/* The extra element is used for chaining the front and sections when
 +	 * the list becomes partitioned (e.g. end < start). The crypto APIs
 +	 * require the chaining.
++=======
+ 	unsigned long			copy;
+ 	/* The extra two elements:
+ 	 * 1) used for chaining the front and sections when the list becomes
+ 	 *    partitioned (e.g. end < start). The crypto APIs require the
+ 	 *    chaining;
+ 	 * 2) to chain tailer SG entries after the message.
++>>>>>>> 031097d9e079 (net: skmsg: fix TLS 1.3 crash with full sk_msg)
  	 */
- 	struct scatterlist		data[MAX_MSG_FRAGS + 1];
+ 	struct scatterlist		data[MAX_MSG_FRAGS + 2];
  };
++<<<<<<< HEAD
++=======
+ static_assert(BITS_PER_LONG >= NR_MSG_FRAG_IDS);
++>>>>>>> 031097d9e079 (net: skmsg: fix TLS 1.3 crash with full sk_msg)
  
  /* UAPI in filter.c depends on struct sk_msg_sg being first element. */
  struct sk_msg {
* Unmerged path include/linux/skmsg.h
diff --git a/net/core/filter.c b/net/core/filter.c
index a1c7b2179063..48f0c06e2152 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -2276,7 +2276,7 @@ BPF_CALL_4(bpf_msg_pull_data, struct sk_msg *, msg, u32, start,
 	WARN_ON_ONCE(last_sge == first_sge);
 	shift = last_sge > first_sge ?
 		last_sge - first_sge - 1 :
-		MAX_SKB_FRAGS - first_sge + last_sge - 1;
+		NR_MSG_FRAG_IDS - first_sge + last_sge - 1;
 	if (!shift)
 		goto out;
 
@@ -2285,8 +2285,8 @@ BPF_CALL_4(bpf_msg_pull_data, struct sk_msg *, msg, u32, start,
 	do {
 		u32 move_from;
 
-		if (i + shift >= MAX_MSG_FRAGS)
-			move_from = i + shift - MAX_MSG_FRAGS;
+		if (i + shift >= NR_MSG_FRAG_IDS)
+			move_from = i + shift - NR_MSG_FRAG_IDS;
 		else
 			move_from = i + shift;
 		if (move_from == msg->sg.end)
@@ -2300,7 +2300,7 @@ BPF_CALL_4(bpf_msg_pull_data, struct sk_msg *, msg, u32, start,
 	} while (1);
 
 	msg->sg.end = msg->sg.end - shift > msg->sg.end ?
-		      msg->sg.end - shift + MAX_MSG_FRAGS :
+		      msg->sg.end - shift + NR_MSG_FRAG_IDS :
 		      msg->sg.end - shift;
 out:
 	msg->data = sg_virt(&msg->sg.data[first_sge]) + start - offset;
diff --git a/net/core/skmsg.c b/net/core/skmsg.c
index 13cb7d01b955..fc6f99dcddfd 100644
--- a/net/core/skmsg.c
+++ b/net/core/skmsg.c
@@ -422,7 +422,7 @@ static int sk_psock_skb_ingress(struct sk_psock *psock, struct sk_buff *skb)
 	copied = skb->len;
 	msg->sg.start = 0;
 	msg->sg.size = copied;
-	msg->sg.end = num_sge == MAX_MSG_FRAGS ? 0 : num_sge;
+	msg->sg.end = num_sge;
 	msg->skb = skb;
 
 	sk_psock_queue_msg(psock, msg);
diff --git a/net/ipv4/tcp_bpf.c b/net/ipv4/tcp_bpf.c
index 3d1e15401384..82769b7a8d19 100644
--- a/net/ipv4/tcp_bpf.c
+++ b/net/ipv4/tcp_bpf.c
@@ -301,7 +301,7 @@ EXPORT_SYMBOL_GPL(tcp_bpf_sendmsg_redir);
 static int tcp_bpf_send_verdict(struct sock *sk, struct sk_psock *psock,
 				struct sk_msg *msg, int *copied, int flags)
 {
-	bool cork = false, enospc = msg->sg.start == msg->sg.end;
+	bool cork = false, enospc = sk_msg_full(msg);
 	struct sock *sk_redir;
 	u32 tosend, delta = 0;
 	int ret;
