netlink: re-add parse/validate functions in strict mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 3de644035446567017e952f16da2594d6bd195fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3de64403.failed

This re-adds the parse and validate functions like nla_parse()
that are now actually strict after the previous rename and were
just split out to make sure everything is converted (and if not
compilation of the previous patch would fail.)

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3de644035446567017e952f16da2594d6bd195fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netlink.h
diff --cc include/net/netlink.h
index 01d3e027e7e1,e4dd874412bf..000000000000
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@@ -425,7 -539,83 +425,87 @@@ nlmsg_next(const struct nlmsghdr *nlh, 
  }
  
  /**
++<<<<<<< HEAD
 + * nlmsg_parse - parse attributes of a netlink message
++=======
+  * nla_parse - Parse a stream of attributes into a tb buffer
+  * @tb: destination array with maxtype+1 elements
+  * @maxtype: maximum attribute type to be expected
+  * @head: head of attribute stream
+  * @len: length of attribute stream
+  * @policy: validation policy
+  * @extack: extended ACK pointer
+  *
+  * Parses a stream of attributes and stores a pointer to each attribute in
+  * the tb array accessible via the attribute type. Attributes with a type
+  * exceeding maxtype will be rejected, policy must be specified, attributes
+  * will be validated in the strictest way possible.
+  *
+  * Returns 0 on success or a negative error code.
+  */
+ static inline int nla_parse(struct nlattr **tb, int maxtype,
+ 			    const struct nlattr *head, int len,
+ 			    const struct nla_policy *policy,
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	return __nla_parse(tb, maxtype, head, len, policy,
+ 			   NL_VALIDATE_STRICT, extack);
+ }
+ 
+ /**
+  * nla_parse_deprecated - Parse a stream of attributes into a tb buffer
+  * @tb: destination array with maxtype+1 elements
+  * @maxtype: maximum attribute type to be expected
+  * @head: head of attribute stream
+  * @len: length of attribute stream
+  * @policy: validation policy
+  * @extack: extended ACK pointer
+  *
+  * Parses a stream of attributes and stores a pointer to each attribute in
+  * the tb array accessible via the attribute type. Attributes with a type
+  * exceeding maxtype will be ignored and attributes from the policy are not
+  * always strictly validated (only for new attributes).
+  *
+  * Returns 0 on success or a negative error code.
+  */
+ static inline int nla_parse_deprecated(struct nlattr **tb, int maxtype,
+ 				       const struct nlattr *head, int len,
+ 				       const struct nla_policy *policy,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	return __nla_parse(tb, maxtype, head, len, policy,
+ 			   NL_VALIDATE_LIBERAL, extack);
+ }
+ 
+ /**
+  * nla_parse_deprecated_strict - Parse a stream of attributes into a tb buffer
+  * @tb: destination array with maxtype+1 elements
+  * @maxtype: maximum attribute type to be expected
+  * @head: head of attribute stream
+  * @len: length of attribute stream
+  * @policy: validation policy
+  * @extack: extended ACK pointer
+  *
+  * Parses a stream of attributes and stores a pointer to each attribute in
+  * the tb array accessible via the attribute type. Attributes with a type
+  * exceeding maxtype will be rejected as well as trailing data, but the
+  * policy is not completely strictly validated (only for new attributes).
+  *
+  * Returns 0 on success or a negative error code.
+  */
+ static inline int nla_parse_deprecated_strict(struct nlattr **tb, int maxtype,
+ 					      const struct nlattr *head,
+ 					      int len,
+ 					      const struct nla_policy *policy,
+ 					      struct netlink_ext_ack *extack)
+ {
+ 	return __nla_parse(tb, maxtype, head, len, policy,
+ 			   NL_VALIDATE_DEPRECATED_STRICT, extack);
+ }
+ 
+ /**
+  * __nlmsg_parse - parse attributes of a netlink message
++>>>>>>> 3de644035446 (netlink: re-add parse/validate functions in strict mode)
   * @nlh: netlink message header
   * @hdrlen: length of family specific header
   * @tb: destination array with maxtype+1 elements
@@@ -445,22 -637,69 +525,60 @@@ static inline int nlmsg_parse(const str
  		return -EINVAL;
  	}
  
 -	return __nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),
 -			   nlmsg_attrlen(nlh, hdrlen), policy, validate,
 -			   extack);
 +	return nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),
 +			 nlmsg_attrlen(nlh, hdrlen), policy, extack);
  }
  
++<<<<<<< HEAD
 +static inline int nlmsg_parse_strict(const struct nlmsghdr *nlh, int hdrlen,
 +				     struct nlattr *tb[], int maxtype,
 +				     const struct nla_policy *policy,
 +				     struct netlink_ext_ack *extack)
++=======
+ /**
+  * nlmsg_parse - parse attributes of a netlink message
+  * @nlh: netlink message header
+  * @hdrlen: length of family specific header
+  * @tb: destination array with maxtype+1 elements
+  * @maxtype: maximum attribute type to be expected
+  * @validate: validation strictness
+  * @extack: extended ACK report struct
+  *
+  * See nla_parse()
+  */
+ static inline int nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,
+ 			      struct nlattr *tb[], int maxtype,
+ 			      const struct nla_policy *policy,
+ 			      struct netlink_ext_ack *extack)
+ {
+ 	return __nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),
+ 			   nlmsg_attrlen(nlh, hdrlen), policy,
+ 			   NL_VALIDATE_STRICT, extack);
+ }
+ 
+ /**
+  * nlmsg_parse_deprecated - parse attributes of a netlink message
+  * @nlh: netlink message header
+  * @hdrlen: length of family specific header
+  * @tb: destination array with maxtype+1 elements
+  * @maxtype: maximum attribute type to be expected
+  * @extack: extended ACK report struct
+  *
+  * See nla_parse_deprecated()
+  */
+ static inline int nlmsg_parse_deprecated(const struct nlmsghdr *nlh, int hdrlen,
+ 					 struct nlattr *tb[], int maxtype,
+ 					 const struct nla_policy *policy,
+ 					 struct netlink_ext_ack *extack)
++>>>>>>> 3de644035446 (netlink: re-add parse/validate functions in strict mode)
  {
 -	return __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,
 -			     NL_VALIDATE_LIBERAL, extack);
 -}
 +	if (nlh->nlmsg_len < nlmsg_msg_size(hdrlen)) {
 +		NL_SET_ERR_MSG(extack, "Invalid header length");
 +		return -EINVAL;
 +	}
  
 -/**
 - * nlmsg_parse_deprecated_strict - parse attributes of a netlink message
 - * @nlh: netlink message header
 - * @hdrlen: length of family specific header
 - * @tb: destination array with maxtype+1 elements
 - * @maxtype: maximum attribute type to be expected
 - * @extack: extended ACK report struct
 - *
 - * See nla_parse_deprecated_strict()
 - */
 -static inline int
 -nlmsg_parse_deprecated_strict(const struct nlmsghdr *nlh, int hdrlen,
 -			      struct nlattr *tb[], int maxtype,
 -			      const struct nla_policy *policy,
 -			      struct netlink_ext_ack *extack)
 -{
 -	return __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,
 -			     NL_VALIDATE_DEPRECATED_STRICT, extack);
 +	return nla_parse_strict(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),
 +				nlmsg_attrlen(nlh, hdrlen), policy, extack);
  }
  
  /**
@@@ -479,7 -718,54 +597,58 @@@ static inline struct nlattr *nlmsg_find
  }
  
  /**
++<<<<<<< HEAD
 + * nlmsg_validate - validate a netlink message including attributes
++=======
+  * nla_validate_deprecated - Validate a stream of attributes
+  * @head: head of attribute stream
+  * @len: length of attribute stream
+  * @maxtype: maximum attribute type to be expected
+  * @policy: validation policy
+  * @validate: validation strictness
+  * @extack: extended ACK report struct
+  *
+  * Validates all attributes in the specified attribute stream against the
+  * specified policy. Validation is done in liberal mode.
+  * See documenation of struct nla_policy for more details.
+  *
+  * Returns 0 on success or a negative error code.
+  */
+ static inline int nla_validate_deprecated(const struct nlattr *head, int len,
+ 					  int maxtype,
+ 					  const struct nla_policy *policy,
+ 					  struct netlink_ext_ack *extack)
+ {
+ 	return __nla_validate(head, len, maxtype, policy, NL_VALIDATE_LIBERAL,
+ 			      extack);
+ }
+ 
+ /**
+  * nla_validate - Validate a stream of attributes
+  * @head: head of attribute stream
+  * @len: length of attribute stream
+  * @maxtype: maximum attribute type to be expected
+  * @policy: validation policy
+  * @validate: validation strictness
+  * @extack: extended ACK report struct
+  *
+  * Validates all attributes in the specified attribute stream against the
+  * specified policy. Validation is done in strict mode.
+  * See documenation of struct nla_policy for more details.
+  *
+  * Returns 0 on success or a negative error code.
+  */
+ static inline int nla_validate(const struct nlattr *head, int len, int maxtype,
+ 			       const struct nla_policy *policy,
+ 			       struct netlink_ext_ack *extack)
+ {
+ 	return __nla_validate(head, len, maxtype, policy, NL_VALIDATE_STRICT,
+ 			      extack);
+ }
+ 
+ /**
+  * nlmsg_validate_deprecated - validate a netlink message including attributes
++>>>>>>> 3de644035446 (netlink: re-add parse/validate functions in strict mode)
   * @nlh: netlinket message header
   * @hdrlen: length of familiy specific header
   * @maxtype: maximum attribute type to be expected
@@@ -813,6 -1101,25 +982,28 @@@ nla_find_nested(const struct nlattr *nl
  
  /**
   * nla_parse_nested - parse nested attributes
++<<<<<<< HEAD
++=======
+  * @tb: destination array with maxtype+1 elements
+  * @maxtype: maximum attribute type to be expected
+  * @nla: attribute containing the nested attributes
+  * @policy: validation policy
+  * @extack: extended ACK report struct
+  *
+  * See nla_parse()
+  */
+ static inline int nla_parse_nested(struct nlattr *tb[], int maxtype,
+ 				   const struct nlattr *nla,
+ 				   const struct nla_policy *policy,
+ 				   struct netlink_ext_ack *extack)
+ {
+ 	return __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,
+ 			   NL_VALIDATE_STRICT, extack);
+ }
+ 
+ /**
+  * nla_parse_nested_deprecated - parse nested attributes
++>>>>>>> 3de644035446 (netlink: re-add parse/validate functions in strict mode)
   * @tb: destination array with maxtype+1 elements
   * @maxtype: maximum attribute type to be expected
   * @nla: attribute containing the nested attributes
diff --git a/include/net/genetlink.h b/include/net/genetlink.h
index 22f49598a574..1d80fb0fe0ca 100644
--- a/include/net/genetlink.h
+++ b/include/net/genetlink.h
@@ -206,6 +206,25 @@ static inline int genlmsg_parse(const struct nlmsghdr *nlh,
 			   policy, extack);
 }
 
+/**
+ * genlmsg_parse - parse attributes of a genetlink message
+ * @nlh: netlink message header
+ * @family: genetlink message family
+ * @tb: destination array with maxtype+1 elements
+ * @maxtype: maximum attribute type to be expected
+ * @policy: validation policy
+ * @extack: extended ACK report struct
+ */
+static inline int genlmsg_parse(const struct nlmsghdr *nlh,
+				const struct genl_family *family,
+				struct nlattr *tb[], int maxtype,
+				const struct nla_policy *policy,
+				struct netlink_ext_ack *extack)
+{
+	return __nlmsg_parse(nlh, family->hdrsize + GENL_HDRLEN, tb, maxtype,
+			     policy, NL_VALIDATE_STRICT, extack);
+}
+
 /**
  * genl_dump_check_consistent - check if sequence is consistent and advertise if not
  * @cb: netlink callback structure that stores the sequence number
* Unmerged path include/net/netlink.h
