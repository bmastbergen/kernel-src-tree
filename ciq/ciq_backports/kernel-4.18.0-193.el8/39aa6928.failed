xfrm: policy: fix netlink/pf_key policy lookups

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit 39aa6928d462d0f4fd809ff8109f98f24843b28b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/39aa6928.failed

Colin Ian King says:
 Static analysis with CoverityScan found a potential issue [..]
 It seems that pointer pol is set to NULL and then a check to see if it
 is non-null is used to set pol to tmp; howeverm this check is always
 going to be false because pol is always NULL.

Fix this and update test script to catch this.  Updated script only:
./xfrm_policy.sh ; echo $?
RTNETLINK answers: No such file or directory
FAIL: ip -net ns3 xfrm policy get src 10.0.1.0/24 dst 10.0.2.0/24 dir out
RTNETLINK answers: No such file or directory
[..]
PASS: policy before exception matches
PASS: ping to .254 bypassed ipsec tunnel
PASS: direct policy matches
PASS: policy matches
1

Fixes: 6be3b0db6db ("xfrm: policy: add inexact policy search tree infrastructure")
	Reported-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 39aa6928d462d0f4fd809ff8109f98f24843b28b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,ddc3335dd552..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -835,28 -1638,53 +835,74 @@@ struct xfrm_policy *xfrm_policy_bysel_c
  	*err = 0;
  	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
  	chain = policy_hash_bysel(net, sel, sel->family, dir);
++<<<<<<< HEAD
 +	if (!chain)
 +		chain = &net->xfrm.policy_inexact[dir];
 +	ret = NULL;
 +	hlist_for_each_entry(pol, chain, bydst) {
 +		if (pol->type == type &&
 +		    pol->if_id == if_id &&
 +		    (mark & pol->mark.m) == pol->mark.v &&
 +		    !selector_cmp(sel, &pol->selector) &&
 +		    xfrm_sec_ctx_match(ctx, pol->security)) {
 +			xfrm_pol_hold(pol);
 +			if (delete) {
 +				*err = security_xfrm_policy_delete(
 +								pol->security);
 +				if (*err) {
 +					spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
 +					return pol;
 +				}
 +				__xfrm_policy_unlink(pol, dir);
++=======
+ 	if (!chain) {
+ 		struct xfrm_pol_inexact_candidates cand;
+ 		int i;
+ 
+ 		bin = xfrm_policy_inexact_lookup(net, type,
+ 						 sel->family, dir, if_id);
+ 		if (!bin) {
+ 			spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 			return NULL;
+ 		}
+ 
+ 		if (!xfrm_policy_find_inexact_candidates(&cand, bin,
+ 							 &sel->saddr,
+ 							 &sel->daddr)) {
+ 			spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 			return NULL;
+ 		}
+ 
+ 		pol = NULL;
+ 		for (i = 0; i < ARRAY_SIZE(cand.res); i++) {
+ 			struct xfrm_policy *tmp;
+ 
+ 			tmp = __xfrm_policy_bysel_ctx(cand.res[i], mark,
+ 						      if_id, type, dir,
+ 						      sel, ctx);
+ 			if (!tmp)
+ 				continue;
+ 
+ 			if (!pol || tmp->pos < pol->pos)
+ 				pol = tmp;
+ 		}
+ 	} else {
+ 		pol = __xfrm_policy_bysel_ctx(chain, mark, if_id, type, dir,
+ 					      sel, ctx);
+ 	}
+ 
+ 	if (pol) {
+ 		xfrm_pol_hold(pol);
+ 		if (delete) {
+ 			*err = security_xfrm_policy_delete(pol->security);
+ 			if (*err) {
+ 				spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 				return pol;
++>>>>>>> 39aa6928d462 (xfrm: policy: fix netlink/pf_key policy lookups)
  			}
 -			__xfrm_policy_unlink(pol, dir);
 +			ret = pol;
 +			break;
  		}
 -		ret = pol;
  	}
  	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
  
* Unmerged path net/xfrm/xfrm_policy.c
diff --git a/tools/testing/selftests/net/xfrm_policy.sh b/tools/testing/selftests/net/xfrm_policy.sh
index 6ca63a6e50e9..8db35b99457c 100755
--- a/tools/testing/selftests/net/xfrm_policy.sh
+++ b/tools/testing/selftests/net/xfrm_policy.sh
@@ -21,6 +21,7 @@
 # Kselftest framework requirement - SKIP code is 4.
 ksft_skip=4
 ret=0
+policy_checks_ok=1
 
 KEY_SHA=0xdeadbeef1234567890abcdefabcdefabcdefabcd
 KEY_AES=0x0123456789abcdef0123456789012345
@@ -45,6 +46,26 @@ do_esp() {
     ip -net $ns xfrm policy add src $rnet dst $lnet dir fwd tmpl src $remote dst $me proto esp mode tunnel priority 100 action allow
 }
 
+do_esp_policy_get_check() {
+    local ns=$1
+    local lnet=$2
+    local rnet=$3
+
+    ip -net $ns xfrm policy get src $lnet dst $rnet dir out > /dev/null
+    if [ $? -ne 0 ] && [ $policy_checks_ok -eq 1 ] ;then
+        policy_checks_ok=0
+        echo "FAIL: ip -net $ns xfrm policy get src $lnet dst $rnet dir out"
+        ret=1
+    fi
+
+    ip -net $ns xfrm policy get src $rnet dst $lnet dir fwd > /dev/null
+    if [ $? -ne 0 ] && [ $policy_checks_ok -eq 1 ] ;then
+        policy_checks_ok=0
+        echo "FAIL: ip -net $ns xfrm policy get src $rnet dst $lnet dir fwd"
+        ret=1
+    fi
+}
+
 do_exception() {
     local ns=$1
     local me=$2
@@ -112,31 +133,31 @@ check_xfrm() {
 	# 1: iptables -m policy rule count != 0
 	rval=$1
 	ip=$2
-	ret=0
+	lret=0
 
 	ip netns exec ns1 ping -q -c 1 10.0.2.$ip > /dev/null
 
 	check_ipt_policy_count ns3
 	if [ $? -ne $rval ] ; then
-		ret=1
+		lret=1
 	fi
 	check_ipt_policy_count ns4
 	if [ $? -ne $rval ] ; then
-		ret=1
+		lret=1
 	fi
 
 	ip netns exec ns2 ping -q -c 1 10.0.1.$ip > /dev/null
 
 	check_ipt_policy_count ns3
 	if [ $? -ne $rval ] ; then
-		ret=1
+		lret=1
 	fi
 	check_ipt_policy_count ns4
 	if [ $? -ne $rval ] ; then
-		ret=1
+		lret=1
 	fi
 
-	return $ret
+	return $lret
 }
 
 #check for needed privileges
@@ -227,6 +248,11 @@ do_esp ns4 dead:3::10 dead:3::1 dead:2::/64 dead:1::/64 $SPI2 $SPI1
 do_dummies4 ns3
 do_dummies6 ns4
 
+do_esp_policy_get_check ns3 10.0.1.0/24 10.0.2.0/24
+do_esp_policy_get_check ns4 10.0.2.0/24 10.0.1.0/24
+do_esp_policy_get_check ns3 dead:1::/64 dead:2::/64
+do_esp_policy_get_check ns4 dead:2::/64 dead:1::/64
+
 # ping to .254 should use ipsec, exception is not installed.
 check_xfrm 1 254
 if [ $? -ne 0 ]; then
