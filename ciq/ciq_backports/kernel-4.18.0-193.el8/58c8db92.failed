net, sk_msg: Don't check if sock is locked when tearing down psock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] sk_msg: Don't check if sock is locked when tearing down psock (Sabrina Dubroca) [1798179]
Rebuild_FUZZ: 96.06%
commit-author Jakub Sitnicki <jakub@cloudflare.com>
commit 58c8db929db1c1d785a6f5d8f8692e5dbcc35e84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/58c8db92.failed

As John Fastabend reports [0], psock state tear-down can happen on receive
path *after* unlocking the socket, if the only other psock user, that is
sockmap or sockhash, releases its psock reference before tcp_bpf_recvmsg
does so:

 tcp_bpf_recvmsg()
  psock = sk_psock_get(sk)                         <- refcnt 2
  lock_sock(sk);
  ...
                                  sock_map_free()  <- refcnt 1
  release_sock(sk)
  sk_psock_put()                                   <- refcnt 0

Remove the lockdep check for socket lock in psock tear-down that got
introduced in 7e81a3530206 ("bpf: Sockmap, ensure sock lock held during
tear down").

[0] https://lore.kernel.org/netdev/5e25dc995d7d_74082aaee6e465b441@john-XPS-13-9370.notmuch/

Fixes: 7e81a3530206 ("bpf: Sockmap, ensure sock lock held during tear down")
	Reported-by: syzbot+d73682fcf7fee6982fe3@syzkaller.appspotmail.com
	Suggested-by: John Fastabend <john.fastabend@gmail.com>
	Signed-off-by: Jakub Sitnicki <jakub@cloudflare.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 58c8db929db1c1d785a6f5d8f8692e5dbcc35e84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skmsg.c
diff --cc net/core/skmsg.c
index 13cb7d01b955,ded2d5227678..000000000000
--- a/net/core/skmsg.c
+++ b/net/core/skmsg.c
@@@ -595,12 -594,12 +595,15 @@@ EXPORT_SYMBOL_GPL(sk_psock_destroy)
  
  void sk_psock_drop(struct sock *sk, struct sk_psock *psock)
  {
++<<<<<<< HEAD
 +	rcu_assign_sk_user_data(sk, NULL);
++=======
++>>>>>>> 58c8db929db1 (net, sk_msg: Don't check if sock is locked when tearing down psock)
  	sk_psock_cork_free(psock);
  	sk_psock_zap_ingress(psock);
 +	sk_psock_restore_proto(sk, psock);
  
  	write_lock_bh(&sk->sk_callback_lock);
 -	sk_psock_restore_proto(sk, psock);
 -	rcu_assign_sk_user_data(sk, NULL);
  	if (psock->progs.skb_parser)
  		sk_psock_stop_strp(sk, psock);
  	write_unlock_bh(&sk->sk_callback_lock);
* Unmerged path net/core/skmsg.c
