net/mlx5: Add stub for mlx5_eswitch_mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [kernel] mlx5: Add stub for mlx5_eswitch_mode (Alaa Hleihel) [1760284 1724336]
Rebuild_FUZZ: 94.74%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit f813cb506b8c9abc106314e1f95c9f2ebf260988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f813cb50.failed

Return MLX5_ESWITCH_NONE when CONFIG_MLX5_ESWITCH
is not selected.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f813cb506b8c9abc106314e1f95c9f2ebf260988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mlx5/eswitch.h
diff --cc include/linux/mlx5/eswitch.h
index 5c8be6f99f8d,825920d3ca40..000000000000
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@@ -41,28 -49,39 +41,41 @@@ struct mlx5_eswitch_rep 
  	u32		       vlan_refcount;
  };
  
 -void mlx5_eswitch_register_vport_reps(struct mlx5_eswitch *esw,
 -				      const struct mlx5_eswitch_rep_ops *ops,
 -				      u8 rep_type);
 -void mlx5_eswitch_unregister_vport_reps(struct mlx5_eswitch *esw, u8 rep_type);
 +void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
 +				     int vport_index,
 +				     struct mlx5_eswitch_rep_if *rep_if,
 +				     u8 rep_type);
 +void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 +				       int vport_index,
 +				       u8 rep_type);
  void *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,
 -				 u16 vport_num,
 +				 int vport,
  				 u8 rep_type);
  struct mlx5_eswitch_rep *mlx5_eswitch_vport_rep(struct mlx5_eswitch *esw,
 -						u16 vport_num);
 +						int vport);
  void *mlx5_eswitch_uplink_get_proto_dev(struct mlx5_eswitch *esw, u8 rep_type);
- u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw);
  struct mlx5_flow_handle *
  mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *esw,
 -				    u16 vport_num, u32 sqn);
 -
 -u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev);
 +				    int vport, u32 sqn);
  
  #ifdef CONFIG_MLX5_ESWITCH
  enum devlink_eswitch_encap_mode
  mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev);
++<<<<<<< HEAD
++=======
+ 
+ bool mlx5_eswitch_vport_match_metadata_enabled(const struct mlx5_eswitch *esw);
+ u32 mlx5_eswitch_get_vport_metadata_for_match(const struct mlx5_eswitch *esw,
+ 					      u16 vport_num);
+ u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw);
++>>>>>>> f813cb506b8c (net/mlx5: Add stub for mlx5_eswitch_mode)
  #else  /* CONFIG_MLX5_ESWITCH */
+ 
+ static inline u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw)
+ {
+ 	return MLX5_ESWITCH_NONE;
+ }
+ 
  static inline enum devlink_eswitch_encap_mode
  mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev)
  {
* Unmerged path include/linux/mlx5/eswitch.h
