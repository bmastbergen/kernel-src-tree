x86/tsc: Consolidate init code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [x86] tsc: Consolidate init code (Al Stone) [1739729 1725581]
Rebuild_FUZZ: 92.86%
commit-author Dou Liyang <douly.fnst@cn.fujitsu.com>
commit 608008a45798fe9e2aee04f99b5270ea57c1376f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/608008a4.failed

Split out suplicated code from tsc_early_init() and tsc_init() into a
common helper and fixup some comment typos.

[ tglx: Massaged changelog and renamed function ]

	Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Pavel Tatashin <pasha.tatashin@oracle.com>
	Cc: <hpa@zytor.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
Link: https://lkml.kernel.org/r/20180730075421.22830-2-douly.fnst@cn.fujitsu.com

(cherry picked from commit 608008a45798fe9e2aee04f99b5270ea57c1376f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/tsc.c
diff --cc arch/x86/kernel/tsc.c
index fce347ac9fd6,1463468ba9a0..000000000000
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@@ -185,6 -171,39 +185,42 @@@ done
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Initialize cyc2ns for boot cpu
+  */
+ static void __init cyc2ns_init_boot_cpu(void)
+ {
+ 	struct cyc2ns *c2n = this_cpu_ptr(&cyc2ns);
+ 
+ 	seqcount_init(&c2n->seq);
+ 	__set_cyc2ns_scale(tsc_khz, smp_processor_id(), rdtsc());
+ }
+ 
+ /*
+  * Secondary CPUs do not run through tsc_init(), so set up
+  * all the scale factors for all CPUs, assuming the same
+  * speed as the bootup CPU. (cpufreq notifiers will fix this
+  * up if their speed diverges)
+  */
+ static void __init cyc2ns_init_secondary_cpus(void)
+ {
+ 	unsigned int cpu, this_cpu = smp_processor_id();
+ 	struct cyc2ns *c2n = this_cpu_ptr(&cyc2ns);
+ 	struct cyc2ns_data *data = c2n->data;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		if (cpu != this_cpu) {
+ 			seqcount_init(&c2n->seq);
+ 			c2n = per_cpu_ptr(&cyc2ns, cpu);
+ 			c2n->data[0] = data[0];
+ 			c2n->data[1] = data[1];
+ 		}
+ 	}
+ }
+ 
+ /*
++>>>>>>> 608008a45798 (x86/tsc: Consolidate init code)
   * Scheduler clock - returns current time in nanosec units.
   */
  u64 native_sched_clock(void)
@@@ -1414,6 -1436,8 +1458,11 @@@ void __init tsc_early_init(void
  	if (!determine_cpu_tsc_frequencies(true))
  		return;
  	loops_per_jiffy = get_loops_per_jiffy();
++<<<<<<< HEAD
++=======
+ 
+ 	tsc_enable_sched_clock();
++>>>>>>> 608008a45798 (x86/tsc: Consolidate init code)
  }
  
  void __init tsc_init(void)
@@@ -1437,24 -1461,10 +1486,31 @@@
  			setup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);
  			return;
  		}
++<<<<<<< HEAD
 +	}
 +
 +	/* Sanitize TSC ADJUST before cyc2ns gets initialized */
 +	tsc_store_and_check_tsc_adjust(true);
 +
 +	/*
 +	 * Secondary CPUs do not run through tsc_init(), so set up
 +	 * all the scale factors for all CPUs, assuming the same
 +	 * speed as the bootup CPU. (cpufreq notifiers will fix this
 +	 * up if their speed diverges)
 +	 */
 +	cyc = rdtsc();
 +	for_each_possible_cpu(cpu) {
 +		cyc2ns_init(cpu);
 +		set_cyc2ns_scale(tsc_khz, cpu, cyc);
 +	}
 +
 +	static_branch_enable(&__use_tsc);
++=======
+ 		tsc_enable_sched_clock();
+ 	}
+ 
+ 	cyc2ns_init_secondary_cpus();
++>>>>>>> 608008a45798 (x86/tsc: Consolidate init code)
  
  	if (!no_sched_irq_time)
  		enable_sched_clock_irqtime();
* Unmerged path arch/x86/kernel/tsc.c
