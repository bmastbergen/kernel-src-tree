perf augmented_raw_syscalls: Move reading filename to the loop

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 602bce09fb43ca6fc41f1bdcba155b839b5e7f38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/602bce09.failed

Almost there, next step is to copy more than one filename payload.

Probably to read syscall arg structs, etc we'll need just a variation of
this that will decide what to use, if probe_read_str() or plain
probe_read for structs, i.e. fixed size.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Luis Cláudio Gonçalves <lclaudio@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-uf6u0pld6xe4xuo16f04owlz@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 602bce09fb43ca6fc41f1bdcba155b839b5e7f38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/examples/bpf/augmented_raw_syscalls.c
diff --cc tools/perf/examples/bpf/augmented_raw_syscalls.c
index b292e763f3c7,2f822bb51717..000000000000
--- a/tools/perf/examples/bpf/augmented_raw_syscalls.c
+++ b/tools/perf/examples/bpf/augmented_raw_syscalls.c
@@@ -131,8 -92,16 +131,21 @@@ SEC("raw_syscalls:sys_enter"
  int sys_enter(struct syscall_enter_args *args)
  {
  	struct augmented_args_filename *augmented_args;
++<<<<<<< HEAD
 +	unsigned int len = sizeof(*augmented_args);
 +	const void *filename_arg = NULL;
++=======
+ 	/*
+ 	 * We start len, the amount of data that will be in the perf ring
+ 	 * buffer, if this is not filtered out by one of pid_filter__has(),
+ 	 * syscall->enabled, etc, with the non-augmented raw syscall payload,
+ 	 * i.e. sizeof(augmented_args->args).
+ 	 *
+ 	 * We'll add to this as we add augmented syscalls right after that
+ 	 * initial, non-augmented raw_syscalls:sys_enter payload.
+ 	 */
+ 	unsigned int len = sizeof(augmented_args->args);
++>>>>>>> 602bce09fb43 (perf augmented_raw_syscalls: Move reading filename to the loop)
  	struct syscall *syscall;
  	int key = 0;
  
@@@ -189,101 -158,66 +202,147 @@@
  	 * 	 after the ctx memory access to prevent their down stream merging.
  	 */
  	/*
 -	 * For now copy just the first string arg, we need to improve the protocol
 -	 * and have more than one.
 +	 * This table of what args are strings will be provided by userspace,
 +	 * in the syscalls map, i.e. we will already have to do the lookup to
 +	 * see if this specific syscall is filtered, so we can as well get more
 +	 * info about what syscall args are strings or pointers, and how many
 +	 * bytes to copy, per arg, etc.
  	 *
 -	 * Using the unrolled loop is not working, only when we do it manually,
 -	 * check this out later...
 -
 -	u8 arg;
 -#pragma clang loop unroll(full)
 -	for (arg = 0; arg < 6; ++arg) {
 -		if (syscall->string_args_len[arg] != 0) {
 -			filename_len = syscall->string_args_len[arg];
 -			filename_arg = (const void *)args->args[arg];
 +	 * For now hard code it, till we have all the basic mechanisms in place
 +	 * to automate everything and make the kernel part be completely driven
 +	 * by information obtained in userspace for each kernel version and
 +	 * processor architecture, making the kernel part the same no matter what
 +	 * kernel version or processor architecture it runs on.
 +	 */
 +	switch (augmented_args->args.syscall_nr) {
 +	case SYS_ACCT:
 +	case SYS_ADD_KEY:
 +	case SYS_CHDIR:
 +	case SYS_CHMOD:
 +	case SYS_CHOWN:
 +	case SYS_CHROOT:
 +	case SYS_CREAT:
 +	case SYS_DELETE_MODULE:
 +	case SYS_EXECVE:
 +	case SYS_GETXATTR:
 +	case SYS_LCHOWN:
 +	case SYS_LGETXATTR:
 +	case SYS_LINK:
 +	case SYS_LISTXATTR:
 +	case SYS_LLISTXATTR:
 +	case SYS_LREMOVEXATTR:
 +	case SYS_LSETXATTR:
 +	case SYS_LSTAT:
 +	case SYS_MEMFD_CREATE:
 +	case SYS_MKDIR:
 +	case SYS_MKNOD:
 +	case SYS_MQ_OPEN:
 +	case SYS_MQ_UNLINK:
 +	case SYS_PIVOT_ROOT:
 +	case SYS_READLINK:
 +	case SYS_REMOVEXATTR:
 +	case SYS_RENAME:
 +	case SYS_REQUEST_KEY:
 +	case SYS_RMDIR:
 +	case SYS_SETXATTR:
 +	case SYS_STAT:
 +	case SYS_STATFS:
 +	case SYS_SWAPOFF:
 +	case SYS_SWAPON:
 +	case SYS_SYMLINK:
 +	case SYS_SYMLINKAT:
 +	case SYS_TRUNCATE:
 +	case SYS_UNLINK:
 +	case SYS_ACCESS:
 +	case SYS_OPEN:	 filename_arg = (const void *)args->args[0];
  			__asm__ __volatile__("": : :"memory");
 -			break;
 -		}
 +			 break;
 +	case SYS_EXECVEAT:
 +	case SYS_FACCESSAT:
 +	case SYS_FCHMODAT:
 +	case SYS_FCHOWNAT:
 +	case SYS_FGETXATTR:
 +	case SYS_FINIT_MODULE:
 +	case SYS_FREMOVEXATTR:
 +	case SYS_FSETXATTR:
 +	case SYS_FUTIMESAT:
 +	case SYS_INOTIFY_ADD_WATCH:
 +	case SYS_LINKAT:
 +	case SYS_MKDIRAT:
 +	case SYS_MKNODAT:
 +	case SYS_MQ_TIMEDSEND:
 +	case SYS_NAME_TO_HANDLE_AT:
 +	case SYS_NEWFSTATAT:
 +	case SYS_PWRITE64:
 +	case SYS_QUOTACTL:
 +	case SYS_READLINKAT:
 +	case SYS_RENAMEAT:
 +	case SYS_RENAMEAT2:
 +	case SYS_STATX:
 +	case SYS_UNLINKAT:
 +	case SYS_UTIMENSAT:
 +	case SYS_OPENAT: filename_arg = (const void *)args->args[1];
 +			 break;
  	}
  
++<<<<<<< HEAD
 +	if (filename_arg != NULL) {
 +		augmented_args->filename.reserved = 0;
 +		augmented_args->filename.size = probe_read_str(&augmented_args->filename.value,
 +							      sizeof(augmented_args->filename.value),
 +							      filename_arg);
 +		if (augmented_args->filename.size < sizeof(augmented_args->filename.value)) {
 +			len -= sizeof(augmented_args->filename.value) - augmented_args->filename.size;
 +			len &= sizeof(augmented_args->filename.value) - 1;
 +		}
 +	} else {
 +		len = sizeof(augmented_args->args);
 +	}
++=======
+ 	verifier log:
+ 
+ ; if (syscall->string_args_len[arg] != 0) {
+ 37: (69) r3 = *(u16 *)(r0 +2)
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1_w=inv0 R2_w=map_value(id=0,off=2,ks=4,vs=14,imm=0) R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ ; if (syscall->string_args_len[arg] != 0) {
+ 38: (55) if r3 != 0x0 goto pc+5
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1=inv0 R2=map_value(id=0,off=2,ks=4,vs=14,imm=0) R3=inv0 R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ 39: (b7) r1 = 1
+ ; if (syscall->string_args_len[arg] != 0) {
+ 40: (bf) r2 = r0
+ 41: (07) r2 += 4
+ 42: (69) r3 = *(u16 *)(r0 +4)
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1_w=inv1 R2_w=map_value(id=0,off=4,ks=4,vs=14,imm=0) R3_w=inv0 R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ ; if (syscall->string_args_len[arg] != 0) {
+ 43: (15) if r3 == 0x0 goto pc+32
+  R0=map_value(id=0,off=0,ks=4,vs=14,imm=0) R1=inv1 R2=map_value(id=0,off=4,ks=4,vs=14,imm=0) R3=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff)) R6=ctx(id=0,off=0,imm=0) R7=map_value(id=0,off=0,ks=4,vs=4168,imm=0) R10=fp0,call_-1 fp-8=mmmmmmmm
+ ; filename_arg = (const void *)args->args[arg];
+ 44: (67) r1 <<= 3
+ 45: (bf) r3 = r6
+ 46: (0f) r3 += r1
+ 47: (b7) r5 = 64
+ 48: (79) r3 = *(u64 *)(r3 +16)
+ dereference of modified ctx ptr R3 off=8 disallowed
+ processed 46 insns (limit 1000000) max_states_per_insn 0 total_states 12 peak_states 12 mark_read 7
+ 	*/
+ 
+ #define __loop_iter(arg) \
+ 	if (syscall->string_args_len[arg] != 0) { \
+ 		unsigned int filename_len = syscall->string_args_len[arg]; \
+ 		const void *filename_arg = (const void *)args->args[arg]; \
+ 		if (filename_len <= sizeof(augmented_args->filename.value)) \
+ 			len += augmented_filename__read(&augmented_args->filename, filename_arg, filename_len);
+ #define loop_iter_first() __loop_iter(0); }
+ #define loop_iter(arg) else __loop_iter(arg); }
+ #define loop_iter_last(arg) else __loop_iter(arg); __asm__ __volatile__("": : :"memory"); }
+ 
+ 	loop_iter_first()
+ 	loop_iter(1)
+ 	loop_iter(2)
+ 	loop_iter(3)
+ 	loop_iter(4)
+ 	loop_iter_last(5)
++>>>>>>> 602bce09fb43 (perf augmented_raw_syscalls: Move reading filename to the loop)
  
  	/* If perf_event_output fails, return non-zero so that it gets recorded unaugmented */
  	return perf_event_output(args, &__augmented_syscalls__, BPF_F_CURRENT_CPU, augmented_args, len);
* Unmerged path tools/perf/examples/bpf/augmented_raw_syscalls.c
