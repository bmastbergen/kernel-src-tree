udp: correct reuseport selection with connected sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Willem de Bruijn <willemb@google.com>
commit acdcecc61285faed359f1a3568c32089cc3a8329
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/acdcecc6.failed

UDP reuseport groups can hold a mix unconnected and connected sockets.
Ensure that connections only receive all traffic to their 4-tuple.

Fast reuseport returns on the first reuseport match on the assumption
that all matches are equal. Only if connections are present, return to
the previous behavior of scoring all sockets.

Record if connections are present and if so (1) treat such connected
sockets as an independent match from the group, (2) only return
2-tuple matches from reuseport and (3) do not return on the first
2-tuple reuseport match to allow for a higher scoring match later.

New field has_conns is set without locks. No other fields in the
bitmap are modified at runtime and the field is only ever set
unconditionally, so an RMW cannot miss a change.

Fixes: e32ea7e74727 ("soreuseport: fast reuseport UDP socket selection")
Link: http://lkml.kernel.org/r/CA+FuTSfRP09aJNYRt04SS6qj22ViiOEWaWmLAwX0psk8-PGNxw@mail.gmail.com
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: Craig Gallek <kraig@google.com>
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit acdcecc61285faed359f1a3568c32089cc3a8329)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock_reuseport.h
diff --cc include/net/sock_reuseport.h
index b0ff88240049,43f4a818d88f..000000000000
--- a/include/net/sock_reuseport.h
+++ b/include/net/sock_reuseport.h
@@@ -15,9 -15,14 +15,10 @@@ struct sock_reuseport 
  
  	u16			max_socks;	/* length of socks */
  	u16			num_socks;	/* elements in socks */
 -	/* The last synq overflow event timestamp of this
 -	 * reuse->socks[] group.
 -	 */
 -	unsigned int		synq_overflow_ts;
  	/* ID stays the same even after the size of socks[] grows. */
  	unsigned int		reuseport_id;
- 	bool			bind_inany;
+ 	unsigned int		bind_inany:1;
+ 	unsigned int		has_conns:1;
  	struct bpf_prog __rcu	*prog;		/* optional BPF sock selector */
  	struct sock		*socks[0];	/* array of sock pointers */
  };
@@@ -31,6 -36,25 +32,28 @@@ extern struct sock *reuseport_select_so
  					  struct sk_buff *skb,
  					  int hdr_len);
  extern int reuseport_attach_prog(struct sock *sk, struct bpf_prog *prog);
++<<<<<<< HEAD
++=======
+ extern int reuseport_detach_prog(struct sock *sk);
+ 
+ static inline bool reuseport_has_conns(struct sock *sk, bool set)
+ {
+ 	struct sock_reuseport *reuse;
+ 	bool ret = false;
+ 
+ 	rcu_read_lock();
+ 	reuse = rcu_dereference(sk->sk_reuseport_cb);
+ 	if (reuse) {
+ 		if (set)
+ 			reuse->has_conns = 1;
+ 		ret = reuse->has_conns;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> acdcecc61285 (udp: correct reuseport selection with connected sockets)
  int reuseport_get_id(struct sock_reuseport *reuse);
  
  #endif  /* _SOCK_REUSEPORT_H */
* Unmerged path include/net/sock_reuseport.h
diff --git a/net/core/sock_reuseport.c b/net/core/sock_reuseport.c
index 14feb61fcdff..8b4c1c3323b2 100644
--- a/net/core/sock_reuseport.c
+++ b/net/core/sock_reuseport.c
@@ -294,8 +294,19 @@ struct sock *reuseport_select_sock(struct sock *sk,
 
 select_by_hash:
 		/* no bpf or invalid bpf result: fall back to hash usage */
-		if (!sk2)
-			sk2 = reuse->socks[reciprocal_scale(hash, socks)];
+		if (!sk2) {
+			int i, j;
+
+			i = j = reciprocal_scale(hash, socks);
+			while (reuse->socks[i]->sk_state == TCP_ESTABLISHED) {
+				i++;
+				if (i >= reuse->num_socks)
+					i = 0;
+				if (i == j)
+					goto out;
+			}
+			sk2 = reuse->socks[i];
+		}
 	}
 
 out:
diff --git a/net/ipv4/datagram.c b/net/ipv4/datagram.c
index f915abff1350..80107a6a2c4a 100644
--- a/net/ipv4/datagram.c
+++ b/net/ipv4/datagram.c
@@ -19,6 +19,7 @@
 #include <net/sock.h>
 #include <net/route.h>
 #include <net/tcp_states.h>
+#include <net/sock_reuseport.h>
 
 int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
@@ -73,6 +74,7 @@ int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len
 	}
 	inet->inet_daddr = fl4->daddr;
 	inet->inet_dport = usin->sin_port;
+	reuseport_has_conns(sk, true);
 	sk->sk_state = TCP_ESTABLISHED;
 	sk_set_txhash(sk);
 	inet->inet_id = jiffies;
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index d4fd2851b9ad..87cb6542c177 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -440,12 +440,13 @@ static struct sock *udp4_lib_lookup2(struct net *net,
 		score = compute_score(sk, net, saddr, sport,
 				      daddr, hnum, dif, sdif, exact_dif);
 		if (score > badness) {
-			if (sk->sk_reuseport) {
+			if (sk->sk_reuseport &&
+			    sk->sk_state != TCP_ESTABLISHED) {
 				hash = udp_ehashfn(net, daddr, hnum,
 						   saddr, sport);
 				result = reuseport_select_sock(sk, hash, skb,
 							sizeof(struct udphdr));
-				if (result)
+				if (result && !reuseport_has_conns(sk, false))
 					return result;
 			}
 			badness = score;
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 567cf8c3d4f5..53b5fce6bbf1 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -31,6 +31,7 @@
 #include <net/ip6_route.h>
 #include <net/tcp_states.h>
 #include <net/dsfield.h>
+#include <net/sock_reuseport.h>
 
 #include <linux/errqueue.h>
 #include <linux/uaccess.h>
@@ -258,6 +259,7 @@ int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr,
 		goto out;
 	}
 
+	reuseport_has_conns(sk, true);
 	sk->sk_state = TCP_ESTABLISHED;
 	sk_set_txhash(sk);
 out:
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 02fad46f3617..adc5ee958035 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -175,13 +175,14 @@ static struct sock *udp6_lib_lookup2(struct net *net,
 		score = compute_score(sk, net, saddr, sport,
 				      daddr, hnum, dif, sdif, exact_dif);
 		if (score > badness) {
-			if (sk->sk_reuseport) {
+			if (sk->sk_reuseport &&
+			    sk->sk_state != TCP_ESTABLISHED) {
 				hash = udp6_ehashfn(net, daddr, hnum,
 						    saddr, sport);
 
 				result = reuseport_select_sock(sk, hash, skb,
 							sizeof(struct udphdr));
-				if (result)
+				if (result && !reuseport_has_conns(sk, false))
 					return result;
 			}
 			result = sk;
