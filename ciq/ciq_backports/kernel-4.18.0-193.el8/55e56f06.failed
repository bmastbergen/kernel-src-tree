dax: Don't access a freed inode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Matthew Wilcox <willy@infradead.org>
commit 55e56f06ed71d9441f3abd5b1d3c1a870812b3fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/55e56f06.failed

After we drop the i_pages lock, the inode can be freed at any time.
The get_unlocked_entry() code has no choice but to reacquire the lock,
so it can't be used here.  Create a new wait_entry_unlocked() which takes
care not to acquire the lock or dereference the address_space in any way.

Fixes: c2a7d2a11552 ("filesystem-dax: Introduce dax_lock_mapping_entry()")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Matthew Wilcox <willy@infradead.org>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 55e56f06ed71d9441f3abd5b1d3c1a870812b3fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index b89ab8b5e700,3f592dc18d67..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -524,32 -403,26 +552,41 @@@ bool dax_lock_mapping_entry(struct pag
  		 * otherwise we would not have a valid pfn_to_page()
  		 * translation.
  		 */
 -		locked = true;
 -		if (S_ISCHR(mapping->host->i_mode))
 +		inode = mapping->host;
 +		if (S_ISCHR(inode->i_mode)) {
 +			did_lock = true;
  			break;
 +		}
  
 -		xas.xa = &mapping->i_pages;
 -		xas_lock_irq(&xas);
 +		xa_lock_irq(&mapping->i_pages);
  		if (mapping != page->mapping) {
 -			xas_unlock_irq(&xas);
 +			xa_unlock_irq(&mapping->i_pages);
  			continue;
  		}
++<<<<<<< HEAD
 +		index = page->index;
 +
 +		entry = __get_unlocked_mapping_entry(mapping, index, &slot,
 +				entry_wait_revalidate);
 +		if (!entry) {
 +			xa_unlock_irq(&mapping->i_pages);
 +			break;
 +		} else if (IS_ERR(entry)) {
 +			xa_unlock_irq(&mapping->i_pages);
 +			WARN_ON_ONCE(PTR_ERR(entry) != -EAGAIN);
++=======
+ 		xas_set(&xas, page->index);
+ 		entry = xas_load(&xas);
+ 		if (dax_is_locked(entry)) {
+ 			rcu_read_unlock();
+ 			wait_entry_unlocked(&xas, entry);
+ 			rcu_read_lock();
++>>>>>>> 55e56f06ed71 (dax: Don't access a freed inode)
  			continue;
  		}
 -		dax_lock_entry(&xas, entry);
 -		xas_unlock_irq(&xas);
 +		lock_slot(mapping, slot);
 +		did_lock = true;
 +		xa_unlock_irq(&mapping->i_pages);
  		break;
  	}
  	rcu_read_unlock();
* Unmerged path fs/dax.c
