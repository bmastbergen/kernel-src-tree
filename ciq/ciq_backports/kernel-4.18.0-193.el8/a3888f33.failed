net/mlx5: E-Switch, Load/unload VF reps according to event from host PF

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Load/unload VF reps according to event from host PF (Alaa Hleihel) [1724333]
Rebuild_FUZZ: 97.10%
commit-author Bodong Wang <bodong@mellanox.com>
commit a3888f33db9f55f401ad315481af251d168e57dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a3888f33.failed

When host PF changes the number of VFs, the ECPF esw driver will get
a FW event. It should query the number of VFs enabled by host PF and
update the VF reps accordingly. Note that host PF can't change the
number of VFs dynamically, it has to reset the number of VFs to 0
before changing to a new positive number.

The host event is registered when driver is moving to switchdev mode,
and it's the last step to do in esw_offloads_init. It's unregistered
and the work queue is flushed when driver quits from switchdev mode.
In this way, the host event and devlink command are serialized.

When driver is enabling switchdev mode, pay attention to the following
two facts:
1. Host PF must not have VF initialized as the flow table in ECPF has
   ENCAP enabled as default. Such flow table can't be created with
   existing initialized VFs.
2. ECPF doesn't know how many VFs the host PF will enable, ECPF
   offloads flow steering shall create the flow table/groups based on
   the max number of VFs possibly supported by host PF.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a3888f33db9f55f401ad315481af251d168e57dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index c2e828153dd7,e18af31336e6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -39,9 -39,8 +39,10 @@@
  #include "lib/eq.h"
  #include "eswitch.h"
  #include "fs_core.h"
+ #include "ecpf.h"
  
 +#define UPLINK_VPORT 0xFFFF
 +
  enum {
  	MLX5_ACTION_NONE = 0,
  	MLX5_ACTION_ADD  = 1,
@@@ -1605,6 -1640,8 +1606,11 @@@ static int eswitch_vport_event(struct n
  
  int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
  {
++<<<<<<< HEAD
++=======
+ 	int vf_nvports = 0, total_nvports = 0;
+ 	struct mlx5_vport *vport;
++>>>>>>> a3888f33db9f (net/mlx5: E-Switch, Load/unload VF reps according to event from host PF)
  	int err;
  	int i, enabled_events;
  
@@@ -1631,7 -1680,7 +1649,11 @@@
  	} else {
  		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_ETH);
  		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
++<<<<<<< HEAD
 +		err = esw_offloads_init(esw, nvfs + MLX5_SPECIAL_VPORTS);
++=======
+ 		err = esw_offloads_init(esw, vf_nvports, total_nvports);
++>>>>>>> a3888f33db9f (net/mlx5: E-Switch, Load/unload VF reps according to event from host PF)
  	}
  
  	if (err)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 6a7d5023272b,af5581a57e56..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -206,10 -215,13 +216,15 @@@ struct mlx5_eswitch 
  	struct mlx5_esw_offload offloads;
  	int                     mode;
  	int                     nvports;
++<<<<<<< HEAD
++=======
+ 	u16                     manager_vport;
+ 	struct mlx5_host_info	host_info;
++>>>>>>> a3888f33db9f (net/mlx5: E-Switch, Load/unload VF reps according to event from host PF)
  };
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw);
 -int esw_offloads_init(struct mlx5_eswitch *esw, int vf_nvports,
 -		      int total_nvports);
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports);
 +int esw_offloads_init(struct mlx5_eswitch *esw, int nvports);
  void esw_offloads_cleanup_reps(struct mlx5_eswitch *esw);
  int esw_offloads_init_reps(struct mlx5_eswitch *esw);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a13e7b20a794,91c4095ac79e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1437,7 -1642,59 +1439,63 @@@ static void esw_offloads_steering_clean
  	esw_destroy_offloads_fdb_tables(esw);
  }
  
++<<<<<<< HEAD
 +int esw_offloads_init(struct mlx5_eswitch *esw, int nvports)
++=======
+ static void esw_host_params_event_handler(struct work_struct *work)
+ {
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 	int err, num_vf = 0;
+ 
+ 	host_work = container_of(work, struct mlx5_host_work, work);
+ 	esw = host_work->esw;
+ 
+ 	err = mlx5_query_host_params_num_vfs(esw->dev, &num_vf);
+ 	if (err || num_vf == esw->host_info.num_vfs)
+ 		goto out;
+ 
+ 	/* Number of VFs can only change from "0 to x" or "x to 0". */
+ 	if (esw->host_info.num_vfs > 0) {
+ 		esw_offloads_unload_vf_reps(esw, esw->host_info.num_vfs);
+ 	} else {
+ 		err = esw_offloads_load_vf_reps(esw, num_vf);
+ 
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	esw->host_info.num_vfs = num_vf;
+ 
+ out:
+ 	kfree(host_work);
+ }
+ 
+ static int esw_host_params_event(struct notifier_block *nb,
+ 				 unsigned long type, void *data)
+ {
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_host_info *host_info;
+ 	struct mlx5_eswitch *esw;
+ 
+ 	host_work = kzalloc(sizeof(*host_work), GFP_ATOMIC);
+ 	if (!host_work)
+ 		return NOTIFY_DONE;
+ 
+ 	host_info = mlx5_nb_cof(nb, struct mlx5_host_info, nb);
+ 	esw = container_of(host_info, struct mlx5_eswitch, host_info);
+ 
+ 	host_work->esw = esw;
+ 
+ 	INIT_WORK(&host_work->work, esw_host_params_event_handler);
+ 	queue_work(esw->work_queue, &host_work->work);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ int esw_offloads_init(struct mlx5_eswitch *esw, int vf_nvports,
+ 		      int total_nvports)
++>>>>>>> a3888f33db9f (net/mlx5: E-Switch, Load/unload VF reps according to event from host PF)
  {
  	int err;
  
@@@ -1478,10 -1743,20 +1544,23 @@@ static int esw_offloads_stop(struct mlx
  	return err;
  }
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw)
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
  {
++<<<<<<< HEAD
++=======
+ 	u16 num_vfs;
+ 
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		mlx5_eq_notifier_unregister(esw->dev, &esw->host_info.nb);
+ 		flush_workqueue(esw->work_queue);
+ 		num_vfs = esw->host_info.num_vfs;
+ 	} else {
+ 		num_vfs = esw->dev->priv.sriov.num_vfs;
+ 	}
+ 
++>>>>>>> a3888f33db9f (net/mlx5: E-Switch, Load/unload VF reps according to event from host PF)
  	esw_offloads_devcom_cleanup(esw);
 -	esw_offloads_unload_all_reps(esw, num_vfs);
 +	esw_offloads_unload_reps(esw, nvports);
  	esw_offloads_steering_cleanup(esw);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
