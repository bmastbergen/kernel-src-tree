RDMA/nldev: Don't expose number of not-visible entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit f2a0e45f36b0a210ff2388ed5fa89f81019c07a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f2a0e45f.failed

Netlink dumpit handshake exchanges the index from which kernel should
start to return its value, in current code, this index included
not-visible in this PID items too and indirectly revealed the number of
entries.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f2a0e45f36b0a210ff2388ed5fa89f81019c07a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
diff --cc drivers/infiniband/core/nldev.c
index efccd8e0fb77,e7350d9d60e9..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -1011,46 -1115,49 +1011,61 @@@ static int res_get_common_dumpit(struc
  
  	has_cap_net_admin = netlink_capable(cb->skb, CAP_NET_ADMIN);
  
++<<<<<<< HEAD
 +	down_read(&device->res.rwsem);
 +	hash_for_each_possible(device->res.hash, res, node, res_type) {
 +		if (idx < start)
 +			goto next;
 +
++=======
+ 	rt = &device->res[res_type];
+ 	xa_lock(&rt->xa);
+ 	/*
+ 	 * FIXME: if the skip ahead is something common this loop should
+ 	 * use xas_for_each & xas_pause to optimize, we can have a lot of
+ 	 * objects.
+ 	 */
+ 	xa_for_each(&rt->xa, id, res) {
++>>>>>>> f2a0e45f36b0 (RDMA/nldev: Don't expose number of not-visible entries)
  		if (!is_visible_in_pid_ns(res))
- 			goto next;
+ 			continue;
  
++<<<<<<< HEAD
 +		if (!rdma_restrack_get(res))
 +			/*
 +			 * Resource is under release now, but we are not
 +			 * relesing lock now, so it will be released in
 +			 * our next pass, once we will get ->next pointer.
 +			 */
++=======
+ 		if (idx < start || !rdma_restrack_get(res))
++>>>>>>> f2a0e45f36b0 (RDMA/nldev: Don't expose number of not-visible entries)
  			goto next;
  
 -		xa_unlock(&rt->xa);
 -
  		filled = true;
  
 -		entry_attr = nla_nest_start(skb, fe->entry);
 -		if (!entry_attr) {
 -			ret = -EMSGSIZE;
 -			rdma_restrack_put(res);
 -			goto msg_full;
 -		}
 -
 +		up_read(&device->res.rwsem);
  		ret = fe->fill_res_func(skb, has_cap_net_admin, res, port);
 +		down_read(&device->res.rwsem);
 +		/*
 +		 * Return resource back, but it won't be released till
 +		 * the &device->res.rwsem will be released for write.
 +		 */
  		rdma_restrack_put(res);
  
 -		if (ret) {
 -			nla_nest_cancel(skb, entry_attr);
 -			if (ret == -EMSGSIZE)
 -				goto msg_full;
 -			if (ret == -EAGAIN)
 -				goto again;
 +		if (ret == -EMSGSIZE)
 +			/*
 +			 * There is a chance to optimize here.
 +			 * It can be done by using list_prepare_entry
 +			 * and list_for_each_entry_continue afterwards.
 +			 */
 +			break;
 +		if (ret)
  			goto res_err;
 -		}
 -		nla_nest_end(skb, entry_attr);
 -again:		xa_lock(&rt->xa);
  next:		idx++;
  	}
 -	xa_unlock(&rt->xa);
 +	up_read(&device->res.rwsem);
  
 -msg_full:
  	nla_nest_end(skb, table_attr);
  	nlmsg_end(skb, nlh);
  	cb->args[0] = idx;
* Unmerged path drivers/infiniband/core/nldev.c
