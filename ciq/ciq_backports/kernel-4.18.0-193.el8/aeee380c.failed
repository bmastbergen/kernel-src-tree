selftests/bpf: fix tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit aeee380ccfc59c05a4c6e8e762fd645c6bdc773a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/aeee380c.failed

Fix tests that assumed no loops.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit aeee380ccfc59c05a4c6e8e762fd645c6bdc773a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_verifier.c
#	tools/testing/selftests/bpf/verifier/calls.c
#	tools/testing/selftests/bpf/verifier/cfg.c
diff --cc tools/testing/selftests/bpf/test_verifier.c
index 96071fae318d,93e1d87a343a..000000000000
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@@ -215,11 -237,11 +215,16 @@@ static void bpf_fill_scale1(struct bpf_
  		insn[i++] = BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_6,
  					-8 * (k % 64 + 1));
  	}
- 	/* every jump adds 1 step to insn_processed, so to stay exactly
- 	 * within 1m limit add MAX_TEST_INSNS - MAX_JMP_SEQ - 1 MOVs and 1 EXIT
+ 	/* is_state_visited() doesn't allocate state for pruning for every jump.
+ 	 * Hence multiply jmps by 4 to accommodate that heuristic
  	 */
++<<<<<<< HEAD
 +	while (i < MAX_TEST_INSNS - MAX_JMP_SEQ - 1)
 +		insn[i++] = BPF_ALU32_IMM(BPF_MOV, BPF_REG_0, 42);
++=======
+ 	while (i < MAX_TEST_INSNS - MAX_JMP_SEQ * 4)
+ 		insn[i++] = BPF_ALU64_IMM(BPF_MOV, BPF_REG_0, 42);
++>>>>>>> aeee380ccfc5 (selftests/bpf: fix tests)
  	insn[i] = BPF_EXIT_INSN();
  	self->prog_len = i + 1;
  	self->retval = 42;
@@@ -247,11 -269,8 +252,16 @@@ static void bpf_fill_scale2(struct bpf_
  		insn[i++] = BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_6,
  					-8 * (k % (64 - 4 * FUNC_NEST) + 1));
  	}
++<<<<<<< HEAD
 +	/* every jump adds 1 step to insn_processed, so to stay exactly
 +	 * within 1m limit add MAX_TEST_INSNS - MAX_JMP_SEQ - 1 MOVs and 1 EXIT
 +	 */
 +	while (i < MAX_TEST_INSNS - MAX_JMP_SEQ - 1)
 +		insn[i++] = BPF_ALU32_IMM(BPF_MOV, BPF_REG_0, 42);
++=======
+ 	while (i < MAX_TEST_INSNS - MAX_JMP_SEQ * 4)
+ 		insn[i++] = BPF_ALU64_IMM(BPF_MOV, BPF_REG_0, 42);
++>>>>>>> aeee380ccfc5 (selftests/bpf: fix tests)
  	insn[i] = BPF_EXIT_INSN();
  	self->prog_len = i + 1;
  	self->retval = 42;
* Unmerged path tools/testing/selftests/bpf/verifier/calls.c
* Unmerged path tools/testing/selftests/bpf/verifier/cfg.c
* Unmerged path tools/testing/selftests/bpf/test_verifier.c
* Unmerged path tools/testing/selftests/bpf/verifier/calls.c
* Unmerged path tools/testing/selftests/bpf/verifier/cfg.c
