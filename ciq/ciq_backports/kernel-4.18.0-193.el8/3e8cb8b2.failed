fuse: fix stack use after return

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 3e8cb8b2eaeb22f540f1cbc00cbb594047b7ba89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3e8cb8b2.failed

Normal, synchronous requests will have their args allocated on the stack.
After the FR_FINISHED bit is set by receiving the reply from the userspace
fuse server, the originating task may return and reuse the stack frame,
resulting in an Oops if the args structure is dereferenced.

Fix by setting a flag in the request itself upon initializing, indicating
whether it has an asynchronous ->end() callback.

	Reported-by: Kyle Sanderson <kyle.leet@gmail.com>
	Reported-by: Michael Stapelberg <michael+lkml@stapelberg.ch>
Fixes: 2b319d1f6f92 ("fuse: don't dereference req->args on finished request")
	Cc: <stable@vger.kernel.org> # v5.4
	Tested-by: Michael Stapelberg <michael+lkml@stapelberg.ch>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 3e8cb8b2eaeb22f540f1cbc00cbb594047b7ba89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/fuse_i.h
diff --cc fs/fuse/fuse_i.h
index b9287760b32a,ca344bf71404..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -302,7 -315,7 +303,11 @@@ enum fuse_req_flag 
  	FR_SENT,
  	FR_FINISHED,
  	FR_PRIVATE,
++<<<<<<< HEAD
 +	FR_ALLOC_PAGES,
++=======
+ 	FR_ASYNC,
++>>>>>>> 3e8cb8b2eaeb (fuse: fix stack use after return)
  };
  
  /**
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index 95c01fcb2e0a..c0f52ae89fcd 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -337,12 +337,10 @@ static void flush_bg_queue(struct fuse_conn *fc)
 static void request_end(struct fuse_conn *fc, struct fuse_req *req)
 {
 	struct fuse_iqueue *fiq = &fc->iq;
-	bool async;
 
 	if (test_and_set_bit(FR_FINISHED, &req->flags))
 		goto put_request;
 
-	async = req->args->end;
 	/*
 	 * test_and_set_bit() implies smp_mb() between bit
 	 * changing and below intr_entry check. Pairs with
@@ -385,7 +383,7 @@ static void request_end(struct fuse_conn *fc, struct fuse_req *req)
 		wake_up(&req->waitq);
 	}
 
-	if (async)
+	if (test_bit(FR_ASYNC, &req->flags))
 		req->args->end(fc, req->args, req->out.h.error);
 put_request:
 	fuse_put_request(fc, req);
@@ -543,6 +541,8 @@ static void fuse_args_to_req(struct fuse_req *req, struct fuse_args *args)
 	req->in.h.opcode = args->opcode;
 	req->in.h.nodeid = args->nodeid;
 	req->args = args;
+	if (args->end)
+		__set_bit(FR_ASYNC, &req->flags);
 }
 
 ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)
* Unmerged path fs/fuse/fuse_i.h
