net/mlx5: E-Switch, Fix default encap mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Fix default encap mode (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 95.00%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 9a64144d683a4395f57562d90247c61a0bf5105f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9a64144d.failed

Encap mode is related to switchdev mode only. Move the init of
the encap mode to eswitch_offloads. Before this change, we reported
that eswitch supports encap, even tough the device was in non
SRIOV mode.

Fixes: 7768d1971de67 ('net/mlx5: E-Switch, Add control for encapsulation')
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 9a64144d683a4395f57562d90247c61a0bf5105f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,c2beadc41c40..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1607,9 -1840,13 +1607,19 @@@ int esw_offloads_init(struct mlx5_eswit
  {
  	int err;
  
++<<<<<<< HEAD
 +	mutex_init(&esw->fdb_table.offloads.fdb_prio_lock);
 +
 +	err = esw_offloads_steering_init(esw, nvports);
++=======
+ 	if (MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, reformat) &&
+ 	    MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, decap))
+ 		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_BASIC;
+ 	else
+ 		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_NONE;
+ 
+ 	err = esw_offloads_steering_init(esw, vf_nvports, total_nvports);
++>>>>>>> 9a64144d683a (net/mlx5: E-Switch, Fix default encap mode)
  	if (err)
  		return err;
  
@@@ -1644,11 -1891,23 +1654,12 @@@ static int esw_offloads_stop(struct mlx
  	return err;
  }
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw)
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
  {
 -	u16 num_vfs;
 -
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		mlx5_eq_notifier_unregister(esw->dev, &esw->host_info.nb);
 -		flush_workqueue(esw->work_queue);
 -		num_vfs = esw->host_info.num_vfs;
 -	} else {
 -		num_vfs = esw->dev->priv.sriov.num_vfs;
 -	}
 -
 -	mlx5_rdma_disable_roce(esw->dev);
  	esw_offloads_devcom_cleanup(esw);
 -	esw_offloads_unload_all_reps(esw, num_vfs);
 +	esw_offloads_unload_reps(esw, nvports);
  	esw_offloads_steering_cleanup(esw);
+ 	esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_NONE;
  }
  
  static int esw_mode_from_devlink(u16 mode, u16 *mlx5_mode)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index f4a0b22e3987..a435226c0e6b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1856,11 +1856,6 @@ int mlx5_eswitch_init(struct mlx5_core_dev *dev)
 	esw->enabled_vports = 0;
 	esw->mode = SRIOV_NONE;
 	esw->offloads.inline_mode = MLX5_INLINE_MODE_NONE;
-	if (MLX5_CAP_ESW_FLOWTABLE_FDB(dev, reformat) &&
-	    MLX5_CAP_ESW_FLOWTABLE_FDB(dev, decap))
-		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_BASIC;
-	else
-		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_NONE;
 
 	dev->priv.eswitch = esw;
 	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
