SUNRPC: Respect RPC call timeouts when retrying transmission

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 7b3fef8e4157ed424bcde039a60a730aa0dfb0eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7b3fef8e.failed

Fix a regression where soft and softconn requests are not timing out
as expected.

Fixes: 89f90fe1ad8b ("SUNRPC: Allow calls to xprt_transmit() to drain...")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 7b3fef8e4157ed424bcde039a60a730aa0dfb0eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 53c6c503223a,311029b7c33a..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -76,9 -74,12 +76,10 @@@ static void	call_timeout(struct rpc_tas
  static void	call_connect(struct rpc_task *task);
  static void	call_connect_status(struct rpc_task *task);
  
 -static int	rpc_encode_header(struct rpc_task *task,
 -				  struct xdr_stream *xdr);
 -static int	rpc_decode_header(struct rpc_task *task,
 -				  struct xdr_stream *xdr);
 +static __be32	*rpc_encode_header(struct rpc_task *task);
 +static __be32	*rpc_verify_header(struct rpc_task *task);
  static int	rpc_ping(struct rpc_clnt *clnt);
+ static void	rpc_check_timeout(struct rpc_task *task);
  
  static void rpc_register_client(struct rpc_clnt *clnt)
  {
@@@ -1932,11 -1981,10 +1932,9 @@@ call_connect_status(struct rpc_task *ta
  		/* retry with existing socket, after a delay */
  		rpc_delay(task, 3*HZ);
  		/* fall through */
 -	case -ENOTCONN:
  	case -EAGAIN:
- 		/* Check for timeouts before looping back to call_bind */
  	case -ETIMEDOUT:
- 		task->tk_action = call_timeout;
- 		return;
+ 		goto out_retry;
  	case 0:
  		clnt->cl_stats->netreconn++;
  		task->tk_action = call_transmit;
@@@ -2048,8 -2080,11 +2051,9 @@@ call_transmit_status(struct rpc_task *t
  	case -EADDRINUSE:
  	case -ENOTCONN:
  	case -EPIPE:
 -		task->tk_action = call_bind;
 -		task->tk_status = 0;
  		break;
  	}
+ 	rpc_check_timeout(task);
  }
  
  #if defined(CONFIG_SUNRPC_BACKCHANNEL)
@@@ -2183,7 -2221,7 +2187,11 @@@ call_status(struct rpc_task *task
  	case -EPIPE:
  	case -ENOTCONN:
  	case -EAGAIN:
++<<<<<<< HEAD
 +		task->tk_action = call_bind;
++=======
+ 		task->tk_action = call_timeout;
++>>>>>>> 7b3fef8e4157 (SUNRPC: Respect RPC call timeouts when retrying transmission)
  		break;
  	case -EIO:
  		/* shutdown or soft timeout */
@@@ -2246,10 -2277,19 +2247,24 @@@ rpc_check_timeout(struct rpc_task *task
  	 * event? RFC2203 requires the server to drop all such requests.
  	 */
  	rpcauth_invalcred(task);
+ }
  
++<<<<<<< HEAD
 +retry:
 +	task->tk_action = call_bind;
++=======
+ /*
+  * 6a.	Handle RPC timeout
+  * 	We do not release the request slot, so we keep using the
+  *	same XID for all retransmits.
+  */
+ static void
+ call_timeout(struct rpc_task *task)
+ {
+ 	task->tk_action = call_encode;
++>>>>>>> 7b3fef8e4157 (SUNRPC: Respect RPC call timeouts when retrying transmission)
  	task->tk_status = 0;
+ 	rpc_check_timeout(task);
  }
  
  /*
* Unmerged path net/sunrpc/clnt.c
