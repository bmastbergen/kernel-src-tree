stacktrace: Use PF_KTHREAD to check for kernel threads

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 7e8e6816c6495a1168f9a7a50125d82c23e59300
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7e8e6816.failed

!current->mm is not a reliable indicator for kernel threads as they might
temporarily use a user mm. Check for PF_KTHREAD instead.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Mark Rutland <mark.rutland@arm.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1907021750100.1802@nanos.tec.linutronix.de

(cherry picked from commit 7e8e6816c6495a1168f9a7a50125d82c23e59300)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/stacktrace.c
diff --cc kernel/stacktrace.c
index f8edee9c792d,c8d0f05721a1..000000000000
--- a/kernel/stacktrace.c
+++ b/kernel/stacktrace.c
@@@ -51,7 -67,176 +51,180 @@@ int snprint_stack_trace(char *buf, size
  
  	return total;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(snprint_stack_trace);
++=======
+ EXPORT_SYMBOL_GPL(stack_trace_snprint);
+ 
+ #ifdef CONFIG_ARCH_STACKWALK
+ 
+ struct stacktrace_cookie {
+ 	unsigned long	*store;
+ 	unsigned int	size;
+ 	unsigned int	skip;
+ 	unsigned int	len;
+ };
+ 
+ static bool stack_trace_consume_entry(void *cookie, unsigned long addr,
+ 				      bool reliable)
+ {
+ 	struct stacktrace_cookie *c = cookie;
+ 
+ 	if (c->len >= c->size)
+ 		return false;
+ 
+ 	if (c->skip > 0) {
+ 		c->skip--;
+ 		return true;
+ 	}
+ 	c->store[c->len++] = addr;
+ 	return c->len < c->size;
+ }
+ 
+ static bool stack_trace_consume_entry_nosched(void *cookie, unsigned long addr,
+ 					      bool reliable)
+ {
+ 	if (in_sched_functions(addr))
+ 		return true;
+ 	return stack_trace_consume_entry(cookie, addr, reliable);
+ }
+ 
+ /**
+  * stack_trace_save - Save a stack trace into a storage array
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save(unsigned long *store, unsigned int size,
+ 			      unsigned int skipnr)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 		.skip	= skipnr + 1,
+ 	};
+ 
+ 	arch_stack_walk(consume_entry, &c, current, NULL);
+ 	return c.len;
+ }
+ EXPORT_SYMBOL_GPL(stack_trace_save);
+ 
+ /**
+  * stack_trace_save_tsk - Save a task stack trace into a storage array
+  * @task:	The task to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save_tsk(struct task_struct *tsk, unsigned long *store,
+ 				  unsigned int size, unsigned int skipnr)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry_nosched;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 		.skip	= skipnr + 1,
+ 	};
+ 
+ 	if (!try_get_task_stack(tsk))
+ 		return 0;
+ 
+ 	arch_stack_walk(consume_entry, &c, tsk, NULL);
+ 	put_task_stack(tsk);
+ 	return c.len;
+ }
+ 
+ /**
+  * stack_trace_save_regs - Save a stack trace based on pt_regs into a storage array
+  * @regs:	Pointer to pt_regs to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save_regs(struct pt_regs *regs, unsigned long *store,
+ 				   unsigned int size, unsigned int skipnr)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 		.skip	= skipnr,
+ 	};
+ 
+ 	arch_stack_walk(consume_entry, &c, current, regs);
+ 	return c.len;
+ }
+ 
+ #ifdef CONFIG_HAVE_RELIABLE_STACKTRACE
+ /**
+  * stack_trace_save_tsk_reliable - Save task stack with verification
+  * @tsk:	Pointer to the task to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  *
+  * Return:	An error if it detects any unreliable features of the
+  *		stack. Otherwise it guarantees that the stack trace is
+  *		reliable and returns the number of entries stored.
+  *
+  * If the task is not 'current', the caller *must* ensure the task is inactive.
+  */
+ int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,
+ 				  unsigned int size)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 	};
+ 	int ret;
+ 
+ 	/*
+ 	 * If the task doesn't have a stack (e.g., a zombie), the stack is
+ 	 * "reliably" empty.
+ 	 */
+ 	if (!try_get_task_stack(tsk))
+ 		return 0;
+ 
+ 	ret = arch_stack_walk_reliable(consume_entry, &c, tsk);
+ 	put_task_stack(tsk);
+ 	return ret ? ret : c.len;
+ }
+ #endif
+ 
+ #ifdef CONFIG_USER_STACKTRACE_SUPPORT
+ /**
+  * stack_trace_save_user - Save a user space stack trace into a storage array
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save_user(unsigned long *store, unsigned int size)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 	};
+ 
+ 	/* Trace user stack if not a kernel thread */
+ 	if (current->flags & PF_KTHREAD)
+ 		return 0;
+ 
+ 	arch_stack_walk_user(consume_entry, &c, task_pt_regs(current));
+ 	return c.len;
+ }
+ #endif
+ 
+ #else /* CONFIG_ARCH_STACKWALK */
++>>>>>>> 7e8e6816c649 (stacktrace: Use PF_KTHREAD to check for kernel threads)
  
  /*
   * Architectures that do not implement save_stack_trace_*()
* Unmerged path kernel/stacktrace.c
