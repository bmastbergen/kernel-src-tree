s390/qeth: handle skb allocation error gracefully

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [s390] qeth: handle skb allocation error gracefully (Philipp Rudo) [1781085]
Rebuild_FUZZ: 94.62%
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 17caeaa4766dc447d6669b0f195c3ead746386ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/17caeaa4.failed

When current code fails to allocate an skb in the RX path, it drops the
whole RX buffer. Considering the large number of packets that a single
RX buffer might contain, this is quite drastic.

Skip over the packet instead, and try to extract the next packet from
the RX buffer.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 17caeaa4766dc447d6669b0f195c3ead746386ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index a0c5702815af,08185f76a727..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -5173,9 -5071,8 +5175,7 @@@ struct sk_buff *qeth_core_get_next_skb(
  	int skb_len = 0;
  	void *data_ptr;
  	int data_len;
- 	int headroom = 0;
- 	int use_rx_sg = 0;
  
 -next_packet:
  	/* qeth_hdr must not cross element boundaries */
  	while (element->length < offset + sizeof(struct qeth_hdr)) {
  		if (qeth_is_last_sbale(element))
@@@ -5220,11 -5135,13 +5220,12 @@@
  
  		skb = napi_alloc_skb(&card->napi, linear + headroom);
  	}
+ 
  	if (!skb)
- 		goto no_mem;
- 	if (headroom)
+ 		QETH_CARD_STAT_INC(card, rx_dropped_nomem);
+ 	else if (headroom)
  		skb_reserve(skb, headroom);
  
 -walk_packet:
  	data_ptr = element->addr + offset;
  	while (skb_len) {
  		data_len = min(skb_len, (int)(element->length - offset));
@@@ -5251,19 -5172,19 +5252,22 @@@
  			offset += data_len;
  		}
  	}
 -
 -	/* This packet was skipped, go get another one: */
 -	if (!skb)
 -		goto next_packet;
 -
  	*__element = element;
  	*__offset = offset;
 -	if (use_rx_sg) {
 -		QETH_CARD_STAT_INC(card, rx_sg_skbs);
 -		QETH_CARD_STAT_ADD(card, rx_sg_frags,
 -				   skb_shinfo(skb)->nr_frags);
 +	if (use_rx_sg && card->options.performance_stats) {
 +		card->perf_stats.sg_skbs_rx++;
 +		card->perf_stats.sg_frags_rx += skb_shinfo(skb)->nr_frags;
  	}
  	return skb;
++<<<<<<< HEAD
 +no_mem:
 +	if (net_ratelimit()) {
 +		QETH_CARD_TEXT(card, 2, "noskbmem");
 +	}
 +	card->stats.rx_dropped++;
 +	return NULL;
++=======
++>>>>>>> 17caeaa4766d (s390/qeth: handle skb allocation error gracefully)
  }
  EXPORT_SYMBOL_GPL(qeth_core_get_next_skb);
  
* Unmerged path drivers/s390/net/qeth_core_main.c
