net/mlx5: Separate IRQ table creation from EQ table creation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Separate IRQ table creation from EQ table creation (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 96.55%
commit-author Yuval Avnery <yuvalav@mellanox.com>
commit e1706e62801e9ad65b1fb6e6eccc69acfa43d16d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e1706e62.failed

IRQ allocation should be part of the IRQ table life-cycle.

	Signed-off-by: Yuval Avnery <yuvalav@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e1706e62801e9ad65b1fb6e6eccc69acfa43d16d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eq.c
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eq.c
index c00cfa7a9ba0,daf9bc3155cc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
@@@ -1002,30 -1056,26 +1002,47 @@@ struct mlx5_eq_comp *mlx5_eqn2comp_eq(s
  void mlx5_core_eq_free_irqs(struct mlx5_core_dev *dev)
  {
  	struct mlx5_eq_table *table = dev->priv.eq_table;
- 	int i, max_eqs;
  
++<<<<<<< HEAD
 +	clear_comp_irqs_affinity_hints(dev);
 +
 +#ifdef CONFIG_RFS_ACCEL
 +	if (table->rmap) {
 +		free_irq_cpu_rmap(table->rmap);
 +		table->rmap = NULL;
 +	}
 +#endif
 +
 +	mutex_lock(&table->lock); /* sync with create/destroy_async_eq */
 +	max_eqs = table->num_comp_vectors + MLX5_EQ_VEC_COMP_BASE;
 +	for (i = max_eqs - 1; i >= 0; i--) {
 +		free_irq(pci_irq_vector(dev->pdev, i), &table->irq_info[i].nh);
 +	}
++=======
+ 	mutex_lock(&table->lock); /* sync with create/destroy_async_eq */
+ 	mlx5_irq_table_destroy(dev);
++>>>>>>> e1706e62801e (net/mlx5: Separate IRQ table creation from EQ table creation)
  	mutex_unlock(&table->lock);
- 	pci_free_irq_vectors(dev->pdev);
  }
  
++<<<<<<< HEAD
 +static int alloc_irq_vectors(struct mlx5_core_dev *dev)
++=======
+ static void unrequest_irqs(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_irq_table *table = dev->priv.irq_table;
+ 	int i;
+ 
+ 	for (i = 0; i < table->nvec; i++)
+ 		free_irq(pci_irq_vector(dev->pdev, i),
+ 			 &mlx5_irq_get(dev, i)->nh);
+ }
+ 
+ int mlx5_irq_table_create(struct mlx5_core_dev *dev)
++>>>>>>> e1706e62801e (net/mlx5: Separate IRQ table creation from EQ table creation)
  {
  	struct mlx5_priv *priv = &dev->priv;
 -	struct mlx5_irq_table *table = priv->irq_table;
 +	struct mlx5_eq_table *table = priv->eq_table;
  	int num_eqs = MLX5_CAP_GEN(dev, max_num_eqs) ?
  		      MLX5_CAP_GEN(dev, max_num_eqs) :
  		      1 << MLX5_CAP_GEN(dev, log_max_eq);
@@@ -1064,26 -1126,31 +1081,31 @@@ err_free_irq_info
  	return err;
  }
  
- static void free_irq_vectors(struct mlx5_core_dev *dev)
+ void mlx5_irq_table_destroy(struct mlx5_core_dev *dev)
  {
 -	struct mlx5_irq_table *table = dev->priv.irq_table;
 +	struct mlx5_eq_table *table = dev->priv.eq_table;
  	int i;
  
 -	/* free_irq requires that affinity and rmap will be cleared
 -	 * before calling it. This is why there is asymmetry with set_rmap
 -	 * which should be called after alloc_irq but before request_irq.
 -	 */
 -	irq_clear_rmap(dev);
 -	clear_comp_irqs_affinity_hints(dev);
 -	for (i = 0; i < table->nvec; i++)
 -		free_irq(pci_irq_vector(dev->pdev, i),
 -			 &mlx5_irq_get(dev, i)->nh);
 +	for (i = 0; i < table->num_comp_vectors + MLX5_EQ_VEC_COMP_BASE; i++)
 +		free_irq(pci_irq_vector(dev->pdev, i), &table->irq_info[i].nh);
  	pci_free_irq_vectors(dev->pdev);
  	kfree(table->irq_info);
  }
  
  int mlx5_eq_table_create(struct mlx5_core_dev *dev)
  {
 -	struct mlx5_eq_table *eq_table = dev->priv.eq_table;
  	int err;
  
++<<<<<<< HEAD
 +	err = alloc_irq_vectors(dev);
 +	if (err) {
 +		mlx5_core_err(dev, "Failed to create IRQ vectors\n");
 +		return err;
 +	}
++=======
+ 	eq_table->num_comp_eqs =
+ 		mlx5_irq_get_num_comp(eq_table->irq_table);
++>>>>>>> e1706e62801e (net/mlx5: Separate IRQ table creation from EQ table creation)
  
  	err = create_async_eqs(dev);
  	if (err) {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index ea5e5990b832,bfc8c6faedc2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1076,9 -1047,15 +1076,15 @@@ static int mlx5_load_one(struct mlx5_co
  	mlx5_events_start(dev);
  	mlx5_pagealloc_start(dev);
  
+ 	err = mlx5_irq_table_create(dev);
+ 	if (err) {
+ 		mlx5_core_err(dev, "Failed to alloc IRQs\n");
+ 		goto err_irq_table;
+ 	}
+ 
  	err = mlx5_eq_table_create(dev);
  	if (err) {
 -		mlx5_core_err(dev, "Failed to create EQs\n");
 +		dev_err(&pdev->dev, "Failed to create EQs\n");
  		goto err_eq_table;
  	}
  
@@@ -1130,6 -1107,76 +1136,79 @@@
  		goto err_ec;
  	}
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ 
+ err_ec:
+ 	mlx5_sriov_detach(dev);
+ err_sriov:
+ 	mlx5_cleanup_fs(dev);
+ err_fs:
+ 	mlx5_accel_tls_cleanup(dev);
+ err_tls_start:
+ 	mlx5_accel_ipsec_cleanup(dev);
+ err_ipsec_start:
+ 	mlx5_fpga_device_stop(dev);
+ err_fpga_start:
+ 	mlx5_fw_tracer_cleanup(dev->tracer);
+ err_fw_tracer:
+ 	mlx5_eq_table_destroy(dev);
+ err_eq_table:
+ 	mlx5_irq_table_destroy(dev);
+ err_irq_table:
+ 	mlx5_pagealloc_stop(dev);
+ 	mlx5_events_stop(dev);
+ 	mlx5_put_uars_page(dev, dev->priv.uar);
+ 	return err;
+ }
+ 
+ static void mlx5_unload(struct mlx5_core_dev *dev)
+ {
+ 	mlx5_ec_cleanup(dev);
+ 	mlx5_sriov_detach(dev);
+ 	mlx5_cleanup_fs(dev);
+ 	mlx5_accel_ipsec_cleanup(dev);
+ 	mlx5_accel_tls_cleanup(dev);
+ 	mlx5_fpga_device_stop(dev);
+ 	mlx5_fw_tracer_cleanup(dev->tracer);
+ 	mlx5_eq_table_destroy(dev);
+ 	mlx5_irq_table_destroy(dev);
+ 	mlx5_pagealloc_stop(dev);
+ 	mlx5_events_stop(dev);
+ 	mlx5_put_uars_page(dev, dev->priv.uar);
+ }
+ 
+ static int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
+ {
+ 	int err = 0;
+ 
+ 	dev->caps.embedded_cpu = mlx5_read_embedded_cpu(dev);
+ 	mutex_lock(&dev->intf_state_mutex);
+ 	if (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
+ 		mlx5_core_warn(dev, "interface is up, NOP\n");
+ 		goto out;
+ 	}
+ 	/* remove any previous indication of internal error */
+ 	dev->state = MLX5_DEVICE_STATE_UP;
+ 
+ 	err = mlx5_function_setup(dev, boot);
+ 	if (err)
+ 		goto out;
+ 
+ 	if (boot) {
+ 		err = mlx5_init_once(dev);
+ 		if (err) {
+ 			mlx5_core_err(dev, "sw objs init failed\n");
+ 			goto function_teardown;
+ 		}
+ 	}
+ 
+ 	err = mlx5_load(dev);
+ 	if (err)
+ 		goto err_load;
+ 
++>>>>>>> e1706e62801e (net/mlx5: Separate IRQ table creation from EQ table creation)
  	if (mlx5_device_registered(dev)) {
  		mlx5_attach_device(dev);
  	} else {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 8213c994e205,14f1f63db3e3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -148,6 -153,11 +148,14 @@@ int mlx5_query_qcam_reg(struct mlx5_cor
  void mlx5_lag_add(struct mlx5_core_dev *dev, struct net_device *netdev);
  void mlx5_lag_remove(struct mlx5_core_dev *dev);
  
++<<<<<<< HEAD
++=======
+ int mlx5_irq_table_init(struct mlx5_core_dev *dev);
+ void mlx5_irq_table_cleanup(struct mlx5_core_dev *dev);
+ int mlx5_irq_table_create(struct mlx5_core_dev *dev);
+ void mlx5_irq_table_destroy(struct mlx5_core_dev *dev);
+ 
++>>>>>>> e1706e62801e (net/mlx5: Separate IRQ table creation from EQ table creation)
  int mlx5_events_init(struct mlx5_core_dev *dev);
  void mlx5_events_cleanup(struct mlx5_core_dev *dev);
  void mlx5_events_start(struct mlx5_core_dev *dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eq.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
