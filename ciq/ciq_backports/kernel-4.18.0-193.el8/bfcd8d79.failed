bnxt_en: Add fast path logic for TPA on 57500 chips.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add fast path logic for TPA on 57500 chips (Jonathan Toppins) [1724766]
Rebuild_FUZZ: 99.03%
commit-author Michael Chan <michael.chan@broadcom.com>
commit bfcd8d791ec18496772d117774398e336917f56e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/bfcd8d79.failed

With all the previous refactoring, the TPA fast path can now be
modified slightly to support TPA on the new chips.  The main
difference is that the agg completions are retrieved differently using
the bnxt_get_tpa_agg_p5() function on the new chips.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bfcd8d791ec18496772d117774398e336917f56e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 08038755587c,59358e5ddc37..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -827,8 -828,29 +827,34 @@@ static inline int bnxt_alloc_rx_page(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void bnxt_reuse_rx_agg_bufs(struct bnxt_cp_ring_info *cpr, u16 cp_cons,
 +				   u32 agg_bufs)
++=======
+ static struct rx_agg_cmp *bnxt_get_agg(struct bnxt *bp,
+ 				       struct bnxt_cp_ring_info *cpr,
+ 				       u16 cp_cons, u16 curr)
+ {
+ 	struct rx_agg_cmp *agg;
+ 
+ 	cp_cons = RING_CMP(ADV_RAW_CMP(cp_cons, curr));
+ 	agg = (struct rx_agg_cmp *)
+ 		&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
+ 	return agg;
+ }
+ 
+ static struct rx_agg_cmp *bnxt_get_tpa_agg_p5(struct bnxt *bp,
+ 					      struct bnxt_rx_ring_info *rxr,
+ 					      u16 agg_id, u16 curr)
+ {
+ 	struct bnxt_tpa_info *tpa_info = &rxr->rx_tpa[agg_id];
+ 
+ 	return &tpa_info->agg_arr[curr];
+ }
+ 
+ static void bnxt_reuse_rx_agg_bufs(struct bnxt_cp_ring_info *cpr, u16 idx,
+ 				   u16 start, u32 agg_bufs, bool tpa)
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  {
  	struct bnxt_napi *bnapi = cpr->bnapi;
  	struct bnxt *bp = bnapi->bp;
@@@ -844,8 -870,10 +874,15 @@@
  		struct rx_bd *prod_bd;
  		struct page *page;
  
++<<<<<<< HEAD
 +		agg = (struct rx_agg_cmp *)
 +			&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
++=======
+ 		if (p5_tpa)
+ 			agg = bnxt_get_tpa_agg_p5(bp, rxr, idx, start + i);
+ 		else
+ 			agg = bnxt_get_agg(bp, cpr, idx, start + i);
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  		cons = agg->rx_agg_cmp_opaque;
  		__clear_bit(cons, rxr->rx_agg_bmap);
  
@@@ -972,8 -1003,10 +1013,15 @@@ static struct sk_buff *bnxt_rx_pages(st
  		struct page *page;
  		dma_addr_t mapping;
  
++<<<<<<< HEAD
 +		agg = (struct rx_agg_cmp *)
 +			&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
++=======
+ 		if (p5_tpa)
+ 			agg = bnxt_get_tpa_agg_p5(bp, rxr, idx, i);
+ 		else
+ 			agg = bnxt_get_agg(bp, cpr, idx, i);
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  		cons = agg->rx_agg_cmp_opaque;
  		frag_len = (le32_to_cpu(agg->rx_agg_cmp_len_flags_type) &
  			    RX_AGG_CMP_LEN) >> RX_AGG_CMP_LEN_SHIFT;
@@@ -1080,9 -1112,10 +1128,16 @@@ static int bnxt_discard_rx(struct bnxt 
  	} else if (cmp_type == CMP_TYPE_RX_L2_TPA_END_CMP) {
  		struct rx_tpa_end_cmp *tpa_end = cmp;
  
++<<<<<<< HEAD
 +		agg_bufs = (le32_to_cpu(tpa_end->rx_tpa_end_cmp_misc_v1) &
 +			    RX_TPA_END_CMP_AGG_BUFS) >>
 +			   RX_TPA_END_CMP_AGG_BUFS_SHIFT;
++=======
+ 		if (bp->flags & BNXT_FLAG_CHIP_P5)
+ 			return 0;
+ 
+ 		agg_bufs = TPA_END_AGG_BUFS(tpa_end);
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  	}
  
  	if (agg_bufs) {
@@@ -1357,9 -1395,10 +1418,16 @@@ static inline struct sk_buff *bnxt_gro_
  	skb_shinfo(skb)->gso_size =
  		le32_to_cpu(tpa_end1->rx_tpa_end_cmp_seg_len);
  	skb_shinfo(skb)->gso_type = tpa_info->gso_type;
++<<<<<<< HEAD
 +	payload_off = (le32_to_cpu(tpa_end->rx_tpa_end_cmp_misc_v1) &
 +		       RX_TPA_END_CMP_PAYLOAD_OFFSET) >>
 +		      RX_TPA_END_CMP_PAYLOAD_OFFSET_SHIFT;
++=======
+ 	if (bp->flags & BNXT_FLAG_CHIP_P5)
+ 		payload_off = TPA_END_PAYLOAD_OFF_P5(tpa_end1);
+ 	else
+ 		payload_off = TPA_END_PAYLOAD_OFF(tpa_end);
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  	skb = bp->gro_func(tpa_info, payload_off, TPA_END_GRO_TS(tpa_end), skb);
  	if (likely(skb))
  		tcp_gro_complete(skb);
@@@ -1387,14 -1426,14 +1455,18 @@@ static inline struct sk_buff *bnxt_tpa_
  {
  	struct bnxt_napi *bnapi = cpr->bnapi;
  	struct bnxt_rx_ring_info *rxr = bnapi->rx_ring;
- 	u8 agg_id = TPA_END_AGG_ID(tpa_end);
  	u8 *data_ptr, agg_bufs;
 +	u16 cp_cons = RING_CMP(*raw_cons);
  	unsigned int len;
  	struct bnxt_tpa_info *tpa_info;
  	dma_addr_t mapping;
  	struct sk_buff *skb;
++<<<<<<< HEAD
++=======
+ 	u16 idx = 0, agg_id;
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  	void *data;
+ 	bool gro;
  
  	if (unlikely(bnapi->in_reset)) {
  		int rc = bnxt_discard_rx(bp, cpr, raw_cons, tpa_end);
@@@ -1411,19 -1476,8 +1509,22 @@@
  	len = tpa_info->len;
  	mapping = tpa_info->mapping;
  
++<<<<<<< HEAD
 +	agg_bufs = (le32_to_cpu(tpa_end->rx_tpa_end_cmp_misc_v1) &
 +		    RX_TPA_END_CMP_AGG_BUFS) >> RX_TPA_END_CMP_AGG_BUFS_SHIFT;
 +
 +	if (agg_bufs) {
 +		if (!bnxt_agg_bufs_valid(bp, cpr, agg_bufs, raw_cons))
 +			return ERR_PTR(-EBUSY);
 +
 +		*event |= BNXT_AGG_EVENT;
 +		cp_cons = NEXT_CMP(cp_cons);
 +	}
 +
++=======
++>>>>>>> bfcd8d791ec1 (bnxt_en: Add fast path logic for TPA on 57500 chips.)
  	if (unlikely(agg_bufs > MAX_SKB_FRAGS || TPA_END_ERRORS(tpa_end1))) {
 -		bnxt_abort_tpa(cpr, idx, agg_bufs);
 +		bnxt_abort_tpa(cpr, cp_cons, agg_bufs);
  		if (agg_bufs > MAX_SKB_FRAGS)
  			netdev_warn(bp->dev, "TPA frags %d exceeded MAX_SKB_FRAGS %d\n",
  				    agg_bufs, (int)MAX_SKB_FRAGS);
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
