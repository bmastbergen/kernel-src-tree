iommu/vt-d: Add attach_deferred() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit 1d4615978f525b769990a4a4ef22fb1b9a04cdf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/1d461597.failed

Implement a helper function to check whether a device's attach process
is deferred.

Fixes: 1ee0186b9a12 ("iommu/vt-d: Refactor find_domain() helper")
	Cc: stable@vger.kernel.org # v5.5
	Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
	Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 1d4615978f525b769990a4a4ef22fb1b9a04cdf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 1431de3bfba0,80f2332a5466..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2378,6 -2515,12 +2383,15 @@@ static struct dmar_domain *find_domain(
  {
  	struct device_domain_info *info;
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(attach_deferred(dev) || iommu_dummy(dev)))
+ 		return NULL;
+ 
+ 	if (dev_is_pci(dev))
+ 		dev = &pci_real_dma_dev(to_pci_dev(dev))->dev;
+ 
++>>>>>>> 1d4615978f52 (iommu/vt-d: Add attach_deferred() helper)
  	/* No lock here, assumes no domain exit in normal case */
  	info = dev->archdata.iommu;
  	if (likely(info))
@@@ -2385,6 -2528,21 +2399,23 @@@
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static struct dmar_domain *deferred_attach_domain(struct device *dev)
+ {
+ 	if (unlikely(attach_deferred(dev))) {
+ 		struct iommu_domain *domain;
+ 
+ 		dev->archdata.iommu = NULL;
+ 		domain = iommu_get_domain_for_dev(dev);
+ 		if (domain)
+ 			intel_iommu_attach_device(domain, dev);
+ 	}
+ 
+ 	return find_domain(dev);
+ }
+ 
++>>>>>>> 1d4615978f52 (iommu/vt-d: Add attach_deferred() helper)
  static inline struct device_domain_info *
  dmar_search_domain_by_dev_info(int segment, int bus, int devfn)
  {
@@@ -5695,6 -6125,52 +5726,55 @@@ intel_iommu_dev_feat_enabled(struct dev
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ intel_iommu_aux_get_pasid(struct iommu_domain *domain, struct device *dev)
+ {
+ 	struct dmar_domain *dmar_domain = to_dmar_domain(domain);
+ 
+ 	return dmar_domain->default_pasid > 0 ?
+ 			dmar_domain->default_pasid : -EINVAL;
+ }
+ 
+ static bool intel_iommu_is_attach_deferred(struct iommu_domain *domain,
+ 					   struct device *dev)
+ {
+ 	return attach_deferred(dev);
+ }
+ 
+ static int
+ intel_iommu_domain_set_attr(struct iommu_domain *domain,
+ 			    enum iommu_attr attr, void *data)
+ {
+ 	struct dmar_domain *dmar_domain = to_dmar_domain(domain);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 
+ 	if (domain->type != IOMMU_DOMAIN_UNMANAGED)
+ 		return -EINVAL;
+ 
+ 	switch (attr) {
+ 	case DOMAIN_ATTR_NESTING:
+ 		spin_lock_irqsave(&device_domain_lock, flags);
+ 		if (nested_mode_support() &&
+ 		    list_empty(&dmar_domain->devices)) {
+ 			dmar_domain->flags |= DOMAIN_FLAG_NESTING_MODE;
+ 			dmar_domain->flags &= ~DOMAIN_FLAG_USE_FIRST_LEVEL;
+ 		} else {
+ 			ret = -ENODEV;
+ 		}
+ 		spin_unlock_irqrestore(&device_domain_lock, flags);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 1d4615978f52 (iommu/vt-d: Add attach_deferred() helper)
  const struct iommu_ops intel_iommu_ops = {
  	.capable		= intel_iommu_capable,
  	.domain_alloc		= intel_iommu_domain_alloc,
* Unmerged path drivers/iommu/intel-iommu.c
