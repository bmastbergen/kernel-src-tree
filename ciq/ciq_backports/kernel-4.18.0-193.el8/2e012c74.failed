net: bpf: Don't leak time wait and request sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Lorenz Bauer <lmb@cloudflare.com>
commit 2e012c74823629d9db27963c79caa3f5b2010746
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2e012c74.failed

It's possible to leak time wait and request sockets via the following
BPF pseudo code:
Â 
  sk = bpf_skc_lookup_tcp(...)
  if (sk)
    bpf_sk_release(sk)

If sk->sk_state is TCP_NEW_SYN_RECV or TCP_TIME_WAIT the refcount taken
by bpf_skc_lookup_tcp is not undone by bpf_sk_release. This is because
sk_flags is re-used for other data in both kinds of sockets. The check

  !sock_flag(sk, SOCK_RCU_FREE)

therefore returns a bogus result. Check that sk_flags is valid by calling
sk_fullsock. Skip checking SOCK_RCU_FREE if we already know that sk is
not a full socket.

Fixes: edbf8c01de5a ("bpf: add skc_lookup_tcp helper")
Fixes: f7355a6c0497 ("bpf: Check sk_fullsock() before returning from bpf_sk_lookup()")
	Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20200110132336.26099-1-lmb@cloudflare.com
(cherry picked from commit 2e012c74823629d9db27963c79caa3f5b2010746)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/filter.c
diff --cc net/core/filter.c
index e238378f7df2,d22d108fc6e3..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -5253,25 -5303,32 +5253,30 @@@ __bpf_sk_lookup(struct sk_buff *skb, st
  		put_net(net);
  	}
  
 -out:
 -	return sk;
 -}
 -
 -static struct sock *
 -__bpf_sk_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
 -		struct net *caller_net, u32 ifindex, u8 proto, u64 netns_id,
 -		u64 flags)
 -{
 -	struct sock *sk = __bpf_skc_lookup(skb, tuple, len, caller_net,
 -					   ifindex, proto, netns_id, flags);
 -
  	if (sk) {
  		sk = sk_to_full_sk(sk);
 +		/* RHEL note: when backporting edbf8c01de5a1, do not forget
 +		 * the other part of the fix below (commit f7355a6c0497,
 +		 * which was only partially backported).
 +		 */
  		if (!sk_fullsock(sk)) {
++<<<<<<< HEAD
 +			if (!sock_flag(sk, SOCK_RCU_FREE))
 +				sock_gen_put(sk);
 +			return (unsigned long) NULL;
++=======
+ 			sock_gen_put(sk);
+ 			return NULL;
++>>>>>>> 2e012c748236 (net: bpf: Don't leak time wait and request sockets)
  		}
  	}
 -
 -	return sk;
 +out:
 +	return (unsigned long) sk;
  }
  
 -static struct sock *
 -bpf_skc_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
 -	       u8 proto, u64 netns_id, u64 flags)
 +static unsigned long
 +bpf_sk_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
 +	      u8 proto, u64 netns_id, u64 flags)
  {
  	struct net *caller_net;
  	int ifindex;
@@@ -5284,10 -5341,47 +5289,50 @@@
  		ifindex = 0;
  	}
  
 -	return __bpf_skc_lookup(skb, tuple, len, caller_net, ifindex, proto,
 -				netns_id, flags);
 +	return __bpf_sk_lookup(skb, tuple, len, caller_net, ifindex,
 +			      proto, netns_id, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static struct sock *
+ bpf_sk_lookup(struct sk_buff *skb, struct bpf_sock_tuple *tuple, u32 len,
+ 	      u8 proto, u64 netns_id, u64 flags)
+ {
+ 	struct sock *sk = bpf_skc_lookup(skb, tuple, len, proto, netns_id,
+ 					 flags);
+ 
+ 	if (sk) {
+ 		sk = sk_to_full_sk(sk);
+ 		if (!sk_fullsock(sk)) {
+ 			sock_gen_put(sk);
+ 			return NULL;
+ 		}
+ 	}
+ 
+ 	return sk;
+ }
+ 
+ BPF_CALL_5(bpf_skc_lookup_tcp, struct sk_buff *, skb,
+ 	   struct bpf_sock_tuple *, tuple, u32, len, u64, netns_id, u64, flags)
+ {
+ 	return (unsigned long)bpf_skc_lookup(skb, tuple, len, IPPROTO_TCP,
+ 					     netns_id, flags);
+ }
+ 
+ static const struct bpf_func_proto bpf_skc_lookup_tcp_proto = {
+ 	.func		= bpf_skc_lookup_tcp,
+ 	.gpl_only	= false,
+ 	.pkt_access	= true,
+ 	.ret_type	= RET_PTR_TO_SOCK_COMMON_OR_NULL,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
++>>>>>>> 2e012c748236 (net: bpf: Don't leak time wait and request sockets)
  BPF_CALL_5(bpf_sk_lookup_tcp, struct sk_buff *, skb,
  	   struct bpf_sock_tuple *, tuple, u32, len, u64, netns_id, u64, flags)
  {
* Unmerged path net/core/filter.c
