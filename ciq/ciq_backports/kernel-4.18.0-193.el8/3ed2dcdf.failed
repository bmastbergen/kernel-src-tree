memremap: validate the pagemap type passed to devm_memremap_pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 3ed2dcdf54d5bf1f9823b5faf1a702e7cee53982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3ed2dcdf.failed

Most pgmap types are only supported when certain config options are
enabled.  Check for a type that is valid for the current configuration
before setting up the pagemap.  For this the usage of the 0 type for
device dax gets replaced with an explicit MEMORY_DEVICE_DEVDAX type.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Tested-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 3ed2dcdf54d5bf1f9823b5faf1a702e7cee53982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/device.c
#	kernel/memremap.c
diff --cc drivers/dax/device.c
index e428468ab661,79014baa782d..000000000000
--- a/drivers/dax/device.c
+++ b/drivers/dax/device.c
@@@ -468,18 -465,13 +468,23 @@@ int dev_dax_probe(struct device *dev
  	if (rc)
  		return rc;
  
 +	rc = devm_add_action_or_reset(dev, dev_dax_percpu_exit, &dev_dax->ref);
 +	if (rc)
 +		return rc;
 +
  	dev_dax->pgmap.ref = &dev_dax->ref;
  	dev_dax->pgmap.kill = dev_dax_percpu_kill;
++<<<<<<< HEAD
++=======
+ 	dev_dax->pgmap.cleanup = dev_dax_percpu_exit;
+ 	dev_dax->pgmap.type = MEMORY_DEVICE_DEVDAX;
++>>>>>>> 3ed2dcdf54d5 (memremap: validate the pagemap type passed to devm_memremap_pages)
  	addr = devm_memremap_pages(dev, &dev_dax->pgmap);
 -	if (IS_ERR(addr))
 +	if (IS_ERR(addr)) {
 +		devm_remove_action(dev, dev_dax_percpu_exit, &dev_dax->ref);
 +		percpu_ref_exit(&dev_dax->ref);
  		return PTR_ERR(addr);
 +	}
  
  	inode = dax_inode(dax_dev);
  	cdev = inode->i_cdev;
diff --cc kernel/memremap.c
index 794888559eb7,abda62d1e5a3..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -177,12 -148,41 +177,39 @@@ void *devm_memremap_pages(struct devic
  			&pgmap->altmap : NULL;
  	struct resource *res = &pgmap->res;
  	struct dev_pagemap *conflict_pgmap;
 -	struct mhp_restrictions restrictions = {
 -		/*
 -		 * We do not want any optional features only our own memmap
 -		*/
 -		.altmap = altmap,
 -	};
  	pgprot_t pgprot = PAGE_KERNEL;
 +	unsigned long pgoff, order;
  	int error, nid, is_ram;
  
++<<<<<<< HEAD
 +	if (!pgmap->ref || !pgmap->kill)
++=======
+ 	switch (pgmap->type) {
+ 	case MEMORY_DEVICE_PRIVATE:
+ 		if (!IS_ENABLED(CONFIG_DEVICE_PRIVATE)) {
+ 			WARN(1, "Device private memory not supported\n");
+ 			return ERR_PTR(-EINVAL);
+ 		}
+ 		break;
+ 	case MEMORY_DEVICE_FS_DAX:
+ 		if (!IS_ENABLED(CONFIG_ZONE_DEVICE) ||
+ 		    IS_ENABLED(CONFIG_FS_DAX_LIMITED)) {
+ 			WARN(1, "File system DAX not supported\n");
+ 			return ERR_PTR(-EINVAL);
+ 		}
+ 		break;
+ 	case MEMORY_DEVICE_DEVDAX:
+ 	case MEMORY_DEVICE_PCI_P2PDMA:
+ 		break;
+ 	default:
+ 		WARN(1, "Invalid pgmap type %d\n", pgmap->type);
+ 		break;
+ 	}
+ 
+ 	if (!pgmap->ref || !pgmap->kill || !pgmap->cleanup) {
+ 		WARN(1, "Missing reference count teardown definition\n");
++>>>>>>> 3ed2dcdf54d5 (memremap: validate the pagemap type passed to devm_memremap_pages)
  		return ERR_PTR(-EINVAL);
 -	}
  
  	align_start = res->start & ~(SECTION_SIZE - 1);
  	align_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)
* Unmerged path drivers/dax/device.c
diff --git a/include/linux/memremap.h b/include/linux/memremap.h
index ae6713454b27..405387b2ca03 100644
--- a/include/linux/memremap.h
+++ b/include/linux/memremap.h
@@ -55,14 +55,22 @@ struct vmem_altmap {
  * wakeup is used to coordinate physical address space management (ex:
  * fs truncate/hole punch) vs pinned pages (ex: device dma).
  *
+ * MEMORY_DEVICE_DEVDAX:
+ * Host memory that has similar access semantics as System RAM i.e. DMA
+ * coherent and supports page pinning. In contrast to
+ * MEMORY_DEVICE_FS_DAX, this memory is access via a device-dax
+ * character device.
+ *
  * MEMORY_DEVICE_PCI_P2PDMA:
  * Device memory residing in a PCI BAR intended for use with Peer-to-Peer
  * transactions.
  */
 enum memory_type {
+	/* 0 is reserved to catch uninitialized type fields */
 	MEMORY_DEVICE_PRIVATE = 1,
 	MEMORY_DEVICE_PUBLIC,
 	MEMORY_DEVICE_FS_DAX,
+	MEMORY_DEVICE_DEVDAX,
 	MEMORY_DEVICE_PCI_P2PDMA,
 };
 
* Unmerged path kernel/memremap.c
