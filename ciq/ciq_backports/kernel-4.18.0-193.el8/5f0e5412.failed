uapi/bpf: fix helper docs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 5f0e5412781b01708f622d00c0b3f77b9dca7367
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5f0e5412.failed

Various small fixes to BPF helper documentation comments, enabling
automatic header generation with a list of BPF helpers.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 5f0e5412781b01708f622d00c0b3f77b9dca7367)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	tools/include/uapi/linux/bpf.h
diff --cc include/uapi/linux/bpf.h
index be4f12d97457,a65c3b0c6935..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -2460,17 -2501,19 +2460,29 @@@ union bpf_attr 
   *	Description
   *		This helper gets a **struct bpf_tcp_sock** pointer from a
   *		**struct bpf_sock** pointer.
 + *
   *	Return
 - *		A **struct bpf_tcp_sock** pointer on success, or **NULL** in
 + *		A **struct bpf_tcp_sock** pointer on success, or NULL in
   *		case of failure.
   *
++<<<<<<< HEAD
 + * int bpf_skb_ecn_set_ce(struct sk_buf *skb)
 + *     Description
 + *             Sets ECN of IP header to ce (congestion encountered) if
 + *             current value is ect (ECN capable). Works with IPv6 and IPv4.
 + *     Return
 + *             1 if set, 0 if not set.
++=======
+  * int bpf_skb_ecn_set_ce(struct sk_buff *skb)
+  *	Description
+  *		Set ECN (Explicit Congestion Notification) field of IP header
+  *		to **CE** (Congestion Encountered) if current value is **ECT**
+  *		(ECN Capable Transport). Otherwise, do nothing. Works with IPv6
+  *		and IPv4.
+  *	Return
+  *		1 if the **CE** flag is set (either by the current helper call
+  *		or because it was already present), 0 if it is not set.
++>>>>>>> 5f0e5412781b (uapi/bpf: fix helper docs)
   *
   * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
   *	Description
diff --cc tools/include/uapi/linux/bpf.h
index a8d76994a40e,a65c3b0c6935..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -996,7 -1023,7 +996,11 @@@ union bpf_attr 
   * 		The realm of the route for the packet associated to *skb*, or 0
   * 		if none was found.
   *
++<<<<<<< HEAD
 + * int bpf_perf_event_output(struct pt_reg *ctx, struct bpf_map *map, u64 flags, void *data, u64 size)
++=======
+  * int bpf_perf_event_output(void *ctx, struct bpf_map *map, u64 flags, void *data, u64 size)
++>>>>>>> 5f0e5412781b (uapi/bpf: fix helper docs)
   * 	Description
   * 		Write raw *data* blob into a special BPF perf event held by
   * 		*map* of type **BPF_MAP_TYPE_PERF_EVENT_ARRAY**. This perf
@@@ -1058,7 -1085,7 +1062,11 @@@
   * 	Return
   * 		0 on success, or a negative error in case of failure.
   *
++<<<<<<< HEAD
 + * int bpf_get_stackid(struct pt_reg *ctx, struct bpf_map *map, u64 flags)
++=======
+  * int bpf_get_stackid(void *ctx, struct bpf_map *map, u64 flags)
++>>>>>>> 5f0e5412781b (uapi/bpf: fix helper docs)
   * 	Description
   * 		Walk a user or a kernel stack and return its id. To achieve
   * 		this, the helper needs *ctx*, which is a pointer to the context
@@@ -2382,6 -2433,323 +2390,326 @@@
   *		"**y**".
   *	Return
   *		0
++<<<<<<< HEAD
++=======
+  *
+  * int bpf_spin_lock(struct bpf_spin_lock *lock)
+  *	Description
+  *		Acquire a spinlock represented by the pointer *lock*, which is
+  *		stored as part of a value of a map. Taking the lock allows to
+  *		safely update the rest of the fields in that value. The
+  *		spinlock can (and must) later be released with a call to
+  *		**bpf_spin_unlock**\ (\ *lock*\ ).
+  *
+  *		Spinlocks in BPF programs come with a number of restrictions
+  *		and constraints:
+  *
+  *		* **bpf_spin_lock** objects are only allowed inside maps of
+  *		  types **BPF_MAP_TYPE_HASH** and **BPF_MAP_TYPE_ARRAY** (this
+  *		  list could be extended in the future).
+  *		* BTF description of the map is mandatory.
+  *		* The BPF program can take ONE lock at a time, since taking two
+  *		  or more could cause dead locks.
+  *		* Only one **struct bpf_spin_lock** is allowed per map element.
+  *		* When the lock is taken, calls (either BPF to BPF or helpers)
+  *		  are not allowed.
+  *		* The **BPF_LD_ABS** and **BPF_LD_IND** instructions are not
+  *		  allowed inside a spinlock-ed region.
+  *		* The BPF program MUST call **bpf_spin_unlock**\ () to release
+  *		  the lock, on all execution paths, before it returns.
+  *		* The BPF program can access **struct bpf_spin_lock** only via
+  *		  the **bpf_spin_lock**\ () and **bpf_spin_unlock**\ ()
+  *		  helpers. Loading or storing data into the **struct
+  *		  bpf_spin_lock** *lock*\ **;** field of a map is not allowed.
+  *		* To use the **bpf_spin_lock**\ () helper, the BTF description
+  *		  of the map value must be a struct and have **struct
+  *		  bpf_spin_lock** *anyname*\ **;** field at the top level.
+  *		  Nested lock inside another struct is not allowed.
+  *		* The **struct bpf_spin_lock** *lock* field in a map value must
+  *		  be aligned on a multiple of 4 bytes in that value.
+  *		* Syscall with command **BPF_MAP_LOOKUP_ELEM** does not copy
+  *		  the **bpf_spin_lock** field to user space.
+  *		* Syscall with command **BPF_MAP_UPDATE_ELEM**, or update from
+  *		  a BPF program, do not update the **bpf_spin_lock** field.
+  *		* **bpf_spin_lock** cannot be on the stack or inside a
+  *		  networking packet (it can only be inside of a map values).
+  *		* **bpf_spin_lock** is available to root only.
+  *		* Tracing programs and socket filter programs cannot use
+  *		  **bpf_spin_lock**\ () due to insufficient preemption checks
+  *		  (but this may change in the future).
+  *		* **bpf_spin_lock** is not allowed in inner maps of map-in-map.
+  *	Return
+  *		0
+  *
+  * int bpf_spin_unlock(struct bpf_spin_lock *lock)
+  *	Description
+  *		Release the *lock* previously locked by a call to
+  *		**bpf_spin_lock**\ (\ *lock*\ ).
+  *	Return
+  *		0
+  *
+  * struct bpf_sock *bpf_sk_fullsock(struct bpf_sock *sk)
+  *	Description
+  *		This helper gets a **struct bpf_sock** pointer such
+  *		that all the fields in this **bpf_sock** can be accessed.
+  *	Return
+  *		A **struct bpf_sock** pointer on success, or **NULL** in
+  *		case of failure.
+  *
+  * struct bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock *sk)
+  *	Description
+  *		This helper gets a **struct bpf_tcp_sock** pointer from a
+  *		**struct bpf_sock** pointer.
+  *	Return
+  *		A **struct bpf_tcp_sock** pointer on success, or **NULL** in
+  *		case of failure.
+  *
+  * int bpf_skb_ecn_set_ce(struct sk_buff *skb)
+  *	Description
+  *		Set ECN (Explicit Congestion Notification) field of IP header
+  *		to **CE** (Congestion Encountered) if current value is **ECT**
+  *		(ECN Capable Transport). Otherwise, do nothing. Works with IPv6
+  *		and IPv4.
+  *	Return
+  *		1 if the **CE** flag is set (either by the current helper call
+  *		or because it was already present), 0 if it is not set.
+  *
+  * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
+  *	Description
+  *		Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
+  *		**bpf_sk_release**\ () is unnecessary and not allowed.
+  *	Return
+  *		A **struct bpf_sock** pointer on success, or **NULL** in
+  *		case of failure.
+  *
+  * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		This function is identical to **bpf_sk_lookup_tcp**\ (), except
+  *		that it also returns timewait or request sockets. Use
+  *		**bpf_sk_fullsock**\ () or **bpf_tcp_sock**\ () to access the
+  *		full structure.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from *reuse*\ **->socks**\ [] using the hash of the
+  *		tuple.
+  *
+  * int bpf_tcp_check_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  * 	Description
+  * 		Check whether *iph* and *th* contain a valid SYN cookie ACK for
+  * 		the listening socket in *sk*.
+  *
+  * 		*iph* points to the start of the IPv4 or IPv6 header, while
+  * 		*iph_len* contains **sizeof**\ (**struct iphdr**) or
+  * 		**sizeof**\ (**struct ip6hdr**).
+  *
+  * 		*th* points to the start of the TCP header, while *th_len*
+  * 		contains **sizeof**\ (**struct tcphdr**).
+  *
+  * 	Return
+  * 		0 if *iph* and *th* are a valid SYN cookie ACK, or a negative
+  * 		error otherwise.
+  *
+  * int bpf_sysctl_get_name(struct bpf_sysctl *ctx, char *buf, size_t buf_len, u64 flags)
+  *	Description
+  *		Get name of sysctl in /proc/sys/ and copy it into provided by
+  *		program buffer *buf* of size *buf_len*.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *
+  *		If *flags* is zero, full name (e.g. "net/ipv4/tcp_mem") is
+  *		copied. Use **BPF_F_SYSCTL_BASE_NAME** flag to copy base name
+  *		only (e.g. "tcp_mem").
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  * int bpf_sysctl_get_current_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get current value of sysctl as it is presented in /proc/sys
+  *		(incl. newline, etc), and copy it as a string into provided
+  *		by program buffer *buf* of size *buf_len*.
+  *
+  *		The whole value is copied, no matter what file position user
+  *		space issued e.g. sys_read at.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if current value was unavailable, e.g. because
+  *		sysctl is uninitialized and read returns -EIO for it.
+  *
+  * int bpf_sysctl_get_new_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get new value being written by user space to sysctl (before
+  *		the actual write happens) and copy it as a string into
+  *		provided by program buffer *buf* of size *buf_len*.
+  *
+  *		User space may write new value at file position > 0.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_sysctl_set_new_value(struct bpf_sysctl *ctx, const char *buf, size_t buf_len)
+  *	Description
+  *		Override new value being written by user space to sysctl with
+  *		value provided by program in buffer *buf* of size *buf_len*.
+  *
+  *		*buf* should contain a string in same form as provided by user
+  *		space on sysctl write.
+  *
+  *		User space may write new value at file position > 0. To override
+  *		the whole sysctl value file position should be set to zero.
+  *	Return
+  *		0 on success.
+  *
+  *		**-E2BIG** if the *buf_len* is too big.
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_strtol(const char *buf, size_t buf_len, u64 flags, long *res)
+  *	Description
+  *		Convert the initial part of the string from buffer *buf* of
+  *		size *buf_len* to a long integer according to the given base
+  *		and save the result in *res*.
+  *
+  *		The string may begin with an arbitrary amount of white space
+  *		(as determined by **isspace**\ (3)) followed by a single
+  *		optional '**-**' sign.
+  *
+  *		Five least significant bits of *flags* encode base, other bits
+  *		are currently unused.
+  *
+  *		Base must be either 8, 10, 16 or 0 to detect it automatically
+  *		similar to user space **strtol**\ (3).
+  *	Return
+  *		Number of characters consumed on success. Must be positive but
+  *		no more than *buf_len*.
+  *
+  *		**-EINVAL** if no valid digits were found or unsupported base
+  *		was provided.
+  *
+  *		**-ERANGE** if resulting value was out of range.
+  *
+  * int bpf_strtoul(const char *buf, size_t buf_len, u64 flags, unsigned long *res)
+  *	Description
+  *		Convert the initial part of the string from buffer *buf* of
+  *		size *buf_len* to an unsigned long integer according to the
+  *		given base and save the result in *res*.
+  *
+  *		The string may begin with an arbitrary amount of white space
+  *		(as determined by **isspace**\ (3)).
+  *
+  *		Five least significant bits of *flags* encode base, other bits
+  *		are currently unused.
+  *
+  *		Base must be either 8, 10, 16 or 0 to detect it automatically
+  *		similar to user space **strtoul**\ (3).
+  *	Return
+  *		Number of characters consumed on success. Must be positive but
+  *		no more than *buf_len*.
+  *
+  *		**-EINVAL** if no valid digits were found or unsupported base
+  *		was provided.
+  *
+  *		**-ERANGE** if resulting value was out of range.
+  *
+  * void *bpf_sk_storage_get(struct bpf_map *map, struct bpf_sock *sk, void *value, u64 flags)
+  *	Description
+  *		Get a bpf-local-storage from a *sk*.
+  *
+  *		Logically, it could be thought of getting the value from
+  *		a *map* with *sk* as the **key**.  From this
+  *		perspective,  the usage is not much different from
+  *		**bpf_map_lookup_elem**\ (*map*, **&**\ *sk*) except this
+  *		helper enforces the key must be a full socket and the map must
+  *		be a **BPF_MAP_TYPE_SK_STORAGE** also.
+  *
+  *		Underneath, the value is stored locally at *sk* instead of
+  *		the *map*.  The *map* is used as the bpf-local-storage
+  *		"type". The bpf-local-storage "type" (i.e. the *map*) is
+  *		searched against all bpf-local-storages residing at *sk*.
+  *
+  *		An optional *flags* (**BPF_SK_STORAGE_GET_F_CREATE**) can be
+  *		used such that a new bpf-local-storage will be
+  *		created if one does not exist.  *value* can be used
+  *		together with **BPF_SK_STORAGE_GET_F_CREATE** to specify
+  *		the initial value of a bpf-local-storage.  If *value* is
+  *		**NULL**, the new bpf-local-storage will be zero initialized.
+  *	Return
+  *		A bpf-local-storage pointer is returned on success.
+  *
+  *		**NULL** if not found or there was an error in adding
+  *		a new bpf-local-storage.
+  *
+  * int bpf_sk_storage_delete(struct bpf_map *map, struct bpf_sock *sk)
+  *	Description
+  *		Delete a bpf-local-storage from a *sk*.
+  *	Return
+  *		0 on success.
+  *
+  *		**-ENOENT** if the bpf-local-storage cannot be found.
+  *
+  * int bpf_send_signal(u32 sig)
+  *	Description
+  *		Send signal *sig* to the current task.
+  *	Return
+  *		0 on success or successfully queued.
+  *
+  *		**-EBUSY** if work queue under nmi is full.
+  *
+  *		**-EINVAL** if *sig* is invalid.
+  *
+  *		**-EPERM** if no permission to send the *sig*.
+  *
+  *		**-EAGAIN** if bpf program can try again.
+  *
+  * s64 bpf_tcp_gen_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  *	Description
+  *		Try to issue a SYN cookie for the packet with corresponding
+  *		IP/TCP headers, *iph* and *th*, on the listening socket in *sk*.
+  *
+  *		*iph* points to the start of the IPv4 or IPv6 header, while
+  *		*iph_len* contains **sizeof**\ (**struct iphdr**) or
+  *		**sizeof**\ (**struct ip6hdr**).
+  *
+  *		*th* points to the start of the TCP header, while *th_len*
+  *		contains the length of the TCP header.
+  *
+  *	Return
+  *		On success, lower 32 bits hold the generated SYN cookie in
+  *		followed by 16 bits which hold the MSS value for that cookie,
+  *		and the top 16 bits are unused.
+  *
+  *		On failure, the returned value is one of the following:
+  *
+  *		**-EINVAL** SYN cookie cannot be issued due to error
+  *
+  *		**-ENOENT** SYN cookie should not be issued (no SYN flood)
+  *
+  *		**-EOPNOTSUPP** kernel configuration does not enable SYN cookies
+  *
+  *		**-EPROTONOSUPPORT** IP packet version is not 4 or 6
++>>>>>>> 5f0e5412781b (uapi/bpf: fix helper docs)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path tools/include/uapi/linux/bpf.h
