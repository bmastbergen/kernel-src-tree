bpf: Add file_pos field to bpf_sysctl ctx

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrey Ignatov <rdna@fb.com>
commit e1550bfe0de47e30484ba91de1e50a91ec1c31f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e1550bfe.failed

Add file_pos field to bpf_sysctl context to read and write sysctl file
position at which sysctl is being accessed (read or written).

The field can be used to e.g. override whole sysctl value on write to
sysctl even when sys_write is called by user space with file_pos > 0. Or
BPF program may reject such accesses.

	Signed-off-by: Andrey Ignatov <rdna@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit e1550bfe0de47e30484ba91de1e50a91ec1c31f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/proc_sysctl.c
#	include/linux/bpf-cgroup.h
#	include/linux/filter.h
#	include/uapi/linux/bpf.h
#	kernel/bpf/cgroup.c
diff --cc fs/proc/proc_sysctl.c
index 89921a0d2ebb,2d61e5e8c863..000000000000
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@@ -589,11 -589,27 +589,19 @@@ static ssize_t proc_sys_call_handler(st
  	if (!table->proc_handler)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	error = BPF_CGROUP_RUN_PROG_SYSCTL(head, table, write, buf, &count,
+ 					   ppos, &new_buf);
+ 	if (error)
+ 		goto out;
+ 
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
  	/* careful: calling conventions are nasty here */
 -	if (new_buf) {
 -		mm_segment_t old_fs;
 -
 -		old_fs = get_fs();
 -		set_fs(KERNEL_DS);
 -		error = table->proc_handler(table, write, (void __user *)new_buf,
 -					    &count, ppos);
 -		set_fs(old_fs);
 -		kfree(new_buf);
 -	} else {
 -		error = table->proc_handler(table, write, buf, &count, ppos);
 -	}
 -
 +	res = count;
 +	error = table->proc_handler(table, write, buf, &res, ppos);
  	if (!error)
 -		error = count;
 +		error = res;
  out:
  	sysctl_head_finish(head);
  
diff --cc include/linux/bpf-cgroup.h
index 14647819f7e6,cb3c6b3b89c8..000000000000
--- a/include/linux/bpf-cgroup.h
+++ b/include/linux/bpf-cgroup.h
@@@ -150,6 -111,12 +150,15 @@@ int __cgroup_bpf_run_filter_sock_ops(st
  int __cgroup_bpf_check_dev_permission(short dev_type, u32 major, u32 minor,
  				      short access, enum bpf_attach_type type);
  
++<<<<<<< HEAD
++=======
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   void __user *buf, size_t *pcount,
+ 				   loff_t *ppos, void **new_buf,
+ 				   enum bpf_attach_type type);
+ 
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
  static inline enum bpf_cgroup_storage_type cgroup_storage_type(
  	struct bpf_map *map)
  {
@@@ -294,6 -261,18 +303,21 @@@ int bpf_percpu_cgroup_storage_update(st
  									      \
  	__ret;								      \
  })
++<<<<<<< HEAD
++=======
+ 
+ 
+ #define BPF_CGROUP_RUN_PROG_SYSCTL(head, table, write, buf, count, pos, nbuf)  \
+ ({									       \
+ 	int __ret = 0;							       \
+ 	if (cgroup_bpf_enabled)						       \
+ 		__ret = __cgroup_bpf_run_filter_sysctl(head, table, write,     \
+ 						       buf, count, pos, nbuf,  \
+ 						       BPF_CGROUP_SYSCTL);     \
+ 	__ret;								       \
+ })
+ 
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
  int cgroup_bpf_prog_attach(const union bpf_attr *attr,
  			   enum bpf_prog_type ptype, struct bpf_prog *prog);
  int cgroup_bpf_prog_detach(const union bpf_attr *attr,
@@@ -362,6 -341,7 +386,10 @@@ static inline int bpf_percpu_cgroup_sto
  #define BPF_CGROUP_RUN_PROG_UDP6_SENDMSG_LOCK(sk, uaddr, t_ctx) ({ 0; })
  #define BPF_CGROUP_RUN_PROG_SOCK_OPS(sock_ops) ({ 0; })
  #define BPF_CGROUP_RUN_PROG_DEVICE_CGROUP(type,major,minor,access) ({ 0; })
++<<<<<<< HEAD
++=======
+ #define BPF_CGROUP_RUN_PROG_SYSCTL(head,table,write,buf,count,pos,nbuf) ({ 0; })
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
  
  #define for_each_cgroup_storage_type(stype) for (; false; )
  
diff --cc include/linux/filter.h
index f32b3eca5a04,fb0edad75971..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -1152,4 -1179,18 +1152,21 @@@ struct bpf_sock_ops_kern 
  					 */
  };
  
++<<<<<<< HEAD
++=======
+ struct bpf_sysctl_kern {
+ 	struct ctl_table_header *head;
+ 	struct ctl_table *table;
+ 	void *cur_val;
+ 	size_t cur_len;
+ 	void *new_val;
+ 	size_t new_len;
+ 	int new_updated;
+ 	int write;
+ 	loff_t *ppos;
+ 	/* Temporary "register" for indirect stores to ppos. */
+ 	u64 tmp_reg;
+ };
+ 
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
  #endif /* __LINUX_FILTER_H__ */
diff --cc include/uapi/linux/bpf.h
index 6d4bc9ebe78a,89976de909af..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -3270,4 -3386,14 +3270,17 @@@ struct bpf_line_info 
  struct bpf_spin_lock {
  	__u32	val;
  };
++<<<<<<< HEAD
++=======
+ 
+ struct bpf_sysctl {
+ 	__u32	write;		/* Sysctl is being read (= 0) or written (= 1).
+ 				 * Allows 1,2,4-byte read, but no write.
+ 				 */
+ 	__u32	file_pos;	/* Sysctl file position to read from, write to.
+ 				 * Allows 1,2,4-byte read an 4-byte write.
+ 				 */
+ };
+ 
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
  #endif /* _UAPI__LINUX_BPF_H__ */
diff --cc kernel/bpf/cgroup.c
index 7d9c426bf2c7,b2adf22139b3..000000000000
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@@ -811,3 -771,352 +811,355 @@@ const struct bpf_verifier_ops cg_dev_ve
  	.get_func_proto		= cgroup_dev_func_proto,
  	.is_valid_access	= cgroup_dev_is_valid_access,
  };
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * __cgroup_bpf_run_filter_sysctl - Run a program on sysctl
+  *
+  * @head: sysctl table header
+  * @table: sysctl table
+  * @write: sysctl is being read (= 0) or written (= 1)
+  * @buf: pointer to buffer passed by user space
+  * @pcount: value-result argument: value is size of buffer pointed to by @buf,
+  *	result is size of @new_buf if program set new value, initial value
+  *	otherwise
+  * @ppos: value-result argument: value is position at which read from or write
+  *	to sysctl is happening, result is new position if program overrode it,
+  *	initial value otherwise
+  * @new_buf: pointer to pointer to new buffer that will be allocated if program
+  *	overrides new value provided by user space on sysctl write
+  *	NOTE: it's caller responsibility to free *new_buf if it was set
+  * @type: type of program to be executed
+  *
+  * Program is run when sysctl is being accessed, either read or written, and
+  * can allow or deny such access.
+  *
+  * This function will return %-EPERM if an attached program is found and
+  * returned value != 1 during execution. In all other cases 0 is returned.
+  */
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   void __user *buf, size_t *pcount,
+ 				   loff_t *ppos, void **new_buf,
+ 				   enum bpf_attach_type type)
+ {
+ 	struct bpf_sysctl_kern ctx = {
+ 		.head = head,
+ 		.table = table,
+ 		.write = write,
+ 		.ppos = ppos,
+ 		.cur_val = NULL,
+ 		.cur_len = PAGE_SIZE,
+ 		.new_val = NULL,
+ 		.new_len = 0,
+ 		.new_updated = 0,
+ 	};
+ 	struct cgroup *cgrp;
+ 	int ret;
+ 
+ 	ctx.cur_val = kmalloc_track_caller(ctx.cur_len, GFP_KERNEL);
+ 	if (ctx.cur_val) {
+ 		mm_segment_t old_fs;
+ 		loff_t pos = 0;
+ 
+ 		old_fs = get_fs();
+ 		set_fs(KERNEL_DS);
+ 		if (table->proc_handler(table, 0, (void __user *)ctx.cur_val,
+ 					&ctx.cur_len, &pos)) {
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.cur_len = 0;
+ 		}
+ 		set_fs(old_fs);
+ 	} else {
+ 		/* Let BPF program decide how to proceed. */
+ 		ctx.cur_len = 0;
+ 	}
+ 
+ 	if (write && buf && *pcount) {
+ 		/* BPF program should be able to override new value with a
+ 		 * buffer bigger than provided by user.
+ 		 */
+ 		ctx.new_val = kmalloc_track_caller(PAGE_SIZE, GFP_KERNEL);
+ 		ctx.new_len = min(PAGE_SIZE, *pcount);
+ 		if (!ctx.new_val ||
+ 		    copy_from_user(ctx.new_val, buf, ctx.new_len))
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.new_len = 0;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	cgrp = task_dfl_cgroup(current);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);
+ 	rcu_read_unlock();
+ 
+ 	kfree(ctx.cur_val);
+ 
+ 	if (ret == 1 && ctx.new_updated) {
+ 		*new_buf = ctx.new_val;
+ 		*pcount = ctx.new_len;
+ 	} else {
+ 		kfree(ctx.new_val);
+ 	}
+ 
+ 	return ret == 1 ? 0 : -EPERM;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_sysctl);
+ 
+ static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,
+ 			      size_t *lenp)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (dir->header.parent) {
+ 		tmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);
+ 	if (ret < 0)
+ 		return ret;
+ 	*bufp += ret;
+ 	*lenp -= ret;
+ 	ret += tmp_ret;
+ 
+ 	/* Avoid leading slash. */
+ 	if (!ret)
+ 		return ret;
+ 
+ 	tmp_ret = strscpy(*bufp, "/", *lenp);
+ 	if (tmp_ret < 0)
+ 		return tmp_ret;
+ 	*bufp += tmp_ret;
+ 	*lenp -= tmp_ret;
+ 
+ 	return ret + tmp_ret;
+ }
+ 
+ BPF_CALL_4(bpf_sysctl_get_name, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len, u64, flags)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (!(flags & BPF_F_SYSCTL_BASE_NAME)) {
+ 		if (!ctx->head)
+ 			return -EINVAL;
+ 		tmp_ret = sysctl_cpy_dir(ctx->head->parent, &buf, &buf_len);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(buf, ctx->table->procname, buf_len);
+ 
+ 	return ret < 0 ? ret : tmp_ret + ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_name_proto = {
+ 	.func		= bpf_sysctl_get_name,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ static int copy_sysctl_value(char *dst, size_t dst_len, char *src,
+ 			     size_t src_len)
+ {
+ 	if (!dst)
+ 		return -EINVAL;
+ 
+ 	if (!dst_len)
+ 		return -E2BIG;
+ 
+ 	if (!src || !src_len) {
+ 		memset(dst, 0, dst_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	memcpy(dst, src, min(dst_len, src_len));
+ 
+ 	if (dst_len > src_len) {
+ 		memset(dst + src_len, '\0', dst_len - src_len);
+ 		return src_len;
+ 	}
+ 
+ 	dst[dst_len - 1] = '\0';
+ 
+ 	return -E2BIG;
+ }
+ 
+ BPF_CALL_3(bpf_sysctl_get_current_value, struct bpf_sysctl_kern *, ctx,
+ 	   char *, buf, size_t, buf_len)
+ {
+ 	return copy_sysctl_value(buf, buf_len, ctx->cur_val, ctx->cur_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_current_value_proto = {
+ 	.func		= bpf_sysctl_get_current_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_get_new_value, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len)
+ {
+ 	if (!ctx->write) {
+ 		if (buf && buf_len)
+ 			memset(buf, '\0', buf_len);
+ 		return -EINVAL;
+ 	}
+ 	return copy_sysctl_value(buf, buf_len, ctx->new_val, ctx->new_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_new_value_proto = {
+ 	.func		= bpf_sysctl_get_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_set_new_value, struct bpf_sysctl_kern *, ctx,
+ 	   const char *, buf, size_t, buf_len)
+ {
+ 	if (!ctx->write || !ctx->new_val || !ctx->new_len || !buf || !buf_len)
+ 		return -EINVAL;
+ 
+ 	if (buf_len > PAGE_SIZE - 1)
+ 		return -E2BIG;
+ 
+ 	memcpy(ctx->new_val, buf, buf_len);
+ 	ctx->new_len = buf_len;
+ 	ctx->new_updated = 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_set_new_value_proto = {
+ 	.func		= bpf_sysctl_set_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ sysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_sysctl_get_name:
+ 		return &bpf_sysctl_get_name_proto;
+ 	case BPF_FUNC_sysctl_get_current_value:
+ 		return &bpf_sysctl_get_current_value_proto;
+ 	case BPF_FUNC_sysctl_get_new_value:
+ 		return &bpf_sysctl_get_new_value_proto;
+ 	case BPF_FUNC_sysctl_set_new_value:
+ 		return &bpf_sysctl_set_new_value_proto;
+ 	default:
+ 		return cgroup_base_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off + size > sizeof(struct bpf_sysctl) || off % size)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		if (type != BPF_READ)
+ 			return false;
+ 		bpf_ctx_record_field_size(info, size_default);
+ 		return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 	case offsetof(struct bpf_sysctl, file_pos):
+ 		if (type == BPF_READ) {
+ 			bpf_ctx_record_field_size(info, size_default);
+ 			return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 		} else {
+ 			return size == size_default;
+ 		}
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static u32 sysctl_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct bpf_sysctl_kern, write,
+ 				       FIELD_SIZEOF(struct bpf_sysctl_kern,
+ 						    write),
+ 				       target_size));
+ 		break;
+ 	case offsetof(struct bpf_sysctl, file_pos):
+ 		/* ppos is a pointer so it should be accessed via indirect
+ 		 * loads and stores. Also for stores additional temporary
+ 		 * register is used since neither src_reg nor dst_reg can be
+ 		 * overridden.
+ 		 */
+ 		if (type == BPF_WRITE) {
+ 			int treg = BPF_REG_9;
+ 
+ 			if (si->src_reg == treg || si->dst_reg == treg)
+ 				--treg;
+ 			if (si->src_reg == treg || si->dst_reg == treg)
+ 				--treg;
+ 			*insn++ = BPF_STX_MEM(
+ 				BPF_DW, si->dst_reg, treg,
+ 				offsetof(struct bpf_sysctl_kern, tmp_reg));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),
+ 				treg, si->dst_reg,
+ 				offsetof(struct bpf_sysctl_kern, ppos));
+ 			*insn++ = BPF_STX_MEM(
+ 				BPF_SIZEOF(u32), treg, si->src_reg, 0);
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_DW, treg, si->dst_reg,
+ 				offsetof(struct bpf_sysctl_kern, tmp_reg));
+ 		} else {
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),
+ 				si->dst_reg, si->src_reg,
+ 				offsetof(struct bpf_sysctl_kern, ppos));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_SIZE(si->code), si->dst_reg, si->dst_reg, 0);
+ 		}
+ 		*target_size = sizeof(u32);
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ const struct bpf_verifier_ops cg_sysctl_verifier_ops = {
+ 	.get_func_proto		= sysctl_func_proto,
+ 	.is_valid_access	= sysctl_is_valid_access,
+ 	.convert_ctx_access	= sysctl_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sysctl_prog_ops = {
+ };
++>>>>>>> e1550bfe0de4 (bpf: Add file_pos field to bpf_sysctl ctx)
* Unmerged path fs/proc/proc_sysctl.c
* Unmerged path include/linux/bpf-cgroup.h
* Unmerged path include/linux/filter.h
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/cgroup.c
