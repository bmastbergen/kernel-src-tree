stacktrace: Don't skip first entry on noncurrent tasks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jiri Slaby <jslaby@suse.cz>
commit b0c51f158455e31d5024100cf3580fcd88214b0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b0c51f15.failed

When doing cat /proc/<PID>/stack, the output is missing the first entry.
When the current code walks the stack starting in stack_trace_save_tsk,
it skips all scheduler functions (that's OK) plus one more function. But
this one function should be skipped only for the 'current' task as it is
stack_trace_save_tsk proper.

The original code (before the common infrastructure) skipped one
function only for the 'current' task -- see save_stack_trace_tsk before
3599fe12a125. So do so also in the new infrastructure now.

Fixes: 214d8ca6ee85 ("stacktrace: Provide common infrastructure")
	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Michal Suchanek <msuchanek@suse.de>
	Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
Link: https://lkml.kernel.org/r/20191030072545.19462-1-jslaby@suse.cz

(cherry picked from commit b0c51f158455e31d5024100cf3580fcd88214b0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/stacktrace.c
diff --cc kernel/stacktrace.c
index f8edee9c792d,c9ea7eb2cb1a..000000000000
--- a/kernel/stacktrace.c
+++ b/kernel/stacktrace.c
@@@ -51,7 -67,182 +51,186 @@@ int snprint_stack_trace(char *buf, size
  
  	return total;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(snprint_stack_trace);
++=======
+ EXPORT_SYMBOL_GPL(stack_trace_snprint);
+ 
+ #ifdef CONFIG_ARCH_STACKWALK
+ 
+ struct stacktrace_cookie {
+ 	unsigned long	*store;
+ 	unsigned int	size;
+ 	unsigned int	skip;
+ 	unsigned int	len;
+ };
+ 
+ static bool stack_trace_consume_entry(void *cookie, unsigned long addr,
+ 				      bool reliable)
+ {
+ 	struct stacktrace_cookie *c = cookie;
+ 
+ 	if (c->len >= c->size)
+ 		return false;
+ 
+ 	if (c->skip > 0) {
+ 		c->skip--;
+ 		return true;
+ 	}
+ 	c->store[c->len++] = addr;
+ 	return c->len < c->size;
+ }
+ 
+ static bool stack_trace_consume_entry_nosched(void *cookie, unsigned long addr,
+ 					      bool reliable)
+ {
+ 	if (in_sched_functions(addr))
+ 		return true;
+ 	return stack_trace_consume_entry(cookie, addr, reliable);
+ }
+ 
+ /**
+  * stack_trace_save - Save a stack trace into a storage array
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save(unsigned long *store, unsigned int size,
+ 			      unsigned int skipnr)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 		.skip	= skipnr + 1,
+ 	};
+ 
+ 	arch_stack_walk(consume_entry, &c, current, NULL);
+ 	return c.len;
+ }
+ EXPORT_SYMBOL_GPL(stack_trace_save);
+ 
+ /**
+  * stack_trace_save_tsk - Save a task stack trace into a storage array
+  * @task:	The task to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save_tsk(struct task_struct *tsk, unsigned long *store,
+ 				  unsigned int size, unsigned int skipnr)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry_nosched;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 		/* skip this function if they are tracing us */
+ 		.skip	= skipnr + !!(current == tsk),
+ 	};
+ 
+ 	if (!try_get_task_stack(tsk))
+ 		return 0;
+ 
+ 	arch_stack_walk(consume_entry, &c, tsk, NULL);
+ 	put_task_stack(tsk);
+ 	return c.len;
+ }
+ 
+ /**
+  * stack_trace_save_regs - Save a stack trace based on pt_regs into a storage array
+  * @regs:	Pointer to pt_regs to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save_regs(struct pt_regs *regs, unsigned long *store,
+ 				   unsigned int size, unsigned int skipnr)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 		.skip	= skipnr,
+ 	};
+ 
+ 	arch_stack_walk(consume_entry, &c, current, regs);
+ 	return c.len;
+ }
+ 
+ #ifdef CONFIG_HAVE_RELIABLE_STACKTRACE
+ /**
+  * stack_trace_save_tsk_reliable - Save task stack with verification
+  * @tsk:	Pointer to the task to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  *
+  * Return:	An error if it detects any unreliable features of the
+  *		stack. Otherwise it guarantees that the stack trace is
+  *		reliable and returns the number of entries stored.
+  *
+  * If the task is not 'current', the caller *must* ensure the task is inactive.
+  */
+ int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,
+ 				  unsigned int size)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 	};
+ 	int ret;
+ 
+ 	/*
+ 	 * If the task doesn't have a stack (e.g., a zombie), the stack is
+ 	 * "reliably" empty.
+ 	 */
+ 	if (!try_get_task_stack(tsk))
+ 		return 0;
+ 
+ 	ret = arch_stack_walk_reliable(consume_entry, &c, tsk);
+ 	put_task_stack(tsk);
+ 	return ret ? ret : c.len;
+ }
+ #endif
+ 
+ #ifdef CONFIG_USER_STACKTRACE_SUPPORT
+ /**
+  * stack_trace_save_user - Save a user space stack trace into a storage array
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  *
+  * Return: Number of trace entries stored.
+  */
+ unsigned int stack_trace_save_user(unsigned long *store, unsigned int size)
+ {
+ 	stack_trace_consume_fn consume_entry = stack_trace_consume_entry;
+ 	struct stacktrace_cookie c = {
+ 		.store	= store,
+ 		.size	= size,
+ 	};
+ 	mm_segment_t fs;
+ 
+ 	/* Trace user stack if not a kernel thread */
+ 	if (current->flags & PF_KTHREAD)
+ 		return 0;
+ 
+ 	fs = get_fs();
+ 	set_fs(USER_DS);
+ 	arch_stack_walk_user(consume_entry, &c, task_pt_regs(current));
+ 	set_fs(fs);
+ 
+ 	return c.len;
+ }
+ #endif
+ 
+ #else /* CONFIG_ARCH_STACKWALK */
++>>>>>>> b0c51f158455 (stacktrace: Don't skip first entry on noncurrent tasks)
  
  /*
   * Architectures that do not implement save_stack_trace_*()
@@@ -70,10 -261,118 +249,108 @@@ save_stack_trace_regs(struct pt_regs *r
  	WARN_ONCE(1, KERN_INFO "save_stack_trace_regs() not implemented yet.\n");
  }
  
 -/**
 - * stack_trace_save - Save a stack trace into a storage array
 - * @store:	Pointer to storage array
 - * @size:	Size of the storage array
 - * @skipnr:	Number of entries to skip at the start of the stack trace
 - *
 - * Return: Number of trace entries stored
 - */
 -unsigned int stack_trace_save(unsigned long *store, unsigned int size,
 -			      unsigned int skipnr)
 +__weak int
 +save_stack_trace_tsk_reliable(struct task_struct *tsk,
 +			      struct stack_trace *trace)
  {
 -	struct stack_trace trace = {
 -		.entries	= store,
 -		.max_entries	= size,
 -		.skip		= skipnr + 1,
 -	};
 -
 -	save_stack_trace(&trace);
 -	return trace.nr_entries;
 +	WARN_ONCE(1, KERN_INFO "save_stack_tsk_reliable() not implemented yet.\n");
 +	return -ENOSYS;
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(stack_trace_save);
+ 
+ /**
+  * stack_trace_save_tsk - Save a task stack trace into a storage array
+  * @task:	The task to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored
+  */
+ unsigned int stack_trace_save_tsk(struct task_struct *task,
+ 				  unsigned long *store, unsigned int size,
+ 				  unsigned int skipnr)
+ {
+ 	struct stack_trace trace = {
+ 		.entries	= store,
+ 		.max_entries	= size,
+ 		/* skip this function if they are tracing us */
+ 		.skip	= skipnr + !!(current == task),
+ 	};
+ 
+ 	save_stack_trace_tsk(task, &trace);
+ 	return trace.nr_entries;
+ }
+ 
+ /**
+  * stack_trace_save_regs - Save a stack trace based on pt_regs into a storage array
+  * @regs:	Pointer to pt_regs to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  * @skipnr:	Number of entries to skip at the start of the stack trace
+  *
+  * Return: Number of trace entries stored
+  */
+ unsigned int stack_trace_save_regs(struct pt_regs *regs, unsigned long *store,
+ 				   unsigned int size, unsigned int skipnr)
+ {
+ 	struct stack_trace trace = {
+ 		.entries	= store,
+ 		.max_entries	= size,
+ 		.skip		= skipnr,
+ 	};
+ 
+ 	save_stack_trace_regs(regs, &trace);
+ 	return trace.nr_entries;
+ }
+ 
+ #ifdef CONFIG_HAVE_RELIABLE_STACKTRACE
+ /**
+  * stack_trace_save_tsk_reliable - Save task stack with verification
+  * @tsk:	Pointer to the task to examine
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  *
+  * Return:	An error if it detects any unreliable features of the
+  *		stack. Otherwise it guarantees that the stack trace is
+  *		reliable and returns the number of entries stored.
+  *
+  * If the task is not 'current', the caller *must* ensure the task is inactive.
+  */
+ int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,
+ 				  unsigned int size)
+ {
+ 	struct stack_trace trace = {
+ 		.entries	= store,
+ 		.max_entries	= size,
+ 	};
+ 	int ret = save_stack_trace_tsk_reliable(tsk, &trace);
+ 
+ 	return ret ? ret : trace.nr_entries;
+ }
+ #endif
+ 
+ #ifdef CONFIG_USER_STACKTRACE_SUPPORT
+ /**
+  * stack_trace_save_user - Save a user space stack trace into a storage array
+  * @store:	Pointer to storage array
+  * @size:	Size of the storage array
+  *
+  * Return: Number of trace entries stored
+  */
+ unsigned int stack_trace_save_user(unsigned long *store, unsigned int size)
+ {
+ 	struct stack_trace trace = {
+ 		.entries	= store,
+ 		.max_entries	= size,
+ 	};
+ 
+ 	save_stack_trace_user(&trace);
+ 	return trace.nr_entries;
+ }
+ #endif /* CONFIG_USER_STACKTRACE_SUPPORT */
+ 
+ #endif /* !CONFIG_ARCH_STACKWALK */
++>>>>>>> b0c51f158455 (stacktrace: Don't skip first entry on noncurrent tasks)
* Unmerged path kernel/stacktrace.c
