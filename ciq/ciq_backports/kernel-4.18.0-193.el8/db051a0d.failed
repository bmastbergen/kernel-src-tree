mm/memory_hotplug: create memory block devices after arch_add_memory()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author David Hildenbrand <david@redhat.com>
commit db051a0dac13db24d58470d75cee0ce7c6b031a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/db051a0d.failed

Only memory to be added to the buddy and to be onlined/offlined by user
space using /sys/devices/system/memory/...  needs (and should have!)
memory block devices.

Factor out creation of memory block devices.  Create all devices after
arch_add_memory() succeeded.  We can later drop the want_memblock
parameter, because it is now effectively stale.

Only after memory block devices have been added, memory can be onlined
by user space.  This implies, that memory is not visible to user space
at all before arch_add_memory() succeeded.

While at it
 - use WARN_ON_ONCE instead of BUG_ON in moved unregister_memory()
 - introduce find_memory_block_by_id() to search via block id
 - Use find_memory_block_by_id() in init_memory_block() to catch
   duplicates

Link: http://lkml.kernel.org/r/20190527111152.16324-8-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: "mike.travis@hpe.com" <mike.travis@hpe.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Andrew Banman <andrew.banman@hpe.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Qian Cai <cai@lca.pw>
	Cc: Wei Yang <richard.weiyang@gmail.com>
	Cc: Arun KS <arunks@codeaurora.org>
	Cc: Mathieu Malaterre <malat@debian.org>
	Cc: Alex Deucher <alexander.deucher@amd.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Anshuman Khandual <anshuman.khandual@arm.com>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Chintan Pandya <cpandya@codeaurora.org>
	Cc: Christophe Leroy <christophe.leroy@c-s.fr>
	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Jun Yao <yaojun8558363@gmail.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: Mark Brown <broonie@kernel.org>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Cc: Nicholas Piggin <npiggin@gmail.com>
	Cc: Oscar Salvador <osalvador@suse.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Rob Herring <robh@kernel.org>
	Cc: Robin Murphy <robin.murphy@arm.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Cc: Yu Zhao <yuzhao@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit db051a0dac13db24d58470d75cee0ce7c6b031a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/memory.c
#	include/linux/memory.h
diff --cc drivers/base/memory.c
index b031eaa5b09d,18a30c3ac0ef..000000000000
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@@ -701,39 -712,10 +718,40 @@@ static int add_memory_block(int base_se
  	return 0;
  }
  
- /*
-  * need an interface for the VM to add new memory regions,
-  * but without onlining it.
-  */
- int hotplug_memory_register(int nid, struct mem_section *section)
+ static void unregister_memory(struct memory_block *memory)
  {
++<<<<<<< HEAD
 +	int block_id = base_memory_block_id(__section_nr(section));
 +	int ret = 0;
 +	struct memory_block *mem;
 +
 +	mutex_lock(&mem_sysfs_mutex);
 +
 +	mem = find_memory_block(section);
 +	if (mem) {
 +		mem->section_count++;
 +		put_device(&mem->dev);
 +	} else {
 +		ret = init_memory_block(&mem, block_id, MEM_OFFLINE);
 +		if (ret)
 +			goto out;
 +		mem->section_count++;
 +	}
 +
 +out:
 +	mutex_unlock(&mem_sysfs_mutex);
 +	return ret;
 +}
 +
 +#ifdef CONFIG_MEMORY_HOTREMOVE
 +static void
 +unregister_memory(struct memory_block *memory)
 +{
 +	BUG_ON(memory->dev.bus != &memory_subsys);
++=======
+ 	if (WARN_ON_ONCE(memory->dev.bus != &memory_subsys))
+ 		return;
++>>>>>>> db051a0dac13 (mm/memory_hotplug: create memory block devices after arch_add_memory())
  
  	/* drop the ref. we got via find_memory_block() */
  	put_device(&memory->dev);
diff --cc include/linux/memory.h
index e1dc1bb2b787,db3e8567f900..000000000000
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@@ -111,10 -111,8 +111,14 @@@ extern int register_memory_notifier(str
  extern void unregister_memory_notifier(struct notifier_block *nb);
  extern int register_memory_isolate_notifier(struct notifier_block *nb);
  extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
++<<<<<<< HEAD
 +int hotplug_memory_register(int nid, struct mem_section *section);
 +#ifdef CONFIG_MEMORY_HOTREMOVE
++=======
+ int create_memory_block_devices(unsigned long start, unsigned long size);
++>>>>>>> db051a0dac13 (mm/memory_hotplug: create memory block devices after arch_add_memory())
  extern void unregister_memory_section(struct mem_section *);
 +#endif
  extern int memory_dev_init(void);
  extern int memory_notify(unsigned long val, void *v);
  extern int memory_isolate_notify(unsigned long val, void *v);
* Unmerged path drivers/base/memory.c
* Unmerged path include/linux/memory.h
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index 20f1bc790834..4fdbacb0a28d 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -262,13 +262,7 @@ static int __meminit __add_section(int nid, unsigned long phys_start_pfn,
 		return -EEXIST;
 
 	ret = sparse_add_one_section(nid, phys_start_pfn, altmap);
-	if (ret < 0)
-		return ret;
-
-	if (!want_memblock)
-		return 0;
-
-	return hotplug_memory_register(nid, __pfn_to_section(phys_start_pfn));
+	return ret < 0 ? ret : 0;
 }
 
 /*
@@ -1156,6 +1150,13 @@ int __ref add_memory_resource(int nid, struct resource *res)
 	if (ret < 0)
 		goto error;
 
+	/* create memory block devices after memory was added */
+	ret = create_memory_block_devices(start, size);
+	if (ret) {
+		arch_remove_memory(nid, start, size, NULL);
+		goto error;
+	}
+
 	if (new_node) {
 		/* If sysfs file of new node can't be created, cpu on the node
 		 * can't be hot-added. There is no rollback way now.
