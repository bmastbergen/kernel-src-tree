ALSA: firewire-lib: code refactoring to process context payloads

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 0f5cfcb24d9c931e4571e9995bbfc08cc76d5d4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0f5cfcb2.failed

This is code refactoring for common processing for payloads of
ishocornous context.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 0f5cfcb24d9c931e4571e9995bbfc08cc76d5d4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/amdtp-stream.c
diff --cc sound/firewire/amdtp-stream.c
index 51ab268a7513,573265113a6f..000000000000
--- a/sound/firewire/amdtp-stream.c
+++ b/sound/firewire/amdtp-stream.c
@@@ -706,12 -792,13 +726,21 @@@ static void out_stream_callback(struct 
  	if (s->packet_index < 0)
  		return;
  
++<<<<<<< HEAD
 +	for (i = 0; i < packets; ++i) {
 +		u32 cycle;
++=======
+ 	generate_ideal_pkt_descs(s, s->pkt_descs, ctx_header, packets);
+ 
+ 	process_ctx_payloads(s, s->pkt_descs, packets);
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = s->pkt_descs + i;
++>>>>>>> 0f5cfcb24d9c (ALSA: firewire-lib: code refactoring to process context payloads)
  		unsigned int syt;
 +		unsigned int data_blocks;
 +		__be32 *buffer;
 +		unsigned int pcm_frames;
  		struct {
  			struct fw_iso_packet params;
  			__be32 header[IT_PKT_HEADER_SIZE_CIP / sizeof(__be32)];
@@@ -757,48 -838,23 +786,59 @@@ static void in_stream_callback(struct f
  	// The number of packets in buffer.
  	packets = header_length / s->ctx_data.tx.ctx_header_size;
  
++<<<<<<< HEAD
 +	for (i = 0; i < packets; i++) {
 +		u32 cycle;
 +		unsigned int payload_length;
 +		unsigned int data_blocks;
 +		unsigned int syt;
 +		__be32 *buffer;
 +		unsigned int pcm_frames = 0;
 +		struct fw_iso_packet params = {0};
 +		struct snd_pcm_substream *pcm;
 +		int err;
 +
 +		cycle = compute_cycle_count(ctx_header[1]);
 +		err = parse_ir_ctx_header(s, cycle, ctx_header, &payload_length,
 +					  &data_blocks, &syt, i);
 +		if (err < 0 && err != -EAGAIN)
 +			break;
 +
 +		if (err >= 0) {
 +			buffer = s->buffer.packets[s->packet_index].buffer;
 +			pcm_frames = s->process_data_blocks(s, buffer,
 +							    data_blocks, &syt);
 +
 +			if (!(s->flags & CIP_DBC_IS_END_EVENT)) {
 +				s->data_block_counter += data_blocks;
 +				s->data_block_counter &= 0xff;
 +			}
 +		}
 +
 +		if (queue_in_packet(s, &params) < 0)
 +			break;
 +
 +		pcm = READ_ONCE(s->pcm);
 +		if (pcm && pcm_frames > 0)
 +			update_pcm_pointers(s, pcm, pcm_frames);
 +
 +		ctx_header += s->ctx_data.tx.ctx_header_size / sizeof(*ctx_header);
++=======
+ 	err = generate_device_pkt_descs(s, s->pkt_descs, ctx_header, packets);
+ 	if (err < 0) {
+ 		if (err != -EAGAIN) {
+ 			cancel_stream(s);
+ 			return;
+ 		}
+ 	} else {
+ 		process_ctx_payloads(s, s->pkt_descs, packets);
++>>>>>>> 0f5cfcb24d9c (ALSA: firewire-lib: code refactoring to process context payloads)
  	}
  
 -	for (i = 0; i < packets; ++i) {
 -		struct fw_iso_packet params = {0};
 -
 -		if (queue_in_packet(s, &params) < 0) {
 -			cancel_stream(s);
 -			return;
 -		}
 +	/* Queueing error or detecting invalid payload. */
 +	if (i < packets) {
 +		cancel_stream(s);
 +		return;
  	}
  
  	fw_iso_context_queue_flush(s->context);
* Unmerged path sound/firewire/amdtp-stream.c
