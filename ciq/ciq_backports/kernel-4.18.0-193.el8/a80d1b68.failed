net/mlx5: Break load_one into three stages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Break load_one into three stages (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 95.00%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit a80d1b68c8b7a06b85434f89d138f0c28f3d27c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a80d1b68.failed

Using foundation from previous patches to factor mlx5_load_one flow
into three stages:
1. mlx5_function_setup() from previous patch to setup function
2. mlx5_init_once() from previous patch to init software objects
according to hw caps
3. New mlx5_load() to load mlx5 components

This provides a better logical separation of mlx5 core device
initialization flow and will help to seamlessly support creating different
mlx5 device types such as PF, VF and SF mlx5 sub-function virtual device.

This patch does not change any functionality.

	Signed-off-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a80d1b68c8b7a06b85434f89d138f0c28f3d27c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index 10376022a40f,b5c711cf7206..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -949,14 -918,6 +949,17 @@@ static int mlx5_load_one(struct mlx5_co
  	struct pci_dev *pdev = dev->pdev;
  	int err;
  
++<<<<<<< HEAD
 +	dev->caps.embedded_cpu = mlx5_read_embedded_cpu(dev);
 +	mutex_lock(&dev->intf_state_mutex);
 +	if (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
 +		dev_warn(&dev->pdev->dev, "%s: interface is up, NOP\n",
 +			 __func__);
 +		goto out;
 +	}
 +
++=======
++>>>>>>> a80d1b68c8b7 (net/mlx5: Break load_one into three stages)
  	dev_info(&pdev->dev, "firmware version: %d.%d.%d\n", fw_rev_maj(dev),
  		 fw_rev_min(dev), fw_rev_sub(dev));
  
@@@ -964,11 -925,6 +967,14 @@@
  	if (mlx5_core_is_pf(dev))
  		pcie_print_link_status(dev->pdev);
  
++<<<<<<< HEAD
 +	/* on load removing any previous indication of internal error, device is
 +	 * up
 +	 */
 +	dev->state = MLX5_DEVICE_STATE_UP;
 +
++=======
++>>>>>>> a80d1b68c8b7 (net/mlx5: Break load_one into three stages)
  	/* wait for firmware to accept initialization segments configurations
  	 */
  	err = wait_fw_init(dev, FW_PRE_INIT_TIMEOUT_MILI);
@@@ -1040,16 -996,44 +1046,54 @@@
  	err = mlx5_query_hca_caps(dev);
  	if (err) {
  		dev_err(&pdev->dev, "query hca failed\n");
 -		goto stop_health;
 +		goto err_stop_poll;
  	}
  
++<<<<<<< HEAD
 +	if (boot) {
 +		err = mlx5_init_once(dev, priv);
 +		if (err) {
 +			dev_err(&pdev->dev, "sw objs init failed\n");
 +			goto err_stop_poll;
 +		}
 +	}
++=======
+ 	return 0;
+ 
+ stop_health:
+ 	mlx5_stop_health_poll(dev, boot);
+ reclaim_boot_pages:
+ 	mlx5_reclaim_startup_pages(dev);
+ err_disable_hca:
+ 	mlx5_core_disable_hca(dev, 0);
+ err_cmd_cleanup:
+ 	mlx5_cmd_cleanup(dev);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5_function_teardown(struct mlx5_core_dev *dev, bool boot)
+ {
+ 	int err;
+ 
+ 	mlx5_stop_health_poll(dev, boot);
+ 	err = mlx5_cmd_teardown_hca(dev);
+ 	if (err) {
+ 		dev_err(&dev->pdev->dev, "tear_down_hca failed, skip cleanup\n");
+ 		return err;
+ 	}
+ 	mlx5_reclaim_startup_pages(dev);
+ 	mlx5_core_disable_hca(dev, 0);
+ 	mlx5_cmd_cleanup(dev);
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_load(struct mlx5_core_dev *dev)
+ {
+ 	struct pci_dev *pdev = dev->pdev;
+ 	int err;
++>>>>>>> a80d1b68c8b7 (net/mlx5: Break load_one into three stages)
  
  	dev->priv.uar = mlx5_get_uars_page(dev);
  	if (IS_ERR(dev->priv.uar)) {
@@@ -1129,58 -1181,15 +1241,67 @@@ static int mlx5_load_one(struct mlx5_co
  out:
  	mutex_unlock(&dev->intf_state_mutex);
  
- 	return 0;
+ 	return err;
  
  err_reg_dev:
++<<<<<<< HEAD
 +	mlx5_ec_cleanup(dev);
 +
 +err_ec:
 +	mlx5_sriov_detach(dev);
 +
 +err_sriov:
 +	mlx5_cleanup_fs(dev);
 +
 +err_fs:
 +	mlx5_accel_tls_cleanup(dev);
 +
 +err_tls_start:
 +	mlx5_accel_ipsec_cleanup(dev);
 +
 +err_ipsec_start:
 +	mlx5_fpga_device_stop(dev);
 +
 +err_fpga_start:
 +	mlx5_fw_tracer_cleanup(dev->tracer);
 +
 +err_fw_tracer:
 +	mlx5_eq_table_destroy(dev);
 +
 +err_eq_table:
 +	mlx5_pagealloc_stop(dev);
 +	mlx5_events_stop(dev);
 +	mlx5_put_uars_page(dev, priv->uar);
 +
 +err_get_uars:
 +	if (boot)
 +		mlx5_cleanup_once(dev);
 +
 +err_stop_poll:
 +	mlx5_stop_health_poll(dev, boot);
 +	if (mlx5_cmd_teardown_hca(dev)) {
 +		dev_err(&dev->pdev->dev, "tear_down_hca failed, skip cleanup\n");
 +		goto out_err;
 +	}
 +
 +reclaim_boot_pages:
 +	mlx5_reclaim_startup_pages(dev);
 +
 +err_disable_hca:
 +	mlx5_core_disable_hca(dev, 0);
 +
 +err_cmd_cleanup:
 +	mlx5_cmd_cleanup(dev);
 +
 +out_err:
++=======
+ 	mlx5_unload(dev);
+ err_load:
+ 	if (boot)
+ 		mlx5_cleanup_once(dev);
+ function_teardown:
+ 	mlx5_function_teardown(dev, boot);
++>>>>>>> a80d1b68c8b7 (net/mlx5: Break load_one into three stages)
  	dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
  	mutex_unlock(&dev->intf_state_mutex);
  
@@@ -1209,30 -1217,12 +1330,35 @@@ static int mlx5_unload_one(struct mlx5_
  	if (mlx5_device_registered(dev))
  		mlx5_detach_device(dev);
  
++<<<<<<< HEAD
 +	mlx5_ec_cleanup(dev);
 +	mlx5_sriov_detach(dev);
 +	mlx5_cleanup_fs(dev);
 +	mlx5_accel_ipsec_cleanup(dev);
 +	mlx5_accel_tls_cleanup(dev);
 +	mlx5_fpga_device_stop(dev);
 +	mlx5_fw_tracer_cleanup(dev->tracer);
 +	mlx5_eq_table_destroy(dev);
 +	mlx5_pagealloc_stop(dev);
 +	mlx5_events_stop(dev);
 +	mlx5_put_uars_page(dev, priv->uar);
++=======
+ 	mlx5_unload(dev);
+ 
++>>>>>>> a80d1b68c8b7 (net/mlx5: Break load_one into three stages)
  	if (cleanup)
  		mlx5_cleanup_once(dev);
 +	mlx5_stop_health_poll(dev, cleanup);
 +
 +	err = mlx5_cmd_teardown_hca(dev);
 +	if (err) {
 +		dev_err(&dev->pdev->dev, "tear_down_hca failed, skip cleanup\n");
 +		goto out;
 +	}
 +	mlx5_reclaim_startup_pages(dev);
 +	mlx5_core_disable_hca(dev, 0);
 +	mlx5_cmd_cleanup(dev);
  
 -	mlx5_function_teardown(dev, cleanup);
  out:
  	mutex_unlock(&dev->intf_state_mutex);
  	return err;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
