mm/memory_hotplug: move and simplify walk_memory_blocks()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] memory_hotplug: move and simplify walk_memory_blocks() (Baoquan He) [1724969]
Rebuild_FUZZ: 97.30%
commit-author David Hildenbrand <david@redhat.com>
commit ea8846411ad686ff626e00bb2c3821b3db2ab56a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ea884641.failed

Let's move walk_memory_blocks() to the place where memory block logic
resides and simplify it.  While at it, add a type for the callback
function.

Link: http://lkml.kernel.org/r/20190614100114.311-6-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Andrew Banman <andrew.banman@hpe.com>
	Cc: Mike Travis <mike.travis@hpe.com>
	Cc: Oscar Salvador <osalvador@suse.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Wei Yang <richard.weiyang@gmail.com>
	Cc: Arun KS <arunks@codeaurora.org>
	Cc: Qian Cai <cai@lca.pw>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ea8846411ad686ff626e00bb2c3821b3db2ab56a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/memory.c
#	include/linux/memory_hotplug.h
#	mm/memory_hotplug.c
diff --cc drivers/base/memory.c
index 25064c825e5c,0204384b4d1d..000000000000
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@@ -39,6 -39,16 +39,19 @@@ static inline int base_memory_block_id(
  	return section_nr / sections_per_block;
  }
  
++<<<<<<< HEAD
++=======
+ static inline unsigned long pfn_to_block_id(unsigned long pfn)
+ {
+ 	return base_memory_block_id(pfn_to_section_nr(pfn));
+ }
+ 
+ static inline unsigned long phys_to_block_id(unsigned long phys)
+ {
+ 	return pfn_to_block_id(PFN_DOWN(phys));
+ }
+ 
++>>>>>>> ea8846411ad6 (mm/memory_hotplug: move and simplify walk_memory_blocks())
  static int memory_subsys_online(struct device *dev);
  static int memory_subsys_offline(struct device *dev);
  
diff --cc include/linux/memory_hotplug.h
index 4408664ab5ca,475aff8efbf8..000000000000
--- a/include/linux/memory_hotplug.h
+++ b/include/linux/memory_hotplug.h
@@@ -327,8 -339,7 +327,12 @@@ static inline int remove_memory(int nid
  static inline void __remove_memory(int nid, u64 start, u64 size) {}
  #endif /* CONFIG_MEMORY_HOTREMOVE */
  
++<<<<<<< HEAD
 +extern int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,
 +		void *arg, int (*func)(struct memory_block *, void *));
++=======
+ extern void __ref free_area_init_core_hotplug(int nid);
++>>>>>>> ea8846411ad6 (mm/memory_hotplug: move and simplify walk_memory_blocks())
  extern int __add_memory(int nid, u64 start, u64 size);
  extern int add_memory(int nid, u64 start, u64 size);
  extern int add_memory_resource(int nid, struct resource *resource);
diff --cc mm/memory_hotplug.c
index 4bea0a4014ee,fafee5f13ef2..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1757,58 -1659,7 +1757,60 @@@ int offline_pages(unsigned long start_p
  {
  	return __offline_pages(start_pfn, start_pfn + nr_pages);
  }
- #endif /* CONFIG_MEMORY_HOTREMOVE */
  
++<<<<<<< HEAD
 +/**
 + * walk_memory_range - walks through all mem sections in [start_pfn, end_pfn)
 + * @start_pfn: start pfn of the memory range
 + * @end_pfn: end pfn of the memory range
 + * @arg: argument passed to func
 + * @func: callback for each memory section walked
 + *
 + * This function walks through all present mem sections in range
 + * [start_pfn, end_pfn) and call func on each mem section.
 + *
 + * Returns the return value of func.
 + */
 +int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,
 +		void *arg, int (*func)(struct memory_block *, void *))
 +{
 +	struct memory_block *mem = NULL;
 +	struct mem_section *section;
 +	unsigned long pfn, section_nr;
 +	int ret;
 +
 +	for (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {
 +		section_nr = pfn_to_section_nr(pfn);
 +		if (!present_section_nr(section_nr))
 +			continue;
 +
 +		section = __nr_to_section(section_nr);
 +		/* same memblock? */
 +		if (mem)
 +			if ((section_nr >= mem->start_section_nr) &&
 +			    (section_nr <= mem->end_section_nr))
 +				continue;
 +
 +		mem = find_memory_block_hinted(section, mem);
 +		if (!mem)
 +			continue;
 +
 +		ret = func(mem, arg);
 +		if (ret) {
 +			kobject_put(&mem->dev.kobj);
 +			return ret;
 +		}
 +	}
 +
 +	if (mem)
 +		kobject_put(&mem->dev.kobj);
 +
 +	return 0;
 +}
 +
 +#ifdef CONFIG_MEMORY_HOTREMOVE
++=======
++>>>>>>> ea8846411ad6 (mm/memory_hotplug: move and simplify walk_memory_blocks())
  static int check_memblock_offlined_cb(struct memory_block *mem, void *arg)
  {
  	int ret = !is_memblock_offlined(mem);
* Unmerged path drivers/base/memory.c
diff --git a/include/linux/memory.h b/include/linux/memory.h
index e1dc1bb2b787..e538d87efae4 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -121,6 +121,9 @@ extern int memory_isolate_notify(unsigned long val, void *v);
 extern struct memory_block *find_memory_block_hinted(struct mem_section *,
 							struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
+typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);
+extern int walk_memory_blocks(unsigned long start, unsigned long size,
+			      void *arg, walk_memory_blocks_func_t func);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 
* Unmerged path include/linux/memory_hotplug.h
* Unmerged path mm/memory_hotplug.c
