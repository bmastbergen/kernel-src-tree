SUNRPC: Move call to rpc_count_iostats before rpc_call_done

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Dave Wysochanski <dwysocha@redhat.com>
commit 9dfe52a95a60096fc12234383a19b0f436304418
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9dfe52a9.failed

For diagnostic purposes, it would be useful to have an rpc_iostats
metric of RPCs completing with tk_status < 0.  Unfortunately,
tk_status is reset inside the rpc_call_done functions for each
operation, and the call to tally the per-op metrics comes after
rpc_call_done.  Refactor the call to rpc_count_iostat earlier in
rpc_exit_task so we can count these RPCs completing in error.

	Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 9dfe52a95a60096fc12234383a19b0f436304418)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprt.c
diff --cc net/sunrpc/xprt.c
index c4d4cd12e49e,ab6b4c729ca5..000000000000
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@@ -1351,22 -1765,7 +1351,26 @@@ void xprt_release(struct rpc_task *task
  	}
  
  	xprt = req->rq_xprt;
++<<<<<<< HEAD
 +	if (task->tk_ops->rpc_count_stats != NULL)
 +		task->tk_ops->rpc_count_stats(task, task->tk_calldata);
 +	else if (task->tk_client)
 +		rpc_count_iostats(task, task->tk_client->cl_metrics);
 +	spin_lock(&xprt->recv_lock);
 +	if (!list_empty(&req->rq_list)) {
 +		list_del_init(&req->rq_list);
 +		if (xprt_is_pinned_rqst(req)) {
 +			set_bit(RPC_TASK_MSG_PIN_WAIT, &req->rq_task->tk_runstate);
 +			spin_unlock(&xprt->recv_lock);
 +			xprt_wait_on_pinned_rqst(req);
 +			spin_lock(&xprt->recv_lock);
 +			clear_bit(RPC_TASK_MSG_PIN_WAIT, &req->rq_task->tk_runstate);
 +		}
 +	}
 +	spin_unlock(&xprt->recv_lock);
++=======
+ 	xprt_request_dequeue_all(task, req);
++>>>>>>> 9dfe52a95a60 (SUNRPC: Move call to rpc_count_iostats before rpc_call_done)
  	spin_lock_bh(&xprt->transport_lock);
  	xprt->ops->release_xprt(xprt, task);
  	if (xprt->ops->release_request)
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index b92b0e9731d5..580484d6a330 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -21,6 +21,7 @@
 #include <linux/freezer.h>
 
 #include <linux/sunrpc/clnt.h>
+#include <linux/sunrpc/metrics.h>
 
 #include "sunrpc.h"
 
@@ -769,6 +770,10 @@ rpc_reset_task_statistics(struct rpc_task *task)
 void rpc_exit_task(struct rpc_task *task)
 {
 	task->tk_action = NULL;
+	if (task->tk_ops->rpc_count_stats)
+		task->tk_ops->rpc_count_stats(task, task->tk_calldata);
+	else if (task->tk_client)
+		rpc_count_iostats(task, task->tk_client->cl_metrics);
 	if (task->tk_ops->rpc_call_done != NULL) {
 		task->tk_ops->rpc_call_done(task, task->tk_calldata);
 		if (task->tk_action != NULL) {
* Unmerged path net/sunrpc/xprt.c
