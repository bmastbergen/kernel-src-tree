x86/fpu: Add an __fpregs_load_activate() internal helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Rik van Riel <riel@surriel.com>
commit 4ee91519e1dccc175665fe24bb20a47c6053575c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4ee91519.failed

Add a helper function that ensures the floating point registers for the
current task are active. Use with preemption disabled.

While at it, add fpregs_lock/unlock() helpers too, to be used in later
patches.

 [ bp: Add a comment about its intended usage. ]

	Signed-off-by: Rik van Riel <riel@surriel.com>
	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Dave Hansen <dave.hansen@intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Aubrey Li <aubrey.li@intel.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Jann Horn <jannh@google.com>
	Cc: "Jason A. Donenfeld" <Jason@zx2c4.com>
	Cc: kvm ML <kvm@vger.kernel.org>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: x86-ml <x86@kernel.org>
Link: https://lkml.kernel.org/r/20190403164156.19645-10-bigeasy@linutronix.de
(cherry picked from commit 4ee91519e1dccc175665fe24bb20a47c6053575c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/internal.h
diff --cc arch/x86/include/asm/fpu/internal.h
index 8265ef2d693b,3e0c2c496f2d..000000000000
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@@ -548,14 -534,8 +560,19 @@@ switch_fpu_prepare(struct fpu *old_fpu
   */
  static inline void switch_fpu_finish(struct fpu *new_fpu, int cpu)
  {
++<<<<<<< HEAD
 +	bool preload = static_cpu_has(X86_FEATURE_FPU) &&
 +		       new_fpu->initialized;
 +
 +	if (preload) {
 +		if (!fpregs_state_valid(new_fpu, cpu))
 +			copy_kernel_to_fpregs(&new_fpu->state);
 +		fpregs_activate(new_fpu);
 +	}
++=======
+ 	if (static_cpu_has(X86_FEATURE_FPU))
+ 		__fpregs_load_activate(new_fpu, cpu);
++>>>>>>> 4ee91519e1dc (x86/fpu: Add an __fpregs_load_activate() internal helper)
  }
  
  /*
diff --git a/arch/x86/include/asm/fpu/api.h b/arch/x86/include/asm/fpu/api.h
index a9caac9d4a72..75511c062221 100644
--- a/arch/x86/include/asm/fpu/api.h
+++ b/arch/x86/include/asm/fpu/api.h
@@ -10,6 +10,7 @@
 
 #ifndef _ASM_X86_FPU_API_H
 #define _ASM_X86_FPU_API_H
+#include <linux/preempt.h>
 
 /*
  * Careful: __kernel_fpu_begin/end() must be called with preempt disabled
@@ -27,6 +28,16 @@ extern void kernel_fpu_begin(void);
 extern void kernel_fpu_end(void);
 extern bool irq_fpu_usable(void);
 
+static inline void fpregs_lock(void)
+{
+	preempt_disable();
+}
+
+static inline void fpregs_unlock(void)
+{
+	preempt_enable();
+}
+
 /*
  * Query the presence of one or more xfeatures. Works on any legacy CPU as well.
  *
* Unmerged path arch/x86/include/asm/fpu/internal.h
