Drivers: hv: vmbus: Fix harmless building warnings without CONFIG_PM_SLEEP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [hv] vmbus: Fix harmless building warnings without CONFIG_PM_SLEEP (Mohammed Gamal) [1774675]
Rebuild_FUZZ: 90.37%
commit-author Dexuan Cui <decui@microsoft.com>
commit 83b50f83a96899f30c6369ef5988412fa2354ab2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/83b50f83.failed

If CONFIG_PM_SLEEP is not set, we can comment out these functions to avoid
the below warnings:

drivers/hv/vmbus_drv.c:2208:12: warning: ‘vmbus_bus_resume’ defined but not used [-Wunused-function]
drivers/hv/vmbus_drv.c:2128:12: warning: ‘vmbus_bus_suspend’ defined but not used [-Wunused-function]
drivers/hv/vmbus_drv.c:937:12: warning: ‘vmbus_resume’ defined but not used [-Wunused-function]
drivers/hv/vmbus_drv.c:918:12: warning: ‘vmbus_suspend’ defined but not used [-Wunused-function]

Fixes: 271b2224d42f ("Drivers: hv: vmbus: Implement suspend/resume for VSC drivers for hibernation")
Fixes: f53335e3289f ("Drivers: hv: vmbus: Suspend/resume the vmbus itself for hibernation")
	Reported-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by:  Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Sasha Levin <sashal@kernel.org>
(cherry picked from commit 83b50f83a96899f30c6369ef5988412fa2354ab2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index f6112615450a,53a60c81e220..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -909,6 -912,45 +909,48 @@@ static void vmbus_shutdown(struct devic
  		drv->shutdown(dev);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ /*
+  * vmbus_suspend - Suspend a vmbus device
+  */
+ static int vmbus_suspend(struct device *child_device)
+ {
+ 	struct hv_driver *drv;
+ 	struct hv_device *dev = device_to_hv_device(child_device);
+ 
+ 	/* The device may not be attached yet */
+ 	if (!child_device->driver)
+ 		return 0;
+ 
+ 	drv = drv_to_hv_drv(child_device->driver);
+ 	if (!drv->suspend)
+ 		return -EOPNOTSUPP;
+ 
+ 	return drv->suspend(dev);
+ }
+ 
+ /*
+  * vmbus_resume - Resume a vmbus device
+  */
+ static int vmbus_resume(struct device *child_device)
+ {
+ 	struct hv_driver *drv;
+ 	struct hv_device *dev = device_to_hv_device(child_device);
+ 
+ 	/* The device may not be attached yet */
+ 	if (!child_device->driver)
+ 		return 0;
+ 
+ 	drv = drv_to_hv_drv(child_device->driver);
+ 	if (!drv->resume)
+ 		return -EOPNOTSUPP;
+ 
+ 	return drv->resume(dev);
+ }
+ #endif /* CONFIG_PM_SLEEP */
++>>>>>>> 83b50f83a968 (Drivers: hv: vmbus: Fix harmless building warnings without CONFIG_PM_SLEEP)
  
  /*
   * vmbus_device_release - Final callback release of the vmbus child device
@@@ -1032,6 -1072,43 +1074,46 @@@ msg_handled
  	vmbus_signal_eom(msg, message_type);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ /*
+  * Fake RESCIND_CHANNEL messages to clean up hv_sock channels by force for
+  * hibernation, because hv_sock connections can not persist across hibernation.
+  */
+ static void vmbus_force_channel_rescinded(struct vmbus_channel *channel)
+ {
+ 	struct onmessage_work_context *ctx;
+ 	struct vmbus_channel_rescind_offer *rescind;
+ 
+ 	WARN_ON(!is_hvsock_channel(channel));
+ 
+ 	/*
+ 	 * sizeof(*ctx) is small and the allocation should really not fail,
+ 	 * otherwise the state of the hv_sock connections ends up in limbo.
+ 	 */
+ 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL | __GFP_NOFAIL);
+ 
+ 	/*
+ 	 * So far, these are not really used by Linux. Just set them to the
+ 	 * reasonable values conforming to the definitions of the fields.
+ 	 */
+ 	ctx->msg.header.message_type = 1;
+ 	ctx->msg.header.payload_size = sizeof(*rescind);
+ 
+ 	/* These values are actually used by Linux. */
+ 	rescind = (struct vmbus_channel_rescind_offer *)ctx->msg.u.payload;
+ 	rescind->header.msgtype = CHANNELMSG_RESCIND_CHANNELOFFER;
+ 	rescind->child_relid = channel->offermsg.child_relid;
+ 
+ 	INIT_WORK(&ctx->work, vmbus_onmessage_work);
+ 
+ 	queue_work_on(vmbus_connection.connect_cpu,
+ 		      vmbus_connection.work_queue,
+ 		      &ctx->work);
+ }
+ #endif /* CONFIG_PM_SLEEP */
++>>>>>>> 83b50f83a968 (Drivers: hv: vmbus: Fix harmless building warnings without CONFIG_PM_SLEEP)
  
  /*
   * Direct callback for channels using other deferred processing
@@@ -2046,6 -2129,131 +2128,134 @@@ acpi_walk_err
  	return ret_val;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ static int vmbus_bus_suspend(struct device *dev)
+ {
+ 	struct vmbus_channel *channel, *sc;
+ 	unsigned long flags;
+ 
+ 	while (atomic_read(&vmbus_connection.offer_in_progress) != 0) {
+ 		/*
+ 		 * We wait here until the completion of any channel
+ 		 * offers that are currently in progress.
+ 		 */
+ 		msleep(1);
+ 	}
+ 
+ 	mutex_lock(&vmbus_connection.channel_mutex);
+ 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
+ 		if (!is_hvsock_channel(channel))
+ 			continue;
+ 
+ 		vmbus_force_channel_rescinded(channel);
+ 	}
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 	/*
+ 	 * Wait until all the sub-channels and hv_sock channels have been
+ 	 * cleaned up. Sub-channels should be destroyed upon suspend, otherwise
+ 	 * they would conflict with the new sub-channels that will be created
+ 	 * in the resume path. hv_sock channels should also be destroyed, but
+ 	 * a hv_sock channel of an established hv_sock connection can not be
+ 	 * really destroyed since it may still be referenced by the userspace
+ 	 * application, so we just force the hv_sock channel to be rescinded
+ 	 * by vmbus_force_channel_rescinded(), and the userspace application
+ 	 * will thoroughly destroy the channel after hibernation.
+ 	 *
+ 	 * Note: the counter nr_chan_close_on_suspend may never go above 0 if
+ 	 * the VM has no sub-channel and hv_sock channel, e.g. a 1-vCPU VM.
+ 	 */
+ 	if (atomic_read(&vmbus_connection.nr_chan_close_on_suspend) > 0)
+ 		wait_for_completion(&vmbus_connection.ready_for_suspend_event);
+ 
+ 	WARN_ON(atomic_read(&vmbus_connection.nr_chan_fixup_on_resume) != 0);
+ 
+ 	mutex_lock(&vmbus_connection.channel_mutex);
+ 
+ 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
+ 		/*
+ 		 * Invalidate the field. Upon resume, vmbus_onoffer() will fix
+ 		 * up the field, and the other fields (if necessary).
+ 		 */
+ 		channel->offermsg.child_relid = INVALID_RELID;
+ 
+ 		if (is_hvsock_channel(channel)) {
+ 			if (!channel->rescind) {
+ 				pr_err("hv_sock channel not rescinded!\n");
+ 				WARN_ON_ONCE(1);
+ 			}
+ 			continue;
+ 		}
+ 
+ 		spin_lock_irqsave(&channel->lock, flags);
+ 		list_for_each_entry(sc, &channel->sc_list, sc_list) {
+ 			pr_err("Sub-channel not deleted!\n");
+ 			WARN_ON_ONCE(1);
+ 		}
+ 		spin_unlock_irqrestore(&channel->lock, flags);
+ 
+ 		atomic_inc(&vmbus_connection.nr_chan_fixup_on_resume);
+ 	}
+ 
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 	vmbus_initiate_unload(false);
+ 
+ 	vmbus_connection.conn_state = DISCONNECTED;
+ 
+ 	/* Reset the event for the next resume. */
+ 	reinit_completion(&vmbus_connection.ready_for_resume_event);
+ 
+ 	return 0;
+ }
+ 
+ static int vmbus_bus_resume(struct device *dev)
+ {
+ 	struct vmbus_channel_msginfo *msginfo;
+ 	size_t msgsize;
+ 	int ret;
+ 
+ 	/*
+ 	 * We only use the 'vmbus_proto_version', which was in use before
+ 	 * hibernation, to re-negotiate with the host.
+ 	 */
+ 	if (vmbus_proto_version == VERSION_INVAL ||
+ 	    vmbus_proto_version == 0) {
+ 		pr_err("Invalid proto version = 0x%x\n", vmbus_proto_version);
+ 		return -EINVAL;
+ 	}
+ 
+ 	msgsize = sizeof(*msginfo) +
+ 		  sizeof(struct vmbus_channel_initiate_contact);
+ 
+ 	msginfo = kzalloc(msgsize, GFP_KERNEL);
+ 
+ 	if (msginfo == NULL)
+ 		return -ENOMEM;
+ 
+ 	ret = vmbus_negotiate_version(msginfo, vmbus_proto_version);
+ 
+ 	kfree(msginfo);
+ 
+ 	if (ret != 0)
+ 		return ret;
+ 
+ 	WARN_ON(atomic_read(&vmbus_connection.nr_chan_fixup_on_resume) == 0);
+ 
+ 	vmbus_request_offers();
+ 
+ 	wait_for_completion(&vmbus_connection.ready_for_resume_event);
+ 
+ 	/* Reset the event for the next suspend. */
+ 	reinit_completion(&vmbus_connection.ready_for_suspend_event);
+ 
+ 	return 0;
+ }
+ #endif /* CONFIG_PM_SLEEP */
+ 
++>>>>>>> 83b50f83a968 (Drivers: hv: vmbus: Fix harmless building warnings without CONFIG_PM_SLEEP)
  static const struct acpi_device_id vmbus_acpi_device_ids[] = {
  	{"VMBUS", 0},
  	{"VMBus", 0},
* Unmerged path drivers/hv/vmbus_drv.c
