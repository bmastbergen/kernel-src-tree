net/mlx5: E-switch, Introduce helper function to enable/disable vports

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-switch, Introduce helper function to enable/disable vports (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 97.06%
commit-author Parav Pandit <parav@mellanox.com>
commit 5019833d661f5edb6bd63abd3da064d2517966b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5019833d.failed

vports needs to be enabled in switchdev and legacy mode.

In switchdev mode, vports should be enabled after initializing
the FDB tables and before creating their represntors so that
representor works on an initialized vport object.

Prepare a helper function which can be called when enabling either of
the eswitch modes.

Similarly, have disable vports helper function.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 5019833d661f5edb6bd63abd3da064d2517966b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 0fb996a72fb2,6d82aefae6e1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -62,16 -61,24 +62,31 @@@ struct vport_addr 
  static void esw_destroy_legacy_fdb_table(struct mlx5_eswitch *esw);
  static void esw_cleanup_vepa_rules(struct mlx5_eswitch *esw);
  
++<<<<<<< HEAD
 +/* Vport context events */
 +#define SRIOV_VPORT_EVENTS (UC_ADDR_CHANGE | \
 +			    MC_ADDR_CHANGE | \
 +			    PROMISC_CHANGE)
++=======
+ struct mlx5_vport *__must_check
+ mlx5_eswitch_get_vport(struct mlx5_eswitch *esw, u16 vport_num)
+ {
+ 	u16 idx;
+ 
+ 	if (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager))
+ 		return ERR_PTR(-EPERM);
+ 
+ 	idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	if (idx > esw->total_vports - 1) {
+ 		esw_debug(esw->dev, "vport out of range: num(0x%x), idx(0x%x)\n",
+ 			  vport_num, idx);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	return &esw->vports[idx];
+ }
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  
  static int arm_vport_context_events_cmd(struct mlx5_core_dev *dev, u16 vport,
  					u32 events_mask)
@@@ -884,28 -890,22 +899,46 @@@ static void esw_vport_change_handle_loc
  	esw_debug(dev, "vport[%d] Context Changed: perm mac: %pM\n",
  		  vport->vport, mac);
  
++<<<<<<< HEAD
 +	if (vport->enabled_events & UC_ADDR_CHANGE) {
 +		esw_update_vport_addr_list(esw, vport->vport,
 +					   MLX5_NVPRT_LIST_TYPE_UC);
 +		esw_apply_vport_addr_list(esw, vport->vport,
 +					  MLX5_NVPRT_LIST_TYPE_UC);
 +	}
 +
 +	if (vport->enabled_events & MC_ADDR_CHANGE) {
 +		esw_update_vport_addr_list(esw, vport->vport,
 +					   MLX5_NVPRT_LIST_TYPE_MC);
 +	}
 +
 +	if (vport->enabled_events & PROMISC_CHANGE) {
 +		esw_update_vport_rx_mode(esw, vport->vport);
++=======
+ 	if (vport->enabled_events & MLX5_VPORT_UC_ADDR_CHANGE) {
+ 		esw_update_vport_addr_list(esw, vport, MLX5_NVPRT_LIST_TYPE_UC);
+ 		esw_apply_vport_addr_list(esw, vport, MLX5_NVPRT_LIST_TYPE_UC);
+ 	}
+ 
+ 	if (vport->enabled_events & MLX5_VPORT_MC_ADDR_CHANGE)
+ 		esw_update_vport_addr_list(esw, vport, MLX5_NVPRT_LIST_TYPE_MC);
+ 
+ 	if (vport->enabled_events & MLX5_VPORT_PROMISC_CHANGE) {
+ 		esw_update_vport_rx_mode(esw, vport);
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  		if (!IS_ERR_OR_NULL(vport->allmulti_rule))
 -			esw_update_vport_mc_promisc(esw, vport);
 +			esw_update_vport_mc_promisc(esw, vport->vport);
  	}
  
++<<<<<<< HEAD
 +	if (vport->enabled_events & (PROMISC_CHANGE | MC_ADDR_CHANGE)) {
 +		esw_apply_vport_addr_list(esw, vport->vport,
 +					  MLX5_NVPRT_LIST_TYPE_MC);
 +	}
++=======
+ 	if (vport->enabled_events & (MLX5_VPORT_PROMISC_CHANGE | MLX5_VPORT_MC_ADDR_CHANGE))
+ 		esw_apply_vport_addr_list(esw, vport, MLX5_NVPRT_LIST_TYPE_MC);
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  
  	esw_debug(esw->dev, "vport[%d] Context Changed: Done\n", vport->vport);
  	if (vport->enabled)
@@@ -1626,10 -1637,10 +1659,15 @@@ static void esw_vport_destroy_drop_coun
  		mlx5_fc_destroy(dev, vport->egress.drop_counter);
  }
  
++<<<<<<< HEAD
 +static void esw_enable_vport(struct mlx5_eswitch *esw, int vport_num,
 +			     int enable_events)
++=======
+ static void esw_enable_vport(struct mlx5_eswitch *esw, struct mlx5_vport *vport,
+ 			     enum mlx5_eswitch_vport_event enabled_events)
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  {
 -	u16 vport_num = vport->vport;
 +	struct mlx5_vport *vport = &esw->vports[vport_num];
  
  	mutex_lock(&esw->state_lock);
  	WARN_ON(vport->enabled);
@@@ -1649,11 -1660,14 +1687,11 @@@
  		esw_warn(esw->dev, "Failed to attach vport %d to eswitch rate limiter", vport_num);
  
  	/* Sync with current vport context */
- 	vport->enabled_events = enable_events;
+ 	vport->enabled_events = enabled_events;
  	vport->enabled = true;
  
 -	/* Esw manager is trusted by default. Host PF (vport 0) is trusted as well
 -	 * in smartNIC as it's a vport group manager.
 -	 */
 -	if (esw->manager_vport == vport_num ||
 -	    (!vport_num && mlx5_core_is_ecpf(esw->dev)))
 +	/* only PF is trusted by default */
 +	if (!vport_num)
  		vport->info.trusted = true;
  
  	esw_vport_change_handle_locked(vport);
@@@ -1719,10 -1737,103 +1757,56 @@@ static int eswitch_vport_event(struct n
  /* Public E-Switch API */
  #define ESW_ALLOWED(esw) ((esw) && MLX5_ESWITCH_MANAGER((esw)->dev))
  
++<<<<<<< HEAD
 +int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
 +{
++=======
+ /* mlx5_eswitch_enable_pf_vf_vports() enables vports of PF, ECPF and VFs
+  * whichever are present on the eswitch.
+  */
+ void
+ mlx5_eswitch_enable_pf_vf_vports(struct mlx5_eswitch *esw,
+ 				 enum mlx5_eswitch_vport_event enabled_events)
+ {
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	/* Enable PF vport */
+ 	vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_PF);
+ 	esw_enable_vport(esw, vport, enabled_events);
+ 
+ 	/* Enable ECPF vports */
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_ECPF);
+ 		esw_enable_vport(esw, vport, enabled_events);
+ 	}
+ 
+ 	/* Enable VF vports */
+ 	mlx5_esw_for_each_vf_vport(esw, i, vport, esw->esw_funcs.num_vfs)
+ 		esw_enable_vport(esw, vport, enabled_events);
+ }
+ 
+ /* mlx5_eswitch_disable_pf_vf_vports() disables vports of PF, ECPF and VFs
+  * whichever are previously enabled on the eswitch.
+  */
+ void mlx5_eswitch_disable_pf_vf_vports(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	mlx5_esw_for_all_vports_reverse(esw, i, vport)
+ 		esw_disable_vport(esw, vport);
+ }
+ 
+ #define MLX5_LEGACY_SRIOV_VPORT_EVENTS (MLX5_VPORT_UC_ADDR_CHANGE | \
+ 					MLX5_VPORT_MC_ADDR_CHANGE | \
+ 					MLX5_VPORT_PROMISC_CHANGE)
+ 
+ int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int mode)
+ {
+ 	int enabled_events;
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  	int err;
- 	int i, enabled_events;
  
  	if (!ESW_ALLOWED(esw) ||
  	    !MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, ft_support)) {
@@@ -1755,25 -1866,17 +1839,39 @@@
  	if (err)
  		goto abort;
  
++<<<<<<< HEAD
 +	err = esw_create_tsar(esw);
 +	if (err)
 +		esw_warn(esw->dev, "Failed to create eswitch TSAR");
 +
 +	/* Don't enable vport events when in SRIOV_OFFLOADS mode, since:
 +	 * 1. L2 table (MPFS) is programmed by PF/VF representors netdevs set_rx_mode
 +	 * 2. FDB/Eswitch is programmed by user space tools
 +	 */
 +	enabled_events = (mode == SRIOV_LEGACY) ? SRIOV_VPORT_EVENTS : 0;
 +	for (i = 0; i <= nvfs; i++)
 +		esw_enable_vport(esw, i, enabled_events);
 +
 +	if (mode == SRIOV_LEGACY) {
 +		MLX5_NB_INIT(&esw->nb, eswitch_vport_event, NIC_VPORT_CHANGE);
 +		mlx5_eq_notifier_register(esw->dev, &esw->nb);
 +	}
 +
 +	esw_info(esw->dev, "SRIOV enabled: active vports(%d)\n",
 +		 esw->enabled_vports);
++=======
+ 	enabled_events = (mode == MLX5_ESWITCH_LEGACY) ? MLX5_LEGACY_SRIOV_VPORT_EVENTS :
+ 		MLX5_VPORT_UC_ADDR_CHANGE;
+ 
+ 	mlx5_eswitch_enable_pf_vf_vports(esw, enabled_events);
+ 
+ 	mlx5_eswitch_event_handlers_register(esw);
+ 
+ 	esw_info(esw->dev, "Enable: mode(%s), nvfs(%d), active vports(%d)\n",
+ 		 mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
+ 		 esw->esw_funcs.num_vfs, esw->enabled_vports);
+ 
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  	return 0;
  
  abort:
@@@ -1791,23 -1894,18 +1889,30 @@@ void mlx5_eswitch_disable_sriov(struct 
  {
  	struct esw_mc_addr *mc_promisc;
  	int old_mode;
++<<<<<<< HEAD
 +	int nvports;
 +	int i;
++=======
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  
 -	if (!ESW_ALLOWED(esw) || esw->mode == MLX5_ESWITCH_NONE)
 +	if (!ESW_ALLOWED(esw) || esw->mode == SRIOV_NONE)
  		return;
  
 -	esw_info(esw->dev, "Disable: mode(%s), nvfs(%d), active vports(%d)\n",
 -		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
 -		 esw->esw_funcs.num_vfs, esw->enabled_vports);
 +	esw_info(esw->dev, "disable SRIOV: active vports(%d) mode(%d)\n",
 +		 esw->enabled_vports, esw->mode);
  
  	mc_promisc = &esw->mc_promisc;
 -	mlx5_eswitch_event_handlers_unregister(esw);
 +	nvports = esw->enabled_vports;
 +
++<<<<<<< HEAD
 +	if (esw->mode == SRIOV_LEGACY)
 +		mlx5_eq_notifier_unregister(esw->dev, &esw->nb);
  
 +	for (i = 0; i < esw->total_vports; i++)
 +		esw_disable_vport(esw, i);
++=======
+ 	mlx5_eswitch_disable_pf_vf_vports(esw);
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  
  	if (mc_promisc && mc_promisc->uplink_rule)
  		mlx5_del_flow_rules(mc_promisc->uplink_rule);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index af9a875f1cf1,3103a34c619c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -395,6 -448,149 +402,88 @@@ bool mlx5_esw_multipath_prereq(struct m
  /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
  void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
  
++<<<<<<< HEAD
++=======
+ /* The vport getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_vports(esw, i, vport)		\
+ 	for ((i) = MLX5_VPORT_PF;			\
+ 	     (vport) = &(esw)->vports[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_all_vports_reverse(esw, i, vport)	\
+ 	for ((i) = (esw)->total_vports - 1;		\
+ 	     (vport) = &(esw)->vports[i],		\
+ 	     (i) >= MLX5_VPORT_PF; (i)--)
+ 
+ #define mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)	\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;			\
+ 	     (vport) = &(esw)->vports[(i)],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_reverse(esw, i, vport, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (vport) = &(esw)->vports[(i)],			\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ /* The rep getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_reps(esw, i, rep)			\
+ 	for ((i) = MLX5_VPORT_PF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep(esw, i, rep, nvfs)		\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ #define mlx5_esw_for_each_vf_vport_num(esw, vport, nvfs)	\
+ 	for ((vport) = MLX5_VPORT_FIRST_VF; (vport) <= (nvfs); (vport)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_num_reverse(esw, vport, nvfs)	\
+ 	for ((vport) = (nvfs); (vport) >= MLX5_VPORT_FIRST_VF; (vport)--)
+ 
+ /* Includes host PF (vport 0) if it's not esw manager. */
+ #define mlx5_esw_for_each_host_func_rep(esw, i, rep, nvfs)	\
+ 	for ((i) = (esw)->first_host_vport;			\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_host_func_rep_reverse(esw, i, rep, nvfs)	\
+ 	for ((i) = (nvfs);						\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],			\
+ 	     (i) >= (esw)->first_host_vport; (i)--)
+ 
+ #define mlx5_esw_for_each_host_func_vport(esw, vport, nvfs)	\
+ 	for ((vport) = (esw)->first_host_vport;			\
+ 	     (vport) <= (nvfs); (vport)++)
+ 
+ #define mlx5_esw_for_each_host_func_vport_reverse(esw, vport, nvfs)	\
+ 	for ((vport) = (nvfs);						\
+ 	     (vport) >= (esw)->first_host_vport; (vport)--)
+ 
+ struct mlx5_vport *__must_check
+ mlx5_eswitch_get_vport(struct mlx5_eswitch *esw, u16 vport_num);
+ 
+ bool mlx5_eswitch_is_vf_vport(const struct mlx5_eswitch *esw, u16 vport_num);
+ 
+ void mlx5_eswitch_update_num_of_vfs(struct mlx5_eswitch *esw, const int num_vfs);
+ int mlx5_esw_funcs_changed_handler(struct notifier_block *nb, unsigned long type, void *data);
+ 
+ void
+ mlx5_eswitch_enable_pf_vf_vports(struct mlx5_eswitch *esw,
+ 				 enum mlx5_eswitch_vport_event enabled_events);
+ void mlx5_eswitch_disable_pf_vf_vports(struct mlx5_eswitch *esw);
+ 
++>>>>>>> 5019833d661f (net/mlx5: E-switch, Introduce helper function to enable/disable vports)
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
