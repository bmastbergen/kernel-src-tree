efi/memreserve: Register reservations as 'reserved' in /proc/iomem

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit ab0eb16205b43ece4c78e2259e681ff3d645ea66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ab0eb162.failed

Memory regions that are reserved using efi_mem_reserve_persistent()
are recorded in a special EFI config table which survives kexec,
allowing the incoming kernel to honour them as well. However,
such reservations are not visible in /proc/iomem, and so the kexec
tools that load the incoming kernel and its initrd into memory may
overwrite these reserved regions before the incoming kernel has a
chance to reserve them from further use.

Address this problem by adding these reservations to /proc/iomem as
they are created. Note that reservations that are inherited from a
previous kernel are memblock_reserve()'d early on, so they are already
visible in /proc/iomem.

	Tested-by: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
	Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
	Reviewed-by: Bhupesh Sharma <bhsharma@redhat.com>
	Cc: <stable@vger.kernel.org> # v5.4+
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Arvind Sankar <nivedita@alum.mit.edu>
	Cc: linux-efi@vger.kernel.org
Link: https://lkml.kernel.org/r/20191206165542.31469-2-ardb@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ab0eb16205b43ece4c78e2259e681ff3d645ea66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
diff --cc drivers/firmware/efi/efi.c
index b6e569a9a368,b0961950d918..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -1019,8 -1020,10 +1037,13 @@@ int __ref efi_mem_reserve_persistent(ph
  			rsv->entry[index].base = addr;
  			rsv->entry[index].size = size;
  
++<<<<<<< HEAD
 +			return 0;
++=======
+ 			memunmap(rsv);
+ 			return efi_mem_reserve_iomem(addr, size);
++>>>>>>> ab0eb16205b4 (efi/memreserve: Register reservations as 'reserved' in /proc/iomem)
  		}
 -		memunmap(rsv);
  	}
  
  	/* no slot found - allocate a new linked list entry */
@@@ -1028,7 -1031,19 +1051,23 @@@
  	if (!rsv)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	rsv->size = EFI_MEMRESERVE_COUNT(PAGE_SIZE);
++=======
+ 	rc = efi_mem_reserve_iomem(__pa(rsv), SZ_4K);
+ 	if (rc) {
+ 		free_page((unsigned long)rsv);
+ 		return rc;
+ 	}
+ 
+ 	/*
+ 	 * The memremap() call above assumes that a linux_efi_memreserve entry
+ 	 * never crosses a page boundary, so let's ensure that this remains true
+ 	 * even when kexec'ing a 4k pages kernel from a >4k pages kernel, by
+ 	 * using SZ_4K explicitly in the size calculation below.
+ 	 */
+ 	rsv->size = EFI_MEMRESERVE_COUNT(SZ_4K);
++>>>>>>> ab0eb16205b4 (efi/memreserve: Register reservations as 'reserved' in /proc/iomem)
  	atomic_set(&rsv->count, 1);
  	rsv->entry[0].base = addr;
  	rsv->entry[0].size = size;
* Unmerged path drivers/firmware/efi/efi.c
