arm64: errata: Hide CTR_EL0.DIC on systems affected by Neoverse-N1 #1542419

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author James Morse <james.morse@arm.com>
commit 05460849c3b51180d5ada3373d0449aea19075e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/05460849.failed

Cores affected by Neoverse-N1 #1542419 could execute a stale instruction
when a branch is updated to point to freshly generated instructions.

To workaround this issue we need user-space to issue unnecessary
icache maintenance that we can trap. Start by hiding CTR_EL0.DIC.

	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: James Morse <james.morse@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 05460849c3b51180d5ada3373d0449aea19075e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/arm64/silicon-errata.rst
#	arch/arm64/Kconfig
#	arch/arm64/include/asm/cpucaps.h
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/Kconfig
index a2ff4c9fea5e,7c3e3e334421..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -525,6 -522,58 +525,61 @@@ config ARM64_ERRATUM_116552
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
++=======
+ config ARM64_ERRATUM_1286807
+ 	bool "Cortex-A76: Modification of the translation table for a virtual address might lead to read-after-read ordering violation"
+ 	default y
+ 	select ARM64_WORKAROUND_REPEAT_TLBI
+ 	help
+ 	  This option adds a workaround for ARM Cortex-A76 erratum 1286807.
+ 
+ 	  On the affected Cortex-A76 cores (r0p0 to r3p0), if a virtual
+ 	  address for a cacheable mapping of a location is being
+ 	  accessed by a core while another core is remapping the virtual
+ 	  address to a new physical page using the recommended
+ 	  break-before-make sequence, then under very rare circumstances
+ 	  TLBI+DSB completes before a read using the translation being
+ 	  invalidated has been observed by other observers. The
+ 	  workaround repeats the TLBI+DSB operation.
+ 
+ 	  If unsure, say Y.
+ 
+ config ARM64_ERRATUM_1463225
+ 	bool "Cortex-A76: Software Step might prevent interrupt recognition"
+ 	default y
+ 	help
+ 	  This option adds a workaround for Arm Cortex-A76 erratum 1463225.
+ 
+ 	  On the affected Cortex-A76 cores (r0p0 to r3p1), software stepping
+ 	  of a system call instruction (SVC) can prevent recognition of
+ 	  subsequent interrupts when software stepping is disabled in the
+ 	  exception handler of the system call and either kernel debugging
+ 	  is enabled or VHE is in use.
+ 
+ 	  Work around the erratum by triggering a dummy step exception
+ 	  when handling a system call from a task that is being stepped
+ 	  in a VHE configuration of the kernel.
+ 
+ 	  If unsure, say Y.
+ 
+ config ARM64_ERRATUM_1542419
+ 	bool "Neoverse-N1: workaround mis-ordering of instruction fetches"
+ 	default y
+ 	help
+ 	  This option adds a workaround for ARM Neoverse-N1 erratum
+ 	  1542419.
+ 
+ 	  Affected Neoverse-N1 cores could execute a stale instruction when
+ 	  modified by another CPU. The workaround depends on a firmware
+ 	  counterpart.
+ 
+ 	  Workaround the issue by hiding the DIC feature from EL0. This
+ 	  forces user-space to perform cache maintenance.
+ 
+ 	  If unsure, say Y.
+ 
++>>>>>>> 05460849c3b5 (arm64: errata: Hide CTR_EL0.DIC on systems affected by Neoverse-N1 #1542419)
  config CAVIUM_ERRATUM_22375
  	bool "Cavium erratum 22375, 24313"
  	default y
diff --cc arch/arm64/include/asm/cpucaps.h
index 1a8df16d556c,f05afaec18cd..000000000000
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@@ -51,11 -40,20 +51,25 @@@
  #define ARM64_SSBD				30
  #define ARM64_MISMATCHED_CACHE_TYPE		31
  #define ARM64_HAS_STAGE2_FWB			32
 -#define ARM64_HAS_CRC32				33
 +#define ARM64_WORKAROUND_1188873		33
  #define ARM64_SSBS				34
 -#define ARM64_WORKAROUND_1418040		35
 +#define ARM64_WORKAROUND_1165522		35
  #define ARM64_HAS_SB				36
++<<<<<<< HEAD
 +
 +#define ARM64_NCAPS				37
++=======
+ #define ARM64_WORKAROUND_1165522		37
+ #define ARM64_HAS_ADDRESS_AUTH_ARCH		38
+ #define ARM64_HAS_ADDRESS_AUTH_IMP_DEF		39
+ #define ARM64_HAS_GENERIC_AUTH_ARCH		40
+ #define ARM64_HAS_GENERIC_AUTH_IMP_DEF		41
+ #define ARM64_HAS_IRQ_PRIO_MASKING		42
+ #define ARM64_HAS_DCPODP			43
+ #define ARM64_WORKAROUND_1463225		44
+ #define ARM64_WORKAROUND_1542419		45
+ 
+ #define ARM64_NCAPS				46
++>>>>>>> 05460849c3b5 (arm64: errata: Hide CTR_EL0.DIC on systems affected by Neoverse-N1 #1542419)
  
  #endif /* __ASM_CPUCAPS_H */
diff --cc arch/arm64/kernel/cpu_errata.c
index feeb8962a8d8,3ae9b78b6d94..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -828,6 -864,24 +848,27 @@@ const struct arm64_cpu_capabilities arm
  		ERRATA_MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
  	},
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_1463225
+ 	{
+ 		.desc = "ARM erratum 1463225",
+ 		.capability = ARM64_WORKAROUND_1463225,
+ 		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
+ 		.matches = has_cortex_a76_erratum_1463225,
+ 	},
+ #endif
+ #ifdef CONFIG_ARM64_ERRATUM_1542419
+ 	{
+ 		/* we depend on the firmware portion for correctness */
+ 		.desc = "ARM erratum 1542419 (kernel portion)",
+ 		.capability = ARM64_WORKAROUND_1542419,
+ 		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
+ 		.matches = has_neoverse_n1_erratum_1542419,
+ 		.cpu_enable = cpu_enable_trap_ctr_access,
+ 	},
+ #endif
++>>>>>>> 05460849c3b5 (arm64: errata: Hide CTR_EL0.DIC on systems affected by Neoverse-N1 #1542419)
  	{
  	}
  };
* Unmerged path Documentation/arm64/silicon-errata.rst
* Unmerged path Documentation/arm64/silicon-errata.rst
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/include/asm/cpucaps.h
* Unmerged path arch/arm64/kernel/cpu_errata.c
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index 6da589ed3e5a..d7cbe32e7e1a 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -485,6 +485,9 @@ static void ctr_read_handler(unsigned int esr, struct pt_regs *regs)
 	int rt = ESR_ELx_SYS64_ISS_RT(esr);
 	unsigned long val = arm64_ftr_reg_user_value(&arm64_ftr_reg_ctrel0);
 
+	if (cpus_have_const_cap(ARM64_WORKAROUND_1542419))
+		val &= ~BIT(CTR_DIC_SHIFT);
+
 	pt_regs_write_reg(regs, rt, val);
 
 	arm64_skip_faulting_instruction(regs, AARCH64_INSN_SIZE);
