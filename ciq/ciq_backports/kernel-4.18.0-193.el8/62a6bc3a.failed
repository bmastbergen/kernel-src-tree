driver: core: Allow subsystems to continue deferring probe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Thierry Reding <treding@nvidia.com>
commit 62a6bc3a1e4f4ee9ae0076fa295f9af1c3725ce3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/62a6bc3a.failed

Some subsystems, such as pinctrl, allow continuing to defer probe
indefinitely. This is useful for devices that depend on resources
provided by devices that are only probed after the init stage.

One example of this can be seen on Tegra, where the DPAUX hardware
contains pinmuxing controls for pins that it shares with an I2C
controller. The I2C controller is typically used for communication
with a monitor over HDMI (DDC). However, other instances of the I2C
controller are used to access system critical components, such as a
PMIC. The I2C controller driver will therefore usually be a builtin
driver, whereas the DPAUX driver is part of the display driver that
is loaded from a module to avoid bloating the kernel image with all
of the DRM/KMS subsystem.

In this particular case the pins used by this I2C/DDC controller
become accessible very late in the boot process. However, since the
controller is only used in conjunction with display, that's not an
issue.

Unfortunately the driver core currently outputs a warning message
when a device fails to get the pinctrl before the end of the init
stage. That can be confusing for the user because it may sound like
an unwanted error occurred, whereas it's really an expected and
harmless situation.

In order to eliminate this warning, this patch allows callers of the
driver_deferred_probe_check_state() helper to specify that they want
to continue deferring probe, regardless of whether we're past the
init stage or not. All of the callers of that function are updated
for the new signature, but only the pinctrl subsystem passes a true
value in the new persist parameter if appropriate.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
Link: https://lore.kernel.org/r/20190621151725.20414-1-thierry.reding@gmail.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 62a6bc3a1e4f4ee9ae0076fa295f9af1c3725ce3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
#	drivers/pinctrl/devicetree.c
#	include/linux/device.h
diff --cc drivers/base/dd.c
index e542ffec3960,994a90747420..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -224,6 -206,111 +224,114 @@@ void device_unblock_probing(void
  	driver_deferred_probe_trigger();
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * deferred_devs_show() - Show the devices in the deferred probe pending list.
+  */
+ static int deferred_devs_show(struct seq_file *s, void *data)
+ {
+ 	struct device_private *curr;
+ 
+ 	mutex_lock(&deferred_probe_mutex);
+ 
+ 	list_for_each_entry(curr, &deferred_probe_pending_list, deferred_probe)
+ 		seq_printf(s, "%s\n", dev_name(curr->device));
+ 
+ 	mutex_unlock(&deferred_probe_mutex);
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(deferred_devs);
+ 
+ static int deferred_probe_timeout = -1;
+ static int __init deferred_probe_timeout_setup(char *str)
+ {
+ 	int timeout;
+ 
+ 	if (!kstrtoint(str, 10, &timeout))
+ 		deferred_probe_timeout = timeout;
+ 	return 1;
+ }
+ __setup("deferred_probe_timeout=", deferred_probe_timeout_setup);
+ 
+ static int __driver_deferred_probe_check_state(struct device *dev)
+ {
+ 	if (!initcalls_done)
+ 		return -EPROBE_DEFER;
+ 
+ 	if (!deferred_probe_timeout) {
+ 		dev_WARN(dev, "deferred probe timeout, ignoring dependency");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * driver_deferred_probe_check_state() - Check deferred probe state
+  * @dev: device to check
+  *
+  * Returns -ENODEV if init is done and all built-in drivers have had a chance
+  * to probe (i.e. initcalls are done), -ETIMEDOUT if deferred probe debug
+  * timeout has expired, or -EPROBE_DEFER if none of those conditions are met.
+  *
+  * Drivers or subsystems can opt-in to calling this function instead of directly
+  * returning -EPROBE_DEFER.
+  */
+ int driver_deferred_probe_check_state(struct device *dev)
+ {
+ 	int ret;
+ 
+ 	ret = __driver_deferred_probe_check_state(dev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	dev_warn(dev, "ignoring dependency for device, assuming no driver");
+ 
+ 	return -ENODEV;
+ }
+ 
+ /**
+  * driver_deferred_probe_check_state_continue() - check deferred probe state
+  * @dev: device to check
+  *
+  * Returns -ETIMEDOUT if deferred probe debug timeout has expired, or
+  * -EPROBE_DEFER otherwise.
+  *
+  * Drivers or subsystems can opt-in to calling this function instead of
+  * directly returning -EPROBE_DEFER.
+  *
+  * This is similar to driver_deferred_probe_check_state(), but it allows the
+  * subsystem to keep deferring probe after built-in drivers have had a chance
+  * to probe. One scenario where that is useful is if built-in drivers rely on
+  * resources that are provided by modular drivers.
+  */
+ int driver_deferred_probe_check_state_continue(struct device *dev)
+ {
+ 	int ret;
+ 
+ 	ret = __driver_deferred_probe_check_state(dev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return -EPROBE_DEFER;
+ }
+ 
+ static void deferred_probe_timeout_work_func(struct work_struct *work)
+ {
+ 	struct device_private *private, *p;
+ 
+ 	deferred_probe_timeout = 0;
+ 	driver_deferred_probe_trigger();
+ 	flush_work(&deferred_probe_work);
+ 
+ 	list_for_each_entry_safe(private, p, &deferred_probe_pending_list, deferred_probe)
+ 		dev_info(private->device, "deferred probe pending");
+ }
+ static DECLARE_DELAYED_WORK(deferred_probe_timeout_work, deferred_probe_timeout_work_func);
+ 
++>>>>>>> 62a6bc3a1e4f (driver: core: Allow subsystems to continue deferring probe)
  /**
   * deferred_probe_initcall() - Enable probing of deferred devices
   *
diff --cc drivers/pinctrl/devicetree.c
index c4aa411f5935,88ddbb2e30de..000000000000
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@@ -115,13 -105,18 +115,21 @@@ static int dt_to_map_one_config(struct 
  	/* Find the pin controller containing np_config */
  	np_pctldev = of_node_get(np_config);
  	for (;;) {
 -		if (!allow_default)
 -			allow_default = of_property_read_bool(np_pctldev,
 -							      "pinctrl-use-default");
 -
  		np_pctldev = of_get_next_parent(np_pctldev);
  		if (!np_pctldev || of_node_is_root(np_pctldev)) {
 +			dev_info(p->dev, "could not find pctldev for node %pOF, deferring probe\n",
 +				np_config);
  			of_node_put(np_pctldev);
++<<<<<<< HEAD
 +			/* OK let's just assume this will appear later then */
 +			return -EPROBE_DEFER;
++=======
+ 			/* keep deferring if modules are enabled unless we've timed out */
+ 			if (IS_ENABLED(CONFIG_MODULES) && !allow_default)
+ 				return driver_deferred_probe_check_state_continue(p->dev);
+ 
+ 			return driver_deferred_probe_check_state(p->dev);
++>>>>>>> 62a6bc3a1e4f (driver: core: Allow subsystems to continue deferring probe)
  		}
  		/* If we're creating a hog we can use the passed pctldev */
  		if (hog_pctldev && (np_pctldev == p->dev->of_node)) {
diff --cc include/linux/device.h
index 6eab71e749c7,ef61e2d50ecc..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -350,8 -338,12 +350,17 @@@ extern int __must_check driver_for_each
  					       int (*fn)(struct device *dev,
  							 void *));
  struct device *driver_find_device(struct device_driver *drv,
++<<<<<<< HEAD
 +				  struct device *start, void *data,
 +				  int (*match)(struct device *dev, void *data));
++=======
+ 				  struct device *start, const void *data,
+ 				  int (*match)(struct device *dev, const void *data));
+ 
+ void driver_deferred_probe_add(struct device *dev);
+ int driver_deferred_probe_check_state(struct device *dev);
+ int driver_deferred_probe_check_state_continue(struct device *dev);
++>>>>>>> 62a6bc3a1e4f (driver: core: Allow subsystems to continue deferring probe)
  
  /**
   * struct subsys_interface - interfaces to device functions
* Unmerged path drivers/base/dd.c
* Unmerged path drivers/pinctrl/devicetree.c
* Unmerged path include/linux/device.h
