fuse: extract fuse_fill_super_common()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stefan Hajnoczi <stefanha@redhat.com>
commit 0cc2656cdb0b1f234e6d29378cb061e29d7522bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0cc2656c.failed

fuse_fill_super() includes code to process the fd= option and link the
struct fuse_dev to the fd's struct file.  In virtio-fs there is no file
descriptor because /dev/fuse is not used.

This patch extracts fuse_fill_super_common() so that both classic fuse and
virtio-fs can share the code to initialize a mount.

	Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 0cc2656cdb0b1f234e6d29378cb061e29d7522bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/inode.c
diff --cc fs/fuse/inode.c
index 523a1f18c557,30d92e633ece..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -59,20 -60,9 +59,26 @@@ MODULE_PARM_DESC(max_user_congthresh
  /** Congestion starts at 75% of maximum */
  #define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)
  
++<<<<<<< HEAD
 +struct fuse_mount_data {
 +	int fd;
 +	unsigned rootmode;
 +	kuid_t user_id;
 +	kgid_t group_id;
 +	unsigned fd_present:1;
 +	unsigned rootmode_present:1;
 +	unsigned user_id_present:1;
 +	unsigned group_id_present:1;
 +	unsigned default_permissions:1;
 +	unsigned allow_other:1;
 +	unsigned max_read;
 +	unsigned blksize;
 +};
++=======
+ #ifdef CONFIG_BLOCK
+ static struct file_system_type fuseblk_fs_type;
+ #endif
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  
  struct fuse_forget_link *fuse_alloc_forget(void)
  {
@@@ -1084,17 -1083,13 +1090,23 @@@ void fuse_dev_free(struct fuse_dev *fud
  }
  EXPORT_SYMBOL_GPL(fuse_dev_free);
  
++<<<<<<< HEAD
 +static int fuse_fill_super(struct super_block *sb, void *data, int silent)
++=======
+ int fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx)
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  {
  	struct fuse_dev *fud;
- 	struct fuse_conn *fc;
+ 	struct fuse_conn *fc = get_fuse_conn_super(sb);
  	struct inode *root;
++<<<<<<< HEAD
 +	struct fuse_mount_data d;
 +	struct file *file;
++=======
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  	struct dentry *root_dentry;
 +	struct fuse_req *init_req;
  	int err;
- 	int is_bdev = sb->s_bdev != NULL;
  
  	err = -EINVAL;
  	if (sb->s_flags & SB_MANDLOCK)
@@@ -1102,13 -1097,10 +1114,17 @@@
  
  	sb->s_flags &= ~(SB_NOSEC | SB_I_VERSION);
  
++<<<<<<< HEAD
 +	if (!parse_fuse_opt(data, &d, is_bdev, sb->s_user_ns))
 +		goto err;
 +
 +	if (is_bdev) {
++=======
+ 	if (ctx->is_bdev) {
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  #ifdef CONFIG_BLOCK
  		err = -EINVAL;
 -		if (!sb_set_blocksize(sb, ctx->blksize))
 +		if (!sb_set_blocksize(sb, d.blksize))
  			goto err;
  #endif
  	} else {
@@@ -1125,19 -1120,6 +1141,22 @@@
  	if (sb->s_user_ns != &init_user_ns)
  		sb->s_iflags |= SB_I_UNTRUSTED_MOUNTER;
  
++<<<<<<< HEAD
 +	file = fget(d.fd);
 +	err = -EINVAL;
 +	if (!file)
 +		goto err;
 +
 +	/*
 +	 * Require mount to happen from the same user namespace which
 +	 * opened /dev/fuse to prevent potential attacks.
 +	 */
 +	if (file->f_op != &fuse_dev_operations ||
 +	    file->f_cred->user_ns != sb->s_user_ns)
 +		goto err_fput;
 +
++=======
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  	/*
  	 * If we are not in the initial user namespace posix
  	 * acls must be translated.
@@@ -1168,17 -1142,15 +1179,26 @@@
  		fc->dont_mask = 1;
  	sb->s_flags |= SB_POSIXACL;
  
++<<<<<<< HEAD
 +	fc->default_permissions = d.default_permissions;
 +	fc->allow_other = d.allow_other;
 +	fc->user_id = d.user_id;
 +	fc->group_id = d.group_id;
 +	fc->max_read = max_t(unsigned, 4096, d.max_read);
 +
 +	/* Used by get_root_inode() */
 +	sb->s_fs_info = fc;
++=======
+ 	fc->default_permissions = ctx->default_permissions;
+ 	fc->allow_other = ctx->allow_other;
+ 	fc->user_id = ctx->user_id;
+ 	fc->group_id = ctx->group_id;
+ 	fc->max_read = max_t(unsigned, 4096, ctx->max_read);
+ 	fc->destroy = ctx->is_bdev;
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  
  	err = -ENOMEM;
 -	root = fuse_get_root_inode(sb, ctx->rootmode);
 +	root = fuse_get_root_inode(sb, d.rootmode);
  	sb->s_d_op = &fuse_root_dentry_operations;
  	root_dentry = d_make_root(root);
  	if (!root_dentry)
@@@ -1186,20 -1158,9 +1206,20 @@@
  	/* Root dentry doesn't have .d_revalidate */
  	sb->s_d_op = &fuse_dentry_operations;
  
 +	init_req = fuse_request_alloc(0);
 +	if (!init_req)
 +		goto err_put_root;
 +	__set_bit(FR_BACKGROUND, &init_req->flags);
 +
 +	if (is_bdev) {
 +		fc->destroy_req = fuse_request_alloc(0);
 +		if (!fc->destroy_req)
 +			goto err_free_init_req;
 +	}
 +
  	mutex_lock(&fuse_mutex);
  	err = -EINVAL;
- 	if (file->private_data)
+ 	if (*ctx->fudptr)
  		goto err_unlock;
  
  	err = fuse_ctl_add_conn(fc);
@@@ -1208,17 -1169,8 +1228,20 @@@
  
  	list_add_tail(&fc->entry, &fuse_conn_list);
  	sb->s_root = root_dentry;
- 	file->private_data = fud;
+ 	*ctx->fudptr = fud;
  	mutex_unlock(&fuse_mutex);
++<<<<<<< HEAD
 +	/*
 +	 * atomic_dec_and_test() in fput() provides the necessary
 +	 * memory barrier for file->private_data to be visible on all
 +	 * CPUs after this
 +	 */
 +	fput(file);
 +
 +	fuse_send_init(fc, init_req);
 +
++=======
++>>>>>>> 0cc2656cdb0b (fuse: extract fuse_fill_super_common())
  	return 0;
  
   err_unlock:
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b9287760b32a..b330b928f730 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -405,6 +405,26 @@ struct fuse_dev {
 	struct list_head entry;
 };
 
+struct fuse_fs_context {
+	int fd;
+	unsigned int rootmode;
+	kuid_t user_id;
+	kgid_t group_id;
+	bool is_bdev:1;
+	bool fd_present:1;
+	bool rootmode_present:1;
+	bool user_id_present:1;
+	bool group_id_present:1;
+	bool default_permissions:1;
+	bool allow_other:1;
+	unsigned int max_read;
+	unsigned int blksize;
+	const char *subtype;
+
+	/* fuse_dev pointer to fill in, should contain NULL on entry */
+	void **fudptr;
+};
+
 /**
  * A Fuse connection.
  *
@@ -904,6 +924,13 @@ void fuse_conn_put(struct fuse_conn *fc);
 struct fuse_dev *fuse_dev_alloc(struct fuse_conn *fc);
 void fuse_dev_free(struct fuse_dev *fud);
 
+/**
+ * Fill in superblock and initialize fuse connection
+ * @sb: partially-initialized superblock to fill in
+ * @ctx: mount context
+ */
+int fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx);
+
 /**
  * Add connection to control filesystem
  */
* Unmerged path fs/fuse/inode.c
