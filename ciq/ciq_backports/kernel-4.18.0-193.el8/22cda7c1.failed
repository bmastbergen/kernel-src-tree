powerpc/eeh: Add debugfs interface to run an EEH check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [powerpc] eeh: Add debugfs interface to run an EEH check (Gustavo Duarte) [1524642]
Rebuild_FUZZ: 92.00%
commit-author Oliver O'Halloran <oohall@gmail.com>
commit 22cda7c1680c1ddfe941adae45e7e7ef52d0e411
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/22cda7c1.failed

Detecting an frozen EEH PE usually occurs when an MMIO load returns a 0xFFs
response. When performing EEH testing using the EEH error injection feature
available on some platforms there is no simple way to kick-off the kernel's
recovery process since any accesses from userspace (usually /dev/mem) will
bypass the MMIO helpers in the kernel which check if a 0xFF response is due
to an EEH freeze or not.

If a device contains a 0xFF byte in it's config space it's possible to
trigger the recovery process via config space read from userspace, but this
is not a reliable method. If a driver is bound to the device an in use it
will frequently trigger the MMIO check, but this is also inconsistent.

To solve these problems this patch adds a debugfs file called
"eeh_dev_check" which accepts a <domain>:<bus>:<dev>.<fn> string and runs
eeh_dev_check_failure() on it. This is the same check that's done when the
kernel gets a 0xFF result from an config or MMIO read with the added
benifit that it can be reliably triggered from userspace.

	Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190903101605.2890-13-oohall@gmail.com
(cherry picked from commit 22cda7c1680c1ddfe941adae45e7e7ef52d0e411)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
diff --cc arch/powerpc/kernel/eeh.c
index 528caf857428,2b3c03215a95..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -1829,22 -1813,122 +1829,88 @@@ static int eeh_enable_dbgfs_get(void *d
  	return 0;
  }
  
 -DEFINE_DEBUGFS_ATTRIBUTE(eeh_enable_dbgfs_ops, eeh_enable_dbgfs_get,
 -			 eeh_enable_dbgfs_set, "0x%llx\n");
 -
 -static ssize_t eeh_force_recover_write(struct file *filp,
 -				const char __user *user_buf,
 -				size_t count, loff_t *ppos)
 +static int eeh_freeze_dbgfs_set(void *data, u64 val)
  {
 -	struct pci_controller *hose;
 -	uint32_t phbid, pe_no;
 -	struct eeh_pe *pe;
 -	char buf[20];
 -	int ret;
 -
 -	ret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);
 -	if (!ret)
 -		return -EFAULT;
 -
 -	/*
 -	 * When PE is NULL the event is a "special" event. Rather than
 -	 * recovering a specific PE it forces the EEH core to scan for failed
 -	 * PHBs and recovers each. This needs to be done before any device
 -	 * recoveries can occur.
 -	 */
 -	if (!strncmp(buf, "hwcheck", 7)) {
 -		__eeh_send_failure_event(NULL);
 -		return count;
 -	}
 -
 -	ret = sscanf(buf, "%x:%x", &phbid, &pe_no);
 -	if (ret != 2)
 -		return -EINVAL;
 -
 -	hose = pci_find_controller_for_domain(phbid);
 -	if (!hose)
 -		return -ENODEV;
 -
 -	/* Retrieve PE */
 -	pe = eeh_pe_get(hose, pe_no, 0);
 -	if (!pe)
 -		return -ENODEV;
 -
 -	/*
 -	 * We don't do any state checking here since the detection
 -	 * process is async to the recovery process. The recovery
 -	 * thread *should* not break even if we schedule a recovery
 -	 * from an odd state (e.g. PE removed, or recovery of a
 -	 * non-isolated PE)
 -	 */
 -	__eeh_send_failure_event(pe);
 +	eeh_max_freezes = val;
 +	return 0;
 +}
  
 -	return ret < 0 ? ret : count;
++<<<<<<< HEAD
 +static int eeh_freeze_dbgfs_get(void *data, u64 *val)
 +{
 +	*val = eeh_max_freezes;
 +	return 0;
  }
  
 +DEFINE_SIMPLE_ATTRIBUTE(eeh_enable_dbgfs_ops, eeh_enable_dbgfs_get,
 +			eeh_enable_dbgfs_set, "0x%llx\n");
 +DEFINE_SIMPLE_ATTRIBUTE(eeh_freeze_dbgfs_ops, eeh_freeze_dbgfs_get,
 +			eeh_freeze_dbgfs_set, "0x%llx\n");
++=======
+ static const struct file_operations eeh_force_recover_fops = {
+ 	.open	= simple_open,
+ 	.llseek	= no_llseek,
+ 	.write	= eeh_force_recover_write,
+ };
+ 
+ static ssize_t eeh_debugfs_dev_usage(struct file *filp,
+ 				char __user *user_buf,
+ 				size_t count, loff_t *ppos)
+ {
+ 	static const char usage[] = "input format: <domain>:<bus>:<dev>.<fn>\n";
+ 
+ 	return simple_read_from_buffer(user_buf, count, ppos,
+ 				       usage, sizeof(usage) - 1);
+ }
+ 
+ static ssize_t eeh_dev_check_write(struct file *filp,
+ 				const char __user *user_buf,
+ 				size_t count, loff_t *ppos)
+ {
+ 	uint32_t domain, bus, dev, fn;
+ 	struct pci_dev *pdev;
+ 	struct eeh_dev *edev;
+ 	char buf[20];
+ 	int ret;
+ 
+ 	ret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);
+ 	if (!ret)
+ 		return -EFAULT;
+ 
+ 	ret = sscanf(buf, "%x:%x:%x.%x", &domain, &bus, &dev, &fn);
+ 	if (ret != 4) {
+ 		pr_err("%s: expected 4 args, got %d\n", __func__, ret);
+ 		return -EINVAL;
+ 	}
+ 
+ 	pdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);
+ 	if (!pdev)
+ 		return -ENODEV;
+ 
+ 	edev = pci_dev_to_eeh_dev(pdev);
+ 	if (!edev) {
+ 		pci_err(pdev, "No eeh_dev for this device!\n");
+ 		pci_dev_put(pdev);
+ 		return -ENODEV;
+ 	}
+ 
+ 	ret = eeh_dev_check_failure(edev);
+ 	pci_info(pdev, "eeh_dev_check_failure(%04x:%02x:%02x.%01x) = %d\n",
+ 			domain, bus, dev, fn, ret);
+ 
+ 	pci_dev_put(pdev);
+ 
+ 	return count;
+ }
+ 
+ static const struct file_operations eeh_dev_check_fops = {
+ 	.open	= simple_open,
+ 	.llseek	= no_llseek,
+ 	.write	= eeh_dev_check_write,
+ 	.read   = eeh_debugfs_dev_usage,
+ };
+ 
++>>>>>>> 22cda7c1680c (powerpc/eeh: Add debugfs interface to run an EEH check)
  #endif
  
  static int __init eeh_init_proc(void)
@@@ -1852,12 -1936,21 +1918,30 @@@
  	if (machine_is(pseries) || machine_is(powernv)) {
  		proc_create_single("powerpc/eeh", 0, NULL, proc_eeh_show);
  #ifdef CONFIG_DEBUG_FS
++<<<<<<< HEAD
 +		debugfs_create_file("eeh_enable", 0600,
 +                                    powerpc_debugfs_root, NULL,
 +                                    &eeh_enable_dbgfs_ops);
 +		debugfs_create_file("eeh_max_freezes", 0600,
 +				    powerpc_debugfs_root, NULL,
 +				    &eeh_freeze_dbgfs_ops);
++=======
+ 		debugfs_create_file_unsafe("eeh_enable", 0600,
+ 					   powerpc_debugfs_root, NULL,
+ 					   &eeh_enable_dbgfs_ops);
+ 		debugfs_create_u32("eeh_max_freezes", 0600,
+ 				powerpc_debugfs_root, &eeh_max_freezes);
+ 		debugfs_create_bool("eeh_disable_recovery", 0600,
+ 				powerpc_debugfs_root,
+ 				&eeh_debugfs_no_recover);
+ 		debugfs_create_file_unsafe("eeh_dev_check", 0600,
+ 				powerpc_debugfs_root, NULL,
+ 				&eeh_dev_check_fops);
+ 		debugfs_create_file_unsafe("eeh_force_recover", 0600,
+ 				powerpc_debugfs_root, NULL,
+ 				&eeh_force_recover_fops);
+ 		eeh_cache_debugfs_init();
++>>>>>>> 22cda7c1680c (powerpc/eeh: Add debugfs interface to run an EEH check)
  #endif
  	}
  
* Unmerged path arch/powerpc/kernel/eeh.c
