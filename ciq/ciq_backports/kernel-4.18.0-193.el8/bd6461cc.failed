powerpc/eeh: Add a eeh_dev_break debugfs interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [powerpc] eeh: Add a eeh_dev_break debugfs interface (Gustavo Duarte) [1524642]
Rebuild_FUZZ: 91.30%
commit-author Oliver O'Halloran <oohall@gmail.com>
commit bd6461cc7b3c4fd12dcba4b0e95dfc612df872fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/bd6461cc.failed

Add an interface to debugfs for generating an EEH event on a given device.
This works by disabling memory accesses to and from the device by setting
the PCI_COMMAND register (or the VF Memory Space Enable on the parent PF).

This is a somewhat portable alternative to using the platform specific
error injection mechanisms since those tend to be either hard to use, or
straight up broken. For pseries the interfaces also requires the use of
/dev/mem which is probably going to go away in a post-LOCKDOWN world
(and it's a horrific hack to begin with) so moving to a kernel-provided
interface makes sense and provides a sane, cross-platform interface for
userspace so we can write more generic testing scripts.

	Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190903101605.2890-14-oohall@gmail.com
(cherry picked from commit bd6461cc7b3c4fd12dcba4b0e95dfc612df872fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh.c
diff --cc arch/powerpc/kernel/eeh.c
index 528caf857428,0a91dee51245..000000000000
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@@ -1829,22 -1813,256 +1829,206 @@@ static int eeh_enable_dbgfs_get(void *d
  	return 0;
  }
  
 -DEFINE_DEBUGFS_ATTRIBUTE(eeh_enable_dbgfs_ops, eeh_enable_dbgfs_get,
 -			 eeh_enable_dbgfs_set, "0x%llx\n");
 -
 -static ssize_t eeh_force_recover_write(struct file *filp,
 -				const char __user *user_buf,
 -				size_t count, loff_t *ppos)
 +static int eeh_freeze_dbgfs_set(void *data, u64 val)
  {
 -	struct pci_controller *hose;
 -	uint32_t phbid, pe_no;
 -	struct eeh_pe *pe;
 -	char buf[20];
 -	int ret;
 -
 -	ret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);
 -	if (!ret)
 -		return -EFAULT;
 -
 -	/*
 -	 * When PE is NULL the event is a "special" event. Rather than
 -	 * recovering a specific PE it forces the EEH core to scan for failed
 -	 * PHBs and recovers each. This needs to be done before any device
 -	 * recoveries can occur.
 -	 */
 -	if (!strncmp(buf, "hwcheck", 7)) {
 -		__eeh_send_failure_event(NULL);
 -		return count;
 -	}
 -
 -	ret = sscanf(buf, "%x:%x", &phbid, &pe_no);
 -	if (ret != 2)
 -		return -EINVAL;
 -
 -	hose = pci_find_controller_for_domain(phbid);
 -	if (!hose)
 -		return -ENODEV;
 -
 -	/* Retrieve PE */
 -	pe = eeh_pe_get(hose, pe_no, 0);
 -	if (!pe)
 -		return -ENODEV;
 -
 -	/*
 -	 * We don't do any state checking here since the detection
 -	 * process is async to the recovery process. The recovery
 -	 * thread *should* not break even if we schedule a recovery
 -	 * from an odd state (e.g. PE removed, or recovery of a
 -	 * non-isolated PE)
 -	 */
 -	__eeh_send_failure_event(pe);
 -
 -	return ret < 0 ? ret : count;
 +	eeh_max_freezes = val;
 +	return 0;
  }
  
 -static const struct file_operations eeh_force_recover_fops = {
 -	.open	= simple_open,
 -	.llseek	= no_llseek,
 -	.write	= eeh_force_recover_write,
 -};
 -
 -static ssize_t eeh_debugfs_dev_usage(struct file *filp,
 -				char __user *user_buf,
 -				size_t count, loff_t *ppos)
 +static int eeh_freeze_dbgfs_get(void *data, u64 *val)
  {
 -	static const char usage[] = "input format: <domain>:<bus>:<dev>.<fn>\n";
 -
 -	return simple_read_from_buffer(user_buf, count, ppos,
 -				       usage, sizeof(usage) - 1);
 +	*val = eeh_max_freezes;
 +	return 0;
  }
  
++<<<<<<< HEAD
 +DEFINE_SIMPLE_ATTRIBUTE(eeh_enable_dbgfs_ops, eeh_enable_dbgfs_get,
 +			eeh_enable_dbgfs_set, "0x%llx\n");
 +DEFINE_SIMPLE_ATTRIBUTE(eeh_freeze_dbgfs_ops, eeh_freeze_dbgfs_get,
 +			eeh_freeze_dbgfs_set, "0x%llx\n");
++=======
+ static ssize_t eeh_dev_check_write(struct file *filp,
+ 				const char __user *user_buf,
+ 				size_t count, loff_t *ppos)
+ {
+ 	uint32_t domain, bus, dev, fn;
+ 	struct pci_dev *pdev;
+ 	struct eeh_dev *edev;
+ 	char buf[20];
+ 	int ret;
+ 
+ 	memset(buf, 0, sizeof(buf));
+ 	ret = simple_write_to_buffer(buf, sizeof(buf)-1, ppos, user_buf, count);
+ 	if (!ret)
+ 		return -EFAULT;
+ 
+ 	ret = sscanf(buf, "%x:%x:%x.%x", &domain, &bus, &dev, &fn);
+ 	if (ret != 4) {
+ 		pr_err("%s: expected 4 args, got %d\n", __func__, ret);
+ 		return -EINVAL;
+ 	}
+ 
+ 	pdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);
+ 	if (!pdev)
+ 		return -ENODEV;
+ 
+ 	edev = pci_dev_to_eeh_dev(pdev);
+ 	if (!edev) {
+ 		pci_err(pdev, "No eeh_dev for this device!\n");
+ 		pci_dev_put(pdev);
+ 		return -ENODEV;
+ 	}
+ 
+ 	ret = eeh_dev_check_failure(edev);
+ 	pci_info(pdev, "eeh_dev_check_failure(%04x:%02x:%02x.%01x) = %d\n",
+ 			domain, bus, dev, fn, ret);
+ 
+ 	pci_dev_put(pdev);
+ 
+ 	return count;
+ }
+ 
+ static const struct file_operations eeh_dev_check_fops = {
+ 	.open	= simple_open,
+ 	.llseek	= no_llseek,
+ 	.write	= eeh_dev_check_write,
+ 	.read   = eeh_debugfs_dev_usage,
+ };
+ 
+ static int eeh_debugfs_break_device(struct pci_dev *pdev)
+ {
+ 	struct resource *bar = NULL;
+ 	void __iomem *mapped;
+ 	u16 old, bit;
+ 	int i, pos;
+ 
+ 	/* Do we have an MMIO BAR to disable? */
+ 	for (i = 0; i <= PCI_STD_RESOURCE_END; i++) {
+ 		struct resource *r = &pdev->resource[i];
+ 
+ 		if (!r->flags || !r->start)
+ 			continue;
+ 		if (r->flags & IORESOURCE_IO)
+ 			continue;
+ 		if (r->flags & IORESOURCE_UNSET)
+ 			continue;
+ 
+ 		bar = r;
+ 		break;
+ 	}
+ 
+ 	if (!bar) {
+ 		pci_err(pdev, "Unable to find Memory BAR to cause EEH with\n");
+ 		return -ENXIO;
+ 	}
+ 
+ 	pci_err(pdev, "Going to break: %pR\n", bar);
+ 
+ 	if (pdev->is_virtfn) {
+ #ifndef CONFIG_IOV
+ 		return -ENXIO;
+ #else
+ 		/*
+ 		 * VFs don't have a per-function COMMAND register, so the best
+ 		 * we can do is clear the Memory Space Enable bit in the PF's
+ 		 * SRIOV control reg.
+ 		 *
+ 		 * Unfortunately, this requires that we have a PF (i.e doesn't
+ 		 * work for a passed-through VF) and it has the potential side
+ 		 * effect of also causing an EEH on every other VF under the
+ 		 * PF. Oh well.
+ 		 */
+ 		pdev = pdev->physfn;
+ 		if (!pdev)
+ 			return -ENXIO; /* passed through VFs have no PF */
+ 
+ 		pos  = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
+ 		pos += PCI_SRIOV_CTRL;
+ 		bit  = PCI_SRIOV_CTRL_MSE;
+ #endif /* !CONFIG_IOV */
+ 	} else {
+ 		bit = PCI_COMMAND_MEMORY;
+ 		pos = PCI_COMMAND;
+ 	}
+ 
+ 	/*
+ 	 * Process here is:
+ 	 *
+ 	 * 1. Disable Memory space.
+ 	 *
+ 	 * 2. Perform an MMIO to the device. This should result in an error
+ 	 *    (CA  / UR) being raised by the device which results in an EEH
+ 	 *    PE freeze. Using the in_8() accessor skips the eeh detection hook
+ 	 *    so the freeze hook so the EEH Detection machinery won't be
+ 	 *    triggered here. This is to match the usual behaviour of EEH
+ 	 *    where the HW will asyncronously freeze a PE and it's up to
+ 	 *    the kernel to notice and deal with it.
+ 	 *
+ 	 * 3. Turn Memory space back on. This is more important for VFs
+ 	 *    since recovery will probably fail if we don't. For normal
+ 	 *    the COMMAND register is reset as a part of re-initialising
+ 	 *    the device.
+ 	 *
+ 	 * Breaking stuff is the point so who cares if it's racy ;)
+ 	 */
+ 	pci_read_config_word(pdev, pos, &old);
+ 
+ 	mapped = ioremap(bar->start, PAGE_SIZE);
+ 	if (!mapped) {
+ 		pci_err(pdev, "Unable to map MMIO BAR %pR\n", bar);
+ 		return -ENXIO;
+ 	}
+ 
+ 	pci_write_config_word(pdev, pos, old & ~bit);
+ 	in_8(mapped);
+ 	pci_write_config_word(pdev, pos, old);
+ 
+ 	iounmap(mapped);
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t eeh_dev_break_write(struct file *filp,
+ 				const char __user *user_buf,
+ 				size_t count, loff_t *ppos)
+ {
+ 	uint32_t domain, bus, dev, fn;
+ 	struct pci_dev *pdev;
+ 	char buf[20];
+ 	int ret;
+ 
+ 	memset(buf, 0, sizeof(buf));
+ 	ret = simple_write_to_buffer(buf, sizeof(buf)-1, ppos, user_buf, count);
+ 	if (!ret)
+ 		return -EFAULT;
+ 
+ 	ret = sscanf(buf, "%x:%x:%x.%x", &domain, &bus, &dev, &fn);
+ 	if (ret != 4) {
+ 		pr_err("%s: expected 4 args, got %d\n", __func__, ret);
+ 		return -EINVAL;
+ 	}
+ 
+ 	pdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);
+ 	if (!pdev)
+ 		return -ENODEV;
+ 
+ 	ret = eeh_debugfs_break_device(pdev);
+ 	pci_dev_put(pdev);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return count;
+ }
+ 
+ static const struct file_operations eeh_dev_break_fops = {
+ 	.open	= simple_open,
+ 	.llseek	= no_llseek,
+ 	.write	= eeh_dev_break_write,
+ 	.read   = eeh_debugfs_dev_usage,
+ };
+ 
++>>>>>>> bd6461cc7b3c (powerpc/eeh: Add a eeh_dev_break debugfs interface)
  #endif
  
  static int __init eeh_init_proc(void)
@@@ -1852,12 -2070,24 +2036,33 @@@
  	if (machine_is(pseries) || machine_is(powernv)) {
  		proc_create_single("powerpc/eeh", 0, NULL, proc_eeh_show);
  #ifdef CONFIG_DEBUG_FS
++<<<<<<< HEAD
 +		debugfs_create_file("eeh_enable", 0600,
 +                                    powerpc_debugfs_root, NULL,
 +                                    &eeh_enable_dbgfs_ops);
 +		debugfs_create_file("eeh_max_freezes", 0600,
 +				    powerpc_debugfs_root, NULL,
 +				    &eeh_freeze_dbgfs_ops);
++=======
+ 		debugfs_create_file_unsafe("eeh_enable", 0600,
+ 					   powerpc_debugfs_root, NULL,
+ 					   &eeh_enable_dbgfs_ops);
+ 		debugfs_create_u32("eeh_max_freezes", 0600,
+ 				powerpc_debugfs_root, &eeh_max_freezes);
+ 		debugfs_create_bool("eeh_disable_recovery", 0600,
+ 				powerpc_debugfs_root,
+ 				&eeh_debugfs_no_recover);
+ 		debugfs_create_file_unsafe("eeh_dev_check", 0600,
+ 				powerpc_debugfs_root, NULL,
+ 				&eeh_dev_check_fops);
+ 		debugfs_create_file_unsafe("eeh_dev_break", 0600,
+ 				powerpc_debugfs_root, NULL,
+ 				&eeh_dev_break_fops);
+ 		debugfs_create_file_unsafe("eeh_force_recover", 0600,
+ 				powerpc_debugfs_root, NULL,
+ 				&eeh_force_recover_fops);
+ 		eeh_cache_debugfs_init();
++>>>>>>> bd6461cc7b3c (powerpc/eeh: Add a eeh_dev_break debugfs interface)
  #endif
  	}
  
* Unmerged path arch/powerpc/kernel/eeh.c
