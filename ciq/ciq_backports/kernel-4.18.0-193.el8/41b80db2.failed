iommu/vt-d: Set context field after value initialized

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [iommu] vt-d: Set context field after value initialized (Jerry Snitselaar) [1742234]
Rebuild_FUZZ: 94.00%
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 41b80db227993394f210f0eb705a326db5f605b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/41b80db2.failed

Otherwise, the translation type field of a context entry for
a PCI device will always be 0. All translated DMA requests
will be blocked by IOMMU. As the result, the PCI devices with
PCI ATS (device IOTBL) support won't work as expected.

	Cc: Ashok Raj <ashok.raj@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Suggested-by: Kevin Tian <kevin.tian@intel.com>
Fixes: 7373a8cc38197 ("iommu/vt-d: Setup context and enable RID2PASID support")
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 41b80db227993394f210f0eb705a326db5f605b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 4961558ba6cf,d7f10fd4ac2d..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -1987,41 -2027,68 +1987,79 @@@ static int domain_context_mapping_one(s
  		}
  	}
  
 -	context_clear_entry(context);
 -
 -	if (sm_supported(iommu)) {
 -		unsigned long pds;
 -
 -		WARN_ON(!table);
 +	pgd = domain->pgd;
  
 -		/* Setup the PASID DIR pointer: */
 -		pds = context_get_sm_pds(table);
 -		context->lo = (u64)virt_to_phys(table->table) |
 -				context_pdts(pds);
 +	context_clear_entry(context);
 +	context_set_domain_id(context, did);
  
 -		/* Setup the RID_PASID field: */
 -		context_set_sm_rid2pasid(context, PASID_RID2PASID);
 +	/*
 +	 * Skip top levels of page tables for iommu which has less agaw
 +	 * than default.  Unnecessary for PT mode.
 +	 */
 +	if (translation != CONTEXT_TT_PASS_THROUGH) {
 +		for (agaw = domain->agaw; agaw > iommu->agaw; agaw--) {
 +			ret = -ENOMEM;
 +			pgd = phys_to_virt(dma_pte_addr(pgd));
 +			if (!dma_pte_present(pgd))
 +				goto out_unlock;
 +		}
  
 -		/*
 -		 * Setup the Device-TLB enable bit and Page request
 -		 * Enable bit:
 -		 */
  		info = iommu_support_dev_iotlb(domain, iommu, bus, devfn);
  		if (info && info->ats_supported)
 -			context_set_sm_dte(context);
 -		if (info && info->pri_supported)
 -			context_set_sm_pre(context);
 +			translation = CONTEXT_TT_DEV_IOTLB;
 +		else
 +			translation = CONTEXT_TT_MULTI_LEVEL;
 +
 +		context_set_address_root(context, virt_to_phys(pgd));
 +		context_set_address_width(context, agaw);
  	} else {
++<<<<<<< HEAD
 +		/*
 +		 * In pass through mode, AW must be programmed to
 +		 * indicate the largest AGAW value supported by
 +		 * hardware. And ASR is ignored by hardware.
 +		 */
 +		context_set_address_width(context, iommu->msagaw);
++=======
+ 		struct dma_pte *pgd = domain->pgd;
+ 		int agaw;
+ 
+ 		context_set_domain_id(context, did);
+ 
+ 		if (translation != CONTEXT_TT_PASS_THROUGH) {
+ 			/*
+ 			 * Skip top levels of page tables for iommu which has
+ 			 * less agaw than default. Unnecessary for PT mode.
+ 			 */
+ 			for (agaw = domain->agaw; agaw > iommu->agaw; agaw--) {
+ 				ret = -ENOMEM;
+ 				pgd = phys_to_virt(dma_pte_addr(pgd));
+ 				if (!dma_pte_present(pgd))
+ 					goto out_unlock;
+ 			}
+ 
+ 			info = iommu_support_dev_iotlb(domain, iommu, bus, devfn);
+ 			if (info && info->ats_supported)
+ 				translation = CONTEXT_TT_DEV_IOTLB;
+ 			else
+ 				translation = CONTEXT_TT_MULTI_LEVEL;
+ 
+ 			context_set_address_root(context, virt_to_phys(pgd));
+ 			context_set_address_width(context, agaw);
+ 		} else {
+ 			/*
+ 			 * In pass through mode, AW must be programmed to
+ 			 * indicate the largest AGAW value supported by
+ 			 * hardware. And ASR is ignored by hardware.
+ 			 */
+ 			context_set_address_width(context, iommu->msagaw);
+ 		}
+ 
+ 		context_set_translation_type(context, translation);
++>>>>>>> 41b80db22799 (iommu/vt-d: Set context field after value initialized)
  	}
  
 +	context_set_translation_type(context, translation);
  	context_set_fault_enable(context);
  	context_set_present(context);
  	domain_flush_cache(domain, context, sizeof(*context));
* Unmerged path drivers/iommu/intel-iommu.c
