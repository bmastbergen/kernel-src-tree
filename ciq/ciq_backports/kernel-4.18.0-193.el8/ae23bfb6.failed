iommu/vt-d: Detach domain before using a private one

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [iommu] vt-d: Detach domain before using a private one (Jerry Snitselaar) [1742234]
Rebuild_FUZZ: 93.88%
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit ae23bfb68f2896835e54a137688906713cb607e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ae23bfb6.failed

When the default domain of a group doesn't work for a device,
the iommu driver will try to use a private domain. The domain
which was previously attached to the device must be detached.

	Cc: Ashok Raj <ashok.raj@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: Kevin Tian <kevin.tian@intel.com>
	Cc: Alex Williamson <alex.williamson@redhat.com>
Fixes: 942067f1b6b97 ("iommu/vt-d: Identify default domains replaced with private")
	Reported-by: Alex Williamson <alex.williamson@redhat.com>
Link: https://lkml.org/lkml/2019/8/2/1379
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Tested-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit ae23bfb68f2896835e54a137688906713cb607e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index e8af7b402adf,37259b7f95a7..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -3589,47 -3417,46 +3589,73 @@@ out
  }
  
  /* Check if the dev needs to go through non-identity map and unmap process.*/
 -static bool iommu_need_mapping(struct device *dev)
 +static int iommu_no_mapping(struct device *dev)
  {
 -	int ret;
 +	int found;
  
  	if (iommu_dummy(dev))
 -		return false;
 +		return 1;
  
 -	ret = identity_mapping(dev);
 -	if (ret) {
 -		u64 dma_mask = *dev->dma_mask;
 +	if (!iommu_identity_mapping)
 +		return 0;
  
++<<<<<<< HEAD
 +	found = identity_mapping(dev);
 +	if (found) {
 +		if (iommu_should_identity_map(dev, 0))
 +			return 1;
 +		else {
 +			/*
 +			 * 32 bit DMA is removed from si_domain and fall back
 +			 * to non-identity mapping.
 +			 */
 +			dmar_remove_one_dev_info(si_domain, dev);
 +			pr_info("32bit %s uses non-identity mapping\n",
 +				dev_name(dev));
 +			return 0;
 +		}
 +	} else {
 +		/*
 +		 * In case of a detached 64 bit DMA device from vm, the device
 +		 * is put into si_domain for identity mapping.
 +		 */
 +		if (iommu_should_identity_map(dev, 0)) {
 +			int ret;
 +			ret = domain_add_dev_info(si_domain, dev);
 +			if (!ret) {
 +				pr_info("64bit %s uses identity mapping\n",
 +					dev_name(dev));
 +				return 1;
 +			}
++=======
+ 		if (dev->coherent_dma_mask && dev->coherent_dma_mask < dma_mask)
+ 			dma_mask = dev->coherent_dma_mask;
+ 
+ 		if (dma_mask >= dma_get_required_mask(dev))
+ 			return false;
+ 
+ 		/*
+ 		 * 32 bit DMA is removed from si_domain and fall back to
+ 		 * non-identity mapping.
+ 		 */
+ 		dmar_remove_one_dev_info(dev);
+ 		ret = iommu_request_dma_domain_for_dev(dev);
+ 		if (ret) {
+ 			struct iommu_domain *domain;
+ 			struct dmar_domain *dmar_domain;
+ 
+ 			domain = iommu_get_domain_for_dev(dev);
+ 			if (domain) {
+ 				dmar_domain = to_dmar_domain(domain);
+ 				dmar_domain->flags |= DOMAIN_FLAG_LOSE_CHILDREN;
+ 			}
+ 			dmar_remove_one_dev_info(dev);
+ 			get_private_domain_for_dev(dev);
++>>>>>>> ae23bfb68f28 (iommu/vt-d: Detach domain before using a private one)
  		}
 -
 -		dev_info(dev, "32bit DMA uses non-identity mapping\n");
  	}
  
 -	return true;
 +	return 0;
  }
  
  static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,
@@@ -5356,8 -5294,9 +5384,9 @@@ static int intel_iommu_add_device(struc
  		if (device_def_domain_type(dev) == IOMMU_DOMAIN_DMA) {
  			ret = iommu_request_dma_domain_for_dev(dev);
  			if (ret) {
+ 				dmar_remove_one_dev_info(dev);
  				dmar_domain->flags |= DOMAIN_FLAG_LOSE_CHILDREN;
 -				if (!get_private_domain_for_dev(dev)) {
 +				if (!get_valid_domain_for_dev(dev)) {
  					dev_warn(dev,
  						 "Failed to get a private domain.\n");
  					return -ENOMEM;
* Unmerged path drivers/iommu/intel-iommu.c
