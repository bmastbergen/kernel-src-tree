net: phy: aquantia: print remote capabilities if link partner is Aquantia PHY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] phy: aquantia: print remote capabilities if link partner is Aquantia PHY (Petr Oros) [1772010]
Rebuild_FUZZ: 96.64%
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 9d685c11bf980bdd8036fb003db5a28913192f2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9d685c11.failed

If both link partners are Aquantia PHY's then additional information is
exchanged as part of the auto-negotiation. Report remote capabilities
if link partner is Aquantia PHY.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9d685c11bf980bdd8036fb003db5a28913192f2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/aquantia_main.c
diff --cc drivers/net/phy/aquantia_main.c
index 3d4b30e24149,330ee02abcad..000000000000
--- a/drivers/net/phy/aquantia_main.c
+++ b/drivers/net/phy/aquantia_main.c
@@@ -157,6 -183,227 +167,230 @@@ static int aqr_read_status(struct phy_d
  	return genphy_c45_read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ static int aqr107_read_downshift_event(struct phy_device *phydev)
+ {
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_INT_STATUS1);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	return !!(val & MDIO_AN_TX_VEND_INT_STATUS1_DOWNSHIFT);
+ }
+ 
+ static int aqr107_read_rate(struct phy_device *phydev)
+ {
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_STATUS1);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	switch (FIELD_GET(MDIO_AN_TX_VEND_STATUS1_RATE_MASK, val)) {
+ 	case MDIO_AN_TX_VEND_STATUS1_10BASET:
+ 		phydev->speed = SPEED_10;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_100BASETX:
+ 		phydev->speed = SPEED_100;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_1000BASET:
+ 		phydev->speed = SPEED_1000;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_2500BASET:
+ 		phydev->speed = SPEED_2500;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_5000BASET:
+ 		phydev->speed = SPEED_5000;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_10GBASET:
+ 		phydev->speed = SPEED_10000;
+ 		break;
+ 	default:
+ 		phydev->speed = SPEED_UNKNOWN;
+ 		break;
+ 	}
+ 
+ 	if (val & MDIO_AN_TX_VEND_STATUS1_FULL_DUPLEX)
+ 		phydev->duplex = DUPLEX_FULL;
+ 	else
+ 		phydev->duplex = DUPLEX_HALF;
+ 
+ 	return 0;
+ }
+ 
+ static int aqr107_read_status(struct phy_device *phydev)
+ {
+ 	int val, ret;
+ 
+ 	ret = aqr_read_status(phydev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!phydev->link || phydev->autoneg == AUTONEG_DISABLE)
+ 		return 0;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_PHYXS_VEND_IF_STATUS);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	switch (FIELD_GET(MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK, val)) {
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_KR:
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_XFI:
+ 		phydev->interface = PHY_INTERFACE_MODE_10GKR;
+ 		break;
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_SGMII:
+ 		phydev->interface = PHY_INTERFACE_MODE_SGMII;
+ 		break;
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_OCSGMII:
+ 		phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+ 		break;
+ 	default:
+ 		phydev->interface = PHY_INTERFACE_MODE_NA;
+ 		break;
+ 	}
+ 
+ 	val = aqr107_read_downshift_event(phydev);
+ 	if (val <= 0)
+ 		return val;
+ 
+ 	phydev_warn(phydev, "Downshift occurred! Cabling may be defective.\n");
+ 
+ 	/* Read downshifted rate from vendor register */
+ 	return aqr107_read_rate(phydev);
+ }
+ 
+ static int aqr107_get_downshift(struct phy_device *phydev, u8 *data)
+ {
+ 	int val, cnt, enable;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	enable = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_EN, val);
+ 	cnt = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);
+ 
+ 	*data = enable && cnt ? cnt : DOWNSHIFT_DEV_DISABLE;
+ 
+ 	return 0;
+ }
+ 
+ static int aqr107_set_downshift(struct phy_device *phydev, u8 cnt)
+ {
+ 	int val = 0;
+ 
+ 	if (!FIELD_FIT(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt))
+ 		return -E2BIG;
+ 
+ 	if (cnt != DOWNSHIFT_DEV_DISABLE) {
+ 		val = MDIO_AN_VEND_PROV_DOWNSHIFT_EN;
+ 		val |= FIELD_PREP(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt);
+ 	}
+ 
+ 	return phy_modify_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV,
+ 			      MDIO_AN_VEND_PROV_DOWNSHIFT_EN |
+ 			      MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);
+ }
+ 
+ static int aqr107_get_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, void *data)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		return aqr107_get_downshift(phydev, data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int aqr107_set_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, const void *data)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		return aqr107_set_downshift(phydev, *(const u8 *)data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int aqr107_config_init(struct phy_device *phydev)
+ {
+ 	/* Check that the PHY interface type is compatible */
+ 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_10GKR)
+ 		return -ENODEV;
+ 
+ 	/* ensure that a latched downshift event is cleared */
+ 	aqr107_read_downshift_event(phydev);
+ 
+ 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+ }
+ 
+ static int aqcs109_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Check that the PHY interface type is compatible */
+ 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX)
+ 		return -ENODEV;
+ 
+ 	/* AQCS109 belongs to a chip family partially supporting 10G and 5G.
+ 	 * PMA speed ability bits are the same for all members of the family,
+ 	 * AQCS109 however supports speeds up to 2.5G only.
+ 	 */
+ 	ret = phy_set_max_speed(phydev, SPEED_2500);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* ensure that a latched downshift event is cleared */
+ 	aqr107_read_downshift_event(phydev);
+ 
+ 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+ }
+ 
+ static void aqr107_link_change_notify(struct phy_device *phydev)
+ {
+ 	u8 fw_major, fw_minor;
+ 	bool downshift, short_reach, afr;
+ 	int val;
+ 
+ 	if (phydev->state != PHY_RUNNING || phydev->autoneg == AUTONEG_DISABLE)
+ 		return;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT1);
+ 	/* call failed or link partner is no Aquantia PHY */
+ 	if (val < 0 || !(val & MDIO_AN_RX_LP_STAT1_AQ_PHY))
+ 		return;
+ 
+ 	short_reach = val & MDIO_AN_RX_LP_STAT1_SHORT_REACH;
+ 	downshift = val & MDIO_AN_RX_LP_STAT1_AQRATE_DOWNSHIFT;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT4);
+ 	if (val < 0)
+ 		return;
+ 
+ 	fw_major = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MAJOR, val);
+ 	fw_minor = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MINOR, val);
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_VEND_STAT3);
+ 	if (val < 0)
+ 		return;
+ 
+ 	afr = val & MDIO_AN_RX_VEND_STAT3_AFR;
+ 
+ 	phydev_dbg(phydev, "Link partner is Aquantia PHY, FW %u.%u%s%s%s\n",
+ 		   fw_major, fw_minor,
+ 		   short_reach ? ", short reach mode" : "",
+ 		   downshift ? ", fast-retrain downshift advertised" : "",
+ 		   afr ? ", fast reframe advertised" : "");
+ }
+ 
++>>>>>>> 9d685c11bf98 (net: phy: aquantia: print remote capabilities if link partner is Aquantia PHY)
  static struct phy_driver aqr_driver[] = {
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQ1202),
@@@ -211,7 -452,13 +445,14 @@@
  	.config_aneg    = aqr_config_aneg,
  	.config_intr	= aqr_config_intr,
  	.ack_interrupt	= aqr_ack_interrupt,
++<<<<<<< HEAD
 +	.read_status	= aqr_read_status,
++=======
+ 	.read_status	= aqr107_read_status,
+ 	.get_tunable    = aqr107_get_tunable,
+ 	.set_tunable    = aqr107_set_tunable,
+ 	.link_change_notify = aqr107_link_change_notify,
++>>>>>>> 9d685c11bf98 (net: phy: aquantia: print remote capabilities if link partner is Aquantia PHY)
  },
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQCS109),
@@@ -221,7 -467,13 +462,14 @@@
  	.config_aneg    = aqr_config_aneg,
  	.config_intr	= aqr_config_intr,
  	.ack_interrupt	= aqr_ack_interrupt,
++<<<<<<< HEAD
 +	.read_status	= aqr_read_status,
++=======
+ 	.read_status	= aqr107_read_status,
+ 	.get_tunable    = aqr107_get_tunable,
+ 	.set_tunable    = aqr107_set_tunable,
+ 	.link_change_notify = aqr107_link_change_notify,
++>>>>>>> 9d685c11bf98 (net: phy: aquantia: print remote capabilities if link partner is Aquantia PHY)
  },
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQR405),
* Unmerged path drivers/net/phy/aquantia_main.c
