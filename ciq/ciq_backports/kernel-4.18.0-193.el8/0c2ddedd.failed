intel_rapl: support two power limits for every RAPL domain

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Zhang Rui <rui.zhang@intel.com>
commit 0c2ddedd8bcb88c4100acb9e0fc5ac8752d09501
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0c2ddedd.failed

RAPL MSR interface supports 2 power limits for package domain, and 1 power
limit for other domains, while RAPL MMIO interface supports 2 power limits
for both package and dram domains.
And when 2 power limits are supported, the FW_LOCK bit is in bit 63 of the
register, instead of bit 31.

Remove the assumption that only pakcage domain supports 2 power limits.
And allow the RAPL interface driver to specify the number of power limits
supported, for every single RAPL domain it owns..

	Reviewed-by: Pandruvada, Srinivas <srinivas.pandruvada@intel.com>
	Tested-by: Pandruvada, Srinivas <srinivas.pandruvada@intel.com>
	Signed-off-by: Zhang Rui <rui.zhang@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 0c2ddedd8bcb88c4100acb9e0fc5ac8752d09501)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
#	drivers/powercap/intel_rapl_msr.c
#	include/linux/intel_rapl.h
diff --cc drivers/powercap/intel_rapl.c
index cb3f68ebdb60,db8df19d8133..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -559,40 -520,26 +560,34 @@@ static void rapl_init_domains(struct ra
  	for (i = 0; i < RAPL_DOMAIN_MAX; i++) {
  		unsigned int mask = rp->domain_map & (1 << i);
  
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +		rd->regs[RAPL_DOMAIN_REG_LIMIT] = rp->priv->regs[i][RAPL_DOMAIN_REG_LIMIT];
 +		rd->regs[RAPL_DOMAIN_REG_STATUS] = rp->priv->regs[i][RAPL_DOMAIN_REG_STATUS];
 +		rd->regs[RAPL_DOMAIN_REG_PERF] = rp->priv->regs[i][RAPL_DOMAIN_REG_PERF];
 +		rd->regs[RAPL_DOMAIN_REG_POLICY] = rp->priv->regs[i][RAPL_DOMAIN_REG_POLICY];
 +		rd->regs[RAPL_DOMAIN_REG_INFO] = rp->priv->regs[i][RAPL_DOMAIN_REG_INFO];
- 
- 		switch (mask) {
- 		case BIT(RAPL_DOMAIN_PACKAGE):
- 			rd->name = rapl_domain_names[RAPL_DOMAIN_PACKAGE];
- 			rd->id = RAPL_DOMAIN_PACKAGE;
- 			rd->rpl[0].prim_id = PL1_ENABLE;
- 			rd->rpl[0].name = pl1_name;
++=======
+ 		if (!mask)
+ 			continue;
++>>>>>>> 0c2ddedd8bcb (intel_rapl: support two power limits for every RAPL domain):drivers/powercap/intel_rapl_common.c
+ 
+ 		rd->rp = rp;
+ 		rd->name = rapl_domain_names[i];
+ 		rd->id = i;
+ 		rd->rpl[0].prim_id = PL1_ENABLE;
+ 		rd->rpl[0].name = pl1_name;
+ 		/* some domain may support two power limits */
+ 		if (rp->priv->limits[i] == 2) {
  			rd->rpl[1].prim_id = PL2_ENABLE;
  			rd->rpl[1].name = pl2_name;
- 			break;
- 		case BIT(RAPL_DOMAIN_PP0):
- 			rd->name = rapl_domain_names[RAPL_DOMAIN_PP0];
- 			rd->id = RAPL_DOMAIN_PP0;
- 			rd->rpl[0].prim_id = PL1_ENABLE;
- 			rd->rpl[0].name = pl1_name;
- 			break;
- 		case BIT(RAPL_DOMAIN_PP1):
- 			rd->name = rapl_domain_names[RAPL_DOMAIN_PP1];
- 			rd->id = RAPL_DOMAIN_PP1;
- 			rd->rpl[0].prim_id = PL1_ENABLE;
- 			rd->rpl[0].name = pl1_name;
- 			break;
- 		case BIT(RAPL_DOMAIN_DRAM):
- 			rd->name = rapl_domain_names[RAPL_DOMAIN_DRAM];
- 			rd->id = RAPL_DOMAIN_DRAM;
- 			rd->rpl[0].prim_id = PL1_ENABLE;
- 			rd->rpl[0].name = pl1_name;
+ 		}
+ 
+ 		for (j = 0; j < RAPL_DOMAIN_REG_MAX; j++)
+ 			rd->regs[j] = rp->priv->regs[i][j];
+ 
+ 		if (i == RAPL_DOMAIN_DRAM) {
  			rd->domain_energy_unit =
 -			    rapl_defaults->dram_domain_energy_unit;
 +				rapl_defaults->dram_domain_energy_unit;
  			if (rd->domain_energy_unit)
  				pr_info("DRAM domain energy unit %dpj\n",
  					rd->domain_energy_unit);
@@@ -643,40 -586,40 +634,46 @@@ static u64 rapl_unit_xlate(struct rapl_
  static struct rapl_primitive_info rpi[] = {
  	/* name, mask, shift, msr index, unit divisor */
  	PRIMITIVE_INFO_INIT(ENERGY_COUNTER, ENERGY_STATUS_MASK, 0,
 -			    RAPL_DOMAIN_REG_STATUS, ENERGY_UNIT, 0),
 +				RAPL_DOMAIN_REG_STATUS, ENERGY_UNIT, 0),
  	PRIMITIVE_INFO_INIT(POWER_LIMIT1, POWER_LIMIT1_MASK, 0,
 -			    RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),
  	PRIMITIVE_INFO_INIT(POWER_LIMIT2, POWER_LIMIT2_MASK, 32,
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +				RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),
 +	PRIMITIVE_INFO_INIT(FW_LOCK, POWER_PP_LOCK, 31,
 +				RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
++=======
+ 			    RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),
+ 	PRIMITIVE_INFO_INIT(FW_LOCK, POWER_LOW_LOCK, 31,
+ 			    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
++>>>>>>> 0c2ddedd8bcb (intel_rapl: support two power limits for every RAPL domain):drivers/powercap/intel_rapl_common.c
  	PRIMITIVE_INFO_INIT(PL1_ENABLE, POWER_LIMIT1_ENABLE, 15,
 -			    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
  	PRIMITIVE_INFO_INIT(PL1_CLAMP, POWER_LIMIT1_CLAMP, 16,
 -			    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
  	PRIMITIVE_INFO_INIT(PL2_ENABLE, POWER_LIMIT2_ENABLE, 47,
 -			    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
  	PRIMITIVE_INFO_INIT(PL2_CLAMP, POWER_LIMIT2_CLAMP, 48,
 -			    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),
  	PRIMITIVE_INFO_INIT(TIME_WINDOW1, TIME_WINDOW1_MASK, 17,
 -			    RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),
  	PRIMITIVE_INFO_INIT(TIME_WINDOW2, TIME_WINDOW2_MASK, 49,
 -			    RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),
 +				RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),
  	PRIMITIVE_INFO_INIT(THERMAL_SPEC_POWER, POWER_INFO_THERMAL_SPEC_MASK,
 -			    0, RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),
 +				0, RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),
  	PRIMITIVE_INFO_INIT(MAX_POWER, POWER_INFO_MAX_MASK, 32,
 -			    RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),
 +				RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),
  	PRIMITIVE_INFO_INIT(MIN_POWER, POWER_INFO_MIN_MASK, 16,
 -			    RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),
 +				RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),
  	PRIMITIVE_INFO_INIT(MAX_TIME_WINDOW, POWER_INFO_MAX_TIME_WIN_MASK, 48,
 -			    RAPL_DOMAIN_REG_INFO, TIME_UNIT, 0),
 +				RAPL_DOMAIN_REG_INFO, TIME_UNIT, 0),
  	PRIMITIVE_INFO_INIT(THROTTLED_TIME, PERF_STATUS_THROTTLE_TIME_MASK, 0,
 -			    RAPL_DOMAIN_REG_PERF, TIME_UNIT, 0),
 +				RAPL_DOMAIN_REG_PERF, TIME_UNIT, 0),
  	PRIMITIVE_INFO_INIT(PRIORITY_LEVEL, PP_POLICY_MASK, 0,
 -			    RAPL_DOMAIN_REG_POLICY, ARBITRARY_UNIT, 0),
 +				RAPL_DOMAIN_REG_POLICY, ARBITRARY_UNIT, 0),
  	/* non-hardware */
  	PRIMITIVE_INFO_INIT(AVERAGE_POWER, 0, 0, 0, POWER_UNIT,
 -			    RAPL_PRIMITIVE_DERIVED),
 +				RAPL_PRIMITIVE_DERIVED),
  	{NULL, 0, 0, 0},
  };
  
@@@ -711,9 -653,9 +708,15 @@@ static int rapl_read_data_raw(struct ra
  
  	cpu = rd->rp->lead_cpu;
  
++<<<<<<< HEAD:drivers/powercap/intel_rapl.c
 +	/* special-case package domain, which uses a different bit*/
 +	if (prim == FW_LOCK && rd->id == RAPL_DOMAIN_PACKAGE) {
 +		rp->mask = POWER_PACKAGE_LOCK;
++=======
+ 	/* domain with 2 limits has different bit */
+ 	if (prim == FW_LOCK && rd->rp->priv->limits[rd->id] == 2) {
+ 		rp->mask = POWER_HIGH_LOCK;
++>>>>>>> 0c2ddedd8bcb (intel_rapl: support two power limits for every RAPL domain):drivers/powercap/intel_rapl_common.c
  		rp->shift = 63;
  	}
  	/* non-hardware data are collected by the polling thread */
diff --cc include/linux/intel_rapl.h
index ff215d64d114,0c179d92d110..000000000000
--- a/include/linux/intel_rapl.h
+++ b/include/linux/intel_rapl.h
@@@ -113,8 -114,9 +114,14 @@@ struct rapl_if_priv 
  	struct powercap_control_type *control_type;
  	struct rapl_domain *platform_rapl_domain;
  	enum cpuhp_state pcap_rapl_online;
++<<<<<<< HEAD
 +	u32 reg_unit;
 +	u32 regs[RAPL_DOMAIN_MAX][RAPL_DOMAIN_REG_MAX];
++=======
+ 	u64 reg_unit;
+ 	u64 regs[RAPL_DOMAIN_MAX][RAPL_DOMAIN_REG_MAX];
+ 	int limits[RAPL_DOMAIN_MAX];
++>>>>>>> 0c2ddedd8bcb (intel_rapl: support two power limits for every RAPL domain)
  	int (*read_raw)(int cpu, struct reg_action *ra);
  	int (*write_raw)(int cpu, struct reg_action *ra);
  };
* Unmerged path drivers/powercap/intel_rapl_msr.c
* Unmerged path drivers/powercap/intel_rapl.c
* Unmerged path drivers/powercap/intel_rapl_msr.c
* Unmerged path include/linux/intel_rapl.h
