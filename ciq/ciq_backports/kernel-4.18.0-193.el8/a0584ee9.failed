SUNRPC: Use struct xdr_stream when decoding RPC Reply header

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit a0584ee9aed805446b044ce855e67264f0dc619e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a0584ee9.failed

Modernize and harden the code path that parses an RPC Reply
message.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit a0584ee9aed805446b044ce855e67264f0dc619e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/auth.h
#	include/linux/sunrpc/xdr.h
#	net/sunrpc/auth.c
#	net/sunrpc/clnt.c
diff --cc include/linux/sunrpc/auth.h
index bca2741a3eb0,c51e1893f77e..000000000000
--- a/include/linux/sunrpc/auth.h
+++ b/include/linux/sunrpc/auth.h
@@@ -131,13 -131,15 +131,22 @@@ struct rpc_credops 
  	void			(*crdestroy)(struct rpc_cred *);
  
  	int			(*crmatch)(struct auth_cred *, struct rpc_cred *, int);
 -	int			(*crmarshal)(struct rpc_task *task,
 -					     struct xdr_stream *xdr);
 +	__be32 *		(*crmarshal)(struct rpc_task *, __be32 *);
  	int			(*crrefresh)(struct rpc_task *);
++<<<<<<< HEAD
 +	__be32 *		(*crvalidate)(struct rpc_task *, __be32 *);
 +	int			(*crwrap_req)(struct rpc_task *, kxdreproc_t,
 +						void *, __be32 *, void *);
 +	int			(*crunwrap_resp)(struct rpc_task *, kxdrdproc_t,
 +						void *, __be32 *, void *);
++=======
+ 	int			(*crvalidate)(struct rpc_task *task,
+ 					      struct xdr_stream *xdr);
+ 	int			(*crwrap_req)(struct rpc_task *task,
+ 					      struct xdr_stream *xdr);
+ 	int			(*crunwrap_resp)(struct rpc_task *task,
+ 						 struct xdr_stream *xdr);
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  	int			(*crkey_timeout)(struct rpc_cred *);
  	char *			(*crstringify_acceptor)(struct rpc_cred *);
  	bool			(*crneed_reencode)(struct rpc_task *);
@@@ -165,10 -167,18 +174,25 @@@ struct rpc_cred *	rpcauth_lookup_credca
  void			rpcauth_init_cred(struct rpc_cred *, const struct auth_cred *, struct rpc_auth *, const struct rpc_credops *);
  struct rpc_cred *	rpcauth_lookupcred(struct rpc_auth *, int);
  void			put_rpccred(struct rpc_cred *);
++<<<<<<< HEAD
 +__be32 *		rpcauth_marshcred(struct rpc_task *, __be32 *);
 +__be32 *		rpcauth_checkverf(struct rpc_task *, __be32 *);
 +int			rpcauth_wrap_req(struct rpc_task *task, kxdreproc_t encode, void *rqstp, __be32 *data, void *obj);
 +int			rpcauth_unwrap_resp(struct rpc_task *task, kxdrdproc_t decode, void *rqstp, __be32 *data, void *obj);
++=======
+ int			rpcauth_marshcred(struct rpc_task *task,
+ 					  struct xdr_stream *xdr);
+ int			rpcauth_checkverf(struct rpc_task *task,
+ 					  struct xdr_stream *xdr);
+ int			rpcauth_wrap_req_encode(struct rpc_task *task,
+ 						struct xdr_stream *xdr);
+ int			rpcauth_wrap_req(struct rpc_task *task,
+ 					 struct xdr_stream *xdr);
+ int			rpcauth_unwrap_resp_decode(struct rpc_task *task,
+ 						   struct xdr_stream *xdr);
+ int			rpcauth_unwrap_resp(struct rpc_task *task,
+ 					    struct xdr_stream *xdr);
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  bool			rpcauth_xmit_need_reencode(struct rpc_task *task);
  int			rpcauth_refreshcred(struct rpc_task *);
  void			rpcauth_invalcred(struct rpc_task *);
diff --cc include/linux/sunrpc/xdr.h
index 2d104fd9d602,65af6a204b75..000000000000
--- a/include/linux/sunrpc/xdr.h
+++ b/include/linux/sunrpc/xdr.h
@@@ -84,6 -87,16 +84,19 @@@ xdr_buf_init(struct xdr_buf *buf, void 
  #define	xdr_one		cpu_to_be32(1)
  #define	xdr_two		cpu_to_be32(2)
  
++<<<<<<< HEAD
++=======
+ #define	rpc_auth_null	cpu_to_be32(RPC_AUTH_NULL)
+ #define	rpc_auth_unix	cpu_to_be32(RPC_AUTH_UNIX)
+ #define	rpc_auth_short	cpu_to_be32(RPC_AUTH_SHORT)
+ #define	rpc_auth_gss	cpu_to_be32(RPC_AUTH_GSS)
+ 
+ #define	rpc_call	cpu_to_be32(RPC_CALL)
+ #define	rpc_reply	cpu_to_be32(RPC_REPLY)
+ 
+ #define	rpc_msg_accepted	cpu_to_be32(RPC_MSG_ACCEPTED)
+ 
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  #define	rpc_success		cpu_to_be32(RPC_SUCCESS)
  #define	rpc_prog_unavail	cpu_to_be32(RPC_PROG_UNAVAIL)
  #define	rpc_prog_mismatch	cpu_to_be32(RPC_PROG_MISMATCH)
diff --cc net/sunrpc/auth.c
index 1267f7cfe688,e7861026b9e5..000000000000
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@@ -749,65 -758,102 +751,102 @@@ destroy
  }
  EXPORT_SYMBOL_GPL(put_rpccred);
  
 -/**
 - * rpcauth_marshcred - Append RPC credential to end of @xdr
 - * @task: controlling RPC task
 - * @xdr: xdr_stream containing initial portion of RPC Call header
 - *
 - * On success, an appropriate verifier is added to @xdr, @xdr is
 - * updated to point past the verifier, and zero is returned.
 - * Otherwise, @xdr is in an undefined state and a negative errno
 - * is returned.
 - */
 -int rpcauth_marshcred(struct rpc_task *task, struct xdr_stream *xdr)
 +__be32 *
 +rpcauth_marshcred(struct rpc_task *task, __be32 *p)
  {
 -	const struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;
 +	struct rpc_cred	*cred = task->tk_rqstp->rq_cred;
  
 -	return ops->crmarshal(task, xdr);
 +	return cred->cr_ops->crmarshal(task, p);
  }
  
++<<<<<<< HEAD
 +__be32 *
 +rpcauth_checkverf(struct rpc_task *task, __be32 *p)
 +{
 +	struct rpc_cred	*cred = task->tk_rqstp->rq_cred;
 +
 +	return cred->cr_ops->crvalidate(task, p);
 +}
 +
 +static void rpcauth_wrap_req_encode(kxdreproc_t encode, struct rpc_rqst *rqstp,
 +				   __be32 *data, void *obj)
++=======
+ /**
+  * rpcauth_wrap_req_encode - XDR encode the RPC procedure
+  * @task: controlling RPC task
+  * @xdr: stream where on-the-wire bytes are to be marshalled
+  *
+  * On success, @xdr contains the encoded and wrapped message.
+  * Otherwise, @xdr is in an undefined state.
+  */
+ int rpcauth_wrap_req_encode(struct rpc_task *task, struct xdr_stream *xdr)
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  {
 -	kxdreproc_t encode = task->tk_msg.rpc_proc->p_encode;
 +	struct xdr_stream xdr;
  
 -	encode(task->tk_rqstp, xdr, task->tk_msg.rpc_argp);
 -	return 0;
 +	xdr_init_encode(&xdr, &rqstp->rq_snd_buf, data, rqstp);
 +	encode(rqstp, &xdr, obj);
  }
 -EXPORT_SYMBOL_GPL(rpcauth_wrap_req_encode);
  
 -/**
 - * rpcauth_wrap_req - XDR encode and wrap the RPC procedure
 - * @task: controlling RPC task
 - * @xdr: stream where on-the-wire bytes are to be marshalled
 - *
 - * On success, @xdr contains the encoded and wrapped message,
 - * and zero is returned. Otherwise, @xdr is in an undefined
 - * state and a negative errno is returned.
 - */
 -int rpcauth_wrap_req(struct rpc_task *task, struct xdr_stream *xdr)
 +int
 +rpcauth_wrap_req(struct rpc_task *task, kxdreproc_t encode, void *rqstp,
 +		__be32 *data, void *obj)
  {
 -	const struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;
 +	struct rpc_cred *cred = task->tk_rqstp->rq_cred;
  
 -	return ops->crwrap_req(task, xdr);
 +	if (cred->cr_ops->crwrap_req)
 +		return cred->cr_ops->crwrap_req(task, encode, rqstp, data, obj);
 +	/* By default, we encode the arguments normally. */
 +	rpcauth_wrap_req_encode(encode, rqstp, data, obj);
 +	return 0;
  }
  
- static int
- rpcauth_unwrap_req_decode(kxdrdproc_t decode, struct rpc_rqst *rqstp,
- 			  __be32 *data, void *obj)
+ /**
+  * rpcauth_checkverf - Validate verifier in RPC Reply header
+  * @task: controlling RPC task
+  * @xdr: xdr_stream containing RPC Reply header
+  *
+  * On success, @xdr is updated to point past the verifier and
+  * zero is returned. Otherwise, @xdr is in an undefined state
+  * and a negative errno is returned.
+  */
+ int
+ rpcauth_checkverf(struct rpc_task *task, struct xdr_stream *xdr)
  {
- 	struct xdr_stream xdr;
+ 	const struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;
  
- 	xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, data, rqstp);
- 	return decode(rqstp, &xdr, obj);
+ 	return ops->crvalidate(task, xdr);
  }
  
+ /**
+  * rpcauth_unwrap_resp_decode - Invoke XDR decode function
+  * @task: controlling RPC task
+  * @xdr: stream where the Reply message resides
+  *
+  * Returns zero on success; otherwise a negative errno is returned.
+  */
  int
- rpcauth_unwrap_resp(struct rpc_task *task, kxdrdproc_t decode, void *rqstp,
- 		__be32 *data, void *obj)
+ rpcauth_unwrap_resp_decode(struct rpc_task *task, struct xdr_stream *xdr)
  {
- 	struct rpc_cred *cred = task->tk_rqstp->rq_cred;
+ 	kxdrdproc_t decode = task->tk_msg.rpc_proc->p_decode;
+ 
+ 	return decode(task->tk_rqstp, xdr, task->tk_msg.rpc_resp);
+ }
+ EXPORT_SYMBOL_GPL(rpcauth_unwrap_resp_decode);
+ 
+ /**
+  * rpcauth_unwrap_resp - Invoke unwrap and decode function for the cred
+  * @task: controlling RPC task
+  * @xdr: stream where the Reply message resides
+  *
+  * Returns zero on success; otherwise a negative errno is returned.
+  */
+ int
+ rpcauth_unwrap_resp(struct rpc_task *task, struct xdr_stream *xdr)
+ {
+ 	const struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;
  
- 	if (cred->cr_ops->crunwrap_resp)
- 		return cred->cr_ops->crunwrap_resp(task, decode, rqstp,
- 						   data, obj);
- 	/* By default, we decode the arguments normally. */
- 	return rpcauth_unwrap_req_decode(decode, rqstp, data, obj);
+ 	return ops->crunwrap_resp(task, xdr);
  }
  
  bool
diff --cc net/sunrpc/clnt.c
index 415348b16ff1,803e93105af1..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -76,8 -77,10 +76,15 @@@ static void	call_timeout(struct rpc_tas
  static void	call_connect(struct rpc_task *task);
  static void	call_connect_status(struct rpc_task *task);
  
++<<<<<<< HEAD
 +static __be32	*rpc_encode_header(struct rpc_task *task);
 +static __be32	*rpc_verify_header(struct rpc_task *task);
++=======
+ static int	rpc_encode_header(struct rpc_task *task,
+ 				  struct xdr_stream *xdr);
+ static int	rpc_decode_header(struct rpc_task *task,
+ 				  struct xdr_stream *xdr);
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  static int	rpc_ping(struct rpc_clnt *clnt);
  
  static void rpc_register_client(struct rpc_clnt *clnt)
@@@ -2300,28 -2292,27 +2306,44 @@@ call_decode(struct rpc_task *task
  		goto out_retry;
  	}
  
++<<<<<<< HEAD
 +	p = rpc_verify_header(task);
 +	if (IS_ERR(p)) {
 +		if (p == ERR_PTR(-EAGAIN))
 +			goto out_retry;
++=======
+ 	xdr_init_decode(&xdr, &req->rq_rcv_buf,
+ 			req->rq_rcv_buf.head[0].iov_base, req);
+ 	switch (rpc_decode_header(task, &xdr)) {
+ 	case 0:
+ 		task->tk_action = rpc_exit_task;
+ 		task->tk_status = rpcauth_unwrap_resp(task, &xdr);
+ 		dprintk("RPC: %5u %s result %d\n",
+ 			task->tk_pid, __func__, task->tk_status);
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  		return;
- 	}
- 	task->tk_action = rpc_exit_task;
- 
- 	task->tk_status = rpcauth_unwrap_resp(task, decode, req, p,
- 					      task->tk_msg.rpc_resp);
- 
- 	dprintk("RPC: %5u call_decode result %d\n", task->tk_pid,
- 			task->tk_status);
- 	return;
+ 	case -EAGAIN:
  out_retry:
++<<<<<<< HEAD
 +	task->tk_status = 0;
 +	/* Note: rpc_verify_header() may have freed the RPC slot */
 +	if (task->tk_rqstp == req) {
 +		req->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;
 +		if (task->tk_client->cl_discrtry)
 +			xprt_conditional_disconnect(req->rq_xprt,
 +					req->rq_connect_cookie);
++=======
+ 		task->tk_status = 0;
+ 		/* Note: rpc_decode_header() may have freed the RPC slot */
+ 		if (task->tk_rqstp == req) {
+ 			xdr_free_bvec(&req->rq_rcv_buf);
+ 			req->rq_reply_bytes_recvd = 0;
+ 			req->rq_rcv_buf.len = 0;
+ 			if (task->tk_client->cl_discrtry)
+ 				xprt_conditional_disconnect(req->rq_xprt,
+ 							    req->rq_connect_cookie);
+ 		}
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  	}
  }
  
@@@ -2330,179 -2321,161 +2352,296 @@@ rpc_encode_header(struct rpc_task *task
  {
  	struct rpc_clnt *clnt = task->tk_client;
  	struct rpc_rqst	*req = task->tk_rqstp;
 -	__be32 *p;
 -	int error;
 +	__be32		*p = req->rq_svec[0].iov_base;
  
 -	error = -EMSGSIZE;
 -	p = xdr_reserve_space(xdr, RPC_CALLHDRSIZE << 2);
 -	if (!p)
 -		goto out_fail;
 -	*p++ = req->rq_xid;
 -	*p++ = rpc_call;
 -	*p++ = cpu_to_be32(RPC_VERSION);
 -	*p++ = cpu_to_be32(clnt->cl_prog);
 -	*p++ = cpu_to_be32(clnt->cl_vers);
 -	*p   = cpu_to_be32(task->tk_msg.rpc_proc->p_proc);
 -
 -	error = rpcauth_marshcred(task, xdr);
 -	if (error < 0)
 -		goto out_fail;
 -	return 0;
 -out_fail:
 -	trace_rpc_bad_callhdr(task);
 -	rpc_exit(task, error);
 -	return error;
 +	/* FIXME: check buffer size? */
 +
 +	*p++ = req->rq_xid;		/* XID */
 +	*p++ = htonl(RPC_CALL);		/* CALL */
 +	*p++ = htonl(RPC_VERSION);	/* RPC version */
 +	*p++ = htonl(clnt->cl_prog);	/* program number */
 +	*p++ = htonl(clnt->cl_vers);	/* program version */
 +	*p++ = htonl(task->tk_msg.rpc_proc->p_proc);	/* procedure */
 +	p = rpcauth_marshcred(task, p);
 +	req->rq_slen = xdr_adjust_iovec(&req->rq_svec[0], p);
 +	return p;
  }
  
++<<<<<<< HEAD
 +static __be32 *
 +rpc_verify_header(struct rpc_task *task)
 +{
 +	struct rpc_clnt *clnt = task->tk_client;
 +	struct kvec *iov = &task->tk_rqstp->rq_rcv_buf.head[0];
 +	int len = task->tk_rqstp->rq_rcv_buf.len >> 2;
 +	__be32	*p = iov->iov_base;
 +	u32 n;
++=======
+ static noinline int
+ rpc_decode_header(struct rpc_task *task, struct xdr_stream *xdr)
+ {
+ 	struct rpc_clnt *clnt = task->tk_client;
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  	int error = -EACCES;
+ 	__be32 *p;
  
++<<<<<<< HEAD
 +	if ((task->tk_rqstp->rq_rcv_buf.len & 3) != 0) {
 +		/* RFC-1014 says that the representation of XDR data must be a
 +		 * multiple of four bytes
 +		 * - if it isn't pointer subtraction in the NFS client may give
 +		 *   undefined results
 +		 */
 +		dprintk("RPC: %5u %s: XDR representation not a multiple of"
 +		       " 4 bytes: 0x%x\n", task->tk_pid, __func__,
 +		       task->tk_rqstp->rq_rcv_buf.len);
 +		error = -EIO;
 +		goto out_err;
 +	}
 +	if ((len -= 3) < 0)
 +		goto out_overflow;
 +
 +	p += 1; /* skip XID */
 +	if ((n = ntohl(*p++)) != RPC_REPLY) {
 +		dprintk("RPC: %5u %s: not an RPC reply: %x\n",
 +			task->tk_pid, __func__, n);
 +		error = -EIO;
 +		goto out_garbage;
 +	}
 +
 +	if ((n = ntohl(*p++)) != RPC_MSG_ACCEPTED) {
 +		if (--len < 0)
 +			goto out_overflow;
 +		switch ((n = ntohl(*p++))) {
 +		case RPC_AUTH_ERROR:
 +			break;
 +		case RPC_MISMATCH:
 +			dprintk("RPC: %5u %s: RPC call version mismatch!\n",
 +				task->tk_pid, __func__);
 +			error = -EPROTONOSUPPORT;
 +			goto out_err;
 +		default:
 +			dprintk("RPC: %5u %s: RPC call rejected, "
 +				"unknown error: %x\n",
 +				task->tk_pid, __func__, n);
 +			error = -EIO;
 +			goto out_err;
 +		}
 +		if (--len < 0)
 +			goto out_overflow;
 +		switch ((n = ntohl(*p++))) {
 +		case RPC_AUTH_REJECTEDCRED:
 +		case RPC_AUTH_REJECTEDVERF:
 +		case RPCSEC_GSS_CREDPROBLEM:
 +		case RPCSEC_GSS_CTXPROBLEM:
 +			if (!task->tk_cred_retry)
 +				break;
 +			task->tk_cred_retry--;
 +			dprintk("RPC: %5u %s: retry stale creds\n",
 +					task->tk_pid, __func__);
 +			rpcauth_invalcred(task);
 +			/* Ensure we obtain a new XID! */
 +			xprt_release(task);
 +			task->tk_action = call_reserve;
 +			goto out_retry;
 +		case RPC_AUTH_BADCRED:
 +		case RPC_AUTH_BADVERF:
 +			/* possibly garbled cred/verf? */
 +			if (!task->tk_garb_retry)
 +				break;
 +			task->tk_garb_retry--;
 +			dprintk("RPC: %5u %s: retry garbled creds\n",
 +					task->tk_pid, __func__);
 +			task->tk_action = call_bind;
 +			goto out_retry;
 +		case RPC_AUTH_TOOWEAK:
 +			printk(KERN_NOTICE "RPC: server %s requires stronger "
 +			       "authentication.\n",
 +			       task->tk_xprt->servername);
 +			break;
 +		default:
 +			dprintk("RPC: %5u %s: unknown auth error: %x\n",
 +					task->tk_pid, __func__, n);
 +			error = -EIO;
 +		}
 +		dprintk("RPC: %5u %s: call rejected %d\n",
 +				task->tk_pid, __func__, n);
 +		goto out_err;
 +	}
 +	p = rpcauth_checkverf(task, p);
 +	if (IS_ERR(p)) {
 +		error = PTR_ERR(p);
 +		dprintk("RPC: %5u %s: auth check failed with %d\n",
 +				task->tk_pid, __func__, error);
 +		goto out_garbage;		/* bad verifier, retry */
 +	}
 +	len = p - (__be32 *)iov->iov_base - 1;
 +	if (len < 0)
 +		goto out_overflow;
 +	switch ((n = ntohl(*p++))) {
 +	case RPC_SUCCESS:
 +		return p;
 +	case RPC_PROG_UNAVAIL:
 +		dprintk("RPC: %5u %s: program %u is unsupported "
 +				"by server %s\n", task->tk_pid, __func__,
 +				(unsigned int)clnt->cl_prog,
 +				task->tk_xprt->servername);
++=======
+ 	/* RFC-1014 says that the representation of XDR data must be a
+ 	 * multiple of four bytes
+ 	 * - if it isn't pointer subtraction in the NFS client may give
+ 	 *   undefined results
+ 	 */
+ 	if (task->tk_rqstp->rq_rcv_buf.len & 3)
+ 		goto out_badlen;
+ 
+ 	p = xdr_inline_decode(xdr, 3 * sizeof(*p));
+ 	if (!p)
+ 		goto out_unparsable;
+ 	p++;	/* skip XID */
+ 	if (*p++ != rpc_reply)
+ 		goto out_unparsable;
+ 	if (*p++ != rpc_msg_accepted)
+ 		goto out_msg_denied;
+ 
+ 	error = rpcauth_checkverf(task, xdr);
+ 	if (error)
+ 		goto out_verifier;
+ 
+ 	p = xdr_inline_decode(xdr, sizeof(*p));
+ 	if (!p)
+ 		goto out_unparsable;
+ 	switch (*p) {
+ 	case rpc_success:
+ 		return 0;
+ 	case rpc_prog_unavail:
+ 		trace_rpc__prog_unavail(task);
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  		error = -EPFNOSUPPORT;
  		goto out_err;
 -	case rpc_prog_mismatch:
 -		trace_rpc__prog_mismatch(task);
 +	case RPC_PROG_MISMATCH:
 +		dprintk("RPC: %5u %s: program %u, version %u unsupported "
 +				"by server %s\n", task->tk_pid, __func__,
 +				(unsigned int)clnt->cl_prog,
 +				(unsigned int)clnt->cl_vers,
 +				task->tk_xprt->servername);
  		error = -EPROTONOSUPPORT;
  		goto out_err;
 -	case rpc_proc_unavail:
 -		trace_rpc__proc_unavail(task);
 +	case RPC_PROC_UNAVAIL:
 +		dprintk("RPC: %5u %s: proc %s unsupported by program %u, "
 +				"version %u on server %s\n",
 +				task->tk_pid, __func__,
 +				rpc_proc_name(task),
 +				clnt->cl_prog, clnt->cl_vers,
 +				task->tk_xprt->servername);
  		error = -EOPNOTSUPP;
  		goto out_err;
 -	case rpc_garbage_args:
 -		trace_rpc__garbage_args(task);
 -		break;
 +	case RPC_GARBAGE_ARGS:
 +		dprintk("RPC: %5u %s: server saw garbage\n",
 +				task->tk_pid, __func__);
 +		break;			/* retry */
  	default:
 -		trace_rpc__unparsable(task);
 +		dprintk("RPC: %5u %s: server accept status: %x\n",
 +				task->tk_pid, __func__, n);
 +		/* Also retry */
  	}
  
  out_garbage:
  	clnt->cl_stats->rpcgarbage++;
  	if (task->tk_garb_retry) {
  		task->tk_garb_retry--;
++<<<<<<< HEAD
 +		dprintk("RPC: %5u %s: retrying\n",
 +				task->tk_pid, __func__);
 +		task->tk_action = call_bind;
 +out_retry:
 +		return ERR_PTR(-EAGAIN);
 +	}
 +out_err:
 +	rpc_exit(task, error);
 +	dprintk("RPC: %5u %s: call failed with error %d\n", task->tk_pid,
 +			__func__, error);
 +	return ERR_PTR(error);
 +out_overflow:
 +	dprintk("RPC: %5u %s: server reply was truncated.\n", task->tk_pid,
 +			__func__);
 +	goto out_garbage;
++=======
+ 		task->tk_action = call_encode;
+ 		return -EAGAIN;
+ 	}
+ out_err:
+ 	rpc_exit(task, error);
+ 	return error;
+ 
+ out_badlen:
+ 	trace_rpc__unparsable(task);
+ 	error = -EIO;
+ 	goto out_err;
+ 
+ out_unparsable:
+ 	trace_rpc__unparsable(task);
+ 	error = -EIO;
+ 	goto out_garbage;
+ 
+ out_verifier:
+ 	trace_rpc_bad_verifier(task);
+ 	goto out_garbage;
+ 
+ out_msg_denied:
+ 	p = xdr_inline_decode(xdr, sizeof(*p));
+ 	if (!p)
+ 		goto out_unparsable;
+ 	switch (*p++) {
+ 	case rpc_auth_error:
+ 		break;
+ 	case rpc_mismatch:
+ 		trace_rpc__mismatch(task);
+ 		error = -EPROTONOSUPPORT;
+ 		goto out_err;
+ 	default:
+ 		trace_rpc__unparsable(task);
+ 		error = -EIO;
+ 		goto out_err;
+ 	}
+ 
+ 	p = xdr_inline_decode(xdr, sizeof(*p));
+ 	if (!p)
+ 		goto out_unparsable;
+ 	switch (*p++) {
+ 	case rpc_autherr_rejectedcred:
+ 	case rpc_autherr_rejectedverf:
+ 	case rpcsec_gsserr_credproblem:
+ 	case rpcsec_gsserr_ctxproblem:
+ 		if (!task->tk_cred_retry)
+ 			break;
+ 		task->tk_cred_retry--;
+ 		trace_rpc__stale_creds(task);
+ 		rpcauth_invalcred(task);
+ 		/* Ensure we obtain a new XID! */
+ 		xprt_release(task);
+ 		task->tk_action = call_reserve;
+ 		return -EAGAIN;
+ 	case rpc_autherr_badcred:
+ 	case rpc_autherr_badverf:
+ 		/* possibly garbled cred/verf? */
+ 		if (!task->tk_garb_retry)
+ 			break;
+ 		task->tk_garb_retry--;
+ 		trace_rpc__bad_creds(task);
+ 		task->tk_action = call_encode;
+ 		return -EAGAIN;
+ 	case rpc_autherr_tooweak:
+ 		trace_rpc__auth_tooweak(task);
+ 		pr_warn("RPC: server %s requires stronger authentication.\n",
+ 			task->tk_xprt->servername);
+ 		break;
+ 	default:
+ 		trace_rpc__unparsable(task);
+ 		error = -EIO;
+ 	}
+ 	goto out_err;
++>>>>>>> a0584ee9aed8 (SUNRPC: Use struct xdr_stream when decoding RPC Reply header)
  }
  
  static void rpcproc_encode_null(struct rpc_rqst *rqstp, struct xdr_stream *xdr,
* Unmerged path include/linux/sunrpc/auth.h
* Unmerged path include/linux/sunrpc/xdr.h
* Unmerged path net/sunrpc/auth.c
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index 6e951620fbcd..c0e189a2e242 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -1655,59 +1655,62 @@ gss_refresh_null(struct rpc_task *task)
 	return 0;
 }
 
-static __be32 *
-gss_validate(struct rpc_task *task, __be32 *p)
+static int
+gss_validate(struct rpc_task *task, struct xdr_stream *xdr)
 {
 	struct rpc_cred *cred = task->tk_rqstp->rq_cred;
 	struct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);
-	__be32		*seq = NULL;
+	__be32		*p, *seq = NULL;
 	struct kvec	iov;
 	struct xdr_buf	verf_buf;
 	struct xdr_netobj mic;
-	u32		flav,len;
-	u32		maj_stat;
-	__be32		*ret = ERR_PTR(-EIO);
+	u32		len, maj_stat;
+	int		status;
 
-	dprintk("RPC: %5u %s\n", task->tk_pid, __func__);
+	p = xdr_inline_decode(xdr, 2 * sizeof(*p));
+	if (!p)
+		goto validate_failed;
+	if (*p++ != rpc_auth_gss)
+		goto validate_failed;
+	len = be32_to_cpup(p);
+	if (len > RPC_MAX_AUTH_SIZE)
+		goto validate_failed;
+	p = xdr_inline_decode(xdr, len);
+	if (!p)
+		goto validate_failed;
 
-	flav = ntohl(*p++);
-	if ((len = ntohl(*p++)) > RPC_MAX_AUTH_SIZE)
-		goto out_bad;
-	if (flav != RPC_AUTH_GSS)
-		goto out_bad;
 	seq = kmalloc(4, GFP_NOFS);
 	if (!seq)
-		goto out_bad;
-	*seq = htonl(task->tk_rqstp->rq_seqno);
+		goto validate_failed;
+	*seq = cpu_to_be32(task->tk_rqstp->rq_seqno);
 	iov.iov_base = seq;
 	iov.iov_len = 4;
 	xdr_buf_from_iov(&iov, &verf_buf);
 	mic.data = (u8 *)p;
 	mic.len = len;
-
-	ret = ERR_PTR(-EACCES);
 	maj_stat = gss_verify_mic(ctx->gc_gss_ctx, &verf_buf, &mic);
 	if (maj_stat == GSS_S_CONTEXT_EXPIRED)
 		clear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);
-	if (maj_stat) {
-		dprintk("RPC: %5u %s: gss_verify_mic returned error 0x%08x\n",
-			task->tk_pid, __func__, maj_stat);
-		goto out_bad;
-	}
+	if (maj_stat)
+		goto bad_mic;
+
 	/* We leave it to unwrap to calculate au_rslack. For now we just
 	 * calculate the length of the verifier: */
 	cred->cr_auth->au_verfsize = XDR_QUADLEN(len) + 2;
+	status = 0;
+out:
 	gss_put_ctx(ctx);
-	dprintk("RPC: %5u %s: gss_verify_mic succeeded.\n",
-			task->tk_pid, __func__);
-	kfree(seq);
-	return p + XDR_QUADLEN(len);
-out_bad:
-	gss_put_ctx(ctx);
-	dprintk("RPC: %5u %s failed ret %ld.\n", task->tk_pid, __func__,
-		PTR_ERR(ret));
 	kfree(seq);
-	return ret;
+	return status;
+
+validate_failed:
+	status = -EIO;
+	goto out;
+bad_mic:
+	dprintk("RPC: %5u %s: gss_verify_mic returned error 0x%08x\n",
+		task->tk_pid, __func__, maj_stat);
+	status = -EACCES;
+	goto out;
 }
 
 static void gss_wrap_req_encode(kxdreproc_t encode, struct rpc_rqst *rqstp,
@@ -1920,79 +1923,98 @@ gss_wrap_req(struct rpc_task *task,
 	return status;
 }
 
-static inline int
+static int
+gss_unwrap_resp_auth(struct rpc_cred *cred)
+{
+	cred->cr_auth->au_rslack = cred->cr_auth->au_verfsize;
+	return 0;
+}
+
+static int
 gss_unwrap_resp_integ(struct rpc_cred *cred, struct gss_cl_ctx *ctx,
-		struct rpc_rqst *rqstp, __be32 **p)
+		      struct rpc_rqst *rqstp, struct xdr_stream *xdr)
 {
-	struct xdr_buf	*rcv_buf = &rqstp->rq_rcv_buf;
-	struct xdr_buf integ_buf;
+	struct xdr_buf integ_buf, *rcv_buf = &rqstp->rq_rcv_buf;
+	u32 data_offset, mic_offset, integ_len, maj_stat;
 	struct xdr_netobj mic;
-	u32 data_offset, mic_offset;
-	u32 integ_len;
-	u32 maj_stat;
-	int status = -EIO;
+	__be32 *p;
 
-	integ_len = ntohl(*(*p)++);
+	p = xdr_inline_decode(xdr, 2 * sizeof(*p));
+	if (unlikely(!p))
+		goto unwrap_failed;
+	integ_len = be32_to_cpup(p++);
 	if (integ_len & 3)
-		return status;
-	data_offset = (u8 *)(*p) - (u8 *)rcv_buf->head[0].iov_base;
+		goto unwrap_failed;
+	data_offset = (u8 *)(p) - (u8 *)rcv_buf->head[0].iov_base;
 	mic_offset = integ_len + data_offset;
 	if (mic_offset > rcv_buf->len)
-		return status;
-	if (ntohl(*(*p)++) != rqstp->rq_seqno)
-		return status;
-
-	if (xdr_buf_subsegment(rcv_buf, &integ_buf, data_offset,
-				mic_offset - data_offset))
-		return status;
+		goto unwrap_failed;
+	if (be32_to_cpup(p) != rqstp->rq_seqno)
+		goto unwrap_failed;
 
+	if (xdr_buf_subsegment(rcv_buf, &integ_buf, data_offset, integ_len))
+		goto unwrap_failed;
 	if (xdr_buf_read_netobj(rcv_buf, &mic, mic_offset))
-		return status;
-
+		goto unwrap_failed;
 	maj_stat = gss_verify_mic(ctx->gc_gss_ctx, &integ_buf, &mic);
 	if (maj_stat == GSS_S_CONTEXT_EXPIRED)
 		clear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);
 	if (maj_stat != GSS_S_COMPLETE)
-		return status;
+		goto bad_mic;
+
+	cred->cr_auth->au_rslack = cred->cr_auth->au_verfsize + 2 +
+				   1 + XDR_QUADLEN(mic.len);
 	return 0;
+unwrap_failed:
+	return -EIO;
+bad_mic:
+	dprintk("RPC:       %s: gss_verify_mic returned error 0x%08x\n",
+		__func__, maj_stat);
+	return -EIO;
 }
 
-static inline int
+static int
 gss_unwrap_resp_priv(struct rpc_cred *cred, struct gss_cl_ctx *ctx,
-		struct rpc_rqst *rqstp, __be32 **p)
-{
-	struct xdr_buf  *rcv_buf = &rqstp->rq_rcv_buf;
-	u32 offset;
-	u32 opaque_len;
-	u32 maj_stat;
-	int status = -EIO;
-
-	opaque_len = ntohl(*(*p)++);
-	offset = (u8 *)(*p) - (u8 *)rcv_buf->head[0].iov_base;
+		     struct rpc_rqst *rqstp, struct xdr_stream *xdr)
+{
+	struct xdr_buf *rcv_buf = &rqstp->rq_rcv_buf;
+	struct kvec *head = rqstp->rq_rcv_buf.head;
+	unsigned int savedlen = rcv_buf->len;
+	u32 offset, opaque_len, maj_stat;
+	__be32 *p;
+
+	p = xdr_inline_decode(xdr, 2 * sizeof(*p));
+	if (unlikely(!p))
+		goto unwrap_failed;
+	opaque_len = be32_to_cpup(p++);
+	offset = (u8 *)(p) - (u8 *)head->iov_base;
 	if (offset + opaque_len > rcv_buf->len)
-		return status;
-	/* remove padding: */
+		goto unwrap_failed;
 	rcv_buf->len = offset + opaque_len;
 
 	maj_stat = gss_unwrap(ctx->gc_gss_ctx, offset, rcv_buf);
 	if (maj_stat == GSS_S_CONTEXT_EXPIRED)
 		clear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);
 	if (maj_stat != GSS_S_COMPLETE)
-		return status;
-	if (ntohl(*(*p)++) != rqstp->rq_seqno)
-		return status;
-
-	return 0;
-}
+		goto bad_unwrap;
+	/* gss_unwrap decrypted the sequence number */
+	if (be32_to_cpup(p++) != rqstp->rq_seqno)
+		goto unwrap_failed;
 
-static int
-gss_unwrap_req_decode(kxdrdproc_t decode, struct rpc_rqst *rqstp,
-		      __be32 *p, void *obj)
-{
-	struct xdr_stream xdr;
+	/* gss_unwrap redacts the opaque blob from the head iovec.
+	 * rcv_buf has changed, thus the stream needs to be reset.
+	 */
+	xdr_init_decode(xdr, rcv_buf, p, rqstp);
 
-	xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p, rqstp);
-	return decode(rqstp, &xdr, obj);
+	cred->cr_auth->au_rslack = cred->cr_auth->au_verfsize + 2 +
+				   XDR_QUADLEN(savedlen - rcv_buf->len);
+	return 0;
+unwrap_failed:
+	return -EIO;
+bad_unwrap:
+	dprintk("RPC:       %s: gss_unwrap returned error 0x%08x\n",
+		__func__, maj_stat);
+	return -EIO;
 }
 
 static bool
@@ -2036,39 +2058,33 @@ gss_xmit_need_reencode(struct rpc_task *task)
 }
 
 static int
-gss_unwrap_resp(struct rpc_task *task,
-		kxdrdproc_t decode, void *rqstp, __be32 *p, void *obj)
+gss_unwrap_resp(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	struct rpc_cred *cred = task->tk_rqstp->rq_cred;
+	struct rpc_rqst *rqstp = task->tk_rqstp;
+	struct rpc_cred *cred = rqstp->rq_cred;
 	struct gss_cred *gss_cred = container_of(cred, struct gss_cred,
 			gc_base);
 	struct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);
-	__be32		*savedp = p;
-	struct kvec	*head = ((struct rpc_rqst *)rqstp)->rq_rcv_buf.head;
-	int		savedlen = head->iov_len;
-	int             status = -EIO;
+	int status = -EIO;
 
 	if (ctx->gc_proc != RPC_GSS_PROC_DATA)
 		goto out_decode;
 	switch (gss_cred->gc_service) {
 	case RPC_GSS_SVC_NONE:
+		status = gss_unwrap_resp_auth(cred);
 		break;
 	case RPC_GSS_SVC_INTEGRITY:
-		status = gss_unwrap_resp_integ(cred, ctx, rqstp, &p);
-		if (status)
-			goto out;
+		status = gss_unwrap_resp_integ(cred, ctx, rqstp, xdr);
 		break;
 	case RPC_GSS_SVC_PRIVACY:
-		status = gss_unwrap_resp_priv(cred, ctx, rqstp, &p);
-		if (status)
-			goto out;
+		status = gss_unwrap_resp_priv(cred, ctx, rqstp, xdr);
 		break;
 	}
-	/* take into account extra slack for integrity and privacy cases: */
-	cred->cr_auth->au_rslack = cred->cr_auth->au_verfsize + (p - savedp)
-						+ (savedlen - head->iov_len);
+	if (status)
+		goto out;
+
 out_decode:
-	status = gss_unwrap_req_decode(decode, rqstp, p, obj);
+	status = rpcauth_unwrap_resp_decode(task, xdr);
 out:
 	gss_put_ctx(ctx);
 	dprintk("RPC: %5u %s returning %d\n",
diff --git a/net/sunrpc/auth_null.c b/net/sunrpc/auth_null.c
index d0ceac57c06e..deb72329dafa 100644
--- a/net/sunrpc/auth_null.c
+++ b/net/sunrpc/auth_null.c
@@ -80,25 +80,19 @@ nul_refresh(struct rpc_task *task)
 	return 0;
 }
 
-static __be32 *
-nul_validate(struct rpc_task *task, __be32 *p)
+static int
+nul_validate(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	rpc_authflavor_t	flavor;
-	u32			size;
-
-	flavor = ntohl(*p++);
-	if (flavor != RPC_AUTH_NULL) {
-		printk("RPC: bad verf flavor: %u\n", flavor);
-		return ERR_PTR(-EIO);
-	}
-
-	size = ntohl(*p++);
-	if (size != 0) {
-		printk("RPC: bad verf size: %u\n", size);
-		return ERR_PTR(-EIO);
-	}
-
-	return p;
+	__be32 *p;
+
+	p = xdr_inline_decode(xdr, 2 * sizeof(*p));
+	if (!p)
+		return -EIO;
+	if (*p++ != rpc_auth_null)
+		return -EIO;
+	if (*p != xdr_zero)
+		return -EIO;
+	return 0;
 }
 
 const struct rpc_authops authnull_ops = {
@@ -127,6 +121,7 @@ const struct rpc_credops null_credops = {
 	.crmarshal	= nul_marshal,
 	.crrefresh	= nul_refresh,
 	.crvalidate	= nul_validate,
+	.crunwrap_resp	= rpcauth_unwrap_resp_decode,
 };
 
 static
diff --git a/net/sunrpc/auth_unix.c b/net/sunrpc/auth_unix.c
index fc8a59134640..4357d6cb09be 100644
--- a/net/sunrpc/auth_unix.c
+++ b/net/sunrpc/auth_unix.c
@@ -142,29 +142,32 @@ unx_refresh(struct rpc_task *task)
 	return 0;
 }
 
-static __be32 *
-unx_validate(struct rpc_task *task, __be32 *p)
+static int
+unx_validate(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	rpc_authflavor_t	flavor;
-	u32			size;
-
-	flavor = ntohl(*p++);
-	if (flavor != RPC_AUTH_NULL &&
-	    flavor != RPC_AUTH_UNIX &&
-	    flavor != RPC_AUTH_SHORT) {
-		printk("RPC: bad verf flavor: %u\n", flavor);
-		return ERR_PTR(-EIO);
+	__be32 *p;
+	u32 size;
+
+	p = xdr_inline_decode(xdr, 2 * sizeof(*p));
+	if (!p)
+		return -EIO;
+	switch (*p++) {
+	case rpc_auth_null:
+	case rpc_auth_unix:
+	case rpc_auth_short:
+		break;
+	default:
+		return -EIO;
 	}
+	size = be32_to_cpup(p);
+	if (size > RPC_MAX_AUTH_SIZE)
+		return -EIO;
+	p = xdr_inline_decode(xdr, size);
+	if (!p)
+		return -EIO;
 
-	size = ntohl(*p++);
-	if (size > RPC_MAX_AUTH_SIZE) {
-		printk("RPC: giant verf size: %u\n", size);
-		return ERR_PTR(-EIO);
-	}
 	task->tk_rqstp->rq_cred->cr_auth->au_rslack = (size >> 2) + 2;
-	p += (size >> 2);
-
-	return p;
+	return 0;
 }
 
 int __init rpc_init_authunix(void)
@@ -204,4 +207,5 @@ const struct rpc_credops unix_credops = {
 	.crmarshal	= unx_marshal,
 	.crrefresh	= unx_refresh,
 	.crvalidate	= unx_validate,
+	.crunwrap_resp	= rpcauth_unwrap_resp_decode,
 };
* Unmerged path net/sunrpc/clnt.c
