net: rtnetlink: address is mandatory for rtnl_fdb_get

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] rtnetlink: address is mandatory for rtnl_fdb_get (Ivan Vecera) [1757105]
Rebuild_FUZZ: 95.05%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit f989d03ef25df3fc26d3ea0fe7c19c9830577166
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f989d03e.failed

We must have an address to lookup otherwise we'll derefence a null
pointer in the ndo_fdb_get callbacks.

CC: Roopa Prabhu <roopa@cumulusnetworks.com>
CC: David Ahern <dsa@cumulusnetworks.com>
	Reported-by: syzbot+017b1f61c82a1c3e7efd@syzkaller.appspotmail.com
Fixes: 5b2f94b27622 ("net: rtnetlink: support for fdb get")
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f989d03ef25df3fc26d3ea0fe7c19c9830577166)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index ec057d9ee278,5ea1bed08ede..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -4034,6 -4021,165 +4034,168 @@@ out
  	return skb->len;
  }
  
++<<<<<<< HEAD
++=======
+ static int valid_fdb_get_strict(const struct nlmsghdr *nlh,
+ 				struct nlattr **tb, u8 *ndm_flags,
+ 				int *br_idx, int *brport_idx, u8 **addr,
+ 				u16 *vid, struct netlink_ext_ack *extack)
+ {
+ 	struct ndmsg *ndm;
+ 	int err, i;
+ 
+ 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {
+ 		NL_SET_ERR_MSG(extack, "Invalid header for fdb get request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ndm = nlmsg_data(nlh);
+ 	if (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||
+ 	    ndm->ndm_type) {
+ 		NL_SET_ERR_MSG(extack, "Invalid values in header for fdb get request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ndm->ndm_flags & ~(NTF_MASTER | NTF_SELF)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid flags in header for fdb get request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = nlmsg_parse_strict(nlh, sizeof(struct ndmsg), tb, NDA_MAX,
+ 				 nda_policy, extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	*ndm_flags = ndm->ndm_flags;
+ 	*brport_idx = ndm->ndm_ifindex;
+ 	for (i = 0; i <= NDA_MAX; ++i) {
+ 		if (!tb[i])
+ 			continue;
+ 
+ 		switch (i) {
+ 		case NDA_MASTER:
+ 			*br_idx = nla_get_u32(tb[i]);
+ 			break;
+ 		case NDA_LLADDR:
+ 			if (nla_len(tb[i]) != ETH_ALEN) {
+ 				NL_SET_ERR_MSG(extack, "Invalid address in fdb get request");
+ 				return -EINVAL;
+ 			}
+ 			*addr = nla_data(tb[i]);
+ 			break;
+ 		case NDA_VLAN:
+ 			err = fdb_vid_parse(tb[i], vid, extack);
+ 			if (err)
+ 				return err;
+ 			break;
+ 		case NDA_VNI:
+ 			break;
+ 		default:
+ 			NL_SET_ERR_MSG(extack, "Unsupported attribute in fdb get request");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_fdb_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,
+ 			struct netlink_ext_ack *extack)
+ {
+ 	struct net_device *dev = NULL, *br_dev = NULL;
+ 	const struct net_device_ops *ops = NULL;
+ 	struct net *net = sock_net(in_skb->sk);
+ 	struct nlattr *tb[NDA_MAX + 1];
+ 	struct sk_buff *skb;
+ 	int brport_idx = 0;
+ 	u8 ndm_flags = 0;
+ 	int br_idx = 0;
+ 	u8 *addr = NULL;
+ 	u16 vid = 0;
+ 	int err;
+ 
+ 	err = valid_fdb_get_strict(nlh, tb, &ndm_flags, &br_idx,
+ 				   &brport_idx, &addr, &vid, extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (!addr) {
+ 		NL_SET_ERR_MSG(extack, "Missing lookup address for fdb get request");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (brport_idx) {
+ 		dev = __dev_get_by_index(net, brport_idx);
+ 		if (!dev) {
+ 			NL_SET_ERR_MSG(extack, "Unknown device ifindex");
+ 			return -ENODEV;
+ 		}
+ 	}
+ 
+ 	if (br_idx) {
+ 		if (dev) {
+ 			NL_SET_ERR_MSG(extack, "Master and device are mutually exclusive");
+ 			return -EINVAL;
+ 		}
+ 
+ 		br_dev = __dev_get_by_index(net, br_idx);
+ 		if (!br_dev) {
+ 			NL_SET_ERR_MSG(extack, "Invalid master ifindex");
+ 			return -EINVAL;
+ 		}
+ 		ops = br_dev->netdev_ops;
+ 	}
+ 
+ 	if (dev) {
+ 		if (!ndm_flags || (ndm_flags & NTF_MASTER)) {
+ 			if (!(dev->priv_flags & IFF_BRIDGE_PORT)) {
+ 				NL_SET_ERR_MSG(extack, "Device is not a bridge port");
+ 				return -EINVAL;
+ 			}
+ 			br_dev = netdev_master_upper_dev_get(dev);
+ 			if (!br_dev) {
+ 				NL_SET_ERR_MSG(extack, "Master of device not found");
+ 				return -EINVAL;
+ 			}
+ 			ops = br_dev->netdev_ops;
+ 		} else {
+ 			if (!(ndm_flags & NTF_SELF)) {
+ 				NL_SET_ERR_MSG(extack, "Missing NTF_SELF");
+ 				return -EINVAL;
+ 			}
+ 			ops = dev->netdev_ops;
+ 		}
+ 	}
+ 
+ 	if (!br_dev && !dev) {
+ 		NL_SET_ERR_MSG(extack, "No device specified");
+ 		return -ENODEV;
+ 	}
+ 
+ 	if (!ops || !ops->ndo_fdb_get) {
+ 		NL_SET_ERR_MSG(extack, "Fdb get operation not supported by device");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+ 	if (!skb)
+ 		return -ENOBUFS;
+ 
+ 	if (br_dev)
+ 		dev = br_dev;
+ 	err = ops->ndo_fdb_get(skb, tb, dev, addr, vid,
+ 			       NETLINK_CB(in_skb).portid,
+ 			       nlh->nlmsg_seq, extack);
+ 	if (err)
+ 		goto out;
+ 
+ 	return rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);
+ out:
+ 	kfree_skb(skb);
+ 	return err;
+ }
+ 
++>>>>>>> f989d03ef25d (net: rtnetlink: address is mandatory for rtnl_fdb_get)
  static int brport_nla_put_flag(struct sk_buff *skb, u32 flags, u32 mask,
  			       unsigned int attrnum, unsigned int flag)
  {
* Unmerged path net/core/rtnetlink.c
