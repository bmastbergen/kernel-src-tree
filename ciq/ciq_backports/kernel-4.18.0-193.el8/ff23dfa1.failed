IB: Pass only ib_udata in function prototypes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
commit ff23dfa134576e071ace69e91761d229a0f73139
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ff23dfa1.failed

Now when ib_udata is passed to all the driver's object create/destroy APIs
the ib_udata will carry the ib_ucontext for every user command. There is
no need to also pass the ib_ucontext via the functions prototypes.

Make ib_udata the only argument psssed.

	Signed-off-by: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit ff23dfa134576e071ace69e91761d229a0f73139)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/verbs.c
#	drivers/infiniband/hw/bnxt_re/ib_verbs.c
#	drivers/infiniband/hw/bnxt_re/ib_verbs.h
#	drivers/infiniband/hw/cxgb3/iwch_provider.c
#	drivers/infiniband/hw/cxgb4/provider.c
#	drivers/infiniband/hw/hns/hns_roce_cq.c
#	drivers/infiniband/hw/hns/hns_roce_device.h
#	drivers/infiniband/hw/hns/hns_roce_hw_v1.c
#	drivers/infiniband/hw/hns/hns_roce_pd.c
#	drivers/infiniband/hw/i40iw/i40iw_verbs.c
#	drivers/infiniband/hw/mlx4/cq.c
#	drivers/infiniband/hw/mlx4/doorbell.c
#	drivers/infiniband/hw/mlx4/main.c
#	drivers/infiniband/hw/mlx4/mlx4_ib.h
#	drivers/infiniband/hw/mlx4/qp.c
#	drivers/infiniband/hw/mlx4/srq.c
#	drivers/infiniband/hw/mlx5/cq.c
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
#	drivers/infiniband/hw/mthca/mthca_provider.c
#	drivers/infiniband/hw/nes/nes_verbs.c
#	drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
#	drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
#	drivers/infiniband/hw/qedr/verbs.c
#	drivers/infiniband/hw/qedr/verbs.h
#	drivers/infiniband/hw/usnic/usnic_ib_verbs.c
#	drivers/infiniband/hw/usnic/usnic_ib_verbs.h
#	drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
#	drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
#	drivers/infiniband/sw/rdmavt/pd.c
#	drivers/infiniband/sw/rdmavt/pd.h
#	drivers/infiniband/sw/rdmavt/qp.c
#	drivers/infiniband/sw/rdmavt/srq.c
#	drivers/infiniband/sw/rxe/rxe_qp.c
#	drivers/infiniband/sw/rxe/rxe_verbs.c
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 4aa2231ad8ef,89b0f5420dfe..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -417,6 -421,11 +417,14 @@@ static int ib_uverbs_alloc_pd(struct uv
  	pd->uobject = uobj;
  	pd->__internal_mr = NULL;
  	atomic_set(&pd->usecnt, 0);
++<<<<<<< HEAD
++=======
+ 	pd->res.type = RDMA_RESTRACK_PD;
+ 
+ 	ret = ib_dev->ops.alloc_pd(pd, &attrs->driver_udata);
+ 	if (ret)
+ 		goto err_alloc;
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  	uobj->object = pd;
  	memset(&resp, 0, sizeof resp);
diff --cc drivers/infiniband/core/verbs.c
index 3220fb42ecce,a479f4c12541..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -265,6 -266,16 +265,19 @@@ struct ib_pd *__ib_alloc_pd(struct ib_d
  	atomic_set(&pd->usecnt, 0);
  	pd->flags = flags;
  
++<<<<<<< HEAD
++=======
+ 	pd->res.type = RDMA_RESTRACK_PD;
+ 	rdma_restrack_set_task(&pd->res, caller);
+ 
+ 	ret = device->ops.alloc_pd(pd, NULL);
+ 	if (ret) {
+ 		kfree(pd);
+ 		return ERR_PTR(ret);
+ 	}
+ 	rdma_restrack_kadd(&pd->res);
+ 
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	if (device->attrs.device_cap_flags & IB_DEVICE_LOCAL_DMA_LKEY)
  		pd->local_dma_lkey = device->local_dma_lkey;
  	else
diff --cc drivers/infiniband/hw/bnxt_re/ib_verbs.c
index bfcab22666c5,04e3529ffe06..000000000000
--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.c
+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.c
@@@ -571,33 -571,20 +571,43 @@@ int bnxt_re_dealloc_pd(struct ib_pd *ib
  
  	bnxt_re_destroy_fence_mr(pd);
  
 -	if (pd->qplib_pd.id)
 -		bnxt_qplib_dealloc_pd(&rdev->qplib_res, &rdev->qplib_res.pd_tbl,
 -				      &pd->qplib_pd);
 +	if (pd->qplib_pd.id) {
 +		rc = bnxt_qplib_dealloc_pd(&rdev->qplib_res,
 +					   &rdev->qplib_res.pd_tbl,
 +					   &pd->qplib_pd);
 +		if (rc)
 +			dev_err(rdev_to_dev(rdev), "Failed to deallocate HW PD");
 +	}
 +
 +	kfree(pd);
 +	return 0;
  }
  
++<<<<<<< HEAD
 +struct ib_pd *bnxt_re_alloc_pd(struct ib_device *ibdev,
 +			       struct ib_ucontext *ucontext,
 +			       struct ib_udata *udata)
++=======
+ int bnxt_re_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = ibpd->device;
  	struct bnxt_re_dev *rdev = to_bnxt_re_dev(ibdev, ibdev);
++<<<<<<< HEAD
 +	struct bnxt_re_ucontext *ucntx = container_of(ucontext,
 +						      struct bnxt_re_ucontext,
 +						      ib_uctx);
 +	struct bnxt_re_pd *pd;
++=======
+ 	struct bnxt_re_ucontext *ucntx = rdma_udata_to_drv_context(
+ 		udata, struct bnxt_re_ucontext, ib_uctx);
+ 	struct bnxt_re_pd *pd = container_of(ibpd, struct bnxt_re_pd, ib_pd);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	int rc;
  
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
 +
  	pd->rdev = rdev;
  	if (bnxt_qplib_alloc_pd(&rdev->qplib_res.pd_tbl, &pd->qplib_pd)) {
  		dev_err(rdev_to_dev(rdev), "Failed to allocate HW PD");
diff --cc drivers/infiniband/hw/bnxt_re/ib_verbs.h
index c4af72604b4f,488dc735a260..000000000000
--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.h
+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.h
@@@ -163,10 -163,8 +163,15 @@@ int bnxt_re_query_gid(struct ib_device 
  		      int index, union ib_gid *gid);
  enum rdma_link_layer bnxt_re_get_link_layer(struct ib_device *ibdev,
  					    u8 port_num);
++<<<<<<< HEAD
 +struct ib_pd *bnxt_re_alloc_pd(struct ib_device *ibdev,
 +			       struct ib_ucontext *context,
 +			       struct ib_udata *udata);
 +int bnxt_re_dealloc_pd(struct ib_pd *pd);
++=======
+ int bnxt_re_alloc_pd(struct ib_pd *pd, struct ib_udata *udata);
+ void bnxt_re_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  struct ib_ah *bnxt_re_create_ah(struct ib_pd *pd,
  				struct rdma_ah_attr *ah_attr,
  				u32 flags,
@@@ -198,9 -196,8 +203,8 @@@ int bnxt_re_post_recv(struct ib_qp *qp
  		      const struct ib_recv_wr **bad_recv_wr);
  struct ib_cq *bnxt_re_create_cq(struct ib_device *ibdev,
  				const struct ib_cq_init_attr *attr,
- 				struct ib_ucontext *context,
  				struct ib_udata *udata);
 -int bnxt_re_destroy_cq(struct ib_cq *cq, struct ib_udata *udata);
 +int bnxt_re_destroy_cq(struct ib_cq *cq);
  int bnxt_re_poll_cq(struct ib_cq *cq, int num_entries, struct ib_wc *wc);
  int bnxt_re_req_notify_cq(struct ib_cq *cq, enum ib_cq_notify_flags flags);
  struct ib_mr *bnxt_re_get_dma_mr(struct ib_pd *pd, int mr_access_flags);
diff --cc drivers/infiniband/hw/cxgb3/iwch_provider.c
index b9bb151437dc,62b99d26f0d3..000000000000
--- a/drivers/infiniband/hw/cxgb3/iwch_provider.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_provider.c
@@@ -379,15 -375,12 +378,19 @@@ static int iwch_deallocate_pd(struct ib
  	rhp = php->rhp;
  	pr_debug("%s ibpd %p pdid 0x%x\n", __func__, pd, php->pdid);
  	cxio_hal_put_pdid(rhp->rdev.rscp, php->pdid);
 +	kfree(php);
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static struct ib_pd *iwch_allocate_pd(struct ib_device *ibdev,
 +			       struct ib_ucontext *context,
 +			       struct ib_udata *udata)
++=======
+ static int iwch_allocate_pd(struct ib_pd *pd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct iwch_pd *php = to_iwch_pd(pd);
 -	struct ib_device *ibdev = pd->device;
 +	struct iwch_pd *php;
  	u32 pdid;
  	struct iwch_dev *rhp;
  
@@@ -395,15 -388,11 +398,15 @@@
  	rhp = (struct iwch_dev *) ibdev;
  	pdid = cxio_hal_get_pdid(rhp->rdev.rscp);
  	if (!pdid)
 -		return -EINVAL;
 -
 +		return ERR_PTR(-EINVAL);
 +	php = kzalloc(sizeof(*php), GFP_KERNEL);
 +	if (!php) {
 +		cxio_hal_put_pdid(rhp->rdev.rscp, pdid);
 +		return ERR_PTR(-ENOMEM);
 +	}
  	php->pdid = pdid;
  	php->rhp = rhp;
- 	if (context) {
+ 	if (udata) {
  		struct iwch_alloc_pd_resp resp = {.pdid = php->pdid};
  
  		if (ib_copy_to_udata(udata, &resp, sizeof(resp))) {
diff --cc drivers/infiniband/hw/cxgb4/provider.c
index adda8df00ce5,0fbad47661cc..000000000000
--- a/drivers/infiniband/hw/cxgb4/provider.c
+++ b/drivers/infiniband/hw/cxgb4/provider.c
@@@ -211,15 -202,12 +211,19 @@@ static int c4iw_deallocate_pd(struct ib
  	mutex_lock(&rhp->rdev.stats.lock);
  	rhp->rdev.stats.pd.cur--;
  	mutex_unlock(&rhp->rdev.stats.lock);
 +	kfree(php);
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static struct ib_pd *c4iw_allocate_pd(struct ib_device *ibdev,
 +				      struct ib_ucontext *context,
 +				      struct ib_udata *udata)
++=======
+ static int c4iw_allocate_pd(struct ib_pd *pd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct c4iw_pd *php = to_c4iw_pd(pd);
 -	struct ib_device *ibdev = pd->device;
 +	struct c4iw_pd *php;
  	u32 pdid;
  	struct c4iw_dev *rhp;
  
@@@ -227,15 -215,11 +231,15 @@@
  	rhp = (struct c4iw_dev *) ibdev;
  	pdid =  c4iw_get_resource(&rhp->rdev.resource.pdid_table);
  	if (!pdid)
 -		return -EINVAL;
 -
 +		return ERR_PTR(-EINVAL);
 +	php = kzalloc(sizeof(*php), GFP_KERNEL);
 +	if (!php) {
 +		c4iw_put_resource(&rhp->rdev.resource.pdid_table, pdid);
 +		return ERR_PTR(-ENOMEM);
 +	}
  	php->pdid = pdid;
  	php->rhp = rhp;
- 	if (context) {
+ 	if (udata) {
  		struct c4iw_alloc_pd_resp uresp = {.pdid = php->pdid};
  
  		if (ib_copy_to_udata(udata, &uresp, sizeof(uresp))) {
diff --cc drivers/infiniband/hw/hns/hns_roce_cq.c
index 3a485f50fede,9caf35061721..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_cq.c
+++ b/drivers/infiniband/hw/hns/hns_roce_cq.c
@@@ -357,8 -351,8 +358,13 @@@ struct ib_cq *hns_roce_ib_create_cq(str
  
  		if ((hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) &&
  		    (udata->outlen >= sizeof(resp))) {
++<<<<<<< HEAD
 +			ret = hns_roce_db_map_user(to_hr_ucontext(context),
 +						   ucmd.db_addr, &hr_cq->db);
++=======
+ 			ret = hns_roce_db_map_user(context, udata, ucmd.db_addr,
+ 						   &hr_cq->db);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  			if (ret) {
  				dev_err(dev, "cq record doorbell map failed!\n");
  				goto err_mtt;
diff --cc drivers/infiniband/hw/hns/hns_roce_device.h
index 5996c474cbe8,b23b13f06d58..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_device.h
+++ b/drivers/infiniband/hw/hns/hns_roce_device.h
@@@ -961,12 -1110,10 +961,17 @@@ struct ib_ah *hns_roce_create_ah(struc
  				 u32 flags,
  				 struct ib_udata *udata);
  int hns_roce_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr);
 -int hns_roce_destroy_ah(struct ib_ah *ah, u32 flags, struct ib_udata *udata);
 +int hns_roce_destroy_ah(struct ib_ah *ah, u32 flags);
  
++<<<<<<< HEAD
 +struct ib_pd *hns_roce_alloc_pd(struct ib_device *ib_dev,
 +				struct ib_ucontext *context,
 +				struct ib_udata *udata);
 +int hns_roce_dealloc_pd(struct ib_pd *pd);
++=======
+ int hns_roce_alloc_pd(struct ib_pd *pd, struct ib_udata *udata);
+ void hns_roce_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  struct ib_mr *hns_roce_get_dma_mr(struct ib_pd *pd, int acc);
  struct ib_mr *hns_roce_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,
@@@ -1013,13 -1176,13 +1018,12 @@@ int to_hr_qp_type(int qp_type)
  
  struct ib_cq *hns_roce_ib_create_cq(struct ib_device *ib_dev,
  				    const struct ib_cq_init_attr *attr,
- 				    struct ib_ucontext *context,
  				    struct ib_udata *udata);
  
 -int hns_roce_ib_destroy_cq(struct ib_cq *ib_cq, struct ib_udata *udata);
 +int hns_roce_ib_destroy_cq(struct ib_cq *ib_cq);
  void hns_roce_free_cq(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq);
  
 -int hns_roce_db_map_user(struct hns_roce_ucontext *context,
 -			 struct ib_udata *udata, unsigned long virt,
 +int hns_roce_db_map_user(struct hns_roce_ucontext *context, unsigned long virt,
  			 struct hns_roce_db *db);
  void hns_roce_db_unmap_user(struct hns_roce_ucontext *context,
  			    struct hns_roce_db *db);
diff --cc drivers/infiniband/hw/hns/hns_roce_hw_v1.c
index 2b5be3df27d6,98c6a41edefd..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
+++ b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
@@@ -742,12 -743,16 +742,23 @@@ static int hns_roce_v1_rsv_lp_qp(struc
  	free_mr->mr_free_cq->ib_cq.cq_context		= NULL;
  	atomic_set(&free_mr->mr_free_cq->ib_cq.usecnt, 0);
  
++<<<<<<< HEAD
 +	pd = hns_roce_alloc_pd(&hr_dev->ib_dev, NULL, NULL);
 +	if (IS_ERR(pd)) {
 +		dev_err(dev, "Create pd for reserved loop qp failed!");
 +		ret = -ENOMEM;
++=======
+ 	ibdev = &hr_dev->ib_dev;
+ 	pd = rdma_zalloc_drv_obj(ibdev, ib_pd);
+ 	if (!pd)
+ 		goto alloc_mem_failed;
+ 
+ 	pd->device  = ibdev;
+ 	ret = hns_roce_alloc_pd(pd, NULL);
+ 	if (ret)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  		goto alloc_pd_failed;
 -
 +	}
  	free_mr->mr_free_pd = to_hr_pd(pd);
  	free_mr->mr_free_pd->ibpd.device  = &hr_dev->ib_dev;
  	free_mr->mr_free_pd->ibpd.uobject = NULL;
diff --cc drivers/infiniband/hw/hns/hns_roce_pd.c
index 4a29b2cb9bab,813401384d78..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_pd.c
+++ b/drivers/infiniband/hw/hns/hns_roce_pd.c
@@@ -57,27 -57,21 +57,31 @@@ void hns_roce_cleanup_pd_table(struct h
  	hns_roce_bitmap_cleanup(&hr_dev->pd_bitmap);
  }
  
++<<<<<<< HEAD
 +struct ib_pd *hns_roce_alloc_pd(struct ib_device *ib_dev,
 +				struct ib_ucontext *context,
 +				struct ib_udata *udata)
++=======
+ int hns_roce_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ib_dev = ibpd->device;
  	struct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);
  	struct device *dev = hr_dev->dev;
 -	struct hns_roce_pd *pd = to_hr_pd(ibpd);
 +	struct hns_roce_pd *pd;
  	int ret;
  
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
 +
  	ret = hns_roce_pd_alloc(to_hr_dev(ib_dev), &pd->pdn);
  	if (ret) {
 +		kfree(pd);
  		dev_err(dev, "[alloc_pd]hns_roce_pd_alloc failed!\n");
 -		return ret;
 +		return ERR_PTR(ret);
  	}
  
- 	if (context) {
+ 	if (udata) {
  		struct hns_roce_ib_alloc_pd_resp uresp = {.pdn = pd->pdn};
  
  		if (ib_copy_to_udata(udata, &uresp, sizeof(uresp))) {
diff --cc drivers/infiniband/hw/i40iw/i40iw_verbs.c
index 524f42b9e564,7bf7fe854464..000000000000
--- a/drivers/infiniband/hw/i40iw/i40iw_verbs.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
@@@ -312,16 -290,13 +312,23 @@@ static void i40iw_dealloc_push_page(str
  
  /**
   * i40iw_alloc_pd - allocate protection domain
++<<<<<<< HEAD
 + * @ibdev: device pointer from stack
 + * @context: user context created during alloc
 + * @udata: user data
 + */
 +static struct ib_pd *i40iw_alloc_pd(struct ib_device *ibdev,
 +				    struct ib_ucontext *context,
 +				    struct ib_udata *udata)
++=======
+  * @pd: PD pointer
+  * @udata: user data
+  */
+ static int i40iw_alloc_pd(struct ib_pd *pd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct i40iw_pd *iwpd = to_iwpd(pd);
 -	struct i40iw_device *iwdev = to_iwdev(pd->device);
 +	struct i40iw_pd *iwpd;
 +	struct i40iw_device *iwdev = to_iwdev(ibdev);
  	struct i40iw_sc_dev *dev = &iwdev->sc_dev;
  	struct i40iw_alloc_pd_resp uresp;
  	struct i40iw_sc_pd *sc_pd;
diff --cc drivers/infiniband/hw/mlx4/cq.c
index 43512347b4f0,022a0b4ea452..000000000000
--- a/drivers/infiniband/hw/mlx4/cq.c
+++ b/drivers/infiniband/hw/mlx4/cq.c
@@@ -219,8 -220,7 +220,12 @@@ struct ib_cq *mlx4_ib_create_cq(struct 
  		if (err)
  			goto err_cq;
  
++<<<<<<< HEAD
 +		err = mlx4_ib_db_map_user(to_mucontext(context), ucmd.db_addr,
 +					  &cq->db);
++=======
+ 		err = mlx4_ib_db_map_user(udata, ucmd.db_addr, &cq->db);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  		if (err)
  			goto err_mtt;
  
diff --cc drivers/infiniband/hw/mlx4/doorbell.c
index c51740986367,0f390351cef0..000000000000
--- a/drivers/infiniband/hw/mlx4/doorbell.c
+++ b/drivers/infiniband/hw/mlx4/doorbell.c
@@@ -41,7 -42,7 +42,11 @@@ struct mlx4_ib_user_db_page 
  	int			refcnt;
  };
  
++<<<<<<< HEAD
 +int mlx4_ib_db_map_user(struct mlx4_ib_ucontext *context, unsigned long virt,
++=======
+ int mlx4_ib_db_map_user(struct ib_udata *udata, unsigned long virt,
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  			struct mlx4_db *db)
  {
  	struct mlx4_ib_user_db_page *page;
diff --cc drivers/infiniband/hw/mlx4/main.c
index d66002a31000,952b1bac46db..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -1186,38 -1177,26 +1186,48 @@@ static int mlx4_ib_mmap(struct ib_ucont
  	}
  }
  
++<<<<<<< HEAD
 +static struct ib_pd *mlx4_ib_alloc_pd(struct ib_device *ibdev,
 +				      struct ib_ucontext *context,
 +				      struct ib_udata *udata)
++=======
+ static int mlx4_ib_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct mlx4_ib_pd *pd = to_mpd(ibpd);
 -	struct ib_device *ibdev = ibpd->device;
 +	struct mlx4_ib_pd *pd;
  	int err;
  
 -	err = mlx4_pd_alloc(to_mdev(ibdev)->dev, &pd->pdn);
 -	if (err)
 -		return err;
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	err = mlx4_pd_alloc(to_mdev(ibdev)->dev, &pd->pdn);
 +	if (err) {
 +		kfree(pd);
 +		return ERR_PTR(err);
++=======
+ 	if (udata && ib_copy_to_udata(udata, &pd->pdn, sizeof(__u32))) {
+ 		mlx4_pd_free(to_mdev(ibdev)->dev, pd->pdn);
+ 		return -EFAULT;
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	}
 -	return 0;
 +
 +	if (context)
 +		if (ib_copy_to_udata(udata, &pd->pdn, sizeof (__u32))) {
 +			mlx4_pd_free(to_mdev(ibdev)->dev, pd->pdn);
 +			kfree(pd);
 +			return ERR_PTR(-EFAULT);
 +		}
 +	return &pd->ibpd;
  }
  
 -static void mlx4_ib_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata)
 +static int mlx4_ib_dealloc_pd(struct ib_pd *pd)
  {
  	mlx4_pd_free(to_mdev(pd->device)->dev, to_mpd(pd)->pdn);
 +	kfree(pd);
 +
 +	return 0;
  }
  
  static struct ib_xrcd *mlx4_ib_alloc_xrcd(struct ib_device *ibdev,
diff --cc drivers/infiniband/hw/mlx4/mlx4_ib.h
index e491f3eda6e7,79143848b560..000000000000
--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h
+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h
@@@ -722,7 -723,7 +722,11 @@@ static inline u8 mlx4_ib_bond_next_port
  int mlx4_ib_init_sriov(struct mlx4_ib_dev *dev);
  void mlx4_ib_close_sriov(struct mlx4_ib_dev *dev);
  
++<<<<<<< HEAD
 +int mlx4_ib_db_map_user(struct mlx4_ib_ucontext *context, unsigned long virt,
++=======
+ int mlx4_ib_db_map_user(struct ib_udata *udata, unsigned long virt,
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  			struct mlx4_db *db);
  void mlx4_ib_db_unmap_user(struct mlx4_ib_ucontext *context, struct mlx4_db *db);
  
@@@ -745,9 -745,8 +749,8 @@@ int mlx4_ib_modify_cq(struct ib_cq *cq
  int mlx4_ib_resize_cq(struct ib_cq *ibcq, int entries, struct ib_udata *udata);
  struct ib_cq *mlx4_ib_create_cq(struct ib_device *ibdev,
  				const struct ib_cq_init_attr *attr,
- 				struct ib_ucontext *context,
  				struct ib_udata *udata);
 -int mlx4_ib_destroy_cq(struct ib_cq *cq, struct ib_udata *udata);
 +int mlx4_ib_destroy_cq(struct ib_cq *cq);
  int mlx4_ib_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *wc);
  int mlx4_ib_arm_cq(struct ib_cq *cq, enum ib_cq_notify_flags flags);
  void __mlx4_ib_cq_clean(struct mlx4_ib_cq *cq, u32 qpn, struct mlx4_ib_srq *srq);
diff --cc drivers/infiniband/hw/mlx4/qp.c
index 971e9a9ebdaf,364e16b5f8e1..000000000000
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@@ -1035,9 -1041,11 +1035,17 @@@ static int create_qp_common(struct mlx4
  			goto err_mtt;
  
  		if (qp_has_rq(init_attr)) {
++<<<<<<< HEAD
 +			err = mlx4_ib_db_map_user(to_mucontext(pd->uobject->context),
 +				(src == MLX4_IB_QP_SRC) ? ucmd.qp.db_addr :
 +				ucmd.wq.db_addr, &qp->db);
++=======
+ 			err = mlx4_ib_db_map_user(udata,
+ 						  (src == MLX4_IB_QP_SRC) ?
+ 							  ucmd.qp.db_addr :
+ 							  ucmd.wq.db_addr,
+ 						  &qp->db);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  			if (err)
  				goto err_mtt;
  		}
diff --cc drivers/infiniband/hw/mlx4/srq.c
index 4456f1b8921d,94c3c334a672..000000000000
--- a/drivers/infiniband/hw/mlx4/srq.c
+++ b/drivers/infiniband/hw/mlx4/srq.c
@@@ -129,8 -131,7 +129,12 @@@ struct ib_srq *mlx4_ib_create_srq(struc
  		if (err)
  			goto err_mtt;
  
++<<<<<<< HEAD
 +		err = mlx4_ib_db_map_user(to_mucontext(pd->uobject->context),
 +					  ucmd.db_addr, &srq->db);
++=======
+ 		err = mlx4_ib_db_map_user(udata, ucmd.db_addr, &srq->db);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  		if (err)
  			goto err_mtt;
  	} else {
diff --cc drivers/infiniband/hw/mlx5/cq.c
index 6bfa574fa013,2e2e65f00257..000000000000
--- a/drivers/infiniband/hw/mlx5/cq.c
+++ b/drivers/infiniband/hw/mlx5/cq.c
@@@ -715,8 -716,7 +716,12 @@@ static int create_cq_user(struct mlx5_i
  		return err;
  	}
  
++<<<<<<< HEAD
 +	err = mlx5_ib_db_map_user(to_mucontext(context), ucmd.db_addr,
 +				  &cq->db);
++=======
+ 	err = mlx5_ib_db_map_user(context, udata, ucmd.db_addr, &cq->db);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	if (err)
  		goto err_umem;
  
@@@ -923,9 -925,9 +927,15 @@@ struct ib_cq *mlx5_ib_create_cq(struct 
  	INIT_LIST_HEAD(&cq->list_send_qp);
  	INIT_LIST_HEAD(&cq->list_recv_qp);
  
++<<<<<<< HEAD
 +	if (context) {
 +		err = create_cq_user(dev, udata, context, cq, entries,
 +				     &cqb, &cqe_size, &index, &inlen);
++=======
+ 	if (udata) {
+ 		err = create_cq_user(dev, udata, cq, entries, &cqb, &cqe_size,
+ 				     &index, &inlen);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  		if (err)
  			goto err_create;
  	} else {
diff --cc drivers/infiniband/hw/mlx5/main.c
index 2e9e8914ac78,f706e1bd40ad..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2320,22 -2341,19 +2320,32 @@@ int mlx5_ib_dealloc_dm(struct ib_dm *ib
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct ib_pd *mlx5_ib_alloc_pd(struct ib_device *ibdev,
 +				      struct ib_ucontext *context,
 +				      struct ib_udata *udata)
++=======
+ static int mlx5_ib_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct mlx5_ib_pd *pd = to_mpd(ibpd);
 -	struct ib_device *ibdev = ibpd->device;
  	struct mlx5_ib_alloc_pd_resp resp;
 +	struct mlx5_ib_pd *pd;
  	int err;
  	u32 out[MLX5_ST_SZ_DW(alloc_pd_out)] = {};
  	u32 in[MLX5_ST_SZ_DW(alloc_pd_in)]   = {};
  	u16 uid = 0;
+ 	struct mlx5_ib_ucontext *context = rdma_udata_to_drv_context(
+ 		udata, struct mlx5_ib_ucontext, ibucontext);
  
++<<<<<<< HEAD
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
 +
 +	uid = context ? to_mucontext(context)->devx_uid : 0;
++=======
+ 	uid = context ? context->devx_uid : 0;
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	MLX5_SET(alloc_pd_in, in, opcode, MLX5_CMD_OP_ALLOC_PD);
  	MLX5_SET(alloc_pd_in, in, uid, uid);
  	err = mlx5_cmd_exec(to_mdev(ibdev)->mdev, in, sizeof(in),
@@@ -4716,7 -4750,11 +4726,15 @@@ static int create_dev_resources(struct 
  	devr->p0->uobject = NULL;
  	atomic_set(&devr->p0->usecnt, 0);
  
++<<<<<<< HEAD
 +	devr->c0 = mlx5_ib_create_cq(&dev->ib_dev, &cq_attr, NULL, NULL);
++=======
+ 	ret = mlx5_ib_alloc_pd(devr->p0, NULL);
+ 	if (ret)
+ 		goto error0;
+ 
+ 	devr->c0 = mlx5_ib_create_cq(&dev->ib_dev, &cq_attr, NULL);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	if (IS_ERR(devr->c0)) {
  		ret = PTR_ERR(devr->c0);
  		goto error1;
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 8120f808023d,f7314d78aafd..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -1083,14 -1075,16 +1083,13 @@@ int mlx5_ib_post_send(struct ib_qp *ibq
  		      const struct ib_send_wr **bad_wr);
  int mlx5_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,
  		      const struct ib_recv_wr **bad_wr);
 -int mlx5_ib_read_user_wqe_sq(struct mlx5_ib_qp *qp, int wqe_index, void *buffer,
 -			     int buflen, size_t *bc);
 -int mlx5_ib_read_user_wqe_rq(struct mlx5_ib_qp *qp, int wqe_index, void *buffer,
 -			     int buflen, size_t *bc);
 -int mlx5_ib_read_user_wqe_srq(struct mlx5_ib_srq *srq, int wqe_index,
 -			      void *buffer, int buflen, size_t *bc);
 +int mlx5_ib_read_user_wqe(struct mlx5_ib_qp *qp, int send, int wqe_index,
 +			  void *buffer, u32 length,
 +			  struct mlx5_ib_qp_base *base);
  struct ib_cq *mlx5_ib_create_cq(struct ib_device *ibdev,
  				const struct ib_cq_init_attr *attr,
- 				struct ib_ucontext *context,
  				struct ib_udata *udata);
 -int mlx5_ib_destroy_cq(struct ib_cq *cq, struct ib_udata *udata);
 +int mlx5_ib_destroy_cq(struct ib_cq *cq);
  int mlx5_ib_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *wc);
  int mlx5_ib_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags);
  int mlx5_ib_modify_cq(struct ib_cq *cq, u16 cq_count, u16 cq_period);
@@@ -1128,9 -1122,8 +1127,14 @@@ int mlx5_ib_process_mad(struct ib_devic
  			struct ib_mad_hdr *out, size_t *out_mad_size,
  			u16 *out_mad_pkey_index);
  struct ib_xrcd *mlx5_ib_alloc_xrcd(struct ib_device *ibdev,
++<<<<<<< HEAD
 +					  struct ib_ucontext *context,
 +					  struct ib_udata *udata);
 +int mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd);
++=======
+ 				   struct ib_udata *udata);
+ int mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  int mlx5_ib_get_buf_offset(u64 addr, int page_shift, u32 *offset);
  int mlx5_query_ext_port_caps(struct mlx5_ib_dev *dev, u8 port);
  int mlx5_query_mad_ifc_smp_attr_node_info(struct ib_device *ibdev,
diff --cc drivers/infiniband/hw/mthca/mthca_provider.c
index ae6b236e4756,9a77374a327b..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@@ -374,28 -363,20 +374,38 @@@ static int mthca_mmap_uar(struct ib_uco
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct ib_pd *mthca_alloc_pd(struct ib_device *ibdev,
 +				    struct ib_ucontext *context,
 +				    struct ib_udata *udata)
++=======
+ static int mthca_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = ibpd->device;
 -	struct mthca_pd *pd = to_mpd(ibpd);
 +	struct mthca_pd *pd;
  	int err;
  
++<<<<<<< HEAD
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
 +
 +	err = mthca_pd_alloc(to_mdev(ibdev), !context, pd);
 +	if (err) {
 +		kfree(pd);
 +		return ERR_PTR(err);
 +	}
++=======
+ 	err = mthca_pd_alloc(to_mdev(ibdev), !udata, pd);
+ 	if (err)
+ 		return err;
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
- 	if (context) {
+ 	if (udata) {
  		if (ib_copy_to_udata(udata, &pd->pd_num, sizeof (__u32))) {
  			mthca_pd_free(to_mdev(ibdev), pd);
 -			return -EFAULT;
 +			kfree(pd);
 +			return ERR_PTR(-EFAULT);
  		}
  	}
  
diff --cc drivers/infiniband/hw/nes/nes_verbs.c
index cd4fa4729089,a3b5e8eecb98..000000000000
--- a/drivers/infiniband/hw/nes/nes_verbs.c
+++ b/drivers/infiniband/hw/nes/nes_verbs.c
@@@ -651,10 -640,10 +651,14 @@@ static int nes_mmap(struct ib_ucontext 
  /**
   * nes_alloc_pd
   */
++<<<<<<< HEAD
 +static struct ib_pd *nes_alloc_pd(struct ib_device *ibdev,
 +		struct ib_ucontext *context, struct ib_udata *udata)
++=======
+ static int nes_alloc_pd(struct ib_pd *pd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = pd->device;
 -	struct nes_pd *nespd = to_nespd(pd);
 +	struct nes_pd *nespd;
  	struct nes_vnic *nesvnic = to_nesvnic(ibdev);
  	struct nes_device *nesdev = nesvnic->nesdev;
  	struct nes_adapter *nesadapter = nesdev->nesadapter;
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index 27249892f0d1,cf7aeb963dce..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@@ -367,17 -368,22 +368,33 @@@ static int ocrdma_get_pd_num(struct ocr
  	return status;
  }
  
++<<<<<<< HEAD
 +static struct ocrdma_pd *_ocrdma_alloc_pd(struct ocrdma_dev *dev,
 +					  struct ocrdma_ucontext *uctx,
 +					  struct ib_udata *udata)
++=======
+ /*
+  * NOTE:
+  *
+  * ocrdma_ucontext must be used here because this function is also
+  * called from ocrdma_alloc_ucontext where ib_udata does not have
+  * valid ib_ucontext pointer. ib_uverbs_get_context does not call
+  * uobj_{alloc|get_xxx} helpers which are used to store the
+  * ib_ucontext in uverbs_attr_bundle wrapping the ib_udata. so
+  * ib_udata does NOT imply valid ib_ucontext here!
+  */
+ static int _ocrdma_alloc_pd(struct ocrdma_dev *dev, struct ocrdma_pd *pd,
+ 			    struct ocrdma_ucontext *uctx,
+ 			    struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 +	struct ocrdma_pd *pd = NULL;
  	int status;
  
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
 +
  	if (udata && uctx && dev->attr.max_dpp_pds) {
  		pd->dpp_enabled =
  			ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R;
@@@ -658,18 -650,17 +675,22 @@@ dpp_map_err
  	return status;
  }
  
++<<<<<<< HEAD
 +struct ib_pd *ocrdma_alloc_pd(struct ib_device *ibdev,
 +			      struct ib_ucontext *context,
 +			      struct ib_udata *udata)
++=======
+ int ocrdma_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = ibpd->device;
  	struct ocrdma_dev *dev = get_ocrdma_dev(ibdev);
  	struct ocrdma_pd *pd;
- 	struct ocrdma_ucontext *uctx = NULL;
  	int status;
  	u8 is_uctx_pd = false;
+ 	struct ocrdma_ucontext *uctx = rdma_udata_to_drv_context(
+ 		udata, struct ocrdma_ucontext, ibucontext);
  
- 	if (udata && context) {
- 		uctx = get_ocrdma_ucontext(context);
+ 	if (udata) {
  		pd = ocrdma_get_ucontext_pd(uctx);
  		if (pd) {
  			is_uctx_pd = true;
@@@ -677,15 -668,14 +698,15 @@@
  		}
  	}
  
 -	pd = get_ocrdma_pd(ibpd);
 -	status = _ocrdma_alloc_pd(dev, pd, uctx, udata);
 -	if (status)
 +	pd = _ocrdma_alloc_pd(dev, uctx, udata);
 +	if (IS_ERR(pd)) {
 +		status = PTR_ERR(pd);
  		goto exit;
 +	}
  
  pd_mapping:
- 	if (udata && context) {
- 		status = ocrdma_copy_pd_uresp(dev, pd, context, udata);
+ 	if (udata) {
+ 		status = ocrdma_copy_pd_uresp(dev, pd, udata);
  		if (status)
  			goto err;
  	}
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
index b69cfdce7970,dfdebe4e48e6..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
@@@ -70,16 -69,14 +70,20 @@@ int ocrdma_dealloc_ucontext(struct ib_u
  
  int ocrdma_mmap(struct ib_ucontext *, struct vm_area_struct *vma);
  
++<<<<<<< HEAD
 +struct ib_pd *ocrdma_alloc_pd(struct ib_device *,
 +			      struct ib_ucontext *, struct ib_udata *);
 +int ocrdma_dealloc_pd(struct ib_pd *pd);
++=======
+ int ocrdma_alloc_pd(struct ib_pd *pd, struct ib_udata *udata);
+ void ocrdma_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  struct ib_cq *ocrdma_create_cq(struct ib_device *ibdev,
  			       const struct ib_cq_init_attr *attr,
- 			       struct ib_ucontext *ib_ctx,
  			       struct ib_udata *udata);
  int ocrdma_resize_cq(struct ib_cq *, int cqe, struct ib_udata *);
 -int ocrdma_destroy_cq(struct ib_cq *ibcq, struct ib_udata *udata);
 +int ocrdma_destroy_cq(struct ib_cq *);
  
  struct ib_qp *ocrdma_create_qp(struct ib_pd *,
  			       struct ib_qp_init_attr *attrs,
diff --cc drivers/infiniband/hw/qedr/verbs.c
index 9cb7820beb81,44ab86718c2f..000000000000
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@@ -443,11 -437,11 +444,15 @@@ int qedr_mmap(struct ib_ucontext *conte
  				  vma->vm_page_prot);
  }
  
++<<<<<<< HEAD
 +struct ib_pd *qedr_alloc_pd(struct ib_device *ibdev,
 +			    struct ib_ucontext *context, struct ib_udata *udata)
++=======
+ int qedr_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = ibpd->device;
  	struct qedr_dev *dev = get_qedr_dev(ibdev);
 -	struct qedr_pd *pd = get_qedr_pd(ibpd);
 +	struct qedr_pd *pd;
  	u16 pd_id;
  	int rc;
  
@@@ -478,10 -470,10 +485,10 @@@
  		if (rc) {
  			DP_ERR(dev, "copy error pd_id=0x%x.\n", pd_id);
  			dev->ops->rdma_dealloc_pd(dev->rdma_ctx, pd_id);
 -			return rc;
 +			goto err;
  		}
  
- 		pd->uctx = get_qedr_ucontext(context);
+ 		pd->uctx = context;
  		pd->uctx->pd = pd;
  	}
  
diff --cc drivers/infiniband/hw/qedr/verbs.h
index 0e5fb4e82418,46a9828b9777..000000000000
--- a/drivers/infiniband/hw/qedr/verbs.h
+++ b/drivers/infiniband/hw/qedr/verbs.h
@@@ -43,20 -43,18 +43,24 @@@ int qedr_iw_query_gid(struct ib_device 
  
  int qedr_query_pkey(struct ib_device *, u8 port, u16 index, u16 *pkey);
  
 -int qedr_alloc_ucontext(struct ib_ucontext *uctx, struct ib_udata *udata);
 -void qedr_dealloc_ucontext(struct ib_ucontext *uctx);
 +struct ib_ucontext *qedr_alloc_ucontext(struct ib_device *, struct ib_udata *);
 +int qedr_dealloc_ucontext(struct ib_ucontext *);
  
  int qedr_mmap(struct ib_ucontext *, struct vm_area_struct *vma);
++<<<<<<< HEAD
 +struct ib_pd *qedr_alloc_pd(struct ib_device *,
 +			    struct ib_ucontext *, struct ib_udata *);
 +int qedr_dealloc_pd(struct ib_pd *pd);
++=======
+ int qedr_alloc_pd(struct ib_pd *pd, struct ib_udata *udata);
+ void qedr_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  struct ib_cq *qedr_create_cq(struct ib_device *ibdev,
  			     const struct ib_cq_init_attr *attr,
- 			     struct ib_ucontext *ib_ctx,
  			     struct ib_udata *udata);
  int qedr_resize_cq(struct ib_cq *, int cqe, struct ib_udata *);
 -int qedr_destroy_cq(struct ib_cq *ibcq, struct ib_udata *udata);
 +int qedr_destroy_cq(struct ib_cq *);
  int qedr_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags);
  struct ib_qp *qedr_create_qp(struct ib_pd *, struct ib_qp_init_attr *attrs,
  			     struct ib_udata *);
diff --cc drivers/infiniband/hw/usnic/usnic_ib_verbs.c
index 432e6f6599fa,e9352750e029..000000000000
--- a/drivers/infiniband/hw/usnic/usnic_ib_verbs.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_verbs.c
@@@ -456,37 -447,22 +456,41 @@@ int usnic_ib_query_pkey(struct ib_devic
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct ib_pd *usnic_ib_alloc_pd(struct ib_device *ibdev,
 +					struct ib_ucontext *context,
 +					struct ib_udata *udata)
++=======
+ int usnic_ib_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct usnic_ib_pd *pd = to_upd(ibpd);
 +	struct usnic_ib_pd *pd;
  	void *umem_pd;
  
 +	usnic_dbg("\n");
 +
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd)
 +		return ERR_PTR(-ENOMEM);
 +
  	umem_pd = pd->umem_pd = usnic_uiom_alloc_pd();
  	if (IS_ERR_OR_NULL(umem_pd)) {
 -		return umem_pd ? PTR_ERR(umem_pd) : -ENOMEM;
 +		kfree(pd);
 +		return ERR_PTR(umem_pd ? PTR_ERR(umem_pd) : -ENOMEM);
  	}
  
 -	return 0;
 +	usnic_info("domain 0x%p allocated for context 0x%p and device %s\n",
 +		   pd, context, dev_name(&ibdev->dev));
 +	return &pd->ibpd;
  }
  
 -void usnic_ib_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata)
 +int usnic_ib_dealloc_pd(struct ib_pd *pd)
  {
 +	usnic_info("freeing domain 0x%p\n", pd);
 +
  	usnic_uiom_dealloc_pd((to_upd(pd))->umem_pd);
 +	kfree(pd);
 +	return 0;
  }
  
  struct ib_qp *usnic_ib_create_qp(struct ib_pd *pd,
diff --cc drivers/infiniband/hw/usnic/usnic_ib_verbs.h
index e33144261b9a,028f322f8e9b..000000000000
--- a/drivers/infiniband/hw/usnic/usnic_ib_verbs.h
+++ b/drivers/infiniband/hw/usnic/usnic_ib_verbs.h
@@@ -48,13 -48,10 +48,18 @@@ int usnic_ib_query_qp(struct ib_qp *qp
  				struct ib_qp_init_attr *qp_init_attr);
  int usnic_ib_query_gid(struct ib_device *ibdev, u8 port, int index,
  				union ib_gid *gid);
 +struct net_device *usnic_get_netdev(struct ib_device *device, u8 port_num);
  int usnic_ib_query_pkey(struct ib_device *ibdev, u8 port, u16 index,
  				u16 *pkey);
++<<<<<<< HEAD
 +struct ib_pd *usnic_ib_alloc_pd(struct ib_device *ibdev,
 +				struct ib_ucontext *context,
 +				struct ib_udata *udata);
 +int usnic_ib_dealloc_pd(struct ib_pd *pd);
++=======
+ int usnic_ib_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata);
+ void usnic_ib_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  struct ib_qp *usnic_ib_create_qp(struct ib_pd *pd,
  					struct ib_qp_init_attr *init_attr,
  					struct ib_udata *udata);
@@@ -63,9 -60,8 +68,8 @@@ int usnic_ib_modify_qp(struct ib_qp *ib
  				int attr_mask, struct ib_udata *udata);
  struct ib_cq *usnic_ib_create_cq(struct ib_device *ibdev,
  				 const struct ib_cq_init_attr *attr,
- 				 struct ib_ucontext *context,
  				 struct ib_udata *udata);
 -int usnic_ib_destroy_cq(struct ib_cq *cq, struct ib_udata *udata);
 +int usnic_ib_destroy_cq(struct ib_cq *cq);
  struct ib_mr *usnic_ib_reg_mr(struct ib_pd *pd, u64 start, u64 length,
  				u64 virt_addr, int access_flags,
  				struct ib_udata *udata);
diff --cc drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
index e426f95731eb,0302fa3b6c85..000000000000
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
@@@ -436,49 -419,40 +437,62 @@@ int pvrdma_mmap(struct ib_ucontext *ibc
  
  /**
   * pvrdma_alloc_pd - allocate protection domain
++<<<<<<< HEAD
 + * @ibdev: the IB device
 + * @context: user context
++=======
+  * @ibpd: PD pointer
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
   * @udata: user data
   *
   * @return: the ib_pd protection domain pointer on success, otherwise errno.
   */
++<<<<<<< HEAD
 +struct ib_pd *pvrdma_alloc_pd(struct ib_device *ibdev,
 +			      struct ib_ucontext *context,
 +			      struct ib_udata *udata)
++=======
+ int pvrdma_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = ibpd->device;
 -	struct pvrdma_pd *pd = to_vpd(ibpd);
 +	struct pvrdma_pd *pd;
  	struct pvrdma_dev *dev = to_vdev(ibdev);
 -	union pvrdma_cmd_req req = {};
 -	union pvrdma_cmd_resp rsp = {};
 +	union pvrdma_cmd_req req;
 +	union pvrdma_cmd_resp rsp;
  	struct pvrdma_cmd_create_pd *cmd = &req.create_pd;
  	struct pvrdma_cmd_create_pd_resp *resp = &rsp.create_pd_resp;
  	struct pvrdma_alloc_pd_resp pd_resp = {0};
  	int ret;
++<<<<<<< HEAD
 +	void *ptr;
++=======
+ 	struct pvrdma_ucontext *context = rdma_udata_to_drv_context(
+ 		udata, struct pvrdma_ucontext, ibucontext);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  	/* Check allowed max pds */
  	if (!atomic_add_unless(&dev->num_pds, 1, dev->dsr->caps.max_pd))
 -		return -ENOMEM;
 +		return ERR_PTR(-ENOMEM);
 +
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd) {
 +		ptr = ERR_PTR(-ENOMEM);
 +		goto err;
 +	}
  
 +	memset(cmd, 0, sizeof(*cmd));
  	cmd->hdr.cmd = PVRDMA_CMD_CREATE_PD;
- 	cmd->ctx_handle = (context) ? to_vucontext(context)->ctx_handle : 0;
+ 	cmd->ctx_handle = context ? context->ctx_handle : 0;
  	ret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_PD_RESP);
  	if (ret < 0) {
  		dev_warn(&dev->pdev->dev,
  			 "failed to allocate protection domain, error: %d\n",
  			 ret);
 -		goto err;
 +		ptr = ERR_PTR(ret);
 +		goto freepd;
  	}
  
- 	pd->privileged = !context;
+ 	pd->privileged = !udata;
  	pd->pd_handle = resp->pd_handle;
  	pd->pdn = resp->pd_handle;
  	pd_resp.pdn = resp->pd_handle;
diff --cc drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
index f7f758d60110,562b70e70e79..000000000000
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
@@@ -396,13 -396,10 +396,20 @@@ int pvrdma_modify_device(struct ib_devi
  int pvrdma_modify_port(struct ib_device *ibdev, u8 port,
  		       int mask, struct ib_port_modify *props);
  int pvrdma_mmap(struct ib_ucontext *context, struct vm_area_struct *vma);
++<<<<<<< HEAD
 +struct ib_ucontext *pvrdma_alloc_ucontext(struct ib_device *ibdev,
 +					  struct ib_udata *udata);
 +int pvrdma_dealloc_ucontext(struct ib_ucontext *context);
 +struct ib_pd *pvrdma_alloc_pd(struct ib_device *ibdev,
 +			      struct ib_ucontext *context,
 +			      struct ib_udata *udata);
 +int pvrdma_dealloc_pd(struct ib_pd *ibpd);
++=======
+ int pvrdma_alloc_ucontext(struct ib_ucontext *uctx, struct ib_udata *udata);
+ void pvrdma_dealloc_ucontext(struct ib_ucontext *context);
+ int pvrdma_alloc_pd(struct ib_pd *pd, struct ib_udata *udata);
+ void pvrdma_dealloc_pd(struct ib_pd *ibpd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  struct ib_mr *pvrdma_get_dma_mr(struct ib_pd *pd, int acc);
  struct ib_mr *pvrdma_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,
  				 u64 virt_addr, int access_flags,
@@@ -414,9 -411,8 +421,8 @@@ int pvrdma_map_mr_sg(struct ib_mr *ibmr
  		     int sg_nents, unsigned int *sg_offset);
  struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
  			       const struct ib_cq_init_attr *attr,
- 			       struct ib_ucontext *context,
  			       struct ib_udata *udata);
 -int pvrdma_destroy_cq(struct ib_cq *cq, struct ib_udata *udata);
 +int pvrdma_destroy_cq(struct ib_cq *cq);
  int pvrdma_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *wc);
  int pvrdma_req_notify_cq(struct ib_cq *cq, enum ib_cq_notify_flags flags);
  struct ib_ah *pvrdma_create_ah(struct ib_pd *pd, struct rdma_ah_attr *ah_attr,
diff --cc drivers/infiniband/sw/rdmavt/pd.c
index dcc1870b8d23,a403718f0b5e..000000000000
--- a/drivers/infiniband/sw/rdmavt/pd.c
+++ b/drivers/infiniband/sw/rdmavt/pd.c
@@@ -50,27 -50,20 +50,35 @@@
  
  /**
   * rvt_alloc_pd - allocate a protection domain
++<<<<<<< HEAD
 + * @ibdev: ib device
 + * @context: optional user context
++=======
+  * @ibpd: PD
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
   * @udata: optional user data
   *
   * Allocate and keep track of a PD.
   *
   * Return: 0 on success
   */
++<<<<<<< HEAD
 +struct ib_pd *rvt_alloc_pd(struct ib_device *ibdev,
 +			   struct ib_ucontext *context,
 +			   struct ib_udata *udata)
++=======
+ int rvt_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct ib_device *ibdev = ibpd->device;
  	struct rvt_dev_info *dev = ib_to_rvt(ibdev);
 -	struct rvt_pd *pd = ibpd_to_rvtpd(ibpd);
 -	int ret = 0;
 +	struct rvt_pd *pd;
 +	struct ib_pd *ret;
  
 +	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
 +	if (!pd) {
 +		ret = ERR_PTR(-ENOMEM);
 +		goto bail;
 +	}
  	/*
  	 * While we could continue allocating protecetion domains, being
  	 * constrained only by system resources. The IBTA spec defines that
diff --cc drivers/infiniband/sw/rdmavt/pd.h
index 1892ca4a9746,71ba76d72b1d..000000000000
--- a/drivers/infiniband/sw/rdmavt/pd.h
+++ b/drivers/infiniband/sw/rdmavt/pd.h
@@@ -50,9 -50,7 +50,14 @@@
  
  #include <rdma/rdma_vt.h>
  
++<<<<<<< HEAD
 +struct ib_pd *rvt_alloc_pd(struct ib_device *ibdev,
 +			   struct ib_ucontext *context,
 +			   struct ib_udata *udata);
 +int rvt_dealloc_pd(struct ib_pd *ibpd);
++=======
+ int rvt_alloc_pd(struct ib_pd *pd, struct ib_udata *udata);
+ void rvt_dealloc_pd(struct ib_pd *ibpd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  #endif          /* DEF_RDMAVTPD_H */
diff --cc drivers/infiniband/sw/rdmavt/qp.c
index 9fb585ace82f,90ed99f4b026..000000000000
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@@ -1128,8 -1129,7 +1128,12 @@@ struct ib_qp *rvt_create_qp(struct ib_p
  		} else {
  			u32 s = sizeof(struct rvt_rwq) + qp->r_rq.size * sz;
  
++<<<<<<< HEAD
 +			qp->ip = rvt_create_mmap_info(rdi, s,
 +						      ibpd->uobject->context,
++=======
+ 			qp->ip = rvt_create_mmap_info(rdi, s, udata,
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  						      qp->r_rq.wq);
  			if (!qp->ip) {
  				ret = ERR_PTR(-ENOMEM);
diff --cc drivers/infiniband/sw/rdmavt/srq.c
index 78e06fc456c5,21d276eaf15a..000000000000
--- a/drivers/infiniband/sw/rdmavt/srq.c
+++ b/drivers/infiniband/sw/rdmavt/srq.c
@@@ -118,9 -119,7 +118,13 @@@ struct ib_srq *rvt_create_srq(struct ib
  		int err;
  		u32 s = sizeof(struct rvt_rwq) + srq->rq.size * sz;
  
++<<<<<<< HEAD
 +		srq->ip =
 +		    rvt_create_mmap_info(dev, s, ibpd->uobject->context,
 +					 srq->rq.wq);
++=======
+ 		srq->ip = rvt_create_mmap_info(dev, s, udata, srq->rq.wq);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  		if (!srq->ip) {
  			ret = ERR_PTR(-ENOMEM);
  			goto bail_wq;
diff --cc drivers/infiniband/sw/rxe/rxe_qp.c
index be5d76b2bcca,e2c6d1cedf41..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_qp.c
+++ b/drivers/infiniband/sw/rxe/rxe_qp.c
@@@ -343,7 -343,6 +342,10 @@@ int rxe_qp_from_init(struct rxe_dev *rx
  	struct rxe_cq *rcq = to_rcq(init->recv_cq);
  	struct rxe_cq *scq = to_rcq(init->send_cq);
  	struct rxe_srq *srq = init->srq ? to_rsrq(init->srq) : NULL;
++<<<<<<< HEAD
 +	struct ib_ucontext *context = udata ? ibpd->uobject->context : NULL;
++=======
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  
  	rxe_add_ref(pd);
  	rxe_add_ref(rcq);
@@@ -358,11 -357,11 +360,19 @@@
  
  	rxe_qp_init_misc(rxe, qp, init);
  
++<<<<<<< HEAD
 +	err = rxe_qp_init_req(rxe, qp, init, context, uresp);
 +	if (err)
 +		goto err1;
 +
 +	err = rxe_qp_init_resp(rxe, qp, init, context, uresp);
++=======
+ 	err = rxe_qp_init_req(rxe, qp, init, udata, uresp);
+ 	if (err)
+ 		goto err1;
+ 
+ 	err = rxe_qp_init_resp(rxe, qp, init, udata, uresp);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	if (err)
  		goto err2;
  
diff --cc drivers/infiniband/sw/rxe/rxe_verbs.c
index f3188f269481,4f581af2ad54..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_verbs.c
+++ b/drivers/infiniband/sw/rxe/rxe_verbs.c
@@@ -178,18 -176,15 +178,22 @@@ static int rxe_port_immutable(struct ib
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct ib_pd *rxe_alloc_pd(struct ib_device *dev,
 +				  struct ib_ucontext *context,
 +				  struct ib_udata *udata)
++=======
+ static int rxe_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  {
 -	struct rxe_dev *rxe = to_rdev(ibpd->device);
 -	struct rxe_pd *pd = to_rpd(ibpd);
 +	struct rxe_dev *rxe = to_rdev(dev);
 +	struct rxe_pd *pd;
  
 -	return rxe_add_to_pool(&rxe->pd_pool, &pd->pelem);
 +	pd = rxe_alloc(&rxe->pd_pool);
 +	return pd ? &pd->ibpd : ERR_PTR(-ENOMEM);
  }
  
 -static void rxe_dealloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)
 +static int rxe_dealloc_pd(struct ib_pd *ibpd)
  {
  	struct rxe_pd *pd = to_rpd(ibpd);
  
@@@ -334,7 -327,7 +338,11 @@@ static struct ib_srq *rxe_create_srq(st
  	rxe_add_ref(pd);
  	srq->pd = pd;
  
++<<<<<<< HEAD
 +	err = rxe_srq_from_init(rxe, srq, init, context, uresp);
++=======
+ 	err = rxe_srq_from_init(rxe, srq, init, udata, uresp);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	if (err)
  		goto err2;
  
diff --cc include/rdma/ib_verbs.h
index 2ff74f11eec0,0e24f6b6c61d..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2380,15 -2389,13 +2380,20 @@@ struct ib_device_ops 
  	int (*del_gid)(const struct ib_gid_attr *attr, void **context);
  	int (*query_pkey)(struct ib_device *device, u8 port_num, u16 index,
  			  u16 *pkey);
 -	int (*alloc_ucontext)(struct ib_ucontext *context,
 -			      struct ib_udata *udata);
 -	void (*dealloc_ucontext)(struct ib_ucontext *context);
 +	struct ib_ucontext *(*alloc_ucontext)(struct ib_device *device,
 +					      struct ib_udata *udata);
 +	int (*dealloc_ucontext)(struct ib_ucontext *context);
  	int (*mmap)(struct ib_ucontext *context, struct vm_area_struct *vma);
  	void (*disassociate_ucontext)(struct ib_ucontext *ibcontext);
++<<<<<<< HEAD
 +	struct ib_pd *(*alloc_pd)(struct ib_device *device,
 +				  struct ib_ucontext *context,
 +				  struct ib_udata *udata);
 +	int (*dealloc_pd)(struct ib_pd *pd);
++=======
+ 	int (*alloc_pd)(struct ib_pd *pd, struct ib_udata *udata);
+ 	void (*dealloc_pd)(struct ib_pd *pd, struct ib_udata *udata);
++>>>>>>> ff23dfa13457 (IB: Pass only ib_udata in function prototypes)
  	struct ib_ah *(*create_ah)(struct ib_pd *pd,
  				   struct rdma_ah_attr *ah_attr, u32 flags,
  				   struct ib_udata *udata);
@@@ -2410,13 -2417,12 +2415,12 @@@
  			 int qp_attr_mask, struct ib_udata *udata);
  	int (*query_qp)(struct ib_qp *qp, struct ib_qp_attr *qp_attr,
  			int qp_attr_mask, struct ib_qp_init_attr *qp_init_attr);
 -	int (*destroy_qp)(struct ib_qp *qp, struct ib_udata *udata);
 +	int (*destroy_qp)(struct ib_qp *qp);
  	struct ib_cq *(*create_cq)(struct ib_device *device,
  				   const struct ib_cq_init_attr *attr,
- 				   struct ib_ucontext *context,
  				   struct ib_udata *udata);
  	int (*modify_cq)(struct ib_cq *cq, u16 cq_count, u16 cq_period);
 -	int (*destroy_cq)(struct ib_cq *cq, struct ib_udata *udata);
 +	int (*destroy_cq)(struct ib_cq *cq);
  	int (*resize_cq)(struct ib_cq *cq, int cqe, struct ib_udata *udata);
  	struct ib_mr *(*get_dma_mr)(struct ib_pd *pd, int mr_access_flags);
  	struct ib_mr *(*reg_user_mr)(struct ib_pd *pd, u64 start, u64 length,
@@@ -2448,9 -2454,8 +2452,8 @@@
  	int (*attach_mcast)(struct ib_qp *qp, union ib_gid *gid, u16 lid);
  	int (*detach_mcast)(struct ib_qp *qp, union ib_gid *gid, u16 lid);
  	struct ib_xrcd *(*alloc_xrcd)(struct ib_device *device,
- 				      struct ib_ucontext *ucontext,
  				      struct ib_udata *udata);
 -	int (*dealloc_xrcd)(struct ib_xrcd *xrcd, struct ib_udata *udata);
 +	int (*dealloc_xrcd)(struct ib_xrcd *xrcd);
  	struct ib_flow *(*create_flow)(struct ib_qp *qp,
  				       struct ib_flow_attr *flow_attr,
  				       int domain, struct ib_udata *udata);
diff --git a/drivers/infiniband/core/cq.c b/drivers/infiniband/core/cq.c
index d61e5e1427c2..281b0c3e1a18 100644
--- a/drivers/infiniband/core/cq.c
+++ b/drivers/infiniband/core/cq.c
@@ -145,7 +145,7 @@ struct ib_cq *__ib_alloc_cq(struct ib_device *dev, void *private,
 	struct ib_cq *cq;
 	int ret = -ENOMEM;
 
-	cq = dev->ops.create_cq(dev, &cq_attr, NULL, NULL);
+	cq = dev->ops.create_cq(dev, &cq_attr, NULL);
 	if (IS_ERR(cq))
 		return cq;
 
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
diff --git a/drivers/infiniband/core/uverbs_std_types_cq.c b/drivers/infiniband/core/uverbs_std_types_cq.c
index a59ea89e3f2b..ccf4a48dcc65 100644
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@ -110,8 +110,7 @@ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(
 	INIT_LIST_HEAD(&obj->comp_list);
 	INIT_LIST_HEAD(&obj->async_list);
 
-	cq = ib_dev->ops.create_cq(ib_dev, &attr, obj->uobject.context,
-				   &attrs->driver_udata);
+	cq = ib_dev->ops.create_cq(ib_dev, &attr, &attrs->driver_udata);
 	if (IS_ERR(cq)) {
 		ret = PTR_ERR(cq);
 		goto err_event_file;
* Unmerged path drivers/infiniband/core/verbs.c
* Unmerged path drivers/infiniband/hw/bnxt_re/ib_verbs.c
* Unmerged path drivers/infiniband/hw/bnxt_re/ib_verbs.h
* Unmerged path drivers/infiniband/hw/cxgb3/iwch_provider.c
diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c
index 1fa5f6445be3..c98fe32b99de 100644
--- a/drivers/infiniband/hw/cxgb4/cq.c
+++ b/drivers/infiniband/hw/cxgb4/cq.c
@@ -992,7 +992,6 @@ int c4iw_destroy_cq(struct ib_cq *ib_cq)
 
 struct ib_cq *c4iw_create_cq(struct ib_device *ibdev,
 			     const struct ib_cq_init_attr *attr,
-			     struct ib_ucontext *ib_context,
 			     struct ib_udata *udata)
 {
 	int entries = attr->cqe;
@@ -1001,10 +1000,11 @@ struct ib_cq *c4iw_create_cq(struct ib_device *ibdev,
 	struct c4iw_cq *chp;
 	struct c4iw_create_cq ucmd;
 	struct c4iw_create_cq_resp uresp;
-	struct c4iw_ucontext *ucontext = NULL;
 	int ret, wr_len;
 	size_t memsize, hwentries;
 	struct c4iw_mm_entry *mm, *mm2;
+	struct c4iw_ucontext *ucontext = rdma_udata_to_drv_context(
+		udata, struct c4iw_ucontext, ibucontext);
 
 	pr_debug("ib_dev %p entries %d\n", ibdev, entries);
 	if (attr->flags)
@@ -1015,8 +1015,7 @@ struct ib_cq *c4iw_create_cq(struct ib_device *ibdev,
 	if (vector >= rhp->rdev.lldi.nciq)
 		return ERR_PTR(-EINVAL);
 
-	if (ib_context) {
-		ucontext = to_c4iw_ucontext(ib_context);
+	if (udata) {
 		if (udata->inlen < sizeof(ucmd))
 			ucontext->is_32b_cqe = 1;
 	}
@@ -1068,7 +1067,7 @@ struct ib_cq *c4iw_create_cq(struct ib_device *ibdev,
 	/*
 	 * memsize must be a multiple of the page size if its a user cq.
 	 */
-	if (ucontext)
+	if (udata)
 		memsize = roundup(memsize, PAGE_SIZE);
 
 	chp->cq.size = hwentries;
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 7dffb68092fc..d603974a53a1 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -1051,7 +1051,6 @@ int c4iw_dereg_mr(struct ib_mr *ib_mr);
 int c4iw_destroy_cq(struct ib_cq *ib_cq);
 struct ib_cq *c4iw_create_cq(struct ib_device *ibdev,
 			     const struct ib_cq_init_attr *attr,
-			     struct ib_ucontext *ib_context,
 			     struct ib_udata *udata);
 int c4iw_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags);
 int c4iw_modify_srq(struct ib_srq *ib_srq, struct ib_srq_attr *attr,
* Unmerged path drivers/infiniband/hw/cxgb4/provider.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_cq.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_device.h
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v1.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_pd.c
* Unmerged path drivers/infiniband/hw/i40iw/i40iw_verbs.c
* Unmerged path drivers/infiniband/hw/mlx4/cq.c
* Unmerged path drivers/infiniband/hw/mlx4/doorbell.c
* Unmerged path drivers/infiniband/hw/mlx4/main.c
* Unmerged path drivers/infiniband/hw/mlx4/mlx4_ib.h
* Unmerged path drivers/infiniband/hw/mlx4/qp.c
* Unmerged path drivers/infiniband/hw/mlx4/srq.c
* Unmerged path drivers/infiniband/hw/mlx5/cq.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c
index 7927d666efe8..ee1a41619b80 100644
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@ -5527,8 +5527,7 @@ int mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,
 }
 
 struct ib_xrcd *mlx5_ib_alloc_xrcd(struct ib_device *ibdev,
-					  struct ib_ucontext *context,
-					  struct ib_udata *udata)
+				   struct ib_udata *udata)
 {
 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
 	struct mlx5_ib_xrcd *xrcd;
* Unmerged path drivers/infiniband/hw/mthca/mthca_provider.c
* Unmerged path drivers/infiniband/hw/nes/nes_verbs.c
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_verbs.h
* Unmerged path drivers/infiniband/hw/qedr/verbs.c
* Unmerged path drivers/infiniband/hw/qedr/verbs.h
* Unmerged path drivers/infiniband/hw/usnic/usnic_ib_verbs.c
* Unmerged path drivers/infiniband/hw/usnic/usnic_ib_verbs.h
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c
index 0f004c737620..3d926e0137b8 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c
@@ -49,6 +49,7 @@
 #include <rdma/ib_addr.h>
 #include <rdma/ib_smi.h>
 #include <rdma/ib_user_verbs.h>
+#include <rdma/uverbs_ioctl.h>
 
 #include "pvrdma.h"
 
@@ -93,7 +94,6 @@ int pvrdma_req_notify_cq(struct ib_cq *ibcq,
  * pvrdma_create_cq - create completion queue
  * @ibdev: the device
  * @attr: completion queue attributes
- * @context: user context
  * @udata: user data
  *
  * @return: ib_cq completion queue pointer on success,
@@ -101,7 +101,6 @@ int pvrdma_req_notify_cq(struct ib_cq *ibcq,
  */
 struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
 			       const struct ib_cq_init_attr *attr,
-			       struct ib_ucontext *context,
 			       struct ib_udata *udata)
 {
 	int entries = attr->cqe;
@@ -116,6 +115,8 @@ struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
 	struct pvrdma_cmd_create_cq_resp *resp = &rsp.create_cq_resp;
 	struct pvrdma_create_cq_resp cq_resp = {0};
 	struct pvrdma_create_cq ucmd;
+	struct pvrdma_ucontext *context = rdma_udata_to_drv_context(
+		udata, struct pvrdma_ucontext, ibucontext);
 
 	BUILD_BUG_ON(sizeof(struct pvrdma_cqe) != 64);
 
@@ -133,7 +134,7 @@ struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
 	}
 
 	cq->ibcq.cqe = entries;
-	cq->is_kernel = !context;
+	cq->is_kernel = !udata;
 
 	if (!cq->is_kernel) {
 		if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {
@@ -185,8 +186,7 @@ struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
 	memset(cmd, 0, sizeof(*cmd));
 	cmd->hdr.cmd = PVRDMA_CMD_CREATE_CQ;
 	cmd->nchunks = npages;
-	cmd->ctx_handle = (context) ?
-		(u64)to_vucontext(context)->ctx_handle : 0;
+	cmd->ctx_handle = context ? context->ctx_handle : 0;
 	cmd->cqe = entries;
 	cmd->pdir_dma = cq->pdir.dir_dma;
 	ret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_CQ_RESP);
@@ -204,7 +204,7 @@ struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
 	spin_unlock_irqrestore(&dev->cq_tbl_lock, flags);
 
 	if (!cq->is_kernel) {
-		cq->uar = &(to_vucontext(context)->uar);
+		cq->uar = &context->uar;
 
 		/* Copy udata back. */
 		if (ib_copy_to_udata(udata, &cq_resp, sizeof(cq_resp))) {
* Unmerged path drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
* Unmerged path drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.h
diff --git a/drivers/infiniband/sw/rdmavt/cq.c b/drivers/infiniband/sw/rdmavt/cq.c
index 4f1544ad4aff..22b1cca57f19 100644
--- a/drivers/infiniband/sw/rdmavt/cq.c
+++ b/drivers/infiniband/sw/rdmavt/cq.c
@@ -168,7 +168,6 @@ static void send_complete(struct work_struct *work)
  * rvt_create_cq - create a completion queue
  * @ibdev: the device this completion queue is attached to
  * @attr: creation attributes
- * @context: unused by the QLogic_IB driver
  * @udata: user data for libibverbs.so
  *
  * Called by ib_create_cq() in the generic verbs code.
@@ -178,7 +177,6 @@ static void send_complete(struct work_struct *work)
  */
 struct ib_cq *rvt_create_cq(struct ib_device *ibdev,
 			    const struct ib_cq_init_attr *attr,
-			    struct ib_ucontext *context,
 			    struct ib_udata *udata)
 {
 	struct rvt_dev_info *rdi = ib_to_rvt(ibdev);
@@ -232,7 +230,7 @@ struct ib_cq *rvt_create_cq(struct ib_device *ibdev,
 	if (udata && udata->outlen >= sizeof(__u64)) {
 		int err;
 
-		cq->ip = rvt_create_mmap_info(rdi, sz, context, wc);
+		cq->ip = rvt_create_mmap_info(rdi, sz, udata, wc);
 		if (!cq->ip) {
 			ret = ERR_PTR(-ENOMEM);
 			goto bail_wc;
diff --git a/drivers/infiniband/sw/rdmavt/cq.h b/drivers/infiniband/sw/rdmavt/cq.h
index 72184b1c176b..c0cc32ce20fc 100644
--- a/drivers/infiniband/sw/rdmavt/cq.h
+++ b/drivers/infiniband/sw/rdmavt/cq.h
@@ -53,7 +53,6 @@
 
 struct ib_cq *rvt_create_cq(struct ib_device *ibdev,
 			    const struct ib_cq_init_attr *attr,
-			    struct ib_ucontext *context,
 			    struct ib_udata *udata);
 int rvt_destroy_cq(struct ib_cq *ibcq);
 int rvt_req_notify_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags notify_flags);
diff --git a/drivers/infiniband/sw/rdmavt/mmap.c b/drivers/infiniband/sw/rdmavt/mmap.c
index 6b712eecbd37..652f4a7efc1b 100644
--- a/drivers/infiniband/sw/rdmavt/mmap.c
+++ b/drivers/infiniband/sw/rdmavt/mmap.c
@@ -49,6 +49,7 @@
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
 #include <asm/pgtable.h>
+#include <rdma/uverbs_ioctl.h>
 #include "mmap.h"
 
 /**
@@ -150,18 +151,19 @@ int rvt_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)
  * rvt_create_mmap_info - allocate information for hfi1_mmap
  * @rdi: rvt dev struct
  * @size: size in bytes to map
- * @context: user context
+ * @udata: user data (must be valid!)
  * @obj: opaque pointer to a cq, wq etc
  *
  * Return: rvt_mmap struct on success
  */
-struct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi,
-					   u32 size,
-					   struct ib_ucontext *context,
-					   void *obj)
+struct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi, u32 size,
+					   struct ib_udata *udata, void *obj)
 {
 	struct rvt_mmap_info *ip;
 
+	if (!udata)
+		return ERR_PTR(-EINVAL);
+
 	ip = kmalloc_node(sizeof(*ip), GFP_KERNEL, rdi->dparms.node);
 	if (!ip)
 		return ip;
@@ -177,7 +179,9 @@ struct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi,
 
 	INIT_LIST_HEAD(&ip->pending_mmaps);
 	ip->size = size;
-	ip->context = context;
+	ip->context =
+		container_of(udata, struct uverbs_attr_bundle, driver_udata)
+			->context;
 	ip->obj = obj;
 	kref_init(&ip->ref);
 
diff --git a/drivers/infiniband/sw/rdmavt/mmap.h b/drivers/infiniband/sw/rdmavt/mmap.h
index fab0e7b1daf9..02466c40bc1e 100644
--- a/drivers/infiniband/sw/rdmavt/mmap.h
+++ b/drivers/infiniband/sw/rdmavt/mmap.h
@@ -53,10 +53,8 @@
 void rvt_mmap_init(struct rvt_dev_info *rdi);
 void rvt_release_mmap_info(struct kref *ref);
 int rvt_mmap(struct ib_ucontext *context, struct vm_area_struct *vma);
-struct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi,
-					   u32 size,
-					   struct ib_ucontext *context,
-					   void *obj);
+struct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi, u32 size,
+					   struct ib_udata *udata, void *obj);
 void rvt_update_mmap_info(struct rvt_dev_info *rdi, struct rvt_mmap_info *ip,
 			  u32 size, void *obj);
 
* Unmerged path drivers/infiniband/sw/rdmavt/pd.c
* Unmerged path drivers/infiniband/sw/rdmavt/pd.h
* Unmerged path drivers/infiniband/sw/rdmavt/qp.c
* Unmerged path drivers/infiniband/sw/rdmavt/srq.c
diff --git a/drivers/infiniband/sw/rxe/rxe_cq.c b/drivers/infiniband/sw/rxe/rxe_cq.c
index a57276f2cb84..ad3090131126 100644
--- a/drivers/infiniband/sw/rxe/rxe_cq.c
+++ b/drivers/infiniband/sw/rxe/rxe_cq.c
@@ -82,7 +82,7 @@ static void rxe_send_complete(unsigned long data)
 }
 
 int rxe_cq_from_init(struct rxe_dev *rxe, struct rxe_cq *cq, int cqe,
-		     int comp_vector, struct ib_ucontext *context,
+		     int comp_vector, struct ib_udata *udata,
 		     struct rxe_create_cq_resp __user *uresp)
 {
 	int err;
@@ -94,7 +94,7 @@ int rxe_cq_from_init(struct rxe_dev *rxe, struct rxe_cq *cq, int cqe,
 		return -ENOMEM;
 	}
 
-	err = do_mmap_info(rxe, uresp ? &uresp->mi : NULL, context,
+	err = do_mmap_info(rxe, uresp ? &uresp->mi : NULL, udata,
 			   cq->queue->buf, cq->queue->buf_size, &cq->queue->ip);
 	if (err) {
 		vfree(cq->queue->buf);
@@ -115,13 +115,13 @@ int rxe_cq_from_init(struct rxe_dev *rxe, struct rxe_cq *cq, int cqe,
 }
 
 int rxe_cq_resize_queue(struct rxe_cq *cq, int cqe,
-			struct rxe_resize_cq_resp __user *uresp)
+			struct rxe_resize_cq_resp __user *uresp,
+			struct ib_udata *udata)
 {
 	int err;
 
 	err = rxe_queue_resize(cq->queue, (unsigned int *)&cqe,
-			       sizeof(struct rxe_cqe),
-			       cq->queue->ip ? cq->queue->ip->context : NULL,
+			       sizeof(struct rxe_cqe), udata,
 			       uresp ? &uresp->mi : NULL, NULL, &cq->cq_lock);
 	if (!err)
 		cq->ibcq.cqe = cqe;
diff --git a/drivers/infiniband/sw/rxe/rxe_loc.h b/drivers/infiniband/sw/rxe/rxe_loc.h
index b517a6c86922..21b12c8ff02a 100644
--- a/drivers/infiniband/sw/rxe/rxe_loc.h
+++ b/drivers/infiniband/sw/rxe/rxe_loc.h
@@ -53,11 +53,12 @@ int rxe_cq_chk_attr(struct rxe_dev *rxe, struct rxe_cq *cq,
 		    int cqe, int comp_vector);
 
 int rxe_cq_from_init(struct rxe_dev *rxe, struct rxe_cq *cq, int cqe,
-		     int comp_vector, struct ib_ucontext *context,
+		     int comp_vector, struct ib_udata *udata,
 		     struct rxe_create_cq_resp __user *uresp);
 
 int rxe_cq_resize_queue(struct rxe_cq *cq, int new_cqe,
-			struct rxe_resize_cq_resp __user *uresp);
+			struct rxe_resize_cq_resp __user *uresp,
+			struct ib_udata *udata);
 
 int rxe_cq_post(struct rxe_cq *cq, struct rxe_cqe *cqe, int solicited);
 
@@ -91,10 +92,8 @@ struct rxe_mmap_info {
 
 void rxe_mmap_release(struct kref *ref);
 
-struct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *dev,
-					   u32 size,
-					   struct ib_ucontext *context,
-					   void *obj);
+struct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *dev, u32 size,
+					   struct ib_udata *udata, void *obj);
 
 int rxe_mmap(struct ib_ucontext *context, struct vm_area_struct *vma);
 
@@ -224,13 +223,12 @@ int rxe_srq_chk_attr(struct rxe_dev *rxe, struct rxe_srq *srq,
 		     struct ib_srq_attr *attr, enum ib_srq_attr_mask mask);
 
 int rxe_srq_from_init(struct rxe_dev *rxe, struct rxe_srq *srq,
-		      struct ib_srq_init_attr *init,
-		      struct ib_ucontext *context,
+		      struct ib_srq_init_attr *init, struct ib_udata *udata,
 		      struct rxe_create_srq_resp __user *uresp);
 
 int rxe_srq_from_attr(struct rxe_dev *rxe, struct rxe_srq *srq,
 		      struct ib_srq_attr *attr, enum ib_srq_attr_mask mask,
-		      struct rxe_modify_srq_cmd *ucmd);
+		      struct rxe_modify_srq_cmd *ucmd, struct ib_udata *udata);
 
 void rxe_release(struct kref *kref);
 
diff --git a/drivers/infiniband/sw/rxe/rxe_mmap.c b/drivers/infiniband/sw/rxe/rxe_mmap.c
index d22431e3a908..48f48122ddcb 100644
--- a/drivers/infiniband/sw/rxe/rxe_mmap.c
+++ b/drivers/infiniband/sw/rxe/rxe_mmap.c
@@ -36,6 +36,7 @@
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <asm/pgtable.h>
+#include <rdma/uverbs_ioctl.h>
 
 #include "rxe.h"
 #include "rxe_loc.h"
@@ -140,13 +141,14 @@ int rxe_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)
 /*
  * Allocate information for rxe_mmap
  */
-struct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *rxe,
-					   u32 size,
-					   struct ib_ucontext *context,
-					   void *obj)
+struct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *rxe, u32 size,
+					   struct ib_udata *udata, void *obj)
 {
 	struct rxe_mmap_info *ip;
 
+	if (!udata)
+		return ERR_PTR(-EINVAL);
+
 	ip = kmalloc(sizeof(*ip), GFP_KERNEL);
 	if (!ip)
 		return NULL;
@@ -165,7 +167,9 @@ struct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *rxe,
 
 	INIT_LIST_HEAD(&ip->pending_mmaps);
 	ip->info.size = size;
-	ip->context = context;
+	ip->context =
+		container_of(udata, struct uverbs_attr_bundle, driver_udata)
+			->context;
 	ip->obj = obj;
 	kref_init(&ip->ref);
 
* Unmerged path drivers/infiniband/sw/rxe/rxe_qp.c
diff --git a/drivers/infiniband/sw/rxe/rxe_queue.c b/drivers/infiniband/sw/rxe/rxe_queue.c
index f84ab4469261..ff92704de32f 100644
--- a/drivers/infiniband/sw/rxe/rxe_queue.c
+++ b/drivers/infiniband/sw/rxe/rxe_queue.c
@@ -36,18 +36,15 @@
 #include "rxe_loc.h"
 #include "rxe_queue.h"
 
-int do_mmap_info(struct rxe_dev *rxe,
-		 struct mminfo __user *outbuf,
-		 struct ib_ucontext *context,
-		 struct rxe_queue_buf *buf,
-		 size_t buf_size,
-		 struct rxe_mmap_info **ip_p)
+int do_mmap_info(struct rxe_dev *rxe, struct mminfo __user *outbuf,
+		 struct ib_udata *udata, struct rxe_queue_buf *buf,
+		 size_t buf_size, struct rxe_mmap_info **ip_p)
 {
 	int err;
 	struct rxe_mmap_info *ip = NULL;
 
 	if (outbuf) {
-		ip = rxe_create_mmap_info(rxe, buf_size, context, buf);
+		ip = rxe_create_mmap_info(rxe, buf_size, udata, buf);
 		if (!ip)
 			goto err1;
 
@@ -153,12 +150,9 @@ static int resize_finish(struct rxe_queue *q, struct rxe_queue *new_q,
 	return 0;
 }
 
-int rxe_queue_resize(struct rxe_queue *q,
-		     unsigned int *num_elem_p,
-		     unsigned int elem_size,
-		     struct ib_ucontext *context,
-		     struct mminfo __user *outbuf,
-		     spinlock_t *producer_lock,
+int rxe_queue_resize(struct rxe_queue *q, unsigned int *num_elem_p,
+		     unsigned int elem_size, struct ib_udata *udata,
+		     struct mminfo __user *outbuf, spinlock_t *producer_lock,
 		     spinlock_t *consumer_lock)
 {
 	struct rxe_queue *new_q;
@@ -170,7 +164,7 @@ int rxe_queue_resize(struct rxe_queue *q,
 	if (!new_q)
 		return -ENOMEM;
 
-	err = do_mmap_info(new_q->rxe, outbuf, context, new_q->buf,
+	err = do_mmap_info(new_q->rxe, outbuf, udata, new_q->buf,
 			   new_q->buf_size, &new_q->ip);
 	if (err) {
 		vfree(new_q->buf);
diff --git a/drivers/infiniband/sw/rxe/rxe_queue.h b/drivers/infiniband/sw/rxe/rxe_queue.h
index 79ba4b320054..acd0a925481c 100644
--- a/drivers/infiniband/sw/rxe/rxe_queue.h
+++ b/drivers/infiniband/sw/rxe/rxe_queue.h
@@ -76,12 +76,9 @@ struct rxe_queue {
 	unsigned int		index_mask;
 };
 
-int do_mmap_info(struct rxe_dev *rxe,
-		 struct mminfo __user *outbuf,
-		 struct ib_ucontext *context,
-		 struct rxe_queue_buf *buf,
-		 size_t buf_size,
-		 struct rxe_mmap_info **ip_p);
+int do_mmap_info(struct rxe_dev *rxe, struct mminfo __user *outbuf,
+		 struct ib_udata *udata, struct rxe_queue_buf *buf,
+		 size_t buf_size, struct rxe_mmap_info **ip_p);
 
 void rxe_queue_reset(struct rxe_queue *q);
 
@@ -89,10 +86,8 @@ struct rxe_queue *rxe_queue_init(struct rxe_dev *rxe,
 				 int *num_elem,
 				 unsigned int elem_size);
 
-int rxe_queue_resize(struct rxe_queue *q,
-		     unsigned int *num_elem_p,
-		     unsigned int elem_size,
-		     struct ib_ucontext *context,
+int rxe_queue_resize(struct rxe_queue *q, unsigned int *num_elem_p,
+		     unsigned int elem_size, struct ib_udata *udata,
 		     struct mminfo __user *outbuf,
 		     /* Protect producers while resizing queue */
 		     spinlock_t *producer_lock,
diff --git a/drivers/infiniband/sw/rxe/rxe_srq.c b/drivers/infiniband/sw/rxe/rxe_srq.c
index c41a5fee81f7..d8459431534e 100644
--- a/drivers/infiniband/sw/rxe/rxe_srq.c
+++ b/drivers/infiniband/sw/rxe/rxe_srq.c
@@ -99,8 +99,7 @@ int rxe_srq_chk_attr(struct rxe_dev *rxe, struct rxe_srq *srq,
 }
 
 int rxe_srq_from_init(struct rxe_dev *rxe, struct rxe_srq *srq,
-		      struct ib_srq_init_attr *init,
-		      struct ib_ucontext *context,
+		      struct ib_srq_init_attr *init, struct ib_udata *udata,
 		      struct rxe_create_srq_resp __user *uresp)
 {
 	int err;
@@ -128,7 +127,7 @@ int rxe_srq_from_init(struct rxe_dev *rxe, struct rxe_srq *srq,
 
 	srq->rq.queue = q;
 
-	err = do_mmap_info(rxe, uresp ? &uresp->mi : NULL, context, q->buf,
+	err = do_mmap_info(rxe, uresp ? &uresp->mi : NULL, udata, q->buf,
 			   q->buf_size, &q->ip);
 	if (err) {
 		vfree(q->buf);
@@ -149,7 +148,7 @@ int rxe_srq_from_init(struct rxe_dev *rxe, struct rxe_srq *srq,
 
 int rxe_srq_from_attr(struct rxe_dev *rxe, struct rxe_srq *srq,
 		      struct ib_srq_attr *attr, enum ib_srq_attr_mask mask,
-		      struct rxe_modify_srq_cmd *ucmd)
+		      struct rxe_modify_srq_cmd *ucmd, struct ib_udata *udata)
 {
 	int err;
 	struct rxe_queue *q = srq->rq.queue;
@@ -163,11 +162,8 @@ int rxe_srq_from_attr(struct rxe_dev *rxe, struct rxe_srq *srq,
 		mi = u64_to_user_ptr(ucmd->mmap_info_addr);
 
 		err = rxe_queue_resize(q, &attr->max_wr,
-				       rcv_wqe_size(srq->rq.max_sge),
-				       srq->rq.queue->ip ?
-						srq->rq.queue->ip->context :
-						NULL,
-				       mi, &srq->rq.producer_lock,
+				       rcv_wqe_size(srq->rq.max_sge), udata, mi,
+				       &srq->rq.producer_lock,
 				       &srq->rq.consumer_lock);
 		if (err)
 			goto err2;
* Unmerged path drivers/infiniband/sw/rxe/rxe_verbs.c
* Unmerged path include/rdma/ib_verbs.h
