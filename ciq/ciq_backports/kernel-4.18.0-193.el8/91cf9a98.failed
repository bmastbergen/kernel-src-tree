HID: logitech-hidpp: make .probe usbhid capable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [hid] logitech-hidpp: make .probe usbhid capable (Benjamin Tissoires) [1740778]
Rebuild_FUZZ: 94.38%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 91cf9a98ae4127551d022e287e283bcd8738ed02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/91cf9a98.failed

The current custom solution for the G920 is not the best because
hid_hw_start() is not called at the end of the .probe().
It means that any configuration retrieved after the initial hid_hw_start
would not be exposed to user space without races.

We can simply force hid_hw_start to just enable the transport layer by
not using a connect_mask. This way, we can have a common path between
USB, Unifying and Bluetooth devices.

With this change, we can now support the non DJ receivers for low end
devices, which will allow us to fetch the actual names of the paired
device (instead of 'Logitech Wireless Receiver')

Tested with a M185 with the non unifying receiver, a T650 and many other
unifying devices, and the T651 over Bluetooth.

	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
(cherry picked from commit 91cf9a98ae4127551d022e287e283bcd8738ed02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-logitech-hidpp.c
diff --cc drivers/hid/hid-logitech-hidpp.c
index 8032df761f2d,b389fcc1a894..000000000000
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@@ -3203,30 -3316,23 +3203,48 @@@ static int hidpp_probe(struct hid_devic
  		hid_warn(hdev, "Cannot allocate sysfs group for %s\n",
  			 hdev->name);
  
++<<<<<<< HEAD
 +	ret = hid_parse(hdev);
 +	if (ret) {
 +		hid_err(hdev, "%s:parse failed\n", __func__);
 +		goto hid_parse_fail;
 +	}
 +
 +	if (hidpp->quirks & HIDPP_QUIRK_NO_HIDINPUT)
 +		connect_mask &= ~HID_CONNECT_HIDINPUT;
 +
 +	if (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {
 +		ret = hid_hw_start(hdev, connect_mask);
 +		if (ret) {
 +			hid_err(hdev, "hw start failed\n");
 +			goto hid_hw_start_fail;
 +		}
 +		ret = hid_hw_open(hdev);
 +		if (ret < 0) {
 +			dev_err(&hdev->dev, "%s:hid_hw_open returned error:%d\n",
 +				__func__, ret);
 +			hid_hw_stop(hdev);
 +			goto hid_hw_start_fail;
 +		}
++=======
+ 	/*
+ 	 * Plain USB connections need to actually call start and open
+ 	 * on the transport driver to allow incoming data.
+ 	 */
+ 	ret = hid_hw_start(hdev, 0);
+ 	if (ret) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto hid_hw_start_fail;
++>>>>>>> 91cf9a98ae41 (HID: logitech-hidpp: make .probe usbhid capable)
  	}
  
+ 	ret = hid_hw_open(hdev);
+ 	if (ret < 0) {
+ 		dev_err(&hdev->dev, "%s:hid_hw_open returned error:%d\n",
+ 			__func__, ret);
+ 		hid_hw_stop(hdev);
+ 		goto hid_hw_open_fail;
+ 	}
  
  	/* Allow incoming packets */
  	hid_device_io_start(hdev);
@@@ -3274,14 -3381,11 +3293,12 @@@
  
  	return ret;
  
- hid_hw_open_failed:
- 	hid_device_io_stop(hdev);
- 	if (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {
- 		hid_hw_close(hdev);
- 		hid_hw_stop(hdev);
- 	}
+ hid_hw_init_fail:
+ 	hid_hw_close(hdev);
+ hid_hw_open_fail:
+ 	hid_hw_stop(hdev);
  hid_hw_start_fail:
 +hid_parse_fail:
  	sysfs_remove_group(&hdev->dev.kobj, &ps_attribute_group);
  	cancel_work_sync(&hidpp->work);
  	mutex_destroy(&hidpp->send_mutex);
@@@ -3292,12 -3396,14 +3309,11 @@@ static void hidpp_remove(struct hid_dev
  {
  	struct hidpp_device *hidpp = hid_get_drvdata(hdev);
  
 -	if (!hidpp)
 -		return hid_hw_stop(hdev);
 -
  	sysfs_remove_group(&hdev->dev.kobj, &ps_attribute_group);
  
- 	if (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {
+ 	if (hidpp->quirks & HIDPP_QUIRK_CLASS_G920)
  		hidpp_ff_deinit(hdev);
- 		hid_hw_close(hdev);
- 	}
+ 
  	hid_hw_stop(hdev);
  	cancel_work_sync(&hidpp->work);
  	mutex_destroy(&hidpp->send_mutex);
* Unmerged path drivers/hid/hid-logitech-hidpp.c
