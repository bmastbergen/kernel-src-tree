fuse: on 64-bit store time in d_fsdata directly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Khazhismel Kumykov <khazhy@google.com>
commit 30c6a23d34cbe19162240e9f9c2c122ba807e58c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/30c6a23d.failed

Implements the optimization noted in commit f75fdf22b0a8 ("fuse: don't
use ->d_time"), as the additional memory can be significant.  (In
particular, on SLAB configurations this 8-byte alloc becomes 32 bytes).
Per-dentry, this can consume significant memory.

	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Signed-off-by: Khazhismel Kumykov <khazhy@google.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 30c6a23d34cbe19162240e9f9c2c122ba807e58c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dir.c
diff --cc fs/fuse/dir.c
index 8ad9bb2eda65,58557d4817e9..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -28,14 -41,36 +40,47 @@@ union fuse_dentry 
  	struct rcu_head rcu;
  };
  
++<<<<<<< HEAD
 +static inline void fuse_dentry_settime(struct dentry *entry, u64 time)
 +{
 +	((union fuse_dentry *) entry->d_fsdata)->time = time;
 +}
 +
 +static inline u64 fuse_dentry_time(struct dentry *entry)
 +{
 +	return ((union fuse_dentry *) entry->d_fsdata)->time;
++=======
+ static inline void __fuse_dentry_settime(struct dentry *dentry, u64 time)
+ {
+ 	((union fuse_dentry *) dentry->d_fsdata)->time = time;
+ }
+ 
+ static inline u64 fuse_dentry_time(const struct dentry *entry)
+ {
+ 	return ((union fuse_dentry *) entry->d_fsdata)->time;
+ }
+ #endif
+ 
+ static void fuse_dentry_settime(struct dentry *dentry, u64 time)
+ {
+ 	struct fuse_conn *fc = get_fuse_conn_super(dentry->d_sb);
+ 	bool delete = !time && fc->delete_stale;
+ 	/*
+ 	 * Mess with DCACHE_OP_DELETE because dput() will be faster without it.
+ 	 * Don't care about races, either way it's just an optimization
+ 	 */
+ 	if ((!delete && (dentry->d_flags & DCACHE_OP_DELETE)) ||
+ 	    (delete && !(dentry->d_flags & DCACHE_OP_DELETE))) {
+ 		spin_lock(&dentry->d_lock);
+ 		if (!delete)
+ 			dentry->d_flags &= ~DCACHE_OP_DELETE;
+ 		else
+ 			dentry->d_flags |= DCACHE_OP_DELETE;
+ 		spin_unlock(&dentry->d_lock);
+ 	}
+ 
+ 	__fuse_dentry_settime(dentry, time);
++>>>>>>> 30c6a23d34cb (fuse: on 64-bit store time in d_fsdata directly)
  }
  
  /*
@@@ -247,11 -289,20 +293,18 @@@ static void fuse_dentry_release(struct 
  
  	kfree_rcu(fd, rcu);
  }
+ #endif
  
 -static int fuse_dentry_delete(const struct dentry *dentry)
 -{
 -	return time_before64(fuse_dentry_time(dentry), get_jiffies_64());
 -}
 -
  const struct dentry_operations fuse_dentry_operations = {
  	.d_revalidate	= fuse_dentry_revalidate,
++<<<<<<< HEAD
++=======
+ 	.d_delete	= fuse_dentry_delete,
+ #if BITS_PER_LONG < 64
++>>>>>>> 30c6a23d34cb (fuse: on 64-bit store time in d_fsdata directly)
  	.d_init		= fuse_dentry_init,
  	.d_release	= fuse_dentry_release,
+ #endif
  };
  
  const struct dentry_operations fuse_root_dentry_operations = {
* Unmerged path fs/fuse/dir.c
