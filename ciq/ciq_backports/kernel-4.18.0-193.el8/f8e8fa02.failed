net/mlx5: E-Switch, Centralize repersentor reg/unreg to eswitch driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Centralize repersentor reg/unreg to eswitch driver (Alaa Hleihel) [1724333]
Rebuild_FUZZ: 97.06%
commit-author Bodong Wang <bodong@mellanox.com>
commit f8e8fa0262eaf544490a11746c524333158ef0b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f8e8fa02.failed

Eswitch has two users: IB and ETH. They both register repersentors
when mlx5 interface is added, and unregister the repersentors when
mlx5 interface is removed. Ideally, each driver should only deal with
the entities which are unique to itself. However, current IB and ETH
drivers have to perform the following eswitch operations:

1. When registering, specify how many vports to register. This number
   is the same for both drivers which is the total available vport
   numbers.
2. When unregistering, specify the number of registered vports to do
   unregister. Also, unload the repersentors which are already loaded.

It's unnecessary for eswitch driver to hands out the control of above
operations to individual driver users, as they're not unique to each
driver. Instead, such operations should be centralized to eswitch
driver. This consolidates eswitch control flow, and simplified IB and
ETH driver.

This patch doesn't change any functionality.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f8e8fa0262eaf544490a11746c524333158ef0b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/ib_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/infiniband/hw/mlx5/ib_rep.c
index 95ac97af6166,4700cffb5a00..000000000000
--- a/drivers/infiniband/hw/mlx5/ib_rep.c
+++ b/drivers/infiniband/hw/mlx5/ib_rep.c
@@@ -107,53 -92,23 +107,70 @@@ static void *mlx5_ib_vport_get_proto_de
  	return mlx5_ib_rep_to_dev(rep);
  }
  
 -void mlx5_ib_register_vport_reps(struct mlx5_core_dev *mdev)
 +static void mlx5_ib_rep_register_vf_vports(struct mlx5_ib_dev *dev)
  {
++<<<<<<< HEAD
 +	struct mlx5_eswitch *esw   = dev->mdev->priv.eswitch;
 +	int total_vfs = MLX5_TOTAL_VPORTS(dev->mdev);
 +	int vport;
 +
 +	for (vport = 1; vport < total_vfs; vport++) {
 +		struct mlx5_eswitch_rep_if rep_if = {};
 +
 +		rep_if.load = mlx5_ib_vport_rep_load;
 +		rep_if.unload = mlx5_ib_vport_rep_unload;
 +		rep_if.get_proto_dev = mlx5_ib_vport_get_proto_dev;
 +		mlx5_eswitch_register_vport_rep(esw, vport, &rep_if, REP_IB);
 +	}
++=======
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep_if rep_if = {};
+ 
+ 	rep_if.load = mlx5_ib_vport_rep_load;
+ 	rep_if.unload = mlx5_ib_vport_rep_unload;
+ 	rep_if.get_proto_dev = mlx5_ib_vport_get_proto_dev;
+ 
+ 	mlx5_eswitch_register_vport_reps(esw, &rep_if, REP_IB);
++>>>>>>> f8e8fa0262ea (net/mlx5: E-Switch, Centralize repersentor reg/unreg to eswitch driver)
  }
  
 -void mlx5_ib_unregister_vport_reps(struct mlx5_core_dev *mdev)
 +static void mlx5_ib_rep_unregister_vf_vports(struct mlx5_ib_dev *dev)
  {
++<<<<<<< HEAD
 +	struct mlx5_eswitch *esw   = dev->mdev->priv.eswitch;
 +	int total_vfs = MLX5_TOTAL_VPORTS(dev->mdev);
 +	int vport;
 +
 +	for (vport = 1; vport < total_vfs; vport++)
 +		mlx5_eswitch_unregister_vport_rep(esw, vport, REP_IB);
++=======
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	mlx5_eswitch_unregister_vport_reps(esw, REP_IB);
++>>>>>>> f8e8fa0262ea (net/mlx5: E-Switch, Centralize repersentor reg/unreg to eswitch driver)
 +}
 +
 +void mlx5_ib_register_vport_reps(struct mlx5_ib_dev *dev)
 +{
 +	struct mlx5_eswitch *esw = dev->mdev->priv.eswitch;
 +	struct mlx5_eswitch_rep_if rep_if = {};
 +
 +	rep_if.load = mlx5_ib_nic_rep_load;
 +	rep_if.unload = mlx5_ib_nic_rep_unload;
 +	rep_if.get_proto_dev = mlx5_ib_vport_get_proto_dev;
 +	rep_if.priv = dev;
 +
 +	mlx5_eswitch_register_vport_rep(esw, 0, &rep_if, REP_IB);
 +
 +	mlx5_ib_rep_register_vf_vports(dev);
 +}
 +
 +void mlx5_ib_unregister_vport_reps(struct mlx5_ib_dev *dev)
 +{
 +	struct mlx5_eswitch *esw   = dev->mdev->priv.eswitch;
 +
 +	mlx5_ib_rep_unregister_vf_vports(dev); /* VFs vports */
 +	mlx5_eswitch_unregister_vport_rep(esw, 0, REP_IB); /* UPLINK PF*/
  }
  
  u8 mlx5_ib_eswitch_mode(struct mlx5_eswitch *esw)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a13e7b20a794,b702b56c457e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1783,39 -1923,39 +1783,65 @@@ int mlx5_devlink_eswitch_encap_mode_get
  	return 0;
  }
  
- void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
- 				     int vport_index,
- 				     struct mlx5_eswitch_rep_if *__rep_if,
- 				     u8 rep_type)
+ void mlx5_eswitch_register_vport_reps(struct mlx5_eswitch *esw,
+ 				      struct mlx5_eswitch_rep_if *__rep_if,
+ 				      u8 rep_type)
  {
- 	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep_if *rep_if;
++<<<<<<< HEAD
 +
 +	rep_if = &offloads->vport_reps[vport_index].rep_if[rep_type];
 +
 +	rep_if->load   = __rep_if->load;
 +	rep_if->unload = __rep_if->unload;
 +	rep_if->get_proto_dev = __rep_if->get_proto_dev;
 +	rep_if->priv = __rep_if->priv;
 +
 +	rep_if->valid = true;
 +}
 +EXPORT_SYMBOL(mlx5_eswitch_register_vport_rep);
 +
 +void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 +				       int vport_index, u8 rep_type)
 +{
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
++=======
++>>>>>>> f8e8fa0262ea (net/mlx5: E-Switch, Centralize repersentor reg/unreg to eswitch driver)
  	struct mlx5_eswitch_rep *rep;
+ 	int i;
  
- 	rep = &offloads->vport_reps[vport_index];
+ 	mlx5_esw_for_all_reps(esw, i, rep) {
+ 		rep_if = &rep->rep_if[rep_type];
+ 		rep_if->load   = __rep_if->load;
+ 		rep_if->unload = __rep_if->unload;
+ 		rep_if->get_proto_dev = __rep_if->get_proto_dev;
+ 		rep_if->priv = __rep_if->priv;
  
++<<<<<<< HEAD
 +	if (esw->mode == SRIOV_OFFLOADS && esw->vports[vport_index].enabled)
 +		rep->rep_if[rep_type].unload(rep);
 +
 +	rep->rep_if[rep_type].valid = false;
++=======
+ 		rep_if->state = REP_REGISTERED;
+ 	}
++>>>>>>> f8e8fa0262ea (net/mlx5: E-Switch, Centralize repersentor reg/unreg to eswitch driver)
+ }
+ EXPORT_SYMBOL(mlx5_eswitch_register_vport_reps);
+ 
+ void mlx5_eswitch_unregister_vport_reps(struct mlx5_eswitch *esw, u8 rep_type)
+ {
+ 	u16 max_vf = mlx5_core_max_vfs(esw->dev);
+ 	struct mlx5_eswitch_rep *rep;
+ 	int i;
+ 
+ 	if (esw->mode == SRIOV_OFFLOADS)
+ 		__unload_reps_all_vport(esw, max_vf, rep_type);
+ 
+ 	mlx5_esw_for_all_reps(esw, i, rep)
+ 		rep->rep_if[rep_type].state = REP_UNREGISTERED;
  }
- EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_rep);
+ EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_reps);
  
  void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type)
  {
* Unmerged path drivers/infiniband/hw/mlx5/ib_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 9aebe35d1bac..2af4b42775e6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -1844,25 +1844,18 @@ static void *mlx5e_vport_rep_get_proto_dev(struct mlx5_eswitch_rep *rep)
 void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev)
 {
 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
-	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
-	int vport;
+	struct mlx5_eswitch_rep_if rep_if = {};
 
-	for (vport = 0; vport < total_vfs; vport++) {
-		struct mlx5_eswitch_rep_if rep_if = {};
+	rep_if.load = mlx5e_vport_rep_load;
+	rep_if.unload = mlx5e_vport_rep_unload;
+	rep_if.get_proto_dev = mlx5e_vport_rep_get_proto_dev;
 
-		rep_if.load = mlx5e_vport_rep_load;
-		rep_if.unload = mlx5e_vport_rep_unload;
-		rep_if.get_proto_dev = mlx5e_vport_rep_get_proto_dev;
-		mlx5_eswitch_register_vport_rep(esw, vport, &rep_if, REP_ETH);
-	}
+	mlx5_eswitch_register_vport_reps(esw, &rep_if, REP_ETH);
 }
 
 void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev)
 {
 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
-	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
-	int vport;
 
-	for (vport = total_vfs - 1; vport >= 0; vport--)
-		mlx5_eswitch_unregister_vport_rep(esw, vport, REP_ETH);
+	mlx5_eswitch_unregister_vport_reps(esw, REP_ETH);
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index fab5121ffb8f..f997d5234f69 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -40,13 +40,10 @@ struct mlx5_eswitch_rep {
 	u32		       vlan_refcount;
 };
 
-void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
-				     int vport_index,
-				     struct mlx5_eswitch_rep_if *rep_if,
-				     u8 rep_type);
-void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
-				       int vport_index,
-				       u8 rep_type);
+void mlx5_eswitch_register_vport_reps(struct mlx5_eswitch *esw,
+				      struct mlx5_eswitch_rep_if *rep_if,
+				      u8 rep_type);
+void mlx5_eswitch_unregister_vport_reps(struct mlx5_eswitch *esw, u8 rep_type);
 void *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,
 				 int vport,
 				 u8 rep_type);
