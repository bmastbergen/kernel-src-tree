NFS/flexfiles: Clean up mirror DS initialisation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit cefa587a40bb5333901486632d4062f40a146585
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/cefa587a.failed

Get rid of the redundant parameter and rename the function
ff_layout_mirror_valid() to ff_layout_init_mirror_ds() for clarity.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit cefa587a40bb5333901486632d4062f40a146585)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/flexfilelayout/flexfilelayoutdev.c
diff --cc fs/nfs/flexfilelayout/flexfilelayoutdev.c
index 142ca9eb1e94,a809989807d6..000000000000
--- a/fs/nfs/flexfilelayout/flexfilelayoutdev.c
+++ b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
@@@ -183,41 -183,6 +183,44 @@@ out_err
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static bool ff_layout_mirror_valid(struct pnfs_layout_segment *lseg,
 +				   struct nfs4_ff_layout_mirror *mirror,
 +				   bool create)
 +{
 +	if (mirror == NULL || IS_ERR(mirror->mirror_ds))
 +		goto outerr;
 +	if (mirror->mirror_ds == NULL) {
 +		if (create) {
 +			struct nfs4_deviceid_node *node;
 +			struct pnfs_layout_hdr *lh = lseg->pls_layout;
 +			struct nfs4_ff_layout_ds *mirror_ds = ERR_PTR(-ENODEV);
 +
 +			node = nfs4_find_get_deviceid(NFS_SERVER(lh->plh_inode),
 +					&mirror->devid, lh->plh_lc_cred,
 +					GFP_KERNEL);
 +			if (node)
 +				mirror_ds = FF_LAYOUT_MIRROR_DS(node);
 +
 +			/* check for race with another call to this function */
 +			if (cmpxchg(&mirror->mirror_ds, NULL, mirror_ds) &&
 +			    mirror_ds != ERR_PTR(-ENODEV))
 +				nfs4_put_deviceid_node(node);
 +		} else
 +			goto outerr;
 +	}
 +
 +	if (IS_ERR(mirror->mirror_ds))
 +		goto outerr;
 +
 +	return true;
 +outerr:
 +	pnfs_error_mark_layout_for_return(lseg->pls_layout->plh_inode, lseg);
 +	return false;
 +}
 +
++=======
++>>>>>>> cefa587a40bb (NFS/flexfiles: Clean up mirror DS initialisation)
  static void extend_ds_error(struct nfs4_ff_layout_ds_err *err,
  			    u64 offset, u64 length)
  {
@@@ -380,15 -374,8 +413,20 @@@ nfs4_ff_layout_prepare_ds(struct pnfs_l
  	unsigned int max_payload;
  	int status;
  
++<<<<<<< HEAD
 +	if (!ff_layout_mirror_valid(lseg, mirror, true)) {
 +		pr_err_ratelimited("NFS: %s: No data server for offset index %d\n",
 +			__func__, ds_idx);
 +		goto out;
 +	}
 +
 +	devid = &mirror->mirror_ds->id_node;
 +	if (ff_layout_test_devid_unavailable(devid))
 +		goto out_fail;
++=======
+ 	if (!ff_layout_init_mirror_ds(lseg->pls_layout, mirror))
+ 		goto noconnect;
++>>>>>>> cefa587a40bb (NFS/flexfiles: Clean up mirror DS initialisation)
  
  	ds = mirror->mirror_ds->ds;
  	/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */
* Unmerged path fs/nfs/flexfilelayout/flexfilelayoutdev.c
