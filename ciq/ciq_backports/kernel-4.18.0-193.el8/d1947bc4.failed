arm64: arm_pmu: Add !VHE support for exclude_host/exclude_guest attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [arm64] arm_pmu: Add !VHE support for exclude_host/exclude_guest attributes (Auger Eric) [1749501]
Rebuild_FUZZ: 95.04%
commit-author Andrew Murray <andrew.murray@arm.com>
commit d1947bc4bc63e56014bb4d812e0db89944ed4a0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d1947bc4.failed

Add support for the :G and :H attributes in perf by handling the
exclude_host/exclude_guest event attributes.

We notify KVM of counters that we wish to be enabled or disabled on
guest entry/exit and thus defer from starting or stopping events based
on their event attributes.

With !VHE we switch the counters between host/guest at EL2. We are able
to eliminate counters counting host events on the boundaries of guest
entry/exit when using :G by filtering out EL2 for exclude_host. When
using !exclude_hv there is a small blackout window at the guest
entry/exit where host events are not captured.

	Signed-off-by: Andrew Murray <andrew.murray@arm.com>
	Acked-by: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit d1947bc4bc63e56014bb4d812e0db89944ed4a0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/perf_event.c
diff --cc arch/arm64/kernel/perf_event.c
index 019a00051790,6bb28aaf5aea..000000000000
--- a/arch/arm64/kernel/perf_event.c
+++ b/arch/arm64/kernel/perf_event.c
@@@ -580,6 -527,25 +581,28 @@@ static inline int armv8pmu_enable_count
  	return idx;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void armv8pmu_enable_event_counter(struct perf_event *event)
+ {
+ 	struct perf_event_attr *attr = &event->attr;
+ 	int idx = event->hw.idx;
+ 	u32 counter_bits = BIT(ARMV8_IDX_TO_COUNTER(idx));
+ 
+ 	if (armv8pmu_event_is_chained(event))
+ 		counter_bits |= BIT(ARMV8_IDX_TO_COUNTER(idx - 1));
+ 
+ 	kvm_set_pmu_events(counter_bits, attr);
+ 
+ 	/* We rely on the hypervisor switch code to enable guest counters */
+ 	if (!kvm_pmu_counter_deferred(attr)) {
+ 		armv8pmu_enable_counter(idx);
+ 		if (armv8pmu_event_is_chained(event))
+ 			armv8pmu_enable_counter(idx - 1);
+ 	}
+ }
+ 
++>>>>>>> d1947bc4bc63 (arm64: arm_pmu: Add !VHE support for exclude_host/exclude_guest attributes)
  static inline int armv8pmu_disable_counter(int idx)
  {
  	u32 counter = ARMV8_IDX_TO_COUNTER(idx);
@@@ -587,6 -553,26 +610,29 @@@
  	return idx;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void armv8pmu_disable_event_counter(struct perf_event *event)
+ {
+ 	struct hw_perf_event *hwc = &event->hw;
+ 	struct perf_event_attr *attr = &event->attr;
+ 	int idx = hwc->idx;
+ 	u32 counter_bits = BIT(ARMV8_IDX_TO_COUNTER(idx));
+ 
+ 	if (armv8pmu_event_is_chained(event))
+ 		counter_bits |= BIT(ARMV8_IDX_TO_COUNTER(idx - 1));
+ 
+ 	kvm_clr_pmu_events(counter_bits);
+ 
+ 	/* We rely on the hypervisor switch code to disable guest counters */
+ 	if (!kvm_pmu_counter_deferred(attr)) {
+ 		if (armv8pmu_event_is_chained(event))
+ 			armv8pmu_disable_counter(idx - 1);
+ 		armv8pmu_disable_counter(idx);
+ 	}
+ }
+ 
++>>>>>>> d1947bc4bc63 (arm64: arm_pmu: Add !VHE support for exclude_host/exclude_guest attributes)
  static inline int armv8pmu_enable_intens(int idx)
  {
  	u32 counter = ARMV8_IDX_TO_COUNTER(idx);
* Unmerged path arch/arm64/kernel/perf_event.c
