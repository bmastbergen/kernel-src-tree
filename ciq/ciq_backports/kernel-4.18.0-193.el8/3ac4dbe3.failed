selftests/bpf: Split off tracing-only helpers into bpf_tracing.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 3ac4dbe3dd8943450e0366f8174fbfc286ea8f19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3ac4dbe3.failed

Split-off PT_REGS-related helpers into bpf_tracing.h header. Adjust
selftests and samples to include it where necessary.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Song Liu <songliubraving@fb.com>
Link: https://lore.kernel.org/bpf/20191008175942.1769476-5-andriin@fb.com
(cherry picked from commit 3ac4dbe3dd8943450e0366f8174fbfc286ea8f19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	samples/bpf/map_perf_test_kern.c
#	samples/bpf/test_map_in_map_kern.c
#	tools/testing/selftests/bpf/bpf_helpers.h
#	tools/testing/selftests/bpf/progs/loop1.c
#	tools/testing/selftests/bpf/progs/loop2.c
#	tools/testing/selftests/bpf/progs/loop3.c
diff --cc samples/bpf/map_perf_test_kern.c
index 2b2ffb97018b,5c11aefbc489..000000000000
--- a/samples/bpf/map_perf_test_kern.c
+++ b/samples/bpf/map_perf_test_kern.c
@@@ -9,6 -9,8 +9,11 @@@
  #include <linux/version.h>
  #include <uapi/linux/bpf.h>
  #include "bpf_helpers.h"
++<<<<<<< HEAD
++=======
+ #include "bpf_legacy.h"
+ #include "bpf_tracing.h"
++>>>>>>> 3ac4dbe3dd89 (selftests/bpf: Split off tracing-only helpers into bpf_tracing.h)
  
  #define MAX_ENTRIES 1000
  #define MAX_NR_CPUS 1024
diff --cc samples/bpf/test_map_in_map_kern.c
index 42c44d091dd1,4f80cbe74c72..000000000000
--- a/samples/bpf/test_map_in_map_kern.c
+++ b/samples/bpf/test_map_in_map_kern.c
@@@ -11,6 -11,8 +11,11 @@@
  #include <uapi/linux/bpf.h>
  #include <uapi/linux/in6.h>
  #include "bpf_helpers.h"
++<<<<<<< HEAD
++=======
+ #include "bpf_legacy.h"
+ #include "bpf_tracing.h"
++>>>>>>> 3ac4dbe3dd89 (selftests/bpf: Split off tracing-only helpers into bpf_tracing.h)
  
  #define MAX_NR_PORTS 65536
  
diff --cc tools/testing/selftests/bpf/bpf_helpers.h
index 91537e9a7fbd,6d059c0a7845..000000000000
--- a/tools/testing/selftests/bpf/bpf_helpers.h
+++ b/tools/testing/selftests/bpf/bpf_helpers.h
@@@ -204,260 -30,10 +204,263 @@@ struct bpf_map_def 
  	unsigned int value_size;
  	unsigned int max_entries;
  	unsigned int map_flags;
 +	unsigned int inner_map_idx;
 +	unsigned int numa_node;
  };
  
++<<<<<<< HEAD
 +#define BPF_ANNOTATE_KV_PAIR(name, type_key, type_val)		\
 +	struct ____btf_map_##name {				\
 +		type_key key;					\
 +		type_val value;					\
 +	};							\
 +	struct ____btf_map_##name				\
 +	__attribute__ ((section(".maps." #name), used))		\
 +		____btf_map_##name = { }
 +
 +static int (*bpf_skb_load_bytes)(void *ctx, int off, void *to, int len) =
 +	(void *) BPF_FUNC_skb_load_bytes;
 +static int (*bpf_skb_load_bytes_relative)(void *ctx, int off, void *to, int len, __u32 start_header) =
 +	(void *) BPF_FUNC_skb_load_bytes_relative;
 +static int (*bpf_skb_store_bytes)(void *ctx, int off, void *from, int len, int flags) =
 +	(void *) BPF_FUNC_skb_store_bytes;
 +static int (*bpf_l3_csum_replace)(void *ctx, int off, int from, int to, int flags) =
 +	(void *) BPF_FUNC_l3_csum_replace;
 +static int (*bpf_l4_csum_replace)(void *ctx, int off, int from, int to, int flags) =
 +	(void *) BPF_FUNC_l4_csum_replace;
 +static int (*bpf_csum_diff)(void *from, int from_size, void *to, int to_size, int seed) =
 +	(void *) BPF_FUNC_csum_diff;
 +static int (*bpf_skb_under_cgroup)(void *ctx, void *map, int index) =
 +	(void *) BPF_FUNC_skb_under_cgroup;
 +static int (*bpf_skb_change_head)(void *, int len, int flags) =
 +	(void *) BPF_FUNC_skb_change_head;
 +static int (*bpf_skb_pull_data)(void *, int len) =
 +	(void *) BPF_FUNC_skb_pull_data;
 +static unsigned int (*bpf_get_cgroup_classid)(void *ctx) =
 +	(void *) BPF_FUNC_get_cgroup_classid;
 +static unsigned int (*bpf_get_route_realm)(void *ctx) =
 +	(void *) BPF_FUNC_get_route_realm;
 +static int (*bpf_skb_change_proto)(void *ctx, __be16 proto, __u64 flags) =
 +	(void *) BPF_FUNC_skb_change_proto;
 +static int (*bpf_skb_change_type)(void *ctx, __u32 type) =
 +	(void *) BPF_FUNC_skb_change_type;
 +static unsigned int (*bpf_get_hash_recalc)(void *ctx) =
 +	(void *) BPF_FUNC_get_hash_recalc;
 +static unsigned long long (*bpf_get_current_task)(void) =
 +	(void *) BPF_FUNC_get_current_task;
 +static int (*bpf_skb_change_tail)(void *ctx, __u32 len, __u64 flags) =
 +	(void *) BPF_FUNC_skb_change_tail;
 +static long long (*bpf_csum_update)(void *ctx, __u32 csum) =
 +	(void *) BPF_FUNC_csum_update;
 +static void (*bpf_set_hash_invalid)(void *ctx) =
 +	(void *) BPF_FUNC_set_hash_invalid;
 +static int (*bpf_get_numa_node_id)(void) =
 +	(void *) BPF_FUNC_get_numa_node_id;
 +static int (*bpf_probe_read_str)(void *ctx, __u32 size,
 +				 const void *unsafe_ptr) =
 +	(void *) BPF_FUNC_probe_read_str;
 +static unsigned int (*bpf_get_socket_uid)(void *ctx) =
 +	(void *) BPF_FUNC_get_socket_uid;
 +static unsigned int (*bpf_set_hash)(void *ctx, __u32 hash) =
 +	(void *) BPF_FUNC_set_hash;
 +static int (*bpf_skb_adjust_room)(void *ctx, __s32 len_diff, __u32 mode,
 +				  unsigned long long flags) =
 +	(void *) BPF_FUNC_skb_adjust_room;
 +
 +/* Scan the ARCH passed in from ARCH env variable (see Makefile) */
 +#if defined(__TARGET_ARCH_x86)
 +	#define bpf_target_x86
 +	#define bpf_target_defined
 +#elif defined(__TARGET_ARCH_s390)
 +	#define bpf_target_s390
 +	#define bpf_target_defined
 +#elif defined(__TARGET_ARCH_arm)
 +	#define bpf_target_arm
 +	#define bpf_target_defined
 +#elif defined(__TARGET_ARCH_arm64)
 +	#define bpf_target_arm64
 +	#define bpf_target_defined
 +#elif defined(__TARGET_ARCH_mips)
 +	#define bpf_target_mips
 +	#define bpf_target_defined
 +#elif defined(__TARGET_ARCH_powerpc)
 +	#define bpf_target_powerpc
 +	#define bpf_target_defined
 +#elif defined(__TARGET_ARCH_sparc)
 +	#define bpf_target_sparc
 +	#define bpf_target_defined
 +#else
 +	#undef bpf_target_defined
 +#endif
 +
 +/* Fall back to what the compiler says */
 +#ifndef bpf_target_defined
 +#if defined(__x86_64__)
 +	#define bpf_target_x86
 +#elif defined(__s390__)
 +	#define bpf_target_s390
 +#elif defined(__arm__)
 +	#define bpf_target_arm
 +#elif defined(__aarch64__)
 +	#define bpf_target_arm64
 +#elif defined(__mips__)
 +	#define bpf_target_mips
 +#elif defined(__powerpc__)
 +	#define bpf_target_powerpc
 +#elif defined(__sparc__)
 +	#define bpf_target_sparc
 +#endif
 +#endif
 +
 +#if defined(bpf_target_x86)
 +
 +#ifdef __KERNEL__
 +#define PT_REGS_PARM1(x) ((x)->di)
 +#define PT_REGS_PARM2(x) ((x)->si)
 +#define PT_REGS_PARM3(x) ((x)->dx)
 +#define PT_REGS_PARM4(x) ((x)->cx)
 +#define PT_REGS_PARM5(x) ((x)->r8)
 +#define PT_REGS_RET(x) ((x)->sp)
 +#define PT_REGS_FP(x) ((x)->bp)
 +#define PT_REGS_RC(x) ((x)->ax)
 +#define PT_REGS_SP(x) ((x)->sp)
 +#define PT_REGS_IP(x) ((x)->ip)
 +#else
 +#ifdef __i386__
 +/* i386 kernel is built with -mregparm=3 */
 +#define PT_REGS_PARM1(x) ((x)->eax)
 +#define PT_REGS_PARM2(x) ((x)->edx)
 +#define PT_REGS_PARM3(x) ((x)->ecx)
 +#define PT_REGS_PARM4(x) 0
 +#define PT_REGS_PARM5(x) 0
 +#define PT_REGS_RET(x) ((x)->esp)
 +#define PT_REGS_FP(x) ((x)->ebp)
 +#define PT_REGS_RC(x) ((x)->eax)
 +#define PT_REGS_SP(x) ((x)->esp)
 +#define PT_REGS_IP(x) ((x)->eip)
 +#else
 +#define PT_REGS_PARM1(x) ((x)->rdi)
 +#define PT_REGS_PARM2(x) ((x)->rsi)
 +#define PT_REGS_PARM3(x) ((x)->rdx)
 +#define PT_REGS_PARM4(x) ((x)->rcx)
 +#define PT_REGS_PARM5(x) ((x)->r8)
 +#define PT_REGS_RET(x) ((x)->rsp)
 +#define PT_REGS_FP(x) ((x)->rbp)
 +#define PT_REGS_RC(x) ((x)->rax)
 +#define PT_REGS_SP(x) ((x)->rsp)
 +#define PT_REGS_IP(x) ((x)->rip)
 +#endif
 +#endif
 +
 +#elif defined(bpf_target_s390)
 +
 +/* s390 provides user_pt_regs instead of struct pt_regs to userspace */
 +struct pt_regs;
 +#define PT_REGS_S390 const volatile user_pt_regs
 +#define PT_REGS_PARM1(x) (((PT_REGS_S390 *)(x))->gprs[2])
 +#define PT_REGS_PARM2(x) (((PT_REGS_S390 *)(x))->gprs[3])
 +#define PT_REGS_PARM3(x) (((PT_REGS_S390 *)(x))->gprs[4])
 +#define PT_REGS_PARM4(x) (((PT_REGS_S390 *)(x))->gprs[5])
 +#define PT_REGS_PARM5(x) (((PT_REGS_S390 *)(x))->gprs[6])
 +#define PT_REGS_RET(x) (((PT_REGS_S390 *)(x))->gprs[14])
 +/* Works only with CONFIG_FRAME_POINTER */
 +#define PT_REGS_FP(x) (((PT_REGS_S390 *)(x))->gprs[11])
 +#define PT_REGS_RC(x) (((PT_REGS_S390 *)(x))->gprs[2])
 +#define PT_REGS_SP(x) (((PT_REGS_S390 *)(x))->gprs[15])
 +#define PT_REGS_IP(x) (((PT_REGS_S390 *)(x))->psw.addr)
 +
 +#elif defined(bpf_target_arm)
 +
 +#define PT_REGS_PARM1(x) ((x)->uregs[0])
 +#define PT_REGS_PARM2(x) ((x)->uregs[1])
 +#define PT_REGS_PARM3(x) ((x)->uregs[2])
 +#define PT_REGS_PARM4(x) ((x)->uregs[3])
 +#define PT_REGS_PARM5(x) ((x)->uregs[4])
 +#define PT_REGS_RET(x) ((x)->uregs[14])
 +#define PT_REGS_FP(x) ((x)->uregs[11]) /* Works only with CONFIG_FRAME_POINTER */
 +#define PT_REGS_RC(x) ((x)->uregs[0])
 +#define PT_REGS_SP(x) ((x)->uregs[13])
 +#define PT_REGS_IP(x) ((x)->uregs[12])
 +
 +#elif defined(bpf_target_arm64)
 +
 +/* arm64 provides struct user_pt_regs instead of struct pt_regs to userspace */
 +struct pt_regs;
 +#define PT_REGS_ARM64 const volatile struct user_pt_regs
 +#define PT_REGS_PARM1(x) (((PT_REGS_ARM64 *)(x))->regs[0])
 +#define PT_REGS_PARM2(x) (((PT_REGS_ARM64 *)(x))->regs[1])
 +#define PT_REGS_PARM3(x) (((PT_REGS_ARM64 *)(x))->regs[2])
 +#define PT_REGS_PARM4(x) (((PT_REGS_ARM64 *)(x))->regs[3])
 +#define PT_REGS_PARM5(x) (((PT_REGS_ARM64 *)(x))->regs[4])
 +#define PT_REGS_RET(x) (((PT_REGS_ARM64 *)(x))->regs[30])
 +/* Works only with CONFIG_FRAME_POINTER */
 +#define PT_REGS_FP(x) (((PT_REGS_ARM64 *)(x))->regs[29])
 +#define PT_REGS_RC(x) (((PT_REGS_ARM64 *)(x))->regs[0])
 +#define PT_REGS_SP(x) (((PT_REGS_ARM64 *)(x))->sp)
 +#define PT_REGS_IP(x) (((PT_REGS_ARM64 *)(x))->pc)
 +
 +#elif defined(bpf_target_mips)
 +
 +#define PT_REGS_PARM1(x) ((x)->regs[4])
 +#define PT_REGS_PARM2(x) ((x)->regs[5])
 +#define PT_REGS_PARM3(x) ((x)->regs[6])
 +#define PT_REGS_PARM4(x) ((x)->regs[7])
 +#define PT_REGS_PARM5(x) ((x)->regs[8])
 +#define PT_REGS_RET(x) ((x)->regs[31])
 +#define PT_REGS_FP(x) ((x)->regs[30]) /* Works only with CONFIG_FRAME_POINTER */
 +#define PT_REGS_RC(x) ((x)->regs[1])
 +#define PT_REGS_SP(x) ((x)->regs[29])
 +#define PT_REGS_IP(x) ((x)->cp0_epc)
 +
 +#elif defined(bpf_target_powerpc)
 +
 +#define PT_REGS_PARM1(x) ((x)->gpr[3])
 +#define PT_REGS_PARM2(x) ((x)->gpr[4])
 +#define PT_REGS_PARM3(x) ((x)->gpr[5])
 +#define PT_REGS_PARM4(x) ((x)->gpr[6])
 +#define PT_REGS_PARM5(x) ((x)->gpr[7])
 +#define PT_REGS_RC(x) ((x)->gpr[3])
 +#define PT_REGS_SP(x) ((x)->sp)
 +#define PT_REGS_IP(x) ((x)->nip)
 +
 +#elif defined(bpf_target_sparc)
 +
 +#define PT_REGS_PARM1(x) ((x)->u_regs[UREG_I0])
 +#define PT_REGS_PARM2(x) ((x)->u_regs[UREG_I1])
 +#define PT_REGS_PARM3(x) ((x)->u_regs[UREG_I2])
 +#define PT_REGS_PARM4(x) ((x)->u_regs[UREG_I3])
 +#define PT_REGS_PARM5(x) ((x)->u_regs[UREG_I4])
 +#define PT_REGS_RET(x) ((x)->u_regs[UREG_I7])
 +#define PT_REGS_RC(x) ((x)->u_regs[UREG_I0])
 +#define PT_REGS_SP(x) ((x)->u_regs[UREG_FP])
 +
 +/* Should this also be a bpf_target check for the sparc case? */
 +#if defined(__arch64__)
 +#define PT_REGS_IP(x) ((x)->tpc)
 +#else
 +#define PT_REGS_IP(x) ((x)->pc)
 +#endif
 +
 +#endif
 +
 +#if defined(bpf_target_powerpc)
 +#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = (ctx)->link; })
 +#define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
 +#elif defined(bpf_target_sparc)
 +#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = PT_REGS_RET(ctx); })
 +#define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
 +#else
 +#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({				\
 +		bpf_probe_read(&(ip), sizeof(ip), (void *)PT_REGS_RET(ctx)); })
 +#define BPF_KRETPROBE_READ_RET_IP(ip, ctx)	({				\
 +		bpf_probe_read(&(ip), sizeof(ip),				\
 +				(void *)(PT_REGS_FP(ctx) + sizeof(ip))); })
 +#endif
 +
++=======
++>>>>>>> 3ac4dbe3dd89 (selftests/bpf: Split off tracing-only helpers into bpf_tracing.h)
  /*
 - * bpf_core_read() abstracts away bpf_probe_read() call and captures offset
 + * BPF_CORE_READ abstracts away bpf_probe_read() call and captures offset
   * relocation for source address using __builtin_preserve_access_index()
   * built-in, provided by Clang.
   *
* Unmerged path tools/testing/selftests/bpf/progs/loop1.c
* Unmerged path tools/testing/selftests/bpf/progs/loop2.c
* Unmerged path tools/testing/selftests/bpf/progs/loop3.c
* Unmerged path samples/bpf/map_perf_test_kern.c
diff --git a/samples/bpf/offwaketime_kern.c b/samples/bpf/offwaketime_kern.c
index e7d9a0a3d45b..9cb5207a692f 100644
--- a/samples/bpf/offwaketime_kern.c
+++ b/samples/bpf/offwaketime_kern.c
@@ -6,6 +6,7 @@
  */
 #include <uapi/linux/bpf.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 #include <uapi/linux/ptrace.h>
 #include <uapi/linux/perf_event.h>
 #include <linux/version.h>
diff --git a/samples/bpf/sampleip_kern.c b/samples/bpf/sampleip_kern.c
index ceabf31079cf..4a190893894f 100644
--- a/samples/bpf/sampleip_kern.c
+++ b/samples/bpf/sampleip_kern.c
@@ -9,6 +9,7 @@
 #include <uapi/linux/bpf.h>
 #include <uapi/linux/bpf_perf_event.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 #define MAX_IPS		8192
 
diff --git a/samples/bpf/spintest_kern.c b/samples/bpf/spintest_kern.c
index ce0167d09cdc..6e9478aa2938 100644
--- a/samples/bpf/spintest_kern.c
+++ b/samples/bpf/spintest_kern.c
@@ -10,6 +10,7 @@
 #include <uapi/linux/bpf.h>
 #include <uapi/linux/perf_event.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 struct bpf_map_def SEC("maps") my_map = {
 	.type = BPF_MAP_TYPE_HASH,
* Unmerged path samples/bpf/test_map_in_map_kern.c
diff --git a/samples/bpf/test_overhead_kprobe_kern.c b/samples/bpf/test_overhead_kprobe_kern.c
index 468a66a92ef9..8d2518e68db9 100644
--- a/samples/bpf/test_overhead_kprobe_kern.c
+++ b/samples/bpf/test_overhead_kprobe_kern.c
@@ -8,6 +8,7 @@
 #include <linux/ptrace.h>
 #include <uapi/linux/bpf.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 #define _(P) ({typeof(P) val = 0; bpf_probe_read(&val, sizeof(val), &P); val;})
 
diff --git a/samples/bpf/test_probe_write_user_kern.c b/samples/bpf/test_probe_write_user_kern.c
index 3a677c807044..a543358218e6 100644
--- a/samples/bpf/test_probe_write_user_kern.c
+++ b/samples/bpf/test_probe_write_user_kern.c
@@ -9,6 +9,7 @@
 #include <uapi/linux/bpf.h>
 #include <linux/version.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 struct bpf_map_def SEC("maps") dnat_map = {
 	.type = BPF_MAP_TYPE_HASH,
diff --git a/samples/bpf/trace_event_kern.c b/samples/bpf/trace_event_kern.c
index 7068fbdde951..8dc18d233a27 100644
--- a/samples/bpf/trace_event_kern.c
+++ b/samples/bpf/trace_event_kern.c
@@ -10,6 +10,7 @@
 #include <uapi/linux/bpf_perf_event.h>
 #include <uapi/linux/perf_event.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 struct key_t {
 	char comm[TASK_COMM_LEN];
diff --git a/samples/bpf/tracex1_kern.c b/samples/bpf/tracex1_kern.c
index 107da148820f..1a15f6605129 100644
--- a/samples/bpf/tracex1_kern.c
+++ b/samples/bpf/tracex1_kern.c
@@ -9,6 +9,7 @@
 #include <uapi/linux/bpf.h>
 #include <linux/version.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 #define _(P) ({typeof(P) val = 0; bpf_probe_read(&val, sizeof(val), &P); val;})
 
diff --git a/samples/bpf/tracex2_kern.c b/samples/bpf/tracex2_kern.c
index 5e11c20ce5ec..d70b3ea79ea7 100644
--- a/samples/bpf/tracex2_kern.c
+++ b/samples/bpf/tracex2_kern.c
@@ -9,6 +9,7 @@
 #include <linux/version.h>
 #include <uapi/linux/bpf.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 struct bpf_map_def SEC("maps") my_map = {
 	.type = BPF_MAP_TYPE_HASH,
diff --git a/samples/bpf/tracex3_kern.c b/samples/bpf/tracex3_kern.c
index ea1d4c19c132..9af546bebfa9 100644
--- a/samples/bpf/tracex3_kern.c
+++ b/samples/bpf/tracex3_kern.c
@@ -9,6 +9,7 @@
 #include <linux/version.h>
 #include <uapi/linux/bpf.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 struct bpf_map_def SEC("maps") my_map = {
 	.type = BPF_MAP_TYPE_HASH,
diff --git a/samples/bpf/tracex4_kern.c b/samples/bpf/tracex4_kern.c
index 6dd8e384de96..2a02cbe9d9a1 100644
--- a/samples/bpf/tracex4_kern.c
+++ b/samples/bpf/tracex4_kern.c
@@ -8,6 +8,7 @@
 #include <linux/version.h>
 #include <uapi/linux/bpf.h>
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 struct pair {
 	u64 val;
diff --git a/samples/bpf/tracex5_kern.c b/samples/bpf/tracex5_kern.c
index f57f4e1ea1ec..184729570c57 100644
--- a/samples/bpf/tracex5_kern.c
+++ b/samples/bpf/tracex5_kern.c
@@ -11,6 +11,7 @@
 #include <uapi/linux/unistd.h>
 #include "syscall_nrs.h"
 #include "bpf_helpers.h"
+#include "bpf_tracing.h"
 
 #define PROG(F) SEC("kprobe/"__stringify(F)) int bpf_func_##F
 
* Unmerged path tools/testing/selftests/bpf/bpf_helpers.h
diff --git a/tools/testing/selftests/bpf/bpf_tracing.h b/tools/testing/selftests/bpf/bpf_tracing.h
new file mode 100644
index 000000000000..b0dafe8b4ebc
--- /dev/null
+++ b/tools/testing/selftests/bpf/bpf_tracing.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
+#ifndef __BPF_TRACING_H__
+#define __BPF_TRACING_H__
+
+/* Scan the ARCH passed in from ARCH env variable (see Makefile) */
+#if defined(__TARGET_ARCH_x86)
+	#define bpf_target_x86
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_s390)
+	#define bpf_target_s390
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_arm)
+	#define bpf_target_arm
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_arm64)
+	#define bpf_target_arm64
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_mips)
+	#define bpf_target_mips
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_powerpc)
+	#define bpf_target_powerpc
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_sparc)
+	#define bpf_target_sparc
+	#define bpf_target_defined
+#else
+	#undef bpf_target_defined
+#endif
+
+/* Fall back to what the compiler says */
+#ifndef bpf_target_defined
+#if defined(__x86_64__)
+	#define bpf_target_x86
+#elif defined(__s390__)
+	#define bpf_target_s390
+#elif defined(__arm__)
+	#define bpf_target_arm
+#elif defined(__aarch64__)
+	#define bpf_target_arm64
+#elif defined(__mips__)
+	#define bpf_target_mips
+#elif defined(__powerpc__)
+	#define bpf_target_powerpc
+#elif defined(__sparc__)
+	#define bpf_target_sparc
+#endif
+#endif
+
+#if defined(bpf_target_x86)
+
+#ifdef __KERNEL__
+#define PT_REGS_PARM1(x) ((x)->di)
+#define PT_REGS_PARM2(x) ((x)->si)
+#define PT_REGS_PARM3(x) ((x)->dx)
+#define PT_REGS_PARM4(x) ((x)->cx)
+#define PT_REGS_PARM5(x) ((x)->r8)
+#define PT_REGS_RET(x) ((x)->sp)
+#define PT_REGS_FP(x) ((x)->bp)
+#define PT_REGS_RC(x) ((x)->ax)
+#define PT_REGS_SP(x) ((x)->sp)
+#define PT_REGS_IP(x) ((x)->ip)
+#else
+#ifdef __i386__
+/* i386 kernel is built with -mregparm=3 */
+#define PT_REGS_PARM1(x) ((x)->eax)
+#define PT_REGS_PARM2(x) ((x)->edx)
+#define PT_REGS_PARM3(x) ((x)->ecx)
+#define PT_REGS_PARM4(x) 0
+#define PT_REGS_PARM5(x) 0
+#define PT_REGS_RET(x) ((x)->esp)
+#define PT_REGS_FP(x) ((x)->ebp)
+#define PT_REGS_RC(x) ((x)->eax)
+#define PT_REGS_SP(x) ((x)->esp)
+#define PT_REGS_IP(x) ((x)->eip)
+#else
+#define PT_REGS_PARM1(x) ((x)->rdi)
+#define PT_REGS_PARM2(x) ((x)->rsi)
+#define PT_REGS_PARM3(x) ((x)->rdx)
+#define PT_REGS_PARM4(x) ((x)->rcx)
+#define PT_REGS_PARM5(x) ((x)->r8)
+#define PT_REGS_RET(x) ((x)->rsp)
+#define PT_REGS_FP(x) ((x)->rbp)
+#define PT_REGS_RC(x) ((x)->rax)
+#define PT_REGS_SP(x) ((x)->rsp)
+#define PT_REGS_IP(x) ((x)->rip)
+#endif
+#endif
+
+#elif defined(bpf_target_s390)
+
+/* s390 provides user_pt_regs instead of struct pt_regs to userspace */
+struct pt_regs;
+#define PT_REGS_S390 const volatile user_pt_regs
+#define PT_REGS_PARM1(x) (((PT_REGS_S390 *)(x))->gprs[2])
+#define PT_REGS_PARM2(x) (((PT_REGS_S390 *)(x))->gprs[3])
+#define PT_REGS_PARM3(x) (((PT_REGS_S390 *)(x))->gprs[4])
+#define PT_REGS_PARM4(x) (((PT_REGS_S390 *)(x))->gprs[5])
+#define PT_REGS_PARM5(x) (((PT_REGS_S390 *)(x))->gprs[6])
+#define PT_REGS_RET(x) (((PT_REGS_S390 *)(x))->gprs[14])
+/* Works only with CONFIG_FRAME_POINTER */
+#define PT_REGS_FP(x) (((PT_REGS_S390 *)(x))->gprs[11])
+#define PT_REGS_RC(x) (((PT_REGS_S390 *)(x))->gprs[2])
+#define PT_REGS_SP(x) (((PT_REGS_S390 *)(x))->gprs[15])
+#define PT_REGS_IP(x) (((PT_REGS_S390 *)(x))->psw.addr)
+
+#elif defined(bpf_target_arm)
+
+#define PT_REGS_PARM1(x) ((x)->uregs[0])
+#define PT_REGS_PARM2(x) ((x)->uregs[1])
+#define PT_REGS_PARM3(x) ((x)->uregs[2])
+#define PT_REGS_PARM4(x) ((x)->uregs[3])
+#define PT_REGS_PARM5(x) ((x)->uregs[4])
+#define PT_REGS_RET(x) ((x)->uregs[14])
+#define PT_REGS_FP(x) ((x)->uregs[11]) /* Works only with CONFIG_FRAME_POINTER */
+#define PT_REGS_RC(x) ((x)->uregs[0])
+#define PT_REGS_SP(x) ((x)->uregs[13])
+#define PT_REGS_IP(x) ((x)->uregs[12])
+
+#elif defined(bpf_target_arm64)
+
+/* arm64 provides struct user_pt_regs instead of struct pt_regs to userspace */
+struct pt_regs;
+#define PT_REGS_ARM64 const volatile struct user_pt_regs
+#define PT_REGS_PARM1(x) (((PT_REGS_ARM64 *)(x))->regs[0])
+#define PT_REGS_PARM2(x) (((PT_REGS_ARM64 *)(x))->regs[1])
+#define PT_REGS_PARM3(x) (((PT_REGS_ARM64 *)(x))->regs[2])
+#define PT_REGS_PARM4(x) (((PT_REGS_ARM64 *)(x))->regs[3])
+#define PT_REGS_PARM5(x) (((PT_REGS_ARM64 *)(x))->regs[4])
+#define PT_REGS_RET(x) (((PT_REGS_ARM64 *)(x))->regs[30])
+/* Works only with CONFIG_FRAME_POINTER */
+#define PT_REGS_FP(x) (((PT_REGS_ARM64 *)(x))->regs[29])
+#define PT_REGS_RC(x) (((PT_REGS_ARM64 *)(x))->regs[0])
+#define PT_REGS_SP(x) (((PT_REGS_ARM64 *)(x))->sp)
+#define PT_REGS_IP(x) (((PT_REGS_ARM64 *)(x))->pc)
+
+#elif defined(bpf_target_mips)
+
+#define PT_REGS_PARM1(x) ((x)->regs[4])
+#define PT_REGS_PARM2(x) ((x)->regs[5])
+#define PT_REGS_PARM3(x) ((x)->regs[6])
+#define PT_REGS_PARM4(x) ((x)->regs[7])
+#define PT_REGS_PARM5(x) ((x)->regs[8])
+#define PT_REGS_RET(x) ((x)->regs[31])
+#define PT_REGS_FP(x) ((x)->regs[30]) /* Works only with CONFIG_FRAME_POINTER */
+#define PT_REGS_RC(x) ((x)->regs[1])
+#define PT_REGS_SP(x) ((x)->regs[29])
+#define PT_REGS_IP(x) ((x)->cp0_epc)
+
+#elif defined(bpf_target_powerpc)
+
+#define PT_REGS_PARM1(x) ((x)->gpr[3])
+#define PT_REGS_PARM2(x) ((x)->gpr[4])
+#define PT_REGS_PARM3(x) ((x)->gpr[5])
+#define PT_REGS_PARM4(x) ((x)->gpr[6])
+#define PT_REGS_PARM5(x) ((x)->gpr[7])
+#define PT_REGS_RC(x) ((x)->gpr[3])
+#define PT_REGS_SP(x) ((x)->sp)
+#define PT_REGS_IP(x) ((x)->nip)
+
+#elif defined(bpf_target_sparc)
+
+#define PT_REGS_PARM1(x) ((x)->u_regs[UREG_I0])
+#define PT_REGS_PARM2(x) ((x)->u_regs[UREG_I1])
+#define PT_REGS_PARM3(x) ((x)->u_regs[UREG_I2])
+#define PT_REGS_PARM4(x) ((x)->u_regs[UREG_I3])
+#define PT_REGS_PARM5(x) ((x)->u_regs[UREG_I4])
+#define PT_REGS_RET(x) ((x)->u_regs[UREG_I7])
+#define PT_REGS_RC(x) ((x)->u_regs[UREG_I0])
+#define PT_REGS_SP(x) ((x)->u_regs[UREG_FP])
+
+/* Should this also be a bpf_target check for the sparc case? */
+#if defined(__arch64__)
+#define PT_REGS_IP(x) ((x)->tpc)
+#else
+#define PT_REGS_IP(x) ((x)->pc)
+#endif
+
+#endif
+
+#if defined(bpf_target_powerpc)
+#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = (ctx)->link; })
+#define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
+#elif defined(bpf_target_sparc)
+#define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = PT_REGS_RET(ctx); })
+#define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
+#else
+#define BPF_KPROBE_READ_RET_IP(ip, ctx)					    \
+	({ bpf_probe_read(&(ip), sizeof(ip), (void *)PT_REGS_RET(ctx)); })
+#define BPF_KRETPROBE_READ_RET_IP(ip, ctx)				    \
+	({ bpf_probe_read(&(ip), sizeof(ip),				    \
+			  (void *)(PT_REGS_FP(ctx) + sizeof(ip))); })
+#endif
+
+#endif
* Unmerged path tools/testing/selftests/bpf/progs/loop1.c
* Unmerged path tools/testing/selftests/bpf/progs/loop2.c
* Unmerged path tools/testing/selftests/bpf/progs/loop3.c
