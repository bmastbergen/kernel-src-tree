bnxt_en: Extend ETHTOOL_RESET to hot reset driver.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Extend ETHTOOL_RESET to hot reset driver (Jonathan Toppins) [1801868]
Rebuild_FUZZ: 98.99%
commit-author Vasundhara Volam <vasundhara-v.volam@broadcom.com>
commit 0a3f4e4f342c070312d799f7998d2f916c502c6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0a3f4e4f.failed

If firmware supports hot reset, extend ETHTOOL_RESET to support
hot reset driver which does not require a driver reload after
ETHTOOL_RESET.  The driver will go through the same coordinated
reset sequence as a firmware initiated fatal/non-fatal reset.

	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0a3f4e4f342c070312d799f7998d2f916c502c6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 17f5edfd8c9f,b081a555534b..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -6718,6 -6945,16 +6718,19 @@@ static int __bnxt_hwrm_func_qcaps(struc
  		bp->flags |= BNXT_FLAG_ROCEV1_CAP;
  	if (flags & FUNC_QCAPS_RESP_FLAGS_ROCE_V2_SUPPORTED)
  		bp->flags |= BNXT_FLAG_ROCEV2_CAP;
++<<<<<<< HEAD
++=======
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_PCIE_STATS_SUPPORTED)
+ 		bp->fw_cap |= BNXT_FW_CAP_PCIE_STATS_SUPPORTED;
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_HOT_RESET_CAPABLE)
+ 		bp->fw_cap |= BNXT_FW_CAP_HOT_RESET;
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_EXT_STATS_SUPPORTED)
+ 		bp->fw_cap |= BNXT_FW_CAP_EXT_STATS_SUPPORTED;
+ 	if (flags &  FUNC_QCAPS_RESP_FLAGS_ERROR_RECOVERY_CAPABLE)
+ 		bp->fw_cap |= BNXT_FW_CAP_ERROR_RECOVERY;
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_ERR_RECOVER_RELOAD)
+ 		bp->fw_cap |= BNXT_FW_CAP_ERR_RECOVER_RELOAD;
++>>>>>>> 0a3f4e4f342c (bnxt_en: Extend ETHTOOL_RESET to hot reset driver.)
  
  	bp->tx_push_thresh = 0;
  	if (flags & FUNC_QCAPS_RESP_FLAGS_PUSH_MODE_SUPPORTED)
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 7b36ae0bfd54,271085f7e481..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1569,6 -1664,14 +1569,17 @@@ struct bnxt 
  	#define BNXT_FW_CAP_KONG_MB_CHNL		0x00000080
  	#define BNXT_FW_CAP_OVS_64BIT_HANDLE		0x00000400
  	#define BNXT_FW_CAP_TRUSTED_VF			0x00000800
++<<<<<<< HEAD
++=======
+ 	#define BNXT_FW_CAP_ERROR_RECOVERY		0x00002000
+ 	#define BNXT_FW_CAP_PKG_VER			0x00004000
+ 	#define BNXT_FW_CAP_CFA_ADV_FLOW		0x00008000
+ 	#define BNXT_FW_CAP_CFA_RFS_RING_TBL_IDX_V2	0x00010000
+ 	#define BNXT_FW_CAP_PCIE_STATS_SUPPORTED	0x00020000
+ 	#define BNXT_FW_CAP_EXT_STATS_SUPPORTED		0x00040000
+ 	#define BNXT_FW_CAP_ERR_RECOVER_RELOAD		0x00100000
+ 	#define BNXT_FW_CAP_HOT_RESET			0x00200000
++>>>>>>> 0a3f4e4f342c (bnxt_en: Extend ETHTOOL_RESET to hot reset driver.)
  
  #define BNXT_NEW_RM(bp)		((bp)->fw_cap & BNXT_FW_CAP_NEW_RM)
  	u32			hwrm_spec_code;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index a09e573be4e3..2a03d09023de 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -1746,6 +1746,8 @@ static int bnxt_firmware_reset(struct net_device *dev,
 	case BNXT_FW_RESET_CHIP:
 		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP;
 		req.selfrst_status = FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP;
+		if (bp->fw_cap & BNXT_FW_CAP_HOT_RESET)
+			req.flags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;
 		break;
 	case BNXT_FW_RESET_AP:
 		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_AP;
@@ -2942,7 +2944,8 @@ static int bnxt_reset(struct net_device *dev, u32 *flags)
 		return -EOPNOTSUPP;
 	}
 
-	if (pci_vfs_assigned(bp->pdev)) {
+	if (pci_vfs_assigned(bp->pdev) &&
+	    !(bp->fw_cap & BNXT_FW_CAP_HOT_RESET)) {
 		netdev_err(dev,
 			   "Reset not allowed when VFs are assigned to VMs\n");
 		return -EBUSY;
@@ -2955,7 +2958,9 @@ static int bnxt_reset(struct net_device *dev, u32 *flags)
 
 		rc = bnxt_firmware_reset(dev, BNXT_FW_RESET_CHIP);
 		if (!rc) {
-			netdev_info(dev, "Reset request successful. Reload driver to complete reset\n");
+			netdev_info(dev, "Reset request successful.\n");
+			if (!(bp->fw_cap & BNXT_FW_CAP_HOT_RESET))
+				netdev_info(dev, "Reload driver to complete reset\n");
 			*flags = 0;
 		}
 	} else if (*flags == ETH_RESET_AP) {
