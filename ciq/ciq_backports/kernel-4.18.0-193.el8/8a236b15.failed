net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 8a236b15144b29ce47f80c37bc55740a5388ecb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/8a236b15.failed

In order to support all of the supported stats that are available in legacy
mode for switchdev uplink representors, convert rep stats infrastructure to
reuse struct mlx5e_stats_grp that is already used when device is in legacy
mode. Refactor rep code to use array of mlx5e_stats_grp
structures (constructed using macros provided by stats infra) to
fill/update stats, instead of fixed hardcoded set of values. This approach
allows to easily extend representors with new stats types.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 8a236b15144b29ce47f80c37bc55740a5388ecb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index e3ab7df3e76c,01745941a11f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -111,23 -117,70 +111,73 @@@ static const struct counter_desc vport_
  #define NUM_VPORT_REP_SW_COUNTERS ARRAY_SIZE(sw_rep_stats_desc)
  #define NUM_VPORT_REP_HW_COUNTERS ARRAY_SIZE(vport_rep_stats_desc)
  
- static void mlx5e_rep_get_strings(struct net_device *dev,
- 				  u32 stringset, uint8_t *data)
+ static MLX5E_DECLARE_STATS_GRP_OP_NUM_STATS(sw_rep)
  {
- 	int i, j;
+ 	return NUM_VPORT_REP_SW_COUNTERS;
+ }
  
- 	switch (stringset) {
- 	case ETH_SS_STATS:
- 		for (i = 0; i < NUM_VPORT_REP_SW_COUNTERS; i++)
- 			strcpy(data + (i * ETH_GSTRING_LEN),
- 			       sw_rep_stats_desc[i].format);
- 		for (j = 0; j < NUM_VPORT_REP_HW_COUNTERS; j++, i++)
- 			strcpy(data + (i * ETH_GSTRING_LEN),
- 			       vport_rep_stats_desc[j].format);
- 		break;
- 	}
++<<<<<<< HEAD
++=======
+ static MLX5E_DECLARE_STATS_GRP_OP_FILL_STRS(sw_rep)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NUM_VPORT_REP_SW_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 		       sw_rep_stats_desc[i].format);
+ 	return idx;
+ }
+ 
+ static MLX5E_DECLARE_STATS_GRP_OP_FILL_STATS(sw_rep)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NUM_VPORT_REP_SW_COUNTERS; i++)
+ 		data[idx++] = MLX5E_READ_CTR64_CPU(&priv->stats.sw,
+ 						   sw_rep_stats_desc, i);
+ 	return idx;
+ }
+ 
+ static MLX5E_DECLARE_STATS_GRP_OP_UPDATE_STATS(sw_rep)
+ {
+ 	struct mlx5e_sw_stats *s = &priv->stats.sw;
+ 	struct rtnl_link_stats64 stats64 = {};
+ 
+ 	memset(s, 0, sizeof(*s));
+ 	mlx5e_fold_sw_stats64(priv, &stats64);
+ 
+ 	s->rx_packets = stats64.rx_packets;
+ 	s->rx_bytes   = stats64.rx_bytes;
+ 	s->tx_packets = stats64.tx_packets;
+ 	s->tx_bytes   = stats64.tx_bytes;
+ 	s->tx_queue_dropped = stats64.tx_dropped;
  }
  
+ static MLX5E_DECLARE_STATS_GRP_OP_NUM_STATS(vport_rep)
+ {
+ 	return NUM_VPORT_REP_HW_COUNTERS;
+ }
+ 
+ static MLX5E_DECLARE_STATS_GRP_OP_FILL_STRS(vport_rep)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NUM_VPORT_REP_HW_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN, vport_rep_stats_desc[i].format);
+ 	return idx;
+ }
+ 
+ static MLX5E_DECLARE_STATS_GRP_OP_FILL_STATS(vport_rep)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NUM_VPORT_REP_HW_COUNTERS; i++)
+ 		data[idx++] = MLX5E_READ_CTR64_CPU(&priv->stats.vf_vport,
+ 						   vport_rep_stats_desc, i);
+ 	return idx;
+ }
+ 
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  static void mlx5e_vf_rep_update_hw_counters(struct mlx5e_priv *priv)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
@@@ -166,53 -219,35 +216,68 @@@ static void mlx5e_uplink_rep_update_hw_
  	vport_stats->tx_bytes   = PPORT_802_3_GET(pstats, a_octets_transmitted_ok);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_rep_update_hw_counters(struct mlx5e_priv *priv)
 +{
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5_eswitch_rep *rep = rpriv->rep;
 +
 +	if (rep->vport == FDB_UPLINK_VPORT)
 +		mlx5e_uplink_rep_update_hw_counters(priv);
 +	else
 +		mlx5e_vf_rep_update_hw_counters(priv);
 +}
 +
 +static void mlx5e_rep_update_sw_counters(struct mlx5e_priv *priv)
++=======
+ static MLX5E_DECLARE_STATS_GRP_OP_UPDATE_STATS(vport_rep)
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  {
- 	struct mlx5e_sw_stats *s = &priv->stats.sw;
- 	struct rtnl_link_stats64 stats64 = {};
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
  
- 	memset(s, 0, sizeof(*s));
- 	mlx5e_fold_sw_stats64(priv, &stats64);
+ 	if (rep->vport == MLX5_VPORT_UPLINK)
+ 		mlx5e_uplink_rep_update_hw_counters(priv);
+ 	else
+ 		mlx5e_vf_rep_update_hw_counters(priv);
+ }
  
- 	s->rx_packets = stats64.rx_packets;
- 	s->rx_bytes   = stats64.rx_bytes;
- 	s->tx_packets = stats64.tx_packets;
- 	s->tx_bytes   = stats64.tx_bytes;
- 	s->tx_queue_dropped = stats64.tx_dropped;
+ static void mlx5e_rep_get_strings(struct net_device *dev,
+ 				  u32 stringset, uint8_t *data)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		mlx5e_stats_fill_strings(priv, data);
+ 		break;
+ 	}
  }
  
  static void mlx5e_rep_get_ethtool_stats(struct net_device *dev,
  					struct ethtool_stats *stats, u64 *data)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
- 	int i, j;
  
++<<<<<<< HEAD
 +	if (!data)
 +		return;
 +
 +	mutex_lock(&priv->state_lock);
 +	mlx5e_rep_update_sw_counters(priv);
 +	mlx5e_rep_update_hw_counters(priv);
 +	mutex_unlock(&priv->state_lock);
 +
 +	for (i = 0; i < NUM_VPORT_REP_SW_COUNTERS; i++)
 +		data[i] = MLX5E_READ_CTR64_CPU(&priv->stats.sw,
 +					       sw_rep_stats_desc, i);
 +
 +	for (j = 0; j < NUM_VPORT_REP_HW_COUNTERS; j++, i++)
 +		data[i] = MLX5E_READ_CTR64_CPU(&priv->stats.vf_vport,
 +					       vport_rep_stats_desc, j);
++=======
+ 	mlx5e_ethtool_get_ethtool_stats(priv, stats, data);
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  }
  
  static int mlx5e_rep_get_sset_count(struct net_device *dev, int sset)
@@@ -1756,18 -1875,47 +1823,59 @@@ static void mlx5e_uplink_rep_disable(st
  	mlx5_lag_remove(mdev);
  }
  
++<<<<<<< HEAD
 +static const struct mlx5e_profile mlx5e_vf_rep_profile = {
++=======
+ static MLX5E_DEFINE_STATS_GRP(sw_rep, 0);
+ static MLX5E_DEFINE_STATS_GRP(vport_rep, MLX5E_NDO_UPDATE_STATS);
+ 
+ /* The stats groups order is opposite to the update_stats() order calls */
+ static mlx5e_stats_grp_t mlx5e_rep_stats_grps[] = {
+ 	&MLX5E_STATS_GRP(sw_rep),
+ 	&MLX5E_STATS_GRP(vport_rep),
+ };
+ 
+ static unsigned int mlx5e_rep_stats_grps_num(struct mlx5e_priv *priv)
+ {
+ 	return ARRAY_SIZE(mlx5e_rep_stats_grps);
+ }
+ 
+ /* The stats groups order is opposite to the update_stats() order calls */
+ static mlx5e_stats_grp_t mlx5e_ul_rep_stats_grps[] = {
+ 	&MLX5E_STATS_GRP(sw_rep),
+ 	&MLX5E_STATS_GRP(vport_rep),
+ };
+ 
+ static unsigned int mlx5e_ul_rep_stats_grps_num(struct mlx5e_priv *priv)
+ {
+ 	return ARRAY_SIZE(mlx5e_ul_rep_stats_grps);
+ }
+ 
+ static const struct mlx5e_profile mlx5e_rep_profile = {
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  	.init			= mlx5e_init_rep,
  	.cleanup		= mlx5e_cleanup_rep,
  	.init_rx		= mlx5e_init_rep_rx,
  	.cleanup_rx		= mlx5e_cleanup_rep_rx,
  	.init_tx		= mlx5e_init_rep_tx,
  	.cleanup_tx		= mlx5e_cleanup_rep_tx,
++<<<<<<< HEAD
 +	.enable		        = mlx5e_vf_rep_enable,
 +	.update_stats           = mlx5e_vf_rep_update_hw_counters,
 +	.rx_handlers.handle_rx_cqe       = mlx5e_handle_rx_cqe_rep,
 +	.rx_handlers.handle_rx_cqe_mpwqe = mlx5e_handle_rx_cqe_mpwrq,
 +	.max_tc			= 1,
++=======
+ 	.enable		        = mlx5e_rep_enable,
+ 	.update_rx		= mlx5e_update_rep_rx,
+ 	.update_stats           = mlx5e_update_ndo_stats,
+ 	.rx_handlers.handle_rx_cqe       = mlx5e_handle_rx_cqe_rep,
+ 	.rx_handlers.handle_rx_cqe_mpwqe = mlx5e_handle_rx_cqe_mpwrq,
+ 	.max_tc			= 1,
+ 	.rq_groups		= MLX5E_NUM_RQ_GROUPS(REGULAR),
+ 	.stats_grps		= mlx5e_rep_stats_grps,
+ 	.stats_grps_num		= mlx5e_rep_stats_grps_num,
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  };
  
  static const struct mlx5e_profile mlx5e_uplink_rep_profile = {
@@@ -1779,13 -1927,75 +1887,24 @@@
  	.cleanup_tx		= mlx5e_cleanup_rep_tx,
  	.enable		        = mlx5e_uplink_rep_enable,
  	.disable	        = mlx5e_uplink_rep_disable,
++<<<<<<< HEAD
 +	.update_stats           = mlx5e_uplink_rep_update_hw_counters,
++=======
+ 	.update_rx		= mlx5e_update_rep_rx,
+ 	.update_stats           = mlx5e_update_ndo_stats,
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  	.update_carrier	        = mlx5e_update_carrier,
  	.rx_handlers.handle_rx_cqe       = mlx5e_handle_rx_cqe_rep,
  	.rx_handlers.handle_rx_cqe_mpwqe = mlx5e_handle_rx_cqe_mpwrq,
  	.max_tc			= MLX5E_MAX_NUM_TC,
++<<<<<<< HEAD
++=======
+ 	.rq_groups		= MLX5E_NUM_RQ_GROUPS(REGULAR),
+ 	.stats_grps		= mlx5e_ul_rep_stats_grps,
+ 	.stats_grps_num		= mlx5e_ul_rep_stats_grps_num,
++>>>>>>> 8a236b15144b (net/mlx5e: Convert rep stats to mlx5e_stats_grp-based infra)
  };
  
 -static bool
 -is_devlink_port_supported(const struct mlx5_core_dev *dev,
 -			  const struct mlx5e_rep_priv *rpriv)
 -{
 -	return rpriv->rep->vport == MLX5_VPORT_UPLINK ||
 -	       rpriv->rep->vport == MLX5_VPORT_PF ||
 -	       mlx5_eswitch_is_vf_vport(dev->priv.eswitch, rpriv->rep->vport);
 -}
 -
 -static unsigned int
 -vport_to_devlink_port_index(const struct mlx5_core_dev *dev, u16 vport_num)
 -{
 -	return (MLX5_CAP_GEN(dev, vhca_id) << 16) | vport_num;
 -}
 -
 -static int register_devlink_port(struct mlx5_core_dev *dev,
 -				 struct mlx5e_rep_priv *rpriv)
 -{
 -	struct devlink *devlink = priv_to_devlink(dev);
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
 -	struct netdev_phys_item_id ppid = {};
 -	unsigned int dl_port_index = 0;
 -
 -	if (!is_devlink_port_supported(dev, rpriv))
 -		return 0;
 -
 -	mlx5e_rep_get_port_parent_id(rpriv->netdev, &ppid);
 -
 -	if (rep->vport == MLX5_VPORT_UPLINK) {
 -		devlink_port_attrs_set(&rpriv->dl_port,
 -				       DEVLINK_PORT_FLAVOUR_PHYSICAL,
 -				       PCI_FUNC(dev->pdev->devfn), false, 0,
 -				       &ppid.id[0], ppid.id_len);
 -		dl_port_index = vport_to_devlink_port_index(dev, rep->vport);
 -	} else if (rep->vport == MLX5_VPORT_PF) {
 -		devlink_port_attrs_pci_pf_set(&rpriv->dl_port,
 -					      &ppid.id[0], ppid.id_len,
 -					      dev->pdev->devfn);
 -		dl_port_index = rep->vport;
 -	} else if (mlx5_eswitch_is_vf_vport(dev->priv.eswitch,
 -					    rpriv->rep->vport)) {
 -		devlink_port_attrs_pci_vf_set(&rpriv->dl_port,
 -					      &ppid.id[0], ppid.id_len,
 -					      dev->pdev->devfn,
 -					      rep->vport - 1);
 -		dl_port_index = vport_to_devlink_port_index(dev, rep->vport);
 -	}
 -
 -	return devlink_port_register(devlink, &rpriv->dl_port, dl_port_index);
 -}
 -
 -static void unregister_devlink_port(struct mlx5_core_dev *dev,
 -				    struct mlx5e_rep_priv *rpriv)
 -{
 -	if (is_devlink_port_supported(dev, rpriv))
 -		devlink_port_unregister(&rpriv->dl_port);
 -}
 -
  /* e-Switch vport representors */
  static int
  mlx5e_vport_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
