bnxt_en: Add support for PCIe statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Vasundhara Volam <vasundhara-v.volam@broadcom.com>
commit 55e4398d4ee578094fb38f25af175629a24675d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/55e4398d.failed

Gather periodic PCIe statistics for ethtool -S.

	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 55e4398d4ee578094fb38f25af175629a24675d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index ba84c87ec7b3,b7a600564a16..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -3446,56 -3446,66 +3452,78 @@@ static int bnxt_alloc_stats(struct bnx
  		cpr->hw_stats_ctx_id = INVALID_STATS_CTX_ID;
  	}
  
 -	if (BNXT_VF(bp) || bp->chip_num == CHIP_NUM_58700)
 -		return 0;
 -
 -	if (bp->hw_rx_port_stats)
 -		goto alloc_ext_stats;
 +	if (BNXT_PF(bp) && bp->chip_num != CHIP_NUM_58700) {
 +		if (bp->hw_rx_port_stats)
 +			goto alloc_ext_stats;
  
 -	bp->hw_port_stats_size = sizeof(struct rx_port_stats) +
 -				 sizeof(struct tx_port_stats) + 1024;
 +		bp->hw_port_stats_size = sizeof(struct rx_port_stats) +
 +					 sizeof(struct tx_port_stats) + 1024;
  
 -	bp->hw_rx_port_stats =
 -		dma_alloc_coherent(&pdev->dev, bp->hw_port_stats_size,
 -				   &bp->hw_rx_port_stats_map,
 -				   GFP_KERNEL);
 -	if (!bp->hw_rx_port_stats)
 -		return -ENOMEM;
 +		bp->hw_rx_port_stats =
 +			dma_alloc_coherent(&pdev->dev, bp->hw_port_stats_size,
 +					   &bp->hw_rx_port_stats_map,
 +					   GFP_KERNEL);
 +		if (!bp->hw_rx_port_stats)
 +			return -ENOMEM;
  
 -	bp->hw_tx_port_stats = (void *)(bp->hw_rx_port_stats + 1) + 512;
 -	bp->hw_tx_port_stats_map = bp->hw_rx_port_stats_map +
 -				   sizeof(struct rx_port_stats) + 512;
 -	bp->flags |= BNXT_FLAG_PORT_STATS;
 +		bp->hw_tx_port_stats = (void *)(bp->hw_rx_port_stats + 1) +
 +				       512;
 +		bp->hw_tx_port_stats_map = bp->hw_rx_port_stats_map +
 +					   sizeof(struct rx_port_stats) + 512;
 +		bp->flags |= BNXT_FLAG_PORT_STATS;
  
  alloc_ext_stats:
 -	/* Display extended statistics only if FW supports it */
 -	if (bp->hwrm_spec_code < 0x10804 || bp->hwrm_spec_code == 0x10900)
 -		return 0;
 +		/* Display extended statistics only if FW supports it */
 +		if (bp->hwrm_spec_code < 0x10804 ||
 +		    bp->hwrm_spec_code == 0x10900)
 +			return 0;
  
 -	if (bp->hw_rx_port_stats_ext)
 -		goto alloc_tx_ext_stats;
 +		if (bp->hw_rx_port_stats_ext)
 +			goto alloc_tx_ext_stats;
  
 -	bp->hw_rx_port_stats_ext =
 -		dma_alloc_coherent(&pdev->dev, sizeof(struct rx_port_stats_ext),
 -				   &bp->hw_rx_port_stats_ext_map, GFP_KERNEL);
 -	if (!bp->hw_rx_port_stats_ext)
 -		return 0;
 +		bp->hw_rx_port_stats_ext =
 +			dma_zalloc_coherent(&pdev->dev,
 +					    sizeof(struct rx_port_stats_ext),
 +					    &bp->hw_rx_port_stats_ext_map,
 +					    GFP_KERNEL);
 +		if (!bp->hw_rx_port_stats_ext)
 +			return 0;
  
  alloc_tx_ext_stats:
++<<<<<<< HEAD
 +		if (bp->hw_tx_port_stats_ext)
 +			return 0;
++=======
+ 	if (bp->hw_tx_port_stats_ext)
+ 		goto alloc_pcie_stats;
++>>>>>>> 55e4398d4ee5 (bnxt_en: Add support for PCIe statistics)
  
 -	if (bp->hwrm_spec_code >= 0x10902) {
 -		bp->hw_tx_port_stats_ext =
 -			dma_alloc_coherent(&pdev->dev,
 -					   sizeof(struct tx_port_stats_ext),
 -					   &bp->hw_tx_port_stats_ext_map,
 -					   GFP_KERNEL);
 +		if (bp->hwrm_spec_code >= 0x10902) {
 +			bp->hw_tx_port_stats_ext =
 +				dma_zalloc_coherent(&pdev->dev,
 +					    sizeof(struct tx_port_stats_ext),
 +					    &bp->hw_tx_port_stats_ext_map,
 +					    GFP_KERNEL);
 +		}
 +		bp->flags |= BNXT_FLAG_PORT_STATS_EXT;
  	}
++<<<<<<< HEAD
++=======
+ 	bp->flags |= BNXT_FLAG_PORT_STATS_EXT;
+ 
+ alloc_pcie_stats:
+ 	if (bp->hw_pcie_stats ||
+ 	    !(bp->fw_cap & BNXT_FW_CAP_PCIE_STATS_SUPPORTED))
+ 		return 0;
+ 
+ 	bp->hw_pcie_stats =
+ 		dma_alloc_coherent(&pdev->dev, sizeof(struct pcie_ctx_hw_stats),
+ 				   &bp->hw_pcie_stats_map, GFP_KERNEL);
+ 	if (!bp->hw_pcie_stats)
+ 		return 0;
+ 
+ 	bp->flags |= BNXT_FLAG_PCIE_STATS;
++>>>>>>> 55e4398d4ee5 (bnxt_en: Add support for PCIe statistics)
  	return 0;
  }
  
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.h b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 61c1e7ccd7d0..0709cd266bb9 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -1355,6 +1355,7 @@ struct bnxt {
 	#define BNXT_FLAG_DIM		0x2000000
 	#define BNXT_FLAG_ROCE_MIRROR_CAP	0x4000000
 	#define BNXT_FLAG_PORT_STATS_EXT	0x10000000
+	#define BNXT_FLAG_PCIE_STATS	0x40000000
 
 	#define BNXT_FLAG_ALL_CONFIG_FEATS (BNXT_FLAG_TPA |		\
 					    BNXT_FLAG_RFS |		\
@@ -1482,6 +1483,7 @@ struct bnxt {
 	#define BNXT_FW_CAP_KONG_MB_CHNL		0x00000080
 	#define BNXT_FW_CAP_OVS_64BIT_HANDLE		0x00000400
 	#define BNXT_FW_CAP_TRUSTED_VF			0x00000800
+	#define BNXT_FW_CAP_PCIE_STATS_SUPPORTED	0x00020000
 
 #define BNXT_NEW_RM(bp)		((bp)->fw_cap & BNXT_FW_CAP_NEW_RM)
 	u32			hwrm_spec_code;
@@ -1500,10 +1502,12 @@ struct bnxt {
 	struct tx_port_stats	*hw_tx_port_stats;
 	struct rx_port_stats_ext	*hw_rx_port_stats_ext;
 	struct tx_port_stats_ext	*hw_tx_port_stats_ext;
+	struct pcie_ctx_hw_stats	*hw_pcie_stats;
 	dma_addr_t		hw_rx_port_stats_map;
 	dma_addr_t		hw_tx_port_stats_map;
 	dma_addr_t		hw_rx_port_stats_ext_map;
 	dma_addr_t		hw_tx_port_stats_ext_map;
+	dma_addr_t		hw_pcie_stats_map;
 	int			hw_port_stats_size;
 	u16			fw_rx_stats_ext_size;
 	u16			fw_tx_stats_ext_size;
@@ -1635,6 +1639,9 @@ struct bnxt {
 #define BNXT_TX_STATS_EXT_OFFSET(counter)		\
 	(offsetof(struct tx_port_stats_ext, counter) / 8)
 
+#define BNXT_PCIE_STATS_OFFSET(counter)			\
+	(offsetof(struct pcie_ctx_hw_stats, counter) / 8)
+
 #define I2C_DEV_ADDR_A0				0xa0
 #define I2C_DEV_ADDR_A2				0xa2
 #define SFF_DIAG_SUPPORT_OFFSET			0x5c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 03bc91698d86..520534b94122 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -235,6 +235,9 @@ static int bnxt_set_coalesce(struct net_device *dev,
 	BNXT_TX_STATS_PRI_ENTRY(counter, 6),		\
 	BNXT_TX_STATS_PRI_ENTRY(counter, 7)
 
+#define BNXT_PCIE_STATS_ENTRY(counter)	\
+	{ BNXT_PCIE_STATS_OFFSET(counter), __stringify(counter) }
+
 enum {
 	RX_TOTAL_DISCARDS,
 	TX_TOTAL_DISCARDS,
@@ -387,6 +390,24 @@ static const struct {
 	BNXT_TX_STATS_PRI_ENTRIES(tx_packets),
 };
 
+static const struct {
+	long offset;
+	char string[ETH_GSTRING_LEN];
+} bnxt_pcie_stats_arr[] = {
+	BNXT_PCIE_STATS_ENTRY(pcie_pl_signal_integrity),
+	BNXT_PCIE_STATS_ENTRY(pcie_dl_signal_integrity),
+	BNXT_PCIE_STATS_ENTRY(pcie_tl_signal_integrity),
+	BNXT_PCIE_STATS_ENTRY(pcie_link_integrity),
+	BNXT_PCIE_STATS_ENTRY(pcie_tx_traffic_rate),
+	BNXT_PCIE_STATS_ENTRY(pcie_rx_traffic_rate),
+	BNXT_PCIE_STATS_ENTRY(pcie_tx_dllp_statistics),
+	BNXT_PCIE_STATS_ENTRY(pcie_rx_dllp_statistics),
+	BNXT_PCIE_STATS_ENTRY(pcie_equalization_time),
+	BNXT_PCIE_STATS_ENTRY(pcie_ltssm_histogram[0]),
+	BNXT_PCIE_STATS_ENTRY(pcie_ltssm_histogram[2]),
+	BNXT_PCIE_STATS_ENTRY(pcie_recovery_histogram),
+};
+
 #define BNXT_NUM_SW_FUNC_STATS	ARRAY_SIZE(bnxt_sw_func_stats)
 #define BNXT_NUM_PORT_STATS ARRAY_SIZE(bnxt_port_stats_arr)
 #define BNXT_NUM_STATS_PRI			\
@@ -394,6 +415,7 @@ static const struct {
 	 ARRAY_SIZE(bnxt_rx_pkts_pri_arr) +	\
 	 ARRAY_SIZE(bnxt_tx_bytes_pri_arr) +	\
 	 ARRAY_SIZE(bnxt_tx_pkts_pri_arr))
+#define BNXT_NUM_PCIE_STATS ARRAY_SIZE(bnxt_pcie_stats_arr)
 
 static int bnxt_get_num_stats(struct bnxt *bp)
 {
@@ -411,6 +433,9 @@ static int bnxt_get_num_stats(struct bnxt *bp)
 			num_stats += BNXT_NUM_STATS_PRI;
 	}
 
+	if (bp->flags & BNXT_FLAG_PCIE_STATS)
+		num_stats += BNXT_NUM_PCIE_STATS;
+
 	return num_stats;
 }
 
@@ -513,6 +538,14 @@ static void bnxt_get_ethtool_stats(struct net_device *dev,
 			}
 		}
 	}
+	if (bp->flags & BNXT_FLAG_PCIE_STATS) {
+		__le64 *pcie_stats = (__le64 *)bp->hw_pcie_stats;
+
+		for (i = 0; i < BNXT_NUM_PCIE_STATS; i++, j++) {
+			buf[j] = le64_to_cpu(*(pcie_stats +
+					       bnxt_pcie_stats_arr[i].offset));
+		}
+	}
 }
 
 static void bnxt_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
@@ -613,6 +646,12 @@ static void bnxt_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
 				}
 			}
 		}
+		if (bp->flags & BNXT_FLAG_PCIE_STATS) {
+			for (i = 0; i < BNXT_NUM_PCIE_STATS; i++) {
+				strcpy(buf, bnxt_pcie_stats_arr[i].string);
+				buf += ETH_GSTRING_LEN;
+			}
+		}
 		break;
 	case ETH_SS_TEST:
 		if (bp->num_tests)
