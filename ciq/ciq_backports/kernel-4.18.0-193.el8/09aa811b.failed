nfp: flower: remove offloaded MACs when reprs are applied to OvS bridges

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author John Hurley <john.hurley@netronome.com>
commit 09aa811bb7def147e230f53ed3c19ff1a54a1575
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/09aa811b.failed

MAC addresses along with an identifying index are offloaded to firmware to
allow tunnel decapsulation. If a tunnel packet arrives with a matching
destination MAC address and a verified index, it can continue on the
decapsulation process. This replicates the MAC verifications carried out
in the kernel network stack.

When a netdev is added to a bridge (e.g. OvS) then packets arriving on
that dev are directed through the bridge datapath instead of passing
through the network stack. Therefore, tunnelled packets matching the MAC
of that dev will not be decapped here.

Replicate this behaviour on firmware by removing offloaded MAC addresses
when a MAC representer is added to an OvS bridge. This can prevent any
false positive tunnel decaps.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 09aa811bb7def147e230f53ed3c19ff1a54a1575)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/main.h
diff --cc drivers/net/ethernet/netronome/nfp/flower/main.h
index cbede9cb0351,31d94592a7c0..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@@ -196,14 -218,20 +196,24 @@@ struct nfp_flower_priv 
   * @lag_port_flags:	Extended port flags to record lag state of repr
   * @mac_offloaded:	Flag indicating a MAC address is offloaded for repr
   * @offloaded_mac_addr:	MAC address that has been offloaded for repr
 - * @block_shared:	Flag indicating if offload applies to shared blocks
   * @mac_list:		List entry of reprs that share the same offloaded MAC
++<<<<<<< HEAD
++=======
+  * @qos_table:		Stored info on filters implementing qos
+  * @on_bridge:		Indicates if the repr is attached to a bridge
++>>>>>>> 09aa811bb7de (nfp: flower: remove offloaded MACs when reprs are applied to OvS bridges)
   */
  struct nfp_flower_repr_priv {
  	struct nfp_repr *nfp_repr;
  	unsigned long lag_port_flags;
  	bool mac_offloaded;
  	u8 offloaded_mac_addr[ETH_ALEN];
 -	bool block_shared;
  	struct list_head mac_list;
++<<<<<<< HEAD
++=======
+ 	struct nfp_fl_qos qos_table;
+ 	bool on_bridge;
++>>>>>>> 09aa811bb7de (nfp: flower: remove offloaded MACs when reprs are applied to OvS bridges)
  };
  
  /**
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.h
diff --git a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
index 353833ffcf69..17b722e49d8d 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
@@ -714,6 +714,9 @@ nfp_tunnel_offload_mac(struct nfp_app *app, struct net_device *netdev,
 			return 0;
 
 		repr_priv = repr->app_priv;
+		if (repr_priv->on_bridge)
+			return 0;
+
 		mac_offloaded = &repr_priv->mac_offloaded;
 		off_mac = &repr_priv->offloaded_mac_addr[0];
 		port = nfp_repr_get_port_id(netdev);
@@ -829,6 +832,45 @@ int nfp_tunnel_mac_event_handler(struct nfp_app *app,
 		if (err)
 			nfp_flower_cmsg_warn(app, "Failed to offload MAC change on %s.\n",
 					     netdev_name(netdev));
+	} else if (event == NETDEV_CHANGEUPPER) {
+		/* If a repr is attached to a bridge then tunnel packets
+		 * entering the physical port are directed through the bridge
+		 * datapath and cannot be directly detunneled. Therefore,
+		 * associated offloaded MACs and indexes should not be used
+		 * by fw for detunneling.
+		 */
+		struct netdev_notifier_changeupper_info *info = ptr;
+		struct net_device *upper = info->upper_dev;
+		struct nfp_flower_repr_priv *repr_priv;
+		struct nfp_repr *repr;
+
+		if (!nfp_netdev_is_nfp_repr(netdev) ||
+		    !nfp_flower_is_supported_bridge(upper))
+			return NOTIFY_OK;
+
+		repr = netdev_priv(netdev);
+		if (repr->app != app)
+			return NOTIFY_OK;
+
+		repr_priv = repr->app_priv;
+
+		if (info->linking) {
+			if (nfp_tunnel_offload_mac(app, netdev,
+						   NFP_TUNNEL_MAC_OFFLOAD_DEL))
+				nfp_flower_cmsg_warn(app, "Failed to delete offloaded MAC on %s.\n",
+						     netdev_name(netdev));
+			repr_priv->on_bridge = true;
+		} else {
+			repr_priv->on_bridge = false;
+
+			if (!(netdev->flags & IFF_UP))
+				return NOTIFY_OK;
+
+			if (nfp_tunnel_offload_mac(app, netdev,
+						   NFP_TUNNEL_MAC_OFFLOAD_ADD))
+				nfp_flower_cmsg_warn(app, "Failed to offload MAC on %s.\n",
+						     netdev_name(netdev));
+		}
 	}
 	return NOTIFY_OK;
 }
