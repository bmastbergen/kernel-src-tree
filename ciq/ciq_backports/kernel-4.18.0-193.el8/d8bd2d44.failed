Drivers: hv: vmbus: Resume after fixing up old primary channels

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [hv] hv: vmbus: Resume after fixing up old primary channels (Mohammed Gamal) [1774675]
Rebuild_FUZZ: 92.31%
commit-author Dexuan Cui <decui@microsoft.com>
commit d8bd2d442bb2688b428ac7164e5dc6d95d4fa65b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d8bd2d44.failed

When the host re-offers the primary channels upon resume, the host only
guarantees the Instance GUID  doesn't change, so vmbus_bus_suspend()
should invalidate channel->offermsg.child_relid and figure out the
number of primary channels that need to be fixed up upon resume.

Upon resume, vmbus_onoffer() finds the old channel structs, and maps
the new offers to the old channels, and fixes up the old structs,
and finally the resume callbacks of the VSC drivers will re-open
the channels.

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Sasha Levin <sashal@kernel.org>
(cherry picked from commit d8bd2d442bb2688b428ac7164e5dc6d95d4fa65b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
#	drivers/hv/connection.c
#	drivers/hv/hyperv_vmbus.h
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/channel_mgmt.c
index addcef50df7a,8eb167540b4f..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -847,6 -859,67 +855,36 @@@ void vmbus_initiate_unload(bool crash
  		vmbus_wait_for_unload();
  }
  
+ static void check_ready_for_resume_event(void)
+ {
+ 	/*
+ 	 * If all the old primary channels have been fixed up, then it's safe
+ 	 * to resume.
+ 	 */
+ 	if (atomic_dec_and_test(&vmbus_connection.nr_chan_fixup_on_resume))
+ 		complete(&vmbus_connection.ready_for_resume_event);
+ }
+ 
+ static void vmbus_setup_channel_state(struct vmbus_channel *channel,
+ 				      struct vmbus_channel_offer_channel *offer)
+ {
+ 	/*
+ 	 * Setup state for signalling the host.
+ 	 */
+ 	channel->sig_event = VMBUS_EVENT_CONNECTION_ID;
+ 
+ 	if (vmbus_proto_version != VERSION_WS2008) {
+ 		channel->is_dedicated_interrupt =
+ 				(offer->is_dedicated_interrupt != 0);
+ 		channel->sig_event = offer->connection_id;
+ 	}
+ 
+ 	memcpy(&channel->offermsg, offer,
+ 	       sizeof(struct vmbus_channel_offer_channel));
+ 	channel->monitor_grp = (u8)offer->monitorid / 32;
+ 	channel->monitor_bit = (u8)offer->monitorid % 32;
+ }
+ 
 -/*
 - * find_primary_channel_by_offer - Get the channel object given the new offer.
 - * This is only used in the resume path of hibernation.
 - */
 -static struct vmbus_channel *
 -find_primary_channel_by_offer(const struct vmbus_channel_offer_channel *offer)
 -{
 -	struct vmbus_channel *channel = NULL, *iter;
 -	const guid_t *inst1, *inst2;
 -
 -	/* Ignore sub-channel offers. */
 -	if (offer->offer.sub_channel_index != 0)
 -		return NULL;
 -
 -	mutex_lock(&vmbus_connection.channel_mutex);
 -
 -	list_for_each_entry(iter, &vmbus_connection.chn_list, listentry) {
 -		inst1 = &iter->offermsg.offer.if_instance;
 -		inst2 = &offer->offer.if_instance;
 -
 -		if (guid_equal(inst1, inst2)) {
 -			channel = iter;
 -			break;
 -		}
 -	}
 -
 -	mutex_unlock(&vmbus_connection.channel_mutex);
 -
 -	return channel;
 -}
 -
  /*
   * vmbus_onoffer - Handler for channel offers from vmbus in parent partition.
   *
@@@ -860,6 -934,51 +898,54 @@@ static void vmbus_onoffer(struct vmbus_
  
  	trace_vmbus_onoffer(offer);
  
++<<<<<<< HEAD
++=======
+ 	oldchannel = find_primary_channel_by_offer(offer);
+ 
+ 	if (oldchannel != NULL) {
+ 		atomic_dec(&vmbus_connection.offer_in_progress);
+ 
+ 		/*
+ 		 * We're resuming from hibernation: all the sub-channel and
+ 		 * hv_sock channels we had before the hibernation should have
+ 		 * been cleaned up, and now we must be seeing a re-offered
+ 		 * primary channel that we had before the hibernation.
+ 		 */
+ 
+ 		WARN_ON(oldchannel->offermsg.child_relid != INVALID_RELID);
+ 		/* Fix up the relid. */
+ 		oldchannel->offermsg.child_relid = offer->child_relid;
+ 
+ 		offer_sz = sizeof(*offer);
+ 		if (memcmp(offer, &oldchannel->offermsg, offer_sz) == 0) {
+ 			check_ready_for_resume_event();
+ 			return;
+ 		}
+ 
+ 		/*
+ 		 * This is not an error, since the host can also change the
+ 		 * other field(s) of the offer, e.g. on WS RS5 (Build 17763),
+ 		 * the offer->connection_id of the Mellanox VF vmbus device
+ 		 * can change when the host reoffers the device upon resume.
+ 		 */
+ 		pr_debug("vmbus offer changed: relid=%d\n",
+ 			 offer->child_relid);
+ 
+ 		print_hex_dump_debug("Old vmbus offer: ", DUMP_PREFIX_OFFSET,
+ 				     16, 4, &oldchannel->offermsg, offer_sz,
+ 				     false);
+ 		print_hex_dump_debug("New vmbus offer: ", DUMP_PREFIX_OFFSET,
+ 				     16, 4, offer, offer_sz, false);
+ 
+ 		/* Fix up the old channel. */
+ 		vmbus_setup_channel_state(oldchannel, offer);
+ 
+ 		check_ready_for_resume_event();
+ 
+ 		return;
+ 	}
+ 
++>>>>>>> d8bd2d442bb2 (Drivers: hv: vmbus: Resume after fixing up old primary channels)
  	/* Allocate the channel object and save this offer. */
  	newchannel = alloc_channel();
  	if (!newchannel) {
diff --cc drivers/hv/connection.c
index 09829e15d4a0,6e4c015783ff..000000000000
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@@ -26,6 -26,11 +26,14 @@@
  struct vmbus_connection vmbus_connection = {
  	.conn_state		= DISCONNECTED,
  	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
++<<<<<<< HEAD
++=======
+ 
+ 	.ready_for_suspend_event= COMPLETION_INITIALIZER(
+ 				  vmbus_connection.ready_for_suspend_event),
+ 	.ready_for_resume_event	= COMPLETION_INITIALIZER(
+ 				  vmbus_connection.ready_for_resume_event),
++>>>>>>> d8bd2d442bb2 (Drivers: hv: vmbus: Resume after fixing up old primary channels)
  };
  EXPORT_SYMBOL_GPL(vmbus_connection);
  
diff --cc drivers/hv/hyperv_vmbus.h
index 4ecd5e54d00e,f7a5f5615f34..000000000000
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@@ -259,6 -260,32 +259,35 @@@ struct vmbus_connection 
  	struct workqueue_struct *work_queue;
  	struct workqueue_struct *handle_primary_chan_wq;
  	struct workqueue_struct *handle_sub_chan_wq;
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * The number of sub-channels and hv_sock channels that should be
+ 	 * cleaned up upon suspend: sub-channels will be re-created upon
+ 	 * resume, and hv_sock channels should not survive suspend.
+ 	 */
+ 	atomic_t nr_chan_close_on_suspend;
+ 	/*
+ 	 * vmbus_bus_suspend() waits for "nr_chan_close_on_suspend" to
+ 	 * drop to zero.
+ 	 */
+ 	struct completion ready_for_suspend_event;
+ 
+ 	/*
+ 	 * The number of primary channels that should be "fixed up"
+ 	 * upon resume: these channels are re-offered upon resume, and some
+ 	 * fields of the channel offers (i.e. child_relid and connection_id)
+ 	 * can change, so the old offermsg must be fixed up, before the resume
+ 	 * callbacks of the VSC drivers start to further touch the channels.
+ 	 */
+ 	atomic_t nr_chan_fixup_on_resume;
+ 	/*
+ 	 * vmbus_bus_resume() waits for "nr_chan_fixup_on_resume" to
+ 	 * drop to zero.
+ 	 */
+ 	struct completion ready_for_resume_event;
++>>>>>>> d8bd2d442bb2 (Drivers: hv: vmbus: Resume after fixing up old primary channels)
  };
  
  
diff --cc drivers/hv/vmbus_drv.c
index f6112615450a,391f0b225c9a..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -2046,6 -2125,129 +2046,132 @@@ acpi_walk_err
  	return ret_val;
  }
  
++<<<<<<< HEAD
++=======
+ static int vmbus_bus_suspend(struct device *dev)
+ {
+ 	struct vmbus_channel *channel, *sc;
+ 	unsigned long flags;
+ 
+ 	while (atomic_read(&vmbus_connection.offer_in_progress) != 0) {
+ 		/*
+ 		 * We wait here until the completion of any channel
+ 		 * offers that are currently in progress.
+ 		 */
+ 		msleep(1);
+ 	}
+ 
+ 	mutex_lock(&vmbus_connection.channel_mutex);
+ 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
+ 		if (!is_hvsock_channel(channel))
+ 			continue;
+ 
+ 		vmbus_force_channel_rescinded(channel);
+ 	}
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 	/*
+ 	 * Wait until all the sub-channels and hv_sock channels have been
+ 	 * cleaned up. Sub-channels should be destroyed upon suspend, otherwise
+ 	 * they would conflict with the new sub-channels that will be created
+ 	 * in the resume path. hv_sock channels should also be destroyed, but
+ 	 * a hv_sock channel of an established hv_sock connection can not be
+ 	 * really destroyed since it may still be referenced by the userspace
+ 	 * application, so we just force the hv_sock channel to be rescinded
+ 	 * by vmbus_force_channel_rescinded(), and the userspace application
+ 	 * will thoroughly destroy the channel after hibernation.
+ 	 *
+ 	 * Note: the counter nr_chan_close_on_suspend may never go above 0 if
+ 	 * the VM has no sub-channel and hv_sock channel, e.g. a 1-vCPU VM.
+ 	 */
+ 	if (atomic_read(&vmbus_connection.nr_chan_close_on_suspend) > 0)
+ 		wait_for_completion(&vmbus_connection.ready_for_suspend_event);
+ 
+ 	WARN_ON(atomic_read(&vmbus_connection.nr_chan_fixup_on_resume) != 0);
+ 
+ 	mutex_lock(&vmbus_connection.channel_mutex);
+ 
+ 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
+ 		/*
+ 		 * Invalidate the field. Upon resume, vmbus_onoffer() will fix
+ 		 * up the field, and the other fields (if necessary).
+ 		 */
+ 		channel->offermsg.child_relid = INVALID_RELID;
+ 
+ 		if (is_hvsock_channel(channel)) {
+ 			if (!channel->rescind) {
+ 				pr_err("hv_sock channel not rescinded!\n");
+ 				WARN_ON_ONCE(1);
+ 			}
+ 			continue;
+ 		}
+ 
+ 		spin_lock_irqsave(&channel->lock, flags);
+ 		list_for_each_entry(sc, &channel->sc_list, sc_list) {
+ 			pr_err("Sub-channel not deleted!\n");
+ 			WARN_ON_ONCE(1);
+ 		}
+ 		spin_unlock_irqrestore(&channel->lock, flags);
+ 
+ 		atomic_inc(&vmbus_connection.nr_chan_fixup_on_resume);
+ 	}
+ 
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 	vmbus_initiate_unload(false);
+ 
+ 	vmbus_connection.conn_state = DISCONNECTED;
+ 
+ 	/* Reset the event for the next resume. */
+ 	reinit_completion(&vmbus_connection.ready_for_resume_event);
+ 
+ 	return 0;
+ }
+ 
+ static int vmbus_bus_resume(struct device *dev)
+ {
+ 	struct vmbus_channel_msginfo *msginfo;
+ 	size_t msgsize;
+ 	int ret;
+ 
+ 	/*
+ 	 * We only use the 'vmbus_proto_version', which was in use before
+ 	 * hibernation, to re-negotiate with the host.
+ 	 */
+ 	if (vmbus_proto_version == VERSION_INVAL ||
+ 	    vmbus_proto_version == 0) {
+ 		pr_err("Invalid proto version = 0x%x\n", vmbus_proto_version);
+ 		return -EINVAL;
+ 	}
+ 
+ 	msgsize = sizeof(*msginfo) +
+ 		  sizeof(struct vmbus_channel_initiate_contact);
+ 
+ 	msginfo = kzalloc(msgsize, GFP_KERNEL);
+ 
+ 	if (msginfo == NULL)
+ 		return -ENOMEM;
+ 
+ 	ret = vmbus_negotiate_version(msginfo, vmbus_proto_version);
+ 
+ 	kfree(msginfo);
+ 
+ 	if (ret != 0)
+ 		return ret;
+ 
+ 	WARN_ON(atomic_read(&vmbus_connection.nr_chan_fixup_on_resume) == 0);
+ 
+ 	vmbus_request_offers();
+ 
+ 	wait_for_completion(&vmbus_connection.ready_for_resume_event);
+ 
+ 	/* Reset the event for the next suspend. */
+ 	reinit_completion(&vmbus_connection.ready_for_suspend_event);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d8bd2d442bb2 (Drivers: hv: vmbus: Resume after fixing up old primary channels)
  static const struct acpi_device_id vmbus_acpi_device_ids[] = {
  	{"VMBUS", 0},
  	{"VMBus", 0},
* Unmerged path drivers/hv/channel_mgmt.c
* Unmerged path drivers/hv/connection.c
* Unmerged path drivers/hv/hyperv_vmbus.h
* Unmerged path drivers/hv/vmbus_drv.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2d39248cff96..0c9692ac625a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -426,6 +426,9 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_COUNT
 };
 
+/* Hyper-V supports about 2048 channels, and the RELIDs start with 1. */
+#define INVALID_RELID	U32_MAX
+
 struct vmbus_channel_message_header {
 	enum vmbus_channel_message_type msgtype;
 	u32 padding;
