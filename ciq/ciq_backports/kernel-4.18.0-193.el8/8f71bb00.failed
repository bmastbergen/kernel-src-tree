RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 8f71bb0030b8816f57be142f95b3c7189c6eaf4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/8f71bb00.failed

Update the struct ib_client for all modules exporting cdevs related to the
ibdevice to also implement RDMA_NLDEV_CMD_GET_CHARDEV. All cdevs are now
autoloadable and discoverable by userspace over netlink instead of relying
on sysfs.

uverbs also exposes the DRIVER_ID for drivers that are able to support
driver id binding in rdma-core.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 8f71bb0030b8816f57be142f95b3c7189c6eaf4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/device.c
#	drivers/infiniband/core/nldev.c
#	drivers/infiniband/hw/cxgb3/iwch_provider.c
#	drivers/infiniband/hw/hns/hns_roce_main.c
#	drivers/infiniband/hw/mthca/mthca_provider.c
#	include/rdma/ib_verbs.h
#	include/uapi/rdma/rdma_netlink.h
diff --cc drivers/infiniband/core/device.c
index ec96a7b1c811,1de4ae5d5e0e..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -1269,6 -2416,21 +1269,24 @@@ void ib_set_device_ops(struct ib_devic
  
  #define SET_OBJ_SIZE(ptr, name) SET_DEVICE_OP(ptr, size_##name)
  
++<<<<<<< HEAD
++=======
+ 	if (ops->driver_id != RDMA_DRIVER_UNKNOWN) {
+ 		WARN_ON(dev_ops->driver_id != RDMA_DRIVER_UNKNOWN &&
+ 			dev_ops->driver_id != ops->driver_id);
+ 		dev_ops->driver_id = ops->driver_id;
+ 	}
+ 	if (ops->owner) {
+ 		WARN_ON(dev_ops->owner && dev_ops->owner != ops->owner);
+ 		dev_ops->owner = ops->owner;
+ 	}
+ 	if (ops->uverbs_abi_ver)
+ 		dev_ops->uverbs_abi_ver = ops->uverbs_abi_ver;
+ 
+ 	dev_ops->uverbs_no_driver_id_binding |=
+ 		ops->uverbs_no_driver_id_binding;
+ 
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  	SET_DEVICE_OP(dev_ops, add_gid);
  	SET_DEVICE_OP(dev_ops, advise_mr);
  	SET_DEVICE_OP(dev_ops, alloc_dm);
diff --cc drivers/infiniband/core/nldev.c
index efccd8e0fb77,3cad72a609ff..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -107,6 -109,24 +107,27 @@@ static const struct nla_policy nldev_po
  	[RDMA_NLDEV_ATTR_DRIVER_U32]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_DRIVER_S64]		= { .type = NLA_S64 },
  	[RDMA_NLDEV_ATTR_DRIVER_U64]		= { .type = NLA_U64 },
++<<<<<<< HEAD
++=======
+ 	[RDMA_NLDEV_ATTR_RES_PDN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_CQN]               = { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_MRN]               = { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_CM_IDN]            = { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_CTXN]              = { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_LINK_TYPE]		= { .type = NLA_NUL_STRING,
+ 				    .len = RDMA_NLDEV_ATTR_ENTRY_STRLEN },
+ 	[RDMA_NLDEV_SYS_ATTR_NETNS_MODE]	= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_DEV_PROTOCOL]		= { .type = NLA_NUL_STRING,
+ 				    .len = RDMA_NLDEV_ATTR_ENTRY_STRLEN },
+ 	[RDMA_NLDEV_NET_NS_FD]			= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_CHARDEV]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_CHARDEV_ABI]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_CHARDEV_TYPE]		= { .type = NLA_NUL_STRING,
+ 				    .len = 128 },
+ 	[RDMA_NLDEV_ATTR_CHARDEV_NAME]		= { .type = NLA_NUL_STRING,
+ 				    .len = RDMA_NLDEV_ATTR_ENTRY_STRLEN },
+ 	[RDMA_NLDEV_ATTR_UVERBS_DRIVER_ID]	= { .type = NLA_U32 },
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  };
  
  static int put_driver_name_print_type(struct sk_buff *msg, const char *name,
diff --cc drivers/infiniband/hw/cxgb3/iwch_provider.c
index ba5689180499,810fa96af2e9..000000000000
--- a/drivers/infiniband/hw/cxgb3/iwch_provider.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_provider.c
@@@ -1316,6 -1227,11 +1316,14 @@@ static void get_dev_fw_ver_str(struct i
  }
  
  static const struct ib_device_ops iwch_dev_ops = {
++<<<<<<< HEAD
++=======
+ 	.owner = THIS_MODULE,
+ 	.driver_id = RDMA_DRIVER_CXGB3,
+ 	.uverbs_abi_ver = IWCH_UVERBS_ABI_VERSION,
+ 	.uverbs_no_driver_id_binding = 1,
+ 
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  	.alloc_hw_stats	= iwch_alloc_stats,
  	.alloc_mr = iwch_alloc_mr,
  	.alloc_mw = iwch_alloc_mw,
diff --cc drivers/infiniband/hw/hns/hns_roce_main.c
index e6509f248a6a,c0e819ed8c9b..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_main.c
+++ b/drivers/infiniband/hw/hns/hns_roce_main.c
@@@ -480,6 -414,11 +480,14 @@@ static void hns_roce_unregister_device(
  }
  
  static const struct ib_device_ops hns_roce_dev_ops = {
++<<<<<<< HEAD
++=======
+ 	.owner = THIS_MODULE,
+ 	.driver_id = RDMA_DRIVER_HNS,
+ 	.uverbs_abi_ver = 1,
+ 	.uverbs_no_driver_id_binding = 1,
+ 
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  	.add_gid = hns_roce_add_gid,
  	.alloc_pd = hns_roce_alloc_pd,
  	.alloc_ucontext = hns_roce_alloc_ucontext,
diff --cc drivers/infiniband/hw/mthca/mthca_provider.c
index f4ce72da939d,d97124bee703..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@@ -1194,6 -1144,11 +1194,14 @@@ static void get_dev_fw_str(struct ib_de
  }
  
  static const struct ib_device_ops mthca_dev_ops = {
++<<<<<<< HEAD
++=======
+ 	.owner = THIS_MODULE,
+ 	.driver_id = RDMA_DRIVER_MTHCA,
+ 	.uverbs_abi_ver = MTHCA_UVERBS_ABI_VERSION,
+ 	.uverbs_no_driver_id_binding = 1,
+ 
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  	.alloc_pd = mthca_alloc_pd,
  	.alloc_ucontext = mthca_alloc_ucontext,
  	.attach_mcast = mthca_multicast_attach,
diff --cc include/rdma/ib_verbs.h
index 5405a5f0fd95,6f09fcc21d7a..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2279,6 -2318,11 +2279,14 @@@ struct uverbs_attr_bundle
   * need to define the supported operations, otherwise they will be set to null.
   */
  struct ib_device_ops {
++<<<<<<< HEAD
++=======
+ 	struct module *owner;
+ 	enum rdma_driver_id driver_id;
+ 	u32 uverbs_abi_ver;
+ 	unsigned int uverbs_no_driver_id_binding:1;
+ 
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  	int (*post_send)(struct ib_qp *qp, const struct ib_send_wr *send_wr,
  			 const struct ib_send_wr **bad_send_wr);
  	int (*post_recv)(struct ib_qp *qp, const struct ib_recv_wr *recv_wr,
diff --cc include/uapi/rdma/rdma_netlink.h
index 213452ef94a5,b27c02185dcc..000000000000
--- a/include/uapi/rdma/rdma_netlink.h
+++ b/include/uapi/rdma/rdma_netlink.h
@@@ -458,6 -465,48 +458,51 @@@ enum rdma_nldev_attr 
  	RDMA_NLDEV_ATTR_DRIVER_U64,		/* u64 */
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * Indexes to get/set secific entry,
+ 	 * for QP use RDMA_NLDEV_ATTR_RES_LQPN
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_PDN,               /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_CQN,               /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_MRN,               /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_CM_IDN,            /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_CTXN,	       /* u32 */
+ 	/*
+ 	 * Identifies the rdma driver. eg: "rxe" or "siw"
+ 	 */
+ 	RDMA_NLDEV_ATTR_LINK_TYPE,		/* string */
+ 
+ 	/*
+ 	 * net namespace mode for rdma subsystem:
+ 	 * either shared or exclusive among multiple net namespaces.
+ 	 */
+ 	RDMA_NLDEV_SYS_ATTR_NETNS_MODE,		/* u8 */
+ 	/*
+ 	 * Device protocol, e.g. ib, iw, usnic, roce and opa
+ 	 */
+ 	RDMA_NLDEV_ATTR_DEV_PROTOCOL,		/* string */
+ 
+ 	/*
+ 	 * File descriptor handle of the net namespace object
+ 	 */
+ 	RDMA_NLDEV_NET_NS_FD,			/* u32 */
+ 
+ 	/*
+ 	 * Information about a chardev.
+ 	 * CHARDEV_TYPE is the name of the chardev ABI (ie uverbs, umad, etc)
+ 	 * CHARDEV_ABI signals the ABI revision (historical)
+ 	 * CHARDEV_NAME is the kernel name for the /dev/ file (no directory)
+ 	 * CHARDEV is the 64 bit dev_t for the inode
+ 	 */
+ 	RDMA_NLDEV_ATTR_CHARDEV_TYPE,		/* string */
+ 	RDMA_NLDEV_ATTR_CHARDEV_NAME,		/* string */
+ 	RDMA_NLDEV_ATTR_CHARDEV_ABI,		/* u64 */
+ 	RDMA_NLDEV_ATTR_CHARDEV,		/* u64 */
+ 	RDMA_NLDEV_ATTR_UVERBS_DRIVER_ID,       /* u64 */
+ 
+ 	/*
++>>>>>>> 8f71bb0030b8 (RDMA: Report available cdevs through RDMA_NLDEV_CMD_GET_CHARDEV)
  	 * Always the end
  	 */
  	RDMA_NLDEV_ATTR_MAX
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path drivers/infiniband/core/nldev.c
diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c
index 407a9ac8007a..97850a6a0fae 100644
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -52,6 +52,8 @@
 #include <rdma/rdma_cm_ib.h>
 #include <rdma/ib_addr.h>
 #include <rdma/ib.h>
+#include <rdma/rdma_netlink.h>
+#include "core_priv.h"
 
 MODULE_AUTHOR("Sean Hefty");
 MODULE_DESCRIPTION("RDMA Userspace Connection Manager Access");
@@ -1788,6 +1790,19 @@ static struct miscdevice ucma_misc = {
 	.fops		= &ucma_fops,
 };
 
+static int ucma_get_global_nl_info(struct ib_client_nl_info *res)
+{
+	res->abi = RDMA_USER_CM_ABI_VERSION;
+	res->cdev = ucma_misc.this_device;
+	return 0;
+}
+
+static struct ib_client rdma_cma_client = {
+	.name = "rdma_cm",
+	.get_global_nl_info = ucma_get_global_nl_info,
+};
+MODULE_ALIAS_RDMA_CLIENT("rdma_cm");
+
 static ssize_t show_abi_version(struct device *dev,
 				struct device_attribute *attr,
 				char *buf)
@@ -1816,7 +1831,14 @@ static int __init ucma_init(void)
 		ret = -ENOMEM;
 		goto err2;
 	}
+
+	ret = ib_register_client(&rdma_cma_client);
+	if (ret)
+		goto err3;
+
 	return 0;
+err3:
+	unregister_net_sysctl_table(ucma_ctl_table_hdr);
 err2:
 	device_remove_file(ucma_misc.this_device, &dev_attr_abi_version);
 err1:
@@ -1826,6 +1848,7 @@ static int __init ucma_init(void)
 
 static void __exit ucma_cleanup(void)
 {
+	ib_unregister_client(&rdma_cma_client);
 	unregister_net_sysctl_table(ucma_ctl_table_hdr);
 	device_remove_file(ucma_misc.this_device, &dev_attr_abi_version);
 	misc_deregister(&ucma_misc);
diff --git a/drivers/infiniband/core/user_mad.c b/drivers/infiniband/core/user_mad.c
index 5c3369895f8c..53d720854290 100644
--- a/drivers/infiniband/core/user_mad.c
+++ b/drivers/infiniband/core/user_mad.c
@@ -54,6 +54,7 @@
 
 #include <rdma/ib_mad.h>
 #include <rdma/ib_user_mad.h>
+#include <rdma/rdma_netlink.h>
 
 #include "core_priv.h"
 
@@ -1114,11 +1115,48 @@ static const struct file_operations umad_sm_fops = {
 	.llseek	 = no_llseek,
 };
 
+static int ib_umad_get_nl_info(struct ib_device *ibdev, void *client_data,
+			       struct ib_client_nl_info *res)
+{
+	struct ib_umad_device *umad_dev = client_data;
+
+	if (!rdma_is_port_valid(ibdev, res->port))
+		return -EINVAL;
+
+	res->abi = IB_USER_MAD_ABI_VERSION;
+	res->cdev = &umad_dev->ports[res->port - rdma_start_port(ibdev)].dev;
+
+	return 0;
+}
+
 static struct ib_client umad_client = {
 	.name   = "umad",
 	.add    = ib_umad_add_one,
-	.remove = ib_umad_remove_one
+	.remove = ib_umad_remove_one,
+	.get_nl_info = ib_umad_get_nl_info,
 };
+MODULE_ALIAS_RDMA_CLIENT("umad");
+
+static int ib_issm_get_nl_info(struct ib_device *ibdev, void *client_data,
+			       struct ib_client_nl_info *res)
+{
+	struct ib_umad_device *umad_dev =
+		ib_get_client_data(ibdev, &umad_client);
+
+	if (!rdma_is_port_valid(ibdev, res->port))
+		return -EINVAL;
+
+	res->abi = IB_USER_MAD_ABI_VERSION;
+	res->cdev = &umad_dev->ports[res->port - rdma_start_port(ibdev)].sm_dev;
+
+	return 0;
+}
+
+static struct ib_client issm_client = {
+	.name = "issm",
+	.get_nl_info = ib_issm_get_nl_info,
+};
+MODULE_ALIAS_RDMA_CLIENT("issm");
 
 static ssize_t ibdev_show(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -1376,13 +1414,17 @@ static int __init ib_umad_init(void)
 	}
 
 	ret = ib_register_client(&umad_client);
-	if (ret) {
-		pr_err("couldn't register ib_umad client\n");
+	if (ret)
 		goto out_class;
-	}
+
+	ret = ib_register_client(&issm_client);
+	if (ret)
+		goto out_client;
 
 	return 0;
 
+out_client:
+	ib_unregister_client(&umad_client);
 out_class:
 	class_unregister(&umad_class);
 
@@ -1400,6 +1442,7 @@ static int __init ib_umad_init(void)
 
 static void __exit ib_umad_cleanup(void)
 {
+	ib_unregister_client(&issm_client);
 	ib_unregister_client(&umad_client);
 	class_unregister(&umad_class);
 	unregister_chrdev_region(base_umad_dev,
diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c
index 38520b130ead..80faed404061 100644
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@ -51,6 +51,7 @@
 
 #include <rdma/ib.h>
 #include <rdma/uverbs_std_types.h>
+#include <rdma/rdma_netlink.h>
 
 #include "uverbs.h"
 #include "core_priv.h"
@@ -1142,12 +1143,41 @@ static const struct file_operations uverbs_mmap_fops = {
 	.compat_ioctl = ib_uverbs_ioctl,
 };
 
+static int ib_uverbs_get_nl_info(struct ib_device *ibdev, void *client_data,
+				 struct ib_client_nl_info *res)
+{
+	struct ib_uverbs_device *uverbs_dev = client_data;
+	int ret;
+
+	if (res->port != -1)
+		return -EINVAL;
+
+	res->abi = ibdev->ops.uverbs_abi_ver;
+	res->cdev = &uverbs_dev->dev;
+
+	/*
+	 * To support DRIVER_ID binding in userspace some of the driver need
+	 * upgrading to expose their PCI dependent revision information
+	 * through get_context instead of relying on modalias matching. When
+	 * the drivers are fixed they can drop this flag.
+	 */
+	if (!ibdev->ops.uverbs_no_driver_id_binding) {
+		ret = nla_put_u32(res->nl_msg, RDMA_NLDEV_ATTR_UVERBS_DRIVER_ID,
+				  ibdev->ops.driver_id);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
 static struct ib_client uverbs_client = {
 	.name   = "uverbs",
 	.no_kverbs_req = true,
 	.add    = ib_uverbs_add_one,
-	.remove = ib_uverbs_remove_one
+	.remove = ib_uverbs_remove_one,
+	.get_nl_info = ib_uverbs_get_nl_info,
 };
+MODULE_ALIAS_RDMA_CLIENT("uverbs");
 
 static ssize_t ibdev_show(struct device *device, struct device_attribute *attr,
 			  char *buf)
* Unmerged path drivers/infiniband/hw/cxgb3/iwch_provider.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_main.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_provider.c
* Unmerged path include/rdma/ib_verbs.h
* Unmerged path include/uapi/rdma/rdma_netlink.h
