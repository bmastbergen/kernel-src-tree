iommu/vt-d: Aux-domain specific domain attach/detach

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [iommu] vt-d: Aux-domain specific domain attach/detach (Jerry Snitselaar) [1742234]
Rebuild_FUZZ: 93.88%
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 67b8e02b5e76159a4f94f85bee370af1d9f442f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/67b8e02b.failed

When multiple domains per device has been enabled by the
device driver, the device will tag the default PASID for
the domain to all DMA traffics out of the subset of this
device; and the IOMMU should translate the DMA requests
in PASID granularity.

This adds the intel_iommu_aux_attach/detach_device() ops
to support managing PASID granular translation structures
when the device driver has enabled multiple domains per
device.

	Cc: Ashok Raj <ashok.raj@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: Kevin Tian <kevin.tian@intel.com>
	Signed-off-by: Sanjay Kumar <sanjay.k.kumar@intel.com>
	Signed-off-by: Liu Yi L <yi.l.liu@intel.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 67b8e02b5e76159a4f94f85bee370af1d9f442f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 940779fd0ec3,28a998afaf74..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -5014,8 -5067,133 +5015,138 @@@ static void intel_iommu_domain_free(str
  	domain_exit(to_dmar_domain(domain));
  }
  
++<<<<<<< HEAD
 +static int intel_iommu_attach_device(struct iommu_domain *domain,
 +				     struct device *dev)
++=======
+ /*
+  * Check whether a @domain could be attached to the @dev through the
+  * aux-domain attach/detach APIs.
+  */
+ static inline bool
+ is_aux_domain(struct device *dev, struct iommu_domain *domain)
+ {
+ 	struct device_domain_info *info = dev->archdata.iommu;
+ 
+ 	return info && info->auxd_enabled &&
+ 			domain->type == IOMMU_DOMAIN_UNMANAGED;
+ }
+ 
+ static void auxiliary_link_device(struct dmar_domain *domain,
+ 				  struct device *dev)
+ {
+ 	struct device_domain_info *info = dev->archdata.iommu;
+ 
+ 	assert_spin_locked(&device_domain_lock);
+ 	if (WARN_ON(!info))
+ 		return;
+ 
+ 	domain->auxd_refcnt++;
+ 	list_add(&domain->auxd, &info->auxiliary_domains);
+ }
+ 
+ static void auxiliary_unlink_device(struct dmar_domain *domain,
+ 				    struct device *dev)
+ {
+ 	struct device_domain_info *info = dev->archdata.iommu;
+ 
+ 	assert_spin_locked(&device_domain_lock);
+ 	if (WARN_ON(!info))
+ 		return;
+ 
+ 	list_del(&domain->auxd);
+ 	domain->auxd_refcnt--;
+ 
+ 	if (!domain->auxd_refcnt && domain->default_pasid > 0)
+ 		intel_pasid_free_id(domain->default_pasid);
+ }
+ 
+ static int aux_domain_add_dev(struct dmar_domain *domain,
+ 			      struct device *dev)
+ {
+ 	int ret;
+ 	u8 bus, devfn;
+ 	unsigned long flags;
+ 	struct intel_iommu *iommu;
+ 
+ 	iommu = device_to_iommu(dev, &bus, &devfn);
+ 	if (!iommu)
+ 		return -ENODEV;
+ 
+ 	if (domain->default_pasid <= 0) {
+ 		int pasid;
+ 
+ 		pasid = intel_pasid_alloc_id(domain, PASID_MIN,
+ 					     pci_max_pasids(to_pci_dev(dev)),
+ 					     GFP_KERNEL);
+ 		if (pasid <= 0) {
+ 			pr_err("Can't allocate default pasid\n");
+ 			return -ENODEV;
+ 		}
+ 		domain->default_pasid = pasid;
+ 	}
+ 
+ 	spin_lock_irqsave(&device_domain_lock, flags);
+ 	/*
+ 	 * iommu->lock must be held to attach domain to iommu and setup the
+ 	 * pasid entry for second level translation.
+ 	 */
+ 	spin_lock(&iommu->lock);
+ 	ret = domain_attach_iommu(domain, iommu);
+ 	if (ret)
+ 		goto attach_failed;
+ 
+ 	/* Setup the PASID entry for mediated devices: */
+ 	ret = intel_pasid_setup_second_level(iommu, domain, dev,
+ 					     domain->default_pasid);
+ 	if (ret)
+ 		goto table_failed;
+ 	spin_unlock(&iommu->lock);
+ 
+ 	auxiliary_link_device(domain, dev);
+ 
+ 	spin_unlock_irqrestore(&device_domain_lock, flags);
+ 
+ 	return 0;
+ 
+ table_failed:
+ 	domain_detach_iommu(domain, iommu);
+ attach_failed:
+ 	spin_unlock(&iommu->lock);
+ 	spin_unlock_irqrestore(&device_domain_lock, flags);
+ 	if (!domain->auxd_refcnt && domain->default_pasid > 0)
+ 		intel_pasid_free_id(domain->default_pasid);
+ 
+ 	return ret;
+ }
+ 
+ static void aux_domain_remove_dev(struct dmar_domain *domain,
+ 				  struct device *dev)
+ {
+ 	struct device_domain_info *info;
+ 	struct intel_iommu *iommu;
+ 	unsigned long flags;
+ 
+ 	if (!is_aux_domain(dev, &domain->domain))
+ 		return;
+ 
+ 	spin_lock_irqsave(&device_domain_lock, flags);
+ 	info = dev->archdata.iommu;
+ 	iommu = info->iommu;
+ 
+ 	auxiliary_unlink_device(domain, dev);
+ 
+ 	spin_lock(&iommu->lock);
+ 	intel_pasid_tear_down_entry(iommu, dev, domain->default_pasid);
+ 	domain_detach_iommu(domain, iommu);
+ 	spin_unlock(&iommu->lock);
+ 
+ 	spin_unlock_irqrestore(&device_domain_lock, flags);
+ }
+ 
+ static int prepare_domain_attach_device(struct iommu_domain *domain,
+ 					struct device *dev)
++>>>>>>> 67b8e02b5e76 (iommu/vt-d: Aux-domain specific domain attach/detach)
  {
  	struct dmar_domain *dmar_domain = to_dmar_domain(domain);
  	struct intel_iommu *iommu;
@@@ -5075,15 -5232,72 +5206,76 @@@
  		dmar_domain->agaw--;
  	}
  
++<<<<<<< HEAD
 +	return domain_add_dev_info(dmar_domain, dev);
++=======
+ 	return 0;
+ }
+ 
+ static int intel_iommu_attach_device(struct iommu_domain *domain,
+ 				     struct device *dev)
+ {
+ 	int ret;
+ 
+ 	if (device_is_rmrr_locked(dev)) {
+ 		dev_warn(dev, "Device is ineligible for IOMMU domain attach due to platform RMRR requirement.  Contact your platform vendor.\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	if (is_aux_domain(dev, domain))
+ 		return -EPERM;
+ 
+ 	/* normally dev is not mapped */
+ 	if (unlikely(domain_context_mapped(dev))) {
+ 		struct dmar_domain *old_domain;
+ 
+ 		old_domain = find_domain(dev);
+ 		if (old_domain) {
+ 			rcu_read_lock();
+ 			dmar_remove_one_dev_info(dev);
+ 			rcu_read_unlock();
+ 
+ 			if (!domain_type_is_vm_or_si(old_domain) &&
+ 			    list_empty(&old_domain->devices))
+ 				domain_exit(old_domain);
+ 		}
+ 	}
+ 
+ 	ret = prepare_domain_attach_device(domain, dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return domain_add_dev_info(to_dmar_domain(domain), dev);
++>>>>>>> 67b8e02b5e76 (iommu/vt-d: Aux-domain specific domain attach/detach)
+ }
+ 
+ static int intel_iommu_aux_attach_device(struct iommu_domain *domain,
+ 					 struct device *dev)
+ {
+ 	int ret;
+ 
+ 	if (!is_aux_domain(dev, domain))
+ 		return -EPERM;
+ 
+ 	ret = prepare_domain_attach_device(domain, dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return aux_domain_add_dev(to_dmar_domain(domain), dev);
  }
  
  static void intel_iommu_detach_device(struct iommu_domain *domain,
  				      struct device *dev)
  {
 -	dmar_remove_one_dev_info(dev);
 +	dmar_remove_one_dev_info(to_dmar_domain(domain), dev);
  }
  
+ static void intel_iommu_aux_detach_device(struct iommu_domain *domain,
+ 					  struct device *dev)
+ {
+ 	aux_domain_remove_dev(to_dmar_domain(domain), dev);
+ }
+ 
  static int intel_iommu_map(struct iommu_domain *domain,
  			   unsigned long iova, phys_addr_t hpa,
  			   size_t size, int iommu_prot)
* Unmerged path drivers/iommu/intel-iommu.c
diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h
index 8d42a6ffd805..f37650545579 100644
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@ -468,9 +468,11 @@ struct dmar_domain {
 					/* Domain ids per IOMMU. Use u16 since
 					 * domain ids are 16 bit wide according
 					 * to VT-d spec, section 9.3 */
+	unsigned int	auxd_refcnt;	/* Refcount of auxiliary attaching */
 
 	bool has_iotlb_device;
 	struct list_head devices;	/* all devices' list */
+	struct list_head auxd;		/* link to device's auxiliary list */
 	struct iova_domain iovad;	/* iova's that belong to this domain */
 
 	struct dma_pte	*pgd;		/* virtual address */
@@ -489,6 +491,11 @@ struct dmar_domain {
 					   2 == 1GiB, 3 == 512GiB, 4 == 1TiB */
 	u64		max_addr;	/* maximum mapped address */
 
+	int		default_pasid;	/*
+					 * The default pasid used for non-SVM
+					 * traffic on mediated devices.
+					 */
+
 	struct iommu_domain domain;	/* generic domain data structure for
 					   iommu core */
 };
@@ -545,6 +552,9 @@ struct device_domain_info {
 	struct list_head link;	/* link to domain siblings */
 	struct list_head global; /* link to global list */
 	struct list_head table;	/* link to pasid table */
+	struct list_head auxiliary_domains; /* auxiliary domains
+					     * attached to this device
+					     */
 	u8 bus;			/* PCI bus number */
 	u8 devfn;		/* PCI devfn number */
 	u16 pfsid;		/* SRIOV physical function source ID */
