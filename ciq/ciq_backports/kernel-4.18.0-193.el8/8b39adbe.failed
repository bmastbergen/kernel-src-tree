locking/lockdep: Make lockdep_unregister_key() honor 'debug_locks' again

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit 8b39adbee805c539a461dbf208b125b096152b1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/8b39adbe.failed

If lockdep_register_key() and lockdep_unregister_key() are called with
debug_locks == false then the following warning is reported:

  WARNING: CPU: 2 PID: 15145 at kernel/locking/lockdep.c:4920 lockdep_unregister_key+0x1ad/0x240

That warning is reported because lockdep_unregister_key() ignores the
value of 'debug_locks' and because the behavior of lockdep_register_key()
depends on whether or not 'debug_locks' is set. Fix this inconsistency
by making lockdep_unregister_key() take 'debug_locks' again into
account.

	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: shenghui <shhuiw@foxmail.com>
Fixes: 90c1cba2b3b3 ("locking/lockdep: Zap lock classes even with lock debugging disabled")
Link: http://lkml.kernel.org/r/20190415170538.23491-1-bvanassche@acm.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8b39adbee805c539a461dbf208b125b096152b1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/lockdep.c
diff --cc kernel/locking/lockdep.c
index aed5c03ce876,e221be724fe8..000000000000
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@@ -4310,17 -4850,87 +4310,36 @@@ void lockdep_reset_lock(struct lockdep_
  	unsigned long flags;
  	int locked;
  
 -	raw_local_irq_save(flags);
 -	locked = graph_lock();
 -	if (!locked)
 -		goto out_irq;
 -
 -	pf = get_pending_free();
 -	__lockdep_reset_lock(pf, lock);
 -	call_rcu_zapped(pf);
 -
 -	graph_unlock();
 -out_irq:
 -	raw_local_irq_restore(flags);
 -}
 -
 -/*
 - * Reset a lock. Does not sleep. Ignores debug_locks. Must only be used by the
 - * lockdep selftests.
 - */
 -static void lockdep_reset_lock_imm(struct lockdep_map *lock)
 -{
 -	struct pending_free *pf = delayed_free.pf;
 -	unsigned long flags;
 -
 -	raw_local_irq_save(flags);
 -	arch_spin_lock(&lockdep_lock);
 -	__lockdep_reset_lock(pf, lock);
 -	__free_zapped_classes(pf);
 -	arch_spin_unlock(&lockdep_lock);
 -	raw_local_irq_restore(flags);
 -}
 -
 -void lockdep_reset_lock(struct lockdep_map *lock)
 -{
  	init_data_structures_once();
  
 -	if (inside_selftest())
 -		lockdep_reset_lock_imm(lock);
 -	else
 -		lockdep_reset_lock_reg(lock);
 -}
 -
 -/* Unregister a dynamically allocated key. */
 -void lockdep_unregister_key(struct lock_class_key *key)
 -{
 -	struct hlist_head *hash_head = keyhashentry(key);
 -	struct lock_class_key *k;
 -	struct pending_free *pf;
 -	unsigned long flags;
 -	bool found = false;
 -
 -	might_sleep();
 -
 -	if (WARN_ON_ONCE(static_obj(key)))
 -		return;
 -
  	raw_local_irq_save(flags);
++<<<<<<< HEAD
 +	locked = graph_lock();
 +	__lockdep_reset_lock(lock);
 +	if (locked)
 +		graph_unlock();
++=======
+ 	if (!graph_lock())
+ 		goto out_irq;
+ 
+ 	pf = get_pending_free();
+ 	hlist_for_each_entry_rcu(k, hash_head, hash_entry) {
+ 		if (k == key) {
+ 			hlist_del_rcu(&k->hash_entry);
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	WARN_ON_ONCE(!found);
+ 	__lockdep_free_key_range(pf, key, 1);
+ 	call_rcu_zapped(pf);
+ 	graph_unlock();
+ out_irq:
++>>>>>>> 8b39adbee805 (locking/lockdep: Make lockdep_unregister_key() honor 'debug_locks' again)
  	raw_local_irq_restore(flags);
 -
 -	/* Wait until is_dynamic_key() has finished accessing k->hash_entry. */
 -	synchronize_rcu();
  }
 -EXPORT_SYMBOL_GPL(lockdep_unregister_key);
  
 -void __init lockdep_init(void)
 +void __init lockdep_info(void)
  {
  	printk("Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\n");
  
* Unmerged path kernel/locking/lockdep.c
