netfilter: synproxy: fix erroneous tcp mss option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Fernando Fernandez Mancera <ffmancera@riseup.net>
commit b83329fb473f29d34d85d642e3a3313bb2871fa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b83329fb.failed

Now synproxy sends the mss value set by the user on client syn-ack packet
instead of the mss value that client announced.

Fixes: 48b1de4c110a ("netfilter: add SYNPROXY core/target")
	Signed-off-by: Fernando Fernandez Mancera <ffmancera@riseup.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b83329fb473f29d34d85d642e3a3313bb2871fa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_synproxy_core.c
#	net/netfilter/nft_synproxy.c
diff --cc net/netfilter/nf_synproxy_core.c
index 8ff4d22f10b2,09718e5a9e41..000000000000
--- a/net/netfilter/nf_synproxy_core.c
+++ b/net/netfilter/nf_synproxy_core.c
@@@ -416,5 -410,830 +416,833 @@@ static void __exit synproxy_core_exit(v
  module_init(synproxy_core_init);
  module_exit(synproxy_core_exit);
  
++<<<<<<< HEAD
++=======
+ static struct iphdr *
+ synproxy_build_ip(struct net *net, struct sk_buff *skb, __be32 saddr,
+ 		  __be32 daddr)
+ {
+ 	struct iphdr *iph;
+ 
+ 	skb_reset_network_header(skb);
+ 	iph = skb_put(skb, sizeof(*iph));
+ 	iph->version	= 4;
+ 	iph->ihl	= sizeof(*iph) / 4;
+ 	iph->tos	= 0;
+ 	iph->id		= 0;
+ 	iph->frag_off	= htons(IP_DF);
+ 	iph->ttl	= net->ipv4.sysctl_ip_default_ttl;
+ 	iph->protocol	= IPPROTO_TCP;
+ 	iph->check	= 0;
+ 	iph->saddr	= saddr;
+ 	iph->daddr	= daddr;
+ 
+ 	return iph;
+ }
+ 
+ static void
+ synproxy_send_tcp(struct net *net,
+ 		  const struct sk_buff *skb, struct sk_buff *nskb,
+ 		  struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,
+ 		  struct iphdr *niph, struct tcphdr *nth,
+ 		  unsigned int tcp_hdr_size)
+ {
+ 	nth->check = ~tcp_v4_check(tcp_hdr_size, niph->saddr, niph->daddr, 0);
+ 	nskb->ip_summed   = CHECKSUM_PARTIAL;
+ 	nskb->csum_start  = (unsigned char *)nth - nskb->head;
+ 	nskb->csum_offset = offsetof(struct tcphdr, check);
+ 
+ 	skb_dst_set_noref(nskb, skb_dst(skb));
+ 	nskb->protocol = htons(ETH_P_IP);
+ 	if (ip_route_me_harder(net, nskb, RTN_UNSPEC))
+ 		goto free_nskb;
+ 
+ 	if (nfct) {
+ 		nf_ct_set(nskb, (struct nf_conn *)nfct, ctinfo);
+ 		nf_conntrack_get(nfct);
+ 	}
+ 
+ 	ip_local_out(net, nskb->sk, nskb);
+ 	return;
+ 
+ free_nskb:
+ 	kfree_skb(nskb);
+ }
+ 
+ void
+ synproxy_send_client_synack(struct net *net,
+ 			    const struct sk_buff *skb, const struct tcphdr *th,
+ 			    const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 	u16 mss = opts->mss_encode;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->daddr, iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(__cookie_v4_init_sequence(iph, th, &mss));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= 0;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
+ }
+ EXPORT_SYMBOL_GPL(synproxy_send_client_synack);
+ 
+ static void
+ synproxy_send_server_syn(struct net *net,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 const struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->saddr, iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(recv_seq - 1);
+ 	/* ack_seq is used to relay our ISN to the synproxy hook to initialize
+ 	 * sequence number translation once a connection tracking entry exists.
+ 	 */
+ 	nth->ack_seq	= htonl(ntohl(th->ack_seq) - 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= th->window;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, &snet->tmpl->ct_general, IP_CT_NEW,
+ 			  niph, nth, tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_server_ack(struct net *net,
+ 			 const struct ip_ct_tcp *state,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->daddr, iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(ntohl(th->ack_seq));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_client_ack(struct net *net,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct iphdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ip_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip(net, nskb, iph->saddr, iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(ntohl(th->seq) + 1);
+ 	nth->ack_seq	= th->ack_seq;
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(ntohs(th->window) >> opts->wscale);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp(net, skb, nskb, skb_nfct(skb),
+ 			  IP_CT_ESTABLISHED_REPLY, niph, nth, tcp_hdr_size);
+ }
+ 
+ bool
+ synproxy_recv_client_ack(struct net *net,
+ 			 const struct sk_buff *skb, const struct tcphdr *th,
+ 			 struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	int mss;
+ 
+ 	mss = __cookie_v4_check(ip_hdr(skb), th, ntohl(th->ack_seq) - 1);
+ 	if (mss == 0) {
+ 		this_cpu_inc(snet->stats->cookie_invalid);
+ 		return false;
+ 	}
+ 
+ 	this_cpu_inc(snet->stats->cookie_valid);
+ 	opts->mss = mss;
+ 	opts->options |= NF_SYNPROXY_OPT_MSS;
+ 
+ 	if (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 		synproxy_check_timestamp_cookie(opts);
+ 
+ 	synproxy_send_server_syn(net, skb, th, opts, recv_seq);
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(synproxy_recv_client_ack);
+ 
+ unsigned int
+ ipv4_synproxy_hook(void *priv, struct sk_buff *skb,
+ 		   const struct nf_hook_state *nhs)
+ {
+ 	struct net *net = nhs->net;
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *ct;
+ 	struct nf_conn_synproxy *synproxy;
+ 	struct synproxy_options opts = {};
+ 	const struct ip_ct_tcp *state;
+ 	struct tcphdr *th, _th;
+ 	unsigned int thoff;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct)
+ 		return NF_ACCEPT;
+ 
+ 	synproxy = nfct_synproxy(ct);
+ 	if (!synproxy)
+ 		return NF_ACCEPT;
+ 
+ 	if (nf_is_loopback_packet(skb) ||
+ 	    ip_hdr(skb)->protocol != IPPROTO_TCP)
+ 		return NF_ACCEPT;
+ 
+ 	thoff = ip_hdrlen(skb);
+ 	th = skb_header_pointer(skb, thoff, sizeof(_th), &_th);
+ 	if (!th)
+ 		return NF_DROP;
+ 
+ 	state = &ct->proto.tcp;
+ 	switch (state->state) {
+ 	case TCP_CONNTRACK_CLOSE:
+ 		if (th->rst && !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
+ 			nf_ct_seqadj_init(ct, ctinfo, synproxy->isn -
+ 						      ntohl(th->seq) + 1);
+ 			break;
+ 		}
+ 
+ 		if (!th->syn || th->ack ||
+ 		    CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)
+ 			break;
+ 
+ 		/* Reopened connection - reset the sequence number and timestamp
+ 		 * adjustments, they will get initialized once the connection is
+ 		 * reestablished.
+ 		 */
+ 		nf_ct_seqadj_init(ct, ctinfo, 0);
+ 		synproxy->tsoff = 0;
+ 		this_cpu_inc(snet->stats->conn_reopened);
+ 
+ 		/* fall through */
+ 	case TCP_CONNTRACK_SYN_SENT:
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (!th->syn && th->ack &&
+ 		    CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {
+ 			/* Keep-Alives are sent with SEG.SEQ = SND.NXT-1,
+ 			 * therefore we need to add 1 to make the SYN sequence
+ 			 * number match the one of first SYN.
+ 			 */
+ 			if (synproxy_recv_client_ack(net, skb, th, &opts,
+ 						     ntohl(th->seq) + 1)) {
+ 				this_cpu_inc(snet->stats->cookie_retrans);
+ 				consume_skb(skb);
+ 				return NF_STOLEN;
+ 			} else {
+ 				return NF_DROP;
+ 			}
+ 		}
+ 
+ 		synproxy->isn = ntohl(th->ack_seq);
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 			synproxy->its = opts.tsecr;
+ 
+ 		nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		break;
+ 	case TCP_CONNTRACK_SYN_RECV:
+ 		if (!th->syn || !th->ack)
+ 			break;
+ 
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP) {
+ 			synproxy->tsoff = opts.tsval - synproxy->its;
+ 			nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		}
+ 
+ 		opts.options &= ~(NF_SYNPROXY_OPT_MSS |
+ 				  NF_SYNPROXY_OPT_WSCALE |
+ 				  NF_SYNPROXY_OPT_SACK_PERM);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_server_ack(net, state, skb, th, &opts);
+ 
+ 		nf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));
+ 		nf_conntrack_event_cache(IPCT_SEQADJ, ct);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_client_ack(net, skb, th, &opts);
+ 
+ 		consume_skb(skb);
+ 		return NF_STOLEN;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	synproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);
+ 	return NF_ACCEPT;
+ }
+ EXPORT_SYMBOL_GPL(ipv4_synproxy_hook);
+ 
+ static const struct nf_hook_ops ipv4_synproxy_ops[] = {
+ 	{
+ 		.hook		= ipv4_synproxy_hook,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ 	{
+ 		.hook		= ipv4_synproxy_hook,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ };
+ 
+ int nf_synproxy_ipv4_init(struct synproxy_net *snet, struct net *net)
+ {
+ 	int err;
+ 
+ 	if (snet->hook_ref4 == 0) {
+ 		err = nf_register_net_hooks(net, ipv4_synproxy_ops,
+ 					    ARRAY_SIZE(ipv4_synproxy_ops));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	snet->hook_ref4++;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv4_init);
+ 
+ void nf_synproxy_ipv4_fini(struct synproxy_net *snet, struct net *net)
+ {
+ 	snet->hook_ref4--;
+ 	if (snet->hook_ref4 == 0)
+ 		nf_unregister_net_hooks(net, ipv4_synproxy_ops,
+ 					ARRAY_SIZE(ipv4_synproxy_ops));
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv4_fini);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static struct ipv6hdr *
+ synproxy_build_ip_ipv6(struct net *net, struct sk_buff *skb,
+ 		       const struct in6_addr *saddr,
+ 		       const struct in6_addr *daddr)
+ {
+ 	struct ipv6hdr *iph;
+ 
+ 	skb_reset_network_header(skb);
+ 	iph = skb_put(skb, sizeof(*iph));
+ 	ip6_flow_hdr(iph, 0, 0);
+ 	iph->hop_limit	= net->ipv6.devconf_all->hop_limit;
+ 	iph->nexthdr	= IPPROTO_TCP;
+ 	iph->saddr	= *saddr;
+ 	iph->daddr	= *daddr;
+ 
+ 	return iph;
+ }
+ 
+ static void
+ synproxy_send_tcp_ipv6(struct net *net,
+ 		       const struct sk_buff *skb, struct sk_buff *nskb,
+ 		       struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,
+ 		       struct ipv6hdr *niph, struct tcphdr *nth,
+ 		       unsigned int tcp_hdr_size)
+ {
+ 	struct dst_entry *dst;
+ 	struct flowi6 fl6;
+ 	int err;
+ 
+ 	nth->check = ~tcp_v6_check(tcp_hdr_size, &niph->saddr, &niph->daddr, 0);
+ 	nskb->ip_summed   = CHECKSUM_PARTIAL;
+ 	nskb->csum_start  = (unsigned char *)nth - nskb->head;
+ 	nskb->csum_offset = offsetof(struct tcphdr, check);
+ 
+ 	memset(&fl6, 0, sizeof(fl6));
+ 	fl6.flowi6_proto = IPPROTO_TCP;
+ 	fl6.saddr = niph->saddr;
+ 	fl6.daddr = niph->daddr;
+ 	fl6.fl6_sport = nth->source;
+ 	fl6.fl6_dport = nth->dest;
+ 	security_skb_classify_flow((struct sk_buff *)skb,
+ 				   flowi6_to_flowi(&fl6));
+ 	err = nf_ip6_route(net, &dst, flowi6_to_flowi(&fl6), false);
+ 	if (err) {
+ 		goto free_nskb;
+ 	}
+ 
+ 	dst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);
+ 	if (IS_ERR(dst))
+ 		goto free_nskb;
+ 
+ 	skb_dst_set(nskb, dst);
+ 
+ 	if (nfct) {
+ 		nf_ct_set(nskb, (struct nf_conn *)nfct, ctinfo);
+ 		nf_conntrack_get(nfct);
+ 	}
+ 
+ 	ip6_local_out(net, nskb->sk, nskb);
+ 	return;
+ 
+ free_nskb:
+ 	kfree_skb(nskb);
+ }
+ 
+ void
+ synproxy_send_client_synack_ipv6(struct net *net,
+ 				 const struct sk_buff *skb,
+ 				 const struct tcphdr *th,
+ 				 const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 	u16 mss = opts->mss_encode;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->daddr, &iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(nf_ipv6_cookie_init_sequence(iph, th, &mss));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= 0;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, skb_nfct(skb),
+ 			       IP_CT_ESTABLISHED_REPLY, niph, nth,
+ 			       tcp_hdr_size);
+ }
+ EXPORT_SYMBOL_GPL(synproxy_send_client_synack_ipv6);
+ 
+ static void
+ synproxy_send_server_syn_ipv6(struct net *net, const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      const struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->saddr, &iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(recv_seq - 1);
+ 	/* ack_seq is used to relay our ISN to the synproxy hook to initialize
+ 	 * sequence number translation once a connection tracking entry exists.
+ 	 */
+ 	nth->ack_seq	= htonl(ntohl(th->ack_seq) - 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_SYN;
+ 	if (opts->options & NF_SYNPROXY_OPT_ECN)
+ 		tcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= th->window;
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, &snet->tmpl->ct_general,
+ 			       IP_CT_NEW, niph, nth, tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_server_ack_ipv6(struct net *net, const struct ip_ct_tcp *state,
+ 			      const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->daddr, &iph->saddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->dest;
+ 	nth->dest	= th->source;
+ 	nth->seq	= htonl(ntohl(th->ack_seq));
+ 	nth->ack_seq	= htonl(ntohl(th->seq) + 1);
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, NULL, 0, niph, nth,
+ 			       tcp_hdr_size);
+ }
+ 
+ static void
+ synproxy_send_client_ack_ipv6(struct net *net, const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      const struct synproxy_options *opts)
+ {
+ 	struct sk_buff *nskb;
+ 	struct ipv6hdr *iph, *niph;
+ 	struct tcphdr *nth;
+ 	unsigned int tcp_hdr_size;
+ 
+ 	iph = ipv6_hdr(skb);
+ 
+ 	tcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);
+ 	nskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,
+ 			 GFP_ATOMIC);
+ 	if (!nskb)
+ 		return;
+ 	skb_reserve(nskb, MAX_TCP_HEADER);
+ 
+ 	niph = synproxy_build_ip_ipv6(net, nskb, &iph->saddr, &iph->daddr);
+ 
+ 	skb_reset_transport_header(nskb);
+ 	nth = skb_put(nskb, tcp_hdr_size);
+ 	nth->source	= th->source;
+ 	nth->dest	= th->dest;
+ 	nth->seq	= htonl(ntohl(th->seq) + 1);
+ 	nth->ack_seq	= th->ack_seq;
+ 	tcp_flag_word(nth) = TCP_FLAG_ACK;
+ 	nth->doff	= tcp_hdr_size / 4;
+ 	nth->window	= htons(ntohs(th->window) >> opts->wscale);
+ 	nth->check	= 0;
+ 	nth->urg_ptr	= 0;
+ 
+ 	synproxy_build_options(nth, opts);
+ 
+ 	synproxy_send_tcp_ipv6(net, skb, nskb, skb_nfct(skb),
+ 			       IP_CT_ESTABLISHED_REPLY, niph, nth,
+ 			       tcp_hdr_size);
+ }
+ 
+ bool
+ synproxy_recv_client_ack_ipv6(struct net *net,
+ 			      const struct sk_buff *skb,
+ 			      const struct tcphdr *th,
+ 			      struct synproxy_options *opts, u32 recv_seq)
+ {
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	int mss;
+ 
+ 	mss = nf_cookie_v6_check(ipv6_hdr(skb), th, ntohl(th->ack_seq) - 1);
+ 	if (mss == 0) {
+ 		this_cpu_inc(snet->stats->cookie_invalid);
+ 		return false;
+ 	}
+ 
+ 	this_cpu_inc(snet->stats->cookie_valid);
+ 	opts->mss = mss;
+ 	opts->options |= NF_SYNPROXY_OPT_MSS;
+ 
+ 	if (opts->options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 		synproxy_check_timestamp_cookie(opts);
+ 
+ 	synproxy_send_server_syn_ipv6(net, skb, th, opts, recv_seq);
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(synproxy_recv_client_ack_ipv6);
+ 
+ unsigned int
+ ipv6_synproxy_hook(void *priv, struct sk_buff *skb,
+ 		   const struct nf_hook_state *nhs)
+ {
+ 	struct net *net = nhs->net;
+ 	struct synproxy_net *snet = synproxy_pernet(net);
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *ct;
+ 	struct nf_conn_synproxy *synproxy;
+ 	struct synproxy_options opts = {};
+ 	const struct ip_ct_tcp *state;
+ 	struct tcphdr *th, _th;
+ 	__be16 frag_off;
+ 	u8 nexthdr;
+ 	int thoff;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct)
+ 		return NF_ACCEPT;
+ 
+ 	synproxy = nfct_synproxy(ct);
+ 	if (!synproxy)
+ 		return NF_ACCEPT;
+ 
+ 	if (nf_is_loopback_packet(skb))
+ 		return NF_ACCEPT;
+ 
+ 	nexthdr = ipv6_hdr(skb)->nexthdr;
+ 	thoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,
+ 				 &frag_off);
+ 	if (thoff < 0 || nexthdr != IPPROTO_TCP)
+ 		return NF_ACCEPT;
+ 
+ 	th = skb_header_pointer(skb, thoff, sizeof(_th), &_th);
+ 	if (!th)
+ 		return NF_DROP;
+ 
+ 	state = &ct->proto.tcp;
+ 	switch (state->state) {
+ 	case TCP_CONNTRACK_CLOSE:
+ 		if (th->rst && !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
+ 			nf_ct_seqadj_init(ct, ctinfo, synproxy->isn -
+ 						      ntohl(th->seq) + 1);
+ 			break;
+ 		}
+ 
+ 		if (!th->syn || th->ack ||
+ 		    CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)
+ 			break;
+ 
+ 		/* Reopened connection - reset the sequence number and timestamp
+ 		 * adjustments, they will get initialized once the connection is
+ 		 * reestablished.
+ 		 */
+ 		nf_ct_seqadj_init(ct, ctinfo, 0);
+ 		synproxy->tsoff = 0;
+ 		this_cpu_inc(snet->stats->conn_reopened);
+ 
+ 		/* fall through */
+ 	case TCP_CONNTRACK_SYN_SENT:
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (!th->syn && th->ack &&
+ 		    CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {
+ 			/* Keep-Alives are sent with SEG.SEQ = SND.NXT-1,
+ 			 * therefore we need to add 1 to make the SYN sequence
+ 			 * number match the one of first SYN.
+ 			 */
+ 			if (synproxy_recv_client_ack_ipv6(net, skb, th, &opts,
+ 							  ntohl(th->seq) + 1)) {
+ 				this_cpu_inc(snet->stats->cookie_retrans);
+ 				consume_skb(skb);
+ 				return NF_STOLEN;
+ 			} else {
+ 				return NF_DROP;
+ 			}
+ 		}
+ 
+ 		synproxy->isn = ntohl(th->ack_seq);
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP)
+ 			synproxy->its = opts.tsecr;
+ 
+ 		nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		break;
+ 	case TCP_CONNTRACK_SYN_RECV:
+ 		if (!th->syn || !th->ack)
+ 			break;
+ 
+ 		if (!synproxy_parse_options(skb, thoff, th, &opts))
+ 			return NF_DROP;
+ 
+ 		if (opts.options & NF_SYNPROXY_OPT_TIMESTAMP) {
+ 			synproxy->tsoff = opts.tsval - synproxy->its;
+ 			nf_conntrack_event_cache(IPCT_SYNPROXY, ct);
+ 		}
+ 
+ 		opts.options &= ~(NF_SYNPROXY_OPT_MSS |
+ 				  NF_SYNPROXY_OPT_WSCALE |
+ 				  NF_SYNPROXY_OPT_SACK_PERM);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_server_ack_ipv6(net, state, skb, th, &opts);
+ 
+ 		nf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));
+ 		nf_conntrack_event_cache(IPCT_SEQADJ, ct);
+ 
+ 		swap(opts.tsval, opts.tsecr);
+ 		synproxy_send_client_ack_ipv6(net, skb, th, &opts);
+ 
+ 		consume_skb(skb);
+ 		return NF_STOLEN;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	synproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);
+ 	return NF_ACCEPT;
+ }
+ EXPORT_SYMBOL_GPL(ipv6_synproxy_hook);
+ 
+ static const struct nf_hook_ops ipv6_synproxy_ops[] = {
+ 	{
+ 		.hook		= ipv6_synproxy_hook,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ 	{
+ 		.hook		= ipv6_synproxy_hook,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM - 1,
+ 	},
+ };
+ 
+ int
+ nf_synproxy_ipv6_init(struct synproxy_net *snet, struct net *net)
+ {
+ 	int err;
+ 
+ 	if (snet->hook_ref6 == 0) {
+ 		err = nf_register_net_hooks(net, ipv6_synproxy_ops,
+ 					    ARRAY_SIZE(ipv6_synproxy_ops));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	snet->hook_ref6++;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv6_init);
+ 
+ void
+ nf_synproxy_ipv6_fini(struct synproxy_net *snet, struct net *net)
+ {
+ 	snet->hook_ref6--;
+ 	if (snet->hook_ref6 == 0)
+ 		nf_unregister_net_hooks(net, ipv6_synproxy_ops,
+ 					ARRAY_SIZE(ipv6_synproxy_ops));
+ }
+ EXPORT_SYMBOL_GPL(nf_synproxy_ipv6_fini);
+ #endif /* CONFIG_IPV6 */
+ 
++>>>>>>> b83329fb473f (netfilter: synproxy: fix erroneous tcp mss option)
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
* Unmerged path net/netfilter/nft_synproxy.c
diff --git a/include/net/netfilter/nf_conntrack_synproxy.h b/include/net/netfilter/nf_conntrack_synproxy.h
index 2c7559a54092..9a1e0fd15fce 100644
--- a/include/net/netfilter/nf_conntrack_synproxy.h
+++ b/include/net/netfilter/nf_conntrack_synproxy.h
@@ -67,6 +67,7 @@ struct synproxy_options {
 	u8				options;
 	u8				wscale;
 	u16				mss;
+	u16				mss_encode;
 	u32				tsval;
 	u32				tsecr;
 };
diff --git a/net/ipv4/netfilter/ipt_SYNPROXY.c b/net/ipv4/netfilter/ipt_SYNPROXY.c
index 690b17ef6a44..aac1b08e7aa1 100644
--- a/net/ipv4/netfilter/ipt_SYNPROXY.c
+++ b/net/ipv4/netfilter/ipt_SYNPROXY.c
@@ -286,6 +286,8 @@ synproxy_tg4(struct sk_buff *skb, const struct xt_action_param *par)
 			opts.options |= XT_SYNPROXY_OPT_ECN;
 
 		opts.options &= info->options;
+		opts.mss_encode = opts.mss;
+		opts.mss = info->mss;
 		if (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)
 			synproxy_init_timestamp_cookie(info, &opts);
 		else
diff --git a/net/ipv6/netfilter/ip6t_SYNPROXY.c b/net/ipv6/netfilter/ip6t_SYNPROXY.c
index cb6d42b03cb5..87f12e53c181 100644
--- a/net/ipv6/netfilter/ip6t_SYNPROXY.c
+++ b/net/ipv6/netfilter/ip6t_SYNPROXY.c
@@ -300,6 +300,8 @@ synproxy_tg6(struct sk_buff *skb, const struct xt_action_param *par)
 			opts.options |= XT_SYNPROXY_OPT_ECN;
 
 		opts.options &= info->options;
+		opts.mss_encode = opts.mss;
+		opts.mss = info->mss;
 		if (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)
 			synproxy_init_timestamp_cookie(info, &opts);
 		else
* Unmerged path net/netfilter/nf_synproxy_core.c
* Unmerged path net/netfilter/nft_synproxy.c
