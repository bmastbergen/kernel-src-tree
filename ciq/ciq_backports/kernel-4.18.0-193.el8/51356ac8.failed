bpf: Fix distinct pointer types warning for ARCH=i386

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrey Ignatov <rdna@fb.com>
commit 51356ac89b5a15e5207e8740d5f4f8b71cb7332f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/51356ac8.failed

Fix a new warning reported by kbuild for make ARCH=i386:

   In file included from kernel/bpf/cgroup.c:11:0:
   kernel/bpf/cgroup.c: In function '__cgroup_bpf_run_filter_sysctl':
   include/linux/kernel.h:827:29: warning: comparison of distinct pointer types lacks a cast
      (!!(sizeof((typeof(x) *)1 == (typeof(y) *)1)))
                                ^
   include/linux/kernel.h:841:4: note: in expansion of macro '__typecheck'
      (__typecheck(x, y) && __no_side_effects(x, y))
       ^~~~~~~~~~~
   include/linux/kernel.h:851:24: note: in expansion of macro '__safe_cmp'
     __builtin_choose_expr(__safe_cmp(x, y), \
                           ^~~~~~~~~~
   include/linux/kernel.h:860:19: note: in expansion of macro '__careful_cmp'
    #define min(x, y) __careful_cmp(x, y, <)
                      ^~~~~~~~~~~~~
>> kernel/bpf/cgroup.c:837:17: note: in expansion of macro 'min'
      ctx.new_len = min(PAGE_SIZE, *pcount);
                    ^~~

Fixes: 4e63acdff864 ("bpf: Introduce bpf_sysctl_{get,set}_new_value helpers")
	Signed-off-by: Andrey Ignatov <rdna@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 51356ac89b5a15e5207e8740d5f4f8b71cb7332f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/cgroup.c
diff --cc kernel/bpf/cgroup.c
index 7d9c426bf2c7,e58a6c247f56..000000000000
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@@ -811,3 -771,356 +811,359 @@@ const struct bpf_verifier_ops cg_dev_ve
  	.get_func_proto		= cgroup_dev_func_proto,
  	.is_valid_access	= cgroup_dev_is_valid_access,
  };
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * __cgroup_bpf_run_filter_sysctl - Run a program on sysctl
+  *
+  * @head: sysctl table header
+  * @table: sysctl table
+  * @write: sysctl is being read (= 0) or written (= 1)
+  * @buf: pointer to buffer passed by user space
+  * @pcount: value-result argument: value is size of buffer pointed to by @buf,
+  *	result is size of @new_buf if program set new value, initial value
+  *	otherwise
+  * @ppos: value-result argument: value is position at which read from or write
+  *	to sysctl is happening, result is new position if program overrode it,
+  *	initial value otherwise
+  * @new_buf: pointer to pointer to new buffer that will be allocated if program
+  *	overrides new value provided by user space on sysctl write
+  *	NOTE: it's caller responsibility to free *new_buf if it was set
+  * @type: type of program to be executed
+  *
+  * Program is run when sysctl is being accessed, either read or written, and
+  * can allow or deny such access.
+  *
+  * This function will return %-EPERM if an attached program is found and
+  * returned value != 1 during execution. In all other cases 0 is returned.
+  */
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   void __user *buf, size_t *pcount,
+ 				   loff_t *ppos, void **new_buf,
+ 				   enum bpf_attach_type type)
+ {
+ 	struct bpf_sysctl_kern ctx = {
+ 		.head = head,
+ 		.table = table,
+ 		.write = write,
+ 		.ppos = ppos,
+ 		.cur_val = NULL,
+ 		.cur_len = PAGE_SIZE,
+ 		.new_val = NULL,
+ 		.new_len = 0,
+ 		.new_updated = 0,
+ 	};
+ 	struct cgroup *cgrp;
+ 	int ret;
+ 
+ 	ctx.cur_val = kmalloc_track_caller(ctx.cur_len, GFP_KERNEL);
+ 	if (ctx.cur_val) {
+ 		mm_segment_t old_fs;
+ 		loff_t pos = 0;
+ 
+ 		old_fs = get_fs();
+ 		set_fs(KERNEL_DS);
+ 		if (table->proc_handler(table, 0, (void __user *)ctx.cur_val,
+ 					&ctx.cur_len, &pos)) {
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.cur_len = 0;
+ 		}
+ 		set_fs(old_fs);
+ 	} else {
+ 		/* Let BPF program decide how to proceed. */
+ 		ctx.cur_len = 0;
+ 	}
+ 
+ 	if (write && buf && *pcount) {
+ 		/* BPF program should be able to override new value with a
+ 		 * buffer bigger than provided by user.
+ 		 */
+ 		ctx.new_val = kmalloc_track_caller(PAGE_SIZE, GFP_KERNEL);
+ 		ctx.new_len = min_t(size_t, PAGE_SIZE, *pcount);
+ 		if (!ctx.new_val ||
+ 		    copy_from_user(ctx.new_val, buf, ctx.new_len))
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.new_len = 0;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	cgrp = task_dfl_cgroup(current);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);
+ 	rcu_read_unlock();
+ 
+ 	kfree(ctx.cur_val);
+ 
+ 	if (ret == 1 && ctx.new_updated) {
+ 		*new_buf = ctx.new_val;
+ 		*pcount = ctx.new_len;
+ 	} else {
+ 		kfree(ctx.new_val);
+ 	}
+ 
+ 	return ret == 1 ? 0 : -EPERM;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_sysctl);
+ 
+ static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,
+ 			      size_t *lenp)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (dir->header.parent) {
+ 		tmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);
+ 	if (ret < 0)
+ 		return ret;
+ 	*bufp += ret;
+ 	*lenp -= ret;
+ 	ret += tmp_ret;
+ 
+ 	/* Avoid leading slash. */
+ 	if (!ret)
+ 		return ret;
+ 
+ 	tmp_ret = strscpy(*bufp, "/", *lenp);
+ 	if (tmp_ret < 0)
+ 		return tmp_ret;
+ 	*bufp += tmp_ret;
+ 	*lenp -= tmp_ret;
+ 
+ 	return ret + tmp_ret;
+ }
+ 
+ BPF_CALL_4(bpf_sysctl_get_name, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len, u64, flags)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (!(flags & BPF_F_SYSCTL_BASE_NAME)) {
+ 		if (!ctx->head)
+ 			return -EINVAL;
+ 		tmp_ret = sysctl_cpy_dir(ctx->head->parent, &buf, &buf_len);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(buf, ctx->table->procname, buf_len);
+ 
+ 	return ret < 0 ? ret : tmp_ret + ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_name_proto = {
+ 	.func		= bpf_sysctl_get_name,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ static int copy_sysctl_value(char *dst, size_t dst_len, char *src,
+ 			     size_t src_len)
+ {
+ 	if (!dst)
+ 		return -EINVAL;
+ 
+ 	if (!dst_len)
+ 		return -E2BIG;
+ 
+ 	if (!src || !src_len) {
+ 		memset(dst, 0, dst_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	memcpy(dst, src, min(dst_len, src_len));
+ 
+ 	if (dst_len > src_len) {
+ 		memset(dst + src_len, '\0', dst_len - src_len);
+ 		return src_len;
+ 	}
+ 
+ 	dst[dst_len - 1] = '\0';
+ 
+ 	return -E2BIG;
+ }
+ 
+ BPF_CALL_3(bpf_sysctl_get_current_value, struct bpf_sysctl_kern *, ctx,
+ 	   char *, buf, size_t, buf_len)
+ {
+ 	return copy_sysctl_value(buf, buf_len, ctx->cur_val, ctx->cur_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_current_value_proto = {
+ 	.func		= bpf_sysctl_get_current_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_get_new_value, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len)
+ {
+ 	if (!ctx->write) {
+ 		if (buf && buf_len)
+ 			memset(buf, '\0', buf_len);
+ 		return -EINVAL;
+ 	}
+ 	return copy_sysctl_value(buf, buf_len, ctx->new_val, ctx->new_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_new_value_proto = {
+ 	.func		= bpf_sysctl_get_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_set_new_value, struct bpf_sysctl_kern *, ctx,
+ 	   const char *, buf, size_t, buf_len)
+ {
+ 	if (!ctx->write || !ctx->new_val || !ctx->new_len || !buf || !buf_len)
+ 		return -EINVAL;
+ 
+ 	if (buf_len > PAGE_SIZE - 1)
+ 		return -E2BIG;
+ 
+ 	memcpy(ctx->new_val, buf, buf_len);
+ 	ctx->new_len = buf_len;
+ 	ctx->new_updated = 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_set_new_value_proto = {
+ 	.func		= bpf_sysctl_set_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ sysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_strtol:
+ 		return &bpf_strtol_proto;
+ 	case BPF_FUNC_strtoul:
+ 		return &bpf_strtoul_proto;
+ 	case BPF_FUNC_sysctl_get_name:
+ 		return &bpf_sysctl_get_name_proto;
+ 	case BPF_FUNC_sysctl_get_current_value:
+ 		return &bpf_sysctl_get_current_value_proto;
+ 	case BPF_FUNC_sysctl_get_new_value:
+ 		return &bpf_sysctl_get_new_value_proto;
+ 	case BPF_FUNC_sysctl_set_new_value:
+ 		return &bpf_sysctl_set_new_value_proto;
+ 	default:
+ 		return cgroup_base_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off + size > sizeof(struct bpf_sysctl) || off % size)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		if (type != BPF_READ)
+ 			return false;
+ 		bpf_ctx_record_field_size(info, size_default);
+ 		return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 	case offsetof(struct bpf_sysctl, file_pos):
+ 		if (type == BPF_READ) {
+ 			bpf_ctx_record_field_size(info, size_default);
+ 			return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 		} else {
+ 			return size == size_default;
+ 		}
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static u32 sysctl_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct bpf_sysctl_kern, write,
+ 				       FIELD_SIZEOF(struct bpf_sysctl_kern,
+ 						    write),
+ 				       target_size));
+ 		break;
+ 	case offsetof(struct bpf_sysctl, file_pos):
+ 		/* ppos is a pointer so it should be accessed via indirect
+ 		 * loads and stores. Also for stores additional temporary
+ 		 * register is used since neither src_reg nor dst_reg can be
+ 		 * overridden.
+ 		 */
+ 		if (type == BPF_WRITE) {
+ 			int treg = BPF_REG_9;
+ 
+ 			if (si->src_reg == treg || si->dst_reg == treg)
+ 				--treg;
+ 			if (si->src_reg == treg || si->dst_reg == treg)
+ 				--treg;
+ 			*insn++ = BPF_STX_MEM(
+ 				BPF_DW, si->dst_reg, treg,
+ 				offsetof(struct bpf_sysctl_kern, tmp_reg));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),
+ 				treg, si->dst_reg,
+ 				offsetof(struct bpf_sysctl_kern, ppos));
+ 			*insn++ = BPF_STX_MEM(
+ 				BPF_SIZEOF(u32), treg, si->src_reg, 0);
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_DW, treg, si->dst_reg,
+ 				offsetof(struct bpf_sysctl_kern, tmp_reg));
+ 		} else {
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),
+ 				si->dst_reg, si->src_reg,
+ 				offsetof(struct bpf_sysctl_kern, ppos));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_SIZE(si->code), si->dst_reg, si->dst_reg, 0);
+ 		}
+ 		*target_size = sizeof(u32);
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ const struct bpf_verifier_ops cg_sysctl_verifier_ops = {
+ 	.get_func_proto		= sysctl_func_proto,
+ 	.is_valid_access	= sysctl_is_valid_access,
+ 	.convert_ctx_access	= sysctl_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sysctl_prog_ops = {
+ };
++>>>>>>> 51356ac89b5a (bpf: Fix distinct pointer types warning for ARCH=i386)
* Unmerged path kernel/bpf/cgroup.c
