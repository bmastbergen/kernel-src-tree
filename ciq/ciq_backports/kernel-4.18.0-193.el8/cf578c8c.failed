drm/mgag200: Set cursor scanout address to correct BO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Thomas Zimmermann <tzimmermann@suse.de>
commit cf578c8c8e0b1fcd7c7de649effaf2c7625433c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/cf578c8c.failed

The hardware requires the correct memory address of the buffer. Currently
the same BO's address is programmed unconditionally, so only every second
cursor update actually becomes visible.

	Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
	Acked-by: Sam Ravnborg <sam@ravnborg.org>
Fixes: 94dc57b10399 ("drm/mgag200: Rewrite cursor handling")
	Cc: Gerd Hoffmann <kraxel@redhat.com>
	Cc: Dave Airlie <airlied@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190723075425.24028-3-tzimmermann@suse.de
(cherry picked from commit cf578c8c8e0b1fcd7c7de649effaf2c7625433c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/mgag200/mgag200_cursor.c
diff --cc drivers/gpu/drm/mgag200/mgag200_cursor.c
index 968e20379d54,f11b862cbed9..000000000000
--- a/drivers/gpu/drm/mgag200/mgag200_cursor.c
+++ b/drivers/gpu/drm/mgag200/mgag200_cursor.c
@@@ -78,50 -73,53 +78,61 @@@ int mga_crtc_cursor_set(struct drm_crt
  	obj = drm_gem_object_lookup(file_priv, handle);
  	if (!obj)
  		return -ENOENT;
 -	gbo = drm_gem_vram_of_gem(obj);
 -	ret = drm_gem_vram_pin(gbo, 0);
 +
 +	ret = mgag200_bo_reserve(pixels_1, true);
  	if (ret) {
 -		dev_err(&dev->pdev->dev, "failed to lock user bo\n");
 -		goto err_drm_gem_object_put_unlocked;
 +		WREG8(MGA_CURPOSXL, 0);
 +		WREG8(MGA_CURPOSXH, 0);
 +		goto out_unref;
  	}
 -	src = drm_gem_vram_kmap(gbo, true, NULL);
 -	if (IS_ERR(src)) {
 -		ret = PTR_ERR(src);
 -		dev_err(&dev->pdev->dev,
 -			"failed to kmap user buffer updates\n");
 -		goto err_drm_gem_vram_unpin_src;
 +	ret = mgag200_bo_reserve(pixels_2, true);
 +	if (ret) {
 +		WREG8(MGA_CURPOSXL, 0);
 +		WREG8(MGA_CURPOSXH, 0);
 +		mgag200_bo_unreserve(pixels_1);
 +		goto out_unreserve1;
  	}
  
 -	/* Pin and map up-coming buffer to write colour indices */
 -	ret = drm_gem_vram_pin(pixels_next, DRM_GEM_VRAM_PL_FLAG_VRAM);
 +	/* Move cursor buffers into VRAM if they aren't already */
 +	if (!pixels_1->pin_count) {
 +		ret = mgag200_bo_pin(pixels_1, TTM_PL_FLAG_VRAM,
 +				     &mdev->cursor.pixels_1_gpu_addr);
 +		if (ret)
 +			goto out1;
 +	}
 +	if (!pixels_2->pin_count) {
 +		ret = mgag200_bo_pin(pixels_2, TTM_PL_FLAG_VRAM,
 +				     &mdev->cursor.pixels_2_gpu_addr);
 +		if (ret) {
 +			mgag200_bo_unpin(pixels_1);
 +			goto out1;
 +		}
 +	}
 +
 +	bo = gem_to_mga_bo(obj);
 +	ret = mgag200_bo_reserve(bo, true);
  	if (ret) {
 -		dev_err(&dev->pdev->dev,
 -			"failed to pin cursor buffer: %d\n", ret);
 -		goto err_drm_gem_vram_kunmap_src;
 +		dev_err(&dev->pdev->dev, "failed to reserve user bo\n");
 +		goto out1;
  	}
 -	dst = drm_gem_vram_kmap(pixels_next, true, NULL);
 -	if (IS_ERR(dst)) {
 -		ret = PTR_ERR(dst);
 -		dev_err(&dev->pdev->dev,
 -			"failed to kmap cursor updates: %d\n", ret);
 -		goto err_drm_gem_vram_unpin_dst;
 +	if (!bo->kmap.virtual) {
 +		ret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);
 +		if (ret) {
 +			dev_err(&dev->pdev->dev, "failed to kmap user buffer updates\n");
 +			goto out2;
 +		}
  	}
++<<<<<<< HEAD
++=======
+ 	gpu_addr = drm_gem_vram_offset(pixels_next);
+ 	if (gpu_addr < 0) {
+ 		ret = (int)gpu_addr;
+ 		dev_err(&dev->pdev->dev,
+ 			"failed to get cursor scanout address: %d\n", ret);
+ 		goto err_drm_gem_vram_kunmap_dst;
+ 	}
+ 	dst_gpu = (u64)gpu_addr;
++>>>>>>> cf578c8c8e0b (drm/mgag200: Set cursor scanout address to correct BO)
  
  	memset(&colour_set[0], 0, sizeof(uint32_t)*16);
  	/* width*height*4 = 16384 */
* Unmerged path drivers/gpu/drm/mgag200/mgag200_cursor.c
