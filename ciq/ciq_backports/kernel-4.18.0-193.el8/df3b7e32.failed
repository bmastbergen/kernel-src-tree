drm/amd/display: refactor Device ID for external chips

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Qingqing Zhuo <qingqing.zhuo@amd.com>
commit df3b7e32ed459a5348f7b408a9b8142b7358fde8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/df3b7e32.failed

IEEE OUI will now be used while referring to certain vendors.
instead of normal index

	Signed-off-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
	Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
	Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit df3b7e32ed459a5348f7b408a9b8142b7358fde8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
diff --cc drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 6809932e80be,40067403b043..000000000000
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@@ -2786,3 -3336,168 +2786,171 @@@ void dp_enable_mst_on_sink(struct dc_li
  
  	core_link_write_dpcd(link, DP_MSTM_CTRL, &mstmCntl, 1);
  }
++<<<<<<< HEAD
++=======
+ 
+ void dp_set_panel_mode(struct dc_link *link, enum dp_panel_mode panel_mode)
+ {
+ 	union dpcd_edp_config edp_config_set;
+ 	bool panel_mode_edp = false;
+ 
+ 	memset(&edp_config_set, '\0', sizeof(union dpcd_edp_config));
+ 
+ 	if (panel_mode != DP_PANEL_MODE_DEFAULT) {
+ 
+ 		switch (panel_mode) {
+ 		case DP_PANEL_MODE_EDP:
+ 		case DP_PANEL_MODE_SPECIAL:
+ 			panel_mode_edp = true;
+ 			break;
+ 
+ 		default:
+ 				break;
+ 		}
+ 
+ 		/*set edp panel mode in receiver*/
+ 		core_link_read_dpcd(
+ 			link,
+ 			DP_EDP_CONFIGURATION_SET,
+ 			&edp_config_set.raw,
+ 			sizeof(edp_config_set.raw));
+ 
+ 		if (edp_config_set.bits.PANEL_MODE_EDP
+ 			!= panel_mode_edp) {
+ 			enum ddc_result result = DDC_RESULT_UNKNOWN;
+ 
+ 			edp_config_set.bits.PANEL_MODE_EDP =
+ 			panel_mode_edp;
+ 			result = core_link_write_dpcd(
+ 				link,
+ 				DP_EDP_CONFIGURATION_SET,
+ 				&edp_config_set.raw,
+ 				sizeof(edp_config_set.raw));
+ 
+ 			ASSERT(result == DDC_RESULT_SUCESSFULL);
+ 		}
+ 	}
+ 	DC_LOG_DETECTION_DP_CAPS("Link: %d eDP panel mode supported: %d "
+ 		 "eDP panel mode enabled: %d \n",
+ 		 link->link_index,
+ 		 link->dpcd_caps.panel_mode_edp,
+ 		 panel_mode_edp);
+ }
+ 
+ enum dp_panel_mode dp_get_panel_mode(struct dc_link *link)
+ {
+ 	/* We need to explicitly check that connector
+ 	 * is not DP. Some Travis_VGA get reported
+ 	 * by video bios as DP.
+ 	 */
+ 	if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+ 
+ 		switch (link->dpcd_caps.branch_dev_id) {
+ 		case DP_BRANCH_DEVICE_ID_0022B9:
+ 			/* alternate scrambler reset is required for Travis
+ 			 * for the case when external chip does not
+ 			 * provide sink device id, alternate scrambler
+ 			 * scheme will  be overriden later by querying
+ 			 * Encoder features
+ 			 */
+ 			if (strncmp(
+ 				link->dpcd_caps.branch_dev_name,
+ 				DP_VGA_LVDS_CONVERTER_ID_2,
+ 				sizeof(
+ 				link->dpcd_caps.
+ 				branch_dev_name)) == 0) {
+ 					return DP_PANEL_MODE_SPECIAL;
+ 			}
+ 			break;
+ 		case DP_BRANCH_DEVICE_ID_00001A:
+ 			/* alternate scrambler reset is required for Travis
+ 			 * for the case when external chip does not provide
+ 			 * sink device id, alternate scrambler scheme will
+ 			 * be overriden later by querying Encoder feature
+ 			 */
+ 			if (strncmp(link->dpcd_caps.branch_dev_name,
+ 				DP_VGA_LVDS_CONVERTER_ID_3,
+ 				sizeof(
+ 				link->dpcd_caps.
+ 				branch_dev_name)) == 0) {
+ 					return DP_PANEL_MODE_SPECIAL;
+ 			}
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (link->dpcd_caps.panel_mode_edp) {
+ 		return DP_PANEL_MODE_EDP;
+ 	}
+ 
+ 	return DP_PANEL_MODE_DEFAULT;
+ }
+ 
+ #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+ void dp_set_fec_ready(struct dc_link *link, bool ready)
+ {
+ 	/* FEC has to be "set ready" before the link training.
+ 	 * The policy is to always train with FEC
+ 	 * if the sink supports it and leave it enabled on link.
+ 	 * If FEC is not supported, disable it.
+ 	 */
+ 	struct link_encoder *link_enc = link->link_enc;
+ 	uint8_t fec_config = 0;
+ 
+ 	if (link->dc->debug.disable_fec ||
+ 			IS_FPGA_MAXIMUS_DC(link->ctx->dce_environment))
+ 		return;
+ 
+ 	if (link_enc->funcs->fec_set_ready &&
+ 			link->dpcd_caps.fec_cap.bits.FEC_CAPABLE) {
+ 		if (ready) {
+ 			fec_config = 1;
+ 			if (core_link_write_dpcd(link,
+ 					DP_FEC_CONFIGURATION,
+ 					&fec_config,
+ 					sizeof(fec_config)) == DC_OK) {
+ 				link_enc->funcs->fec_set_ready(link_enc, true);
+ 				link->fec_state = dc_link_fec_ready;
+ 			} else {
+ 				link->link_enc->funcs->fec_set_ready(link->link_enc, false);
+ 				link->fec_state = dc_link_fec_not_ready;
+ 				dm_error("dpcd write failed to set fec_ready");
+ 			}
+ 		} else if (link->fec_state == dc_link_fec_ready) {
+ 			fec_config = 0;
+ 			core_link_write_dpcd(link,
+ 					DP_FEC_CONFIGURATION,
+ 					&fec_config,
+ 					sizeof(fec_config));
+ 			link->link_enc->funcs->fec_set_ready(
+ 					link->link_enc, false);
+ 			link->fec_state = dc_link_fec_not_ready;
+ 		}
+ 	}
+ }
+ 
+ void dp_set_fec_enable(struct dc_link *link, bool enable)
+ {
+ 	struct link_encoder *link_enc = link->link_enc;
+ 
+ 	if (link->dc->debug.disable_fec ||
+ 			IS_FPGA_MAXIMUS_DC(link->ctx->dce_environment))
+ 		return;
+ 
+ 	if (link_enc->funcs->fec_set_enable &&
+ 			link->dpcd_caps.fec_cap.bits.FEC_CAPABLE) {
+ 		if (link->fec_state == dc_link_fec_ready && enable) {
+ 			msleep(1);
+ 			link_enc->funcs->fec_set_enable(link_enc, true);
+ 			link->fec_state = dc_link_fec_enabled;
+ 		} else if (link->fec_state == dc_link_fec_enabled && !enable) {
+ 			link_enc->funcs->fec_set_enable(link_enc, false);
+ 			link->fec_state = dc_link_fec_ready;
+ 		}
+ 	}
+ }
+ #endif
+ 
++>>>>>>> df3b7e32ed45 (drm/amd/display: refactor Device ID for external chips)
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c
index 4ddba5b2e101..7de251720a74 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c
@@ -294,7 +294,7 @@ static uint32_t defer_delay_converter_wa(
 {
 	struct dc_link *link = ddc->link;
 
-	if (link->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_4 &&
+	if (link->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_0080E1 &&
 		!memcmp(link->dpcd_caps.branch_dev_name,
 			DP_DVI_CONVERTER_ID_4,
 			sizeof(link->dpcd_caps.branch_dev_name)))
* Unmerged path drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
diff --git a/drivers/gpu/drm/amd/display/include/ddc_service_types.h b/drivers/gpu/drm/amd/display/include/ddc_service_types.h
index d968956a10cd..18961707db23 100644
--- a/drivers/gpu/drm/amd/display/include/ddc_service_types.h
+++ b/drivers/gpu/drm/amd/display/include/ddc_service_types.h
@@ -25,10 +25,12 @@
 #ifndef __DAL_DDC_SERVICE_TYPES_H__
 #define __DAL_DDC_SERVICE_TYPES_H__
 
-#define DP_BRANCH_DEVICE_ID_1 0x0010FA
-#define DP_BRANCH_DEVICE_ID_2 0x0022B9
-#define DP_BRANCH_DEVICE_ID_3 0x00001A
-#define DP_BRANCH_DEVICE_ID_4 0x0080e1
+/* 0010FA dongles (ST Micro) external converter chip id */
+#define DP_BRANCH_DEVICE_ID_0010FA 0x0010FA
+/* 0022B9 external converter chip id */
+#define DP_BRANCH_DEVICE_ID_0022B9 0x0022B9
+#define DP_BRANCH_DEVICE_ID_00001A 0x00001A
+#define DP_BRANCH_DEVICE_ID_0080E1 0x0080e1
 
 enum ddc_result {
 	DDC_RESULT_UNKNOWN = 0,
