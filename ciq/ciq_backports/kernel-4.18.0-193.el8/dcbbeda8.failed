SUNRPC: Move RPC retransmission stat counter to xprt_transmit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit dcbbeda836bc748e8fecd753b83d5b345ef8ec31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/dcbbeda8.failed

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit dcbbeda836bc748e8fecd753b83d5b345ef8ec31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index d6ca4ed0e072,8dc3d33827c4..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1963,19 -1971,6 +1961,22 @@@ call_transmit(struct rpc_task *task
  	if (!xprt_prepare_transmit(task))
  		return;
  	xprt_transmit(task);
++<<<<<<< HEAD
 +	if (task->tk_status < 0)
 +		return;
 +	if (is_retrans)
 +		task->tk_client->cl_stats->rpcretrans++;
 +	/*
 +	 * On success, ensure that we call xprt_end_transmit() before sleeping
 +	 * in order to allow access to the socket to other RPC requests.
 +	 */
 +	call_transmit_status(task);
 +	if (rpc_reply_expected(task))
 +		return;
 +	task->tk_action = rpc_exit_task;
 +	rpc_wake_up_queued_task(&task->tk_rqstp->rq_xprt->pending, task);
++=======
++>>>>>>> dcbbeda836bc (SUNRPC: Move RPC retransmission stat counter to xprt_transmit())
  }
  
  /*
* Unmerged path net/sunrpc/clnt.c
diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index eacde9249456..87f8dc88c95a 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -191,8 +191,6 @@ int xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task)
 		goto out_sleep;
 	}
 	xprt->snd_task = task;
-	if (req != NULL)
-		req->rq_ntrans++;
 
 	return 1;
 
@@ -247,7 +245,6 @@ int xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task)
 	}
 	if (__xprt_get_cong(xprt, task)) {
 		xprt->snd_task = task;
-		req->rq_ntrans++;
 		return 1;
 	}
 	xprt_clear_locked(xprt);
@@ -281,12 +278,8 @@ static inline int xprt_lock_write(struct rpc_xprt *xprt, struct rpc_task *task)
 static bool __xprt_lock_write_func(struct rpc_task *task, void *data)
 {
 	struct rpc_xprt *xprt = data;
-	struct rpc_rqst *req;
 
-	req = task->tk_rqstp;
 	xprt->snd_task = task;
-	if (req)
-		req->rq_ntrans++;
 	return true;
 }
 
@@ -1008,6 +1001,7 @@ void xprt_transmit(struct rpc_task *task)
 	struct rpc_rqst	*req = task->tk_rqstp;
 	struct rpc_xprt	*xprt = req->rq_xprt;
 	unsigned int connect_cookie;
+	int is_retrans = RPC_WAS_SENT(task);
 	int status;
 
 	dprintk("RPC: %5u xprt_transmit(%u)\n", task->tk_pid, req->rq_slen);
@@ -1039,14 +1033,25 @@ void xprt_transmit(struct rpc_task *task)
 	} else if (xprt_request_data_received(task) && !req->rq_bytes_sent)
 		return;
 
+	/*
+	 * Update req->rq_ntrans before transmitting to avoid races with
+	 * xprt_update_rtt(), which needs to know that it is recording a
+	 * reply to the first transmission.
+	 */
+	req->rq_ntrans++;
+
 	connect_cookie = xprt->connect_cookie;
 	status = xprt->ops->send_request(req, task);
 	trace_xprt_transmit(xprt, req->rq_xid, status);
 	if (status != 0) {
+		req->rq_ntrans--;
 		task->tk_status = status;
 		return;
 	}
 
+	if (is_retrans)
+		task->tk_client->cl_stats->rpcretrans++;
+
 	xprt_inject_disconnect(xprt);
 
 	dprintk("RPC: %5u xmit complete\n", task->tk_pid);
