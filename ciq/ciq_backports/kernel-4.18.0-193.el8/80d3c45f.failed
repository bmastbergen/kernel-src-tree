SUNRPC: Fix possible autodisconnect during connect due to old last_used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Dave Wysochanski <dwysocha@redhat.com>
commit 80d3c45fd765fbf4f10981b60ff6b1384bdbc706
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/80d3c45f.failed

Ensure last_used is updated before calling mod_timer inside
xprt_schedule_autodisconnect.  This avoids a possible xprt_autoclose
firing immediately after a successful connect when xprt_unlock_connect
calls xprt_schedule_autodisconnect with an old value of last_used.

	Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 80d3c45fd765fbf4f10981b60ff6b1384bdbc706)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprt.c
diff --cc net/sunrpc/xprt.c
index c4d4cd12e49e,70d6a1f10db9..000000000000
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@@ -682,7 -750,8 +682,12 @@@ static voi
  xprt_schedule_autodisconnect(struct rpc_xprt *xprt)
  	__must_hold(&xprt->transport_lock)
  {
++<<<<<<< HEAD
 +	if (list_empty(&xprt->recv) && xprt_has_timer(xprt))
++=======
+ 	xprt->last_used = jiffies;
+ 	if (RB_EMPTY_ROOT(&xprt->recv_queue) && xprt_has_timer(xprt))
++>>>>>>> 80d3c45fd765 (SUNRPC: Fix possible autodisconnect during connect due to old last_used)
  		mod_timer(&xprt->timer, xprt->last_used + xprt->idle_timeout);
  }
  
@@@ -1371,9 -1766,8 +1376,8 @@@ void xprt_release(struct rpc_task *task
  	xprt->ops->release_xprt(xprt, task);
  	if (xprt->ops->release_request)
  		xprt->ops->release_request(task);
- 	xprt->last_used = jiffies;
  	xprt_schedule_autodisconnect(xprt);
 -	spin_unlock(&xprt->transport_lock);
 +	spin_unlock_bh(&xprt->transport_lock);
  	if (req->rq_buffer)
  		xprt->ops->buf_free(task);
  	xprt_inject_disconnect(xprt);
* Unmerged path net/sunrpc/xprt.c
