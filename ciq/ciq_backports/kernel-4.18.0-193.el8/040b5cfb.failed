Fixed updating of ethertype in function skb_mpls_pop

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Martin Varghese <martin.varghese@nokia.com>
commit 040b5cfbcefa263ccf2c118c4938308606bb7ed8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/040b5cfb.failed

The skb_mpls_pop was not updating ethertype of an ethernet packet if the
packet was originally received from a non ARPHRD_ETHER device.

In the below OVS data path flow, since the device corresponding to port 7
is an l3 device (ARPHRD_NONE) the skb_mpls_pop function does not update
the ethertype of the packet even though the previous push_eth action had
added an ethernet header to the packet.

recirc_id(0),in_port(7),eth_type(0x8847),
mpls(label=12/0xfffff,tc=0/0,ttl=0/0x0,bos=1/1),
actions:push_eth(src=00:00:00:00:00:00,dst=00:00:00:00:00:00),
pop_mpls(eth_type=0x800),4

Fixes: ed246cee09b9 ("net: core: move pop MPLS functionality from OvS to core helper")
	Signed-off-by: Martin Varghese <martin.varghese@nokia.com>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 040b5cfbcefa263ccf2c118c4938308606bb7ed8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/skbuff.c
#	net/openvswitch/actions.c
#	net/sched/act_mpls.c
diff --cc include/linux/skbuff.h
index e1d0fa223b89,5aea72fe8498..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3436,7 -3528,12 +3436,16 @@@ int skb_ensure_writable(struct sk_buff 
  int __skb_vlan_pop(struct sk_buff *skb, u16 *vlan_tci);
  int skb_vlan_pop(struct sk_buff *skb);
  int skb_vlan_push(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci);
++<<<<<<< HEAD
 +int skb_mpls_push(struct sk_buff *skb, __be32 mpls_lse, __be16 mpls_proto);
++=======
+ int skb_mpls_push(struct sk_buff *skb, __be32 mpls_lse, __be16 mpls_proto,
+ 		  int mac_len);
+ int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto, int mac_len,
+ 		 bool ethernet);
+ int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse);
+ int skb_mpls_dec_ttl(struct sk_buff *skb);
++>>>>>>> 040b5cfbcefa (Fixed updating of ethertype in function skb_mpls_pop)
  struct sk_buff *pskb_extract(struct sk_buff *skb, int off, int to_copy,
  			     gfp_t gfp);
  
diff --cc net/core/skbuff.c
index 083b4d0722c0,312e80e86898..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -5402,6 -5524,113 +5402,116 @@@ int skb_mpls_push(struct sk_buff *skb, 
  EXPORT_SYMBOL_GPL(skb_mpls_push);
  
  /**
++<<<<<<< HEAD
++=======
+  * skb_mpls_pop() - pop the outermost MPLS header
+  *
+  * @skb: buffer
+  * @next_proto: ethertype of header after popped MPLS header
+  * @mac_len: length of the MAC header
+  * @ethernet: flag to indicate if ethernet header is present in packet
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto, int mac_len,
+ 		 bool ethernet)
+ {
+ 	int err;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return 0;
+ 
+ 	err = skb_ensure_writable(skb, mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	skb_postpull_rcsum(skb, mpls_hdr(skb), MPLS_HLEN);
+ 	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
+ 		mac_len);
+ 
+ 	__skb_pull(skb, MPLS_HLEN);
+ 	skb_reset_mac_header(skb);
+ 	skb_set_network_header(skb, mac_len);
+ 
+ 	if (ethernet) {
+ 		struct ethhdr *hdr;
+ 
+ 		/* use mpls_hdr() to get ethertype to account for VLANs. */
+ 		hdr = (struct ethhdr *)((void *)mpls_hdr(skb) - ETH_HLEN);
+ 		skb_mod_eth_type(skb, hdr, next_proto);
+ 	}
+ 	skb->protocol = next_proto;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_pop);
+ 
+ /**
+  * skb_mpls_update_lse() - modify outermost MPLS header and update csum
+  *
+  * @skb: buffer
+  * @mpls_lse: new MPLS label stack entry to update to
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse)
+ {
+ 	int err;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return -EINVAL;
+ 
+ 	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+ 		__be32 diff[] = { ~mpls_hdr(skb)->label_stack_entry, mpls_lse };
+ 
+ 		skb->csum = csum_partial((char *)diff, sizeof(diff), skb->csum);
+ 	}
+ 
+ 	mpls_hdr(skb)->label_stack_entry = mpls_lse;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_update_lse);
+ 
+ /**
+  * skb_mpls_dec_ttl() - decrement the TTL of the outermost MPLS header
+  *
+  * @skb: buffer
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_dec_ttl(struct sk_buff *skb)
+ {
+ 	u32 lse;
+ 	u8 ttl;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return -EINVAL;
+ 
+ 	lse = be32_to_cpu(mpls_hdr(skb)->label_stack_entry);
+ 	ttl = (lse & MPLS_LS_TTL_MASK) >> MPLS_LS_TTL_SHIFT;
+ 	if (!--ttl)
+ 		return -EINVAL;
+ 
+ 	lse &= ~MPLS_LS_TTL_MASK;
+ 	lse |= ttl << MPLS_LS_TTL_SHIFT;
+ 
+ 	return skb_mpls_update_lse(skb, cpu_to_be32(lse));
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_dec_ttl);
+ 
+ /**
++>>>>>>> 040b5cfbcefa (Fixed updating of ethertype in function skb_mpls_pop)
   * alloc_skb_with_frags - allocate skb with page frags
   *
   * @header_len: size of linear part
diff --cc net/openvswitch/actions.c
index c45ff6be42d0,91e210061bb3..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -199,31 -179,11 +199,37 @@@ static int pop_mpls(struct sk_buff *skb
  {
  	int err;
  
++<<<<<<< HEAD
 +	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
 +	if (unlikely(err))
++=======
+ 	err = skb_mpls_pop(skb, ethertype, skb->mac_len,
+ 			   ovs_key_mac_proto(key) == MAC_PROTO_ETHERNET);
+ 	if (err)
++>>>>>>> 040b5cfbcefa (Fixed updating of ethertype in function skb_mpls_pop)
  		return err;
  
 +	skb_postpull_rcsum(skb, mpls_hdr(skb), MPLS_HLEN);
 +
 +	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
 +		skb->mac_len);
 +
 +	__skb_pull(skb, MPLS_HLEN);
 +	skb_reset_mac_header(skb);
 +	skb_set_network_header(skb, skb->mac_len);
 +
 +	if (ovs_key_mac_proto(key) == MAC_PROTO_ETHERNET) {
 +		struct ethhdr *hdr;
 +
 +		/* mpls_hdr() is used to locate the ethertype field correctly in the
 +		 * presence of VLAN tags.
 +		 */
 +		hdr = (struct ethhdr *)((void *)mpls_hdr(skb) - ETH_HLEN);
 +		update_ethertype(skb, hdr, ethertype);
 +	}
 +	if (eth_p_mpls(skb->protocol))
 +		skb->protocol = ethertype;
 +
  	invalidate_flow_key(key);
  	return 0;
  }
* Unmerged path net/sched/act_mpls.c
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/skbuff.c
* Unmerged path net/openvswitch/actions.c
* Unmerged path net/sched/act_mpls.c
