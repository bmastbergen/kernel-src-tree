bpf: Allow narrow loads of bpf_sysctl fields with offset > 0

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Ilya Leoshkevich <iii@linux.ibm.com>
commit 7541c87c9b7a7e07c84481f37f2c19063b44469b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7541c87c.failed

"ctx:file_pos sysctl:read read ok narrow" works on s390 by accident: it
reads the wrong byte, which happens to have the expected value of 0.
Improve the test by seeking to the 4th byte and expecting 4 instead of
0.

This makes the latent problem apparent: the test attempts to read the
first byte of bpf_sysctl.file_pos, assuming this is the least-significant
byte, which is not the case on big-endian machines: a non-zero offset is
needed.

The point of the test is to verify narrow loads, so we cannot cheat our
way out by simply using BPF_W. The existence of the test means that such
loads have to be supported, most likely because llvm can generate them.
Fix the test by adding a big-endian variant, which uses an offset to
access the least-significant byte of bpf_sysctl.file_pos.

This reveals the final problem: verifier rejects accesses to bpf_sysctl
fields with offset > 0. Such accesses are already allowed for a wide
range of structs: __sk_buff, bpf_sock_addr and sk_msg_md to name a few.
Extend this support to bpf_sysctl by using bpf_ctx_range instead of
offsetof when matching field offsets.

Fixes: 7b146cebe30c ("bpf: Sysctl hook")
Fixes: e1550bfe0de4 ("bpf: Add file_pos field to bpf_sysctl ctx")
Fixes: 9a1027e52535 ("selftests/bpf: Test file_pos field in bpf_sysctl ctx")
	Signed-off-by: Ilya Leoshkevich <iii@linux.ibm.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrey Ignatov <rdna@fb.com>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20191028122902.9763-1-iii@linux.ibm.com
(cherry picked from commit 7541c87c9b7a7e07c84481f37f2c19063b44469b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/cgroup.c
#	tools/testing/selftests/bpf/test_sysctl.c
diff --cc kernel/bpf/cgroup.c
index 2dc2cddbbfde,a3eaf08e7dd3..000000000000
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@@ -832,3 -846,707 +832,710 @@@ const struct bpf_verifier_ops cg_dev_ve
  	.get_func_proto		= cgroup_dev_func_proto,
  	.is_valid_access	= cgroup_dev_is_valid_access,
  };
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * __cgroup_bpf_run_filter_sysctl - Run a program on sysctl
+  *
+  * @head: sysctl table header
+  * @table: sysctl table
+  * @write: sysctl is being read (= 0) or written (= 1)
+  * @buf: pointer to buffer passed by user space
+  * @pcount: value-result argument: value is size of buffer pointed to by @buf,
+  *	result is size of @new_buf if program set new value, initial value
+  *	otherwise
+  * @ppos: value-result argument: value is position at which read from or write
+  *	to sysctl is happening, result is new position if program overrode it,
+  *	initial value otherwise
+  * @new_buf: pointer to pointer to new buffer that will be allocated if program
+  *	overrides new value provided by user space on sysctl write
+  *	NOTE: it's caller responsibility to free *new_buf if it was set
+  * @type: type of program to be executed
+  *
+  * Program is run when sysctl is being accessed, either read or written, and
+  * can allow or deny such access.
+  *
+  * This function will return %-EPERM if an attached program is found and
+  * returned value != 1 during execution. In all other cases 0 is returned.
+  */
+ int __cgroup_bpf_run_filter_sysctl(struct ctl_table_header *head,
+ 				   struct ctl_table *table, int write,
+ 				   void __user *buf, size_t *pcount,
+ 				   loff_t *ppos, void **new_buf,
+ 				   enum bpf_attach_type type)
+ {
+ 	struct bpf_sysctl_kern ctx = {
+ 		.head = head,
+ 		.table = table,
+ 		.write = write,
+ 		.ppos = ppos,
+ 		.cur_val = NULL,
+ 		.cur_len = PAGE_SIZE,
+ 		.new_val = NULL,
+ 		.new_len = 0,
+ 		.new_updated = 0,
+ 	};
+ 	struct cgroup *cgrp;
+ 	int ret;
+ 
+ 	ctx.cur_val = kmalloc_track_caller(ctx.cur_len, GFP_KERNEL);
+ 	if (ctx.cur_val) {
+ 		mm_segment_t old_fs;
+ 		loff_t pos = 0;
+ 
+ 		old_fs = get_fs();
+ 		set_fs(KERNEL_DS);
+ 		if (table->proc_handler(table, 0, (void __user *)ctx.cur_val,
+ 					&ctx.cur_len, &pos)) {
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.cur_len = 0;
+ 		}
+ 		set_fs(old_fs);
+ 	} else {
+ 		/* Let BPF program decide how to proceed. */
+ 		ctx.cur_len = 0;
+ 	}
+ 
+ 	if (write && buf && *pcount) {
+ 		/* BPF program should be able to override new value with a
+ 		 * buffer bigger than provided by user.
+ 		 */
+ 		ctx.new_val = kmalloc_track_caller(PAGE_SIZE, GFP_KERNEL);
+ 		ctx.new_len = min_t(size_t, PAGE_SIZE, *pcount);
+ 		if (!ctx.new_val ||
+ 		    copy_from_user(ctx.new_val, buf, ctx.new_len))
+ 			/* Let BPF program decide how to proceed. */
+ 			ctx.new_len = 0;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	cgrp = task_dfl_cgroup(current);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[type], &ctx, BPF_PROG_RUN);
+ 	rcu_read_unlock();
+ 
+ 	kfree(ctx.cur_val);
+ 
+ 	if (ret == 1 && ctx.new_updated) {
+ 		*new_buf = ctx.new_val;
+ 		*pcount = ctx.new_len;
+ 	} else {
+ 		kfree(ctx.new_val);
+ 	}
+ 
+ 	return ret == 1 ? 0 : -EPERM;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_sysctl);
+ 
+ #ifdef CONFIG_NET
+ static bool __cgroup_bpf_prog_array_is_empty(struct cgroup *cgrp,
+ 					     enum bpf_attach_type attach_type)
+ {
+ 	struct bpf_prog_array *prog_array;
+ 	bool empty;
+ 
+ 	rcu_read_lock();
+ 	prog_array = rcu_dereference(cgrp->bpf.effective[attach_type]);
+ 	empty = bpf_prog_array_is_empty(prog_array);
+ 	rcu_read_unlock();
+ 
+ 	return empty;
+ }
+ 
+ static int sockopt_alloc_buf(struct bpf_sockopt_kern *ctx, int max_optlen)
+ {
+ 	if (unlikely(max_optlen > PAGE_SIZE) || max_optlen < 0)
+ 		return -EINVAL;
+ 
+ 	ctx->optval = kzalloc(max_optlen, GFP_USER);
+ 	if (!ctx->optval)
+ 		return -ENOMEM;
+ 
+ 	ctx->optval_end = ctx->optval + max_optlen;
+ 
+ 	return 0;
+ }
+ 
+ static void sockopt_free_buf(struct bpf_sockopt_kern *ctx)
+ {
+ 	kfree(ctx->optval);
+ }
+ 
+ int __cgroup_bpf_run_filter_setsockopt(struct sock *sk, int *level,
+ 				       int *optname, char __user *optval,
+ 				       int *optlen, char **kernel_optval)
+ {
+ 	struct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);
+ 	struct bpf_sockopt_kern ctx = {
+ 		.sk = sk,
+ 		.level = *level,
+ 		.optname = *optname,
+ 	};
+ 	int ret, max_optlen;
+ 
+ 	/* Opportunistic check to see whether we have any BPF program
+ 	 * attached to the hook so we don't waste time allocating
+ 	 * memory and locking the socket.
+ 	 */
+ 	if (!cgroup_bpf_enabled ||
+ 	    __cgroup_bpf_prog_array_is_empty(cgrp, BPF_CGROUP_SETSOCKOPT))
+ 		return 0;
+ 
+ 	/* Allocate a bit more than the initial user buffer for
+ 	 * BPF program. The canonical use case is overriding
+ 	 * TCP_CONGESTION(nv) to TCP_CONGESTION(cubic).
+ 	 */
+ 	max_optlen = max_t(int, 16, *optlen);
+ 
+ 	ret = sockopt_alloc_buf(&ctx, max_optlen);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ctx.optlen = *optlen;
+ 
+ 	if (copy_from_user(ctx.optval, optval, *optlen) != 0) {
+ 		ret = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	lock_sock(sk);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[BPF_CGROUP_SETSOCKOPT],
+ 				 &ctx, BPF_PROG_RUN);
+ 	release_sock(sk);
+ 
+ 	if (!ret) {
+ 		ret = -EPERM;
+ 		goto out;
+ 	}
+ 
+ 	if (ctx.optlen == -1) {
+ 		/* optlen set to -1, bypass kernel */
+ 		ret = 1;
+ 	} else if (ctx.optlen > max_optlen || ctx.optlen < -1) {
+ 		/* optlen is out of bounds */
+ 		ret = -EFAULT;
+ 	} else {
+ 		/* optlen within bounds, run kernel handler */
+ 		ret = 0;
+ 
+ 		/* export any potential modifications */
+ 		*level = ctx.level;
+ 		*optname = ctx.optname;
+ 		*optlen = ctx.optlen;
+ 		*kernel_optval = ctx.optval;
+ 	}
+ 
+ out:
+ 	if (ret)
+ 		sockopt_free_buf(&ctx);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_setsockopt);
+ 
+ int __cgroup_bpf_run_filter_getsockopt(struct sock *sk, int level,
+ 				       int optname, char __user *optval,
+ 				       int __user *optlen, int max_optlen,
+ 				       int retval)
+ {
+ 	struct cgroup *cgrp = sock_cgroup_ptr(&sk->sk_cgrp_data);
+ 	struct bpf_sockopt_kern ctx = {
+ 		.sk = sk,
+ 		.level = level,
+ 		.optname = optname,
+ 		.retval = retval,
+ 	};
+ 	int ret;
+ 
+ 	/* Opportunistic check to see whether we have any BPF program
+ 	 * attached to the hook so we don't waste time allocating
+ 	 * memory and locking the socket.
+ 	 */
+ 	if (!cgroup_bpf_enabled ||
+ 	    __cgroup_bpf_prog_array_is_empty(cgrp, BPF_CGROUP_GETSOCKOPT))
+ 		return retval;
+ 
+ 	ret = sockopt_alloc_buf(&ctx, max_optlen);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ctx.optlen = max_optlen;
+ 
+ 	if (!retval) {
+ 		/* If kernel getsockopt finished successfully,
+ 		 * copy whatever was returned to the user back
+ 		 * into our temporary buffer. Set optlen to the
+ 		 * one that kernel returned as well to let
+ 		 * BPF programs inspect the value.
+ 		 */
+ 
+ 		if (get_user(ctx.optlen, optlen)) {
+ 			ret = -EFAULT;
+ 			goto out;
+ 		}
+ 
+ 		if (ctx.optlen > max_optlen)
+ 			ctx.optlen = max_optlen;
+ 
+ 		if (copy_from_user(ctx.optval, optval, ctx.optlen) != 0) {
+ 			ret = -EFAULT;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	lock_sock(sk);
+ 	ret = BPF_PROG_RUN_ARRAY(cgrp->bpf.effective[BPF_CGROUP_GETSOCKOPT],
+ 				 &ctx, BPF_PROG_RUN);
+ 	release_sock(sk);
+ 
+ 	if (!ret) {
+ 		ret = -EPERM;
+ 		goto out;
+ 	}
+ 
+ 	if (ctx.optlen > max_optlen) {
+ 		ret = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	/* BPF programs only allowed to set retval to 0, not some
+ 	 * arbitrary value.
+ 	 */
+ 	if (ctx.retval != 0 && ctx.retval != retval) {
+ 		ret = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	if (copy_to_user(optval, ctx.optval, ctx.optlen) ||
+ 	    put_user(ctx.optlen, optlen)) {
+ 		ret = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	ret = ctx.retval;
+ 
+ out:
+ 	sockopt_free_buf(&ctx);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(__cgroup_bpf_run_filter_getsockopt);
+ #endif
+ 
+ static ssize_t sysctl_cpy_dir(const struct ctl_dir *dir, char **bufp,
+ 			      size_t *lenp)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (dir->header.parent) {
+ 		tmp_ret = sysctl_cpy_dir(dir->header.parent, bufp, lenp);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(*bufp, dir->header.ctl_table[0].procname, *lenp);
+ 	if (ret < 0)
+ 		return ret;
+ 	*bufp += ret;
+ 	*lenp -= ret;
+ 	ret += tmp_ret;
+ 
+ 	/* Avoid leading slash. */
+ 	if (!ret)
+ 		return ret;
+ 
+ 	tmp_ret = strscpy(*bufp, "/", *lenp);
+ 	if (tmp_ret < 0)
+ 		return tmp_ret;
+ 	*bufp += tmp_ret;
+ 	*lenp -= tmp_ret;
+ 
+ 	return ret + tmp_ret;
+ }
+ 
+ BPF_CALL_4(bpf_sysctl_get_name, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len, u64, flags)
+ {
+ 	ssize_t tmp_ret = 0, ret;
+ 
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (!(flags & BPF_F_SYSCTL_BASE_NAME)) {
+ 		if (!ctx->head)
+ 			return -EINVAL;
+ 		tmp_ret = sysctl_cpy_dir(ctx->head->parent, &buf, &buf_len);
+ 		if (tmp_ret < 0)
+ 			return tmp_ret;
+ 	}
+ 
+ 	ret = strscpy(buf, ctx->table->procname, buf_len);
+ 
+ 	return ret < 0 ? ret : tmp_ret + ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_name_proto = {
+ 	.func		= bpf_sysctl_get_name,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ static int copy_sysctl_value(char *dst, size_t dst_len, char *src,
+ 			     size_t src_len)
+ {
+ 	if (!dst)
+ 		return -EINVAL;
+ 
+ 	if (!dst_len)
+ 		return -E2BIG;
+ 
+ 	if (!src || !src_len) {
+ 		memset(dst, 0, dst_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	memcpy(dst, src, min(dst_len, src_len));
+ 
+ 	if (dst_len > src_len) {
+ 		memset(dst + src_len, '\0', dst_len - src_len);
+ 		return src_len;
+ 	}
+ 
+ 	dst[dst_len - 1] = '\0';
+ 
+ 	return -E2BIG;
+ }
+ 
+ BPF_CALL_3(bpf_sysctl_get_current_value, struct bpf_sysctl_kern *, ctx,
+ 	   char *, buf, size_t, buf_len)
+ {
+ 	return copy_sysctl_value(buf, buf_len, ctx->cur_val, ctx->cur_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_current_value_proto = {
+ 	.func		= bpf_sysctl_get_current_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_get_new_value, struct bpf_sysctl_kern *, ctx, char *, buf,
+ 	   size_t, buf_len)
+ {
+ 	if (!ctx->write) {
+ 		if (buf && buf_len)
+ 			memset(buf, '\0', buf_len);
+ 		return -EINVAL;
+ 	}
+ 	return copy_sysctl_value(buf, buf_len, ctx->new_val, ctx->new_len);
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_get_new_value_proto = {
+ 	.func		= bpf_sysctl_get_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_3(bpf_sysctl_set_new_value, struct bpf_sysctl_kern *, ctx,
+ 	   const char *, buf, size_t, buf_len)
+ {
+ 	if (!ctx->write || !ctx->new_val || !ctx->new_len || !buf || !buf_len)
+ 		return -EINVAL;
+ 
+ 	if (buf_len > PAGE_SIZE - 1)
+ 		return -E2BIG;
+ 
+ 	memcpy(ctx->new_val, buf, buf_len);
+ 	ctx->new_len = buf_len;
+ 	ctx->new_updated = 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_sysctl_set_new_value_proto = {
+ 	.func		= bpf_sysctl_set_new_value,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ sysctl_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_strtol:
+ 		return &bpf_strtol_proto;
+ 	case BPF_FUNC_strtoul:
+ 		return &bpf_strtoul_proto;
+ 	case BPF_FUNC_sysctl_get_name:
+ 		return &bpf_sysctl_get_name_proto;
+ 	case BPF_FUNC_sysctl_get_current_value:
+ 		return &bpf_sysctl_get_current_value_proto;
+ 	case BPF_FUNC_sysctl_get_new_value:
+ 		return &bpf_sysctl_get_new_value_proto;
+ 	case BPF_FUNC_sysctl_set_new_value:
+ 		return &bpf_sysctl_set_new_value_proto;
+ 	default:
+ 		return cgroup_base_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool sysctl_is_valid_access(int off, int size, enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off + size > sizeof(struct bpf_sysctl) || off % size)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct bpf_sysctl, write):
+ 		if (type != BPF_READ)
+ 			return false;
+ 		bpf_ctx_record_field_size(info, size_default);
+ 		return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 	case bpf_ctx_range(struct bpf_sysctl, file_pos):
+ 		if (type == BPF_READ) {
+ 			bpf_ctx_record_field_size(info, size_default);
+ 			return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 		} else {
+ 			return size == size_default;
+ 		}
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static u32 sysctl_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	u32 read_size;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sysctl, write):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct bpf_sysctl_kern, write,
+ 				       FIELD_SIZEOF(struct bpf_sysctl_kern,
+ 						    write),
+ 				       target_size));
+ 		break;
+ 	case offsetof(struct bpf_sysctl, file_pos):
+ 		/* ppos is a pointer so it should be accessed via indirect
+ 		 * loads and stores. Also for stores additional temporary
+ 		 * register is used since neither src_reg nor dst_reg can be
+ 		 * overridden.
+ 		 */
+ 		if (type == BPF_WRITE) {
+ 			int treg = BPF_REG_9;
+ 
+ 			if (si->src_reg == treg || si->dst_reg == treg)
+ 				--treg;
+ 			if (si->src_reg == treg || si->dst_reg == treg)
+ 				--treg;
+ 			*insn++ = BPF_STX_MEM(
+ 				BPF_DW, si->dst_reg, treg,
+ 				offsetof(struct bpf_sysctl_kern, tmp_reg));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),
+ 				treg, si->dst_reg,
+ 				offsetof(struct bpf_sysctl_kern, ppos));
+ 			*insn++ = BPF_STX_MEM(
+ 				BPF_SIZEOF(u32), treg, si->src_reg,
+ 				bpf_ctx_narrow_access_offset(
+ 					0, sizeof(u32), sizeof(loff_t)));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_DW, treg, si->dst_reg,
+ 				offsetof(struct bpf_sysctl_kern, tmp_reg));
+ 		} else {
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_FIELD_SIZEOF(struct bpf_sysctl_kern, ppos),
+ 				si->dst_reg, si->src_reg,
+ 				offsetof(struct bpf_sysctl_kern, ppos));
+ 			read_size = bpf_size_to_bytes(BPF_SIZE(si->code));
+ 			*insn++ = BPF_LDX_MEM(
+ 				BPF_SIZE(si->code), si->dst_reg, si->dst_reg,
+ 				bpf_ctx_narrow_access_offset(
+ 					0, read_size, sizeof(loff_t)));
+ 		}
+ 		*target_size = sizeof(u32);
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ const struct bpf_verifier_ops cg_sysctl_verifier_ops = {
+ 	.get_func_proto		= sysctl_func_proto,
+ 	.is_valid_access	= sysctl_is_valid_access,
+ 	.convert_ctx_access	= sysctl_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sysctl_prog_ops = {
+ };
+ 
+ static const struct bpf_func_proto *
+ cg_sockopt_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ #ifdef CONFIG_NET
+ 	case BPF_FUNC_sk_storage_get:
+ 		return &bpf_sk_storage_get_proto;
+ 	case BPF_FUNC_sk_storage_delete:
+ 		return &bpf_sk_storage_delete_proto;
+ #endif
+ #ifdef CONFIG_INET
+ 	case BPF_FUNC_tcp_sock:
+ 		return &bpf_tcp_sock_proto;
+ #endif
+ 	default:
+ 		return cgroup_base_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool cg_sockopt_is_valid_access(int off, int size,
+ 				       enum bpf_access_type type,
+ 				       const struct bpf_prog *prog,
+ 				       struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off >= sizeof(struct bpf_sockopt))
+ 		return false;
+ 
+ 	if (off % size != 0)
+ 		return false;
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case offsetof(struct bpf_sockopt, retval):
+ 			if (size != size_default)
+ 				return false;
+ 			return prog->expected_attach_type ==
+ 				BPF_CGROUP_GETSOCKOPT;
+ 		case offsetof(struct bpf_sockopt, optname):
+ 			/* fallthrough */
+ 		case offsetof(struct bpf_sockopt, level):
+ 			if (size != size_default)
+ 				return false;
+ 			return prog->expected_attach_type ==
+ 				BPF_CGROUP_SETSOCKOPT;
+ 		case offsetof(struct bpf_sockopt, optlen):
+ 			return size == size_default;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case offsetof(struct bpf_sockopt, sk):
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		info->reg_type = PTR_TO_SOCKET;
+ 		break;
+ 	case offsetof(struct bpf_sockopt, optval):
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case offsetof(struct bpf_sockopt, optval_end):
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	case offsetof(struct bpf_sockopt, retval):
+ 		if (size != size_default)
+ 			return false;
+ 		return prog->expected_attach_type == BPF_CGROUP_GETSOCKOPT;
+ 	default:
+ 		if (size != size_default)
+ 			return false;
+ 		break;
+ 	}
+ 	return true;
+ }
+ 
+ #define CG_SOCKOPT_ACCESS_FIELD(T, F)					\
+ 	T(BPF_FIELD_SIZEOF(struct bpf_sockopt_kern, F),			\
+ 	  si->dst_reg, si->src_reg,					\
+ 	  offsetof(struct bpf_sockopt_kern, F))
+ 
+ static u32 cg_sockopt_convert_ctx_access(enum bpf_access_type type,
+ 					 const struct bpf_insn *si,
+ 					 struct bpf_insn *insn_buf,
+ 					 struct bpf_prog *prog,
+ 					 u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sockopt, sk):
+ 		*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, sk);
+ 		break;
+ 	case offsetof(struct bpf_sockopt, level):
+ 		if (type == BPF_WRITE)
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, level);
+ 		else
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, level);
+ 		break;
+ 	case offsetof(struct bpf_sockopt, optname):
+ 		if (type == BPF_WRITE)
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, optname);
+ 		else
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optname);
+ 		break;
+ 	case offsetof(struct bpf_sockopt, optlen):
+ 		if (type == BPF_WRITE)
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, optlen);
+ 		else
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optlen);
+ 		break;
+ 	case offsetof(struct bpf_sockopt, retval):
+ 		if (type == BPF_WRITE)
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_STX_MEM, retval);
+ 		else
+ 			*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, retval);
+ 		break;
+ 	case offsetof(struct bpf_sockopt, optval):
+ 		*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optval);
+ 		break;
+ 	case offsetof(struct bpf_sockopt, optval_end):
+ 		*insn++ = CG_SOCKOPT_ACCESS_FIELD(BPF_LDX_MEM, optval_end);
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static int cg_sockopt_get_prologue(struct bpf_insn *insn_buf,
+ 				   bool direct_write,
+ 				   const struct bpf_prog *prog)
+ {
+ 	/* Nothing to do for sockopt argument. The data is kzalloc'ated.
+ 	 */
+ 	return 0;
+ }
+ 
+ const struct bpf_verifier_ops cg_sockopt_verifier_ops = {
+ 	.get_func_proto		= cg_sockopt_func_proto,
+ 	.is_valid_access	= cg_sockopt_is_valid_access,
+ 	.convert_ctx_access	= cg_sockopt_convert_ctx_access,
+ 	.gen_prologue		= cg_sockopt_get_prologue,
+ };
+ 
+ const struct bpf_prog_ops cg_sockopt_prog_ops = {
+ };
++>>>>>>> 7541c87c9b7a (bpf: Allow narrow loads of bpf_sysctl fields with offset > 0)
* Unmerged path tools/testing/selftests/bpf/test_sysctl.c
* Unmerged path kernel/bpf/cgroup.c
* Unmerged path tools/testing/selftests/bpf/test_sysctl.c
