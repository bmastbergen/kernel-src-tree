RDMA/mlx5: Move to single device multiport ports in switchdev mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Mark Bloch <markb@mellanox.com>
commit 26628e2d58c910fa724312c6bcc3f4d12c9e805e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/26628e2d.failed

Move from IB device (representor) per virtual function to single IB device
with port per virtual function (port 1 represents the uplink). As number
of ports is a static property of an IB device, declare the IB device with
as many port as the possible according to the PCI bus.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 26628e2d58c910fa724312c6bcc3f4d12c9e805e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/ib_rep.c
diff --cc drivers/infiniband/hw/mlx5/ib_rep.c
index 95ac97af6166,224ef6c88d17..000000000000
--- a/drivers/infiniband/hw/mlx5/ib_rep.c
+++ b/drivers/infiniband/hw/mlx5/ib_rep.c
@@@ -46,42 -47,57 +46,89 @@@ static const struct mlx5_ib_profile rep
  };
  
  static int
++<<<<<<< HEAD
 +mlx5_ib_nic_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
 +{
 +	struct mlx5_ib_dev *ibdev;
 +
 +	ibdev = mlx5_ib_rep_to_dev(rep);
 +	if (!__mlx5_ib_add(ibdev, ibdev->profile))
 +		return -EINVAL;
 +	return 0;
 +}
 +
 +static void
 +mlx5_ib_nic_rep_unload(struct mlx5_eswitch_rep *rep)
 +{
 +	struct mlx5_ib_dev *ibdev;
 +
 +	ibdev = mlx5_ib_rep_to_dev(rep);
 +	__mlx5_ib_remove(ibdev, ibdev->profile, MLX5_IB_STAGE_MAX);
 +}
 +
 +static int
 +mlx5_ib_vport_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
 +{
 +	struct mlx5_ib_dev *ibdev;
++=======
+ mlx5_ib_set_vport_rep(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
+ {
+ 	struct mlx5_ib_dev *ibdev;
+ 	int vport_index;
+ 
+ 	ibdev = mlx5_ib_get_uplink_ibdev(dev->priv.eswitch);
+ 	vport_index = ibdev->free_port++;
+ 
+ 	ibdev->port[vport_index].rep = rep;
+ 	write_lock(&ibdev->port[vport_index].roce.netdev_lock);
+ 	ibdev->port[vport_index].roce.netdev =
+ 		mlx5_ib_get_rep_netdev(dev->priv.eswitch, rep->vport);
+ 	write_unlock(&ibdev->port[vport_index].roce.netdev_lock);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlx5_ib_vport_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
+ {
+ 	int num_ports = MLX5_TOTAL_VPORTS(dev);
+ 	const struct mlx5_ib_profile *profile;
+ 	struct mlx5_ib_dev *ibdev;
+ 	int vport_index;
+ 
+ 	if (rep->vport == MLX5_VPORT_UPLINK)
+ 		profile = &uplink_rep_profile;
+ 	else
+ 		return mlx5_ib_set_vport_rep(dev, rep);
++>>>>>>> 26628e2d58c9 (RDMA/mlx5: Move to single device multiport ports in switchdev mode)
  
  	ibdev = ib_alloc_device(mlx5_ib_dev, ib_dev);
  	if (!ibdev)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ibdev->rep = rep;
++=======
+ 	ibdev->port = kcalloc(num_ports, sizeof(*ibdev->port),
+ 			      GFP_KERNEL);
+ 	if (!ibdev->port) {
+ 		ib_dealloc_device(&ibdev->ib_dev);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ibdev->is_rep = true;
+ 	vport_index = ibdev->free_port++;
+ 	ibdev->port[vport_index].rep = rep;
+ 	ibdev->port[vport_index].roce.netdev =
+ 		mlx5_ib_get_rep_netdev(dev->priv.eswitch, rep->vport);
++>>>>>>> 26628e2d58c9 (RDMA/mlx5: Move to single device multiport ports in switchdev mode)
  	ibdev->mdev = dev;
 -	ibdev->num_ports = num_ports;
 -
 -	if (!__mlx5_ib_add(ibdev, profile))
 +	ibdev->num_ports = max(MLX5_CAP_GEN(dev, num_ports),
 +			       MLX5_CAP_GEN(dev, num_vhca_ports));
 +	if (!__mlx5_ib_add(ibdev, &rep_profile)) {
 +		ib_dealloc_device(&ibdev->ib_dev);
  		return -EINVAL;
 +	}
  
  	rep->rep_if[REP_IB].priv = ibdev;
  
* Unmerged path drivers/infiniband/hw/mlx5/ib_rep.c
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 245cb37cd76b..64d78ef46196 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -479,9 +479,14 @@ static int mlx5_query_port_roce(struct ib_device *device, u8 port_num,
 
 	/* Possible bad flows are checked before filling out props so in case
 	 * of an error it will still be zeroed out.
+	 * Use native port in case of reps
 	 */
-	err = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN,
-				   mdev_port_num);
+	if (dev->is_rep)
+		err = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN,
+					   1);
+	else
+		err = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN,
+					   mdev_port_num);
 	if (err)
 		goto out;
 	ext = MLX5_CAP_PCAM_FEATURE(dev->mdev, ptys_extended_ethernet);
@@ -1409,7 +1414,9 @@ static int mlx5_ib_rep_query_port(struct ib_device *ibdev, u8 port,
 {
 	int ret;
 
-	/* Only link layer == ethernet is valid for representors */
+	/* Only link layer == ethernet is valid for representors
+	 * and we always use port 1
+	 */
 	ret = mlx5_query_port_roce(ibdev, port, props);
 	if (ret || !props)
 		return ret;
@@ -4557,7 +4564,7 @@ static void get_ext_port_caps(struct mlx5_ib_dev *dev)
 		mlx5_query_ext_port_caps(dev, port);
 }
 
-static int get_port_caps(struct mlx5_ib_dev *dev, u8 port)
+static int __get_port_caps(struct mlx5_ib_dev *dev, u8 port)
 {
 	struct ib_device_attr *dprops = NULL;
 	struct ib_port_attr *pprops = NULL;
@@ -4600,6 +4607,16 @@ static int get_port_caps(struct mlx5_ib_dev *dev, u8 port)
 	return err;
 }
 
+static int get_port_caps(struct mlx5_ib_dev *dev, u8 port)
+{
+	/* For representors use port 1, is this is the only native
+	 * port
+	 */
+	if (dev->is_rep)
+		return __get_port_caps(dev, 1);
+	return __get_port_caps(dev, port);
+}
+
 static void destroy_umrc_res(struct mlx5_ib_dev *dev)
 {
 	int err;
@@ -6174,6 +6191,7 @@ static int mlx5_ib_stage_common_roce_init(struct mlx5_ib_dev *dev)
 
 	port_num = mlx5_core_native_port_num(dev->mdev) - 1;
 
+	/* Register only for native ports */
 	return mlx5_add_netdev_notifier(dev, port_num);
 }
 
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index d77f0cb4a75e..b0d862b982f5 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -954,6 +954,7 @@ struct mlx5_ib_dev {
 	u16			devx_whitelist_uid;
 	struct mlx5_srq_table   srq_table;
 	struct mlx5_async_ctx   async_ctx;
+	int			free_port;
 };
 
 static inline struct mlx5_ib_cq *to_mibcq(struct mlx5_core_cq *mcq)
