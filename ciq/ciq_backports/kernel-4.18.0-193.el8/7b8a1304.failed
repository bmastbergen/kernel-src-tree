bpf: when doing BPF_PROG_TEST_RUN for flow dissector use no-skb mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 7b8a1304323b35bbf060e0d29691031056836b73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7b8a1304.failed

Now that we have bpf_flow_dissect which can work on raw data,
use it when doing BPF_PROG_TEST_RUN for flow dissector.

Simplifies bpf_prog_test_run_flow_dissector and allows us to
test no-skb mode.

Note, that previously, with bpf_flow_dissect_skb we used to call
eth_type_trans which pulled L2 (ETH_HLEN) header and we explicitly called
skb_reset_network_header. That means flow_keys->nhoff would be
initialized to 0 (skb_network_offset) in init_flow_keys.
Now we call bpf_flow_dissect with nhoff set to ETH_HLEN and need
to undo it once the dissection is done to preserve the existing behavior.

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 7b8a1304323b35bbf060e0d29691031056836b73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bpf/test_run.c
diff --cc net/bpf/test_run.c
index 2221573dacdb,db2ec88ab129..000000000000
--- a/net/bpf/test_run.c
+++ b/net/bpf/test_run.c
@@@ -382,10 -383,8 +383,12 @@@ int bpf_prog_test_run_flow_dissector(st
  	u32 repeat = kattr->test.repeat;
  	struct bpf_flow_keys flow_keys;
  	u64 time_start, time_spent = 0;
++<<<<<<< HEAD
 +	struct bpf_skb_data_end *cb;
++=======
+ 	const struct ethhdr *eth;
++>>>>>>> 7b8a1304323b (bpf: when doing BPF_PROG_TEST_RUN for flow dissector use no-skb mode)
  	u32 retval, duration;
- 	struct sk_buff *skb;
- 	struct sock *sk;
  	void *data;
  	int ret;
  	u32 i;
@@@ -401,31 -402,8 +406,11 @@@
  	if (IS_ERR(data))
  		return PTR_ERR(data);
  
- 	sk = kzalloc(sizeof(*sk), GFP_USER);
- 	if (!sk) {
- 		kfree(data);
- 		return -ENOMEM;
- 	}
- 	sock_net_set(sk, current->nsproxy->net_ns);
- 	sock_init_data(NULL, sk);
- 
- 	skb = build_skb(data, 0);
- 	if (!skb) {
- 		kfree(data);
- 		kfree(sk);
- 		return -ENOMEM;
- 	}
- 	skb->sk = sk;
- 
- 	skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);
- 	__skb_put(skb, size);
- 	skb->protocol = eth_type_trans(skb,
- 				       current->nsproxy->net_ns->loopback_dev);
- 	skb_reset_network_header(skb);
+ 	eth = (struct ethhdr *)data;
  
 +	cb = (struct bpf_skb_data_end *)skb->cb;
 +	cb->qdisc_cb.flow_keys = &flow_keys;
 +
  	if (!repeat)
  		repeat = 1;
  
* Unmerged path net/bpf/test_run.c
