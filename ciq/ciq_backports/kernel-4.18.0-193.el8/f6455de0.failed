net/mlx5: E-Switch, Refactor eswitch SR-IOV interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Refactor eswitch SR-IOV interface (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 96.08%
commit-author Bodong Wang <bodong@mellanox.com>
commit f6455de0b0e52dcb11aeb503151b12ec87f9c5e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f6455de0.failed

Devlink eswitch mode is not necessarily related to SR-IOV, e.g, ECPF
can be at offload mode when SR-IOV is not enabled.

Rename the interface and eswitch mode names to decouple from SR-IOV,
and cleanup eswitch messages accordingly.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f6455de0b0e52dcb11aeb503151b12ec87f9c5e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 53992d0700dc,798aa5e0941e..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -6613,6 -6812,14 +6613,16 @@@ static void *mlx5_ib_add(struct mlx5_co
  
  	printk_once(KERN_INFO "%s", mlx5_version);
  
++<<<<<<< HEAD
++=======
+ 	if (MLX5_ESWITCH_MANAGER(mdev) &&
+ 	    mlx5_ib_eswitch_mode(mdev->priv.eswitch) == MLX5_ESWITCH_OFFLOADS) {
+ 		if (!mlx5_core_mp_enabled(mdev))
+ 			mlx5_ib_register_vport_reps(mdev);
+ 		return mdev;
+ 	}
+ 
++>>>>>>> f6455de0b0e5 (net/mlx5: E-Switch, Refactor eswitch SR-IOV interface)
  	port_type_cap = MLX5_CAP_GEN(mdev, port_type);
  	ll = mlx5_port_type_cap_to_rdma_ll(port_type_cap);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index f4a0b22e3987,b42540e1ba6e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1548,13 -1562,22 +1548,13 @@@ static void esw_apply_vport_conf(struc
  				      MLX5_VPORT_STATE_OP_MOD_ESW_VPORT,
  				      vport_num, 1,
  				      vport->info.link_state);
 -
 -	/* Host PF has its own mac/guid. */
 -	if (vport_num) {
 -		mlx5_modify_nic_vport_mac_address(esw->dev, vport_num,
 -						  vport->info.mac);
 -		mlx5_modify_nic_vport_node_guid(esw->dev, vport_num,
 -						vport->info.node_guid);
 -	}
 -
 -	flags = (vport->info.vlan || vport->info.qos) ?
 -		SET_VLAN_STRIP | SET_VLAN_INSERT : 0;
 +	mlx5_modify_nic_vport_mac_address(esw->dev, vport_num, vport->info.mac);
 +	mlx5_modify_nic_vport_node_guid(esw->dev, vport_num, vport->info.node_guid);
  	modify_esw_vport_cvlan(esw->dev, vport_num, vport->info.vlan, vport->info.qos,
 -			       flags);
 +			       (vport->info.vlan || vport->info.qos));
  
  	/* Only legacy mode needs ACLs */
- 	if (esw->mode == SRIOV_LEGACY) {
+ 	if (esw->mode == MLX5_ESWITCH_LEGACY) {
  		esw_vport_ingress_config(esw, vport);
  		esw_vport_egress_config(esw, vport);
  	}
@@@ -1654,9 -1681,9 +1654,9 @@@ static void esw_disable_vport(struct ml
  	 */
  	esw_vport_change_handle_locked(vport);
  	vport->enabled_events = 0;
 -	esw_vport_disable_qos(esw, vport);
 +	esw_vport_disable_qos(esw, vport_num);
  	if (esw->manager_vport != vport_num &&
- 	    esw->mode == SRIOV_LEGACY) {
+ 	    esw->mode == MLX5_ESWITCH_LEGACY) {
  		mlx5_modify_vport_admin_state(esw->dev,
  					      MLX5_VPORT_STATE_OP_MOD_ESW_VPORT,
  					      vport_num, 1,
@@@ -1688,8 -1718,20 +1688,8 @@@ static int eswitch_vport_event(struct n
  /* Public E-Switch API */
  #define ESW_ALLOWED(esw) ((esw) && MLX5_ESWITCH_MANAGER((esw)->dev))
  
- int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
+ int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int nvfs, int mode)
  {
 -	struct mlx5_vport *vport;
 -	int total_nvports = 0;
  	int err;
  	int i, enabled_events;
  
@@@ -1700,12 -1742,17 +1700,21 @@@
  	}
  
  	if (!MLX5_CAP_ESW_INGRESS_ACL(esw->dev, ft_support))
- 		esw_warn(esw->dev, "E-Switch ingress ACL is not supported by FW\n");
+ 		esw_warn(esw->dev, "ingress ACL is not supported by FW\n");
  
  	if (!MLX5_CAP_ESW_EGRESS_ACL(esw->dev, ft_support))
- 		esw_warn(esw->dev, "E-Switch engress ACL is not supported by FW\n");
+ 		esw_warn(esw->dev, "engress ACL is not supported by FW\n");
  
++<<<<<<< HEAD
 +	esw_info(esw->dev, "E-Switch enable SRIOV: nvfs(%d) mode (%d)\n", nvfs, mode);
++=======
+ 	if (mode == MLX5_ESWITCH_OFFLOADS) {
+ 		if (mlx5_core_is_ecpf_esw_manager(esw->dev))
+ 			total_nvports = esw->total_vports;
+ 		else
+ 			total_nvports = nvfs + MLX5_SPECIAL_VPORTS(esw->dev);
+ 	}
++>>>>>>> f6455de0b0e5 (net/mlx5: E-Switch, Refactor eswitch SR-IOV interface)
  
  	esw->mode = mode;
  
@@@ -1732,11 -1779,23 +1741,29 @@@
  	 * 1. L2 table (MPFS) is programmed by PF/VF representors netdevs set_rx_mode
  	 * 2. FDB/Eswitch is programmed by user space tools
  	 */
++<<<<<<< HEAD
 +	enabled_events = (mode == SRIOV_LEGACY) ? SRIOV_VPORT_EVENTS : 0;
 +	for (i = 0; i <= nvfs; i++)
 +		esw_enable_vport(esw, i, enabled_events);
++=======
+ 	enabled_events = (mode == MLX5_ESWITCH_LEGACY) ? SRIOV_VPORT_EVENTS : 0;
  
- 	if (mode == SRIOV_LEGACY) {
+ 	/* Enable PF vport */
+ 	vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_PF);
+ 	esw_enable_vport(esw, vport, enabled_events);
+ 
+ 	/* Enable ECPF vports */
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_ECPF);
+ 		esw_enable_vport(esw, vport, enabled_events);
+ 	}
+ 
+ 	/* Enable VF vports */
+ 	mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)
+ 		esw_enable_vport(esw, vport, enabled_events);
++>>>>>>> f6455de0b0e5 (net/mlx5: E-Switch, Refactor eswitch SR-IOV interface)
+ 
+ 	if (mode == MLX5_ESWITCH_LEGACY) {
  		MLX5_NB_INIT(&esw->nb, eswitch_vport_event, NIC_VPORT_CHANGE);
  		mlx5_eq_notifier_register(esw->dev, &esw->nb);
  	}
@@@ -1756,40 -1817,40 +1785,46 @@@ abort
  	return err;
  }
  
- void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw)
+ void mlx5_eswitch_disable(struct mlx5_eswitch *esw)
  {
  	struct esw_mc_addr *mc_promisc;
 -	struct mlx5_vport *vport;
  	int old_mode;
 +	int nvports;
  	int i;
  
- 	if (!ESW_ALLOWED(esw) || esw->mode == SRIOV_NONE)
+ 	if (!ESW_ALLOWED(esw) || esw->mode == MLX5_ESWITCH_NONE)
  		return;
  
- 	esw_info(esw->dev, "disable SRIOV: active vports(%d) mode(%d)\n",
- 		 esw->enabled_vports, esw->mode);
+ 	esw_info(esw->dev, "Disable: mode(%s), nvfs(%d), active vports(%d)\n",
+ 		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
+ 		 esw->dev->priv.sriov.num_vfs, esw->enabled_vports);
  
  	mc_promisc = &esw->mc_promisc;
 +	nvports = esw->enabled_vports;
  
- 	if (esw->mode == SRIOV_LEGACY)
+ 	if (esw->mode == MLX5_ESWITCH_LEGACY)
  		mlx5_eq_notifier_unregister(esw->dev, &esw->nb);
  
 -	mlx5_esw_for_all_vports(esw, i, vport)
 -		esw_disable_vport(esw, vport);
 +	for (i = 0; i < esw->total_vports; i++)
 +		esw_disable_vport(esw, i);
  
  	if (mc_promisc && mc_promisc->uplink_rule)
  		mlx5_del_flow_rules(mc_promisc->uplink_rule);
  
  	esw_destroy_tsar(esw);
  
- 	if (esw->mode == SRIOV_LEGACY)
+ 	if (esw->mode == MLX5_ESWITCH_LEGACY)
  		esw_destroy_legacy_table(esw);
++<<<<<<< HEAD
 +	else if (esw->mode == SRIOV_OFFLOADS)
 +		esw_offloads_cleanup(esw, nvports);
++=======
+ 	else if (esw->mode == MLX5_ESWITCH_OFFLOADS)
+ 		esw_offloads_cleanup(esw);
++>>>>>>> f6455de0b0e5 (net/mlx5: E-Switch, Refactor eswitch SR-IOV interface)
  
  	old_mode = esw->mode;
- 	esw->mode = SRIOV_NONE;
+ 	esw->mode = MLX5_ESWITCH_NONE;
  
  	mlx5_lag_update(esw->dev);
  
@@@ -1852,9 -1914,8 +1887,9 @@@ int mlx5_eswitch_init(struct mlx5_core_
  			  esw_vport_change_handler);
  	}
  
 +	esw->total_vports = total_vports;
  	esw->enabled_vports = 0;
- 	esw->mode = SRIOV_NONE;
+ 	esw->mode = MLX5_ESWITCH_NONE;
  	esw->offloads.inline_mode = MLX5_INLINE_MODE_NONE;
  	if (MLX5_CAP_ESW_FLOWTABLE_FDB(dev, reformat) &&
  	    MLX5_CAP_ESW_FLOWTABLE_FDB(dev, decap))
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,a1beada1cdbf..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -86,9 -146,8 +86,9 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	struct mlx5_flow_handle *rule;
  	struct mlx5_flow_table *fdb;
  	int j, i = 0;
 +	void *misc;
  
- 	if (esw->mode != SRIOV_OFFLOADS)
+ 	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
  		return ERR_PTR(-EOPNOTSUPP);
  
  	flow_act.action = attr->action;
@@@ -1952,39 -2500,35 +1952,44 @@@ int mlx5_devlink_eswitch_encap_mode_get
  	return 0;
  }
  
 -void mlx5_eswitch_register_vport_reps(struct mlx5_eswitch *esw,
 -				      const struct mlx5_eswitch_rep_ops *ops,
 -				      u8 rep_type)
 +void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
 +				     int vport_index,
 +				     struct mlx5_eswitch_rep_if *__rep_if,
 +				     u8 rep_type)
  {
 -	struct mlx5_eswitch_rep_data *rep_data;
 -	struct mlx5_eswitch_rep *rep;
 -	int i;
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
 +	struct mlx5_eswitch_rep_if *rep_if;
  
 -	esw->offloads.rep_ops[rep_type] = ops;
 -	mlx5_esw_for_all_reps(esw, i, rep) {
 -		rep_data = &rep->rep_data[rep_type];
 -		atomic_set(&rep_data->state, REP_REGISTERED);
 -	}
 +	rep_if = &offloads->vport_reps[vport_index].rep_if[rep_type];
 +
 +	rep_if->load   = __rep_if->load;
 +	rep_if->unload = __rep_if->unload;
 +	rep_if->get_proto_dev = __rep_if->get_proto_dev;
 +	rep_if->priv = __rep_if->priv;
 +
 +	rep_if->valid = true;
  }
 -EXPORT_SYMBOL(mlx5_eswitch_register_vport_reps);
 +EXPORT_SYMBOL(mlx5_eswitch_register_vport_rep);
  
 -void mlx5_eswitch_unregister_vport_reps(struct mlx5_eswitch *esw, u8 rep_type)
 +void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 +				       int vport_index, u8 rep_type)
  {
 -	u16 max_vf = mlx5_core_max_vfs(esw->dev);
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
 -	int i;
  
++<<<<<<< HEAD
 +	rep = &offloads->vport_reps[vport_index];
++=======
+ 	if (esw->mode == MLX5_ESWITCH_OFFLOADS)
+ 		__unload_reps_all_vport(esw, max_vf, rep_type);
++>>>>>>> f6455de0b0e5 (net/mlx5: E-Switch, Refactor eswitch SR-IOV interface)
  
 -	mlx5_esw_for_all_reps(esw, i, rep)
 -		atomic_set(&rep->rep_data[rep_type].state, REP_UNREGISTERED);
 +	if (esw->mode == SRIOV_OFFLOADS && esw->vports[vport_index].enabled)
 +		rep->rep_if[rep_type].unload(rep);
 +
 +	rep->rep_if[rep_type].valid = false;
  }
 -EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_reps);
 +EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_rep);
  
  void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type)
  {
diff --git a/drivers/infiniband/hw/mlx5/ib_rep.h b/drivers/infiniband/hw/mlx5/ib_rep.h
index 090c992c76a6..5a94c68cd8b4 100644
--- a/drivers/infiniband/hw/mlx5/ib_rep.h
+++ b/drivers/infiniband/hw/mlx5/ib_rep.h
@@ -25,7 +25,7 @@ struct net_device *mlx5_ib_get_rep_netdev(struct mlx5_eswitch *esw,
 #else /* CONFIG_MLX5_ESWITCH */
 static inline u8 mlx5_ib_eswitch_mode(struct mlx5_eswitch *esw)
 {
-	return SRIOV_NONE;
+	return MLX5_ESWITCH_NONE;
 }
 
 static inline
* Unmerged path drivers/infiniband/hw/mlx5/main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index bfec84e64a0c..1f9a08aecb39 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -5144,7 +5144,7 @@ static void *mlx5e_add(struct mlx5_core_dev *mdev)
 
 #ifdef CONFIG_MLX5_ESWITCH
 	if (MLX5_ESWITCH_MANAGER(mdev) &&
-	    mlx5_eswitch_mode(mdev->priv.eswitch) == SRIOV_OFFLOADS) {
+	    mlx5_eswitch_mode(mdev->priv.eswitch) == MLX5_ESWITCH_OFFLOADS) {
 		mlx5e_rep_register_vport_reps(mdev);
 		return mdev;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1ddcc10576ec..d62063dce9a7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -407,7 +407,7 @@ static int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr)
 	struct mlx5e_priv *uplink_priv = NULL;
 	struct net_device *uplink_dev;
 
-	if (esw->mode == SRIOV_NONE)
+	if (esw->mode == MLX5_ESWITCH_NONE)
 		return -EOPNOTSUPP;
 
 	uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
@@ -441,7 +441,7 @@ static void mlx5e_sqs2vport_stop(struct mlx5_eswitch *esw,
 	struct mlx5e_rep_sq *rep_sq, *tmp;
 	struct mlx5e_rep_priv *rpriv;
 
-	if (esw->mode != SRIOV_OFFLOADS)
+	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
 		return;
 
 	rpriv = mlx5e_rep_to_rep_priv(rep);
@@ -462,7 +462,7 @@ static int mlx5e_sqs2vport_start(struct mlx5_eswitch *esw,
 	int err;
 	int i;
 
-	if (esw->mode != SRIOV_OFFLOADS)
+	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
 		return 0;
 
 	rpriv = mlx5e_rep_to_rep_priv(rep);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 94c980b7a713..94250c55b424 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -3274,7 +3274,7 @@ mlx5e_tc_add_flow(struct mlx5e_priv *priv,
 	if (!tc_can_offload_extack(priv->netdev, f->common.extack))
 		return -EOPNOTSUPP;
 
-	if (esw && esw->mode == SRIOV_OFFLOADS)
+	if (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)
 		err = mlx5e_add_fdb_flow(priv, f, flow_flags,
 					 filter_dev, flow);
 	else
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index af9a875f1cf1..5984cfd64299 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -231,8 +231,8 @@ void esw_vport_disable_ingress_acl(struct mlx5_eswitch *esw,
 /* E-Switch API */
 int mlx5_eswitch_init(struct mlx5_core_dev *dev);
 void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw);
-int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode);
-void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw);
+int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int nvfs, int mode);
+void mlx5_eswitch_disable(struct mlx5_eswitch *esw);
 int mlx5_eswitch_set_vport_mac(struct mlx5_eswitch *esw,
 			       int vport, u8 mac[ETH_ALEN]);
 int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,
@@ -399,8 +399,8 @@ void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
 /* eswitch API stubs */
 static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
 static inline void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw) {}
-static inline int  mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode) { return 0; }
-static inline void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw) {}
+static inline int  mlx5_eswitch_enable(struct mlx5_eswitch *esw, int nvfs, int mode) { return 0; }
+static inline void mlx5_eswitch_disable(struct mlx5_eswitch *esw) {}
 static inline bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0, struct mlx5_core_dev *dev1) { return true; }
 
 #define FDB_MAX_CHAIN 1
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag.c b/drivers/net/ethernet/mellanox/mlx5/core/lag.c
index 959605559858..c5ef2ff26465 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag.c
@@ -305,8 +305,8 @@ static void mlx5_do_bond(struct mlx5_lag *ldev)
 			   !mlx5_sriov_is_enabled(dev1);
 
 #ifdef CONFIG_MLX5_ESWITCH
-		roce_lag &= dev0->priv.eswitch->mode == SRIOV_NONE &&
-			    dev1->priv.eswitch->mode == SRIOV_NONE;
+		roce_lag &= dev0->priv.eswitch->mode == MLX5_ESWITCH_NONE &&
+			    dev1->priv.eswitch->mode == MLX5_ESWITCH_NONE;
 #endif
 
 		if (roce_lag)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
index a249b3c3843d..320f01937067 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@ -84,7 +84,7 @@ static int mlx5_device_enable_sriov(struct mlx5_core_dev *dev, int num_vfs)
 	if (!MLX5_ESWITCH_MANAGER(dev))
 		goto enable_vfs_hca;
 
-	err = mlx5_eswitch_enable_sriov(dev->priv.eswitch, num_vfs, SRIOV_LEGACY);
+	err = mlx5_eswitch_enable(dev->priv.eswitch, num_vfs, MLX5_ESWITCH_LEGACY);
 	if (err) {
 		mlx5_core_warn(dev,
 			       "failed to enable eswitch SRIOV (%d)\n", err);
@@ -138,7 +138,7 @@ static void mlx5_device_disable_sriov(struct mlx5_core_dev *dev)
 
 out:
 	if (MLX5_ESWITCH_MANAGER(dev))
-		mlx5_eswitch_disable_sriov(dev->priv.eswitch);
+		mlx5_eswitch_disable(dev->priv.eswitch);
 
 	if (mlx5_wait_for_pages(dev, &dev->priv.vfs_pages))
 		mlx5_core_warn(dev, "timeout reclaiming VFs pages\n");
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index 5c8be6f99f8d..927bf3e185a8 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -12,9 +12,9 @@
 #define MLX5_ESWITCH_MANAGER(mdev) MLX5_CAP_GEN(mdev, eswitch_manager)
 
 enum {
-	SRIOV_NONE,
-	SRIOV_LEGACY,
-	SRIOV_OFFLOADS
+	MLX5_ESWITCH_NONE,
+	MLX5_ESWITCH_LEGACY,
+	MLX5_ESWITCH_OFFLOADS
 };
 
 enum {
