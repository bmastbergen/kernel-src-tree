SUNRPC: Don't try to parse incomplete RPC messages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trondmy@gmail.com>
commit 9ba828861c56a21d211d5d10f5643774b1ea330d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9ba82886.failed

If the copy of the RPC reply into our buffers did not complete, and
we could end up with a truncated message. In that case, just resend
the call.

Fixes: a0584ee9aed80 ("SUNRPC: Use struct xdr_stream when decoding...")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 9ba828861c56a21d211d5d10f5643774b1ea330d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index d26c45609b4f,8b622ceb1158..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2262,8 -2464,8 +2262,13 @@@ call_decode(struct rpc_task *task
  {
  	struct rpc_clnt	*clnt = task->tk_client;
  	struct rpc_rqst	*req = task->tk_rqstp;
++<<<<<<< HEAD
 +	kxdrdproc_t	decode = task->tk_msg.rpc_proc->p_decode;
 +	__be32		*p;
++=======
+ 	struct xdr_stream xdr;
+ 	int err;
++>>>>>>> 9ba828861c56 (SUNRPC: Don't try to parse incomplete RPC messages)
  
  	dprint_status(task);
  
@@@ -2292,39 -2503,31 +2306,52 @@@
  	WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
  				sizeof(req->rq_rcv_buf)) != 0);
  
++<<<<<<< HEAD
 +	if (req->rq_rcv_buf.len < 12) {
 +		if (!RPC_IS_SOFT(task)) {
 +			task->tk_action = call_bind;
 +			goto out_retry;
 +		}
 +		dprintk("RPC:       %s: too small RPC reply size (%d bytes)\n",
 +				clnt->cl_program->name, task->tk_status);
 +		task->tk_action = call_timeout;
 +		goto out_retry;
 +	}
 +
 +	p = rpc_verify_header(task);
 +	if (IS_ERR(p)) {
 +		if (p == ERR_PTR(-EAGAIN))
 +			goto out_retry;
++=======
+ 	xdr_init_decode(&xdr, &req->rq_rcv_buf,
+ 			req->rq_rcv_buf.head[0].iov_base, req);
+ 	err = rpc_decode_header(task, &xdr);
+ out:
+ 	switch (err) {
+ 	case 0:
+ 		task->tk_action = rpc_exit_task;
+ 		task->tk_status = rpcauth_unwrap_resp(task, &xdr);
+ 		dprintk("RPC: %5u %s result %d\n",
+ 			task->tk_pid, __func__, task->tk_status);
++>>>>>>> 9ba828861c56 (SUNRPC: Don't try to parse incomplete RPC messages)
  		return;
 -	case -EAGAIN:
 -		task->tk_status = 0;
 +	}
 +	task->tk_action = rpc_exit_task;
 +
 +	task->tk_status = rpcauth_unwrap_resp(task, decode, req, p,
 +					      task->tk_msg.rpc_resp);
 +
 +	dprintk("RPC: %5u call_decode result %d\n", task->tk_pid,
 +			task->tk_status);
 +	return;
 +out_retry:
 +	task->tk_status = 0;
 +	/* Note: rpc_verify_header() may have freed the RPC slot */
 +	if (task->tk_rqstp == req) {
 +		req->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;
  		if (task->tk_client->cl_discrtry)
  			xprt_conditional_disconnect(req->rq_xprt,
 -						    req->rq_connect_cookie);
 -		task->tk_action = call_encode;
 -		rpc_check_timeout(task);
 -		break;
 -	case -EKEYREJECTED:
 -		task->tk_action = call_reserve;
 -		rpc_check_timeout(task);
 -		rpcauth_invalcred(task);
 -		/* Ensure we obtain a new XID if we retry! */
 -		xprt_release(task);
 +					req->rq_connect_cookie);
  	}
  }
  
* Unmerged path net/sunrpc/clnt.c
