SUNRPC: Don't handle errors if the bind/connect succeeded

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit bd736ed3e2d1088d9b4050f727342e1e619c3841
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/bd736ed3.failed

Don't handle errors in call_bind_status()/call_connect_status()
if it turns out that a previous call caused it to succeed.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Cc: stable@vger.kernel.org # v5.1+
(cherry picked from commit bd736ed3e2d1088d9b4050f727342e1e619c3841)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index d26c45609b4f,3b731411d8e8..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1791,16 -1970,23 +1791,28 @@@ call_bind(struct rpc_task *task
  static void
  call_bind_status(struct rpc_task *task)
  {
+ 	struct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;
  	int status = -EIO;
  
++<<<<<<< HEAD
 +	if (task->tk_status >= 0) {
 +		dprint_status(task);
- 		task->tk_status = 0;
- 		task->tk_action = call_connect;
++=======
+ 	if (rpc_task_transmitted(task)) {
+ 		rpc_task_handle_transmitted(task);
  		return;
  	}
  
+ 	dprint_status(task);
  	trace_rpc_bind_status(task);
+ 	if (task->tk_status >= 0)
+ 		goto out_next;
+ 	if (xprt_bound(xprt)) {
++>>>>>>> bd736ed3e2d1 (SUNRPC: Don't handle errors if the bind/connect succeeded)
+ 		task->tk_status = 0;
+ 		goto out_next;
+ 	}
+ 
  	switch (task->tk_status) {
  	case -ENOMEM:
  		dprintk("RPC: %5u rpcbind out of memory\n", task->tk_pid);
@@@ -1855,12 -2043,15 +1867,14 @@@
  				task->tk_pid, -task->tk_status);
  	}
  
 -	rpc_call_rpcerror(task, status);
 +	rpc_exit(task, status);
  	return;
- 
+ out_next:
+ 	task->tk_action = call_connect;
+ 	return;
  retry_timeout:
  	task->tk_status = 0;
 -	task->tk_action = call_bind;
 -	rpc_check_timeout(task);
 +	task->tk_action = call_timeout;
  }
  
  /*
@@@ -1934,17 -2141,20 +1958,31 @@@ call_connect_status(struct rpc_task *ta
  		/* retry with existing socket, after a delay */
  		rpc_delay(task, 3*HZ);
  		/* fall through */
 -	case -ENOTCONN:
  	case -EAGAIN:
 +		/* Check for timeouts before looping back to call_bind */
  	case -ETIMEDOUT:
++<<<<<<< HEAD
 +		task->tk_action = call_timeout;
 +		return;
 +	case 0:
 +		clnt->cl_stats->netreconn++;
 +		task->tk_action = call_transmit;
 +		return;
 +	}
 +	rpc_exit(task, status);
++=======
+ 		goto out_retry;
+ 	}
+ 	rpc_call_rpcerror(task, status);
+ 	return;
+ out_next:
+ 	task->tk_action = call_transmit;
+ 	return;
+ out_retry:
+ 	/* Check for timeouts before looping back to call_bind */
+ 	task->tk_action = call_bind;
+ 	rpc_check_timeout(task);
++>>>>>>> bd736ed3e2d1 (SUNRPC: Don't handle errors if the bind/connect succeeded)
  }
  
  /*
* Unmerged path net/sunrpc/clnt.c
