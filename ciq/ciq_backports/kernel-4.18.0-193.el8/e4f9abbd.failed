net/mlx5e: Extend hairpin entry with reference counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Extend hairpin entry with reference counter (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 96.15%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit e4f9abbd38e468c73710ad3678005ad05f79c818
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e4f9abbd.failed

List of flows attached to hairpin entry is used as implicit reference
counter (hairpin entry is deallocated when list becomes free) and as a
mechanism to obtain hairpin entry that flow is attached to (through list
head). This is not safe when concurrent modification of list of flows
attached to hairpin entry is possible. Proper atomic reference counter is
required to support concurrent access.

As a preparation for extending hairpin with reference counting, extract
code that deletes hairpin entry into standalone function. In order to
remove this dependency on external locking, extend hairpin entry with
reference counter to manage its lifetime and extend flow structure with
direct pointer to hairpin entry that flow is attached to.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e4f9abbd38e468c73710ad3678005ad05f79c818)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c033e0d4fc59,64ce762ec1e6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -692,23 -794,13 +714,33 @@@ create_hairpin_err
  static void mlx5e_hairpin_flow_del(struct mlx5e_priv *priv,
  				   struct mlx5e_tc_flow *flow)
  {
++<<<<<<< HEAD
 +	struct list_head *next = flow->hairpin.next;
 +
 +	list_del(&flow->hairpin);
 +
 +	/* no more hairpin flows for us, release the hairpin pair */
 +	if (list_empty(next)) {
 +		struct mlx5e_hairpin_entry *hpe;
 +
 +		hpe = list_entry(next, struct mlx5e_hairpin_entry, flows);
 +
 +		netdev_dbg(priv->netdev, "del hairpin: peer %s\n",
 +			   hpe->hp->pair->peer_mdev->priv.name);
 +
 +		mlx5e_hairpin_destroy(hpe->hp);
 +		hash_del(&hpe->hairpin_hlist);
 +		kfree(hpe);
 +	}
++=======
+ 	/* flow wasn't fully initialized */
+ 	if (!flow->hpe)
+ 		return;
+ 
+ 	list_del(&flow->hairpin);
+ 	mlx5e_hairpin_put(priv, flow->hpe);
+ 	flow->hpe = NULL;
++>>>>>>> e4f9abbd38e4 (net/mlx5e: Extend hairpin entry with reference counter)
  }
  
  static int
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
