tools/bpf: sync bpf uapi header bpf.h to tools directory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [tools] bpf: sync bpf uapi header bpf.h to tools directory (Yauheni Kaliuta) [1747617]
Rebuild_FUZZ: 94.34%
commit-author Yonghong Song <yhs@fb.com>
commit edaccf8985305967c22903a78283c8c837ea48dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/edaccf89.failed

The bpf uapi header include/uapi/linux/bpf.h is sync'ed
to tools/include/uapi/linux/bpf.h.

	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit edaccf8985305967c22903a78283c8c837ea48dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/bpf.h
diff --cc tools/include/uapi/linux/bpf.h
index f30861eb0ae9,68d4470523a0..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -2379,6 -2396,296 +2379,299 @@@ union bpf_attr 
   *		"**y**".
   *	Return
   *		0
++<<<<<<< HEAD
++=======
+  *
+  * int bpf_spin_lock(struct bpf_spin_lock *lock)
+  *	Description
+  *		Acquire a spinlock represented by the pointer *lock*, which is
+  *		stored as part of a value of a map. Taking the lock allows to
+  *		safely update the rest of the fields in that value. The
+  *		spinlock can (and must) later be released with a call to
+  *		**bpf_spin_unlock**\ (\ *lock*\ ).
+  *
+  *		Spinlocks in BPF programs come with a number of restrictions
+  *		and constraints:
+  *
+  *		* **bpf_spin_lock** objects are only allowed inside maps of
+  *		  types **BPF_MAP_TYPE_HASH** and **BPF_MAP_TYPE_ARRAY** (this
+  *		  list could be extended in the future).
+  *		* BTF description of the map is mandatory.
+  *		* The BPF program can take ONE lock at a time, since taking two
+  *		  or more could cause dead locks.
+  *		* Only one **struct bpf_spin_lock** is allowed per map element.
+  *		* When the lock is taken, calls (either BPF to BPF or helpers)
+  *		  are not allowed.
+  *		* The **BPF_LD_ABS** and **BPF_LD_IND** instructions are not
+  *		  allowed inside a spinlock-ed region.
+  *		* The BPF program MUST call **bpf_spin_unlock**\ () to release
+  *		  the lock, on all execution paths, before it returns.
+  *		* The BPF program can access **struct bpf_spin_lock** only via
+  *		  the **bpf_spin_lock**\ () and **bpf_spin_unlock**\ ()
+  *		  helpers. Loading or storing data into the **struct
+  *		  bpf_spin_lock** *lock*\ **;** field of a map is not allowed.
+  *		* To use the **bpf_spin_lock**\ () helper, the BTF description
+  *		  of the map value must be a struct and have **struct
+  *		  bpf_spin_lock** *anyname*\ **;** field at the top level.
+  *		  Nested lock inside another struct is not allowed.
+  *		* The **struct bpf_spin_lock** *lock* field in a map value must
+  *		  be aligned on a multiple of 4 bytes in that value.
+  *		* Syscall with command **BPF_MAP_LOOKUP_ELEM** does not copy
+  *		  the **bpf_spin_lock** field to user space.
+  *		* Syscall with command **BPF_MAP_UPDATE_ELEM**, or update from
+  *		  a BPF program, do not update the **bpf_spin_lock** field.
+  *		* **bpf_spin_lock** cannot be on the stack or inside a
+  *		  networking packet (it can only be inside of a map values).
+  *		* **bpf_spin_lock** is available to root only.
+  *		* Tracing programs and socket filter programs cannot use
+  *		  **bpf_spin_lock**\ () due to insufficient preemption checks
+  *		  (but this may change in the future).
+  *		* **bpf_spin_lock** is not allowed in inner maps of map-in-map.
+  *	Return
+  *		0
+  *
+  * int bpf_spin_unlock(struct bpf_spin_lock *lock)
+  *	Description
+  *		Release the *lock* previously locked by a call to
+  *		**bpf_spin_lock**\ (\ *lock*\ ).
+  *	Return
+  *		0
+  *
+  * struct bpf_sock *bpf_sk_fullsock(struct bpf_sock *sk)
+  *	Description
+  *		This helper gets a **struct bpf_sock** pointer such
+  *		that all the fields in this **bpf_sock** can be accessed.
+  *	Return
+  *		A **struct bpf_sock** pointer on success, or **NULL** in
+  *		case of failure.
+  *
+  * struct bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock *sk)
+  *	Description
+  *		This helper gets a **struct bpf_tcp_sock** pointer from a
+  *		**struct bpf_sock** pointer.
+  *	Return
+  *		A **struct bpf_tcp_sock** pointer on success, or **NULL** in
+  *		case of failure.
+  *
+  * int bpf_skb_ecn_set_ce(struct sk_buf *skb)
+  *	Description
+  *		Set ECN (Explicit Congestion Notification) field of IP header
+  *		to **CE** (Congestion Encountered) if current value is **ECT**
+  *		(ECN Capable Transport). Otherwise, do nothing. Works with IPv6
+  *		and IPv4.
+  *	Return
+  *		1 if the **CE** flag is set (either by the current helper call
+  *		or because it was already present), 0 if it is not set.
+  *
+  * struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *sk)
+  *	Description
+  *		Return a **struct bpf_sock** pointer in **TCP_LISTEN** state.
+  *		**bpf_sk_release**\ () is unnecessary and not allowed.
+  *	Return
+  *		A **struct bpf_sock** pointer on success, or **NULL** in
+  *		case of failure.
+  *
+  * struct bpf_sock *bpf_skc_lookup_tcp(void *ctx, struct bpf_sock_tuple *tuple, u32 tuple_size, u64 netns, u64 flags)
+  *	Description
+  *		Look for TCP socket matching *tuple*, optionally in a child
+  *		network namespace *netns*. The return value must be checked,
+  *		and if non-**NULL**, released via **bpf_sk_release**\ ().
+  *
+  *		This function is identical to **bpf_sk_lookup_tcp**\ (), except
+  *		that it also returns timewait or request sockets. Use
+  *		**bpf_sk_fullsock**\ () or **bpf_tcp_sock**\ () to access the
+  *		full structure.
+  *
+  *		This helper is available only if the kernel was compiled with
+  *		**CONFIG_NET** configuration option.
+  *	Return
+  *		Pointer to **struct bpf_sock**, or **NULL** in case of failure.
+  *		For sockets with reuseport option, the **struct bpf_sock**
+  *		result is from *reuse*\ **->socks**\ [] using the hash of the
+  *		tuple.
+  *
+  * int bpf_tcp_check_syncookie(struct bpf_sock *sk, void *iph, u32 iph_len, struct tcphdr *th, u32 th_len)
+  * 	Description
+  * 		Check whether *iph* and *th* contain a valid SYN cookie ACK for
+  * 		the listening socket in *sk*.
+  *
+  * 		*iph* points to the start of the IPv4 or IPv6 header, while
+  * 		*iph_len* contains **sizeof**\ (**struct iphdr**) or
+  * 		**sizeof**\ (**struct ip6hdr**).
+  *
+  * 		*th* points to the start of the TCP header, while *th_len*
+  * 		contains **sizeof**\ (**struct tcphdr**).
+  *
+  * 	Return
+  * 		0 if *iph* and *th* are a valid SYN cookie ACK, or a negative
+  * 		error otherwise.
+  *
+  * int bpf_sysctl_get_name(struct bpf_sysctl *ctx, char *buf, size_t buf_len, u64 flags)
+  *	Description
+  *		Get name of sysctl in /proc/sys/ and copy it into provided by
+  *		program buffer *buf* of size *buf_len*.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *
+  *		If *flags* is zero, full name (e.g. "net/ipv4/tcp_mem") is
+  *		copied. Use **BPF_F_SYSCTL_BASE_NAME** flag to copy base name
+  *		only (e.g. "tcp_mem").
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  * int bpf_sysctl_get_current_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get current value of sysctl as it is presented in /proc/sys
+  *		(incl. newline, etc), and copy it as a string into provided
+  *		by program buffer *buf* of size *buf_len*.
+  *
+  *		The whole value is copied, no matter what file position user
+  *		space issued e.g. sys_read at.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if current value was unavailable, e.g. because
+  *		sysctl is uninitialized and read returns -EIO for it.
+  *
+  * int bpf_sysctl_get_new_value(struct bpf_sysctl *ctx, char *buf, size_t buf_len)
+  *	Description
+  *		Get new value being written by user space to sysctl (before
+  *		the actual write happens) and copy it as a string into
+  *		provided by program buffer *buf* of size *buf_len*.
+  *
+  *		User space may write new value at file position > 0.
+  *
+  *		The buffer is always NUL terminated, unless it's zero-sized.
+  *	Return
+  *		Number of character copied (not including the trailing NUL).
+  *
+  *		**-E2BIG** if the buffer wasn't big enough (*buf* will contain
+  *		truncated name in this case).
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_sysctl_set_new_value(struct bpf_sysctl *ctx, const char *buf, size_t buf_len)
+  *	Description
+  *		Override new value being written by user space to sysctl with
+  *		value provided by program in buffer *buf* of size *buf_len*.
+  *
+  *		*buf* should contain a string in same form as provided by user
+  *		space on sysctl write.
+  *
+  *		User space may write new value at file position > 0. To override
+  *		the whole sysctl value file position should be set to zero.
+  *	Return
+  *		0 on success.
+  *
+  *		**-E2BIG** if the *buf_len* is too big.
+  *
+  *		**-EINVAL** if sysctl is being read.
+  *
+  * int bpf_strtol(const char *buf, size_t buf_len, u64 flags, long *res)
+  *	Description
+  *		Convert the initial part of the string from buffer *buf* of
+  *		size *buf_len* to a long integer according to the given base
+  *		and save the result in *res*.
+  *
+  *		The string may begin with an arbitrary amount of white space
+  *		(as determined by **isspace**\ (3)) followed by a single
+  *		optional '**-**' sign.
+  *
+  *		Five least significant bits of *flags* encode base, other bits
+  *		are currently unused.
+  *
+  *		Base must be either 8, 10, 16 or 0 to detect it automatically
+  *		similar to user space **strtol**\ (3).
+  *	Return
+  *		Number of characters consumed on success. Must be positive but
+  *		no more than *buf_len*.
+  *
+  *		**-EINVAL** if no valid digits were found or unsupported base
+  *		was provided.
+  *
+  *		**-ERANGE** if resulting value was out of range.
+  *
+  * int bpf_strtoul(const char *buf, size_t buf_len, u64 flags, unsigned long *res)
+  *	Description
+  *		Convert the initial part of the string from buffer *buf* of
+  *		size *buf_len* to an unsigned long integer according to the
+  *		given base and save the result in *res*.
+  *
+  *		The string may begin with an arbitrary amount of white space
+  *		(as determined by **isspace**\ (3)).
+  *
+  *		Five least significant bits of *flags* encode base, other bits
+  *		are currently unused.
+  *
+  *		Base must be either 8, 10, 16 or 0 to detect it automatically
+  *		similar to user space **strtoul**\ (3).
+  *	Return
+  *		Number of characters consumed on success. Must be positive but
+  *		no more than *buf_len*.
+  *
+  *		**-EINVAL** if no valid digits were found or unsupported base
+  *		was provided.
+  *
+  *		**-ERANGE** if resulting value was out of range.
+  *
+  * void *bpf_sk_storage_get(struct bpf_map *map, struct bpf_sock *sk, void *value, u64 flags)
+  *	Description
+  *		Get a bpf-local-storage from a *sk*.
+  *
+  *		Logically, it could be thought of getting the value from
+  *		a *map* with *sk* as the **key**.  From this
+  *		perspective,  the usage is not much different from
+  *		**bpf_map_lookup_elem**\ (*map*, **&**\ *sk*) except this
+  *		helper enforces the key must be a full socket and the map must
+  *		be a **BPF_MAP_TYPE_SK_STORAGE** also.
+  *
+  *		Underneath, the value is stored locally at *sk* instead of
+  *		the *map*.  The *map* is used as the bpf-local-storage
+  *		"type". The bpf-local-storage "type" (i.e. the *map*) is
+  *		searched against all bpf-local-storages residing at *sk*.
+  *
+  *		An optional *flags* (**BPF_SK_STORAGE_GET_F_CREATE**) can be
+  *		used such that a new bpf-local-storage will be
+  *		created if one does not exist.  *value* can be used
+  *		together with **BPF_SK_STORAGE_GET_F_CREATE** to specify
+  *		the initial value of a bpf-local-storage.  If *value* is
+  *		**NULL**, the new bpf-local-storage will be zero initialized.
+  *	Return
+  *		A bpf-local-storage pointer is returned on success.
+  *
+  *		**NULL** if not found or there was an error in adding
+  *		a new bpf-local-storage.
+  *
+  * int bpf_sk_storage_delete(struct bpf_map *map, struct bpf_sock *sk)
+  *	Description
+  *		Delete a bpf-local-storage from a *sk*.
+  *	Return
+  *		0 on success.
+  *
+  *		**-ENOENT** if the bpf-local-storage cannot be found.
+  *
+  * int bpf_send_signal(u32 sig)
+  *	Description
+  *		Send signal *sig* to the current task.
+  *	Return
+  *		0 on success or successfully queued.
+  *
+  *		**-EBUSY** if work queue under nmi is full.
+  *
+  *		**-EINVAL** if *sig* is invalid.
+  *
+  *		**-EPERM** if no permission to send the *sig*.
+  *
+  *		**-EAGAIN** if bpf program can try again.
++>>>>>>> edaccf898530 (tools/bpf: sync bpf uapi header bpf.h to tools directory)
   */
  #define __BPF_FUNC_MAPPER(FN)		\
  	FN(unspec),			\
@@@ -2475,7 -2782,22 +2768,26 @@@
  	FN(msg_pop_data),		\
  	FN(rc_pointer_rel),		\
  	FN(spin_lock),			\
++<<<<<<< HEAD
 +	FN(spin_unlock),
++=======
+ 	FN(spin_unlock),		\
+ 	FN(sk_fullsock),		\
+ 	FN(tcp_sock),			\
+ 	FN(skb_ecn_set_ce),		\
+ 	FN(get_listener_sock),		\
+ 	FN(skc_lookup_tcp),		\
+ 	FN(tcp_check_syncookie),	\
+ 	FN(sysctl_get_name),		\
+ 	FN(sysctl_get_current_value),	\
+ 	FN(sysctl_get_new_value),	\
+ 	FN(sysctl_set_new_value),	\
+ 	FN(strtol),			\
+ 	FN(strtoul),			\
+ 	FN(sk_storage_get),		\
+ 	FN(sk_storage_delete),		\
+ 	FN(send_signal),
++>>>>>>> edaccf898530 (tools/bpf: sync bpf uapi header bpf.h to tools directory)
  
  /* integer value in 'imm' field of BPF_CALL instruction selects which helper
   * function eBPF program intends to call
* Unmerged path tools/include/uapi/linux/bpf.h
