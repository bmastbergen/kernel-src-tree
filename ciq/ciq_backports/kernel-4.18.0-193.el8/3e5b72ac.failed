net/mlx5: Issue SW reset on FW assert

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Issue SW reset on FW assert (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 94.29%
commit-author Feras Daoud <ferasda@mellanox.com>
commit 3e5b72ac2f298423902169db7893fef43365e0a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3e5b72ac.failed

If a FW assert is considered fatal, indicated by a new bit in the health
buffer, reset the FW. After the reset go through the normal recovery
flow. Only one PF needs to issue the reset, so an attempt is made to
prevent the 2nd function from also issuing the reset.
It's not an error if that happens, it just slows recovery.

	Signed-off-by: Feras Daoud <ferasda@mellanox.com>
	Signed-off-by: Alex Vesker <valex@mellanox.com>
	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 3e5b72ac2f298423902169db7893fef43365e0a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/diag/crdump.c
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index bff749be0582,caf54bd7d538..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -62,7 -63,15 +63,19 @@@ enum 
  
  enum {
  	MLX5_DROP_NEW_HEALTH_WORK,
++<<<<<<< HEAD
 +	MLX5_DROP_NEW_RECOVERY_WORK,
++=======
+ };
+ 
+ enum  {
+ 	MLX5_SENSOR_NO_ERR		= 0,
+ 	MLX5_SENSOR_PCI_COMM_ERR	= 1,
+ 	MLX5_SENSOR_PCI_ERR		= 2,
+ 	MLX5_SENSOR_NIC_DISABLED	= 3,
+ 	MLX5_SENSOR_NIC_SW_RESET	= 4,
+ 	MLX5_SENSOR_FW_SYND_RFR		= 5,
++>>>>>>> 3e5b72ac2f29 (net/mlx5: Issue SW reset on FW assert)
  };
  
  u8 mlx5_get_nic_state(struct mlx5_core_dev *dev)
@@@ -85,23 -94,113 +98,126 @@@ static int in_fatal(struct mlx5_core_de
  	struct mlx5_core_health *health = &dev->priv.health;
  	struct health_buffer __iomem *h = health->health;
  
++<<<<<<< HEAD
 +	if (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)
 +		return 1;
++=======
+ 	/* Offline PCI reads return 0xffffffff */
+ 	return (ioread32be(&h->fw_ver) == 0xffffffff);
+ }
+ 
+ static bool sensor_fw_synd_rfr(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_core_health *health = &dev->priv.health;
+ 	struct health_buffer __iomem *h = health->health;
+ 	u32 rfr = ioread32be(&h->rfr) >> MLX5_RFR_OFFSET;
+ 	u8 synd = ioread8(&h->synd);
+ 
+ 	if (rfr && synd)
+ 		mlx5_core_dbg(dev, "FW requests reset, synd: %d\n", synd);
+ 	return rfr && synd;
+ }
+ 
+ static u32 check_fatal_sensors(struct mlx5_core_dev *dev)
+ {
+ 	if (sensor_pci_not_working(dev))
+ 		return MLX5_SENSOR_PCI_COMM_ERR;
+ 	if (pci_channel_offline(dev->pdev))
+ 		return MLX5_SENSOR_PCI_ERR;
+ 	if (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)
+ 		return MLX5_SENSOR_NIC_DISABLED;
+ 	if (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_SW_RESET)
+ 		return MLX5_SENSOR_NIC_SW_RESET;
+ 	if (sensor_fw_synd_rfr(dev))
+ 		return MLX5_SENSOR_FW_SYND_RFR;
++>>>>>>> 3e5b72ac2f29 (net/mlx5: Issue SW reset on FW assert)
 +
 +	if (ioread32be(&h->fw_ver) == 0xffffffff)
 +		return 1;
  
 -	return MLX5_SENSOR_NO_ERR;
 +	return 0;
  }
  
+ static int lock_sem_sw_reset(struct mlx5_core_dev *dev, bool lock)
+ {
+ 	enum mlx5_vsc_state state;
+ 	int ret;
+ 
+ 	if (!mlx5_core_is_pf(dev))
+ 		return -EBUSY;
+ 
+ 	/* Try to lock GW access, this stage doesn't return
+ 	 * EBUSY because locked GW does not mean that other PF
+ 	 * already started the reset.
+ 	 */
+ 	ret = mlx5_vsc_gw_lock(dev);
+ 	if (ret == -EBUSY)
+ 		return -EINVAL;
+ 	if (ret)
+ 		return ret;
+ 
+ 	state = lock ? MLX5_VSC_LOCK : MLX5_VSC_UNLOCK;
+ 	/* At this stage, if the return status == EBUSY, then we know
+ 	 * for sure that another PF started the reset, so don't allow
+ 	 * another reset.
+ 	 */
+ 	ret = mlx5_vsc_sem_set_space(dev, MLX5_SEMAPHORE_SW_RESET, state);
+ 	if (ret)
+ 		mlx5_core_warn(dev, "Failed to lock SW reset semaphore\n");
+ 
+ 	/* Unlock GW access */
+ 	mlx5_vsc_gw_unlock(dev);
+ 
+ 	return ret;
+ }
+ 
+ static bool reset_fw_if_needed(struct mlx5_core_dev *dev)
+ {
+ 	bool supported = (ioread32be(&dev->iseg->initializing) >>
+ 			  MLX5_FW_RESET_SUPPORTED_OFFSET) & 1;
+ 	u32 fatal_error;
+ 
+ 	if (!supported)
+ 		return false;
+ 
+ 	/* The reset only needs to be issued by one PF. The health buffer is
+ 	 * shared between all functions, and will be cleared during a reset.
+ 	 * Check again to avoid a redundant 2nd reset. If the fatal erros was
+ 	 * PCI related a reset won't help.
+ 	 */
+ 	fatal_error = check_fatal_sensors(dev);
+ 	if (fatal_error == MLX5_SENSOR_PCI_COMM_ERR ||
+ 	    fatal_error == MLX5_SENSOR_NIC_DISABLED ||
+ 	    fatal_error == MLX5_SENSOR_NIC_SW_RESET) {
+ 		mlx5_core_warn(dev, "Not issuing FW reset. Either it's already done or won't help.");
+ 		return false;
+ 	}
+ 
+ 	mlx5_core_warn(dev, "Issuing FW Reset\n");
+ 	/* Write the NIC interface field to initiate the reset, the command
+ 	 * interface address also resides here, don't overwrite it.
+ 	 */
+ 	mlx5_set_nic_state(dev, MLX5_NIC_IFC_SW_RESET);
+ 
+ 	return true;
+ }
+ 
  void mlx5_enter_error_state(struct mlx5_core_dev *dev, bool force)
  {
  	mutex_lock(&dev->intf_state_mutex);
  	if (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)
  		goto unlock;
+ 	if (dev->state == MLX5_DEVICE_STATE_UNINITIALIZED) {
+ 		dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
+ 		goto unlock;
+ 	}
  
++<<<<<<< HEAD
 +	mlx5_core_err(dev, "start\n");
 +	if (pci_channel_offline(dev->pdev) || in_fatal(dev) || force) {
++=======
+ 	if (check_fatal_sensors(dev) || force) {
++>>>>>>> 3e5b72ac2f29 (net/mlx5: Issue SW reset on FW assert)
  		dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
  		mlx5_cmd_flush(dev);
  	}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index ea5e5990b832,ec5287c51825..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1388,12 -1357,12 +1388,17 @@@ static pci_ers_result_t mlx5_pci_err_de
  					      pci_channel_state_t state)
  {
  	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 +	struct mlx5_priv *priv = &dev->priv;
  
 -	mlx5_core_info(dev, "%s was called\n", __func__);
 +	dev_info(&pdev->dev, "%s was called\n", __func__);
  
  	mlx5_enter_error_state(dev, false);
++<<<<<<< HEAD
 +	mlx5_unload_one(dev, priv, false);
++=======
+ 	mlx5_error_sw_reset(dev);
+ 	mlx5_unload_one(dev, false);
++>>>>>>> 3e5b72ac2f29 (net/mlx5: Issue SW reset on FW assert)
  	/* In case of kernel call drain the health wq */
  	if (state) {
  		mlx5_drain_health_wq(dev);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 8213c994e205,29bb61a10289..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -106,6 -111,11 +106,14 @@@ enum 
  	MLX5_DRIVER_SYND = 0xbadd00de,
  };
  
++<<<<<<< HEAD
++=======
+ enum mlx5_semaphore_space_address {
+ 	MLX5_SEMAPHORE_SPACE_DOMAIN     = 0xA,
+ 	MLX5_SEMAPHORE_SW_RESET         = 0x20,
+ };
+ 
++>>>>>>> 3e5b72ac2f29 (net/mlx5: Issue SW reset on FW assert)
  int mlx5_query_hca_caps(struct mlx5_core_dev *dev);
  int mlx5_query_board_id(struct mlx5_core_dev *dev);
  int mlx5_cmd_init_hca(struct mlx5_core_dev *dev, uint32_t *sw_owner_id);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/diag/crdump.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/diag/crdump.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h
index fc2b6e807f06..2cfa2ec8b5d3 100644
--- a/include/linux/mlx5/device.h
+++ b/include/linux/mlx5/device.h
@@ -510,6 +510,10 @@ struct mlx5_cmd_layout {
 	u8		status_own;
 };
 
+enum mlx5_fatal_assert_bit_offsets {
+	MLX5_RFR_OFFSET = 31,
+};
+
 struct health_buffer {
 	__be32		assert_var[5];
 	__be32		rsvd0[3];
@@ -518,12 +522,16 @@ struct health_buffer {
 	__be32		rsvd1[2];
 	__be32		fw_ver;
 	__be32		hw_id;
-	__be32		rsvd2;
+	__be32		rfr;
 	u8		irisc_index;
 	u8		synd;
 	__be16		ext_synd;
 };
 
+enum mlx5_initializing_bit_offsets {
+	MLX5_FW_RESET_SUPPORTED_OFFSET = 30,
+};
+
 enum mlx5_cmd_addr_l_sz_offset {
 	MLX5_NIC_IFC_OFFSET = 8,
 };
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 655e39273378..a2d2a175e0f7 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -576,6 +576,7 @@ struct mlx5_priv {
 };
 
 enum mlx5_device_state {
+	MLX5_DEVICE_STATE_UNINITIALIZED,
 	MLX5_DEVICE_STATE_UP,
 	MLX5_DEVICE_STATE_INTERNAL_ERROR,
 };
