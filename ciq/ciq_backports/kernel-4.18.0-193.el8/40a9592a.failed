drm/amdkfd: Fix MQD size calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Oak Zeng <Oak.Zeng@amd.com>
commit 40a9592a26608e16f7545a068ea4165e1869f629
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/40a9592a.failed

On device initialization, a chunk of GTT memory is pre-allocated for
HIQ and all SDMA queues mqd. The size of this allocation was wrong.
The correct sdma engine number should be PCIe-optimized SDMA engine
number plus xgmi SDMA engine number.

	Reported-by: Jonathan Kim <Jonathan.Kim@amd.com>
	Signed-off-by: Jonathan Kim <Jonathan.Kim@amd.com>
	Signed-off-by: Oak Zeng <Oak.Zeng@amd.com>
	Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 40a9592a26608e16f7545a068ea4165e1869f629)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
diff --cc drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
index 722fa1f5244b,1d82bfe2f3f8..000000000000
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
@@@ -1640,21 -1638,69 +1640,68 @@@ static int process_termination_cpsch(st
  		qpd->reset_wavefronts = false;
  	}
  
 -	dqm_unlock(dqm);
 -
 -	/* Outside the DQM lock because under the DQM lock we can't do
 -	 * reclaim or take other locks that others hold while reclaiming.
 -	 */
 -	if (found)
 -		kfd_dec_compute_active(dqm->dev);
 -
 -	/* Lastly, free mqd resources.
 -	 * Do free_mqd() after dqm_unlock to avoid circular locking.
 -	 */
 +	/* lastly, free mqd resources */
  	list_for_each_entry_safe(q, next, &qpd->queues_list, list) {
 -		mqd_mgr = dqm->mqd_mgrs[get_mqd_type_from_queue_type(
 -				q->properties.type)];
 +		mqd_mgr = dqm->ops.get_mqd_manager(dqm,
 +			get_mqd_type_from_queue_type(q->properties.type));
 +		if (!mqd_mgr) {
 +			retval = -ENOMEM;
 +			goto out;
 +		}
  		list_del(&q->list);
  		qpd->queue_count--;
 -		mqd_mgr->free_mqd(mqd_mgr, q->mqd, q->mqd_mem_obj);
 +		mqd_mgr->uninit_mqd(mqd_mgr, q->mqd, q->mqd_mem_obj);
  	}
  
++<<<<<<< HEAD
 +out:
 +	dqm_unlock(dqm);
++=======
+ 	return retval;
+ }
+ 
+ static int init_mqd_managers(struct device_queue_manager *dqm)
+ {
+ 	int i, j;
+ 	struct mqd_manager *mqd_mgr;
+ 
+ 	for (i = 0; i < KFD_MQD_TYPE_MAX; i++) {
+ 		mqd_mgr = dqm->asic_ops.mqd_manager_init(i, dqm->dev);
+ 		if (!mqd_mgr) {
+ 			pr_err("mqd manager [%d] initialization failed\n", i);
+ 			goto out_free;
+ 		}
+ 		dqm->mqd_mgrs[i] = mqd_mgr;
+ 	}
+ 
+ 	return 0;
+ 
+ out_free:
+ 	for (j = 0; j < i; j++) {
+ 		kfree(dqm->mqd_mgrs[j]);
+ 		dqm->mqd_mgrs[j] = NULL;
+ 	}
+ 
+ 	return -ENOMEM;
+ }
+ 
+ /* Allocate one hiq mqd (HWS) and all SDMA mqd in a continuous trunk*/
+ static int allocate_hiq_sdma_mqd(struct device_queue_manager *dqm)
+ {
+ 	int retval;
+ 	struct kfd_dev *dev = dqm->dev;
+ 	struct kfd_mem_obj *mem_obj = &dqm->hiq_sdma_mqd;
+ 	uint32_t size = dqm->mqd_mgrs[KFD_MQD_TYPE_SDMA]->mqd_size *
+ 		(dev->device_info->num_sdma_engines +
+ 		dev->device_info->num_xgmi_sdma_engines) *
+ 		dev->device_info->num_sdma_queues_per_engine +
+ 		dqm->mqd_mgrs[KFD_MQD_TYPE_HIQ]->mqd_size;
+ 
+ 	retval = amdgpu_amdkfd_alloc_gtt_mem(dev->kgd, size,
+ 		&(mem_obj->gtt_mem), &(mem_obj->gpu_addr),
+ 		(void *)&(mem_obj->cpu_ptr), true);
+ 
++>>>>>>> 40a9592a2660 (drm/amdkfd: Fix MQD size calculation)
  	return retval;
  }
  
* Unmerged path drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
