net/mlx5: E-Switch, Return raw output for query esw functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Return raw output for query esw functions (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 96.61%
commit-author Bodong Wang <bodong@mellanox.com>
commit 10ee82cedb62dd716c44ba7a2c458688638873ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/10ee82ce.failed

Current function only returns host num of VFs, later patch requires
other params such as host maximum num of VFs.

Return the raw output so that caller can extract info as needed.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 10ee82cedb62dd716c44ba7a2c458688638873ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 881a0621eae0,a4df109fbeb7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1661,6 -1686,16 +1661,19 @@@ static int eswitch_vport_event(struct n
  	return NOTIFY_OK;
  }
  
++<<<<<<< HEAD
++=======
+ int mlx5_esw_query_functions(struct mlx5_core_dev *dev, u32 *out, int outlen)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(query_esw_functions_in)] = {};
+ 
+ 	MLX5_SET(query_esw_functions_in, in, opcode,
+ 		 MLX5_CMD_OP_QUERY_ESW_FUNCTIONS);
+ 
+ 	return mlx5_cmd_exec(dev, in, sizeof(in), out, outlen);
+ }
+ 
++>>>>>>> 10ee82cedb62 (net/mlx5: E-Switch, Return raw output for query esw functions)
  /* Public E-Switch API */
  #define ESW_ALLOWED(esw) ((esw) && MLX5_ESWITCH_MANAGER((esw)->dev))
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 14d8d502a0a3,e03811be771d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -374,13 -387,15 +374,18 @@@ bool mlx5_esw_lag_prereq(struct mlx5_co
  bool mlx5_esw_multipath_prereq(struct mlx5_core_dev *dev0,
  			       struct mlx5_core_dev *dev1);
  
++<<<<<<< HEAD
++=======
+ int mlx5_esw_query_functions(struct mlx5_core_dev *dev, u32 *out, int outlen);
+ 
++>>>>>>> 10ee82cedb62 (net/mlx5: E-Switch, Return raw output for query esw functions)
  #define MLX5_DEBUG_ESWITCH_MASK BIT(3)
  
 -#define esw_info(__dev, format, ...)			\
 -	dev_info((__dev)->device, "E-Switch: " format, ##__VA_ARGS__)
 +#define esw_info(dev, format, ...)				\
 +	pr_info("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
  
 -#define esw_warn(__dev, format, ...)			\
 -	dev_warn((__dev)->device, "E-Switch: " format, ##__VA_ARGS__)
 +#define esw_warn(dev, format, ...)				\
 +	pr_warn("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
  
  #define esw_debug(dev, format, ...)				\
  	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
@@@ -395,6 -513,12 +400,15 @@@ static inline void mlx5_eswitch_cleanup
  static inline int  mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode) { return 0; }
  static inline void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw) {}
  static inline bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0, struct mlx5_core_dev *dev1) { return true; }
++<<<<<<< HEAD
++=======
+ static inline bool mlx5_eswitch_is_funcs_handler(struct mlx5_core_dev *dev) { return false; }
+ static inline int
+ mlx5_esw_query_functions(struct mlx5_core_dev *dev, u32 *out, int outlen)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> 10ee82cedb62 (net/mlx5: E-Switch, Return raw output for query esw functions)
  
  #define FDB_MAX_CHAIN 1
  #define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 087fd65120c5,1638e4cdeb16..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1603,7 -1760,104 +1603,108 @@@ static void esw_offloads_steering_clean
  		esw_prio_tag_acls_cleanup(esw);
  }
  
++<<<<<<< HEAD
 +int esw_offloads_init(struct mlx5_eswitch *esw, int nvports)
++=======
+ static void esw_functions_changed_event_handler(struct work_struct *work)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(query_esw_functions_out)] = {};
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 	u16 num_vfs = 0;
+ 	int err;
+ 
+ 	host_work = container_of(work, struct mlx5_host_work, work);
+ 	esw = host_work->esw;
+ 
+ 	err = mlx5_esw_query_functions(esw->dev, out, sizeof(out));
+ 	num_vfs = MLX5_GET(query_esw_functions_out, out,
+ 			   host_params_context.host_num_of_vfs);
+ 	if (err || num_vfs == esw->esw_funcs.num_vfs)
+ 		goto out;
+ 
+ 	/* Number of VFs can only change from "0 to x" or "x to 0". */
+ 	if (esw->esw_funcs.num_vfs > 0) {
+ 		esw_offloads_unload_vf_reps(esw, esw->esw_funcs.num_vfs);
+ 	} else {
+ 		err = esw_offloads_load_vf_reps(esw, num_vfs);
+ 
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	esw->esw_funcs.num_vfs = num_vfs;
+ 
+ out:
+ 	kfree(host_work);
+ }
+ 
+ static void esw_emulate_event_handler(struct work_struct *work)
+ {
+ 	struct mlx5_host_work *host_work =
+ 		container_of(work, struct mlx5_host_work, work);
+ 	struct mlx5_eswitch *esw = host_work->esw;
+ 	int err;
+ 
+ 	if (esw->esw_funcs.num_vfs) {
+ 		err = esw_offloads_load_vf_reps(esw, esw->esw_funcs.num_vfs);
+ 		if (err)
+ 			esw_warn(esw->dev, "Load vf reps err=%d\n", err);
+ 	}
+ 	kfree(host_work);
+ }
+ 
+ static int esw_functions_changed_event(struct notifier_block *nb,
+ 				       unsigned long type, void *data)
+ {
+ 	struct mlx5_esw_functions *esw_funcs;
+ 	struct mlx5_host_work *host_work;
+ 	struct mlx5_eswitch *esw;
+ 
+ 	host_work = kzalloc(sizeof(*host_work), GFP_ATOMIC);
+ 	if (!host_work)
+ 		return NOTIFY_DONE;
+ 
+ 	esw_funcs = mlx5_nb_cof(nb, struct mlx5_esw_functions, nb);
+ 	esw = container_of(esw_funcs, struct mlx5_eswitch, esw_funcs);
+ 
+ 	host_work->esw = esw;
+ 
+ 	if (mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		INIT_WORK(&host_work->work,
+ 			  esw_functions_changed_event_handler);
+ 	else
+ 		INIT_WORK(&host_work->work, esw_emulate_event_handler);
+ 	queue_work(esw->work_queue, &host_work->work);
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static void esw_functions_changed_event_init(struct mlx5_eswitch *esw,
+ 					     u16 vf_nvports)
+ {
+ 	if (mlx5_eswitch_is_funcs_handler(esw->dev)) {
+ 		esw->esw_funcs.num_vfs = 0;
+ 		MLX5_NB_INIT(&esw->esw_funcs.nb, esw_functions_changed_event,
+ 			     ESW_FUNCTIONS_CHANGED);
+ 		mlx5_eq_notifier_register(esw->dev, &esw->esw_funcs.nb);
+ 	} else {
+ 		esw->esw_funcs.num_vfs = vf_nvports;
+ 	}
+ }
+ 
+ static void esw_functions_changed_event_cleanup(struct mlx5_eswitch *esw)
+ {
+ 	if (!mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		return;
+ 
+ 	mlx5_eq_notifier_unregister(esw->dev, &esw->esw_funcs.nb);
+ 	flush_workqueue(esw->work_queue);
+ }
+ 
+ int esw_offloads_init(struct mlx5_eswitch *esw, int vf_nvports,
+ 		      int total_nvports)
++>>>>>>> 10ee82cedb62 (net/mlx5: E-Switch, Return raw output for query esw functions)
  {
  	int err;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
