iov_iter: Add I/O discard iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author David Howells <dhowells@redhat.com>
commit 9ea9ce0427aab02a2fd88fc608267cf6952119f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9ea9ce04.failed

Add a new iterator, ITER_DISCARD, that can only be used in READ mode and
just discards any data copied to it.

This is useful in a network filesystem for discarding any unwanted data
sent by a server.

	Signed-off-by: David Howells <dhowells@redhat.com>
(cherry picked from commit 9ea9ce0427aab02a2fd88fc608267cf6952119f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/uio.h
#	lib/iov_iter.c
diff --cc include/linux/uio.h
index bc2b9f6f90bf,55ce99ddb912..000000000000
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@@ -50,6 -48,41 +51,44 @@@ struct iov_iter 
  	};
  };
  
++<<<<<<< HEAD
++=======
+ static inline enum iter_type iov_iter_type(const struct iov_iter *i)
+ {
+ 	return i->type & ~(READ | WRITE);
+ }
+ 
+ static inline bool iter_is_iovec(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_IOVEC;
+ }
+ 
+ static inline bool iov_iter_is_kvec(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_KVEC;
+ }
+ 
+ static inline bool iov_iter_is_bvec(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_BVEC;
+ }
+ 
+ static inline bool iov_iter_is_pipe(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_PIPE;
+ }
+ 
+ static inline bool iov_iter_is_discard(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_DISCARD;
+ }
+ 
+ static inline unsigned char iov_iter_rw(const struct iov_iter *i)
+ {
+ 	return i->type & (READ | WRITE);
+ }
+ 
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  /*
   * Total number of bytes covered by an iovec.
   *
@@@ -184,14 -218,15 +223,15 @@@ size_t copy_to_iter_mcsafe(void *addr, 
  size_t iov_iter_zero(size_t bytes, struct iov_iter *);
  unsigned long iov_iter_alignment(const struct iov_iter *i);
  unsigned long iov_iter_gap_alignment(const struct iov_iter *i);
 -void iov_iter_init(struct iov_iter *i, unsigned int direction, const struct iovec *iov,
 +void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
  			unsigned long nr_segs, size_t count);
 -void iov_iter_kvec(struct iov_iter *i, unsigned int direction, const struct kvec *kvec,
 +void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *kvec,
  			unsigned long nr_segs, size_t count);
 -void iov_iter_bvec(struct iov_iter *i, unsigned int direction, const struct bio_vec *bvec,
 +void iov_iter_bvec(struct iov_iter *i, int direction, const struct bio_vec *bvec,
  			unsigned long nr_segs, size_t count);
 -void iov_iter_pipe(struct iov_iter *i, unsigned int direction, struct pipe_inode_info *pipe,
 +void iov_iter_pipe(struct iov_iter *i, int direction, struct pipe_inode_info *pipe,
  			size_t count);
+ void iov_iter_discard(struct iov_iter *i, unsigned int direction, size_t count);
  ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
  			size_t maxsize, unsigned maxpages, size_t *start);
  ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
diff --cc lib/iov_iter.c
index b7db915a24cc,7ebccb5c1637..000000000000
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@@ -837,7 -841,9 +840,13 @@@ size_t copy_page_to_iter(struct page *p
  		size_t wanted = copy_to_iter(kaddr + offset, bytes, i);
  		kunmap_atomic(kaddr);
  		return wanted;
++<<<<<<< HEAD
 +	} else if (likely(!(i->type & ITER_PIPE)))
++=======
+ 	} else if (unlikely(iov_iter_is_discard(i)))
+ 		return bytes;
+ 	else if (likely(!iov_iter_is_pipe(i)))
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		return copy_page_to_iter_iovec(page, offset, bytes, i);
  	else
  		return copy_page_to_iter_pipe(page, offset, bytes, i);
@@@ -849,7 -855,7 +858,11 @@@ size_t copy_page_from_iter(struct page 
  {
  	if (unlikely(!page_copy_sane(page, offset, bytes)))
  		return 0;
++<<<<<<< HEAD
 +	if (unlikely(i->type & ITER_PIPE)) {
++=======
+ 	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) {
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		WARN_ON(1);
  		return 0;
  	}
@@@ -909,7 -915,7 +922,11 @@@ size_t iov_iter_copy_from_user_atomic(s
  		kunmap_atomic(kaddr);
  		return 0;
  	}
++<<<<<<< HEAD
 +	if (unlikely(i->type & ITER_PIPE)) {
++=======
+ 	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) {
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		kunmap_atomic(kaddr);
  		WARN_ON(1);
  		return 0;
@@@ -1054,7 -1066,9 +1077,13 @@@ size_t iov_iter_single_seg_count(const 
  		return i->count;	// it is a silly place, anyway
  	if (i->nr_segs == 1)
  		return i->count;
++<<<<<<< HEAD
 +	else if (i->type & ITER_BVEC)
++=======
+ 	if (unlikely(iov_iter_is_discard(i)))
+ 		return i->count;
+ 	else if (iov_iter_is_bvec(i))
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		return min(i->count, i->bvec->bv_len - i->iov_offset);
  	else
  		return min(i->count, i->iov->iov_len - i->iov_offset);
@@@ -1126,7 -1158,7 +1173,11 @@@ unsigned long iov_iter_gap_alignment(co
  	unsigned long res = 0;
  	size_t size = i->count;
  
++<<<<<<< HEAD
 +	if (unlikely(i->type & ITER_PIPE)) {
++=======
+ 	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) {
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		WARN_ON(1);
  		return ~0U;
  	}
@@@ -1194,8 -1226,11 +1245,11 @@@ ssize_t iov_iter_get_pages(struct iov_i
  	if (maxsize > i->count)
  		maxsize = i->count;
  
 -	if (unlikely(iov_iter_is_pipe(i)))
 +	if (unlikely(i->type & ITER_PIPE))
  		return pipe_get_pages(i, pages, maxsize, maxpages, start);
+ 	if (unlikely(iov_iter_is_discard(i)))
+ 		return -EFAULT;
+ 
  	iterate_all_kinds(i, maxsize, v, ({
  		unsigned long addr = (unsigned long)v.iov_base;
  		size_t len = v.iov_len + (*start = addr & (PAGE_SIZE - 1));
@@@ -1271,8 -1306,11 +1325,11 @@@ ssize_t iov_iter_get_pages_alloc(struc
  	if (maxsize > i->count)
  		maxsize = i->count;
  
 -	if (unlikely(iov_iter_is_pipe(i)))
 +	if (unlikely(i->type & ITER_PIPE))
  		return pipe_get_pages_alloc(i, pages, maxsize, start);
+ 	if (unlikely(iov_iter_is_discard(i)))
+ 		return -EFAULT;
+ 
  	iterate_all_kinds(i, maxsize, v, ({
  		unsigned long addr = (unsigned long)v.iov_base;
  		size_t len = v.iov_len + (*start = addr & (PAGE_SIZE - 1));
@@@ -1314,7 -1352,7 +1371,11 @@@ size_t csum_and_copy_from_iter(void *ad
  	__wsum sum, next;
  	size_t off = 0;
  	sum = *csum;
++<<<<<<< HEAD
 +	if (unlikely(i->type & ITER_PIPE)) {
++=======
+ 	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) {
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		WARN_ON(1);
  		return 0;
  	}
@@@ -1356,7 -1394,7 +1417,11 @@@ bool csum_and_copy_from_iter_full(void 
  	__wsum sum, next;
  	size_t off = 0;
  	sum = *csum;
++<<<<<<< HEAD
 +	if (unlikely(i->type & ITER_PIPE)) {
++=======
+ 	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) {
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		WARN_ON(1);
  		return false;
  	}
@@@ -1402,7 -1439,7 +1467,11 @@@ size_t csum_and_copy_to_iter(const voi
  	__wsum sum, next;
  	size_t off = 0;
  	sum = *csum;
++<<<<<<< HEAD
 +	if (unlikely(i->type & ITER_PIPE)) {
++=======
+ 	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) {
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		WARN_ON(1);	/* for now */
  		return 0;
  	}
@@@ -1463,8 -1481,10 +1532,10 @@@ int iov_iter_npages(const struct iov_it
  
  	if (!size)
  		return 0;
+ 	if (unlikely(iov_iter_is_discard(i)))
+ 		return 0;
  
 -	if (unlikely(iov_iter_is_pipe(i))) {
 +	if (unlikely(i->type & ITER_PIPE)) {
  		struct pipe_inode_info *pipe = i->pipe;
  		size_t off;
  		int idx;
@@@ -1506,7 -1526,9 +1577,13 @@@ const void *dup_iter(struct iov_iter *n
  		WARN_ON(1);
  		return NULL;
  	}
++<<<<<<< HEAD
 +	if (new->type & ITER_BVEC)
++=======
+ 	if (unlikely(iov_iter_is_discard(new)))
+ 		return NULL;
+ 	if (iov_iter_is_bvec(new))
++>>>>>>> 9ea9ce0427aa (iov_iter: Add I/O discard iterator)
  		return new->bvec = kmemdup(new->bvec,
  				    new->nr_segs * sizeof(struct bio_vec),
  				    flags);
* Unmerged path include/linux/uio.h
* Unmerged path lib/iov_iter.c
