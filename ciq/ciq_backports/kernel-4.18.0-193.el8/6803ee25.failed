libbpf: Extract and generalize CPU mask parsing logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 6803ee25f0ead1e836808acb14396bb9a9849113
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6803ee25.failed

This logic is re-used for parsing a set of online CPUs. Having it as an
isolated piece of code working with input string makes it conveninent to test
this logic as well. While refactoring, also improve the robustness of original
implementation.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20191212013548.1690564-1-andriin@fb.com
(cherry picked from commit 6803ee25f0ead1e836808acb14396bb9a9849113)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf_internal.h
diff --cc tools/lib/bpf/libbpf.c
index c4973b88b834,98455e8aa6db..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -5019,47 -6611,16 +5092,59 @@@ int libbpf_num_possible_cpus(void
  	if (tmp_cpus > 0)
  		return tmp_cpus;
  
++<<<<<<< HEAD
 +	fd = open(fcpu, O_RDONLY);
 +	if (fd < 0) {
 +		error = errno;
 +		pr_warning("Failed to open file %s: %s\n",
 +			   fcpu, strerror(error));
 +		return -error;
 +	}
 +	len = read(fd, buf, sizeof(buf));
 +	close(fd);
 +	if (len <= 0) {
 +		error = len ? errno : EINVAL;
 +		pr_warning("Failed to read # of possible cpus from %s: %s\n",
 +			   fcpu, strerror(error));
 +		return -error;
 +	}
 +	if (len == sizeof(buf)) {
 +		pr_warning("File %s size overflow\n", fcpu);
 +		return -EOVERFLOW;
 +	}
 +	buf[len] = '\0';
 +
 +	for (ir = 0, tmp_cpus = 0; ir <= len; ir++) {
 +		/* Each sub string separated by ',' has format \d+-\d+ or \d+ */
 +		if (buf[ir] == ',' || buf[ir] == '\0') {
 +			buf[ir] = '\0';
 +			n = sscanf(&buf[il], "%u-%u", &start, &end);
 +			if (n <= 0) {
 +				pr_warning("Failed to get # CPUs from %s\n",
 +					   &buf[il]);
 +				return -EINVAL;
 +			} else if (n == 1) {
 +				end = start;
 +			}
 +			tmp_cpus += end - start + 1;
 +			il = ir + 1;
 +		}
 +	}
 +	if (tmp_cpus <= 0) {
 +		pr_warning("Invalid #CPUs %d from %s\n", tmp_cpus, fcpu);
 +		return -EINVAL;
++=======
+ 	err = parse_cpu_mask_file(fcpu, &mask, &n);
+ 	if (err)
+ 		return err;
+ 
+ 	tmp_cpus = 0;
+ 	for (i = 0; i < n; i++) {
+ 		if (mask[i])
+ 			tmp_cpus++;
++>>>>>>> 6803ee25f0ea (libbpf: Extract and generalize CPU mask parsing logic)
  	}
+ 	free(mask);
  
  	WRITE_ONCE(cpus, tmp_cpus);
  	return tmp_cpus;
diff --cc tools/lib/bpf/libbpf_internal.h
index 2e83a34f8c79,f4f10715db40..000000000000
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@@ -47,6 -63,40 +47,43 @@@ do {				
  #define pr_info(fmt, ...)	__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)
  #define pr_debug(fmt, ...)	__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)
  
++<<<<<<< HEAD
++=======
+ static inline bool libbpf_validate_opts(const char *opts,
+ 					size_t opts_sz, size_t user_sz,
+ 					const char *type_name)
+ {
+ 	if (user_sz < sizeof(size_t)) {
+ 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
+ 		return false;
+ 	}
+ 	if (user_sz > opts_sz) {
+ 		size_t i;
+ 
+ 		for (i = opts_sz; i < user_sz; i++) {
+ 			if (opts[i]) {
+ 				pr_warn("%s has non-zero extra bytes",
+ 					type_name);
+ 				return false;
+ 			}
+ 		}
+ 	}
+ 	return true;
+ }
+ 
+ #define OPTS_VALID(opts, type)						      \
+ 	(!(opts) || libbpf_validate_opts((const char *)opts,		      \
+ 					 offsetofend(struct type,	      \
+ 						     type##__last_field),     \
+ 					 (opts)->sz, #type))
+ #define OPTS_HAS(opts, field) \
+ 	((opts) && opts->sz >= offsetofend(typeof(*(opts)), field))
+ #define OPTS_GET(opts, field, fallback_value) \
+ 	(OPTS_HAS(opts, field) ? (opts)->field : fallback_value)
+ 
+ int parse_cpu_mask_str(const char *s, bool **mask, int *mask_sz);
+ int parse_cpu_mask_file(const char *fcpu, bool **mask, int *mask_sz);
++>>>>>>> 6803ee25f0ea (libbpf: Extract and generalize CPU mask parsing logic)
  int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
  			 const char *str_sec, size_t str_len);
  
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf_internal.h
