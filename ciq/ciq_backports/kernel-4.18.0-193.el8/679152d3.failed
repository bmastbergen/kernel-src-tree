libbpf: Fix printf compilation warnings on ppc64le arch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 679152d3a32e305c213f83160c328c37566ae8bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/679152d3.failed

On ppc64le __u64 and __s64 are defined as long int and unsigned long int,
respectively. This causes compiler to emit warning when %lld/%llu are used to
printf 64-bit numbers. Fix this by casting to size_t/ssize_t with %zu and %zd
format specifiers, respectively.

v1->v2:
- use size_t/ssize_t instead of custom typedefs (Martin).

Fixes: 1f8e2bcb2cd5 ("libbpf: Refactor relocation handling")
Fixes: abd29c931459 ("libbpf: allow specifying map definitions using BTF")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20191212171918.638010-1-andriin@fb.com
(cherry picked from commit 679152d3a32e305c213f83160c328c37566ae8bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index c4973b88b834,920d4e06a5f9..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -1192,15 -1242,15 +1192,25 @@@ static int bpf_object__init_user_btf_ma
  			}
  			sz = btf__resolve_size(obj->btf, t->type);
  			if (sz < 0) {
++<<<<<<< HEAD
 +				pr_warning("map '%s': can't determine key size for type [%u]: %lld.\n",
 +					   map_name, t->type, sz);
++=======
+ 				pr_warn("map '%s': can't determine key size for type [%u]: %zd.\n",
+ 					map_name, t->type, (ssize_t)sz);
++>>>>>>> 679152d3a32e (libbpf: Fix printf compilation warnings on ppc64le arch)
  				return sz;
  			}
- 			pr_debug("map '%s': found key [%u], sz = %lld.\n",
- 				 map_name, t->type, sz);
+ 			pr_debug("map '%s': found key [%u], sz = %zd.\n",
+ 				 map_name, t->type, (ssize_t)sz);
  			if (map->def.key_size && map->def.key_size != sz) {
++<<<<<<< HEAD
 +				pr_warning("map '%s': conflicting key size %u != %lld.\n",
 +					   map_name, map->def.key_size, sz);
++=======
+ 				pr_warn("map '%s': conflicting key size %u != %zd.\n",
+ 					map_name, map->def.key_size, (ssize_t)sz);
++>>>>>>> 679152d3a32e (libbpf: Fix printf compilation warnings on ppc64le arch)
  				return -EINVAL;
  			}
  			map->def.key_size = sz;
@@@ -1235,15 -1285,15 +1245,25 @@@
  			}
  			sz = btf__resolve_size(obj->btf, t->type);
  			if (sz < 0) {
++<<<<<<< HEAD
 +				pr_warning("map '%s': can't determine value size for type [%u]: %lld.\n",
 +					   map_name, t->type, sz);
++=======
+ 				pr_warn("map '%s': can't determine value size for type [%u]: %zd.\n",
+ 					map_name, t->type, (ssize_t)sz);
++>>>>>>> 679152d3a32e (libbpf: Fix printf compilation warnings on ppc64le arch)
  				return sz;
  			}
- 			pr_debug("map '%s': found value [%u], sz = %lld.\n",
- 				 map_name, t->type, sz);
+ 			pr_debug("map '%s': found value [%u], sz = %zd.\n",
+ 				 map_name, t->type, (ssize_t)sz);
  			if (map->def.value_size && map->def.value_size != sz) {
++<<<<<<< HEAD
 +				pr_warning("map '%s': conflicting value size %u != %lld.\n",
 +					   map_name, map->def.value_size, sz);
++=======
+ 				pr_warn("map '%s': conflicting value size %u != %zd.\n",
+ 					map_name, map->def.value_size, (ssize_t)sz);
++>>>>>>> 679152d3a32e (libbpf: Fix printf compilation warnings on ppc64le arch)
  				return -EINVAL;
  			}
  			map->def.value_size = sz;
@@@ -1724,6 -1793,116 +1744,119 @@@ bpf_object__section_to_libbpf_map_type(
  		return LIBBPF_MAP_UNSPEC;
  }
  
++<<<<<<< HEAD
++=======
+ static int bpf_program__record_reloc(struct bpf_program *prog,
+ 				     struct reloc_desc *reloc_desc,
+ 				     __u32 insn_idx, const char *name,
+ 				     const GElf_Sym *sym, const GElf_Rel *rel)
+ {
+ 	struct bpf_insn *insn = &prog->insns[insn_idx];
+ 	size_t map_idx, nr_maps = prog->obj->nr_maps;
+ 	struct bpf_object *obj = prog->obj;
+ 	__u32 shdr_idx = sym->st_shndx;
+ 	enum libbpf_map_type type;
+ 	struct bpf_map *map;
+ 
+ 	/* sub-program call relocation */
+ 	if (insn->code == (BPF_JMP | BPF_CALL)) {
+ 		if (insn->src_reg != BPF_PSEUDO_CALL) {
+ 			pr_warn("incorrect bpf_call opcode\n");
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		/* text_shndx can be 0, if no default "main" program exists */
+ 		if (!shdr_idx || shdr_idx != obj->efile.text_shndx) {
+ 			pr_warn("bad call relo against section %u\n", shdr_idx);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		if (sym->st_value % 8) {
+ 			pr_warn("bad call relo offset: %zu\n",
+ 				(size_t)sym->st_value);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		reloc_desc->type = RELO_CALL;
+ 		reloc_desc->insn_idx = insn_idx;
+ 		reloc_desc->sym_off = sym->st_value;
+ 		obj->has_pseudo_calls = true;
+ 		return 0;
+ 	}
+ 
+ 	if (insn->code != (BPF_LD | BPF_IMM | BPF_DW)) {
+ 		pr_warn("invalid relo for insns[%d].code 0x%x\n",
+ 			insn_idx, insn->code);
+ 		return -LIBBPF_ERRNO__RELOC;
+ 	}
+ 	if (!shdr_idx || shdr_idx >= SHN_LORESERVE) {
+ 		pr_warn("invalid relo for \'%s\' in special section 0x%x; forgot to initialize global var?..\n",
+ 			name, shdr_idx);
+ 		return -LIBBPF_ERRNO__RELOC;
+ 	}
+ 
+ 	type = bpf_object__section_to_libbpf_map_type(obj, shdr_idx);
+ 
+ 	/* generic map reference relocation */
+ 	if (type == LIBBPF_MAP_UNSPEC) {
+ 		if (!bpf_object__shndx_is_maps(obj, shdr_idx)) {
+ 			pr_warn("bad map relo against section %u\n",
+ 				shdr_idx);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		for (map_idx = 0; map_idx < nr_maps; map_idx++) {
+ 			map = &obj->maps[map_idx];
+ 			if (map->libbpf_type != type ||
+ 			    map->sec_idx != sym->st_shndx ||
+ 			    map->sec_offset != sym->st_value)
+ 				continue;
+ 			pr_debug("found map %zd (%s, sec %d, off %zu) for insn %u\n",
+ 				 map_idx, map->name, map->sec_idx,
+ 				 map->sec_offset, insn_idx);
+ 			break;
+ 		}
+ 		if (map_idx >= nr_maps) {
+ 			pr_warn("map relo failed to find map for sec %u, off %zu\n",
+ 				shdr_idx, (size_t)sym->st_value);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 		reloc_desc->type = RELO_LD64;
+ 		reloc_desc->insn_idx = insn_idx;
+ 		reloc_desc->map_idx = map_idx;
+ 		reloc_desc->sym_off = 0; /* sym->st_value determines map_idx */
+ 		return 0;
+ 	}
+ 
+ 	/* global data map relocation */
+ 	if (!bpf_object__shndx_is_data(obj, shdr_idx)) {
+ 		pr_warn("bad data relo against section %u\n", shdr_idx);
+ 		return -LIBBPF_ERRNO__RELOC;
+ 	}
+ 	if (!obj->caps.global_data) {
+ 		pr_warn("relocation: kernel does not support global \'%s\' variable access in insns[%d]\n",
+ 			name, insn_idx);
+ 		return -LIBBPF_ERRNO__RELOC;
+ 	}
+ 	for (map_idx = 0; map_idx < nr_maps; map_idx++) {
+ 		map = &obj->maps[map_idx];
+ 		if (map->libbpf_type != type)
+ 			continue;
+ 		pr_debug("found data map %zd (%s, sec %d, off %zu) for insn %u\n",
+ 			 map_idx, map->name, map->sec_idx, map->sec_offset,
+ 			 insn_idx);
+ 		break;
+ 	}
+ 	if (map_idx >= nr_maps) {
+ 		pr_warn("data relo failed to find map for sec %u\n",
+ 			shdr_idx);
+ 		return -LIBBPF_ERRNO__RELOC;
+ 	}
+ 
+ 	reloc_desc->type = RELO_DATA;
+ 	reloc_desc->insn_idx = insn_idx;
+ 	reloc_desc->map_idx = map_idx;
+ 	reloc_desc->sym_off = sym->st_value;
+ 	return 0;
+ }
+ 
++>>>>>>> 679152d3a32e (libbpf: Fix printf compilation warnings on ppc64le arch)
  static int
  bpf_program__collect_reloc(struct bpf_program *prog, GElf_Shdr *shdr,
  			   Elf_Data *data, struct bpf_object *obj)
@@@ -1767,87 -1941,17 +1900,95 @@@
  		name = elf_strptr(obj->efile.elf, obj->efile.strtabidx,
  				  sym.st_name) ? : "<?>";
  
++<<<<<<< HEAD
 +		pr_debug("relo for %lld value %lld name %d (\'%s\')\n",
 +			 (long long) (rel.r_info >> 32),
 +			 (long long) sym.st_value, sym.st_name, name);
++=======
+ 		pr_debug("relo for shdr %u, symb %zu, value %zu, type %d, bind %d, name %d (\'%s\'), insn %u\n",
+ 			 (__u32)sym.st_shndx, (size_t)GELF_R_SYM(rel.r_info),
+ 			 (size_t)sym.st_value, GELF_ST_TYPE(sym.st_info),
+ 			 GELF_ST_BIND(sym.st_info), sym.st_name, name,
+ 			 insn_idx);
++>>>>>>> 679152d3a32e (libbpf: Fix printf compilation warnings on ppc64le arch)
  
 -		err = bpf_program__record_reloc(prog, &prog->reloc_desc[i],
 -						insn_idx, name, &sym, &rel);
 -		if (err)
 -			return err;
 +		shdr_idx = sym.st_shndx;
 +		insn_idx = rel.r_offset / sizeof(struct bpf_insn);
 +		pr_debug("relocation: insn_idx=%u, shdr_idx=%u\n",
 +			 insn_idx, shdr_idx);
 +
 +		if (shdr_idx >= SHN_LORESERVE) {
 +			pr_warning("relocation: not yet supported relo for non-static global \'%s\' variable in special section (0x%x) found in insns[%d].code 0x%x\n",
 +				   name, shdr_idx, insn_idx,
 +				   insns[insn_idx].code);
 +			return -LIBBPF_ERRNO__RELOC;
 +		}
 +		if (!bpf_object__relo_in_known_section(obj, shdr_idx)) {
 +			pr_warning("Program '%s' contains unrecognized relo data pointing to section %u\n",
 +				   prog->section_name, shdr_idx);
 +			return -LIBBPF_ERRNO__RELOC;
 +		}
 +
 +		if (insns[insn_idx].code == (BPF_JMP | BPF_CALL)) {
 +			if (insns[insn_idx].src_reg != BPF_PSEUDO_CALL) {
 +				pr_warning("incorrect bpf_call opcode\n");
 +				return -LIBBPF_ERRNO__RELOC;
 +			}
 +			prog->reloc_desc[i].type = RELO_CALL;
 +			prog->reloc_desc[i].insn_idx = insn_idx;
 +			prog->reloc_desc[i].text_off = sym.st_value;
 +			obj->has_pseudo_calls = true;
 +			continue;
 +		}
 +
 +		if (insns[insn_idx].code != (BPF_LD | BPF_IMM | BPF_DW)) {
 +			pr_warning("bpf: relocation: invalid relo for insns[%d].code 0x%x\n",
 +				   insn_idx, insns[insn_idx].code);
 +			return -LIBBPF_ERRNO__RELOC;
 +		}
 +
 +		if (bpf_object__shndx_is_maps(obj, shdr_idx) ||
 +		    bpf_object__shndx_is_data(obj, shdr_idx)) {
 +			type = bpf_object__section_to_libbpf_map_type(obj, shdr_idx);
 +			if (type != LIBBPF_MAP_UNSPEC) {
 +				if (GELF_ST_BIND(sym.st_info) == STB_GLOBAL) {
 +					pr_warning("bpf: relocation: not yet supported relo for non-static global \'%s\' variable found in insns[%d].code 0x%x\n",
 +						   name, insn_idx, insns[insn_idx].code);
 +					return -LIBBPF_ERRNO__RELOC;
 +				}
 +				if (!obj->caps.global_data) {
 +					pr_warning("bpf: relocation: kernel does not support global \'%s\' variable access in insns[%d]\n",
 +						   name, insn_idx);
 +					return -LIBBPF_ERRNO__RELOC;
 +				}
 +			}
 +
 +			for (map_idx = 0; map_idx < nr_maps; map_idx++) {
 +				if (maps[map_idx].libbpf_type != type)
 +					continue;
 +				if (type != LIBBPF_MAP_UNSPEC ||
 +				    (maps[map_idx].sec_idx == sym.st_shndx &&
 +				     maps[map_idx].sec_offset == sym.st_value)) {
 +					pr_debug("relocation: found map %zd (%s, sec_idx %d, offset %zu) for insn %u\n",
 +						 map_idx, maps[map_idx].name,
 +						 maps[map_idx].sec_idx,
 +						 maps[map_idx].sec_offset,
 +						 insn_idx);
 +					break;
 +				}
 +			}
 +
 +			if (map_idx >= nr_maps) {
 +				pr_warning("bpf relocation: map_idx %d larger than %d\n",
 +					   (int)map_idx, (int)nr_maps - 1);
 +				return -LIBBPF_ERRNO__RELOC;
 +			}
 +
 +			prog->reloc_desc[i].type = type != LIBBPF_MAP_UNSPEC ?
 +						   RELO_DATA : RELO_LD64;
 +			prog->reloc_desc[i].insn_idx = insn_idx;
 +			prog->reloc_desc[i].map_idx = map_idx;
 +		}
  	}
  	return 0;
  }
* Unmerged path tools/lib/bpf/libbpf.c
