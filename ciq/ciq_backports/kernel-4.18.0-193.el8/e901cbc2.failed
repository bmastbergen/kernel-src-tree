xfrm: policy: check reinserted policies match their node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit e901cbc29316fb06423de5dfbc5afb78d4efda53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e901cbc2.failed

validate the re-inserted policies match the lookup node.
Policies that fail this test won't be returned in the candidate set.

This is enabled by default for now, it should not cause noticeable
reinsert slow down.

Such reinserts are needed when we have to merge an existing node
(e.g. for 10.0.0.0/28 because a overlapping subnet was added (e.g.
10.0.0.0/24), so whenever this happens existing policies have to
be placed on the list of the new node.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit e901cbc29316fb06423de5dfbc5afb78d4efda53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,57e28dcd7c53..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -560,6 -655,432 +560,435 @@@ static void xfrm_hash_resize(struct wor
  	mutex_unlock(&hash_resize_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ static void xfrm_hash_reset_inexact_table(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *b;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry(b, &net->xfrm.inexact_bins, inexact_bins)
+ 		INIT_HLIST_HEAD(&b->hhead);
+ }
+ 
+ /* Make sure *pol can be inserted into fastbin.
+  * Useful to check that later insert requests will be sucessful
+  * (provided xfrm_policy_lock is held throughout).
+  */
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_alloc_bin(const struct xfrm_policy *pol, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *prev;
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = pol->family,
+ 		.type = pol->type,
+ 		.dir = dir,
+ 		.if_id = pol->if_id,
+ 	};
+ 	struct net *net = xp_net(pol);
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	write_pnet(&k.net, net);
+ 	bin = rhashtable_lookup_fast(&xfrm_policy_inexact_table, &k,
+ 				     xfrm_pol_inexact_params);
+ 	if (bin)
+ 		return bin;
+ 
+ 	bin = kzalloc(sizeof(*bin), GFP_ATOMIC);
+ 	if (!bin)
+ 		return NULL;
+ 
+ 	bin->k = k;
+ 	INIT_HLIST_HEAD(&bin->hhead);
+ 	bin->root_d = RB_ROOT;
+ 	seqcount_init(&bin->count);
+ 
+ 	prev = rhashtable_lookup_get_insert_key(&xfrm_policy_inexact_table,
+ 						&bin->k, &bin->head,
+ 						xfrm_pol_inexact_params);
+ 	if (!prev) {
+ 		list_add(&bin->inexact_bins, &net->xfrm.inexact_bins);
+ 		return bin;
+ 	}
+ 
+ 	kfree(bin);
+ 
+ 	return IS_ERR(prev) ? NULL : prev;
+ }
+ 
+ static bool xfrm_pol_inexact_addr_use_any_list(const xfrm_address_t *addr,
+ 					       int family, u8 prefixlen)
+ {
+ 	if (xfrm_addr_any(addr, family))
+ 		return true;
+ 
+ 	if (family == AF_INET6 && prefixlen < INEXACT_PREFIXLEN_IPV6)
+ 		return true;
+ 
+ 	if (family == AF_INET && prefixlen < INEXACT_PREFIXLEN_IPV4)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool
+ xfrm_policy_inexact_insert_use_any_list(const struct xfrm_policy *policy)
+ {
+ 	const xfrm_address_t *addr;
+ 	bool saddr_any, daddr_any;
+ 	u8 prefixlen;
+ 
+ 	addr = &policy->selector.saddr;
+ 	prefixlen = policy->selector.prefixlen_s;
+ 
+ 	saddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	addr = &policy->selector.daddr;
+ 	prefixlen = policy->selector.prefixlen_d;
+ 	daddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	return saddr_any && daddr_any;
+ }
+ 
+ static void xfrm_pol_inexact_node_init(struct xfrm_pol_inexact_node *node,
+ 				       const xfrm_address_t *addr, u8 prefixlen)
+ {
+ 	node->addr = *addr;
+ 	node->prefixlen = prefixlen;
+ }
+ 
+ static struct xfrm_pol_inexact_node *
+ xfrm_pol_inexact_node_alloc(const xfrm_address_t *addr, u8 prefixlen)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 
+ 	node = kzalloc(sizeof(*node), GFP_ATOMIC);
+ 	if (node)
+ 		xfrm_pol_inexact_node_init(node, addr, prefixlen);
+ 
+ 	return node;
+ }
+ 
+ static int xfrm_policy_addr_delta(const xfrm_address_t *a,
+ 				  const xfrm_address_t *b,
+ 				  u8 prefixlen, u16 family)
+ {
+ 	unsigned int pdw, pbi;
+ 	int delta = 0;
+ 
+ 	switch (family) {
+ 	case AF_INET:
+ 		if (sizeof(long) == 4 && prefixlen == 0)
+ 			return ntohl(a->a4) - ntohl(b->a4);
+ 		return (ntohl(a->a4) & ((~0UL << (32 - prefixlen)))) -
+ 		       (ntohl(b->a4) & ((~0UL << (32 - prefixlen))));
+ 	case AF_INET6:
+ 		pdw = prefixlen >> 5;
+ 		pbi = prefixlen & 0x1f;
+ 
+ 		if (pdw) {
+ 			delta = memcmp(a->a6, b->a6, pdw << 2);
+ 			if (delta)
+ 				return delta;
+ 		}
+ 		if (pbi) {
+ 			u32 mask = ~0u << (32 - pbi);
+ 
+ 			delta = (ntohl(a->a6[pdw]) & mask) -
+ 				(ntohl(b->a6[pdw]) & mask);
+ 		}
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return delta;
+ }
+ 
+ static void xfrm_policy_inexact_list_reinsert(struct net *net,
+ 					      struct xfrm_pol_inexact_node *n,
+ 					      u16 family)
+ {
+ 	unsigned int matched_s, matched_d;
+ 	struct hlist_node *newpos = NULL;
+ 	struct xfrm_policy *policy, *p;
+ 
+ 	matched_s = 0;
+ 	matched_d = 0;
+ 
+ 	list_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {
+ 		bool matches_s, matches_d;
+ 
+ 		if (!policy->bydst_reinsert)
+ 			continue;
+ 
+ 		WARN_ON_ONCE(policy->family != family);
+ 
+ 		policy->bydst_reinsert = false;
+ 		hlist_for_each_entry(p, &n->hhead, bydst) {
+ 			if (policy->priority >= p->priority)
+ 				newpos = &p->bydst;
+ 			else
+ 				break;
+ 		}
+ 
+ 		if (newpos)
+ 			hlist_add_behind(&policy->bydst, newpos);
+ 		else
+ 			hlist_add_head(&policy->bydst, &n->hhead);
+ 
+ 		/* paranoia checks follow.
+ 		 * Check that the reinserted policy matches at least
+ 		 * saddr or daddr for current node prefix.
+ 		 *
+ 		 * Matching both is fine, matching saddr in one policy
+ 		 * (but not daddr) and then matching only daddr in another
+ 		 * is a bug.
+ 		 */
+ 		matches_s = xfrm_policy_addr_delta(&policy->selector.saddr,
+ 						   &n->addr,
+ 						   n->prefixlen,
+ 						   family) == 0;
+ 		matches_d = xfrm_policy_addr_delta(&policy->selector.daddr,
+ 						   &n->addr,
+ 						   n->prefixlen,
+ 						   family) == 0;
+ 		if (matches_s && matches_d)
+ 			continue;
+ 
+ 		WARN_ON_ONCE(!matches_s && !matches_d);
+ 		if (matches_s)
+ 			matched_s++;
+ 		if (matches_d)
+ 			matched_d++;
+ 		WARN_ON_ONCE(matched_s && matched_d);
+ 	}
+ }
+ 
+ /* merge nodes v and n */
+ static void xfrm_policy_inexact_node_merge(struct net *net,
+ 					   struct xfrm_pol_inexact_node *v,
+ 					   struct xfrm_pol_inexact_node *n,
+ 					   u16 family)
+ {
+ 	struct xfrm_policy *tmp;
+ 
+ 	hlist_for_each_entry(tmp, &v->hhead, bydst)
+ 		tmp->bydst_reinsert = true;
+ 	hlist_for_each_entry(tmp, &n->hhead, bydst)
+ 		tmp->bydst_reinsert = true;
+ 
+ 	INIT_HLIST_HEAD(&n->hhead);
+ 	xfrm_policy_inexact_list_reinsert(net, n, family);
+ }
+ 
+ static struct xfrm_pol_inexact_node *
+ xfrm_policy_inexact_insert_node(struct net *net,
+ 				struct rb_root *root,
+ 				xfrm_address_t *addr,
+ 				u16 family, u8 prefixlen, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_node *cached = NULL;
+ 	struct rb_node **p, *parent = NULL;
+ 	struct xfrm_pol_inexact_node *node;
+ 
+ 	p = &root->rb_node;
+ 	while (*p) {
+ 		int delta;
+ 
+ 		parent = *p;
+ 		node = rb_entry(*p, struct xfrm_pol_inexact_node, node);
+ 
+ 		delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 					       node->prefixlen,
+ 					       family);
+ 		if (delta == 0 && prefixlen >= node->prefixlen) {
+ 			WARN_ON_ONCE(cached); /* ipsec policies got lost */
+ 			return node;
+ 		}
+ 
+ 		if (delta < 0)
+ 			p = &parent->rb_left;
+ 		else
+ 			p = &parent->rb_right;
+ 
+ 		if (prefixlen < node->prefixlen) {
+ 			delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 						       prefixlen,
+ 						       family);
+ 			if (delta)
+ 				continue;
+ 
+ 			/* This node is a subnet of the new prefix. It needs
+ 			 * to be removed and re-inserted with the smaller
+ 			 * prefix and all nodes that are now also covered
+ 			 * by the reduced prefixlen.
+ 			 */
+ 			rb_erase(&node->node, root);
+ 
+ 			if (!cached) {
+ 				xfrm_pol_inexact_node_init(node, addr,
+ 							   prefixlen);
+ 				cached = node;
+ 			} else {
+ 				/* This node also falls within the new
+ 				 * prefixlen. Merge the to-be-reinserted
+ 				 * node and this one.
+ 				 */
+ 				xfrm_policy_inexact_node_merge(net, node,
+ 							       cached, family);
+ 				kfree_rcu(node, rcu);
+ 			}
+ 
+ 			/* restart */
+ 			p = &root->rb_node;
+ 			parent = NULL;
+ 		}
+ 	}
+ 
+ 	node = cached;
+ 	if (!node) {
+ 		node = xfrm_pol_inexact_node_alloc(addr, prefixlen);
+ 		if (!node)
+ 			return NULL;
+ 	}
+ 
+ 	rb_link_node_rcu(&node->node, parent, p);
+ 	rb_insert_color(&node->node, root);
+ 
+ 	return node;
+ }
+ 
+ static void xfrm_policy_inexact_gc_tree(struct rb_root *r, bool rm)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 	struct rb_node *rn = rb_first(r);
+ 
+ 	while (rn) {
+ 		node = rb_entry(rn, struct xfrm_pol_inexact_node, node);
+ 
+ 		rn = rb_next(rn);
+ 
+ 		if (!hlist_empty(&node->hhead)) {
+ 			WARN_ON_ONCE(rm);
+ 			continue;
+ 		}
+ 
+ 		rb_erase(&node->node, r);
+ 		kfree_rcu(node, rcu);
+ 	}
+ }
+ 
+ static void __xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b, bool net_exit)
+ {
+ 	write_seqcount_begin(&b->count);
+ 	xfrm_policy_inexact_gc_tree(&b->root_d, net_exit);
+ 	write_seqcount_end(&b->count);
+ 
+ 	if (!RB_EMPTY_ROOT(&b->root_d) ||
+ 	    !hlist_empty(&b->hhead)) {
+ 		WARN_ON_ONCE(net_exit);
+ 		return;
+ 	}
+ 
+ 	if (rhashtable_remove_fast(&xfrm_policy_inexact_table, &b->head,
+ 				   xfrm_pol_inexact_params) == 0) {
+ 		list_del(&b->inexact_bins);
+ 		kfree_rcu(b, rcu);
+ 	}
+ }
+ 
+ static void xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b)
+ {
+ 	struct net *net = read_pnet(&b->k.net);
+ 
+ 	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
+ 	__xfrm_policy_inexact_prune_bin(b, false);
+ 	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ }
+ 
+ static void __xfrm_policy_inexact_flush(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *t;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry_safe(bin, t, &net->xfrm.inexact_bins, inexact_bins)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ }
+ 
+ static struct hlist_head *
+ xfrm_policy_inexact_alloc_chain(struct xfrm_pol_inexact_bin *bin,
+ 				struct xfrm_policy *policy, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_node *n;
+ 	struct net *net;
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	if (xfrm_policy_inexact_insert_use_any_list(policy))
+ 		return &bin->hhead;
+ 
+ 	if (xfrm_pol_inexact_addr_use_any_list(&policy->selector.daddr,
+ 					       policy->family,
+ 					       policy->selector.prefixlen_d))
+ 		return &bin->hhead;
+ 
+ 	/* daddr is fixed */
+ 	write_seqcount_begin(&bin->count);
+ 	n = xfrm_policy_inexact_insert_node(net,
+ 					    &bin->root_d,
+ 					    &policy->selector.daddr,
+ 					    policy->family,
+ 					    policy->selector.prefixlen_d, dir);
+ 	write_seqcount_end(&bin->count);
+ 	if (!n)
+ 		return NULL;
+ 	return &n->hhead;
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_inexact_insert(struct xfrm_policy *policy, u8 dir, int excl)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 	struct xfrm_policy *delpol;
+ 	struct hlist_head *chain;
+ 	struct net *net;
+ 
+ 	bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 	if (!bin)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	chain = xfrm_policy_inexact_alloc_chain(bin, policy, dir);
+ 	if (!chain) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	delpol = xfrm_policy_insert_list(chain, policy, excl);
+ 	if (delpol && excl) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-EEXIST);
+ 	}
+ 
+ 	chain = &net->xfrm.policy_inexact[dir];
+ 	xfrm_policy_insert_inexact_list(chain, policy);
+ 
+ 	if (delpol)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 
+ 	return delpol;
+ }
+ 
++>>>>>>> e901cbc29316 (xfrm: policy: check reinserted policies match their node)
  static void xfrm_hash_rebuild(struct work_struct *work)
  {
  	struct net *net = container_of(work, struct net,
* Unmerged path net/xfrm/xfrm_policy.c
