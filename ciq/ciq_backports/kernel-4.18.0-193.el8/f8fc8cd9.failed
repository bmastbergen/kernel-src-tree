RDMA/nldev: Added configuration of RDMA dynamic interrupt moderation to netlink

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Yamin Friedman <yaminf@mellanox.com>
commit f8fc8cd9c612c31f92b19b72f619fa043ec76e5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f8fc8cd9.failed

Added parameter in ib_device for enabling dynamic interrupt moderation so
that it can be configured in userspace using rdma tool.

In order to set adaptive-moderation for an ib device the command is:
rdma dev set [DEV] adaptive-moderation [on|off]
Please set on/off.

rdma dev show
0: mlx5_0: node_type ca fw 16.26.0055 node_guid 248a:0703:00a5:29d0
sys_image_guid 248a:0703:00a5:29d0 adaptive-moderation on

rdma resource show cq
dev mlx5_0 cqn 0 cqe 1023 users 4 poll-ctx UNBOUND_WORKQUEUE
adaptive-moderation off comm [ib_core]

	Signed-off-by: Yamin Friedman <yaminf@mellanox.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f8fc8cd9c612c31f92b19b72f619fa043ec76e5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
#	include/uapi/rdma/rdma_netlink.h
diff --cc drivers/infiniband/core/nldev.c
index efccd8e0fb77,d9f2a30e6467..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -39,31 -40,77 +39,96 @@@
  
  #include "core_priv.h"
  #include "cma_priv.h"
 -#include "restrack.h"
  
 -/*
 - * Sort array elements by the netlink attribute name
 - */
  static const struct nla_policy nldev_policy[RDMA_NLDEV_ATTR_MAX] = {
++<<<<<<< HEAD
 +	[RDMA_NLDEV_ATTR_DEV_INDEX]     = { .type = NLA_U32 },
 +	[RDMA_NLDEV_ATTR_DEV_NAME]	= { .type = NLA_NUL_STRING,
 +					    .len = IB_DEVICE_NAME_MAX - 1},
 +	[RDMA_NLDEV_ATTR_PORT_INDEX]	= { .type = NLA_U32 },
 +	[RDMA_NLDEV_ATTR_FW_VERSION]	= { .type = NLA_NUL_STRING,
 +					    .len = IB_FW_VERSION_NAME_MAX - 1},
 +	[RDMA_NLDEV_ATTR_NODE_GUID]	= { .type = NLA_U64 },
 +	[RDMA_NLDEV_ATTR_SYS_IMAGE_GUID] = { .type = NLA_U64 },
 +	[RDMA_NLDEV_ATTR_SUBNET_PREFIX]	= { .type = NLA_U64 },
 +	[RDMA_NLDEV_ATTR_LID]		= { .type = NLA_U32 },
 +	[RDMA_NLDEV_ATTR_SM_LID]	= { .type = NLA_U32 },
 +	[RDMA_NLDEV_ATTR_LMC]		= { .type = NLA_U8 },
 +	[RDMA_NLDEV_ATTR_PORT_STATE]	= { .type = NLA_U8 },
 +	[RDMA_NLDEV_ATTR_PORT_PHYS_STATE] = { .type = NLA_U8 },
 +	[RDMA_NLDEV_ATTR_DEV_NODE_TYPE] = { .type = NLA_U8 },
 +	[RDMA_NLDEV_ATTR_RES_SUMMARY]	= { .type = NLA_NESTED },
 +	[RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY]	= { .type = NLA_NESTED },
 +	[RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY_NAME] = { .type = NLA_NUL_STRING,
 +					     .len = 16 },
 +	[RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY_CURR] = { .type = NLA_U64 },
++=======
+ 	[RDMA_NLDEV_ATTR_CHARDEV]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_CHARDEV_ABI]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_CHARDEV_NAME]		= { .type = NLA_NUL_STRING,
+ 					.len = RDMA_NLDEV_ATTR_EMPTY_STRING },
+ 	[RDMA_NLDEV_ATTR_CHARDEV_TYPE]		= { .type = NLA_NUL_STRING,
+ 					.len = RDMA_NLDEV_ATTR_CHARDEV_TYPE_SIZE },
+ 	[RDMA_NLDEV_ATTR_DEV_DIM]               = { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_DEV_INDEX]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_DEV_NAME]		= { .type = NLA_NUL_STRING,
+ 					.len = IB_DEVICE_NAME_MAX },
+ 	[RDMA_NLDEV_ATTR_DEV_NODE_TYPE]		= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_DEV_PROTOCOL]		= { .type = NLA_NUL_STRING,
+ 					.len = RDMA_NLDEV_ATTR_EMPTY_STRING },
+ 	[RDMA_NLDEV_ATTR_DRIVER]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_DRIVER_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_DRIVER_PRINT_TYPE]	= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_STRING]		= { .type = NLA_NUL_STRING,
+ 					.len = RDMA_NLDEV_ATTR_EMPTY_STRING },
+ 	[RDMA_NLDEV_ATTR_DRIVER_S32]		= { .type = NLA_S32 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_S64]		= { .type = NLA_S64 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_U32]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_U64]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_FW_VERSION]		= { .type = NLA_NUL_STRING,
+ 					.len = RDMA_NLDEV_ATTR_EMPTY_STRING },
+ 	[RDMA_NLDEV_ATTR_LID]			= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_LINK_TYPE]		= { .type = NLA_NUL_STRING,
+ 					.len = IFNAMSIZ },
+ 	[RDMA_NLDEV_ATTR_LMC]			= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_NDEV_INDEX]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_NDEV_NAME]		= { .type = NLA_NUL_STRING,
+ 					.len = IFNAMSIZ },
+ 	[RDMA_NLDEV_ATTR_NODE_GUID]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_PORT_INDEX]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_PORT_PHYS_STATE]	= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_PORT_STATE]		= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CM_IDN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY]	= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQ]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQE]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_CQN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_CQ_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CTXN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_DST_ADDR]		= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_IOVA]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_KERN_NAME]		= { .type = NLA_NUL_STRING,
+ 					.len = RDMA_NLDEV_ATTR_EMPTY_STRING },
+ 	[RDMA_NLDEV_ATTR_RES_LKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY]	= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_LQPN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_MR]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_MRLEN]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_MRN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_MR_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PATH_MIG_STATE]	= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_RES_PD]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PDN]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_PD_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PID]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_POLL_CTX]		= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_RES_PS]		= { .type = NLA_U32 },
++>>>>>>> f8fc8cd9c612 (RDMA/nldev: Added configuration of RDMA dynamic interrupt moderation to netlink)
  	[RDMA_NLDEV_ATTR_RES_QP]		= { .type = NLA_NESTED },
  	[RDMA_NLDEV_ATTR_RES_QP_ENTRY]		= { .type = NLA_NESTED },
 -	[RDMA_NLDEV_ATTR_RES_RKEY]		= { .type = NLA_U32 },
 +	[RDMA_NLDEV_ATTR_RES_LQPN]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_RES_RQPN]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_RES_RQ_PSN]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_RES_SQ_PSN]		= { .type = NLA_U32 },
@@@ -217,7 -253,27 +282,31 @@@ static int fill_dev_info(struct sk_buf
  		return -EMSGSIZE;
  	if (nla_put_u8(msg, RDMA_NLDEV_ATTR_DEV_NODE_TYPE, device->node_type))
  		return -EMSGSIZE;
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	if (nla_put_u8(msg, RDMA_NLDEV_ATTR_DEV_DIM, device->use_cq_dim))
+ 		return -EMSGSIZE;
+ 
+ 	/*
+ 	 * Link type is determined on first port and mlx4 device
+ 	 * which can potentially have two different link type for the same
+ 	 * IB device is considered as better to be avoided in the future,
+ 	 */
+ 	port = rdma_start_port(device);
+ 	if (rdma_cap_opa_mad(device, port))
+ 		ret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, "opa");
+ 	else if (rdma_protocol_ib(device, port))
+ 		ret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, "ib");
+ 	else if (rdma_protocol_iwarp(device, port))
+ 		ret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, "iw");
+ 	else if (rdma_protocol_roce(device, port))
+ 		ret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, "roce");
+ 	else if (rdma_protocol_usnic(device, port))
+ 		ret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL,
+ 				     "usnic");
+ 	return ret;
++>>>>>>> f8fc8cd9c612 (RDMA/nldev: Added configuration of RDMA dynamic interrupt moderation to netlink)
  }
  
  static int fill_port_info(struct sk_buff *msg,
@@@ -508,6 -555,16 +597,19 @@@ static int fill_res_cq_entry(struct sk_
  	    nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_POLL_CTX, cq->poll_ctx))
  		goto err;
  
++<<<<<<< HEAD
++=======
+ 	if (nla_put_u8(msg, RDMA_NLDEV_ATTR_DEV_DIM, (cq->dim != NULL)))
+ 		goto err;
+ 
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQN, res->id))
+ 		goto err;
+ 	if (!rdma_is_kernel_res(res) &&
+ 	    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CTXN,
+ 			cq->uobject->context->res.id))
+ 		goto err;
+ 
++>>>>>>> f8fc8cd9c612 (RDMA/nldev: Added configuration of RDMA dynamic interrupt moderation to netlink)
  	if (fill_res_name_pid(msg, res))
  		goto err;
  
@@@ -669,9 -865,28 +771,29 @@@ static int nldev_set_doit(struct sk_buf
  		nla_strlcpy(name, tb[RDMA_NLDEV_ATTR_DEV_NAME],
  			    IB_DEVICE_NAME_MAX);
  		err = ib_device_rename(device, name);
 -		goto done;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (tb[RDMA_NLDEV_NET_NS_FD]) {
+ 		u32 ns_fd;
+ 
+ 		ns_fd = nla_get_u32(tb[RDMA_NLDEV_NET_NS_FD]);
+ 		err = ib_device_set_netns_put(skb, device, ns_fd);
+ 		goto put_done;
+ 	}
+ 
+ 	if (tb[RDMA_NLDEV_ATTR_DEV_DIM]) {
+ 		u8 use_dim;
+ 
+ 		use_dim = nla_get_u8(tb[RDMA_NLDEV_ATTR_DEV_DIM]);
+ 		err = ib_device_set_dim(device,  use_dim);
+ 		goto done;
+ 	}
+ 
+ done:
++>>>>>>> f8fc8cd9c612 (RDMA/nldev: Added configuration of RDMA dynamic interrupt moderation to netlink)
  	ib_device_put(device);
 -put_done:
  	return err;
  }
  
diff --cc include/uapi/rdma/rdma_netlink.h
index 213452ef94a5,8e277783fa96..000000000000
--- a/include/uapi/rdma/rdma_netlink.h
+++ b/include/uapi/rdma/rdma_netlink.h
@@@ -458,6 -467,65 +458,68 @@@ enum rdma_nldev_attr 
  	RDMA_NLDEV_ATTR_DRIVER_U64,		/* u64 */
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * Indexes to get/set secific entry,
+ 	 * for QP use RDMA_NLDEV_ATTR_RES_LQPN
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_PDN,               /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_CQN,               /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_MRN,               /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_CM_IDN,            /* u32 */
+ 	RDMA_NLDEV_ATTR_RES_CTXN,	       /* u32 */
+ 	/*
+ 	 * Identifies the rdma driver. eg: "rxe" or "siw"
+ 	 */
+ 	RDMA_NLDEV_ATTR_LINK_TYPE,		/* string */
+ 
+ 	/*
+ 	 * net namespace mode for rdma subsystem:
+ 	 * either shared or exclusive among multiple net namespaces.
+ 	 */
+ 	RDMA_NLDEV_SYS_ATTR_NETNS_MODE,		/* u8 */
+ 	/*
+ 	 * Device protocol, e.g. ib, iw, usnic, roce and opa
+ 	 */
+ 	RDMA_NLDEV_ATTR_DEV_PROTOCOL,		/* string */
+ 
+ 	/*
+ 	 * File descriptor handle of the net namespace object
+ 	 */
+ 	RDMA_NLDEV_NET_NS_FD,			/* u32 */
+ 	/*
+ 	 * Information about a chardev.
+ 	 * CHARDEV_TYPE is the name of the chardev ABI (ie uverbs, umad, etc)
+ 	 * CHARDEV_ABI signals the ABI revision (historical)
+ 	 * CHARDEV_NAME is the kernel name for the /dev/ file (no directory)
+ 	 * CHARDEV is the 64 bit dev_t for the inode
+ 	 */
+ 	RDMA_NLDEV_ATTR_CHARDEV_TYPE,		/* string */
+ 	RDMA_NLDEV_ATTR_CHARDEV_NAME,		/* string */
+ 	RDMA_NLDEV_ATTR_CHARDEV_ABI,		/* u64 */
+ 	RDMA_NLDEV_ATTR_CHARDEV,		/* u64 */
+ 	RDMA_NLDEV_ATTR_UVERBS_DRIVER_ID,       /* u64 */
+ 	/*
+ 	 * Counter-specific attributes.
+ 	 */
+ 	RDMA_NLDEV_ATTR_STAT_MODE,		/* u32 */
+ 	RDMA_NLDEV_ATTR_STAT_RES,		/* u32 */
+ 	RDMA_NLDEV_ATTR_STAT_AUTO_MODE_MASK,	/* u32 */
+ 	RDMA_NLDEV_ATTR_STAT_COUNTER,		/* nested table */
+ 	RDMA_NLDEV_ATTR_STAT_COUNTER_ENTRY,	/* nested table */
+ 	RDMA_NLDEV_ATTR_STAT_COUNTER_ID,	/* u32 */
+ 	RDMA_NLDEV_ATTR_STAT_HWCOUNTERS,	/* nested table */
+ 	RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY,	/* nested table */
+ 	RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_NAME,	/* string */
+ 	RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_VALUE,	/* u64 */
+ 
+ 	/*
+ 	 * CQ adaptive moderatio (DIM)
+ 	 */
+ 	RDMA_NLDEV_ATTR_DEV_DIM,                /* u8 */
+ 
+ 	/*
++>>>>>>> f8fc8cd9c612 (RDMA/nldev: Added configuration of RDMA dynamic interrupt moderation to netlink)
  	 * Always the end
  	 */
  	RDMA_NLDEV_ATTR_MAX
diff --git a/drivers/infiniband/Kconfig b/drivers/infiniband/Kconfig
index 0c60d51c1095..05fed9b00891 100644
--- a/drivers/infiniband/Kconfig
+++ b/drivers/infiniband/Kconfig
@@ -6,6 +6,7 @@ menuconfig INFINIBAND
 	depends on m || IPV6 != m
 	depends on !ALPHA
 	select IRQ_POLL
+	select DIMLIB
 	---help---
 	  Core support for InfiniBand (IB).  Make sure to also select
 	  any protocols you wish to use as well as drivers for your
diff --git a/drivers/infiniband/core/core_priv.h b/drivers/infiniband/core/core_priv.h
index 6629502453b0..eabd8316990a 100644
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@ -57,6 +57,7 @@ struct pkey_index_qp_list {
 int ib_device_register_sysfs(struct ib_device *device);
 void ib_device_unregister_sysfs(struct ib_device *device);
 int ib_device_rename(struct ib_device *ibdev, const char *name);
+int ib_device_set_dim(struct ib_device *ibdev, u8 use_dim);
 
 typedef void (*roce_netdev_callback)(struct ib_device *device, u8 port,
 	      struct net_device *idev, void *cookie);
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index ec96a7b1c811..fca052c8d6e7 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -213,6 +213,15 @@ int ib_device_rename(struct ib_device *ibdev, const char *name)
 	return ret;
 }
 
+int ib_device_set_dim(struct ib_device *ibdev, u8 use_dim)
+{
+	if (use_dim > 1)
+		return -EINVAL;
+	ibdev->use_cq_dim = use_dim;
+
+	return 0;
+}
+
 static int alloc_name(struct ib_device *ibdev, const char *name)
 {
 	struct ib_device *device;
* Unmerged path drivers/infiniband/core/nldev.c
* Unmerged path include/uapi/rdma/rdma_netlink.h
