syscall_get_arch: add "struct task_struct *" argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Dmitry V. Levin <ldv@altlinux.org>
commit 16add411645cff83360086e102daa67b25f1e39a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/16add411.failed

This argument is required to extend the generic ptrace API with
PTRACE_GET_SYSCALL_INFO request: syscall_get_arch() is going
to be called from ptrace_request() along with syscall_get_nr(),
syscall_get_arguments(), syscall_get_error(), and
syscall_get_return_value() functions with a tracee as their argument.

The primary intent is that the triple (audit_arch, syscall_nr, arg1..arg6)
should describe what system call is being called and what its arguments
are.

Reverts: 5e937a9ae913 ("syscall_get_arch: remove useless function arguments")
Reverts: 1002d94d3076 ("syscall.h: fix doc text for syscall_get_arch()")
	Reviewed-by: Andy Lutomirski <luto@kernel.org> # for x86
	Reviewed-by: Palmer Dabbelt <palmer@sifive.com>
	Acked-by: Paul Moore <paul@paul-moore.com>
	Acked-by: Paul Burton <paul.burton@mips.com> # MIPS parts
	Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
	Acked-by: Kees Cook <keescook@chromium.org> # seccomp parts
	Acked-by: Mark Salter <msalter@redhat.com> # for the c6x bit
	Cc: Elvira Khabirova <lineprinter@altlinux.org>
	Cc: Eugene Syromyatnikov <esyr@redhat.com>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: x86@kernel.org
	Cc: linux-alpha@vger.kernel.org
	Cc: linux-snps-arc@lists.infradead.org
	Cc: linux-arm-kernel@lists.infradead.org
	Cc: linux-c6x-dev@linux-c6x.org
	Cc: uclinux-h8-devel@lists.sourceforge.jp
	Cc: linux-hexagon@vger.kernel.org
	Cc: linux-ia64@vger.kernel.org
	Cc: linux-m68k@lists.linux-m68k.org
	Cc: linux-mips@vger.kernel.org
	Cc: nios2-dev@lists.rocketboards.org
	Cc: openrisc@lists.librecores.org
	Cc: linux-parisc@vger.kernel.org
	Cc: linuxppc-dev@lists.ozlabs.org
	Cc: linux-riscv@lists.infradead.org
	Cc: linux-s390@vger.kernel.org
	Cc: linux-sh@vger.kernel.org
	Cc: sparclinux@vger.kernel.org
	Cc: linux-um@lists.infradead.org
	Cc: linux-xtensa@linux-xtensa.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-audit@redhat.com
	Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 16add411645cff83360086e102daa67b25f1e39a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/include/asm/syscall.h
#	arch/c6x/include/asm/syscall.h
#	arch/csky/include/asm/syscall.h
#	arch/h8300/include/asm/syscall.h
#	arch/hexagon/include/asm/syscall.h
#	arch/m68k/include/asm/syscall.h
#	arch/nds32/include/asm/syscall.h
#	arch/nios2/include/asm/syscall.h
#	arch/riscv/include/asm/syscall.h
#	arch/unicore32/include/asm/syscall.h
#	arch/xtensa/include/asm/syscall.h
diff --cc arch/arc/include/asm/syscall.h
index 29de09804306,caf2697ef5b7..000000000000
--- a/arch/arc/include/asm/syscall.h
+++ b/arch/arc/include/asm/syscall.h
@@@ -68,4 -69,14 +68,17 @@@ syscall_get_arguments(struct task_struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ syscall_get_arch(struct task_struct *task)
+ {
+ 	return IS_ENABLED(CONFIG_ISA_ARCOMPACT)
+ 		? (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
+ 			? AUDIT_ARCH_ARCOMPACTBE : AUDIT_ARCH_ARCOMPACT)
+ 		: (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
+ 			? AUDIT_ARCH_ARCV2BE : AUDIT_ARCH_ARCV2);
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  #endif
diff --cc arch/c6x/include/asm/syscall.h
index ae2be315ee9c,595057191c9c..000000000000
--- a/arch/c6x/include/asm/syscall.h
+++ b/arch/c6x/include/asm/syscall.h
@@@ -120,4 -121,10 +120,13 @@@ static inline void syscall_set_argument
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline int syscall_get_arch(struct task_struct *task)
+ {
+ 	return IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
+ 		? AUDIT_ARCH_C6XBE : AUDIT_ARCH_C6X;
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  #endif /* __ASM_C6X_SYSCALLS_H */
diff --cc arch/h8300/include/asm/syscall.h
index 924990401237,d316c3d40d4e..000000000000
--- a/arch/h8300/include/asm/syscall.h
+++ b/arch/h8300/include/asm/syscall.h
@@@ -47,6 -48,11 +47,14 @@@ syscall_get_arguments(struct task_struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ syscall_get_arch(struct task_struct *task)
+ {
+ 	return AUDIT_ARCH_H8300;
+ }
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  
  
  /* Misc syscall related bits */
diff --cc arch/hexagon/include/asm/syscall.h
index 4af9c7b6f13a,47b0bc3f16be..000000000000
--- a/arch/hexagon/include/asm/syscall.h
+++ b/arch/hexagon/include/asm/syscall.h
@@@ -43,4 -45,10 +43,13 @@@ static inline void syscall_get_argument
  	BUG_ON(i + n > 6);
  	memcpy(args, &(&regs->r00)[i], n * sizeof(args[0]));
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int syscall_get_arch(struct task_struct *task)
+ {
+ 	return AUDIT_ARCH_HEXAGON;
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  #endif
diff --cc arch/nds32/include/asm/syscall.h
index f7e5e86765fe,7501e376a6b1..000000000000
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@@ -185,4 -186,12 +185,15 @@@ void syscall_set_arguments(struct task_
  
  	memcpy(&regs->uregs[0] + i, args, n * sizeof(args[0]));
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int
+ syscall_get_arch(struct task_struct *task)
+ {
+ 	return IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
+ 		? AUDIT_ARCH_NDS32BE : AUDIT_ARCH_NDS32;
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  #endif /* _ASM_NDS32_SYSCALL_H */
diff --cc arch/nios2/include/asm/syscall.h
index 9de220854c4a,f0f6ae208e78..000000000000
--- a/arch/nios2/include/asm/syscall.h
+++ b/arch/nios2/include/asm/syscall.h
@@@ -135,4 -136,9 +135,12 @@@ static inline void syscall_set_argument
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline int syscall_get_arch(struct task_struct *task)
+ {
+ 	return AUDIT_ARCH_NIOS2;
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  #endif
diff --cc arch/riscv/include/asm/syscall.h
index 8d25f8904c00,ca120a36a037..000000000000
--- a/arch/riscv/include/asm/syscall.h
+++ b/arch/riscv/include/asm/syscall.h
@@@ -99,4 -100,13 +99,16 @@@ static inline void syscall_set_argument
  	memcpy(&regs->a1 + i * sizeof(regs->a1), args, n * sizeof(regs->a0));
  }
  
++<<<<<<< HEAD
++=======
+ static inline int syscall_get_arch(struct task_struct *task)
+ {
+ #ifdef CONFIG_64BIT
+ 	return AUDIT_ARCH_RISCV64;
+ #else
+ 	return AUDIT_ARCH_RISCV32;
+ #endif
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  #endif	/* _ASM_RISCV_SYSCALL_H */
diff --cc arch/xtensa/include/asm/syscall.h
index 3673ff1f1bc5,0681ca656809..000000000000
--- a/arch/xtensa/include/asm/syscall.h
+++ b/arch/xtensa/include/asm/syscall.h
@@@ -6,11 -4,102 +6,107 @@@
   * for more details.
   *
   * Copyright (C) 2001 - 2007 Tensilica Inc.
 - * Copyright (C) 2018 Cadence Design Systems Inc.
   */
  
++<<<<<<< HEAD
 +struct pt_regs;
 +asmlinkage long xtensa_ptrace(long, long, long, long);
 +asmlinkage long xtensa_sigreturn(struct pt_regs*);
++=======
+ #ifndef _ASM_SYSCALL_H
+ #define _ASM_SYSCALL_H
+ 
+ #include <linux/err.h>
+ #include <asm/ptrace.h>
+ #include <uapi/linux/audit.h>
+ 
+ static inline int syscall_get_arch(struct task_struct *task)
+ {
+ 	return AUDIT_ARCH_XTENSA;
+ }
+ 
+ typedef void (*syscall_t)(void);
+ extern syscall_t sys_call_table[];
+ 
+ static inline long syscall_get_nr(struct task_struct *task,
+ 				  struct pt_regs *regs)
+ {
+ 	return regs->syscall;
+ }
+ 
+ static inline void syscall_rollback(struct task_struct *task,
+ 				    struct pt_regs *regs)
+ {
+ 	/* Do nothing. */
+ }
+ 
+ static inline long syscall_get_error(struct task_struct *task,
+ 				     struct pt_regs *regs)
+ {
+ 	/* 0 if syscall succeeded, otherwise -Errorcode */
+ 	return IS_ERR_VALUE(regs->areg[2]) ? regs->areg[2] : 0;
+ }
+ 
+ static inline long syscall_get_return_value(struct task_struct *task,
+ 					    struct pt_regs *regs)
+ {
+ 	return regs->areg[2];
+ }
+ 
+ static inline void syscall_set_return_value(struct task_struct *task,
+ 					    struct pt_regs *regs,
+ 					    int error, long val)
+ {
+ 	regs->areg[0] = (long) error ? error : val;
+ }
+ 
+ #define SYSCALL_MAX_ARGS 6
+ #define XTENSA_SYSCALL_ARGUMENT_REGS {6, 3, 4, 5, 8, 9}
+ 
+ static inline void syscall_get_arguments(struct task_struct *task,
+ 					 struct pt_regs *regs,
+ 					 unsigned int i, unsigned int n,
+ 					 unsigned long *args)
+ {
+ 	static const unsigned int reg[] = XTENSA_SYSCALL_ARGUMENT_REGS;
+ 	unsigned int j;
+ 
+ 	if (n == 0)
+ 		return;
+ 
+ 	WARN_ON_ONCE(i + n > SYSCALL_MAX_ARGS);
+ 
+ 	for (j = 0; j < n; ++j) {
+ 		if (i + j < SYSCALL_MAX_ARGS)
+ 			args[j] = regs->areg[reg[i + j]];
+ 		else
+ 			args[j] = 0;
+ 	}
+ }
+ 
+ static inline void syscall_set_arguments(struct task_struct *task,
+ 					 struct pt_regs *regs,
+ 					 unsigned int i, unsigned int n,
+ 					 const unsigned long *args)
+ {
+ 	static const unsigned int reg[] = XTENSA_SYSCALL_ARGUMENT_REGS;
+ 	unsigned int j;
+ 
+ 	if (n == 0)
+ 		return;
+ 
+ 	if (WARN_ON_ONCE(i + n > SYSCALL_MAX_ARGS)) {
+ 		if (i < SYSCALL_MAX_ARGS)
+ 			n = SYSCALL_MAX_ARGS - i;
+ 		else
+ 			return;
+ 	}
+ 
+ 	for (j = 0; j < n; ++j)
+ 		regs->areg[reg[i + j]] = args[j];
+ }
+ 
++>>>>>>> 16add411645c (syscall_get_arch: add "struct task_struct *" argument)
  asmlinkage long xtensa_rt_sigreturn(struct pt_regs*);
  asmlinkage long xtensa_shmat(int, char __user *, int);
  asmlinkage long xtensa_fadvise64_64(int, int,
* Unmerged path arch/csky/include/asm/syscall.h
* Unmerged path arch/m68k/include/asm/syscall.h
* Unmerged path arch/unicore32/include/asm/syscall.h
diff --git a/arch/alpha/include/asm/syscall.h b/arch/alpha/include/asm/syscall.h
index d73a6fcb519c..11c688c1d7ec 100644
--- a/arch/alpha/include/asm/syscall.h
+++ b/arch/alpha/include/asm/syscall.h
@@ -4,7 +4,7 @@
 
 #include <uapi/linux/audit.h>
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	return AUDIT_ARCH_ALPHA;
 }
* Unmerged path arch/arc/include/asm/syscall.h
diff --git a/arch/arm/include/asm/syscall.h b/arch/arm/include/asm/syscall.h
index 06dea6bce293..3940ceac0bdc 100644
--- a/arch/arm/include/asm/syscall.h
+++ b/arch/arm/include/asm/syscall.h
@@ -104,7 +104,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
 	memcpy(&regs->ARM_r0 + i, args, n * sizeof(args[0]));
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	/* ARM tasks don't change audit architectures on the fly. */
 	return AUDIT_ARCH_ARM;
diff --git a/arch/arm64/include/asm/syscall.h b/arch/arm64/include/asm/syscall.h
index ad8be16a39c9..1870df03f774 100644
--- a/arch/arm64/include/asm/syscall.h
+++ b/arch/arm64/include/asm/syscall.h
@@ -117,9 +117,9 @@ static inline void syscall_set_arguments(struct task_struct *task,
  * We don't care about endianness (__AUDIT_ARCH_LE bit) here because
  * AArch64 has the same system calls both on little- and big- endian.
  */
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
-	if (is_compat_task())
+	if (is_compat_thread(task_thread_info(task)))
 		return AUDIT_ARCH_ARM;
 
 	return AUDIT_ARCH_AARCH64;
* Unmerged path arch/c6x/include/asm/syscall.h
* Unmerged path arch/csky/include/asm/syscall.h
* Unmerged path arch/h8300/include/asm/syscall.h
* Unmerged path arch/hexagon/include/asm/syscall.h
diff --git a/arch/ia64/include/asm/syscall.h b/arch/ia64/include/asm/syscall.h
index 1d0b875fec44..47ab33f5448a 100644
--- a/arch/ia64/include/asm/syscall.h
+++ b/arch/ia64/include/asm/syscall.h
@@ -81,7 +81,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
 	ia64_syscall_get_set_arguments(task, regs, i, n, args, 1);
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	return AUDIT_ARCH_IA64;
 }
* Unmerged path arch/m68k/include/asm/syscall.h
diff --git a/arch/microblaze/include/asm/syscall.h b/arch/microblaze/include/asm/syscall.h
index 220decd605a4..77a86fafa974 100644
--- a/arch/microblaze/include/asm/syscall.h
+++ b/arch/microblaze/include/asm/syscall.h
@@ -101,7 +101,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
 asmlinkage unsigned long do_syscall_trace_enter(struct pt_regs *regs);
 asmlinkage void do_syscall_trace_leave(struct pt_regs *regs);
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	return AUDIT_ARCH_MICROBLAZE;
 }
diff --git a/arch/mips/include/asm/syscall.h b/arch/mips/include/asm/syscall.h
index 0170602a1e4e..c3d3afbb5973 100644
--- a/arch/mips/include/asm/syscall.h
+++ b/arch/mips/include/asm/syscall.h
@@ -140,14 +140,14 @@ extern const unsigned long sys_call_table[];
 extern const unsigned long sys32_call_table[];
 extern const unsigned long sysn32_call_table[];
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	int arch = AUDIT_ARCH_MIPS;
 #ifdef CONFIG_64BIT
-	if (!test_thread_flag(TIF_32BIT_REGS)) {
+	if (!test_tsk_thread_flag(task, TIF_32BIT_REGS)) {
 		arch |= __AUDIT_ARCH_64BIT;
 		/* N32 sets only TIF_32BIT_ADDR */
-		if (test_thread_flag(TIF_32BIT_ADDR))
+		if (test_tsk_thread_flag(task, TIF_32BIT_ADDR))
 			arch |= __AUDIT_ARCH_CONVENTION_MIPS64_N32;
 	}
 #endif
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 1ae4e180716b..a6b00d9415a1 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -1020,7 +1020,7 @@ asmlinkage long syscall_trace_enter(struct pt_regs *regs, long syscall)
 		unsigned long args[6];
 
 		sd.nr = syscall;
-		sd.arch = syscall_get_arch();
+		sd.arch = syscall_get_arch(current);
 		syscall_get_arguments(current, regs, 0, 6, args);
 		for (i = 0; i < 6; i++)
 			sd.args[i] = args[i];
* Unmerged path arch/nds32/include/asm/syscall.h
* Unmerged path arch/nios2/include/asm/syscall.h
diff --git a/arch/openrisc/include/asm/syscall.h b/arch/openrisc/include/asm/syscall.h
index 2db9f1cf0694..46b10c674bd2 100644
--- a/arch/openrisc/include/asm/syscall.h
+++ b/arch/openrisc/include/asm/syscall.h
@@ -72,7 +72,7 @@ syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
 	memcpy(&regs->gpr[3 + i], args, n * sizeof(args[0]));
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	return AUDIT_ARCH_OPENRISC;
 }
diff --git a/arch/parisc/include/asm/syscall.h b/arch/parisc/include/asm/syscall.h
index 8bff1a58c97f..c04ffc6ac928 100644
--- a/arch/parisc/include/asm/syscall.h
+++ b/arch/parisc/include/asm/syscall.h
@@ -62,11 +62,11 @@ static inline void syscall_rollback(struct task_struct *task,
 	/* do nothing */
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	int arch = AUDIT_ARCH_PARISC;
 #ifdef CONFIG_64BIT
-	if (!is_compat_task())
+	if (!__is_compat_task(task))
 		arch = AUDIT_ARCH_PARISC64;
 #endif
 	return arch;
diff --git a/arch/powerpc/include/asm/syscall.h b/arch/powerpc/include/asm/syscall.h
index ab9f3f0a8637..d88b34179118 100644
--- a/arch/powerpc/include/asm/syscall.h
+++ b/arch/powerpc/include/asm/syscall.h
@@ -100,9 +100,15 @@ static inline void syscall_set_arguments(struct task_struct *task,
 		regs->orig_gpr3 = args[0];
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
-	int arch = is_32bit_task() ? AUDIT_ARCH_PPC : AUDIT_ARCH_PPC64;
+	int arch;
+
+	if (IS_ENABLED(CONFIG_PPC64) && !test_tsk_thread_flag(task, TIF_32BIT))
+		arch = AUDIT_ARCH_PPC64;
+	else
+		arch = AUDIT_ARCH_PPC;
+
 #ifdef __LITTLE_ENDIAN__
 	arch |= __AUDIT_ARCH_LE;
 #endif
* Unmerged path arch/riscv/include/asm/syscall.h
diff --git a/arch/s390/include/asm/syscall.h b/arch/s390/include/asm/syscall.h
index 96f9a9151fde..5a40ea8b90ea 100644
--- a/arch/s390/include/asm/syscall.h
+++ b/arch/s390/include/asm/syscall.h
@@ -92,10 +92,10 @@ static inline void syscall_set_arguments(struct task_struct *task,
 		regs->orig_gpr2 = args[0];
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 #ifdef CONFIG_COMPAT
-	if (test_tsk_thread_flag(current, TIF_31BIT))
+	if (test_tsk_thread_flag(task, TIF_31BIT))
 		return AUDIT_ARCH_S390;
 #endif
 	return AUDIT_ARCH_S390X;
diff --git a/arch/sh/include/asm/syscall_32.h b/arch/sh/include/asm/syscall_32.h
index 6e118799831c..08de429eccd4 100644
--- a/arch/sh/include/asm/syscall_32.h
+++ b/arch/sh/include/asm/syscall_32.h
@@ -95,7 +95,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
 	}
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	int arch = AUDIT_ARCH_SH;
 
diff --git a/arch/sh/include/asm/syscall_64.h b/arch/sh/include/asm/syscall_64.h
index 43882580c7f9..9b62a2404531 100644
--- a/arch/sh/include/asm/syscall_64.h
+++ b/arch/sh/include/asm/syscall_64.h
@@ -63,7 +63,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
 	memcpy(&regs->regs[2 + i], args, n * sizeof(args[0]));
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	int arch = AUDIT_ARCH_SH;
 
diff --git a/arch/sparc/include/asm/syscall.h b/arch/sparc/include/asm/syscall.h
index 053989e3f6a6..9ffb367c17fd 100644
--- a/arch/sparc/include/asm/syscall.h
+++ b/arch/sparc/include/asm/syscall.h
@@ -128,10 +128,11 @@ static inline void syscall_set_arguments(struct task_struct *task,
 		regs->u_regs[UREG_I0 + i + j] = args[j];
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 #if defined(CONFIG_SPARC64) && defined(CONFIG_COMPAT)
-	return in_compat_syscall() ? AUDIT_ARCH_SPARC : AUDIT_ARCH_SPARC64;
+	return test_tsk_thread_flag(task, TIF_32BIT)
+		? AUDIT_ARCH_SPARC : AUDIT_ARCH_SPARC64;
 #elif defined(CONFIG_SPARC64)
 	return AUDIT_ARCH_SPARC64;
 #else
* Unmerged path arch/unicore32/include/asm/syscall.h
diff --git a/arch/x86/include/asm/syscall.h b/arch/x86/include/asm/syscall.h
index d653139857af..435f3f09279c 100644
--- a/arch/x86/include/asm/syscall.h
+++ b/arch/x86/include/asm/syscall.h
@@ -107,7 +107,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
 	memcpy(&regs->bx + i, args, n * sizeof(args[0]));
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	return AUDIT_ARCH_I386;
 }
@@ -236,10 +236,12 @@ static inline void syscall_set_arguments(struct task_struct *task,
 		}
 }
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 	/* x32 tasks should be considered AUDIT_ARCH_X86_64. */
-	return in_ia32_syscall() ? AUDIT_ARCH_I386 : AUDIT_ARCH_X86_64;
+	return (IS_ENABLED(CONFIG_IA32_EMULATION) &&
+		task->thread_info.status & TS_COMPAT)
+		? AUDIT_ARCH_I386 : AUDIT_ARCH_X86_64;
 }
 #endif	/* CONFIG_X86_32 */
 
diff --git a/arch/x86/um/asm/syscall.h b/arch/x86/um/asm/syscall.h
index ef898af102d1..56a2f0913e3c 100644
--- a/arch/x86/um/asm/syscall.h
+++ b/arch/x86/um/asm/syscall.h
@@ -9,7 +9,7 @@ typedef asmlinkage long (*sys_call_ptr_t)(unsigned long, unsigned long,
 					  unsigned long, unsigned long,
 					  unsigned long, unsigned long);
 
-static inline int syscall_get_arch(void)
+static inline int syscall_get_arch(struct task_struct *task)
 {
 #ifdef CONFIG_X86_32
 	return AUDIT_ARCH_I386;
* Unmerged path arch/xtensa/include/asm/syscall.h
diff --git a/include/asm-generic/syscall.h b/include/asm-generic/syscall.h
index 0c938a4354f6..e0d060b43321 100644
--- a/include/asm-generic/syscall.h
+++ b/include/asm-generic/syscall.h
@@ -144,14 +144,15 @@ void syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
 
 /**
  * syscall_get_arch - return the AUDIT_ARCH for the current system call
+ * @task:	task of interest, must be blocked
  *
  * Returns the AUDIT_ARCH_* based on the system call convention in use.
  *
- * It's only valid to call this when current is stopped on entry to a system
+ * It's only valid to call this when @task is stopped on entry to a system
  * call, due to %TIF_SYSCALL_TRACE, %TIF_SYSCALL_AUDIT, or %TIF_SECCOMP.
  *
  * Architectures which permit CONFIG_HAVE_ARCH_SECCOMP_FILTER must
  * provide an implementation of this.
  */
-int syscall_get_arch(void);
+int syscall_get_arch(struct task_struct *task);
 #endif	/* _ASM_SYSCALL_H */
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 0c8a8df874f6..a26d2b5b439a 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1641,7 +1641,7 @@ void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,
 			return;
 	}
 
-	context->arch	    = syscall_get_arch();
+	context->arch	    = syscall_get_arch(current);
 	context->major      = major;
 	context->argv[0]    = a1;
 	context->argv[1]    = a2;
@@ -2624,7 +2624,7 @@ void audit_seccomp(unsigned long syscall, long signr, int code)
 		return;
 	audit_log_task(ab);
 	audit_log_format(ab, " sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x",
-			 signr, syscall_get_arch(), syscall,
+			 signr, syscall_get_arch(current), syscall,
 			 in_compat_syscall(), KSTK_EIP(current), code);
 	audit_log_end(ab);
 }
diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 52ea70eee293..30eb7606ea69 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -82,7 +82,7 @@ static void populate_seccomp_data(struct seccomp_data *sd)
 	unsigned long args[6];
 
 	sd->nr = syscall_get_nr(task, regs);
-	sd->arch = syscall_get_arch();
+	sd->arch = syscall_get_arch(task);
 	syscall_get_arguments(task, regs, 0, 6, args);
 	sd->args[0] = args[0];
 	sd->args[1] = args[1];
@@ -531,7 +531,7 @@ static void seccomp_init_siginfo(kernel_siginfo_t *info, int syscall, int reason
 	info->si_code = SYS_SECCOMP;
 	info->si_call_addr = (void __user *)KSTK_EIP(current);
 	info->si_errno = reason;
-	info->si_arch = syscall_get_arch();
+	info->si_arch = syscall_get_arch(current);
 	info->si_syscall = syscall;
 }
 
