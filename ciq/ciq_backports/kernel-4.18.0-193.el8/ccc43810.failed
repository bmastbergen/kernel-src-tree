arm64: perf: strip PAC when unwinding userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [arm64] perf: strip PAC when unwinding userspace (Mark Salter) [1756103]
Rebuild_FUZZ: 91.95%
commit-author Mark Rutland <mark.rutland@arm.com>
commit ccc43810827f9feb5e588e4b7098dc55b1d972f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ccc43810.failed

When the kernel is unwinding userspace callchains, we can't expect that
the userspace consumer of these callchains has the data necessary to
strip the PAC from the stored LR.

This patch has the kernel strip the PAC from user stackframes when the
in-kernel unwinder is used. This only affects the LR value, and not the
FP.

This only affects the in-kernel unwinder. When userspace performs
unwinding, it is up to userspace to strip PACs as necessary (which can
be determined from DWARF information).

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Kristina Martsenko <kristina.martsenko@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit ccc43810827f9feb5e588e4b7098dc55b1d972f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/pointer_auth.h
* Unmerged path arch/arm64/include/asm/pointer_auth.h
* Unmerged path arch/arm64/include/asm/pointer_auth.h
diff --git a/arch/arm64/kernel/perf_callchain.c b/arch/arm64/kernel/perf_callchain.c
index 44a6dad894cb..742a45c78707 100644
--- a/arch/arm64/kernel/perf_callchain.c
+++ b/arch/arm64/kernel/perf_callchain.c
@@ -18,6 +18,7 @@
 #include <linux/perf_event.h>
 #include <linux/uaccess.h>
 
+#include <asm/pointer_auth.h>
 #include <asm/stacktrace.h>
 
 struct frame_tail {
@@ -35,6 +36,7 @@ user_backtrace(struct frame_tail __user *tail,
 {
 	struct frame_tail buftail;
 	unsigned long err;
+	unsigned long lr;
 
 	/* Also check accessibility of one struct frame_tail beyond */
 	if (!access_ok(tail, sizeof(buftail)))
@@ -47,7 +49,9 @@ user_backtrace(struct frame_tail __user *tail,
 	if (err)
 		return NULL;
 
-	perf_callchain_store(entry, buftail.lr);
+	lr = ptrauth_strip_insn_pac(buftail.lr);
+
+	perf_callchain_store(entry, lr);
 
 	/*
 	 * Frame pointers should strictly progress back up the stack
