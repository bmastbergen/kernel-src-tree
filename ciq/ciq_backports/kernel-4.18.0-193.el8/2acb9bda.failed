cpufreq: Explain the kobject_put() in cpufreq_policy_alloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [cpufreq] Explain the kobject_put() in cpufreq_policy_alloc() (Al Stone) [1739729 1725581]
Rebuild_FUZZ: 91.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 2acb9bdae92d0662cd4fa11c481e80b6202b5630
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2acb9bda.failed

It may not be particularly clear why the kobject_put() after
failing kobject_init_and_add() in cpufreq_policy_alloc() is not
redundant, so add a comment to explain that.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit 2acb9bdae92d0662cd4fa11c481e80b6202b5630)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index d5123438e171,57a3853a55fb..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1134,6 -1134,12 +1134,15 @@@ static struct cpufreq_policy *cpufreq_p
  				   cpufreq_global_kobject, "policy%u", cpu);
  	if (ret) {
  		pr_err("%s: failed to init policy->kobj: %d\n", __func__, ret);
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * The entire policy object will be freed below, but the extra
+ 		 * memory allocated for the kobject name needs to be freed by
+ 		 * releasing the kobject.
+ 		 */
+ 		kobject_put(&policy->kobj);
++>>>>>>> 2acb9bdae92d (cpufreq: Explain the kobject_put() in cpufreq_policy_alloc())
  		goto err_free_real_cpus;
  	}
  
* Unmerged path drivers/cpufreq/cpufreq.c
