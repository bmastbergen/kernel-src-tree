bnxt_en: Free context memory in the open path if firmware has been reset.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Free context memory in the open path if firmware has been reset (Jonathan Toppins) [1801868]
Rebuild_FUZZ: 99.31%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 325f85f37e5b35807d86185bdf2c64d2980c44ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/325f85f3.failed

This will trigger new context memory to be rediscovered and allocated
during the re-probe process after a firmware reset.  Without this, the
newly reset firmware does not have valid context memory and the driver
will eventually fail to allocate some resources.

Fixes: ec5d31e3c15d ("bnxt_en: Handle firmware reset status during IF_UP.")
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 325f85f37e5b35807d86185bdf2c64d2980c44ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index f7c9d57ddad5,65c1c4e26f4f..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -8355,26 -8774,62 +8355,55 @@@ static int bnxt_hwrm_if_change(struct b
  		req.flags = cpu_to_le32(FUNC_DRV_IF_CHANGE_REQ_FLAGS_UP);
  	mutex_lock(&bp->hwrm_cmd_lock);
  	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
 -	if (!rc)
 -		flags = le32_to_cpu(resp->flags);
 -	mutex_unlock(&bp->hwrm_cmd_lock);
 -	if (rc)
 -		return rc;
 -
 -	if (!up)
 -		return 0;
 -
 -	if (flags & FUNC_DRV_IF_CHANGE_RESP_FLAGS_RESC_CHANGE)
 +	if (!rc && (resp->flags &
 +		    cpu_to_le32(FUNC_DRV_IF_CHANGE_RESP_FLAGS_RESC_CHANGE)))
  		resc_reinit = true;
 -	if (flags & FUNC_DRV_IF_CHANGE_RESP_FLAGS_HOT_FW_RESET_DONE)
 -		fw_reset = true;
 +	mutex_unlock(&bp->hwrm_cmd_lock);
  
++<<<<<<< HEAD
 +	if (up && resc_reinit && BNXT_NEW_RM(bp)) {
 +		struct bnxt_hw_resc *hw_resc = &bp->hw_resc;
++=======
+ 	if (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state) && !fw_reset) {
+ 		netdev_err(bp->dev, "RESET_DONE not set during FW reset.\n");
+ 		return -ENODEV;
+ 	}
+ 	if (resc_reinit || fw_reset) {
+ 		if (fw_reset) {
+ 			if (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 				bnxt_ulp_stop(bp);
+ 			bnxt_free_ctx_mem(bp);
+ 			kfree(bp->ctx);
+ 			bp->ctx = NULL;
+ 			rc = bnxt_fw_init_one(bp);
+ 			if (rc) {
+ 				set_bit(BNXT_STATE_ABORT_ERR, &bp->state);
+ 				return rc;
+ 			}
+ 			bnxt_clear_int_mode(bp);
+ 			rc = bnxt_init_int_mode(bp);
+ 			if (rc) {
+ 				netdev_err(bp->dev, "init int mode failed\n");
+ 				return rc;
+ 			}
+ 			set_bit(BNXT_STATE_FW_RESET_DET, &bp->state);
+ 		}
+ 		if (BNXT_NEW_RM(bp)) {
+ 			struct bnxt_hw_resc *hw_resc = &bp->hw_resc;
++>>>>>>> 325f85f37e5b (bnxt_en: Free context memory in the open path if firmware has been reset.)
  
 -			rc = bnxt_hwrm_func_resc_qcaps(bp, true);
 -			hw_resc->resv_cp_rings = 0;
 -			hw_resc->resv_stat_ctxs = 0;
 -			hw_resc->resv_irqs = 0;
 -			hw_resc->resv_tx_rings = 0;
 -			hw_resc->resv_rx_rings = 0;
 -			hw_resc->resv_hw_ring_grps = 0;
 -			hw_resc->resv_vnics = 0;
 -			if (!fw_reset) {
 -				bp->tx_nr_rings = 0;
 -				bp->rx_nr_rings = 0;
 -			}
 -		}
 +		rc = bnxt_hwrm_func_resc_qcaps(bp, true);
 +		hw_resc->resv_cp_rings = 0;
 +		hw_resc->resv_stat_ctxs = 0;
 +		hw_resc->resv_irqs = 0;
 +		hw_resc->resv_tx_rings = 0;
 +		hw_resc->resv_rx_rings = 0;
 +		hw_resc->resv_hw_ring_grps = 0;
 +		hw_resc->resv_vnics = 0;
 +		bp->tx_nr_rings = 0;
 +		bp->rx_nr_rings = 0;
  	}
 -	return 0;
 +	return rc;
  }
  
  static int bnxt_hwrm_port_led_qcaps(struct bnxt *bp)
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
