net/mlx5e: Refactor neigh used value update for concurrent execution

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Refactor neigh used value update for concurrent execution (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 96.97%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 6a06c2f7843d85b43ccea6e89de8e432834c089b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6a06c2f7.failed

In order to remove dependency on rtnl lock and allow neigh used value
update workqueue task to execute concurrently with tc, refactor
mlx5e_tc_update_neigh_used_value() for concurrent execution:

- Lock encap table when accessing encap entry to prevent concurrent
  changes.

- Save offloaded encap flows to temporary list and release them after encap
  entry is updated. Add mlx5e_put_encap_flow_list() helper which is
  intended to be shared with neigh update code in following patch in this
  series. This is necessary because mlx5e_flow_put() can't be called while
  holding encap_tbl_lock.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6a06c2f7843d85b43ccea6e89de8e432834c089b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c033e0d4fc59,3a562189af71..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -121,6 -125,10 +121,12 @@@ struct mlx5e_tc_flow 
  	struct list_head	hairpin; /* flows sharing the same hairpin */
  	struct list_head	peer;    /* flows with peer flow */
  	struct list_head	unready; /* flows not ready to be offloaded (e.g due to missing route) */
++<<<<<<< HEAD
++=======
+ 	struct list_head	tmp_list; /* temporary flow list used by neigh update */
+ 	refcount_t		refcnt;
+ 	struct rcu_head		rcu_head;
++>>>>>>> 6a06c2f7843d (net/mlx5e: Refactor neigh used value update for concurrent execution)
  	union {
  		struct mlx5_esw_flow_attr esw_attr[0];
  		struct mlx5_nic_flow_attr nic_attr[0];
@@@ -1227,6 -1413,60 +1233,63 @@@ static struct mlx5_fc *mlx5e_tc_get_cou
  		return flow->nic_attr->counter;
  }
  
++<<<<<<< HEAD
++=======
+ /* Iterate over tmp_list of flows attached to flow_list head. */
+ static void mlx5e_put_encap_flow_list(struct mlx5e_priv *priv, struct list_head *flow_list)
+ {
+ 	struct mlx5e_tc_flow *flow, *tmp;
+ 
+ 	list_for_each_entry_safe(flow, tmp, flow_list, tmp_list)
+ 		mlx5e_flow_put(priv, flow);
+ }
+ 
+ static struct mlx5e_encap_entry *
+ mlx5e_get_next_valid_encap(struct mlx5e_neigh_hash_entry *nhe,
+ 			   struct mlx5e_encap_entry *e)
+ {
+ 	struct mlx5e_encap_entry *next = NULL;
+ 
+ retry:
+ 	rcu_read_lock();
+ 
+ 	/* find encap with non-zero reference counter value */
+ 	for (next = e ?
+ 		     list_next_or_null_rcu(&nhe->encap_list,
+ 					   &e->encap_list,
+ 					   struct mlx5e_encap_entry,
+ 					   encap_list) :
+ 		     list_first_or_null_rcu(&nhe->encap_list,
+ 					    struct mlx5e_encap_entry,
+ 					    encap_list);
+ 	     next;
+ 	     next = list_next_or_null_rcu(&nhe->encap_list,
+ 					  &next->encap_list,
+ 					  struct mlx5e_encap_entry,
+ 					  encap_list))
+ 		if (mlx5e_encap_take(next))
+ 			break;
+ 
+ 	rcu_read_unlock();
+ 
+ 	/* release starting encap */
+ 	if (e)
+ 		mlx5e_encap_put(netdev_priv(e->out_dev), e);
+ 	if (!next)
+ 		return next;
+ 
+ 	/* wait for encap to be fully initialized */
+ 	wait_for_completion(&next->res_ready);
+ 	/* continue searching if encap entry is not in valid state after completion */
+ 	if (!(next->flags & MLX5_ENCAP_ENTRY_VALID)) {
+ 		e = next;
+ 		goto retry;
+ 	}
+ 
+ 	return next;
+ }
+ 
++>>>>>>> 6a06c2f7843d (net/mlx5e: Refactor neigh used value update for concurrent execution)
  void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe)
  {
  	struct mlx5e_neigh *m_neigh = &nhe->m_neigh;
@@@ -1247,14 -1487,25 +1310,36 @@@
  	else
  		return;
  
++<<<<<<< HEAD
 +	list_for_each_entry(e, &nhe->encap_list, encap_list) {
 +		struct encap_flow_item *efi;
 +		if (!(e->flags & MLX5_ENCAP_ENTRY_VALID))
 +			continue;
 +		list_for_each_entry(efi, &e->flows, list) {
 +			flow = container_of(efi, struct mlx5e_tc_flow,
 +					    encaps[efi->index]);
 +			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
++=======
+ 	/* mlx5e_get_next_valid_encap() releases previous encap before returning
+ 	 * next one.
+ 	 */
+ 	while ((e = mlx5e_get_next_valid_encap(nhe, e)) != NULL) {
+ 		struct mlx5e_priv *priv = netdev_priv(e->out_dev);
+ 		struct encap_flow_item *efi, *tmp;
+ 		struct mlx5_eswitch *esw;
+ 		LIST_HEAD(flow_list);
+ 
+ 		esw = priv->mdev->priv.eswitch;
+ 		mutex_lock(&esw->offloads.encap_tbl_lock);
+ 		list_for_each_entry_safe(efi, tmp, &e->flows, list) {
+ 			flow = container_of(efi, struct mlx5e_tc_flow,
+ 					    encaps[efi->index]);
+ 			if (IS_ERR(mlx5e_flow_get(flow)))
+ 				continue;
+ 			list_add(&flow->tmp_list, &flow_list);
+ 
+ 			if (mlx5e_is_offloaded_flow(flow)) {
++>>>>>>> 6a06c2f7843d (net/mlx5e: Refactor neigh used value update for concurrent execution)
  				counter = mlx5e_tc_get_counter(flow);
  				lastuse = mlx5_fc_query_lastuse(counter);
  				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
@@@ -1263,8 -1514,14 +1348,17 @@@
  				}
  			}
  		}
++<<<<<<< HEAD
 +		if (neigh_used)
++=======
+ 		mutex_unlock(&esw->offloads.encap_tbl_lock);
+ 
+ 		mlx5e_put_encap_flow_list(priv, &flow_list);
+ 		if (neigh_used) {
+ 			/* release current encap before breaking the loop */
+ 			mlx5e_encap_put(priv, e);
++>>>>>>> 6a06c2f7843d (net/mlx5e: Refactor neigh used value update for concurrent execution)
  			break;
 -		}
  	}
  
  	if (neigh_used) {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
