ALSA: firewire-lib: cancel flushing isoc context in the laste step to process context callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 813dfbd6845e5366f2dbef190a695f8b06c1d83d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/813dfbd6.failed

The aim of AMDTP domain is to process several isoc context in the same
time. However, current implementation is against this idea because it
flushes each isoc context in the end of processing context callback.

This commit cancels it.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Link: https://lore.kernel.org/r/20191018061911.24909-5-o-takashi@sakamocchi.jp
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 813dfbd6845e5366f2dbef190a695f8b06c1d83d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/amdtp-stream.c
diff --cc sound/firewire/amdtp-stream.c
index 6e1b83a082a2,36c3f1f9dbff..000000000000
--- a/sound/firewire/amdtp-stream.c
+++ b/sound/firewire/amdtp-stream.c
@@@ -751,15 -839,9 +751,19 @@@ static void out_stream_callback(struct 
  			cancel_stream(s);
  			return;
  		}
 +
++<<<<<<< HEAD
 +		pcm = READ_ONCE(s->pcm);
 +		if (pcm && pcm_frames > 0)
 +			update_pcm_pointers(s, pcm, pcm_frames);
 +
 +		++ctx_header;
  	}
  
 +	fw_iso_context_queue_flush(s->context);
++=======
+ 	s->event_count = event_count;
++>>>>>>> 813dfbd6845e (ALSA: firewire-lib: cancel flushing isoc context in the laste step to process context callback)
  }
  
  static void in_stream_callback(struct fw_iso_context *context, u32 tstamp,
@@@ -773,54 -859,42 +777,58 @@@
  	if (s->packet_index < 0)
  		return;
  
 -	// Calculate the number of packets in buffer and check XRUN.
 +	// The number of packets in buffer.
  	packets = header_length / s->ctx_data.tx.ctx_header_size;
  
 -	err = generate_device_pkt_descs(s, s->pkt_descs, ctx_header, packets);
 -	if (err < 0) {
 -		if (err != -EAGAIN) {
 -			cancel_stream(s);
 -			return;
 -		}
 -	} else {
 -		process_ctx_payloads(s, s->pkt_descs, packets);
 -	}
 -
 -	for (i = 0; i < packets; ++i) {
 -		const struct pkt_desc *desc = s->pkt_descs + i;
 +	for (i = 0; i < packets; i++) {
 +		u32 cycle;
 +		unsigned int payload_length;
 +		unsigned int data_blocks;
 +		unsigned int syt;
 +		__be32 *buffer;
 +		unsigned int pcm_frames = 0;
  		struct fw_iso_packet params = {0};
 -		bool sched_irq = false;
 +		struct snd_pcm_substream *pcm;
 +		int err;
 +
 +		cycle = compute_cycle_count(ctx_header[1]);
 +		err = parse_ir_ctx_header(s, cycle, ctx_header, &payload_length,
 +					  &data_blocks, &syt, i);
 +		if (err < 0 && err != -EAGAIN)
 +			break;
  
  		if (err >= 0) {
 -			event_count += desc->data_blocks;
 -			if (event_count >= events_per_period) {
 -				event_count -= events_per_period;
 -				sched_irq = true;
 +			buffer = s->buffer.packets[s->packet_index].buffer;
 +			pcm_frames = s->process_data_blocks(s, buffer,
 +							    data_blocks, &syt);
 +
 +			if (!(s->flags & CIP_DBC_IS_END_EVENT)) {
 +				s->data_block_counter += data_blocks;
 +				s->data_block_counter &= 0xff;
  			}
 -		} else {
 -			sched_irq =
 -				!((s->packet_index + 1) % s->idle_irq_interval);
  		}
  
 -		if (queue_in_packet(s, &params, sched_irq) < 0) {
 -			cancel_stream(s);
 -			return;
 -		}
 +		if (queue_in_packet(s, &params) < 0)
 +			break;
 +
 +		pcm = READ_ONCE(s->pcm);
 +		if (pcm && pcm_frames > 0)
 +			update_pcm_pointers(s, pcm, pcm_frames);
 +
 +		ctx_header += s->ctx_data.tx.ctx_header_size / sizeof(*ctx_header);
 +	}
 +
++<<<<<<< HEAD
 +	/* Queueing error or detecting invalid payload. */
 +	if (i < packets) {
 +		cancel_stream(s);
 +		return;
  	}
  
 +	fw_iso_context_queue_flush(s->context);
++=======
+ 	s->event_count = event_count;
++>>>>>>> 813dfbd6845e (ALSA: firewire-lib: cancel flushing isoc context in the laste step to process context callback)
  }
  
  /* this is executed one time */
* Unmerged path sound/firewire/amdtp-stream.c
