RDMA/mlx5: Improve PI handover performance

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Israel Rukshin <israelr@mellanox.com>
commit de0ae958deb5e6af35c4c6a4679d4fe9896a98ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/de0ae958.failed

In some loads, there is performance degradation when using KLM mkey
instead of MTT mkey. This is because KLM descriptor access is via
indirection that might require more HW resources and cycles.
Using KLM descriptor is not necessary when there are no gaps at the
data/metadata sg lists. As an optimization, use MTT mkey whenever it
is possible. For that matter, allocate internal MTT mkey and choose the
effective pi_mr for in transaction according to the required mapping
scheme.

The setup of the tested benchmark (using iSER ULP):
 - 2 servers with 24 cores (1 initiator and 1 target)
 - ConnectX-4/ConnectX-5 adapters
 - 24 target sessions with 1 LUN each
 - ramdisk backstore
 - PI active

Performance results running fio (24 jobs, 128 iodepth) using
write_generate=1 and read_verify=1 (w/w.o/baseline):

bs      IOPS(read)                IOPS(write)
----    ----------                ----------
512   1262.4K/1243.3K/1147.1K    1732.1K/1725.1K/1423.8K
4k    570902/571233/457874       773982/743293/642080
32k   72086/72388/71933          96164/71789/93249

Using write_generate=0 and read_verify=0 (w/w.o patch):
bs      IOPS(read)                IOPS(write)
----    ----------                ----------
512   1600.1K/1572.1K/1393.3K    1830.3K/1823.5K/1557.2K
4k    937272/921992/762934       815304/753772/646071
32k   77369/75052/72058          97435/73180/94612

	Signed-off-by: Israel Rukshin <israelr@mellanox.com>
	Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
	Suggested-by: Max Gurtovoy <maxg@mellanox.com>
	Suggested-by: Idan Burstein <idanb@mellanox.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit de0ae958deb5e6af35c4c6a4679d4fe9896a98ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
#	drivers/infiniband/hw/mlx5/mr.c
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 7e795d5a30d7,405059521321..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -584,6 -605,12 +584,15 @@@ struct mlx5_ib_mr 
  	int			access_flags; /* Needed for rereg MR */
  
  	struct mlx5_ib_mr      *parent;
++<<<<<<< HEAD
++=======
+ 	/* Needed for IB_MR_TYPE_INTEGRITY */
+ 	struct mlx5_ib_mr      *pi_mr;
+ 	struct mlx5_ib_mr      *klm_mr;
+ 	struct mlx5_ib_mr      *mtt_mr;
+ 	u64			pi_iova;
+ 
++>>>>>>> de0ae958deb5 (RDMA/mlx5: Improve PI handover performance)
  	atomic_t		num_leaf_free;
  	wait_queue_head_t       q_leaf_free;
  	struct mlx5_async_work  cb_work;
diff --cc drivers/infiniband/hw/mlx5/mr.c
index 0a633d06794a,8b40abd0070b..000000000000
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@@ -1655,15 -1637,88 +1655,98 @@@ static void dereg_mr(struct mlx5_ib_de
  		kfree(mr);
  }
  
 -int mlx5_ib_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata)
 +int mlx5_ib_dereg_mr(struct ib_mr *ibmr)
  {
++<<<<<<< HEAD
 +	dereg_mr(to_mdev(ibmr->device), to_mmr(ibmr));
 +	return 0;
 +}
 +
 +struct ib_mr *mlx5_ib_alloc_mr(struct ib_pd *pd,
 +			       enum ib_mr_type mr_type,
 +			       u32 max_num_sg)
++=======
+ 	struct mlx5_ib_mr *mmr = to_mmr(ibmr);
+ 
+ 	if (ibmr->type == IB_MR_TYPE_INTEGRITY) {
+ 		dereg_mr(to_mdev(mmr->mtt_mr->ibmr.device), mmr->mtt_mr);
+ 		dereg_mr(to_mdev(mmr->klm_mr->ibmr.device), mmr->klm_mr);
+ 	}
+ 
+ 	dereg_mr(to_mdev(ibmr->device), mmr);
+ 
+ 	return 0;
+ }
+ 
+ static struct mlx5_ib_mr *mlx5_ib_alloc_pi_mr(struct ib_pd *pd,
+ 				u32 max_num_sg, u32 max_num_meta_sg,
+ 				int desc_size, int access_mode)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(pd->device);
+ 	int inlen = MLX5_ST_SZ_BYTES(create_mkey_in);
+ 	int ndescs = ALIGN(max_num_sg + max_num_meta_sg, 4);
+ 	struct mlx5_ib_mr *mr;
+ 	void *mkc;
+ 	u32 *in;
+ 	int err;
+ 
+ 	mr = kzalloc(sizeof(*mr), GFP_KERNEL);
+ 	if (!mr)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	in = kzalloc(inlen, GFP_KERNEL);
+ 	if (!in) {
+ 		err = -ENOMEM;
+ 		goto err_free;
+ 	}
+ 
+ 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
+ 	MLX5_SET(mkc, mkc, free, 1);
+ 	MLX5_SET(mkc, mkc, translations_octword_size, ndescs);
+ 	if (access_mode == MLX5_MKC_ACCESS_MODE_MTT)
+ 		MLX5_SET(mkc, mkc, log_page_size, PAGE_SHIFT);
+ 	MLX5_SET(mkc, mkc, qpn, 0xffffff);
+ 	MLX5_SET(mkc, mkc, pd, to_mpd(pd)->pdn);
+ 
+ 	mr->access_mode = access_mode;
+ 
+ 	err = mlx5_alloc_priv_descs(pd->device, mr, ndescs, desc_size);
+ 	if (err)
+ 		goto err_free_in;
+ 	mr->desc_size = desc_size;
+ 	mr->max_descs = ndescs;
+ 
+ 	MLX5_SET(mkc, mkc, access_mode_1_0, mr->access_mode & 0x3);
+ 	MLX5_SET(mkc, mkc, access_mode_4_2, (mr->access_mode >> 2) & 0x7);
+ 	MLX5_SET(mkc, mkc, umr_en, 1);
+ 
+ 	mr->ibmr.pd = pd;
+ 	mr->ibmr.device = pd->device;
+ 	err = mlx5_core_create_mkey(dev->mdev, &mr->mmkey, in, inlen);
+ 	if (err)
+ 		goto err_priv_descs;
+ 
+ 	mr->mmkey.type = MLX5_MKEY_MR;
+ 	mr->ibmr.lkey = mr->mmkey.key;
+ 	mr->ibmr.rkey = mr->mmkey.key;
+ 	mr->umem = NULL;
+ 	kfree(in);
+ 
+ 	return mr;
+ 
+ err_priv_descs:
+ 	mlx5_free_priv_descs(mr);
+ err_free_in:
+ 	kfree(in);
+ err_free:
+ 	kfree(mr);
+ 	return ERR_PTR(err);
+ }
+ 
+ static struct ib_mr *__mlx5_ib_alloc_mr(struct ib_pd *pd,
+ 					enum ib_mr_type mr_type, u32 max_num_sg,
+ 					u32 max_num_meta_sg)
++>>>>>>> de0ae958deb5 (RDMA/mlx5: Improve PI handover performance)
  {
  	struct mlx5_ib_dev *dev = to_mdev(pd->device);
  	int inlen = MLX5_ST_SZ_BYTES(create_mkey_in);
@@@ -1733,6 -1790,22 +1816,25 @@@
  		mr->sig->sig_err_exists = false;
  		/* Next UMR, Arm SIGERR */
  		++mr->sig->sigerr_count;
++<<<<<<< HEAD
++=======
+ 		mr->klm_mr = mlx5_ib_alloc_pi_mr(pd, max_num_sg,
+ 						max_num_meta_sg,
+ 						sizeof(struct mlx5_klm),
+ 						MLX5_MKC_ACCESS_MODE_KLMS);
+ 		if (IS_ERR(mr->klm_mr)) {
+ 			err = PTR_ERR(mr->klm_mr);
+ 			goto err_destroy_psv;
+ 		}
+ 		mr->mtt_mr = mlx5_ib_alloc_pi_mr(pd, max_num_sg,
+ 						max_num_meta_sg,
+ 						sizeof(struct mlx5_mtt),
+ 						MLX5_MKC_ACCESS_MODE_MTT);
+ 		if (IS_ERR(mr->mtt_mr)) {
+ 			err = PTR_ERR(mr->mtt_mr);
+ 			goto err_free_klm_mr;
+ 		}
++>>>>>>> de0ae958deb5 (RDMA/mlx5: Improve PI handover performance)
  	} else {
  		mlx5_ib_warn(dev, "Invalid mr type %d\n", mr_type);
  		err = -EINVAL;
@@@ -1756,6 -1829,16 +1858,19 @@@
  
  	return &mr->ibmr;
  
++<<<<<<< HEAD
++=======
+ err_free_pi_mr:
+ 	if (mr->mtt_mr) {
+ 		dereg_mr(to_mdev(mr->mtt_mr->ibmr.device), mr->mtt_mr);
+ 		mr->mtt_mr = NULL;
+ 	}
+ err_free_klm_mr:
+ 	if (mr->klm_mr) {
+ 		dereg_mr(to_mdev(mr->klm_mr->ibmr.device), mr->klm_mr);
+ 		mr->klm_mr = NULL;
+ 	}
++>>>>>>> de0ae958deb5 (RDMA/mlx5: Improve PI handover performance)
  err_destroy_psv:
  	if (mr->sig) {
  		if (mlx5_core_destroy_psv(dev->mdev,
@@@ -1952,6 -2075,160 +2067,163 @@@ static int mlx5_set_page(struct ib_mr *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx5_set_page_pi(struct ib_mr *ibmr, u64 addr)
+ {
+ 	struct mlx5_ib_mr *mr = to_mmr(ibmr);
+ 	__be64 *descs;
+ 
+ 	if (unlikely(mr->ndescs + mr->meta_ndescs == mr->max_descs))
+ 		return -ENOMEM;
+ 
+ 	descs = mr->descs;
+ 	descs[mr->ndescs + mr->meta_ndescs++] =
+ 		cpu_to_be64(addr | MLX5_EN_RD | MLX5_EN_WR);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlx5_ib_map_mtt_mr_sg_pi(struct ib_mr *ibmr, struct scatterlist *data_sg,
+ 			 int data_sg_nents, unsigned int *data_sg_offset,
+ 			 struct scatterlist *meta_sg, int meta_sg_nents,
+ 			 unsigned int *meta_sg_offset)
+ {
+ 	struct mlx5_ib_mr *mr = to_mmr(ibmr);
+ 	struct mlx5_ib_mr *pi_mr = mr->mtt_mr;
+ 	int n;
+ 	u64 iova;
+ 
+ 	pi_mr->ndescs = 0;
+ 	pi_mr->meta_ndescs = 0;
+ 	pi_mr->meta_length = 0;
+ 
+ 	ib_dma_sync_single_for_cpu(ibmr->device, pi_mr->desc_map,
+ 				   pi_mr->desc_size * pi_mr->max_descs,
+ 				   DMA_TO_DEVICE);
+ 
+ 	pi_mr->ibmr.page_size = ibmr->page_size;
+ 	n = ib_sg_to_pages(&pi_mr->ibmr, data_sg, data_sg_nents, data_sg_offset,
+ 			   mlx5_set_page);
+ 	if (n != data_sg_nents)
+ 		return n;
+ 
+ 	iova = pi_mr->ibmr.iova;
+ 	pi_mr->data_length = pi_mr->ibmr.length;
+ 	pi_mr->ibmr.length = pi_mr->data_length;
+ 	ibmr->length = pi_mr->data_length;
+ 
+ 	if (meta_sg_nents) {
+ 		u64 page_mask = ~((u64)ibmr->page_size - 1);
+ 
+ 		n += ib_sg_to_pages(&pi_mr->ibmr, meta_sg, meta_sg_nents,
+ 				    meta_sg_offset, mlx5_set_page_pi);
+ 
+ 		pi_mr->meta_length = pi_mr->ibmr.length;
+ 		/*
+ 		 * PI address for the HW is the offset of the metadata address
+ 		 * relative to the first data page address.
+ 		 * It equals to first data page address + size of data pages +
+ 		 * metadata offset at the first metadata page
+ 		 */
+ 		pi_mr->pi_iova = (iova & page_mask) +
+ 				 pi_mr->ndescs * ibmr->page_size +
+ 				 (pi_mr->ibmr.iova & ~page_mask);
+ 		/*
+ 		 * In order to use one MTT MR for data and metadata, we register
+ 		 * also the gaps between the end of the data and the start of
+ 		 * the metadata (the sig MR will verify that the HW will access
+ 		 * to right addresses). This mapping is safe because we use
+ 		 * internal mkey for the registration.
+ 		 */
+ 		pi_mr->ibmr.length = pi_mr->pi_iova + pi_mr->meta_length - iova;
+ 		pi_mr->ibmr.iova = iova;
+ 		ibmr->length += pi_mr->meta_length;
+ 	}
+ 
+ 	ib_dma_sync_single_for_device(ibmr->device, pi_mr->desc_map,
+ 				      pi_mr->desc_size * pi_mr->max_descs,
+ 				      DMA_TO_DEVICE);
+ 
+ 	return n;
+ }
+ 
+ static int
+ mlx5_ib_map_klm_mr_sg_pi(struct ib_mr *ibmr, struct scatterlist *data_sg,
+ 			 int data_sg_nents, unsigned int *data_sg_offset,
+ 			 struct scatterlist *meta_sg, int meta_sg_nents,
+ 			 unsigned int *meta_sg_offset)
+ {
+ 	struct mlx5_ib_mr *mr = to_mmr(ibmr);
+ 	struct mlx5_ib_mr *pi_mr = mr->klm_mr;
+ 	int n;
+ 
+ 	pi_mr->ndescs = 0;
+ 	pi_mr->meta_ndescs = 0;
+ 	pi_mr->meta_length = 0;
+ 
+ 	ib_dma_sync_single_for_cpu(ibmr->device, pi_mr->desc_map,
+ 				   pi_mr->desc_size * pi_mr->max_descs,
+ 				   DMA_TO_DEVICE);
+ 
+ 	n = mlx5_ib_sg_to_klms(pi_mr, data_sg, data_sg_nents, data_sg_offset,
+ 			       meta_sg, meta_sg_nents, meta_sg_offset);
+ 
+ 	ib_dma_sync_single_for_device(ibmr->device, pi_mr->desc_map,
+ 				      pi_mr->desc_size * pi_mr->max_descs,
+ 				      DMA_TO_DEVICE);
+ 
+ 	/* This is zero-based memory region */
+ 	pi_mr->ibmr.iova = 0;
+ 	pi_mr->pi_iova = pi_mr->data_length;
+ 	ibmr->length = pi_mr->ibmr.length;
+ 
+ 	return n;
+ }
+ 
+ int mlx5_ib_map_mr_sg_pi(struct ib_mr *ibmr, struct scatterlist *data_sg,
+ 			 int data_sg_nents, unsigned int *data_sg_offset,
+ 			 struct scatterlist *meta_sg, int meta_sg_nents,
+ 			 unsigned int *meta_sg_offset)
+ {
+ 	struct mlx5_ib_mr *mr = to_mmr(ibmr);
+ 	struct mlx5_ib_mr *pi_mr = mr->mtt_mr;
+ 	int n;
+ 
+ 	WARN_ON(ibmr->type != IB_MR_TYPE_INTEGRITY);
+ 
+ 	/*
+ 	 * As a performance optimization, if possible, there is no need to map
+ 	 * the sg lists to KLM descriptors. First try to map the sg lists to MTT
+ 	 * descriptors and fallback to KLM only in case of a failure.
+ 	 * It's more efficient for the HW to work with MTT descriptors
+ 	 * (especially in high load).
+ 	 * Use KLM (indirect access) only if it's mandatory.
+ 	 */
+ 	n = mlx5_ib_map_mtt_mr_sg_pi(ibmr, data_sg, data_sg_nents,
+ 				     data_sg_offset, meta_sg, meta_sg_nents,
+ 				     meta_sg_offset);
+ 	if (n == data_sg_nents + meta_sg_nents)
+ 		goto out;
+ 
+ 	pi_mr = mr->klm_mr;
+ 	n = mlx5_ib_map_klm_mr_sg_pi(ibmr, data_sg, data_sg_nents,
+ 				     data_sg_offset, meta_sg, meta_sg_nents,
+ 				     meta_sg_offset);
+ 	if (unlikely(n != data_sg_nents + meta_sg_nents))
+ 		return -ENOMEM;
+ 
+ out:
+ 	/* This is zero-based memory region */
+ 	ibmr->iova = 0;
+ 	mr->pi_mr = pi_mr;
+ 	ibmr->sig_attrs->meta_length = pi_mr->meta_length;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> de0ae958deb5 (RDMA/mlx5: Improve PI handover performance)
  int mlx5_ib_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg, int sg_nents,
  		      unsigned int *sg_offset)
  {
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 7d1e0ba30dfa,f0962be5b11c..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -4534,32 -4557,17 +4534,43 @@@ static int set_sig_data_segment(const s
  	bool prot = false;
  	int ret;
  	int wqe_size;
 -	struct mlx5_ib_mr *mr = to_mmr(sig_mr);
 -	struct mlx5_ib_mr *pi_mr = mr->pi_mr;
  
++<<<<<<< HEAD
 +	if (send_wr->opcode == IB_WR_REG_SIG_MR) {
 +		const struct ib_sig_handover_wr *wr = sig_handover_wr(send_wr);
 +
 +		data_len = wr->wr.sg_list->length;
 +		data_key = wr->wr.sg_list->lkey;
 +		data_va = wr->wr.sg_list->addr;
 +		if (wr->prot) {
 +			prot_len = wr->prot->length;
 +			prot_key = wr->prot->lkey;
 +			prot_va = wr->prot->addr;
 +			prot = true;
 +		}
 +	} else {
 +		struct mlx5_ib_mr *mr = to_mmr(sig_mr);
 +		struct mlx5_ib_mr *pi_mr = mr->pi_mr;
 +
 +		data_len = pi_mr->data_length;
 +		data_key = pi_mr->ibmr.lkey;
 +		data_va = pi_mr->ibmr.iova;
 +		if (pi_mr->meta_ndescs) {
 +			prot_len = pi_mr->meta_length;
 +			prot_key = pi_mr->ibmr.lkey;
 +			prot_va = pi_mr->ibmr.iova + data_len;
 +			prot = true;
 +		}
++=======
+ 	data_len = pi_mr->data_length;
+ 	data_key = pi_mr->ibmr.lkey;
+ 	data_va = pi_mr->ibmr.iova;
+ 	if (pi_mr->meta_ndescs) {
+ 		prot_len = pi_mr->meta_length;
+ 		prot_key = pi_mr->ibmr.lkey;
+ 		prot_va = pi_mr->pi_iova;
+ 		prot = true;
++>>>>>>> de0ae958deb5 (RDMA/mlx5: Improve PI handover performance)
  	}
  
  	if (!prot || (data_key == prot_key && data_va == prot_va &&
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
* Unmerged path drivers/infiniband/hw/mlx5/mr.c
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
