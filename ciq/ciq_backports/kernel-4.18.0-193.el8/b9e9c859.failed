flow_dissector: fix clamping of BPF flow_keys for non-zero nhoff

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit b9e9c8599f0f23e3d2051befc9966a84b639f64f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b9e9c859.failed

Don't allow BPF program to set flow_keys->nhoff to less than initial
value. We currently don't read the value afterwards in anything but
the tests, but it's still a good practice to return consistent
values to the test programs.

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit b9e9c8599f0f23e3d2051befc9966a84b639f64f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index ea22c4441222,94a450b2191a..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -683,6 -683,48 +683,51 @@@ static void __skb_flow_bpf_to_target(co
  	}
  }
  
++<<<<<<< HEAD
++=======
+ bool __skb_flow_bpf_dissect(struct bpf_prog *prog,
+ 			    const struct sk_buff *skb,
+ 			    struct flow_dissector *flow_dissector,
+ 			    struct bpf_flow_keys *flow_keys)
+ {
+ 	struct bpf_skb_data_end cb_saved;
+ 	struct bpf_skb_data_end *cb;
+ 	u32 result;
+ 
+ 	/* Note that even though the const qualifier is discarded
+ 	 * throughout the execution of the BPF program, all changes(the
+ 	 * control block) are reverted after the BPF program returns.
+ 	 * Therefore, __skb_flow_dissect does not alter the skb.
+ 	 */
+ 
+ 	cb = (struct bpf_skb_data_end *)skb->cb;
+ 
+ 	/* Save Control Block */
+ 	memcpy(&cb_saved, cb, sizeof(cb_saved));
+ 	memset(cb, 0, sizeof(*cb));
+ 
+ 	/* Pass parameters to the BPF program */
+ 	memset(flow_keys, 0, sizeof(*flow_keys));
+ 	cb->qdisc_cb.flow_keys = flow_keys;
+ 	flow_keys->n_proto = skb->protocol;
+ 	flow_keys->nhoff = skb_network_offset(skb);
+ 	flow_keys->thoff = flow_keys->nhoff;
+ 
+ 	bpf_compute_data_pointers((struct sk_buff *)skb);
+ 	result = BPF_PROG_RUN(prog, skb);
+ 
+ 	/* Restore state */
+ 	memcpy(cb, &cb_saved, sizeof(cb_saved));
+ 
+ 	flow_keys->nhoff = clamp_t(u16, flow_keys->nhoff,
+ 				   skb_network_offset(skb), skb->len);
+ 	flow_keys->thoff = clamp_t(u16, flow_keys->thoff,
+ 				   flow_keys->nhoff, skb->len);
+ 
+ 	return result == BPF_OK;
+ }
+ 
++>>>>>>> b9e9c8599f0f (flow_dissector: fix clamping of BPF flow_keys for non-zero nhoff)
  /**
   * __skb_flow_dissect - extract the flow_keys struct and return it
   * @skb: sk_buff to extract the flow from, can be NULL if the rest are specified
* Unmerged path net/core/flow_dissector.c
