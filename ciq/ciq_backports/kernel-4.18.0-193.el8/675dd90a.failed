xprtrdma: Modernize ops->connect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 675dd90ad0932f2c03912a5252458d792bd7033a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/675dd90a.failed

Adapt and apply changes that were made to the TCP socket connect
code. See the following commits for details on the purpose of
these changes:

Commit 7196dbb02ea0 ("SUNRPC: Allow changing of the TCP timeout parameters on the fly")
Commit 3851f1cdb2b8 ("SUNRPC: Limit the reconnect backoff timer to the max RPC message timeout")
Commit 02910177aede ("SUNRPC: Fix reconnection timeouts")

Some common transport code is moved to xprt.c to satisfy the code
duplication police.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 675dd90ad0932f2c03912a5252458d792bd7033a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprt.c
diff --cc net/sunrpc/xprt.c
index c4d4cd12e49e,b1f54b7ccc0c..000000000000
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@@ -784,32 -850,105 +784,74 @@@ void xprt_connect(struct rpc_task *task
  	xprt_release_write(xprt, task);
  }
  
++<<<<<<< HEAD
 +static void xprt_connect_status(struct rpc_task *task)
++=======
+ /**
+  * xprt_reconnect_delay - compute the wait before scheduling a connect
+  * @xprt: transport instance
+  *
+  */
+ unsigned long xprt_reconnect_delay(const struct rpc_xprt *xprt)
+ {
+ 	unsigned long start, now = jiffies;
+ 
+ 	start = xprt->stat.connect_start + xprt->reestablish_timeout;
+ 	if (time_after(start, now))
+ 		return start - now;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(xprt_reconnect_delay);
+ 
+ /**
+  * xprt_reconnect_backoff - compute the new re-establish timeout
+  * @xprt: transport instance
+  * @init_to: initial reestablish timeout
+  *
+  */
+ void xprt_reconnect_backoff(struct rpc_xprt *xprt, unsigned long init_to)
+ {
+ 	xprt->reestablish_timeout <<= 1;
+ 	if (xprt->reestablish_timeout > xprt->max_reconnect_timeout)
+ 		xprt->reestablish_timeout = xprt->max_reconnect_timeout;
+ 	if (xprt->reestablish_timeout < init_to)
+ 		xprt->reestablish_timeout = init_to;
+ }
+ EXPORT_SYMBOL_GPL(xprt_reconnect_backoff);
+ 
+ enum xprt_xid_rb_cmp {
+ 	XID_RB_EQUAL,
+ 	XID_RB_LEFT,
+ 	XID_RB_RIGHT,
+ };
+ static enum xprt_xid_rb_cmp
+ xprt_xid_cmp(__be32 xid1, __be32 xid2)
++>>>>>>> 675dd90ad093 (xprtrdma: Modernize ops->connect)
  {
 -	if (xid1 == xid2)
 -		return XID_RB_EQUAL;
 -	if ((__force u32)xid1 < (__force u32)xid2)
 -		return XID_RB_LEFT;
 -	return XID_RB_RIGHT;
 -}
 -
 -static struct rpc_rqst *
 -xprt_request_rb_find(struct rpc_xprt *xprt, __be32 xid)
 -{
 -	struct rb_node *n = xprt->recv_queue.rb_node;
 -	struct rpc_rqst *req;
 -
 -	while (n != NULL) {
 -		req = rb_entry(n, struct rpc_rqst, rq_recv);
 -		switch (xprt_xid_cmp(xid, req->rq_xid)) {
 -		case XID_RB_LEFT:
 -			n = n->rb_left;
 -			break;
 -		case XID_RB_RIGHT:
 -			n = n->rb_right;
 -			break;
 -		case XID_RB_EQUAL:
 -			return req;
 -		}
 -	}
 -	return NULL;
 -}
 -
 -static void
 -xprt_request_rb_insert(struct rpc_xprt *xprt, struct rpc_rqst *new)
 -{
 -	struct rb_node **p = &xprt->recv_queue.rb_node;
 -	struct rb_node *n = NULL;
 -	struct rpc_rqst *req;
 -
 -	while (*p != NULL) {
 -		n = *p;
 -		req = rb_entry(n, struct rpc_rqst, rq_recv);
 -		switch(xprt_xid_cmp(new->rq_xid, req->rq_xid)) {
 -		case XID_RB_LEFT:
 -			p = &n->rb_left;
 -			break;
 -		case XID_RB_RIGHT:
 -			p = &n->rb_right;
 -			break;
 -		case XID_RB_EQUAL:
 -			WARN_ON_ONCE(new != req);
 -			return;
 -		}
 +	switch (task->tk_status) {
 +	case 0:
 +		dprintk("RPC: %5u xprt_connect_status: connection established\n",
 +				task->tk_pid);
 +		break;
 +	case -ECONNREFUSED:
 +	case -ECONNRESET:
 +	case -ECONNABORTED:
 +	case -ENETUNREACH:
 +	case -EHOSTUNREACH:
 +	case -EPIPE:
 +	case -EAGAIN:
 +		dprintk("RPC: %5u xprt_connect_status: retrying\n", task->tk_pid);
 +		break;
 +	case -ETIMEDOUT:
 +		dprintk("RPC: %5u xprt_connect_status: connect attempt timed "
 +				"out\n", task->tk_pid);
 +		break;
 +	default:
 +		dprintk("RPC: %5u xprt_connect_status: error %d connecting to "
 +				"server %s\n", task->tk_pid, -task->tk_status,
 +				task->tk_rqstp->rq_xprt->servername);
 +		task->tk_status = -EIO;
  	}
 -	rb_link_node(&new->rq_recv, n, p);
 -	rb_insert_color(&new->rq_recv, &xprt->recv_queue);
 -}
 -
 -static void
 -xprt_request_rb_remove(struct rpc_xprt *xprt, struct rpc_rqst *req)
 -{
 -	rb_erase(&req->rq_recv, &xprt->recv_queue);
  }
  
  /**
diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a7adc8248a5b..91716dbad71c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -323,6 +323,9 @@ struct xprt_class {
  */
 struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
+unsigned long		xprt_reconnect_delay(const struct rpc_xprt *xprt);
+void			xprt_reconnect_backoff(struct rpc_xprt *xprt,
+					       unsigned long init_to);
 void			xprt_reserve(struct rpc_task *task);
 void			xprt_retry_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
diff --git a/include/trace/events/rpcrdma.h b/include/trace/events/rpcrdma.h
index bfa903f6b855..e6f13c339505 100644
--- a/include/trace/events/rpcrdma.h
+++ b/include/trace/events/rpcrdma.h
@@ -390,6 +390,37 @@ DEFINE_RXPRT_EVENT(xprtrdma_op_inject_dsc);
 DEFINE_RXPRT_EVENT(xprtrdma_op_close);
 DEFINE_RXPRT_EVENT(xprtrdma_op_connect);
 
+TRACE_EVENT(xprtrdma_op_set_cto,
+	TP_PROTO(
+		const struct rpcrdma_xprt *r_xprt,
+		unsigned long connect,
+		unsigned long reconnect
+	),
+
+	TP_ARGS(r_xprt, connect, reconnect),
+
+	TP_STRUCT__entry(
+		__field(const void *, r_xprt)
+		__field(unsigned long, connect)
+		__field(unsigned long, reconnect)
+		__string(addr, rpcrdma_addrstr(r_xprt))
+		__string(port, rpcrdma_portstr(r_xprt))
+	),
+
+	TP_fast_assign(
+		__entry->r_xprt = r_xprt;
+		__entry->connect = connect;
+		__entry->reconnect = reconnect;
+		__assign_str(addr, rpcrdma_addrstr(r_xprt));
+		__assign_str(port, rpcrdma_portstr(r_xprt));
+	),
+
+	TP_printk("peer=[%s]:%s r_xprt=%p: connect=%lu reconnect=%lu",
+		__get_str(addr), __get_str(port), __entry->r_xprt,
+		__entry->connect / HZ, __entry->reconnect / HZ
+	)
+);
+
 TRACE_EVENT(xprtrdma_qp_event,
 	TP_PROTO(
 		const struct rpcrdma_xprt *r_xprt,
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index b92b0e9731d5..7f1ff72fcde4 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -56,6 +56,7 @@ static struct rpc_wait_queue delay_queue;
  */
 struct workqueue_struct *rpciod_workqueue __read_mostly;
 struct workqueue_struct *xprtiod_workqueue __read_mostly;
+EXPORT_SYMBOL_GPL(xprtiod_workqueue);
 
 /*
  * Disable the timer for a given RPC task. Should be called with
* Unmerged path net/sunrpc/xprt.c
diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index 834507c61e0f..092786c8a060 100644
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -298,6 +298,7 @@ xprt_rdma_destroy(struct rpc_xprt *xprt)
 	module_put(THIS_MODULE);
 }
 
+/* 60 second timeout, no retries */
 static const struct rpc_timeout xprt_rdma_default_timeout = {
 	.to_initval = 60 * HZ,
 	.to_maxval = 60 * HZ,
@@ -325,8 +326,9 @@ xprt_setup_rdma(struct xprt_create *args)
 	if (!xprt)
 		return ERR_PTR(-ENOMEM);
 
-	/* 60 second timeout, no retries */
 	xprt->timeout = &xprt_rdma_default_timeout;
+	xprt->connect_timeout = xprt->timeout->to_initval;
+	xprt->max_reconnect_timeout = xprt->timeout->to_maxval;
 	xprt->bind_timeout = RPCRDMA_BIND_TO;
 	xprt->reestablish_timeout = RPCRDMA_INIT_REEST_TO;
 	xprt->idle_timeout = RPCRDMA_IDLE_DISC_TO;
@@ -508,31 +510,64 @@ xprt_rdma_timer(struct rpc_xprt *xprt, struct rpc_task *task)
 }
 
 /**
- * xprt_rdma_connect - try to establish a transport connection
+ * xprt_rdma_set_connect_timeout - set timeouts for establishing a connection
+ * @xprt: controlling transport instance
+ * @connect_timeout: reconnect timeout after client disconnects
+ * @reconnect_timeout: reconnect timeout after server disconnects
+ *
+ */
+static void xprt_rdma_tcp_set_connect_timeout(struct rpc_xprt *xprt,
+					      unsigned long connect_timeout,
+					      unsigned long reconnect_timeout)
+{
+	struct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);
+
+	trace_xprtrdma_op_set_cto(r_xprt, connect_timeout, reconnect_timeout);
+
+	spin_lock(&xprt->transport_lock);
+
+	if (connect_timeout < xprt->connect_timeout) {
+		struct rpc_timeout to;
+		unsigned long initval;
+
+		to = *xprt->timeout;
+		initval = connect_timeout;
+		if (initval < RPCRDMA_INIT_REEST_TO << 1)
+			initval = RPCRDMA_INIT_REEST_TO << 1;
+		to.to_initval = initval;
+		to.to_maxval = initval;
+		r_xprt->rx_timeout = to;
+		xprt->timeout = &r_xprt->rx_timeout;
+		xprt->connect_timeout = connect_timeout;
+	}
+
+	if (reconnect_timeout < xprt->max_reconnect_timeout)
+		xprt->max_reconnect_timeout = reconnect_timeout;
+
+	spin_unlock(&xprt->transport_lock);
+}
+
+/**
+ * xprt_rdma_connect - schedule an attempt to reconnect
  * @xprt: transport state
- * @task: RPC scheduler context
+ * @task: RPC scheduler context (unused)
  *
  */
 static void
 xprt_rdma_connect(struct rpc_xprt *xprt, struct rpc_task *task)
 {
 	struct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);
+	unsigned long delay;
 
 	trace_xprtrdma_op_connect(r_xprt);
+
+	delay = 0;
 	if (r_xprt->rx_ep.rep_connected != 0) {
-		/* Reconnect */
-		schedule_delayed_work(&r_xprt->rx_connect_worker,
-				      xprt->reestablish_timeout);
-		xprt->reestablish_timeout <<= 1;
-		if (xprt->reestablish_timeout > RPCRDMA_MAX_REEST_TO)
-			xprt->reestablish_timeout = RPCRDMA_MAX_REEST_TO;
-		else if (xprt->reestablish_timeout < RPCRDMA_INIT_REEST_TO)
-			xprt->reestablish_timeout = RPCRDMA_INIT_REEST_TO;
-	} else {
-		schedule_delayed_work(&r_xprt->rx_connect_worker, 0);
-		if (!RPC_IS_ASYNC(task))
-			flush_delayed_work(&r_xprt->rx_connect_worker);
+		delay = xprt_reconnect_delay(xprt);
+		xprt_reconnect_backoff(xprt, RPCRDMA_INIT_REEST_TO);
 	}
+	queue_delayed_work(xprtiod_workqueue, &r_xprt->rx_connect_worker,
+			   delay);
 }
 
 /**
@@ -780,6 +815,7 @@ static const struct rpc_xprt_ops xprt_rdma_procs = {
 	.send_request		= xprt_rdma_send_request,
 	.close			= xprt_rdma_close,
 	.destroy		= xprt_rdma_destroy,
+	.set_connect_timeout	= xprt_rdma_tcp_set_connect_timeout,
 	.print_stats		= xprt_rdma_print_stats,
 	.enable_swap		= xprt_rdma_enable_swap,
 	.disable_swap		= xprt_rdma_disable_swap,
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index 3d3c2b9bba6f..b358337bfde1 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -460,6 +460,7 @@ struct rpcrdma_xprt {
 	struct rpcrdma_buffer	rx_buf;
 	struct rpcrdma_create_data_internal rx_data;
 	struct delayed_work	rx_connect_worker;
+	struct rpc_timeout	rx_timeout;
 	struct rpcrdma_stats	rx_stats;
 };
 
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 2984e705d710..f38e1108f3d9 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -2505,25 +2505,6 @@ static void xs_tcp_setup_socket(struct work_struct *work)
 	xprt_wake_pending_tasks(xprt, status);
 }
 
-static unsigned long xs_reconnect_delay(const struct rpc_xprt *xprt)
-{
-	unsigned long start, now = jiffies;
-
-	start = xprt->stat.connect_start + xprt->reestablish_timeout;
-	if (time_after(start, now))
-		return start - now;
-	return 0;
-}
-
-static void xs_reconnect_backoff(struct rpc_xprt *xprt)
-{
-	xprt->reestablish_timeout <<= 1;
-	if (xprt->reestablish_timeout > xprt->max_reconnect_timeout)
-		xprt->reestablish_timeout = xprt->max_reconnect_timeout;
-	if (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)
-		xprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;
-}
-
 /**
  * xs_connect - connect a socket to a remote endpoint
  * @xprt: pointer to transport structure
@@ -2553,8 +2534,8 @@ static void xs_connect(struct rpc_xprt *xprt, struct rpc_task *task)
 		/* Start by resetting any existing state */
 		xs_reset_transport(transport);
 
-		delay = xs_reconnect_delay(xprt);
-		xs_reconnect_backoff(xprt);
+		delay = xprt_reconnect_delay(xprt);
+		xprt_reconnect_backoff(xprt, XS_TCP_INIT_REEST_TO);
 
 	} else
 		dprintk("RPC:       xs_connect scheduled xprt %p\n", xprt);
