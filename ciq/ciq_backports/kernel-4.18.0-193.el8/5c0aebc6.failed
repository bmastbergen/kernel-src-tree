s390/qeth: remove locking for RX modeset cache

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 5c0aebc6db8cf81c5dd888388dcb455beb1a87b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5c0aebc6.failed

The L2 and L3 .ndo_set_rx_mode callbacks maintain an address cache
to decide which addresses have changed since the last modeset.

When the card is set offline, qeth_l?_stop_card() drains this cache.
This happens only after 1) the net_device has been detached, and
2) any pending RX modeset has completed. Consequently we can access the
cache lock-free.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5c0aebc6db8cf81c5dd888388dcb455beb1a87b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 0a2c8843d8cb,918c3e2e2c3d..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -530,8 -528,7 +528,12 @@@ static void qeth_l2_set_rx_mode(struct 
  
  	QETH_CARD_TEXT(card, 3, "setmulti");
  
++<<<<<<< HEAD
 +	spin_lock_bh(&card->mclock);
 +
++=======
+ 	netif_addr_lock_bh(dev);
++>>>>>>> 5c0aebc6db8c (s390/qeth: remove locking for RX modeset cache)
  	netdev_for_each_mc_addr(ha, dev)
  		qeth_l2_add_mac(card, ha);
  	netdev_for_each_uc_addr(ha, dev)
diff --cc drivers/s390/net/qeth_l3_main.c
index 8322b3859bdf,7e32edac627b..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -268,6 -268,18 +268,21 @@@ static int qeth_l3_add_ip(struct qeth_c
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static void qeth_l3_drain_rx_mode_cache(struct qeth_card *card)
+ {
+ 	struct qeth_ipaddr *addr;
+ 	struct hlist_node *tmp;
+ 	int i;
+ 
+ 	hash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {
+ 		hash_del(&addr->hnode);
+ 		kfree(addr);
+ 	}
+ }
+ 
++>>>>>>> 5c0aebc6db8c (s390/qeth: remove locking for RX modeset cache)
  static void qeth_l3_clear_ip_htable(struct qeth_card *card, int recover)
  {
  	struct qeth_ipaddr *addr;
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 43763e505604..1e7adf0e41cc 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -762,7 +762,6 @@ struct qeth_card {
 
 	struct workqueue_struct *event_wq;
 	wait_queue_head_t wait_q;
-	spinlock_t mclock;
 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
 	DECLARE_HASHTABLE(mac_htable, 4);
 	DECLARE_HASHTABLE(ip_htable, 4);
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 3cee916767c4..c9b128a0a419 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -1416,7 +1416,6 @@ static void qeth_setup_card(struct qeth_card *card)
 
 	card->info.type = CARD_RDEV(card)->id.driver_info;
 	card->state = CARD_STATE_DOWN;
-	spin_lock_init(&card->mclock);
 	spin_lock_init(&card->lock);
 	spin_lock_init(&card->ip_lock);
 	spin_lock_init(&card->thread_mask_lock);
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
