xfs: refactor inode update in iunlink_remove

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit b1d2a068ea631891ae7a0b19c37ff8a5bf0f6af4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b1d2a068.failed

In xfs_iunlink_remove we have two identical calls to
xfs_iunlink_update_inode, so move it out of the if statement to simplify
the code some more.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit b1d2a068ea631891ae7a0b19c37ff8a5bf0f6af4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index e66f940da2c6,282316bcce39..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -2006,9 -2189,8 +2006,10 @@@ xfs_iunlink_remove
  	xfs_agnumber_t		agno = XFS_INO_TO_AGNO(mp, ip->i_ino);
  	xfs_agino_t		agino = XFS_INO_TO_AGINO(mp, ip->i_ino);
  	xfs_agino_t		next_agino;
+ 	xfs_agino_t		head_agino;
  	short			bucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;
 +	int			offset;
 +	int			last_offset = 0;
  	int			error;
  
  	/* Get the agi buffer first.  It ensures lock ordering on the list. */
@@@ -2028,132 -2210,34 +2029,162 @@@
  		return -EFSCORRUPTED;
  	}
  
++<<<<<<< HEAD
 +	if (next_agino == agino) {
 +		/*
 +		 * We're at the head of the list.  Get the inode's on-disk
 +		 * buffer to see if there is anyone after us on the list.
 +		 * Only modify our next pointer if it is not already NULLAGINO.
 +		 * This saves us the overhead of dealing with the buffer when
 +		 * there is no need to change it.
 +		 */
 +		error = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,
 +				       0, 0);
 +		if (error) {
 +			xfs_warn(mp, "%s: xfs_imap_to_bp returned error %d.",
 +				__func__, error);
 +			return error;
 +		}
 +		next_agino = be32_to_cpu(dip->di_next_unlinked);
 +		ASSERT(next_agino != 0);
 +		if (next_agino != NULLAGINO) {
 +			dip->di_next_unlinked = cpu_to_be32(NULLAGINO);
 +			offset = ip->i_imap.im_boffset +
 +				offsetof(xfs_dinode_t, di_next_unlinked);
 +
 +			/* need to recalc the inode CRC if appropriate */
 +			xfs_dinode_calc_crc(mp, dip);
 +
 +			xfs_trans_inode_buf(tp, ibp);
 +			xfs_trans_log_buf(tp, ibp, offset,
 +					  (offset + sizeof(xfs_agino_t) - 1));
 +			xfs_inobp_check(mp, ibp);
 +		} else {
 +			xfs_trans_brelse(tp, ibp);
 +		}
 +		/*
 +		 * Point the bucket head pointer at the next inode.
 +		 */
 +		ASSERT(next_agino != 0);
 +		ASSERT(next_agino != agino);
 +		agi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);
 +		offset = offsetof(xfs_agi_t, agi_unlinked) +
 +			(sizeof(xfs_agino_t) * bucket_index);
 +		xfs_trans_log_buf(tp, agibp, offset,
 +				  (offset + sizeof(xfs_agino_t) - 1));
++=======
+ 	/*
+ 	 * Set our inode's next_unlinked pointer to NULL and then return
+ 	 * the old pointer value so that we can update whatever was previous
+ 	 * to us in the list to point to whatever was next in the list.
+ 	 */
+ 	error = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO, &next_agino);
+ 	if (error)
+ 		return error;
+ 
+ 	if (head_agino == agino) {
+ 		/* Point the head of the list to the next unlinked inode. */
+ 		error = xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,
+ 				next_agino);
+ 		if (error)
+ 			return error;
++>>>>>>> b1d2a068ea63 (xfs: refactor inode update in iunlink_remove)
  	} else {
 -		struct xfs_imap	imap;
 -		xfs_agino_t	prev_agino;
 +		/*
 +		 * We need to search the list for the inode being freed.
 +		 */
 +		last_ibp = NULL;
 +		while (next_agino != agino) {
 +			struct xfs_imap	imap;
 +
++<<<<<<< HEAD
 +			if (last_ibp)
 +				xfs_trans_brelse(tp, last_ibp);
 +
 +			imap.im_blkno = 0;
 +			next_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);
 +
 +			error = xfs_imap(mp, tp, next_ino, &imap, 0);
 +			if (error) {
 +				xfs_warn(mp,
 +	"%s: xfs_imap returned error %d.",
 +					 __func__, error);
 +				return error;
 +			}
 +
 +			error = xfs_imap_to_bp(mp, tp, &imap, &last_dip,
 +					       &last_ibp, 0, 0);
 +			if (error) {
 +				xfs_warn(mp,
 +	"%s: xfs_imap_to_bp returned error %d.",
 +					__func__, error);
 +				return error;
 +			}
  
 +			last_offset = imap.im_boffset;
 +			next_agino = be32_to_cpu(last_dip->di_next_unlinked);
 +			if (!xfs_verify_agino(mp, agno, next_agino)) {
 +				XFS_CORRUPTION_ERROR(__func__,
 +						XFS_ERRLEVEL_LOW, mp,
 +						last_dip, sizeof(*last_dip));
 +				return -EFSCORRUPTED;
 +			}
 +		}
 +
 +		/*
 +		 * Now last_ibp points to the buffer previous to us on the
 +		 * unlinked list.  Pull us from the list.
 +		 */
 +		error = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &ibp,
 +				       0, 0);
 +		if (error) {
 +			xfs_warn(mp, "%s: xfs_imap_to_bp(2) returned error %d.",
 +				__func__, error);
 +			return error;
 +		}
 +		next_agino = be32_to_cpu(dip->di_next_unlinked);
 +		ASSERT(next_agino != 0);
 +		ASSERT(next_agino != agino);
 +		if (next_agino != NULLAGINO) {
 +			dip->di_next_unlinked = cpu_to_be32(NULLAGINO);
 +			offset = ip->i_imap.im_boffset +
 +				offsetof(xfs_dinode_t, di_next_unlinked);
 +
 +			/* need to recalc the inode CRC if appropriate */
 +			xfs_dinode_calc_crc(mp, dip);
 +
 +			xfs_trans_inode_buf(tp, ibp);
 +			xfs_trans_log_buf(tp, ibp, offset,
 +					  (offset + sizeof(xfs_agino_t) - 1));
 +			xfs_inobp_check(mp, ibp);
 +		} else {
 +			xfs_trans_brelse(tp, ibp);
 +		}
 +		/*
 +		 * Point the previous inode on the list to the next inode.
 +		 */
 +		last_dip->di_next_unlinked = cpu_to_be32(next_agino);
 +		ASSERT(next_agino != 0);
 +		offset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);
 +
 +		/* need to recalc the inode CRC if appropriate */
 +		xfs_dinode_calc_crc(mp, last_dip);
 +
 +		xfs_trans_inode_buf(tp, last_ibp);
 +		xfs_trans_log_buf(tp, last_ibp, offset,
 +				  (offset + sizeof(xfs_agino_t) - 1));
 +		xfs_inobp_check(mp, last_ibp);
++=======
+ 		/* We need to search the list for the inode being freed. */
+ 		error = xfs_iunlink_map_prev(tp, agno, head_agino, agino,
+ 				&prev_agino, &imap, &last_dip, &last_ibp);
+ 		if (error)
+ 			return error;
+ 
+ 		/* Point the previous inode on the list to the next inode. */
+ 		xfs_iunlink_update_dinode(tp, agno, prev_agino, last_ibp,
+ 				last_dip, &imap, next_agino);
++>>>>>>> b1d2a068ea63 (xfs: refactor inode update in iunlink_remove)
  	}
  	return 0;
  }
* Unmerged path fs/xfs/xfs_inode.c
