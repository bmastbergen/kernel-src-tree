KVM: selftests: Remove duplicate guest mode handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Peter Xu <peterx@redhat.com>
commit 52200d0d944e473142271773c41f5f490f3a821f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/52200d0d.failed

Remove the duplication code in run_test() of dirty_log_test because
after some reordering of functions now we can directly use the outcome
of vm_create().

Meanwhile, with the new VM_MODE_PXXV48_4K, we can safely revert
b442324b58 too where we stick the x86_64 PA width to 39 bits for
dirty_log_test.

	Reviewed-by: Andrew Jones <drjones@redhat.com>
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 52200d0d944e473142271773c41f5f490f3a821f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/dirty_log_test.c
#	tools/testing/selftests/kvm/include/kvm_util.h
#	tools/testing/selftests/kvm/lib/kvm_util.c
diff --cc tools/testing/selftests/kvm/dirty_log_test.c
index a310c854f969,5614222a6628..000000000000
--- a/tools/testing/selftests/kvm/dirty_log_test.c
+++ b/tools/testing/selftests/kvm/dirty_log_test.c
@@@ -233,59 -264,36 +233,82 @@@ static struct kvm_vm *create_vm(enum vm
  static void run_test(enum vm_guest_mode mode, unsigned long iterations,
  		     unsigned long interval, uint64_t phys_offset)
  {
- 	unsigned int guest_pa_bits, guest_page_shift;
  	pthread_t vcpu_thread;
  	struct kvm_vm *vm;
- 	uint64_t max_gfn;
  	unsigned long *bmap;
  
++<<<<<<< HEAD
 +	switch (mode) {
 +	case VM_MODE_P52V48_4K:
 +		guest_pa_bits = 52;
 +		guest_page_shift = 12;
 +		break;
 +	case VM_MODE_P52V48_64K:
 +		guest_pa_bits = 52;
 +		guest_page_shift = 16;
 +		break;
 +	case VM_MODE_P48V48_4K:
 +		guest_pa_bits = 48;
 +		guest_page_shift = 12;
 +		break;
 +	case VM_MODE_P48V48_64K:
 +		guest_pa_bits = 48;
 +		guest_page_shift = 16;
 +		break;
 +	case VM_MODE_P40V48_4K:
 +		guest_pa_bits = 40;
 +		guest_page_shift = 12;
 +		break;
 +	case VM_MODE_P40V48_64K:
 +		guest_pa_bits = 40;
 +		guest_page_shift = 16;
 +		break;
 +	default:
 +		TEST_ASSERT(false, "Unknown guest mode, mode: 0x%x", mode);
 +	}
 +
 +	DEBUG("Testing guest mode: %s\n", vm_guest_mode_string(mode));
 +
 +#ifdef __x86_64__
 +	/*
 +	 * FIXME
 +	 * The x86_64 kvm selftests framework currently only supports a
 +	 * single PML4 which restricts the number of physical address
 +	 * bits we can change to 39.
 +	 */
 +	guest_pa_bits = 39;
 +#endif
 +	max_gfn = (1ul << (guest_pa_bits - guest_page_shift)) - 1;
 +	guest_page_size = (1ul << guest_page_shift);
++=======
+ 	/*
+ 	 * We reserve page table for 2 times of extra dirty mem which
+ 	 * will definitely cover the original (1G+) test range.  Here
+ 	 * we do the calculation with 4K page size which is the
+ 	 * smallest so the page number will be enough for all archs
+ 	 * (e.g., 64K page size guest will need even less memory for
+ 	 * page tables).
+ 	 */
+ 	vm = create_vm(mode, VCPU_ID,
+ 		       2ul << (DIRTY_MEM_BITS - PAGE_SHIFT_4K),
+ 		       guest_code);
+ 
+ 	guest_page_size = vm_get_page_size(vm);
++>>>>>>> 52200d0d944e (KVM: selftests: Remove duplicate guest mode handling)
  	/*
  	 * A little more than 1G of guest page sized pages.  Cover the
  	 * case where the size is not aligned to 64 pages.
  	 */
++<<<<<<< HEAD
 +	guest_num_pages = (1ul << (30 - guest_page_shift)) + 16;
++=======
+ 	guest_num_pages = (1ul << (DIRTY_MEM_BITS -
+ 				   vm_get_page_shift(vm))) + 16;
+ #ifdef __s390x__
+ 	/* Round up to multiple of 1M (segment size) */
+ 	guest_num_pages = (guest_num_pages + 0xff) & ~0xffUL;
+ #endif
++>>>>>>> 52200d0d944e (KVM: selftests: Remove duplicate guest mode handling)
  	host_page_size = getpagesize();
  	host_num_pages = (guest_num_pages * guest_page_size) / host_page_size +
  			 !!((guest_num_pages * guest_page_size) % host_page_size);
diff --cc tools/testing/selftests/kvm/include/kvm_util.h
index 91ca600b443e,29cccaf96baf..000000000000
--- a/tools/testing/selftests/kvm/include/kvm_util.h
+++ b/tools/testing/selftests/kvm/include/kvm_util.h
@@@ -146,6 -152,12 +146,15 @@@ struct kvm_vm *vm_create_default(uint32
  				 void *guest_code);
  void vm_vcpu_add_default(struct kvm_vm *vm, uint32_t vcpuid, void *guest_code);
  
++<<<<<<< HEAD
++=======
+ bool vm_is_unrestricted_guest(struct kvm_vm *vm);
+ 
+ unsigned int vm_get_page_size(struct kvm_vm *vm);
+ unsigned int vm_get_page_shift(struct kvm_vm *vm);
+ unsigned int vm_get_max_gfn(struct kvm_vm *vm);
+ 
++>>>>>>> 52200d0d944e (KVM: selftests: Remove duplicate guest mode handling)
  struct kvm_userspace_memory_region *
  kvm_userspace_memory_region_find(struct kvm_vm *vm, uint64_t start,
  				 uint64_t end);
diff --cc tools/testing/selftests/kvm/lib/kvm_util.c
index 78349c83aabc,80a338b5403c..000000000000
--- a/tools/testing/selftests/kvm/lib/kvm_util.c
+++ b/tools/testing/selftests/kvm/lib/kvm_util.c
@@@ -1601,3 -1616,54 +1603,57 @@@ void *addr_gva2hva(struct kvm_vm *vm, v
  {
  	return addr_gpa2hva(vm, addr_gva2gpa(vm, gva));
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Is Unrestricted Guest
+  *
+  * Input Args:
+  *   vm - Virtual Machine
+  *
+  * Output Args: None
+  *
+  * Return: True if the unrestricted guest is set to 'Y', otherwise return false.
+  *
+  * Check if the unrestricted guest flag is enabled.
+  */
+ bool vm_is_unrestricted_guest(struct kvm_vm *vm)
+ {
+ 	char val = 'N';
+ 	size_t count;
+ 	FILE *f;
+ 
+ 	if (vm == NULL) {
+ 		/* Ensure that the KVM vendor-specific module is loaded. */
+ 		f = fopen(KVM_DEV_PATH, "r");
+ 		TEST_ASSERT(f != NULL, "Error in opening KVM dev file: %d",
+ 			    errno);
+ 		fclose(f);
+ 	}
+ 
+ 	f = fopen("/sys/module/kvm_intel/parameters/unrestricted_guest", "r");
+ 	if (f) {
+ 		count = fread(&val, sizeof(char), 1, f);
+ 		TEST_ASSERT(count == 1, "Unable to read from param file.");
+ 		fclose(f);
+ 	}
+ 
+ 	return val == 'Y';
+ }
+ 
+ unsigned int vm_get_page_size(struct kvm_vm *vm)
+ {
+ 	return vm->page_size;
+ }
+ 
+ unsigned int vm_get_page_shift(struct kvm_vm *vm)
+ {
+ 	return vm->page_shift;
+ }
+ 
+ unsigned int vm_get_max_gfn(struct kvm_vm *vm)
+ {
+ 	return vm->max_gfn;
+ }
++>>>>>>> 52200d0d944e (KVM: selftests: Remove duplicate guest mode handling)
* Unmerged path tools/testing/selftests/kvm/dirty_log_test.c
* Unmerged path tools/testing/selftests/kvm/include/kvm_util.h
* Unmerged path tools/testing/selftests/kvm/lib/kvm_util.c
