net/mlx5: E-Switch, Use atomic rep state to serialize state change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Use atomic rep state to serialize state change (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 96.88%
commit-author Bodong Wang <bodong@mellanox.com>
commit 6f4e02193c9a9ea54dd3151cf97489fa787cd0e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6f4e0219.failed

When the state of rep was introduced, it was also designed to prevent
duplicate unloading of the same rep. Considering the following two
flows when an eswitch manager is at switchdev mode with n VF reps loaded.

+--------------------------------------+--------------------------------+
| cpu-0                                | cpu-1                          |
| --------                             | --------                       |
| mlx5_ib_remove                       | mlx5_eswitch_disable_sriov     |
|  mlx5_ib_unregister_vport_reps       |  esw_offloads_cleanup          |
|   mlx5_eswitch_unregister_vport_reps |   esw_offloads_unload_all_reps |
|    __unload_reps_all_vport           |    __unload_reps_all_vport     |
+--------------------------------------+--------------------------------+

These two flows will try to unload the same rep. Per original design,
once one flow unloads the rep, the state moves to REGISTERED. The 2nd
flow will no longer needs to do the unload and bails out. However, as
read and write of the state is not atomic, when 1st flow is doing the
unload, the state is still LOADED, 2nd flow is able to do the same
unload action. Kernel crash will happen.

To solve this, driver should do atomic test-and-set for the state. So
that only one flow can change the rep state from LOADED to REGISTERED,
and proceed to do the actual unloading.

Since the state is changing to atomic type, all other read/write should
be atomic action as well.

Fixes: f121e0ea9586 (net/mlx5: E-Switch, Add state to eswitch vport representors)
	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6f4e02193c9a9ea54dd3151cf97489fa787cd0e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	include/linux/mlx5/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 5d30117c7129,e09ae27485ee..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -319,7 -333,7 +319,11 @@@ static int esw_set_global_vlan_pop(stru
  	esw_debug(esw->dev, "%s applying global %s policy\n", __func__, val ? "pop" : "none");
  	for (vf_vport = 1; vf_vport < esw->enabled_vports; vf_vport++) {
  		rep = &esw->offloads.vport_reps[vf_vport];
++<<<<<<< HEAD
 +		if (!rep->rep_if[REP_ETH].valid)
++=======
+ 		if (atomic_read(&rep->rep_if[REP_ETH].state) != REP_LOADED)
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  			continue;
  
  		err = __mlx5_eswitch_set_vport_vlan(esw, rep->vport, 0, 0, val);
@@@ -1219,57 -1270,161 +1223,113 @@@ int esw_offloads_init_reps(struct mlx5_
  	if (!esw->offloads.vport_reps)
  		return -ENOMEM;
  
 +	offloads = &esw->offloads;
  	mlx5_query_nic_vport_mac_address(dev, 0, hw_id);
  
 -	mlx5_esw_for_all_reps(esw, vport, rep) {
 -		rep->vport = mlx5_eswitch_index_to_vport_num(esw, vport);
 +	for (vport = 0; vport < total_vfs; vport++) {
 +		rep = &offloads->vport_reps[vport];
 +
 +		rep->vport = vport;
  		ether_addr_copy(rep->hw_id, hw_id);
++<<<<<<< HEAD
++=======
+ 
+ 		for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
+ 			atomic_set(&rep->rep_if[rep_type].state,
+ 				   REP_UNREGISTERED);
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  	}
  
 +	offloads->vport_reps[0].vport = FDB_UPLINK_VPORT;
 +
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void esw_offloads_unload_reps_type(struct mlx5_eswitch *esw, int nvports,
 +					  u8 rep_type)
++=======
+ static void __esw_offloads_unload_rep(struct mlx5_eswitch *esw,
+ 				      struct mlx5_eswitch_rep *rep, u8 rep_type)
+ {
+ 	if (atomic_cmpxchg(&rep->rep_if[rep_type].state,
+ 			   REP_LOADED, REP_REGISTERED) == REP_LOADED)
+ 		rep->rep_if[rep_type].unload(rep);
+ }
+ 
+ static void __unload_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  {
  	struct mlx5_eswitch_rep *rep;
 +	int vport;
  
 -	if (mlx5_ecpf_vport_exists(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -	}
 +	for (vport = nvports - 1; vport >= 0; vport--) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
  
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 +		rep->rep_if[rep_type].unload(rep);
  	}
 -
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	__esw_offloads_unload_rep(esw, rep, rep_type);
 -}
 -
 -static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 -				   u8 rep_type)
 -{
 -	struct mlx5_eswitch_rep *rep;
 -	int i;
 -
 -	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
  }
  
 -static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
 +static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
  {
  	u8 rep_type = NUM_REP_TYPES;
  
  	while (rep_type-- > 0)
 -		__unload_reps_vf_vport(esw, nvports, rep_type);
 +		esw_offloads_unload_reps_type(esw, nvports, rep_type);
  }
  
++<<<<<<< HEAD
 +static int esw_offloads_load_reps_type(struct mlx5_eswitch *esw, int nvports,
 +				       u8 rep_type)
++=======
+ static void __unload_reps_all_vport(struct mlx5_eswitch *esw, int nvports,
+ 				    u8 rep_type)
+ {
+ 	__unload_reps_vf_vport(esw, nvports, rep_type);
+ 
+ 	/* Special vports must be the last to unload. */
+ 	__unload_reps_special_vport(esw, rep_type);
+ }
+ 
+ static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw, int nvports)
+ {
+ 	u8 rep_type = NUM_REP_TYPES;
+ 
+ 	while (rep_type-- > 0)
+ 		__unload_reps_all_vport(esw, nvports, rep_type);
+ }
+ 
+ static int __esw_offloads_load_rep(struct mlx5_eswitch *esw,
+ 				   struct mlx5_eswitch_rep *rep, u8 rep_type)
+ {
+ 	int err = 0;
+ 
+ 	if (atomic_cmpxchg(&rep->rep_if[rep_type].state,
+ 			   REP_REGISTERED, REP_LOADED) == REP_REGISTERED) {
+ 		err = rep->rep_if[rep_type].load(esw->dev, rep);
+ 		if (err)
+ 			atomic_set(&rep->rep_if[rep_type].state,
+ 				   REP_REGISTERED);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int __load_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  {
  	struct mlx5_eswitch_rep *rep;
 +	int vport;
  	int err;
  
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	err = __esw_offloads_load_rep(esw, rep, rep_type);
 -	if (err)
 -		return err;
 -
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 -		err = __esw_offloads_load_rep(esw, rep, rep_type);
 -		if (err)
 -			goto err_pf;
 -	}
 -
 -	if (mlx5_ecpf_vport_exists(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
 -		err = __esw_offloads_load_rep(esw, rep, rep_type);
 -		if (err)
 -			goto err_ecpf;
 -	}
 -
 -	return 0;
 -
 -err_ecpf:
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -	}
 -
 -err_pf:
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	__esw_offloads_unload_rep(esw, rep, rep_type);
 -	return err;
 -}
 -
 -static int __load_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 -				u8 rep_type)
 -{
 -	struct mlx5_eswitch_rep *rep;
 -	int err, i;
 -
 -	mlx5_esw_for_each_vf_rep(esw, i, rep, nvports) {
 -		err = __esw_offloads_load_rep(esw, rep, rep_type);
 -		if (err)
 -			goto err_vf;
 -	}
 -
 -	return 0;
 -
 -err_vf:
 -	__unload_reps_vf_vport(esw, --i, rep_type);
 -	return err;
 -}
 -
 -static int esw_offloads_load_vf_reps(struct mlx5_eswitch *esw, int nvports)
 -{
 -	u8 rep_type = 0;
 -	int err;
 +	for (vport = 0; vport < nvports; vport++) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
  
 -	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++) {
 -		err = __load_reps_vf_vport(esw, nvports, rep_type);
 +		err = rep->rep_if[rep_type].load(esw->dev, rep);
  		if (err)
  			goto err_reps;
  	}
@@@ -1950,39 -2200,39 +2010,49 @@@ int mlx5_devlink_eswitch_encap_mode_get
  	return 0;
  }
  
 -void mlx5_eswitch_register_vport_reps(struct mlx5_eswitch *esw,
 -				      struct mlx5_eswitch_rep_if *__rep_if,
 -				      u8 rep_type)
 +void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
 +				     int vport_index,
 +				     struct mlx5_eswitch_rep_if *__rep_if,
 +				     u8 rep_type)
  {
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep_if *rep_if;
 -	struct mlx5_eswitch_rep *rep;
 -	int i;
  
 -	mlx5_esw_for_all_reps(esw, i, rep) {
 -		rep_if = &rep->rep_if[rep_type];
 -		rep_if->load   = __rep_if->load;
 -		rep_if->unload = __rep_if->unload;
 -		rep_if->get_proto_dev = __rep_if->get_proto_dev;
 -		rep_if->priv = __rep_if->priv;
 +	rep_if = &offloads->vport_reps[vport_index].rep_if[rep_type];
 +
++<<<<<<< HEAD
 +	rep_if->load   = __rep_if->load;
 +	rep_if->unload = __rep_if->unload;
 +	rep_if->get_proto_dev = __rep_if->get_proto_dev;
 +	rep_if->priv = __rep_if->priv;
  
 +	rep_if->valid = true;
++=======
+ 		atomic_set(&rep_if->state, REP_REGISTERED);
+ 	}
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  }
 -EXPORT_SYMBOL(mlx5_eswitch_register_vport_reps);
 +EXPORT_SYMBOL(mlx5_eswitch_register_vport_rep);
  
 -void mlx5_eswitch_unregister_vport_reps(struct mlx5_eswitch *esw, u8 rep_type)
 +void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 +				       int vport_index, u8 rep_type)
  {
 -	u16 max_vf = mlx5_core_max_vfs(esw->dev);
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
 -	int i;
  
 -	if (esw->mode == SRIOV_OFFLOADS)
 -		__unload_reps_all_vport(esw, max_vf, rep_type);
 +	rep = &offloads->vport_reps[vport_index];
 +
++<<<<<<< HEAD
 +	if (esw->mode == SRIOV_OFFLOADS && esw->vports[vport_index].enabled)
 +		rep->rep_if[rep_type].unload(rep);
  
 +	rep->rep_if[rep_type].valid = false;
++=======
+ 	mlx5_esw_for_all_reps(esw, i, rep)
+ 		atomic_set(&rep->rep_if[rep_type].state, REP_UNREGISTERED);
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  }
 -EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_reps);
 +EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_rep);
  
  void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type)
  {
@@@ -1998,15 -2246,11 +2068,19 @@@ void *mlx5_eswitch_get_proto_dev(struc
  				 int vport,
  				 u8 rep_type)
  {
 +	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
  
 -	rep = mlx5_eswitch_get_rep(esw, vport);
 +	if (vport == FDB_UPLINK_VPORT)
 +		vport = UPLINK_REP_INDEX;
 +
++<<<<<<< HEAD
 +	rep = &offloads->vport_reps[vport];
  
 +	if (rep->rep_if[rep_type].valid &&
++=======
+ 	if (atomic_read(&rep->rep_if[rep_type].state) == REP_LOADED &&
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  	    rep->rep_if[rep_type].get_proto_dev)
  		return rep->rep_if[rep_type].get_proto_dev(rep);
  	return NULL;
diff --cc include/linux/mlx5/eswitch.h
index fab5121ffb8f,0ca77dd1429c..000000000000
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@@ -29,7 -35,7 +29,11 @@@ struct mlx5_eswitch_rep_if 
  	void		       (*unload)(struct mlx5_eswitch_rep *rep);
  	void		       *(*get_proto_dev)(struct mlx5_eswitch_rep *rep);
  	void			*priv;
++<<<<<<< HEAD
 +	bool		       valid;
++=======
+ 	atomic_t		state;
++>>>>>>> 6f4e02193c9a (net/mlx5: E-Switch, Use atomic rep state to serialize state change)
  };
  
  struct mlx5_eswitch_rep {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path include/linux/mlx5/eswitch.h
