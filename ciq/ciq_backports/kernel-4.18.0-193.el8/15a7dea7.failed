net/tls: use RCU protection on icsk->icsk_ulp_data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] tls: use RCU protection on icsk->icsk_ulp_data (Sabrina Dubroca) [1760375]
Rebuild_FUZZ: 95.83%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 15a7dea750e0162f273c6e61a94f96944b75b31e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/15a7dea7.failed

We need to make sure context does not get freed while diag
code is interrogating it. Free struct tls_context with
kfree_rcu().

We add the __rcu annotation directly in icsk, and cast it
away in the datapath accessor. Presumably all ULPs will
do a similar thing.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 15a7dea750e0162f273c6e61a94f96944b75b31e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_main.c
diff --cc net/tls/tls_main.c
index 797e39e87f9c,f8f2d2c3d627..000000000000
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@@ -305,6 -316,13 +317,16 @@@ static void tls_sk_proto_close(struct s
  	if (ctx->tx_conf != TLS_BASE || ctx->rx_conf != TLS_BASE)
  		tls_sk_proto_cleanup(sk, ctx, timeo);
  
++<<<<<<< HEAD
++=======
+ 	write_lock_bh(&sk->sk_callback_lock);
+ 	if (free_ctx)
+ 		rcu_assign_pointer(icsk->icsk_ulp_data, NULL);
+ 	sk->sk_prot = ctx->sk_proto;
+ 	if (sk->sk_write_space == tls_write_space)
+ 		sk->sk_write_space = ctx->sk_write_space;
+ 	write_unlock_bh(&sk->sk_callback_lock);
++>>>>>>> 15a7dea750e0 (net/tls: use RCU protection on icsk->icsk_ulp_data)
  	release_sock(sk);
  	if (ctx->tx_conf == TLS_SW)
  		tls_sw_free_ctx_tx(ctx);
@@@ -312,10 -330,10 +334,10 @@@
  		tls_sw_strparser_done(ctx);
  	if (ctx->rx_conf == TLS_SW)
  		tls_sw_free_ctx_rx(ctx);
 -	ctx->sk_proto_close(sk, timeout);
 +	sk_proto_close(sk, timeout);
  
  	if (free_ctx)
- 		tls_ctx_free(ctx);
+ 		tls_ctx_free(sk, ctx);
  }
  
  static int do_tls_getsockopt_tx(struct sock *sk, char __user *optval,
diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h
index fa43b82607d9..59e85bd6f04b 100644
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@ -100,7 +100,7 @@ struct inet_connection_sock {
 	const struct tcp_congestion_ops *icsk_ca_ops;
 	const struct inet_connection_sock_af_ops *icsk_af_ops;
 	const struct tcp_ulp_ops  *icsk_ulp_ops;
-	void			  *icsk_ulp_data;
+	void __rcu		  *icsk_ulp_data;
 	void (*icsk_clean_acked)(struct sock *sk, u32 acked_seq);
 	struct hlist_node         icsk_listen_portaddr_node;
 	unsigned int		  (*icsk_sync_mss)(struct sock *sk, u32 pmtu);
diff --git a/include/net/tls.h b/include/net/tls.h
index c12ffebfa2b4..2aea4fa10abc 100644
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@ -41,6 +41,7 @@
 #include <linux/tcp.h>
 #include <linux/skmsg.h>
 #include <linux/netdevice.h>
+#include <linux/rcupdate.h>
 
 #include <net/tcp.h>
 #include <net/strparser.h>
@@ -290,6 +291,7 @@ struct tls_context {
 
 	struct list_head list;
 	refcount_t refcount;
+	struct rcu_head rcu;
 };
 
 struct tls_offload_context_rx {
@@ -307,7 +309,7 @@ struct tls_offload_context_rx {
 #define TLS_OFFLOAD_CONTEXT_SIZE_RX					\
 	(sizeof(struct tls_offload_context_rx) + TLS_DRIVER_STATE_SIZE_RX)
 
-void tls_ctx_free(struct tls_context *ctx);
+void tls_ctx_free(struct sock *sk, struct tls_context *ctx);
 int wait_on_pending_writer(struct sock *sk, long *timeo);
 int tls_sk_query(struct sock *sk, int optname, char __user *optval,
 		int __user *optlen);
@@ -427,7 +429,10 @@ static inline struct tls_context *tls_get_ctx(const struct sock *sk)
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 
-	return icsk->icsk_ulp_data;
+	/* Use RCU on icsk_ulp_data only for sock diag code,
+	 * TLS data path doesn't need rcu_dereference().
+	 */
+	return (__force void *)icsk->icsk_ulp_data;
 }
 
 static inline void tls_advance_record_sn(struct sock *sk,
diff --git a/net/core/sock_map.c b/net/core/sock_map.c
index 5880835bf4bf..838c787b97dc 100644
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
@@ -354,7 +354,7 @@ static int sock_map_update_common(struct bpf_map *map, u32 idx,
 		return -EINVAL;
 	if (unlikely(idx >= map->max_entries))
 		return -E2BIG;
-	if (unlikely(icsk->icsk_ulp_data))
+	if (unlikely(rcu_access_pointer(icsk->icsk_ulp_data)))
 		return -EINVAL;
 
 	link = sk_psock_init_link();
diff --git a/net/tls/tls_device.c b/net/tls/tls_device.c
index 330d54f9f11e..c59a4dccb01e 100644
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@ -61,7 +61,7 @@ static void tls_device_free_ctx(struct tls_context *ctx)
 	if (ctx->rx_conf == TLS_HW)
 		kfree(tls_offload_ctx_rx(ctx));
 
-	tls_ctx_free(ctx);
+	tls_ctx_free(NULL, ctx);
 }
 
 static void tls_device_gc_task(struct work_struct *work)
* Unmerged path net/tls/tls_main.c
