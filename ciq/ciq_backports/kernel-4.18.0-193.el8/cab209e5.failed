tcp: fix a possible lockdep splat in tcp_done()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Eric Dumazet <edumazet@google.com>
commit cab209e571a9375f7dc6db69a6c40d2d98e57e3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/cab209e5.failed

syzbot found that if __inet_inherit_port() returns an error,
we call tcp_done() after inet_csk_prepare_forced_close(),
meaning the socket lock is no longer held.

We might fix this in a different way in net-next, but
for 5.4 it seems safer to relax the lockdep check.

Fixes: d983ea6f16b8 ("tcp: add rcu protection around tp->fastopen_rsk")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: syzbot <syzkaller@googlegroups.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cab209e571a9375f7dc6db69a6c40d2d98e57e3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp.c
diff --cc net/ipv4/tcp.c
index d17c837b6339,42187a3b82f4..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -3714,8 -3840,14 +3714,17 @@@ EXPORT_SYMBOL(tcp_md5_hash_key)
  
  void tcp_done(struct sock *sk)
  {
 -	struct request_sock *req;
 +	struct request_sock *req = tcp_sk(sk)->fastopen_rsk;
  
++<<<<<<< HEAD
++=======
+ 	/* We might be called with a new socket, after
+ 	 * inet_csk_prepare_forced_close() has been called
+ 	 * so we can not use lockdep_sock_is_held(sk)
+ 	 */
+ 	req = rcu_dereference_protected(tcp_sk(sk)->fastopen_rsk, 1);
+ 
++>>>>>>> cab209e571a9 (tcp: fix a possible lockdep splat in tcp_done())
  	if (sk->sk_state == TCP_SYN_SENT || sk->sk_state == TCP_SYN_RECV)
  		TCP_INC_STATS(sock_net(sk), TCP_MIB_ATTEMPTFAILS);
  
* Unmerged path net/ipv4/tcp.c
