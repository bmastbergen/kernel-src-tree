net/mlx5: fix memory leak in mlx5_fw_fatal_reporter_dump

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: fix memory leak in mlx5_fw_fatal_reporter_dump (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 96.30%
commit-author Navid Emamdoost <navid.emamdoost@gmail.com>
commit c7ed6d0183d5ea9bc31bcaeeba4070bd62546471
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c7ed6d01.failed

In mlx5_fw_fatal_reporter_dump if mlx5_crdump_collect fails the
allocated memory for cr_data must be released otherwise there will be
memory leak. To fix this, this commit changes the return instruction
into goto error handling.

Fixes: 9b1f29823605 ("net/mlx5: Add support for FW fatal reporter dump")
	Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit c7ed6d0183d5ea9bc31bcaeeba4070bd62546471)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index fa1691ba661a,c07f3154437c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -262,9 -408,231 +262,102 @@@ mlx5_fw_reporter_diagnose(struct devlin
  static const struct devlink_health_reporter_ops mlx5_fw_reporter_ops = {
  		.name = "fw",
  		.diagnose = mlx5_fw_reporter_diagnose,
 -		.dump = mlx5_fw_reporter_dump,
  };
  
++<<<<<<< HEAD
 +static void mlx5_fw_reporter_create(struct mlx5_core_dev *dev)
++=======
+ static int
+ mlx5_fw_fatal_reporter_recover(struct devlink_health_reporter *reporter,
+ 			       void *priv_ctx)
+ {
+ 	struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);
+ 
+ 	return mlx5_health_try_recover(dev);
+ }
+ 
+ #define MLX5_CR_DUMP_CHUNK_SIZE 256
+ static int
+ mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,
+ 			    struct devlink_fmsg *fmsg, void *priv_ctx)
+ {
+ 	struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);
+ 	u32 crdump_size = dev->priv.health.crdump_size;
+ 	u32 *cr_data;
+ 	u32 data_size;
+ 	u32 offset;
+ 	int err;
+ 
+ 	if (!mlx5_core_is_pf(dev))
+ 		return -EPERM;
+ 
+ 	cr_data = kvmalloc(crdump_size, GFP_KERNEL);
+ 	if (!cr_data)
+ 		return -ENOMEM;
+ 	err = mlx5_crdump_collect(dev, cr_data);
+ 	if (err)
+ 		goto free_data;
+ 
+ 	if (priv_ctx) {
+ 		struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;
+ 
+ 		err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);
+ 		if (err)
+ 			goto free_data;
+ 	}
+ 
+ 	err = devlink_fmsg_arr_pair_nest_start(fmsg, "crdump_data");
+ 	if (err)
+ 		goto free_data;
+ 	for (offset = 0; offset < crdump_size; offset += data_size) {
+ 		if (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)
+ 			data_size = crdump_size - offset;
+ 		else
+ 			data_size = MLX5_CR_DUMP_CHUNK_SIZE;
+ 		err = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,
+ 					      data_size);
+ 		if (err)
+ 			goto free_data;
+ 	}
+ 	err = devlink_fmsg_arr_pair_nest_end(fmsg);
+ 
+ free_data:
+ 	kvfree(cr_data);
+ 	return err;
+ }
+ 
+ static void mlx5_fw_fatal_reporter_err_work(struct work_struct *work)
+ {
+ 	struct mlx5_fw_reporter_ctx fw_reporter_ctx;
+ 	struct mlx5_core_health *health;
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5_priv *priv;
+ 
+ 	health = container_of(work, struct mlx5_core_health, fatal_report_work);
+ 	priv = container_of(health, struct mlx5_priv, health);
+ 	dev = container_of(priv, struct mlx5_core_dev, priv);
+ 
+ 	mlx5_enter_error_state(dev, false);
+ 	if (IS_ERR_OR_NULL(health->fw_fatal_reporter)) {
+ 		if (mlx5_health_try_recover(dev))
+ 			mlx5_core_err(dev, "health recovery failed\n");
+ 		return;
+ 	}
+ 	fw_reporter_ctx.err_synd = health->synd;
+ 	fw_reporter_ctx.miss_counter = health->miss_counter;
+ 	devlink_health_report(health->fw_fatal_reporter,
+ 			      "FW fatal error reported", &fw_reporter_ctx);
+ }
+ 
+ static const struct devlink_health_reporter_ops mlx5_fw_fatal_reporter_ops = {
+ 		.name = "fw_fatal",
+ 		.recover = mlx5_fw_fatal_reporter_recover,
+ 		.dump = mlx5_fw_fatal_reporter_dump,
+ };
+ 
+ #define MLX5_REPORTER_FW_GRACEFUL_PERIOD 1200000
+ static void mlx5_fw_reporters_create(struct mlx5_core_dev *dev)
++>>>>>>> c7ed6d0183d5 (net/mlx5: fix memory leak in mlx5_fw_fatal_reporter_dump)
  {
  	struct mlx5_core_health *health = &dev->priv.health;
  	struct devlink *devlink = priv_to_devlink(dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
