net/mlx5: Add fw fatal devlink_health_reporter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Add fw fatal devlink_health_reporter (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 95.45%
commit-author Moshe Shemesh <moshe@mellanox.com>
commit 96c82cdfe77b5e769624af71ec0554434037b82f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/96c82cdf.failed

Create mlx5_devlink_health_reporter for fw fatal reporter.
The fw fatal reporter is added in addition to the fw reporter and
implements the recover callback.
The point of having two reporters for FW issues, is that we
don't want to run FW recover on any issue, but only fatal ones.

	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 96c82cdfe77b5e769624af71ec0554434037b82f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index fa1691ba661a,82a658834675..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -137,52 -299,45 +137,90 @@@ static void mlx5_handle_bad_state(struc
  	mlx5_disable_device(dev);
  }
  
 +static void health_recover(struct work_struct *work)
 +{
 +	struct mlx5_core_health *health;
 +	struct delayed_work *dwork;
 +	struct mlx5_core_dev *dev;
 +	struct mlx5_priv *priv;
 +	u8 nic_state;
 +
 +	dwork = container_of(work, struct delayed_work, work);
 +	health = container_of(dwork, struct mlx5_core_health, recover_work);
 +	priv = container_of(health, struct mlx5_priv, health);
 +	dev = container_of(priv, struct mlx5_core_dev, priv);
 +
 +	nic_state = mlx5_get_nic_state(dev);
 +	if (nic_state == MLX5_NIC_IFC_INVALID) {
 +		dev_err(&dev->pdev->dev, "health recovery flow aborted since the nic state is invalid\n");
 +		return;
 +	}
 +
 +	dev_err(&dev->pdev->dev, "starting health recovery flow\n");
 +	mlx5_recover_device(dev);
 +}
 +
  /* How much time to wait until health resetting the driver (in msecs) */
++<<<<<<< HEAD
 +#define MLX5_RECOVERY_DELAY_MSECS 60000
 +static void health_care(struct work_struct *work)
 +{
 +	unsigned long recover_delay = msecs_to_jiffies(MLX5_RECOVERY_DELAY_MSECS);
 +	struct mlx5_core_health *health;
 +	struct mlx5_core_dev *dev;
 +	struct mlx5_priv *priv;
 +	unsigned long flags;
++=======
+ #define MLX5_RECOVERY_WAIT_MSECS 60000
+ static int mlx5_health_try_recover(struct mlx5_core_dev *dev)
+ {
+ 	unsigned long end;
++>>>>>>> 96c82cdfe77b (net/mlx5: Add fw fatal devlink_health_reporter)
  
- 	health = container_of(work, struct mlx5_core_health, work);
- 	priv = container_of(health, struct mlx5_priv, health);
- 	dev = container_of(priv, struct mlx5_core_dev, priv);
  	mlx5_core_warn(dev, "handling bad device here\n");
  	mlx5_handle_bad_state(dev);
++<<<<<<< HEAD
 +
 +	spin_lock_irqsave(&health->wq_lock, flags);
 +	if (!test_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags))
 +		schedule_delayed_work(&health->recover_work, recover_delay);
 +	else
 +		dev_err(&dev->pdev->dev,
 +			"new health works are not permitted at this stage\n");
 +	spin_unlock_irqrestore(&health->wq_lock, flags);
++=======
+ 	end = jiffies + msecs_to_jiffies(MLX5_RECOVERY_WAIT_MSECS);
+ 	while (sensor_pci_not_working(dev)) {
+ 		if (time_after(jiffies, end)) {
+ 			mlx5_core_err(dev,
+ 				      "health recovery flow aborted, PCI reads still not working\n");
+ 			return -EIO;
+ 		}
+ 		msleep(100);
+ 	}
+ 
+ 	mlx5_core_err(dev, "starting health recovery flow\n");
+ 	mlx5_recover_device(dev);
+ 	if (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state) ||
+ 	    check_fatal_sensors(dev)) {
+ 		mlx5_core_err(dev, "health recovery failed\n");
+ 		return -EIO;
+ 	}
+ 	return 0;
+ }
+ 
+ static void health_recover_work(struct work_struct *work)
+ {
+ 	struct mlx5_core_health *health;
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5_priv *priv;
+ 
+ 	health = container_of(work, struct mlx5_core_health, work);
+ 	priv = container_of(health, struct mlx5_priv, health);
+ 	dev = container_of(priv, struct mlx5_core_dev, priv);
+ 
+ 	mlx5_health_try_recover(dev);
++>>>>>>> 96c82cdfe77b (net/mlx5: Add fw fatal devlink_health_reporter)
  }
  
  static const char *hsynd_str(u8 synd)
@@@ -262,9 -421,157 +300,24 @@@ mlx5_fw_reporter_diagnose(struct devlin
  static const struct devlink_health_reporter_ops mlx5_fw_reporter_ops = {
  		.name = "fw",
  		.diagnose = mlx5_fw_reporter_diagnose,
 -		.dump = mlx5_fw_reporter_dump,
  };
  
- static void mlx5_fw_reporter_create(struct mlx5_core_dev *dev)
+ static int
+ mlx5_fw_fatal_reporter_recover(struct devlink_health_reporter *reporter,
+ 			       void *priv_ctx)
+ {
+ 	struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);
+ 
+ 	return mlx5_health_try_recover(dev);
+ }
+ 
+ static const struct devlink_health_reporter_ops mlx5_fw_fatal_reporter_ops = {
+ 		.name = "fw_fatal",
+ 		.recover = mlx5_fw_fatal_reporter_recover,
+ };
+ 
+ #define MLX5_REPORTER_FW_GRACEFUL_PERIOD 1200000
+ static void mlx5_fw_reporters_create(struct mlx5_core_dev *dev)
  {
  	struct mlx5_core_health *health = &dev->priv.health;
  	struct devlink *devlink = priv_to_devlink(dev);
@@@ -413,19 -736,21 +478,26 @@@ int mlx5_health_init(struct mlx5_core_d
  	health = &dev->priv.health;
  	name = kmalloc(64, GFP_KERNEL);
  	if (!name)
- 		return -ENOMEM;
+ 		goto out_err;
  
  	strcpy(name, "mlx5_health");
 -	strcat(name, dev_name(dev->device));
 +	strcat(name, dev->priv.name);
  	health->wq = create_singlethread_workqueue(name);
  	kfree(name);
  	if (!health->wq)
- 		return -ENOMEM;
+ 		goto out_err;
  	spin_lock_init(&health->wq_lock);
++<<<<<<< HEAD
 +	INIT_WORK(&health->work, health_care);
 +	INIT_DELAYED_WORK(&health->recover_work, health_recover);
- 
- 	mlx5_fw_reporter_create(dev);
++=======
+ 	INIT_WORK(&health->work, health_recover_work);
+ 	INIT_WORK(&health->report_work, mlx5_fw_reporter_err_work);
++>>>>>>> 96c82cdfe77b (net/mlx5: Add fw fatal devlink_health_reporter)
  
  	return 0;
+ 
+ out_err:
+ 	mlx5_fw_reporters_destroy(dev);
+ 	return -ENOMEM;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index a8a8d169f681..9e1e3ba04793 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -444,6 +444,7 @@ struct mlx5_core_health {
 	struct work_struct		work;
 	struct delayed_work		recover_work;
 	struct devlink_health_reporter *fw_reporter;
+	struct devlink_health_reporter *fw_fatal_reporter;
 };
 
 struct mlx5_qp_table {
