fuse: unexport request ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 66abc3599c3c8795861470f21ae149520a57153d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/66abc359.failed

All requests are now sent with one of the fuse_simple_... helpers.  Get rid
of the old api from the fuse internal header.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 66abc3599c3c8795861470f21ae149520a57153d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index 64cb2e924653,1ff18d319949..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -96,34 -90,7 +90,38 @@@ static void fuse_req_pages_free(struct 
  		kfree(req->pages);
  }
  
++<<<<<<< HEAD
 +bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
 +			    gfp_t flags)
 +{
 +	struct page **pages;
 +	struct fuse_page_desc *page_descs;
 +	unsigned int npages = min_t(unsigned int,
 +				    max_t(unsigned int, req->max_pages * 2,
 +					  FUSE_DEFAULT_MAX_PAGES_PER_REQ),
 +				    fc->max_pages);
 +	WARN_ON(npages <= req->max_pages);
 +
 +	pages = fuse_pages_alloc(npages, flags, &page_descs);
 +	if (!pages)
 +		return false;
 +
 +	memcpy(pages, req->pages, sizeof(struct page *) * req->max_pages);
 +	memcpy(page_descs, req->page_descs,
 +	       sizeof(struct fuse_page_desc) * req->max_pages);
 +	fuse_req_pages_free(req);
 +	__set_bit(FR_ALLOC_PAGES, &req->flags);
 +	req->pages = pages;
 +	req->page_descs = page_descs;
 +	req->max_pages = npages;
 +
 +	return true;
 +}
 +
 +void fuse_request_free(struct fuse_req *req)
++=======
+ static void fuse_request_free(struct fuse_req *req)
++>>>>>>> 66abc3599c3c (fuse: unexport request ops)
  {
  	fuse_req_pages_free(req);
  	kmem_cache_free(fuse_req_cachep, req);
* Unmerged path fs/fuse/dev.c
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 9711237b572b..9d5e5aa5d9df 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -912,45 +912,12 @@ void __exit fuse_ctl_cleanup(void);
 /**
  * Allocate a request
  */
-struct fuse_req *fuse_request_alloc(unsigned npages);
-
-struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
-
 struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
 			       struct fuse_page_desc **desc);
 bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
 			    gfp_t flags);
 
 
-/**
- * Free a request
- */
-void fuse_request_free(struct fuse_req *req);
-
-/**
- * Get a request, may fail with -ENOMEM,
- * caller should specify # elements in req->pages[] explicitly
- */
-struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages);
-struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
-					     unsigned npages);
-
-/*
- * Increment reference count on request
- */
-void __fuse_get_request(struct fuse_req *req);
-
-/**
- * Decrement reference count of a request.  If count goes to zero free
- * the request.
- */
-void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
-
-/**
- * Send a request (synchronous)
- */
-void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
-
 /**
  * Simple request sending that does request allocation and freeing
  */
@@ -958,12 +925,6 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
 int fuse_simple_background(struct fuse_conn *fc, struct fuse_args *args,
 			   gfp_t gfp_flags);
 
-/**
- * Send a request in the background
- */
-void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
-bool fuse_request_queue_background(struct fuse_conn *fc, struct fuse_req *req);
-
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 void fuse_wait_aborted(struct fuse_conn *fc);
