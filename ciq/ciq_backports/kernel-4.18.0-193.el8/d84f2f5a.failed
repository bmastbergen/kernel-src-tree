drivers/base/node.c: simplify unregister_memory_block_under_nodes()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [base] base/node.c: simplify unregister_memory_block_under_nodes() (Christoph von Recklinghausen) [1766491]
Rebuild_FUZZ: 93.65%
commit-author David Hildenbrand <david@redhat.com>
commit d84f2f5a755208da3f93e17714631485cb3da11c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d84f2f5a.failed

We don't allow to offline memory block devices that belong to multiple
numa nodes.  Therefore, such devices can never get removed.  It is
sufficient to process a single node when removing the memory block.  No
need to iterate over each and every PFN.

We already have the nid stored for each memory block.  Make sure that the
nid always has a sane value.

Please note that checking for node_online(nid) is not required.  If we
would have a memory block belonging to a node that is no longer offline,
then we would have a BUG in the node offlining code.

Link: http://lkml.kernel.org/r/20190719135244.15242-1-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d84f2f5a755208da3f93e17714631485cb3da11c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/node.c
diff --cc drivers/base/node.c
index 8598fcbd2a17,840c95baa1d8..000000000000
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@@ -801,40 -808,19 +806,56 @@@ int register_mem_sect_under_node(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* unregister memory section under all nodes that it spans */
 +int unregister_mem_sect_under_nodes(struct memory_block *mem_blk,
 +				    unsigned long phys_index)
 +{
 +	NODEMASK_ALLOC(nodemask_t, unlinked_nodes, GFP_KERNEL);
 +	unsigned long pfn, sect_start_pfn, sect_end_pfn;
 +
 +	if (!mem_blk) {
 +		NODEMASK_FREE(unlinked_nodes);
 +		return -EFAULT;
 +	}
 +	if (!unlinked_nodes)
 +		return -ENOMEM;
 +	nodes_clear(*unlinked_nodes);
 +
 +	sect_start_pfn = section_nr_to_pfn(phys_index);
 +	sect_end_pfn = sect_start_pfn + PAGES_PER_SECTION - 1;
 +	for (pfn = sect_start_pfn; pfn <= sect_end_pfn; pfn++) {
 +		int nid;
 +
 +		nid = get_nid_for_pfn(pfn);
 +		if (nid < 0)
 +			continue;
 +		if (!node_online(nid))
 +			continue;
 +		if (node_test_and_set(nid, *unlinked_nodes))
 +			continue;
 +		sysfs_remove_link(&node_devices[nid]->dev.kobj,
 +			 kobject_name(&mem_blk->dev.kobj));
 +		sysfs_remove_link(&mem_blk->dev.kobj,
 +			 kobject_name(&node_devices[nid]->dev.kobj));
 +	}
 +	NODEMASK_FREE(unlinked_nodes);
 +	return 0;
++=======
+ /*
+  * Unregister a memory block device under the node it spans. Memory blocks
+  * with multiple nodes cannot be offlined and therefore also never be removed.
+  */
+ void unregister_memory_block_under_nodes(struct memory_block *mem_blk)
+ {
+ 	if (mem_blk->nid == NUMA_NO_NODE)
+ 		return;
+ 
+ 	sysfs_remove_link(&node_devices[mem_blk->nid]->dev.kobj,
+ 			  kobject_name(&mem_blk->dev.kobj));
+ 	sysfs_remove_link(&mem_blk->dev.kobj,
+ 			  kobject_name(&node_devices[mem_blk->nid]->dev.kobj));
++>>>>>>> d84f2f5a7552 (drivers/base/node.c: simplify unregister_memory_block_under_nodes())
  }
  
  int link_mem_sections(int nid, unsigned long start_pfn, unsigned long end_pfn)
diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index 25064c825e5c..707d83c778b2 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -666,6 +666,7 @@ static int init_memory_block(struct memory_block **memory, int block_id,
 	mem->state = state;
 	start_pfn = section_nr_to_pfn(mem->start_section_nr);
 	mem->phys_device = arch_get_memory_phys_device(start_pfn);
+	mem->nid = NUMA_NO_NODE;
 
 	ret = register_memory(mem);
 
* Unmerged path drivers/base/node.c
