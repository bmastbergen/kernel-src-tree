linux/dim: Implement RDMA adaptive moderation (DIM)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Yamin Friedman <yaminf@mellanox.com>
commit f4915455dcf07c4f237d6160a4b6adb0575d2909
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f4915455.failed

RDMA DIM implements a different algorithm from net DIM and is based on
completions which is how we can implement interrupt moderation in RDMA.

The algorithm optimizes for number of completions and ratio between
completions and events. In order to avoid long latencies, the
implementation performs fast reduction of moderation level when the
traffic changes.

	Signed-off-by: Yamin Friedman <yaminf@mellanox.com>
	Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f4915455dcf07c4f237d6160a4b6adb0575d2909)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/dim.h
#	lib/dim/Makefile
diff --cc include/linux/dim.h
index f0f20ed25497,aa69730c3b8d..000000000000
--- a/include/linux/dim.h
+++ b/include/linux/dim.h
@@@ -31,13 -70,33 +31,34 @@@ struct dim_stats 
  	int ppms; /* packets per msec */
  	int bpms; /* bytes per msec */
  	int epms; /* events per msec */
 -	int cpms; /* completions per msec */
 -	int cpe_ratio; /* ratio of completions to events */
  };
  
++<<<<<<< HEAD
 +struct net_dim { /* Dynamic Interrupt Moderation */
++=======
+ /**
+  * Main structure for dynamic interrupt moderation (DIM).
+  * Used for holding all information about a specific DIM instance.
+  *
+  * @state: Algorithm state (see below)
+  * @prev_stats: Measured rates from previous iteration (for comparison)
+  * @start_sample: Sampled data at start of current iteration
+  * @work: Work to perform on action required
+  * @priv: A pointer to the struct that points to dim
+  * @profile_ix: Current moderation profile
+  * @mode: CQ period count mode
+  * @tune_state: Algorithm tuning state (see below)
+  * @steps_right: Number of steps taken towards higher moderation
+  * @steps_left: Number of steps taken towards lower moderation
+  * @tired: Parking depth counter
+  */
+ struct dim {
++>>>>>>> f4915455dcf0 (linux/dim: Implement RDMA adaptive moderation (DIM))
  	u8 state;
  	struct dim_stats prev_stats;
 -	struct dim_sample start_sample;
 -	struct dim_sample measuring_sample;
 +	struct net_dim_sample start_sample;
  	struct work_struct work;
+ 	void *priv;
  	u8 profile_ix;
  	u8 mode;
  	u8 tune_state;
@@@ -132,23 -253,150 +153,155 @@@ net_dim_update_sample(u16 event_ctr, u6
  	s->event_ctr = event_ctr;
  }
  
 -/**
 - *	dim_update_sample_with_comps - set a sample's fields with given
 - *	values including the completion parameter
 - *	@event_ctr: number of events to set
 - *	@packets: number of packets to set
 - *	@bytes: number of bytes to set
 - *	@comps: number of completions to set
 - *	@s: DIM sample
 - */
  static inline void
 -dim_update_sample_with_comps(u16 event_ctr, u64 packets, u64 bytes, u64 comps,
 -			     struct dim_sample *s)
 +dim_calc_stats(struct net_dim_sample *start, struct net_dim_sample *end,
 +	       struct dim_stats *curr_stats)
  {
 -	dim_update_sample(event_ctr, packets, bytes, s);
 -	s->comp_ctr = comps;
 +	/* u32 holds up to 71 minutes, should be enough */
 +	u32 delta_us = ktime_us_delta(end->time, start->time);
 +	u32 npkts = BIT_GAP(BITS_PER_TYPE(u32), end->pkt_ctr, start->pkt_ctr);
 +	u32 nbytes = BIT_GAP(BITS_PER_TYPE(u32), end->byte_ctr,
 +			     start->byte_ctr);
 +
 +	if (!delta_us)
 +		return;
 +
 +	curr_stats->ppms = DIV_ROUND_UP(npkts * USEC_PER_MSEC, delta_us);
 +	curr_stats->bpms = DIV_ROUND_UP(nbytes * USEC_PER_MSEC, delta_us);
 +	curr_stats->epms = DIV_ROUND_UP(DIM_NEVENTS * USEC_PER_MSEC,
 +					delta_us);
  }
  
++<<<<<<< HEAD
++=======
+ /* Net DIM */
+ 
+ /*
+  * Net DIM profiles:
+  *        There are different set of profiles for each CQ period mode.
+  *        There are different set of profiles for RX/TX CQs.
+  *        Each profile size must be of NET_DIM_PARAMS_NUM_PROFILES
+  */
+ #define NET_DIM_PARAMS_NUM_PROFILES 5
+ #define NET_DIM_DEFAULT_RX_CQ_MODERATION_PKTS_FROM_EQE 256
+ #define NET_DIM_DEFAULT_TX_CQ_MODERATION_PKTS_FROM_EQE 128
+ #define NET_DIM_DEF_PROFILE_CQE 1
+ #define NET_DIM_DEF_PROFILE_EQE 1
+ 
+ #define NET_DIM_RX_EQE_PROFILES { \
+ 	{1,   NET_DIM_DEFAULT_RX_CQ_MODERATION_PKTS_FROM_EQE}, \
+ 	{8,   NET_DIM_DEFAULT_RX_CQ_MODERATION_PKTS_FROM_EQE}, \
+ 	{64,  NET_DIM_DEFAULT_RX_CQ_MODERATION_PKTS_FROM_EQE}, \
+ 	{128, NET_DIM_DEFAULT_RX_CQ_MODERATION_PKTS_FROM_EQE}, \
+ 	{256, NET_DIM_DEFAULT_RX_CQ_MODERATION_PKTS_FROM_EQE}, \
+ }
+ 
+ #define NET_DIM_RX_CQE_PROFILES { \
+ 	{2,  256},             \
+ 	{8,  128},             \
+ 	{16, 64},              \
+ 	{32, 64},              \
+ 	{64, 64}               \
+ }
+ 
+ #define NET_DIM_TX_EQE_PROFILES { \
+ 	{1,   NET_DIM_DEFAULT_TX_CQ_MODERATION_PKTS_FROM_EQE},  \
+ 	{8,   NET_DIM_DEFAULT_TX_CQ_MODERATION_PKTS_FROM_EQE},  \
+ 	{32,  NET_DIM_DEFAULT_TX_CQ_MODERATION_PKTS_FROM_EQE},  \
+ 	{64,  NET_DIM_DEFAULT_TX_CQ_MODERATION_PKTS_FROM_EQE},  \
+ 	{128, NET_DIM_DEFAULT_TX_CQ_MODERATION_PKTS_FROM_EQE}   \
+ }
+ 
+ #define NET_DIM_TX_CQE_PROFILES { \
+ 	{5,  128},  \
+ 	{8,  64},  \
+ 	{16, 32},  \
+ 	{32, 32},  \
+ 	{64, 32}   \
+ }
+ 
+ static const struct dim_cq_moder
+ rx_profile[DIM_CQ_PERIOD_NUM_MODES][NET_DIM_PARAMS_NUM_PROFILES] = {
+ 	NET_DIM_RX_EQE_PROFILES,
+ 	NET_DIM_RX_CQE_PROFILES,
+ };
+ 
+ static const struct dim_cq_moder
+ tx_profile[DIM_CQ_PERIOD_NUM_MODES][NET_DIM_PARAMS_NUM_PROFILES] = {
+ 	NET_DIM_TX_EQE_PROFILES,
+ 	NET_DIM_TX_CQE_PROFILES,
+ };
+ 
+ /**
+  *	net_dim_get_rx_moderation - provide a CQ moderation object for the given RX profile
+  *	@cq_period_mode: CQ period mode
+  *	@ix: Profile index
+  */
+ struct dim_cq_moder net_dim_get_rx_moderation(u8 cq_period_mode, int ix);
+ 
+ /**
+  *	net_dim_get_def_rx_moderation - provide the default RX moderation
+  *	@cq_period_mode: CQ period mode
+  */
+ struct dim_cq_moder net_dim_get_def_rx_moderation(u8 cq_period_mode);
+ 
+ /**
+  *	net_dim_get_tx_moderation - provide a CQ moderation object for the given TX profile
+  *	@cq_period_mode: CQ period mode
+  *	@ix: Profile index
+  */
+ struct dim_cq_moder net_dim_get_tx_moderation(u8 cq_period_mode, int ix);
+ 
+ /**
+  *	net_dim_get_def_tx_moderation - provide the default TX moderation
+  *	@cq_period_mode: CQ period mode
+  */
+ struct dim_cq_moder net_dim_get_def_tx_moderation(u8 cq_period_mode);
+ 
+ /**
+  *	net_dim - main DIM algorithm entry point
+  *	@dim: DIM instance information
+  *	@end_sample: Current data measurement
+  *
+  * Called by the consumer.
+  * This is the main logic of the algorithm, where data is processed in order to decide on next
+  * required action.
+  */
+ void net_dim(struct dim *dim, struct dim_sample end_sample);
+ 
+ /* RDMA DIM */
+ 
+ /*
+  * RDMA DIM profile:
+  * profile size must be of RDMA_DIM_PARAMS_NUM_PROFILES.
+  */
+ #define RDMA_DIM_PARAMS_NUM_PROFILES 9
+ #define RDMA_DIM_START_PROFILE 0
+ 
+ static const struct dim_cq_moder
+ rdma_dim_prof[RDMA_DIM_PARAMS_NUM_PROFILES] = {
+ 	{1,   0, 1,  0},
+ 	{1,   0, 4,  0},
+ 	{2,   0, 4,  0},
+ 	{2,   0, 8,  0},
+ 	{4,   0, 8,  0},
+ 	{16,  0, 8,  0},
+ 	{16,  0, 16, 0},
+ 	{32,  0, 16, 0},
+ 	{32,  0, 32, 0},
+ };
+ 
+ /**
+  * rdma_dim - Runs the adaptive moderation.
+  * @dim: The moderation struct.
+  * @completions: The number of completions collected in this round.
+  *
+  * Each call to rdma_dim takes the latest amount of completions that
+  * have been collected and counts them as a new event.
+  * Once enough events have been collected the algorithm decides a new
+  * moderation level.
+  */
+ void rdma_dim(struct dim *dim, u64 completions);
+ 
++>>>>>>> f4915455dcf0 (linux/dim: Implement RDMA adaptive moderation (DIM))
  #endif /* DIM_H */
* Unmerged path lib/dim/Makefile
* Unmerged path include/linux/dim.h
* Unmerged path lib/dim/Makefile
diff --git a/lib/dim/rdma_dim.c b/lib/dim/rdma_dim.c
new file mode 100644
index 000000000000..f7e26c7b4749
--- /dev/null
+++ b/lib/dim/rdma_dim.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+/*
+ * Copyright (c) 2019, Mellanox Technologies inc.  All rights reserved.
+ */
+
+#include <linux/dim.h>
+
+static int rdma_dim_step(struct dim *dim)
+{
+	if (dim->tune_state == DIM_GOING_RIGHT) {
+		if (dim->profile_ix == (RDMA_DIM_PARAMS_NUM_PROFILES - 1))
+			return DIM_ON_EDGE;
+		dim->profile_ix++;
+		dim->steps_right++;
+	}
+	if (dim->tune_state == DIM_GOING_LEFT) {
+		if (dim->profile_ix == 0)
+			return DIM_ON_EDGE;
+		dim->profile_ix--;
+		dim->steps_left++;
+	}
+
+	return DIM_STEPPED;
+}
+
+static int rdma_dim_stats_compare(struct dim_stats *curr,
+				  struct dim_stats *prev)
+{
+	/* first stat */
+	if (!prev->cpms)
+		return DIM_STATS_SAME;
+
+	if (IS_SIGNIFICANT_DIFF(curr->cpms, prev->cpms))
+		return (curr->cpms > prev->cpms) ? DIM_STATS_BETTER :
+						DIM_STATS_WORSE;
+
+	if (IS_SIGNIFICANT_DIFF(curr->cpe_ratio, prev->cpe_ratio))
+		return (curr->cpe_ratio > prev->cpe_ratio) ? DIM_STATS_BETTER :
+						DIM_STATS_WORSE;
+
+	return DIM_STATS_SAME;
+}
+
+static bool rdma_dim_decision(struct dim_stats *curr_stats, struct dim *dim)
+{
+	int prev_ix = dim->profile_ix;
+	u8 state = dim->tune_state;
+	int stats_res;
+	int step_res;
+
+	if (state != DIM_PARKING_ON_TOP && state != DIM_PARKING_TIRED) {
+		stats_res = rdma_dim_stats_compare(curr_stats,
+						   &dim->prev_stats);
+
+		switch (stats_res) {
+		case DIM_STATS_SAME:
+			if (curr_stats->cpe_ratio <= 50 * prev_ix)
+				dim->profile_ix = 0;
+			break;
+		case DIM_STATS_WORSE:
+			dim_turn(dim);
+			/* fall through */
+		case DIM_STATS_BETTER:
+			step_res = rdma_dim_step(dim);
+			if (step_res == DIM_ON_EDGE)
+				dim_turn(dim);
+			break;
+		}
+	}
+
+	dim->prev_stats = *curr_stats;
+
+	return dim->profile_ix != prev_ix;
+}
+
+void rdma_dim(struct dim *dim, u64 completions)
+{
+	struct dim_sample *curr_sample = &dim->measuring_sample;
+	struct dim_stats curr_stats;
+	u32 nevents;
+
+	dim_update_sample_with_comps(curr_sample->event_ctr + 1, 0, 0,
+				     curr_sample->comp_ctr + completions,
+				     &dim->measuring_sample);
+
+	switch (dim->state) {
+	case DIM_MEASURE_IN_PROGRESS:
+		nevents = curr_sample->event_ctr - dim->start_sample.event_ctr;
+		if (nevents < DIM_NEVENTS)
+			break;
+		dim_calc_stats(&dim->start_sample, curr_sample, &curr_stats);
+		if (rdma_dim_decision(&curr_stats, dim)) {
+			dim->state = DIM_APPLY_NEW_PROFILE;
+			schedule_work(&dim->work);
+			break;
+		}
+		/* fall through */
+	case DIM_START_MEASURE:
+		dim->state = DIM_MEASURE_IN_PROGRESS;
+		dim_update_sample_with_comps(curr_sample->event_ctr, 0, 0,
+					     curr_sample->comp_ctr,
+					     &dim->start_sample);
+		break;
+	case DIM_APPLY_NEW_PROFILE:
+		break;
+	}
+}
+EXPORT_SYMBOL(rdma_dim);
