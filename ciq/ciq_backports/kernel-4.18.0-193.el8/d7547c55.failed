KVM: Introduce KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Peter Xu <peterx@redhat.com>
commit d7547c55cbe7471255ca51f14bcd4699f5eaabe5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d7547c55.failed

The previous KVM_CAP_MANUAL_DIRTY_LOG_PROTECT has some problem which
blocks the correct usage from userspace.  Obsolete the old one and
introduce a new capability bit for it.

	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Peter Xu <peterx@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d7547c55cbe7471255ca51f14bcd4699f5eaabe5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index 0b986138c74d,47a5eb00bc53..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -3936,8 -3791,8 +3936,13 @@@ to I/O ports
  
  4.117 KVM_CLEAR_DIRTY_LOG (vm ioctl)
  
++<<<<<<< HEAD
 +Capability: KVM_CAP_MANUAL_DIRTY_LOG_PROTECT
 +Architectures: x86, arm, arm64, mips
++=======
+ Capability: KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2
+ Architectures: x86
++>>>>>>> d7547c55cbe7 (KVM: Introduce KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2)
  Type: vm ioctl
  Parameters: struct kvm_dirty_log (in)
  Returns: 0 on success, -1 on error
@@@ -4968,9 -4780,9 +4973,9 @@@ and injected exceptions
  * For the new DR6 bits, note that bit 16 is set iff the #DB exception
    will clear DR6.RTM.
  
- 7.18 KVM_CAP_MANUAL_DIRTY_LOG_PROTECT
+ 7.18 KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2
  
 -Architectures: all
 +Architectures: x86, arm, arm64, mips
  Parameters: args[0] whether feature should be enabled or not
  
  With this capability enabled, KVM_GET_DIRTY_LOG will not automatically
diff --cc include/uapi/linux/kvm.h
index 89711b519133,d673734c46cb..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -986,10 -986,9 +986,14 @@@ struct kvm_ppc_resize_hpt 
  #define KVM_CAP_HYPERV_ENLIGHTENED_VMCS 163
  #define KVM_CAP_EXCEPTION_PAYLOAD 164
  #define KVM_CAP_ARM_VM_IPA_SIZE 165
- #define KVM_CAP_MANUAL_DIRTY_LOG_PROTECT 166
+ #define KVM_CAP_MANUAL_DIRTY_LOG_PROTECT 166 /* Obsolete */
  #define KVM_CAP_HYPERV_CPUID 167
++<<<<<<< HEAD
 +#define KVM_CAP_PPC_IRQ_XIVE 169
 +#define KVM_CAP_ARM_SVE 170
++=======
+ #define KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 168
++>>>>>>> d7547c55cbe7 (KVM: Introduce KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
* Unmerged path Documentation/virtual/kvm/api.txt
* Unmerged path include/uapi/linux/kvm.h
diff --git a/tools/testing/selftests/kvm/dirty_log_test.c b/tools/testing/selftests/kvm/dirty_log_test.c
index 50a6b3fe6857..5d5ae1be4984 100644
--- a/tools/testing/selftests/kvm/dirty_log_test.c
+++ b/tools/testing/selftests/kvm/dirty_log_test.c
@@ -314,7 +314,7 @@ static void run_test(enum vm_guest_mode mode, unsigned long iterations,
 #ifdef USE_CLEAR_DIRTY_LOG
 	struct kvm_enable_cap cap = {};
 
-	cap.cap = KVM_CAP_MANUAL_DIRTY_LOG_PROTECT;
+	cap.cap = KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2;
 	cap.args[0] = 1;
 	vm_enable_cap(vm, &cap);
 #endif
@@ -433,7 +433,7 @@ int main(int argc, char *argv[])
 #endif
 
 #ifdef USE_CLEAR_DIRTY_LOG
-	if (!kvm_check_cap(KVM_CAP_MANUAL_DIRTY_LOG_PROTECT)) {
+	if (!kvm_check_cap(KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2)) {
 		fprintf(stderr, "KVM_CLEAR_DIRTY_LOG not available, skipping tests\n");
 		exit(KSFT_SKIP);
 	}
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 94830de03d20..c82e50bc923b 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -3128,7 +3128,7 @@ static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
 	case KVM_CAP_CHECK_EXTENSION_VM:
 	case KVM_CAP_ENABLE_CAP_VM:
 #ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
-	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT:
+	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2:
 #endif
 		return 1;
 #ifdef CONFIG_KVM_MMIO
@@ -3164,7 +3164,7 @@ static int kvm_vm_ioctl_enable_cap_generic(struct kvm *kvm,
 {
 	switch (cap->cap) {
 #ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT
-	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT:
+	case KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2:
 		if (cap->flags || (cap->args[0] & ~1))
 			return -EINVAL;
 		kvm->manual_dirty_log_protect = cap->args[0];
