SUNRPC: Refactor RPC call encoding

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 762e4e67b356ab7b8fbfc39bc07dc6110121505e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/762e4e67.failed

Move the call encoding so that it occurs before the transport connection
etc.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 762e4e67b356ab7b8fbfc39bc07dc6110121505e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/xprt.h
#	net/sunrpc/clnt.c
#	net/sunrpc/xprt.c
diff --cc include/linux/sunrpc/xprt.h
index bd743c51a865,b8a7de161f67..000000000000
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@@ -334,6 -344,10 +334,13 @@@ void			xprt_free_slot(struct rpc_xprt *
  				       struct rpc_rqst *req);
  void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
  bool			xprt_prepare_transmit(struct rpc_task *task);
++<<<<<<< HEAD
++=======
+ void			xprt_request_enqueue_transmit(struct rpc_task *task);
+ void			xprt_request_enqueue_receive(struct rpc_task *task);
+ void			xprt_request_wait_receive(struct rpc_task *task);
+ bool			xprt_request_need_retransmit(struct rpc_task *task);
++>>>>>>> 762e4e67b356 (SUNRPC: Refactor RPC call encoding)
  void			xprt_transmit(struct rpc_task *task);
  void			xprt_end_transmit(struct rpc_task *task);
  int			xprt_adjust_timeout(struct rpc_rqst *req);
diff --cc net/sunrpc/clnt.c
index d6ca4ed0e072,64159716be30..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1759,10 -1761,36 +1762,38 @@@ rpc_xdr_encode(struct rpc_task *task
  
  	task->tk_status = rpcauth_wrap_req(task, encode, req, p,
  			task->tk_msg.rpc_argp);
 +	if (task->tk_status == 0)
 +		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
  }
  
+ /*
+  * 3.	Encode arguments of an RPC call
+  */
+ static void
+ call_encode(struct rpc_task *task)
+ {
+ 	if (!rpc_task_need_encode(task))
+ 		goto out;
+ 	/* Encode here so that rpcsec_gss can use correct sequence number. */
+ 	rpc_xdr_encode(task);
+ 	/* Did the encode result in an error condition? */
+ 	if (task->tk_status != 0) {
+ 		/* Was the error nonfatal? */
+ 		if (task->tk_status == -EAGAIN)
+ 			rpc_delay(task, HZ >> 4);
+ 		else
+ 			rpc_exit(task, task->tk_status);
+ 		return;
+ 	}
+ 
+ 	/* Add task to reply queue before transmission to avoid races */
+ 	if (rpc_reply_expected(task))
+ 		xprt_request_enqueue_receive(task);
+ 	xprt_request_enqueue_transmit(task);
+ out:
+ 	task->tk_action = call_bind;
+ }
+ 
  /*
   * 4.	Get the server port number if not yet set
   */
@@@ -1947,19 -1975,9 +1978,25 @@@ call_transmit(struct rpc_task *task
  	dprint_status(task);
  
  	task->tk_action = call_transmit_status;
++<<<<<<< HEAD
 +	/* Encode here so that rpcsec_gss can use correct sequence number. */
 +	if (rpc_task_need_encode(task)) {
 +		rpc_xdr_encode(task);
 +		/* Did the encode result in an error condition? */
 +		if (task->tk_status != 0) {
 +			/* Was the error nonfatal? */
 +			if (task->tk_status == -EAGAIN)
 +				rpc_delay(task, HZ >> 4);
 +			else
 +				rpc_exit(task, task->tk_status);
 +			return;
 +		}
 +	}
++=======
+ 	if (!test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate))
+ 		return;
+ 
++>>>>>>> 762e4e67b356 (SUNRPC: Refactor RPC call encoding)
  	if (!xprt_prepare_transmit(task))
  		return;
  	xprt_transmit(task);
@@@ -2001,10 -2011,9 +2038,15 @@@ call_transmit_status(struct rpc_task *t
  		xprt_end_transmit(task);
  		break;
  	case -EBADMSG:
++<<<<<<< HEAD
 +		clear_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
 +		task->tk_action = call_transmit;
 +		task->tk_status = 0;
++=======
++>>>>>>> 762e4e67b356 (SUNRPC: Refactor RPC call encoding)
  		xprt_end_transmit(task);
+ 		task->tk_status = 0;
+ 		task->tk_action = call_encode;
  		break;
  		/*
  		 * Special cases: if we've been waiting on the
diff --cc net/sunrpc/xprt.c
index cc25632c1df5,613f558a3791..000000000000
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@@ -956,6 -1026,109 +956,112 @@@ static void xprt_timer(struct rpc_task 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * xprt_request_wait_receive - wait for the reply to an RPC request
+  * @task: RPC task about to send a request
+  *
+  */
+ void xprt_request_wait_receive(struct rpc_task *task)
+ {
+ 	struct rpc_rqst *req = task->tk_rqstp;
+ 	struct rpc_xprt *xprt = req->rq_xprt;
+ 
+ 	if (!test_bit(RPC_TASK_NEED_RECV, &task->tk_runstate))
+ 		return;
+ 	/*
+ 	 * Sleep on the pending queue if we're expecting a reply.
+ 	 * The spinlock ensures atomicity between the test of
+ 	 * req->rq_reply_bytes_recvd, and the call to rpc_sleep_on().
+ 	 */
+ 	spin_lock(&xprt->queue_lock);
+ 	if (test_bit(RPC_TASK_NEED_RECV, &task->tk_runstate)) {
+ 		xprt->ops->set_retrans_timeout(task);
+ 		rpc_sleep_on(&xprt->pending, task, xprt_timer);
+ 		/*
+ 		 * Send an extra queue wakeup call if the
+ 		 * connection was dropped in case the call to
+ 		 * rpc_sleep_on() raced.
+ 		 */
+ 		if (xprt_request_retransmit_after_disconnect(task))
+ 			rpc_wake_up_queued_task_set_status(&xprt->pending,
+ 					task, -ENOTCONN);
+ 	}
+ 	spin_unlock(&xprt->queue_lock);
+ }
+ 
+ static bool
+ xprt_request_need_enqueue_transmit(struct rpc_task *task, struct rpc_rqst *req)
+ {
+ 	return !test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
+ }
+ 
+ /**
+  * xprt_request_enqueue_transmit - queue a task for transmission
+  * @task: pointer to rpc_task
+  *
+  * Add a task to the transmission queue.
+  */
+ void
+ xprt_request_enqueue_transmit(struct rpc_task *task)
+ {
+ 	struct rpc_rqst *req = task->tk_rqstp;
+ 	struct rpc_xprt *xprt = req->rq_xprt;
+ 
+ 	if (xprt_request_need_enqueue_transmit(task, req)) {
+ 		spin_lock(&xprt->queue_lock);
+ 		list_add_tail(&req->rq_xmit, &xprt->xmit_queue);
+ 		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
+ 		spin_unlock(&xprt->queue_lock);
+ 	}
+ }
+ 
+ /**
+  * xprt_request_dequeue_transmit_locked - remove a task from the transmission queue
+  * @task: pointer to rpc_task
+  *
+  * Remove a task from the transmission queue
+  * Caller must hold xprt->queue_lock
+  */
+ static void
+ xprt_request_dequeue_transmit_locked(struct rpc_task *task)
+ {
+ 	xprt_task_clear_bytes_sent(task);
+ 	if (test_and_clear_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate))
+ 		list_del(&task->tk_rqstp->rq_xmit);
+ }
+ 
+ /**
+  * xprt_request_dequeue_transmit - remove a task from the transmission queue
+  * @task: pointer to rpc_task
+  *
+  * Remove a task from the transmission queue
+  */
+ static void
+ xprt_request_dequeue_transmit(struct rpc_task *task)
+ {
+ 	struct rpc_rqst *req = task->tk_rqstp;
+ 	struct rpc_xprt *xprt = req->rq_xprt;
+ 
+ 	spin_lock(&xprt->queue_lock);
+ 	xprt_request_dequeue_transmit_locked(task);
+ 	spin_unlock(&xprt->queue_lock);
+ }
+ 
+ /**
+  * xprt_request_need_retransmit - Test if a task needs retransmission
+  * @task: pointer to rpc_task
+  *
+  * Test for whether a connection breakage requires the task to retransmit
+  */
+ bool
+ xprt_request_need_retransmit(struct rpc_task *task)
+ {
+ 	return xprt_request_retransmit_after_disconnect(task);
+ }
+ 
+ /**
++>>>>>>> 762e4e67b356 (SUNRPC: Refactor RPC call encoding)
   * xprt_prepare_transmit - reserve the transport before sending a request
   * @task: RPC task about to send a request
   *
* Unmerged path include/linux/sunrpc/xprt.h
* Unmerged path net/sunrpc/clnt.c
* Unmerged path net/sunrpc/xprt.c
