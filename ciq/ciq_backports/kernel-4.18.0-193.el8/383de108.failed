net/mlx5e: Don't clear the whole vf config when switching modes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Dmytro Linkin <dmitrolin@mellanox.com>
commit 383de108157c881074f32914b61125e299820bd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/383de108.failed

There is no need to reset all vf config (except link state) between
legacy and switchdev modes changes.
Also, set link state to AUTO, when legacy enabled.

Fixes: 3b83b6c2e024 ("net/mlx5e: Clear VF config when switching modes")
	Signed-off-by: Dmytro Linkin <dmitrolin@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 383de108157c881074f32914b61125e299820bd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index fc18b33e9731,e49acd0c5da5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -452,6 -453,41 +452,44 @@@ static void esw_destroy_legacy_table(st
  	esw_destroy_legacy_vepa_table(esw);
  }
  
++<<<<<<< HEAD
++=======
+ #define MLX5_LEGACY_SRIOV_VPORT_EVENTS (MLX5_VPORT_UC_ADDR_CHANGE | \
+ 					MLX5_VPORT_MC_ADDR_CHANGE | \
+ 					MLX5_VPORT_PROMISC_CHANGE)
+ 
+ static int esw_legacy_enable(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_vport *vport;
+ 	int ret, i;
+ 
+ 	ret = esw_create_legacy_table(esw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	mlx5_esw_for_each_vf_vport(esw, i, vport, esw->esw_funcs.num_vfs)
+ 		vport->info.link_state = MLX5_VPORT_ADMIN_STATE_AUTO;
+ 
+ 	ret = mlx5_eswitch_enable_pf_vf_vports(esw, MLX5_LEGACY_SRIOV_VPORT_EVENTS);
+ 	if (ret)
+ 		esw_destroy_legacy_table(esw);
+ 	return ret;
+ }
+ 
+ static void esw_legacy_disable(struct mlx5_eswitch *esw)
+ {
+ 	struct esw_mc_addr *mc_promisc;
+ 
+ 	mlx5_eswitch_disable_pf_vf_vports(esw);
+ 
+ 	mc_promisc = &esw->mc_promisc;
+ 	if (mc_promisc->uplink_rule)
+ 		mlx5_del_flow_rules(mc_promisc->uplink_rule);
+ 
+ 	esw_destroy_legacy_table(esw);
+ }
+ 
++>>>>>>> 383de108157c (net/mlx5e: Don't clear the whole vf config when switching modes)
  /* E-Switch vport UC/MC lists management */
  typedef int (*vport_addr_action)(struct mlx5_eswitch *esw,
  				 struct vport_addr *vaddr);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index cfa5607ee8ba,1a57b2bd74b8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1176,8 -1172,9 +1176,14 @@@ static int esw_offloads_start(struct ml
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_sriov(esw);
 +	err = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_OFFLOADS);
++=======
+ 	mlx5_eswitch_disable(esw, false);
+ 	mlx5_eswitch_update_num_of_vfs(esw, esw->dev->priv.sriov.num_vfs);
+ 	err = mlx5_eswitch_enable(esw, MLX5_ESWITCH_OFFLOADS);
++>>>>>>> 383de108157c (net/mlx5e: Don't clear the whole vf config when switching modes)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack,
  				   "Failed setting eswitch to offloads");
@@@ -1628,13 -2063,13 +1634,18 @@@ err_reps
  static int esw_offloads_stop(struct mlx5_eswitch *esw,
  			     struct netlink_ext_ack *extack)
  {
 -	int err, err1;
 +	int err, err1, num_vfs = esw->dev->priv.sriov.num_vfs;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_sriov(esw);
 +	err = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_LEGACY);
++=======
+ 	mlx5_eswitch_disable(esw, false);
+ 	err = mlx5_eswitch_enable(esw, MLX5_ESWITCH_LEGACY);
++>>>>>>> 383de108157c (net/mlx5e: Don't clear the whole vf config when switching modes)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack, "Failed setting eswitch to legacy");
 -		err1 = mlx5_eswitch_enable(esw, MLX5_ESWITCH_OFFLOADS);
 +		err1 = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_OFFLOADS);
  		if (err1) {
  			NL_SET_ERR_MSG_MOD(extack,
  					   "Failed setting eswitch back to offloads");
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
