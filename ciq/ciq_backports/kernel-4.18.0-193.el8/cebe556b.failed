RDMA/core: Introduce ib_core_device to hold device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Parav Pandit <parav@mellanox.com>
commit cebe556bd755d16559c8bc0d1fe5545db6bbeaf0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/cebe556b.failed

In order to support sysfs entries in multiple net namespaces for a rdma
device, introduce a ib_core_device whose scope is limited to hold core
device and per port sysfs related entries.

This is preparation patch so that multiple ib_core_devices in each net
namespace can be created in subsequent patch who all can share ib_device.

(a) Move sysfs specific fields to ib_core_device.
(b) Make sysfs and device life cycle related routines to work on
    ib_core_device.
(c) Introduce and use rdma_init_coredev() helper to initialize
    coredev fields.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit cebe556bd755d16559c8bc0d1fe5545db6bbeaf0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/device.c
#	drivers/infiniband/core/sysfs.c
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/device.c
index 8641d8bca5aa,31229074981d..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -299,17 -403,25 +318,32 @@@ struct ib_device *_ib_alloc_device(size
  	if (!device)
  		return NULL;
  
 -	if (rdma_restrack_init(device)) {
 -		kfree(device);
 -		return NULL;
 -	}
 +	rdma_restrack_init(device);
 +
++<<<<<<< HEAD
 +	device->dev.class = &ib_class;
 +	device_initialize(&device->dev);
  
 +	INIT_LIST_HEAD(&device->event_handler_list);
 +	spin_lock_init(&device->event_handler_lock);
 +	rwlock_init(&device->client_data_lock);
 +	INIT_LIST_HEAD(&device->client_data_list);
 +	INIT_LIST_HEAD(&device->port_list);
++=======
+ 	device->groups[0] = &ib_dev_attr_group;
+ 	rdma_init_coredev(&device->coredev, device);
+ 
+ 	INIT_LIST_HEAD(&device->event_handler_list);
+ 	spin_lock_init(&device->event_handler_lock);
+ 	mutex_init(&device->unregistration_lock);
+ 	/*
+ 	 * client_data needs to be alloc because we don't want our mark to be
+ 	 * destroyed if the user stores NULL in the client data.
+ 	 */
+ 	xa_init_flags(&device->client_data, XA_FLAGS_ALLOC);
+ 	init_rwsem(&device->client_data_rwsem);
++>>>>>>> cebe556bd755 (RDMA/core: Introduce ib_core_device to hold device)
  	init_completion(&device->unreg_completion);
 -	INIT_WORK(&device->unregistration_work, ib_unregister_work);
  
  	return device;
  }
diff --cc drivers/infiniband/core/sysfs.c
index 7e51b406e89a,46ac766af110..000000000000
--- a/drivers/infiniband/core/sysfs.c
+++ b/drivers/infiniband/core/sysfs.c
@@@ -1303,28 -1304,24 +1304,39 @@@ static void ib_free_port_attrs(struct i
  		kobject_put(p);
  	}
  
- 	kobject_put(device->ports_kobj);
+ 	kobject_put(coredev->ports_kobj);
  }
  
- static int ib_setup_port_attrs(struct ib_device *device)
+ static int ib_setup_port_attrs(struct ib_core_device *coredev)
  {
++<<<<<<< HEAD
++=======
+ 	struct ib_device *device = rdma_device_to_ibdev(&coredev->dev);
+ 	unsigned int port;
++>>>>>>> cebe556bd755 (RDMA/core: Introduce ib_core_device to hold device)
  	int ret;
 +	int i;
  
- 	device->ports_kobj = kobject_create_and_add("ports", &device->dev.kobj);
- 	if (!device->ports_kobj)
+ 	coredev->ports_kobj = kobject_create_and_add("ports",
+ 						     &coredev->dev.kobj);
+ 	if (!coredev->ports_kobj)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if (rdma_cap_ib_switch(device)) {
 +		ret = add_port(device, 0);
++=======
+ 	rdma_for_each_port (device, port) {
+ 		ret = add_port(coredev, port);
++>>>>>>> cebe556bd755 (RDMA/core: Introduce ib_core_device to hold device)
  		if (ret)
  			goto err_put;
 +	} else {
 +		for (i = 1; i <= device->phys_port_cnt; ++i) {
 +			ret = add_port(device, i);
 +			if (ret)
 +				goto err_put;
 +		}
  	}
  
  	return 0;
@@@ -1338,10 -1335,7 +1350,14 @@@ int ib_device_register_sysfs(struct ib_
  {
  	int ret;
  
++<<<<<<< HEAD
 +	device->groups[0] = &dev_attr_group;
 +	device->dev.groups = device->groups;
 +
 +	ret = device_add(&device->dev);
++=======
+ 	ret = ib_setup_port_attrs(&device->coredev);
++>>>>>>> cebe556bd755 (RDMA/core: Introduce ib_core_device to hold device)
  	if (ret)
  		return ret;
  
@@@ -1362,7 -1351,5 +1378,11 @@@ void ib_device_unregister_sysfs(struct 
  		free_hsag(&device->dev.kobj, device->hw_stats_ag);
  	kfree(device->hw_stats);
  
++<<<<<<< HEAD
 +	ib_free_port_attrs(device);
 +	/* Balances with device_add */
 +	device_del(&device->dev);
++=======
+ 	ib_free_port_attrs(&device->coredev);
++>>>>>>> cebe556bd755 (RDMA/core: Introduce ib_core_device to hold device)
  }
diff --cc include/rdma/ib_verbs.h
index 2ff74f11eec0,5f9f4fcdc4cc..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2525,8 -2533,38 +2525,22 @@@ struct ib_device_ops 
  	 */
  	int (*init_port)(struct ib_device *device, u8 port_num,
  			 struct kobject *port_sysfs);
 -	/**
 -	 * Allows rdma drivers to add their own restrack attributes.
 -	 */
 -	int (*fill_res_entry)(struct sk_buff *msg,
 -			      struct rdma_restrack_entry *entry);
 -
 -	/* Device lifecycle callbacks */
 -	/*
 -	 * Called after the device becomes registered, before clients are
 -	 * attached
 -	 */
 -	int (*enable_driver)(struct ib_device *dev);
 -	/*
 -	 * This is called as part of ib_dealloc_device().
 -	 */
 -	void (*dealloc_driver)(struct ib_device *dev);
 -
 -	DECLARE_RDMA_OBJ_SIZE(ib_pd);
 -	DECLARE_RDMA_OBJ_SIZE(ib_ucontext);
  };
  
++<<<<<<< HEAD
++=======
+ struct ib_core_device {
+ 	/* device must be the first element in structure until,
+ 	 * union of ib_core_device and device exists in ib_device.
+ 	 */
+ 	struct device dev;
+ 	struct kobject *ports_kobj;
+ 	struct list_head port_list;
+ 	struct ib_device *owner; /* reach back to owner ib_device */
+ };
+ 
+ struct rdma_restrack_root;
++>>>>>>> cebe556bd755 (RDMA/core: Introduce ib_core_device to hold device)
  struct ib_device {
  	/* Do not access @dma_device directly from ULP nor from HW drivers. */
  	struct device                *dma_device;
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path drivers/infiniband/core/sysfs.c
* Unmerged path include/rdma/ib_verbs.h
