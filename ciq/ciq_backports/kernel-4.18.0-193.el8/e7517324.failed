KVM: X86: Fix fpu state crash in kvm guest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Wanpeng Li <wanpengli@tencent.com>
commit e751732486eb3f159089a64d1901992b1357e7cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e7517324.failed

The idea before commit 240c35a37 (which has just been reverted)
was that we have the following FPU states:

               userspace (QEMU)             guest
---------------------------------------------------------------------------
               processor                    vcpu->arch.guest_fpu
>>> KVM_RUN: kvm_load_guest_fpu
               vcpu->arch.user_fpu          processor
>>> preempt out
               vcpu->arch.user_fpu          current->thread.fpu
>>> preempt in
               vcpu->arch.user_fpu          processor
>>> back to userspace
>>> kvm_put_guest_fpu
               processor                    vcpu->arch.guest_fpu
---------------------------------------------------------------------------

With the new lazy model we want to get the state back to the processor
when schedule in from current->thread.fpu.

	Reported-by: Thomas Lambertz <mail@thomaslambertz.de>
	Reported-by: anthony <antdev66@gmail.com>
	Tested-by: anthony <antdev66@gmail.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Thomas Lambertz <mail@thomaslambertz.de>
	Cc: anthony <antdev66@gmail.com>
	Cc: stable@vger.kernel.org
Fixes: 5f409e20b (x86/fpu: Defer FPU state load until return to userspace)
	Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
[Add a comment in front of the warning. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e751732486eb3f159089a64d1901992b1357e7cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index e45a5f0a3c94,7eb56f8e2ea8..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7891,11 -7992,11 +7895,17 @@@ static int vcpu_enter_guest(struct kvm_
  	}
  
  	trace_kvm_entry(vcpu->vcpu_id);
 +	if (lapic_in_kernel(vcpu) &&
 +	    vcpu->arch.apic->lapic_timer.timer_advance_ns)
 +		wait_lapic_expire(vcpu);
  	guest_enter_irqoff();
  
++<<<<<<< HEAD
++=======
+ 	/* The preempt notifier should have taken care of the FPU already.  */
+ 	WARN_ON_ONCE(test_thread_flag(TIF_NEED_FPU_LOAD));
+ 
++>>>>>>> e751732486eb (KVM: X86: Fix fpu state crash in kvm guest)
  	if (unlikely(vcpu->arch.switch_db_regs)) {
  		set_debugreg(0, 7);
  		set_debugreg(vcpu->arch.eff_db[0], 0);
* Unmerged path arch/x86/kvm/x86.c
