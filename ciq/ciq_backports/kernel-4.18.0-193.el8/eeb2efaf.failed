net/tls: generalize the resync callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] tls: generalize the resync callback (Sabrina Dubroca) [1760375]
Rebuild_FUZZ: 94.59%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit eeb2efaf36c75753f9028de3500669bddfac81a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/eeb2efaf.failed

Currently only RX direction is ever resynced, however, TX may
also get out of sequence if packets get dropped on the way to
the driver.  Rename the resync callback and add a direction
parameter.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eeb2efaf36c75753f9028de3500669bddfac81a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.c
#	drivers/net/ethernet/netronome/nfp/crypto/tls.c
#	include/net/tls.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.c
index e88340e196f7,dc15c5c9e557..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.c
@@@ -160,13 -160,17 +160,21 @@@ static void mlx5e_tls_del(struct net_de
  				direction == TLS_OFFLOAD_CTX_DIR_TX);
  }
  
++<<<<<<< HEAD
 +static void mlx5e_tls_resync_rx(struct net_device *netdev, struct sock *sk,
 +				u32 seq, u64 rcd_sn)
++=======
+ static void mlx5e_tls_resync(struct net_device *netdev, struct sock *sk,
+ 			     u32 seq, u8 *rcd_sn_data,
+ 			     enum tls_offload_ctx_dir direction)
++>>>>>>> eeb2efaf36c7 (net/tls: generalize the resync callback)
  {
  	struct tls_context *tls_ctx = tls_get_ctx(sk);
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5e_tls_offload_context_rx *rx_ctx;
 -	u64 rcd_sn = *(u64 *)rcd_sn_data;
  
+ 	if (WARN_ON_ONCE(direction != TLS_OFFLOAD_CTX_DIR_RX))
+ 		return;
  	rx_ctx = mlx5e_get_tls_rx_context(tls_ctx);
  
  	netdev_info(netdev, "resyncing seq %d rcd %lld\n", seq,
diff --cc include/net/tls.h
index 654ae56c8ae2,9b49baecc4a8..000000000000
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@@ -293,6 -286,32 +293,35 @@@ struct tls_context 
  	refcount_t refcount;
  };
  
++<<<<<<< HEAD
++=======
+ enum tls_offload_ctx_dir {
+ 	TLS_OFFLOAD_CTX_DIR_RX,
+ 	TLS_OFFLOAD_CTX_DIR_TX,
+ };
+ 
+ struct tlsdev_ops {
+ 	int (*tls_dev_add)(struct net_device *netdev, struct sock *sk,
+ 			   enum tls_offload_ctx_dir direction,
+ 			   struct tls_crypto_info *crypto_info,
+ 			   u32 start_offload_tcp_sn);
+ 	void (*tls_dev_del)(struct net_device *netdev,
+ 			    struct tls_context *ctx,
+ 			    enum tls_offload_ctx_dir direction);
+ 	void (*tls_dev_resync)(struct net_device *netdev,
+ 			       struct sock *sk, u32 seq, u8 *rcd_sn,
+ 			       enum tls_offload_ctx_dir direction);
+ };
+ 
+ enum tls_offload_sync_type {
+ 	TLS_OFFLOAD_SYNC_TYPE_DRIVER_REQ = 0,
+ 	TLS_OFFLOAD_SYNC_TYPE_CORE_NEXT_HINT = 1,
+ };
+ 
+ #define TLS_DEVICE_RESYNC_NH_START_IVAL		2
+ #define TLS_DEVICE_RESYNC_NH_MAX_IVAL		128
+ 
++>>>>>>> eeb2efaf36c7 (net/tls: generalize the resync callback)
  struct tls_offload_context_rx {
  	/* sw must be the first member of tls_offload_context_rx */
  	struct tls_sw_context_rx sw;
* Unmerged path drivers/net/ethernet/netronome/nfp/crypto/tls.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_accel/tls.c
* Unmerged path drivers/net/ethernet/netronome/nfp/crypto/tls.c
* Unmerged path include/net/tls.h
diff --git a/net/tls/tls_device.c b/net/tls/tls_device.c
index 330d54f9f11e..3ba32aeaa775 100644
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@ -559,7 +559,8 @@ static void tls_device_resync_rx(struct tls_context *tls_ctx,
 		return;
 	netdev = READ_ONCE(tls_ctx->netdev);
 	if (netdev)
-		netdev->tlsdev_ops->tls_dev_resync_rx(netdev, sk, seq, rcd_sn);
+		netdev->tlsdev_ops->tls_dev_resync(netdev, sk, seq, rcd_sn,
+						   TLS_OFFLOAD_CTX_DIR_RX);
 	clear_bit_unlock(TLS_RX_SYNC_RUNNING, &tls_ctx->flags);
 }
 
@@ -1026,7 +1027,7 @@ static int tls_dev_event(struct notifier_block *this, unsigned long event,
 	case NETDEV_REGISTER:
 	case NETDEV_FEAT_CHANGE:
 		if ((dev->features & NETIF_F_HW_TLS_RX) &&
-		    !dev->tlsdev_ops->tls_dev_resync_rx)
+		    !dev->tlsdev_ops->tls_dev_resync)
 			return NOTIFY_BAD;
 
 		if  (dev->tlsdev_ops &&
