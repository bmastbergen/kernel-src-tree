ALSA: firewire-lib: process payload of isoc context according to packet descriptors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 9a738ad1b1a64ef6d8271d8d42d715b75db6eb0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9a738ad1.failed

This commit changes each of data block processing layer so that it
receives list of packet descriptor.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 9a738ad1b1a64ef6d8271d8d42d715b75db6eb0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/amdtp-am824.c
#	sound/firewire/amdtp-stream.c
#	sound/firewire/amdtp-stream.h
#	sound/firewire/digi00x/amdtp-dot.c
#	sound/firewire/fireface/amdtp-ff.c
#	sound/firewire/motu/amdtp-motu.c
#	sound/firewire/tascam/amdtp-tascam.c
diff --cc sound/firewire/amdtp-am824.c
index 99c99d5627ae,67d735e9a6a4..000000000000
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@@ -331,43 -345,60 +331,99 @@@ static void read_midi_messages(struct a
  	}
  }
  
++<<<<<<< HEAD
 +static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
 +					   unsigned int data_blocks, unsigned int *syt)
 +{
 +	struct amdtp_am824 *p = s->protocol;
 +	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 +	unsigned int pcm_frames;
 +
 +	if (pcm) {
 +		write_pcm_s32(s, pcm, buffer, data_blocks);
 +		pcm_frames = data_blocks * p->frame_multiplier;
 +	} else {
 +		write_pcm_silence(s, buffer, data_blocks);
 +		pcm_frames = 0;
 +	}
 +
 +	if (p->midi_ports)
 +		write_midi_messages(s, buffer, data_blocks);
++=======
+ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	struct amdtp_am824 *p = s->protocol;
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks * p->frame_multiplier;
+ 		} else {
+ 			write_pcm_silence(s, buf, data_blocks);
+ 		}
+ 
+ 		if (p->midi_ports) {
+ 			write_midi_messages(s, buf, data_blocks,
+ 					    desc->data_block_counter);
+ 		}
+ 	}
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  
  	return pcm_frames;
  }
  
++<<<<<<< HEAD
 +static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
 +					   unsigned int data_blocks, unsigned int *syt)
 +{
 +	struct amdtp_am824 *p = s->protocol;
 +	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 +	unsigned int pcm_frames;
 +
 +	if (pcm) {
 +		read_pcm_s32(s, pcm, buffer, data_blocks);
 +		pcm_frames = data_blocks * p->frame_multiplier;
 +	} else {
 +		pcm_frames = 0;
 +	}
 +
 +	if (p->midi_ports)
 +		read_midi_messages(s, buffer, data_blocks);
++=======
+ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	struct amdtp_am824 *p = s->protocol;
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks * p->frame_multiplier;
+ 		}
+ 
+ 		if (p->midi_ports) {
+ 			read_midi_messages(s, buf, data_blocks,
+ 					   desc->data_block_counter);
+ 		}
+ 	}
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  
  	return pcm_frames;
  }
diff --cc sound/firewire/amdtp-stream.c
index 51ab268a7513,369e75e33120..000000000000
--- a/sound/firewire/amdtp-stream.c
+++ b/sound/firewire/amdtp-stream.c
@@@ -102,8 -102,11 +102,8 @@@ int amdtp_stream_init(struct amdtp_stre
  	s->callbacked = false;
  
  	s->fmt = fmt;
- 	s->process_data_blocks = process_data_blocks;
+ 	s->process_ctx_payloads = process_ctx_payloads;
  
 -	if (dir == AMDTP_OUT_STREAM)
 -		s->ctx_data.rx.syt_override = -1;
 -
  	return 0;
  }
  EXPORT_SYMBOL(amdtp_stream_init);
@@@ -694,6 -760,19 +694,22 @@@ static inline void cancel_stream(struc
  	WRITE_ONCE(s->pcm_buffer_pointer, SNDRV_PCM_POS_XRUN);
  }
  
++<<<<<<< HEAD
++=======
+ static void process_ctx_payloads(struct amdtp_stream *s,
+ 				 const struct pkt_desc *descs,
+ 				 unsigned int packets)
+ {
+ 	struct snd_pcm_substream *pcm;
+ 	unsigned int pcm_frames;
+ 
+ 	pcm = READ_ONCE(s->pcm);
+ 	pcm_frames = s->process_ctx_payloads(s, descs, packets, pcm);
+ 	if (pcm)
+ 		update_pcm_pointers(s, pcm, pcm_frames);
+ }
+ 
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  static void out_stream_callback(struct fw_iso_context *context, u32 tstamp,
  				size_t header_length, void *header,
  				void *private_data)
diff --cc sound/firewire/amdtp-stream.h
index eff408b4ee36,50041fa884d9..000000000000
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@@ -100,11 -103,11 +100,17 @@@ struct pkt_desc 
  };
  
  struct amdtp_stream;
- typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
+ typedef unsigned int (*amdtp_stream_process_ctx_payloads_t)(
  						struct amdtp_stream *s,
++<<<<<<< HEAD
 +						__be32 *buffer,
 +						unsigned int data_blocks,
 +						unsigned int *syt);
++=======
+ 						const struct pkt_desc *desc,
+ 						unsigned int packets,
+ 						struct snd_pcm_substream *pcm);
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  struct amdtp_stream {
  	struct fw_unit *unit;
  	enum cip_flags flags;
diff --cc sound/firewire/digi00x/amdtp-dot.c
index 45ff73d16074,d613642a2ce3..000000000000
--- a/sound/firewire/digi00x/amdtp-dot.c
+++ b/sound/firewire/digi00x/amdtp-dot.c
@@@ -329,46 -341,54 +329,97 @@@ void amdtp_dot_midi_trigger(struct amdt
  		WRITE_ONCE(p->midi[port], midi);
  }
  
++<<<<<<< HEAD
 +static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 +					   __be32 *buffer,
 +					   unsigned int data_blocks,
 +					   unsigned int *syt)
 +{
 +	struct snd_pcm_substream *pcm;
 +	unsigned int pcm_frames;
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (pcm) {
 +		read_pcm_s32(s, pcm, buffer, data_blocks);
 +		pcm_frames = data_blocks;
 +	} else {
 +		pcm_frames = 0;
 +	}
 +
 +	read_midi_messages(s, buffer, data_blocks);
 +
 +	return pcm_frames;
 +}
 +
 +static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 +					   __be32 *buffer,
 +					   unsigned int data_blocks,
 +					   unsigned int *syt)
 +{
 +	struct snd_pcm_substream *pcm;
 +	unsigned int pcm_frames;
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (pcm) {
 +		write_pcm_s32(s, pcm, buffer, data_blocks);
 +		pcm_frames = data_blocks;
 +	} else {
 +		write_pcm_silence(s, buffer, data_blocks);
 +		pcm_frames = 0;
 +	}
 +
 +	write_midi_messages(s, buffer, data_blocks);
 +
++=======
+ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		}
+ 
+ 		read_midi_messages(s, buf, data_blocks);
+ 	}
+ 
+ 	return pcm_frames;
+ }
+ 
+ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		} else {
+ 			write_pcm_silence(s, buf, data_blocks);
+ 		}
+ 
+ 		write_midi_messages(s, buf, data_blocks,
+ 				    desc->data_block_counter);
+ 	}
+ 
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  	return pcm_frames;
  }
  
diff --cc sound/firewire/fireface/amdtp-ff.c
index 2938489740b4,119c0076b17a..000000000000
--- a/sound/firewire/fireface/amdtp-ff.c
+++ b/sound/firewire/fireface/amdtp-ff.c
@@@ -102,38 -112,47 +102,80 @@@ int amdtp_ff_add_pcm_hw_constraints(str
  	return amdtp_stream_add_pcm_hw_constraints(s, runtime);
  }
  
++<<<<<<< HEAD
 +static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 +					   __be32 *buffer,
 +					   unsigned int data_blocks,
 +					   unsigned int *syt)
 +{
 +	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 +	unsigned int pcm_frames;
 +
 +	if (pcm) {
 +		write_pcm_s32(s, pcm, (__le32 *)buffer, data_blocks);
 +		pcm_frames = data_blocks;
 +	} else {
 +		write_pcm_silence(s, (__le32 *)buffer, data_blocks);
 +		pcm_frames = 0;
++=======
+ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+ 					   const struct pkt_desc *descs,
+ 					   unsigned int packets,
+ 					   struct snd_pcm_substream *pcm)
+ {
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__le32 *buf = (__le32 *)desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		} else {
+ 			write_pcm_silence(s, buf, data_blocks);
+ 		}
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  	}
  
  	return pcm_frames;
  }
  
++<<<<<<< HEAD
 +static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 +					   __be32 *buffer,
 +					   unsigned int data_blocks,
 +					   unsigned int *syt)
 +{
 +	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 +	unsigned int pcm_frames;
 +
 +	if (pcm) {
 +		read_pcm_s32(s, pcm, (__le32 *)buffer, data_blocks);
 +		pcm_frames = data_blocks;
 +	} else {
 +		pcm_frames = 0;
++=======
+ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__le32 *buf = (__le32 *)desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		}
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  	}
  
  	return pcm_frames;
diff --cc sound/firewire/motu/amdtp-motu.c
index 7973dedd31ef,05a6e218b0ad..000000000000
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@@ -298,24 -310,33 +298,52 @@@ static void __maybe_unused copy_message
  	}
  }
  
++<<<<<<< HEAD
 +static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 +				__be32 *buffer, unsigned int data_blocks,
 +				unsigned int *syt)
 +{
 +	struct amdtp_motu *p = s->protocol;
 +	struct snd_pcm_substream *pcm;
 +
 +	trace_data_block_sph(s, data_blocks, buffer);
 +	trace_data_block_message(s, data_blocks, buffer);
 +
 +	if (p->midi_ports)
 +		read_midi_messages(s, buffer, data_blocks);
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (data_blocks > 0 && pcm)
 +		read_pcm_s32(s, pcm->runtime, buffer, data_blocks);
++=======
+ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	struct amdtp_motu *p = s->protocol;
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		trace_data_block_sph(s, data_blocks, buf);
+ 		trace_data_block_message(s, data_blocks, buf);
+ 
+ 		if (p->midi_ports)
+ 			read_midi_messages(s, buf, data_blocks);
+ 
+ 		if (pcm) {
+ 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		}
+ 	}
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  
 -	return pcm_frames;
 +	return data_blocks;
  }
  
  static inline void compute_next_elapse_from_start(struct amdtp_motu *p)
@@@ -360,33 -381,39 +388,69 @@@ static void write_sph(struct amdtp_stre
  	}
  }
  
++<<<<<<< HEAD
 +static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 +				__be32 *buffer, unsigned int data_blocks,
 +				unsigned int *syt)
 +{
 +	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
 +	struct snd_pcm_substream *pcm;
 +
 +	/* Not used. */
 +	*syt = 0xffff;
++=======
+ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	struct amdtp_motu *p = s->protocol;
+ 	unsigned int pcm_frames = 0;
+ 	int i;
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  
- 	/* TODO: how to interact control messages between userspace? */
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
  
++<<<<<<< HEAD
 +	if (p->midi_ports)
 +		write_midi_messages(s, buffer, data_blocks);
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (pcm)
 +		write_pcm_s32(s, pcm->runtime, buffer, data_blocks);
 +	else
 +		write_pcm_silence(s, buffer, data_blocks);
 +
 +	write_sph(s, buffer, data_blocks);
 +
 +	trace_data_block_sph(s, data_blocks, buffer);
 +	trace_data_block_message(s, data_blocks, buffer);
 +
 +	return data_blocks;
++=======
+ 		// TODO: how to interact control messages between userspace?
+ 
+ 		if (p->midi_ports)
+ 			write_midi_messages(s, buf, data_blocks);
+ 
+ 		if (pcm) {
+ 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		} else {
+ 			write_pcm_silence(s, buf, data_blocks);
+ 		}
+ 
+ 		write_sph(s, buf, data_blocks);
+ 
+ 		trace_data_block_sph(s, data_blocks, buf);
+ 		trace_data_block_message(s, data_blocks, buf);
+ 	}
+ 
+ 	return pcm_frames;
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  }
  
  int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
diff --cc sound/firewire/tascam/amdtp-tascam.c
index 95fb10b7a737,e80bb84c43f6..000000000000
--- a/sound/firewire/tascam/amdtp-tascam.c
+++ b/sound/firewire/tascam/amdtp-tascam.c
@@@ -165,39 -175,52 +165,86 @@@ static void read_status_messages(struc
  	}
  }
  
++<<<<<<< HEAD
 +static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 +					   __be32 *buffer,
 +					   unsigned int data_blocks,
 +					   unsigned int *syt)
 +{
 +	struct snd_pcm_substream *pcm;
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (data_blocks > 0 && pcm)
 +		read_pcm_s32(s, pcm, buffer, data_blocks);
 +
 +	read_status_messages(s, buffer, data_blocks);
 +
 +	return data_blocks;
 +}
 +
 +static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 +					   __be32 *buffer,
 +					   unsigned int data_blocks,
 +					   unsigned int *syt)
 +{
 +	struct snd_pcm_substream *pcm;
 +
 +	/* This field is not used. */
 +	*syt = 0x0000;
++=======
+ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		}
+ 
+ 		read_status_messages(s, buf, data_blocks);
+ 	}
+ 
+ 	return pcm_frames;
+ }
+ 
+ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		} else {
+ 			write_pcm_silence(s, buf, data_blocks);
+ 		}
+ 	}
++>>>>>>> 9a738ad1b1a6 (ALSA: firewire-lib: process payload of isoc context according to packet descriptors)
  
 -	return pcm_frames;
 +	pcm = READ_ONCE(s->pcm);
 +	if (pcm)
 +		write_pcm_s32(s, pcm, buffer, data_blocks);
 +	else
 +		write_pcm_silence(s, buffer, data_blocks);
 +
 +	return data_blocks;
  }
  
  int amdtp_tscm_init(struct amdtp_stream *s, struct fw_unit *unit,
* Unmerged path sound/firewire/amdtp-am824.c
* Unmerged path sound/firewire/amdtp-stream.c
* Unmerged path sound/firewire/amdtp-stream.h
* Unmerged path sound/firewire/digi00x/amdtp-dot.c
* Unmerged path sound/firewire/fireface/amdtp-ff.c
* Unmerged path sound/firewire/motu/amdtp-motu.c
* Unmerged path sound/firewire/tascam/amdtp-tascam.c
