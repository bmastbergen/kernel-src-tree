s390/kasan: support memcpy_real with TRACE_IRQFLAGS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [s390] kasan: support memcpy_real with TRACE_IRQFLAGS (Philipp Rudo) [1777468]
Rebuild_FUZZ: 94.85%
commit-author Vasily Gorbik <gor@linux.ibm.com>
commit 13f9bae579c6bd051e58f326913dd09af1291208
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/13f9bae5.failed

Currently if the kernel is built with CONFIG_TRACE_IRQFLAGS and KASAN
and used as crash kernel it crashes itself due to
trace_hardirqs_off/trace_hardirqs_on being called with DAT off. This
happens because trace_hardirqs_off/trace_hardirqs_on are instrumented and
kasan code tries to perform access to shadow memory to validate memory
accesses. Kasan shadow memory is populated with vmemmap, so all accesses
require DAT on.

memcpy_real could be called with DAT on or off (with kasan enabled DAT
is set even before early code is executed).

Make sure that trace_hardirqs_off/trace_hardirqs_on are called with DAT
on and only actual __memcpy_real is called with DAT off.

Also annotate __memcpy_real and _memcpy_real with __no_sanitize_address
to avoid further problems due to switching DAT off.

	Reviewed-by: Philipp Rudo <prudo@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 13f9bae579c6bd051e58f326913dd09af1291208)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/mm/maccess.c
diff --cc arch/s390/mm/maccess.c
index 0747af25700d,59ad7997fed1..000000000000
--- a/arch/s390/mm/maccess.c
+++ b/arch/s390/mm/maccess.c
@@@ -90,10 -91,9 +90,16 @@@ static int __no_sanitize_address __memc
  	return rc;
  }
  
++<<<<<<< HEAD
 +/*
 + * Copy memory in real mode (kernel to kernel)
 + */
 +int memcpy_real(void *dest, void *src, size_t count)
++=======
+ static unsigned long __no_sanitize_address _memcpy_real(unsigned long dest,
+ 							unsigned long src,
+ 							unsigned long count)
++>>>>>>> 13f9bae579c6 (s390/kasan: support memcpy_real with TRACE_IRQFLAGS)
  {
  	int irqs_disabled, rc;
  	unsigned long flags;
@@@ -104,7 -104,10 +110,14 @@@
  	irqs_disabled = arch_irqs_disabled_flags(flags);
  	if (!irqs_disabled)
  		trace_hardirqs_off();
++<<<<<<< HEAD
 +	rc = __memcpy_real(dest, src, count);
++=======
+ 	__arch_local_irq_stnsm(0xf8); // disable DAT
+ 	rc = __memcpy_real((void *) dest, (void *) src, (size_t) count);
+ 	if (flags & PSW_MASK_DAT)
+ 		__arch_local_irq_stosm(0x04); // enable DAT
++>>>>>>> 13f9bae579c6 (s390/kasan: support memcpy_real with TRACE_IRQFLAGS)
  	if (!irqs_disabled)
  		trace_hardirqs_on();
  	__arch_local_irq_ssm(flags);
* Unmerged path arch/s390/mm/maccess.c
