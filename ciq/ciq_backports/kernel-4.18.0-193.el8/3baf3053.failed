ALSA: firewire-lib: add syt_override member for some protocols

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 3baf30532f94030244a31a275b546d042656c535
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3baf3053.failed

Some protocols don't use syt field of CIP header to represent
presentation timestamp. For such protocol, ALSA IEC 61883-1/6
packet streaming engine uses a pointer into local variable for
the value of syt to call data block processing layer. However,
it can decide the value when initializing packet streaming
layer.

This commit adds 'syt_override' member for packet streaming
layer.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 3baf30532f94030244a31a275b546d042656c535)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/amdtp-stream.c
diff --cc sound/firewire/amdtp-stream.c
index 6572b73cef04,6242240cd8ee..000000000000
--- a/sound/firewire/amdtp-stream.c
+++ b/sound/firewire/amdtp-stream.c
@@@ -722,11 -713,23 +725,20 @@@ static void out_stream_callback(struct 
  		syt = calculate_syt(s, cycle);
  		data_blocks = calculate_data_blocks(s, syt);
  		buffer = s->buffer.packets[s->packet_index].buffer;
 -		dbc = s->data_block_counter;
 -		pcm_frames = s->process_data_blocks(s, buffer, data_blocks, dbc,
 +		pcm_frames = s->process_data_blocks(s, buffer, data_blocks,
  						    &syt);
  
++<<<<<<< HEAD
++=======
+ 		if (s->flags & CIP_DBC_IS_END_EVENT)
+ 			dbc = (dbc + data_blocks) & 0xff;
+ 
+ 		if (s->ctx_data.rx.syt_override >= 0)
+ 			syt = s->ctx_data.rx.syt_override;
+ 
++>>>>>>> 3baf30532f94 (ALSA: firewire-lib: add syt_override member for some protocols)
  		build_it_pkt_header(s, cycle, &template.params, data_blocks,
 -				    dbc, syt, i);
 -
 -		if (!(s->flags & CIP_DBC_IS_END_EVENT))
 -			dbc = (dbc + data_blocks) & 0xff;
 -
 -		s->data_block_counter = dbc;
 +				    syt, i);
  
  		if (queue_out_packet(s, &template.params) < 0) {
  			cancel_stream(s);
* Unmerged path sound/firewire/amdtp-stream.c
diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 3942894c11ac..7779c96ac327 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -131,6 +131,7 @@ struct amdtp_stream {
 
 			// To generate CIP header.
 			unsigned int fdf;
+			int syt_override;
 		} rx;
 	} ctx_data;
 
diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 7973dedd31ef..dc7015cbb174 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -428,7 +428,13 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 		return err;
 
 	s->sph = 1;
-	s->ctx_data.rx.fdf = MOTU_FDF_AM824;
+
+	if (dir == AMDTP_OUT_STREAM) {
+		// Use fixed value for FDF field.
+		s->ctx_data.rx.fdf = MOTU_FDF_AM824;
+		// Not used.
+		s->ctx_data.rx.syt_override = 0xffff;
+	}
 
 	return 0;
 }
diff --git a/sound/firewire/tascam/amdtp-tascam.c b/sound/firewire/tascam/amdtp-tascam.c
index 95fb10b7a737..c5804e431723 100644
--- a/sound/firewire/tascam/amdtp-tascam.c
+++ b/sound/firewire/tascam/amdtp-tascam.c
@@ -222,8 +222,12 @@ int amdtp_tscm_init(struct amdtp_stream *s, struct fw_unit *unit,
 	if (err < 0)
 		return 0;
 
-	/* Use fixed value for FDF field. */
-	s->ctx_data.rx.fdf = 0x00;
+	if (dir == AMDTP_OUT_STREAM) {
+		// Use fixed value for FDF field.
+		s->ctx_data.rx.fdf = 0x00;
+		// Not used.
+		s->ctx_data.rx.syt_override = 0x0000;
+	}
 
 	/* This protocol uses fixed number of data channels for PCM samples. */
 	p = s->protocol;
