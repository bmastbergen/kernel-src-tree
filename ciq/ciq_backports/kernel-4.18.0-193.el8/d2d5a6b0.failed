ALSA: firewire-motu: more code refactoring for MOTU data block processing layer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit d2d5a6b0253d30ef04d513447cdd00df4fa627c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d2d5a6b0.failed

MOTU data block processing layer has some tracepoints events. This
commit is code refactoring to split probing the events from processing
data blocks.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit d2d5a6b0253d30ef04d513447cdd00df4fa627c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/motu/amdtp-motu.c
diff --cc sound/firewire/motu/amdtp-motu.c
index 7973dedd31ef,0fd36e469ad0..000000000000
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@@ -298,24 -310,52 +298,70 @@@ static void __maybe_unused copy_message
  	}
  }
  
++<<<<<<< HEAD
 +static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 +				__be32 *buffer, unsigned int data_blocks,
 +				unsigned int *syt)
 +{
 +	struct amdtp_motu *p = s->protocol;
 +	struct snd_pcm_substream *pcm;
++=======
+ static void probe_tracepoints_events(struct amdtp_stream *s,
+ 				     const struct pkt_desc *descs,
+ 				     unsigned int packets)
+ {
+ 	int i;
++>>>>>>> d2d5a6b0253d (ALSA: firewire-motu: more code refactoring for MOTU data block processing layer)
  
 -	for (i = 0; i < packets; ++i) {
 -		const struct pkt_desc *desc = descs + i;
 -		__be32 *buf = desc->ctx_payload;
 -		unsigned int data_blocks = desc->data_blocks;
 +	trace_data_block_sph(s, data_blocks, buffer);
 +	trace_data_block_message(s, data_blocks, buffer);
  
++<<<<<<< HEAD
 +	if (p->midi_ports)
 +		read_midi_messages(s, buffer, data_blocks);
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (data_blocks > 0 && pcm)
 +		read_pcm_s32(s, pcm->runtime, buffer, data_blocks);
 +
 +	return data_blocks;
++=======
+ 		trace_data_block_sph(s, data_blocks, buf);
+ 		trace_data_block_message(s, data_blocks, buf);
+ 	}
+ }
+ 
+ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+ 					    const struct pkt_desc *descs,
+ 					    unsigned int packets,
+ 					    struct snd_pcm_substream *pcm)
+ {
+ 	struct amdtp_motu *p = s->protocol;
+ 	unsigned int pcm_frames = 0;
+ 	int i;
+ 
+ 	// For data block processing.
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		}
+ 
+ 		if (p->midi_ports)
+ 			read_midi_messages(s, buf, data_blocks);
+ 	}
+ 
+ 	// For tracepoints.
+ 	if (trace_data_block_sph_enabled() ||
+ 	    trace_data_block_message_enabled())
+ 		probe_tracepoints_events(s, descs, packets);
+ 
+ 	return pcm_frames;
++>>>>>>> d2d5a6b0253d (ALSA: firewire-motu: more code refactoring for MOTU data block processing layer)
  }
  
  static inline void compute_next_elapse_from_start(struct amdtp_motu *p)
@@@ -360,33 -400,42 +406,63 @@@ static void write_sph(struct amdtp_stre
  	}
  }
  
 -static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
 -					    const struct pkt_desc *descs,
 -					    unsigned int packets,
 -					    struct snd_pcm_substream *pcm)
 +static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 +				__be32 *buffer, unsigned int data_blocks,
 +				unsigned int *syt)
  {
 -	struct amdtp_motu *p = s->protocol;
 -	unsigned int pcm_frames = 0;
 -	int i;
 +	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
 +	struct snd_pcm_substream *pcm;
 +
++<<<<<<< HEAD
 +	/* Not used. */
 +	*syt = 0xffff;
 +
 +	/* TODO: how to interact control messages between userspace? */
  
 +	if (p->midi_ports)
 +		write_midi_messages(s, buffer, data_blocks);
 +
 +	pcm = READ_ONCE(s->pcm);
 +	if (pcm)
 +		write_pcm_s32(s, pcm->runtime, buffer, data_blocks);
 +	else
 +		write_pcm_silence(s, buffer, data_blocks);
 +
 +	write_sph(s, buffer, data_blocks);
 +
 +	trace_data_block_sph(s, data_blocks, buffer);
 +	trace_data_block_message(s, data_blocks, buffer);
 +
 +	return data_blocks;
++=======
+ 	// For data block processing.
+ 	for (i = 0; i < packets; ++i) {
+ 		const struct pkt_desc *desc = descs + i;
+ 		__be32 *buf = desc->ctx_payload;
+ 		unsigned int data_blocks = desc->data_blocks;
+ 
+ 		if (pcm) {
+ 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+ 			pcm_frames += data_blocks;
+ 		} else {
+ 			write_pcm_silence(s, buf, data_blocks);
+ 		}
+ 
+ 		if (p->midi_ports)
+ 			write_midi_messages(s, buf, data_blocks);
+ 
+ 		// TODO: how to interact control messages between userspace?
+ 
+ 		write_sph(s, buf, data_blocks);
+ 	}
+ 
+ 	// For tracepoints.
+ 	if (trace_data_block_sph_enabled() ||
+ 	    trace_data_block_message_enabled())
+ 		probe_tracepoints_events(s, descs, packets);
+ 
+ 	return pcm_frames;
++>>>>>>> d2d5a6b0253d (ALSA: firewire-motu: more code refactoring for MOTU data block processing layer)
  }
  
  int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
* Unmerged path sound/firewire/motu/amdtp-motu.c
