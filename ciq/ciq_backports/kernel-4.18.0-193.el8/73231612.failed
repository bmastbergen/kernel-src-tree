mm/hmm: improve and rename hmm_vma_fault() to hmm_range_fault()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] hmm: improve and rename hmm_vma_fault() to hmm_range_fault() (Jerome Glisse) [1498655 1597758]
Rebuild_FUZZ: 97.56%
commit-author Jérôme Glisse <jglisse@redhat.com>
commit 73231612dc7c907bd96880a4086ee55eef6b6888
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/73231612.failed

Minor optimization around hmm_pte_need_fault().  Rename for consistency
between code, comments and documentation.  Also improves the comments on
all the possible returns values.  Improve the function by returning the
number of populated entries in pfns array.

Link: http://lkml.kernel.org/r/20190403193318.16478-6-jglisse@redhat.com
	Signed-off-by: Jérôme Glisse <jglisse@redhat.com>
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Balbir Singh <bsingharora@gmail.com>
	Cc: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Souptick Joarder <jrdr.linux@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 73231612dc7c907bd96880a4086ee55eef6b6888)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/vm/hmm.rst
#	mm/hmm.c
diff --cc Documentation/vm/hmm.rst
index cdf3911582c8,61f073215a8d..000000000000
--- a/Documentation/vm/hmm.rst
+++ b/Documentation/vm/hmm.rst
@@@ -189,20 -189,10 +189,25 @@@ the driver callback returns
  When the device driver wants to populate a range of virtual addresses, it can
  use either::
  
++<<<<<<< HEAD
 +  int hmm_vma_get_pfns(struct vm_area_struct *vma,
 +                      struct hmm_range *range,
 +                      unsigned long start,
 +                      unsigned long end,
 +                      hmm_pfn_t *pfns);
 + int hmm_vma_fault(struct vm_area_struct *vma,
 +                   struct hmm_range *range,
 +                   unsigned long start,
 +                   unsigned long end,
 +                   hmm_pfn_t *pfns,
 +                   bool write,
 +                   bool block);
++=======
+   long hmm_range_snapshot(struct hmm_range *range);
+   long hmm_range_fault(struct hmm_range *range, bool block);
++>>>>>>> 73231612dc7c (mm/hmm: improve and rename hmm_vma_fault() to hmm_range_fault())
  
 -The first one (hmm_range_snapshot()) will only fetch present CPU page table
 +The first one (hmm_vma_get_pfns()) will only fetch present CPU page table
  entries and will not trigger a page fault on missing or non-present entries.
  The second one does trigger a page fault on missing or read-only entry if the
  write parameter is true. Page faults use the generic mm page fault code path
diff --cc mm/hmm.c
index 4c052ccc4e21,b7e4034d96e1..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -938,10 -973,20 +924,25 @@@ long hmm_range_fault(struct hmm_range *
  		hmm_pfns_clear(range, &range->pfns[i], hmm_vma_walk.last,
  			       range->end);
  		hmm_vma_range_done(range);
++<<<<<<< HEAD
 +	}
 +	return ret;
++=======
+ 		hmm_put(hmm);
+ 		return ret;
+ 	} else {
+ 		/*
+ 		 * Transfer hmm reference to the range struct it will be drop
+ 		 * inside the hmm_vma_range_done() function (which _must_ be
+ 		 * call if this function return 0).
+ 		 */
+ 		range->hmm = hmm;
+ 	}
+ 
+ 	return (hmm_vma_walk.last - range->start) >> PAGE_SHIFT;
++>>>>>>> 73231612dc7c (mm/hmm: improve and rename hmm_vma_fault() to hmm_range_fault())
  }
- EXPORT_SYMBOL(hmm_vma_fault);
+ EXPORT_SYMBOL(hmm_range_fault);
  #endif /* IS_ENABLED(CONFIG_HMM_MIRROR) */
  
  
* Unmerged path Documentation/vm/hmm.rst
diff --git a/include/linux/hmm.h b/include/linux/hmm.h
index e51dc3e6210f..6ed6b2a24f30 100644
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@ -388,7 +388,18 @@ bool hmm_vma_range_done(struct hmm_range *range);
  *
  * See the function description in mm/hmm.c for further documentation.
  */
-int hmm_vma_fault(struct hmm_range *range, bool block);
+long hmm_range_fault(struct hmm_range *range, bool block);
+
+/* This is a temporary helper to avoid merge conflict between trees. */
+static inline int hmm_vma_fault(struct hmm_range *range, bool block)
+{
+	long ret = hmm_range_fault(range, block);
+	if (ret == -EBUSY)
+		ret = -EAGAIN;
+	else if (ret == -EAGAIN)
+		ret = -EBUSY;
+	return ret < 0 ? ret : 0;
+}
 
 /* Below are for HMM internal use only! Not to be used by device driver! */
 void hmm_mm_destroy(struct mm_struct *mm);
* Unmerged path mm/hmm.c
