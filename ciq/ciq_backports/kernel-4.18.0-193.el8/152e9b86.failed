s390/vtime: steal time exponential moving average

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [s390] vtime: steal time exponential moving average (Thomas Huth) [1749503]
Rebuild_FUZZ: 94.62%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 152e9b8676c6e788c6bff095c1eaae7b86df5003
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/152e9b86.failed

To be able to judge the current overcommitment ratio for a CPU add
a lowcore field with the exponential moving average of the steal time.
The average is updated every tick.

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 152e9b8676c6e788c6bff095c1eaae7b86df5003)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/lowcore.h
diff --cc arch/s390/include/asm/lowcore.h
index 406d940173ab,5b9f10b1e55d..000000000000
--- a/arch/s390/include/asm/lowcore.h
+++ b/arch/s390/include/asm/lowcore.h
@@@ -91,31 -91,32 +91,39 @@@ struct lowcore 
  	__u64	hardirq_timer;			/* 0x02e8 */
  	__u64	softirq_timer;			/* 0x02f0 */
  	__u64	steal_timer;			/* 0x02f8 */
- 	__u64	last_update_timer;		/* 0x0300 */
- 	__u64	last_update_clock;		/* 0x0308 */
- 	__u64	int_clock;			/* 0x0310 */
- 	__u64	mcck_clock;			/* 0x0318 */
- 	__u64	clock_comparator;		/* 0x0320 */
- 	__u64	boot_clock[2];			/* 0x0328 */
+ 	__u64	avg_steal_timer;		/* 0x0300 */
+ 	__u64	last_update_timer;		/* 0x0308 */
+ 	__u64	last_update_clock;		/* 0x0310 */
+ 	__u64	int_clock;			/* 0x0318*/
+ 	__u64	mcck_clock;			/* 0x0320 */
+ 	__u64	clock_comparator;		/* 0x0328 */
+ 	__u64	boot_clock[2];			/* 0x0330 */
  
  	/* Current process. */
- 	__u64	current_task;			/* 0x0338 */
- 	__u64	kernel_stack;			/* 0x0340 */
+ 	__u64	current_task;			/* 0x0340 */
+ 	__u64	kernel_stack;			/* 0x0348 */
  
++<<<<<<< HEAD
 +	/* Interrupt, panic and restart stack. */
 +	__u64	async_stack;			/* 0x0348 */
 +	__u64	panic_stack;			/* 0x0350 */
 +	__u64	restart_stack;			/* 0x0358 */
++=======
+ 	/* Interrupt, DAT-off and restartstack. */
+ 	__u64	async_stack;			/* 0x0350 */
+ 	__u64	nodat_stack;			/* 0x0358 */
+ 	__u64	restart_stack;			/* 0x0360 */
++>>>>>>> 152e9b8676c6 (s390/vtime: steal time exponential moving average)
  
  	/* Restart function and parameter. */
- 	__u64	restart_fn;			/* 0x0360 */
- 	__u64	restart_data;			/* 0x0368 */
- 	__u64	restart_source;			/* 0x0370 */
+ 	__u64	restart_fn;			/* 0x0368 */
+ 	__u64	restart_data;			/* 0x0370 */
+ 	__u64	restart_source;			/* 0x0378 */
  
  	/* Address space pointer. */
- 	__u64	kernel_asce;			/* 0x0378 */
- 	__u64	user_asce;			/* 0x0380 */
- 	__u64	vdso_asce;			/* 0x0388 */
+ 	__u64	kernel_asce;			/* 0x0380 */
+ 	__u64	user_asce;			/* 0x0388 */
+ 	__u64	vdso_asce;			/* 0x0390 */
  
  	/*
  	 * The lpp and current_pid fields form a
* Unmerged path arch/s390/include/asm/lowcore.h
diff --git a/arch/s390/kernel/smp.c b/arch/s390/kernel/smp.c
index fdeb14d5b884..3fba343eb1ca 100644
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -262,7 +262,8 @@ static void pcpu_prepare_secondary(struct pcpu *pcpu, int cpu)
 	lc->percpu_offset = __per_cpu_offset[cpu];
 	lc->kernel_asce = S390_lowcore.kernel_asce;
 	lc->machine_flags = S390_lowcore.machine_flags;
-	lc->user_timer = lc->system_timer = lc->steal_timer = 0;
+	lc->user_timer = lc->system_timer =
+		lc->steal_timer = lc->avg_steal_timer = 0;
 	__ctl_store(lc->cregs_save_area, 0, 15);
 	save_access_regs((unsigned int *) lc->access_regs_save_area);
 	memcpy(lc->stfle_fac_list, S390_lowcore.stfle_fac_list,
diff --git a/arch/s390/kernel/vtime.c b/arch/s390/kernel/vtime.c
index 1b3a10898210..9f8c9ba7b2e1 100644
--- a/arch/s390/kernel/vtime.c
+++ b/arch/s390/kernel/vtime.c
@@ -124,7 +124,7 @@ static void account_system_index_scaled(struct task_struct *p, u64 cputime,
  */
 static int do_account_vtime(struct task_struct *tsk)
 {
-	u64 timer, clock, user, guest, system, hardirq, softirq, steal;
+	u64 timer, clock, user, guest, system, hardirq, softirq;
 
 	timer = S390_lowcore.last_update_timer;
 	clock = S390_lowcore.last_update_clock;
@@ -182,12 +182,6 @@ static int do_account_vtime(struct task_struct *tsk)
 	if (softirq)
 		account_system_index_scaled(tsk, softirq, CPUTIME_SOFTIRQ);
 
-	steal = S390_lowcore.steal_timer;
-	if ((s64) steal > 0) {
-		S390_lowcore.steal_timer = 0;
-		account_steal_time(cputime_to_nsecs(steal));
-	}
-
 	return virt_timer_forward(user + guest + system + hardirq + softirq);
 }
 
@@ -213,8 +207,19 @@ void vtime_task_switch(struct task_struct *prev)
  */
 void vtime_flush(struct task_struct *tsk)
 {
+	u64 steal, avg_steal;
+
 	if (do_account_vtime(tsk))
 		virt_timer_expire();
+
+	steal = S390_lowcore.steal_timer;
+	avg_steal = S390_lowcore.avg_steal_timer / 2;
+	if ((s64) steal > 0) {
+		S390_lowcore.steal_timer = 0;
+		account_steal_time(steal);
+		avg_steal += steal;
+	}
+	S390_lowcore.avg_steal_timer = avg_steal;
 }
 
 /*
