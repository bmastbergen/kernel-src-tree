tcp: adjust rto_base in retransmits_timed_out()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 3256a2d6ab1f71f9a1bd2d7f6f18eb8108c48d17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3256a2d6.failed

The cited commit exposed an old retransmits_timed_out() bug
which assumed it could call tcp_model_timeout() with
TCP_RTO_MIN as rto_base for all states.

But flows in SYN_SENT or SYN_RECV state uses a different
RTO base (1 sec instead of 200 ms, unless BPF choses
another value)

This caused a reduction of SYN retransmits from 6 to 4 with
the default /proc/sys/net/ipv4/tcp_syn_retries value.

Fixes: a41e8a88b06e ("tcp: better handle TCP_USER_TIMEOUT in SYN_SENT state")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Marek Majkowski <marek@cloudflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3256a2d6ab1f71f9a1bd2d7f6f18eb8108c48d17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_timer.c
diff --cc net/ipv4/tcp_timer.c
index f581b63b08b7,05be564414e9..000000000000
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@@ -196,21 -197,16 +196,32 @@@ static bool retransmits_timed_out(struc
  	if (!inet_csk(sk)->icsk_retransmits)
  		return false;
  
++<<<<<<< HEAD
 +	start_ts = tcp_retransmit_stamp(sk);
 +	if (!start_ts)
 +		return false;
++=======
+ 	start_ts = tcp_sk(sk)->retrans_stamp;
+ 	if (likely(timeout == 0)) {
+ 		unsigned int rto_base = TCP_RTO_MIN;
+ 
+ 		if ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))
+ 			rto_base = tcp_timeout_init(sk);
+ 		timeout = tcp_model_timeout(sk, boundary, rto_base);
+ 	}
++>>>>>>> 3256a2d6ab1f (tcp: adjust rto_base in retransmits_timed_out())
  
 -	return (s32)(tcp_time_stamp(tcp_sk(sk)) - start_ts - timeout) >= 0;
 +	if (likely(timeout == 0)) {
 +		linear_backoff_thresh = ilog2(TCP_RTO_MAX/rto_base);
 +
 +		if (boundary <= linear_backoff_thresh)
 +			timeout = ((2 << boundary) - 1) * rto_base;
 +		else
 +			timeout = ((2 << linear_backoff_thresh) - 1) * rto_base +
 +				(boundary - linear_backoff_thresh) * TCP_RTO_MAX;
 +		timeout = jiffies_to_msecs(timeout);
 +	}
 +	return (tcp_time_stamp(tcp_sk(sk)) - start_ts) >= timeout;
  }
  
  /* A write timeout has occurred. Process the after effects. */
* Unmerged path net/ipv4/tcp_timer.c
