ASoC: soc-core: remove legacy style dai_link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: soc-core: remove legacy style dai_link (Jaroslav Kysela) [1738610]
Rebuild_FUZZ: 93.62%
commit-author Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
commit adb76b5b9c4740a11f6ad6c68764515961ae8ade
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/adb76b5b.failed

All drivers switched to modern style dai_link
(= struct snd_soc_dai_link_component).
Let's remove legacy style dai_link.

	Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit adb76b5b9c4740a11f6ad6c68764515961ae8ade)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/soc.h
#	sound/soc/soc-core.c
diff --cc include/sound/soc.h
index 8387b011d9c9,055e6d035e04..000000000000
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@@ -925,20 -912,9 +912,13 @@@ struct snd_soc_dai_link 
  	 * omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node
  	 * only, which only works well when that device exposes a single DAI.
  	 */
++<<<<<<< HEAD
 +	const char *cpu_dai_name;
++=======
+ 	struct snd_soc_dai_link_component *cpus;
+ 	unsigned int num_cpus;
++>>>>>>> adb76b5b9c47 (ASoC: soc-core: remove legacy style dai_link)
  
- 	/*
- 	 *	codec_name
- 	 *	codec_of_node
- 	 *	codec_dai_name
- 	 *
- 	 * These are legacy style, it will be converted to modern style
- 	 * (= snd_soc_dai_link_component) automatically in soc-core
- 	 * if driver is using legacy style.
- 	 * Driver shouldn't use both legacy and modern style in the same time.
- 	 * If modern style was supported for CPU, all driver will switch
- 	 * to use it, and, legacy style code will be removed from ALSA SoC.
- 	 */
  	/*
  	 * You MUST specify the link's codec, either by device name, or by
  	 * DT/OF node, but not both.
@@@ -1030,12 -989,6 +993,15 @@@
  	/* Do not create a PCM for this DAI link (Backend link) */
  	unsigned int ignore:1;
  
++<<<<<<< HEAD
 +	/*
 +	 * This driver uses legacy platform naming. Set by the core, machine
 +	 * drivers should not modify this value.
 +	 */
 +	unsigned int legacy_platform:1;
 +
++=======
++>>>>>>> adb76b5b9c47 (ASoC: soc-core: remove legacy style dai_link)
  	struct list_head list; /* DAI link list of the soc card */
  	struct snd_soc_dobj dobj; /* For topology */
  };
diff --cc sound/soc/soc-core.c
index 49d2af2ba06a,f8426c8120b2..000000000000
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@@ -1054,117 -1053,18 +1054,128 @@@ static void soc_remove_dai_links(struc
  	}
  }
  
++<<<<<<< HEAD
 +static int snd_soc_init_platform(struct snd_soc_card *card,
 +				 struct snd_soc_dai_link *dai_link)
 +{
 +	struct snd_soc_dai_link_component *platform = dai_link->platforms;
 +
 +	/*
 +	 * REMOVE ME
 +	 *
 +	 * This is glue code for Legacy vs Modern dai_link.
 +	 * This function will be removed if all derivers are switched to
 +	 * modern style dai_link.
 +	 * Driver shouldn't use both legacy and modern style in the same time.
 +	 * see
 +	 *	soc.h :: struct snd_soc_dai_link
 +	 */
 +	/* convert Legacy platform link */
 +	if (!platform) {
 +		platform = devm_kzalloc(card->dev,
 +				sizeof(struct snd_soc_dai_link_component),
 +				GFP_KERNEL);
 +		if (!platform)
 +			return -ENOMEM;
 +
 +		dai_link->platforms	  = platform;
 +		dai_link->num_platforms	  = 1;
 +		dai_link->legacy_platform = 1;
 +		platform->name		  = dai_link->platform_name;
 +		platform->of_node	  = dai_link->platform_of_node;
 +		platform->dai_name	  = NULL;
 +	}
 +
 +	/* if there's no platform we match on the empty platform */
 +	if (!platform->name &&
 +	    !platform->of_node)
 +		platform->name = "snd-soc-dummy";
 +
 +	return 0;
 +}
 +
 +static void soc_cleanup_platform(struct snd_soc_card *card)
 +{
 +	struct snd_soc_dai_link *link;
 +	int i;
 +	/*
 +	 * FIXME
 +	 *
 +	 * this function should be removed with snd_soc_init_platform
 +	 */
 +
 +	for_each_card_prelinks(card, i, link) {
 +		if (link->legacy_platform) {
 +			link->legacy_platform = 0;
 +			link->platforms       = NULL;
 +		}
 +	}
 +}
 +
 +static int snd_soc_init_multicodec(struct snd_soc_card *card,
 +				   struct snd_soc_dai_link *dai_link)
 +{
 +	/*
 +	 * REMOVE ME
 +	 *
 +	 * This is glue code for Legacy vs Modern dai_link.
 +	 * This function will be removed if all derivers are switched to
 +	 * modern style dai_link.
 +	 * Driver shouldn't use both legacy and modern style in the same time.
 +	 * see
 +	 *	soc.h :: struct snd_soc_dai_link
 +	 */
 +
 +	/* Legacy codec/codec_dai link is a single entry in multicodec */
 +	if (dai_link->codec_name || dai_link->codec_of_node ||
 +	    dai_link->codec_dai_name) {
 +		dai_link->num_codecs = 1;
 +
 +		dai_link->codecs = devm_kzalloc(card->dev,
 +				sizeof(struct snd_soc_dai_link_component),
 +				GFP_KERNEL);
 +		if (!dai_link->codecs)
 +			return -ENOMEM;
 +
 +		dai_link->codecs[0].name = dai_link->codec_name;
 +		dai_link->codecs[0].of_node = dai_link->codec_of_node;
 +		dai_link->codecs[0].dai_name = dai_link->codec_dai_name;
 +	}
 +
 +	if (!dai_link->codecs) {
 +		dev_err(card->dev, "ASoC: DAI link has no CODECs\n");
 +		return -EINVAL;
 +	}
 +
 +	return 0;
 +}
++=======
+ static struct snd_soc_dai_link_component dummy_link = COMP_DUMMY();
++>>>>>>> adb76b5b9c47 (ASoC: soc-core: remove legacy style dai_link)
  
  static int soc_init_dai_link(struct snd_soc_card *card,
  			     struct snd_soc_dai_link *link)
  {
- 	int i, ret;
+ 	int i;
  	struct snd_soc_dai_link_component *codec;
  
++<<<<<<< HEAD
 +	ret = snd_soc_init_platform(card, link);
 +	if (ret) {
 +		dev_err(card->dev, "ASoC: failed to init multiplatform\n");
 +		return ret;
 +	}
 +
 +	ret = snd_soc_init_multicodec(card, link);
 +	if (ret) {
 +		dev_err(card->dev, "ASoC: failed to init multicodec\n");
 +		return ret;
++=======
+ 	/* default Platform */
+ 	if (!link->platforms || !link->num_platforms) {
+ 		link->platforms = &dummy_link;
+ 		link->num_platforms = 1;
++>>>>>>> adb76b5b9c47 (ASoC: soc-core: remove legacy style dai_link)
  	}
  
  	for_each_link_codecs(link, i, codec) {
@@@ -2054,7 -1962,6 +2065,10 @@@ static int soc_cleanup_card_resources(s
  	/* remove and free each DAI */
  	soc_remove_dai_links(card);
  	soc_remove_pcm_runtimes(card);
++<<<<<<< HEAD
 +	soc_cleanup_platform(card);
++=======
++>>>>>>> adb76b5b9c47 (ASoC: soc-core: remove legacy style dai_link)
  
  	/* remove auxiliary devices */
  	soc_remove_aux_devices(card);
@@@ -2814,6 -2710,22 +2828,22 @@@ int snd_soc_register_card(struct snd_so
  	if (!card->name || !card->dev)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&client_mutex);
+ 	for_each_card_prelinks(card, i, link) {
+ 
+ 		ret = soc_init_dai_link(card, link);
+ 		if (ret) {
+ 			dev_err(card->dev, "ASoC: failed to init link %s\n",
+ 				link->name);
+ 			mutex_unlock(&client_mutex);
+ 			return ret;
+ 		}
+ 	}
+ 	mutex_unlock(&client_mutex);
+ 
++>>>>>>> adb76b5b9c47 (ASoC: soc-core: remove legacy style dai_link)
  	dev_set_drvdata(card->dev, card);
  
  	snd_soc_initialize_card_lists(card);
* Unmerged path include/sound/soc.h
* Unmerged path sound/soc/soc-core.c
