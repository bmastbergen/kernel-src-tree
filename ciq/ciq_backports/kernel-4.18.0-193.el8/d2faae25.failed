net/mlx5e: Protect mod_hdr hash table with mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Protect mod_hdr hash table with mutex (Alaa Hleihel) [1663231 1724336]
Rebuild_FUZZ: 95.65%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit d2faae25c3050a87c8ff965a7939e999e3154b62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d2faae25.failed

To remove dependency on rtnl lock, protect mod_hdr hash table from
concurrent modifications with new mutex.

Implement helper function to get flow namespace to prevent code
duplication.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d2faae25c3050a87c8ff965a7939e999e3154b62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	include/linux/mlx5/fs.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c033e0d4fc59,0600b7878600..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -200,15 -289,61 +200,68 @@@ static inline int cmp_mod_hdr_info(stru
  	return memcmp(a->actions, b->actions, a->num_actions * MLX5_MH_ACT_SZ);
  }
  
++<<<<<<< HEAD
++=======
+ static struct mod_hdr_tbl *
+ get_mod_hdr_table(struct mlx5e_priv *priv, int namespace)
+ {
+ 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 
+ 	return namespace == MLX5_FLOW_NAMESPACE_FDB ? &esw->offloads.mod_hdr :
+ 		&priv->fs.tc.mod_hdr;
+ }
+ 
+ static struct mlx5e_mod_hdr_entry *
+ mlx5e_mod_hdr_get(struct mod_hdr_tbl *tbl, struct mod_hdr_key *key, u32 hash_key)
+ {
+ 	struct mlx5e_mod_hdr_entry *mh, *found = NULL;
+ 
+ 	hash_for_each_possible(tbl->hlist, mh, mod_hdr_hlist, hash_key) {
+ 		if (!cmp_mod_hdr_info(&mh->key, key)) {
+ 			refcount_inc(&mh->refcnt);
+ 			found = mh;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return found;
+ }
+ 
+ static void mlx5e_mod_hdr_put(struct mlx5e_priv *priv,
+ 			      struct mlx5e_mod_hdr_entry *mh,
+ 			      int namespace)
+ {
+ 	struct mod_hdr_tbl *tbl = get_mod_hdr_table(priv, namespace);
+ 
+ 	if (!refcount_dec_and_mutex_lock(&mh->refcnt, &tbl->lock))
+ 		return;
+ 	hash_del(&mh->mod_hdr_hlist);
+ 	mutex_unlock(&tbl->lock);
+ 
+ 	WARN_ON(!list_empty(&mh->flows));
+ 	mlx5_modify_header_dealloc(priv->mdev, mh->mod_hdr_id);
+ 
+ 	kfree(mh);
+ }
+ 
+ static int get_flow_name_space(struct mlx5e_tc_flow *flow)
+ {
+ 	return mlx5e_is_eswitch_flow(flow) ?
+ 		MLX5_FLOW_NAMESPACE_FDB : MLX5_FLOW_NAMESPACE_KERNEL;
+ }
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  static int mlx5e_attach_mod_hdr(struct mlx5e_priv *priv,
  				struct mlx5e_tc_flow *flow,
  				struct mlx5e_tc_flow_parse_attr *parse_attr)
  {
++<<<<<<< HEAD
 +	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++=======
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  	int num_actions, actions_size, namespace, err;
  	struct mlx5e_mod_hdr_entry *mh;
 -	struct mod_hdr_tbl *tbl;
  	struct mod_hdr_key key;
 +	bool found = false;
  	u32 hash_key;
  
  	num_actions  = parse_attr->num_mod_hdr_actions;
@@@ -219,27 -354,12 +272,36 @@@
  
  	hash_key = hash_mod_hdr_info(&key);
  
++<<<<<<< HEAD
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH) {
 +		namespace = MLX5_FLOW_NAMESPACE_FDB;
 +		hash_for_each_possible(esw->offloads.mod_hdr_tbl, mh,
 +				       mod_hdr_hlist, hash_key) {
 +			if (!cmp_mod_hdr_info(&mh->key, &key)) {
 +				found = true;
 +				break;
 +			}
 +		}
 +	} else {
 +		namespace = MLX5_FLOW_NAMESPACE_KERNEL;
 +		hash_for_each_possible(priv->fs.tc.mod_hdr_tbl, mh,
 +				       mod_hdr_hlist, hash_key) {
 +			if (!cmp_mod_hdr_info(&mh->key, &key)) {
 +				found = true;
 +				break;
 +			}
 +		}
 +	}
 +
 +	if (found)
++=======
+ 	namespace = get_flow_name_space(flow);
+ 	tbl = get_mod_hdr_table(priv, namespace);
+ 
+ 	mutex_lock(&tbl->lock);
+ 	mh = mlx5e_mod_hdr_get(tbl, &key, hash_key);
+ 	if (mh)
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  		goto attach_flow;
  
  	mh = kzalloc(sizeof(*mh) + actions_size, GFP_KERNEL);
@@@ -258,14 -382,15 +322,23 @@@
  	if (err)
  		goto out_err;
  
 -	hash_add(tbl->hlist, &mh->mod_hdr_hlist, hash_key);
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH)
 +		hash_add(esw->offloads.mod_hdr_tbl, &mh->mod_hdr_hlist, hash_key);
 +	else
 +		hash_add(priv->fs.tc.mod_hdr_tbl, &mh->mod_hdr_hlist, hash_key);
  
  attach_flow:
++<<<<<<< HEAD
 +	list_add(&flow->mod_hdr, &mh->flows);
 +	if (flow->flags & MLX5E_TC_FLOW_ESWITCH)
++=======
+ 	mutex_unlock(&tbl->lock);
+ 	flow->mh = mh;
+ 	spin_lock(&mh->flows_lock);
+ 	list_add(&flow->mod_hdr, &mh->flows);
+ 	spin_unlock(&mh->flows_lock);
+ 	if (mlx5e_is_eswitch_flow(flow))
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  		flow->esw_attr->mod_hdr_id = mh->mod_hdr_id;
  	else
  		flow->nic_attr->mod_hdr_id = mh->mod_hdr_id;
@@@ -280,19 -406,16 +354,24 @@@ out_err
  static void mlx5e_detach_mod_hdr(struct mlx5e_priv *priv,
  				 struct mlx5e_tc_flow *flow)
  {
 -	/* flow wasn't fully initialized */
 -	if (!flow->mh)
 -		return;
 +	struct list_head *next = flow->mod_hdr.next;
  
 -	spin_lock(&flow->mh->flows_lock);
  	list_del(&flow->mod_hdr);
 -	spin_unlock(&flow->mh->flows_lock);
  
++<<<<<<< HEAD
 +	if (list_empty(next)) {
 +		struct mlx5e_mod_hdr_entry *mh;
 +
 +		mh = list_entry(next, struct mlx5e_mod_hdr_entry, flows);
 +
 +		mlx5_modify_header_dealloc(priv->mdev, mh->mod_hdr_id);
 +		hash_del(&mh->mod_hdr_hlist);
 +		kfree(mh);
 +	}
++=======
+ 	mlx5e_mod_hdr_put(priv, flow->mh, get_flow_name_space(flow));
+ 	flow->mh = NULL;
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  }
  
  static
@@@ -3460,7 -3877,10 +3539,14 @@@ int mlx5e_tc_nic_init(struct mlx5e_pri
  	struct mlx5e_tc_table *tc = &priv->fs.tc;
  	int err;
  
++<<<<<<< HEAD
 +	hash_init(tc->mod_hdr_tbl);
++=======
+ 	mutex_init(&tc->t_lock);
+ 	mutex_init(&tc->mod_hdr.lock);
+ 	hash_init(tc->mod_hdr.hlist);
+ 	mutex_init(&tc->hairpin_tbl_lock);
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  	hash_init(tc->hairpin_tbl);
  
  	err = rhashtable_init(&tc->ht, &tc_ht_params);
@@@ -3492,6 -3912,9 +3578,12 @@@ void mlx5e_tc_nic_cleanup(struct mlx5e_
  	if (tc->netdevice_nb.notifier_call)
  		unregister_netdevice_notifier(&tc->netdevice_nb);
  
++<<<<<<< HEAD
++=======
+ 	mutex_destroy(&tc->mod_hdr.lock);
+ 	mutex_destroy(&tc->hairpin_tbl_lock);
+ 
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  	rhashtable_destroy(&tc->ht);
  
  	if (!IS_ERR_OR_NULL(tc->t)) {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index be195cce77a4,2d734ecae719..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1868,13 -2000,13 +1868,19 @@@ int mlx5_eswitch_init(struct mlx5_core_
  		goto abort;
  
  	hash_init(esw->offloads.encap_tbl);
++<<<<<<< HEAD
 +	hash_init(esw->offloads.mod_hdr_tbl);
++=======
+ 	mutex_init(&esw->offloads.mod_hdr.lock);
+ 	hash_init(esw->offloads.mod_hdr.hlist);
+ 	atomic64_set(&esw->offloads.num_flows, 0);
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  	mutex_init(&esw->state_lock);
  
 -	mlx5_esw_for_all_vports(esw, i, vport) {
 -		vport->vport = mlx5_eswitch_index_to_vport_num(esw, i);
 +	for (vport_num = 0; vport_num < total_vports; vport_num++) {
 +		struct mlx5_vport *vport = &esw->vports[vport_num];
 +
 +		vport->vport = vport_num;
  		vport->info.link_state = MLX5_VPORT_ADMIN_STATE_AUTO;
  		vport->dev = dev;
  		INIT_WORK(&vport->vport_change_handler,
diff --cc include/linux/mlx5/fs.h
index 8f2806f456c6,1cb1045ce313..000000000000
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@@ -126,6 -126,11 +126,14 @@@ struct mlx5_flow_destination 
  	};
  };
  
++<<<<<<< HEAD
++=======
+ struct mod_hdr_tbl {
+ 	struct mutex lock; /* protects hlist */
+ 	DECLARE_HASHTABLE(hlist, 8);
+ };
+ 
++>>>>>>> d2faae25c305 (net/mlx5e: Protect mod_hdr hash table with mutex)
  struct mlx5_flow_namespace *
  mlx5_get_fdb_sub_ns(struct mlx5_core_dev *dev, int n);
  struct mlx5_flow_namespace *
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path include/linux/mlx5/fs.h
