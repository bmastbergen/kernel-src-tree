mm/memory_hotplug: cleanup __remove_pages()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] memory_hotplug: cleanup __remove_pages() (Christoph von Recklinghausen) [1766491]
Rebuild_FUZZ: 96.39%
commit-author David Hildenbrand <david@redhat.com>
commit 52fb87c81f11daa7027af25fc24ac7974eb8f45a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/52fb87c8.failed

Let's drop the basically unused section stuff and simplify.

Also, let's use a shorter variant to calculate the number of pages to
the next section boundary.

Link: http://lkml.kernel.org/r/20191006085646.5768-11-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
	Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.ibm.com>
	Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: Pankaj Gupta <pagupta@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 52fb87c81f11daa7027af25fc24ac7974eb8f45a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index 78199d99535f,4344e85213f2..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -493,41 -513,26 +493,55 @@@ static void __remove_section(struct zon
   * sure that pages are marked reserved and zones are adjust properly by
   * calling offline_pages().
   */
 -void __remove_pages(unsigned long pfn, unsigned long nr_pages,
 -		    struct vmem_altmap *altmap)
 +int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,
 +		 unsigned long nr_pages, struct vmem_altmap *altmap)
  {
++<<<<<<< HEAD
 +	unsigned long i;
 +	unsigned long map_offset = 0;
 +	int sections_to_remove;
++=======
+ 	const unsigned long end_pfn = pfn + nr_pages;
+ 	unsigned long cur_nr_pages;
+ 	unsigned long map_offset = 0;
++>>>>>>> 52fb87c81f11 (mm/memory_hotplug: cleanup __remove_pages())
  
 -	map_offset = vmem_altmap_offset(altmap);
 +	/* In the ZONE_DEVICE case device driver owns the memory region */
 +	if (is_dev_zone(zone)) {
 +		if (altmap)
 +			map_offset = vmem_altmap_offset(altmap);
 +	}
  
 -	if (check_pfn_span(pfn, nr_pages, "remove"))
 -		return;
 +	clear_zone_contiguous(zone);
  
++<<<<<<< HEAD
 +	/*
 +	 * We can only remove entire sections
 +	 */
 +	BUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);
 +	BUG_ON(nr_pages % PAGES_PER_SECTION);
 +
 +	sections_to_remove = nr_pages / PAGES_PER_SECTION;
 +	for (i = 0; i < sections_to_remove; i++) {
 +		unsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;
 +
 +		cond_resched();
 +		__remove_section(zone, __pfn_to_section(pfn), map_offset,
 +				 altmap);
++=======
+ 	for (; pfn < end_pfn; pfn += cur_nr_pages) {
+ 		cond_resched();
+ 		/* Select all remaining pages up to the next section boundary */
+ 		cur_nr_pages = min(end_pfn - pfn, -(pfn | PAGE_SECTION_MASK));
+ 		__remove_section(pfn, cur_nr_pages, map_offset, altmap);
++>>>>>>> 52fb87c81f11 (mm/memory_hotplug: cleanup __remove_pages())
  		map_offset = 0;
  	}
 +
 +	set_zone_contiguous(zone);
 +	return 0;
  }
 +#endif /* CONFIG_MEMORY_HOTREMOVE */
  
  int set_online_page_callback(online_page_callback_t callback)
  {
* Unmerged path mm/memory_hotplug.c
