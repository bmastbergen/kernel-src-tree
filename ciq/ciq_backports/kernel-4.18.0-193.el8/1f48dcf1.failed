Drivers: hv: vmbus: Clean up hv_sock channels by force upon suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [hv] hv: vmbus: Clean up hv_sock channels by force upon suspend (Mohammed Gamal) [1774675]
Rebuild_FUZZ: 92.80%
commit-author Dexuan Cui <decui@microsoft.com>
commit 1f48dcf180e5422b1a633b24680dd0f5c3f540f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/1f48dcf1.failed

Fake RESCIND_CHANNEL messages to clean up hv_sock channels by force for
hibernation. There is no better method to clean up the channels since
some of the channels may still be referenced by the userspace apps when
hibernation is triggered: in this case, with this patch, the "rescind"
fields of the channels are set, and the apps will thoroughly destroy
the channels after hibernation.

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Sasha Levin <sashal@kernel.org>
(cherry picked from commit 1f48dcf180e5422b1a633b24680dd0f5c3f540f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index f6112615450a,45b976ec6e79..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -2046,6 -2125,70 +2082,73 @@@ acpi_walk_err
  	return ret_val;
  }
  
++<<<<<<< HEAD
++=======
+ static int vmbus_bus_suspend(struct device *dev)
+ {
+ 	struct vmbus_channel *channel;
+ 
+ 	while (atomic_read(&vmbus_connection.offer_in_progress) != 0) {
+ 		/*
+ 		 * We wait here until the completion of any channel
+ 		 * offers that are currently in progress.
+ 		 */
+ 		msleep(1);
+ 	}
+ 
+ 	mutex_lock(&vmbus_connection.channel_mutex);
+ 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
+ 		if (!is_hvsock_channel(channel))
+ 			continue;
+ 
+ 		vmbus_force_channel_rescinded(channel);
+ 	}
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 	vmbus_initiate_unload(false);
+ 
+ 	vmbus_connection.conn_state = DISCONNECTED;
+ 
+ 	return 0;
+ }
+ 
+ static int vmbus_bus_resume(struct device *dev)
+ {
+ 	struct vmbus_channel_msginfo *msginfo;
+ 	size_t msgsize;
+ 	int ret;
+ 
+ 	/*
+ 	 * We only use the 'vmbus_proto_version', which was in use before
+ 	 * hibernation, to re-negotiate with the host.
+ 	 */
+ 	if (vmbus_proto_version == VERSION_INVAL ||
+ 	    vmbus_proto_version == 0) {
+ 		pr_err("Invalid proto version = 0x%x\n", vmbus_proto_version);
+ 		return -EINVAL;
+ 	}
+ 
+ 	msgsize = sizeof(*msginfo) +
+ 		  sizeof(struct vmbus_channel_initiate_contact);
+ 
+ 	msginfo = kzalloc(msgsize, GFP_KERNEL);
+ 
+ 	if (msginfo == NULL)
+ 		return -ENOMEM;
+ 
+ 	ret = vmbus_negotiate_version(msginfo, vmbus_proto_version);
+ 
+ 	kfree(msginfo);
+ 
+ 	if (ret != 0)
+ 		return ret;
+ 
+ 	vmbus_request_offers();
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 1f48dcf180e5 (Drivers: hv: vmbus: Clean up hv_sock channels by force upon suspend)
  static const struct acpi_device_id vmbus_acpi_device_ids[] = {
  	{"VMBUS", 0},
  	{"VMBus", 0},
* Unmerged path drivers/hv/vmbus_drv.c
