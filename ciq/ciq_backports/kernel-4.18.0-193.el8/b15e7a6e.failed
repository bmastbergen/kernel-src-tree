net: sched: don't take rtnl lock during flow_action setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] sched: don't take rtnl lock during flow_action setup (Marcelo Leitner) [1804385]
Rebuild_FUZZ: 95.41%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit b15e7a6e8d31d6abe2d98929d60ad3a0e6ae4de1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b15e7a6e.failed

Refactor tc_setup_flow_action() function not to use rtnl lock and remove
'rtnl_held' argument that is no longer needed.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b15e7a6e8d31d6abe2d98929d60ad3a0e6ae4de1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	net/sched/cls_api.c
#	net/sched/cls_flower.c
diff --cc include/net/pkt_cls.h
index 835bbad70a4b,53946b509b51..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -608,29 -510,27 +608,34 @@@ tcf_match_indev(struct sk_buff *skb, in
  
  int tc_setup_flow_action(struct flow_action *flow_action,
  			 const struct tcf_exts *exts);
++<<<<<<< HEAD
++=======
+ void tc_cleanup_flow_action(struct flow_action *flow_action);
+ 
++>>>>>>> b15e7a6e8d31 (net: sched: don't take rtnl lock during flow_action setup)
  int tc_setup_cb_call(struct tcf_block *block, enum tc_setup_type type,
 -		     void *type_data, bool err_stop, bool rtnl_held);
 -int tc_setup_cb_add(struct tcf_block *block, struct tcf_proto *tp,
 -		    enum tc_setup_type type, void *type_data, bool err_stop,
 -		    u32 *flags, unsigned int *in_hw_count, bool rtnl_held);
 -int tc_setup_cb_replace(struct tcf_block *block, struct tcf_proto *tp,
 -			enum tc_setup_type type, void *type_data, bool err_stop,
 -			u32 *old_flags, unsigned int *old_in_hw_count,
 -			u32 *new_flags, unsigned int *new_in_hw_count,
 -			bool rtnl_held);
 -int tc_setup_cb_destroy(struct tcf_block *block, struct tcf_proto *tp,
 -			enum tc_setup_type type, void *type_data, bool err_stop,
 -			u32 *flags, unsigned int *in_hw_count, bool rtnl_held);
 -int tc_setup_cb_reoffload(struct tcf_block *block, struct tcf_proto *tp,
 -			  bool add, flow_setup_cb_t *cb,
 -			  enum tc_setup_type type, void *type_data,
 -			  void *cb_priv, u32 *flags, unsigned int *in_hw_count);
 +		     void *type_data, bool err_stop);
  unsigned int tcf_exts_num_actions(struct tcf_exts *exts);
  
 +enum tc_block_command {
 +	TC_BLOCK_BIND,
 +	TC_BLOCK_UNBIND,
 +};
 +
 +struct tc_block_offload {
 +	enum tc_block_command command;
 +	enum tcf_block_binder_type binder_type;
 +	struct tcf_block *block;
 +	struct netlink_ext_ack *extack;
 +};
 +
 +struct tc_cls_common_offload {
 +	u32 chain_index;
 +	__be16 protocol;
 +	u32 prio;
 +	struct netlink_ext_ack *extack;
 +};
 +
  struct tc_cls_u32_knode {
  	struct tcf_exts *exts;
  	struct tcf_result *res;
diff --cc net/sched/cls_api.c
index e26b73488898,13c33eaf1ca1..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -3385,9 -3572,15 +3385,19 @@@ int tc_setup_flow_action(struct flow_ac
  		if (!is_tcf_pedit(act))
  			j++;
  	}
 -
 +	return 0;
  err_out:
++<<<<<<< HEAD
 +	return -EOPNOTSUPP;
++=======
+ 	if (err)
+ 		tc_cleanup_flow_action(flow_action);
+ 
+ 	return err;
+ err_out_locked:
+ 	spin_unlock_bh(&act->tcfa_lock);
+ 	goto err_out;
++>>>>>>> b15e7a6e8d31 (net: sched: don't take rtnl lock during flow_action setup)
  }
  EXPORT_SYMBOL(tc_setup_flow_action);
  
diff --cc net/sched/cls_flower.c
index d92186eb7b26,726fc9c5910f..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -1618,65 -1936,95 +1618,75 @@@ static void fl_walk(struct tcf_proto *t
  			arg->stop = 1;
  			break;
  		}
 -		__fl_put(f);
 +		arg->cookie = (unsigned long)f->handle + 1;
  		arg->count++;
  	}
 -	arg->cookie = id;
 -}
 -
 -static struct cls_fl_filter *
 -fl_get_next_hw_filter(struct tcf_proto *tp, struct cls_fl_filter *f, bool add)
 -{
 -	struct cls_fl_head *head = fl_head_dereference(tp);
 -
 -	spin_lock(&tp->lock);
 -	if (list_empty(&head->hw_filters)) {
 -		spin_unlock(&tp->lock);
 -		return NULL;
 -	}
 -
 -	if (!f)
 -		f = list_entry(&head->hw_filters, struct cls_fl_filter,
 -			       hw_list);
 -	list_for_each_entry_continue(f, &head->hw_filters, hw_list) {
 -		if (!(add && f->deleted) && refcount_inc_not_zero(&f->refcnt)) {
 -			spin_unlock(&tp->lock);
 -			return f;
 -		}
 -	}
 -
 -	spin_unlock(&tp->lock);
 -	return NULL;
  }
  
 -static int fl_reoffload(struct tcf_proto *tp, bool add, flow_setup_cb_t *cb,
 +static int fl_reoffload(struct tcf_proto *tp, bool add, tc_setup_cb_t *cb,
  			void *cb_priv, struct netlink_ext_ack *extack)
  {
 +	struct cls_fl_head *head = fl_head_dereference(tp);
 +	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
 -	struct flow_cls_offload cls_flower = {};
 -	struct cls_fl_filter *f = NULL;
 +	struct fl_flow_mask *mask;
 +	struct cls_fl_filter *f;
  	int err;
  
 -	/* hw_filters list can only be changed by hw offload functions after
 -	 * obtaining rtnl lock. Make sure it is not changed while reoffload is
 -	 * iterating it.
 -	 */
 -	ASSERT_RTNL();
 -
 -	while ((f = fl_get_next_hw_filter(tp, f, add))) {
 -		cls_flower.rule =
 -			flow_rule_alloc(tcf_exts_num_actions(&f->exts));
 -		if (!cls_flower.rule) {
 -			__fl_put(f);
 -			return -ENOMEM;
 -		}
 -
 -		tc_cls_common_offload_init(&cls_flower.common, tp, f->flags,
 -					   extack);
 -		cls_flower.command = add ?
 -			FLOW_CLS_REPLACE : FLOW_CLS_DESTROY;
 -		cls_flower.cookie = (unsigned long)f;
 -		cls_flower.rule->match.dissector = &f->mask->dissector;
 -		cls_flower.rule->match.mask = &f->mask->key;
 -		cls_flower.rule->match.key = &f->mkey;
 -
 +	list_for_each_entry(mask, &head->masks, list) {
 +		list_for_each_entry(f, &mask->filters, list) {
 +			if (tc_skip_hw(f->flags))
 +				continue;
 +
 +			cls_flower.rule =
 +				flow_rule_alloc(tcf_exts_num_actions(&f->exts));
 +			if (!cls_flower.rule)
 +				return -ENOMEM;
 +
 +			tc_cls_common_offload_init(&cls_flower.common, tp,
 +						   f->flags, extack);
 +			cls_flower.command = add ?
 +				TC_CLSFLOWER_REPLACE : TC_CLSFLOWER_DESTROY;
 +			cls_flower.cookie = (unsigned long)f;
 +			cls_flower.rule->match.dissector = &mask->dissector;
 +			cls_flower.rule->match.mask = &mask->key;
 +			cls_flower.rule->match.key = &f->mkey;
 +
++<<<<<<< HEAD
 +			err = tc_setup_flow_action(&cls_flower.rule->action,
 +						   &f->exts);
 +			if (err) {
 +				kfree(cls_flower.rule);
 +				if (tc_skip_sw(f->flags)) {
 +					NL_SET_ERR_MSG_MOD(extack, "Failed to setup flow action");
 +					return err;
 +				}
 +				continue;
++=======
+ 		err = tc_setup_flow_action(&cls_flower.rule->action, &f->exts);
+ 		if (err) {
+ 			kfree(cls_flower.rule);
+ 			if (tc_skip_sw(f->flags)) {
+ 				NL_SET_ERR_MSG_MOD(extack, "Failed to setup flow action");
+ 				__fl_put(f);
+ 				return err;
++>>>>>>> b15e7a6e8d31 (net: sched: don't take rtnl lock during flow_action setup)
  			}
 -			goto next_flow;
 -		}
  
 -		cls_flower.classid = f->res.classid;
 +			cls_flower.classid = f->res.classid;
  
 -		err = tc_setup_cb_reoffload(block, tp, add, cb,
 -					    TC_SETUP_CLSFLOWER, &cls_flower,
 -					    cb_priv, &f->flags,
 -					    &f->in_hw_count);
 -		tc_cleanup_flow_action(&cls_flower.rule->action);
 -		kfree(cls_flower.rule);
 +			err = cb(TC_SETUP_CLSFLOWER, &cls_flower, cb_priv);
 +			kfree(cls_flower.rule);
  
 -		if (err) {
 -			__fl_put(f);
 -			return err;
 +			if (err) {
 +				if (add && tc_skip_sw(f->flags))
 +					return err;
 +				continue;
 +			}
 +
 +			tc_cls_offload_cnt_update(block, &f->in_hw_count,
 +						  &f->flags, add);
  		}
 -next_flow:
 -		__fl_put(f);
  	}
  
  	return 0;
* Unmerged path include/net/pkt_cls.h
* Unmerged path net/sched/cls_api.c
* Unmerged path net/sched/cls_flower.c
