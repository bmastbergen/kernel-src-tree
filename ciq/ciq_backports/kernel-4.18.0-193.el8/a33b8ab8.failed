mt76: move tx tasklet to struct mt76_dev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Felix Fietkau <nbd@nbd.name>
commit a33b8ab868ad774dfb66e750ebd158887ff8d337
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a33b8ab8.failed

Allows it to be scheduled from core code

	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit a33b8ab868ad774dfb66e750ebd158887ff8d337)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt76.h
#	drivers/net/wireless/mediatek/mt76/mt76x0/usb.c
#	drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
#	drivers/net/wireless/mediatek/mt76/mt76x2/usb.c
#	drivers/net/wireless/mediatek/mt76/usb.c
diff --cc drivers/net/wireless/mediatek/mt76/mt76.h
index 1c8ddf9c225d,c35305ad2d12..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@@ -453,8 -448,6 +453,11 @@@ struct mt76_dev 
  	int tx_dma_idx[4];
  
  	struct tasklet_struct tx_tasklet;
++<<<<<<< HEAD
 +	struct napi_struct tx_napi;
 +	struct delayed_work mac_work;
++=======
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  
  	wait_queue_head_t tx_wait;
  	struct sk_buff_head status_list;
diff --cc drivers/net/wireless/mediatek/mt76/mt76x0/usb.c
index 645f4d15fb61,db2c3c6c2c66..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x0/usb.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x0/usb.c
@@@ -309,7 -331,10 +309,14 @@@ static int __maybe_unused mt76x0_resume
  	if (ret < 0)
  		goto err;
  
++<<<<<<< HEAD
 +	ret = mt76x0u_init_hardware(dev, false);
++=======
+ 	tasklet_enable(&usb->rx_tasklet);
+ 	tasklet_enable(&dev->mt76.tx_tasklet);
+ 
+ 	ret = mt76x0u_init_hardware(dev);
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  	if (ret)
  		goto err;
  
diff --cc drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
index 617934565818,958b2a3e4878..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
@@@ -202,10 -182,9 +202,14 @@@ int mt76x02_dma_init(struct mt76x02_de
  
  	tasklet_init(&dev->mt76.tx_tasklet, mt76x02_tx_tasklet,
  		     (unsigned long) dev);
++<<<<<<< HEAD
 +	tasklet_init(&dev->mt76.pre_tbtt_tasklet, mt76x02_pre_tbtt_tasklet,
++=======
+ 	tasklet_init(&dev->pre_tbtt_tasklet, mt76x02_pre_tbtt_tasklet,
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  		     (unsigned long)dev);
  
 +	spin_lock_init(&dev->txstatus_fifo_lock);
  	kfifo_init(&dev->txstatus_fifo, status_fifo, fifo_size);
  
  	mt76_dma_attach(&dev->mt76);
@@@ -278,6 -249,11 +282,14 @@@ irqreturn_t mt76x02_irq_handler(int irq
  
  	intr &= dev->mt76.mmio.irqmask;
  
++<<<<<<< HEAD
++=======
+ 	if (intr & MT_INT_TX_DONE_ALL) {
+ 		mt76x02_irq_disable(dev, MT_INT_TX_DONE_ALL);
+ 		tasklet_schedule(&dev->mt76.tx_tasklet);
+ 	}
+ 
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  	if (intr & MT_INT_RX_DONE(0)) {
  		mt76x02_irq_disable(dev, MT_INT_RX_DONE(0));
  		napi_schedule(&dev->mt76.napi[0]);
@@@ -299,12 -275,9 +311,16 @@@
  			mt76_queue_kick(dev, dev->mt76.q_tx[MT_TXQ_PSD].q);
  	}
  
 -	if (intr & MT_INT_TX_STAT) {
 +	if (intr & MT_INT_TX_STAT)
  		mt76x02_mac_poll_tx_status(dev, true);
++<<<<<<< HEAD
 +
 +	if (intr & (MT_INT_TX_STAT | MT_INT_TX_DONE_ALL)) {
 +		mt76x02_irq_disable(dev, MT_INT_TX_DONE_ALL);
 +		napi_schedule(&dev->mt76.tx_napi);
++=======
+ 		tasklet_schedule(&dev->mt76.tx_tasklet);
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  	}
  
  	if (intr & MT_INT_GPTIMER) {
@@@ -335,7 -308,6 +351,10 @@@ static void mt76x02_dma_enable(struct m
  void mt76x02_dma_cleanup(struct mt76x02_dev *dev)
  {
  	tasklet_kill(&dev->mt76.tx_tasklet);
++<<<<<<< HEAD
 +	netif_napi_del(&dev->mt76.tx_napi);
++=======
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  	mt76_dma_cleanup(&dev->mt76);
  }
  EXPORT_SYMBOL_GPL(mt76x02_dma_cleanup);
@@@ -453,9 -425,8 +472,14 @@@ static void mt76x02_watchdog_reset(stru
  	ieee80211_stop_queues(dev->mt76.hw);
  	set_bit(MT76_RESET, &dev->mt76.state);
  
++<<<<<<< HEAD
 +	tasklet_disable(&dev->mt76.pre_tbtt_tasklet);
 +	tasklet_disable(&dev->mt76.tx_tasklet);
 +	napi_disable(&dev->mt76.tx_napi);
++=======
+ 	tasklet_disable(&dev->pre_tbtt_tasklet);
+ 	tasklet_disable(&dev->mt76.tx_tasklet);
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  
  	for (i = 0; i < ARRAY_SIZE(dev->mt76.napi); i++)
  		napi_disable(&dev->mt76.napi[i]);
@@@ -509,10 -480,9 +533,14 @@@
  	clear_bit(MT76_RESET, &dev->mt76.state);
  
  	tasklet_enable(&dev->mt76.tx_tasklet);
++<<<<<<< HEAD
 +	napi_enable(&dev->mt76.tx_napi);
 +	napi_schedule(&dev->mt76.tx_napi);
++=======
+ 	tasklet_schedule(&dev->mt76.tx_tasklet);
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  
 -	tasklet_enable(&dev->pre_tbtt_tasklet);
 +	tasklet_enable(&dev->mt76.pre_tbtt_tasklet);
  
  	for (i = 0; i < ARRAY_SIZE(dev->mt76.napi); i++) {
  		napi_enable(&dev->mt76.napi[i]);
diff --cc drivers/net/wireless/mediatek/mt76/mt76x2/usb.c
index 7a994a783510,d1bddd5931bd..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x2/usb.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x2/usb.c
@@@ -121,6 -123,9 +121,12 @@@ static int __maybe_unused mt76x2u_resum
  	if (err < 0)
  		goto err;
  
++<<<<<<< HEAD
++=======
+ 	tasklet_enable(&usb->rx_tasklet);
+ 	tasklet_enable(&dev->mt76.tx_tasklet);
+ 
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  	err = mt76x2u_init_hardware(dev);
  	if (err < 0)
  		goto err;
diff --cc drivers/net/wireless/mediatek/mt76/usb.c
index fb87ce7fbdf6,15aeda0582e7..000000000000
--- a/drivers/net/wireless/mediatek/mt76/usb.c
+++ b/drivers/net/wireless/mediatek/mt76/usb.c
@@@ -879,49 -828,34 +879,64 @@@ static void mt76u_free_tx(struct mt76_d
  	}
  }
  
 -static void mt76u_stop_tx(struct mt76_dev *dev)
 +void mt76u_stop_tx(struct mt76_dev *dev)
  {
 +	struct mt76_queue_entry entry;
  	struct mt76_queue *q;
 -	int i, j;
 +	int i, j, ret;
  
 -	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 -		q = dev->q_tx[i].q;
 -		for (j = 0; j < q->ndesc; j++)
 -			usb_kill_urb(q->entry[j].urb);
 +	ret = wait_event_timeout(dev->tx_wait, !mt76_has_tx_pending(dev), HZ/5);
 +	if (!ret) {
 +		dev_err(dev->dev, "timed out waiting for pending tx\n");
 +
 +		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 +			q = dev->q_tx[i].q;
 +			for (j = 0; j < q->ndesc; j++)
 +				usb_kill_urb(q->entry[j].urb);
 +		}
 +
 +		tasklet_kill(&dev->tx_tasklet);
 +
 +		/* On device removal we maight queue skb's, but mt76u_tx_kick()
 +		 * will fail to submit urb, cleanup those skb's manually.
 +		 */
 +		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 +			q = dev->q_tx[i].q;
 +
 +			/* Assure we are in sync with killed tasklet. */
 +			spin_lock_bh(&q->lock);
 +			while (q->queued) {
 +				entry = q->entry[q->head];
 +				q->head = (q->head + 1) % q->ndesc;
 +				q->queued--;
 +
 +				dev->drv->tx_complete_skb(dev, i, &entry);
 +			}
 +			spin_unlock_bh(&q->lock);
 +		}
  	}
 -}
  
++<<<<<<< HEAD
++=======
+ void mt76u_stop_queues(struct mt76_dev *dev)
+ {
+ 	tasklet_disable(&dev->usb.rx_tasklet);
+ 	tasklet_disable(&dev->tx_tasklet);
+ 
+ 	mt76u_stop_rx(dev);
+ 	mt76u_stop_tx(dev);
+ }
+ EXPORT_SYMBOL_GPL(mt76u_stop_queues);
+ 
+ void mt76u_stop_stat_wk(struct mt76_dev *dev)
+ {
++>>>>>>> a33b8ab868ad (mt76: move tx tasklet to struct mt76_dev)
  	cancel_delayed_work_sync(&dev->usb.stat_work);
  	clear_bit(MT76_READING_STATS, &dev->state);
 +
 +	mt76_tx_status_check(dev, NULL, true);
  }
 -EXPORT_SYMBOL_GPL(mt76u_stop_stat_wk);
 +EXPORT_SYMBOL_GPL(mt76u_stop_tx);
  
  void mt76u_queues_deinit(struct mt76_dev *dev)
  {
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/core.c b/drivers/net/wireless/mediatek/mt76/mt7603/core.c
index cbb948675674..642f051dabfd 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/core.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/core.c
@@ -46,7 +46,7 @@ irqreturn_t mt7603_irq_handler(int irq, void *dev_instance)
 
 	if (intr & MT_INT_TX_DONE_ALL) {
 		mt7603_irq_disable(dev, MT_INT_TX_DONE_ALL);
-		tasklet_schedule(&dev->tx_tasklet);
+		tasklet_schedule(&dev->mt76.tx_tasklet);
 	}
 
 	if (intr & MT_INT_RX_DONE(0)) {
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c
index b3ae0aaea62a..19179b84f166 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c
@@ -163,7 +163,7 @@ int mt7603_dma_init(struct mt7603_dev *dev)
 	init_waitqueue_head(&dev->mt76.mmio.mcu.wait);
 	skb_queue_head_init(&dev->mt76.mmio.mcu.res_q);
 
-	tasklet_init(&dev->tx_tasklet, mt7603_tx_tasklet, (unsigned long)dev);
+	tasklet_init(&dev->mt76.tx_tasklet, mt7603_tx_tasklet, (unsigned long)dev);
 
 	mt76_clear(dev, MT_WPDMA_GLO_CFG,
 		   MT_WPDMA_GLO_CFG_TX_DMA_EN |
@@ -223,6 +223,6 @@ void mt7603_dma_cleanup(struct mt7603_dev *dev)
 		   MT_WPDMA_GLO_CFG_RX_DMA_EN |
 		   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);
 
-	tasklet_kill(&dev->tx_tasklet);
+	tasklet_kill(&dev->mt76.tx_tasklet);
 	mt76_dma_cleanup(&dev->mt76);
 }
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
index 5388d1a6ffcf..fbdce4514b68 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
@@ -1276,7 +1276,7 @@ static void mt7603_mac_watchdog_reset(struct mt7603_dev *dev)
 	/* lock/unlock all queues to ensure that no tx is pending */
 	mt76_txq_schedule_all(&dev->mt76);
 
-	tasklet_disable(&dev->tx_tasklet);
+	tasklet_disable(&dev->mt76.tx_tasklet);
 	tasklet_disable(&dev->pre_tbtt_tasklet);
 	napi_disable(&dev->mt76.napi[0]);
 	napi_disable(&dev->mt76.napi[1]);
@@ -1323,8 +1323,8 @@ static void mt7603_mac_watchdog_reset(struct mt7603_dev *dev)
 	clear_bit(MT76_RESET, &dev->mt76.state);
 	mutex_unlock(&dev->mt76.mutex);
 
-	tasklet_enable(&dev->tx_tasklet);
-	tasklet_schedule(&dev->tx_tasklet);
+	tasklet_enable(&dev->mt76.tx_tasklet);
+	tasklet_schedule(&dev->mt76.tx_tasklet);
 
 	tasklet_enable(&dev->pre_tbtt_tasklet);
 	mt7603_beacon_set_timer(dev, -1, beacon_int);
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h b/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h
index 10ced8d17526..bb85481a6c2f 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h
@@ -145,7 +145,6 @@ struct mt7603_dev {
 	unsigned int reset_cause[__RESET_CAUSE_MAX];
 
 	struct delayed_work mac_work;
-	struct tasklet_struct tx_tasklet;
 	struct tasklet_struct pre_tbtt_tasklet;
 };
 
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x0/usb.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x2/usb.c
* Unmerged path drivers/net/wireless/mediatek/mt76/usb.c
