net/mlx5: Clear VF's configuration on disabling SRIOV

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Clear VF's configuration on disabling SRIOV (Mohammad Heib) [1776921]
Rebuild_FUZZ: 96.08%
commit-author Aya Levin <ayal@mellanox.com>
commit 556b9d16d3f53d1e72b988f37501bb7e6d3f358b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/556b9d16.failed

When setting number of VFs to 0 (disable SRIOV), clear VF's
configuration.

	Signed-off-by: Aya Levin <ayal@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 556b9d16d3f53d1e72b988f37501bb7e6d3f358b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	drivers/net/ethernet/mellanox/mlx5/core/sriov.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index db5d9cd3be4d,89a2806eceb8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1716,6 -1779,67 +1716,70 @@@ static int eswitch_vport_event(struct n
  	return NOTIFY_OK;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mlx5_esw_query_functions - Returns raw output about functions state
+  * @dev:	Pointer to device to query
+  *
+  * mlx5_esw_query_functions() allocates and returns functions changed
+  * raw output memory pointer from device on success. Otherwise returns ERR_PTR.
+  * Caller must free the memory using kvfree() when valid pointer is returned.
+  */
+ const u32 *mlx5_esw_query_functions(struct mlx5_core_dev *dev)
+ {
+ 	int outlen = MLX5_ST_SZ_BYTES(query_esw_functions_out);
+ 	u32 in[MLX5_ST_SZ_DW(query_esw_functions_in)] = {};
+ 	u32 *out;
+ 	int err;
+ 
+ 	out = kvzalloc(outlen, GFP_KERNEL);
+ 	if (!out)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	MLX5_SET(query_esw_functions_in, in, opcode,
+ 		 MLX5_CMD_OP_QUERY_ESW_FUNCTIONS);
+ 
+ 	err = mlx5_cmd_exec(dev, in, sizeof(in), out, outlen);
+ 	if (!err)
+ 		return out;
+ 
+ 	kvfree(out);
+ 	return ERR_PTR(err);
+ }
+ 
+ static void mlx5_eswitch_event_handlers_register(struct mlx5_eswitch *esw)
+ {
+ 	MLX5_NB_INIT(&esw->nb, eswitch_vport_event, NIC_VPORT_CHANGE);
+ 	mlx5_eq_notifier_register(esw->dev, &esw->nb);
+ 
+ 	if (esw->mode == MLX5_ESWITCH_OFFLOADS && mlx5_eswitch_is_funcs_handler(esw->dev)) {
+ 		MLX5_NB_INIT(&esw->esw_funcs.nb, mlx5_esw_funcs_changed_handler,
+ 			     ESW_FUNCTIONS_CHANGED);
+ 		mlx5_eq_notifier_register(esw->dev, &esw->esw_funcs.nb);
+ 	}
+ }
+ 
+ static void mlx5_eswitch_event_handlers_unregister(struct mlx5_eswitch *esw)
+ {
+ 	if (esw->mode == MLX5_ESWITCH_OFFLOADS && mlx5_eswitch_is_funcs_handler(esw->dev))
+ 		mlx5_eq_notifier_unregister(esw->dev, &esw->esw_funcs.nb);
+ 
+ 	mlx5_eq_notifier_unregister(esw->dev, &esw->nb);
+ 
+ 	flush_workqueue(esw->work_queue);
+ }
+ 
+ static void mlx5_eswitch_clear_vf_vports_info(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	mlx5_esw_for_each_vf_vport(esw, i, vport, esw->esw_funcs.num_vfs)
+ 		memset(&vport->info, 0, sizeof(vport->info));
+ }
+ 
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  /* Public E-Switch API */
  #define ESW_ALLOWED(esw) ((esw) && MLX5_ESWITCH_MANAGER((esw)->dev))
  
@@@ -1785,30 -1932,23 +1849,34 @@@ abort
  	return err;
  }
  
++<<<<<<< HEAD
 +void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw)
++=======
+ void mlx5_eswitch_disable(struct mlx5_eswitch *esw, bool clear_vf)
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  {
 +	struct esw_mc_addr *mc_promisc;
  	int old_mode;
 +	int nvports;
 +	int i;
  
 -	if (!ESW_ALLOWED(esw) || esw->mode == MLX5_ESWITCH_NONE)
 +	if (!ESW_ALLOWED(esw) || esw->mode == SRIOV_NONE)
  		return;
  
 -	esw_info(esw->dev, "Disable: mode(%s), nvfs(%d), active vports(%d)\n",
 -		 esw->mode == MLX5_ESWITCH_LEGACY ? "LEGACY" : "OFFLOADS",
 -		 esw->esw_funcs.num_vfs, esw->enabled_vports);
 +	esw_info(esw->dev, "disable SRIOV: active vports(%d) mode(%d)\n",
 +		 esw->enabled_vports, esw->mode);
  
 -	mlx5_eswitch_event_handlers_unregister(esw);
 +	mc_promisc = &esw->mc_promisc;
 +	nvports = esw->enabled_vports;
 +
 +	if (esw->mode == SRIOV_LEGACY)
 +		mlx5_eq_notifier_unregister(esw->dev, &esw->nb);
  
 -	if (esw->mode == MLX5_ESWITCH_LEGACY)
 -		esw_legacy_disable(esw);
 -	else if (esw->mode == MLX5_ESWITCH_OFFLOADS)
 -		esw_offloads_disable(esw);
 +	for (i = 0; i < esw->total_vports; i++)
 +		esw_disable_vport(esw, i);
 +
 +	if (mc_promisc && mc_promisc->uplink_rule)
 +		mlx5_del_flow_rules(mc_promisc->uplink_rule);
  
  	esw_destroy_tsar(esw);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 0b84087d3e8a,804a7ed2b969..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -232,19 -269,19 +232,24 @@@ void esw_vport_disable_ingress_acl(stru
  /* E-Switch API */
  int mlx5_eswitch_init(struct mlx5_core_dev *dev);
  void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw);
++<<<<<<< HEAD
 +int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode);
 +void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw);
++=======
+ int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int mode);
+ void mlx5_eswitch_disable(struct mlx5_eswitch *esw, bool clear_vf);
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  int mlx5_eswitch_set_vport_mac(struct mlx5_eswitch *esw,
 -			       u16 vport, u8 mac[ETH_ALEN]);
 +			       int vport, u8 mac[ETH_ALEN]);
  int mlx5_eswitch_set_vport_state(struct mlx5_eswitch *esw,
 -				 u16 vport, int link_state);
 +				 int vport, int link_state);
  int mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,
 -				u16 vport, u16 vlan, u8 qos);
 +				int vport, u16 vlan, u8 qos);
  int mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,
 -				    u16 vport, bool spoofchk);
 +				    int vport, bool spoofchk);
  int mlx5_eswitch_set_vport_trust(struct mlx5_eswitch *esw,
 -				 u16 vport_num, bool setting);
 -int mlx5_eswitch_set_vport_rate(struct mlx5_eswitch *esw, u16 vport,
 +				 int vport_num, bool setting);
 +int mlx5_eswitch_set_vport_rate(struct mlx5_eswitch *esw, int vport,
  				u32 max_rate, u32 min_rate);
  int mlx5_eswitch_set_vepa(struct mlx5_eswitch *esw, u8 setting);
  int mlx5_eswitch_get_vepa(struct mlx5_eswitch *esw, u8 *setting);
@@@ -400,9 -602,16 +405,14 @@@ void mlx5e_tc_clean_fdb_peer_flows(stru
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
  static inline void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw) {}
++<<<<<<< HEAD
 +static inline int  mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode) { return 0; }
 +static inline void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw) {}
++=======
+ static inline int  mlx5_eswitch_enable(struct mlx5_eswitch *esw, int mode) { return 0; }
+ static inline void mlx5_eswitch_disable(struct mlx5_eswitch *esw, bool clear_vf) {}
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  static inline bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0, struct mlx5_core_dev *dev1) { return true; }
 -static inline bool mlx5_eswitch_is_funcs_handler(struct mlx5_core_dev *dev) { return false; }
 -static inline const u32 *mlx5_esw_query_functions(struct mlx5_core_dev *dev)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
 -static inline void mlx5_eswitch_update_num_of_vfs(struct mlx5_eswitch *esw, const int num_vfs) {}
  
  #define FDB_MAX_CHAIN 1
  #define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index cfa5607ee8ba,cbd88f42350e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1176,8 -1370,9 +1176,14 @@@ static int esw_offloads_start(struct ml
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_sriov(esw);
 +	err = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_OFFLOADS);
++=======
+ 	mlx5_eswitch_disable(esw, false);
+ 	mlx5_eswitch_update_num_of_vfs(esw, esw->dev->priv.sriov.num_vfs);
+ 	err = mlx5_eswitch_enable(esw, MLX5_ESWITCH_OFFLOADS);
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack,
  				   "Failed setting eswitch to offloads");
@@@ -1628,13 -2194,13 +1634,18 @@@ err_reps
  static int esw_offloads_stop(struct mlx5_eswitch *esw,
  			     struct netlink_ext_ack *extack)
  {
 -	int err, err1;
 +	int err, err1, num_vfs = esw->dev->priv.sriov.num_vfs;
  
++<<<<<<< HEAD
 +	mlx5_eswitch_disable_sriov(esw);
 +	err = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_LEGACY);
++=======
+ 	mlx5_eswitch_disable(esw, false);
+ 	err = mlx5_eswitch_enable(esw, MLX5_ESWITCH_LEGACY);
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  	if (err) {
  		NL_SET_ERR_MSG_MOD(extack, "Failed setting eswitch to legacy");
 -		err1 = mlx5_eswitch_enable(esw, MLX5_ESWITCH_OFFLOADS);
 +		err1 = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_OFFLOADS);
  		if (err1) {
  			NL_SET_ERR_MSG_MOD(extack,
  					   "Failed setting eswitch back to offloads");
diff --cc drivers/net/ethernet/mellanox/mlx5/core/sriov.c
index a249b3c3843d,f641f1336402..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@@ -115,9 -108,10 +115,9 @@@ enable_vfs_hca
  	return 0;
  }
  
- static void mlx5_device_disable_sriov(struct mlx5_core_dev *dev)
+ static void mlx5_device_disable_sriov(struct mlx5_core_dev *dev, bool clear_vf)
  {
  	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
 -	int num_vfs = pci_num_vf(dev->pdev);
  	int err;
  	int vf;
  
@@@ -133,12 -124,10 +133,16 @@@
  			continue;
  		}
  		sriov->vfs_ctx[vf].enabled = 0;
 +		sriov->enabled_vfs--;
  	}
  
 +out:
  	if (MLX5_ESWITCH_MANAGER(dev))
++<<<<<<< HEAD
 +		mlx5_eswitch_disable_sriov(dev->priv.eswitch);
++=======
+ 		mlx5_eswitch_disable(dev->priv.eswitch, clear_vf);
++>>>>>>> 556b9d16d3f5 (net/mlx5: Clear VF's configuration on disabling SRIOV)
  
  	if (mlx5_wait_for_pages(dev, &dev->priv.vfs_pages))
  		mlx5_core_warn(dev, "timeout reclaiming VFs pages\n");
@@@ -205,9 -192,33 +209,9 @@@ void mlx5_sriov_detach(struct mlx5_core
  	if (!mlx5_core_is_pf(dev))
  		return;
  
- 	mlx5_device_disable_sriov(dev);
+ 	mlx5_device_disable_sriov(dev, false);
  }
  
 -static u16 mlx5_get_max_vfs(struct mlx5_core_dev *dev)
 -{
 -	u16 host_total_vfs;
 -	const u32 *out;
 -
 -	if (mlx5_core_is_ecpf_esw_manager(dev)) {
 -		out = mlx5_esw_query_functions(dev);
 -
 -		/* Old FW doesn't support getting total_vfs from esw func
 -		 * but supports getting it from pci_sriov.
 -		 */
 -		if (IS_ERR(out))
 -			goto done;
 -		host_total_vfs = MLX5_GET(query_esw_functions_out, out,
 -					  host_params_context.host_total_vfs);
 -		kvfree(out);
 -		if (host_total_vfs)
 -			return host_total_vfs;
 -	}
 -
 -done:
 -	return pci_sriov_get_totalvfs(dev->pdev);
 -}
 -
  int mlx5_sriov_init(struct mlx5_core_dev *dev)
  {
  	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/sriov.c
