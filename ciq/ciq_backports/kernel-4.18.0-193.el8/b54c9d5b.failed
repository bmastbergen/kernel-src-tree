net: Use skb_frag_off accessors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] Use skb_frag_off accessors (Stefan Assmann) [1721697]
Rebuild_FUZZ: 91.23%
commit-author Jonathan Lemon <jonathan.lemon@gmail.com>
commit b54c9d5bd6e38edac9ce3a3f95f14a1292b5268d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b54c9d5b.failed

Use accessor functions for skb fragment's page_offset instead
of direct references, in preparation for bvec conversion.

	Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b54c9d5bd6e38edac9ce3a3f95f14a1292b5268d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hsi/clients/ssi_protocol.c
#	drivers/net/ethernet/myricom/myri10ge/myri10ge.c
#	drivers/net/usb/usbnet.c
#	drivers/net/xen-netback/netback.c
#	drivers/staging/unisys/visornic/visornic_main.c
#	drivers/target/iscsi/cxgbit/cxgbit_target.c
#	net/core/skbuff.c
#	net/ipv4/tcp.c
#	net/kcm/kcmsock.c
#	net/tls/tls_device.c
diff --cc drivers/hsi/clients/ssi_protocol.c
index 561abf7bdf1f,0253e76f1df2..000000000000
--- a/drivers/hsi/clients/ssi_protocol.c
+++ b/drivers/hsi/clients/ssi_protocol.c
@@@ -194,7 -181,8 +194,12 @@@ static void ssip_skb_to_msg(struct sk_b
  		sg = sg_next(sg);
  		BUG_ON(!sg);
  		frag = &skb_shinfo(skb)->frags[i];
++<<<<<<< HEAD
 +		sg_set_page(sg, frag->page.p, frag->size, frag->page_offset);
++=======
+ 		sg_set_page(sg, skb_frag_page(frag), skb_frag_size(frag),
+ 				skb_frag_off(frag));
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  	}
  }
  
diff --cc drivers/net/ethernet/myricom/myri10ge/myri10ge.c
index b2d2ec8c11e2,99eaadba555f..000000000000
--- a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
+++ b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
@@@ -1365,8 -1364,8 +1365,13 @@@ myri10ge_rx_done(struct myri10ge_slice_
  	}
  
  	/* remove padding */
++<<<<<<< HEAD
 +	rx_frags[0].page_offset += MXGEFW_PAD;
 +	rx_frags[0].size -= MXGEFW_PAD;
++=======
+ 	skb_frag_off_add(&rx_frags[0], MXGEFW_PAD);
+ 	skb_frag_size_sub(&rx_frags[0], MXGEFW_PAD);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  	len -= MXGEFW_PAD;
  
  	skb->len = len;
diff --cc drivers/net/usb/usbnet.c
index 770aa624147f,58952a79b05f..000000000000
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@@ -1335,11 -1324,11 +1335,16 @@@ static int build_dma_sg(const struct sk
  	total_len += skb_headlen(skb);
  
  	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 -		skb_frag_t *f = &skb_shinfo(skb)->frags[i];
 +		struct skb_frag_struct *f = &skb_shinfo(skb)->frags[i];
  
  		total_len += skb_frag_size(f);
++<<<<<<< HEAD
 +		sg_set_page(&urb->sg[i + s], f->page.p, f->size,
 +				f->page_offset);
++=======
+ 		sg_set_page(&urb->sg[i + s], skb_frag_page(f), skb_frag_size(f),
+ 			    skb_frag_off(f));
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  	}
  	urb->transfer_buffer_length = total_len;
  
diff --cc drivers/net/xen-netback/netback.c
index a27daa23c9dc,3ef07b63613e..000000000000
--- a/drivers/net/xen-netback/netback.c
+++ b/drivers/net/xen-netback/netback.c
@@@ -1067,8 -1067,8 +1067,13 @@@ static int xenvif_handle_frag_list(stru
  			BUG();
  
  		offset += len;
++<<<<<<< HEAD
 +		frags[i].page.p = page;
 +		frags[i].page_offset = 0;
++=======
+ 		__skb_frag_set_page(&frags[i], page);
+ 		skb_frag_off_set(&frags[i], 0);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  		skb_frag_size_set(&frags[i], len);
  	}
  
diff --cc drivers/staging/unisys/visornic/visornic_main.c
index 5eeb4b93b45b,6fa7726185de..000000000000
--- a/drivers/staging/unisys/visornic/visornic_main.c
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@@ -284,9 -284,9 +284,15 @@@ static int visor_copy_fragsinfo_from_sk
  		for (frag = 0; frag < numfrags; frag++) {
  			count = add_physinfo_entries(page_to_pfn(
  				  skb_frag_page(&skb_shinfo(skb)->frags[frag])),
++<<<<<<< HEAD
 +				  skb_shinfo(skb)->frags[frag].page_offset,
 +				  skb_shinfo(skb)->frags[frag].size, count,
 +				  frags_max, frags);
++=======
+ 				  skb_frag_off(&skb_shinfo(skb)->frags[frag]),
+ 				  skb_frag_size(&skb_shinfo(skb)->frags[frag]),
+ 				  count, frags_max, frags);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  			/* add_physinfo_entries only returns
  			 * zero if the frags array is out of room
  			 * That should never happen because we
diff --cc drivers/target/iscsi/cxgbit/cxgbit_target.c
index 29b350a0b58f,fcdc4211e3c2..000000000000
--- a/drivers/target/iscsi/cxgbit/cxgbit_target.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_target.c
@@@ -902,9 -899,9 +902,15 @@@ cxgbit_handle_immediate_data(struct isc
  		skb_frag_t *dfrag = &ssi->frags[pdu_cb->dfrag_idx];
  
  		sg_init_table(&ccmd->sg, 1);
++<<<<<<< HEAD
 +		sg_set_page(&ccmd->sg, dfrag->page.p, skb_frag_size(dfrag),
 +			    dfrag->page_offset);
 +		get_page(dfrag->page.p);
++=======
+ 		sg_set_page(&ccmd->sg, skb_frag_page(dfrag),
+ 				skb_frag_size(dfrag), skb_frag_off(dfrag));
+ 		get_page(skb_frag_page(dfrag));
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  
  		cmd->se_cmd.t_data_sg = &ccmd->sg;
  		cmd->se_cmd.t_data_nents = 1;
@@@ -1406,7 -1403,8 +1412,12 @@@ static void cxgbit_lro_skb_dump(struct 
  			pdu_cb->ddigest, pdu_cb->frags);
  	for (i = 0; i < ssi->nr_frags; i++)
  		pr_info("skb 0x%p, frag %d, off %u, sz %u.\n",
++<<<<<<< HEAD
 +			skb, i, ssi->frags[i].page_offset, ssi->frags[i].size);
++=======
+ 			skb, i, skb_frag_off(&ssi->frags[i]),
+ 			skb_frag_size(&ssi->frags[i]));
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  }
  
  static void cxgbit_lro_hskb_reset(struct cxgbit_sock *csk)
diff --cc net/core/skbuff.c
index f2c265694b99,ea8e8d332d85..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -680,6 -709,105 +680,108 @@@ void kfree_skb_list(struct sk_buff *seg
  }
  EXPORT_SYMBOL(kfree_skb_list);
  
++<<<<<<< HEAD
++=======
+ /* Dump skb information and contents.
+  *
+  * Must only be called from net_ratelimit()-ed paths.
+  *
+  * Dumps up to can_dump_full whole packets if full_pkt, headers otherwise.
+  */
+ void skb_dump(const char *level, const struct sk_buff *skb, bool full_pkt)
+ {
+ 	static atomic_t can_dump_full = ATOMIC_INIT(5);
+ 	struct skb_shared_info *sh = skb_shinfo(skb);
+ 	struct net_device *dev = skb->dev;
+ 	struct sock *sk = skb->sk;
+ 	struct sk_buff *list_skb;
+ 	bool has_mac, has_trans;
+ 	int headroom, tailroom;
+ 	int i, len, seg_len;
+ 
+ 	if (full_pkt)
+ 		full_pkt = atomic_dec_if_positive(&can_dump_full) >= 0;
+ 
+ 	if (full_pkt)
+ 		len = skb->len;
+ 	else
+ 		len = min_t(int, skb->len, MAX_HEADER + 128);
+ 
+ 	headroom = skb_headroom(skb);
+ 	tailroom = skb_tailroom(skb);
+ 
+ 	has_mac = skb_mac_header_was_set(skb);
+ 	has_trans = skb_transport_header_was_set(skb);
+ 
+ 	printk("%sskb len=%u headroom=%u headlen=%u tailroom=%u\n"
+ 	       "mac=(%d,%d) net=(%d,%d) trans=%d\n"
+ 	       "shinfo(txflags=%u nr_frags=%u gso(size=%hu type=%u segs=%hu))\n"
+ 	       "csum(0x%x ip_summed=%u complete_sw=%u valid=%u level=%u)\n"
+ 	       "hash(0x%x sw=%u l4=%u) proto=0x%04x pkttype=%u iif=%d\n",
+ 	       level, skb->len, headroom, skb_headlen(skb), tailroom,
+ 	       has_mac ? skb->mac_header : -1,
+ 	       has_mac ? skb_mac_header_len(skb) : -1,
+ 	       skb->network_header,
+ 	       has_trans ? skb_network_header_len(skb) : -1,
+ 	       has_trans ? skb->transport_header : -1,
+ 	       sh->tx_flags, sh->nr_frags,
+ 	       sh->gso_size, sh->gso_type, sh->gso_segs,
+ 	       skb->csum, skb->ip_summed, skb->csum_complete_sw,
+ 	       skb->csum_valid, skb->csum_level,
+ 	       skb->hash, skb->sw_hash, skb->l4_hash,
+ 	       ntohs(skb->protocol), skb->pkt_type, skb->skb_iif);
+ 
+ 	if (dev)
+ 		printk("%sdev name=%s feat=0x%pNF\n",
+ 		       level, dev->name, &dev->features);
+ 	if (sk)
+ 		printk("%ssk family=%hu type=%u proto=%u\n",
+ 		       level, sk->sk_family, sk->sk_type, sk->sk_protocol);
+ 
+ 	if (full_pkt && headroom)
+ 		print_hex_dump(level, "skb headroom: ", DUMP_PREFIX_OFFSET,
+ 			       16, 1, skb->head, headroom, false);
+ 
+ 	seg_len = min_t(int, skb_headlen(skb), len);
+ 	if (seg_len)
+ 		print_hex_dump(level, "skb linear:   ", DUMP_PREFIX_OFFSET,
+ 			       16, 1, skb->data, seg_len, false);
+ 	len -= seg_len;
+ 
+ 	if (full_pkt && tailroom)
+ 		print_hex_dump(level, "skb tailroom: ", DUMP_PREFIX_OFFSET,
+ 			       16, 1, skb_tail_pointer(skb), tailroom, false);
+ 
+ 	for (i = 0; len && i < skb_shinfo(skb)->nr_frags; i++) {
+ 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+ 		u32 p_off, p_len, copied;
+ 		struct page *p;
+ 		u8 *vaddr;
+ 
+ 		skb_frag_foreach_page(frag, skb_frag_off(frag),
+ 				      skb_frag_size(frag), p, p_off, p_len,
+ 				      copied) {
+ 			seg_len = min_t(int, p_len, len);
+ 			vaddr = kmap_atomic(p);
+ 			print_hex_dump(level, "skb frag:     ",
+ 				       DUMP_PREFIX_OFFSET,
+ 				       16, 1, vaddr + p_off, seg_len, false);
+ 			kunmap_atomic(vaddr);
+ 			len -= seg_len;
+ 			if (!len)
+ 				break;
+ 		}
+ 	}
+ 
+ 	if (full_pkt && skb_has_frag_list(skb)) {
+ 		printk("skb fraglist:\n");
+ 		skb_walk_frags(skb, list_skb)
+ 			skb_dump(level, list_skb, true);
+ 	}
+ }
+ EXPORT_SYMBOL(skb_dump);
+ 
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  /**
   *	skb_tx_error - report an sk_buff xmit error
   *	@skb: buffer that triggered an error
@@@ -2341,11 -2496,11 +2445,16 @@@ do_frag_list
  	for (; len && fragidx < skb_shinfo(skb)->nr_frags; fragidx++) {
  		skb_frag_t *frag  = &skb_shinfo(skb)->frags[fragidx];
  
 -		slen = min_t(size_t, len, skb_frag_size(frag) - offset);
 +		slen = min_t(size_t, len, frag->size - offset);
  
  		while (slen) {
++<<<<<<< HEAD
 +			ret = kernel_sendpage_locked(sk, frag->page.p,
 +						     frag->page_offset + offset,
++=======
+ 			ret = kernel_sendpage_locked(sk, skb_frag_page(frag),
+ 						     skb_frag_off(frag) + offset,
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  						     slen, MSG_DONTWAIT);
  			if (ret <= 0)
  				goto error;
@@@ -2519,12 -2662,16 +2628,12 @@@ __wsum __skb_checksum(const struct sk_b
  				copy = len;
  
  			skb_frag_foreach_page(frag,
- 					      frag->page_offset + offset - start,
+ 					      skb_frag_off(frag) + offset - start,
  					      copy, p, p_off, p_len, copied) {
  				vaddr = kmap_atomic(p);
 -				csum2 = INDIRECT_CALL_1(ops->update,
 -							csum_partial_ext,
 -							vaddr + p_off, p_len, 0);
 +				csum2 = ops->update(vaddr + p_off, p_len, 0);
  				kunmap_atomic(vaddr);
 -				csum = INDIRECT_CALL_1(ops->combine,
 -						       csum_block_add_ext, csum,
 -						       csum2, pos, p_len);
 +				csum = ops->combine(csum, csum2, pos, p_len);
  				pos += p_len;
  			}
  
@@@ -3177,11 -3366,11 +3286,16 @@@ int skb_shift(struct sk_buff *tgt, stru
  
  		} else {
  			__skb_frag_ref(fragfrom);
++<<<<<<< HEAD
 +			fragto->page = fragfrom->page;
 +			fragto->page_offset = fragfrom->page_offset;
++=======
+ 			skb_frag_page_copy(fragto, fragfrom);
+ 			skb_frag_off_copy(fragto, fragfrom);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  			skb_frag_size_set(fragto, todo);
  
- 			fragfrom->page_offset += todo;
+ 			skb_frag_off_add(fragfrom, todo);
  			skb_frag_size_sub(fragfrom, todo);
  			todo = 0;
  
@@@ -3500,10 -3631,10 +3614,17 @@@ static inline skb_frag_t skb_head_frag_
  	struct page *page;
  
  	page = virt_to_head_page(frag_skb->head);
++<<<<<<< HEAD
 +	head_frag.page.p = page;
 +	head_frag.page_offset = frag_skb->data -
 +		(unsigned char *)page_address(page);
 +	head_frag.size = skb_headlen(frag_skb);
++=======
+ 	__skb_frag_set_page(&head_frag, page);
+ 	skb_frag_off_set(&head_frag, frag_skb->data -
+ 			 (unsigned char *)page_address(page));
+ 	skb_frag_size_set(&head_frag, skb_headlen(frag_skb));
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  	return head_frag;
  }
  
@@@ -3915,8 -4027,8 +4036,13 @@@ int skb_gro_receive(struct sk_buff **he
  
  		pinfo->nr_frags = nr_frags + 1 + skbinfo->nr_frags;
  
++<<<<<<< HEAD
 +		frag->page.p	  = page;
 +		frag->page_offset = first_offset;
++=======
+ 		__skb_frag_set_page(frag, page);
+ 		skb_frag_off_set(frag, first_offset);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  		skb_frag_size_set(frag, first_size);
  
  		memcpy(frag + 1, skbinfo->frags, sizeof(*frag) * skbinfo->nr_frags);
diff --cc net/ipv4/tcp.c
index d17c837b6339,a0a66321c0ee..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -1816,8 -1782,19 +1816,22 @@@ static int tcp_zerocopy_receive(struct 
  				frags++;
  			}
  		}
++<<<<<<< HEAD
 +		if (frags->size != PAGE_SIZE || frags->page_offset)
++=======
+ 		if (skb_frag_size(frags) != PAGE_SIZE || skb_frag_off(frags)) {
+ 			int remaining = zc->recv_skip_hint;
+ 			int size = skb_frag_size(frags);
+ 
+ 			while (remaining && (size != PAGE_SIZE ||
+ 					     skb_frag_off(frags))) {
+ 				remaining -= size;
+ 				frags++;
+ 				size = skb_frag_size(frags);
+ 			}
+ 			zc->recv_skip_hint -= remaining;
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  			break;
 -		}
  		ret = vm_insert_page(vma, address + length,
  				     skb_frag_page(frags));
  		if (ret)
@@@ -3681,8 -3783,8 +3695,13 @@@ int tcp_md5_hash_skb_data(struct tcp_md
  		return 1;
  
  	for (i = 0; i < shi->nr_frags; ++i) {
++<<<<<<< HEAD
 +		const struct skb_frag_struct *f = &shi->frags[i];
 +		unsigned int offset = f->page_offset;
++=======
+ 		const skb_frag_t *f = &shi->frags[i];
+ 		unsigned int offset = skb_frag_off(f);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  		struct page *page = skb_frag_page(f) + (offset >> PAGE_SHIFT);
  
  		sg_set_page(&sg, page, skb_frag_size(f),
diff --cc net/kcm/kcmsock.c
index d3601d421571,4ff75c3a8d6e..000000000000
--- a/net/kcm/kcmsock.c
+++ b/net/kcm/kcmsock.c
@@@ -644,9 -641,9 +644,15 @@@ do_frag
  			}
  
  			ret = kernel_sendpage(psock->sk->sk_socket,
++<<<<<<< HEAD
 +					      frag->page.p,
 +					      frag->page_offset + frag_offset,
 +					      frag->size - frag_offset,
++=======
+ 					      skb_frag_page(frag),
+ 					      skb_frag_off(frag) + frag_offset,
+ 					      skb_frag_size(frag) - frag_offset,
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  					      MSG_DONTWAIT);
  			if (ret <= 0) {
  				if (ret == -EAGAIN) {
diff --cc net/tls/tls_device.c
index 24e7aeb8db86,d184230665eb..000000000000
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@@ -216,14 -243,14 +216,25 @@@ static void tls_append_frag(struct tls_
  	skb_frag_t *frag;
  
  	frag = &record->frags[record->num_frags - 1];
++<<<<<<< HEAD
 +	if (frag->page.p == pfrag->page &&
 +	    frag->page_offset + frag->size == pfrag->offset) {
 +		frag->size += size;
 +	} else {
 +		++frag;
 +		frag->page.p = pfrag->page;
 +		frag->page_offset = pfrag->offset;
 +		frag->size = size;
++=======
+ 	if (skb_frag_page(frag) == pfrag->page &&
+ 	    skb_frag_off(frag) + skb_frag_size(frag) == pfrag->offset) {
+ 		skb_frag_size_add(frag, size);
+ 	} else {
+ 		++frag;
+ 		__skb_frag_set_page(frag, pfrag->page);
+ 		skb_frag_off_set(frag, pfrag->offset);
+ 		skb_frag_size_set(frag, size);
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  		++record->num_frags;
  		get_page(pfrag->page);
  	}
@@@ -270,8 -301,8 +281,13 @@@ static int tls_push_record(struct sock 
  		frag = &record->frags[i];
  		sg_unmark_end(&offload_ctx->sg_tx_data[i]);
  		sg_set_page(&offload_ctx->sg_tx_data[i], skb_frag_page(frag),
++<<<<<<< HEAD
 +			    frag->size, frag->page_offset);
 +		sk_mem_charge(sk, frag->size);
++=======
+ 			    skb_frag_size(frag), skb_frag_off(frag));
+ 		sk_mem_charge(sk, skb_frag_size(frag));
++>>>>>>> b54c9d5bd6e3 (net: Use skb_frag_off accessors)
  		get_page(skb_frag_page(frag));
  	}
  	sg_mark_end(&offload_ctx->sg_tx_data[record->num_frags - 1]);
diff --git a/drivers/atm/eni.c b/drivers/atm/eni.c
index 6470e3c4c990..deb6b31dec77 100644
--- a/drivers/atm/eni.c
+++ b/drivers/atm/eni.c
@@ -1134,7 +1134,7 @@ DPRINTK("doing direct send\n"); /* @@@ well, this doesn't work anyway */
 			else
 				put_dma(tx->index,eni_dev->dma,&j,(unsigned long)
 				    skb_frag_page(&skb_shinfo(skb)->frags[i]) +
-					skb_shinfo(skb)->frags[i].page_offset,
+					skb_frag_off(&skb_shinfo(skb)->frags[i]),
 				    skb_frag_size(&skb_shinfo(skb)->frags[i]));
 	}
 	if (skb->len & 3) {
* Unmerged path drivers/hsi/clients/ssi_protocol.c
diff --git a/drivers/infiniband/hw/hfi1/vnic_sdma.c b/drivers/infiniband/hw/hfi1/vnic_sdma.c
index af1b1ffcb38e..110e380114a2 100644
--- a/drivers/infiniband/hw/hfi1/vnic_sdma.c
+++ b/drivers/infiniband/hw/hfi1/vnic_sdma.c
@@ -108,7 +108,7 @@ static noinline int build_vnic_ulp_payload(struct sdma_engine *sde,
 		ret = sdma_txadd_page(sde->dd,
 				      &tx->txreq,
 				      skb_frag_page(frag),
-				      frag->page_offset,
+				      skb_frag_off(frag),
 				      skb_frag_size(frag));
 		if (unlikely(ret))
 			goto bail_txadd;
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
index 78fa777c87b1..c332b4761816 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
@@ -293,7 +293,8 @@ int ipoib_dma_map_tx(struct ib_device *ca, struct ipoib_tx_buf *tx_req)
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		mapping[i + off] = ib_dma_map_page(ca,
 						 skb_frag_page(frag),
-						 frag->page_offset, skb_frag_size(frag),
+						 skb_frag_off(frag),
+						 skb_frag_size(frag),
 						 DMA_TO_DEVICE);
 		if (unlikely(ib_dma_mapping_error(ca, mapping[i + off])))
 			goto partial_error;
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 94501af8bebc..dd2a9bd445ba 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -932,7 +932,7 @@ static struct sk_buff *bnxt_rx_page_skb(struct bnxt *bp,
 
 	frag = &skb_shinfo(skb)->frags[0];
 	skb_frag_size_sub(frag, payload);
-	frag->page_offset += payload;
+	skb_frag_off_add(frag, payload);
 	skb->data_len -= payload;
 	skb->tail += payload;
 
diff --git a/drivers/net/ethernet/cavium/thunder/nicvf_queues.c b/drivers/net/ethernet/cavium/thunder/nicvf_queues.c
index 9a4cfa61ed93..f765d159f3fb 100644
--- a/drivers/net/ethernet/cavium/thunder/nicvf_queues.c
+++ b/drivers/net/ethernet/cavium/thunder/nicvf_queues.c
@@ -1599,7 +1599,7 @@ int nicvf_sq_append_skb(struct nicvf *nic, struct snd_queue *sq,
 		size = skb_frag_size(frag);
 		dma_addr = dma_map_page_attrs(&nic->pdev->dev,
 					      skb_frag_page(frag),
-					      frag->page_offset, size,
+					      skb_frag_off(frag), size,
 					      DMA_TO_DEVICE,
 					      DMA_ATTR_SKIP_CPU_SYNC);
 		if (dma_mapping_error(&nic->pdev->dev, dma_addr)) {
diff --git a/drivers/net/ethernet/chelsio/cxgb3/sge.c b/drivers/net/ethernet/chelsio/cxgb3/sge.c
index 20b6e1b3f5e3..1f3aea99344c 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/sge.c
@@ -2182,7 +2182,7 @@ static void lro_add_page(struct adapter *adap, struct sge_qset *qs,
 
 	rx_frag += nr_frags;
 	__skb_frag_set_page(rx_frag, sd->pg_chunk.page);
-	rx_frag->page_offset = sd->pg_chunk.offset + offset;
+	skb_frag_off_set(rx_frag, sd->pg_chunk.offset + offset);
 	skb_frag_size_set(rx_frag, len);
 
 	skb->len += len;
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 81cef49a955c..9a758e08eced 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -2349,8 +2349,8 @@ static void skb_fill_rx_data(struct be_rx_obj *rxo, struct sk_buff *skb,
 		memcpy(skb->data, start, hdr_len);
 		skb_shinfo(skb)->nr_frags = 1;
 		skb_frag_set_page(skb, 0, page_info->page);
-		skb_shinfo(skb)->frags[0].page_offset =
-					page_info->page_offset + hdr_len;
+		skb_frag_off_set(&skb_shinfo(skb)->frags[0],
+				 page_info->page_offset + hdr_len);
 		skb_frag_size_set(&skb_shinfo(skb)->frags[0],
 				  curr_frag_len - hdr_len);
 		skb->data_len = curr_frag_len - hdr_len;
@@ -2375,8 +2375,8 @@ static void skb_fill_rx_data(struct be_rx_obj *rxo, struct sk_buff *skb,
 			/* Fresh page */
 			j++;
 			skb_frag_set_page(skb, j, page_info->page);
-			skb_shinfo(skb)->frags[j].page_offset =
-							page_info->page_offset;
+			skb_frag_off_set(&skb_shinfo(skb)->frags[j],
+					 page_info->page_offset);
 			skb_frag_size_set(&skb_shinfo(skb)->frags[j], 0);
 			skb_shinfo(skb)->nr_frags++;
 		} else {
@@ -2457,8 +2457,8 @@ static void be_rx_compl_process_gro(struct be_rx_obj *rxo,
 			/* First frag or Fresh page */
 			j++;
 			skb_frag_set_page(skb, j, page_info->page);
-			skb_shinfo(skb)->frags[j].page_offset =
-							page_info->page_offset;
+			skb_frag_off_set(&skb_shinfo(skb)->frags[j],
+					 page_info->page_offset);
 			skb_frag_size_set(&skb_shinfo(skb)->frags[j], 0);
 		} else {
 			put_page(page_info->page);
diff --git a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
index 2c2976a2dda6..e9554be87235 100644
--- a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
+++ b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
@@ -500,7 +500,7 @@ static int fs_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		nr_frags = skb_shinfo(skb)->nr_frags;
 		frag = skb_shinfo(skb)->frags;
 		for (i = 0; i < nr_frags; i++, frag++) {
-			if (!IS_ALIGNED(frag->page_offset, 4)) {
+			if (!IS_ALIGNED(skb_frag_off(frag), 4)) {
 				is_aligned = 0;
 				break;
 			}
diff --git a/drivers/net/ethernet/ibm/ibmvnic.c b/drivers/net/ethernet/ibm/ibmvnic.c
index 1ab6f56d6809..8da1fcf50d0b 100644
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@ -1499,7 +1499,7 @@ static int ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)
 
 			memcpy(dst + cur,
 			       page_address(skb_frag_page(frag)) +
-			       frag->page_offset, skb_frag_size(frag));
+			       skb_frag_off(frag), skb_frag_size(frag));
 			cur += skb_frag_size(frag);
 		}
 	} else {
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 7d85f41d0e68..23ea07194236 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -3311,7 +3311,7 @@ bool __i40e_chk_linearize(struct sk_buff *skb)
 		 * descriptor associated with the fragment.
 		 */
 		if (stale_size > I40E_MAX_DATA_PER_TXD) {
-			int align_pad = -(stale->page_offset) &
+			int align_pad = -(skb_frag_off(stale)) &
 					(I40E_MAX_READ_REQ_SIZE - 1);
 
 			sum -= align_pad;
diff --git a/drivers/net/ethernet/intel/iavf/iavf_txrx.c b/drivers/net/ethernet/intel/iavf/iavf_txrx.c
index f170b5e15631..017b0e2443ed 100644
--- a/drivers/net/ethernet/intel/iavf/iavf_txrx.c
+++ b/drivers/net/ethernet/intel/iavf/iavf_txrx.c
@@ -2205,7 +2205,7 @@ bool __iavf_chk_linearize(struct sk_buff *skb)
 		 * descriptor associated with the fragment.
 		 */
 		if (stale_size > IAVF_MAX_DATA_PER_TXD) {
-			int align_pad = -(stale->page_offset) &
+			int align_pad = -(skb_frag_off(stale)) &
 					(IAVF_MAX_READ_REQ_SIZE - 1);
 
 			sum -= align_pad;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 676942919522..38486ee14742 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -1807,7 +1807,7 @@ static void ixgbe_pull_tail(struct ixgbe_ring *rx_ring,
 
 	/* update all of the pointers */
 	skb_frag_size_sub(frag, pull_len);
-	frag->page_offset += pull_len;
+	skb_frag_off_add(frag, pull_len);
 	skb->data_len -= pull_len;
 	skb->tail += pull_len;
 }
@@ -1838,7 +1838,7 @@ static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring,
 
 		dma_sync_single_range_for_cpu(rx_ring->dev,
 					      IXGBE_CB(skb)->dma,
-					      frag->page_offset,
+					      skb_frag_off(frag),
 					      skb_frag_size(frag),
 					      DMA_FROM_DEVICE);
 	}
diff --git a/drivers/net/ethernet/jme.c b/drivers/net/ethernet/jme.c
index 06ff185eb188..4dea01158a75 100644
--- a/drivers/net/ethernet/jme.c
+++ b/drivers/net/ethernet/jme.c
@@ -2059,8 +2059,8 @@ jme_map_tx_skb(struct jme_adapter *jme, struct sk_buff *skb, int idx)
 		ctxbi = txbi + ((idx + i + 2) & (mask));
 
 		ret = jme_fill_tx_map(jme->pdev, ctxdesc, ctxbi,
-				skb_frag_page(frag),
-				frag->page_offset, skb_frag_size(frag), hidma);
+				      skb_frag_page(frag), skb_frag_off(frag),
+				      skb_frag_size(frag), hidma);
 		if (ret) {
 			jme_drop_tx_map(jme, idx, i);
 			goto out;
diff --git a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
index 010b7987ce55..547bd4efa675 100644
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@ -671,7 +671,7 @@ static inline unsigned int has_tiny_unaligned_frags(struct sk_buff *skb)
 	for (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {
 		const skb_frag_t *fragp = &skb_shinfo(skb)->frags[frag];
 
-		if (skb_frag_size(fragp) <= 8 && fragp->page_offset & 7)
+		if (skb_frag_size(fragp) <= 8 && skb_frag_off(fragp) & 7)
 			return 1;
 	}
 
* Unmerged path drivers/net/ethernet/myricom/myri10ge/myri10ge.c
diff --git a/drivers/net/ethernet/sfc/tx.c b/drivers/net/ethernet/sfc/tx.c
index 6ea87b43fb9e..2f04234e7642 100644
--- a/drivers/net/ethernet/sfc/tx.c
+++ b/drivers/net/ethernet/sfc/tx.c
@@ -277,7 +277,7 @@ static void efx_skb_copy_bits_to_pio(struct efx_nic *efx, struct sk_buff *skb,
 
 		vaddr = kmap_atomic(skb_frag_page(f));
 
-		efx_memcpy_toio_aligned_cb(efx, piobuf, vaddr + f->page_offset,
+		efx_memcpy_toio_aligned_cb(efx, piobuf, vaddr + skb_frag_off(f),
 					   skb_frag_size(f), copy_buf);
 		kunmap_atomic(vaddr);
 	}
diff --git a/drivers/net/ethernet/sun/cassini.c b/drivers/net/ethernet/sun/cassini.c
index 9020b084b953..5de6fd646205 100644
--- a/drivers/net/ethernet/sun/cassini.c
+++ b/drivers/net/ethernet/sun/cassini.c
@@ -2047,7 +2047,7 @@ static int cas_rx_process_pkt(struct cas *cp, struct cas_rx_comp *rxc,
 
 		__skb_frag_set_page(frag, page->buffer);
 		__skb_frag_ref(frag);
-		frag->page_offset = off;
+		skb_frag_off_set(frag, off);
 		skb_frag_size_set(frag, hlen - swivel);
 
 		/* any more data? */
@@ -2071,7 +2071,7 @@ static int cas_rx_process_pkt(struct cas *cp, struct cas_rx_comp *rxc,
 
 			__skb_frag_set_page(frag, page->buffer);
 			__skb_frag_ref(frag);
-			frag->page_offset = 0;
+			skb_frag_off_set(frag, 0);
 			skb_frag_size_set(frag, hlen);
 			RX_USED_ADD(page, hlen + cp->crc_size);
 		}
@@ -2829,7 +2829,7 @@ static inline int cas_xmit_tx_ringN(struct cas *cp, int ring,
 		mapping = skb_frag_dma_map(&cp->pdev->dev, fragp, 0, len,
 					   DMA_TO_DEVICE);
 
-		tabort = cas_calc_tabort(cp, fragp->page_offset, len);
+		tabort = cas_calc_tabort(cp, skb_frag_off(fragp), len);
 		if (unlikely(tabort)) {
 			void *addr;
 
@@ -2840,7 +2840,7 @@ static inline int cas_xmit_tx_ringN(struct cas *cp, int ring,
 
 			addr = cas_page_map(skb_frag_page(fragp));
 			memcpy(tx_tiny_buf(cp, ring, entry),
-			       addr + fragp->page_offset + len - tabort,
+			       addr + skb_frag_off(fragp) + len - tabort,
 			       tabort);
 			cas_page_unmap(addr);
 			mapping = tx_tiny_map(cp, ring, entry, tentry);
diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c
index 88c12474a0c3..6f5d6450b50d 100644
--- a/drivers/net/ethernet/sun/niu.c
+++ b/drivers/net/ethernet/sun/niu.c
@@ -6713,7 +6713,7 @@ static netdev_tx_t niu_start_xmit(struct sk_buff *skb,
 
 		len = skb_frag_size(frag);
 		mapping = np->ops->map_page(np->device, skb_frag_page(frag),
-					    frag->page_offset, len,
+					    skb_frag_off(frag), len,
 					    DMA_TO_DEVICE);
 
 		rp->tx_buffs[prod].skb = NULL;
diff --git a/drivers/net/ethernet/sun/sunvnet_common.c b/drivers/net/ethernet/sun/sunvnet_common.c
index d8f4c3f28150..1d074d383f3d 100644
--- a/drivers/net/ethernet/sun/sunvnet_common.c
+++ b/drivers/net/ethernet/sun/sunvnet_common.c
@@ -1088,7 +1088,7 @@ static inline int vnet_skb_map(struct ldc_channel *lp, struct sk_buff *skb,
 			vaddr = kmap_atomic(skb_frag_page(f));
 			blen = skb_frag_size(f);
 			blen += 8 - (blen & 7);
-			err = ldc_map_single(lp, vaddr + f->page_offset,
+			err = ldc_map_single(lp, vaddr + skb_frag_off(f),
 					     blen, cookies + nc, ncookies - nc,
 					     map_perm);
 			kunmap_atomic(vaddr);
@@ -1124,7 +1124,7 @@ static inline struct sk_buff *vnet_skb_shape(struct sk_buff *skb, int ncookies)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		skb_frag_t *f = &skb_shinfo(skb)->frags[i];
 
-		docopy |= f->page_offset & 7;
+		docopy |= skb_frag_off(f) & 7;
 	}
 	if (((unsigned long)skb->data & 7) != VNET_PACKET_SKIP ||
 	    skb_tailroom(skb) < pad ||
diff --git a/drivers/net/ethernet/ti/netcp_core.c b/drivers/net/ethernet/ti/netcp_core.c
index 2c455bdd6cae..4b18d4733482 100644
--- a/drivers/net/ethernet/ti/netcp_core.c
+++ b/drivers/net/ethernet/ti/netcp_core.c
@@ -1130,7 +1130,7 @@ netcp_tx_map_skb(struct sk_buff *skb, struct netcp_intf *netcp)
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		struct page *page = skb_frag_page(frag);
-		u32 page_offset = frag->page_offset;
+		u32 page_offset = skb_frag_off(frag);
 		u32 buf_len = skb_frag_size(frag);
 		dma_addr_t desc_dma;
 		u32 desc_dma_32;
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index b8479569f99f..3debb26ff52d 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -448,7 +448,7 @@ static u32 init_page_array(void *hdr, u32 len, struct sk_buff *skb,
 		skb_frag_t *frag = skb_shinfo(skb)->frags + i;
 
 		slots_used += fill_pg_buf(skb_frag_page(frag),
-					frag->page_offset,
+					skb_frag_off(frag),
 					skb_frag_size(frag), &pb[slots_used]);
 	}
 	return slots_used;
@@ -462,7 +462,7 @@ static int count_skb_frag_slots(struct sk_buff *skb)
 	for (i = 0; i < frags; i++) {
 		skb_frag_t *frag = skb_shinfo(skb)->frags + i;
 		unsigned long size = skb_frag_size(frag);
-		unsigned long offset = frag->page_offset;
+		unsigned long offset = skb_frag_off(frag);
 
 		/* Skip unused frames from start of page */
 		offset &= ~PAGE_MASK;
diff --git a/drivers/net/thunderbolt.c b/drivers/net/thunderbolt.c
index e0d6760f3219..dba082b58312 100644
--- a/drivers/net/thunderbolt.c
+++ b/drivers/net/thunderbolt.c
@@ -1008,7 +1008,7 @@ static void *tbnet_kmap_frag(struct sk_buff *skb, unsigned int frag_num,
 	const skb_frag_t *frag = &skb_shinfo(skb)->frags[frag_num];
 
 	*len = skb_frag_size(frag);
-	return kmap_atomic(skb_frag_page(frag)) + frag->page_offset;
+	return kmap_atomic(skb_frag_page(frag)) + skb_frag_off(frag);
 }
 
 static netdev_tx_t tbnet_start_xmit(struct sk_buff *skb,
* Unmerged path drivers/net/usb/usbnet.c
diff --git a/drivers/net/vmxnet3/vmxnet3_drv.c b/drivers/net/vmxnet3/vmxnet3_drv.c
index f08936e85dc8..4ac6a348e86e 100644
--- a/drivers/net/vmxnet3/vmxnet3_drv.c
+++ b/drivers/net/vmxnet3/vmxnet3_drv.c
@@ -663,7 +663,7 @@ vmxnet3_append_frag(struct sk_buff *skb, struct Vmxnet3_RxCompDesc *rcd,
 	BUG_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS);
 
 	__skb_frag_set_page(frag, rbi->page);
-	frag->page_offset = 0;
+	skb_frag_off_set(frag, 0);
 	skb_frag_size_set(frag, rcd->len);
 	skb->data_len += rcd->len;
 	skb->truesize += PAGE_SIZE;
* Unmerged path drivers/net/xen-netback/netback.c
diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c
index 9407acbd19a9..190aa07f05fc 100644
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@ -533,7 +533,7 @@ static int xennet_count_skb_slots(struct sk_buff *skb)
 	for (i = 0; i < frags; i++) {
 		skb_frag_t *frag = skb_shinfo(skb)->frags + i;
 		unsigned long size = skb_frag_size(frag);
-		unsigned long offset = frag->page_offset;
+		unsigned long offset = skb_frag_off(frag);
 
 		/* Skip unused frames from start of page */
 		offset &= ~PAGE_MASK;
@@ -677,8 +677,8 @@ static netdev_tx_t xennet_start_xmit(struct sk_buff *skb, struct net_device *dev
 	/* Requests for all the frags. */
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
-		tx = xennet_make_txreqs(queue, tx, skb,
-					skb_frag_page(frag), frag->page_offset,
+		tx = xennet_make_txreqs(queue, tx, skb, skb_frag_page(frag),
+					skb_frag_off(frag),
 					skb_frag_size(frag));
 	}
 
@@ -1039,7 +1039,7 @@ static int xennet_poll(struct napi_struct *napi, int budget)
 		if (NETFRONT_SKB_CB(skb)->pull_to > RX_COPY_THRESHOLD)
 			NETFRONT_SKB_CB(skb)->pull_to = RX_COPY_THRESHOLD;
 
-		skb_shinfo(skb)->frags[0].page_offset = rx->offset;
+		skb_frag_off_set(&skb_shinfo(skb)->frags[0], rx->offset);
 		skb_frag_size_set(&skb_shinfo(skb)->frags[0], rx->status);
 		skb->data_len = rx->status;
 		skb->len += rx->status;
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 41e782c2f2a4..8ccff44ff8e9 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -346,7 +346,7 @@ static int bnx2fc_xmit(struct fc_lport *lport, struct fc_frame *fp)
 			return -ENOMEM;
 		}
 		frag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];
-		cp = kmap_atomic(skb_frag_page(frag)) + frag->page_offset;
+		cp = kmap_atomic(skb_frag_page(frag)) + skb_frag_off(frag);
 	} else {
 		cp = skb_put(skb, tlen);
 	}
diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index f46b312d04bc..4dbc4a8d0ae3 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -1535,8 +1535,7 @@ static int fcoe_xmit(struct fc_lport *lport, struct fc_frame *fp)
 			return -ENOMEM;
 		}
 		frag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];
-		cp = kmap_atomic(skb_frag_page(frag))
-			+ frag->page_offset;
+		cp = kmap_atomic(skb_frag_page(frag)) + skb_frag_off(frag);
 	} else {
 		cp = skb_put(skb, tlen);
 	}
diff --git a/drivers/scsi/fcoe/fcoe_transport.c b/drivers/scsi/fcoe/fcoe_transport.c
index f4909cd206d3..8d978288a206 100644
--- a/drivers/scsi/fcoe/fcoe_transport.c
+++ b/drivers/scsi/fcoe/fcoe_transport.c
@@ -330,7 +330,7 @@ u32 fcoe_fc_crc(struct fc_frame *fp)
 
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		frag = &skb_shinfo(skb)->frags[i];
-		off = frag->page_offset;
+		off = skb_frag_off(frag);
 		len = skb_frag_size(frag);
 		while (len > 0) {
 			clen = min(len, PAGE_SIZE - (off & ~PAGE_MASK));
diff --git a/drivers/scsi/qedf/qedf_main.c b/drivers/scsi/qedf/qedf_main.c
index d65c2749b0ad..c4585b5b3c89 100644
--- a/drivers/scsi/qedf/qedf_main.c
+++ b/drivers/scsi/qedf/qedf_main.c
@@ -1105,7 +1105,7 @@ static int qedf_xmit(struct fc_lport *lport, struct fc_frame *fp)
 			return -ENOMEM;
 		}
 		frag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];
-		cp = kmap_atomic(skb_frag_page(frag)) + frag->page_offset;
+		cp = kmap_atomic(skb_frag_page(frag)) + skb_frag_off(frag);
 	} else {
 		cp = skb_put(skb, tlen);
 	}
* Unmerged path drivers/staging/unisys/visornic/visornic_main.c
* Unmerged path drivers/target/iscsi/cxgbit/cxgbit_target.c
diff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c
index 9b6bc5abe946..2aa8f6e3db91 100644
--- a/net/appletalk/ddp.c
+++ b/net/appletalk/ddp.c
@@ -958,8 +958,8 @@ static unsigned long atalk_sum_skb(const struct sk_buff *skb, int offset,
 			if (copy > len)
 				copy = len;
 			vaddr = kmap_atomic(skb_frag_page(frag));
-			sum = atalk_sum_partial(vaddr + frag->page_offset +
-						  offset - start, copy, sum);
+			sum = atalk_sum_partial(vaddr + skb_frag_off(frag) +
+						offset - start, copy, sum);
 			kunmap_atomic(vaddr);
 
 			if (!(len -= copy))
diff --git a/net/core/datagram.c b/net/core/datagram.c
index c733072e8ccb..11eb90c7a5a5 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -443,8 +443,8 @@ int __skb_datagram_iter(const struct sk_buff *skb, int offset,
 
 			if (copy > len)
 				copy = len;
-			n = cb(vaddr + frag->page_offset +
-				offset - start, copy, data, to);
+			n = cb(vaddr + skb_frag_off(frag) + offset - start,
+			       copy, data, to);
 			kunmap(page);
 			offset += n;
 			if (n != copy)
@@ -574,7 +574,7 @@ int skb_copy_datagram_from_iter(struct sk_buff *skb, int offset,
 			if (copy > len)
 				copy = len;
 			copied = copy_page_from_iter(skb_frag_page(frag),
-					  frag->page_offset + offset - start,
+					  skb_frag_off(frag) + offset - start,
 					  copy, from);
 			if (copied != copy)
 				goto fault;
diff --git a/net/core/dev.c b/net/core/dev.c
index 72f1708ed697..cc788f5e5c03 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -5279,7 +5279,7 @@ static void gro_pull_from_frag0(struct sk_buff *skb, int grow)
 	skb->data_len -= grow;
 	skb->tail += grow;
 
-	pinfo->frags[0].page_offset += grow;
+	skb_frag_off_add(&pinfo->frags[0], grow);
 	skb_frag_size_sub(&pinfo->frags[0], grow);
 
 	if (unlikely(!skb_frag_size(&pinfo->frags[0]))) {
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index ee8c1f58491b..9fd59b0447d4 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -2660,7 +2660,7 @@ static void pktgen_finalize_skb(struct pktgen_dev *pkt_dev, struct sk_buff *skb,
 			}
 			get_page(pkt_dev->page);
 			skb_frag_set_page(skb, i, pkt_dev->page);
-			skb_shinfo(skb)->frags[i].page_offset = 0;
+			skb_frag_off_set(&skb_shinfo(skb)->frags[i], 0);
 			/*last fragment, fill rest of data*/
 			if (i == (frags - 1))
 				skb_frag_size_set(&skb_shinfo(skb)->frags[i],
* Unmerged path net/core/skbuff.c
* Unmerged path net/ipv4/tcp.c
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 97e11e678888..04167428bbcf 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1416,7 +1416,7 @@ static int __pskb_trim_head(struct sk_buff *skb, int len)
 		} else {
 			shinfo->frags[k] = shinfo->frags[i];
 			if (eat) {
-				shinfo->frags[k].page_offset += eat;
+				skb_frag_off_add(&shinfo->frags[k], eat);
 				skb_frag_size_sub(&shinfo->frags[k], eat);
 				eat = 0;
 			}
* Unmerged path net/kcm/kcmsock.c
* Unmerged path net/tls/tls_device.c
diff --git a/net/tls/tls_device_fallback.c b/net/tls/tls_device_fallback.c
index ec381f37ba34..7b7f2beb1089 100644
--- a/net/tls/tls_device_fallback.c
+++ b/net/tls/tls_device_fallback.c
@@ -274,7 +274,7 @@ static int fill_sg_in(struct scatterlist *sg_in,
 
 		__skb_frag_ref(frag);
 		sg_set_page(sg_in + i, skb_frag_page(frag),
-			    skb_frag_size(frag), frag->page_offset);
+			    skb_frag_size(frag), skb_frag_off(frag));
 
 		remaining -= skb_frag_size(frag);
 
diff --git a/net/xfrm/xfrm_ipcomp.c b/net/xfrm/xfrm_ipcomp.c
index a00ec715aa46..2c30cd59bb4a 100644
--- a/net/xfrm/xfrm_ipcomp.c
+++ b/net/xfrm/xfrm_ipcomp.c
@@ -89,7 +89,7 @@ static int ipcomp_decompress(struct xfrm_state *x, struct sk_buff *skb)
 		if (dlen < len)
 			len = dlen;
 
-		frag->page_offset = 0;
+		skb_frag_off_set(frag, 0);
 		skb_frag_size_set(frag, len);
 		memcpy(skb_frag_address(frag), scratch, len);
 
