bnxt_en: Add devlink health reset reporter.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add devlink health reset reporter (Jonathan Toppins) [1724766]
Rebuild_FUZZ: 98.82%
commit-author Vasundhara Volam <vasundhara-v.volam@broadcom.com>
commit 657a33c8a0a2342e91259b28356838dc89216b19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/657a33c8.failed

Add devlink health reporter for the firmware reset event.  Once we get
the notification from firmware about the impending reset, the driver
will report this to devlink and the call to bnxt_fw_reset() will be
initiated to complete the reset sequence.

	Cc: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 657a33c8a0a2342e91259b28356838dc89216b19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index bd05f81be6ab,d65625fc3183..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1325,6 -1346,52 +1325,55 @@@ struct bnxt_ctx_mem_info 
  	struct bnxt_ctx_pg_info *tqm_mem[9];
  };
  
++<<<<<<< HEAD
++=======
+ struct bnxt_fw_health {
+ 	u32 flags;
+ 	u32 polling_dsecs;
+ 	u32 master_func_wait_dsecs;
+ 	u32 normal_func_wait_dsecs;
+ 	u32 post_reset_wait_dsecs;
+ 	u32 post_reset_max_wait_dsecs;
+ 	u32 regs[4];
+ 	u32 mapped_regs[4];
+ #define BNXT_FW_HEALTH_REG		0
+ #define BNXT_FW_HEARTBEAT_REG		1
+ #define BNXT_FW_RESET_CNT_REG		2
+ #define BNXT_FW_RESET_INPROG_REG	3
+ 	u32 fw_reset_inprog_reg_mask;
+ 	u32 last_fw_heartbeat;
+ 	u32 last_fw_reset_cnt;
+ 	u8 enabled:1;
+ 	u8 master:1;
+ 	u8 tmr_multiplier;
+ 	u8 tmr_counter;
+ 	u8 fw_reset_seq_cnt;
+ 	u32 fw_reset_seq_regs[16];
+ 	u32 fw_reset_seq_vals[16];
+ 	u32 fw_reset_seq_delay_msec[16];
+ 	struct devlink_health_reporter	*fw_reporter;
+ 	struct devlink_health_reporter *fw_reset_reporter;
+ };
+ 
+ struct bnxt_fw_reporter_ctx {
+ 	unsigned long sp_event;
+ };
+ 
+ #define BNXT_FW_HEALTH_REG_TYPE_MASK	3
+ #define BNXT_FW_HEALTH_REG_TYPE_CFG	0
+ #define BNXT_FW_HEALTH_REG_TYPE_GRC	1
+ #define BNXT_FW_HEALTH_REG_TYPE_BAR0	2
+ #define BNXT_FW_HEALTH_REG_TYPE_BAR1	3
+ 
+ #define BNXT_FW_HEALTH_REG_TYPE(reg)	((reg) & BNXT_FW_HEALTH_REG_TYPE_MASK)
+ #define BNXT_FW_HEALTH_REG_OFF(reg)	((reg) & ~BNXT_FW_HEALTH_REG_TYPE_MASK)
+ 
+ #define BNXT_FW_HEALTH_WIN_BASE		0x3000
+ #define BNXT_FW_HEALTH_WIN_MAP_OFF	8
+ 
+ #define BNXT_FW_STATUS_HEALTHY		0x8000
+ 
++>>>>>>> 657a33c8a0a2 (bnxt_en: Add devlink health reset reporter.)
  struct bnxt {
  	void __iomem		*bar0;
  	void __iomem		*bar1;
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
index 336fbceafb45,8512467c2134..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
@@@ -15,6 -15,136 +15,139 @@@
  #include "bnxt_vfr.h"
  #include "bnxt_devlink.h"
  
++<<<<<<< HEAD
++=======
+ static int bnxt_fw_reporter_diagnose(struct devlink_health_reporter *reporter,
+ 				     struct devlink_fmsg *fmsg)
+ {
+ 	struct bnxt *bp = devlink_health_reporter_priv(reporter);
+ 	struct bnxt_fw_health *health = bp->fw_health;
+ 	u32 val, health_status;
+ 	int rc;
+ 
+ 	if (!health || test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 		return 0;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
+ 	health_status = val & 0xffff;
+ 
+ 	if (health_status == BNXT_FW_STATUS_HEALTHY) {
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "FW status",
+ 						  "Healthy;");
+ 		if (rc)
+ 			return rc;
+ 	} else if (health_status < BNXT_FW_STATUS_HEALTHY) {
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "FW status",
+ 						  "Not yet completed initialization;");
+ 		if (rc)
+ 			return rc;
+ 	} else if (health_status > BNXT_FW_STATUS_HEALTHY) {
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "FW status",
+ 						  "Encountered fatal error and cannot recover;");
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	if (val >> 16) {
+ 		rc = devlink_fmsg_u32_pair_put(fmsg, "Error", val >> 16);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
+ 	rc = devlink_fmsg_u32_pair_put(fmsg, "Reset count", val);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return 0;
+ }
+ 
+ static const struct devlink_health_reporter_ops bnxt_dl_fw_reporter_ops = {
+ 	.name = "fw",
+ 	.diagnose = bnxt_fw_reporter_diagnose,
+ };
+ 
+ static int bnxt_fw_reset_recover(struct devlink_health_reporter *reporter,
+ 				 void *priv_ctx)
+ {
+ 	struct bnxt *bp = devlink_health_reporter_priv(reporter);
+ 
+ 	if (!priv_ctx)
+ 		return -EOPNOTSUPP;
+ 
+ 	bnxt_fw_reset(bp);
+ 	return 0;
+ }
+ 
+ static const
+ struct devlink_health_reporter_ops bnxt_dl_fw_reset_reporter_ops = {
+ 	.name = "fw_reset",
+ 	.recover = bnxt_fw_reset_recover,
+ };
+ 
+ static void bnxt_dl_fw_reporters_create(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *health = bp->fw_health;
+ 
+ 	if (!health)
+ 		return;
+ 
+ 	health->fw_reporter =
+ 		devlink_health_reporter_create(bp->dl, &bnxt_dl_fw_reporter_ops,
+ 					       0, false, bp);
+ 	if (IS_ERR(health->fw_reporter)) {
+ 		netdev_warn(bp->dev, "Failed to create FW health reporter, rc = %ld\n",
+ 			    PTR_ERR(health->fw_reporter));
+ 		health->fw_reporter = NULL;
+ 	}
+ 
+ 	health->fw_reset_reporter =
+ 		devlink_health_reporter_create(bp->dl,
+ 					       &bnxt_dl_fw_reset_reporter_ops,
+ 					       0, true, bp);
+ 	if (IS_ERR(health->fw_reset_reporter)) {
+ 		netdev_warn(bp->dev, "Failed to create FW fatal health reporter, rc = %ld\n",
+ 			    PTR_ERR(health->fw_reset_reporter));
+ 		health->fw_reset_reporter = NULL;
+ 	}
+ }
+ 
+ static void bnxt_dl_fw_reporters_destroy(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *health = bp->fw_health;
+ 
+ 	if (!health)
+ 		return;
+ 
+ 	if (health->fw_reporter)
+ 		devlink_health_reporter_destroy(health->fw_reporter);
+ 
+ 	if (health->fw_reset_reporter)
+ 		devlink_health_reporter_destroy(health->fw_reset_reporter);
+ }
+ 
+ void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	struct bnxt_fw_reporter_ctx fw_reporter_ctx;
+ 
+ 	if (!fw_health)
+ 		return;
+ 
+ 	fw_reporter_ctx.sp_event = event;
+ 	switch (event) {
+ 	case BNXT_FW_RESET_NOTIFY_SP_EVENT:
+ 		if (!fw_health->fw_reset_reporter)
+ 			return;
+ 
+ 		devlink_health_report(fw_health->fw_reset_reporter,
+ 				      "FW non-fatal reset event received",
+ 				      &fw_reporter_ctx);
+ 		return;
+ 	}
+ }
+ 
++>>>>>>> 657a33c8a0a2 (bnxt_en: Add devlink health reset reporter.)
  static const struct devlink_ops bnxt_dl_ops = {
  #ifdef CONFIG_BNXT_SRIOV
  	.eswitch_mode_set = bnxt_dl_eswitch_mode_set,
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 5b5a34df2263..7d00e3de9ce7 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -9666,6 +9666,9 @@ static void bnxt_sp_task(struct work_struct *work)
 	if (test_and_clear_bit(BNXT_RESET_TASK_SILENT_SP_EVENT, &bp->sp_event))
 		bnxt_reset(bp, true);
 
+	if (test_and_clear_bit(BNXT_FW_RESET_NOTIFY_SP_EVENT, &bp->sp_event))
+		bnxt_devlink_health_report(bp, BNXT_FW_RESET_NOTIFY_SP_EVENT);
+
 	smp_mb__before_atomic();
 	clear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);
 }
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
index 5b6b2c7d97cf..b97e0baeb42d 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
@@ -55,6 +55,7 @@ struct bnxt_dl_nvm_param {
 	u16 num_bits;
 };
 
+void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event);
 int bnxt_dl_register(struct bnxt *bp);
 void bnxt_dl_unregister(struct bnxt *bp);
 
