net/mlx5: Split mdev init and pci init

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Split mdev init and pci init (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 94.44%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 11f3b84d7068397df9f329b8bcf1177507061938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/11f3b84d.failed

Separate resources initialization from pci initialization.

This provides a better logical separation of mlx5 core device
initialization flow and will help to seamlessly support creating different
mlx5 device types such as PF, VF and SF mlx5 sub-function virtual device.

This patch does not change any functionality.

	Signed-off-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 11f3b84d7068397df9f329b8bcf1177507061938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index 10376022a40f,e26246eacea5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -716,50 -729,16 +716,52 @@@ static int mlx5_core_set_issi(struct ml
  	return -EOPNOTSUPP;
  }
  
++<<<<<<< HEAD
 +/* PCI table of mlx5 devices that are tech preview in RHEL */
 +static const struct pci_device_id mlx5_core_hw_unsupp_pci_table[] = {
 +	{ PCI_VDEVICE(MELLANOX, 0x101d) },			/* ConnectX-6 Dx */
 +	{ PCI_VDEVICE(MELLANOX, 0x101e), MLX5_PCI_DEV_IS_VF},	/* ConnectX Family mlx5Gen Virtual Function */
 +	{ 0, }
 +};
 +
 +static char mlx5_pci_id[32]; /* more than enough space */
 +/*
 + * Function to check if an mlx5 device is tech-preview.
 + * If so, print out message and mark accordingly.
 + *
 + * most of it stolen from pci_match_device() in drivers/pci/pci-drivers.c
 + *
 + */
 +static void mlx5_check_hw_unsupp_status(struct pci_dev *pdev)
 +{
 +	const struct pci_device_id *found_id = NULL;
 +
 +	found_id = pci_match_id(mlx5_core_hw_unsupp_pci_table, pdev);
 +
 +	if (found_id) {
 +		sprintf(mlx5_pci_id, "%s: %04x:%02x:%02x.%01x\n", "pci-device",
 +				pci_domain_nr(pdev->bus), pdev->bus->number,
 +				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 +		/* mark-hw-unsupported doesn't taint kernel; just prints warning */
 +		mark_hardware_unsupported(mlx5_pci_id);
 +	}
 +}
 +
 +static int mlx5_pci_init(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
 +{
 +	struct pci_dev *pdev = dev->pdev;
++=======
+ static int mlx5_pci_init(struct mlx5_core_dev *dev, struct pci_dev *pdev,
+ 			 const struct pci_device_id *id)
+ {
+ 	struct mlx5_priv *priv = &dev->priv;
++>>>>>>> 11f3b84d7068 (net/mlx5: Split mdev init and pci init)
  	int err = 0;
  
- 	pci_set_drvdata(dev->pdev, dev);
- 	strncpy(priv->name, dev_name(&pdev->dev), MLX5_MAX_NAME_LEN);
- 	priv->name[MLX5_MAX_NAME_LEN - 1] = 0;
- 
- 	mutex_init(&priv->pgdir_mutex);
- 	INIT_LIST_HEAD(&priv->pgdir_list);
- 	spin_lock_init(&priv->mkey_lock);
+ 	dev->pdev = pdev;
+ 	priv->pci_dev_data = id->driver_data;
  
- 	mutex_init(&priv->alloc_mutex);
+ 	pci_set_drvdata(dev->pdev, dev);
  
  	priv->numa_node = dev_to_node(&dev->pdev->dev);
  
@@@ -820,10 -791,9 +815,13 @@@ static void mlx5_pci_close(struct mlx5_
  	pci_clear_master(dev->pdev);
  	release_bar(dev->pdev);
  	mlx5_pci_disable_device(dev);
++<<<<<<< HEAD
 +	debugfs_remove_recursive(priv->dbg_root);
++=======
++>>>>>>> 11f3b84d7068 (net/mlx5: Split mdev init and pci init)
  }
  
 -static int mlx5_init_once(struct mlx5_core_dev *dev)
 +static int mlx5_init_once(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
  {
  	struct pci_dev *pdev = dev->pdev;
  	int err;
@@@ -1283,10 -1236,48 +1266,52 @@@ static int mlx5_mdev_init(struct mlx5_c
  	INIT_LIST_HEAD(&priv->bfregs.reg_head.list);
  	INIT_LIST_HEAD(&priv->bfregs.wc_head.list);
  
++<<<<<<< HEAD
 +	err = mlx5_pci_init(dev, priv);
++=======
+ 	mutex_init(&priv->alloc_mutex);
+ 	mutex_init(&priv->pgdir_mutex);
+ 	INIT_LIST_HEAD(&priv->pgdir_list);
+ 	spin_lock_init(&priv->mkey_lock);
+ 
+ 	priv->dbg_root = debugfs_create_dir(name, mlx5_debugfs_root);
+ 	if (!priv->dbg_root) {
+ 		pr_err("mlx5_core: %s error, Cannot create debugfs dir, aborting\n", name);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void mlx5_mdev_uninit(struct mlx5_core_dev *dev)
+ {
+ 	debugfs_remove_recursive(dev->priv.dbg_root);
+ }
+ 
+ #define MLX5_IB_MOD "mlx5_ib"
+ static int init_one(struct pci_dev *pdev, const struct pci_device_id *id)
+ {
+ 	struct mlx5_core_dev *dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = devlink_alloc(&mlx5_devlink_ops, sizeof(*dev));
+ 	if (!devlink) {
+ 		dev_err(&pdev->dev, "kzalloc failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	dev = devlink_priv(devlink);
+ 
+ 	err = mlx5_mdev_init(dev, prof_sel, dev_name(&pdev->dev));
+ 	if (err)
+ 		goto mdev_init_err;
+ 
+ 	err = mlx5_pci_init(dev, pdev, id);
++>>>>>>> 11f3b84d7068 (net/mlx5: Split mdev init and pci init)
  	if (err) {
  		dev_err(&pdev->dev, "mlx5_pci_init failed with error code %d\n", err);
- 		goto clean_dev;
+ 		goto pci_init_err;
  	}
  
  	err = mlx5_health_init(dev);
@@@ -1321,8 -1312,10 +1346,15 @@@ err_load_one
  err_pagealloc_init:
  	mlx5_health_cleanup(dev);
  close_pci:
++<<<<<<< HEAD
 +	mlx5_pci_close(dev, priv);
 +clean_dev:
++=======
+ 	mlx5_pci_close(dev);
+ pci_init_err:
+ 	mlx5_mdev_uninit(dev);
+ mdev_init_err:
++>>>>>>> 11f3b84d7068 (net/mlx5: Split mdev init and pci init)
  	devlink_free(devlink);
  
  	return err;
@@@ -1345,7 -1337,8 +1377,12 @@@ static void remove_one(struct pci_dev *
  
  	mlx5_pagealloc_cleanup(dev);
  	mlx5_health_cleanup(dev);
++<<<<<<< HEAD
 +	mlx5_pci_close(dev, priv);
++=======
+ 	mlx5_pci_close(dev);
+ 	mlx5_mdev_uninit(dev);
++>>>>>>> 11f3b84d7068 (net/mlx5: Split mdev init and pci init)
  	devlink_free(devlink);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
