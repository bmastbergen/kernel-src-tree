sunrpc: remove unused bc_up operation from rpc_xprt_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Vasily Averin <vvs@virtuozzo.com>
commit 4aa5cffefa6f8af8f16490df58b8f0d827911b58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4aa5cffe.failed

	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 4aa5cffefa6f8af8f16490df58b8f0d827911b58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index da4215b1fa21,5b392b3df90a..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -1162,274 -1404,7 +1162,277 @@@ static void xs_tcp_force_close(struct r
  	xprt_force_disconnect(xprt);
  }
  
 +static inline void xs_tcp_read_fraghdr(struct rpc_xprt *xprt, struct xdr_skb_reader *desc)
 +{
 +	struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
 +	size_t len, used;
 +	char *p;
 +
 +	p = ((char *) &transport->recv.fraghdr) + transport->recv.offset;
 +	len = sizeof(transport->recv.fraghdr) - transport->recv.offset;
 +	used = xdr_skb_read_bits(desc, p, len);
 +	transport->recv.offset += used;
 +	if (used != len)
 +		return;
 +
 +	transport->recv.len = ntohl(transport->recv.fraghdr);
 +	if (transport->recv.len & RPC_LAST_STREAM_FRAGMENT)
 +		transport->recv.flags |= TCP_RCV_LAST_FRAG;
 +	else
 +		transport->recv.flags &= ~TCP_RCV_LAST_FRAG;
 +	transport->recv.len &= RPC_FRAGMENT_SIZE_MASK;
 +
 +	transport->recv.flags &= ~TCP_RCV_COPY_FRAGHDR;
 +	transport->recv.offset = 0;
 +
 +	/* Sanity check of the record length */
 +	if (unlikely(transport->recv.len < 8)) {
 +		dprintk("RPC:       invalid TCP record fragment length\n");
 +		xs_tcp_force_close(xprt);
 +		return;
 +	}
 +	dprintk("RPC:       reading TCP record fragment of length %d\n",
 +			transport->recv.len);
 +}
 +
 +static void xs_tcp_check_fraghdr(struct sock_xprt *transport)
 +{
 +	if (transport->recv.offset == transport->recv.len) {
 +		transport->recv.flags |= TCP_RCV_COPY_FRAGHDR;
 +		transport->recv.offset = 0;
 +		if (transport->recv.flags & TCP_RCV_LAST_FRAG) {
 +			transport->recv.flags &= ~TCP_RCV_COPY_DATA;
 +			transport->recv.flags |= TCP_RCV_COPY_XID;
 +			transport->recv.copied = 0;
 +		}
 +	}
 +}
 +
 +static inline void xs_tcp_read_xid(struct sock_xprt *transport, struct xdr_skb_reader *desc)
 +{
 +	size_t len, used;
 +	char *p;
 +
 +	len = sizeof(transport->recv.xid) - transport->recv.offset;
 +	dprintk("RPC:       reading XID (%zu bytes)\n", len);
 +	p = ((char *) &transport->recv.xid) + transport->recv.offset;
 +	used = xdr_skb_read_bits(desc, p, len);
 +	transport->recv.offset += used;
 +	if (used != len)
 +		return;
 +	transport->recv.flags &= ~TCP_RCV_COPY_XID;
 +	transport->recv.flags |= TCP_RCV_READ_CALLDIR;
 +	transport->recv.copied = 4;
 +	dprintk("RPC:       reading %s XID %08x\n",
 +			(transport->recv.flags & TCP_RPC_REPLY) ? "reply for"
 +							      : "request with",
 +			ntohl(transport->recv.xid));
 +	xs_tcp_check_fraghdr(transport);
 +}
 +
 +static inline void xs_tcp_read_calldir(struct sock_xprt *transport,
 +				       struct xdr_skb_reader *desc)
 +{
 +	size_t len, used;
 +	u32 offset;
 +	char *p;
 +
 +	/*
 +	 * We want transport->recv.offset to be 8 at the end of this routine
 +	 * (4 bytes for the xid and 4 bytes for the call/reply flag).
 +	 * When this function is called for the first time,
 +	 * transport->recv.offset is 4 (after having already read the xid).
 +	 */
 +	offset = transport->recv.offset - sizeof(transport->recv.xid);
 +	len = sizeof(transport->recv.calldir) - offset;
 +	dprintk("RPC:       reading CALL/REPLY flag (%zu bytes)\n", len);
 +	p = ((char *) &transport->recv.calldir) + offset;
 +	used = xdr_skb_read_bits(desc, p, len);
 +	transport->recv.offset += used;
 +	if (used != len)
 +		return;
 +	transport->recv.flags &= ~TCP_RCV_READ_CALLDIR;
 +	/*
 +	 * We don't yet have the XDR buffer, so we will write the calldir
 +	 * out after we get the buffer from the 'struct rpc_rqst'
 +	 */
 +	switch (ntohl(transport->recv.calldir)) {
 +	case RPC_REPLY:
 +		transport->recv.flags |= TCP_RCV_COPY_CALLDIR;
 +		transport->recv.flags |= TCP_RCV_COPY_DATA;
 +		transport->recv.flags |= TCP_RPC_REPLY;
 +		break;
 +	case RPC_CALL:
 +		transport->recv.flags |= TCP_RCV_COPY_CALLDIR;
 +		transport->recv.flags |= TCP_RCV_COPY_DATA;
 +		transport->recv.flags &= ~TCP_RPC_REPLY;
 +		break;
 +	default:
 +		dprintk("RPC:       invalid request message type\n");
 +		xs_tcp_force_close(&transport->xprt);
 +	}
 +	xs_tcp_check_fraghdr(transport);
 +}
 +
 +static inline void xs_tcp_read_common(struct rpc_xprt *xprt,
 +				     struct xdr_skb_reader *desc,
 +				     struct rpc_rqst *req)
 +{
 +	struct sock_xprt *transport =
 +				container_of(xprt, struct sock_xprt, xprt);
 +	struct xdr_buf *rcvbuf;
 +	size_t len;
 +	ssize_t r;
 +
 +	rcvbuf = &req->rq_private_buf;
 +
 +	if (transport->recv.flags & TCP_RCV_COPY_CALLDIR) {
 +		/*
 +		 * Save the RPC direction in the XDR buffer
 +		 */
 +		memcpy(rcvbuf->head[0].iov_base + transport->recv.copied,
 +			&transport->recv.calldir,
 +			sizeof(transport->recv.calldir));
 +		transport->recv.copied += sizeof(transport->recv.calldir);
 +		transport->recv.flags &= ~TCP_RCV_COPY_CALLDIR;
 +	}
 +
 +	len = desc->count;
 +	if (len > transport->recv.len - transport->recv.offset)
 +		desc->count = transport->recv.len - transport->recv.offset;
 +	r = xdr_partial_copy_from_skb(rcvbuf, transport->recv.copied,
 +					  desc, xdr_skb_read_bits);
 +
 +	if (desc->count) {
 +		/* Error when copying to the receive buffer,
 +		 * usually because we weren't able to allocate
 +		 * additional buffer pages. All we can do now
 +		 * is turn off TCP_RCV_COPY_DATA, so the request
 +		 * will not receive any additional updates,
 +		 * and time out.
 +		 * Any remaining data from this record will
 +		 * be discarded.
 +		 */
 +		transport->recv.flags &= ~TCP_RCV_COPY_DATA;
 +		dprintk("RPC:       XID %08x truncated request\n",
 +				ntohl(transport->recv.xid));
 +		dprintk("RPC:       xprt = %p, recv.copied = %lu, "
 +				"recv.offset = %u, recv.len = %u\n",
 +				xprt, transport->recv.copied,
 +				transport->recv.offset, transport->recv.len);
 +		return;
 +	}
 +
 +	transport->recv.copied += r;
 +	transport->recv.offset += r;
 +	desc->count = len - r;
 +
 +	dprintk("RPC:       XID %08x read %zd bytes\n",
 +			ntohl(transport->recv.xid), r);
 +	dprintk("RPC:       xprt = %p, recv.copied = %lu, recv.offset = %u, "
 +			"recv.len = %u\n", xprt, transport->recv.copied,
 +			transport->recv.offset, transport->recv.len);
 +
 +	if (transport->recv.copied == req->rq_private_buf.buflen)
 +		transport->recv.flags &= ~TCP_RCV_COPY_DATA;
 +	else if (transport->recv.offset == transport->recv.len) {
 +		if (transport->recv.flags & TCP_RCV_LAST_FRAG)
 +			transport->recv.flags &= ~TCP_RCV_COPY_DATA;
 +	}
 +}
 +
 +/*
 + * Finds the request corresponding to the RPC xid and invokes the common
 + * tcp read code to read the data.
 + */
 +static inline int xs_tcp_read_reply(struct rpc_xprt *xprt,
 +				    struct xdr_skb_reader *desc)
 +{
 +	struct sock_xprt *transport =
 +				container_of(xprt, struct sock_xprt, xprt);
 +	struct rpc_rqst *req;
 +
 +	dprintk("RPC:       read reply XID %08x\n", ntohl(transport->recv.xid));
 +
 +	/* Find and lock the request corresponding to this xid */
 +	spin_lock(&xprt->recv_lock);
 +	req = xprt_lookup_rqst(xprt, transport->recv.xid);
 +	if (!req) {
 +		dprintk("RPC:       XID %08x request not found!\n",
 +				ntohl(transport->recv.xid));
 +		spin_unlock(&xprt->recv_lock);
 +		return -1;
 +	}
 +	xprt_pin_rqst(req);
 +	spin_unlock(&xprt->recv_lock);
 +
 +	xs_tcp_read_common(xprt, desc, req);
 +
 +	spin_lock(&xprt->recv_lock);
 +	if (!(transport->recv.flags & TCP_RCV_COPY_DATA))
 +		xprt_complete_rqst(req->rq_task, transport->recv.copied);
 +	xprt_unpin_rqst(req);
 +	spin_unlock(&xprt->recv_lock);
 +	return 0;
 +}
 +
  #if defined(CONFIG_SUNRPC_BACKCHANNEL)
++<<<<<<< HEAD
 +/*
 + * Obtains an rpc_rqst previously allocated and invokes the common
 + * tcp read code to read the data.  The result is placed in the callback
 + * queue.
 + * If we're unable to obtain the rpc_rqst we schedule the closing of the
 + * connection and return -1.
 + */
 +static int xs_tcp_read_callback(struct rpc_xprt *xprt,
 +				       struct xdr_skb_reader *desc)
 +{
 +	struct sock_xprt *transport =
 +				container_of(xprt, struct sock_xprt, xprt);
 +	struct rpc_rqst *req;
 +
 +	/* Look up the request corresponding to the given XID */
 +	req = xprt_lookup_bc_request(xprt, transport->recv.xid);
 +	if (req == NULL) {
 +		printk(KERN_WARNING "Callback slot table overflowed\n");
 +		xprt_force_disconnect(xprt);
 +		return -1;
 +	}
 +
 +	dprintk("RPC:       read callback  XID %08x\n", ntohl(req->rq_xid));
 +	xs_tcp_read_common(xprt, desc, req);
 +
 +	if (!(transport->recv.flags & TCP_RCV_COPY_DATA))
 +		xprt_complete_bc_request(req, transport->recv.copied);
 +
 +	return 0;
 +}
 +
 +static inline int _xs_tcp_read_data(struct rpc_xprt *xprt,
 +					struct xdr_skb_reader *desc)
 +{
 +	struct sock_xprt *transport =
 +				container_of(xprt, struct sock_xprt, xprt);
 +
 +	return (transport->recv.flags & TCP_RPC_REPLY) ?
 +		xs_tcp_read_reply(xprt, desc) :
 +		xs_tcp_read_callback(xprt, desc);
 +}
 +
 +static int xs_tcp_bc_up(struct svc_serv *serv, struct net *net)
 +{
 +	int ret;
 +
 +	ret = svc_create_xprt(serv, "tcp-bc", net, PF_INET, 0,
 +			      SVC_SOCK_ANONYMOUS);
 +	if (ret < 0)
 +		return ret;
 +	return 0;
 +}
 +
++=======
++>>>>>>> 4aa5cffefa6f (sunrpc: remove unused bc_up operation from rpc_xprt_ops)
  static size_t xs_tcp_bc_maxpayload(struct rpc_xprt *xprt)
  {
  	return PAGE_SIZE;
diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index e7472a422479..3327c5a090a3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -149,7 +149,6 @@ struct rpc_xprt_ops {
 	void		(*inject_disconnect)(struct rpc_xprt *xprt);
 	int		(*bc_setup)(struct rpc_xprt *xprt,
 				    unsigned int min_reqs);
-	int		(*bc_up)(struct svc_serv *serv, struct net *net);
 	size_t		(*bc_maxpayload)(struct rpc_xprt *xprt);
 	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
 	void		(*bc_destroy)(struct rpc_xprt *xprt,
diff --git a/net/sunrpc/xprtrdma/backchannel.c b/net/sunrpc/xprtrdma/backchannel.c
index d21c49c1fa08..031e388d9f33 100644
--- a/net/sunrpc/xprtrdma/backchannel.c
+++ b/net/sunrpc/xprtrdma/backchannel.c
@@ -99,26 +99,6 @@ int xprt_rdma_bc_setup(struct rpc_xprt *xprt, unsigned int reqs)
 	return -ENOMEM;
 }
 
-/**
- * xprt_rdma_bc_up - Create transport endpoint for backchannel service
- * @serv: server endpoint
- * @net: network namespace
- *
- * The "xprt" is an implied argument: it supplies the name of the
- * backchannel transport class.
- *
- * Returns zero on success, negative errno on failure
- */
-int xprt_rdma_bc_up(struct svc_serv *serv, struct net *net)
-{
-	int ret;
-
-	ret = svc_create_xprt(serv, "rdma-bc", net, PF_INET, 0, 0);
-	if (ret < 0)
-		return ret;
-	return 0;
-}
-
 /**
  * xprt_rdma_bc_maxpayload - Return maximum backchannel message size
  * @xprt: transport
diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index 112d4b459fc7..9fc0b2082520 100644
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -830,7 +830,6 @@ static const struct rpc_xprt_ops xprt_rdma_procs = {
 	.inject_disconnect	= xprt_rdma_inject_disconnect,
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)
 	.bc_setup		= xprt_rdma_bc_setup,
-	.bc_up			= xprt_rdma_bc_up,
 	.bc_maxpayload		= xprt_rdma_bc_maxpayload,
 	.bc_free_rqst		= xprt_rdma_bc_free_rqst,
 	.bc_destroy		= xprt_rdma_bc_destroy,
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index 51812e628cb5..10f6593e1a6a 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -639,7 +639,6 @@ void xprt_rdma_cleanup(void);
  */
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)
 int xprt_rdma_bc_setup(struct rpc_xprt *, unsigned int);
-int xprt_rdma_bc_up(struct svc_serv *, struct net *);
 size_t xprt_rdma_bc_maxpayload(struct rpc_xprt *);
 int rpcrdma_bc_post_recv(struct rpcrdma_xprt *, unsigned int);
 void rpcrdma_bc_receive_call(struct rpcrdma_xprt *, struct rpcrdma_rep *);
* Unmerged path net/sunrpc/xprtsock.c
