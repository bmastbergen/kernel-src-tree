dax: Fix missed wakeup in put_unlocked_entry()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jan Kara <jack@suse.cz>
commit 61c30c98ef17e5a330d7bb8494b78b3d6dffe9b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/61c30c98.failed

The condition checking whether put_unlocked_entry() needs to wake up
following waiter got broken by commit 23c84eb78375 ("dax: Fix missed
wakeup with PMD faults"). We need to wake the waiter whenever the passed
entry is valid (i.e., non-NULL and not special conflict entry). This
could lead to processes never being woken up when waiting for entry
lock. Fix the condition.

	Cc: <stable@vger.kernel.org>
Link: http://lore.kernel.org/r/20190729120228.GC17833@quack2.suse.cz
Fixes: 23c84eb78375 ("dax: Fix missed wakeup with PMD faults")
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 61c30c98ef17e5a330d7bb8494b78b3d6dffe9b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index 7752d3866711,b64964ef44f6..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -246,7 -240,33 +246,11 @@@ static void *get_unlocked_entry(struct 
  static void put_unlocked_entry(struct xa_state *xas, void *entry)
  {
  	/* If we were the only waiter woken, wake the next one */
++<<<<<<< HEAD
 +	if (entry)
++=======
+ 	if (entry && !dax_is_conflict(entry))
++>>>>>>> 61c30c98ef17 (dax: Fix missed wakeup in put_unlocked_entry())
  		dax_wake_entry(xas, entry, false);
  }
  
* Unmerged path fs/dax.c
