nl80211: use for_each_element() in validate_ie_attr()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 9f308616b6176b6dc470e6eb3569a09b100a823a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9f308616.failed

This makes for much simpler code, simply walk through all
the elements and check that the last one found ends with
the end of the data. This works because if any element is
malformed the walk is aborted, we end up with a mismatch.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 9f308616b6176b6dc470e6eb3569a09b100a823a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 4e1c052bca2e,5d85f6032f84..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -205,9 -200,25 +205,30 @@@ cfg80211_get_dev_from_info(struct net *
  	return __cfg80211_rdev_from_attrs(netns, info->attrs);
  }
  
++<<<<<<< HEAD
++=======
+ static int validate_ie_attr(const struct nlattr *attr,
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	const u8 *data = nla_data(attr);
+ 	unsigned int len = nla_len(attr);
+ 	struct element *elem;
+ 
+ 	for_each_element(elem, data, len) {
+ 		/* nothing */
+ 	}
+ 
+ 	if (for_each_element_completed(elem, data, len))
+ 		return 0;
+ 
+ 	NL_SET_ERR_MSG_ATTR(extack, attr, "malformed information elements");
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 9f308616b617 (nl80211: use for_each_element() in validate_ie_attr())
  /* policy for the attributes */
 +
 +#if 0 /* Not in RHEL */
  static const struct nla_policy
  nl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {
  	[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },
* Unmerged path net/wireless/nl80211.c
