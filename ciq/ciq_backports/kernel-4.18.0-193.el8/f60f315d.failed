net/mlx5e: Register devlink ports for physical link, PCI PF, VFs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5e: Register devlink ports for physical link, PCI PF, VFs (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 96.77%
commit-author Parav Pandit <parav@mellanox.com>
commit f60f315d339e14633a51cd2d468500d08055b84b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f60f315d.failed

Register devlink port of physical port, PCI PF and PCI VF flavour
for each PF, VF when a given devlink instance is in switchdev mode.

Implement ndo_get_devlink_port callback API to make use of registered
devlink ports.
This eliminates ndo_get_phys_port_name() and ndo_get_port_parent_id()
callbacks. Hence, remove them.

An example output with 2 VFs, without a PF and single uplink port is
below.

$devlink port show
pci/0000:06:00.0/65535: type eth netdev ens2f0 flavour physical
pci/0000:05:00.0/1: type eth netdev eth1 flavour pcivf pfnum 0 vfnum 0
pci/0000:05:00.0/2: type eth netdev eth2 flavour pcivf pfnum 0 vfnum 1

	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f60f315d339e14633a51cd2d468500d08055b84b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1ddcc10576ec,6810b9fa0705..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1146,32 -1120,6 +1147,35 @@@ static int mlx5e_vf_rep_close(struct ne
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_rep_get_phys_port_name(struct net_device *dev,
 +					char *buf, size_t len)
 +{
 +	struct mlx5e_priv *priv = netdev_priv(dev);
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 +	struct mlx5_eswitch_rep *rep = rpriv->rep;
 +	unsigned int fn;
 +	int ret;
 +
 +	fn = PCI_FUNC(priv->mdev->pdev->devfn);
 +	if (fn >= MLX5_MAX_PORTS)
 +		return -EOPNOTSUPP;
 +
 +	if (rep->vport == FDB_UPLINK_VPORT)
 +		ret = snprintf(buf, len, "p%d", fn);
 +	else if (rep->vport == MLX5_VPORT_PF)
 +		ret = snprintf(buf, len, "pf%d", fn);
 +	else
 +		ret = snprintf(buf, len, "pf%dvf%d", fn, rep->vport - 1);
 +
 +	if (ret >= len)
 +		return -EOPNOTSUPP;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f60f315d339e (net/mlx5e: Register devlink ports for physical link, PCI PF, VFs)
  static int
  mlx5e_rep_setup_tc_cls_flower(struct mlx5e_priv *priv,
  			      struct tc_cls_flower_offload *cls_flower, int flags)
@@@ -1325,20 -1273,24 +1329,41 @@@ static int mlx5e_uplink_rep_set_vf_vlan
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct switchdev_ops mlx5e_rep_switchdev_ops = {
 +	.switchdev_port_attr_get	= mlx5e_attr_get,
 +};
 +
 +static const struct net_device_ops mlx5e_netdev_ops_vf_rep = {
 +	.ndo_open                = mlx5e_vf_rep_open,
 +	.ndo_stop                = mlx5e_vf_rep_close,
++=======
+ static struct devlink_port *mlx5e_get_devlink_port(struct net_device *dev)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 
+ 	return &rpriv->dl_port;
+ }
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_rep = {
+ 	.ndo_open                = mlx5e_rep_open,
+ 	.ndo_stop                = mlx5e_rep_close,
++>>>>>>> f60f315d339e (net/mlx5e: Register devlink ports for physical link, PCI PF, VFs)
  	.ndo_start_xmit          = mlx5e_xmit,
- 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
  	.ndo_setup_tc            = mlx5e_rep_setup_tc,
++<<<<<<< HEAD
 +	.ndo_get_stats64         = mlx5e_vf_rep_get_stats,
 +	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
 +	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
 +	.ndo_change_mtu          = mlx5e_vf_rep_change_mtu,
++=======
+ 	.ndo_get_devlink_port = mlx5e_get_devlink_port,
+ 	.ndo_get_stats64         = mlx5e_rep_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_rep_change_mtu,
++>>>>>>> f60f315d339e (net/mlx5e: Register devlink ports for physical link, PCI PF, VFs)
  };
  
  static const struct net_device_ops mlx5e_netdev_ops_uplink_rep = {
@@@ -1836,12 -1855,16 +1922,16 @@@ mlx5e_vport_rep_unload(struct mlx5_eswi
  	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
  	struct net_device *netdev = rpriv->netdev;
  	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *dev = priv->mdev;
  	void *ppriv = priv->ppriv;
  
+ 	if (is_devlink_port_supported(dev, rpriv))
+ 		devlink_port_type_clear(&rpriv->dl_port);
  	unregister_netdev(netdev);
+ 	unregister_devlink_port(dev, rpriv);
  	mlx5e_rep_neigh_cleanup(rpriv);
  	mlx5e_detach_netdev(priv);
 -	if (rep->vport == MLX5_VPORT_UPLINK)
 +	if (rep->vport == FDB_UPLINK_VPORT)
  		mlx5e_destroy_mdev_resources(priv->mdev);
  	mlx5e_destroy_netdev(priv);
  	kfree(ppriv); /* mlx5e_rep_priv */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 98e5b7d6bb09..322aa4431e5f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -86,6 +86,7 @@ struct mlx5e_rep_priv {
 	struct mlx5_flow_handle *vport_rx_rule;
 	struct list_head       vport_sqs_list;
 	struct mlx5_rep_uplink_priv uplink_priv; /* valid for uplink rep */
+	struct devlink_port dl_port;
 };
 
 static inline
