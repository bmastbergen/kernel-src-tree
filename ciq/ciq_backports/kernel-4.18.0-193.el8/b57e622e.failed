mm/hmm: convert to use vm_fault_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Souptick Joarder <jrdr.linux@gmail.com>
commit b57e622e6da9048c96fa0ed6943834949a398e3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b57e622e.failed

Convert to use vm_fault_t type as return type for fault handler.

kbuild reported warning during testing of
*mm-create-the-new-vm_fault_t-type.patch* available in below link -
https://patchwork.kernel.org/patch/10752741/

  kernel/memremap.c:46:34: warning: incorrect type in return expression
                           (different base types)
  kernel/memremap.c:46:34: expected restricted vm_fault_t
  kernel/memremap.c:46:34: got int

This patch has fixed the warnings and also hmm_devmem_fault() is
converted to return vm_fault_t to avoid further warnings.

[sfr@canb.auug.org.au: drm/nouveau/dmem: update for struct hmm_devmem_ops member change]
  Link: http://lkml.kernel.org/r/20190220174407.753d94e5@canb.auug.org.au
Link: http://lkml.kernel.org/r/20190110145900.GA1317@jordon-HP-15-Notebook-PC
	Signed-off-by: Souptick Joarder <jrdr.linux@gmail.com>
	Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
	Reviewed-by: Jérôme Glisse <jglisse@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b57e622e6da9048c96fa0ed6943834949a398e3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hmm.h
diff --cc include/linux/hmm.h
index 2f68a486cc0d,ad50b7b4f141..000000000000
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@@ -517,7 -495,28 +517,16 @@@ struct hmm_devmem_ops 
   *
   * Device drivers can directly use ZONE_DEVICE memory on their own if they
   * wish to do so.
 - *
 - * The page_fault() callback must migrate page back, from device memory to
 - * system memory, so that the CPU can access it. This might fail for various
 - * reasons (device issues,  device have been unplugged, ...). When such error
 - * conditions happen, the page_fault() callback must return VM_FAULT_SIGBUS and
 - * set the CPU page table entry to "poisoned".
 - *
 - * Note that because memory cgroup charges are transferred to the device memory,
 - * this should never fail due to memory restrictions. However, allocation
 - * of a regular system page might still fail because we are out of memory. If
 - * that happens, the page_fault() callback must return VM_FAULT_OOM.
 - *
 - * The page_fault() callback can also try to migrate back multiple pages in one
 - * chunk, as an optimization. It must, however, prioritize the faulting address
 - * over all the others.
   */
++<<<<<<< HEAD
++=======
+ typedef vm_fault_t (*dev_page_fault_t)(struct vm_area_struct *vma,
+ 				unsigned long addr,
+ 				const struct page *page,
+ 				unsigned int flags,
+ 				pmd_t *pmdp);
+ 
++>>>>>>> b57e622e6da9 (mm/hmm: convert to use vm_fault_t)
  struct hmm_devmem {
  	struct completion		completion;
  	unsigned long			pfn_first;
* Unmerged path include/linux/hmm.h
diff --git a/mm/hmm.c b/mm/hmm.c
index 91b885757871..fbd3f1508f0b 100644
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@ -983,7 +983,7 @@ static void hmm_devmem_ref_kill(struct percpu_ref *ref)
 	percpu_ref_kill(ref);
 }
 
-static int hmm_devmem_fault(struct vm_area_struct *vma,
+static vm_fault_t hmm_devmem_fault(struct vm_area_struct *vma,
 			    unsigned long addr,
 			    const struct page *page,
 			    unsigned int flags,
