xfrm: policy: avoid warning splat when merging nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit 769a807d0b41df4201dbeb01c22eaeb3e5905532
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/769a807d.failed

syzbot reported a splat:
 xfrm_policy_inexact_list_reinsert+0x625/0x6e0 net/xfrm/xfrm_policy.c:877
 CPU: 1 PID: 6756 Comm: syz-executor.1 Not tainted 5.3.0-rc2+ #57
 Call Trace:
  xfrm_policy_inexact_node_reinsert net/xfrm/xfrm_policy.c:922 [inline]
  xfrm_policy_inexact_node_merge net/xfrm/xfrm_policy.c:958 [inline]
  xfrm_policy_inexact_insert_node+0x537/0xb50 net/xfrm/xfrm_policy.c:1023
  xfrm_policy_inexact_alloc_chain+0x62b/0xbd0 net/xfrm/xfrm_policy.c:1139
  xfrm_policy_inexact_insert+0xe8/0x1540 net/xfrm/xfrm_policy.c:1182
  xfrm_policy_insert+0xdf/0xce0 net/xfrm/xfrm_policy.c:1574
  xfrm_add_policy+0x4cf/0x9b0 net/xfrm/xfrm_user.c:1670
  xfrm_user_rcv_msg+0x46b/0x720 net/xfrm/xfrm_user.c:2676
  netlink_rcv_skb+0x1f0/0x460 net/netlink/af_netlink.c:2477
  xfrm_netlink_rcv+0x74/0x90 net/xfrm/xfrm_user.c:2684
  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]
  netlink_unicast+0x809/0x9a0 net/netlink/af_netlink.c:1328
  netlink_sendmsg+0xa70/0xd30 net/netlink/af_netlink.c:1917
  sock_sendmsg_nosec net/socket.c:637 [inline]
  sock_sendmsg net/socket.c:657 [inline]

There is no reproducer, however, the warning can be reproduced
by adding rules with ever smaller prefixes.

The sanity check ("does the policy match the node") uses the prefix value
of the node before its updated to the smaller value.

To fix this, update the prefix earlier.  The bug has no impact on tree
correctness, this is only to prevent a false warning.

	Reported-by: syzbot+8cc27ace5f6972910b31@syzkaller.appspotmail.com
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 769a807d0b41df4201dbeb01c22eaeb3e5905532)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
#	tools/testing/selftests/net/xfrm_policy.sh
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,0fa7c5ce3b2c..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -560,6 -682,526 +560,529 @@@ static void xfrm_hash_resize(struct wor
  	mutex_unlock(&hash_resize_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ /* Make sure *pol can be inserted into fastbin.
+  * Useful to check that later insert requests will be sucessful
+  * (provided xfrm_policy_lock is held throughout).
+  */
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_alloc_bin(const struct xfrm_policy *pol, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *prev;
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = pol->family,
+ 		.type = pol->type,
+ 		.dir = dir,
+ 		.if_id = pol->if_id,
+ 	};
+ 	struct net *net = xp_net(pol);
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	write_pnet(&k.net, net);
+ 	bin = rhashtable_lookup_fast(&xfrm_policy_inexact_table, &k,
+ 				     xfrm_pol_inexact_params);
+ 	if (bin)
+ 		return bin;
+ 
+ 	bin = kzalloc(sizeof(*bin), GFP_ATOMIC);
+ 	if (!bin)
+ 		return NULL;
+ 
+ 	bin->k = k;
+ 	INIT_HLIST_HEAD(&bin->hhead);
+ 	bin->root_d = RB_ROOT;
+ 	bin->root_s = RB_ROOT;
+ 	seqcount_init(&bin->count);
+ 
+ 	prev = rhashtable_lookup_get_insert_key(&xfrm_policy_inexact_table,
+ 						&bin->k, &bin->head,
+ 						xfrm_pol_inexact_params);
+ 	if (!prev) {
+ 		list_add(&bin->inexact_bins, &net->xfrm.inexact_bins);
+ 		return bin;
+ 	}
+ 
+ 	kfree(bin);
+ 
+ 	return IS_ERR(prev) ? NULL : prev;
+ }
+ 
+ static bool xfrm_pol_inexact_addr_use_any_list(const xfrm_address_t *addr,
+ 					       int family, u8 prefixlen)
+ {
+ 	if (xfrm_addr_any(addr, family))
+ 		return true;
+ 
+ 	if (family == AF_INET6 && prefixlen < INEXACT_PREFIXLEN_IPV6)
+ 		return true;
+ 
+ 	if (family == AF_INET && prefixlen < INEXACT_PREFIXLEN_IPV4)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static bool
+ xfrm_policy_inexact_insert_use_any_list(const struct xfrm_policy *policy)
+ {
+ 	const xfrm_address_t *addr;
+ 	bool saddr_any, daddr_any;
+ 	u8 prefixlen;
+ 
+ 	addr = &policy->selector.saddr;
+ 	prefixlen = policy->selector.prefixlen_s;
+ 
+ 	saddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	addr = &policy->selector.daddr;
+ 	prefixlen = policy->selector.prefixlen_d;
+ 	daddr_any = xfrm_pol_inexact_addr_use_any_list(addr,
+ 						       policy->family,
+ 						       prefixlen);
+ 	return saddr_any && daddr_any;
+ }
+ 
+ static void xfrm_pol_inexact_node_init(struct xfrm_pol_inexact_node *node,
+ 				       const xfrm_address_t *addr, u8 prefixlen)
+ {
+ 	node->addr = *addr;
+ 	node->prefixlen = prefixlen;
+ }
+ 
+ static struct xfrm_pol_inexact_node *
+ xfrm_pol_inexact_node_alloc(const xfrm_address_t *addr, u8 prefixlen)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 
+ 	node = kzalloc(sizeof(*node), GFP_ATOMIC);
+ 	if (node)
+ 		xfrm_pol_inexact_node_init(node, addr, prefixlen);
+ 
+ 	return node;
+ }
+ 
+ static int xfrm_policy_addr_delta(const xfrm_address_t *a,
+ 				  const xfrm_address_t *b,
+ 				  u8 prefixlen, u16 family)
+ {
+ 	unsigned int pdw, pbi;
+ 	int delta = 0;
+ 
+ 	switch (family) {
+ 	case AF_INET:
+ 		if (sizeof(long) == 4 && prefixlen == 0)
+ 			return ntohl(a->a4) - ntohl(b->a4);
+ 		return (ntohl(a->a4) & ((~0UL << (32 - prefixlen)))) -
+ 		       (ntohl(b->a4) & ((~0UL << (32 - prefixlen))));
+ 	case AF_INET6:
+ 		pdw = prefixlen >> 5;
+ 		pbi = prefixlen & 0x1f;
+ 
+ 		if (pdw) {
+ 			delta = memcmp(a->a6, b->a6, pdw << 2);
+ 			if (delta)
+ 				return delta;
+ 		}
+ 		if (pbi) {
+ 			u32 mask = ~0u << (32 - pbi);
+ 
+ 			delta = (ntohl(a->a6[pdw]) & mask) -
+ 				(ntohl(b->a6[pdw]) & mask);
+ 		}
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return delta;
+ }
+ 
+ static void xfrm_policy_inexact_list_reinsert(struct net *net,
+ 					      struct xfrm_pol_inexact_node *n,
+ 					      u16 family)
+ {
+ 	unsigned int matched_s, matched_d;
+ 	struct xfrm_policy *policy, *p;
+ 
+ 	matched_s = 0;
+ 	matched_d = 0;
+ 
+ 	list_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {
+ 		struct hlist_node *newpos = NULL;
+ 		bool matches_s, matches_d;
+ 
+ 		if (!policy->bydst_reinsert)
+ 			continue;
+ 
+ 		WARN_ON_ONCE(policy->family != family);
+ 
+ 		policy->bydst_reinsert = false;
+ 		hlist_for_each_entry(p, &n->hhead, bydst) {
+ 			if (policy->priority > p->priority)
+ 				newpos = &p->bydst;
+ 			else if (policy->priority == p->priority &&
+ 				 policy->pos > p->pos)
+ 				newpos = &p->bydst;
+ 			else
+ 				break;
+ 		}
+ 
+ 		if (newpos)
+ 			hlist_add_behind_rcu(&policy->bydst, newpos);
+ 		else
+ 			hlist_add_head_rcu(&policy->bydst, &n->hhead);
+ 
+ 		/* paranoia checks follow.
+ 		 * Check that the reinserted policy matches at least
+ 		 * saddr or daddr for current node prefix.
+ 		 *
+ 		 * Matching both is fine, matching saddr in one policy
+ 		 * (but not daddr) and then matching only daddr in another
+ 		 * is a bug.
+ 		 */
+ 		matches_s = xfrm_policy_addr_delta(&policy->selector.saddr,
+ 						   &n->addr,
+ 						   n->prefixlen,
+ 						   family) == 0;
+ 		matches_d = xfrm_policy_addr_delta(&policy->selector.daddr,
+ 						   &n->addr,
+ 						   n->prefixlen,
+ 						   family) == 0;
+ 		if (matches_s && matches_d)
+ 			continue;
+ 
+ 		WARN_ON_ONCE(!matches_s && !matches_d);
+ 		if (matches_s)
+ 			matched_s++;
+ 		if (matches_d)
+ 			matched_d++;
+ 		WARN_ON_ONCE(matched_s && matched_d);
+ 	}
+ }
+ 
+ static void xfrm_policy_inexact_node_reinsert(struct net *net,
+ 					      struct xfrm_pol_inexact_node *n,
+ 					      struct rb_root *new,
+ 					      u16 family)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 	struct rb_node **p, *parent;
+ 
+ 	/* we should not have another subtree here */
+ 	WARN_ON_ONCE(!RB_EMPTY_ROOT(&n->root));
+ restart:
+ 	parent = NULL;
+ 	p = &new->rb_node;
+ 	while (*p) {
+ 		u8 prefixlen;
+ 		int delta;
+ 
+ 		parent = *p;
+ 		node = rb_entry(*p, struct xfrm_pol_inexact_node, node);
+ 
+ 		prefixlen = min(node->prefixlen, n->prefixlen);
+ 
+ 		delta = xfrm_policy_addr_delta(&n->addr, &node->addr,
+ 					       prefixlen, family);
+ 		if (delta < 0) {
+ 			p = &parent->rb_left;
+ 		} else if (delta > 0) {
+ 			p = &parent->rb_right;
+ 		} else {
+ 			bool same_prefixlen = node->prefixlen == n->prefixlen;
+ 			struct xfrm_policy *tmp;
+ 
+ 			hlist_for_each_entry(tmp, &n->hhead, bydst) {
+ 				tmp->bydst_reinsert = true;
+ 				hlist_del_rcu(&tmp->bydst);
+ 			}
+ 
+ 			node->prefixlen = prefixlen;
+ 
+ 			xfrm_policy_inexact_list_reinsert(net, node, family);
+ 
+ 			if (same_prefixlen) {
+ 				kfree_rcu(n, rcu);
+ 				return;
+ 			}
+ 
+ 			rb_erase(*p, new);
+ 			kfree_rcu(n, rcu);
+ 			n = node;
+ 			goto restart;
+ 		}
+ 	}
+ 
+ 	rb_link_node_rcu(&n->node, parent, p);
+ 	rb_insert_color(&n->node, new);
+ }
+ 
+ /* merge nodes v and n */
+ static void xfrm_policy_inexact_node_merge(struct net *net,
+ 					   struct xfrm_pol_inexact_node *v,
+ 					   struct xfrm_pol_inexact_node *n,
+ 					   u16 family)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 	struct xfrm_policy *tmp;
+ 	struct rb_node *rnode;
+ 
+ 	/* To-be-merged node v has a subtree.
+ 	 *
+ 	 * Dismantle it and insert its nodes to n->root.
+ 	 */
+ 	while ((rnode = rb_first(&v->root)) != NULL) {
+ 		node = rb_entry(rnode, struct xfrm_pol_inexact_node, node);
+ 		rb_erase(&node->node, &v->root);
+ 		xfrm_policy_inexact_node_reinsert(net, node, &n->root,
+ 						  family);
+ 	}
+ 
+ 	hlist_for_each_entry(tmp, &v->hhead, bydst) {
+ 		tmp->bydst_reinsert = true;
+ 		hlist_del_rcu(&tmp->bydst);
+ 	}
+ 
+ 	xfrm_policy_inexact_list_reinsert(net, n, family);
+ }
+ 
+ static struct xfrm_pol_inexact_node *
+ xfrm_policy_inexact_insert_node(struct net *net,
+ 				struct rb_root *root,
+ 				xfrm_address_t *addr,
+ 				u16 family, u8 prefixlen, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_node *cached = NULL;
+ 	struct rb_node **p, *parent = NULL;
+ 	struct xfrm_pol_inexact_node *node;
+ 
+ 	p = &root->rb_node;
+ 	while (*p) {
+ 		int delta;
+ 
+ 		parent = *p;
+ 		node = rb_entry(*p, struct xfrm_pol_inexact_node, node);
+ 
+ 		delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 					       node->prefixlen,
+ 					       family);
+ 		if (delta == 0 && prefixlen >= node->prefixlen) {
+ 			WARN_ON_ONCE(cached); /* ipsec policies got lost */
+ 			return node;
+ 		}
+ 
+ 		if (delta < 0)
+ 			p = &parent->rb_left;
+ 		else
+ 			p = &parent->rb_right;
+ 
+ 		if (prefixlen < node->prefixlen) {
+ 			delta = xfrm_policy_addr_delta(addr, &node->addr,
+ 						       prefixlen,
+ 						       family);
+ 			if (delta)
+ 				continue;
+ 
+ 			/* This node is a subnet of the new prefix. It needs
+ 			 * to be removed and re-inserted with the smaller
+ 			 * prefix and all nodes that are now also covered
+ 			 * by the reduced prefixlen.
+ 			 */
+ 			rb_erase(&node->node, root);
+ 
+ 			if (!cached) {
+ 				xfrm_pol_inexact_node_init(node, addr,
+ 							   prefixlen);
+ 				cached = node;
+ 			} else {
+ 				/* This node also falls within the new
+ 				 * prefixlen. Merge the to-be-reinserted
+ 				 * node and this one.
+ 				 */
+ 				xfrm_policy_inexact_node_merge(net, node,
+ 							       cached, family);
+ 				kfree_rcu(node, rcu);
+ 			}
+ 
+ 			/* restart */
+ 			p = &root->rb_node;
+ 			parent = NULL;
+ 		}
+ 	}
+ 
+ 	node = cached;
+ 	if (!node) {
+ 		node = xfrm_pol_inexact_node_alloc(addr, prefixlen);
+ 		if (!node)
+ 			return NULL;
+ 	}
+ 
+ 	rb_link_node_rcu(&node->node, parent, p);
+ 	rb_insert_color(&node->node, root);
+ 
+ 	return node;
+ }
+ 
+ static void xfrm_policy_inexact_gc_tree(struct rb_root *r, bool rm)
+ {
+ 	struct xfrm_pol_inexact_node *node;
+ 	struct rb_node *rn = rb_first(r);
+ 
+ 	while (rn) {
+ 		node = rb_entry(rn, struct xfrm_pol_inexact_node, node);
+ 
+ 		xfrm_policy_inexact_gc_tree(&node->root, rm);
+ 		rn = rb_next(rn);
+ 
+ 		if (!hlist_empty(&node->hhead) || !RB_EMPTY_ROOT(&node->root)) {
+ 			WARN_ON_ONCE(rm);
+ 			continue;
+ 		}
+ 
+ 		rb_erase(&node->node, r);
+ 		kfree_rcu(node, rcu);
+ 	}
+ }
+ 
+ static void __xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b, bool net_exit)
+ {
+ 	write_seqcount_begin(&b->count);
+ 	xfrm_policy_inexact_gc_tree(&b->root_d, net_exit);
+ 	xfrm_policy_inexact_gc_tree(&b->root_s, net_exit);
+ 	write_seqcount_end(&b->count);
+ 
+ 	if (!RB_EMPTY_ROOT(&b->root_d) || !RB_EMPTY_ROOT(&b->root_s) ||
+ 	    !hlist_empty(&b->hhead)) {
+ 		WARN_ON_ONCE(net_exit);
+ 		return;
+ 	}
+ 
+ 	if (rhashtable_remove_fast(&xfrm_policy_inexact_table, &b->head,
+ 				   xfrm_pol_inexact_params) == 0) {
+ 		list_del(&b->inexact_bins);
+ 		kfree_rcu(b, rcu);
+ 	}
+ }
+ 
+ static void xfrm_policy_inexact_prune_bin(struct xfrm_pol_inexact_bin *b)
+ {
+ 	struct net *net = read_pnet(&b->k.net);
+ 
+ 	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
+ 	__xfrm_policy_inexact_prune_bin(b, false);
+ 	spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ }
+ 
+ static void __xfrm_policy_inexact_flush(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *t;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry_safe(bin, t, &net->xfrm.inexact_bins, inexact_bins)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ }
+ 
+ static struct hlist_head *
+ xfrm_policy_inexact_alloc_chain(struct xfrm_pol_inexact_bin *bin,
+ 				struct xfrm_policy *policy, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_node *n;
+ 	struct net *net;
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	if (xfrm_policy_inexact_insert_use_any_list(policy))
+ 		return &bin->hhead;
+ 
+ 	if (xfrm_pol_inexact_addr_use_any_list(&policy->selector.daddr,
+ 					       policy->family,
+ 					       policy->selector.prefixlen_d)) {
+ 		write_seqcount_begin(&bin->count);
+ 		n = xfrm_policy_inexact_insert_node(net,
+ 						    &bin->root_s,
+ 						    &policy->selector.saddr,
+ 						    policy->family,
+ 						    policy->selector.prefixlen_s,
+ 						    dir);
+ 		write_seqcount_end(&bin->count);
+ 		if (!n)
+ 			return NULL;
+ 
+ 		return &n->hhead;
+ 	}
+ 
+ 	/* daddr is fixed */
+ 	write_seqcount_begin(&bin->count);
+ 	n = xfrm_policy_inexact_insert_node(net,
+ 					    &bin->root_d,
+ 					    &policy->selector.daddr,
+ 					    policy->family,
+ 					    policy->selector.prefixlen_d, dir);
+ 	write_seqcount_end(&bin->count);
+ 	if (!n)
+ 		return NULL;
+ 
+ 	/* saddr is wildcard */
+ 	if (xfrm_pol_inexact_addr_use_any_list(&policy->selector.saddr,
+ 					       policy->family,
+ 					       policy->selector.prefixlen_s))
+ 		return &n->hhead;
+ 
+ 	write_seqcount_begin(&bin->count);
+ 	n = xfrm_policy_inexact_insert_node(net,
+ 					    &n->root,
+ 					    &policy->selector.saddr,
+ 					    policy->family,
+ 					    policy->selector.prefixlen_s, dir);
+ 	write_seqcount_end(&bin->count);
+ 	if (!n)
+ 		return NULL;
+ 
+ 	return &n->hhead;
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_inexact_insert(struct xfrm_policy *policy, u8 dir, int excl)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 	struct xfrm_policy *delpol;
+ 	struct hlist_head *chain;
+ 	struct net *net;
+ 
+ 	bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 	if (!bin)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	net = xp_net(policy);
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	chain = xfrm_policy_inexact_alloc_chain(bin, policy, dir);
+ 	if (!chain) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	delpol = xfrm_policy_insert_list(chain, policy, excl);
+ 	if (delpol && excl) {
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 		return ERR_PTR(-EEXIST);
+ 	}
+ 
+ 	chain = &net->xfrm.policy_inexact[dir];
+ 	xfrm_policy_insert_inexact_list(chain, policy);
+ 
+ 	if (delpol)
+ 		__xfrm_policy_inexact_prune_bin(bin, false);
+ 
+ 	return delpol;
+ }
+ 
++>>>>>>> 769a807d0b41 (xfrm: policy: avoid warning splat when merging nodes)
  static void xfrm_hash_rebuild(struct work_struct *work)
  {
  	struct net *net = container_of(work, struct net,
diff --cc tools/testing/selftests/net/xfrm_policy.sh
index 22f2483ac0e9,7a1bf94c5bd3..000000000000
--- a/tools/testing/selftests/net/xfrm_policy.sh
+++ b/tools/testing/selftests/net/xfrm_policy.sh
@@@ -55,6 -56,85 +55,88 @@@ do_esp() 
      do_esp_policy $ns $me $remote $lnet $rnet
  }
  
++<<<<<<< HEAD
++=======
+ # add policies with different netmasks, to make sure kernel carries
+ # the policies contained within new netmask over when search tree is
+ # re-built.
+ # peer netns that are supposed to be encapsulated via esp have addresses
+ # in the 10.0.1.0/24 and 10.0.2.0/24 subnets, respectively.
+ #
+ # Adding a policy for '10.0.1.0/23' will make it necessary to
+ # alter the prefix of 10.0.1.0 subnet.
+ # In case new prefix overlaps with existing node, the node and all
+ # policies it carries need to be merged with the existing one(s).
+ #
+ # Do that here.
+ do_overlap()
+ {
+     local ns=$1
+ 
+     # adds new nodes to tree (neither network exists yet in policy database).
+     ip -net $ns xfrm policy add src 10.1.0.0/24 dst 10.0.0.0/24 dir fwd priority 200 action block
+ 
+     # adds a new node in the 10.0.0.0/24 tree (dst node exists).
+     ip -net $ns xfrm policy add src 10.2.0.0/24 dst 10.0.0.0/24 dir fwd priority 200 action block
+ 
+     # adds a 10.2.0.0/23 node, but for different dst.
+     ip -net $ns xfrm policy add src 10.2.0.0/23 dst 10.0.1.0/24 dir fwd priority 200 action block
+ 
+     # dst now overlaps with the 10.0.1.0/24 ESP policy in fwd.
+     # kernel must 'promote' existing one (10.0.0.0/24) to 10.0.0.0/23.
+     # But 10.0.0.0/23 also includes existing 10.0.1.0/24, so that node
+     # also has to be merged too, including source-sorted subtrees.
+     # old:
+     # 10.0.0.0/24 (node 1 in dst tree of the bin)
+     #    10.1.0.0/24 (node in src tree of dst node 1)
+     #    10.2.0.0/24 (node in src tree of dst node 1)
+     # 10.0.1.0/24 (node 2 in dst tree of the bin)
+     #    10.0.2.0/24 (node in src tree of dst node 2)
+     #    10.2.0.0/24 (node in src tree of dst node 2)
+     #
+     # The next 'policy add' adds dst '10.0.0.0/23', which means
+     # that dst node 1 and dst node 2 have to be merged including
+     # the sub-tree.  As no duplicates are allowed, policies in
+     # the two '10.0.2.0/24' are also merged.
+     #
+     # after the 'add', internal search tree should look like this:
+     # 10.0.0.0/23 (node in dst tree of bin)
+     #     10.0.2.0/24 (node in src tree of dst node)
+     #     10.1.0.0/24 (node in src tree of dst node)
+     #     10.2.0.0/24 (node in src tree of dst node)
+     #
+     # 10.0.0.0/24 and 10.0.1.0/24 nodes have been merged as 10.0.0.0/23.
+     ip -net $ns xfrm policy add src 10.1.0.0/24 dst 10.0.0.0/23 dir fwd priority 200 action block
+ 
+     # similar to above: add policies (with partially random address), with shrinking prefixes.
+     for p in 29 28 27;do
+       for k in $(seq 1 32); do
+        ip -net $ns xfrm policy add src 10.253.1.$((RANDOM%255))/$p dst 10.254.1.$((RANDOM%255))/$p dir fwd priority $((200+k)) action block 2>/dev/null
+       done
+     done
+ }
+ 
+ do_esp_policy_get_check() {
+     local ns=$1
+     local lnet=$2
+     local rnet=$3
+ 
+     ip -net $ns xfrm policy get src $lnet dst $rnet dir out > /dev/null
+     if [ $? -ne 0 ] && [ $policy_checks_ok -eq 1 ] ;then
+         policy_checks_ok=0
+         echo "FAIL: ip -net $ns xfrm policy get src $lnet dst $rnet dir out"
+         ret=1
+     fi
+ 
+     ip -net $ns xfrm policy get src $rnet dst $lnet dir fwd > /dev/null
+     if [ $? -ne 0 ] && [ $policy_checks_ok -eq 1 ] ;then
+         policy_checks_ok=0
+         echo "FAIL: ip -net $ns xfrm policy get src $rnet dst $lnet dir fwd"
+         ret=1
+     fi
+ }
+ 
++>>>>>>> 769a807d0b41 (xfrm: policy: avoid warning splat when merging nodes)
  do_exception() {
      local ns=$1
      local me=$2
* Unmerged path net/xfrm/xfrm_policy.c
* Unmerged path tools/testing/selftests/net/xfrm_policy.sh
