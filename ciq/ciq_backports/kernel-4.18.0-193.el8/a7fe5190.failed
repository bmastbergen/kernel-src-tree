cpuidle: menu: Remove get_loadavg() from the performance multiplier

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [cpuidle] menu: Remove get_loadavg() from the performance multiplier (Al Stone) [1725618]
Rebuild_FUZZ: 92.80%
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit a7fe5190c03f8137ef08db84a58dd4daf2c4785d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a7fe5190.failed

The function get_loadavg() returns almost always zero. To be more
precise, statistically speaking for a total of 1023379 times passing
in the function, the load is equal to zero 1020728 times, greater than
100, 610 times, the remaining is between 0 and 5.

In 2011, the get_loadavg() was removed from the Android tree because
of the above [1]. At this time, the load was:

unsigned long this_cpu_load(void)
{
        struct rq *this = this_rq();
        return this->cpu_load[0];
}

In 2014, the code was changed by commit 372ba8cb46b2 (cpuidle: menu: Lookup CPU
runqueues less) and the load is:

void get_iowait_load(unsigned long *nr_waiters, unsigned long *load)
{
        struct rq *rq = this_rq();
        *nr_waiters = atomic_read(&rq->nr_iowait);
        *load = rq->load.weight;
}

with the same result.

Both measurements show using the load in this code path does no matter
anymore. Removing it.

[1] https://android.googlesource.com/kernel/common/+/4dedd9f124703207895777ac6e91dacde0f7cc17

	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Acked-by: Mel Gorman <mgorman@suse.de>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a7fe5190c03f8137ef08db84a58dd4daf2c4785d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/governors/menu.c
diff --cc drivers/cpuidle/governors/menu.c
index 471076599073,76df4f947f07..000000000000
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@@ -130,10 -130,9 +130,16 @@@ struct menu_device 
  	int		interval_ptr;
  };
  
++<<<<<<< HEAD
 +static inline int get_loadavg(unsigned long load)
 +{
 +	return LOAD_INT(load) * 10 + LOAD_FRAC(load) / 10;
 +}
++=======
+ 
+ #define LOAD_INT(x) ((x) >> FSHIFT)
+ #define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1-1)) * 100)
++>>>>>>> a7fe5190c03f (cpuidle: menu: Remove get_loadavg() from the performance multiplier)
  
  static inline int which_bucket(unsigned int duration, unsigned long nr_iowaiters)
  {
@@@ -283,9 -287,8 +281,9 @@@ static int menu_select(struct cpuidle_d
  	int i;
  	int idx;
  	unsigned int interactivity_req;
 +	unsigned int expected_interval;
  	unsigned int predicted_us;
- 	unsigned long nr_iowaiters, cpu_load;
+ 	unsigned long nr_iowaiters;
  	ktime_t delta_next;
  
  	if (data->needs_update) {
* Unmerged path drivers/cpuidle/governors/menu.c
diff --git a/include/linux/sched/stat.h b/include/linux/sched/stat.h
index 04f1321d14c4..f30954cc059d 100644
--- a/include/linux/sched/stat.h
+++ b/include/linux/sched/stat.h
@@ -20,7 +20,6 @@ extern unsigned long nr_running(void);
 extern bool single_task_running(void);
 extern unsigned long nr_iowait(void);
 extern unsigned long nr_iowait_cpu(int cpu);
-extern void get_iowait_load(unsigned long *nr_waiters, unsigned long *load);
 
 static inline int sched_info_on(void)
 {
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 7f95b6688883..14fd92764600 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2883,13 +2883,6 @@ unsigned long nr_iowait_cpu(int cpu)
 	return atomic_read(&cpu_rq(cpu)->nr_iowait);
 }
 
-void get_iowait_load(unsigned long *nr_waiters, unsigned long *load)
-{
-	struct rq *rq = this_rq();
-	*nr_waiters = atomic_read(&rq->nr_iowait);
-	*load = rq->load.weight;
-}
-
 /*
  * IO-wait accounting, and how its mostly bollocks (on SMP).
  *
