RDMA/iwcm: move iw_rem_ref() calls out of spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Krishnamraju Eraparaju <krishna2@chelsio.com>
commit 54102dd410b037a4d7984e6a5826fb212c2f8aca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/54102dd4.failed

kref release routines usually perform memory release operations,
hence, they should not be called with spinlocks held.
one such case is: SIW kref release routine siw_free_qp(), which
can sleep via vfree() while freeing queue memory.

Hence, all iw_rem_ref() calls in IWCM are moved out of spinlocks.

Fixes: 922a8e9fb2e0 ("RDMA: iWARP Connection Manager.")
	Signed-off-by: Krishnamraju Eraparaju <krishna2@chelsio.com>
	Reviewed-by: Bernard Metzler <bmt@zurich.ibm.com>
Link: https://lore.kernel.org/r/20191007102627.12568-1-krishna2@chelsio.com
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 54102dd410b037a4d7984e6a5826fb212c2f8aca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/iwcm.c
diff --cc drivers/infiniband/core/iwcm.c
index 732637c913d9,ade71823370f..000000000000
--- a/drivers/infiniband/core/iwcm.c
+++ b/drivers/infiniband/core/iwcm.c
@@@ -426,11 -430,9 +430,16 @@@ static void destroy_cm_id(struct iw_cm_
  		BUG();
  		break;
  	}
++<<<<<<< HEAD
 +	if (cm_id_priv->qp) {
 +		cm_id_priv->id.device->iwcm->rem_ref(cm_id_priv->qp);
 +		cm_id_priv->qp = NULL;
 +	}
++=======
++>>>>>>> 54102dd410b0 (RDMA/iwcm: move iw_rem_ref() calls out of spinlock)
  	spin_unlock_irqrestore(&cm_id_priv->lock, flags);
+ 	if (qp)
+ 		cm_id_priv->id.device->ops.iw_rem_ref(qp);
  
  	if (cm_id->mapped) {
  		iwpm_remove_mapinfo(&cm_id->local_addr, &cm_id->m_local_addr);
@@@ -670,11 -673,11 +679,18 @@@ int iw_cm_accept(struct iw_cm_id *cm_id
  		BUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_RECV);
  		cm_id_priv->state = IW_CM_STATE_IDLE;
  		spin_lock_irqsave(&cm_id_priv->lock, flags);
++<<<<<<< HEAD
 +		if (cm_id_priv->qp) {
 +			cm_id->device->iwcm->rem_ref(qp);
 +			cm_id_priv->qp = NULL;
 +		}
++=======
+ 		qp = cm_id_priv->qp;
+ 		cm_id_priv->qp = NULL;
++>>>>>>> 54102dd410b0 (RDMA/iwcm: move iw_rem_ref() calls out of spinlock)
  		spin_unlock_irqrestore(&cm_id_priv->lock, flags);
+ 		if (qp)
+ 			cm_id->device->ops.iw_rem_ref(qp);
  		clear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);
  		wake_up_all(&cm_id_priv->connect_wait);
  	}
@@@ -729,10 -732,8 +745,15 @@@ int iw_cm_connect(struct iw_cm_id *cm_i
  		return 0;	/* success */
  
  	spin_lock_irqsave(&cm_id_priv->lock, flags);
++<<<<<<< HEAD
 +	if (cm_id_priv->qp) {
 +		cm_id->device->iwcm->rem_ref(qp);
 +		cm_id_priv->qp = NULL;
 +	}
++=======
+ 	qp = cm_id_priv->qp;
+ 	cm_id_priv->qp = NULL;
++>>>>>>> 54102dd410b0 (RDMA/iwcm: move iw_rem_ref() calls out of spinlock)
  	cm_id_priv->state = IW_CM_STATE_IDLE;
  err:
  	spin_unlock_irqrestore(&cm_id_priv->lock, flags);
@@@ -895,7 -899,7 +919,11 @@@ static int cm_conn_rep_handler(struct i
  		cm_id_priv->state = IW_CM_STATE_ESTABLISHED;
  	} else {
  		/* REJECTED or RESET */
++<<<<<<< HEAD
 +		cm_id_priv->id.device->iwcm->rem_ref(cm_id_priv->qp);
++=======
+ 		qp = cm_id_priv->qp;
++>>>>>>> 54102dd410b0 (RDMA/iwcm: move iw_rem_ref() calls out of spinlock)
  		cm_id_priv->qp = NULL;
  		cm_id_priv->state = IW_CM_STATE_IDLE;
  	}
@@@ -941,14 -947,13 +971,20 @@@ static void cm_disconnect_handler(struc
  static int cm_close_handler(struct iwcm_id_private *cm_id_priv,
  				  struct iw_cm_event *iw_event)
  {
+ 	struct ib_qp *qp;
  	unsigned long flags;
- 	int ret = 0;
+ 	int ret = 0, notify_event = 0;
  	spin_lock_irqsave(&cm_id_priv->lock, flags);
+ 	qp = cm_id_priv->qp;
+ 	cm_id_priv->qp = NULL;
  
++<<<<<<< HEAD
 +	if (cm_id_priv->qp) {
 +		cm_id_priv->id.device->iwcm->rem_ref(cm_id_priv->qp);
 +		cm_id_priv->qp = NULL;
 +	}
++=======
++>>>>>>> 54102dd410b0 (RDMA/iwcm: move iw_rem_ref() calls out of spinlock)
  	switch (cm_id_priv->state) {
  	case IW_CM_STATE_ESTABLISHED:
  	case IW_CM_STATE_CLOSING:
* Unmerged path drivers/infiniband/core/iwcm.c
