bnxt_en: Pre-map the firmware health monitoring registers.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Pre-map the firmware health monitoring registers (Jonathan Toppins) [1724766]
Rebuild_FUZZ: 99.13%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 9ffbd67734909ca8bb099e62f06387649b43d5a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9ffbd677.failed

Pre-map the GRC registers for periodic firmware health monitoring.

	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9ffbd67734909ca8bb099e62f06387649b43d5a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 73747346c6cf,8ec41d66430e..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -6717,6 -6922,131 +6717,134 @@@ static int bnxt_hwrm_func_qcaps(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_hwrm_cfa_adv_flow_mgnt_qcaps(struct bnxt *bp)
+ {
+ 	struct hwrm_cfa_adv_flow_mgnt_qcaps_input req = {0};
+ 	struct hwrm_cfa_adv_flow_mgnt_qcaps_output *resp;
+ 	int rc = 0;
+ 	u32 flags;
+ 
+ 	if (!(bp->fw_cap & BNXT_FW_CAP_CFA_ADV_FLOW))
+ 		return 0;
+ 
+ 	resp = bp->hwrm_cmd_resp_addr;
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_CFA_ADV_FLOW_MGNT_QCAPS, -1, -1);
+ 
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		goto hwrm_cfa_adv_qcaps_exit;
+ 
+ 	flags = le32_to_cpu(resp->flags);
+ 	if (flags &
+ 	    CFA_ADV_FLOW_MGNT_QCAPS_RESP_FLAGS_RFS_RING_TBL_IDX_SUPPORTED)
+ 		bp->fw_cap |= BNXT_FW_CAP_CFA_RFS_RING_TBL_IDX;
+ 
+ hwrm_cfa_adv_qcaps_exit:
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ 	return rc;
+ }
+ 
+ static int bnxt_map_fw_health_regs(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 reg_base = 0xffffffff;
+ 	int i;
+ 
+ 	/* Only pre-map the monitoring GRC registers using window 3 */
+ 	for (i = 0; i < 4; i++) {
+ 		u32 reg = fw_health->regs[i];
+ 
+ 		if (BNXT_FW_HEALTH_REG_TYPE(reg) != BNXT_FW_HEALTH_REG_TYPE_GRC)
+ 			continue;
+ 		if (reg_base == 0xffffffff)
+ 			reg_base = reg & BNXT_GRC_BASE_MASK;
+ 		if ((reg & BNXT_GRC_BASE_MASK) != reg_base)
+ 			return -ERANGE;
+ 		fw_health->mapped_regs[i] = BNXT_FW_HEALTH_WIN_BASE +
+ 					    (reg & BNXT_GRC_OFFSET_MASK);
+ 	}
+ 	if (reg_base == 0xffffffff)
+ 		return 0;
+ 
+ 	writel(reg_base, bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT +
+ 			 BNXT_FW_HEALTH_WIN_MAP_OFF);
+ 	return 0;
+ }
+ 
+ static int bnxt_hwrm_error_recovery_qcfg(struct bnxt *bp)
+ {
+ 	struct hwrm_error_recovery_qcfg_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	struct hwrm_error_recovery_qcfg_input req = {0};
+ 	int rc, i;
+ 
+ 	if (!(bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY))
+ 		return 0;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_ERROR_RECOVERY_QCFG, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		goto err_recovery_out;
+ 	if (!fw_health) {
+ 		fw_health = kzalloc(sizeof(*fw_health), GFP_KERNEL);
+ 		bp->fw_health = fw_health;
+ 		if (!fw_health) {
+ 			rc = -ENOMEM;
+ 			goto err_recovery_out;
+ 		}
+ 	}
+ 	fw_health->flags = le32_to_cpu(resp->flags);
+ 	if ((fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU) &&
+ 	    !(bp->fw_cap & BNXT_FW_CAP_KONG_MB_CHNL)) {
+ 		rc = -EINVAL;
+ 		goto err_recovery_out;
+ 	}
+ 	fw_health->polling_dsecs = le32_to_cpu(resp->driver_polling_freq);
+ 	fw_health->master_func_wait_dsecs =
+ 		le32_to_cpu(resp->master_func_wait_period);
+ 	fw_health->normal_func_wait_dsecs =
+ 		le32_to_cpu(resp->normal_func_wait_period);
+ 	fw_health->post_reset_wait_dsecs =
+ 		le32_to_cpu(resp->master_func_wait_period_after_reset);
+ 	fw_health->post_reset_max_wait_dsecs =
+ 		le32_to_cpu(resp->max_bailout_time_after_reset);
+ 	fw_health->regs[BNXT_FW_HEALTH_REG] =
+ 		le32_to_cpu(resp->fw_health_status_reg);
+ 	fw_health->regs[BNXT_FW_HEARTBEAT_REG] =
+ 		le32_to_cpu(resp->fw_heartbeat_reg);
+ 	fw_health->regs[BNXT_FW_RESET_CNT_REG] =
+ 		le32_to_cpu(resp->fw_reset_cnt_reg);
+ 	fw_health->regs[BNXT_FW_RESET_INPROG_REG] =
+ 		le32_to_cpu(resp->reset_inprogress_reg);
+ 	fw_health->fw_reset_inprog_reg_mask =
+ 		le32_to_cpu(resp->reset_inprogress_reg_mask);
+ 	fw_health->fw_reset_seq_cnt = resp->reg_array_cnt;
+ 	if (fw_health->fw_reset_seq_cnt >= 16) {
+ 		rc = -EINVAL;
+ 		goto err_recovery_out;
+ 	}
+ 	for (i = 0; i < fw_health->fw_reset_seq_cnt; i++) {
+ 		fw_health->fw_reset_seq_regs[i] =
+ 			le32_to_cpu(resp->reset_reg[i]);
+ 		fw_health->fw_reset_seq_vals[i] =
+ 			le32_to_cpu(resp->reset_reg_val[i]);
+ 		fw_health->fw_reset_seq_delay_msec[i] =
+ 			resp->delay_after_reset[i];
+ 	}
+ err_recovery_out:
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ 	if (!rc)
+ 		rc = bnxt_map_fw_health_regs(bp);
+ 	if (rc)
+ 		bp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;
+ 	return rc;
+ }
+ 
++>>>>>>> 9ffbd6773490 (bnxt_en: Pre-map the firmware health monitoring registers.)
  static int bnxt_hwrm_func_reset(struct bnxt *bp)
  {
  	struct hwrm_func_reset_input req = {0};
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 21c36ec4b1cf,78fd5850646b..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1317,6 -1336,44 +1320,47 @@@ struct bnxt_ctx_mem_info 
  	struct bnxt_ctx_pg_info *tqm_mem[9];
  };
  
++<<<<<<< HEAD
++=======
+ struct bnxt_fw_health {
+ 	u32 flags;
+ 	u32 polling_dsecs;
+ 	u32 master_func_wait_dsecs;
+ 	u32 normal_func_wait_dsecs;
+ 	u32 post_reset_wait_dsecs;
+ 	u32 post_reset_max_wait_dsecs;
+ 	u32 regs[4];
+ 	u32 mapped_regs[4];
+ #define BNXT_FW_HEALTH_REG		0
+ #define BNXT_FW_HEARTBEAT_REG		1
+ #define BNXT_FW_RESET_CNT_REG		2
+ #define BNXT_FW_RESET_INPROG_REG	3
+ 	u32 fw_reset_inprog_reg_mask;
+ 	u32 last_fw_heartbeat;
+ 	u32 last_fw_reset_cnt;
+ 	u8 enabled:1;
+ 	u8 master:1;
+ 	u8 tmr_multiplier;
+ 	u8 tmr_counter;
+ 	u8 fw_reset_seq_cnt;
+ 	u32 fw_reset_seq_regs[16];
+ 	u32 fw_reset_seq_vals[16];
+ 	u32 fw_reset_seq_delay_msec[16];
+ };
+ 
+ #define BNXT_FW_HEALTH_REG_TYPE_MASK	3
+ #define BNXT_FW_HEALTH_REG_TYPE_CFG	0
+ #define BNXT_FW_HEALTH_REG_TYPE_GRC	1
+ #define BNXT_FW_HEALTH_REG_TYPE_BAR0	2
+ #define BNXT_FW_HEALTH_REG_TYPE_BAR1	3
+ 
+ #define BNXT_FW_HEALTH_REG_TYPE(reg)	((reg) & BNXT_FW_HEALTH_REG_TYPE_MASK)
+ #define BNXT_FW_HEALTH_REG_OFF(reg)	((reg) & ~BNXT_FW_HEALTH_REG_TYPE_MASK)
+ 
+ #define BNXT_FW_HEALTH_WIN_BASE		0x3000
+ #define BNXT_FW_HEALTH_WIN_MAP_OFF	8
+ 
++>>>>>>> 9ffbd6773490 (bnxt_en: Pre-map the firmware health monitoring registers.)
  struct bnxt {
  	void __iomem		*bar0;
  	void __iomem		*bar1;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
