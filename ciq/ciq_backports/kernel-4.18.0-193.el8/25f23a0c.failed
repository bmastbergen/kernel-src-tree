mm/hmm: improve and rename hmm_vma_get_pfns() to hmm_range_snapshot()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] hmm: improve and rename hmm_vma_get_pfns() to hmm_range_snapshot() (Jerome Glisse) [1498655 1597758]
Rebuild_FUZZ: 97.78%
commit-author Jérôme Glisse <jglisse@redhat.com>
commit 25f23a0c7127b65c4d8200ccda8a352ad5ce1e1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/25f23a0c.failed

Rename for consistency between code, comments and documentation.  Also
improves the comments on all the possible returns values.  Improve the
function by returning the number of populated entries in pfns array.

Link: http://lkml.kernel.org/r/20190403193318.16478-5-jglisse@redhat.com
	Signed-off-by: Jérôme Glisse <jglisse@redhat.com>
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Reviewed-by: John Hubbard <jhubbard@nvidia.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Balbir Singh <bsingharora@gmail.com>
	Cc: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Souptick Joarder <jrdr.linux@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 25f23a0c7127b65c4d8200ccda8a352ad5ce1e1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/vm/hmm.rst
#	mm/hmm.c
diff --cc Documentation/vm/hmm.rst
index cdf3911582c8,d9b27bdadd1b..000000000000
--- a/Documentation/vm/hmm.rst
+++ b/Documentation/vm/hmm.rst
@@@ -189,20 -189,16 +189,31 @@@ the driver callback returns
  When the device driver wants to populate a range of virtual addresses, it can
  use either::
  
++<<<<<<< HEAD
 +  int hmm_vma_get_pfns(struct vm_area_struct *vma,
 +                      struct hmm_range *range,
 +                      unsigned long start,
 +                      unsigned long end,
 +                      hmm_pfn_t *pfns);
 + int hmm_vma_fault(struct vm_area_struct *vma,
 +                   struct hmm_range *range,
 +                   unsigned long start,
 +                   unsigned long end,
 +                   hmm_pfn_t *pfns,
 +                   bool write,
 +                   bool block);
- 
- The first one (hmm_vma_get_pfns()) will only fetch present CPU page table
++=======
+   long hmm_range_snapshot(struct hmm_range *range);
+   int hmm_vma_fault(struct vm_area_struct *vma,
+                     struct hmm_range *range,
+                     unsigned long start,
+                     unsigned long end,
+                     hmm_pfn_t *pfns,
+                     bool write,
+                     bool block);
++>>>>>>> 25f23a0c7127 (mm/hmm: improve and rename hmm_vma_get_pfns() to hmm_range_snapshot())
+ 
+ The first one (hmm_range_snapshot()) will only fetch present CPU page table
  entries and will not trigger a page fault on missing or non-present entries.
  The second one does trigger a page fault on missing or read-only entry if the
  write parameter is true. Page faults use the generic mm page fault code path
diff --cc mm/hmm.c
index 4c052ccc4e21,bd957a9f10d1..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -751,9 -785,15 +754,19 @@@ long hmm_range_snapshot(struct hmm_rang
  	mm_walk.pte_hole = hmm_vma_walk_hole;
  
  	walk_page_range(range->start, range->end, &mm_walk);
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	/*
+ 	 * Transfer hmm reference to the range struct it will be drop inside
+ 	 * the hmm_vma_range_done() function (which _must_ be call if this
+ 	 * function return 0).
+ 	 */
+ 	range->hmm = hmm;
+ 	return (hmm_vma_walk.last - range->start) >> PAGE_SHIFT;
++>>>>>>> 25f23a0c7127 (mm/hmm: improve and rename hmm_vma_get_pfns() to hmm_range_snapshot())
  }
- EXPORT_SYMBOL(hmm_vma_get_pfns);
+ EXPORT_SYMBOL(hmm_range_snapshot);
  
  /*
   * hmm_vma_range_done() - stop tracking change to CPU page table over a range
* Unmerged path Documentation/vm/hmm.rst
diff --git a/include/linux/hmm.h b/include/linux/hmm.h
index e51dc3e6210f..b0ca24756f9a 100644
--- a/include/linux/hmm.h
+++ b/include/linux/hmm.h
@@ -362,11 +362,11 @@ void hmm_mirror_unregister(struct hmm_mirror *mirror);
  * table invalidation serializes on it.
  *
  * YOU MUST CALL hmm_vma_range_done() ONCE AND ONLY ONCE EACH TIME YOU CALL
- * hmm_vma_get_pfns() WITHOUT ERROR !
+ * hmm_range_snapshot() WITHOUT ERROR !
  *
  * IF YOU DO NOT FOLLOW THE ABOVE RULE THE SNAPSHOT CONTENT MIGHT BE INVALID !
  */
-int hmm_vma_get_pfns(struct hmm_range *range);
+long hmm_range_snapshot(struct hmm_range *range);
 bool hmm_vma_range_done(struct hmm_range *range);
 
 
* Unmerged path mm/hmm.c
