net: sched: add skbedit of ptype action to hardware IR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] sched: add skbedit of ptype action to hardware IR (Ivan Vecera) [1757520]
Rebuild_FUZZ: 95.15%
commit-author John Hurley <john.hurley@netronome.com>
commit fb1b775a247ee8d846152841f780eba6cb71bcfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/fb1b775a.failed

TC rules can impliment skbedit actions. Currently actions that modify the
skb mark are passed to offloading drivers via the hardware intermediate
representation in the flow_offload API.

Extend this to include skbedit actions that modify the packet type of the
skb. Such actions may be used to set the ptype to HOST when redirecting a
packet to ingress.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb1b775a247ee8d846152841f780eba6cb71bcfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 51cea3b125f9,ae73d3705571..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -3355,6 -3266,37 +3355,40 @@@ int tc_setup_flow_action(struct flow_ac
  			entry->police.burst = tcf_police_tcfp_burst(act);
  			entry->police.rate_bytes_ps =
  				tcf_police_rate_bytes_ps(act);
++<<<<<<< HEAD
++=======
+ 		} else if (is_tcf_ct(act)) {
+ 			entry->id = FLOW_ACTION_CT;
+ 			entry->ct.action = tcf_ct_action(act);
+ 			entry->ct.zone = tcf_ct_zone(act);
+ 		} else if (is_tcf_mpls(act)) {
+ 			switch (tcf_mpls_action(act)) {
+ 			case TCA_MPLS_ACT_PUSH:
+ 				entry->id = FLOW_ACTION_MPLS_PUSH;
+ 				entry->mpls_push.proto = tcf_mpls_proto(act);
+ 				entry->mpls_push.label = tcf_mpls_label(act);
+ 				entry->mpls_push.tc = tcf_mpls_tc(act);
+ 				entry->mpls_push.bos = tcf_mpls_bos(act);
+ 				entry->mpls_push.ttl = tcf_mpls_ttl(act);
+ 				break;
+ 			case TCA_MPLS_ACT_POP:
+ 				entry->id = FLOW_ACTION_MPLS_POP;
+ 				entry->mpls_pop.proto = tcf_mpls_proto(act);
+ 				break;
+ 			case TCA_MPLS_ACT_MODIFY:
+ 				entry->id = FLOW_ACTION_MPLS_MANGLE;
+ 				entry->mpls_mangle.label = tcf_mpls_label(act);
+ 				entry->mpls_mangle.tc = tcf_mpls_tc(act);
+ 				entry->mpls_mangle.bos = tcf_mpls_bos(act);
+ 				entry->mpls_mangle.ttl = tcf_mpls_ttl(act);
+ 				break;
+ 			default:
+ 				goto err_out;
+ 			}
+ 		} else if (is_tcf_skbedit_ptype(act)) {
+ 			entry->id = FLOW_ACTION_PTYPE;
+ 			entry->ptype = tcf_skbedit_ptype(act);
++>>>>>>> fb1b775a247e (net: sched: add skbedit of ptype action to hardware IR)
  		} else {
  			goto err_out;
  		}
diff --git a/include/net/flow_offload.h b/include/net/flow_offload.h
index 36127c1858a4..41d72c02afd2 100644
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@ -125,6 +125,7 @@ enum flow_action_id {
 	FLOW_ACTION_ADD,
 	FLOW_ACTION_CSUM,
 	FLOW_ACTION_MARK,
+	FLOW_ACTION_PTYPE,
 	FLOW_ACTION_WAKE,
 	FLOW_ACTION_QUEUE,
 	FLOW_ACTION_SAMPLE,
@@ -163,6 +164,7 @@ struct flow_action_entry {
 		const struct ip_tunnel_info *tunnel;	/* FLOW_ACTION_TUNNEL_ENCAP */
 		u32			csum_flags;	/* FLOW_ACTION_CSUM */
 		u32			mark;		/* FLOW_ACTION_MARK */
+		u16                     ptype;          /* FLOW_ACTION_PTYPE */
 		struct {				/* FLOW_ACTION_QUEUE */
 			u32		ctx;
 			u32		index;
* Unmerged path net/sched/cls_api.c
