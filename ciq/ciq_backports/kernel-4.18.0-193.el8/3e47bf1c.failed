mac80211: Simplify Extended Key ID API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Alexander Wetzel <alexander@wetzel-home.de>
commit 3e47bf1ca4c363ba8b1f99c4c3dcda13d2979954
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/3e47bf1c.failed

1) Drop IEEE80211_HW_EXT_KEY_ID_NATIVE and let drivers directly set
   the NL80211_EXT_FEATURE_EXT_KEY_ID flag.

2) Drop IEEE80211_HW_NO_AMPDU_KEYBORDER_SUPPORT and simply assume all
   drivers are unable to handle A-MPDU key borders.

The new Extended Key ID API now requires all mac80211 drivers to set
NL80211_EXT_FEATURE_EXT_KEY_ID when they implement set_key() and can
handle Extended Key ID. For drivers not providing set_key() mac80211
itself enables Extended Key ID support, using the internal SW crypto
services.

	Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
Link: https://lore.kernel.org/r/20190629195015.19680-2-alexander@wetzel-home.de
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 3e47bf1ca4c363ba8b1f99c4c3dcda13d2979954)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/main.c
diff --cc net/mac80211/main.c
index 5c2878092f39,29b9d57df1a3..000000000000
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@@ -1048,23 -1048,15 +1048,33 @@@ int ieee80211_register_hw(struct ieee80
  		}
  	}
  
++<<<<<<< HEAD
 +#if 0  /* Not in RHEL */
 +	/* Enable Extended Key IDs when driver allowed it, or when it
 +	 * supports neither HW crypto nor A-MPDUs
 +	 */
 +	if ((!local->ops->set_key &&
 +	     !ieee80211_hw_check(hw, AMPDU_AGGREGATION)) ||
 +	    ieee80211_hw_check(&local->hw, EXT_KEY_ID_NATIVE))
 +		wiphy_ext_feature_set(local->hw.wiphy,
 +				      NL80211_EXT_FEATURE_EXT_KEY_ID);
 +#endif
 +
 +	/* Mac80211 and therefore all cards only using SW crypto are able to
 +	 * handle PTK rekeys correctly
 +	 */
 +	if (!local->ops->set_key)
++=======
+ 	/* Mac80211 and therefore all drivers using SW crypto only
+ 	 * are able to handle PTK rekeys and Extended Key ID.
+ 	 */
+ 	if (!local->ops->set_key) {
++>>>>>>> 3e47bf1ca4c3 (mac80211: Simplify Extended Key ID API)
  		wiphy_ext_feature_set(local->hw.wiphy,
  				      NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
+ 		wiphy_ext_feature_set(local->hw.wiphy,
+ 				      NL80211_EXT_FEATURE_EXT_KEY_ID);
+ 	}
  
  	/*
  	 * Calculate scan IE length -- we need this to alloc
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index b47436ca5fea..12e4033be054 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -2273,12 +2273,6 @@ struct ieee80211_txq {
  * @IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID: Hardware supports multi BSSID
  *	only for HE APs. Applies if @IEEE80211_HW_SUPPORTS_MULTI_BSSID is set.
  *
- * @IEEE80211_HW_EXT_KEY_ID_NATIVE: Driver and hardware are supporting Extended
- *	Key ID and can handle two unicast keys per station for Rx and Tx.
- *
- * @IEEE80211_HW_NO_AMPDU_KEYBORDER_SUPPORT: The card/driver can't handle
- *	active Tx A-MPDU sessions with Extended Key IDs during rekey.
- *
  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
  */
 enum ieee80211_hw_flags {
@@ -2330,8 +2324,6 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,
 	IEEE80211_HW_SUPPORTS_MULTI_BSSID,
 	IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,
-	IEEE80211_HW_EXT_KEY_ID_NATIVE,
-	IEEE80211_HW_NO_AMPDU_KEYBORDER_SUPPORT,
 
 	/* keep last, obviously */
 	NUM_IEEE80211_HW_FLAGS
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 2e7f75938c51..47435f57e086 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -271,8 +271,6 @@ static const char *hw_flag_names[] = {
 	FLAG(TX_STATUS_NO_AMPDU_LEN),
 	FLAG(SUPPORTS_MULTI_BSSID),
 	FLAG(SUPPORTS_ONLY_HE_MULTI_BSSID),
-	FLAG(EXT_KEY_ID_NATIVE),
-	FLAG(NO_AMPDU_KEYBORDER_SUPPORT),
 #undef FLAG
 };
 
diff --git a/net/mac80211/key.c b/net/mac80211/key.c
index dd60f6428049..92c3affb0eb0 100644
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@ -270,8 +270,7 @@ int ieee80211_set_tx_key(struct ieee80211_key *key)
 
 	sta->ptk_idx = key->conf.keyidx;
 
-	if (ieee80211_hw_check(&local->hw, NO_AMPDU_KEYBORDER_SUPPORT))
-		clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
+	clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
 	ieee80211_check_fast_xmit(sta);
 
 	return 0;
@@ -289,16 +288,15 @@ static void ieee80211_pairwise_rekey(struct ieee80211_key *old,
 	if (new->conf.flags & IEEE80211_KEY_FLAG_NO_AUTO_TX) {
 		/* Extended Key ID key install, initial one or rekey */
 
-		if (sta->ptk_idx != INVALID_PTK_KEYIDX &&
-		    ieee80211_hw_check(&local->hw,
-				       NO_AMPDU_KEYBORDER_SUPPORT)) {
+		if (sta->ptk_idx != INVALID_PTK_KEYIDX) {
 			/* Aggregation Sessions with Extended Key ID must not
 			 * mix MPDUs with different keyIDs within one A-MPDU.
-			 * Tear down any running Tx aggregation and all new
-			 * Rx/Tx aggregation request during rekey if the driver
-			 * asks us to do so. (Blocking Tx only would be
-			 * sufficient but WLAN_STA_BLOCK_BA gets the job done
-			 * for the few ms we need it.)
+			 * Tear down running Tx aggregation sessions and block
+			 * new Rx/Tx aggregation requests during rekey to
+			 * ensure there are no A-MPDUs for the driver to
+			 * aggregate. (Blocking Tx only would be sufficient but
+			 * WLAN_STA_BLOCK_BA gets the job done for the few ms
+			 * we need it.)
 			 */
 			set_sta_flag(sta, WLAN_STA_BLOCK_BA);
 			mutex_lock(&sta->ampdu_mlme.mtx);
* Unmerged path net/mac80211/main.c
