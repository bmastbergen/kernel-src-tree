netfilter: nf_tables: don't prevent event handler from device cleanup on netns exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit 6a48de0144767f2c6880540c0a4ac6741e3c440b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/6a48de01.failed

When a netnsamespace exits, the nf_tables pernet_ops will remove all rules.
However, there is one caveat:

Base chains that register ingress hooks will cause use-after-free:
device is already gone at that point.

The device event handlers prevent this from happening:
netns exit synthesizes unregister events for all devices.

However, an improper fix for a race condition made the notifiers a no-op
in case they get called from netns exit path, so revert that part.

This is safe now as the previous patch fixed nf_tables pernet ops
and device notifier initialisation ordering.

Fixes: 0a2cf5ee432c2 ("netfilter: nf_tables: close race between netns exit and rmmod")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6a48de0144767f2c6880540c0a4ac6741e3c440b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_chain_filter.c
diff --cc net/netfilter/nf_tables_api.c
index 353328df22a0,1dca5683f59f..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -5985,18 -5925,15 +5985,28 @@@ static int nf_tables_flowtable_event(st
  	if (event != NETDEV_UNREGISTER)
  		return 0;
  
++<<<<<<< HEAD
 +	net = maybe_get_net(dev_net(dev));
 +	if (!net)
 +		return 0;
 +
 +	nfnl_lock(NFNL_SUBSYS_NFTABLES);
++=======
+ 	net = dev_net(dev);
+ 	mutex_lock(&net->nft.commit_mutex);
++>>>>>>> 6a48de014476 (netfilter: nf_tables: don't prevent event handler from device cleanup on netns exit)
  	list_for_each_entry(table, &net->nft.tables, list) {
  		list_for_each_entry(flowtable, &table->flowtables, list) {
  			nft_flowtable_event(event, dev, flowtable);
  		}
  	}
++<<<<<<< HEAD
 +	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
 +	put_net(net);
++=======
+ 	mutex_unlock(&net->nft.commit_mutex);
+ 
++>>>>>>> 6a48de014476 (netfilter: nf_tables: don't prevent event handler from device cleanup on netns exit)
  	return NOTIFY_DONE;
  }
  
diff --cc net/netfilter/nft_chain_filter.c
index fa8dbcb0c580,3fd540b2c6ba..000000000000
--- a/net/netfilter/nft_chain_filter.c
+++ b/net/netfilter/nft_chain_filter.c
@@@ -318,11 -325,7 +325,15 @@@ static int nf_tables_netdev_event(struc
  	    event != NETDEV_CHANGENAME)
  		return NOTIFY_DONE;
  
++<<<<<<< HEAD
 +	ctx.net = maybe_get_net(ctx.net);
 +	if (!ctx.net)
 +		return NOTIFY_DONE;
 +
 +	nfnl_lock(NFNL_SUBSYS_NFTABLES);
++=======
+ 	mutex_lock(&ctx.net->nft.commit_mutex);
++>>>>>>> 6a48de014476 (netfilter: nf_tables: don't prevent event handler from device cleanup on netns exit)
  	list_for_each_entry(table, &ctx.net->nft.tables, list) {
  		if (table->family != NFPROTO_NETDEV)
  			continue;
@@@ -337,8 -340,7 +348,12 @@@
  			nft_netdev_event(event, dev, &ctx);
  		}
  	}
++<<<<<<< HEAD
 +	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
 +	put_net(ctx.net);
++=======
+ 	mutex_unlock(&ctx.net->nft.commit_mutex);
++>>>>>>> 6a48de014476 (netfilter: nf_tables: don't prevent event handler from device cleanup on netns exit)
  
  	return NOTIFY_DONE;
  }
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_chain_filter.c
