net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership (Alaa Hleihel) [1724333]
Rebuild_FUZZ: 96.97%
commit-author Bodong Wang <bodong@mellanox.com>
commit 81cd229c294e2e416e9161d9286d34f3aaf19348
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/81cd229c.failed

ECPF connects to the eswitch through vport 0xfffe. ECPF may or may
not be the eswitch manager depending on firmware configuration.

1. If ECPF is eswitch manager: ECPF will take over the eswitch manager
   responsibility. A rep of the host PF shall be created at the ECPF
   side for the eswitch manager to control.

2. If ECPF is not eswitch manager: host PF will be the eswitch manager,
   ECPF acts similar as a VF to the host PF. Host PF will be aware
   of the ECPF vport presence and control it's rep.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 81cd229c294e2e416e9161d9286d34f3aaf19348)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	include/linux/mlx5/vport.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index c2e828153dd7,d2ab1ee19b2a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1631,7 -1666,8 +1631,12 @@@ int mlx5_eswitch_enable_sriov(struct ml
  	} else {
  		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_ETH);
  		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
++<<<<<<< HEAD
 +		err = esw_offloads_init(esw, nvfs + MLX5_SPECIAL_VPORTS);
++=======
+ 		err = esw_offloads_init(esw, nvfs,
+ 					nvfs + MLX5_SPECIAL_VPORTS(esw->dev));
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  	}
  
  	if (err)
@@@ -1646,8 -1682,20 +1651,25 @@@
  	 * 2. FDB/Eswitch is programmed by user space tools
  	 */
  	enabled_events = (mode == SRIOV_LEGACY) ? SRIOV_VPORT_EVENTS : 0;
++<<<<<<< HEAD
 +	for (i = 0; i <= nvfs; i++)
 +		esw_enable_vport(esw, i, enabled_events);
++=======
+ 
+ 	/* Enable PF vport */
+ 	vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_PF);
+ 	esw_enable_vport(esw, vport, enabled_events);
+ 
+ 	/* Enable ECPF vports */
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_ECPF);
+ 		esw_enable_vport(esw, vport, enabled_events);
+ 	}
+ 
+ 	/* Enable VF vports */
+ 	mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)
+ 		esw_enable_vport(esw, vport, enabled_events);
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  
  	if (mode == SRIOV_LEGACY) {
  		MLX5_NB_INIT(&esw->nb, eswitch_vport_event, NIC_VPORT_CHANGE);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 6a7d5023272b,2baa0d71380c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -368,8 -367,51 +368,56 @@@ bool mlx5_esw_multipath_prereq(struct m
  #define esw_debug(dev, format, ...)				\
  	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
  
++<<<<<<< HEAD
 +/* TODO: This mlx5e_tc function shouldn't be called by eswitch */
 +void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
++=======
+ /* The returned number is valid only when the dev is eswitch manager. */
+ static inline u16 mlx5_eswitch_manager_vport(struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_core_is_ecpf_esw_manager(dev) ?
+ 		MLX5_VPORT_ECPF : MLX5_VPORT_PF;
+ }
+ 
+ static inline int mlx5_eswitch_uplink_idx(struct mlx5_eswitch *esw)
+ {
+ 	/* Uplink always locate at the last element of the array.*/
+ 	return esw->total_vports - 1;
+ }
+ 
+ static inline int mlx5_eswitch_ecpf_idx(struct mlx5_eswitch *esw)
+ {
+ 	return esw->total_vports - 2;
+ }
+ 
+ static inline int mlx5_eswitch_vport_num_to_index(struct mlx5_eswitch *esw,
+ 						  u16 vport_num)
+ {
+ 	if (vport_num == MLX5_VPORT_ECPF) {
+ 		if (!mlx5_ecpf_vport_exists(esw->dev))
+ 			esw_warn(esw->dev, "ECPF vport doesn't exist!\n");
+ 		return mlx5_eswitch_ecpf_idx(esw);
+ 	}
+ 
+ 	if (vport_num == MLX5_VPORT_UPLINK)
+ 		return mlx5_eswitch_uplink_idx(esw);
+ 
+ 	return vport_num;
+ }
+ 
+ static inline int mlx5_eswitch_index_to_vport_num(struct mlx5_eswitch *esw,
+ 						  int index)
+ {
+ 	if (index == mlx5_eswitch_ecpf_idx(esw) &&
+ 	    mlx5_ecpf_vport_exists(esw->dev))
+ 		return MLX5_VPORT_ECPF;
+ 
+ 	if (index == mlx5_eswitch_uplink_idx(esw))
+ 		return MLX5_VPORT_UPLINK;
+ 
+ 	return index;
+ }
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a13e7b20a794,84a33f8e3350..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -601,7 -639,29 +601,33 @@@ static int esw_add_fdb_peer_miss_rules(
  	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value,
  			    misc_parameters);
  
++<<<<<<< HEAD
 +	for (i = 1; i < nvports; i++) {
++=======
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		MLX5_SET(fte_match_set_misc, misc, source_port, MLX5_VPORT_PF);
+ 		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 					   spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow)) {
+ 			err = PTR_ERR(flow);
+ 			goto add_pf_flow_err;
+ 		}
+ 		flows[MLX5_VPORT_PF] = flow;
+ 	}
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		MLX5_SET(fte_match_set_misc, misc, source_port, MLX5_VPORT_ECPF);
+ 		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 					   spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow)) {
+ 			err = PTR_ERR(flow);
+ 			goto add_ecpf_flow_err;
+ 		}
+ 		flows[mlx5_eswitch_ecpf_idx(esw)] = flow;
+ 	}
+ 
+ 	mlx5_esw_for_each_vf_vport(esw, i, mlx5_core_max_vfs(esw->dev)) {
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  		MLX5_SET(fte_match_set_misc, misc, source_port, i);
  		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
  					   spec, &flow_act, &dest, 1);
@@@ -618,9 -677,18 +643,23 @@@
  	kvfree(spec);
  	return 0;
  
++<<<<<<< HEAD
 +add_flow_err:
 +	for (i--; i > 0; i--)
++=======
+ add_vf_flow_err:
+ 	nvports = --i;
+ 	mlx5_esw_for_each_vf_vport_reverse(esw, i, nvports)
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  		mlx5_del_flow_rules(flows[i]);
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev))
+ 		mlx5_del_flow_rules(flows[mlx5_eswitch_ecpf_idx(esw)]);
+ add_ecpf_flow_err:
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev))
+ 		mlx5_del_flow_rules(flows[MLX5_VPORT_PF]);
+ add_pf_flow_err:
+ 	esw_warn(esw->dev, "FDB: Failed to add peer miss flow rule err %d\n", err);
  	kvfree(flows);
  alloc_flows_err:
  	kvfree(spec);
@@@ -634,9 -702,15 +673,15 @@@ static void esw_del_fdb_peer_miss_rules
  
  	flows = esw->fdb_table.offloads.peer_miss_rules;
  
 -	mlx5_esw_for_each_vf_vport_reverse(esw, i, mlx5_core_max_vfs(esw->dev))
 +	for (i = 1; i < esw->total_vports; i++)
  		mlx5_del_flow_rules(flows[i]);
  
+ 	if (mlx5_ecpf_vport_exists(esw->dev))
+ 		mlx5_del_flow_rules(flows[mlx5_eswitch_ecpf_idx(esw)]);
+ 
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev))
+ 		mlx5_del_flow_rules(flows[MLX5_VPORT_PF]);
+ 
  	kvfree(flows);
  }
  
@@@ -1223,57 -1296,163 +1268,174 @@@ int esw_offloads_init_reps(struct mlx5_
  	if (!esw->offloads.vport_reps)
  		return -ENOMEM;
  
 +	offloads = &esw->offloads;
  	mlx5_query_nic_vport_mac_address(dev, 0, hw_id);
  
 -	mlx5_esw_for_all_reps(esw, vport, rep) {
 -		rep->vport = mlx5_eswitch_index_to_vport_num(esw, vport);
 -		ether_addr_copy(rep->hw_id, hw_id);
 +	for (vport = 0; vport < total_vfs; vport++) {
 +		rep = &offloads->vport_reps[vport];
  
 -		for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
 -			rep->rep_if[rep_type].state = REP_UNREGISTERED;
 +		rep->vport = vport;
 +		ether_addr_copy(rep->hw_id, hw_id);
  	}
  
++<<<<<<< HEAD
 +	offloads->vport_reps[0].vport = FDB_UPLINK_VPORT;
++=======
+ 	return 0;
+ }
+ 
+ static void __esw_offloads_unload_rep(struct mlx5_eswitch *esw,
+ 				      struct mlx5_eswitch_rep *rep, u8 rep_type)
+ {
+ 	if (rep->rep_if[rep_type].state != REP_LOADED)
+ 		return;
+ 
+ 	rep->rep_if[rep_type].unload(rep);
+ 	rep->rep_if[rep_type].state = REP_REGISTERED;
+ }
+ 
+ static void __unload_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
+ {
+ 	struct mlx5_eswitch_rep *rep;
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
+ 		__esw_offloads_unload_rep(esw, rep, rep_type);
+ 	}
+ 
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
+ 		__esw_offloads_unload_rep(esw, rep, rep_type);
+ 	}
+ 
+ 	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
+ 	__esw_offloads_unload_rep(esw, rep, rep_type);
+ }
+ 
+ static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
+ 				   u8 rep_type)
+ {
+ 	struct mlx5_eswitch_rep *rep;
+ 	int i;
+ 
+ 	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
+ 		__esw_offloads_unload_rep(esw, rep, rep_type);
+ }
+ 
+ static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
+ {
+ 	u8 rep_type = NUM_REP_TYPES;
+ 
+ 	while (rep_type-- > 0)
+ 		__unload_reps_vf_vport(esw, nvports, rep_type);
+ }
+ 
+ static void __unload_reps_all_vport(struct mlx5_eswitch *esw, int nvports,
+ 				    u8 rep_type)
+ {
+ 	__unload_reps_vf_vport(esw, nvports, rep_type);
+ 
+ 	/* Special vports must be the last to unload. */
+ 	__unload_reps_special_vport(esw, rep_type);
+ }
+ 
+ static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw, int nvports)
+ {
+ 	u8 rep_type = NUM_REP_TYPES;
+ 
+ 	while (rep_type-- > 0)
+ 		__unload_reps_all_vport(esw, nvports, rep_type);
+ }
+ 
+ static int __esw_offloads_load_rep(struct mlx5_eswitch *esw,
+ 				   struct mlx5_eswitch_rep *rep, u8 rep_type)
+ {
+ 	int err = 0;
+ 
+ 	if (rep->rep_if[rep_type].state != REP_REGISTERED)
+ 		return 0;
+ 
+ 	err = rep->rep_if[rep_type].load(esw->dev, rep);
+ 	if (err)
+ 		return err;
+ 
+ 	rep->rep_if[rep_type].state = REP_LOADED;
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  
  	return 0;
  }
  
 -static int __load_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
 +static void esw_offloads_unload_reps_type(struct mlx5_eswitch *esw, int nvports,
 +					  u8 rep_type)
 +{
 +	struct mlx5_eswitch_rep *rep;
 +	int vport;
 +
 +	for (vport = nvports - 1; vport >= 0; vport--) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
 +
 +		rep->rep_if[rep_type].unload(rep);
 +	}
 +}
 +
 +static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
 +{
 +	u8 rep_type = NUM_REP_TYPES;
 +
 +	while (rep_type-- > 0)
 +		esw_offloads_unload_reps_type(esw, nvports, rep_type);
 +}
 +
 +static int esw_offloads_load_reps_type(struct mlx5_eswitch *esw, int nvports,
 +				       u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 +	int vport;
  	int err;
  
++<<<<<<< HEAD
 +	for (vport = 0; vport < nvports; vport++) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
++=======
+ 	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
+ 	err = __esw_offloads_load_rep(esw, rep, rep_type);
+ 	if (err)
+ 		return err;
+ 
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
+ 		err = __esw_offloads_load_rep(esw, rep, rep_type);
+ 		if (err)
+ 			goto err_pf;
+ 	}
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_ECPF);
+ 		err = __esw_offloads_load_rep(esw, rep, rep_type);
+ 		if (err)
+ 			goto err_ecpf;
+ 	}
+ 
+ 	return 0;
+ 
+ err_ecpf:
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_PF);
+ 		__esw_offloads_unload_rep(esw, rep, rep_type);
+ 	}
+ 
+ err_pf:
+ 	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
+ 	__esw_offloads_unload_rep(esw, rep, rep_type);
+ 	return err;
+ }
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  
 -static int __load_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 -				u8 rep_type)
 -{
 -	struct mlx5_eswitch_rep *rep;
 -	int err, i;
 -
 -	mlx5_esw_for_each_vf_rep(esw, i, rep, nvports) {
 -		err = __esw_offloads_load_rep(esw, rep, rep_type);
 -		if (err)
 -			goto err_vf;
 -	}
 -
 -	return 0;
 -
 -err_vf:
 -	__unload_reps_vf_vport(esw, --i, rep_type);
 -	return err;
 -}
 -
 -static int esw_offloads_load_vf_reps(struct mlx5_eswitch *esw, int nvports)
 -{
 -	u8 rep_type = 0;
 -	int err;
 -
 -	for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++) {
 -		err = __load_reps_vf_vport(esw, nvports, rep_type);
 +		err = rep->rep_if[rep_type].load(esw->dev, rep);
  		if (err)
  			goto err_reps;
  	}
diff --cc include/linux/mlx5/vport.h
index 75268e380ab7,0eef548b9946..000000000000
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@@ -36,9 -36,16 +36,22 @@@
  #include <linux/mlx5/driver.h>
  #include <linux/mlx5/device.h>
  
++<<<<<<< HEAD
 +#define MLX5_VPORT_PF_PLACEHOLDER (1u)
 +#define MLX5_SPECIAL_VPORTS (MLX5_VPORT_PF_PLACEHOLDER)
 +#define MLX5_TOTAL_VPORTS(mdev) (MLX5_SPECIAL_VPORTS +	mlx5_core_max_vfs(mdev))
++=======
+ #define MLX5_VPORT_PF_PLACEHOLDER		(1u)
+ #define MLX5_VPORT_UPLINK_PLACEHOLDER		(1u)
+ #define MLX5_VPORT_ECPF_PLACEHOLDER(mdev)	(mlx5_ecpf_vport_exists(mdev))
+ 
+ #define MLX5_SPECIAL_VPORTS(mdev) (MLX5_VPORT_PF_PLACEHOLDER +		\
+ 				   MLX5_VPORT_UPLINK_PLACEHOLDER +	\
+ 				   MLX5_VPORT_ECPF_PLACEHOLDER(mdev))
+ 
+ #define MLX5_TOTAL_VPORTS(mdev)	(MLX5_SPECIAL_VPORTS(mdev) +		\
+ 				 mlx5_core_max_vfs(mdev))
++>>>>>>> 81cd229c294e (net/mlx5: E-Switch, Consider ECPF vport depends on eswitch ownership)
  
  #define MLX5_VPORT_MANAGER(mdev)					\
  	(MLX5_CAP_GEN(mdev, vport_group_manager) &&			\
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index ba41de3212a3..35ff6182342d 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -1087,6 +1087,11 @@ static inline bool mlx5_core_is_ecpf_esw_manager(struct mlx5_core_dev *dev)
 	return dev->caps.embedded_cpu && MLX5_CAP_GEN(dev, eswitch_manager);
 }
 
+static inline bool mlx5_ecpf_vport_exists(struct mlx5_core_dev *dev)
+{
+	return mlx5_core_is_pf(dev) && MLX5_CAP_ESW(dev, ecpf_vport_exists);
+}
+
 #define MLX5_HOST_PF_MAX_VFS	(127u)
 static inline u16 mlx5_core_max_vfs(struct mlx5_core_dev *dev)
 {
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index 1abd9dc6c1ff..3b83288749c6 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -631,7 +631,8 @@ struct mlx5_ifc_e_switch_cap_bits {
 	u8         vport_svlan_insert[0x1];
 	u8         vport_cvlan_insert_if_not_exist[0x1];
 	u8         vport_cvlan_insert_overwrite[0x1];
-	u8         reserved_at_5[0x17];
+	u8         reserved_at_5[0x16];
+	u8         ecpf_vport_exists[0x1];
 	u8         counter_eswitch_affinity[0x1];
 	u8         merged_eswitch[0x1];
 	u8         nic_vport_node_guid_modify[0x1];
* Unmerged path include/linux/mlx5/vport.h
