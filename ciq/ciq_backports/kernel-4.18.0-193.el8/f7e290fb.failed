net: phy: icplus: implement .did_interrupt for IP101A/G

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] phy: icplus: implement .did_interrupt for IP101A/G (Petr Oros) [1772010]
Rebuild_FUZZ: 95.24%
commit-author Martin Blumenstingl <martin.blumenstingl@googlemail.com>
commit f7e290fbeb336421ba6237548b693c9afb4d75fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f7e290fb.failed

The IP101A_G_IRQ_CONF_STATUS register has bits to detect which
interrupts have fired. Implement the .did_interrupt callback to let the
PHY core know whether the interrupt was for this specific PHY.

This is useful for debugging interrupt problems with 32-pin IP101GR PHYs
where the interrupt line is shared with the RX_ERR (receive error
status) signal. The default values are:
- RX_ERR is enabled by default (LOW means that there is no receive
  error)
- the PHY's interrupt line is configured "active low" by default

Without any additional changes there is a flood of interrupts if the
RX_ERR/INTR32 signal is configured in RX_ERR mode (which is the
default). Having a did_interrupt ensures that the PHY core returns
IRQ_NONE instead of endlessly triggering the PHY state machine.
Additionally the kernel will report this after a while:
  irq 28: nobody cared (try booting with the "irqpoll" option)

	Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f7e290fbeb336421ba6237548b693c9afb4d75fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/icplus.c
diff --cc drivers/net/phy/icplus.c
index 6dc83343b55c,3dc8bbbe746b..000000000000
--- a/drivers/net/phy/icplus.c
+++ b/drivers/net/phy/icplus.c
@@@ -42,8 -42,11 +42,16 @@@ MODULE_LICENSE("GPL")
  #define IP1001_APS_ON			11	/* IP1001 APS Mode  bit */
  #define IP101A_G_APS_ON			BIT(1)	/* IP101A/G APS Mode bit */
  #define IP101A_G_IRQ_CONF_STATUS	0x11	/* Conf Info IRQ & Status Reg */
++<<<<<<< HEAD
 +#define	IP101A_G_IRQ_PIN_USED		(1<<15) /* INTR pin used */
 +#define	IP101A_G_IRQ_DEFAULT		IP101A_G_IRQ_PIN_USED
++=======
+ #define	IP101A_G_IRQ_PIN_USED		BIT(15) /* INTR pin used */
+ #define IP101A_G_IRQ_ALL_MASK		BIT(11) /* IRQ's inactive */
+ #define IP101A_G_IRQ_SPEED_CHANGE	BIT(2)
+ #define IP101A_G_IRQ_DUPLEX_CHANGE	BIT(1)
+ #define IP101A_G_IRQ_LINK_CHANGE	BIT(0)
++>>>>>>> f7e290fbeb33 (net: phy: icplus: implement .did_interrupt for IP101A/G)
  
  static int ip175c_config_init(struct phy_device *phydev)
  {
@@@ -201,6 -184,46 +209,49 @@@ static int ip175c_config_aneg(struct ph
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ip101a_g_config_init(struct phy_device *phydev)
+ {
+ 	int c;
+ 
+ 	c = ip1xx_reset(phydev);
+ 	if (c < 0)
+ 		return c;
+ 
+ 	/* Enable Auto Power Saving mode */
+ 	c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
+ 	c |= IP101A_G_APS_ON;
+ 
+ 	return phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
+ }
+ 
+ static int ip101a_g_config_intr(struct phy_device *phydev)
+ {
+ 	u16 val;
+ 
+ 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+ 		/* INTR pin used: Speed/link/duplex will cause an interrupt */
+ 		val = IP101A_G_IRQ_PIN_USED;
+ 	else
+ 		val = IP101A_G_IRQ_ALL_MASK;
+ 
+ 	return phy_write(phydev, IP101A_G_IRQ_CONF_STATUS, val);
+ }
+ 
+ static int ip101a_g_did_interrupt(struct phy_device *phydev)
+ {
+ 	int val = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
+ 
+ 	if (val < 0)
+ 		return 0;
+ 
+ 	return val & (IP101A_G_IRQ_SPEED_CHANGE |
+ 		      IP101A_G_IRQ_DUPLEX_CHANGE |
+ 		      IP101A_G_IRQ_LINK_CHANGE);
+ }
+ 
++>>>>>>> f7e290fbeb33 (net: phy: icplus: implement .did_interrupt for IP101A/G)
  static int ip101a_g_ack_interrupt(struct phy_device *phydev)
  {
  	int err = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
@@@ -234,7 -257,8 +285,12 @@@ static struct phy_driver icplus_driver[
  	.name		= "ICPlus IP101A/G",
  	.phy_id_mask	= 0x0ffffff0,
  	.features	= PHY_BASIC_FEATURES,
++<<<<<<< HEAD
 +	.flags		= PHY_HAS_INTERRUPT,
++=======
+ 	.config_intr	= ip101a_g_config_intr,
+ 	.did_interrupt	= ip101a_g_did_interrupt,
++>>>>>>> f7e290fbeb33 (net: phy: icplus: implement .did_interrupt for IP101A/G)
  	.ack_interrupt	= ip101a_g_ack_interrupt,
  	.config_init	= &ip101a_g_config_init,
  	.suspend	= genphy_suspend,
* Unmerged path drivers/net/phy/icplus.c
