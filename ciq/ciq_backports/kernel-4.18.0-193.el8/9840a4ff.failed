selftests/bpf: fix race in flow dissector tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Petar Penkov <ppenkov@google.com>
commit 9840a4ffcf0b26e08472ed53d176a6a0f1d4c498
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9840a4ff.failed

Since the "last_dissection" map holds only the flow keys for the most
recent packet, there is a small race in the skb-less flow dissector
tests if a new packet comes between transmitting the test packet, and
reading its keys from the map. If this happens, the test packet keys
will be overwritten and the test will fail.

Changing the "last_dissection" map to a hash map, keyed on the
source/dest port pair resolves this issue. Additionally, let's clear the
last test results from the map between tests to prevent previous test
cases from interfering with the following test cases.

Fixes: 0905beec9f52 ("selftests/bpf: run flow dissector tests in skb-less mode")
	Signed-off-by: Petar Penkov <ppenkov@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 9840a4ffcf0b26e08472ed53d176a6a0f1d4c498)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/bpf_flow.c
#	tools/testing/selftests/bpf/prog_tests/flow_dissector.c
diff --cc tools/testing/selftests/bpf/bpf_flow.c
index 284660f5aa95,040a44206f29..000000000000
--- a/tools/testing/selftests/bpf/bpf_flow.c
+++ b/tools/testing/selftests/bpf/bpf_flow.c
@@@ -57,12 -57,36 +57,45 @@@ struct frag_hdr 
  	__be32 identification;
  };
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/bpf_flow.c
 +struct bpf_map_def SEC("maps") jmp_table = {
 +	.type = BPF_MAP_TYPE_PROG_ARRAY,
 +	.key_size = sizeof(__u32),
 +	.value_size = sizeof(__u32),
 +	.max_entries = 8
 +};
++=======
+ struct {
+ 	__uint(type, BPF_MAP_TYPE_PROG_ARRAY);
+ 	__uint(max_entries, 8);
+ 	__uint(key_size, sizeof(__u32));
+ 	__uint(value_size, sizeof(__u32));
+ } jmp_table SEC(".maps");
+ 
+ struct {
+ 	__uint(type, BPF_MAP_TYPE_HASH);
+ 	__uint(max_entries, 1024);
+ 	__type(key, __u32);
+ 	__type(value, struct bpf_flow_keys);
+ } last_dissection SEC(".maps");
+ 
+ static __always_inline int export_flow_keys(struct bpf_flow_keys *keys,
+ 					    int ret)
+ {
+ 	__u32 key = (__u32)(keys->sport) << 16 | keys->dport;
+ 	struct bpf_flow_keys val;
+ 
+ 	memcpy(&val, keys, sizeof(val));
+ 	bpf_map_update_elem(&last_dissection, &key, &val, BPF_ANY);
+ 	return ret;
+ }
+ 
+ #define IPV6_FLOWLABEL_MASK		__bpf_constant_htonl(0x000FFFFF)
+ static inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)
+ {
+ 	return *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;
+ }
++>>>>>>> 9840a4ffcf0b (selftests/bpf: fix race in flow dissector tests):tools/testing/selftests/bpf/progs/bpf_flow.c
  
  static __always_inline void *bpf_flow_dissect_get_header(struct __sk_buff *skb,
  							 __u16 hdr_size,
* Unmerged path tools/testing/selftests/bpf/prog_tests/flow_dissector.c
* Unmerged path tools/testing/selftests/bpf/bpf_flow.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/flow_dissector.c
