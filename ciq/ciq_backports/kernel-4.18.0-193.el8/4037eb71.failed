bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state (Jonathan Toppins) [1724766]
Rebuild_FUZZ: 99.13%
commit-author Vasundhara Volam <vasundhara-v.volam@broadcom.com>
commit 4037eb715680caa3d80075fb54dbc35d79d5f9ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4037eb71.failed

This new state is required when firmware indicates that the error
recovery process requires polling for firmware state to be completely
down before initiating reset.  For example, firmware may take some
time to collect the crash dump before it is down and ready to be
reset.

	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4037eb715680caa3d80075fb54dbc35d79d5f9ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index edad0df8fa2b,b4a8cf620a0c..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -6718,6 -6941,14 +6718,17 @@@ static int __bnxt_hwrm_func_qcaps(struc
  		bp->flags |= BNXT_FLAG_ROCEV1_CAP;
  	if (flags & FUNC_QCAPS_RESP_FLAGS_ROCE_V2_SUPPORTED)
  		bp->flags |= BNXT_FLAG_ROCEV2_CAP;
++<<<<<<< HEAD
++=======
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_PCIE_STATS_SUPPORTED)
+ 		bp->fw_cap |= BNXT_FW_CAP_PCIE_STATS_SUPPORTED;
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_EXT_STATS_SUPPORTED)
+ 		bp->fw_cap |= BNXT_FW_CAP_EXT_STATS_SUPPORTED;
+ 	if (flags &  FUNC_QCAPS_RESP_FLAGS_ERROR_RECOVERY_CAPABLE)
+ 		bp->fw_cap |= BNXT_FW_CAP_ERROR_RECOVERY;
+ 	if (flags & FUNC_QCAPS_RESP_FLAGS_ERR_RECOVER_RELOAD)
+ 		bp->fw_cap |= BNXT_FW_CAP_ERR_RECOVER_RELOAD;
++>>>>>>> 4037eb715680 (bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.)
  
  	bp->tx_push_thresh = 0;
  	if (flags & FUNC_QCAPS_RESP_FLAGS_PUSH_MODE_SUPPORTED)
@@@ -9539,6 -10046,138 +9550,141 @@@ static void bnxt_reset(struct bnxt *bp
  	bnxt_rtnl_unlock_sp(bp);
  }
  
++<<<<<<< HEAD
++=======
+ static void bnxt_fw_reset_close(struct bnxt *bp)
+ {
+ 	__bnxt_close_nic(bp, true, false);
+ 	bnxt_ulp_irq_stop(bp);
+ 	bnxt_clear_int_mode(bp);
+ 	bnxt_hwrm_func_drv_unrgtr(bp);
+ 	bnxt_free_ctx_mem(bp);
+ 	kfree(bp->ctx);
+ 	bp->ctx = NULL;
+ }
+ 
+ static bool is_bnxt_fw_ok(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	bool no_heartbeat = false, has_reset = false;
+ 	u32 val;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);
+ 	if (val == fw_health->last_fw_heartbeat)
+ 		no_heartbeat = true;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
+ 	if (val != fw_health->last_fw_reset_cnt)
+ 		has_reset = true;
+ 
+ 	if (!no_heartbeat && has_reset)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* rtnl_lock is acquired before calling this function */
+ static void bnxt_force_fw_reset(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 wait_dsecs;
+ 
+ 	if (!test_bit(BNXT_STATE_OPEN, &bp->state) ||
+ 	    test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 		return;
+ 
+ 	set_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 	bnxt_fw_reset_close(bp);
+ 	wait_dsecs = fw_health->master_func_wait_dsecs;
+ 	if (fw_health->master) {
+ 		if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU)
+ 			wait_dsecs = 0;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;
+ 	} else {
+ 		bp->fw_reset_timestamp = jiffies + wait_dsecs * HZ / 10;
+ 		wait_dsecs = fw_health->normal_func_wait_dsecs;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 	}
+ 
+ 	bp->fw_reset_min_dsecs = fw_health->post_reset_wait_dsecs;
+ 	bp->fw_reset_max_dsecs = fw_health->post_reset_max_wait_dsecs;
+ 	bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ }
+ 
+ void bnxt_fw_exception(struct bnxt *bp)
+ {
+ 	set_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
+ 	bnxt_rtnl_lock_sp(bp);
+ 	bnxt_force_fw_reset(bp);
+ 	bnxt_rtnl_unlock_sp(bp);
+ }
+ 
+ /* Returns the number of registered VFs, or 1 if VF configuration is pending, or
+  * < 0 on error.
+  */
+ static int bnxt_get_registered_vfs(struct bnxt *bp)
+ {
+ #ifdef CONFIG_BNXT_SRIOV
+ 	int rc;
+ 
+ 	if (!BNXT_PF(bp))
+ 		return 0;
+ 
+ 	rc = bnxt_hwrm_func_qcfg(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "func_qcfg cmd failed, rc = %d\n", rc);
+ 		return rc;
+ 	}
+ 	if (bp->pf.registered_vfs)
+ 		return bp->pf.registered_vfs;
+ 	if (bp->sriov_cfg)
+ 		return 1;
+ #endif
+ 	return 0;
+ }
+ 
+ void bnxt_fw_reset(struct bnxt *bp)
+ {
+ 	bnxt_rtnl_lock_sp(bp);
+ 	if (test_bit(BNXT_STATE_OPEN, &bp->state) &&
+ 	    !test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {
+ 		int n = 0, tmo;
+ 
+ 		set_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 		if (bp->pf.active_vfs &&
+ 		    !test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))
+ 			n = bnxt_get_registered_vfs(bp);
+ 		if (n < 0) {
+ 			netdev_err(bp->dev, "Firmware reset aborted, rc = %d\n",
+ 				   n);
+ 			clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 			dev_close(bp->dev);
+ 			goto fw_reset_exit;
+ 		} else if (n > 0) {
+ 			u16 vf_tmo_dsecs = n * 10;
+ 
+ 			if (bp->fw_reset_max_dsecs < vf_tmo_dsecs)
+ 				bp->fw_reset_max_dsecs = vf_tmo_dsecs;
+ 			bp->fw_reset_state =
+ 				BNXT_FW_RESET_STATE_POLL_VF;
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			goto fw_reset_exit;
+ 		}
+ 		bnxt_fw_reset_close(bp);
+ 		if (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;
+ 			tmo = HZ / 10;
+ 		} else {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			tmo = bp->fw_reset_min_dsecs * HZ / 10;
+ 		}
+ 		bnxt_queue_fw_reset_work(bp, tmo);
+ 	}
+ fw_reset_exit:
+ 	bnxt_rtnl_unlock_sp(bp);
+ }
+ 
++>>>>>>> 4037eb715680 (bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.)
  static void bnxt_chk_missed_irq(struct bnxt *bp)
  {
  	int i;
@@@ -9762,6 -10411,336 +9908,339 @@@ static void bnxt_init_dflt_coal(struct 
  	bp->stats_coal_ticks = BNXT_DEF_STATS_COAL_TICKS;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_fw_init_one_p1(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	bp->fw_cap = 0;
+ 	rc = bnxt_hwrm_ver_get(bp);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (bp->fw_cap & BNXT_FW_CAP_KONG_MB_CHNL) {
+ 		rc = bnxt_alloc_kong_hwrm_resources(bp);
+ 		if (rc)
+ 			bp->fw_cap &= ~BNXT_FW_CAP_KONG_MB_CHNL;
+ 	}
+ 
+ 	if ((bp->fw_cap & BNXT_FW_CAP_SHORT_CMD) ||
+ 	    bp->hwrm_max_ext_req_len > BNXT_HWRM_MAX_REQ_LEN) {
+ 		rc = bnxt_alloc_hwrm_short_cmd_req(bp);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 	rc = bnxt_hwrm_func_reset(bp);
+ 	if (rc)
+ 		return -ENODEV;
+ 
+ 	bnxt_hwrm_fw_set_time(bp);
+ 	return 0;
+ }
+ 
+ static int bnxt_fw_init_one_p2(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	/* Get the MAX capabilities for this function */
+ 	rc = bnxt_hwrm_func_qcaps(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "hwrm query capability failure rc: %x\n",
+ 			   rc);
+ 		return -ENODEV;
+ 	}
+ 
+ 	rc = bnxt_hwrm_cfa_adv_flow_mgnt_qcaps(bp);
+ 	if (rc)
+ 		netdev_warn(bp->dev, "hwrm query adv flow mgnt failure rc: %d\n",
+ 			    rc);
+ 
+ 	rc = bnxt_hwrm_error_recovery_qcfg(bp);
+ 	if (rc)
+ 		netdev_warn(bp->dev, "hwrm query error recovery failure rc: %d\n",
+ 			    rc);
+ 
+ 	rc = bnxt_hwrm_func_drv_rgtr(bp);
+ 	if (rc)
+ 		return -ENODEV;
+ 
+ 	rc = bnxt_hwrm_func_rgtr_async_events(bp, NULL, 0);
+ 	if (rc)
+ 		return -ENODEV;
+ 
+ 	bnxt_hwrm_func_qcfg(bp);
+ 	bnxt_hwrm_vnic_qcaps(bp);
+ 	bnxt_hwrm_port_led_qcaps(bp);
+ 	bnxt_ethtool_init(bp);
+ 	bnxt_dcb_init(bp);
+ 	return 0;
+ }
+ 
+ static void bnxt_set_dflt_rss_hash_type(struct bnxt *bp)
+ {
+ 	bp->flags &= ~BNXT_FLAG_UDP_RSS_CAP;
+ 	bp->rss_hash_cfg = VNIC_RSS_CFG_REQ_HASH_TYPE_IPV4 |
+ 			   VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV4 |
+ 			   VNIC_RSS_CFG_REQ_HASH_TYPE_IPV6 |
+ 			   VNIC_RSS_CFG_REQ_HASH_TYPE_TCP_IPV6;
+ 	if (BNXT_CHIP_P4(bp) && bp->hwrm_spec_code >= 0x10501) {
+ 		bp->flags |= BNXT_FLAG_UDP_RSS_CAP;
+ 		bp->rss_hash_cfg |= VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV4 |
+ 				    VNIC_RSS_CFG_REQ_HASH_TYPE_UDP_IPV6;
+ 	}
+ }
+ 
+ static void bnxt_set_dflt_rfs(struct bnxt *bp)
+ {
+ 	struct net_device *dev = bp->dev;
+ 
+ 	dev->hw_features &= ~NETIF_F_NTUPLE;
+ 	dev->features &= ~NETIF_F_NTUPLE;
+ 	bp->flags &= ~BNXT_FLAG_RFS;
+ 	if (bnxt_rfs_supported(bp)) {
+ 		dev->hw_features |= NETIF_F_NTUPLE;
+ 		if (bnxt_rfs_capable(bp)) {
+ 			bp->flags |= BNXT_FLAG_RFS;
+ 			dev->features |= NETIF_F_NTUPLE;
+ 		}
+ 	}
+ }
+ 
+ static void bnxt_fw_init_one_p3(struct bnxt *bp)
+ {
+ 	struct pci_dev *pdev = bp->pdev;
+ 
+ 	bnxt_set_dflt_rss_hash_type(bp);
+ 	bnxt_set_dflt_rfs(bp);
+ 
+ 	bnxt_get_wol_settings(bp);
+ 	if (bp->flags & BNXT_FLAG_WOL_CAP)
+ 		device_set_wakeup_enable(&pdev->dev, bp->wol);
+ 	else
+ 		device_set_wakeup_capable(&pdev->dev, false);
+ 
+ 	bnxt_hwrm_set_cache_line_size(bp, cache_line_size());
+ 	bnxt_hwrm_coal_params_qcaps(bp);
+ }
+ 
+ static int bnxt_fw_init_one(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	rc = bnxt_fw_init_one_p1(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "Firmware init phase 1 failed\n");
+ 		return rc;
+ 	}
+ 	rc = bnxt_fw_init_one_p2(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "Firmware init phase 2 failed\n");
+ 		return rc;
+ 	}
+ 	rc = bnxt_approve_mac(bp, bp->dev->dev_addr, false);
+ 	if (rc)
+ 		return rc;
+ 	bnxt_fw_init_one_p3(bp);
+ 	return 0;
+ }
+ 
+ static void bnxt_fw_reset_writel(struct bnxt *bp, int reg_idx)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 reg = fw_health->fw_reset_seq_regs[reg_idx];
+ 	u32 val = fw_health->fw_reset_seq_vals[reg_idx];
+ 	u32 reg_type, reg_off, delay_msecs;
+ 
+ 	delay_msecs = fw_health->fw_reset_seq_delay_msec[reg_idx];
+ 	reg_type = BNXT_FW_HEALTH_REG_TYPE(reg);
+ 	reg_off = BNXT_FW_HEALTH_REG_OFF(reg);
+ 	switch (reg_type) {
+ 	case BNXT_FW_HEALTH_REG_TYPE_CFG:
+ 		pci_write_config_dword(bp->pdev, reg_off, val);
+ 		break;
+ 	case BNXT_FW_HEALTH_REG_TYPE_GRC:
+ 		writel(reg_off & BNXT_GRC_BASE_MASK,
+ 		       bp->bar0 + BNXT_GRCPF_REG_WINDOW_BASE_OUT + 4);
+ 		reg_off = (reg_off & BNXT_GRC_OFFSET_MASK) + 0x2000;
+ 		/* fall through */
+ 	case BNXT_FW_HEALTH_REG_TYPE_BAR0:
+ 		writel(val, bp->bar0 + reg_off);
+ 		break;
+ 	case BNXT_FW_HEALTH_REG_TYPE_BAR1:
+ 		writel(val, bp->bar1 + reg_off);
+ 		break;
+ 	}
+ 	if (delay_msecs) {
+ 		pci_read_config_dword(bp->pdev, 0, &val);
+ 		msleep(delay_msecs);
+ 	}
+ }
+ 
+ static void bnxt_reset_all(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	int i;
+ 
+ 	if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_HOST) {
+ 		for (i = 0; i < fw_health->fw_reset_seq_cnt; i++)
+ 			bnxt_fw_reset_writel(bp, i);
+ 	} else if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU) {
+ 		struct hwrm_fw_reset_input req = {0};
+ 		int rc;
+ 
+ 		bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FW_RESET, -1, -1);
+ 		req.resp_addr = cpu_to_le64(bp->hwrm_cmd_kong_resp_dma_addr);
+ 		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP;
+ 		req.selfrst_status = FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP;
+ 		req.flags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;
+ 		rc = hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 		if (rc)
+ 			netdev_warn(bp->dev, "Unable to reset FW rc=%d\n", rc);
+ 	}
+ 	bp->fw_reset_timestamp = jiffies;
+ }
+ 
+ static void bnxt_fw_reset_task(struct work_struct *work)
+ {
+ 	struct bnxt *bp = container_of(work, struct bnxt, fw_reset_task.work);
+ 	int rc;
+ 
+ 	if (!test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {
+ 		netdev_err(bp->dev, "bnxt_fw_reset_task() called when not in fw reset mode!\n");
+ 		return;
+ 	}
+ 
+ 	switch (bp->fw_reset_state) {
+ 	case BNXT_FW_RESET_STATE_POLL_VF: {
+ 		int n = bnxt_get_registered_vfs(bp);
+ 		int tmo;
+ 
+ 		if (n < 0) {
+ 			netdev_err(bp->dev, "Firmware reset aborted, subsequent func_qcfg cmd failed, rc = %d, %d msecs since reset timestamp\n",
+ 				   n, jiffies_to_msecs(jiffies -
+ 				   bp->fw_reset_timestamp));
+ 			goto fw_reset_abort;
+ 		} else if (n > 0) {
+ 			if (time_after(jiffies, bp->fw_reset_timestamp +
+ 				       (bp->fw_reset_max_dsecs * HZ / 10))) {
+ 				clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 				bp->fw_reset_state = 0;
+ 				netdev_err(bp->dev, "Firmware reset aborted, bnxt_get_registered_vfs() returns %d\n",
+ 					   n);
+ 				return;
+ 			}
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			return;
+ 		}
+ 		bp->fw_reset_timestamp = jiffies;
+ 		rtnl_lock();
+ 		bnxt_fw_reset_close(bp);
+ 		if (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;
+ 			tmo = HZ / 10;
+ 		} else {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			tmo = bp->fw_reset_min_dsecs * HZ / 10;
+ 		}
+ 		rtnl_unlock();
+ 		bnxt_queue_fw_reset_work(bp, tmo);
+ 		return;
+ 	}
+ 	case BNXT_FW_RESET_STATE_POLL_FW_DOWN: {
+ 		u32 val;
+ 
+ 		val = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
+ 		if (!(val & BNXT_FW_STATUS_SHUTDOWN) &&
+ 		    !time_after(jiffies, bp->fw_reset_timestamp +
+ 		    (bp->fw_reset_max_dsecs * HZ / 10))) {
+ 			bnxt_queue_fw_reset_work(bp, HZ / 5);
+ 			return;
+ 		}
+ 
+ 		if (!bp->fw_health->master) {
+ 			u32 wait_dsecs = bp->fw_health->normal_func_wait_dsecs;
+ 
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ 			return;
+ 		}
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;
+ 	}
+ 	/* fall through */
+ 	case BNXT_FW_RESET_STATE_RESET_FW: {
+ 		u32 wait_dsecs = bp->fw_health->post_reset_wait_dsecs;
+ 
+ 		bnxt_reset_all(bp);
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 		bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ 		return;
+ 	}
+ 	case BNXT_FW_RESET_STATE_ENABLE_DEV:
+ 		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) &&
+ 		    bp->fw_health) {
+ 			u32 val;
+ 
+ 			val = bnxt_fw_health_readl(bp,
+ 						   BNXT_FW_RESET_INPROG_REG);
+ 			if (val)
+ 				netdev_warn(bp->dev, "FW reset inprog %x after min wait time.\n",
+ 					    val);
+ 		}
+ 		clear_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
+ 		if (pci_enable_device(bp->pdev)) {
+ 			netdev_err(bp->dev, "Cannot re-enable PCI device\n");
+ 			goto fw_reset_abort;
+ 		}
+ 		pci_set_master(bp->pdev);
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW;
+ 		/* fall through */
+ 	case BNXT_FW_RESET_STATE_POLL_FW:
+ 		bp->hwrm_cmd_timeout = SHORT_HWRM_CMD_TIMEOUT;
+ 		rc = __bnxt_hwrm_ver_get(bp, true);
+ 		if (rc) {
+ 			if (time_after(jiffies, bp->fw_reset_timestamp +
+ 				       (bp->fw_reset_max_dsecs * HZ / 10))) {
+ 				netdev_err(bp->dev, "Firmware reset aborted\n");
+ 				goto fw_reset_abort;
+ 			}
+ 			bnxt_queue_fw_reset_work(bp, HZ / 5);
+ 			return;
+ 		}
+ 		bp->hwrm_cmd_timeout = DFLT_HWRM_CMD_TIMEOUT;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_OPENING;
+ 		/* fall through */
+ 	case BNXT_FW_RESET_STATE_OPENING:
+ 		while (!rtnl_trylock()) {
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			return;
+ 		}
+ 		rc = bnxt_open(bp->dev);
+ 		if (rc) {
+ 			netdev_err(bp->dev, "bnxt_open_nic() failed\n");
+ 			clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 			dev_close(bp->dev);
+ 		}
+ 		bnxt_ulp_irq_restart(bp, rc);
+ 		rtnl_unlock();
+ 
+ 		bp->fw_reset_state = 0;
+ 		/* Make sure fw_reset_state is 0 before clearing the flag */
+ 		smp_mb__before_atomic();
+ 		clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 		break;
+ 	}
+ 	return;
+ 
+ fw_reset_abort:
+ 	clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 	bp->fw_reset_state = 0;
+ 	rtnl_lock();
+ 	dev_close(bp->dev);
+ 	rtnl_unlock();
+ }
+ 
++>>>>>>> 4037eb715680 (bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.)
  static int bnxt_init_board(struct pci_dev *pdev, struct net_device *dev)
  {
  	int rc;
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index eba02543e96c,d333589811a5..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1326,6 -1352,54 +1326,57 @@@ struct bnxt_ctx_mem_info 
  	struct bnxt_ctx_pg_info *tqm_mem[9];
  };
  
++<<<<<<< HEAD
++=======
+ struct bnxt_fw_health {
+ 	u32 flags;
+ 	u32 polling_dsecs;
+ 	u32 master_func_wait_dsecs;
+ 	u32 normal_func_wait_dsecs;
+ 	u32 post_reset_wait_dsecs;
+ 	u32 post_reset_max_wait_dsecs;
+ 	u32 regs[4];
+ 	u32 mapped_regs[4];
+ #define BNXT_FW_HEALTH_REG		0
+ #define BNXT_FW_HEARTBEAT_REG		1
+ #define BNXT_FW_RESET_CNT_REG		2
+ #define BNXT_FW_RESET_INPROG_REG	3
+ 	u32 fw_reset_inprog_reg_mask;
+ 	u32 last_fw_heartbeat;
+ 	u32 last_fw_reset_cnt;
+ 	u8 enabled:1;
+ 	u8 master:1;
+ 	u8 tmr_multiplier;
+ 	u8 tmr_counter;
+ 	u8 fw_reset_seq_cnt;
+ 	u32 fw_reset_seq_regs[16];
+ 	u32 fw_reset_seq_vals[16];
+ 	u32 fw_reset_seq_delay_msec[16];
+ 	struct devlink_health_reporter	*fw_reporter;
+ 	struct devlink_health_reporter *fw_reset_reporter;
+ 	struct devlink_health_reporter *fw_fatal_reporter;
+ };
+ 
+ struct bnxt_fw_reporter_ctx {
+ 	unsigned long sp_event;
+ };
+ 
+ #define BNXT_FW_HEALTH_REG_TYPE_MASK	3
+ #define BNXT_FW_HEALTH_REG_TYPE_CFG	0
+ #define BNXT_FW_HEALTH_REG_TYPE_GRC	1
+ #define BNXT_FW_HEALTH_REG_TYPE_BAR0	2
+ #define BNXT_FW_HEALTH_REG_TYPE_BAR1	3
+ 
+ #define BNXT_FW_HEALTH_REG_TYPE(reg)	((reg) & BNXT_FW_HEALTH_REG_TYPE_MASK)
+ #define BNXT_FW_HEALTH_REG_OFF(reg)	((reg) & ~BNXT_FW_HEALTH_REG_TYPE_MASK)
+ 
+ #define BNXT_FW_HEALTH_WIN_BASE		0x3000
+ #define BNXT_FW_HEALTH_WIN_MAP_OFF	8
+ 
+ #define BNXT_FW_STATUS_HEALTHY		0x8000
+ #define BNXT_FW_STATUS_SHUTDOWN		0x100000
+ 
++>>>>>>> 4037eb715680 (bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.)
  struct bnxt {
  	void __iomem		*bar0;
  	void __iomem		*bar1;
@@@ -1569,6 -1650,13 +1620,16 @@@
  	#define BNXT_FW_CAP_KONG_MB_CHNL		0x00000080
  	#define BNXT_FW_CAP_OVS_64BIT_HANDLE		0x00000400
  	#define BNXT_FW_CAP_TRUSTED_VF			0x00000800
++<<<<<<< HEAD
++=======
+ 	#define BNXT_FW_CAP_ERROR_RECOVERY		0x00002000
+ 	#define BNXT_FW_CAP_PKG_VER			0x00004000
+ 	#define BNXT_FW_CAP_CFA_ADV_FLOW		0x00008000
+ 	#define BNXT_FW_CAP_CFA_RFS_RING_TBL_IDX	0x00010000
+ 	#define BNXT_FW_CAP_PCIE_STATS_SUPPORTED	0x00020000
+ 	#define BNXT_FW_CAP_EXT_STATS_SUPPORTED		0x00040000
+ 	#define BNXT_FW_CAP_ERR_RECOVER_RELOAD		0x00100000
++>>>>>>> 4037eb715680 (bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.)
  
  #define BNXT_NEW_RM(bp)		((bp)->fw_cap & BNXT_FW_CAP_NEW_RM)
  	u32			hwrm_spec_code;
@@@ -1646,6 -1737,16 +1707,19 @@@
  #define BNXT_UPDATE_PHY_SP_EVENT	16
  #define BNXT_RING_COAL_NOW_SP_EVENT	17
  #define BNXT_FW_RESET_NOTIFY_SP_EVENT	18
++<<<<<<< HEAD
++=======
+ #define BNXT_FW_EXCEPTION_SP_EVENT	19
+ 
+ 	struct delayed_work	fw_reset_task;
+ 	int			fw_reset_state;
+ #define BNXT_FW_RESET_STATE_POLL_VF	1
+ #define BNXT_FW_RESET_STATE_RESET_FW	2
+ #define BNXT_FW_RESET_STATE_ENABLE_DEV	3
+ #define BNXT_FW_RESET_STATE_POLL_FW	4
+ #define BNXT_FW_RESET_STATE_OPENING	5
+ #define BNXT_FW_RESET_STATE_POLL_FW_DOWN	6
++>>>>>>> 4037eb715680 (bnxt_en: Add a new BNXT_FW_RESET_STATE_POLL_FW_DOWN state.)
  
  	u16			fw_reset_min_dsecs;
  #define BNXT_DFLT_FW_RST_MIN_DSECS	20
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
