arm64: add basic pointer authentication support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [arm64] add basic pointer authentication support (Mark Salter) [1756103]
Rebuild_FUZZ: 91.95%
commit-author Mark Rutland <mark.rutland@arm.com>
commit 7503197562567b57ec14feb3a9d5400ebc56812f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/75031975.failed

This patch adds basic support for pointer authentication, allowing
userspace to make use of APIAKey, APIBKey, APDAKey, APDBKey, and
APGAKey. The kernel maintains key values for each process (shared by all
threads within), which are initialised to random values at exec() time.

The ID_AA64ISAR1_EL1.{APA,API,GPA,GPI} fields are exposed to userspace,
to describe that pointer authentication instructions are available and
that the kernel is managing the keys. Two new hwcaps are added for the
same reason: PACA (for address authentication) and PACG (for generic
authentication).

	Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Kristina Martsenko <kristina.martsenko@arm.com>
	Tested-by: Adam Wallis <awallis@codeaurora.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>
	Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
[will: Fix sizeof() usage and unroll address key initialisation]
	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit 7503197562567b57ec14feb3a9d5400ebc56812f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpufeature.c
diff --cc arch/arm64/kernel/cpufeature.c
index ea14666781d7,f15000872e08..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -1162,6 -1168,64 +1162,67 @@@ static void cpu_enable_ssbs(const struc
  }
  #endif /* CONFIG_ARM64_SSBD */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_PAN
+ static void cpu_enable_pan(const struct arm64_cpu_capabilities *__unused)
+ {
+ 	/*
+ 	 * We modify PSTATE. This won't work from irq context as the PSTATE
+ 	 * is discarded once we return from the exception.
+ 	 */
+ 	WARN_ON_ONCE(in_interrupt());
+ 
+ 	sysreg_clear_set(sctlr_el1, SCTLR_EL1_SPAN, 0);
+ 	asm(SET_PSTATE_PAN(1));
+ }
+ #endif /* CONFIG_ARM64_PAN */
+ 
+ #ifdef CONFIG_ARM64_RAS_EXTN
+ static void cpu_clear_disr(const struct arm64_cpu_capabilities *__unused)
+ {
+ 	/* Firmware may have left a deferred SError in this register. */
+ 	write_sysreg_s(0, SYS_DISR_EL1);
+ }
+ #endif /* CONFIG_ARM64_RAS_EXTN */
+ 
+ #ifdef CONFIG_ARM64_PTR_AUTH
+ static void cpu_enable_address_auth(struct arm64_cpu_capabilities const *cap)
+ {
+ 	sysreg_clear_set(sctlr_el1, 0, SCTLR_ELx_ENIA | SCTLR_ELx_ENIB |
+ 				       SCTLR_ELx_ENDA | SCTLR_ELx_ENDB);
+ }
+ 
+ static bool has_address_auth(const struct arm64_cpu_capabilities *entry,
+ 			     int __unused)
+ {
+ 	u64 isar1 = read_sanitised_ftr_reg(SYS_ID_AA64ISAR1_EL1);
+ 	bool api, apa;
+ 
+ 	apa = cpuid_feature_extract_unsigned_field(isar1,
+ 					ID_AA64ISAR1_APA_SHIFT) > 0;
+ 	api = cpuid_feature_extract_unsigned_field(isar1,
+ 					ID_AA64ISAR1_API_SHIFT) > 0;
+ 
+ 	return apa || api;
+ }
+ 
+ static bool has_generic_auth(const struct arm64_cpu_capabilities *entry,
+ 			     int __unused)
+ {
+ 	u64 isar1 = read_sanitised_ftr_reg(SYS_ID_AA64ISAR1_EL1);
+ 	bool gpi, gpa;
+ 
+ 	gpa = cpuid_feature_extract_unsigned_field(isar1,
+ 					ID_AA64ISAR1_GPA_SHIFT) > 0;
+ 	gpi = cpuid_feature_extract_unsigned_field(isar1,
+ 					ID_AA64ISAR1_GPI_SHIFT) > 0;
+ 
+ 	return gpa || gpi;
+ }
+ #endif /* CONFIG_ARM64_PTR_AUTH */
+ 
++>>>>>>> 750319756256 (arm64: add basic pointer authentication support)
  static const struct arm64_cpu_capabilities arm64_features[] = {
  	{
  		.desc = "GIC system register CPU interface",
@@@ -1371,19 -1449,69 +1432,75 @@@
  		.cpu_enable = cpu_enable_cnp,
  	},
  #endif
 +#ifdef CONFIG_ARM64_SSBD
  	{
 -		.desc = "Speculation barrier (SB)",
 -		.capability = ARM64_HAS_SB,
 -		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
 +		.desc = "Speculative Store Bypassing Safe (SSBS)",
 +		.capability = ARM64_SSBS,
 +		.type = ARM64_CPUCAP_WEAK_LOCAL_CPU_FEATURE,
  		.matches = has_cpuid_feature,
 -		.sys_reg = SYS_ID_AA64ISAR1_EL1,
 -		.field_pos = ID_AA64ISAR1_SB_SHIFT,
 +		.sys_reg = SYS_ID_AA64PFR1_EL1,
 +		.field_pos = ID_AA64PFR1_SSBS_SHIFT,
  		.sign = FTR_UNSIGNED,
 -		.min_field_value = 1,
 +		.min_field_value = ID_AA64PFR1_SSBS_PSTATE_ONLY,
 +		.cpu_enable = cpu_enable_ssbs,
  	},
++<<<<<<< HEAD
 +#endif
++=======
+ #ifdef CONFIG_ARM64_PTR_AUTH
+ 	{
+ 		.desc = "Address authentication (architected algorithm)",
+ 		.capability = ARM64_HAS_ADDRESS_AUTH_ARCH,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.sys_reg = SYS_ID_AA64ISAR1_EL1,
+ 		.sign = FTR_UNSIGNED,
+ 		.field_pos = ID_AA64ISAR1_APA_SHIFT,
+ 		.min_field_value = ID_AA64ISAR1_APA_ARCHITECTED,
+ 		.matches = has_cpuid_feature,
+ 	},
+ 	{
+ 		.desc = "Address authentication (IMP DEF algorithm)",
+ 		.capability = ARM64_HAS_ADDRESS_AUTH_IMP_DEF,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.sys_reg = SYS_ID_AA64ISAR1_EL1,
+ 		.sign = FTR_UNSIGNED,
+ 		.field_pos = ID_AA64ISAR1_API_SHIFT,
+ 		.min_field_value = ID_AA64ISAR1_API_IMP_DEF,
+ 		.matches = has_cpuid_feature,
+ 	},
+ 	{
+ 		.capability = ARM64_HAS_ADDRESS_AUTH,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.matches = has_address_auth,
+ 		.cpu_enable = cpu_enable_address_auth,
+ 	},
+ 	{
+ 		.desc = "Generic authentication (architected algorithm)",
+ 		.capability = ARM64_HAS_GENERIC_AUTH_ARCH,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.sys_reg = SYS_ID_AA64ISAR1_EL1,
+ 		.sign = FTR_UNSIGNED,
+ 		.field_pos = ID_AA64ISAR1_GPA_SHIFT,
+ 		.min_field_value = ID_AA64ISAR1_GPA_ARCHITECTED,
+ 		.matches = has_cpuid_feature,
+ 	},
+ 	{
+ 		.desc = "Generic authentication (IMP DEF algorithm)",
+ 		.capability = ARM64_HAS_GENERIC_AUTH_IMP_DEF,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.sys_reg = SYS_ID_AA64ISAR1_EL1,
+ 		.sign = FTR_UNSIGNED,
+ 		.field_pos = ID_AA64ISAR1_GPI_SHIFT,
+ 		.min_field_value = ID_AA64ISAR1_GPI_IMP_DEF,
+ 		.matches = has_cpuid_feature,
+ 	},
+ 	{
+ 		.capability = ARM64_HAS_GENERIC_AUTH,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.matches = has_generic_auth,
+ 	},
+ #endif /* CONFIG_ARM64_PTR_AUTH */
++>>>>>>> 750319756256 (arm64: add basic pointer authentication support)
  	{},
  };
  
diff --git a/arch/arm64/include/asm/pointer_auth.h b/arch/arm64/include/asm/pointer_auth.h
new file mode 100644
index 000000000000..91c4185dda5b
--- /dev/null
+++ b/arch/arm64/include/asm/pointer_auth.h
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef __ASM_POINTER_AUTH_H
+#define __ASM_POINTER_AUTH_H
+
+#include <linux/random.h>
+
+#include <asm/cpufeature.h>
+#include <asm/sysreg.h>
+
+#ifdef CONFIG_ARM64_PTR_AUTH
+/*
+ * Each key is a 128-bit quantity which is split across a pair of 64-bit
+ * registers (Lo and Hi).
+ */
+struct ptrauth_key {
+	unsigned long lo, hi;
+};
+
+/*
+ * We give each process its own keys, which are shared by all threads. The keys
+ * are inherited upon fork(), and reinitialised upon exec*().
+ */
+struct ptrauth_keys {
+	struct ptrauth_key apia;
+	struct ptrauth_key apib;
+	struct ptrauth_key apda;
+	struct ptrauth_key apdb;
+	struct ptrauth_key apga;
+};
+
+static inline void ptrauth_keys_init(struct ptrauth_keys *keys)
+{
+	if (system_supports_address_auth()) {
+		get_random_bytes(&keys->apia, sizeof(keys->apia));
+		get_random_bytes(&keys->apib, sizeof(keys->apib));
+		get_random_bytes(&keys->apda, sizeof(keys->apda));
+		get_random_bytes(&keys->apdb, sizeof(keys->apdb));
+	}
+
+	if (system_supports_generic_auth())
+		get_random_bytes(&keys->apga, sizeof(keys->apga));
+}
+
+#define __ptrauth_key_install(k, v)				\
+do {								\
+	struct ptrauth_key __pki_v = (v);			\
+	write_sysreg_s(__pki_v.lo, SYS_ ## k ## KEYLO_EL1);	\
+	write_sysreg_s(__pki_v.hi, SYS_ ## k ## KEYHI_EL1);	\
+} while (0)
+
+static inline void ptrauth_keys_switch(struct ptrauth_keys *keys)
+{
+	if (system_supports_address_auth()) {
+		__ptrauth_key_install(APIA, keys->apia);
+		__ptrauth_key_install(APIB, keys->apib);
+		__ptrauth_key_install(APDA, keys->apda);
+		__ptrauth_key_install(APDB, keys->apdb);
+	}
+
+	if (system_supports_generic_auth())
+		__ptrauth_key_install(APGA, keys->apga);
+}
+
+#define ptrauth_thread_init_user(tsk)					\
+do {									\
+	struct task_struct *__ptiu_tsk = (tsk);				\
+	ptrauth_keys_init(&__ptiu_tsk->thread_info.keys_user);		\
+	ptrauth_keys_switch(&__ptiu_tsk->thread_info.keys_user);	\
+} while (0)
+
+#define ptrauth_thread_switch(tsk)	\
+	ptrauth_keys_switch(&(tsk)->thread_info.keys_user)
+
+#else /* CONFIG_ARM64_PTR_AUTH */
+#define ptrauth_thread_init_user(tsk)
+#define ptrauth_thread_switch(tsk)
+#endif /* CONFIG_ARM64_PTR_AUTH */
+
+#endif /* __ASM_POINTER_AUTH_H */
diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
index bbca68b54732..f8f66ad9dd8f 100644
--- a/arch/arm64/include/asm/thread_info.h
+++ b/arch/arm64/include/asm/thread_info.h
@@ -28,6 +28,7 @@
 struct task_struct;
 
 #include <asm/memory.h>
+#include <asm/pointer_auth.h>
 #include <asm/stack_pointer.h>
 #include <asm/types.h>
 
@@ -54,6 +55,9 @@ struct thread_info {
 #endif
 		} preempt;
 	};
+#ifdef CONFIG_ARM64_PTR_AUTH
+	struct ptrauth_keys	keys_user;
+#endif
 };
 
 #define thread_saved_pc(tsk)	\
diff --git a/arch/arm64/include/uapi/asm/hwcap.h b/arch/arm64/include/uapi/asm/hwcap.h
index 7784f7cba16c..5f0750c2199c 100644
--- a/arch/arm64/include/uapi/asm/hwcap.h
+++ b/arch/arm64/include/uapi/asm/hwcap.h
@@ -50,5 +50,7 @@
 #define HWCAP_FLAGM		(1 << 27)
 #define HWCAP_SSBS		(1 << 28)
 #define HWCAP_SB		(1 << 29)
+#define HWCAP_PACA		(1 << 30)
+#define HWCAP_PACG		(1UL << 31)
 
 #endif /* _UAPI__ASM_HWCAP_H */
* Unmerged path arch/arm64/kernel/cpufeature.c
diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c
index 7cb0b08ab0a7..ca0685f33900 100644
--- a/arch/arm64/kernel/cpuinfo.c
+++ b/arch/arm64/kernel/cpuinfo.c
@@ -83,6 +83,8 @@ static const char *const hwcap_str[] = {
 	"flagm",
 	"ssbs",
 	"sb",
+	"paca",
+	"pacg",
 	NULL
 };
 
diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index 084acadd51f8..213bc972f4c4 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -57,6 +57,7 @@
 #include <asm/fpsimd.h>
 #include <asm/mmu_context.h>
 #include <asm/processor.h>
+#include <asm/pointer_auth.h>
 #include <asm/stacktrace.h>
 
 #ifdef CONFIG_STACKPROTECTOR
@@ -427,6 +428,7 @@ __notrace_funcgraph struct task_struct *__switch_to(struct task_struct *prev,
 	contextidr_thread_switch(next);
 	entry_task_switch(next);
 	uao_thread_switch(next);
+	ptrauth_thread_switch(next);
 
 	/*
 	 * Complete any pending TLB or cache maintenance on this CPU in case
@@ -494,4 +496,6 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 void arch_setup_new_exec(void)
 {
 	current->mm->context.flags = is_compat_task() ? MMCF_AARCH32 : 0;
+
+	ptrauth_thread_init_user(current);
 }
