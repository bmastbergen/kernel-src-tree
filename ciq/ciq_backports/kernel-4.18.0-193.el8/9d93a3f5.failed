io_uring: punt short reads to async context

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 9d93a3f5a0c0d0f79aebc597d47c7cedc852aeb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9d93a3f5.failed

We can encounter a short read when we're doing buffered reads and the
data is partially cached. Right now we just return the short read, but
that forces the application to read that CQE, then issue another SQE
to finish the read. That read will not be cached, and hence will result
in an async punt.

It's more efficient to do that async punt from within the kernel, as
that will the not need two round trips more to the kernel.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9d93a3f5a0c0d0f79aebc597d47c7cedc852aeb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 8da4e80415da,92debd8be535..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -1086,7 -1089,7 +1086,11 @@@ static int io_read(struct io_kiocb *req
  	struct iov_iter iter;
  	struct file *file;
  	size_t iov_count;
++<<<<<<< HEAD
 +	int ret;
++=======
+ 	ssize_t read_size, ret;
++>>>>>>> 9d93a3f5a0c0 (io_uring: punt short reads to async context)
  
  	ret = io_prep_rw(req, s, force_nonblock);
  	if (ret)
@@@ -1099,9 -1102,10 +1103,10 @@@
  		return -EINVAL;
  
  	ret = io_import_iovec(req->ctx, READ, s, &iovec, &iter);
 -	if (ret < 0)
 +	if (ret)
  		return ret;
  
+ 	read_size = ret;
  	iov_count = iov_iter_count(&iter);
  	ret = rw_verify_area(READ, file, &kiocb->ki_pos, iov_count);
  	if (!ret) {
* Unmerged path fs/io_uring.c
