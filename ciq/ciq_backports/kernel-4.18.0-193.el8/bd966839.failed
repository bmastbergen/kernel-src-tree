s390/qeth: handle error when updating TX queue count

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit bd966839bdf9165ee0aefa57132e87e9caf55982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/bd966839.failed

netif_set_real_num_tx_queues() can return an error, deal with it.

Fixes: 73dc2daf110f ("s390/qeth: add TX multiqueue support for OSA devices")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd966839bdf9165ee0aefa57132e87e9caf55982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index 6ca4665a0044,b1823d75dd35..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -1282,27 -1274,30 +1282,52 @@@ static int qeth_setup_channel(struct qe
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void qeth_set_single_write_queues(struct qeth_card *card)
 +{
 +	if ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&
 +	    (card->qdio.no_out_queues == 4))
++=======
+ static int qeth_osa_set_output_queues(struct qeth_card *card, bool single)
+ {
+ 	unsigned int count = single ? 1 : card->dev->num_tx_queues;
+ 	int rc;
+ 
+ 	rtnl_lock();
+ 	rc = netif_set_real_num_tx_queues(card->dev, count);
+ 	rtnl_unlock();
+ 
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (card->qdio.no_out_queues == count)
+ 		return 0;
+ 
+ 	if (atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED)
++>>>>>>> bd966839bdf9 (s390/qeth: handle error when updating TX queue count)
  		qeth_free_qdio_queues(card);
  
 -	if (count == 1)
 +	card->qdio.no_out_queues = 1;
 +	if (card->qdio.default_out_queue != 0)
  		dev_info(&card->gdev->dev, "Priority Queueing not supported\n");
  
++<<<<<<< HEAD
 +	card->qdio.default_out_queue = 0;
 +}
 +
 +static void qeth_set_multiple_write_queues(struct qeth_card *card)
 +{
 +	if ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&
 +	    (card->qdio.no_out_queues == 1)) {
 +		qeth_free_qdio_queues(card);
 +		card->qdio.default_out_queue = 2;
 +	}
 +	card->qdio.no_out_queues = 4;
++=======
+ 	card->qdio.default_out_queue = single ? 0 : QETH_DEFAULT_QUEUE;
+ 	card->qdio.no_out_queues = count;
+ 	return 0;
++>>>>>>> bd966839bdf9 (s390/qeth: handle error when updating TX queue count)
  }
  
  static int qeth_update_from_chp_desc(struct qeth_card *card)
@@@ -1318,15 -1314,11 +1344,22 @@@
  		return -ENOMEM;
  
  	card->info.func_level = 0x4100 + chp_dsc->desc;
 +	if (card->info.type == QETH_CARD_TYPE_IQD)
 +		goto out;
  
++<<<<<<< HEAD
 +	/* CHPP field bit 6 == 1 -> single queue */
 +	if ((chp_dsc->chpp & 0x02) == 0x02)
 +		qeth_set_single_write_queues(card);
 +	else
 +		qeth_set_multiple_write_queues(card);
 +out:
++=======
+ 	if (IS_OSD(card) || IS_OSX(card))
+ 		/* CHPP field bit 6 == 1 -> single queue */
+ 		rc = qeth_osa_set_output_queues(card, chp_dsc->chpp & 0x02);
+ 
++>>>>>>> bd966839bdf9 (s390/qeth: handle error when updating TX queue count)
  	kfree(chp_dsc);
  	QETH_DBF_TEXT_(SETUP, 2, "nr:%x", card->qdio.no_out_queues);
  	QETH_DBF_TEXT_(SETUP, 2, "lvl:%02x", card->info.func_level);
@@@ -5593,8 -5602,14 +5626,19 @@@ static struct net_device *qeth_alloc_ne
  		dev->priv_flags &= ~IFF_TX_SKB_SHARING;
  		dev->hw_features |= NETIF_F_SG;
  		dev->vlan_features |= NETIF_F_SG;
++<<<<<<< HEAD
 +		if (IS_IQD(card))
 +			dev->features |= NETIF_F_SG;
++=======
+ 		if (IS_IQD(card)) {
+ 			dev->features |= NETIF_F_SG;
+ 			if (netif_set_real_num_tx_queues(dev,
+ 							 QETH_IQD_MIN_TXQ)) {
+ 				free_netdev(dev);
+ 				return NULL;
+ 			}
+ 		}
++>>>>>>> bd966839bdf9 (s390/qeth: handle error when updating TX queue count)
  	}
  
  	return dev;
* Unmerged path drivers/s390/net/qeth_core_main.c
