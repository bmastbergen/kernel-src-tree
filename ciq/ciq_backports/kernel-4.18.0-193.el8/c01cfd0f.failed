net/mlx5: E-Switch, Add match on vport metadata for rule in fast path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Add match on vport metadata for rule in fast path (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 97.01%
commit-author Jianbo Liu <jianbol@mellanox.com>
commit c01cfd0f111511f005ac9c2608556a02b012a2dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c01cfd0f.failed

If FW's capabilities and configurations meet the requirement of vport
metadata matching, this feature will be used. As the information
about vport number and vhca_id related to packet is already stored to
its metadata register, which is used as an indicator for perticular
vport, now we can change to match on this metadata for all the
offloading rules in fast path.

	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit c01cfd0f111511f005ac9c2608556a02b012a2dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,a3cf787382ee..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -146,21 -205,8 +192,23 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  		i++;
  	}
  
- 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
- 	MLX5_SET(fte_match_set_misc, misc, source_port, attr->in_rep->vport);
+ 	mlx5_eswitch_set_rule_source_port(esw, spec, attr);
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
 +		MLX5_SET(fte_match_set_misc, misc,
 +			 source_eswitch_owner_vhca_id,
 +			 MLX5_CAP_GEN(attr->in_mdev, vhca_id));
 +
 +	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
 +	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
 +	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
 +		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
 +				 source_eswitch_owner_vhca_id);
 +
 +	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;
++=======
++>>>>>>> c01cfd0f1115 (net/mlx5: E-Switch, Add match on vport metadata for rule in fast path)
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP) {
  		if (attr->tunnel_match_level != MLX5_MATCH_NONE)
  			spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
@@@ -238,25 -283,10 +285,29 @@@ mlx5_eswitch_add_fwd_rule(struct mlx5_e
  	dest[i].ft = fwd_fdb,
  	i++;
  
- 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
- 	MLX5_SET(fte_match_set_misc, misc, source_port, attr->in_rep->vport);
+ 	mlx5_eswitch_set_rule_source_port(esw, spec, attr);
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
 +		MLX5_SET(fte_match_set_misc, misc,
 +			 source_eswitch_owner_vhca_id,
 +			 MLX5_CAP_GEN(attr->in_mdev, vhca_id));
 +
 +	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
 +	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
 +	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
 +		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
 +				 source_eswitch_owner_vhca_id);
 +
 +	if (attr->match_level == MLX5_MATCH_NONE)
 +		spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS;
 +	else
 +		spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS |
 +					       MLX5_MATCH_MISC_PARAMETERS;
++=======
+ 	if (attr->match_level != MLX5_MATCH_NONE)
+ 		spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
++>>>>>>> c01cfd0f1115 (net/mlx5: E-Switch, Add match on vport metadata for rule in fast path)
  
  	rule = mlx5_add_flow_rules(fast_fdb, spec, &flow_act, dest, i);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
