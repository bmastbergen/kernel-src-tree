net: openvswitch: Set OvS recirc_id from tc chain index

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] openvswitch: Set OvS recirc_id from tc chain index (Ivan Vecera) [1739606]
Rebuild_FUZZ: 95.24%
commit-author Paul Blakey <paulb@mellanox.com>
commit 95a7233c452a58a4c2310c456c73997853b2ec46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/95a7233c.failed

Offloaded OvS datapath rules are translated one to one to tc rules,
for example the following simplified OvS rule:

recirc_id(0),in_port(dev1),eth_type(0x0800),ct_state(-trk) actions:ct(),recirc(2)

Will be translated to the following tc rule:

$ tc filter add dev dev1 ingress \
	    prio 1 chain 0 proto ip \
		flower tcp ct_state -trk \
		action ct pipe \
		action goto chain 2

Received packets will first travel though tc, and if they aren't stolen
by it, like in the above rule, they will continue to OvS datapath.
Since we already did some actions (action ct in this case) which might
modify the packets, and updated action stats, we would like to continue
the proccessing with the correct recirc_id in OvS (here recirc_id(2))
where we left off.

To support this, introduce a new skb extension for tc, which
will be used for translating tc chain to ovs recirc_id to
handle these miss cases. Last tc chain index will be set
by tc goto chain action and read by OvS datapath.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 95a7233c452a58a4c2310c456c73997853b2ec46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/skbuff.c
#	net/sched/Kconfig
diff --cc include/linux/skbuff.h
index aec895840f07,028e684fa974..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3953,6 -4065,12 +3963,15 @@@ enum skb_ext_id 
  #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
  	SKB_EXT_BRIDGE_NF,
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_XFRM
+ 	SKB_EXT_SEC_PATH,
+ #endif
+ #if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+ 	TC_SKB_EXT,
+ #endif
++>>>>>>> 95a7233c452a (net: openvswitch: Set OvS recirc_id from tc chain index)
  	SKB_EXT_NUM, /* must be last */
  };
  
diff --cc net/core/skbuff.c
index a1768efc0b86,2b40b5a9425b..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -3952,6 -4084,12 +3952,15 @@@ static const u8 skb_ext_type_len[] = 
  #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
  	[SKB_EXT_BRIDGE_NF] = SKB_EXT_CHUNKSIZEOF(struct nf_bridge_info),
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_XFRM
+ 	[SKB_EXT_SEC_PATH] = SKB_EXT_CHUNKSIZEOF(struct sec_path),
+ #endif
+ #if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+ 	[TC_SKB_EXT] = SKB_EXT_CHUNKSIZEOF(struct tc_skb_ext),
+ #endif
++>>>>>>> 95a7233c452a (net: openvswitch: Set OvS recirc_id from tc chain index)
  };
  
  static __always_inline unsigned int skb_ext_total_length(void)
@@@ -3960,6 -4098,12 +3969,15 @@@
  #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
  		skb_ext_type_len[SKB_EXT_BRIDGE_NF] +
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_XFRM
+ 		skb_ext_type_len[SKB_EXT_SEC_PATH] +
+ #endif
+ #if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+ 		skb_ext_type_len[TC_SKB_EXT] +
+ #endif
++>>>>>>> 95a7233c452a (net: openvswitch: Set OvS recirc_id from tc chain index)
  		0;
  }
  
diff --cc net/sched/Kconfig
index f5773effcfdc,b3faafeafab9..000000000000
--- a/net/sched/Kconfig
+++ b/net/sched/Kconfig
@@@ -940,13 -963,18 +940,28 @@@ config NET_IFE_SKBTCINDE
          tristate "Support to encoding decoding skb tcindex on IFE action"
          depends on NET_ACT_IFE
  
++<<<<<<< HEAD
 +config NET_CLS_IND
 +	bool "Incoming device classification"
 +	depends on NET_CLS_U32 || NET_CLS_FW
 +	---help---
 +	  Say Y here to extend the u32 and fw classifier to support
 +	  classification based on the incoming device. This option is
 +	  likely to disappear in favour of the metadata ematch.
++=======
+ config NET_TC_SKB_EXT
+ 	bool "TC recirculation support"
+ 	depends on NET_CLS_ACT
+ 	default y if NET_CLS_ACT
+ 	select SKB_EXTENSIONS
+ 
+ 	help
+ 	  Say Y here to allow tc chain misses to continue in OvS datapath in
+ 	  the correct recirc_id, and hardware chain misses to continue in
+ 	  the correct chain in tc software datapath.
+ 
+ 	  Say N here if you won't be using tc<->ovs offload or tc chains offload.
++>>>>>>> 95a7233c452a (net: openvswitch: Set OvS recirc_id from tc chain index)
  
  endif # NET_SCHED
  
* Unmerged path include/linux/skbuff.h
diff --git a/include/uapi/linux/openvswitch.h b/include/uapi/linux/openvswitch.h
index dbe0cbe4f1b7..b815b34db1ae 100644
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@ -123,6 +123,9 @@ struct ovs_vport_stats {
 /* Allow datapath to associate multiple Netlink PIDs to each vport */
 #define OVS_DP_F_VPORT_PIDS	(1 << 1)
 
+/* Allow tc offload recirc sharing */
+#define OVS_DP_F_TC_RECIRC_SHARING	(1 << 2)
+
 /* Fixed logical ports. */
 #define OVSP_LOCAL      ((__u32)0)
 
* Unmerged path net/core/skbuff.c
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index d4afddccb179..d00f465422ff 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -1554,10 +1554,34 @@ static void ovs_dp_reset_user_features(struct sk_buff *skb, struct genl_info *in
 	dp->user_features = 0;
 }
 
-static void ovs_dp_change(struct datapath *dp, struct nlattr *a[])
+DEFINE_STATIC_KEY_FALSE(tc_recirc_sharing_support);
+
+static int ovs_dp_change(struct datapath *dp, struct nlattr *a[])
 {
-	if (a[OVS_DP_ATTR_USER_FEATURES])
-		dp->user_features = nla_get_u32(a[OVS_DP_ATTR_USER_FEATURES]);
+	u32 user_features = 0;
+
+	if (a[OVS_DP_ATTR_USER_FEATURES]) {
+		user_features = nla_get_u32(a[OVS_DP_ATTR_USER_FEATURES]);
+
+		if (user_features & ~(OVS_DP_F_VPORT_PIDS |
+				      OVS_DP_F_UNALIGNED |
+				      OVS_DP_F_TC_RECIRC_SHARING))
+			return -EOPNOTSUPP;
+
+#if !IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+		if (user_features & OVS_DP_F_TC_RECIRC_SHARING)
+			return -EOPNOTSUPP;
+#endif
+	}
+
+	dp->user_features = user_features;
+
+	if (dp->user_features & OVS_DP_F_TC_RECIRC_SHARING)
+		static_branch_enable(&tc_recirc_sharing_support);
+	else
+		static_branch_disable(&tc_recirc_sharing_support);
+
+	return 0;
 }
 
 static int ovs_dp_cmd_new(struct sk_buff *skb, struct genl_info *info)
@@ -1619,7 +1643,9 @@ static int ovs_dp_cmd_new(struct sk_buff *skb, struct genl_info *info)
 	parms.port_no = OVSP_LOCAL;
 	parms.upcall_portids = a[OVS_DP_ATTR_UPCALL_PID];
 
-	ovs_dp_change(dp, a);
+	err = ovs_dp_change(dp, a);
+	if (err)
+		goto err_destroy_meters;
 
 	/* So far only local changes have been made, now need the lock. */
 	ovs_lock();
@@ -1745,7 +1771,9 @@ static int ovs_dp_cmd_set(struct sk_buff *skb, struct genl_info *info)
 	if (IS_ERR(dp))
 		goto err_unlock_free;
 
-	ovs_dp_change(dp, info->attrs);
+	err = ovs_dp_change(dp, info->attrs);
+	if (err)
+		goto err_unlock_free;
 
 	err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,
 				   info->snd_seq, 0, OVS_DP_CMD_SET);
diff --git a/net/openvswitch/datapath.h b/net/openvswitch/datapath.h
index c9eb267c6f7e..42dc282f8306 100644
--- a/net/openvswitch/datapath.h
+++ b/net/openvswitch/datapath.h
@@ -231,6 +231,8 @@ static inline struct datapath *get_dp(struct net *net, int dp_ifindex)
 extern struct notifier_block ovs_dp_device_notifier;
 extern struct genl_family dp_vport_genl_family;
 
+DECLARE_STATIC_KEY_FALSE(tc_recirc_sharing_support);
+
 void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key);
 void ovs_dp_detach_port(struct vport *);
 int ovs_dp_upcall(struct datapath *, struct sk_buff *,
diff --git a/net/openvswitch/flow.c b/net/openvswitch/flow.c
index c7d8eff6c272..8220334101fe 100644
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@ -832,6 +832,9 @@ static int key_extract_mac_proto(struct sk_buff *skb)
 int ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,
 			 struct sk_buff *skb, struct sw_flow_key *key)
 {
+#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+	struct tc_skb_ext *tc_ext;
+#endif
 	int res, err;
 
 	/* Extract metadata from packet. */
@@ -864,7 +867,17 @@ int ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,
 	if (res < 0)
 		return res;
 	key->mac_proto = res;
+
+#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+	if (static_branch_unlikely(&tc_recirc_sharing_support)) {
+		tc_ext = skb_ext_find(skb, TC_SKB_EXT);
+		key->recirc_id = tc_ext ? tc_ext->chain : 0;
+	} else {
+		key->recirc_id = 0;
+	}
+#else
 	key->recirc_id = 0;
+#endif
 
 	err = key_extract(skb, key);
 	if (!err)
* Unmerged path net/sched/Kconfig
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index 081ac3d0fb50..b107f8014c0d 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -1754,6 +1754,18 @@ int tcf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 			goto reset;
 		} else if (unlikely(TC_ACT_EXT_CMP(err, TC_ACT_GOTO_CHAIN))) {
 			first_tp = res->goto_tp;
+
+#if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+			{
+				struct tc_skb_ext *ext;
+
+				ext = skb_ext_add(skb, TC_SKB_EXT);
+				if (WARN_ON_ONCE(!ext))
+					return TC_ACT_SHOT;
+
+				ext->chain = err & TC_ACT_EXT_VAL_MASK;
+			}
+#endif
 			goto reset;
 		}
 #endif
