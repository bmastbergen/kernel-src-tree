mt76: remove mt76_queue dependency from tx_prepare_skb function pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit 300832ad5f53591311304bb3af749dc427957d2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/300832ad.failed

Remove mt76_queue dependency from tx_prepare_skb function pointer and
rely on mt76_tx_qid instead. This is a preliminary patch to introduce
mt76_sw_queue support

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit 300832ad5f53591311304bb3af749dc427957d2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/dma.c
#	drivers/net/wireless/mediatek/mt76/mt76.h
#	drivers/net/wireless/mediatek/mt76/mt76x02.h
#	drivers/net/wireless/mediatek/mt76/mt76x02_txrx.c
#	drivers/net/wireless/mediatek/mt76/mt76x02_usb.h
#	drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
#	drivers/net/wireless/mediatek/mt76/usb.c
diff --cc drivers/net/wireless/mediatek/mt76/dma.c
index 4381155375e1,a9f0195ef0b7..000000000000
--- a/drivers/net/wireless/mediatek/mt76/dma.c
+++ b/drivers/net/wireless/mediatek/mt76/dma.c
@@@ -307,24 -297,32 +307,35 @@@ mt76_dma_tx_queue_skb(struct mt76_dev *
  		ieee80211_free_txskb(dev->hw, skb);
  		return -ENOMEM;
  	}
 +	txwi = mt76_get_txwi_ptr(dev, t);
  
  	skb->prev = skb->next = NULL;
++<<<<<<< HEAD
 +	if (dev->drv->tx_aligned4_skbs)
 +		mt76_insert_hdr_pad(skb);
++=======
+ 	dma_sync_single_for_cpu(dev->dev, t->dma_addr, sizeof(t->txwi),
+ 				DMA_TO_DEVICE);
+ 	ret = dev->drv->tx_prepare_skb(dev, &t->txwi, skb, qid, wcid, sta,
+ 				       &tx_info);
+ 	dma_sync_single_for_device(dev->dev, t->dma_addr, sizeof(t->txwi),
+ 				   DMA_TO_DEVICE);
+ 	if (ret < 0)
+ 		goto free;
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  
 -	len = skb->len - skb->data_len;
 +	len = skb_headlen(skb);
  	addr = dma_map_single(dev->dev, skb->data, len, DMA_TO_DEVICE);
 -	if (dma_mapping_error(dev->dev, addr)) {
 -		ret = -ENOMEM;
 +	if (unlikely(dma_mapping_error(dev->dev, addr)))
  		goto free;
 -	}
  
 -	n = 0;
 -	buf[n].addr = t->dma_addr;
 -	buf[n++].len = dev->drv->txwi_size;
 -	buf[n].addr = addr;
 -	buf[n++].len = len;
 +	tx_info.buf[n].addr = t->dma_addr;
 +	tx_info.buf[n++].len = dev->drv->txwi_size;
 +	tx_info.buf[n].addr = addr;
 +	tx_info.buf[n++].len = len;
  
  	skb_walk_frags(skb, iter) {
 -		if (n == ARRAY_SIZE(buf))
 +		if (n == ARRAY_SIZE(tx_info.buf))
  			goto unmap;
  
  		addr = dma_map_single(dev->dev, iter->data, iter->len,
diff --cc drivers/net/wireless/mediatek/mt76/mt76.h
index 1c8ddf9c225d,98d41f4aebb5..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76.h
@@@ -300,12 -288,12 +300,18 @@@ struct mt76_driver_ops 
  	void (*update_survey)(struct mt76_dev *dev);
  
  	int (*tx_prepare_skb)(struct mt76_dev *dev, void *txwi_ptr,
++<<<<<<< HEAD
 +			      enum mt76_txq_id qid, struct mt76_wcid *wcid,
 +			      struct ieee80211_sta *sta,
 +			      struct mt76_tx_info *tx_info);
++=======
+ 			      struct sk_buff *skb, enum mt76_txq_id qid,
+ 			      struct mt76_wcid *wcid,
+ 			      struct ieee80211_sta *sta, u32 *tx_info);
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  
 -	void (*tx_complete_skb)(struct mt76_dev *dev, struct mt76_queue *q,
 -				struct mt76_queue_entry *e, bool flush);
 +	void (*tx_complete_skb)(struct mt76_dev *dev, enum mt76_txq_id qid,
 +				struct mt76_queue_entry *e);
  
  	bool (*tx_status_data)(struct mt76_dev *dev, u8 *update);
  
diff --cc drivers/net/wireless/mediatek/mt76/mt76x02.h
index f7fd53a1738a,9b66dceca148..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x02.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02.h
@@@ -180,9 -173,9 +180,15 @@@ irqreturn_t mt76x02_irq_handler(int irq
  void mt76x02_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,
  		struct sk_buff *skb);
  int mt76x02_tx_prepare_skb(struct mt76_dev *mdev, void *txwi,
++<<<<<<< HEAD
 +			   enum mt76_txq_id qid, struct mt76_wcid *wcid,
 +			   struct ieee80211_sta *sta,
 +			   struct mt76_tx_info *tx_info);
++=======
+ 			   struct sk_buff *skb, enum mt76_txq_id qid,
+ 			   struct mt76_wcid *wcid, struct ieee80211_sta *sta,
+ 			   u32 *tx_info);
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  void mt76x02_sw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
  		     const u8 *mac);
  void mt76x02_sw_scan_complete(struct ieee80211_hw *hw,
diff --cc drivers/net/wireless/mediatek/mt76/mt76x02_txrx.c
index 04118f08debc,ce9ace11339d..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_txrx.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_txrx.c
@@@ -147,15 -147,15 +147,21 @@@ bool mt76x02_tx_status_data(struct mt76
  EXPORT_SYMBOL_GPL(mt76x02_tx_status_data);
  
  int mt76x02_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
++<<<<<<< HEAD
 +			   enum mt76_txq_id qid, struct mt76_wcid *wcid,
 +			   struct ieee80211_sta *sta,
 +			   struct mt76_tx_info *tx_info)
++=======
+ 			   struct sk_buff *skb, enum mt76_txq_id qid,
+ 			   struct mt76_wcid *wcid, struct ieee80211_sta *sta,
+ 			   u32 *tx_info)
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  {
  	struct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);
 +	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx_info->skb->data;
  	struct mt76x02_txwi *txwi = txwi_ptr;
 -	int qsel = MT_QSEL_EDCA;
 -	int pid;
 -	int ret;
 +	bool ampdu = IEEE80211_SKB_CB(tx_info->skb)->flags & IEEE80211_TX_CTL_AMPDU;
 +	int hdrlen, len, pid, qsel = MT_QSEL_EDCA;
  
  	if (qid == MT_TXQ_PSD && wcid && wcid->idx < 128)
  		mt76x02_mac_wcid_set_drop(dev, wcid->idx, false);
diff --cc drivers/net/wireless/mediatek/mt76/mt76x02_usb.h
index 7b53f9e57f29,20e0cee6e4e4..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_usb.h
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_usb.h
@@@ -26,11 -26,9 +26,19 @@@ int mt76x02u_mcu_fw_send_data(struct mt
  
  int mt76x02u_skb_dma_info(struct sk_buff *skb, int port, u32 flags);
  int mt76x02u_tx_prepare_skb(struct mt76_dev *mdev, void *data,
++<<<<<<< HEAD
 +			    enum mt76_txq_id qid, struct mt76_wcid *wcid,
 +			    struct ieee80211_sta *sta,
 +			    struct mt76_tx_info *tx_info);
 +void mt76x02u_tx_complete_skb(struct mt76_dev *mdev, enum mt76_txq_id qid,
 +			      struct mt76_queue_entry *e);
 +void mt76x02u_init_beacon_config(struct mt76x02_dev *dev);
 +void mt76x02u_exit_beacon_config(struct mt76x02_dev *dev);
++=======
+ 			    struct sk_buff *skb, enum mt76_txq_id qid,
+ 			    struct mt76_wcid *wcid, struct ieee80211_sta *sta,
+ 			    u32 *tx_info);
+ void mt76x02u_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue *q,
+ 			      struct mt76_queue_entry *e, bool flush);
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  #endif /* __MT76x02_USB_H */
diff --cc drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
index 5e4f3a8c5784,643a817ae079..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
@@@ -72,33 -72,26 +72,46 @@@ int mt76x02u_skb_dma_info(struct sk_buf
  }
  
  int mt76x02u_tx_prepare_skb(struct mt76_dev *mdev, void *data,
++<<<<<<< HEAD
 +			    enum mt76_txq_id qid, struct mt76_wcid *wcid,
 +			    struct ieee80211_sta *sta,
 +			    struct mt76_tx_info *tx_info)
 +{
 +	struct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);
 +	int pid, len = tx_info->skb->len, ep = q2ep(mdev->q_tx[qid].q->hw_idx);
++=======
+ 			    struct sk_buff *skb, enum mt76_txq_id qid,
+ 			    struct mt76_wcid *wcid, struct ieee80211_sta *sta,
+ 			    u32 *tx_info)
+ {
+ 	struct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);
+ 	int pid, len = skb->len, ep = q2ep(mdev->q_tx[qid].hw_idx);
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  	struct mt76x02_txwi *txwi;
 +	bool ampdu = IEEE80211_SKB_CB(tx_info->skb)->flags & IEEE80211_TX_CTL_AMPDU;
  	enum mt76_qsel qsel;
  	u32 flags;
  
 -	mt76x02_insert_hdr_pad(skb);
 +	mt76_insert_hdr_pad(tx_info->skb);
 +
 +	txwi = (struct mt76x02_txwi *)(tx_info->skb->data - sizeof(*txwi));
 +	mt76x02_mac_write_txwi(dev, txwi, tx_info->skb, wcid, sta, len);
 +	skb_push(tx_info->skb, sizeof(*txwi));
 +
 +	pid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);
  
 -	txwi = (struct mt76x02_txwi *)(skb->data - sizeof(struct mt76x02_txwi));
 -	mt76x02_mac_write_txwi(dev, txwi, skb, wcid, sta, len);
 -	skb_push(skb, sizeof(struct mt76x02_txwi));
 +	/* encode packet rate for no-skb packet id to fix up status reporting */
 +	if (pid == MT_PACKET_ID_NO_SKB)
 +		pid = MT_PACKET_ID_HAS_RATE |
 +		      (le16_to_cpu(txwi->rate) & MT_RXWI_RATE_INDEX);
  
 -	pid = mt76_tx_status_skb_add(mdev, wcid, skb);
  	txwi->pktid = pid;
  
++<<<<<<< HEAD
 +	if ((mt76_is_skb_pktid(pid) && ampdu) || ep == MT_EP_OUT_HCCA)
++=======
+ 	if (pid >= MT_PACKET_ID_FIRST || ep == MT_EP_OUT_HCCA)
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  		qsel = MT_QSEL_MGMT;
  	else
  		qsel = MT_QSEL_EDCA;
diff --cc drivers/net/wireless/mediatek/mt76/usb.c
index fb87ce7fbdf6,e9ccdab8f919..000000000000
--- a/drivers/net/wireless/mediatek/mt76/usb.c
+++ b/drivers/net/wireless/mediatek/mt76/usb.c
@@@ -788,7 -739,7 +788,11 @@@ mt76u_tx_queue_skb(struct mt76_dev *dev
  		return -ENOSPC;
  
  	skb->prev = skb->next = NULL;
++<<<<<<< HEAD
 +	err = dev->drv->tx_prepare_skb(dev, NULL, qid, wcid, sta, &tx_info);
++=======
+ 	err = dev->drv->tx_prepare_skb(dev, NULL, skb, qid, wcid, sta, NULL);
++>>>>>>> 300832ad5f53 (mt76: remove mt76_queue dependency from tx_prepare_skb function pointer)
  	if (err < 0)
  		return err;
  
* Unmerged path drivers/net/wireless/mediatek/mt76/dma.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76.h
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
index 5abc02b57818..306323f5b205 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c
@@ -783,7 +783,7 @@ int mt7603_wtbl_set_key(struct mt7603_dev *dev, int wcid,
 
 static int
 mt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,
-		      struct sk_buff *skb, struct mt76_queue *q,
+		      struct sk_buff *skb, enum mt76_txq_id qid,
 		      struct mt76_wcid *wcid, struct ieee80211_sta *sta,
 		      int pid, struct ieee80211_key_conf *key)
 {
@@ -792,6 +792,7 @@ mt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;
 	struct ieee80211_vif *vif = info->control.vif;
+	struct mt76_queue *q = &dev->mt76.q_tx[qid];
 	struct mt7603_vif *mvif;
 	int wlan_idx;
 	int hdr_len = ieee80211_get_hdrlen_from_skb(skb);
@@ -806,7 +807,7 @@ mt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,
 	if (vif) {
 		mvif = (struct mt7603_vif *)vif->drv_priv;
 		vif_idx = mvif->idx;
-		if (vif_idx && q >= &dev->mt76.q_tx[MT_TXQ_BEACON])
+		if (vif_idx && qid >= MT_TXQ_BEACON)
 			vif_idx += 0x10;
 	}
 
@@ -880,7 +881,7 @@ mt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,
 	}
 
 	/* use maximum tx count for beacons and buffered multicast */
-	if (q >= &dev->mt76.q_tx[MT_TXQ_BEACON])
+	if (qid >= MT_TXQ_BEACON)
 		tx_count = 0x1f;
 
 	val = FIELD_PREP(MT_TXD3_REM_TX_COUNT, tx_count) |
@@ -911,7 +912,7 @@ mt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,
 }
 
 int mt7603_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
-			  struct sk_buff *skb, struct mt76_queue *q,
+			  struct sk_buff *skb, enum mt76_txq_id qid,
 			  struct mt76_wcid *wcid, struct ieee80211_sta *sta,
 			  u32 *tx_info)
 {
@@ -943,7 +944,7 @@ int mt7603_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 		spin_unlock_bh(&dev->mt76.lock);
 	}
 
-	mt7603_mac_write_txwi(dev, txwi_ptr, skb, q, wcid, sta, pid, key);
+	mt7603_mac_write_txwi(dev, txwi_ptr, skb, qid, wcid, sta, pid, key);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h b/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h
index 6049f3b7c8fe..55a2ad34f5f4 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h
+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mt7603.h
@@ -225,7 +225,7 @@ void mt7603_wtbl_set_smps(struct mt7603_dev *dev, struct mt7603_sta *sta,
 void mt7603_filter_tx(struct mt7603_dev *dev, int idx, bool abort);
 
 int mt7603_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
-			  struct sk_buff *skb, struct mt76_queue *q,
+			  struct sk_buff *skb, enum mt76_txq_id qid,
 			  struct mt76_wcid *wcid, struct ieee80211_sta *sta,
 			  u32 *tx_info);
 
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x02.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x02_txrx.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x02_usb.h
* Unmerged path drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c
* Unmerged path drivers/net/wireless/mediatek/mt76/usb.c
