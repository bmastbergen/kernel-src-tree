RDMA: Check umem pointer validity prior to release

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Leon Romanovsky <leon@kernel.org>
commit 836a0fbb3e76f704ad65ddfb57f00725245e509b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/836a0fbb.failed

Update ib_umem_release() to behave similarly to kfree() and allow
submitting NULL pointer as safe input to this function.

Fixes: a52c8e2469c3 ("RDMA: Clean destroy CQ in drivers do not return errors")
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 836a0fbb3e76f704ad65ddfb57f00725245e509b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/bnxt_re/ib_verbs.c
#	drivers/infiniband/hw/hns/hns_roce_cq.c
#	drivers/infiniband/hw/hns/hns_roce_hw_v1.c
#	drivers/infiniband/hw/hns/hns_roce_hw_v2.c
#	drivers/infiniband/hw/hns/hns_roce_qp.c
#	drivers/infiniband/hw/hns/hns_roce_srq.c
#	drivers/infiniband/hw/mlx4/cq.c
#	drivers/infiniband/hw/mlx4/srq.c
diff --cc drivers/infiniband/hw/bnxt_re/ib_verbs.c
index 9361cce3c120,a91653aabf38..000000000000
--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.c
+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.c
@@@ -1334,15 -1295,8 +1328,20 @@@ int bnxt_re_destroy_srq(struct ib_srq *
  
  	if (qplib_srq->cq)
  		nq = qplib_srq->cq->nq;
++<<<<<<< HEAD
 +	rc = bnxt_qplib_destroy_srq(&rdev->qplib_res, qplib_srq);
 +	if (rc) {
 +		dev_err(rdev_to_dev(rdev), "Destroy HW SRQ failed!");
 +		return rc;
 +	}
 +
 +	if (srq->umem)
 +		ib_umem_release(srq->umem);
 +	kfree(srq);
++=======
+ 	bnxt_qplib_destroy_srq(&rdev->qplib_res, qplib_srq);
+ 	ib_umem_release(srq->umem);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  	atomic_dec(&rdev->srq_count);
  	if (nq)
  		nq->budget--;
@@@ -1453,14 -1402,12 +1452,18 @@@ struct ib_srq *bnxt_re_create_srq(struc
  		nq->budget++;
  	atomic_inc(&rdev->srq_count);
  
 -	return 0;
 +	return &srq->ib_srq;
  
  fail:
++<<<<<<< HEAD
 +	if (srq->umem)
 +		ib_umem_release(srq->umem);
 +	kfree(srq);
++=======
+ 	ib_umem_release(srq->umem);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  exit:
 -	return rc;
 +	return ERR_PTR(rc);
  }
  
  int bnxt_re_modify_srq(struct ib_srq *ib_srq, struct ib_srq_attr *srq_attr,
@@@ -2568,13 -2519,8 +2571,18 @@@ int bnxt_re_destroy_cq(struct ib_cq *ib
  	rdev = cq->rdev;
  	nq = cq->qplib_cq.nq;
  
++<<<<<<< HEAD
 +	rc = bnxt_qplib_destroy_cq(&rdev->qplib_res, &cq->qplib_cq);
 +	if (rc) {
 +		dev_err(rdev_to_dev(rdev), "Failed to destroy HW CQ");
 +		return rc;
 +	}
 +	if (!IS_ERR_OR_NULL(cq->umem))
 +		ib_umem_release(cq->umem);
++=======
+ 	bnxt_qplib_destroy_cq(&rdev->qplib_res, &cq->qplib_cq);
+ 	ib_umem_release(cq->umem);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  
  	atomic_dec(&rdev->cq_count);
  	nq->budget--;
@@@ -2685,15 -2620,13 +2693,19 @@@ struct ib_cq *bnxt_re_create_cq(struct 
  		}
  	}
  
 -	return 0;
 +	return &cq->ib_cq;
  
  c2fail:
++<<<<<<< HEAD
 +	if (context)
 +		ib_umem_release(cq->umem);
++=======
+ 	ib_umem_release(cq->umem);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  fail:
  	kfree(cq->cql);
 -	return rc;
 +	kfree(cq);
 +	return ERR_PTR(rc);
  }
  
  static u8 __req_to_ib_wc_status(u8 qstatus)
diff --cc drivers/infiniband/hw/hns/hns_roce_cq.c
index 3a485f50fede,6b4d8e50aabe..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_cq.c
+++ b/drivers/infiniband/hw/hns/hns_roce_cq.c
@@@ -435,9 -423,8 +435,14 @@@ err_dbmap
  
  err_mtt:
  	hns_roce_mtt_cleanup(hr_dev, &hr_cq->hr_buf.hr_mtt);
++<<<<<<< HEAD
 +	if (context)
 +		ib_umem_release(hr_cq->umem);
 +	else
++=======
+ 	ib_umem_release(hr_cq->umem);
+ 	if (!udata)
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  		hns_roce_ib_free_cq_buf(hr_dev, &hr_cq->hr_buf,
  					hr_cq->ib_cq.cqe);
  
@@@ -455,33 -441,29 +460,51 @@@ int hns_roce_ib_destroy_cq(struct ib_c
  {
  	struct hns_roce_dev *hr_dev = to_hr_dev(ib_cq->device);
  	struct hns_roce_cq *hr_cq = to_hr_cq(ib_cq);
 +	int ret = 0;
  
  	if (hr_dev->hw->destroy_cq) {
++<<<<<<< HEAD
 +		ret = hr_dev->hw->destroy_cq(ib_cq);
++=======
+ 		hr_dev->hw->destroy_cq(ib_cq, udata);
+ 		return;
+ 	}
+ 
+ 	hns_roce_free_cq(hr_dev, hr_cq);
+ 	hns_roce_mtt_cleanup(hr_dev, &hr_cq->hr_buf.hr_mtt);
+ 
+ 	ib_umem_release(hr_cq->umem);
+ 	if (udata) {
+ 		if (hr_cq->db_en == 1)
+ 			hns_roce_db_unmap_user(rdma_udata_to_drv_context(
+ 						       udata,
+ 						       struct hns_roce_ucontext,
+ 						       ibucontext),
+ 					       &hr_cq->db);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  	} else {
 -		/* Free the buff of stored cq */
 -		hns_roce_ib_free_cq_buf(hr_dev, &hr_cq->hr_buf, ib_cq->cqe);
 -		if (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB)
 -			hns_roce_free_db(hr_dev, &hr_cq->db);
 +		hns_roce_free_cq(hr_dev, hr_cq);
 +		hns_roce_mtt_cleanup(hr_dev, &hr_cq->hr_buf.hr_mtt);
 +
 +		if (ib_cq->uobject) {
 +			ib_umem_release(hr_cq->umem);
 +
 +			if (hr_cq->db_en == 1)
 +				hns_roce_db_unmap_user(
 +					to_hr_ucontext(ib_cq->uobject->context),
 +					&hr_cq->db);
 +		} else {
 +			/* Free the buff of stored cq */
 +			hns_roce_ib_free_cq_buf(hr_dev, &hr_cq->hr_buf,
 +						ib_cq->cqe);
 +			if (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB)
 +				hns_roce_free_db(hr_dev, &hr_cq->db);
 +		}
 +
 +		kfree(hr_cq);
  	}
 +
 +	return ret;
  }
  EXPORT_SYMBOL_GPL(hns_roce_ib_destroy_cq);
  
diff --cc drivers/infiniband/hw/hns/hns_roce_hw_v1.c
index ce18a158aa0b,cb004190ccba..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
+++ b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c
@@@ -3959,9 -3640,8 +3958,14 @@@ int hns_roce_v1_destroy_qp(struct ib_q
  
  	hns_roce_mtt_cleanup(hr_dev, &hr_qp->mtt);
  
++<<<<<<< HEAD
 +	if (is_user)
 +		ib_umem_release(hr_qp->umem);
 +	else {
++=======
+ 	ib_umem_release(hr_qp->umem);
+ 	if (!udata) {
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  		kfree(hr_qp->sq.wrid);
  		kfree(hr_qp->rq.wrid);
  
diff --cc drivers/infiniband/hw/hns/hns_roce_hw_v2.c
index 9390d30235c7,edd62b4dc0a0..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_hw_v2.c
+++ b/drivers/infiniband/hw/hns/hns_roce_hw_v2.c
@@@ -3914,17 -4570,18 +3914,21 @@@ static int hns_roce_v2_destroy_qp_commo
  
  	hns_roce_mtt_cleanup(hr_dev, &hr_qp->mtt);
  
 -	if (udata) {
 -		struct hns_roce_ucontext *context =
 -			rdma_udata_to_drv_context(
 -				udata,
 -				struct hns_roce_ucontext,
 -				ibucontext);
 -
 +	if (is_user) {
  		if (hr_qp->sq.wqe_cnt && (hr_qp->sdb_en == 1))
 -			hns_roce_db_unmap_user(context, &hr_qp->sdb);
 +			hns_roce_db_unmap_user(
 +				to_hr_ucontext(hr_qp->ibqp.uobject->context),
 +				&hr_qp->sdb);
  
  		if (hr_qp->rq.wqe_cnt && (hr_qp->rdb_en == 1))
++<<<<<<< HEAD
 +			hns_roce_db_unmap_user(
 +				to_hr_ucontext(hr_qp->ibqp.uobject->context),
 +				&hr_qp->rdb);
 +		ib_umem_release(hr_qp->umem);
++=======
+ 			hns_roce_db_unmap_user(context, &hr_qp->rdb);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  	} else {
  		kfree(hr_qp->sq.wrid);
  		kfree(hr_qp->rq.wrid);
@@@ -3932,8 -4589,10 +3936,9 @@@
  		if (hr_qp->rq.wqe_cnt)
  			hns_roce_free_db(hr_dev, &hr_qp->rdb);
  	}
+ 	ib_umem_release(hr_qp->umem);
  
 -	if ((hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RQ_INLINE) &&
 -	     hr_qp->rq.wqe_cnt) {
 +	if (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RQ_INLINE) {
  		kfree(hr_qp->rq_inl_buf.wqe_list[0].sg_list);
  		kfree(hr_qp->rq_inl_buf.wqe_list);
  	}
diff --cc drivers/infiniband/hw/hns/hns_roce_qp.c
index 21ec4d28079a,7e9db8236072..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_qp.c
+++ b/drivers/infiniband/hw/hns/hns_roce_qp.c
@@@ -823,18 -932,15 +823,24 @@@ err_sq_dbmap
  		    (udata->inlen >= sizeof(ucmd)) &&
  		    (udata->outlen >= sizeof(resp)) &&
  		    hns_roce_qp_has_sq(init_attr))
 -			hns_roce_db_unmap_user(uctx, &hr_qp->sdb);
 +			hns_roce_db_unmap_user(
 +					to_hr_ucontext(ib_pd->uobject->context),
 +					&hr_qp->sdb);
  
 -err_get_bufs:
 -	hns_roce_free_buf_list(buf_list, hr_qp->region_cnt);
 +err_mtt:
 +	hns_roce_mtt_cleanup(hr_dev, &hr_qp->mtt);
  
++<<<<<<< HEAD
 +err_buf:
 +	if (hr_qp->umem)
 +		ib_umem_release(hr_qp->umem);
 +	else
++=======
+ err_alloc_list:
+ 	if (!hr_qp->umem)
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  		hns_roce_buf_free(hr_dev, hr_qp->buff_size, &hr_qp->hr_buf);
+ 	ib_umem_release(hr_qp->umem);
  
  err_db:
  	if (!udata && hns_roce_qp_has_rq(init_attr) &&
diff --cc drivers/infiniband/hw/mlx4/cq.c
index 3b6507196091,a7d238d312f0..000000000000
--- a/drivers/infiniband/hw/mlx4/cq.c
+++ b/drivers/infiniband/hw/mlx4/cq.c
@@@ -281,9 -277,8 +281,14 @@@ err_dbmap
  err_mtt:
  	mlx4_mtt_cleanup(dev->dev, &cq->buf.mtt);
  
++<<<<<<< HEAD
 +	if (context)
 +		ib_umem_release(cq->umem);
 +	else
++=======
+ 	ib_umem_release(cq->umem);
+ 	if (!udata)
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  		mlx4_ib_free_cq_buf(dev, &cq->buf, cq->ibcq.cqe);
  
  err_db:
@@@ -494,17 -483,18 +496,31 @@@ int mlx4_ib_destroy_cq(struct ib_cq *cq
  	mlx4_cq_free(dev->dev, &mcq->mcq);
  	mlx4_mtt_cleanup(dev->dev, &mcq->buf.mtt);
  
++<<<<<<< HEAD
 +	if (cq->uobject) {
 +		mlx4_ib_db_unmap_user(to_mucontext(cq->uobject->context), &mcq->db);
 +		ib_umem_release(mcq->umem);
++=======
+ 	if (udata) {
+ 		mlx4_ib_db_unmap_user(
+ 			rdma_udata_to_drv_context(
+ 				udata,
+ 				struct mlx4_ib_ucontext,
+ 				ibucontext),
+ 			&mcq->db);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  	} else {
  		mlx4_ib_free_cq_buf(dev, &mcq->buf, cq->cqe);
  		mlx4_db_free(dev->dev, &mcq->db);
  	}
++<<<<<<< HEAD
 +
 +	kfree(mcq);
 +
 +	return 0;
++=======
+ 	ib_umem_release(mcq->umem);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  }
  
  static void dump_cqe(void *cqe)
diff --cc drivers/infiniband/hw/mlx4/srq.c
index 4456f1b8921d,848db7264cc9..000000000000
--- a/drivers/infiniband/hw/mlx4/srq.c
+++ b/drivers/infiniband/hw/mlx4/srq.c
@@@ -278,19 -267,20 +277,33 @@@ int mlx4_ib_destroy_srq(struct ib_srq *
  	mlx4_srq_free(dev->dev, &msrq->msrq);
  	mlx4_mtt_cleanup(dev->dev, &msrq->mtt);
  
++<<<<<<< HEAD
 +	if (srq->uobject) {
 +		mlx4_ib_db_unmap_user(to_mucontext(srq->uobject->context), &msrq->db);
 +		ib_umem_release(msrq->umem);
++=======
+ 	if (udata) {
+ 		mlx4_ib_db_unmap_user(
+ 			rdma_udata_to_drv_context(
+ 				udata,
+ 				struct mlx4_ib_ucontext,
+ 				ibucontext),
+ 			&msrq->db);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  	} else {
  		kvfree(msrq->wrid);
  		mlx4_buf_free(dev->dev, msrq->msrq.max << msrq->msrq.wqe_shift,
  			      &msrq->buf);
  		mlx4_db_free(dev->dev, &msrq->db);
  	}
++<<<<<<< HEAD
 +
 +	kfree(msrq);
 +
 +	return 0;
++=======
+ 	ib_umem_release(msrq->umem);
++>>>>>>> 836a0fbb3e76 (RDMA: Check umem pointer validity prior to release)
  }
  
  void mlx4_ib_free_srq_wqe(struct mlx4_ib_srq *srq, int wqe_index)
* Unmerged path drivers/infiniband/hw/hns/hns_roce_srq.c
diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c
index edc90e805bd8..1cbd16ba5a4b 100644
--- a/drivers/infiniband/core/umem.c
+++ b/drivers/infiniband/core/umem.c
@@ -352,6 +352,9 @@ static void __ib_umem_release_tail(struct ib_umem *umem)
  */
 void ib_umem_release(struct ib_umem *umem)
 {
+	if (!umem)
+		return;
+
 	if (umem->is_odp) {
 		ib_umem_odp_release(to_ib_umem_odp(umem));
 		__ib_umem_release_tail(umem);
* Unmerged path drivers/infiniband/hw/bnxt_re/ib_verbs.c
diff --git a/drivers/infiniband/hw/cxgb3/iwch_provider.c b/drivers/infiniband/hw/cxgb3/iwch_provider.c
index ba5689180499..3b3b50732a14 100644
--- a/drivers/infiniband/hw/cxgb3/iwch_provider.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_provider.c
@@ -433,8 +433,7 @@ static int iwch_dereg_mr(struct ib_mr *ib_mr)
 	remove_handle(rhp, &rhp->mmidr, mmid);
 	if (mhp->kva)
 		kfree((void *) (unsigned long) mhp->kva);
-	if (mhp->umem)
-		ib_umem_release(mhp->umem);
+	ib_umem_release(mhp->umem);
 	pr_debug("%s mmid 0x%x ptr %p\n", __func__, mmid, mhp);
 	kfree(mhp);
 	return 0;
diff --git a/drivers/infiniband/hw/cxgb4/mem.c b/drivers/infiniband/hw/cxgb4/mem.c
index 743d91421184..491aff36ee65 100644
--- a/drivers/infiniband/hw/cxgb4/mem.c
+++ b/drivers/infiniband/hw/cxgb4/mem.c
@@ -808,8 +808,7 @@ int c4iw_dereg_mr(struct ib_mr *ib_mr)
 				  mhp->attr.pbl_size << 3);
 	if (mhp->kva)
 		kfree((void *) (unsigned long) mhp->kva);
-	if (mhp->umem)
-		ib_umem_release(mhp->umem);
+	ib_umem_release(mhp->umem);
 	pr_debug("mmid 0x%x ptr %p\n", mmid, mhp);
 	c4iw_put_wr_wait(mhp->wr_waitp);
 	kfree(mhp);
diff --git a/drivers/infiniband/hw/efa/efa_verbs.c b/drivers/infiniband/hw/efa/efa_verbs.c
index 2187063e7c29..984afc9367ca 100644
--- a/drivers/infiniband/hw/efa/efa_verbs.c
+++ b/drivers/infiniband/hw/efa/efa_verbs.c
@@ -1503,8 +1503,8 @@ int efa_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata)
 		err = efa_com_dereg_mr(&dev->edev, &params);
 		if (err)
 			return err;
-		ib_umem_release(mr->umem);
 	}
+	ib_umem_release(mr->umem);
 
 	kfree(mr);
 
* Unmerged path drivers/infiniband/hw/hns/hns_roce_cq.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v1.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v2.c
diff --git a/drivers/infiniband/hw/hns/hns_roce_mr.c b/drivers/infiniband/hw/hns/hns_roce_mr.c
index d066659b382b..6f335d3d4618 100644
--- a/drivers/infiniband/hw/hns/hns_roce_mr.c
+++ b/drivers/infiniband/hw/hns/hns_roce_mr.c
@@ -1193,9 +1193,7 @@ int hns_roce_dereg_mr(struct ib_mr *ibmr)
 	} else {
 		hns_roce_mr_free(hr_dev, mr);
 
-		if (mr->umem)
-			ib_umem_release(mr->umem);
-
+		ib_umem_release(mr->umem);
 		kfree(mr);
 	}
 
* Unmerged path drivers/infiniband/hw/hns/hns_roce_qp.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_srq.c
diff --git a/drivers/infiniband/hw/i40iw/i40iw_verbs.c b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
index fab854e906ed..ee4cd7adb7f3 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_verbs.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
@@ -2046,8 +2046,7 @@ static int i40iw_dereg_mr(struct ib_mr *ib_mr)
 	struct cqp_commands_info *cqp_info;
 	u32 stag_idx;
 
-	if (iwmr->region)
-		ib_umem_release(iwmr->region);
+	ib_umem_release(iwmr->region);
 
 	if (iwmr->type != IW_MEMREG_TYPE_MEM) {
 		/* region is released. only test for userness. */
* Unmerged path drivers/infiniband/hw/mlx4/cq.c
diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c
index 971e9a9ebdaf..b8ae425dae17 100644
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -1201,10 +1201,9 @@ static int create_qp_common(struct mlx4_ib_dev *dev, struct ib_pd *pd,
 	mlx4_mtt_cleanup(dev->dev, &qp->mtt);
 
 err_buf:
-	if (qp->umem)
-		ib_umem_release(qp->umem);
-	else
+	if (!qp->umem)
 		mlx4_buf_free(dev->dev, qp->buf_size, &qp->buf);
+	ib_umem_release(qp->umem);
 
 err_db:
 	if (!udata && qp_has_rq(init_attr))
@@ -1407,7 +1406,6 @@ static void destroy_qp_common(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp,
 				to_mucontext(qp->ibwq.uobject->context);
 			mlx4_ib_db_unmap_user(mcontext, &qp->db);
 		}
-		ib_umem_release(qp->umem);
 	} else {
 		kvfree(qp->sq.wrid);
 		kvfree(qp->rq.wrid);
@@ -1418,6 +1416,7 @@ static void destroy_qp_common(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp,
 		if (qp->rq.wqe_cnt)
 			mlx4_db_free(dev->dev, &qp->db);
 	}
+	ib_umem_release(qp->umem);
 
 	del_gid_entries(qp);
 }
* Unmerged path drivers/infiniband/hw/mlx4/srq.c
diff --git a/drivers/infiniband/hw/mlx5/cq.c b/drivers/infiniband/hw/mlx5/cq.c
index 6bfa574fa013..526b14d34f1c 100644
--- a/drivers/infiniband/hw/mlx5/cq.c
+++ b/drivers/infiniband/hw/mlx5/cq.c
@@ -1141,11 +1141,6 @@ static int resize_user(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,
 	return 0;
 }
 
-static void un_resize_user(struct mlx5_ib_cq *cq)
-{
-	ib_umem_release(cq->resize_umem);
-}
-
 static int resize_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,
 			 int entries, int cqe_size)
 {
@@ -1168,12 +1163,6 @@ static int resize_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,
 	return err;
 }
 
-static void un_resize_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq)
-{
-	free_cq_buf(dev, cq->resize_buf);
-	cq->resize_buf = NULL;
-}
-
 static int copy_resize_cqes(struct mlx5_ib_cq *cq)
 {
 	struct mlx5_ib_dev *dev = to_mdev(cq->ibcq.device);
@@ -1354,10 +1343,11 @@ int mlx5_ib_resize_cq(struct ib_cq *ibcq, int entries, struct ib_udata *udata)
 	kvfree(in);
 
 ex_resize:
-	if (udata)
-		un_resize_user(cq);
-	else
-		un_resize_kernel(dev, cq);
+	ib_umem_release(cq->resize_umem);
+	if (!udata) {
+		free_cq_buf(dev, cq->resize_buf);
+		cq->resize_buf = NULL;
+	}
 ex:
 	mutex_unlock(&cq->resize_mutex);
 	return err;
diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c
index 117463d43c3b..01310c9e5910 100644
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@ -1526,10 +1526,9 @@ int mlx5_ib_rereg_user_mr(struct ib_mr *ib_mr, int flags, u64 start,
 	return 0;
 
 err:
-	if (mr->umem) {
-		ib_umem_release(mr->umem);
-		mr->umem = NULL;
-	}
+	ib_umem_release(mr->umem);
+	mr->umem = NULL;
+
 	clean_mr(dev, mr);
 	return err;
 }
@@ -1648,10 +1647,10 @@ static void dereg_mr(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr)
 	 * remove the DMA mapping.
 	 */
 	mlx5_mr_cache_free(dev, mr);
-	if (umem) {
-		ib_umem_release(umem);
+	ib_umem_release(umem);
+	if (umem)
 		atomic_sub(npages, &dev->mdev->priv.reg_pages);
-	}
+
 	if (!mr->allocated_from_cache)
 		kfree(mr);
 }
diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c
index 7927d666efe8..d4815c5cb935 100644
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@ -690,8 +690,7 @@ static void destroy_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 
 	context = to_mucontext(pd->uobject->context);
 	mlx5_ib_db_unmap_user(context, &rwq->db);
-	if (rwq->umem)
-		ib_umem_release(rwq->umem);
+	ib_umem_release(rwq->umem);
 }
 
 static int create_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,
@@ -878,8 +877,7 @@ static int create_user_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 	kvfree(*in);
 
 err_umem:
-	if (ubuffer->umem)
-		ib_umem_release(ubuffer->umem);
+	ib_umem_release(ubuffer->umem);
 
 err_bfreg:
 	if (bfregn != MLX5_IB_INVALID_BFREG)
@@ -894,8 +892,7 @@ static void destroy_qp_user(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 
 	context = to_mucontext(pd->uobject->context);
 	mlx5_ib_db_unmap_user(context, &qp->db);
-	if (base->ubuffer.umem)
-		ib_umem_release(base->ubuffer.umem);
+	ib_umem_release(base->ubuffer.umem);
 
 	/*
 	 * Free only the BFREGs which are handled by the kernel.
diff --git a/drivers/infiniband/hw/mthca/mthca_provider.c b/drivers/infiniband/hw/mthca/mthca_provider.c
index f4ce72da939d..0070109c491d 100644
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@ -1003,8 +1003,7 @@ static int mthca_dereg_mr(struct ib_mr *mr)
 	struct mthca_mr *mmr = to_mmr(mr);
 
 	mthca_free_mr(to_mdev(mr->device), mmr);
-	if (mmr->umem)
-		ib_umem_release(mmr->umem);
+	ib_umem_release(mmr->umem);
 	kfree(mmr);
 
 	return 0;
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index 9c19475e0282..c728fe13f586 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@ -939,8 +939,7 @@ int ocrdma_dereg_mr(struct ib_mr *ib_mr)
 	ocrdma_free_mr_pbl_tbl(dev, &mr->hwmr);
 
 	/* it could be user registered memory. */
-	if (mr->umem)
-		ib_umem_release(mr->umem);
+	ib_umem_release(mr->umem);
 	kfree(mr);
 
 	/* Don't stop cleanup, in case FW is unresponsive */
diff --git a/drivers/infiniband/hw/qedr/verbs.c b/drivers/infiniband/hw/qedr/verbs.c
index 26243f439c76..23adbf074573 100644
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@ -1636,12 +1636,10 @@ qedr_iwarp_populate_user_qp(struct qedr_dev *dev,
 
 static void qedr_cleanup_user(struct qedr_dev *dev, struct qedr_qp *qp)
 {
-	if (qp->usq.umem)
-		ib_umem_release(qp->usq.umem);
+	ib_umem_release(qp->usq.umem);
 	qp->usq.umem = NULL;
 
-	if (qp->urq.umem)
-		ib_umem_release(qp->urq.umem);
+	ib_umem_release(qp->urq.umem);
 	qp->urq.umem = NULL;
 }
 
@@ -2751,8 +2749,7 @@ int qedr_dereg_mr(struct ib_mr *ib_mr)
 		qedr_free_pbl(dev, &mr->info.pbl_info, mr->info.pbl_table);
 
 	/* it could be user registered memory. */
-	if (mr->umem)
-		ib_umem_release(mr->umem);
+	ib_umem_release(mr->umem);
 
 	kfree(mr);
 
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c
index 0f004c737620..7adbaba6ea83 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_cq.c
@@ -220,8 +220,7 @@ struct ib_cq *pvrdma_create_cq(struct ib_device *ibdev,
 err_page_dir:
 	pvrdma_page_dir_cleanup(dev, &cq->pdir);
 err_umem:
-	if (!cq->is_kernel)
-		ib_umem_release(cq->umem);
+	ib_umem_release(cq->umem);
 err_cq:
 	atomic_dec(&dev->num_cqs);
 	kfree(cq);
@@ -235,8 +234,7 @@ static void pvrdma_free_cq(struct pvrdma_dev *dev, struct pvrdma_cq *cq)
 		complete(&cq->free);
 	wait_for_completion(&cq->free);
 
-	if (!cq->is_kernel)
-		ib_umem_release(cq->umem);
+	ib_umem_release(cq->umem);
 
 	pvrdma_page_dir_cleanup(dev, &cq->pdir);
 	kfree(cq);
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_mr.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_mr.c
index ee51525240da..969db4faa7d1 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_mr.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_mr.c
@@ -291,8 +291,7 @@ int pvrdma_dereg_mr(struct ib_mr *ibmr)
 			 "could not deregister mem region, error: %d\n", ret);
 
 	pvrdma_page_dir_cleanup(dev, &mr->pdir);
-	if (mr->umem)
-		ib_umem_release(mr->umem);
+	ib_umem_release(mr->umem);
 
 	kfree(mr->pages);
 	kfree(mr);
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
index 1ec3646087ba..a46c742fed0c 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_qp.c
@@ -393,12 +393,8 @@ struct ib_qp *pvrdma_create_qp(struct ib_pd *pd,
 err_pdir:
 	pvrdma_page_dir_cleanup(dev, &qp->pdir);
 err_umem:
-	if (!qp->is_kernel) {
-		if (qp->rumem)
-			ib_umem_release(qp->rumem);
-		if (qp->sumem)
-			ib_umem_release(qp->sumem);
-	}
+	ib_umem_release(qp->rumem);
+	ib_umem_release(qp->sumem);
 err_qp:
 	kfree(qp);
 	atomic_dec(&dev->num_qps);
@@ -431,12 +427,8 @@ static void pvrdma_free_qp(struct pvrdma_qp *qp)
 		complete(&qp->free);
 	wait_for_completion(&qp->free);
 
-	if (!qp->is_kernel) {
-		if (qp->rumem)
-			ib_umem_release(qp->rumem);
-		if (qp->sumem)
-			ib_umem_release(qp->sumem);
-	}
+	ib_umem_release(qp->rumem);
+	ib_umem_release(qp->sumem);
 
 	pvrdma_page_dir_cleanup(dev, &qp->pdir);
 
diff --git a/drivers/infiniband/sw/rdmavt/mr.c b/drivers/infiniband/sw/rdmavt/mr.c
index e63e21783840..65ef3006cdc3 100644
--- a/drivers/infiniband/sw/rdmavt/mr.c
+++ b/drivers/infiniband/sw/rdmavt/mr.c
@@ -561,8 +561,7 @@ int rvt_dereg_mr(struct ib_mr *ibmr)
 	if (ret)
 		goto out;
 	rvt_deinit_mregion(&mr->mr);
-	if (mr->umem)
-		ib_umem_release(mr->umem);
+	ib_umem_release(mr->umem);
 	kfree(mr);
 out:
 	return ret;
diff --git a/drivers/infiniband/sw/rxe/rxe_mr.c b/drivers/infiniband/sw/rxe/rxe_mr.c
index f6c3008f2a07..3b4f7fac98ce 100644
--- a/drivers/infiniband/sw/rxe/rxe_mr.c
+++ b/drivers/infiniband/sw/rxe/rxe_mr.c
@@ -96,8 +96,7 @@ void rxe_mem_cleanup(struct rxe_pool_entry *arg)
 	struct rxe_mem *mem = container_of(arg, typeof(*mem), pelem);
 	int i;
 
-	if (mem->umem)
-		ib_umem_release(mem->umem);
+	ib_umem_release(mem->umem);
 
 	if (mem->map) {
 		for (i = 0; i < mem->num_map; i++)
