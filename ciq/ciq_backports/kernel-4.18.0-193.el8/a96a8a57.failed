HID: logitech-hidpp: HID: make const array consumer_rdesc_start static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [hid] logitech-hidpp: hid: make const array consumer_rdesc_start static (Benjamin Tissoires) [1740778]
Rebuild_FUZZ: 96.30%
commit-author Colin Ian King <colin.king@canonical.com>
commit a96a8a576bf5cc45534d0079d7006fc3fe25282b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/a96a8a57.failed

Don't populate the array consumer_rdesc_start on the stack but instead
make it static. Makes the object code smaller by 88 bytes.

Before:
   text	   data	    bss	    dec	    hex	filename
  59155	   9840	    448	  69443	  10f43	drivers/hid/hid-logitech-hidpp.o

After:
   text	   data	    bss	    dec	    hex	filename
  59003	   9904	    448	  69355	  10eeb	drivers/hid/hid-logitech-hidpp.o

(gcc version 8.3.0, amd64)

	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit a96a8a576bf5cc45534d0079d7006fc3fe25282b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-logitech-hidpp.c
diff --cc drivers/hid/hid-logitech-hidpp.c
index 844711d5f9a8,df960491e473..000000000000
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@@ -2677,6 -2750,175 +2677,178 @@@ static int g920_get_config(struct hidpp
  }
  
  /* -------------------------------------------------------------------------- */
++<<<<<<< HEAD
++=======
+ /* HID++1.0 devices which use HID++ reports for their wheels                  */
+ /* -------------------------------------------------------------------------- */
+ static int hidpp10_wheel_connect(struct hidpp_device *hidpp)
+ {
+ 	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
+ 			HIDPP_ENABLE_WHEEL_REPORT | HIDPP_ENABLE_HWHEEL_REPORT,
+ 			HIDPP_ENABLE_WHEEL_REPORT | HIDPP_ENABLE_HWHEEL_REPORT);
+ }
+ 
+ static int hidpp10_wheel_raw_event(struct hidpp_device *hidpp,
+ 				   u8 *data, int size)
+ {
+ 	s8 value, hvalue;
+ 
+ 	if (!hidpp->input)
+ 		return -EINVAL;
+ 
+ 	if (size < 7)
+ 		return 0;
+ 
+ 	if (data[0] != REPORT_ID_HIDPP_SHORT || data[2] != HIDPP_SUB_ID_ROLLER)
+ 		return 0;
+ 
+ 	value = data[3];
+ 	hvalue = data[4];
+ 
+ 	input_report_rel(hidpp->input, REL_WHEEL, value);
+ 	input_report_rel(hidpp->input, REL_WHEEL_HI_RES, value * 120);
+ 	input_report_rel(hidpp->input, REL_HWHEEL, hvalue);
+ 	input_report_rel(hidpp->input, REL_HWHEEL_HI_RES, hvalue * 120);
+ 	input_sync(hidpp->input);
+ 
+ 	return 1;
+ }
+ 
+ static void hidpp10_wheel_populate_input(struct hidpp_device *hidpp,
+ 					 struct input_dev *input_dev)
+ {
+ 	__set_bit(EV_REL, input_dev->evbit);
+ 	__set_bit(REL_WHEEL, input_dev->relbit);
+ 	__set_bit(REL_WHEEL_HI_RES, input_dev->relbit);
+ 	__set_bit(REL_HWHEEL, input_dev->relbit);
+ 	__set_bit(REL_HWHEEL_HI_RES, input_dev->relbit);
+ }
+ 
+ /* -------------------------------------------------------------------------- */
+ /* HID++1.0 mice which use HID++ reports for extra mouse buttons              */
+ /* -------------------------------------------------------------------------- */
+ static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
+ {
+ 	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
+ 				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
+ 				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
+ }
+ 
+ static int hidpp10_extra_mouse_buttons_raw_event(struct hidpp_device *hidpp,
+ 				    u8 *data, int size)
+ {
+ 	int i;
+ 
+ 	if (!hidpp->input)
+ 		return -EINVAL;
+ 
+ 	if (size < 7)
+ 		return 0;
+ 
+ 	if (data[0] != REPORT_ID_HIDPP_SHORT ||
+ 	    data[2] != HIDPP_SUB_ID_MOUSE_EXTRA_BTNS)
+ 		return 0;
+ 
+ 	/*
+ 	 * Buttons are either delivered through the regular mouse report *or*
+ 	 * through the extra buttons report. At least for button 6 how it is
+ 	 * delivered differs per receiver firmware version. Even receivers with
+ 	 * the same usb-id show different behavior, so we handle both cases.
+ 	 */
+ 	for (i = 0; i < 8; i++)
+ 		input_report_key(hidpp->input, BTN_MOUSE + i,
+ 				 (data[3] & (1 << i)));
+ 
+ 	/* Some mice report events on button 9+, use BTN_MISC */
+ 	for (i = 0; i < 8; i++)
+ 		input_report_key(hidpp->input, BTN_MISC + i,
+ 				 (data[4] & (1 << i)));
+ 
+ 	input_sync(hidpp->input);
+ 	return 1;
+ }
+ 
+ static void hidpp10_extra_mouse_buttons_populate_input(
+ 			struct hidpp_device *hidpp, struct input_dev *input_dev)
+ {
+ 	/* BTN_MOUSE - BTN_MOUSE+7 are set already by the descriptor */
+ 	__set_bit(BTN_0, input_dev->keybit);
+ 	__set_bit(BTN_1, input_dev->keybit);
+ 	__set_bit(BTN_2, input_dev->keybit);
+ 	__set_bit(BTN_3, input_dev->keybit);
+ 	__set_bit(BTN_4, input_dev->keybit);
+ 	__set_bit(BTN_5, input_dev->keybit);
+ 	__set_bit(BTN_6, input_dev->keybit);
+ 	__set_bit(BTN_7, input_dev->keybit);
+ }
+ 
+ /* -------------------------------------------------------------------------- */
+ /* HID++1.0 kbds which only report 0x10xx consumer usages through sub-id 0x03 */
+ /* -------------------------------------------------------------------------- */
+ 
+ /* Find the consumer-page input report desc and change Maximums to 0x107f */
+ static u8 *hidpp10_consumer_keys_report_fixup(struct hidpp_device *hidpp,
+ 					      u8 *_rdesc, unsigned int *rsize)
+ {
+ 	/* Note 0 terminated so we can use strnstr to search for this. */
+ 	static const char consumer_rdesc_start[] = {
+ 		0x05, 0x0C,	/* USAGE_PAGE (Consumer Devices)       */
+ 		0x09, 0x01,	/* USAGE (Consumer Control)            */
+ 		0xA1, 0x01,	/* COLLECTION (Application)            */
+ 		0x85, 0x03,	/* REPORT_ID = 3                       */
+ 		0x75, 0x10,	/* REPORT_SIZE (16)                    */
+ 		0x95, 0x02,	/* REPORT_COUNT (2)                    */
+ 		0x15, 0x01,	/* LOGICAL_MIN (1)                     */
+ 		0x26, 0x00	/* LOGICAL_MAX (...                    */
+ 	};
+ 	char *consumer_rdesc, *rdesc = (char *)_rdesc;
+ 	unsigned int size;
+ 
+ 	consumer_rdesc = strnstr(rdesc, consumer_rdesc_start, *rsize);
+ 	size = *rsize - (consumer_rdesc - rdesc);
+ 	if (consumer_rdesc && size >= 25) {
+ 		consumer_rdesc[15] = 0x7f;
+ 		consumer_rdesc[16] = 0x10;
+ 		consumer_rdesc[20] = 0x7f;
+ 		consumer_rdesc[21] = 0x10;
+ 	}
+ 	return _rdesc;
+ }
+ 
+ static int hidpp10_consumer_keys_connect(struct hidpp_device *hidpp)
+ {
+ 	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
+ 				    HIDPP_ENABLE_CONSUMER_REPORT,
+ 				    HIDPP_ENABLE_CONSUMER_REPORT);
+ }
+ 
+ static int hidpp10_consumer_keys_raw_event(struct hidpp_device *hidpp,
+ 					   u8 *data, int size)
+ {
+ 	u8 consumer_report[5];
+ 
+ 	if (size < 7)
+ 		return 0;
+ 
+ 	if (data[0] != REPORT_ID_HIDPP_SHORT ||
+ 	    data[2] != HIDPP_SUB_ID_CONSUMER_VENDOR_KEYS)
+ 		return 0;
+ 
+ 	/*
+ 	 * Build a normal consumer report (3) out of the data, this detour
+ 	 * is necessary to get some keyboards to report their 0x10xx usages.
+ 	 */
+ 	consumer_report[0] = 0x03;
+ 	memcpy(&consumer_report[1], &data[3], 4);
+ 	/* We are called from atomic context */
+ 	hid_report_raw_event(hidpp->hid_dev, HID_INPUT_REPORT,
+ 			     consumer_report, 5, 1);
+ 
+ 	return 1;
+ }
+ 
+ /* -------------------------------------------------------------------------- */
++>>>>>>> a96a8a576bf5 (HID: logitech-hidpp: HID: make const array consumer_rdesc_start static)
  /* High-resolution scroll wheels                                              */
  /* -------------------------------------------------------------------------- */
  
* Unmerged path drivers/hid/hid-logitech-hidpp.c
