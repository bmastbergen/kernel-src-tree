arm64: debug: Don't propagate UNKNOWN FAR into si_code for debug signals

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Will Deacon <will.deacon@arm.com>
commit b9a4b9d084d978f80eb9210727c81804588b42ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b9a4b9d0.failed

FAR_EL1 is UNKNOWN for all debug exceptions other than those caused by
taking a hardware watchpoint. Unfortunately, if a debug handler returns
a non-zero value, then we will propagate the UNKNOWN FAR value to
userspace via the si_addr field of the SIGTRAP siginfo_t.

Instead, let's set si_addr to take on the PC of the faulting instruction,
which we have available in the current pt_regs.

	Cc: <stable@vger.kernel.org>
	Reviewed-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit b9a4b9d084d978f80eb9210727c81804588b42ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/fault.c
diff --cc arch/arm64/mm/fault.c
index cda34ebb74ca,ef46925096f0..000000000000
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@@ -824,10 -839,10 +825,14 @@@ asmlinkage int __exception do_debug_exc
  	if (interrupts_enabled(regs))
  		trace_hardirqs_off();
  
++<<<<<<< HEAD
 +	if (user_mode(regs) && instruction_pointer(regs) > TASK_SIZE)
++=======
+ 	if (user_mode(regs) && !is_ttbr0_addr(pc))
++>>>>>>> b9a4b9d084d9 (arm64: debug: Don't propagate UNKNOWN FAR into si_code for debug signals)
  		arm64_apply_bp_hardening();
  
- 	if (!inf->fn(addr, esr, regs)) {
+ 	if (!inf->fn(addr_if_watchpoint, esr, regs)) {
  		rv = 1;
  	} else {
  		arm64_notify_die(inf->name, regs,
* Unmerged path arch/arm64/mm/fault.c
