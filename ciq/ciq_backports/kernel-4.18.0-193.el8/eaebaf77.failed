IB/mlx5: Implement DEVX hot unplug for async command FD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit eaebaf77e7cb22fc371b7843370c903f1dd0fc3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/eaebaf77.failed

Implement DEVX hot unplug for the async command FD.

This is done by managing a list of the inflight commands and wait until
all launched work is completed as part of
devx_hot_unplug_async_cmd_event_file.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit eaebaf77e7cb22fc371b7843370c903f1dd0fc3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/mlx5/devx.c
index 0f2c729c8d42,84ef296857ef..000000000000
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@@ -1310,6 -1183,8 +1310,11 @@@ struct devx_async_event_queue 
  	spinlock_t		lock;
  	wait_queue_head_t	poll_wait;
  	struct list_head	event_list;
++<<<<<<< HEAD
++=======
+ 	atomic_t		bytes_in_use;
+ 	u8			is_destroyed:1;
++>>>>>>> eaebaf77e7cb (IB/mlx5: Implement DEVX hot unplug for async command FD)
  };
  
  struct devx_async_cmd_event_file {
@@@ -1322,6 -1198,8 +1327,11 @@@ static void devx_init_event_queue(struc
  	spin_lock_init(&ev_queue->lock);
  	INIT_LIST_HEAD(&ev_queue->event_list);
  	init_waitqueue_head(&ev_queue->poll_wait);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ev_queue->bytes_in_use, 0);
+ 	ev_queue->is_destroyed = 0;
++>>>>>>> eaebaf77e7cb (IB/mlx5: Implement DEVX hot unplug for async command FD)
  }
  
  static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_ASYNC_CMD_FD_ALLOC)(
@@@ -1565,6 -1572,19 +1583,22 @@@ const struct file_operations devx_async
  static int devx_hot_unplug_async_cmd_event_file(struct ib_uobject *uobj,
  						   enum rdma_remove_reason why)
  {
++<<<<<<< HEAD
++=======
+ 	struct devx_async_cmd_event_file *comp_ev_file =
+ 		container_of(uobj, struct devx_async_cmd_event_file,
+ 			     uobj);
+ 	struct devx_async_event_queue *ev_queue = &comp_ev_file->ev_queue;
+ 
+ 	spin_lock_irq(&ev_queue->lock);
+ 	ev_queue->is_destroyed = 1;
+ 	spin_unlock_irq(&ev_queue->lock);
+ 
+ 	if (why == RDMA_REMOVE_DRIVER_REMOVE)
+ 		wake_up_interruptible(&ev_queue->poll_wait);
+ 
+ 	mlx5_cmd_cleanup_async_ctx(&comp_ev_file->async_ctx);
++>>>>>>> eaebaf77e7cb (IB/mlx5: Implement DEVX hot unplug for async command FD)
  	return 0;
  };
  
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
