x86: tsc: Rework time_cpufreq_notifier()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [x86] tsc: Rework time_cpufreq_notifier() (Al Stone) [1739729 1725581]
Rebuild_FUZZ: 93.33%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit c208ac8f8f862dba7b01eb54557f4803b3c17296
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c208ac8f.failed

There are problems with running time_cpufreq_notifier() on SMP
systems.

First off, the rdtsc() called from there runs on the CPU executing
that code and not necessarily on the CPU whose sched_clock() rate is
updated which is questionable at best.

Second, in the cases when the frequencies of all CPUs in an SMP
system are always in sync, it is not sufficient to update just
one of them or the set associated with a given cpufreq policy on
frequency changes - all CPUs in the system should be updated and
that would require more than a simple transition notifier.

Note, however, that the underlying issue (the TSC rate depending on
the CPU frequency) has not been present in hardware shipping for the
last few years and in quite a few relevant cases (acpi-cpufreq in
particular) running time_cpufreq_notifier() will cause the TSC to
be marked as unstable anyway.

For this reason, make time_cpufreq_notifier() simply mark the TSC
as unstable and give up when run on SMP and only try to carry out
any adjustments otherwise.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit c208ac8f8f862dba7b01eb54557f4803b3c17296)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/tsc.c
diff --cc arch/x86/kernel/tsc.c
index a568e394760e,cc6df5c6d7b3..000000000000
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@@ -186,6 -172,38 +186,41 @@@ done
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Initialize cyc2ns for boot cpu
+  */
+ static void __init cyc2ns_init_boot_cpu(void)
+ {
+ 	struct cyc2ns *c2n = this_cpu_ptr(&cyc2ns);
+ 
+ 	seqcount_init(&c2n->seq);
+ 	__set_cyc2ns_scale(tsc_khz, smp_processor_id(), rdtsc());
+ }
+ 
+ /*
+  * Secondary CPUs do not run through tsc_init(), so set up
+  * all the scale factors for all CPUs, assuming the same
+  * speed as the bootup CPU.
+  */
+ static void __init cyc2ns_init_secondary_cpus(void)
+ {
+ 	unsigned int cpu, this_cpu = smp_processor_id();
+ 	struct cyc2ns *c2n = this_cpu_ptr(&cyc2ns);
+ 	struct cyc2ns_data *data = c2n->data;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		if (cpu != this_cpu) {
+ 			seqcount_init(&c2n->seq);
+ 			c2n = per_cpu_ptr(&cyc2ns, cpu);
+ 			c2n->data[0] = data[0];
+ 			c2n->data[1] = data[1];
+ 		}
+ 	}
+ }
+ 
+ /*
++>>>>>>> c208ac8f8f86 (x86: tsc: Rework time_cpufreq_notifier())
   * Scheduler clock - returns current time in nanosec units.
   */
  u64 native_sched_clock(void)
* Unmerged path arch/x86/kernel/tsc.c
