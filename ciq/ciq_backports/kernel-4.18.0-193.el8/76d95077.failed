selftests/bpf: add verifier tests for wide stores

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 76d950773cd2a365f492ce973429ae629d58131c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/76d95077.failed

Make sure that wide stores are allowed at proper (aligned) addresses.
Note that user_ip6 is naturally aligned on 8-byte boundary, so
correct addresses are user_ip6[0] and user_ip6[2]. msg_src_ip6 is,
however, aligned on a 4-byte bondary, so only msg_src_ip6[1]
can be wide-stored.

	Cc: Andrii Nakryiko <andriin@fb.com>
	Cc: Yonghong Song <yhs@fb.com>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Acked-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 76d950773cd2a365f492ce973429ae629d58131c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_verifier.c
diff --cc tools/testing/selftests/bpf/test_verifier.c
index 96071fae318d,b0773291012a..000000000000
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@@ -17110,8 -883,17 +17112,22 @@@ static void do_test_single(struct bpf_t
  		pflags |= BPF_F_STRICT_ALIGNMENT;
  	if (test->flags & F_NEEDS_EFFICIENT_UNALIGNED_ACCESS)
  		pflags |= BPF_F_ANY_ALIGNMENT;
++<<<<<<< HEAD
 +	fd_prog = bpf_verify_program(prog_type, prog, prog_len, pflags,
 +				     "GPL", 0, bpf_vlog, sizeof(bpf_vlog), 1);
++=======
+ 
+ 	memset(&attr, 0, sizeof(attr));
+ 	attr.prog_type = prog_type;
+ 	attr.expected_attach_type = test->expected_attach_type;
+ 	attr.insns = prog;
+ 	attr.insns_cnt = prog_len;
+ 	attr.license = "GPL";
+ 	attr.log_level = 4;
+ 	attr.prog_flags = pflags;
+ 
+ 	fd_prog = bpf_load_program_xattr(&attr, bpf_vlog, sizeof(bpf_vlog));
++>>>>>>> 76d950773cd2 (selftests/bpf: add verifier tests for wide stores)
  	if (fd_prog < 0 && !bpf_probe_prog_type(prog_type, 0)) {
  		printf("SKIP (unsupported program type %d)\n", prog_type);
  		skips++;
* Unmerged path tools/testing/selftests/bpf/test_verifier.c
diff --git a/tools/testing/selftests/bpf/verifier/wide_store.c b/tools/testing/selftests/bpf/verifier/wide_store.c
new file mode 100644
index 000000000000..8fe99602ded4
--- /dev/null
+++ b/tools/testing/selftests/bpf/verifier/wide_store.c
@@ -0,0 +1,36 @@
+#define BPF_SOCK_ADDR(field, off, res, err) \
+{ \
+	"wide store to bpf_sock_addr." #field "[" #off "]", \
+	.insns = { \
+	BPF_MOV64_IMM(BPF_REG_0, 1), \
+	BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, \
+		    offsetof(struct bpf_sock_addr, field[off])), \
+	BPF_EXIT_INSN(), \
+	}, \
+	.result = res, \
+	.prog_type = BPF_PROG_TYPE_CGROUP_SOCK_ADDR, \
+	.expected_attach_type = BPF_CGROUP_UDP6_SENDMSG, \
+	.errstr = err, \
+}
+
+/* user_ip6[0] is u64 aligned */
+BPF_SOCK_ADDR(user_ip6, 0, ACCEPT,
+	      NULL),
+BPF_SOCK_ADDR(user_ip6, 1, REJECT,
+	      "invalid bpf_context access off=12 size=8"),
+BPF_SOCK_ADDR(user_ip6, 2, ACCEPT,
+	      NULL),
+BPF_SOCK_ADDR(user_ip6, 3, REJECT,
+	      "invalid bpf_context access off=20 size=8"),
+
+/* msg_src_ip6[0] is _not_ u64 aligned */
+BPF_SOCK_ADDR(msg_src_ip6, 0, REJECT,
+	      "invalid bpf_context access off=44 size=8"),
+BPF_SOCK_ADDR(msg_src_ip6, 1, ACCEPT,
+	      NULL),
+BPF_SOCK_ADDR(msg_src_ip6, 2, REJECT,
+	      "invalid bpf_context access off=52 size=8"),
+BPF_SOCK_ADDR(msg_src_ip6, 3, REJECT,
+	      "invalid bpf_context access off=56 size=8"),
+
+#undef BPF_SOCK_ADDR
