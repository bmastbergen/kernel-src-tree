ALSA: fireface: share PCM buffer size for both direction

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 4de3eb062e2daf04646d23417a39b8843df4508b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4de3eb06.failed

This commit allows ALSA fireface driver to share PCM buffer size for
both capture and playback PCM substream. When AMDTP domain starts for
one of the PCM substream, buffer size of the PCM substream is stores to
AMDTP domain structure. Some AMDTP streams have already run with the
buffer size when another PCM substream starts, therefore the PCM
substream has a constraint to its buffer size.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Link: https://lore.kernel.org/r/20191017155424.885-10-o-takashi@sakamocchi.jp
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 4de3eb062e2daf04646d23417a39b8843df4508b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/fireface/ff-stream.c
diff --cc sound/firewire/fireface/ff-stream.c
index d05e7d3055e1,a13754f914e8..000000000000
--- a/sound/firewire/fireface/ff-stream.c
+++ b/sound/firewire/fireface/ff-stream.c
@@@ -153,7 -154,7 +154,11 @@@ int snd_ff_stream_reserve_duplex(struc
  			return err;
  
  		err = amdtp_domain_set_events_per_period(&ff->domain,
++<<<<<<< HEAD
 +							 frames_per_period);
++=======
+ 					frames_per_period, frames_per_buffer);
++>>>>>>> 4de3eb062e2d (ALSA: fireface: share PCM buffer size for both direction)
  		if (err < 0) {
  			fw_iso_resources_free(&ff->tx_resources);
  			fw_iso_resources_free(&ff->rx_resources);
diff --git a/sound/firewire/fireface/ff-pcm.c b/sound/firewire/fireface/ff-pcm.c
index 415bc9ccd1c7..005d959f8651 100644
--- a/sound/firewire/fireface/ff-pcm.c
+++ b/sound/firewire/fireface/ff-pcm.c
@@ -180,6 +180,7 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	} else {
 		if (ff->substreams_counter > 0) {
 			unsigned int frames_per_period = d->events_per_period;
+			unsigned int frames_per_buffer = d->events_per_buffer;
 
 			rate = amdtp_rate_table[ff->rx_stream.sfc];
 			substream->runtime->hw.rate_min = rate;
@@ -192,6 +193,14 @@ static int pcm_open(struct snd_pcm_substream *substream)
 				mutex_unlock(&ff->mutex);
 				goto release_lock;
 			}
+
+			err = snd_pcm_hw_constraint_minmax(substream->runtime,
+					SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+					frames_per_buffer, frames_per_buffer);
+			if (err < 0) {
+				mutex_unlock(&ff->mutex);
+				goto release_lock;
+			}
 		}
 	}
 
@@ -229,9 +238,11 @@ static int pcm_hw_params(struct snd_pcm_substream *substream,
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		unsigned int rate = params_rate(hw_params);
 		unsigned int frames_per_period = params_period_size(hw_params);
+		unsigned int frames_per_buffer = params_buffer_size(hw_params);
 
 		mutex_lock(&ff->mutex);
-		err = snd_ff_stream_reserve_duplex(ff, rate, frames_per_period);
+		err = snd_ff_stream_reserve_duplex(ff, rate, frames_per_period,
+						   frames_per_buffer);
 		if (err >= 0)
 			++ff->substreams_counter;
 		mutex_unlock(&ff->mutex);
* Unmerged path sound/firewire/fireface/ff-stream.c
diff --git a/sound/firewire/fireface/ff.h b/sound/firewire/fireface/ff.h
index 970d4ae571ee..dc7a20f75983 100644
--- a/sound/firewire/fireface/ff.h
+++ b/sound/firewire/fireface/ff.h
@@ -140,7 +140,8 @@ int snd_ff_stream_get_multiplier_mode(enum cip_sfc sfc,
 int snd_ff_stream_init_duplex(struct snd_ff *ff);
 void snd_ff_stream_destroy_duplex(struct snd_ff *ff);
 int snd_ff_stream_reserve_duplex(struct snd_ff *ff, unsigned int rate,
-				 unsigned int frames_per_period);
+				 unsigned int frames_per_period,
+				 unsigned int frames_per_buffer);
 int snd_ff_stream_start_duplex(struct snd_ff *ff, unsigned int rate);
 void snd_ff_stream_stop_duplex(struct snd_ff *ff);
 void snd_ff_stream_update_duplex(struct snd_ff *ff);
