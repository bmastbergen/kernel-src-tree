tcp: add dsack blocks received stats

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Wei Wang <weiwan@google.com>
commit 7e10b6554ff2ce7f86d5d3eec3af5db8db482caa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7e10b655.failed

Introduce a new TCP stat to record the number of DSACK blocks received
(RFC4989 tcpEStatsStackDSACKDups) and expose it in both tcp_info
(TCP_INFO) and opt_stats (SOF_TIMESTAMPING_OPT_STATS).

	Signed-off-by: Wei Wang <weiwan@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7e10b6554ff2ce7f86d5d3eec3af5db8db482caa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/tcp.h
#	net/ipv4/tcp.c
diff --cc include/uapi/linux/tcp.h
index e3f6ed8a7064,0e1c0aec0153..000000000000
--- a/include/uapi/linux/tcp.h
+++ b/include/uapi/linux/tcp.h
@@@ -235,6 -235,10 +235,13 @@@ struct tcp_info 
  
  	__u32	tcpi_delivered;
  	__u32	tcpi_delivered_ce;
++<<<<<<< HEAD
++=======
+ 
+ 	__u64	tcpi_bytes_sent;     /* RFC4898 tcpEStatsPerfHCDataOctetsOut */
+ 	__u64	tcpi_bytes_retrans;  /* RFC4898 tcpEStatsPerfOctetsRetrans */
+ 	__u32	tcpi_dsack_dups;     /* RFC4898 tcpEStatsStackDSACKDups */
++>>>>>>> 7e10b6554ff2 (tcp: add dsack blocks received stats)
  };
  
  /* netlink attributes types for SCM_TIMESTAMPING_OPT_STATS */
@@@ -257,7 -261,9 +264,13 @@@ enum 
  	TCP_NLA_SND_SSTHRESH,	/* Slow start size threshold */
  	TCP_NLA_DELIVERED,	/* Data pkts delivered incl. out-of-order */
  	TCP_NLA_DELIVERED_CE,	/* Like above but only ones w/ CE marks */
++<<<<<<< HEAD
 +
++=======
+ 	TCP_NLA_BYTES_SENT,	/* Data bytes sent including retransmission */
+ 	TCP_NLA_BYTES_RETRANS,	/* Data bytes retransmitted */
+ 	TCP_NLA_DSACK_DUPS,	/* DSACK blocks received */
++>>>>>>> 7e10b6554ff2 (tcp: add dsack blocks received stats)
  };
  
  /* for TCP_MD5SIG socket option */
diff --cc net/ipv4/tcp.c
index 6da266d09f97,d6232b598cae..000000000000
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@@ -2611,8 -2594,9 +2611,14 @@@ int tcp_disconnect(struct sock *sk, in
  	sk->sk_rx_dst = NULL;
  	tcp_saved_syn_free(tp);
  	tp->compressed_ack = 0;
++<<<<<<< HEAD
 +	tp->bytes_acked = 0;
 +	tp->bytes_received = 0;
++=======
+ 	tp->bytes_sent = 0;
+ 	tp->bytes_retrans = 0;
+ 	tp->dsack_dups = 0;
++>>>>>>> 7e10b6554ff2 (tcp: add dsack blocks received stats)
  
  	/* Clean up fastopen related fields */
  	tcp_free_fastopen_req(tp);
@@@ -3222,6 -3204,9 +3228,12 @@@ void tcp_get_info(struct sock *sk, stru
  		info->tcpi_delivery_rate = rate64;
  	info->tcpi_delivered = tp->delivered;
  	info->tcpi_delivered_ce = tp->delivered_ce;
++<<<<<<< HEAD
++=======
+ 	info->tcpi_bytes_sent = tp->bytes_sent;
+ 	info->tcpi_bytes_retrans = tp->bytes_retrans;
+ 	info->tcpi_dsack_dups = tp->dsack_dups;
++>>>>>>> 7e10b6554ff2 (tcp: add dsack blocks received stats)
  	unlock_sock_fast(sk, slow);
  }
  EXPORT_SYMBOL_GPL(tcp_get_info);
@@@ -3246,6 -3231,9 +3258,12 @@@ static size_t tcp_opt_stats_get_size(vo
  		nla_total_size(sizeof(u32)) + /* TCP_NLA_SND_SSTHRESH */
  		nla_total_size(sizeof(u32)) + /* TCP_NLA_DELIVERED */
  		nla_total_size(sizeof(u32)) + /* TCP_NLA_DELIVERED_CE */
++<<<<<<< HEAD
++=======
+ 		nla_total_size_64bit(sizeof(u64)) + /* TCP_NLA_BYTES_SENT */
+ 		nla_total_size_64bit(sizeof(u64)) + /* TCP_NLA_BYTES_RETRANS */
+ 		nla_total_size(sizeof(u32)) + /* TCP_NLA_DSACK_DUPS */
++>>>>>>> 7e10b6554ff2 (tcp: add dsack blocks received stats)
  		0;
  }
  
@@@ -3293,6 -3281,12 +3311,15 @@@ struct sk_buff *tcp_get_timestamping_op
  	nla_put_u32(stats, TCP_NLA_SNDQ_SIZE, tp->write_seq - tp->snd_una);
  	nla_put_u8(stats, TCP_NLA_CA_STATE, inet_csk(sk)->icsk_ca_state);
  
++<<<<<<< HEAD
++=======
+ 	nla_put_u64_64bit(stats, TCP_NLA_BYTES_SENT, tp->bytes_sent,
+ 			  TCP_NLA_PAD);
+ 	nla_put_u64_64bit(stats, TCP_NLA_BYTES_RETRANS, tp->bytes_retrans,
+ 			  TCP_NLA_PAD);
+ 	nla_put_u32(stats, TCP_NLA_DSACK_DUPS, tp->dsack_dups);
+ 
++>>>>>>> 7e10b6554ff2 (tcp: add dsack blocks received stats)
  	return stats;
  }
  
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index 8c66475339ed..8a31d9dc82ff 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -185,6 +185,9 @@ struct tcp_sock {
 				 * sum(delta(snd_una)), or how many bytes
 				 * were acked.
 				 */
+	u32	dsack_dups;	/* RFC4898 tcpEStatsStackDSACKDups
+				 * total number of DSACK blocks received
+				 */
  	u32	snd_una;	/* First byte we want an ack for	*/
  	u32	snd_sml;	/* Last byte of the most recently transmitted small packet */
 	u32	rcv_tstamp;	/* timestamp of last received ACK (for keepalives) */
* Unmerged path include/uapi/linux/tcp.h
* Unmerged path net/ipv4/tcp.c
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 50c5aa90e243..0daad4b90cab 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -878,6 +878,7 @@ static void tcp_dsack_seen(struct tcp_sock *tp)
 {
 	tp->rx_opt.sack_ok |= TCP_DSACK_SEEN;
 	tp->rack.dsack_seen = 1;
+	tp->dsack_dups++;
 }
 
 /* It's reordering when higher sequence was delivered (i.e. sacked) before
