net/mlx5: E-Switch, Fix the check of legal vport

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Fix the check of legal vport (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 95.65%
commit-author Bodong Wang <bodong@mellanox.com>
commit 5d9986a3947a08185c407442c9a5fc9546b9e440
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5d9986a3.failed

The check of legal vport is to ensure the vport number falls between
0 and total number of vports. Along with the introduction of uplink
rep, enabled vports are not consecutive any more.
Therefore, rely on the eswitch vport getter function to check if it's
a valid vport.

As the getter function relies on eswitch, add the check of vport
group manager and validation the presence of eswitch structure.
Remove the redundant check in the function calls.

Since the vport array will be allocated once eswitch is initialized
and will be kept alive if eswitch presents, no need to protect it with
the state lock.

Fixes: 5ae5162066d8 ("net/mlx5: E-Switch, Assign a different position for uplink rep and vport")
	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 5d9986a3947a08185c407442c9a5fc9546b9e440)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 881a0621eae0,9ea0ccfe5ef5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -73,6 -72,25 +73,28 @@@ static void esw_cleanup_vepa_rules(stru
  			    MC_ADDR_CHANGE | \
  			    PROMISC_CHANGE)
  
++<<<<<<< HEAD
++=======
+ struct mlx5_vport *__must_check
+ mlx5_eswitch_get_vport(struct mlx5_eswitch *esw, u16 vport_num)
+ {
+ 	u16 idx;
+ 
+ 	if (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager))
+ 		return ERR_PTR(-EPERM);
+ 
+ 	idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	if (idx > esw->total_vports - 1) {
+ 		esw_debug(esw->dev, "vport out of range: num(0x%x), idx(0x%x)\n",
+ 			  vport_num, idx);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	return &esw->vports[idx];
+ }
+ 
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  static int arm_vport_context_events_cmd(struct mlx5_core_dev *dev, u16 vport,
  					u32 events_mask)
  {
@@@ -1654,7 -1676,10 +1676,14 @@@ static int eswitch_vport_event(struct n
  	u16 vport_num;
  
  	vport_num = be16_to_cpu(eqe->data.vport_change.vport_num);
++<<<<<<< HEAD
 +	vport = &esw->vports[vport_num];
++=======
+ 	vport = mlx5_eswitch_get_vport(esw, vport_num);
+ 	if (IS_ERR(vport))
+ 		return NOTIFY_OK;
+ 
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  	if (vport->enabled)
  		queue_work(esw->work_queue, &vport->vport_change_handler);
  
@@@ -1879,7 -1927,6 +1906,10 @@@ int mlx5_eswitch_set_vport_mac(struct m
  		return -EINVAL;
  
  	mutex_lock(&esw->state_lock);
++<<<<<<< HEAD
 +	evport = &esw->vports[vport];
++=======
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  
  	if (evport->info.spoofchk && !is_valid_ether_addr(mac))
  		mlx5_core_warn(esw->dev,
@@@ -1919,11 -1966,10 +1949,14 @@@ int mlx5_eswitch_set_vport_state(struc
  
  	if (!ESW_ALLOWED(esw))
  		return -EPERM;
- 	if (!LEGAL_VPORT(esw, vport))
- 		return -EINVAL;
+ 	if (IS_ERR(evport))
+ 		return PTR_ERR(evport);
  
  	mutex_lock(&esw->state_lock);
++<<<<<<< HEAD
 +	evport = &esw->vports[vport];
++=======
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  
  	err = mlx5_modify_vport_admin_state(esw->dev,
  					    MLX5_VPORT_STATE_OP_MOD_ESW_VPORT,
@@@ -1945,14 -1991,10 +1978,19 @@@ unlock
  int mlx5_eswitch_get_vport_config(struct mlx5_eswitch *esw,
  				  int vport, struct ifla_vf_info *ivi)
  {
- 	struct mlx5_vport *evport;
+ 	struct mlx5_vport *evport = mlx5_eswitch_get_vport(esw, vport);
  
++<<<<<<< HEAD
 +	if (!esw || !MLX5_CAP_GEN(esw->dev, vport_group_manager))
 +		return -EPERM;
 +	if (!LEGAL_VPORT(esw, vport))
 +		return -EINVAL;
 +
 +	evport = &esw->vports[vport];
++=======
+ 	if (IS_ERR(evport))
+ 		return PTR_ERR(evport);
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  
  	memset(ivi, 0, sizeof(*ivi));
  	ivi->vf = vport - 1;
@@@ -1983,7 -2027,6 +2023,10 @@@ int __mlx5_eswitch_set_vport_vlan(struc
  		return -EINVAL;
  
  	mutex_lock(&esw->state_lock);
++<<<<<<< HEAD
 +	evport = &esw->vports[vport];
++=======
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  
  	err = modify_esw_vport_cvlan(esw->dev, vport, vlan, qos, set_flags);
  	if (err)
@@@ -2023,11 -2066,10 +2066,14 @@@ int mlx5_eswitch_set_vport_spoofchk(str
  
  	if (!ESW_ALLOWED(esw))
  		return -EPERM;
- 	if (!LEGAL_VPORT(esw, vport))
- 		return -EINVAL;
+ 	if (IS_ERR(evport))
+ 		return PTR_ERR(evport);
  
  	mutex_lock(&esw->state_lock);
++<<<<<<< HEAD
 +	evport = &esw->vports[vport];
++=======
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  	pschk = evport->info.spoofchk;
  	evport->info.spoofchk = spoofchk;
  	if (pschk && !is_valid_ether_addr(evport->info.mac))
@@@ -2172,11 -2214,10 +2218,14 @@@ int mlx5_eswitch_set_vport_trust(struc
  
  	if (!ESW_ALLOWED(esw))
  		return -EPERM;
- 	if (!LEGAL_VPORT(esw, vport))
- 		return -EINVAL;
+ 	if (IS_ERR(evport))
+ 		return PTR_ERR(evport);
  
  	mutex_lock(&esw->state_lock);
++<<<<<<< HEAD
 +	evport = &esw->vports[vport];
++=======
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  	evport->info.trusted = setting;
  	if (evport->enabled)
  		esw_vport_change_handle_locked(evport);
@@@ -2264,7 -2303,6 +2313,10 @@@ int mlx5_eswitch_set_vport_rate(struct 
  		return -EOPNOTSUPP;
  
  	mutex_lock(&esw->state_lock);
++<<<<<<< HEAD
 +	evport = &esw->vports[vport];
++=======
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  
  	if (min_rate == evport->info.min_rate)
  		goto set_max_rate;
@@@ -2331,19 -2368,18 +2383,28 @@@ static int mlx5_eswitch_query_vport_dro
  }
  
  int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,
 -				 int vport_num,
 +				 int vport,
  				 struct ifla_vf_stats *vf_stats)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  	int outlen = MLX5_ST_SZ_BYTES(query_vport_counter_out);
  	u32 in[MLX5_ST_SZ_DW(query_vport_counter_in)] = {0};
  	struct mlx5_vport_drop_stats stats = {0};
  	int err = 0;
  	u32 *out;
  
++<<<<<<< HEAD
 +	if (!ESW_ALLOWED(esw))
 +		return -EPERM;
 +	if (!LEGAL_VPORT(esw, vport))
 +		return -EINVAL;
++=======
+ 	if (IS_ERR(vport))
+ 		return PTR_ERR(vport);
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  
  	out = kvzalloc(outlen, GFP_KERNEL);
  	if (!out)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 14d8d502a0a3,ed3fad689ec9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -388,6 -400,97 +388,54 @@@ bool mlx5_esw_multipath_prereq(struct m
  /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
  void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
  
++<<<<<<< HEAD
++=======
+ /* The vport getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_vports(esw, i, vport)		\
+ 	for ((i) = MLX5_VPORT_PF;			\
+ 	     (vport) = &(esw)->vports[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)	\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;			\
+ 	     (vport) = &(esw)->vports[(i)],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_reverse(esw, i, vport, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (vport) = &(esw)->vports[(i)],			\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ /* The rep getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_reps(esw, i, rep)			\
+ 	for ((i) = MLX5_VPORT_PF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep(esw, i, rep, nvfs)		\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ #define mlx5_esw_for_each_vf_vport_num(esw, vport, nvfs)	\
+ 	for ((vport) = MLX5_VPORT_FIRST_VF; (vport) <= (nvfs); (vport)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_num_reverse(esw, vport, nvfs)	\
+ 	for ((vport) = (nvfs); (vport) >= MLX5_VPORT_FIRST_VF; (vport)--)
+ 
+ struct mlx5_vport *__must_check
+ mlx5_eswitch_get_vport(struct mlx5_eswitch *esw, u16 vport_num);
+ 
++>>>>>>> 5d9986a3947a (net/mlx5: E-Switch, Fix the check of legal vport)
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
