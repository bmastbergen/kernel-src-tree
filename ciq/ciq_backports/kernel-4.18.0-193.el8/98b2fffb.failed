iommu/vt-d: Handle 32bit device with identity default domain

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [iommu] vt-d: Handle 32bit device with identity default domain (Jerry Snitselaar) [1742234]
Rebuild_FUZZ: 94.74%
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 98b2fffb5e274d73e47d495da2caf213cfa28fc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/98b2fffb.failed

The iommu driver doesn't know whether the bit width of a PCI
device is sufficient for access to the whole system memory.
Hence, the driver checks this when the driver calls into the
dma APIs. If a device is using an identity domain, but the
bit width is less than the system requirement, we need to use
a dma domain instead. This also applies after we delegated
the domain life cycle management to the upper layer.

	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 98b2fffb5e274d73e47d495da2caf213cfa28fc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index d5aa558dd444,87f9f2237238..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -3586,47 -3593,45 +3567,78 @@@ out
  }
  
  /* Check if the dev needs to go through non-identity map and unmap process.*/
 -static bool iommu_need_mapping(struct device *dev)
 +static int iommu_no_mapping(struct device *dev)
  {
- 	int found;
+ 	int ret;
  
  	if (iommu_dummy(dev))
 -		return false;
 +		return 1;
  
 +	if (!iommu_identity_mapping)
 +		return 0;
 +
++<<<<<<< HEAD
 +	found = identity_mapping(dev);
 +	if (found) {
 +		if (iommu_should_identity_map(dev, 0))
 +			return 1;
 +		else {
 +			/*
 +			 * 32 bit DMA is removed from si_domain and fall back
 +			 * to non-identity mapping.
 +			 */
 +			dmar_remove_one_dev_info(si_domain, dev);
 +			pr_info("32bit %s uses non-identity mapping\n",
 +				dev_name(dev));
 +			return 0;
 +		}
 +	} else {
 +		/*
 +		 * In case of a detached 64 bit DMA device from vm, the device
 +		 * is put into si_domain for identity mapping.
 +		 */
 +		if (iommu_should_identity_map(dev, 0)) {
 +			int ret;
 +			ret = domain_add_dev_info(si_domain, dev);
 +			if (!ret) {
 +				pr_info("64bit %s uses identity mapping\n",
 +					dev_name(dev));
 +				return 1;
 +			}
++=======
+ 	ret = identity_mapping(dev);
+ 	if (ret) {
+ 		u64 dma_mask = *dev->dma_mask;
+ 
+ 		if (dev->coherent_dma_mask && dev->coherent_dma_mask < dma_mask)
+ 			dma_mask = dev->coherent_dma_mask;
+ 
+ 		if (dma_mask >= dma_get_required_mask(dev))
+ 			return false;
+ 
+ 		/*
+ 		 * 32 bit DMA is removed from si_domain and fall back to
+ 		 * non-identity mapping.
+ 		 */
+ 		dmar_remove_one_dev_info(dev);
+ 		ret = iommu_request_dma_domain_for_dev(dev);
+ 		if (ret) {
+ 			struct iommu_domain *domain;
+ 			struct dmar_domain *dmar_domain;
+ 
+ 			domain = iommu_get_domain_for_dev(dev);
+ 			if (domain) {
+ 				dmar_domain = to_dmar_domain(domain);
+ 				dmar_domain->flags |= DOMAIN_FLAG_LOSE_CHILDREN;
+ 			}
+ 			get_valid_domain_for_dev(dev);
++>>>>>>> 98b2fffb5e27 (iommu/vt-d: Handle 32bit device with identity default domain)
  		}
+ 
+ 		dev_info(dev, "32bit DMA uses non-identity mapping\n");
  	}
  
 -	return true;
 +	return 0;
  }
  
  static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,
* Unmerged path drivers/iommu/intel-iommu.c
