libnvdimm/pfn: Fix namespace creation on misaligned addresses

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jeff Moyer <jmoyer@redhat.com>
commit 274b924088e93593c76fb122d24bc0ef18d0ddf4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/274b9240.failed

Yi reported[1] that after commit a3619190d62e ("libnvdimm/pfn: stop
padding pmem namespaces to section alignment"), it was no longer
possible to create a device dax namespace with a 1G alignment.  The
reason was that the pmem region was not itself 1G-aligned.  The code
happily skips past the first 512M, but fails to account for a now
misaligned end offset (since space was allocated starting at that
misaligned address, and extending for size GBs).  Reintroduce
end_trunc, so that the code correctly handles the misaligned end
address.  This results in the same behavior as before the introduction
of the offending commit.

[1] https://lists.01.org/pipermail/linux-nvdimm/2019-July/022813.html

Fixes: a3619190d62e ("libnvdimm/pfn: stop padding pmem namespaces ...")
Reported-and-tested-by: Yi Zhang <yi.zhang@redhat.com>
	Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Link: https://lore.kernel.org/r/x49ftll8f39.fsf@segfault.boston.devel.redhat.com
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 274b924088e93593c76fb122d24bc0ef18d0ddf4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/pfn_devs.c
diff --cc drivers/nvdimm/pfn_devs.c
index 8762ec764857,cb98b8fe786e..000000000000
--- a/drivers/nvdimm/pfn_devs.c
+++ b/drivers/nvdimm/pfn_devs.c
@@@ -695,11 -652,11 +695,16 @@@ static int nd_pfn_init(struct nd_pfn *n
  {
  	struct nd_namespace_common *ndns = nd_pfn->ndns;
  	struct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);
 +	u32 start_pad, end_trunc, reserve = info_block_reserve();
  	resource_size_t start, size;
  	struct nd_region *nd_region;
++<<<<<<< HEAD
++=======
+ 	unsigned long npfns, align;
+ 	u32 end_trunc;
++>>>>>>> 274b924088e9 (libnvdimm/pfn: Fix namespace creation on misaligned addresses)
  	struct nd_pfn_sb *pfn_sb;
 +	unsigned long npfns;
  	phys_addr_t offset;
  	const char *sig;
  	u64 checksum;
@@@ -743,10 -693,11 +748,16 @@@
  	 * implementation will limit the pfns advertised through
  	 * ->direct_access() to those that are included in the memmap.
  	 */
 -	start = nsio->res.start;
 +	start = nsio->res.start + start_pad;
  	size = resource_size(&nsio->res);
++<<<<<<< HEAD
 +	npfns = PFN_SECTION_ALIGN_UP((size - start_pad - end_trunc - reserve)
 +			/ PAGE_SIZE);
++=======
+ 	npfns = PHYS_PFN(size - SZ_8K);
+ 	align = max(nd_pfn->align, (1UL << SUBSECTION_SHIFT));
+ 	end_trunc = start + size - ALIGN_DOWN(start + size, align);
++>>>>>>> 274b924088e9 (libnvdimm/pfn: Fix namespace creation on misaligned addresses)
  	if (nd_pfn->mode == PFN_MODE_PMEM) {
  		/*
  		 * The altmap should be padded out to the block size used
@@@ -766,7 -716,7 +777,11 @@@
  		return -ENXIO;
  	}
  
++<<<<<<< HEAD
 +	npfns = (size - offset - start_pad - end_trunc) / SZ_4K;
++=======
+ 	npfns = PHYS_PFN(size - offset - end_trunc);
++>>>>>>> 274b924088e9 (libnvdimm/pfn: Fix namespace creation on misaligned addresses)
  	pfn_sb->mode = cpu_to_le32(nd_pfn->mode);
  	pfn_sb->dataoff = cpu_to_le64(offset);
  	pfn_sb->npfns = cpu_to_le64(npfns);
@@@ -775,7 -725,6 +790,10 @@@
  	memcpy(pfn_sb->parent_uuid, nd_dev_to_uuid(&ndns->dev), 16);
  	pfn_sb->version_major = cpu_to_le16(1);
  	pfn_sb->version_minor = cpu_to_le16(3);
++<<<<<<< HEAD
 +	pfn_sb->start_pad = cpu_to_le32(start_pad);
++=======
++>>>>>>> 274b924088e9 (libnvdimm/pfn: Fix namespace creation on misaligned addresses)
  	pfn_sb->end_trunc = cpu_to_le32(end_trunc);
  	pfn_sb->align = cpu_to_le32(nd_pfn->align);
  	checksum = nd_sb_checksum((struct nd_gen_sb *) pfn_sb);
* Unmerged path drivers/nvdimm/pfn_devs.c
