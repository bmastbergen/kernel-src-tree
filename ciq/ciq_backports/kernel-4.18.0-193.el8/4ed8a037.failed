drm/amdgpu: invalidate mmhub semaphore workaround in gmc9/gmc10

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author changzhu <Changfeng.Zhu@amd.com>
commit 4ed8a03740d0ce092563c8fcb76d2c28da4675cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4ed8a037.failed

It may lose gpuvm invalidate acknowldege state across power-gating off
cycle. To avoid this issue in gmc9/gmc10 invalidation, add semaphore acquire
before invalidation and semaphore release after invalidation.

After adding semaphore acquire before invalidation, the semaphore
register become read-only if another process try to acquire semaphore.
Then it will not be able to release this semaphore. Then it may cause
deadlock problem. If this deadlock problem happens, it needs a semaphore
firmware fix.

	Signed-off-by: changzhu <Changfeng.Zhu@amd.com>
	Acked-by: Huang Rui <ray.huang@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 4ed8a03740d0ce092563c8fcb76d2c28da4675cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c
#	drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
diff --cc drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
index c0446af00cdd,365a88ecdec4..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
@@@ -391,44 -432,87 +391,103 @@@ static uint32_t gmc_v9_0_get_invalidate
   *
   * Flush the TLB for the requested page table using certain type.
   */
 -static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev, uint32_t vmid,
 -					uint32_t vmhub, uint32_t flush_type)
 +static void gmc_v9_0_flush_gpu_tlb(struct amdgpu_device *adev,
 +				uint32_t vmid, uint32_t flush_type)
  {
  	const unsigned eng = 17;
 -	u32 j, tmp;
 -	struct amdgpu_vmhub *hub;
 +	unsigned i, j;
  
 -	BUG_ON(vmhub >= adev->num_vmhubs);
 +	for (i = 0; i < AMDGPU_MAX_VMHUBS; ++i) {
 +		struct amdgpu_vmhub *hub = &adev->vmhub[i];
 +		u32 tmp = gmc_v9_0_get_invalidate_req(vmid, flush_type);
  
 -	hub = &adev->vmhub[vmhub];
 -	tmp = gmc_v9_0_get_invalidate_req(vmid, flush_type);
 +		/* This is necessary for a HW workaround under SRIOV as well
 +		 * as GFXOFF under bare metal
 +		 */
 +		if (adev->gfx.kiq.ring.sched.ready &&
 +		    (amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev)) &&
 +		    !adev->in_gpu_reset) {
 +			uint32_t req = hub->vm_inv_eng0_req + eng;
 +			uint32_t ack = hub->vm_inv_eng0_ack + eng;
 +
 +			amdgpu_virt_kiq_reg_write_reg_wait(adev, req, ack, tmp,
 +							   1 << vmid);
 +			continue;
 +		}
  
 -	/* This is necessary for a HW workaround under SRIOV as well
 -	 * as GFXOFF under bare metal
 -	 */
 -	if (adev->gfx.kiq.ring.sched.ready &&
 -			(amdgpu_sriov_runtime(adev) || !amdgpu_sriov_vf(adev)) &&
 -			!adev->in_gpu_reset) {
 -		uint32_t req = hub->vm_inv_eng0_req + eng;
 -		uint32_t ack = hub->vm_inv_eng0_ack + eng;
 -
 -		amdgpu_virt_kiq_reg_write_reg_wait(adev, req, ack, tmp,
 -				1 << vmid);
 -		return;
 +		spin_lock(&adev->gmc.invalidate_lock);
 +		WREG32_NO_KIQ(hub->vm_inv_eng0_req + eng, tmp);
 +		for (j = 0; j < adev->usec_timeout; j++) {
 +			tmp = RREG32_NO_KIQ(hub->vm_inv_eng0_ack + eng);
 +			if (tmp & (1 << vmid))
 +				break;
 +			udelay(1);
 +		}
 +		spin_unlock(&adev->gmc.invalidate_lock);
 +		if (j < adev->usec_timeout)
 +			continue;
 +
 +		DRM_ERROR("Timeout waiting for VM flush ACK!\n");
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	spin_lock(&adev->gmc.invalidate_lock);
+ 
+ 	/*
+ 	 * It may lose gpuvm invalidate acknowldege state across power-gating
+ 	 * off cycle, add semaphore acquire before invalidation and semaphore
+ 	 * release after invalidation to avoid entering power gated state
+ 	 * to WA the Issue
+ 	 */
+ 
+ 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
+ 	if (vmhub == AMDGPU_MMHUB_0 ||
+ 	    vmhub == AMDGPU_MMHUB_1) {
+ 		for (j = 0; j < adev->usec_timeout; j++) {
+ 			/* a read return value of 1 means semaphore acuqire */
+ 			tmp = RREG32_NO_KIQ(hub->vm_inv_eng0_sem + eng);
+ 			if (tmp & 0x1)
+ 				break;
+ 			udelay(1);
+ 		}
+ 
+ 		if (j >= adev->usec_timeout)
+ 			DRM_ERROR("Timeout waiting for sem acquire in VM flush!\n");
+ 	}
+ 
+ 	WREG32_NO_KIQ(hub->vm_inv_eng0_req + eng, tmp);
+ 
+ 	/*
+ 	 * Issue a dummy read to wait for the ACK register to be cleared
+ 	 * to avoid a false ACK due to the new fast GRBM interface.
+ 	 */
+ 	if (vmhub == AMDGPU_GFXHUB_0)
+ 		RREG32_NO_KIQ(hub->vm_inv_eng0_req + eng);
+ 
+ 	for (j = 0; j < adev->usec_timeout; j++) {
+ 		tmp = RREG32_NO_KIQ(hub->vm_inv_eng0_ack + eng);
+ 		if (tmp & (1 << vmid))
+ 			break;
+ 		udelay(1);
+ 	}
+ 
+ 	/* TODO: It needs to continue working on debugging with semaphore for GFXHUB as well. */
+ 	if (vmhub == AMDGPU_MMHUB_0 ||
+ 	    vmhub == AMDGPU_MMHUB_1)
+ 		/*
+ 		 * add semaphore release after invalidation,
+ 		 * write with 0 means semaphore release
+ 		 */
+ 		WREG32_NO_KIQ(hub->vm_inv_eng0_sem + eng, 0);
+ 
+ 	spin_unlock(&adev->gmc.invalidate_lock);
+ 
+ 	if (j < adev->usec_timeout)
+ 		return;
+ 
+ 	DRM_ERROR("Timeout waiting for VM flush ACK!\n");
++>>>>>>> 4ed8a03740d0 (drm/amdgpu: invalidate mmhub semaphore workaround in gmc9/gmc10)
  }
  
  static uint64_t gmc_v9_0_emit_flush_gpu_tlb(struct amdgpu_ring *ring,
* Unmerged path drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c
diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.h b/drivers/gpu/drm/amd/amdgpu/soc15.h
index a66c8bfbbaa6..4bb1b82143ca 100644
--- a/drivers/gpu/drm/amd/amdgpu/soc15.h
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.h
@@ -28,8 +28,8 @@
 #include "nbio_v7_0.h"
 #include "nbio_v7_4.h"
 
-#define SOC15_FLUSH_GPU_TLB_NUM_WREG		4
-#define SOC15_FLUSH_GPU_TLB_NUM_REG_WAIT	1
+#define SOC15_FLUSH_GPU_TLB_NUM_WREG		6
+#define SOC15_FLUSH_GPU_TLB_NUM_REG_WAIT	3
 
 extern const struct amd_ip_funcs soc15_common_ip_funcs;
 
