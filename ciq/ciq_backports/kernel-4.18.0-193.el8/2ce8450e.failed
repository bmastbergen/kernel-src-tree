libbpf: add bpf_object__open_{file, mem} w/ extensible opts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 2ce8450ef5a381e5ffeb4682c0093a3ab5d07008
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2ce8450e.failed

Add new set of bpf_object__open APIs using new approach to optional
parameters extensibility allowing simpler ABI compatibility approach.

This patch demonstrates an approach to implementing libbpf APIs that
makes it easy to extend existing APIs with extra optional parameters in
such a way, that ABI compatibility is preserved without having to do
symbol versioning and generating lots of boilerplate code to handle it.
To facilitate succinct code for working with options, add OPTS_VALID,
OPTS_HAS, and OPTS_GET macros that hide all the NULL, size, and zero
checks.

Additionally, newly added libbpf APIs are encouraged to follow similar
pattern of having all mandatory parameters as formal function parameters
and always have optional (NULL-able) xxx_opts struct, which should
always have real struct size as a first field and the rest would be
optional parameters added over time, which tune the behavior of existing
API, if specified by user.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 2ce8450ef5a381e5ffeb4682c0093a3ab5d07008)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
#	tools/lib/bpf/libbpf.map
diff --cc tools/lib/bpf/libbpf.c
index 70dc223cca5a,d471d33400ae..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -486,9 -492,21 +486,15 @@@ bpf_object__init_prog_names(struct bpf_
  	return 0;
  }
  
 -static __u32 get_kernel_version(void)
 -{
 -	__u32 major, minor, patch;
 -	struct utsname info;
 -
 -	uname(&info);
 -	if (sscanf(info.release, "%u.%u.%u", &major, &minor, &patch) != 3)
 -		return 0;
 -	return KERNEL_VERSION(major, minor, patch);
 -}
 -
  static struct bpf_object *bpf_object__new(const char *path,
++<<<<<<< HEAD
 +					  void *obj_buf,
 +					  size_t obj_buf_sz)
++=======
+ 					  const void *obj_buf,
+ 					  size_t obj_buf_sz,
+ 					  const char *obj_name)
++>>>>>>> 2ce8450ef5a3 (libbpf: add bpf_object__open_{file, mem} w/ extensible opts)
  {
  	struct bpf_object *obj;
  	char *end;
@@@ -2648,53 -3552,9 +2660,58 @@@ bpf_object__load_progs(struct bpf_objec
  	return 0;
  }
  
 +static bool bpf_prog_type__needs_kver(enum bpf_prog_type type)
 +{
 +	switch (type) {
 +	case BPF_PROG_TYPE_SOCKET_FILTER:
 +	case BPF_PROG_TYPE_SCHED_CLS:
 +	case BPF_PROG_TYPE_SCHED_ACT:
 +	case BPF_PROG_TYPE_XDP:
 +	case BPF_PROG_TYPE_CGROUP_SKB:
 +	case BPF_PROG_TYPE_CGROUP_SOCK:
 +	case BPF_PROG_TYPE_LWT_IN:
 +	case BPF_PROG_TYPE_LWT_OUT:
 +	case BPF_PROG_TYPE_LWT_XMIT:
 +	case BPF_PROG_TYPE_LWT_SEG6LOCAL:
 +	case BPF_PROG_TYPE_SOCK_OPS:
 +	case BPF_PROG_TYPE_SK_SKB:
 +	case BPF_PROG_TYPE_CGROUP_DEVICE:
 +	case BPF_PROG_TYPE_SK_MSG:
 +	case BPF_PROG_TYPE_CGROUP_SOCK_ADDR:
 +	case BPF_PROG_TYPE_LIRC_MODE2:
 +	case BPF_PROG_TYPE_SK_REUSEPORT:
 +	case BPF_PROG_TYPE_FLOW_DISSECTOR:
 +	case BPF_PROG_TYPE_UNSPEC:
 +	case BPF_PROG_TYPE_TRACEPOINT:
 +	case BPF_PROG_TYPE_RAW_TRACEPOINT:
 +	case BPF_PROG_TYPE_PERF_EVENT:
 +	case BPF_PROG_TYPE_CGROUP_SYSCTL:
 +	case BPF_PROG_TYPE_CGROUP_SOCKOPT:
 +		return false;
 +	case BPF_PROG_TYPE_KPROBE:
 +	default:
 +		return true;
 +	}
 +}
 +
 +static int bpf_object__validate(struct bpf_object *obj, bool needs_kver)
 +{
 +	if (needs_kver && obj->kern_version == 0) {
 +		pr_warning("%s doesn't provide kernel version\n",
 +			   obj->path);
 +		return -LIBBPF_ERRNO__KVERSION;
 +	}
 +	return 0;
 +}
 +
  static struct bpf_object *
++<<<<<<< HEAD
 +__bpf_object__open(const char *path, void *obj_buf, size_t obj_buf_sz,
 +		   bool needs_kver, int flags)
++=======
+ __bpf_object__open(const char *path, const void *obj_buf, size_t obj_buf_sz,
+ 		   const char *obj_name, int flags)
++>>>>>>> 2ce8450ef5a3 (libbpf: add bpf_object__open_{file, mem} w/ extensible opts)
  {
  	struct bpf_object *obj;
  	int err;
@@@ -2731,9 -3590,7 +2748,13 @@@ struct bpf_object *__bpf_object__open_x
  
  	pr_debug("loading %s\n", attr->file);
  
++<<<<<<< HEAD
 +	return __bpf_object__open(attr->file, NULL, 0,
 +				  bpf_prog_type__needs_kver(attr->prog_type),
 +				  flags);
++=======
+ 	return __bpf_object__open(attr->file, NULL, 0, NULL, flags);
++>>>>>>> 2ce8450ef5a3 (libbpf: add bpf_object__open_{file, mem} w/ extensible opts)
  }
  
  struct bpf_object *bpf_object__open_xattr(struct bpf_object_open_attr *attr)
@@@ -2765,11 -3645,30 +2809,34 @@@ bpf_object__open_mem(const void *obj_bu
  		snprintf(tmp_name, sizeof(tmp_name), "%lx-%lx",
  			 (unsigned long)obj_buf,
  			 (unsigned long)obj_buf_sz);
- 		name = tmp_name;
+ 		obj_name = tmp_name;
  	}
- 	pr_debug("loading object '%s' from buffer\n", name);
+ 	pr_debug("loading object '%s' from buffer\n", obj_name);
  
++<<<<<<< HEAD
 +	return __bpf_object__open(name, obj_buf, obj_buf_sz, true, true);
++=======
+ 	relaxed_maps = OPTS_GET(opts, relaxed_maps, false);
+ 	return __bpf_object__open(obj_name, obj_buf, obj_buf_sz, obj_name,
+ 				  relaxed_maps ? MAPS_RELAX_COMPAT : 0);
+ }
+ 
+ struct bpf_object *
+ bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
+ 			const char *name)
+ {
+ 	LIBBPF_OPTS(bpf_object_open_opts, opts,
+ 		.object_name = name,
+ 		/* wrong default, but backwards-compatible */
+ 		.relaxed_maps = true,
+ 	);
+ 
+ 	/* returning NULL is wrong, but backwards-compatible */
+ 	if (!obj_buf || obj_buf_sz == 0)
+ 		return NULL;
+ 
+ 	return bpf_object__open_mem(obj_buf, obj_buf_sz, &opts);
++>>>>>>> 2ce8450ef5a3 (libbpf: add bpf_object__open_{file, mem} w/ extensible opts)
  }
  
  int bpf_object__unload(struct bpf_object *obj)
diff --cc tools/lib/bpf/libbpf.h
index 5cbf459ece0b,667e6853e51f..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -67,14 -67,52 +67,60 @@@ struct bpf_object_open_attr 
  	enum bpf_prog_type prog_type;
  };
  
+ /* Helper macro to declare and initialize libbpf options struct
+  *
+  * This dance with uninitialized declaration, followed by memset to zero,
+  * followed by assignment using compound literal syntax is done to preserve
+  * ability to use a nice struct field initialization syntax and **hopefully**
+  * have all the padding bytes initialized to zero. It's not guaranteed though,
+  * when copying literal, that compiler won't copy garbage in literal's padding
+  * bytes, but that's the best way I've found and it seems to work in practice.
+  */
+ #define LIBBPF_OPTS(TYPE, NAME, ...)					    \
+ 	struct TYPE NAME;						    \
+ 	memset(&NAME, 0, sizeof(struct TYPE));				    \
+ 	NAME = (struct TYPE) {						    \
+ 		.sz = sizeof(struct TYPE),				    \
+ 		__VA_ARGS__						    \
+ 	}
+ 
+ struct bpf_object_open_opts {
+ 	/* size of this struct, for forward/backward compatiblity */
+ 	size_t sz;
+ 	/* object name override, if provided:
+ 	 * - for object open from file, this will override setting object
+ 	 *   name from file path's base name;
+ 	 * - for object open from memory buffer, this will specify an object
+ 	 *   name and will override default "<addr>-<buf-size>" name;
+ 	 */
+ 	const char *object_name;
+ 	/* parse map definitions non-strictly, allowing extra attributes/data */
+ 	bool relaxed_maps;
+ };
+ #define bpf_object_open_opts__last_field relaxed_maps
+ 
  LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
  LIBBPF_API struct bpf_object *
+ bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts);
+ LIBBPF_API struct bpf_object *
+ bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
+ 		     struct bpf_object_open_opts *opts);
+ 
+ /* deprecated bpf_object__open variants */
+ LIBBPF_API struct bpf_object *
+ bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
+ 			const char *name);
+ LIBBPF_API struct bpf_object *
  bpf_object__open_xattr(struct bpf_object_open_attr *attr);
 -
++<<<<<<< HEAD
 +struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 +					    int flags);
 +LIBBPF_API struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 +						      size_t obj_buf_sz,
 +						      const char *name);
++=======
++
++>>>>>>> 2ce8450ef5a3 (libbpf: add bpf_object__open_{file, mem} w/ extensible opts)
  int bpf_object__section_size(const struct bpf_object *obj, const char *name,
  			     __u32 *size);
  int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
diff --cc tools/lib/bpf/libbpf.map
index 4e72df8e98ba,4d241fd92dd4..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -186,4 -186,13 +186,13 @@@ LIBBPF_0.0.4 
  } LIBBPF_0.0.3;
  
  LIBBPF_0.0.5 {
 -	global:
 -		bpf_btf_get_next_id;
  } LIBBPF_0.0.4;
++<<<<<<< HEAD
++=======
+ 
+ LIBBPF_0.0.6 {
+ 	global:
+ 		bpf_object__open_file;
+ 		bpf_object__open_mem;
+ } LIBBPF_0.0.5;
++>>>>>>> 2ce8450ef5a3 (libbpf: add bpf_object__open_{file, mem} w/ extensible opts)
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
* Unmerged path tools/lib/bpf/libbpf.map
diff --git a/tools/lib/bpf/libbpf_internal.h b/tools/lib/bpf/libbpf_internal.h
index 2e83a34f8c79..f51444fc7eb7 100644
--- a/tools/lib/bpf/libbpf_internal.h
+++ b/tools/lib/bpf/libbpf_internal.h
@@ -47,6 +47,38 @@ do {				\
 #define pr_info(fmt, ...)	__pr(LIBBPF_INFO, fmt, ##__VA_ARGS__)
 #define pr_debug(fmt, ...)	__pr(LIBBPF_DEBUG, fmt, ##__VA_ARGS__)
 
+static inline bool libbpf_validate_opts(const char *opts,
+					size_t opts_sz, size_t user_sz,
+					const char *type_name)
+{
+	if (user_sz < sizeof(size_t)) {
+		pr_warning("%s size (%zu) is too small\n", type_name, user_sz);
+		return false;
+	}
+	if (user_sz > opts_sz) {
+		size_t i;
+
+		for (i = opts_sz; i < user_sz; i++) {
+			if (opts[i]) {
+				pr_warning("%s has non-zero extra bytes",
+					   type_name);
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+#define OPTS_VALID(opts, type)						      \
+	(!(opts) || libbpf_validate_opts((const char *)opts,		      \
+					 offsetofend(struct type,	      \
+						     type##__last_field),     \
+					 (opts)->sz, #type))
+#define OPTS_HAS(opts, field) \
+	((opts) && opts->sz >= offsetofend(typeof(*(opts)), field))
+#define OPTS_GET(opts, field, fallback_value) \
+	(OPTS_HAS(opts, field) ? (opts)->field : fallback_value)
+
 int libbpf__load_raw_btf(const char *raw_types, size_t types_len,
 			 const char *str_sec, size_t str_len);
 
