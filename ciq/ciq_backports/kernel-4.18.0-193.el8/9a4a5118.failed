xfs: refactor AGI unlinked bucket updates

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 9a4a5118644e41ac9da7fa7d87ff3b09e61304de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9a4a5118.failed

Split the AGI unlinked bucket updates into a separate function.  No
functional changes.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 9a4a5118644e41ac9da7fa7d87ff3b09e61304de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_inode.c
diff --cc fs/xfs/xfs_inode.c
index 2557b96757c8,f1de80e8b9a6..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -1907,8 -1907,48 +1907,53 @@@ xfs_inactive
  }
  
  /*
++<<<<<<< HEAD
 + * This is called when the inode's link count has gone to 0 or we are creating
 + * a tmpfile via O_TMPFILE.  The inode @ip must have nlink == 0.
++=======
+  * Point the AGI unlinked bucket at an inode and log the results.  The caller
+  * is responsible for validating the old value.
+  */
+ STATIC int
+ xfs_iunlink_update_bucket(
+ 	struct xfs_trans	*tp,
+ 	xfs_agnumber_t		agno,
+ 	struct xfs_buf		*agibp,
+ 	unsigned int		bucket_index,
+ 	xfs_agino_t		new_agino)
+ {
+ 	struct xfs_agi		*agi = XFS_BUF_TO_AGI(agibp);
+ 	xfs_agino_t		old_value;
+ 	int			offset;
+ 
+ 	ASSERT(xfs_verify_agino_or_null(tp->t_mountp, agno, new_agino));
+ 
+ 	old_value = be32_to_cpu(agi->agi_unlinked[bucket_index]);
+ 	trace_xfs_iunlink_update_bucket(tp->t_mountp, agno, bucket_index,
+ 			old_value, new_agino);
+ 
+ 	/*
+ 	 * We should never find the head of the list already set to the value
+ 	 * passed in because either we're adding or removing ourselves from the
+ 	 * head of the list.
+ 	 */
+ 	if (old_value == new_agino)
+ 		return -EFSCORRUPTED;
+ 
+ 	agi->agi_unlinked[bucket_index] = cpu_to_be32(new_agino);
+ 	offset = offsetof(struct xfs_agi, agi_unlinked) +
+ 			(sizeof(xfs_agino_t) * bucket_index);
+ 	xfs_trans_log_buf(tp, agibp, offset, offset + sizeof(xfs_agino_t) - 1);
+ 	return 0;
+ }
+ 
+ /*
+  * This is called when the inode's link count goes to 0 or we are creating a
+  * tmpfile via O_TMPFILE. In the case of a tmpfile, @ignore_linkcount will be
+  * set to true as the link count is dropped to zero by the VFS after we've
+  * created the file successfully, so we have to add it to the unlinked list
+  * while the link count is non-zero.
++>>>>>>> 9a4a5118644e (xfs: refactor AGI unlinked bucket updates)
   *
   * We place the on-disk inode on a list in the AGI.  It will be pulled from this
   * list when the inode is freed.
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_trace.h b/fs/xfs/xfs_trace.h
index 6fcc893dfc91..c10478e7e49a 100644
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@ -3371,6 +3371,32 @@ DEFINE_TRANS_EVENT(xfs_trans_roll);
 DEFINE_TRANS_EVENT(xfs_trans_add_item);
 DEFINE_TRANS_EVENT(xfs_trans_free_items);
 
+TRACE_EVENT(xfs_iunlink_update_bucket,
+	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, unsigned int bucket,
+		 xfs_agino_t old_ptr, xfs_agino_t new_ptr),
+	TP_ARGS(mp, agno, bucket, old_ptr, new_ptr),
+	TP_STRUCT__entry(
+		__field(dev_t, dev)
+		__field(xfs_agnumber_t, agno)
+		__field(unsigned int, bucket)
+		__field(xfs_agino_t, old_ptr)
+		__field(xfs_agino_t, new_ptr)
+	),
+	TP_fast_assign(
+		__entry->dev = mp->m_super->s_dev;
+		__entry->agno = agno;
+		__entry->bucket = bucket;
+		__entry->old_ptr = old_ptr;
+		__entry->new_ptr = new_ptr;
+	),
+	TP_printk("dev %d:%d agno %u bucket %u old 0x%x new 0x%x",
+		  MAJOR(__entry->dev), MINOR(__entry->dev),
+		  __entry->agno,
+		  __entry->bucket,
+		  __entry->old_ptr,
+		  __entry->new_ptr)
+);
+
 #endif /* _TRACE_XFS_H */
 
 #undef TRACE_INCLUDE_PATH
