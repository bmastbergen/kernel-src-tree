clocksource/drivers/tcb_clksrc: Use tcb as sched_clock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Alexandre Belloni <alexandre.belloni@bootlin.com>
commit f712a1e8e59e8f42b5a9ec3887a4ad079bb18175
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f712a1e8.failed

Now that the driver is registered early enough, use the TCB as the
sched_clock which is much more accurate than the jiffies implementation.

	Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
(cherry picked from commit f712a1e8e59e8f42b5a9ec3887a4ad079bb18175)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/clocksource/tcb_clksrc.c
diff --cc drivers/clocksource/tcb_clksrc.c
index 43f4d5c4d6fa,9de8c10ab546..000000000000
--- a/drivers/clocksource/tcb_clksrc.c
+++ b/drivers/clocksource/tcb_clksrc.c
@@@ -9,9 -9,11 +9,15 @@@
  #include <linux/err.h>
  #include <linux/ioport.h>
  #include <linux/io.h>
++<<<<<<< HEAD
 +#include <linux/platform_device.h>
++=======
+ #include <linux/of_address.h>
+ #include <linux/of_irq.h>
+ #include <linux/sched_clock.h>
++>>>>>>> f712a1e8e59e (clocksource/drivers/tcb_clksrc: Use tcb as sched_clock)
  #include <linux/syscore_ops.h>
 -#include <soc/at91/atmel_tcb.h>
 +#include <linux/atmel_tc.h>
  
  
  /*
@@@ -330,14 -333,20 +346,19 @@@ static void __init tcb_setup_single_cha
  	writel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);
  }
  
 -static const u8 atmel_tcb_divisors[5] = { 2, 8, 32, 128, 0, };
 -
 -static const struct of_device_id atmel_tcb_of_match[] = {
 -	{ .compatible = "atmel,at91rm9200-tcb", .data = (void *)16, },
 -	{ .compatible = "atmel,at91sam9x5-tcb", .data = (void *)32, },
 -	{ /* sentinel */ }
 -};
 -
 -static int __init tcb_clksrc_init(struct device_node *node)
 +static int __init tcb_clksrc_init(void)
  {
 -	struct atmel_tc tc;
 +	static char bootinfo[] __initdata
 +		= KERN_DEBUG "%s: tc%d at %d.%03d MHz\n";
 +
 +	struct platform_device *pdev;
 +	struct atmel_tc *tc;
  	struct clk *t0_clk;
++<<<<<<< HEAD
++=======
+ 	const struct of_device_id *match;
+ 	u64 (*tc_sched_clock)(void);
++>>>>>>> f712a1e8e59e (clocksource/drivers/tcb_clksrc: Use tcb as sched_clock)
  	u32 rate, divided_rate = 0;
  	int best_divisor_idx = -1;
  	int clk32k_divisor_idx = -1;
@@@ -390,18 -430,20 +411,28 @@@
  		/* use apropriate function to read 32 bit counter */
  		clksrc.read = tc_get_cycles32;
  		/* setup ony channel 0 */
++<<<<<<< HEAD
 +		tcb_setup_single_chan(tc, best_divisor_idx);
++=======
+ 		tcb_setup_single_chan(&tc, best_divisor_idx);
+ 		tc_sched_clock = tc_sched_clock_read32;
++>>>>>>> f712a1e8e59e (clocksource/drivers/tcb_clksrc: Use tcb as sched_clock)
  	} else {
 -		/* we have three clocks no matter what the
 +		/* tclib will give us three clocks no matter what the
  		 * underlying platform supports.
  		 */
 -		ret = clk_prepare_enable(tc.clk[1]);
 +		ret = clk_prepare_enable(tc->clk[1]);
  		if (ret) {
  			pr_debug("can't enable T1 clk\n");
  			goto err_disable_t0;
  		}
  		/* setup both channel 0 & 1 */
++<<<<<<< HEAD
 +		tcb_setup_dual_chan(tc, best_divisor_idx);
++=======
+ 		tcb_setup_dual_chan(&tc, best_divisor_idx);
+ 		tc_sched_clock = tc_sched_clock_read;
++>>>>>>> f712a1e8e59e (clocksource/drivers/tcb_clksrc: Use tcb as sched_clock)
  	}
  
  	/* and away we go! */
* Unmerged path drivers/clocksource/tcb_clksrc.c
