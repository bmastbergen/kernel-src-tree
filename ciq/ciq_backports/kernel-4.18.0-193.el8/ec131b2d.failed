mm/hmm: invalidate device page table at start of invalidation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [mm] hmm: invalidate device page table at start of invalidation (Jerome Glisse) [1498655 1597758]
Rebuild_FUZZ: 97.48%
commit-author Jérôme Glisse <jglisse@redhat.com>
commit ec131b2d7fa629edf88a1f51669d1b4a189cba44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ec131b2d.failed

Invalidate device page table at start of invalidation and invalidate in
progress CPU page table snapshooting at both start and end of any
invalidation.

This is helpful when device need to dirty page because the device page
table report the page as dirty.  Dirtying page must happen in the start
mmu notifier callback and not in the end one.

Link: http://lkml.kernel.org/r/20181019160442.18723-7-jglisse@redhat.com
	Signed-off-by: Jérôme Glisse <jglisse@redhat.com>
	Cc: Ralph Campbell <rcampbell@nvidia.com>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ec131b2d7fa629edf88a1f51669d1b4a189cba44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hmm.c
diff --cc mm/hmm.c
index 332f92c5115d,90c34f3d1243..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -188,16 -188,22 +188,33 @@@ static void hmm_release(struct mmu_noti
  	up_write(&hmm->mirrors_sem);
  }
  
++<<<<<<< HEAD
 +static void hmm_invalidate_range_start(struct mmu_notifier *mn,
 +				       struct mm_struct *mm,
 +				       unsigned long start,
 +				       unsigned long end)
++=======
+ static int hmm_invalidate_range_start(struct mmu_notifier *mn,
+ 				      struct mm_struct *mm,
+ 				      unsigned long start,
+ 				      unsigned long end,
+ 				      bool blockable)
++>>>>>>> ec131b2d7fa6 (mm/hmm: invalidate device page table at start of invalidation)
  {
+ 	struct hmm_update update;
  	struct hmm *hmm = mm->hmm;
  
  	VM_BUG_ON(!hmm);
  
++<<<<<<< HEAD
 +	atomic_inc(&hmm->sequence);
++=======
+ 	update.start = start;
+ 	update.end = end;
+ 	update.event = HMM_UPDATE_INVALIDATE;
+ 	update.blockable = blockable;
+ 	return hmm_invalidate_range(hmm, true, &update);
++>>>>>>> ec131b2d7fa6 (mm/hmm: invalidate device page table at start of invalidation)
  }
  
  static void hmm_invalidate_range_end(struct mmu_notifier *mn,
* Unmerged path mm/hmm.c
