SUNRPC: Use struct xdr_stream when constructing RPC Call header

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit e8680a24a269bd6dcb533f4e4a5faba9ae58925c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/e8680a24.failed

Modernize and harden the code path that constructs each RPC Call
message.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit e8680a24a269bd6dcb533f4e4a5faba9ae58925c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth_gss/auth_gss.c
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/auth_gss/auth_gss.c
index 6e951620fbcd,b333b1bdad45..000000000000
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@@ -1549,15 -1557,19 +1557,17 @@@ static int gss_marshal(struct rpc_task 
  	cred_len = p++;
  
  	spin_lock(&ctx->gc_seq_lock);
 -	req->rq_seqno = (ctx->gc_seq < MAXSEQ) ? ctx->gc_seq++ : MAXSEQ;
 +	req->rq_seqno = ctx->gc_seq++;
  	spin_unlock(&ctx->gc_seq_lock);
 -	if (req->rq_seqno == MAXSEQ)
 -		goto out_expired;
  
- 	*p++ = htonl((u32) RPC_GSS_VERSION);
- 	*p++ = htonl((u32) ctx->gc_proc);
- 	*p++ = htonl((u32) req->rq_seqno);
- 	*p++ = htonl((u32) gss_cred->gc_service);
+ 	*p++ = cpu_to_be32(RPC_GSS_VERSION);
+ 	*p++ = cpu_to_be32(ctx->gc_proc);
+ 	*p++ = cpu_to_be32(req->rq_seqno);
+ 	*p++ = cpu_to_be32(gss_cred->gc_service);
  	p = xdr_encode_netobj(p, &ctx->gc_wire_ctx);
- 	*cred_len = htonl((p - (cred_len + 1)) << 2);
+ 	*cred_len = cpu_to_be32((p - (cred_len + 1)) << 2);
+ 
+ 	/* Verifier */
  
  	/* We compute the checksum for the verifier over the xdr-encoded bytes
  	 * starting with the xid and ending at the end of the credential: */
@@@ -1565,23 -1577,27 +1575,38 @@@
  	iov.iov_len = (u8 *)p - (u8 *)iov.iov_base;
  	xdr_buf_from_iov(&iov, &verf_buf);
  
- 	/* set verifier flavor*/
- 	*p++ = htonl(RPC_AUTH_GSS);
- 
+ 	p = xdr_reserve_space(xdr, sizeof(*p));
+ 	if (!p)
+ 		goto out_put_ctx;
+ 	*p++ = rpc_auth_gss;
  	mic.data = (u8 *)(p + 1);
  	maj_stat = gss_get_mic(ctx->gc_gss_ctx, &verf_buf, &mic);
++<<<<<<< HEAD
 +	if (maj_stat == GSS_S_CONTEXT_EXPIRED) {
 +		clear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);
 +	} else if (maj_stat != 0) {
 +		printk("gss_marshal: gss_get_mic FAILED (%d)\n", maj_stat);
++=======
+ 	if (maj_stat == GSS_S_CONTEXT_EXPIRED)
+ 		goto out_expired;
+ 	else if (maj_stat != 0)
+ 		goto out_put_ctx;
+ 	if (xdr_stream_encode_opaque_inline(xdr, (void **)&p, mic.len) < 0)
++>>>>>>> e8680a24a269 (SUNRPC: Use struct xdr_stream when constructing RPC Call header)
  		goto out_put_ctx;
- 	}
- 	p = xdr_encode_opaque(p, NULL, mic.len);
  	gss_put_ctx(ctx);
++<<<<<<< HEAD
 +	return p;
++=======
+ 	return 0;
+ out_expired:
+ 	gss_put_ctx(ctx);
+ 	clear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);
+ 	return -EKEYEXPIRED;
++>>>>>>> e8680a24a269 (SUNRPC: Use struct xdr_stream when constructing RPC Call header)
  out_put_ctx:
  	gss_put_ctx(ctx);
- 	return NULL;
+ 	return -EMSGSIZE;
  }
  
  static int gss_renew_cred(struct rpc_task *task)
diff --cc net/sunrpc/clnt.c
index 415348b16ff1,d6750b7f169a..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1747,21 -1738,51 +1745,70 @@@ rpc_xdr_encode(struct rpc_task *task
  		     req->rq_rbuffer,
  		     req->rq_rcvsize);
  
++<<<<<<< HEAD
 +	p = rpc_encode_header(task);
 +	if (p == NULL) {
 +		printk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");
 +		rpc_exit(task, -EIO);
++=======
+ 	req->rq_snd_buf.head[0].iov_len = 0;
+ 	xdr_init_encode(&xdr, &req->rq_snd_buf,
+ 			req->rq_snd_buf.head[0].iov_base, req);
+ 	if (rpc_encode_header(task, &xdr))
++>>>>>>> e8680a24a269 (SUNRPC: Use struct xdr_stream when constructing RPC Call header)
 +		return;
 +	}
 +
++<<<<<<< HEAD
 +	encode = task->tk_msg.rpc_proc->p_encode;
 +	if (encode == NULL)
  		return;
  
 +	task->tk_status = rpcauth_wrap_req(task, encode, req, p,
 +			task->tk_msg.rpc_argp);
 +	if (task->tk_status == 0)
 +		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
++=======
+ 	task->tk_status = rpcauth_wrap_req(task, &xdr);
+ }
+ 
+ /*
+  * 3.	Encode arguments of an RPC call
+  */
+ static void
+ call_encode(struct rpc_task *task)
+ {
+ 	if (!rpc_task_need_encode(task))
+ 		goto out;
+ 	dprint_status(task);
+ 	/* Encode here so that rpcsec_gss can use correct sequence number. */
+ 	rpc_xdr_encode(task);
+ 	/* Did the encode result in an error condition? */
+ 	if (task->tk_status != 0) {
+ 		/* Was the error nonfatal? */
+ 		switch (task->tk_status) {
+ 		case -EAGAIN:
+ 		case -ENOMEM:
+ 			rpc_delay(task, HZ >> 4);
+ 			break;
+ 		case -EKEYEXPIRED:
+ 			task->tk_action = call_refresh;
+ 			break;
+ 		default:
+ 			rpc_exit(task, task->tk_status);
+ 		}
+ 		return;
+ 	} else {
+ 		xprt_request_prepare(task->tk_rqstp);
+ 	}
+ 
+ 	/* Add task to reply queue before transmission to avoid races */
+ 	if (rpc_reply_expected(task))
+ 		xprt_request_enqueue_receive(task);
+ 	xprt_request_enqueue_transmit(task);
+ out:
+ 	task->tk_action = call_bind;
++>>>>>>> e8680a24a269 (SUNRPC: Use struct xdr_stream when constructing RPC Call header)
  }
  
  /*
@@@ -2330,19 -2323,28 +2377,40 @@@ rpc_encode_header(struct rpc_task *task
  {
  	struct rpc_clnt *clnt = task->tk_client;
  	struct rpc_rqst	*req = task->tk_rqstp;
- 	__be32		*p = req->rq_svec[0].iov_base;
- 
- 	/* FIXME: check buffer size? */
- 
+ 	__be32 *p;
+ 	int error;
+ 
+ 	error = -EMSGSIZE;
+ 	p = xdr_reserve_space(xdr, RPC_CALLHDRSIZE << 2);
+ 	if (!p)
+ 		goto out_fail;
+ 	*p++ = req->rq_xid;
+ 	*p++ = rpc_call;
+ 	*p++ = cpu_to_be32(RPC_VERSION);
+ 	*p++ = cpu_to_be32(clnt->cl_prog);
+ 	*p++ = cpu_to_be32(clnt->cl_vers);
+ 	*p   = cpu_to_be32(task->tk_msg.rpc_proc->p_proc);
+ 
++<<<<<<< HEAD
 +	*p++ = req->rq_xid;		/* XID */
 +	*p++ = htonl(RPC_CALL);		/* CALL */
 +	*p++ = htonl(RPC_VERSION);	/* RPC version */
 +	*p++ = htonl(clnt->cl_prog);	/* program number */
 +	*p++ = htonl(clnt->cl_vers);	/* program version */
 +	*p++ = htonl(task->tk_msg.rpc_proc->p_proc);	/* procedure */
 +	p = rpcauth_marshcred(task, p);
 +	req->rq_slen = xdr_adjust_iovec(&req->rq_svec[0], p);
 +	return p;
++=======
+ 	error = rpcauth_marshcred(task, xdr);
+ 	if (error < 0)
+ 		goto out_fail;
+ 	return 0;
+ out_fail:
+ 	trace_rpc_bad_callhdr(task);
+ 	rpc_exit(task, error);
+ 	return error;
++>>>>>>> e8680a24a269 (SUNRPC: Use struct xdr_stream when constructing RPC Call header)
  }
  
  static __be32 *
diff --git a/include/linux/sunrpc/auth.h b/include/linux/sunrpc/auth.h
index bca2741a3eb0..5fd2fceff386 100644
--- a/include/linux/sunrpc/auth.h
+++ b/include/linux/sunrpc/auth.h
@@ -131,11 +131,12 @@ struct rpc_credops {
 	void			(*crdestroy)(struct rpc_cred *);
 
 	int			(*crmatch)(struct auth_cred *, struct rpc_cred *, int);
-	__be32 *		(*crmarshal)(struct rpc_task *, __be32 *);
+	int			(*crmarshal)(struct rpc_task *task,
+					     struct xdr_stream *xdr);
 	int			(*crrefresh)(struct rpc_task *);
 	__be32 *		(*crvalidate)(struct rpc_task *, __be32 *);
-	int			(*crwrap_req)(struct rpc_task *, kxdreproc_t,
-						void *, __be32 *, void *);
+	int			(*crwrap_req)(struct rpc_task *task,
+					      struct xdr_stream *xdr);
 	int			(*crunwrap_resp)(struct rpc_task *, kxdrdproc_t,
 						void *, __be32 *, void *);
 	int			(*crkey_timeout)(struct rpc_cred *);
@@ -165,9 +166,13 @@ struct rpc_cred *	rpcauth_lookup_credcache(struct rpc_auth *, struct auth_cred *
 void			rpcauth_init_cred(struct rpc_cred *, const struct auth_cred *, struct rpc_auth *, const struct rpc_credops *);
 struct rpc_cred *	rpcauth_lookupcred(struct rpc_auth *, int);
 void			put_rpccred(struct rpc_cred *);
-__be32 *		rpcauth_marshcred(struct rpc_task *, __be32 *);
+int			rpcauth_marshcred(struct rpc_task *task,
+					  struct xdr_stream *xdr);
 __be32 *		rpcauth_checkverf(struct rpc_task *, __be32 *);
-int			rpcauth_wrap_req(struct rpc_task *task, kxdreproc_t encode, void *rqstp, __be32 *data, void *obj);
+int			rpcauth_wrap_req_encode(struct rpc_task *task,
+						struct xdr_stream *xdr);
+int			rpcauth_wrap_req(struct rpc_task *task,
+					 struct xdr_stream *xdr);
 int			rpcauth_unwrap_resp(struct rpc_task *task, kxdrdproc_t decode, void *rqstp, __be32 *data, void *obj);
 bool			rpcauth_xmit_need_reencode(struct rpc_task *task);
 int			rpcauth_refreshcred(struct rpc_task *);
diff --git a/include/linux/sunrpc/xdr.h b/include/linux/sunrpc/xdr.h
index 2d104fd9d602..6ebd6cf47c93 100644
--- a/include/linux/sunrpc/xdr.h
+++ b/include/linux/sunrpc/xdr.h
@@ -84,6 +84,12 @@ xdr_buf_init(struct xdr_buf *buf, void *start, size_t len)
 #define	xdr_one		cpu_to_be32(1)
 #define	xdr_two		cpu_to_be32(2)
 
+#define	rpc_auth_null	cpu_to_be32(RPC_AUTH_NULL)
+#define	rpc_auth_unix	cpu_to_be32(RPC_AUTH_UNIX)
+#define	rpc_auth_gss	cpu_to_be32(RPC_AUTH_GSS)
+
+#define	rpc_call	cpu_to_be32(RPC_CALL)
+
 #define	rpc_success		cpu_to_be32(RPC_SUCCESS)
 #define	rpc_prog_unavail	cpu_to_be32(RPC_PROG_UNAVAIL)
 #define	rpc_prog_mismatch	cpu_to_be32(RPC_PROG_MISMATCH)
diff --git a/include/trace/events/sunrpc.h b/include/trace/events/sunrpc.h
index 42376a2afcb8..cf53cff630bb 100644
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@ -213,6 +213,35 @@ DECLARE_EVENT_CLASS(rpc_task_queued,
 DEFINE_RPC_QUEUED_EVENT(sleep);
 DEFINE_RPC_QUEUED_EVENT(wakeup);
 
+DECLARE_EVENT_CLASS(rpc_failure,
+
+	TP_PROTO(const struct rpc_task *task),
+
+	TP_ARGS(task),
+
+	TP_STRUCT__entry(
+		__field(unsigned int, task_id)
+		__field(unsigned int, client_id)
+	),
+
+	TP_fast_assign(
+		__entry->task_id = task->tk_pid;
+		__entry->client_id = task->tk_client->cl_clid;
+	),
+
+	TP_printk("task:%u@%u",
+		__entry->task_id, __entry->client_id)
+);
+
+#define DEFINE_RPC_FAILURE(name)					\
+	DEFINE_EVENT(rpc_failure, rpc_bad_##name,			\
+			TP_PROTO(					\
+				const struct rpc_task *task		\
+			),						\
+			TP_ARGS(task))
+
+DEFINE_RPC_FAILURE(callhdr);
+
 TRACE_EVENT(rpc_stats_latency,
 
 	TP_PROTO(
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index 1267f7cfe688..e3f273e9bcb9 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -749,12 +749,21 @@ put_rpccred(struct rpc_cred *cred)
 }
 EXPORT_SYMBOL_GPL(put_rpccred);
 
-__be32 *
-rpcauth_marshcred(struct rpc_task *task, __be32 *p)
+/**
+ * rpcauth_marshcred - Append RPC credential to end of @xdr
+ * @task: controlling RPC task
+ * @xdr: xdr_stream containing initial portion of RPC Call header
+ *
+ * On success, an appropriate verifier is added to @xdr, @xdr is
+ * updated to point past the verifier, and zero is returned.
+ * Otherwise, @xdr is in an undefined state and a negative errno
+ * is returned.
+ */
+int rpcauth_marshcred(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	struct rpc_cred	*cred = task->tk_rqstp->rq_cred;
+	const struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;
 
-	return cred->cr_ops->crmarshal(task, p);
+	return ops->crmarshal(task, xdr);
 }
 
 __be32 *
@@ -765,26 +774,37 @@ rpcauth_checkverf(struct rpc_task *task, __be32 *p)
 	return cred->cr_ops->crvalidate(task, p);
 }
 
-static void rpcauth_wrap_req_encode(kxdreproc_t encode, struct rpc_rqst *rqstp,
-				   __be32 *data, void *obj)
+/**
+ * rpcauth_wrap_req_encode - XDR encode the RPC procedure
+ * @task: controlling RPC task
+ * @xdr: stream where on-the-wire bytes are to be marshalled
+ *
+ * On success, @xdr contains the encoded and wrapped message.
+ * Otherwise, @xdr is in an undefined state.
+ */
+int rpcauth_wrap_req_encode(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	struct xdr_stream xdr;
+	kxdreproc_t encode = task->tk_msg.rpc_proc->p_encode;
 
-	xdr_init_encode(&xdr, &rqstp->rq_snd_buf, data, rqstp);
-	encode(rqstp, &xdr, obj);
+	encode(task->tk_rqstp, xdr, task->tk_msg.rpc_argp);
+	return 0;
 }
+EXPORT_SYMBOL_GPL(rpcauth_wrap_req_encode);
 
-int
-rpcauth_wrap_req(struct rpc_task *task, kxdreproc_t encode, void *rqstp,
-		__be32 *data, void *obj)
+/**
+ * rpcauth_wrap_req - XDR encode and wrap the RPC procedure
+ * @task: controlling RPC task
+ * @xdr: stream where on-the-wire bytes are to be marshalled
+ *
+ * On success, @xdr contains the encoded and wrapped message,
+ * and zero is returned. Otherwise, @xdr is in an undefined
+ * state and a negative errno is returned.
+ */
+int rpcauth_wrap_req(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	struct rpc_cred *cred = task->tk_rqstp->rq_cred;
+	const struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;
 
-	if (cred->cr_ops->crwrap_req)
-		return cred->cr_ops->crwrap_req(task, encode, rqstp, data, obj);
-	/* By default, we encode the arguments normally. */
-	rpcauth_wrap_req_encode(encode, rqstp, data, obj);
-	return 0;
+	return ops->crwrap_req(task, xdr);
 }
 
 static int
* Unmerged path net/sunrpc/auth_gss/auth_gss.c
diff --git a/net/sunrpc/auth_null.c b/net/sunrpc/auth_null.c
index d0ceac57c06e..797f8472c21b 100644
--- a/net/sunrpc/auth_null.c
+++ b/net/sunrpc/auth_null.c
@@ -59,15 +59,21 @@ nul_match(struct auth_cred *acred, struct rpc_cred *cred, int taskflags)
 /*
  * Marshal credential.
  */
-static __be32 *
-nul_marshal(struct rpc_task *task, __be32 *p)
+static int
+nul_marshal(struct rpc_task *task, struct xdr_stream *xdr)
 {
-	*p++ = htonl(RPC_AUTH_NULL);
-	*p++ = 0;
-	*p++ = htonl(RPC_AUTH_NULL);
-	*p++ = 0;
-
-	return p;
+	__be32 *p;
+
+	p = xdr_reserve_space(xdr, 4 * sizeof(*p));
+	if (!p)
+		return -EMSGSIZE;
+	/* Credential */
+	*p++ = rpc_auth_null;
+	*p++ = xdr_zero;
+	/* Verifier */
+	*p++ = rpc_auth_null;
+	*p   = xdr_zero;
+	return 0;
 }
 
 /*
@@ -125,6 +131,7 @@ const struct rpc_credops null_credops = {
 	.crdestroy	= nul_destroy_cred,
 	.crmatch	= nul_match,
 	.crmarshal	= nul_marshal,
+	.crwrap_req	= rpcauth_wrap_req_encode,
 	.crrefresh	= nul_refresh,
 	.crvalidate	= nul_validate,
 };
diff --git a/net/sunrpc/auth_unix.c b/net/sunrpc/auth_unix.c
index fc8a59134640..1d5b7ed9c6f7 100644
--- a/net/sunrpc/auth_unix.c
+++ b/net/sunrpc/auth_unix.c
@@ -99,37 +99,55 @@ unx_match(struct auth_cred *acred, struct rpc_cred *cred, int flags)
  * Marshal credentials.
  * Maybe we should keep a cached credential for performance reasons.
  */
-static __be32 *
-unx_marshal(struct rpc_task *task, __be32 *p)
+static int
+unx_marshal(struct rpc_task *task, struct xdr_stream *xdr)
 {
 	struct rpc_clnt	*clnt = task->tk_client;
 	struct rpc_cred	*cred = task->tk_rqstp->rq_cred;
-	__be32		*base, *hold;
+	__be32		*p, *cred_len, *gidarr_len;
 	int		i;
 	struct group_info *gi = cred->cr_cred->group_info;
 
-	*p++ = htonl(RPC_AUTH_UNIX);
-	base = p++;
-	*p++ = htonl(jiffies/HZ);
-
-	/*
-	 * Copy the UTS nodename captured when the client was created.
-	 */
-	p = xdr_encode_array(p, clnt->cl_nodename, clnt->cl_nodelen);
-
-	*p++ = htonl((u32) from_kuid(&init_user_ns, cred->cr_cred->fsuid));
-	*p++ = htonl((u32) from_kgid(&init_user_ns, cred->cr_cred->fsgid));
-	hold = p++;
+	/* Credential */
+
+	p = xdr_reserve_space(xdr, 3 * sizeof(*p));
+	if (!p)
+		goto marshal_failed;
+	*p++ = rpc_auth_unix;
+	cred_len = p++;
+	*p++ = xdr_zero;	/* stamp */
+	if (xdr_stream_encode_opaque(xdr, clnt->cl_nodename,
+				     clnt->cl_nodelen) < 0)
+		goto marshal_failed;
+	p = xdr_reserve_space(xdr, 3 * sizeof(*p));
+	if (!p)
+		goto marshal_failed;
+	*p++ = cpu_to_be32(from_kuid(&init_user_ns, cred->cr_cred->fsuid));
+	*p++ = cpu_to_be32(from_kgid(&init_user_ns, cred->cr_cred->fsgid));
+
+	gidarr_len = p++;
 	if (gi)
 		for (i = 0; i < UNX_NGROUPS && i < gi->ngroups; i++)
-			*p++ = htonl((u32) from_kgid(&init_user_ns, gi->gid[i]));
-	*hold = htonl(p - hold - 1);		/* gid array length */
-	*base = htonl((p - base - 1) << 2);	/* cred length */
+			*p++ = cpu_to_be32(from_kgid(&init_user_ns,
+						     gi->gid[i]));
+	*gidarr_len = cpu_to_be32(p - gidarr_len - 1);
+	*cred_len = cpu_to_be32((p - cred_len - 1) << 2);
+	p = xdr_reserve_space(xdr, (p - gidarr_len - 1) << 2);
+	if (!p)
+		goto marshal_failed;
+
+	/* Verifier */
+
+	p = xdr_reserve_space(xdr, 2 * sizeof(*p));
+	if (!p)
+		goto marshal_failed;
+	*p++ = rpc_auth_null;
+	*p   = xdr_zero;
 
-	*p++ = htonl(RPC_AUTH_NULL);
-	*p++ = htonl(0);
+	return 0;
 
-	return p;
+marshal_failed:
+	return -EMSGSIZE;
 }
 
 /*
@@ -202,6 +220,7 @@ const struct rpc_credops unix_credops = {
 	.crdestroy	= unx_destroy_cred,
 	.crmatch	= unx_match,
 	.crmarshal	= unx_marshal,
+	.crwrap_req	= rpcauth_wrap_req_encode,
 	.crrefresh	= unx_refresh,
 	.crvalidate	= unx_validate,
 };
* Unmerged path net/sunrpc/clnt.c
