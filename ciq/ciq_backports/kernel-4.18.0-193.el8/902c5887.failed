SUNRPC: Fix up the back channel transmit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 902c58872e1e9a2c146a55b0701c0b26cc5a4b24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/902c5887.failed

Fix up the back channel code to recognise that it has already been
transmitted, so does not need to be called again.
Also ensure that we set req->rq_task.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 902c58872e1e9a2c146a55b0701c0b26cc5a4b24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
#	net/sunrpc/xprt.c
diff --cc net/sunrpc/clnt.c
index d6ca4ed0e072,dcefbf406482..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1137,10 -1138,10 +1137,9 @@@ EXPORT_SYMBOL_GPL(rpc_call_async)
  struct rpc_task *rpc_run_bc_task(struct rpc_rqst *req)
  {
  	struct rpc_task *task;
- 	struct xdr_buf *xbufp = &req->rq_snd_buf;
  	struct rpc_task_setup task_setup_data = {
  		.callback_ops = &rpc_default_ops,
 -		.flags = RPC_TASK_SOFTCONN |
 -			RPC_TASK_NO_RETRANS_TIMEOUT,
 +		.flags = RPC_TASK_SOFTCONN,
  	};
  
  	dprintk("RPC: rpc_run_bc_task req= %p\n", req);
@@@ -1148,15 -1149,7 +1147,19 @@@
  	 * Create an rpc_task to send the data
  	 */
  	task = rpc_new_task(&task_setup_data);
++<<<<<<< HEAD
 +	task->tk_rqstp = req;
 +
 +	/*
 +	 * Set up the xdr_buf length.
 +	 * This also indicates that the buffer is XDR encoded already.
 +	 */
 +	xbufp->len = xbufp->head[0].iov_len + xbufp->page_len +
 +			xbufp->tail[0].iov_len;
 +	set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
++=======
+ 	xprt_init_bc_request(req, task);
++>>>>>>> 902c58872e1e (SUNRPC: Fix up the back channel transmit)
  
  	task->tk_action = call_bc_transmit;
  	atomic_inc(&task->tk_count);
@@@ -2053,6 -2054,11 +2056,14 @@@ call_bc_transmit(struct rpc_task *task
  {
  	struct rpc_rqst *req = task->tk_rqstp;
  
++<<<<<<< HEAD
++=======
+ 	if (rpc_task_need_encode(task))
+ 		xprt_request_enqueue_transmit(task);
+ 	if (!test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate))
+ 		goto out_wakeup;
+ 
++>>>>>>> 902c58872e1e (SUNRPC: Fix up the back channel transmit)
  	if (!xprt_prepare_transmit(task))
  		goto out_retry;
  
diff --cc net/sunrpc/xprt.c
index cc25632c1df5,f5be739492d4..000000000000
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@@ -1285,7 -1424,7 +1291,11 @@@ xprt_request_init(struct rpc_task *task
  	req->rq_xprt    = xprt;
  	req->rq_buffer  = NULL;
  	req->rq_xid	= xprt_alloc_xid(xprt);
++<<<<<<< HEAD
 +	req->rq_connect_cookie = xprt->connect_cookie - 1;
++=======
+ 	xprt_init_connect_cookie(req, xprt);
++>>>>>>> 902c58872e1e (SUNRPC: Fix up the back channel transmit)
  	req->rq_bytes_sent = 0;
  	req->rq_snd_buf.len = 0;
  	req->rq_snd_buf.buflen = 0;
diff --git a/include/linux/sunrpc/bc_xprt.h b/include/linux/sunrpc/bc_xprt.h
index 6a6ea3a8f7eb..4e8c773d02be 100644
--- a/include/linux/sunrpc/bc_xprt.h
+++ b/include/linux/sunrpc/bc_xprt.h
@@ -34,6 +34,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifdef CONFIG_SUNRPC_BACKCHANNEL
 struct rpc_rqst *xprt_lookup_bc_request(struct rpc_xprt *xprt, __be32 xid);
 void xprt_complete_bc_request(struct rpc_rqst *req, uint32_t copied);
+void xprt_init_bc_request(struct rpc_rqst *req, struct rpc_task *task);
 void xprt_free_bc_request(struct rpc_rqst *req);
 int xprt_setup_backchannel(struct rpc_xprt *, unsigned int min_reqs);
 void xprt_destroy_backchannel(struct rpc_xprt *, unsigned int max_reqs);
* Unmerged path net/sunrpc/clnt.c
* Unmerged path net/sunrpc/xprt.c
