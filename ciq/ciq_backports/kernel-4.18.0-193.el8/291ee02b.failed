libbpf: Refactor bpf_object__open APIs to use common opts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 291ee02b5e407eb1eb99c9eeaa968ef8a0c16949
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/291ee02b.failed

Refactor all the various bpf_object__open variations to ultimately
specify common bpf_object_open_opts struct. This makes it easy to keep
extending this common struct w/ extra parameters without having to
update all the legacy APIs.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20191015182849.3922287-3-andriin@fb.com
(cherry picked from commit 291ee02b5e407eb1eb99c9eeaa968ef8a0c16949)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index 70dc223cca5a,db3308b91806..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -2648,55 -3552,14 +2648,63 @@@ bpf_object__load_progs(struct bpf_objec
  	return 0;
  }
  
 +static bool bpf_prog_type__needs_kver(enum bpf_prog_type type)
 +{
 +	switch (type) {
 +	case BPF_PROG_TYPE_SOCKET_FILTER:
 +	case BPF_PROG_TYPE_SCHED_CLS:
 +	case BPF_PROG_TYPE_SCHED_ACT:
 +	case BPF_PROG_TYPE_XDP:
 +	case BPF_PROG_TYPE_CGROUP_SKB:
 +	case BPF_PROG_TYPE_CGROUP_SOCK:
 +	case BPF_PROG_TYPE_LWT_IN:
 +	case BPF_PROG_TYPE_LWT_OUT:
 +	case BPF_PROG_TYPE_LWT_XMIT:
 +	case BPF_PROG_TYPE_LWT_SEG6LOCAL:
 +	case BPF_PROG_TYPE_SOCK_OPS:
 +	case BPF_PROG_TYPE_SK_SKB:
 +	case BPF_PROG_TYPE_CGROUP_DEVICE:
 +	case BPF_PROG_TYPE_SK_MSG:
 +	case BPF_PROG_TYPE_CGROUP_SOCK_ADDR:
 +	case BPF_PROG_TYPE_LIRC_MODE2:
 +	case BPF_PROG_TYPE_SK_REUSEPORT:
 +	case BPF_PROG_TYPE_FLOW_DISSECTOR:
 +	case BPF_PROG_TYPE_UNSPEC:
 +	case BPF_PROG_TYPE_TRACEPOINT:
 +	case BPF_PROG_TYPE_RAW_TRACEPOINT:
 +	case BPF_PROG_TYPE_PERF_EVENT:
 +	case BPF_PROG_TYPE_CGROUP_SYSCTL:
 +	case BPF_PROG_TYPE_CGROUP_SOCKOPT:
 +		return false;
 +	case BPF_PROG_TYPE_KPROBE:
 +	default:
 +		return true;
 +	}
 +}
 +
 +static int bpf_object__validate(struct bpf_object *obj, bool needs_kver)
 +{
 +	if (needs_kver && obj->kern_version == 0) {
 +		pr_warning("%s doesn't provide kernel version\n",
 +			   obj->path);
 +		return -LIBBPF_ERRNO__KVERSION;
 +	}
 +	return 0;
 +}
 +
  static struct bpf_object *
++<<<<<<< HEAD
 +__bpf_object__open(const char *path, void *obj_buf, size_t obj_buf_sz,
 +		   bool needs_kver, int flags)
++=======
+ __bpf_object__open(const char *path, const void *obj_buf, size_t obj_buf_sz,
+ 		   struct bpf_object_open_opts *opts)
++>>>>>>> 291ee02b5e40 (libbpf: Refactor bpf_object__open APIs to use common opts)
  {
  	struct bpf_object *obj;
+ 	const char *obj_name;
+ 	char tmp_name[64];
+ 	bool relaxed_maps;
  	int err;
  
  	if (elf_version(EV_CURRENT) == EV_NONE) {
@@@ -2704,7 -3568,22 +2713,26 @@@
  		return ERR_PTR(-LIBBPF_ERRNO__LIBELF);
  	}
  
++<<<<<<< HEAD
 +	obj = bpf_object__new(path, obj_buf, obj_buf_sz);
++=======
+ 	if (!OPTS_VALID(opts, bpf_object_open_opts))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	obj_name = OPTS_GET(opts, object_name, path);
+ 	if (obj_buf) {
+ 		if (!obj_name) {
+ 			snprintf(tmp_name, sizeof(tmp_name), "%lx-%lx",
+ 				 (unsigned long)obj_buf,
+ 				 (unsigned long)obj_buf_sz);
+ 			obj_name = tmp_name;
+ 		}
+ 		path = obj_name;
+ 		pr_debug("loading object '%s' from buffer\n", obj_name);
+ 	}
+ 
+ 	obj = bpf_object__new(path, obj_buf, obj_buf_sz, obj_name);
++>>>>>>> 291ee02b5e40 (libbpf: Refactor bpf_object__open APIs to use common opts)
  	if (IS_ERR(obj))
  		return obj;
  
@@@ -2711,9 -3592,8 +2741,9 @@@
  	CHECK_ERR(bpf_object__elf_init(obj), err, out);
  	CHECK_ERR(bpf_object__check_endianness(obj), err, out);
  	CHECK_ERR(bpf_object__probe_caps(obj), err, out);
- 	CHECK_ERR(bpf_object__elf_collect(obj, flags), err, out);
+ 	CHECK_ERR(bpf_object__elf_collect(obj, relaxed_maps), err, out);
  	CHECK_ERR(bpf_object__collect_reloc(obj), err, out);
 +	CHECK_ERR(bpf_object__validate(obj, needs_kver), err, out);
  
  	bpf_object__elf_finish(obj);
  	return obj;
@@@ -2722,18 -3602,19 +2752,26 @@@ out
  	return ERR_PTR(err);
  }
  
 -static struct bpf_object *
 -__bpf_object__open_xattr(struct bpf_object_open_attr *attr, int flags)
 +struct bpf_object *__bpf_object__open_xattr(struct bpf_object_open_attr *attr,
 +					    int flags)
  {
+ 	LIBBPF_OPTS(bpf_object_open_opts, opts,
+ 		.relaxed_maps = flags & MAPS_RELAX_COMPAT,
+ 	);
+ 
  	/* param validation */
  	if (!attr->file)
  		return NULL;
  
  	pr_debug("loading %s\n", attr->file);
++<<<<<<< HEAD
 +
 +	return __bpf_object__open(attr->file, NULL, 0,
 +				  bpf_prog_type__needs_kver(attr->prog_type),
 +				  flags);
++=======
+ 	return __bpf_object__open(attr->file, NULL, 0, &opts);
++>>>>>>> 291ee02b5e40 (libbpf: Refactor bpf_object__open APIs to use common opts)
  }
  
  struct bpf_object *bpf_object__open_xattr(struct bpf_object_open_attr *attr)
@@@ -2751,25 -3632,42 +2789,64 @@@ struct bpf_object *bpf_object__open(con
  	return bpf_object__open_xattr(&attr);
  }
  
++<<<<<<< HEAD
 +struct bpf_object *bpf_object__open_buffer(void *obj_buf,
 +					   size_t obj_buf_sz,
 +					   const char *name)
 +{
 +	char tmp_name[64];
 +
 +	/* param validation */
 +	if (!obj_buf || obj_buf_sz <= 0)
 +		return NULL;
 +
 +	if (!name) {
 +		snprintf(tmp_name, sizeof(tmp_name), "%lx-%lx",
 +			 (unsigned long)obj_buf,
 +			 (unsigned long)obj_buf_sz);
 +		name = tmp_name;
 +	}
 +	pr_debug("loading object '%s' from buffer\n", name);
 +
 +	return __bpf_object__open(name, obj_buf, obj_buf_sz, true, true);
++=======
+ struct bpf_object *
+ bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts)
+ {
+ 	if (!path)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	pr_debug("loading %s\n", path);
+ 
+ 	return __bpf_object__open(path, NULL, 0, opts);
+ }
+ 
+ struct bpf_object *
+ bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
+ 		     struct bpf_object_open_opts *opts)
+ {
+ 	if (!obj_buf || obj_buf_sz == 0)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return __bpf_object__open(NULL, obj_buf, obj_buf_sz, opts);
+ }
+ 
+ struct bpf_object *
+ bpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,
+ 			const char *name)
+ {
+ 	LIBBPF_OPTS(bpf_object_open_opts, opts,
+ 		.object_name = name,
+ 		/* wrong default, but backwards-compatible */
+ 		.relaxed_maps = true,
+ 	);
+ 
+ 	/* returning NULL is wrong, but backwards-compatible */
+ 	if (!obj_buf || obj_buf_sz == 0)
+ 		return NULL;
+ 
+ 	return bpf_object__open_mem(obj_buf, obj_buf_sz, &opts);
++>>>>>>> 291ee02b5e40 (libbpf: Refactor bpf_object__open APIs to use common opts)
  }
  
  int bpf_object__unload(struct bpf_object *obj)
* Unmerged path tools/lib/bpf/libbpf.c
