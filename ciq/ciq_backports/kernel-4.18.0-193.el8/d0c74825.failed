s390/qeth: defer RX modesetting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit d0c748256611f8612728bcbf9933eb103c077763
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d0c74825.failed

.ndo_set_rx_mode gets called in process context, but while holding the
addr_list spinlock. Which means we currently can't sleep while
re-programming the HW, and need to poll for IO completion. That's bad,
in particular since receiving the cmd response can fail silently and
we're then polling until the timeout hits.

As a first step towards eliminating the IO completion polling, run the
RX modeset from a work element and only take the addr_list lock while
updating the RX mode address cache.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d0c748256611f8612728bcbf9933eb103c077763)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 0a2c8843d8cb,437a399d5557..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -292,12 -291,11 +292,18 @@@ static void qeth_l2_stop_card(struct qe
  	QETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));
  
  	qeth_set_allowed_threads(card, 0, 1);
++<<<<<<< HEAD
 +	if (card->read.state == CH_STATE_UP &&
 +	    card->write.state == CH_STATE_UP &&
 +	    card->state == CARD_STATE_UP)
 +		card->state = CARD_STATE_SOFTSETUP;
++=======
+ 
+ 	cancel_work_sync(&card->rx_mode_work);
+ 	qeth_l2_drain_rx_mode_cache(card);
+ 
++>>>>>>> d0c748256611 (s390/qeth: defer RX modesetting)
  	if (card->state == CARD_STATE_SOFTSETUP) {
- 		qeth_l2_del_all_macs(card);
  		qeth_clear_ipacmd_list(card);
  		card->state = CARD_STATE_HARDSETUP;
  	}
diff --cc drivers/s390/net/qeth_l3_main.c
index 8322b3859bdf,b6df38f092e6..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1413,6 -1416,10 +1417,13 @@@ static void qeth_l3_stop_card(struct qe
  	QETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));
  
  	qeth_set_allowed_threads(card, 0, 1);
++<<<<<<< HEAD
++=======
+ 
+ 	cancel_work_sync(&card->rx_mode_work);
+ 	qeth_l3_drain_rx_mode_cache(card);
+ 
++>>>>>>> d0c748256611 (s390/qeth: defer RX modesetting)
  	if (card->options.sniffer &&
  	    (card->info.promisc_mode == SET_PROMISC_MODE_ON))
  		qeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_DISABLE);
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 43763e505604..ae3f44cafcb3 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -767,6 +767,7 @@ struct qeth_card {
 	DECLARE_HASHTABLE(mac_htable, 4);
 	DECLARE_HASHTABLE(ip_htable, 4);
 	DECLARE_HASHTABLE(ip_mc_htable, 4);
+	struct work_struct rx_mode_work;
 	struct work_struct kernel_thread_starter;
 	spinlock_t thread_mask_lock;
 	unsigned long thread_start_mask;
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
