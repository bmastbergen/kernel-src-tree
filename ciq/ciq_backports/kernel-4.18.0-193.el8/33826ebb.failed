fuse: convert writepages to simple api

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 33826ebbbe4b45ccecf2f5a08b3457f5d59c6282
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/33826ebb.failed

Derive fuse_writepage_args from fuse_io_args.

Sending the request is tricky since it was done with fi->lock held, hence
we must either use atomic allocation or release the lock.  Both are
possible so try atomic first and if it fails, release the lock and do the
regular allocation with GFP_NOFS and __GFP_NOFAIL.  Both flags are
necessary for correct operation.

Move the page realloc function from dev.c to file.c and convert to using
fuse_writepage_args.

The last caller of fuse_write_fill() is gone, so get rid of it.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 33826ebbbe4b45ccecf2f5a08b3457f5d59c6282)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index 73aa881f4e49,399b89b29bb4..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1598,21 -1594,20 +1589,34 @@@ static void fuse_writepage_finish(struc
  	wake_up(&fi->page_waitq);
  }
  
++<<<<<<< HEAD
 +/* Called under fc->lock, may release and reacquire it */
 +static void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,
 +				loff_t size)
 +__releases(fc->lock)
 +__acquires(fc->lock)
- {
- 	struct fuse_req *aux, *next;
- 	struct fuse_inode *fi = get_fuse_inode(req->inode);
- 	struct fuse_write_in *inarg = &req->misc.write.in;
- 	__u64 data_size = req->num_pages * PAGE_SIZE;
- 	bool queued;
++=======
+ /* Called under fi->lock, may release and reacquire it */
+ static void fuse_send_writepage(struct fuse_conn *fc,
+ 				struct fuse_writepage_args *wpa, loff_t size)
+ __releases(fi->lock)
+ __acquires(fi->lock)
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
+ {
+ 	struct fuse_writepage_args *aux, *next;
+ 	struct fuse_inode *fi = get_fuse_inode(wpa->inode);
+ 	struct fuse_write_in *inarg = &wpa->ia.write.in;
+ 	struct fuse_args *args = &wpa->ia.ap.args;
+ 	__u64 data_size = wpa->ia.ap.num_pages * PAGE_SIZE;
+ 	int err;
  
++<<<<<<< HEAD
 +	if (!fc->connected)
 +		goto out_free;
 +
++=======
+ 	fi->writectr++;
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  	if (inarg->offset + data_size <= size) {
  		inarg->size = data_size;
  	} else if (inarg->offset < size) {
@@@ -1622,27 -1617,37 +1626,55 @@@
  		goto out_free;
  	}
  
++<<<<<<< HEAD
 +	req->in.args[1].size = inarg->size;
 +	fi->writectr++;
 +	queued = fuse_request_queue_background(fc, req);
 +	WARN_ON(!queued);
 +	return;
 +
 + out_free:
 +	fuse_writepage_finish(fc, req);
 +	spin_unlock(&fc->lock);
++=======
+ 	args->in_args[1].size = inarg->size;
+ 	args->force = true;
+ 	args->nocreds = true;
+ 
+ 	err = fuse_simple_background(fc, args, GFP_ATOMIC);
+ 	if (err == -ENOMEM) {
+ 		spin_unlock(&fi->lock);
+ 		err = fuse_simple_background(fc, args, GFP_NOFS | __GFP_NOFAIL);
+ 		spin_lock(&fi->lock);
+ 	}
+ 
+ 	/* Fails on broken connection only */
+ 	if (unlikely(err))
+ 		goto out_free;
+ 
+ 	return;
+ 
+  out_free:
+ 	fi->writectr--;
+ 	fuse_writepage_finish(fc, wpa);
+ 	spin_unlock(&fi->lock);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  
  	/* After fuse_writepage_finish() aux request list is private */
- 	for (aux = req->misc.write.next; aux; aux = next) {
- 		next = aux->misc.write.next;
- 		aux->misc.write.next = NULL;
- 		fuse_writepage_free(fc, aux);
- 		fuse_put_request(fc, aux);
+ 	for (aux = wpa->next; aux; aux = next) {
+ 		next = aux->next;
+ 		aux->next = NULL;
+ 		fuse_writepage_free(aux);
  	}
  
++<<<<<<< HEAD
 +	fuse_writepage_free(fc, req);
 +	fuse_put_request(fc, req);
 +	spin_lock(&fc->lock);
++=======
+ 	fuse_writepage_free(wpa);
+ 	spin_lock(&fi->lock);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  }
  
  /*
@@@ -1667,20 -1673,24 +1700,30 @@@ __acquires(fc->lock
  	}
  }
  
- static void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)
+ static void fuse_writepage_end(struct fuse_conn *fc, struct fuse_args *args,
+ 			       int error)
  {
- 	struct inode *inode = req->inode;
+ 	struct fuse_writepage_args *wpa =
+ 		container_of(args, typeof(*wpa), ia.ap.args);
+ 	struct inode *inode = wpa->inode;
  	struct fuse_inode *fi = get_fuse_inode(inode);
  
++<<<<<<< HEAD
 +	mapping_set_error(inode->i_mapping, req->out.h.error);
 +	spin_lock(&fc->lock);
 +	while (req->misc.write.next) {
++=======
+ 	mapping_set_error(inode->i_mapping, error);
+ 	spin_lock(&fi->lock);
+ 	while (wpa->next) {
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  		struct fuse_conn *fc = get_fuse_conn(inode);
- 		struct fuse_write_in *inarg = &req->misc.write.in;
- 		struct fuse_req *next = req->misc.write.next;
- 		req->misc.write.next = next->misc.write.next;
- 		next->misc.write.next = NULL;
- 		next->ff = fuse_file_get(req->ff);
+ 		struct fuse_write_in *inarg = &wpa->ia.write.in;
+ 		struct fuse_writepage_args *next = wpa->next;
+ 
+ 		wpa->next = next->next;
+ 		next->next = NULL;
+ 		next->ia.ff = fuse_file_get(wpa->ia.ff);
  		list_add(&next->writepages_entry, &fi->writepages);
  
  		/*
@@@ -1709,9 -1719,9 +1752,15 @@@
  		fuse_send_writepage(fc, next, inarg->offset + inarg->size);
  	}
  	fi->writectr--;
++<<<<<<< HEAD
 +	fuse_writepage_finish(fc, req);
 +	spin_unlock(&fc->lock);
 +	fuse_writepage_free(fc, req);
++=======
+ 	fuse_writepage_finish(fc, wpa);
+ 	spin_unlock(&fi->lock);
+ 	fuse_writepage_free(wpa);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  }
  
  static struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,
@@@ -1796,11 -1825,11 +1864,17 @@@ static int fuse_writepage_locked(struc
  	inc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);
  	inc_node_page_state(tmp_page, NR_WRITEBACK_TEMP);
  
++<<<<<<< HEAD
 +	spin_lock(&fc->lock);
 +	list_add(&req->writepages_entry, &fi->writepages);
 +	list_add_tail(&req->list, &fi->queued_writes);
++=======
+ 	spin_lock(&fi->lock);
+ 	list_add(&wpa->writepages_entry, &fi->writepages);
+ 	list_add_tail(&wpa->queue_entry, &fi->queued_writes);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  	fuse_flush_writepages(inode);
 -	spin_unlock(&fi->lock);
 +	spin_unlock(&fc->lock);
  
  	end_page_writeback(page);
  
@@@ -1843,22 -1872,48 +1917,55 @@@ struct fuse_fill_wb_data 
  	struct fuse_file *ff;
  	struct inode *inode;
  	struct page **orig_pages;
+ 	unsigned int max_pages;
  };
  
+ static bool fuse_pages_realloc(struct fuse_fill_wb_data *data)
+ {
+ 	struct fuse_args_pages *ap = &data->wpa->ia.ap;
+ 	struct fuse_conn *fc = get_fuse_conn(data->inode);
+ 	struct page **pages;
+ 	struct fuse_page_desc *descs;
+ 	unsigned int npages = min_t(unsigned int,
+ 				    max_t(unsigned int, data->max_pages * 2,
+ 					  FUSE_DEFAULT_MAX_PAGES_PER_REQ),
+ 				    fc->max_pages);
+ 	WARN_ON(npages <= data->max_pages);
+ 
+ 	pages = fuse_pages_alloc(npages, GFP_NOFS, &descs);
+ 	if (!pages)
+ 		return false;
+ 
+ 	memcpy(pages, ap->pages, sizeof(struct page *) * ap->num_pages);
+ 	memcpy(descs, ap->descs, sizeof(struct fuse_page_desc) * ap->num_pages);
+ 	kfree(ap->pages);
+ 	ap->pages = pages;
+ 	ap->descs = descs;
+ 	data->max_pages = npages;
+ 
+ 	return true;
+ }
+ 
  static void fuse_writepages_send(struct fuse_fill_wb_data *data)
  {
- 	struct fuse_req *req = data->req;
+ 	struct fuse_writepage_args *wpa = data->wpa;
  	struct inode *inode = data->inode;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
  	struct fuse_inode *fi = get_fuse_inode(inode);
- 	int num_pages = req->num_pages;
+ 	int num_pages = wpa->ia.ap.num_pages;
  	int i;
  
++<<<<<<< HEAD
 +	req->ff = fuse_file_get(data->ff);
 +	spin_lock(&fc->lock);
 +	list_add_tail(&req->list, &fi->queued_writes);
++=======
+ 	wpa->ia.ff = fuse_file_get(data->ff);
+ 	spin_lock(&fi->lock);
+ 	list_add_tail(&wpa->queue_entry, &fi->queued_writes);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  	fuse_flush_writepages(inode);
 -	spin_unlock(&fi->lock);
 +	spin_unlock(&fc->lock);
  
  	for (i = 0; i < num_pages; i++)
  		end_page_writeback(data->orig_pages[i]);
@@@ -1871,22 -1926,22 +1978,31 @@@
   * this new request onto the auxiliary list, otherwise reuse the existing one by
   * copying the new page contents over to the old temporary page.
   */
- static bool fuse_writepage_in_flight(struct fuse_req *new_req,
+ static bool fuse_writepage_in_flight(struct fuse_writepage_args *new_wpa,
  				     struct page *page)
  {
- 	struct fuse_conn *fc = get_fuse_conn(new_req->inode);
- 	struct fuse_inode *fi = get_fuse_inode(new_req->inode);
- 	struct fuse_req *tmp;
- 	struct fuse_req *old_req;
+ 	struct fuse_inode *fi = get_fuse_inode(new_wpa->inode);
+ 	struct fuse_writepage_args *tmp;
+ 	struct fuse_writepage_args *old_wpa;
+ 	struct fuse_args_pages *new_ap = &new_wpa->ia.ap;
  
- 	WARN_ON(new_req->num_pages != 0);
+ 	WARN_ON(new_ap->num_pages != 0);
  
++<<<<<<< HEAD
 +	spin_lock(&fc->lock);
 +	list_del(&new_req->writepages_entry);
 +	old_req = fuse_find_writeback(fi, page->index, page->index);
 +	if (!old_req) {
 +		list_add(&new_req->writepages_entry, &fi->writepages);
 +		spin_unlock(&fc->lock);
++=======
+ 	spin_lock(&fi->lock);
+ 	list_del(&new_wpa->writepages_entry);
+ 	old_wpa = fuse_find_writeback(fi, page->index, page->index);
+ 	if (!old_wpa) {
+ 		list_add(&new_wpa->writepages_entry, &fi->writepages);
+ 		spin_unlock(&fi->lock);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  		return false;
  	}
  
@@@ -1905,20 -1959,19 +2020,19 @@@
  	}
  
  	if (!tmp) {
- 		new_req->misc.write.next = old_req->misc.write.next;
- 		old_req->misc.write.next = new_req;
+ 		new_wpa->next = old_wpa->next;
+ 		old_wpa->next = new_wpa;
  	}
  
 -	spin_unlock(&fi->lock);
 +	spin_unlock(&fc->lock);
  
  	if (tmp) {
- 		struct backing_dev_info *bdi = inode_to_bdi(new_req->inode);
+ 		struct backing_dev_info *bdi = inode_to_bdi(new_wpa->inode);
  
  		dec_wb_stat(&bdi->wb, WB_WRITEBACK);
- 		dec_node_page_state(new_req->pages[0], NR_WRITEBACK_TEMP);
+ 		dec_node_page_state(new_ap->pages[0], NR_WRITEBACK_TEMP);
  		wb_writeout_inc(&bdi->wb);
- 		fuse_writepage_free(fc, new_req);
- 		fuse_request_free(new_req);
+ 		fuse_writepage_free(new_wpa);
  	}
  
  	return true;
@@@ -1928,8 -1981,10 +2042,9 @@@ static int fuse_writepages_fill(struct 
  		struct writeback_control *wbc, void *_data)
  {
  	struct fuse_fill_wb_data *data = _data;
- 	struct fuse_req *req = data->req;
+ 	struct fuse_writepage_args *wpa = data->wpa;
+ 	struct fuse_args_pages *ap = &wpa->ia.ap;
  	struct inode *inode = data->inode;
 -	struct fuse_inode *fi = get_fuse_inode(inode);
  	struct fuse_conn *fc = get_fuse_conn(inode);
  	struct page *tmp_page;
  	bool is_writeback;
@@@ -1990,21 -2045,22 +2105,28 @@@
  			__free_page(tmp_page);
  			goto out_unlock;
  		}
- 
- 		fuse_write_fill(req, data->ff, page_offset(page), 0);
- 		req->misc.write.in.write_flags |= FUSE_WRITE_CACHE;
- 		req->misc.write.next = NULL;
- 		req->in.argpages = 1;
- 		__set_bit(FR_BACKGROUND, &req->flags);
- 		req->num_pages = 0;
- 		req->end = fuse_writepage_end;
- 		req->inode = inode;
- 
+ 		data->max_pages = 1;
+ 
+ 		ap = &wpa->ia.ap;
+ 		fuse_write_args_fill(&wpa->ia, data->ff, page_offset(page), 0);
+ 		wpa->ia.write.in.write_flags |= FUSE_WRITE_CACHE;
+ 		wpa->next = NULL;
+ 		ap->args.in_pages = true;
+ 		ap->args.end = fuse_writepage_end;
+ 		ap->num_pages = 0;
+ 		wpa->inode = inode;
+ 
++<<<<<<< HEAD
 +		spin_lock(&fc->lock);
 +		list_add(&req->writepages_entry, &fi->writepages);
 +		spin_unlock(&fc->lock);
++=======
+ 		spin_lock(&fi->lock);
+ 		list_add(&wpa->writepages_entry, &fi->writepages);
+ 		spin_unlock(&fi->lock);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  
- 		data->req = req;
+ 		data->wpa = wpa;
  	}
  	set_page_writeback(page);
  
@@@ -2017,20 -2073,20 +2139,26 @@@
  	inc_node_page_state(tmp_page, NR_WRITEBACK_TEMP);
  
  	err = 0;
- 	if (is_writeback && fuse_writepage_in_flight(req, page)) {
+ 	if (is_writeback && fuse_writepage_in_flight(wpa, page)) {
  		end_page_writeback(page);
- 		data->req = NULL;
+ 		data->wpa = NULL;
  		goto out_unlock;
  	}
- 	data->orig_pages[req->num_pages] = page;
+ 	data->orig_pages[ap->num_pages] = page;
  
  	/*
 -	 * Protected by fi->lock against concurrent access by
 +	 * Protected by fc->lock against concurrent access by
  	 * fuse_page_is_writeback().
  	 */
++<<<<<<< HEAD
 +	spin_lock(&fc->lock);
 +	req->num_pages++;
 +	spin_unlock(&fc->lock);
++=======
+ 	spin_lock(&fi->lock);
+ 	ap->num_pages++;
+ 	spin_unlock(&fi->lock);
++>>>>>>> 33826ebbbe4b (fuse: convert writepages to simple api)
  
  out_unlock:
  	unlock_page(page);
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index b4af1d942b5e..21138ae67842 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -96,33 +96,6 @@ static void fuse_req_pages_free(struct fuse_req *req)
 		kfree(req->pages);
 }
 
-bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
-			    gfp_t flags)
-{
-	struct page **pages;
-	struct fuse_page_desc *page_descs;
-	unsigned int npages = min_t(unsigned int,
-				    max_t(unsigned int, req->max_pages * 2,
-					  FUSE_DEFAULT_MAX_PAGES_PER_REQ),
-				    fc->max_pages);
-	WARN_ON(npages <= req->max_pages);
-
-	pages = fuse_pages_alloc(npages, flags, &page_descs);
-	if (!pages)
-		return false;
-
-	memcpy(pages, req->pages, sizeof(struct page *) * req->max_pages);
-	memcpy(page_descs, req->page_descs,
-	       sizeof(struct fuse_page_desc) * req->max_pages);
-	fuse_req_pages_free(req);
-	__set_bit(FR_ALLOC_PAGES, &req->flags);
-	req->pages = pages;
-	req->page_descs = page_descs;
-	req->max_pages = npages;
-
-	return true;
-}
-
 void fuse_request_free(struct fuse_req *req)
 {
 	fuse_req_pages_free(req);
* Unmerged path fs/fuse/file.c
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4222d0e679e1..11ba0f7efa41 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -920,9 +920,6 @@ struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 
 struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
 			       struct fuse_page_desc **desc);
-bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
-			    gfp_t flags);
-
 
 /**
  * Free a request
