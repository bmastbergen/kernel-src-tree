page_pool: make sure struct device is stable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit f71fec47c2df704c7081f946d7e46fe036a4208b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f71fec47.failed

For DMA mapping use-case the page_pool keeps a pointer
to the struct device, which is used in DMA map/unmap calls.

For our in-flight handling, we also need to make sure that
the struct device have not disappeared.  This is assured
via using get_device/put_device API.

	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Reported-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f71fec47c2df704c7081f946d7e46fe036a4208b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/page_pool.c
diff --cc net/core/page_pool.c
index 41391b5dc14c,b366f59885c1..000000000000
--- a/net/core/page_pool.c
+++ b/net/core/page_pool.c
@@@ -43,6 -47,11 +44,14 @@@ static int page_pool_init(struct page_p
  	if (ptr_ring_init(&pool->ring, ring_qsize, GFP_KERNEL) < 0)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	atomic_set(&pool->pages_state_release_cnt, 0);
+ 
+ 	if (pool->p.flags & PP_FLAG_DMA_MAP)
+ 		get_device(pool->p.dev);
+ 
++>>>>>>> f71fec47c2df (page_pool: make sure struct device is stable)
  	return 0;
  }
  
@@@ -297,7 -359,15 +306,11 @@@ void __page_pool_free(struct page_pool 
  	WARN(pool->alloc.count, "API usage violation");
  	WARN(!ptr_ring_empty(&pool->ring), "ptr_ring is not empty");
  
 -	/* Can happen due to forced shutdown */
 -	if (!__page_pool_safe_to_destroy(pool))
 -		__warn_in_flight(pool);
 -
  	ptr_ring_cleanup(&pool->ring, NULL);
+ 
+ 	if (pool->p.flags & PP_FLAG_DMA_MAP)
+ 		put_device(pool->p.dev);
+ 
  	kfree(pool);
  }
  EXPORT_SYMBOL(__page_pool_free);
* Unmerged path net/core/page_pool.c
