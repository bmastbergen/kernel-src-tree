selftests/bpf: add bpf-gcc support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Ilya Leoshkevich <iii@linux.ibm.com>
commit 4ce150b6a412f14074400eac5fc39d1a71c4ef0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4ce150b6.failed

Now that binutils and gcc support for BPF is upstream, make use of it in
BPF selftests using alu32-like approach. Share as much as possible of
CFLAGS calculation with clang.

Fixes only obvious issues, leaving more complex ones for later:
- Use gcc-provided bpf-helpers.h instead of manually defining the
  helpers, change bpf_helpers.h include guard to avoid conflict.
- Include <linux/stddef.h> for __always_inline.
- Add $(OUTPUT)/../usr/include to include path in order to use local
  kernel headers instead of system kernel headers when building with O=.

In order to activate the bpf-gcc support, one needs to configure
binutils and gcc with --target=bpf and make them available in $PATH. In
particular, gcc must be installed as `bpf-gcc`, which is the default.

Right now with binutils 25a2915e8dba and gcc r275589 only a handful of
tests work:

	# ./test_progs_bpf_gcc
	# Summary: 7/39 PASSED, 1 SKIPPED, 98 FAILED

The reason for those failures are as follows:

- Build errors:
  - `error: too many function arguments for eBPF` for __always_inline
    functions read_str_var and read_map_var - must be inlining issue,
    and for process_l3_headers_v6, which relies on optimizing away
    function arguments.
  - `error: indirect call in function, which are not supported by eBPF`
    where there are no obvious indirect calls in the source calls, e.g.
    in __encap_ipip_none.
  - `error: field 'lock' has incomplete type` for fields of `struct
    bpf_spin_lock` type - bpf_spin_lock is re#defined by bpf-helpers.h,
    so its usage is sensitive to order of #includes.
  - `error: eBPF stack limit exceeded` in sysctl_tcp_mem.
- Load errors:
  - Missing object files due to above build errors.
  - `libbpf: failed to create map (name: 'test_ver.bss')`.
  - `libbpf: object file doesn't contain bpf program`.
  - `libbpf: Program '.text' contains unrecognized relo data pointing to
    section 0`.
  - `libbpf: BTF is required, but is missing or corrupted` - no BTF
    support in gcc yet.

	Signed-off-by: Ilya Leoshkevich <iii@linux.ibm.com>
	Cc: Jose E. Marchesi <jose.marchesi@oracle.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 4ce150b6a412f14074400eac5fc39d1a71c4ef0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/Makefile
#	tools/testing/selftests/bpf/progs/test_tc_edt.c
diff --cc tools/testing/selftests/bpf/Makefile
index 9bfa8b025d92,6889c19a628c..000000000000
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@@ -10,37 -12,45 +10,53 @@@ ifneq ($(wildcard $(GENHDR)),
    GENFLAGS := -DHAVE_GENHDR
  endif
  
++<<<<<<< HEAD
 +CFLAGS += -Wall -O2 -I$(APIDIR) -I$(LIBDIR) -I$(BPFDIR) -I$(GENDIR) $(GENFLAGS) -I../../../include
++=======
+ CLANG		?= clang
+ LLC		?= llc
+ LLVM_OBJCOPY	?= llvm-objcopy
+ LLVM_READELF	?= llvm-readelf
+ BTF_PAHOLE	?= pahole
+ BPF_GCC		?= $(shell command -v bpf-gcc;)
+ CFLAGS += -g -Wall -O2 -I$(APIDIR) -I$(LIBDIR) -I$(BPFDIR) -I$(GENDIR) $(GENFLAGS) -I../../../include \
+ 	  -Dbpf_prog_load=bpf_prog_test_load \
+ 	  -Dbpf_load_program=bpf_test_load_program
++>>>>>>> 4ce150b6a412 (selftests/bpf: add bpf-gcc support)
  LDLIBS += -lcap -lelf -lrt -lpthread
  
 +TEST_CUSTOM_PROGS = $(OUTPUT)/urandom_read
 +all: $(TEST_CUSTOM_PROGS)
 +
 +$(TEST_CUSTOM_PROGS): $(OUTPUT)/%: %.c
 +	$(CC) -o $(TEST_CUSTOM_PROGS) $< -Wl,--build-id
 +
  # Order correspond to 'make run_tests' order
  TEST_GEN_PROGS = test_verifier test_tag test_maps test_lru_map test_lpm_map test_progs \
  	test_align test_verifier_log test_dev_cgroup test_tcpbpf_user \
 -	test_sock test_btf test_sockmap get_cgroup_id_user test_socket_cookie \
 -	test_cgroup_storage test_select_reuseport test_section_names \
 -	test_netcnt test_tcpnotify_user test_sock_fields test_sysctl test_hashmap \
 -	test_btf_dump test_cgroup_attach xdping
 -
 -BPF_OBJ_FILES = $(patsubst %.c,%.o, $(notdir $(wildcard progs/*.c)))
 -TEST_GEN_FILES = $(BPF_OBJ_FILES)
 -
 -BTF_C_FILES = $(wildcard progs/btf_dump_test_case_*.c)
 -TEST_FILES = $(BTF_C_FILES)
 -
 -# Also test sub-register code-gen if LLVM has eBPF v3 processor support which
 -# contains both ALU32 and JMP32 instructions.
 -SUBREG_CODEGEN := $(shell echo "int cal(int a) { return a > 0; }" | \
 -			$(CLANG) -target bpf -O2 -emit-llvm -S -x c - -o - | \
 -			$(LLC) -mattr=+alu32 -mcpu=v3 2>&1 | \
 -			grep 'if w')
 -ifneq ($(SUBREG_CODEGEN),)
 -TEST_GEN_FILES += $(patsubst %.o,alu32/%.o, $(BPF_OBJ_FILES))
 -endif
 +	test_sock test_btf test_sockmap test_lirc_mode2_user get_cgroup_id_user \
 +	test_socket_cookie test_cgroup_storage test_select_reuseport test_section_names \
 +	test_netcnt test_tcpnotify_user
 +
 +TEST_GEN_FILES = test_pkt_access.o test_xdp.o test_l4lb.o test_tcp_estats.o test_obj_id.o \
 +	test_pkt_md_access.o test_xdp_redirect.o test_xdp_meta.o sockmap_parse_prog.o     \
 +	sockmap_verdict_prog.o dev_cgroup.o sample_ret0.o test_tracepoint.o \
 +	test_l4lb_noinline.o test_xdp_noinline.o test_stacktrace_map.o \
 +	test_tcpnotify_kern.o \
 +	sample_map_ret0.o test_tcpbpf_kern.o test_stacktrace_build_id.o \
 +	sockmap_tcp_msg_prog.o connect4_prog.o connect6_prog.o test_adjust_tail.o \
 +	test_btf_haskv.o test_btf_nokv.o test_sockmap_kern.o test_tunnel_kern.o \
 +	test_get_stack_rawtp.o test_sockmap_kern.o test_sockhash_kern.o \
 +	test_lwt_seg6local.o sendmsg4_prog.o sendmsg6_prog.o test_lirc_mode2_kern.o \
 +	get_cgroup_id_kern.o socket_cookie_prog.o test_select_reuseport_kern.o \
 +	test_skb_cgroup_id_kern.o bpf_flow.o netcnt_prog.o \
 +	test_sk_lookup_kern.o test_xdp_vlan.o test_queue_map.o test_stack_map.o \
 +	xdp_dummy.o test_map_in_map.o
  
+ ifneq ($(BPF_GCC),)
+ TEST_GEN_FILES += $(patsubst %.o,bpf_gcc/%.o, $(BPF_OBJ_FILES))
+ endif
+ 
  # Order correspond to 'make run_tests' order
  TEST_PROGS := test_kmod.sh \
  	test_libbpf.sh \
@@@ -116,15 -142,19 +132,25 @@@ endi
  #
  # Use '-idirafter': Don't interfere with include mechanics except where the
  # build would have failed anyways.
- CLANG_SYS_INCLUDES := $(shell $(CLANG) -v -E - </dev/null 2>&1 \
+ define get_sys_includes
+ $(shell $(1) -v -E - </dev/null 2>&1 \
  	| sed -n '/<...> search starts here:/,/End of search list./{ s| \(/.*\)|-idirafter \1|p }')
+ endef
+ CLANG_SYS_INCLUDES = $(call get_sys_includes,$(CLANG))
+ BPF_CFLAGS = -I. -I./include/uapi -I../../../include/uapi \
+ 	     -I$(OUTPUT)/../usr/include -D__TARGET_ARCH_$(SRCARCH)
  
++<<<<<<< HEAD
 +CLANG_FLAGS = -I. -I./include/uapi -I../../../include/uapi \
 +	      $(CLANG_SYS_INCLUDES) \
 +	      -Wno-compare-distinct-pointer-types
++=======
+ CLANG_CFLAGS = $(CLANG_SYS_INCLUDES) \
+ 	       -Wno-compare-distinct-pointer-types
++>>>>>>> 4ce150b6a412 (selftests/bpf: add bpf-gcc support)
  
- $(OUTPUT)/test_l4lb_noinline.o: CLANG_FLAGS += -fno-inline
- $(OUTPUT)/test_xdp_noinline.o: CLANG_FLAGS += -fno-inline
+ $(OUTPUT)/test_l4lb_noinline.o: BPF_CFLAGS += -fno-inline
+ $(OUTPUT)/test_xdp_noinline.o: BPF_CFLAGS += -fno-inline
  
  $(OUTPUT)/test_queue_map.o: test_queue_stack_map.h
  $(OUTPUT)/test_stack_map.o: test_queue_stack_map.h
@@@ -154,22 -184,139 +180,157 @@@ endi
  endif
  endif
  
++<<<<<<< HEAD
 +# Have one program compiled without "-target bpf" to test whether libbpf loads
 +# it successfully
 +$(OUTPUT)/test_xdp.o: test_xdp.c
 +	$(CLANG) $(CLANG_FLAGS) \
 +		-O2 -emit-llvm -c $< -o - | \
++=======
+ TEST_PROGS_CFLAGS := -I. -I$(OUTPUT)
+ TEST_MAPS_CFLAGS := -I. -I$(OUTPUT)
+ TEST_VERIFIER_CFLAGS := -I. -I$(OUTPUT) -Iverifier
+ 
+ ifneq ($(SUBREG_CODEGEN),)
+ ALU32_BUILD_DIR = $(OUTPUT)/alu32
+ TEST_CUSTOM_PROGS += $(ALU32_BUILD_DIR)/test_progs_32
+ $(ALU32_BUILD_DIR):
+ 	mkdir -p $@
+ 
+ $(ALU32_BUILD_DIR)/urandom_read: $(OUTPUT)/urandom_read | $(ALU32_BUILD_DIR)
+ 	cp $< $@
+ 
+ $(ALU32_BUILD_DIR)/test_progs_32: test_progs.c $(OUTPUT)/libbpf.a\
+ 						$(ALU32_BUILD_DIR)/urandom_read \
+ 						| $(ALU32_BUILD_DIR)
+ 	$(CC) $(TEST_PROGS_CFLAGS) $(CFLAGS) \
+ 		-o $(ALU32_BUILD_DIR)/test_progs_32 \
+ 		test_progs.c test_stub.c cgroup_helpers.c trace_helpers.c prog_tests/*.c \
+ 		$(OUTPUT)/libbpf.a $(LDLIBS)
+ 
+ $(ALU32_BUILD_DIR)/test_progs_32: $(PROG_TESTS_H)
+ $(ALU32_BUILD_DIR)/test_progs_32: prog_tests/*.c
+ 
+ $(ALU32_BUILD_DIR)/%.o: progs/%.c $(ALU32_BUILD_DIR)/test_progs_32 \
+ 					| $(ALU32_BUILD_DIR)
+ 	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -target bpf -emit-llvm \
+ 		-c $< -o - || echo "clang failed") | \
+ 	$(LLC) -march=bpf -mattr=+alu32 -mcpu=$(CPU) $(LLC_FLAGS) \
+ 		-filetype=obj -o $@
+ ifeq ($(DWARF2BTF),y)
+ 	$(BTF_PAHOLE) -J $@
+ endif
+ endif
+ 
+ ifneq ($(BPF_GCC),)
+ GCC_SYS_INCLUDES = $(call get_sys_includes,gcc)
+ IS_LITTLE_ENDIAN = $(shell $(CC) -dM -E - </dev/null | \
+ 			grep 'define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__')
+ ifeq ($(IS_LITTLE_ENDIAN),)
+ MENDIAN=-mbig-endian
+ else
+ MENDIAN=-mlittle-endian
+ endif
+ BPF_GCC_CFLAGS = $(GCC_SYS_INCLUDES) $(MENDIAN)
+ BPF_GCC_BUILD_DIR = $(OUTPUT)/bpf_gcc
+ TEST_CUSTOM_PROGS += $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc
+ $(BPF_GCC_BUILD_DIR):
+ 	mkdir -p $@
+ 
+ $(BPF_GCC_BUILD_DIR)/urandom_read: $(OUTPUT)/urandom_read | $(BPF_GCC_BUILD_DIR)
+ 	cp $< $@
+ 
+ $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc: $(OUTPUT)/test_progs \
+ 					 | $(BPF_GCC_BUILD_DIR)
+ 	cp $< $@
+ 
+ $(BPF_GCC_BUILD_DIR)/%.o: progs/%.c $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc \
+ 			  | $(BPF_GCC_BUILD_DIR)
+ 	$(BPF_GCC) $(BPF_CFLAGS) $(BPF_GCC_CFLAGS) -O2 -c $< -o $@
+ endif
+ 
+ # Have one program compiled without "-target bpf" to test whether libbpf loads
+ # it successfully
+ $(OUTPUT)/test_xdp.o: progs/test_xdp.c
+ 	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -emit-llvm -c $< -o - || \
+ 		echo "clang failed") | \
++>>>>>>> 4ce150b6a412 (selftests/bpf: add bpf-gcc support)
  	$(LLC) -march=bpf -mcpu=$(CPU) $(LLC_FLAGS) -filetype=obj -o $@
  ifeq ($(DWARF2BTF),y)
  	$(BTF_PAHOLE) -J $@
  endif
  
++<<<<<<< HEAD
 +$(OUTPUT)/%.o: %.c
 +	$(CLANG) $(CLANG_FLAGS) \
 +		 -O2 -target bpf -emit-llvm -c $< -o - |      \
++=======
+ $(OUTPUT)/%.o: progs/%.c
+ 	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -target bpf -emit-llvm \
+ 		-c $< -o - || echo "clang failed") | \
++>>>>>>> 4ce150b6a412 (selftests/bpf: add bpf-gcc support)
  	$(LLC) -march=bpf -mcpu=$(CPU) $(LLC_FLAGS) -filetype=obj -o $@
  ifeq ($(DWARF2BTF),y)
  	$(BTF_PAHOLE) -J $@
  endif
  
++<<<<<<< HEAD
 +EXTRA_CLEAN := $(TEST_CUSTOM_PROGS)
++=======
+ PROG_TESTS_DIR = $(OUTPUT)/prog_tests
+ $(PROG_TESTS_DIR):
+ 	mkdir -p $@
+ PROG_TESTS_H := $(PROG_TESTS_DIR)/tests.h
+ PROG_TESTS_FILES := $(wildcard prog_tests/*.c)
+ test_progs.c: $(PROG_TESTS_H)
+ $(OUTPUT)/test_progs: CFLAGS += $(TEST_PROGS_CFLAGS)
+ $(OUTPUT)/test_progs: test_progs.c $(PROG_TESTS_FILES) | $(PROG_TESTS_H)
+ $(PROG_TESTS_H): $(PROG_TESTS_FILES) | $(PROG_TESTS_DIR)
+ 	$(shell ( cd prog_tests/; \
+ 		  echo '/* Generated header, do not edit */'; \
+ 		  ls *.c 2> /dev/null | \
+ 			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@'; \
+ 		 ) > $(PROG_TESTS_H))
+ 
+ MAP_TESTS_DIR = $(OUTPUT)/map_tests
+ $(MAP_TESTS_DIR):
+ 	mkdir -p $@
+ MAP_TESTS_H := $(MAP_TESTS_DIR)/tests.h
+ MAP_TESTS_FILES := $(wildcard map_tests/*.c)
+ test_maps.c: $(MAP_TESTS_H)
+ $(OUTPUT)/test_maps: CFLAGS += $(TEST_MAPS_CFLAGS)
+ $(OUTPUT)/test_maps: test_maps.c $(MAP_TESTS_FILES) | $(MAP_TESTS_H)
+ $(MAP_TESTS_H): $(MAP_TESTS_FILES) | $(MAP_TESTS_DIR)
+ 	$(shell ( cd map_tests/; \
+ 		  echo '/* Generated header, do not edit */'; \
+ 		  echo '#ifdef DECLARE'; \
+ 		  ls *.c 2> /dev/null | \
+ 			sed -e 's@\([^\.]*\)\.c@extern void test_\1(void);@'; \
+ 		  echo '#endif'; \
+ 		  echo '#ifdef CALL'; \
+ 		  ls *.c 2> /dev/null | \
+ 			sed -e 's@\([^\.]*\)\.c@test_\1();@'; \
+ 		  echo '#endif' \
+ 		 ) > $(MAP_TESTS_H))
+ 
+ VERIFIER_TESTS_DIR = $(OUTPUT)/verifier
+ $(VERIFIER_TESTS_DIR):
+ 	mkdir -p $@
+ VERIFIER_TESTS_H := $(VERIFIER_TESTS_DIR)/tests.h
+ VERIFIER_TEST_FILES := $(wildcard verifier/*.c)
+ test_verifier.c: $(VERIFIER_TESTS_H)
+ $(OUTPUT)/test_verifier: CFLAGS += $(TEST_VERIFIER_CFLAGS)
+ $(OUTPUT)/test_verifier: test_verifier.c | $(VERIFIER_TEST_FILES) $(VERIFIER_TESTS_H)
+ $(VERIFIER_TESTS_H): $(VERIFIER_TEST_FILES) | $(VERIFIER_TESTS_DIR)
+ 	$(shell ( cd verifier/; \
+ 		  echo '/* Generated header, do not edit */'; \
+ 		  echo '#ifdef FILL_ARRAY'; \
+ 		  ls *.c 2> /dev/null | \
+ 			sed -e 's@\(.*\)@#include \"\1\"@'; \
+ 		  echo '#endif' \
+ 		 ) > $(VERIFIER_TESTS_H))
+ 
+ EXTRA_CLEAN := $(TEST_CUSTOM_PROGS) $(ALU32_BUILD_DIR) $(BPF_GCC_BUILD_DIR) \
+ 	$(VERIFIER_TESTS_H) $(PROG_TESTS_H) $(MAP_TESTS_H) \
+ 	feature
++>>>>>>> 4ce150b6a412 (selftests/bpf: add bpf-gcc support)
* Unmerged path tools/testing/selftests/bpf/progs/test_tc_edt.c
* Unmerged path tools/testing/selftests/bpf/Makefile
diff --git a/tools/testing/selftests/bpf/bpf_helpers.h b/tools/testing/selftests/bpf/bpf_helpers.h
index 91537e9a7fbd..312d4ef925b7 100644
--- a/tools/testing/selftests/bpf/bpf_helpers.h
+++ b/tools/testing/selftests/bpf/bpf_helpers.h
@@ -1,12 +1,6 @@
 /* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
-#ifndef __BPF_HELPERS_H
-#define __BPF_HELPERS_H
-
-/* helper macro to place programs, maps, license in
- * different sections in elf_bpf file. Section names
- * are interpreted by elf_bpf loader
- */
-#define SEC(NAME) __attribute__((section(NAME), used))
+#ifndef __BPF_HELPERS__
+#define __BPF_HELPERS__
 
 #define __uint(name, val) int (*name)[val]
 #define __type(name, val) val *name
@@ -19,6 +13,14 @@
 			 ##__VA_ARGS__);		\
 })
 
+#ifdef __clang__
+
+/* helper macro to place programs, maps, license in
+ * different sections in elf_bpf file. Section names
+ * are interpreted by elf_bpf loader
+ */
+#define SEC(NAME) __attribute__((section(NAME), used))
+
 /* helper functions called from eBPF programs written in C */
 static void *(*bpf_map_lookup_elem)(void *map, void *key) =
 	(void *) BPF_FUNC_map_lookup_elem;
@@ -208,6 +210,12 @@ struct bpf_map_def {
 	unsigned int numa_node;
 };
 
+#else
+
+#include <bpf-helpers.h>
+
+#endif
+
 #define BPF_ANNOTATE_KV_PAIR(name, type_key, type_val)		\
 	struct ____btf_map_##name {				\
 		type_key key;					\
* Unmerged path tools/testing/selftests/bpf/progs/test_tc_edt.c
