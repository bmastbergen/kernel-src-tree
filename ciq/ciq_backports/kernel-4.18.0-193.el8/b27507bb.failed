net/ibmvnic: unlock rtnl_lock in reset so linkwatch_event can run

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Juliet Kim <julietk@linux.vnet.ibm.com>
commit b27507bb59ed504d7fa4d6a35f25a8cc39903b54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b27507bb.failed

Commit a5681e20b541 ("net/ibmnvic: Fix deadlock problem in reset")
made the change to hold the RTNL lock during a reset to avoid deadlock
but linkwatch_event is fired during the reset and needs the RTNL lock.
That keeps linkwatch_event process from proceeding until the reset
is complete. The reset process cannot tolerate the linkwatch_event
processing after reset completes, so release the RTNL lock during the
process to allow a chance for linkwatch_event to run during reset.
This does not guarantee that the linkwatch_event will be processed as
soon as link state changes, but is an improvement over the current code
where linkwatch_event processing is always delayed, which prevents
transmissions on the device from being deactivated leading transmit
watchdog timer to time-out.

Release the RTNL lock before link state change and re-acquire after
the link state change to allow linkwatch_event to grab the RTNL lock
and run during the reset.

Fixes: a5681e20b541 ("net/ibmnvic: Fix deadlock problem in reset")
	Signed-off-by: Juliet Kim <julietk@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b27507bb59ed504d7fa4d6a35f25a8cc39903b54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 7964c3c08f01,d7db5cc51f6a..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -1979,22 -2049,11 +2063,17 @@@ static void __ibmvnic_reset(struct work
  {
  	struct ibmvnic_rwi *rwi;
  	struct ibmvnic_adapter *adapter;
++<<<<<<< HEAD
 +	struct net_device *netdev;
 +	bool we_lock_rtnl = false;
++=======
++>>>>>>> b27507bb59ed (net/ibmvnic: unlock rtnl_lock in reset so linkwatch_event can run)
  	u32 reset_state;
  	int rc = 0;
  
  	adapter = container_of(work, struct ibmvnic_adapter, ibmvnic_reset);
 +	netdev = adapter->netdev;
  
- 	/* netif_set_real_num_xx_queues needs to take rtnl lock here
- 	 * unless wait_for_reset is set, in which case the rtnl lock
- 	 * has already been taken before initializing the reset
- 	 */
- 	if (!adapter->wait_for_reset) {
- 		rtnl_lock();
- 		we_lock_rtnl = true;
- 	}
  	reset_state = adapter->state;
  
  	rwi = get_next_rwi(adapter);
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
diff --git a/drivers/net/ethernet/ibm/ibmvnic.h b/drivers/net/ethernet/ibm/ibmvnic.h
index dcf2eb6d9290..c862b88e6d07 100644
--- a/drivers/net/ethernet/ibm/ibmvnic.h
+++ b/drivers/net/ethernet/ibm/ibmvnic.h
@@ -31,6 +31,7 @@
 #define IBMVNIC_INVALID_MAP	-1
 #define IBMVNIC_STATS_TIMEOUT	1
 #define IBMVNIC_INIT_FAILED	2
+#define IBMVNIC_OPEN_FAILED	3
 
 /* basic structures plus 100 2k buffers */
 #define IBMVNIC_IO_ENTITLEMENT_DEFAULT	610305
