nfp: bpf: split up the skip flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 91a87a5823f798f1c7b26783e0d2c6d22a1dc28c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/91a87a58.failed

We fail program loading if jump lands on a skipped instruction.
This is for historical reasons, it used to be that we only skipped
instructions optimized out based on prior context, and therefore
the optimization would be buggy if we jumped directly to such
instruction (because the context would be skipped by the jump).

There are cases where instructions can be skipped without any
context, for example there is no point in generating code for:

	 r0 |= 0

We will also soon support dropping dead code, so make the skip
logic differentiate between "optimized with preceding context"
vs other skip types.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 91a87a5823f798f1c7b26783e0d2c6d22a1dc28c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/jit.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/jit.c
index c861d1ad5059,054382b9cbe6..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/jit.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
@@@ -1306,6 -1295,11 +1306,14 @@@ wrp_alu32_imm(struct nfp_prog *nfp_prog
  {
  	const struct bpf_insn *insn = &meta->insn;
  
++<<<<<<< HEAD
++=======
+ 	if (skip) {
+ 		meta->flags |= FLAG_INSN_SKIP_NOOP;
+ 		return 0;
+ 	}
+ 
++>>>>>>> 91a87a5823f7 (nfp: bpf: split up the skip flag)
  	wrp_alu_imm(nfp_prog, insn->dst_reg * 2, alu_op, insn->imm);
  	wrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);
  
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/jit.c
diff --git a/drivers/net/ethernet/netronome/nfp/bpf/main.h b/drivers/net/ethernet/netronome/nfp/bpf/main.h
index 941277936475..40291aedd895 100644
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@ -243,6 +243,13 @@ struct nfp_bpf_reg_state {
 #define FLAG_INSN_IS_JUMP_DST			BIT(0)
 #define FLAG_INSN_IS_SUBPROG_START		BIT(1)
 #define FLAG_INSN_PTR_CALLER_STACK_FRAME	BIT(2)
+/* Instruction is pointless, noop even on its own */
+#define FLAG_INSN_SKIP_NOOP			BIT(3)
+/* Instruction is optimized out based on preceding instructions */
+#define FLAG_INSN_SKIP_PREC_DEPENDENT		BIT(4)
+
+#define FLAG_INSN_SKIP_MASK		(FLAG_INSN_SKIP_NOOP | \
+					 FLAG_INSN_SKIP_PREC_DEPENDENT)
 
 /**
  * struct nfp_insn_meta - BPF instruction wrapper
@@ -271,7 +278,6 @@ struct nfp_bpf_reg_state {
  * @n: eBPF instruction number
  * @flags: eBPF instruction extra optimization flags
  * @subprog_idx: index of subprogram to which the instruction belongs
- * @skip: skip this instruction (optimized out)
  * @double_cb: callback for second part of the instruction
  * @l: link on nfp_prog->insns list
  */
@@ -319,7 +325,6 @@ struct nfp_insn_meta {
 	unsigned short n;
 	unsigned short flags;
 	unsigned short subprog_idx;
-	bool skip;
 	instr_cb_t double_cb;
 
 	struct list_head l;
