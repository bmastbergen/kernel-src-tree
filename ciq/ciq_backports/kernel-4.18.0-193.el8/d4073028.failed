bnxt_en: Fix logic that disables Bus Master during firmware reset.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] bnxt_en: Fix logic that disables Bus Master during firmware reset (Jonathan Toppins) [1801868]
Rebuild_FUZZ: 99.24%
commit-author Vasundhara Volam <vasundhara-v.volam@broadcom.com>
commit d407302895d3f3ca3a333c711744a95e0b1b0150
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d4073028.failed

The current logic that calls pci_disable_device() in __bnxt_close_nic()
during firmware reset is flawed.  If firmware is still alive, we're
disabling the device too early, causing some firmware commands to
not reach the firmware.

Fix it by moving the logic to bnxt_reset_close().  If firmware is
in fatal condition, we call pci_disable_device() before we free
any of the rings to prevent DMA corruption of the freed rings.  If
firmware is still alive, we call pci_disable_device() after the
last firmware message has been sent.

Fixes: 3bc7d4a352ef ("bnxt_en: Add BNXT_STATE_IN_FW_RESET state.")
	Signed-off-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit d407302895d3f3ca3a333c711744a95e0b1b0150)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 3fd9beafbaf6,cea603372cff..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -9557,6 -10095,146 +9557,149 @@@ static void bnxt_reset(struct bnxt *bp
  	bnxt_rtnl_unlock_sp(bp);
  }
  
++<<<<<<< HEAD
++=======
+ static void bnxt_fw_reset_close(struct bnxt *bp)
+ {
+ 	bnxt_ulp_stop(bp);
+ 	/* When firmware is fatal state, disable PCI device to prevent
+ 	 * any potential bad DMAs before freeing kernel memory.
+ 	 */
+ 	if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))
+ 		pci_disable_device(bp->pdev);
+ 	__bnxt_close_nic(bp, true, false);
+ 	bnxt_clear_int_mode(bp);
+ 	bnxt_hwrm_func_drv_unrgtr(bp);
+ 	if (pci_is_enabled(bp->pdev))
+ 		pci_disable_device(bp->pdev);
+ 	bnxt_free_ctx_mem(bp);
+ 	kfree(bp->ctx);
+ 	bp->ctx = NULL;
+ }
+ 
+ static bool is_bnxt_fw_ok(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	bool no_heartbeat = false, has_reset = false;
+ 	u32 val;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_HEARTBEAT_REG);
+ 	if (val == fw_health->last_fw_heartbeat)
+ 		no_heartbeat = true;
+ 
+ 	val = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
+ 	if (val != fw_health->last_fw_reset_cnt)
+ 		has_reset = true;
+ 
+ 	if (!no_heartbeat && has_reset)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ /* rtnl_lock is acquired before calling this function */
+ static void bnxt_force_fw_reset(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 wait_dsecs;
+ 
+ 	if (!test_bit(BNXT_STATE_OPEN, &bp->state) ||
+ 	    test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
+ 		return;
+ 
+ 	set_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 	bnxt_fw_reset_close(bp);
+ 	wait_dsecs = fw_health->master_func_wait_dsecs;
+ 	if (fw_health->master) {
+ 		if (fw_health->flags & ERROR_RECOVERY_QCFG_RESP_FLAGS_CO_CPU)
+ 			wait_dsecs = 0;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_RESET_FW;
+ 	} else {
+ 		bp->fw_reset_timestamp = jiffies + wait_dsecs * HZ / 10;
+ 		wait_dsecs = fw_health->normal_func_wait_dsecs;
+ 		bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 	}
+ 
+ 	bp->fw_reset_min_dsecs = fw_health->post_reset_wait_dsecs;
+ 	bp->fw_reset_max_dsecs = fw_health->post_reset_max_wait_dsecs;
+ 	bnxt_queue_fw_reset_work(bp, wait_dsecs * HZ / 10);
+ }
+ 
+ void bnxt_fw_exception(struct bnxt *bp)
+ {
+ 	netdev_warn(bp->dev, "Detected firmware fatal condition, initiating reset\n");
+ 	set_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
+ 	bnxt_rtnl_lock_sp(bp);
+ 	bnxt_force_fw_reset(bp);
+ 	bnxt_rtnl_unlock_sp(bp);
+ }
+ 
+ /* Returns the number of registered VFs, or 1 if VF configuration is pending, or
+  * < 0 on error.
+  */
+ static int bnxt_get_registered_vfs(struct bnxt *bp)
+ {
+ #ifdef CONFIG_BNXT_SRIOV
+ 	int rc;
+ 
+ 	if (!BNXT_PF(bp))
+ 		return 0;
+ 
+ 	rc = bnxt_hwrm_func_qcfg(bp);
+ 	if (rc) {
+ 		netdev_err(bp->dev, "func_qcfg cmd failed, rc = %d\n", rc);
+ 		return rc;
+ 	}
+ 	if (bp->pf.registered_vfs)
+ 		return bp->pf.registered_vfs;
+ 	if (bp->sriov_cfg)
+ 		return 1;
+ #endif
+ 	return 0;
+ }
+ 
+ void bnxt_fw_reset(struct bnxt *bp)
+ {
+ 	bnxt_rtnl_lock_sp(bp);
+ 	if (test_bit(BNXT_STATE_OPEN, &bp->state) &&
+ 	    !test_bit(BNXT_STATE_IN_FW_RESET, &bp->state)) {
+ 		int n = 0, tmo;
+ 
+ 		set_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 		if (bp->pf.active_vfs &&
+ 		    !test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state))
+ 			n = bnxt_get_registered_vfs(bp);
+ 		if (n < 0) {
+ 			netdev_err(bp->dev, "Firmware reset aborted, rc = %d\n",
+ 				   n);
+ 			clear_bit(BNXT_STATE_IN_FW_RESET, &bp->state);
+ 			dev_close(bp->dev);
+ 			goto fw_reset_exit;
+ 		} else if (n > 0) {
+ 			u16 vf_tmo_dsecs = n * 10;
+ 
+ 			if (bp->fw_reset_max_dsecs < vf_tmo_dsecs)
+ 				bp->fw_reset_max_dsecs = vf_tmo_dsecs;
+ 			bp->fw_reset_state =
+ 				BNXT_FW_RESET_STATE_POLL_VF;
+ 			bnxt_queue_fw_reset_work(bp, HZ / 10);
+ 			goto fw_reset_exit;
+ 		}
+ 		bnxt_fw_reset_close(bp);
+ 		if (bp->fw_cap & BNXT_FW_CAP_ERR_RECOVER_RELOAD) {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_POLL_FW_DOWN;
+ 			tmo = HZ / 10;
+ 		} else {
+ 			bp->fw_reset_state = BNXT_FW_RESET_STATE_ENABLE_DEV;
+ 			tmo = bp->fw_reset_min_dsecs * HZ / 10;
+ 		}
+ 		bnxt_queue_fw_reset_work(bp, tmo);
+ 	}
+ fw_reset_exit:
+ 	bnxt_rtnl_unlock_sp(bp);
+ }
+ 
++>>>>>>> d407302895d3 (bnxt_en: Fix logic that disables Bus Master during firmware reset.)
  static void bnxt_chk_missed_irq(struct bnxt *bp)
  {
  	int i;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
