net/mlx5: DR, Add support for multiple destination table action

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Alex Vesker <valex@mellanox.com>
commit b8853c969f406bfb682740b7646ee8b4623ee955
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b8853c96.failed

A multiple destination table action allows HW packet duplication
to multiple destinations, this is useful for multicast or mirroring
traffic for debug. Duplicating is done using a FW flow table with
multiple destinations.

The new action creation function, mlx5dr_action_create_mult_dest_tbl
will allow creating a single table to iterate over several dr actions.

	Signed-off-by: Alex Vesker <valex@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit b8853c969f406bfb682740b7646ee8b4623ee955)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/steering/dr_action.c
#	drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/steering/dr_action.c
index 004c56c2fc0c,9359eed10889..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_action.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_action.c
@@@ -982,8 -982,106 +982,111 @@@ dec_ref
  }
  
  struct mlx5dr_action *
++<<<<<<< HEAD
 +mlx5dr_create_action_dest_flow_fw_table(struct mlx5_flow_table *ft,
 +					struct mlx5_core_dev *mdev)
++=======
+ mlx5dr_action_create_mult_dest_tbl(struct mlx5dr_domain *dmn,
+ 				   struct mlx5dr_action_dest *dests,
+ 				   u32 num_of_dests)
+ {
+ 	struct mlx5dr_cmd_flow_destination_hw_info *hw_dests;
+ 	struct mlx5dr_action **ref_actions;
+ 	struct mlx5dr_action *action;
+ 	bool reformat_req = false;
+ 	u32 num_of_ref = 0;
+ 	int ret;
+ 	int i;
+ 
+ 	if (dmn->type != MLX5DR_DOMAIN_TYPE_FDB) {
+ 		mlx5dr_err(dmn, "Multiple destination support is for FDB only\n");
+ 		return NULL;
+ 	}
+ 
+ 	hw_dests = kzalloc(sizeof(*hw_dests) * num_of_dests, GFP_KERNEL);
+ 	if (!hw_dests)
+ 		return NULL;
+ 
+ 	ref_actions = kzalloc(sizeof(*ref_actions) * num_of_dests * 2, GFP_KERNEL);
+ 	if (!ref_actions)
+ 		goto free_hw_dests;
+ 
+ 	for (i = 0; i < num_of_dests; i++) {
+ 		struct mlx5dr_action *reformat_action = dests[i].reformat;
+ 		struct mlx5dr_action *dest_action = dests[i].dest;
+ 
+ 		ref_actions[num_of_ref++] = dest_action;
+ 
+ 		switch (dest_action->action_type) {
+ 		case DR_ACTION_TYP_VPORT:
+ 			hw_dests[i].vport.flags = MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 			hw_dests[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 			hw_dests[i].vport.num = dest_action->vport.caps->num;
+ 			hw_dests[i].vport.vhca_id = dest_action->vport.caps->vhca_gvmi;
+ 			if (reformat_action) {
+ 				reformat_req = true;
+ 				hw_dests[i].vport.reformat_id =
+ 					reformat_action->reformat.reformat_id;
+ 				ref_actions[num_of_ref++] = reformat_action;
+ 				hw_dests[i].vport.flags |= MLX5_FLOW_DEST_VPORT_REFORMAT_ID;
+ 			}
+ 			break;
+ 
+ 		case DR_ACTION_TYP_FT:
+ 			hw_dests[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 			if (dest_action->dest_tbl.is_fw_tbl)
+ 				hw_dests[i].ft_id = dest_action->dest_tbl.fw_tbl.id;
+ 			else
+ 				hw_dests[i].ft_id = dest_action->dest_tbl.tbl->table_id;
+ 			break;
+ 
+ 		default:
+ 			mlx5dr_dbg(dmn, "Invalid multiple destinations action\n");
+ 			goto free_ref_actions;
+ 		}
+ 	}
+ 
+ 	action = dr_action_create_generic(DR_ACTION_TYP_FT);
+ 	if (!action)
+ 		goto free_ref_actions;
+ 
+ 	ret = mlx5dr_fw_create_md_tbl(dmn,
+ 				      hw_dests,
+ 				      num_of_dests,
+ 				      reformat_req,
+ 				      &action->dest_tbl.fw_tbl.id,
+ 				      &action->dest_tbl.fw_tbl.group_id);
+ 	if (ret)
+ 		goto free_action;
+ 
+ 	refcount_inc(&dmn->refcount);
+ 
+ 	for (i = 0; i < num_of_ref; i++)
+ 		refcount_inc(&ref_actions[i]->refcount);
+ 
+ 	action->dest_tbl.is_fw_tbl = true;
+ 	action->dest_tbl.fw_tbl.dmn = dmn;
+ 	action->dest_tbl.fw_tbl.type = FS_FT_FDB;
+ 	action->dest_tbl.fw_tbl.ref_actions = ref_actions;
+ 	action->dest_tbl.fw_tbl.num_of_ref_actions = num_of_ref;
+ 
+ 	kfree(hw_dests);
+ 
+ 	return action;
+ 
+ free_action:
+ 	kfree(action);
+ free_ref_actions:
+ 	kfree(ref_actions);
+ free_hw_dests:
+ 	kfree(hw_dests);
+ 	return NULL;
+ }
+ 
+ struct mlx5dr_action *
+ mlx5dr_action_create_dest_flow_fw_table(struct mlx5dr_domain *dmn,
+ 					struct mlx5_flow_table *ft)
++>>>>>>> b8853c969f40 (net/mlx5: DR, Add support for multiple destination table action)
  {
  	struct mlx5dr_action *action;
  
@@@ -1559,8 -1660,26 +1662,24 @@@ int mlx5dr_action_destroy(struct mlx5dr
  
  	switch (action->action_type) {
  	case DR_ACTION_TYP_FT:
 -		if (action->dest_tbl.is_fw_tbl)
 -			refcount_dec(&action->dest_tbl.fw_tbl.dmn->refcount);
 -		else
 +		if (!action->dest_tbl.is_fw_tbl)
  			refcount_dec(&action->dest_tbl.tbl->refcount);
+ 
+ 		if (action->dest_tbl.is_fw_tbl &&
+ 		    action->dest_tbl.fw_tbl.num_of_ref_actions) {
+ 			struct mlx5dr_action **ref_actions;
+ 			int i;
+ 
+ 			ref_actions = action->dest_tbl.fw_tbl.ref_actions;
+ 			for (i = 0; i < action->dest_tbl.fw_tbl.num_of_ref_actions; i++)
+ 				refcount_dec(&ref_actions[i]->refcount);
+ 
+ 			kfree(ref_actions);
+ 
+ 			mlx5dr_fw_destroy_md_tbl(action->dest_tbl.fw_tbl.dmn,
+ 						 action->dest_tbl.fw_tbl.id,
+ 						 action->dest_tbl.fw_tbl.group_id);
+ 		}
  		break;
  	case DR_ACTION_TYP_TNL_L2_TO_L2:
  		refcount_dec(&action->reformat.dmn->refcount);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
index e464aa2385cf,0fc52d634e10..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
@@@ -739,10 -743,14 +739,21 @@@ struct mlx5dr_action 
  			union {
  				struct mlx5dr_table *tbl;
  				struct {
++<<<<<<< HEAD
 +					struct mlx5_flow_table *ft;
 +					u64 rx_icm_addr;
 +					u64 tx_icm_addr;
 +					struct mlx5_core_dev *mdev;
++=======
+ 					struct mlx5dr_domain *dmn;
+ 					u32 id;
+ 					u32 group_id;
+ 					enum fs_flow_table_type type;
+ 					u64 rx_icm_addr;
+ 					u64 tx_icm_addr;
+ 					struct mlx5dr_action **ref_actions;
+ 					u32 num_of_ref_actions;
++>>>>>>> b8853c969f40 (net/mlx5: DR, Add support for multiple destination table action)
  				} fw_tbl;
  			};
  		} dest_tbl;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/steering/dr_action.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/steering/dr_types.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/mlx5dr.h b/drivers/net/ethernet/mellanox/mlx5/core/steering/mlx5dr.h
index adda9cbfba45..4bba37399d97 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/mlx5dr.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/mlx5dr.h
@@ -33,6 +33,11 @@ struct mlx5dr_match_parameters {
 	u64 *match_buf; /* Device spec format */
 };
 
+struct mlx5dr_action_dest {
+	struct mlx5dr_action *dest;
+	struct mlx5dr_action *reformat;
+};
+
 #ifdef CONFIG_MLX5_SW_STEERING
 
 struct mlx5dr_domain *
@@ -83,6 +88,11 @@ mlx5dr_action_create_dest_vport(struct mlx5dr_domain *domain,
 				u32 vport, u8 vhca_id_valid,
 				u16 vhca_id);
 
+struct mlx5dr_action *
+mlx5dr_action_create_mult_dest_tbl(struct mlx5dr_domain *dmn,
+				   struct mlx5dr_action_dest *dests,
+				   u32 num_of_dests);
+
 struct mlx5dr_action *mlx5dr_action_create_drop(void);
 
 struct mlx5dr_action *mlx5dr_action_create_tag(u32 tag_value);
@@ -173,6 +183,11 @@ mlx5dr_action_create_dest_vport(struct mlx5dr_domain *domain,
 				u32 vport, u8 vhca_id_valid,
 				u16 vhca_id) { return NULL; }
 
+static inline struct mlx5dr_action *
+mlx5dr_action_create_mult_dest_tbl(struct mlx5dr_domain *dmn,
+				   struct mlx5dr_action_dest *dests,
+				   u32 num_of_dests)  { return NULL; }
+
 static inline struct mlx5dr_action *
 mlx5dr_action_create_drop(void) { return NULL; }
 
