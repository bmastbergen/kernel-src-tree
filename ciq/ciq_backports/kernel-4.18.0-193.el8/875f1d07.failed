iov_iter: add ITER_BVEC_FLAG_NO_REF flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 875f1d0769cdcfe1596ff0ca609b453359e42ec9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/875f1d07.failed

For ITER_BVEC, if we're holding on to kernel pages, the caller
doesn't need to grab a reference to the bvec pages, and drop that
same reference on IO completion. This is essentially safe for any
ITER_BVEC, but some use cases end up reusing pages and uncondtionally
dropping a page reference on completion. And example of that is
sendfile(2), that ends up being a splice_in + splice_out on the
pipe pages.

Add a flag that tells us it's fine to not grab a page reference
to the bvec pages, since that caller knows not to drop a reference
when it's done with the pages.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 875f1d0769cdcfe1596ff0ca609b453359e42ec9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/uio.h
diff --cc include/linux/uio.h
index bc2b9f6f90bf,4e926641fa80..000000000000
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@@ -24,15 -22,25 +24,37 @@@ struct kvec 
  	size_t iov_len;
  };
  
++<<<<<<< HEAD
 +enum {
 +	ITER_IOVEC = 0,
 +	ITER_KVEC = 2,
 +	ITER_BVEC = 4,
 +	ITER_PIPE = 8,
 +};
 +
 +struct iov_iter {
 +	int type;
++=======
+ enum iter_type {
+ 	/* set if ITER_BVEC doesn't hold a bv_page ref */
+ 	ITER_BVEC_FLAG_NO_REF = 2,
+ 
+ 	/* iter types */
+ 	ITER_IOVEC = 4,
+ 	ITER_KVEC = 8,
+ 	ITER_BVEC = 16,
+ 	ITER_PIPE = 32,
+ 	ITER_DISCARD = 64,
+ };
+ 
+ struct iov_iter {
+ 	/*
+ 	 * Bit 0 is the read/write bit, set if we're writing.
+ 	 * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and
+ 	 * the caller isn't expecting to drop a page reference when done.
+ 	 */
+ 	unsigned int type;
++>>>>>>> 875f1d0769cd (iov_iter: add ITER_BVEC_FLAG_NO_REF flag)
  	size_t iov_offset;
  	size_t count;
  	union {
@@@ -50,6 -58,46 +72,49 @@@
  	};
  };
  
++<<<<<<< HEAD
++=======
+ static inline enum iter_type iov_iter_type(const struct iov_iter *i)
+ {
+ 	return i->type & ~(READ | WRITE);
+ }
+ 
+ static inline bool iter_is_iovec(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_IOVEC;
+ }
+ 
+ static inline bool iov_iter_is_kvec(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_KVEC;
+ }
+ 
+ static inline bool iov_iter_is_bvec(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_BVEC;
+ }
+ 
+ static inline bool iov_iter_is_pipe(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_PIPE;
+ }
+ 
+ static inline bool iov_iter_is_discard(const struct iov_iter *i)
+ {
+ 	return iov_iter_type(i) == ITER_DISCARD;
+ }
+ 
+ static inline unsigned char iov_iter_rw(const struct iov_iter *i)
+ {
+ 	return i->type & (READ | WRITE);
+ }
+ 
+ static inline bool iov_iter_bvec_no_ref(const struct iov_iter *i)
+ {
+ 	return (i->type & ITER_BVEC_FLAG_NO_REF) != 0;
+ }
+ 
++>>>>>>> 875f1d0769cd (iov_iter: add ITER_BVEC_FLAG_NO_REF flag)
  /*
   * Total number of bytes covered by an iovec.
   *
diff --git a/fs/io_uring.c b/fs/io_uring.c
index c33b76cbfef8..6aaa30580a2b 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -855,6 +855,9 @@ static int io_import_fixed(struct io_ring_ctx *ctx, int rw,
 	iov_iter_bvec(iter, rw, imu->bvec, imu->nr_bvecs, offset + len);
 	if (offset)
 		iov_iter_advance(iter, offset);
+
+	/* don't drop a reference to these pages */
+	iter->type |= ITER_BVEC_FLAG_NO_REF;
 	return 0;
 }
 
* Unmerged path include/linux/uio.h
