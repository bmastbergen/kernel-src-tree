PCI/PM: Remove unused pci_driver.resume_early() hook

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 89cdbc3546354c359558a1809133902028c57da4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/89cdbc35.failed

The struct pci_driver.resume_early() hook is one of the legacy PCI power
management callbacks, and there are no remaining users of it.  Remove it.

Link: https://lore.kernel.org/r/20191101204558.210235-6-helgaas@kernel.org
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 89cdbc3546354c359558a1809133902028c57da4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/power/pci.txt
#	include/linux/pci.h
diff --cc Documentation/power/pci.txt
index 8eaf9ee24d43,ff7029b94068..000000000000
--- a/Documentation/power/pci.txt
+++ b/Documentation/power/pci.txt
@@@ -677,8 -691,8 +677,13 @@@ controlling the runtime power managemen
  
  At the time of this writing there are two ways to define power management
  callbacks for a PCI device driver, the recommended one, based on using a
++<<<<<<< HEAD:Documentation/power/pci.txt
 +dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and the
 +"legacy" one, in which the .suspend(), .suspend_late(), .resume_early(), and
++=======
+ dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and
+ the "legacy" one, in which the .suspend(), .suspend_late(), and
++>>>>>>> 89cdbc354635 (PCI/PM: Remove unused pci_driver.resume_early() hook):Documentation/power/pci.rst
  .resume() callbacks from struct pci_driver are used.  The legacy approach,
  however, doesn't allow one to define runtime power management callbacks and is
  not really suitable for any new drivers.  Therefore it is not covered by this
diff --cc include/linux/pci.h
index 906f59ad2896,dd4596fc1208..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -808,6 -778,49 +808,52 @@@ struct pci_error_handlers 
  
  
  struct module;
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * struct pci_driver - PCI driver structure
+  * @node:	List of driver structures.
+  * @name:	Driver name.
+  * @id_table:	Pointer to table of device IDs the driver is
+  *		interested in.  Most drivers should export this
+  *		table using MODULE_DEVICE_TABLE(pci,...).
+  * @probe:	This probing function gets called (during execution
+  *		of pci_register_driver() for already existing
+  *		devices or later if a new device gets inserted) for
+  *		all PCI devices which match the ID table and are not
+  *		"owned" by the other drivers yet. This function gets
+  *		passed a "struct pci_dev \*" for each device whose
+  *		entry in the ID table matches the device. The probe
+  *		function returns zero when the driver chooses to
+  *		take "ownership" of the device or an error code
+  *		(negative number) otherwise.
+  *		The probe function always gets called from process
+  *		context, so it can sleep.
+  * @remove:	The remove() function gets called whenever a device
+  *		being handled by this driver is removed (either during
+  *		deregistration of the driver or when it's manually
+  *		pulled out of a hot-pluggable slot).
+  *		The remove function always gets called from process
+  *		context, so it can sleep.
+  * @suspend:	Put device into low power state.
+  * @suspend_late: Put device into low power state.
+  * @resume:	Wake device from low power state.
+  *		(Please see Documentation/power/pci.rst for descriptions
+  *		of PCI Power Management and the related functions.)
+  * @shutdown:	Hook into reboot_notifier_list (kernel/sys.c).
+  *		Intended to stop any idling DMA operations.
+  *		Useful for enabling wake-on-lan (NIC) or changing
+  *		the power state of a device before reboot.
+  *		e.g. drivers/net/e100.c.
+  * @sriov_configure: Optional driver callback to allow configuration of
+  *		number of VFs to enable via sysfs "sriov_numvfs" file.
+  * @err_handler: See Documentation/PCI/pci-error-recovery.rst
+  * @groups:	Sysfs attribute groups.
+  * @driver:	Driver model structure.
+  * @dynids:	List of dynamically added device IDs.
+  */
++>>>>>>> 89cdbc354635 (PCI/PM: Remove unused pci_driver.resume_early() hook)
  struct pci_driver {
  	struct list_head	node;
  	const char		*name;
* Unmerged path Documentation/power/pci.txt
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index e6614ab5ceca..70b3d5bddbf8 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -659,15 +659,6 @@ static int pci_legacy_suspend_late(struct device *dev, pm_message_t state)
 	return 0;
 }
 
-static int pci_legacy_resume_early(struct device *dev)
-{
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct pci_driver *drv = pci_dev->driver;
-
-	return drv && drv->resume_early ?
-			drv->resume_early(pci_dev) : 0;
-}
-
 static int pci_legacy_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -691,8 +682,7 @@ static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 static bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)
 {
 	struct pci_driver *drv = pci_dev->driver;
-	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume
-		|| drv->resume_early);
+	bool ret = drv && (drv->suspend || drv->suspend_late || drv->resume);
 
 	/*
 	 * Legacy PM support is used by default, so warn if the new framework is
@@ -950,7 +940,7 @@ static int pci_pm_resume_noirq(struct device *dev)
 	pci_pm_default_resume_early(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return 0;
 
 	pcie_pme_root_status_cleanup(pci_dev);
 
@@ -1083,9 +1073,8 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	}
 
 	/*
-	 * Both the legacy ->resume_early() and the new pm->thaw_noirq()
-	 * callbacks assume the device has been returned to D0 and its
-	 * config state has been restored.
+	 * The pm->thaw_noirq() callback assumes the device has been
+	 * returned to D0 and its config state has been restored.
 	 *
 	 * In addition, pci_restore_state() restores MSI-X state in MMIO
 	 * space, which requires the device to be in D0, so return it to D0
@@ -1096,7 +1085,7 @@ static int pci_pm_thaw_noirq(struct device *dev)
 	pci_restore_state(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return 0;
 
 	if (drv && drv->pm && drv->pm->thaw_noirq)
 		error = drv->pm->thaw_noirq(dev);
@@ -1227,7 +1216,7 @@ static int pci_pm_restore_noirq(struct device *dev)
 	pci_pm_default_resume_early(pci_dev);
 
 	if (pci_has_legacy_pm_support(pci_dev))
-		return pci_legacy_resume_early(dev);
+		return 0;
 
 	if (drv && drv->pm && drv->pm->restore_noirq)
 		error = drv->pm->restore_noirq(dev);
* Unmerged path include/linux/pci.h
