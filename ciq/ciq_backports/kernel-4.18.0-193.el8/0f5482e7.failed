ALSA: firewire-motu: share PCM buffer size for both direction

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 0f5482e7875bc2d507e6d92fcc8de22ff75fbdda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/0f5482e7.failed

This commit allows ALSA firewire-motu driver to share PCM buffer
size for both capture and playback PCM substream. When AMDTP domain
starts for one of the PCM substream, buffer size of the PCM substream
is stores to AMDTP domain structure. Some AMDTP streams have already
run with the buffer size when another PCM substream starts, therefore
the PCM substream has a constraint to its buffer size.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Link: https://lore.kernel.org/r/20191017155424.885-9-o-takashi@sakamocchi.jp
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 0f5482e7875bc2d507e6d92fcc8de22ff75fbdda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/motu/motu-stream.c
diff --cc sound/firewire/motu/motu-stream.c
index 52b7c375bb0b,9975770c9b1f..000000000000
--- a/sound/firewire/motu/motu-stream.c
+++ b/sound/firewire/motu/motu-stream.c
@@@ -174,7 -175,7 +175,11 @@@ int snd_motu_stream_reserve_duplex(stru
  		}
  
  		err = amdtp_domain_set_events_per_period(&motu->domain,
++<<<<<<< HEAD
 +							 frames_per_period);
++=======
+ 					frames_per_period, frames_per_buffer);
++>>>>>>> 0f5482e7875b (ALSA: firewire-motu: share PCM buffer size for both direction)
  		if (err < 0) {
  			fw_iso_resources_free(&motu->tx_resources);
  			fw_iso_resources_free(&motu->rx_resources);
diff --git a/sound/firewire/motu/motu-midi.c b/sound/firewire/motu/motu-midi.c
index 997dd6c8ec31..2365f7dfde26 100644
--- a/sound/firewire/motu/motu-midi.c
+++ b/sound/firewire/motu/motu-midi.c
@@ -17,7 +17,7 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 
 	mutex_lock(&motu->mutex);
 
-	err = snd_motu_stream_reserve_duplex(motu, 0, 0);
+	err = snd_motu_stream_reserve_duplex(motu, 0, 0, 0);
 	if (err >= 0) {
 		++motu->substreams_counter;
 		err = snd_motu_stream_start_duplex(motu);
diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 7bbf8b86a33d..00e693da0cad 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -162,6 +162,7 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	if (src != SND_MOTU_CLOCK_SOURCE_INTERNAL ||
 	    (motu->substreams_counter > 0 && d->events_per_period > 0)) {
 		unsigned int frames_per_period = d->events_per_period;
+		unsigned int frames_per_buffer = d->events_per_buffer;
 		unsigned int rate;
 
 		err = protocol->get_clock_rate(motu, &rate);
@@ -179,6 +180,14 @@ static int pcm_open(struct snd_pcm_substream *substream)
 				mutex_unlock(&motu->mutex);
 				goto err_locked;
 			}
+
+			err = snd_pcm_hw_constraint_minmax(substream->runtime,
+					SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+					frames_per_buffer, frames_per_buffer);
+			if (err < 0) {
+				mutex_unlock(&motu->mutex);
+				goto err_locked;
+			}
 		}
 	}
 
@@ -216,10 +225,11 @@ static int pcm_hw_params(struct snd_pcm_substream *substream,
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		unsigned int rate = params_rate(hw_params);
 		unsigned int frames_per_period = params_period_size(hw_params);
+		unsigned int frames_per_buffer = params_buffer_size(hw_params);
 
 		mutex_lock(&motu->mutex);
 		err = snd_motu_stream_reserve_duplex(motu, rate,
-						     frames_per_period);
+					frames_per_period, frames_per_buffer);
 		if (err >= 0)
 			++motu->substreams_counter;
 		mutex_unlock(&motu->mutex);
* Unmerged path sound/firewire/motu/motu-stream.c
diff --git a/sound/firewire/motu/motu.h b/sound/firewire/motu/motu.h
index a419e6e7daed..35ed8b6bb8e8 100644
--- a/sound/firewire/motu/motu.h
+++ b/sound/firewire/motu/motu.h
@@ -155,7 +155,8 @@ int snd_motu_stream_init_duplex(struct snd_motu *motu);
 void snd_motu_stream_destroy_duplex(struct snd_motu *motu);
 int snd_motu_stream_cache_packet_formats(struct snd_motu *motu);
 int snd_motu_stream_reserve_duplex(struct snd_motu *motu, unsigned int rate,
-				   unsigned int frames_per_period);
+				   unsigned int frames_per_period,
+				   unsigned int frames_per_buffer);
 int snd_motu_stream_start_duplex(struct snd_motu *motu);
 void snd_motu_stream_stop_duplex(struct snd_motu *motu);
 int snd_motu_stream_lock_try(struct snd_motu *motu);
