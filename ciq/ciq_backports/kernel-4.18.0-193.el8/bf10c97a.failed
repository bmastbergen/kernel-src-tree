x86/jump_label: Make tp_vec_nr static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [x86] jump_label: Make tp_vec_nr static (Daniel Bristot de Oliveira) [1731860]
Rebuild_FUZZ: 94.29%
commit-author YueHaibing <yuehaibing@huawei.com>
commit bf10c97adbd0dc8fa65c35d5b0c0dc281a68ac8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/bf10c97a.failed

Fix sparse warning:

arch/x86/kernel/jump_label.c:106:5: warning:
 symbol 'tp_vec_nr' was not declared. Should it be static?

It's only used in jump_label.c, so make it static.

Fixes: ba54f0c3f7c4 ("x86/jump_label: Batch jump label updates")
	Reported-by: Hulk Robot <hulkci@huawei.com>
	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: <bp@alien8.de>
	Cc: <hpa@zytor.com>
	Cc: <peterz@infradead.org>
	Cc: <bristot@redhat.com>
	Cc: <namit@vmware.com>
Link: https://lkml.kernel.org/r/20190625034548.26392-1-yuehaibing@huawei.com

(cherry picked from commit bf10c97adbd0dc8fa65c35d5b0c0dc281a68ac8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/jump_label.c
diff --cc arch/x86/kernel/jump_label.c
index 29e6648a2d8f,044053235302..000000000000
--- a/arch/x86/kernel/jump_label.c
+++ b/arch/x86/kernel/jump_label.c
@@@ -103,6 -101,75 +103,78 @@@ void arch_jump_label_transform(struct j
  	mutex_unlock(&text_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ #define TP_VEC_MAX (PAGE_SIZE / sizeof(struct text_poke_loc))
+ static struct text_poke_loc tp_vec[TP_VEC_MAX];
+ static int tp_vec_nr;
+ 
+ bool arch_jump_label_transform_queue(struct jump_entry *entry,
+ 				     enum jump_label_type type)
+ {
+ 	struct text_poke_loc *tp;
+ 	void *entry_code;
+ 
+ 	if (system_state == SYSTEM_BOOTING) {
+ 		/*
+ 		 * Fallback to the non-batching mode.
+ 		 */
+ 		arch_jump_label_transform(entry, type);
+ 		return true;
+ 	}
+ 
+ 	/*
+ 	 * No more space in the vector, tell upper layer to apply
+ 	 * the queue before continuing.
+ 	 */
+ 	if (tp_vec_nr == TP_VEC_MAX)
+ 		return false;
+ 
+ 	tp = &tp_vec[tp_vec_nr];
+ 
+ 	entry_code = (void *)jump_entry_code(entry);
+ 
+ 	/*
+ 	 * The INT3 handler will do a bsearch in the queue, so we need entries
+ 	 * to be sorted. We can survive an unsorted list by rejecting the entry,
+ 	 * forcing the generic jump_label code to apply the queue. Warning once,
+ 	 * to raise the attention to the case of an unsorted entry that is
+ 	 * better not happen, because, in the worst case we will perform in the
+ 	 * same way as we do without batching - with some more overhead.
+ 	 */
+ 	if (tp_vec_nr > 0) {
+ 		int prev = tp_vec_nr - 1;
+ 		struct text_poke_loc *prev_tp = &tp_vec[prev];
+ 
+ 		if (WARN_ON_ONCE(prev_tp->addr > entry_code))
+ 			return false;
+ 	}
+ 
+ 	__jump_label_set_jump_code(entry, type,
+ 				   (union jump_code_union *) &tp->opcode, 0);
+ 
+ 	tp->addr = entry_code;
+ 	tp->detour = entry_code + JUMP_LABEL_NOP_SIZE;
+ 	tp->len = JUMP_LABEL_NOP_SIZE;
+ 
+ 	tp_vec_nr++;
+ 
+ 	return true;
+ }
+ 
+ void arch_jump_label_transform_apply(void)
+ {
+ 	if (!tp_vec_nr)
+ 		return;
+ 
+ 	mutex_lock(&text_mutex);
+ 	text_poke_bp_batch(tp_vec, tp_vec_nr);
+ 	mutex_unlock(&text_mutex);
+ 
+ 	tp_vec_nr = 0;
+ }
+ 
++>>>>>>> bf10c97adbd0 (x86/jump_label: Make tp_vec_nr static)
  static enum {
  	JL_STATE_START,
  	JL_STATE_NO_UPDATE,
* Unmerged path arch/x86/kernel/jump_label.c
