perf bpf: Show more BPF program info in print_bpf_prog_info()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Song Liu <songliubraving@fb.com>
commit f8dfeae009effc0b6dac2741cf8d7cbb91edb982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f8dfeae0.failed

This patch enables showing bpf program name, address, and size in the
header.

Before the patch:

  perf report --header-only
  ...
  # bpf_prog_info of id 9
  # bpf_prog_info of id 10
  # bpf_prog_info of id 13

After the patch:

  # bpf_prog_info 9: bpf_prog_7be49e3934a125ba addr 0xffffffffa0024947 size 229
  # bpf_prog_info 10: bpf_prog_2a142ef67aaad174 addr 0xffffffffa007c94d size 229
  # bpf_prog_info 13: bpf_prog_47368425825d7384_task__task_newt addr 0xffffffffa0251137 size 369

Committer notes:

Fix the fallback definition when HAVE_LIBBPF_SUPPORT is not defined,
i.e. add the missing 'static inline' and add the __maybe_unused to the
args. Also add stdio.h since we now use FILE * in bpf-event.h.

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stanislav Fomichev <sdf@google.com>
Link: http://lkml.kernel.org/r/20190319165454.1298742-3-songliubraving@fb.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit f8dfeae009effc0b6dac2741cf8d7cbb91edb982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/header.c
diff --cc tools/perf/util/header.c
index 5b16579df3db,b9e693825873..000000000000
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@@ -1577,6 -1452,52 +1577,55 @@@ static void print_dir_format(struct fea
  	fprintf(fp, "# directory data version : %"PRIu64"\n", data->dir.version);
  }
  
++<<<<<<< HEAD
++=======
+ static void print_bpf_prog_info(struct feat_fd *ff, FILE *fp)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	struct rb_root *root;
+ 	struct rb_node *next;
+ 
+ 	down_read(&env->bpf_progs.lock);
+ 
+ 	root = &env->bpf_progs.infos;
+ 	next = rb_first(root);
+ 
+ 	while (next) {
+ 		struct bpf_prog_info_node *node;
+ 
+ 		node = rb_entry(next, struct bpf_prog_info_node, rb_node);
+ 		next = rb_next(&node->rb_node);
+ 
+ 		bpf_event__print_bpf_prog_info(&node->info_linear->info,
+ 					       env, fp);
+ 	}
+ 
+ 	up_read(&env->bpf_progs.lock);
+ }
+ 
+ static void print_bpf_btf(struct feat_fd *ff, FILE *fp)
+ {
+ 	struct perf_env *env = &ff->ph->env;
+ 	struct rb_root *root;
+ 	struct rb_node *next;
+ 
+ 	down_read(&env->bpf_progs.lock);
+ 
+ 	root = &env->bpf_progs.btfs;
+ 	next = rb_first(root);
+ 
+ 	while (next) {
+ 		struct btf_node *node;
+ 
+ 		node = rb_entry(next, struct btf_node, rb_node);
+ 		next = rb_next(&node->rb_node);
+ 		fprintf(fp, "# btf info of id %u\n", node->id);
+ 	}
+ 
+ 	up_read(&env->bpf_progs.lock);
+ }
+ 
++>>>>>>> f8dfeae009ef (perf bpf: Show more BPF program info in print_bpf_prog_info())
  static void free_event_desc(struct perf_evsel *events)
  {
  	struct perf_evsel *evsel;
diff --git a/tools/perf/util/bpf-event.c b/tools/perf/util/bpf-event.c
index d5b041649f26..2a4a0da35632 100644
--- a/tools/perf/util/bpf-event.c
+++ b/tools/perf/util/bpf-event.c
@@ -438,3 +438,43 @@ int bpf_event__add_sb_event(struct perf_evlist **evlist,
 
 	return perf_evlist__add_sb_event(evlist, &attr, bpf_event__sb_cb, env);
 }
+
+void bpf_event__print_bpf_prog_info(struct bpf_prog_info *info,
+				    struct perf_env *env,
+				    FILE *fp)
+{
+	__u32 *prog_lens = (__u32 *)(uintptr_t)(info->jited_func_lens);
+	__u64 *prog_addrs = (__u64 *)(uintptr_t)(info->jited_ksyms);
+	char name[KSYM_NAME_LEN];
+	struct btf *btf = NULL;
+	u32 sub_prog_cnt, i;
+
+	sub_prog_cnt = info->nr_jited_ksyms;
+	if (sub_prog_cnt != info->nr_prog_tags ||
+	    sub_prog_cnt != info->nr_jited_func_lens)
+		return;
+
+	if (info->btf_id) {
+		struct btf_node *node;
+
+		node = perf_env__find_btf(env, info->btf_id);
+		if (node)
+			btf = btf__new((__u8 *)(node->data),
+				       node->data_size);
+	}
+
+	if (sub_prog_cnt == 1) {
+		synthesize_bpf_prog_name(name, KSYM_NAME_LEN, info, btf, 0);
+		fprintf(fp, "# bpf_prog_info %u: %s addr 0x%llx size %u\n",
+			info->id, name, prog_addrs[0], prog_lens[0]);
+		return;
+	}
+
+	fprintf(fp, "# bpf_prog_info %u:\n", info->id);
+	for (i = 0; i < sub_prog_cnt; i++) {
+		synthesize_bpf_prog_name(name, KSYM_NAME_LEN, info, btf, i);
+
+		fprintf(fp, "# \tsub_prog %u: %s addr 0x%llx size %u\n",
+			i, name, prog_addrs[i], prog_lens[i]);
+	}
+}
diff --git a/tools/perf/util/bpf-event.h b/tools/perf/util/bpf-event.h
index 8cb1189149ec..04c33b3bfe28 100644
--- a/tools/perf/util/bpf-event.h
+++ b/tools/perf/util/bpf-event.h
@@ -7,6 +7,7 @@
 #include <pthread.h>
 #include <api/fd/array.h>
 #include "event.h"
+#include <stdio.h>
 
 struct machine;
 union perf_event;
@@ -38,7 +39,9 @@ int perf_event__synthesize_bpf_events(struct perf_session *session,
 				      struct record_opts *opts);
 int bpf_event__add_sb_event(struct perf_evlist **evlist,
 				 struct perf_env *env);
-
+void bpf_event__print_bpf_prog_info(struct bpf_prog_info *info,
+				    struct perf_env *env,
+				    FILE *fp);
 #else
 static inline int machine__process_bpf_event(struct machine *machine __maybe_unused,
 					     union perf_event *event __maybe_unused,
@@ -61,5 +64,11 @@ static inline int bpf_event__add_sb_event(struct perf_evlist **evlist __maybe_un
 	return 0;
 }
 
+static inline void bpf_event__print_bpf_prog_info(struct bpf_prog_info *info __maybe_unused,
+						  struct perf_env *env __maybe_unused,
+						  FILE *fp __maybe_unused)
+{
+
+}
 #endif // HAVE_LIBBPF_SUPPORT
 #endif
* Unmerged path tools/perf/util/header.c
