io_uring: add support for sqe links

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 9e645e1105ca60fbbc6bddf2fd5ef7e57ed3dca8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/9e645e11.failed

With SQE links, we can create chains of dependent SQEs. One example
would be queueing an SQE that's a read from one file descriptor, with
the linked SQE being a write to another with the same set of buffers.

An SQE link will not stall the pipeline, it'll just ensure that
dependent SQEs aren't issued before the previous link has completed.

Any error at submission or completion time will break the chain of SQEs.
For completions, this also includes short reads or writes, as the next
SQE could depend on the previous one being fully completed.

Any SQE in a chain that gets canceled due to any of the above errors,
will get an CQE fill with -ECANCELED as the error value.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9e645e1105ca60fbbc6bddf2fd5ef7e57ed3dca8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 1f79dd22450a,9f0ef4956f87..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -1100,9 -1167,13 +1165,16 @@@ static int io_read(struct io_kiocb *req
  		return -EINVAL;
  
  	ret = io_import_iovec(req->ctx, READ, s, &iovec, &iter);
 -	if (ret < 0)
 +	if (ret)
  		return ret;
  
++<<<<<<< HEAD
++=======
+ 	read_size = ret;
+ 	if (req->flags & REQ_F_LINK)
+ 		req->result = read_size;
+ 
++>>>>>>> 9e645e1105ca (io_uring: add support for sqe links)
  	iov_count = iov_iter_count(&iter);
  	ret = rw_verify_area(READ, file, &kiocb->ki_pos, iov_count);
  	if (!ret) {
@@@ -1147,9 -1228,12 +1219,12 @@@ static int io_write(struct io_kiocb *re
  		return -EINVAL;
  
  	ret = io_import_iovec(req->ctx, WRITE, s, &iovec, &iter);
 -	if (ret < 0)
 +	if (ret)
  		return ret;
  
+ 	if (req->flags & REQ_F_LINK)
+ 		req->result = ret;
+ 
  	iov_count = iov_iter_count(&iter);
  
  	ret = -EAGAIN;
* Unmerged path fs/io_uring.c
diff --git a/include/uapi/linux/io_uring.h b/include/uapi/linux/io_uring.h
index a0c460025036..10b7c45f6d57 100644
--- a/include/uapi/linux/io_uring.h
+++ b/include/uapi/linux/io_uring.h
@@ -40,6 +40,7 @@ struct io_uring_sqe {
  */
 #define IOSQE_FIXED_FILE	(1U << 0)	/* use fixed fileset */
 #define IOSQE_IO_DRAIN		(1U << 1)	/* issue after inflight IO */
+#define IOSQE_IO_LINK		(1U << 2)	/* links next sqe */
 
 /*
  * io_uring_setup() flags
