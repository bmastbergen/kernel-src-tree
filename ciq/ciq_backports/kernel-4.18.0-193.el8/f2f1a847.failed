net: phy: icplus: allow configuring the interrupt function on IP101GR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] phy: icplus: allow configuring the interrupt function on IP101GR (Petr Oros) [1772010]
Rebuild_FUZZ: 96.24%
commit-author Martin Blumenstingl <martin.blumenstingl@googlemail.com>
commit f2f1a847e74f61fb151e0f6f689a8485345ed1fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f2f1a847.failed

The IP101GR is a 32-pin QFN package variant of the IP101G/IP101GA
Ethernet PHY. Due to it's limited amount of pins the RXER (receive
error) and INTR32 (interrupt) functions share pin 21.
By default the PHY is configured to output the "receive error" status on
pin 21. Depending on the board layout and requirements we may want to
re-configure the PHY to output the interrupt signal there.

The mode of pin 21 can be configured in the "Digital I/O Specific
Control Register" (register 29), bit 2:
- 0 = RXER function
- 1 = INTR(32) function

Depending on the devicetree configuration we will now:
- change the mode to either ther RXER or INTR32 function
- keep the SEL_INTR32 value set by the bootloader (default) if no
  configuration is provided (to ensure that we're not breaking existing
  boards)
- error out if conflicting configuration is given (RXER and INTR32 mode
  are enabled at the same time)

	Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f2f1a847e74f61fb151e0f6f689a8485345ed1fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/icplus.c
diff --cc drivers/net/phy/icplus.c
index 6dc83343b55c,7d5938b87660..000000000000
--- a/drivers/net/phy/icplus.c
+++ b/drivers/net/phy/icplus.c
@@@ -42,9 -43,29 +43,26 @@@ MODULE_LICENSE("GPL")
  #define IP1001_APS_ON			11	/* IP1001 APS Mode  bit */
  #define IP101A_G_APS_ON			BIT(1)	/* IP101A/G APS Mode bit */
  #define IP101A_G_IRQ_CONF_STATUS	0x11	/* Conf Info IRQ & Status Reg */
 -#define	IP101A_G_IRQ_PIN_USED		BIT(15) /* INTR pin used */
 -#define IP101A_G_IRQ_ALL_MASK		BIT(11) /* IRQ's inactive */
 -#define IP101A_G_IRQ_SPEED_CHANGE	BIT(2)
 -#define IP101A_G_IRQ_DUPLEX_CHANGE	BIT(1)
 -#define IP101A_G_IRQ_LINK_CHANGE	BIT(0)
 +#define	IP101A_G_IRQ_PIN_USED		(1<<15) /* INTR pin used */
 +#define	IP101A_G_IRQ_DEFAULT		IP101A_G_IRQ_PIN_USED
  
+ #define IP101G_DIGITAL_IO_SPEC_CTRL			0x1d
+ #define IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32		BIT(2)
+ 
+ /* The 32-pin IP101GR package can re-configure the mode of the RXER/INTR_32 pin
+  * (pin number 21). The hardware default is RXER (receive error) mode. But it
+  * can be configured to interrupt mode manually.
+  */
+ enum ip101gr_sel_intr32 {
+ 	IP101GR_SEL_INTR32_KEEP,
+ 	IP101GR_SEL_INTR32_INTR,
+ 	IP101GR_SEL_INTR32_RXER,
+ };
+ 
+ struct ip101a_g_phy_priv {
+ 	enum ip101gr_sel_intr32 sel_intr32;
+ };
+ 
  static int ip175c_config_init(struct phy_device *phydev)
  {
  	int err, i;
@@@ -201,6 -202,106 +219,109 @@@ static int ip175c_config_aneg(struct ph
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ip101a_g_probe(struct phy_device *phydev)
+ {
+ 	struct device *dev = &phydev->mdio.dev;
+ 	struct ip101a_g_phy_priv *priv;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	/* Both functions (RX error and interrupt status) are sharing the same
+ 	 * pin on the 32-pin IP101GR, so this is an exclusive choice.
+ 	 */
+ 	if (device_property_read_bool(dev, "icplus,select-rx-error") &&
+ 	    device_property_read_bool(dev, "icplus,select-interrupt")) {
+ 		dev_err(dev,
+ 			"RXER and INTR mode cannot be selected together\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (device_property_read_bool(dev, "icplus,select-rx-error"))
+ 		priv->sel_intr32 = IP101GR_SEL_INTR32_RXER;
+ 	else if (device_property_read_bool(dev, "icplus,select-interrupt"))
+ 		priv->sel_intr32 = IP101GR_SEL_INTR32_INTR;
+ 	else
+ 		priv->sel_intr32 = IP101GR_SEL_INTR32_KEEP;
+ 
+ 	phydev->priv = priv;
+ 
+ 	return 0;
+ }
+ 
+ static int ip101a_g_config_init(struct phy_device *phydev)
+ {
+ 	struct ip101a_g_phy_priv *priv = phydev->priv;
+ 	int err, c;
+ 
+ 	c = ip1xx_reset(phydev);
+ 	if (c < 0)
+ 		return c;
+ 
+ 	/* configure the RXER/INTR_32 pin of the 32-pin IP101GR if needed: */
+ 	switch (priv->sel_intr32) {
+ 	case IP101GR_SEL_INTR32_RXER:
+ 		err = phy_modify(phydev, IP101G_DIGITAL_IO_SPEC_CTRL,
+ 				 IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32, 0);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 
+ 	case IP101GR_SEL_INTR32_INTR:
+ 		err = phy_modify(phydev, IP101G_DIGITAL_IO_SPEC_CTRL,
+ 				 IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32,
+ 				 IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 
+ 	default:
+ 		/* Don't touch IP101G_DIGITAL_IO_SPEC_CTRL because it's not
+ 		 * documented on IP101A and it's not clear whether this would
+ 		 * cause problems.
+ 		 * For the 32-pin IP101GR we simply keep the SEL_INTR32
+ 		 * configuration as set by the bootloader when not configured
+ 		 * to one of the special functions.
+ 		 */
+ 		break;
+ 	}
+ 
+ 	/* Enable Auto Power Saving mode */
+ 	c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
+ 	c |= IP101A_G_APS_ON;
+ 
+ 	return phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
+ }
+ 
+ static int ip101a_g_config_intr(struct phy_device *phydev)
+ {
+ 	u16 val;
+ 
+ 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+ 		/* INTR pin used: Speed/link/duplex will cause an interrupt */
+ 		val = IP101A_G_IRQ_PIN_USED;
+ 	else
+ 		val = IP101A_G_IRQ_ALL_MASK;
+ 
+ 	return phy_write(phydev, IP101A_G_IRQ_CONF_STATUS, val);
+ }
+ 
+ static int ip101a_g_did_interrupt(struct phy_device *phydev)
+ {
+ 	int val = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
+ 
+ 	if (val < 0)
+ 		return 0;
+ 
+ 	return val & (IP101A_G_IRQ_SPEED_CHANGE |
+ 		      IP101A_G_IRQ_DUPLEX_CHANGE |
+ 		      IP101A_G_IRQ_LINK_CHANGE);
+ }
+ 
++>>>>>>> f2f1a847e74f (net: phy: icplus: allow configuring the interrupt function on IP101GR)
  static int ip101a_g_ack_interrupt(struct phy_device *phydev)
  {
  	int err = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
@@@ -234,7 -335,9 +355,13 @@@ static struct phy_driver icplus_driver[
  	.name		= "ICPlus IP101A/G",
  	.phy_id_mask	= 0x0ffffff0,
  	.features	= PHY_BASIC_FEATURES,
++<<<<<<< HEAD
 +	.flags		= PHY_HAS_INTERRUPT,
++=======
+ 	.probe		= ip101a_g_probe,
+ 	.config_intr	= ip101a_g_config_intr,
+ 	.did_interrupt	= ip101a_g_did_interrupt,
++>>>>>>> f2f1a847e74f (net: phy: icplus: allow configuring the interrupt function on IP101GR)
  	.ack_interrupt	= ip101a_g_ack_interrupt,
  	.config_init	= &ip101a_g_config_init,
  	.suspend	= genphy_suspend,
* Unmerged path drivers/net/phy/icplus.c
