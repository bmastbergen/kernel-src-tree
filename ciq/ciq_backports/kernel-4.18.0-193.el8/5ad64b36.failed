SUNRPC: Add tracking of RPC level errors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trondmy@gmail.com>
commit 5ad64b36dda962797ce3ed579a27189ec7482d0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5ad64b36.failed

Add variables to track RPC level errors so that we can distinguish
between issue that arose in the RPC transport layer as opposed to
those arising from the reply message.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 5ad64b36dda962797ce3ed579a27189ec7482d0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 2b272ab9272e,315f9c9cb72d..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1453,22 -1464,14 +1453,27 @@@ void rpc_force_rebind(struct rpc_clnt *
  }
  EXPORT_SYMBOL_GPL(rpc_force_rebind);
  
 -static int
 -__rpc_restart_call(struct rpc_task *task, void (*action)(struct rpc_task *))
 +/*
 + * Restart an (async) RPC call from the call_prepare state.
 + * Usually called from within the exit handler.
 + */
 +int
 +rpc_restart_call_prepare(struct rpc_task *task)
  {
 +	if (RPC_ASSASSINATED(task))
 +		return 0;
 +	task->tk_action = call_start;
  	task->tk_status = 0;
++<<<<<<< HEAD
 +	if (task->tk_ops->rpc_call_prepare != NULL)
 +		task->tk_action = rpc_prepare_task;
++=======
+ 	task->tk_rpc_status = 0;
+ 	task->tk_action = action;
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  	return 1;
  }
 +EXPORT_SYMBOL_GPL(rpc_restart_call_prepare);
  
  /*
   * Restart an (async) RPC call. Usually called from within the
@@@ -1750,21 -1772,73 +1768,56 @@@ rpc_xdr_encode(struct rpc_task *task
  		     req->rq_rbuffer,
  		     req->rq_rcvsize);
  
 -	req->rq_snd_buf.head[0].iov_len = 0;
 -	xdr_init_encode(&xdr, &req->rq_snd_buf,
 -			req->rq_snd_buf.head[0].iov_base, req);
 -	if (rpc_encode_header(task, &xdr))
 +	p = rpc_encode_header(task);
 +	if (p == NULL) {
 +		printk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");
 +		rpc_exit(task, -EIO);
  		return;
++<<<<<<< HEAD
++=======
+ 
+ 	task->tk_status = rpcauth_wrap_req(task, &xdr);
+ }
+ 
+ /*
+  * 3.	Encode arguments of an RPC call
+  */
+ static void
+ call_encode(struct rpc_task *task)
+ {
+ 	if (!rpc_task_need_encode(task))
+ 		goto out;
+ 	dprint_status(task);
+ 	/* Encode here so that rpcsec_gss can use correct sequence number. */
+ 	rpc_xdr_encode(task);
+ 	/* Did the encode result in an error condition? */
+ 	if (task->tk_status != 0) {
+ 		/* Was the error nonfatal? */
+ 		switch (task->tk_status) {
+ 		case -EAGAIN:
+ 		case -ENOMEM:
+ 			rpc_delay(task, HZ >> 4);
+ 			break;
+ 		case -EKEYEXPIRED:
+ 			task->tk_action = call_refresh;
+ 			break;
+ 		default:
+ 			rpc_call_rpcerror(task, task->tk_status);
+ 		}
+ 		return;
+ 	} else {
+ 		xprt_request_prepare(task->tk_rqstp);
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  	}
  
 -	/* Add task to reply queue before transmission to avoid races */
 -	if (rpc_reply_expected(task))
 -		xprt_request_enqueue_receive(task);
 -	xprt_request_enqueue_transmit(task);
 -out:
 -	task->tk_action = call_transmit;
 -	/* Check that the connection is OK */
 -	if (!xprt_bound(task->tk_xprt))
 -		task->tk_action = call_bind;
 -	else if (!xprt_connected(task->tk_xprt))
 -		task->tk_action = call_connect;
 -}
 -
 -/*
 - * Helpers to check if the task was already transmitted, and
 - * to take action when that is the case.
 - */
 -static bool
 -rpc_task_transmitted(struct rpc_task *task)
 -{
 -	return !test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
 -}
 +	encode = task->tk_msg.rpc_proc->p_encode;
 +	if (encode == NULL)
 +		return;
  
 -static void
 -rpc_task_handle_transmitted(struct rpc_task *task)
 -{
 -	xprt_end_transmit(task);
 -	task->tk_action = call_transmit_status;
 +	task->tk_status = rpcauth_wrap_req(task, encode, req, p,
 +			task->tk_msg.rpc_argp);
 +	if (task->tk_status == 0)
 +		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
  }
  
  /*
@@@ -1875,17 -1976,16 +1928,26 @@@ call_connect(struct rpc_task *task
  			task->tk_pid, xprt,
  			(xprt_connected(xprt) ? "is" : "is not"));
  
++<<<<<<< HEAD
 +	task->tk_action = call_transmit;
 +	if (!xprt_connected(xprt)) {
 +		task->tk_action = call_connect_status;
 +		if (task->tk_status < 0)
 +			return;
 +		if (task->tk_flags & RPC_TASK_NOCONNECT) {
 +			rpc_exit(task, -ENOTCONN);
 +			return;
 +		}
 +		xprt_connect(task);
++=======
+ 	task->tk_action = call_connect_status;
+ 	if (task->tk_status < 0)
+ 		return;
+ 	if (task->tk_flags & RPC_TASK_NOCONNECT) {
+ 		rpc_call_rpcerror(task, -ENOTCONN);
+ 		return;
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  	}
 -	if (!xprt_prepare_transmit(task))
 -		return;
 -	xprt_connect(task);
  }
  
  /*
@@@ -1944,7 -2040,12 +2006,16 @@@ call_connect_status(struct rpc_task *ta
  		task->tk_action = call_transmit;
  		return;
  	}
++<<<<<<< HEAD
 +	rpc_exit(task, status);
++=======
+ 	rpc_call_rpcerror(task, status);
+ 	return;
+ out_retry:
+ 	/* Check for timeouts before looping back to call_bind */
+ 	task->tk_action = call_bind;
+ 	rpc_check_timeout(task);
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  }
  
  /*
@@@ -2041,8 -2125,8 +2112,13 @@@ call_transmit_status(struct rpc_task *t
  			if (!task->tk_msg.rpc_proc->p_proc)
  				trace_xprt_ping(task->tk_xprt,
  						task->tk_status);
++<<<<<<< HEAD
 +			rpc_exit(task, task->tk_status);
 +			break;
++=======
+ 			rpc_call_rpcerror(task, task->tk_status);
+ 			return;
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  		}
  		/* fall through */
  	case -ECONNRESET:
@@@ -2195,17 -2283,26 +2271,34 @@@ call_status(struct rpc_task *task
  		if (clnt->cl_chatty)
  			printk("%s: RPC call returned error %d\n",
  			       clnt->cl_program->name, -status);
 -		goto out_exit;
 +		rpc_exit(task, status);
  	}
++<<<<<<< HEAD
++=======
+ 	task->tk_action = call_encode;
+ 	rpc_check_timeout(task);
+ 	return;
+ out_exit:
+ 	rpc_call_rpcerror(task, status);
+ }
+ 
+ static bool
+ rpc_check_connected(const struct rpc_rqst *req)
+ {
+ 	/* No allocated request or transport? return true */
+ 	if (!req || !req->rq_xprt)
+ 		return true;
+ 	return xprt_connected(req->rq_xprt);
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  }
  
 +/*
 + * 6a.	Handle RPC timeout
 + * 	We do not release the request slot, so we keep using the
 + *	same XID for all retransmits.
 + */
  static void
 -rpc_check_timeout(struct rpc_task *task)
 +call_timeout(struct rpc_task *task)
  {
  	struct rpc_clnt	*clnt = task->tk_client;
  
@@@ -2217,10 -2312,11 +2310,15 @@@
  	dprintk("RPC: %5u call_timeout (major)\n", task->tk_pid);
  	task->tk_timeouts++;
  
++<<<<<<< HEAD
 +	if (RPC_IS_SOFTCONN(task)) {
 +		rpc_exit(task, -ETIMEDOUT);
++=======
+ 	if (RPC_IS_SOFTCONN(task) && !rpc_check_connected(task->tk_rqstp)) {
+ 		rpc_call_rpcerror(task, -ETIMEDOUT);
++>>>>>>> 5ad64b36dda9 (SUNRPC: Add tracking of RPC level errors)
  		return;
  	}
 -
  	if (RPC_IS_SOFT(task)) {
  		if (clnt->cl_chatty) {
  			printk(KERN_NOTICE "%s: server %s not responding, timed out\n",
diff --git a/include/linux/sunrpc/sched.h b/include/linux/sunrpc/sched.h
index 4e2b893b83a8..24f9b48b4795 100644
--- a/include/linux/sunrpc/sched.h
+++ b/include/linux/sunrpc/sched.h
@@ -62,6 +62,8 @@ struct rpc_task {
 		struct rpc_wait		tk_wait;	/* RPC wait */
 	} u;
 
+	int			tk_rpc_status;	/* Result of last RPC operation */
+
 	/*
 	 * RPC call state
 	 */
* Unmerged path net/sunrpc/clnt.c
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 2984e705d710..43d92c593e6f 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -2119,6 +2119,7 @@ static void xs_local_connect(struct rpc_xprt *xprt, struct rpc_task *task)
 		 * we'll need to figure out how to pass a namespace to
 		 * connect.
 		 */
+		task->tk_rpc_status = -ENOTCONN;
 		rpc_exit(task, -ENOTCONN);
 		return;
 	}
