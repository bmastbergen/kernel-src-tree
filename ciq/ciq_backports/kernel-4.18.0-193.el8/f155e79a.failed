ALSA: firewire-lib: fix isoc cycle count to which rx packet is scheduled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit f155e79ab516c9ed2adb2f337fb4ff58b7474428
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f155e79a.failed

When introducing the list of packet descriptor, for rx packet, the
calculation of scheduled isoc cycle is omitted. This commit fixes the
bug.

Fixes: f4f6ae7b7c1f ("ALSA: firewire-lib: use packet descriptor for IT context")
	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit f155e79ab516c9ed2adb2f337fb4ff58b7474428)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/firewire/amdtp-stream.c
diff --cc sound/firewire/amdtp-stream.c
index 9a6d16de6a5b,88270257e896..000000000000
--- a/sound/firewire/amdtp-stream.c
+++ b/sound/firewire/amdtp-stream.c
@@@ -686,6 -678,80 +686,83 @@@ static inline u32 compute_it_cycle(cons
  	return increment_cycle_count(cycle, QUEUE_LENGTH);
  }
  
++<<<<<<< HEAD
++=======
+ static int generate_device_pkt_descs(struct amdtp_stream *s,
+ 				     struct pkt_desc *descs,
+ 				     const __be32 *ctx_header,
+ 				     unsigned int packets)
+ {
+ 	unsigned int dbc = s->data_block_counter;
+ 	int i;
+ 	int err;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		struct pkt_desc *desc = descs + i;
+ 		unsigned int index = (s->packet_index + i) % QUEUE_LENGTH;
+ 		unsigned int cycle;
+ 		unsigned int payload_length;
+ 		unsigned int data_blocks;
+ 		unsigned int syt;
+ 
+ 		cycle = compute_cycle_count(ctx_header[1]);
+ 
+ 		err = parse_ir_ctx_header(s, cycle, ctx_header, &payload_length,
+ 					  &data_blocks, &dbc, &syt, i);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		desc->cycle = cycle;
+ 		desc->syt = syt;
+ 		desc->data_blocks = data_blocks;
+ 		desc->data_block_counter = dbc;
+ 		desc->ctx_payload = s->buffer.packets[index].buffer;
+ 
+ 		if (!(s->flags & CIP_DBC_IS_END_EVENT))
+ 			dbc = (dbc + desc->data_blocks) & 0xff;
+ 
+ 		ctx_header +=
+ 			s->ctx_data.tx.ctx_header_size / sizeof(*ctx_header);
+ 	}
+ 
+ 	s->data_block_counter = dbc;
+ 
+ 	return 0;
+ }
+ 
+ static void generate_ideal_pkt_descs(struct amdtp_stream *s,
+ 				     struct pkt_desc *descs,
+ 				     const __be32 *ctx_header,
+ 				     unsigned int packets)
+ {
+ 	unsigned int dbc = s->data_block_counter;
+ 	int i;
+ 
+ 	for (i = 0; i < packets; ++i) {
+ 		struct pkt_desc *desc = descs + i;
+ 		unsigned int index = (s->packet_index + i) % QUEUE_LENGTH;
+ 
+ 		desc->cycle = compute_it_cycle(*ctx_header);
+ 		desc->syt = calculate_syt(s, desc->cycle);
+ 		desc->data_blocks = calculate_data_blocks(s, desc->syt);
+ 
+ 		if (s->flags & CIP_DBC_IS_END_EVENT)
+ 			dbc = (dbc + desc->data_blocks) & 0xff;
+ 
+ 		desc->data_block_counter = dbc;
+ 
+ 		if (!(s->flags & CIP_DBC_IS_END_EVENT))
+ 			dbc = (dbc + desc->data_blocks) & 0xff;
+ 
+ 		desc->ctx_payload = s->buffer.packets[index].buffer;
+ 
+ 		++ctx_header;
+ 	}
+ 
+ 	s->data_block_counter = dbc;
+ }
+ 
++>>>>>>> f155e79ab516 (ALSA: firewire-lib: fix isoc cycle count to which rx packet is scheduled)
  static inline void cancel_stream(struct amdtp_stream *s)
  {
  	s->packet_index = -1;
* Unmerged path sound/firewire/amdtp-stream.c
