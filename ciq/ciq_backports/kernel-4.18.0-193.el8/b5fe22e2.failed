xfrm: policy: consider if_id when hashing inexact policy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Florian Westphal <fw@strlen.de>
commit b5fe22e2337d47cd68bb7d8e4103a628808c4d5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/b5fe22e2.failed

This avoids searches of polices that cannot match in the first
place due to different interface id by placing them in different bins.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit b5fe22e2337d47cd68bb7d8e4103a628808c4d5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 6b43f9247a17,dda27fd7b8a4..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -45,6 -46,23 +45,26 @@@ struct xfrm_flo 
  	u8 flags;
  };
  
++<<<<<<< HEAD
++=======
+ struct xfrm_pol_inexact_key {
+ 	possible_net_t net;
+ 	u32 if_id;
+ 	u16 family;
+ 	u8 dir, type;
+ };
+ 
+ struct xfrm_pol_inexact_bin {
+ 	struct xfrm_pol_inexact_key k;
+ 	struct rhash_head head;
+ 	struct hlist_head hhead;
+ 
+ 	/* slow path below */
+ 	struct list_head inexact_bins;
+ 	struct rcu_head rcu;
+ };
+ 
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  static DEFINE_SPINLOCK(xfrm_if_cb_lock);
  static struct xfrm_if_cb const __rcu *xfrm_if_cb __read_mostly;
  
@@@ -64,6 -85,19 +84,22 @@@ static void __xfrm_policy_link(struct x
  static struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,
  						int dir);
  
++<<<<<<< HEAD
++=======
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family, u8 dir,
+ 			   u32 if_id);
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup_rcu(struct net *net,
+ 			       u8 type, u16 family, u8 dir, u32 if_id);
+ static struct xfrm_policy *
+ xfrm_policy_insert_list(struct hlist_head *chain, struct xfrm_policy *policy,
+ 			bool excl);
+ static void xfrm_policy_insert_inexact_list(struct hlist_head *chain,
+ 					    struct xfrm_policy *policy);
+ 
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  static inline bool xfrm_pol_hold_rcu(struct xfrm_policy *policy)
  {
  	return refcount_inc_not_zero(&policy->refcnt);
@@@ -560,6 -598,108 +596,111 @@@ static void xfrm_hash_resize(struct wor
  	mutex_unlock(&hash_resize_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ static void xfrm_hash_reset_inexact_table(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *b;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry(b, &net->xfrm.inexact_bins, inexact_bins)
+ 		INIT_HLIST_HEAD(&b->hhead);
+ }
+ 
+ /* Make sure *pol can be inserted into fastbin.
+  * Useful to check that later insert requests will be sucessful
+  * (provided xfrm_policy_lock is held throughout).
+  */
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_alloc_bin(const struct xfrm_policy *pol, u8 dir)
+ {
+ 	struct xfrm_pol_inexact_bin *bin, *prev;
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = pol->family,
+ 		.type = pol->type,
+ 		.dir = dir,
+ 		.if_id = pol->if_id,
+ 	};
+ 	struct net *net = xp_net(pol);
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	write_pnet(&k.net, net);
+ 	bin = rhashtable_lookup_fast(&xfrm_policy_inexact_table, &k,
+ 				     xfrm_pol_inexact_params);
+ 	if (bin)
+ 		return bin;
+ 
+ 	bin = kzalloc(sizeof(*bin), GFP_ATOMIC);
+ 	if (!bin)
+ 		return NULL;
+ 
+ 	bin->k = k;
+ 	INIT_HLIST_HEAD(&bin->hhead);
+ 
+ 	prev = rhashtable_lookup_get_insert_key(&xfrm_policy_inexact_table,
+ 						&bin->k, &bin->head,
+ 						xfrm_pol_inexact_params);
+ 	if (!prev) {
+ 		list_add(&bin->inexact_bins, &net->xfrm.inexact_bins);
+ 		return bin;
+ 	}
+ 
+ 	kfree(bin);
+ 
+ 	return IS_ERR(prev) ? NULL : prev;
+ }
+ 
+ static void xfrm_policy_inexact_delete_bin(struct net *net,
+ 					   struct xfrm_pol_inexact_bin *b)
+ {
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	if (!hlist_empty(&b->hhead))
+ 		return;
+ 
+ 	if (rhashtable_remove_fast(&xfrm_policy_inexact_table, &b->head,
+ 				   xfrm_pol_inexact_params) == 0) {
+ 		list_del(&b->inexact_bins);
+ 		kfree_rcu(b, rcu);
+ 	}
+ }
+ 
+ static void __xfrm_policy_inexact_flush(struct net *net)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	list_for_each_entry(bin, &net->xfrm.inexact_bins, inexact_bins)
+ 		xfrm_policy_inexact_delete_bin(net, bin);
+ }
+ 
+ static struct xfrm_policy *
+ xfrm_policy_inexact_insert(struct xfrm_policy *policy, u8 dir, int excl)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 	struct xfrm_policy *delpol;
+ 	struct hlist_head *chain;
+ 	struct net *net;
+ 
+ 	bin = xfrm_policy_inexact_alloc_bin(policy, dir);
+ 	if (!bin)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	delpol = xfrm_policy_insert_list(&bin->hhead, policy, excl);
+ 	if (delpol && excl)
+ 		return ERR_PTR(-EEXIST);
+ 
+ 	net = xp_net(policy);
+ 	chain = &net->xfrm.policy_inexact[dir];
+ 	xfrm_policy_insert_inexact_list(chain, policy);
+ 
+ 	return delpol;
+ }
+ 
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  static void xfrm_hash_rebuild(struct work_struct *work)
  {
  	struct net *net = container_of(work, struct net,
@@@ -741,6 -923,85 +882,88 @@@ static bool xfrm_policy_mark_match(stru
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static u32 xfrm_pol_bin_key(const void *data, u32 len, u32 seed)
+ {
+ 	const struct xfrm_pol_inexact_key *k = data;
+ 	u32 a = k->type << 24 | k->dir << 16 | k->family;
+ 
+ 	return jhash_3words(a, k->if_id, net_hash_mix(read_pnet(&k->net)),
+ 			    seed);
+ }
+ 
+ static u32 xfrm_pol_bin_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct xfrm_pol_inexact_bin *b = data;
+ 
+ 	return xfrm_pol_bin_key(&b->k, 0, seed);
+ }
+ 
+ static int xfrm_pol_bin_cmp(struct rhashtable_compare_arg *arg,
+ 			    const void *ptr)
+ {
+ 	const struct xfrm_pol_inexact_key *key = arg->key;
+ 	const struct xfrm_pol_inexact_bin *b = ptr;
+ 	int ret;
+ 
+ 	if (!net_eq(read_pnet(&b->k.net), read_pnet(&key->net)))
+ 		return -1;
+ 
+ 	ret = b->k.dir ^ key->dir;
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = b->k.type ^ key->type;
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = b->k.family ^ key->family;
+ 	if (ret)
+ 		return ret;
+ 
+ 	return b->k.if_id ^ key->if_id;
+ }
+ 
+ static const struct rhashtable_params xfrm_pol_inexact_params = {
+ 	.head_offset		= offsetof(struct xfrm_pol_inexact_bin, head),
+ 	.hashfn			= xfrm_pol_bin_key,
+ 	.obj_hashfn		= xfrm_pol_bin_obj,
+ 	.obj_cmpfn		= xfrm_pol_bin_cmp,
+ 	.automatic_shrinking	= true,
+ };
+ 
+ static void xfrm_policy_insert_inexact_list(struct hlist_head *chain,
+ 					    struct xfrm_policy *policy)
+ {
+ 	struct xfrm_policy *pol, *delpol = NULL;
+ 	struct hlist_node *newpos = NULL;
+ 
+ 	hlist_for_each_entry(pol, chain, bydst_inexact_list) {
+ 		if (pol->type == policy->type &&
+ 		    pol->if_id == policy->if_id &&
+ 		    !selector_cmp(&pol->selector, &policy->selector) &&
+ 		    xfrm_policy_mark_match(policy, pol) &&
+ 		    xfrm_sec_ctx_match(pol->security, policy->security) &&
+ 		    !WARN_ON(delpol)) {
+ 			delpol = pol;
+ 			if (policy->priority > pol->priority)
+ 				continue;
+ 		} else if (policy->priority >= pol->priority) {
+ 			newpos = &pol->bydst_inexact_list;
+ 			continue;
+ 		}
+ 		if (delpol)
+ 			break;
+ 	}
+ 
+ 	if (newpos)
+ 		hlist_add_behind_rcu(&policy->bydst_inexact_list, newpos);
+ 	else
+ 		hlist_add_head_rcu(&policy->bydst_inexact_list, chain);
+ }
+ 
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  static struct xfrm_policy *xfrm_policy_insert_list(struct hlist_head *chain,
  						   struct xfrm_policy *policy,
  						   bool excl)
@@@ -835,8 -1096,17 +1058,22 @@@ struct xfrm_policy *xfrm_policy_bysel_c
  	*err = 0;
  	spin_lock_bh(&net->xfrm.xfrm_policy_lock);
  	chain = policy_hash_bysel(net, sel, sel->family, dir);
++<<<<<<< HEAD
 +	if (!chain)
 +		chain = &net->xfrm.policy_inexact[dir];
++=======
+ 	if (!chain) {
+ 		bin = xfrm_policy_inexact_lookup(net, type,
+ 						 sel->family, dir, if_id);
+ 		if (!bin) {
+ 			spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
+ 			return NULL;
+ 		}
+ 
+ 		chain = &bin->hhead;
+ 	}
+ 
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  	ret = NULL;
  	hlist_for_each_entry(pol, chain, bydst) {
  		if (pol->type == type &&
@@@ -1066,6 -1338,38 +1303,41 @@@ static int xfrm_policy_match(const stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup_rcu(struct net *net, u8 type, u16 family,
+ 			       u8 dir, u32 if_id)
+ {
+ 	struct xfrm_pol_inexact_key k = {
+ 		.family = family,
+ 		.type = type,
+ 		.dir = dir,
+ 		.if_id = if_id,
+ 	};
+ 
+ 	write_pnet(&k.net, net);
+ 
+ 	return rhashtable_lookup(&xfrm_policy_inexact_table, &k,
+ 				 xfrm_pol_inexact_params);
+ }
+ 
+ static struct xfrm_pol_inexact_bin *
+ xfrm_policy_inexact_lookup(struct net *net, u8 type, u16 family,
+ 			   u8 dir, u32 if_id)
+ {
+ 	struct xfrm_pol_inexact_bin *bin;
+ 
+ 	lockdep_assert_held(&net->xfrm.xfrm_policy_lock);
+ 
+ 	rcu_read_lock();
+ 	bin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);
+ 	rcu_read_unlock();
+ 
+ 	return bin;
+ }
+ 
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  static struct xfrm_policy *xfrm_policy_lookup_bytype(struct net *net, u8 type,
  						     const struct flowi *fl,
  						     u16 family, u8 dir,
@@@ -1107,7 -1412,10 +1379,14 @@@
  			break;
  		}
  	}
++<<<<<<< HEAD
 +	chain = &net->xfrm.policy_inexact[dir];
++=======
+ 	bin = xfrm_policy_inexact_lookup_rcu(net, type, family, dir, if_id);
+ 	if (!bin)
+ 		goto skip_inexact;
+ 	chain = &bin->hhead;
++>>>>>>> b5fe22e2337d (xfrm: policy: consider if_id when hashing inexact policy)
  	hlist_for_each_entry_rcu(pol, chain, bydst) {
  		if ((pol->priority >= priority) && ret)
  			break;
* Unmerged path net/xfrm/xfrm_policy.c
