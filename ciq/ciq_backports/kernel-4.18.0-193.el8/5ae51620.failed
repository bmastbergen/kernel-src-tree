net/mlx5: E-Switch, Assign a different position for uplink rep and vport

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Assign a different position for uplink rep and vport (Alaa Hleihel) [1724333]
Rebuild_FUZZ: 97.14%
commit-author Bodong Wang <bodong@mellanox.com>
commit 5ae5162066d8e59e365678a9e76fc4d8f6b78d40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5ae51620.failed

In offloads mode, the current implementation puts the uplink
representor at index zero of the vport reps array. It is not "natural"
to place it at index 0 since we want to put the representor for vport
0 at index 0 with the introduction of SmartNIC. A separate patch will
handle the case whether a rep is needed for vport 0 (PF vport).

So, we want to have a different placeholder for uplink vport and
representor. It was placed at the end of vport and rep array. Since
vport number can no longer act as an index into the vport or
representors arrays, use functions to map vport numbers to indices
when accessing the vports or representors arrays, and vice versa.

	Signed-off-by: Bodong Wang <bodong@mellanox.com>
	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 5ae5162066d8e59e365678a9e76fc4d8f6b78d40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index c2e828153dd7,bb7f72467df9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -70,6 -68,28 +70,31 @@@ enum 
  			    MC_ADDR_CHANGE | \
  			    PROMISC_CHANGE)
  
++<<<<<<< HEAD
++=======
+ /* The vport getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_vports(esw, i, vport)			\
+ 	for ((i) = MLX5_VPORT_PF;				\
+ 	     (vport) = &(esw)->vports[i],			\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)	\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;				\
+ 	     (vport) = &(esw)->vports[i],			\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ static struct mlx5_vport *mlx5_eswitch_get_vport(struct mlx5_eswitch *esw,
+ 						 u16 vport_num)
+ {
+ 	u16 idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	WARN_ON(vport_num > esw->total_vports - 1);
+ 	return &esw->vports[idx];
+ }
+ 
++>>>>>>> 5ae5162066d8 (net/mlx5: E-Switch, Assign a different position for uplink rep and vport)
  static int arm_vport_context_events_cmd(struct mlx5_core_dev *dev, u16 vport,
  					u32 events_mask)
  {
@@@ -1716,8 -1757,8 +1741,13 @@@ int mlx5_eswitch_init(struct mlx5_core_
  {
  	int total_vports = MLX5_TOTAL_VPORTS(dev);
  	struct mlx5_eswitch *esw;
++<<<<<<< HEAD
 +	int vport_num;
 +	int err;
++=======
+ 	struct mlx5_vport *vport;
+ 	int err, i;
++>>>>>>> 5ae5162066d8 (net/mlx5: E-Switch, Assign a different position for uplink rep and vport)
  
  	if (!MLX5_VPORT_MANAGER(dev))
  		return 0;
@@@ -1755,10 -1799,8 +1785,15 @@@
  	hash_init(esw->offloads.mod_hdr_tbl);
  	mutex_init(&esw->state_lock);
  
++<<<<<<< HEAD
 +	for (vport_num = 0; vport_num < total_vports; vport_num++) {
 +		struct mlx5_vport *vport = &esw->vports[vport_num];
 +
 +		vport->vport = vport_num;
++=======
+ 	mlx5_esw_for_all_vports(esw, i, vport) {
+ 		vport->vport = mlx5_eswitch_index_to_vport_num(esw, i);
++>>>>>>> 5ae5162066d8 (net/mlx5: E-Switch, Assign a different position for uplink rep and vport)
  		vport->info.link_state = MLX5_VPORT_ADMIN_STATE_AUTO;
  		vport->dev = dev;
  		INIT_WORK(&vport->vport_change_handler,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a13e7b20a794,e787e9212174..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -54,6 -54,43 +54,46 @@@ enum 
  #define fdb_prio_table(esw, chain, prio, level) \
  	(esw)->fdb_table.offloads.fdb_prio[(chain)][(prio)][(level)]
  
++<<<<<<< HEAD
++=======
+ #define UPLINK_REP_INDEX 0
+ 
+ /* The rep getter/iterator are only valid after esw->total_vports
+  * and vport->vport are initialized in mlx5_eswitch_init.
+  */
+ #define mlx5_esw_for_all_reps(esw, i, rep)			\
+ 	for ((i) = MLX5_VPORT_PF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) < (esw)->total_vports; (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep(esw, i, rep, nvfs)		\
+ 	for ((i) = MLX5_VPORT_FIRST_VF;				\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) <= (nvfs); (i)++)
+ 
+ #define mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvfs)	\
+ 	for ((i) = (nvfs);					\
+ 	     (rep) = &(esw)->offloads.vport_reps[i],		\
+ 	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+ 
+ #define mlx5_esw_for_each_vf_vport(esw, vport, nvfs)		\
+ 	for ((vport) = MLX5_VPORT_FIRST_VF;			\
+ 	     (vport) <= (nvfs); (vport)++)
+ 
+ #define mlx5_esw_for_each_vf_vport_reverse(esw, vport, nvfs)	\
+ 	for ((vport) = (nvfs);					\
+ 	     (vport) >= MLX5_VPORT_FIRST_VF; (vport)--)
+ 
+ static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
+ 						     u16 vport_num)
+ {
+ 	u16 idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	WARN_ON(idx > esw->total_vports - 1);
+ 	return &esw->offloads.vport_reps[idx];
+ }
+ 
++>>>>>>> 5ae5162066d8 (net/mlx5: E-Switch, Assign a different position for uplink rep and vport)
  static struct mlx5_flow_table *
  esw_get_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
  static void
@@@ -1212,9 -1251,8 +1252,8 @@@ int esw_offloads_init_reps(struct mlx5_
  {
  	int total_vfs = MLX5_TOTAL_VPORTS(esw->dev);
  	struct mlx5_core_dev *dev = esw->dev;
- 	struct mlx5_esw_offload *offloads;
  	struct mlx5_eswitch_rep *rep;
 -	u8 hw_id[ETH_ALEN], rep_type;
 +	u8 hw_id[ETH_ALEN];
  	int vport;
  
  	esw->offloads.vport_reps = kcalloc(total_vfs,
@@@ -1223,37 -1261,65 +1262,44 @@@
  	if (!esw->offloads.vport_reps)
  		return -ENOMEM;
  
- 	offloads = &esw->offloads;
  	mlx5_query_nic_vport_mac_address(dev, 0, hw_id);
  
++<<<<<<< HEAD
 +	for (vport = 0; vport < total_vfs; vport++) {
 +		rep = &offloads->vport_reps[vport];
 +
 +		rep->vport = vport;
++=======
+ 	mlx5_esw_for_all_reps(esw, vport, rep) {
+ 		rep->vport = mlx5_eswitch_index_to_vport_num(esw, vport);
++>>>>>>> 5ae5162066d8 (net/mlx5: E-Switch, Assign a different position for uplink rep and vport)
  		ether_addr_copy(rep->hw_id, hw_id);
 -
 -		for (rep_type = 0; rep_type < NUM_REP_TYPES; rep_type++)
 -			rep->rep_if[rep_type].state = REP_UNREGISTERED;
  	}
  
 -	return 0;
 -}
 -
 -static void __esw_offloads_unload_rep(struct mlx5_eswitch *esw,
 -				      struct mlx5_eswitch_rep *rep, u8 rep_type)
 -{
 -	if (rep->rep_if[rep_type].state != REP_LOADED)
 -		return;
 -
 -	rep->rep_if[rep_type].unload(rep);
 -	rep->rep_if[rep_type].state = REP_REGISTERED;
 -}
 -
 -static void __unload_reps_special_vport(struct mlx5_eswitch *esw, u8 rep_type)
 -{
 -	struct mlx5_eswitch_rep *rep;
++<<<<<<< HEAD
 +	offloads->vport_reps[0].vport = FDB_UPLINK_VPORT;
  
 -	rep = mlx5_eswitch_get_rep(esw, MLX5_VPORT_UPLINK);
 -	__esw_offloads_unload_rep(esw, rep, rep_type);
++=======
++>>>>>>> 5ae5162066d8 (net/mlx5: E-Switch, Assign a different position for uplink rep and vport)
 +	return 0;
  }
  
 -static void __unload_reps_vf_vport(struct mlx5_eswitch *esw, int nvports,
 -				   u8 rep_type)
 +static void esw_offloads_unload_reps_type(struct mlx5_eswitch *esw, int nvports,
 +					  u8 rep_type)
  {
  	struct mlx5_eswitch_rep *rep;
 -	int i;
 -
 -	mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvports)
 -		__esw_offloads_unload_rep(esw, rep, rep_type);
 -}
 -
 -static void esw_offloads_unload_vf_reps(struct mlx5_eswitch *esw, int nvports)
 -{
 -	u8 rep_type = NUM_REP_TYPES;
 -
 -	while (rep_type-- > 0)
 -		__unload_reps_vf_vport(esw, nvports, rep_type);
 -}
 +	int vport;
  
 -static void __unload_reps_all_vport(struct mlx5_eswitch *esw, int nvports,
 -				    u8 rep_type)
 -{
 -	__unload_reps_vf_vport(esw, nvports, rep_type);
 +	for (vport = nvports - 1; vport >= 0; vport--) {
 +		rep = &esw->offloads.vport_reps[vport];
 +		if (!rep->rep_if[rep_type].valid)
 +			continue;
  
 -	/* Special vports must be the last to unload. */
 -	__unload_reps_special_vport(esw, rep_type);
 +		rep->rep_if[rep_type].unload(rep);
 +	}
  }
  
 -static void esw_offloads_unload_all_reps(struct mlx5_eswitch *esw, int nvports)
 +static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
  {
  	u8 rep_type = NUM_REP_TYPES;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 6a7d5023272b..00fb048c2147 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -371,6 +371,30 @@ bool mlx5_esw_multipath_prereq(struct mlx5_core_dev *dev0,
 /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
 void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
 
+static inline int mlx5_eswitch_uplink_idx(struct mlx5_eswitch *esw)
+{
+	/* Uplink always locate at the last element of the array.*/
+	return esw->total_vports - 1;
+}
+
+static inline int mlx5_eswitch_vport_num_to_index(struct mlx5_eswitch *esw,
+						  u16 vport_num)
+{
+	if (vport_num == MLX5_VPORT_UPLINK)
+		return mlx5_eswitch_uplink_idx(esw);
+
+	return vport_num;
+}
+
+static inline int mlx5_eswitch_index_to_vport_num(struct mlx5_eswitch *esw,
+						  int index)
+{
+	if (index == mlx5_eswitch_uplink_idx(esw))
+		return MLX5_VPORT_UPLINK;
+
+	return index;
+}
+
 #else  /* CONFIG_MLX5_ESWITCH */
 /* eswitch API stubs */
 static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/vport.h b/include/linux/mlx5/vport.h
index 75268e380ab7..aab5ce1754a9 100644
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@ -36,9 +36,14 @@
 #include <linux/mlx5/driver.h>
 #include <linux/mlx5/device.h>
 
-#define MLX5_VPORT_PF_PLACEHOLDER (1u)
-#define MLX5_SPECIAL_VPORTS (MLX5_VPORT_PF_PLACEHOLDER)
-#define MLX5_TOTAL_VPORTS(mdev) (MLX5_SPECIAL_VPORTS +	mlx5_core_max_vfs(mdev))
+#define MLX5_VPORT_PF_PLACEHOLDER		(1u)
+#define MLX5_VPORT_UPLINK_PLACEHOLDER		(1u)
+
+#define MLX5_SPECIAL_VPORTS	(MLX5_VPORT_PF_PLACEHOLDER +		\
+				 MLX5_VPORT_UPLINK_PLACEHOLDER)
+
+#define MLX5_TOTAL_VPORTS(mdev)	(MLX5_SPECIAL_VPORTS +			\
+				 mlx5_core_max_vfs(mdev))
 
 #define MLX5_VPORT_MANAGER(mdev)					\
 	(MLX5_CAP_GEN(mdev, vport_group_manager) &&			\
