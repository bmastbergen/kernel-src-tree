net/mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 96.61%
commit-author Parav Pandit <parav@mellanox.com>
commit 786ef904b43b9ddb675f55ef05afad5f07fb49d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/786ef904.failed

Currently mlx5_esw_for_each_vf_vport iterates over mlx5_vport entries in
eswitch.c
Same macro in eswitch_offloads.c iterates over vport number in
eswitch_offloads.c

Instead of duplicate macro names, to avoid confusion and to reuse the
same macro in both files, move it to eswitch.h.

To iterate over vport numbers where there is no need to iterate over
mlx5_vport, but only a vport number is needed, rename those macros in
eswitch_offloads.c to mlx5_esw_for_each_vf_num_vport*.

While at it, keep all vport and vport rep iterators together.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 786ef904b43b9ddb675f55ef05afad5f07fb49d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 881a0621eae0,01dc89e9f91d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -73,6 -72,15 +73,18 @@@ static void esw_cleanup_vepa_rules(stru
  			    MC_ADDR_CHANGE | \
  			    PROMISC_CHANGE)
  
++<<<<<<< HEAD
++=======
+ static struct mlx5_vport *mlx5_eswitch_get_vport(struct mlx5_eswitch *esw,
+ 						 u16 vport_num)
+ {
+ 	u16 idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	WARN_ON(idx > esw->total_vports - 1);
+ 	return &esw->vports[idx];
+ }
+ 
++>>>>>>> 786ef904b43b (net/mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files)
  static int arm_vport_context_events_cmd(struct mlx5_core_dev *dev, u16 vport,
  					u32 events_mask)
  {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 5d30117c7129,e88feaa293f6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -49,6 -52,17 +49,20 @@@
  #define fdb_prio_table(esw, chain, prio, level) \
  	(esw)->fdb_table.offloads.fdb_prio[(chain)][(prio)][(level)]
  
++<<<<<<< HEAD
++=======
+ #define UPLINK_REP_INDEX 0
+ 
+ static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
+ 						     u16 vport_num)
+ {
+ 	u16 idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
+ 
+ 	WARN_ON(idx > esw->total_vports - 1);
+ 	return &esw->offloads.vport_reps[idx];
+ }
+ 
++>>>>>>> 786ef904b43b (net/mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files)
  static struct mlx5_flow_table *
  esw_get_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
  static void
@@@ -596,7 -611,29 +610,33 @@@ static int esw_add_fdb_peer_miss_rules(
  	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value,
  			    misc_parameters);
  
++<<<<<<< HEAD
 +	for (i = 1; i < nvports; i++) {
++=======
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
+ 		MLX5_SET(fte_match_set_misc, misc, source_port, MLX5_VPORT_PF);
+ 		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 					   spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow)) {
+ 			err = PTR_ERR(flow);
+ 			goto add_pf_flow_err;
+ 		}
+ 		flows[MLX5_VPORT_PF] = flow;
+ 	}
+ 
+ 	if (mlx5_ecpf_vport_exists(esw->dev)) {
+ 		MLX5_SET(fte_match_set_misc, misc, source_port, MLX5_VPORT_ECPF);
+ 		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
+ 					   spec, &flow_act, &dest, 1);
+ 		if (IS_ERR(flow)) {
+ 			err = PTR_ERR(flow);
+ 			goto add_ecpf_flow_err;
+ 		}
+ 		flows[mlx5_eswitch_ecpf_idx(esw)] = flow;
+ 	}
+ 
+ 	mlx5_esw_for_each_vf_vport_num(esw, i, mlx5_core_max_vfs(esw->dev)) {
++>>>>>>> 786ef904b43b (net/mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files)
  		MLX5_SET(fte_match_set_misc, misc, source_port, i);
  		flow = mlx5_add_flow_rules(esw->fdb_table.offloads.slow_fdb,
  					   spec, &flow_act, &dest, 1);
@@@ -613,9 -649,18 +653,15 @@@
  	kvfree(spec);
  	return 0;
  
++<<<<<<< HEAD
 +add_flow_err:
 +	for (i--; i > 0; i--)
++=======
+ add_vf_flow_err:
+ 	nvports = --i;
+ 	mlx5_esw_for_each_vf_vport_num_reverse(esw, i, nvports)
++>>>>>>> 786ef904b43b (net/mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files)
  		mlx5_del_flow_rules(flows[i]);
 -
 -	if (mlx5_ecpf_vport_exists(esw->dev))
 -		mlx5_del_flow_rules(flows[mlx5_eswitch_ecpf_idx(esw)]);
 -add_ecpf_flow_err:
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev))
 -		mlx5_del_flow_rules(flows[MLX5_VPORT_PF]);
 -add_pf_flow_err:
 -	esw_warn(esw->dev, "FDB: Failed to add peer miss flow rule err %d\n", err);
  	kvfree(flows);
  alloc_flows_err:
  	kvfree(spec);
@@@ -629,9 -674,16 +675,14 @@@ static void esw_del_fdb_peer_miss_rules
  
  	flows = esw->fdb_table.offloads.peer_miss_rules;
  
++<<<<<<< HEAD
 +	for (i = 1; i < esw->total_vports; i++)
++=======
+ 	mlx5_esw_for_each_vf_vport_num_reverse(esw, i,
+ 					       mlx5_core_max_vfs(esw->dev))
++>>>>>>> 786ef904b43b (net/mlx5: Reuse mlx5_esw_for_each_vf_vport macro in two files)
  		mlx5_del_flow_rules(flows[i]);
  
 -	if (mlx5_ecpf_vport_exists(esw->dev))
 -		mlx5_del_flow_rules(flows[mlx5_eswitch_ecpf_idx(esw)]);
 -
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev))
 -		mlx5_del_flow_rules(flows[MLX5_VPORT_PF]);
 -
  	kvfree(flows);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 14d8d502a0a3..cc3b29c0f1a3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -388,6 +388,48 @@ bool mlx5_esw_multipath_prereq(struct mlx5_core_dev *dev0,
 /* TODO: This mlx5e_tc function shouldn't be called by eswitch */
 void mlx5e_tc_clean_fdb_peer_flows(struct mlx5_eswitch *esw);
 
+/* The vport getter/iterator are only valid after esw->total_vports
+ * and vport->vport are initialized in mlx5_eswitch_init.
+ */
+#define mlx5_esw_for_all_vports(esw, i, vport)		\
+	for ((i) = MLX5_VPORT_PF;			\
+	     (vport) = &(esw)->vports[i],		\
+	     (i) < (esw)->total_vports; (i)++)
+
+#define mlx5_esw_for_each_vf_vport(esw, i, vport, nvfs)	\
+	for ((i) = MLX5_VPORT_FIRST_VF;			\
+	     (vport) = &(esw)->vports[(i)],		\
+	     (i) <= (nvfs); (i)++)
+
+#define mlx5_esw_for_each_vf_vport_reverse(esw, i, vport, nvfs)	\
+	for ((i) = (nvfs);					\
+	     (vport) = &(esw)->vports[(i)],			\
+	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+
+/* The rep getter/iterator are only valid after esw->total_vports
+ * and vport->vport are initialized in mlx5_eswitch_init.
+ */
+#define mlx5_esw_for_all_reps(esw, i, rep)			\
+	for ((i) = MLX5_VPORT_PF;				\
+	     (rep) = &(esw)->offloads.vport_reps[i],		\
+	     (i) < (esw)->total_vports; (i)++)
+
+#define mlx5_esw_for_each_vf_rep(esw, i, rep, nvfs)		\
+	for ((i) = MLX5_VPORT_FIRST_VF;				\
+	     (rep) = &(esw)->offloads.vport_reps[i],		\
+	     (i) <= (nvfs); (i)++)
+
+#define mlx5_esw_for_each_vf_rep_reverse(esw, i, rep, nvfs)	\
+	for ((i) = (nvfs);					\
+	     (rep) = &(esw)->offloads.vport_reps[i],		\
+	     (i) >= MLX5_VPORT_FIRST_VF; (i)--)
+
+#define mlx5_esw_for_each_vf_vport_num(esw, vport, nvfs)	\
+	for ((vport) = MLX5_VPORT_FIRST_VF; (vport) <= (nvfs); (vport)++)
+
+#define mlx5_esw_for_each_vf_vport_num_reverse(esw, vport, nvfs)	\
+	for ((vport) = (nvfs); (vport) >= MLX5_VPORT_FIRST_VF; (vport)--)
+
 #else  /* CONFIG_MLX5_ESWITCH */
 /* eswitch API stubs */
 static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
