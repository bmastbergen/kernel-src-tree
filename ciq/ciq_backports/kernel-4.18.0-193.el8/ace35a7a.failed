locking/lockdep: Reuse list entries that are no longer in use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Bart Van Assche <bvanassche@acm.org>
commit ace35a7ac493d4284a57ad807579011bebba891c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ace35a7a.failed

Instead of abandoning elements of list_entries[] that are no longer in
use, make alloc_list_entry() reuse array elements that have been freed.

	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Johannes Berg <johannes@sipsolutions.net>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: johannes.berg@intel.com
	Cc: tj@kernel.org
Link: https://lkml.kernel.org/r/20190214230058.196511-13-bvanassche@acm.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ace35a7ac493d4284a57ad807579011bebba891c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/locking/lockdep.c
diff --cc kernel/locking/lockdep.c
index ca1c46610d39,2c6d0b67e7b6..000000000000
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@@ -4157,22 -4283,41 +4164,22 @@@ static void zap_class(struct lock_clas
  	 * Remove all dependencies this lock is
  	 * involved in:
  	 */
- 	for (i = 0, entry = list_entries; i < nr_list_entries; i++, entry++) {
+ 	for_each_set_bit(i, list_entries_in_use, ARRAY_SIZE(list_entries)) {
+ 		entry = list_entries + i;
  		if (entry->class != class && entry->links_to != class)
  			continue;
+ 		__clear_bit(i, list_entries_in_use);
+ 		nr_list_entries--;
  		list_del_rcu(&entry->entry);
- 		/* Clear .class and .links_to to avoid double removal. */
- 		WRITE_ONCE(entry->class, NULL);
- 		WRITE_ONCE(entry->links_to, NULL);
  	}
 -	if (list_empty(&class->locks_after) &&
 -	    list_empty(&class->locks_before)) {
 -		list_move_tail(&class->lock_entry, &pf->zapped);
 -		hlist_del_rcu(&class->hash_entry);
 -		WRITE_ONCE(class->key, NULL);
 -		WRITE_ONCE(class->name, NULL);
 -		nr_lock_classes--;
 -	} else {
 -		WARN_ONCE(true, "%s() failed for class %s\n", __func__,
 -			  class->name);
 -	}
 -
 -	remove_class_from_lock_chains(class);
 -}
 -
 -static void reinit_class(struct lock_class *class)
 -{
 -	void *const p = class;
 -	const unsigned int offset = offsetof(struct lock_class, key);
 +	/*
 +	 * Unhash the class and remove it from the all_lock_classes list:
 +	 */
 +	hlist_del_rcu(&class->hash_entry);
 +	list_del(&class->lock_entry);
  
 -	WARN_ON_ONCE(!class->lock_entry.next);
 -	WARN_ON_ONCE(!list_empty(&class->locks_after));
 -	WARN_ON_ONCE(!list_empty(&class->locks_before));
 -	memset(p + offset, 0, sizeof(*class) - offset);
 -	WARN_ON_ONCE(!class->lock_entry.next);
 -	WARN_ON_ONCE(!list_empty(&class->locks_after));
 -	WARN_ON_ONCE(!list_empty(&class->locks_before));
 +	RCU_INIT_POINTER(class->key, NULL);
 +	RCU_INIT_POINTER(class->name, NULL);
  }
  
  static inline int within(const void *addr, void *start, unsigned long size)
@@@ -4311,7 -4603,9 +4318,13 @@@ void __init lockdep_info(void
  	       (sizeof(lock_classes) +
  		sizeof(classhash_table) +
  		sizeof(list_entries) +
++<<<<<<< HEAD
 +		sizeof(chainhash_table)
++=======
+ 		sizeof(list_entries_in_use) +
+ 		sizeof(chainhash_table) +
+ 		sizeof(delayed_free)
++>>>>>>> ace35a7ac493 (locking/lockdep: Reuse list entries that are no longer in use)
  #ifdef CONFIG_PROVE_LOCKING
  		+ sizeof(lock_cq)
  		+ sizeof(lock_chains)
* Unmerged path kernel/locking/lockdep.c
