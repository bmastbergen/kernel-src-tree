net: phy: aquantia: add SGMII statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] phy: aquantia: add SGMII statistics (Petr Oros) [1772010]
Rebuild_FUZZ: 93.33%
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 74dcb4c1a52c7c6666319a149ad4adb001f1d00b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/74dcb4c1.failed

The AQR107 family has SGMII statistics counters. Let's expose them to
ethtool. To interpret the counters correctly one has to be aware that
rx on SGMII side is tx on ethernet side. The counters are populated
by the chip in 100Mbps/1Gbps mode only.

v2:
- add constant AQR107_SGMII_STAT_SZ
- add struct aqr107_priv to be prepared for more private data fields
- let aqr107_get_stat() return U64_MAX in case of an error

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 74dcb4c1a52c7c6666319a149ad4adb001f1d00b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/aquantia_main.c
diff --cc drivers/net/phy/aquantia_main.c
index 3d4b30e24149,b7133c3f7437..000000000000
--- a/drivers/net/phy/aquantia_main.c
+++ b/drivers/net/phy/aquantia_main.c
@@@ -42,8 -58,42 +42,20 @@@
  #define MDIO_AN_RX_LP_STAT1			0xe820
  #define MDIO_AN_RX_LP_STAT1_1000BASET_FULL	BIT(15)
  #define MDIO_AN_RX_LP_STAT1_1000BASET_HALF	BIT(14)
 -#define MDIO_AN_RX_LP_STAT1_SHORT_REACH		BIT(13)
 -#define MDIO_AN_RX_LP_STAT1_AQRATE_DOWNSHIFT	BIT(12)
 -#define MDIO_AN_RX_LP_STAT1_AQ_PHY		BIT(2)
 -
 -#define MDIO_AN_RX_LP_STAT4			0xe823
 -#define MDIO_AN_RX_LP_STAT4_FW_MAJOR		GENMASK(15, 8)
 -#define MDIO_AN_RX_LP_STAT4_FW_MINOR		GENMASK(7, 0)
 -
 -#define MDIO_AN_RX_VEND_STAT3			0xe832
 -#define MDIO_AN_RX_VEND_STAT3_AFR		BIT(0)
  
+ /* MDIO_MMD_C22EXT */
+ #define MDIO_C22EXT_STAT_SGMII_RX_GOOD_FRAMES		0xd292
+ #define MDIO_C22EXT_STAT_SGMII_RX_BAD_FRAMES		0xd294
+ #define MDIO_C22EXT_STAT_SGMII_RX_FALSE_CARRIER		0xd297
+ #define MDIO_C22EXT_STAT_SGMII_TX_GOOD_FRAMES		0xd313
+ #define MDIO_C22EXT_STAT_SGMII_TX_BAD_FRAMES		0xd315
+ #define MDIO_C22EXT_STAT_SGMII_TX_FALSE_CARRIER		0xd317
+ #define MDIO_C22EXT_STAT_SGMII_TX_COLLISIONS		0xd318
+ #define MDIO_C22EXT_STAT_SGMII_TX_LINE_COLLISIONS	0xd319
+ #define MDIO_C22EXT_STAT_SGMII_TX_FRAME_ALIGN_ERR	0xd31a
+ #define MDIO_C22EXT_STAT_SGMII_TX_RUNT_FRAMES		0xd31b
+ 
  /* Vendor specific 1, MDIO_MMD_VEND1 */
 -#define VEND1_GLOBAL_FW_ID			0x0020
 -#define VEND1_GLOBAL_FW_ID_MAJOR		GENMASK(15, 8)
 -#define VEND1_GLOBAL_FW_ID_MINOR		GENMASK(7, 0)
 -
 -#define VEND1_GLOBAL_RSVD_STAT1			0xc885
 -#define VEND1_GLOBAL_RSVD_STAT1_FW_BUILD_ID	GENMASK(7, 4)
 -#define VEND1_GLOBAL_RSVD_STAT1_PROV_ID		GENMASK(3, 0)
 -
 -#define VEND1_GLOBAL_RSVD_STAT9			0xc88d
 -#define VEND1_GLOBAL_RSVD_STAT9_MODE		GENMASK(7, 0)
 -#define VEND1_GLOBAL_RSVD_STAT9_1000BT2		0x23
 -
  #define VEND1_GLOBAL_INT_STD_STATUS		0xfc00
  #define VEND1_GLOBAL_INT_VEND_STATUS		0xfc01
  
@@@ -157,6 -289,311 +251,314 @@@ static int aqr_read_status(struct phy_d
  	return genphy_c45_read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ static int aqr107_read_downshift_event(struct phy_device *phydev)
+ {
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_INT_STATUS1);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	return !!(val & MDIO_AN_TX_VEND_INT_STATUS1_DOWNSHIFT);
+ }
+ 
+ static int aqr107_read_rate(struct phy_device *phydev)
+ {
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_STATUS1);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	switch (FIELD_GET(MDIO_AN_TX_VEND_STATUS1_RATE_MASK, val)) {
+ 	case MDIO_AN_TX_VEND_STATUS1_10BASET:
+ 		phydev->speed = SPEED_10;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_100BASETX:
+ 		phydev->speed = SPEED_100;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_1000BASET:
+ 		phydev->speed = SPEED_1000;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_2500BASET:
+ 		phydev->speed = SPEED_2500;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_5000BASET:
+ 		phydev->speed = SPEED_5000;
+ 		break;
+ 	case MDIO_AN_TX_VEND_STATUS1_10GBASET:
+ 		phydev->speed = SPEED_10000;
+ 		break;
+ 	default:
+ 		phydev->speed = SPEED_UNKNOWN;
+ 		break;
+ 	}
+ 
+ 	if (val & MDIO_AN_TX_VEND_STATUS1_FULL_DUPLEX)
+ 		phydev->duplex = DUPLEX_FULL;
+ 	else
+ 		phydev->duplex = DUPLEX_HALF;
+ 
+ 	return 0;
+ }
+ 
+ static int aqr107_read_status(struct phy_device *phydev)
+ {
+ 	int val, ret;
+ 
+ 	ret = aqr_read_status(phydev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!phydev->link || phydev->autoneg == AUTONEG_DISABLE)
+ 		return 0;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_PHYXS_VEND_IF_STATUS);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	switch (FIELD_GET(MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK, val)) {
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_KR:
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_XFI:
+ 		phydev->interface = PHY_INTERFACE_MODE_10GKR;
+ 		break;
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_SGMII:
+ 		phydev->interface = PHY_INTERFACE_MODE_SGMII;
+ 		break;
+ 	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_OCSGMII:
+ 		phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+ 		break;
+ 	default:
+ 		phydev->interface = PHY_INTERFACE_MODE_NA;
+ 		break;
+ 	}
+ 
+ 	val = aqr107_read_downshift_event(phydev);
+ 	if (val <= 0)
+ 		return val;
+ 
+ 	phydev_warn(phydev, "Downshift occurred! Cabling may be defective.\n");
+ 
+ 	/* Read downshifted rate from vendor register */
+ 	return aqr107_read_rate(phydev);
+ }
+ 
+ static int aqr107_get_downshift(struct phy_device *phydev, u8 *data)
+ {
+ 	int val, cnt, enable;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV);
+ 	if (val < 0)
+ 		return val;
+ 
+ 	enable = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_EN, val);
+ 	cnt = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);
+ 
+ 	*data = enable && cnt ? cnt : DOWNSHIFT_DEV_DISABLE;
+ 
+ 	return 0;
+ }
+ 
+ static int aqr107_set_downshift(struct phy_device *phydev, u8 cnt)
+ {
+ 	int val = 0;
+ 
+ 	if (!FIELD_FIT(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt))
+ 		return -E2BIG;
+ 
+ 	if (cnt != DOWNSHIFT_DEV_DISABLE) {
+ 		val = MDIO_AN_VEND_PROV_DOWNSHIFT_EN;
+ 		val |= FIELD_PREP(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt);
+ 	}
+ 
+ 	return phy_modify_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV,
+ 			      MDIO_AN_VEND_PROV_DOWNSHIFT_EN |
+ 			      MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);
+ }
+ 
+ static int aqr107_get_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, void *data)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		return aqr107_get_downshift(phydev, data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int aqr107_set_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, const void *data)
+ {
+ 	switch (tuna->id) {
+ 	case ETHTOOL_PHY_DOWNSHIFT:
+ 		return aqr107_set_downshift(phydev, *(const u8 *)data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ /* If we configure settings whilst firmware is still initializing the chip,
+  * then these settings may be overwritten. Therefore make sure chip
+  * initialization has completed. Use presence of the firmware ID as
+  * indicator for initialization having completed.
+  * The chip also provides a "reset completed" bit, but it's cleared after
+  * read. Therefore function would time out if called again.
+  */
+ static int aqr107_wait_reset_complete(struct phy_device *phydev)
+ {
+ 	int val, retries = 100;
+ 
+ 	do {
+ 		val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);
+ 		if (val < 0)
+ 			return val;
+ 		msleep(20);
+ 	} while (!val && --retries);
+ 
+ 	return val ? 0 : -ETIMEDOUT;
+ }
+ 
+ static void aqr107_chip_info(struct phy_device *phydev)
+ {
+ 	u8 fw_major, fw_minor, build_id, prov_id;
+ 	int val;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);
+ 	if (val < 0)
+ 		return;
+ 
+ 	fw_major = FIELD_GET(VEND1_GLOBAL_FW_ID_MAJOR, val);
+ 	fw_minor = FIELD_GET(VEND1_GLOBAL_FW_ID_MINOR, val);
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT1);
+ 	if (val < 0)
+ 		return;
+ 
+ 	build_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_FW_BUILD_ID, val);
+ 	prov_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_PROV_ID, val);
+ 
+ 	phydev_dbg(phydev, "FW %u.%u, Build %u, Provisioning %u\n",
+ 		   fw_major, fw_minor, build_id, prov_id);
+ }
+ 
+ static int aqr107_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Check that the PHY interface type is compatible */
+ 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_10GKR)
+ 		return -ENODEV;
+ 
+ 	ret = aqr107_wait_reset_complete(phydev);
+ 	if (!ret)
+ 		aqr107_chip_info(phydev);
+ 
+ 	/* ensure that a latched downshift event is cleared */
+ 	aqr107_read_downshift_event(phydev);
+ 
+ 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+ }
+ 
+ static int aqcs109_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Check that the PHY interface type is compatible */
+ 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX)
+ 		return -ENODEV;
+ 
+ 	ret = aqr107_wait_reset_complete(phydev);
+ 	if (!ret)
+ 		aqr107_chip_info(phydev);
+ 
+ 	/* AQCS109 belongs to a chip family partially supporting 10G and 5G.
+ 	 * PMA speed ability bits are the same for all members of the family,
+ 	 * AQCS109 however supports speeds up to 2.5G only.
+ 	 */
+ 	ret = phy_set_max_speed(phydev, SPEED_2500);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* ensure that a latched downshift event is cleared */
+ 	aqr107_read_downshift_event(phydev);
+ 
+ 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+ }
+ 
+ static void aqr107_link_change_notify(struct phy_device *phydev)
+ {
+ 	u8 fw_major, fw_minor;
+ 	bool downshift, short_reach, afr;
+ 	int mode, val;
+ 
+ 	if (phydev->state != PHY_RUNNING || phydev->autoneg == AUTONEG_DISABLE)
+ 		return;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT1);
+ 	/* call failed or link partner is no Aquantia PHY */
+ 	if (val < 0 || !(val & MDIO_AN_RX_LP_STAT1_AQ_PHY))
+ 		return;
+ 
+ 	short_reach = val & MDIO_AN_RX_LP_STAT1_SHORT_REACH;
+ 	downshift = val & MDIO_AN_RX_LP_STAT1_AQRATE_DOWNSHIFT;
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT4);
+ 	if (val < 0)
+ 		return;
+ 
+ 	fw_major = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MAJOR, val);
+ 	fw_minor = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MINOR, val);
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_VEND_STAT3);
+ 	if (val < 0)
+ 		return;
+ 
+ 	afr = val & MDIO_AN_RX_VEND_STAT3_AFR;
+ 
+ 	phydev_dbg(phydev, "Link partner is Aquantia PHY, FW %u.%u%s%s%s\n",
+ 		   fw_major, fw_minor,
+ 		   short_reach ? ", short reach mode" : "",
+ 		   downshift ? ", fast-retrain downshift advertised" : "",
+ 		   afr ? ", fast reframe advertised" : "");
+ 
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT9);
+ 	if (val < 0)
+ 		return;
+ 
+ 	mode = FIELD_GET(VEND1_GLOBAL_RSVD_STAT9_MODE, val);
+ 	if (mode == VEND1_GLOBAL_RSVD_STAT9_1000BT2)
+ 		phydev_info(phydev, "Aquantia 1000Base-T2 mode active\n");
+ }
+ 
+ static int aqr107_suspend(struct phy_device *phydev)
+ {
+ 	return phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MDIO_CTRL1,
+ 				MDIO_CTRL1_LPOWER);
+ }
+ 
+ static int aqr107_resume(struct phy_device *phydev)
+ {
+ 	return phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MDIO_CTRL1,
+ 				  MDIO_CTRL1_LPOWER);
+ }
+ 
+ static int aqr107_probe(struct phy_device *phydev)
+ {
+ 	phydev->priv = devm_kzalloc(&phydev->mdio.dev,
+ 				    sizeof(struct aqr107_priv), GFP_KERNEL);
+ 	if (!phydev->priv)
+ 		return -ENOMEM;
+ 
+ 	return aqr_hwmon_probe(phydev);
+ }
+ 
++>>>>>>> 74dcb4c1a52c (net: phy: aquantia: add SGMII statistics)
  static struct phy_driver aqr_driver[] = {
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQ1202),
@@@ -205,23 -638,42 +607,59 @@@
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQR107),
  	.name		= "Aquantia AQR107",
 +	.features	= PHY_10GBIT_FULL_FEATURES,
 +	.flags		= PHY_HAS_INTERRUPT,
  	.aneg_done	= genphy_c45_aneg_done,
++<<<<<<< HEAD
 +	.config_aneg    = aqr_config_aneg,
 +	.config_intr	= aqr_config_intr,
 +	.ack_interrupt	= aqr_ack_interrupt,
 +	.read_status	= aqr_read_status,
++=======
+ 	.get_features	= genphy_c45_pma_read_abilities,
+ 	.probe		= aqr107_probe,
+ 	.config_init	= aqr107_config_init,
+ 	.config_aneg    = aqr_config_aneg,
+ 	.config_intr	= aqr_config_intr,
+ 	.ack_interrupt	= aqr_ack_interrupt,
+ 	.read_status	= aqr107_read_status,
+ 	.get_tunable    = aqr107_get_tunable,
+ 	.set_tunable    = aqr107_set_tunable,
+ 	.suspend	= aqr107_suspend,
+ 	.resume		= aqr107_resume,
+ 	.get_sset_count	= aqr107_get_sset_count,
+ 	.get_strings	= aqr107_get_strings,
+ 	.get_stats	= aqr107_get_stats,
+ 	.link_change_notify = aqr107_link_change_notify,
++>>>>>>> 74dcb4c1a52c (net: phy: aquantia: add SGMII statistics)
  },
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQCS109),
  	.name		= "Aquantia AQCS109",
 +	.features	= PHY_10GBIT_FULL_FEATURES,
  	.aneg_done	= genphy_c45_aneg_done,
++<<<<<<< HEAD
 +	.config_aneg    = aqr_config_aneg,
 +	.config_intr	= aqr_config_intr,
 +	.ack_interrupt	= aqr_ack_interrupt,
 +	.read_status	= aqr_read_status,
++=======
+ 	.get_features	= genphy_c45_pma_read_abilities,
+ 	.probe		= aqr107_probe,
+ 	.config_init	= aqcs109_config_init,
+ 	.config_aneg    = aqr_config_aneg,
+ 	.config_intr	= aqr_config_intr,
+ 	.ack_interrupt	= aqr_ack_interrupt,
+ 	.read_status	= aqr107_read_status,
+ 	.get_tunable    = aqr107_get_tunable,
+ 	.set_tunable    = aqr107_set_tunable,
+ 	.suspend	= aqr107_suspend,
+ 	.resume		= aqr107_resume,
+ 	.get_sset_count	= aqr107_get_sset_count,
+ 	.get_strings	= aqr107_get_strings,
+ 	.get_stats	= aqr107_get_stats,
+ 	.link_change_notify = aqr107_link_change_notify,
++>>>>>>> 74dcb4c1a52c (net: phy: aquantia: add SGMII statistics)
  },
  {
  	PHY_ID_MATCH_MODEL(PHY_ID_AQR405),
* Unmerged path drivers/net/phy/aquantia_main.c
