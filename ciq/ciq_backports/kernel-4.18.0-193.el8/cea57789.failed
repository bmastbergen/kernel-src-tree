SUNRPC: Clean up

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit cea57789e4081870ac3498fbefabbbd0d0fd8434
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/cea57789.failed

Replace remaining callers of call_timeout() with rpc_check_timeout().

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit cea57789e4081870ac3498fbefabbbd0d0fd8434)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 53c6c503223a,a0e7322fc171..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2183,7 -2218,6 +2180,10 @@@ call_status(struct rpc_task *task
  	case -EPIPE:
  	case -ENOTCONN:
  	case -EAGAIN:
++<<<<<<< HEAD
 +		task->tk_action = call_bind;
++=======
++>>>>>>> cea57789e408 (SUNRPC: Clean up)
  		break;
  	case -EIO:
  		/* shutdown or soft timeout */
@@@ -2193,17 -2226,17 +2192,22 @@@
  		if (clnt->cl_chatty)
  			printk("%s: RPC call returned error %d\n",
  			       clnt->cl_program->name, -status);
- 		rpc_exit(task, status);
+ 		goto out_exit;
  	}
+ 	task->tk_action = call_encode;
+ 	rpc_check_timeout(task);
+ 	return;
+ out_exit:
+ 	rpc_exit(task, status);
  }
  
 +/*
 + * 6a.	Handle RPC timeout
 + * 	We do not release the request slot, so we keep using the
 + *	same XID for all retransmits.
 + */
  static void
 -rpc_check_timeout(struct rpc_task *task)
 +call_timeout(struct rpc_task *task)
  {
  	struct rpc_clnt	*clnt = task->tk_client;
  
@@@ -2246,12 -2277,8 +2250,15 @@@
  	 * event? RFC2203 requires the server to drop all such requests.
  	 */
  	rpcauth_invalcred(task);
 +
++<<<<<<< HEAD
 +retry:
 +	task->tk_action = call_bind;
 +	task->tk_status = 0;
  }
  
++=======
++>>>>>>> cea57789e408 (SUNRPC: Clean up)
  /*
   * 7.	Decode the RPC reply
   */
@@@ -2290,39 -2316,32 +2297,57 @@@ call_decode(struct rpc_task *task
  	WARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,
  				sizeof(req->rq_rcv_buf)) != 0);
  
++<<<<<<< HEAD
 +	if (req->rq_rcv_buf.len < 12) {
 +		if (!RPC_IS_SOFT(task)) {
 +			task->tk_action = call_bind;
 +			goto out_retry;
 +		}
 +		dprintk("RPC:       %s: too small RPC reply size (%d bytes)\n",
 +				clnt->cl_program->name, task->tk_status);
 +		task->tk_action = call_timeout;
++=======
+ 	if (req->rq_rcv_buf.len < 12)
++>>>>>>> cea57789e408 (SUNRPC: Clean up)
  		goto out_retry;
- 	}
  
 -	xdr_init_decode(&xdr, &req->rq_rcv_buf,
 -			req->rq_rcv_buf.head[0].iov_base, req);
 -	switch (rpc_decode_header(task, &xdr)) {
 -	case 0:
 -		task->tk_action = rpc_exit_task;
 -		task->tk_status = rpcauth_unwrap_resp(task, &xdr);
 -		dprintk("RPC: %5u %s result %d\n",
 -			task->tk_pid, __func__, task->tk_status);
 +	p = rpc_verify_header(task);
 +	if (IS_ERR(p)) {
 +		if (p == ERR_PTR(-EAGAIN))
 +			goto out_retry;
  		return;
 -	case -EAGAIN:
 +	}
 +	task->tk_action = rpc_exit_task;
 +
 +	task->tk_status = rpcauth_unwrap_resp(task, decode, req, p,
 +					      task->tk_msg.rpc_resp);
 +
 +	dprintk("RPC: %5u call_decode result %d\n", task->tk_pid,
 +			task->tk_status);
 +	return;
  out_retry:
++<<<<<<< HEAD
 +	task->tk_status = 0;
 +	/* Note: rpc_verify_header() may have freed the RPC slot */
 +	if (task->tk_rqstp == req) {
 +		req->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;
 +		if (task->tk_client->cl_discrtry)
 +			xprt_conditional_disconnect(req->rq_xprt,
 +					req->rq_connect_cookie);
++=======
+ 		task->tk_status = 0;
+ 		/* Note: rpc_decode_header() may have freed the RPC slot */
+ 		if (task->tk_rqstp == req) {
+ 			xdr_free_bvec(&req->rq_rcv_buf);
+ 			req->rq_reply_bytes_recvd = 0;
+ 			req->rq_rcv_buf.len = 0;
+ 			if (task->tk_client->cl_discrtry)
+ 				xprt_conditional_disconnect(req->rq_xprt,
+ 							    req->rq_connect_cookie);
+ 		}
+ 		task->tk_action = call_encode;
+ 		rpc_check_timeout(task);
++>>>>>>> cea57789e408 (SUNRPC: Clean up)
  	}
  }
  
* Unmerged path net/sunrpc/clnt.c
