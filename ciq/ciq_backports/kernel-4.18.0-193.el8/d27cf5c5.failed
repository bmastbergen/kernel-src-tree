net: core: add MPLS update core helper and use in OvS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] core: add MPLS update core helper and use in OvS (Ivan Vecera) [1737820]
Rebuild_FUZZ: 95.05%
commit-author John Hurley <john.hurley@netronome.com>
commit d27cf5c59a12f66425df29cd81f61aa73ef14ac1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d27cf5c5.failed

Open vSwitch allows the updating of an existing MPLS header on a packet.
In preparation for supporting similar functionality in TC, move this to a
common skb helper function.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Reviewed-by: Willem de Bruijn <willemb@google.com>
	Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d27cf5c59a12f66425df29cd81f61aa73ef14ac1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/skbuff.c
diff --cc include/linux/skbuff.h
index 45ac9388e751,9f7e01f2be83..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3408,6 -3448,8 +3408,11 @@@ int __skb_vlan_pop(struct sk_buff *skb
  int skb_vlan_pop(struct sk_buff *skb);
  int skb_vlan_push(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci);
  int skb_mpls_push(struct sk_buff *skb, __be32 mpls_lse, __be16 mpls_proto);
++<<<<<<< HEAD
++=======
+ int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto);
+ int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse);
++>>>>>>> d27cf5c59a12 (net: core: add MPLS update core helper and use in OvS)
  struct sk_buff *pskb_extract(struct sk_buff *skb, int off, int to_copy,
  			     gfp_t gfp);
  
diff --cc net/core/skbuff.c
index 20259cd3ce3e,93443a01ab39..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -5309,6 -5490,81 +5309,84 @@@ int skb_mpls_push(struct sk_buff *skb, 
  EXPORT_SYMBOL_GPL(skb_mpls_push);
  
  /**
++<<<<<<< HEAD
++=======
+  * skb_mpls_pop() - pop the outermost MPLS header
+  *
+  * @skb: buffer
+  * @next_proto: ethertype of header after popped MPLS header
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_pop(struct sk_buff *skb, __be16 next_proto)
+ {
+ 	int err;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return -EINVAL;
+ 
+ 	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	skb_postpull_rcsum(skb, mpls_hdr(skb), MPLS_HLEN);
+ 	memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),
+ 		skb->mac_len);
+ 
+ 	__skb_pull(skb, MPLS_HLEN);
+ 	skb_reset_mac_header(skb);
+ 	skb_set_network_header(skb, skb->mac_len);
+ 
+ 	if (skb->dev && skb->dev->type == ARPHRD_ETHER) {
+ 		struct ethhdr *hdr;
+ 
+ 		/* use mpls_hdr() to get ethertype to account for VLANs. */
+ 		hdr = (struct ethhdr *)((void *)mpls_hdr(skb) - ETH_HLEN);
+ 		skb_mod_eth_type(skb, hdr, next_proto);
+ 	}
+ 	skb->protocol = next_proto;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_pop);
+ 
+ /**
+  * skb_mpls_update_lse() - modify outermost MPLS header and update csum
+  *
+  * @skb: buffer
+  * @mpls_lse: new MPLS label stack entry to update to
+  *
+  * Expects skb->data at mac header.
+  *
+  * Returns 0 on success, -errno otherwise.
+  */
+ int skb_mpls_update_lse(struct sk_buff *skb, __be32 mpls_lse)
+ {
+ 	int err;
+ 
+ 	if (unlikely(!eth_p_mpls(skb->protocol)))
+ 		return -EINVAL;
+ 
+ 	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+ 		__be32 diff[] = { ~mpls_hdr(skb)->label_stack_entry, mpls_lse };
+ 
+ 		skb->csum = csum_partial((char *)diff, sizeof(diff), skb->csum);
+ 	}
+ 
+ 	mpls_hdr(skb)->label_stack_entry = mpls_lse;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(skb_mpls_update_lse);
+ 
+ /**
++>>>>>>> d27cf5c59a12 (net: core: add MPLS update core helper and use in OvS)
   * alloc_skb_with_frags - allocate skb with page frags
   *
   * @header_len: size of linear part
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/skbuff.c
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index c45ff6be42d0..9d63dbeb00da 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -235,19 +235,12 @@ static int set_mpls(struct sk_buff *skb, struct sw_flow_key *flow_key,
 	__be32 lse;
 	int err;
 
-	err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);
-	if (unlikely(err))
-		return err;
-
 	stack = mpls_hdr(skb);
 	lse = OVS_MASKED(stack->label_stack_entry, *mpls_lse, *mask);
-	if (skb->ip_summed == CHECKSUM_COMPLETE) {
-		__be32 diff[] = { ~(stack->label_stack_entry), lse };
-
-		skb->csum = csum_partial((char *)diff, sizeof(diff), skb->csum);
-	}
+	err = skb_mpls_update_lse(skb, lse);
+	if (err)
+		return err;
 
-	stack->label_stack_entry = lse;
 	flow_key->mpls.top_lse = lse;
 	return 0;
 }
