net/mlx5: E-Switch, Enable vport metadata matching if firmware supports it

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Enable vport metadata matching if firmware supports it (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 97.22%
commit-author Jianbo Liu <jianbol@mellanox.com>
commit 92ab1eb392c6ac6f7fdeee4bfdfb39aa860a371f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/92ab1eb3.failed

As the ingress ACL rules save vhca id and vport number to packet's
metadata REG_C_0, and the metadata matching for the rules in both fast
path and slow path are all added, enable this feature if supported.

	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 92ab1eb392c6ac6f7fdeee4bfdfb39aa860a371f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7,174b0ec4162f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1521,20 -1863,91 +1521,92 @@@ out_no_mem
  	return err;
  }
  
 -static int esw_vport_ingress_common_config(struct mlx5_eswitch *esw,
 -					   struct mlx5_vport *vport)
 +static int esw_prio_tag_acls_config(struct mlx5_eswitch *esw, int nvports)
  {
++<<<<<<< HEAD
 +	int i, j;
 +	int err;
 +
 +	mlx5_esw_for_each_vf_vport(esw, i, nvports) {
 +		err = esw_vport_ingress_prio_tag_config(esw, &esw->vports[i]);
++=======
+ 	int err;
+ 
+ 	if (!mlx5_eswitch_vport_match_metadata_enabled(esw) &&
+ 	    !MLX5_CAP_GEN(esw->dev, prio_tag_required))
+ 		return 0;
+ 
+ 	esw_vport_cleanup_ingress_rules(esw, vport);
+ 
+ 	err = esw_vport_enable_ingress_acl(esw, vport);
+ 	if (err) {
+ 		esw_warn(esw->dev,
+ 			 "failed to enable ingress acl (%d) on vport[%d]\n",
+ 			 err, vport->vport);
+ 		return err;
+ 	}
+ 
+ 	esw_debug(esw->dev,
+ 		  "vport[%d] configure ingress rules\n", vport->vport);
+ 
+ 	if (mlx5_eswitch_vport_match_metadata_enabled(esw)) {
+ 		err = esw_vport_add_ingress_acl_modify_metadata(esw, vport);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(esw->dev, prio_tag_required) &&
+ 	    mlx5_eswitch_is_vf_vport(esw, vport->vport)) {
+ 		err = esw_vport_ingress_prio_tag_config(esw, vport);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ out:
+ 	if (err)
+ 		esw_vport_disable_ingress_acl(esw, vport);
+ 	return err;
+ }
+ 
+ static bool
+ esw_check_vport_match_metadata_supported(const struct mlx5_eswitch *esw)
+ {
+ 	if (!MLX5_CAP_ESW(esw->dev, esw_uplink_ingress_acl))
+ 		return false;
+ 
+ 	if (!(MLX5_CAP_ESW_FLOWTABLE(esw->dev, fdb_to_vport_reg_c_id) &
+ 	      MLX5_FDB_TO_VPORT_REG_C_0))
+ 		return false;
+ 
+ 	if (!MLX5_CAP_ESW_FLOWTABLE(esw->dev, flow_source))
+ 		return false;
+ 
+ 	if (mlx5_core_is_ecpf_esw_manager(esw->dev) ||
+ 	    mlx5_ecpf_vport_exists(esw->dev))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static int esw_create_offloads_acl_tables(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_vport *vport;
+ 	int i, j;
+ 	int err;
+ 
+ 	if (esw_check_vport_match_metadata_supported(esw))
+ 		esw->flags |= MLX5_ESWITCH_VPORT_MATCH_METADATA;
+ 
+ 	mlx5_esw_for_all_vports(esw, i, vport) {
+ 		err = esw_vport_ingress_common_config(esw, vport);
++>>>>>>> 92ab1eb392c6 (net/mlx5: E-Switch, Enable vport metadata matching if firmware supports it)
  		if (err)
  			goto err_ingress;
 -
 -		if (mlx5_eswitch_is_vf_vport(esw, vport->vport)) {
 -			err = esw_vport_egress_prio_tag_config(esw, vport);
 -			if (err)
 -				goto err_egress;
 -		}
 +		err = esw_vport_egress_prio_tag_config(esw, &esw->vports[i]);
 +		if (err)
 +			goto err_egress;
  	}
  
 -	if (mlx5_eswitch_vport_match_metadata_enabled(esw))
 -		esw_info(esw->dev, "Use metadata reg_c as source vport to match\n");
 -
  	return 0;
  
  err_egress:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
