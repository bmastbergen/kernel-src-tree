fuse: simplify request allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 7213394c4e184b002d8011c13d916e7ac6d17520
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/7213394c.failed

Page arrays are not allocated together with the request anymore.  Get rid
of the dead code

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 7213394c4e184b002d8011c13d916e7ac6d17520)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
#	fs/fuse/fuse_i.h
diff --cc fs/fuse/dev.c
index 64cb2e924653,f240d541edfc..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -77,55 -58,8 +58,56 @@@ static struct fuse_req *fuse_request_al
  	return req;
  }
  
++<<<<<<< HEAD
 +struct fuse_req *fuse_request_alloc(unsigned npages)
 +{
 +	return __fuse_request_alloc(npages, GFP_KERNEL);
 +}
 +EXPORT_SYMBOL_GPL(fuse_request_alloc);
 +
 +struct fuse_req *fuse_request_alloc_nofs(unsigned npages)
 +{
 +	return __fuse_request_alloc(npages, GFP_NOFS);
 +}
 +
 +static void fuse_req_pages_free(struct fuse_req *req)
 +{
 +	if (test_bit(FR_ALLOC_PAGES, &req->flags))
 +		kfree(req->pages);
 +}
 +
 +bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
 +			    gfp_t flags)
 +{
 +	struct page **pages;
 +	struct fuse_page_desc *page_descs;
 +	unsigned int npages = min_t(unsigned int,
 +				    max_t(unsigned int, req->max_pages * 2,
 +					  FUSE_DEFAULT_MAX_PAGES_PER_REQ),
 +				    fc->max_pages);
 +	WARN_ON(npages <= req->max_pages);
 +
 +	pages = fuse_pages_alloc(npages, flags, &page_descs);
 +	if (!pages)
 +		return false;
 +
 +	memcpy(pages, req->pages, sizeof(struct page *) * req->max_pages);
 +	memcpy(page_descs, req->page_descs,
 +	       sizeof(struct fuse_page_desc) * req->max_pages);
 +	fuse_req_pages_free(req);
 +	__set_bit(FR_ALLOC_PAGES, &req->flags);
 +	req->pages = pages;
 +	req->page_descs = page_descs;
 +	req->max_pages = npages;
 +
 +	return true;
 +}
 +
 +void fuse_request_free(struct fuse_req *req)
++=======
+ static void fuse_request_free(struct fuse_req *req)
++>>>>>>> 7213394c4e18 (fuse: simplify request allocation)
  {
- 	fuse_req_pages_free(req);
  	kmem_cache_free(fuse_req_cachep, req);
  }
  
@@@ -166,8 -100,9 +148,14 @@@ static void fuse_drop_waiting(struct fu
  	}
  }
  
++<<<<<<< HEAD
 +static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,
 +				       bool for_background)
++=======
+ static void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
+ 
+ static struct fuse_req *fuse_get_req(struct fuse_conn *fc, bool for_background)
++>>>>>>> 7213394c4e18 (fuse: simplify request allocation)
  {
  	struct fuse_req *req;
  	int err;
@@@ -218,20 -153,7 +206,24 @@@
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
 +struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages)
 +{
 +	return __fuse_get_req(fc, npages, false);
 +}
 +EXPORT_SYMBOL_GPL(fuse_get_req);
 +
 +struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
 +					     unsigned npages)
 +{
 +	return __fuse_get_req(fc, npages, true);
 +}
 +EXPORT_SYMBOL_GPL(fuse_get_req_for_background);
 +
 +void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)
++=======
+ static void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)
++>>>>>>> 7213394c4e18 (fuse: simplify request allocation)
  {
  	if (refcount_dec_and_test(&req->count)) {
  		if (test_bit(FR_BACKGROUND, &req->flags)) {
diff --cc fs/fuse/fuse_i.h
index 9711237b572b,90cb82d5d62d..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -910,48 -921,6 +909,51 @@@ int fuse_ctl_init(void)
  void __exit fuse_ctl_cleanup(void);
  
  /**
++<<<<<<< HEAD
 + * Allocate a request
 + */
 +struct fuse_req *fuse_request_alloc(unsigned npages);
 +
 +struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 +
 +struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
 +			       struct fuse_page_desc **desc);
 +bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
 +			    gfp_t flags);
 +
 +
 +/**
 + * Free a request
 + */
 +void fuse_request_free(struct fuse_req *req);
 +
 +/**
 + * Get a request, may fail with -ENOMEM,
 + * caller should specify # elements in req->pages[] explicitly
 + */
 +struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages);
 +struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
 +					     unsigned npages);
 +
 +/*
 + * Increment reference count on request
 + */
 +void __fuse_get_request(struct fuse_req *req);
 +
 +/**
 + * Decrement reference count of a request.  If count goes to zero free
 + * the request.
 + */
 +void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
 +
 +/**
 + * Send a request (synchronous)
 + */
 +void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
 +
 +/**
++=======
++>>>>>>> 7213394c4e18 (fuse: simplify request allocation)
   * Simple request sending that does request allocation and freeing
   */
  ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
* Unmerged path fs/fuse/dev.c
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 5aa3069d8a02..888b350b2576 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -19,8 +19,8 @@
 #include <linux/falloc.h>
 #include <linux/uio.h>
 
-struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
-			       struct fuse_page_desc **desc)
+static struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
+				      struct fuse_page_desc **desc)
 {
 	struct page **pages;
 
* Unmerged path fs/fuse/fuse_i.h
