KVM: nVMX: Update vmcs12 for SYSENTER MSRs when they're written

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit de70d279709efb7d0b0c0dce2eb398fc43c4b7f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/de70d279.failed

For L2, KVM always intercepts WRMSR to SYSENTER MSRs.  Update vmcs12 in
the WRMSR handler so that they don't need to be (re)read from vmcs02 on
every nested VM-Exit.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit de70d279709efb7d0b0c0dce2eb398fc43c4b7f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/vmx/nested.c
index 30e583bdd230,c096e803e6f0..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -3457,11 -3465,69 +3457,15 @@@ static void sync_vmcs12(struct kvm_vcp
  	vmcs12->guest_tr_base = vmcs_readl(GUEST_TR_BASE);
  	vmcs12->guest_gdtr_base = vmcs_readl(GUEST_GDTR_BASE);
  	vmcs12->guest_idtr_base = vmcs_readl(GUEST_IDTR_BASE);
 -	vmcs12->guest_pending_dbg_exceptions =
 -		vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);
 -	if (kvm_mpx_supported())
 -		vmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);
 -
 -	vmx->nested.need_sync_vmcs02_to_vmcs12_rare = false;
 -}
 -
 -static void copy_vmcs02_to_vmcs12_rare(struct kvm_vcpu *vcpu,
 -				       struct vmcs12 *vmcs12)
 -{
 -	struct vcpu_vmx *vmx = to_vmx(vcpu);
 -	int cpu;
 -
 -	if (!vmx->nested.need_sync_vmcs02_to_vmcs12_rare)
 -		return;
 -
 -
 -	WARN_ON_ONCE(vmx->loaded_vmcs != &vmx->vmcs01);
 -
 -	cpu = get_cpu();
 -	vmx->loaded_vmcs = &vmx->nested.vmcs02;
 -	vmx_vcpu_load(&vmx->vcpu, cpu);
 -
 -	sync_vmcs02_to_vmcs12_rare(vcpu, vmcs12);
 -
 -	vmx->loaded_vmcs = &vmx->vmcs01;
 -	vmx_vcpu_load(&vmx->vcpu, cpu);
 -	put_cpu();
 -}
 -
 -/*
 - * Update the guest state fields of vmcs12 to reflect changes that
 - * occurred while L2 was running. (The "IA-32e mode guest" bit of the
 - * VM-entry controls is also updated, since this is really a guest
 - * state bit.)
 - */
 -static void sync_vmcs02_to_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
 -{
 -	struct vcpu_vmx *vmx = to_vmx(vcpu);
 -
 -	if (vmx->nested.hv_evmcs)
 -		sync_vmcs02_to_vmcs12_rare(vcpu, vmcs12);
 -
 -	vmx->nested.need_sync_vmcs02_to_vmcs12_rare = !vmx->nested.hv_evmcs;
 -
 -	vmcs12->guest_cr0 = vmcs12_guest_cr0(vcpu, vmcs12);
 -	vmcs12->guest_cr4 = vmcs12_guest_cr4(vcpu, vmcs12);
 -
 -	vmcs12->guest_rsp = kvm_rsp_read(vcpu);
 -	vmcs12->guest_rip = kvm_rip_read(vcpu);
 -	vmcs12->guest_rflags = vmcs_readl(GUEST_RFLAGS);
 -
 -	vmcs12->guest_cs_ar_bytes = vmcs_read32(GUEST_CS_AR_BYTES);
 -	vmcs12->guest_ss_ar_bytes = vmcs_read32(GUEST_SS_AR_BYTES);
  
+ 	vmcs12->guest_sysenter_cs = vmcs_read32(GUEST_SYSENTER_CS);
+ 	vmcs12->guest_sysenter_esp = vmcs_readl(GUEST_SYSENTER_ESP);
+ 	vmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);
+ 
  	vmcs12->guest_interruptibility_info =
  		vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);
 -
 +	vmcs12->guest_pending_dbg_exceptions =
 +		vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS);
  	if (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)
  		vmcs12->guest_activity_state = GUEST_ACTIVITY_HLT;
  	else
@@@ -3504,11 -3570,6 +3508,14 @@@
  
  	if (vmcs12->vm_exit_controls & VM_EXIT_SAVE_IA32_EFER)
  		vmcs12->guest_ia32_efer = vcpu->arch.efer;
++<<<<<<< HEAD
 +	vmcs12->guest_sysenter_cs = vmcs_read32(GUEST_SYSENTER_CS);
 +	vmcs12->guest_sysenter_esp = vmcs_readl(GUEST_SYSENTER_ESP);
 +	vmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);
 +	if (kvm_mpx_supported())
 +		vmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);
++=======
++>>>>>>> de70d279709e (KVM: nVMX: Update vmcs12 for SYSENTER MSRs when they're written)
  }
  
  /*
* Unmerged path arch/x86/kvm/vmx/nested.c
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 2f1e38e866a9..5940adf7be6a 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -1831,12 +1831,18 @@ static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		break;
 #endif
 	case MSR_IA32_SYSENTER_CS:
+		if (is_guest_mode(vcpu))
+			get_vmcs12(vcpu)->guest_sysenter_cs = data;
 		vmcs_write32(GUEST_SYSENTER_CS, data);
 		break;
 	case MSR_IA32_SYSENTER_EIP:
+		if (is_guest_mode(vcpu))
+			get_vmcs12(vcpu)->guest_sysenter_eip = data;
 		vmcs_writel(GUEST_SYSENTER_EIP, data);
 		break;
 	case MSR_IA32_SYSENTER_ESP:
+		if (is_guest_mode(vcpu))
+			get_vmcs12(vcpu)->guest_sysenter_esp = data;
 		vmcs_writel(GUEST_SYSENTER_ESP, data);
 		break;
 	case MSR_IA32_BNDCFGS:
