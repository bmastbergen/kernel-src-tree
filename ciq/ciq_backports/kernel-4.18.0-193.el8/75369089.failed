SUNRPC: Ensure the bvecs are reset when we re-encode the RPC request

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 75369089820473eac45e9ddd970081901a373c08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/75369089.failed

The bvec tracks the list of pages, so if the number of pages changes
due to a re-encode, we need to reset the bvec as well.

Fixes: 277e4ab7d530 ("SUNRPC: Simplify TCP receive code by switching...")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Cc: stable@vger.kernel.org # v4.20+
(cherry picked from commit 75369089820473eac45e9ddd970081901a373c08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
#	net/sunrpc/xprt.c
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/clnt.c
index 4c9385209a04,d8679b6027e9..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -1750,21 -1862,79 +1750,67 @@@ rpc_xdr_encode(struct rpc_task *task
  		     req->rq_rbuffer,
  		     req->rq_rcvsize);
  
++<<<<<<< HEAD
 +	p = rpc_encode_header(task);
 +	if (p == NULL) {
 +		printk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");
 +		rpc_exit(task, -EIO);
 +		return;
++=======
+ 	req->rq_snd_buf.head[0].iov_len = 0;
+ 	xdr_init_encode(&xdr, &req->rq_snd_buf,
+ 			req->rq_snd_buf.head[0].iov_base, req);
+ 	xdr_free_bvec(&req->rq_snd_buf);
+ 	if (rpc_encode_header(task, &xdr))
+ 		return;
+ 
+ 	task->tk_status = rpcauth_wrap_req(task, &xdr);
+ }
+ 
+ /*
+  * 3.	Encode arguments of an RPC call
+  */
+ static void
+ call_encode(struct rpc_task *task)
+ {
+ 	if (!rpc_task_need_encode(task))
+ 		goto out;
+ 	dprint_status(task);
+ 	/* Encode here so that rpcsec_gss can use correct sequence number. */
+ 	rpc_xdr_encode(task);
+ 	/* Did the encode result in an error condition? */
+ 	if (task->tk_status != 0) {
+ 		/* Was the error nonfatal? */
+ 		switch (task->tk_status) {
+ 		case -EAGAIN:
+ 		case -ENOMEM:
+ 			rpc_delay(task, HZ >> 4);
+ 			break;
+ 		case -EKEYEXPIRED:
+ 			if (!task->tk_cred_retry) {
+ 				rpc_exit(task, task->tk_status);
+ 			} else {
+ 				task->tk_action = call_refresh;
+ 				task->tk_cred_retry--;
+ 				dprintk("RPC: %5u %s: retry refresh creds\n",
+ 					task->tk_pid, __func__);
+ 			}
+ 			break;
+ 		default:
+ 			rpc_call_rpcerror(task, task->tk_status);
+ 		}
+ 		return;
++>>>>>>> 753690898204 (SUNRPC: Ensure the bvecs are reset when we re-encode the RPC request)
  	}
  
 -	/* Add task to reply queue before transmission to avoid races */
 -	if (rpc_reply_expected(task))
 -		xprt_request_enqueue_receive(task);
 -	xprt_request_enqueue_transmit(task);
 -out:
 -	task->tk_action = call_transmit;
 -	/* Check that the connection is OK */
 -	if (!xprt_bound(task->tk_xprt))
 -		task->tk_action = call_bind;
 -	else if (!xprt_connected(task->tk_xprt))
 -		task->tk_action = call_connect;
 -}
 -
 -/*
 - * Helpers to check if the task was already transmitted, and
 - * to take action when that is the case.
 - */
 -static bool
 -rpc_task_transmitted(struct rpc_task *task)
 -{
 -	return !test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
 -}
 +	encode = task->tk_msg.rpc_proc->p_encode;
 +	if (encode == NULL)
 +		return;
  
 -static void
 -rpc_task_handle_transmitted(struct rpc_task *task)
 -{
 -	xprt_end_transmit(task);
 -	task->tk_action = call_transmit_status;
 +	task->tk_status = rpcauth_wrap_req(task, encode, req, p,
 +			task->tk_msg.rpc_argp);
 +	if (task->tk_status == 0)
 +		set_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);
  }
  
  /*
diff --cc net/sunrpc/xprt.c
index c4d4cd12e49e,783748dc5e6f..000000000000
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@@ -879,6 -1014,65 +879,68 @@@ static void xprt_wait_on_pinned_rqst(st
  	wait_var_event(&req->rq_pin, !xprt_is_pinned_rqst(req));
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ xprt_request_data_received(struct rpc_task *task)
+ {
+ 	return !test_bit(RPC_TASK_NEED_RECV, &task->tk_runstate) &&
+ 		READ_ONCE(task->tk_rqstp->rq_reply_bytes_recvd) != 0;
+ }
+ 
+ static bool
+ xprt_request_need_enqueue_receive(struct rpc_task *task, struct rpc_rqst *req)
+ {
+ 	return !test_bit(RPC_TASK_NEED_RECV, &task->tk_runstate) &&
+ 		READ_ONCE(task->tk_rqstp->rq_reply_bytes_recvd) == 0;
+ }
+ 
+ /**
+  * xprt_request_enqueue_receive - Add an request to the receive queue
+  * @task: RPC task
+  *
+  */
+ void
+ xprt_request_enqueue_receive(struct rpc_task *task)
+ {
+ 	struct rpc_rqst *req = task->tk_rqstp;
+ 	struct rpc_xprt *xprt = req->rq_xprt;
+ 
+ 	if (!xprt_request_need_enqueue_receive(task, req))
+ 		return;
+ 
+ 	xprt_request_prepare(task->tk_rqstp);
+ 	spin_lock(&xprt->queue_lock);
+ 
+ 	/* Update the softirq receive buffer */
+ 	memcpy(&req->rq_private_buf, &req->rq_rcv_buf,
+ 			sizeof(req->rq_private_buf));
+ 
+ 	/* Add request to the receive list */
+ 	xprt_request_rb_insert(xprt, req);
+ 	set_bit(RPC_TASK_NEED_RECV, &task->tk_runstate);
+ 	spin_unlock(&xprt->queue_lock);
+ 
+ 	/* Turn off autodisconnect */
+ 	del_singleshot_timer_sync(&xprt->timer);
+ }
+ 
+ /**
+  * xprt_request_dequeue_receive_locked - Remove a request from the receive queue
+  * @task: RPC task
+  *
+  * Caller must hold xprt->queue_lock.
+  */
+ static void
+ xprt_request_dequeue_receive_locked(struct rpc_task *task)
+ {
+ 	struct rpc_rqst *req = task->tk_rqstp;
+ 
+ 	if (test_and_clear_bit(RPC_TASK_NEED_RECV, &task->tk_runstate))
+ 		xprt_request_rb_remove(req->rq_xprt, req);
+ }
+ 
++>>>>>>> 753690898204 (SUNRPC: Ensure the bvecs are reset when we re-encode the RPC request)
  /**
   * xprt_update_rtt - Update RPC RTT statistics
   * @task: RPC request that recently completed
diff --cc net/sunrpc/xprtsock.c
index 2984e705d710,e2176c167a57..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -524,6 -906,13 +524,16 @@@ static int xs_nospace(struct rpc_rqst *
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ xs_stream_prepare_request(struct rpc_rqst *req)
+ {
+ 	xdr_free_bvec(&req->rq_rcv_buf);
+ 	req->rq_task->tk_status = xdr_alloc_bvec(&req->rq_rcv_buf, GFP_KERNEL);
+ }
+ 
++>>>>>>> 753690898204 (SUNRPC: Ensure the bvecs are reset when we re-encode the RPC request)
  /*
   * Determine if the previous message in the stream was aborted before it
   * could complete transmission.
* Unmerged path net/sunrpc/clnt.c
* Unmerged path net/sunrpc/xprt.c
* Unmerged path net/sunrpc/xprtsock.c
