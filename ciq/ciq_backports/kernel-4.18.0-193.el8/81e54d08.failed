cfg80211: support FTM responder configuration/statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
commit 81e54d08d9d845053111f30045a93f3eb1c3ca96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/81e54d08.failed

Allow userspace to enable fine timing measurement responder
functionality with configurable lci/civic parameters in AP mode.
This can be done at AP start or changing beacon parameters.

A new EXT_FEATURE flag is introduced for drivers to advertise
the capability.

Also nl80211 API support for retrieving statistics is added.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
[remove unused cfg80211_ftm_responder_params, clarify docs,
 move validation into policy]
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 81e54d08d9d845053111f30045a93f3eb1c3ca96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/cfg80211.h
#	include/uapi/linux/nl80211.h
#	net/wireless/nl80211.c
#	net/wireless/rdev-ops.h
#	net/wireless/trace.h
diff --cc include/net/cfg80211.h
index f4b191144774,deb313105014..000000000000
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@@ -788,10 -777,8 +788,15 @@@ struct cfg80211_crypto_settings 
   * @probe_resp: probe response template (AP mode only)
   * @ftm_responder: enable FTM responder functionality; -1 for no change
   *	(which also implies no change in LCI/civic location data)
++<<<<<<< HEAD
 + * @lci: Measurement Report element content, starting with Measurement Token
 + *	(measurement type 8)
 + * @civicloc: Measurement Report element content, starting with Measurement
 + *	Token (measurement type 11)
++=======
+  * @lci: LCI subelement content
+  * @civicloc: Civic location subelement content
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
   * @lci_len: LCI data length
   * @civicloc_len: Civic location data length
   */
@@@ -2924,253 -2805,42 +2929,287 @@@ struct cfg80211_external_auth_params 
  	struct cfg80211_ssid ssid;
  	unsigned int key_mgmt_suite;
  	u16 status;
 +	const u8 *pmkid;
 +};
 +
 +/**
 + * struct cfg80211_ftm_responder_stats - FTM responder statistics
 + *
 + * @filled: bitflag of flags using the bits of &enum nl80211_ftm_stats to
 + *	indicate the relevant values in this struct for them
 + * @success_num: number of FTM sessions in which all frames were successfully
 + *	answered
 + * @partial_num: number of FTM sessions in which part of frames were
 + *	successfully answered
 + * @failed_num: number of failed FTM sessions
 + * @asap_num: number of ASAP FTM sessions
 + * @non_asap_num: number of  non-ASAP FTM sessions
 + * @total_duration_ms: total sessions durations - gives an indication
 + *	of how much time the responder was busy
 + * @unknown_triggers_num: number of unknown FTM triggers - triggers from
 + *	initiators that didn't finish successfully the negotiation phase with
 + *	the responder
 + * @reschedule_requests_num: number of FTM reschedule requests - initiator asks
 + *	for a new scheduling although it already has scheduled FTM slot
 + * @out_of_window_triggers_num: total FTM triggers out of scheduled window
 + */
 +struct cfg80211_ftm_responder_stats {
 +	u32 filled;
 +	u32 success_num;
 +	u32 partial_num;
 +	u32 failed_num;
 +	u32 asap_num;
 +	u32 non_asap_num;
 +	u64 total_duration_ms;
 +	u32 unknown_triggers_num;
 +	u32 reschedule_requests_num;
 +	u32 out_of_window_triggers_num;
 +};
 +
 +/**
 + * struct cfg80211_pmsr_ftm_result - FTM result
 + * @failure_reason: if this measurement failed (PMSR status is
 + *	%NL80211_PMSR_STATUS_FAILURE), this gives a more precise
 + *	reason than just "failure"
 + * @burst_index: if reporting partial results, this is the index
 + *	in [0 .. num_bursts-1] of the burst that's being reported
 + * @num_ftmr_attempts: number of FTM request frames transmitted
 + * @num_ftmr_successes: number of FTM request frames acked
 + * @busy_retry_time: if failure_reason is %NL80211_PMSR_FTM_FAILURE_PEER_BUSY,
 + *	fill this to indicate in how many seconds a retry is deemed possible
 + *	by the responder
 + * @num_bursts_exp: actual number of bursts exponent negotiated
 + * @burst_duration: actual burst duration negotiated
 + * @ftms_per_burst: actual FTMs per burst negotiated
 + * @lci_len: length of LCI information (if present)
 + * @civicloc_len: length of civic location information (if present)
 + * @lci: LCI data (may be %NULL)
 + * @civicloc: civic location data (may be %NULL)
 + * @rssi_avg: average RSSI over FTM action frames reported
 + * @rssi_spread: spread of the RSSI over FTM action frames reported
 + * @tx_rate: bitrate for transmitted FTM action frame response
 + * @rx_rate: bitrate of received FTM action frame
 + * @rtt_avg: average of RTTs measured (must have either this or @dist_avg)
 + * @rtt_variance: variance of RTTs measured (note that standard deviation is
 + *	the square root of the variance)
 + * @rtt_spread: spread of the RTTs measured
 + * @dist_avg: average of distances (mm) measured
 + *	(must have either this or @rtt_avg)
 + * @dist_variance: variance of distances measured (see also @rtt_variance)
 + * @dist_spread: spread of distances measured (see also @rtt_spread)
 + * @num_ftmr_attempts_valid: @num_ftmr_attempts is valid
 + * @num_ftmr_successes_valid: @num_ftmr_successes is valid
 + * @rssi_avg_valid: @rssi_avg is valid
 + * @rssi_spread_valid: @rssi_spread is valid
 + * @tx_rate_valid: @tx_rate is valid
 + * @rx_rate_valid: @rx_rate is valid
 + * @rtt_avg_valid: @rtt_avg is valid
 + * @rtt_variance_valid: @rtt_variance is valid
 + * @rtt_spread_valid: @rtt_spread is valid
 + * @dist_avg_valid: @dist_avg is valid
 + * @dist_variance_valid: @dist_variance is valid
 + * @dist_spread_valid: @dist_spread is valid
 + */
 +struct cfg80211_pmsr_ftm_result {
 +	const u8 *lci;
 +	const u8 *civicloc;
 +	unsigned int lci_len;
 +	unsigned int civicloc_len;
 +	enum nl80211_peer_measurement_ftm_failure_reasons failure_reason;
 +	u32 num_ftmr_attempts, num_ftmr_successes;
 +	s16 burst_index;
 +	u8 busy_retry_time;
 +	u8 num_bursts_exp;
 +	u8 burst_duration;
 +	u8 ftms_per_burst;
 +	s32 rssi_avg;
 +	s32 rssi_spread;
 +	struct rate_info tx_rate, rx_rate;
 +	s64 rtt_avg;
 +	s64 rtt_variance;
 +	s64 rtt_spread;
 +	s64 dist_avg;
 +	s64 dist_variance;
 +	s64 dist_spread;
 +
 +	u16 num_ftmr_attempts_valid:1,
 +	    num_ftmr_successes_valid:1,
 +	    rssi_avg_valid:1,
 +	    rssi_spread_valid:1,
 +	    tx_rate_valid:1,
 +	    rx_rate_valid:1,
 +	    rtt_avg_valid:1,
 +	    rtt_variance_valid:1,
 +	    rtt_spread_valid:1,
 +	    dist_avg_valid:1,
 +	    dist_variance_valid:1,
 +	    dist_spread_valid:1;
 +};
 +
 +/**
 + * struct cfg80211_pmsr_result - peer measurement result
 + * @addr: address of the peer
 + * @host_time: host time (use ktime_get_boottime() adjust to the time when the
 + *	measurement was made)
 + * @ap_tsf: AP's TSF at measurement time
 + * @status: status of the measurement
 + * @final: if reporting partial results, mark this as the last one; if not
 + *	reporting partial results always set this flag
 + * @ap_tsf_valid: indicates the @ap_tsf value is valid
 + * @type: type of the measurement reported, note that we only support reporting
 + *	one type at a time, but you can report multiple results separately and
 + *	they're all aggregated for userspace.
 + */
 +struct cfg80211_pmsr_result {
 +	u64 host_time, ap_tsf;
 +	enum nl80211_peer_measurement_status status;
 +
 +	u8 addr[ETH_ALEN];
 +
 +	u8 final:1,
 +	   ap_tsf_valid:1;
 +
 +	enum nl80211_peer_measurement_type type;
 +
 +	union {
 +		struct cfg80211_pmsr_ftm_result ftm;
 +	};
 +};
 +
 +/**
 + * struct cfg80211_pmsr_ftm_request_peer - FTM request data
 + * @requested: indicates FTM is requested
 + * @preamble: frame preamble to use
 + * @burst_period: burst period to use
 + * @asap: indicates to use ASAP mode
 + * @num_bursts_exp: number of bursts exponent
 + * @burst_duration: burst duration
 + * @ftms_per_burst: number of FTMs per burst
 + * @ftmr_retries: number of retries for FTM request
 + * @request_lci: request LCI information
 + * @request_civicloc: request civic location information
 + *
 + * See also nl80211 for the respective attribute documentation.
 + */
 +struct cfg80211_pmsr_ftm_request_peer {
 +	enum nl80211_preamble preamble;
 +	u16 burst_period;
 +	u8 requested:1,
 +	   asap:1,
 +	   request_lci:1,
 +	   request_civicloc:1;
 +	u8 num_bursts_exp;
 +	u8 burst_duration;
 +	u8 ftms_per_burst;
 +	u8 ftmr_retries;
 +};
 +
 +/**
 + * struct cfg80211_pmsr_request_peer - peer data for a peer measurement request
 + * @addr: MAC address
 + * @chandef: channel to use
 + * @report_ap_tsf: report the associated AP's TSF
 + * @ftm: FTM data, see &struct cfg80211_pmsr_ftm_request_peer
 + */
 +struct cfg80211_pmsr_request_peer {
 +	u8 addr[ETH_ALEN];
 +	struct cfg80211_chan_def chandef;
 +	u8 report_ap_tsf:1;
 +	struct cfg80211_pmsr_ftm_request_peer ftm;
 +};
 +
 +/**
 + * struct cfg80211_pmsr_request - peer measurement request
 + * @cookie: cookie, set by cfg80211
 + * @nl_portid: netlink portid - used by cfg80211
 + * @drv_data: driver data for this request, if required for aborting,
 + *	not otherwise freed or anything by cfg80211
 + * @mac_addr: MAC address used for (randomised) request
 + * @mac_addr_mask: MAC address mask used for randomisation, bits that
 + *	are 0 in the mask should be randomised, bits that are 1 should
 + *	be taken from the @mac_addr
 + * @list: used by cfg80211 to hold on to the request
 + * @timeout: timeout (in milliseconds) for the whole operation, if
 + *	zero it means there's no timeout
 + * @n_peers: number of peers to do measurements with
 + * @peers: per-peer measurement request data
 + */
 +struct cfg80211_pmsr_request {
 +	u64 cookie;
 +	void *drv_data;
 +	u32 n_peers;
 +	u32 nl_portid;
 +
 +	u32 timeout;
 +
 +	u8 mac_addr[ETH_ALEN] __aligned(2);
 +	u8 mac_addr_mask[ETH_ALEN] __aligned(2);
 +
 +	struct list_head list;
 +
 +	struct cfg80211_pmsr_request_peer peers[];
 +};
 +
 +/**
 + * struct cfg80211_update_owe_info - OWE Information
 + *
 + * This structure provides information needed for the drivers to offload OWE
 + * (Opportunistic Wireless Encryption) processing to the user space.
 + *
 + * Commonly used across update_owe_info request and event interfaces.
 + *
 + * @peer: MAC address of the peer device for which the OWE processing
 + *	has to be done.
 + * @status: status code, %WLAN_STATUS_SUCCESS for successful OWE info
 + *	processing, use %WLAN_STATUS_UNSPECIFIED_FAILURE if user space
 + *	cannot give you the real status code for failures. Used only for
 + *	OWE update request command interface (user space to driver).
 + * @ie: IEs obtained from the peer or constructed by the user space. These are
 + *	the IEs of the remote peer in the event from the host driver and
 + *	the constructed IEs by the user space in the request interface.
 + * @ie_len: Length of IEs in octets.
 + */
 +struct cfg80211_update_owe_info {
 +	u8 peer[ETH_ALEN] __aligned(2);
 +	u16 status;
 +	const u8 *ie;
 +	size_t ie_len;
  };
  
+ /**
+  * cfg80211_ftm_responder_stats - FTM responder statistics
+  *
+  * @filled: bitflag of flags using the bits of &enum nl80211_ftm_stats to
+  *	indicate the relevant values in this struct for them
+  * @success_num: number of FTM sessions in which all frames were successfully
+  *	answered
+  * @partial_num: number of FTM sessions in which part of frames were
+  *	successfully answered
+  * @failed_num: number of failed FTM sessions
+  * @asap_num: number of ASAP FTM sessions
+  * @non_asap_num: number of  non-ASAP FTM sessions
+  * @total_duration_ms: total sessions durations - gives an indication
+  *	of how much time the responder was busy
+  * @unknown_triggers_num: number of unknown FTM triggers - triggers from
+  *	initiators that didn't finish successfully the negotiation phase with
+  *	the responder
+  * @reschedule_requests_num: number of FTM reschedule requests - initiator asks
+  *	for a new scheduling although it already has scheduled FTM slot
+  * @out_of_window_triggers_num: total FTM triggers out of scheduled window
+  */
+ struct cfg80211_ftm_responder_stats {
+ 	u32 filled;
+ 	u32 success_num;
+ 	u32 partial_num;
+ 	u32 failed_num;
+ 	u32 asap_num;
+ 	u32 non_asap_num;
+ 	u64 total_duration_ms;
+ 	u32 unknown_triggers_num;
+ 	u32 reschedule_requests_num;
+ 	u32 out_of_window_triggers_num;
+ };
+ 
  /**
   * struct cfg80211_ops - backend description for wireless configuration
   *
@@@ -3506,15 -3176,6 +3545,18 @@@
   *
   * @get_ftm_responder_stats: Retrieve FTM responder statistics, if available.
   *	Statistics should be cumulative, currently no way to reset is provided.
++<<<<<<< HEAD
 + * @start_pmsr: start peer measurement (e.g. FTM)
 + * @abort_pmsr: abort peer measurement
 + *
 + * @update_owe_info: Provide updated OWE info to driver. Driver implementing SME
 + *	but offloading OWE processing to the user space will get the updated
 + *	DH IE through this interface.
 + *
 + * @probe_mesh_link: Probe direct Mesh peer's link quality by sending data frame
 + *	and overrule HWMP path selection algorithm.
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
   */
  struct cfg80211_ops {
  	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
@@@ -3824,15 -3485,6 +3866,18 @@@
  	int	(*get_ftm_responder_stats)(struct wiphy *wiphy,
  				struct net_device *dev,
  				struct cfg80211_ftm_responder_stats *ftm_stats);
++<<<<<<< HEAD
 +
 +	int	(*start_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,
 +			      struct cfg80211_pmsr_request *request);
 +	void	(*abort_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev,
 +			      struct cfg80211_pmsr_request *request);
 +	int	(*update_owe_info)(struct wiphy *wiphy, struct net_device *dev,
 +				   struct cfg80211_update_owe_info *owe_info);
 +	int	(*probe_mesh_link)(struct wiphy *wiphy, struct net_device *dev,
 +				   const u8 *buf, size_t len);
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  };
  
  /*
diff --cc include/uapi/linux/nl80211.h
index ce2530138aa4,dc6d5a1ef470..000000000000
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@@ -1036,55 -1036,6 +1036,58 @@@
   * @NL80211_CMD_GET_FTM_RESPONDER_STATS: Retrieve FTM responder statistics, in
   *	the %NL80211_ATTR_FTM_RESPONDER_STATS attribute.
   *
++<<<<<<< HEAD
 + * @NL80211_CMD_PEER_MEASUREMENT_START: start a (set of) peer measurement(s)
 + *	with the given parameters, which are encapsulated in the nested
 + *	%NL80211_ATTR_PEER_MEASUREMENTS attribute. Optionally, MAC address
 + *	randomization may be enabled and configured by specifying the
 + *	%NL80211_ATTR_MAC and %NL80211_ATTR_MAC_MASK attributes.
 + *	If a timeout is requested, use the %NL80211_ATTR_TIMEOUT attribute.
 + *	A u64 cookie for further %NL80211_ATTR_COOKIE use is is returned in
 + *	the netlink extended ack message.
 + *
 + *	To cancel a measurement, close the socket that requested it.
 + *
 + *	Measurement results are reported to the socket that requested the
 + *	measurement using @NL80211_CMD_PEER_MEASUREMENT_RESULT when they
 + *	become available, so applications must ensure a large enough socket
 + *	buffer size.
 + *
 + *	Depending on driver support it may or may not be possible to start
 + *	multiple concurrent measurements.
 + * @NL80211_CMD_PEER_MEASUREMENT_RESULT: This command number is used for the
 + *	result notification from the driver to the requesting socket.
 + * @NL80211_CMD_PEER_MEASUREMENT_COMPLETE: Notification only, indicating that
 + *	the measurement completed, using the measurement cookie
 + *	(%NL80211_ATTR_COOKIE).
 + *
 + * @NL80211_CMD_NOTIFY_RADAR: Notify the kernel that a radar signal was
 + *	detected and reported by a neighboring device on the channel
 + *	indicated by %NL80211_ATTR_WIPHY_FREQ and other attributes
 + *	determining the width and type.
 + *
 + * @NL80211_CMD_UPDATE_OWE_INFO: This interface allows the host driver to
 + *	offload OWE processing to user space. This intends to support
 + *	OWE AKM by the host drivers that implement SME but rely
 + *	on the user space for the cryptographic/DH IE processing in AP mode.
 + *
 + * @NL80211_CMD_PROBE_MESH_LINK: The requirement for mesh link metric
 + *	refreshing, is that from one mesh point we be able to send some data
 + *	frames to other mesh points which are not currently selected as a
 + *	primary traffic path, but which are only 1 hop away. The absence of
 + *	the primary path to the chosen node makes it necessary to apply some
 + *	form of marking on a chosen packet stream so that the packets can be
 + *	properly steered to the selected node for testing, and not by the
 + *	regular mesh path lookup. Further, the packets must be of type data
 + *	so that the rate control (often embedded in firmware) is used for
 + *	rate selection.
 + *
 + *	Here attribute %NL80211_ATTR_MAC is used to specify connected mesh
 + *	peer MAC address and %NL80211_ATTR_FRAME is used to specify the frame
 + *	content. The frame is ethernet data.
 + *
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
   * @NL80211_CMD_MAX: highest used command number
   * @__NL80211_CMD_AFTER_LAST: internal use
   */
@@@ -1299,16 -1250,6 +1302,19 @@@ enum nl80211_commands 
  
  	NL80211_CMD_GET_FTM_RESPONDER_STATS,
  
++<<<<<<< HEAD
 +	NL80211_CMD_PEER_MEASUREMENT_START,
 +	NL80211_CMD_PEER_MEASUREMENT_RESULT,
 +	NL80211_CMD_PEER_MEASUREMENT_COMPLETE,
 +
 +	NL80211_CMD_NOTIFY_RADAR,
 +
 +	NL80211_CMD_UPDATE_OWE_INFO,
 +
 +	NL80211_CMD_PROBE_MESH_LINK,
 +
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  	/* add new commands above here */
  
  	/* used to define NL80211_CMD_MAX below */
@@@ -2319,28 -2254,6 +2325,31 @@@
   * @NL80211_ATTR_FTM_RESPONDER_STATS: Nested attribute with FTM responder
   *	statistics, see &enum nl80211_ftm_responder_stats.
   *
++<<<<<<< HEAD
 + * @NL80211_ATTR_TIMEOUT: Timeout for the given operation in milliseconds (u32),
 + *	if the attribute is not given no timeout is requested. Note that 0 is an
 + *	invalid value.
 + *
 + * @NL80211_ATTR_PEER_MEASUREMENTS: peer measurements request (and result)
 + *	data, uses nested attributes specified in
 + *	&enum nl80211_peer_measurement_attrs.
 + *	This is also used for capability advertisement in the wiphy information,
 + *	with the appropriate sub-attributes.
 + *
 + * @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime
 + *	scheduler.
 + *
 + * @NL80211_ATTR_STA_TX_POWER_SETTING: Transmit power setting type (u8) for
 + *	station associated with the AP. See &enum nl80211_tx_power_setting for
 + *	possible values.
 + * @NL80211_ATTR_STA_TX_POWER: Transmit power level (s16) in dBm units. This
 + *	allows to set Tx power for a station. If this attribute is not included,
 + *	the default per-interface tx power setting will be overriding. Driver
 + *	should be picking up the lowest tx power, either tx power per-interface
 + *	or per-station.
 + *
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
   * @NUM_NL80211_ATTR: total number of nl80211_attrs available
   * @NL80211_ATTR_MAX: highest attribute number currently defined
   * @__NL80211_ATTR_AFTER_LAST: internal use
@@@ -2786,14 -2699,6 +2795,17 @@@ enum nl80211_attrs 
  
  	NL80211_ATTR_FTM_RESPONDER_STATS,
  
++<<<<<<< HEAD
 +	NL80211_ATTR_TIMEOUT,
 +
 +	NL80211_ATTR_PEER_MEASUREMENTS,
 +
 +	NL80211_ATTR_AIRTIME_WEIGHT,
 +	NL80211_ATTR_STA_TX_POWER_SETTING,
 +	NL80211_ATTR_STA_TX_POWER,
 +
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  	/* add attributes here, update the policy in nl80211.c */
  
  	__NL80211_ATTR_AFTER_LAST,
@@@ -5440,10 -5289,6 +5452,13 @@@ enum nl80211_ext_feature_index 
  	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT,
  	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0,
  	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER,
++<<<<<<< HEAD
 +	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS,
 +	NL80211_EXT_FEATURE_AP_PMKSA_CACHING,
 +	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD,
 +	NL80211_EXT_FEATURE_STA_TX_PWR,
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  
  	/* add new features before the definition below */
  	NUM_NL80211_EXT_FEATURES,
@@@ -5994,11 -5834,9 +6009,17 @@@ enum nl80211_external_auth_action 
   * @__NL80211_FTM_RESP_ATTR_INVALID: Invalid
   * @NL80211_FTM_RESP_ATTR_ENABLED: FTM responder is enabled
   * @NL80211_FTM_RESP_ATTR_LCI: The content of Measurement Report Element
++<<<<<<< HEAD
 + *	(9.4.2.22 in 802.11-2016) with type 8 - LCI (9.4.2.22.10),
 + *	i.e. starting with the measurement token
 + * @NL80211_FTM_RESP_ATTR_CIVIC: The content of Measurement Report Element
 + *	(9.4.2.22 in 802.11-2016) with type 11 - Civic (Section 9.4.2.22.13),
 + *	i.e. starting with the measurement token
++=======
+  *	(9.4.2.22 in 802.11-2016) with type 8 - LCI (9.4.2.22.10)
+  * @NL80211_FTM_RESP_ATTR_CIVIC: The content of Measurement Report Element
+  *	(9.4.2.22 in 802.11-2016) with type 11 - Civic (Section 9.4.2.22.13)
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
   * @__NL80211_FTM_RESP_ATTR_LAST: Internal
   * @NL80211_FTM_RESP_ATTR_MAX: highest FTM responder attribute.
   */
@@@ -6060,386 -5898,4 +6081,389 @@@ enum nl80211_ftm_responder_stats 
  	NL80211_FTM_STATS_MAX = __NL80211_FTM_STATS_AFTER_LAST - 1
  };
  
++<<<<<<< HEAD
 +/**
 + * enum nl80211_preamble - frame preamble types
 + * @NL80211_PREAMBLE_LEGACY: legacy (HR/DSSS, OFDM, ERP PHY) preamble
 + * @NL80211_PREAMBLE_HT: HT preamble
 + * @NL80211_PREAMBLE_VHT: VHT preamble
 + * @NL80211_PREAMBLE_DMG: DMG preamble
 + */
 +enum nl80211_preamble {
 +	NL80211_PREAMBLE_LEGACY,
 +	NL80211_PREAMBLE_HT,
 +	NL80211_PREAMBLE_VHT,
 +	NL80211_PREAMBLE_DMG,
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_type - peer measurement types
 + * @NL80211_PMSR_TYPE_INVALID: invalid/unused, needed as we use
 + *	these numbers also for attributes
 + *
 + * @NL80211_PMSR_TYPE_FTM: flight time measurement
 + *
 + * @NUM_NL80211_PMSR_TYPES: internal
 + * @NL80211_PMSR_TYPE_MAX: highest type number
 + */
 +enum nl80211_peer_measurement_type {
 +	NL80211_PMSR_TYPE_INVALID,
 +
 +	NL80211_PMSR_TYPE_FTM,
 +
 +	NUM_NL80211_PMSR_TYPES,
 +	NL80211_PMSR_TYPE_MAX = NUM_NL80211_PMSR_TYPES - 1
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_status - peer measurement status
 + * @NL80211_PMSR_STATUS_SUCCESS: measurement completed successfully
 + * @NL80211_PMSR_STATUS_REFUSED: measurement was locally refused
 + * @NL80211_PMSR_STATUS_TIMEOUT: measurement timed out
 + * @NL80211_PMSR_STATUS_FAILURE: measurement failed, a type-dependent
 + *	reason may be available in the response data
 + */
 +enum nl80211_peer_measurement_status {
 +	NL80211_PMSR_STATUS_SUCCESS,
 +	NL80211_PMSR_STATUS_REFUSED,
 +	NL80211_PMSR_STATUS_TIMEOUT,
 +	NL80211_PMSR_STATUS_FAILURE,
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_req - peer measurement request attributes
 + * @__NL80211_PMSR_REQ_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_REQ_ATTR_DATA: This is a nested attribute with measurement
 + *	type-specific request data inside. The attributes used are from the
 + *	enums named nl80211_peer_measurement_<type>_req.
 + * @NL80211_PMSR_REQ_ATTR_GET_AP_TSF: include AP TSF timestamp, if supported
 + *	(flag attribute)
 + *
 + * @NUM_NL80211_PMSR_REQ_ATTRS: internal
 + * @NL80211_PMSR_REQ_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_req {
 +	__NL80211_PMSR_REQ_ATTR_INVALID,
 +
 +	NL80211_PMSR_REQ_ATTR_DATA,
 +	NL80211_PMSR_REQ_ATTR_GET_AP_TSF,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_REQ_ATTRS,
 +	NL80211_PMSR_REQ_ATTR_MAX = NUM_NL80211_PMSR_REQ_ATTRS - 1
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_resp - peer measurement response attributes
 + * @__NL80211_PMSR_RESP_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_RESP_ATTR_DATA: This is a nested attribute with measurement
 + *	type-specific results inside. The attributes used are from the enums
 + *	named nl80211_peer_measurement_<type>_resp.
 + * @NL80211_PMSR_RESP_ATTR_STATUS: u32 value with the measurement status
 + *	(using values from &enum nl80211_peer_measurement_status.)
 + * @NL80211_PMSR_RESP_ATTR_HOST_TIME: host time (%CLOCK_BOOTTIME) when the
 + *	result was measured; this value is not expected to be accurate to
 + *	more than 20ms. (u64, nanoseconds)
 + * @NL80211_PMSR_RESP_ATTR_AP_TSF: TSF of the AP that the interface
 + *	doing the measurement is connected to when the result was measured.
 + *	This shall be accurately reported if supported and requested
 + *	(u64, usec)
 + * @NL80211_PMSR_RESP_ATTR_FINAL: If results are sent to the host partially
 + *	(*e.g. with FTM per-burst data) this flag will be cleared on all but
 + *	the last result; if all results are combined it's set on the single
 + *	result.
 + * @NL80211_PMSR_RESP_ATTR_PAD: padding for 64-bit attributes, ignore
 + *
 + * @NUM_NL80211_PMSR_RESP_ATTRS: internal
 + * @NL80211_PMSR_RESP_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_resp {
 +	__NL80211_PMSR_RESP_ATTR_INVALID,
 +
 +	NL80211_PMSR_RESP_ATTR_DATA,
 +	NL80211_PMSR_RESP_ATTR_STATUS,
 +	NL80211_PMSR_RESP_ATTR_HOST_TIME,
 +	NL80211_PMSR_RESP_ATTR_AP_TSF,
 +	NL80211_PMSR_RESP_ATTR_FINAL,
 +	NL80211_PMSR_RESP_ATTR_PAD,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_RESP_ATTRS,
 +	NL80211_PMSR_RESP_ATTR_MAX = NUM_NL80211_PMSR_RESP_ATTRS - 1
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_peer_attrs - peer attributes for measurement
 + * @__NL80211_PMSR_PEER_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_PEER_ATTR_ADDR: peer's MAC address
 + * @NL80211_PMSR_PEER_ATTR_CHAN: channel definition, nested, using top-level
 + *	attributes like %NL80211_ATTR_WIPHY_FREQ etc.
 + * @NL80211_PMSR_PEER_ATTR_REQ: This is a nested attribute indexed by
 + *	measurement type, with attributes from the
 + *	&enum nl80211_peer_measurement_req inside.
 + * @NL80211_PMSR_PEER_ATTR_RESP: This is a nested attribute indexed by
 + *	measurement type, with attributes from the
 + *	&enum nl80211_peer_measurement_resp inside.
 + *
 + * @NUM_NL80211_PMSR_PEER_ATTRS: internal
 + * @NL80211_PMSR_PEER_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_peer_attrs {
 +	__NL80211_PMSR_PEER_ATTR_INVALID,
 +
 +	NL80211_PMSR_PEER_ATTR_ADDR,
 +	NL80211_PMSR_PEER_ATTR_CHAN,
 +	NL80211_PMSR_PEER_ATTR_REQ,
 +	NL80211_PMSR_PEER_ATTR_RESP,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_PEER_ATTRS,
 +	NL80211_PMSR_PEER_ATTR_MAX = NUM_NL80211_PMSR_PEER_ATTRS - 1,
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_attrs - peer measurement attributes
 + * @__NL80211_PMSR_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_ATTR_MAX_PEERS: u32 attribute used for capability
 + *	advertisement only, indicates the maximum number of peers
 + *	measurements can be done with in a single request
 + * @NL80211_PMSR_ATTR_REPORT_AP_TSF: flag attribute in capability
 + *	indicating that the connected AP's TSF can be reported in
 + *	measurement results
 + * @NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR: flag attribute in capability
 + *	indicating that MAC address randomization is supported.
 + * @NL80211_PMSR_ATTR_TYPE_CAPA: capabilities reported by the device,
 + *	this contains a nesting indexed by measurement type, and
 + *	type-specific capabilities inside, which are from the enums
 + *	named nl80211_peer_measurement_<type>_capa.
 + * @NL80211_PMSR_ATTR_PEERS: nested attribute, the nesting index is
 + *	meaningless, just a list of peers to measure with, with the
 + *	sub-attributes taken from
 + *	&enum nl80211_peer_measurement_peer_attrs.
 + *
 + * @NUM_NL80211_PMSR_ATTR: internal
 + * @NL80211_PMSR_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_attrs {
 +	__NL80211_PMSR_ATTR_INVALID,
 +
 +	NL80211_PMSR_ATTR_MAX_PEERS,
 +	NL80211_PMSR_ATTR_REPORT_AP_TSF,
 +	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR,
 +	NL80211_PMSR_ATTR_TYPE_CAPA,
 +	NL80211_PMSR_ATTR_PEERS,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_ATTR,
 +	NL80211_PMSR_ATTR_MAX = NUM_NL80211_PMSR_ATTR - 1
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_ftm_capa - FTM capabilities
 + * @__NL80211_PMSR_FTM_CAPA_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_FTM_CAPA_ATTR_ASAP: flag attribute indicating ASAP mode
 + *	is supported
 + * @NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP: flag attribute indicating non-ASAP
 + *	mode is supported
 + * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI: flag attribute indicating if LCI
 + *	data can be requested during the measurement
 + * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC: flag attribute indicating if civic
 + *	location data can be requested during the measurement
 + * @NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES: u32 bitmap attribute of bits
 + *	from &enum nl80211_preamble.
 + * @NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS: bitmap of values from
 + *	&enum nl80211_chan_width indicating the supported channel
 + *	bandwidths for FTM. Note that a higher channel bandwidth may be
 + *	configured to allow for other measurements types with different
 + *	bandwidth requirement in the same measurement.
 + * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT: u32 attribute indicating
 + *	the maximum bursts exponent that can be used (if not present anything
 + *	is valid)
 + * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST: u32 attribute indicating
 + *	the maximum FTMs per burst (if not present anything is valid)
 + *
 + * @NUM_NL80211_PMSR_FTM_CAPA_ATTR: internal
 + * @NL80211_PMSR_FTM_CAPA_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_ftm_capa {
 +	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID,
 +
 +	NL80211_PMSR_FTM_CAPA_ATTR_ASAP,
 +	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP,
 +	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI,
 +	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC,
 +	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,
 +	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,
 +	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,
 +	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_FTM_CAPA_ATTR,
 +	NL80211_PMSR_FTM_CAPA_ATTR_MAX = NUM_NL80211_PMSR_FTM_CAPA_ATTR - 1
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_ftm_req - FTM request attributes
 + * @__NL80211_PMSR_FTM_REQ_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_FTM_REQ_ATTR_ASAP: ASAP mode requested (flag)
 + * @NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE: preamble type (see
 + *	&enum nl80211_preamble), optional for DMG (u32)
 + * @NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP: number of bursts exponent as in
 + *	802.11-2016 9.4.2.168 "Fine Timing Measurement Parameters element"
 + *	(u8, 0-15, optional with default 15 i.e. "no preference")
 + * @NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD: interval between bursts in units
 + *	of 100ms (u16, optional with default 0)
 + * @NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION: burst duration, as in 802.11-2016
 + *	Table 9-257 "Burst Duration field encoding" (u8, 0-15, optional with
 + *	default 15 i.e. "no preference")
 + * @NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST: number of successful FTM frames
 + *	requested per burst
 + *	(u8, 0-31, optional with default 0 i.e. "no preference")
 + * @NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES: number of FTMR frame retries
 + *	(u8, default 3)
 + * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI: request LCI data (flag)
 + * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC: request civic location data
 + *	(flag)
 + *
 + * @NUM_NL80211_PMSR_FTM_REQ_ATTR: internal
 + * @NL80211_PMSR_FTM_REQ_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_ftm_req {
 +	__NL80211_PMSR_FTM_REQ_ATTR_INVALID,
 +
 +	NL80211_PMSR_FTM_REQ_ATTR_ASAP,
 +	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE,
 +	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP,
 +	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD,
 +	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION,
 +	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST,
 +	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES,
 +	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI,
 +	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_FTM_REQ_ATTR,
 +	NL80211_PMSR_FTM_REQ_ATTR_MAX = NUM_NL80211_PMSR_FTM_REQ_ATTR - 1
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_ftm_failure_reasons - FTM failure reasons
 + * @NL80211_PMSR_FTM_FAILURE_UNSPECIFIED: unspecified failure, not used
 + * @NL80211_PMSR_FTM_FAILURE_NO_RESPONSE: no response from the FTM responder
 + * @NL80211_PMSR_FTM_FAILURE_REJECTED: FTM responder rejected measurement
 + * @NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL: we already know the peer is
 + *	on a different channel, so can't measure (if we didn't know, we'd
 + *	try and get no response)
 + * @NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE: peer can't actually do FTM
 + * @NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP: invalid T1/T4 timestamps
 + *	received
 + * @NL80211_PMSR_FTM_FAILURE_PEER_BUSY: peer reports busy, you may retry
 + *	later (see %NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME)
 + * @NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS: parameters were changed
 + *	by the peer and are no longer supported
 + */
 +enum nl80211_peer_measurement_ftm_failure_reasons {
 +	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED,
 +	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE,
 +	NL80211_PMSR_FTM_FAILURE_REJECTED,
 +	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL,
 +	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE,
 +	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP,
 +	NL80211_PMSR_FTM_FAILURE_PEER_BUSY,
 +	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS,
 +};
 +
 +/**
 + * enum nl80211_peer_measurement_ftm_resp - FTM response attributes
 + * @__NL80211_PMSR_FTM_RESP_ATTR_INVALID: invalid
 + *
 + * @NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON: FTM-specific failure reason
 + *	(u32, optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX: optional, if bursts are reported
 + *	as separate results then it will be the burst index 0...(N-1) and
 + *	the top level will indicate partial results (u32)
 + * @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS: number of FTM Request frames
 + *	transmitted (u32, optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES: number of FTM Request frames
 + *	that were acknowleged (u32, optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME: retry time received from the
 + *	busy peer (u32, seconds)
 + * @NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP: actual number of bursts exponent
 + *	used by the responder (similar to request, u8)
 + * @NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION: actual burst duration used by
 + *	the responder (similar to request, u8)
 + * @NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST: actual FTMs per burst used
 + *	by the responder (similar to request, u8)
 + * @NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG: average RSSI across all FTM action
 + *	frames (optional, s32, 1/2 dBm)
 + * @NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD: RSSI spread across all FTM action
 + *	frames (optional, s32, 1/2 dBm)
 + * @NL80211_PMSR_FTM_RESP_ATTR_TX_RATE: bitrate we used for the response to the
 + *	FTM action frame (optional, nested, using &enum nl80211_rate_info
 + *	attributes)
 + * @NL80211_PMSR_FTM_RESP_ATTR_RX_RATE: bitrate the responder used for the FTM
 + *	action frame (optional, nested, using &enum nl80211_rate_info attrs)
 + * @NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG: average RTT (s64, picoseconds, optional
 + *	but one of RTT/DIST must be present)
 + * @NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE: RTT variance (u64, ps^2, note that
 + *	standard deviation is the square root of variance, optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD: RTT spread (u64, picoseconds,
 + *	optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG: average distance (s64, mm, optional
 + *	but one of RTT/DIST must be present)
 + * @NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE: distance variance (u64, mm^2, note
 + *	that standard deviation is the square root of variance, optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD: distance spread (u64, mm, optional)
 + * @NL80211_PMSR_FTM_RESP_ATTR_LCI: LCI data from peer (binary, optional);
 + *	this is the contents of the Measurement Report Element (802.11-2016
 + *	9.4.2.22.1) starting with the Measurement Token, with Measurement
 + *	Type 8.
 + * @NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC: civic location data from peer
 + *	(binary, optional);
 + *	this is the contents of the Measurement Report Element (802.11-2016
 + *	9.4.2.22.1) starting with the Measurement Token, with Measurement
 + *	Type 11.
 + * @NL80211_PMSR_FTM_RESP_ATTR_PAD: ignore, for u64/s64 padding only
 + *
 + * @NUM_NL80211_PMSR_FTM_RESP_ATTR: internal
 + * @NL80211_PMSR_FTM_RESP_ATTR_MAX: highest attribute number
 + */
 +enum nl80211_peer_measurement_ftm_resp {
 +	__NL80211_PMSR_FTM_RESP_ATTR_INVALID,
 +
 +	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON,
 +	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX,
 +	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS,
 +	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES,
 +	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME,
 +	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP,
 +	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION,
 +	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST,
 +	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG,
 +	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD,
 +	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE,
 +	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE,
 +	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG,
 +	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE,
 +	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD,
 +	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG,
 +	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE,
 +	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD,
 +	NL80211_PMSR_FTM_RESP_ATTR_LCI,
 +	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC,
 +	NL80211_PMSR_FTM_RESP_ATTR_PAD,
 +
 +	/* keep last */
 +	NUM_NL80211_PMSR_FTM_RESP_ATTR,
 +	NL80211_PMSR_FTM_RESP_ATTR_MAX = NUM_NL80211_PMSR_FTM_RESP_ATTR - 1
 +};
 +
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  #endif /* __LINUX_NL80211_H */
diff --cc net/wireless/nl80211.c
index 4e1c052bca2e,235a43185e8d..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -206,8 -201,6 +206,11 @@@ cfg80211_get_dev_from_info(struct net *
  }
  
  /* policy for the attributes */
++<<<<<<< HEAD
 +
 +#if 0 /* Not in RHEL */
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  static const struct nla_policy
  nl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {
  	[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },
@@@ -217,61 -210,7 +220,65 @@@
  					     .len = U8_MAX },
  };
  
++<<<<<<< HEAD
 +static const struct nla_policy
 +nl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {
 +	[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },
 +	[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },
 +	[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =
 +		NLA_POLICY_MAX(NLA_U8, 15),
 +	[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },
 +	[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =
 +		NLA_POLICY_MAX(NLA_U8, 15),
 +	[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =
 +		NLA_POLICY_MAX(NLA_U8, 31),
 +	[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },
 +	[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },
 +	[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },
 +};
 +
 +static const struct nla_policy
 +nl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {
 +	[NL80211_PMSR_TYPE_FTM] =
 +		NLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),
 +};
 +
 +static const struct nla_policy
 +nl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {
 +	[NL80211_PMSR_REQ_ATTR_DATA] =
 +		NLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),
 +	[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },
 +};
 +
 +static const struct nla_policy
 +nl80211_psmr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {
 +	[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,
 +	/*
 +	 * we could specify this again to be the top-level policy,
 +	 * but that would open us up to recursion problems ...
 +	 */
 +	[NL80211_PMSR_PEER_ATTR_CHAN] = { .type = NLA_NESTED },
 +	[NL80211_PMSR_PEER_ATTR_REQ] =
 +		NLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),
 +	[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },
 +};
 +
 +static const struct nla_policy
 +nl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {
 +	[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },
 +	[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },
 +	[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },
 +	[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },
 +	[NL80211_PMSR_ATTR_PEERS] =
 +		NLA_POLICY_NESTED_ARRAY(nl80211_psmr_peer_attr_policy),
 +};
 +#endif /* Not in RHEL */
 +
 +const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 +	[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },
++=======
+ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  	[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },
  	[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,
  				      .len = 20-1 },
@@@ -502,16 -439,11 +509,23 @@@
  	[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },
  	[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,
  					 .len = NL80211_HE_MAX_CAPABILITY_LEN },
++<<<<<<< HEAD
 +#if 0 /* Not in RHEL */
++=======
+ 
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  	[NL80211_ATTR_FTM_RESPONDER] = {
  		.type = NLA_NESTED,
  		.validation_data = nl80211_ftm_responder_policy,
  	},
++<<<<<<< HEAD
 +	[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),
 +	[NL80211_ATTR_PEER_MEASUREMENTS] =
 +		NLA_POLICY_NESTED(nl80211_pmsr_attr_policy),
 +	[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),
 +#endif /* Not in RHEL */
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  };
  
  /* policy for the key attributes */
@@@ -4305,10 -4062,9 +4319,16 @@@ static int nl80211_parse_beacon(struct 
  	if (attrs[NL80211_ATTR_FTM_RESPONDER]) {
  		struct nlattr *tb[NL80211_FTM_RESP_ATTR_MAX + 1];
  
++<<<<<<< HEAD
 +		err = nla_parse_nested_deprecated(tb,
 +						  NL80211_FTM_RESP_ATTR_MAX,
 +						  attrs[NL80211_ATTR_FTM_RESPONDER],
 +						  NULL, NULL);
++=======
+ 		err = nla_parse_nested(tb, NL80211_FTM_RESP_ATTR_MAX,
+ 				       attrs[NL80211_ATTR_FTM_RESPONDER],
+ 				       NULL, NULL);
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  		if (err)
  			return err;
  
@@@ -13550,8 -13063,7 +13570,12 @@@ static int nl80211_get_ftm_responder_st
  	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	ftm_stats_attr = nla_nest_start_noflag(msg,
 +					       NL80211_ATTR_FTM_RESPONDER_STATS);
++=======
+ 	ftm_stats_attr = nla_nest_start(msg, NL80211_ATTR_FTM_RESPONDER_STATS);
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  	if (!ftm_stats_attr)
  		goto nla_put_failure;
  
@@@ -13587,72 -13099,6 +13611,75 @@@ nla_put_failure
  	return -ENOBUFS;
  }
  
++<<<<<<< HEAD
 +static int nl80211_update_owe_info(struct sk_buff *skb, struct genl_info *info)
 +{
 +	struct cfg80211_registered_device *rdev = info->user_ptr[0];
 +	struct cfg80211_update_owe_info owe_info;
 +	struct net_device *dev = info->user_ptr[1];
 +
 +	if (!rdev->ops->update_owe_info)
 +		return -EOPNOTSUPP;
 +
 +	if (!info->attrs[NL80211_ATTR_STATUS_CODE] ||
 +	    !info->attrs[NL80211_ATTR_MAC])
 +		return -EINVAL;
 +
 +	memset(&owe_info, 0, sizeof(owe_info));
 +	owe_info.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);
 +	nla_memcpy(owe_info.peer, info->attrs[NL80211_ATTR_MAC], ETH_ALEN);
 +
 +	if (info->attrs[NL80211_ATTR_IE]) {
 +		owe_info.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
 +		owe_info.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
 +	}
 +
 +	return rdev_update_owe_info(rdev, dev, &owe_info);
 +}
 +
 +static int nl80211_probe_mesh_link(struct sk_buff *skb, struct genl_info *info)
 +{
 +	struct cfg80211_registered_device *rdev = info->user_ptr[0];
 +	struct net_device *dev = info->user_ptr[1];
 +	struct wireless_dev *wdev = dev->ieee80211_ptr;
 +	struct station_info sinfo = {};
 +	const u8 *buf;
 +	size_t len;
 +	u8 *dest;
 +	int err;
 +
 +	if (!rdev->ops->probe_mesh_link || !rdev->ops->get_station)
 +		return -EOPNOTSUPP;
 +
 +	if (!info->attrs[NL80211_ATTR_MAC] ||
 +	    !info->attrs[NL80211_ATTR_FRAME]) {
 +		GENL_SET_ERR_MSG(info, "Frame or MAC missing");
 +		return -EINVAL;
 +	}
 +
 +	if (wdev->iftype != NL80211_IFTYPE_MESH_POINT)
 +		return -EOPNOTSUPP;
 +
 +	dest = nla_data(info->attrs[NL80211_ATTR_MAC]);
 +	buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);
 +	len = nla_len(info->attrs[NL80211_ATTR_FRAME]);
 +
 +	if (len < sizeof(struct ethhdr))
 +		return -EINVAL;
 +
 +	if (!ether_addr_equal(buf, dest) || is_multicast_ether_addr(buf) ||
 +	    !ether_addr_equal(buf + ETH_ALEN, dev->dev_addr))
 +		return -EINVAL;
 +
 +	err = rdev_get_station(rdev, dev, dest, &sinfo);
 +	if (err)
 +		return err;
 +
 +	return rdev_probe_mesh_link(rdev, dev, dest, buf, len);
 +}
 +
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  #define NL80211_FLAG_NEED_WIPHY		0x01
  #define NL80211_FLAG_NEED_NETDEV	0x02
  #define NL80211_FLAG_NEED_RTNL		0x04
@@@ -14577,36 -14017,6 +14604,39 @@@ static const struct genl_ops nl80211_op
  		.internal_flags = NL80211_FLAG_NEED_NETDEV |
  				  NL80211_FLAG_NEED_RTNL,
  	},
++<<<<<<< HEAD
 +	{
 +		.cmd = NL80211_CMD_PEER_MEASUREMENT_START,
 +		.doit = nl80211_pmsr_start,
 +		.policy = nl80211_policy,
 +		.flags = GENL_UNS_ADMIN_PERM,
 +		.internal_flags = NL80211_FLAG_NEED_WDEV_UP |
 +				  NL80211_FLAG_NEED_RTNL,
 +	},
 +	{
 +		.cmd = NL80211_CMD_NOTIFY_RADAR,
 +		.doit = nl80211_notify_radar_detection,
 +		.policy = nl80211_policy,
 +		.flags = GENL_UNS_ADMIN_PERM,
 +		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 +				  NL80211_FLAG_NEED_RTNL,
 +	},
 +	{
 +		.cmd = NL80211_CMD_UPDATE_OWE_INFO,
 +		.doit = nl80211_update_owe_info,
 +		.flags = GENL_ADMIN_PERM,
 +		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 +				  NL80211_FLAG_NEED_RTNL,
 +	},
 +	{
 +		.cmd = NL80211_CMD_PROBE_MESH_LINK,
 +		.doit = nl80211_probe_mesh_link,
 +		.flags = GENL_UNS_ADMIN_PERM,
 +		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 +				  NL80211_FLAG_NEED_RTNL,
 +	},
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  };
  
  static struct genl_family nl80211_fam __ro_after_init = {
diff --cc net/wireless/rdev-ops.h
index 71c2d31937ec,51380b5c32f2..000000000000
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@@ -1247,55 -1247,4 +1247,58 @@@ rdev_get_ftm_responder_stats(struct cfg
  	return ret;
  }
  
++<<<<<<< HEAD
 +static inline int
 +rdev_start_pmsr(struct cfg80211_registered_device *rdev,
 +		struct wireless_dev *wdev,
 +		struct cfg80211_pmsr_request *request)
 +{
 +	int ret = -EOPNOTSUPP;
 +
 +	trace_rdev_start_pmsr(&rdev->wiphy, wdev, request->cookie);
 +	if (rdev->ops->start_pmsr)
 +		ret = rdev->ops->start_pmsr(&rdev->wiphy, wdev, request);
 +	trace_rdev_return_int(&rdev->wiphy, ret);
 +	return ret;
 +}
 +
 +static inline void
 +rdev_abort_pmsr(struct cfg80211_registered_device *rdev,
 +		struct wireless_dev *wdev,
 +		struct cfg80211_pmsr_request *request)
 +{
 +	trace_rdev_abort_pmsr(&rdev->wiphy, wdev, request->cookie);
 +	if (rdev->ops->abort_pmsr)
 +		rdev->ops->abort_pmsr(&rdev->wiphy, wdev, request);
 +	trace_rdev_return_void(&rdev->wiphy);
 +}
 +
 +static inline int rdev_update_owe_info(struct cfg80211_registered_device *rdev,
 +				       struct net_device *dev,
 +				       struct cfg80211_update_owe_info *oweinfo)
 +{
 +	int ret = -EOPNOTSUPP;
 +
 +	trace_rdev_update_owe_info(&rdev->wiphy, dev, oweinfo);
 +	if (rdev->ops->update_owe_info)
 +		ret = rdev->ops->update_owe_info(&rdev->wiphy, dev, oweinfo);
 +	trace_rdev_return_int(&rdev->wiphy, ret);
 +	return ret;
 +}
 +
 +static inline int
 +rdev_probe_mesh_link(struct cfg80211_registered_device *rdev,
 +		     struct net_device *dev, const u8 *dest,
 +		     const void *buf, size_t len)
 +{
 +	int ret;
 +
 +	trace_rdev_probe_mesh_link(&rdev->wiphy, dev, dest, buf, len);
 +	ret = rdev->ops->probe_mesh_link(&rdev->wiphy, dev, buf, len);
 +	trace_rdev_return_int(&rdev->wiphy, ret);
 +	return ret;
 +}
 +
++=======
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  #endif /* __CFG80211_RDEV_OPS */
diff --cc net/wireless/trace.h
index c6933fa21497,7e0380192445..000000000000
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@@ -3431,12 -3175,125 +3431,125 @@@ TRACE_EVENT(rdev_probe_mesh_link
  	TP_fast_assign(
  		WIPHY_ASSIGN;
  		NETDEV_ASSIGN;
 -		CHAN_DEF_ASSIGN(chandef);
 -		__entry->cac_time_ms = cac_time_ms;
 +		MAC_ASSIGN(dest, dest);
  	),
 -	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", " CHAN_DEF_PR_FMT
 -		  ", cac_time_ms=%u",
 -		  WIPHY_PR_ARG, NETDEV_PR_ARG, CHAN_DEF_PR_ARG,
 -		  __entry->cac_time_ms)
 +	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", " MAC_PR_FMT,
 +		  WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(dest))
  );
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(rdev_set_mcast_rate,
+ 	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+ 		 int *mcast_rate),
+ 	TP_ARGS(wiphy, netdev, mcast_rate),
+ 	TP_STRUCT__entry(
+ 		WIPHY_ENTRY
+ 		NETDEV_ENTRY
+ 		__array(int, mcast_rate, NUM_NL80211_BANDS)
+ 	),
+ 	TP_fast_assign(
+ 		WIPHY_ASSIGN;
+ 		NETDEV_ASSIGN;
+ 		memcpy(__entry->mcast_rate, mcast_rate,
+ 		       sizeof(int) * NUM_NL80211_BANDS);
+ 	),
+ 	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", "
+ 		  "mcast_rates [2.4GHz=0x%x, 5.2GHz=0x%x, 60GHz=0x%x]",
+ 		  WIPHY_PR_ARG, NETDEV_PR_ARG,
+ 		  __entry->mcast_rate[NL80211_BAND_2GHZ],
+ 		  __entry->mcast_rate[NL80211_BAND_5GHZ],
+ 		  __entry->mcast_rate[NL80211_BAND_60GHZ])
+ );
+ 
+ TRACE_EVENT(rdev_set_coalesce,
+ 	TP_PROTO(struct wiphy *wiphy, struct cfg80211_coalesce *coalesce),
+ 	TP_ARGS(wiphy, coalesce),
+ 	TP_STRUCT__entry(
+ 		WIPHY_ENTRY
+ 		__field(int, n_rules)
+ 	),
+ 	TP_fast_assign(
+ 		WIPHY_ASSIGN;
+ 		__entry->n_rules = coalesce ? coalesce->n_rules : 0;
+ 	),
+ 	TP_printk(WIPHY_PR_FMT ", n_rules=%d",
+ 		  WIPHY_PR_ARG, __entry->n_rules)
+ );
+ 
+ DEFINE_EVENT(wiphy_wdev_evt, rdev_abort_scan,
+ 	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev),
+ 	TP_ARGS(wiphy, wdev)
+ );
+ 
+ TRACE_EVENT(rdev_set_multicast_to_unicast,
+ 	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+ 		 const bool enabled),
+ 	TP_ARGS(wiphy, netdev, enabled),
+ 	TP_STRUCT__entry(
+ 		WIPHY_ENTRY
+ 		NETDEV_ENTRY
+ 		__field(bool, enabled)
+ 	),
+ 	TP_fast_assign(
+ 		WIPHY_ASSIGN;
+ 		NETDEV_ASSIGN;
+ 		__entry->enabled = enabled;
+ 	),
+ 	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", unicast: %s",
+ 		  WIPHY_PR_ARG, NETDEV_PR_ARG,
+ 		  BOOL_TO_STR(__entry->enabled))
+ );
+ 
+ DEFINE_EVENT(wiphy_wdev_evt, rdev_get_txq_stats,
+ 	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev),
+ 	TP_ARGS(wiphy, wdev)
+ );
+ 
+ TRACE_EVENT(rdev_get_ftm_responder_stats,
+ 	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+ 		 struct cfg80211_ftm_responder_stats *ftm_stats),
+ 
+ 	TP_ARGS(wiphy, netdev, ftm_stats),
+ 
+ 	TP_STRUCT__entry(
+ 		WIPHY_ENTRY
+ 		NETDEV_ENTRY
+ 		__field(u64, timestamp)
+ 		__field(u32, success_num)
+ 		__field(u32, partial_num)
+ 		__field(u32, failed_num)
+ 		__field(u32, asap_num)
+ 		__field(u32, non_asap_num)
+ 		__field(u64, duration)
+ 		__field(u32, unknown_triggers)
+ 		__field(u32, reschedule)
+ 		__field(u32, out_of_window)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		WIPHY_ASSIGN;
+ 		NETDEV_ASSIGN;
+ 		__entry->success_num = ftm_stats->success_num;
+ 		__entry->partial_num = ftm_stats->partial_num;
+ 		__entry->failed_num = ftm_stats->failed_num;
+ 		__entry->asap_num = ftm_stats->asap_num;
+ 		__entry->non_asap_num = ftm_stats->non_asap_num;
+ 		__entry->duration = ftm_stats->total_duration_ms;
+ 		__entry->unknown_triggers = ftm_stats->unknown_triggers_num;
+ 		__entry->reschedule = ftm_stats->reschedule_requests_num;
+ 		__entry->out_of_window = ftm_stats->out_of_window_triggers_num;
+ 	),
+ 
+ 	TP_printk(WIPHY_PR_FMT "Ftm responder stats: success %u, partial %u, "
+ 		"failed %u, asap %u, non asap %u, total duration %llu, unknown "
+ 		"triggers %u, rescheduled %u, out of window %u", WIPHY_PR_ARG,
+ 		__entry->success_num, __entry->partial_num, __entry->failed_num,
+ 		__entry->asap_num, __entry->non_asap_num, __entry->duration,
+ 		__entry->unknown_triggers, __entry->reschedule,
+ 		__entry->out_of_window)
+ );
++>>>>>>> 81e54d08d9d8 (cfg80211: support FTM responder configuration/statistics)
  #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
  
  #undef TRACE_INCLUDE_PATH
* Unmerged path include/net/cfg80211.h
* Unmerged path include/uapi/linux/nl80211.h
* Unmerged path net/wireless/nl80211.c
* Unmerged path net/wireless/rdev-ops.h
* Unmerged path net/wireless/trace.h
