fuse: allow skipping control interface and forced unmount

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Vivek Goyal <vgoyal@redhat.com>
commit 15c8e72e88e0b707ffefd524ca33f28cdb3db487
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/15c8e72e.failed

virtio-fs does not support aborting requests which are being
processed. That is requests which have been sent to fuse daemon on host.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 15c8e72e88e0b707ffefd524ca33f28cdb3db487)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/fuse_i.h
#	fs/fuse/inode.c
diff --cc fs/fuse/fuse_i.h
index b9287760b32a,fc89cb40e874..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -405,6 -455,29 +405,32 @@@ struct fuse_dev 
  	struct list_head entry;
  };
  
++<<<<<<< HEAD
++=======
+ struct fuse_fs_context {
+ 	int fd;
+ 	unsigned int rootmode;
+ 	kuid_t user_id;
+ 	kgid_t group_id;
+ 	bool is_bdev:1;
+ 	bool fd_present:1;
+ 	bool rootmode_present:1;
+ 	bool user_id_present:1;
+ 	bool group_id_present:1;
+ 	bool default_permissions:1;
+ 	bool allow_other:1;
+ 	bool destroy:1;
+ 	bool no_control:1;
+ 	bool no_force_umount:1;
+ 	unsigned int max_read;
+ 	unsigned int blksize;
+ 	const char *subtype;
+ 
+ 	/* fuse_dev pointer to fill in, should contain NULL on entry */
+ 	void **fudptr;
+ };
+ 
++>>>>>>> 15c8e72e88e0 (fuse: allow skipping control interface and forced unmount)
  /**
   * A Fuse connection.
   *
@@@ -619,6 -692,18 +645,21 @@@ struct fuse_conn 
  	/** Does the filesystem support copy_file_range? */
  	unsigned no_copy_file_range:1;
  
++<<<<<<< HEAD
++=======
+ 	/* Send DESTROY request */
+ 	unsigned int destroy:1;
+ 
+ 	/* Delete dentries that have gone stale */
+ 	unsigned int delete_stale:1;
+ 
+ 	/** Do not create entry in fusectl fs */
+ 	unsigned int no_control:1;
+ 
+ 	/** Do not allow MNT_FORCE umount */
+ 	unsigned int no_force_umount:1;
+ 
++>>>>>>> 15c8e72e88e0 (fuse: allow skipping control interface and forced unmount)
  	/** The number of requests waiting for completion */
  	atomic_t num_waiting;
  
diff --cc fs/fuse/inode.c
index 523a1f18c557,10d193b24fb8..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -1168,17 -1168,17 +1171,28 @@@ static int fuse_fill_super(struct super
  		fc->dont_mask = 1;
  	sb->s_flags |= SB_POSIXACL;
  
++<<<<<<< HEAD
 +	fc->default_permissions = d.default_permissions;
 +	fc->allow_other = d.allow_other;
 +	fc->user_id = d.user_id;
 +	fc->group_id = d.group_id;
 +	fc->max_read = max_t(unsigned, 4096, d.max_read);
 +
 +	/* Used by get_root_inode() */
 +	sb->s_fs_info = fc;
++=======
+ 	fc->default_permissions = ctx->default_permissions;
+ 	fc->allow_other = ctx->allow_other;
+ 	fc->user_id = ctx->user_id;
+ 	fc->group_id = ctx->group_id;
+ 	fc->max_read = max_t(unsigned, 4096, ctx->max_read);
+ 	fc->destroy = ctx->destroy;
+ 	fc->no_control = ctx->no_control;
+ 	fc->no_force_umount = ctx->no_force_umount;
++>>>>>>> 15c8e72e88e0 (fuse: allow skipping control interface and forced unmount)
  
  	err = -ENOMEM;
 -	root = fuse_get_root_inode(sb, ctx->rootmode);
 +	root = fuse_get_root_inode(sb, d.rootmode);
  	sb->s_d_op = &fuse_root_dentry_operations;
  	root_dentry = d_make_root(root);
  	if (!root_dentry)
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path fs/fuse/inode.c
