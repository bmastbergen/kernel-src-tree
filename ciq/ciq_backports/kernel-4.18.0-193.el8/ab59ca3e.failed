RDMA/core: Fix an error handling path in 'res_get_common_doit()'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Christophe JAILLET <christophe.jaillet@wanadoo.fr>
commit ab59ca3eb4e7059727df85eee68bda169d26c8f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ab59ca3e.failed

According to surrounding error paths, it is likely that 'goto err_get;' is
expected here. Otherwise, a call to 'rdma_restrack_put(res);' would be
missing.

Fixes: c5dfe0ea6ffa ("RDMA/nldev: Add resource tracker doit callback")
Link: https://lore.kernel.org/r/20190818091044.8845-1-christophe.jaillet@wanadoo.fr
	Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit ab59ca3eb4e7059727df85eee68bda169d26c8f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
diff --cc drivers/infiniband/core/nldev.c
index efccd8e0fb77,3e84981e5e57..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -938,15 -1168,97 +938,95 @@@ static const struct nldev_fill_res_entr
  	},
  };
  
 -static int res_get_common_doit(struct sk_buff *skb, struct nlmsghdr *nlh,
 -			       struct netlink_ext_ack *extack,
 -			       enum rdma_restrack_type res_type)
 +static bool is_visible_in_pid_ns(struct rdma_restrack_entry *res)
  {
 -	const struct nldev_fill_res_entry *fe = &fill_entries[res_type];
++<<<<<<< HEAD
 +	/*
 +	 * 1. Kern resources should be visible in init name space only
 +	 * 2. Present only resources visible in the current namespace
 +	 */
 +	if (rdma_is_kernel_res(res))
 +		return task_active_pid_ns(current) == &init_pid_ns;
 +	return task_active_pid_ns(current) == task_active_pid_ns(res->task);
++=======
++	const struct nldev_fill_res_entry *fe = &fill_entries[res_type];
+ 	struct nlattr *tb[RDMA_NLDEV_ATTR_MAX];
+ 	struct rdma_restrack_entry *res;
+ 	struct ib_device *device;
+ 	u32 index, id, port = 0;
+ 	bool has_cap_net_admin;
+ 	struct sk_buff *msg;
+ 	int ret;
+ 
+ 	ret = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,
+ 				     nldev_policy, extack);
+ 	if (ret || !tb[RDMA_NLDEV_ATTR_DEV_INDEX] || !fe->id || !tb[fe->id])
+ 		return -EINVAL;
+ 
+ 	index = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);
+ 	device = ib_device_get_by_index(sock_net(skb->sk), index);
+ 	if (!device)
+ 		return -EINVAL;
+ 
+ 	if (tb[RDMA_NLDEV_ATTR_PORT_INDEX]) {
+ 		port = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);
+ 		if (!rdma_is_port_valid(device, port)) {
+ 			ret = -EINVAL;
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	if ((port && fe->flags & NLDEV_PER_DEV) ||
+ 	    (!port && ~fe->flags & NLDEV_PER_DEV)) {
+ 		ret = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	id = nla_get_u32(tb[fe->id]);
+ 	res = rdma_restrack_get_byid(device, res_type, id);
+ 	if (IS_ERR(res)) {
+ 		ret = PTR_ERR(res);
+ 		goto err;
+ 	}
+ 
+ 	if (!rdma_is_visible_in_pid_ns(res)) {
+ 		ret = -ENOENT;
+ 		goto err_get;
+ 	}
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg) {
+ 		ret = -ENOMEM;
+ 		goto err_get;
+ 	}
+ 
+ 	nlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,
+ 			RDMA_NL_GET_TYPE(RDMA_NL_NLDEV, fe->nldev_cmd),
+ 			0, 0);
+ 
+ 	if (fill_nldev_handle(msg, device)) {
+ 		ret = -EMSGSIZE;
+ 		goto err_free;
+ 	}
+ 
+ 	has_cap_net_admin = netlink_capable(skb, CAP_NET_ADMIN);
+ 	ret = fe->fill_res_func(msg, has_cap_net_admin, res, port);
+ 	rdma_restrack_put(res);
+ 	if (ret)
+ 		goto err_free;
+ 
+ 	nlmsg_end(msg, nlh);
+ 	ib_device_put(device);
+ 	return rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);
+ 
+ err_free:
+ 	nlmsg_free(msg);
+ err_get:
+ 	rdma_restrack_put(res);
+ err:
+ 	ib_device_put(device);
+ 	return ret;
++>>>>>>> ab59ca3eb4e7 (RDMA/core: Fix an error handling path in 'res_get_common_doit()')
  }
  
  static int res_get_common_dumpit(struct sk_buff *skb,
* Unmerged path drivers/infiniband/core/nldev.c
