s390/qeth: support per-frame invalidation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [s390] qeth: support per-frame invalidation (Philipp Rudo) [1781085]
Rebuild_FUZZ: 93.51%
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 5fd3fcbb8af8f9bc82afd84937393c193b95c204
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/5fd3fcbb.failed

Each RX buffer may contain up to 64KB worth of data. In case the device
needs to discard a packet _after_ already having reserved space for it
in the buffer, the whole buffer gets set to ERROR state. As the buffer
might contain any number of good packets, this can result in collateral
packet loss.

qeth can provide relief by enabling per-frame invalidation. The RX
buffer is then presented as usual, we just need to spot & drop any
individual packet that was flagged as invalid.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5fd3fcbb8af8f9bc82afd84937393c193b95c204)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core.h
index dcbcb3b4d38f,52fd3c4bb132..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -461,6 -465,56 +462,59 @@@ enum qeth_out_q_states 
         QETH_OUT_Q_LOCKED_FLUSH,
  };
  
++<<<<<<< HEAD
++=======
+ #define QETH_CARD_STAT_ADD(_c, _stat, _val)	((_c)->stats._stat += (_val))
+ #define QETH_CARD_STAT_INC(_c, _stat)		QETH_CARD_STAT_ADD(_c, _stat, 1)
+ 
+ #define QETH_TXQ_STAT_ADD(_q, _stat, _val)	((_q)->stats._stat += (_val))
+ #define QETH_TXQ_STAT_INC(_q, _stat)		QETH_TXQ_STAT_ADD(_q, _stat, 1)
+ 
+ struct qeth_card_stats {
+ 	u64 rx_bufs;
+ 	u64 rx_skb_csum;
+ 	u64 rx_sg_skbs;
+ 	u64 rx_sg_frags;
+ 	u64 rx_sg_alloc_page;
+ 
+ 	u64 rx_dropped_nomem;
+ 	u64 rx_dropped_notsupp;
+ 
+ 	/* rtnl_link_stats64 */
+ 	u64 rx_packets;
+ 	u64 rx_bytes;
+ 	u64 rx_multicast;
+ 	u64 rx_length_errors;
+ 	u64 rx_frame_errors;
+ 	u64 rx_fifo_errors;
+ };
+ 
+ struct qeth_out_q_stats {
+ 	u64 bufs;
+ 	u64 bufs_pack;
+ 	u64 buf_elements;
+ 	u64 skbs_pack;
+ 	u64 skbs_sg;
+ 	u64 skbs_csum;
+ 	u64 skbs_tso;
+ 	u64 skbs_linearized;
+ 	u64 skbs_linearized_fail;
+ 	u64 tso_bytes;
+ 	u64 packing_mode_switch;
+ 	u64 stopped;
+ 	u64 completion_yield;
+ 	u64 completion_timer;
+ 
+ 	/* rtnl_link_stats64 */
+ 	u64 tx_packets;
+ 	u64 tx_bytes;
+ 	u64 tx_errors;
+ 	u64 tx_dropped;
+ };
+ 
+ #define QETH_TX_TIMER_USECS		500
+ 
++>>>>>>> 5fd3fcbb8af8 (s390/qeth: support per-frame invalidation)
  struct qeth_qdio_out_q {
  	struct qdio_buffer *qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];
  	struct qeth_qdio_out_buffer *bufs[QDIO_MAX_BUFFERS_PER_Q];
diff --cc drivers/s390/net/qeth_core_main.c
index a0c5702815af,c52241df980b..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4436,7 -4347,9 +4437,13 @@@ static int qeth_mdio_read(struct net_de
  	case MII_NWAYTEST: /* N-way auto-neg test register */
  		break;
  	case MII_RERRCOUNTER: /* rx error counter */
++<<<<<<< HEAD
 +		rc = card->stats.rx_errors;
++=======
+ 		rc = card->stats.rx_length_errors +
+ 		     card->stats.rx_frame_errors +
+ 		     card->stats.rx_fifo_errors;
++>>>>>>> 5fd3fcbb8af8 (s390/qeth: support per-frame invalidation)
  		break;
  	case MII_SREVISION: /* silicon revision */
  		break;
@@@ -5199,6 -5095,11 +5206,14 @@@ struct sk_buff *qeth_core_get_next_skb(
  		headroom = sizeof(struct qeth_hdr);
  		break;
  	default:
++<<<<<<< HEAD
++=======
+ 		if ((*hdr)->hdr.l2.id & QETH_HEADER_MASK_INVAL)
+ 			QETH_CARD_STAT_INC(card, rx_frame_errors);
+ 		else
+ 			QETH_CARD_STAT_INC(card, rx_dropped_notsupp);
+ 
++>>>>>>> 5fd3fcbb8af8 (s390/qeth: support per-frame invalidation)
  		break;
  	}
  
@@@ -6215,6 -6234,46 +6230,49 @@@ netdev_features_t qeth_features_check(s
  }
  EXPORT_SYMBOL_GPL(qeth_features_check);
  
++<<<<<<< HEAD
++=======
+ void qeth_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+ {
+ 	struct qeth_card *card = dev->ml_priv;
+ 	struct qeth_qdio_out_q *queue;
+ 	unsigned int i;
+ 
+ 	QETH_CARD_TEXT(card, 5, "getstat");
+ 
+ 	stats->rx_packets = card->stats.rx_packets;
+ 	stats->rx_bytes = card->stats.rx_bytes;
+ 	stats->rx_errors = card->stats.rx_length_errors +
+ 			   card->stats.rx_frame_errors +
+ 			   card->stats.rx_fifo_errors;
+ 	stats->rx_dropped = card->stats.rx_dropped_nomem +
+ 			    card->stats.rx_dropped_notsupp;
+ 	stats->multicast = card->stats.rx_multicast;
+ 	stats->rx_length_errors = card->stats.rx_length_errors;
+ 	stats->rx_frame_errors = card->stats.rx_frame_errors;
+ 	stats->rx_fifo_errors = card->stats.rx_fifo_errors;
+ 
+ 	for (i = 0; i < card->qdio.no_out_queues; i++) {
+ 		queue = card->qdio.out_qs[i];
+ 
+ 		stats->tx_packets += queue->stats.tx_packets;
+ 		stats->tx_bytes += queue->stats.tx_bytes;
+ 		stats->tx_errors += queue->stats.tx_errors;
+ 		stats->tx_dropped += queue->stats.tx_dropped;
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(qeth_get_stats64);
+ 
+ u16 qeth_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			  u8 cast_type, struct net_device *sb_dev)
+ {
+ 	if (cast_type != RTN_UNICAST)
+ 		return QETH_IQD_MCAST_TXQ;
+ 	return QETH_IQD_MIN_UCAST_TXQ;
+ }
+ EXPORT_SYMBOL_GPL(qeth_iqd_select_queue);
+ 
++>>>>>>> 5fd3fcbb8af8 (s390/qeth: support per-frame invalidation)
  int qeth_open(struct net_device *dev)
  {
  	struct qeth_card *card = dev->ml_priv;
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/net/qeth_core_mpc.h b/drivers/s390/net/qeth_core_mpc.h
index d36f9b1973eb..ba2a1d0aa9ce 100644
--- a/drivers/s390/net/qeth_core_mpc.h
+++ b/drivers/s390/net/qeth_core_mpc.h
@@ -905,6 +905,7 @@ extern unsigned char IDX_ACTIVATE_WRITE[];
 #define IDX_ACTIVATE_SIZE	0x22
 #define QETH_IDX_ACT_PNO(buffer) (buffer+0x0b)
 #define QETH_IDX_ACT_ISSUER_RM_TOKEN(buffer) (buffer + 0x0c)
+#define QETH_IDX_ACT_INVAL_FRAME	0x40
 #define QETH_IDX_NO_PORTNAME_REQUIRED(buffer) ((buffer)[0x0b] & 0x80)
 #define QETH_IDX_ACT_FUNC_LEVEL(buffer) (buffer + 0x10)
 #define QETH_IDX_ACT_DATASET_NAME(buffer) (buffer + 0x16)
