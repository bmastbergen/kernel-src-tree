drm/nouveau/kms/nv50-: Call outp_atomic_check_view() before handling PBN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Lyude Paul <lyude@redhat.com>
commit 310d35771ee9040f5744109fc277206ad96ba253
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/310d3577.failed

Since nv50_outp_atomic_check_view() can set crtc_state->mode_changed, we
probably should be calling it before handling any PBN changes. Just a
precaution.

	Signed-off-by: Lyude Paul <lyude@redhat.com>
Fixes: 232c9eec417a ("drm/nouveau: Use atomic VCPI helpers for MST")
	Cc: Ben Skeggs <bskeggs@redhat.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: David Airlie <airlied@redhat.com>
	Cc: Jerry Zuo <Jerry.Zuo@amd.com>
	Cc: Harry Wentland <harry.wentland@amd.com>
	Cc: Juston Li <juston.li@intel.com>
	Cc: Sean Paul <seanpaul@chromium.org>
	Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Cc: <stable@vger.kernel.org> # v5.1+
	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 310d35771ee9040f5744109fc277206ad96ba253)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index 5216b642fff4,6327aaf37c08..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -765,32 -770,36 +765,41 @@@ nv50_msto_atomic_check(struct drm_encod
  	struct nv50_mstm *mstm = mstc->mstm;
  	struct nv50_head_atom *asyh = nv50_head_atom(crtc_state);
  	int slots;
+ 	int ret;
  
- 	if (crtc_state->mode_changed || crtc_state->connectors_changed) {
- 		/*
- 		 * When restoring duplicated states, we need to make sure that
- 		 * the bw remains the same and avoid recalculating it, as the
- 		 * connector's bpc may have changed after the state was
- 		 * duplicated
- 		 */
- 		if (!state->duplicated) {
- 			const int bpp = connector->display_info.bpc * 3;
- 			const int clock = crtc_state->adjusted_mode.clock;
+ 	ret = nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,
+ 					  mstc->native);
+ 	if (ret)
+ 		return ret;
  
++<<<<<<< HEAD
 +			asyh->dp.pbn = drm_dp_calc_pbn_mode(bpp, clock);
 +		}
++=======
+ 	if (!crtc_state->mode_changed && !crtc_state->connectors_changed)
+ 		return 0;
++>>>>>>> 310d35771ee9 (drm/nouveau/kms/nv50-: Call outp_atomic_check_view() before handling PBN)
  
- 		slots = drm_dp_atomic_find_vcpi_slots(state, &mstm->mgr,
- 						      mstc->port,
- 						      asyh->dp.pbn);
- 		if (slots < 0)
- 			return slots;
+ 	/*
+ 	 * When restoring duplicated states, we need to make sure that the bw
+ 	 * remains the same and avoid recalculating it, as the connector's bpc
+ 	 * may have changed after the state was duplicated
+ 	 */
+ 	if (!state->duplicated) {
+ 		const int bpp = connector->display_info.bpc * 3;
+ 		const int clock = crtc_state->adjusted_mode.clock;
  
- 		asyh->dp.tu = slots;
+ 		asyh->dp.pbn = drm_dp_calc_pbn_mode(clock, bpp);
  	}
  
- 	return nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,
- 					   mstc->native);
+ 	slots = drm_dp_atomic_find_vcpi_slots(state, &mstm->mgr, mstc->port,
+ 					      asyh->dp.pbn);
+ 	if (slots < 0)
+ 		return slots;
+ 
+ 	asyh->dp.tu = slots;
+ 
+ 	return 0;
  }
  
  static void
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
