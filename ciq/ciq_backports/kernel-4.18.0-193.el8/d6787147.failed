net/sched: remove block pointer from common offload structure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] sched: remove block pointer from common offload structure (Ivan Vecera) [1731416]
Rebuild_FUZZ: 96.61%
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit d6787147e15dffa7b7f3116a5bc3cbe0670bd74f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d6787147.failed

Based on feedback from Jiri avoid carrying a pointer to the tcf_block
structure in the tc_cls_common_offload structure. Instead store
a flag in driver private data which indicates if offloads apply
to a shared block at block binding time.

	Suggested-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d6787147e15dffa7b7f3116a5bc3cbe0670bd74f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/qos_conf.c
#	net/sched/cls_bpf.c
#	net/sched/cls_flower.c
diff --cc net/sched/cls_bpf.c
index ff1deece0104,27365ed3fe0b..000000000000
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@@ -159,8 -157,7 +159,12 @@@ static int cls_bpf_offload_cmd(struct t
  	skip_sw = prog && tc_skip_sw(prog->gen_flags);
  	obj = prog ?: oldprog;
  
++<<<<<<< HEAD
 +	tc_cls_common_offload_init(&cls_bpf.common, tp, obj->gen_flags,
 +				   extack);
++=======
+ 	tc_cls_common_offload_init(&cls_bpf.common, tp, obj->gen_flags, extack);
++>>>>>>> d6787147e15d (net/sched: remove block pointer from common offload structure)
  	cls_bpf.command = TC_CLSBPF_OFFLOAD;
  	cls_bpf.exts = &obj->exts;
  	cls_bpf.prog = prog ? prog->filter : NULL;
diff --cc net/sched/cls_flower.c
index bf30bf04d4ea,f6685fc53119..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -370,6 -386,9 +370,12 @@@ static void fl_hw_destroy_filter(struc
  	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
  
++<<<<<<< HEAD
++=======
+ 	if (!rtnl_held)
+ 		rtnl_lock();
+ 
++>>>>>>> d6787147e15d (net/sched: remove block pointer from common offload structure)
  	tc_cls_common_offload_init(&cls_flower.common, tp, f->flags, extack);
  	cls_flower.command = TC_CLSFLOWER_DESTROY;
  	cls_flower.cookie = (unsigned long) f;
@@@ -431,6 -475,9 +437,12 @@@ static void fl_hw_update_stats(struct t
  	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
  
++<<<<<<< HEAD
++=======
+ 	if (!rtnl_held)
+ 		rtnl_lock();
+ 
++>>>>>>> d6787147e15d (net/sched: remove block pointer from common offload structure)
  	tc_cls_common_offload_init(&cls_flower.common, tp, f->flags, NULL);
  	cls_flower.command = TC_CLSFLOWER_STATS;
  	cls_flower.cookie = (unsigned long) f;
@@@ -1544,57 -1712,89 +1556,68 @@@ static void fl_walk(struct tcf_proto *t
  static int fl_reoffload(struct tcf_proto *tp, bool add, tc_setup_cb_t *cb,
  			void *cb_priv, struct netlink_ext_ack *extack)
  {
 +	struct cls_fl_head *head = fl_head_dereference(tp);
  	struct tc_cls_flower_offload cls_flower = {};
  	struct tcf_block *block = tp->chain->block;
 -	struct cls_fl_filter *f = NULL;
 +	struct fl_flow_mask *mask;
 +	struct cls_fl_filter *f;
  	int err;
  
 -	/* hw_filters list can only be changed by hw offload functions after
 -	 * obtaining rtnl lock. Make sure it is not changed while reoffload is
 -	 * iterating it.
 -	 */
 -	ASSERT_RTNL();
 -
 -	while ((f = fl_get_next_hw_filter(tp, f, add))) {
 -		cls_flower.rule =
 -			flow_rule_alloc(tcf_exts_num_actions(&f->exts));
 -		if (!cls_flower.rule) {
 -			__fl_put(f);
 -			return -ENOMEM;
 -		}
 -
 +	list_for_each_entry(mask, &head->masks, list) {
 +		list_for_each_entry(f, &mask->filters, list) {
 +			if (tc_skip_hw(f->flags))
 +				continue;
 +
 +			cls_flower.rule =
 +				flow_rule_alloc(tcf_exts_num_actions(&f->exts));
 +			if (!cls_flower.rule)
 +				return -ENOMEM;
 +
++<<<<<<< HEAD
 +			tc_cls_common_offload_init(&cls_flower.common, tp,
 +						   f->flags, extack);
 +			cls_flower.command = add ?
 +				TC_CLSFLOWER_REPLACE : TC_CLSFLOWER_DESTROY;
 +			cls_flower.cookie = (unsigned long)f;
 +			cls_flower.rule->match.dissector = &mask->dissector;
 +			cls_flower.rule->match.mask = &mask->key;
 +			cls_flower.rule->match.key = &f->mkey;
++=======
+ 		tc_cls_common_offload_init(&cls_flower.common, tp, f->flags,
+ 					   extack);
+ 		cls_flower.command = add ?
+ 			TC_CLSFLOWER_REPLACE : TC_CLSFLOWER_DESTROY;
+ 		cls_flower.cookie = (unsigned long)f;
+ 		cls_flower.rule->match.dissector = &f->mask->dissector;
+ 		cls_flower.rule->match.mask = &f->mask->key;
+ 		cls_flower.rule->match.key = &f->mkey;
 -
 -		err = tc_setup_flow_action(&cls_flower.rule->action, &f->exts);
 -		if (err) {
 -			kfree(cls_flower.rule);
 -			if (tc_skip_sw(f->flags)) {
 -				NL_SET_ERR_MSG_MOD(extack, "Failed to setup flow action");
 -				__fl_put(f);
 -				return err;
++>>>>>>> d6787147e15d (net/sched: remove block pointer from common offload structure)
 +
 +			err = tc_setup_flow_action(&cls_flower.rule->action,
 +						   &f->exts);
 +			if (err) {
 +				kfree(cls_flower.rule);
 +				if (tc_skip_sw(f->flags)) {
 +					NL_SET_ERR_MSG_MOD(extack, "Failed to setup flow action");
 +					return err;
 +				}
 +				continue;
  			}
 -			goto next_flow;
 -		}
  
 -		cls_flower.classid = f->res.classid;
 +			cls_flower.classid = f->res.classid;
  
 -		err = cb(TC_SETUP_CLSFLOWER, &cls_flower, cb_priv);
 -		kfree(cls_flower.rule);
 +			err = cb(TC_SETUP_CLSFLOWER, &cls_flower, cb_priv);
 +			kfree(cls_flower.rule);
  
 -		if (err) {
 -			if (add && tc_skip_sw(f->flags)) {
 -				__fl_put(f);
 -				return err;
 +			if (err) {
 +				if (add && tc_skip_sw(f->flags))
 +					return err;
 +				continue;
  			}
 -			goto next_flow;
 -		}
  
 -		spin_lock(&tp->lock);
 -		tc_cls_offload_cnt_update(block, &f->in_hw_count, &f->flags,
 -					  add);
 -		spin_unlock(&tp->lock);
 -next_flow:
 -		__fl_put(f);
 +			tc_cls_offload_cnt_update(block, &f->in_hw_count,
 +						  &f->flags, add);
 +		}
  	}
  
  	return 0;
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/qos_conf.c
diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.h b/drivers/net/ethernet/netronome/nfp/flower/main.h
index 6c27e9b403bc..437a561833a6 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@ -179,6 +179,7 @@ struct nfp_flower_priv {
  * @lag_port_flags:	Extended port flags to record lag state of repr
  * @mac_offloaded:	Flag indicating a MAC address is offloaded for repr
  * @offloaded_mac_addr:	MAC address that has been offloaded for repr
+ * @block_shared:	Flag indicating if offload applies to shared blocks
  * @mac_list:		List entry of reprs that share the same offloaded MAC
  */
 struct nfp_flower_repr_priv {
@@ -186,6 +187,7 @@ struct nfp_flower_repr_priv {
 	unsigned long lag_port_flags;
 	bool mac_offloaded;
 	u8 offloaded_mac_addr[ETH_ALEN];
+	bool block_shared;
 	struct list_head mac_list;
 };
 
diff --git a/drivers/net/ethernet/netronome/nfp/flower/offload.c b/drivers/net/ethernet/netronome/nfp/flower/offload.c
index bdd551f36cb7..60a65209e545 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@ -603,10 +603,14 @@ static int nfp_flower_setup_tc_block(struct net_device *netdev,
 				     struct tc_block_offload *f)
 {
 	struct nfp_repr *repr = netdev_priv(netdev);
+	struct nfp_flower_repr_priv *repr_priv;
 
 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
 		return -EOPNOTSUPP;
 
+	repr_priv = repr->app_priv;
+	repr_priv->block_shared = tcf_block_shared(f->block);
+
 	switch (f->command) {
 	case TC_BLOCK_BIND:
 		return tcf_block_cb_register(f->block,
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/qos_conf.c
* Unmerged path net/sched/cls_bpf.c
* Unmerged path net/sched/cls_flower.c
