powerpc/fadump: remove RMA_START and RMA_END macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Hari Bathini <hbathini@linux.ibm.com>
commit becd91d9c5467160984a0380df72fdf71fee82f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/becd91d9.failed

RMA_START is defined as '0' and there is even a BUILD_BUG_ON() to
make sure it is never anything else. Remove this macro and use '0'
instead as code change is needed anyway when it has to be something
else. Also, remove unused RMA_END macro.

	Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/156821384096.5656.15026984053970204652.stgit@hbathini.in.ibm.com
(cherry picked from commit becd91d9c5467160984a0380df72fdf71fee82f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/fadump-internal.h
#	arch/powerpc/kernel/fadump.c
#	arch/powerpc/platforms/pseries/rtas-fadump.c
diff --cc arch/powerpc/include/asm/fadump-internal.h
index f8097510e03f,aec1515ac8f8..000000000000
--- a/arch/powerpc/include/asm/fadump-internal.h
+++ b/arch/powerpc/include/asm/fadump-internal.h
@@@ -9,24 -9,7 +9,28 @@@
  #ifndef _ASM_POWERPC_FADUMP_INTERNAL_H
  #define _ASM_POWERPC_FADUMP_INTERNAL_H
  
++<<<<<<< HEAD
 +/*
 + * The RMA region will be saved for later dumping when kernel crashes.
 + * RMA is Real Mode Area, the first block of logical memory address owned
 + * by logical partition, containing the storage that may be accessed with
 + * translate off.
 + */
 +#define RMA_START	0x0
 +#define RMA_END		(ppc64_rma_size)
++=======
+ #ifndef CONFIG_PRESERVE_FA_DUMP
++>>>>>>> becd91d9c546 (powerpc/fadump: remove RMA_START and RMA_END macros)
 +
 +/*
 + * On some Power systems where RMO is 128MB, it still requires minimum of
 + * 256MB for kernel to boot successfully. When kdump infrastructure is
 + * configured to save vmcore over network, we run into OOM issue while
 + * loading modules related to network setup. Hence we need additional 64M
 + * of memory to avoid OOM issue.
 + */
 +#define MIN_BOOT_MEM	(((RMA_END < (0x1UL << 28)) ? (0x1UL << 28) : RMA_END) \
 +			+ (0x1UL << 26))
  
  /* The upper limit percentage for user specified boot memory size (25%) */
  #define MAX_BOOT_MEM_RATIO			4
diff --cc arch/powerpc/kernel/fadump.c
index 56526469b148,2e139259474d..000000000000
--- a/arch/powerpc/kernel/fadump.c
+++ b/arch/powerpc/kernel/fadump.c
@@@ -1141,29 -772,28 +1145,32 @@@ static int fadump_setup_crash_memory_ra
  	int ret;
  
  	pr_debug("Setup crash memory ranges.\n");
 -	crash_mrange_info.mem_range_cnt = 0;
 +	crash_mem_ranges = 0;
  
  	/*
- 	 * add the first memory chunk (RMA_START through boot_memory_size) as
+ 	 * add the first memory chunk (0 through boot_memory_size) as
  	 * a separate memory chunk. The reason is, at the time crash firmware
  	 * will move the content of this memory chunk to different location
  	 * specified during fadump registration. We need to create a separate
  	 * program header for this chunk with the correct offset.
  	 */
++<<<<<<< HEAD
 +	ret = fadump_add_crash_memory(RMA_START, fw_dump.boot_memory_size);
++=======
+ 	ret = fadump_add_mem_range(&crash_mrange_info,
+ 				   0, fw_dump.boot_memory_size);
++>>>>>>> becd91d9c546 (powerpc/fadump: remove RMA_START and RMA_END macros)
  	if (ret)
  		return ret;
  
  	for_each_memblock(memory, reg) {
 -		start = (u64)reg->base;
 -		end = start + (u64)reg->size;
 +		start = (unsigned long long)reg->base;
 +		end = start + (unsigned long long)reg->size;
  
  		/*
- 		 * skip the first memory chunk that is already added (RMA_START
- 		 * through boot_memory_size). This logic needs a relook if and
- 		 * when RMA_START changes to a non-zero value.
+ 		 * skip the first memory chunk that is already added
+ 		 * (0 through boot_memory_size).
  		 */
- 		BUILD_BUG_ON(RMA_START != 0);
  		if (start < fw_dump.boot_memory_size) {
  			if (end > fw_dump.boot_memory_size)
  				start = fw_dump.boot_memory_size;
@@@ -1187,8 -817,8 +1194,13 @@@
   */
  static inline unsigned long fadump_relocate(unsigned long paddr)
  {
++<<<<<<< HEAD
 +	if (paddr > RMA_START && paddr < fw_dump.boot_memory_size)
 +		return be64_to_cpu(fdm.rmr_region.destination_address) + paddr;
++=======
+ 	if ((paddr > 0) && (paddr < fw_dump.boot_memory_size))
+ 		return fw_dump.boot_mem_dest_addr + paddr;
++>>>>>>> becd91d9c546 (powerpc/fadump: remove RMA_START and RMA_END macros)
  	else
  		return paddr;
  }
@@@ -1255,13 -885,13 +1267,13 @@@ static int fadump_create_elfcore_header
  		phdr->p_flags	= PF_R|PF_W|PF_X;
  		phdr->p_offset	= mbase;
  
- 		if (mbase == RMA_START) {
+ 		if (mbase == 0) {
  			/*
- 			 * The entire RMA region will be moved by firmware
- 			 * to the specified destination_address. Hence set
- 			 * the correct offset.
+ 			 * The entire real memory region will be moved by
+ 			 * firmware to the specified destination_address.
+ 			 * Hence set the correct offset.
  			 */
 -			phdr->p_offset = fw_dump.boot_mem_dest_addr;
 +			phdr->p_offset = be64_to_cpu(fdm.rmr_region.destination_address);
  		}
  
  		phdr->p_paddr = mbase;
* Unmerged path arch/powerpc/platforms/pseries/rtas-fadump.c
* Unmerged path arch/powerpc/include/asm/fadump-internal.h
* Unmerged path arch/powerpc/kernel/fadump.c
* Unmerged path arch/powerpc/platforms/pseries/rtas-fadump.c
