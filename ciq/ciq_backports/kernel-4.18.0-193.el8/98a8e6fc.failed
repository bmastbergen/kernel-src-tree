net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info (Alaa Hleihel) [1724335]
Rebuild_FUZZ: 96.67%
commit-author Huy Nguyen <huyn@mellanox.com>
commit 98a8e6fc482d96809d90fcab661835ed299359c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/98a8e6fc.failed

Replace pci dev_err/warn/info messages with mlx5_core_err/warn/info
messages to provide a better report/debug of different mlx5 device types.

This patch does not change any functionality.

	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Signed-off-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 98a8e6fc482d96809d90fcab661835ed299359c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index 10376022a40f,8bedbe497f02..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -763,14 -741,10 +762,19 @@@ static int mlx5_pci_init(struct mlx5_co
  
  	priv->numa_node = dev_to_node(&dev->pdev->dev);
  
 +	if (mlx5_debugfs_root)
 +		priv->dbg_root =
 +			debugfs_create_dir(pci_name(pdev), mlx5_debugfs_root);
 +
  	err = mlx5_pci_enable_device(dev);
  	if (err) {
++<<<<<<< HEAD
 +		dev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");
 +		goto err_dbg;
++=======
+ 		mlx5_core_err(dev, "Cannot enable PCI device, aborting\n");
+ 		return err;
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  	}
  
  	err = request_bar(pdev);
@@@ -820,18 -790,16 +824,24 @@@ static void mlx5_pci_close(struct mlx5_
  	pci_clear_master(dev->pdev);
  	release_bar(dev->pdev);
  	mlx5_pci_disable_device(dev);
 +	debugfs_remove_recursive(priv->dbg_root);
  }
  
 -static int mlx5_init_once(struct mlx5_core_dev *dev)
 +static int mlx5_init_once(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
  {
- 	struct pci_dev *pdev = dev->pdev;
  	int err;
  
++<<<<<<< HEAD
 +	priv->devcom = mlx5_devcom_register_device(dev);
 +	if (IS_ERR(priv->devcom))
 +		dev_err(&pdev->dev, "failed to register with devcom (0x%p)\n",
 +			priv->devcom);
++=======
+ 	dev->priv.devcom = mlx5_devcom_register_device(dev);
+ 	if (IS_ERR(dev->priv.devcom))
+ 		mlx5_core_err(dev, "failed to register with devcom (0x%p)\n",
+ 			      dev->priv.devcom);
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  
  	err = mlx5_query_board_id(dev);
  	if (err) {
@@@ -943,22 -911,12 +953,26 @@@ static void mlx5_cleanup_once(struct ml
  	mlx5_devcom_unregister_device(dev->priv.devcom);
  }
  
 -static int mlx5_function_setup(struct mlx5_core_dev *dev, bool boot)
 +static int mlx5_load_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,
 +			 bool boot)
  {
- 	struct pci_dev *pdev = dev->pdev;
  	int err;
  
++<<<<<<< HEAD
 +	dev->caps.embedded_cpu = mlx5_read_embedded_cpu(dev);
 +	mutex_lock(&dev->intf_state_mutex);
 +	if (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
 +		dev_warn(&dev->pdev->dev, "%s: interface is up, NOP\n",
 +			 __func__);
 +		goto out;
 +	}
 +
 +	dev_info(&pdev->dev, "firmware version: %d.%d.%d\n", fw_rev_maj(dev),
 +		 fw_rev_min(dev), fw_rev_sub(dev));
++=======
+ 	mlx5_core_info(dev, "firmware version: %d.%d.%d\n", fw_rev_maj(dev),
+ 		       fw_rev_min(dev), fw_rev_sub(dev));
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  
  	/* Only PFs hold the relevant PCIe information for this query */
  	if (mlx5_core_is_pf(dev))
@@@ -973,15 -926,15 +987,26 @@@
  	 */
  	err = wait_fw_init(dev, FW_PRE_INIT_TIMEOUT_MILI);
  	if (err) {
++<<<<<<< HEAD
 +		dev_err(&dev->pdev->dev, "Firmware over %d MS in pre-initializing state, aborting\n",
 +			FW_PRE_INIT_TIMEOUT_MILI);
 +		goto out_err;
++=======
+ 		mlx5_core_err(dev, "Firmware over %d MS in pre-initializing state, aborting\n",
+ 			      FW_PRE_INIT_TIMEOUT_MILI);
+ 		return err;
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  	}
  
  	err = mlx5_cmd_init(dev);
  	if (err) {
++<<<<<<< HEAD
 +		dev_err(&pdev->dev, "Failed initializing command interface, aborting\n");
 +		goto out_err;
++=======
+ 		mlx5_core_err(dev, "Failed initializing command interface, aborting\n");
+ 		return err;
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  	}
  
  	err = wait_fw_init(dev, FW_INIT_TIMEOUT_MILI);
@@@ -1039,23 -992,50 +1064,64 @@@
  
  	err = mlx5_query_hca_caps(dev);
  	if (err) {
++<<<<<<< HEAD
 +		dev_err(&pdev->dev, "query hca failed\n");
 +		goto err_stop_poll;
 +	}
 +
 +	if (boot) {
 +		err = mlx5_init_once(dev, priv);
 +		if (err) {
 +			dev_err(&pdev->dev, "sw objs init failed\n");
 +			goto err_stop_poll;
 +		}
 +	}
++=======
+ 		mlx5_core_err(dev, "query hca failed\n");
+ 		goto stop_health;
+ 	}
+ 
+ 	return 0;
+ 
+ stop_health:
+ 	mlx5_stop_health_poll(dev, boot);
+ reclaim_boot_pages:
+ 	mlx5_reclaim_startup_pages(dev);
+ err_disable_hca:
+ 	mlx5_core_disable_hca(dev, 0);
+ err_cmd_cleanup:
+ 	mlx5_cmd_cleanup(dev);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5_function_teardown(struct mlx5_core_dev *dev, bool boot)
+ {
+ 	int err;
+ 
+ 	mlx5_stop_health_poll(dev, boot);
+ 	err = mlx5_cmd_teardown_hca(dev);
+ 	if (err) {
+ 		mlx5_core_err(dev, "tear_down_hca failed, skip cleanup\n");
+ 		return err;
+ 	}
+ 	mlx5_reclaim_startup_pages(dev);
+ 	mlx5_core_disable_hca(dev, 0);
+ 	mlx5_cmd_cleanup(dev);
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_load(struct mlx5_core_dev *dev)
+ {
+ 	int err;
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  
  	dev->priv.uar = mlx5_get_uars_page(dev);
  	if (IS_ERR(dev->priv.uar)) {
- 		dev_err(&pdev->dev, "Failed allocating uar, aborting\n");
+ 		mlx5_core_err(dev, "Failed allocating uar, aborting\n");
  		err = PTR_ERR(dev->priv.uar);
 -		return err;
 +		goto err_get_uars;
  	}
  
  	mlx5_events_start(dev);
@@@ -1115,12 -1095,79 +1181,86 @@@
  		goto err_ec;
  	}
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ 
+ err_ec:
+ 	mlx5_sriov_detach(dev);
+ err_sriov:
+ 	mlx5_cleanup_fs(dev);
+ err_fs:
+ 	mlx5_accel_tls_cleanup(dev);
+ err_tls_start:
+ 	mlx5_accel_ipsec_cleanup(dev);
+ err_ipsec_start:
+ 	mlx5_fpga_device_stop(dev);
+ err_fpga_start:
+ 	mlx5_fw_tracer_cleanup(dev->tracer);
+ err_fw_tracer:
+ 	mlx5_eq_table_destroy(dev);
+ err_eq_table:
+ 	mlx5_pagealloc_stop(dev);
+ 	mlx5_events_stop(dev);
+ 	mlx5_put_uars_page(dev, dev->priv.uar);
+ 	return err;
+ }
+ 
+ static void mlx5_unload(struct mlx5_core_dev *dev)
+ {
+ 	mlx5_ec_cleanup(dev);
+ 	mlx5_sriov_detach(dev);
+ 	mlx5_cleanup_fs(dev);
+ 	mlx5_accel_ipsec_cleanup(dev);
+ 	mlx5_accel_tls_cleanup(dev);
+ 	mlx5_fpga_device_stop(dev);
+ 	mlx5_fw_tracer_cleanup(dev->tracer);
+ 	mlx5_eq_table_destroy(dev);
+ 	mlx5_pagealloc_stop(dev);
+ 	mlx5_events_stop(dev);
+ 	mlx5_put_uars_page(dev, dev->priv.uar);
+ }
+ 
+ static int mlx5_load_one(struct mlx5_core_dev *dev, bool boot)
+ {
+ 	int err = 0;
+ 
+ 	dev->caps.embedded_cpu = mlx5_read_embedded_cpu(dev);
+ 	mutex_lock(&dev->intf_state_mutex);
+ 	if (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
+ 		mlx5_core_warn(dev, "interface is up, NOP\n");
+ 		goto out;
+ 	}
+ 	/* remove any previous indication of internal error */
+ 	dev->state = MLX5_DEVICE_STATE_UP;
+ 
+ 	err = mlx5_function_setup(dev, boot);
+ 	if (err)
+ 		goto out;
+ 
+ 	if (boot) {
+ 		err = mlx5_init_once(dev);
+ 		if (err) {
+ 			mlx5_core_err(dev, "sw objs init failed\n");
+ 			goto function_teardown;
+ 		}
+ 	}
+ 
+ 	err = mlx5_load(dev);
+ 	if (err)
+ 		goto err_load;
+ 
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  	if (mlx5_device_registered(dev)) {
  		mlx5_attach_device(dev);
  	} else {
  		err = mlx5_register_device(dev);
  		if (err) {
++<<<<<<< HEAD
 +			dev_err(&pdev->dev, "mlx5_register_device failed %d\n", err);
++=======
+ 			mlx5_core_err(dev, "register device failed %d\n", err);
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  			goto err_reg_dev;
  		}
  	}
@@@ -1299,9 -1273,53 +1439,57 @@@ static int init_one(struct pci_dev *pde
  	if (err)
  		goto err_pagealloc_init;
  
++<<<<<<< HEAD
 +	err = mlx5_load_one(dev, priv, true);
++=======
+ 	return 0;
+ 
+ err_pagealloc_init:
+ 	mlx5_health_cleanup(dev);
+ err_health_init:
+ 	debugfs_remove(dev->priv.dbg_root);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5_mdev_uninit(struct mlx5_core_dev *dev)
+ {
+ 	mlx5_pagealloc_cleanup(dev);
+ 	mlx5_health_cleanup(dev);
+ 	debugfs_remove_recursive(dev->priv.dbg_root);
+ }
+ 
+ #define MLX5_IB_MOD "mlx5_ib"
+ static int init_one(struct pci_dev *pdev, const struct pci_device_id *id)
+ {
+ 	struct mlx5_core_dev *dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = devlink_alloc(&mlx5_devlink_ops, sizeof(*dev));
+ 	if (!devlink) {
+ 		dev_err(&pdev->dev, "kzalloc failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	dev = devlink_priv(devlink);
+ 
+ 	err = mlx5_mdev_init(dev, prof_sel, dev_name(&pdev->dev));
+ 	if (err)
+ 		goto mdev_init_err;
+ 
+ 	err = mlx5_pci_init(dev, pdev, id);
+ 	if (err) {
+ 		mlx5_core_err(dev, "mlx5_pci_init failed with error code %d\n",
+ 			      err);
+ 		goto pci_init_err;
+ 	}
+ 
+ 	err = mlx5_load_one(dev, true);
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  	if (err) {
- 		dev_err(&pdev->dev, "mlx5_load_one failed with error code %d\n", err);
+ 		mlx5_core_err(dev, "mlx5_load_one failed with error code %d\n",
+ 			      err);
  		goto err_load_one;
  	}
  
@@@ -1337,9 -1353,9 +1525,15 @@@ static void remove_one(struct pci_dev *
  	devlink_unregister(devlink);
  	mlx5_unregister_device(dev);
  
++<<<<<<< HEAD
 +	if (mlx5_unload_one(dev, priv, true)) {
 +		dev_err(&dev->pdev->dev, "mlx5_unload_one failed\n");
 +		mlx5_health_cleanup(dev);
++=======
+ 	if (mlx5_unload_one(dev, true)) {
+ 		mlx5_core_err(dev, "mlx5_unload_one failed\n");
+ 		mlx5_health_flush(dev);
++>>>>>>> 98a8e6fc482d (net/mlx5: Replace dev_err/warn/info by mlx5_core_err/warn/info)
  		return;
  	}
  
@@@ -1353,12 -1368,11 +1547,12 @@@ static pci_ers_result_t mlx5_pci_err_de
  					      pci_channel_state_t state)
  {
  	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 +	struct mlx5_priv *priv = &dev->priv;
  
- 	dev_info(&pdev->dev, "%s was called\n", __func__);
+ 	mlx5_core_info(dev, "%s was called\n", __func__);
  
  	mlx5_enter_error_state(dev, false);
 -	mlx5_unload_one(dev, false);
 +	mlx5_unload_one(dev, priv, false);
  	/* In case of kernel call drain the health wq */
  	if (state) {
  		mlx5_drain_health_wq(dev);
@@@ -1425,17 -1441,16 +1621,17 @@@ static pci_ers_result_t mlx5_pci_slot_r
  static void mlx5_pci_resume(struct pci_dev *pdev)
  {
  	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 +	struct mlx5_priv *priv = &dev->priv;
  	int err;
  
- 	dev_info(&pdev->dev, "%s was called\n", __func__);
+ 	mlx5_core_info(dev, "%s was called\n", __func__);
  
 -	err = mlx5_load_one(dev, false);
 +	err = mlx5_load_one(dev, priv, false);
  	if (err)
- 		dev_err(&pdev->dev, "%s: mlx5_load_one failed with error code: %d\n"
- 			, __func__, err);
+ 		mlx5_core_err(dev, "%s: mlx5_load_one failed with error code: %d\n",
+ 			      __func__, err);
  	else
- 		dev_info(&pdev->dev, "%s: device recovered\n", __func__);
+ 		mlx5_core_info(dev, "%s: device recovered\n", __func__);
  }
  
  static const struct pci_error_handlers mlx5_err_handler = {
@@@ -1497,13 -1512,12 +1693,13 @@@ succeed
  static void shutdown(struct pci_dev *pdev)
  {
  	struct mlx5_core_dev *dev  = pci_get_drvdata(pdev);
 +	struct mlx5_priv *priv = &dev->priv;
  	int err;
  
- 	dev_info(&pdev->dev, "Shutdown was called\n");
+ 	mlx5_core_info(dev, "Shutdown was called\n");
  	err = mlx5_try_fast_unload(dev);
  	if (err)
 -		mlx5_unload_one(dev, false);
 +		mlx5_unload_one(dev, priv, false);
  	mlx5_pci_disable_device(dev);
  }
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index 2e27bca11652..f48dd815fb76 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -1902,9 +1902,9 @@ int mlx5_cmd_init(struct mlx5_core_dev *dev)
 	memset(cmd, 0, sizeof(*cmd));
 	cmd_if_rev = cmdif_rev(dev);
 	if (cmd_if_rev != CMD_IF_REV) {
-		dev_err(&dev->pdev->dev,
-			"Driver cmdif rev(%d) differs from firmware's(%d)\n",
-			CMD_IF_REV, cmd_if_rev);
+		mlx5_core_err(dev,
+			      "Driver cmdif rev(%d) differs from firmware's(%d)\n",
+			      CMD_IF_REV, cmd_if_rev);
 		return -EINVAL;
 	}
 
@@ -1921,14 +1921,14 @@ int mlx5_cmd_init(struct mlx5_core_dev *dev)
 	cmd->log_sz = cmd_l >> 4 & 0xf;
 	cmd->log_stride = cmd_l & 0xf;
 	if (1 << cmd->log_sz > MLX5_MAX_COMMANDS) {
-		dev_err(&dev->pdev->dev, "firmware reports too many outstanding commands %d\n",
-			1 << cmd->log_sz);
+		mlx5_core_err(dev, "firmware reports too many outstanding commands %d\n",
+			      1 << cmd->log_sz);
 		err = -EINVAL;
 		goto err_free_page;
 	}
 
 	if (cmd->log_sz + cmd->log_stride > MLX5_ADAPTER_PAGE_SHIFT) {
-		dev_err(&dev->pdev->dev, "command queue size overflow\n");
+		mlx5_core_err(dev, "command queue size overflow\n");
 		err = -EINVAL;
 		goto err_free_page;
 	}
@@ -1939,8 +1939,8 @@ int mlx5_cmd_init(struct mlx5_core_dev *dev)
 
 	cmd->cmdif_rev = ioread32be(&dev->iseg->cmdif_rev_fw_sub) >> 16;
 	if (cmd->cmdif_rev > CMD_IF_REV) {
-		dev_err(&dev->pdev->dev, "driver does not support command interface version. driver %d, firmware %d\n",
-			CMD_IF_REV, cmd->cmdif_rev);
+		mlx5_core_err(dev, "driver does not support command interface version. driver %d, firmware %d\n",
+			      CMD_IF_REV, cmd->cmdif_rev);
 		err = -EOPNOTSUPP;
 		goto err_free_page;
 	}
@@ -1956,7 +1956,7 @@ int mlx5_cmd_init(struct mlx5_core_dev *dev)
 	cmd_h = (u32)((u64)(cmd->dma) >> 32);
 	cmd_l = (u32)(cmd->dma);
 	if (cmd_l & 0xfff) {
-		dev_err(&dev->pdev->dev, "invalid command queue address\n");
+		mlx5_core_err(dev, "invalid command queue address\n");
 		err = -ENOMEM;
 		goto err_free_page;
 	}
@@ -1976,7 +1976,7 @@ int mlx5_cmd_init(struct mlx5_core_dev *dev)
 	set_wqname(dev);
 	cmd->wq = create_singlethread_workqueue(cmd->wq_name);
 	if (!cmd->wq) {
-		dev_err(&dev->pdev->dev, "failed to create command workqueue\n");
+		mlx5_core_err(dev, "failed to create command workqueue\n");
 		err = -ENOMEM;
 		goto err_cache;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h b/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h
index 7e2e871dbf83..52c9dee91ea4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h
@@ -37,6 +37,7 @@
 
 #include <linux/mlx5/eq.h>
 
+#include "mlx5_core.h"
 #include "lib/eq.h"
 #include "fpga/cmd.h"
 
@@ -62,26 +63,26 @@ struct mlx5_fpga_device {
 };
 
 #define mlx5_fpga_dbg(__adev, format, ...) \
-	dev_dbg(&(__adev)->mdev->pdev->dev, "FPGA: %s:%d:(pid %d): " format, \
-		 __func__, __LINE__, current->pid, ##__VA_ARGS__)
+	mlx5_core_dbg((__adev)->mdev, "FPGA: %s:%d:(pid %d): " format, \
+		       __func__, __LINE__, current->pid, ##__VA_ARGS__)
 
 #define mlx5_fpga_err(__adev, format, ...) \
-	dev_err(&(__adev)->mdev->pdev->dev, "FPGA: %s:%d:(pid %d): " format, \
-		__func__, __LINE__, current->pid, ##__VA_ARGS__)
+	mlx5_core_err((__adev)->mdev, "FPGA: %s:%d:(pid %d): " format, \
+		      __func__, __LINE__, current->pid, ##__VA_ARGS__)
 
 #define mlx5_fpga_warn(__adev, format, ...) \
-	dev_warn(&(__adev)->mdev->pdev->dev, "FPGA: %s:%d:(pid %d): " format, \
-		__func__, __LINE__, current->pid, ##__VA_ARGS__)
+	mlx5_core_warn((__adev)->mdev, "FPGA: %s:%d:(pid %d): " format, \
+		       __func__, __LINE__, current->pid, ##__VA_ARGS__)
 
 #define mlx5_fpga_warn_ratelimited(__adev, format, ...) \
-	dev_warn_ratelimited(&(__adev)->mdev->pdev->dev, "FPGA: %s:%d: " \
-		format, __func__, __LINE__, ##__VA_ARGS__)
+	mlx5_core_err_rl((__adev)->mdev, "FPGA: %s:%d: " \
+			 format, __func__, __LINE__, ##__VA_ARGS__)
 
 #define mlx5_fpga_notice(__adev, format, ...) \
-	dev_notice(&(__adev)->mdev->pdev->dev, "FPGA: " format, ##__VA_ARGS__)
+	mlx5_core_info((__adev)->mdev, "FPGA: " format, ##__VA_ARGS__)
 
 #define mlx5_fpga_info(__adev, format, ...) \
-	dev_info(&(__adev)->mdev->pdev->dev, "FPGA: " format, ##__VA_ARGS__)
+	mlx5_core_info((__adev)->mdev, "FPGA: " format, ##__VA_ARGS__)
 
 int mlx5_fpga_init(struct mlx5_core_dev *mdev);
 void mlx5_fpga_cleanup(struct mlx5_core_dev *mdev);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/health.c b/drivers/net/ethernet/mellanox/mlx5/core/health.c
index bff749be0582..a4051d535482 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@ -152,11 +152,11 @@ static void health_recover(struct work_struct *work)
 
 	nic_state = mlx5_get_nic_state(dev);
 	if (nic_state == MLX5_NIC_IFC_INVALID) {
-		dev_err(&dev->pdev->dev, "health recovery flow aborted since the nic state is invalid\n");
+		mlx5_core_err(dev, "health recovery flow aborted since the nic state is invalid\n");
 		return;
 	}
 
-	dev_err(&dev->pdev->dev, "starting health recovery flow\n");
+	mlx5_core_err(dev, "starting health recovery flow\n");
 	mlx5_recover_device(dev);
 }
 
@@ -180,8 +180,8 @@ static void health_care(struct work_struct *work)
 	if (!test_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags))
 		schedule_delayed_work(&health->recover_work, recover_delay);
 	else
-		dev_err(&dev->pdev->dev,
-			"new health works are not permitted at this stage\n");
+		mlx5_core_err(dev,
+			      "new health works are not permitted at this stage\n");
 	spin_unlock_irqrestore(&health->wq_lock, flags);
 }
 
@@ -228,18 +228,22 @@ static void print_health_info(struct mlx5_core_dev *dev)
 		return;
 
 	for (i = 0; i < ARRAY_SIZE(h->assert_var); i++)
-		dev_err(&dev->pdev->dev, "assert_var[%d] 0x%08x\n", i, ioread32be(h->assert_var + i));
+		mlx5_core_err(dev, "assert_var[%d] 0x%08x\n", i,
+			      ioread32be(h->assert_var + i));
 
-	dev_err(&dev->pdev->dev, "assert_exit_ptr 0x%08x\n", ioread32be(&h->assert_exit_ptr));
-	dev_err(&dev->pdev->dev, "assert_callra 0x%08x\n", ioread32be(&h->assert_callra));
+	mlx5_core_err(dev, "assert_exit_ptr 0x%08x\n",
+		      ioread32be(&h->assert_exit_ptr));
+	mlx5_core_err(dev, "assert_callra 0x%08x\n",
+		      ioread32be(&h->assert_callra));
 	sprintf(fw_str, "%d.%d.%d", fw_rev_maj(dev), fw_rev_min(dev), fw_rev_sub(dev));
-	dev_err(&dev->pdev->dev, "fw_ver %s\n", fw_str);
-	dev_err(&dev->pdev->dev, "hw_id 0x%08x\n", ioread32be(&h->hw_id));
-	dev_err(&dev->pdev->dev, "irisc_index %d\n", ioread8(&h->irisc_index));
-	dev_err(&dev->pdev->dev, "synd 0x%x: %s\n", ioread8(&h->synd), hsynd_str(ioread8(&h->synd)));
-	dev_err(&dev->pdev->dev, "ext_synd 0x%04x\n", ioread16be(&h->ext_synd));
+	mlx5_core_err(dev, "fw_ver %s\n", fw_str);
+	mlx5_core_err(dev, "hw_id 0x%08x\n", ioread32be(&h->hw_id));
+	mlx5_core_err(dev, "irisc_index %d\n", ioread8(&h->irisc_index));
+	mlx5_core_err(dev, "synd 0x%x: %s\n", ioread8(&h->synd),
+		      hsynd_str(ioread8(&h->synd)));
+	mlx5_core_err(dev, "ext_synd 0x%04x\n", ioread16be(&h->ext_synd));
 	fw = ioread32be(&h->fw_ver);
-	dev_err(&dev->pdev->dev, "raw fw_ver 0x%08x\n", fw);
+	mlx5_core_err(dev, "raw fw_ver 0x%08x\n", fw);
 }
 
 static unsigned long get_next_poll_jiffies(void)
@@ -262,8 +266,7 @@ void mlx5_trigger_health_work(struct mlx5_core_dev *dev)
 	if (!test_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags))
 		queue_work(health->wq, &health->work);
 	else
-		dev_err(&dev->pdev->dev,
-			"new health works are not permitted at this stage\n");
+		mlx5_core_err(dev, "new health works are not permitted at this stage\n");
 	spin_unlock_irqrestore(&health->wq_lock, flags);
 }
 
@@ -284,7 +287,7 @@ static void poll_health(struct timer_list *t)
 
 	health->prev = count;
 	if (health->miss_counter == MAX_MISSES) {
-		dev_err(&dev->pdev->dev, "device's health compromised - reached miss count\n");
+		mlx5_core_err(dev, "device's health compromised - reached miss count\n");
 		print_health_info(dev);
 	}
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
