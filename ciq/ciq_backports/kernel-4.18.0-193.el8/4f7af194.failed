drm/i915: Support ro ppgtt mapped cmdparser shadow buffers

jira LE-1907
cve CVE-2019-0155
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Jon Bloomfield <jon.bloomfield@intel.com>
commit 4f7af1948abcb18b4772fe1bcd84d7d27d96258c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/4f7af194.failed

For Gen7, the original cmdparser motive was to permit limited
use of register read/write instructions in unprivileged BB's.
This worked by copying the user supplied bb to a kmd owned
bb, and running it in secure mode, from the ggtt, only if
the scanner finds no unsafe commands or registers.

For Gen8+ we can't use this same technique because running bb's
from the ggtt also disables access to ppgtt space. But we also
do not actually require 'secure' execution since we are only
trying to reduce the available command/register set. Instead we
will copy the user buffer to a kmd owned read-only bb in ppgtt,
and run in the usual non-secure mode.

Note that ro pages are only supported by ppgtt (not ggtt), but
luckily that's exactly what we need.

Add the required paths to map the shadow buffer to ppgtt ro for Gen8+

v2: IS_GEN7/IS_GEN (Mika)
v3: rebase
v4: rebase
v5: rebase

	Signed-off-by: Jon Bloomfield <jon.bloomfield@intel.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Dave Airlie <airlied@redhat.com>
	Cc: Takashi Iwai <tiwai@suse.de>
	Cc: Tyler Hicks <tyhicks@canonical.com>
	Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
	Reviewed-by: Chris Wilson <chris.p.wilson@intel.com>
(cherry picked from commit 4f7af1948abcb18b4772fe1bcd84d7d27d96258c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_gem.c
#	drivers/gpu/drm/i915/i915_gem_execbuffer.c
diff --cc drivers/gpu/drm/i915/i915_gem.c
index 4cffc168c73e,98305d987ac1..000000000000
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@@ -4017,7 -1044,15 +4031,19 @@@ i915_gem_object_pin(struct drm_i915_gem
  			return ERR_PTR(ret);
  	}
  
++<<<<<<< HEAD
 +	ret = i915_vma_pin(vma, size, alignment, flags | PIN_GLOBAL);
++=======
+ 	if (vma->fence && !i915_gem_object_is_tiled(obj)) {
+ 		mutex_lock(&vma->vm->mutex);
+ 		ret = i915_vma_revoke_fence(vma);
+ 		mutex_unlock(&vma->vm->mutex);
+ 		if (ret)
+ 			return ERR_PTR(ret);
+ 	}
+ 
+ 	ret = i915_vma_pin(vma, size, alignment, flags);
++>>>>>>> 4f7af1948abc (drm/i915: Support ro ppgtt mapped cmdparser shadow buffers)
  	if (ret)
  		return ERR_PTR(ret);
  
diff --cc drivers/gpu/drm/i915/i915_gem_execbuffer.c
index 21a06982621e,1f423bb2d644..000000000000
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@@ -1977,9 -1956,37 +1977,37 @@@ static int i915_reset_gen7_sol_offsets(
  	return 0;
  }
  
+ static struct i915_vma *
+ shadow_batch_pin(struct i915_execbuffer *eb, struct drm_i915_gem_object *obj)
+ {
+ 	struct drm_i915_private *dev_priv = eb->i915;
+ 	struct i915_vma * const vma = *eb->vma;
+ 	struct i915_address_space *vm;
+ 	u64 flags;
+ 
+ 	/*
+ 	 * PPGTT backed shadow buffers must be mapped RO, to prevent
+ 	 * post-scan tampering
+ 	 */
+ 	if (CMDPARSER_USES_GGTT(dev_priv)) {
+ 		flags = PIN_GLOBAL;
+ 		vm = &dev_priv->ggtt.vm;
+ 		eb->batch_flags |= I915_DISPATCH_SECURE;
+ 	} else if (vma->vm->has_read_only) {
+ 		flags = PIN_USER;
+ 		vm = vma->vm;
+ 		i915_gem_object_set_readonly(obj);
+ 	} else {
+ 		DRM_DEBUG("Cannot prevent post-scan tampering without RO capable vm\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	return i915_gem_object_pin(obj, vm, NULL, 0, 0, flags);
+ }
+ 
  static struct i915_vma *eb_parse(struct i915_execbuffer *eb)
  {
 -	struct intel_engine_pool_node *pool;
 +	struct drm_i915_gem_object *shadow_batch_obj;
  	struct i915_vma *vma;
  	int err;
  
@@@ -1998,12 -2011,12 +2033,16 @@@
  			vma = NULL;
  		else
  			vma = ERR_PTR(err);
 -		goto err;
 +		goto out;
  	}
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/i915_gem_execbuffer.c
 +	vma = i915_gem_object_ggtt_pin(shadow_batch_obj, NULL, 0, 0, 0);
++=======
+ 	vma = shadow_batch_pin(eb, pool->obj);
++>>>>>>> 4f7af1948abc (drm/i915: Support ro ppgtt mapped cmdparser shadow buffers):drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
  	if (IS_ERR(vma))
 -		goto err;
 +		goto out;
  
  	eb->vma[eb->buffer_count] = i915_vma_get(vma);
  	eb->flags[eb->buffer_count] =
@@@ -2011,8 -2024,15 +2050,20 @@@
  	vma->exec_flags = &eb->flags[eb->buffer_count];
  	eb->buffer_count++;
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/i915_gem_execbuffer.c
 +out:
 +	i915_gem_object_unpin_pages(shadow_batch_obj);
++=======
+ 	eb->batch_start_offset = 0;
+ 	eb->batch = vma;
+ 	/* eb->batch_len unchanged */
+ 
+ 	vma->private = pool;
+ 	return vma;
+ 
+ err:
+ 	intel_engine_pool_put(pool);
++>>>>>>> 4f7af1948abc (drm/i915: Support ro ppgtt mapped cmdparser shadow buffers):drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
  	return vma;
  }
  
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 2a3ce817328c..1390805e5641 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -2461,6 +2461,12 @@ static inline unsigned int i915_sg_segment_size(void)
 #define HAS_BLT(dev_priv)	HAS_ENGINE(dev_priv, BCS)
 #define HAS_VEBOX(dev_priv)	HAS_ENGINE(dev_priv, VECS)
 
+/*
+ * The Gen7 cmdparser copies the scanned buffer to the ggtt for execution
+ * All later gens can run the final buffer from the ppgtt
+ */
+#define CMDPARSER_USES_GGTT(dev_priv) IS_GEN(dev_priv, 7)
+
 #define HAS_LLC(dev_priv)	(INTEL_INFO(dev_priv)->has_llc)
 #define HAS_SNOOP(dev_priv)	(INTEL_INFO(dev_priv)->has_snoop)
 #define HAS_EDRAM(dev_priv)	(!!((dev_priv)->edram_cap & EDRAM_ENABLED))
@@ -2875,6 +2881,14 @@ i915_gem_object_ggtt_pin(struct drm_i915_gem_object *obj,
 int i915_gem_object_unbind(struct drm_i915_gem_object *obj);
 void i915_gem_release_mmap(struct drm_i915_gem_object *obj);
 
+struct i915_vma * __must_check
+i915_gem_object_pin(struct drm_i915_gem_object *obj,
+		    struct i915_address_space *vm,
+		    const struct i915_ggtt_view *view,
+		    u64 size,
+		    u64 alignment,
+		    u64 flags);
+
 void i915_gem_runtime_suspend(struct drm_i915_private *dev_priv);
 
 static inline int __sg_page_count(const struct scatterlist *sg)
* Unmerged path drivers/gpu/drm/i915/i915_gem.c
* Unmerged path drivers/gpu/drm/i915/i915_gem_execbuffer.c
