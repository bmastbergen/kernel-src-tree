s390/qeth: streamline SNMP cmd code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit d4c08afafa0469a24771b14528ee179f72861ea3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d4c08afa.failed

Apply some cleanups to qeth_snmp_command() and its callback:
1. when accessing the user data, use the proper struct instead of
   hard-coded offsets. Also copy the request data straight into the
   allocated cmd, skipping the extra memdup_user() to a tmp buffer.
2. capping the request length is no longer needed, the same check gets
   applied at a base level in qeth_alloc_cmd().
3. clean up some duplicated (and misindented) trace statements.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4c08afafa0469a24771b14528ee179f72861ea3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index e8cac443e3b9,efb9a27b916e..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4516,38 -4350,28 +4510,54 @@@ static int qeth_snmp_command(struct qet
  	    IS_LAYER3(card))
  		return -EOPNOTSUPP;
  
- 	/* skip 4 bytes (data_len struct member) to get req_len */
- 	if (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))
+ 	ureq = (struct qeth_snmp_ureq __user *) udata;
+ 	if (get_user(qinfo.udata_len, &ureq->hdr.data_len) ||
+ 	    get_user(req_len, &ureq->hdr.req_len))
  		return -EFAULT;
+ 
+ 	iob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL, req_len);
+ 	if (!iob)
+ 		return -ENOMEM;
+ 
+ 	if (copy_from_user(&__ipa_cmd(iob)->data.setadapterparms.data.snmp,
+ 			   &ureq->cmd, req_len)) {
+ 		qeth_put_cmd(iob);
+ 		return -EFAULT;
++<<<<<<< HEAD
 +	if (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -
 +		       sizeof(struct qeth_ipacmd_hdr) -
 +		       sizeof(struct qeth_ipacmd_setadpparms_hdr)))
 +		return -EINVAL;
 +	ureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));
 +	if (IS_ERR(ureq)) {
 +		QETH_CARD_TEXT(card, 2, "snmpnome");
 +		return PTR_ERR(ureq);
++=======
++>>>>>>> d4c08afafa04 (s390/qeth: streamline SNMP cmd code)
  	}
- 	qinfo.udata_len = ureq->hdr.data_len;
+ 
  	qinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);
  	if (!qinfo.udata) {
- 		kfree(ureq);
+ 		qeth_put_cmd(iob);
  		return -ENOMEM;
  	}
  	qinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);
  
++<<<<<<< HEAD
 +	iob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,
 +				   QETH_SNMP_SETADP_CMDLENGTH + req_len);
 +	if (!iob) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* for large requests, fix-up the length fields: */
 +	qeth_prepare_ipa_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len);
 +
 +	cmd = __ipa_cmd(iob);
 +	memcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);
++=======
++>>>>>>> d4c08afafa04 (s390/qeth: streamline SNMP cmd code)
  	rc = qeth_send_ipa_cmd(card, iob, qeth_snmp_command_cb, &qinfo);
  	if (rc)
  		QETH_DBF_MESSAGE(2, "SNMP command failed on device %x: (%#x)\n",
* Unmerged path drivers/s390/net/qeth_core_main.c
