memremap: move dev_pagemap callbacks into a separate structure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 1e240e8d4a7d92232b6214e02a0a4197a53afd6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/1e240e8d.failed

The dev_pagemap is a growing too many callbacks.  Move them into a
separate ops structure so that they are not duplicated for multiple
instances, and an attacker can't easily overwrite them.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Logan Gunthorpe <logang@deltatee.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Tested-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 1e240e8d4a7d92232b6214e02a0a4197a53afd6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/device.c
#	drivers/nvdimm/pmem.c
#	drivers/pci/p2pdma.c
#	include/linux/memremap.h
#	kernel/memremap.c
#	mm/hmm.c
#	tools/testing/nvdimm/test/iomap.c
diff --cc drivers/dax/device.c
index e428468ab661,f390083a64d7..000000000000
--- a/drivers/dax/device.c
+++ b/drivers/dax/device.c
@@@ -468,18 -469,12 +472,23 @@@ int dev_dax_probe(struct device *dev
  	if (rc)
  		return rc;
  
 +	rc = devm_add_action_or_reset(dev, dev_dax_percpu_exit, &dev_dax->ref);
 +	if (rc)
 +		return rc;
 +
  	dev_dax->pgmap.ref = &dev_dax->ref;
++<<<<<<< HEAD
 +	dev_dax->pgmap.kill = dev_dax_percpu_kill;
++=======
+ 	dev_dax->pgmap.type = MEMORY_DEVICE_DEVDAX;
+ 	dev_dax->pgmap.ops = &dev_dax_pagemap_ops;
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  	addr = devm_memremap_pages(dev, &dev_dax->pgmap);
 -	if (IS_ERR(addr))
 +	if (IS_ERR(addr)) {
 +		devm_remove_action(dev, dev_dax_percpu_exit, &dev_dax->ref);
 +		percpu_ref_exit(&dev_dax->ref);
  		return PTR_ERR(addr);
 +	}
  
  	inode = dax_inode(dax_dev);
  	cdev = inode->i_cdev;
diff --cc drivers/nvdimm/pmem.c
index d9d845077b8b,c2449af2b388..000000000000
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@@ -311,12 -303,20 +311,25 @@@ static const struct attribute_group *pm
  	NULL,
  };
  
++<<<<<<< HEAD
 +static void pmem_release_queue(void *q)
++=======
+ static void pmem_pagemap_cleanup(struct percpu_ref *ref)
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  {
 -	struct request_queue *q;
 -
 -	q = container_of(ref, typeof(*q), q_usage_counter);
  	blk_cleanup_queue(q);
  }
  
++<<<<<<< HEAD
 +static void pmem_freeze_queue(struct percpu_ref *ref)
++=======
+ static void pmem_release_queue(void *ref)
+ {
+ 	pmem_pagemap_cleanup(ref);
+ }
+ 
+ static void pmem_pagemap_kill(struct percpu_ref *ref)
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  {
  	struct request_queue *q;
  
@@@ -407,12 -412,8 +425,15 @@@ static int pmem_attach_disk(struct devi
  	if (!q)
  		return -ENOMEM;
  
 +	if (devm_add_action_or_reset(dev, pmem_release_queue, q))
 +		return -ENOMEM;
 +
  	pmem->pfn_flags = PFN_DEV;
  	pmem->pgmap.ref = &q->q_usage_counter;
++<<<<<<< HEAD
 +	pmem->pgmap.kill = pmem_freeze_queue;
++=======
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  	if (is_nd_pfn(dev)) {
  		if (setup_pagemap_fsdax(dev, &pmem->pgmap))
  			return -ENOMEM;
diff --cc drivers/pci/p2pdma.c
index 9d5953e3f11b,fb039259d463..000000000000
--- a/drivers/pci/p2pdma.c
+++ b/drivers/pci/p2pdma.c
@@@ -218,7 -213,7 +223,11 @@@ int pci_p2pdma_add_resource(struct pci_
  	pgmap->type = MEMORY_DEVICE_PCI_P2PDMA;
  	pgmap->pci_p2pdma_bus_offset = pci_bus_address(pdev, bar) -
  		pci_resource_start(pdev, bar);
++<<<<<<< HEAD
 +	pgmap->kill = pci_p2pdma_percpu_kill;
++=======
+ 	pgmap->ops = &pci_p2pdma_pagemap_ops;
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  
  	addr = devm_memremap_pages(&pdev->dev, pgmap);
  	if (IS_ERR(addr)) {
diff --cc include/linux/memremap.h
index ae6713454b27,919755f48c7e..000000000000
--- a/include/linux/memremap.h
+++ b/include/linux/memremap.h
@@@ -66,60 -62,37 +66,91 @@@ enum memory_type 
  	MEMORY_DEVICE_PCI_P2PDMA,
  };
  
++<<<<<<< HEAD
 +/*
 + * For MEMORY_DEVICE_PRIVATE we use ZONE_DEVICE and extend it with two
 + * callbacks:
 + *   page_fault()
 + *   page_free()
 + *
 + * Additional notes about MEMORY_DEVICE_PRIVATE may be found in
 + * include/linux/hmm.h and Documentation/vm/hmm.rst. There is also a brief
 + * explanation in include/linux/memory_hotplug.h.
 + *
 + * The page_fault() callback must migrate page back, from device memory to
 + * system memory, so that the CPU can access it. This might fail for various
 + * reasons (device issues,  device have been unplugged, ...). When such error
 + * conditions happen, the page_fault() callback must return VM_FAULT_SIGBUS and
 + * set the CPU page table entry to "poisoned".
 + *
 + * Note that because memory cgroup charges are transferred to the device memory,
 + * this should never fail due to memory restrictions. However, allocation
 + * of a regular system page might still fail because we are out of memory. If
 + * that happens, the page_fault() callback must return VM_FAULT_OOM.
 + *
 + * The page_fault() callback can also try to migrate back multiple pages in one
 + * chunk, as an optimization. It must, however, prioritize the faulting address
 + * over all the others.
 + *
 + *
 + * The page_free() callback is called once the page refcount reaches 1
 + * (ZONE_DEVICE pages never reach 0 refcount unless there is a refcount bug.
 + * This allows the device driver to implement its own memory management.)
 + *
 + * For MEMORY_DEVICE_PUBLIC only the page_free() callback matter.
 + */
 +typedef int (*dev_page_fault_t)(struct vm_area_struct *vma,
 +				unsigned long addr,
 +				const struct page *page,
 +				unsigned int flags,
 +				pmd_t *pmdp);
 +typedef void (*dev_page_free_t)(struct page *page, void *data);
 +
 +/**
 + * struct dev_pagemap - metadata for ZONE_DEVICE mappings
 + * @page_fault: callback when CPU fault on an unaddressable device page
 + * @page_free: free page callback when page refcount reaches 1
 + * @altmap: pre-allocated/reserved memory for vmemmap allocations
 + * @res: physical address range covered by @ref
 + * @ref: reference count that pins the devm_memremap_pages() mapping
 + * @kill: callback to transition @ref to the dead state
++=======
+ struct dev_pagemap_ops {
+ 	/*
+ 	 * Called once the page refcount reaches 1.  (ZONE_DEVICE pages never
+ 	 * reach 0 refcount unless there is a refcount bug. This allows the
+ 	 * device driver to implement its own memory management.)
+ 	 */
+ 	void (*page_free)(struct page *page, void *data);
+ 
+ 	/*
+ 	 * Transition the refcount in struct dev_pagemap to the dead state.
+ 	 */
+ 	void (*kill)(struct percpu_ref *ref);
+ 
+ 	/*
+ 	 * Wait for refcount in struct dev_pagemap to be idle and reap it.
+ 	 */
+ 	void (*cleanup)(struct percpu_ref *ref);
+ };
+ 
+ /**
+  * struct dev_pagemap - metadata for ZONE_DEVICE mappings
+  * @altmap: pre-allocated/reserved memory for vmemmap allocations
+  * @res: physical address range covered by @ref
+  * @ref: reference count that pins the devm_memremap_pages() mapping
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
   * @dev: host device of the mapping for debug
   * @data: private data pointer for page_free()
   * @type: memory type: see MEMORY_* in memory_hotplug.h
+  * @ops: method table
   */
  struct dev_pagemap {
++<<<<<<< HEAD
 +	dev_page_fault_t page_fault;
 +	dev_page_free_t page_free;
++=======
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  	struct vmem_altmap altmap;
  	bool altmap_valid;
  	struct resource res;
@@@ -128,7 -101,7 +159,11 @@@
  	void *data;
  	enum memory_type type;
  	u64 pci_p2pdma_bus_offset;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(void (*kill)(struct percpu_ref *ref))
++=======
+ 	const struct dev_pagemap_ops *ops;
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  };
  
  #ifdef CONFIG_ZONE_DEVICE
diff --cc kernel/memremap.c
index 794888559eb7,0824237ef979..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -122,9 -92,10 +122,13 @@@ static void devm_memremap_pages_release
  	unsigned long pfn;
  	int nid;
  
- 	pgmap->kill(pgmap->ref);
+ 	pgmap->ops->kill(pgmap->ref);
  	for_each_device_pfn(pfn, pgmap)
  		put_page(pfn_to_page(pfn));
++<<<<<<< HEAD
++=======
+ 	pgmap->ops->cleanup(pgmap->ref);
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  
  	/* pages are dead and unused, undo the arch mapping */
  	align_start = res->start & ~(SECTION_SIZE - 1);
@@@ -177,12 -148,42 +181,40 @@@ void *devm_memremap_pages(struct devic
  			&pgmap->altmap : NULL;
  	struct resource *res = &pgmap->res;
  	struct dev_pagemap *conflict_pgmap;
 -	struct mhp_restrictions restrictions = {
 -		/*
 -		 * We do not want any optional features only our own memmap
 -		*/
 -		.altmap = altmap,
 -	};
  	pgprot_t pgprot = PAGE_KERNEL;
 +	unsigned long pgoff, order;
  	int error, nid, is_ram;
  
++<<<<<<< HEAD
 +	if (!pgmap->ref || !pgmap->kill)
++=======
+ 	switch (pgmap->type) {
+ 	case MEMORY_DEVICE_PRIVATE:
+ 		if (!IS_ENABLED(CONFIG_DEVICE_PRIVATE)) {
+ 			WARN(1, "Device private memory not supported\n");
+ 			return ERR_PTR(-EINVAL);
+ 		}
+ 		break;
+ 	case MEMORY_DEVICE_FS_DAX:
+ 		if (!IS_ENABLED(CONFIG_ZONE_DEVICE) ||
+ 		    IS_ENABLED(CONFIG_FS_DAX_LIMITED)) {
+ 			WARN(1, "File system DAX not supported\n");
+ 			return ERR_PTR(-EINVAL);
+ 		}
+ 		break;
+ 	case MEMORY_DEVICE_DEVDAX:
+ 	case MEMORY_DEVICE_PCI_P2PDMA:
+ 		break;
+ 	default:
+ 		WARN(1, "Invalid pgmap type %d\n", pgmap->type);
+ 		break;
+ 	}
+ 
+ 	if (!pgmap->ref || !pgmap->ops || !pgmap->ops->kill ||
+ 	    !pgmap->ops->cleanup) {
+ 		WARN(1, "Missing reference count teardown definition\n");
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  		return ERR_PTR(-EINVAL);
 -	}
  
  	align_start = res->start & ~(SECTION_SIZE - 1);
  	align_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)
@@@ -299,10 -292,10 +331,17 @@@
   err_kasan:
  	untrack_pfn(NULL, PHYS_PFN(align_start), align_size);
   err_pfn_remap:
++<<<<<<< HEAD
 + err_radix:
 +	pgmap_radix_release(res, pgoff);
 + err_pgmap:
 +	pgmap->kill(pgmap->ref);
++=======
+ 	pgmap_array_delete(res);
+  err_array:
+ 	pgmap->ops->kill(pgmap->ref);
+ 	pgmap->ops->cleanup(pgmap->ref);
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  	return ERR_PTR(error);
  }
  EXPORT_SYMBOL_GPL(devm_memremap_pages);
diff --cc mm/hmm.c
index 91b885757871,583a02a16872..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -1081,12 -1443,11 +1087,19 @@@ struct hmm_devmem *hmm_devmem_add(cons
  
  	devmem->pagemap.type = MEMORY_DEVICE_PRIVATE;
  	devmem->pagemap.res = *devmem->resource;
++<<<<<<< HEAD
 +	devmem->pagemap.page_fault = hmm_devmem_fault;
 +	devmem->pagemap.page_free = hmm_devmem_free;
 +	devmem->pagemap.altmap_valid = false;
 +	devmem->pagemap.ref = &devmem->ref;
 +	devmem->pagemap.data = devmem;
 +	devmem->pagemap.kill = hmm_devmem_ref_kill;
++=======
+ 	devmem->pagemap.ops = &hmm_pagemap_ops;
+ 	devmem->pagemap.altmap_valid = false;
+ 	devmem->pagemap.ref = &devmem->ref;
+ 	devmem->pagemap.data = devmem;
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  
  	result = devm_memremap_pages(devmem->device, &devmem->pagemap);
  	if (IS_ERR(result))
diff --cc tools/testing/nvdimm/test/iomap.c
index 280015c22598,cf3f064a697d..000000000000
--- a/tools/testing/nvdimm/test/iomap.c
+++ b/tools/testing/nvdimm/test/iomap.c
@@@ -100,7 -100,10 +100,14 @@@ static void nfit_test_kill(void *_pgmap
  {
  	struct dev_pagemap *pgmap = _pgmap;
  
++<<<<<<< HEAD
 +	pgmap->kill(pgmap->ref);
++=======
+ 	WARN_ON(!pgmap || !pgmap->ref || !pgmap->ops || !pgmap->ops->kill ||
+ 		!pgmap->ops->cleanup);
+ 	pgmap->ops->kill(pgmap->ref);
+ 	pgmap->ops->cleanup(pgmap->ref);
++>>>>>>> 1e240e8d4a7d (memremap: move dev_pagemap callbacks into a separate structure)
  }
  
  void *__wrap_devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)
* Unmerged path drivers/dax/device.c
diff --git a/drivers/dax/pmem/core.c b/drivers/dax/pmem/core.c
index bdcff1b14e95..9df89601539c 100644
--- a/drivers/dax/pmem/core.c
+++ b/drivers/dax/pmem/core.c
@@ -16,7 +16,7 @@ struct dev_dax *__dax_pmem_probe(struct device *dev, enum dev_dax_subsys subsys)
 	struct dev_dax *dev_dax;
 	struct nd_namespace_io *nsio;
 	struct dax_region *dax_region;
-	struct dev_pagemap pgmap = { 0 };
+	struct dev_pagemap pgmap = { };
 	struct nd_namespace_common *ndns;
 	struct nd_dax *nd_dax = to_nd_dax(dev);
 	struct nd_pfn *nd_pfn = &nd_dax->nd_pfn;
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path drivers/pci/p2pdma.c
* Unmerged path include/linux/memremap.h
* Unmerged path kernel/memremap.c
* Unmerged path mm/hmm.c
* Unmerged path tools/testing/nvdimm/test/iomap.c
