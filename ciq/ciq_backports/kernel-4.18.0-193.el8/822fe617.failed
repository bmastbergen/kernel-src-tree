net/flow_dissector: pass flow_keys->n_proto to BPF programs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit 822fe61795018265ae14731d4e5399e5bde36864
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/822fe617.failed

This is a preparation for the next commit that would prohibit access to
the most fields of __sk_buff from the BPF programs.

Instead of requiring BPF flow dissector programs to look into skb,
pass all input data in the flow_keys.

	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 822fe61795018265ae14731d4e5399e5bde36864)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
#	tools/testing/selftests/bpf/bpf_flow.c
diff --cc net/core/flow_dissector.c
index ea22c4441222,9b84250039df..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -683,6 -683,47 +683,50 @@@ static void __skb_flow_bpf_to_target(co
  	}
  }
  
++<<<<<<< HEAD
++=======
+ bool __skb_flow_bpf_dissect(struct bpf_prog *prog,
+ 			    const struct sk_buff *skb,
+ 			    struct flow_dissector *flow_dissector,
+ 			    struct bpf_flow_keys *flow_keys)
+ {
+ 	struct bpf_skb_data_end cb_saved;
+ 	struct bpf_skb_data_end *cb;
+ 	u32 result;
+ 
+ 	/* Note that even though the const qualifier is discarded
+ 	 * throughout the execution of the BPF program, all changes(the
+ 	 * control block) are reverted after the BPF program returns.
+ 	 * Therefore, __skb_flow_dissect does not alter the skb.
+ 	 */
+ 
+ 	cb = (struct bpf_skb_data_end *)skb->cb;
+ 
+ 	/* Save Control Block */
+ 	memcpy(&cb_saved, cb, sizeof(cb_saved));
+ 	memset(cb, 0, sizeof(*cb));
+ 
+ 	/* Pass parameters to the BPF program */
+ 	memset(flow_keys, 0, sizeof(*flow_keys));
+ 	cb->qdisc_cb.flow_keys = flow_keys;
+ 	flow_keys->n_proto = skb->protocol;
+ 	flow_keys->nhoff = skb_network_offset(skb);
+ 	flow_keys->thoff = flow_keys->nhoff;
+ 
+ 	bpf_compute_data_pointers((struct sk_buff *)skb);
+ 	result = BPF_PROG_RUN(prog, skb);
+ 
+ 	/* Restore state */
+ 	memcpy(cb, &cb_saved, sizeof(cb_saved));
+ 
+ 	flow_keys->nhoff = clamp_t(u16, flow_keys->nhoff, 0, skb->len);
+ 	flow_keys->thoff = clamp_t(u16, flow_keys->thoff,
+ 				   flow_keys->nhoff, skb->len);
+ 
+ 	return result == BPF_OK;
+ }
+ 
++>>>>>>> 822fe6179501 (net/flow_dissector: pass flow_keys->n_proto to BPF programs)
  /**
   * __skb_flow_dissect - extract the flow_keys struct and return it
   * @skb: sk_buff to extract the flow from, can be NULL if the rest are specified
diff --cc tools/testing/selftests/bpf/bpf_flow.c
index 284660f5aa95,75b17cada539..000000000000
--- a/tools/testing/selftests/bpf/bpf_flow.c
+++ b/tools/testing/selftests/bpf/bpf_flow.c
@@@ -119,10 -118,9 +118,16 @@@ static __always_inline int parse_eth_pr
  SEC("flow_dissector")
  int _dissect(struct __sk_buff *skb)
  {
++<<<<<<< HEAD:tools/testing/selftests/bpf/bpf_flow.c
 +	if (!skb->vlan_present)
 +		return parse_eth_proto(skb, skb->protocol);
 +	else
 +		return parse_eth_proto(skb, skb->vlan_proto);
++=======
+ 	struct bpf_flow_keys *keys = skb->flow_keys;
+ 
+ 	return parse_eth_proto(skb, keys->n_proto);
++>>>>>>> 822fe6179501 (net/flow_dissector: pass flow_keys->n_proto to BPF programs):tools/testing/selftests/bpf/progs/bpf_flow.c
  }
  
  /* Parses on IPPROTO_* */
* Unmerged path net/core/flow_dissector.c
* Unmerged path tools/testing/selftests/bpf/bpf_flow.c
