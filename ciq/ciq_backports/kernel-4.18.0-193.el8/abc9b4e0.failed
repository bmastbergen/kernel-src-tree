tipc: fix retrans failure due to wrong destination

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Tuong Lien <tuong.t.lien@dektech.com.au>
commit abc9b4e0549b93fdaff56e9532bc49a2d7b04955
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/abc9b4e0.failed

When a user message is sent, TIPC will check if the socket has faced a
congestion at link layer. If that happens, it will make a sleep to wait
for the congestion to disappear. This leaves a gap for other users to
take over the socket (e.g. multi threads) since the socket is released
as well. Also, in case of connectionless (e.g. SOCK_RDM), user is free
to send messages to various destinations (e.g. via 'sendto()'), then
the socket's preformatted header has to be updated correspondingly
prior to the actual payload message building.

Unfortunately, the latter action is done before the first action which
causes a condition issue that the destination of a certain message can
be modified incorrectly in the middle, leading to wrong destination
when that message is built. Consequently, when the message is sent to
the link layer, it gets stuck there forever because the peer node will
simply reject it. After a number of retransmission attempts, the link
is eventually taken down and the retransmission failure is reported.

This commit fixes the problem by rearranging the order of actions to
prevent the race condition from occurring, so the message building is
'atomic' and its header will not be modified by anyone.

Fixes: 365ad353c256 ("tipc: reduce risk of user starvation during link congestion")
	Acked-by: Jon Maloy <jon.maloy@ericsson.com>
	Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit abc9b4e0549b93fdaff56e9532bc49a2d7b04955)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/socket.c
diff --cc net/tipc/socket.c
index ed3c2a7d341e,6552f986774c..000000000000
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@@ -1387,8 -1433,24 +1375,29 @@@ static int __tipc_sendmsg(struct socke
  	if (unlikely(rc))
  		return rc;
  
++<<<<<<< HEAD
 +	skb_queue_head_init(&pkts);
 +	mtu = tipc_node_get_mtu(net, dnode, tsk->portid);
++=======
+ 	if (dest->addrtype == TIPC_ADDR_NAME) {
+ 		msg_set_type(hdr, TIPC_NAMED_MSG);
+ 		msg_set_hdr_sz(hdr, NAMED_H_SIZE);
+ 		msg_set_nametype(hdr, type);
+ 		msg_set_nameinst(hdr, inst);
+ 		msg_set_lookup_scope(hdr, tipc_node2scope(dnode));
+ 		msg_set_destnode(hdr, dnode);
+ 		msg_set_destport(hdr, dport);
+ 	} else { /* TIPC_ADDR_ID */
+ 		msg_set_type(hdr, TIPC_DIRECT_MSG);
+ 		msg_set_lookup_scope(hdr, 0);
+ 		msg_set_destnode(hdr, dnode);
+ 		msg_set_destport(hdr, dest->addr.id.ref);
+ 		msg_set_hdr_sz(hdr, BASIC_H_SIZE);
+ 	}
+ 
+ 	__skb_queue_head_init(&pkts);
+ 	mtu = tipc_node_get_mtu(net, dnode, tsk->portid, false);
++>>>>>>> abc9b4e0549b (tipc: fix retrans failure due to wrong destination)
  	rc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);
  	if (unlikely(rc != dlen))
  		return rc;
* Unmerged path net/tipc/socket.c
