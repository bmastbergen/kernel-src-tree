ibmvnic: Serialize device queries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Thomas Falcon <tlfalcon@linux.ibm.com>
commit ff25dcb9a1492ecbe495de936765c7ff3441b601
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/ff25dcb9.failed

Provide some serialization for device CRQ commands
and queries to ensure that the shared variable used for
storing return codes is properly synchronized.

	Signed-off-by: Thomas Falcon <tlfalcon@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ff25dcb9a1492ecbe495de936765c7ff3441b601)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 0e273a551d9e,c90080781924..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -221,7 -210,9 +221,13 @@@ static int alloc_long_term_buff(struct 
  	ltb->map_id = adapter->map_id;
  	adapter->map_id++;
  
++<<<<<<< HEAD
 +	init_completion(&adapter->fw_done);
++=======
+ 	mutex_lock(&adapter->fw_lock);
+ 	adapter->fw_done_rc = 0;
+ 	reinit_completion(&adapter->fw_done);
++>>>>>>> ff25dcb9a149 (ibmvnic: Serialize device queries)
  	rc = send_request_map(adapter, ltb->addr,
  			      ltb->size, ltb->map_id);
  	if (rc) {
@@@ -269,10 -264,15 +279,19 @@@ static int reset_long_term_buff(struct 
  
  	memset(ltb->buff, 0, ltb->size);
  
++<<<<<<< HEAD
 +	init_completion(&adapter->fw_done);
++=======
+ 	mutex_lock(&adapter->fw_lock);
+ 	adapter->fw_done_rc = 0;
+ 
+ 	reinit_completion(&adapter->fw_done);
++>>>>>>> ff25dcb9a149 (ibmvnic: Serialize device queries)
  	rc = send_request_map(adapter, ltb->addr, ltb->size, ltb->map_id);
- 	if (rc)
+ 	if (rc) {
+ 		mutex_unlock(&adapter->fw_lock);
  		return rc;
+ 	}
  
  	rc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);
  	if (rc) {
@@@ -1006,7 -1006,10 +1028,14 @@@ static int ibmvnic_get_vpd(struct ibmvn
  	if (adapter->vpd->buff)
  		len = adapter->vpd->len;
  
++<<<<<<< HEAD
 +	init_completion(&adapter->fw_done);
++=======
+ 	mutex_lock(&adapter->fw_lock);
+ 	adapter->fw_done_rc = 0;
+ 	reinit_completion(&adapter->fw_done);
+ 
++>>>>>>> ff25dcb9a149 (ibmvnic: Serialize device queries)
  	crq.get_vpd_size.first = IBMVNIC_CRQ_CMD;
  	crq.get_vpd_size.cmd = GET_VPD_SIZE;
  	rc = ibmvnic_send_crq(adapter, &crq);
@@@ -1764,7 -1777,10 +1803,14 @@@ static int __ibmvnic_set_mac(struct net
  	crq.change_mac_addr.cmd = CHANGE_MAC_ADDR;
  	ether_addr_copy(&crq.change_mac_addr.mac_addr[0], dev_addr);
  
++<<<<<<< HEAD
 +	init_completion(&adapter->fw_done);
++=======
+ 	mutex_lock(&adapter->fw_lock);
+ 	adapter->fw_done_rc = 0;
+ 	reinit_completion(&adapter->fw_done);
+ 
++>>>>>>> ff25dcb9a149 (ibmvnic: Serialize device queries)
  	rc = ibmvnic_send_crq(adapter, &crq);
  	if (rc) {
  		rc = -EIO;
@@@ -4396,15 -4518,24 +4444,28 @@@ static int send_query_phys_parms(struc
  	memset(&crq, 0, sizeof(crq));
  	crq.query_phys_parms.first = IBMVNIC_CRQ_CMD;
  	crq.query_phys_parms.cmd = QUERY_PHYS_PARMS;
++<<<<<<< HEAD
 +	init_completion(&adapter->fw_done);
++=======
+ 
+ 	mutex_lock(&adapter->fw_lock);
+ 	adapter->fw_done_rc = 0;
+ 	reinit_completion(&adapter->fw_done);
+ 
++>>>>>>> ff25dcb9a149 (ibmvnic: Serialize device queries)
  	rc = ibmvnic_send_crq(adapter, &crq);
- 	if (rc)
+ 	if (rc) {
+ 		mutex_unlock(&adapter->fw_lock);
  		return rc;
+ 	}
  
  	rc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);
- 	if (rc)
+ 	if (rc) {
+ 		mutex_unlock(&adapter->fw_lock);
  		return rc;
+ 	}
  
+ 	mutex_unlock(&adapter->fw_lock);
  	return adapter->fw_done_rc ? -EIO : 0;
  }
  
@@@ -4947,10 -5087,16 +5008,11 @@@ static int ibmvnic_probe(struct vio_de
  	spin_lock_init(&adapter->stats_lock);
  
  	INIT_WORK(&adapter->ibmvnic_reset, __ibmvnic_reset);
 -	INIT_DELAYED_WORK(&adapter->ibmvnic_delayed_reset,
 -			  __ibmvnic_delayed_reset);
  	INIT_LIST_HEAD(&adapter->rwi_list);
  	spin_lock_init(&adapter->rwi_lock);
+ 	mutex_init(&adapter->fw_lock);
  	init_completion(&adapter->init_done);
 -	init_completion(&adapter->fw_done);
 -	init_completion(&adapter->reset_done);
 -	init_completion(&adapter->stats_done);
 -	clear_bit(0, &adapter->resetting);
 +	adapter->resetting = false;
  
  	do {
  		rc = init_crq_queue(adapter);
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
diff --git a/drivers/net/ethernet/ibm/ibmvnic.h b/drivers/net/ethernet/ibm/ibmvnic.h
index dcf2eb6d9290..1d112b354b6b 100644
--- a/drivers/net/ethernet/ibm/ibmvnic.h
+++ b/drivers/net/ethernet/ibm/ibmvnic.h
@@ -1034,6 +1034,8 @@ struct ibmvnic_adapter {
 	int init_done_rc;
 
 	struct completion fw_done;
+	/* Used for serialization of device commands */
+	struct mutex fw_lock;
 	int fw_done_rc;
 
 	struct completion reset_done;
