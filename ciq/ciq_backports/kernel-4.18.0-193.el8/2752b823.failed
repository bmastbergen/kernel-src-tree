net/mlx5: Introduce and use mlx5_eswitch_get_total_vports()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Introduce and use mlx5_eswitch_get_total_vports() (Alaa Hleihel) [1724327 1724336]
Rebuild_FUZZ: 96.49%
commit-author Parav Pandit <parav@mellanox.com>
commit 2752b823169b216db142c4466b43269281962dcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/2752b823.failed

Instead MLX5_TOTAL_VPORTS, use mlx5_eswitch_get_total_vports().
mlx5_eswitch_get_total_vports() in subsequent patch accounts for SF
vports as well.
Expanding MLX5_TOTAL_VPORTS macro would require exposing SF internals to
more generic vport.h header file. Such exposure is not desired.
Hence a mlx5_eswitch_get_total_vports() is introduced.

Given that mlx5_eswitch_get_total_vports() API wants to work on const
mlx5_core_dev*, change its helper functions also to accept const *dev.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 2752b823169b216db142c4466b43269281962dcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/ib_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	include/linux/mlx5/driver.h
#	include/linux/mlx5/vport.h
diff --cc drivers/infiniband/hw/mlx5/ib_rep.c
index 95ac97af6166,f2cb789d2331..000000000000
--- a/drivers/infiniband/hw/mlx5/ib_rep.c
+++ b/drivers/infiniband/hw/mlx5/ib_rep.c
@@@ -68,7 -29,15 +68,12 @@@ mlx5_ib_nic_rep_unload(struct mlx5_eswi
  static int
  mlx5_ib_vport_rep_load(struct mlx5_core_dev *dev, struct mlx5_eswitch_rep *rep)
  {
++<<<<<<< HEAD
++=======
+ 	int num_ports = mlx5_eswitch_get_total_vports(dev);
+ 	const struct mlx5_ib_profile *profile;
++>>>>>>> 2752b823169b (net/mlx5: Introduce and use mlx5_eswitch_get_total_vports())
  	struct mlx5_ib_dev *ibdev;
 -	int vport_index;
 -
 -	if (rep->vport == MLX5_VPORT_UPLINK)
 -		profile = &uplink_rep_profile;
 -	else
 -		return mlx5_ib_set_vport_rep(dev, rep);
  
  	ibdev = ib_alloc_device(mlx5_ib_dev, ib_dev);
  	if (!ibdev)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index f4a0b22e3987,9137a8390216..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1801,10 -1868,10 +1801,15 @@@ void mlx5_eswitch_disable_sriov(struct 
  
  int mlx5_eswitch_init(struct mlx5_core_dev *dev)
  {
- 	int total_vports = MLX5_TOTAL_VPORTS(dev);
  	struct mlx5_eswitch *esw;
++<<<<<<< HEAD
 +	int vport_num;
 +	int err;
++=======
+ 	struct mlx5_vport *vport;
+ 	int total_vports;
+ 	int err, i;
++>>>>>>> 2752b823169b (net/mlx5: Introduce and use mlx5_eswitch_get_total_vports())
  
  	if (!MLX5_VPORT_MANAGER(dev))
  		return 0;
diff --cc include/linux/mlx5/driver.h
index 3a941a23ac1e,031043341ed5..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -1075,9 -1085,9 +1075,13 @@@ enum 
  	MLX5_PCI_DEV_IS_VF		= 1 << 0,
  };
  
++<<<<<<< HEAD
 +static inline int mlx5_core_is_pf(struct mlx5_core_dev *dev)
++=======
+ static inline bool mlx5_core_is_pf(const struct mlx5_core_dev *dev)
++>>>>>>> 2752b823169b (net/mlx5: Introduce and use mlx5_eswitch_get_total_vports())
  {
 -	return dev->coredev_type == MLX5_COREDEV_PF;
 +	return !(dev->priv.pci_dev_data & MLX5_PCI_DEV_IS_VF);
  }
  
  static inline bool mlx5_core_is_ecpf(struct mlx5_core_dev *dev)
@@@ -1090,13 -1101,14 +1095,22 @@@ mlx5_core_is_ecpf_esw_manager(const str
  	return dev->caps.embedded_cpu && MLX5_CAP_GEN(dev, eswitch_manager);
  }
  
++<<<<<<< HEAD
 +#define MLX5_HOST_PF_MAX_VFS	(127u)
 +static inline u16 mlx5_core_max_vfs(struct mlx5_core_dev *dev)
++=======
+ static inline bool mlx5_ecpf_vport_exists(const struct mlx5_core_dev *dev)
+ {
+ 	return mlx5_core_is_pf(dev) && MLX5_CAP_ESW(dev, ecpf_vport_exists);
+ }
+ 
+ static inline u16 mlx5_core_max_vfs(const struct mlx5_core_dev *dev)
++>>>>>>> 2752b823169b (net/mlx5: Introduce and use mlx5_eswitch_get_total_vports())
  {
 -	return dev->priv.sriov.max_vfs;
 +	if (mlx5_core_is_ecpf_esw_manager(dev))
 +		return MLX5_HOST_PF_MAX_VFS;
 +	else
 +		return pci_sriov_get_totalvfs(dev->pdev);
  }
  
  static inline int mlx5_get_gid_table_len(u16 param)
diff --cc include/linux/mlx5/vport.h
index bf6a92201084,16060fb9b5e5..000000000000
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@@ -36,9 -36,13 +36,19 @@@
  #include <linux/mlx5/driver.h>
  #include <linux/mlx5/device.h>
  
++<<<<<<< HEAD
 +#define MLX5_VPORT_PF_PLACEHOLDER (1u)
 +#define MLX5_SPECIAL_VPORTS (MLX5_VPORT_PF_PLACEHOLDER)
 +#define MLX5_TOTAL_VPORTS(mdev) (MLX5_SPECIAL_VPORTS +	mlx5_core_max_vfs(mdev))
++=======
+ #define MLX5_VPORT_PF_PLACEHOLDER		(1u)
+ #define MLX5_VPORT_UPLINK_PLACEHOLDER		(1u)
+ #define MLX5_VPORT_ECPF_PLACEHOLDER(mdev)	(mlx5_ecpf_vport_exists(mdev))
+ 
+ #define MLX5_SPECIAL_VPORTS(mdev) (MLX5_VPORT_PF_PLACEHOLDER +		\
+ 				   MLX5_VPORT_UPLINK_PLACEHOLDER +	\
+ 				   MLX5_VPORT_ECPF_PLACEHOLDER(mdev))
++>>>>>>> 2752b823169b (net/mlx5: Introduce and use mlx5_eswitch_get_total_vports())
  
  #define MLX5_VPORT_MANAGER(mdev)					\
  	(MLX5_CAP_GEN(mdev, vport_group_manager) &&			\
* Unmerged path drivers/infiniband/hw/mlx5/ib_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 2a02050a09e7..6c06d571b769 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -1206,7 +1206,7 @@ void esw_offloads_cleanup_reps(struct mlx5_eswitch *esw)
 
 int esw_offloads_init_reps(struct mlx5_eswitch *esw)
 {
-	int total_vports = MLX5_TOTAL_VPORTS(esw->dev);
+	int total_vports = esw->total_vports;
 	struct mlx5_core_dev *dev = esw->dev;
 	struct mlx5_esw_offload *offloads;
 	struct mlx5_eswitch_rep *rep;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 585e7adcbf99..b0939a18ba2d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -2092,7 +2092,7 @@ struct mlx5_flow_namespace *mlx5_get_flow_vport_acl_namespace(struct mlx5_core_d
 {
 	struct mlx5_flow_steering *steering = dev->priv.steering;
 
-	if (!steering || vport >= MLX5_TOTAL_VPORTS(dev))
+	if (!steering || vport >= mlx5_eswitch_get_total_vports(dev))
 		return NULL;
 
 	switch (type) {
@@ -2423,7 +2423,7 @@ static void cleanup_egress_acls_root_ns(struct mlx5_core_dev *dev)
 	if (!steering->esw_egress_root_ns)
 		return;
 
-	for (i = 0; i < MLX5_TOTAL_VPORTS(dev); i++)
+	for (i = 0; i < mlx5_eswitch_get_total_vports(dev); i++)
 		cleanup_root_ns(steering->esw_egress_root_ns[i]);
 
 	kfree(steering->esw_egress_root_ns);
@@ -2438,7 +2438,7 @@ static void cleanup_ingress_acls_root_ns(struct mlx5_core_dev *dev)
 	if (!steering->esw_ingress_root_ns)
 		return;
 
-	for (i = 0; i < MLX5_TOTAL_VPORTS(dev); i++)
+	for (i = 0; i < mlx5_eswitch_get_total_vports(dev); i++)
 		cleanup_root_ns(steering->esw_ingress_root_ns[i]);
 
 	kfree(steering->esw_ingress_root_ns);
@@ -2606,16 +2606,18 @@ static int init_ingress_acl_root_ns(struct mlx5_flow_steering *steering, int vpo
 static int init_egress_acls_root_ns(struct mlx5_core_dev *dev)
 {
 	struct mlx5_flow_steering *steering = dev->priv.steering;
+	int total_vports = mlx5_eswitch_get_total_vports(dev);
 	int err;
 	int i;
 
-	steering->esw_egress_root_ns = kcalloc(MLX5_TOTAL_VPORTS(dev),
-					       sizeof(*steering->esw_egress_root_ns),
-					       GFP_KERNEL);
+	steering->esw_egress_root_ns =
+			kcalloc(total_vports,
+				sizeof(*steering->esw_egress_root_ns),
+				GFP_KERNEL);
 	if (!steering->esw_egress_root_ns)
 		return -ENOMEM;
 
-	for (i = 0; i < MLX5_TOTAL_VPORTS(dev); i++) {
+	for (i = 0; i < total_vports; i++) {
 		err = init_egress_acl_root_ns(steering, i);
 		if (err)
 			goto cleanup_root_ns;
@@ -2634,16 +2636,18 @@ static int init_egress_acls_root_ns(struct mlx5_core_dev *dev)
 static int init_ingress_acls_root_ns(struct mlx5_core_dev *dev)
 {
 	struct mlx5_flow_steering *steering = dev->priv.steering;
+	int total_vports = mlx5_eswitch_get_total_vports(dev);
 	int err;
 	int i;
 
-	steering->esw_ingress_root_ns = kcalloc(MLX5_TOTAL_VPORTS(dev),
-						sizeof(*steering->esw_ingress_root_ns),
-						GFP_KERNEL);
+	steering->esw_ingress_root_ns =
+			kcalloc(total_vports,
+				sizeof(*steering->esw_ingress_root_ns),
+				GFP_KERNEL);
 	if (!steering->esw_ingress_root_ns)
 		return -ENOMEM;
 
-	for (i = 0; i < MLX5_TOTAL_VPORTS(dev); i++) {
+	for (i = 0; i < total_vports; i++) {
 		err = init_ingress_acl_root_ns(steering, i);
 		if (err)
 			goto cleanup_root_ns;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vport.c b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 95cdc8cbcba4..47da132e2c0f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@ -34,6 +34,7 @@
 #include <linux/etherdevice.h>
 #include <linux/mlx5/driver.h>
 #include <linux/mlx5/vport.h>
+#include <linux/mlx5/eswitch.h>
 #include "mlx5_core.h"
 
 /* Mutex to hold while enabling or disabling RoCE */
@@ -1157,3 +1158,17 @@ u64 mlx5_query_nic_system_image_guid(struct mlx5_core_dev *mdev)
 	return tmp;
 }
 EXPORT_SYMBOL_GPL(mlx5_query_nic_system_image_guid);
+
+/**
+ * mlx5_eswitch_get_total_vports - Get total vports of the eswitch
+ *
+ * @dev:	Pointer to core device
+ *
+ * mlx5_eswitch_get_total_vports returns total number of vports for
+ * the eswitch.
+ */
+u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev)
+{
+	return MLX5_SPECIAL_VPORTS(dev) + mlx5_core_max_vfs(dev);
+}
+EXPORT_SYMBOL(mlx5_eswitch_get_total_vports);
* Unmerged path include/linux/mlx5/driver.h
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index 5c8be6f99f8d..90c0b98d9c78 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -59,6 +59,8 @@ struct mlx5_flow_handle *
 mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *esw,
 				    int vport, u32 sqn);
 
+u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev);
+
 #ifdef CONFIG_MLX5_ESWITCH
 enum devlink_eswitch_encap_mode
 mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev);
@@ -69,4 +71,5 @@ mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev)
 	return DEVLINK_ESWITCH_ENCAP_MODE_NONE;
 }
 #endif /* CONFIG_MLX5_ESWITCH */
+
 #endif
* Unmerged path include/linux/mlx5/vport.h
