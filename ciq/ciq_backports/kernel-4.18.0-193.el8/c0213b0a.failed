x86/alternative: Batch of patch operations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [x86] alternative: Batch of patch operations (Daniel Bristot de Oliveira) [1731860]
Rebuild_FUZZ: 95.00%
commit-author Daniel Bristot de Oliveira <bristot@redhat.com>
commit c0213b0ac03cf69f90fe5c6a8fe2c986630940fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/c0213b0a.failed

Currently, the patch of an address is done in three steps:

-- Pseudo-code #1 - Current implementation ---

        1) add an int3 trap to the address that will be patched
            sync cores (send IPI to all other CPUs)
        2) update all but the first byte of the patched range
            sync cores (send IPI to all other CPUs)
        3) replace the first byte (int3) by the first byte of replacing opcode
            sync cores (send IPI to all other CPUs)

-- Pseudo-code #1 ---

When a static key has more than one entry, these steps are called once for
each entry. The number of IPIs then is linear with regard to the number 'n' of
entries of a key: O(n*3), which is O(n).

This algorithm works fine for the update of a single key. But we think
it is possible to optimize the case in which a static key has more than
one entry. For instance, the sched_schedstats jump label has 56 entries
in my (updated) fedora kernel, resulting in 168 IPIs for each CPU in
which the thread that is enabling the key is _not_ running.

With this patch, rather than receiving a single patch to be processed, a vector
of patches is passed, enabling the rewrite of the pseudo-code #1 in this
way:

-- Pseudo-code #2 - This patch  ---
1)  for each patch in the vector:
        add an int3 trap to the address that will be patched

    sync cores (send IPI to all other CPUs)

2)  for each patch in the vector:
        update all but the first byte of the patched range

    sync cores (send IPI to all other CPUs)

3)  for each patch in the vector:
        replace the first byte (int3) by the first byte of replacing opcode

    sync cores (send IPI to all other CPUs)
-- Pseudo-code #2 - This patch  ---

Doing the update in this way, the number of IPI becomes O(3) with regard
to the number of keys, which is O(1).

The batch mode is done with the function text_poke_bp_batch(), that receives
two arguments: a vector of "struct text_to_poke", and the number of entries
in the vector.

The vector must be sorted by the addr field of the text_to_poke structure,
enabling the binary search of a handler in the poke_int3_handler function
(a fast path).

	Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Chris von Recklinghausen <crecklin@redhat.com>
	Cc: Clark Williams <williams@redhat.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Jason Baron <jbaron@akamai.com>
	Cc: Jiri Kosina <jkosina@suse.cz>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Scott Wood <swood@redhat.com>
	Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/ca506ed52584c80f64de23f6f55ca288e5d079de.1560325897.git.bristot@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c0213b0ac03cf69f90fe5c6a8fe2c986630940fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/alternative.c
diff --cc arch/x86/kernel/alternative.c
index c03f0cb0610f,bd542f9b0953..000000000000
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@@ -11,6 -12,9 +11,12 @@@
  #include <linux/stop_machine.h>
  #include <linux/slab.h>
  #include <linux/kdebug.h>
++<<<<<<< HEAD
++=======
+ #include <linux/kprobes.h>
+ #include <linux/mmu_context.h>
+ #include <linux/bsearch.h>
++>>>>>>> c0213b0ac03c (x86/alternative: Batch of patch operations)
  #include <asm/text-patching.h>
  #include <asm/alternative.h>
  #include <asm/sections.h>
@@@ -787,25 -884,43 +811,43 @@@ int poke_int3_handler(struct pt_regs *r
  	 */
  	smp_rmb();
  
- 	if (likely(!bp_patching_in_progress))
+ 	if (likely(!bp_patching.nr_entries))
  		return 0;
  
- 	if (user_mode(regs) || regs->ip != (unsigned long)bp_int3_addr)
+ 	if (user_mode(regs))
  		return 0;
  
- 	/* set up the specified breakpoint handler */
- 	regs->ip = (unsigned long) bp_int3_handler;
+ 	/*
+ 	 * Discount the sizeof(int3). See text_poke_bp_batch().
+ 	 */
+ 	ip = (void *) regs->ip - sizeof(int3);
+ 
+ 	/*
+ 	 * Skip the binary search if there is a single member in the vector.
+ 	 */
+ 	if (unlikely(bp_patching.nr_entries > 1)) {
+ 		tp = bsearch(ip, bp_patching.vec, bp_patching.nr_entries,
+ 			     sizeof(struct text_poke_loc),
+ 			     patch_cmp);
+ 		if (!tp)
+ 			return 0;
+ 	} else {
+ 		tp = bp_patching.vec;
+ 		if (tp->addr != ip)
+ 			return 0;
+ 	}
+ 
+ 	/* set up the specified breakpoint detour */
+ 	regs->ip = (unsigned long) tp->detour;
  
  	return 1;
 +
  }
 -NOKPROBE_SYMBOL(poke_int3_handler);
  
  /**
-  * text_poke_bp() -- update instructions on live kernel on SMP
-  * @addr:	address to patch
-  * @opcode:	opcode of new instruction
-  * @len:	length to copy
-  * @handler:	address to jump to when the temporary breakpoint is hit
+  * text_poke_bp_batch() -- update instructions on live kernel on SMP
+  * @tp:			vector of instructions to patch
+  * @nr_entries:		number of entries in the vector
   *
   * Modify multi-byte instruction by using int3 breakpoint on SMP.
   * We completely avoid stop_machine() here, and achieve the
diff --git a/arch/x86/include/asm/text-patching.h b/arch/x86/include/asm/text-patching.h
index ac1361abf866..c2fc7e927488 100644
--- a/arch/x86/include/asm/text-patching.h
+++ b/arch/x86/include/asm/text-patching.h
@@ -18,6 +18,20 @@ static inline void apply_paravirt(struct paravirt_patch_site *start,
 #define __parainstructions_end	NULL
 #endif
 
+/*
+ * Currently, the max observed size in the kernel code is
+ * JUMP_LABEL_NOP_SIZE/RELATIVEJUMP_SIZE, which are 5.
+ * Raise it if needed.
+ */
+#define POKE_MAX_OPCODE_SIZE	5
+
+struct text_poke_loc {
+	void *detour;
+	void *addr;
+	size_t len;
+	const char opcode[POKE_MAX_OPCODE_SIZE];
+};
+
 extern void text_poke_early(void *addr, const void *opcode, size_t len);
 
 /*
@@ -38,6 +52,7 @@ extern void *text_poke(void *addr, const void *opcode, size_t len);
 extern void *text_poke_kgdb(void *addr, const void *opcode, size_t len);
 extern int poke_int3_handler(struct pt_regs *regs);
 extern void text_poke_bp(void *addr, const void *opcode, size_t len, void *handler);
+extern void text_poke_bp_batch(struct text_poke_loc *tp, unsigned int nr_entries);
 extern int after_bootmem;
 
 #endif /* _ASM_X86_TEXT_PATCHING_H */
* Unmerged path arch/x86/kernel/alternative.c
