net/mlx5: Move IRQ affinity set to IRQ allocation phase

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Move IRQ affinity set to IRQ allocation phase (Alaa Hleihel) [1724336]
Rebuild_FUZZ: 96.23%
commit-author Yuval Avnery <yuvalav@mellanox.com>
commit 90426cc00c77e4c11f1d23799de44ecb54e8ff27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/90426cc0.failed

Affinity set/clear is part of the IRQ life-cycle.

	Signed-off-by: Yuval Avnery <yuvalav@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 90426cc00c77e4c11f1d23799de44ecb54e8ff27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eq.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eq.c
index c00cfa7a9ba0,d30bd01cf050..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
@@@ -859,14 -934,6 +859,17 @@@ static void destroy_comp_eqs(struct mlx
  	struct mlx5_eq_table *table = dev->priv.eq_table;
  	struct mlx5_eq_comp *eq, *n;
  
++<<<<<<< HEAD
 +	clear_comp_irqs_affinity_hints(dev);
 +
 +#ifdef CONFIG_RFS_ACCEL
 +	if (table->rmap) {
 +		free_irq_cpu_rmap(table->rmap);
 +		table->rmap = NULL;
 +	}
 +#endif
++=======
++>>>>>>> 90426cc00c77 (net/mlx5: Move IRQ affinity set to IRQ allocation phase)
  	list_for_each_entry_safe(eq, n, &table->comp_eqs_list, list) {
  		list_del(&eq->list);
  		if (destroy_unmap_eq(dev, &eq->core))
@@@ -1053,11 -1115,19 +1060,23 @@@ static int alloc_irq_vectors(struct mlx
  
  	err = request_irqs(dev, nvec);
  	if (err)
 -		goto err_request_irqs;
 +		goto err_free_irqs;
  
+ 	err = set_comp_irq_affinity_hints(dev);
+ 	if (err)
+ 		goto err_set_affinity;
+ 
  	return 0;
  
++<<<<<<< HEAD
 +err_free_irqs:
++=======
+ err_set_affinity:
+ 	unrequest_irqs(dev);
+ err_request_irqs:
+ 	irq_clear_rmap(dev);
+ err_set_rmap:
++>>>>>>> 90426cc00c77 (net/mlx5: Move IRQ affinity set to IRQ allocation phase)
  	pci_free_irq_vectors(dev->pdev);
  err_free_irq_info:
  	kfree(table->irq_info);
@@@ -1066,11 -1136,18 +1085,23 @@@
  
  static void free_irq_vectors(struct mlx5_core_dev *dev)
  {
 -	struct mlx5_irq_table *table = dev->priv.irq_table;
 +	struct mlx5_eq_table *table = dev->priv.eq_table;
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < table->num_comp_vectors + MLX5_EQ_VEC_COMP_BASE; i++)
 +		free_irq(pci_irq_vector(dev->pdev, i), &table->irq_info[i].nh);
++=======
+ 	/* free_irq requires that affinity and rmap will be cleared
+ 	 * before calling it. This is why there is asymmetry with set_rmap
+ 	 * which should be called after alloc_irq but before request_irq.
+ 	 */
+ 	irq_clear_rmap(dev);
+ 	clear_comp_irqs_affinity_hints(dev);
+ 	for (i = 0; i < table->nvec; i++)
+ 		free_irq(pci_irq_vector(dev->pdev, i),
+ 			 &mlx5_irq_get(dev, i)->nh);
++>>>>>>> 90426cc00c77 (net/mlx5: Move IRQ affinity set to IRQ allocation phase)
  	pci_free_irq_vectors(dev->pdev);
  	kfree(table->irq_info);
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eq.c
