iommu/vt-d: Remove unnecessary rcu_read_locks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [iommu] vt-d: Remove unnecessary rcu_read_locks (Jerry Snitselaar) [1742234]
Rebuild_FUZZ: 92.86%
commit-author Lukasz Odzioba <lukasz.odzioba@intel.com>
commit f780a8dc196db1c41b5da21ecfa27e83ee5fb776
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f780a8dc.failed

We use RCU's for rarely updated lists like iommus, rmrr, atsr units.

I'm not sure why domain_remove_dev_info() in domain_exit() was surrounded
by rcu_read_lock. Lock was present before refactoring in d160aca527,
but it was related to rcu list, not domain_remove_dev_info function.

dmar_remove_one_dev_info() doesn't touch any of those lists, so it doesn't
require a lock. In fact it is called 6 times without it anyway.

Fixes: d160aca5276d ("iommu/vt-d: Unify domain->iommu attach/detachment")

	Signed-off-by: Lukasz Odzioba <lukasz.odzioba@intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit f780a8dc196db1c41b5da21ecfa27e83ee5fb776)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 2b01c065423a,1b7ad80c0537..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -5086,7 -5230,56 +5084,60 @@@ static int intel_iommu_attach_device(st
  		dmar_domain->agaw--;
  	}
  
++<<<<<<< HEAD
 +	return domain_add_dev_info(dmar_domain, dev);
++=======
+ 	return 0;
+ }
+ 
+ static int intel_iommu_attach_device(struct iommu_domain *domain,
+ 				     struct device *dev)
+ {
+ 	int ret;
+ 
+ 	if (device_is_rmrr_locked(dev)) {
+ 		dev_warn(dev, "Device is ineligible for IOMMU domain attach due to platform RMRR requirement.  Contact your platform vendor.\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	if (is_aux_domain(dev, domain))
+ 		return -EPERM;
+ 
+ 	/* normally dev is not mapped */
+ 	if (unlikely(domain_context_mapped(dev))) {
+ 		struct dmar_domain *old_domain;
+ 
+ 		old_domain = find_domain(dev);
+ 		if (old_domain) {
+ 			dmar_remove_one_dev_info(dev);
+ 
+ 			if (!domain_type_is_vm_or_si(old_domain) &&
+ 			    list_empty(&old_domain->devices))
+ 				domain_exit(old_domain);
+ 		}
+ 	}
+ 
+ 	ret = prepare_domain_attach_device(domain, dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return domain_add_dev_info(to_dmar_domain(domain), dev);
+ }
+ 
+ static int intel_iommu_aux_attach_device(struct iommu_domain *domain,
+ 					 struct device *dev)
+ {
+ 	int ret;
+ 
+ 	if (!is_aux_domain(dev, domain))
+ 		return -EPERM;
+ 
+ 	ret = prepare_domain_attach_device(domain, dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return aux_domain_add_dev(to_dmar_domain(domain), dev);
++>>>>>>> f780a8dc196d (iommu/vt-d: Remove unnecessary rcu_read_locks)
  }
  
  static void intel_iommu_detach_device(struct iommu_domain *domain,
* Unmerged path drivers/iommu/intel-iommu.c
