memremap: pass a struct dev_pagemap to ->kill and ->cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Christoph Hellwig <hch@lst.de>
commit d8668bb0451c3c45b59dbcde2654e0539aad1d2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d8668bb0.failed

Passing the actual typed structure leads to more understandable code
vs just passing the ref member.

	Reported-by: Logan Gunthorpe <logang@deltatee.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Logan Gunthorpe <logang@deltatee.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Tested-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit d8668bb0451c3c45b59dbcde2654e0539aad1d2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/device.c
#	drivers/nvdimm/pmem.c
#	drivers/pci/p2pdma.c
#	include/linux/memremap.h
#	kernel/memremap.c
#	mm/hmm.c
#	tools/testing/nvdimm/test/iomap.c
diff --cc drivers/dax/device.c
index e428468ab661,b5257038c188..000000000000
--- a/drivers/dax/device.c
+++ b/drivers/dax/device.c
@@@ -27,23 -27,21 +27,35 @@@ static void dev_dax_percpu_release(stru
  	complete(&dev_dax->cmp);
  }
  
++<<<<<<< HEAD
 +static void dev_dax_percpu_exit(void *data)
 +{
 +	struct percpu_ref *ref = data;
 +	struct dev_dax *dev_dax = ref_to_dev_dax(ref);
++=======
+ static void dev_dax_percpu_exit(struct dev_pagemap *pgmap)
+ {
+ 	struct dev_dax *dev_dax = container_of(pgmap, struct dev_dax, pgmap);
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  
  	dev_dbg(&dev_dax->dev, "%s\n", __func__);
  	wait_for_completion(&dev_dax->cmp);
- 	percpu_ref_exit(ref);
+ 	percpu_ref_exit(pgmap->ref);
  }
  
++<<<<<<< HEAD
 +static void dev_dax_percpu_kill(struct percpu_ref *data)
 +{
 +	struct percpu_ref *ref = data;
 +	struct dev_dax *dev_dax = ref_to_dev_dax(ref);
++=======
+ static void dev_dax_percpu_kill(struct dev_pagemap *pgmap)
+ {
+ 	struct dev_dax *dev_dax = container_of(pgmap, struct dev_dax, pgmap);
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  
  	dev_dbg(&dev_dax->dev, "%s\n", __func__);
- 	percpu_ref_kill(ref);
+ 	percpu_ref_kill(pgmap->ref);
  }
  
  static int check_vma(struct dev_dax *dev_dax, struct vm_area_struct *vma,
diff --cc drivers/nvdimm/pmem.c
index d9d845077b8b,9dac48359353..000000000000
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@@ -311,16 -303,24 +311,33 @@@ static const struct attribute_group *pm
  	NULL,
  };
  
++<<<<<<< HEAD
 +static void pmem_release_queue(void *q)
 +{
 +	blk_cleanup_queue(q);
 +}
 +
 +static void pmem_freeze_queue(struct percpu_ref *ref)
++=======
+ static void pmem_pagemap_cleanup(struct dev_pagemap *pgmap)
  {
- 	struct request_queue *q;
+ 	struct request_queue *q =
+ 		container_of(pgmap->ref, struct request_queue, q_usage_counter);
+ 
+ 	blk_cleanup_queue(q);
+ }
+ 
+ static void pmem_release_queue(void *pgmap)
+ {
+ 	pmem_pagemap_cleanup(pgmap);
+ }
+ 
+ static void pmem_pagemap_kill(struct dev_pagemap *pgmap)
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
+ {
+ 	struct request_queue *q =
+ 		container_of(pgmap->ref, struct request_queue, q_usage_counter);
  
- 	q = container_of(ref, typeof(*q), q_usage_counter);
  	blk_freeze_queue_start(q);
  }
  
@@@ -433,6 -434,9 +450,12 @@@ static int pmem_attach_disk(struct devi
  		pmem->pfn_flags |= PFN_MAP;
  		memcpy(&bb_res, &pmem->pgmap.res, sizeof(bb_res));
  	} else {
++<<<<<<< HEAD
++=======
+ 		if (devm_add_action_or_reset(dev, pmem_release_queue,
+ 					&pmem->pgmap))
+ 			return -ENOMEM;
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  		addr = devm_memremap(dev, pmem->phys_addr,
  				pmem->size, ARCH_MEMREMAP_PMEM);
  		memcpy(&bb_res, &nsio->res, sizeof(bb_res));
diff --cc drivers/pci/p2pdma.c
index 9d5953e3f11b,fa6249e4ed5f..000000000000
--- a/drivers/pci/p2pdma.c
+++ b/drivers/pci/p2pdma.c
@@@ -91,14 -91,15 +91,19 @@@ static void pci_p2pdma_percpu_release(s
  	complete(&p2p_pgmap->ref_done);
  }
  
- static void pci_p2pdma_percpu_kill(struct percpu_ref *ref)
+ static void pci_p2pdma_percpu_kill(struct dev_pagemap *pgmap)
  {
- 	percpu_ref_kill(ref);
+ 	percpu_ref_kill(pgmap->ref);
  }
  
++<<<<<<< HEAD
 +static void pci_p2pdma_percpu_cleanup(void *ref)
++=======
+ static void pci_p2pdma_percpu_cleanup(struct dev_pagemap *pgmap)
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  {
- 	struct p2pdma_pagemap *p2p_pgmap = to_p2p_pgmap(ref);
+ 	struct p2pdma_pagemap *p2p_pgmap =
+ 		container_of(pgmap, struct p2pdma_pagemap, pgmap);
  
  	wait_for_completion(&p2p_pgmap->ref_done);
  	percpu_ref_exit(&p2p_pgmap->ref);
diff --cc include/linux/memremap.h
index ae6713454b27,b8666a0d8665..000000000000
--- a/include/linux/memremap.h
+++ b/include/linux/memremap.h
@@@ -66,44 -62,25 +66,65 @@@ enum memory_type 
  	MEMORY_DEVICE_PCI_P2PDMA,
  };
  
++<<<<<<< HEAD
 +/*
 + * For MEMORY_DEVICE_PRIVATE we use ZONE_DEVICE and extend it with two
 + * callbacks:
 + *   page_fault()
 + *   page_free()
 + *
 + * Additional notes about MEMORY_DEVICE_PRIVATE may be found in
 + * include/linux/hmm.h and Documentation/vm/hmm.rst. There is also a brief
 + * explanation in include/linux/memory_hotplug.h.
 + *
 + * The page_fault() callback must migrate page back, from device memory to
 + * system memory, so that the CPU can access it. This might fail for various
 + * reasons (device issues,  device have been unplugged, ...). When such error
 + * conditions happen, the page_fault() callback must return VM_FAULT_SIGBUS and
 + * set the CPU page table entry to "poisoned".
 + *
 + * Note that because memory cgroup charges are transferred to the device memory,
 + * this should never fail due to memory restrictions. However, allocation
 + * of a regular system page might still fail because we are out of memory. If
 + * that happens, the page_fault() callback must return VM_FAULT_OOM.
 + *
 + * The page_fault() callback can also try to migrate back multiple pages in one
 + * chunk, as an optimization. It must, however, prioritize the faulting address
 + * over all the others.
 + *
 + *
 + * The page_free() callback is called once the page refcount reaches 1
 + * (ZONE_DEVICE pages never reach 0 refcount unless there is a refcount bug.
 + * This allows the device driver to implement its own memory management.)
 + *
 + * For MEMORY_DEVICE_PUBLIC only the page_free() callback matter.
 + */
 +typedef int (*dev_page_fault_t)(struct vm_area_struct *vma,
 +				unsigned long addr,
 +				const struct page *page,
 +				unsigned int flags,
 +				pmd_t *pmdp);
 +typedef void (*dev_page_free_t)(struct page *page, void *data);
++=======
+ struct dev_pagemap_ops {
+ 	/*
+ 	 * Called once the page refcount reaches 1.  (ZONE_DEVICE pages never
+ 	 * reach 0 refcount unless there is a refcount bug. This allows the
+ 	 * device driver to implement its own memory management.)
+ 	 */
+ 	void (*page_free)(struct page *page, void *data);
+ 
+ 	/*
+ 	 * Transition the refcount in struct dev_pagemap to the dead state.
+ 	 */
+ 	void (*kill)(struct dev_pagemap *pgmap);
+ 
+ 	/*
+ 	 * Wait for refcount in struct dev_pagemap to be idle and reap it.
+ 	 */
+ 	void (*cleanup)(struct dev_pagemap *pgmap);
+ };
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  
  /**
   * struct dev_pagemap - metadata for ZONE_DEVICE mappings
diff --cc kernel/memremap.c
index 794888559eb7,00c1ceb60c19..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -122,9 -92,10 +122,16 @@@ static void devm_memremap_pages_release
  	unsigned long pfn;
  	int nid;
  
++<<<<<<< HEAD
 +	pgmap->kill(pgmap->ref);
 +	for_each_device_pfn(pfn, pgmap)
 +		put_page(pfn_to_page(pfn));
++=======
+ 	pgmap->ops->kill(pgmap);
+ 	for_each_device_pfn(pfn, pgmap)
+ 		put_page(pfn_to_page(pfn));
+ 	pgmap->ops->cleanup(pgmap);
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  
  	/* pages are dead and unused, undo the arch mapping */
  	align_start = res->start & ~(SECTION_SIZE - 1);
@@@ -299,10 -292,10 +306,17 @@@ void *devm_memremap_pages(struct devic
   err_kasan:
  	untrack_pfn(NULL, PHYS_PFN(align_start), align_size);
   err_pfn_remap:
++<<<<<<< HEAD
 + err_radix:
 +	pgmap_radix_release(res, pgoff);
 + err_pgmap:
 +	pgmap->kill(pgmap->ref);
++=======
+ 	pgmap_array_delete(res);
+  err_array:
+ 	pgmap->ops->kill(pgmap);
+ 	pgmap->ops->cleanup(pgmap);
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  	return ERR_PTR(error);
  }
  EXPORT_SYMBOL_GPL(devm_memremap_pages);
diff --cc mm/hmm.c
index 91b885757871,987793fba923..000000000000
--- a/mm/hmm.c
+++ b/mm/hmm.c
@@@ -968,22 -1352,21 +968,26 @@@ static void hmm_devmem_ref_release(stru
  	complete(&devmem->completion);
  }
  
++<<<<<<< HEAD
 +static void hmm_devmem_ref_exit(void *data)
++=======
+ static void hmm_devmem_ref_exit(struct dev_pagemap *pgmap)
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  {
 +	struct percpu_ref *ref = data;
  	struct hmm_devmem *devmem;
  
- 	devmem = container_of(ref, struct hmm_devmem, ref);
+ 	devmem = container_of(pgmap, struct hmm_devmem, pagemap);
  	wait_for_completion(&devmem->completion);
- 	percpu_ref_exit(ref);
+ 	percpu_ref_exit(pgmap->ref);
  }
  
- static void hmm_devmem_ref_kill(struct percpu_ref *ref)
+ static void hmm_devmem_ref_kill(struct dev_pagemap *pgmap)
  {
- 	percpu_ref_kill(ref);
+ 	percpu_ref_kill(pgmap->ref);
  }
  
 -static vm_fault_t hmm_devmem_fault(struct vm_area_struct *vma,
 +static int hmm_devmem_fault(struct vm_area_struct *vma,
  			    unsigned long addr,
  			    const struct page *page,
  			    unsigned int flags,
diff --cc tools/testing/nvdimm/test/iomap.c
index 280015c22598,82f901569e06..000000000000
--- a/tools/testing/nvdimm/test/iomap.c
+++ b/tools/testing/nvdimm/test/iomap.c
@@@ -100,7 -100,10 +100,14 @@@ static void nfit_test_kill(void *_pgmap
  {
  	struct dev_pagemap *pgmap = _pgmap;
  
++<<<<<<< HEAD
 +	pgmap->kill(pgmap->ref);
++=======
+ 	WARN_ON(!pgmap || !pgmap->ref || !pgmap->ops || !pgmap->ops->kill ||
+ 		!pgmap->ops->cleanup);
+ 	pgmap->ops->kill(pgmap);
+ 	pgmap->ops->cleanup(pgmap);
++>>>>>>> d8668bb0451c (memremap: pass a struct dev_pagemap to ->kill and ->cleanup)
  }
  
  void *__wrap_devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)
* Unmerged path drivers/dax/device.c
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path drivers/pci/p2pdma.c
* Unmerged path include/linux/memremap.h
* Unmerged path kernel/memremap.c
* Unmerged path mm/hmm.c
* Unmerged path tools/testing/nvdimm/test/iomap.c
