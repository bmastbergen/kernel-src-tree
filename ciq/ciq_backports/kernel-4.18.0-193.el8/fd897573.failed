rcu: Improve diagnostics for failed RCU grace-period start

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Paul E. McKenney <paulmck@linux.ibm.com>
commit fd897573fa4cfe66ebddf5f4444f36710cf0cad0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/fd897573.failed

If a grace period fails to start (for example, because you commented
out the last two lines of rcu_accelerate_cbs_unlocked()), rcu_core()
will invoke rcu_check_gp_start_stall(), which will notice and complain.
However, this complaint is lacking crucial debugging information such
as when the last wakeup executed and what the value of ->gp_seq was at
that time.  This commit therefore removes the current pr_alert() from
rcu_check_gp_start_stall(), instead invoking show_rcu_gp_kthreads(),
which has been updated to print the needed information, which is collected
by rcu_gp_kthread_wake().

	Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>
(cherry picked from commit fd897573fa4cfe66ebddf5f4444f36710cf0cad0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 58493b8b5f11,8543a90d53f2..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -503,6 -504,23 +503,26 @@@ unsigned long rcu_exp_batches_completed
  EXPORT_SYMBOL_GPL(rcu_exp_batches_completed);
  
  /*
++<<<<<<< HEAD
++=======
+  * Force a quiescent state.
+  */
+ void rcu_force_quiescent_state(void)
+ {
+ 	force_quiescent_state();
+ }
+ EXPORT_SYMBOL_GPL(rcu_force_quiescent_state);
+ 
+ /*
+  * Return the root node of the rcu_state structure.
+  */
+ static struct rcu_node *rcu_get_root(void)
+ {
+ 	return &rcu_state.node[0];
+ }
+ 
+ /*
++>>>>>>> fd897573fa4c (rcu: Improve diagnostics for failed RCU grace-period start)
   * Convert a ->gp_state value to a character string.
   */
  static const char *gp_state_getname(short gs)
@@@ -1556,7 -1580,9 +1580,13 @@@ static void rcu_gp_kthread_wake(void
  	    !READ_ONCE(rcu_state.gp_flags) ||
  	    !rcu_state.gp_kthread)
  		return;
++<<<<<<< HEAD
 +	swake_up(&rcu_state.gp_wq);
++=======
+ 	WRITE_ONCE(rcu_state.gp_wake_time, jiffies);
+ 	WRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));
+ 	swake_up_one(&rcu_state.gp_wq);
++>>>>>>> fd897573fa4c (rcu: Improve diagnostics for failed RCU grace-period start)
  }
  
  /*
* Unmerged path kernel/rcu/tree.c
diff --git a/kernel/rcu/tree.h b/kernel/rcu/tree.h
index beaa50da4050..149557b7c39c 100644
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@ -305,6 +305,8 @@ struct rcu_state {
 	struct swait_queue_head gp_wq;		/* Where GP task waits. */
 	short gp_flags;				/* Commands for GP task. */
 	short gp_state;				/* GP kthread sleep state. */
+	unsigned long gp_wake_time;		/* Last GP kthread wake. */
+	unsigned long gp_wake_seq;		/* ->gp_seq at ^^^. */
 
 	/* End of fields guarded by root rcu_node's lock. */
 
