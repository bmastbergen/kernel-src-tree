xdp: obtain the mem_id mutex before trying to remove an entry.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [net] xdp: obtain the mem_id mutex before trying to remove an entry (Jiri Benc) [1802507]
Rebuild_FUZZ: 99.19%
commit-author Jonathan Lemon <jonathan.lemon@gmail.com>
commit 86c76c09898332143be365c702cf8d586ed4ed21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/86c76c09.failed

A lockdep splat was observed when trying to remove an xdp memory
model from the table since the mutex was obtained when trying to
remove the entry, but not before the table walk started:

Fix the splat by obtaining the lock before starting the table walk.

Fixes: c3f812cea0d7 ("page_pool: do not release pool until inflight == 0.")
	Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
	Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
	Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
	Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Acked-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 86c76c09898332143be365c702cf8d586ed4ed21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/xdp.c
diff --cc net/core/xdp.c
index 762abeb89847,7c8390ad4dc6..000000000000
--- a/net/core/xdp.c
+++ b/net/core/xdp.c
@@@ -94,6 -76,59 +94,62 @@@ static void __xdp_mem_allocator_rcu_fre
  	kfree(xa);
  }
  
++<<<<<<< HEAD
++=======
+ static void mem_xa_remove(struct xdp_mem_allocator *xa)
+ {
+ 	trace_mem_disconnect(xa);
+ 
+ 	if (!rhashtable_remove_fast(mem_id_ht, &xa->node, mem_id_rht_params))
+ 		call_rcu(&xa->rcu, __xdp_mem_allocator_rcu_free);
+ }
+ 
+ static void mem_allocator_disconnect(void *allocator)
+ {
+ 	struct xdp_mem_allocator *xa;
+ 	struct rhashtable_iter iter;
+ 
+ 	mutex_lock(&mem_id_lock);
+ 
+ 	rhashtable_walk_enter(mem_id_ht, &iter);
+ 	do {
+ 		rhashtable_walk_start(&iter);
+ 
+ 		while ((xa = rhashtable_walk_next(&iter)) && !IS_ERR(xa)) {
+ 			if (xa->allocator == allocator)
+ 				mem_xa_remove(xa);
+ 		}
+ 
+ 		rhashtable_walk_stop(&iter);
+ 
+ 	} while (xa == ERR_PTR(-EAGAIN));
+ 	rhashtable_walk_exit(&iter);
+ 
+ 	mutex_unlock(&mem_id_lock);
+ }
+ 
+ static void mem_id_disconnect(int id)
+ {
+ 	struct xdp_mem_allocator *xa;
+ 
+ 	mutex_lock(&mem_id_lock);
+ 
+ 	xa = rhashtable_lookup_fast(mem_id_ht, &id, mem_id_rht_params);
+ 	if (!xa) {
+ 		mutex_unlock(&mem_id_lock);
+ 		WARN(1, "Request remove non-existing id(%d), driver bug?", id);
+ 		return;
+ 	}
+ 
+ 	trace_mem_disconnect(xa);
+ 
+ 	if (!rhashtable_remove_fast(mem_id_ht, &xa->node, mem_id_rht_params))
+ 		call_rcu(&xa->rcu, __xdp_mem_allocator_rcu_free);
+ 
+ 	mutex_unlock(&mem_id_lock);
+ }
+ 
++>>>>>>> 86c76c098983 (xdp: obtain the mem_id mutex before trying to remove an entry.)
  void xdp_rxq_info_unreg_mem_model(struct xdp_rxq_info *xdp_rxq)
  {
  	struct xdp_mem_allocator *xa;
* Unmerged path net/core/xdp.c
