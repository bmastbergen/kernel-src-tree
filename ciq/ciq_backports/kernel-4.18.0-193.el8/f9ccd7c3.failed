PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit f9ccd7c3a1d87cea3a6f9ed6c946dee9e7456b2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/f9ccd7c3.failed

Attaching a device via genpd_dev_pm_attach_by_id|name() makes
genpd allocate a virtual device that it attaches instead. This
leads to a problem in case when the base device belongs to a CPU.
More precisely, it means genpd_get_cpu() compares against the
virtual device, thus it fails to find a matching CPU device.

Address this limitation by passing the base device to genpd_get_cpu()
rather than the virtual device.

Moreover, to deal with detach correctly from genpd_remove_device(),
store the CPU number in struct generic_pm_domain_data, so as to be
able to clear the corresponding bit in the cpumask for the genpd.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit f9ccd7c3a1d87cea3a6f9ed6c946dee9e7456b2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/domain.c
diff --cc drivers/base/power/domain.c
index ae411ec1ee12,3d899e8abd58..000000000000
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@@ -1452,8 -1450,57 +1452,62 @@@ static void genpd_free_dev_data(struct 
  	dev_pm_put_subsys_data(dev);
  }
  
++<<<<<<< HEAD
 +static int genpd_add_device(struct generic_pm_domain *genpd, struct device *dev,
 +			    struct gpd_timing_data *td)
++=======
+ static void genpd_update_cpumask(struct generic_pm_domain *genpd,
+ 				 int cpu, bool set, unsigned int depth)
+ {
+ 	struct gpd_link *link;
+ 
+ 	if (!genpd_is_cpu_domain(genpd))
+ 		return;
+ 
+ 	list_for_each_entry(link, &genpd->slave_links, slave_node) {
+ 		struct generic_pm_domain *master = link->master;
+ 
+ 		genpd_lock_nested(master, depth + 1);
+ 		genpd_update_cpumask(master, cpu, set, depth + 1);
+ 		genpd_unlock(master);
+ 	}
+ 
+ 	if (set)
+ 		cpumask_set_cpu(cpu, genpd->cpus);
+ 	else
+ 		cpumask_clear_cpu(cpu, genpd->cpus);
+ }
+ 
+ static void genpd_set_cpumask(struct generic_pm_domain *genpd, int cpu)
+ {
+ 	if (cpu >= 0)
+ 		genpd_update_cpumask(genpd, cpu, true, 0);
+ }
+ 
+ static void genpd_clear_cpumask(struct generic_pm_domain *genpd, int cpu)
+ {
+ 	if (cpu >= 0)
+ 		genpd_update_cpumask(genpd, cpu, false, 0);
+ }
+ 
+ static int genpd_get_cpu(struct generic_pm_domain *genpd, struct device *dev)
+ {
+ 	int cpu;
+ 
+ 	if (!genpd_is_cpu_domain(genpd))
+ 		return -1;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		if (get_cpu_device(cpu) == dev)
+ 			return cpu;
+ 	}
+ 
+ 	return -1;
+ }
+ 
+ static int genpd_add_device(struct generic_pm_domain *genpd, struct device *dev,
+ 			    struct device *base_dev)
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  {
  	struct generic_pm_domain_data *gpd_data;
  	int ret;
@@@ -1467,12 -1514,15 +1521,21 @@@
  	if (IS_ERR(gpd_data))
  		return PTR_ERR(gpd_data);
  
++<<<<<<< HEAD
++=======
+ 	gpd_data->cpu = genpd_get_cpu(genpd, base_dev);
+ 
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  	ret = genpd->attach_dev ? genpd->attach_dev(genpd, dev) : 0;
  	if (ret)
  		goto out;
  
  	genpd_lock(genpd);
  
++<<<<<<< HEAD
++=======
+ 	genpd_set_cpumask(genpd, gpd_data->cpu);
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  	dev_pm_domain_set(dev, &genpd->domain);
  
  	genpd->device_count++;
@@@ -1500,7 -1550,7 +1563,11 @@@ int pm_genpd_add_device(struct generic_
  	int ret;
  
  	mutex_lock(&gpd_list_lock);
++<<<<<<< HEAD
 +	ret = genpd_add_device(genpd, dev, NULL);
++=======
+ 	ret = genpd_add_device(genpd, dev, dev);
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  	mutex_unlock(&gpd_list_lock);
  
  	return ret;
@@@ -1530,6 -1580,7 +1597,10 @@@ static int genpd_remove_device(struct g
  	genpd->device_count--;
  	genpd->max_off_time_changed = true;
  
++<<<<<<< HEAD
++=======
+ 	genpd_clear_cpumask(genpd, gpd_data->cpu);
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  	dev_pm_domain_set(dev, NULL);
  
  	list_del_init(&pdd->list_node);
@@@ -2196,7 -2256,7 +2267,11 @@@ int of_genpd_add_device(struct of_phand
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = genpd_add_device(genpd, dev, NULL);
++=======
+ 	ret = genpd_add_device(genpd, dev, dev);
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  
  out:
  	mutex_unlock(&gpd_list_lock);
@@@ -2366,7 -2426,7 +2441,11 @@@ static int __genpd_dev_pm_attach(struc
  
  	dev_dbg(dev, "adding to PM domain %s\n", pd->name);
  
++<<<<<<< HEAD
 +	ret = genpd_add_device(pd, dev, NULL);
++=======
+ 	ret = genpd_add_device(pd, dev, base_dev);
++>>>>>>> f9ccd7c3a1d8 (PM / Domains: Allow to attach a CPU via genpd_dev_pm_attach_by_id|name())
  	mutex_unlock(&gpd_list_lock);
  
  	if (ret < 0) {
* Unmerged path drivers/base/power/domain.c
diff --git a/include/linux/pm_domain.h b/include/linux/pm_domain.h
index 4cccffdf912a..31f53ce81521 100644
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@ -162,6 +162,7 @@ struct generic_pm_domain_data {
 	struct pm_domain_data base;
 	struct gpd_timing_data td;
 	struct notifier_block nb;
+	int cpu;
 	unsigned int performance_state;
 	void *data;
 };
