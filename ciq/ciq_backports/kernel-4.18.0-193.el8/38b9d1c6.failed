net/mlx5: Add API to set the namespace steering mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [netdrv] mlx5: Add API to set the namespace steering mode (Alaa Hleihel) [1760284 1724336]
Rebuild_FUZZ: 96.00%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 38b9d1c62a6e9428048e4d080d2aabd0dc2e7f88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/38b9d1c6.failed

Add API to set the flow steering root namesapce mode.
Setting new mode should be called before any steering operation
is executed on the namespace.
This API is going to be used by steering users such switchdev.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 38b9d1c62a6e9428048e4d080d2aabd0dc2e7f88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 585e7adcbf99,3bbb49354829..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -2842,3 -2889,160 +2842,163 @@@ out
  	return err;
  }
  EXPORT_SYMBOL(mlx5_fs_remove_rx_underlay_qpn);
++<<<<<<< HEAD
++=======
+ 
+ static struct mlx5_flow_root_namespace
+ *get_root_namespace(struct mlx5_core_dev *dev, enum mlx5_flow_namespace_type ns_type)
+ {
+ 	struct mlx5_flow_namespace *ns;
+ 
+ 	if (ns_type == MLX5_FLOW_NAMESPACE_ESW_EGRESS ||
+ 	    ns_type == MLX5_FLOW_NAMESPACE_ESW_INGRESS)
+ 		ns = mlx5_get_flow_vport_acl_namespace(dev, ns_type, 0);
+ 	else
+ 		ns = mlx5_get_flow_namespace(dev, ns_type);
+ 	if (!ns)
+ 		return NULL;
+ 
+ 	return find_root(&ns->node);
+ }
+ 
+ struct mlx5_modify_hdr *mlx5_modify_header_alloc(struct mlx5_core_dev *dev,
+ 						 u8 ns_type, u8 num_actions,
+ 						 void *modify_actions)
+ {
+ 	struct mlx5_flow_root_namespace *root;
+ 	struct mlx5_modify_hdr *modify_hdr;
+ 	int err;
+ 
+ 	root = get_root_namespace(dev, ns_type);
+ 	if (!root)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	modify_hdr = kzalloc(sizeof(*modify_hdr), GFP_KERNEL);
+ 	if (!modify_hdr)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	modify_hdr->ns_type = ns_type;
+ 	err = root->cmds->modify_header_alloc(root, ns_type, num_actions,
+ 					      modify_actions, modify_hdr);
+ 	if (err) {
+ 		kfree(modify_hdr);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return modify_hdr;
+ }
+ EXPORT_SYMBOL(mlx5_modify_header_alloc);
+ 
+ void mlx5_modify_header_dealloc(struct mlx5_core_dev *dev,
+ 				struct mlx5_modify_hdr *modify_hdr)
+ {
+ 	struct mlx5_flow_root_namespace *root;
+ 
+ 	root = get_root_namespace(dev, modify_hdr->ns_type);
+ 	if (WARN_ON(!root))
+ 		return;
+ 	root->cmds->modify_header_dealloc(root, modify_hdr);
+ 	kfree(modify_hdr);
+ }
+ EXPORT_SYMBOL(mlx5_modify_header_dealloc);
+ 
+ struct mlx5_pkt_reformat *mlx5_packet_reformat_alloc(struct mlx5_core_dev *dev,
+ 						     int reformat_type,
+ 						     size_t size,
+ 						     void *reformat_data,
+ 						     enum mlx5_flow_namespace_type ns_type)
+ {
+ 	struct mlx5_pkt_reformat *pkt_reformat;
+ 	struct mlx5_flow_root_namespace *root;
+ 	int err;
+ 
+ 	root = get_root_namespace(dev, ns_type);
+ 	if (!root)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	pkt_reformat = kzalloc(sizeof(*pkt_reformat), GFP_KERNEL);
+ 	if (!pkt_reformat)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pkt_reformat->ns_type = ns_type;
+ 	pkt_reformat->reformat_type = reformat_type;
+ 	err = root->cmds->packet_reformat_alloc(root, reformat_type, size,
+ 						reformat_data, ns_type,
+ 						pkt_reformat);
+ 	if (err) {
+ 		kfree(pkt_reformat);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	return pkt_reformat;
+ }
+ EXPORT_SYMBOL(mlx5_packet_reformat_alloc);
+ 
+ void mlx5_packet_reformat_dealloc(struct mlx5_core_dev *dev,
+ 				  struct mlx5_pkt_reformat *pkt_reformat)
+ {
+ 	struct mlx5_flow_root_namespace *root;
+ 
+ 	root = get_root_namespace(dev, pkt_reformat->ns_type);
+ 	if (WARN_ON(!root))
+ 		return;
+ 	root->cmds->packet_reformat_dealloc(root, pkt_reformat);
+ 	kfree(pkt_reformat);
+ }
+ EXPORT_SYMBOL(mlx5_packet_reformat_dealloc);
+ 
+ int mlx5_flow_namespace_set_peer(struct mlx5_flow_root_namespace *ns,
+ 				 struct mlx5_flow_root_namespace *peer_ns)
+ {
+ 	if (peer_ns && ns->mode != peer_ns->mode) {
+ 		mlx5_core_err(ns->dev,
+ 			      "Can't peer namespace of different steering mode\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return ns->cmds->set_peer(ns, peer_ns);
+ }
+ 
+ /* This function should be called only at init stage of the namespace.
+  * It is not safe to call this function while steering operations
+  * are executed in the namespace.
+  */
+ int mlx5_flow_namespace_set_mode(struct mlx5_flow_namespace *ns,
+ 				 enum mlx5_flow_steering_mode mode)
+ {
+ 	struct mlx5_flow_root_namespace *root;
+ 	const struct mlx5_flow_cmds *cmds;
+ 	int err;
+ 
+ 	root = find_root(&ns->node);
+ 	if (&root->ns != ns)
+ 	/* Can't set cmds to non root namespace */
+ 		return -EINVAL;
+ 
+ 	if (root->table_type != FS_FT_FDB)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (root->mode == mode)
+ 		return 0;
+ 
+ 	if (mode == MLX5_FLOW_STEERING_MODE_SMFS)
+ 		cmds = mlx5_fs_cmd_get_dr_cmds();
+ 	else
+ 		cmds = mlx5_fs_cmd_get_fw_cmds();
+ 	if (!cmds)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = cmds->create_ns(root);
+ 	if (err) {
+ 		mlx5_core_err(root->dev, "Failed to create flow namespace (%d)\n",
+ 			      err);
+ 		return err;
+ 	}
+ 
+ 	root->cmds->destroy_ns(root);
+ 	root->cmds = cmds;
+ 	root->mode = mode;
+ 
+ 	return 0;
+ }
++>>>>>>> 38b9d1c62a6e (net/mlx5: Add API to set the namespace steering mode)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index c1252d6be0ef,00717eba2256..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@@ -212,6 -241,8 +218,11 @@@ struct mlx5_flow_group 
  
  struct mlx5_flow_root_namespace {
  	struct mlx5_flow_namespace	ns;
++<<<<<<< HEAD
++=======
+ 	enum   mlx5_flow_steering_mode	mode;
+ 	struct mlx5_fs_dr_domain	fs_dr_domain;
++>>>>>>> 38b9d1c62a6e (net/mlx5: Add API to set the namespace steering mode)
  	enum   fs_flow_table_type	table_type;
  	struct mlx5_core_dev		*dev;
  	struct mlx5_flow_table		*root_ft;
@@@ -230,6 -260,14 +241,17 @@@ void mlx5_fc_queue_stats_work(struct ml
  void mlx5_fc_update_sampling_interval(struct mlx5_core_dev *dev,
  				      unsigned long interval);
  
++<<<<<<< HEAD
++=======
+ const struct mlx5_flow_cmds *mlx5_fs_cmd_get_fw_cmds(void);
+ 
+ int mlx5_flow_namespace_set_peer(struct mlx5_flow_root_namespace *ns,
+ 				 struct mlx5_flow_root_namespace *peer_ns);
+ 
+ int mlx5_flow_namespace_set_mode(struct mlx5_flow_namespace *ns,
+ 				 enum mlx5_flow_steering_mode mode);
+ 
++>>>>>>> 38b9d1c62a6e (net/mlx5: Add API to set the namespace steering mode)
  int mlx5_init_fs(struct mlx5_core_dev *dev);
  void mlx5_cleanup_fs(struct mlx5_core_dev *dev);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
