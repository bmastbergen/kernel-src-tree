arm64: add ptrace regsets for ptrauth key management

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-193.el8
Rebuild_CHGLOG: - [arm64] add ptrace regsets for ptrauth key management (Mark Salter) [1756103]
Rebuild_FUZZ: 92.78%
commit-author Kristina Martsenko <kristina.martsenko@arm.com>
commit d0a060be573bfbf8753a15dca35497db5e968bb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-193.el8/d0a060be.failed

Add two new ptrace regsets, which can be used to request and change the
pointer authentication keys of a thread. NT_ARM_PACA_KEYS gives access
to the instruction/data address keys, and NT_ARM_PACG_KEYS to the
generic authentication key. The keys are also part of the core dump file
of the process.

The regsets are only exposed if the kernel is compiled with
CONFIG_CHECKPOINT_RESTORE=y, as the only intended use case is
checkpointing and restoring processes that are using pointer
authentication. (This can be changed later if there are other use
cases.)

	Reviewed-by: Dave Martin <Dave.Martin@arm.com>
	Signed-off-by: Kristina Martsenko <kristina.martsenko@arm.com>
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit d0a060be573bfbf8753a15dca35497db5e968bb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/uapi/asm/ptrace.h
#	arch/arm64/kernel/ptrace.c
#	include/uapi/linux/elf.h
diff --cc arch/arm64/include/uapi/asm/ptrace.h
index a835f12fff62,d78623acb649..000000000000
--- a/arch/arm64/include/uapi/asm/ptrace.h
+++ b/arch/arm64/include/uapi/asm/ptrace.h
@@@ -230,6 -226,26 +230,29 @@@ struct user_sve_header 
  		  SVE_PT_SVE_OFFSET + SVE_PT_SVE_SIZE(vq, flags)	\
  		: SVE_PT_FPSIMD_OFFSET + SVE_PT_FPSIMD_SIZE(vq, flags))
  
++<<<<<<< HEAD
++=======
+ /* pointer authentication masks (NT_ARM_PAC_MASK) */
+ 
+ struct user_pac_mask {
+ 	__u64		data_mask;
+ 	__u64		insn_mask;
+ };
+ 
+ /* pointer authentication keys (NT_ARM_PACA_KEYS, NT_ARM_PACG_KEYS) */
+ 
+ struct user_pac_address_keys {
+ 	__uint128_t	apiakey;
+ 	__uint128_t	apibkey;
+ 	__uint128_t	apdakey;
+ 	__uint128_t	apdbkey;
+ };
+ 
+ struct user_pac_generic_keys {
+ 	__uint128_t	apgakey;
+ };
+ 
++>>>>>>> d0a060be573b (arm64: add ptrace regsets for ptrauth key management)
  #endif /* __ASSEMBLY__ */
  
  #endif /* _UAPI__ASM_PTRACE_H */
diff --cc arch/arm64/kernel/ptrace.c
index 844049737964,a86413be5a2d..000000000000
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@@ -956,6 -957,155 +956,158 @@@ out
  
  #endif /* CONFIG_ARM64_SVE */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_PTR_AUTH
+ static int pac_mask_get(struct task_struct *target,
+ 			const struct user_regset *regset,
+ 			unsigned int pos, unsigned int count,
+ 			void *kbuf, void __user *ubuf)
+ {
+ 	/*
+ 	 * The PAC bits can differ across data and instruction pointers
+ 	 * depending on TCR_EL1.TBID*, which we may make use of in future, so
+ 	 * we expose separate masks.
+ 	 */
+ 	unsigned long mask = ptrauth_user_pac_mask();
+ 	struct user_pac_mask uregs = {
+ 		.data_mask = mask,
+ 		.insn_mask = mask,
+ 	};
+ 
+ 	if (!system_supports_address_auth())
+ 		return -EINVAL;
+ 
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, &uregs, 0, -1);
+ }
+ 
+ #ifdef CONFIG_CHECKPOINT_RESTORE
+ static __uint128_t pac_key_to_user(const struct ptrauth_key *key)
+ {
+ 	return (__uint128_t)key->hi << 64 | key->lo;
+ }
+ 
+ static struct ptrauth_key pac_key_from_user(__uint128_t ukey)
+ {
+ 	struct ptrauth_key key = {
+ 		.lo = (unsigned long)ukey,
+ 		.hi = (unsigned long)(ukey >> 64),
+ 	};
+ 
+ 	return key;
+ }
+ 
+ static void pac_address_keys_to_user(struct user_pac_address_keys *ukeys,
+ 				     const struct ptrauth_keys *keys)
+ {
+ 	ukeys->apiakey = pac_key_to_user(&keys->apia);
+ 	ukeys->apibkey = pac_key_to_user(&keys->apib);
+ 	ukeys->apdakey = pac_key_to_user(&keys->apda);
+ 	ukeys->apdbkey = pac_key_to_user(&keys->apdb);
+ }
+ 
+ static void pac_address_keys_from_user(struct ptrauth_keys *keys,
+ 				       const struct user_pac_address_keys *ukeys)
+ {
+ 	keys->apia = pac_key_from_user(ukeys->apiakey);
+ 	keys->apib = pac_key_from_user(ukeys->apibkey);
+ 	keys->apda = pac_key_from_user(ukeys->apdakey);
+ 	keys->apdb = pac_key_from_user(ukeys->apdbkey);
+ }
+ 
+ static int pac_address_keys_get(struct task_struct *target,
+ 				const struct user_regset *regset,
+ 				unsigned int pos, unsigned int count,
+ 				void *kbuf, void __user *ubuf)
+ {
+ 	struct ptrauth_keys *keys = &target->thread.keys_user;
+ 	struct user_pac_address_keys user_keys;
+ 
+ 	if (!system_supports_address_auth())
+ 		return -EINVAL;
+ 
+ 	pac_address_keys_to_user(&user_keys, keys);
+ 
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+ 				   &user_keys, 0, -1);
+ }
+ 
+ static int pac_address_keys_set(struct task_struct *target,
+ 				const struct user_regset *regset,
+ 				unsigned int pos, unsigned int count,
+ 				const void *kbuf, const void __user *ubuf)
+ {
+ 	struct ptrauth_keys *keys = &target->thread.keys_user;
+ 	struct user_pac_address_keys user_keys;
+ 	int ret;
+ 
+ 	if (!system_supports_address_auth())
+ 		return -EINVAL;
+ 
+ 	pac_address_keys_to_user(&user_keys, keys);
+ 	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				 &user_keys, 0, -1);
+ 	if (ret)
+ 		return ret;
+ 	pac_address_keys_from_user(keys, &user_keys);
+ 
+ 	return 0;
+ }
+ 
+ static void pac_generic_keys_to_user(struct user_pac_generic_keys *ukeys,
+ 				     const struct ptrauth_keys *keys)
+ {
+ 	ukeys->apgakey = pac_key_to_user(&keys->apga);
+ }
+ 
+ static void pac_generic_keys_from_user(struct ptrauth_keys *keys,
+ 				       const struct user_pac_generic_keys *ukeys)
+ {
+ 	keys->apga = pac_key_from_user(ukeys->apgakey);
+ }
+ 
+ static int pac_generic_keys_get(struct task_struct *target,
+ 				const struct user_regset *regset,
+ 				unsigned int pos, unsigned int count,
+ 				void *kbuf, void __user *ubuf)
+ {
+ 	struct ptrauth_keys *keys = &target->thread.keys_user;
+ 	struct user_pac_generic_keys user_keys;
+ 
+ 	if (!system_supports_generic_auth())
+ 		return -EINVAL;
+ 
+ 	pac_generic_keys_to_user(&user_keys, keys);
+ 
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+ 				   &user_keys, 0, -1);
+ }
+ 
+ static int pac_generic_keys_set(struct task_struct *target,
+ 				const struct user_regset *regset,
+ 				unsigned int pos, unsigned int count,
+ 				const void *kbuf, const void __user *ubuf)
+ {
+ 	struct ptrauth_keys *keys = &target->thread.keys_user;
+ 	struct user_pac_generic_keys user_keys;
+ 	int ret;
+ 
+ 	if (!system_supports_generic_auth())
+ 		return -EINVAL;
+ 
+ 	pac_generic_keys_to_user(&user_keys, keys);
+ 	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				 &user_keys, 0, -1);
+ 	if (ret)
+ 		return ret;
+ 	pac_generic_keys_from_user(keys, &user_keys);
+ 
+ 	return 0;
+ }
+ #endif /* CONFIG_CHECKPOINT_RESTORE */
+ #endif /* CONFIG_ARM64_PTR_AUTH */
+ 
++>>>>>>> d0a060be573b (arm64: add ptrace regsets for ptrauth key management)
  enum aarch64_regset {
  	REGSET_GPR,
  	REGSET_FPR,
@@@ -968,6 -1118,13 +1120,16 @@@
  #ifdef CONFIG_ARM64_SVE
  	REGSET_SVE,
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_PTR_AUTH
+ 	REGSET_PAC_MASK,
+ #ifdef CONFIG_CHECKPOINT_RESTORE
+ 	REGSET_PACA_KEYS,
+ 	REGSET_PACG_KEYS,
+ #endif
+ #endif
++>>>>>>> d0a060be573b (arm64: add ptrace regsets for ptrauth key management)
  };
  
  static const struct user_regset aarch64_regsets[] = {
@@@ -1037,6 -1194,34 +1199,37 @@@
  		.get_size = sve_get_size,
  	},
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_PTR_AUTH
+ 	[REGSET_PAC_MASK] = {
+ 		.core_note_type = NT_ARM_PAC_MASK,
+ 		.n = sizeof(struct user_pac_mask) / sizeof(u64),
+ 		.size = sizeof(u64),
+ 		.align = sizeof(u64),
+ 		.get = pac_mask_get,
+ 		/* this cannot be set dynamically */
+ 	},
+ #ifdef CONFIG_CHECKPOINT_RESTORE
+ 	[REGSET_PACA_KEYS] = {
+ 		.core_note_type = NT_ARM_PACA_KEYS,
+ 		.n = sizeof(struct user_pac_address_keys) / sizeof(__uint128_t),
+ 		.size = sizeof(__uint128_t),
+ 		.align = sizeof(__uint128_t),
+ 		.get = pac_address_keys_get,
+ 		.set = pac_address_keys_set,
+ 	},
+ 	[REGSET_PACG_KEYS] = {
+ 		.core_note_type = NT_ARM_PACG_KEYS,
+ 		.n = sizeof(struct user_pac_generic_keys) / sizeof(__uint128_t),
+ 		.size = sizeof(__uint128_t),
+ 		.align = sizeof(__uint128_t),
+ 		.get = pac_generic_keys_get,
+ 		.set = pac_generic_keys_set,
+ 	},
+ #endif
+ #endif
++>>>>>>> d0a060be573b (arm64: add ptrace regsets for ptrauth key management)
  };
  
  static const struct user_regset_view user_aarch64_view = {
diff --cc include/uapi/linux/elf.h
index 4e12c423b9fe,34c02e4290fe..000000000000
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@@ -420,8 -420,14 +420,14 @@@ typedef struct elf64_shdr 
  #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
  #define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
  #define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
++<<<<<<< HEAD
++=======
+ #define NT_ARM_PAC_MASK		0x406	/* ARM pointer authentication code masks */
+ #define NT_ARM_PACA_KEYS	0x407	/* ARM pointer authentication address keys */
+ #define NT_ARM_PACG_KEYS	0x408	/* ARM pointer authentication generic key */
++>>>>>>> d0a060be573b (arm64: add ptrace regsets for ptrauth key management)
  #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
  #define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
 -#define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */
 -#define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
 -#define NT_MIPS_MSA	0x802		/* MIPS SIMD registers */
  
  /* Note header in a PT_NOTE section */
  typedef struct elf32_note {
diff --git a/Documentation/arm64/pointer-authentication.txt b/Documentation/arm64/pointer-authentication.txt
index a25cd21290e9..5baca42ba146 100644
--- a/Documentation/arm64/pointer-authentication.txt
+++ b/Documentation/arm64/pointer-authentication.txt
@@ -78,6 +78,11 @@ bits can vary between the two. Note that the masks apply to TTBR0
 addresses, and are not valid to apply to TTBR1 addresses (e.g. kernel
 pointers).
 
+Additionally, when CONFIG_CHECKPOINT_RESTORE is also set, the kernel
+will expose the NT_ARM_PACA_KEYS and NT_ARM_PACG_KEYS regsets (struct
+user_pac_address_keys and struct user_pac_generic_keys). These can be
+used to get and set the keys for a thread.
+
 
 Virtualization
 --------------
* Unmerged path arch/arm64/include/uapi/asm/ptrace.h
* Unmerged path arch/arm64/kernel/ptrace.c
* Unmerged path include/uapi/linux/elf.h
