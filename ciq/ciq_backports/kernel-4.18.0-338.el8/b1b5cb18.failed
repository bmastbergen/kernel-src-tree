ch_ktls: Correction in finding correct length

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit b1b5cb18032b37ab69b23a461eb8be1a44fcfc3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/b1b5cb18.failed

There is a possibility of linear skbs coming in. Correcting
the length extraction logic.

v2->v3:
- Separated un-related changes from this patch.

Fixes: 5a4b9fe7fece ("cxgb4/chcr: complete record tx handling")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit b1b5cb18032b37ab69b23a461eb8be1a44fcfc3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_ktls.c
diff --cc drivers/crypto/chelsio/chcr_ktls.c
index 640fa34b6566,447aec7ae954..000000000000
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@@ -1826,30 -1858,29 +1826,37 @@@ out
  }
  
  /* nic tls TX handler */
 -static int chcr_ktls_xmit(struct sk_buff *skb, struct net_device *dev)
 +int chcr_ktls_xmit(struct sk_buff *skb, struct net_device *dev)
  {
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
++=======
+ 	u32 tls_end_offset, tcp_seq, skb_data_len, skb_offset;
+ 	struct ch_ktls_port_stats_debug *port_stats;
++>>>>>>> b1b5cb18032b (ch_ktls: Correction in finding correct length):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  	struct chcr_ktls_ofld_ctx_tx *tx_ctx;
 -	struct ch_ktls_stats_debug *stats;
  	struct tcphdr *th = tcp_hdr(skb);
  	int data_len, qidx, ret = 0, mss;
  	struct tls_record_info *record;
 +	struct chcr_stats_debug *stats;
  	struct chcr_ktls_info *tx_info;
- 	u32 tls_end_offset, tcp_seq;
  	struct tls_context *tls_ctx;
  	struct sk_buff *local_skb;
 +	int new_connection_state;
  	struct sge_eth_txq *q;
  	struct adapter *adap;
  	unsigned long flags;
  
  	tcp_seq = ntohl(th->seq);
+ 	skb_offset = skb_transport_offset(skb) + tcp_hdrlen(skb);
+ 	skb_data_len = skb->len - skb_offset;
+ 	data_len = skb_data_len;
  
- 	mss = skb_is_gso(skb) ? skb_shinfo(skb)->gso_size : skb->data_len;
+ 	mss = skb_is_gso(skb) ? skb_shinfo(skb)->gso_size : data_len;
  
 +	/* check if we haven't set it for ktls offload */
 +	if (!skb->sk || !tls_is_sk_tx_device_offloaded(skb->sk))
 +		goto out;
 +
  	tls_ctx = tls_get_ctx(skb->sk);
  	if (unlikely(tls_ctx->netdev != dev))
  		goto out;
@@@ -2000,10 -2021,9 +2005,16 @@@ clear_ref
  
  	} while (data_len > 0);
  
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +	tx_info->prev_seq = ntohl(th->seq) + skb->data_len;
 +
 +	atomic64_inc(&stats->ktls_tx_encrypted_packets);
 +	atomic64_add(skb->data_len, &stats->ktls_tx_encrypted_bytes);
++=======
+ 	tx_info->prev_seq = ntohl(th->seq) + skb_data_len;
+ 	atomic64_inc(&port_stats->ktls_tx_encrypted_packets);
+ 	atomic64_add(skb_data_len, &port_stats->ktls_tx_encrypted_bytes);
++>>>>>>> b1b5cb18032b (ch_ktls: Correction in finding correct length):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  
  	/* tcp finish is set, send a separate tcp msg including all the options
  	 * as well.
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
