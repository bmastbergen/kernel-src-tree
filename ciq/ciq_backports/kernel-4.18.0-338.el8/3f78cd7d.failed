fs: dlm: fix mark per nodeid setting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Alexander Aring <aahringo@redhat.com>
commit 3f78cd7d2449a07904b3a23751758cbdeaaa20f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/3f78cd7d.failed

This patch fixes to set per nodeid mark configuration for accepted
sockets as well. Before this patch only the listen socket mark value was
used for all accepted connections. This patch will ensure that the
cluster mark attribute value will be always used for all sockets, if a
per nodeid mark value is specified dlm will use this value for the
specific node.

	Signed-off-by: Alexander Aring <aahringo@redhat.com>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit 3f78cd7d2449a07904b3a23751758cbdeaaa20f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/config.c
#	fs/dlm/config.h
#	fs/dlm/lowcomms.c
diff --cc fs/dlm/config.c
index 1270551d24e3,ca4a9795afbe..000000000000
--- a/fs/dlm/config.c
+++ b/fs/dlm/config.c
@@@ -831,6 -860,24 +831,27 @@@ int dlm_comm_seq(int nodeid, uint32_t *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void dlm_comm_mark(int nodeid, unsigned int *mark)
+ {
+ 	struct dlm_comm *cm;
+ 
+ 	cm = get_comm(nodeid);
+ 	if (!cm) {
+ 		*mark = dlm_config.ci_mark;
+ 		return;
+ 	}
+ 
+ 	if (cm->mark)
+ 		*mark = cm->mark;
+ 	else
+ 		*mark = dlm_config.ci_mark;
+ 
+ 	put_comm(cm);
+ }
+ 
++>>>>>>> 3f78cd7d2449 (fs: dlm: fix mark per nodeid setting)
  int dlm_our_nodeid(void)
  {
  	return local_comm ? local_comm->nodeid : 0;
diff --cc fs/dlm/config.h
index 6041eec886ab,3b284ae9aeeb..000000000000
--- a/fs/dlm/config.h
+++ b/fs/dlm/config.h
@@@ -47,6 -46,7 +47,10 @@@ void dlm_config_exit(void)
  int dlm_config_nodes(char *lsname, struct dlm_config_node **nodes_out,
  		     int *count_out);
  int dlm_comm_seq(int nodeid, uint32_t *seq);
++<<<<<<< HEAD
++=======
+ void dlm_comm_mark(int nodeid, unsigned int *mark);
++>>>>>>> 3f78cd7d2449 (fs: dlm: fix mark per nodeid setting)
  int dlm_our_nodeid(void);
  int dlm_our_addr(struct sockaddr_storage *addr, int num);
  
diff --cc fs/dlm/lowcomms.c
index 2ece988dabc6,96f84541867c..000000000000
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@@ -735,13 -790,11 +735,14 @@@ static int tcp_accept_from_sock(struct 
  	int nodeid;
  	struct connection *newcon;
  	struct connection *addcon;
+ 	unsigned int mark;
  
 +	mutex_lock(&connections_lock);
  	if (!dlm_allow_conn) {
 +		mutex_unlock(&connections_lock);
  		return -1;
  	}
 +	mutex_unlock(&connections_lock);
  
  	mutex_lock_nested(&con->sock_mutex, 0);
  
@@@ -1044,6 -975,8 +1048,11 @@@ static void sctp_connect_to_sock(struc
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	dlm_comm_mark(con->nodeid, &mark);
+ 
++>>>>>>> 3f78cd7d2449 (fs: dlm: fix mark per nodeid setting)
  	mutex_lock(&con->sock_mutex);
  
  	/* Some odd races can cause double-connects, ignore them */
@@@ -1141,6 -1073,8 +1150,11 @@@ static void tcp_connect_to_sock(struct 
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	dlm_comm_mark(con->nodeid, &mark);
+ 
++>>>>>>> 3f78cd7d2449 (fs: dlm: fix mark per nodeid setting)
  	mutex_lock(&con->sock_mutex);
  	if (con->retries++ > MAX_CONNECT_RETRIES)
  		goto out;
* Unmerged path fs/dlm/config.c
* Unmerged path fs/dlm/config.h
* Unmerged path fs/dlm/lowcomms.c
