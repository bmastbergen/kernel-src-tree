bpf: Wrap aux data inside bpf_sanitize_info container

jira LE-1907
cve CVE-2021-29155
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 3d0220f6861d713213b015b582e9f21e5b28d2e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/3d0220f6.failed

Add a container structure struct bpf_sanitize_info which holds
the current aux info, and update call-sites to sanitize_ptr_alu()
to pass it in. This is needed for passing in additional state
later on.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Reviewed-by: Piotr Krysiuk <piotras@gmail.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 3d0220f6861d713213b015b582e9f21e5b28d2e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index e65c8ec142c6,98690f5367f9..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5848,14 -6481,26 +5848,34 @@@ static int sanitize_val_alu(struct bpf_
  	return update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static bool sanitize_needed(u8 opcode)
+ {
+ 	return opcode == BPF_ADD || opcode == BPF_SUB;
+ }
+ 
+ struct bpf_sanitize_info {
+ 	struct bpf_insn_aux_data aux;
+ };
+ 
++>>>>>>> 3d0220f6861d (bpf: Wrap aux data inside bpf_sanitize_info container)
  static int sanitize_ptr_alu(struct bpf_verifier_env *env,
  			    struct bpf_insn *insn,
  			    const struct bpf_reg_state *ptr_reg,
  			    const struct bpf_reg_state *off_reg,
++<<<<<<< HEAD
 +			    struct bpf_reg_state *dst_reg)
 +{
++=======
+ 			    struct bpf_reg_state *dst_reg,
+ 			    struct bpf_sanitize_info *info,
+ 			    const bool commit_window)
+ {
+ 	struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : &info->aux;
++>>>>>>> 3d0220f6861d (bpf: Wrap aux data inside bpf_sanitize_info container)
  	struct bpf_verifier_state *vstate = env->cur_state;
 -	bool off_is_imm = tnum_is_const(off_reg->var_off);
 +	struct bpf_insn_aux_data *aux = cur_aux(env);
  	bool off_is_neg = off_reg->smin_value < 0;
  	bool ptr_is_dst_reg = ptr_reg == dst_reg;
  	u8 opcode = BPF_OP(insn->code);
@@@ -5882,6 -6523,19 +5902,22 @@@
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
++=======
+ 	if (commit_window) {
+ 		/* In commit phase we narrow the masking window based on
+ 		 * the observed pointer move after the simulated operation.
+ 		 */
+ 		alu_state = info->aux.alu_state;
+ 		alu_limit = abs(info->aux.alu_limit - alu_limit);
+ 	} else {
+ 		alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;
+ 		alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;
+ 		alu_state |= ptr_is_dst_reg ?
+ 			     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;
+ 	}
+ 
++>>>>>>> 3d0220f6861d (bpf: Wrap aux data inside bpf_sanitize_info container)
  	err = update_alu_sanitation_state(aux, alu_state, alu_limit);
  	if (err < 0)
  		return err;
@@@ -5989,8 -6689,9 +6025,12 @@@ static int adjust_ptr_min_max_vals(stru
  	    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;
  	u64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,
  	    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;
++<<<<<<< HEAD
 +	u32 dst = insn->dst_reg, src = insn->src_reg;
++=======
+ 	struct bpf_sanitize_info info = {};
++>>>>>>> 3d0220f6861d (bpf: Wrap aux data inside bpf_sanitize_info container)
  	u8 opcode = BPF_OP(insn->code);
 -	u32 dst = insn->dst_reg;
  	int ret;
  
  	dst_reg = &regs[dst];
@@@ -6062,13 -6756,15 +6102,23 @@@
  	/* pointer types do not carry 32-bit bounds at the moment. */
  	__mark_reg32_unbounded(dst_reg);
  
++<<<<<<< HEAD
++=======
+ 	if (sanitize_needed(opcode)) {
+ 		ret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg,
+ 				       &info, false);
+ 		if (ret < 0)
+ 			return sanitize_err(env, insn, ret, off_reg, dst_reg);
+ 	}
+ 
++>>>>>>> 3d0220f6861d (bpf: Wrap aux data inside bpf_sanitize_info container)
  	switch (opcode) {
  	case BPF_ADD:
 +		ret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg);
 +		if (ret < 0) {
 +			verbose(env, "R%d tried to add from different maps, paths, or prohibited types\n", dst);
 +			return ret;
 +		}
  		/* We can take a fixed offset as long as it doesn't overflow
  		 * the s32 'off' field
  		 */
@@@ -6206,6 -6897,12 +6256,15 @@@
  
  	if (sanitize_check_bounds(env, insn, dst_reg) < 0)
  		return -EACCES;
++<<<<<<< HEAD
++=======
+ 	if (sanitize_needed(opcode)) {
+ 		ret = sanitize_ptr_alu(env, insn, dst_reg, off_reg, dst_reg,
+ 				       &info, true);
+ 		if (ret < 0)
+ 			return sanitize_err(env, insn, ret, off_reg, dst_reg);
+ 	}
++>>>>>>> 3d0220f6861d (bpf: Wrap aux data inside bpf_sanitize_info container)
  
  	return 0;
  }
* Unmerged path kernel/bpf/verifier.c
