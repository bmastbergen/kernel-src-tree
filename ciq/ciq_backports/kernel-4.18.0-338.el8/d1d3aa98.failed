arm64: tlb: Use the TLBI RANGE feature in arm64

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Zhenyu Ye <yezhenyu2@huawei.com>
commit d1d3aa98b1d4826a19adfefb69b96142a0cac633
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/d1d3aa98.failed

Add __TLBI_VADDR_RANGE macro and rewrite __flush_tlb_range().

When cpu supports TLBI feature, the minimum range granularity is
decided by 'scale', so we can not flush all pages by one instruction
in some cases.

For example, when the pages = 0xe81a, let's start 'scale' from
maximum, and find right 'num' for each 'scale':

1. scale = 3, we can flush no pages because the minimum range is
   2^(5*3 + 1) = 0x10000.
2. scale = 2, the minimum range is 2^(5*2 + 1) = 0x800, we can
   flush 0xe800 pages this time, the num = 0xe800/0x800 - 1 = 0x1c.
   Remaining pages is 0x1a;
3. scale = 1, the minimum range is 2^(5*1 + 1) = 0x40, no page
   can be flushed.
4. scale = 0, we flush the remaining 0x1a pages, the num =
   0x1a/0x2 - 1 = 0xd.

However, in most scenarios, the pages = 1 when flush_tlb_range() is
called. Start from scale = 3 or other proper value (such as scale =
ilog2(pages)), will incur extra overhead.
So increase 'scale' from 0 to maximum, the flush order is exactly
opposite to the example.

	Signed-off-by: Zhenyu Ye <yezhenyu2@huawei.com>
Link: https://lore.kernel.org/r/20200715071945.897-4-yezhenyu2@huawei.com
[catalin.marinas@arm.com: removed unnecessary masks in __TLBI_VADDR_RANGE]
[catalin.marinas@arm.com: __TLB_RANGE_NUM subtracts 1]
[catalin.marinas@arm.com: minor adjustments to the comments]
[catalin.marinas@arm.com: introduce system_supports_tlb_range()]
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit d1d3aa98b1d4826a19adfefb69b96142a0cac633)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/cpufeature.h
#	arch/arm64/include/asm/tlbflush.h
diff --cc arch/arm64/include/asm/cpufeature.h
index 20b808bf353e,cf56daa95a7d..000000000000
--- a/arch/arm64/include/asm/cpufeature.h
+++ b/arch/arm64/include/asm/cpufeature.h
@@@ -698,6 -687,23 +698,26 @@@ static inline bool system_has_prio_mask
  	       system_uses_irq_prio_masking();
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool system_supports_bti(void)
+ {
+ 	return IS_ENABLED(CONFIG_ARM64_BTI) && cpus_have_const_cap(ARM64_BTI);
+ }
+ 
+ static inline bool system_supports_tlb_range(void)
+ {
+ 	return IS_ENABLED(CONFIG_ARM64_TLB_RANGE) &&
+ 		cpus_have_const_cap(ARM64_HAS_TLB_RANGE);
+ }
+ 
+ #define ARM64_BP_HARDEN_UNKNOWN		-1
+ #define ARM64_BP_HARDEN_WA_NEEDED	0
+ #define ARM64_BP_HARDEN_NOT_REQUIRED	1
+ 
+ int get_spectre_v2_workaround_state(void);
+ 
++>>>>>>> d1d3aa98b1d4 (arm64: tlb: Use the TLBI RANGE feature in arm64)
  #define ARM64_SSBD_UNKNOWN		-1
  #define ARM64_SSBD_FORCE_DISABLE	0
  #define ARM64_SSBD_KERNEL		1
diff --cc arch/arm64/include/asm/tlbflush.h
index a5b457f860a3,d493174415db..000000000000
--- a/arch/arm64/include/asm/tlbflush.h
+++ b/arch/arm64/include/asm/tlbflush.h
@@@ -71,6 -61,102 +71,105 @@@
  	})
  
  /*
++<<<<<<< HEAD
++=======
+  * Get translation granule of the system, which is decided by
+  * PAGE_SIZE.  Used by TTL.
+  *  - 4KB	: 1
+  *  - 16KB	: 2
+  *  - 64KB	: 3
+  */
+ #define TLBI_TTL_TG_4K		1
+ #define TLBI_TTL_TG_16K		2
+ #define TLBI_TTL_TG_64K		3
+ 
+ static inline unsigned long get_trans_granule(void)
+ {
+ 	switch (PAGE_SIZE) {
+ 	case SZ_4K:
+ 		return TLBI_TTL_TG_4K;
+ 	case SZ_16K:
+ 		return TLBI_TTL_TG_16K;
+ 	case SZ_64K:
+ 		return TLBI_TTL_TG_64K;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ /*
+  * Level-based TLBI operations.
+  *
+  * When ARMv8.4-TTL exists, TLBI operations take an additional hint for
+  * the level at which the invalidation must take place. If the level is
+  * wrong, no invalidation may take place. In the case where the level
+  * cannot be easily determined, a 0 value for the level parameter will
+  * perform a non-hinted invalidation.
+  *
+  * For Stage-2 invalidation, use the level values provided to that effect
+  * in asm/stage2_pgtable.h.
+  */
+ #define TLBI_TTL_MASK		GENMASK_ULL(47, 44)
+ 
+ #define __tlbi_level(op, addr, level) do {				\
+ 	u64 arg = addr;							\
+ 									\
+ 	if (cpus_have_const_cap(ARM64_HAS_ARMv8_4_TTL) &&		\
+ 	    level) {							\
+ 		u64 ttl = level & 3;					\
+ 		ttl |= get_trans_granule() << 2;			\
+ 		arg &= ~TLBI_TTL_MASK;					\
+ 		arg |= FIELD_PREP(TLBI_TTL_MASK, ttl);			\
+ 	}								\
+ 									\
+ 	__tlbi(op, arg);						\
+ } while(0)
+ 
+ #define __tlbi_user_level(op, arg, level) do {				\
+ 	if (arm64_kernel_unmapped_at_el0())				\
+ 		__tlbi_level(op, (arg | USER_ASID_FLAG), level);	\
+ } while (0)
+ 
+ /*
+  * This macro creates a properly formatted VA operand for the TLB RANGE.
+  * The value bit assignments are:
+  *
+  * +----------+------+-------+-------+-------+----------------------+
+  * |   ASID   |  TG  | SCALE |  NUM  |  TTL  |        BADDR         |
+  * +-----------------+-------+-------+-------+----------------------+
+  * |63      48|47  46|45   44|43   39|38   37|36                   0|
+  *
+  * The address range is determined by below formula:
+  * [BADDR, BADDR + (NUM + 1) * 2^(5*SCALE + 1) * PAGESIZE)
+  *
+  */
+ #define __TLBI_VADDR_RANGE(addr, asid, scale, num, ttl)		\
+ 	({							\
+ 		unsigned long __ta = (addr) >> PAGE_SHIFT;	\
+ 		__ta &= GENMASK_ULL(36, 0);			\
+ 		__ta |= (unsigned long)(ttl) << 37;		\
+ 		__ta |= (unsigned long)(num) << 39;		\
+ 		__ta |= (unsigned long)(scale) << 44;		\
+ 		__ta |= get_trans_granule() << 46;		\
+ 		__ta |= (unsigned long)(asid) << 48;		\
+ 		__ta;						\
+ 	})
+ 
+ /* These macros are used by the TLBI RANGE feature. */
+ #define __TLBI_RANGE_PAGES(num, scale)	\
+ 	((unsigned long)((num) + 1) << (5 * (scale) + 1))
+ #define MAX_TLBI_RANGE_PAGES		__TLBI_RANGE_PAGES(31, 3)
+ 
+ /*
+  * Generate 'num' values from -1 to 30 with -1 rejected by the
+  * __flush_tlb_range() loop below.
+  */
+ #define TLBI_RANGE_MASK			GENMASK_ULL(4, 0)
+ #define __TLBI_RANGE_NUM(pages, scale)	\
+ 	((((pages) >> (5 * (scale) + 1)) & TLBI_RANGE_MASK) - 1)
+ 
+ /*
++>>>>>>> d1d3aa98b1d4 (arm64: tlb: Use the TLBI RANGE feature in arm64)
   *	TLB Invalidation
   *	================
   *
@@@ -254,61 -276,85 +353,138 @@@ static inline void flush_tlb_page(struc
  
  static inline void __flush_tlb_range(struct vm_area_struct *vma,
  				     unsigned long start, unsigned long end,
 -				     unsigned long stride, bool last_level,
 -				     int tlb_level)
 +				     unsigned long stride, bool last_level)
  {
++<<<<<<< HEAD
 +	struct mm_struct *mm = vma->vm_mm;
 +	unsigned long asid = ASID(mm);
 +	unsigned long addr;
 +	enum tlb_flush_types flush;
 +
 +	if ((end - start) > (MAX_TLBI_OPS * stride)) {
 +		flush_tlb_mm(mm);
 +		return;
 +	}
 +
 +	/* Convert the stride into units of 4k */
 +	stride >>= 12;
 +
 +	start = __TLBI_VADDR(start, asid);
 +	end = __TLBI_VADDR(end, asid);
 +
 +	flush = tlb_flush_check(mm, get_cpu());
 +	switch (flush) {
 +	case TLB_FLUSH_LOCAL:
 +
 +		dsb(nshst);
 +		for (addr = start; addr < end; addr += stride) {
 +			if (last_level) {
 +				__tlbi(vale1, addr);
 +				__tlbi_user(vale1, addr);
 +			} else {
 +				__tlbi(vae1, addr);
 +				__tlbi_user(vae1, addr);
 +			}
 +		}
 +		dsb(nsh);
 +
 +		/* fall through */
 +	case TLB_FLUSH_NO:
 +		put_cpu();
 +		break;
 +	case TLB_FLUSH_BROADCAST:
 +		put_cpu();
 +
 +		dsb(ishst);
 +		for (addr = start; addr < end; addr += stride) {
 +			if (last_level) {
 +				__tlbi(vale1is, addr);
 +				__tlbi_user(vale1is, addr);
 +			} else {
 +				__tlbi(vae1is, addr);
 +				__tlbi_user(vae1is, addr);
 +			}
 +		}
 +		dsb(ish);
 +
 +		break;
++=======
+ 	int num = 0;
+ 	int scale = 0;
+ 	unsigned long asid = ASID(vma->vm_mm);
+ 	unsigned long addr;
+ 	unsigned long pages;
+ 
+ 	start = round_down(start, stride);
+ 	end = round_up(end, stride);
+ 	pages = (end - start) >> PAGE_SHIFT;
+ 
+ 	/*
+ 	 * When not uses TLB range ops, we can handle up to
+ 	 * (MAX_TLBI_OPS - 1) pages;
+ 	 * When uses TLB range ops, we can handle up to
+ 	 * (MAX_TLBI_RANGE_PAGES - 1) pages.
+ 	 */
+ 	if ((!system_supports_tlb_range() &&
+ 	     (end - start) >= (MAX_TLBI_OPS * stride)) ||
+ 	    pages >= MAX_TLBI_RANGE_PAGES) {
+ 		flush_tlb_mm(vma->vm_mm);
+ 		return;
+ 	}
+ 
+ 	dsb(ishst);
+ 
+ 	/*
+ 	 * When the CPU does not support TLB range operations, flush the TLB
+ 	 * entries one by one at the granularity of 'stride'. If the the TLB
+ 	 * range ops are supported, then:
+ 	 *
+ 	 * 1. If 'pages' is odd, flush the first page through non-range
+ 	 *    operations;
+ 	 *
+ 	 * 2. For remaining pages: the minimum range granularity is decided
+ 	 *    by 'scale', so multiple range TLBI operations may be required.
+ 	 *    Start from scale = 0, flush the corresponding number of pages
+ 	 *    ((num+1)*2^(5*scale+1) starting from 'addr'), then increase it
+ 	 *    until no pages left.
+ 	 *
+ 	 * Note that certain ranges can be represented by either num = 31 and
+ 	 * scale or num = 0 and scale + 1. The loop below favours the latter
+ 	 * since num is limited to 30 by the __TLBI_RANGE_NUM() macro.
+ 	 */
+ 	while (pages > 0) {
+ 		if (!system_supports_tlb_range() ||
+ 		    pages % 2 == 1) {
+ 			addr = __TLBI_VADDR(start, asid);
+ 			if (last_level) {
+ 				__tlbi_level(vale1is, addr, tlb_level);
+ 				__tlbi_user_level(vale1is, addr, tlb_level);
+ 			} else {
+ 				__tlbi_level(vae1is, addr, tlb_level);
+ 				__tlbi_user_level(vae1is, addr, tlb_level);
+ 			}
+ 			start += stride;
+ 			pages -= stride >> PAGE_SHIFT;
+ 			continue;
+ 		}
+ 
+ 		num = __TLBI_RANGE_NUM(pages, scale);
+ 		if (num >= 0) {
+ 			addr = __TLBI_VADDR_RANGE(start, asid, scale,
+ 						  num, tlb_level);
+ 			if (last_level) {
+ 				__tlbi(rvale1is, addr);
+ 				__tlbi_user(rvale1is, addr);
+ 			} else {
+ 				__tlbi(rvae1is, addr);
+ 				__tlbi_user(rvae1is, addr);
+ 			}
+ 			start += __TLBI_RANGE_PAGES(num, scale) << PAGE_SHIFT;
+ 			pages -= __TLBI_RANGE_PAGES(num, scale);
+ 		}
+ 		scale++;
++>>>>>>> d1d3aa98b1d4 (arm64: tlb: Use the TLBI RANGE feature in arm64)
  	}
 -	dsb(ish);
  }
  
  static inline void flush_tlb_range(struct vm_area_struct *vma,
* Unmerged path arch/arm64/include/asm/cpufeature.h
* Unmerged path arch/arm64/include/asm/tlbflush.h
