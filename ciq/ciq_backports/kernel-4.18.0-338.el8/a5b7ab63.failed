fs: dlm: set skb mark for listen socket

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Alexander Aring <aahringo@redhat.com>
commit a5b7ab6352bfaab6eec4df6618a135341d72c247
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/a5b7ab63.failed

This patch adds support to set the skb mark value for the DLM listen
tcp and sctp sockets. The mark value will be offered as cluster
configuration. At creation time of the listen socket it will be set as
socket option.

	Signed-off-by: Alexander Aring <aahringo@redhat.com>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit a5b7ab6352bfaab6eec4df6618a135341d72c247)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/lowcomms.c
diff --cc fs/dlm/lowcomms.c
index 2ece988dabc6,eaedad7d069a..000000000000
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@@ -1314,15 -1186,9 +1316,21 @@@ static int sctp_listen_for_all(void
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	result = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,
 +				 (char *)&bufsize, sizeof(bufsize));
 +	if (result)
 +		log_print("Error increasing buffer space on socket %d", result);
 +
 +	result = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,
 +				   sizeof(one));
 +	if (result < 0)
 +		log_print("Could not set SCTP NODELAY error %d\n", result);
++=======
+ 	sock_set_rcvbuf(sock->sk, NEEDED_RMEM);
+ 	sock_set_mark(sock->sk, dlm_config.ci_mark);
+ 	sctp_sock_set_nodelay(sock->sk);
++>>>>>>> a5b7ab6352bf (fs: dlm: set skb mark for listen socket)
  
  	write_lock_bh(&sock->sk->sk_callback_lock);
  	/* Init con struct */
diff --git a/fs/dlm/config.c b/fs/dlm/config.c
index 1270551d24e3..e34d9b53b490 100644
--- a/fs/dlm/config.c
+++ b/fs/dlm/config.c
@@ -75,6 +75,7 @@ struct dlm_cluster {
 	unsigned int cl_log_debug;
 	unsigned int cl_log_info;
 	unsigned int cl_protocol;
+	unsigned int cl_mark;
 	unsigned int cl_timewarn_cs;
 	unsigned int cl_waitwarn_us;
 	unsigned int cl_new_rsb_count;
@@ -98,6 +99,7 @@ enum {
 	CLUSTER_ATTR_LOG_DEBUG,
 	CLUSTER_ATTR_LOG_INFO,
 	CLUSTER_ATTR_PROTOCOL,
+	CLUSTER_ATTR_MARK,
 	CLUSTER_ATTR_TIMEWARN_CS,
 	CLUSTER_ATTR_WAITWARN_US,
 	CLUSTER_ATTR_NEW_RSB_COUNT,
@@ -170,6 +172,7 @@ CLUSTER_ATTR(scan_secs, 1);
 CLUSTER_ATTR(log_debug, 0);
 CLUSTER_ATTR(log_info, 0);
 CLUSTER_ATTR(protocol, 0);
+CLUSTER_ATTR(mark, 0);
 CLUSTER_ATTR(timewarn_cs, 1);
 CLUSTER_ATTR(waitwarn_us, 0);
 CLUSTER_ATTR(new_rsb_count, 0);
@@ -185,6 +188,7 @@ static struct configfs_attribute *cluster_attrs[] = {
 	[CLUSTER_ATTR_LOG_DEBUG] = &cluster_attr_log_debug,
 	[CLUSTER_ATTR_LOG_INFO] = &cluster_attr_log_info,
 	[CLUSTER_ATTR_PROTOCOL] = &cluster_attr_protocol,
+	[CLUSTER_ATTR_MARK] = &cluster_attr_mark,
 	[CLUSTER_ATTR_TIMEWARN_CS] = &cluster_attr_timewarn_cs,
 	[CLUSTER_ATTR_WAITWARN_US] = &cluster_attr_waitwarn_us,
 	[CLUSTER_ATTR_NEW_RSB_COUNT] = &cluster_attr_new_rsb_count,
@@ -857,6 +861,7 @@ int dlm_our_addr(struct sockaddr_storage *addr, int num)
 #define DEFAULT_LOG_DEBUG          0
 #define DEFAULT_LOG_INFO           1
 #define DEFAULT_PROTOCOL           0
+#define DEFAULT_MARK               0
 #define DEFAULT_TIMEWARN_CS      500 /* 5 sec = 500 centiseconds */
 #define DEFAULT_WAITWARN_US	   0
 #define DEFAULT_NEW_RSB_COUNT    128
@@ -873,6 +878,7 @@ struct dlm_config_info dlm_config = {
 	.ci_log_debug = DEFAULT_LOG_DEBUG,
 	.ci_log_info = DEFAULT_LOG_INFO,
 	.ci_protocol = DEFAULT_PROTOCOL,
+	.ci_mark = DEFAULT_MARK,
 	.ci_timewarn_cs = DEFAULT_TIMEWARN_CS,
 	.ci_waitwarn_us = DEFAULT_WAITWARN_US,
 	.ci_new_rsb_count = DEFAULT_NEW_RSB_COUNT,
diff --git a/fs/dlm/config.h b/fs/dlm/config.h
index 6041eec886ab..3b25c975e4b2 100644
--- a/fs/dlm/config.h
+++ b/fs/dlm/config.h
@@ -33,6 +33,7 @@ struct dlm_config_info {
 	int ci_log_debug;
 	int ci_log_info;
 	int ci_protocol;
+	int ci_mark;
 	int ci_timewarn_cs;
 	int ci_waitwarn_us;
 	int ci_new_rsb_count;
* Unmerged path fs/dlm/lowcomms.c
