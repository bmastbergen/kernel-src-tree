ch_ktls: don't free skb before sending FIN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit 659bf0383d15b07e492e27443d87736b24171558
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/659bf038.failed

If its a last packet and fin is set. Make sure FIN is informed
to HW before skb gets freed.

Fixes: 429765a149f1 ("chcr: handle partial end part of a record")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 659bf0383d15b07e492e27443d87736b24171558)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_ktls.c
diff --cc drivers/crypto/chelsio/chcr_ktls.c
index 074af13f5bc4,a8062e038ebc..000000000000
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@@ -1935,10 -1909,64 +1935,41 @@@ int chcr_ktls_xmit(struct sk_buff *skb
  			goto out;
  		}
  
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
++=======
+ 		tls_end_offset = record->end_seq - tcp_seq;
+ 
+ 		pr_debug("seq 0x%x, end_seq 0x%x prev_seq 0x%x, datalen 0x%x\n",
+ 			 tcp_seq, record->end_seq, tx_info->prev_seq, data_len);
+ 		/* update tcb for the skb */
+ 		if (skb_data_len == data_len) {
+ 			u32 tx_max = tcp_seq;
+ 
+ 			if (!tls_record_is_start_marker(record) &&
+ 			    tls_end_offset < TLS_CIPHER_AES_GCM_128_TAG_SIZE)
+ 				tx_max = record->end_seq -
+ 					TLS_CIPHER_AES_GCM_128_TAG_SIZE;
+ 
+ 			ret = chcr_ktls_xmit_tcb_cpls(tx_info, q, tx_max,
+ 						      ntohl(th->ack_seq),
+ 						      ntohs(th->window),
+ 						      tls_end_offset !=
+ 						      record->len);
+ 			if (ret) {
+ 				spin_unlock_irqrestore(&tx_ctx->base.lock,
+ 						       flags);
+ 				goto out;
+ 			}
+ 
+ 			if (th->fin)
+ 				skb_get(skb);
+ 		}
+ 
++>>>>>>> 659bf0383d15 (ch_ktls: don't free skb before sending FIN):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  		if (unlikely(tls_record_is_start_marker(record))) {
 -			atomic64_inc(&port_stats->ktls_tx_skip_no_sync_data);
 -			/* If tls_end_offset < data_len, means there is some
 -			 * data after start marker, which needs encryption, send
 -			 * plaintext first and take skb refcount. else send out
 -			 * complete pkt as plaintext.
 -			 */
 -			if (tls_end_offset < data_len)
 -				skb_get(skb);
 -			else
 -				tls_end_offset = data_len;
 -
 -			ret = chcr_ktls_tx_plaintxt(tx_info, skb, tcp_seq, mss,
 -						    (!th->fin && th->psh), q,
 -						    tx_info->port_id, NULL,
 -						    tls_end_offset, skb_offset,
 -						    0);
 -
  			spin_unlock_irqrestore(&tx_ctx->base.lock, flags);
 -			if (ret) {
 -				/* free the refcount taken earlier */
 -				if (tls_end_offset < data_len)
 -					dev_kfree_skb_any(skb);
 -				goto out;
 -			}
 -
 -			data_len -= tls_end_offset;
 -			tcp_seq = record->end_seq;
 -			skb_offset += tls_end_offset;
 -			continue;
 +			atomic64_inc(&stats->ktls_tx_skip_no_sync_data);
 +			goto out;
  		}
  
  		/* increase page reference count of the record, so that there
@@@ -2000,8 -2009,12 +2031,17 @@@ clear_ref
  			__skb_frag_unref(&record->frags[i]);
  		}
  		/* if any failure, come out from the loop. */
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +		if (ret)
 +			goto out;
++=======
+ 		if (ret) {
+ 			if (th->fin)
+ 				dev_kfree_skb_any(skb);
+ 			return NETDEV_TX_OK;
+ 		}
+ 
++>>>>>>> 659bf0383d15 (ch_ktls: don't free skb before sending FIN):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  		/* length should never be less than 0 */
  		WARN_ON(data_len < 0);
  
@@@ -2015,9 -2026,12 +2055,11 @@@
  	/* tcp finish is set, send a separate tcp msg including all the options
  	 * as well.
  	 */
- 	if (th->fin)
+ 	if (th->fin) {
  		chcr_ktls_write_tcp_options(tx_info, skb, q, tx_info->tx_chan);
+ 		dev_kfree_skb_any(skb);
+ 	}
  
 -	return NETDEV_TX_OK;
  out:
  	dev_kfree_skb_any(skb);
  	return NETDEV_TX_OK;
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
