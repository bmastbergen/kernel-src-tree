ch_ktls: Issue if connection offload fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit efca3878a5fbda8d847bd4afb7ccf48b62876d48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/efca3878.failed

Since driver first return success to tls_dev_add, if req to HW is
successful, but later if HW returns failure, that connection traffic
fails permanently and connection status remains unknown to stack.

v1->v2:
- removed conn_up from all places.

v2->v3:
- Corrected timeout handling.

Fixes: 34aba2c45024 ("cxgb4/chcr : Register to tls add and del callback")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit efca3878a5fbda8d847bd4afb7ccf48b62876d48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_ktls.c
diff --cc drivers/crypto/chelsio/chcr_ktls.c
index 640fa34b6566,c8db78b6775e..000000000000
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@@ -117,60 -125,6 +117,63 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +static int chcr_ktls_update_connection_state(struct chcr_ktls_info *tx_info,
 +					     int new_state)
 +{
 +	/* This function can be called from both rx (interrupt context) and tx
 +	 * queue contexts.
 +	 */
 +	spin_lock_bh(&tx_info->lock);
 +	switch (tx_info->connection_state) {
 +	case KTLS_CONN_CLOSED:
 +		tx_info->connection_state = new_state;
 +		break;
 +
 +	case KTLS_CONN_ACT_OPEN_REQ:
 +		/* only go forward if state is greater than current state. */
 +		if (new_state <= tx_info->connection_state)
 +			break;
 +		/* update to the next state and also initialize TCB */
 +		tx_info->connection_state = new_state;
 +		/* FALLTHRU */
 +	case KTLS_CONN_ACT_OPEN_RPL:
 +		/* if we are stuck in this state, means tcb init might not
 +		 * received by HW, try sending it again.
 +		 */
 +		if (!chcr_init_tcb_fields(tx_info))
 +			tx_info->connection_state = KTLS_CONN_SET_TCB_REQ;
 +		break;
 +
 +	case KTLS_CONN_SET_TCB_REQ:
 +		/* only go forward if state is greater than current state. */
 +		if (new_state <= tx_info->connection_state)
 +			break;
 +		/* update to the next state and check if l2t_state is valid  */
 +		tx_info->connection_state = new_state;
 +		/* FALLTHRU */
 +	case KTLS_CONN_SET_TCB_RPL:
 +		/* Check if l2t state is valid, then move to ready state. */
 +		if (cxgb4_check_l2t_valid(tx_info->l2te)) {
 +			tx_info->connection_state = KTLS_CONN_TX_READY;
 +			atomic64_inc(&tx_info->adap->chcr_stats.ktls_tx_ctx);
 +		}
 +		break;
 +
 +	case KTLS_CONN_TX_READY:
 +		/* nothing to be done here */
 +		break;
 +
 +	default:
 +		pr_err("unknown KTLS connection state\n");
 +		break;
 +	}
 +	spin_unlock_bh(&tx_info->lock);
 +
 +	return tx_info->connection_state;
 +}
++=======
++>>>>>>> efca3878a5fb (ch_ktls: Issue if connection offload fails):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  /*
   * chcr_ktls_act_open_req: creates TCB entry for ipv4 connection.
   * @sk - tcp socket.
@@@ -540,23 -484,75 +533,84 @@@ int chcr_ktls_dev_add(struct net_devic
  	/* create a filter and call cxgb4_l2t_send to send the packet out, which
  	 * will take care of updating l2t entry in hw if not already done.
  	 */
- 	ret = chcr_setup_connection(sk, tx_info);
- 	if (ret)
- 		goto out2;
+ 	tx_info->open_state = CH_KTLS_OPEN_PENDING;
  
- 	/* Driver shouldn't be removed until any single connection exists */
- 	if (!try_module_get(THIS_MODULE)) {
- 		ret = -EINVAL;
- 		goto out2;
+ 	if (chcr_setup_connection(sk, tx_info))
+ 		goto put_module;
+ 
+ 	/* Wait for reply */
+ 	wait_for_completion_timeout(&tx_info->completion, 30 * HZ);
+ 	spin_lock_bh(&tx_info->lock);
+ 	if (tx_info->open_state) {
+ 		/* need to wait for hw response, can't free tx_info yet. */
+ 		if (tx_info->open_state == CH_KTLS_OPEN_PENDING)
+ 			tx_info->pending_close = true;
+ 		/* free the lock after the cleanup */
+ 		goto put_module;
  	}
+ 	spin_unlock_bh(&tx_info->lock);
+ 
+ 	/* initialize tcb */
+ 	reinit_completion(&tx_info->completion);
+ 	/* mark it pending for hw response */
+ 	tx_info->open_state = CH_KTLS_OPEN_PENDING;
+ 
+ 	if (chcr_init_tcb_fields(tx_info))
+ 		goto free_tid;
+ 
+ 	/* Wait for reply */
+ 	wait_for_completion_timeout(&tx_info->completion, 30 * HZ);
+ 	spin_lock_bh(&tx_info->lock);
+ 	if (tx_info->open_state) {
+ 		/* need to wait for hw response, can't free tx_info yet. */
+ 		tx_info->pending_close = true;
+ 		/* free the lock after cleanup */
+ 		goto free_tid;
+ 	}
+ 	spin_unlock_bh(&tx_info->lock);
+ 
+ 	if (!cxgb4_check_l2t_valid(tx_info->l2te))
+ 		goto free_tid;
+ 
+ 	atomic64_inc(&adap->ch_ktls_stats.ktls_tx_ctx);
+ 	tx_ctx->chcr_info = tx_info;
  
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +	atomic64_inc(&adap->chcr_stats.ktls_tx_connection_open);
++=======
++>>>>>>> efca3878a5fb (ch_ktls: Issue if connection offload fails):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  	return 0;
- out2:
- 	kvfree(tx_info);
+ 
+ free_tid:
+ 	chcr_ktls_mark_tcb_close(tx_info);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	/* clear clip entry */
+ 	if (tx_info->ip_family == AF_INET6)
+ 		cxgb4_clip_release(netdev, (const u32 *)
+ 				   &sk->sk_v6_rcv_saddr,
+ 				   1);
+ #endif
+ 	cxgb4_remove_tid(&tx_info->adap->tids, tx_info->tx_chan,
+ 			 tx_info->tid, tx_info->ip_family);
+ 
+ put_module:
+ 	/* release module refcount */
+ 	module_put(THIS_MODULE);
+ free_l2t:
+ 	cxgb4_l2t_release(tx_info->l2te);
+ free_tx_info:
+ 	if (tx_info->pending_close)
+ 		spin_unlock_bh(&tx_info->lock);
+ 	else
+ 		kvfree(tx_info);
  out:
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +	atomic64_inc(&adap->chcr_stats.ktls_tx_connection_fail);
 +	return ret;
++=======
+ 	atomic64_inc(&adap->ch_ktls_stats.ktls_tx_connection_fail);
+ 	return -1;
++>>>>>>> efca3878a5fb (ch_ktls: Issue if connection offload fails):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  }
  
  /*
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
diff --git a/drivers/crypto/chelsio/chcr_ktls.h b/drivers/crypto/chelsio/chcr_ktls.h
index 5cbd84b1da05..d5da52feb0fb 100644
--- a/drivers/crypto/chelsio/chcr_ktls.h
+++ b/drivers/crypto/chelsio/chcr_ktls.h
@@ -24,22 +24,20 @@
 #define CHCR_KTLS_WR_SIZE	(CHCR_PLAIN_TX_DATA_LEN +\
 				 sizeof(struct cpl_tx_sec_pdu))
 
-enum chcr_ktls_conn_state {
-	KTLS_CONN_CLOSED,
-	KTLS_CONN_ACT_OPEN_REQ,
-	KTLS_CONN_ACT_OPEN_RPL,
-	KTLS_CONN_SET_TCB_REQ,
-	KTLS_CONN_SET_TCB_RPL,
-	KTLS_CONN_TX_READY,
+enum ch_ktls_open_state {
+	CH_KTLS_OPEN_SUCCESS = 0,
+	CH_KTLS_OPEN_PENDING = 1,
+	CH_KTLS_OPEN_FAILURE = 2,
 };
 
 struct chcr_ktls_info {
 	struct sock *sk;
-	spinlock_t lock; /* state machine lock */
+	spinlock_t lock; /* lock for pending_close */
 	struct ktls_key_ctx key_ctx;
 	struct adapter *adap;
 	struct l2t_entry *l2te;
 	struct net_device *netdev;
+	struct completion completion;
 	u64 iv;
 	u64 record_no;
 	int tid;
@@ -55,13 +53,14 @@ struct chcr_ktls_info {
 	u32 tcp_start_seq_number;
 	u32 scmd0_short_seqno_numivs;
 	u32 scmd0_short_ivgen_hdrlen;
-	enum chcr_ktls_conn_state connection_state;
 	u16 prev_win;
 	u8 tx_chan;
 	u8 smt_idx;
 	u8 port_id;
 	u8 ip_family;
 	u8 first_qset;
+	enum ch_ktls_open_state open_state;
+	bool pending_close;
 };
 
 struct chcr_ktls_ofld_ctx_tx {
