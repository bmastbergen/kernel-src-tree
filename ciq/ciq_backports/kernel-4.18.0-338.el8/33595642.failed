cxgb4: Fix work request size calculation for loopback test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Ganji Aravind <ganji.aravind@chelsio.com>
commit 335956421c86f64fd46186d76d3961f6adcff187
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/33595642.failed

Work request used for sending loopback packet needs to add
the firmware work request only once. So, fix by using
correct structure size.

Fixes: 7235ffae3d2c ("cxgb4: add loopback ethtool self-test")
	Signed-off-by: Ganji Aravind <ganji.aravind@chelsio.com>
	Reviewed-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 335956421c86f64fd46186d76d3961f6adcff187)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/sge.c
index 5d3a92d2f716,7c9fe4bc235b..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@@ -2534,6 -2537,80 +2534,83 @@@ static void ctrlq_check_stop(struct sge
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #define CXGB4_SELFTEST_LB_STR "CHELSIO_SELFTEST"
+ 
+ int cxgb4_selftest_lb_pkt(struct net_device *netdev)
+ {
+ 	struct port_info *pi = netdev_priv(netdev);
+ 	struct adapter *adap = pi->adapter;
+ 	struct cxgb4_ethtool_lb_test *lb;
+ 	int ret, i = 0, pkt_len, credits;
+ 	struct fw_eth_tx_pkt_wr *wr;
+ 	struct cpl_tx_pkt_core *cpl;
+ 	u32 ctrl0, ndesc, flits;
+ 	struct sge_eth_txq *q;
+ 	u8 *sgl;
+ 
+ 	pkt_len = ETH_HLEN + sizeof(CXGB4_SELFTEST_LB_STR);
+ 
+ 	flits = DIV_ROUND_UP(pkt_len + sizeof(*cpl) + sizeof(*wr),
+ 			     sizeof(__be64));
+ 	ndesc = flits_to_desc(flits);
+ 
+ 	lb = &pi->ethtool_lb;
+ 	lb->loopback = 1;
+ 
+ 	q = &adap->sge.ethtxq[pi->first_qset];
+ 
+ 	reclaim_completed_tx(adap, &q->q, -1, true);
+ 	credits = txq_avail(&q->q) - ndesc;
+ 	if (unlikely(credits < 0))
+ 		return -ENOMEM;
+ 
+ 	wr = (void *)&q->q.desc[q->q.pidx];
+ 	memset(wr, 0, sizeof(struct tx_desc));
+ 
+ 	wr->op_immdlen = htonl(FW_WR_OP_V(FW_ETH_TX_PKT_WR) |
+ 			       FW_WR_IMMDLEN_V(pkt_len +
+ 			       sizeof(*cpl)));
+ 	wr->equiq_to_len16 = htonl(FW_WR_LEN16_V(DIV_ROUND_UP(flits, 2)));
+ 	wr->r3 = cpu_to_be64(0);
+ 
+ 	cpl = (void *)(wr + 1);
+ 	sgl = (u8 *)(cpl + 1);
+ 
+ 	ctrl0 = TXPKT_OPCODE_V(CPL_TX_PKT_XT) | TXPKT_PF_V(adap->pf) |
+ 		TXPKT_INTF_V(pi->tx_chan + 4);
+ 
+ 	cpl->ctrl0 = htonl(ctrl0);
+ 	cpl->pack = htons(0);
+ 	cpl->len = htons(pkt_len);
+ 	cpl->ctrl1 = cpu_to_be64(TXPKT_L4CSUM_DIS_F | TXPKT_IPCSUM_DIS_F);
+ 
+ 	eth_broadcast_addr(sgl);
+ 	i += ETH_ALEN;
+ 	ether_addr_copy(&sgl[i], netdev->dev_addr);
+ 	i += ETH_ALEN;
+ 
+ 	snprintf(&sgl[i], sizeof(CXGB4_SELFTEST_LB_STR), "%s",
+ 		 CXGB4_SELFTEST_LB_STR);
+ 
+ 	init_completion(&lb->completion);
+ 	txq_advance(&q->q, ndesc);
+ 	cxgb4_ring_tx_db(adap, &q->q, ndesc);
+ 
+ 	/* wait for the pkt to return */
+ 	ret = wait_for_completion_timeout(&lb->completion, 10 * HZ);
+ 	if (!ret)
+ 		ret = -ETIMEDOUT;
+ 	else
+ 		ret = lb->result;
+ 
+ 	lb->loopback = 0;
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 335956421c86 (cxgb4: Fix work request size calculation for loopback test)
  /**
   *	ctrl_xmit - send a packet through an SGE control Tx queue
   *	@q: the control queue
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/sge.c
