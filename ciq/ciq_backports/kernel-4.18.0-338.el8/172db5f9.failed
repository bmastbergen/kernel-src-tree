ice: add support for auxiliary input/output pins

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Maciej Machnikowski <maciej.machnikowski@intel.com>
commit 172db5f91d5f7b91670c68a7547798b0b5374158
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/172db5f9.failed

The E810 device supports programmable pins for enabling both input and
output events related to the PTP hardware clock. This includes both
output signals with programmable period, as well as timestamping of
events on input pins.

Add support for enabling these using the CONFIG_PTP_1588_CLOCK
interface.

This allows programming the software defined pins to take advantage of
the hardware clock features.

	Signed-off-by: Maciej Machnikowski <maciej.machnikowski@intel.com>
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 172db5f91d5f7b91670c68a7547798b0b5374158)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_hw_autogen.h
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_ptp.c
#	drivers/net/ethernet/intel/ice/ice_ptp.h
diff --cc drivers/net/ethernet/intel/ice/ice_hw_autogen.h
index c02295f48915,76021d977b60..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
+++ b/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
@@@ -155,6 -206,8 +159,11 @@@
  #define PFINT_MBX_CTL_ITR_INDX_M		ICE_M(0x3, 11)
  #define PFINT_MBX_CTL_CAUSE_ENA_M		BIT(30)
  #define PFINT_OICR				0x0016CA00
++<<<<<<< HEAD
++=======
+ #define PFINT_OICR_TSYN_TX_M			BIT(11)
+ #define PFINT_OICR_TSYN_EVNT_M			BIT(12)
++>>>>>>> 172db5f91d5f (ice: add support for auxiliary input/output pins)
  #define PFINT_OICR_ECC_ERR_M			BIT(16)
  #define PFINT_OICR_MAL_DETECT_M			BIT(19)
  #define PFINT_OICR_GRST_M			BIT(20)
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index 0510fcf5eb90,ef8d1815af56..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -2726,11 -2812,36 +2726,44 @@@ static irqreturn_t ice_misc_intr(int __
  		}
  	}
  
++<<<<<<< HEAD
 +	if (oicr & PFINT_OICR_HMC_ERR_M) {
 +		ena_mask &= ~PFINT_OICR_HMC_ERR_M;
 +		dev_dbg(dev, "HMC Error interrupt - info 0x%x, data 0x%x\n",
 +			rd32(hw, PFHMC_ERRORINFO),
 +			rd32(hw, PFHMC_ERRORDATA));
++=======
+ 	if (oicr & PFINT_OICR_TSYN_TX_M) {
+ 		ena_mask &= ~PFINT_OICR_TSYN_TX_M;
+ 		ice_ptp_process_ts(pf);
+ 	}
+ 
+ 	if (oicr & PFINT_OICR_TSYN_EVNT_M) {
+ 		u8 tmr_idx = hw->func_caps.ts_func_info.tmr_index_owned;
+ 		u32 gltsyn_stat = rd32(hw, GLTSYN_STAT(tmr_idx));
+ 
+ 		/* Save EVENTs from GTSYN register */
+ 		pf->ptp.ext_ts_irq |= gltsyn_stat & (GLTSYN_STAT_EVENT0_M |
+ 						     GLTSYN_STAT_EVENT1_M |
+ 						     GLTSYN_STAT_EVENT2_M);
+ 		ena_mask &= ~PFINT_OICR_TSYN_EVNT_M;
+ 		kthread_queue_work(pf->ptp.kworker, &pf->ptp.extts_work);
+ 	}
+ 
+ #define ICE_AUX_CRIT_ERR (PFINT_OICR_PE_CRITERR_M | PFINT_OICR_HMC_ERR_M | PFINT_OICR_PE_PUSH_M)
+ 	if (oicr & ICE_AUX_CRIT_ERR) {
+ 		struct iidc_event *event;
+ 
+ 		ena_mask &= ~ICE_AUX_CRIT_ERR;
+ 		event = kzalloc(sizeof(*event), GFP_KERNEL);
+ 		if (event) {
+ 			set_bit(IIDC_EVENT_CRIT_ERR, event->type);
+ 			/* report the entire OICR value to AUX driver */
+ 			event->reg = oicr;
+ 			ice_send_event_to_aux(pf, event);
+ 			kfree(event);
+ 		}
++>>>>>>> 172db5f91d5f (ice: add support for auxiliary input/output pins)
  	}
  
  	/* Report any remaining unexpected interrupts */
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_hw_autogen.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.h
