kernfs: dont call d_splice_alias() under kernfs node lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Ian Kent <raven@themaw.net>
commit df6192f47d2311cf40cd4321cc59863a5853b665
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/df6192f4.failed

The call to d_splice_alias() in kernfs_iop_lookup() doesn't depend on
any kernfs node so there's no reason to hold the kernfs node lock when
calling it.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Signed-off-by: Ian Kent <raven@themaw.net>
Link: https://lore.kernel.org/r/162642772000.63632.10672683419693513226.stgit@web.messagingengine.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit df6192f47d2311cf40cd4321cc59863a5853b665)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/dir.c
diff --cc fs/kernfs/dir.c
index e1a020cfd462,ba581429bf7b..000000000000
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@@ -1117,14 -1119,14 +1116,19 @@@ static struct dentry *kernfs_iop_lookup
  	/* Needed only for negative dentry validation */
  	if (!inode)
  		kernfs_set_rev(parent, dentry);
++<<<<<<< HEAD
 +	/* instantiate and hash (possibly negative) dentry */
 +	ret = d_splice_alias(inode, dentry);
 +	mutex_unlock(&kernfs_mutex);
++=======
+ 	up_read(&kernfs_rwsem);
++>>>>>>> df6192f47d23 (kernfs: dont call d_splice_alias() under kernfs node lock)
  
- 	return ret;
+ 	/* instantiate and hash (possibly negative) dentry */
+ 	return d_splice_alias(inode, dentry);
  }
  
 -static int kernfs_iop_mkdir(struct user_namespace *mnt_userns,
 -			    struct inode *dir, struct dentry *dentry,
 +static int kernfs_iop_mkdir(struct inode *dir, struct dentry *dentry,
  			    umode_t mode)
  {
  	struct kernfs_node *parent = dir->i_private;
* Unmerged path fs/kernfs/dir.c
