ch_ktls: Correction in trimmed_len calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit c68a28a9e2798a4602dde1c77046a3b577eb31f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/c68a28a9.failed

trimmed length calculation goes wrong if skb has only tag part
to send. It should be zero if there is no data bytes apart from
TAG.

Fixes: dc05f3df8fac ("chcr: Handle first or middle part of record")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit c68a28a9e2798a4602dde1c77046a3b577eb31f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_ktls.c
diff --cc drivers/crypto/chelsio/chcr_ktls.c
index 074af13f5bc4,4286decce095..000000000000
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@@ -1712,27 -1729,21 +1712,37 @@@ static int chcr_short_record_handler(st
  
  	if (remaining_record > 0 &&
  	    remaining_record < TLS_CIPHER_AES_GCM_128_TAG_SIZE) {
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +		int trimmed_len = skb->data_len -
 +			(TLS_CIPHER_AES_GCM_128_TAG_SIZE - remaining_record);
 +		struct sk_buff *tmp_skb = NULL;
 +		/* don't process the pkt if it is only a partial tag */
 +		if (skb->data_len < TLS_CIPHER_AES_GCM_128_TAG_SIZE)
++=======
+ 		int trimmed_len = 0;
+ 
+ 		if (tls_end_offset > TLS_CIPHER_AES_GCM_128_TAG_SIZE)
+ 			trimmed_len = data_len -
+ 				      (TLS_CIPHER_AES_GCM_128_TAG_SIZE -
+ 				       remaining_record);
+ 		if (!trimmed_len)
++>>>>>>> c68a28a9e279 (ch_ktls: Correction in trimmed_len calculation):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  			goto out;
  
 -		WARN_ON(trimmed_len > data_len);
 +		WARN_ON(trimmed_len > skb->data_len);
  
 -		data_len = trimmed_len;
 -		atomic64_inc(&tx_info->adap->ch_ktls_stats.ktls_tx_trimmed_pkts);
 -	}
 +		/* shift to those many bytes */
 +		tmp_skb = alloc_skb(0, GFP_KERNEL);
 +		if (unlikely(!tmp_skb))
 +			goto out;
  
 +		chcr_ktls_skb_shift(tmp_skb, skb, trimmed_len);
 +		/* free the last trimmed portion */
 +		dev_kfree_skb_any(skb);
 +		skb = tmp_skb;
 +		atomic64_inc(&tx_info->adap->chcr_stats.ktls_tx_trimmed_pkts);
 +	}
 +	data_len = skb->data_len;
  	/* check if the middle record's start point is 16 byte aligned. CTR
  	 * needs 16 byte aligned start point to start encryption.
  	 */
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
