cxgb4/ch_ktls: decrypted bit is not enough

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit 9d2e5e9eeb59524a59b461fe256139826d464e1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/9d2e5e9e.failed

If skb has retransmit data starting before start marker, e.g. ccs,
decrypted bit won't be set for that, and if it has some data to
encrypt, then it must be given to crypto ULD. So in place of
decrypted, check if socket is tls offloaded. Also, unless skb has
some data to encrypt, no need to give it for tls offload handling.

v2->v3:
- Removed ifdef.

Fixes: 5a4b9fe7fece ("cxgb4/chcr: complete record tx handling")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9d2e5e9eeb59524a59b461fe256139826d464e1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/sge.c
index d1c0b53b96ee,01bd9c0dfe4e..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@@ -1413,14 -1416,15 +1413,21 @@@ static netdev_tx_t cxgb4_eth_xmit(struc
  	pi = netdev_priv(dev);
  	adap = pi->adapter;
  	ssi = skb_shinfo(skb);
 -#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)
 +#ifdef CONFIG_CHELSIO_IPSEC_INLINE
  	if (xfrm_offload(skb) && !ssi->gso_size)
 -		return adap->uld[CXGB4_ULD_IPSEC].tx_handler(skb, dev);
 +		return adap->uld[CXGB4_ULD_CRYPTO].tx_handler(skb, dev);
  #endif /* CHELSIO_IPSEC_INLINE */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_CHELSIO_TLS_DEVICE
 +	if (skb->decrypted)
 +		return adap->uld[CXGB4_ULD_CRYPTO].tx_handler(skb, dev);
++=======
+ #if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)
+ 	if (cxgb4_is_ktls_skb(skb) &&
+ 	    (skb->len - (skb_transport_offset(skb) + tcp_hdrlen(skb))))
+ 		return adap->uld[CXGB4_ULD_KTLS].tx_handler(skb, dev);
++>>>>>>> 9d2e5e9eeb59 (cxgb4/ch_ktls: decrypted bit is not enough)
  #endif /* CHELSIO_TLS_DEVICE */
  
  	qidx = skb_get_queue_mapping(skb);
diff --git a/drivers/crypto/chelsio/chcr_ktls.c b/drivers/crypto/chelsio/chcr_ktls.c
index 640fa34b6566..98703e443ad4 100644
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@ -1846,10 +1846,6 @@ int chcr_ktls_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	mss = skb_is_gso(skb) ? skb_shinfo(skb)->gso_size : skb->data_len;
 
-	/* check if we haven't set it for ktls offload */
-	if (!skb->sk || !tls_is_sk_tx_device_offloaded(skb->sk))
-		goto out;
-
 	tls_ctx = tls_get_ctx(skb->sk);
 	if (unlikely(tls_ctx->netdev != dev))
 		goto out;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index acd7043aee47..73478c2425f0 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -1171,6 +1171,7 @@ static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 		txq = fallback(dev, skb, sb_dev);
 		if (xfrm_offload(skb) || is_ptp_enabled(skb, dev) ||
 		    skb->encapsulation ||
+		    cxgb4_is_ktls_skb(skb) ||
 		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP))
 			txq = txq % pi->nqsets;
 
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
index a963fd0b4540..14800b90ff6e 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
@@ -475,6 +475,11 @@ struct cxgb4_uld_info {
 #endif
 };
 
+static inline bool cxgb4_is_ktls_skb(struct sk_buff *skb)
+{
+	return skb->sk && tls_is_sk_tx_device_offloaded(skb->sk);
+}
+
 void cxgb4_uld_enable(struct adapter *adap);
 void cxgb4_register_uld(enum cxgb4_uld type, const struct cxgb4_uld_info *p);
 int cxgb4_unregister_uld(enum cxgb4_uld type);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/sge.c
