fs: dlm: set skb mark per peer socket

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Alexander Aring <aahringo@redhat.com>
commit 9c9f168f5b145986535f727d259ef75f6ea26990
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/9c9f168f.failed

This patch adds support to set the skb mark value for the DLM tcp and
sctp socket per peer. The mark value will be offered as per comm value
of configfs. At creation time of the peer socket it will be set as
socket option.

	Signed-off-by: Alexander Aring <aahringo@redhat.com>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit 9c9f168f5b145986535f727d259ef75f6ea26990)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/lowcomms.c
diff --cc fs/dlm/lowcomms.c
index 2ece988dabc6,3fa1b93dbbc7..000000000000
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@@ -1037,7 -914,7 +1037,11 @@@ static void sctp_connect_to_sock(struc
  	int result;
  	int addr_len;
  	struct socket *sock;
++<<<<<<< HEAD
 +	struct timeval tv = { .tv_sec = 5, .tv_usec = 0 };
++=======
+ 	unsigned int mark;
++>>>>>>> 9c9f168f5b14 (fs: dlm: set skb mark per peer socket)
  
  	if (con->nodeid == 0) {
  		log_print("attempt to connect sock 0 foiled");
diff --git a/fs/dlm/config.c b/fs/dlm/config.c
index 1270551d24e3..b14e3e64c82d 100644
--- a/fs/dlm/config.c
+++ b/fs/dlm/config.c
@@ -198,6 +198,7 @@ enum {
 	COMM_ATTR_LOCAL,
 	COMM_ATTR_ADDR,
 	COMM_ATTR_ADDR_LIST,
+	COMM_ATTR_MARK,
 };
 
 enum {
@@ -230,6 +231,7 @@ struct dlm_comm {
 	int nodeid;
 	int local;
 	int addr_count;
+	unsigned int mark;
 	struct sockaddr_storage *addr[DLM_MAX_ADDR_COUNT];
 };
 
@@ -467,6 +469,7 @@ static struct config_item *make_comm(struct config_group *g, const char *name)
 	cm->nodeid = -1;
 	cm->local = 0;
 	cm->addr_count = 0;
+	cm->mark = 0;
 	return &cm->item;
 }
 
@@ -662,8 +665,28 @@ static ssize_t comm_addr_list_show(struct config_item *item, char *buf)
 	return 4096 - allowance;
 }
 
+static ssize_t comm_mark_show(struct config_item *item, char *buf)
+{
+	return sprintf(buf, "%u\n", config_item_to_comm(item)->mark);
+}
+
+static ssize_t comm_mark_store(struct config_item *item, const char *buf,
+			       size_t len)
+{
+	unsigned int mark;
+	int rc;
+
+	rc = kstrtouint(buf, 0, &mark);
+	if (rc)
+		return rc;
+
+	config_item_to_comm(item)->mark = mark;
+	return len;
+}
+
 CONFIGFS_ATTR(comm_, nodeid);
 CONFIGFS_ATTR(comm_, local);
+CONFIGFS_ATTR(comm_, mark);
 CONFIGFS_ATTR_WO(comm_, addr);
 CONFIGFS_ATTR_RO(comm_, addr_list);
 
@@ -672,6 +695,7 @@ static struct configfs_attribute *comm_attrs[] = {
 	[COMM_ATTR_LOCAL] = &comm_attr_local,
 	[COMM_ATTR_ADDR] = &comm_attr_addr,
 	[COMM_ATTR_ADDR_LIST] = &comm_attr_addr_list,
+	[COMM_ATTR_MARK] = &comm_attr_mark,
 	NULL,
 };
 
@@ -831,6 +855,20 @@ int dlm_comm_seq(int nodeid, uint32_t *seq)
 	return 0;
 }
 
+int dlm_comm_mark(int nodeid, unsigned int *mark)
+{
+	struct dlm_comm *cm;
+
+	cm = get_comm(nodeid);
+	if (!cm)
+		return -ENOENT;
+
+	*mark = cm->mark;
+	put_comm(cm);
+
+	return 0;
+}
+
 int dlm_our_nodeid(void)
 {
 	return local_comm ? local_comm->nodeid : 0;
diff --git a/fs/dlm/config.h b/fs/dlm/config.h
index 6041eec886ab..c87f83c22d52 100644
--- a/fs/dlm/config.h
+++ b/fs/dlm/config.h
@@ -47,6 +47,7 @@ void dlm_config_exit(void);
 int dlm_config_nodes(char *lsname, struct dlm_config_node **nodes_out,
 		     int *count_out);
 int dlm_comm_seq(int nodeid, uint32_t *seq);
+int dlm_comm_mark(int nodeid, unsigned int *mark);
 int dlm_our_nodeid(void);
 int dlm_our_addr(struct sockaddr_storage *addr, int num);
 
* Unmerged path fs/dlm/lowcomms.c
