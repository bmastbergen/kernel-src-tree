cxgb4: add TC-MATCHALL IPv6 support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
commit 59b328cf566001fce32c33375ea9bc570625af2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/59b328cf.failed

Matching IPv6 traffic require allocating their own individual slots
in TCAM. So, fetch additional slots to insert IPv6 rules. Also, fetch
the cumulative stats of all the slots occupied by the Matchall rule.

	Signed-off-by: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 59b328cf566001fce32c33375ea9bc570625af2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.h
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
index 733f2f8014ea,2e309f6673f7..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
@@@ -197,8 -188,69 +197,74 @@@ static void cxgb4_matchall_free_tc(stru
  	tc_port_matchall->egress.state = CXGB4_MATCHALL_STATE_DISABLED;
  }
  
++<<<<<<< HEAD
 +static int cxgb4_matchall_alloc_filter(struct net_device *dev,
 +				       struct tc_cls_matchall_offload *cls)
++=======
+ static int cxgb4_matchall_mirror_alloc(struct net_device *dev,
+ 				       struct tc_cls_matchall_offload *cls)
+ {
+ 	struct netlink_ext_ack *extack = cls->common.extack;
+ 	struct cxgb4_tc_port_matchall *tc_port_matchall;
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	struct flow_action_entry *act;
+ 	int ret;
+ 	u32 i;
+ 
+ 	tc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];
+ 	flow_action_for_each(i, act, &cls->rule->action) {
+ 		if (act->id == FLOW_ACTION_MIRRED) {
+ 			ret = cxgb4_port_mirror_alloc(dev);
+ 			if (ret) {
+ 				NL_SET_ERR_MSG_MOD(extack,
+ 						   "Couldn't allocate mirror");
+ 				return ret;
+ 			}
+ 
+ 			tc_port_matchall->ingress.viid_mirror = pi->viid_mirror;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void cxgb4_matchall_mirror_free(struct net_device *dev)
+ {
+ 	struct cxgb4_tc_port_matchall *tc_port_matchall;
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 
+ 	tc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];
+ 	if (!tc_port_matchall->ingress.viid_mirror)
+ 		return;
+ 
+ 	cxgb4_port_mirror_free(dev);
+ 	tc_port_matchall->ingress.viid_mirror = 0;
+ }
+ 
+ static int cxgb4_matchall_del_filter(struct net_device *dev, u8 filter_type)
+ {
+ 	struct cxgb4_tc_port_matchall *tc_port_matchall;
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	int ret;
+ 
+ 	tc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];
+ 	ret = cxgb4_del_filter(dev, tc_port_matchall->ingress.tid[filter_type],
+ 			       &tc_port_matchall->ingress.fs[filter_type]);
+ 	if (ret)
+ 		return ret;
+ 
+ 	tc_port_matchall->ingress.tid[filter_type] = 0;
+ 	return 0;
+ }
+ 
+ static int cxgb4_matchall_add_filter(struct net_device *dev,
+ 				     struct tc_cls_matchall_offload *cls,
+ 				     u8 filter_type)
++>>>>>>> 59b328cf5660 (cxgb4: add TC-MATCHALL IPv6 support)
  {
  	struct netlink_ext_ack *extack = cls->common.extack;
  	struct cxgb4_tc_port_matchall *tc_port_matchall;
@@@ -239,10 -291,40 +305,46 @@@
  	ret = cxgb4_set_filter(dev, fidx, fs);
  	if (ret)
  		return ret;
++<<<<<<< HEAD
++=======
+ 
+ 	tc_port_matchall->ingress.tid[filter_type] = fidx;
+ 	return 0;
+ }
+ 
+ static int cxgb4_matchall_alloc_filter(struct net_device *dev,
+ 				       struct tc_cls_matchall_offload *cls)
+ {
+ 	struct cxgb4_tc_port_matchall *tc_port_matchall;
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	int ret, i;
+ 
+ 	tc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];
+ 
+ 	ret = cxgb4_matchall_mirror_alloc(dev, cls);
+ 	if (ret)
+ 		return ret;
+ 
+ 	for (i = 0; i < CXGB4_FILTER_TYPE_MAX; i++) {
+ 		ret = cxgb4_matchall_add_filter(dev, cls, i);
+ 		if (ret)
+ 			goto out_free;
+ 	}
++>>>>>>> 59b328cf5660 (cxgb4: add TC-MATCHALL IPv6 support)
  
- 	tc_port_matchall->ingress.tid = fidx;
  	tc_port_matchall->ingress.state = CXGB4_MATCHALL_STATE_ENABLED;
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ out_free:
+ 	while (i-- > 0)
+ 		cxgb4_matchall_del_filter(dev, i);
+ 
+ 	cxgb4_matchall_mirror_free(dev);
+ 	return ret;
++>>>>>>> 59b328cf5660 (cxgb4: add TC-MATCHALL IPv6 support)
  }
  
  static int cxgb4_matchall_free_filter(struct net_device *dev)
@@@ -254,11 -337,14 +357,12 @@@
  
  	tc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];
  
- 	ret = cxgb4_del_filter(dev, tc_port_matchall->ingress.tid,
- 			       &tc_port_matchall->ingress.fs);
- 	if (ret)
- 		return ret;
+ 	for (i = 0; i < CXGB4_FILTER_TYPE_MAX; i++) {
+ 		ret = cxgb4_matchall_del_filter(dev, i);
+ 		if (ret)
+ 			return ret;
+ 	}
  
 -	cxgb4_matchall_mirror_free(dev);
 -
  	tc_port_matchall->ingress.packets = 0;
  	tc_port_matchall->ingress.bytes = 0;
  	tc_port_matchall->ingress.last_used = 0;
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.h
index ab6b5683dfd3,fe7ec423a4c9..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.h
@@@ -19,8 -19,10 +19,15 @@@ struct cxgb4_matchall_egress_entry 
  
  struct cxgb4_matchall_ingress_entry {
  	enum cxgb4_matchall_state state; /* Current MATCHALL offload state */
++<<<<<<< HEAD
 +	u32 tid; /* Index to hardware filter entry */
 +	struct ch_filter_specification fs; /* Filter entry */
++=======
+ 	u32 tid[CXGB4_FILTER_TYPE_MAX]; /* Index to hardware filter entries */
+ 	/* Filter entries */
+ 	struct ch_filter_specification fs[CXGB4_FILTER_TYPE_MAX];
+ 	u16 viid_mirror; /* Identifier for allocated Mirror VI */
++>>>>>>> 59b328cf5660 (cxgb4: add TC-MATCHALL IPv6 support)
  	u64 bytes; /* # of bytes hitting the filter */
  	u64 packets; /* # of packets hitting the filter */
  	u64 last_used; /* Last updated jiffies time */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 23149ddf89f0..1d7a065fc460 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -1417,6 +1417,8 @@ enum {
 	NAT_MODE_ALL		/* NAT on entire 4-tuple */
 };
 
+#define CXGB4_FILTER_TYPE_MAX 2
+
 /* Host shadow copy of ingress filter entry.  This is in host native format
  * and doesn't match the ordering or bit order, etc. of the hardware of the
  * firmware command.  The use of bit-field structure elements is purely to
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.h
