sk_buff: avoid potentially clearing 'slow_gro' field

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit a432934a30679c0e3c47b87f13e4901bc1a3fc03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/a432934a.failed

If skb_dst_set_noref() is invoked with a NULL dst, the 'slow_gro'
field is cleared, too. That could lead to wrong behavior if
the skb later enters the GRO stage.

Fix the potential issue replacing preserving a non-zero value of
the 'slow_gro' field.

Additionally, fix a comment typo.

	Reported-by: Sabrina Dubroca <sd@queasysnail.net>
	Reported-by: Jakub Kicinski <kuba@kernel.org>
Fixes: 8a886b142bd0 ("sk_buff: track dst status in slow_gro")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Link: https://lore.kernel.org/r/aa42529252dc8bb02bd42e8629427040d1058537.1627662501.git.pabeni@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit a432934a30679c0e3c47b87f13e4901bc1a3fc03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index 4f3813eeafe4,64e1a5f63f93..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -5553,6 -6021,32 +5553,35 @@@ static void gro_list_prepare(struct nap
  			diffs = memcmp(skb_mac_header(p),
  				       skb_mac_header(skb),
  				       maclen);
++<<<<<<< HEAD
++=======
+ 
+ 		/* in most common scenarions 'slow_gro' is 0
+ 		 * otherwise we are already on some slower paths
+ 		 * either skip all the infrequent tests altogether or
+ 		 * avoid trying too hard to skip each of them individually
+ 		 */
+ 		if (!diffs && unlikely(skb->slow_gro | p->slow_gro)) {
+ #if IS_ENABLED(CONFIG_SKB_EXTENSIONS) && IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+ 			struct tc_skb_ext *skb_ext;
+ 			struct tc_skb_ext *p_ext;
+ #endif
+ 
+ 			diffs |= p->sk != skb->sk;
+ 			diffs |= skb_metadata_dst_cmp(p, skb);
+ 			diffs |= skb_get_nfct(p) ^ skb_get_nfct(skb);
+ 
+ #if IS_ENABLED(CONFIG_SKB_EXTENSIONS) && IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
+ 			skb_ext = skb_ext_find(skb, TC_SKB_EXT);
+ 			p_ext = skb_ext_find(p, TC_SKB_EXT);
+ 
+ 			diffs |= (!!p_ext) ^ (!!skb_ext);
+ 			if (!diffs && unlikely(skb_ext))
+ 				diffs |= p_ext->chain ^ skb_ext->chain;
+ #endif
+ 		}
+ 
++>>>>>>> a432934a3067 (sk_buff: avoid potentially clearing 'slow_gro' field)
  		NAPI_GRO_CB(p)->same_flow = !diffs;
  	}
  }
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 8d0ae55ed330..7b5adaa46f0d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1021,7 +1021,7 @@ static inline void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
 static inline void skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst)
 {
 	WARN_ON(!rcu_read_lock_held() && !rcu_read_lock_bh_held());
-	skb->slow_gro = !!dst;
+	skb->slow_gro |= !!dst;
 	skb->_skb_refdst = (unsigned long)dst | SKB_DST_NOREF;
 }
 
* Unmerged path net/core/dev.c
