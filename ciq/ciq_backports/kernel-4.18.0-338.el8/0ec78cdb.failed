cxgb4/ch_ipsec: Replace the module name to ch_ipsec from chcr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Ayush Sawal <ayush.sawal@chelsio.com>
commit 0ec78cdb1ab1ab740ee23a260135471f259caf02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/0ec78cdb.failed

This patch changes the module name to "ch_ipsec" and prepends
"ch_ipsec" string instead of "chcr" in all debug messages and
function names.

V1->V2:
-Removed inline keyword from functions.
-Removed CH_IPSEC prefix from pr_debug.
-Used proper indentation for the continuation line of the function
arguments.

V2->V3:
Fix the checkpatch.pl warnings.

Fixes: 1b77be463929 ("crypto/chcr: Moving chelsio's inline ipsec functionality to /drivers/net")
	Signed-off-by: Ayush Sawal <ayush.sawal@chelsio.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0ec78cdb1ab1ab740ee23a260135471f259caf02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_core.h
#	drivers/crypto/chelsio/chcr_ipsec.c
diff --cc drivers/crypto/chelsio/chcr_core.h
index a751041d615e,b02f981e7c32..000000000000
--- a/drivers/crypto/chelsio/chcr_core.h
+++ b/drivers/crypto/chelsio/chcr_core.h
@@@ -221,18 -137,4 +221,21 @@@ int chcr_uld_rx_handler(void *handle, c
  int chcr_uld_tx_handler(struct sk_buff *skb, struct net_device *dev);
  int chcr_handle_resp(struct crypto_async_request *req, unsigned char *input,
  		     int err);
++<<<<<<< HEAD
 +int chcr_ipsec_xmit(struct sk_buff *skb, struct net_device *dev);
 +void chcr_add_xfrmops(const struct cxgb4_lld_info *lld);
 +#ifdef CONFIG_CHELSIO_TLS_DEVICE
 +int chcr_ktls_cpl_act_open_rpl(struct adapter *adap, unsigned char *input);
 +int chcr_ktls_cpl_set_tcb_rpl(struct adapter *adap, unsigned char *input);
 +int chcr_ktls_xmit(struct sk_buff *skb, struct net_device *dev);
 +extern int chcr_ktls_dev_add(struct net_device *netdev, struct sock *sk,
 +			     enum tls_offload_ctx_dir direction,
 +			     struct tls_crypto_info *crypto_info,
 +			     u32 start_offload_tcp_sn);
 +extern void chcr_ktls_dev_del(struct net_device *netdev,
 +			      struct tls_context *tls_ctx,
 +			      enum tls_offload_ctx_dir direction);
 +#endif
++=======
++>>>>>>> 0ec78cdb1ab1 (cxgb4/ch_ipsec: Replace the module name to ch_ipsec from chcr)
  #endif /* __CHCR_CORE_H__ */
diff --cc drivers/crypto/chelsio/chcr_ipsec.c
index 057e74c82fcd,072299b14b8d..000000000000
--- a/drivers/crypto/chelsio/chcr_ipsec.c
+++ b/drivers/crypto/chelsio/chcr_ipsec.c
@@@ -72,39 -69,80 +72,99 @@@
  #define MAX_IMM_TX_PKT_LEN 256
  #define GCM_ESP_IV_SIZE     8
  
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ipsec.c
 +static int chcr_xfrm_add_state(struct xfrm_state *x);
 +static void chcr_xfrm_del_state(struct xfrm_state *x);
 +static void chcr_xfrm_free_state(struct xfrm_state *x);
 +static bool chcr_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x);
 +static void chcr_advance_esn_state(struct xfrm_state *x);
- 
- static const struct xfrmdev_ops chcr_xfrmdev_ops = {
- 	.xdo_dev_state_add      = chcr_xfrm_add_state,
- 	.xdo_dev_state_delete   = chcr_xfrm_del_state,
- 	.xdo_dev_state_free     = chcr_xfrm_free_state,
- 	.xdo_dev_offload_ok     = chcr_ipsec_offload_ok,
- 	.xdo_dev_state_advance_esn = chcr_advance_esn_state,
++=======
+ static LIST_HEAD(uld_ctx_list);
+ static DEFINE_MUTEX(dev_mutex);
+ 
+ static bool ch_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x);
+ static int ch_ipsec_uld_state_change(void *handle, enum cxgb4_state new_state);
+ static int ch_ipsec_xmit(struct sk_buff *skb, struct net_device *dev);
+ static void *ch_ipsec_uld_add(const struct cxgb4_lld_info *infop);
+ static void ch_ipsec_advance_esn_state(struct xfrm_state *x);
+ static void ch_ipsec_xfrm_free_state(struct xfrm_state *x);
+ static void ch_ipsec_xfrm_del_state(struct xfrm_state *x);
+ static int ch_ipsec_xfrm_add_state(struct xfrm_state *x);
++>>>>>>> 0ec78cdb1ab1 (cxgb4/ch_ipsec: Replace the module name to ch_ipsec from chcr):drivers/net/ethernet/chelsio/inline_crypto/ch_ipsec/chcr_ipsec.c
+ 
+ static const struct xfrmdev_ops ch_ipsec_xfrmdev_ops = {
+ 	.xdo_dev_state_add      = ch_ipsec_xfrm_add_state,
+ 	.xdo_dev_state_delete   = ch_ipsec_xfrm_del_state,
+ 	.xdo_dev_state_free     = ch_ipsec_xfrm_free_state,
+ 	.xdo_dev_offload_ok     = ch_ipsec_offload_ok,
+ 	.xdo_dev_state_advance_esn = ch_ipsec_advance_esn_state,
  };
  
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ipsec.c
 +/* Add offload xfrms to Chelsio Interface */
 +void chcr_add_xfrmops(const struct cxgb4_lld_info *lld)
++=======
+ static struct cxgb4_uld_info ch_ipsec_uld_info = {
+ 	.name = CHIPSEC_DRV_MODULE_NAME,
+ 	.nrxq = MAX_ULD_QSETS,
+ 	/* Max ntxq will be derived from fw config file*/
+ 	.rxq_size = 1024,
+ 	.add = ch_ipsec_uld_add,
+ 	.state_change = ch_ipsec_uld_state_change,
+ 	.tx_handler = ch_ipsec_xmit,
+ 	.xfrmdev_ops = &ch_ipsec_xfrmdev_ops,
+ };
+ 
+ static void *ch_ipsec_uld_add(const struct cxgb4_lld_info *infop)
++>>>>>>> 0ec78cdb1ab1 (cxgb4/ch_ipsec: Replace the module name to ch_ipsec from chcr):drivers/net/ethernet/chelsio/inline_crypto/ch_ipsec/chcr_ipsec.c
  {
 -	struct ipsec_uld_ctx *u_ctx;
 -
 -	pr_info_once("%s - version %s\n", CHIPSEC_DRV_DESC,
 -		     CHIPSEC_DRV_VERSION);
 -	u_ctx = kzalloc(sizeof(*u_ctx), GFP_KERNEL);
 -	if (!u_ctx) {
 -		u_ctx = ERR_PTR(-ENOMEM);
 -		goto out;
 -	}
 +	struct net_device *netdev = NULL;
 +	int i;
 +
 +	for (i = 0; i < lld->nports; i++) {
 +		netdev = lld->ports[i];
 +		if (!netdev)
 +			continue;
 +		netdev->xfrmdev_ops = &chcr_xfrmdev_ops;
 +		netdev->hw_enc_features |= NETIF_F_HW_ESP;
 +		netdev->features |= NETIF_F_HW_ESP;
 +		netdev_change_features(netdev);
 +	}
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ipsec.c
++=======
+ 	u_ctx->lldi = *infop;
+ out:
+ 	return u_ctx;
  }
  
- static inline int chcr_ipsec_setauthsize(struct xfrm_state *x,
- 					 struct ipsec_sa_entry *sa_entry)
+ static int ch_ipsec_uld_state_change(void *handle, enum cxgb4_state new_state)
+ {
+ 	struct ipsec_uld_ctx *u_ctx = handle;
+ 
+ 	pr_debug("new_state %u\n", new_state);
+ 	switch (new_state) {
+ 	case CXGB4_STATE_UP:
+ 		pr_info("%s: Up\n", pci_name(u_ctx->lldi.pdev));
+ 		mutex_lock(&dev_mutex);
+ 		list_add_tail(&u_ctx->entry, &uld_ctx_list);
+ 		mutex_unlock(&dev_mutex);
+ 		break;
+ 	case CXGB4_STATE_START_RECOVERY:
+ 	case CXGB4_STATE_DOWN:
+ 	case CXGB4_STATE_DETACH:
+ 		pr_info("%s: Down\n", pci_name(u_ctx->lldi.pdev));
+ 		list_del(&u_ctx->entry);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 0ec78cdb1ab1 (cxgb4/ch_ipsec: Replace the module name to ch_ipsec from chcr):drivers/net/ethernet/chelsio/inline_crypto/ch_ipsec/chcr_ipsec.c
+ }
+ 
+ static int ch_ipsec_setauthsize(struct xfrm_state *x,
+ 				struct ipsec_sa_entry *sa_entry)
  {
  	int hmac_ctrl;
  	int authsize = x->aead->alg_icv_len / 8;
@@@ -127,10 -165,9 +187,10 @@@
  	return hmac_ctrl;
  }
  
- static inline int chcr_ipsec_setkey(struct xfrm_state *x,
- 				    struct ipsec_sa_entry *sa_entry)
+ static int ch_ipsec_setkey(struct xfrm_state *x,
+ 			   struct ipsec_sa_entry *sa_entry)
  {
 +	struct crypto_cipher *cipher;
  	int keylen = (x->aead->alg_key_len + 7) / 8;
  	unsigned char *key = x->aead->alg_key;
  	int ck_size, key_ctx_size = 0;
@@@ -763,3 -791,35 +823,38 @@@ out_free:       dev_kfree_skb_any(skb)
  	cxgb4_ring_tx_db(adap, &q->q, ndesc);
  	return NETDEV_TX_OK;
  }
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ipsec.c
++=======
+ 
+ static int __init ch_ipsec_init(void)
+ {
+ 	cxgb4_register_uld(CXGB4_ULD_IPSEC, &ch_ipsec_uld_info);
+ 
+ 	return 0;
+ }
+ 
+ static void __exit ch_ipsec_exit(void)
+ {
+ 	struct ipsec_uld_ctx *u_ctx, *tmp;
+ 	struct adapter *adap;
+ 
+ 	mutex_lock(&dev_mutex);
+ 	list_for_each_entry_safe(u_ctx, tmp, &uld_ctx_list, entry) {
+ 		adap = pci_get_drvdata(u_ctx->lldi.pdev);
+ 		atomic_set(&adap->ch_ipsec_stats.ipsec_cnt, 0);
+ 		list_del(&u_ctx->entry);
+ 		kfree(u_ctx);
+ 	}
+ 	mutex_unlock(&dev_mutex);
+ 	cxgb4_unregister_uld(CXGB4_ULD_IPSEC);
+ }
+ 
+ module_init(ch_ipsec_init);
+ module_exit(ch_ipsec_exit);
+ 
+ MODULE_DESCRIPTION("Crypto IPSEC for Chelsio Terminator cards.");
+ MODULE_LICENSE("GPL");
+ MODULE_AUTHOR("Chelsio Communications");
+ MODULE_VERSION(CHIPSEC_DRV_VERSION);
+ 
++>>>>>>> 0ec78cdb1ab1 (cxgb4/ch_ipsec: Replace the module name to ch_ipsec from chcr):drivers/net/ethernet/chelsio/inline_crypto/ch_ipsec/chcr_ipsec.c
* Unmerged path drivers/crypto/chelsio/chcr_core.h
* Unmerged path drivers/crypto/chelsio/chcr_ipsec.c
