ch_ktls: fix device connection close

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Vinay Kumar Yadav <vinay.yadav@chelsio.com>
commit bc16efd2430652f894ae34b1de5eccc3bf0d2810
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/bc16efd2.failed

When sge queue is full and chcr_ktls_xmit_wr_complete()
returns failure, skb is not freed if it is not the last tls record in
this skb, causes refcount never gets freed and tls_dev_del()
never gets called on this connection.

Fixes: 5a4b9fe7fece ("cxgb4/chcr: complete record tx handling")
	Signed-off-by: Vinay Kumar Yadav <vinay.yadav@chelsio.com>
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bc16efd2430652f894ae34b1de5eccc3bf0d2810)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_ktls.c
diff --cc drivers/crypto/chelsio/chcr_ktls.c
index 887ecc2060e8,a626560f8365..000000000000
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@@ -1634,10 -1732,12 +1634,12 @@@ static int chcr_end_part_handler(struc
  				 struct sk_buff *skb,
  				 struct tls_record_info *record,
  				 u32 tcp_seq, int mss, bool tcp_push_no_fin,
 -				 struct sge_eth_txq *q, u32 skb_offset,
 +				 struct sge_eth_txq *q,
  				 u32 tls_end_offset, bool last_wr)
  {
+ 	bool free_skb_if_tx_fails = false;
  	struct sk_buff *nskb = NULL;
+ 
  	/* check if it is a complete record */
  	if (tls_end_offset == record->len) {
  		nskb = skb;
@@@ -1654,19 -1755,29 +1656,35 @@@
  		 * accordingly.
  		 */
  		tcp_seq = tls_record_start_seq(record);
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +		/* reset snd una, so the middle record won't send the already
 +		 * sent part.
 +		 */
 +		if (chcr_ktls_update_snd_una(tx_info, q))
 +			goto out;
 +		atomic64_inc(&tx_info->adap->chcr_stats.ktls_tx_end_pkts);
++=======
+ 		/* reset skb offset */
+ 		skb_offset = 0;
+ 
+ 		if (last_wr)
+ 			dev_kfree_skb_any(skb);
+ 		else
+ 			free_skb_if_tx_fails = true;
+ 
+ 		last_wr = true;
+ 
+ 		atomic64_inc(&tx_info->adap->ch_ktls_stats.ktls_tx_end_pkts);
++>>>>>>> bc16efd24306 (ch_ktls: fix device connection close):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  	}
  
  	if (chcr_ktls_xmit_wr_complete(nskb, tx_info, q, tcp_seq,
 -				       last_wr, record->len, skb_offset,
 -				       record->num_frags,
  				       (last_wr && tcp_push_no_fin),
  				       mss)) {
+ 		if (free_skb_if_tx_fails)
+ 			dev_kfree_skb_any(skb);
  		goto out;
  	}
 -	tx_info->prev_seq = record->end_seq;
  	return 0;
  out:
  	dev_kfree_skb_any(nskb);
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
