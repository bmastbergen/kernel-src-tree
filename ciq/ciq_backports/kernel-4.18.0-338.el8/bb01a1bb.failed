bpf: Fix mask direction swap upon off reg sign change

jira LE-1907
cve CVE-2021-29155
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit bb01a1bba579b4b1c5566af24d95f1767859771e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/bb01a1bb.failed

Masking direction as indicated via mask_to_left is considered to be
calculated once and then used to derive pointer limits. Thus, this
needs to be placed into bpf_sanitize_info instead so we can pass it
to sanitize_ptr_alu() call after the pointer move. Piotr noticed a
corner case where the off reg causes masking direction change which
then results in an incorrect final aux->alu_limit.

Fixes: 7fedb63a8307 ("bpf: Tighten speculative pointer arithmetic mask")
	Reported-by: Piotr Krysiuk <piotras@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Reviewed-by: Piotr Krysiuk <piotras@gmail.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit bb01a1bba579b4b1c5566af24d95f1767859771e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index e65c8ec142c6,8574cb60915a..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5778,12 -6400,18 +5778,18 @@@ static struct bpf_insn_aux_data *cur_au
  	return &env->insn_aux_data[env->insn_idx];
  }
  
 -enum {
 -	REASON_BOUNDS	= -1,
 -	REASON_TYPE	= -2,
 -	REASON_PATHS	= -3,
 -	REASON_LIMIT	= -4,
 -	REASON_STACK	= -5,
 -};
 -
  static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,
++<<<<<<< HEAD
 +			      u32 *ptr_limit, u8 opcode, bool off_is_neg)
 +{
 +	bool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||
 +			    (opcode == BPF_SUB && !off_is_neg);
 +	u32 off, max;
++=======
+ 			      u32 *alu_limit, bool mask_to_left)
+ {
+ 	u32 max = 0, ptr_limit = 0;
++>>>>>>> bb01a1bba579 (bpf: Fix mask direction swap upon off reg sign change)
  
  	switch (ptr_reg->type) {
  	case PTR_TO_STACK:
@@@ -5848,6 -6473,16 +5854,19 @@@ static int sanitize_val_alu(struct bpf_
  	return update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static bool sanitize_needed(u8 opcode)
+ {
+ 	return opcode == BPF_ADD || opcode == BPF_SUB;
+ }
+ 
+ struct bpf_sanitize_info {
+ 	struct bpf_insn_aux_data aux;
+ 	bool mask_to_left;
+ };
+ 
++>>>>>>> bb01a1bba579 (bpf: Fix mask direction swap upon off reg sign change)
  static int sanitize_ptr_alu(struct bpf_verifier_env *env,
  			    struct bpf_insn *insn,
  			    const struct bpf_reg_state *ptr_reg,
@@@ -5874,11 -6512,16 +5893,24 @@@
  	if (vstate->speculative)
  		goto do_sim;
  
++<<<<<<< HEAD
 +	alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;
 +	alu_state |= ptr_is_dst_reg ?
 +		     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;
 +
 +	err = retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg);
++=======
+ 	if (!commit_window) {
+ 		if (!tnum_is_const(off_reg->var_off) &&
+ 		    (off_reg->smin_value < 0) != (off_reg->smax_value < 0))
+ 			return REASON_BOUNDS;
+ 
+ 		info->mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||
+ 				     (opcode == BPF_SUB && !off_is_neg);
+ 	}
+ 
+ 	err = retrieve_ptr_limit(ptr_reg, &alu_limit, info->mask_to_left);
++>>>>>>> bb01a1bba579 (bpf: Fix mask direction swap upon off reg sign change)
  	if (err < 0)
  		return err;
  
* Unmerged path kernel/bpf/verifier.c
