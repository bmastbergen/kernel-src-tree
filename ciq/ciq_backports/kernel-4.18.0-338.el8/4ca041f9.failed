netfilter: nf_tables: Fix dereference of null pointer flow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit 4ca041f919f13783b0b03894783deee00dbca19a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/4ca041f9.failed

In the case where chain->flags & NFT_CHAIN_HW_OFFLOAD is false then
nft_flow_rule_create is not called and flow is NULL. The subsequent
error handling execution via label err_destroy_flow_rule will lead
to a null pointer dereference on flow when calling nft_flow_rule_destroy.
Since the error path to err_destroy_flow_rule has to cater for null
and non-null flows, only call nft_flow_rule_destroy if flow is non-null
to fix this issue.

Addresses-Coverity: ("Explicity null dereference")
Fixes: 3c5e44622011 ("netfilter: nf_tables: memleak in hw offload abort path")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 4ca041f919f13783b0b03894783deee00dbca19a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 7ef71dac0666,de182d1f7c4e..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3195,32 -3434,32 +3195,39 @@@ static int nf_tables_newrule(struct ne
  				list_add_rcu(&rule->list, &chain->rules);
  		}
  	}
 -	kvfree(expr_info);
 +	kvfree(info);
  	chain->use++;
  
 -	if (flow)
 -		nft_trans_flow_rule(trans) = flow;
 -
 -	if (nft_net->validate_state == NFT_VALIDATE_DO)
 +	if (net->nft.validate_state == NFT_VALIDATE_DO)
  		return nft_table_validate(net, table);
  
 -	return 0;
 +	if (chain->flags & NFT_CHAIN_HW_OFFLOAD) {
 +		flow = nft_flow_rule_create(net, rule);
 +		if (IS_ERR(flow))
 +			return PTR_ERR(flow);
  
 -err_destroy_flow_rule:
 -	if (flow)
 -		nft_flow_rule_destroy(flow);
++<<<<<<< HEAD
 +		nft_trans_flow_rule(trans) = flow;
 +	}
 +
 +	return 0;
 +err2:
++=======
++err_destroy_flow_rule:
++	if (flow)
++		nft_flow_rule_destroy(flow);
+ err_release_rule:
++>>>>>>> 4ca041f919f1 (netfilter: nf_tables: Fix dereference of null pointer flow)
  	nf_tables_rule_release(&ctx, rule);
 -err_release_expr:
 +err1:
  	for (i = 0; i < n; i++) {
 -		if (expr_info[i].ops) {
 -			module_put(expr_info[i].ops->type->owner);
 -			if (expr_info[i].ops->type->release_ops)
 -				expr_info[i].ops->type->release_ops(expr_info[i].ops);
 +		if (info[i].ops) {
 +			module_put(info[i].ops->type->owner);
 +			if (info[i].ops->type->release_ops)
 +				info[i].ops->type->release_ops(info[i].ops);
  		}
  	}
 -	kvfree(expr_info);
 -
 +	kvfree(info);
  	return err;
  }
  
* Unmerged path net/netfilter/nf_tables_api.c
