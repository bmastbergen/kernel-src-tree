cxgb4: add main VI to mirror VI config replication

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
commit 696c278fdfd8dd852af286fcebaacc11adbf20f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/696c278f.failed

When mirror VI is enabled, replicate various VI config params
enabled on main VI to mirror VI. These include replicating MTU,
promiscuous mode, all-multicast mode, and enabled netdev Rx
feature offloads.

v3:
- Replace mirror VI refcount_t with normal u32 variable.
- Add back calling cxgb4_port_mirror_start() in cxgb_open(), which
  was there in v1, but got missed in v2 during refactoring.

v2:
- Simplify the replication code by refactoring t4_set_rxmode()
  to handle mirror VI, instead of duplicating the t4_set_rxmode()
  calls in multiple places.

	Signed-off-by: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 696c278fdfd8dd852af286fcebaacc11adbf20f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 1f97b12b19c9,0991631f3a91..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -1292,6 -1297,292 +1293,295 @@@ static int setup_debugfs(struct adapte
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void cxgb4_port_mirror_free_rxq(struct adapter *adap,
+ 				       struct sge_eth_rxq *mirror_rxq)
+ {
+ 	if ((adap->flags & CXGB4_FULL_INIT_DONE) &&
+ 	    !(adap->flags & CXGB4_SHUTTING_DOWN))
+ 		cxgb4_quiesce_rx(&mirror_rxq->rspq);
+ 
+ 	if (adap->flags & CXGB4_USING_MSIX) {
+ 		cxgb4_clear_msix_aff(mirror_rxq->msix->vec,
+ 				     mirror_rxq->msix->aff_mask);
+ 		free_irq(mirror_rxq->msix->vec, &mirror_rxq->rspq);
+ 		cxgb4_free_msix_idx_in_bmap(adap, mirror_rxq->msix->idx);
+ 	}
+ 
+ 	free_rspq_fl(adap, &mirror_rxq->rspq, &mirror_rxq->fl);
+ }
+ 
+ static int cxgb4_port_mirror_alloc_queues(struct net_device *dev)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	struct sge_eth_rxq *mirror_rxq;
+ 	struct sge *s = &adap->sge;
+ 	int ret = 0, msix = 0;
+ 	u16 i, rxqid;
+ 	u16 *rss;
+ 
+ 	if (!pi->vi_mirror_count)
+ 		return 0;
+ 
+ 	if (s->mirror_rxq[pi->port_id])
+ 		return 0;
+ 
+ 	mirror_rxq = kcalloc(pi->nmirrorqsets, sizeof(*mirror_rxq), GFP_KERNEL);
+ 	if (!mirror_rxq)
+ 		return -ENOMEM;
+ 
+ 	s->mirror_rxq[pi->port_id] = mirror_rxq;
+ 
+ 	if (!(adap->flags & CXGB4_USING_MSIX))
+ 		msix = -((int)adap->sge.intrq.abs_id + 1);
+ 
+ 	for (i = 0, rxqid = 0; i < pi->nmirrorqsets; i++, rxqid++) {
+ 		mirror_rxq = &s->mirror_rxq[pi->port_id][i];
+ 
+ 		/* Allocate Mirror Rxqs */
+ 		if (msix >= 0) {
+ 			msix = cxgb4_get_msix_idx_from_bmap(adap);
+ 			if (msix < 0) {
+ 				ret = msix;
+ 				goto out_free_queues;
+ 			}
+ 
+ 			mirror_rxq->msix = &adap->msix_info[msix];
+ 			snprintf(mirror_rxq->msix->desc,
+ 				 sizeof(mirror_rxq->msix->desc),
+ 				 "%s-mirrorrxq%d", dev->name, i);
+ 		}
+ 
+ 		init_rspq(adap, &mirror_rxq->rspq,
+ 			  CXGB4_MIRROR_RXQ_DEFAULT_INTR_USEC,
+ 			  CXGB4_MIRROR_RXQ_DEFAULT_PKT_CNT,
+ 			  CXGB4_MIRROR_RXQ_DEFAULT_DESC_NUM,
+ 			  CXGB4_MIRROR_RXQ_DEFAULT_DESC_SIZE);
+ 
+ 		mirror_rxq->fl.size = CXGB4_MIRROR_FLQ_DEFAULT_DESC_NUM;
+ 
+ 		ret = t4_sge_alloc_rxq(adap, &mirror_rxq->rspq, false,
+ 				       dev, msix, &mirror_rxq->fl,
+ 				       t4_ethrx_handler, NULL, 0);
+ 		if (ret)
+ 			goto out_free_msix_idx;
+ 
+ 		/* Setup MSI-X vectors for Mirror Rxqs */
+ 		if (adap->flags & CXGB4_USING_MSIX) {
+ 			ret = request_irq(mirror_rxq->msix->vec,
+ 					  t4_sge_intr_msix, 0,
+ 					  mirror_rxq->msix->desc,
+ 					  &mirror_rxq->rspq);
+ 			if (ret)
+ 				goto out_free_rxq;
+ 
+ 			cxgb4_set_msix_aff(adap, mirror_rxq->msix->vec,
+ 					   &mirror_rxq->msix->aff_mask, i);
+ 		}
+ 
+ 		/* Start NAPI for Mirror Rxqs */
+ 		cxgb4_enable_rx(adap, &mirror_rxq->rspq);
+ 	}
+ 
+ 	/* Setup RSS for Mirror Rxqs */
+ 	rss = kcalloc(pi->rss_size, sizeof(u16), GFP_KERNEL);
+ 	if (!rss) {
+ 		ret = -ENOMEM;
+ 		goto out_free_queues;
+ 	}
+ 
+ 	mirror_rxq = &s->mirror_rxq[pi->port_id][0];
+ 	for (i = 0; i < pi->rss_size; i++)
+ 		rss[i] = mirror_rxq[i % pi->nmirrorqsets].rspq.abs_id;
+ 
+ 	ret = cxgb4_config_rss(pi, rss, pi->rss_size, pi->viid_mirror);
+ 	kfree(rss);
+ 	if (ret)
+ 		goto out_free_queues;
+ 
+ 	return 0;
+ 
+ out_free_rxq:
+ 	free_rspq_fl(adap, &mirror_rxq->rspq, &mirror_rxq->fl);
+ 
+ out_free_msix_idx:
+ 	cxgb4_free_msix_idx_in_bmap(adap, mirror_rxq->msix->idx);
+ 
+ out_free_queues:
+ 	while (rxqid-- > 0)
+ 		cxgb4_port_mirror_free_rxq(adap,
+ 					   &s->mirror_rxq[pi->port_id][rxqid]);
+ 
+ 	kfree(s->mirror_rxq[pi->port_id]);
+ 	s->mirror_rxq[pi->port_id] = NULL;
+ 	return ret;
+ }
+ 
+ static void cxgb4_port_mirror_free_queues(struct net_device *dev)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	struct sge *s = &adap->sge;
+ 	u16 i;
+ 
+ 	if (!pi->vi_mirror_count)
+ 		return;
+ 
+ 	if (!s->mirror_rxq[pi->port_id])
+ 		return;
+ 
+ 	for (i = 0; i < pi->nmirrorqsets; i++)
+ 		cxgb4_port_mirror_free_rxq(adap,
+ 					   &s->mirror_rxq[pi->port_id][i]);
+ 
+ 	kfree(s->mirror_rxq[pi->port_id]);
+ 	s->mirror_rxq[pi->port_id] = NULL;
+ }
+ 
+ static int cxgb4_port_mirror_start(struct net_device *dev)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	int ret, idx = -1;
+ 
+ 	if (!pi->vi_mirror_count)
+ 		return 0;
+ 
+ 	/* Mirror VIs can be created dynamically after stack had
+ 	 * already setup Rx modes like MTU, promisc, allmulti, etc.
+ 	 * on main VI. So, parse what the stack had setup on the
+ 	 * main VI and update the same on the mirror VI.
+ 	 */
+ 	ret = t4_set_rxmode(adap, adap->mbox, pi->viid, pi->viid_mirror,
+ 			    dev->mtu, (dev->flags & IFF_PROMISC) ? 1 : 0,
+ 			    (dev->flags & IFF_ALLMULTI) ? 1 : 0, 1,
+ 			    !!(dev->features & NETIF_F_HW_VLAN_CTAG_RX), true);
+ 	if (ret) {
+ 		dev_err(adap->pdev_dev,
+ 			"Failed start up Rx mode for Mirror VI 0x%x, ret: %d\n",
+ 			pi->viid_mirror, ret);
+ 		return ret;
+ 	}
+ 
+ 	/* Enable replication bit for the device's MAC address
+ 	 * in MPS TCAM, so that the packets for the main VI are
+ 	 * replicated to mirror VI.
+ 	 */
+ 	ret = cxgb4_update_mac_filt(pi, pi->viid_mirror, &idx,
+ 				    dev->dev_addr, true, NULL);
+ 	if (ret) {
+ 		dev_err(adap->pdev_dev,
+ 			"Failed updating MAC filter for Mirror VI 0x%x, ret: %d\n",
+ 			pi->viid_mirror, ret);
+ 		return ret;
+ 	}
+ 
+ 	/* Enabling a Virtual Interface can result in an interrupt
+ 	 * during the processing of the VI Enable command and, in some
+ 	 * paths, result in an attempt to issue another command in the
+ 	 * interrupt context. Thus, we disable interrupts during the
+ 	 * course of the VI Enable command ...
+ 	 */
+ 	local_bh_disable();
+ 	ret = t4_enable_vi_params(adap, adap->mbox, pi->viid_mirror, true, true,
+ 				  false);
+ 	local_bh_enable();
+ 	if (ret)
+ 		dev_err(adap->pdev_dev,
+ 			"Failed starting Mirror VI 0x%x, ret: %d\n",
+ 			pi->viid_mirror, ret);
+ 
+ 	return ret;
+ }
+ 
+ static void cxgb4_port_mirror_stop(struct net_device *dev)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 
+ 	if (!pi->vi_mirror_count)
+ 		return;
+ 
+ 	t4_enable_vi_params(adap, adap->mbox, pi->viid_mirror, false, false,
+ 			    false);
+ }
+ 
+ int cxgb4_port_mirror_alloc(struct net_device *dev)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 	int ret = 0;
+ 
+ 	if (!pi->nmirrorqsets)
+ 		return -EOPNOTSUPP;
+ 
+ 	mutex_lock(&pi->vi_mirror_mutex);
+ 	if (pi->viid_mirror) {
+ 		pi->vi_mirror_count++;
+ 		goto out_unlock;
+ 	}
+ 
+ 	ret = t4_init_port_mirror(pi, adap->mbox, pi->port_id, adap->pf, 0,
+ 				  &pi->viid_mirror);
+ 	if (ret)
+ 		goto out_unlock;
+ 
+ 	pi->vi_mirror_count = 1;
+ 
+ 	if (adap->flags & CXGB4_FULL_INIT_DONE) {
+ 		ret = cxgb4_port_mirror_alloc_queues(dev);
+ 		if (ret)
+ 			goto out_free_vi;
+ 
+ 		ret = cxgb4_port_mirror_start(dev);
+ 		if (ret)
+ 			goto out_free_queues;
+ 	}
+ 
+ 	mutex_unlock(&pi->vi_mirror_mutex);
+ 	return 0;
+ 
+ out_free_queues:
+ 	cxgb4_port_mirror_free_queues(dev);
+ 
+ out_free_vi:
+ 	pi->vi_mirror_count = 0;
+ 	t4_free_vi(adap, adap->mbox, adap->pf, 0, pi->viid_mirror);
+ 	pi->viid_mirror = 0;
+ 
+ out_unlock:
+ 	mutex_unlock(&pi->vi_mirror_mutex);
+ 	return ret;
+ }
+ 
+ void cxgb4_port_mirror_free(struct net_device *dev)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 	struct adapter *adap = netdev2adap(dev);
+ 
+ 	mutex_lock(&pi->vi_mirror_mutex);
+ 	if (!pi->viid_mirror)
+ 		goto out_unlock;
+ 
+ 	if (pi->vi_mirror_count > 1) {
+ 		pi->vi_mirror_count--;
+ 		goto out_unlock;
+ 	}
+ 
+ 	cxgb4_port_mirror_stop(dev);
+ 	cxgb4_port_mirror_free_queues(dev);
+ 
+ 	pi->vi_mirror_count = 0;
+ 	t4_free_vi(adap, adap->mbox, adap->pf, 0, pi->viid_mirror);
+ 	pi->viid_mirror = 0;
+ 
+ out_unlock:
+ 	mutex_unlock(&pi->vi_mirror_mutex);
+ }
+ 
++>>>>>>> 696c278fdfd8 (cxgb4: add main VI to mirror VI config replication)
  /*
   * upper-layer driver support
   */
@@@ -2563,8 -2855,29 +2853,34 @@@ int cxgb_open(struct net_device *dev
  		return err;
  
  	err = link_start(dev);
++<<<<<<< HEAD
 +	if (!err)
 +		netif_tx_start_all_queues(dev);
++=======
+ 	if (err)
+ 		return err;
+ 
+ 	if (pi->nmirrorqsets) {
+ 		mutex_lock(&pi->vi_mirror_mutex);
+ 		err = cxgb4_port_mirror_alloc_queues(dev);
+ 		if (err)
+ 			goto out_unlock;
+ 
+ 		err = cxgb4_port_mirror_start(dev);
+ 		if (err)
+ 			goto out_free_queues;
+ 		mutex_unlock(&pi->vi_mirror_mutex);
+ 	}
+ 
+ 	netif_tx_start_all_queues(dev);
+ 	return 0;
+ 
+ out_free_queues:
+ 	cxgb4_port_mirror_free_queues(dev);
+ 
+ out_unlock:
+ 	mutex_unlock(&pi->vi_mirror_mutex);
++>>>>>>> 696c278fdfd8 (cxgb4: add main VI to mirror VI config replication)
  	return err;
  }
  
@@@ -2582,7 -2895,17 +2898,21 @@@ int cxgb_close(struct net_device *dev
  	cxgb4_dcb_reset(dev);
  	dcb_tx_queue_prio_enable(dev, false);
  #endif
++<<<<<<< HEAD
 +	return ret;
++=======
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pi->nmirrorqsets) {
+ 		mutex_lock(&pi->vi_mirror_mutex);
+ 		cxgb4_port_mirror_stop(dev);
+ 		cxgb4_port_mirror_free_queues(dev);
+ 		mutex_unlock(&pi->vi_mirror_mutex);
+ 	}
+ 
+ 	return 0;
++>>>>>>> 696c278fdfd8 (cxgb4: add main VI to mirror VI config replication)
  }
  
  int cxgb4_create_server_filter(const struct net_device *dev, unsigned int stid,
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index de332a7d4963..b0d1632eae7b 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -1969,8 +1969,8 @@ int t4_free_vi(struct adapter *adap, unsigned int mbox,
 	       unsigned int pf, unsigned int vf,
 	       unsigned int viid);
 int t4_set_rxmode(struct adapter *adap, unsigned int mbox, unsigned int viid,
-		int mtu, int promisc, int all_multi, int bcast, int vlanex,
-		bool sleep_ok);
+		  unsigned int viid_mirror, int mtu, int promisc, int all_multi,
+		  int bcast, int vlanex, bool sleep_ok);
 int t4_free_raw_mac_filt(struct adapter *adap, unsigned int viid,
 			 const u8 *addr, const u8 *mask, unsigned int idx,
 			 u8 lookup_type, u8 port_id, bool sleep_ok);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index d4ebff41df51..9c8a913f0b91 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -7708,6 +7708,7 @@ int t4_free_vi(struct adapter *adap, unsigned int mbox, unsigned int pf,
  *	@adap: the adapter
  *	@mbox: mailbox to use for the FW command
  *	@viid: the VI id
+ *	@viid_mirror: the mirror VI id
  *	@mtu: the new MTU or -1
  *	@promisc: 1 to enable promiscuous mode, 0 to disable it, -1 no change
  *	@all_multi: 1 to enable all-multi mode, 0 to disable it, -1 no change
@@ -7718,10 +7719,11 @@ int t4_free_vi(struct adapter *adap, unsigned int mbox, unsigned int pf,
  *	Sets Rx properties of a virtual interface.
  */
 int t4_set_rxmode(struct adapter *adap, unsigned int mbox, unsigned int viid,
-		  int mtu, int promisc, int all_multi, int bcast, int vlanex,
-		  bool sleep_ok)
+		  unsigned int viid_mirror, int mtu, int promisc, int all_multi,
+		  int bcast, int vlanex, bool sleep_ok)
 {
-	struct fw_vi_rxmode_cmd c;
+	struct fw_vi_rxmode_cmd c, c_mirror;
+	int ret;
 
 	/* convert to FW values */
 	if (mtu < 0)
@@ -7746,7 +7748,24 @@ int t4_set_rxmode(struct adapter *adap, unsigned int mbox, unsigned int viid,
 			    FW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |
 			    FW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |
 			    FW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));
-	return t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
+
+	if (viid_mirror) {
+		memcpy(&c_mirror, &c, sizeof(c_mirror));
+		c_mirror.op_to_viid =
+			cpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |
+				    FW_CMD_REQUEST_F | FW_CMD_WRITE_F |
+				    FW_VI_RXMODE_CMD_VIID_V(viid_mirror));
+	}
+
+	ret = t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
+	if (ret)
+		return ret;
+
+	if (viid_mirror)
+		ret = t4_wr_mbox_meat(adap, mbox, &c_mirror, sizeof(c_mirror),
+				      NULL, sleep_ok);
+
+	return ret;
 }
 
 /**
