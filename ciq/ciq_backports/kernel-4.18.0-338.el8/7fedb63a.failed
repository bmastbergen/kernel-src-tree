bpf: Tighten speculative pointer arithmetic mask

jira LE-1907
cve CVE-2021-33200
cve CVE-2021-29155
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/7fedb63a.failed

This work tightens the offset mask we use for unprivileged pointer arithmetic
in order to mitigate a corner case reported by Piotr and Benedict where in
the speculative domain it is possible to advance, for example, the map value
pointer by up to value_size-1 out-of-bounds in order to leak kernel memory
via side-channel to user space.

Before this change, the computed ptr_limit for retrieve_ptr_limit() helper
represents largest valid distance when moving pointer to the right or left
which is then fed as aux->alu_limit to generate masking instructions against
the offset register. After the change, the derived aux->alu_limit represents
the largest potential value of the offset register which we mask against which
is just a narrower subset of the former limit.

For minimal complexity, we call sanitize_ptr_alu() from 2 observation points
in adjust_ptr_min_max_vals(), that is, before and after the simulated alu
operation. In the first step, we retieve the alu_state and alu_limit before
the operation as well as we branch-off a verifier path and push it to the
verification stack as we did before which checks the dst_reg under truncation,
in other words, when the speculative domain would attempt to move the pointer
out-of-bounds.

In the second step, we retrieve the new alu_limit and calculate the absolute
distance between both. Moreover, we commit the alu_state and final alu_limit
via update_alu_sanitation_state() to the env's instruction aux data, and bail
out from there if there is a mismatch due to coming from different verification
paths with different states.

	Reported-by: Piotr Krysiuk <piotras@gmail.com>
	Reported-by: Benedict Schlueter <benedict.schlueter@rub.de>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Reviewed-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Tested-by: Benedict Schlueter <benedict.schlueter@rub.de>
(cherry picked from commit 7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 4bfae8a52d70,0399ac092b36..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5778,40 -5856,51 +5778,61 @@@ static struct bpf_insn_aux_data *cur_au
  	return &env->insn_aux_data[env->insn_idx];
  }
  
 -enum {
 -	REASON_BOUNDS	= -1,
 -	REASON_TYPE	= -2,
 -	REASON_PATHS	= -3,
 -	REASON_LIMIT	= -4,
 -	REASON_STACK	= -5,
 -};
 -
  static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,
 -			      const struct bpf_reg_state *off_reg,
 -			      u32 *alu_limit, u8 opcode)
 +			      u32 *ptr_limit, u8 opcode, bool off_is_neg)
  {
 -	bool off_is_neg = off_reg->smin_value < 0;
  	bool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||
  			    (opcode == BPF_SUB && !off_is_neg);
++<<<<<<< HEAD
 +	u32 off, max;
++=======
+ 	u32 max = 0, ptr_limit = 0;
+ 
+ 	if (!tnum_is_const(off_reg->var_off) &&
+ 	    (off_reg->smin_value < 0) != (off_reg->smax_value < 0))
+ 		return REASON_BOUNDS;
++>>>>>>> 7fedb63a8307 (bpf: Tighten speculative pointer arithmetic mask)
  
  	switch (ptr_reg->type) {
  	case PTR_TO_STACK:
  		/* Offset 0 is out-of-bounds, but acceptable start for the
- 		 * left direction, see BPF_REG_FP.
+ 		 * left direction, see BPF_REG_FP. Also, unknown scalar
+ 		 * offset where we would need to deal with min/max bounds is
+ 		 * currently prohibited for unprivileged.
  		 */
  		max = MAX_BPF_STACK + mask_to_left;
++<<<<<<< HEAD
 +		/* Indirect variable offset stack access is prohibited in
 +		 * unprivileged mode so it's not handled here.
 +		 */
 +		off = ptr_reg->off + ptr_reg->var_off.value;
 +		if (mask_to_left)
 +			*ptr_limit = MAX_BPF_STACK + off;
 +		else
 +			*ptr_limit = -off - 1;
 +		return *ptr_limit >= max ? -ERANGE : 0;
 +	case PTR_TO_MAP_VALUE:
 +		max = ptr_reg->map_ptr->value_size;
 +		if (mask_to_left) {
 +			*ptr_limit = ptr_reg->umax_value + ptr_reg->off;
 +		} else {
 +			off = ptr_reg->smin_value + ptr_reg->off;
 +			*ptr_limit = ptr_reg->map_ptr->value_size - off - 1;
 +		}
 +		return *ptr_limit >= max ? -ERANGE : 0;
++=======
+ 		ptr_limit = -(ptr_reg->var_off.value + ptr_reg->off);
+ 		break;
+ 	case PTR_TO_MAP_VALUE:
+ 		max = ptr_reg->map_ptr->value_size;
+ 		ptr_limit = (mask_to_left ?
+ 			     ptr_reg->smin_value :
+ 			     ptr_reg->umax_value) + ptr_reg->off;
+ 		break;
++>>>>>>> 7fedb63a8307 (bpf: Tighten speculative pointer arithmetic mask)
  	default:
 -		return REASON_TYPE;
 +		return -EINVAL;
  	}
 -
 -	if (ptr_limit >= max)
 -		return REASON_LIMIT;
 -	*alu_limit = ptr_limit;
 -	return 0;
  }
  
  static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,
@@@ -5874,11 -5970,7 +5897,15 @@@ static int sanitize_ptr_alu(struct bpf_
  	if (vstate->speculative)
  		goto do_sim;
  
++<<<<<<< HEAD
 +	alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;
 +	alu_state |= ptr_is_dst_reg ?
 +		     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;
 +
 +	err = retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg);
++=======
+ 	err = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode);
++>>>>>>> 7fedb63a8307 (bpf: Tighten speculative pointer arithmetic mask)
  	if (err < 0)
  		return err;
  
@@@ -5989,8 -6139,9 +6035,12 @@@ static int adjust_ptr_min_max_vals(stru
  	    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;
  	u64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,
  	    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;
++<<<<<<< HEAD
 +	u32 dst = insn->dst_reg, src = insn->src_reg;
++=======
+ 	struct bpf_insn_aux_data tmp_aux = {};
++>>>>>>> 7fedb63a8307 (bpf: Tighten speculative pointer arithmetic mask)
  	u8 opcode = BPF_OP(insn->code);
 -	u32 dst = insn->dst_reg;
  	int ret;
  
  	dst_reg = &regs[dst];
@@@ -6062,13 -6206,15 +6112,25 @@@
  	/* pointer types do not carry 32-bit bounds at the moment. */
  	__mark_reg32_unbounded(dst_reg);
  
++<<<<<<< HEAD
 +	switch (opcode) {
 +	case BPF_ADD:
 +		ret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg);
 +		if (ret < 0) {
 +			verbose(env, "R%d tried to add from different maps, paths, or prohibited types\n", dst);
 +			return ret;
 +		}
++=======
+ 	if (sanitize_needed(opcode)) {
+ 		ret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg,
+ 				       &tmp_aux, false);
+ 		if (ret < 0)
+ 			return sanitize_err(env, insn, ret, off_reg, dst_reg);
+ 	}
+ 
+ 	switch (opcode) {
+ 	case BPF_ADD:
++>>>>>>> 7fedb63a8307 (bpf: Tighten speculative pointer arithmetic mask)
  		/* We can take a fixed offset as long as it doesn't overflow
  		 * the s32 'off' field
  		 */
@@@ -6119,11 -6265,6 +6181,14 @@@
  		}
  		break;
  	case BPF_SUB:
++<<<<<<< HEAD
 +		ret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg);
 +		if (ret < 0) {
 +			verbose(env, "R%d tried to sub from different maps, paths, or prohibited types\n", dst);
 +			return ret;
 +		}
++=======
++>>>>>>> 7fedb63a8307 (bpf: Tighten speculative pointer arithmetic mask)
  		if (dst_reg == off_reg) {
  			/* scalar -= pointer.  Creates an unknown scalar */
  			verbose(env, "R%d tried to subtract pointer from scalar\n",
* Unmerged path kernel/bpf/verifier.c
