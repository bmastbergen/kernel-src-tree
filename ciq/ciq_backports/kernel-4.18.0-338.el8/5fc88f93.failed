sk_buff: introduce 'slow_gro' flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 5fc88f93edf2f797f1aa63334cc6c86f9c15d585
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/5fc88f93.failed

The new flag tracks if any state field is set, so that
GRO requires 'unusual'/slow prepare steps.

Set such flag when a ct entry is attached to the skb,
and never clear it.

The new bit uses an existing hole into the sk_buff struct

RFC -> v1:
 - use a single state bit, never clear it
 - avoid moving the _nfct field

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5fc88f93edf2f797f1aa63334cc6c86f9c15d585)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 9634b2289bb0,3ff18300d210..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -685,12 -679,24 +685,13 @@@ typedef unsigned char *sk_buff_data_t
   *	@wifi_acked_valid: wifi_acked was set
   *	@wifi_acked: whether frame was acked on wifi or not
   *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS
 - *	@encapsulation: indicates the inner headers in the skbuff are valid
 - *	@encap_hdr_csum: software checksum is needed
 - *	@csum_valid: checksum is already valid
   *	@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL
 - *	@csum_complete_sw: checksum was completed by software
 - *	@csum_level: indicates the number of consecutive checksums found in
 - *		the packet minus one that have been verified as
 - *		CHECKSUM_UNNECESSARY (max 3)
   *	@dst_pending_confirm: need to confirm neighbour
   *	@decrypted: Decrypted SKB
+  *	@slow_gro: state present at GRO time, slower prepare step required
   *	@napi_id: id of the NAPI struct this skb came from
 - *	@sender_cpu: (aka @napi_id) source CPU in XPS
   *	@secmark: security marking
   *	@mark: Generic packet mark
 - *	@reserved_tailroom: (aka @mark) number of bytes of free space available
 - *		at the tail of an sk_buff
 - *	@vlan_present: VLAN tag is present
   *	@vlan_proto: vlan encapsulation protocol
   *	@vlan_tci: vlan tag control information
   *	@inner_protocol: Protocol (encapsulation)
@@@ -846,12 -864,14 +847,13 @@@ struct sk_buff 
  	__u8			tc_skip_classify:1;
  	__u8			tc_at_ingress:1;
  #endif
 -	__u8			redirected:1;
  #ifdef CONFIG_NET_REDIRECT
 -	__u8			from_ingress:1;
 -#endif
 -#ifdef CONFIG_TLS_DEVICE
 -	__u8			decrypted:1;
 +	__u8			RH_KABI_RENAME(tc_redirected:1,
 +					       redirected:1);
 +	__u8			RH_KABI_RENAME(tc_from_ingress:1,
 +					       from_ingress:1);
  #endif
+ 	__u8			slow_gro:1;
  
  #ifdef CONFIG_NET_SCHED
  	__u16			tc_index;	/* traffic control index */
@@@ -4145,40 -4206,20 +4147,46 @@@ static inline struct nf_conntrack *skb_
  #endif
  }
  
 -static inline unsigned long skb_get_nfct(const struct sk_buff *skb)
 +#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 +void nf_conntrack_destroy(struct nf_conntrack *nfct);
 +static inline void nf_conntrack_put(struct nf_conntrack *nfct)
  {
 -#if IS_ENABLED(CONFIG_NF_CONNTRACK)
 -	return skb->_nfct;
 -#else
 -	return 0UL;
 -#endif
 +	if (nfct && atomic_dec_and_test(&nfct->use))
 +		nf_conntrack_destroy(nfct);
 +}
 +static inline void nf_conntrack_get(struct nf_conntrack *nfct)
 +{
++<<<<<<< HEAD
 +	if (nfct)
 +		atomic_inc(&nfct->use);
  }
 +#endif
 +
 +/* RHEL: Helper function that needs to be called when skb_ext_put() and
 + * skb_ext_reset() are called. This helper takes care of skb->sp
 + * (and maybe about skb->nf_bridge in future) that cannot be converted
 + * to SKB extension due to KABI reasons.
 + */
 +struct sec_path;
 +void __secpath_destroy(struct sec_path *sp);
  
 -static inline void skb_set_nfct(struct sk_buff *skb, unsigned long nfct)
 +static __always_inline void __rh_skb_ext_put(struct sk_buff *skb, bool reset)
  {
 +#ifdef CONFIG_XFRM
 +	/* RHEL: We need to expand an implementation of secpath_reset() here
 +	 * because we cannot include <net/xfrm.h> in this header. Due to this
 +	 * fact we also cannot dereference .refcnt field from struct sec_path
 +	 * so assume that this field is at the beginning of that struct.
 +	 */
 +	if (skb->sp && refcount_dec_and_test((refcount_t *)skb->sp))
 +		__secpath_destroy(skb->sp);
 +	if (reset)
 +		skb->sp = NULL;
++=======
+ #if IS_ENABLED(CONFIG_NF_CONNTRACK)
+ 	skb->slow_gro |= !!nfct;
+ 	skb->_nfct = nfct;
++>>>>>>> 5fc88f93edf2 (sk_buff: introduce 'slow_gro' flags)
  #endif
  }
  
@@@ -4368,9 -4378,7 +4376,13 @@@ static inline void nf_copy(struct sk_bu
  #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
  	nf_conntrack_put(skb_nfct(dst));
  #endif
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 +	nf_bridge_put(dst->nf_bridge);
 +#endif
++=======
+ 	dst->slow_gro = src->slow_gro;
++>>>>>>> 5fc88f93edf2 (sk_buff: introduce 'slow_gro' flags)
  	__nf_copy(dst, src, true);
  }
  
* Unmerged path include/linux/skbuff.h
