ch_ktls: missing handling of header alone

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit 83deb094dd5c636a790da3914008570c9fd1693f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/83deb094.failed

If an skb has only header part which doesn't start from
beginning, is not being handled properly.

Fixes: dc05f3df8fac ("chcr: Handle first or middle part of record")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 83deb094dd5c636a790da3914008570c9fd1693f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_ktls.c
diff --cc drivers/crypto/chelsio/chcr_ktls.c
index 074af13f5bc4,8a54fce9bfae..000000000000
--- a/drivers/crypto/chelsio/chcr_ktls.c
+++ b/drivers/crypto/chelsio/chcr_ktls.c
@@@ -1712,27 -1729,32 +1712,42 @@@ static int chcr_short_record_handler(st
  
  	if (remaining_record > 0 &&
  	    remaining_record < TLS_CIPHER_AES_GCM_128_TAG_SIZE) {
 -		int trimmed_len = 0;
 -
 -		if (tls_end_offset > TLS_CIPHER_AES_GCM_128_TAG_SIZE)
 -			trimmed_len = data_len -
 -				      (TLS_CIPHER_AES_GCM_128_TAG_SIZE -
 -				       remaining_record);
 -		if (!trimmed_len)
 +		int trimmed_len = skb->data_len -
 +			(TLS_CIPHER_AES_GCM_128_TAG_SIZE - remaining_record);
 +		struct sk_buff *tmp_skb = NULL;
 +		/* don't process the pkt if it is only a partial tag */
 +		if (skb->data_len < TLS_CIPHER_AES_GCM_128_TAG_SIZE)
  			goto out;
  
 -		WARN_ON(trimmed_len > data_len);
 +		WARN_ON(trimmed_len > skb->data_len);
 +
 +		/* shift to those many bytes */
 +		tmp_skb = alloc_skb(0, GFP_KERNEL);
 +		if (unlikely(!tmp_skb))
 +			goto out;
  
 -		data_len = trimmed_len;
 -		atomic64_inc(&tx_info->adap->ch_ktls_stats.ktls_tx_trimmed_pkts);
 +		chcr_ktls_skb_shift(tmp_skb, skb, trimmed_len);
 +		/* free the last trimmed portion */
 +		dev_kfree_skb_any(skb);
 +		skb = tmp_skb;
 +		atomic64_inc(&tx_info->adap->chcr_stats.ktls_tx_trimmed_pkts);
  	}
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +	data_len = skb->data_len;
++=======
+ 
+ 	/* check if it is only the header part. */
+ 	if (tls_rec_offset + data_len <= (TLS_HEADER_SIZE + tx_info->iv_size)) {
+ 		if (chcr_ktls_tx_plaintxt(tx_info, skb, tcp_seq, mss,
+ 					  tcp_push_no_fin, q,
+ 					  tx_info->port_id, prior_data,
+ 					  data_len, skb_offset, prior_data_len))
+ 			goto out;
+ 
+ 		return 0;
+ 	}
+ 
++>>>>>>> 83deb094dd5c (ch_ktls: missing handling of header alone):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  	/* check if the middle record's start point is 16 byte aligned. CTR
  	 * needs 16 byte aligned start point to start encryption.
  	 */
@@@ -1802,22 -1821,9 +1817,26 @@@
  		 */
  		if (chcr_ktls_update_snd_una(tx_info, q))
  			goto out;
 -		atomic64_inc(&tx_info->adap->ch_ktls_stats.ktls_tx_middle_pkts);
 +		atomic64_inc(&tx_info->adap->chcr_stats.ktls_tx_middle_pkts);
  	} else {
++<<<<<<< HEAD:drivers/crypto/chelsio/chcr_ktls.c
 +		/* Else means, its a partial first part of the record. Check if
 +		 * its only the header, don't need to send for encryption then.
 +		 */
 +		if (data_len <= TLS_HEADER_SIZE + tx_info->iv_size) {
 +			if (chcr_ktls_tx_plaintxt(tx_info, skb, tcp_seq, mss,
 +						  tcp_push_no_fin, q,
 +						  tx_info->port_id,
 +						  prior_data,
 +						  prior_data_len)) {
 +				goto out;
 +			}
 +			return 0;
 +		}
 +		atomic64_inc(&tx_info->adap->chcr_stats.ktls_tx_start_pkts);
++=======
+ 		atomic64_inc(&tx_info->adap->ch_ktls_stats.ktls_tx_start_pkts);
++>>>>>>> 83deb094dd5c (ch_ktls: missing handling of header alone):drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_ktls.c
  	}
  
  	if (chcr_ktls_xmit_wr_short(skb, tx_info, q, tcp_seq, tcp_push_no_fin,
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
