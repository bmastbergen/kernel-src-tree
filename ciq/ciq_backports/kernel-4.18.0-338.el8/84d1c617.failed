net: sock: add sock_set_mark

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Alexander Aring <aahringo@redhat.com>
commit 84d1c617402e7e67fc95ab2384da8dae7d1b0efe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/84d1c617.failed

This patch adds a new socket helper function to set the mark value for a
kernel socket.

	Signed-off-by: Alexander Aring <aahringo@redhat.com>
	Signed-off-by: David Teigland <teigland@redhat.com>
(cherry picked from commit 84d1c617402e7e67fc95ab2384da8dae7d1b0efe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
#	net/core/sock.c
diff --cc include/net/sock.h
index b3e2a308efa6,591dd3f12dbb..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -2669,6 -2695,12 +2669,11 @@@ int sock_set_timestamping(struct sock *
  void sock_no_linger(struct sock *sk);
  void sock_set_keepalive(struct sock *sk);
  void sock_set_priority(struct sock *sk, u32 priority);
++<<<<<<< HEAD
++=======
+ void sock_set_rcvbuf(struct sock *sk, int val);
+ void sock_set_mark(struct sock *sk, u32 val);
++>>>>>>> 84d1c617402e (net: sock: add sock_set_mark)
  void sock_set_reuseaddr(struct sock *sk);
 -void sock_set_reuseport(struct sock *sk);
 -void sock_set_sndtimeo(struct sock *sk, s64 secs);
 -
 -int sock_bind_add(struct sock *sk, struct sockaddr *addr, int addr_len);
  
  #endif	/* _SOCK_H */
diff --cc net/core/sock.c
index 2f82a47789df,ea6e8348b3dc..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -816,6 -799,43 +816,46 @@@ void sock_set_keepalive(struct sock *sk
  }
  EXPORT_SYMBOL(sock_set_keepalive);
  
++<<<<<<< HEAD
++=======
+ static void __sock_set_rcvbuf(struct sock *sk, int val)
+ {
+ 	/* Ensure val * 2 fits into an int, to prevent max_t() from treating it
+ 	 * as a negative value.
+ 	 */
+ 	val = min_t(int, val, INT_MAX / 2);
+ 	sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
+ 
+ 	/* We double it on the way in to account for "struct sk_buff" etc.
+ 	 * overhead.   Applications assume that the SO_RCVBUF setting they make
+ 	 * will allow that much actual data to be received on that socket.
+ 	 *
+ 	 * Applications are unaware that "struct sk_buff" and other overheads
+ 	 * allocate from the receive buffer during socket buffer allocation.
+ 	 *
+ 	 * And after considering the possible alternatives, returning the value
+ 	 * we actually used in getsockopt is the most desirable behavior.
+ 	 */
+ 	WRITE_ONCE(sk->sk_rcvbuf, max_t(int, val * 2, SOCK_MIN_RCVBUF));
+ }
+ 
+ void sock_set_rcvbuf(struct sock *sk, int val)
+ {
+ 	lock_sock(sk);
+ 	__sock_set_rcvbuf(sk, val);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_rcvbuf);
+ 
+ void sock_set_mark(struct sock *sk, u32 val)
+ {
+ 	lock_sock(sk);
+ 	sk->sk_mark = val;
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_mark);
+ 
++>>>>>>> 84d1c617402e (net: sock: add sock_set_mark)
  /*
   *	This is meant for all protocols to use and covers goings on
   *	at the socket level. Everything here is generic.
* Unmerged path include/net/sock.h
* Unmerged path net/core/sock.c
