ice: Stop processing VF messages during teardown

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
commit c503e63200c679e362afca7aca9d3dc63a0f45ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/c503e632.failed

When VFs are setup and torn down in quick succession, it is possible
that a VF is torn down by the PF while the VF's virtchnl requests are
still in the PF's mailbox ring. Processing the VF's virtchnl request
when the VF itself doesn't exist results in undefined behavior. Fix
this by adding a check to stop processing virtchnl requests when VF
teardown is in progress.

Fixes: ddf30f7ff840 ("ice: Add handler to configure SR-IOV")
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Tested-by: Konrad Jankowski <konrad0.jankowski@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit c503e63200c679e362afca7aca9d3dc63a0f45ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice.h
index 111fc73e9f46,eadcb9958346..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -190,53 -204,60 +190,76 @@@ struct ice_sw 
  	u8 dflt_vsi_ena:1;	/* true if above dflt_vsi is enabled */
  };
  
 -enum ice_pf_state {
 -	ICE_TESTING,
 -	ICE_DOWN,
 -	ICE_NEEDS_RESTART,
 -	ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
 -	ICE_RESET_OICR_RECV,		/* set by driver after rcv reset OICR */
 -	ICE_PFR_REQ,		/* set by driver */
 -	ICE_CORER_REQ,		/* set by driver */
 -	ICE_GLOBR_REQ,		/* set by driver */
 -	ICE_CORER_RECV,		/* set by OICR handler */
 -	ICE_GLOBR_RECV,		/* set by OICR handler */
 -	ICE_EMPR_RECV,		/* set by OICR handler */
 -	ICE_SUSPENDED,		/* set on module remove path */
 -	ICE_RESET_FAILED,		/* set by reset/rebuild */
 +enum ice_state {
 +	__ICE_TESTING,
 +	__ICE_DOWN,
 +	__ICE_NEEDS_RESTART,
 +	__ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
 +	__ICE_RESET_OICR_RECV,		/* set by driver after rcv reset OICR */
 +	__ICE_PFR_REQ,			/* set by driver and peers */
 +	__ICE_CORER_REQ,		/* set by driver and peers */
 +	__ICE_GLOBR_REQ,		/* set by driver and peers */
 +	__ICE_CORER_RECV,		/* set by OICR handler */
 +	__ICE_GLOBR_RECV,		/* set by OICR handler */
 +	__ICE_EMPR_RECV,		/* set by OICR handler */
 +	__ICE_SUSPENDED,		/* set on module remove path */
 +	__ICE_RESET_FAILED,		/* set by reset/rebuild */
  	/* When checking for the PF to be in a nominal operating state, the
  	 * bits that are grouped at the beginning of the list need to be
 -	 * checked. Bits occurring before ICE_STATE_NOMINAL_CHECK_BITS will
 +	 * checked. Bits occurring before __ICE_STATE_NOMINAL_CHECK_BITS will
  	 * be checked. If you need to add a bit into consideration for nominal
  	 * operating state, it must be added before
 -	 * ICE_STATE_NOMINAL_CHECK_BITS. Do not move this entry's position
 +	 * __ICE_STATE_NOMINAL_CHECK_BITS. Do not move this entry's position
  	 * without appropriate consideration.
  	 */
++<<<<<<< HEAD
 +	__ICE_STATE_NOMINAL_CHECK_BITS,
 +	__ICE_ADMINQ_EVENT_PENDING,
 +	__ICE_MAILBOXQ_EVENT_PENDING,
 +	__ICE_MDD_EVENT_PENDING,
 +	__ICE_VFLR_EVENT_PENDING,
 +	__ICE_FLTR_OVERFLOW_PROMISC,
 +	__ICE_VF_DIS,
 +	__ICE_CFG_BUSY,
 +	__ICE_SERVICE_SCHED,
 +	__ICE_SERVICE_DIS,
 +	__ICE_FD_FLUSH_REQ,
 +	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
 +	__ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
 +	__ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
 +	__ICE_LINK_DEFAULT_OVERRIDE_PENDING,
 +	__ICE_PHY_INIT_COMPLETE,
 +	__ICE_STATE_NBITS		/* must be last */
++=======
+ 	ICE_STATE_NOMINAL_CHECK_BITS,
+ 	ICE_ADMINQ_EVENT_PENDING,
+ 	ICE_MAILBOXQ_EVENT_PENDING,
+ 	ICE_SIDEBANDQ_EVENT_PENDING,
+ 	ICE_MDD_EVENT_PENDING,
+ 	ICE_VFLR_EVENT_PENDING,
+ 	ICE_FLTR_OVERFLOW_PROMISC,
+ 	ICE_VF_DIS,
+ 	ICE_VF_DEINIT_IN_PROGRESS,
+ 	ICE_CFG_BUSY,
+ 	ICE_SERVICE_SCHED,
+ 	ICE_SERVICE_DIS,
+ 	ICE_FD_FLUSH_REQ,
+ 	ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
+ 	ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
+ 	ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
+ 	ICE_LINK_DEFAULT_OVERRIDE_PENDING,
+ 	ICE_PHY_INIT_COMPLETE,
+ 	ICE_FD_VF_FLUSH_CTX,		/* set at FD Rx IRQ or timeout */
+ 	ICE_STATE_NBITS		/* must be last */
++>>>>>>> c503e63200c6 (ice: Stop processing VF messages during teardown)
  };
  
 -enum ice_vsi_state {
 -	ICE_VSI_DOWN,
 -	ICE_VSI_NEEDS_RESTART,
 -	ICE_VSI_NETDEV_ALLOCD,
 -	ICE_VSI_NETDEV_REGISTERED,
 -	ICE_VSI_UMAC_FLTR_CHANGED,
 -	ICE_VSI_MMAC_FLTR_CHANGED,
 -	ICE_VSI_VLAN_FLTR_CHANGED,
 -	ICE_VSI_PROMISC_CHANGED,
 -	ICE_VSI_STATE_NBITS		/* must be last */
 +enum ice_vsi_flags {
 +	ICE_VSI_FLAG_UMAC_FLTR_CHANGED,
 +	ICE_VSI_FLAG_MMAC_FLTR_CHANGED,
 +	ICE_VSI_FLAG_VLAN_FLTR_CHANGED,
 +	ICE_VSI_FLAG_PROMISC_CHANGED,
 +	ICE_VSI_FLAG_NBITS		/* must be last */
  };
  
  /* struct that defines a VSI, associated with a dev */
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 48dee9c5d534,e93430ab37f1..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -401,7 -673,16 +403,20 @@@ void ice_free_vfs(struct ice_pf *pf
  			wr32(hw, GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));
  		}
  	}
++<<<<<<< HEAD
 +	clear_bit(__ICE_VF_DIS, pf->state);
++=======
+ 
+ 	/* clear malicious info if the VFs are getting released */
+ 	for (i = 0; i < tmp; i++)
+ 		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->malvfs,
+ 					ICE_MAX_VF_COUNT, i))
+ 			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n",
+ 				i);
+ 
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 	clear_bit(ICE_VF_DEINIT_IN_PROGRESS, pf->state);
++>>>>>>> c503e63200c6 (ice: Stop processing VF messages during teardown)
  	clear_bit(ICE_FLAG_SRIOV_ENA, pf->flags);
  }
  
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
