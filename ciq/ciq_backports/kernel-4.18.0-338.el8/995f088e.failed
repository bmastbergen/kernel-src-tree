perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Stephane Eranian <eranian@google.com>
commit 995f088efebe1eba0282a6ffa12411b37f8990c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/995f088e.failed

When studying code layout, it is useful to capture the page size of the
sampled code address.

Add a new sample type for code page size.
The new sample type requires collecting the ip. The code page size can
be calculated from the NMI-safe perf_get_page_size().

For large PEBS, it's very unlikely that the mapping is gone for the
earlier PEBS records. Enable the feature for the large PEBS. The worst
case is that page-size '0' is returned.

	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Stephane Eranian <eranian@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20201001135749.2804-5-kan.liang@linux.intel.com
(cherry picked from commit 995f088efebe1eba0282a6ffa12411b37f8990c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/perf_event.h
#	include/uapi/linux/perf_event.h
#	kernel/events/core.c
diff --cc include/linux/perf_event.h
index 477e3a44ef5b,e533b03af053..000000000000
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@@ -1053,7 -1033,9 +1053,13 @@@ struct perf_sample_data 
  	u64				stack_user_size;
  
  	u64				phys_addr;
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_INSERT(u64				cgroup)
++=======
+ 	u64				cgroup;
+ 	u64				data_page_size;
+ 	u64				code_page_size;
++>>>>>>> 995f088efebe (perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE)
  } ____cacheline_aligned;
  
  /* default value for data source */
diff --cc include/uapi/linux/perf_event.h
index 9a7caf442fb5,c2f20ee3124d..000000000000
--- a/include/uapi/linux/perf_event.h
+++ b/include/uapi/linux/perf_event.h
@@@ -143,13 -143,10 +143,20 @@@ enum perf_event_sample_format 
  	PERF_SAMPLE_PHYS_ADDR			= 1U << 19,
  	PERF_SAMPLE_AUX				= 1U << 20,
  	PERF_SAMPLE_CGROUP			= 1U << 21,
++<<<<<<< HEAD
 +#ifndef __GENKSYMS__
 +	PERF_SAMPLE_WEIGHT_STRUCT		= 1U << 22,
 +
 +	PERF_SAMPLE_MAX = 1U << 23,		/* non-ABI */
 +#else
 +	PERF_SAMPLE_MAX = 1U << 22,		/* non-ABI */
 +#endif /* __GENKSYMS__ */
++=======
+ 	PERF_SAMPLE_DATA_PAGE_SIZE		= 1U << 22,
+ 	PERF_SAMPLE_CODE_PAGE_SIZE		= 1U << 23,
+ 
+ 	PERF_SAMPLE_MAX = 1U << 24,		/* non-ABI */
++>>>>>>> 995f088efebe (perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE)
  
  	__PERF_SAMPLE_CALLCHAIN_EARLY		= 1ULL << 63, /* non-ABI; internal use */
  };
@@@ -947,6 -898,8 +954,11 @@@ enum perf_event_type 
  	 *	{ u64			phys_addr;} && PERF_SAMPLE_PHYS_ADDR
  	 *	{ u64			size;
  	 *	  char			data[size]; } && PERF_SAMPLE_AUX
++<<<<<<< HEAD
++=======
+ 	 *	{ u64			data_page_size;} && PERF_SAMPLE_DATA_PAGE_SIZE
+ 	 *	{ u64			code_page_size;} && PERF_SAMPLE_CODE_PAGE_SIZE
++>>>>>>> 995f088efebe (perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE)
  	 * };
  	 */
  	PERF_RECORD_SAMPLE			= 9,
diff --cc kernel/events/core.c
index 04b715857832,7f655d19b8c4..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -1901,6 -1895,12 +1901,15 @@@ static void __perf_event_header_size(st
  	if (sample_type & PERF_SAMPLE_CGROUP)
  		size += sizeof(data->cgroup);
  
++<<<<<<< HEAD
++=======
+ 	if (sample_type & PERF_SAMPLE_DATA_PAGE_SIZE)
+ 		size += sizeof(data->data_page_size);
+ 
+ 	if (sample_type & PERF_SAMPLE_CODE_PAGE_SIZE)
+ 		size += sizeof(data->code_page_size);
+ 
++>>>>>>> 995f088efebe (perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE)
  	event->header_size = size;
  }
  
@@@ -6978,6 -6945,12 +6987,15 @@@ void perf_output_sample(struct perf_out
  	if (sample_type & PERF_SAMPLE_CGROUP)
  		perf_output_put(handle, data->cgroup);
  
++<<<<<<< HEAD
++=======
+ 	if (sample_type & PERF_SAMPLE_DATA_PAGE_SIZE)
+ 		perf_output_put(handle, data->data_page_size);
+ 
+ 	if (sample_type & PERF_SAMPLE_CODE_PAGE_SIZE)
+ 		perf_output_put(handle, data->code_page_size);
+ 
++>>>>>>> 995f088efebe (perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE)
  	if (sample_type & PERF_SAMPLE_AUX) {
  		perf_output_put(handle, data->aux_size);
  
@@@ -7189,6 -7251,17 +7207,20 @@@ void perf_prepare_sample(struct perf_ev
  	}
  #endif
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * PERF_DATA_PAGE_SIZE requires PERF_SAMPLE_ADDR. If the user doesn't
+ 	 * require PERF_SAMPLE_ADDR, kernel implicitly retrieve the data->addr,
+ 	 * but the value will not dump to the userspace.
+ 	 */
+ 	if (sample_type & PERF_SAMPLE_DATA_PAGE_SIZE)
+ 		data->data_page_size = perf_get_page_size(data->addr);
+ 
+ 	if (sample_type & PERF_SAMPLE_CODE_PAGE_SIZE)
+ 		data->code_page_size = perf_get_page_size(data->ip);
+ 
++>>>>>>> 995f088efebe (perf/core: Add support for PERF_SAMPLE_CODE_PAGE_SIZE)
  	if (sample_type & PERF_SAMPLE_AUX) {
  		u64 size;
  
diff --git a/arch/x86/events/perf_event.h b/arch/x86/events/perf_event.h
index 2b7a197fef41..913285d796bc 100644
--- a/arch/x86/events/perf_event.h
+++ b/arch/x86/events/perf_event.h
@@ -133,7 +133,7 @@ struct amd_nb {
 	PERF_SAMPLE_DATA_SRC | PERF_SAMPLE_IDENTIFIER | \
 	PERF_SAMPLE_TRANSACTION | PERF_SAMPLE_PHYS_ADDR | \
 	PERF_SAMPLE_REGS_INTR | PERF_SAMPLE_REGS_USER | \
-	PERF_SAMPLE_PERIOD)
+	PERF_SAMPLE_PERIOD | PERF_SAMPLE_CODE_PAGE_SIZE)
 
 #define PEBS_GP_REGS			\
 	((1ULL << PERF_REG_X86_AX)    | \
* Unmerged path include/linux/perf_event.h
* Unmerged path include/uapi/linux/perf_event.h
* Unmerged path kernel/events/core.c
