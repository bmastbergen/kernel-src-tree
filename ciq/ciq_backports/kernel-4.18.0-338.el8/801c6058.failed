bpf: Fix leakage of uninitialized bpf stack under speculation

jira LE-1907
cve CVE-2021-31829
cve CVE-2021-29155
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 801c6058d14a82179a7ee17a4b532cac6fad067f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/801c6058.failed

The current implemented mechanisms to mitigate data disclosure under
speculation mainly address stack and map value oob access from the
speculative domain. However, Piotr discovered that uninitialized BPF
stack is not protected yet, and thus old data from the kernel stack,
potentially including addresses of kernel structures, could still be
extracted from that 512 bytes large window. The BPF stack is special
compared to map values since it's not zero initialized for every
program invocation, whereas map values /are/ zero initialized upon
their initial allocation and thus cannot leak any prior data in either
domain. In the non-speculative domain, the verifier ensures that every
stack slot read must have a prior stack slot write by the BPF program
to avoid such data leaking issue.

However, this is not enough: for example, when the pointer arithmetic
operation moves the stack pointer from the last valid stack offset to
the first valid offset, the sanitation logic allows for any intermediate
offsets during speculative execution, which could then be used to
extract any restricted stack content via side-channel.

Given for unprivileged stack pointer arithmetic the use of unknown
but bounded scalars is generally forbidden, we can simply turn the
register-based arithmetic operation into an immediate-based arithmetic
operation without the need for masking. This also gives the benefit
of reducing the needed instructions for the operation. Given after
the work in 7fedb63a8307 ("bpf: Tighten speculative pointer arithmetic
mask"), the aux->alu_limit already holds the final immediate value for
the offset register with the known scalar. Thus, a simple mov of the
immediate to AX register with using AX as the source for the original
instruction is sufficient and possible now in this case.

	Reported-by: Piotr Krysiuk <piotras@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Tested-by: Piotr Krysiuk <piotras@gmail.com>
	Reviewed-by: Piotr Krysiuk <piotras@gmail.com>
	Reviewed-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 801c6058d14a82179a7ee17a4b532cac6fad067f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index e65c8ec142c6,757476c91c98..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5852,10 -6490,13 +5852,14 @@@ static int sanitize_ptr_alu(struct bpf_
  			    struct bpf_insn *insn,
  			    const struct bpf_reg_state *ptr_reg,
  			    const struct bpf_reg_state *off_reg,
 -			    struct bpf_reg_state *dst_reg,
 -			    struct bpf_insn_aux_data *tmp_aux,
 -			    const bool commit_window)
 +			    struct bpf_reg_state *dst_reg)
  {
 -	struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux;
  	struct bpf_verifier_state *vstate = env->cur_state;
++<<<<<<< HEAD
 +	struct bpf_insn_aux_data *aux = cur_aux(env);
++=======
+ 	bool off_is_imm = tnum_is_const(off_reg->var_off);
++>>>>>>> 801c6058d14a (bpf: Fix leakage of uninitialized bpf stack under speculation)
  	bool off_is_neg = off_reg->smin_value < 0;
  	bool ptr_is_dst_reg = ptr_reg == dst_reg;
  	u8 opcode = BPF_OP(insn->code);
@@@ -5882,6 -6519,19 +5886,22 @@@
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
++=======
+ 	if (commit_window) {
+ 		/* In commit phase we narrow the masking window based on
+ 		 * the observed pointer move after the simulated operation.
+ 		 */
+ 		alu_state = tmp_aux->alu_state;
+ 		alu_limit = abs(tmp_aux->alu_limit - alu_limit);
+ 	} else {
+ 		alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;
+ 		alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;
+ 		alu_state |= ptr_is_dst_reg ?
+ 			     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;
+ 	}
+ 
++>>>>>>> 801c6058d14a (bpf: Fix leakage of uninitialized bpf stack under speculation)
  	err = update_alu_sanitation_state(aux, alu_state, alu_limit);
  	if (err < 0)
  		return err;
@@@ -11597,9 -12372,8 +11617,9 @@@ static int fixup_bpf_calls(struct bpf_v
  		    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {
  			const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;
  			const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;
 +			struct bpf_insn insn_buf[16];
  			struct bpf_insn *patch = &insn_buf[0];
- 			bool issrc, isneg;
+ 			bool issrc, isneg, isimm;
  			u32 off_reg;
  
  			aux = &env->insn_aux_data[i + delta];
diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h
index 4f9a6cb270fe..a9fa0298fceb 100644
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -306,10 +306,11 @@ struct bpf_verifier_state_list {
 };
 
 /* Possible states for alu_state member. */
-#define BPF_ALU_SANITIZE_SRC		1U
-#define BPF_ALU_SANITIZE_DST		2U
+#define BPF_ALU_SANITIZE_SRC		(1U << 0)
+#define BPF_ALU_SANITIZE_DST		(1U << 1)
 #define BPF_ALU_NEG_VALUE		(1U << 2)
 #define BPF_ALU_NON_POINTER		(1U << 3)
+#define BPF_ALU_IMMEDIATE		(1U << 4)
 #define BPF_ALU_SANITIZE		(BPF_ALU_SANITIZE_SRC | \
 					 BPF_ALU_SANITIZE_DST)
 
* Unmerged path kernel/bpf/verifier.c
