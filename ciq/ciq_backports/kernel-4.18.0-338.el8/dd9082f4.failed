net: sock: fix in-kernel mark setting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Alexander Aring <aahringo@redhat.com>
commit dd9082f4a9f94280fbbece641bf8fc0a25f71f7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/dd9082f4.failed

This patch fixes the in-kernel mark setting by doing an additional
sk_dst_reset() which was introduced by commit 50254256f382 ("sock: Reset
dst when changing sk_mark via setsockopt"). The code is now shared to
avoid any further suprises when changing the socket mark value.

Fixes: 84d1c617402e ("net: sock: add sock_set_mark")
	Reported-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: Alexander Aring <aahringo@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dd9082f4a9f94280fbbece641bf8fc0a25f71f7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/sock.c
diff --cc net/core/sock.c
index 9e586b10cb28,946888afef88..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -816,6 -786,51 +816,54 @@@ void sock_set_keepalive(struct sock *sk
  }
  EXPORT_SYMBOL(sock_set_keepalive);
  
++<<<<<<< HEAD
++=======
+ static void __sock_set_rcvbuf(struct sock *sk, int val)
+ {
+ 	/* Ensure val * 2 fits into an int, to prevent max_t() from treating it
+ 	 * as a negative value.
+ 	 */
+ 	val = min_t(int, val, INT_MAX / 2);
+ 	sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
+ 
+ 	/* We double it on the way in to account for "struct sk_buff" etc.
+ 	 * overhead.   Applications assume that the SO_RCVBUF setting they make
+ 	 * will allow that much actual data to be received on that socket.
+ 	 *
+ 	 * Applications are unaware that "struct sk_buff" and other overheads
+ 	 * allocate from the receive buffer during socket buffer allocation.
+ 	 *
+ 	 * And after considering the possible alternatives, returning the value
+ 	 * we actually used in getsockopt is the most desirable behavior.
+ 	 */
+ 	WRITE_ONCE(sk->sk_rcvbuf, max_t(int, val * 2, SOCK_MIN_RCVBUF));
+ }
+ 
+ void sock_set_rcvbuf(struct sock *sk, int val)
+ {
+ 	lock_sock(sk);
+ 	__sock_set_rcvbuf(sk, val);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_rcvbuf);
+ 
+ static void __sock_set_mark(struct sock *sk, u32 val)
+ {
+ 	if (val != sk->sk_mark) {
+ 		sk->sk_mark = val;
+ 		sk_dst_reset(sk);
+ 	}
+ }
+ 
+ void sock_set_mark(struct sock *sk, u32 val)
+ {
+ 	lock_sock(sk);
+ 	__sock_set_mark(sk, val);
+ 	release_sock(sk);
+ }
+ EXPORT_SYMBOL(sock_set_mark);
+ 
++>>>>>>> dd9082f4a9f9 (net: sock: fix in-kernel mark setting)
  /*
   *	This is meant for all protocols to use and covers goings on
   *	at the socket level. Everything here is generic.
* Unmerged path net/core/sock.c
