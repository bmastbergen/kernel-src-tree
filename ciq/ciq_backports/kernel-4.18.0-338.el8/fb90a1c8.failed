Crypto/chcr: Calculate src and dst sg lengths separately for dma map

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Ayush Sawal <ayush.sawal@chelsio.com>
commit fb90a1c85d8f08c85d9fd5729bfdeb786119f219
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/fb90a1c8.failed

This patch calculates src and dst sg lengths separately for
dma mapping in case of aead operation.

This fixes a panic which occurs due to the accessing of a zero
length sg.
Panic:
[  138.173225] kernel BUG at drivers/iommu/intel-iommu.c:1184!

	Signed-off-by: Ayush Sawal <ayush.sawal@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb90a1c85d8f08c85d9fd5729bfdeb786119f219)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_algo.c
diff --cc drivers/crypto/chelsio/chcr_algo.c
index d62afc4ebccc,f8b55137cf7d..000000000000
--- a/drivers/crypto/chelsio/chcr_algo.c
+++ b/drivers/crypto/chelsio/chcr_algo.c
@@@ -2581,11 -2590,22 +2581,28 @@@ int chcr_aead_dma_map(struct device *de
  	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req);
  	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
  	unsigned int authsize = crypto_aead_authsize(tfm);
- 	int dst_size;
+ 	int src_len, dst_len;
  
++<<<<<<< HEAD
 +	dst_size = req->assoclen + req->cryptlen + (op_type ?
 +				-authsize : authsize);
 +	if (!req->cryptlen || !dst_size)
++=======
+ 	/* calculate and handle src and dst sg length separately
+ 	 * for inplace and out-of place operations
+ 	 */
+ 	if (req->src == req->dst) {
+ 		src_len = req->assoclen + req->cryptlen + (op_type ?
+ 							0 : authsize);
+ 		dst_len = src_len;
+ 	} else {
+ 		src_len = req->assoclen + req->cryptlen;
+ 		dst_len = req->assoclen + req->cryptlen + (op_type ?
+ 							-authsize : authsize);
+ 	}
+ 
+ 	if (!req->cryptlen || !src_len || !dst_len)
++>>>>>>> fb90a1c85d8f (Crypto/chcr: Calculate src and dst sg lengths separately for dma map)
  		return 0;
  	reqctx->iv_dma = dma_map_single(dev, reqctx->iv, (IV + reqctx->b0_len),
  					DMA_BIDIRECTIONAL);
@@@ -2628,23 -2651,37 +2648,48 @@@ void chcr_aead_dma_unmap(struct device 
  	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req);
  	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
  	unsigned int authsize = crypto_aead_authsize(tfm);
- 	int dst_size;
+ 	int src_len, dst_len;
  
++<<<<<<< HEAD
 +	dst_size = req->assoclen + req->cryptlen + (op_type ?
 +					-authsize : authsize);
 +	if (!req->cryptlen || !dst_size)
++=======
+ 	/* calculate and handle src and dst sg length separately
+ 	 * for inplace and out-of place operations
+ 	 */
+ 	if (req->src == req->dst) {
+ 		src_len = req->assoclen + req->cryptlen + (op_type ?
+ 							0 : authsize);
+ 		dst_len = src_len;
+ 	} else {
+ 		src_len = req->assoclen + req->cryptlen;
+ 		dst_len = req->assoclen + req->cryptlen + (op_type ?
+ 						-authsize : authsize);
+ 	}
+ 
+ 	if (!req->cryptlen || !src_len || !dst_len)
++>>>>>>> fb90a1c85d8f (Crypto/chcr: Calculate src and dst sg lengths separately for dma map)
  		return;
  
  	dma_unmap_single(dev, reqctx->iv_dma, (IV + reqctx->b0_len),
  					DMA_BIDIRECTIONAL);
  	if (req->src == req->dst) {
++<<<<<<< HEAD
 +		dma_unmap_sg(dev, req->src, sg_nents(req->src),
 +				   DMA_BIDIRECTIONAL);
++=======
+ 		dma_unmap_sg(dev, req->src,
+ 			     sg_nents_for_len(req->src, src_len),
+ 			     DMA_BIDIRECTIONAL);
++>>>>>>> fb90a1c85d8f (Crypto/chcr: Calculate src and dst sg lengths separately for dma map)
  	} else {
- 		dma_unmap_sg(dev, req->src, sg_nents(req->src),
- 				   DMA_TO_DEVICE);
- 		dma_unmap_sg(dev, req->dst, sg_nents(req->dst),
- 				   DMA_FROM_DEVICE);
+ 		dma_unmap_sg(dev, req->src,
+ 			     sg_nents_for_len(req->src, src_len),
+ 			     DMA_TO_DEVICE);
+ 		dma_unmap_sg(dev, req->dst,
+ 			     sg_nents_for_len(req->dst, dst_len),
+ 			     DMA_FROM_DEVICE);
  	}
  }
  
* Unmerged path drivers/crypto/chelsio/chcr_algo.c
