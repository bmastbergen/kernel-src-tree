arm64: enable tlbi range instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-338.el8
commit-author Zhenyu Ye <yezhenyu2@huawei.com>
commit 7c78f67e9bd97478d56157c2ad53823668b5b822
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-338.el8/7c78f67e.failed

TLBI RANGE feature instoduces new assembly instructions and only
support by binutils >= 2.30.  Add necessary Kconfig logic to allow
this to be enabled and pass '-march=armv8.4-a' to KBUILD_CFLAGS.

	Signed-off-by: Zhenyu Ye <yezhenyu2@huawei.com>
Link: https://lore.kernel.org/r/20200715071945.897-3-yezhenyu2@huawei.com
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 7c78f67e9bd97478d56157c2ad53823668b5b822)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/Kconfig
#	arch/arm64/Makefile
diff --cc arch/arm64/Kconfig
index 2f69e66ee530,0f39468dbc60..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -1399,6 -1546,138 +1399,141 @@@ config ARM64_PTR_AUT
  	  be enabled. However, KVM guest also require VHE mode and hence
  	  CONFIG_ARM64_VHE=y option to use this feature.
  
++<<<<<<< HEAD
++=======
+ 	  If the feature is present on the boot CPU but not on a late CPU, then
+ 	  the late CPU will be parked. Also, if the boot CPU does not have
+ 	  address auth and the late CPU has then the late CPU will still boot
+ 	  but with the feature disabled. On such a system, this option should
+ 	  not be selected.
+ 
+ 	  This feature works with FUNCTION_GRAPH_TRACER option only if
+ 	  DYNAMIC_FTRACE_WITH_REGS is enabled.
+ 
+ config CC_HAS_BRANCH_PROT_PAC_RET
+ 	# GCC 9 or later, clang 8 or later
+ 	def_bool $(cc-option,-mbranch-protection=pac-ret+leaf)
+ 
+ config CC_HAS_SIGN_RETURN_ADDRESS
+ 	# GCC 7, 8
+ 	def_bool $(cc-option,-msign-return-address=all)
+ 
+ config AS_HAS_PAC
+ 	def_bool $(cc-option,-Wa$(comma)-march=armv8.3-a)
+ 
+ config AS_HAS_CFI_NEGATE_RA_STATE
+ 	def_bool $(as-instr,.cfi_startproc\n.cfi_negate_ra_state\n.cfi_endproc\n)
+ 
+ endmenu
+ 
+ menu "ARMv8.4 architectural features"
+ 
+ config ARM64_AMU_EXTN
+ 	bool "Enable support for the Activity Monitors Unit CPU extension"
+ 	default y
+ 	help
+ 	  The activity monitors extension is an optional extension introduced
+ 	  by the ARMv8.4 CPU architecture. This enables support for version 1
+ 	  of the activity monitors architecture, AMUv1.
+ 
+ 	  To enable the use of this extension on CPUs that implement it, say Y.
+ 
+ 	  Note that for architectural reasons, firmware _must_ implement AMU
+ 	  support when running on CPUs that present the activity monitors
+ 	  extension. The required support is present in:
+ 	    * Version 1.5 and later of the ARM Trusted Firmware
+ 
+ 	  For kernels that have this configuration enabled but boot with broken
+ 	  firmware, you may need to say N here until the firmware is fixed.
+ 	  Otherwise you may experience firmware panics or lockups when
+ 	  accessing the counter registers. Even if you are not observing these
+ 	  symptoms, the values returned by the register reads might not
+ 	  correctly reflect reality. Most commonly, the value read will be 0,
+ 	  indicating that the counter is not enabled.
+ 
+ config AS_HAS_ARMV8_4
+ 	def_bool $(cc-option,-Wa$(comma)-march=armv8.4-a)
+ 
+ config ARM64_TLB_RANGE
+ 	bool "Enable support for tlbi range feature"
+ 	default y
+ 	depends on AS_HAS_ARMV8_4
+ 	help
+ 	  ARMv8.4-TLBI provides TLBI invalidation instruction that apply to a
+ 	  range of input addresses.
+ 
+ 	  The feature introduces new assembly instructions, and they were
+ 	  support when binutils >= 2.30.
+ 
+ endmenu
+ 
+ menu "ARMv8.5 architectural features"
+ 
+ config ARM64_BTI
+ 	bool "Branch Target Identification support"
+ 	default y
+ 	help
+ 	  Branch Target Identification (part of the ARMv8.5 Extensions)
+ 	  provides a mechanism to limit the set of locations to which computed
+ 	  branch instructions such as BR or BLR can jump.
+ 
+ 	  To make use of BTI on CPUs that support it, say Y.
+ 
+ 	  BTI is intended to provide complementary protection to other control
+ 	  flow integrity protection mechanisms, such as the Pointer
+ 	  authentication mechanism provided as part of the ARMv8.3 Extensions.
+ 	  For this reason, it does not make sense to enable this option without
+ 	  also enabling support for pointer authentication.  Thus, when
+ 	  enabling this option you should also select ARM64_PTR_AUTH=y.
+ 
+ 	  Userspace binaries must also be specifically compiled to make use of
+ 	  this mechanism.  If you say N here or the hardware does not support
+ 	  BTI, such binaries can still run, but you get no additional
+ 	  enforcement of branch destinations.
+ 
+ config ARM64_BTI_KERNEL
+ 	bool "Use Branch Target Identification for kernel"
+ 	default y
+ 	depends on ARM64_BTI
+ 	depends on ARM64_PTR_AUTH
+ 	depends on CC_HAS_BRANCH_PROT_PAC_RET_BTI
+ 	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94697
+ 	depends on !CC_IS_GCC || GCC_VERSION >= 100100
+ 	# https://reviews.llvm.org/rGb8ae3fdfa579dbf366b1bb1cbfdbf8c51db7fa55
+ 	depends on !CC_IS_CLANG || CLANG_VERSION >= 100001
+ 	depends on !(CC_IS_CLANG && GCOV_KERNEL)
+ 	depends on (!FUNCTION_GRAPH_TRACER || DYNAMIC_FTRACE_WITH_REGS)
+ 	help
+ 	  Build the kernel with Branch Target Identification annotations
+ 	  and enable enforcement of this for kernel code. When this option
+ 	  is enabled and the system supports BTI all kernel code including
+ 	  modular code must have BTI enabled.
+ 
+ config CC_HAS_BRANCH_PROT_PAC_RET_BTI
+ 	# GCC 9 or later, clang 8 or later
+ 	def_bool $(cc-option,-mbranch-protection=pac-ret+leaf+bti)
+ 
+ config ARM64_E0PD
+ 	bool "Enable support for E0PD"
+ 	default y
+ 	help
+ 	  E0PD (part of the ARMv8.5 extensions) allows us to ensure
+ 	  that EL0 accesses made via TTBR1 always fault in constant time,
+ 	  providing similar benefits to KASLR as those provided by KPTI, but
+ 	  with lower overhead and without disrupting legitimate access to
+ 	  kernel memory such as SPE.
+ 
+ 	  This option enables E0PD for TTBR1 where available.
+ 
+ config ARCH_RANDOM
+ 	bool "Enable support for random number generation"
+ 	default y
+ 	help
+ 	  Random number generation (part of the ARMv8.5 Extensions)
+ 	  provides a high bandwidth, cryptographically secure
+ 	  hardware random number generator.
+ 
++>>>>>>> 7c78f67e9bd9 (arm64: enable tlbi range instructions)
  endmenu
  
  config ARM64_SVE
diff --cc arch/arm64/Makefile
index c07bc2f53038,4e823b97c92e..000000000000
--- a/arch/arm64/Makefile
+++ b/arch/arm64/Makefile
@@@ -87,6 -64,40 +87,43 @@@ stack_protector_prepare: prepare
  					include/generated/asm-offsets.h))
  endif
  
++<<<<<<< HEAD
++=======
+ # Ensure that if the compiler supports branch protection we default it
+ # off, this will be overridden if we are using branch protection.
+ branch-prot-flags-y += $(call cc-option,-mbranch-protection=none)
+ 
+ ifeq ($(CONFIG_ARM64_PTR_AUTH),y)
+ branch-prot-flags-$(CONFIG_CC_HAS_SIGN_RETURN_ADDRESS) := -msign-return-address=all
+ # We enable additional protection for leaf functions as there is some
+ # narrow potential for ROP protection benefits and no substantial
+ # performance impact has been observed.
+ ifeq ($(CONFIG_ARM64_BTI_KERNEL),y)
+ branch-prot-flags-$(CONFIG_CC_HAS_BRANCH_PROT_PAC_RET_BTI) := -mbranch-protection=pac-ret+leaf+bti
+ else
+ branch-prot-flags-$(CONFIG_CC_HAS_BRANCH_PROT_PAC_RET) := -mbranch-protection=pac-ret+leaf
+ endif
+ # -march=armv8.3-a enables the non-nops instructions for PAC, to avoid the
+ # compiler to generate them and consequently to break the single image contract
+ # we pass it only to the assembler. This option is utilized only in case of non
+ # integrated assemblers.
+ ifneq ($(CONFIG_AS_HAS_ARMV8_4), y)
+ branch-prot-flags-$(CONFIG_AS_HAS_PAC) += -Wa,-march=armv8.3-a
+ endif
+ endif
+ 
+ KBUILD_CFLAGS += $(branch-prot-flags-y)
+ 
+ ifeq ($(CONFIG_AS_HAS_ARMV8_4), y)
+ # make sure to pass the newest target architecture to -march.
+ KBUILD_CFLAGS	+= -Wa,-march=armv8.4-a
+ endif
+ 
+ ifeq ($(CONFIG_SHADOW_CALL_STACK), y)
+ KBUILD_CFLAGS	+= -ffixed-x18
+ endif
+ 
++>>>>>>> 7c78f67e9bd9 (arm64: enable tlbi range instructions)
  ifeq ($(CONFIG_CPU_BIG_ENDIAN), y)
  KBUILD_CPPFLAGS	+= -mbig-endian
  CHECKFLAGS	+= -D__AARCH64EB__
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/Makefile
