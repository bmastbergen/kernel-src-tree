netfilter: nft_limit: reject configurations that cause integer overflow

jira LE-1907
cve CVE-2024-26668
Rebuild_History Non-Buildable kernel-5.14.0-427.33.1.el9_4
commit-author Florian Westphal <fw@strlen.de>
commit c9d9eb9c53d37cdebbad56b91e40baf42d5a97aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.33.1.el9_4/c9d9eb9c.failed

Reject bogus configs where internal token counter wraps around.
This only occurs with very very large requests, such as 17gbyte/s.

Its better to reject this rather than having incorrect ratelimit.

Fixes: d2168e849ebf ("netfilter: nft_limit: add per-byte limiting")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c9d9eb9c53d37cdebbad56b91e40baf42d5a97aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_limit.c
diff --cc net/netfilter/nft_limit.c
index fd7a28dc5524,cefa25e0dbb0..000000000000
--- a/net/netfilter/nft_limit.c
+++ b/net/netfilter/nft_limit.c
@@@ -51,44 -55,51 +51,78 @@@ static inline bool nft_limit_eval(struc
  /* Use same default as in iptables. */
  #define NFT_LIMIT_PKT_BURST_DEFAULT	5
  
 -static int nft_limit_init(struct nft_limit_priv *priv,
 +static int nft_limit_init(struct nft_limit *limit,
  			  const struct nlattr * const tb[], bool pkts)
  {
++<<<<<<< HEAD
 +	u64 unit, tokens;
++=======
+ 	u64 unit, tokens, rate_with_burst;
+ 	bool invert = false;
++>>>>>>> c9d9eb9c53d3 (netfilter: nft_limit: reject configurations that cause integer overflow)
  
  	if (tb[NFTA_LIMIT_RATE] == NULL ||
  	    tb[NFTA_LIMIT_UNIT] == NULL)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	limit->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));
 +	unit = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_UNIT]));
 +	limit->nsecs = unit * NSEC_PER_SEC;
 +	if (limit->rate == 0 || limit->nsecs < unit)
++=======
+ 	priv->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));
+ 	if (priv->rate == 0)
+ 		return -EINVAL;
+ 
+ 	unit = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_UNIT]));
+ 	if (check_mul_overflow(unit, NSEC_PER_SEC, &priv->nsecs))
++>>>>>>> c9d9eb9c53d3 (netfilter: nft_limit: reject configurations that cause integer overflow)
  		return -EOVERFLOW;
  
  	if (tb[NFTA_LIMIT_BURST])
 -		priv->burst = ntohl(nla_get_be32(tb[NFTA_LIMIT_BURST]));
 +		limit->burst = ntohl(nla_get_be32(tb[NFTA_LIMIT_BURST]));
  
 -	if (pkts && priv->burst == 0)
 -		priv->burst = NFT_LIMIT_PKT_BURST_DEFAULT;
 +	if (pkts && limit->burst == 0)
 +		limit->burst = NFT_LIMIT_PKT_BURST_DEFAULT;
  
++<<<<<<< HEAD
 +	if (limit->rate + limit->burst < limit->rate)
 +		return -EOVERFLOW;
 +
 +	if (pkts) {
 +		tokens = div64_u64(limit->nsecs, limit->rate) * limit->burst;
++=======
+ 	if (check_add_overflow(priv->rate, priv->burst, &rate_with_burst))
+ 		return -EOVERFLOW;
+ 
+ 	if (pkts) {
+ 		u64 tmp = div64_u64(priv->nsecs, priv->rate);
+ 
+ 		if (check_mul_overflow(tmp, priv->burst, &tokens))
+ 			return -EOVERFLOW;
++>>>>>>> c9d9eb9c53d3 (netfilter: nft_limit: reject configurations that cause integer overflow)
  	} else {
+ 		u64 tmp;
+ 
  		/* The token bucket size limits the number of tokens can be
  		 * accumulated. tokens_max specifies the bucket size.
  		 * tokens_max = unit * (rate + burst) / rate.
  		 */
++<<<<<<< HEAD
 +		tokens = div64_u64(limit->nsecs * (limit->rate + limit->burst),
 +				 limit->rate);
++=======
+ 		if (check_mul_overflow(priv->nsecs, rate_with_burst, &tmp))
+ 			return -EOVERFLOW;
+ 
+ 		tokens = div64_u64(tmp, priv->rate);
++>>>>>>> c9d9eb9c53d3 (netfilter: nft_limit: reject configurations that cause integer overflow)
  	}
  
 +	limit->tokens = tokens;
 +	limit->tokens_max = limit->tokens;
 +
  	if (tb[NFTA_LIMIT_FLAGS]) {
  		u32 flags = ntohl(nla_get_be32(tb[NFTA_LIMIT_FLAGS]));
  
* Unmerged path net/netfilter/nft_limit.c
