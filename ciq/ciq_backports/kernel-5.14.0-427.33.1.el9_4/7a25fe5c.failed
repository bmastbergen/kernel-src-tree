ice: stop destroying and reinitalizing Tx tracker during reset

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.33.1.el9_4
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 7a25fe5cd5fb2265065ac6765c53c0a1f1e874d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.33.1.el9_4/7a25fe5c.failed

The ice driver currently attempts to destroy and re-initialize the Tx
timestamp tracker during the reset flow. The release of the Tx tracker
only happened during CORE reset or GLOBAL reset. The ice_ptp_rebuild()
function always calls the ice_ptp_init_tx function which will allocate
a new tracker data structure, resulting in memory leaks during PF reset.

Certainly the driver should not be allocating a new tracker without
removing the old tracker data, as this results in a memory leak.
Additionally, there's no reason to remove the tracker memory during a
reset. Remove this logic from the reset and rebuild flow. Instead of
releasing the Tx tracker, flush outstanding timestamps just before we
reset the PHY timestamp block in ice_ptp_cfg_phy_interrupt().

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Karol Kolacinski <karol.kolacinski@intel.com>
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 7a25fe5cd5fb2265065ac6765c53c0a1f1e874d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ptp.c
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.c
index c75040fefb27,c11eba07283c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.c
@@@ -841,11 -956,29 +841,27 @@@ ice_ptp_flush_tx_tracker(struct ice_pf 
  static void
  ice_ptp_mark_tx_tracker_stale(struct ice_ptp_tx *tx)
  {
 -	unsigned long flags;
 -
 -	spin_lock_irqsave(&tx->lock, flags);
 +	spin_lock(&tx->lock);
  	bitmap_or(tx->stale, tx->stale, tx->in_use, tx->len);
 -	spin_unlock_irqrestore(&tx->lock, flags);
 +	spin_unlock(&tx->lock);
  }
  
+ /**
+  * ice_ptp_flush_all_tx_tracker - Flush all timestamp trackers on this clock
+  * @pf: Board private structure
+  *
+  * Called by the clock owner to flush all the Tx timestamp trackers associated
+  * with the clock.
+  */
+ static void
+ ice_ptp_flush_all_tx_tracker(struct ice_pf *pf)
+ {
+ 	struct ice_ptp_port *port;
+ 
+ 	list_for_each_entry(port, &pf->ptp.ports_owner.ports, list_member)
+ 		ice_ptp_flush_tx_tracker(ptp_port_to_pf(port), &port->tx);
+ }
+ 
  /**
   * ice_ptp_release_tx_tracker - Release allocated memory for Tx tracker
   * @pf: Board private structure
@@@ -2591,29 -2740,40 +2612,32 @@@ void ice_ptp_reset(struct ice_pf *pf
  		/* Enable quad interrupts */
  		err = ice_ptp_cfg_phy_interrupt(pf, true, 1);
  		if (err)
 -			return err;
 -
 -		ice_ptp_restart_all_phy(pf);
 -	}
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_ptp_rebuild - Initialize PTP hardware clock support after reset
 - * @pf: Board private structure
 - * @reset_type: the reset type being performed
 - */
 -void ice_ptp_rebuild(struct ice_pf *pf, enum ice_reset_req reset_type)
 -{
 -	struct ice_ptp *ptp = &pf->ptp;
 -	int err;
 -
 -	if (ptp->state == ICE_PTP_READY) {
 -		ice_ptp_prepare_for_reset(pf, reset_type);
 -	} else if (ptp->state != ICE_PTP_RESETTING) {
 -		err = -EINVAL;
 -		dev_err(ice_pf_to_dev(pf), "PTP was not initialized\n");
 -		goto err;
 +			goto err;
  	}
  
 -	if (ice_pf_src_tmr_owned(pf) && reset_type != ICE_RESET_PFR) {
 -		err = ice_ptp_rebuild_owner(pf);
 -		if (err)
 -			goto err;
++<<<<<<< HEAD
 +pfr:
 +	/* Init Tx structures */
 +	if (ice_is_e810(&pf->hw)) {
 +		err = ice_ptp_init_tx_e810(pf, &ptp->port.tx);
 +	} else {
 +		kthread_init_delayed_work(&ptp->port.ov_work,
 +					  ice_ptp_wait_for_offsets);
 +		err = ice_ptp_init_tx_e82x(pf, &ptp->port.tx,
 +					   ptp->port.port_num);
  	}
 +	if (err)
 +		goto err;
  
++=======
++>>>>>>> 7a25fe5cd5fb (ice: stop destroying and reinitalizing Tx tracker during reset)
  	ptp->state = ICE_PTP_READY;
  
 +	/* Restart the PHY timestamping block */
 +	if (!test_bit(ICE_PFR_REQ, pf->state) &&
 +	    ice_pf_src_tmr_owned(pf))
 +		ice_ptp_restart_all_phy(pf);
 +
  	/* Start periodic work going */
  	kthread_queue_delayed_work(ptp->kworker, &ptp->work, 0);
  
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
