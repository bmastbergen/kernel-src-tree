ice: rename verify_cached to has_ready_bitmap

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.33.1.el9_4
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 3f2216e8dbce04da5376ea7df410541f7b687cb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.33.1.el9_4/3f2216e8.failed

The tx->verify_cached flag is used to inform the Tx timestamp tracking
code whether it needs to verify the cached Tx timestamp value against
a previous captured value. This is necessary on E810 hardware which does
not have a Tx timestamp ready bitmap.

In addition, we currently rely on the fact that the
ice_get_phy_tx_tstamp_ready() function returns all 1s for E810 hardware.
Instead of introducing a brand new flag, rename and verify_cached to
has_ready_bitmap, inverting the relevant checks.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Karol Kolacinski <karol.kolacinski@intel.com>
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 3f2216e8dbce04da5376ea7df410541f7b687cb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ptp.c
#	drivers/net/ethernet/intel/ice/ice_ptp.h
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.c
index d864fbb8c3da,a10e0018b2e2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.c
@@@ -526,6 -525,119 +526,122 @@@ ice_ptp_is_tx_tracker_up(struct ice_ptp
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_ptp_req_tx_single_tstamp - Request Tx timestamp for a port from FW
+  * @tx: the PTP Tx timestamp tracker
+  * @idx: index of the timestamp to request
+  */
+ void ice_ptp_req_tx_single_tstamp(struct ice_ptp_tx *tx, u8 idx)
+ {
+ 	struct ice_ptp_port *ptp_port;
+ 	struct sk_buff *skb;
+ 	struct ice_pf *pf;
+ 
+ 	if (!tx->init)
+ 		return;
+ 
+ 	ptp_port = container_of(tx, struct ice_ptp_port, tx);
+ 	pf = ptp_port_to_pf(ptp_port);
+ 
+ 	/* Drop packets which have waited for more than 2 seconds */
+ 	if (time_is_before_jiffies(tx->tstamps[idx].start + 2 * HZ)) {
+ 		/* Count the number of Tx timestamps that timed out */
+ 		pf->ptp.tx_hwtstamp_timeouts++;
+ 
+ 		skb = tx->tstamps[idx].skb;
+ 		tx->tstamps[idx].skb = NULL;
+ 		clear_bit(idx, tx->in_use);
+ 
+ 		dev_kfree_skb_any(skb);
+ 		return;
+ 	}
+ 
+ 	ice_trace(tx_tstamp_fw_req, tx->tstamps[idx].skb, idx);
+ 
+ 	/* Write TS index to read to the PF register so the FW can read it */
+ 	wr32(&pf->hw, PF_SB_ATQBAL,
+ 	     TS_LL_READ_TS_INTR | FIELD_PREP(TS_LL_READ_TS_IDX, idx) |
+ 	     TS_LL_READ_TS);
+ 	tx->last_ll_ts_idx_read = idx;
+ }
+ 
+ /**
+  * ice_ptp_complete_tx_single_tstamp - Complete Tx timestamp for a port
+  * @tx: the PTP Tx timestamp tracker
+  */
+ void ice_ptp_complete_tx_single_tstamp(struct ice_ptp_tx *tx)
+ {
+ 	struct skb_shared_hwtstamps shhwtstamps = {};
+ 	u8 idx = tx->last_ll_ts_idx_read;
+ 	struct ice_ptp_port *ptp_port;
+ 	u64 raw_tstamp, tstamp;
+ 	bool drop_ts = false;
+ 	struct sk_buff *skb;
+ 	struct ice_pf *pf;
+ 	u32 val;
+ 
+ 	if (!tx->init || tx->last_ll_ts_idx_read < 0)
+ 		return;
+ 
+ 	ptp_port = container_of(tx, struct ice_ptp_port, tx);
+ 	pf = ptp_port_to_pf(ptp_port);
+ 
+ 	ice_trace(tx_tstamp_fw_done, tx->tstamps[idx].skb, idx);
+ 
+ 	val = rd32(&pf->hw, PF_SB_ATQBAL);
+ 
+ 	/* When the bit is cleared, the TS is ready in the register */
+ 	if (val & TS_LL_READ_TS) {
+ 		dev_err(ice_pf_to_dev(pf), "Failed to get the Tx tstamp - FW not ready");
+ 		return;
+ 	}
+ 
+ 	/* High 8 bit value of the TS is on the bits 16:23 */
+ 	raw_tstamp = FIELD_GET(TS_LL_READ_TS_HIGH, val);
+ 	raw_tstamp <<= 32;
+ 
+ 	/* Read the low 32 bit value */
+ 	raw_tstamp |= (u64)rd32(&pf->hw, PF_SB_ATQBAH);
+ 
+ 	/* For PHYs which don't implement a proper timestamp ready bitmap,
+ 	 * verify that the timestamp value is different from the last cached
+ 	 * timestamp. If it is not, skip this for now assuming it hasn't yet
+ 	 * been captured by hardware.
+ 	 */
+ 	if (!drop_ts && !tx->has_ready_bitmap &&
+ 	    raw_tstamp == tx->tstamps[idx].cached_tstamp)
+ 		return;
+ 
+ 	if (!tx->has_ready_bitmap && raw_tstamp)
+ 		tx->tstamps[idx].cached_tstamp = raw_tstamp;
+ 	clear_bit(idx, tx->in_use);
+ 	skb = tx->tstamps[idx].skb;
+ 	tx->tstamps[idx].skb = NULL;
+ 	if (test_and_clear_bit(idx, tx->stale))
+ 		drop_ts = true;
+ 
+ 	if (!skb)
+ 		return;
+ 
+ 	if (drop_ts) {
+ 		dev_kfree_skb_any(skb);
+ 		return;
+ 	}
+ 
+ 	/* Extend the timestamp using cached PHC time */
+ 	tstamp = ice_ptp_extend_40b_ts(pf, raw_tstamp);
+ 	if (tstamp) {
+ 		shhwtstamps.hwtstamp = ns_to_ktime(tstamp);
+ 		ice_trace(tx_tstamp_complete, skb, idx);
+ 	}
+ 
+ 	skb_tstamp_tx(skb, &shhwtstamps);
+ 	dev_kfree_skb_any(skb);
+ }
+ 
+ /**
++>>>>>>> 3f2216e8dbce (ice: rename verify_cached to has_ready_bitmap)
   * ice_ptp_process_tx_tstamp - Process Tx timestamps for a port
   * @tx: the PTP Tx timestamp tracker
   *
@@@ -647,8 -760,8 +763,13 @@@ static void ice_ptp_process_tx_tstamp(s
  			drop_ts = true;
  
  skip_ts_read:
++<<<<<<< HEAD
 +		spin_lock(&tx->lock);
 +		if (tx->verify_cached && raw_tstamp)
++=======
+ 		spin_lock_irqsave(&tx->lock, flags);
+ 		if (!tx->has_ready_bitmap && raw_tstamp)
++>>>>>>> 3f2216e8dbce (ice: rename verify_cached to has_ready_bitmap)
  			tx->tstamps[idx].cached_tstamp = raw_tstamp;
  		clear_bit(idx, tx->in_use);
  		skb = tx->tstamps[idx].skb;
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.h
index 7012808e4497,aa7a5588d11d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.h
@@@ -130,7 -130,10 +130,14 @@@ enum ice_tx_tstamp_work 
   * @init: if true, the tracker is initialized;
   * @calibrating: if true, the PHY is calibrating the Tx offset. During this
   *               window, timestamps are temporarily disabled.
++<<<<<<< HEAD
 + * @verify_cached: if true, verify new timestamp differs from last read value
++=======
+  * @has_ready_bitmap: if true, the hardware has a valid Tx timestamp ready
+  *                    bitmap register. If false, fall back to verifying new
+  *                    timestamp values against previously cached copy.
+  * @last_ll_ts_idx_read: index of the last LL TS read by the FW
++>>>>>>> 3f2216e8dbce (ice: rename verify_cached to has_ready_bitmap)
   */
  struct ice_ptp_tx {
  	spinlock_t lock; /* lock protecting in_use bitmap */
@@@ -142,7 -145,8 +149,12 @@@
  	u8 len;
  	u8 init : 1;
  	u8 calibrating : 1;
++<<<<<<< HEAD
 +	u8 verify_cached : 1;
++=======
+ 	u8 has_ready_bitmap : 1;
+ 	s8 last_ll_ts_idx_read;
++>>>>>>> 3f2216e8dbce (ice: rename verify_cached to has_ready_bitmap)
  };
  
  /* Quad and port information for initializing timestamp blocks */
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.h
