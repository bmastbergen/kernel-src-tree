netfilter: nf_tables: release mutex after nft_gc_seq_end from abort path

jira LE-1907
cve CVE-2024-26925
Rebuild_History Non-Buildable kernel-5.14.0-427.33.1.el9_4
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 0d459e2ffb541841714839e8228b845458ed3b27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.33.1.el9_4/0d459e2f.failed

The commit mutex should not be released during the critical section
between nft_gc_seq_begin() and nft_gc_seq_end(), otherwise, async GC
worker could collect expired objects and get the released commit lock
within the same GC sequence.

nf_tables_module_autoload() temporarily releases the mutex to load
module dependencies, then it goes back to replay the transaction again.
Move it at the end of the abort phase after nft_gc_seq_end() is called.

	Cc: stable@vger.kernel.org
Fixes: 720344340fb9 ("netfilter: nf_tables: GC transaction race with abort path")
	Reported-by: Kuan-Ting Chen <hexrabbit@devco.re>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 0d459e2ffb541841714839e8228b845458ed3b27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index e60b4ceb3116,0d432d0674e1..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -10181,12 -10651,7 +10181,16 @@@ static int __nf_tables_abort(struct ne
  		nf_tables_abort_release(trans);
  	}
  
++<<<<<<< HEAD
 +	if (action == NFNL_ABORT_AUTOLOAD)
 +		nf_tables_module_autoload(net);
 +	else
 +		nf_tables_module_autoload_cleanup(net);
 +
 +	return 0;
++=======
+ 	return err;
++>>>>>>> 0d459e2ffb54 (netfilter: nf_tables: release mutex after nft_gc_seq_end from abort path)
  }
  
  static int nf_tables_abort(struct net *net, struct sk_buff *skb,
@@@ -10199,6 -10664,17 +10203,20 @@@
  	gc_seq = nft_gc_seq_begin(nft_net);
  	ret = __nf_tables_abort(net, action);
  	nft_gc_seq_end(nft_net, gc_seq);
++<<<<<<< HEAD
++=======
+ 
+ 	WARN_ON_ONCE(!list_empty(&nft_net->commit_list));
+ 
+ 	/* module autoload needs to happen after GC sequence update because it
+ 	 * temporarily releases and grabs mutex again.
+ 	 */
+ 	if (action == NFNL_ABORT_AUTOLOAD)
+ 		nf_tables_module_autoload(net);
+ 	else
+ 		nf_tables_module_autoload_cleanup(net);
+ 
++>>>>>>> 0d459e2ffb54 (netfilter: nf_tables: release mutex after nft_gc_seq_end from abort path)
  	mutex_unlock(&nft_net->commit_mutex);
  
  	return ret;
* Unmerged path net/netfilter/nf_tables_api.c
