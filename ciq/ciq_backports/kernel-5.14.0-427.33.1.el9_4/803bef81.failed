ice: factor out ice_ptp_rebuild_owner()

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.33.1.el9_4
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 803bef817807d2d36c930dada20c96fffae0dd19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.33.1.el9_4/803bef81.failed

The ice_ptp_reset() function uses a goto to skip past clock owner
operations if performing a PF reset or if the device is not the clock
owner. This is a bit confusing. Factor this out into
ice_ptp_rebuild_owner() instead.

The ice_ptp_reset() function is called by ice_rebuild() to restore PTP
functionality after a device reset. Follow the convention set by the
ice_main.c file and rename this function to ice_ptp_rebuild(), in the
same way that we have ice_prepare_for_reset() and
ice_ptp_prepare_for_reset().

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Karol Kolacinski <karol.kolacinski@intel.com>
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 803bef817807d2d36c930dada20c96fffae0dd19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_ptp.c
#	drivers/net/ethernet/intel/ice/ice_ptp.h
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index f201190b7a2d,2b7960824bc3..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -7446,7 -7548,7 +7446,11 @@@ static void ice_rebuild(struct ice_pf *
  	 * fail.
  	 */
  	if (test_bit(ICE_FLAG_PTP_SUPPORTED, pf->flags))
++<<<<<<< HEAD
 +		ice_ptp_reset(pf);
++=======
+ 		ice_ptp_rebuild(pf, reset_type);
++>>>>>>> 803bef817807 (ice: factor out ice_ptp_rebuild_owner())
  
  	if (ice_is_feature_supported(pf, ICE_F_GNSS))
  		ice_gnss_init(pf);
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.c
index c75040fefb27,5ede4f61c054..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.c
@@@ -2528,10 -2665,13 +2528,18 @@@ void ice_ptp_prepare_for_reset(struct i
  }
  
  /**
-  * ice_ptp_reset - Initialize PTP hardware clock support after reset
+  * ice_ptp_rebuild_owner - Initialize PTP clock owner after reset
   * @pf: Board private structure
++<<<<<<< HEAD
 + */
 +void ice_ptp_reset(struct ice_pf *pf)
++=======
+  *
+  * Companion function for ice_ptp_rebuild() which handles tasks that only the
+  * PTP clock owner instance should perform.
+  */
+ static int ice_ptp_rebuild_owner(struct ice_pf *pf)
++>>>>>>> 803bef817807 (ice: factor out ice_ptp_rebuild_owner())
  {
  	struct ice_ptp *ptp = &pf->ptp;
  	struct ice_hw *hw = &pf->hw;
@@@ -2539,21 -2679,9 +2547,24 @@@
  	u64 time_diff;
  	int err;
  
++<<<<<<< HEAD
 +	if (ptp->state == ICE_PTP_READY) {
 +		ice_ptp_prepare_for_reset(pf);
 +	} else if (ptp->state != ICE_PTP_RESETTING) {
 +		err = -EINVAL;
 +		dev_err(ice_pf_to_dev(pf), "PTP was not initialized\n");
 +		goto err;
 +	}
 +
 +	if (test_bit(ICE_PFR_REQ, pf->state) ||
 +	    !ice_pf_src_tmr_owned(pf))
 +		goto pfr;
 +
++=======
++>>>>>>> 803bef817807 (ice: factor out ice_ptp_rebuild_owner())
  	err = ice_ptp_init_phc(hw);
  	if (err)
- 		goto err;
+ 		return err;
  
  	/* Acquire the global hardware lock */
  	if (!ice_ptp_lock(hw)) {
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.h
index 7012808e4497,3af20025043a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.h
@@@ -309,9 -313,12 +309,16 @@@ s8 ice_ptp_request_ts(struct ice_ptp_t
  enum ice_tx_tstamp_work ice_ptp_process_ts(struct ice_pf *pf);
  
  u64 ice_ptp_get_rx_hwts(const union ice_32b_rx_flex_desc *rx_desc,
++<<<<<<< HEAD
 +			struct ice_rx_ring *rx_ring);
 +void ice_ptp_reset(struct ice_pf *pf);
 +void ice_ptp_prepare_for_reset(struct ice_pf *pf);
++=======
+ 			const struct ice_pkt_ctx *pkt_ctx);
+ void ice_ptp_rebuild(struct ice_pf *pf, enum ice_reset_req reset_type);
+ void ice_ptp_prepare_for_reset(struct ice_pf *pf,
+ 			       enum ice_reset_req reset_type);
++>>>>>>> 803bef817807 (ice: factor out ice_ptp_rebuild_owner())
  void ice_ptp_init(struct ice_pf *pf);
  void ice_ptp_release(struct ice_pf *pf);
  void ice_ptp_link_change(struct ice_pf *pf, u8 port, bool linkup);
@@@ -346,8 -358,15 +353,20 @@@ ice_ptp_get_rx_hwts(const union ice_32b
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline void ice_ptp_reset(struct ice_pf *pf) { }
 +static inline void ice_ptp_prepare_for_reset(struct ice_pf *pf) { }
++=======
+ static inline void ice_ptp_rebuild(struct ice_pf *pf,
+ 				   enum ice_reset_req reset_type)
+ {
+ }
+ 
+ static inline void ice_ptp_prepare_for_reset(struct ice_pf *pf,
+ 					     enum ice_reset_req reset_type)
+ {
+ }
++>>>>>>> 803bef817807 (ice: factor out ice_ptp_rebuild_owner())
  static inline void ice_ptp_init(struct ice_pf *pf) { }
  static inline void ice_ptp_release(struct ice_pf *pf) { }
  static inline void ice_ptp_link_change(struct ice_pf *pf, u8 port, bool linkup)
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.h
