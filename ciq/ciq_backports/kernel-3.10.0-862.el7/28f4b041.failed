genirq/msi: Add cpumask allocation to alloc_msi_entry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 28f4b04143c56135b1ca742fc64b664ed04de6a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/28f4b041.failed

For irq spreading want to store affinity masks in the msi_entry. Add the
infrastructure for it.

We allocate an array of cpumasks with an array size of the number of used
vectors in the entry, so we can hand in the information per linux interrupt
later.

As we hand in the number of used vectors, we assign them right
away. Convert all the call sites.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: axboe@fb.com
	Cc: keith.busch@intel.com
	Cc: agordeev@redhat.com
	Cc: linux-block@vger.kernel.org
	Cc: Christoph Hellwig <hch@lst.de>
Link: http://lkml.kernel.org/r/1473862739-15032-2-git-send-email-hch@lst.de

(cherry picked from commit 28f4b04143c56135b1ca742fc64b664ed04de6a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/platform-msi.c
#	drivers/pci/msi.c
#	drivers/staging/fsl-mc/bus/mc-msi.c
#	include/linux/msi.h
#	kernel/irq/msi.c
diff --cc drivers/pci/msi.c
index 3127b0433131,0db72ba24003..000000000000
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@@ -548,7 -555,7 +548,11 @@@ static struct msi_desc *msi_setup_entry
  	struct msi_desc *entry;
  
  	/* MSI Entry Initialization */
++<<<<<<< HEAD
 +	entry = alloc_msi_entry(dev);
++=======
+ 	entry = alloc_msi_entry(&dev->dev, nvec, NULL);
++>>>>>>> 28f4b04143c5 (genirq/msi: Add cpumask allocation to alloc_msi_entry)
  	if (!entry)
  		return NULL;
  
@@@ -559,10 -566,9 +563,14 @@@
  	entry->msi_attrib.entry_nr	= 0;
  	entry->msi_attrib.maskbit	= !!(control & PCI_MSI_FLAGS_MASKBIT);
  	entry->msi_attrib.default_irq	= dev->irq;	/* Save IOAPIC IRQ */
 -	entry->msi_attrib.multi_cap	= (control & PCI_MSI_FLAGS_QMASK) >> 1;
 +	entry->msi_attrib.pos		= dev->msi_cap;
 +	entry->multi_cap		= (control & PCI_MSI_FLAGS_QMASK) >> 1;
  	entry->msi_attrib.multiple	= ilog2(__roundup_pow_of_two(nvec));
++<<<<<<< HEAD
 +	entry->nvec_used		= nvec;
++=======
+ 	entry->affinity			= dev->irq_affinity;
++>>>>>>> 28f4b04143c5 (genirq/msi: Add cpumask allocation to alloc_msi_entry)
  
  	if (control & PCI_MSI_FLAGS_64BIT)
  		entry->mask_pos = dev->msi_cap + PCI_MSI_MASK_64;
@@@ -674,11 -680,19 +682,22 @@@ static void __iomem *msix_map_region(st
  static int msix_setup_entries(struct pci_dev *dev, void __iomem *base,
  			      struct msix_entry *entries, int nvec)
  {
 -	const struct cpumask *mask = NULL;
  	struct msi_desc *entry;
 -	int cpu = -1, i;
 +	int i;
  
  	for (i = 0; i < nvec; i++) {
++<<<<<<< HEAD
 +		entry = alloc_msi_entry(dev);
++=======
+ 		if (dev->irq_affinity) {
+ 			cpu = cpumask_next(cpu, dev->irq_affinity);
+ 			if (cpu >= nr_cpu_ids)
+ 				cpu = cpumask_first(dev->irq_affinity);
+ 			mask = cpumask_of(cpu);
+ 		}
+ 
+ 		entry = alloc_msi_entry(&dev->dev, 1, NULL);
++>>>>>>> 28f4b04143c5 (genirq/msi: Add cpumask allocation to alloc_msi_entry)
  		if (!entry) {
  			if (!i)
  				iounmap(base);
@@@ -690,12 -704,15 +709,16 @@@
  
  		entry->msi_attrib.is_msix	= 1;
  		entry->msi_attrib.is_64		= 1;
 -		if (entries)
 -			entry->msi_attrib.entry_nr = entries[i].entry;
 -		else
 -			entry->msi_attrib.entry_nr = i;
 +		entry->msi_attrib.entry_nr	= entries[i].entry;
  		entry->msi_attrib.default_irq	= dev->irq;
  		entry->mask_base		= base;
++<<<<<<< HEAD
 +		entry->nvec_used		= 1;
++=======
+ 		entry->affinity			= mask;
++>>>>>>> 28f4b04143c5 (genirq/msi: Add cpumask allocation to alloc_msi_entry)
  
 -		list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
 +		list_add_tail(&entry->list, &dev->msi_list);
  	}
  
  	return 0;
diff --cc include/linux/msi.h
index d7e73b739119,0db320b7bb15..000000000000
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@@ -17,47 -13,146 +17,112 @@@ struct msi_msg 
  /* Helper functions */
  struct irq_data;
  struct msi_desc;
 -struct pci_dev;
 -struct platform_msi_priv_data;
 +void mask_msi_irq(struct irq_data *data);
 +void unmask_msi_irq(struct irq_data *data);
 +void __read_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
  void __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
 +void __write_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
 +void read_msi_msg(unsigned int irq, struct msi_msg *msg);
  void get_cached_msi_msg(unsigned int irq, struct msi_msg *msg);
 +void write_msi_msg(unsigned int irq, struct msi_msg *msg);
  
 -typedef void (*irq_write_msi_msg_t)(struct msi_desc *desc,
 -				    struct msi_msg *msg);
 -
 -/**
 - * platform_msi_desc - Platform device specific msi descriptor data
 - * @msi_priv_data:	Pointer to platform private data
 - * @msi_index:		The index of the MSI descriptor for multi MSI
 - */
 -struct platform_msi_desc {
 -	struct platform_msi_priv_data	*msi_priv_data;
 -	u16				msi_index;
 -};
 -
 -/**
 - * fsl_mc_msi_desc - FSL-MC device specific msi descriptor data
 - * @msi_index:		The index of the MSI descriptor
 - */
 -struct fsl_mc_msi_desc {
 -	u16				msi_index;
 -};
 -
 -/**
 - * struct msi_desc - Descriptor structure for MSI based interrupts
 - * @list:	List head for management
 - * @irq:	The base interrupt number
 - * @nvec_used:	The number of vectors used
 - * @dev:	Pointer to the device which uses this descriptor
 - * @msg:	The last set MSI message cached for reuse
 - * @affinity:	Optional pointer to a cpu affinity mask for this descriptor
 - *
 - * @masked:	[PCI MSI/X] Mask bits
 - * @is_msix:	[PCI MSI/X] True if MSI-X
 - * @multiple:	[PCI MSI/X] log2 num of messages allocated
 - * @multi_cap:	[PCI MSI/X] log2 num of messages supported
 - * @maskbit:	[PCI MSI/X] Mask-Pending bit supported?
 - * @is_64:	[PCI MSI/X] Address size: 0=32bit 1=64bit
 - * @entry_nr:	[PCI MSI/X] Entry which is described by this descriptor
 - * @default_irq:[PCI MSI/X] The default pre-assigned non-MSI irq
 - * @mask_pos:	[PCI MSI]   Mask register position
 - * @mask_base:	[PCI MSI-X] Mask register base address
 - * @platform:	[platform]  Platform device specific msi descriptor data
 - */
  struct msi_desc {
++<<<<<<< HEAD
 +	struct {
 +		__u8	is_msix	: 1;
 +		__u8	multiple: 3;	/* log2 num of messages allocated */
 +		__u8	maskbit	: 1;	/* mask-pending bit supported ? */
 +		__u8	is_64	: 1;	/* Address size: 0=32bit 1=64bit */
 +		__u8	pos;		/* Deprecated - do not use */
 +		__u16	entry_nr;	/* specific enabled entry */
 +		unsigned default_irq;	/* default pre-assigned irq */
 +	} msi_attrib;
 +
 +	u32 masked;			/* mask bits */
 +	unsigned int irq;
 +	unsigned int nvec_used;		/* number of messages */
 +
 +	/* RHEL KABI: upstream has 'multi_cap' within 'msi_attrib' */
 +	RH_KABI_FILL_HOLE(__u8	multi_cap : 3)	/* log2 num msgs supported */
 +
 +	struct list_head list;
++=======
+ 	/* Shared device/bus type independent data */
+ 	struct list_head		list;
+ 	unsigned int			irq;
+ 	unsigned int			nvec_used;
+ 	struct device			*dev;
+ 	struct msi_msg			msg;
+ 	struct cpumask			*affinity;
++>>>>>>> 28f4b04143c5 (genirq/msi: Add cpumask allocation to alloc_msi_entry)
  
  	union {
 -		/* PCI MSI/X specific data */
 -		struct {
 -			u32 masked;
 -			struct {
 -				__u8	is_msix		: 1;
 -				__u8	multiple	: 3;
 -				__u8	multi_cap	: 3;
 -				__u8	maskbit		: 1;
 -				__u8	is_64		: 1;
 -				__u16	entry_nr;
 -				unsigned default_irq;
 -			} msi_attrib;
 -			union {
 -				u8	mask_pos;
 -				void __iomem *mask_base;
 -			};
 -		};
 -
 -		/*
 -		 * Non PCI variants add their data structure here. New
 -		 * entries need to use a named structure. We want
 -		 * proper name spaces for this. The PCI part is
 -		 * anonymous for now as it would require an immediate
 -		 * tree wide cleanup.
 -		 */
 -		struct platform_msi_desc platform;
 -		struct fsl_mc_msi_desc fsl_mc;
 +		void __iomem *mask_base;
 +		u8 mask_pos;
  	};
 +	struct pci_dev *dev;
 +
 +	/* Last set MSI message */
 +	struct msi_msg msg;
 +
 +	struct kobject kobj;	/* Deprecated - do not use */
  };
  
++<<<<<<< HEAD
++=======
+ /* Helpers to hide struct msi_desc implementation details */
+ #define msi_desc_to_dev(desc)		((desc)->dev)
+ #define dev_to_msi_list(dev)		(&(dev)->msi_list)
+ #define first_msi_entry(dev)		\
+ 	list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
+ #define for_each_msi_entry(desc, dev)	\
+ 	list_for_each_entry((desc), dev_to_msi_list((dev)), list)
+ 
+ #ifdef CONFIG_PCI_MSI
+ #define first_pci_msi_entry(pdev)	first_msi_entry(&(pdev)->dev)
+ #define for_each_pci_msi_entry(desc, pdev)	\
+ 	for_each_msi_entry((desc), &(pdev)->dev)
+ 
+ struct pci_dev *msi_desc_to_pci_dev(struct msi_desc *desc);
+ void *msi_desc_to_pci_sysdata(struct msi_desc *desc);
+ #else /* CONFIG_PCI_MSI */
+ static inline void *msi_desc_to_pci_sysdata(struct msi_desc *desc)
+ {
+ 	return NULL;
+ }
+ #endif /* CONFIG_PCI_MSI */
+ 
+ struct msi_desc *alloc_msi_entry(struct device *dev, int nvec,
+ 				 const struct cpumask *affinity);
+ void free_msi_entry(struct msi_desc *entry);
+ void __pci_read_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
+ void __pci_write_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
+ void pci_write_msi_msg(unsigned int irq, struct msi_msg *msg);
+ 
+ u32 __pci_msix_desc_mask_irq(struct msi_desc *desc, u32 flag);
+ u32 __pci_msi_desc_mask_irq(struct msi_desc *desc, u32 mask, u32 flag);
+ void pci_msi_mask_irq(struct irq_data *data);
+ void pci_msi_unmask_irq(struct irq_data *data);
+ 
+ /* Conversion helpers. Should be removed after merging */
+ static inline void __write_msi_msg(struct msi_desc *entry, struct msi_msg *msg)
+ {
+ 	__pci_write_msi_msg(entry, msg);
+ }
+ static inline void write_msi_msg(int irq, struct msi_msg *msg)
+ {
+ 	pci_write_msi_msg(irq, msg);
+ }
+ static inline void mask_msi_irq(struct irq_data *data)
+ {
+ 	pci_msi_mask_irq(data);
+ }
+ static inline void unmask_msi_irq(struct irq_data *data)
+ {
+ 	pci_msi_unmask_irq(data);
+ }
+ 
++>>>>>>> 28f4b04143c5 (genirq/msi: Add cpumask allocation to alloc_msi_entry)
  /*
   * The arch hooks to setup up msi irqs. Those functions are
   * implemented as weak symbols so that they /can/ be overriden by
* Unmerged path drivers/base/platform-msi.c
* Unmerged path drivers/staging/fsl-mc/bus/mc-msi.c
* Unmerged path kernel/irq/msi.c
* Unmerged path drivers/base/platform-msi.c
* Unmerged path drivers/pci/msi.c
* Unmerged path drivers/staging/fsl-mc/bus/mc-msi.c
* Unmerged path include/linux/msi.h
* Unmerged path kernel/irq/msi.c
