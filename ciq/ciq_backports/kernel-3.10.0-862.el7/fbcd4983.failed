IB/mlx5: Fix NULL deference on mlx5_ib_update_xlt failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ilya Lesokhin <ilyal@mellanox.com>
commit fbcd49838d9094ca45772356e7b33afe4b7c93e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fbcd4983.failed

mlx5_ib_reg_user_mr called mlx5_ib_dereg_mr in case of MR population
failure. This resulted in a NULL dereference as ibmr->device wasn't
initialized yet.

We address this by adding an internal dereg_mr function that can handle
partially initialized MRs, and fixing clean_mr to work on partially
initialized MRs.

Fixes: ff740aefecb9 ("IB/mlx5: Decouple MR allocation and population flows")
	Signed-off-by: Ilya Lesokhin <ilyal@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit fbcd49838d9094ca45772356e7b33afe4b7c93e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/mr.c
diff --cc drivers/infiniband/hw/mlx5/mr.c
index 41cc30b2cbb2,37bbc543847a..000000000000
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@@ -46,14 -46,11 +46,21 @@@ enum 
  };
  
  #define MLX5_UMR_ALIGN 2048
 +#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
 +static __be64 mlx5_ib_update_mtt_emergency_buffer[
 +		MLX5_UMR_MTT_MIN_CHUNK_SIZE/sizeof(__be64)]
 +	__aligned(MLX5_UMR_ALIGN);
 +static DEFINE_MUTEX(mlx5_ib_update_mtt_emergency_buffer_mutex);
 +#endif
  
++<<<<<<< HEAD
 +static int clean_mr(struct mlx5_ib_mr *mr);
++=======
+ static int clean_mr(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr);
+ static int dereg_mr(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr);
+ static int mr_cache_max_order(struct mlx5_ib_dev *dev);
+ static int unreg_umr(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr);
++>>>>>>> fbcd49838d90 (IB/mlx5: Fix NULL deference on mlx5_ib_update_xlt failure)
  
  static int destroy_mkey(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr)
  {
@@@ -1259,8 -1263,23 +1266,27 @@@ struct ib_mr *mlx5_ib_reg_user_mr(struc
  	update_odp_mr(mr);
  #endif
  
++<<<<<<< HEAD
++=======
+ 	if (use_umr) {
+ 		int update_xlt_flags = MLX5_IB_UPD_XLT_ENABLE;
+ 
+ 		if (access_flags & IB_ACCESS_ON_DEMAND)
+ 			update_xlt_flags |= MLX5_IB_UPD_XLT_ZAP;
+ 
+ 		err = mlx5_ib_update_xlt(mr, 0, ncont, page_shift,
+ 					 update_xlt_flags);
+ 
+ 		if (err) {
+ 			dereg_mr(dev, mr);
+ 			return ERR_PTR(err);
+ 		}
+ 	}
+ 
+ 	mr->live = 1;
++>>>>>>> fbcd49838d90 (IB/mlx5: Fix NULL deference on mlx5_ib_update_xlt failure)
  	return &mr->ibmr;
 +
  error:
  	ib_umem_release(umem);
  	return ERR_PTR(err);
@@@ -1399,7 -1358,7 +1425,11 @@@ int mlx5_ib_rereg_user_mr(struct ib_mr 
  		err = mr_umem_get(pd, addr, len, access_flags, &mr->umem,
  				  &npages, &page_shift, &ncont, &order);
  		if (err < 0) {
++<<<<<<< HEAD
 +			mr->umem = NULL;
++=======
+ 			clean_mr(dev, mr);
++>>>>>>> fbcd49838d90 (IB/mlx5: Fix NULL deference on mlx5_ib_update_xlt failure)
  			return err;
  		}
  	}
@@@ -1431,10 -1391,28 +1461,15 @@@
  		/*
  		 * Send a UMR WQE
  		 */
 -		mr->ibmr.pd = pd;
 -		mr->access_flags = access_flags;
 -		mr->mmkey.iova = addr;
 -		mr->mmkey.size = len;
 -		mr->mmkey.pd = to_mpd(pd)->pdn;
 -
 -		if (flags & IB_MR_REREG_TRANS) {
 -			upd_flags = MLX5_IB_UPD_XLT_ADDR;
 -			if (flags & IB_MR_REREG_PD)
 -				upd_flags |= MLX5_IB_UPD_XLT_PD;
 -			if (flags & IB_MR_REREG_ACCESS)
 -				upd_flags |= MLX5_IB_UPD_XLT_ACCESS;
 -			err = mlx5_ib_update_xlt(mr, 0, npages, page_shift,
 -						 upd_flags);
 -		} else {
 -			err = rereg_umr(pd, mr, access_flags, flags);
 -		}
 -
 +		err = rereg_umr(pd, mr, addr, len, npages, page_shift,
 +				order, access_flags, flags);
  		if (err) {
  			mlx5_ib_warn(dev, "Failed to rereg UMR\n");
++<<<<<<< HEAD
++=======
+ 			ib_umem_release(mr->umem);
+ 			clean_mr(dev, mr);
++>>>>>>> fbcd49838d90 (IB/mlx5: Fix NULL deference on mlx5_ib_update_xlt failure)
  			return err;
  		}
  	}
@@@ -1506,10 -1471,9 +1541,14 @@@ mlx5_free_priv_descs(struct mlx5_ib_mr 
  	}
  }
  
- static int clean_mr(struct mlx5_ib_mr *mr)
+ static int clean_mr(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr)
  {
++<<<<<<< HEAD
 +	struct mlx5_ib_dev *dev = to_mdev(mr->ibmr.device);
 +	int umred = mr->umred;
++=======
+ 	int allocated_from_cache = mr->allocated_from_cache;
++>>>>>>> fbcd49838d90 (IB/mlx5: Fix NULL deference on mlx5_ib_update_xlt failure)
  	int err;
  
  	if (mr->sig) {
* Unmerged path drivers/infiniband/hw/mlx5/mr.c
