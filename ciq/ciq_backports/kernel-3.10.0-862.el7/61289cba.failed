iommu/amd: Remove old alias handling code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] amd: Remove old alias handling code (Jerry Snitselaar) [1411581]
Rebuild_FUZZ: 92.11%
commit-author Joerg Roedel <jroedel@suse.de>
commit 61289cbaf6c854a493ad0fa405c3dd39e7a384f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/61289cba.failed

This mostly removes the code to create dev_data structures
for alias device ids. They are not necessary anymore, as
they were only created for device ids which have no struct
pci_dev associated with it.  But these device ids are
handled in a simpler way now, so there is no need for this
code anymore.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 61289cbaf6c854a493ad0fa405c3dd39e7a384f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu.c
diff --cc drivers/iommu/amd_iommu.c
index d7000b809828,fe112bbaae88..000000000000
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@@ -310,67 -296,6 +295,70 @@@ out
  	iommu_group_put(group);
  }
  
++<<<<<<< HEAD
 +static int __last_alias(struct pci_dev *pdev, u16 alias, void *data)
 +{
 +	*(u16 *)data = alias;
 +	return 0;
 +}
 +
 +static u16 get_alias(struct device *dev)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +	u16 devid, ivrs_alias, pci_alias;
 +
 +	devid = get_device_id(dev);
 +	ivrs_alias = amd_iommu_alias_table[devid];
 +	pci_for_each_dma_alias(pdev, __last_alias, &pci_alias);
 +
 +	if (ivrs_alias == pci_alias)
 +		return ivrs_alias;
 +
 +	/*
 +	 * DMA alias showdown
 +	 *
 +	 * The IVRS is fairly reliable in telling us about aliases, but it
 +	 * can't know about every screwy device.  If we don't have an IVRS
 +	 * reported alias, use the PCI reported alias.  In that case we may
 +	 * still need to initialize the rlookup and dev_table entries if the
 +	 * alias is to a non-existent device.
 +	 */
 +	if (ivrs_alias == devid) {
 +		if (!amd_iommu_rlookup_table[pci_alias]) {
 +			amd_iommu_rlookup_table[pci_alias] =
 +				amd_iommu_rlookup_table[devid];
 +			memcpy(amd_iommu_dev_table[pci_alias].data,
 +			       amd_iommu_dev_table[devid].data,
 +			       sizeof(amd_iommu_dev_table[pci_alias].data));
 +		}
 +
 +		return pci_alias;
 +	}
 +
 +	pr_info("AMD-Vi: Using IVRS reported alias %02x:%02x.%d "
 +		"for device %s[%04x:%04x], kernel reported alias "
 +		"%02x:%02x.%d\n", PCI_BUS_NUM(ivrs_alias), PCI_SLOT(ivrs_alias),
 +		PCI_FUNC(ivrs_alias), dev_name(dev), pdev->vendor, pdev->device,
 +		PCI_BUS_NUM(pci_alias), PCI_SLOT(pci_alias),
 +		PCI_FUNC(pci_alias));
 +
 +	/*
 +	 * If we don't have a PCI DMA alias and the IVRS alias is on the same
 +	 * bus, then the IVRS table may know about a quirk that we don't.
 +	 */
 +	if (pci_alias == devid &&
 +	    PCI_BUS_NUM(ivrs_alias) == pdev->bus->number) {
 +		pci_add_dma_alias(pdev, ivrs_alias & 0xff);
 +		pr_info("AMD-Vi: Added PCI DMA alias %02x.%d for %s\n",
 +			PCI_SLOT(ivrs_alias), PCI_FUNC(ivrs_alias),
 +			dev_name(dev));
 +	}
 +
 +	return ivrs_alias;
 +}
 +
++=======
++>>>>>>> 61289cbaf6c8 (iommu/amd: Remove old alias handling code)
  static int iommu_init_device(struct device *dev)
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
* Unmerged path drivers/iommu/amd_iommu.c
