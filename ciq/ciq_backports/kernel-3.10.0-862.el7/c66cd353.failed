RDMA/core: expose affinity mappings per completion vector

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [infiniband] core: expose affinity mappings per completion vector (Don Dutile) [1499364 1456694]
Rebuild_FUZZ: 95.41%
commit-author Sagi Grimberg <sagi@grimberg.me>
commit c66cd353bbe6869a059869a7a1518ec619afdc9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c66cd353.failed

This will allow ULPs to intelligently locate threads based
on completion vector cpu affinity mappings. In case the
driver does not expose a get_vector_affinity callout, return
NULL so the caller can maintain a fallback logic.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: HÃ¥kon Bugge <haakon.bugge@oracle.com>
	Acked-by: Doug Ledford <dledford@redhat.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit c66cd353bbe6869a059869a7a1518ec619afdc9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/rdma/ib_verbs.h
diff --cc include/rdma/ib_verbs.h
index 9d98b1e7b1da,73ed2e4e802f..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -3510,5 -3556,178 +3512,182 @@@ void ib_drain_sq(struct ib_qp *qp)
  void ib_drain_qp(struct ib_qp *qp);
  
  int ib_resolve_eth_dmac(struct ib_device *device,
++<<<<<<< HEAD
 +			struct ib_ah_attr *ah_attr);
++=======
+ 			struct rdma_ah_attr *ah_attr);
+ 
+ static inline u8 *rdma_ah_retrieve_dmac(struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_ROCE)
+ 		return attr->roce.dmac;
+ 	return NULL;
+ }
+ 
+ static inline void rdma_ah_set_dlid(struct rdma_ah_attr *attr, u32 dlid)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		attr->ib.dlid = (u16)dlid;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		attr->opa.dlid = dlid;
+ }
+ 
+ static inline u32 rdma_ah_get_dlid(const struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		return attr->ib.dlid;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		return attr->opa.dlid;
+ 	return 0;
+ }
+ 
+ static inline void rdma_ah_set_sl(struct rdma_ah_attr *attr, u8 sl)
+ {
+ 	attr->sl = sl;
+ }
+ 
+ static inline u8 rdma_ah_get_sl(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->sl;
+ }
+ 
+ static inline void rdma_ah_set_path_bits(struct rdma_ah_attr *attr,
+ 					 u8 src_path_bits)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		attr->ib.src_path_bits = src_path_bits;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		attr->opa.src_path_bits = src_path_bits;
+ }
+ 
+ static inline u8 rdma_ah_get_path_bits(const struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		return attr->ib.src_path_bits;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		return attr->opa.src_path_bits;
+ 	return 0;
+ }
+ 
+ static inline void rdma_ah_set_port_num(struct rdma_ah_attr *attr, u8 port_num)
+ {
+ 	attr->port_num = port_num;
+ }
+ 
+ static inline u8 rdma_ah_get_port_num(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->port_num;
+ }
+ 
+ static inline void rdma_ah_set_static_rate(struct rdma_ah_attr *attr,
+ 					   u8 static_rate)
+ {
+ 	attr->static_rate = static_rate;
+ }
+ 
+ static inline u8 rdma_ah_get_static_rate(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->static_rate;
+ }
+ 
+ static inline void rdma_ah_set_ah_flags(struct rdma_ah_attr *attr,
+ 					enum ib_ah_flags flag)
+ {
+ 	attr->ah_flags = flag;
+ }
+ 
+ static inline enum ib_ah_flags
+ 		rdma_ah_get_ah_flags(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->ah_flags;
+ }
+ 
+ static inline const struct ib_global_route
+ 		*rdma_ah_read_grh(const struct rdma_ah_attr *attr)
+ {
+ 	return &attr->grh;
+ }
+ 
+ /*To retrieve and modify the grh */
+ static inline struct ib_global_route
+ 		*rdma_ah_retrieve_grh(struct rdma_ah_attr *attr)
+ {
+ 	return &attr->grh;
+ }
+ 
+ static inline void rdma_ah_set_dgid_raw(struct rdma_ah_attr *attr, void *dgid)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	memcpy(grh->dgid.raw, dgid, sizeof(grh->dgid));
+ }
+ 
+ static inline void rdma_ah_set_subnet_prefix(struct rdma_ah_attr *attr,
+ 					     __be64 prefix)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	grh->dgid.global.subnet_prefix = prefix;
+ }
+ 
+ static inline void rdma_ah_set_interface_id(struct rdma_ah_attr *attr,
+ 					    __be64 if_id)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	grh->dgid.global.interface_id = if_id;
+ }
+ 
+ static inline void rdma_ah_set_grh(struct rdma_ah_attr *attr,
+ 				   union ib_gid *dgid, u32 flow_label,
+ 				   u8 sgid_index, u8 hop_limit,
+ 				   u8 traffic_class)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	attr->ah_flags = IB_AH_GRH;
+ 	if (dgid)
+ 		grh->dgid = *dgid;
+ 	grh->flow_label = flow_label;
+ 	grh->sgid_index = sgid_index;
+ 	grh->hop_limit = hop_limit;
+ 	grh->traffic_class = traffic_class;
+ }
+ 
+ /*Get AH type */
+ static inline enum rdma_ah_attr_type rdma_ah_find_type(struct ib_device *dev,
+ 						       u32 port_num)
+ {
+ 	if ((rdma_protocol_roce(dev, port_num)) ||
+ 	    (rdma_protocol_iwarp(dev, port_num)))
+ 		return RDMA_AH_ATTR_TYPE_ROCE;
+ 	else if ((rdma_protocol_ib(dev, port_num)) &&
+ 		 (rdma_cap_opa_ah(dev, port_num)))
+ 		return RDMA_AH_ATTR_TYPE_OPA;
+ 	else
+ 		return RDMA_AH_ATTR_TYPE_IB;
+ }
+ 
+ /**
+  * ib_get_vector_affinity - Get the affinity mappings of a given completion
+  *   vector
+  * @device:         the rdma device
+  * @comp_vector:    index of completion vector
+  *
+  * Returns NULL on failure, otherwise a corresponding cpu map of the
+  * completion vector (returns all-cpus map if the device driver doesn't
+  * implement get_vector_affinity).
+  */
+ static inline const struct cpumask *
+ ib_get_vector_affinity(struct ib_device *device, int comp_vector)
+ {
+ 	if (comp_vector < 0 || comp_vector >= device->num_comp_vectors ||
+ 	    !device->get_vector_affinity)
+ 		return NULL;
+ 
+ 	return device->get_vector_affinity(device, comp_vector);
+ 
+ }
+ 
++>>>>>>> c66cd353bbe6 (RDMA/core: expose affinity mappings per completion vector)
  #endif /* IB_VERBS_H */
* Unmerged path include/rdma/ib_verbs.h
