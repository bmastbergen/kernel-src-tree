scsi_dh_alua: Declare local functions static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 1f275f976fdc04bf1bfd06929d10852b1b05decc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1f275f97.failed

This patch avoids that building with W=1 causes gcc to report the
following type of warning:

    no previous prototype for ... [-Wmissing-prototypes]

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Hannes Reinicke <hare@suse.de>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Ewan Milne <emilne@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1f275f976fdc04bf1bfd06929d10852b1b05decc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 2f054f24112a,e034f12c1418..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -165,6 -190,84 +165,87 @@@ static int submit_stpg(struct scsi_devi
  				      ALUA_FAILOVER_RETRIES, NULL, req_flags);
  }
  
++<<<<<<< HEAD
++=======
+ static struct alua_port_group *alua_find_get_pg(char *id_str, size_t id_size,
+ 						int group_id)
+ {
+ 	struct alua_port_group *pg;
+ 
+ 	list_for_each_entry(pg, &port_group_list, node) {
+ 		if (pg->group_id != group_id)
+ 			continue;
+ 		if (pg->device_id_len != id_size)
+ 			continue;
+ 		if (strncmp(pg->device_id_str, id_str, id_size))
+ 			continue;
+ 		if (!kref_get_unless_zero(&pg->kref))
+ 			continue;
+ 		return pg;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * alua_alloc_pg - Allocate a new port_group structure
+  * @sdev: scsi device
+  * @h: alua device_handler data
+  * @group_id: port group id
+  *
+  * Allocate a new port_group structure for a given
+  * device.
+  */
+ static struct alua_port_group *alua_alloc_pg(struct scsi_device *sdev,
+ 					     int group_id, int tpgs)
+ {
+ 	struct alua_port_group *pg, *tmp_pg;
+ 
+ 	pg = kzalloc(sizeof(struct alua_port_group), GFP_KERNEL);
+ 	if (!pg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pg->device_id_len = scsi_vpd_lun_id(sdev, pg->device_id_str,
+ 					    sizeof(pg->device_id_str));
+ 	if (pg->device_id_len <= 0) {
+ 		/*
+ 		 * Internal error: TPGS supported but no device
+ 		 * identifcation found. Disable ALUA support.
+ 		 */
+ 		kfree(pg);
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: No device descriptors found\n",
+ 			    ALUA_DH_NAME);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 	pg->group_id = group_id;
+ 	pg->tpgs = tpgs;
+ 	pg->state = SCSI_ACCESS_STATE_OPTIMAL;
+ 	if (optimize_stpg)
+ 		pg->flags |= ALUA_OPTIMIZE_STPG;
+ 	kref_init(&pg->kref);
+ 	INIT_DELAYED_WORK(&pg->rtpg_work, alua_rtpg_work);
+ 	INIT_LIST_HEAD(&pg->rtpg_list);
+ 	INIT_LIST_HEAD(&pg->node);
+ 	INIT_LIST_HEAD(&pg->dh_list);
+ 	spin_lock_init(&pg->lock);
+ 
+ 	spin_lock(&port_group_lock);
+ 	tmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,
+ 				  group_id);
+ 	if (tmp_pg) {
+ 		spin_unlock(&port_group_lock);
+ 		kfree(pg);
+ 		return tmp_pg;
+ 	}
+ 
+ 	list_add(&pg->node, &port_group_list);
+ 	spin_unlock(&port_group_lock);
+ 
+ 	return pg;
+ }
+ 
++>>>>>>> 1f275f976fdc (scsi_dh_alua: Declare local functions static)
  /*
   * alua_check_tpgs - Evaluate TPGS setting
   * @sdev: device to be checked
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
