scripts/spelling.txt: add "an union" pattern and fix typo instances

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Masahiro Yamada <yamada.masahiro@socionext.com>
commit 03440c4e5e2f167764997a7e0f2dbb279d8078e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/03440c4e.failed

Fix typos and add the following to the scripts/spelling.txt:

  an union||a union

Link: http://lkml.kernel.org/r/1481573103-11329-5-git-send-email-yamada.masahiro@socionext.com
	Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 03440c4e5e2f167764997a7e0f2dbb279d8078e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/media/uapi/dvb/dvb-frontend-parameters.rst
#	drivers/acpi/acpica/dbconvert.c
#	drivers/staging/lustre/lustre/include/lustre/lustre_idl.h
#	include/linux/dcache.h
#	include/media/v4l2-ctrls.h
#	scripts/spelling.txt
diff --cc include/linux/dcache.h
index f0773ba5c120,591b6c16f9c1..000000000000
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@@ -568,4 -556,39 +568,42 @@@ static inline struct dentry *d_backing_
  	return upper;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * d_real - Return the real dentry
+  * @dentry: the dentry to query
+  * @inode: inode to select the dentry from multiple layers (can be NULL)
+  * @flags: open flags to control copy-up behavior
+  *
+  * If dentry is on a union/overlay, then return the underlying, real dentry.
+  * Otherwise return the dentry itself.
+  *
+  * See also: Documentation/filesystems/vfs.txt
+  */
+ static inline struct dentry *d_real(struct dentry *dentry,
+ 				    const struct inode *inode,
+ 				    unsigned int flags)
+ {
+ 	if (unlikely(dentry->d_flags & DCACHE_OP_REAL))
+ 		return dentry->d_op->d_real(dentry, inode, flags);
+ 	else
+ 		return dentry;
+ }
+ 
+ /**
+  * d_real_inode - Return the real inode
+  * @dentry: The dentry to query
+  *
+  * If dentry is on a union/overlay, then return the underlying, real inode.
+  * Otherwise return d_inode().
+  */
+ static inline struct inode *d_real_inode(const struct dentry *dentry)
+ {
+ 	/* This usage of d_real() results in const dentry */
+ 	return d_backing_inode(d_real((struct dentry *) dentry, NULL, 0));
+ }
+ 
+ 
++>>>>>>> 03440c4e5e2f (scripts/spelling.txt: add "an union" pattern and fix typo instances)
  #endif	/* __LINUX_DCACHE_H */
diff --cc include/media/v4l2-ctrls.h
index 47ada23345a1,bee1404391dd..000000000000
--- a/include/media/v4l2-ctrls.h
+++ b/include/media/v4l2-ctrls.h
@@@ -54,63 -72,115 +54,142 @@@ struct v4l2_ctrl_ops 
  	int (*s_ctrl)(struct v4l2_ctrl *ctrl);
  };
  
 -/**
 - * struct v4l2_ctrl_type_ops - The control type operations that the driver
 - *			       has to provide.
 - *
 - * @equal: return true if both values are equal.
 - * @init: initialize the value.
 - * @log: log the value.
 - * @validate: validate the value. Return 0 on success and a negative value
 - *	otherwise.
 - */
 -struct v4l2_ctrl_type_ops {
 -	bool (*equal)(const struct v4l2_ctrl *ctrl, u32 idx,
 -		      union v4l2_ctrl_ptr ptr1,
 -		      union v4l2_ctrl_ptr ptr2);
 -	void (*init)(const struct v4l2_ctrl *ctrl, u32 idx,
 -		     union v4l2_ctrl_ptr ptr);
 -	void (*log)(const struct v4l2_ctrl *ctrl);
 -	int (*validate)(const struct v4l2_ctrl *ctrl, u32 idx,
 -			union v4l2_ctrl_ptr ptr);
 -};
 -
 -/**
 - * typedef v4l2_ctrl_notify_fnc - typedef for a notify argument with a function
 - *	that should be called when a control value has changed.
 - *
 - * @ctrl: pointer to struct &v4l2_ctrl
 - * @priv: control private data
 - *
 - * This typedef definition is used as an argument to v4l2_ctrl_notify()
 - * and as an argument at struct &v4l2_ctrl_handler.
 - */
  typedef void (*v4l2_ctrl_notify_fnc)(struct v4l2_ctrl *ctrl, void *priv);
  
++<<<<<<< HEAD
 +/** struct v4l2_ctrl - The control structure.
 +  * @node:	The list node.
 +  * @ev_subs:	The list of control event subscriptions.
 +  * @handler:	The handler that owns the control.
 +  * @cluster:	Point to start of cluster array.
 +  * @ncontrols:	Number of controls in cluster array.
 +  * @done:	Internal flag: set for each processed control.
 +  * @is_new:	Set when the user specified a new value for this control. It
 +  *		is also set when called from v4l2_ctrl_handler_setup. Drivers
 +  *		should never set this flag.
 +  * @is_private: If set, then this control is private to its handler and it
 +  *		will not be added to any other handlers. Drivers can set
 +  *		this flag.
 +  * @is_auto:   If set, then this control selects whether the other cluster
 +  *		members are in 'automatic' mode or 'manual' mode. This is
 +  *		used for autogain/gain type clusters. Drivers should never
 +  *		set this flag directly.
 +  * @has_volatiles: If set, then one or more members of the cluster are volatile.
 +  *		Drivers should never touch this flag.
 +  * @call_notify: If set, then call the handler's notify function whenever the
 +  *		control's value changes.
 +  * @manual_mode_value: If the is_auto flag is set, then this is the value
 +  *		of the auto control that determines if that control is in
 +  *		manual mode. So if the value of the auto control equals this
 +  *		value, then the whole cluster is in manual mode. Drivers should
 +  *		never set this flag directly.
 +  * @ops:	The control ops.
 +  * @id:	The control ID.
 +  * @name:	The control name.
 +  * @type:	The control type.
 +  * @minimum:	The control's minimum value.
 +  * @maximum:	The control's maximum value.
 +  * @default_value: The control's default value.
 +  * @step:	The control's step value for non-menu controls.
 +  * @menu_skip_mask: The control's skip mask for menu controls. This makes it
 +  *		easy to skip menu items that are not valid. If bit X is set,
 +  *		then menu item X is skipped. Of course, this only works for
 +  *		menus with <= 32 menu items. There are no menus that come
 +  *		close to that number, so this is OK. Should we ever need more,
 +  *		then this will have to be extended to a u64 or a bit array.
 +  * @qmenu:	A const char * array for all menu items. Array entries that are
 +  *		empty strings ("") correspond to non-existing menu items (this
 +  *		is in addition to the menu_skip_mask above). The last entry
 +  *		must be NULL.
 +  * @flags:	The control's flags.
 +  * @cur:	The control's current value.
 +  * @val:	The control's new s32 value.
 +  * @val64:	The control's new s64 value.
 +  * @string:	The control's new string value.
 +  * @priv:	The control's private pointer. For use by the driver. It is
 +  *		untouched by the control framework. Note that this pointer is
 +  *		not freed when the control is deleted. Should this be needed
 +  *		then a new internal bitfield can be added to tell the framework
 +  *		to free this pointer.
 +  */
++=======
+ /**
+  * struct v4l2_ctrl - The control structure.
+  *
+  * @node:	The list node.
+  * @ev_subs:	The list of control event subscriptions.
+  * @handler:	The handler that owns the control.
+  * @cluster:	Point to start of cluster array.
+  * @ncontrols:	Number of controls in cluster array.
+  * @done:	Internal flag: set for each processed control.
+  * @is_new:	Set when the user specified a new value for this control. It
+  *		is also set when called from v4l2_ctrl_handler_setup(). Drivers
+  *		should never set this flag.
+  * @has_changed: Set when the current value differs from the new value. Drivers
+  *		should never use this flag.
+  * @is_private: If set, then this control is private to its handler and it
+  *		will not be added to any other handlers. Drivers can set
+  *		this flag.
+  * @is_auto:   If set, then this control selects whether the other cluster
+  *		members are in 'automatic' mode or 'manual' mode. This is
+  *		used for autogain/gain type clusters. Drivers should never
+  *		set this flag directly.
+  * @is_int:    If set, then this control has a simple integer value (i.e. it
+  *		uses ctrl->val).
+  * @is_string: If set, then this control has type %V4L2_CTRL_TYPE_STRING.
+  * @is_ptr:	If set, then this control is an array and/or has type >=
+  *		%V4L2_CTRL_COMPOUND_TYPES
+  *		and/or has type %V4L2_CTRL_TYPE_STRING. In other words, &struct
+  *		v4l2_ext_control uses field p to point to the data.
+  * @is_array: If set, then this control contains an N-dimensional array.
+  * @has_volatiles: If set, then one or more members of the cluster are volatile.
+  *		Drivers should never touch this flag.
+  * @call_notify: If set, then call the handler's notify function whenever the
+  *		control's value changes.
+  * @manual_mode_value: If the is_auto flag is set, then this is the value
+  *		of the auto control that determines if that control is in
+  *		manual mode. So if the value of the auto control equals this
+  *		value, then the whole cluster is in manual mode. Drivers should
+  *		never set this flag directly.
+  * @ops:	The control ops.
+  * @type_ops:	The control type ops.
+  * @id:	The control ID.
+  * @name:	The control name.
+  * @type:	The control type.
+  * @minimum:	The control's minimum value.
+  * @maximum:	The control's maximum value.
+  * @default_value: The control's default value.
+  * @step:	The control's step value for non-menu controls.
+  * @elems:	The number of elements in the N-dimensional array.
+  * @elem_size:	The size in bytes of the control.
+  * @dims:	The size of each dimension.
+  * @nr_of_dims:The number of dimensions in @dims.
+  * @menu_skip_mask: The control's skip mask for menu controls. This makes it
+  *		easy to skip menu items that are not valid. If bit X is set,
+  *		then menu item X is skipped. Of course, this only works for
+  *		menus with <= 32 menu items. There are no menus that come
+  *		close to that number, so this is OK. Should we ever need more,
+  *		then this will have to be extended to a u64 or a bit array.
+  * @qmenu:	A const char * array for all menu items. Array entries that are
+  *		empty strings ("") correspond to non-existing menu items (this
+  *		is in addition to the menu_skip_mask above). The last entry
+  *		must be NULL.
+  * @flags:	The control's flags.
+  * @cur:	The control's current value.
+  * @val:	The control's new s32 value.
+  * @priv:	The control's private pointer. For use by the driver. It is
+  *		untouched by the control framework. Note that this pointer is
+  *		not freed when the control is deleted. Should this be needed
+  *		then a new internal bitfield can be added to tell the framework
+  *		to free this pointer.
+  * @p_cur:	The control's current value represented via a union with
+  *		provides a standard way of accessing control types
+  *		through a pointer.
+  * @p_new:	The control's new value represented via a union with provides
+  *		a standard way of accessing control types
+  *		through a pointer.
+  */
++>>>>>>> 03440c4e5e2f (scripts/spelling.txt: add "an union" pattern and fix typo instances)
  struct v4l2_ctrl {
  	/* Administrative fields */
  	struct list_head node;
* Unmerged path Documentation/media/uapi/dvb/dvb-frontend-parameters.rst
* Unmerged path drivers/acpi/acpica/dbconvert.c
* Unmerged path drivers/staging/lustre/lustre/include/lustre/lustre_idl.h
* Unmerged path scripts/spelling.txt
* Unmerged path Documentation/media/uapi/dvb/dvb-frontend-parameters.rst
diff --git a/arch/x86/include/asm/desc_defs.h b/arch/x86/include/asm/desc_defs.h
index 278441f39856..9a32d310bcae 100644
--- a/arch/x86/include/asm/desc_defs.h
+++ b/arch/x86/include/asm/desc_defs.h
@@ -15,7 +15,7 @@
  * FIXME: Accessing the desc_struct through its fields is more elegant,
  * and should be the one valid thing to do. However, a lot of open code
  * still touches the a and b accessors, and doing this allow us to do it
- * incrementally. We keep the signature as a struct, rather than an union,
+ * incrementally. We keep the signature as a struct, rather than a union,
  * so we can get rid of it transparently in the future -- glommer
  */
 /* 8 byte segment descriptor */
* Unmerged path drivers/acpi/acpica/dbconvert.c
diff --git a/drivers/acpi/acpica/nspredef.c b/drivers/acpi/acpica/nspredef.c
index 24b71a01bf93..5dcec6384ce3 100644
--- a/drivers/acpi/acpica/nspredef.c
+++ b/drivers/acpi/acpica/nspredef.c
@@ -309,7 +309,7 @@ acpi_ns_check_reference(struct acpi_evaluate_info *info,
 
 	/*
 	 * Check the reference object for the correct reference type (opcode).
-	 * The only type of reference that can be converted to an union acpi_object is
+	 * The only type of reference that can be converted to a union acpi_object is
 	 * a reference to a named object (reference class: NAME)
 	 */
 	if (return_object->reference.class == ACPI_REFCLASS_NAME) {
diff --git a/drivers/acpi/acpica/nsxfeval.c b/drivers/acpi/acpica/nsxfeval.c
index 3013b3cad107..84f8262b88e9 100644
--- a/drivers/acpi/acpica/nsxfeval.c
+++ b/drivers/acpi/acpica/nsxfeval.c
@@ -493,9 +493,9 @@ static void acpi_ns_resolve_references(struct acpi_evaluate_info *info)
 	/*
 	 * Two types of references are supported - those created by Index and
 	 * ref_of operators. A name reference (AML_NAMEPATH_OP) can be converted
-	 * to an union acpi_object, so it is not dereferenced here. A ddb_handle
+	 * to a union acpi_object, so it is not dereferenced here. A ddb_handle
 	 * (AML_LOAD_OP) cannot be dereferenced, nor can it be converted to
-	 * an union acpi_object.
+	 * a union acpi_object.
 	 */
 	switch (info->return_object->reference.class) {
 	case ACPI_REFCLASS_INDEX:
* Unmerged path drivers/staging/lustre/lustre/include/lustre/lustre_idl.h
* Unmerged path include/linux/dcache.h
* Unmerged path include/media/v4l2-ctrls.h
diff --git a/include/xen/interface/grant_table.h b/include/xen/interface/grant_table.h
index e40fae9bf11a..ecc007df3091 100644
--- a/include/xen/interface/grant_table.h
+++ b/include/xen/interface/grant_table.h
@@ -181,7 +181,7 @@ struct grant_entry_header {
 };
 
 /*
- * Version 2 of the grant entry structure, here is an union because three
+ * Version 2 of the grant entry structure, here is a union because three
  * different types are suppotted: full_page, sub_page and transitive.
  */
 union grant_entry_v2 {
* Unmerged path scripts/spelling.txt
diff --git a/sound/pci/ice1712/wm8766.c b/sound/pci/ice1712/wm8766.c
index f7ac8d5e862c..27c03e40c9b1 100644
--- a/sound/pci/ice1712/wm8766.c
+++ b/sound/pci/ice1712/wm8766.c
@@ -254,7 +254,7 @@ static int snd_wm8766_ctl_put(struct snd_kcontrol *kcontrol,
 	int n = kcontrol->private_value;
 	u16 val, regval1, regval2;
 
-	/* this also works for enum because value is an union */
+	/* this also works for enum because value is a union */
 	regval1 = ucontrol->value.integer.value[0];
 	regval2 = ucontrol->value.integer.value[1];
 	if (wm->ctl[n].flags & WM8766_FLAG_INVERT) {
diff --git a/sound/pci/ice1712/wm8776.c b/sound/pci/ice1712/wm8776.c
index ebd2fe4b4a57..553669b103c2 100644
--- a/sound/pci/ice1712/wm8776.c
+++ b/sound/pci/ice1712/wm8776.c
@@ -528,7 +528,7 @@ static int snd_wm8776_ctl_put(struct snd_kcontrol *kcontrol,
 	int n = kcontrol->private_value;
 	u16 val, regval1, regval2;
 
-	/* this also works for enum because value is an union */
+	/* this also works for enum because value is a union */
 	regval1 = ucontrol->value.integer.value[0];
 	regval2 = ucontrol->value.integer.value[1];
 	if (wm->ctl[n].flags & WM8776_FLAG_INVERT) {
diff --git a/tools/perf/util/probe-finder.c b/tools/perf/util/probe-finder.c
index 73f6971c374d..2f78c35b826f 100644
--- a/tools/perf/util/probe-finder.c
+++ b/tools/perf/util/probe-finder.c
@@ -460,7 +460,7 @@ static int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,
 		/* Verify it is a data structure  */
 		tag = dwarf_tag(&type);
 		if (tag != DW_TAG_structure_type && tag != DW_TAG_union_type) {
-			pr_warning("%s is not a data structure nor an union.\n",
+			pr_warning("%s is not a data structure nor a union.\n",
 				   varname);
 			return -EINVAL;
 		}
@@ -475,7 +475,7 @@ static int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,
 	} else {
 		/* Verify it is a data structure  */
 		if (tag != DW_TAG_structure_type && tag != DW_TAG_union_type) {
-			pr_warning("%s is not a data structure nor an union.\n",
+			pr_warning("%s is not a data structure nor a union.\n",
 				   varname);
 			return -EINVAL;
 		}
diff --git a/tools/perf/util/sort.h b/tools/perf/util/sort.h
index 03b5966c825d..3fd5bf147579 100644
--- a/tools/perf/util/sort.h
+++ b/tools/perf/util/sort.h
@@ -109,7 +109,7 @@ struct hist_entry {
 		/*
 		 * Since perf diff only supports the stdio output, TUI
 		 * fields are only accessed from perf report (or perf
-		 * top).  So make it an union to reduce memory usage.
+		 * top).  So make it a union to reduce memory usage.
 		 */
 		struct hist_entry_diff	diff;
 		struct /* for TUI */ {
