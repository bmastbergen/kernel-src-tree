drm/i915/gvt: Adding ACTHD mmio read handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Xiong Zhang <xiong.y.zhang@intel.com>
commit 894e287b3dcc8bfc8d974f883dab3b5c66344089
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/894e287b.failed

When a workload is too heavy to finish it in gpu hang check timer
intervals(1.5), gpu hang check function will check ACTHD register
value to decide whether gpu is real dead or not. On real hw,
ACTHD is updated by HW when workload is running, then host kernel
won't think it is gpu hang. while guest kernel always read a constant
ACTHD value as GVT doesn't supply ACTHD emulate handler, then
guest kernel detects a fake gpu hang.

To remove such guest fake gpu hang, this patch supply ACTHD
mmio read handler which read real HW ACTHD register directly.

	Signed-off-by: Xiong Zhang <xiong.y.zhang@intel.com>
	Signed-off-by: Zhi Wang <zhi.a.wang@intel.com>
	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/b4c9a097-3e62-124e-6856-b0c37764df7b@intel.com
(cherry picked from commit 894e287b3dcc8bfc8d974f883dab3b5c66344089)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gvt/handlers.c
diff --cc drivers/gpu/drm/i915/gvt/handlers.c
index 4a24dc155ace,a5bed2e71b92..000000000000
--- a/drivers/gpu/drm/i915/gvt/handlers.c
+++ b/drivers/gpu/drm/i915/gvt/handlers.c
@@@ -2423,31 -2463,8 +2423,36 @@@ static int init_broadwell_mmio_info(str
  	MMIO_DH(GEN8_MASTER_IRQ, D_BDW_PLUS, NULL,
  		intel_vgpu_reg_master_irq_handler);
  
++<<<<<<< HEAD
 +	MMIO_DFH(RING_HWSTAM(GEN8_BSD2_RING_BASE), D_BDW_PLUS,
 +		F_CMD_ACCESS, NULL, NULL);
 +	MMIO_DFH(0x1c134, D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);
 +
 +	MMIO_DFH(RING_TAIL(GEN8_BSD2_RING_BASE), D_BDW_PLUS, F_CMD_ACCESS,
 +		NULL, NULL);
 +	MMIO_DFH(RING_HEAD(GEN8_BSD2_RING_BASE),  D_BDW_PLUS,
 +		F_CMD_ACCESS, NULL, NULL);
 +	MMIO_GM_RDR(RING_START(GEN8_BSD2_RING_BASE), D_BDW_PLUS, NULL, NULL);
 +	MMIO_DFH(RING_CTL(GEN8_BSD2_RING_BASE), D_BDW_PLUS, F_CMD_ACCESS,
 +		NULL, NULL);
 +	MMIO_DFH(RING_ACTHD(GEN8_BSD2_RING_BASE), D_BDW_PLUS,
 +		F_CMD_ACCESS, NULL, NULL);
 +	MMIO_DFH(RING_ACTHD_UDW(GEN8_BSD2_RING_BASE), D_BDW_PLUS,
 +		F_CMD_ACCESS, NULL, NULL);
 +	MMIO_DFH(0x1c29c, D_BDW_PLUS, F_MODE_MASK | F_CMD_ACCESS, NULL,
 +		ring_mode_mmio_write);
 +	MMIO_DFH(RING_MI_MODE(GEN8_BSD2_RING_BASE), D_BDW_PLUS,
 +		F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);
 +	MMIO_DFH(RING_INSTPM(GEN8_BSD2_RING_BASE), D_BDW_PLUS,
 +		F_MODE_MASK | F_CMD_ACCESS, NULL, NULL);
 +	MMIO_DFH(RING_TIMESTAMP(GEN8_BSD2_RING_BASE), D_BDW_PLUS, F_CMD_ACCESS,
 +			ring_timestamp_mmio_read, NULL);
 +
 +	MMIO_RING_DFH(RING_ACTHD_UDW, D_BDW_PLUS, F_CMD_ACCESS, NULL, NULL);
++=======
+ 	MMIO_RING_DFH(RING_ACTHD_UDW, D_BDW_PLUS, F_CMD_ACCESS,
+ 		mmio_read_from_hw, NULL);
++>>>>>>> 894e287b3dcc (drm/i915/gvt: Adding ACTHD mmio read handler)
  
  #define RING_REG(base) (base + 0xd0)
  	MMIO_RING_F(RING_REG, 4, F_RO, 0,
* Unmerged path drivers/gpu/drm/i915/gvt/handlers.c
