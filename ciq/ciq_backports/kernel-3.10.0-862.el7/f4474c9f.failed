x86/dumpstack: Handle NULL stack pointer in show_trace_log_lvl()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit f4474c9f0bba17857b1a47c8dc89c07a0845c2b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f4474c9f.failed

When show_trace_log_lvl() is called from show_regs(), it completely
fails to dump the stack.  This bug was introduced when
show_stack_log_lvl() was removed with the following commit:

  0ee1dd9f5e7e ("x86/dumpstack: Remove raw stack dump")

Previous callers of that function now call show_trace_log_lvl()
directly.  That resulted in a subtle change, in that the 'stack'
argument can now be NULL in certain cases.

A NULL 'stack' pointer means that the stack dump should start from the
topmost stack frame unless 'regs' is valid, in which case it should
start from 'regs->sp'.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: 0ee1dd9f5e7e ("x86/dumpstack: Remove raw stack dump")
Link: http://lkml.kernel.org/r/c551842302a9c222d96a14e42e4003f059509f69.1479362652.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f4474c9f0bba17857b1a47c8dc89c07a0845c2b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/dumpstack.c
diff --cc arch/x86/kernel/dumpstack.c
index 08594671b59f,1e057b01b648..000000000000
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@@ -29,157 -45,119 +29,162 @@@ static void printk_stack_address(unsign
  				 char *log_lvl)
  {
  	touch_nmi_watchdog();
 -	printk("%s %s%pB\n", log_lvl, reliable ? "" : "? ", (void *)address);
 +	printk("%s [<%p>] %s%pB\n",
 +		log_lvl, (void *)address, reliable ? "" : "? ",
 +		(void *)address);
  }
  
 -void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 -			unsigned long *stack, char *log_lvl)
 +void printk_address(unsigned long address)
  {
 -	struct unwind_state state;
 -	struct stack_info stack_info = {0};
 -	unsigned long visit_mask = 0;
 -	int graph_idx = 0;
 +	pr_cont(" [<%p>] %pS\n", (void *)address, (void *)address);
 +}
  
 -	printk("%sCall Trace:\n", log_lvl);
 +#ifdef CONFIG_FUNCTION_GRAPH_TRACER
 +static void
 +print_ftrace_graph_addr(unsigned long addr, void *data,
 +			const struct stacktrace_ops *ops,
 +			struct thread_info *tinfo, int *graph)
 +{
 +	struct task_struct *task;
 +	unsigned long ret_addr;
 +	int index;
  
++<<<<<<< HEAD
 +	if (addr != (unsigned long)return_to_handler)
 +		return;
++=======
+ 	unwind_start(&state, task, regs, stack);
+ 	stack = stack ? : get_stack_pointer(task, regs);
++>>>>>>> f4474c9f0bba (x86/dumpstack: Handle NULL stack pointer in show_trace_log_lvl())
  
 -	/*
 -	 * Iterate through the stacks, starting with the current stack pointer.
 -	 * Each stack has a pointer to the next one.
 -	 *
 -	 * x86-64 can have several stacks:
 -	 * - task stack
 -	 * - interrupt stack
 -	 * - HW exception stacks (double fault, nmi, debug, mce)
 -	 *
 -	 * x86-32 can have up to three stacks:
 -	 * - task stack
 -	 * - softirq stack
 -	 * - hardirq stack
 -	 */
 -	for (regs = NULL; stack; stack = stack_info.next_sp) {
 -		const char *str_begin, *str_end;
 +	task = tinfo->task;
 +	index = task->curr_ret_stack;
  
 -		/*
 -		 * If we overflowed the task stack into a guard page, jump back
 -		 * to the bottom of the usable stack.
 -		 */
 -		if (task_stack_page(task) - (void *)stack < PAGE_SIZE)
 -			stack = task_stack_page(task);
 +	if (!task->ret_stack || index < *graph)
 +		return;
  
 -		if (get_stack_info(stack, task, &stack_info, &visit_mask))
 -			break;
 +	index -= *graph;
 +	ret_addr = task->ret_stack[index].ret;
  
 -		stack_type_str(stack_info.type, &str_begin, &str_end);
 -		if (str_begin)
 -			printk("%s <%s>\n", log_lvl, str_begin);
 -
 -		/*
 -		 * Scan the stack, printing any text addresses we find.  At the
 -		 * same time, follow proper stack frames with the unwinder.
 -		 *
 -		 * Addresses found during the scan which are not reported by
 -		 * the unwinder are considered to be additional clues which are
 -		 * sometimes useful for debugging and are prefixed with '?'.
 -		 * This also serves as a failsafe option in case the unwinder
 -		 * goes off in the weeds.
 -		 */
 -		for (; stack < stack_info.end; stack++) {
 -			unsigned long real_addr;
 -			int reliable = 0;
 -			unsigned long addr = *stack;
 -			unsigned long *ret_addr_p =
 -				unwind_get_return_address_ptr(&state);
 -
 -			if (!__kernel_text_address(addr))
 -				continue;
 -
 -			/*
 -			 * Don't print regs->ip again if it was already printed
 -			 * by __show_regs() below.
 -			 */
 -			if (regs && stack == &regs->ip) {
 -				unwind_next_frame(&state);
 -				continue;
 -			}
 +	ops->address(data, ret_addr, 1);
  
 -			if (stack == ret_addr_p)
 -				reliable = 1;
 -
 -			/*
 -			 * When function graph tracing is enabled for a
 -			 * function, its return address on the stack is
 -			 * replaced with the address of an ftrace handler
 -			 * (return_to_handler).  In that case, before printing
 -			 * the "real" address, we want to print the handler
 -			 * address as an "unreliable" hint that function graph
 -			 * tracing was involved.
 -			 */
 -			real_addr = ftrace_graph_ret_addr(task, &graph_idx,
 -							  addr, stack);
 -			if (real_addr != addr)
 -				printk_stack_address(addr, 0, log_lvl);
 -			printk_stack_address(real_addr, reliable, log_lvl);
 -
 -			if (!reliable)
 -				continue;
 -
 -			/*
 -			 * Get the next frame from the unwinder.  No need to
 -			 * check for an error: if anything goes wrong, the rest
 -			 * of the addresses will just be printed as unreliable.
 -			 */
 -			unwind_next_frame(&state);
 -
 -			/* if the frame has entry regs, print them */
 -			regs = unwind_get_entry_regs(&state);
 -			if (regs)
 -				__show_regs(regs, 0);
 +	(*graph)++;
 +}
 +#else
 +static inline void
 +print_ftrace_graph_addr(unsigned long addr, void *data,
 +			const struct stacktrace_ops *ops,
 +			struct thread_info *tinfo, int *graph)
 +{ }
 +#endif
 +
 +/*
 + * x86-64 can have up to three kernel stacks:
 + * process stack
 + * interrupt stack
 + * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
 + */
 +
 +static inline int valid_stack_ptr(struct thread_info *tinfo,
 +			void *p, unsigned int size, void *end)
 +{
 +	void *t = tinfo;
 +	if (end) {
 +		if (p < end && p >= (end-THREAD_SIZE))
 +			return 1;
 +		else
 +			return 0;
 +	}
 +	return p > t && p < t + THREAD_SIZE - size;
 +}
 +
 +unsigned long
 +print_context_stack(struct thread_info *tinfo,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data,
 +		unsigned long *end, int *graph)
 +{
 +	struct stack_frame *frame = (struct stack_frame *)bp;
 +
 +	while (valid_stack_ptr(tinfo, stack, sizeof(*stack), end)) {
 +		unsigned long addr;
 +
 +		addr = *stack;
 +		if (__kernel_text_address(addr)) {
 +			if ((unsigned long) stack == bp + sizeof(long)) {
 +				ops->address(data, addr, 1);
 +				frame = frame->next_frame;
 +				bp = (unsigned long) frame;
 +			} else {
 +				ops->address(data, addr, 0);
 +			}
 +			print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
  		}
 +		stack++;
 +	}
 +	return bp;
 +}
 +EXPORT_SYMBOL_GPL(print_context_stack);
 +
 +unsigned long
 +print_context_stack_bp(struct thread_info *tinfo,
 +		       unsigned long *stack, unsigned long bp,
 +		       const struct stacktrace_ops *ops, void *data,
 +		       unsigned long *end, int *graph)
 +{
 +	struct stack_frame *frame = (struct stack_frame *)bp;
 +	unsigned long *ret_addr = &frame->return_address;
 +
 +	while (valid_stack_ptr(tinfo, ret_addr, sizeof(*ret_addr), end)) {
 +		unsigned long addr = *ret_addr;
 +
 +		if (!__kernel_text_address(addr))
 +			break;
  
 -		if (str_end)
 -			printk("%s <%s>\n", log_lvl, str_end);
 +		if (ops->address(data, addr, 1))
 +			break;
 +		frame = frame->next_frame;
 +		ret_addr = &frame->return_address;
 +		print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
  	}
 +
 +	return (unsigned long)frame;
 +}
 +EXPORT_SYMBOL_GPL(print_context_stack_bp);
 +
 +static int print_trace_stack(void *data, char *name)
 +{
 +	printk("%s <%s> ", (char *)data, name);
 +	return 0;
 +}
 +
 +/*
 + * Print one address/symbol entries per line.
 + */
 +static int print_trace_address(void *data, unsigned long addr, int reliable)
 +{
 +	printk_stack_address(addr, reliable, data);
 +	return 0;
 +}
 +
 +static const struct stacktrace_ops print_trace_ops = {
 +	.stack			= print_trace_stack,
 +	.address		= print_trace_address,
 +	.walk_stack		= print_context_stack,
 +};
 +
 +void
 +show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp, char *log_lvl)
 +{
 +	printk("%sCall Trace:\n", log_lvl);
 +	dump_trace(task, regs, stack, bp, &print_trace_ops, log_lvl);
 +}
 +
 +void show_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp)
 +{
 +	show_trace_log_lvl(task, regs, stack, bp, "");
  }
  
  void show_stack(struct task_struct *task, unsigned long *sp)
* Unmerged path arch/x86/kernel/dumpstack.c
