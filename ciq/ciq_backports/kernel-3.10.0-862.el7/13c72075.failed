ovl: move impure to ovl_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 13c72075ac9f5a5cf3f61c85adaafffe48a6f797
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/13c72075.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 13c72075ac9f5a5cf3f61c85adaafffe48a6f797)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/inode.c
index e60c6d748742,23d64d51f331..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -436,18 -463,39 +436,33 @@@ static int ovl_inode_set(struct inode *
  	return 0;
  }
  
 -struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry)
 +struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode)
 +
  {
 -	struct dentry *lowerdentry = ovl_dentry_lower(dentry);
 -	struct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;
  	struct inode *inode;
  
 -	if (!realinode)
 -		realinode = d_inode(lowerdentry);
 -
 -	if (upperdentry && !d_is_dir(upperdentry)) {
 -		inode = iget5_locked(dentry->d_sb, (unsigned long) realinode,
 -				     ovl_inode_test, ovl_inode_set, realinode);
 -		if (!inode)
 -			goto out;
 -		if (!(inode->i_state & I_NEW)) {
 -			dput(upperdentry);
 -			goto out;
 -		}
 -
 +	inode = iget5_locked(sb, (unsigned long) realinode,
 +			     ovl_inode_test, ovl_inode_set, realinode);
 +	if (inode && inode->i_state & I_NEW) {
 +		ovl_fill_inode(inode, realinode->i_mode);
  		set_nlink(inode, realinode->i_nlink);
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		inode = new_inode(dentry->d_sb);
+ 		if (!inode)
+ 			goto out;
+ 	}
+ 	ovl_fill_inode(inode, realinode->i_mode, realinode->i_rdev);
+ 	ovl_inode_init(inode, upperdentry, lowerdentry);
+ 
+ 	if (upperdentry && ovl_is_impuredir(upperdentry))
+ 		ovl_set_flag(OVL_IMPURE, inode);
+ 
+ 	if (inode->i_state & I_NEW)
++>>>>>>> 13c72075ac9f (ovl: move impure to ovl_inode)
  		unlock_new_inode(inode);
 -out:
 +	}
 +
  	return inode;
  }
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,b1be3d39ac9d..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -24,8 -22,47 +24,48 @@@ enum ovl_path_type 
  
  #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
  #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
 -#define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
 -#define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
 -#define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
  
++<<<<<<< HEAD
 +#define OVL_ISUPPER_MASK 1UL
++=======
+ enum ovl_flag {
+ 	OVL_IMPURE,
+ };
+ 
+ /*
+  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
+  * where:
+  * origin.fh	- exported file handle of the lower file
+  * origin.uuid	- uuid of the lower filesystem
+  */
+ #define OVL_FH_VERSION	0
+ #define OVL_FH_MAGIC	0xfb
+ 
+ /* CPU byte order required for fid decoding:  */
+ #define OVL_FH_FLAG_BIG_ENDIAN	(1 << 0)
+ #define OVL_FH_FLAG_ANY_ENDIAN	(1 << 1)
+ 
+ #define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
+ 
+ #if defined(__LITTLE_ENDIAN)
+ #define OVL_FH_FLAG_CPU_ENDIAN 0
+ #elif defined(__BIG_ENDIAN)
+ #define OVL_FH_FLAG_CPU_ENDIAN OVL_FH_FLAG_BIG_ENDIAN
+ #else
+ #error Endianness not defined
+ #endif
+ 
+ /* On-disk and in-memeory format for redirect by file handle */
+ struct ovl_fh {
+ 	u8 version;	/* 0 */
+ 	u8 magic;	/* 0xfb */
+ 	u8 len;		/* size of this header + size of fid */
+ 	u8 flags;	/* OVL_FH_FLAG_* */
+ 	u8 type;	/* fid_type of fid */
+ 	uuid_t uuid;	/* uuid of filesystem */
+ 	u8 fid[0];	/* file identifier */
+ } __packed;
++>>>>>>> 13c72075ac9f (ovl: move impure to ovl_inode)
  
  static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
  {
@@@ -151,27 -193,44 +191,61 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 -struct inode *ovl_inode_upper(struct inode *inode);
 -struct inode *ovl_inode_lower(struct inode *inode);
 -struct inode *ovl_inode_real(struct inode *inode);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+ 		    struct dentry *lowerdentry);
+ void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+ 		       const char *name, const void *value, size_t size,
+ 		       int xerr);
+ int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_set_flag(unsigned long flag, struct inode *inode);
+ bool ovl_test_flag(unsigned long flag, struct inode *inode);
+ 
+ static inline bool ovl_is_impuredir(struct dentry *dentry)
+ {
+ 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+ }
+ 
+ 
+ /* namei.c */
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> 13c72075ac9f (ovl: move impure to ovl_inode)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
diff --cc fs/overlayfs/super.c
index aaf06952d88f,7c7b946b063f..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -415,282 -156,42 +415,289 @@@ static const struct dentry_operations_w
  	.d_real = ovl_d_real,
  };
  
 -static const struct dentry_operations ovl_reval_dentry_operations = {
 -	.d_release = ovl_dentry_release,
 +static const struct dentry_operations_wrapper ovl_reval_dentry_operations = {
 +	.ops = {
 +		.d_release = ovl_dentry_release,
 +		.d_revalidate = ovl_dentry_revalidate,
 +		.d_weak_revalidate = ovl_dentry_weak_revalidate,
 +	},
 +	.size = sizeof(struct dentry_operations_wrapper),
  	.d_real = ovl_d_real,
 -	.d_revalidate = ovl_dentry_revalidate,
 -	.d_weak_revalidate = ovl_dentry_weak_revalidate,
  };
  
 -static struct kmem_cache *ovl_inode_cachep;
 -
 -static struct inode *ovl_alloc_inode(struct super_block *sb)
 +static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)
  {
 -	struct ovl_inode *oi = kmem_cache_alloc(ovl_inode_cachep, GFP_KERNEL);
 +	size_t size = offsetof(struct ovl_entry, lowerstack[numlower]);
 +	struct ovl_entry *oe = kzalloc(size, GFP_KERNEL);
  
++<<<<<<< HEAD
 +	if (oe)
 +		oe->numlower = numlower;
++=======
+ 	oi->redirect = NULL;
+ 	oi->flags = 0;
+ 	oi->__upperdentry = NULL;
+ 	oi->lower = NULL;
++>>>>>>> 13c72075ac9f (ovl: move impure to ovl_inode)
 +
 +	return oe;
 +}
 +
 +static bool ovl_dentry_remote(struct dentry *dentry)
 +{
 +	return dentry->d_flags &
 +		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE |
 +		 DCACHE_OP_REAL);
 +}
 +
 +static bool ovl_dentry_weird(struct dentry *dentry)
 +{
 +	return dentry->d_flags & (DCACHE_NEED_AUTOMOUNT |
 +				  DCACHE_MANAGE_TRANSIT |
 +				  DCACHE_OP_HASH |
 +				  DCACHE_OP_COMPARE);
 +}
  
 -	return &oi->vfs_inode;
 +static inline struct dentry *ovl_lookup_real(struct dentry *dir,
 +					     const struct qstr *name)
 +{
 +	struct dentry *dentry;
 +
 +	dentry = lookup_one_len_unlocked(name->name, dir, name->len);
 +	if (IS_ERR(dentry)) {
 +		if (PTR_ERR(dentry) == -ENOENT)
 +			dentry = NULL;
 +	} else if (!dentry->d_inode) {
 +		dput(dentry);
 +		dentry = NULL;
 +	} else if (ovl_dentry_weird(dentry)) {
 +		dput(dentry);
 +		/* Don't support traversing automounts and other weirdness */
 +		dentry = ERR_PTR(-EREMOTE);
 +	}
 +	return dentry;
  }
  
 -static void ovl_i_callback(struct rcu_head *head)
 +/*
 + * Returns next layer in stack starting from top.
 + * Returns -1 if this is the last layer.
 + */
 +int ovl_path_next(int idx, struct dentry *dentry, struct path *path)
  {
 -	struct inode *inode = container_of(head, struct inode, i_rcu);
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	BUG_ON(idx < 0);
 +	if (idx == 0) {
 +		ovl_path_upper(dentry, path);
 +		if (path->dentry)
 +			return oe->numlower ? 1 : -1;
 +		idx++;
 +	}
 +	BUG_ON(idx > oe->numlower);
 +	*path = oe->lowerstack[idx - 1];
 +
 +	return (idx < oe->numlower) ? idx + 1 : -1;
 +}
 +
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags)
 +{
 +	struct ovl_entry *oe;
 +	const struct cred *old_cred;
 +	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 +	struct path *stack = NULL;
 +	struct dentry *upperdir, *upperdentry = NULL;
 +	unsigned int ctr = 0;
 +	struct inode *inode = NULL;
 +	bool upperopaque = false;
 +	bool stop = false;
 +	bool isdir = false;
 +	struct dentry *this;
 +	unsigned int i;
 +	int err;
 +
 +	old_cred = ovl_override_creds(dentry->d_sb);
 +	upperdir = ovl_upperdentry_dereference(poe);
 +	if (upperdir) {
 +		this = ovl_lookup_real(upperdir, &dentry->d_name);
 +		err = PTR_ERR(this);
 +		if (IS_ERR(this))
 +			goto out;
 +
 +		if (this) {
 +			if (unlikely(ovl_dentry_remote(this))) {
 +				dput(this);
 +				err = -EREMOTE;
 +				goto out;
 +			}
 +			if (ovl_is_whiteout(this)) {
 +				dput(this);
 +				this = NULL;
 +				stop = upperopaque = true;
 +			} else if (!d_is_dir(this)) {
 +				stop = true;
 +			} else {
 +				isdir = true;
 +				if (poe->numlower && ovl_is_opaquedir(this))
 +					stop = upperopaque = true;
 +			}
 +		}
 +		upperdentry = this;
 +	}
 +
 +	if (!stop && poe->numlower) {
 +		err = -ENOMEM;
 +		stack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);
 +		if (!stack)
 +			goto out_put_upper;
 +	}
 +
 +	for (i = 0; !stop && i < poe->numlower; i++) {
 +		struct path lowerpath = poe->lowerstack[i];
 +
 +		this = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);
 +		err = PTR_ERR(this);
 +		if (IS_ERR(this)) {
 +			/*
 +			 * If it's positive, then treat ENAMETOOLONG as ENOENT.
 +			 */
 +			if (err == -ENAMETOOLONG && (upperdentry || ctr))
 +				continue;
 +			goto out_put;
 +		}
 +		if (!this)
 +			continue;
 +		if (ovl_is_whiteout(this)) {
 +			dput(this);
 +			break;
 +		}
 +		/*
 +		 * If this is a non-directory then stop here.
 +		 */
 +		if (!d_is_dir(this)) {
 +			if (isdir) {
 +				dput(this);
 +				break;
 +			}
 +			stop = true;
 +		} else {
 +			/*
 +			 * Only makes sense to check opaque dir if this is not
 +			 * the lowermost layer.
 +			 */
 +			if (i < poe->numlower - 1 && ovl_is_opaquedir(this))
 +				stop = true;
 +		}
 +
 +		stack[ctr].dentry = this;
 +		stack[ctr].mnt = lowerpath.mnt;
 +		ctr++;
 +	}
 +
 +	oe = ovl_alloc_entry(ctr);
 +	err = -ENOMEM;
 +	if (!oe)
 +		goto out_put;
 +
 +	if (upperdentry || ctr) {
 +		struct dentry *realdentry;
 +		struct inode *realinode;
 +
 +		realdentry = upperdentry ? upperdentry : stack[0].dentry;
 +		realinode = d_inode(realdentry);
 +
 +		err = -ENOMEM;
 +		if (upperdentry && !d_is_dir(upperdentry)) {
 +			inode = ovl_get_inode(dentry->d_sb, realinode);
 +		} else {
 +			inode = ovl_new_inode(dentry->d_sb, realinode->i_mode);
 +			if (inode)
 +				ovl_inode_init(inode, realinode, !!upperdentry);
 +		}
 +		if (!inode)
 +			goto out_free_oe;
 +		ovl_copyattr(realdentry->d_inode, inode);
 +	}
 +
 +	revert_creds(old_cred);
 +	oe->opaque = upperopaque;
 +	oe->__upperdentry = upperdentry;
 +	memcpy(oe->lowerstack, stack, sizeof(struct path) * ctr);
 +	kfree(stack);
 +	dentry->d_fsdata = oe;
 +	d_add(dentry, inode);
  
 -	kmem_cache_free(ovl_inode_cachep, OVL_I(inode));
 +	return NULL;
 +
 +out_free_oe:
 +	kfree(oe);
 +out_put:
 +	for (i = 0; i < ctr; i++)
 +		dput(stack[i].dentry);
 +	kfree(stack);
 +out_put_upper:
 +	dput(upperdentry);
 +out:
 +	revert_creds(old_cred);
 +	return ERR_PTR(err);
  }
  
 -static void ovl_destroy_inode(struct inode *inode)
 +bool ovl_lower_positive(struct dentry *dentry)
  {
 -	struct ovl_inode *oi = OVL_I(inode);
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 +	const struct qstr *name = &dentry->d_name;
 +	unsigned int i;
 +	bool positive = false;
 +	bool done = false;
 +
 +	/*
 +	 * If dentry is negative, then lower is positive iff this is a
 +	 * whiteout.
 +	 */
 +	if (!dentry->d_inode)
 +		return oe->opaque;
 +
 +	/* Negative upper -> positive lower */
 +	if (!oe->__upperdentry)
 +		return true;
 +
 +	/* Positive upper -> have to look up lower to see whether it exists */
 +	for (i = 0; !done && !positive && i < poe->numlower; i++) {
 +		struct dentry *this;
 +		struct dentry *lowerdir = poe->lowerstack[i].dentry;
 +
 +		this = lookup_one_len_unlocked(name->name, lowerdir,
 +					       name->len);
 +		if (IS_ERR(this)) {
 +			switch (PTR_ERR(this)) {
 +			case -ENOENT:
 +			case -ENAMETOOLONG:
 +				break;
 +
 +			default:
 +				/*
 +				 * Assume something is there, we just couldn't
 +				 * access it.
 +				 */
 +				positive = true;
 +				break;
 +			}
 +		} else {
 +			if (this->d_inode) {
 +				positive = !ovl_is_whiteout(this);
 +				done = true;
 +			}
 +			dput(this);
 +		}
 +	}
  
 -	dput(oi->__upperdentry);
 -	kfree(oi->redirect);
 +	return positive;
 +}
  
 -	call_rcu(&inode->i_rcu, ovl_i_callback);
 +struct file *ovl_path_open(struct path *path, int flags)
 +{
 +	return dentry_open(path, flags | O_NOATIME, current_cred());
  }
  
  static void ovl_put_super(struct super_block *sb)
@@@ -1468,7 -1004,10 +1475,14 @@@ static int ovl_fill_super(struct super_
  	path_put(&workpath);
  	kfree(lowertmp);
  
++<<<<<<< HEAD
 +	oe->__upperdentry = upperpath.dentry;
++=======
+ 	if (upperpath.dentry) {
+ 		if (ovl_is_impuredir(upperpath.dentry))
+ 			ovl_set_flag(OVL_IMPURE, d_inode(root_dentry));
+ 	}
++>>>>>>> 13c72075ac9f (ovl: move impure to ovl_inode)
  	for (i = 0; i < numlower; i++) {
  		oe->lowerstack[i].dentry = stack[i].dentry;
  		oe->lowerstack[i].mnt = ufs->lower_mnt[i];
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
* Unmerged path fs/overlayfs/util.c
