ovl: do not cleanup directory and whiteout index entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 61b674710cd9afa2a8b17bdd1ac80670c9b79f1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/61b67471.failed

Directory index entries are going to be used for looking up
redirected upper dirs by lower dir fh when decoding an overlay
file handle of a merge dir.

Whiteout index entries are going to be used as an indication that
an exported overlay file handle should be treated as stale (i.e.
after unlink of the overlay inode).

We don't know the verification rules for directory and whiteout
index entries, because they have not been implemented yet, so fail
to mount overlay rw if those entries are found to avoid corrupting
an index that was created by a newer kernel.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 61b674710cd9afa2a8b17bdd1ac80670c9b79f1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/namei.c
#	fs/overlayfs/readdir.c
diff --cc fs/overlayfs/readdir.c
index 2010cf9bd904,3d424a51cabb..000000000000
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@@ -678,3 -667,56 +678,59 @@@ void ovl_workdir_cleanup(struct inode *
  		ovl_cleanup(dir, dentry);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
+ 			 struct path *lowerstack, unsigned int numlower)
+ {
+ 	int err;
+ 	struct inode *dir = dentry->d_inode;
+ 	struct path path = { .mnt = mnt, .dentry = dentry };
+ 	LIST_HEAD(list);
+ 	struct ovl_cache_entry *p;
+ 	struct ovl_readdir_data rdd = {
+ 		.ctx.actor = ovl_fill_merge,
+ 		.dentry = NULL,
+ 		.list = &list,
+ 		.root = RB_ROOT,
+ 		.is_lowest = false,
+ 	};
+ 
+ 	err = ovl_dir_read(&path, &rdd);
+ 	if (err)
+ 		goto out;
+ 
+ 	inode_lock_nested(dir, I_MUTEX_PARENT);
+ 	list_for_each_entry(p, &list, l_node) {
+ 		struct dentry *index;
+ 
+ 		if (p->name[0] == '.') {
+ 			if (p->len == 1)
+ 				continue;
+ 			if (p->len == 2 && p->name[1] == '.')
+ 				continue;
+ 		}
+ 		index = lookup_one_len(p->name, dentry, p->len);
+ 		if (IS_ERR(index)) {
+ 			err = PTR_ERR(index);
+ 			break;
+ 		}
+ 		err = ovl_verify_index(index, lowerstack, numlower);
+ 		if (err) {
+ 			if (err == -EROFS)
+ 				break;
+ 			err = ovl_cleanup(dir, index);
+ 			if (err)
+ 				break;
+ 		}
+ 		dput(index);
+ 	}
+ 	inode_unlock(dir);
+ out:
+ 	ovl_cache_free(&list);
+ 	if (err)
+ 		pr_err("overlayfs: failed index dir cleanup (%i)\n", err);
+ 	return err;
+ }
++>>>>>>> 61b674710cd9 (ovl: do not cleanup directory and whiteout index entries)
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/readdir.c
