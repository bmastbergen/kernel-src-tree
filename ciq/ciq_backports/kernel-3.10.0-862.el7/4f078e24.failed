scsi: smartpqi: cleanup doorbell register usage.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] smartpqi: cleanup doorbell register usage (Don Brace) [1457414]
Rebuild_FUZZ: 92.13%
commit-author Kevin Barnett <kevin.barnett@microsemi.com>
commit 4f078e24080626764896055d857719cd886e6321
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4f078e24.failed

	Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4f078e24080626764896055d857719cd886e6321)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi_init.c
#	drivers/scsi/smartpqi/smartpqi_sis.c
#	drivers/scsi/smartpqi/smartpqi_sis.h
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index 63928022276c,70b1f97daee8..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -2997,6 -2977,102 +2997,105 @@@ static unsigned int pqi_process_event_i
  	return num_events;
  }
  
++<<<<<<< HEAD
++=======
+ #define PQI_LEGACY_INTX_MASK	0x1
+ 
+ static inline void pqi_configure_legacy_intx(struct pqi_ctrl_info *ctrl_info,
+ 						bool enable_intx)
+ {
+ 	u32 intx_mask;
+ 	struct pqi_device_registers __iomem *pqi_registers;
+ 	volatile void __iomem *register_addr;
+ 
+ 	pqi_registers = ctrl_info->pqi_registers;
+ 
+ 	if (enable_intx)
+ 		register_addr = &pqi_registers->legacy_intx_mask_clear;
+ 	else
+ 		register_addr = &pqi_registers->legacy_intx_mask_set;
+ 
+ 	intx_mask = readl(register_addr);
+ 	intx_mask |= PQI_LEGACY_INTX_MASK;
+ 	writel(intx_mask, register_addr);
+ }
+ 
+ static void pqi_change_irq_mode(struct pqi_ctrl_info *ctrl_info,
+ 	enum pqi_irq_mode new_mode)
+ {
+ 	switch (ctrl_info->irq_mode) {
+ 	case IRQ_MODE_MSIX:
+ 		switch (new_mode) {
+ 		case IRQ_MODE_MSIX:
+ 			break;
+ 		case IRQ_MODE_INTX:
+ 			pqi_configure_legacy_intx(ctrl_info, true);
+ 			sis_enable_intx(ctrl_info);
+ 			break;
+ 		case IRQ_MODE_NONE:
+ 			break;
+ 		}
+ 		break;
+ 	case IRQ_MODE_INTX:
+ 		switch (new_mode) {
+ 		case IRQ_MODE_MSIX:
+ 			pqi_configure_legacy_intx(ctrl_info, false);
+ 			sis_enable_msix(ctrl_info);
+ 			break;
+ 		case IRQ_MODE_INTX:
+ 			break;
+ 		case IRQ_MODE_NONE:
+ 			pqi_configure_legacy_intx(ctrl_info, false);
+ 			break;
+ 		}
+ 		break;
+ 	case IRQ_MODE_NONE:
+ 		switch (new_mode) {
+ 		case IRQ_MODE_MSIX:
+ 			sis_enable_msix(ctrl_info);
+ 			break;
+ 		case IRQ_MODE_INTX:
+ 			pqi_configure_legacy_intx(ctrl_info, true);
+ 			sis_enable_intx(ctrl_info);
+ 			break;
+ 		case IRQ_MODE_NONE:
+ 			break;
+ 		}
+ 		break;
+ 	}
+ 
+ 	ctrl_info->irq_mode = new_mode;
+ }
+ 
+ #define PQI_LEGACY_INTX_PENDING		0x1
+ 
+ static inline bool pqi_is_valid_irq(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	bool valid_irq;
+ 	u32 intx_status;
+ 
+ 	switch (ctrl_info->irq_mode) {
+ 	case IRQ_MODE_MSIX:
+ 		valid_irq = true;
+ 		break;
+ 	case IRQ_MODE_INTX:
+ 		intx_status =
+ 			readl(&ctrl_info->pqi_registers->legacy_intx_status);
+ 		if (intx_status & PQI_LEGACY_INTX_PENDING)
+ 			valid_irq = true;
+ 		else
+ 			valid_irq = false;
+ 		break;
+ 	case IRQ_MODE_NONE:
+ 	default:
+ 		valid_irq = false;
+ 		break;
+ 	}
+ 
+ 	return valid_irq;
+ }
+ 
++>>>>>>> 4f078e240806 (scsi: smartpqi: cleanup doorbell register usage.)
  static irqreturn_t pqi_irq_handler(int irq, void *data)
  {
  	struct pqi_ctrl_info *ctrl_info;
diff --cc drivers/scsi/smartpqi/smartpqi_sis.c
index 6ebeb141fe44,5141bd4c9f06..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_sis.c
+++ b/drivers/scsi/smartpqi/smartpqi_sis.c
@@@ -33,11 -33,14 +33,20 @@@
  /* for submission of legacy SIS commands */
  #define SIS_REENABLE_SIS_MODE			0x1
  #define SIS_ENABLE_MSIX				0x40
++<<<<<<< HEAD
 +#define SIS_SOFT_RESET				0x100
 +#define SIS_TRIGGER_SHUTDOWN			0x800000
 +#define SIS_CMD_READY				0x200
++=======
+ #define SIS_ENABLE_INTX				0x80
+ #define SIS_CMD_READY				0x200
+ #define SIS_TRIGGER_SHUTDOWN			0x800000
+ #define SIS_PQI_RESET_QUIESCE			0x1000000
+ 
++>>>>>>> 4f078e240806 (scsi: smartpqi: cleanup doorbell register usage.)
  #define SIS_CMD_COMPLETE			0x1000
  #define SIS_CLEAR_CTRL_TO_HOST_DOORBELL		0x1000
+ 
  #define SIS_CMD_STATUS_SUCCESS			0x1
  #define SIS_CMD_COMPLETE_TIMEOUT_SECS		30
  #define SIS_CMD_COMPLETE_POLL_INTERVAL_MSECS	10
@@@ -318,68 -340,31 +327,65 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +/* Enable MSI-X interrupts on the controller. */
 +
 +void sis_enable_msix(struct pqi_ctrl_info *ctrl_info)
 +{
 +	u32 doorbell_register;
 +
 +	doorbell_register =
 +		readl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);
 +	doorbell_register |= SIS_ENABLE_MSIX;
 +
 +	writel(doorbell_register,
 +		&ctrl_info->registers->sis_host_to_ctrl_doorbell);
 +}
 +
 +/* Disable MSI-X interrupts on the controller. */
 +
 +void sis_disable_msix(struct pqi_ctrl_info *ctrl_info)
 +{
 +	u32 doorbell_register;
 +
 +	doorbell_register =
 +		readl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);
 +	doorbell_register &= ~SIS_ENABLE_MSIX;
 +
 +	writel(doorbell_register,
 +		&ctrl_info->registers->sis_host_to_ctrl_doorbell);
 +}
 +
 +void sis_soft_reset(struct pqi_ctrl_info *ctrl_info)
 +{
 +	writel(SIS_SOFT_RESET,
 +		&ctrl_info->registers->sis_host_to_ctrl_doorbell);
- }
- 
- void sis_shutdown_ctrl(struct pqi_ctrl_info *ctrl_info)
- {
- 	writel(SIS_TRIGGER_SHUTDOWN,
- 		&ctrl_info->registers->sis_host_to_ctrl_doorbell);
- }
++=======
+ #define SIS_DOORBELL_BIT_CLEAR_TIMEOUT_SECS	30
  
- #define SIS_MODE_READY_TIMEOUT_SECS	30
- 
- int sis_reenable_sis_mode(struct pqi_ctrl_info *ctrl_info)
+ static int sis_wait_for_doorbell_bit_to_clear(
+ 	struct pqi_ctrl_info *ctrl_info, u32 bit)
  {
- 	int rc;
+ 	int rc = 0;
+ 	u32 doorbell_register;
  	unsigned long timeout;
- 	struct pqi_ctrl_registers __iomem *registers;
- 	u32 doorbell;
- 
- 	registers = ctrl_info->registers;
- 
- 	writel(SIS_REENABLE_SIS_MODE,
- 		&registers->sis_host_to_ctrl_doorbell);
  
- 	rc = 0;
- 	timeout = (SIS_MODE_READY_TIMEOUT_SECS * HZ) + jiffies;
+ 	timeout = (SIS_DOORBELL_BIT_CLEAR_TIMEOUT_SECS * HZ) + jiffies;
  
  	while (1) {
- 		doorbell = readl(&registers->sis_ctrl_to_host_doorbell);
- 		if ((doorbell & SIS_REENABLE_SIS_MODE) == 0)
+ 		doorbell_register =
+ 			readl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);
+ 		if ((doorbell_register & bit) == 0)
+ 			break;
+ 		if (readl(&ctrl_info->registers->sis_firmware_status) &
+ 			SIS_CTRL_KERNEL_PANIC) {
+ 			rc = -ENODEV;
  			break;
+ 		}
  		if (time_after(jiffies, timeout)) {
+ 			dev_err(&ctrl_info->pci_dev->dev,
+ 				"doorbell register bit 0x%x not cleared\n",
+ 				bit);
  			rc = -ETIMEDOUT;
  			break;
  		}
@@@ -388,10 -374,43 +395,44 @@@
  	return rc;
  }
  
+ static inline int sis_set_doorbell_bit(struct pqi_ctrl_info *ctrl_info, u32 bit)
+ {
+ 	writel(bit, &ctrl_info->registers->sis_host_to_ctrl_doorbell);
+ 
+ 	return sis_wait_for_doorbell_bit_to_clear(ctrl_info, bit);
+ }
+ 
+ void sis_enable_msix(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	sis_set_doorbell_bit(ctrl_info, SIS_ENABLE_MSIX);
+ }
+ 
+ void sis_enable_intx(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	sis_set_doorbell_bit(ctrl_info, SIS_ENABLE_INTX);
++>>>>>>> 4f078e240806 (scsi: smartpqi: cleanup doorbell register usage.)
+ }
+ 
+ void sis_shutdown_ctrl(struct pqi_ctrl_info *ctrl_info)
+ {
 -	if (readl(&ctrl_info->registers->sis_firmware_status) &
 -		SIS_CTRL_KERNEL_PANIC)
 -		return;
 -
+ 	writel(SIS_TRIGGER_SHUTDOWN,
+ 		&ctrl_info->registers->sis_host_to_ctrl_doorbell);
+ }
+ 
++<<<<<<< HEAD
++#define SIS_MODE_READY_TIMEOUT_SECS	30
++=======
+ int sis_pqi_reset_quiesce(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	return sis_set_doorbell_bit(ctrl_info, SIS_PQI_RESET_QUIESCE);
+ }
++>>>>>>> 4f078e240806 (scsi: smartpqi: cleanup doorbell register usage.)
+ 
+ int sis_reenable_sis_mode(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	return sis_set_doorbell_bit(ctrl_info, SIS_REENABLE_SIS_MODE);
+ }
+ 
  void sis_write_driver_scratch(struct pqi_ctrl_info *ctrl_info, u32 value)
  {
  	writel(value, &ctrl_info->registers->sis_driver_scratch);
diff --cc drivers/scsi/smartpqi/smartpqi_sis.h
index 157768d939a9,2bf889dbf5ab..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_sis.h
+++ b/drivers/scsi/smartpqi/smartpqi_sis.h
@@@ -26,9 -27,9 +26,13 @@@ int sis_get_ctrl_properties(struct pqi_
  int sis_get_pqi_capabilities(struct pqi_ctrl_info *ctrl_info);
  int sis_init_base_struct_addr(struct pqi_ctrl_info *ctrl_info);
  void sis_enable_msix(struct pqi_ctrl_info *ctrl_info);
++<<<<<<< HEAD
 +void sis_disable_msix(struct pqi_ctrl_info *ctrl_info);
 +void sis_soft_reset(struct pqi_ctrl_info *ctrl_info);
++=======
+ void sis_enable_intx(struct pqi_ctrl_info *ctrl_info);
++>>>>>>> 4f078e240806 (scsi: smartpqi: cleanup doorbell register usage.)
  void sis_shutdown_ctrl(struct pqi_ctrl_info *ctrl_info);
 -int sis_pqi_reset_quiesce(struct pqi_ctrl_info *ctrl_info);
  int sis_reenable_sis_mode(struct pqi_ctrl_info *ctrl_info);
  void sis_write_driver_scratch(struct pqi_ctrl_info *ctrl_info, u32 value);
  u32 sis_read_driver_scratch(struct pqi_ctrl_info *ctrl_info);
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
* Unmerged path drivers/scsi/smartpqi/smartpqi_sis.c
* Unmerged path drivers/scsi/smartpqi/smartpqi_sis.h
