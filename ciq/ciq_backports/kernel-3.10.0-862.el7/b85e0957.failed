scsi: qla2xxx: Add timeout ability to wait_for_sess_deletion().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add timeout ability to wait_for_sess_deletion() (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 94.12%
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit b85e0957b8a81003511e4b950ec6e6d2e7fc830d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b85e0957.failed

	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b85e0957b8a81003511e4b950ec6e6d2e7fc830d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index f37094562f4a,c217cec4dd49..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -1020,6 -1116,34 +1020,37 @@@ qla2x00_wait_for_hba_online(scsi_qla_ho
  	return (return_status);
  }
  
++<<<<<<< HEAD
++=======
+ static inline int test_fcport_count(scsi_qla_host_t *vha)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	int res;
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	ql_dbg(ql_dbg_init, vha, 0x00ec,
+ 	    "tgt %p, fcport_count=%d\n",
+ 	    vha, vha->fcport_count);
+ 	res = (vha->fcport_count == 0);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 	return res;
+ }
+ 
+ /*
+  * qla2x00_wait_for_sess_deletion can only be called from remove_one.
+  * it has dependency on UNLOADING flag to stop device discovery
+  */
+ static void
+ qla2x00_wait_for_sess_deletion(scsi_qla_host_t *vha)
+ {
+ 	qla2x00_mark_all_devices_lost(vha, 0);
+ 
+ 	wait_event_timeout(vha->fcport_waitQ, test_fcport_count(vha), 10*HZ);
+ }
+ 
++>>>>>>> b85e0957b8a8 (scsi: qla2xxx: Add timeout ability to wait_for_sess_deletion().)
  /*
   * qla2x00_wait_for_hba_ready
   * Wait till the HBA is ready before doing driver unload
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 4244f37d5d93,6a6d9db6479f..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -952,18 -1477,18 +952,23 @@@ void qlt_stop_phase1(struct qla_tgt *tg
  	spin_unlock_irqrestore(&tgt->sess_work_lock, flags);
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00a,
 -	    "Waiting for tgt %p: sess_count=%d\n", tgt, tgt->sess_count);
 +	    "Waiting for tgt %p: list_empty(sess_list)=%d "
 +	    "sess_count=%d\n", tgt, list_empty(&tgt->sess_list),
 +	    tgt->sess_count);
  
- 	wait_event(tgt->waitQ, test_tgt_sess_count(tgt));
+ 	wait_event_timeout(tgt->waitQ, test_tgt_sess_count(tgt), 10*HZ);
  
  	/* Big hammer */
 -	if (!ha->flags.host_shutting_down &&
 -	    (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)))
 +	if (!ha->flags.host_shutting_down && qla_tgt_mode_enabled(vha))
  		qlt_disable_vha(vha);
  
  	/* Wait for sessions to clear out (just in case) */
++<<<<<<< HEAD
 +	wait_event(tgt->waitQ, test_tgt_sess_count(tgt));
++=======
+ 	wait_event_timeout(tgt->waitQ, test_tgt_sess_count(tgt), 10*HZ);
+ 	return 0;
++>>>>>>> b85e0957b8a8 (scsi: qla2xxx: Add timeout ability to wait_for_sess_deletion().)
  }
  EXPORT_SYMBOL(qlt_stop_phase1);
  
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
