mnt: fs_fully_visible test the proper mount for MNT_LOCKED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit d71ed6c930ac7d8f88f3cef6624a7e826392d61f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d71ed6c9.failed

MNT_LOCKED implies on a child mount implies the child is locked to the
parent.  So while looping through the children the children should be
tested (not their parent).

Typically an unshare of a mount namespace locks all mounts together
making both the parent and the slave as locked but there are a few
corner cases where other things work.

	Cc: stable@vger.kernel.org
Fixes: ceeb0e5d39fc ("vfs: Ignore unlocked mounts in fs_fully_visible")
	Reported-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit d71ed6c930ac7d8f88f3cef6624a7e826392d61f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index edd7c5e218b1,a7ec92c051f5..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -3300,23 -3224,79 +3300,76 @@@ void update_mnt_policy(struct user_name
  
  	down_read(&namespace_sem);
  	list_for_each_entry(mnt, &ns->list, mnt_list) {
++<<<<<<< HEAD
 +		switch (mnt->mnt.mnt_sb->s_magic) {
 +		case SYSFS_MAGIC:
 +			userns->may_mount_sysfs = true;
 +			break;
 +		case PROC_SUPER_MAGIC:
 +			userns->may_mount_proc = true;
 +			break;
++=======
+ 		struct mount *child;
+ 		int mnt_flags;
+ 
+ 		if (mnt->mnt.mnt_sb->s_type != type)
+ 			continue;
+ 
+ 		/* This mount is not fully visible if it's root directory
+ 		 * is not the root directory of the filesystem.
+ 		 */
+ 		if (mnt->mnt.mnt_root != mnt->mnt.mnt_sb->s_root)
+ 			continue;
+ 
+ 		/* Read the mount flags and filter out flags that
+ 		 * may safely be ignored.
+ 		 */
+ 		mnt_flags = mnt->mnt.mnt_flags;
+ 		if (mnt->mnt.mnt_sb->s_iflags & SB_I_NOEXEC)
+ 			mnt_flags &= ~(MNT_LOCK_NOSUID | MNT_LOCK_NOEXEC);
+ 
+ 		/* Verify the mount flags are equal to or more permissive
+ 		 * than the proposed new mount.
+ 		 */
+ 		if ((mnt_flags & MNT_LOCK_READONLY) &&
+ 		    !(new_flags & MNT_READONLY))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NODEV) &&
+ 		    !(new_flags & MNT_NODEV))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NOSUID) &&
+ 		    !(new_flags & MNT_NOSUID))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NOEXEC) &&
+ 		    !(new_flags & MNT_NOEXEC))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_ATIME) &&
+ 		    ((mnt_flags & MNT_ATIME_MASK) != (new_flags & MNT_ATIME_MASK)))
+ 			continue;
+ 
+ 		/* This mount is not fully visible if there are any
+ 		 * locked child mounts that cover anything except for
+ 		 * empty directories.
+ 		 */
+ 		list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {
+ 			struct inode *inode = child->mnt_mountpoint->d_inode;
+ 			/* Only worry about locked mounts */
+ 			if (!(child->mnt.mnt_flags & MNT_LOCKED))
+ 				continue;
+ 			/* Is the directory permanetly empty? */
+ 			if (!is_empty_dir_inode(inode))
+ 				goto next;
++>>>>>>> d71ed6c930ac (mnt: fs_fully_visible test the proper mount for MNT_LOCKED)
  		}
 -		/* Preserve the locked attributes */
 -		*new_mnt_flags |= mnt_flags & (MNT_LOCK_READONLY | \
 -					       MNT_LOCK_NODEV    | \
 -					       MNT_LOCK_NOSUID   | \
 -					       MNT_LOCK_NOEXEC   | \
 -					       MNT_LOCK_ATIME);
 -		visible = true;
 -		goto found;
 -	next:	;
 -	}
 -found:
 +		if (userns->may_mount_sysfs && userns->may_mount_proc)
 +			break;
 +	}
  	up_read(&namespace_sem);
 -	return visible;
  }
  
 -static struct ns_common *mntns_get(struct task_struct *task)
 +static void *mntns_get(struct task_struct *task)
  {
 -	struct ns_common *ns = NULL;
 +	struct mnt_namespace *ns = NULL;
  	struct nsproxy *nsproxy;
  
  	task_lock(task);
* Unmerged path fs/namespace.c
