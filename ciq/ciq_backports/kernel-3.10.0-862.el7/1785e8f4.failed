netfiler: ipset: Add net namespace for ipset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] netfilter: ipset: Add net namespace for ipset (Sabrina Dubroca) [1226051]
Rebuild_FUZZ: 98.88%
commit-author Vitaly Lavrov <lve@guap.ru>
commit 1785e8f473082aa60d62c7165856cf6484077b99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1785e8f4.failed

This patch adds netns support for ipset.

Major changes were made in ip_set_core.c and ip_set.h.
Global variables are moved to per net namespace.
Added initialization code and the destruction of the network namespace ipset subsystem.
In the prototypes of public functions ip_set_* added parameter "struct net*".

The remaining corrections related to the change prototypes of public functions ip_set_*.

The patch for git://git.netfilter.org/ipset.git commit 6a4ec96c0b8caac5c35474e40e319704d92ca347

	Signed-off-by: Vitaly Lavrov <lve@guap.ru>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 1785e8f473082aa60d62c7165856cf6484077b99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index daeeab1af220,7967516adc0d..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -250,11 -317,13 +251,21 @@@ ip_set_init_counter(struct ip_set_count
  }
  
  /* register and unregister set references */
++<<<<<<< HEAD
 +extern ip_set_id_t ip_set_get_byname(const char *name, struct ip_set **set);
 +extern void ip_set_put_byindex(ip_set_id_t index);
 +extern const char *ip_set_name_byindex(ip_set_id_t index);
 +extern ip_set_id_t ip_set_nfnl_get_byindex(ip_set_id_t index);
 +extern void ip_set_nfnl_put(ip_set_id_t index);
++=======
+ extern ip_set_id_t ip_set_get_byname(struct net *net,
+ 				     const char *name, struct ip_set **set);
+ extern void ip_set_put_byindex(struct net *net, ip_set_id_t index);
+ extern const char *ip_set_name_byindex(struct net *net, ip_set_id_t index);
+ extern ip_set_id_t ip_set_nfnl_get(struct net *net, const char *name);
+ extern ip_set_id_t ip_set_nfnl_get_byindex(struct net *net, ip_set_id_t index);
+ extern void ip_set_nfnl_put(struct net *net, ip_set_id_t index);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  
  /* API for iptables set match, and SET target */
  
diff --cc net/netfilter/ipset/ip_set_core.c
index 98b197a78f1a,dc9284bdd2dd..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -43,10 -54,10 +54,15 @@@ MODULE_DESCRIPTION("core IP set support
  MODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_IPSET);
  
  /* When the nfnl mutex is held: */
 -#define nfnl_dereference(p)		\
 +#define ip_set_dereference(p)		\
  	rcu_dereference_protected(p, 1)
++<<<<<<< HEAD
 +#define ip_set(id)		\
 +	ip_set_dereference(ip_set_list)[id]
++=======
+ #define nfnl_set(inst, id)			\
+ 	nfnl_dereference((inst)->ip_set_list)[id]
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  
  /*
   * The set types are implemented in modules and registered set types
@@@ -540,6 -625,34 +570,37 @@@ EXPORT_SYMBOL_GPL(ip_set_name_byindex)
   */
  
  /*
++<<<<<<< HEAD
++=======
+  * Find set by name, reference it once. The reference makes sure the
+  * thing pointed to, does not go away under our feet.
+  *
+  * The nfnl mutex is used in the function.
+  */
+ ip_set_id_t
+ ip_set_nfnl_get(struct net *net, const char *name)
+ {
+ 	ip_set_id_t i, index = IPSET_INVALID_ID;
+ 	struct ip_set *s;
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 
+ 	nfnl_lock(NFNL_SUBSYS_IPSET);
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		s = nfnl_set(inst, i);
+ 		if (s != NULL && STREQ(s->name, name)) {
+ 			__ip_set_get(s);
+ 			index = i;
+ 			break;
+ 		}
+ 	}
+ 	nfnl_unlock(NFNL_SUBSYS_IPSET);
+ 
+ 	return index;
+ }
+ EXPORT_SYMBOL_GPL(ip_set_nfnl_get);
+ 
+ /*
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
   * Find set by index, reference it once. The reference makes sure the
   * thing pointed to, does not go away under our feet.
   *
@@@ -554,7 -668,7 +616,11 @@@ ip_set_nfnl_get_byindex(struct net *net
  		return IPSET_INVALID_ID;
  
  	nfnl_lock(NFNL_SUBSYS_IPSET);
++<<<<<<< HEAD
 +	set = ip_set(index);
++=======
+ 	set = nfnl_set(inst, index);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  	if (set)
  		__ip_set_get(set);
  	else
@@@ -573,13 -687,17 +639,23 @@@ EXPORT_SYMBOL_GPL(ip_set_nfnl_get_byind
   * The nfnl mutex is used in the function.
   */
  void
- ip_set_nfnl_put(ip_set_id_t index)
+ ip_set_nfnl_put(struct net *net, ip_set_id_t index)
  {
  	struct ip_set *set;
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 
  	nfnl_lock(NFNL_SUBSYS_IPSET);
++<<<<<<< HEAD
 +	set = ip_set(index);
 +	if (set != NULL)
 +		__ip_set_put(set);
++=======
+ 	if (!inst->is_deleted) { /* already deleted from ip_set_net_exit() */
+ 		set = nfnl_set(inst, index);
+ 		if (set != NULL)
+ 			__ip_set_put(set);
+ 	}
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  	nfnl_unlock(NFNL_SUBSYS_IPSET);
  }
  EXPORT_SYMBOL_GPL(ip_set_nfnl_put);
@@@ -643,8 -761,8 +719,13 @@@ find_set_and_id(struct ip_set_net *inst
  	ip_set_id_t i;
  
  	*id = IPSET_INVALID_ID;
++<<<<<<< HEAD
 +	for (i = 0; i < ip_set_max; i++) {
 +		set = ip_set(i);
++=======
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		set = nfnl_set(inst, i);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		if (set != NULL && STREQ(set->name, name)) {
  			*id = i;
  			break;
@@@ -668,8 -787,8 +750,13 @@@ find_free_id(struct ip_set_net *inst, c
  	ip_set_id_t i;
  
  	*index = IPSET_INVALID_ID;
++<<<<<<< HEAD
 +	for (i = 0;  i < ip_set_max; i++) {
 +		s = ip_set(i);
++=======
+ 	for (i = 0;  i < inst->ip_set_max; i++) {
+ 		s = nfnl_set(inst, i);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		if (s == NULL) {
  			if (*index == IPSET_INVALID_ID)
  				*index = i;
@@@ -790,9 -911,9 +879,15 @@@ ip_set_create(struct sock *ctnl, struc
  		if (!list)
  			goto cleanup;
  		/* nfnl mutex is held, both lists are valid */
++<<<<<<< HEAD
 +		tmp = ip_set_dereference(ip_set_list);
 +		memcpy(list, tmp, sizeof(struct ip_set *) * ip_set_max);
 +		rcu_assign_pointer(ip_set_list, list);
++=======
+ 		tmp = nfnl_dereference(inst->ip_set_list);
+ 		memcpy(list, tmp, sizeof(struct ip_set *) * inst->ip_set_max);
+ 		rcu_assign_pointer(inst->ip_set_list, list);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		/* Make sure all current packets have passed through */
  		synchronize_net();
  		/* Use new list */
@@@ -807,7 -928,7 +902,11 @@@
  	 * Finally! Add our shiny new set to the list, and be done.
  	 */
  	pr_debug("create: '%s' created with index %u!\n", set->name, index);
++<<<<<<< HEAD
 +	ip_set(index) = set;
++=======
+ 	nfnl_set(inst, index) = set;
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  
  	return ret;
  
@@@ -830,12 -951,12 +929,19 @@@ ip_set_setname_policy[IPSET_ATTR_CMD_MA
  };
  
  static void
- ip_set_destroy_set(ip_set_id_t index)
+ ip_set_destroy_set(struct ip_set_net *inst, ip_set_id_t index)
  {
++<<<<<<< HEAD
 +	struct ip_set *set = ip_set(index);
 +
 +	pr_debug("set: %s\n",  set->name);
 +	ip_set(index) = NULL;
++=======
+ 	struct ip_set *set = nfnl_set(inst, index);
+ 
+ 	pr_debug("set: %s\n",  set->name);
+ 	nfnl_set(inst, index) = NULL;
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  
  	/* Must call it without holding any lock */
  	set->variant->destroy(set);
@@@ -867,21 -989,22 +974,32 @@@ ip_set_destroy(struct sock *ctnl, struc
  	 */
  	read_lock_bh(&ip_set_ref_lock);
  	if (!attr[IPSET_ATTR_SETNAME]) {
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = ip_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = nfnl_set(inst, i);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  			if (s != NULL && s->ref) {
  				ret = -IPSET_ERR_BUSY;
  				goto out;
  			}
  		}
  		read_unlock_bh(&ip_set_ref_lock);
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = ip_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = nfnl_set(inst, i);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  			if (s != NULL)
- 				ip_set_destroy_set(i);
+ 				ip_set_destroy_set(inst, i);
  		}
  	} else {
- 		s = find_set_and_id(nla_data(attr[IPSET_ATTR_SETNAME]), &i);
+ 		s = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),
+ 				    &i);
  		if (s == NULL) {
  			ret = -ENOENT;
  			goto out;
@@@ -923,8 -1047,8 +1042,13 @@@ ip_set_flush(struct sock *ctnl, struct 
  		return -IPSET_ERR_PROTOCOL;
  
  	if (!attr[IPSET_ATTR_SETNAME]) {
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = ip_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = nfnl_set(inst, i);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  			if (s != NULL)
  				ip_set_flush_set(s);
  		}
@@@ -976,8 -1101,8 +1101,13 @@@ ip_set_rename(struct sock *ctnl, struc
  	}
  
  	name2 = nla_data(attr[IPSET_ATTR_SETNAME2]);
++<<<<<<< HEAD
 +	for (i = 0; i < ip_set_max; i++) {
 +		s = ip_set(i);
++=======
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		s = nfnl_set(inst, i);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		if (s != NULL && STREQ(s->name, name2)) {
  			ret = -IPSET_ERR_EXIST_SETNAME2;
  			goto out;
@@@ -1034,8 -1162,8 +1167,13 @@@ ip_set_swap(struct sock *ctnl, struct s
  
  	write_lock_bh(&ip_set_ref_lock);
  	swap(from->ref, to->ref);
++<<<<<<< HEAD
 +	ip_set(from_id) = to;
 +	ip_set(to_id) = from;
++=======
+ 	nfnl_set(inst, from_id) = to;
+ 	nfnl_set(inst, to_id) = from;
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  	write_unlock_bh(&ip_set_ref_lock);
  
  	return 0;
@@@ -1054,9 -1182,10 +1192,15 @@@
  static int
  ip_set_dump_done(struct netlink_callback *cb)
  {
+ 	struct ip_set_net *inst = (struct ip_set_net *)cb->data;
  	if (cb->args[2]) {
++<<<<<<< HEAD
 +		pr_debug("release set %s\n", ip_set(cb->args[1])->name);
 +		ip_set_put_byindex((ip_set_id_t) cb->args[1]);
++=======
+ 		pr_debug("release set %s\n", nfnl_set(inst, cb->args[1])->name);
+ 		__ip_set_put_byindex(inst, (ip_set_id_t) cb->args[1]);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  	}
  	return 0;
  }
@@@ -1147,7 -1278,7 +1293,11 @@@ dump_last
  		 dump_type, dump_flags, cb->args[1]);
  	for (; cb->args[1] < max; cb->args[1]++) {
  		index = (ip_set_id_t) cb->args[1];
++<<<<<<< HEAD
 +		set = ip_set(index);
++=======
+ 		set = nfnl_set(inst, index);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		if (set == NULL) {
  			if (dump_type == DUMP_ONE) {
  				ret = -ENOENT;
@@@ -1225,8 -1356,8 +1375,13 @@@ next_set
  release_refcount:
  	/* If there was an error or set is done, release set */
  	if (ret || !cb->args[2]) {
++<<<<<<< HEAD
 +		pr_debug("release set %s\n", ip_set(index)->name);
 +		ip_set_put_byindex(index);
++=======
+ 		pr_debug("release set %s\n", nfnl_set(inst, index)->name);
+ 		__ip_set_put_byindex(inst, index);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		cb->args[2] = 0;
  	}
  out:
@@@ -1757,11 -1896,28 +1921,31 @@@ ip_set_sockfn_get(struct sock *sk, int 
  		}
  		req_get->set.name[IPSET_MAXNAMELEN - 1] = '\0';
  		nfnl_lock(NFNL_SUBSYS_IPSET);
- 		find_set_and_id(req_get->set.name, &id);
+ 		find_set_and_id(inst, req_get->set.name, &id);
+ 		req_get->set.index = id;
+ 		nfnl_unlock(NFNL_SUBSYS_IPSET);
+ 		goto copy;
+ 	}
++<<<<<<< HEAD
++=======
+ 	case IP_SET_OP_GET_FNAME: {
+ 		struct ip_set_req_get_set_family *req_get = data;
+ 		ip_set_id_t id;
+ 
+ 		if (*len != sizeof(struct ip_set_req_get_set_family)) {
+ 			ret = -EINVAL;
+ 			goto done;
+ 		}
+ 		req_get->set.name[IPSET_MAXNAMELEN - 1] = '\0';
+ 		nfnl_lock(NFNL_SUBSYS_IPSET);
+ 		find_set_and_id(inst, req_get->set.name, &id);
  		req_get->set.index = id;
+ 		if (id != IPSET_INVALID_ID)
+ 			req_get->family = nfnl_set(inst, id)->family;
  		nfnl_unlock(NFNL_SUBSYS_IPSET);
  		goto copy;
  	}
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  	case IP_SET_OP_GET_BYINDEX: {
  		struct ip_set_req_get_set *req_get = data;
  		struct ip_set *set;
@@@ -1772,7 -1928,7 +1956,11 @@@
  			goto done;
  		}
  		nfnl_lock(NFNL_SUBSYS_IPSET);
++<<<<<<< HEAD
 +		set = ip_set(req_get->set.index);
++=======
+ 		set = nfnl_set(inst, req_get->set.index);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		strncpy(req_get->set.name, set ? set->name : "",
  			IPSET_MAXNAMELEN);
  		nfnl_unlock(NFNL_SUBSYS_IPSET);
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 707bc520d629,6a80dbd30df7..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -946,10 -1011,10 +946,15 @@@ static const struct ip_set_type_varian
  
  #ifdef IP_SET_EMIT_CREATE
  static int
++<<<<<<< HEAD
 +TOKEN(HTYPE, _create)(struct ip_set *set, struct nlattr *tb[], u32 flags)
++=======
+ IPSET_TOKEN(HTYPE, _create)(struct net *net, struct ip_set *set,
+ 			    struct nlattr *tb[], u32 flags)
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  {
  	u32 hashsize = IPSET_DEFAULT_HASHSIZE, maxelem = IPSET_DEFAULT_MAXELEM;
 +	u32 cadt_flags = 0;
  	u8 hbits;
  #ifdef IP_SET_HASH_WITH_NETMASK
  	u8 netmask;
diff --cc net/netfilter/ipset/ip_set_list_set.c
index 979b8c90e422,ec6f6d15dded..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -58,11 -37,9 +58,12 @@@ struct set_adt_elem 
  
  /* Type structure */
  struct list_set {
 +	size_t dsize;		/* element size */
 +	size_t offset[IPSET_OFFSET_MAX]; /* Offsets to extensions */
  	u32 size;		/* size of set list array */
 +	u32 timeout;		/* timeout value */
  	struct timer_list gc;	/* garbage collection */
+ 	struct net *net;	/* namespace */
  	struct set_elem members[0]; /* the set members */
  };
  
@@@ -199,20 -167,26 +200,38 @@@ list_set_add(struct ip_set *set, u32 i
  	     const struct ip_set_ext *ext)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e = list_set_elem(set, map, i);
 +	struct set_elem *e = list_set_elem(map, i);
  
  	if (e->id != IPSET_INVALID_ID) {
 -		if (i == map->size - 1) {
 +		if (i == map->size - 1)
  			/* Last element replaced: e.g. add new,before,last */
++<<<<<<< HEAD
 +			ip_set_put_byindex(e->id);
 +		else {
 +			struct set_elem *x = list_set_elem(map, map->size - 1);
 +
 +			/* Last element pushed off */
 +			if (x->id != IPSET_INVALID_ID)
 +				ip_set_put_byindex(x->id);
 +			memmove(list_set_elem(map, i + 1), e,
 +				map->dsize * (map->size - (i + 1)));
++=======
+ 			ip_set_put_byindex(map->net, e->id);
+ 			ip_set_ext_destroy(set, e);
+ 		} else {
+ 			struct set_elem *x = list_set_elem(set, map,
+ 							   map->size - 1);
+ 
+ 			/* Last element pushed off */
+ 			if (x->id != IPSET_INVALID_ID) {
+ 				ip_set_put_byindex(map->net, x->id);
+ 				ip_set_ext_destroy(set, x);
+ 			}
+ 			memmove(list_set_elem(set, map, i + 1), e,
+ 				set->dsize * (map->size - (i + 1)));
+ 			/* Extensions must be initialized to zero */
+ 			memset(e, 0, set->dsize);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		}
  	}
  
@@@ -228,16 -204,17 +247,21 @@@ static in
  list_set_del(struct ip_set *set, u32 i)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e = list_set_elem(set, map, i);
 +	struct set_elem *e = list_set_elem(map, i);
  
++<<<<<<< HEAD
 +	ip_set_put_byindex(e->id);
++=======
+ 	ip_set_put_byindex(map->net, e->id);
+ 	ip_set_ext_destroy(set, e);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  
  	if (i < map->size - 1)
 -		memmove(e, list_set_elem(set, map, i + 1),
 -			set->dsize * (map->size - (i + 1)));
 +		memmove(e, list_set_elem(map, i + 1),
 +			map->dsize * (map->size - (i + 1)));
  
  	/* Last element */
 -	e = list_set_elem(set, map, map->size - 1);
 +	e = list_set_elem(map, map->size - 1);
  	e->id = IPSET_INVALID_ID;
  	return 0;
  }
@@@ -319,12 -299,16 +343,12 @@@ list_set_uadd(struct ip_set *set, void 
  			/* Can't re-add */
  			return -IPSET_ERR_EXIST;
  		/* Update extensions */
 -		ip_set_ext_destroy(set, e);
 -
  		if (SET_WITH_TIMEOUT(set))
 -			ip_set_timeout_set(ext_timeout(e, set), ext->timeout);
 +			ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
  		if (SET_WITH_COUNTER(set))
 -			ip_set_init_counter(ext_counter(e, set), ext);
 -		if (SET_WITH_COMMENT(set))
 -			ip_set_init_comment(ext_comment(e, set), ext);
 +			ip_set_init_counter(ext_counter(e, map), ext);
  		/* Set is already added to the list */
- 		ip_set_put_byindex(d->id);
+ 		ip_set_put_byindex(map->net, d->id);
  		return 0;
  	}
  insert:
@@@ -454,9 -439,10 +479,14 @@@ list_set_flush(struct ip_set *set
  	u32 i;
  
  	for (i = 0; i < map->size; i++) {
 -		e = list_set_elem(set, map, i);
 +		e = list_set_elem(map, i);
  		if (e->id != IPSET_INVALID_ID) {
++<<<<<<< HEAD
 +			ip_set_put_byindex(e->id);
++=======
+ 			ip_set_put_byindex(map->net, e->id);
+ 			ip_set_ext_destroy(set, e);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  			e->id = IPSET_INVALID_ID;
  		}
  	}
@@@ -530,15 -513,9 +560,15 @@@ list_set_list(const struct ip_set *set
  				goto nla_put_failure;
  		}
  		if (nla_put_string(skb, IPSET_ATTR_NAME,
- 				   ip_set_name_byindex(e->id)))
+ 				   ip_set_name_byindex(map->net, e->id)))
  			goto nla_put_failure;
 -		if (ip_set_put_extensions(skb, set, e, true))
 +		if (SET_WITH_TIMEOUT(set) &&
 +		    nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +				  htonl(ip_set_timeout_get(
 +						ext_timeout(e, map)))))
 +			goto nla_put_failure;
 +		if (SET_WITH_COUNTER(set) &&
 +		    ip_set_put_counter(skb, ext_counter(e, map)))
  			goto nla_put_failure;
  		ipset_nest_end(skb, nested);
  	}
@@@ -612,21 -589,19 +642,30 @@@ list_set_gc_init(struct ip_set *set, vo
  
  /* Create list:set type of sets */
  
++<<<<<<< HEAD
 +static struct list_set *
 +init_list_set(struct ip_set *set, u32 size, size_t dsize,
 +	      unsigned long timeout)
++=======
+ static bool
+ init_list_set(struct net *net, struct ip_set *set, u32 size)
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  {
  	struct list_set *map;
  	struct set_elem *e;
  	u32 i;
  
 -	map = kzalloc(sizeof(*map) + size * set->dsize, GFP_KERNEL);
 +	map = kzalloc(sizeof(*map) + size * dsize, GFP_KERNEL);
  	if (!map)
 -		return false;
 +		return NULL;
  
  	map->size = size;
++<<<<<<< HEAD
 +	map->dsize = dsize;
 +	map->timeout = timeout;
++=======
+ 	map->net = net;
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  	set->data = map;
  
  	for (i = 0; i < size; i++) {
@@@ -638,11 -613,10 +677,12 @@@
  }
  
  static int
- list_set_create(struct ip_set *set, struct nlattr *tb[], u32 flags)
+ list_set_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
+ 		u32 flags)
  {
 -	u32 size = IP_SET_LIST_DEFAULT_SIZE;
 +	struct list_set *map;
 +	u32 size = IP_SET_LIST_DEFAULT_SIZE, cadt_flags = 0;
 +	unsigned long timeout = 0;
  
  	if (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_SIZE) ||
  		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
@@@ -654,45 -628,13 +694,53 @@@
  	if (size < IP_SET_LIST_MIN_SIZE)
  		size = IP_SET_LIST_MIN_SIZE;
  
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (tb[IPSET_ATTR_TIMEOUT])
 +		timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
  	set->variant = &set_variant;
++<<<<<<< HEAD
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map = init_list_set(set, size,
 +					sizeof(struct setct_elem), timeout);
 +			if (!map)
 +				return -ENOMEM;
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			map->offset[IPSET_OFFSET_TIMEOUT] =
 +				offsetof(struct setct_elem, timeout);
 +			map->offset[IPSET_OFFSET_COUNTER] =
 +				offsetof(struct setct_elem, counter);
 +			list_set_gc_init(set, list_set_gc);
 +		} else {
 +			map = init_list_set(set, size,
 +					    sizeof(struct setc_elem), 0);
 +			if (!map)
 +				return -ENOMEM;
 +			map->offset[IPSET_OFFSET_COUNTER] =
 +				offsetof(struct setc_elem, counter);
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map = init_list_set(set, size,
 +				    sizeof(struct sett_elem), timeout);
 +		if (!map)
 +			return -ENOMEM;
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		map->offset[IPSET_OFFSET_TIMEOUT] =
 +			offsetof(struct sett_elem, timeout);
++=======
+ 	set->dsize = ip_set_elem_len(set, tb, sizeof(struct set_elem));
+ 	if (!init_list_set(net, set, size))
+ 		return -ENOMEM;
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
++>>>>>>> 1785e8f47308 (netfiler: ipset: Add net namespace for ipset)
  		list_set_gc_init(set, list_set_gc);
 +	} else {
 +		map = init_list_set(set, size, sizeof(struct set_elem), 0);
 +		if (!map)
 +			return -ENOMEM;
  	}
  	return 0;
  }
* Unmerged path include/linux/netfilter/ipset/ip_set.h
diff --git a/net/netfilter/ipset/ip_set_bitmap_ip.c b/net/netfilter/ipset/ip_set_bitmap_ip.c
index f1a8128bef01..006d34da7c8a 100644
--- a/net/netfilter/ipset/ip_set_bitmap_ip.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ip.c
@@ -261,7 +261,8 @@ init_map_ip(struct ip_set *set, struct bitmap_ip *map,
 }
 
 static int
-bitmap_ip_create(struct ip_set *set, struct nlattr *tb[], u32 flags)
+bitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
+		 u32 flags)
 {
 	struct bitmap_ip *map;
 	u32 first_ip, last_ip, hosts, cadt_flags = 0;
diff --git a/net/netfilter/ipset/ip_set_bitmap_ipmac.c b/net/netfilter/ipset/ip_set_bitmap_ipmac.c
index 3b30e0bef890..0a8bf8f26537 100644
--- a/net/netfilter/ipset/ip_set_bitmap_ipmac.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ipmac.c
@@ -352,7 +352,7 @@ init_map_ipmac(struct ip_set *set, struct bitmap_ipmac *map,
 }
 
 static int
-bitmap_ipmac_create(struct ip_set *set, struct nlattr *tb[],
+bitmap_ipmac_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
 		    u32 flags)
 {
 	u32 first_ip, last_ip, cadt_flags = 0;
diff --git a/net/netfilter/ipset/ip_set_bitmap_port.c b/net/netfilter/ipset/ip_set_bitmap_port.c
index 8207d1fda528..6ba95387fa2e 100644
--- a/net/netfilter/ipset/ip_set_bitmap_port.c
+++ b/net/netfilter/ipset/ip_set_bitmap_port.c
@@ -248,7 +248,8 @@ init_map_port(struct ip_set *set, struct bitmap_port *map,
 }
 
 static int
-bitmap_port_create(struct ip_set *set, struct nlattr *tb[], u32 flags)
+bitmap_port_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
+		   u32 flags)
 {
 	struct bitmap_port *map;
 	u16 first_port, last_port;
* Unmerged path net/netfilter/ipset/ip_set_core.c
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
diff --git a/net/netfilter/xt_set.c b/net/netfilter/xt_set.c
index 2095488684ff..e7c4e0e01ff5 100644
--- a/net/netfilter/xt_set.c
+++ b/net/netfilter/xt_set.c
@@ -81,7 +81,7 @@ set_match_v0_checkentry(const struct xt_mtchk_param *par)
 	struct xt_set_info_match_v0 *info = par->matchinfo;
 	ip_set_id_t index;
 
-	index = ip_set_nfnl_get_byindex(info->match_set.index);
+	index = ip_set_nfnl_get_byindex(par->net, info->match_set.index);
 
 	if (index == IPSET_INVALID_ID) {
 		pr_warning("Cannot find set indentified by id %u to match\n",
@@ -91,7 +91,7 @@ set_match_v0_checkentry(const struct xt_mtchk_param *par)
 	if (info->match_set.u.flags[IPSET_DIM_MAX-1] != 0) {
 		pr_warning("Protocol error: set match dimension "
 			   "is over the limit!\n");
-		ip_set_nfnl_put(info->match_set.index);
+		ip_set_nfnl_put(par->net, info->match_set.index);
 		return -ERANGE;
 	}
 
@@ -106,7 +106,7 @@ set_match_v0_destroy(const struct xt_mtdtor_param *par)
 {
 	struct xt_set_info_match_v0 *info = par->matchinfo;
 
-	ip_set_nfnl_put(info->match_set.index);
+	ip_set_nfnl_put(par->net, info->match_set.index);
 }
 
 /* Revision 1 match */
@@ -131,7 +131,7 @@ set_match_v1_checkentry(const struct xt_mtchk_param *par)
 	struct xt_set_info_match_v1 *info = par->matchinfo;
 	ip_set_id_t index;
 
-	index = ip_set_nfnl_get_byindex(info->match_set.index);
+	index = ip_set_nfnl_get_byindex(par->net, info->match_set.index);
 
 	if (index == IPSET_INVALID_ID) {
 		pr_warning("Cannot find set indentified by id %u to match\n",
@@ -141,7 +141,7 @@ set_match_v1_checkentry(const struct xt_mtchk_param *par)
 	if (info->match_set.dim > IPSET_DIM_MAX) {
 		pr_warning("Protocol error: set match dimension "
 			   "is over the limit!\n");
-		ip_set_nfnl_put(info->match_set.index);
+		ip_set_nfnl_put(par->net, info->match_set.index);
 		return -ERANGE;
 	}
 
@@ -153,7 +153,7 @@ set_match_v1_destroy(const struct xt_mtdtor_param *par)
 {
 	struct xt_set_info_match_v1 *info = par->matchinfo;
 
-	ip_set_nfnl_put(info->match_set.index);
+	ip_set_nfnl_put(par->net, info->match_set.index);
 }
 
 /* Revision 3 match */
@@ -228,7 +228,7 @@ set_target_v0_checkentry(const struct xt_tgchk_param *par)
 	ip_set_id_t index;
 
 	if (info->add_set.index != IPSET_INVALID_ID) {
-		index = ip_set_nfnl_get_byindex(info->add_set.index);
+		index = ip_set_nfnl_get_byindex(par->net, info->add_set.index);
 		if (index == IPSET_INVALID_ID) {
 			pr_warning("Cannot find add_set index %u as target\n",
 				   info->add_set.index);
@@ -237,12 +237,12 @@ set_target_v0_checkentry(const struct xt_tgchk_param *par)
 	}
 
 	if (info->del_set.index != IPSET_INVALID_ID) {
-		index = ip_set_nfnl_get_byindex(info->del_set.index);
+		index = ip_set_nfnl_get_byindex(par->net, info->del_set.index);
 		if (index == IPSET_INVALID_ID) {
 			pr_warning("Cannot find del_set index %u as target\n",
 				   info->del_set.index);
 			if (info->add_set.index != IPSET_INVALID_ID)
-				ip_set_nfnl_put(info->add_set.index);
+				ip_set_nfnl_put(par->net, info->add_set.index);
 			return -ENOENT;
 		}
 	}
@@ -251,9 +251,9 @@ set_target_v0_checkentry(const struct xt_tgchk_param *par)
 		pr_warning("Protocol error: SET target dimension "
 			   "is over the limit!\n");
 		if (info->add_set.index != IPSET_INVALID_ID)
-			ip_set_nfnl_put(info->add_set.index);
+			ip_set_nfnl_put(par->net, info->add_set.index);
 		if (info->del_set.index != IPSET_INVALID_ID)
-			ip_set_nfnl_put(info->del_set.index);
+			ip_set_nfnl_put(par->net, info->del_set.index);
 		return -ERANGE;
 	}
 
@@ -270,9 +270,9 @@ set_target_v0_destroy(const struct xt_tgdtor_param *par)
 	const struct xt_set_info_target_v0 *info = par->targinfo;
 
 	if (info->add_set.index != IPSET_INVALID_ID)
-		ip_set_nfnl_put(info->add_set.index);
+		ip_set_nfnl_put(par->net, info->add_set.index);
 	if (info->del_set.index != IPSET_INVALID_ID)
-		ip_set_nfnl_put(info->del_set.index);
+		ip_set_nfnl_put(par->net, info->del_set.index);
 }
 
 /* Revision 1 target */
@@ -301,7 +301,7 @@ set_target_v1_checkentry(const struct xt_tgchk_param *par)
 	ip_set_id_t index;
 
 	if (info->add_set.index != IPSET_INVALID_ID) {
-		index = ip_set_nfnl_get_byindex(info->add_set.index);
+		index = ip_set_nfnl_get_byindex(par->net, info->add_set.index);
 		if (index == IPSET_INVALID_ID) {
 			pr_warning("Cannot find add_set index %u as target\n",
 				   info->add_set.index);
@@ -310,12 +310,12 @@ set_target_v1_checkentry(const struct xt_tgchk_param *par)
 	}
 
 	if (info->del_set.index != IPSET_INVALID_ID) {
-		index = ip_set_nfnl_get_byindex(info->del_set.index);
+		index = ip_set_nfnl_get_byindex(par->net, info->del_set.index);
 		if (index == IPSET_INVALID_ID) {
 			pr_warning("Cannot find del_set index %u as target\n",
 				   info->del_set.index);
 			if (info->add_set.index != IPSET_INVALID_ID)
-				ip_set_nfnl_put(info->add_set.index);
+				ip_set_nfnl_put(par->net, info->add_set.index);
 			return -ENOENT;
 		}
 	}
@@ -324,9 +324,9 @@ set_target_v1_checkentry(const struct xt_tgchk_param *par)
 		pr_warning("Protocol error: SET target dimension "
 			   "is over the limit!\n");
 		if (info->add_set.index != IPSET_INVALID_ID)
-			ip_set_nfnl_put(info->add_set.index);
+			ip_set_nfnl_put(par->net, info->add_set.index);
 		if (info->del_set.index != IPSET_INVALID_ID)
-			ip_set_nfnl_put(info->del_set.index);
+			ip_set_nfnl_put(par->net, info->del_set.index);
 		return -ERANGE;
 	}
 
@@ -339,9 +339,9 @@ set_target_v1_destroy(const struct xt_tgdtor_param *par)
 	const struct xt_set_info_target_v1 *info = par->targinfo;
 
 	if (info->add_set.index != IPSET_INVALID_ID)
-		ip_set_nfnl_put(info->add_set.index);
+		ip_set_nfnl_put(par->net, info->add_set.index);
 	if (info->del_set.index != IPSET_INVALID_ID)
-		ip_set_nfnl_put(info->del_set.index);
+		ip_set_nfnl_put(par->net, info->del_set.index);
 }
 
 /* Revision 2 target */
diff --git a/net/sched/em_ipset.c b/net/sched/em_ipset.c
index 7caea2bf514e..4888cc580060 100644
--- a/net/sched/em_ipset.c
+++ b/net/sched/em_ipset.c
@@ -24,11 +24,12 @@ static int em_ipset_change(struct net *net, void *data, int data_len,
 {
 	struct xt_set_info *set = data;
 	ip_set_id_t index;
+	struct net *net = qdisc_dev(tp->q)->nd_net;
 
 	if (data_len != sizeof(*set))
 		return -EINVAL;
 
-	index = ip_set_nfnl_get_byindex(set->index);
+	index = ip_set_nfnl_get_byindex(net, set->index);
 	if (index == IPSET_INVALID_ID)
 		return -ENOENT;
 
@@ -37,7 +38,7 @@ static int em_ipset_change(struct net *net, void *data, int data_len,
 	if (em->data)
 		return 0;
 
-	ip_set_nfnl_put(index);
+	ip_set_nfnl_put(net, index);
 	return -ENOMEM;
 }
 
@@ -45,7 +46,7 @@ static void em_ipset_destroy(struct tcf_ematch *em)
 {
 	const struct xt_set_info *set = (const void *) em->data;
 	if (set) {
-		ip_set_nfnl_put(set->index);
+		ip_set_nfnl_put(qdisc_dev(p->q)->nd_net, set->index);
 		kfree((void *) em->data);
 	}
 }
