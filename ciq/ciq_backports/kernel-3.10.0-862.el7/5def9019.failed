ALSA: x86: Use snd_pcm_stop_xrun() for connection / disconnection paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 5def90196b52d0bbec4f662448e25f2a4c06ddbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5def9019.failed

This seems more friendly to user-space, as it's notified at least as
an error, instead of forcibly moving the PCM state to SETUP out of
sudden.

Moreover, snd_pcm_stop() needs an extra PCM spinlock I forgot, while
snd_pcm_stop_xrun() takes the spinlock by itself.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 5def90196b52d0bbec4f662448e25f2a4c06ddbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,a7343f2d2730..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -1458,55 -1353,80 +1458,125 @@@ out
  	return retval;
  }
  
 -/* process hot plug, called from wq with mutex locked */
 -static void had_process_hot_plug(struct snd_intelhad *intelhaddata)
 -{
 -	struct snd_pcm_substream *substream;
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
 +	.open =		snd_intelhad_open,
 +	.close =	snd_intelhad_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_intelhad_hw_params,
 +	.hw_free =	snd_intelhad_hw_free,
 +	.prepare =	snd_intelhad_pcm_prepare,
 +	.trigger =	snd_intelhad_pcm_trigger,
 +	.pointer =	snd_intelhad_pcm_pointer,
 +	.mmap =	snd_intelhad_pcm_mmap,
 +};
  
++<<<<<<< HEAD
 +/**
 + * snd_intelhad_create - to crete alsa card instance
 + *
 + * @intelhaddata: pointer to internal context
 + * @card: pointer to card
 + *
 + * This function is called when the hdmi cable is plugged in
++=======
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	if (intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		return;
+ 	}
+ 
+ 	intelhaddata->connected = true;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	/* Safety check */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"Force to stop the active stream by disconnection\n");
+ 		/* Set runtime->state to hw_params done */
+ 		snd_pcm_stop_xrun(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ 
+ 	snd_jack_report(intelhaddata->jack, SND_JACK_AVOUT);
+ }
+ 
+ /* process hot unplug, called from wq with mutex locked */
+ static void had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		goto out;
+ 
+ 	}
+ 
+ 	/* Disable Audio */
+ 	had_enable_audio(intelhaddata, false);
+ 
+ 	intelhaddata->connected = false;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	/* Report to above ALSA layer */
+ 	if (substream)
+ 		snd_pcm_stop_xrun(substream);
+ 
+  out:
+ 	snd_jack_report(intelhaddata->jack, 0);
+ 	if (substream)
+ 		had_substream_put(intelhaddata);
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ }
+ 
+ /*
+  * ALSA iec958 and ELD controls
++>>>>>>> 5def90196b52 (ALSA: x86: Use snd_pcm_stop_xrun() for connection / disconnection paths)
 + */
 +static int snd_intelhad_create(
 +		struct snd_intelhad *intelhaddata,
 +		struct snd_card *card)
 +{
 +	int retval;
 +	static struct snd_device_ops ops = {
 +	};
 +
 +	pr_debug("snd_intelhad_create called\n");
 +
 +	if (!intelhaddata)
 +		return -EINVAL;
 +
 +	/* ALSA api to register the device */
 +	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelhaddata, &ops);
 +	return retval;
 +}
 +/**
 + * snd_intelhad_pcm_free - to free the memory allocated
 + *
 + * @pcm: pointer to pcm instance
 + * This function is called when the device is removed
   */
 +static void snd_intelhad_pcm_free(struct snd_pcm *pcm)
 +{
 +	pr_debug("Freeing PCM preallocated pages\n");
 +	snd_pcm_lib_preallocate_free_for_all(pcm);
 +}
  
  static int had_iec958_info(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_info *uinfo)
* Unmerged path sound/x86/intel_hdmi_audio.c
