x86/mm: Enable RCU based page table freeing (CONFIG_HAVE_RCU_TABLE_FREE=y)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mm: Enable RCU based page table freeing (CONFIG_HAVE_RCU_TABLE_FREE=y) (Vitaly Kuznetsov) [1465471]
Rebuild_FUZZ: 97.22%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 9e52fc2b50de3a1c08b44f94c610fbe998c0031a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9e52fc2b.failed

There's a subtle bug in how some of the paravirt guest code handles
page table freeing on x86:

On x86 software page table walkers depend on the fact that remote TLB flush
does an IPI: walk is performed lockless but with interrupts disabled and in
case the page table is freed the freeing CPU will get blocked as remote TLB
flush is required. On other architectures which don't require an IPI to do
remote TLB flush we have an RCU-based mechanism (see
include/asm-generic/tlb.h for more details).

In virtualized environments we may want to override the ->flush_tlb_others
callback in pv_mmu_ops and use a hypercall asking the hypervisor to do a
remote TLB flush for us. This breaks the assumption about IPIs. Xen PV has
been doing this for years and the upcoming remote TLB flush for Hyper-V will
do it too.

This is not safe, as software page table walkers may step on an already
freed page.

Fix the bug by enabling the RCU-based page table freeing mechanism,
CONFIG_HAVE_RCU_TABLE_FREE=y.

Testing with kernbench and mmap/munmap microbenchmarks, and neither showed
any noticeable performance impact.

	Suggested-by: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Acked-by: Peter Zijlstra <peterz@infradead.org>
	Acked-by: Juergen Gross <jgross@suse.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Andrew Cooper <andrew.cooper3@citrix.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Jork Loeser <Jork.Loeser@microsoft.com>
	Cc: KY Srinivasan <kys@microsoft.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: xen-devel@lists.xenproject.org
Link: http://lkml.kernel.org/r/20170828082251.5562-1-vkuznets@redhat.com
[ Rewrote/fixed/clarified the changelog. ]
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9e52fc2b50de3a1c08b44f94c610fbe998c0031a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
#	arch/x86/mm/pgtable.c
diff --cc arch/x86/Kconfig
index c83b7a921031,87e447286c37..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -15,125 -21,171 +15,134 @@@ config X86_3
  config X86_64
  	def_bool y
  	depends on 64BIT
 -	# Options that are inherently 64-bit kernel only:
 -	select ARCH_HAS_GIGANTIC_PAGE if (MEMORY_ISOLATION && COMPACTION) || CMA
 -	select ARCH_SUPPORTS_INT128
 -	select ARCH_USE_CMPXCHG_LOCKREF
 -	select HAVE_ARCH_SOFT_DIRTY
 -	select MODULES_USE_ELF_RELA
  	select X86_DEV_DMA_OPS
 +	select ARCH_USE_CMPXCHG_LOCKREF
  
 -#
 -# Arch settings
 -#
 -# ( Note that options that are marked 'if X86_64' could in principle be
 -#   ported to 32-bit as well. )
 -#
 +### Arch settings
  config X86
  	def_bool y
 -	#
 -	# Note: keep this list sorted alphabetically
 -	#
 -	select ACPI_LEGACY_TABLES_LOOKUP	if ACPI
 -	select ACPI_SYSTEM_POWER_STATES_SUPPORT	if ACPI
 -	select ANON_INODES
 -	select ARCH_CLOCKSOURCE_DATA
 -	select ARCH_DISCARD_MEMBLOCK
 -	select ARCH_HAS_ACPI_TABLE_UPGRADE	if ACPI
 -	select ARCH_HAS_DEBUG_VIRTUAL
 -	select ARCH_HAS_DEVMEM_IS_ALLOWED
 -	select ARCH_HAS_ELF_RANDOMIZE
 -	select ARCH_HAS_FAST_MULTIPLIER
 -	select ARCH_HAS_FORTIFY_SOURCE
 -	select ARCH_HAS_GCOV_PROFILE_ALL
 -	select ARCH_HAS_KCOV			if X86_64
 -	select ARCH_HAS_MMIO_FLUSH
 +	select ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS
  	select ARCH_HAS_PMEM_API		if X86_64
 -	select ARCH_HAS_UACCESS_FLUSHCACHE	if X86_64
 -	select ARCH_HAS_SET_MEMORY
 -	select ARCH_HAS_SG_CHAIN
 -	select ARCH_HAS_STRICT_KERNEL_RWX
 -	select ARCH_HAS_STRICT_MODULE_RWX
 -	select ARCH_HAS_UBSAN_SANITIZE_ALL
 -	select ARCH_HAS_ZONE_DEVICE		if X86_64
 -	select ARCH_HAVE_NMI_SAFE_CMPXCHG
 -	select ARCH_MIGHT_HAVE_ACPI_PDC		if ACPI
 -	select ARCH_MIGHT_HAVE_PC_PARPORT
 -	select ARCH_MIGHT_HAVE_PC_SERIO
 -	select ARCH_SUPPORTS_ATOMIC_RMW
 +	select ARCH_HAS_MMIO_FLUSH
 +	select HAVE_AOUT if X86_32
 +	select HAVE_UNSTABLE_SCHED_CLOCK
 +	select ARCH_SUPPORTS_NUMA_BALANCING
 +	select ARCH_SUPPORTS_INT128 if X86_64
 +	select ARCH_WANTS_PROT_NUMA_PROT_NONE
 +	select HAVE_IDE
 +	select HAVE_OPROFILE
 +	select HAVE_PCSPKR_PLATFORM
 +	select HAVE_PERF_EVENTS
 +	select HAVE_IOREMAP_PROT
 +	select HAVE_KPROBES
 +	select HAVE_MEMBLOCK
 +	select HAVE_MEMBLOCK_NODE_MAP
 +	select ARCH_DISCARD_MEMBLOCK
  	select ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT
 -	select ARCH_SUPPORTS_NUMA_BALANCING	if X86_64
 -	select ARCH_USE_BUILTIN_BSWAP
 -	select ARCH_USE_QUEUED_RWLOCKS
 -	select ARCH_USE_QUEUED_SPINLOCKS
 -	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH
 +	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH if SMP
 +	select ARCH_WANT_OPTIONAL_GPIOLIB
  	select ARCH_WANT_FRAME_POINTERS
 -	select ARCH_WANTS_DYNAMIC_TASK_STRUCT
 -	select ARCH_WANTS_THP_SWAP		if X86_64
 -	select BUILDTIME_EXTABLE_SORT
 -	select CLKEVT_I8253
 -	select CLOCKSOURCE_VALIDATE_LAST_CYCLE
 -	select CLOCKSOURCE_WATCHDOG
 -	select DCACHE_WORD_ACCESS
 -	select EDAC_ATOMIC_SCRUB
 -	select EDAC_SUPPORT
 -	select GENERIC_CLOCKEVENTS
 -	select GENERIC_CLOCKEVENTS_BROADCAST	if X86_64 || (X86_32 && X86_LOCAL_APIC)
 -	select GENERIC_CLOCKEVENTS_MIN_ADJUST
 -	select GENERIC_CMOS_UPDATE
 -	select GENERIC_CPU_AUTOPROBE
 -	select GENERIC_EARLY_IOREMAP
 -	select GENERIC_FIND_FIRST_BIT
 -	select GENERIC_IOMAP
 -	select GENERIC_IRQ_EFFECTIVE_AFF_MASK	if SMP
 -	select GENERIC_IRQ_MIGRATION		if SMP
 -	select GENERIC_IRQ_PROBE
 -	select GENERIC_IRQ_SHOW
 -	select GENERIC_PENDING_IRQ		if SMP
 -	select GENERIC_SMP_IDLE_THREAD
 -	select GENERIC_STRNCPY_FROM_USER
 -	select GENERIC_STRNLEN_USER
 -	select GENERIC_TIME_VSYSCALL
 -	select HARDLOCKUP_CHECK_TIMESTAMP	if X86_64
 -	select HAVE_ACPI_APEI			if ACPI
 -	select HAVE_ACPI_APEI_NMI		if ACPI
 -	select HAVE_ALIGNED_STRUCT_PAGE		if SLUB
 -	select HAVE_ARCH_AUDITSYSCALL
 -	select HAVE_ARCH_HUGE_VMAP		if X86_64 || X86_PAE
 -	select HAVE_ARCH_JUMP_LABEL
 -	select HAVE_ARCH_KASAN			if X86_64 && SPARSEMEM_VMEMMAP
 -	select HAVE_ARCH_KGDB
 -	select HAVE_ARCH_KMEMCHECK
 +	select HAVE_DMA_ATTRS
 +	select HAVE_DMA_CONTIGUOUS if !SWIOTLB
 +	select HAVE_KRETPROBES
 +	select HAVE_OPTPROBES
 +	select HAVE_KPROBES_ON_FTRACE
 +	select HAVE_FTRACE_MCOUNT_RECORD
 +	select HAVE_FENTRY if X86_64
  	select HAVE_ARCH_MMAP_RND_BITS		if MMU
  	select HAVE_ARCH_MMAP_RND_COMPAT_BITS	if MMU && COMPAT
 -	select HAVE_ARCH_COMPAT_MMAP_BASES	if MMU && COMPAT
 -	select HAVE_ARCH_SECCOMP_FILTER
 -	select HAVE_ARCH_TRACEHOOK
 -	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
 -	select HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD if X86_64
 -	select HAVE_ARCH_VMAP_STACK		if X86_64
 -	select HAVE_ARCH_WITHIN_STACK_FRAMES
 -	select HAVE_CC_STACKPROTECTOR
 -	select HAVE_CMPXCHG_DOUBLE
 -	select HAVE_CMPXCHG_LOCAL
 -	select HAVE_CONTEXT_TRACKING		if X86_64
 -	select HAVE_COPY_THREAD_TLS
  	select HAVE_C_RECORDMCOUNT
 -	select HAVE_DEBUG_KMEMLEAK
 -	select HAVE_DEBUG_STACKOVERFLOW
 -	select HAVE_DMA_API_DEBUG
 -	select HAVE_DMA_CONTIGUOUS
  	select HAVE_DYNAMIC_FTRACE
  	select HAVE_DYNAMIC_FTRACE_WITH_REGS
 -	select HAVE_EBPF_JIT			if X86_64
 -	select HAVE_EFFICIENT_UNALIGNED_ACCESS
 -	select HAVE_EXIT_THREAD
 -	select HAVE_FENTRY			if X86_64 || DYNAMIC_FTRACE
 -	select HAVE_FTRACE_MCOUNT_RECORD
 -	select HAVE_FUNCTION_GRAPH_TRACER
  	select HAVE_FUNCTION_TRACER
 -	select HAVE_GCC_PLUGINS
 -	select HAVE_HW_BREAKPOINT
 -	select HAVE_IDE
 -	select HAVE_IOREMAP_PROT
 -	select HAVE_IRQ_EXIT_ON_IRQ_STACK	if X86_64
 -	select HAVE_IRQ_TIME_ACCOUNTING
 -	select HAVE_KERNEL_BZIP2
 +	select HAVE_FUNCTION_GRAPH_TRACER
 +	select HAVE_FUNCTION_GRAPH_FP_TEST
 +	select HAVE_SYSCALL_TRACEPOINTS
 +	select SYSCTL_EXCEPTION_TRACE
 +	select HAVE_KVM
 +	select HAVE_ARCH_KGDB
 +	select HAVE_ARCH_TRACEHOOK
 +	select HAVE_GENERIC_DMA_COHERENT if X86_32
 +	select HAVE_EFFICIENT_UNALIGNED_ACCESS
 +	select USER_STACKTRACE_SUPPORT
 +	select HAVE_REGS_AND_STACK_ACCESS_API
 +	select HAVE_DMA_API_DEBUG
  	select HAVE_KERNEL_GZIP
 -	select HAVE_KERNEL_LZ4
 +	select HAVE_KERNEL_BZIP2
  	select HAVE_KERNEL_LZMA
 -	select HAVE_KERNEL_LZO
  	select HAVE_KERNEL_XZ
 -	select HAVE_KPROBES
 -	select HAVE_KPROBES_ON_FTRACE
 -	select HAVE_KRETPROBES
 -	select HAVE_KVM
 -	select HAVE_LIVEPATCH			if X86_64
 -	select HAVE_MEMBLOCK
 -	select HAVE_MEMBLOCK_NODE_MAP
 +	select HAVE_KERNEL_LZO
 +	select HAVE_HW_BREAKPOINT
  	select HAVE_MIXED_BREAKPOINTS_REGS
 -	select HAVE_NMI
 -	select HAVE_OPROFILE
 -	select HAVE_OPTPROBES
 -	select HAVE_PCSPKR_PLATFORM
 -	select HAVE_PERF_EVENTS
 +	select PERF_EVENTS
  	select HAVE_PERF_EVENTS_NMI
 -	select HAVE_HARDLOCKUP_DETECTOR_PERF	if PERF_EVENTS && HAVE_PERF_EVENTS_NMI
  	select HAVE_PERF_REGS
  	select HAVE_PERF_USER_STACK_DUMP
++<<<<<<< HEAD
 +	select HAVE_DEBUG_KMEMLEAK
 +	select ANON_INODES
 +	select HAVE_ALIGNED_STRUCT_PAGE if SLUB
 +	select HAVE_CMPXCHG_LOCAL
 +	select HAVE_CMPXCHG_DOUBLE
 +	select HAVE_ARCH_KMEMCHECK
++=======
+ 	select HAVE_RCU_TABLE_FREE
+ 	select HAVE_REGS_AND_STACK_ACCESS_API
+ 	select HAVE_RELIABLE_STACKTRACE		if X86_64 && FRAME_POINTER && STACK_VALIDATION
+ 	select HAVE_STACK_VALIDATION		if X86_64
+ 	select HAVE_SYSCALL_TRACEPOINTS
+ 	select HAVE_UNSTABLE_SCHED_CLOCK
++>>>>>>> 9e52fc2b50de (x86/mm: Enable RCU based page table freeing (CONFIG_HAVE_RCU_TABLE_FREE=y))
  	select HAVE_USER_RETURN_NOTIFIER
 -	select IRQ_FORCED_THREADING
 -	select PCI_LOCKLESS_CONFIG
 -	select PERF_EVENTS
 -	select RTC_LIB
 -	select RTC_MC146818_LIB
 +	select ARCH_HAS_ELF_RANDOMIZE
 +	select HAVE_ARCH_JUMP_LABEL
 +	select HAVE_TEXT_POKE_SMP
 +	select HAVE_GENERIC_HARDIRQS
 +	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
  	select SPARSE_IRQ
 -	select SRCU
 -	select SYSCTL_EXCEPTION_TRACE
 -	select THREAD_INFO_IN_TASK
 -	select USER_STACKTRACE_SUPPORT
 +	select GENERIC_FIND_FIRST_BIT
 +	select GENERIC_IRQ_PROBE
 +	select GENERIC_PENDING_IRQ if SMP
 +	select GENERIC_IRQ_SHOW
 +	select GENERIC_CLOCKEVENTS_MIN_ADJUST
 +	select IRQ_FORCED_THREADING
 +	select USE_GENERIC_SMP_HELPERS if SMP
 +	select HAVE_BPF_JIT if X86_64
 +	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
 +	select HAVE_ARCH_HUGE_VMAP if X86_64 || (X86_32 && X86_PAE)
 +	select CLKEVT_I8253
 +	select ARCH_HAVE_NMI_SAFE_CMPXCHG
 +	select GENERIC_IOMAP
 +	select DCACHE_WORD_ACCESS
 +	select GENERIC_SMP_IDLE_THREAD
 +	select ARCH_WANT_IPC_PARSE_VERSION if X86_32
 +	select HAVE_ARCH_SECCOMP_FILTER
 +	select BUILDTIME_EXTABLE_SORT
 +	select GENERIC_CMOS_UPDATE
 +	select HAVE_ARCH_SOFT_DIRTY
 +	select GENERIC_CLOCKEVENTS
 +	select ARCH_CLOCKSOURCE_DATA if X86_64
 +	select CLOCKSOURCE_VALIDATE_LAST_CYCLE
 +	select GENERIC_CLOCKEVENTS_BROADCAST if X86_64 || (X86_32 && X86_LOCAL_APIC)
 +	select GENERIC_TIME_VSYSCALL if X86_64
 +	select KTIME_SCALAR if X86_32
 +	select GENERIC_STRNCPY_FROM_USER
 +	select GENERIC_STRNLEN_USER
 +	select HAVE_CONTEXT_TRACKING if X86_64
 +	select HAVE_IRQ_TIME_ACCOUNTING
  	select VIRT_TO_BUS
 -	select X86_FEATURE_NAMES		if PROC_FS
 +	select MODULES_USE_ELF_REL if X86_32
 +	select MODULES_USE_ELF_RELA if X86_64
 +	select CLONE_BACKWARDS if X86_32
 +	select ARCH_USE_BUILTIN_BSWAP
 +	select ARCH_USE_QUEUED_SPINLOCKS
 +	select ARCH_USE_QUEUED_RWLOCKS
 +	select OLD_SIGSUSPEND3 if X86_32 || IA32_EMULATION
 +	select OLD_SIGACTION if X86_32
 +	select COMPAT_OLD_SIGACTION if IA32_EMULATION
 +	select RTC_LIB
 +	select HAVE_CC_STACKPROTECTOR
 +	select HAVE_STACK_VALIDATION if X86_64
  
  config INSTRUCTION_DECODER
  	def_bool y
diff --cc arch/x86/mm/pgtable.c
index 78194902ac3a,218834a3e9ad..000000000000
--- a/arch/x86/mm/pgtable.c
+++ b/arch/x86/mm/pgtable.c
@@@ -56,10 -56,10 +56,10 @@@ void ___pte_free_tlb(struct mmu_gather 
  {
  	pgtable_page_dtor(pte);
  	paravirt_release_pte(page_to_pfn(pte));
- 	tlb_remove_page(tlb, pte);
+ 	tlb_remove_table(tlb, pte);
  }
  
 -#if CONFIG_PGTABLE_LEVELS > 2
 +#if PAGETABLE_LEVELS > 2
  void ___pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmd)
  {
  	struct page *page = virt_to_page(pmd);
@@@ -72,17 -72,25 +72,30 @@@
  	tlb->need_flush_all = 1;
  #endif
  	pgtable_pmd_page_dtor(page);
- 	tlb_remove_page(tlb, page);
+ 	tlb_remove_table(tlb, page);
  }
  
 -#if CONFIG_PGTABLE_LEVELS > 3
 +#if PAGETABLE_LEVELS > 3
  void ___pud_free_tlb(struct mmu_gather *tlb, pud_t *pud)
  {
  	paravirt_release_pud(__pa(pud) >> PAGE_SHIFT);
- 	tlb_remove_page(tlb, virt_to_page(pud));
+ 	tlb_remove_table(tlb, virt_to_page(pud));
  }
++<<<<<<< HEAD
 +#endif	/* PAGETABLE_LEVELS > 3 */
 +#endif	/* PAGETABLE_LEVELS > 2 */
++=======
+ 
+ #if CONFIG_PGTABLE_LEVELS > 4
+ void ___p4d_free_tlb(struct mmu_gather *tlb, p4d_t *p4d)
+ {
+ 	paravirt_release_p4d(__pa(p4d) >> PAGE_SHIFT);
+ 	tlb_remove_table(tlb, virt_to_page(p4d));
+ }
+ #endif	/* CONFIG_PGTABLE_LEVELS > 4 */
+ #endif	/* CONFIG_PGTABLE_LEVELS > 3 */
+ #endif	/* CONFIG_PGTABLE_LEVELS > 2 */
++>>>>>>> 9e52fc2b50de (x86/mm: Enable RCU based page table freeing (CONFIG_HAVE_RCU_TABLE_FREE=y))
  
  static inline void pgd_list_add(pgd_t *pgd)
  {
* Unmerged path arch/x86/Kconfig
diff --git a/arch/x86/include/asm/tlb.h b/arch/x86/include/asm/tlb.h
index c7797307fc2b..79a4ca6a9606 100644
--- a/arch/x86/include/asm/tlb.h
+++ b/arch/x86/include/asm/tlb.h
@@ -15,4 +15,18 @@
 
 #include <asm-generic/tlb.h>
 
+/*
+ * While x86 architecture in general requires an IPI to perform TLB
+ * shootdown, enablement code for several hypervisors overrides
+ * .flush_tlb_others hook in pv_mmu_ops and implements it by issuing
+ * a hypercall. To keep software pagetable walkers safe in this case we
+ * switch to RCU based table free (HAVE_RCU_TABLE_FREE). See the comment
+ * below 'ifdef CONFIG_HAVE_RCU_TABLE_FREE' in include/asm-generic/tlb.h
+ * for more details.
+ */
+static inline void __tlb_remove_table(void *table)
+{
+	free_page_and_swap_cache(table);
+}
+
 #endif /* _ASM_X86_TLB_H */
* Unmerged path arch/x86/mm/pgtable.c
