ACPI: fix NULL pointer dereference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit fc68f42aa737dc15e7665a4101d4168aadb8e4c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fc68f42a.failed

Commit 71f642833284 ("ACPI: utils: Fix reference counting in
for_each_acpi_dev_match()") started doing "acpi_dev_put()" on a pointer
that was possibly NULL.  That fails miserably, because that helper
inline function is not set up to handle that case.

Just make acpi_dev_put() silently accept a NULL pointer, rather than
calling down to put_device() with an invalid offset off that NULL
pointer.

Link: https://lore.kernel.org/lkml/a607c149-6bf6-0fd0-0e31-100378504da2@kernel.dk/
Reported-and-tested-by: Jens Axboe <axboe@kernel.dk>
	Tested-by: Daniel Scally <djrscally@gmail.com>
	Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fc68f42aa737dc15e7665a4101d4168aadb8e4c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/acpi/acpi_bus.h
diff --cc include/acpi/acpi_bus.h
index cc435b3d5b75,13d93371790e..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -638,9 -685,51 +638,52 @@@ static inline bool acpi_device_can_wake
  
  static inline bool acpi_device_can_poweroff(struct acpi_device *adev)
  {
 -	return adev->power.states[ACPI_STATE_D3_COLD].flags.valid ||
 -		((acpi_gbl_FADT.header.revision < 6) &&
 -		adev->power.states[ACPI_STATE_D3_HOT].flags.explicit_set);
 +	return adev->power.states[ACPI_STATE_D3_COLD].flags.os_accessible;
  }
  
++<<<<<<< HEAD
++=======
+ bool acpi_dev_hid_uid_match(struct acpi_device *adev, const char *hid2, const char *uid2);
+ 
+ void acpi_dev_clear_dependencies(struct acpi_device *supplier);
+ struct acpi_device *acpi_dev_get_first_consumer_dev(struct acpi_device *supplier);
+ struct acpi_device *
+ acpi_dev_get_next_match_dev(struct acpi_device *adev, const char *hid, const char *uid, s64 hrv);
+ struct acpi_device *
+ acpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv);
+ 
+ /**
+  * for_each_acpi_dev_match - iterate over ACPI devices that matching the criteria
+  * @adev: pointer to the matching ACPI device, NULL at the end of the loop
+  * @hid: Hardware ID of the device.
+  * @uid: Unique ID of the device, pass NULL to not check _UID
+  * @hrv: Hardware Revision of the device, pass -1 to not check _HRV
+  *
+  * The caller is responsible for invoking acpi_dev_put() on the returned device.
+  */
+ #define for_each_acpi_dev_match(adev, hid, uid, hrv)			\
+ 	for (adev = acpi_dev_get_first_match_dev(hid, uid, hrv);	\
+ 	     adev;							\
+ 	     adev = acpi_dev_get_next_match_dev(adev, hid, uid, hrv))
+ 
+ static inline struct acpi_device *acpi_dev_get(struct acpi_device *adev)
+ {
+ 	return adev ? to_acpi_device(get_device(&adev->dev)) : NULL;
+ }
+ 
+ static inline void acpi_dev_put(struct acpi_device *adev)
+ {
+ 	if (adev)
+ 		put_device(&adev->dev);
+ }
+ 
+ struct acpi_device *acpi_bus_get_acpi_device(acpi_handle handle);
+ 
+ static inline void acpi_bus_put_acpi_device(struct acpi_device *adev)
+ {
+ 	acpi_dev_put(adev);
+ }
++>>>>>>> fc68f42aa737 (ACPI: fix NULL pointer dereference)
  #else	/* CONFIG_ACPI */
  
  static inline int register_acpi_bus_type(void *bus) { return 0; }
* Unmerged path include/acpi/acpi_bus.h
