ibmvnic: Update main crq initialization and release

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit f992887c34a15d40a257c73fe59800826bcaf1a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f992887c.failed

Update the initialization and release routines for the crq queue so that
we validate the crq queue.

Additionally this updates the naming of the init and release routines
for the crq queue to drop the ibmvnic prefix. This matches the naming
for similar routines in the driver

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f992887c34a15d40a257c73fe59800826bcaf1a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 6a325c61534d,01ab60f4a92a..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -110,6 -109,11 +110,14 @@@ static int ibmvnic_poll(struct napi_str
  static void send_map_query(struct ibmvnic_adapter *adapter);
  static void send_request_map(struct ibmvnic_adapter *, dma_addr_t, __be32, u8);
  static void send_request_unmap(struct ibmvnic_adapter *, u8);
++<<<<<<< HEAD
++=======
+ static void send_login(struct ibmvnic_adapter *adapter);
+ static void send_cap_queries(struct ibmvnic_adapter *adapter);
+ static int init_sub_crq_irqs(struct ibmvnic_adapter *adapter);
+ static int ibmvnic_init(struct ibmvnic_adapter *);
+ static void release_crq_queue(struct ibmvnic_adapter *);
++>>>>>>> f992887c34a1 (ibmvnic: Update main crq initialization and release)
  
  struct ibmvnic_stat {
  	char name[ETH_GSTRING_LEN];
@@@ -538,6 -590,50 +546,53 @@@ static int ibmvnic_close(struct net_dev
  		adapter->bounce_buffer = NULL;
  	}
  
++<<<<<<< HEAD
++=======
+ 	tx_scrqs = be32_to_cpu(adapter->login_rsp_buf->num_txsubm_subcrqs);
+ 	for (i = 0; i < tx_scrqs; i++) {
+ 		struct ibmvnic_tx_pool *tx_pool = &adapter->tx_pool[i];
+ 
+ 		kfree(tx_pool->tx_buff);
+ 		free_long_term_buff(adapter, &tx_pool->long_term_buff);
+ 		kfree(tx_pool->free_map);
+ 	}
+ 	kfree(adapter->tx_pool);
+ 	adapter->tx_pool = NULL;
+ 
+ 	rx_scrqs = be32_to_cpu(adapter->login_rsp_buf->num_rxadd_subcrqs);
+ 	for (i = 0; i < rx_scrqs; i++) {
+ 		struct ibmvnic_rx_pool *rx_pool = &adapter->rx_pool[i];
+ 
+ 		free_rx_pool(adapter, rx_pool);
+ 		free_long_term_buff(adapter, &rx_pool->long_term_buff);
+ 	}
+ 	kfree(adapter->rx_pool);
+ 	adapter->rx_pool = NULL;
+ 
+ 	release_sub_crqs(adapter);
+ 	release_crq_queue(adapter);
+ 
+ 	if (adapter->stats_token)
+ 		dma_unmap_single(dev, adapter->stats_token,
+ 				 sizeof(struct ibmvnic_statistics),
+ 				 DMA_FROM_DEVICE);
+ }
+ 
+ static int ibmvnic_close(struct net_device *netdev)
+ {
+ 	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
+ 	union ibmvnic_crq crq;
+ 	int i;
+ 
+ 	adapter->closing = true;
+ 
+ 	for (i = 0; i < adapter->req_rx_queues; i++)
+ 		napi_disable(&adapter->napi[i]);
+ 
+ 	if (!adapter->failover)
+ 		netif_tx_stop_all_queues(netdev);
+ 
++>>>>>>> f992887c34a1 (ibmvnic: Update main crq initialization and release)
  	memset(&crq, 0, sizeof(crq));
  	crq.logical_link_state.first = IBMVNIC_CRQ_CMD;
  	crq.logical_link_state.cmd = LOGICAL_LINK_STATE;
@@@ -3758,9 -3224,40 +3821,44 @@@ task_failed
  	dev_err(dev, "Passive initialization was not successful\n");
  }
  
++<<<<<<< HEAD
++=======
+ static int ibmvnic_init(struct ibmvnic_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->vdev->dev;
+ 	unsigned long timeout = msecs_to_jiffies(30000);
+ 	int rc;
+ 
+ 	rc = init_crq_queue(adapter);
+ 	if (rc) {
+ 		dev_err(dev, "Couldn't initialize crq. rc=%d\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	adapter->stats_token = dma_map_single(dev, &adapter->stats,
+ 				      sizeof(struct ibmvnic_statistics),
+ 				      DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(dev, adapter->stats_token)) {
+ 		release_crq_queue(adapter);
+ 		dev_err(dev, "Couldn't map stats buffer\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	init_completion(&adapter->init_done);
+ 	ibmvnic_send_crq_init(adapter);
+ 	if (!wait_for_completion_timeout(&adapter->init_done, timeout)) {
+ 		dev_err(dev, "Initialization sequence timed out\n");
+ 		release_crq_queue(adapter);
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f992887c34a1 (ibmvnic: Update main crq initialization and release)
  static int ibmvnic_probe(struct vio_dev *dev, const struct vio_device_id *id)
  {
 +	unsigned long timeout = msecs_to_jiffies(30000);
  	struct ibmvnic_adapter *adapter;
  	struct net_device *netdev;
  	unsigned char *mac_addr_p;
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
