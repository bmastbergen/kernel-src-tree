qed: Cleaner seperation of LL2 inputs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 13c547717231aad7e1635004ae3f698e5e78d6d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/13c54771.failed

A LL2 connection [qed_ll2_info] has a sub-structure of type qed_ll2_conn
that contain various inputs for ll2 acquisition, but the connection also
utilizes a couple of other inputs.

Restructure the input structure to include all the inputs and refactor
the code necessary to populate those.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 13c547717231aad7e1635004ae3f698e5e78d6d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_ll2.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_ll2.c
index b1ff824f44b2,fcf4ea98e0bf..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_ll2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_ll2.c
@@@ -987,64 -939,6 +939,67 @@@ static void qed_ll2_stop_ooo(struct qed
  	*handle = QED_LL2_UNUSED_HANDLE;
  }
  
++<<<<<<< HEAD
 +static int qed_ll2_start_ooo(struct qed_dev *cdev,
 +			     struct qed_ll2_params *params)
 +{
 +	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
 +	u8 *handle = &hwfn->pf_params.iscsi_pf_params.ll2_ooo_queue_id;
 +	struct qed_ll2_conn ll2_info;
 +	int rc;
 +
 +	ll2_info.conn_type = QED_LL2_TYPE_ISCSI_OOO;
 +	ll2_info.mtu = params->mtu;
 +	ll2_info.rx_drop_ttl0_flg = params->drop_ttl0_packets;
 +	ll2_info.rx_vlan_removal_en = params->rx_vlan_stripping;
 +	ll2_info.tx_tc = OOO_LB_TC;
 +	ll2_info.tx_dest = CORE_TX_DEST_LB;
 +
 +	rc = qed_ll2_acquire_connection(hwfn, &ll2_info,
 +					QED_LL2_RX_SIZE, QED_LL2_TX_SIZE,
 +					handle);
 +	if (rc) {
 +		DP_INFO(cdev, "Failed to acquire LL2 OOO connection\n");
 +		goto out;
 +	}
 +
 +	rc = qed_ll2_establish_connection(hwfn, *handle);
 +	if (rc) {
 +		DP_INFO(cdev, "Failed to establist LL2 OOO connection\n");
 +		goto fail;
 +	}
 +
 +	return 0;
 +
 +fail:
 +	qed_ll2_release_connection(hwfn, *handle);
 +out:
 +	*handle = QED_LL2_UNUSED_HANDLE;
 +	return rc;
 +}
 +#else /* IS_ENABLED(CONFIG_QED_ISCSI) */
 +static int qed_ll2_lb_rxq_completion(struct qed_hwfn *p_hwfn,
 +				     void *p_cookie) { return -EINVAL; }
 +static int qed_ll2_lb_txq_completion(struct qed_hwfn *p_hwfn,
 +				     void *p_cookie) { return -EINVAL; }
 +static inline int
 +qed_ll2_acquire_connection_ooo(struct qed_hwfn *p_hwfn,
 +			       struct qed_ll2_info *p_ll2_info,
 +			       u16 rx_num_ooo_buffers, u16 mtu) { return 0; }
 +static inline void
 +qed_ll2_establish_connection_ooo(struct qed_hwfn *p_hwfn,
 +				 struct qed_ll2_info *p_ll2_conn) { return; }
 +static inline void
 +qed_ll2_release_connection_ooo(struct qed_hwfn *p_hwfn,
 +			       struct qed_ll2_info *p_ll2_conn) { return; }
 +static inline void qed_ll2_stop_ooo(struct qed_dev *cdev) { return; }
 +static inline int qed_ll2_start_ooo(struct qed_dev *cdev,
 +				    struct qed_ll2_params *params)
 +				    { return -EINVAL; }
 +#endif /* IS_ENABLED(CONFIG_QED_ISCSI) */
 +
++=======
++>>>>>>> 13c547717231 (qed: Cleaner seperation of LL2 inputs)
  static int qed_sp_ll2_rx_queue_start(struct qed_hwfn *p_hwfn,
  				     struct qed_ll2_info *p_ll2_conn,
  				     u8 action_on_error)
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ll2.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_ll2.h b/drivers/net/ethernet/qlogic/qed/qed_ll2.h
index 96af50b733e8..3caaad53c958 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_ll2.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_ll2.h
@@ -47,17 +47,6 @@
 
 #define QED_MAX_NUM_OF_LL2_CONNECTIONS                    (4)
 
-enum qed_ll2_conn_type {
-	QED_LL2_TYPE_FCOE,
-	QED_LL2_TYPE_ISCSI,
-	QED_LL2_TYPE_TEST,
-	QED_LL2_TYPE_ISCSI_OOO,
-	QED_LL2_TYPE_RESERVED2,
-	QED_LL2_TYPE_ROCE,
-	QED_LL2_TYPE_RESERVED3,
-	MAX_QED_LL2_RX_CONN_TYPE
-};
-
 struct qed_ll2_rx_packet {
 	struct list_head list_entry;
 	struct core_rx_bd_with_buff_len *rxq_bd;
@@ -123,27 +112,17 @@ struct qed_ll2_tx_queue {
 	bool b_completing_packet;
 };
 
-struct qed_ll2_conn {
-	enum qed_ll2_conn_type conn_type;
-	u16 mtu;
-	u8 rx_drop_ttl0_flg;
-	u8 rx_vlan_removal_en;
-	u8 tx_tc;
-	enum core_tx_dest tx_dest;
-	enum core_error_handle ai_err_packet_too_big;
-	enum core_error_handle ai_err_no_buf;
-	u8 gsi_enable;
-};
-
 struct qed_ll2_info {
 	/* Lock protecting the state of LL2 */
 	struct mutex mutex;
-	struct qed_ll2_conn conn;
+
+	struct qed_ll2_acquire_data_inputs input;
 	u32 cid;
 	u8 my_id;
 	u8 queue_id;
 	u8 tx_stats_id;
 	bool b_active;
+	enum core_tx_dest tx_dest;
 	u8 tx_stats_en;
 	struct qed_ll2_rx_queue rx_queue;
 	struct qed_ll2_tx_queue tx_queue;
@@ -154,20 +133,13 @@ struct qed_ll2_info {
  *        starts rx & tx (if relevant) queues pair. Provides
  *        connecion handler as output parameter.
  *
- * @param p_hwfn
- * @param p_params		Contain various configuration properties
- * @param rx_num_desc
- * @param tx_num_desc
- *
- * @param p_connection_handle  Output container for LL2 connection's handle
  *
- * @return 0 on success, failure otherwise
+ * @param p_hwfn
+ * @param data - describes connection parameters
+ * @return int
  */
 int qed_ll2_acquire_connection(struct qed_hwfn *p_hwfn,
-			       struct qed_ll2_conn *p_params,
-			       u16 rx_num_desc,
-			       u16 tx_num_desc,
-			       u8 *p_connection_handle);
+			       struct qed_ll2_acquire_data *data);
 
 /**
  * @brief qed_ll2_establish_connection - start previously
diff --git a/drivers/net/ethernet/qlogic/qed/qed_roce.c b/drivers/net/ethernet/qlogic/qed/qed_roce.c
index 92968ecf3bc4..d87f6564c2c2 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_roce.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_roce.c
@@ -2821,7 +2821,7 @@ static int qed_roce_ll2_start(struct qed_dev *cdev,
 {
 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
 	struct qed_roce_ll2_info *roce_ll2;
-	struct qed_ll2_conn ll2_params;
+	struct qed_ll2_acquire_data data;
 	int rc;
 
 	if (!params) {
@@ -2847,25 +2847,26 @@ static int qed_roce_ll2_start(struct qed_dev *cdev,
 		DP_ERR(cdev, "qed roce ll2 start: failed memory allocation\n");
 		return -ENOMEM;
 	}
+
 	roce_ll2->handle = QED_LL2_UNUSED_HANDLE;
 	roce_ll2->cbs = params->cbs;
 	roce_ll2->cb_cookie = params->cb_cookie;
 	mutex_init(&roce_ll2->lock);
 
-	memset(&ll2_params, 0, sizeof(ll2_params));
-	ll2_params.conn_type = QED_LL2_TYPE_ROCE;
-	ll2_params.mtu = params->mtu;
-	ll2_params.rx_drop_ttl0_flg = true;
-	ll2_params.rx_vlan_removal_en = false;
-	ll2_params.tx_dest = CORE_TX_DEST_NW;
-	ll2_params.ai_err_packet_too_big = LL2_DROP_PACKET;
-	ll2_params.ai_err_no_buf = LL2_DROP_PACKET;
-	ll2_params.gsi_enable = true;
-
-	rc = qed_ll2_acquire_connection(QED_LEADING_HWFN(cdev), &ll2_params,
-					params->max_rx_buffers,
-					params->max_tx_buffers,
-					&roce_ll2->handle);
+	memset(&data, 0, sizeof(data));
+	data.input.conn_type = QED_LL2_TYPE_ROCE;
+	data.input.mtu = params->mtu;
+	data.input.rx_num_desc = params->max_rx_buffers;
+	data.input.tx_num_desc = params->max_tx_buffers;
+	data.input.rx_drop_ttl0_flg = true;
+	data.input.rx_vlan_removal_en = false;
+	data.input.tx_dest = QED_LL2_TX_DEST_NW;
+	data.input.ai_err_packet_too_big = LL2_DROP_PACKET;
+	data.input.ai_err_no_buf = LL2_DROP_PACKET;
+	data.p_connection_handle = &roce_ll2->handle;
+	data.input.gsi_enable = true;
+
+	rc = qed_ll2_acquire_connection(QED_LEADING_HWFN(cdev), &data);
 	if (rc) {
 		DP_ERR(cdev,
 		       "qed roce ll2 start: failed to acquire LL2 connection (rc=%d)\n",
diff --git a/include/linux/qed/qed_ll2_if.h b/include/linux/qed/qed_ll2_if.h
index 056ac007dd12..a1f63eca430a 100644
--- a/include/linux/qed/qed_ll2_if.h
+++ b/include/linux/qed/qed_ll2_if.h
@@ -43,6 +43,17 @@
 #include <linux/slab.h>
 #include <linux/qed/qed_if.h>
 
+enum qed_ll2_conn_type {
+	QED_LL2_TYPE_FCOE,
+	QED_LL2_TYPE_ISCSI,
+	QED_LL2_TYPE_TEST,
+	QED_LL2_TYPE_ISCSI_OOO,
+	QED_LL2_TYPE_RESERVED2,
+	QED_LL2_TYPE_ROCE,
+	QED_LL2_TYPE_RESERVED3,
+	MAX_QED_LL2_RX_CONN_TYPE
+};
+
 enum qed_ll2_roce_flavor_type {
 	QED_LL2_ROCE,
 	QED_LL2_RROCE,
@@ -55,6 +66,12 @@ enum qed_ll2_tx_dest {
 	QED_LL2_TX_DEST_MAX
 };
 
+enum qed_ll2_error_handle {
+	QED_LL2_DROP_PACKET,
+	QED_LL2_DO_NOTHING,
+	QED_LL2_ASSERT,
+};
+
 struct qed_ll2_stats {
 	u64 gsi_invalid_hdr;
 	u64 gsi_invalid_pkt_length;
@@ -105,6 +122,28 @@ struct qed_ll2_comp_rx_data {
 	} u;
 };
 
+struct qed_ll2_acquire_data_inputs {
+	enum qed_ll2_conn_type conn_type;
+	u16 mtu;
+	u16 rx_num_desc;
+	u16 rx_num_ooo_buffers;
+	u8 rx_drop_ttl0_flg;
+	u8 rx_vlan_removal_en;
+	u16 tx_num_desc;
+	u8 tx_max_bds_per_packet;
+	u8 tx_tc;
+	enum qed_ll2_tx_dest tx_dest;
+	enum qed_ll2_error_handle ai_err_packet_too_big;
+	enum qed_ll2_error_handle ai_err_no_buf;
+	u8 gsi_enable;
+};
+
+struct qed_ll2_acquire_data {
+	struct qed_ll2_acquire_data_inputs input;
+	/* Output container for LL2 connection's handle */
+	u8 *p_connection_handle;
+};
+
 struct qed_ll2_tx_pkt_info {
 	void *cookie;
 	dma_addr_t first_frag;
