pipe: fix limit checking in alloc_pipe_info()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael Kerrisk (man-pages) <mtk.manpages@gmail.com>
commit a005ca0e6813e1d796a7422a7e31d8b8d6555df1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a005ca0e.failed

The limit checking in alloc_pipe_info() (used by pipe(2) and when
opening a FIFO) has the following problems:

(1) When checking capacity required for the new pipe, the checks against
    the limit in /proc/sys/fs/pipe-user-pages-{soft,hard} are made
    against existing consumption, and exclude the memory required for
    the new pipe capacity. As a consequence: (1) the memory allocation
    throttling provided by the soft limit does not kick in quite as
    early as it should, and (2) the user can overrun the hard limit.

(2) As currently implemented, accounting and checking against the limits
    is done as follows:

    (a) Test whether the user has exceeded the limit.
    (b) Make new pipe buffer allocation.
    (c) Account new allocation against the limits.

    This is racey. Multiple processes may pass point (a) simultaneously,
    and then allocate pipe buffers that are accounted for only in step
    (c).  The race means that the user's pipe buffer allocation could be
    pushed over the limit (by an arbitrary amount, depending on how
    unlucky we were in the race). [Thanks to Vegard Nossum for spotting
    this point, which I had missed.]

This patch addresses the above problems as follows:

* Alter the checks against limits to include the memory required for the
  new pipe.
* Re-order the accounting step so that it precedes the buffer allocation.
  If the accounting step determines that a limit has been reached, revert
  the accounting and cause the operation to fail.

Link: http://lkml.kernel.org/r/8ff3e9f9-23f6-510c-644f-8e70cd1c0bd9@gmail.com
	Signed-off-by: Michael Kerrisk <mtk.manpages@gmail.com>
	Reviewed-by: Vegard Nossum <vegard.nossum@oracle.com>
	Cc: Willy Tarreau <w@1wt.eu>
	Cc: <socketpair@gmail.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Jens Axboe <axboe@fb.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a005ca0e6813e1d796a7422a7e31d8b8d6555df1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/pipe.c
diff --cc fs/pipe.c
index 771f837999b4,83a292464de7..000000000000
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@@ -823,31 -622,40 +823,61 @@@ static bool too_many_pipe_buffers_hard(
  struct pipe_inode_info *alloc_pipe_info(void)
  {
  	struct pipe_inode_info *pipe;
 -	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
 -	struct user_struct *user = get_current_user();
  
 -	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
 -	if (pipe == NULL)
 -		goto out_free_uid;
 +	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
 +	if (pipe) {
 +		unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
 +		struct user_struct *user = get_current_user();
  
++<<<<<<< HEAD
 +		if (!too_many_pipe_buffers_hard(user)) {
 +			if (too_many_pipe_buffers_soft(user))
 +				pipe_bufs = 1;
 +			pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);
 +		}
 +
 +		if (pipe->bufs) {
 +			init_waitqueue_head(&pipe->wait);
 +			pipe->r_counter = pipe->w_counter = 1;
 +			pipe->buffers = pipe_bufs;
 +			pipe->user = user;
 +			account_pipe_buffers(user, 0, pipe_bufs);
 +			mutex_init(&pipe->mutex);
 +			return pipe;
 +		}
 +		free_uid(user);
 +		kfree(pipe);
 +	}
 +
++=======
+ 	account_pipe_buffers(user, 0, pipe_bufs);
+ 
+ 	if (too_many_pipe_buffers_soft(user)) {
+ 		account_pipe_buffers(user, pipe_bufs, 1);
+ 		pipe_bufs = 1;
+ 	}
+ 
+ 	if (too_many_pipe_buffers_hard(user))
+ 		goto out_revert_acct;
+ 
+ 	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
+ 			     GFP_KERNEL_ACCOUNT);
+ 
+ 	if (pipe->bufs) {
+ 		init_waitqueue_head(&pipe->wait);
+ 		pipe->r_counter = pipe->w_counter = 1;
+ 		pipe->buffers = pipe_bufs;
+ 		pipe->user = user;
+ 		mutex_init(&pipe->mutex);
+ 		return pipe;
+ 	}
+ 
+ out_revert_acct:
+ 	account_pipe_buffers(user, pipe_bufs, 0);
+ 	kfree(pipe);
+ out_free_uid:
+ 	free_uid(user);
++>>>>>>> a005ca0e6813 (pipe: fix limit checking in alloc_pipe_info())
  	return NULL;
  }
  
* Unmerged path fs/pipe.c
