mlxsw: spectrum: Offload multichain TC rules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit 45b62742df6a27fba71f799cd1a2f721e1c0d584
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/45b62742.failed

Reflect chain index coming down from TC core and create a ruleset per
chain. Note that only chain 0, being the implicit chain, is bound to the
device for processing. The rest of chains have to be "jumped-to" by
actions.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 45b62742df6a27fba71f799cd1a2f721e1c0d584)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 3aac4cc5ecc4,6e641db16702..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -1707,42 -1693,72 +1707,100 @@@ static void mlxsw_sp_port_del_cls_match
  	kfree(mall_tc_entry);
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_setup_tc(struct net_device *dev, u32 handle,
 +			     __be16 proto, struct tc_to_netdev *tc)
++=======
+ static int mlxsw_sp_setup_tc_cls_matchall(struct mlxsw_sp_port *mlxsw_sp_port,
+ 					  struct tc_cls_matchall_offload *f)
+ {
+ 	bool ingress;
+ 
+ 	if (is_classid_clsact_ingress(f->common.classid))
+ 		ingress = true;
+ 	else if (is_classid_clsact_egress(f->common.classid))
+ 		ingress = false;
+ 	else
+ 		return -EOPNOTSUPP;
+ 
+ 	if (f->common.chain_index)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_CLSMATCHALL_REPLACE:
+ 		return mlxsw_sp_port_add_cls_matchall(mlxsw_sp_port, f,
+ 						      ingress);
+ 	case TC_CLSMATCHALL_DESTROY:
+ 		mlxsw_sp_port_del_cls_matchall(mlxsw_sp_port, f);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int
+ mlxsw_sp_setup_tc_cls_flower(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			     struct tc_cls_flower_offload *f)
+ {
+ 	bool ingress;
+ 
+ 	if (is_classid_clsact_ingress(f->common.classid))
+ 		ingress = true;
+ 	else if (is_classid_clsact_egress(f->common.classid))
+ 		ingress = false;
+ 	else
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_CLSFLOWER_REPLACE:
+ 		return mlxsw_sp_flower_replace(mlxsw_sp_port, ingress, f);
+ 	case TC_CLSFLOWER_DESTROY:
+ 		mlxsw_sp_flower_destroy(mlxsw_sp_port, ingress, f);
+ 		return 0;
+ 	case TC_CLSFLOWER_STATS:
+ 		return mlxsw_sp_flower_stats(mlxsw_sp_port, ingress, f);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int mlxsw_sp_setup_tc(struct net_device *dev, enum tc_setup_type type,
+ 			     void *type_data)
++>>>>>>> 45b62742df6a (mlxsw: spectrum: Offload multichain TC rules)
  {
  	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);
 -
 -	switch (type) {
 -	case TC_SETUP_CLSMATCHALL:
 -		return mlxsw_sp_setup_tc_cls_matchall(mlxsw_sp_port, type_data);
 +	bool ingress = TC_H_MAJ(handle) == TC_H_MAJ(TC_H_INGRESS);
 +
 +	switch (tc->type) {
 +	case TC_SETUP_MATCHALL:
 +		switch (tc->cls_mall->command) {
 +		case TC_CLSMATCHALL_REPLACE:
 +			return mlxsw_sp_port_add_cls_matchall(mlxsw_sp_port,
 +							      proto,
 +							      tc->cls_mall,
 +							      ingress);
 +		case TC_CLSMATCHALL_DESTROY:
 +			mlxsw_sp_port_del_cls_matchall(mlxsw_sp_port,
 +						       tc->cls_mall);
 +			return 0;
 +		default:
 +			return -EINVAL;
 +		}
  	case TC_SETUP_CLSFLOWER:
 -		return mlxsw_sp_setup_tc_cls_flower(mlxsw_sp_port, type_data);
 -	default:
 -		return -EOPNOTSUPP;
 +		switch (tc->cls_flower->command) {
 +		case TC_CLSFLOWER_REPLACE:
 +			return mlxsw_sp_flower_replace(mlxsw_sp_port, ingress,
 +						       proto, tc->cls_flower);
 +		case TC_CLSFLOWER_DESTROY:
 +			mlxsw_sp_flower_destroy(mlxsw_sp_port, ingress,
 +						tc->cls_flower);
 +			return 0;
 +		default:
 +			return -EOPNOTSUPP;
 +		}
  	}
 +
 +	return -EOPNOTSUPP;
  }
  
  static const struct net_device_ops mlxsw_sp_port_netdev_ops = {
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
index 32ab6a76fff7,34872aa52073..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
@@@ -423,3 -435,39 +424,42 @@@ void mlxsw_sp_flower_destroy(struct mlx
  
  	mlxsw_sp_acl_ruleset_put(mlxsw_sp, ruleset);
  }
++<<<<<<< HEAD
++=======
+ 
+ int mlxsw_sp_flower_stats(struct mlxsw_sp_port *mlxsw_sp_port, bool ingress,
+ 			  struct tc_cls_flower_offload *f)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
+ 	struct mlxsw_sp_acl_ruleset *ruleset;
+ 	struct mlxsw_sp_acl_rule *rule;
+ 	u64 packets;
+ 	u64 lastuse;
+ 	u64 bytes;
+ 	int err;
+ 
+ 	ruleset = mlxsw_sp_acl_ruleset_get(mlxsw_sp, mlxsw_sp_port->dev,
+ 					   ingress, f->common.chain_index,
+ 					   MLXSW_SP_ACL_PROFILE_FLOWER);
+ 	if (WARN_ON(IS_ERR(ruleset)))
+ 		return -EINVAL;
+ 
+ 	rule = mlxsw_sp_acl_rule_lookup(mlxsw_sp, ruleset, f->cookie);
+ 	if (!rule)
+ 		return -EINVAL;
+ 
+ 	err = mlxsw_sp_acl_rule_get_stats(mlxsw_sp, rule, &packets, &bytes,
+ 					  &lastuse);
+ 	if (err)
+ 		goto err_rule_get_stats;
+ 
+ 	tcf_exts_stats_update(f->exts, bytes, packets, lastuse);
+ 
+ 	mlxsw_sp_acl_ruleset_put(mlxsw_sp, ruleset);
+ 	return 0;
+ 
+ err_rule_get_stats:
+ 	mlxsw_sp_acl_ruleset_put(mlxsw_sp, ruleset);
+ 	return err;
+ }
++>>>>>>> 45b62742df6a (mlxsw: spectrum: Offload multichain TC rules)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index e33337ab34c4..1a2dc07c866b 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@ -577,8 +577,8 @@ struct mlxsw_sp_acl_ops {
 struct mlxsw_sp_acl_ruleset;
 
 struct mlxsw_sp_acl_ruleset *
-mlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp,
-			 struct net_device *dev, bool ingress,
+mlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp, struct net_device *dev,
+			 bool ingress, u32 chain_index,
 			 enum mlxsw_sp_acl_profile profile);
 void mlxsw_sp_acl_ruleset_put(struct mlxsw_sp *mlxsw_sp,
 			      struct mlxsw_sp_acl_ruleset *ruleset);
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
index ccccd03a0129..973444f4afbc 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
@@ -73,6 +73,7 @@ struct mlxsw_afk *mlxsw_sp_acl_afk(struct mlxsw_sp_acl *acl)
 struct mlxsw_sp_acl_ruleset_ht_key {
 	struct net_device *dev; /* dev this ruleset is bound to */
 	bool ingress;
+	u32 chain_index;
 	const struct mlxsw_sp_acl_profile_ops *ops;
 };
 
@@ -155,7 +156,8 @@ static void mlxsw_sp_acl_ruleset_destroy(struct mlxsw_sp *mlxsw_sp,
 
 static int mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
 				     struct mlxsw_sp_acl_ruleset *ruleset,
-				     struct net_device *dev, bool ingress)
+				     struct net_device *dev, bool ingress,
+				     u32 chain_index)
 {
 	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
 	struct mlxsw_sp_acl *acl = mlxsw_sp->acl;
@@ -163,13 +165,20 @@ static int mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
 
 	ruleset->ht_key.dev = dev;
 	ruleset->ht_key.ingress = ingress;
+	ruleset->ht_key.chain_index = chain_index;
 	err = rhashtable_insert_fast(&acl->ruleset_ht, &ruleset->ht_node,
 				     mlxsw_sp_acl_ruleset_ht_params);
 	if (err)
 		return err;
-	err = ops->ruleset_bind(mlxsw_sp, ruleset->priv, dev, ingress);
-	if (err)
-		goto err_ops_ruleset_bind;
+	if (!ruleset->ht_key.chain_index) {
+		/* We only need ruleset with chain index 0, the implicit one,
+		 * to be directly bound to device. The rest of the rulesets
+		 * are bound by "Goto action set".
+		 */
+		err = ops->ruleset_bind(mlxsw_sp, ruleset->priv, dev, ingress);
+		if (err)
+			goto err_ops_ruleset_bind;
+	}
 	return 0;
 
 err_ops_ruleset_bind:
@@ -184,7 +193,8 @@ static void mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,
 	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
 	struct mlxsw_sp_acl *acl = mlxsw_sp->acl;
 
-	ops->ruleset_unbind(mlxsw_sp, ruleset->priv);
+	if (!ruleset->ht_key.chain_index)
+		ops->ruleset_unbind(mlxsw_sp, ruleset->priv);
 	rhashtable_remove_fast(&acl->ruleset_ht, &ruleset->ht_node,
 			       mlxsw_sp_acl_ruleset_ht_params);
 }
@@ -204,8 +214,8 @@ static void mlxsw_sp_acl_ruleset_ref_dec(struct mlxsw_sp *mlxsw_sp,
 }
 
 struct mlxsw_sp_acl_ruleset *
-mlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp,
-			 struct net_device *dev, bool ingress,
+mlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp, struct net_device *dev,
+			 bool ingress, u32 chain_index,
 			 enum mlxsw_sp_acl_profile profile)
 {
 	const struct mlxsw_sp_acl_profile_ops *ops;
@@ -221,6 +231,7 @@ mlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp,
 	memset(&ht_key, 0, sizeof(ht_key));
 	ht_key.dev = dev;
 	ht_key.ingress = ingress;
+	ht_key.chain_index = chain_index;
 	ht_key.ops = ops;
 	ruleset = rhashtable_lookup_fast(&acl->ruleset_ht, &ht_key,
 					 mlxsw_sp_acl_ruleset_ht_params);
@@ -231,7 +242,8 @@ mlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp,
 	ruleset = mlxsw_sp_acl_ruleset_create(mlxsw_sp, ops);
 	if (IS_ERR(ruleset))
 		return ruleset;
-	err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, ruleset, dev, ingress);
+	err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, ruleset, dev,
+					ingress, chain_index);
 	if (err)
 		goto err_ruleset_bind;
 	return ruleset;
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
