ptrace: use fsuid, fsgid, effective creds for fs access checks

jira LE-1907
cve CVE-2017-14140
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jann Horn <jann@thejh.net>
commit caaee6234d05a58c5b4d05e7bf766131b810a657
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/caaee623.failed

By checking the effective credentials instead of the real UID / permitted
capabilities, ensure that the calling process actually intended to use its
credentials.

To ensure that all ptrace checks use the correct caller credentials (e.g.
in case out-of-tree code or newly added code omits the PTRACE_MODE_*CREDS
flag), use two new flags and require one of them to be set.

The problem was that when a privileged task had temporarily dropped its
privileges, e.g.  by calling setreuid(0, user_uid), with the intent to
perform following syscalls with the credentials of a user, it still passed
ptrace access checks that the user would not be able to pass.

While an attacker should not be able to convince the privileged task to
perform a ptrace() syscall, this is a problem because the ptrace access
check is reused for things in procfs.

In particular, the following somewhat interesting procfs entries only rely
on ptrace access checks:

 /proc/$pid/stat - uses the check for determining whether pointers
     should be visible, useful for bypassing ASLR
 /proc/$pid/maps - also useful for bypassing ASLR
 /proc/$pid/cwd - useful for gaining access to restricted
     directories that contain files with lax permissions, e.g. in
     this scenario:
     lrwxrwxrwx root root /proc/13020/cwd -> /root/foobar
     drwx------ root root /root
     drwxr-xr-x root root /root/foobar
     -rw-r--r-- root root /root/foobar/secret

Therefore, on a system where a root-owned mode 6755 binary changes its
effective credentials as described and then dumps a user-specified file,
this could be used by an attacker to reveal the memory layout of root's
processes or reveal the contents of files he is not allowed to access
(through /proc/$pid/cwd).

[akpm@linux-foundation.org: fix warning]
	Signed-off-by: Jann Horn <jann@thejh.net>
	Acked-by: Kees Cook <keescook@chromium.org>
	Cc: Casey Schaufler <casey@schaufler-ca.com>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: James Morris <james.l.morris@oracle.com>
	Cc: "Serge E. Hallyn" <serge.hallyn@ubuntu.com>
	Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Cc: Willy Tarreau <w@1wt.eu>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit caaee6234d05a58c5b4d05e7bf766131b810a657)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/base.c
#	fs/proc/namespaces.c
diff --cc fs/proc/base.c
index c36f34194d71,e665097c1da5..000000000000
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@@ -395,14 -396,14 +395,18 @@@ out_mmput
  }
  
  static const struct file_operations proc_pid_cmdline_ops = {
 -	.read	= proc_pid_cmdline_read,
 -	.llseek	= generic_file_llseek,
 +	.read   = proc_pid_cmdline_read,
 +	.llseek = generic_file_llseek,
  };
  
 -static int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,
 -			 struct pid *pid, struct task_struct *task)
 +static int proc_pid_auxv(struct task_struct *task, char *buffer)
  {
++<<<<<<< HEAD
 +	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ);
 +	int res = PTR_ERR(mm);
++=======
+ 	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);
++>>>>>>> caaee6234d05 (ptrace: use fsuid, fsgid, effective creds for fs access checks)
  	if (mm && !IS_ERR(mm)) {
  		unsigned int nwords = 0;
  		do {
@@@ -430,13 -430,13 +434,19 @@@ static int proc_pid_wchan(struct task_s
  
  	wchan = get_wchan(task);
  
++<<<<<<< HEAD
 +	if (lookup_symbol_name(wchan, symname) < 0)
 +		if (!ptrace_may_access(task, PTRACE_MODE_READ))
 +			return 0;
 +		else
 +			return sprintf(buffer, "%lu", wchan);
++=======
+ 	if (wchan && ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)
+ 			&& !lookup_symbol_name(wchan, symname))
+ 		seq_printf(m, "%s", symname);
++>>>>>>> caaee6234d05 (ptrace: use fsuid, fsgid, effective creds for fs access checks)
  	else
 -		seq_putc(m, '0');
 -
 -	return 0;
 +		return sprintf(buffer, "%s", symname);
  }
  #endif /* CONFIG_KALLSYMS */
  
@@@ -2071,11 -2013,11 +2081,16 @@@ static struct dentry *proc_map_files_lo
  	if (!task)
  		goto out;
  
++<<<<<<< HEAD
 +	result = ERR_PTR(-EACCES);
 +	if (!ptrace_may_access(task, PTRACE_MODE_READ))
++=======
+ 	result = -EACCES;
+ 	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
++>>>>>>> caaee6234d05 (ptrace: use fsuid, fsgid, effective creds for fs access checks)
  		goto out_put_task;
  
 -	result = -ENOENT;
 +	result = ERR_PTR(-ENOENT);
  	if (dname_to_vma_addr(dentry, &vm_start, &vm_end))
  		goto out_put_task;
  
diff --cc fs/proc/namespaces.c
index 4cb44c180b55,276f12431dbf..000000000000
--- a/fs/proc/namespaces.c
+++ b/fs/proc/namespaces.c
@@@ -121,26 -39,19 +121,33 @@@ static void *proc_ns_follow_link(struc
  	struct path ns_path;
  	void *error = ERR_PTR(-EACCES);
  
 -	if (!dentry)
 -		return ERR_PTR(-ECHILD);
 -
  	task = get_proc_task(inode);
  	if (!task)
 -		return error;
 +		goto out;
 +
++<<<<<<< HEAD
 +	if (!ptrace_may_access(task, PTRACE_MODE_READ))
 +		goto out_put_task;
  
 +	ns_path.dentry = proc_ns_get_dentry(sb, task, ei->ns.ns_ops);
 +	if (IS_ERR(ns_path.dentry)) {
 +		error = ERR_CAST(ns_path.dentry);
 +		goto out_put_task;
++=======
+ 	if (ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {
+ 		error = ns_get_path(&ns_path, task, ns_ops);
+ 		if (!error)
+ 			nd_jump_link(&ns_path);
++>>>>>>> caaee6234d05 (ptrace: use fsuid, fsgid, effective creds for fs access checks)
  	}
 +
 +	ns_path.mnt = mntget(nd->path.mnt);
 +	nd_jump_link(nd, &ns_path);
 +	error = NULL;
 +
 +out_put_task:
  	put_task_struct(task);
 +out:
  	return error;
  }
  
@@@ -156,29 -65,15 +163,37 @@@ static int proc_ns_readlink(struct dent
  
  	task = get_proc_task(inode);
  	if (!task)
 -		return res;
 +		goto out;
 +
++<<<<<<< HEAD
 +	if (!ptrace_may_access(task, PTRACE_MODE_READ))
 +		goto out_put_task;
  
 +	len = -ENOENT;
 +	ns = ns_ops->get(task);
 +	if (!ns)
 +		goto out_put_task;
 +
 +	snprintf(name, sizeof(name), "%s:[%u]", ns_ops->name, ns_ops->inum(ns));
 +	len = strlen(name);
 +
 +	if (len > buflen)
 +		len = buflen;
 +	if (copy_to_user(buffer, name, len))
 +		len = -EFAULT;
 +
 +	ns_ops->put(ns);
 +out_put_task:
++=======
+ 	if (ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {
+ 		res = ns_get_name(name, sizeof(name), task, ns_ops);
+ 		if (res >= 0)
+ 			res = readlink_copy(buffer, buflen, name);
+ 	}
++>>>>>>> caaee6234d05 (ptrace: use fsuid, fsgid, effective creds for fs access checks)
  	put_task_struct(task);
 -	return res;
 +out:
 +	return len;
  }
  
  static const struct inode_operations proc_ns_link_inode_operations = {
diff --git a/fs/proc/array.c b/fs/proc/array.c
index e72efe817a60..7431516d5eaf 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -422,7 +422,7 @@ static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
-	permitted = ptrace_may_access(task, PTRACE_MODE_READ | PTRACE_MODE_NOAUDIT);
+	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
 	if (mm) {
 		vsize = task_vsize(mm);
* Unmerged path fs/proc/base.c
* Unmerged path fs/proc/namespaces.c
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index 29e2041e91db..36ae74b4a637 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -58,7 +58,29 @@ extern void exit_ptrace(struct task_struct *tracer);
 #define PTRACE_MODE_READ	0x01
 #define PTRACE_MODE_ATTACH	0x02
 #define PTRACE_MODE_NOAUDIT	0x04
-/* Returns true on success, false on denial. */
+#define PTRACE_MODE_FSCREDS 0x08
+#define PTRACE_MODE_REALCREDS 0x10
+
+/* shorthands for READ/ATTACH and FSCREDS/REALCREDS combinations */
+#define PTRACE_MODE_READ_FSCREDS (PTRACE_MODE_READ | PTRACE_MODE_FSCREDS)
+#define PTRACE_MODE_READ_REALCREDS (PTRACE_MODE_READ | PTRACE_MODE_REALCREDS)
+#define PTRACE_MODE_ATTACH_FSCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS)
+#define PTRACE_MODE_ATTACH_REALCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS)
+
+/**
+ * ptrace_may_access - check whether the caller is permitted to access
+ * a target task.
+ * @task: target task
+ * @mode: selects type of access and caller credentials
+ *
+ * Returns true on success, false on denial.
+ *
+ * One of the flags PTRACE_MODE_FSCREDS and PTRACE_MODE_REALCREDS must
+ * be set in @mode to specify whether the access was requested through
+ * a filesystem syscall (should use effective capabilities and fsuid
+ * of the caller) or through an explicit syscall such as
+ * process_vm_writev or ptrace (and should use the real credentials).
+ */
 extern bool ptrace_may_access(struct task_struct *task, unsigned int mode);
 
 static inline int ptrace_reparented(struct task_struct *child)
diff --git a/kernel/events/core.c b/kernel/events/core.c
index c7982922c47d..abf37c78608d 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -3745,7 +3745,7 @@ find_lively_task_by_vpid(pid_t vpid)
 
 	/* Reuse ptrace permission checks for now. */
 	err = -EACCES;
-	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
 		goto errout;
 
 	return task;
diff --git a/kernel/futex.c b/kernel/futex.c
index 96b663cd803c..5bc2f9dc92b6 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -2785,7 +2785,7 @@ SYSCALL_DEFINE3(get_robust_list, int, pid,
 	}
 
 	ret = -EPERM;
-	if (!ptrace_may_access(p, PTRACE_MODE_READ))
+	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))
 		goto err_unlock;
 
 	head = p->robust_list;
diff --git a/kernel/futex_compat.c b/kernel/futex_compat.c
index f9f44fd4d34d..3888617a1f9e 100644
--- a/kernel/futex_compat.c
+++ b/kernel/futex_compat.c
@@ -155,7 +155,7 @@ COMPAT_SYSCALL_DEFINE3(get_robust_list, int, pid,
 	}
 
 	ret = -EPERM;
-	if (!ptrace_may_access(p, PTRACE_MODE_READ))
+	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))
 		goto err_unlock;
 
 	head = p->compat_robust_list;
diff --git a/kernel/kcmp.c b/kernel/kcmp.c
index e30ac0fe61c3..8199e5fcc677 100644
--- a/kernel/kcmp.c
+++ b/kernel/kcmp.c
@@ -121,8 +121,8 @@ SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,
 			&task2->signal->cred_guard_mutex);
 	if (ret)
 		goto err;
-	if (!ptrace_may_access(task1, PTRACE_MODE_READ) ||
-	    !ptrace_may_access(task2, PTRACE_MODE_READ)) {
+	if (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||
+	    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {
 		ret = -EPERM;
 		goto err_unlock;
 	}
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 1db5135025ba..7db609afb45f 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -225,6 +225,14 @@ static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)
 static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 {
 	const struct cred *cred = current_cred(), *tcred;
+	int dumpable = 0;
+	kuid_t caller_uid;
+	kgid_t caller_gid;
+
+	if (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {
+		WARN(1, "denying ptrace access check without PTRACE_MODE_*CREDS\n");
+		return -EPERM;
+	}
 
 	/* May we inspect the given task?
 	 * This check is used both for attaching with ptrace
@@ -234,18 +242,33 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	 * because setting up the necessary parent/child relationship
 	 * or halting the specified task is impossible.
 	 */
-	int dumpable = 0;
+
 	/* Don't let security modules deny introspection */
 	if (same_thread_group(task, current))
 		return 0;
 	rcu_read_lock();
+	if (mode & PTRACE_MODE_FSCREDS) {
+		caller_uid = cred->fsuid;
+		caller_gid = cred->fsgid;
+	} else {
+		/*
+		 * Using the euid would make more sense here, but something
+		 * in userland might rely on the old behavior, and this
+		 * shouldn't be a security problem since
+		 * PTRACE_MODE_REALCREDS implies that the caller explicitly
+		 * used a syscall that requests access to another process
+		 * (and not a filesystem syscall to procfs).
+		 */
+		caller_uid = cred->uid;
+		caller_gid = cred->gid;
+	}
 	tcred = __task_cred(task);
-	if (uid_eq(cred->uid, tcred->euid) &&
-	    uid_eq(cred->uid, tcred->suid) &&
-	    uid_eq(cred->uid, tcred->uid)  &&
-	    gid_eq(cred->gid, tcred->egid) &&
-	    gid_eq(cred->gid, tcred->sgid) &&
-	    gid_eq(cred->gid, tcred->gid))
+	if (uid_eq(caller_uid, tcred->euid) &&
+	    uid_eq(caller_uid, tcred->suid) &&
+	    uid_eq(caller_uid, tcred->uid)  &&
+	    gid_eq(caller_gid, tcred->egid) &&
+	    gid_eq(caller_gid, tcred->sgid) &&
+	    gid_eq(caller_gid, tcred->gid))
 		goto ok;
 	if (ptrace_has_cap(tcred->user_ns, mode))
 		goto ok;
@@ -312,7 +335,7 @@ static int ptrace_attach(struct task_struct *task, long request,
 		goto out;
 
 	task_lock(task);
-	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH);
+	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);
 	task_unlock(task);
 	if (retval)
 		goto unlock_creds;
diff --git a/mm/process_vm_access.c b/mm/process_vm_access.c
index b7140e4b7916..5a020522b50d 100644
--- a/mm/process_vm_access.c
+++ b/mm/process_vm_access.c
@@ -198,7 +198,7 @@ static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,
 		goto free_proc_pages;
 	}
 
-	mm = mm_access(task, PTRACE_MODE_ATTACH);
+	mm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);
 	if (!mm || IS_ERR(mm)) {
 		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
 		/*
diff --git a/security/commoncap.c b/security/commoncap.c
index 9fb6de81bb8f..46dfee9b08cb 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -142,12 +142,17 @@ int cap_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
 	int ret = 0;
 	const struct cred *cred, *child_cred;
+	const kernel_cap_t *caller_caps;
 
 	rcu_read_lock();
 	cred = current_cred();
 	child_cred = __task_cred(child);
+	if (mode & PTRACE_MODE_FSCREDS)
+		caller_caps = &cred->cap_effective;
+	else
+		caller_caps = &cred->cap_permitted;
 	if (cred->user_ns == child_cred->user_ns &&
-	    cap_issubset(child_cred->cap_permitted, cred->cap_permitted))
+	    cap_issubset(child_cred->cap_permitted, *caller_caps))
 		goto out;
 	if (ns_capable(child_cred->user_ns, CAP_SYS_PTRACE))
 		goto out;
