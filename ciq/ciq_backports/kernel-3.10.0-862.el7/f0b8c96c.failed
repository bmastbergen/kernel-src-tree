ibmvnic: Create init and release routines for the bounce buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit f0b8c96cbcc5fbd4f66abcbf4bc442a1066d8899
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f0b8c96c.failed

Move the handling of initialization and releasing the bounce buffer to their
own init and release routines.

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f0b8c96cbcc5fbd4f66abcbf4bc442a1066d8899)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 6a325c61534d,c3e5305604c8..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -368,6 -372,82 +368,85 @@@ static void free_rx_pool(struct ibmvnic
  	pool->rx_buff = NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static void release_bounce_buffer(struct ibmvnic_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->vdev->dev;
+ 
+ 	if (!adapter->bounce_buffer)
+ 		return;
+ 
+ 	if (!dma_mapping_error(dev, adapter->bounce_buffer_dma)) {
+ 		dma_unmap_single(dev, adapter->bounce_buffer_dma,
+ 				 adapter->bounce_buffer_size,
+ 				 DMA_BIDIRECTIONAL);
+ 		adapter->bounce_buffer_dma = DMA_ERROR_CODE;
+ 	}
+ 
+ 	kfree(adapter->bounce_buffer);
+ 	adapter->bounce_buffer = NULL;
+ }
+ 
+ static int init_bounce_buffer(struct net_device *netdev)
+ {
+ 	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
+ 	struct device *dev = &adapter->vdev->dev;
+ 	char *buf;
+ 	int buf_sz;
+ 	dma_addr_t map_addr;
+ 
+ 	buf_sz = (netdev->mtu + ETH_HLEN - 1) / PAGE_SIZE + 1;
+ 	buf = kmalloc(adapter->bounce_buffer_size, GFP_KERNEL);
+ 	if (!buf)
+ 		return -1;
+ 
+ 	map_addr = dma_map_single(dev, buf, buf_sz, DMA_TO_DEVICE);
+ 	if (dma_mapping_error(dev, map_addr)) {
+ 		dev_err(dev, "Couldn't map bounce buffer\n");
+ 		kfree(buf);
+ 		return -1;
+ 	}
+ 
+ 	adapter->bounce_buffer = buf;
+ 	adapter->bounce_buffer_size = buf_sz;
+ 	adapter->bounce_buffer_dma = map_addr;
+ 	return 0;
+ }
+ 
+ static int ibmvnic_login(struct net_device *netdev)
+ {
+ 	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
+ 	unsigned long timeout = msecs_to_jiffies(30000);
+ 	struct device *dev = &adapter->vdev->dev;
+ 
+ 	do {
+ 		if (adapter->renegotiate) {
+ 			adapter->renegotiate = false;
+ 			release_sub_crqs_no_irqs(adapter);
+ 
+ 			reinit_completion(&adapter->init_done);
+ 			send_cap_queries(adapter);
+ 			if (!wait_for_completion_timeout(&adapter->init_done,
+ 							 timeout)) {
+ 				dev_err(dev, "Capabilities query timeout\n");
+ 				return -1;
+ 			}
+ 		}
+ 
+ 		reinit_completion(&adapter->init_done);
+ 		send_login(adapter);
+ 		if (!wait_for_completion_timeout(&adapter->init_done,
+ 						 timeout)) {
+ 			dev_err(dev, "Login timeout\n");
+ 			return -1;
+ 		}
+ 	} while (adapter->renegotiate);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f0b8c96cbcc5 (ibmvnic: Create init and release routines for the bounce buffer)
  static int ibmvnic_open(struct net_device *netdev)
  {
  	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
@@@ -518,6 -649,6 +586,7 @@@ static int ibmvnic_close(struct net_dev
  	union ibmvnic_crq crq;
  	int i;
  
++<<<<<<< HEAD
  	adapter->closing = true;
  
  	for (i = 0; i < adapter->req_rx_queues; i++)
@@@ -526,18 -657,6 +595,21 @@@
  	if (!adapter->failover)
  		netif_tx_stop_all_queues(netdev);
  
 +	if (adapter->bounce_buffer) {
 +		if (!dma_mapping_error(dev, adapter->bounce_buffer_dma)) {
 +			dma_unmap_single(&adapter->vdev->dev,
 +					 adapter->bounce_buffer_dma,
 +					 adapter->bounce_buffer_size,
 +					 DMA_BIDIRECTIONAL);
 +			adapter->bounce_buffer_dma = DMA_ERROR_CODE;
 +		}
 +		kfree(adapter->bounce_buffer);
 +		adapter->bounce_buffer = NULL;
 +	}
++=======
++	release_bounce_buffer(adapter);
++>>>>>>> f0b8c96cbcc5 (ibmvnic: Create init and release routines for the bounce buffer)
 +
  	memset(&crq, 0, sizeof(crq));
  	crq.logical_link_state.first = IBMVNIC_CRQ_CMD;
  	crq.logical_link_state.cmd = LOGICAL_LINK_STATE;
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
