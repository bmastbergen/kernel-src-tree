KEYS: load key flags and expiry time atomically in proc_keys_show()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Biggers <ebiggers@google.com>
commit ab5c69f01313c80df948e4f768efe616258f85f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ab5c69f0.failed

In proc_keys_show(), the key semaphore is not held, so the key ->flags
and ->expiry can be changed concurrently.  We therefore should read them
atomically just once.

	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
(cherry picked from commit ab5c69f01313c80df948e4f768efe616258f85f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/proc.c
diff --cc security/keys/proc.c
index 350f5f61c840,6d1fcbba1e09..000000000000
--- a/security/keys/proc.c
+++ b/security/keys/proc.c
@@@ -185,9 -179,12 +185,11 @@@ static int proc_keys_show(struct seq_fi
  	struct rb_node *_p = v;
  	struct key *key = rb_entry(_p, struct key, serial_node);
  	struct timespec now;
+ 	time_t expiry;
  	unsigned long timo;
+ 	unsigned long flags;
  	key_ref_t key_ref, skey_ref;
  	char xbuf[16];
 -	short state;
  	int rc;
  
  	struct keyring_search_context ctx = {
@@@ -246,19 -240,22 +249,38 @@@
  			sprintf(xbuf, "%luw", timo / (60*60*24*7));
  	}
  
++<<<<<<< HEAD
 +#define showflag(KEY, LETTER, FLAG) \
 +	(test_bit(FLAG,	&(KEY)->flags) ? LETTER : '-')
++=======
+ 	state = key_read_state(key);
  
+ #define showflag(FLAGS, LETTER, FLAG) \
+ 	((FLAGS & (1 << FLAG)) ? LETTER : '-')
++>>>>>>> ab5c69f01313 (KEYS: load key flags and expiry time atomically in proc_keys_show())
+ 
+ 	flags = READ_ONCE(key->flags);
  	seq_printf(m, "%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s ",
  		   key->serial,
++<<<<<<< HEAD
 +		   showflag(key, 'I', KEY_FLAG_INSTANTIATED),
 +		   showflag(key, 'R', KEY_FLAG_REVOKED),
 +		   showflag(key, 'D', KEY_FLAG_DEAD),
 +		   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),
 +		   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),
 +		   showflag(key, 'N', KEY_FLAG_NEGATIVE),
 +		   showflag(key, 'i', KEY_FLAG_INVALIDATED),
 +		   atomic_read(&key->usage),
++=======
+ 		   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',
+ 		   showflag(flags, 'R', KEY_FLAG_REVOKED),
+ 		   showflag(flags, 'D', KEY_FLAG_DEAD),
+ 		   showflag(flags, 'Q', KEY_FLAG_IN_QUOTA),
+ 		   showflag(flags, 'U', KEY_FLAG_USER_CONSTRUCT),
+ 		   state < 0 ? 'N' : '-',
+ 		   showflag(flags, 'i', KEY_FLAG_INVALIDATED),
+ 		   refcount_read(&key->usage),
++>>>>>>> ab5c69f01313 (KEYS: load key flags and expiry time atomically in proc_keys_show())
  		   xbuf,
  		   key->perm,
  		   from_kuid_munged(seq_user_ns(m), key->uid),
* Unmerged path security/keys/proc.c
