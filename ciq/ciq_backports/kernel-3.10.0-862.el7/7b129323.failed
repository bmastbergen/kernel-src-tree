fsnotify: Add group pointer in fsnotify_init_mark()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 7b1293234084ddb6469c4e9a5ef818f399b5786b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7b129323.failed

Currently we initialize mark->group only in fsnotify_add_mark_lock().
However we will need to access fsnotify_ops of corresponding group from
fsnotify_put_mark() so we need mark->group initialized earlier. Do that
in fsnotify_init_mark() which has a consequence that once
fsnotify_init_mark() is called on a mark, the mark has to be destroyed
by fsnotify_put_mark().

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 7b1293234084ddb6469c4e9a5ef818f399b5786b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fsnotify_backend.h
#	kernel/audit_tree.c
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,a64518e36bd5..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -331,23 -338,19 +331,39 @@@ extern struct fsnotify_event *fsnotify_
  
  /* functions used to manipulate the marks attached to inodes */
  
++<<<<<<< HEAD
 +/* run all marks associated with a vfsmount and update mnt->mnt_fsnotify_mask */
 +extern void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt);
 +/* run all marks associated with an inode and update inode->i_fsnotify_mask */
 +extern void fsnotify_recalc_inode_mask(struct inode *inode);
 +extern void fsnotify_init_mark(struct fsnotify_mark *mark, void (*free_mark)(struct fsnotify_mark *mark));
 +/* find (and take a reference) to a mark associated with group and inode */
 +extern struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group, struct inode *inode);
 +/* find (and take a reference) to a mark associated with group and vfsmount */
 +extern struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group, struct vfsmount *mnt);
 +/* set the ignored_mask of a mark */
 +extern void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask);
 +/* set the mask of a mark (might pin the object into memory */
 +extern void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask);
 +/* attach the mark to both the group and the inode */
 +extern int fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,
 +			     struct inode *inode, struct vfsmount *mnt, int allow_dups);
 +extern int fsnotify_add_mark_locked(struct fsnotify_mark *mark, struct fsnotify_group *group,
++=======
+ /* Calculate mask of events for a list of marks */
+ extern void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
+ extern void fsnotify_init_mark(struct fsnotify_mark *mark,
+ 			       struct fsnotify_group *group,
+ 			       void (*free_mark)(struct fsnotify_mark *mark));
+ /* Find mark belonging to given group in the list of marks */
+ extern struct fsnotify_mark *fsnotify_find_mark(
+ 				struct fsnotify_mark_connector __rcu **connp,
+ 				struct fsnotify_group *group);
+ /* attach the mark to the inode or vfsmount */
+ extern int fsnotify_add_mark(struct fsnotify_mark *mark, struct inode *inode,
+ 			     struct vfsmount *mnt, int allow_dups);
+ extern int fsnotify_add_mark_locked(struct fsnotify_mark *mark,
++>>>>>>> 7b1293234084 (fsnotify: Add group pointer in fsnotify_init_mark())
  				    struct inode *inode, struct vfsmount *mnt, int allow_dups);
  /* given a group and a mark, flag mark to be freed when all references are dropped */
  extern void fsnotify_destroy_mark(struct fsnotify_mark *mark,
diff --cc kernel/audit_tree.c
index 4dfdb945bae9,da7f7a3e6a42..000000000000
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@@ -260,8 -287,8 +261,13 @@@ static void untag_chunk(struct node *p
  	if (!new)
  		goto Fallback;
  
++<<<<<<< HEAD
 +	if (fsnotify_add_mark_locked(&new->mark,
 +				     entry->group, entry->inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark_locked(&new->mark, entry->connector->inode,
+ 				     NULL, 1)) {
++>>>>>>> 7b1293234084 (fsnotify: Add group pointer in fsnotify_init_mark())
  		fsnotify_put_mark(&new->mark);
  		goto Fallback;
  	}
@@@ -402,7 -434,7 +408,11 @@@ static int tag_chunk(struct inode *inod
  	}
  
  	if (fsnotify_add_mark_locked(chunk_entry,
++<<<<<<< HEAD
 +				     old_entry->group, old_entry->inode, NULL, 1)) {
++=======
+ 			     old_entry->connector->inode, NULL, 1)) {
++>>>>>>> 7b1293234084 (fsnotify: Add group pointer in fsnotify_init_mark())
  		spin_unlock(&old_entry->lock);
  		mutex_unlock(&old_entry->group->mark_mutex);
  		fsnotify_put_mark(chunk_entry);
diff --git a/fs/notify/dnotify/dnotify.c b/fs/notify/dnotify/dnotify.c
index 38696275be90..c5f2cbf97371 100644
--- a/fs/notify/dnotify/dnotify.c
+++ b/fs/notify/dnotify/dnotify.c
@@ -308,7 +308,7 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
 
 	/* set up the new_fsn_mark and new_dn_mark */
 	new_fsn_mark = &new_dn_mark->fsn_mark;
-	fsnotify_init_mark(new_fsn_mark, dnotify_free_mark);
+	fsnotify_init_mark(new_fsn_mark, dnotify_group, dnotify_free_mark);
 	new_fsn_mark->mask = mask;
 	new_dn_mark->dn = NULL;
 
@@ -321,8 +321,7 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
 		dn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);
 		spin_lock(&fsn_mark->lock);
 	} else {
-		fsnotify_add_mark_locked(new_fsn_mark, dnotify_group, inode,
-					 NULL, 0);
+		fsnotify_add_mark_locked(new_fsn_mark, inode, NULL, 0);
 		spin_lock(&new_fsn_mark->lock);
 		fsn_mark = new_fsn_mark;
 		dn_mark = new_dn_mark;
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 0bc2e0fd9d85..76ccabd6281f 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -630,8 +630,8 @@ static struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,
 	if (!mark)
 		return ERR_PTR(-ENOMEM);
 
-	fsnotify_init_mark(mark, fanotify_free_mark);
-	ret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);
+	fsnotify_init_mark(mark, group, fanotify_free_mark);
+	ret = fsnotify_add_mark_locked(mark, inode, mnt, 0);
 	if (ret) {
 		fsnotify_put_mark(mark);
 		return ERR_PTR(ret);
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 9881b183eb6d..59e399af0d04 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -562,7 +562,7 @@ static int inotify_new_watch(struct fsnotify_group *group,
 	if (unlikely(!tmp_i_mark))
 		return -ENOMEM;
 
-	fsnotify_init_mark(&tmp_i_mark->fsn_mark, inotify_free_mark);
+	fsnotify_init_mark(&tmp_i_mark->fsn_mark, group, inotify_free_mark);
 	tmp_i_mark->fsn_mark.mask = mask;
 	tmp_i_mark->wd = -1;
 
@@ -575,8 +575,7 @@ static int inotify_new_watch(struct fsnotify_group *group,
 		goto out_err;
 
 	/* we are on the idr, now get on the inode */
-	ret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, group, inode,
-				       NULL, 0);
+	ret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, inode, NULL, 0);
 	if (ret) {
 		/* we failed to get on the inode, get off the idr */
 		inotify_remove_from_idr(group, tmp_i_mark);
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index 4fae28e73aa3..d7d46e645083 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -332,10 +332,10 @@ int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,
  * These marks may be used for the fsnotify backend to determine which
  * event types should be delivered to which group.
  */
-int fsnotify_add_mark_locked(struct fsnotify_mark *mark,
-			     struct fsnotify_group *group, struct inode *inode,
+int fsnotify_add_mark_locked(struct fsnotify_mark *mark, struct inode *inode,
 			     struct vfsmount *mnt, int allow_dups)
 {
+	struct fsnotify_group *group = mark->group;
 	int ret = 0;
 
 	BUG_ON(inode && mnt);
@@ -351,8 +351,6 @@ int fsnotify_add_mark_locked(struct fsnotify_mark *mark,
 	spin_lock(&mark->lock);
 	mark->flags |= FSNOTIFY_MARK_FLAG_ALIVE | FSNOTIFY_MARK_FLAG_ATTACHED;
 
-	fsnotify_get_group(group);
-	mark->group = group;
 	list_add(&mark->g_list, &group->marks_list);
 	atomic_inc(&group->num_marks);
 	fsnotify_get_mark(mark); /* for i_list and g_list */
@@ -388,12 +386,14 @@ err:
 	return ret;
 }
 
-int fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,
-		      struct inode *inode, struct vfsmount *mnt, int allow_dups)
+int fsnotify_add_mark(struct fsnotify_mark *mark, struct inode *inode,
+		      struct vfsmount *mnt, int allow_dups)
 {
 	int ret;
+	struct fsnotify_group *group = mark->group;
+
 	mutex_lock(&group->mark_mutex);
-	ret = fsnotify_add_mark_locked(mark, group, inode, mnt, allow_dups);
+	ret = fsnotify_add_mark_locked(mark, inode, mnt, allow_dups);
 	mutex_unlock(&group->mark_mutex);
 	return ret;
 }
@@ -486,12 +486,15 @@ void fsnotify_detach_group_marks(struct fsnotify_group *group)
  * Nothing fancy, just initialize lists and locks and counters.
  */
 void fsnotify_init_mark(struct fsnotify_mark *mark,
+			struct fsnotify_group *group,
 			void (*free_mark)(struct fsnotify_mark *mark))
 {
 	memset(mark, 0, sizeof(*mark));
 	spin_lock_init(&mark->lock);
 	atomic_set(&mark->refcnt, 1);
 	mark->free_mark = free_mark;
+	fsnotify_get_group(group);
+	mark->group = group;
 }
 
 /*
* Unmerged path include/linux/fsnotify_backend.h
diff --git a/kernel/audit_fsnotify.c b/kernel/audit_fsnotify.c
index a0a04ea5fb32..789f8973b76c 100644
--- a/kernel/audit_fsnotify.c
+++ b/kernel/audit_fsnotify.c
@@ -103,15 +103,16 @@ struct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pa
 		goto out;
 	}
 
-	fsnotify_init_mark(&audit_mark->mark, audit_fsnotify_free_mark);
+	fsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group,
+			   audit_fsnotify_free_mark);
 	audit_mark->mark.mask = AUDIT_FS_EVENTS;
 	audit_mark->path = pathname;
 	audit_update_mark(audit_mark, dentry->d_inode);
 	audit_mark->rule = krule;
 
-	ret = fsnotify_add_mark(&audit_mark->mark, audit_fsnotify_group, inode, NULL, true);
+	ret = fsnotify_add_mark(&audit_mark->mark, inode, NULL, true);
 	if (ret < 0) {
-		audit_fsnotify_mark_free(audit_mark);
+		fsnotify_put_mark(&audit_mark->mark);
 		audit_mark = ERR_PTR(ret);
 	}
 out:
* Unmerged path kernel/audit_tree.c
diff --git a/kernel/audit_watch.c b/kernel/audit_watch.c
index 30ee1f1108b2..bbfdf9b3441a 100644
--- a/kernel/audit_watch.c
+++ b/kernel/audit_watch.c
@@ -157,9 +157,10 @@ static struct audit_parent *audit_init_parent(struct path *path)
 
 	INIT_LIST_HEAD(&parent->watches);
 
-	fsnotify_init_mark(&parent->mark, audit_watch_free_mark);
+	fsnotify_init_mark(&parent->mark, audit_watch_group,
+			   audit_watch_free_mark);
 	parent->mark.mask = AUDIT_FS_WATCH;
-	ret = fsnotify_add_mark(&parent->mark, audit_watch_group, inode, NULL, 0);
+	ret = fsnotify_add_mark(&parent->mark, inode, NULL, 0);
 	if (ret < 0) {
 		audit_free_parent(parent);
 		return ERR_PTR(ret);
