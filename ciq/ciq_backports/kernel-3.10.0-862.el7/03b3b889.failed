fold d_kill() and d_free()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 03b3b889e79cdb6b806fc0ba9be0d71c186bbfaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/03b3b889.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 03b3b889e79cdb6b806fc0ba9be0d71c186bbfaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index e518a196fb4f,9b15c5c37277..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -224,24 -246,6 +224,27 @@@ static void __d_free(struct rcu_head *h
  	kmem_cache_free(dentry_cache, dentry); 
  }
  
++<<<<<<< HEAD
 +/*
 + * no locks, please.
 + */
 +static void d_free(struct dentry *dentry)
 +{
 +	struct rcu_head *p = (struct rcu_head *)&dentry->d_alias;
 +	BUG_ON((int)dentry->d_lockref.count > 0);
 +	this_cpu_dec(nr_dentry);
 +	if (dentry->d_op && dentry->d_op->d_release)
 +		dentry->d_op->d_release(dentry);
 +
 +	/* if dentry was never visible to RCU, immediate free is OK */
 +	if (!(dentry->d_flags & DCACHE_RCUACCESS))
 +		__d_free(p);
 +	else
 +		call_rcu(p, __d_free);
 +}
 +
++=======
++>>>>>>> 03b3b889e79c (fold d_kill() and d_free())
  /**
   * dentry_rcuwalk_barrier - invalidate in-progress rcu-walk lookups
   * @dentry: the target dentry
@@@ -329,63 -357,33 +332,64 @@@ static void __dentry_lru_del(struct den
  }
  
  /*
 - * These can only be called under the global LRU lock, ie during the
 - * callback for freeing the LRU list. "isolate" removes it from the
 - * LRU lists entirely, while shrink_move moves it to the indicated
 - * private list.
 + * Remove a dentry with references from the LRU.
   */
 -static void d_lru_isolate(struct dentry *dentry)
 +static void dentry_lru_del(struct dentry *dentry)
  {
 -	D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);
 -	dentry->d_flags &= ~DCACHE_LRU_LIST;
 -	this_cpu_dec(nr_dentry_unused);
 -	list_del_init(&dentry->d_lru);
 +	if (!list_empty(&dentry->d_lru)) {
 +		spin_lock(&dcache_lru_lock);
 +		__dentry_lru_del(dentry);
 +		spin_unlock(&dcache_lru_lock);
 +	}
  }
  
 -static void d_lru_shrink_move(struct dentry *dentry, struct list_head *list)
 +static void dentry_lru_move_list(struct dentry *dentry, struct list_head *list)
  {
 -	D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);
 -	dentry->d_flags |= DCACHE_SHRINK_LIST;
 -	list_move_tail(&dentry->d_lru, list);
 +	spin_lock(&dcache_lru_lock);
 +	if (list_empty(&dentry->d_lru)) {
 +		dentry->d_flags |= DCACHE_LRU_LIST;
 +		list_add_tail(&dentry->d_lru, list);
 +		dentry->d_sb->s_nr_dentry_unused++;
 +		dentry_stat.nr_unused++;
 +	} else {
 +		list_move_tail(&dentry->d_lru, list);
 +	}
 +	spin_unlock(&dcache_lru_lock);
  }
  
 -/*
 - * dentry_lru_(add|del)_list) must be called with d_lock held.
 +/**
++<<<<<<< HEAD
 + * d_kill - kill dentry and return parent
 + * @dentry: dentry to kill
 + * @parent: parent dentry
 + *
 + * The dentry must already be unhashed and removed from the LRU.
 + *
 + * If this is the root of the dentry tree, return NULL.
 + *
 + * dentry->d_lock and parent->d_lock must be held by caller, and are dropped by
 + * d_kill.
   */
 -static void dentry_lru_add(struct dentry *dentry)
 +static struct dentry *d_kill(struct dentry *dentry, struct dentry *parent)
 +	__releases(dentry->d_lock)
 +	__releases(parent->d_lock)
 +	__releases(dentry->d_inode->i_lock)
  {
 -	if (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))
 -		d_lru_add(dentry);
 +	__list_del_entry(&dentry->d_u.d_child);
 +	/*
 +	 * Inform d_walk() that we are no longer attached to the
 +	 * dentry tree
 +	 */
 +	dentry->d_flags |= DCACHE_DENTRY_KILLED;
 +	if (parent)
 +		spin_unlock(&parent->d_lock);
 +	dentry_iput(dentry);
 +	/*
 +	 * dentry_iput drops the locks, at which point nobody (except
 +	 * transient RCU lookups) can reach this dentry.
 +	 */
 +	d_free(dentry);
 +	return parent;
  }
  
  /*
@@@ -410,6 -403,6 +414,8 @@@ static void __d_shrink(struct dentry *d
  }
  
  /**
++=======
++>>>>>>> 03b3b889e79c (fold d_kill() and d_free())
   * d_drop - drop a dentry
   * @dentry: dentry to drop
   *
* Unmerged path fs/dcache.c
