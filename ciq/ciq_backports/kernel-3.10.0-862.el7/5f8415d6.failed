ovl: persistent overlay inode nlink for indexed inodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 5f8415d6b87ecb4ebf1bbd02c538694ebb7fb57c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5f8415d6.failed

With inodes index enabled, an overlay inode nlink counts the union of upper
and non-covered lower hardlinks. During the lifetime of a non-pure upper
inode, the following nlink modifying operations can happen:

1. Lower hardlink copy up
2. Upper hardlink created, unlinked or renamed over
3. Lower hardlink whiteout or renamed over

For the first, copy up case, the union nlink does not change, whether the
operation succeeds or fails, but the upper inode nlink may change.
Therefore, before copy up, we store the union nlink value relative to the
lower inode nlink in the index inode xattr trusted.overlay.nlink.

For the second, upper hardlink case, the union nlink should be incremented
or decremented IFF the operation succeeds, aligned with nlink change of the
upper inode. Therefore, before link/unlink/rename, we store the union nlink
value relative to the upper inode nlink in the index inode.

For the last, lower cover up case, we simplify things by preceding the
whiteout or cover up with copy up. This makes sure that there is an index
upper inode where the nlink xattr can be stored before the copied up upper
entry is unlink.

Return the overlay inode nlinks for indexed upper inodes on stat(2).

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 5f8415d6b87ecb4ebf1bbd02c538694ebb7fb57c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/dir.c
#	fs/overlayfs/inode.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,f193976560de..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -264,33 -233,170 +264,142 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
 -struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper)
 +static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
 +			      struct dentry *dentry, struct path *lowerpath,
 +			      struct kstat *stat, const char *link)
  {
 -	struct ovl_fh *fh;
 -	int fh_type, fh_len, dwords;
 -	void *buf;
 -	int buflen = MAX_HANDLE_SZ;
 -	uuid_t *uuid = &lower->d_sb->s_uuid;
 -
 -	buf = kmalloc(buflen, GFP_TEMPORARY);
 -	if (!buf)
 -		return ERR_PTR(-ENOMEM);
 +	struct inode *wdir = workdir->d_inode;
 +	struct inode *udir = upperdir->d_inode;
 +	struct dentry *newdentry = NULL;
 +	struct dentry *upper = NULL;
 +	umode_t mode = stat->mode;
 +	int err;
 +	const struct cred *old_creds = NULL;
 +	struct cred *new_creds = NULL;
  
 -	/*
 -	 * We encode a non-connectable file handle for non-dir, because we
 -	 * only need to find the lower inode number and we don't want to pay
 -	 * the price or reconnecting the dentry.
 -	 */
 -	dwords = buflen >> 2;
 -	fh_type = exportfs_encode_fh(lower, buf, &dwords, 0);
 -	buflen = (dwords << 2);
 -
 -	fh = ERR_PTR(-EIO);
 -	if (WARN_ON(fh_type < 0) ||
 -	    WARN_ON(buflen > MAX_HANDLE_SZ) ||
 -	    WARN_ON(fh_type == FILEID_INVALID))
 +	newdentry = ovl_lookup_temp(workdir, dentry);
 +	err = PTR_ERR(newdentry);
 +	if (IS_ERR(newdentry))
  		goto out;
  
++<<<<<<< HEAD
 +	upper = lookup_one_len(dentry->d_name.name, upperdir,
 +			       dentry->d_name.len);
 +	err = PTR_ERR(upper);
++=======
+ 	BUILD_BUG_ON(MAX_HANDLE_SZ + offsetof(struct ovl_fh, fid) > 255);
+ 	fh_len = offsetof(struct ovl_fh, fid) + buflen;
+ 	fh = kmalloc(fh_len, GFP_KERNEL);
+ 	if (!fh) {
+ 		fh = ERR_PTR(-ENOMEM);
+ 		goto out;
+ 	}
+ 
+ 	fh->version = OVL_FH_VERSION;
+ 	fh->magic = OVL_FH_MAGIC;
+ 	fh->type = fh_type;
+ 	fh->flags = OVL_FH_FLAG_CPU_ENDIAN;
+ 	/*
+ 	 * When we will want to decode an overlay dentry from this handle
+ 	 * and all layers are on the same fs, if we get a disconncted real
+ 	 * dentry when we decode fid, the only way to tell if we should assign
+ 	 * it to upperdentry or to lowerstack is by checking this flag.
+ 	 */
+ 	if (is_upper)
+ 		fh->flags |= OVL_FH_FLAG_PATH_UPPER;
+ 	fh->len = fh_len;
+ 	fh->uuid = *uuid;
+ 	memcpy(fh->fid, buf, buflen);
+ 
+ out:
+ 	kfree(buf);
+ 	return fh;
+ }
+ 
+ static int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+ 			  struct dentry *upper)
+ {
+ 	const struct ovl_fh *fh = NULL;
+ 	int err;
+ 
+ 	/*
+ 	 * When lower layer doesn't support export operations store a 'null' fh,
+ 	 * so we can use the overlay.origin xattr to distignuish between a copy
+ 	 * up and a pure upper inode.
+ 	 */
+ 	if (ovl_can_decode_fh(lower->d_sb)) {
+ 		fh = ovl_encode_fh(lower, false);
+ 		if (IS_ERR(fh))
+ 			return PTR_ERR(fh);
+ 	}
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_ORIGIN, fh,
+ 				 fh ? fh->len : 0, 0);
+ 	kfree(fh);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_link_up(struct dentry *parent, struct dentry *dentry)
+ {
+ 	int err;
+ 	struct dentry *upper;
+ 	struct dentry *upperdir = ovl_dentry_upper(parent);
+ 	struct inode *udir = d_inode(upperdir);
+ 
+ 	err = ovl_set_nlink_lower(dentry);
+ 	if (err)
+ 		return err;
+ 
+ 	inode_lock_nested(udir, I_MUTEX_PARENT);
+ 	upper = lookup_one_len(dentry->d_name.name, upperdir,
+ 			       dentry->d_name.len);
+ 	err = PTR_ERR(upper);
+ 	if (!IS_ERR(upper)) {
+ 		err = ovl_do_link(ovl_dentry_upper(dentry), udir, upper, true);
+ 		dput(upper);
+ 
+ 		if (!err)
+ 			ovl_dentry_set_upper_alias(dentry);
+ 	}
+ 	inode_unlock(udir);
+ 	ovl_set_nlink_upper(dentry);
+ 
+ 	return err;
+ }
+ 
+ struct ovl_copy_up_ctx {
+ 	struct dentry *parent;
+ 	struct dentry *dentry;
+ 	struct path lowerpath;
+ 	struct kstat stat;
+ 	struct kstat pstat;
+ 	const char *link;
+ 	struct dentry *destdir;
+ 	struct qstr destname;
+ 	struct dentry *workdir;
+ 	bool tmpfile;
+ 	bool origin;
+ };
+ 
+ static int ovl_install_temp(struct ovl_copy_up_ctx *c, struct dentry *temp,
+ 			    struct dentry **newdentry)
+ {
+ 	int err;
+ 	struct dentry *upper;
+ 	struct inode *udir = d_inode(c->destdir);
+ 
+ 	upper = lookup_one_len(c->destname.name, c->destdir, c->destname.len);
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  	if (IS_ERR(upper))
 -		return PTR_ERR(upper);
 -
 -	if (c->tmpfile)
 -		err = ovl_do_link(temp, udir, upper, true);
 -	else
 -		err = ovl_do_rename(d_inode(c->workdir), temp, udir, upper, 0);
 -
 -	if (!err)
 -		*newdentry = dget(c->tmpfile ? upper : temp);
 -	dput(upper);
 -
 -	return err;
 -}
 -
 -static int ovl_get_tmpfile(struct ovl_copy_up_ctx *c, struct dentry **tempp)
 -{
 -	int err;
 -	struct dentry *temp;
 -	const struct cred *old_creds = NULL;
 -	struct cred *new_creds = NULL;
 -	struct cattr cattr = {
 -		/* Can't properly set mode on creation because of the umask */
 -		.mode = c->stat.mode & S_IFMT,
 -		.rdev = c->stat.rdev,
 -		.link = c->link
 -	};
 +		goto out1;
  
 -	err = security_inode_copy_up(c->dentry, &new_creds);
 +	err = security_inode_copy_up(dentry, &new_creds);
  	if (err < 0)
 -		goto out;
 +		goto out2;
  
  	if (new_creds)
  		old_creds = override_creds(new_creds);
diff --cc fs/overlayfs/dir.c
index 709c8eb662f9,641d9ee97f91..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -753,28 -747,12 +759,28 @@@ out_unlock
  	return err;
  }
  
 +static inline int ovl_check_sticky(struct dentry *dentry)
 +{
 +	struct inode *dir = ovl_dentry_real(dentry->d_parent)->d_inode;
 +	struct inode *inode = ovl_dentry_real(dentry)->d_inode;
 +
 +	if (check_sticky(dir, inode))
 +		return -EPERM;
 +
 +	return 0;
 +}
 +
  static int ovl_do_remove(struct dentry *dentry, bool is_dir)
  {
- 	enum ovl_path_type type;
  	int err;
+ 	bool locked = false;
  	const struct cred *old_cred;
  
 +
 +	err = ovl_check_sticky(dentry);
 +	if (err)
 +		goto out;
 +
  	err = ovl_want_write(dentry);
  	if (err)
  		goto out;
@@@ -818,8 -900,7 +827,12 @@@ static int ovl_rename(struct inode *old
  		      unsigned int flags)
  {
  	int err;
++<<<<<<< HEAD
 +	enum ovl_path_type old_type;
 +	enum ovl_path_type new_type;
++=======
+ 	bool locked = false;
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  	struct dentry *old_upperdir;
  	struct dentry *new_upperdir;
  	struct dentry *olddentry;
diff --cc fs/overlayfs/inode.c
index e60c6d748742,196a4e5450c0..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -9,9 -9,10 +9,10 @@@
  
  #include <linux/fs.h>
  #include <linux/slab.h>
 -#include <linux/cred.h>
  #include <linux/xattr.h>
 +#include <linux/cred.h>
  #include <linux/posix_acl.h>
+ #include <linux/ratelimit.h>
  #include "overlayfs.h"
  
  int ovl_setattr(struct dentry *dentry, struct iattr *attr)
@@@ -78,17 -58,91 +79,91 @@@ out
  	return err;
  }
  
 -int ovl_getattr(const struct path *path, struct kstat *stat,
 -		u32 request_mask, unsigned int flags)
 +static int ovl_getattr(struct vfsmount *mnt, struct dentry *dentry,
 +			 struct kstat *stat)
  {
 -	struct dentry *dentry = path->dentry;
 -	enum ovl_path_type type;
  	struct path realpath;
  	const struct cred *old_cred;
 -	bool is_dir = S_ISDIR(dentry->d_inode->i_mode);
  	int err;
  
 -	type = ovl_path_real(dentry, &realpath);
 +	ovl_path_real(dentry, &realpath);
  	old_cred = ovl_override_creds(dentry->d_sb);
++<<<<<<< HEAD
 +	err = vfs_getattr(&realpath, stat);
++=======
+ 	err = vfs_getattr(&realpath, stat, request_mask, flags);
+ 	if (err)
+ 		goto out;
+ 
+ 	/*
+ 	 * When all layers are on the same fs, all real inode number are
+ 	 * unique, so we use the overlay st_dev, which is friendly to du -x.
+ 	 *
+ 	 * We also use st_ino of the copy up origin, if we know it.
+ 	 * This guaranties constant st_dev/st_ino across copy up.
+ 	 *
+ 	 * If filesystem supports NFS export ops, this also guaranties
+ 	 * persistent st_ino across mount cycle.
+ 	 */
+ 	if (ovl_same_sb(dentry->d_sb)) {
+ 		if (OVL_TYPE_ORIGIN(type)) {
+ 			struct kstat lowerstat;
+ 			u32 lowermask = STATX_INO | (!is_dir ? STATX_NLINK : 0);
+ 
+ 			ovl_path_lower(dentry, &realpath);
+ 			err = vfs_getattr(&realpath, &lowerstat,
+ 					  lowermask, flags);
+ 			if (err)
+ 				goto out;
+ 
+ 			WARN_ON_ONCE(stat->dev != lowerstat.dev);
+ 			/*
+ 			 * Lower hardlinks may be broken on copy up to different
+ 			 * upper files, so we cannot use the lower origin st_ino
+ 			 * for those different files, even for the same fs case.
+ 			 * With inodes index enabled, it is safe to use st_ino
+ 			 * of an indexed hardlinked origin. The index validates
+ 			 * that the upper hardlink is not broken.
+ 			 */
+ 			if (is_dir || lowerstat.nlink == 1 ||
+ 			    ovl_test_flag(OVL_INDEX, d_inode(dentry)))
+ 				stat->ino = lowerstat.ino;
+ 		}
+ 		stat->dev = dentry->d_sb->s_dev;
+ 	} else if (is_dir) {
+ 		/*
+ 		 * If not all layers are on the same fs the pair {real st_ino;
+ 		 * overlay st_dev} is not unique, so use the non persistent
+ 		 * overlay st_ino.
+ 		 *
+ 		 * Always use the overlay st_dev for directories, so 'find
+ 		 * -xdev' will scan the entire overlay mount and won't cross the
+ 		 * overlay mount boundaries.
+ 		 */
+ 		stat->dev = dentry->d_sb->s_dev;
+ 		stat->ino = dentry->d_inode->i_ino;
+ 	}
+ 
+ 	/*
+ 	 * It's probably not worth it to count subdirs to get the
+ 	 * correct link count.  nlink=1 seems to pacify 'find' and
+ 	 * other utilities.
+ 	 */
+ 	if (is_dir && OVL_TYPE_MERGE(type))
+ 		stat->nlink = 1;
+ 
+ 	/*
+ 	 * Return the overlay inode nlinks for indexed upper inodes.
+ 	 * Overlay inode nlink counts the union of the upper hardlinks
+ 	 * and non-covered lower hardlinks. It does not include the upper
+ 	 * index hardlink.
+ 	 */
+ 	if (!is_dir && ovl_test_flag(OVL_INDEX, d_inode(dentry)))
+ 		stat->nlink = dentry->d_inode->i_nlink;
+ 
+ out:
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  	revert_creds(old_cred);
 -
  	return err;
  }
  
@@@ -414,7 -452,104 +489,108 @@@ static void ovl_fill_inode(struct inod
  	}
  }
  
++<<<<<<< HEAD
 +struct inode *ovl_new_inode(struct super_block *sb, umode_t mode)
++=======
+ /*
+  * With inodes index enabled, an overlay inode nlink counts the union of upper
+  * hardlinks and non-covered lower hardlinks. During the lifetime of a non-pure
+  * upper inode, the following nlink modifying operations can happen:
+  *
+  * 1. Lower hardlink copy up
+  * 2. Upper hardlink created, unlinked or renamed over
+  * 3. Lower hardlink whiteout or renamed over
+  *
+  * For the first, copy up case, the union nlink does not change, whether the
+  * operation succeeds or fails, but the upper inode nlink may change.
+  * Therefore, before copy up, we store the union nlink value relative to the
+  * lower inode nlink in the index inode xattr trusted.overlay.nlink.
+  *
+  * For the second, upper hardlink case, the union nlink should be incremented
+  * or decremented IFF the operation succeeds, aligned with nlink change of the
+  * upper inode. Therefore, before link/unlink/rename, we store the union nlink
+  * value relative to the upper inode nlink in the index inode.
+  *
+  * For the last, lower cover up case, we simplify things by preceding the
+  * whiteout or cover up with copy up. This makes sure that there is an index
+  * upper inode where the nlink xattr can be stored before the copied up upper
+  * entry is unlink.
+  */
+ #define OVL_NLINK_ADD_UPPER	(1 << 0)
+ 
+ /*
+  * On-disk format for indexed nlink:
+  *
+  * nlink relative to the upper inode - "U[+-]NUM"
+  * nlink relative to the lower inode - "L[+-]NUM"
+  */
+ 
+ static int ovl_set_nlink_common(struct dentry *dentry,
+ 				struct dentry *realdentry, const char *format)
+ {
+ 	struct inode *inode = d_inode(dentry);
+ 	struct inode *realinode = d_inode(realdentry);
+ 	char buf[13];
+ 	int len;
+ 
+ 	len = snprintf(buf, sizeof(buf), format,
+ 		       (int) (inode->i_nlink - realinode->i_nlink));
+ 
+ 	return ovl_do_setxattr(ovl_dentry_upper(dentry),
+ 			       OVL_XATTR_NLINK, buf, len, 0);
+ }
+ 
+ int ovl_set_nlink_upper(struct dentry *dentry)
+ {
+ 	return ovl_set_nlink_common(dentry, ovl_dentry_upper(dentry), "U%+i");
+ }
+ 
+ int ovl_set_nlink_lower(struct dentry *dentry)
+ {
+ 	return ovl_set_nlink_common(dentry, ovl_dentry_lower(dentry), "L%+i");
+ }
+ 
+ static unsigned int ovl_get_nlink(struct dentry *lowerdentry,
+ 				  struct dentry *upperdentry,
+ 				  unsigned int fallback)
+ {
+ 	int nlink_diff;
+ 	int nlink;
+ 	char buf[13];
+ 	int err;
+ 
+ 	if (!lowerdentry || !upperdentry || d_inode(lowerdentry)->i_nlink == 1)
+ 		return fallback;
+ 
+ 	err = vfs_getxattr(upperdentry, OVL_XATTR_NLINK, &buf, sizeof(buf) - 1);
+ 	if (err < 0)
+ 		goto fail;
+ 
+ 	buf[err] = '\0';
+ 	if ((buf[0] != 'L' && buf[0] != 'U') ||
+ 	    (buf[1] != '+' && buf[1] != '-'))
+ 		goto fail;
+ 
+ 	err = kstrtoint(buf + 1, 10, &nlink_diff);
+ 	if (err < 0)
+ 		goto fail;
+ 
+ 	nlink = d_inode(buf[0] == 'L' ? lowerdentry : upperdentry)->i_nlink;
+ 	nlink += nlink_diff;
+ 
+ 	if (nlink <= 0)
+ 		goto fail;
+ 
+ 	return nlink;
+ 
+ fail:
+ 	pr_warn_ratelimited("overlayfs: failed to get index nlink (%pd2, err=%i)\n",
+ 			    upperdentry, err);
+ 	return fallback;
+ }
+ 
+ struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev)
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  {
  	struct inode *inode;
  
@@@ -436,18 -571,78 +612,63 @@@ static int ovl_inode_set(struct inode *
  	return 0;
  }
  
 -static bool ovl_verify_inode(struct inode *inode, struct dentry *lowerdentry,
 -			     struct dentry *upperdentry)
 -{
 -	struct inode *lowerinode = lowerdentry ? d_inode(lowerdentry) : NULL;
 -
 -	/* Lower (origin) inode must match, even if NULL */
 -	if (ovl_inode_lower(inode) != lowerinode)
 -		return false;
 -
 -	/*
 -	 * Allow non-NULL __upperdentry in inode even if upperdentry is NULL.
 -	 * This happens when finding a lower alias for a copied up hard link.
 -	 */
 -	if (upperdentry && ovl_inode_upper(inode) != d_inode(upperdentry))
 -		return false;
 +struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode)
  
 -	return true;
 -}
 -
 -struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry)
  {
 -	struct dentry *lowerdentry = ovl_dentry_lower(dentry);
 -	struct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;
  	struct inode *inode;
  
++<<<<<<< HEAD
 +	inode = iget5_locked(sb, (unsigned long) realinode,
 +			     ovl_inode_test, ovl_inode_set, realinode);
 +	if (inode && inode->i_state & I_NEW) {
 +		ovl_fill_inode(inode, realinode->i_mode);
 +		set_nlink(inode, realinode->i_nlink);
++=======
+ 	if (!realinode)
+ 		realinode = d_inode(lowerdentry);
+ 
+ 	if (!S_ISDIR(realinode->i_mode) &&
+ 	    (upperdentry || (lowerdentry && ovl_indexdir(dentry->d_sb)))) {
+ 		struct inode *key = d_inode(lowerdentry ?: upperdentry);
+ 		unsigned int nlink;
+ 
+ 		inode = iget5_locked(dentry->d_sb, (unsigned long) key,
+ 				     ovl_inode_test, ovl_inode_set, key);
+ 		if (!inode)
+ 			goto out_nomem;
+ 		if (!(inode->i_state & I_NEW)) {
+ 			/*
+ 			 * Verify that the underlying files stored in the inode
+ 			 * match those in the dentry.
+ 			 */
+ 			if (!ovl_verify_inode(inode, lowerdentry, upperdentry)) {
+ 				iput(inode);
+ 				inode = ERR_PTR(-ESTALE);
+ 				goto out;
+ 			}
+ 
+ 			dput(upperdentry);
+ 			goto out;
+ 		}
+ 
+ 		nlink = ovl_get_nlink(lowerdentry, upperdentry,
+ 				      realinode->i_nlink);
+ 		set_nlink(inode, nlink);
+ 	} else {
+ 		inode = new_inode(dentry->d_sb);
+ 		if (!inode)
+ 			goto out_nomem;
+ 	}
+ 	ovl_fill_inode(inode, realinode->i_mode, realinode->i_rdev);
+ 	ovl_inode_init(inode, upperdentry, lowerdentry);
+ 
+ 	if (upperdentry && ovl_is_impuredir(upperdentry))
+ 		ovl_set_flag(OVL_IMPURE, inode);
+ 
+ 	if (inode->i_state & I_NEW)
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  		unlock_new_inode(inode);
 -out:
 -	return inode;
 +	}
  
 -out_nomem:
 -	inode = ERR_PTR(-ENOMEM);
 -	goto out;
 +	return inode;
  }
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,c1321ab38224..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -24,8 -22,51 +24,15 @@@ enum ovl_path_type 
  
  #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
  #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
++<<<<<<< HEAD
++=======
+ #define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
+ #define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
+ #define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
+ #define OVL_XATTR_NLINK OVL_XATTR_PREFIX "nlink"
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  
 -enum ovl_flag {
 -	OVL_IMPURE,
 -	OVL_INDEX,
 -};
 -
 -/*
 - * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
 - * where:
 - * origin.fh	- exported file handle of the lower file
 - * origin.uuid	- uuid of the lower filesystem
 - */
 -#define OVL_FH_VERSION	0
 -#define OVL_FH_MAGIC	0xfb
 -
 -/* CPU byte order required for fid decoding:  */
 -#define OVL_FH_FLAG_BIG_ENDIAN	(1 << 0)
 -#define OVL_FH_FLAG_ANY_ENDIAN	(1 << 1)
 -/* Is the real inode encoded in fid an upper inode? */
 -#define OVL_FH_FLAG_PATH_UPPER	(1 << 2)
 -
 -#define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
 -
 -#if defined(__LITTLE_ENDIAN)
 -#define OVL_FH_FLAG_CPU_ENDIAN 0
 -#elif defined(__BIG_ENDIAN)
 -#define OVL_FH_FLAG_CPU_ENDIAN OVL_FH_FLAG_BIG_ENDIAN
 -#else
 -#error Endianness not defined
 -#endif
 -
 -/* On-disk and in-memeory format for redirect by file handle */
 -struct ovl_fh {
 -	u8 version;	/* 0 */
 -	u8 magic;	/* 0xfb */
 -	u8 len;		/* size of this header + size of fid */
 -	u8 flags;	/* OVL_FH_FLAG_* */
 -	u8 type;	/* fid_type of fid */
 -	uuid_t uuid;	/* uuid of filesystem */
 -	u8 fid[0];	/* file identifier */
 -} __packed;
 +#define OVL_ISUPPER_MASK 1UL
  
  static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
  {
@@@ -151,27 -199,55 +158,72 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 -struct inode *ovl_inode_upper(struct inode *inode);
 -struct inode *ovl_inode_lower(struct inode *inode);
 -struct inode *ovl_inode_real(struct inode *inode);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_dentry_has_upper_alias(struct dentry *dentry);
+ void ovl_dentry_set_upper_alias(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+ 		    struct dentry *lowerdentry);
+ void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+ 		       const char *name, const void *value, size_t size,
+ 		       int xerr);
+ int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_set_flag(unsigned long flag, struct inode *inode);
+ bool ovl_test_flag(unsigned long flag, struct inode *inode);
+ bool ovl_inuse_trylock(struct dentry *dentry);
+ void ovl_inuse_unlock(struct dentry *dentry);
+ int ovl_nlink_start(struct dentry *dentry, bool *locked);
+ void ovl_nlink_end(struct dentry *dentry, bool locked);
+ 
+ static inline bool ovl_is_impuredir(struct dentry *dentry)
+ {
+ 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+ }
+ 
+ 
+ /* namei.c */
+ int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
+ 		      struct dentry *origin, bool is_upper, bool set);
+ int ovl_verify_index(struct dentry *index, struct path *lowerstack,
+ 		     unsigned int numlower);
+ int ovl_get_index_name(struct dentry *origin, struct qstr *name);
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> 5f8415d6b87e (ovl: persistent overlay inode nlink for indexed inodes)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
@@@ -181,9 -257,15 +233,11 @@@ void ovl_cache_free(struct list_head *l
  int ovl_check_d_type_supported(struct path *realpath);
  void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
  			 struct dentry *dentry, int level);
 -int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 -			 struct path *lowerstack, unsigned int numlower);
  
  /* inode.c */
+ int ovl_set_nlink_upper(struct dentry *dentry);
+ int ovl_set_nlink_lower(struct dentry *dentry);
  int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 -int ovl_getattr(const struct path *path, struct kstat *stat,
 -		u32 request_mask, unsigned int flags);
  int ovl_permission(struct inode *inode, int mask);
  int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
  		  size_t size, int flags);
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/util.c
