x86/hyper-v: Introduce fast hypercall implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] hyper-v: Introduce fast hypercall implementation (Vitaly Kuznetsov) [1465471]
Rebuild_FUZZ: 96.00%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 6a8edbd0c54ae266b12f4f63e406313481c9d4bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6a8edbd0.failed

Hyper-V supports 'fast' hypercalls when all parameters are passed through
registers. Implement an inline version of a simpliest of these calls:
hypercall with one 8-byte input and no output.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Jork Loeser <Jork.Loeser@microsoft.com>
	Cc: K. Y. Srinivasan <kys@microsoft.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Simon Xiao <sixiao@microsoft.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: devel@linuxdriverproject.org
Link: http://lkml.kernel.org/r/20170802160921.21791-4-vkuznets@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6a8edbd0c54ae266b12f4f63e406313481c9d4bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index c86331fdc4b0,e484255bd9de..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -83,6 -168,143 +83,84 @@@ void hv_setup_crash_handler(void (*hand
  void hv_remove_crash_handler(void);
  
  #if IS_ENABLED(CONFIG_HYPERV)
++<<<<<<< HEAD
++=======
+ extern struct clocksource *hyperv_cs;
+ extern void *hv_hypercall_pg;
+ 
+ static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
+ {
+ 	u64 input_address = input ? virt_to_phys(input) : 0;
+ 	u64 output_address = output ? virt_to_phys(output) : 0;
+ 	u64 hv_status;
+ 	register void *__sp asm(_ASM_SP);
+ 
+ #ifdef CONFIG_X86_64
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("mov %4, %%r8\n"
+ 			     "call *%5"
+ 			     : "=a" (hv_status), "+r" (__sp),
+ 			       "+c" (control), "+d" (input_address)
+ 			     :  "r" (output_address), "m" (hv_hypercall_pg)
+ 			     : "cc", "memory", "r8", "r9", "r10", "r11");
+ #else
+ 	u32 input_address_hi = upper_32_bits(input_address);
+ 	u32 input_address_lo = lower_32_bits(input_address);
+ 	u32 output_address_hi = upper_32_bits(output_address);
+ 	u32 output_address_lo = lower_32_bits(output_address);
+ 
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("call *%7"
+ 			     : "=A" (hv_status),
+ 			       "+c" (input_address_lo), "+r" (__sp)
+ 			     : "A" (control),
+ 			       "b" (input_address_hi),
+ 			       "D"(output_address_hi), "S"(output_address_lo),
+ 			       "m" (hv_hypercall_pg)
+ 			     : "cc", "memory");
+ #endif /* !x86_64 */
+ 	return hv_status;
+ }
+ 
+ #define HV_HYPERCALL_FAST_BIT		BIT(16)
+ 
+ /* Fast hypercall with 8 bytes of input and no output */
+ static inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)
+ {
+ 	u64 hv_status, control = (u64)code | HV_HYPERCALL_FAST_BIT;
+ 	register void *__sp asm(_ASM_SP);
+ 
+ #ifdef CONFIG_X86_64
+ 	{
+ 		__asm__ __volatile__("call *%4"
+ 				     : "=a" (hv_status), "+r" (__sp),
+ 				       "+c" (control), "+d" (input1)
+ 				     : "m" (hv_hypercall_pg)
+ 				     : "cc", "r8", "r9", "r10", "r11");
+ 	}
+ #else
+ 	{
+ 		u32 input1_hi = upper_32_bits(input1);
+ 		u32 input1_lo = lower_32_bits(input1);
+ 
+ 		__asm__ __volatile__ ("call *%5"
+ 				      : "=A"(hv_status),
+ 					"+c"(input1_lo),
+ 					"+r"(__sp)
+ 				      :	"A" (control),
+ 					"b" (input1_hi),
+ 					"m" (hv_hypercall_pg)
+ 				      : "cc", "edi", "esi");
+ 	}
+ #endif
+ 		return hv_status;
+ }
+ 
++>>>>>>> 6a8edbd0c54a (x86/hyper-v: Introduce fast hypercall implementation)
  void hyperv_init(void);
 -void hyperv_report_panic(struct pt_regs *regs);
 -bool hv_is_hypercall_page_setup(void);
 -void hyperv_cleanup(void);
 -#else /* CONFIG_HYPERV */
 -static inline void hyperv_init(void) {}
 -static inline bool hv_is_hypercall_page_setup(void) { return false; }
 -static inline void hyperv_cleanup(void) {}
 -#endif /* CONFIG_HYPERV */
 -
 -#ifdef CONFIG_HYPERV_TSCPAGE
 -struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
 -static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
 -{
 -	u64 scale, offset, cur_tsc;
 -	u32 sequence;
 -
 -	/*
 -	 * The protocol for reading Hyper-V TSC page is specified in Hypervisor
 -	 * Top-Level Functional Specification ver. 3.0 and above. To get the
 -	 * reference time we must do the following:
 -	 * - READ ReferenceTscSequence
 -	 *   A special '0' value indicates the time source is unreliable and we
 -	 *   need to use something else. The currently published specification
 -	 *   versions (up to 4.0b) contain a mistake and wrongly claim '-1'
 -	 *   instead of '0' as the special value, see commit c35b82ef0294.
 -	 * - ReferenceTime =
 -	 *        ((RDTSC() * ReferenceTscScale) >> 64) + ReferenceTscOffset
 -	 * - READ ReferenceTscSequence again. In case its value has changed
 -	 *   since our first reading we need to discard ReferenceTime and repeat
 -	 *   the whole sequence as the hypervisor was updating the page in
 -	 *   between.
 -	 */
 -	do {
 -		sequence = READ_ONCE(tsc_pg->tsc_sequence);
 -		if (!sequence)
 -			return U64_MAX;
 -		/*
 -		 * Make sure we read sequence before we read other values from
 -		 * TSC page.
 -		 */
 -		smp_rmb();
 -
 -		scale = READ_ONCE(tsc_pg->tsc_scale);
 -		offset = READ_ONCE(tsc_pg->tsc_offset);
 -		cur_tsc = rdtsc_ordered();
 -
 -		/*
 -		 * Make sure we read sequence after we read all other values
 -		 * from TSC page.
 -		 */
 -		smp_rmb();
 -
 -	} while (READ_ONCE(tsc_pg->tsc_sequence) != sequence);
 -
 -	return mul_u64_u64_shr(cur_tsc, scale, 64) + offset;
 -}
 -
 -#else
 -static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
 -{
 -	return NULL;
 -}
  #endif
  #endif
* Unmerged path arch/x86/include/asm/mshyperv.h
