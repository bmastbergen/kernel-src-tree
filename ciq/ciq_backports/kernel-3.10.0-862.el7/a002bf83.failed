scsi: cxlflash: Track pending scsi commands in each hardware queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Track pending scsi commands in each hardware queue (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 95.24%
commit-author Uma Krishnan <ukrishn@linux.vnet.ibm.com>
commit a002bf830f5df3e622e32fdbde1756bcbb6aedad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a002bf83.failed

Currently, there is no book keeping of the pending scsi commands in the
cxlflash driver. This lack of tracking in-flight requests is too
restrictive and requires a heavy-hammer reset each time an adapter error is
encountered. Additionally, it does not allow for commands to be properly
retried.

In order to avoid this problem and to better handle error path command
cleanup, introduce a linked list for each hardware queue that tracks
pending commands.

	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Acked-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a002bf830f5df3e622e32fdbde1756bcbb6aedad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,3eaa3be43d24..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -132,13 -151,14 +132,14 @@@ struct cxlflash_cfg 
  struct afu_cmd {
  	struct sisl_ioarcb rcb;	/* IOARCB (cache line aligned) */
  	struct sisl_ioasa sa;	/* IOASA must follow IOARCB */
 -	struct afu *parent;
 -	struct scsi_cmnd *scp;
 +	spinlock_t slock;
  	struct completion cevent;
 -	struct list_head queue;
 -	u32 hwq_index;
 +	struct afu *parent;
 +	int slot;
 +	atomic_t free;
  
  	u8 cmd_tmf:1;
+ 	struct list_head list;	/* Pending commands link */
  
  	/* As per the SISLITE spec the IOARCB EA has to be 16-byte aligned.
  	 * However for performance reasons the IOARCB/IOASA should be
@@@ -158,14 -187,21 +159,20 @@@ struct afu 
  	/* Beware of alignment till here. Preferably introduce new
  	 * fields after this point
  	 */
 -	struct afu *afu;
 -	struct cxl_context *ctx;
 +
 +	/* AFU HW */
  	struct cxl_ioctl_start_work work;
 +	struct cxlflash_afu_map __iomem *afu_map;	/* entire MMIO map */
  	struct sisl_host_map __iomem *host_map;		/* MC host map */
  	struct sisl_ctrl_map __iomem *ctrl_map;		/* MC control map */
++<<<<<<< HEAD
++=======
+ 	ctx_hndl_t ctx_hndl;	/* master's context handle */
+ 	u32 index;		/* Index of this hwq */
+ 	struct list_head pending_cmds;	/* Commands pending completion */
++>>>>>>> a002bf830f5d (scsi: cxlflash: Track pending scsi commands in each hardware queue)
  
 -	atomic_t hsq_credits;
 -	spinlock_t hsq_slock;	/* Hardware send queue lock */
 -	struct sisl_ioarcb *hsq_start;
 -	struct sisl_ioarcb *hsq_end;
 -	struct sisl_ioarcb *hsq_curr;
 -	spinlock_t hrrq_slock;
 +	ctx_hndl_t ctx_hndl;	/* master's context handle */
  	u64 *hrrq_start;
  	u64 *hrrq_end;
  	u64 *hrrq_curr;
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,1446fabe4cf6..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -219,14 -161,16 +219,27 @@@ static void cmd_complete(struct afu_cm
  	ulong lock_flags;
  	struct afu *afu = cmd->parent;
  	struct cxlflash_cfg *cfg = afu->parent;
++<<<<<<< HEAD
 +	bool cmd_is_tmf;
 +
 +	spin_lock_irqsave(&cmd->slock, lock_flags);
 +	cmd->sa.host_use_b[0] |= B_DONE;
 +	spin_unlock_irqrestore(&cmd->slock, lock_flags);
 +
 +	if (cmd->rcb.scp) {
 +		scp = cmd->rcb.scp;
++=======
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct hwq *hwq = get_hwq(afu, cmd->hwq_index);
+ 	bool cmd_is_tmf;
+ 
+ 	spin_lock_irqsave(&hwq->hsq_slock, lock_flags);
+ 	list_del(&cmd->list);
+ 	spin_unlock_irqrestore(&hwq->hsq_slock, lock_flags);
+ 
+ 	if (cmd->scp) {
+ 		scp = cmd->scp;
++>>>>>>> a002bf830f5d (scsi: cxlflash: Track pending scsi commands in each hardware queue)
  		if (unlikely(cmd->sa.ioasc))
  			process_cmd_err(cmd, scp);
  		else
@@@ -324,14 -281,61 +337,69 @@@ static int send_cmd(struct afu *afu, st
  			rc = SCSI_MLQUEUE_HOST_BUSY;
  			goto out;
  		}
 -		hwq->room = room - 1;
 +		afu->room = room - 1;
  	}
  
++<<<<<<< HEAD
 +	writeq_be((u64)&cmd->rcb, &afu->host_map->ioarrin);
 +out:
 +	spin_unlock_irqrestore(&afu->rrin_slock, lock_flags);
 +	pr_devel("%s: cmd=%p len=%d ea=%p rc=%d\n", __func__, cmd,
 +		 cmd->rcb.data_len, (void *)cmd->rcb.data_ea, rc);
++=======
+ 	list_add(&cmd->list, &hwq->pending_cmds);
+ 	writeq_be((u64)&cmd->rcb, &hwq->host_map->ioarrin);
+ out:
+ 	spin_unlock_irqrestore(&hwq->hsq_slock, lock_flags);
+ 	dev_dbg(dev, "%s: cmd=%p len=%u ea=%016llx rc=%d\n", __func__,
+ 		cmd, cmd->rcb.data_len, cmd->rcb.data_ea, rc);
+ 	return rc;
+ }
+ 
+ /**
+  * send_cmd_sq() - sends an AFU command via SQ ring
+  * @afu:	AFU associated with the host.
+  * @cmd:	AFU command to send.
+  *
+  * Return:
+  *	0 on success, SCSI_MLQUEUE_HOST_BUSY on failure
+  */
+ static int send_cmd_sq(struct afu *afu, struct afu_cmd *cmd)
+ {
+ 	struct cxlflash_cfg *cfg = afu->parent;
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct hwq *hwq = get_hwq(afu, cmd->hwq_index);
+ 	int rc = 0;
+ 	int newval;
+ 	ulong lock_flags;
+ 
+ 	newval = atomic_dec_if_positive(&hwq->hsq_credits);
+ 	if (newval <= 0) {
+ 		rc = SCSI_MLQUEUE_HOST_BUSY;
+ 		goto out;
+ 	}
+ 
+ 	cmd->rcb.ioasa = &cmd->sa;
+ 
+ 	spin_lock_irqsave(&hwq->hsq_slock, lock_flags);
+ 
+ 	*hwq->hsq_curr = cmd->rcb;
+ 	if (hwq->hsq_curr < hwq->hsq_end)
+ 		hwq->hsq_curr++;
+ 	else
+ 		hwq->hsq_curr = hwq->hsq_start;
+ 
+ 	list_add(&cmd->list, &hwq->pending_cmds);
+ 	writeq_be((u64)hwq->hsq_curr, &hwq->host_map->sq_tail);
+ 
+ 	spin_unlock_irqrestore(&hwq->hsq_slock, lock_flags);
+ out:
+ 	dev_dbg(dev, "%s: cmd=%p len=%u ea=%016llx ioasa=%p rc=%d curr=%p "
+ 	       "head=%016llx tail=%016llx\n", __func__, cmd, cmd->rcb.data_len,
+ 	       cmd->rcb.data_ea, cmd->rcb.ioasa, rc, hwq->hsq_curr,
+ 	       readq_be(&hwq->host_map->sq_head),
+ 	       readq_be(&hwq->host_map->sq_tail));
++>>>>>>> a002bf830f5d (scsi: cxlflash: Track pending scsi commands in each hardware queue)
  	return rc;
  }
  
@@@ -1660,12 -1845,22 +1728,23 @@@ static int init_mc(struct cxlflash_cfg 
  	int rc = 0;
  	enum undo_level level;
  
++<<<<<<< HEAD
 +	ctx = cxl_get_context(cfg->dev);
++=======
+ 	hwq->afu = cfg->afu;
+ 	hwq->index = index;
+ 	INIT_LIST_HEAD(&hwq->pending_cmds);
+ 
+ 	if (index == PRIMARY_HWQ)
+ 		ctx = cxl_get_context(cfg->dev);
+ 	else
+ 		ctx = cxl_dev_context_init(cfg->dev);
++>>>>>>> a002bf830f5d (scsi: cxlflash: Track pending scsi commands in each hardware queue)
  	if (unlikely(!ctx)) {
  		rc = -ENOMEM;
 -		goto err1;
 +		goto ret;
  	}
 -
 -	WARN_ON(hwq->ctx);
 -	hwq->ctx = ctx;
 +	cfg->mcctx = ctx;
  
  	/* Set it up as a master with the CXL */
  	cxl_set_master(ctx);
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
