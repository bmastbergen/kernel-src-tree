sched: push TC filter protocol creation into a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit 33a48927c193d030c80ecaeb3e021b7ed85f9c78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/33a48927.failed

Make the long function tc_ctl_tfilter a little bit shorter and easier to
read. Also make the creation of filter proto symmetric to destruction.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 33a48927c193d030c80ecaeb3e021b7ed85f9c78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 610890f8531c,d378a0b156c1..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -127,6 -128,77 +128,80 @@@ static inline u32 tcf_auto_prio(struct 
  	return first;
  }
  
++<<<<<<< HEAD
++=======
+ static struct tcf_proto *tcf_proto_create(const char *kind, u32 protocol,
+ 					  u32 prio, u32 parent, struct Qdisc *q)
+ {
+ 	struct tcf_proto *tp;
+ 	int err;
+ 
+ 	tp = kzalloc(sizeof(*tp), GFP_KERNEL);
+ 	if (!tp)
+ 		return ERR_PTR(-ENOBUFS);
+ 
+ 	err = -ENOENT;
+ 	tp->ops = tcf_proto_lookup_ops(kind);
+ 	if (!tp->ops) {
+ #ifdef CONFIG_MODULES
+ 		rtnl_unlock();
+ 		request_module("cls_%s", kind);
+ 		rtnl_lock();
+ 		tp->ops = tcf_proto_lookup_ops(kind);
+ 		/* We dropped the RTNL semaphore in order to perform
+ 		 * the module load. So, even if we succeeded in loading
+ 		 * the module we have to replay the request. We indicate
+ 		 * this using -EAGAIN.
+ 		 */
+ 		if (tp->ops) {
+ 			module_put(tp->ops->owner);
+ 			err = -EAGAIN;
+ 		} else {
+ 			err = -ENOENT;
+ 		}
+ 		goto errout;
+ #endif
+ 	}
+ 	tp->classify = tp->ops->classify;
+ 	tp->protocol = protocol;
+ 	tp->prio = prio;
+ 	tp->classid = parent;
+ 	tp->q = q;
+ 
+ 	err = tp->ops->init(tp);
+ 	if (err) {
+ 		module_put(tp->ops->owner);
+ 		goto errout;
+ 	}
+ 	return tp;
+ 
+ errout:
+ 	kfree(tp);
+ 	return ERR_PTR(err);
+ }
+ 
+ static bool tcf_proto_destroy(struct tcf_proto *tp, bool force)
+ {
+ 	if (tp->ops->destroy(tp, force)) {
+ 		module_put(tp->ops->owner);
+ 		kfree_rcu(tp, rcu);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ void tcf_destroy_chain(struct tcf_proto __rcu **fl)
+ {
+ 	struct tcf_proto *tp;
+ 
+ 	while ((tp = rtnl_dereference(*fl)) != NULL) {
+ 		RCU_INIT_POINTER(*fl, tp->next);
+ 		tcf_proto_destroy(tp, true);
+ 	}
+ }
+ EXPORT_SYMBOL(tcf_destroy_chain);
+ 
++>>>>>>> 33a48927c193 (sched: push TC filter protocol creation into a separate function)
  /* Add/change/delete/get a filter node */
  
  static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n)
* Unmerged path net/sched/cls_api.c
