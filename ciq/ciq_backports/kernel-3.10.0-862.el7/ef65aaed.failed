smb2: Enforce sec= mount option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sachin Prabhu <sprabhu@redhat.com>
commit ef65aaede23f75977af56a8c330bb9be8c6e125c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ef65aaed.failed

If the security type specified using a mount option is not supported,
the SMB2 session setup code changes the security type to RawNTLMSSP. We
should instead fail the mount and return an error.

The patch changes the code for SMB2 to make it similar to the code used
for SMB1. Like in SMB1, we now use the global security flags to select
the security method to be used when no security method is specified and
to return an error when the requested auth method is not available.

For SMB2, we also use ntlmv2 as a synonym for nltmssp.

	Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
	Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
	Acked-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit ef65aaede23f75977af56a8c330bb9be8c6e125c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsglob.h
#	fs/cifs/cifsproto.h
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/cifsglob.h
index 2d53c6a224e6,d42dd3288647..000000000000
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@@ -434,6 -435,17 +434,20 @@@ struct smb_version_operations 
  	bool (*dir_needs_close)(struct cifsFileInfo *);
  	long (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,
  			  loff_t);
++<<<<<<< HEAD
++=======
+ 	/* init transform request - used for encryption for now */
+ 	int (*init_transform_rq)(struct TCP_Server_Info *, struct smb_rqst *,
+ 				 struct smb_rqst *);
+ 	/* free transform request */
+ 	void (*free_transform_rq)(struct smb_rqst *);
+ 	int (*is_transform_hdr)(void *buf);
+ 	int (*receive_transform)(struct TCP_Server_Info *,
+ 				 struct mid_q_entry **);
+ 	enum securityEnum (*select_sectype)(struct TCP_Server_Info *,
+ 			    enum securityEnum);
+ 
++>>>>>>> ef65aaede23f (smb2: Enforce sec= mount option)
  };
  
  struct smb_version_values {
diff --cc fs/cifs/cifsproto.h
index 4b148b10a6b7,97e5d236d265..000000000000
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@@ -519,4 -530,9 +519,12 @@@ int cifs_create_mf_symlink(unsigned in
  			   struct cifs_sb_info *cifs_sb,
  			   const unsigned char *path, char *pbuf,
  			   unsigned int *pbytes_written);
++<<<<<<< HEAD
++=======
+ int __cifs_calc_signature(struct smb_rqst *rqst,
+ 			struct TCP_Server_Info *server, char *signature,
+ 			struct shash_desc *shash);
+ enum securityEnum cifs_select_sectype(struct TCP_Server_Info *,
+ 					enum securityEnum);
++>>>>>>> ef65aaede23f (smb2: Enforce sec= mount option)
  #endif			/* _CIFSPROTO_H */
diff --cc fs/cifs/smb2ops.c
index 5d456ebb3813,0231108d9387..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -1623,6 -2380,8 +1623,11 @@@ struct smb_version_operations smb20_ope
  	.clone_range = smb2_clone_range,
  	.wp_retry_size = smb2_wp_retry_size,
  	.dir_needs_close = smb2_dir_needs_close,
++<<<<<<< HEAD
++=======
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
++>>>>>>> ef65aaede23f (smb2: Enforce sec= mount option)
  };
  
  struct smb_version_operations smb21_operations = {
@@@ -1704,6 -2463,8 +1709,11 @@@
  	.wp_retry_size = smb2_wp_retry_size,
  	.dir_needs_close = smb2_dir_needs_close,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
++>>>>>>> ef65aaede23f (smb2: Enforce sec= mount option)
  };
  
  struct smb_version_operations smb30_operations = {
@@@ -1791,6 -2552,12 +1801,15 @@@
  	.dir_needs_close = smb2_dir_needs_close,
  	.fallocate = smb3_fallocate,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.init_transform_rq = smb3_init_transform_rq,
+ 	.free_transform_rq = smb3_free_transform_rq,
+ 	.is_transform_hdr = smb3_is_transform_hdr,
+ 	.receive_transform = smb3_receive_transform,
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
++>>>>>>> ef65aaede23f (smb2: Enforce sec= mount option)
  };
  
  #ifdef CONFIG_CIFS_SMB311
@@@ -1879,6 -2646,12 +1898,15 @@@ struct smb_version_operations smb311_op
  	.dir_needs_close = smb2_dir_needs_close,
  	.fallocate = smb3_fallocate,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.init_transform_rq = smb3_init_transform_rq,
+ 	.free_transform_rq = smb3_free_transform_rq,
+ 	.is_transform_hdr = smb3_is_transform_hdr,
+ 	.receive_transform = smb3_receive_transform,
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
++>>>>>>> ef65aaede23f (smb2: Enforce sec= mount option)
  };
  #endif /* CIFS_SMB311 */
  
* Unmerged path fs/cifs/cifsglob.h
* Unmerged path fs/cifs/cifsproto.h
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 301fe5c81577..d19e8d752519 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -2110,7 +2110,8 @@ match_security(struct TCP_Server_Info *server, struct smb_vol *vol)
 	 * that was specified, or "Unspecified" if that sectype was not
 	 * compatible with the given NEGOTIATE request.
 	 */
-	if (select_sectype(server, vol->sectype) == Unspecified)
+	if (server->ops->select_sectype(server, vol->sectype)
+	     == Unspecified)
 		return false;
 
 	/*
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index 2f048e3b5020..a13b3af6dd3c 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -500,7 +500,7 @@ setup_ntlmv2_ret:
 }
 
 enum securityEnum
-select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
+cifs_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
 {
 	switch (server->negflavor) {
 	case CIFS_NEGFLAVOR_EXTENDED:
@@ -1390,7 +1390,7 @@ static int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)
 {
 	int type;
 
-	type = select_sectype(ses->server, ses->sectype);
+	type = cifs_select_sectype(ses->server, ses->sectype);
 	cifs_dbg(FYI, "sess setup type %d\n", type);
 	if (type == Unspecified) {
 		cifs_dbg(VFS,
diff --git a/fs/cifs/smb1ops.c b/fs/cifs/smb1ops.c
index 87b87e091e8e..a56f5c773352 100644
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@ -1097,6 +1097,7 @@ struct smb_version_operations smb1_operations = {
 	.is_read_op = cifs_is_read_op,
 	.wp_retry_size = cifs_wp_retry_size,
 	.dir_needs_close = cifs_dir_needs_close,
+	.select_sectype = cifs_select_sectype,
 #ifdef CONFIG_CIFS_XATTR
 	.query_all_EAs = CIFSSMBQAllEAs,
 	.set_EA = CIFSSMBSetEA,
* Unmerged path fs/cifs/smb2ops.c
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index 69971c2a8e39..4514a5fccdbe 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -596,6 +596,28 @@ vneg_out:
 	return -EIO;
 }
 
+enum securityEnum
+smb2_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
+{
+	switch (requested) {
+	case Kerberos:
+	case RawNTLMSSP:
+		return requested;
+	case NTLMv2:
+		return RawNTLMSSP;
+	case Unspecified:
+		if (server->sec_ntlmssp &&
+			(global_secflags & CIFSSEC_MAY_NTLMSSP))
+			return RawNTLMSSP;
+		if ((server->sec_kerberos || server->sec_mskerberos) &&
+			(global_secflags & CIFSSEC_MAY_KRB5))
+			return Kerberos;
+		/* Fallthrough */
+	default:
+		return Unspecified;
+	}
+}
+
 struct SMB2_sess_data {
 	unsigned int xid;
 	struct cifs_ses *ses;
@@ -958,10 +980,17 @@ out:
 static int
 SMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)
 {
-	if (ses->sectype != Kerberos && ses->sectype != RawNTLMSSP)
-		ses->sectype = RawNTLMSSP;
+	int type;
+
+	type = smb2_select_sectype(ses->server, ses->sectype);
+	cifs_dbg(FYI, "sess setup type %d\n", type);
+	if (type == Unspecified) {
+		cifs_dbg(VFS,
+			"Unable to select appropriate authentication method!");
+		return -EINVAL;
+	}
 
-	switch (ses->sectype) {
+	switch (type) {
 	case Kerberos:
 		sess_data->func = SMB2_auth_kerberos;
 		break;
@@ -969,7 +998,7 @@ SMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)
 		sess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;
 		break;
 	default:
-		cifs_dbg(VFS, "secType %d not supported!\n", ses->sectype);
+		cifs_dbg(VFS, "secType %d not supported!\n", type);
 		return -EOPNOTSUPP;
 	}
 
diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h
index f2d511a6971b..2f0a5a26cf56 100644
--- a/fs/cifs/smb2proto.h
+++ b/fs/cifs/smb2proto.h
@@ -175,4 +175,6 @@ extern int SMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,
 			    __u8 *lease_key, const __le32 lease_state);
 extern int smb3_validate_negotiate(const unsigned int, struct cifs_tcon *);
 
+extern enum securityEnum smb2_select_sectype(struct TCP_Server_Info *,
+					enum securityEnum);
 #endif			/* _SMB2PROTO_H */
