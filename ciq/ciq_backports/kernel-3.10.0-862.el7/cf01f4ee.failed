locks: only validate the lock vs. f_mode in F_SETLK codepaths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit cf01f4eef9fe367ec0d85b38dd7214e29e376cdb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cf01f4ee.failed

v2: replace missing break in switch statement (as pointed out by Dave
    Jones)

commit bce7560d4946 (locks: consolidate checks for compatible
filp->f_mode values in setlk handlers) introduced a regression in the
F_GETLK handler.

flock64_to_posix_lock is a shared codepath between F_GETLK and F_SETLK,
but the f_mode checks should only be applicable to the F_SETLK codepaths
according to POSIX.

Instead of just reverting the patch, add a new function to do this
checking and have the F_SETLK handlers call it.

	Cc: Dave Jones <davej@redhat.com>
Reported-and-Tested-by: Reuben Farrelly <reuben@reub.net>
	Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
(cherry picked from commit cf01f4eef9fe367ec0d85b38dd7214e29e376cdb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 20dcff562a1d,e390bd9ae068..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -2130,10 -2074,38 +2134,42 @@@ again
  	error = flock_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW) {
++=======
+ 
+ 	error = check_fmode_for_setlk(file_lock);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_OFDLCK flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW:
++>>>>>>> cf01f4eef9fe (locks: only validate the lock vs. f_mode in F_SETLK codepaths)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2232,10 -2213,38 +2268,42 @@@ again
  	error = flock64_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW64) {
++=======
+ 
+ 	error = check_fmode_for_setlk(file_lock);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_OFDLCK flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK64;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW64;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW64:
++>>>>>>> cf01f4eef9fe (locks: only validate the lock vs. f_mode in F_SETLK codepaths)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
* Unmerged path fs/locks.c
