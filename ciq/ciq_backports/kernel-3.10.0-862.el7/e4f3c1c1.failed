mlxsw: spectrum_router: Implement common RIF core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit e4f3c1c17b6d101af5474e8c72b38aa0baaf719d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e4f3c1c1.failed

The mlxsw driver currently implements three types of RIFs. VLAN and FID
RIFs for L3 interfaces on top of VLAN-aware and VLAN-unaware bridges
(respectively) and Subport RIFs for all other L3 interfaces.

All the RIF types follow a common configuration procedure, which only
differs in the type-specific bits. The patch exploits this fact and
consolidates the common code paths, thereby simplifying the code and
making it more extensible.

This work also prepares the driver for use with future ASICs, where the
range of the Subport RIFs will be extended and their configuration
modified accordingly. By merely implementing a new RIF operations and
selecting it during initialization, the same driver could be re-used.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e4f3c1c17b6d101af5474e8c72b38aa0baaf719d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.h
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_fid.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index 280114e1ebf6,1a834109bda1..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@@ -519,16 -377,11 +519,24 @@@ int mlxsw_sp_router_netevent_event(stru
  int mlxsw_sp_netdevice_router_port_event(struct net_device *dev);
  int mlxsw_sp_inetaddr_event(struct notifier_block *unused,
  			    unsigned long event, void *ptr);
++<<<<<<< HEAD
 +void mlxsw_sp_rif_bridge_destroy(struct mlxsw_sp *mlxsw_sp,
 +				 struct mlxsw_sp_rif *r);
 +int mlxsw_sp_vport_vrf_join(struct mlxsw_sp_port *mlxsw_sp_vport);
 +void mlxsw_sp_vport_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_vport);
 +int mlxsw_sp_port_vrf_join(struct mlxsw_sp_port *mlxsw_sp_port);
 +void mlxsw_sp_port_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_port);
 +int mlxsw_sp_bridge_vrf_join(struct mlxsw_sp *mlxsw_sp,
 +			     struct net_device *l3_dev);
 +void mlxsw_sp_bridge_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 +			       struct net_device *l3_dev);
++=======
+ int mlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,
+ 				 struct netdev_notifier_changeupper_info *info);
+ void
+ mlxsw_sp_port_vlan_router_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan);
+ void mlxsw_sp_rif_destroy(struct mlxsw_sp_rif *rif);
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  
  int mlxsw_sp_kvdl_alloc(struct mlxsw_sp *mlxsw_sp, unsigned int entry_count,
  			u32 *p_entry_index);
@@@ -651,4 -508,31 +659,34 @@@ int mlxsw_sp_flow_counter_alloc(struct 
  void mlxsw_sp_flow_counter_free(struct mlxsw_sp *mlxsw_sp,
  				unsigned int counter_index);
  
++<<<<<<< HEAD
++=======
+ int mlxsw_sp_fid_flood_set(struct mlxsw_sp_fid *fid,
+ 			   enum mlxsw_sp_flood_type packet_type, u8 local_port,
+ 			   bool member);
+ int mlxsw_sp_fid_port_vid_map(struct mlxsw_sp_fid *fid,
+ 			      struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);
+ void mlxsw_sp_fid_port_vid_unmap(struct mlxsw_sp_fid *fid,
+ 				 struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);
+ enum mlxsw_sp_rif_type mlxsw_sp_fid_rif_type(const struct mlxsw_sp_fid *fid);
+ u16 mlxsw_sp_fid_index(const struct mlxsw_sp_fid *fid);
+ enum mlxsw_sp_fid_type mlxsw_sp_fid_type(const struct mlxsw_sp_fid *fid);
+ void mlxsw_sp_fid_rif_set(struct mlxsw_sp_fid *fid, struct mlxsw_sp_rif *rif);
+ enum mlxsw_sp_rif_type
+ mlxsw_sp_fid_type_rif_type(const struct mlxsw_sp *mlxsw_sp,
+ 			   enum mlxsw_sp_fid_type type);
+ u16 mlxsw_sp_fid_8021q_vid(const struct mlxsw_sp_fid *fid);
+ struct mlxsw_sp_fid *mlxsw_sp_fid_8021q_get(struct mlxsw_sp *mlxsw_sp, u16 vid);
+ struct mlxsw_sp_fid *mlxsw_sp_fid_8021d_get(struct mlxsw_sp *mlxsw_sp,
+ 					    int br_ifindex);
+ struct mlxsw_sp_fid *mlxsw_sp_fid_rfid_get(struct mlxsw_sp *mlxsw_sp,
+ 					   u16 rif_index);
+ struct mlxsw_sp_fid *mlxsw_sp_fid_dummy_get(struct mlxsw_sp *mlxsw_sp);
+ void mlxsw_sp_fid_put(struct mlxsw_sp_fid *fid);
+ int mlxsw_sp_port_fids_init(struct mlxsw_sp_port *mlxsw_sp_port);
+ void mlxsw_sp_port_fids_fini(struct mlxsw_sp_port *mlxsw_sp_port);
+ int mlxsw_sp_fids_init(struct mlxsw_sp *mlxsw_sp);
+ void mlxsw_sp_fids_fini(struct mlxsw_sp *mlxsw_sp);
+ 
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  #endif
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index f8e7036e3f4a,a4272c351e3a..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -50,18 -53,253 +50,261 @@@
  #include "spectrum.h"
  #include "core.h"
  #include "reg.h"
++<<<<<<< HEAD
++=======
+ #include "spectrum_cnt.h"
+ #include "spectrum_dpipe.h"
+ #include "spectrum_router.h"
+ 
+ struct mlxsw_sp_vr;
+ struct mlxsw_sp_lpm_tree;
+ struct mlxsw_sp_rif_ops;
+ 
+ struct mlxsw_sp_router {
+ 	struct mlxsw_sp *mlxsw_sp;
+ 	struct mlxsw_sp_rif **rifs;
+ 	struct mlxsw_sp_vr *vrs;
+ 	struct rhashtable neigh_ht;
+ 	struct rhashtable nexthop_group_ht;
+ 	struct rhashtable nexthop_ht;
+ 	struct {
+ 		struct mlxsw_sp_lpm_tree *trees;
+ 		unsigned int tree_count;
+ 	} lpm;
+ 	struct {
+ 		struct delayed_work dw;
+ 		unsigned long interval;	/* ms */
+ 	} neighs_update;
+ 	struct delayed_work nexthop_probe_dw;
+ #define MLXSW_SP_UNRESOLVED_NH_PROBE_INTERVAL 5000 /* ms */
+ 	struct list_head nexthop_neighs_list;
+ 	bool aborted;
+ 	struct notifier_block fib_nb;
+ 	const struct mlxsw_sp_rif_ops **rif_ops_arr;
+ };
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  
  struct mlxsw_sp_rif {
  	struct list_head nexthop_list;
  	struct list_head neigh_list;
  	struct net_device *dev;
 -	struct mlxsw_sp_fid *fid;
 +	struct mlxsw_sp_fid *f;
  	unsigned char addr[ETH_ALEN];
  	int mtu;
 -	u16 rif_index;
 +	u16 rif;
  	u16 vr_id;
++<<<<<<< HEAD
++};
++
++=======
+ 	const struct mlxsw_sp_rif_ops *ops;
+ 	struct mlxsw_sp *mlxsw_sp;
+ 
+ 	unsigned int counter_ingress;
+ 	bool counter_ingress_valid;
+ 	unsigned int counter_egress;
+ 	bool counter_egress_valid;
+ };
+ 
+ struct mlxsw_sp_rif_params {
+ 	struct net_device *dev;
+ 	union {
+ 		u16 system_port;
+ 		u16 lag_id;
+ 	};
+ 	u16 vid;
+ 	bool lag;
+ };
+ 
+ struct mlxsw_sp_rif_subport {
+ 	struct mlxsw_sp_rif common;
+ 	union {
+ 		u16 system_port;
+ 		u16 lag_id;
+ 	};
+ 	u16 vid;
+ 	bool lag;
+ };
+ 
+ struct mlxsw_sp_rif_ops {
+ 	enum mlxsw_sp_rif_type type;
+ 	size_t rif_size;
+ 
+ 	void (*setup)(struct mlxsw_sp_rif *rif,
+ 		      const struct mlxsw_sp_rif_params *params);
+ 	int (*configure)(struct mlxsw_sp_rif *rif);
+ 	void (*deconfigure)(struct mlxsw_sp_rif *rif);
+ 	struct mlxsw_sp_fid * (*fid_get)(struct mlxsw_sp_rif *rif);
  };
  
+ static unsigned int *
+ mlxsw_sp_rif_p_counter_get(struct mlxsw_sp_rif *rif,
+ 			   enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return &rif->counter_egress;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return &rif->counter_ingress;
+ 	}
+ 	return NULL;
+ }
+ 
+ static bool
+ mlxsw_sp_rif_counter_valid_get(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return rif->counter_egress_valid;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return rif->counter_ingress_valid;
+ 	}
+ 	return false;
+ }
+ 
+ static void
+ mlxsw_sp_rif_counter_valid_set(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir,
+ 			       bool valid)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		rif->counter_egress_valid = valid;
+ 		break;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		rif->counter_ingress_valid = valid;
+ 		break;
+ 	}
+ }
+ 
+ static int mlxsw_sp_rif_counter_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,
+ 				     unsigned int counter_index, bool enable,
+ 				     enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 	bool is_egress = false;
+ 	int err;
+ 
+ 	if (dir == MLXSW_SP_RIF_COUNTER_EGRESS)
+ 		is_egress = true;
+ 	mlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	mlxsw_reg_ritr_counter_pack(ritr_pl, counter_index, enable,
+ 				    is_egress);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_rif *rif,
+ 				   enum mlxsw_sp_rif_counter_dir dir, u64 *cnt)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 	unsigned int *p_counter_index;
+ 	bool valid;
+ 	int err;
+ 
+ 	valid = mlxsw_sp_rif_counter_valid_get(rif, dir);
+ 	if (!valid)
+ 		return -EINVAL;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, *p_counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_NOP);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ 	if (err)
+ 		return err;
+ 	*cnt = mlxsw_reg_ricnt_good_unicast_packets_get(ricnt_pl);
+ 	return 0;
+ }
+ 
+ static int mlxsw_sp_rif_counter_clear(struct mlxsw_sp *mlxsw_sp,
+ 				      unsigned int counter_index)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_CLEAR);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_alloc(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 	int err;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	err = mlxsw_sp_counter_alloc(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 				     p_counter_index);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_rif_counter_clear(mlxsw_sp, *p_counter_index);
+ 	if (err)
+ 		goto err_counter_clear;
+ 
+ 	err = mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 					*p_counter_index, true, dir);
+ 	if (err)
+ 		goto err_counter_edit;
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, true);
+ 	return 0;
+ 
+ err_counter_edit:
+ err_counter_clear:
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_rif_counter_free(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 
+ 	if (!mlxsw_sp_rif_counter_valid_get(rif, dir))
+ 		return;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (WARN_ON(!p_counter_index))
+ 		return;
+ 	mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 				  *p_counter_index, false, dir);
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, false);
+ }
+ 
+ static void mlxsw_sp_rif_counters_alloc(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct devlink *devlink;
+ 
+ 	devlink = priv_to_devlink(mlxsw_sp->core);
+ 	if (!devlink_dpipe_table_counter_enabled(devlink,
+ 						 MLXSW_SP_DPIPE_TABLE_NAME_ERIF))
+ 		return;
+ 	mlxsw_sp_rif_counter_alloc(mlxsw_sp, rif, MLXSW_SP_RIF_COUNTER_EGRESS);
+ }
+ 
+ static void mlxsw_sp_rif_counters_free(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 
+ 	mlxsw_sp_rif_counter_free(mlxsw_sp, rif, MLXSW_SP_RIF_COUNTER_EGRESS);
+ }
+ 
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  static struct mlxsw_sp_rif *
  mlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,
  			 const struct net_device *dev);
@@@ -2682,218 -2960,262 +2925,384 @@@ static bool mlxsw_sp_rif_should_config(
  	return false;
  }
  
++<<<<<<< HEAD
 +#define MLXSW_SP_INVALID_RIF 0xffff
++=======
+ static enum mlxsw_sp_rif_type
+ mlxsw_sp_dev_rif_type(const struct mlxsw_sp *mlxsw_sp,
+ 		      const struct net_device *dev)
+ {
+ 	enum mlxsw_sp_fid_type type;
+ 
+ 	/* RIF type is derived from the type of the underlying FID */
+ 	if (is_vlan_dev(dev) && netif_is_bridge_master(vlan_dev_real_dev(dev)))
+ 		type = MLXSW_SP_FID_TYPE_8021Q;
+ 	else if (netif_is_bridge_master(dev) && br_vlan_enabled(dev))
+ 		type = MLXSW_SP_FID_TYPE_8021Q;
+ 	else if (netif_is_bridge_master(dev))
+ 		type = MLXSW_SP_FID_TYPE_8021D;
+ 	else
+ 		type = MLXSW_SP_FID_TYPE_RFID;
+ 
+ 	return mlxsw_sp_fid_type_rif_type(mlxsw_sp, type);
+ }
+ 
+ #define MLXSW_SP_INVALID_INDEX_RIF 0xffff
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  static int mlxsw_sp_avail_rif_get(struct mlxsw_sp *mlxsw_sp)
  {
  	int i;
  
  	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
 -		if (!mlxsw_sp->router->rifs[i])
 +		if (!mlxsw_sp->rifs[i])
  			return i;
  
 -	return MLXSW_SP_INVALID_INDEX_RIF;
 +	return MLXSW_SP_INVALID_RIF;
 +}
 +
++<<<<<<< HEAD
 +static void mlxsw_sp_vport_rif_sp_attr_get(struct mlxsw_sp_port *mlxsw_sp_vport,
 +					   bool *p_lagged, u16 *p_system_port)
 +{
 +	u8 local_port = mlxsw_sp_vport->local_port;
 +
 +	*p_lagged = mlxsw_sp_vport->lagged;
 +	*p_system_port = *p_lagged ? mlxsw_sp_vport->lag_id : local_port;
 +}
 +
 +static int mlxsw_sp_vport_rif_sp_op(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				    u16 vr_id, struct net_device *l3_dev,
 +				    u16 rif, bool create)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	bool lagged = mlxsw_sp_vport->lagged;
 +	char ritr_pl[MLXSW_REG_RITR_LEN];
 +	u16 system_port;
 +
 +	mlxsw_reg_ritr_pack(ritr_pl, create, MLXSW_REG_RITR_SP_IF, rif, vr_id,
 +			    l3_dev->mtu, l3_dev->dev_addr);
 +
 +	mlxsw_sp_vport_rif_sp_attr_get(mlxsw_sp_vport, &lagged, &system_port);
 +	mlxsw_reg_ritr_sp_if_pack(ritr_pl, lagged, system_port,
 +				  mlxsw_sp_vport_vid_get(mlxsw_sp_vport));
 +
 +	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
 +}
 +
 +static void mlxsw_sp_vport_rif_sp_leave(struct mlxsw_sp_port *mlxsw_sp_vport);
 +
 +static u16 mlxsw_sp_rif_sp_to_fid(u16 rif)
 +{
 +	return MLXSW_SP_RFID_BASE + rif;
  }
  
 +static struct mlxsw_sp_fid *
 +mlxsw_sp_rfid_alloc(u16 fid, struct net_device *l3_dev)
 +{
 +	struct mlxsw_sp_fid *f;
 +
 +	f = kzalloc(sizeof(*f), GFP_KERNEL);
 +	if (!f)
 +		return NULL;
 +
 +	f->leave = mlxsw_sp_vport_rif_sp_leave;
 +	f->ref_count = 0;
 +	f->dev = l3_dev;
 +	f->fid = fid;
++=======
+ static struct mlxsw_sp_rif *mlxsw_sp_rif_alloc(size_t rif_size, u16 rif_index,
+ 					       u16 vr_id,
+ 					       struct net_device *l3_dev)
+ {
+ 	struct mlxsw_sp_rif *rif;
+ 
+ 	rif = kzalloc(rif_size, GFP_KERNEL);
+ 	if (!rif)
+ 		return NULL;
+ 
+ 	INIT_LIST_HEAD(&rif->nexthop_list);
+ 	INIT_LIST_HEAD(&rif->neigh_list);
+ 	ether_addr_copy(rif->addr, l3_dev->dev_addr);
+ 	rif->mtu = l3_dev->mtu;
+ 	rif->vr_id = vr_id;
+ 	rif->dev = l3_dev;
+ 	rif->rif_index = rif_index;
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  
 -	return rif;
 +	return f;
  }
  
 -struct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,
 -					   u16 rif_index)
 +static struct mlxsw_sp_rif *
++<<<<<<< HEAD
 +mlxsw_sp_rif_alloc(u16 rif, u16 vr_id, struct net_device *l3_dev,
 +		   struct mlxsw_sp_fid *f)
  {
 -	return mlxsw_sp->router->rifs[rif_index];
 -}
 +	struct mlxsw_sp_rif *r;
  
 -u16 mlxsw_sp_rif_index(const struct mlxsw_sp_rif *rif)
 -{
 -	return rif->rif_index;
 -}
 +	r = kzalloc(sizeof(*r), GFP_KERNEL);
 +	if (!r)
 +		return NULL;
  
 -int mlxsw_sp_rif_dev_ifindex(const struct mlxsw_sp_rif *rif)
 -{
 -	return rif->dev->ifindex;
 +	INIT_LIST_HEAD(&r->nexthop_list);
 +	INIT_LIST_HEAD(&r->neigh_list);
 +	ether_addr_copy(r->addr, l3_dev->dev_addr);
 +	r->mtu = l3_dev->mtu;
 +	r->vr_id = vr_id;
 +	r->dev = l3_dev;
 +	r->rif = rif;
 +	r->f = f;
 +
 +	return r;
  }
  
  static struct mlxsw_sp_rif *
 +mlxsw_sp_vport_rif_sp_create(struct mlxsw_sp_port *mlxsw_sp_vport,
 +			     struct net_device *l3_dev)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
++=======
+ mlxsw_sp_rif_create(struct mlxsw_sp *mlxsw_sp,
+ 		    const struct mlxsw_sp_rif_params *params)
+ {
+ 	u32 tb_id = l3mdev_fib_table(params->dev);
+ 	const struct mlxsw_sp_rif_ops *ops;
+ 	enum mlxsw_sp_rif_type type;
+ 	struct mlxsw_sp_rif *rif;
+ 	struct mlxsw_sp_fid *fid;
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  	struct mlxsw_sp_vr *vr;
 -	u16 rif_index;
 +	struct mlxsw_sp_fid *f;
 +	struct mlxsw_sp_rif *r;
 +	u16 fid, rif;
  	int err;
  
++<<<<<<< HEAD
 +	rif = mlxsw_sp_avail_rif_get(mlxsw_sp);
 +	if (rif == MLXSW_SP_INVALID_RIF)
 +		return ERR_PTR(-ERANGE);
 +
 +	vr = mlxsw_sp_vr_get(mlxsw_sp, RT_TABLE_MAIN);
++=======
+ 	type = mlxsw_sp_dev_rif_type(mlxsw_sp, params->dev);
+ 	ops = mlxsw_sp->router->rif_ops_arr[type];
+ 
+ 	vr = mlxsw_sp_vr_get(mlxsw_sp, tb_id ? : RT_TABLE_MAIN);
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  	if (IS_ERR(vr))
  		return ERR_CAST(vr);
  
 -	rif_index = mlxsw_sp_avail_rif_get(mlxsw_sp);
 -	if (rif_index == MLXSW_SP_INVALID_INDEX_RIF) {
 -		err = -ERANGE;
 -		goto err_avail_rif_get;
 +	err = mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif,
 +				       true);
 +	if (err)
 +		goto err_vport_rif_sp_op;
 +
 +	fid = mlxsw_sp_rif_sp_to_fid(rif);
 +	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, true);
 +	if (err)
 +		goto err_rif_fdb_op;
 +
 +	f = mlxsw_sp_rfid_alloc(fid, l3_dev);
 +	if (!f) {
 +		err = -ENOMEM;
 +		goto err_rfid_alloc;
  	}
  
++<<<<<<< HEAD
 +	r = mlxsw_sp_rif_alloc(rif, vr->id, l3_dev, f);
 +	if (!r) {
++=======
+ 	rif = mlxsw_sp_rif_alloc(ops->rif_size, rif_index, vr->id, params->dev);
+ 	if (!rif) {
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  		err = -ENOMEM;
  		goto err_rif_alloc;
  	}
+ 	rif->mlxsw_sp = mlxsw_sp;
+ 	rif->ops = ops;
  
++<<<<<<< HEAD
 +	f->r = r;
 +	mlxsw_sp->rifs[rif] = r;
++=======
+ 	fid = ops->fid_get(rif);
+ 	if (IS_ERR(fid)) {
+ 		err = PTR_ERR(fid);
+ 		goto err_fid_get;
+ 	}
+ 	rif->fid = fid;
+ 
+ 	if (ops->setup)
+ 		ops->setup(rif, params);
+ 
+ 	err = ops->configure(rif);
+ 	if (err)
+ 		goto err_configure;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, params->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_rif_counters_alloc(rif);
+ 	mlxsw_sp_fid_rif_set(fid, rif);
+ 	mlxsw_sp->router->rifs[rif_index] = rif;
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  	vr->rif_count++;
  
 -	return rif;
 +	return r;
  
++<<<<<<< HEAD
 +err_rif_alloc:
 +	kfree(f);
 +err_rfid_alloc:
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
 +err_rif_fdb_op:
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
 +err_vport_rif_sp_op:
++=======
+ err_rif_fdb_op:
+ 	ops->deconfigure(rif);
+ err_configure:
+ 	mlxsw_sp_fid_put(fid);
+ err_fid_get:
+ 	kfree(rif);
+ err_rif_alloc:
+ err_avail_rif_get:
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  	mlxsw_sp_vr_put(vr);
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
 +static void mlxsw_sp_vport_rif_sp_destroy(struct mlxsw_sp_port *mlxsw_sp_vport,
 +					  struct mlxsw_sp_rif *r)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_vr *vr = &mlxsw_sp->router.vrs[r->vr_id];
 +	struct net_device *l3_dev = r->dev;
 +	struct mlxsw_sp_fid *f = r->f;
 +	u16 fid = f->fid;
 +	u16 rif = r->rif;
 +
 +	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, r);
 +
 +	vr->rif_count--;
 +	mlxsw_sp->rifs[rif] = NULL;
 +	f->r = NULL;
 +
 +	kfree(r);
 +
 +	kfree(f);
 +
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
 +
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
 +
 +	mlxsw_sp_vr_put(vr);
 +}
 +
 +static int mlxsw_sp_vport_rif_sp_join(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				      struct net_device *l3_dev)
++=======
+ void mlxsw_sp_rif_destroy(struct mlxsw_sp_rif *rif)
+ {
+ 	const struct mlxsw_sp_rif_ops *ops = rif->ops;
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 	struct mlxsw_sp_vr *vr;
+ 
+ 	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, rif);
+ 	vr = &mlxsw_sp->router->vrs[rif->vr_id];
+ 
+ 	vr->rif_count--;
+ 	mlxsw_sp->router->rifs[rif->rif_index] = NULL;
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_counters_free(rif);
+ 	mlxsw_sp_rif_fdb_op(mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	ops->deconfigure(rif);
+ 	mlxsw_sp_fid_put(fid);
+ 	kfree(rif);
+ 	mlxsw_sp_vr_put(vr);
+ }
+ 
+ static void
+ mlxsw_sp_rif_subport_params_init(struct mlxsw_sp_rif_params *params,
+ 				 struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)
+ {
+ 	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
+ 
+ 	params->vid = mlxsw_sp_port_vlan->vid;
+ 	params->lag = mlxsw_sp_port->lagged;
+ 	if (params->lag)
+ 		params->lag_id = mlxsw_sp_port->lag_id;
+ 	else
+ 		params->system_port = mlxsw_sp_port->local_port;
+ }
+ 
+ static int
+ mlxsw_sp_port_vlan_router_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,
+ 			       struct net_device *l3_dev)
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  {
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 -	u16 vid = mlxsw_sp_port_vlan->vid;
 -	struct mlxsw_sp_rif *rif;
 -	struct mlxsw_sp_fid *fid;
 -	int err;
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_rif *r;
 +
++<<<<<<< HEAD
 +	r = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 +	if (!r) {
 +		r = mlxsw_sp_vport_rif_sp_create(mlxsw_sp_vport, l3_dev);
 +		if (IS_ERR(r))
 +			return PTR_ERR(r);
 +	}
  
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, r->f);
 +	r->f->ref_count++;
++=======
+ 	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
+ 	if (!rif) {
+ 		struct mlxsw_sp_rif_params params = {
+ 			.dev = l3_dev,
+ 		};
+ 
+ 		mlxsw_sp_rif_subport_params_init(&params, mlxsw_sp_port_vlan);
+ 		rif = mlxsw_sp_rif_create(mlxsw_sp, &params);
+ 		if (IS_ERR(rif))
+ 			return PTR_ERR(rif);
+ 	}
+ 
+ 	/* FID was already created, just take a reference */
+ 	fid = rif->ops->fid_get(rif);
+ 	err = mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port, vid);
+ 	if (err)
+ 		goto err_fid_port_vid_map;
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  
 -	err = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);
 -	if (err)
 -		goto err_port_vid_learning_set;
 -
 -	err = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,
 -					BR_STATE_FORWARDING);
 -	if (err)
 -		goto err_port_vid_stp_set;
 -
 -	mlxsw_sp_port_vlan->fid = fid;
 +	netdev_dbg(mlxsw_sp_vport->dev, "Joined FID=%d\n", r->f->fid);
  
  	return 0;
 -
 -err_port_vid_stp_set:
 -	mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);
 -err_port_vid_learning_set:
 -	mlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);
 -err_fid_port_vid_map:
 -	mlxsw_sp_fid_put(fid);
 -	return err;
  }
  
 -void
 -mlxsw_sp_port_vlan_router_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)
 +static void mlxsw_sp_vport_rif_sp_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;
 -	u16 vid = mlxsw_sp_port_vlan->vid;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
  
 -	if (WARN_ON(mlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_RFID))
 -		return;
 +	netdev_dbg(mlxsw_sp_vport->dev, "Left FID=%d\n", f->fid);
  
 -	mlxsw_sp_port_vlan->fid = NULL;
 -	mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_BLOCKING);
 -	mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);
 -	mlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);
 -	/* If router port holds the last reference on the rFID, then the
 -	 * associated Sub-port RIF will be destroyed.
 -	 */
 -	mlxsw_sp_fid_put(fid);
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, NULL);
 +	if (--f->ref_count == 0)
 +		mlxsw_sp_vport_rif_sp_destroy(mlxsw_sp_vport, f->r);
  }
  
 -static int mlxsw_sp_inetaddr_port_vlan_event(struct net_device *l3_dev,
 -					     struct net_device *port_dev,
 -					     unsigned long event, u16 vid)
 +static int mlxsw_sp_inetaddr_vport_event(struct net_device *l3_dev,
 +					 struct net_device *port_dev,
 +					 unsigned long event, u16 vid)
  {
  	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(port_dev);
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
  
 -	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);
 -	if (WARN_ON(!mlxsw_sp_port_vlan))
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, vid);
 +	if (WARN_ON(!mlxsw_sp_vport))
  		return -EINVAL;
  
  	switch (event) {
@@@ -2947,186 -3271,24 +3356,206 @@@ static int mlxsw_sp_inetaddr_lag_event(
  	return __mlxsw_sp_inetaddr_lag_event(lag_dev, lag_dev, event, 1);
  }
  
++<<<<<<< HEAD
 +static struct mlxsw_sp_fid *mlxsw_sp_bridge_fid_get(struct mlxsw_sp *mlxsw_sp,
 +						    struct net_device *l3_dev)
 +{
 +	u16 fid;
 +
 +	if (is_vlan_dev(l3_dev))
 +		fid = vlan_dev_vlan_id(l3_dev);
 +	else if (mlxsw_sp->master_bridge.dev == l3_dev)
 +		fid = 1;
 +	else
 +		return mlxsw_sp_vfid_find(mlxsw_sp, l3_dev);
 +
 +	return mlxsw_sp_fid_find(mlxsw_sp, fid);
 +}
 +
 +static u8 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp)
 +{
 +	return mlxsw_core_max_ports(mlxsw_sp->core) + 1;
 +}
 +
 +static enum mlxsw_flood_table_type mlxsw_sp_flood_table_type_get(u16 fid)
 +{
 +	return mlxsw_sp_fid_is_vfid(fid) ? MLXSW_REG_SFGC_TABLE_TYPE_FID :
 +	       MLXSW_REG_SFGC_TABLE_TYPE_FID_OFFEST;
 +}
 +
 +static u16 mlxsw_sp_flood_table_index_get(u16 fid)
 +{
 +	return mlxsw_sp_fid_is_vfid(fid) ? mlxsw_sp_fid_to_vfid(fid) : fid;
 +}
 +
 +static int mlxsw_sp_router_port_flood_set(struct mlxsw_sp *mlxsw_sp, u16 fid,
 +					  bool set)
 +{
 +	u8 router_port = mlxsw_sp_router_port(mlxsw_sp);
 +	enum mlxsw_flood_table_type table_type;
 +	char *sftr_pl;
 +	u16 index;
 +	int err;
 +
 +	sftr_pl = kmalloc(MLXSW_REG_SFTR_LEN, GFP_KERNEL);
 +	if (!sftr_pl)
 +		return -ENOMEM;
 +
 +	table_type = mlxsw_sp_flood_table_type_get(fid);
 +	index = mlxsw_sp_flood_table_index_get(fid);
 +	mlxsw_reg_sftr_pack(sftr_pl, MLXSW_SP_FLOOD_TABLE_BC, index, table_type,
 +			    1, router_port, set);
 +	err = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sftr), sftr_pl);
 +
 +	kfree(sftr_pl);
 +	return err;
 +}
 +
 +static enum mlxsw_reg_ritr_if_type mlxsw_sp_rif_type_get(u16 fid)
 +{
 +	if (mlxsw_sp_fid_is_vfid(fid))
 +		return MLXSW_REG_RITR_FID_IF;
 +	else
 +		return MLXSW_REG_RITR_VLAN_IF;
 +}
 +
 +static int mlxsw_sp_rif_bridge_op(struct mlxsw_sp *mlxsw_sp, u16 vr_id,
 +				  struct net_device *l3_dev,
 +				  u16 fid, u16 rif,
 +				  bool create)
 +{
 +	enum mlxsw_reg_ritr_if_type rif_type;
 +	char ritr_pl[MLXSW_REG_RITR_LEN];
 +
 +	rif_type = mlxsw_sp_rif_type_get(fid);
 +	mlxsw_reg_ritr_pack(ritr_pl, create, rif_type, rif, vr_id, l3_dev->mtu,
 +			    l3_dev->dev_addr);
 +	mlxsw_reg_ritr_fid_set(ritr_pl, rif_type, fid);
 +
 +	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
 +}
 +
 +static int mlxsw_sp_rif_bridge_create(struct mlxsw_sp *mlxsw_sp,
 +				      struct net_device *l3_dev,
 +				      struct mlxsw_sp_fid *f)
 +{
 +	struct mlxsw_sp_vr *vr;
 +	struct mlxsw_sp_rif *r;
 +	u16 rif;
 +	int err;
 +
 +	rif = mlxsw_sp_avail_rif_get(mlxsw_sp);
 +	if (rif == MLXSW_SP_INVALID_RIF)
 +		return -ERANGE;
 +
 +	vr = mlxsw_sp_vr_get(mlxsw_sp, RT_TABLE_MAIN);
 +	if (IS_ERR(vr))
 +		return PTR_ERR(vr);
 +
 +	err = mlxsw_sp_router_port_flood_set(mlxsw_sp, f->fid, true);
 +	if (err)
 +		goto err_port_flood_set;
 +
 +	err = mlxsw_sp_rif_bridge_op(mlxsw_sp, vr->id, l3_dev, f->fid, rif,
 +				     true);
 +	if (err)
 +		goto err_rif_bridge_op;
 +
 +	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, f->fid, true);
 +	if (err)
 +		goto err_rif_fdb_op;
 +
 +	r = mlxsw_sp_rif_alloc(rif, vr->id, l3_dev, f);
 +	if (!r) {
 +		err = -ENOMEM;
 +		goto err_rif_alloc;
 +	}
 +
 +	f->r = r;
 +	mlxsw_sp->rifs[rif] = r;
 +	vr->rif_count++;
 +
 +	netdev_dbg(l3_dev, "RIF=%d created\n", rif);
 +
 +	return 0;
 +
 +err_rif_alloc:
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, f->fid, false);
 +err_rif_fdb_op:
 +	mlxsw_sp_rif_bridge_op(mlxsw_sp, vr->id, l3_dev, f->fid, rif, false);
 +err_rif_bridge_op:
 +	mlxsw_sp_router_port_flood_set(mlxsw_sp, f->fid, false);
 +err_port_flood_set:
 +	mlxsw_sp_vr_put(vr);
 +	return err;
 +}
 +
 +void mlxsw_sp_rif_bridge_destroy(struct mlxsw_sp *mlxsw_sp,
 +				 struct mlxsw_sp_rif *r)
 +{
 +	struct mlxsw_sp_vr *vr = &mlxsw_sp->router.vrs[r->vr_id];
 +	struct net_device *l3_dev = r->dev;
 +	struct mlxsw_sp_fid *f = r->f;
 +	u16 rif = r->rif;
 +
 +	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, r);
 +
 +	vr->rif_count--;
 +	mlxsw_sp->rifs[rif] = NULL;
 +	f->r = NULL;
 +
 +	kfree(r);
 +
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, f->fid, false);
 +
 +	mlxsw_sp_rif_bridge_op(mlxsw_sp, vr->id, l3_dev, f->fid, rif, false);
 +
 +	mlxsw_sp_router_port_flood_set(mlxsw_sp, f->fid, false);
 +
 +	mlxsw_sp_vr_put(vr);
 +
 +	netdev_dbg(l3_dev, "RIF=%d destroyed\n", rif);
 +}
 +
++=======
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  static int mlxsw_sp_inetaddr_bridge_event(struct net_device *l3_dev,
 +					  struct net_device *br_dev,
  					  unsigned long event)
  {
  	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
++<<<<<<< HEAD
 +	struct mlxsw_sp_fid *f;
 +
 +	/* FID can either be an actual FID if the L3 device is the
 +	 * VLAN-aware bridge or a VLAN device on top. Otherwise, the
 +	 * L3 device is a VLAN-unaware bridge and we get a vFID.
 +	 */
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return -EINVAL;
 +
 +	switch (event) {
 +	case NETDEV_UP:
 +		return mlxsw_sp_rif_bridge_create(mlxsw_sp, l3_dev, f);
 +	case NETDEV_DOWN:
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
++=======
+ 	struct mlxsw_sp_rif_params params = {
+ 		.dev = l3_dev,
+ 	};
+ 	struct mlxsw_sp_rif *rif;
+ 
+ 	switch (event) {
+ 	case NETDEV_UP:
+ 		rif = mlxsw_sp_rif_create(mlxsw_sp, &params);
+ 		if (IS_ERR(rif))
+ 			return PTR_ERR(rif);
+ 		break;
+ 	case NETDEV_DOWN:
+ 		rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
+ 		mlxsw_sp_rif_destroy(rif);
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  		break;
  	}
  
@@@ -3241,71 -3410,261 +3670,280 @@@ err_rif_edit
  	return err;
  }
  
 -static int mlxsw_sp_port_vrf_join(struct mlxsw_sp *mlxsw_sp,
 -				  struct net_device *l3_dev)
 +int mlxsw_sp_vport_vrf_join(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
 +	struct net_device *dev = mlxsw_sp_vport->dev;
  
 -	/* If netdev is already associated with a RIF, then we need to
 -	 * destroy it and create a new one with the new virtual router ID.
 +	/* In case vPort already has a RIF, then we need to drop it.
 +	 * A new one will be created using the VRF's VR.
  	 */
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (rif)
 -		__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +	if (f && f->r)
 +		mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
  
 -	return __mlxsw_sp_inetaddr_event(l3_dev, NETDEV_UP);
 +	return mlxsw_sp_vport_rif_sp_join(mlxsw_sp_vport, dev);
  }
  
 -static void mlxsw_sp_port_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 -				    struct net_device *l3_dev)
 +void mlxsw_sp_vport_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
 +}
  
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (!rif)
 +int mlxsw_sp_port_vrf_join(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
 +		return -EINVAL;
 +
 +	return mlxsw_sp_vport_vrf_join(mlxsw_sp_vport);
 +}
 +
 +void mlxsw_sp_port_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
  		return;
 -	__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +
 +	mlxsw_sp_vport_vrf_leave(mlxsw_sp_vport);
  }
  
 -int mlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,
 -				 struct netdev_notifier_changeupper_info *info)
 +int mlxsw_sp_bridge_vrf_join(struct mlxsw_sp *mlxsw_sp,
 +			     struct net_device *l3_dev)
  {
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
 -	int err = 0;
 +	struct mlxsw_sp_fid *f;
  
 -	if (!mlxsw_sp)
 -		return 0;
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return -EINVAL;
  
 -	switch (event) {
 -	case NETDEV_PRECHANGEUPPER:
 -		return 0;
 -	case NETDEV_CHANGEUPPER:
 -		if (info->linking)
 -			err = mlxsw_sp_port_vrf_join(mlxsw_sp, l3_dev);
 -		else
 -			mlxsw_sp_port_vrf_leave(mlxsw_sp, l3_dev);
 -		break;
 -	}
 +	if (f->r)
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
  
 -	return err;
 +	return mlxsw_sp_rif_bridge_create(mlxsw_sp, l3_dev, f);
  }
  
++<<<<<<< HEAD
 +void mlxsw_sp_bridge_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 +			       struct net_device *l3_dev)
 +{
 +	struct mlxsw_sp_fid *f;
 +
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return;
 +	mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
++=======
+ static struct mlxsw_sp_rif_subport *
+ mlxsw_sp_rif_subport_rif(const struct mlxsw_sp_rif *rif)
+ {
+ 	return container_of(rif, struct mlxsw_sp_rif_subport, common);
+ }
+ 
+ static void mlxsw_sp_rif_subport_setup(struct mlxsw_sp_rif *rif,
+ 				       const struct mlxsw_sp_rif_params *params)
+ {
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	rif_subport->vid = params->vid;
+ 	rif_subport->lag = params->lag;
+ 	if (params->lag)
+ 		rif_subport->lag_id = params->lag_id;
+ 	else
+ 		rif_subport->system_port = params->system_port;
+ }
+ 
+ static int mlxsw_sp_rif_subport_op(struct mlxsw_sp_rif *rif, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_SP_IF,
+ 			    rif->rif_index, rif->vr_id, rif->dev->mtu,
+ 			    rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_sp_if_pack(ritr_pl, rif_subport->lag,
+ 				  rif_subport->lag ? rif_subport->lag_id :
+ 						     rif_subport->system_port,
+ 				  rif_subport->vid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static int mlxsw_sp_rif_subport_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_rif_subport_op(rif, true);
+ }
+ 
+ static void mlxsw_sp_rif_subport_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	mlxsw_sp_rif_subport_op(rif, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_subport_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_rfid_get(rif->mlxsw_sp, rif->rif_index);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_subport_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_SUBPORT,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif_subport),
+ 	.setup			= mlxsw_sp_rif_subport_setup,
+ 	.configure		= mlxsw_sp_rif_subport_configure,
+ 	.deconfigure		= mlxsw_sp_rif_subport_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_subport_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_vlan_fid_op(struct mlxsw_sp_rif *rif,
+ 				    enum mlxsw_reg_ritr_if_type type,
+ 				    u16 vid_fid, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, type, rif->rif_index, rif->vr_id,
+ 			    rif->dev->mtu, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_fid_set(ritr_pl, type, vid_fid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static u8 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp)
+ {
+ 	return mlxsw_core_max_ports(mlxsw_sp->core) + 1;
+ }
+ 
+ static int mlxsw_sp_rif_vlan_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	return 0;
+ 
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_vlan_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 vid = is_vlan_dev(rif->dev) ? vlan_dev_vlan_id(rif->dev) : 1;
+ 
+ 	return mlxsw_sp_fid_8021q_get(rif->mlxsw_sp, vid);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_vlan_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_VLAN,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_vlan_configure,
+ 	.deconfigure		= mlxsw_sp_rif_vlan_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_vlan_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_fid_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index,
+ 				       true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	return 0;
+ 
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_fid_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_8021d_get(rif->mlxsw_sp, rif->dev->ifindex);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_fid_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_FID,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_fid_configure,
+ 	.deconfigure		= mlxsw_sp_rif_fid_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_fid_fid_get,
+ };
+ 
+ static const struct mlxsw_sp_rif_ops *mlxsw_sp_rif_ops_arr[] = {
+ 	[MLXSW_SP_RIF_TYPE_SUBPORT]	= &mlxsw_sp_rif_subport_ops,
+ 	[MLXSW_SP_RIF_TYPE_VLAN]	= &mlxsw_sp_rif_vlan_ops,
+ 	[MLXSW_SP_RIF_TYPE_FID]		= &mlxsw_sp_rif_fid_ops,
+ };
+ 
+ static int mlxsw_sp_rifs_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	u64 max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);
+ 
+ 	mlxsw_sp->router->rifs = kcalloc(max_rifs,
+ 					 sizeof(struct mlxsw_sp_rif *),
+ 					 GFP_KERNEL);
+ 	if (!mlxsw_sp->router->rifs)
+ 		return -ENOMEM;
+ 
+ 	mlxsw_sp->router->rif_ops_arr = mlxsw_sp_rif_ops_arr;
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_rifs_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
+ 		WARN_ON_ONCE(mlxsw_sp->router->rifs[i]);
+ 
+ 	kfree(mlxsw_sp->router->rifs);
++>>>>>>> e4f3c1c17b6d (mlxsw: spectrum_router: Implement common RIF core)
  }
  
  static void mlxsw_sp_router_fib_dump_flush(struct notifier_block *nb)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_fid.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_fid.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
