x86/dumpstack: Remove raw stack dump

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] dumpstack: Remove raw stack dump (Scott Wood) [1479560]
Rebuild_FUZZ: 94.12%
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 0ee1dd9f5e7eae4e55f95935b72d4beecb03de9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0ee1dd9f.failed

For mostly historical reasons, the x86 oops dump shows the raw stack
values:

  ...
  [registers]
  Stack:
   ffff880079af7350 ffff880079905400 0000000000000000 ffffc900008f3ae0
   ffffffffa0196610 0000000000000001 00010000ffffffff 0000000087654321
   0000000000000002 0000000000000000 0000000000000000 0000000000000000
  Call Trace:
  ...

This seems to be an artifact from long ago, and probably isn't needed
anymore.  It generally just adds noise to the dump, and it can be
actively harmful because it leaks kernel addresses.

Linus says:

  "The stack dump actually goes back to forever, and it used to be
   useful back in 1992 or so. But it used to be useful mainly because
   stacks were simpler and we didn't have very good call traces anyway. I
   definitely remember having used them - I just do not remember having
   used them in the last ten+ years.

   Of course, it's still true that if you can trigger an oops, you've
   likely already lost the security game, but since the stack dump is so
   useless, let's aim to just remove it and make games like the above
   harder."

This also removes the related 'kstack=' cmdline option and the
'kstack_depth_to_print' sysctl.

	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/e83bd50df52d8fe88e94d2566426ae40d813bf8f.1477405374.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0ee1dd9f5e7eae4e55f95935b72d4beecb03de9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/x86/x86_64/boot-options.txt
#	arch/x86/include/asm/stacktrace.h
#	arch/x86/kernel/dumpstack.c
#	arch/x86/kernel/dumpstack_32.c
#	arch/x86/kernel/dumpstack_64.c
diff --cc Documentation/x86/x86_64/boot-options.txt
index 1548b73e021f,61b611e9eeaf..000000000000
--- a/Documentation/x86/x86_64/boot-options.txt
+++ b/Documentation/x86/x86_64/boot-options.txt
@@@ -288,20 -277,6 +288,23 @@@ IOMMU (input/output memory management u
      space might stop working. Use this option if you have devices that
      are accessed from userspace directly on some PCI host bridge.
  
++<<<<<<< HEAD
 +Debugging
 +
 +  kstack=N	Print N words from the kernel stack in oops dumps.
 +
 +  pagefaulttrace  Dump all page faults. Only useful for extreme debugging
 +		and will create a lot of output.
 +
 +  call_trace=[old|both|newfallback|new]
 +		old: use old inexact backtracer
 +		new: use new exact dwarf2 unwinder
 + 		both: print entries from both
 +		newfallback: use new unwinder but fall back to old if it gets
 +			stuck (default)
 +
++=======
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  Miscellaneous
  
  	nogbpages
diff --cc arch/x86/include/asm/stacktrace.h
index 7c247e7404be,1e375b05cfa8..000000000000
--- a/arch/x86/include/asm/stacktrace.h
+++ b/arch/x86/include/asm/stacktrace.h
@@@ -8,86 -8,81 +8,100 @@@
  
  #include <linux/uaccess.h>
  #include <linux/ptrace.h>
 -#include <asm/switch_to.h>
 -
 -enum stack_type {
 -	STACK_TYPE_UNKNOWN,
 -	STACK_TYPE_TASK,
 -	STACK_TYPE_IRQ,
 -	STACK_TYPE_SOFTIRQ,
 -	STACK_TYPE_EXCEPTION,
 -	STACK_TYPE_EXCEPTION_LAST = STACK_TYPE_EXCEPTION + N_EXCEPTION_STACKS-1,
 -};
  
 -struct stack_info {
 -	enum stack_type type;
 -	unsigned long *begin, *end, *next_sp;
++<<<<<<< HEAD
 +extern int kstack_depth_to_print;
 +
 +struct thread_info;
 +struct stacktrace_ops;
 +
 +typedef unsigned long (*walk_stack_t)(struct thread_info *tinfo,
 +				      unsigned long *stack,
 +				      unsigned long bp,
 +				      const struct stacktrace_ops *ops,
 +				      void *data,
 +				      unsigned long *end,
 +				      int *graph);
 +
 +extern unsigned long
 +print_context_stack(struct thread_info *tinfo,
 +		    unsigned long *stack, unsigned long bp,
 +		    const struct stacktrace_ops *ops, void *data,
 +		    unsigned long *end, int *graph);
 +
 +extern unsigned long
 +print_context_stack_bp(struct thread_info *tinfo,
 +		       unsigned long *stack, unsigned long bp,
 +		       const struct stacktrace_ops *ops, void *data,
 +		       unsigned long *end, int *graph);
 +
 +/* Generic stack tracer with callbacks */
 +
 +struct stacktrace_ops {
 +	int (*address)(void *data, unsigned long address, int reliable);
 +	/* On negative return stop dumping */
 +	int (*stack)(void *data, char *name);
 +	walk_stack_t	walk_stack;
  };
  
 -bool in_task_stack(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info);
 -
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask);
 -
 -void stack_type_str(enum stack_type type, const char **begin,
 -		    const char **end);
 -
 -static inline bool on_stack(struct stack_info *info, void *addr, size_t len)
 -{
 -	void *begin = info->begin;
 -	void *end   = info->end;
 -
 -	return (info->type != STACK_TYPE_UNKNOWN &&
 -		addr >= begin && addr < end &&
 -		addr + len > begin && addr + len <= end);
 -}
 +void dump_trace(struct task_struct *tsk, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data);
  
++=======
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  #ifdef CONFIG_X86_32
  #define STACKSLOTS_PER_LINE 8
 +#define get_bp(bp) asm("movl %%ebp, %0" : "=r" (bp) :)
  #else
  #define STACKSLOTS_PER_LINE 4
 +#define get_bp(bp) asm("movq %%rbp, %0" : "=r" (bp) :)
  #endif
  
  #ifdef CONFIG_FRAME_POINTER
 -static inline unsigned long *
 -get_frame_pointer(struct task_struct *task, struct pt_regs *regs)
 +static inline unsigned long
 +stack_frame(struct task_struct *task, struct pt_regs *regs)
  {
 +	unsigned long bp;
 +
  	if (regs)
 -		return (unsigned long *)regs->bp;
 +		return regs->bp;
  
 -	if (task == current)
 -		return __builtin_frame_address(0);
 +	if (task == current) {
 +		/* Grab bp right from our regs */
 +		get_bp(bp);
 +		return bp;
 +	}
  
 -	return (unsigned long *)((struct inactive_task_frame *)task->thread.sp)->bp;
 +	/* bp is the last reg pushed by switch_to */
 +	return *(unsigned long *)task->thread.sp;
  }
  #else
 -static inline unsigned long *
 -get_frame_pointer(struct task_struct *task, struct pt_regs *regs)
 +static inline unsigned long
 +stack_frame(struct task_struct *task, struct pt_regs *regs)
  {
 -	return NULL;
 +	return 0;
  }
 -#endif /* CONFIG_FRAME_POINTER */
 +#endif
  
 -static inline unsigned long *
 -get_stack_pointer(struct task_struct *task, struct pt_regs *regs)
 -{
 -	if (regs)
 -		return (unsigned long *)kernel_stack_pointer(regs);
 +extern void
 +show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *stack, unsigned long bp, char *log_lvl);
  
++<<<<<<< HEAD
 +extern void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl);
++=======
+ 	if (task == current)
+ 		return __builtin_frame_address(0);
+ 
+ 	return (unsigned long *)task->thread.sp;
+ }
+ 
+ void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
+ 			unsigned long *stack, char *log_lvl);
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  
  extern unsigned int code_bytes;
  
diff --cc arch/x86/kernel/dumpstack.c
index 08594671b59f,499aa6f0fde5..000000000000
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@@ -22,164 -22,141 +22,163 @@@
  int panic_on_unrecovered_nmi;
  int panic_on_io_nmi;
  unsigned int code_bytes = 64;
- int kstack_depth_to_print = 3 * STACKSLOTS_PER_LINE;
  static int die_counter;
  
 -bool in_task_stack(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info)
 +static void printk_stack_address(unsigned long address, int reliable,
 +				 char *log_lvl)
 +{
 +	touch_nmi_watchdog();
 +	printk("%s [<%p>] %s%pB\n",
 +		log_lvl, (void *)address, reliable ? "" : "? ",
 +		(void *)address);
 +}
 +
 +void printk_address(unsigned long address)
 +{
 +	pr_cont(" [<%p>] %pS\n", (void *)address, (void *)address);
 +}
 +
 +#ifdef CONFIG_FUNCTION_GRAPH_TRACER
 +static void
 +print_ftrace_graph_addr(unsigned long addr, void *data,
 +			const struct stacktrace_ops *ops,
 +			struct thread_info *tinfo, int *graph)
  {
 -	unsigned long *begin = task_stack_page(task);
 -	unsigned long *end   = task_stack_page(task) + THREAD_SIZE;
 +	struct task_struct *task;
 +	unsigned long ret_addr;
 +	int index;
 +
 +	if (addr != (unsigned long)return_to_handler)
 +		return;
  
 -	if (stack < begin || stack >= end)
 -		return false;
 +	task = tinfo->task;
 +	index = task->curr_ret_stack;
  
 -	info->type	= STACK_TYPE_TASK;
 -	info->begin	= begin;
 -	info->end	= end;
 -	info->next_sp	= NULL;
 +	if (!task->ret_stack || index < *graph)
 +		return;
 +
 +	index -= *graph;
 +	ret_addr = task->ret_stack[index].ret;
  
 -	return true;
 +	ops->address(data, ret_addr, 1);
 +
 +	(*graph)++;
  }
 +#else
 +static inline void
 +print_ftrace_graph_addr(unsigned long addr, void *data,
 +			const struct stacktrace_ops *ops,
 +			struct thread_info *tinfo, int *graph)
 +{ }
 +#endif
  
 -static void printk_stack_address(unsigned long address, int reliable,
 -				 char *log_lvl)
 +/*
 + * x86-64 can have up to three kernel stacks:
 + * process stack
 + * interrupt stack
 + * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
 + */
 +
 +static inline int valid_stack_ptr(struct thread_info *tinfo,
 +			void *p, unsigned int size, void *end)
  {
 -	touch_nmi_watchdog();
 -	printk("%s %s%pB\n", log_lvl, reliable ? "" : "? ", (void *)address);
 +	void *t = tinfo;
 +	if (end) {
 +		if (p < end && p >= (end-THREAD_SIZE))
 +			return 1;
 +		else
 +			return 0;
 +	}
 +	return p > t && p < t + THREAD_SIZE - size;
  }
  
 -void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 -			unsigned long *stack, char *log_lvl)
 +unsigned long
 +print_context_stack(struct thread_info *tinfo,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data,
 +		unsigned long *end, int *graph)
  {
 -	struct unwind_state state;
 -	struct stack_info stack_info = {0};
 -	unsigned long visit_mask = 0;
 -	int graph_idx = 0;
 -
 -	printk("%sCall Trace:\n", log_lvl);
 +	struct stack_frame *frame = (struct stack_frame *)bp;
 +
 +	while (valid_stack_ptr(tinfo, stack, sizeof(*stack), end)) {
 +		unsigned long addr;
 +
 +		addr = *stack;
 +		if (__kernel_text_address(addr)) {
 +			if ((unsigned long) stack == bp + sizeof(long)) {
 +				ops->address(data, addr, 1);
 +				frame = frame->next_frame;
 +				bp = (unsigned long) frame;
 +			} else {
 +				ops->address(data, addr, 0);
 +			}
 +			print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
 +		}
 +		stack++;
 +	}
 +	return bp;
 +}
 +EXPORT_SYMBOL_GPL(print_context_stack);
  
 -	unwind_start(&state, task, regs, stack);
 +unsigned long
 +print_context_stack_bp(struct thread_info *tinfo,
 +		       unsigned long *stack, unsigned long bp,
 +		       const struct stacktrace_ops *ops, void *data,
 +		       unsigned long *end, int *graph)
 +{
 +	struct stack_frame *frame = (struct stack_frame *)bp;
 +	unsigned long *ret_addr = &frame->return_address;
  
 -	/*
 -	 * Iterate through the stacks, starting with the current stack pointer.
 -	 * Each stack has a pointer to the next one.
 -	 *
 -	 * x86-64 can have several stacks:
 -	 * - task stack
 -	 * - interrupt stack
 -	 * - HW exception stacks (double fault, nmi, debug, mce)
 -	 *
 -	 * x86-32 can have up to three stacks:
 -	 * - task stack
 -	 * - softirq stack
 -	 * - hardirq stack
 -	 */
 -	for (regs = NULL; stack; stack = stack_info.next_sp) {
 -		const char *str_begin, *str_end;
 +	while (valid_stack_ptr(tinfo, ret_addr, sizeof(*ret_addr), end)) {
 +		unsigned long addr = *ret_addr;
  
 -		/*
 -		 * If we overflowed the task stack into a guard page, jump back
 -		 * to the bottom of the usable stack.
 -		 */
 -		if (task_stack_page(task) - (void *)stack < PAGE_SIZE)
 -			stack = task_stack_page(task);
 +		if (!__kernel_text_address(addr))
 +			break;
  
 -		if (get_stack_info(stack, task, &stack_info, &visit_mask))
 +		if (ops->address(data, addr, 1))
  			break;
 +		frame = frame->next_frame;
 +		ret_addr = &frame->return_address;
 +		print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
 +	}
  
 -		stack_type_str(stack_info.type, &str_begin, &str_end);
 -		if (str_begin)
 -			printk("%s <%s>\n", log_lvl, str_begin);
 -
 -		/*
 -		 * Scan the stack, printing any text addresses we find.  At the
 -		 * same time, follow proper stack frames with the unwinder.
 -		 *
 -		 * Addresses found during the scan which are not reported by
 -		 * the unwinder are considered to be additional clues which are
 -		 * sometimes useful for debugging and are prefixed with '?'.
 -		 * This also serves as a failsafe option in case the unwinder
 -		 * goes off in the weeds.
 -		 */
 -		for (; stack < stack_info.end; stack++) {
 -			unsigned long real_addr;
 -			int reliable = 0;
 -			unsigned long addr = *stack;
 -			unsigned long *ret_addr_p =
 -				unwind_get_return_address_ptr(&state);
 -
 -			if (!__kernel_text_address(addr))
 -				continue;
 -
 -			/*
 -			 * Don't print regs->ip again if it was already printed
 -			 * by __show_regs() below.
 -			 */
 -			if (regs && stack == &regs->ip) {
 -				unwind_next_frame(&state);
 -				continue;
 -			}
 +	return (unsigned long)frame;
 +}
 +EXPORT_SYMBOL_GPL(print_context_stack_bp);
  
 -			if (stack == ret_addr_p)
 -				reliable = 1;
 -
 -			/*
 -			 * When function graph tracing is enabled for a
 -			 * function, its return address on the stack is
 -			 * replaced with the address of an ftrace handler
 -			 * (return_to_handler).  In that case, before printing
 -			 * the "real" address, we want to print the handler
 -			 * address as an "unreliable" hint that function graph
 -			 * tracing was involved.
 -			 */
 -			real_addr = ftrace_graph_ret_addr(task, &graph_idx,
 -							  addr, stack);
 -			if (real_addr != addr)
 -				printk_stack_address(addr, 0, log_lvl);
 -			printk_stack_address(real_addr, reliable, log_lvl);
 -
 -			if (!reliable)
 -				continue;
 -
 -			/*
 -			 * Get the next frame from the unwinder.  No need to
 -			 * check for an error: if anything goes wrong, the rest
 -			 * of the addresses will just be printed as unreliable.
 -			 */
 -			unwind_next_frame(&state);
 -
 -			/* if the frame has entry regs, print them */
 -			regs = unwind_get_entry_regs(&state);
 -			if (regs)
 -				__show_regs(regs, 0);
 -		}
 +static int print_trace_stack(void *data, char *name)
 +{
 +	printk("%s <%s> ", (char *)data, name);
 +	return 0;
 +}
  
 -		if (str_end)
 -			printk("%s <%s>\n", log_lvl, str_end);
 -	}
 +/*
 + * Print one address/symbol entries per line.
 + */
 +static int print_trace_address(void *data, unsigned long addr, int reliable)
 +{
 +	printk_stack_address(addr, reliable, data);
 +	return 0;
 +}
 +
 +static const struct stacktrace_ops print_trace_ops = {
 +	.stack			= print_trace_stack,
 +	.address		= print_trace_address,
 +	.walk_stack		= print_context_stack,
 +};
 +
 +void
 +show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp, char *log_lvl)
 +{
 +	printk("%sCall Trace:\n", log_lvl);
 +	dump_trace(task, regs, stack, bp, &print_trace_ops, log_lvl);
 +}
 +
 +void show_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp)
 +{
 +	show_trace_log_lvl(task, regs, stack, bp, "");
  }
  
  void show_stack(struct task_struct *task, unsigned long *sp)
@@@ -191,12 -167,15 +190,21 @@@
  	 * Stack frames below this one aren't interesting.  Don't show them
  	 * if we're printing for %current.
  	 */
 -	if (!sp && task == current)
 -		sp = get_stack_pointer(current, NULL);
 +	if (!sp && (!task || task == current)) {
 +		sp = &stack;
 +		bp = stack_frame(current, NULL);
 +	}
  
++<<<<<<< HEAD
 +	show_stack_log_lvl(task, NULL, sp, bp, "");
++=======
+ 	show_trace_log_lvl(task, NULL, sp, KERN_DEFAULT);
+ }
+ 
+ void show_stack_regs(struct pt_regs *regs)
+ {
+ 	show_trace_log_lvl(current, regs, NULL, KERN_DEFAULT);
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  }
  
  static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;
diff --cc arch/x86/kernel/dumpstack_32.c
index c90b53d2857e,90cf460d50bd..000000000000
--- a/arch/x86/kernel/dumpstack_32.c
+++ b/arch/x86/kernel/dumpstack_32.c
@@@ -16,77 -16,111 +16,80 @@@
  
  #include <asm/stacktrace.h>
  
 -void stack_type_str(enum stack_type type, const char **begin, const char **end)
 -{
 -	switch (type) {
 -	case STACK_TYPE_IRQ:
 -	case STACK_TYPE_SOFTIRQ:
 -		*begin = "IRQ";
 -		*end   = "EOI";
 -		break;
 -	default:
 -		*begin = NULL;
 -		*end   = NULL;
 -	}
 -}
  
 -static bool in_hardirq_stack(unsigned long *stack, struct stack_info *info)
 +void dump_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data)
  {
 -	unsigned long *begin = (unsigned long *)this_cpu_read(hardirq_stack);
 -	unsigned long *end   = begin + (THREAD_SIZE / sizeof(long));
 -
 -	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 -	 */
 -	if (stack < begin || stack > end)
 -		return false;
 +	int graph = 0;
  
 -	info->type	= STACK_TYPE_IRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 +	if (!task)
 +		task = current;
  
 -	/*
 -	 * See irq_32.c -- the next stack pointer is stored at the beginning of
 -	 * the stack.
 -	 */
 -	info->next_sp	= (unsigned long *)*begin;
 +	if (!stack) {
 +		unsigned long dummy;
  
 -	return true;
 -}
 +		stack = &dummy;
 +		if (task && task != current)
 +			stack = (unsigned long *)task->thread.sp;
 +	}
  
 -static bool in_softirq_stack(unsigned long *stack, struct stack_info *info)
 -{
 -	unsigned long *begin = (unsigned long *)this_cpu_read(softirq_stack);
 -	unsigned long *end   = begin + (THREAD_SIZE / sizeof(long));
 +	if (!bp)
 +		bp = stack_frame(task, regs);
  
 -	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 -	 */
 -	if (stack < begin || stack > end)
 -		return false;
 -
 -	info->type	= STACK_TYPE_SOFTIRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 +	for (;;) {
 +		struct thread_info *context;
  
 -	/*
 -	 * The next stack pointer is stored at the beginning of the stack.
 -	 * See irq_32.c.
 -	 */
 -	info->next_sp	= (unsigned long *)*begin;
 +		context = (struct thread_info *)
 +			((unsigned long)stack & (~(THREAD_SIZE - 1)));
 +		bp = ops->walk_stack(context, stack, bp, ops, data, NULL, &graph);
  
 -	return true;
 +		stack = (unsigned long *)context->previous_esp;
 +		if (!stack)
 +			break;
 +		if (ops->stack(data, "IRQ") < 0)
 +			break;
 +		touch_nmi_watchdog();
 +	}
  }
 +EXPORT_SYMBOL(dump_trace);
  
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask)
++<<<<<<< HEAD
 +void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl)
  {
 -	if (!stack)
 -		goto unknown;
 -
 -	task = task ? : current;
 -
 -	if (in_task_stack(stack, task, info))
 -		goto recursion_check;
 -
 -	if (task != current)
 -		goto unknown;
 -
 -	if (in_hardirq_stack(stack, info))
 -		goto recursion_check;
 -
 -	if (in_softirq_stack(stack, info))
 -		goto recursion_check;
 -
 -	goto unknown;
 +	unsigned long *stack;
 +	int i;
  
 -recursion_check:
 -	/*
 -	 * Make sure we don't iterate through any given stack more than once.
 -	 * If it comes up a second time then there's something wrong going on:
 -	 * just break out and report an unknown stack type.
 -	 */
 -	if (visit_mask) {
 -		if (*visit_mask & (1UL << info->type))
 -			goto unknown;
 -		*visit_mask |= 1UL << info->type;
 +	if (sp == NULL) {
 +		if (regs)
 +			sp = (unsigned long *)regs->sp;
 +		else if (task)
 +			sp = (unsigned long *)task->thread.sp;
 +		else
 +			sp = (unsigned long *)&sp;
  	}
  
 -	return 0;
 -
 -unknown:
 -	info->type = STACK_TYPE_UNKNOWN;
 -	return -EINVAL;
 +	stack = sp;
 +	for (i = 0; i < kstack_depth_to_print; i++) {
 +		if (kstack_end(stack))
 +			break;
 +		if ((i % STACKSLOTS_PER_LINE) == 0) {
 +			if (i != 0)
 +				pr_cont("\n");
 +			printk("%s %08lx", log_lvl, *stack++);
 +		} else
 +			pr_cont(" %08lx", *stack++);
 +		touch_nmi_watchdog();
 +	}
 +	pr_cont("\n");
 +	show_trace_log_lvl(task, regs, sp, bp, log_lvl);
  }
  
 +
++=======
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  void show_regs(struct pt_regs *regs)
  {
  	int i;
@@@ -104,8 -138,7 +107,12 @@@
  		unsigned char c;
  		u8 *ip;
  
++<<<<<<< HEAD
 +		pr_emerg("Stack:\n");
 +		show_stack_log_lvl(NULL, regs, &regs->sp, 0, KERN_EMERG);
++=======
+ 		show_trace_log_lvl(current, regs, NULL, KERN_EMERG);
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  
  		pr_emerg("Code:");
  
diff --cc arch/x86/kernel/dumpstack_64.c
index 101e30243d5b,310abf4542dc..000000000000
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@@ -16,286 -16,130 +16,289 @@@
  
  #include <asm/stacktrace.h>
  
 -static char *exception_stack_names[N_EXCEPTION_STACKS] = {
 -		[ DOUBLEFAULT_STACK-1	]	= "#DF",
 -		[ NMI_STACK-1		]	= "NMI",
 -		[ DEBUG_STACK-1		]	= "#DB",
 -		[ MCE_STACK-1		]	= "#MC",
 -};
  
 -static unsigned long exception_stack_sizes[N_EXCEPTION_STACKS] = {
 -	[0 ... N_EXCEPTION_STACKS - 1]		= EXCEPTION_STKSZ,
 -	[DEBUG_STACK - 1]			= DEBUG_STKSZ
 +#define N_EXCEPTION_STACKS_END \
 +		(N_EXCEPTION_STACKS + DEBUG_STKSZ/EXCEPTION_STKSZ - 2)
 +
 +static char x86_stack_ids[][8] = {
 +		[ DEBUG_STACK-1			]	= "#DB",
 +		[ NMI_STACK-1			]	= "NMI",
 +		[ DOUBLEFAULT_STACK-1		]	= "#DF",
 +		[ MCE_STACK-1			]	= "#MC",
 +#if DEBUG_STKSZ > EXCEPTION_STKSZ
 +		[ N_EXCEPTION_STACKS ...
 +		  N_EXCEPTION_STACKS_END	]	= "#DB[?]"
 +#endif
  };
  
 -void stack_type_str(enum stack_type type, const char **begin, const char **end)
 +static unsigned long *in_exception_stack(unsigned cpu, unsigned long stack,
 +					 unsigned *usedp, char **idp)
  {
 -	BUILD_BUG_ON(N_EXCEPTION_STACKS != 4);
 -
 -	switch (type) {
 -	case STACK_TYPE_IRQ:
 -		*begin = "IRQ";
 -		*end   = "EOI";
 -		break;
 -	case STACK_TYPE_EXCEPTION ... STACK_TYPE_EXCEPTION_LAST:
 -		*begin = exception_stack_names[type - STACK_TYPE_EXCEPTION];
 -		*end   = "EOE";
 -		break;
 -	default:
 -		*begin = NULL;
 -		*end   = NULL;
 +	unsigned k;
 +
 +	/*
 +	 * Iterate over all exception stacks, and figure out whether
 +	 * 'stack' is in one of them:
 +	 */
 +	for (k = 0; k < N_EXCEPTION_STACKS; k++) {
 +		unsigned long end = per_cpu(orig_ist, cpu).ist[k];
 +		/*
 +		 * Is 'stack' above this exception frame's end?
 +		 * If yes then skip to the next frame.
 +		 */
 +		if (stack >= end)
 +			continue;
 +		/*
 +		 * Is 'stack' above this exception frame's start address?
 +		 * If yes then we found the right frame.
 +		 */
 +		if (stack >= end - EXCEPTION_STKSZ) {
 +			/*
 +			 * Make sure we only iterate through an exception
 +			 * stack once. If it comes up for the second time
 +			 * then there's something wrong going on - just
 +			 * break out and return NULL:
 +			 */
 +			if (*usedp & (1U << k))
 +				break;
 +			*usedp |= 1U << k;
 +			*idp = x86_stack_ids[k];
 +			return (unsigned long *)end;
 +		}
 +		/*
 +		 * If this is a debug stack, and if it has a larger size than
 +		 * the usual exception stacks, then 'stack' might still
 +		 * be within the lower portion of the debug stack:
 +		 */
 +#if DEBUG_STKSZ > EXCEPTION_STKSZ
 +		if (k == DEBUG_STACK - 1 && stack >= end - DEBUG_STKSZ) {
 +			unsigned j = N_EXCEPTION_STACKS - 1;
 +
 +			/*
 +			 * Black magic. A large debug stack is composed of
 +			 * multiple exception stack entries, which we
 +			 * iterate through now. Dont look:
 +			 */
 +			do {
 +				++j;
 +				end -= EXCEPTION_STKSZ;
 +				x86_stack_ids[j][4] = '1' +
 +						(j - N_EXCEPTION_STACKS);
 +			} while (stack < end - EXCEPTION_STKSZ);
 +			if (*usedp & (1U << j))
 +				break;
 +			*usedp |= 1U << j;
 +			*idp = x86_stack_ids[j];
 +			return (unsigned long *)end;
 +		}
 +#endif
  	}
 +	return NULL;
  }
  
 -static bool in_exception_stack(unsigned long *stack, struct stack_info *info)
 +static inline int
 +in_irq_stack(unsigned long *stack, unsigned long *irq_stack,
 +	     unsigned long *irq_stack_end)
  {
 -	unsigned long *begin, *end;
 -	struct pt_regs *regs;
 -	unsigned k;
 +	return (stack >= irq_stack && stack < irq_stack_end);
 +}
  
 -	BUILD_BUG_ON(N_EXCEPTION_STACKS != 4);
 +enum stack_type {
 +	STACK_IS_UNKNOWN,
 +	STACK_IS_NORMAL,
 +	STACK_IS_EXCEPTION,
 +	STACK_IS_IRQ,
 +};
  
 -	for (k = 0; k < N_EXCEPTION_STACKS; k++) {
 -		end   = (unsigned long *)raw_cpu_ptr(&orig_ist)->ist[k];
 -		begin = end - (exception_stack_sizes[k] / sizeof(long));
 -		regs  = (struct pt_regs *)end - 1;
 +static enum stack_type
 +analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
 +	      unsigned long **stack_end, unsigned long *irq_stack,
 +	      unsigned *used, char **id)
 +{
 +	unsigned long addr;
  
 -		if (stack < begin || stack >= end)
 -			continue;
 +	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
 +	if ((unsigned long)task_stack_page(task) == addr)
 +		return STACK_IS_NORMAL;
  
 -		info->type	= STACK_TYPE_EXCEPTION + k;
 -		info->begin	= begin;
 -		info->end	= end;
 -		info->next_sp	= (unsigned long *)regs->sp;
 +	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
 +					used, id);
 +	if (*stack_end)
 +		return STACK_IS_EXCEPTION;
  
 -		return true;
 -	}
 +	if (!irq_stack)
 +		return STACK_IS_NORMAL;
 +
 +	*stack_end = irq_stack;
 +	irq_stack -= (IRQ_STACK_SIZE / sizeof(long));
  
 -	return false;
 +	if (in_irq_stack(stack, irq_stack, *stack_end))
 +		return STACK_IS_IRQ;
 +
 +	return STACK_IS_UNKNOWN;
  }
  
 -static bool in_irq_stack(unsigned long *stack, struct stack_info *info)
 +/*
 + * x86-64 can have up to three kernel stacks:
 + * process stack
 + * interrupt stack
 + * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
 + */
 +
 +void dump_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data)
  {
 -	unsigned long *end   = (unsigned long *)this_cpu_read(irq_stack_ptr);
 -	unsigned long *begin = end - (IRQ_STACK_SIZE / sizeof(long));
 +	const unsigned cpu = get_cpu();
 +	struct thread_info *tinfo;
 +	unsigned long *irq_stack = (unsigned long *)per_cpu(irq_stack_ptr, cpu);
 +	unsigned long dummy;
 +	unsigned used = 0;
 +	int graph = 0;
 +	int done = 0;
 +
 +	if (!task)
 +		task = current;
 +
 +	if (!stack) {
 +		if (regs)
 +			stack = (unsigned long *)regs->sp;
 +		else if (task != current)
 +			stack = (unsigned long *)task->thread.sp;
 +		else
 +			stack = &dummy;
 +	}
  
 +	if (!bp)
 +		bp = stack_frame(task, regs);
  	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 +	 * Print function call entries in all stacks, starting at the
 +	 * current stack address. If the stacks consist of nested
 +	 * exceptions
  	 */
 -	if (stack < begin || stack > end)
 -		return false;
 +	tinfo = task_thread_info(task);
 +	while (!done) {
 +		unsigned long *stack_end;
 +		enum stack_type stype;
 +		char *id;
  
 -	info->type	= STACK_TYPE_IRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 +		stype = analyze_stack(cpu, task, stack, &stack_end,
 +				      irq_stack, &used, &id);
  
 -	/*
 -	 * The next stack pointer is the first thing pushed by the entry code
 -	 * after switching to the irq stack.
 -	 */
 -	info->next_sp = (unsigned long *)*(end - 1);
 +		/* Default finish unless specified to continue */
 +		done = 1;
  
 -	return true;
 -}
 +		switch (stype) {
  
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask)
 -{
 -	if (!stack)
 -		goto unknown;
 +		/* Break out early if we are on the thread stack */
 +		case STACK_IS_NORMAL:
 +			break;
  
 -	task = task ? : current;
 +		case STACK_IS_EXCEPTION:
  
 -	if (in_task_stack(stack, task, info))
 -		goto recursion_check;
 +			if (ops->stack(data, id) < 0)
 +				break;
  
 -	if (task != current)
 -		goto unknown;
 +			bp = ops->walk_stack(tinfo, stack, bp, ops,
 +					     data, stack_end, &graph);
 +			ops->stack(data, "EOE");
 +			/*
 +			 * We link to the next stack via the
 +			 * second-to-last pointer (index -2 to end) in the
 +			 * exception stack:
 +			 */
 +			stack = (unsigned long *) stack_end[-2];
 +			done = 0;
 +			break;
 +
 +		case STACK_IS_IRQ:
 +
 +			if (ops->stack(data, "IRQ") < 0)
 +				break;
 +			bp = ops->walk_stack(tinfo, stack, bp,
 +				     ops, data, stack_end, &graph);
 +			/*
 +			 * We link to the next stack (which would be
 +			 * the process stack normally) the last
 +			 * pointer (index -1 to end) in the IRQ stack:
 +			 */
 +			stack = (unsigned long *) (stack_end[-1]);
 +			irq_stack = NULL;
 +			ops->stack(data, "EOI");
 +			done = 0;
 +			break;
 +
 +		case STACK_IS_UNKNOWN:
 +			ops->stack(data, "UNK");
 +			break;
 +		}
 +	}
  
 -	if (in_exception_stack(stack, info))
 -		goto recursion_check;
 +	/*
 +	 * This handles the process stack:
 +	 */
 +	bp = ops->walk_stack(tinfo, stack, bp, ops, data, NULL, &graph);
 +	put_cpu();
 +}
 +EXPORT_SYMBOL(dump_trace);
 +
++<<<<<<< HEAD
 +void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl)
 +{
 +	unsigned long *irq_stack_end;
 +	unsigned long *irq_stack;
 +	unsigned long *stack;
 +	int cpu;
 +	int i;
  
 -	if (in_irq_stack(stack, info))
 -		goto recursion_check;
 +	preempt_disable();
 +	cpu = smp_processor_id();
  
 -	goto unknown;
 +	irq_stack_end = (unsigned long *)(per_cpu(irq_stack_ptr, cpu));
 +	irq_stack     = irq_stack_end - (IRQ_STACK_SIZE / sizeof(long));
  
 -recursion_check:
  	/*
 -	 * Make sure we don't iterate through any given stack more than once.
 -	 * If it comes up a second time then there's something wrong going on:
 -	 * just break out and report an unknown stack type.
 +	 * Debugging aid: "show_stack(NULL, NULL);" prints the
 +	 * back trace for this cpu:
  	 */
 -	if (visit_mask) {
 -		if (*visit_mask & (1UL << info->type))
 -			goto unknown;
 -		*visit_mask |= 1UL << info->type;
 +	if (sp == NULL) {
 +		if (regs)
 +			sp = (unsigned long *)regs->sp;
 +		else if (task)
 +			sp = (unsigned long *)task->thread.sp;
 +		else
 +			sp = (unsigned long *)&sp;
  	}
  
 -	return 0;
 +	stack = sp;
 +	for (i = 0; i < kstack_depth_to_print; i++) {
 +		if (stack >= irq_stack && stack <= irq_stack_end) {
 +			if (stack == irq_stack_end) {
 +				stack = (unsigned long *) (irq_stack_end[-1]);
 +				pr_cont(" <EOI> ");
 +			}
 +		} else {
 +		if (((long) stack & (THREAD_SIZE-1)) == 0)
 +			break;
 +		}
 +		if ((i % STACKSLOTS_PER_LINE) == 0) {
 +			if (i != 0)
 +				pr_cont("\n");
 +			printk("%s %016lx", log_lvl, *stack++);
 +		} else
 +			pr_cont(" %016lx", *stack++);
 +		touch_nmi_watchdog();
 +	}
 +	preempt_enable();
  
 -unknown:
 -	info->type = STACK_TYPE_UNKNOWN;
 -	return -EINVAL;
 +	pr_cont("\n");
 +	show_trace_log_lvl(task, regs, sp, bp, log_lvl);
  }
  
++=======
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  void show_regs(struct pt_regs *regs)
  {
  	int i;
@@@ -315,9 -157,7 +318,13 @@@
  		unsigned char c;
  		u8 *ip;
  
++<<<<<<< HEAD
 +		printk(KERN_DEFAULT "Stack:\n");
 +		show_stack_log_lvl(NULL, regs, (unsigned long *)sp,
 +				   0, KERN_DEFAULT);
++=======
+ 		show_trace_log_lvl(current, regs, NULL, KERN_DEFAULT);
++>>>>>>> 0ee1dd9f5e7e (x86/dumpstack: Remove raw stack dump)
  
  		printk(KERN_DEFAULT "Code: ");
  
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 1d9178db9795..26d3cebfc961 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1492,9 +1492,6 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			Valid arguments: on, off
 			Default: on
 
-	kstack=N	[X86] Print N words from the kernel stack
-			in oops dumps.
-
 	kvm.ignore_msrs=[KVM] Ignore guest accesses to unhandled MSRs.
 			Default is 0 (don't ignore, but inject #GP)
 
diff --git a/Documentation/sysctl/kernel.txt b/Documentation/sysctl/kernel.txt
index 50713c8133e8..db01b36e03d4 100644
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@ -40,7 +40,6 @@ show up in /proc/sys/kernel:
 - hung_task_timeout_secs
 - hung_task_warnings
 - kptr_restrict
-- kstack_depth_to_print       [ X86 only ]
 - l2cr                        [ PPC only ]
 - modprobe                    ==> Documentation/debugging-modules.txt
 - modules_disabled
@@ -388,13 +387,6 @@ When kptr_restrict is set to (2), kernel pointers printed using
 
 ==============================================================
 
-kstack_depth_to_print: (X86 only)
-
-Controls the number of words to print when dumping the raw
-kernel stack.
-
-==============================================================
-
 l2cr: (PPC only)
 
 This flag controls the L2 cache of G3 processor boards. If
* Unmerged path Documentation/x86/x86_64/boot-options.txt
* Unmerged path arch/x86/include/asm/stacktrace.h
* Unmerged path arch/x86/kernel/dumpstack.c
* Unmerged path arch/x86/kernel/dumpstack_32.c
* Unmerged path arch/x86/kernel/dumpstack_64.c
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 61f4051791d8..7ef2e6a773cb 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -977,13 +977,6 @@ static struct ctl_table kern_table[] = {
 		.mode		= 0444,
 		.proc_handler	= proc_dointvec,
 	},
-	{
-		.procname	= "kstack_depth_to_print",
-		.data		= &kstack_depth_to_print,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec,
-	},
 	{
 		.procname	= "io_delay_type",
 		.data		= &io_delay_type,
