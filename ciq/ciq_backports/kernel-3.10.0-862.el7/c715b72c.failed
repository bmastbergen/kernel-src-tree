mm: revert x86_64 and arm64 ELF_ET_DYN_BASE base changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kees Cook <keescook@chromium.org>
commit c715b72c1ba406f133217b509044c38d8e714a37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c715b72c.failed

Moving the x86_64 and arm64 PIE base from 0x555555554000 to 0x000100000000
broke AddressSanitizer.  This is a partial revert of:

  eab09532d400 ("binfmt_elf: use ELF_ET_DYN_BASE only for PIE")
  02445990a96e ("arm64: move ELF_ET_DYN_BASE to 4GB / 4MB")

The AddressSanitizer tool has hard-coded expectations about where
executable mappings are loaded.

The motivation for changing the PIE base in the above commits was to
avoid the Stack-Clash CVEs that allowed executable mappings to get too
close to heap and stack.  This was mainly a problem on 32-bit, but the
64-bit bases were moved too, in an effort to proactively protect those
systems (proofs of concept do exist that show 64-bit collisions, but
other recent changes to fix stack accounting and setuid behaviors will
minimize the impact).

The new 32-bit PIE base is fine for ASan (since it matches the ET_EXEC
base), so only the 64-bit PIE base needs to be reverted to let x86 and
arm64 ASan binaries run again.  Future changes to the 64-bit PIE base on
these architectures can be made optional once a more dynamic method for
dealing with AddressSanitizer is found.  (e.g.  always loading PIE into
the mmap region for marked binaries.)

Link: http://lkml.kernel.org/r/20170807201542.GA21271@beast
Fixes: eab09532d400 ("binfmt_elf: use ELF_ET_DYN_BASE only for PIE")
Fixes: 02445990a96e ("arm64: move ELF_ET_DYN_BASE to 4GB / 4MB")
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Reported-by: Kostya Serebryany <kcc@google.com>
	Acked-by: Will Deacon <will.deacon@arm.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c715b72c1ba406f133217b509044c38d8e714a37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/elf.h
diff --cc arch/arm64/include/asm/elf.h
index fe32c0e4ac01,3288c2b36731..000000000000
--- a/arch/arm64/include/asm/elf.h
+++ b/arch/arm64/include/asm/elf.h
@@@ -109,13 -113,22 +109,32 @@@ typedef struct user_fpsimd_state elf_fp
  #define ELF_EXEC_PAGESIZE	PAGE_SIZE
  
  /*
++<<<<<<< HEAD
 + * This is the location that an ET_DYN program is loaded if exec'ed.  Typical
 + * use of this is to invoke "./ld.so someprog" to test out a new version of
 + * the loader.  We need to make sure that it is out of the way of the program
 + * that it will "exec", and that there is sufficient room for the brk.
 + */
 +extern unsigned long randomize_et_dyn(unsigned long base);
 +#define ELF_ET_DYN_BASE	(randomize_et_dyn(2 * TASK_SIZE_64 / 3))
++=======
+  * This is the base location for PIE (ET_DYN with INTERP) loads. On
+  * 64-bit, this is above 4GB to leave the entire 32-bit address
+  * space open for things that want to use the area for 32-bit pointers.
+  */
+ #define ELF_ET_DYN_BASE		(2 * TASK_SIZE_64 / 3)
+ 
+ #ifndef __ASSEMBLY__
+ 
+ typedef unsigned long elf_greg_t;
+ 
+ #define ELF_NGREG (sizeof(struct user_pt_regs) / sizeof(elf_greg_t))
+ #define ELF_CORE_COPY_REGS(dest, regs)	\
+ 	*(struct user_pt_regs *)&(dest) = (regs)->user_regs;
+ 
+ typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+ typedef struct user_fpsimd_state elf_fpregset_t;
++>>>>>>> c715b72c1ba4 (mm: revert x86_64 and arm64 ELF_ET_DYN_BASE base changes)
  
  /*
   * When the program starts, a1 contains a pointer to a function to be
* Unmerged path arch/arm64/include/asm/elf.h
diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h
index 1e0dcf23e1bf..189e5f5dd406 100644
--- a/arch/x86/include/asm/elf.h
+++ b/arch/x86/include/asm/elf.h
@@ -240,11 +240,11 @@ extern int force_personality32;
 
 /*
  * This is the base location for PIE (ET_DYN with INTERP) loads. On
- * 64-bit, this is raised to 4GB to leave the entire 32-bit address
+ * 64-bit, this is above 4GB to leave the entire 32-bit address
  * space open for things that want to use the area for 32-bit pointers.
  */
 #define ELF_ET_DYN_BASE		(mmap_is_ia32() ? 0x000400000UL : \
-						  0x100000000UL)
+						  (TASK_SIZE / 3 * 2))
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
