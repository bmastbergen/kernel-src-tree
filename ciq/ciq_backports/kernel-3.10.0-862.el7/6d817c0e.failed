ASoC: codecs: Add da7219 codec driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: asoc: codecs: Add da7219 codec driver (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 92.50%
commit-author Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
commit 6d817c0e9fd7536be76690bfdee88e8a81c16f7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6d817c0e.failed

This adds support for the DA7219 audio codec with built-in advanced
accessory detect features.

	Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 6d817c0e9fd7536be76690bfdee88e8a81c16f7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/Kconfig
#	sound/soc/codecs/Makefile
diff --cc sound/soc/codecs/Kconfig
index bec1671f0a76,c9a895cc4eff..000000000000
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@@ -13,11 -13,82 +13,61 @@@ menu "CODEC drivers
  config SND_SOC_ALL_CODECS
  	tristate "Build all ASoC CODEC drivers"
  	depends on COMPILE_TEST
++<<<<<<< HEAD
++=======
+ 	select SND_SOC_88PM860X if MFD_88PM860X
+ 	select SND_SOC_L3
+ 	select SND_SOC_AB8500_CODEC if ABX500_CORE
+ 	select SND_SOC_AC97_CODEC
+ 	select SND_SOC_AD1836 if SPI_MASTER
+ 	select SND_SOC_AD193X_SPI if SPI_MASTER
+ 	select SND_SOC_AD193X_I2C if I2C
+ 	select SND_SOC_AD1980 if SND_SOC_AC97_BUS
+ 	select SND_SOC_AD73311
+ 	select SND_SOC_ADAU1373 if I2C
+ 	select SND_SOC_ADAU1761_I2C if I2C
+ 	select SND_SOC_ADAU1761_SPI if SPI
+ 	select SND_SOC_ADAU1781_I2C if I2C
+ 	select SND_SOC_ADAU1781_SPI if SPI
+ 	select SND_SOC_ADAV801 if SPI_MASTER
+ 	select SND_SOC_ADAV803 if I2C
+ 	select SND_SOC_ADAU1977_SPI if SPI_MASTER
+ 	select SND_SOC_ADAU1977_I2C if I2C
+ 	select SND_SOC_ADAU1701 if I2C
+ 	select SND_SOC_ADS117X
+ 	select SND_SOC_AK4104 if SPI_MASTER
+ 	select SND_SOC_AK4535 if I2C
+ 	select SND_SOC_AK4554
+ 	select SND_SOC_AK4641 if I2C
+ 	select SND_SOC_AK4642 if I2C
+ 	select SND_SOC_AK4671 if I2C
+ 	select SND_SOC_AK5386
+ 	select SND_SOC_ALC5623 if I2C
+ 	select SND_SOC_ALC5632 if I2C
+ 	select SND_SOC_CQ0093VC if MFD_DAVINCI_VOICECODEC
+ 	select SND_SOC_CS35L32 if I2C
+ 	select SND_SOC_CS42L51_I2C if I2C
+ 	select SND_SOC_CS42L52 if I2C && INPUT
+ 	select SND_SOC_CS42L56 if I2C && INPUT
+ 	select SND_SOC_CS42L73 if I2C
+ 	select SND_SOC_CS4265 if I2C
+ 	select SND_SOC_CS4270 if I2C
+ 	select SND_SOC_CS4271_I2C if I2C
+ 	select SND_SOC_CS4271_SPI if SPI_MASTER
+ 	select SND_SOC_CS42XX8_I2C if I2C
+ 	select SND_SOC_CS4349 if I2C
+ 	select SND_SOC_CX20442 if TTY
+ 	select SND_SOC_DA7210 if SND_SOC_I2C_AND_SPI
+ 	select SND_SOC_DA7213 if I2C
+ 	select SND_SOC_DA7219 if I2C
+ 	select SND_SOC_DA732X if I2C
+ 	select SND_SOC_DA9055 if I2C
++>>>>>>> 6d817c0e9fd7 (ASoC: codecs: Add da7219 codec driver)
  	select SND_SOC_DMIC
 -	select SND_SOC_BT_SCO
 -	select SND_SOC_ES8328_SPI if SPI_MASTER
 -	select SND_SOC_ES8328_I2C if I2C
 -	select SND_SOC_GTM601
 -	select SND_SOC_ICS43432
 -	select SND_SOC_ISABELLE if I2C
 -	select SND_SOC_JZ4740_CODEC
 -	select SND_SOC_LM4857 if I2C
 -	select SND_SOC_LM49453 if I2C
 -	select SND_SOC_MAX98088 if I2C
 +	select SND_SOC_HDAC_HDMI
  	select SND_SOC_MAX98090 if I2C
 -	select SND_SOC_MAX98095 if I2C
  	select SND_SOC_MAX98357A if GPIOLIB
 -	select SND_SOC_MAX98925 if I2C
 -	select SND_SOC_MAX9850 if I2C
 -	select SND_SOC_MAX9768 if I2C
 -	select SND_SOC_MAX9877 if I2C
 -	select SND_SOC_MC13783 if MFD_MC13XXX
 -	select SND_SOC_ML26124 if I2C
 -	select SND_SOC_HDMI_CODEC
 -	select SND_SOC_PCM1681 if I2C
 -	select SND_SOC_PCM1792A if SPI_MASTER
 -	select SND_SOC_PCM3008
 -	select SND_SOC_PCM512x_I2C if I2C
 -	select SND_SOC_PCM512x_SPI if SPI_MASTER
 -	select SND_SOC_RT286 if I2C
 -	select SND_SOC_RT298 if I2C
 -	select SND_SOC_RT5631 if I2C
 +	select SND_SOC_NAU8825 if I2C
  	select SND_SOC_RT5640 if I2C
  	select SND_SOC_RT5645 if I2C
  	select SND_SOC_RT5651 if I2C
@@@ -36,6 -188,261 +86,264 @@@
  
            If unsure select "N".
  
++<<<<<<< HEAD
++=======
+ config SND_SOC_88PM860X
+ 	tristate
+ 
+ config SND_SOC_ARIZONA
+ 	tristate
+ 	default y if SND_SOC_WM5102=y
+ 	default y if SND_SOC_WM5110=y
+ 	default y if SND_SOC_WM8997=y
+ 	default m if SND_SOC_WM5102=m
+ 	default m if SND_SOC_WM5110=m
+ 	default m if SND_SOC_WM8997=m
+ 
+ config SND_SOC_WM_HUBS
+ 	tristate
+ 	default y if SND_SOC_WM8993=y || SND_SOC_WM8994=y
+ 	default m if SND_SOC_WM8993=m || SND_SOC_WM8994=m
+ 
+ config SND_SOC_WM_ADSP
+ 	tristate
+ 	default y if SND_SOC_WM5102=y
+ 	default y if SND_SOC_WM5110=y
+ 	default y if SND_SOC_WM2200=y
+ 	default m if SND_SOC_WM5102=m
+ 	default m if SND_SOC_WM5110=m
+ 	default m if SND_SOC_WM2200=m
+ 
+ config SND_SOC_AB8500_CODEC
+ 	tristate
+ 
+ config SND_SOC_AC97_CODEC
+ 	tristate "Build generic ASoC AC97 CODEC driver"
+ 	select SND_AC97_CODEC
+ 	select SND_SOC_AC97_BUS
+ 
+ config SND_SOC_AD1836
+ 	tristate
+ 
+ config SND_SOC_AD193X
+ 	tristate
+ 
+ config SND_SOC_AD193X_SPI
+ 	tristate
+ 	select SND_SOC_AD193X
+ 
+ config SND_SOC_AD193X_I2C
+ 	tristate
+ 	select SND_SOC_AD193X
+ 
+ config SND_SOC_AD1980
+ 	select REGMAP_AC97
+ 	tristate
+ 
+ config SND_SOC_AD73311
+ 	tristate
+ 
+ config SND_SOC_ADAU1373
+ 	tristate
+ 
+ config SND_SOC_ADAU1701
+ 	tristate "Analog Devices ADAU1701 CODEC"
+ 	depends on I2C
+ 	select SND_SOC_SIGMADSP_I2C
+ 
+ config SND_SOC_ADAU17X1
+ 	tristate
+ 	select SND_SOC_SIGMADSP_REGMAP
+ 
+ config SND_SOC_ADAU1761
+ 	tristate
+ 	select SND_SOC_ADAU17X1
+ 
+ config SND_SOC_ADAU1761_I2C
+ 	tristate
+ 	select SND_SOC_ADAU1761
+ 	select REGMAP_I2C
+ 
+ config SND_SOC_ADAU1761_SPI
+ 	tristate
+ 	select SND_SOC_ADAU1761
+ 	select REGMAP_SPI
+ 
+ config SND_SOC_ADAU1781
+ 	select SND_SOC_ADAU17X1
+ 	tristate
+ 
+ config SND_SOC_ADAU1781_I2C
+ 	tristate
+ 	select SND_SOC_ADAU1781
+ 	select REGMAP_I2C
+ 
+ config SND_SOC_ADAU1781_SPI
+ 	tristate
+ 	select SND_SOC_ADAU1781
+ 	select REGMAP_SPI
+ 
+ config SND_SOC_ADAU1977
+ 	tristate
+ 
+ config SND_SOC_ADAU1977_SPI
+ 	tristate
+ 	select SND_SOC_ADAU1977
+ 	select REGMAP_SPI
+ 
+ config SND_SOC_ADAU1977_I2C
+ 	tristate
+ 	select SND_SOC_ADAU1977
+ 	select REGMAP_I2C
+ 
+ config SND_SOC_ADAV80X
+ 	tristate
+ 
+ config SND_SOC_ADAV801
+ 	tristate
+ 	select SND_SOC_ADAV80X
+ 
+ config SND_SOC_ADAV803
+ 	tristate
+ 	select SND_SOC_ADAV80X
+ 
+ config SND_SOC_ADS117X
+ 	tristate
+ 
+ config SND_SOC_AK4104
+ 	tristate "AKM AK4104 CODEC"
+ 	depends on SPI_MASTER
+ 
+ config SND_SOC_AK4535
+ 	tristate
+ 
+ config SND_SOC_AK4554
+ 	tristate "AKM AK4554 CODEC"
+ 
+ config SND_SOC_AK4641
+ 	tristate
+ 
+ config SND_SOC_AK4642
+ 	tristate "AKM AK4642 CODEC"
+ 	depends on I2C
+ 
+ config SND_SOC_AK4671
+ 	tristate
+ 
+ config SND_SOC_AK5386
+ 	tristate "AKM AK5638 CODEC"
+ 
+ config SND_SOC_ALC5623
+        tristate "Realtek ALC5623 CODEC"
+ 	depends on I2C
+ 
+ config SND_SOC_ALC5632
+ 	tristate
+ 
+ config SND_SOC_CQ0093VC
+ 	tristate
+ 
+ config SND_SOC_CS35L32
+ 	tristate "Cirrus Logic CS35L32 CODEC"
+ 	depends on I2C
+ 
+ config SND_SOC_CS42L51
+ 	tristate
+ 
+ config SND_SOC_CS42L51_I2C
+ 	tristate "Cirrus Logic CS42L51 CODEC (I2C)"
+ 	depends on I2C
+ 	select SND_SOC_CS42L51
+ 
+ config SND_SOC_CS42L52
+ 	tristate "Cirrus Logic CS42L52 CODEC"
+ 	depends on I2C && INPUT
+ 
+ config SND_SOC_CS42L56
+ 	tristate "Cirrus Logic CS42L56 CODEC"
+ 	depends on I2C && INPUT
+ 
+ config SND_SOC_CS42L73
+ 	tristate "Cirrus Logic CS42L73 CODEC"
+ 	depends on I2C
+ 
+ config SND_SOC_CS4265
+ 	tristate "Cirrus Logic CS4265 CODEC"
+ 	depends on I2C
+ 	select REGMAP_I2C
+ 
+ # Cirrus Logic CS4270 Codec
+ config SND_SOC_CS4270
+ 	tristate "Cirrus Logic CS4270 CODEC"
+ 	depends on I2C
+ 
+ # Cirrus Logic CS4270 Codec VD = 3.3V Errata
+ # Select if you are affected by the errata where the part will not function
+ # if MCLK divide-by-1.5 is selected and VD is set to 3.3V.  The driver will
+ # not select any sample rates that require MCLK to be divided by 1.5.
+ config SND_SOC_CS4270_VD33_ERRATA
+ 	bool
+ 	depends on SND_SOC_CS4270
+ 
+ config SND_SOC_CS4271
+ 	tristate
+ 
+ config SND_SOC_CS4271_I2C
+ 	tristate "Cirrus Logic CS4271 CODEC (I2C)"
+ 	depends on I2C
+ 	select SND_SOC_CS4271
+ 	select REGMAP_I2C
+ 
+ config SND_SOC_CS4271_SPI
+ 	tristate "Cirrus Logic CS4271 CODEC (SPI)"
+ 	depends on SPI_MASTER
+ 	select SND_SOC_CS4271
+ 	select REGMAP_SPI
+ 
+ config SND_SOC_CS42XX8
+ 	tristate
+ 
+ config SND_SOC_CS42XX8_I2C
+ 	tristate "Cirrus Logic CS42448/CS42888 CODEC (I2C)"
+ 	depends on I2C
+ 	select SND_SOC_CS42XX8
+ 	select REGMAP_I2C
+ 
+ # Cirrus Logic CS4349 HiFi DAC
+ config SND_SOC_CS4349
+ 	tristate "Cirrus Logic CS4349 CODEC"
+ 	depends on I2C
+ 
+ config SND_SOC_CX20442
+ 	tristate
+ 	depends on TTY
+ 
+ config SND_SOC_JZ4740_CODEC
+ 	select REGMAP_MMIO
+ 	tristate
+ 
+ config SND_SOC_L3
+        tristate
+ 
+ config SND_SOC_DA7210
+         tristate
+ 
+ config SND_SOC_DA7213
+         tristate
+ 
+ config SND_SOC_DA7219
+         tristate
+ 
+ config SND_SOC_DA732X
+         tristate
+ 
+ config SND_SOC_DA9055
+ 	tristate
+ 
+ config SND_SOC_BT_SCO
+ 	tristate
+ 
++>>>>>>> 6d817c0e9fd7 (ASoC: codecs: Add da7219 codec driver)
  config SND_SOC_DMIC
  	tristate
  
diff --cc sound/soc/codecs/Makefile
index 1f16972a45d6,eb10a34d5e13..000000000000
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@@ -1,7 -1,85 +1,65 @@@
++<<<<<<< HEAD
++=======
+ snd-soc-88pm860x-objs := 88pm860x-codec.o
+ snd-soc-ab8500-codec-objs := ab8500-codec.o
+ snd-soc-ac97-objs := ac97.o
+ snd-soc-ad1836-objs := ad1836.o
+ snd-soc-ad193x-objs := ad193x.o
+ snd-soc-ad193x-spi-objs := ad193x-spi.o
+ snd-soc-ad193x-i2c-objs := ad193x-i2c.o
+ snd-soc-ad1980-objs := ad1980.o
+ snd-soc-ad73311-objs := ad73311.o
+ snd-soc-adau1373-objs := adau1373.o
+ snd-soc-adau1701-objs := adau1701.o
+ snd-soc-adau17x1-objs := adau17x1.o
+ snd-soc-adau1761-objs := adau1761.o
+ snd-soc-adau1761-i2c-objs := adau1761-i2c.o
+ snd-soc-adau1761-spi-objs := adau1761-spi.o
+ snd-soc-adau1781-objs := adau1781.o
+ snd-soc-adau1781-i2c-objs := adau1781-i2c.o
+ snd-soc-adau1781-spi-objs := adau1781-spi.o
+ snd-soc-adau1977-objs := adau1977.o
+ snd-soc-adau1977-spi-objs := adau1977-spi.o
+ snd-soc-adau1977-i2c-objs := adau1977-i2c.o
+ snd-soc-adav80x-objs := adav80x.o
+ snd-soc-adav801-objs := adav801.o
+ snd-soc-adav803-objs := adav803.o
+ snd-soc-ads117x-objs := ads117x.o
+ snd-soc-ak4104-objs := ak4104.o
+ snd-soc-ak4535-objs := ak4535.o
+ snd-soc-ak4554-objs := ak4554.o
+ snd-soc-ak4641-objs := ak4641.o
+ snd-soc-ak4642-objs := ak4642.o
+ snd-soc-ak4671-objs := ak4671.o
+ snd-soc-ak5386-objs := ak5386.o
+ snd-soc-arizona-objs := arizona.o
+ snd-soc-cq93vc-objs := cq93vc.o
+ snd-soc-cs35l32-objs := cs35l32.o
+ snd-soc-cs42l51-objs := cs42l51.o
+ snd-soc-cs42l51-i2c-objs := cs42l51-i2c.o
+ snd-soc-cs42l52-objs := cs42l52.o
+ snd-soc-cs42l56-objs := cs42l56.o
+ snd-soc-cs42l73-objs := cs42l73.o
+ snd-soc-cs4265-objs := cs4265.o
+ snd-soc-cs4270-objs := cs4270.o
+ snd-soc-cs4271-objs := cs4271.o
+ snd-soc-cs4271-i2c-objs := cs4271-i2c.o
+ snd-soc-cs4271-spi-objs := cs4271-spi.o
+ snd-soc-cs42xx8-objs := cs42xx8.o
+ snd-soc-cs42xx8-i2c-objs := cs42xx8-i2c.o
+ snd-soc-cs4349-objs := cs4349.o
+ snd-soc-cx20442-objs := cx20442.o
+ snd-soc-da7210-objs := da7210.o
+ snd-soc-da7213-objs := da7213.o
+ snd-soc-da7219-objs := da7219.o da7219-aad.o
+ snd-soc-da732x-objs := da732x.o
+ snd-soc-da9055-objs := da9055.o
+ snd-soc-bt-sco-objs := bt-sco.o
++>>>>>>> 6d817c0e9fd7 (ASoC: codecs: Add da7219 codec driver)
  snd-soc-dmic-objs := dmic.o
 -snd-soc-es8328-objs := es8328.o
 -snd-soc-es8328-i2c-objs := es8328-i2c.o
 -snd-soc-es8328-spi-objs := es8328-spi.o
 -snd-soc-gtm601-objs := gtm601.o
 -snd-soc-ics43432-objs := ics43432.o
 -snd-soc-isabelle-objs := isabelle.o
 -snd-soc-jz4740-codec-objs := jz4740.o
 -snd-soc-l3-objs := l3.o
 -snd-soc-lm4857-objs := lm4857.o
 -snd-soc-lm49453-objs := lm49453.o
 -snd-soc-max9768-objs := max9768.o
 -snd-soc-max98088-objs := max98088.o
 +snd-soc-hdac-hdmi-objs := hdac_hdmi.o
  snd-soc-max98090-objs := max98090.o
 -snd-soc-max98095-objs := max98095.o
 -snd-soc-max98357a-objs := max98357a.o
 -snd-soc-max98925-objs := max98925.o
 -snd-soc-max9850-objs := max9850.o
 -snd-soc-mc13783-objs := mc13783.o
 -snd-soc-ml26124-objs := ml26124.o
 -snd-soc-hdmi-codec-objs := hdmi.o
 -snd-soc-pcm1681-objs := pcm1681.o
 -snd-soc-pcm1792a-codec-objs := pcm1792a.o
 -snd-soc-pcm3008-objs := pcm3008.o
 -snd-soc-pcm512x-objs := pcm512x.o
 -snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 -snd-soc-pcm512x-spi-objs := pcm512x-spi.o
 +snd-soc-nau8825-objs := nau8825.o
  snd-soc-rl6231-objs := rl6231.o
  snd-soc-rl6347a-objs := rl6347a.o
  snd-soc-rt286-objs := rt286.o
@@@ -9,15 -89,190 +67,80 @@@ snd-soc-rt5640-objs := rt5640.
  snd-soc-rt5645-objs := rt5645.o
  snd-soc-rt5651-objs := rt5651.o
  snd-soc-rt5670-objs := rt5670.o
 -snd-soc-rt5677-objs := rt5677.o
 -snd-soc-rt5677-spi-objs := rt5677-spi.o
 -snd-soc-sgtl5000-objs := sgtl5000.o
 -snd-soc-alc5623-objs := alc5623.o
 -snd-soc-alc5632-objs := alc5632.o
 -snd-soc-sigmadsp-objs := sigmadsp.o
 -snd-soc-sigmadsp-i2c-objs := sigmadsp-i2c.o
 -snd-soc-sigmadsp-regmap-objs := sigmadsp-regmap.o
 -snd-soc-si476x-objs := si476x.o
 -snd-soc-sirf-audio-codec-objs := sirf-audio-codec.o
  snd-soc-sn95031-objs := sn95031.o
 -snd-soc-spdif-tx-objs := spdif_transmitter.o
 -snd-soc-spdif-rx-objs := spdif_receiver.o
  snd-soc-ssm2518-objs := ssm2518.o
 -snd-soc-ssm2602-objs := ssm2602.o
 -snd-soc-ssm2602-spi-objs := ssm2602-spi.o
 -snd-soc-ssm2602-i2c-objs := ssm2602-i2c.o
  snd-soc-ssm4567-objs := ssm4567.o
 -snd-soc-sta32x-objs := sta32x.o
 -snd-soc-sta350-objs := sta350.o
 -snd-soc-sta529-objs := sta529.o
 -snd-soc-stac9766-objs := stac9766.o
 -snd-soc-sti-sas-objs := sti-sas.o
 -snd-soc-tas5086-objs := tas5086.o
 -snd-soc-tas571x-objs := tas571x.o
 -snd-soc-tfa9879-objs := tfa9879.o
 -snd-soc-tlv320aic23-objs := tlv320aic23.o
 -snd-soc-tlv320aic23-i2c-objs := tlv320aic23-i2c.o
 -snd-soc-tlv320aic23-spi-objs := tlv320aic23-spi.o
 -snd-soc-tlv320aic26-objs := tlv320aic26.o
 -snd-soc-tlv320aic31xx-objs := tlv320aic31xx.o
 -snd-soc-tlv320aic32x4-objs := tlv320aic32x4.o
 -snd-soc-tlv320aic3x-objs := tlv320aic3x.o
 -snd-soc-tlv320dac33-objs := tlv320dac33.o
  snd-soc-ts3a227e-objs := ts3a227e.o
 -snd-soc-twl4030-objs := twl4030.o
 -snd-soc-twl6040-objs := twl6040.o
 -snd-soc-uda134x-objs := uda134x.o
 -snd-soc-uda1380-objs := uda1380.o
 -snd-soc-wl1273-objs := wl1273.o
 -snd-soc-wm-adsp-objs := wm_adsp.o
 -snd-soc-wm0010-objs := wm0010.o
 -snd-soc-wm1250-ev1-objs := wm1250-ev1.o
 -snd-soc-wm2000-objs := wm2000.o
 -snd-soc-wm2200-objs := wm2200.o
 -snd-soc-wm5100-objs := wm5100.o wm5100-tables.o
 -snd-soc-wm5102-objs := wm5102.o
 -snd-soc-wm5110-objs := wm5110.o
 -snd-soc-wm8350-objs := wm8350.o
 -snd-soc-wm8400-objs := wm8400.o
 -snd-soc-wm8510-objs := wm8510.o
 -snd-soc-wm8523-objs := wm8523.o
 -snd-soc-wm8580-objs := wm8580.o
 -snd-soc-wm8711-objs := wm8711.o
 -snd-soc-wm8727-objs := wm8727.o
 -snd-soc-wm8728-objs := wm8728.o
 -snd-soc-wm8731-objs := wm8731.o
 -snd-soc-wm8737-objs := wm8737.o
 -snd-soc-wm8741-objs := wm8741.o
 -snd-soc-wm8750-objs := wm8750.o
 -snd-soc-wm8753-objs := wm8753.o
 -snd-soc-wm8770-objs := wm8770.o
 -snd-soc-wm8776-objs := wm8776.o
 -snd-soc-wm8782-objs := wm8782.o
 -snd-soc-wm8804-objs := wm8804.o
 -snd-soc-wm8804-i2c-objs := wm8804-i2c.o
 -snd-soc-wm8804-spi-objs := wm8804-spi.o
 -snd-soc-wm8900-objs := wm8900.o
 -snd-soc-wm8903-objs := wm8903.o
 -snd-soc-wm8904-objs := wm8904.o
 -snd-soc-wm8996-objs := wm8996.o
 -snd-soc-wm8940-objs := wm8940.o
 -snd-soc-wm8955-objs := wm8955.o
 -snd-soc-wm8960-objs := wm8960.o
 -snd-soc-wm8961-objs := wm8961.o
 -snd-soc-wm8962-objs := wm8962.o
 -snd-soc-wm8971-objs := wm8971.o
 -snd-soc-wm8974-objs := wm8974.o
 -snd-soc-wm8978-objs := wm8978.o
 -snd-soc-wm8983-objs := wm8983.o
 -snd-soc-wm8985-objs := wm8985.o
 -snd-soc-wm8988-objs := wm8988.o
 -snd-soc-wm8990-objs := wm8990.o
 -snd-soc-wm8991-objs := wm8991.o
 -snd-soc-wm8993-objs := wm8993.o
 -snd-soc-wm8994-objs := wm8994.o wm8958-dsp2.o
 -snd-soc-wm8995-objs := wm8995.o
 -snd-soc-wm8997-objs := wm8997.o
 -snd-soc-wm9081-objs := wm9081.o
 -snd-soc-wm9090-objs := wm9090.o
 -snd-soc-wm9705-objs := wm9705.o
 -snd-soc-wm9712-objs := wm9712.o
 -snd-soc-wm9713-objs := wm9713.o
 -snd-soc-wm-hubs-objs := wm_hubs.o
  
++<<<<<<< HEAD
++=======
+ # Amp
+ snd-soc-max9877-objs := max9877.o
+ snd-soc-tpa6130a2-objs := tpa6130a2.o
+ snd-soc-tas2552-objs := tas2552.o
+ 
+ obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
+ obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
+ obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
+ obj-$(CONFIG_SND_SOC_AD1836)	+= snd-soc-ad1836.o
+ obj-$(CONFIG_SND_SOC_AD193X)	+= snd-soc-ad193x.o
+ obj-$(CONFIG_SND_SOC_AD193X_SPI)	+= snd-soc-ad193x-spi.o
+ obj-$(CONFIG_SND_SOC_AD193X_I2C)	+= snd-soc-ad193x-i2c.o
+ obj-$(CONFIG_SND_SOC_AD1980)	+= snd-soc-ad1980.o
+ obj-$(CONFIG_SND_SOC_AD73311) += snd-soc-ad73311.o
+ obj-$(CONFIG_SND_SOC_ADAU1373)	+= snd-soc-adau1373.o
+ obj-$(CONFIG_SND_SOC_ADAU1701)		+= snd-soc-adau1701.o
+ obj-$(CONFIG_SND_SOC_ADAU17X1)		+= snd-soc-adau17x1.o
+ obj-$(CONFIG_SND_SOC_ADAU1761)		+= snd-soc-adau1761.o
+ obj-$(CONFIG_SND_SOC_ADAU1761_I2C)	+= snd-soc-adau1761-i2c.o
+ obj-$(CONFIG_SND_SOC_ADAU1761_SPI)	+= snd-soc-adau1761-spi.o
+ obj-$(CONFIG_SND_SOC_ADAU1781)		+= snd-soc-adau1781.o
+ obj-$(CONFIG_SND_SOC_ADAU1781_I2C)	+= snd-soc-adau1781-i2c.o
+ obj-$(CONFIG_SND_SOC_ADAU1781_SPI)	+= snd-soc-adau1781-spi.o
+ obj-$(CONFIG_SND_SOC_ADAU1977)		+= snd-soc-adau1977.o
+ obj-$(CONFIG_SND_SOC_ADAU1977_SPI)	+= snd-soc-adau1977-spi.o
+ obj-$(CONFIG_SND_SOC_ADAU1977_I2C)	+= snd-soc-adau1977-i2c.o
+ obj-$(CONFIG_SND_SOC_ADAV80X)  += snd-soc-adav80x.o
+ obj-$(CONFIG_SND_SOC_ADAV801)  += snd-soc-adav801.o
+ obj-$(CONFIG_SND_SOC_ADAV803)  += snd-soc-adav803.o
+ obj-$(CONFIG_SND_SOC_ADS117X)	+= snd-soc-ads117x.o
+ obj-$(CONFIG_SND_SOC_AK4104)	+= snd-soc-ak4104.o
+ obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
+ obj-$(CONFIG_SND_SOC_AK4554)	+= snd-soc-ak4554.o
+ obj-$(CONFIG_SND_SOC_AK4641)	+= snd-soc-ak4641.o
+ obj-$(CONFIG_SND_SOC_AK4642)	+= snd-soc-ak4642.o
+ obj-$(CONFIG_SND_SOC_AK4671)	+= snd-soc-ak4671.o
+ obj-$(CONFIG_SND_SOC_AK5386)	+= snd-soc-ak5386.o
+ obj-$(CONFIG_SND_SOC_ALC5623)    += snd-soc-alc5623.o
+ obj-$(CONFIG_SND_SOC_ALC5632)	+= snd-soc-alc5632.o
+ obj-$(CONFIG_SND_SOC_ARIZONA)	+= snd-soc-arizona.o
+ obj-$(CONFIG_SND_SOC_CQ0093VC) += snd-soc-cq93vc.o
+ obj-$(CONFIG_SND_SOC_CS35L32)	+= snd-soc-cs35l32.o
+ obj-$(CONFIG_SND_SOC_CS42L51)	+= snd-soc-cs42l51.o
+ obj-$(CONFIG_SND_SOC_CS42L51_I2C)	+= snd-soc-cs42l51-i2c.o
+ obj-$(CONFIG_SND_SOC_CS42L52)	+= snd-soc-cs42l52.o
+ obj-$(CONFIG_SND_SOC_CS42L56)	+= snd-soc-cs42l56.o
+ obj-$(CONFIG_SND_SOC_CS42L73)	+= snd-soc-cs42l73.o
+ obj-$(CONFIG_SND_SOC_CS4265)	+= snd-soc-cs4265.o
+ obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
+ obj-$(CONFIG_SND_SOC_CS4271)	+= snd-soc-cs4271.o
+ obj-$(CONFIG_SND_SOC_CS4271_I2C)	+= snd-soc-cs4271-i2c.o
+ obj-$(CONFIG_SND_SOC_CS4271_SPI)	+= snd-soc-cs4271-spi.o
+ obj-$(CONFIG_SND_SOC_CS42XX8)	+= snd-soc-cs42xx8.o
+ obj-$(CONFIG_SND_SOC_CS42XX8_I2C) += snd-soc-cs42xx8-i2c.o
+ obj-$(CONFIG_SND_SOC_CS4349)	+= snd-soc-cs4349.o
+ obj-$(CONFIG_SND_SOC_CX20442)	+= snd-soc-cx20442.o
+ obj-$(CONFIG_SND_SOC_DA7210)	+= snd-soc-da7210.o
+ obj-$(CONFIG_SND_SOC_DA7213)	+= snd-soc-da7213.o
+ obj-$(CONFIG_SND_SOC_DA7219)	+= snd-soc-da7219.o
+ obj-$(CONFIG_SND_SOC_DA732X)	+= snd-soc-da732x.o
+ obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
+ obj-$(CONFIG_SND_SOC_BT_SCO)	+= snd-soc-bt-sco.o
++>>>>>>> 6d817c0e9fd7 (ASoC: codecs: Add da7219 codec driver)
  obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
 -obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
 -obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 -obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
 -obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
 -obj-$(CONFIG_SND_SOC_ICS43432)	+= snd-soc-ics43432.o
 -obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
 -obj-$(CONFIG_SND_SOC_JZ4740_CODEC)	+= snd-soc-jz4740-codec.o
 -obj-$(CONFIG_SND_SOC_L3)	+= snd-soc-l3.o
 -obj-$(CONFIG_SND_SOC_LM4857)	+= snd-soc-lm4857.o
 -obj-$(CONFIG_SND_SOC_LM49453)   += snd-soc-lm49453.o
 -obj-$(CONFIG_SND_SOC_MAX9768)	+= snd-soc-max9768.o
 -obj-$(CONFIG_SND_SOC_MAX98088)	+= snd-soc-max98088.o
 +obj-$(CONFIG_SND_SOC_HDAC_HDMI) += snd-soc-hdac-hdmi.o
  obj-$(CONFIG_SND_SOC_MAX98090)	+= snd-soc-max98090.o
 -obj-$(CONFIG_SND_SOC_MAX98095)	+= snd-soc-max98095.o
 -obj-$(CONFIG_SND_SOC_MAX98357A)	+= snd-soc-max98357a.o
 -obj-$(CONFIG_SND_SOC_MAX98925)	+= snd-soc-max98925.o
 -obj-$(CONFIG_SND_SOC_MAX9850)	+= snd-soc-max9850.o
 -obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc-mc13783.o
 -obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 -obj-$(CONFIG_SND_SOC_HDMI_CODEC) += snd-soc-hdmi-codec.o
 -obj-$(CONFIG_SND_SOC_PCM1681)	+= snd-soc-pcm1681.o
 -obj-$(CONFIG_SND_SOC_PCM1792A)	+= snd-soc-pcm1792a-codec.o
 -obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
 -obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 -obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 -obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
 +obj-$(CONFIG_SND_SOC_NAU8825)   += snd-soc-nau8825.o
  obj-$(CONFIG_SND_SOC_RL6231)	+= snd-soc-rl6231.o
  obj-$(CONFIG_SND_SOC_RL6347A)	+= snd-soc-rl6347a.o
  obj-$(CONFIG_SND_SOC_RT286)	+= snd-soc-rt286.o
diff --git a/include/sound/da7219-aad.h b/include/sound/da7219-aad.h
new file mode 100644
index 000000000000..17802fb86ec4
--- /dev/null
+++ b/include/sound/da7219-aad.h
@@ -0,0 +1,99 @@
+/*
+ * da7219-aad.h - DA7322 ASoC Codec AAD Driver Platform Data
+ *
+ * Copyright (c) 2015 Dialog Semiconductor Ltd.
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __DA7219_AAD_PDATA_H
+#define __DA7219_AAD_PDATA_H
+
+enum da7219_aad_micbias_pulse_lvl {
+	DA7219_AAD_MICBIAS_PULSE_LVL_OFF = 0,
+	DA7219_AAD_MICBIAS_PULSE_LVL_2_8V = 6,
+	DA7219_AAD_MICBIAS_PULSE_LVL_2_9V,
+};
+
+enum da7219_aad_btn_cfg {
+	DA7219_AAD_BTN_CFG_2MS = 1,
+	DA7219_AAD_BTN_CFG_5MS,
+	DA7219_AAD_BTN_CFG_10MS,
+	DA7219_AAD_BTN_CFG_50MS,
+	DA7219_AAD_BTN_CFG_100MS,
+	DA7219_AAD_BTN_CFG_200MS,
+	DA7219_AAD_BTN_CFG_500MS,
+};
+
+enum da7219_aad_mic_det_thr {
+	DA7219_AAD_MIC_DET_THR_200_OHMS = 0,
+	DA7219_AAD_MIC_DET_THR_500_OHMS,
+	DA7219_AAD_MIC_DET_THR_750_OHMS,
+	DA7219_AAD_MIC_DET_THR_1000_OHMS,
+};
+
+enum da7219_aad_jack_ins_deb {
+	DA7219_AAD_JACK_INS_DEB_5MS = 0,
+	DA7219_AAD_JACK_INS_DEB_10MS,
+	DA7219_AAD_JACK_INS_DEB_20MS,
+	DA7219_AAD_JACK_INS_DEB_50MS,
+	DA7219_AAD_JACK_INS_DEB_100MS,
+	DA7219_AAD_JACK_INS_DEB_200MS,
+	DA7219_AAD_JACK_INS_DEB_500MS,
+	DA7219_AAD_JACK_INS_DEB_1S,
+};
+
+enum da7219_aad_jack_det_rate {
+	DA7219_AAD_JACK_DET_RATE_32_64MS = 0,
+	DA7219_AAD_JACK_DET_RATE_64_128MS,
+	DA7219_AAD_JACK_DET_RATE_128_256MS,
+	DA7219_AAD_JACK_DET_RATE_256_512MS,
+};
+
+enum da7219_aad_jack_rem_deb {
+	DA7219_AAD_JACK_REM_DEB_1MS = 0,
+	DA7219_AAD_JACK_REM_DEB_5MS,
+	DA7219_AAD_JACK_REM_DEB_10MS,
+	DA7219_AAD_JACK_REM_DEB_20MS,
+};
+
+enum da7219_aad_btn_avg {
+	DA7219_AAD_BTN_AVG_1 = 0,
+	DA7219_AAD_BTN_AVG_2,
+	DA7219_AAD_BTN_AVG_4,
+	DA7219_AAD_BTN_AVG_8,
+};
+
+enum da7219_aad_adc_1bit_rpt {
+	DA7219_AAD_ADC_1BIT_RPT_1 = 0,
+	DA7219_AAD_ADC_1BIT_RPT_2,
+	DA7219_AAD_ADC_1BIT_RPT_4,
+	DA7219_AAD_ADC_1BIT_RPT_8,
+};
+
+struct da7219_aad_pdata {
+	int irq;
+
+	enum da7219_aad_micbias_pulse_lvl micbias_pulse_lvl;
+	u32 micbias_pulse_time;
+	enum da7219_aad_btn_cfg btn_cfg;
+	enum da7219_aad_mic_det_thr mic_det_thr;
+	enum da7219_aad_jack_ins_deb jack_ins_deb;
+	enum da7219_aad_jack_det_rate jack_det_rate;
+	enum da7219_aad_jack_rem_deb jack_rem_deb;
+
+	u8 a_d_btn_thr;
+	u8 d_b_btn_thr;
+	u8 b_c_btn_thr;
+	u8 c_mic_btn_thr;
+
+	enum da7219_aad_btn_avg btn_avg;
+	enum da7219_aad_adc_1bit_rpt adc_1bit_rpt;
+};
+
+#endif /* __DA7219_AAD_PDATA_H */
diff --git a/include/sound/da7219.h b/include/sound/da7219.h
new file mode 100644
index 000000000000..3f39e135312d
--- /dev/null
+++ b/include/sound/da7219.h
@@ -0,0 +1,55 @@
+/*
+ * da7219.h - DA7219 ASoC Codec Driver Platform Data
+ *
+ * Copyright (c) 2015 Dialog Semiconductor
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __DA7219_PDATA_H
+#define __DA7219_PDATA_H
+
+/* LDO */
+enum da7219_ldo_lvl_sel {
+	DA7219_LDO_LVL_SEL_1_05V = 0,
+	DA7219_LDO_LVL_SEL_1_10V,
+	DA7219_LDO_LVL_SEL_1_20V,
+	DA7219_LDO_LVL_SEL_1_40V,
+};
+
+/* Mic Bias */
+enum da7219_micbias_voltage {
+	DA7219_MICBIAS_1_8V = 1,
+	DA7219_MICBIAS_2_0V,
+	DA7219_MICBIAS_2_2V,
+	DA7219_MICBIAS_2_4V,
+	DA7219_MICBIAS_2_6V,
+};
+
+/* Mic input type */
+enum da7219_mic_amp_in_sel {
+	DA7219_MIC_AMP_IN_SEL_DIFF = 0,
+	DA7219_MIC_AMP_IN_SEL_SE_P,
+	DA7219_MIC_AMP_IN_SEL_SE_N,
+};
+
+struct da7219_aad_pdata;
+
+struct da7219_pdata {
+	/* Internal LDO */
+	enum da7219_ldo_lvl_sel ldo_lvl_sel;
+
+	/* Mic */
+	enum da7219_micbias_voltage micbias_lvl;
+	enum da7219_mic_amp_in_sel mic_amp_in_sel;
+
+	/* AAD */
+	struct da7219_aad_pdata *aad_pdata;
+};
+
+#endif /* __DA7219_PDATA_H */
* Unmerged path sound/soc/codecs/Kconfig
* Unmerged path sound/soc/codecs/Makefile
diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
new file mode 100644
index 000000000000..9459593eef13
--- /dev/null
+++ b/sound/soc/codecs/da7219-aad.c
@@ -0,0 +1,823 @@
+/*
+ * da7219-aad.c - Dialog DA7219 ALSA SoC AAD Driver
+ *
+ * Copyright (c) 2015 Dialog Semiconductor Ltd.
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/da7219.h>
+
+#include "da7219.h"
+#include "da7219-aad.h"
+
+
+/*
+ * Detection control
+ */
+
+void da7219_aad_jack_det(struct snd_soc_codec *codec, struct snd_soc_jack *jack)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	da7219->aad->jack = jack;
+	da7219->aad->jack_inserted = false;
+
+	/* Send an initial empty report */
+	snd_soc_jack_report(jack, 0, DA7219_AAD_REPORT_ALL_MASK);
+
+	/* Enable/Disable jack detection */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			    DA7219_ACCDET_EN_MASK,
+			    (jack ? DA7219_ACCDET_EN_MASK : 0));
+}
+EXPORT_SYMBOL_GPL(da7219_aad_jack_det);
+
+/*
+ * Button/HPTest work
+ */
+
+static void da7219_aad_btn_det_work(struct work_struct *work)
+{
+	struct da7219_aad_priv *da7219_aad =
+		container_of(work, struct da7219_aad_priv, btn_det_work);
+	struct snd_soc_codec *codec = da7219_aad->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	u8 statusa, micbias_ctrl;
+	bool micbias_up = false;
+	int retries = 0;
+
+	/* Drive headphones/lineout */
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+			    DA7219_HP_L_AMP_OE_MASK,
+			    DA7219_HP_L_AMP_OE_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+			    DA7219_HP_R_AMP_OE_MASK,
+			    DA7219_HP_R_AMP_OE_MASK);
+
+	/* Make sure mic bias is up */
+	snd_soc_dapm_force_enable_pin(dapm, "Mic Bias");
+	snd_soc_dapm_sync(dapm);
+
+	do {
+		statusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);
+		if (statusa & DA7219_MICBIAS_UP_STS_MASK)
+			micbias_up = true;
+		else if (retries++ < DA7219_AAD_MICBIAS_CHK_RETRIES)
+			msleep(DA7219_AAD_MICBIAS_CHK_DELAY);
+	} while ((!micbias_up) && (retries < DA7219_AAD_MICBIAS_CHK_RETRIES));
+
+	if (retries >= DA7219_AAD_MICBIAS_CHK_RETRIES)
+		dev_warn(codec->dev, "Mic bias status check timed out");
+
+	/*
+	 * Mic bias pulse required to enable mic, must be done before enabling
+	 * button detection to prevent erroneous button readings.
+	 */
+	if (da7219_aad->micbias_pulse_lvl && da7219_aad->micbias_pulse_time) {
+		/* Pulse higher level voltage */
+		micbias_ctrl = snd_soc_read(codec, DA7219_MICBIAS_CTRL);
+		snd_soc_update_bits(codec, DA7219_MICBIAS_CTRL,
+				    DA7219_MICBIAS1_LEVEL_MASK,
+				    da7219_aad->micbias_pulse_lvl);
+		msleep(da7219_aad->micbias_pulse_time);
+		snd_soc_write(codec, DA7219_MICBIAS_CTRL, micbias_ctrl);
+
+	}
+
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			    DA7219_BUTTON_CONFIG_MASK,
+			    da7219_aad->btn_cfg);
+}
+
+static void da7219_aad_hptest_work(struct work_struct *work)
+{
+	struct da7219_aad_priv *da7219_aad =
+		container_of(work, struct da7219_aad_priv, hptest_work);
+	struct snd_soc_codec *codec = da7219_aad->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	u16 tonegen_freq_hptest;
+	u8 accdet_cfg8;
+	int report = 0;
+
+	/* Lock DAPM and any Kcontrols that are affected by this test */
+	snd_soc_dapm_mutex_lock(dapm);
+	mutex_lock(&da7219->lock);
+
+	/* Bypass cache so it saves current settings */
+	regcache_cache_bypass(da7219->regmap, true);
+
+	/* Make sure Tone Generator is disabled */
+	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, 0);
+
+	/* Enable HPTest block, 1KOhms check */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
+			    DA7219_HPTEST_EN_MASK | DA7219_HPTEST_RES_SEL_MASK,
+			    DA7219_HPTEST_EN_MASK |
+			    DA7219_HPTEST_RES_SEL_1KOHMS);
+
+	/* Set gains to 0db */
+	snd_soc_write(codec, DA7219_DAC_L_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
+	snd_soc_write(codec, DA7219_DAC_R_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
+	snd_soc_write(codec, DA7219_HP_L_GAIN, DA7219_HP_AMP_GAIN_0DB);
+	snd_soc_write(codec, DA7219_HP_R_GAIN, DA7219_HP_AMP_GAIN_0DB);
+
+	/* Disable DAC filters, EQs and soft mute */
+	snd_soc_update_bits(codec, DA7219_DAC_FILTERS1, DA7219_HPF_MODE_MASK,
+			    0);
+	snd_soc_update_bits(codec, DA7219_DAC_FILTERS4, DA7219_DAC_EQ_EN_MASK,
+			    0);
+	snd_soc_update_bits(codec, DA7219_DAC_FILTERS5,
+			    DA7219_DAC_SOFTMUTE_EN_MASK, 0);
+
+	/* Enable HP left & right paths */
+	snd_soc_update_bits(codec, DA7219_CP_CTRL, DA7219_CP_EN_MASK,
+			    DA7219_CP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_DIG_ROUTING_DAC,
+			    DA7219_DAC_L_SRC_MASK | DA7219_DAC_R_SRC_MASK,
+			    DA7219_DAC_L_SRC_TONEGEN |
+			    DA7219_DAC_R_SRC_TONEGEN);
+	snd_soc_update_bits(codec, DA7219_DAC_L_CTRL,
+			    DA7219_DAC_L_EN_MASK | DA7219_DAC_L_MUTE_EN_MASK,
+			    DA7219_DAC_L_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_DAC_R_CTRL,
+			    DA7219_DAC_R_EN_MASK | DA7219_DAC_R_MUTE_EN_MASK,
+			    DA7219_DAC_R_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_L_SELECT,
+			    DA7219_MIXOUT_L_MIX_SELECT_MASK,
+			    DA7219_MIXOUT_L_MIX_SELECT_MASK);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_R_SELECT,
+			    DA7219_MIXOUT_R_MIX_SELECT_MASK,
+			    DA7219_MIXOUT_R_MIX_SELECT_MASK);
+	snd_soc_update_bits(codec, DA7219_DROUTING_ST_OUTFILT_1L,
+			    DA7219_OUTFILT_ST_1L_SRC_MASK,
+			    DA7219_DMIX_ST_SRC_OUTFILT1L);
+	snd_soc_update_bits(codec, DA7219_DROUTING_ST_OUTFILT_1R,
+			    DA7219_OUTFILT_ST_1R_SRC_MASK,
+			    DA7219_DMIX_ST_SRC_OUTFILT1R);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_L_CTRL,
+			    DA7219_MIXOUT_L_AMP_EN_MASK,
+			    DA7219_MIXOUT_L_AMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_R_CTRL,
+			    DA7219_MIXOUT_R_AMP_EN_MASK,
+			    DA7219_MIXOUT_R_AMP_EN_MASK);
+	snd_soc_write(codec, DA7219_HP_L_CTRL,
+		      DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK);
+	snd_soc_write(codec, DA7219_HP_R_CTRL,
+		      DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);
+
+	/* Configure & start Tone Generator */
+	snd_soc_write(codec, DA7219_TONE_GEN_ON_PER, DA7219_BEEP_ON_PER_MASK);
+	tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);
+	regmap_raw_write(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,
+			 &tonegen_freq_hptest, sizeof(tonegen_freq_hptest));
+	snd_soc_update_bits(codec, DA7219_TONE_GEN_CFG2,
+			    DA7219_SWG_SEL_MASK | DA7219_TONE_GEN_GAIN_MASK,
+			    DA7219_SWG_SEL_SRAMP |
+			    DA7219_TONE_GEN_GAIN_MINUS_15DB);
+	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, DA7219_START_STOPN_MASK);
+
+	msleep(DA7219_AAD_HPTEST_PERIOD);
+
+	/* Grab comparator reading */
+	accdet_cfg8 = snd_soc_read(codec, DA7219_ACCDET_CONFIG_8);
+	if (accdet_cfg8 & DA7219_HPTEST_COMP_MASK)
+		report |= SND_JACK_HEADPHONE;
+	else
+		report |= SND_JACK_LINEOUT;
+
+	/* Stop tone generator */
+	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, 0);
+
+	msleep(DA7219_AAD_HPTEST_PERIOD);
+
+	/* Restore original settings from cache */
+	regcache_mark_dirty(da7219->regmap);
+	regcache_sync_region(da7219->regmap, DA7219_HP_L_CTRL,
+			     DA7219_HP_R_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_CTRL,
+			     DA7219_MIXOUT_R_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_DROUTING_ST_OUTFILT_1L,
+			     DA7219_DROUTING_ST_OUTFILT_1R);
+	regcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_SELECT,
+			     DA7219_MIXOUT_R_SELECT);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_L_CTRL,
+			     DA7219_DAC_R_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_DIG_ROUTING_DAC,
+			     DA7219_DIG_ROUTING_DAC);
+	regcache_sync_region(da7219->regmap, DA7219_CP_CTRL, DA7219_CP_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_FILTERS5,
+			     DA7219_DAC_FILTERS5);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_FILTERS4,
+			     DA7219_DAC_FILTERS1);
+	regcache_sync_region(da7219->regmap, DA7219_HP_L_GAIN,
+			     DA7219_HP_R_GAIN);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_L_GAIN,
+			     DA7219_DAC_R_GAIN);
+	regcache_sync_region(da7219->regmap, DA7219_TONE_GEN_ON_PER,
+			     DA7219_TONE_GEN_ON_PER);
+	regcache_sync_region(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,
+			     DA7219_TONE_GEN_FREQ1_U);
+	regcache_sync_region(da7219->regmap, DA7219_TONE_GEN_CFG1,
+			     DA7219_TONE_GEN_CFG2);
+
+	regcache_cache_bypass(da7219->regmap, false);
+
+	/* Disable HPTest block */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
+			    DA7219_HPTEST_EN_MASK, 0);
+
+	/* Drive Headphones/lineout */
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL, DA7219_HP_L_AMP_OE_MASK,
+			    DA7219_HP_L_AMP_OE_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
+			    DA7219_HP_R_AMP_OE_MASK);
+
+	mutex_unlock(&da7219->lock);
+	snd_soc_dapm_mutex_unlock(dapm);
+
+	/*
+	 * Only send report if jack hasn't been removed during process,
+	 * otherwise it's invalid and we drop it.
+	 */
+	if (da7219_aad->jack_inserted)
+		snd_soc_jack_report(da7219_aad->jack, report,
+				    SND_JACK_HEADSET | SND_JACK_LINEOUT);
+}
+
+
+/*
+ * IRQ
+ */
+
+static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
+{
+	struct da7219_aad_priv *da7219_aad = data;
+	struct snd_soc_codec *codec = da7219_aad->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	u8 events[DA7219_AAD_IRQ_REG_MAX];
+	u8 statusa;
+	int i, report = 0, mask = 0;
+
+	/* Read current IRQ events */
+	regmap_bulk_read(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,
+			 events, DA7219_AAD_IRQ_REG_MAX);
+
+	if (!events[DA7219_AAD_IRQ_REG_A] && !events[DA7219_AAD_IRQ_REG_B])
+		return IRQ_NONE;
+
+	/* Read status register for jack insertion & type status */
+	statusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);
+
+	/* Clear events */
+	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,
+			  events, DA7219_AAD_IRQ_REG_MAX);
+
+	dev_dbg(codec->dev, "IRQ events = 0x%x|0x%x, status = 0x%x\n",
+		events[DA7219_AAD_IRQ_REG_A], events[DA7219_AAD_IRQ_REG_B],
+		statusa);
+
+	if (statusa & DA7219_JACK_INSERTION_STS_MASK) {
+		/* Jack Insertion */
+		if (events[DA7219_AAD_IRQ_REG_A] &
+		    DA7219_E_JACK_INSERTED_MASK) {
+			report |= SND_JACK_MECHANICAL;
+			mask |= SND_JACK_MECHANICAL;
+			da7219_aad->jack_inserted = true;
+		}
+
+		/* Jack type detection */
+		if (events[DA7219_AAD_IRQ_REG_A] &
+		    DA7219_E_JACK_DETECT_COMPLETE_MASK) {
+			/*
+			 * If 4-pole, then enable button detection, else perform
+			 * HP impedance test to determine output type to report.
+			 *
+			 * We schedule work here as the tasks themselves can
+			 * take time to complete, and in particular for hptest
+			 * we want to be able to check if the jack was removed
+			 * during the procedure as this will invalidate the
+			 * result. By doing this as work, the IRQ thread can
+			 * handle a removal, and we can check at the end of
+			 * hptest if we have a valid result or not.
+			 */
+			if (statusa & DA7219_JACK_TYPE_STS_MASK) {
+				report |= SND_JACK_HEADSET;
+				mask |=	SND_JACK_HEADSET | SND_JACK_LINEOUT;
+				schedule_work(&da7219_aad->btn_det_work);
+			} else {
+				schedule_work(&da7219_aad->hptest_work);
+			}
+		}
+
+		/* Button support for 4-pole jack */
+		if (statusa & DA7219_JACK_TYPE_STS_MASK) {
+			for (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {
+				/* Button Press */
+				if (events[DA7219_AAD_IRQ_REG_B] &
+				    (DA7219_E_BUTTON_A_PRESSED_MASK << i)) {
+					report |= SND_JACK_BTN_0 >> i;
+					mask |= SND_JACK_BTN_0 >> i;
+				}
+			}
+			snd_soc_jack_report(da7219_aad->jack, report, mask);
+
+			for (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {
+				/* Button Release */
+				if (events[DA7219_AAD_IRQ_REG_B] &
+				    (DA7219_E_BUTTON_A_RELEASED_MASK >> i)) {
+					report &= ~(SND_JACK_BTN_0 >> i);
+					mask |= SND_JACK_BTN_0 >> i;
+				}
+			}
+		}
+	} else {
+		/* Jack removal */
+		if (events[DA7219_AAD_IRQ_REG_A] & DA7219_E_JACK_REMOVED_MASK) {
+			report = 0;
+			mask |= DA7219_AAD_REPORT_ALL_MASK;
+			da7219_aad->jack_inserted = false;
+
+			/* Un-drive headphones/lineout */
+			snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+					    DA7219_HP_R_AMP_OE_MASK, 0);
+			snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+					    DA7219_HP_L_AMP_OE_MASK, 0);
+
+			/* Ensure button detection disabled */
+			snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+					    DA7219_BUTTON_CONFIG_MASK, 0);
+
+			/* Disable mic bias */
+			snd_soc_dapm_disable_pin(dapm, "Mic Bias");
+			snd_soc_dapm_sync(dapm);
+
+			/* Cancel any pending work */
+			cancel_work_sync(&da7219_aad->btn_det_work);
+			cancel_work_sync(&da7219_aad->hptest_work);
+		}
+	}
+
+	snd_soc_jack_report(da7219_aad->jack, report, mask);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * DT to pdata conversion
+ */
+
+static enum da7219_aad_micbias_pulse_lvl
+	da7219_aad_of_micbias_pulse_lvl(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 2800:
+		return DA7219_AAD_MICBIAS_PULSE_LVL_2_8V;
+	case 2900:
+		return DA7219_AAD_MICBIAS_PULSE_LVL_2_9V;
+	default:
+		dev_warn(codec->dev, "Invalid micbias pulse level");
+		return DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
+	}
+}
+
+static enum da7219_aad_btn_cfg
+	da7219_aad_of_btn_cfg(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 2:
+		return DA7219_AAD_BTN_CFG_2MS;
+	case 5:
+		return DA7219_AAD_BTN_CFG_5MS;
+	case 10:
+		return DA7219_AAD_BTN_CFG_10MS;
+	case 50:
+		return DA7219_AAD_BTN_CFG_50MS;
+	case 100:
+		return DA7219_AAD_BTN_CFG_100MS;
+	case 200:
+		return DA7219_AAD_BTN_CFG_200MS;
+	case 500:
+		return DA7219_AAD_BTN_CFG_500MS;
+	default:
+		dev_warn(codec->dev, "Invalid button config");
+		return DA7219_AAD_BTN_CFG_10MS;
+	}
+}
+
+static enum da7219_aad_mic_det_thr
+	da7219_aad_of_mic_det_thr(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 200:
+		return DA7219_AAD_MIC_DET_THR_200_OHMS;
+	case 500:
+		return DA7219_AAD_MIC_DET_THR_500_OHMS;
+	case 750:
+		return DA7219_AAD_MIC_DET_THR_750_OHMS;
+	case 1000:
+		return DA7219_AAD_MIC_DET_THR_1000_OHMS;
+	default:
+		dev_warn(codec->dev, "Invalid mic detect threshold");
+		return DA7219_AAD_MIC_DET_THR_500_OHMS;
+	}
+}
+
+static enum da7219_aad_jack_ins_deb
+	da7219_aad_of_jack_ins_deb(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 5:
+		return DA7219_AAD_JACK_INS_DEB_5MS;
+	case 10:
+		return DA7219_AAD_JACK_INS_DEB_10MS;
+	case 20:
+		return DA7219_AAD_JACK_INS_DEB_20MS;
+	case 50:
+		return DA7219_AAD_JACK_INS_DEB_50MS;
+	case 100:
+		return DA7219_AAD_JACK_INS_DEB_100MS;
+	case 200:
+		return DA7219_AAD_JACK_INS_DEB_200MS;
+	case 500:
+		return DA7219_AAD_JACK_INS_DEB_500MS;
+	case 1000:
+		return DA7219_AAD_JACK_INS_DEB_1S;
+	default:
+		dev_warn(codec->dev, "Invalid jack insert debounce");
+		return DA7219_AAD_JACK_INS_DEB_20MS;
+	}
+}
+
+static enum da7219_aad_jack_det_rate
+	da7219_aad_of_jack_det_rate(struct snd_soc_codec *codec, const char *str)
+{
+	if (!strcmp(str, "32ms_64ms")) {
+		return DA7219_AAD_JACK_DET_RATE_32_64MS;
+	} else if (!strcmp(str, "64ms_128ms")) {
+		return DA7219_AAD_JACK_DET_RATE_64_128MS;
+	} else if (!strcmp(str, "128ms_256ms")) {
+		return DA7219_AAD_JACK_DET_RATE_128_256MS;
+	} else if (!strcmp(str, "256ms_512ms")) {
+		return DA7219_AAD_JACK_DET_RATE_256_512MS;
+	} else {
+		dev_warn(codec->dev, "Invalid jack detect rate");
+		return DA7219_AAD_JACK_DET_RATE_256_512MS;
+	}
+}
+
+static enum da7219_aad_jack_rem_deb
+	da7219_aad_of_jack_rem_deb(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1:
+		return DA7219_AAD_JACK_REM_DEB_1MS;
+	case 5:
+		return DA7219_AAD_JACK_REM_DEB_5MS;
+	case 10:
+		return DA7219_AAD_JACK_REM_DEB_10MS;
+	case 20:
+		return DA7219_AAD_JACK_REM_DEB_20MS;
+	default:
+		dev_warn(codec->dev, "Invalid jack removal debounce");
+		return DA7219_AAD_JACK_REM_DEB_1MS;
+	}
+}
+
+static enum da7219_aad_btn_avg
+	da7219_aad_of_btn_avg(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1:
+		return DA7219_AAD_BTN_AVG_1;
+	case 2:
+		return DA7219_AAD_BTN_AVG_2;
+	case 4:
+		return DA7219_AAD_BTN_AVG_4;
+	case 8:
+		return DA7219_AAD_BTN_AVG_8;
+	default:
+		dev_warn(codec->dev, "Invalid button average value");
+		return DA7219_AAD_BTN_AVG_2;
+	}
+}
+
+static enum da7219_aad_adc_1bit_rpt
+	da7219_aad_of_adc_1bit_rpt(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1:
+		return DA7219_AAD_ADC_1BIT_RPT_1;
+	case 2:
+		return DA7219_AAD_ADC_1BIT_RPT_2;
+	case 4:
+		return DA7219_AAD_ADC_1BIT_RPT_4;
+	case 8:
+		return DA7219_AAD_ADC_1BIT_RPT_8;
+	default:
+		dev_warn(codec->dev, "Invalid ADC 1-bit repeat value");
+		return DA7219_AAD_ADC_1BIT_RPT_1;
+	}
+}
+
+static struct da7219_aad_pdata *da7219_aad_of_to_pdata(struct snd_soc_codec *codec)
+{
+	struct device_node *np = codec->dev->of_node;
+	struct device_node *aad_np = of_find_node_by_name(np, "da7219_aad");
+	struct da7219_aad_pdata *aad_pdata;
+	const char *of_str;
+	u32 of_val32;
+
+	if (!aad_np)
+		return NULL;
+
+	aad_pdata = devm_kzalloc(codec->dev, sizeof(*aad_pdata), GFP_KERNEL);
+	if (!aad_pdata)
+		goto out;
+
+	aad_pdata->irq = irq_of_parse_and_map(np, 0);
+
+	if (of_property_read_u32(aad_np, "dlg,micbias-pulse-lvl",
+				 &of_val32) >= 0)
+		aad_pdata->micbias_pulse_lvl =
+			da7219_aad_of_micbias_pulse_lvl(codec, of_val32);
+	else
+		aad_pdata->micbias_pulse_lvl = DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
+
+	if (of_property_read_u32(aad_np, "dlg,micbias-pulse-time",
+				 &of_val32) >= 0)
+		aad_pdata->micbias_pulse_time = of_val32;
+
+	if (of_property_read_u32(aad_np, "dlg,btn-cfg", &of_val32) >= 0)
+		aad_pdata->btn_cfg = da7219_aad_of_btn_cfg(codec, of_val32);
+	else
+		aad_pdata->btn_cfg = DA7219_AAD_BTN_CFG_10MS;
+
+	if (of_property_read_u32(aad_np, "dlg,mic-det-thr", &of_val32) >= 0)
+		aad_pdata->mic_det_thr =
+			da7219_aad_of_mic_det_thr(codec, of_val32);
+	else
+		aad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_500_OHMS;
+
+	if (of_property_read_u32(aad_np, "dlg,jack-ins-deb", &of_val32) >= 0)
+		aad_pdata->jack_ins_deb =
+			da7219_aad_of_jack_ins_deb(codec, of_val32);
+	else
+		aad_pdata->jack_ins_deb = DA7219_AAD_JACK_INS_DEB_20MS;
+
+	if (!of_property_read_string(aad_np, "dlg,jack-det-rate", &of_str))
+		aad_pdata->jack_det_rate =
+			da7219_aad_of_jack_det_rate(codec, of_str);
+	else
+		aad_pdata->jack_det_rate = DA7219_AAD_JACK_DET_RATE_256_512MS;
+
+	if (of_property_read_u32(aad_np, "dlg,jack-rem-deb", &of_val32) >= 0)
+		aad_pdata->jack_rem_deb =
+			da7219_aad_of_jack_rem_deb(codec, of_val32);
+	else
+		aad_pdata->jack_rem_deb = DA7219_AAD_JACK_REM_DEB_1MS;
+
+	if (of_property_read_u32(aad_np, "dlg,a-d-btn-thr", &of_val32) >= 0)
+		aad_pdata->a_d_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->a_d_btn_thr = 0xA;
+
+	if (of_property_read_u32(aad_np, "dlg,d-b-btn-thr", &of_val32) >= 0)
+		aad_pdata->d_b_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->d_b_btn_thr = 0x16;
+
+	if (of_property_read_u32(aad_np, "dlg,b-c-btn-thr", &of_val32) >= 0)
+		aad_pdata->b_c_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->b_c_btn_thr = 0x21;
+
+	if (of_property_read_u32(aad_np, "dlg,c-mic-btn-thr", &of_val32) >= 0)
+		aad_pdata->c_mic_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->c_mic_btn_thr = 0x3E;
+
+	if (of_property_read_u32(aad_np, "dlg,btn-avg", &of_val32) >= 0)
+		aad_pdata->btn_avg = da7219_aad_of_btn_avg(codec, of_val32);
+	else
+		aad_pdata->btn_avg = DA7219_AAD_BTN_AVG_2;
+
+	if (of_property_read_u32(aad_np, "dlg,adc-1bit-rpt", &of_val32) >= 0)
+		aad_pdata->adc_1bit_rpt =
+			da7219_aad_of_adc_1bit_rpt(codec, of_val32);
+	else
+		aad_pdata->adc_1bit_rpt = DA7219_AAD_ADC_1BIT_RPT_1;
+
+out:
+	of_node_put(aad_np);
+
+	return aad_pdata;
+}
+
+static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad = da7219->aad;
+	struct da7219_pdata *pdata = da7219->pdata;
+
+	if ((pdata) && (pdata->aad_pdata)) {
+		struct da7219_aad_pdata *aad_pdata = pdata->aad_pdata;
+		u8 cfg, mask;
+
+		da7219_aad->irq = aad_pdata->irq;
+
+		switch (aad_pdata->micbias_pulse_lvl) {
+		case DA7219_AAD_MICBIAS_PULSE_LVL_2_8V:
+		case DA7219_AAD_MICBIAS_PULSE_LVL_2_9V:
+			da7219_aad->micbias_pulse_lvl =
+				(aad_pdata->micbias_pulse_lvl <<
+				 DA7219_MICBIAS1_LEVEL_SHIFT);
+			break;
+		default:
+			break;
+		}
+
+		da7219_aad->micbias_pulse_time = aad_pdata->micbias_pulse_time;
+
+		switch (aad_pdata->btn_cfg) {
+		case DA7219_AAD_BTN_CFG_2MS:
+		case DA7219_AAD_BTN_CFG_5MS:
+		case DA7219_AAD_BTN_CFG_10MS:
+		case DA7219_AAD_BTN_CFG_50MS:
+		case DA7219_AAD_BTN_CFG_100MS:
+		case DA7219_AAD_BTN_CFG_200MS:
+		case DA7219_AAD_BTN_CFG_500MS:
+			da7219_aad->btn_cfg  = (aad_pdata->btn_cfg <<
+						DA7219_BUTTON_CONFIG_SHIFT);
+		}
+
+		cfg = 0;
+		mask = 0;
+		switch (aad_pdata->mic_det_thr) {
+		case DA7219_AAD_MIC_DET_THR_200_OHMS:
+		case DA7219_AAD_MIC_DET_THR_500_OHMS:
+		case DA7219_AAD_MIC_DET_THR_750_OHMS:
+		case DA7219_AAD_MIC_DET_THR_1000_OHMS:
+			cfg |= (aad_pdata->mic_det_thr <<
+				DA7219_MIC_DET_THRESH_SHIFT);
+			mask |= DA7219_MIC_DET_THRESH_MASK;
+		}
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1, mask, cfg);
+
+		cfg = 0;
+		mask = 0;
+		switch (aad_pdata->jack_ins_deb) {
+		case DA7219_AAD_JACK_INS_DEB_5MS:
+		case DA7219_AAD_JACK_INS_DEB_10MS:
+		case DA7219_AAD_JACK_INS_DEB_20MS:
+		case DA7219_AAD_JACK_INS_DEB_50MS:
+		case DA7219_AAD_JACK_INS_DEB_100MS:
+		case DA7219_AAD_JACK_INS_DEB_200MS:
+		case DA7219_AAD_JACK_INS_DEB_500MS:
+		case DA7219_AAD_JACK_INS_DEB_1S:
+			cfg |= (aad_pdata->jack_ins_deb <<
+				DA7219_JACKDET_DEBOUNCE_SHIFT);
+			mask |= DA7219_JACKDET_DEBOUNCE_MASK;
+		}
+		switch (aad_pdata->jack_det_rate) {
+		case DA7219_AAD_JACK_DET_RATE_32_64MS:
+		case DA7219_AAD_JACK_DET_RATE_64_128MS:
+		case DA7219_AAD_JACK_DET_RATE_128_256MS:
+		case DA7219_AAD_JACK_DET_RATE_256_512MS:
+			cfg |= (aad_pdata->jack_det_rate <<
+				DA7219_JACK_DETECT_RATE_SHIFT);
+			mask |= DA7219_JACK_DETECT_RATE_MASK;
+		}
+		switch (aad_pdata->jack_rem_deb) {
+		case DA7219_AAD_JACK_REM_DEB_1MS:
+		case DA7219_AAD_JACK_REM_DEB_5MS:
+		case DA7219_AAD_JACK_REM_DEB_10MS:
+		case DA7219_AAD_JACK_REM_DEB_20MS:
+			cfg |= (aad_pdata->jack_rem_deb <<
+				DA7219_JACKDET_REM_DEB_SHIFT);
+			mask |= DA7219_JACKDET_REM_DEB_MASK;
+		}
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_2, mask, cfg);
+
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_3,
+			      aad_pdata->a_d_btn_thr);
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_4,
+			      aad_pdata->d_b_btn_thr);
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_5,
+			      aad_pdata->b_c_btn_thr);
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_6,
+			      aad_pdata->c_mic_btn_thr);
+
+		cfg = 0;
+		mask = 0;
+		switch (aad_pdata->btn_avg) {
+		case DA7219_AAD_BTN_AVG_1:
+		case DA7219_AAD_BTN_AVG_2:
+		case DA7219_AAD_BTN_AVG_4:
+		case DA7219_AAD_BTN_AVG_8:
+			cfg |= (aad_pdata->btn_avg <<
+				DA7219_BUTTON_AVERAGE_SHIFT);
+			mask |= DA7219_BUTTON_AVERAGE_MASK;
+		}
+		switch (aad_pdata->adc_1bit_rpt) {
+		case DA7219_AAD_ADC_1BIT_RPT_1:
+		case DA7219_AAD_ADC_1BIT_RPT_2:
+		case DA7219_AAD_ADC_1BIT_RPT_4:
+		case DA7219_AAD_ADC_1BIT_RPT_8:
+			cfg |= (aad_pdata->adc_1bit_rpt <<
+			       DA7219_ADC_1_BIT_REPEAT_SHIFT);
+			mask |= DA7219_ADC_1_BIT_REPEAT_MASK;
+		}
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_7, mask, cfg);
+	}
+}
+
+
+/*
+ * Init/Exit
+ */
+
+int da7219_aad_init(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad;
+	u8 mask[DA7219_AAD_IRQ_REG_MAX];
+	int ret;
+
+	da7219_aad = devm_kzalloc(codec->dev, sizeof(*da7219_aad), GFP_KERNEL);
+	if (!da7219_aad)
+		return -ENOMEM;
+
+	da7219->aad = da7219_aad;
+	da7219_aad->codec = codec;
+
+	/* Handle any DT/platform data */
+	if ((codec->dev->of_node) && (da7219->pdata))
+		da7219->pdata->aad_pdata = da7219_aad_of_to_pdata(codec);
+
+	da7219_aad_handle_pdata(codec);
+
+	/* Disable button detection */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			    DA7219_BUTTON_CONFIG_MASK, 0);
+
+	INIT_WORK(&da7219_aad->btn_det_work, da7219_aad_btn_det_work);
+	INIT_WORK(&da7219_aad->hptest_work, da7219_aad_hptest_work);
+
+	ret = request_threaded_irq(da7219_aad->irq, NULL,
+				   da7219_aad_irq_thread,
+				   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				   "da7219-aad", da7219_aad);
+	if (ret) {
+		dev_err(codec->dev, "Failed to request IRQ: %d\n", ret);
+		return ret;
+	}
+
+	/* Unmask AAD IRQs */
+	memset(mask, 0, DA7219_AAD_IRQ_REG_MAX);
+	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_MASK_A,
+			  &mask, DA7219_AAD_IRQ_REG_MAX);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(da7219_aad_init);
+
+void da7219_aad_exit(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad = da7219->aad;
+	u8 mask[DA7219_AAD_IRQ_REG_MAX];
+
+	/* Mask off AAD IRQs */
+	memset(mask, DA7219_BYTE_MASK, DA7219_AAD_IRQ_REG_MAX);
+	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_MASK_A,
+			  mask, DA7219_AAD_IRQ_REG_MAX);
+
+	free_irq(da7219_aad->irq, da7219_aad);
+
+	cancel_work_sync(&da7219_aad->btn_det_work);
+	cancel_work_sync(&da7219_aad->hptest_work);
+}
+EXPORT_SYMBOL_GPL(da7219_aad_exit);
+
+MODULE_DESCRIPTION("ASoC DA7219 AAD Driver");
+MODULE_AUTHOR("Adam Thomson <Adam.Thomson.Opensource@diasemi.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/da7219-aad.h b/sound/soc/codecs/da7219-aad.h
new file mode 100644
index 000000000000..4fccf677cd06
--- /dev/null
+++ b/sound/soc/codecs/da7219-aad.h
@@ -0,0 +1,212 @@
+/*
+ * da7219-aad.h - DA7322 ASoC AAD Driver
+ *
+ * Copyright (c) 2015 Dialog Semiconductor Ltd.
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __DA7219_AAD_H
+#define __DA7219_AAD_H
+
+#include <linux/timer.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/da7219-aad.h>
+
+/*
+ * Registers
+ */
+
+#define DA7219_ACCDET_STATUS_A		0xC0
+#define DA7219_ACCDET_STATUS_B		0xC1
+#define DA7219_ACCDET_IRQ_EVENT_A	0xC2
+#define DA7219_ACCDET_IRQ_EVENT_B	0xC3
+#define DA7219_ACCDET_IRQ_MASK_A	0xC4
+#define DA7219_ACCDET_IRQ_MASK_B	0xC5
+#define DA7219_ACCDET_CONFIG_1		0xC6
+#define DA7219_ACCDET_CONFIG_2		0xC7
+#define DA7219_ACCDET_CONFIG_3		0xC8
+#define DA7219_ACCDET_CONFIG_4		0xC9
+#define DA7219_ACCDET_CONFIG_5		0xCA
+#define DA7219_ACCDET_CONFIG_6		0xCB
+#define DA7219_ACCDET_CONFIG_7		0xCC
+#define DA7219_ACCDET_CONFIG_8		0xCD
+
+
+/*
+ * Bit Fields
+ */
+
+/* DA7219_ACCDET_STATUS_A = 0xC0 */
+#define DA7219_JACK_INSERTION_STS_SHIFT	0
+#define DA7219_JACK_INSERTION_STS_MASK	(0x1 << 0)
+#define DA7219_JACK_TYPE_STS_SHIFT	1
+#define DA7219_JACK_TYPE_STS_MASK	(0x1 << 1)
+#define DA7219_JACK_PIN_ORDER_STS_SHIFT	2
+#define DA7219_JACK_PIN_ORDER_STS_MASK	(0x1 << 2)
+#define DA7219_MICBIAS_UP_STS_SHIFT	3
+#define DA7219_MICBIAS_UP_STS_MASK	(0x1 << 3)
+
+/* DA7219_ACCDET_STATUS_B = 0xC1 */
+#define DA7219_BUTTON_TYPE_STS_SHIFT	0
+#define DA7219_BUTTON_TYPE_STS_MASK	(0xFF << 0)
+
+/* DA7219_ACCDET_IRQ_EVENT_A = 0xC2 */
+#define DA7219_E_JACK_INSERTED_SHIFT		0
+#define DA7219_E_JACK_INSERTED_MASK		(0x1 << 0)
+#define DA7219_E_JACK_REMOVED_SHIFT		1
+#define DA7219_E_JACK_REMOVED_MASK		(0x1 << 1)
+#define DA7219_E_JACK_DETECT_COMPLETE_SHIFT	2
+#define DA7219_E_JACK_DETECT_COMPLETE_MASK	(0x1 << 2)
+
+/* DA7219_ACCDET_IRQ_EVENT_B = 0xC3 */
+#define DA7219_E_BUTTON_A_PRESSED_SHIFT		0
+#define DA7219_E_BUTTON_A_PRESSED_MASK		(0x1 << 0)
+#define DA7219_E_BUTTON_B_PRESSED_SHIFT		1
+#define DA7219_E_BUTTON_B_PRESSED_MASK		(0x1 << 1)
+#define DA7219_E_BUTTON_C_PRESSED_SHIFT		2
+#define DA7219_E_BUTTON_C_PRESSED_MASK		(0x1 << 2)
+#define DA7219_E_BUTTON_D_PRESSED_SHIFT		3
+#define DA7219_E_BUTTON_D_PRESSED_MASK		(0x1 << 3)
+#define DA7219_E_BUTTON_D_RELEASED_SHIFT	4
+#define DA7219_E_BUTTON_D_RELEASED_MASK		(0x1 << 4)
+#define DA7219_E_BUTTON_C_RELEASED_SHIFT	5
+#define DA7219_E_BUTTON_C_RELEASED_MASK		(0x1 << 5)
+#define DA7219_E_BUTTON_B_RELEASED_SHIFT	6
+#define DA7219_E_BUTTON_B_RELEASED_MASK		(0x1 << 6)
+#define DA7219_E_BUTTON_A_RELEASED_SHIFT	7
+#define DA7219_E_BUTTON_A_RELEASED_MASK		(0x1 << 7)
+
+/* DA7219_ACCDET_IRQ_MASK_A = 0xC4 */
+#define DA7219_M_JACK_INSERTED_SHIFT		0
+#define DA7219_M_JACK_INSERTED_MASK		(0x1 << 0)
+#define DA7219_M_JACK_REMOVED_SHIFT		1
+#define DA7219_M_JACK_REMOVED_MASK		(0x1 << 1)
+#define DA7219_M_JACK_DETECT_COMPLETE_SHIFT	2
+#define DA7219_M_JACK_DETECT_COMPLETE_MASK	(0x1 << 2)
+
+/* DA7219_ACCDET_IRQ_MASK_B = 0xC5 */
+#define DA7219_M_BUTTON_A_PRESSED_SHIFT		0
+#define DA7219_M_BUTTON_A_PRESSED_MASK		(0x1 << 0)
+#define DA7219_M_BUTTON_B_PRESSED_SHIFT		1
+#define DA7219_M_BUTTON_B_PRESSED_MASK		(0x1 << 1)
+#define DA7219_M_BUTTON_C_PRESSED_SHIFT		2
+#define DA7219_M_BUTTON_C_PRESSED_MASK		(0x1 << 2)
+#define DA7219_M_BUTTON_D_PRESSED_SHIFT		3
+#define DA7219_M_BUTTON_D_PRESSED_MASK		(0x1 << 3)
+#define DA7219_M_BUTTON_D_RELEASED_SHIFT	4
+#define DA7219_M_BUTTON_D_RELEASED_MASK		(0x1 << 4)
+#define DA7219_M_BUTTON_C_RELEASED_SHIFT	5
+#define DA7219_M_BUTTON_C_RELEASED_MASK		(0x1 << 5)
+#define DA7219_M_BUTTON_B_RELEASED_SHIFT	6
+#define DA7219_M_BUTTON_B_RELEASED_MASK		(0x1 << 6)
+#define DA7219_M_BUTTON_A_RELEASED_SHIFT	7
+#define DA7219_M_BUTTON_A_RELEASED_MASK		(0x1 << 7)
+
+/* DA7219_ACCDET_CONFIG_1 = 0xC6 */
+#define DA7219_ACCDET_EN_SHIFT		0
+#define DA7219_ACCDET_EN_MASK		(0x1 << 0)
+#define DA7219_BUTTON_CONFIG_SHIFT	1
+#define DA7219_BUTTON_CONFIG_MASK	(0x7 << 1)
+#define DA7219_MIC_DET_THRESH_SHIFT	4
+#define DA7219_MIC_DET_THRESH_MASK	(0x3 << 4)
+#define DA7219_JACK_TYPE_DET_EN_SHIFT	6
+#define DA7219_JACK_TYPE_DET_EN_MASK	(0x1 << 6)
+#define DA7219_PIN_ORDER_DET_EN_SHIFT	7
+#define DA7219_PIN_ORDER_DET_EN_MASK	(0x1 << 7)
+
+/* DA7219_ACCDET_CONFIG_2 = 0xC7 */
+#define DA7219_ACCDET_PAUSE_SHIFT	0
+#define DA7219_ACCDET_PAUSE_MASK	(0x1 << 0)
+#define DA7219_JACKDET_DEBOUNCE_SHIFT	1
+#define DA7219_JACKDET_DEBOUNCE_MASK	(0x7 << 1)
+#define DA7219_JACK_DETECT_RATE_SHIFT	4
+#define DA7219_JACK_DETECT_RATE_MASK	(0x3 << 4)
+#define DA7219_JACKDET_REM_DEB_SHIFT	6
+#define DA7219_JACKDET_REM_DEB_MASK	(0x3 << 6)
+
+/* DA7219_ACCDET_CONFIG_3 = 0xC8 */
+#define DA7219_A_D_BUTTON_THRESH_SHIFT	0
+#define DA7219_A_D_BUTTON_THRESH_MASK	(0xFF << 0)
+
+/* DA7219_ACCDET_CONFIG_4 = 0xC9 */
+#define DA7219_D_B_BUTTON_THRESH_SHIFT	0
+#define DA7219_D_B_BUTTON_THRESH_MASK	(0xFF << 0)
+
+/* DA7219_ACCDET_CONFIG_5 = 0xCA */
+#define DA7219_B_C_BUTTON_THRESH_SHIFT	0
+#define DA7219_B_C_BUTTON_THRESH_MASK	(0xFF << 0)
+
+/* DA7219_ACCDET_CONFIG_6 = 0xCB */
+#define DA7219_C_MIC_BUTTON_THRESH_SHIFT	0
+#define DA7219_C_MIC_BUTTON_THRESH_MASK		(0xFF << 0)
+
+/* DA7219_ACCDET_CONFIG_7 = 0xCC */
+#define DA7219_BUTTON_AVERAGE_SHIFT	0
+#define DA7219_BUTTON_AVERAGE_MASK	(0x3 << 0)
+#define DA7219_ADC_1_BIT_REPEAT_SHIFT	2
+#define DA7219_ADC_1_BIT_REPEAT_MASK	(0x3 << 2)
+#define DA7219_PIN_ORDER_FORCE_SHIFT	4
+#define DA7219_PIN_ORDER_FORCE_MASK	(0x1 << 4)
+#define DA7219_JACK_TYPE_FORCE_SHIFT	5
+#define DA7219_JACK_TYPE_FORCE_MASK	(0x1 << 5)
+
+/* DA7219_ACCDET_CONFIG_8 = 0xCD */
+#define DA7219_HPTEST_EN_SHIFT		0
+#define DA7219_HPTEST_EN_MASK		(0x1 << 0)
+#define DA7219_HPTEST_RES_SEL_SHIFT	1
+#define DA7219_HPTEST_RES_SEL_MASK	(0x3 << 1)
+#define DA7219_HPTEST_RES_SEL_1KOHMS	(0x0 << 1)
+#define DA7219_HPTEST_COMP_SHIFT	4
+#define DA7219_HPTEST_COMP_MASK		(0x1 << 4)
+
+
+#define DA7219_AAD_MAX_BUTTONS		4
+#define DA7219_AAD_REPORT_ALL_MASK	(SND_JACK_MECHANICAL |			\
+					 SND_JACK_HEADSET | SND_JACK_LINEOUT |	\
+					 SND_JACK_BTN_0 | SND_JACK_BTN_1 |	\
+					 SND_JACK_BTN_2 | SND_JACK_BTN_3)
+
+#define DA7219_AAD_MICBIAS_CHK_DELAY	10
+#define DA7219_AAD_MICBIAS_CHK_RETRIES	5
+
+#define DA7219_AAD_HPTEST_RAMP_FREQ	0x28
+#define DA7219_AAD_HPTEST_PERIOD	65
+
+enum da7219_aad_event_regs {
+	DA7219_AAD_IRQ_REG_A = 0,
+	DA7219_AAD_IRQ_REG_B,
+	DA7219_AAD_IRQ_REG_MAX,
+};
+
+/* Private data */
+struct da7219_aad_priv {
+	struct snd_soc_codec *codec;
+	int irq;
+
+	u8 micbias_pulse_lvl;
+	u32 micbias_pulse_time;
+
+	u8 btn_cfg;
+
+	struct work_struct btn_det_work;
+	struct work_struct hptest_work;
+
+	struct snd_soc_jack *jack;
+	bool jack_inserted;
+};
+
+/* AAD control */
+void da7219_aad_jack_det(struct snd_soc_codec *codec, struct snd_soc_jack *jack);
+
+/* Init/Exit */
+int da7219_aad_init(struct snd_soc_codec *codec);
+void da7219_aad_exit(struct snd_soc_codec *codec);
+
+#endif /* __DA7219_AAD_H */
diff --git a/sound/soc/codecs/da7219.c b/sound/soc/codecs/da7219.c
new file mode 100644
index 000000000000..76f8fc2c00fe
--- /dev/null
+++ b/sound/soc/codecs/da7219.c
@@ -0,0 +1,1940 @@
+/*
+ * da7219.c - DA7219 ALSA SoC Codec Driver
+ *
+ * Copyright (c) 2015 Dialog Semiconductor
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <asm/div64.h>
+
+#include <sound/da7219.h>
+#include "da7219.h"
+#include "da7219-aad.h"
+
+
+/*
+ * TLVs and Enums
+ */
+
+/* Input TLVs */
+static const DECLARE_TLV_DB_SCALE(da7219_mic_gain_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_mixin_gain_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_adc_dig_gain_tlv, -8325, 75, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_alc_threshold_tlv, -9450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_alc_gain_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_alc_ana_gain_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_sidetone_gain_tlv, -4200, 300, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_tonegen_gain_tlv, -4500, 300, 0);
+
+/* Output TLVs */
+static const DECLARE_TLV_DB_SCALE(da7219_dac_eq_band_tlv, -1050, 150, 0);
+
+static const DECLARE_TLV_DB_RANGE(da7219_dac_dig_gain_tlv,
+	0x0, 0x07, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),
+	/* -77.25dB to 12dB */
+	0x08, 0x7f, TLV_DB_SCALE_ITEM(-7725, 75, 0)
+);
+
+static const DECLARE_TLV_DB_SCALE(da7219_dac_ng_threshold_tlv, -10200, 600, 0);
+static const DECLARE_TLV_DB_SCALE(da7219_hp_gain_tlv, -5700, 100, 0);
+
+/* Input Enums */
+static const char * const da7219_alc_attack_rate_txt[] = {
+	"7.33/fs", "14.66/fs", "29.32/fs", "58.64/fs", "117.3/fs", "234.6/fs",
+	"469.1/fs", "938.2/fs", "1876/fs", "3753/fs", "7506/fs", "15012/fs",
+	"30024/fs"
+};
+
+static const struct soc_enum da7219_alc_attack_rate =
+	SOC_ENUM_SINGLE(DA7219_ALC_CTRL2, DA7219_ALC_ATTACK_SHIFT,
+			DA7219_ALC_ATTACK_MAX, da7219_alc_attack_rate_txt);
+
+static const char * const da7219_alc_release_rate_txt[] = {
+	"28.66/fs", "57.33/fs", "114.6/fs", "229.3/fs", "458.6/fs", "917.1/fs",
+	"1834/fs", "3668/fs", "7337/fs", "14674/fs", "29348/fs"
+};
+
+static const struct soc_enum da7219_alc_release_rate =
+	SOC_ENUM_SINGLE(DA7219_ALC_CTRL2, DA7219_ALC_RELEASE_SHIFT,
+			DA7219_ALC_RELEASE_MAX, da7219_alc_release_rate_txt);
+
+static const char * const da7219_alc_hold_time_txt[] = {
+	"62/fs", "124/fs", "248/fs", "496/fs", "992/fs", "1984/fs", "3968/fs",
+	"7936/fs", "15872/fs", "31744/fs", "63488/fs", "126976/fs",
+	"253952/fs", "507904/fs", "1015808/fs", "2031616/fs"
+};
+
+static const struct soc_enum da7219_alc_hold_time =
+	SOC_ENUM_SINGLE(DA7219_ALC_CTRL3, DA7219_ALC_HOLD_SHIFT,
+			DA7219_ALC_HOLD_MAX, da7219_alc_hold_time_txt);
+
+static const char * const da7219_alc_env_rate_txt[] = {
+	"1/4", "1/16", "1/256", "1/65536"
+};
+
+static const struct soc_enum da7219_alc_env_attack_rate =
+	SOC_ENUM_SINGLE(DA7219_ALC_CTRL3, DA7219_ALC_INTEG_ATTACK_SHIFT,
+			DA7219_ALC_INTEG_MAX, da7219_alc_env_rate_txt);
+
+static const struct soc_enum da7219_alc_env_release_rate =
+	SOC_ENUM_SINGLE(DA7219_ALC_CTRL3, DA7219_ALC_INTEG_RELEASE_SHIFT,
+			DA7219_ALC_INTEG_MAX, da7219_alc_env_rate_txt);
+
+static const char * const da7219_alc_anticlip_step_txt[] = {
+	"0.034dB/fs", "0.068dB/fs", "0.136dB/fs", "0.272dB/fs"
+};
+
+static const struct soc_enum da7219_alc_anticlip_step =
+	SOC_ENUM_SINGLE(DA7219_ALC_ANTICLIP_CTRL,
+			DA7219_ALC_ANTICLIP_STEP_SHIFT,
+			DA7219_ALC_ANTICLIP_STEP_MAX,
+			da7219_alc_anticlip_step_txt);
+
+/* Input/Output Enums */
+static const char * const da7219_gain_ramp_rate_txt[] = {
+	"Nominal Rate * 8", "Nominal Rate", "Nominal Rate / 8",
+	"Nominal Rate / 16"
+};
+
+static const struct soc_enum da7219_gain_ramp_rate =
+	SOC_ENUM_SINGLE(DA7219_GAIN_RAMP_CTRL, DA7219_GAIN_RAMP_RATE_SHIFT,
+			DA7219_GAIN_RAMP_RATE_MAX, da7219_gain_ramp_rate_txt);
+
+static const char * const da7219_hpf_mode_txt[] = {
+	"Disabled", "Audio", "Voice"
+};
+
+static const unsigned int da7219_hpf_mode_val[] = {
+	DA7219_HPF_DISABLED, DA7219_HPF_AUDIO_EN, DA7219_HPF_VOICE_EN,
+};
+
+static const struct soc_enum da7219_adc_hpf_mode =
+	SOC_VALUE_ENUM_SINGLE(DA7219_ADC_FILTERS1, DA7219_HPF_MODE_SHIFT,
+			      DA7219_HPF_MODE_MASK, DA7219_HPF_MODE_MAX,
+			      da7219_hpf_mode_txt, da7219_hpf_mode_val);
+
+static const struct soc_enum da7219_dac_hpf_mode =
+	SOC_VALUE_ENUM_SINGLE(DA7219_DAC_FILTERS1, DA7219_HPF_MODE_SHIFT,
+			      DA7219_HPF_MODE_MASK, DA7219_HPF_MODE_MAX,
+			      da7219_hpf_mode_txt, da7219_hpf_mode_val);
+
+static const char * const da7219_audio_hpf_corner_txt[] = {
+	"2Hz", "4Hz", "8Hz", "16Hz"
+};
+
+static const struct soc_enum da7219_adc_audio_hpf_corner =
+	SOC_ENUM_SINGLE(DA7219_ADC_FILTERS1,
+			DA7219_ADC_AUDIO_HPF_CORNER_SHIFT,
+			DA7219_AUDIO_HPF_CORNER_MAX,
+			da7219_audio_hpf_corner_txt);
+
+static const struct soc_enum da7219_dac_audio_hpf_corner =
+	SOC_ENUM_SINGLE(DA7219_DAC_FILTERS1,
+			DA7219_DAC_AUDIO_HPF_CORNER_SHIFT,
+			DA7219_AUDIO_HPF_CORNER_MAX,
+			da7219_audio_hpf_corner_txt);
+
+static const char * const da7219_voice_hpf_corner_txt[] = {
+	"2.5Hz", "25Hz", "50Hz", "100Hz", "150Hz", "200Hz", "300Hz", "400Hz"
+};
+
+static const struct soc_enum da7219_adc_voice_hpf_corner =
+	SOC_ENUM_SINGLE(DA7219_ADC_FILTERS1,
+			DA7219_ADC_VOICE_HPF_CORNER_SHIFT,
+			DA7219_VOICE_HPF_CORNER_MAX,
+			da7219_voice_hpf_corner_txt);
+
+static const struct soc_enum da7219_dac_voice_hpf_corner =
+	SOC_ENUM_SINGLE(DA7219_DAC_FILTERS1,
+			DA7219_DAC_VOICE_HPF_CORNER_SHIFT,
+			DA7219_VOICE_HPF_CORNER_MAX,
+			da7219_voice_hpf_corner_txt);
+
+static const char * const da7219_tonegen_dtmf_key_txt[] = {
+	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D",
+	"*", "#"
+};
+
+static const struct soc_enum da7219_tonegen_dtmf_key =
+	SOC_ENUM_SINGLE(DA7219_TONE_GEN_CFG1, DA7219_DTMF_REG_SHIFT,
+			DA7219_DTMF_REG_MAX, da7219_tonegen_dtmf_key_txt);
+
+static const char * const da7219_tonegen_swg_sel_txt[] = {
+	"Sum", "SWG1", "SWG2", "SWG1_1-Cos"
+};
+
+static const struct soc_enum da7219_tonegen_swg_sel =
+	SOC_ENUM_SINGLE(DA7219_TONE_GEN_CFG2, DA7219_SWG_SEL_SHIFT,
+			DA7219_SWG_SEL_MAX, da7219_tonegen_swg_sel_txt);
+
+/* Output Enums */
+static const char * const da7219_dac_softmute_rate_txt[] = {
+	"1 Sample", "2 Samples", "4 Samples", "8 Samples", "16 Samples",
+	"32 Samples", "64 Samples"
+};
+
+static const struct soc_enum da7219_dac_softmute_rate =
+	SOC_ENUM_SINGLE(DA7219_DAC_FILTERS5, DA7219_DAC_SOFTMUTE_RATE_SHIFT,
+			DA7219_DAC_SOFTMUTE_RATE_MAX,
+			da7219_dac_softmute_rate_txt);
+
+static const char * const da7219_dac_ng_setup_time_txt[] = {
+	"256 Samples", "512 Samples", "1024 Samples", "2048 Samples"
+};
+
+static const struct soc_enum da7219_dac_ng_setup_time =
+	SOC_ENUM_SINGLE(DA7219_DAC_NG_SETUP_TIME,
+			DA7219_DAC_NG_SETUP_TIME_SHIFT,
+			DA7219_DAC_NG_SETUP_TIME_MAX,
+			da7219_dac_ng_setup_time_txt);
+
+static const char * const da7219_dac_ng_rampup_txt[] = {
+	"0.22ms/dB", "0.0138ms/dB"
+};
+
+static const struct soc_enum da7219_dac_ng_rampup_rate =
+	SOC_ENUM_SINGLE(DA7219_DAC_NG_SETUP_TIME,
+			DA7219_DAC_NG_RAMPUP_RATE_SHIFT,
+			DA7219_DAC_NG_RAMP_RATE_MAX,
+			da7219_dac_ng_rampup_txt);
+
+static const char * const da7219_dac_ng_rampdown_txt[] = {
+	"0.88ms/dB", "14.08ms/dB"
+};
+
+static const struct soc_enum da7219_dac_ng_rampdown_rate =
+	SOC_ENUM_SINGLE(DA7219_DAC_NG_SETUP_TIME,
+			DA7219_DAC_NG_RAMPDN_RATE_SHIFT,
+			DA7219_DAC_NG_RAMP_RATE_MAX,
+			da7219_dac_ng_rampdown_txt);
+
+
+static const char * const da7219_cp_track_mode_txt[] = {
+	"Largest Volume", "DAC Volume", "Signal Magnitude"
+};
+
+static const unsigned int da7219_cp_track_mode_val[] = {
+	DA7219_CP_MCHANGE_LARGEST_VOL, DA7219_CP_MCHANGE_DAC_VOL,
+	DA7219_CP_MCHANGE_SIG_MAG
+};
+
+static const struct soc_enum da7219_cp_track_mode =
+	SOC_VALUE_ENUM_SINGLE(DA7219_CP_CTRL, DA7219_CP_MCHANGE_SHIFT,
+			      DA7219_CP_MCHANGE_REL_MASK, DA7219_CP_MCHANGE_MAX,
+			      da7219_cp_track_mode_txt,
+			      da7219_cp_track_mode_val);
+
+
+/*
+ * Control Functions
+ */
+
+/* Locked Kcontrol calls */
+static int da7219_volsw_locked_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	mutex_lock(&da7219->lock);
+	ret = snd_soc_get_volsw(kcontrol, ucontrol);
+	mutex_unlock(&da7219->lock);
+
+	return ret;
+}
+
+static int da7219_volsw_locked_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	mutex_lock(&da7219->lock);
+	ret = snd_soc_put_volsw(kcontrol, ucontrol);
+	mutex_unlock(&da7219->lock);
+
+	return ret;
+}
+
+static int da7219_enum_locked_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	mutex_lock(&da7219->lock);
+	ret = snd_soc_get_enum_double(kcontrol, ucontrol);
+	mutex_unlock(&da7219->lock);
+
+	return ret;
+}
+
+static int da7219_enum_locked_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	mutex_lock(&da7219->lock);
+	ret = snd_soc_put_enum_double(kcontrol, ucontrol);
+	mutex_unlock(&da7219->lock);
+
+	return ret;
+}
+
+/* ALC */
+static void da7219_alc_calib(struct snd_soc_codec *codec)
+{
+	u8 mic_ctrl, mixin_ctrl, adc_ctrl, calib_ctrl;
+
+	/* Save current state of mic control register */
+	mic_ctrl = snd_soc_read(codec, DA7219_MIC_1_CTRL);
+
+	/* Save current state of input mixer control register */
+	mixin_ctrl = snd_soc_read(codec, DA7219_MIXIN_L_CTRL);
+
+	/* Save current state of input ADC control register */
+	adc_ctrl = snd_soc_read(codec, DA7219_ADC_L_CTRL);
+
+	/* Enable then Mute MIC PGAs */
+	snd_soc_update_bits(codec, DA7219_MIC_1_CTRL, DA7219_MIC_1_AMP_EN_MASK,
+			    DA7219_MIC_1_AMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_MIC_1_CTRL,
+			    DA7219_MIC_1_AMP_MUTE_EN_MASK,
+			    DA7219_MIC_1_AMP_MUTE_EN_MASK);
+
+	/* Enable input mixers unmuted */
+	snd_soc_update_bits(codec, DA7219_MIXIN_L_CTRL,
+			    DA7219_MIXIN_L_AMP_EN_MASK |
+			    DA7219_MIXIN_L_AMP_MUTE_EN_MASK,
+			    DA7219_MIXIN_L_AMP_EN_MASK);
+
+	/* Enable input filters unmuted */
+	snd_soc_update_bits(codec, DA7219_ADC_L_CTRL,
+			    DA7219_ADC_L_MUTE_EN_MASK | DA7219_ADC_L_EN_MASK,
+			    DA7219_ADC_L_EN_MASK);
+
+	/* Perform auto calibration */
+	snd_soc_update_bits(codec, DA7219_ALC_CTRL1,
+			    DA7219_ALC_AUTO_CALIB_EN_MASK,
+			    DA7219_ALC_AUTO_CALIB_EN_MASK);
+	do {
+		calib_ctrl = snd_soc_read(codec, DA7219_ALC_CTRL1);
+	} while (calib_ctrl & DA7219_ALC_AUTO_CALIB_EN_MASK);
+
+	/* If auto calibration fails, disable DC offset, hybrid ALC */
+	if (calib_ctrl & DA7219_ALC_CALIB_OVERFLOW_MASK) {
+		dev_warn(codec->dev,
+			 "ALC auto calibration failed with overflow\n");
+		snd_soc_update_bits(codec, DA7219_ALC_CTRL1,
+				    DA7219_ALC_OFFSET_EN_MASK |
+				    DA7219_ALC_SYNC_MODE_MASK, 0);
+	} else {
+		/* Enable DC offset cancellation, hybrid mode */
+		snd_soc_update_bits(codec, DA7219_ALC_CTRL1,
+				    DA7219_ALC_OFFSET_EN_MASK |
+				    DA7219_ALC_SYNC_MODE_MASK,
+				    DA7219_ALC_OFFSET_EN_MASK |
+				    DA7219_ALC_SYNC_MODE_MASK);
+	}
+
+	/* Restore input filter control register to original state */
+	snd_soc_write(codec, DA7219_ADC_L_CTRL, adc_ctrl);
+
+	/* Restore input mixer control registers to original state */
+	snd_soc_write(codec, DA7219_MIXIN_L_CTRL, mixin_ctrl);
+
+	/* Restore MIC control registers to original states */
+	snd_soc_write(codec, DA7219_MIC_1_CTRL, mic_ctrl);
+}
+
+static int da7219_mixin_gain_put(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	ret = snd_soc_put_volsw(kcontrol, ucontrol);
+
+	/*
+	 * If ALC in operation and value of control has been updated,
+	 * make sure calibrated offsets are updated.
+	 */
+	if ((ret == 1) && (da7219->alc_en))
+		da7219_alc_calib(codec);
+
+	return ret;
+}
+
+static int da7219_alc_sw_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+
+	/* Force ALC offset calibration if enabling ALC */
+	if ((ucontrol->value.integer.value[0]) && (!da7219->alc_en)) {
+		da7219_alc_calib(codec);
+		da7219->alc_en = false;
+	} else {
+		da7219->alc_en = false;
+	}
+
+	return snd_soc_put_volsw(kcontrol, ucontrol);
+}
+
+/* ToneGen */
+static int da7219_tonegen_freq_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct soc_mixer_control *mixer_ctrl =
+		(struct soc_mixer_control *) kcontrol->private_value;
+	unsigned int reg = mixer_ctrl->reg;
+	u16 val;
+	int ret;
+
+	mutex_lock(&da7219->lock);
+	ret = regmap_raw_read(da7219->regmap, reg, &val, sizeof(val));
+	mutex_unlock(&da7219->lock);
+
+	if (ret)
+		return ret;
+
+	/*
+	 * Frequency value spans two 8-bit registers, lower then upper byte.
+	 * Therefore we need to convert to host endianness here.
+	 */
+	ucontrol->value.integer.value[0] = le16_to_cpu(val);
+
+	return 0;
+}
+
+static int da7219_tonegen_freq_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct soc_mixer_control *mixer_ctrl =
+		(struct soc_mixer_control *) kcontrol->private_value;
+	unsigned int reg = mixer_ctrl->reg;
+	u16 val;
+	int ret;
+
+	/*
+	 * Frequency value spans two 8-bit registers, lower then upper byte.
+	 * Therefore we need to convert to little endian here to align with
+	 * HW registers.
+	 */
+	val = cpu_to_le16(ucontrol->value.integer.value[0]);
+
+	mutex_lock(&da7219->lock);
+	ret = regmap_raw_write(da7219->regmap, reg, &val, sizeof(val));
+	mutex_unlock(&da7219->lock);
+
+	return ret;
+}
+
+
+/*
+ * KControls
+ */
+
+static const struct snd_kcontrol_new da7219_snd_controls[] = {
+	/* Mics */
+	SOC_SINGLE_TLV("Mic Volume", DA7219_MIC_1_GAIN,
+		       DA7219_MIC_1_AMP_GAIN_SHIFT, DA7219_MIC_1_AMP_GAIN_MAX,
+		       DA7219_NO_INVERT, da7219_mic_gain_tlv),
+	SOC_SINGLE("Mic Switch", DA7219_MIC_1_CTRL,
+		   DA7219_MIC_1_AMP_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_INVERT),
+
+	/* Mixer Input */
+	SOC_SINGLE_EXT_TLV("Mixin Volume", DA7219_MIXIN_L_GAIN,
+			   DA7219_MIXIN_L_AMP_GAIN_SHIFT,
+			   DA7219_MIXIN_L_AMP_GAIN_MAX, DA7219_NO_INVERT,
+			   snd_soc_get_volsw, da7219_mixin_gain_put,
+			   da7219_mixin_gain_tlv),
+	SOC_SINGLE("Mixin Switch", DA7219_MIXIN_L_CTRL,
+		   DA7219_MIXIN_L_AMP_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_INVERT),
+	SOC_SINGLE("Mixin Gain Ramp Switch", DA7219_MIXIN_L_CTRL,
+		   DA7219_MIXIN_L_AMP_RAMP_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_NO_INVERT),
+	SOC_SINGLE("Mixin ZC Gain Switch", DA7219_MIXIN_L_CTRL,
+		   DA7219_MIXIN_L_AMP_ZC_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_NO_INVERT),
+
+	/* ADC */
+	SOC_SINGLE_TLV("Capture Digital Volume", DA7219_ADC_L_GAIN,
+		       DA7219_ADC_L_DIGITAL_GAIN_SHIFT,
+		       DA7219_ADC_L_DIGITAL_GAIN_MAX, DA7219_NO_INVERT,
+		       da7219_adc_dig_gain_tlv),
+	SOC_SINGLE("Capture Digital Switch", DA7219_ADC_L_CTRL,
+		   DA7219_ADC_L_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_INVERT),
+	SOC_SINGLE("Capture Digital Gain Ramp Switch", DA7219_ADC_L_CTRL,
+		   DA7219_ADC_L_RAMP_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_NO_INVERT),
+
+	/* ALC */
+	SOC_ENUM("ALC Attack Rate", da7219_alc_attack_rate),
+	SOC_ENUM("ALC Release Rate", da7219_alc_release_rate),
+	SOC_ENUM("ALC Hold Time", da7219_alc_hold_time),
+	SOC_ENUM("ALC Envelope Attack Rate", da7219_alc_env_attack_rate),
+	SOC_ENUM("ALC Envelope Release Rate", da7219_alc_env_release_rate),
+	SOC_SINGLE_TLV("ALC Noise Threshold", DA7219_ALC_NOISE,
+		       DA7219_ALC_NOISE_SHIFT, DA7219_ALC_THRESHOLD_MAX,
+		       DA7219_INVERT, da7219_alc_threshold_tlv),
+	SOC_SINGLE_TLV("ALC Min Threshold", DA7219_ALC_TARGET_MIN,
+		       DA7219_ALC_THRESHOLD_MIN_SHIFT, DA7219_ALC_THRESHOLD_MAX,
+		       DA7219_INVERT, da7219_alc_threshold_tlv),
+	SOC_SINGLE_TLV("ALC Max Threshold", DA7219_ALC_TARGET_MAX,
+		       DA7219_ALC_THRESHOLD_MAX_SHIFT, DA7219_ALC_THRESHOLD_MAX,
+		       DA7219_INVERT, da7219_alc_threshold_tlv),
+	SOC_SINGLE_TLV("ALC Max Attenuation", DA7219_ALC_GAIN_LIMITS,
+		       DA7219_ALC_ATTEN_MAX_SHIFT, DA7219_ALC_ATTEN_GAIN_MAX,
+		       DA7219_NO_INVERT, da7219_alc_gain_tlv),
+	SOC_SINGLE_TLV("ALC Max Volume", DA7219_ALC_GAIN_LIMITS,
+		       DA7219_ALC_GAIN_MAX_SHIFT, DA7219_ALC_ATTEN_GAIN_MAX,
+		       DA7219_NO_INVERT, da7219_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC Min Analog Volume", DA7219_ALC_ANA_GAIN_LIMITS,
+			     DA7219_ALC_ANA_GAIN_MIN_SHIFT,
+			     DA7219_ALC_ANA_GAIN_MIN, DA7219_ALC_ANA_GAIN_MAX,
+			     DA7219_NO_INVERT, da7219_alc_ana_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC Max Analog Volume", DA7219_ALC_ANA_GAIN_LIMITS,
+			     DA7219_ALC_ANA_GAIN_MAX_SHIFT,
+			     DA7219_ALC_ANA_GAIN_MIN, DA7219_ALC_ANA_GAIN_MAX,
+			     DA7219_NO_INVERT, da7219_alc_ana_gain_tlv),
+	SOC_ENUM("ALC Anticlip Step", da7219_alc_anticlip_step),
+	SOC_SINGLE("ALC Anticlip Switch", DA7219_ALC_ANTICLIP_CTRL,
+		   DA7219_ALC_ANTIPCLIP_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_NO_INVERT),
+	SOC_SINGLE_EXT("ALC Switch", DA7219_ALC_CTRL1, DA7219_ALC_EN_SHIFT,
+		       DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT,
+		       snd_soc_get_volsw, da7219_alc_sw_put),
+
+	/* Input High-Pass Filters */
+	SOC_ENUM("ADC HPF Mode", da7219_adc_hpf_mode),
+	SOC_ENUM("ADC HPF Corner Audio", da7219_adc_audio_hpf_corner),
+	SOC_ENUM("ADC HPF Corner Voice", da7219_adc_voice_hpf_corner),
+
+	/* Sidetone Filter */
+	SOC_SINGLE_TLV("Sidetone Volume", DA7219_SIDETONE_GAIN,
+		       DA7219_SIDETONE_GAIN_SHIFT, DA7219_SIDETONE_GAIN_MAX,
+		       DA7219_NO_INVERT, da7219_sidetone_gain_tlv),
+	SOC_SINGLE("Sidetone Switch", DA7219_SIDETONE_CTRL,
+		   DA7219_SIDETONE_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		   DA7219_INVERT),
+
+	/* Tone Generator */
+	SOC_SINGLE_EXT_TLV("ToneGen Volume", DA7219_TONE_GEN_CFG2,
+			   DA7219_TONE_GEN_GAIN_SHIFT, DA7219_TONE_GEN_GAIN_MAX,
+			   DA7219_NO_INVERT, da7219_volsw_locked_get,
+			   da7219_volsw_locked_put, da7219_tonegen_gain_tlv),
+	SOC_ENUM_EXT("ToneGen DTMF Key", da7219_tonegen_dtmf_key,
+		     da7219_enum_locked_get, da7219_enum_locked_put),
+	SOC_SINGLE_EXT("ToneGen DTMF Switch", DA7219_TONE_GEN_CFG1,
+		       DA7219_DTMF_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		       DA7219_NO_INVERT, da7219_volsw_locked_get,
+		       da7219_volsw_locked_put),
+	SOC_ENUM_EXT("ToneGen Sinewave Gen Type", da7219_tonegen_swg_sel,
+		     da7219_enum_locked_get, da7219_enum_locked_put),
+	SOC_SINGLE_EXT("ToneGen Sinewave1 Freq", DA7219_TONE_GEN_FREQ1_L,
+		       DA7219_FREQ1_L_SHIFT, DA7219_FREQ_MAX, DA7219_NO_INVERT,
+		       da7219_tonegen_freq_get, da7219_tonegen_freq_put),
+	SOC_SINGLE_EXT("ToneGen Sinewave2 Freq", DA7219_TONE_GEN_FREQ2_L,
+		       DA7219_FREQ2_L_SHIFT, DA7219_FREQ_MAX, DA7219_NO_INVERT,
+		       da7219_tonegen_freq_get, da7219_tonegen_freq_put),
+	SOC_SINGLE_EXT("ToneGen On Time", DA7219_TONE_GEN_ON_PER,
+		       DA7219_BEEP_ON_PER_SHIFT, DA7219_BEEP_ON_OFF_MAX,
+		       DA7219_NO_INVERT, da7219_volsw_locked_get,
+		       da7219_volsw_locked_put),
+	SOC_SINGLE("ToneGen Off Time", DA7219_TONE_GEN_OFF_PER,
+		   DA7219_BEEP_OFF_PER_SHIFT, DA7219_BEEP_ON_OFF_MAX,
+		   DA7219_NO_INVERT),
+
+	/* Gain ramping */
+	SOC_ENUM("Gain Ramp Rate", da7219_gain_ramp_rate),
+
+	/* DAC High-Pass Filter */
+	SOC_ENUM_EXT("DAC HPF Mode", da7219_dac_hpf_mode,
+		     da7219_enum_locked_get, da7219_enum_locked_put),
+	SOC_ENUM("DAC HPF Corner Audio", da7219_dac_audio_hpf_corner),
+	SOC_ENUM("DAC HPF Corner Voice", da7219_dac_voice_hpf_corner),
+
+	/* DAC 5-Band Equaliser */
+	SOC_SINGLE_TLV("DAC EQ Band1 Volume", DA7219_DAC_FILTERS2,
+		       DA7219_DAC_EQ_BAND1_SHIFT, DA7219_DAC_EQ_BAND_MAX,
+		       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),
+	SOC_SINGLE_TLV("DAC EQ Band2 Volume", DA7219_DAC_FILTERS2,
+		       DA7219_DAC_EQ_BAND2_SHIFT, DA7219_DAC_EQ_BAND_MAX,
+		       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),
+	SOC_SINGLE_TLV("DAC EQ Band3 Volume", DA7219_DAC_FILTERS3,
+		       DA7219_DAC_EQ_BAND3_SHIFT, DA7219_DAC_EQ_BAND_MAX,
+		       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),
+	SOC_SINGLE_TLV("DAC EQ Band4 Volume", DA7219_DAC_FILTERS3,
+		       DA7219_DAC_EQ_BAND4_SHIFT, DA7219_DAC_EQ_BAND_MAX,
+		       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),
+	SOC_SINGLE_TLV("DAC EQ Band5 Volume", DA7219_DAC_FILTERS4,
+		       DA7219_DAC_EQ_BAND5_SHIFT, DA7219_DAC_EQ_BAND_MAX,
+		       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),
+	SOC_SINGLE_EXT("DAC EQ Switch", DA7219_DAC_FILTERS4,
+		       DA7219_DAC_EQ_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		       DA7219_NO_INVERT, da7219_volsw_locked_get,
+		       da7219_volsw_locked_put),
+
+	/* DAC Softmute */
+	SOC_ENUM("DAC Soft Mute Rate", da7219_dac_softmute_rate),
+	SOC_SINGLE_EXT("DAC Soft Mute Switch", DA7219_DAC_FILTERS5,
+		       DA7219_DAC_SOFTMUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+		       DA7219_NO_INVERT, da7219_volsw_locked_get,
+		       da7219_volsw_locked_put),
+
+	/* DAC Noise Gate */
+	SOC_ENUM("DAC NG Setup Time", da7219_dac_ng_setup_time),
+	SOC_ENUM("DAC NG Rampup Rate", da7219_dac_ng_rampup_rate),
+	SOC_ENUM("DAC NG Rampdown Rate", da7219_dac_ng_rampdown_rate),
+	SOC_SINGLE_TLV("DAC NG Off Threshold", DA7219_DAC_NG_OFF_THRESH,
+		       DA7219_DAC_NG_OFF_THRESHOLD_SHIFT,
+		       DA7219_DAC_NG_THRESHOLD_MAX, DA7219_NO_INVERT,
+		       da7219_dac_ng_threshold_tlv),
+	SOC_SINGLE_TLV("DAC NG On Threshold", DA7219_DAC_NG_ON_THRESH,
+		       DA7219_DAC_NG_ON_THRESHOLD_SHIFT,
+		       DA7219_DAC_NG_THRESHOLD_MAX, DA7219_NO_INVERT,
+		       da7219_dac_ng_threshold_tlv),
+	SOC_SINGLE("DAC NG Switch", DA7219_DAC_NG_CTRL, DA7219_DAC_NG_EN_SHIFT,
+		   DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+
+	/* DACs */
+	SOC_DOUBLE_R_EXT_TLV("Playback Digital Volume", DA7219_DAC_L_GAIN,
+			     DA7219_DAC_R_GAIN, DA7219_DAC_L_DIGITAL_GAIN_SHIFT,
+			     DA7219_DAC_DIGITAL_GAIN_MAX, DA7219_NO_INVERT,
+			     da7219_volsw_locked_get, da7219_volsw_locked_put,
+			     da7219_dac_dig_gain_tlv),
+	SOC_DOUBLE_R_EXT("Playback Digital Switch", DA7219_DAC_L_CTRL,
+			 DA7219_DAC_R_CTRL, DA7219_DAC_L_MUTE_EN_SHIFT,
+			 DA7219_SWITCH_EN_MAX, DA7219_INVERT,
+			 da7219_volsw_locked_get, da7219_volsw_locked_put),
+	SOC_DOUBLE_R("Playback Digital Gain Ramp Switch", DA7219_DAC_L_CTRL,
+		     DA7219_DAC_R_CTRL, DA7219_DAC_L_RAMP_EN_SHIFT,
+		     DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+
+	/* CP */
+	SOC_ENUM("Charge Pump Track Mode", da7219_cp_track_mode),
+	SOC_SINGLE("Charge Pump Threshold", DA7219_CP_VOL_THRESHOLD1,
+		   DA7219_CP_THRESH_VDD2_SHIFT, DA7219_CP_THRESH_VDD2_MAX,
+		   DA7219_NO_INVERT),
+
+	/* Headphones */
+	SOC_DOUBLE_R_EXT_TLV("Headphone Volume", DA7219_HP_L_GAIN,
+			     DA7219_HP_R_GAIN, DA7219_HP_L_AMP_GAIN_SHIFT,
+			     DA7219_HP_AMP_GAIN_MAX, DA7219_NO_INVERT,
+			     da7219_volsw_locked_get, da7219_volsw_locked_put,
+			     da7219_hp_gain_tlv),
+	SOC_DOUBLE_R_EXT("Headphone Switch", DA7219_HP_L_CTRL, DA7219_HP_R_CTRL,
+			 DA7219_HP_L_AMP_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,
+			 DA7219_INVERT, da7219_volsw_locked_get,
+			 da7219_volsw_locked_put),
+	SOC_DOUBLE_R("Headphone Gain Ramp Switch", DA7219_HP_L_CTRL,
+		     DA7219_HP_R_CTRL, DA7219_HP_L_AMP_RAMP_EN_SHIFT,
+		     DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+	SOC_DOUBLE_R("Headphone ZC Gain Switch", DA7219_HP_L_CTRL,
+		     DA7219_HP_R_CTRL, DA7219_HP_L_AMP_ZC_EN_SHIFT,
+		     DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+};
+
+
+/*
+ * DAPM Mux Controls
+ */
+
+static const char * const da7219_out_sel_txt[] = {
+	"ADC", "Tone Generator", "DAIL", "DAIR"
+};
+
+static const struct soc_enum da7219_out_dail_sel =
+	SOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAI,
+			DA7219_DAI_L_SRC_SHIFT,
+			DA7219_OUT_SRC_MAX,
+			da7219_out_sel_txt);
+
+static const struct snd_kcontrol_new da7219_out_dail_sel_mux =
+	SOC_DAPM_ENUM("Out DAIL Mux", da7219_out_dail_sel);
+
+static const struct soc_enum da7219_out_dair_sel =
+	SOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAI,
+			DA7219_DAI_R_SRC_SHIFT,
+			DA7219_OUT_SRC_MAX,
+			da7219_out_sel_txt);
+
+static const struct snd_kcontrol_new da7219_out_dair_sel_mux =
+	SOC_DAPM_ENUM("Out DAIR Mux", da7219_out_dair_sel);
+
+static const struct soc_enum da7219_out_dacl_sel =
+	SOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAC,
+			DA7219_DAC_L_SRC_SHIFT,
+			DA7219_OUT_SRC_MAX,
+			da7219_out_sel_txt);
+
+static const struct snd_kcontrol_new da7219_out_dacl_sel_mux =
+	SOC_DAPM_ENUM("Out DACL Mux", da7219_out_dacl_sel);
+
+static const struct soc_enum da7219_out_dacr_sel =
+	SOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAC,
+			DA7219_DAC_R_SRC_SHIFT,
+			DA7219_OUT_SRC_MAX,
+			da7219_out_sel_txt);
+
+static const struct snd_kcontrol_new da7219_out_dacr_sel_mux =
+	SOC_DAPM_ENUM("Out DACR Mux", da7219_out_dacr_sel);
+
+
+/*
+ * DAPM Mixer Controls
+ */
+
+static const struct snd_kcontrol_new da7219_mixin_controls[] = {
+	SOC_DAPM_SINGLE("Mic Switch", DA7219_MIXIN_L_SELECT,
+			DA7219_MIXIN_L_MIX_SELECT_SHIFT,
+			DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+};
+
+static const struct snd_kcontrol_new da7219_mixout_l_controls[] = {
+	SOC_DAPM_SINGLE("DACL Switch", DA7219_MIXOUT_L_SELECT,
+			DA7219_MIXOUT_L_MIX_SELECT_SHIFT,
+			DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+};
+
+static const struct snd_kcontrol_new da7219_mixout_r_controls[] = {
+	SOC_DAPM_SINGLE("DACR Switch", DA7219_MIXOUT_R_SELECT,
+			DA7219_MIXOUT_R_MIX_SELECT_SHIFT,
+			DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),
+};
+
+#define DA7219_DMIX_ST_CTRLS(reg)					\
+	SOC_DAPM_SINGLE("Out FilterL Switch", reg,			\
+			DA7219_DMIX_ST_SRC_OUTFILT1L_SHIFT,		\
+			DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),	\
+	SOC_DAPM_SINGLE("Out FilterR Switch", reg,			\
+			DA7219_DMIX_ST_SRC_OUTFILT1R_SHIFT,		\
+			DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),	\
+	SOC_DAPM_SINGLE("Sidetone Switch", reg,				\
+			DA7219_DMIX_ST_SRC_SIDETONE_SHIFT,		\
+			DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT)		\
+
+static const struct snd_kcontrol_new da7219_st_out_filtl_mix_controls[] = {
+	DA7219_DMIX_ST_CTRLS(DA7219_DROUTING_ST_OUTFILT_1L),
+};
+
+static const struct snd_kcontrol_new da7219_st_out_filtr_mix_controls[] = {
+	DA7219_DMIX_ST_CTRLS(DA7219_DROUTING_ST_OUTFILT_1R),
+};
+
+
+/*
+ * DAPM Events
+ */
+
+static int da7219_dai_event(struct snd_soc_dapm_widget *w,
+			    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	u8 pll_ctrl, pll_status;
+	int i = 0;
+	bool srm_lock = false;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		if (da7219->master)
+			/* Enable DAI clks for master mode */
+			snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
+					    DA7219_DAI_CLK_EN_MASK,
+					    DA7219_DAI_CLK_EN_MASK);
+
+		/* PC synchronised to DAI */
+		snd_soc_update_bits(codec, DA7219_PC_COUNT,
+				    DA7219_PC_FREERUN_MASK, 0);
+
+		/* Slave mode, if SRM not enabled no need for status checks */
+		pll_ctrl = snd_soc_read(codec, DA7219_PLL_CTRL);
+		if ((pll_ctrl & DA7219_PLL_MODE_MASK) != DA7219_PLL_MODE_SRM)
+			return 0;
+
+		/* Check SRM has locked */
+		do {
+			pll_status = snd_soc_read(codec, DA7219_PLL_SRM_STS);
+			if (pll_status & DA7219_PLL_SRM_STS_SRM_LOCK) {
+				srm_lock = true;
+			} else {
+				++i;
+				msleep(50);
+			}
+		} while ((i < DA7219_SRM_CHECK_RETRIES) & (!srm_lock));
+
+		if (!srm_lock)
+			dev_warn(codec->dev, "SRM failed to lock\n");
+
+		return 0;
+	case SND_SOC_DAPM_POST_PMD:
+		/* PC free-running */
+		snd_soc_update_bits(codec, DA7219_PC_COUNT,
+				    DA7219_PC_FREERUN_MASK,
+				    DA7219_PC_FREERUN_MASK);
+
+		/* Disable DAI clks if in master mode */
+		if (da7219->master)
+			snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
+					    DA7219_DAI_CLK_EN_MASK, 0);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+
+/*
+ * DAPM Widgets
+ */
+
+static const struct snd_soc_dapm_widget da7219_dapm_widgets[] = {
+	/* Input Supplies */
+	SND_SOC_DAPM_SUPPLY("Mic Bias", DA7219_MICBIAS_CTRL,
+			    DA7219_MICBIAS1_EN_SHIFT, DA7219_NO_INVERT,
+			    NULL, 0),
+
+	/* Inputs */
+	SND_SOC_DAPM_INPUT("MIC"),
+
+	/* Input PGAs */
+	SND_SOC_DAPM_PGA("Mic PGA", DA7219_MIC_1_CTRL,
+			 DA7219_MIC_1_AMP_EN_SHIFT, DA7219_NO_INVERT,
+			 NULL, 0),
+	SND_SOC_DAPM_PGA("Mixin PGA", DA7219_MIXIN_L_CTRL,
+			 DA7219_MIXIN_L_AMP_EN_SHIFT, DA7219_NO_INVERT,
+			 NULL, 0),
+
+	/* Input Filters */
+	SND_SOC_DAPM_ADC("ADC", NULL, DA7219_ADC_L_CTRL, DA7219_ADC_L_EN_SHIFT,
+			 DA7219_NO_INVERT),
+
+	/* Tone Generator */
+	SND_SOC_DAPM_SIGGEN("TONE"),
+	SND_SOC_DAPM_PGA("Tone Generator", DA7219_TONE_GEN_CFG1,
+			 DA7219_START_STOPN_SHIFT, DA7219_NO_INVERT, NULL, 0),
+
+	/* Sidetone Input */
+	SND_SOC_DAPM_ADC("Sidetone Filter", NULL, DA7219_SIDETONE_CTRL,
+			 DA7219_SIDETONE_EN_SHIFT, DA7219_NO_INVERT),
+
+	/* Input Mixer Supply */
+	SND_SOC_DAPM_SUPPLY("Mixer In Supply", DA7219_MIXIN_L_CTRL,
+			    DA7219_MIXIN_L_MIX_EN_SHIFT, DA7219_NO_INVERT,
+			    NULL, 0),
+
+	/* Input Mixer */
+	SND_SOC_DAPM_MIXER("Mixer In", SND_SOC_NOPM, 0, 0,
+			   da7219_mixin_controls,
+			   ARRAY_SIZE(da7219_mixin_controls)),
+
+	/* Input Muxes */
+	SND_SOC_DAPM_MUX("Out DAIL Mux", SND_SOC_NOPM, 0, 0,
+			 &da7219_out_dail_sel_mux),
+	SND_SOC_DAPM_MUX("Out DAIR Mux", SND_SOC_NOPM, 0, 0,
+			 &da7219_out_dair_sel_mux),
+
+	/* DAI Supply */
+	SND_SOC_DAPM_SUPPLY("DAI", DA7219_DAI_CTRL, DA7219_DAI_EN_SHIFT,
+			    DA7219_NO_INVERT, da7219_dai_event,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	/* DAI */
+	SND_SOC_DAPM_AIF_OUT("DAIOUT", "Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("DAIIN", "Playback", 0, SND_SOC_NOPM, 0, 0),
+
+	/* Output Muxes */
+	SND_SOC_DAPM_MUX("Out DACL Mux", SND_SOC_NOPM, 0, 0,
+			 &da7219_out_dacl_sel_mux),
+	SND_SOC_DAPM_MUX("Out DACR Mux", SND_SOC_NOPM, 0, 0,
+			 &da7219_out_dacr_sel_mux),
+
+	/* Output Mixers */
+	SND_SOC_DAPM_MIXER("Mixer Out FilterL", SND_SOC_NOPM, 0, 0,
+			   da7219_mixout_l_controls,
+			   ARRAY_SIZE(da7219_mixout_l_controls)),
+	SND_SOC_DAPM_MIXER("Mixer Out FilterR", SND_SOC_NOPM, 0, 0,
+			   da7219_mixout_r_controls,
+			   ARRAY_SIZE(da7219_mixout_r_controls)),
+
+	/* Sidetone Mixers */
+	SND_SOC_DAPM_MIXER("ST Mixer Out FilterL", SND_SOC_NOPM, 0, 0,
+			   da7219_st_out_filtl_mix_controls,
+			   ARRAY_SIZE(da7219_st_out_filtl_mix_controls)),
+	SND_SOC_DAPM_MIXER("ST Mixer Out FilterR", SND_SOC_NOPM, 0,
+			   0, da7219_st_out_filtr_mix_controls,
+			   ARRAY_SIZE(da7219_st_out_filtr_mix_controls)),
+
+	/* DACs */
+	SND_SOC_DAPM_DAC("DACL", NULL, DA7219_DAC_L_CTRL, DA7219_DAC_L_EN_SHIFT,
+			 DA7219_NO_INVERT),
+	SND_SOC_DAPM_DAC("DACR", NULL, DA7219_DAC_R_CTRL, DA7219_DAC_R_EN_SHIFT,
+			 DA7219_NO_INVERT),
+
+	/* Output PGAs */
+	SND_SOC_DAPM_PGA("Mixout Left PGA", DA7219_MIXOUT_L_CTRL,
+			 DA7219_MIXOUT_L_AMP_EN_SHIFT, DA7219_NO_INVERT,
+			 NULL, 0),
+	SND_SOC_DAPM_PGA("Mixout Right PGA", DA7219_MIXOUT_R_CTRL,
+			 DA7219_MIXOUT_R_AMP_EN_SHIFT, DA7219_NO_INVERT,
+			 NULL, 0),
+	SND_SOC_DAPM_PGA("Headphone Left PGA", DA7219_HP_L_CTRL,
+			 DA7219_HP_L_AMP_EN_SHIFT, DA7219_NO_INVERT, NULL, 0),
+	SND_SOC_DAPM_PGA("Headphone Right PGA", DA7219_HP_R_CTRL,
+			 DA7219_HP_R_AMP_EN_SHIFT, DA7219_NO_INVERT, NULL, 0),
+
+	/* Output Supplies */
+	SND_SOC_DAPM_SUPPLY("Charge Pump", DA7219_CP_CTRL, DA7219_CP_EN_SHIFT,
+			    DA7219_NO_INVERT, NULL, 0),
+
+	/* Outputs */
+	SND_SOC_DAPM_OUTPUT("HPL"),
+	SND_SOC_DAPM_OUTPUT("HPR"),
+};
+
+
+/*
+ * DAPM Mux Routes
+ */
+
+#define DA7219_OUT_DAI_MUX_ROUTES(name)			\
+	{name, "ADC", "Mixer In"},			\
+	{name, "Tone Generator", "Tone Generator"},	\
+	{name, "DAIL", "DAIOUT"},			\
+	{name, "DAIR", "DAIOUT"}
+
+#define DA7219_OUT_DAC_MUX_ROUTES(name)			\
+	{name, "ADC", "Mixer In"},			\
+	{name, "Tone Generator", "Tone Generator"},		\
+	{name, "DAIL", "DAIIN"},			\
+	{name, "DAIR", "DAIIN"}
+
+/*
+ * DAPM Mixer Routes
+ */
+
+#define DA7219_DMIX_ST_ROUTES(name)				\
+	{name, "Out FilterL Switch", "Mixer Out FilterL"},	\
+	{name, "Out FilterR Switch", "Mixer Out FilterR"},	\
+	{name, "Sidetone Switch", "Sidetone Filter"}
+
+
+/*
+ * DAPM audio route definition
+ */
+
+static const struct snd_soc_dapm_route da7219_audio_map[] = {
+	/* Input paths */
+	{"MIC", NULL, "Mic Bias"},
+	{"Mic PGA", NULL, "MIC"},
+	{"Mixin PGA", NULL, "Mic PGA"},
+	{"ADC", NULL, "Mixin PGA"},
+
+	{"Sidetone Filter", NULL, "ADC"},
+	{"Mixer In", NULL, "Mixer In Supply"},
+	{"Mixer In", "Mic Switch", "ADC"},
+
+	{"Tone Generator", NULL, "TONE"},
+
+	DA7219_OUT_DAI_MUX_ROUTES("Out DAIL Mux"),
+	DA7219_OUT_DAI_MUX_ROUTES("Out DAIR Mux"),
+
+	{"DAIOUT", NULL, "Out DAIL Mux"},
+	{"DAIOUT", NULL, "Out DAIR Mux"},
+	{"DAIOUT", NULL, "DAI"},
+
+	/* Output paths */
+	{"DAIIN", NULL, "DAI"},
+
+	DA7219_OUT_DAC_MUX_ROUTES("Out DACL Mux"),
+	DA7219_OUT_DAC_MUX_ROUTES("Out DACR Mux"),
+
+	{"Mixer Out FilterL", "DACL Switch", "Out DACL Mux"},
+	{"Mixer Out FilterR", "DACR Switch", "Out DACR Mux"},
+
+	DA7219_DMIX_ST_ROUTES("ST Mixer Out FilterL"),
+	DA7219_DMIX_ST_ROUTES("ST Mixer Out FilterR"),
+
+	{"DACL", NULL, "ST Mixer Out FilterL"},
+	{"DACR", NULL, "ST Mixer Out FilterR"},
+
+	{"Mixout Left PGA", NULL, "DACL"},
+	{"Mixout Right PGA", NULL, "DACR"},
+
+	{"Headphone Left PGA", NULL, "Mixout Left PGA"},
+	{"Headphone Right PGA", NULL, "Mixout Right PGA"},
+
+	{"HPL", NULL, "Headphone Left PGA"},
+	{"HPR", NULL, "Headphone Right PGA"},
+
+	{"HPL", NULL, "Charge Pump"},
+	{"HPR", NULL, "Charge Pump"},
+};
+
+
+/*
+ * DAI operations
+ */
+
+static int da7219_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+
+	if ((da7219->clk_src == clk_id) && (da7219->mclk_rate == freq))
+		return 0;
+
+	if (((freq < 2000000) && (freq != 32768)) || (freq > 54000000)) {
+		dev_err(codec_dai->dev, "Unsupported MCLK value %d\n",
+			freq);
+		return -EINVAL;
+	}
+
+	switch (clk_id) {
+	case DA7219_CLKSRC_MCLK_SQR:
+		snd_soc_update_bits(codec, DA7219_PLL_CTRL,
+				    DA7219_PLL_MCLK_SQR_EN_MASK,
+				    DA7219_PLL_MCLK_SQR_EN_MASK);
+		break;
+	case DA7219_CLKSRC_MCLK:
+		snd_soc_update_bits(codec, DA7219_PLL_CTRL,
+				    DA7219_PLL_MCLK_SQR_EN_MASK, 0);
+		break;
+	default:
+		dev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);
+		return -EINVAL;
+	}
+
+	da7219->clk_src = clk_id;
+
+	if (da7219->mclk) {
+		freq = clk_round_rate(da7219->mclk, freq);
+		ret = clk_set_rate(da7219->mclk, freq);
+		if (ret) {
+			dev_err(codec_dai->dev, "Failed to set clock rate %d\n",
+				freq);
+			return ret;
+		}
+	}
+
+	da7219->mclk_rate = freq;
+
+	return 0;
+}
+
+static int da7219_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
+			      int source, unsigned int fref, unsigned int fout)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	u8 pll_ctrl, indiv_bits, indiv;
+	u8 pll_frac_top, pll_frac_bot, pll_integer;
+	u32 freq_ref;
+	u64 frac_div;
+
+	/* Verify 32KHz, 2MHz - 54MHz MCLK provided, and set input divider */
+	if (da7219->mclk_rate == 32768) {
+		indiv_bits = DA7219_PLL_INDIV_2_5_MHZ;
+		indiv = DA7219_PLL_INDIV_2_5_MHZ_VAL;
+	} else if (da7219->mclk_rate < 2000000) {
+		dev_err(codec->dev, "PLL input clock %d below valid range\n",
+			da7219->mclk_rate);
+		return -EINVAL;
+	} else if (da7219->mclk_rate <= 5000000) {
+		indiv_bits = DA7219_PLL_INDIV_2_5_MHZ;
+		indiv = DA7219_PLL_INDIV_2_5_MHZ_VAL;
+	} else if (da7219->mclk_rate <= 10000000) {
+		indiv_bits = DA7219_PLL_INDIV_5_10_MHZ;
+		indiv = DA7219_PLL_INDIV_5_10_MHZ_VAL;
+	} else if (da7219->mclk_rate <= 20000000) {
+		indiv_bits = DA7219_PLL_INDIV_10_20_MHZ;
+		indiv = DA7219_PLL_INDIV_10_20_MHZ_VAL;
+	} else if (da7219->mclk_rate <= 40000000) {
+		indiv_bits = DA7219_PLL_INDIV_20_40_MHZ;
+		indiv = DA7219_PLL_INDIV_20_40_MHZ_VAL;
+	} else if (da7219->mclk_rate <= 54000000) {
+		indiv_bits = DA7219_PLL_INDIV_40_54_MHZ;
+		indiv = DA7219_PLL_INDIV_40_54_MHZ_VAL;
+	} else {
+		dev_err(codec->dev, "PLL input clock %d above valid range\n",
+			da7219->mclk_rate);
+		return -EINVAL;
+	}
+	freq_ref = (da7219->mclk_rate / indiv);
+	pll_ctrl = indiv_bits;
+
+	/* Configure PLL */
+	switch (source) {
+	case DA7219_SYSCLK_MCLK:
+		pll_ctrl |= DA7219_PLL_MODE_BYPASS;
+		snd_soc_update_bits(codec, DA7219_PLL_CTRL,
+				    DA7219_PLL_INDIV_MASK |
+				    DA7219_PLL_MODE_MASK, pll_ctrl);
+		return 0;
+	case DA7219_SYSCLK_PLL:
+		pll_ctrl |= DA7219_PLL_MODE_NORMAL;
+		break;
+	case DA7219_SYSCLK_PLL_SRM:
+		pll_ctrl |= DA7219_PLL_MODE_SRM;
+		break;
+	case DA7219_SYSCLK_PLL_32KHZ:
+		pll_ctrl |= DA7219_PLL_MODE_32KHZ;
+		break;
+	default:
+		dev_err(codec->dev, "Invalid PLL config\n");
+		return -EINVAL;
+	}
+
+	/* Calculate dividers for PLL */
+	pll_integer = fout / freq_ref;
+	frac_div = (u64)(fout % freq_ref) * 8192ULL;
+	do_div(frac_div, freq_ref);
+	pll_frac_top = (frac_div >> DA7219_BYTE_SHIFT) & DA7219_BYTE_MASK;
+	pll_frac_bot = (frac_div) & DA7219_BYTE_MASK;
+
+	/* Write PLL config & dividers */
+	snd_soc_write(codec, DA7219_PLL_FRAC_TOP, pll_frac_top);
+	snd_soc_write(codec, DA7219_PLL_FRAC_BOT, pll_frac_bot);
+	snd_soc_write(codec, DA7219_PLL_INTEGER, pll_integer);
+	snd_soc_update_bits(codec, DA7219_PLL_CTRL,
+			    DA7219_PLL_INDIV_MASK | DA7219_PLL_MODE_MASK,
+			    pll_ctrl);
+
+	return 0;
+}
+
+static int da7219_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	u8 dai_clk_mode = 0, dai_ctrl = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		da7219->master = true;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		da7219->master = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		dai_clk_mode |= DA7219_DAI_WCLK_POL_INV;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dai_clk_mode |= DA7219_DAI_CLK_POL_INV;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dai_clk_mode |= DA7219_DAI_WCLK_POL_INV |
+				DA7219_DAI_CLK_POL_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dai_ctrl |= DA7219_DAI_FORMAT_I2S;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dai_ctrl |= DA7219_DAI_FORMAT_LEFT_J;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		dai_ctrl |= DA7219_DAI_FORMAT_RIGHT_J;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		dai_ctrl |= DA7219_DAI_FORMAT_DSP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* By default 64 BCLKs per WCLK is supported */
+	dai_clk_mode |= DA7219_DAI_BCLKS_PER_WCLK_64;
+
+	snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
+			    DA7219_DAI_BCLKS_PER_WCLK_MASK |
+			    DA7219_DAI_CLK_POL_MASK | DA7219_DAI_WCLK_POL_MASK,
+			    dai_clk_mode);
+	snd_soc_update_bits(codec, DA7219_DAI_CTRL, DA7219_DAI_FORMAT_MASK,
+			    dai_ctrl);
+
+	return 0;
+}
+
+static int da7219_set_dai_tdm_slot(struct snd_soc_dai *dai,
+				   unsigned int tx_mask, unsigned int rx_mask,
+				   int slots, int slot_width)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	u8 dai_bclks_per_wclk;
+	u16 offset;
+	u32 frame_size;
+
+	/* No channels enabled so disable TDM, revert to 64-bit frames */
+	if (!tx_mask) {
+		snd_soc_update_bits(codec, DA7219_DAI_TDM_CTRL,
+				    DA7219_DAI_TDM_CH_EN_MASK |
+				    DA7219_DAI_TDM_MODE_EN_MASK, 0);
+		snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
+				    DA7219_DAI_BCLKS_PER_WCLK_MASK,
+				    DA7219_DAI_BCLKS_PER_WCLK_64);
+		return 0;
+	}
+
+	/* Check we have valid slots */
+	if (fls(tx_mask) > DA7219_DAI_TDM_MAX_SLOTS) {
+		dev_err(codec->dev, "Invalid number of slots, max = %d\n",
+			DA7219_DAI_TDM_MAX_SLOTS);
+		return -EINVAL;
+	}
+
+	/* Check we have a valid offset given */
+	if (rx_mask > DA7219_DAI_OFFSET_MAX) {
+		dev_err(codec->dev, "Invalid slot offset, max = %d\n",
+			DA7219_DAI_OFFSET_MAX);
+		return -EINVAL;
+	}
+
+	/* Calculate & validate frame size based on slot info provided. */
+	frame_size = slots * slot_width;
+	switch (frame_size) {
+	case 32:
+		dai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_32;
+		break;
+	case 64:
+		dai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_64;
+		break;
+	case 128:
+		dai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_128;
+		break;
+	case 256:
+		dai_bclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_256;
+		break;
+	default:
+		dev_err(codec->dev, "Invalid frame size %d\n", frame_size);
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
+			    DA7219_DAI_BCLKS_PER_WCLK_MASK,
+			    dai_bclks_per_wclk);
+
+	offset = cpu_to_le16(rx_mask);
+	regmap_bulk_write(da7219->regmap, DA7219_DAI_OFFSET_LOWER,
+			  &offset, sizeof(offset));
+
+	snd_soc_update_bits(codec, DA7219_DAI_TDM_CTRL,
+			    DA7219_DAI_TDM_CH_EN_MASK |
+			    DA7219_DAI_TDM_MODE_EN_MASK,
+			    (tx_mask << DA7219_DAI_TDM_CH_EN_SHIFT) |
+			    DA7219_DAI_TDM_MODE_EN_MASK);
+
+	return 0;
+}
+
+static int da7219_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u8 dai_ctrl = 0, fs;
+	unsigned int channels;
+
+	switch (params_width(params)) {
+	case 16:
+		dai_ctrl |= DA7219_DAI_WORD_LENGTH_S16_LE;
+		break;
+	case 20:
+		dai_ctrl |= DA7219_DAI_WORD_LENGTH_S20_LE;
+		break;
+	case 24:
+		dai_ctrl |= DA7219_DAI_WORD_LENGTH_S24_LE;
+		break;
+	case 32:
+		dai_ctrl |= DA7219_DAI_WORD_LENGTH_S32_LE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	channels = params_channels(params);
+	if ((channels < 1) | (channels > DA7219_DAI_CH_NUM_MAX)) {
+		dev_err(codec->dev,
+			"Invalid number of channels, only 1 to %d supported\n",
+			DA7219_DAI_CH_NUM_MAX);
+		return -EINVAL;
+	}
+	dai_ctrl |= channels << DA7219_DAI_CH_NUM_SHIFT;
+
+	switch (params_rate(params)) {
+	case 8000:
+		fs = DA7219_SR_8000;
+		break;
+	case 11025:
+		fs = DA7219_SR_11025;
+		break;
+	case 12000:
+		fs = DA7219_SR_12000;
+		break;
+	case 16000:
+		fs = DA7219_SR_16000;
+		break;
+	case 22050:
+		fs = DA7219_SR_22050;
+		break;
+	case 24000:
+		fs = DA7219_SR_24000;
+		break;
+	case 32000:
+		fs = DA7219_SR_32000;
+		break;
+	case 44100:
+		fs = DA7219_SR_44100;
+		break;
+	case 48000:
+		fs = DA7219_SR_48000;
+		break;
+	case 88200:
+		fs = DA7219_SR_88200;
+		break;
+	case 96000:
+		fs = DA7219_SR_96000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, DA7219_DAI_CTRL,
+			    DA7219_DAI_WORD_LENGTH_MASK |
+			    DA7219_DAI_CH_NUM_MASK,
+			    dai_ctrl);
+	snd_soc_write(codec, DA7219_SR, fs);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops da7219_dai_ops = {
+	.hw_params	= da7219_hw_params,
+	.set_sysclk	= da7219_set_dai_sysclk,
+	.set_pll	= da7219_set_dai_pll,
+	.set_fmt	= da7219_set_dai_fmt,
+	.set_tdm_slot	= da7219_set_dai_tdm_slot,
+};
+
+#define DA7219_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver da7219_dai = {
+	.name = "da7219-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = DA7219_DAI_CH_NUM_MAX,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = DA7219_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = DA7219_DAI_CH_NUM_MAX,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = DA7219_FORMATS,
+	},
+	.ops = &da7219_dai_ops,
+	.symmetric_rates = 1,
+	.symmetric_channels = 1,
+	.symmetric_samplebits = 1,
+};
+
+
+/*
+ * DT
+ */
+
+static const struct of_device_id da7219_of_match[] = {
+	{ .compatible = "dlg,da7219", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, da7219_of_match);
+
+static enum da7219_ldo_lvl_sel da7219_of_ldo_lvl(struct snd_soc_codec *codec,
+						 u32 val)
+{
+	switch (val) {
+	case 1050:
+		return DA7219_LDO_LVL_SEL_1_05V;
+	case 1100:
+		return DA7219_LDO_LVL_SEL_1_10V;
+	case 1200:
+		return DA7219_LDO_LVL_SEL_1_20V;
+	case 1400:
+		return DA7219_LDO_LVL_SEL_1_40V;
+	default:
+		dev_warn(codec->dev, "Invalid LDO level");
+		return DA7219_LDO_LVL_SEL_1_05V;
+	}
+}
+
+static enum da7219_micbias_voltage
+	da7219_of_micbias_lvl(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1800:
+		return DA7219_MICBIAS_1_8V;
+	case 2000:
+		return DA7219_MICBIAS_2_0V;
+	case 2200:
+		return DA7219_MICBIAS_2_2V;
+	case 2400:
+		return DA7219_MICBIAS_2_4V;
+	case 2600:
+		return DA7219_MICBIAS_2_6V;
+	default:
+		dev_warn(codec->dev, "Invalid micbias level");
+		return DA7219_MICBIAS_2_2V;
+	}
+}
+
+static enum da7219_mic_amp_in_sel
+	da7219_of_mic_amp_in_sel(struct snd_soc_codec *codec, const char *str)
+{
+	if (!strcmp(str, "diff")) {
+		return DA7219_MIC_AMP_IN_SEL_DIFF;
+	} else if (!strcmp(str, "se_p")) {
+		return DA7219_MIC_AMP_IN_SEL_SE_P;
+	} else if (!strcmp(str, "se_n")) {
+		return DA7219_MIC_AMP_IN_SEL_SE_N;
+	} else {
+		dev_warn(codec->dev, "Invalid mic input type selection");
+		return DA7219_MIC_AMP_IN_SEL_DIFF;
+	}
+}
+
+static struct da7219_pdata *da7219_of_to_pdata(struct snd_soc_codec *codec)
+{
+	struct device_node *np = codec->dev->of_node;
+	struct da7219_pdata *pdata;
+	const char *of_str;
+	u32 of_val32;
+
+	pdata = devm_kzalloc(codec->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	if (of_property_read_u32(np, "dlg,ldo-lvl", &of_val32) >= 0)
+		pdata->ldo_lvl_sel = da7219_of_ldo_lvl(codec, of_val32);
+
+	if (of_property_read_u32(np, "dlg,micbias-lvl", &of_val32) >= 0)
+		pdata->micbias_lvl = da7219_of_micbias_lvl(codec, of_val32);
+	else
+		pdata->micbias_lvl = DA7219_MICBIAS_2_2V;
+
+	if (!of_property_read_string(np, "dlg,mic-amp-in-sel", &of_str))
+		pdata->mic_amp_in_sel = da7219_of_mic_amp_in_sel(codec, of_str);
+	else
+		pdata->mic_amp_in_sel = DA7219_MIC_AMP_IN_SEL_DIFF;
+
+	return pdata;
+}
+
+
+/*
+ * Codec driver functions
+ */
+
+static int da7219_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
+			/* MCLK */
+			clk_prepare_enable(da7219->mclk);
+
+			/* Master bias */
+			snd_soc_update_bits(codec, DA7219_REFERENCES,
+					    DA7219_BIAS_EN_MASK,
+					    DA7219_BIAS_EN_MASK);
+
+			/* Enable Internal Digital LDO */
+			snd_soc_update_bits(codec, DA7219_LDO_CTRL,
+					    DA7219_LDO_EN_MASK,
+					    DA7219_LDO_EN_MASK);
+		}
+		break;
+	case SND_SOC_BIAS_OFF:
+		/* Only disable if jack detection not active */
+		if (!da7219->aad->jack) {
+			/* Bypass Internal Digital LDO */
+			snd_soc_update_bits(codec, DA7219_LDO_CTRL,
+					    DA7219_LDO_EN_MASK, 0);
+
+			/* Master bias */
+			snd_soc_update_bits(codec, DA7219_REFERENCES,
+					    DA7219_BIAS_EN_MASK, 0);
+		}
+
+		/* MCLK */
+		clk_disable_unprepare(da7219->mclk);
+		break;
+	}
+
+	return 0;
+}
+
+static const char *da7219_supply_names[DA7219_NUM_SUPPLIES] = {
+	[DA7219_SUPPLY_VDD] = "VDD",
+	[DA7219_SUPPLY_VDDMIC] = "VDDMIC",
+	[DA7219_SUPPLY_VDDIO] = "VDDIO",
+};
+
+static int da7219_handle_supplies(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct regulator *vddio;
+	u8 io_voltage_lvl = DA7219_IO_VOLTAGE_LEVEL_2_5V_3_6V;
+	int i, ret;
+
+	/* Get required supplies */
+	for (i = 0; i < DA7219_NUM_SUPPLIES; ++i)
+		da7219->supplies[i].supply = da7219_supply_names[i];
+
+	ret = devm_regulator_bulk_get(codec->dev, DA7219_NUM_SUPPLIES,
+				      da7219->supplies);
+	if (ret)
+		return ret;
+
+	/* Determine VDDIO voltage provided */
+	vddio = da7219->supplies[DA7219_SUPPLY_VDDIO].consumer;
+	ret = regulator_get_voltage(vddio);
+	if (ret < 1200000)
+		dev_warn(codec->dev, "Invalid VDDIO voltage\n");
+	else if (ret < 2800000)
+		io_voltage_lvl = DA7219_IO_VOLTAGE_LEVEL_1_2V_2_8V;
+
+	/* Enable main supplies */
+	ret = regulator_bulk_enable(DA7219_NUM_SUPPLIES, da7219->supplies);
+
+	/* Ensure device in active mode */
+	snd_soc_write(codec, DA7219_SYSTEM_ACTIVE, DA7219_SYSTEM_ACTIVE_MASK);
+
+	/* Update IO voltage level range */
+	snd_soc_write(codec, DA7219_IO_CTRL, io_voltage_lvl);
+
+	return ret;
+}
+
+static void da7219_handle_pdata(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_pdata *pdata = da7219->pdata;
+
+	if (pdata) {
+		u8 micbias_lvl = 0;
+
+		/* Internal LDO */
+		switch (pdata->ldo_lvl_sel) {
+		case DA7219_LDO_LVL_SEL_1_05V:
+		case DA7219_LDO_LVL_SEL_1_10V:
+		case DA7219_LDO_LVL_SEL_1_20V:
+		case DA7219_LDO_LVL_SEL_1_40V:
+			snd_soc_update_bits(codec, DA7219_LDO_CTRL,
+					    DA7219_LDO_LEVEL_SELECT_MASK,
+					    (pdata->ldo_lvl_sel <<
+					     DA7219_LDO_LEVEL_SELECT_SHIFT));
+			break;
+		}
+
+		/* Mic Bias voltages */
+		switch (pdata->micbias_lvl) {
+		case DA7219_MICBIAS_1_8V:
+		case DA7219_MICBIAS_2_0V:
+		case DA7219_MICBIAS_2_2V:
+		case DA7219_MICBIAS_2_4V:
+		case DA7219_MICBIAS_2_6V:
+			micbias_lvl |= (pdata->micbias_lvl <<
+					DA7219_MICBIAS1_LEVEL_SHIFT);
+			break;
+		}
+
+		snd_soc_write(codec, DA7219_MICBIAS_CTRL, micbias_lvl);
+
+		/* Mic */
+		switch (pdata->mic_amp_in_sel) {
+		case DA7219_MIC_AMP_IN_SEL_DIFF:
+		case DA7219_MIC_AMP_IN_SEL_SE_P:
+		case DA7219_MIC_AMP_IN_SEL_SE_N:
+			snd_soc_write(codec, DA7219_MIC_1_SELECT,
+				      pdata->mic_amp_in_sel);
+			break;
+		}
+	}
+}
+
+static int da7219_probe(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	mutex_init(&da7219->lock);
+
+	/* Regulator configuration */
+	ret = da7219_handle_supplies(codec);
+	if (ret)
+		return ret;
+
+	/* Handle DT/Platform data */
+	if (codec->dev->of_node)
+		da7219->pdata = da7219_of_to_pdata(codec);
+	else
+		da7219->pdata = dev_get_platdata(codec->dev);
+
+	da7219_handle_pdata(codec);
+
+	/* Check if MCLK provided */
+	da7219->mclk = devm_clk_get(codec->dev, "mclk");
+	if (IS_ERR(da7219->mclk)) {
+		if (PTR_ERR(da7219->mclk) != -ENOENT)
+			return PTR_ERR(da7219->mclk);
+		else
+			da7219->mclk = NULL;
+	}
+
+	/* Default PC counter to free-running */
+	snd_soc_update_bits(codec, DA7219_PC_COUNT, DA7219_PC_FREERUN_MASK,
+			    DA7219_PC_FREERUN_MASK);
+
+	/* Default gain ramping */
+	snd_soc_update_bits(codec, DA7219_MIXIN_L_CTRL,
+			    DA7219_MIXIN_L_AMP_RAMP_EN_MASK,
+			    DA7219_MIXIN_L_AMP_RAMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_ADC_L_CTRL, DA7219_ADC_L_RAMP_EN_MASK,
+			    DA7219_ADC_L_RAMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_DAC_L_CTRL, DA7219_DAC_L_RAMP_EN_MASK,
+			    DA7219_DAC_L_RAMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_DAC_R_CTRL, DA7219_DAC_R_RAMP_EN_MASK,
+			    DA7219_DAC_R_RAMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+			    DA7219_HP_L_AMP_RAMP_EN_MASK,
+			    DA7219_HP_L_AMP_RAMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+			    DA7219_HP_R_AMP_RAMP_EN_MASK,
+			    DA7219_HP_R_AMP_RAMP_EN_MASK);
+
+	/* Default infinite tone gen, start/stop by Kcontrol */
+	snd_soc_write(codec, DA7219_TONE_GEN_CYCLES, DA7219_BEEP_CYCLES_MASK);
+
+	/* Initialise AAD block */
+	return da7219_aad_init(codec);
+}
+
+static int da7219_remove(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	da7219_aad_exit(codec);
+
+	/* Supplies */
+	return regulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);
+}
+
+#ifdef CONFIG_PM
+static int da7219_suspend(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	snd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	/* Put device into standby mode if jack detection disabled */
+	if (!da7219->aad->jack)
+		snd_soc_write(codec, DA7219_SYSTEM_ACTIVE, 0);
+
+	return 0;
+}
+
+static int da7219_resume(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	/* Put device into active mode if previously pushed to standby */
+	if (!da7219->aad->jack)
+		snd_soc_write(codec, DA7219_SYSTEM_ACTIVE,
+			      DA7219_SYSTEM_ACTIVE_MASK);
+
+	snd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+#else
+#define da7219_suspend NULL
+#define da7219_resume NULL
+#endif
+
+static struct snd_soc_codec_driver soc_codec_dev_da7219 = {
+	.probe			= da7219_probe,
+	.remove			= da7219_remove,
+	.suspend		= da7219_suspend,
+	.resume			= da7219_resume,
+	.set_bias_level		= da7219_set_bias_level,
+
+	.controls		= da7219_snd_controls,
+	.num_controls		= ARRAY_SIZE(da7219_snd_controls),
+
+	.dapm_widgets		= da7219_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(da7219_dapm_widgets),
+	.dapm_routes		= da7219_audio_map,
+	.num_dapm_routes	= ARRAY_SIZE(da7219_audio_map),
+};
+
+
+/*
+ * Regmap configs
+ */
+
+static struct reg_default da7219_reg_defaults[] = {
+	{ DA7219_MIC_1_SELECT, 0x00 },
+	{ DA7219_CIF_TIMEOUT_CTRL, 0x01 },
+	{ DA7219_SR_24_48, 0x00 },
+	{ DA7219_SR, 0x0A },
+	{ DA7219_CIF_I2C_ADDR_CFG, 0x02 },
+	{ DA7219_PLL_CTRL, 0x10 },
+	{ DA7219_PLL_FRAC_TOP, 0x00 },
+	{ DA7219_PLL_FRAC_BOT, 0x00 },
+	{ DA7219_PLL_INTEGER, 0x20 },
+	{ DA7219_DIG_ROUTING_DAI, 0x10 },
+	{ DA7219_DAI_CLK_MODE, 0x01 },
+	{ DA7219_DAI_CTRL, 0x28 },
+	{ DA7219_DAI_TDM_CTRL, 0x40 },
+	{ DA7219_DIG_ROUTING_DAC, 0x32 },
+	{ DA7219_DAI_OFFSET_LOWER, 0x00 },
+	{ DA7219_DAI_OFFSET_UPPER, 0x00 },
+	{ DA7219_REFERENCES, 0x00 },
+	{ DA7219_MIXIN_L_SELECT, 0x00 },
+	{ DA7219_MIXIN_L_GAIN, 0x03 },
+	{ DA7219_ADC_L_GAIN, 0x6F },
+	{ DA7219_ADC_FILTERS1, 0x80 },
+	{ DA7219_MIC_1_GAIN, 0x01 },
+	{ DA7219_SIDETONE_CTRL, 0x40 },
+	{ DA7219_SIDETONE_GAIN, 0x0E },
+	{ DA7219_DROUTING_ST_OUTFILT_1L, 0x01 },
+	{ DA7219_DROUTING_ST_OUTFILT_1R, 0x02 },
+	{ DA7219_DAC_FILTERS5, 0x00 },
+	{ DA7219_DAC_FILTERS2, 0x88 },
+	{ DA7219_DAC_FILTERS3, 0x88 },
+	{ DA7219_DAC_FILTERS4, 0x08 },
+	{ DA7219_DAC_FILTERS1, 0x80 },
+	{ DA7219_DAC_L_GAIN, 0x6F },
+	{ DA7219_DAC_R_GAIN, 0x6F },
+	{ DA7219_CP_CTRL, 0x20 },
+	{ DA7219_HP_L_GAIN, 0x39 },
+	{ DA7219_HP_R_GAIN, 0x39 },
+	{ DA7219_MIXOUT_L_SELECT, 0x00 },
+	{ DA7219_MIXOUT_R_SELECT, 0x00 },
+	{ DA7219_MICBIAS_CTRL, 0x03 },
+	{ DA7219_MIC_1_CTRL, 0x40 },
+	{ DA7219_MIXIN_L_CTRL, 0x40 },
+	{ DA7219_ADC_L_CTRL, 0x40 },
+	{ DA7219_DAC_L_CTRL, 0x40 },
+	{ DA7219_DAC_R_CTRL, 0x40 },
+	{ DA7219_HP_L_CTRL, 0x40 },
+	{ DA7219_HP_R_CTRL, 0x40 },
+	{ DA7219_MIXOUT_L_CTRL, 0x10 },
+	{ DA7219_MIXOUT_R_CTRL, 0x10 },
+	{ DA7219_CHIP_ID1, 0x23 },
+	{ DA7219_CHIP_ID2, 0x93 },
+	{ DA7219_CHIP_REVISION, 0x00 },
+	{ DA7219_LDO_CTRL, 0x00 },
+	{ DA7219_IO_CTRL, 0x00 },
+	{ DA7219_GAIN_RAMP_CTRL, 0x00 },
+	{ DA7219_PC_COUNT, 0x02 },
+	{ DA7219_CP_VOL_THRESHOLD1, 0x0E },
+	{ DA7219_DIG_CTRL, 0x00 },
+	{ DA7219_ALC_CTRL2, 0x00 },
+	{ DA7219_ALC_CTRL3, 0x00 },
+	{ DA7219_ALC_NOISE, 0x3F },
+	{ DA7219_ALC_TARGET_MIN, 0x3F },
+	{ DA7219_ALC_TARGET_MAX, 0x00 },
+	{ DA7219_ALC_GAIN_LIMITS, 0xFF },
+	{ DA7219_ALC_ANA_GAIN_LIMITS, 0x71 },
+	{ DA7219_ALC_ANTICLIP_CTRL, 0x00 },
+	{ DA7219_ALC_ANTICLIP_LEVEL, 0x00 },
+	{ DA7219_DAC_NG_SETUP_TIME, 0x00 },
+	{ DA7219_DAC_NG_OFF_THRESH, 0x00 },
+	{ DA7219_DAC_NG_ON_THRESH, 0x00 },
+	{ DA7219_DAC_NG_CTRL, 0x00 },
+	{ DA7219_TONE_GEN_CFG1, 0x00 },
+	{ DA7219_TONE_GEN_CFG2, 0x00 },
+	{ DA7219_TONE_GEN_CYCLES, 0x00 },
+	{ DA7219_TONE_GEN_FREQ1_L, 0x55 },
+	{ DA7219_TONE_GEN_FREQ1_U, 0x15 },
+	{ DA7219_TONE_GEN_FREQ2_L, 0x00 },
+	{ DA7219_TONE_GEN_FREQ2_U, 0x40 },
+	{ DA7219_TONE_GEN_ON_PER, 0x02 },
+	{ DA7219_TONE_GEN_OFF_PER, 0x01 },
+	{ DA7219_ACCDET_IRQ_MASK_A, 0x00 },
+	{ DA7219_ACCDET_IRQ_MASK_B, 0x00 },
+	{ DA7219_ACCDET_CONFIG_1, 0xD6 },
+	{ DA7219_ACCDET_CONFIG_2, 0x34 },
+	{ DA7219_ACCDET_CONFIG_3, 0x0A },
+	{ DA7219_ACCDET_CONFIG_4, 0x16 },
+	{ DA7219_ACCDET_CONFIG_5, 0x21 },
+	{ DA7219_ACCDET_CONFIG_6, 0x3E },
+	{ DA7219_ACCDET_CONFIG_7, 0x01 },
+	{ DA7219_SYSTEM_ACTIVE, 0x00 },
+};
+
+static bool da7219_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case DA7219_MIC_1_GAIN_STATUS:
+	case DA7219_MIXIN_L_GAIN_STATUS:
+	case DA7219_ADC_L_GAIN_STATUS:
+	case DA7219_DAC_L_GAIN_STATUS:
+	case DA7219_DAC_R_GAIN_STATUS:
+	case DA7219_HP_L_GAIN_STATUS:
+	case DA7219_HP_R_GAIN_STATUS:
+	case DA7219_CIF_CTRL:
+	case DA7219_PLL_SRM_STS:
+	case DA7219_ALC_CTRL1:
+	case DA7219_SYSTEM_MODES_INPUT:
+	case DA7219_SYSTEM_MODES_OUTPUT:
+	case DA7219_ALC_OFFSET_AUTO_M_L:
+	case DA7219_ALC_OFFSET_AUTO_U_L:
+	case DA7219_TONE_GEN_CFG1:
+	case DA7219_ACCDET_STATUS_A:
+	case DA7219_ACCDET_STATUS_B:
+	case DA7219_ACCDET_IRQ_EVENT_A:
+	case DA7219_ACCDET_IRQ_EVENT_B:
+	case DA7219_ACCDET_CONFIG_8:
+	case DA7219_SYSTEM_STATUS:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static const struct regmap_config da7219_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = DA7219_SYSTEM_ACTIVE,
+	.reg_defaults = da7219_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(da7219_reg_defaults),
+	.volatile_reg = da7219_volatile_register,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+
+/*
+ * I2C layer
+ */
+
+static int da7219_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct da7219_priv *da7219;
+	int ret;
+
+	da7219 = devm_kzalloc(&i2c->dev, sizeof(struct da7219_priv),
+			      GFP_KERNEL);
+	if (!da7219)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, da7219);
+
+	da7219->regmap = devm_regmap_init_i2c(i2c, &da7219_regmap_config);
+	if (IS_ERR(da7219->regmap)) {
+		ret = PTR_ERR(da7219->regmap);
+		dev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_da7219,
+				     &da7219_dai, 1);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "Failed to register da7219 codec: %d\n",
+			ret);
+	}
+	return ret;
+}
+
+static int da7219_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id da7219_i2c_id[] = {
+	{ "da7219", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, da7219_i2c_id);
+
+static struct i2c_driver da7219_i2c_driver = {
+	.driver = {
+		.name = "da7219",
+		.of_match_table = da7219_of_match,
+	},
+	.probe		= da7219_i2c_probe,
+	.remove		= da7219_i2c_remove,
+	.id_table	= da7219_i2c_id,
+};
+
+module_i2c_driver(da7219_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC DA7219 Codec Driver");
+MODULE_AUTHOR("Adam Thomson <Adam.Thomson.Opensource@diasemi.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/da7219.h b/sound/soc/codecs/da7219.h
new file mode 100644
index 000000000000..b514268c6c56
--- /dev/null
+++ b/sound/soc/codecs/da7219.h
@@ -0,0 +1,820 @@
+/*
+ * da7219.h - DA7219 ALSA SoC Codec Driver
+ *
+ * Copyright (c) 2015 Dialog Semiconductor
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __DA7219_H
+#define __DA7219_H
+
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <sound/da7219.h>
+
+/*
+ * Registers
+ */
+
+#define DA7219_MIC_1_GAIN_STATUS	0x6
+#define DA7219_MIXIN_L_GAIN_STATUS	0x8
+#define DA7219_ADC_L_GAIN_STATUS	0xA
+#define DA7219_DAC_L_GAIN_STATUS	0xC
+#define DA7219_DAC_R_GAIN_STATUS	0xD
+#define DA7219_HP_L_GAIN_STATUS		0xE
+#define DA7219_HP_R_GAIN_STATUS		0xF
+#define DA7219_MIC_1_SELECT		0x10
+#define DA7219_CIF_TIMEOUT_CTRL		0x12
+#define DA7219_CIF_CTRL			0x13
+#define DA7219_SR_24_48			0x16
+#define DA7219_SR			0x17
+#define DA7219_CIF_I2C_ADDR_CFG		0x1B
+#define DA7219_PLL_CTRL			0x20
+#define DA7219_PLL_FRAC_TOP		0x22
+#define DA7219_PLL_FRAC_BOT		0x23
+#define DA7219_PLL_INTEGER		0x24
+#define DA7219_PLL_SRM_STS		0x25
+#define DA7219_DIG_ROUTING_DAI		0x2A
+#define DA7219_DAI_CLK_MODE		0x2B
+#define DA7219_DAI_CTRL			0x2C
+#define DA7219_DAI_TDM_CTRL		0x2D
+#define DA7219_DIG_ROUTING_DAC		0x2E
+#define DA7219_ALC_CTRL1		0x2F
+#define DA7219_DAI_OFFSET_LOWER		0x30
+#define DA7219_DAI_OFFSET_UPPER		0x31
+#define DA7219_REFERENCES		0x32
+#define DA7219_MIXIN_L_SELECT		0x33
+#define DA7219_MIXIN_L_GAIN		0x34
+#define DA7219_ADC_L_GAIN		0x36
+#define DA7219_ADC_FILTERS1		0x38
+#define DA7219_MIC_1_GAIN		0x39
+#define DA7219_SIDETONE_CTRL		0x3A
+#define DA7219_SIDETONE_GAIN		0x3B
+#define DA7219_DROUTING_ST_OUTFILT_1L	0x3C
+#define DA7219_DROUTING_ST_OUTFILT_1R	0x3D
+#define DA7219_DAC_FILTERS5		0x40
+#define DA7219_DAC_FILTERS2		0x41
+#define DA7219_DAC_FILTERS3		0x42
+#define DA7219_DAC_FILTERS4		0x43
+#define DA7219_DAC_FILTERS1		0x44
+#define DA7219_DAC_L_GAIN		0x45
+#define DA7219_DAC_R_GAIN		0x46
+#define DA7219_CP_CTRL			0x47
+#define DA7219_HP_L_GAIN		0x48
+#define DA7219_HP_R_GAIN		0x49
+#define DA7219_MIXOUT_L_SELECT		0x4B
+#define DA7219_MIXOUT_R_SELECT		0x4C
+#define DA7219_SYSTEM_MODES_INPUT	0x50
+#define DA7219_SYSTEM_MODES_OUTPUT	0x51
+#define DA7219_MICBIAS_CTRL		0x62
+#define DA7219_MIC_1_CTRL		0x63
+#define DA7219_MIXIN_L_CTRL		0x65
+#define DA7219_ADC_L_CTRL		0x67
+#define DA7219_DAC_L_CTRL		0x69
+#define DA7219_DAC_R_CTRL		0x6A
+#define DA7219_HP_L_CTRL		0x6B
+#define DA7219_HP_R_CTRL		0x6C
+#define DA7219_MIXOUT_L_CTRL		0x6E
+#define DA7219_MIXOUT_R_CTRL		0x6F
+#define DA7219_CHIP_ID1			0x81
+#define DA7219_CHIP_ID2			0x82
+#define DA7219_CHIP_REVISION		0x83
+#define DA7219_LDO_CTRL			0x90
+#define DA7219_IO_CTRL			0x91
+#define DA7219_GAIN_RAMP_CTRL		0x92
+#define DA7219_PC_COUNT			0x94
+#define DA7219_CP_VOL_THRESHOLD1	0x95
+#define DA7219_CP_DELAY			0x96
+#define DA7219_DIG_CTRL			0x99
+#define DA7219_ALC_CTRL2		0x9A
+#define DA7219_ALC_CTRL3		0x9B
+#define DA7219_ALC_NOISE		0x9C
+#define DA7219_ALC_TARGET_MIN		0x9D
+#define DA7219_ALC_TARGET_MAX		0x9E
+#define DA7219_ALC_GAIN_LIMITS		0x9F
+#define DA7219_ALC_ANA_GAIN_LIMITS	0xA0
+#define DA7219_ALC_ANTICLIP_CTRL	0xA1
+#define DA7219_ALC_ANTICLIP_LEVEL	0xA2
+#define DA7219_ALC_OFFSET_AUTO_M_L	0xA3
+#define DA7219_ALC_OFFSET_AUTO_U_L	0xA4
+#define DA7219_DAC_NG_SETUP_TIME	0xAF
+#define DA7219_DAC_NG_OFF_THRESH	0xB0
+#define DA7219_DAC_NG_ON_THRESH		0xB1
+#define DA7219_DAC_NG_CTRL		0xB2
+#define DA7219_TONE_GEN_CFG1		0xB4
+#define DA7219_TONE_GEN_CFG2		0xB5
+#define DA7219_TONE_GEN_CYCLES		0xB6
+#define DA7219_TONE_GEN_FREQ1_L		0xB7
+#define DA7219_TONE_GEN_FREQ1_U		0xB8
+#define DA7219_TONE_GEN_FREQ2_L		0xB9
+#define DA7219_TONE_GEN_FREQ2_U		0xBA
+#define DA7219_TONE_GEN_ON_PER		0xBB
+#define DA7219_TONE_GEN_OFF_PER		0xBC
+#define DA7219_SYSTEM_STATUS		0xE0
+#define DA7219_SYSTEM_ACTIVE		0xFD
+
+
+/*
+ * Bit Fields
+ */
+
+#define DA7219_SWITCH_EN_MAX		0x1
+
+/* DA7219_MIC_1_GAIN_STATUS = 0x6 */
+#define DA7219_MIC_1_AMP_GAIN_STATUS_SHIFT	0
+#define DA7219_MIC_1_AMP_GAIN_STATUS_MASK	(0x7 << 0)
+#define DA7219_MIC_1_AMP_GAIN_MAX		0x7
+
+/* DA7219_MIXIN_L_GAIN_STATUS = 0x8 */
+#define DA7219_MIXIN_L_AMP_GAIN_STATUS_SHIFT	0
+#define DA7219_MIXIN_L_AMP_GAIN_STATUS_MASK	(0xF << 0)
+
+/* DA7219_ADC_L_GAIN_STATUS = 0xA */
+#define DA7219_ADC_L_DIGITAL_GAIN_STATUS_SHIFT	0
+#define DA7219_ADC_L_DIGITAL_GAIN_STATUS_MASK	(0x7F << 0)
+
+/* DA7219_DAC_L_GAIN_STATUS = 0xC */
+#define DA7219_DAC_L_DIGITAL_GAIN_STATUS_SHIFT	0
+#define DA7219_DAC_L_DIGITAL_GAIN_STATUS_MASK	(0x7F << 0)
+
+/* DA7219_DAC_R_GAIN_STATUS = 0xD */
+#define DA7219_DAC_R_DIGITAL_GAIN_STATUS_SHIFT	0
+#define DA7219_DAC_R_DIGITAL_GAIN_STATUS_MASK	(0x7F << 0)
+
+/* DA7219_HP_L_GAIN_STATUS = 0xE */
+#define DA7219_HP_L_AMP_GAIN_STATUS_SHIFT	0
+#define DA7219_HP_L_AMP_GAIN_STATUS_MASK	(0x3F << 0)
+
+/* DA7219_HP_R_GAIN_STATUS = 0xF */
+#define DA7219_HP_R_AMP_GAIN_STATUS_SHIFT	0
+#define DA7219_HP_R_AMP_GAIN_STATUS_MASK	(0x3F << 0)
+
+/* DA7219_MIC_1_SELECT = 0x10 */
+#define DA7219_MIC_1_AMP_IN_SEL_SHIFT	0
+#define DA7219_MIC_1_AMP_IN_SEL_MASK	(0x3 << 0)
+
+/* DA7219_CIF_TIMEOUT_CTRL = 0x12 */
+#define DA7219_I2C_TIMEOUT_EN_SHIFT	0
+#define DA7219_I2C_TIMEOUT_EN_MASK	(0x1 << 0)
+
+/* DA7219_CIF_CTRL = 0x13 */
+#define DA7219_CIF_I2C_WRITE_MODE_SHIFT		0
+#define DA7219_CIF_I2C_WRITE_MODE_MASK		(0x1 << 0)
+#define DA7219_CIF_REG_SOFT_RESET_SHIFT		7
+#define DA7219_CIF_REG_SOFT_RESET_MASK		(0x1 << 7)
+
+/* DA7219_SR_24_48 = 0x16 */
+#define DA7219_SR_24_48_SHIFT	0
+#define DA7219_SR_24_48_MASK	(0x1 << 0)
+
+/* DA7219_SR = 0x17 */
+#define DA7219_SR_SHIFT		0
+#define DA7219_SR_MASK		(0xF << 0)
+#define DA7219_SR_8000		(0x01 << 0)
+#define DA7219_SR_11025		(0x02 << 0)
+#define DA7219_SR_12000		(0x03 << 0)
+#define DA7219_SR_16000		(0x05 << 0)
+#define DA7219_SR_22050		(0x06 << 0)
+#define DA7219_SR_24000		(0x07 << 0)
+#define DA7219_SR_32000		(0x09 << 0)
+#define DA7219_SR_44100		(0x0A << 0)
+#define DA7219_SR_48000		(0x0B << 0)
+#define DA7219_SR_88200		(0x0E << 0)
+#define DA7219_SR_96000		(0x0F << 0)
+
+/* DA7219_CIF_I2C_ADDR_CFG = 0x1B */
+#define DA7219_CIF_I2C_ADDR_CFG_SHIFT	0
+#define DA7219_CIF_I2C_ADDR_CFG_MASK	(0x3 << 0)
+
+/* DA7219_PLL_CTRL = 0x20 */
+#define DA7219_PLL_INDIV_SHIFT		2
+#define DA7219_PLL_INDIV_MASK		(0x7 << 2)
+#define DA7219_PLL_INDIV_2_5_MHZ	(0x0 << 2)
+#define DA7219_PLL_INDIV_5_10_MHZ	(0x1 << 2)
+#define DA7219_PLL_INDIV_10_20_MHZ	(0x2 << 2)
+#define DA7219_PLL_INDIV_20_40_MHZ	(0x3 << 2)
+#define DA7219_PLL_INDIV_40_54_MHZ	(0x4 << 2)
+#define DA7219_PLL_MCLK_SQR_EN_SHIFT	5
+#define DA7219_PLL_MCLK_SQR_EN_MASK	(0x1 << 5)
+#define DA7219_PLL_MODE_SHIFT		6
+#define DA7219_PLL_MODE_MASK		(0x3 << 6)
+#define DA7219_PLL_MODE_BYPASS		(0x0 << 6)
+#define DA7219_PLL_MODE_NORMAL		(0x1 << 6)
+#define DA7219_PLL_MODE_SRM		(0x2 << 6)
+#define DA7219_PLL_MODE_32KHZ		(0x3 << 6)
+
+/* DA7219_PLL_FRAC_TOP = 0x22 */
+#define DA7219_PLL_FBDIV_FRAC_TOP_SHIFT	0
+#define DA7219_PLL_FBDIV_FRAC_TOP_MASK	(0x1F << 0)
+
+/* DA7219_PLL_FRAC_BOT = 0x23 */
+#define DA7219_PLL_FBDIV_FRAC_BOT_SHIFT	0
+#define DA7219_PLL_FBDIV_FRAC_BOT_MASK	(0xFF << 0)
+
+/* DA7219_PLL_INTEGER = 0x24 */
+#define DA7219_PLL_FBDIV_INTEGER_SHIFT	0
+#define DA7219_PLL_FBDIV_INTEGER_MASK	(0x7F << 0)
+
+/* DA7219_PLL_SRM_STS = 0x25 */
+#define DA7219_PLL_SRM_STATE_SHIFT	0
+#define DA7219_PLL_SRM_STATE_MASK	(0xF << 0)
+#define DA7219_PLL_SRM_STATUS_SHIFT	4
+#define DA7219_PLL_SRM_STATUS_MASK	(0xF << 4)
+#define DA7219_PLL_SRM_STS_SRM_LOCK	(0x1 << 7)
+
+/* DA7219_DIG_ROUTING_DAI = 0x2A */
+#define DA7219_DAI_L_SRC_SHIFT	0
+#define DA7219_DAI_L_SRC_MASK	(0x3 << 0)
+#define DA7219_DAI_R_SRC_SHIFT	4
+#define DA7219_DAI_R_SRC_MASK	(0x3 << 4)
+#define DA7219_OUT_SRC_MAX	4
+
+/* DA7219_DAI_CLK_MODE = 0x2B */
+#define DA7219_DAI_BCLKS_PER_WCLK_SHIFT	0
+#define DA7219_DAI_BCLKS_PER_WCLK_MASK	(0x3 << 0)
+#define DA7219_DAI_BCLKS_PER_WCLK_32	(0x0 << 0)
+#define DA7219_DAI_BCLKS_PER_WCLK_64	(0x1 << 0)
+#define DA7219_DAI_BCLKS_PER_WCLK_128	(0x2 << 0)
+#define DA7219_DAI_BCLKS_PER_WCLK_256	(0x3 << 0)
+#define DA7219_DAI_CLK_POL_SHIFT	2
+#define DA7219_DAI_CLK_POL_MASK		(0x1 << 2)
+#define DA7219_DAI_CLK_POL_INV		(0x1 << 2)
+#define DA7219_DAI_WCLK_POL_SHIFT	3
+#define DA7219_DAI_WCLK_POL_MASK	(0x1 << 3)
+#define DA7219_DAI_WCLK_POL_INV		(0x1 << 3)
+#define DA7219_DAI_WCLK_TRI_STATE_SHIFT	4
+#define DA7219_DAI_WCLK_TRI_STATE_MASK	(0x1 << 4)
+#define DA7219_DAI_CLK_EN_SHIFT		7
+#define DA7219_DAI_CLK_EN_MASK		(0x1 << 7)
+
+/* DA7219_DAI_CTRL = 0x2C */
+#define DA7219_DAI_FORMAT_SHIFT		0
+#define DA7219_DAI_FORMAT_MASK		(0x3 << 0)
+#define DA7219_DAI_FORMAT_I2S		(0x0 << 0)
+#define DA7219_DAI_FORMAT_LEFT_J	(0x1 << 0)
+#define DA7219_DAI_FORMAT_RIGHT_J	(0x2 << 0)
+#define DA7219_DAI_FORMAT_DSP		(0x3 << 0)
+#define DA7219_DAI_WORD_LENGTH_SHIFT	2
+#define DA7219_DAI_WORD_LENGTH_MASK	(0x3 << 2)
+#define DA7219_DAI_WORD_LENGTH_S16_LE	(0x0 << 2)
+#define DA7219_DAI_WORD_LENGTH_S20_LE	(0x1 << 2)
+#define DA7219_DAI_WORD_LENGTH_S24_LE	(0x2 << 2)
+#define DA7219_DAI_WORD_LENGTH_S32_LE	(0x3 << 2)
+#define DA7219_DAI_CH_NUM_SHIFT		4
+#define DA7219_DAI_CH_NUM_MASK		(0x3 << 4)
+#define DA7219_DAI_CH_NUM_MAX		2
+#define DA7219_DAI_EN_SHIFT		7
+#define DA7219_DAI_EN_MASK		(0x1 << 7)
+
+/* DA7219_DAI_TDM_CTRL = 0x2D */
+#define DA7219_DAI_TDM_CH_EN_SHIFT	0
+#define DA7219_DAI_TDM_CH_EN_MASK	(0x3 << 0)
+#define DA7219_DAI_OE_SHIFT		6
+#define DA7219_DAI_OE_MASK		(0x1 << 6)
+#define DA7219_DAI_TDM_MODE_EN_SHIFT	7
+#define DA7219_DAI_TDM_MODE_EN_MASK	(0x1 << 7)
+#define DA7219_DAI_TDM_MAX_SLOTS	2
+
+/* DA7219_DIG_ROUTING_DAC = 0x2E */
+#define DA7219_DAC_L_SRC_SHIFT		0
+#define DA7219_DAC_L_SRC_MASK		(0x3 << 0)
+#define DA7219_DAC_L_SRC_TONEGEN	(0x1 << 0)
+#define DA7219_DAC_L_MONO_SHIFT		3
+#define DA7219_DAC_L_MONO_MASK		(0x1 << 3)
+#define DA7219_DAC_R_SRC_SHIFT		4
+#define DA7219_DAC_R_SRC_MASK		(0x3 << 4)
+#define DA7219_DAC_R_SRC_TONEGEN	(0x1 << 4)
+#define DA7219_DAC_R_MONO_SHIFT		7
+#define DA7219_DAC_R_MONO_MASK		(0x1 << 7)
+
+/* DA7219_ALC_CTRL1 = 0x2F */
+#define DA7219_ALC_OFFSET_EN_SHIFT	0
+#define DA7219_ALC_OFFSET_EN_MASK	(0x1 << 0)
+#define DA7219_ALC_SYNC_MODE_SHIFT	1
+#define DA7219_ALC_SYNC_MODE_MASK	(0x1 << 1)
+#define DA7219_ALC_EN_SHIFT		3
+#define DA7219_ALC_EN_MASK		(0x1 << 3)
+#define DA7219_ALC_AUTO_CALIB_EN_SHIFT	4
+#define DA7219_ALC_AUTO_CALIB_EN_MASK	(0x1 << 4)
+#define DA7219_ALC_CALIB_OVERFLOW_SHIFT	5
+#define DA7219_ALC_CALIB_OVERFLOW_MASK	(0x1 << 5)
+
+/* DA7219_DAI_OFFSET_LOWER = 0x30 */
+#define DA7219_DAI_OFFSET_LOWER_SHIFT	0
+#define DA7219_DAI_OFFSET_LOWER_MASK	(0xFF << 0)
+
+/* DA7219_DAI_OFFSET_UPPER = 0x31 */
+#define DA7219_DAI_OFFSET_UPPER_SHIFT	0
+#define DA7219_DAI_OFFSET_UPPER_MASK	(0x7 << 0)
+#define DA7219_DAI_OFFSET_MAX		0x2FF
+
+/* DA7219_REFERENCES = 0x32 */
+#define DA7219_BIAS_EN_SHIFT		3
+#define DA7219_BIAS_EN_MASK		(0x1 << 3)
+#define DA7219_VMID_FAST_CHARGE_SHIFT	4
+#define DA7219_VMID_FAST_CHARGE_MASK	(0x1 << 4)
+
+/* DA7219_MIXIN_L_SELECT = 0x33 */
+#define DA7219_MIXIN_L_MIX_SELECT_SHIFT	0
+#define DA7219_MIXIN_L_MIX_SELECT_MASK	(0x1 << 0)
+
+/* DA7219_MIXIN_L_GAIN = 0x34 */
+#define DA7219_MIXIN_L_AMP_GAIN_SHIFT	0
+#define DA7219_MIXIN_L_AMP_GAIN_MASK	(0xF << 0)
+#define DA7219_MIXIN_L_AMP_GAIN_MAX	0xF
+
+/* DA7219_ADC_L_GAIN = 0x36 */
+#define DA7219_ADC_L_DIGITAL_GAIN_SHIFT	0
+#define DA7219_ADC_L_DIGITAL_GAIN_MASK	(0x7F << 0)
+#define DA7219_ADC_L_DIGITAL_GAIN_MAX	0x7F
+
+/* DA7219_ADC_FILTERS1 = 0x38 */
+#define DA7219_ADC_VOICE_HPF_CORNER_SHIFT	0
+#define DA7219_ADC_VOICE_HPF_CORNER_MASK	(0x7 << 0)
+#define DA7219_VOICE_HPF_CORNER_MAX		8
+#define DA7219_ADC_VOICE_EN_SHIFT		3
+#define DA7219_ADC_VOICE_EN_MASK		(0x1 << 3)
+#define DA7219_ADC_AUDIO_HPF_CORNER_SHIFT	4
+#define DA7219_ADC_AUDIO_HPF_CORNER_MASK	(0x3 << 4)
+#define DA7219_AUDIO_HPF_CORNER_MAX		4
+#define DA7219_ADC_HPF_EN_SHIFT			7
+#define DA7219_ADC_HPF_EN_MASK			(0x1 << 7)
+#define DA7219_HPF_MODE_SHIFT			0
+#define DA7219_HPF_DISABLED			((0x0 << 3) | (0x0 << 7))
+#define DA7219_HPF_AUDIO_EN			((0x0 << 3) | (0x1 << 7))
+#define DA7219_HPF_VOICE_EN			((0x1 << 3) | (0x1 << 7))
+#define DA7219_HPF_MODE_MASK			((0x1 << 3) | (0x1 << 7))
+#define DA7219_HPF_MODE_MAX			3
+
+/* DA7219_MIC_1_GAIN = 0x39 */
+#define DA7219_MIC_1_AMP_GAIN_SHIFT	0
+#define DA7219_MIC_1_AMP_GAIN_MASK	(0x7 << 0)
+
+/* DA7219_SIDETONE_CTRL = 0x3A */
+#define DA7219_SIDETONE_MUTE_EN_SHIFT	6
+#define DA7219_SIDETONE_MUTE_EN_MASK	(0x1 << 6)
+#define DA7219_SIDETONE_EN_SHIFT	7
+#define DA7219_SIDETONE_EN_MASK		(0x1 << 7)
+
+/* DA7219_SIDETONE_GAIN = 0x3B */
+#define DA7219_SIDETONE_GAIN_SHIFT	0
+#define DA7219_SIDETONE_GAIN_MASK	(0xF << 0)
+#define DA7219_SIDETONE_GAIN_MAX	0xE
+
+/* DA7219_DROUTING_ST_OUTFILT_1L = 0x3C */
+#define DA7219_OUTFILT_ST_1L_SRC_SHIFT		0
+#define DA7219_OUTFILT_ST_1L_SRC_MASK		(0x7 << 0)
+#define DA7219_DMIX_ST_SRC_OUTFILT1L_SHIFT	0
+#define DA7219_DMIX_ST_SRC_OUTFILT1R_SHIFT	1
+#define DA7219_DMIX_ST_SRC_SIDETONE_SHIFT	2
+#define DA7219_DMIX_ST_SRC_OUTFILT1L		(0x1 << 0)
+#define DA7219_DMIX_ST_SRC_OUTFILT1R		(0x1 << 1)
+
+/* DA7219_DROUTING_ST_OUTFILT_1R = 0x3D */
+#define DA7219_OUTFILT_ST_1R_SRC_SHIFT	0
+#define DA7219_OUTFILT_ST_1R_SRC_MASK	(0x7 << 0)
+
+/* DA7219_DAC_FILTERS5 = 0x40 */
+#define DA7219_DAC_SOFTMUTE_RATE_SHIFT	4
+#define DA7219_DAC_SOFTMUTE_RATE_MASK	(0x7 << 4)
+#define DA7219_DAC_SOFTMUTE_RATE_MAX	7
+#define DA7219_DAC_SOFTMUTE_EN_SHIFT	7
+#define DA7219_DAC_SOFTMUTE_EN_MASK	(0x1 << 7)
+
+/* DA7219_DAC_FILTERS2 = 0x41 */
+#define DA7219_DAC_EQ_BAND1_SHIFT	0
+#define DA7219_DAC_EQ_BAND1_MASK	(0xF << 0)
+#define DA7219_DAC_EQ_BAND2_SHIFT	4
+#define DA7219_DAC_EQ_BAND2_MASK	(0xF << 4)
+#define DA7219_DAC_EQ_BAND_MAX		0xF
+
+/* DA7219_DAC_FILTERS3 = 0x42 */
+#define DA7219_DAC_EQ_BAND3_SHIFT	0
+#define DA7219_DAC_EQ_BAND3_MASK	(0xF << 0)
+#define DA7219_DAC_EQ_BAND4_SHIFT	4
+#define DA7219_DAC_EQ_BAND4_MASK	(0xF << 4)
+
+/* DA7219_DAC_FILTERS4 = 0x43 */
+#define DA7219_DAC_EQ_BAND5_SHIFT	0
+#define DA7219_DAC_EQ_BAND5_MASK	(0xF << 0)
+#define DA7219_DAC_EQ_EN_SHIFT		7
+#define DA7219_DAC_EQ_EN_MASK		(0x1 << 7)
+
+/* DA7219_DAC_FILTERS1 = 0x44 */
+#define DA7219_DAC_VOICE_HPF_CORNER_SHIFT	0
+#define DA7219_DAC_VOICE_HPF_CORNER_MASK	(0x7 << 0)
+#define DA7219_DAC_VOICE_EN_SHIFT		3
+#define DA7219_DAC_VOICE_EN_MASK		(0x1 << 3)
+#define DA7219_DAC_AUDIO_HPF_CORNER_SHIFT	4
+#define DA7219_DAC_AUDIO_HPF_CORNER_MASK	(0x3 << 4)
+#define DA7219_DAC_HPF_EN_SHIFT			7
+#define DA7219_DAC_HPF_EN_MASK			(0x1 << 7)
+
+/* DA7219_DAC_L_GAIN = 0x45 */
+#define DA7219_DAC_L_DIGITAL_GAIN_SHIFT	0
+#define DA7219_DAC_L_DIGITAL_GAIN_MASK	(0x7F << 0)
+#define DA7219_DAC_DIGITAL_GAIN_MAX	0x7F
+#define DA7219_DAC_DIGITAL_GAIN_0DB	(0x6F << 0)
+
+/* DA7219_DAC_R_GAIN = 0x46 */
+#define DA7219_DAC_R_DIGITAL_GAIN_SHIFT	0
+#define DA7219_DAC_R_DIGITAL_GAIN_MASK	(0x7F << 0)
+
+/* DA7219_CP_CTRL = 0x47 */
+#define DA7219_CP_MCHANGE_SHIFT		4
+#define DA7219_CP_MCHANGE_MASK		(0x3 << 4)
+#define DA7219_CP_MCHANGE_REL_MASK	0x3
+#define DA7219_CP_MCHANGE_MAX		3
+#define DA7219_CP_MCHANGE_LARGEST_VOL	0x1
+#define DA7219_CP_MCHANGE_DAC_VOL	0x2
+#define DA7219_CP_MCHANGE_SIG_MAG	0x3
+#define DA7219_CP_EN_SHIFT		7
+#define DA7219_CP_EN_MASK		(0x1 << 7)
+
+/* DA7219_HP_L_GAIN = 0x48 */
+#define DA7219_HP_L_AMP_GAIN_SHIFT	0
+#define DA7219_HP_L_AMP_GAIN_MASK	(0x3F << 0)
+#define DA7219_HP_AMP_GAIN_MAX		0x3F
+#define DA7219_HP_AMP_GAIN_0DB		(0x39 << 0)
+
+/* DA7219_HP_R_GAIN = 0x49 */
+#define DA7219_HP_R_AMP_GAIN_SHIFT	0
+#define DA7219_HP_R_AMP_GAIN_MASK	(0x3F << 0)
+
+/* DA7219_MIXOUT_L_SELECT = 0x4B */
+#define DA7219_MIXOUT_L_MIX_SELECT_SHIFT	0
+#define DA7219_MIXOUT_L_MIX_SELECT_MASK		(0x1 << 0)
+
+/* DA7219_MIXOUT_R_SELECT = 0x4C */
+#define DA7219_MIXOUT_R_MIX_SELECT_SHIFT	0
+#define DA7219_MIXOUT_R_MIX_SELECT_MASK		(0x1 << 0)
+
+/* DA7219_SYSTEM_MODES_INPUT = 0x50 */
+#define DA7219_MODE_SUBMIT_SHIFT	0
+#define DA7219_MODE_SUBMIT_MASK		(0x1 << 0)
+#define DA7219_ADC_MODE_SHIFT		1
+#define DA7219_ADC_MODE_MASK		(0x7F << 1)
+
+/* DA7219_SYSTEM_MODES_OUTPUT = 0x51 */
+#define DA7219_MODE_SUBMIT_SHIFT	0
+#define DA7219_MODE_SUBMIT_MASK		(0x1 << 0)
+#define DA7219_DAC_MODE_SHIFT		1
+#define DA7219_DAC_MODE_MASK		(0x7F << 1)
+
+/* DA7219_MICBIAS_CTRL = 0x62 */
+#define DA7219_MICBIAS1_LEVEL_SHIFT	0
+#define DA7219_MICBIAS1_LEVEL_MASK	(0x7 << 0)
+#define DA7219_MICBIAS1_EN_SHIFT	3
+#define DA7219_MICBIAS1_EN_MASK		(0x1 << 3)
+
+/* DA7219_MIC_1_CTRL = 0x63 */
+#define DA7219_MIC_1_AMP_RAMP_EN_SHIFT	5
+#define DA7219_MIC_1_AMP_RAMP_EN_MASK	(0x1 << 5)
+#define DA7219_MIC_1_AMP_MUTE_EN_SHIFT	6
+#define DA7219_MIC_1_AMP_MUTE_EN_MASK	(0x1 << 6)
+#define DA7219_MIC_1_AMP_EN_SHIFT	7
+#define DA7219_MIC_1_AMP_EN_MASK	(0x1 << 7)
+
+/* DA7219_MIXIN_L_CTRL = 0x65 */
+#define DA7219_MIXIN_L_MIX_EN_SHIFT		3
+#define DA7219_MIXIN_L_MIX_EN_MASK		(0x1 << 3)
+#define DA7219_MIXIN_L_AMP_ZC_EN_SHIFT		4
+#define DA7219_MIXIN_L_AMP_ZC_EN_MASK		(0x1 << 4)
+#define DA7219_MIXIN_L_AMP_RAMP_EN_SHIFT	5
+#define DA7219_MIXIN_L_AMP_RAMP_EN_MASK		(0x1 << 5)
+#define DA7219_MIXIN_L_AMP_MUTE_EN_SHIFT	6
+#define DA7219_MIXIN_L_AMP_MUTE_EN_MASK		(0x1 << 6)
+#define DA7219_MIXIN_L_AMP_EN_SHIFT		7
+#define DA7219_MIXIN_L_AMP_EN_MASK		(0x1 << 7)
+
+/* DA7219_ADC_L_CTRL = 0x67 */
+#define DA7219_ADC_L_BIAS_SHIFT		0
+#define DA7219_ADC_L_BIAS_MASK		(0x3 << 0)
+#define DA7219_ADC_L_RAMP_EN_SHIFT	5
+#define DA7219_ADC_L_RAMP_EN_MASK	(0x1 << 5)
+#define DA7219_ADC_L_MUTE_EN_SHIFT	6
+#define DA7219_ADC_L_MUTE_EN_MASK	(0x1 << 6)
+#define DA7219_ADC_L_EN_SHIFT		7
+#define DA7219_ADC_L_EN_MASK		(0x1 << 7)
+
+/* DA7219_DAC_L_CTRL = 0x69 */
+#define DA7219_DAC_L_RAMP_EN_SHIFT	5
+#define DA7219_DAC_L_RAMP_EN_MASK	(0x1 << 5)
+#define DA7219_DAC_L_MUTE_EN_SHIFT	6
+#define DA7219_DAC_L_MUTE_EN_MASK	(0x1 << 6)
+#define DA7219_DAC_L_EN_SHIFT		7
+#define DA7219_DAC_L_EN_MASK		(0x1 << 7)
+
+/* DA7219_DAC_R_CTRL = 0x6A */
+#define DA7219_DAC_R_RAMP_EN_SHIFT	5
+#define DA7219_DAC_R_RAMP_EN_MASK	(0x1 << 5)
+#define DA7219_DAC_R_MUTE_EN_SHIFT	6
+#define DA7219_DAC_R_MUTE_EN_MASK	(0x1 << 6)
+#define DA7219_DAC_R_EN_SHIFT		7
+#define DA7219_DAC_R_EN_MASK		(0x1 << 7)
+
+/* DA7219_HP_L_CTRL = 0x6B */
+#define DA7219_HP_L_AMP_MIN_GAIN_EN_SHIFT	2
+#define DA7219_HP_L_AMP_MIN_GAIN_EN_MASK	(0x1 << 2)
+#define DA7219_HP_L_AMP_OE_SHIFT		3
+#define DA7219_HP_L_AMP_OE_MASK			(0x1 << 3)
+#define DA7219_HP_L_AMP_ZC_EN_SHIFT		4
+#define DA7219_HP_L_AMP_ZC_EN_MASK		(0x1 << 4)
+#define DA7219_HP_L_AMP_RAMP_EN_SHIFT		5
+#define DA7219_HP_L_AMP_RAMP_EN_MASK		(0x1 << 5)
+#define DA7219_HP_L_AMP_MUTE_EN_SHIFT		6
+#define DA7219_HP_L_AMP_MUTE_EN_MASK		(0x1 << 6)
+#define DA7219_HP_L_AMP_EN_SHIFT		7
+#define DA7219_HP_L_AMP_EN_MASK			(0x1 << 7)
+
+/* DA7219_HP_R_CTRL = 0x6C */
+#define DA7219_HP_R_AMP_MIN_GAIN_EN_SHIFT	2
+#define DA7219_HP_R_AMP_MIN_GAIN_EN_MASK	(0x1 << 2)
+#define DA7219_HP_R_AMP_OE_SHIFT		3
+#define DA7219_HP_R_AMP_OE_MASK			(0x1 << 3)
+#define DA7219_HP_R_AMP_ZC_EN_SHIFT		4
+#define DA7219_HP_R_AMP_ZC_EN_MASK		(0x1 << 4)
+#define DA7219_HP_R_AMP_RAMP_EN_SHIFT		5
+#define DA7219_HP_R_AMP_RAMP_EN_MASK		(0x1 << 5)
+#define DA7219_HP_R_AMP_MUTE_EN_SHIFT		6
+#define DA7219_HP_R_AMP_MUTE_EN_MASK		(0x1 << 6)
+#define DA7219_HP_R_AMP_EN_SHIFT		7
+#define DA7219_HP_R_AMP_EN_MASK			(0x1 << 7)
+
+/* DA7219_MIXOUT_L_CTRL = 0x6E */
+#define DA7219_MIXOUT_L_AMP_EN_SHIFT	7
+#define DA7219_MIXOUT_L_AMP_EN_MASK	(0x1 << 7)
+
+/* DA7219_MIXOUT_R_CTRL = 0x6F */
+#define DA7219_MIXOUT_R_AMP_EN_SHIFT	7
+#define DA7219_MIXOUT_R_AMP_EN_MASK	(0x1 << 7)
+
+/* DA7219_CHIP_ID1 = 0x81 */
+#define DA7219_CHIP_ID1_SHIFT	0
+#define DA7219_CHIP_ID1_MASK	(0xFF << 0)
+
+/* DA7219_CHIP_ID2 = 0x82 */
+#define DA7219_CHIP_ID2_SHIFT	0
+#define DA7219_CHIP_ID2_MASK	(0xFF << 0)
+
+/* DA7219_CHIP_REVISION = 0x83 */
+#define DA7219_CHIP_MINOR_SHIFT	0
+#define DA7219_CHIP_MINOR_MASK	(0xF << 0)
+#define DA7219_CHIP_MAJOR_SHIFT	4
+#define DA7219_CHIP_MAJOR_MASK	(0xF << 4)
+
+/* DA7219_LDO_CTRL = 0x90 */
+#define DA7219_LDO_LEVEL_SELECT_SHIFT	4
+#define DA7219_LDO_LEVEL_SELECT_MASK	(0x3 << 4)
+#define DA7219_LDO_EN_SHIFT		7
+#define DA7219_LDO_EN_MASK		(0x1 << 7)
+
+/* DA7219_IO_CTRL = 0x91 */
+#define DA7219_IO_VOLTAGE_LEVEL_SHIFT		0
+#define DA7219_IO_VOLTAGE_LEVEL_MASK		(0x1 << 0)
+#define DA7219_IO_VOLTAGE_LEVEL_2_5V_3_6V	0
+#define DA7219_IO_VOLTAGE_LEVEL_1_2V_2_8V	1
+
+/* DA7219_GAIN_RAMP_CTRL = 0x92 */
+#define DA7219_GAIN_RAMP_RATE_SHIFT	0
+#define DA7219_GAIN_RAMP_RATE_MASK	(0x3 << 0)
+#define DA7219_GAIN_RAMP_RATE_MAX	4
+
+/* DA7219_PC_COUNT = 0x94 */
+#define DA7219_PC_FREERUN_SHIFT		0
+#define DA7219_PC_FREERUN_MASK		(0x1 << 0)
+#define DA7219_PC_RESYNC_AUTO_SHIFT	1
+#define DA7219_PC_RESYNC_AUTO_MASK	(0x1 << 1)
+
+/* DA7219_CP_VOL_THRESHOLD1 = 0x95 */
+#define DA7219_CP_THRESH_VDD2_SHIFT	0
+#define DA7219_CP_THRESH_VDD2_MASK	(0x3F << 0)
+#define DA7219_CP_THRESH_VDD2_MAX	0x3F
+
+/* DA7219_DIG_CTRL = 0x99 */
+#define DA7219_DAC_L_INV_SHIFT	3
+#define DA7219_DAC_L_INV_MASK	(0x1 << 3)
+#define DA7219_DAC_R_INV_SHIFT	7
+#define DA7219_DAC_R_INV_MASK	(0x1 << 7)
+
+/* DA7219_ALC_CTRL2 = 0x9A */
+#define DA7219_ALC_ATTACK_SHIFT		0
+#define DA7219_ALC_ATTACK_MASK		(0xF << 0)
+#define DA7219_ALC_ATTACK_MAX		13
+#define DA7219_ALC_RELEASE_SHIFT	4
+#define DA7219_ALC_RELEASE_MASK		(0xF << 4)
+#define DA7219_ALC_RELEASE_MAX		11
+
+/* DA7219_ALC_CTRL3 = 0x9B */
+#define DA7219_ALC_HOLD_SHIFT		0
+#define DA7219_ALC_HOLD_MASK		(0xF << 0)
+#define DA7219_ALC_HOLD_MAX		16
+#define DA7219_ALC_INTEG_ATTACK_SHIFT	4
+#define DA7219_ALC_INTEG_ATTACK_MASK	(0x3 << 4)
+#define DA7219_ALC_INTEG_RELEASE_SHIFT	6
+#define DA7219_ALC_INTEG_RELEASE_MASK	(0x3 << 6)
+#define DA7219_ALC_INTEG_MAX		4
+
+/* DA7219_ALC_NOISE = 0x9C */
+#define DA7219_ALC_NOISE_SHIFT		0
+#define DA7219_ALC_NOISE_MASK		(0x3F << 0)
+#define DA7219_ALC_THRESHOLD_MAX	0x3F
+
+/* DA7219_ALC_TARGET_MIN = 0x9D */
+#define DA7219_ALC_THRESHOLD_MIN_SHIFT	0
+#define DA7219_ALC_THRESHOLD_MIN_MASK	(0x3F << 0)
+
+/* DA7219_ALC_TARGET_MAX = 0x9E */
+#define DA7219_ALC_THRESHOLD_MAX_SHIFT	0
+#define DA7219_ALC_THRESHOLD_MAX_MASK	(0x3F << 0)
+
+/* DA7219_ALC_GAIN_LIMITS = 0x9F */
+#define DA7219_ALC_ATTEN_MAX_SHIFT	0
+#define DA7219_ALC_ATTEN_MAX_MASK	(0xF << 0)
+#define DA7219_ALC_GAIN_MAX_SHIFT	4
+#define DA7219_ALC_GAIN_MAX_MASK	(0xF << 4)
+#define DA7219_ALC_ATTEN_GAIN_MAX	0xF
+
+/* DA7219_ALC_ANA_GAIN_LIMITS = 0xA0 */
+#define DA7219_ALC_ANA_GAIN_MIN_SHIFT	0
+#define DA7219_ALC_ANA_GAIN_MIN_MASK	(0x7 << 0)
+#define DA7219_ALC_ANA_GAIN_MIN		0x1
+#define DA7219_ALC_ANA_GAIN_MAX_SHIFT	4
+#define DA7219_ALC_ANA_GAIN_MAX_MASK	(0x7 << 4)
+#define DA7219_ALC_ANA_GAIN_MAX		0x7
+
+/* DA7219_ALC_ANTICLIP_CTRL = 0xA1 */
+#define DA7219_ALC_ANTICLIP_STEP_SHIFT	0
+#define DA7219_ALC_ANTICLIP_STEP_MASK	(0x3 << 0)
+#define DA7219_ALC_ANTICLIP_STEP_MAX	4
+#define DA7219_ALC_ANTIPCLIP_EN_SHIFT	7
+#define DA7219_ALC_ANTIPCLIP_EN_MASK	(0x1 << 7)
+
+/* DA7219_ALC_ANTICLIP_LEVEL = 0xA2 */
+#define DA7219_ALC_ANTICLIP_LEVEL_SHIFT	0
+#define DA7219_ALC_ANTICLIP_LEVEL_MASK	(0x7F << 0)
+
+/* DA7219_ALC_OFFSET_AUTO_M_L = 0xA3 */
+#define DA7219_ALC_OFFSET_AUTO_M_L_SHIFT	0
+#define DA7219_ALC_OFFSET_AUTO_M_L_MASK		(0xFF << 0)
+
+/* DA7219_ALC_OFFSET_AUTO_U_L = 0xA4 */
+#define DA7219_ALC_OFFSET_AUTO_U_L_SHIFT	0
+#define DA7219_ALC_OFFSET_AUTO_U_L_MASK		(0xF << 0)
+
+/* DA7219_DAC_NG_SETUP_TIME = 0xAF */
+#define DA7219_DAC_NG_SETUP_TIME_SHIFT	0
+#define DA7219_DAC_NG_SETUP_TIME_MASK	(0x3 << 0)
+#define DA7219_DAC_NG_SETUP_TIME_MAX	4
+#define DA7219_DAC_NG_RAMPUP_RATE_SHIFT	2
+#define DA7219_DAC_NG_RAMPUP_RATE_MASK	(0x1 << 2)
+#define DA7219_DAC_NG_RAMPDN_RATE_SHIFT	3
+#define DA7219_DAC_NG_RAMPDN_RATE_MASK	(0x1 << 3)
+#define DA7219_DAC_NG_RAMP_RATE_MAX	2
+
+/* DA7219_DAC_NG_OFF_THRESH = 0xB0 */
+#define DA7219_DAC_NG_OFF_THRESHOLD_SHIFT	0
+#define DA7219_DAC_NG_OFF_THRESHOLD_MASK	(0x7 << 0)
+#define DA7219_DAC_NG_THRESHOLD_MAX		0x7
+
+/* DA7219_DAC_NG_ON_THRESH = 0xB1 */
+#define DA7219_DAC_NG_ON_THRESHOLD_SHIFT	0
+#define DA7219_DAC_NG_ON_THRESHOLD_MASK		(0x7 << 0)
+
+/* DA7219_DAC_NG_CTRL = 0xB2 */
+#define DA7219_DAC_NG_EN_SHIFT	7
+#define DA7219_DAC_NG_EN_MASK	(0x1 << 7)
+
+/* DA7219_TONE_GEN_CFG1 = 0xB4 */
+#define DA7219_DTMF_REG_SHIFT		0
+#define DA7219_DTMF_REG_MASK		(0xF << 0)
+#define DA7219_DTMF_REG_MAX		16
+#define DA7219_DTMF_EN_SHIFT		4
+#define DA7219_DTMF_EN_MASK		(0x1 << 4)
+#define DA7219_START_STOPN_SHIFT	7
+#define DA7219_START_STOPN_MASK		(0x1 << 7)
+
+/* DA7219_TONE_GEN_CFG2 = 0xB5 */
+#define DA7219_SWG_SEL_SHIFT		0
+#define DA7219_SWG_SEL_MASK		(0x3 << 0)
+#define DA7219_SWG_SEL_MAX		4
+#define DA7219_SWG_SEL_SRAMP		(0x3 << 0)
+#define DA7219_TONE_GEN_GAIN_SHIFT	4
+#define DA7219_TONE_GEN_GAIN_MASK	(0xF << 4)
+#define DA7219_TONE_GEN_GAIN_MAX	0xF
+#define DA7219_TONE_GEN_GAIN_MINUS_9DB	(0x3 << 4)
+#define DA7219_TONE_GEN_GAIN_MINUS_15DB	(0x5 << 4)
+
+/* DA7219_TONE_GEN_CYCLES = 0xB6 */
+#define DA7219_BEEP_CYCLES_SHIFT	0
+#define DA7219_BEEP_CYCLES_MASK		(0x7 << 0)
+
+/* DA7219_TONE_GEN_FREQ1_L = 0xB7 */
+#define DA7219_FREQ1_L_SHIFT	0
+#define DA7219_FREQ1_L_MASK	(0xFF << 0)
+#define DA7219_FREQ_MAX		0xFFFF
+
+/* DA7219_TONE_GEN_FREQ1_U = 0xB8 */
+#define DA7219_FREQ1_U_SHIFT	0
+#define DA7219_FREQ1_U_MASK	(0xFF << 0)
+
+/* DA7219_TONE_GEN_FREQ2_L = 0xB9 */
+#define DA7219_FREQ2_L_SHIFT	0
+#define DA7219_FREQ2_L_MASK	(0xFF << 0)
+
+/* DA7219_TONE_GEN_FREQ2_U = 0xBA */
+#define DA7219_FREQ2_U_SHIFT	0
+#define DA7219_FREQ2_U_MASK	(0xFF << 0)
+
+/* DA7219_TONE_GEN_ON_PER = 0xBB */
+#define DA7219_BEEP_ON_PER_SHIFT	0
+#define DA7219_BEEP_ON_PER_MASK		(0x3F << 0)
+#define DA7219_BEEP_ON_OFF_MAX		0x3F
+
+/* DA7219_TONE_GEN_OFF_PER = 0xBC */
+#define DA7219_BEEP_OFF_PER_SHIFT	0
+#define DA7219_BEEP_OFF_PER_MASK	(0x3F << 0)
+
+/* DA7219_SYSTEM_STATUS = 0xE0 */
+#define DA7219_SC1_BUSY_SHIFT	0
+#define DA7219_SC1_BUSY_MASK	(0x1 << 0)
+#define DA7219_SC2_BUSY_SHIFT	1
+#define DA7219_SC2_BUSY_MASK	(0x1 << 1)
+
+/* DA7219_SYSTEM_ACTIVE = 0xFD */
+#define DA7219_SYSTEM_ACTIVE_SHIFT	0
+#define DA7219_SYSTEM_ACTIVE_MASK	(0x1 << 0)
+
+
+/*
+ * General defines & data
+ */
+
+/* Register inversion */
+#define DA7219_NO_INVERT	0
+#define DA7219_INVERT		1
+
+/* Byte related defines */
+#define DA7219_BYTE_SHIFT	8
+#define DA7219_BYTE_MASK	0xFF
+
+/* PLL Output Frequencies */
+#define DA7219_PLL_FREQ_OUT_90316	90316800
+#define DA7219_PLL_FREQ_OUT_98304	98304000
+
+/* PLL Frequency Dividers */
+#define DA7219_PLL_INDIV_2_5_MHZ_VAL	1
+#define DA7219_PLL_INDIV_5_10_MHZ_VAL	2
+#define DA7219_PLL_INDIV_10_20_MHZ_VAL	4
+#define DA7219_PLL_INDIV_20_40_MHZ_VAL	8
+#define DA7219_PLL_INDIV_40_54_MHZ_VAL	16
+
+/* SRM */
+#define DA7219_SRM_CHECK_RETRIES	8
+
+enum da7219_clk_src {
+	DA7219_CLKSRC_MCLK = 0,
+	DA7219_CLKSRC_MCLK_SQR,
+};
+
+enum da7219_sys_clk {
+	DA7219_SYSCLK_MCLK = 0,
+	DA7219_SYSCLK_PLL,
+	DA7219_SYSCLK_PLL_SRM,
+	DA7219_SYSCLK_PLL_32KHZ
+};
+
+/* Regulators */
+enum da7219_supplies {
+	DA7219_SUPPLY_VDD = 0,
+	DA7219_SUPPLY_VDDMIC,
+	DA7219_SUPPLY_VDDIO,
+	DA7219_NUM_SUPPLIES,
+};
+
+struct da7219_aad_priv;
+
+/* Private data */
+struct da7219_priv {
+	struct da7219_aad_priv *aad;
+	struct da7219_pdata *pdata;
+
+	struct regulator_bulk_data supplies[DA7219_NUM_SUPPLIES];
+	struct regmap *regmap;
+	struct mutex lock;
+
+	struct clk *mclk;
+	unsigned int mclk_rate;
+	int clk_src;
+
+	bool master;
+	bool alc_en;
+};
+
+#endif /* __DA7219_H */
