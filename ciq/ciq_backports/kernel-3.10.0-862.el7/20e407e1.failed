genirq/affinity: Introduce struct irq_affinity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 20e407e195b29a4f5a18d713a61f54a75f992bd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/20e407e1.failed

Some drivers (various network and RDMA adapter for example) have a MSI-X
vector layout where most of the vectors are used for I/O queues and should
have CPU affinity assigned to them, but some (usually 1 but sometimes more)
at the beginning or end are used for low-performance admin or configuration
work and should not have any explicit affinity assigned to them.

Add a new irq_affinity structure, which will be passed through a variant of
pci_irq_alloc_vectors that allows to specify these requirements (and is
extensible to any future quirks in that area) so that the core IRQ affinity
algorithm can take this quirks into account.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Acked-by: Jens Axboe <axboe@kernel.dk>
	Cc: linux-block@vger.kernel.org
	Cc: linux-pci@vger.kernel.org
Link: http://lkml.kernel.org/r/1478654107-7384-2-git-send-email-hch@lst.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 20e407e195b29a4f5a18d713a61f54a75f992bd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/interrupt.h
diff --cc include/linux/interrupt.h
index 775c38a0baff,6b5268688a81..000000000000
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@@ -296,6 -232,61 +296,64 @@@ struct irq_affinity_notify 
  	void (*release)(struct kref *ref);
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct irq_affinity - Description for automatic irq affinity assignements
+  * @pre_vectors:	Don't apply affinity to @pre_vectors at beginning of
+  *			the MSI(-X) vector space
+  * @post_vectors:	Don't apply affinity to @post_vectors at end of
+  *			the MSI(-X) vector space
+  */
+ struct irq_affinity {
+ 	int	pre_vectors;
+ 	int	post_vectors;
+ };
+ 
+ #if defined(CONFIG_SMP)
+ 
+ extern cpumask_var_t irq_default_affinity;
+ 
+ /* Internal implementation. Use the helpers below */
+ extern int __irq_set_affinity(unsigned int irq, const struct cpumask *cpumask,
+ 			      bool force);
+ 
+ /**
+  * irq_set_affinity - Set the irq affinity of a given irq
+  * @irq:	Interrupt to set affinity
+  * @cpumask:	cpumask
+  *
+  * Fails if cpumask does not contain an online CPU
+  */
+ static inline int
+ irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)
+ {
+ 	return __irq_set_affinity(irq, cpumask, false);
+ }
+ 
+ /**
+  * irq_force_affinity - Force the irq affinity of a given irq
+  * @irq:	Interrupt to set affinity
+  * @cpumask:	cpumask
+  *
+  * Same as irq_set_affinity, but without checking the mask against
+  * online cpus.
+  *
+  * Solely for low level cpu hotplug code, where we need to make per
+  * cpu interrupts affine before the cpu becomes online.
+  */
+ static inline int
+ irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)
+ {
+ 	return __irq_set_affinity(irq, cpumask, true);
+ }
+ 
+ extern int irq_can_set_affinity(unsigned int irq);
+ extern int irq_select_affinity(unsigned int irq);
+ 
+ extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
+ 
++>>>>>>> 20e407e195b2 (genirq/affinity: Introduce struct irq_affinity)
  extern int
  irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
  
* Unmerged path include/linux/interrupt.h
