soreuseport: fast reuseport UDP socket selection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Craig Gallek <kraig@google.com>
commit e32ea7e747271a0abcd37e265005e97cc81d9df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e32ea7e7.failed

Include a struct sock_reuseport instance when a UDP socket binds to
a specific address for the first time with the reuseport flag set.
When selecting a socket for an incoming UDP packet, use the information
available in sock_reuseport if present.

This required adding an additional field to the UDP source address
equality function to differentiate between exact and wildcard matches.
The original use case allowed wildcard matches when checking for
existing port uses during bind.  The new use case of adding a socket
to a reuseport group requires exact address matching.

Performance test (using a machine with 2 CPU sockets and a total of
48 cores):  Create reuseport groups of varying size.  Use one socket
from this group per user thread (pinning each thread to a different
core) calling recvmmsg in a tight loop.  Record number of messages
received per second while saturating a 10G link.
  10 sockets: 18% increase (~2.8M -> 3.3M pkts/s)
  20 sockets: 14% increase (~2.9M -> 3.3M pkts/s)
  40 sockets: 13% increase (~3.0M -> 3.4M pkts/s)

This work is based off a similar implementation written by
Ying Cai <ycai@google.com> for implementing policy-based reuseport
selection.

	Signed-off-by: Craig Gallek <kraig@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e32ea7e747271a0abcd37e265005e97cc81d9df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/udp.h
#	net/ipv6/udp.c
diff --cc include/net/udp.h
index 886fb5efc132,3b5d7f93bc23..000000000000
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@@ -193,9 -190,11 +193,17 @@@ static inline void udp_lib_close(struc
  	sk_common_release(sk);
  }
  
++<<<<<<< HEAD
 +extern int udp_lib_get_port(struct sock *sk, unsigned short snum,
 +			    int (*)(const struct sock *,const struct sock *),
 +			    unsigned int hash2_nulladdr);
++=======
+ int udp_lib_get_port(struct sock *sk, unsigned short snum,
+ 		     int (*)(const struct sock *, const struct sock *, bool),
+ 		     unsigned int hash2_nulladdr);
+ 
+ u32 udp_flow_hashrnd(void);
++>>>>>>> e32ea7e74727 (soreuseport: fast reuseport UDP socket selection)
  
  static inline __be16 udp_flow_src_port(struct net *net, struct sk_buff *skb,
  				       int min, int max, bool use_eth)
diff --cc net/ipv6/udp.c
index f5a8a12b48a5,6204b8992de4..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -76,10 -77,16 +77,17 @@@ static unsigned int udp6_ehashfn(struc
  			       udp_ipv6_hash_secret + net_hash_mix(net));
  }
  
- int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)
+ /* match_wildcard == true:  IPV6_ADDR_ANY equals to any IPv6 addresses if IPv6
+  *                          only, and any IPv4 addresses if not IPv6 only
+  * match_wildcard == false: addresses must be exactly the same, i.e.
+  *                          IPV6_ADDR_ANY only equals to IPV6_ADDR_ANY,
+  *                          and 0.0.0.0 equals to 0.0.0.0 only
+  */
+ int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
+ 			 bool match_wildcard)
  {
  	const struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);
 +	int sk_ipv6only = ipv6_only_sock(sk);
  	int sk2_ipv6only = inet_v6_ipv6only(sk2);
  	int addr_type = ipv6_addr_type(&sk->sk_v6_rcv_saddr);
  	int addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;
@@@ -94,8 -109,8 +110,13 @@@
  	    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))
  		return 1;
  
++<<<<<<< HEAD
 +	if (addr_type == IPV6_ADDR_ANY &&
 +	    !(sk_ipv6only && addr_type2 == IPV6_ADDR_MAPPED))
++=======
+ 	if (addr_type == IPV6_ADDR_ANY && match_wildcard &&
+ 	    !(ipv6_only_sock(sk) && addr_type2 == IPV6_ADDR_MAPPED))
++>>>>>>> e32ea7e74727 (soreuseport: fast reuseport UDP socket selection)
  		return 1;
  
  	if (sk2_rcv_saddr6 &&
@@@ -250,11 -269,16 +271,17 @@@ begin
  			badness = score;
  			reuseport = sk->sk_reuseport;
  			if (reuseport) {
+ 				struct sock *sk2;
  				hash = udp6_ehashfn(net, daddr, hnum,
  						    saddr, sport);
+ 				sk2 = reuseport_select_sock(sk, hash);
+ 				if (sk2) {
+ 					result = sk2;
+ 					goto found;
+ 				}
  				matches = 1;
 -			}
 +			} else if (score == SCORE2_MAX)
 +				goto exact_match;
  		} else if (score == badness && reuseport) {
  			matches++;
  			if (reciprocal_scale(hash, matches) == 0)
@@@ -271,7 -295,7 +298,11 @@@
  		goto begin;
  
  	if (result) {
++<<<<<<< HEAD
 +exact_match:
++=======
+ found:
++>>>>>>> e32ea7e74727 (soreuseport: fast reuseport UDP socket selection)
  		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
  			result = NULL;
  		else if (unlikely(compute_score2(result, net, saddr, sport,
@@@ -561,9 -579,9 +599,15 @@@ void __udp6_lib_err(struct sk_buff *skb
  	int err;
  	struct net *net = dev_net(skb->dev);
  
++<<<<<<< HEAD
 +	sk = __udp6_lib_lookup(net, daddr, uh->dest,
 +			       saddr, uh->source, inet6_iif(skb), udptable);
 +	if (sk == NULL) {
++=======
+ 	sk = __udp6_lib_lookup(net, daddr, uh->dest, saddr, uh->source,
+ 			       inet6_iif(skb), udptable);
+ 	if (!sk) {
++>>>>>>> e32ea7e74727 (soreuseport: fast reuseport UDP socket selection)
  		ICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),
  				   ICMP6_MIB_INERRORS);
  		return;
diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f337b6d63734..178e5c0b190b 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -85,7 +85,8 @@ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 		      u32 banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    u32 banned_flags);
-int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
+int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
+			 bool match_wildcard);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 
* Unmerged path include/net/udp.h
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 65a7d1f16a3d..16568e011236 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -114,6 +114,7 @@
 #include <trace/events/skb.h>
 #include <net/busy_poll.h>
 #include "udp_impl.h"
+#include <net/sock_reuseport.h>
 
 struct udp_table udp_table __read_mostly;
 EXPORT_SYMBOL(udp_table);
@@ -138,7 +139,8 @@ static int udp_lib_lport_inuse(struct net *net, __u16 num,
 			       unsigned long *bitmap,
 			       struct sock *sk,
 			       int (*saddr_comp)(const struct sock *sk1,
-						 const struct sock *sk2),
+						 const struct sock *sk2,
+						 bool match_wildcard),
 			       unsigned int log)
 {
 	struct sock *sk2;
@@ -153,8 +155,9 @@ static int udp_lib_lport_inuse(struct net *net, __u16 num,
 		    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if ||
 		     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
 		    (!sk2->sk_reuseport || !sk->sk_reuseport ||
+		     rcu_access_pointer(sk->sk_reuseport_cb) ||
 		     !uid_eq(uid, sock_i_uid(sk2))) &&
-		    saddr_comp(sk, sk2)) {
+		    saddr_comp(sk, sk2, true)) {
 			if (!bitmap)
 				return 1;
 			__set_bit(udp_sk(sk2)->udp_port_hash >> log, bitmap);
@@ -171,7 +174,8 @@ static int udp_lib_lport_inuse2(struct net *net, __u16 num,
 				struct udp_hslot *hslot2,
 				struct sock *sk,
 				int (*saddr_comp)(const struct sock *sk1,
-						  const struct sock *sk2))
+						  const struct sock *sk2,
+						  bool match_wildcard))
 {
 	struct sock *sk2;
 	struct hlist_nulls_node *node;
@@ -187,8 +191,9 @@ static int udp_lib_lport_inuse2(struct net *net, __u16 num,
 		    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if ||
 		     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
 		    (!sk2->sk_reuseport || !sk->sk_reuseport ||
+		     rcu_access_pointer(sk->sk_reuseport_cb) ||
 		     !uid_eq(uid, sock_i_uid(sk2))) &&
-		    saddr_comp(sk, sk2)) {
+		    saddr_comp(sk, sk2, true)) {
 			res = 1;
 			break;
 		}
@@ -197,6 +202,35 @@ static int udp_lib_lport_inuse2(struct net *net, __u16 num,
 	return res;
 }
 
+static int udp_reuseport_add_sock(struct sock *sk, struct udp_hslot *hslot,
+				  int (*saddr_same)(const struct sock *sk1,
+						    const struct sock *sk2,
+						    bool match_wildcard))
+{
+	struct net *net = sock_net(sk);
+	struct hlist_nulls_node *node;
+	kuid_t uid = sock_i_uid(sk);
+	struct sock *sk2;
+
+	sk_nulls_for_each(sk2, node, &hslot->head) {
+		if (net_eq(sock_net(sk2), net) &&
+		    sk2 != sk &&
+		    sk2->sk_family == sk->sk_family &&
+		    ipv6_only_sock(sk2) == ipv6_only_sock(sk) &&
+		    (udp_sk(sk2)->udp_port_hash == udp_sk(sk)->udp_port_hash) &&
+		    (sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
+		    sk2->sk_reuseport && uid_eq(uid, sock_i_uid(sk2)) &&
+		    (*saddr_same)(sk, sk2, false)) {
+			return reuseport_add_sock(sk, sk2);
+		}
+	}
+
+	/* Initial allocation may have already happened via setsockopt */
+	if (!rcu_access_pointer(sk->sk_reuseport_cb))
+		return reuseport_alloc(sk);
+	return 0;
+}
+
 /**
  *  udp_lib_get_port  -  UDP/-Lite port lookup for IPv4 and IPv6
  *
@@ -208,7 +242,8 @@ static int udp_lib_lport_inuse2(struct net *net, __u16 num,
  */
 int udp_lib_get_port(struct sock *sk, unsigned short snum,
 		     int (*saddr_comp)(const struct sock *sk1,
-				       const struct sock *sk2),
+				       const struct sock *sk2,
+				       bool match_wildcard),
 		     unsigned int hash2_nulladdr)
 {
 	struct udp_hslot *hslot, *hslot2;
@@ -291,6 +326,14 @@ found:
 	udp_sk(sk)->udp_port_hash = snum;
 	udp_sk(sk)->udp_portaddr_hash ^= snum;
 	if (sk_unhashed(sk)) {
+		if (sk->sk_reuseport &&
+		    udp_reuseport_add_sock(sk, hslot, saddr_comp)) {
+			inet_sk(sk)->inet_num = 0;
+			udp_sk(sk)->udp_port_hash = 0;
+			udp_sk(sk)->udp_portaddr_hash ^= snum;
+			goto fail_unlock;
+		}
+
 		sk_nulls_add_node_rcu(sk, &hslot->head);
 		hslot->count++;
 		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
@@ -310,13 +353,22 @@ fail:
 }
 EXPORT_SYMBOL(udp_lib_get_port);
 
-static int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)
+/* match_wildcard == true:  0.0.0.0 equals to any IPv4 addresses
+ * match_wildcard == false: addresses must be exactly the same, i.e.
+ *                          0.0.0.0 only equals to 0.0.0.0
+ */
+static int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2,
+				bool match_wildcard)
 {
 	struct inet_sock *inet1 = inet_sk(sk1), *inet2 = inet_sk(sk2);
 
-	return 	(!ipv6_only_sock(sk2)  &&
-		 (!inet1->inet_rcv_saddr || !inet2->inet_rcv_saddr ||
-		   inet1->inet_rcv_saddr == inet2->inet_rcv_saddr));
+	if (!ipv6_only_sock(sk2)) {
+		if (inet1->inet_rcv_saddr == inet2->inet_rcv_saddr)
+			return 1;
+		if (!inet1->inet_rcv_saddr || !inet2->inet_rcv_saddr)
+			return match_wildcard;
+	}
+	return 0;
 }
 
 static unsigned int udp4_portaddr_hash(struct net *net, __be32 saddr,
@@ -457,8 +509,14 @@ begin:
 			badness = score;
 			reuseport = sk->sk_reuseport;
 			if (reuseport) {
+				struct sock *sk2;
 				hash = udp_ehashfn(net, daddr, hnum,
 						   saddr, sport);
+				sk2 = reuseport_select_sock(sk, hash);
+				if (sk2) {
+					result = sk2;
+					goto found;
+				}
 				matches = 1;
 			}
 		} else if (score == badness && reuseport) {
@@ -476,6 +534,7 @@ begin:
 	if (get_nulls_value(node) != slot2)
 		goto begin;
 	if (result) {
+found:
 		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 			result = NULL;
 		else if (unlikely(compute_score2(result, net, saddr, sport,
@@ -538,8 +597,14 @@ begin:
 			badness = score;
 			reuseport = sk->sk_reuseport;
 			if (reuseport) {
+				struct sock *sk2;
 				hash = udp_ehashfn(net, daddr, hnum,
 						   saddr, sport);
+				sk2 = reuseport_select_sock(sk, hash);
+				if (sk2) {
+					result = sk2;
+					goto found;
+				}
 				matches = 1;
 			}
 		} else if (score == badness && reuseport) {
@@ -558,6 +623,7 @@ begin:
 		goto begin;
 
 	if (result) {
+found:
 		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 			result = NULL;
 		else if (unlikely(compute_score(result, net, saddr, hnum, sport,
@@ -592,7 +658,8 @@ EXPORT_SYMBOL_GPL(udp4_lib_lookup_skb);
 struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 			     __be32 daddr, __be16 dport, int dif)
 {
-	return __udp4_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);
+	return __udp4_lib_lookup(net, saddr, sport, daddr, dport, dif,
+				 &udp_table);
 }
 EXPORT_SYMBOL_GPL(udp4_lib_lookup);
 
@@ -1494,6 +1561,8 @@ void udp_lib_unhash(struct sock *sk)
 		hslot2 = udp_hashslot2(udptable, udp_sk(sk)->udp_portaddr_hash);
 
 		spin_lock_bh(&hslot->lock);
+		if (rcu_access_pointer(sk->sk_reuseport_cb))
+			reuseport_detach_sock(sk);
 		if (sk_nulls_del_node_init_rcu(sk)) {
 			hslot->count--;
 			inet_sk(sk)->inet_num = 0;
@@ -1521,22 +1590,28 @@ void udp_lib_rehash(struct sock *sk, u16 newhash)
 		hslot2 = udp_hashslot2(udptable, udp_sk(sk)->udp_portaddr_hash);
 		nhslot2 = udp_hashslot2(udptable, newhash);
 		udp_sk(sk)->udp_portaddr_hash = newhash;
-		if (hslot2 != nhslot2) {
+
+		if (hslot2 != nhslot2 ||
+		    rcu_access_pointer(sk->sk_reuseport_cb)) {
 			hslot = udp_hashslot(udptable, sock_net(sk),
 					     udp_sk(sk)->udp_port_hash);
 			/* we must lock primary chain too */
 			spin_lock_bh(&hslot->lock);
-
-			spin_lock(&hslot2->lock);
-			hlist_nulls_del_init_rcu(&udp_sk(sk)->udp_portaddr_node);
-			hslot2->count--;
-			spin_unlock(&hslot2->lock);
-
-			spin_lock(&nhslot2->lock);
-			hlist_nulls_add_head_rcu(&udp_sk(sk)->udp_portaddr_node,
-						 &nhslot2->head);
-			nhslot2->count++;
-			spin_unlock(&nhslot2->lock);
+			if (rcu_access_pointer(sk->sk_reuseport_cb))
+				reuseport_detach_sock(sk);
+
+			if (hslot2 != nhslot2) {
+				spin_lock(&hslot2->lock);
+				hlist_nulls_del_init_rcu(&udp_sk(sk)->udp_portaddr_node);
+				hslot2->count--;
+				spin_unlock(&hslot2->lock);
+
+				spin_lock(&nhslot2->lock);
+				hlist_nulls_add_head_rcu(&udp_sk(sk)->udp_portaddr_node,
+							 &nhslot2->head);
+				nhslot2->count++;
+				spin_unlock(&nhslot2->lock);
+			}
 
 			spin_unlock_bh(&hslot->lock);
 		}
diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c
index ef7a87510b54..293b6c9ea00b 100644
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -51,12 +51,12 @@ int inet6_csk_bind_conflict(const struct sock *sk,
 			     (sk2->sk_state != TCP_TIME_WAIT &&
 			      !uid_eq(uid,
 				      sock_i_uid((struct sock *)sk2))))) {
-				if (ipv6_rcv_saddr_equal(sk, sk2))
+				if (ipv6_rcv_saddr_equal(sk, sk2, true))
 					break;
 			}
 			if (!relax && reuse && sk2->sk_reuse &&
 			    sk2->sk_state != TCP_LISTEN &&
-			    ipv6_rcv_saddr_equal(sk, sk2))
+			    ipv6_rcv_saddr_equal(sk, sk2, true))
 				break;
 		}
 	}
* Unmerged path net/ipv6/udp.c
