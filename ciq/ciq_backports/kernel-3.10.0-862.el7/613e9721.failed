device property: Add function to search for named child of device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: device property: Add function to search for named child of device (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 95.59%
commit-author Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
commit 613e97218ccbd7f33895cad4525d861810a9d5d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/613e9721.failed

For device nodes in both DT and ACPI, it possible to have named
child nodes which contain properties (an existing example being
gpio-leds). This adds a function to find a named child node for
a device which can be used by drivers for property retrieval.

For DT data node name matching, of_node_cmp() and similar functions
are made available outside of CONFIG_OF block so the new function
can reference these for DT and non-DT builds.

For ACPI data node name matching, a helper function is also added
which returns false if CONFIG_ACPI is not set, otherwise it
performs a string comparison on the data node name. This avoids
using the acpi_data_node struct for non CONFIG_ACPI builds,
which would otherwise cause a build failure.

	Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
	Acked-by: Sathyanarayana Nujella <sathyanarayana.nujella@intel.com>
	Acked-by: Rob Herring <robh@kernel.org>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 613e97218ccbd7f33895cad4525d861810a9d5d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/of.h
diff --cc include/linux/of.h
index 579834746e27,8455741e313e..000000000000
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@@ -203,17 -238,6 +203,20 @@@ static inline unsigned long of_read_ulo
  #define OF_ROOT_NODE_SIZE_CELLS_DEFAULT 1
  #endif
  
++<<<<<<< HEAD
 +/* Default string compare functions, Allow arch asm/prom.h to override */
 +#if !defined(of_compat_cmp)
 +#define of_compat_cmp(s1, s2, l)	strcasecmp((s1), (s2))
 +#define of_prop_cmp(s1, s2)		strcmp((s1), (s2))
 +#define of_node_cmp(s1, s2)		strcasecmp((s1), (s2))
 +#endif
 +
 +/* flag descriptions */
 +#define OF_DYNAMIC	1 /* node and properties were allocated via kmalloc */
 +#define OF_DETACHED	2 /* node has been detached from the device tree */
 +
++=======
++>>>>>>> 613e97218ccb (device property: Add function to search for named child of device)
  #define OF_IS_DYNAMIC(x) test_bit(OF_DYNAMIC, &x->_flags)
  #define OF_MARK_DYNAMIC(x) set_bit(OF_DYNAMIC, &x->_flags)
  
@@@ -571,14 -666,66 +574,21 @@@ static inline int of_machine_is_compati
  	return 0;
  }
  
 -static inline bool of_console_check(const struct device_node *dn, const char *name, int index)
 -{
 -	return false;
 -}
 -
 -static inline const __be32 *of_prop_next_u32(struct property *prop,
 -		const __be32 *cur, u32 *pu)
 -{
 -	return NULL;
 -}
 -
 -static inline const char *of_prop_next_string(struct property *prop,
 -		const char *cur)
 -{
 -	return NULL;
 -}
 -
 -static inline int of_node_check_flag(struct device_node *n, unsigned long flag)
 -{
 -	return 0;
 -}
 -
 -static inline int of_node_test_and_set_flag(struct device_node *n,
 -					    unsigned long flag)
 -{
 -	return 0;
 -}
 -
 -static inline void of_node_set_flag(struct device_node *n, unsigned long flag)
 -{
 -}
 -
 -static inline void of_node_clear_flag(struct device_node *n, unsigned long flag)
 -{
 -}
 -
 -static inline int of_property_check_flag(struct property *p, unsigned long flag)
 -{
 -	return 0;
 -}
 -
 -static inline void of_property_set_flag(struct property *p, unsigned long flag)
 -{
 -}
 -
 -static inline void of_property_clear_flag(struct property *p, unsigned long flag)
 -{
 -}
 -
  #define of_match_ptr(_ptr)	NULL
  #define of_match_node(_matches, _node)	NULL
 +#define of_property_for_each_u32(np, propname, prop, p, u) \
 +	while (0)
 +#define of_property_for_each_string(np, propname, prop, s) \
 +	while (0)
  #endif /* CONFIG_OF */
  
+ /* Default string compare functions, Allow arch asm/prom.h to override */
+ #if !defined(of_compat_cmp)
+ #define of_compat_cmp(s1, s2, l)	strcasecmp((s1), (s2))
+ #define of_prop_cmp(s1, s2)		strcmp((s1), (s2))
+ #define of_node_cmp(s1, s2)		strcasecmp((s1), (s2))
+ #endif
+ 
  #if defined(CONFIG_OF) && defined(CONFIG_NUMA)
  extern int of_node_to_nid(struct device_node *np);
  #else
diff --git a/drivers/base/property.c b/drivers/base/property.c
index d046257a58c4..c15a0252e4af 100644
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@ -882,6 +882,34 @@ struct fwnode_handle *device_get_next_child_node(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(device_get_next_child_node);
 
+/**
+ * device_get_named_child_node - Return first matching named child node handle
+ * @dev: Device to find the named child node for.
+ * @childname: String to match child node name against.
+ */
+struct fwnode_handle *device_get_named_child_node(struct device *dev,
+						  const char *childname)
+{
+	struct fwnode_handle *child;
+
+	/*
+	 * Find first matching named child node of this device.
+	 * For ACPI this will be a data only sub-node.
+	 */
+	device_for_each_child_node(dev, child) {
+		if (is_of_node(child)) {
+			if (!of_node_cmp(to_of_node(child)->name, childname))
+				return child;
+		} else if (is_acpi_data_node(child)) {
+			if (acpi_data_node_match(child, childname))
+				return child;
+		}
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(device_get_named_child_node);
+
 /**
  * fwnode_handle_put - Drop reference to a device node
  * @fwnode: Pointer to the device node to drop the reference to.
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index a1d6fc503b68..23b72711ba49 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -417,6 +417,13 @@ static inline struct acpi_data_node *to_acpi_data_node(struct fwnode_handle *fwn
 		container_of(fwnode, struct acpi_data_node, fwnode) : NULL;
 }
 
+static inline bool acpi_data_node_match(struct fwnode_handle *fwnode,
+					const char *name)
+{
+	return is_acpi_data_node(fwnode) ?
+		(!strcmp(to_acpi_data_node(fwnode)->name, name)) : false;
+}
+
 static inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)
 {
 	return &adev->fwnode;
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index 0ab4b0e3a549..668434599c54 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -481,6 +481,12 @@ static inline struct acpi_data_node *to_acpi_data_node(struct fwnode_handle *fwn
 	return NULL;
 }
 
+static inline bool acpi_data_node_match(struct fwnode_handle *fwnode,
+					const char *name)
+{
+	return false;
+}
+
 static inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)
 {
 	return NULL;
* Unmerged path include/linux/of.h
diff --git a/include/linux/property.h b/include/linux/property.h
index b51fcd36d892..d2752dc28cc2 100644
--- a/include/linux/property.h
+++ b/include/linux/property.h
@@ -77,6 +77,9 @@ struct fwnode_handle *device_get_next_child_node(struct device *dev,
 	for (child = device_get_next_child_node(dev, NULL); child;	\
 	     child = device_get_next_child_node(dev, child))
 
+struct fwnode_handle *device_get_named_child_node(struct device *dev,
+						  const char *childname);
+
 void fwnode_handle_put(struct fwnode_handle *fwnode);
 
 unsigned int device_get_child_node_count(struct device *dev);
