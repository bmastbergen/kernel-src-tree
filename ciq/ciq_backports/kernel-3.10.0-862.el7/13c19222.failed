IB/rdmavt, hfi1, qib: Modify check_ah() to account for extended LIDs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit 13c19222889daf91da36b7fb63b5d5d9ce89b377
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/13c19222.failed

rvt_check_ah() delegates lid verification to underlying
driver. Underlying driver uses different conditions to
check for dlid depending on whether the device supports
extended LIDs

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 13c19222889daf91da36b7fb63b5d5d9ce89b377)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/sw/rdmavt/ah.c
#	drivers/infiniband/sw/rdmavt/qp.c
#	include/rdma/opa_addr.h
diff --cc drivers/infiniband/sw/rdmavt/ah.c
index b0f09fb45c72,ba3639a0d77c..000000000000
--- a/drivers/infiniband/sw/rdmavt/ah.c
+++ b/drivers/infiniband/sw/rdmavt/ah.c
@@@ -60,34 -60,27 +60,42 @@@
   * Return: 0 on success
   */
  int rvt_check_ah(struct ib_device *ibdev,
 -		 struct rdma_ah_attr *ah_attr)
 +		 struct ib_ah_attr *ah_attr)
  {
  	int err;
 -	int port_num = rdma_ah_get_port_num(ah_attr);
  	struct ib_port_attr port_attr;
  	struct rvt_dev_info *rdi = ib_to_rvt(ibdev);
++<<<<<<< HEAD
 +	enum rdma_link_layer link = rdma_port_get_link_layer(ibdev,
 +							     ah_attr->port_num);
++=======
+ 	u8 ah_flags = rdma_ah_get_ah_flags(ah_attr);
+ 	u8 static_rate = rdma_ah_get_static_rate(ah_attr);
++>>>>>>> 13c19222889d (IB/rdmavt, hfi1, qib: Modify check_ah() to account for extended LIDs)
  
 -	err = ib_query_port(ibdev, port_num, &port_attr);
 +	err = ib_query_port(ibdev, ah_attr->port_num, &port_attr);
  	if (err)
  		return -EINVAL;
 -	if (port_num < 1 ||
 -	    port_num > ibdev->phys_port_cnt)
 +	if (ah_attr->port_num < 1 ||
 +	    ah_attr->port_num > ibdev->phys_port_cnt)
  		return -EINVAL;
 -	if (static_rate != IB_RATE_PORT_CURRENT &&
 -	    ib_rate_to_mbps(static_rate) < 0)
 +	if (ah_attr->static_rate != IB_RATE_PORT_CURRENT &&
 +	    ib_rate_to_mbps(ah_attr->static_rate) < 0)
  		return -EINVAL;
 -	if ((ah_flags & IB_AH_GRH) &&
 -	    rdma_ah_read_grh(ah_attr)->sgid_index >= port_attr.gid_tbl_len)
 +	if ((ah_attr->ah_flags & IB_AH_GRH) &&
 +	    ah_attr->grh.sgid_index >= port_attr.gid_tbl_len)
  		return -EINVAL;
++<<<<<<< HEAD
 +	if (link != IB_LINK_LAYER_ETHERNET) {
 +		if (ah_attr->dlid == 0)
 +			return -EINVAL;
 +		if (ah_attr->dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE) &&
 +		    ah_attr->dlid != be16_to_cpu(IB_LID_PERMISSIVE) &&
 +		    !(ah_attr->ah_flags & IB_AH_GRH))
 +			return -EINVAL;
 +	}
++=======
++>>>>>>> 13c19222889d (IB/rdmavt, hfi1, qib: Modify check_ah() to account for extended LIDs)
  	if (rdi->driver_f.check_ah)
  		return rdi->driver_f.check_ah(ibdev, ah_attr);
  	return 0;
diff --cc drivers/infiniband/sw/rdmavt/qp.c
index 5ffa730e62c7,6f6525d24a2f..000000000000
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@@ -1086,16 -1089,31 +1089,42 @@@ int rvt_modify_qp(struct ib_qp *ibqp, s
  		goto inval;
  
  	if (attr_mask & IB_QP_AV) {
++<<<<<<< HEAD
 +		if (attr->ah_attr.dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE))
 +			goto inval;
++=======
+ 		if (opa_ah) {
+ 			if (rdma_ah_get_dlid(&attr->ah_attr) >=
+ 				opa_get_mcast_base(OPA_MCAST_NR))
+ 				goto inval;
+ 		} else {
+ 			if (rdma_ah_get_dlid(&attr->ah_attr) >=
+ 				be16_to_cpu(IB_MULTICAST_LID_BASE))
+ 				goto inval;
+ 		}
+ 
++>>>>>>> 13c19222889d (IB/rdmavt, hfi1, qib: Modify check_ah() to account for extended LIDs)
  		if (rvt_check_ah(qp->ibqp.device, &attr->ah_attr))
  			goto inval;
  	}
  
  	if (attr_mask & IB_QP_ALT_PATH) {
++<<<<<<< HEAD
 +		if (attr->alt_ah_attr.dlid >=
 +		    be16_to_cpu(IB_MULTICAST_LID_BASE))
 +			goto inval;
++=======
+ 		if (opa_ah) {
+ 			if (rdma_ah_get_dlid(&attr->alt_ah_attr) >=
+ 				opa_get_mcast_base(OPA_MCAST_NR))
+ 				goto inval;
+ 		} else {
+ 			if (rdma_ah_get_dlid(&attr->alt_ah_attr) >=
+ 				be16_to_cpu(IB_MULTICAST_LID_BASE))
+ 				goto inval;
+ 		}
+ 
++>>>>>>> 13c19222889d (IB/rdmavt, hfi1, qib: Modify check_ah() to account for extended LIDs)
  		if (rvt_check_ah(qp->ibqp.device, &attr->alt_ah_attr))
  			goto inval;
  		if (attr->alt_pkey_index >= rvt_get_npkeys(rdi))
diff --cc include/rdma/opa_addr.h
index eace28f1555d,8d3ad4ecbea1..000000000000
--- a/include/rdma/opa_addr.h
+++ b/include/rdma/opa_addr.h
@@@ -48,9 -48,21 +48,20 @@@
  #ifndef OPA_ADDR_H
  #define OPA_ADDR_H
  
+ #include <rdma/opa_smi.h>
+ 
  #define	OPA_SPECIAL_OUI		(0x00066AULL)
  #define OPA_MAKE_ID(x)          (cpu_to_be64(OPA_SPECIAL_OUI << 40 | (x)))
 -#define OPA_TO_IB_UCAST_LID(x) (((x) >= be16_to_cpu(IB_MULTICAST_LID_BASE)) \
 -				? 0 : x)
 +
+ /**
+  * 0xF8 - 4 bits of multicast range and 1 bit for collective range
+  * Example: For 24 bit LID space,
+  * Multicast range: 0xF00000 to 0xF7FFFF
+  * Collective range: 0xF80000 to 0xFFFFFE
+  */
+ #define OPA_MCAST_NR 0x4 /* Number of top bits set */
+ #define OPA_COLLECTIVE_NR 0x1 /* Number of bits after MCAST_NR */
+ 
  /**
   * ib_is_opa_gid: Returns true if the top 24 bits of the gid
   * contains the OPA_STL_OUI identifier. This identifies that
@@@ -76,4 -88,29 +87,32 @@@ static inline u32 opa_get_lid_from_gid(
  {
  	return be64_to_cpu(gid->global.interface_id) & 0xFFFFFFFF;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * opa_is_extended_lid: Returns true if dlid or slid are
+  * extended.
+  *
+  * @dlid: The DLID
+  * @slid: The SLID
+  */
+ static inline bool opa_is_extended_lid(u32 dlid, u32 slid)
+ {
+ 	if ((be32_to_cpu(dlid) >=
+ 	     be16_to_cpu(IB_MULTICAST_LID_BASE)) ||
+ 	    (be32_to_cpu(slid) >=
+ 	     be16_to_cpu(IB_MULTICAST_LID_BASE)))
+ 		return true;
+ 	else
+ 		return false;
+ }
+ 
+ /* Get multicast lid base */
+ static inline u32 opa_get_mcast_base(u32 nr_top_bits)
+ {
+ 	return (be32_to_cpu(OPA_LID_PERMISSIVE) << (32 - nr_top_bits));
+ }
+ 
++>>>>>>> 13c19222889d (IB/rdmavt, hfi1, qib: Modify check_ah() to account for extended LIDs)
  #endif /* OPA_ADDR_H */
diff --git a/drivers/infiniband/hw/hfi1/common.h b/drivers/infiniband/hw/hfi1/common.h
index 995d62c7f9a7..316900d43534 100644
--- a/drivers/infiniband/hw/hfi1/common.h
+++ b/drivers/infiniband/hw/hfi1/common.h
@@ -332,15 +332,6 @@ struct diag_pkt {
 
 #define DEFAULT_P_KEY LIM_MGMT_P_KEY
 
-/**
- * 0xF8 - 4 bits of multicast range and 1 bit for collective range
- * Example: For 24 bit LID space,
- * Multicast range: 0xF00000 to 0xF7FFFF
- * Collective range: 0xF80000 to 0xFFFFFE
- */
-#define HFI1_MCAST_NR 0x4 /* Number of top bits set */
-#define HFI1_COLLECTIVE_NR 0x1 /* Number of bits after MCAST_NR */
-
 #define HFI1_PSM_IOC_BASE_SEQ 0x0
 
 static inline __u64 rhf_to_cpu(const __le32 *rbuf)
diff --git a/drivers/infiniband/hw/hfi1/mad.c b/drivers/infiniband/hw/hfi1/mad.c
index d59426fb9866..1240abef2cf6 100644
--- a/drivers/infiniband/hw/hfi1/mad.c
+++ b/drivers/infiniband/hw/hfi1/mad.c
@@ -46,6 +46,7 @@
  */
 
 #include <linux/net.h>
+#include <rdma/opa_addr.h>
 #define OPA_NUM_PKEY_BLOCKS_PER_SMP (OPA_SMP_DR_DATA_SIZE \
 			/ (OPA_PARTITION_TABLE_BLK_SIZE * sizeof(u16)))
 
@@ -715,8 +716,8 @@ static int __subn_get_opa_portinfo(struct opa_smp *smp, u32 am, u8 *data,
 	pi->buffer_units = cpu_to_be32(buffer_units);
 
 	pi->opa_cap_mask = cpu_to_be16(ibp->rvp.port_cap3_flags);
-	pi->collectivemask_multicastmask = ((HFI1_COLLECTIVE_NR & 0x7)
-					    << 3 | (HFI1_MCAST_NR & 0x7));
+	pi->collectivemask_multicastmask = ((OPA_COLLECTIVE_NR & 0x7)
+					    << 3 | (OPA_MCAST_NR & 0x7));
 
 	/* HFI supports a replay buffer 128 LTPs in size */
 	pi->replay_depth.buffer = 0x80;
diff --git a/drivers/infiniband/hw/hfi1/verbs.c b/drivers/infiniband/hw/hfi1/verbs.c
index 06ac08cf82a6..1540b76a2b31 100644
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@ -53,6 +53,7 @@
 #include <linux/rculist.h>
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
+#include <rdma/opa_addr.h>
 
 #include "hfi.h"
 #include "common.h"
@@ -1471,6 +1472,10 @@ static int hfi1_check_ah(struct ib_device *ibdev, struct ib_ah_attr *ah_attr)
 	struct hfi1_devdata *dd;
 	u8 sc5;
 
+	if (hfi1_check_mcast(rdma_ah_get_dlid(ah_attr)) &&
+	    !(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH))
+		return -EINVAL;
+
 	/* test the mapping for validity */
 	ibp = to_iport(ibdev, ah_attr->port_num);
 	ppd = ppd_from_ibp(ibp);
diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
index f1ccc4aa53fa..7888ba4e3458 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@ -1340,6 +1340,15 @@ int qib_check_ah(struct ib_device *ibdev, struct ib_ah_attr *ah_attr)
 	if (ah_attr->sl > 15)
 		return -EINVAL;
 
+	if (rdma_ah_get_dlid(ah_attr) == 0)
+		return -EINVAL;
+	if (rdma_ah_get_dlid(ah_attr) >=
+		be16_to_cpu(IB_MULTICAST_LID_BASE) &&
+	    rdma_ah_get_dlid(ah_attr) !=
+		be16_to_cpu(IB_LID_PERMISSIVE) &&
+	    !(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH))
+		return -EINVAL;
+
 	return 0;
 }
 
* Unmerged path drivers/infiniband/sw/rdmavt/ah.c
* Unmerged path drivers/infiniband/sw/rdmavt/qp.c
* Unmerged path include/rdma/opa_addr.h
