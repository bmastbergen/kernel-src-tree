net: move pskb_put() to core code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] move pskb_put() to core code (Jiri Benc) [1497085]
Rebuild_FUZZ: 91.80%
commit-author Mathias Krause <mathias.krause@secunet.com>
commit 0c7ddf36c29c3ce12f2d2931a357ccaa0861035a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0c7ddf36.failed

This function has usage beside IPsec so move it to the core skbuff code.
While doing so, give it some documentation and change its return type to
'unsigned char *' to be in line with skb_put().

	Signed-off-by: Mathias Krause <mathias.krause@secunet.com>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0c7ddf36c29c3ce12f2d2931a357ccaa0861035a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/esp.h
diff --cc include/net/esp.h
index d58451331dbd,a43be85aedc4..000000000000
--- a/include/net/esp.h
+++ b/include/net/esp.h
@@@ -3,18 -3,6 +3,21 @@@
  
  #include <linux/skbuff.h>
  
++<<<<<<< HEAD
 +struct crypto_aead;
 +
 +struct esp_data {
 +	/* 0..255 */
 +	int padlen;
 +
 +	/* Confidentiality & Integrity */
 +	struct crypto_aead *aead;
 +};
 +
 +extern void *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len);
 +
++=======
++>>>>>>> 0c7ddf36c29c (net: move pskb_put() to core code)
  struct ip_esp_hdr;
  
  static inline struct ip_esp_hdr *ip_esp_hdr(const struct sk_buff *skb)
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 28aefdf34562..91f46ce73bea 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1918,6 +1918,7 @@ static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
 /*
  *	Add data to an sk_buff
  */
+unsigned char *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len);
 unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
 static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
 {
* Unmerged path include/net/esp.h
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 1810381d0deb..72a9ac5a9b3e 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -1452,6 +1452,29 @@ free_skb:
 }
 EXPORT_SYMBOL(skb_pad);
 
+/**
+ *	pskb_put - add data to the tail of a potentially fragmented buffer
+ *	@skb: start of the buffer to use
+ *	@tail: tail fragment of the buffer to use
+ *	@len: amount of data to add
+ *
+ *	This function extends the used data area of the potentially
+ *	fragmented buffer. @tail must be the last fragment of @skb -- or
+ *	@skb itself. If this would exceed the total buffer size the kernel
+ *	will panic. A pointer to the first byte of the extra data is
+ *	returned.
+ */
+
+unsigned char *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len)
+{
+	if (tail != skb) {
+		skb->data_len += len;
+		skb->len += len;
+	}
+	return skb_put(tail, len);
+}
+EXPORT_SYMBOL_GPL(pskb_put);
+
 /**
  *	skb_put - add data to a buffer
  *	@skb: buffer to use
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
index ab4ef72f0b1d..debe733386f8 100644
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -802,17 +802,4 @@ int xfrm_count_pfkey_enc_supported(void)
 }
 EXPORT_SYMBOL_GPL(xfrm_count_pfkey_enc_supported);
 
-#if defined(CONFIG_INET_ESP) || defined(CONFIG_INET_ESP_MODULE) || defined(CONFIG_INET6_ESP) || defined(CONFIG_INET6_ESP_MODULE)
-
-void *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len)
-{
-	if (tail != skb) {
-		skb->data_len += len;
-		skb->len += len;
-	}
-	return skb_put(tail, len);
-}
-EXPORT_SYMBOL_GPL(pskb_put);
-#endif
-
 MODULE_LICENSE("GPL");
