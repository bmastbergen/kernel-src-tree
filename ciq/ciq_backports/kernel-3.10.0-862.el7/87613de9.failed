vxlan: fix snooping for link-local IPv6 addresses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthias Schiffer <mschiffer@universe-factory.net>
commit 87613de95041a88e426105d05a53acece52fd81e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/87613de9.failed

If VXLAN is run over link-local IPv6 addresses, it is necessary to store
the ifindex in the FDB entries. Otherwise, the used interface is undefined
and unicast communication will most likely fail.

Support for link-local IPv4 addresses should be possible as well, but as
the semantics aren't as well defined as for IPv6, and there doesn't seem to
be much interest in having the support, it's not implemented for now.

	Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 87613de95041a88e426105d05a53acece52fd81e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 740e6d79f5f2,45a8a5475f3d..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -917,12 -956,20 +917,24 @@@ out
   * Return true if packet is bogus and should be dropped.
   */
  static bool vxlan_snoop(struct net_device *dev,
++<<<<<<< HEAD
 +			union vxlan_addr *src_ip, const u8 *src_mac)
++=======
+ 			union vxlan_addr *src_ip, const u8 *src_mac,
+ 			u32 src_ifindex, __be32 vni)
++>>>>>>> 87613de95041 (vxlan: fix snooping for link-local IPv6 addresses)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct vxlan_fdb *f;
+ 	u32 ifindex = 0;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (src_ip->sa.sa_family == AF_INET6 &&
+ 	    (ipv6_addr_type(&src_ip->sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL))
+ 		ifindex = src_ifindex;
+ #endif
  
 -	f = vxlan_find_mac(vxlan, src_mac, vni);
 +	f = vxlan_find_mac(vxlan, src_mac);
  	if (likely(f)) {
  		struct vxlan_rdst *rdst = first_remote_rcu(f);
  
@@@ -951,8 -999,9 +964,8 @@@
  					 NUD_REACHABLE,
  					 NLM_F_EXCL|NLM_F_CREATE,
  					 vxlan->cfg.dst_port,
 -					 vni,
  					 vxlan->default_dst.remote_vni,
- 					 0, NTF_SELF);
+ 					 ifindex, NTF_SELF);
  		spin_unlock(&vxlan->hash_lock);
  	}
  
@@@ -1205,9 -1269,10 +1218,10 @@@ static bool vxlan_parse_gpe_hdr(struct 
  
  static bool vxlan_set_mac(struct vxlan_dev *vxlan,
  			  struct vxlan_sock *vs,
 -			  struct sk_buff *skb, __be32 vni)
 +			  struct sk_buff *skb)
  {
  	union vxlan_addr saddr;
+ 	u32 ifindex = skb->dev->ifindex;
  
  	skb_reset_mac_header(skb);
  	skb->protocol = eth_type_trans(skb, vxlan->dev);
@@@ -1228,8 -1293,8 +1242,13 @@@
  #endif
  	}
  
++<<<<<<< HEAD
 +	if ((vxlan->flags & VXLAN_F_LEARN) &&
 +	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source))
++=======
+ 	if ((vxlan->cfg.flags & VXLAN_F_LEARN) &&
+ 	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source, ifindex, vni))
++>>>>>>> 87613de95041 (vxlan: fix snooping for link-local IPv6 addresses)
  		return false;
  
  	return true;
@@@ -1882,8 -2002,9 +1901,14 @@@ static void vxlan_encap_bypass(struct s
  #endif
  	}
  
++<<<<<<< HEAD
 +	if (dst_vxlan->flags & VXLAN_F_LEARN)
 +		vxlan_snoop(skb->dev, &loopback, eth_hdr(skb)->h_source);
++=======
+ 	if (dst_vxlan->cfg.flags & VXLAN_F_LEARN)
+ 		vxlan_snoop(skb->dev, &loopback, eth_hdr(skb)->h_source, 0,
+ 			    vni);
++>>>>>>> 87613de95041 (vxlan: fix snooping for link-local IPv6 addresses)
  
  	u64_stats_update_begin(&tx_stats->syncp);
  	tx_stats->tx_packets++;
* Unmerged path drivers/net/vxlan.c
