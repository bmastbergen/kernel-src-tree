arp: always override existing neigh entries with gratuitous ARP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ihar Hrachyshka <ihrachys@redhat.com>
commit 7d472a59c0e5ec117220a05de6b370447fb6cb66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7d472a59.failed

Currently, when arp_accept is 1, we always override existing neigh
entries with incoming gratuitous ARP replies. Otherwise, we override
them only if new replies satisfy _locktime_ conditional (packets arrive
not earlier than _locktime_ seconds since the last update to the neigh
entry).

The idea behind locktime is to pick the very first (=> close) reply
received in a unicast burst when ARP proxies are used. This helps to
avoid ARP thrashing where Linux would switch back and forth from one
proxy to another.

This logic has nothing to do with gratuitous ARP replies that are
generally not aligned in time when multiple IP address carriers send
them into network.

This patch enforces overriding of existing neigh entries by all incoming
gratuitous ARP packets, irrespective of their time of arrival. This will
make the kernel honour all incoming gratuitous ARP packets.

	Signed-off-by: Ihar Hrachyshka <ihrachys@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7d472a59c0e5ec117220a05de6b370447fb6cb66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/arp.c
diff --cc net/ipv4/arp.c
index 98def2add661,ae96e6f3e0cb..000000000000
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@@ -914,15 -863,25 +914,35 @@@ static int arp_process(struct sock *sk
  
  	n = __neigh_lookup(&arp_tbl, &sip, dev, 0);
  
++<<<<<<< HEAD
++=======
+ 	if (n || IN_DEV_ARP_ACCEPT(in_dev)) {
+ 		addr_type = -1;
+ 		is_garp = arp_is_garp(net, dev, &addr_type, arp->ar_op,
+ 				      sip, tip, sha, tha);
+ 	}
+ 
++>>>>>>> 7d472a59c0e5 (arp: always override existing neigh entries with gratuitous ARP)
  	if (IN_DEV_ARP_ACCEPT(in_dev)) {
  		/* Unsolicited ARP is not accepted by default.
  		   It is possible, that this option should be enabled for some
  		   devices (strip is candidate)
  		 */
++<<<<<<< HEAD
 +		if (n == NULL &&
 +		    (arp->ar_op == htons(ARPOP_REPLY) ||
 +		     (arp->ar_op == htons(ARPOP_REQUEST) && tip == sip)) &&
 +		    inet_addr_type(net, sip) == RTN_UNICAST)
++=======
+ 		if (!n &&
+ 		    (is_garp ||
+ 		     (arp->ar_op == htons(ARPOP_REPLY) &&
+ 		      (addr_type == RTN_UNICAST ||
+ 		       (addr_type < 0 &&
+ 			/* postpone calculation to as late as possible */
+ 			inet_addr_type_dev_table(net, dev, sip) ==
+ 				RTN_UNICAST)))))
++>>>>>>> 7d472a59c0e5 (arp: always override existing neigh entries with gratuitous ARP)
  			n = __neigh_lookup(&arp_tbl, &sip, dev, 1);
  	}
  
* Unmerged path net/ipv4/arp.c
