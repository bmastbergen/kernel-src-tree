power_supply: Add power_supply_put for decrementing device reference counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Krzysztof Kozlowski <k.kozlowski@samsung.com>
commit 1a352462b5377ac68f5955d674b3460c7bac52a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1a352462.failed

The power_supply_get_by_phandle() and power_supply_get_by_name() use
function class_find_device() for obtaining the reference to power
supply. Each use of class_find_device() increases the power supply's
device reference counter.

However the reference counter was not decreased by users of this API.
Thus final device_unregister() call from power_supply_unregister() could
not release the device and clean up its resources. This lead to memory
leak if at least once power_supply_get_by_*() was called between
registering and unregistering the power supply.

Add and document new API power_supply_put() for decrementing the
reference counter.

	Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
	Acked-by: Pavel Machek <pavel@ucw.cz>
	Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Reviewed-by: Sebastian Reichel <sre@kernel.org>
	Signed-off-by: Sebastian Reichel <sre@kernel.org>
(cherry picked from commit 1a352462b5377ac68f5955d674b3460c7bac52a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/power/power_supply_core.c
#	include/linux/power_supply.h
diff --cc drivers/power/power_supply_core.c
index 0d8164e2f763,b4ec14683b7f..000000000000
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@@ -319,9 -333,20 +319,20 @@@ static int power_supply_match_device_by
  	const char *name = data;
  	struct power_supply *psy = dev_get_drvdata(dev);
  
 -	return strcmp(psy->desc->name, name) == 0;
 +	return strcmp(psy->name, name) == 0;
  }
  
+ /**
+  * power_supply_get_by_name() - Search for a power supply and returns its ref
+  * @name: Power supply name to fetch
+  *
+  * If power supply was found, it increases reference count for the
+  * internal power supply's device. The user should power_supply_put()
+  * after usage.
+  *
+  * Return: On success returns a reference to a power supply with
+  * matching name equals to @name, a NULL otherwise.
+  */
  struct power_supply *power_supply_get_by_name(const char *name)
  {
  	struct device *dev = class_find_device(power_supply_class, NULL, name,
@@@ -331,9 -356,105 +342,108 @@@
  }
  EXPORT_SYMBOL_GPL(power_supply_get_by_name);
  
++<<<<<<< HEAD
++=======
+ /**
+  * power_supply_put() - Drop reference obtained with power_supply_get_by_name
+  * @psy: Reference to put
+  *
+  * The reference to power supply should be put before unregistering
+  * the power supply.
+  */
+ void power_supply_put(struct power_supply *psy)
+ {
+ 	might_sleep();
+ 
+ 	put_device(&psy->dev);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_put);
+ 
+ #ifdef CONFIG_OF
+ static int power_supply_match_device_node(struct device *dev, const void *data)
+ {
+ 	return dev->parent && dev->parent->of_node == data;
+ }
+ 
+ /**
+  * power_supply_get_by_phandle() - Search for a power supply and returns its ref
+  * @np: Pointer to device node holding phandle property
+  * @phandle_name: Name of property holding a power supply name
+  *
+  * If power supply was found, it increases reference count for the
+  * internal power supply's device. The user should power_supply_put()
+  * after usage.
+  *
+  * Return: On success returns a reference to a power supply with
+  * matching name equals to value under @property, NULL or ERR_PTR otherwise.
+  */
+ struct power_supply *power_supply_get_by_phandle(struct device_node *np,
+ 							const char *property)
+ {
+ 	struct device_node *power_supply_np;
+ 	struct device *dev;
+ 
+ 	power_supply_np = of_parse_phandle(np, property, 0);
+ 	if (!power_supply_np)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	dev = class_find_device(power_supply_class, NULL, power_supply_np,
+ 						power_supply_match_device_node);
+ 
+ 	of_node_put(power_supply_np);
+ 
+ 	return dev ? dev_get_drvdata(dev) : NULL;
+ }
+ EXPORT_SYMBOL_GPL(power_supply_get_by_phandle);
+ #endif /* CONFIG_OF */
+ 
+ int power_supply_get_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    union power_supply_propval *val)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->get_property(psy, psp, val);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_get_property);
+ 
+ int power_supply_set_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    const union power_supply_propval *val)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 || !psy->desc->set_property)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->set_property(psy, psp, val);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_set_property);
+ 
+ int power_supply_property_is_writeable(struct power_supply *psy,
+ 					enum power_supply_property psp)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 ||
+ 			!psy->desc->property_is_writeable)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->property_is_writeable(psy, psp);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_property_is_writeable);
+ 
+ void power_supply_external_power_changed(struct power_supply *psy)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 ||
+ 			!psy->desc->external_power_changed)
+ 		return;
+ 
+ 	psy->desc->external_power_changed(psy);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_external_power_changed);
+ 
++>>>>>>> 1a352462b537 (power_supply: Add power_supply_put for decrementing device reference counter)
  int power_supply_powers(struct power_supply *psy, struct device *dev)
  {
 -	return sysfs_create_link(&psy->dev.kobj, &dev->kobj, "powers");
 +	return sysfs_create_link(&psy->dev->kobj, &dev->kobj, "powers");
  }
  EXPORT_SYMBOL_GPL(power_supply_powers);
  
diff --cc include/linux/power_supply.h
index b5a0d5291835,75a1dd8dc56e..000000000000
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@@ -238,7 -278,19 +238,19 @@@ struct power_supply_info 
  	int use_for_apm;
  };
  
 -extern struct atomic_notifier_head power_supply_notifier;
 -extern int power_supply_reg_notifier(struct notifier_block *nb);
 -extern void power_supply_unreg_notifier(struct notifier_block *nb);
  extern struct power_supply *power_supply_get_by_name(const char *name);
++<<<<<<< HEAD
++=======
+ extern void power_supply_put(struct power_supply *psy);
+ #ifdef CONFIG_OF
+ extern struct power_supply *power_supply_get_by_phandle(struct device_node *np,
+ 							const char *property);
+ #else /* !CONFIG_OF */
+ static inline struct power_supply *
+ power_supply_get_by_phandle(struct device_node *np, const char *property)
+ { return NULL; }
+ #endif /* CONFIG_OF */
++>>>>>>> 1a352462b537 (power_supply: Add power_supply_put for decrementing device reference counter)
  extern void power_supply_changed(struct power_supply *psy);
  extern int power_supply_am_i_supplied(struct power_supply *psy);
  extern int power_supply_set_battery_charged(struct power_supply *psy);
* Unmerged path drivers/power/power_supply_core.c
* Unmerged path include/linux/power_supply.h
