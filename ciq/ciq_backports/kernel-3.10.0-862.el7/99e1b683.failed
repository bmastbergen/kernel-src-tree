scsi: qla2xxx: Add ql2xiniexchg parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add ql2xiniexchg parameter (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 92.11%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 99e1b683c4be3fee5cff824af18411cf8cc568d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/99e1b683.failed

Previously, the ql2xexchoffld module parameter was used to control the
max number of exchanges to be offload onto host memory.

Module parameter ql_dm_tgt_ex_pct was used to control the percentage of
exchanges allocated to the Target side.

With this patch, module parameter ql_dm_tgt_ex_pct is no longer used to
control exchanges for the driver. New module parameter ql2xiniexchg is
added to control exchanges between target mode and initiator mode.

With the updated module parameters, users can control the exact number
of exchanges for either Initiator or Target. The exchange offload
feature will be automatically enabled when the total number of exchanges
exceeds 2048 limit.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 99e1b683c4be3fee5cff824af18411cf8cc568d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,ddf93efe3986..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -273,18 -286,10 +273,22 @@@
  #define RESPONSE_ENTRY_CNT_MQ		128	/* Number of response entries.*/
  #define ATIO_ENTRY_CNT_24XX		4096	/* Number of ATIO entries. */
  #define RESPONSE_ENTRY_CNT_FX00		256     /* Number of response entries.*/
++<<<<<<< HEAD
++=======
+ #define FW_DEF_EXCHANGES_CNT 2048
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  
  struct req_que;
 -struct qla_tgt_sess;
 +
 +/*
 + * (sd.h is not exported, hence local inclusion)
 + * Data Integrity Field tuple.
 + */
 +struct sd_dif_tuple {
 +	__be16 guard_tag;	/* Checksum */
 +	__be16 app_tag;		/* Opaque storage */
 +	__be32 ref_tag;		/* Target LBA or indirect LBA */
 +};
  
  /*
   * SCSI Request Block
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,f8540f5c9e5d..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -118,10 -132,14 +118,16 @@@ extern int ql2xenabledif
  extern int ql2xenablehba_err_chk;
  extern int ql2xtargetreset;
  extern int ql2xdontresethba;
 -extern uint64_t ql2xmaxlun;
 +extern unsigned int ql2xmaxlun;
  extern int ql2xmdcapmask;
  extern int ql2xmdenable;
++<<<<<<< HEAD
++=======
+ extern int ql2xexlogins;
+ extern int ql2xexchoffld;
+ extern int ql2xiniexchg;
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  extern int ql2xfwholdabts;
 -extern int ql2xmvasynctoatio;
  
  extern int qla2x00_loop_reset(scsi_qla_host_t *);
  extern void qla2x00_abort_all_cmds(scsi_qla_host_t *, int);
@@@ -782,4 -835,27 +788,30 @@@ extern void qla82xx_mbx_completion(scsi
  extern int qla8044_abort_isp(scsi_qla_host_t *);
  extern int qla8044_check_fw_alive(struct scsi_qla_host *);
  
++<<<<<<< HEAD
++=======
+ extern void qlt_host_reset_handler(struct qla_hw_data *ha);
+ extern int qla_get_exlogin_status(scsi_qla_host_t *, uint16_t *,
+ 	uint16_t *);
+ extern int qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr);
+ extern int qla_get_exchoffld_status(scsi_qla_host_t *, uint16_t *, uint16_t *);
+ extern int qla_set_exchoffld_mem_cfg(scsi_qla_host_t *);
+ extern void qlt_handle_abts_recv(struct scsi_qla_host *, response_t *);
+ 
+ int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
+ 	struct imm_ntfy_from_isp *, int);
+ void qla24xx_do_nack_work(struct scsi_qla_host *, struct qla_work_evt *);
+ void qlt_plogi_ack_link(struct scsi_qla_host *, struct qlt_plogi_ack_t *,
+ 	struct fc_port *, enum qlt_plogi_link_t);
+ void qlt_plogi_ack_unref(struct scsi_qla_host *, struct qlt_plogi_ack_t *);
+ extern void qlt_schedule_sess_for_deletion(struct fc_port *, bool);
+ extern void qlt_schedule_sess_for_deletion_lock(struct fc_port *);
+ extern struct fc_port *qlt_find_sess_invalidate_other(scsi_qla_host_t *,
+ 	uint64_t wwn, port_id_t port_id, uint16_t loop_id, struct fc_port **);
+ void qla24xx_delete_sess_fn(struct work_struct *);
+ void qlt_unknown_atio_work_fn(struct work_struct *);
+ void qlt_update_host_map(struct scsi_qla_host *, port_id_t);
+ void qlt_remove_target_resources(struct qla_hw_data *);
+ 
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,08000aebe8d4..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1841,6 -2720,12 +1841,15 @@@ qla2x00_setup_chip(scsi_qla_host_t *vha
  			ql_dbg(ql_dbg_init, vha, 0x00ca,
  			    "Starting firmware.\n");
  
++<<<<<<< HEAD
++=======
+ 			if (ql2xexlogins)
+ 				ha->flags.exlogins_enabled = 1;
+ 
+ 			if (qla_is_exch_offld_enabled(vha))
+ 				ha->flags.exchoffld_enabled = 1;
+ 
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  			rval = qla2x00_execute_fw(vha, srisc_address);
  			/* Retrieve firmware information. */
  			if (rval == QLA_SUCCESS) {
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 21eee93873e8,bebac42d9e9e..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -611,6 -639,224 +611,227 @@@ qla2x00_execute_fw(scsi_qla_host_t *vha
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * qla_get_exlogin_status
+  *	Get extended login status
+  *	uses the memory offload control/status Mailbox
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	fwopt:		firmware options
+  *
+  * Returns:
+  *	qla2x00 local function status
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define	FETCH_XLOGINS_STAT	0x8
+ int
+ qla_get_exlogin_status(scsi_qla_host_t *vha, uint16_t *buf_sz,
+ 	uint16_t *ex_logins_cnt)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118f,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = FETCH_XLOGINS_STAT;
+ 	mcp->out_mb = MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_10|MBX_4|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1115, "Failed=%x.\n", rval);
+ 	} else {
+ 		*buf_sz = mcp->mb[4];
+ 		*ex_logins_cnt = mcp->mb[10];
+ 
+ 		ql_log(ql_log_info, vha, 0x1190,
+ 		    "buffer size 0x%x, exchange login count=%d\n",
+ 		    mcp->mb[4], mcp->mb[10]);
+ 
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1116,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+  * qla_set_exlogin_mem_cfg
+  *	set extended login memory configuration
+  *	Mbx needs to be issues before init_cb is set
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	buffer:		buffer pointer
+  *	phys_addr:	physical address of buffer
+  *	size:		size of buffer
+  *	TARGET_QUEUE_LOCK must be released
+  *	ADAPTER_STATE_LOCK must be release
+  *
+  * Returns:
+  *	qla2x00 local funxtion status code.
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define CONFIG_XLOGINS_MEM	0x3
+ int
+ qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr)
+ {
+ 	int		rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111a,
+ 	    "Entered %s.\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = CONFIG_XLOGINS_MEM;
+ 	mcp->mb[2] = MSW(phys_addr);
+ 	mcp->mb[3] = LSW(phys_addr);
+ 	mcp->mb[6] = MSW(MSD(phys_addr));
+ 	mcp->mb[7] = LSW(MSD(phys_addr));
+ 	mcp->mb[8] = MSW(ha->exlogin_size);
+ 	mcp->mb[9] = LSW(ha->exlogin_size);
+ 	mcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_11|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		/*EMPTY*/
+ 		ql_dbg(ql_dbg_mbx, vha, 0x111b, "Failed=%x.\n", rval);
+ 	} else {
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118c,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+  * qla_get_exchoffld_status
+  *	Get exchange offload status
+  *	uses the memory offload control/status Mailbox
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	fwopt:		firmware options
+  *
+  * Returns:
+  *	qla2x00 local function status
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define	FETCH_XCHOFFLD_STAT	0x2
+ int
+ qla_get_exchoffld_status(scsi_qla_host_t *vha, uint16_t *buf_sz,
+ 	uint16_t *ex_logins_cnt)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1019,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = FETCH_XCHOFFLD_STAT;
+ 	mcp->out_mb = MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_10|MBX_4|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1155, "Failed=%x.\n", rval);
+ 	} else {
+ 		*buf_sz = mcp->mb[4];
+ 		*ex_logins_cnt = mcp->mb[10];
+ 
+ 		ql_log(ql_log_info, vha, 0x118e,
+ 		    "buffer size 0x%x, exchange offload count=%d\n",
+ 		    mcp->mb[4], mcp->mb[10]);
+ 
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1156,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+  * qla_set_exchoffld_mem_cfg
+  *	Set exchange offload memory configuration
+  *	Mbx needs to be issues before init_cb is set
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	buffer:		buffer pointer
+  *	phys_addr:	physical address of buffer
+  *	size:		size of buffer
+  *	TARGET_QUEUE_LOCK must be released
+  *	ADAPTER_STATE_LOCK must be release
+  *
+  * Returns:
+  *	qla2x00 local funxtion status code.
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define CONFIG_XCHOFFLD_MEM	0x3
+ int
+ qla_set_exchoffld_mem_cfg(scsi_qla_host_t *vha)
+ {
+ 	int		rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1157,
+ 	    "Entered %s.\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = CONFIG_XCHOFFLD_MEM;
+ 	mcp->mb[2] = MSW(ha->exchoffld_buf_dma);
+ 	mcp->mb[3] = LSW(ha->exchoffld_buf_dma);
+ 	mcp->mb[6] = MSW(MSD(ha->exchoffld_buf_dma));
+ 	mcp->mb[7] = LSW(MSD(ha->exchoffld_buf_dma));
+ 	mcp->mb[8] = MSW(ha->exchoffld_size);
+ 	mcp->mb[9] = LSW(ha->exchoffld_size);
+ 	mcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_11|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		/*EMPTY*/
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1158, "Failed=%x.\n", rval);
+ 	} else {
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1192,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
   * qla2x00_get_fw_version
   *	Get firmware version.
   *
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 4e0d0a2f9461,dcf50aa61e9d..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -217,6 -218,22 +217,25 @@@ MODULE_PARM_DESC(ql2xmdenable
  		"0 - MiniDump disabled. "
  		"1 (Default) - MiniDump enabled.");
  
++<<<<<<< HEAD
++=======
+ int ql2xexlogins = 0;
+ module_param(ql2xexlogins, uint, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(ql2xexlogins,
+ 		 "Number of extended Logins. "
+ 		 "0 (Default)- Disabled.");
+ 
+ int ql2xexchoffld = 1024;
+ module_param(ql2xexchoffld, uint, 0644);
+ MODULE_PARM_DESC(ql2xexchoffld,
+ 	"Number of target exchanges.");
+ 
+ int ql2xiniexchg = 1024;
+ module_param(ql2xiniexchg, uint, 0644);
+ MODULE_PARM_DESC(ql2xiniexchg,
+ 	"Number of initiator exchanges.");
+ 
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  int ql2xfwholdabts = 0;
  module_param(ql2xfwholdabts, int, S_IRUGO);
  MODULE_PARM_DESC(ql2xfwholdabts,
@@@ -3946,6 -3979,198 +3965,201 @@@ fail
  	return -ENOMEM;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ qla2x00_set_exlogins_buffer(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	uint16_t	size, max_cnt, temp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	/* Return if we don't need to alloacate any extended logins */
+ 	if (!ql2xexlogins)
+ 		return QLA_SUCCESS;
+ 
+ 	if (!IS_EXLOGIN_OFFLD_CAPABLE(ha))
+ 		return QLA_SUCCESS;
+ 
+ 	ql_log(ql_log_info, vha, 0xd021, "EXLOGIN count: %d.\n", ql2xexlogins);
+ 	max_cnt = 0;
+ 	rval = qla_get_exlogin_status(vha, &size, &max_cnt);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd029,
+ 		    "Failed to get exlogin status.\n");
+ 		return rval;
+ 	}
+ 
+ 	temp = (ql2xexlogins > max_cnt) ? max_cnt : ql2xexlogins;
+ 	temp *= size;
+ 
+ 	if (temp != ha->exlogin_size) {
+ 		qla2x00_free_exlogin_buffer(ha);
+ 		ha->exlogin_size = temp;
+ 
+ 		ql_log(ql_log_info, vha, 0xd024,
+ 		    "EXLOGIN: max_logins=%d, portdb=0x%x, total=%d.\n",
+ 		    max_cnt, size, temp);
+ 
+ 		ql_log(ql_log_info, vha, 0xd025,
+ 		    "EXLOGIN: requested size=0x%x\n", ha->exlogin_size);
+ 
+ 		/* Get consistent memory for extended logins */
+ 		ha->exlogin_buf = dma_alloc_coherent(&ha->pdev->dev,
+ 			ha->exlogin_size, &ha->exlogin_buf_dma, GFP_KERNEL);
+ 		if (!ha->exlogin_buf) {
+ 			ql_log_pci(ql_log_fatal, ha->pdev, 0xd02a,
+ 		    "Failed to allocate memory for exlogin_buf_dma.\n");
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	/* Now configure the dma buffer */
+ 	rval = qla_set_exlogin_mem_cfg(vha, ha->exlogin_buf_dma);
+ 	if (rval) {
+ 		ql_log(ql_log_fatal, vha, 0xd033,
+ 		    "Setup extended login buffer  ****FAILED****.\n");
+ 		qla2x00_free_exlogin_buffer(ha);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+ * qla2x00_free_exlogin_buffer
+ *
+ * Input:
+ *	ha = adapter block pointer
+ */
+ void
+ qla2x00_free_exlogin_buffer(struct qla_hw_data *ha)
+ {
+ 	if (ha->exlogin_buf) {
+ 		dma_free_coherent(&ha->pdev->dev, ha->exlogin_size,
+ 		    ha->exlogin_buf, ha->exlogin_buf_dma);
+ 		ha->exlogin_buf = NULL;
+ 		ha->exlogin_size = 0;
+ 	}
+ }
+ 
+ static void
+ qla2x00_number_of_exch(scsi_qla_host_t *vha, u32 *ret_cnt, u16 max_cnt)
+ {
+ 	u32 temp;
+ 	*ret_cnt = FW_DEF_EXCHANGES_CNT;
+ 
+ 	if (qla_ini_mode_enabled(vha)) {
+ 		if (ql2xiniexchg > max_cnt)
+ 			ql2xiniexchg = max_cnt;
+ 
+ 		if (ql2xiniexchg > FW_DEF_EXCHANGES_CNT)
+ 			*ret_cnt = ql2xiniexchg;
+ 	} else if (qla_tgt_mode_enabled(vha)) {
+ 		if (ql2xexchoffld > max_cnt)
+ 			ql2xexchoffld = max_cnt;
+ 
+ 		if (ql2xexchoffld > FW_DEF_EXCHANGES_CNT)
+ 			*ret_cnt = ql2xexchoffld;
+ 	} else if (qla_dual_mode_enabled(vha)) {
+ 		temp = ql2xiniexchg + ql2xexchoffld;
+ 		if (temp > max_cnt) {
+ 			ql2xiniexchg -= (temp - max_cnt)/2;
+ 			ql2xexchoffld -= (((temp - max_cnt)/2) + 1);
+ 			temp = max_cnt;
+ 		}
+ 
+ 		if (temp > FW_DEF_EXCHANGES_CNT)
+ 			*ret_cnt = temp;
+ 	}
+ }
+ 
+ int
+ qla2x00_set_exchoffld_buffer(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	u16 size, max_cnt;
+ 	u32 temp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!ha->flags.exchoffld_enabled)
+ 		return QLA_SUCCESS;
+ 
+ 	if (!IS_EXCHG_OFFLD_CAPABLE(ha))
+ 		return QLA_SUCCESS;
+ 
+ 	ql_log(ql_log_info, vha, 0xd014,
+ 	    "Exchange offload count: %d.\n", ql2xexlogins);
+ 
+ 	max_cnt = 0;
+ 	rval = qla_get_exchoffld_status(vha, &size, &max_cnt);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd012,
+ 		    "Failed to get exlogin status.\n");
+ 		return rval;
+ 	}
+ 
+ 	qla2x00_number_of_exch(vha, &temp, max_cnt);
+ 	temp *= size;
+ 
+ 	if (temp != ha->exchoffld_size) {
+ 		qla2x00_free_exchoffld_buffer(ha);
+ 		ha->exchoffld_size = temp;
+ 
+ 		ql_log(ql_log_info, vha, 0xd016,
+ 		    "Exchange offload: max_count=%d, buffers=0x%x, total=%d.\n",
+ 		    max_cnt, size, temp);
+ 
+ 		ql_log(ql_log_info, vha, 0xd017,
+ 		    "Exchange Buffers requested size = 0x%x\n",
+ 		    ha->exchoffld_size);
+ 
+ 		/* Get consistent memory for extended logins */
+ 		ha->exchoffld_buf = dma_alloc_coherent(&ha->pdev->dev,
+ 			ha->exchoffld_size, &ha->exchoffld_buf_dma, GFP_KERNEL);
+ 		if (!ha->exchoffld_buf) {
+ 			ql_log_pci(ql_log_fatal, ha->pdev, 0xd013,
+ 			"Failed to allocate memory for exchoffld_buf_dma.\n");
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	/* Now configure the dma buffer */
+ 	rval = qla_set_exchoffld_mem_cfg(vha);
+ 	if (rval) {
+ 		ql_log(ql_log_fatal, vha, 0xd02e,
+ 		    "Setup exchange offload buffer ****FAILED****.\n");
+ 		qla2x00_free_exchoffld_buffer(ha);
+ 	} else {
+ 		/* re-adjust number of target exchange */
+ 		struct init_cb_81xx *icb = (struct init_cb_81xx *)ha->init_cb;
+ 
+ 		if (qla_ini_mode_enabled(vha))
+ 			icb->exchange_count = 0;
+ 		else
+ 			icb->exchange_count = cpu_to_le16(ql2xexchoffld);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+ * qla2x00_free_exchoffld_buffer
+ *
+ * Input:
+ *	ha = adapter block pointer
+ */
+ void
+ qla2x00_free_exchoffld_buffer(struct qla_hw_data *ha)
+ {
+ 	if (ha->exchoffld_buf) {
+ 		dma_free_coherent(&ha->pdev->dev, ha->exchoffld_size,
+ 		    ha->exchoffld_buf, ha->exchoffld_buf_dma);
+ 		ha->exchoffld_buf = NULL;
+ 		ha->exchoffld_size = 0;
+ 	}
+ }
+ 
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  /*
  * qla2x00_free_fw_dump
  *	Frees fw dump stuff.
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,324048476d9e..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -50,10 -55,21 +50,20 @@@ MODULE_PARM_DESC(qlini_mode
  	"disabled on enabling target mode and then on disabling target mode "
  	"enabled back; "
  	"\"disabled\" - initiator mode will never be enabled; "
 -	"\"dual\" - Initiator Modes will be enabled. Target Mode can be activated "
 -	"when ready "
  	"\"enabled\" (default) - initiator mode will always stay enabled.");
  
++<<<<<<< HEAD
++=======
+ static int ql_dm_tgt_ex_pct = 0;
+ module_param(ql_dm_tgt_ex_pct, int, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(ql_dm_tgt_ex_pct,
+ 	"For Dual Mode (qlini_mode=dual), this parameter determines "
+ 	"the percentage of exchanges/cmds FW will allocate resources "
+ 	"for Target mode.");
+ 
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  int ql2x_ini_mode = QLA2XXX_INI_MODE_EXCLUSIVE;
  
 -static int temp_sam_status = SAM_STAT_BUSY;
 -
  /*
   * From scsi/fc/fc_fcp.h
   */
@@@ -4711,8 -6438,11 +4721,14 @@@ voi
  qlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_24xx *nv)
  {
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 
+ 	if (!QLA_TGT_MODE_ENABLED())
+ 		return;
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  
 -	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {
 +	if (qla_tgt_mode_enabled(vha)) {
  		if (!ha->tgt.saved_set) {
  			/* We save only once */
  			ha->tgt.saved_exchange_count = nv->exchange_count;
@@@ -4725,7 -6455,10 +4741,14 @@@
  			ha->tgt.saved_set = 1;
  		}
  
++<<<<<<< HEAD
 +		nv->exchange_count = cpu_to_le16(0xFFFF);
++=======
+ 		if (qla_tgt_mode_enabled(vha))
+ 			nv->exchange_count = cpu_to_le16(0xFFFF);
+ 		else			/* dual */
+ 			nv->exchange_count = cpu_to_le16(ql2xexchoffld);
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  
  		/* Enable target mode */
  		nv->firmware_options_1 |= cpu_to_le32(BIT_4);
@@@ -4816,7 -6560,10 +4839,14 @@@ qlt_81xx_config_nvram_stage1(struct scs
  			ha->tgt.saved_set = 1;
  		}
  
++<<<<<<< HEAD
 +		nv->exchange_count = cpu_to_le16(0xFFFF);
++=======
+ 		if (qla_tgt_mode_enabled(vha))
+ 			nv->exchange_count = cpu_to_le16(0xFFFF);
+ 		else			/* dual */
+ 			nv->exchange_count = cpu_to_le16(ql2xexchoffld);
++>>>>>>> 99e1b683c4be (scsi: qla2xxx: Add ql2xiniexchg parameter)
  
  		/* Enable target mode */
  		nv->firmware_options_1 |= cpu_to_le32(BIT_4);
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_inline.h b/drivers/scsi/qla2xxx/qla_inline.h
index 0ac13772fc47..d4e0acd23d27 100644
--- a/drivers/scsi/qla2xxx/qla_inline.h
+++ b/drivers/scsi/qla2xxx/qla_inline.h
@@ -308,3 +308,19 @@ qla2x00_set_retry_delay_timestamp(fc_port_t *fcport, uint16_t retry_delay)
 		fcport->retry_delay_timestamp = jiffies +
 		    (retry_delay * HZ / 10);
 }
+
+static inline bool
+qla_is_exch_offld_enabled(struct scsi_qla_host *vha)
+{
+	if (qla_ini_mode_enabled(vha) &&
+	    (ql2xiniexchg > FW_DEF_EXCHANGES_CNT))
+		return true;
+	else if (qla_tgt_mode_enabled(vha) &&
+	    (ql2xexchoffld > FW_DEF_EXCHANGES_CNT))
+		return true;
+	else if (qla_dual_mode_enabled(vha) &&
+	    ((ql2xiniexchg + ql2xexchoffld) > FW_DEF_EXCHANGES_CNT))
+		return true;
+	else
+		return false;
+}
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
