IB/hfi1: Setup common IB fields in hfi1_packet struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit 9039746cdf39dcbf2ddfcc4a68f729cbbbc853df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9039746c.failed

We move many common IB fields into the hfi1_packet structure and
set them up in a single function. This allows us to set the fields
in a single place and not deal with them throughout the driver.

	Reviewed-by: Brian Welty <brian.welty@intel.com>
	Reviewed-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9039746cdf39dcbf2ddfcc4a68f729cbbbc853df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.h
#	drivers/infiniband/hw/hfi1/driver.c
#	drivers/infiniband/hw/hfi1/rc.c
#	drivers/infiniband/hw/hfi1/ruc.c
#	drivers/infiniband/hw/hfi1/uc.c
#	drivers/infiniband/hw/hfi1/ud.c
#	drivers/infiniband/hw/hfi1/verbs.c
diff --cc drivers/infiniband/hw/hfi1/chip.h
index 8a7b218d745f,0b4f418ba0ac..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@@ -1345,9 -1347,7 +1345,13 @@@ enum 
  u64 get_all_cpu_total(u64 __percpu *cntr);
  void hfi1_start_cleanup(struct hfi1_devdata *dd);
  void hfi1_clear_tids(struct hfi1_ctxtdata *rcd);
++<<<<<<< HEAD
 +struct ib_header *hfi1_get_msgheader(
 +				struct hfi1_devdata *dd, __le32 *rhf_addr);
 +int hfi1_init_ctxt(struct send_context *sc);
++=======
+ void hfi1_init_ctxt(struct send_context *sc);
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  void hfi1_put_tid(struct hfi1_devdata *dd, u32 index,
  		  u32 type, unsigned long pa, u16 order);
  void hfi1_quiet_serdes(struct hfi1_pportdata *ppd);
diff --cc drivers/infiniband/hw/hfi1/driver.c
index 500b129ed565,2a1022e374a5..000000000000
--- a/drivers/infiniband/hw/hfi1/driver.c
+++ b/drivers/infiniband/hw/hfi1/driver.c
@@@ -306,24 -294,20 +330,25 @@@ static void rcv_hdrerr(struct hfi1_ctxt
  			goto drop;
  
  		/* Check for GRH */
- 		if (lnh == HFI1_LRH_BTH) {
- 			ohdr = &rhdr->u.oth;
- 		} else if (lnh == HFI1_LRH_GRH) {
+ 		if (has_grh) {
  			u32 vtf;
+ 			struct ib_grh *grh = packet->grh;
  
- 			ohdr = &rhdr->u.l.oth;
- 			if (rhdr->u.l.grh.next_hdr != IB_GRH_NEXT_HDR)
+ 			if (grh->next_hdr != IB_GRH_NEXT_HDR)
  				goto drop;
- 			vtf = be32_to_cpu(rhdr->u.l.grh.version_tclass_flow);
+ 			vtf = be32_to_cpu(grh->version_tclass_flow);
  			if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
  				goto drop;
- 			rcv_flags |= HFI1_HAS_GRH;
- 		} else {
- 			goto drop;
  		}
+ 
  		/* Get the destination QP number. */
++<<<<<<< HEAD
 +		qp_num = be32_to_cpu(ohdr->bth[1]) & RVT_QPN_MASK;
 +		if (lid < be16_to_cpu(IB_MULTICAST_LID_BASE)) {
++=======
+ 		qp_num = ib_bth_get_qpn(packet->ohdr);
+ 		if (dlid < mlid_base) {
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  			struct rvt_qp *qp;
  			unsigned long flags;
  
diff --cc drivers/infiniband/hw/hfi1/rc.c
index be9bcccf13a9,baa67bf0772b..000000000000
--- a/drivers/infiniband/hw/hfi1/rc.c
+++ b/drivers/infiniband/hw/hfi1/rc.c
@@@ -1939,9 -1943,7 +1939,13 @@@ void hfi1_rc_rcv(struct hfi1_packet *pa
  		return;
  
  	is_fecn = process_ecn(qp, packet, false);
++<<<<<<< HEAD
 +
 +	psn = be32_to_cpu(ohdr->bth[2]);
 +	opcode = ib_bth_get_opcode(ohdr);
++=======
+ 	psn = ib_bth_get_psn(ohdr);
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  
  	/*
  	 * Process responses (ACKs) before anything else.  Note that the
@@@ -2372,21 -2371,13 +2373,18 @@@ void hfi1_rc_hdrerr
  	struct hfi1_ibport *ibp = rcd_to_iport(rcd);
  	int diff;
  	u32 opcode;
- 	u32 psn, bth0;
- 
- 	/* Check for GRH */
- 	ohdr = &hdr->u.oth;
- 	if (has_grh)
- 		ohdr = &hdr->u.l.oth;
+ 	u32 psn;
  
- 	bth0 = be32_to_cpu(ohdr->bth[0]);
- 	if (hfi1_ruc_check_hdr(ibp, hdr, has_grh, qp, bth0))
+ 	if (hfi1_ruc_check_hdr(ibp, packet))
  		return;
  
++<<<<<<< HEAD
 +	psn = be32_to_cpu(ohdr->bth[2]);
 +	opcode = ib_bth_get_opcode(ohdr);
++=======
+ 	psn = ib_bth_get_psn(packet->ohdr);
+ 	opcode = ib_bth_get_opcode(packet->ohdr);
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  
  	/* Only deal with RDMA Writes for now */
  	if (opcode < IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST) {
diff --cc drivers/infiniband/hw/hfi1/ruc.c
index 21e5a2279e51,9cc9c7be9dd4..000000000000
--- a/drivers/infiniband/hw/hfi1/ruc.c
+++ b/drivers/infiniband/hw/hfi1/ruc.c
@@@ -219,76 -218,87 +218,137 @@@ int hfi1_ruc_check_hdr(struct hfi1_ibpo
  {
  	__be64 guid;
  	unsigned long flags;
++<<<<<<< HEAD
 +	u8 sc5 = ibp->sl_to_sc[qp->remote_ah_attr.sl];
 +
 +	if (qp->s_mig_state == IB_MIG_ARMED && (bth0 & IB_BTH_MIG_REQ)) {
 +		if (!has_grh) {
 +			if (qp->alt_ah_attr.ah_flags & IB_AH_GRH)
 +				goto err;
 +		} else {
 +			if (!(qp->alt_ah_attr.ah_flags & IB_AH_GRH))
 +				goto err;
 +			guid = get_sguid(ibp, qp->alt_ah_attr.grh.sgid_index);
 +			if (!gid_ok(&hdr->u.l.grh.dgid, ibp->rvp.gid_prefix,
++=======
+ 	struct rvt_qp *qp = packet->qp;
+ 	u8 sc5 = ibp->sl_to_sc[rdma_ah_get_sl(&qp->remote_ah_attr)];
+ 	u32 dlid = packet->dlid;
+ 	u32 slid = packet->slid;
+ 	u32 sl = packet->sl;
+ 	int migrated;
+ 	u32 bth0, bth1;
+ 
+ 	bth0 = be32_to_cpu(packet->ohdr->bth[0]);
+ 	bth1 = be32_to_cpu(packet->ohdr->bth[1]);
+ 	migrated = bth0 & IB_BTH_MIG_REQ;
+ 
+ 	if (qp->s_mig_state == IB_MIG_ARMED && migrated) {
+ 		if (!packet->grh) {
+ 			if (rdma_ah_get_ah_flags(&qp->alt_ah_attr) &
+ 			    IB_AH_GRH)
+ 				return 1;
+ 		} else {
+ 			const struct ib_global_route *grh;
+ 
+ 			if (!(rdma_ah_get_ah_flags(&qp->alt_ah_attr) &
+ 			      IB_AH_GRH))
+ 				return 1;
+ 			grh = rdma_ah_read_grh(&qp->alt_ah_attr);
+ 			guid = get_sguid(ibp, grh->sgid_index);
+ 			if (!gid_ok(&packet->grh->dgid, ibp->rvp.gid_prefix,
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  				    guid))
- 				goto err;
+ 				return 1;
  			if (!gid_ok(
++<<<<<<< HEAD
 +				&hdr->u.l.grh.sgid,
 +				qp->alt_ah_attr.grh.dgid.global.subnet_prefix,
 +				qp->alt_ah_attr.grh.dgid.global.interface_id))
 +				goto err;
++=======
+ 				&packet->grh->sgid,
+ 				grh->dgid.global.subnet_prefix,
+ 				grh->dgid.global.interface_id))
+ 				return 1;
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  		}
- 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0, sc5,
- 					    ib_get_slid(hdr)))) {
- 			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY,
- 				       (u16)bth0,
- 				       ib_get_sl(hdr),
- 				       0, qp->ibqp.qp_num,
- 				       ib_get_slid(hdr),
- 				       ib_get_dlid(hdr));
- 			goto err;
+ 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0,
+ 					    sc5, slid))) {
+ 			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY, (u16)bth0, sl,
+ 				       0, qp->ibqp.qp_num, slid, dlid);
+ 			return 1;
  		}
  		/* Validate the SLID. See Ch. 9.6.1.5 and 17.2.8 */
++<<<<<<< HEAD
 +		if (ib_get_slid(hdr) != qp->alt_ah_attr.dlid ||
 +		    ppd_from_ibp(ibp)->port != qp->alt_ah_attr.port_num)
 +			goto err;
++=======
+ 		if (slid != rdma_ah_get_dlid(&qp->alt_ah_attr) ||
+ 		    ppd_from_ibp(ibp)->port !=
+ 			rdma_ah_get_port_num(&qp->alt_ah_attr))
+ 			return 1;
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  		spin_lock_irqsave(&qp->s_lock, flags);
  		hfi1_migrate_qp(qp);
  		spin_unlock_irqrestore(&qp->s_lock, flags);
  	} else {
++<<<<<<< HEAD
 +		if (!has_grh) {
 +			if (qp->remote_ah_attr.ah_flags & IB_AH_GRH)
 +				goto err;
 +		} else {
 +			if (!(qp->remote_ah_attr.ah_flags & IB_AH_GRH))
 +				goto err;
 +			guid = get_sguid(ibp,
 +					 qp->remote_ah_attr.grh.sgid_index);
 +			if (!gid_ok(&hdr->u.l.grh.dgid, ibp->rvp.gid_prefix,
++=======
+ 		if (!packet->grh) {
+ 			if (rdma_ah_get_ah_flags(&qp->remote_ah_attr) &
+ 						 IB_AH_GRH)
+ 				return 1;
+ 		} else {
+ 			const struct ib_global_route *grh;
+ 
+ 			if (!(rdma_ah_get_ah_flags(&qp->remote_ah_attr) &
+ 						   IB_AH_GRH))
+ 				return 1;
+ 			grh = rdma_ah_read_grh(&qp->remote_ah_attr);
+ 			guid = get_sguid(ibp, grh->sgid_index);
+ 			if (!gid_ok(&packet->grh->dgid, ibp->rvp.gid_prefix,
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  				    guid))
- 				goto err;
+ 				return 1;
  			if (!gid_ok(
++<<<<<<< HEAD
 +			     &hdr->u.l.grh.sgid,
 +			     qp->remote_ah_attr.grh.dgid.global.subnet_prefix,
 +			     qp->remote_ah_attr.grh.dgid.global.interface_id))
 +				goto err;
++=======
+ 			     &packet->grh->sgid,
+ 			     grh->dgid.global.subnet_prefix,
+ 			     grh->dgid.global.interface_id))
+ 				return 1;
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  		}
- 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0, sc5,
- 					    ib_get_slid(hdr)))) {
- 			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY,
- 				       (u16)bth0,
- 				       ib_get_sl(hdr),
- 				       0, qp->ibqp.qp_num,
- 				       ib_get_slid(hdr),
- 				       ib_get_dlid(hdr));
- 			goto err;
+ 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0,
+ 					    sc5, slid))) {
+ 			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY, (u16)bth0, sl,
+ 				       0, qp->ibqp.qp_num, slid, dlid);
+ 			return 1;
  		}
  		/* Validate the SLID. See Ch. 9.6.1.5 */
++<<<<<<< HEAD
 +		if (ib_get_slid(hdr) != qp->remote_ah_attr.dlid ||
++=======
+ 		if ((slid != rdma_ah_get_dlid(&qp->remote_ah_attr)) ||
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  		    ppd_from_ibp(ibp)->port != qp->port_num)
- 			goto err;
- 		if (qp->s_mig_state == IB_MIG_REARM &&
- 		    !(bth0 & IB_BTH_MIG_REQ))
+ 			return 1;
+ 		if (qp->s_mig_state == IB_MIG_REARM && !migrated)
  			qp->s_mig_state = IB_MIG_ARMED;
  	}
  
diff --cc drivers/infiniband/hw/hfi1/uc.c
index f0bdb100e005,76c2451a53d7..000000000000
--- a/drivers/infiniband/hw/hfi1/uc.c
+++ b/drivers/infiniband/hw/hfi1/uc.c
@@@ -319,9 -315,7 +315,13 @@@ void hfi1_uc_rcv(struct hfi1_packet *pa
  
  	process_ecn(qp, packet, true);
  
++<<<<<<< HEAD
 +	psn = be32_to_cpu(ohdr->bth[2]);
 +	opcode = ib_bth_get_opcode(ohdr);
 +
++=======
+ 	psn = ib_bth_get_psn(ohdr);
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  	/* Compare the PSN verses the expected PSN. */
  	if (unlikely(cmp_psn(psn, qp->r_psn) != 0)) {
  		/*
diff --cc drivers/infiniband/hw/hfi1/ud.c
index 45bc3f04793e,c995aa58c36a..000000000000
--- a/drivers/infiniband/hw/hfi1/ud.c
+++ b/drivers/infiniband/hw/hfi1/ud.c
@@@ -678,23 -680,19 +677,27 @@@ void hfi1_ud_rcv(struct hfi1_packet *pa
  	void *data = packet->ebuf;
  	u32 tlen = packet->tlen;
  	struct rvt_qp *qp = packet->qp;
- 	bool has_grh = rcv_flags & HFI1_HAS_GRH;
  	u8 sc5 = hfi1_9B_get_sc5(hdr, packet->rhf);
  	u32 bth1;
- 	u8 sl_from_sc, sl;
- 	u16 slid;
- 	u8 extra_bytes;
- 
+ 	u8 sl_from_sc;
+ 	u8 extra_bytes = packet->pad;
+ 	u8 opcode = packet->opcode;
+ 	u8 sl = packet->sl;
+ 	u32 dlid = packet->dlid;
+ 	u32 slid = packet->slid;
+ 
++<<<<<<< HEAD
 +	qkey = be32_to_cpu(ohdr->u.ud.deth[0]);
 +	src_qp = be32_to_cpu(ohdr->u.ud.deth[1]) & RVT_QPN_MASK;
 +	dlid = ib_get_dlid(hdr);
 +	bth1 = be32_to_cpu(ohdr->bth[1]);
 +	slid = ib_get_slid(hdr);
++=======
+ 	bth1 = be32_to_cpu(ohdr->bth[1]);
+ 	qkey = ib_get_qkey(ohdr);
+ 	src_qp = ib_get_sqpn(ohdr);
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  	pkey = ib_bth_get_pkey(ohdr);
- 	opcode = ib_bth_get_opcode(ohdr);
- 	sl = ib_get_sl(hdr);
- 	extra_bytes = ib_bth_get_pad(ohdr);
  	extra_bytes += (SIZE_OF_CRC << 2);
  	sl_from_sc = ibp->sc_to_sl[sc5];
  
diff --cc drivers/infiniband/hw/hfi1/verbs.c
index 95bc2ee63c9d,af54d3f4696a..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@@ -566,38 -559,10 +559,33 @@@ static inline void hfi1_handle_packet(s
  	struct rvt_dev_info *rdi = &ppd->dd->verbs_dev.rdi;
  	opcode_handler packet_handler;
  	unsigned long flags;
- 	u32 qp_num;
- 	int lnh;
- 	u8 opcode;
- 	u16 lid;
  
- 	/* Check for GRH */
- 	lnh = ib_get_lnh(hdr);
- 	if (lnh == HFI1_LRH_BTH) {
- 		packet->ohdr = &hdr->u.oth;
- 	} else if (lnh == HFI1_LRH_GRH) {
- 		u32 vtf;
+ 	inc_opstats(packet->tlen, &rcd->opstats->stats[packet->opcode]);
  
++<<<<<<< HEAD
 +		packet->ohdr = &hdr->u.l.oth;
 +		if (hdr->u.l.grh.next_hdr != IB_GRH_NEXT_HDR)
 +			goto drop;
 +		vtf = be32_to_cpu(hdr->u.l.grh.version_tclass_flow);
 +		if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
 +			goto drop;
 +		packet->rcv_flags |= HFI1_HAS_GRH;
 +	} else {
 +		goto drop;
 +	}
 +
 +	trace_input_ibhdr(rcd->dd, packet, !!(packet->rhf & RHF_DC_INFO_SMASK));
 +	opcode = ib_bth_get_opcode(packet->ohdr);
 +	inc_opstats(tlen, &rcd->opstats->stats[opcode]);
 +
 +	/* Get the destination QP number. */
 +	qp_num = be32_to_cpu(packet->ohdr->bth[1]) & RVT_QPN_MASK;
 +	lid = ib_get_dlid(hdr);
 +	if (unlikely((lid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) &&
 +		     (lid != be16_to_cpu(IB_LID_PERMISSIVE)))) {
++=======
+ 	if (unlikely(is_mcast)) {
++>>>>>>> 9039746cdf39 (IB/hfi1: Setup common IB fields in hfi1_packet struct)
  		struct rvt_mcast *mcast;
  		struct rvt_mcast_qp *p;
  
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index 5a15a115c76c..bd5358f39b3d 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -9810,15 +9810,6 @@ void hfi1_clear_tids(struct hfi1_ctxtdata *rcd)
 		hfi1_put_tid(dd, i, PT_INVALID, 0, 0);
 }
 
-struct ib_header *hfi1_get_msgheader(
-	struct hfi1_devdata *dd, __le32 *rhf_addr)
-{
-	u32 offset = rhf_hdrq_offset(rhf_to_cpu(rhf_addr));
-
-	return (struct ib_header *)
-		(rhf_addr - dd->rhf_offset + offset);
-}
-
 static const char * const ib_cfg_name_strings[] = {
 	"HFI1_IB_CFG_LIDLMC",
 	"HFI1_IB_CFG_LWID_DG_ENB",
* Unmerged path drivers/infiniband/hw/hfi1/chip.h
diff --git a/drivers/infiniband/hw/hfi1/common.h b/drivers/infiniband/hw/hfi1/common.h
index 995d62c7f9a7..ba9ab971ced9 100644
--- a/drivers/infiniband/hw/hfi1/common.h
+++ b/drivers/infiniband/hw/hfi1/common.h
@@ -325,6 +325,7 @@ struct diag_pkt {
 #define HFI1_LRH_BTH 0x0002      /* 1. word of IB LRH - next header: BTH */
 
 /* misc. */
+#define SC15_PACKET 0xF
 #define SIZE_OF_CRC 1
 
 #define LIM_MGMT_P_KEY       0x7FFF
* Unmerged path drivers/infiniband/hw/hfi1/driver.c
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index 9e4a63b05006..8f5347f8ef5c 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -363,17 +363,26 @@ struct hfi1_packet {
 	__le32 *rhf_addr;
 	struct rvt_qp *qp;
 	struct ib_other_headers *ohdr;
+	struct ib_grh *grh;
 	u64 rhf;
 	u32 maxcnt;
 	u32 rhqoff;
+	u32 dlid;
+	u32 slid;
 	u16 tlen;
 	s16 etail;
 	u8 hlen;
 	u8 numpkt;
 	u8 rsize;
 	u8 updegr;
-	u8 rcv_flags;
 	u8 etype;
+	u8 extra_byte;
+	u8 pad;
+	u8 sc;
+	u8 sl;
+	u8 opcode;
+	bool becn;
+	bool fecn;
 };
 
 struct rvt_sge_state;
@@ -2091,4 +2100,14 @@ int hfi1_tempsense_rd(struct hfi1_devdata *dd, struct hfi1_temp *temp);
 
 #define DD_DEV_ENTRY(dd)       __string(dev, dev_name(&(dd)->pcidev->dev))
 #define DD_DEV_ASSIGN(dd)      __assign_str(dev, dev_name(&(dd)->pcidev->dev))
+
+/*
+ * hfi1_check_mcast- Check if the given lid is
+ * in the IB multicast range.
+ */
+static inline bool hfi1_check_mcast(u16 lid)
+{
+	return ((lid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) &&
+		(lid != be16_to_cpu(IB_LID_PERMISSIVE)));
+}
 #endif                          /* _HFI1_KERNEL_H */
* Unmerged path drivers/infiniband/hw/hfi1/rc.c
* Unmerged path drivers/infiniband/hw/hfi1/ruc.c
* Unmerged path drivers/infiniband/hw/hfi1/uc.c
* Unmerged path drivers/infiniband/hw/hfi1/ud.c
* Unmerged path drivers/infiniband/hw/hfi1/verbs.c
diff --git a/drivers/infiniband/hw/hfi1/verbs.h b/drivers/infiniband/hw/hfi1/verbs.h
index 76081f770f70..4f0696467d72 100644
--- a/drivers/infiniband/hw/hfi1/verbs.h
+++ b/drivers/infiniband/hw/hfi1/verbs.h
@@ -307,8 +307,7 @@ void hfi1_rc_rcv(struct hfi1_packet *packet);
 
 void hfi1_rc_hdrerr(
 	struct hfi1_ctxtdata *rcd,
-	struct ib_header *hdr,
-	u32 rcv_flags,
+	struct hfi1_packet *packet,
 	struct rvt_qp *qp);
 
 u8 ah_to_sc(struct ib_device *ibdev, struct ib_ah_attr *ah_attr);
@@ -346,8 +345,7 @@ static inline u8 get_opcode(struct ib_header *h)
 		return be32_to_cpu(h->u.l.oth.bth[0]) >> 24;
 }
 
-int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct ib_header *hdr,
-		       int has_grh, struct rvt_qp *qp, u32 bth0);
+int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct hfi1_packet *packet);
 
 u32 hfi1_make_grh(struct hfi1_ibport *ibp, struct ib_grh *hdr,
 		  struct ib_global_route *grh, u32 hwords, u32 nwords);
