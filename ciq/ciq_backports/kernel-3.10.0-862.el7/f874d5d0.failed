nvme-fc: on lldd/transport io error, terminate association

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: on lldd/transport io error, terminate association (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 95.50%
commit-author James Smart <jsmart2021@gmail.com>
commit f874d5d079ec35158fa1a1509554c9d641bd5770
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f874d5d0.failed

Per FC-NVME, when lldd or transport detects an i/o error, the
connection must be terminated, which in turn requires the association
to be termianted.  Currently the transport simply creates a nvme
completion status of transport error and returns the io. The FC-NVME
spec makes the mandate as initiator and host, depending on the error,
can get out of sync on outstanding io counts (sqhd/sqtail).

Implement the association teardown on lldd or transport detected
errors.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
(cherry picked from commit f874d5d079ec35158fa1a1509554c9d641bd5770)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index a2d701be7e74,2edae54688e8..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1086,6 -1138,8 +1086,11 @@@ nvme_fc_xmt_disconnect_assoc(struct nvm
  
  /* *********************** NVME Ctrl Routines **************************** */
  
++<<<<<<< HEAD
++=======
+ static void __nvme_fc_final_op_cleanup(struct request *rq);
+ static void nvme_fc_error_recovery(struct nvme_fc_ctrl *ctrl, char *errmsg);
++>>>>>>> f874d5d079ec (nvme-fc: on lldd/transport io error, terminate association)
  
  static int
  nvme_fc_reinit_request(void *data, struct request *rq)
@@@ -1146,7 -1263,10 +1151,14 @@@ nvme_fc_fcpio_done(struct nvmefc_fcp_re
  	struct nvme_fc_ctrl *ctrl = op->ctrl;
  	struct nvme_fc_queue *queue = op->queue;
  	struct nvme_completion *cqe = &op->rsp_iu.cqe;
++<<<<<<< HEAD
 +	u16 status;
++=======
+ 	struct nvme_command *sqe = &op->cmd_iu.sqe;
+ 	__le16 status = cpu_to_le16(NVME_SC_SUCCESS << 1);
+ 	union nvme_result result;
+ 	bool complete_rq, terminate_assoc = true;
++>>>>>>> f874d5d079ec (nvme-fc: on lldd/transport io error, terminate association)
  
  	/*
  	 * WARNING:
@@@ -1239,15 -1368,32 +1259,34 @@@
  		goto done;
  	}
  
+ 	terminate_assoc = false;
+ 
  done:
 -	if (op->flags & FCOP_FLAGS_AEN) {
 -		nvme_complete_async_event(&queue->ctrl->ctrl, status, &result);
 -		complete_rq = __nvme_fc_fcpop_chk_teardowns(ctrl, op);
 -		atomic_set(&op->state, FCPOP_STATE_IDLE);
 -		op->flags = FCOP_FLAGS_AEN;	/* clear other flags */
 +	if (!queue->qnum && op->rqno >= AEN_CMDID_BASE) {
 +		nvme_complete_async_event(&queue->ctrl->ctrl, status,
 +					&op->nreq.result);
  		nvme_fc_ctrl_put(ctrl);
- 		return;
+ 		goto check_error;
  	}
  
++<<<<<<< HEAD
 +	blk_mq_complete_request(rq, status);
++=======
+ 	complete_rq = __nvme_fc_fcpop_chk_teardowns(ctrl, op);
+ 	if (!complete_rq) {
+ 		if (unlikely(op->flags & FCOP_FLAGS_TERMIO)) {
+ 			status = cpu_to_le16(NVME_SC_ABORT_REQ << 1);
+ 			if (blk_queue_dying(rq->q))
+ 				status |= cpu_to_le16(NVME_SC_DNR << 1);
+ 		}
+ 		nvme_end_request(rq, status, result);
+ 	} else
+ 		__nvme_fc_final_op_cleanup(rq);
+ 
+ check_error:
+ 	if (terminate_assoc)
+ 		nvme_fc_error_recovery(ctrl, "transport detected io error");
++>>>>>>> f874d5d079ec (nvme-fc: on lldd/transport io error, terminate association)
  }
  
  static int
* Unmerged path drivers/nvme/host/fc.c
