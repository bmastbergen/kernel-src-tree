tcmu: Make dev_size configurable via userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bryant G. Ly <bryantly@linux.vnet.ibm.com>
commit 801fc54d5d943e8a6a6bc26bc94fb9b90938ff68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/801fc54d.failed

Allow tcmu backstores to be able to set the device size
after it has been configured via set attribute.

Part of support in userspace to support certain backstores
changing device size.

	Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
Reviewed-By: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 801fc54d5d943e8a6a6bc26bc94fb9b90938ff68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 5b22226ed5d2,c8c84b71dc91..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1456,30 -1546,94 +1456,103 @@@ static ssize_t tcmu_dev_store_attr_cmd_
  	udev->cmd_time_out = val * MSEC_PER_SEC;
  	return count;
  }
 -CONFIGFS_ATTR(tcmu_, cmd_time_out);
 +TB_DEV_ATTR(tcmu, cmd_time_out, S_IRUGO | S_IWUSR);
  
++<<<<<<< HEAD
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_pi_prot_type);
 +TB_DEV_ATTR_RO(tcmu, hw_pi_prot_type);
++=======
+ static ssize_t tcmu_dev_size_show(struct config_item *item, char *page)
+ {
+ 	struct se_dev_attrib *da = container_of(to_config_group(item),
+ 						struct se_dev_attrib, da_group);
+ 	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
+ 
+ 	return snprintf(page, PAGE_SIZE, "%zu\n", udev->dev_size);
+ }
+ 
+ static ssize_t tcmu_dev_size_store(struct config_item *item, const char *page,
+ 				   size_t count)
+ {
+ 	struct se_dev_attrib *da = container_of(to_config_group(item),
+ 						struct se_dev_attrib, da_group);
+ 	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
+ 	unsigned long val;
+ 	int ret;
+ 
+ 	ret = kstrtoul(page, 0, &val);
+ 	if (ret < 0)
+ 		return ret;
+ 	udev->dev_size = val;
+ 
+ 	/* Check if device has been configured before */
+ 	if (tcmu_dev_configured(udev)) {
+ 		ret = tcmu_netlink_event(TCMU_CMD_RECONFIG_DEVICE,
+ 					 udev->uio_info.name,
+ 					 udev->uio_info.uio_dev->minor);
+ 		if (ret) {
+ 			pr_err("Unable to reconfigure device\n");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	return count;
+ }
+ CONFIGFS_ATTR(tcmu_, dev_size);
+ 
+ static ssize_t tcmu_emulate_write_cache_show(struct config_item *item,
+ 					     char *page)
+ {
+ 	struct se_dev_attrib *da = container_of(to_config_group(item),
+ 					struct se_dev_attrib, da_group);
++>>>>>>> 801fc54d5d94 (tcmu: Make dev_size configurable via userspace)
  
 -	return snprintf(page, PAGE_SIZE, "%i\n", da->emulate_write_cache);
 -}
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_block_size);
 +TB_DEV_ATTR_RO(tcmu, hw_block_size);
  
 -static ssize_t tcmu_emulate_write_cache_store(struct config_item *item,
 -					      const char *page, size_t count)
 -{
 -	struct se_dev_attrib *da = container_of(to_config_group(item),
 -					struct se_dev_attrib, da_group);
 -	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
 -	int val;
 -	int ret;
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_max_sectors);
 +TB_DEV_ATTR_RO(tcmu, hw_max_sectors);
  
 -	ret = kstrtouint(page, 0, &val);
 -	if (ret < 0)
 -		return ret;
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_queue_depth);
 +TB_DEV_ATTR_RO(tcmu, hw_queue_depth);
  
 -	da->emulate_write_cache = val;
 +static struct configfs_attribute *tcmu_backend_dev_attrs[] = {
 +	&tcmu_dev_attrib_hw_pi_prot_type.attr,
 +	&tcmu_dev_attrib_hw_block_size.attr,
 +	&tcmu_dev_attrib_hw_max_sectors.attr,
 +	&tcmu_dev_attrib_hw_queue_depth.attr,
 +	&tcmu_dev_attrib_cmd_time_out.attr,
 +	NULL,
 +};
  
++<<<<<<< HEAD
 +static struct se_subsystem_api tcmu_template = {
++=======
+ 	/* Check if device has been configured before */
+ 	if (tcmu_dev_configured(udev)) {
+ 		ret = tcmu_netlink_event(TCMU_CMD_RECONFIG_DEVICE,
+ 					 udev->uio_info.name,
+ 					 udev->uio_info.uio_dev->minor);
+ 		if (ret) {
+ 			pr_err("Unable to reconfigure device\n");
+ 			return ret;
+ 		}
+ 	}
+ 	return count;
+ }
+ CONFIGFS_ATTR(tcmu_, emulate_write_cache);
+ 
+ struct configfs_attribute *tcmu_attrib_attrs[] = {
+ 	&tcmu_attr_cmd_time_out,
+ 	&tcmu_attr_dev_size,
+ 	&tcmu_attr_emulate_write_cache,
+ 	NULL,
+ };
+ 
+ static struct configfs_attribute **tcmu_attrs;
+ 
+ static struct target_backend_ops tcmu_ops = {
++>>>>>>> 801fc54d5d94 (tcmu: Make dev_size configurable via userspace)
  	.name			= "user",
  	.owner			= THIS_MODULE,
  	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH,
@@@ -1494,12 -1647,90 +1567,16 @@@
  	.show_configfs_dev_params = tcmu_show_configfs_dev_params,
  	.get_device_type	= sbc_get_device_type,
  	.get_blocks		= tcmu_get_blocks,
 -	.tb_dev_attrib_attrs	= NULL,
  };
  
 -static int unmap_thread_fn(void *data)
 -{
 -	struct tcmu_dev *udev;
 -	loff_t off;
 -	uint32_t start, end, block;
 -	struct page *page;
 -	int i;
 -
 -	while (1) {
 -		DEFINE_WAIT(__wait);
 -
 -		prepare_to_wait(&unmap_wait, &__wait, TASK_INTERRUPTIBLE);
 -		schedule();
 -		finish_wait(&unmap_wait, &__wait);
 -
 -		if (kthread_should_stop())
 -			break;
 -
 -		mutex_lock(&root_udev_mutex);
 -		list_for_each_entry(udev, &root_udev, node) {
 -			mutex_lock(&udev->cmdr_lock);
 -
 -			/* Try to complete the finished commands first */
 -			tcmu_handle_completions(udev);
 -
 -			/* Skip the udevs waiting the global pool or in idle */
 -			if (udev->waiting_global || !udev->dbi_thresh) {
 -				mutex_unlock(&udev->cmdr_lock);
 -				continue;
 -			}
 -
 -			end = udev->dbi_max + 1;
 -			block = find_last_bit(udev->data_bitmap, end);
 -			if (block == udev->dbi_max) {
 -				/*
 -				 * The last bit is dbi_max, so there is
 -				 * no need to shrink any blocks.
 -				 */
 -				mutex_unlock(&udev->cmdr_lock);
 -				continue;
 -			} else if (block == end) {
 -				/* The current udev will goto idle state */
 -				udev->dbi_thresh = start = 0;
 -				udev->dbi_max = 0;
 -			} else {
 -				udev->dbi_thresh = start = block + 1;
 -				udev->dbi_max = block;
 -			}
 -
 -			/* Here will truncate the data area from off */
 -			off = udev->data_off + start * DATA_BLOCK_SIZE;
 -			unmap_mapping_range(udev->inode->i_mapping, off, 0, 1);
 -
 -			/* Release the block pages */
 -			for (i = start; i < end; i++) {
 -				page = radix_tree_delete(&udev->data_blocks, i);
 -				if (page) {
 -					__free_page(page);
 -					atomic_dec(&global_db_count);
 -				}
 -			}
 -			mutex_unlock(&udev->cmdr_lock);
 -		}
 -
 -		/*
 -		 * Try to wake up the udevs who are waiting
 -		 * for the global data pool.
 -		 */
 -		list_for_each_entry(udev, &root_udev, node) {
 -			if (udev->waiting_global)
 -				wake_up(&udev->wait_cmdr);
 -		}
 -		mutex_unlock(&root_udev_mutex);
 -	}
 -
 -	return 0;
 -}
 -
  static int __init tcmu_module_init(void)
  {
++<<<<<<< HEAD
 +	struct target_backend_cits *tbc = &tcmu_template.tb_cits;
 +	int ret;
++=======
+ 	int ret, i, k, len = 0;
++>>>>>>> 801fc54d5d94 (tcmu: Make dev_size configurable via userspace)
  
  	BUILD_BUG_ON((sizeof(struct tcmu_cmd_entry) % TCMU_OP_ALIGN_SIZE) != 0);
  
@@@ -1521,14 -1752,39 +1598,41 @@@
  		goto out_unreg_device;
  	}
  
++<<<<<<< HEAD
 +	target_core_setup_sub_cits(&tcmu_template);
 +	tbc->tb_dev_attrib_cit.ct_attrs = tcmu_backend_dev_attrs;
 +
 +	ret = transport_subsystem_register(&tcmu_template);
++=======
+ 	for (i = 0; passthrough_attrib_attrs[i] != NULL; i++) {
+ 		len += sizeof(struct configfs_attribute *);
+ 	}
+ 	for (i = 0; tcmu_attrib_attrs[i] != NULL; i++) {
+ 		len += sizeof(struct configfs_attribute *);
+ 	}
+ 	len += sizeof(struct configfs_attribute *);
+ 
+ 	tcmu_attrs = kzalloc(len, GFP_KERNEL);
+ 	if (!tcmu_attrs) {
+ 		ret = -ENOMEM;
+ 		goto out_unreg_genl;
+ 	}
+ 
+ 	for (i = 0; passthrough_attrib_attrs[i] != NULL; i++) {
+ 		tcmu_attrs[i] = passthrough_attrib_attrs[i];
+ 	}
+ 	for (k = 0; tcmu_attrib_attrs[k] != NULL; k++) {
+ 		tcmu_attrs[i] = tcmu_attrib_attrs[k];
+ 		i++;
+ 	}
+ 	tcmu_ops.tb_dev_attrib_attrs = tcmu_attrs;
+ 
+ 	ret = transport_backend_register(&tcmu_ops);
++>>>>>>> 801fc54d5d94 (tcmu: Make dev_size configurable via userspace)
  	if (ret)
 -		goto out_attrs;
 +		goto out_unreg_genl;
  
 -	init_waitqueue_head(&unmap_wait);
 -	unmap_thread = kthread_run(unmap_thread_fn, NULL, "tcmu_unmap");
 -	if (IS_ERR(unmap_thread)) {
 -		ret = PTR_ERR(unmap_thread);
 -		goto out_unreg_transport;
 -	}
 +	idr_init(&devices_idr);
  
  	return 0;
  
* Unmerged path drivers/target/target_core_user.c
