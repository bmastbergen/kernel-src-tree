iio: hid-sensor-hub: Implement batch mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
commit 138bc7969c24c6cbba28e919c2376ad10a46fc60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/138bc796.failed

HID sensor hubs using Integrated Senor Hub (ISH) has added capability to
support batch mode. This allows host processor to go to sleep for extended
duration, while the sensor hub is storing samples in its internal buffers.

'Commit f4f4673b7535 ("iio: add support for hardware fifo")' implements
feature in IIO core to implement such feature. This feature is used in
bmc150-accel-core.c to implement batch mode. This implementation allows
software device buffer watermark to be used as a hint to adjust hardware
FIFO.

But HID sensor hubs don't allow to change internal buffer size of FIFOs.
Instead an additional usage id to set "maximum report latency" is defined.
This allows host to go to sleep upto this latency period without getting
any report. Since there is no ABI to set this latency, a new attribute
"hwfifo_timeout" is added so that user mode can specify a latency.

This change checks presence of usage id to get/set maximum report latency
and if present, it will expose hwfifo_timeout.

	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 138bc7969c24c6cbba28e919c2376ad10a46fc60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-bus-iio
#	drivers/iio/common/hid-sensors/hid-sensor-attributes.c
#	drivers/iio/common/hid-sensors/hid-sensor-trigger.c
#	include/linux/hid-sensor-hub.h
#	include/linux/hid-sensor-ids.h
diff --cc Documentation/ABI/testing/sysfs-bus-iio
index 2e33dc6b2346,2db2cdf42d54..000000000000
--- a/Documentation/ABI/testing/sysfs-bus-iio
+++ b/Documentation/ABI/testing/sysfs-bus-iio
@@@ -792,3 -1208,429 +792,432 @@@ Contact:	linux-iio@vger.kernel.or
  Description:
  		This attribute is used to read the amount of quadrature error
  		present in the device at a given time.
++<<<<<<< HEAD
++=======
+ 
+ What:		/sys/.../iio:deviceX/in_accelX_power_mode
+ KernelVersion:	3.11
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies the chip power mode.
+ 		low_noise: reduce noise level from ADC,
+ 		low_power: enable low current consumption.
+ 		For a list of available output power modes read
+ 		in_accel_power_mode_available.
+ 
+ What:		/sys/.../iio:deviceX/in_energy_input
+ What:		/sys/.../iio:deviceX/in_energy_raw
+ KernelVersion:	4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the energy value reported by the
+ 		device (e.g.: human activity sensors report energy burnt by the
+ 		user). Units after application of scale are Joules.
+ 
+ What:		/sys/.../iio:deviceX/in_distance_input
+ What:		/sys/.../iio:deviceX/in_distance_raw
+ KernelVersion:	4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the distance covered by the user
+ 		since the last reboot while activated. Units after application
+ 		of scale are meters.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/store_eeprom
+ KernelVersion:	3.4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Writing '1' stores the current device configuration into
+ 		on-chip EEPROM. After power-up or chip reset the device will
+ 		automatically load the saved configuration.
+ 
+ What:		/sys/.../iio:deviceX/in_proximity_raw
+ What:		/sys/.../iio:deviceX/in_proximity_input
+ What:		/sys/.../iio:deviceX/in_proximityY_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Proximity measurement indicating that some
+ 		object is near the sensor, usually by observing
+ 		reflectivity of infrared or ultrasound emitted.
+ 		Often these sensors are unit less and as such conversion
+ 		to SI units is not possible. Higher proximity measurements
+ 		indicate closer objects, and vice versa. Units after
+ 		application of scale and offset are meters.
+ 
+ What:		/sys/.../iio:deviceX/in_illuminance_input
+ What:		/sys/.../iio:deviceX/in_illuminance_raw
+ What:		/sys/.../iio:deviceX/in_illuminanceY_input
+ What:		/sys/.../iio:deviceX/in_illuminanceY_raw
+ What:		/sys/.../iio:deviceX/in_illuminanceY_mean_raw
+ What:		/sys/.../iio:deviceX/in_illuminance_ir_raw
+ What:		/sys/.../iio:deviceX/in_illuminance_clear_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Illuminance measurement, units after application of scale
+ 		and offset are lux.
+ 
+ What:		/sys/.../iio:deviceX/in_intensityY_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_ir_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_both_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_uv_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Unit-less light intensity. Modifiers both and ir indicate
+ 		that measurements contains visible and infrared light
+ 		components or just infrared light, respectively. Modifier uv indicates
+ 		that measurements contain ultraviolet light components.
+ 
+ What:		/sys/.../iio:deviceX/in_uvindex_input
+ KernelVersion:	4.6
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		UV light intensity index measuring the human skin's response to
+ 		different wavelength of sunlight weighted according to the
+ 		standardised CIE Erythemal Action Spectrum. UV index values range
+ 		from 0 (low) to >=11 (extreme).
+ 
+ What:		/sys/.../iio:deviceX/in_intensity_red_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_green_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_blue_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_clear_integration_time
+ What:		/sys/.../iio:deviceX/in_illuminance_integration_time
+ KernelVersion:	3.12
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to get/set the integration time in
+ 		seconds.
+ 
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_integration_time
+ KernelVersion:	4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Number of seconds in which to compute speed.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_quaternion_raw
+ KernelVersion:	3.15
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw value of quaternion components using a format
+ 		x y z w. Here x, y, and z component represents the axis about
+ 		which a rotation will occur and w component represents the
+ 		amount of rotation.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_magnetic_tilt_comp_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_true_tilt_comp_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_magnetic_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_true_raw
+ KernelVersion:	3.15
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw value of rotation from true/magnetic north measured with
+ 		or without compensation from tilt sensors.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_currentX_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_currentX_i_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_currentX_q_raw
+ KernelVersion:	3.18
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw current measurement from channel X. Units are in milliamps
+ 		after application of scale and offset. If no offset or scale is
+ 		present, output should be considered as processed with the
+ 		unit in milliamps.
+ 
+ 		Channels with 'i' and 'q' modifiers always exist in pairs and both
+ 		channels refer to the same signal. The 'i' channel contains the in-phase
+ 		component of the signal while the 'q' channel contains the quadrature
+ 		component.
+ 
+ What:		/sys/.../iio:deviceX/in_energy_en
+ What:		/sys/.../iio:deviceX/in_distance_en
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_en
+ What:		/sys/.../iio:deviceX/in_steps_en
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Activates a device feature that runs in firmware/hardware.
+ 		E.g. for steps: the pedometer saves power while not used;
+ 		when activated, it will count the steps taken by the user in
+ 		firmware and export them through in_steps_input.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_input
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the number of steps taken by the user
+ 		since the last reboot while activated.
+ 
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_input
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_raw
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the current speed value of the
+ 		user (which is the norm or magnitude of the velocity vector).
+ 		Units after application of scale are m/s.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_debounce_count
+ KernelVersion:	4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies the number of steps that must occur within
+ 		in_steps_filter_debounce_time for the pedometer to decide the
+ 		consumer is making steps.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_debounce_time
+ KernelVersion:	4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies number of seconds in which we compute the steps
+ 		that occur in order to decide if the consumer is making steps.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/watermark
+ KernelVersion:	4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the maximum number of scan
+ 		elements to wait for.
+ 		Poll will block until the watermark is reached.
+ 		Blocking read will wait until the minimum between the requested
+ 		read amount or the low water mark is available.
+ 		Non-blocking read will retrieve the available samples from the
+ 		buffer even if there are less samples then watermark level. This
+ 		allows the application to block on poll with a timeout and read
+ 		the available samples after the timeout expires and thus have a
+ 		maximum delay guarantee.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_enabled
+ KernelVersion: 4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A read-only boolean value that indicates if the hardware fifo is
+ 		currently enabled or disabled. If the device does not have a
+ 		hardware fifo this entry is not present.
+ 		The hardware fifo is enabled when the buffer is enabled if the
+ 		current hardware fifo watermark level is set and other current
+ 		device settings allows it (e.g. if a trigger is set that samples
+ 		data differently that the hardware fifo does then hardware fifo
+ 		will not enabled).
+ 		If the hardware fifo is enabled and the level of the hardware
+ 		fifo reaches the hardware fifo watermark level the device will
+ 		flush its hardware fifo to the device buffer. Doing a non
+ 		blocking read on the device when no samples are present in the
+ 		device buffer will also force a flush.
+ 		When the hardware fifo is enabled there is no need to use a
+ 		trigger to use buffer mode since the watermark settings
+ 		guarantees that the hardware fifo is flushed to the device
+ 		buffer.
+ 
+ What:		/sys/bus/iio/devices/iio:device*/buffer/hwfifo_timeout
+ KernelVersion:	4.12
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A read/write property to provide capability to delay reporting of
+ 		samples till a timeout is reached. This allows host processors to
+ 		sleep, while the sensor is storing samples in its internal fifo.
+ 		The maximum timeout in seconds can be specified by setting
+ 		hwfifo_timeout.The current delay can be read by reading
+ 		hwfifo_timeout. A value of 0 means that there is no timeout.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark
+ KernelVersion: 4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Read-only entry that contains a single integer specifying the
+ 		current watermark level for the hardware fifo. If the device
+ 		does not have a hardware fifo this entry is not present.
+ 		The watermark level for the hardware fifo is set by the driver
+ 		based on the value set by the user in buffer/watermark but
+ 		taking into account hardware limitations (e.g. most hardware
+ 		buffers are limited to 32-64 samples, some hardware buffers
+ 		watermarks are fixed or have minimum levels).  A value of 0
+ 		means that the hardware watermark is unset.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark_min
+ KernelVersion: 4.2
+ Contact:       linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the minimum watermark level
+ 		for the hardware fifo of this device. If the device does not
+ 		have a hardware fifo this entry is not present.
+ 		If the user sets buffer/watermark to a value less than this one,
+ 		then the hardware watermark will remain unset.
+ 
+ What:	       /sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark_max
+ KernelVersion: 4.2
+ Contact:       linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the maximum watermark level
+ 		for the hardware fifo of this device. If the device does not
+ 		have a hardware fifo this entry is not present.
+ 		If the user sets buffer/watermark to a value greater than this
+ 		one, then the hardware watermark will be capped at this value.
+ 
+ What:	       /sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark_available
+ KernelVersion: 4.2
+ Contact:       linux-iio@vger.kernel.org
+ Description:
+ 		A list of positive integers specifying the available watermark
+ 		levels for the hardware fifo. This entry is optional and if it
+ 		is not present it means that all the values between
+ 		hwfifo_watermark_min and hwfifo_watermark_max are supported.
+ 		If the user sets buffer/watermark to a value greater than
+ 		hwfifo_watermak_min but not equal to any of the values in this
+ 		list, the driver will chose an appropriate value for the
+ 		hardware fifo watermark level.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_temp_calibemissivity
+ What:		/sys/bus/iio/devices/iio:deviceX/in_tempX_calibemissivity
+ What:		/sys/bus/iio/devices/iio:deviceX/in_temp_object_calibemissivity
+ What:		/sys/bus/iio/devices/iio:deviceX/in_tempX_object_calibemissivity
+ KernelVersion:	4.1
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		The emissivity ratio of the surface in the field of view of the
+ 		contactless temperature sensor.  Emissivity varies from 0 to 1,
+ 		with 1 being the emissivity of a black body.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_magn_x_oversampling_ratio
+ What:		/sys/bus/iio/devices/iio:deviceX/in_magn_y_oversampling_ratio
+ What:		/sys/bus/iio/devices/iio:deviceX/in_magn_z_oversampling_ratio
+ KernelVersion:	4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Hardware applied number of measurements for acquiring one
+ 		data point. The HW will do <type>[_name]_oversampling_ratio
+ 		measurements and return the average value as output data. Each
+ 		value resulted from <type>[_name]_oversampling_ratio measurements
+ 		is considered as one sample for <type>[_name]_sampling_frequency.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_concentration_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_concentrationX_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_concentration_co2_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_concentrationX_co2_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_concentration_voc_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_concentrationX_voc_raw
+ KernelVersion:	4.3
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw (unscaled no offset etc.) percentage reading of a substance.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_resistance_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_resistanceX_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/out_resistance_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/out_resistanceX_raw
+ KernelVersion:	4.3
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw (unscaled no offset etc.) resistance reading that can be processed
+ 		into an ohm value.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/heater_enable
+ KernelVersion:	4.1.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		'1' (enable) or '0' (disable) specifying the enable
+ 		of heater function. Same reading values apply
+ 		This ABI is especially applicable for humidity sensors
+ 		to heatup the device and get rid of any condensation
+ 		in some humidity environment
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_ph_raw
+ KernelVersion:	4.5
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw (unscaled no offset etc.) pH reading of a substance as a negative
+ 		base-10 logarithm of hydrodium ions in a litre of water.
+ 
+ What:           /sys/bus/iio/devices/iio:deviceX/mount_matrix
+ What:           /sys/bus/iio/devices/iio:deviceX/in_mount_matrix
+ What:           /sys/bus/iio/devices/iio:deviceX/out_mount_matrix
+ What:           /sys/bus/iio/devices/iio:deviceX/in_anglvel_mount_matrix
+ What:           /sys/bus/iio/devices/iio:deviceX/in_accel_mount_matrix
+ KernelVersion:  4.6
+ Contact:        linux-iio@vger.kernel.org
+ Description:
+ 		Mounting matrix for IIO sensors. This is a rotation matrix which
+ 		informs userspace about sensor chip's placement relative to the
+ 		main hardware it is mounted on.
+ 		Main hardware placement is defined according to the local
+ 		reference frame related to the physical quantity the sensor
+ 		measures.
+ 		Given that the rotation matrix is defined in a board specific
+ 		way (platform data and / or device-tree), the main hardware
+ 		reference frame definition is left to the implementor's choice
+ 		(see below for a magnetometer example).
+ 		Applications should apply this rotation matrix to samples so
+ 		that when main hardware reference frame is aligned onto local
+ 		reference frame, then sensor chip reference frame is also
+ 		perfectly aligned with it.
+ 		Matrix is a 3x3 unitary matrix and typically looks like
+ 		[0, 1, 0; 1, 0, 0; 0, 0, -1]. Identity matrix
+ 		[1, 0, 0; 0, 1, 0; 0, 0, 1] means sensor chip and main hardware
+ 		are perfectly aligned with each other.
+ 
+ 		For example, a mounting matrix for a magnetometer sensor informs
+ 		userspace about sensor chip's ORIENTATION relative to the main
+ 		hardware.
+ 		More specifically, main hardware orientation is defined with
+ 		respect to the LOCAL EARTH GEOMAGNETIC REFERENCE FRAME where :
+ 		* Y is in the ground plane and positive towards magnetic North ;
+ 		* X is in the ground plane, perpendicular to the North axis and
+ 		  positive towards the East ;
+ 		* Z is perpendicular to the ground plane and positive upwards.
+ 
+ 		An implementor might consider that for a hand-held device, a
+ 		'natural' orientation would be 'front facing camera at the top'.
+ 		The main hardware reference frame could then be described as :
+ 		* Y is in the plane of the screen and is positive towards the
+ 		  top of the screen ;
+ 		* X is in the plane of the screen, perpendicular to Y axis, and
+ 		  positive towards the right hand side of the screen ;
+ 		* Z is perpendicular to the screen plane and positive out of the
+ 		  screen.
+ 		Another example for a quadrotor UAV might be :
+ 		* Y is in the plane of the propellers and positive towards the
+ 		  front-view camera;
+ 		* X is in the plane of the propellers, perpendicular to Y axis,
+ 		  and positive towards the starboard side of the UAV ;
+ 		* Z is perpendicular to propellers plane and positive upwards.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_electricalconductivity_raw
+ KernelVersion:	4.8
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw (unscaled no offset etc.) electric conductivity reading that
+ 		can be processed to siemens per meter.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_countY_raw
+ KernelVersion:	4.10
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw counter device counts from channel Y. For quadrature
+ 		counters, multiplication by an available [Y]_scale results in
+ 		the counts of a single quadrature signal phase from channel Y.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_indexY_raw
+ KernelVersion:	4.10
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw counter device index value from channel Y. This attribute
+ 		provides an absolute positional reference (e.g. a pulse once per
+ 		revolution) which may be used to home positional systems as
+ 		required.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_count_count_direction_available
+ KernelVersion:	4.12
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A list of possible counting directions which are:
+ 		- "up"	: counter device is increasing.
+ 		- "down": counter device is decreasing.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_countY_count_direction
+ KernelVersion:	4.12
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw counter device counters direction for channel Y.
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
diff --cc drivers/iio/common/hid-sensors/hid-sensor-attributes.c
index 75b54730a963,f5d4d786e193..000000000000
--- a/drivers/iio/common/hid-sensors/hid-sensor-attributes.c
+++ b/drivers/iio/common/hid-sensors/hid-sensor-attributes.c
@@@ -209,6 -304,154 +209,157 @@@ int hid_sensor_write_raw_hyst_value(str
  }
  EXPORT_SYMBOL(hid_sensor_write_raw_hyst_value);
  
++<<<<<<< HEAD
++=======
+ /*
+  * This fuction applies the unit exponent to the scale.
+  * For example:
+  * 9.806650000 ->exp:2-> val0[980]val1[665000000]
+  * 9.000806000 ->exp:2-> val0[900]val1[80600000]
+  * 0.174535293 ->exp:2-> val0[17]val1[453529300]
+  * 1.001745329 ->exp:0-> val0[1]val1[1745329]
+  * 1.001745329 ->exp:2-> val0[100]val1[174532900]
+  * 1.001745329 ->exp:4-> val0[10017]val1[453290000]
+  * 9.806650000 ->exp:-2-> val0[0]val1[98066500]
+  */
+ static void adjust_exponent_nano(int *val0, int *val1, int scale0,
+ 				  int scale1, int exp)
+ {
+ 	int i;
+ 	int x;
+ 	int res;
+ 	int rem;
+ 
+ 	if (exp > 0) {
+ 		*val0 = scale0 * pow_10(exp);
+ 		res = 0;
+ 		if (exp > 9) {
+ 			*val1 = 0;
+ 			return;
+ 		}
+ 		for (i = 0; i < exp; ++i) {
+ 			x = scale1 / pow_10(8 - i);
+ 			res += (pow_10(exp - 1 - i) * x);
+ 			scale1 = scale1 % pow_10(8 - i);
+ 		}
+ 		*val0 += res;
+ 			*val1 = scale1 * pow_10(exp);
+ 	} else if (exp < 0) {
+ 		exp = abs(exp);
+ 		if (exp > 9) {
+ 			*val0 = *val1 = 0;
+ 			return;
+ 		}
+ 		*val0 = scale0 / pow_10(exp);
+ 		rem = scale0 % pow_10(exp);
+ 		res = 0;
+ 		for (i = 0; i < (9 - exp); ++i) {
+ 			x = scale1 / pow_10(8 - i);
+ 			res += (pow_10(8 - exp - i) * x);
+ 			scale1 = scale1 % pow_10(8 - i);
+ 		}
+ 		*val1 = rem * pow_10(9 - exp) + res;
+ 	} else {
+ 		*val0 = scale0;
+ 		*val1 = scale1;
+ 	}
+ }
+ 
+ int hid_sensor_format_scale(u32 usage_id,
+ 			struct hid_sensor_hub_attribute_info *attr_info,
+ 			int *val0, int *val1)
+ {
+ 	int i;
+ 	int exp;
+ 
+ 	*val0 = 1;
+ 	*val1 = 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(unit_conversion); ++i) {
+ 		if (unit_conversion[i].usage_id == usage_id &&
+ 			unit_conversion[i].unit == attr_info->units) {
+ 			exp  = hid_sensor_convert_exponent(
+ 						attr_info->unit_expo);
+ 			adjust_exponent_nano(val0, val1,
+ 					unit_conversion[i].scale_val0,
+ 					unit_conversion[i].scale_val1, exp);
+ 			break;
+ 		}
+ 	}
+ 
+ 	return IIO_VAL_INT_PLUS_NANO;
+ }
+ EXPORT_SYMBOL(hid_sensor_format_scale);
+ 
+ int64_t hid_sensor_convert_timestamp(struct hid_sensor_common *st,
+ 				     int64_t raw_value)
+ {
+ 	return st->timestamp_ns_scale * raw_value;
+ }
+ EXPORT_SYMBOL(hid_sensor_convert_timestamp);
+ 
+ static
+ int hid_sensor_get_reporting_interval(struct hid_sensor_hub_device *hsdev,
+ 					u32 usage_id,
+ 					struct hid_sensor_common *st)
+ {
+ 	sensor_hub_input_get_attribute_info(hsdev,
+ 					HID_FEATURE_REPORT, usage_id,
+ 					HID_USAGE_SENSOR_PROP_REPORT_INTERVAL,
+ 					&st->poll);
+ 	/* Default unit of measure is milliseconds */
+ 	if (st->poll.units == 0)
+ 		st->poll.units = HID_USAGE_SENSOR_UNITS_MILLISECOND;
+ 
+ 	st->poll_interval = -1;
+ 
+ 	return 0;
+ 
+ }
+ 
+ static void hid_sensor_get_report_latency_info(struct hid_sensor_hub_device *hsdev,
+ 					       u32 usage_id,
+ 					       struct hid_sensor_common *st)
+ {
+ 	sensor_hub_input_get_attribute_info(hsdev, HID_FEATURE_REPORT,
+ 					    usage_id,
+ 					    HID_USAGE_SENSOR_PROP_REPORT_LATENCY,
+ 					    &st->report_latency);
+ 
+ 	hid_dbg(hsdev->hdev, "Report latency attributes: %x:%x\n",
+ 		st->report_latency.index, st->report_latency.report_id);
+ }
+ 
+ int hid_sensor_get_report_latency(struct hid_sensor_common *st)
+ {
+ 	int ret;
+ 	int value;
+ 
+ 	ret = sensor_hub_get_feature(st->hsdev, st->report_latency.report_id,
+ 				     st->report_latency.index, sizeof(value),
+ 				     &value);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return value;
+ }
+ EXPORT_SYMBOL(hid_sensor_get_report_latency);
+ 
+ int hid_sensor_set_report_latency(struct hid_sensor_common *st, int latency_ms)
+ {
+ 	return sensor_hub_set_feature(st->hsdev, st->report_latency.report_id,
+ 				      st->report_latency.index,
+ 				      sizeof(latency_ms), &latency_ms);
+ }
+ EXPORT_SYMBOL(hid_sensor_set_report_latency);
+ 
+ bool hid_sensor_batch_mode_supported(struct hid_sensor_common *st)
+ {
+ 	return st->report_latency.index > 0 && st->report_latency.report_id > 0;
+ }
+ EXPORT_SYMBOL(hid_sensor_batch_mode_supported);
+ 
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  int hid_sensor_parse_common_attributes(struct hid_sensor_hub_device *hsdev,
  					u32 usage_id,
  					struct hid_sensor_common *st)
@@@ -234,11 -478,37 +385,45 @@@
  			HID_USAGE_SENSOR_PROP_SENSITIVITY_ABS,
  			 &st->sensitivity);
  
++<<<<<<< HEAD
 +	hid_dbg(hsdev->hdev, "common attributes: %x:%x, %x:%x, %x:%x %x:%x\n",
 +			st->poll.index, st->poll.report_id,
 +			st->report_state.index, st->report_state.report_id,
 +			st->power_state.index, st->power_state.report_id,
 +			st->sensitivity.index, st->sensitivity.report_id);
++=======
+ 	st->raw_hystersis = -1;
+ 
+ 	sensor_hub_input_get_attribute_info(hsdev,
+ 					    HID_INPUT_REPORT, usage_id,
+ 					    HID_USAGE_SENSOR_TIME_TIMESTAMP,
+ 					    &timestamp);
+ 	if (timestamp.index >= 0 && timestamp.report_id) {
+ 		int val0, val1;
+ 
+ 		hid_sensor_format_scale(HID_USAGE_SENSOR_TIME_TIMESTAMP,
+ 					&timestamp, &val0, &val1);
+ 		st->timestamp_ns_scale = val0;
+ 	} else
+ 		st->timestamp_ns_scale = 1000000000;
+ 
+ 	hid_sensor_get_report_latency_info(hsdev, usage_id, st);
+ 
+ 	hid_dbg(hsdev->hdev, "common attributes: %x:%x, %x:%x, %x:%x %x:%x %x:%x\n",
+ 		st->poll.index, st->poll.report_id,
+ 		st->report_state.index, st->report_state.report_id,
+ 		st->power_state.index, st->power_state.report_id,
+ 		st->sensitivity.index, st->sensitivity.report_id,
+ 		timestamp.index, timestamp.report_id);
+ 
+ 	ret = sensor_hub_get_feature(hsdev,
+ 				st->power_state.report_id,
+ 				st->power_state.index, sizeof(value), &value);
+ 	if (ret < 0)
+ 		return ret;
+ 	if (value < 0)
+ 		return -EINVAL;
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  
  	return 0;
  }
diff --cc drivers/iio/common/hid-sensors/hid-sensor-trigger.c
index 5cc9e5190684,16ade0a0327b..000000000000
--- a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c
+++ b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c
@@@ -28,16 -30,94 +29,94 @@@
  #include <linux/iio/sysfs.h>
  #include "hid-sensor-trigger.h"
  
++<<<<<<< HEAD
 +static int hid_sensor_data_rdy_trigger_set_state(struct iio_trigger *trig,
 +						bool state)
++=======
+ static ssize_t _hid_sensor_set_report_latency(struct device *dev,
+ 					      struct device_attribute *attr,
+ 					      const char *buf, size_t len)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);
+ 	int integer, fract, ret;
+ 	int latency;
+ 
+ 	ret = iio_str_to_fixpoint(buf, 100000, &integer, &fract);
+ 	if (ret)
+ 		return ret;
+ 
+ 	latency = integer * 1000 + fract / 1000;
+ 	ret = hid_sensor_set_report_latency(attrb, latency);
+ 	if (ret < 0)
+ 		return len;
+ 
+ 	attrb->latency_ms = hid_sensor_get_report_latency(attrb);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t _hid_sensor_get_report_latency(struct device *dev,
+ 					      struct device_attribute *attr,
+ 					      char *buf)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);
+ 	int latency;
+ 
+ 	latency = hid_sensor_get_report_latency(attrb);
+ 	if (latency < 0)
+ 		return latency;
+ 
+ 	return sprintf(buf, "%d.%06u\n", latency / 1000, (latency % 1000) * 1000);
+ }
+ 
+ static ssize_t _hid_sensor_get_fifo_state(struct device *dev,
+ 					  struct device_attribute *attr,
+ 					  char *buf)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);
+ 	int latency;
+ 
+ 	latency = hid_sensor_get_report_latency(attrb);
+ 	if (latency < 0)
+ 		return latency;
+ 
+ 	return sprintf(buf, "%d\n", !!latency);
+ }
+ 
+ static IIO_DEVICE_ATTR(hwfifo_timeout, 0644,
+ 		       _hid_sensor_get_report_latency,
+ 		       _hid_sensor_set_report_latency, 0);
+ static IIO_DEVICE_ATTR(hwfifo_enabled, 0444,
+ 		       _hid_sensor_get_fifo_state, NULL, 0);
+ 
+ static const struct attribute *hid_sensor_fifo_attributes[] = {
+ 	&iio_dev_attr_hwfifo_timeout.dev_attr.attr,
+ 	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+ 	NULL,
+ };
+ 
+ static void hid_sensor_setup_batch_mode(struct iio_dev *indio_dev,
+ 					struct hid_sensor_common *st)
+ {
+ 	if (!hid_sensor_batch_mode_supported(st))
+ 		return;
+ 
+ 	iio_buffer_set_attrs(indio_dev->buffer, hid_sensor_fifo_attributes);
+ }
+ 
+ static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  {
 +	struct hid_sensor_common *st = iio_trigger_get_drvdata(trig);
  	int state_val;
  	int report_val;
 -	s32 poll_value = 0;
  
  	if (state) {
 -		if (!atomic_read(&st->user_requested_state))
 -			return 0;
  		if (sensor_hub_device_open(st->hsdev))
  			return -EIO;
 -
 -		atomic_inc(&st->data_ready);
 -
  		state_val = hid_sensor_get_usage_index(st->hsdev,
  			st->power_state.report_id,
  			st->power_state.index,
@@@ -74,10 -162,71 +153,71 @@@
  	}
  
  	sensor_hub_get_feature(st->hsdev, st->power_state.report_id,
 -			       st->power_state.index,
 -			       sizeof(state_val), &state_val);
 -	if (state && poll_value)
 -		msleep_interruptible(poll_value * 2);
 -
 +					st->power_state.index,
 +					&state_val);
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL(hid_sensor_power_state);
+ 
+ int hid_sensor_power_state(struct hid_sensor_common *st, bool state)
+ {
+ 
+ #ifdef CONFIG_PM
+ 	int ret;
+ 
+ 	atomic_set(&st->user_requested_state, state);
+ 	if (state)
+ 		ret = pm_runtime_get_sync(&st->pdev->dev);
+ 	else {
+ 		pm_runtime_mark_last_busy(&st->pdev->dev);
+ 		ret = pm_runtime_put_autosuspend(&st->pdev->dev);
+ 	}
+ 	if (ret < 0) {
+ 		if (state)
+ 			pm_runtime_put_noidle(&st->pdev->dev);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ #else
+ 	atomic_set(&st->user_requested_state, state);
+ 	return _hid_sensor_power_state(st, state);
+ #endif
+ }
+ 
+ static void hid_sensor_set_power_work(struct work_struct *work)
+ {
+ 	struct hid_sensor_common *attrb = container_of(work,
+ 						       struct hid_sensor_common,
+ 						       work);
+ 
+ 	if (attrb->poll_interval >= 0)
+ 		sensor_hub_set_feature(attrb->hsdev, attrb->poll.report_id,
+ 				       attrb->poll.index,
+ 				       sizeof(attrb->poll_interval),
+ 				       &attrb->poll_interval);
+ 
+ 	if (attrb->raw_hystersis >= 0)
+ 		sensor_hub_set_feature(attrb->hsdev,
+ 				       attrb->sensitivity.report_id,
+ 				       attrb->sensitivity.index,
+ 				       sizeof(attrb->raw_hystersis),
+ 				       &attrb->raw_hystersis);
+ 
+ 	if (attrb->latency_ms > 0)
+ 		hid_sensor_set_report_latency(attrb, attrb->latency_ms);
+ 
+ 	_hid_sensor_power_state(attrb, true);
+ }
+ 
+ static int hid_sensor_data_rdy_trigger_set_state(struct iio_trigger *trig,
+ 						bool state)
+ {
+ 	return hid_sensor_power_state(iio_trigger_get_drvdata(trig), state);
+ }
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  
  void hid_sensor_remove_trigger(struct hid_sensor_common *attrb)
  {
@@@ -116,8 -270,26 +256,28 @@@ int hid_sensor_setup_trigger(struct iio
  	attrb->trigger = trig;
  	indio_dev->trig = iio_trigger_get(trig);
  
++<<<<<<< HEAD
++=======
+ 	hid_sensor_setup_batch_mode(indio_dev, attrb);
+ 
+ 	ret = pm_runtime_set_active(&indio_dev->dev);
+ 	if (ret)
+ 		goto error_unreg_trigger;
+ 
+ 	iio_device_set_drvdata(indio_dev, attrb);
+ 
+ 	INIT_WORK(&attrb->work, hid_sensor_set_power_work);
+ 
+ 	pm_suspend_ignore_children(&attrb->pdev->dev, true);
+ 	pm_runtime_enable(&attrb->pdev->dev);
+ 	/* Default to 3 seconds, but can be changed from sysfs */
+ 	pm_runtime_set_autosuspend_delay(&attrb->pdev->dev,
+ 					 3000);
+ 	pm_runtime_use_autosuspend(&attrb->pdev->dev);
+ 
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  	return ret;
 -error_unreg_trigger:
 -	iio_trigger_unregister(trig);
 +
  error_free_trig:
  	iio_trigger_free(trig);
  error_ret:
diff --cc include/linux/hid-sensor-hub.h
index 05fe6c21f3e2,fc7aae64dcde..000000000000
--- a/include/linux/hid-sensor-hub.h
+++ b/include/linux/hid-sensor-hub.h
@@@ -167,15 -229,22 +167,28 @@@ struct hid_sensor_common 
  	struct hid_sensor_hub_device *hsdev;
  	struct platform_device *pdev;
  	unsigned usage_id;
++<<<<<<< HEAD
 +	bool data_ready;
++=======
+ 	atomic_t data_ready;
+ 	atomic_t user_requested_state;
+ 	int poll_interval;
+ 	int raw_hystersis;
+ 	int latency_ms;
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  	struct iio_trigger *trigger;
 -	int timestamp_ns_scale;
  	struct hid_sensor_hub_attribute_info poll;
  	struct hid_sensor_hub_attribute_info report_state;
  	struct hid_sensor_hub_attribute_info power_state;
  	struct hid_sensor_hub_attribute_info sensitivity;
++<<<<<<< HEAD
++=======
+ 	struct hid_sensor_hub_attribute_info report_latency;
+ 	struct work_struct work;
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  };
  
 -/* Convert from hid unit expo to regular exponent */
 +/*Convert from hid unit expo to regular exponent*/
  static inline int hid_sensor_convert_exponent(int unit_expo)
  {
  	if (unit_expo < 0x08)
@@@ -198,4 -267,19 +211,22 @@@ int hid_sensor_write_samp_freq_value(st
  int hid_sensor_read_samp_freq_value(struct hid_sensor_common *st,
  					int *val1, int *val2);
  
++<<<<<<< HEAD
++=======
+ int hid_sensor_get_usage_index(struct hid_sensor_hub_device *hsdev,
+ 				u32 report_id, int field_index, u32 usage_id);
+ 
+ int hid_sensor_format_scale(u32 usage_id,
+ 			    struct hid_sensor_hub_attribute_info *attr_info,
+ 			    int *val0, int *val1);
+ 
+ s32 hid_sensor_read_poll_value(struct hid_sensor_common *st);
+ 
+ int64_t hid_sensor_convert_timestamp(struct hid_sensor_common *st,
+ 				     int64_t raw_value);
+ bool hid_sensor_batch_mode_supported(struct hid_sensor_common *st);
+ int hid_sensor_set_report_latency(struct hid_sensor_common *st, int latency);
+ int hid_sensor_get_report_latency(struct hid_sensor_common *st);
+ 
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  #endif
diff --cc include/linux/hid-sensor-ids.h
index f1f71e65f98c,76033e0420a7..000000000000
--- a/include/linux/hid-sensor-ids.h
+++ b/include/linux/hid-sensor-ids.h
@@@ -117,6 -152,13 +117,16 @@@
  #define HID_USAGE_SENSOR_PROP_REPORT_STATE			0x200316
  #define HID_USAGE_SENSOR_PROY_POWER_STATE			0x200319
  
++<<<<<<< HEAD
++=======
+ /* Batch mode selectors */
+ #define HID_USAGE_SENSOR_PROP_REPORT_LATENCY			0x20031B
+ 
+ /* Per data field properties */
+ #define HID_USAGE_SENSOR_DATA_MOD_NONE					0x00
+ #define HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS		0x1000
+ 
++>>>>>>> 138bc7969c24 (iio: hid-sensor-hub: Implement batch mode)
  /* Power state enumerations */
  #define HID_USAGE_SENSOR_PROP_POWER_STATE_UNDEFINED_ENUM	0x200850
  #define HID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM	0x200851
* Unmerged path Documentation/ABI/testing/sysfs-bus-iio
* Unmerged path drivers/iio/common/hid-sensors/hid-sensor-attributes.c
* Unmerged path drivers/iio/common/hid-sensors/hid-sensor-trigger.c
* Unmerged path include/linux/hid-sensor-hub.h
* Unmerged path include/linux/hid-sensor-ids.h
