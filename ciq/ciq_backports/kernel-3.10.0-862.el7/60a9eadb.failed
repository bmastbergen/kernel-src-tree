scsi: qla2xxx: Move target stat counters from vha to qpair.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Move target stat counters from vha to qpair (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 93.69%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 60a9eadb19f33a7b3e183207b5b5e1d01d8a6add
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/60a9eadb.failed

Move counters to qpair to reduce cache miss.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 60a9eadb19f33a7b3e183207b5b5e1d01d8a6add)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_dfs.c
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,e1af9db3691d..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2835,6 -3182,21 +2835,24 @@@ struct bidi_statistics 
  #define QLA_PRECONFIG_VPORTS 32
  #define QLA_MAX_VPORTS_QLA24XX	128
  #define QLA_MAX_VPORTS_QLA25XX	256
++<<<<<<< HEAD
++=======
+ 
+ struct qla_tgt_counters {
+ 	uint64_t qla_core_sbt_cmd;
+ 	uint64_t core_qla_que_buf;
+ 	uint64_t qla_core_ret_ctio;
+ 	uint64_t core_qla_snd_status;
+ 	uint64_t qla_core_ret_sta_ctio;
+ 	uint64_t core_qla_free_cmd;
+ 	uint64_t num_q_full_sent;
+ 	uint64_t num_alloc_iocb_failed;
+ 	uint64_t num_term_xchg_sent;
+ };
+ 
+ struct qla_qpair;
+ 
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  /* Response queue data structure */
  struct rsp_que {
  	dma_addr_t  dma;
@@@ -2919,13 -3295,9 +2937,19 @@@ struct qla_qpair 
  	struct qla_hw_data *hw;
  	struct work_struct q_work;
  	struct list_head qp_list_elem; /* vha->qp_list */
++<<<<<<< HEAD
 +};
 +
 +struct qla_percpu_qp_hint {
 +	int change_in_progress;
 +	struct qla_qpair *qp;
 +	int redirect_to_cpuid;
 +	struct qla_qpair *alternate_qp;
++=======
+ 	struct list_head hints_list;
+ 	uint16_t cpuid;
+ 	struct qla_tgt_counters tgt_counters;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  };
  
  /* Place holder for FW buffer parameters */
diff --cc drivers/scsi/qla2xxx/qla_dfs.c
index 2ca39b8e7166,d231e7156134..000000000000
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@@ -13,6 -13,241 +13,244 @@@ static struct dentry *qla2x00_dfs_root
  static atomic_t qla2x00_dfs_root_count;
  
  static int
++<<<<<<< HEAD
++=======
+ qla2x00_dfs_tgt_sess_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct fc_port *sess = NULL;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n", vha->host_str);
+ 	if (tgt) {
+ 		seq_puts(s, "Port ID   Port Name                Handle\n");
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		list_for_each_entry(sess, &vha->vp_fcports, list)
+ 			seq_printf(s, "%02x:%02x:%02x  %8phC  %d\n",
+ 			    sess->d_id.b.domain, sess->d_id.b.area,
+ 			    sess->d_id.b.al_pa, sess->port_name,
+ 			    sess->loop_id);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_sess_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 	return single_open(file, qla2x00_dfs_tgt_sess_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_sess_ops = {
+ 	.open		= qla2x00_dfs_tgt_sess_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla2x00_dfs_tgt_port_database_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct gid_list_info *gid_list;
+ 	dma_addr_t gid_list_dma;
+ 	fc_port_t fc_port;
+ 	char *id_iter;
+ 	int rc, i;
+ 	uint16_t entries, loop_id;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n", vha->host_str);
+ 	if (tgt) {
+ 		gid_list = dma_alloc_coherent(&ha->pdev->dev,
+ 		    qla2x00_gid_list_size(ha),
+ 		    &gid_list_dma, GFP_KERNEL);
+ 		if (!gid_list) {
+ 			ql_dbg(ql_dbg_user, vha, 0x7018,
+ 			    "DMA allocation failed for %u\n",
+ 			     qla2x00_gid_list_size(ha));
+ 			return 0;
+ 		}
+ 
+ 		rc = qla24xx_gidlist_wait(vha, gid_list, gid_list_dma,
+ 		    &entries);
+ 		if (rc != QLA_SUCCESS)
+ 			goto out_free_id_list;
+ 
+ 		id_iter = (char *)gid_list;
+ 
+ 		seq_puts(s, "Port Name	Port ID 	Loop ID\n");
+ 
+ 		for (i = 0; i < entries; i++) {
+ 			struct gid_list_info *gid =
+ 			    (struct gid_list_info *)id_iter;
+ 			loop_id = le16_to_cpu(gid->loop_id);
+ 			memset(&fc_port, 0, sizeof(fc_port_t));
+ 
+ 			fc_port.loop_id = loop_id;
+ 
+ 			rc = qla24xx_gpdb_wait(vha, &fc_port, 0);
+ 			seq_printf(s, "%8phC  %02x%02x%02x  %d\n",
+ 				fc_port.port_name, fc_port.d_id.b.domain,
+ 				fc_port.d_id.b.area, fc_port.d_id.b.al_pa,
+ 				fc_port.loop_id);
+ 			id_iter += ha->gid_list_info_size;
+ 		}
+ out_free_id_list:
+ 		dma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),
+ 		    gid_list, gid_list_dma);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_port_database_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 
+ 	return single_open(file, qla2x00_dfs_tgt_port_database_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_port_database_ops = {
+ 	.open		= qla2x00_dfs_tgt_port_database_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	seq_puts(s, "FW Resource count\n\n");
+ 	seq_printf(s, "Original TGT exchg count[%d]\n",
+ 	    ha->orig_fw_tgt_xcb_count);
+ 	seq_printf(s, "current TGT exchg count[%d]\n",
+ 	    ha->cur_fw_tgt_xcb_count);
+ 	seq_printf(s, "original Initiator Exchange count[%d]\n",
+ 	    ha->orig_fw_xcb_count);
+ 	seq_printf(s, "Current Initiator Exchange count[%d]\n",
+ 	    ha->cur_fw_xcb_count);
+ 	seq_printf(s, "Original IOCB count[%d]\n", ha->orig_fw_iocb_count);
+ 	seq_printf(s, "Current IOCB count[%d]\n", ha->cur_fw_iocb_count);
+ 	seq_printf(s, "MAX VP count[%d]\n", ha->max_npiv_vports);
+ 	seq_printf(s, "MAX FCF count[%d]\n", ha->fw_max_fcf_count);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_fw_resource_cnt_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_fw_resource_cnt_show, vha);
+ }
+ 
+ static const struct file_operations dfs_fw_resource_cnt_ops = {
+ 	.open           = qla_dfs_fw_resource_cnt_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
+ qla_dfs_tgt_counters_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_qpair *qpair = vha->hw->base_qpair;
+ 	uint64_t qla_core_sbt_cmd, core_qla_que_buf, qla_core_ret_ctio,
+ 		core_qla_snd_status, qla_core_ret_sta_ctio, core_qla_free_cmd,
+ 		num_q_full_sent, num_alloc_iocb_failed, num_term_xchg_sent;
+ 	u16 i;
+ 
+ 	qla_core_sbt_cmd = qpair->tgt_counters.qla_core_sbt_cmd;
+ 	core_qla_que_buf = qpair->tgt_counters.core_qla_que_buf;
+ 	qla_core_ret_ctio = qpair->tgt_counters.qla_core_ret_ctio;
+ 	core_qla_snd_status = qpair->tgt_counters.core_qla_snd_status;
+ 	qla_core_ret_sta_ctio = qpair->tgt_counters.qla_core_ret_sta_ctio;
+ 	core_qla_free_cmd = qpair->tgt_counters.core_qla_free_cmd;
+ 	num_q_full_sent = qpair->tgt_counters.num_q_full_sent;
+ 	num_alloc_iocb_failed = qpair->tgt_counters.num_alloc_iocb_failed;
+ 	num_term_xchg_sent = qpair->tgt_counters.num_term_xchg_sent;
+ 
+ 	for (i = 0; i < vha->hw->max_qpairs; i++) {
+ 		qpair = vha->hw->queue_pair_map[i];
+ 		qla_core_sbt_cmd += qpair->tgt_counters.qla_core_sbt_cmd;
+ 		core_qla_que_buf += qpair->tgt_counters.core_qla_que_buf;
+ 		qla_core_ret_ctio += qpair->tgt_counters.qla_core_ret_ctio;
+ 		core_qla_snd_status += qpair->tgt_counters.core_qla_snd_status;
+ 		qla_core_ret_sta_ctio +=
+ 		    qpair->tgt_counters.qla_core_ret_sta_ctio;
+ 		core_qla_free_cmd += qpair->tgt_counters.core_qla_free_cmd;
+ 		num_q_full_sent += qpair->tgt_counters.num_q_full_sent;
+ 		num_alloc_iocb_failed +=
+ 		    qpair->tgt_counters.num_alloc_iocb_failed;
+ 		num_term_xchg_sent += qpair->tgt_counters.num_term_xchg_sent;
+ 	}
+ 
+ 	seq_puts(s, "Target Counters\n");
+ 	seq_printf(s, "qla_core_sbt_cmd = %lld\n",
+ 		qla_core_sbt_cmd);
+ 	seq_printf(s, "qla_core_ret_sta_ctio = %lld\n",
+ 		qla_core_ret_sta_ctio);
+ 	seq_printf(s, "qla_core_ret_ctio = %lld\n",
+ 		qla_core_ret_ctio);
+ 	seq_printf(s, "core_qla_que_buf = %lld\n",
+ 		core_qla_que_buf);
+ 	seq_printf(s, "core_qla_snd_status = %lld\n",
+ 		core_qla_snd_status);
+ 	seq_printf(s, "core_qla_free_cmd = %lld\n",
+ 		core_qla_free_cmd);
+ 	seq_printf(s, "num alloc iocb failed = %lld\n",
+ 		num_alloc_iocb_failed);
+ 	seq_printf(s, "num term exchange sent = %lld\n",
+ 		num_term_xchg_sent);
+ 	seq_printf(s, "num Q full sent = %lld\n",
+ 		num_q_full_sent);
+ 
+ 	/* DIF stats */
+ 	seq_printf(s, "DIF Inp Bytes = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_input_bytes);
+ 	seq_printf(s, "DIF Outp Bytes = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_output_bytes);
+ 	seq_printf(s, "DIF Inp Req = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_input_requests);
+ 	seq_printf(s, "DIF Outp Req = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_output_requests);
+ 	seq_printf(s, "DIF Guard err = %d\n",
+ 		vha->qla_stats.qla_dif_stats.dif_guard_err);
+ 	seq_printf(s, "DIF Ref tag err = %d\n",
+ 		vha->qla_stats.qla_dif_stats.dif_ref_tag_err);
+ 	seq_printf(s, "DIF App tag err = %d\n",
+ 		vha->qla_stats.qla_dif_stats.dif_app_tag_err);
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_tgt_counters_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_tgt_counters_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_counters_ops = {
+ 	.open           = qla_dfs_tgt_counters_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  qla2x00_dfs_fce_show(struct seq_file *s, void *unused)
  {
  	scsi_qla_host_t *vha = s->private;
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index ed77a6d229e8,ac49febbac76..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2164,6 -2189,7 +2164,10 @@@ skip_cmd_array
  	}
  
  queuing_error:
++<<<<<<< HEAD
++=======
+ 	qpair->tgt_counters.num_alloc_iocb_failed++;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	return pkt;
  }
  
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7a27b61e2d53,12e76cc37fb0..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -2044,10 -3075,30 +2044,34 @@@ int qlt_xmit_response(struct qla_tgt_cm
  		return res;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
++=======
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 
+ 	if (xmit_type == QLA_TGT_XMIT_STATUS)
+ 		qpair->tgt_counters.core_qla_snd_status++;
+ 	else
+ 		qpair->tgt_counters.core_qla_que_buf++;
+ 
+ 	if (!qpair->fw_started || cmd->reset_count != qpair->chip_reset) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_PROCESSED;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg_qp(ql_dbg_async, qpair, 0xe101,
+ 			"RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, qpair->chip_reset);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 		return 0;
+ 	}
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  
  	/* Does F/W have an IOCBs for this request */
 -	res = qlt_check_reserve_free_req(qpair, full_req_cnt);
 +	res = qlt_check_reserve_free_req(vha, full_req_cnt);
  	if (unlikely(res))
  		goto out_unmap_unlock;
  
@@@ -2225,6 -3500,7 +2249,10 @@@ static int __qlt_send_term_exchange(str
  			ret = 1;
  	}
  
++<<<<<<< HEAD
++=======
+ 	qpair->tgt_counters.num_term_xchg_sent++;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	pkt->entry_count = 1;
  	pkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;
  
@@@ -3602,14 -5095,15 +3630,18 @@@ static void qlt_send_busy(struct scsi_q
  	}
  	/* Sending marker isn't necessary, since we called from ISR */
  
 -	pkt = (request_t *)__qla2x00_alloc_iocbs(qpair, NULL);
 +	pkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);
  	if (!pkt) {
 -		ql_dbg(ql_dbg_io, vha, 0x3063,
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf06e,
  		    "qla_target(%d): %s failed: unable to allocate "
  		    "request packet", vha->vp_idx, __func__);
 -		return -ENOMEM;
 +		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	qpair->tgt_counters.num_q_full_sent++;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	pkt->entry_count = 1;
  	pkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;
  
@@@ -3742,10 -5463,10 +3774,14 @@@ static void qlt_24xx_atio_pkt(struct sc
  
  /* ha->hardware_lock supposed to be held on entry */
  /* called via callback from qla2xxx */
 -static void qlt_response_pkt(struct scsi_qla_host *vha,
 -	struct rsp_que *rsp, response_t *pkt)
 +static void qlt_response_pkt(struct scsi_qla_host *vha, response_t *pkt)
  {
++<<<<<<< HEAD
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
++=======
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  
  	if (unlikely(tgt == NULL)) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe05d,
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,c4b414833b86..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -403,6 -279,12 +403,15 @@@ static void tcm_qla2xxx_complete_free(s
  {
  	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
  
++<<<<<<< HEAD
++=======
+ 	cmd->cmd_in_wq = 0;
+ 
+ 	WARN_ON(cmd->trc_flags & TRC_CMD_FREE);
+ 
+ 	cmd->qpair->tgt_counters.qla_core_ret_sta_ctio++;
+ 	cmd->trc_flags |= TRC_CMD_FREE;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	transport_generic_free_cmd(&cmd->se_cmd, 0);
  }
  
@@@ -413,8 -295,14 +422,17 @@@
   */
  static void tcm_qla2xxx_free_cmd(struct qla_tgt_cmd *cmd)
  {
++<<<<<<< HEAD
++=======
+ 	cmd->qpair->tgt_counters.core_qla_free_cmd++;
+ 	cmd->cmd_in_wq = 1;
+ 
+ 	WARN_ON(cmd->trc_flags & TRC_CMD_DONE);
+ 	cmd->trc_flags |= TRC_CMD_DONE;
+ 
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	INIT_WORK(&cmd->work, tcm_qla2xxx_complete_free);
 -	queue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);
 +	queue_work(tcm_qla2xxx_free_wq, &cmd->work);
  }
  
  /*
@@@ -592,6 -482,16 +610,19 @@@ static int tcm_qla2xxx_handle_cmd(scsi_
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_TCM_QLA2XXX_DEBUG
+ 	se_tpg = se_sess->se_tpg;
+ 	tpg = container_of(se_tpg, struct tcm_qla2xxx_tpg, se_tpg);
+ 	if (unlikely(tpg->tpg_attrib.jam_host)) {
+ 		/* return, and dont run target_submit_cmd,discarding command */
+ 		return 0;
+ 	}
+ #endif
+ 
+ 	cmd->qpair->tgt_counters.qla_core_sbt_cmd++;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	return target_submit_cmd(se_cmd, se_sess, cdb, &cmd->sense_buffer[0],
  				cmd->unpacked_lun, data_length, fcp_task_attr,
  				data_dir, flags);
@@@ -605,6 -506,20 +636,23 @@@ static void tcm_qla2xxx_handle_data_wor
  	 * Ensure that the complete FCP WRITE payload has been received.
  	 * Otherwise return an exception via CHECK_CONDITION status.
  	 */
++<<<<<<< HEAD
++=======
+ 	cmd->cmd_in_wq = 0;
+ 
+ 	spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 	cmd->data_work = 1;
+ 	if (cmd->aborted) {
+ 		cmd->data_work_free = 1;
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 		tcm_qla2xxx_free_cmd(cmd);
+ 		return;
+ 	}
+ 	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 	cmd->qpair->tgt_counters.qla_core_ret_ctio++;
++>>>>>>> 60a9eadb19f3 (scsi: qla2xxx: Move target stat counters from vha to qpair.)
  	if (!cmd->write_data_transferred) {
  		/*
  		 * Check if se_cmd has already been aborted via LUN_RESET, and
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_dfs.c
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
