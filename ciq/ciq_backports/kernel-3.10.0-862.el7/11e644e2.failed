scsi: lpfc: Fix crash doing IO with resets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix crash doing IO with resets (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 92.31%
commit-author James Smart <jsmart2021@gmail.com>
commit 11e644e2a2afa34a4d0ca896cf722572317b21ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/11e644e2.failed

During every reset, IOCBs are allocated. So, at one point, number of
allocated IOCBs reaches maximum limit and lpfc_sli_next_iotag fails.

Allocate IOCBs only during initialization. Reuse them after every reset
instead of allocating new set of IOCBs.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 11e644e2a2afa34a4d0ca896cf722572317b21ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_sli.c
diff --cc drivers/scsi/lpfc/lpfc_sli.c
index afe166ddbf5a,e948ea05fd33..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@@ -6612,19 -6896,120 +6612,136 @@@ lpfc_sli4_hba_setup(struct lpfc_hba *ph
  				"0582 Error %d during els sgl post "
  				"operation\n", rc);
  		rc = -ENODEV;
++<<<<<<< HEAD
 +		goto out_free_mbox;
 +	}
 +
 +	/* register the allocated scsi sgl pool to the port */
 +	rc = lpfc_sli4_repost_scsi_sgl_list(phba);
 +	if (unlikely(rc)) {
 +		lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
 +				"0383 Error %d during scsi sgl post "
 +				"operation\n", rc);
 +		/* Some Scsi buffers were moved to the abort scsi list */
 +		/* A pci function reset will repost them */
 +		rc = -ENODEV;
 +		goto out_free_mbox;
++=======
+ 		goto out_destroy_queue;
+ 	}
+ 	phba->sli4_hba.els_xri_cnt = rc;
+ 
+ 	if (phba->nvmet_support) {
+ 		/* update host nvmet xri-sgl sizes and mappings */
+ 		rc = lpfc_sli4_nvmet_sgl_update(phba);
+ 		if (unlikely(rc)) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
+ 					"6308 Failed to update nvmet-sgl size "
+ 					"and mapping: %d\n", rc);
+ 			goto out_destroy_queue;
+ 		}
+ 
+ 		/* register the nvmet sgl pool to the port */
+ 		rc = lpfc_sli4_repost_sgl_list(
+ 			phba,
+ 			&phba->sli4_hba.lpfc_nvmet_sgl_list,
+ 			phba->sli4_hba.nvmet_xri_cnt);
+ 		if (unlikely(rc < 0)) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
+ 					"3117 Error %d during nvmet "
+ 					"sgl post\n", rc);
+ 			rc = -ENODEV;
+ 			goto out_destroy_queue;
+ 		}
+ 		phba->sli4_hba.nvmet_xri_cnt = rc;
+ 
+ 		cnt = phba->cfg_iocb_cnt * 1024;
+ 		/* We need 1 iocbq for every SGL, for IO processing */
+ 		cnt += phba->sli4_hba.nvmet_xri_cnt;
+ 	} else {
+ 		/* update host scsi xri-sgl sizes and mappings */
+ 		rc = lpfc_sli4_scsi_sgl_update(phba);
+ 		if (unlikely(rc)) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
+ 					"6309 Failed to update scsi-sgl size "
+ 					"and mapping: %d\n", rc);
+ 			goto out_destroy_queue;
+ 		}
+ 
+ 		/* update host nvme xri-sgl sizes and mappings */
+ 		rc = lpfc_sli4_nvme_sgl_update(phba);
+ 		if (unlikely(rc)) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
+ 					"6082 Failed to update nvme-sgl size "
+ 					"and mapping: %d\n", rc);
+ 			goto out_destroy_queue;
+ 		}
+ 
+ 		cnt = phba->cfg_iocb_cnt * 1024;
+ 	}
+ 
+ 	if (!phba->sli.iocbq_lookup) {
+ 		/* Initialize and populate the iocb list per host */
+ 		lpfc_printf_log(phba, KERN_INFO, LOG_INIT,
+ 				"2821 initialize iocb list %d total %d\n",
+ 				phba->cfg_iocb_cnt, cnt);
+ 		rc = lpfc_init_iocb_list(phba, cnt);
+ 		if (rc) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 					"1413 Failed to init iocb list.\n");
+ 			goto out_destroy_queue;
+ 		}
+ 	}
+ 
+ 	if (phba->nvmet_support)
+ 		lpfc_nvmet_create_targetport(phba);
+ 
+ 	if (phba->nvmet_support && phba->cfg_nvmet_mrq) {
+ 		/* Post initial buffers to all RQs created */
+ 		for (i = 0; i < phba->cfg_nvmet_mrq; i++) {
+ 			rqbp = phba->sli4_hba.nvmet_mrq_hdr[i]->rqbp;
+ 			INIT_LIST_HEAD(&rqbp->rqb_buffer_list);
+ 			rqbp->rqb_alloc_buffer = lpfc_sli4_nvmet_alloc;
+ 			rqbp->rqb_free_buffer = lpfc_sli4_nvmet_free;
+ 			rqbp->entry_count = LPFC_NVMET_RQE_DEF_COUNT;
+ 			rqbp->buffer_count = 0;
+ 
+ 			lpfc_post_rq_buffer(
+ 				phba, phba->sli4_hba.nvmet_mrq_hdr[i],
+ 				phba->sli4_hba.nvmet_mrq_data[i],
+ 				LPFC_NVMET_RQE_DEF_COUNT, i);
+ 		}
+ 	}
+ 
+ 	if (phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP) {
+ 		/* register the allocated scsi sgl pool to the port */
+ 		rc = lpfc_sli4_repost_scsi_sgl_list(phba);
+ 		if (unlikely(rc)) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
+ 					"0383 Error %d during scsi sgl post "
+ 					"operation\n", rc);
+ 			/* Some Scsi buffers were moved to abort scsi list */
+ 			/* A pci function reset will repost them */
+ 			rc = -ENODEV;
+ 			goto out_destroy_queue;
+ 		}
+ 	}
+ 
+ 	if ((phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME) &&
+ 	    (phba->nvmet_support == 0)) {
+ 
+ 		/* register the allocated nvme sgl pool to the port */
+ 		rc = lpfc_repost_nvme_sgl_list(phba);
+ 		if (unlikely(rc)) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
+ 					"6116 Error %d during nvme sgl post "
+ 					"operation\n", rc);
+ 			/* Some NVME buffers were moved to abort nvme list */
+ 			/* A pci function reset will repost them */
+ 			rc = -ENODEV;
+ 			goto out_destroy_queue;
+ 		}
++>>>>>>> 11e644e2a2af (scsi: lpfc: Fix crash doing IO with resets)
  	}
  
  	/* Post the rpi header region to the device. */
* Unmerged path drivers/scsi/lpfc/lpfc_sli.c
