IB/mlx5: Expose extended error counters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Parav Pandit <parav@mellanox.com>
commit 58dcb60a226ee48cc66c96c27b751f06ec2bc5a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/58dcb60a.failed

This patch adds below requester and responder side error counters,
which will be exposed by hardware counters interface and are supported
as part of query Q counters command extension.

 +---------------------------+-------------------------------------+
 |      Name                 |           Description               |
 |---------------------------+-------------------------------------|
 |resp_local_length_error    | Number of times responder detected  |
 |                           | local length errors                 |
 |---------------------------+-------------------------------------|
 |resp_cqe_error             | Number of CQEs completed with error |
 |                           | at responder                        |
 |---------------------------+-------------------------------------|
 |req_cqe_error              | Number of CQEs completed with error |
 |                           | at requester                        |
 |---------------------------+-------------------------------------|
 |req_remote_invalid_request | Number of times requester detected  |
 |                           | remote invalid request error        |
 |---------------------------+-------------------------------------|
 |req_remote_access_error    | Number of times requester detected  |
 |                           | remote access error                 |
 |---------------------------+-------------------------------------|
 |resp_remote_access_error   | Number of times responder detected  |
 |                           | remote access error                 |
 |---------------------------+-------------------------------------|
 |resp_cqe_flush_error       | Number of CQEs completed with       |
 |                           | flushed with error at responder     |
 |---------------------------+-------------------------------------|
 |req_cqe_flush_error        | Number of CQEs completed with       |
 |                           | flushed with error at requester     |
 +---------------------------+-------------------------------------+

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Reviewed-by: Eli Cohen <eli@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 58dcb60a226ee48cc66c96c27b751f06ec2bc5a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 278c0964f404,9dd9759459fb..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -3180,88 -3394,148 +3180,187 @@@ static void mlx5_disable_eth(struct mlx
  		mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
 -struct mlx5_ib_counter {
 -	const char *name;
 -	size_t offset;
 +static const char * const names[] = {
 +	"rx_write_requests",
 +	"rx_read_requests",
 +	"rx_atomic_requests",
 +	"out_of_buffer",
 +	"out_of_sequence",
 +	"duplicate_request",
 +	"rnr_nak_retry_err",
 +	"packet_seq_err",
 +	"implied_nak_seq_err",
 +	"local_ack_timeout_err",
  };
  
 -#define INIT_Q_COUNTER(_name)		\
 -	{ .name = #_name, .offset = MLX5_BYTE_OFF(query_q_counter_out, _name)}
 -
 -static const struct mlx5_ib_counter basic_q_cnts[] = {
 -	INIT_Q_COUNTER(rx_write_requests),
 -	INIT_Q_COUNTER(rx_read_requests),
 -	INIT_Q_COUNTER(rx_atomic_requests),
 -	INIT_Q_COUNTER(out_of_buffer),
 +static const size_t stats_offsets[] = {
 +	MLX5_BYTE_OFF(query_q_counter_out, rx_write_requests),
 +	MLX5_BYTE_OFF(query_q_counter_out, rx_read_requests),
 +	MLX5_BYTE_OFF(query_q_counter_out, rx_atomic_requests),
 +	MLX5_BYTE_OFF(query_q_counter_out, out_of_buffer),
 +	MLX5_BYTE_OFF(query_q_counter_out, out_of_sequence),
 +	MLX5_BYTE_OFF(query_q_counter_out, duplicate_request),
 +	MLX5_BYTE_OFF(query_q_counter_out, rnr_nak_retry_err),
 +	MLX5_BYTE_OFF(query_q_counter_out, packet_seq_err),
 +	MLX5_BYTE_OFF(query_q_counter_out, implied_nak_seq_err),
 +	MLX5_BYTE_OFF(query_q_counter_out, local_ack_timeout_err),
  };
  
 -static const struct mlx5_ib_counter out_of_seq_q_cnts[] = {
 -	INIT_Q_COUNTER(out_of_sequence),
 -};
 +static struct rdma_hw_stats *mlx5_ib_alloc_hw_stats(struct ib_device *ibdev,
 +						    u8 port_num)
 +{
 +	BUILD_BUG_ON(ARRAY_SIZE(names) != ARRAY_SIZE(stats_offsets));
  
 -static const struct mlx5_ib_counter retrans_q_cnts[] = {
 -	INIT_Q_COUNTER(duplicate_request),
 -	INIT_Q_COUNTER(rnr_nak_retry_err),
 -	INIT_Q_COUNTER(packet_seq_err),
 -	INIT_Q_COUNTER(implied_nak_seq_err),
 -	INIT_Q_COUNTER(local_ack_timeout_err),
 -};
 +	/* We support only per port stats */
 +	if (port_num == 0)
 +		return NULL;
  
 -#define INIT_CONG_COUNTER(_name)		\
 -	{ .name = #_name, .offset =	\
 -		MLX5_BYTE_OFF(query_cong_statistics_out, _name ## _high)}
 +	return rdma_alloc_hw_stats_struct(names, ARRAY_SIZE(names),
 +					  RDMA_HW_STATS_DEFAULT_LIFESPAN);
 +}
  
 -static const struct mlx5_ib_counter cong_cnts[] = {
 -	INIT_CONG_COUNTER(rp_cnp_ignored),
 -	INIT_CONG_COUNTER(rp_cnp_handled),
 -	INIT_CONG_COUNTER(np_ecn_marked_roce_packets),
 -	INIT_CONG_COUNTER(np_cnp_sent),
 -};
 +static int mlx5_ib_get_hw_stats(struct ib_device *ibdev,
 +				struct rdma_hw_stats *stats,
 +				u8 port, int index)
 +{
 +	struct mlx5_ib_dev *dev = to_mdev(ibdev);
 +	int outlen = MLX5_ST_SZ_BYTES(query_q_counter_out);
 +	void *out;
 +	__be32 val;
 +	int ret;
 +	int i;
 +
++<<<<<<< HEAD
 +	if (!port || !stats)
 +		return -ENOSYS;
 +
 +	out = mlx5_vzalloc(outlen);
 +	if (!out)
 +		return -ENOMEM;
 +
 +	ret = mlx5_core_query_q_counter(dev->mdev,
 +					dev->port[port - 1].q_cnt_id, 0,
 +					out, outlen);
 +	if (ret)
 +		goto free;
 +
 +	for (i = 0; i < ARRAY_SIZE(names); i++) {
 +		val = *(__be32 *)(out + stats_offsets[i]);
 +		stats->value[i] = (u64)be32_to_cpu(val);
 +	}
 +free:
 +	kvfree(out);
 +	return ARRAY_SIZE(names);
 +}
  
 +static void mlx5_ib_dealloc_q_counters(struct mlx5_ib_dev *dev)
++=======
+ static const struct mlx5_ib_counter extended_err_cnts[] = {
+ 	INIT_Q_COUNTER(resp_local_length_error),
+ 	INIT_Q_COUNTER(resp_cqe_error),
+ 	INIT_Q_COUNTER(req_cqe_error),
+ 	INIT_Q_COUNTER(req_remote_invalid_request),
+ 	INIT_Q_COUNTER(req_remote_access_errors),
+ 	INIT_Q_COUNTER(resp_remote_access_errors),
+ 	INIT_Q_COUNTER(resp_cqe_flush_error),
+ 	INIT_Q_COUNTER(req_cqe_flush_error),
+ };
+ 
+ static void mlx5_ib_dealloc_counters(struct mlx5_ib_dev *dev)
++>>>>>>> 58dcb60a226e (IB/mlx5: Expose extended error counters)
  {
  	unsigned int i;
  
 -	for (i = 0; i < dev->num_ports; i++) {
 +	for (i = 0; i < dev->num_ports; i++)
  		mlx5_core_dealloc_q_counter(dev->mdev,
 -					    dev->port[i].cnts.set_id);
 -		kfree(dev->port[i].cnts.names);
 -		kfree(dev->port[i].cnts.offsets);
 -	}
 +					    dev->port[i].q_cnt_id);
  }
  
++<<<<<<< HEAD
 +static int mlx5_ib_alloc_q_counters(struct mlx5_ib_dev *dev)
++=======
+ static int __mlx5_ib_alloc_counters(struct mlx5_ib_dev *dev,
+ 				    struct mlx5_ib_counters *cnts)
+ {
+ 	u32 num_counters;
+ 
+ 	num_counters = ARRAY_SIZE(basic_q_cnts);
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, out_of_seq_cnt))
+ 		num_counters += ARRAY_SIZE(out_of_seq_q_cnts);
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, retransmission_q_counters))
+ 		num_counters += ARRAY_SIZE(retrans_q_cnts);
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, enhanced_error_q_counters))
+ 		num_counters += ARRAY_SIZE(extended_err_cnts);
+ 
+ 	cnts->num_q_counters = num_counters;
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, cc_query_allowed)) {
+ 		cnts->num_cong_counters = ARRAY_SIZE(cong_cnts);
+ 		num_counters += ARRAY_SIZE(cong_cnts);
+ 	}
+ 
+ 	cnts->names = kcalloc(num_counters, sizeof(cnts->names), GFP_KERNEL);
+ 	if (!cnts->names)
+ 		return -ENOMEM;
+ 
+ 	cnts->offsets = kcalloc(num_counters,
+ 				sizeof(cnts->offsets), GFP_KERNEL);
+ 	if (!cnts->offsets)
+ 		goto err_names;
+ 
+ 	return 0;
+ 
+ err_names:
+ 	kfree(cnts->names);
+ 	return -ENOMEM;
+ }
+ 
+ static void mlx5_ib_fill_counters(struct mlx5_ib_dev *dev,
+ 				  const char **names,
+ 				  size_t *offsets)
+ {
+ 	int i;
+ 	int j = 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(basic_q_cnts); i++, j++) {
+ 		names[j] = basic_q_cnts[i].name;
+ 		offsets[j] = basic_q_cnts[i].offset;
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, out_of_seq_cnt)) {
+ 		for (i = 0; i < ARRAY_SIZE(out_of_seq_q_cnts); i++, j++) {
+ 			names[j] = out_of_seq_q_cnts[i].name;
+ 			offsets[j] = out_of_seq_q_cnts[i].offset;
+ 		}
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, retransmission_q_counters)) {
+ 		for (i = 0; i < ARRAY_SIZE(retrans_q_cnts); i++, j++) {
+ 			names[j] = retrans_q_cnts[i].name;
+ 			offsets[j] = retrans_q_cnts[i].offset;
+ 		}
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, enhanced_error_q_counters)) {
+ 		for (i = 0; i < ARRAY_SIZE(extended_err_cnts); i++, j++) {
+ 			names[j] = extended_err_cnts[i].name;
+ 			offsets[j] = extended_err_cnts[i].offset;
+ 		}
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev->mdev, cc_query_allowed)) {
+ 		for (i = 0; i < ARRAY_SIZE(cong_cnts); i++, j++) {
+ 			names[j] = cong_cnts[i].name;
+ 			offsets[j] = cong_cnts[i].offset;
+ 		}
+ 	}
+ }
+ 
+ static int mlx5_ib_alloc_counters(struct mlx5_ib_dev *dev)
++>>>>>>> 58dcb60a226e (IB/mlx5: Expose extended error counters)
  {
  	int i;
  	int ret;
* Unmerged path drivers/infiniband/hw/mlx5/main.c
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index 7814f59a455b..8419d7541be9 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -844,7 +844,7 @@ struct mlx5_ifc_cmd_hca_cap_bits {
 	u8         pcam_reg[0x1];
 	u8         local_ca_ack_delay[0x5];
 	u8         port_module_event[0x1];
-	u8         reserved_at_1b1[0x1];
+	u8         enhanced_error_q_counters[0x1];
 	u8         ports_check[0x1];
 	u8         reserved_at_1b3[0x1];
 	u8         disable_link_up[0x1];
@@ -3924,7 +3924,47 @@ struct mlx5_ifc_query_q_counter_out_bits {
 
 	u8         local_ack_timeout_err[0x20];
 
-	u8         reserved_at_320[0x4e0];
+	u8         reserved_at_320[0xa0];
+
+	u8         resp_local_length_error[0x20];
+
+	u8         req_local_length_error[0x20];
+
+	u8         resp_local_qp_error[0x20];
+
+	u8         local_operation_error[0x20];
+
+	u8         resp_local_protection[0x20];
+
+	u8         req_local_protection[0x20];
+
+	u8         resp_cqe_error[0x20];
+
+	u8         req_cqe_error[0x20];
+
+	u8         req_mw_binding[0x20];
+
+	u8         req_bad_response[0x20];
+
+	u8         req_remote_invalid_request[0x20];
+
+	u8         resp_remote_invalid_request[0x20];
+
+	u8         req_remote_access_errors[0x20];
+
+	u8	   resp_remote_access_errors[0x20];
+
+	u8         req_remote_operation_errors[0x20];
+
+	u8         req_transport_retries_exceeded[0x20];
+
+	u8         cq_overflow[0x20];
+
+	u8         resp_cqe_flush_error[0x20];
+
+	u8         req_cqe_flush_error[0x20];
+
+	u8         reserved_at_620[0x1e0];
 };
 
 struct mlx5_ifc_query_q_counter_in_bits {
