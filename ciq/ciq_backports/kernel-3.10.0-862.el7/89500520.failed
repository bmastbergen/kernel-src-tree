dmaengine: dw: apply both HS interfaces and remove slave_id usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: dmaengine: dw: apply both HS interfaces and remove slave_id usage (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 95.59%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 8950052029874a6738552debb45077c596e90e6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/89500520.failed

Instead of one request line member let's use both source and destination ones.
Usually we have no such hardware except Atmel MMC controller found on AVR32
platform (see arch/avr32/mach-at32ap/at32ap700x.c and
drivers/mmc/host/atmel-mci.c).

This patch removes slave_id usage since it'll be removed from the generic
structure in later. This breaks the non-ACPI / non-DT cases for the users of
the driver, i.e. SPI and HSUART. However, these cases mean only PCI enumerated
devices for now, which is anyway broken (considering more than one DMA
controller in the system) and this patch series is intended to fix that
eventually.

The ACPI and DT cases shall be aware of the channel direction when setting
request lines, but this is a minor problem that would be addressed in future.

	Suggested-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit 8950052029874a6738552debb45077c596e90e6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dw/platform.c
#	drivers/dma/dw_dmac.c
diff --cc drivers/dma/dw_dmac.c
index e4409f73fad7,1c4521283fa9..000000000000
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@@ -41,28 -37,6 +41,31 @@@
   * support descriptor writeback.
   */
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +static inline unsigned int dwc_get_dms(struct dw_dma_slave *slave)
 +{
 +	return slave ? slave->dst_master : 0;
 +}
 +
 +static inline unsigned int dwc_get_sms(struct dw_dma_slave *slave)
 +{
 +	return slave ? slave->src_master : 1;
 +}
 +
 +static inline void dwc_set_masters(struct dw_dma_chan *dwc)
 +{
 +	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
 +	struct dw_dma_slave *dws = dwc->chan.private;
 +	unsigned char mmax = dw->nr_masters - 1;
 +
 +	if (dwc->request_line == ~0) {
 +		dwc->src_master = min_t(unsigned char, mmax, dwc_get_sms(dws));
 +		dwc->dst_master = min_t(unsigned char, mmax, dwc_get_dms(dws));
 +	}
 +}
 +
++=======
++>>>>>>> 895005202987 (dmaengine: dw: apply both HS interfaces and remove slave_id usage):drivers/dma/dw/core.c
  #define DWC_DEFAULT_CTLLO(_chan) ({				\
  		struct dw_dma_chan *_dwc = to_dw_dma_chan(_chan);	\
  		struct dma_slave_config	*_sconfig = &_dwc->dma_sconfig;	\
@@@ -995,10 -947,6 +996,13 @@@ set_runtime_config(struct dma_chan *cha
  	memcpy(&dwc->dma_sconfig, sconfig, sizeof(*sconfig));
  	dwc->direction = sconfig->direction;
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	/* Take the request line from slave_id member */
 +	if (dwc->request_line == ~0)
 +		dwc->request_line = sconfig->slave_id;
 +
++=======
++>>>>>>> 895005202987 (dmaengine: dw: apply both HS interfaces and remove slave_id usage):drivers/dma/dw/core.c
  	convert_burst(&dwc->dma_sconfig.src_maxburst);
  	convert_burst(&dwc->dma_sconfig.dst_maxburst);
  
* Unmerged path drivers/dma/dw/platform.c
* Unmerged path drivers/dma/dw/platform.c
* Unmerged path drivers/dma/dw_dmac.c
diff --git a/drivers/dma/dw_dmac_regs.h b/drivers/dma/dw_dmac_regs.h
index 9d417200bd57..f6753ef69b15 100644
--- a/drivers/dma/dw_dmac_regs.h
+++ b/drivers/dma/dw_dmac_regs.h
@@ -214,9 +214,10 @@ struct dw_dma_chan {
 	bool			nollp;
 
 	/* custom slave configuration */
-	unsigned int		request_line;
-	unsigned char		src_master;
-	unsigned char		dst_master;
+	u8			src_id;
+	u8			dst_id;
+	u8			src_master;
+	u8			dst_master;
 
 	/* configuration passed via DMA_SLAVE_CONFIG */
 	struct dma_slave_config dma_sconfig;
