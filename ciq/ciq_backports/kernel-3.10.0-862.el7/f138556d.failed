mm/mprotect.c: don't imply PROT_EXEC on non-exec fs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] mprotect.c: don't imply PROT_EXEC on non-exec fs (Rui Wang) [1272615]
Rebuild_FUZZ: 96.97%
commit-author Piotr Kwapulinski <kwapulinski.piotr@gmail.com>
commit f138556daf62665f19178732ec4daf86c4ca13f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f138556d.failed

The mprotect(PROT_READ) fails when called by the READ_IMPLIES_EXEC
binary on a memory mapped file located on non-exec fs.  The mprotect
does not check whether fs is _executable_ or not.  The PROT_EXEC flag is
set automatically even if a memory mapped file is located on non-exec
fs.  Fix it by checking whether a memory mapped file is located on a
non-exec fs.  If so the PROT_EXEC is not implied by the PROT_READ.  The
implementation uses the VM_MAYEXEC flag set properly in mmap.  Now it is
consistent with mmap.

I did the isolated tests (PT_GNU_STACK X/NX, multiple VMAs, X/NX fs).  I
also patched the official 3.19.0-47-generic Ubuntu 14.04 kernel and it
seems to work.

	Signed-off-by: Piotr Kwapulinski <kwapulinski.piotr@gmail.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f138556daf62665f19178732ec4daf86c4ca13f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mprotect.c
diff --cc mm/mprotect.c
index 12cbcc768180,b650c5412f58..000000000000
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@@ -355,14 -378,7 +358,9 @@@ SYSCALL_DEFINE3(mprotect, unsigned long
  		return -EINVAL;
  
  	reqprot = prot;
- 	/*
- 	 * Does the application expect PROT_READ to imply PROT_EXEC:
- 	 */
- 	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
- 		prot |= PROT_EXEC;
  
 +	vm_flags = calc_vm_prot_bits(prot);
 +
  	down_write(&current->mm->mmap_sem);
  
  	vma = find_vma(current->mm, start);
@@@ -395,7 -411,12 +393,15 @@@
  
  		/* Here we know that vma->vm_start <= nstart < vma->vm_end. */
  
++<<<<<<< HEAD
 +		newflags = vm_flags;
++=======
+ 		/* Does the application expect PROT_READ to imply PROT_EXEC */
+ 		if (rier && (vma->vm_flags & VM_MAYEXEC))
+ 			prot |= PROT_EXEC;
+ 
+ 		newflags = calc_vm_prot_bits(prot, pkey);
++>>>>>>> f138556daf62 (mm/mprotect.c: don't imply PROT_EXEC on non-exec fs)
  		newflags |= (vma->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));
  
  		/* newflags >> 4 shift VM_MAY% in place of VM_% */
* Unmerged path mm/mprotect.c
