mlxsw: spectrum_router: Prepare nexthop group's hash table for IPv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit ba31d3666924adf1b4ad8e19400324a06b99c52c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ba31d366.failed

This patch does preparation before introducing IPv6 nexthop group
consolidation. Currently the nexthop group hash table is used only by
IPv4 and uses fixed key size. In order to support the IPv6's variable
length key the current table is changed.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ba31d3666924adf1b4ad8e19400324a06b99c52c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 4a30fec5c668,510042905f22..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1184,27 -1522,60 +1184,64 @@@ struct mlxsw_sp_nexthop 
  	struct mlxsw_sp_neigh_entry *neigh_entry;
  };
  
- struct mlxsw_sp_nexthop_group_key {
- 	struct fib_info *fi;
- };
- 
  struct mlxsw_sp_nexthop_group {
+ 	void *priv;
  	struct rhash_head ht_node;
  	struct list_head fib_list; /* list of fib entries that use this group */
++<<<<<<< HEAD
 +	struct mlxsw_sp_nexthop_group_key key;
++=======
+ 	struct neigh_table *neigh_tbl;
++>>>>>>> ba31d3666924 (mlxsw: spectrum_router: Prepare nexthop group's hash table for IPv6)
  	u8 adj_index_valid:1,
  	   gateway:1; /* routes using the group use a gateway */
  	u32 adj_index;
  	u16 ecmp_size;
  	u16 count;
  	struct mlxsw_sp_nexthop nexthops[0];
 -#define nh_rif	nexthops[0].rif
 +#define nh_rif	nexthops[0].r
  };
  
+ static struct fib_info *
+ mlxsw_sp_nexthop4_group_fi(const struct mlxsw_sp_nexthop_group *nh_grp)
+ {
+ 	return nh_grp->priv;
+ }
+ 
+ struct mlxsw_sp_nexthop_group_cmp_arg {
+ 	struct fib_info *fi;
+ };
+ 
+ static int
+ mlxsw_sp_nexthop_group_cmp(struct rhashtable_compare_arg *arg, const void *ptr)
+ {
+ 	const struct mlxsw_sp_nexthop_group_cmp_arg *cmp_arg = arg->key;
+ 	const struct mlxsw_sp_nexthop_group *nh_grp = ptr;
+ 
+ 	return cmp_arg->fi != mlxsw_sp_nexthop4_group_fi(nh_grp);
+ }
+ 
+ static u32 mlxsw_sp_nexthop_group_hash_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct mlxsw_sp_nexthop_group *nh_grp = data;
+ 	struct fib_info *fi = mlxsw_sp_nexthop4_group_fi(nh_grp);
+ 
+ 	return jhash(&fi, sizeof(fi), seed);
+ }
+ 
+ static u32
+ mlxsw_sp_nexthop_group_hash(const void *data, u32 len, u32 seed)
+ {
+ 	const struct mlxsw_sp_nexthop_group_cmp_arg *cmp_arg = data;
+ 
+ 	return jhash(&cmp_arg->fi, sizeof(cmp_arg->fi), seed);
+ }
+ 
  static const struct rhashtable_params mlxsw_sp_nexthop_group_ht_params = {
- 	.key_offset = offsetof(struct mlxsw_sp_nexthop_group, key),
  	.head_offset = offsetof(struct mlxsw_sp_nexthop_group, ht_node),
- 	.key_len = sizeof(struct mlxsw_sp_nexthop_group_key),
+ 	.hashfn	     = mlxsw_sp_nexthop_group_hash,
+ 	.obj_hashfn  = mlxsw_sp_nexthop_group_hash_obj,
+ 	.obj_cmpfn   = mlxsw_sp_nexthop_group_cmp,
  };
  
  static int mlxsw_sp_nexthop_group_insert(struct mlxsw_sp *mlxsw_sp,
@@@ -1224,10 -1595,14 +1261,18 @@@ static void mlxsw_sp_nexthop_group_remo
  }
  
  static struct mlxsw_sp_nexthop_group *
- mlxsw_sp_nexthop_group_lookup(struct mlxsw_sp *mlxsw_sp,
- 			      struct mlxsw_sp_nexthop_group_key key)
+ mlxsw_sp_nexthop4_group_lookup(struct mlxsw_sp *mlxsw_sp,
+ 			       struct fib_info *fi)
  {
++<<<<<<< HEAD
 +	return rhashtable_lookup_fast(&mlxsw_sp->router.nexthop_group_ht, &key,
++=======
+ 	struct mlxsw_sp_nexthop_group_cmp_arg cmp_arg;
+ 
+ 	cmp_arg.fi = fi;
+ 	return rhashtable_lookup_fast(&mlxsw_sp->router->nexthop_group_ht,
+ 				      &cmp_arg,
++>>>>>>> ba31d3666924 (mlxsw: spectrum_router: Prepare nexthop group's hash table for IPv6)
  				      mlxsw_sp_nexthop_group_ht_params);
  }
  
@@@ -1725,10 -2099,12 +1770,10 @@@ mlxsw_sp_nexthop_group_create(struct ml
  	nh_grp = kzalloc(alloc_size, GFP_KERNEL);
  	if (!nh_grp)
  		return ERR_PTR(-ENOMEM);
+ 	nh_grp->priv = fi;
  	INIT_LIST_HEAD(&nh_grp->fib_list);
 -	nh_grp->neigh_tbl = &arp_tbl;
 -
  	nh_grp->gateway = fi->fib_nh->nh_scope == RT_SCOPE_LINK;
  	nh_grp->count = fi->fib_nhs;
- 	nh_grp->key.fi = fi;
  	fib_info_hold(fi);
  	for (i = 0; i < nh_grp->count; i++) {
  		nh = &nh_grp->nexthops[i];
@@@ -1744,12 -2120,12 +1789,12 @@@
  	return nh_grp;
  
  err_nexthop_group_insert:
 -err_nexthop4_init:
 +err_nexthop_init:
  	for (i--; i >= 0; i--) {
  		nh = &nh_grp->nexthops[i];
 -		mlxsw_sp_nexthop4_fini(mlxsw_sp, nh);
 +		mlxsw_sp_nexthop_fini(mlxsw_sp, nh);
  	}
- 	fib_info_put(nh_grp->key.fi);
+ 	fib_info_put(fi);
  	kfree(nh_grp);
  	return ERR_PTR(err);
  }
@@@ -1772,17 -2148,15 +1817,15 @@@ mlxsw_sp_nexthop_group_destroy(struct m
  	kfree(nh_grp);
  }
  
 -static int mlxsw_sp_nexthop4_group_get(struct mlxsw_sp *mlxsw_sp,
 -				       struct mlxsw_sp_fib_entry *fib_entry,
 -				       struct fib_info *fi)
 +static int mlxsw_sp_nexthop_group_get(struct mlxsw_sp *mlxsw_sp,
 +				      struct mlxsw_sp_fib_entry *fib_entry,
 +				      struct fib_info *fi)
  {
- 	struct mlxsw_sp_nexthop_group_key key;
  	struct mlxsw_sp_nexthop_group *nh_grp;
  
- 	key.fi = fi;
- 	nh_grp = mlxsw_sp_nexthop_group_lookup(mlxsw_sp, key);
+ 	nh_grp = mlxsw_sp_nexthop4_group_lookup(mlxsw_sp, fi);
  	if (!nh_grp) {
 -		nh_grp = mlxsw_sp_nexthop4_group_create(mlxsw_sp, fi);
 +		nh_grp = mlxsw_sp_nexthop_group_create(mlxsw_sp, fi);
  		if (IS_ERR(nh_grp))
  			return PTR_ERR(nh_grp);
  	}
@@@ -2130,12 -2581,13 +2173,22 @@@ mlxsw_sp_fib4_entry_lookup(struct mlxsw
  	if (!fib_node)
  		return NULL;
  
++<<<<<<< HEAD
 +	list_for_each_entry(fib_entry, &fib_node->entry_list, list) {
 +		if (fib_entry->params.tb_id == fen_info->tb_id &&
 +		    fib_entry->params.tos == fen_info->tos &&
 +		    fib_entry->params.type == fen_info->type &&
 +		    fib_entry->nh_group->key.fi == fen_info->fi) {
 +			return fib_entry;
++=======
+ 	list_for_each_entry(fib4_entry, &fib_node->entry_list, common.list) {
+ 		if (fib4_entry->tb_id == fen_info->tb_id &&
+ 		    fib4_entry->tos == fen_info->tos &&
+ 		    fib4_entry->type == fen_info->type &&
+ 		    mlxsw_sp_nexthop4_group_fi(fib4_entry->common.nh_group) ==
+ 		    fen_info->fi) {
+ 			return fib4_entry;
++>>>>>>> ba31d3666924 (mlxsw: spectrum_router: Prepare nexthop group's hash table for IPv6)
  		}
  	}
  
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
