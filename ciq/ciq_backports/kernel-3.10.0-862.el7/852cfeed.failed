mlxsw: spectrum_switchdev: Release multicast groups during fini

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 852cfeed0ebe93a1c1e0c153c04a57221f72bd7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/852cfeed.failed

Each multicast group (MID) stores a bitmap of ports to which a packet
should be forwarded to in case an MDB entry associated with the MID is
hit.

Since the initial introduction of IGMP snooping in commit 3a49b4fde2a1
("mlxsw: Adding layer 2 multicast support") the driver didn't correctly
free these multicast groups upon ungraceful situations such as the
removal of the upper bridge device or module removal.

The correct way to fix this is to associate each MID with the bridge
ports member in it and then drop the reference in case the bridge port
is destroyed, but this will result in a lot more code and will be fixed
in net-next.

For now, upon module removal, traverse the MID list and release each
one.

Fixes: 3a49b4fde2a1 ("mlxsw: Adding layer 2 multicast support")
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 852cfeed0ebe93a1c1e0c153c04a57221f72bd7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index a7736231096b,5eb1606765c5..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -1503,17 -1969,47 +1503,34 @@@ static int mlxsw_sp_fdb_init(struct mlx
  
  static void mlxsw_sp_fdb_fini(struct mlxsw_sp *mlxsw_sp)
  {
 -	cancel_delayed_work_sync(&mlxsw_sp->bridge->fdb_notify.dw);
 -	unregister_switchdev_notifier(&mlxsw_sp_switchdev_notifier);
 -
 +	cancel_delayed_work_sync(&mlxsw_sp->fdb_notify.dw);
  }
  
+ static void mlxsw_sp_mids_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct mlxsw_sp_mid *mid, *tmp;
+ 
+ 	list_for_each_entry_safe(mid, tmp, &mlxsw_sp->bridge->mids_list, list) {
+ 		list_del(&mid->list);
+ 		clear_bit(mid->mid, mlxsw_sp->bridge->mids_bitmap);
+ 		kfree(mid);
+ 	}
+ }
+ 
  int mlxsw_sp_switchdev_init(struct mlxsw_sp *mlxsw_sp)
  {
 -	struct mlxsw_sp_bridge *bridge;
 -
 -	bridge = kzalloc(sizeof(*mlxsw_sp->bridge), GFP_KERNEL);
 -	if (!bridge)
 -		return -ENOMEM;
 -	mlxsw_sp->bridge = bridge;
 -	bridge->mlxsw_sp = mlxsw_sp;
 -
 -	INIT_LIST_HEAD(&mlxsw_sp->bridge->bridges_list);
 -	INIT_LIST_HEAD(&mlxsw_sp->bridge->mids_list);
 -
 -	bridge->bridge_8021q_ops = &mlxsw_sp_bridge_8021q_ops;
 -	bridge->bridge_8021d_ops = &mlxsw_sp_bridge_8021d_ops;
 -
  	return mlxsw_sp_fdb_init(mlxsw_sp);
  }
  
  void mlxsw_sp_switchdev_fini(struct mlxsw_sp *mlxsw_sp)
  {
  	mlxsw_sp_fdb_fini(mlxsw_sp);
++<<<<<<< HEAD
++=======
+ 	mlxsw_sp_mids_fini(mlxsw_sp);
+ 	WARN_ON(!list_empty(&mlxsw_sp->bridge->bridges_list));
+ 	kfree(mlxsw_sp->bridge);
++>>>>>>> 852cfeed0ebe (mlxsw: spectrum_switchdev: Release multicast groups during fini)
  }
  
  void mlxsw_sp_port_switchdev_init(struct mlxsw_sp_port *mlxsw_sp_port)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
