sysfs, kernfs: make super_blocks bind to different kernfs_roots

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit df394fb56c64244b30b442e9e02de1a2d9c5a98b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/df394fb5.failed

kernfs is being updated to allow multiple sysfs_dirent hierarchies so
that it can also be used by other users.  Currently, sysfs
super_blocks are always attached to one kernfs_root - sysfs_root - and
distinguished only by their namespace tags.

This patch adds sysfs_super_info->root and update
sysfs_fill/test_super() so that super_blocks are identified by the
combination of both the associated kernfs_root and namespace tag.
This allows mounting different kernfs hierarchies.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit df394fb56c64244b30b442e9e02de1a2d9c5a98b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/mount.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/mount.c
index 59ee03fe48e1,f143b203a7e6..000000000000
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@@ -65,10 -59,11 +66,15 @@@ static int sysfs_fill_super(struct supe
  	/* instantiate and link root dentry */
  	root = d_make_root(inode);
  	if (!root) {
 -		pr_debug("%s: could not get root dentry!\n", __func__);
 +		pr_debug("%s: could not get root dentry!\n",__func__);
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
 +	root->d_fsdata = sysfs_root_sd;
++=======
+ 	kernfs_get(info->root->sd);
+ 	root->d_fsdata = info->root->sd;
++>>>>>>> df394fb56c64 (sysfs, kernfs: make super_blocks bind to different kernfs_roots)
  	sb->s_root = root;
  	sb->s_d_op = &sysfs_dentry_ops;
  	return 0;
@@@ -78,14 -73,8 +84,18 @@@ static int sysfs_test_super(struct supe
  {
  	struct sysfs_super_info *sb_info = sysfs_info(sb);
  	struct sysfs_super_info *info = data;
 +	enum kobj_ns_type type;
 +	int found = 1;
  
++<<<<<<< HEAD
 +	for (type = KOBJ_NS_TYPE_NONE; type < KOBJ_NS_TYPES; type++) {
 +		if (sb_info->ns[type] != info->ns[type])
 +			found = 0;
 +	}
 +	return found;
++=======
+ 	return sb_info->root == info->root && sb_info->ns == info->ns;
++>>>>>>> df394fb56c64 (sysfs, kernfs: make super_blocks bind to different kernfs_roots)
  }
  
  static int sysfs_set_super(struct super_block *sb, void *data)
@@@ -120,8 -111,8 +130,13 @@@ static struct dentry *sysfs_mount(struc
  	if (!info)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	for (type = KOBJ_NS_TYPE_NONE; type < KOBJ_NS_TYPES; type++)
 +		info->ns[type] = kobj_ns_grab_current(type);
++=======
+ 	info->root = sysfs_root;
+ 	info->ns = kobj_ns_grab_current(KOBJ_NS_TYPE_NET);
++>>>>>>> df394fb56c64 (sysfs, kernfs: make super_blocks bind to different kernfs_roots)
  
  	sb = sget(fs_type, sysfs_test_super, sysfs_set_super, flags, info);
  	if (IS_ERR(sb) || sb->s_fs_info != info)
diff --cc fs/sysfs/sysfs.h
index 0d53c3e35ad6,93b4b68458ad..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -140,13 -18,20 +140,29 @@@ struct sysfs_addrm_cxt 
   * mount.c
   */
  
 +/*
 + * Each sb is associated with a set of namespace tags (i.e.
 + * the network namespace of the task which mounted this sysfs
 + * instance).
 + */
  struct sysfs_super_info {
++<<<<<<< HEAD
 +	void *ns[KOBJ_NS_TYPES];
++=======
+ 	/*
+ 	 * The root associated with this super_block.  Each super_block is
+ 	 * identified by the root and ns it's associated with.
+ 	 */
+ 	struct kernfs_root	*root;
+ 
+ 	/*
+ 	 * Each sb is associated with one namespace tag, currently the network
+ 	 * namespace of the task which mounted this sysfs instance.  If multiple
+ 	 * tags become necessary, make the following an array and compare
+ 	 * sysfs_dirent tag against every entry.
+ 	 */
+ 	const void		*ns;
++>>>>>>> df394fb56c64 (sysfs, kernfs: make super_blocks bind to different kernfs_roots)
  };
  #define sysfs_info(SB) ((struct sysfs_super_info *)(SB->s_fs_info))
  extern struct sysfs_dirent *sysfs_root_sd;
* Unmerged path fs/sysfs/mount.c
* Unmerged path fs/sysfs/sysfs.h
