iw_cxgb4: allocate wait object for each ep object

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Steve Wise <swise@opengridcomputing.com>
commit ef885dc66c29dd8e6f6a12f164ed11237323c234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ef885dc6.failed

Remove the embedded c4iw_wr_wait object in preparation for correctly
handling timeouts.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit ef885dc66c29dd8e6f6a12f164ed11237323c234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 9b70d4724eb7,72a2d349c7fa..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -318,11 -318,18 +318,22 @@@ static void *alloc_ep(int size, gfp_t g
  
  	epc = kzalloc(size, gfp);
  	if (epc) {
+ 		epc->wr_waitp = kzalloc(sizeof(*epc->wr_waitp), gfp);
+ 		if (!epc->wr_waitp) {
+ 			kfree(epc);
+ 			epc = NULL;
+ 			goto out;
+ 		}
  		kref_init(&epc->kref);
  		mutex_init(&epc->mutex);
- 		c4iw_init_wr_wait(&epc->wr_wait);
+ 		c4iw_init_wr_wait(epc->wr_waitp);
  	}
++<<<<<<< HEAD
 +	PDBG("%s alloc ep %p\n", __func__, epc);
++=======
+ 	pr_debug("alloc ep %p\n", epc);
+ out:
++>>>>>>> ef885dc66c29 (iw_cxgb4: allocate wait object for each ep object)
  	return epc;
  }
  
@@@ -2104,9 -2106,9 +2116,9 @@@ static int c4iw_reconnect(struct c4iw_e
  	int iptype;
  	__u8 *ra;
  
 -	pr_debug("qp %p cm_id %p\n", ep->com.qp, ep->com.cm_id);
 +	PDBG("%s qp %p cm_id %p\n", __func__, ep->com.qp, ep->com.cm_id);
  	init_timer(&ep->timer);
- 	c4iw_init_wr_wait(&ep->com.wr_wait);
+ 	c4iw_init_wr_wait(ep->com.wr_waitp);
  
  	/* When MPA revision is different on nodes, the node with MPA_rev=2
  	 * tries to reconnect with MPA_rev 1 for the same EP through
@@@ -2320,12 -2322,12 +2332,18 @@@ static int pass_open_rpl(struct c4iw_de
  	struct c4iw_listen_ep *ep = get_ep_from_stid(dev, stid);
  
  	if (!ep) {
 -		pr_warn("%s stid %d lookup failure!\n", __func__, stid);
 +		PDBG("%s stid %d lookup failure!\n", __func__, stid);
  		goto out;
  	}
++<<<<<<< HEAD
 +	PDBG("%s ep %p status %d error %d\n", __func__, ep,
 +	     rpl->status, status2errno(rpl->status));
 +	c4iw_wake_up(&ep->com.wr_wait, status2errno(rpl->status));
++=======
+ 	pr_debug("ep %p status %d error %d\n", ep,
+ 		 rpl->status, status2errno(rpl->status));
+ 	c4iw_wake_up(ep->com.wr_waitp, status2errno(rpl->status));
++>>>>>>> ef885dc66c29 (iw_cxgb4: allocate wait object for each ep object)
  	c4iw_put_ep(&ep->com);
  out:
  	return 0;
@@@ -2337,9 -2339,14 +2355,18 @@@ static int close_listsrv_rpl(struct c4i
  	unsigned int stid = GET_TID(rpl);
  	struct c4iw_listen_ep *ep = get_ep_from_stid(dev, stid);
  
++<<<<<<< HEAD
 +	PDBG("%s ep %p\n", __func__, ep);
 +	c4iw_wake_up(&ep->com.wr_wait, status2errno(rpl->status));
++=======
+ 	if (!ep) {
+ 		pr_warn("%s stid %d lookup failure!\n", __func__, stid);
+ 		goto out;
+ 	}
+ 	pr_debug("ep %p\n", ep);
+ 	c4iw_wake_up(ep->com.wr_waitp, status2errno(rpl->status));
++>>>>>>> ef885dc66c29 (iw_cxgb4: allocate wait object for each ep object)
  	c4iw_put_ep(&ep->com);
 -out:
  	return 0;
  }
  
@@@ -2673,13 -2678,13 +2700,23 @@@ static int peer_close(struct c4iw_dev *
  		 * in rdma connection migration (see c4iw_accept_cr()).
  		 */
  		__state_set(&ep->com, CLOSING);
++<<<<<<< HEAD
 +		PDBG("waking up ep %p tid %u\n", ep, ep->hwtid);
 +		c4iw_wake_up(&ep->com.wr_wait, -ECONNRESET);
 +		break;
 +	case MPA_REP_SENT:
 +		__state_set(&ep->com, CLOSING);
 +		PDBG("waking up ep %p tid %u\n", ep, ep->hwtid);
 +		c4iw_wake_up(&ep->com.wr_wait, -ECONNRESET);
++=======
+ 		pr_debug("waking up ep %p tid %u\n", ep, ep->hwtid);
+ 		c4iw_wake_up(ep->com.wr_waitp, -ECONNRESET);
+ 		break;
+ 	case MPA_REP_SENT:
+ 		__state_set(&ep->com, CLOSING);
+ 		pr_debug("waking up ep %p tid %u\n", ep, ep->hwtid);
+ 		c4iw_wake_up(ep->com.wr_waitp, -ECONNRESET);
++>>>>>>> ef885dc66c29 (iw_cxgb4: allocate wait object for each ep object)
  		break;
  	case FPDU_MODE:
  		start_ep_timer(ep);
@@@ -3358,8 -3361,10 +3395,8 @@@ static int create_server6(struct c4iw_d
  				   ep->com.dev->rdev.lldi.rxq_ids[0]);
  	if (!err)
  		err = c4iw_wait_for_reply(&ep->com.dev->rdev,
- 					  &ep->com.wr_wait,
+ 					  ep->com.wr_waitp,
  					  0, 0, __func__);
 -	else if (err > 0)
 -		err = net_xmit_errno(err);
  	if (err) {
  		cxgb4_clip_release(ep->com.dev->rdev.lldi.ports[0],
  				   (const u32 *)&sin6->sin6_addr.s6_addr, 1);
@@@ -3398,8 -3403,10 +3435,8 @@@ static int create_server4(struct c4iw_d
  				0, ep->com.dev->rdev.lldi.rxq_ids[0]);
  		if (!err)
  			err = c4iw_wait_for_reply(&ep->com.dev->rdev,
- 						  &ep->com.wr_wait,
+ 						  ep->com.wr_waitp,
  						  0, 0, __func__);
 -		else if (err > 0)
 -			err = net_xmit_errno(err);
  	}
  	if (err)
  		pr_err("cxgb4_create_server/filter failed err %d stid %d laddr %pI4 lport %d\n"
@@@ -4215,15 -4217,14 +4252,15 @@@ static int peer_abort_intr(struct c4iw_
  		return 0;
  	}
  	if (cxgb_is_neg_adv(req->status)) {
 -		pr_warn("%s Negative advice on abort- tid %u status %d (%s)\n",
 -			__func__, ep->hwtid, req->status,
 -			 neg_adv_str(req->status));
 +		PDBG("%s Negative advice on abort- tid %u status %d (%s)\n",
 +		     __func__, ep->hwtid, req->status,
 +		     neg_adv_str(req->status));
  		goto out;
  	}
 -	pr_debug("ep %p tid %u state %u\n", ep, ep->hwtid, ep->com.state);
 +	PDBG("%s ep %p tid %u state %u\n", __func__, ep, ep->hwtid,
 +	     ep->com.state);
  
- 	c4iw_wake_up(&ep->com.wr_wait, -ECONNRESET);
+ 	c4iw_wake_up(ep->com.wr_waitp, -ECONNRESET);
  out:
  	sched(dev, skb);
  	return 0;
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 9da4fb4991be..540709034d38 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -841,7 +841,7 @@ struct c4iw_ep_common {
 	struct mutex mutex;
 	struct sockaddr_storage local_addr;
 	struct sockaddr_storage remote_addr;
-	struct c4iw_wr_wait wr_wait;
+	struct c4iw_wr_wait *wr_waitp;
 	unsigned long flags;
 	unsigned long history;
 };
diff --git a/drivers/infiniband/hw/cxgb4/qp.c b/drivers/infiniband/hw/cxgb4/qp.c
index 6ffecd386576..a19949bfb223 100644
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@ -1357,14 +1357,14 @@ static int rdma_fini(struct c4iw_dev *rhp, struct c4iw_qp *qhp,
 	wqe->flowid_len16 = cpu_to_be32(
 		FW_WR_FLOWID_V(ep->hwtid) |
 		FW_WR_LEN16_V(DIV_ROUND_UP(sizeof(*wqe), 16)));
-	wqe->cookie = (uintptr_t)&ep->com.wr_wait;
+	wqe->cookie = (uintptr_t)ep->com.wr_waitp;
 
 	wqe->u.fini.type = FW_RI_TYPE_FINI;
 	ret = c4iw_ofld_send(&rhp->rdev, skb);
 	if (ret)
 		goto out;
 
-	ret = c4iw_wait_for_reply(&rhp->rdev, &ep->com.wr_wait, qhp->ep->hwtid,
+	ret = c4iw_wait_for_reply(&rhp->rdev, ep->com.wr_waitp, qhp->ep->hwtid,
 			     qhp->wq.sq.qid, __func__);
 out:
 	PDBG("%s ret %d\n", __func__, ret);
@@ -1427,7 +1427,7 @@ static int rdma_init(struct c4iw_dev *rhp, struct c4iw_qp *qhp)
 		FW_WR_FLOWID_V(qhp->ep->hwtid) |
 		FW_WR_LEN16_V(DIV_ROUND_UP(sizeof(*wqe), 16)));
 
-	wqe->cookie = (uintptr_t)&qhp->ep->com.wr_wait;
+	wqe->cookie = (uintptr_t)qhp->ep->com.wr_waitp;
 
 	wqe->u.init.type = FW_RI_TYPE_INIT;
 	wqe->u.init.mpareqbit_p2ptype =
@@ -1468,7 +1468,7 @@ static int rdma_init(struct c4iw_dev *rhp, struct c4iw_qp *qhp)
 	if (ret)
 		goto err1;
 
-	ret = c4iw_wait_for_reply(&rhp->rdev, &qhp->ep->com.wr_wait,
+	ret = c4iw_wait_for_reply(&rhp->rdev, qhp->ep->com.wr_waitp,
 				  qhp->ep->hwtid, qhp->wq.sq.qid, __func__);
 	if (!ret)
 		goto out;
