pipe: add proc_dopipe_max_size() to safely assign pipe_max_size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Joe Lawrence <joe.lawrence@redhat.com>
commit 7a8d181949fb2c16be00f8cdb354794a30e46b39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7a8d1819.failed

pipe_max_size is assigned directly via procfs sysctl:

  static struct ctl_table fs_table[] = {
          ...
          {
                  .procname       = "pipe-max-size",
                  .data           = &pipe_max_size,
                  .maxlen         = sizeof(int),
                  .mode           = 0644,
                  .proc_handler   = &pipe_proc_fn,
                  .extra1         = &pipe_min_size,
          },
          ...

  int pipe_proc_fn(struct ctl_table *table, int write, void __user *buf,
                   size_t *lenp, loff_t *ppos)
  {
          ...
          ret = proc_dointvec_minmax(table, write, buf, lenp, ppos)
          ...

and then later rounded in-place a few statements later:

          ...
          pipe_max_size = round_pipe_size(pipe_max_size);
          ...

This leaves a window of time between initial assignment and rounding
that may be visible to other threads.  (For example, one thread sets a
non-rounded value to pipe_max_size while another reads its value.)

Similar reads of pipe_max_size are potentially racy:

  pipe.c :: alloc_pipe_info()
  pipe.c :: pipe_set_size()

Add a new proc_dopipe_max_size() that consolidates reading the new value
from the user buffer, verifying bounds, and calling round_pipe_size()
with a single assignment to pipe_max_size.

Link: http://lkml.kernel.org/r/1507658689-11669-4-git-send-email-joe.lawrence@redhat.com
	Signed-off-by: Joe Lawrence <joe.lawrence@redhat.com>
	Reported-by: Mikulas Patocka <mpatocka@redhat.com>
	Reviewed-by: Mikulas Patocka <mpatocka@redhat.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7a8d181949fb2c16be00f8cdb354794a30e46b39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sysctl.c
diff --cc kernel/sysctl.c
index 03946f49a1c4,138b6484f277..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -62,9 -62,13 +62,15 @@@
  #include <linux/capability.h>
  #include <linux/binfmts.h>
  #include <linux/sched/sysctl.h>
 -#include <linux/sched/coredump.h>
  #include <linux/kexec.h>
++<<<<<<< HEAD
++=======
+ #include <linux/bpf.h>
+ #include <linux/mount.h>
+ #include <linux/pipe_fs_i.h>
++>>>>>>> 7a8d181949fb (pipe: add proc_dopipe_max_size() to safely assign pipe_max_size)
  
 -#include <linux/uaccess.h>
 +#include <asm/uaccess.h>
  #include <asm/processor.h>
  
  #ifdef CONFIG_X86
diff --git a/fs/pipe.c b/fs/pipe.c
index f173e48cf9cb..02206e802f16 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -1209,7 +1209,7 @@ const struct file_operations pipefifo_fops = {
  * Currently we rely on the pipe array holding a power-of-2 number
  * of pages. Returns 0 on error.
  */
-static inline unsigned int round_pipe_size(unsigned int size)
+unsigned int round_pipe_size(unsigned int size)
 {
 	unsigned long nr_pages;
 
@@ -1291,25 +1291,13 @@ static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)
 }
 
 /*
- * This should work even if CONFIG_PROC_FS isn't set, as proc_dointvec_minmax
+ * This should work even if CONFIG_PROC_FS isn't set, as proc_dopipe_max_size
  * will return an error.
  */
 int pipe_proc_fn(struct ctl_table *table, int write, void __user *buf,
 		 size_t *lenp, loff_t *ppos)
 {
-	unsigned int rounded_pipe_max_size;
-	int ret;
-
-	ret = proc_douintvec_minmax(table, write, buf, lenp, ppos);
-	if (ret < 0 || !write)
-		return ret;
-
-	rounded_pipe_max_size = round_pipe_size(pipe_max_size);
-	if (rounded_pipe_max_size == 0)
-		return -EINVAL;
-
-	pipe_max_size = rounded_pipe_max_size;
-	return ret;
+	return proc_dopipe_max_size(table, write, buf, lenp, ppos);
 }
 
 /*
diff --git a/include/linux/pipe_fs_i.h b/include/linux/pipe_fs_i.h
index 4820101b66d1..56fc59508cbd 100644
--- a/include/linux/pipe_fs_i.h
+++ b/include/linux/pipe_fs_i.h
@@ -166,5 +166,6 @@ long pipe_fcntl(struct file *, unsigned int, unsigned long arg);
 struct pipe_inode_info *get_pipe_info(struct file *file);
 
 int create_pipe_files(struct file **, int);
+unsigned int round_pipe_size(unsigned int size);
 
 #endif
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index 48b2a182aabc..b47950897f44 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -50,6 +50,9 @@ extern int proc_dointvec_minmax(struct ctl_table *, int,
 extern int proc_douintvec_minmax(struct ctl_table *table, int write,
 				 void __user *buffer, size_t *lenp,
 				 loff_t *ppos);
+extern int proc_dopipe_max_size(struct ctl_table *table, int write,
+				void __user *buffer, size_t *lenp,
+				loff_t *ppos);
 extern int proc_dointvec_jiffies(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
 extern int proc_dointvec_userhz_jiffies(struct ctl_table *, int,
* Unmerged path kernel/sysctl.c
