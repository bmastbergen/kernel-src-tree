scsi: cxlflash: Wait for active AFU commands to timeout upon tear down

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Wait for active AFU commands to timeout upon tear down (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 95.52%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit de01283baa334b1d938cfd9121198c517ad6dc89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/de01283b.failed

With the removal of the static private command pool, the ability to
'complete' outstanding commands was lost. While not an issue for the
commands originating outside the driver, internal AFU commands are
synchronous and therefore have a timeout associated with them. To
avoid a stale memory access, the tear down sequence needs to ensure
that there are not any active commands before proceeding. As these
internal AFU commands are rare events, the simplest way to accomplish
this is detecting the activity and waiting for it to timeout.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Acked-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit de01283baa334b1d938cfd9121198c517ad6dc89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/main.c
index d8aaf45b8306,839eca4c4e02..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -587,32 -531,16 +587,37 @@@ static void free_mem(struct cxlflash_cf
   *
   * Safe to call with AFU in a partially allocated/initialized state.
   *
-  * Cleans up all state associated with the command queue, and unmaps
+  * Waits for any active internal AFU commands to timeout and then unmaps
   * the MMIO space.
 + *
 + *  - complete() will take care of commands we initiated (they'll be checked
 + *  in as part of the cleanup that occurs after the completion)
 + *
 + *  - cmd_checkin() will take care of entries that we did not initiate and that
 + *  have not (and will not) complete because they are sitting on a [now stale]
 + *  hardware queue
   */
  static void stop_afu(struct cxlflash_cfg *cfg)
  {
 +	int i;
  	struct afu *afu = cfg->afu;
 +	struct afu_cmd *cmd;
 +
 +	cancel_work_sync(&cfg->work_q);
  
  	if (likely(afu)) {
++<<<<<<< HEAD
 +		for (i = 0; i < CXLFLASH_NUM_CMDS; i++) {
 +			cmd = &afu->cmd[i];
 +			complete(&cmd->cevent);
 +			if (!atomic_read(&cmd->free))
 +				cmd_checkin(cmd);
 +		}
 +
++=======
+ 		while (atomic_read(&afu->cmds_active))
+ 			ssleep(1);
++>>>>>>> de01283baa33 (scsi: cxlflash: Wait for active AFU commands to timeout upon tear down)
  		if (likely(afu->afu_map)) {
  			cxl_psa_unmap((void __iomem *)afu->afu_map);
  			afu->afu_map = NULL;
diff --git a/drivers/scsi/cxlflash/common.h b/drivers/scsi/cxlflash/common.h
index 811927d91c5c..9897740dd923 100644
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@ -170,6 +170,7 @@ struct afu {
 	u64 *hrrq_end;
 	u64 *hrrq_curr;
 	bool toggle;
+	atomic_t cmds_active;	/* Number of currently active AFU commands */
 	s64 room;
 	spinlock_t rrin_slock; /* Lock to rrin queuing and cmd_room updates */
 	u64 hb;
* Unmerged path drivers/scsi/cxlflash/main.c
