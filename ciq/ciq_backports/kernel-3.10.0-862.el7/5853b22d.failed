i2c: core: Add function for finding the bus speed from ACPI, take 2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [i2c] core: Add function for finding the bus speed from ACPI, take 2 (Gopal Tiwari) [1456705]
Rebuild_FUZZ: 96.12%
commit-author Jarkko Nikula <jarkko.nikula@linux.intel.com>
commit 5853b22d96fa786365ff11fe9f008a68a533f043
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5853b22d.failed

ACPI 5 specification doesn't have property for the I2C bus speed but
I2cSerialBus resource descriptor which define each controller-slave
connection define the maximum speed supported by that connection.

Thus finding the maximum safe speed for the bus is to walk through all
I2cSerialBus resources that are associated to I2C controller and use the
speed of slowest connection.

Add function i2c_acpi_find_bus_speed() to the i2c-core that adapter
drivers can call prior registering itself to core.

This implies two-step walk through the I2cSerialBus resources: call to
i2c_acpi_find_bus_speed() does the first scan and finds the safe bus
speed that adapter drivers can set up. Adapter driver registration does
the second scan when i2c-core creates the I2C slaves by calling the
i2c_acpi_register_devices(). In that way the bus speed is set in case
slave device probe gets called during registration and does communication.

Previous version commit 55d38d060e99 ("i2c: core: Add function for finding
the bus speed from ACPI") got reverted due merge conflicts from
commit 525e6fabeae2 ("i2c / ACPI: add support for ACPI reconfigure
notifications").

This version is a bit bigger than previous version but is still sharing
the lowest and complicated part of I2cSerialBus lookup routines with the
existing code.

	Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit 5853b22d96fa786365ff11fe9f008a68a533f043)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/i2c-core.c
#	include/linux/i2c.h
diff --cc drivers/i2c/i2c-core.c
index f8cf59d9b563,05794423e01f..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -60,6 -74,593 +60,596 @@@ static DEFINE_IDR(i2c_adapter_idr)
  static struct device_type i2c_client_type;
  static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);
  
++<<<<<<< HEAD
++=======
+ static struct static_key i2c_trace_msg = STATIC_KEY_INIT_FALSE;
+ static bool is_registered;
+ 
+ void i2c_transfer_trace_reg(void)
+ {
+ 	static_key_slow_inc(&i2c_trace_msg);
+ }
+ 
+ void i2c_transfer_trace_unreg(void)
+ {
+ 	static_key_slow_dec(&i2c_trace_msg);
+ }
+ 
+ #if defined(CONFIG_ACPI)
+ struct i2c_acpi_handler_data {
+ 	struct acpi_connection_info info;
+ 	struct i2c_adapter *adapter;
+ };
+ 
+ struct gsb_buffer {
+ 	u8	status;
+ 	u8	len;
+ 	union {
+ 		u16	wdata;
+ 		u8	bdata;
+ 		u8	data[0];
+ 	};
+ } __packed;
+ 
+ struct i2c_acpi_lookup {
+ 	struct i2c_board_info *info;
+ 	acpi_handle adapter_handle;
+ 	acpi_handle device_handle;
+ 	acpi_handle search_handle;
+ 	u32 speed;
+ 	u32 min_speed;
+ };
+ 
+ static int i2c_acpi_fill_info(struct acpi_resource *ares, void *data)
+ {
+ 	struct i2c_acpi_lookup *lookup = data;
+ 	struct i2c_board_info *info = lookup->info;
+ 	struct acpi_resource_i2c_serialbus *sb;
+ 	acpi_status status;
+ 
+ 	if (info->addr || ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)
+ 		return 1;
+ 
+ 	sb = &ares->data.i2c_serial_bus;
+ 	if (sb->type != ACPI_RESOURCE_SERIAL_TYPE_I2C)
+ 		return 1;
+ 
+ 	status = acpi_get_handle(lookup->device_handle,
+ 				 sb->resource_source.string_ptr,
+ 				 &lookup->adapter_handle);
+ 	if (!ACPI_SUCCESS(status))
+ 		return 1;
+ 
+ 	info->addr = sb->slave_address;
+ 	lookup->speed = sb->connection_speed;
+ 	if (sb->access_mode == ACPI_I2C_10BIT_MODE)
+ 		info->flags |= I2C_CLIENT_TEN;
+ 
+ 	return 1;
+ }
+ 
+ static int i2c_acpi_do_lookup(struct acpi_device *adev,
+ 			      struct i2c_acpi_lookup *lookup)
+ {
+ 	struct i2c_board_info *info = lookup->info;
+ 	struct list_head resource_list;
+ 	int ret;
+ 
+ 	if (acpi_bus_get_status(adev) || !adev->status.present ||
+ 	    acpi_device_enumerated(adev))
+ 		return -EINVAL;
+ 
+ 	memset(info, 0, sizeof(*info));
+ 	lookup->device_handle = acpi_device_handle(adev);
+ 
+ 	/* Look up for I2cSerialBus resource */
+ 	INIT_LIST_HEAD(&resource_list);
+ 	ret = acpi_dev_get_resources(adev, &resource_list,
+ 				     i2c_acpi_fill_info, lookup);
+ 	acpi_dev_free_resource_list(&resource_list);
+ 
+ 	if (ret < 0 || !info->addr)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int i2c_acpi_get_info(struct acpi_device *adev,
+ 			     struct i2c_board_info *info,
+ 			     acpi_handle *adapter_handle)
+ {
+ 	struct list_head resource_list;
+ 	struct resource_entry *entry;
+ 	struct i2c_acpi_lookup lookup;
+ 	int ret;
+ 
+ 	memset(&lookup, 0, sizeof(lookup));
+ 	lookup.info = info;
+ 
+ 	ret = i2c_acpi_do_lookup(adev, &lookup);
+ 	if (ret)
+ 		return ret;
+ 
+ 	info->fwnode = acpi_fwnode_handle(adev);
+ 	*adapter_handle = lookup.adapter_handle;
+ 
+ 	/* Then fill IRQ number if any */
+ 	INIT_LIST_HEAD(&resource_list);
+ 	ret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);
+ 	if (ret < 0)
+ 		return -EINVAL;
+ 
+ 	resource_list_for_each_entry(entry, &resource_list) {
+ 		if (resource_type(entry->res) == IORESOURCE_IRQ) {
+ 			info->irq = entry->res->start;
+ 			break;
+ 		}
+ 	}
+ 
+ 	acpi_dev_free_resource_list(&resource_list);
+ 
+ 	strlcpy(info->type, dev_name(&adev->dev), sizeof(info->type));
+ 
+ 	return 0;
+ }
+ 
+ static void i2c_acpi_register_device(struct i2c_adapter *adapter,
+ 				     struct acpi_device *adev,
+ 				     struct i2c_board_info *info)
+ {
+ 	adev->power.flags.ignore_parent = true;
+ 	acpi_device_set_enumerated(adev);
+ 
+ 	if (!i2c_new_device(adapter, info)) {
+ 		adev->power.flags.ignore_parent = false;
+ 		dev_err(&adapter->dev,
+ 			"failed to add I2C device %s from ACPI\n",
+ 			dev_name(&adev->dev));
+ 	}
+ }
+ 
+ static acpi_status i2c_acpi_add_device(acpi_handle handle, u32 level,
+ 				       void *data, void **return_value)
+ {
+ 	struct i2c_adapter *adapter = data;
+ 	struct acpi_device *adev;
+ 	acpi_handle adapter_handle;
+ 	struct i2c_board_info info;
+ 
+ 	if (acpi_bus_get_device(handle, &adev))
+ 		return AE_OK;
+ 
+ 	if (i2c_acpi_get_info(adev, &info, &adapter_handle))
+ 		return AE_OK;
+ 
+ 	if (adapter_handle != ACPI_HANDLE(&adapter->dev))
+ 		return AE_OK;
+ 
+ 	i2c_acpi_register_device(adapter, adev, &info);
+ 
+ 	return AE_OK;
+ }
+ 
+ #define I2C_ACPI_MAX_SCAN_DEPTH 32
+ 
+ /**
+  * i2c_acpi_register_devices - enumerate I2C slave devices behind adapter
+  * @adap: pointer to adapter
+  *
+  * Enumerate all I2C slave devices behind this adapter by walking the ACPI
+  * namespace. When a device is found it will be added to the Linux device
+  * model and bound to the corresponding ACPI handle.
+  */
+ static void i2c_acpi_register_devices(struct i2c_adapter *adap)
+ {
+ 	acpi_status status;
+ 
+ 	if (!has_acpi_companion(&adap->dev))
+ 		return;
+ 
+ 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+ 				     I2C_ACPI_MAX_SCAN_DEPTH,
+ 				     i2c_acpi_add_device, NULL,
+ 				     adap, NULL);
+ 	if (ACPI_FAILURE(status))
+ 		dev_warn(&adap->dev, "failed to enumerate I2C slaves\n");
+ }
+ 
+ static acpi_status i2c_acpi_lookup_speed(acpi_handle handle, u32 level,
+ 					   void *data, void **return_value)
+ {
+ 	struct i2c_acpi_lookup *lookup = data;
+ 	struct acpi_device *adev;
+ 
+ 	if (acpi_bus_get_device(handle, &adev))
+ 		return AE_OK;
+ 
+ 	if (i2c_acpi_do_lookup(adev, lookup))
+ 		return AE_OK;
+ 
+ 	if (lookup->search_handle != lookup->adapter_handle)
+ 		return AE_OK;
+ 
+ 	if (lookup->speed <= lookup->min_speed)
+ 		lookup->min_speed = lookup->speed;
+ 
+ 	return AE_OK;
+ }
+ 
+ /**
+  * i2c_acpi_find_bus_speed - find I2C bus speed from ACPI
+  * @dev: The device owning the bus
+  *
+  * Find the I2C bus speed by walking the ACPI namespace for all I2C slaves
+  * devices connected to this bus and use the speed of slowest device.
+  *
+  * Returns the speed in Hz or zero
+  */
+ u32 i2c_acpi_find_bus_speed(struct device *dev)
+ {
+ 	struct i2c_acpi_lookup lookup;
+ 	struct i2c_board_info dummy;
+ 	acpi_status status;
+ 
+ 	if (!has_acpi_companion(dev))
+ 		return 0;
+ 
+ 	memset(&lookup, 0, sizeof(lookup));
+ 	lookup.search_handle = ACPI_HANDLE(dev);
+ 	lookup.min_speed = UINT_MAX;
+ 	lookup.info = &dummy;
+ 
+ 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+ 				     I2C_ACPI_MAX_SCAN_DEPTH,
+ 				     i2c_acpi_lookup_speed, NULL,
+ 				     &lookup, NULL);
+ 
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_warn(dev, "unable to find I2C bus speed from ACPI\n");
+ 		return 0;
+ 	}
+ 
+ 	return lookup.min_speed != UINT_MAX ? lookup.min_speed : 0;
+ }
+ EXPORT_SYMBOL_GPL(i2c_acpi_find_bus_speed);
+ 
+ static int i2c_acpi_match_adapter(struct device *dev, void *data)
+ {
+ 	struct i2c_adapter *adapter = i2c_verify_adapter(dev);
+ 
+ 	if (!adapter)
+ 		return 0;
+ 
+ 	return ACPI_HANDLE(dev) == (acpi_handle)data;
+ }
+ 
+ static int i2c_acpi_match_device(struct device *dev, void *data)
+ {
+ 	return ACPI_COMPANION(dev) == data;
+ }
+ 
+ static struct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle)
+ {
+ 	struct device *dev;
+ 
+ 	dev = bus_find_device(&i2c_bus_type, NULL, handle,
+ 			      i2c_acpi_match_adapter);
+ 	return dev ? i2c_verify_adapter(dev) : NULL;
+ }
+ 
+ static struct i2c_client *i2c_acpi_find_client_by_adev(struct acpi_device *adev)
+ {
+ 	struct device *dev;
+ 
+ 	dev = bus_find_device(&i2c_bus_type, NULL, adev, i2c_acpi_match_device);
+ 	return dev ? i2c_verify_client(dev) : NULL;
+ }
+ 
+ static int i2c_acpi_notify(struct notifier_block *nb, unsigned long value,
+ 			   void *arg)
+ {
+ 	struct acpi_device *adev = arg;
+ 	struct i2c_board_info info;
+ 	acpi_handle adapter_handle;
+ 	struct i2c_adapter *adapter;
+ 	struct i2c_client *client;
+ 
+ 	switch (value) {
+ 	case ACPI_RECONFIG_DEVICE_ADD:
+ 		if (i2c_acpi_get_info(adev, &info, &adapter_handle))
+ 			break;
+ 
+ 		adapter = i2c_acpi_find_adapter_by_handle(adapter_handle);
+ 		if (!adapter)
+ 			break;
+ 
+ 		i2c_acpi_register_device(adapter, adev, &info);
+ 		break;
+ 	case ACPI_RECONFIG_DEVICE_REMOVE:
+ 		if (!acpi_device_enumerated(adev))
+ 			break;
+ 
+ 		client = i2c_acpi_find_client_by_adev(adev);
+ 		if (!client)
+ 			break;
+ 
+ 		i2c_unregister_device(client);
+ 		put_device(&client->dev);
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block i2c_acpi_notifier = {
+ 	.notifier_call = i2c_acpi_notify,
+ };
+ #else /* CONFIG_ACPI */
+ static inline void i2c_acpi_register_devices(struct i2c_adapter *adap) { }
+ extern struct notifier_block i2c_acpi_notifier;
+ #endif /* CONFIG_ACPI */
+ 
+ #ifdef CONFIG_ACPI_I2C_OPREGION
+ static int acpi_gsb_i2c_read_bytes(struct i2c_client *client,
+ 		u8 cmd, u8 *data, u8 data_len)
+ {
+ 
+ 	struct i2c_msg msgs[2];
+ 	int ret;
+ 	u8 *buffer;
+ 
+ 	buffer = kzalloc(data_len, GFP_KERNEL);
+ 	if (!buffer)
+ 		return AE_NO_MEMORY;
+ 
+ 	msgs[0].addr = client->addr;
+ 	msgs[0].flags = client->flags;
+ 	msgs[0].len = 1;
+ 	msgs[0].buf = &cmd;
+ 
+ 	msgs[1].addr = client->addr;
+ 	msgs[1].flags = client->flags | I2C_M_RD;
+ 	msgs[1].len = data_len;
+ 	msgs[1].buf = buffer;
+ 
+ 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+ 	if (ret < 0)
+ 		dev_err(&client->adapter->dev, "i2c read failed\n");
+ 	else
+ 		memcpy(data, buffer, data_len);
+ 
+ 	kfree(buffer);
+ 	return ret;
+ }
+ 
+ static int acpi_gsb_i2c_write_bytes(struct i2c_client *client,
+ 		u8 cmd, u8 *data, u8 data_len)
+ {
+ 
+ 	struct i2c_msg msgs[1];
+ 	u8 *buffer;
+ 	int ret = AE_OK;
+ 
+ 	buffer = kzalloc(data_len + 1, GFP_KERNEL);
+ 	if (!buffer)
+ 		return AE_NO_MEMORY;
+ 
+ 	buffer[0] = cmd;
+ 	memcpy(buffer + 1, data, data_len);
+ 
+ 	msgs[0].addr = client->addr;
+ 	msgs[0].flags = client->flags;
+ 	msgs[0].len = data_len + 1;
+ 	msgs[0].buf = buffer;
+ 
+ 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+ 	if (ret < 0)
+ 		dev_err(&client->adapter->dev, "i2c write failed\n");
+ 
+ 	kfree(buffer);
+ 	return ret;
+ }
+ 
+ static acpi_status
+ i2c_acpi_space_handler(u32 function, acpi_physical_address command,
+ 			u32 bits, u64 *value64,
+ 			void *handler_context, void *region_context)
+ {
+ 	struct gsb_buffer *gsb = (struct gsb_buffer *)value64;
+ 	struct i2c_acpi_handler_data *data = handler_context;
+ 	struct acpi_connection_info *info = &data->info;
+ 	struct acpi_resource_i2c_serialbus *sb;
+ 	struct i2c_adapter *adapter = data->adapter;
+ 	struct i2c_client *client;
+ 	struct acpi_resource *ares;
+ 	u32 accessor_type = function >> 16;
+ 	u8 action = function & ACPI_IO_MASK;
+ 	acpi_status ret;
+ 	int status;
+ 
+ 	ret = acpi_buffer_to_resource(info->connection, info->length, &ares);
+ 	if (ACPI_FAILURE(ret))
+ 		return ret;
+ 
+ 	client = kzalloc(sizeof(*client), GFP_KERNEL);
+ 	if (!client) {
+ 		ret = AE_NO_MEMORY;
+ 		goto err;
+ 	}
+ 
+ 	if (!value64 || ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+ 		ret = AE_BAD_PARAMETER;
+ 		goto err;
+ 	}
+ 
+ 	sb = &ares->data.i2c_serial_bus;
+ 	if (sb->type != ACPI_RESOURCE_SERIAL_TYPE_I2C) {
+ 		ret = AE_BAD_PARAMETER;
+ 		goto err;
+ 	}
+ 
+ 	client->adapter = adapter;
+ 	client->addr = sb->slave_address;
+ 
+ 	if (sb->access_mode == ACPI_I2C_10BIT_MODE)
+ 		client->flags |= I2C_CLIENT_TEN;
+ 
+ 	switch (accessor_type) {
+ 	case ACPI_GSB_ACCESS_ATTRIB_SEND_RCV:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_byte(client);
+ 			if (status >= 0) {
+ 				gsb->bdata = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_byte(client, gsb->bdata);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_BYTE:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_byte_data(client, command);
+ 			if (status >= 0) {
+ 				gsb->bdata = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_byte_data(client, command,
+ 					gsb->bdata);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_WORD:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_word_data(client, command);
+ 			if (status >= 0) {
+ 				gsb->wdata = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_word_data(client, command,
+ 					gsb->wdata);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_BLOCK:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_block_data(client, command,
+ 					gsb->data);
+ 			if (status >= 0) {
+ 				gsb->len = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_block_data(client, command,
+ 					gsb->len, gsb->data);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE:
+ 		if (action == ACPI_READ) {
+ 			status = acpi_gsb_i2c_read_bytes(client, command,
+ 					gsb->data, info->access_length);
+ 			if (status > 0)
+ 				status = 0;
+ 		} else {
+ 			status = acpi_gsb_i2c_write_bytes(client, command,
+ 					gsb->data, info->access_length);
+ 		}
+ 		break;
+ 
+ 	default:
+ 		dev_warn(&adapter->dev, "protocol 0x%02x not supported for client 0x%02x\n",
+ 			 accessor_type, client->addr);
+ 		ret = AE_BAD_PARAMETER;
+ 		goto err;
+ 	}
+ 
+ 	gsb->status = status;
+ 
+  err:
+ 	kfree(client);
+ 	ACPI_FREE(ares);
+ 	return ret;
+ }
+ 
+ 
+ static int i2c_acpi_install_space_handler(struct i2c_adapter *adapter)
+ {
+ 	acpi_handle handle;
+ 	struct i2c_acpi_handler_data *data;
+ 	acpi_status status;
+ 
+ 	if (!adapter->dev.parent)
+ 		return -ENODEV;
+ 
+ 	handle = ACPI_HANDLE(adapter->dev.parent);
+ 
+ 	if (!handle)
+ 		return -ENODEV;
+ 
+ 	data = kzalloc(sizeof(struct i2c_acpi_handler_data),
+ 			    GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->adapter = adapter;
+ 	status = acpi_bus_attach_private_data(handle, (void *)data);
+ 	if (ACPI_FAILURE(status)) {
+ 		kfree(data);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	status = acpi_install_address_space_handler(handle,
+ 				ACPI_ADR_SPACE_GSBUS,
+ 				&i2c_acpi_space_handler,
+ 				NULL,
+ 				data);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&adapter->dev, "Error installing i2c space handler\n");
+ 		acpi_bus_detach_private_data(handle);
+ 		kfree(data);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	acpi_walk_dep_device_list(handle);
+ 	return 0;
+ }
+ 
+ static void i2c_acpi_remove_space_handler(struct i2c_adapter *adapter)
+ {
+ 	acpi_handle handle;
+ 	struct i2c_acpi_handler_data *data;
+ 	acpi_status status;
+ 
+ 	if (!adapter->dev.parent)
+ 		return;
+ 
+ 	handle = ACPI_HANDLE(adapter->dev.parent);
+ 
+ 	if (!handle)
+ 		return;
+ 
+ 	acpi_remove_address_space_handler(handle,
+ 				ACPI_ADR_SPACE_GSBUS,
+ 				&i2c_acpi_space_handler);
+ 
+ 	status = acpi_bus_get_private_data(handle, (void **)&data);
+ 	if (ACPI_SUCCESS(status))
+ 		kfree(data);
+ 
+ 	acpi_bus_detach_private_data(handle);
+ }
+ #else /* CONFIG_ACPI_I2C_OPREGION */
+ static inline void i2c_acpi_remove_space_handler(struct i2c_adapter *adapter)
+ { }
+ 
+ static inline int i2c_acpi_install_space_handler(struct i2c_adapter *adapter)
+ { return 0; }
+ #endif /* CONFIG_ACPI_I2C_OPREGION */
+ 
++>>>>>>> 5853b22d96fa (i2c: core: Add function for finding the bus speed from ACPI, take 2)
  /* ------------------------------------------------------------------------- */
  
  static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
diff --cc include/linux/i2c.h
index 4227ca6aa715,5b4a3cbe5d7d..000000000000
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@@ -658,16 -780,13 +658,27 @@@ static inline struct i2c_adapter *of_ge
  }
  #endif /* CONFIG_OF */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_I2C_ACPI
 +int acpi_i2c_install_space_handler(struct i2c_adapter *adapter);
 +void acpi_i2c_remove_space_handler(struct i2c_adapter *adapter);
 +void acpi_i2c_register_devices(struct i2c_adapter *adap);
 +#else
 +static inline void acpi_i2c_register_devices(struct i2c_adapter *adap) { }
 +static inline void acpi_i2c_remove_space_handler(struct i2c_adapter *adapter)
 +{ }
 +static inline int acpi_i2c_install_space_handler(struct i2c_adapter *adapter)
 +{ return 0; }
 +#endif
++=======
+ #if IS_ENABLED(CONFIG_ACPI)
+ u32 i2c_acpi_find_bus_speed(struct device *dev);
+ #else
+ static inline u32 i2c_acpi_find_bus_speed(struct device *dev)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_ACPI */
++>>>>>>> 5853b22d96fa (i2c: core: Add function for finding the bus speed from ACPI, take 2)
  
  #endif /* _LINUX_I2C_H */
* Unmerged path drivers/i2c/i2c-core.c
* Unmerged path include/linux/i2c.h
