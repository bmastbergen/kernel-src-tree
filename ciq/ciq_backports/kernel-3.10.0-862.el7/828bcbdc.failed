IB/hfi1: Unsuccessful PCIe caps tuning should not fail driver load

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Harish Chegondi <harish.chegondi@intel.com>
commit 828bcbdc975fbcfb27946c33d4b1d1bfab70789b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/828bcbdc.failed

Failure to tune PCIe capabilities should not fail driver load. This can
cause the driver load to fail on systems with any of the following:
1. HFI's parent is not root. Example: HFI card is behind a PCIe bridge.
2. HFI's parent is not PCI Express capable.
In these situations, failure to tune PCIe capabilities should be logged
in the system message logs but not cause the driver load to fail.

This patch also ensures pcie capability word DevCtl is written only
after a successful read and the capability tuning process continues
even if read/write of the pcie capability word DevCtl fails.

Fixes: c53df62c7a9a ("IB/hfi1: Check return values from PCI config API calls")
Fixes: bf70a7757736 ("staging/rdma/hfi1: Enable WFR PCIe extended tags from the driver")
	Reviewed-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Reviewed-by: Jakub Byczkowski <jakub.byczkowski@intel.com>
	Signed-off-by: Harish Chegondi <harish.chegondi@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 828bcbdc975fbcfb27946c33d4b1d1bfab70789b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/pcie.c
diff --cc drivers/infiniband/hw/hfi1/pcie.c
index 6a9f6f9819e1,09e50fd2a08f..000000000000
--- a/drivers/infiniband/hw/hfi1/pcie.c
+++ b/drivers/infiniband/hw/hfi1/pcie.c
@@@ -364,49 -344,145 +364,56 @@@ int pcie_speeds(struct hfi1_devdata *dd
  }
  
  /*
 - * Returns:
 - *	- actual number of interrupts allocated or
 + * Returns in *nent:
 + *	- actual number of interrupts allocated
   *	- 0 if fell back to INTx.
 - *      - error
   */
 -int request_msix(struct hfi1_devdata *dd, u32 msireq)
 +void request_msix(struct hfi1_devdata *dd, u32 *nent,
 +		  struct hfi1_msix_entry *entry)
  {
++<<<<<<< HEAD
 +	int pos;
++=======
+ 	int nvec;
++>>>>>>> 828bcbdc975f (IB/hfi1: Unsuccessful PCIe caps tuning should not fail driver load)
  
 -	nvec = pci_alloc_irq_vectors(dd->pcidev, 1, msireq,
 -				     PCI_IRQ_MSIX | PCI_IRQ_LEGACY);
 -	if (nvec < 0) {
 -		dd_dev_err(dd, "pci_alloc_irq_vectors() failed: %d\n", nvec);
 -		return nvec;
 +	pos = dd->pcidev->msix_cap;
 +	if (*nent && pos) {
 +		msix_setup(dd, pos, nent, entry);
 +		/* did it, either MSI-X or INTx */
 +	} else {
 +		*nent = 0;
 +		hfi1_enable_intx(dd->pcidev);
  	}
  
  	tune_pcie_caps(dd);
 -
 -	/* check for legacy IRQ */
 -	if (nvec == 1 && !dd->pcidev->msix_enabled)
 -		return 0;
 -
 -	return nvec;
++<<<<<<< HEAD
  }
++=======
++>>>>>>> 828bcbdc975f (IB/hfi1: Unsuccessful PCIe caps tuning should not fail driver load)
  
 -/* restore command and BARs after a reset has wiped them out */
 -int restore_pci_variables(struct hfi1_devdata *dd)
 +void hfi1_enable_intx(struct pci_dev *pdev)
  {
 -	int ret = 0;
 -
 -	ret = pci_write_config_word(dd->pcidev, PCI_COMMAND, dd->pci_command);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,
 -				     dd->pcibar0);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,
 -				     dd->pcibar1);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_ROM_ADDRESS, dd->pci_rom);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL,
 -					 dd->pcie_devctl);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_write_word(dd->pcidev, PCI_EXP_LNKCTL,
 -					 dd->pcie_lnkctl);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL2,
 -					 dd->pcie_devctl2);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_CFG_MSIX0, dd->pci_msix0);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_SPCIE1,
 -				     dd->pci_lnkctl3);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2, dd->pci_tph2);
 -	if (ret)
 -		goto error;
 -
 -	return 0;
 -
 -error:
 -	dd_dev_err(dd, "Unable to write to PCI config\n");
 -	return ret;
 +	/* first, turn on INTx */
 +	pci_intx(pdev, 1);
 +	/* then turn off MSI-X */
 +	pci_disable_msix(pdev);
  }
  
 -/* Save BARs and command to rewrite after device reset */
 -int save_pci_variables(struct hfi1_devdata *dd)
 +/* restore command and BARs after a reset has wiped them out */
 +void restore_pci_variables(struct hfi1_devdata *dd)
  {
 -	int ret = 0;
 -
 -	ret = pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,
 -				    &dd->pcibar0);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,
 -				    &dd->pcibar1);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_read_config_dword(dd->pcidev, PCI_ROM_ADDRESS, &dd->pci_rom);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_read_config_word(dd->pcidev, PCI_COMMAND, &dd->pci_command);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL,
 -					&dd->pcie_devctl);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_LNKCTL,
 -					&dd->pcie_lnkctl);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL2,
 -					&dd->pcie_devctl2);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_read_config_dword(dd->pcidev, PCI_CFG_MSIX0, &dd->pci_msix0);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_SPCIE1,
 -				    &dd->pci_lnkctl3);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_TPH2, &dd->pci_tph2);
 -	if (ret)
 -		goto error;
 -
 -	return 0;
 -
 -error:
 -	dd_dev_err(dd, "Unable to read from PCI config\n");
 -	return ret;
 +	pci_write_config_word(dd->pcidev, PCI_COMMAND, dd->pci_command);
 +	pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0, dd->pcibar0);
 +	pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1, dd->pcibar1);
 +	pci_write_config_dword(dd->pcidev, PCI_ROM_ADDRESS, dd->pci_rom);
 +	pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL, dd->pcie_devctl);
 +	pcie_capability_write_word(dd->pcidev, PCI_EXP_LNKCTL, dd->pcie_lnkctl);
 +	pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL2,
 +				   dd->pcie_devctl2);
 +	pci_write_config_dword(dd->pcidev, PCI_CFG_MSIX0, dd->pci_msix0);
 +	pci_write_config_dword(dd->pcidev, PCIE_CFG_SPCIE1, dd->pci_lnkctl3);
 +	pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2, dd->pci_tph2);
  }
  
  /*
@@@ -431,11 -508,14 +438,22 @@@ static void tune_pcie_caps(struct hfi1_
  	 * Turn on extended tags in DevCtl in case the BIOS has turned it off
  	 * to improve WFR SDMA bandwidth
  	 */
++<<<<<<< HEAD
 +	pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL, &ectl);
 +	if (!(ectl & PCI_EXP_DEVCTL_EXT_TAG)) {
 +		dd_dev_info(dd, "Enabling PCIe extended tags\n");
 +		ectl |= PCI_EXP_DEVCTL_EXT_TAG;
 +		pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL, ectl);
++=======
+ 	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL, &ectl);
+ 	if ((!ret) && !(ectl & PCI_EXP_DEVCTL_EXT_TAG)) {
+ 		dd_dev_info(dd, "Enabling PCIe extended tags\n");
+ 		ectl |= PCI_EXP_DEVCTL_EXT_TAG;
+ 		ret = pcie_capability_write_word(dd->pcidev,
+ 						 PCI_EXP_DEVCTL, ectl);
+ 		if (ret)
+ 			dd_dev_info(dd, "Unable to write to PCI config\n");
++>>>>>>> 828bcbdc975f (IB/hfi1: Unsuccessful PCIe caps tuning should not fail driver load)
  	}
  	/* Find out supported and configured values for parent (root) */
  	parent = dd->pcidev->bus->self;
@@@ -443,15 -523,22 +461,34 @@@
  	 * The driver cannot perform the tuning if it does not have
  	 * access to the upstream component.
  	 */
++<<<<<<< HEAD
 +	if (!parent)
 +		return;
 +	if (!pci_is_root_bus(parent->bus)) {
 +		dd_dev_info(dd, "Parent not root\n");
 +		return;
 +	}
 +
 +	if (!pci_is_pcie(parent) || !pci_is_pcie(dd->pcidev))
 +		return;
++=======
+ 	if (!parent) {
+ 		dd_dev_info(dd, "Parent not found\n");
+ 		return;
+ 	}
+ 	if (!pci_is_root_bus(parent->bus)) {
+ 		dd_dev_info(dd, "Parent not root\n");
+ 		return;
+ 	}
+ 	if (!pci_is_pcie(parent)) {
+ 		dd_dev_info(dd, "Parent is not PCI Express capable\n");
+ 		return;
+ 	}
+ 	if (!pci_is_pcie(dd->pcidev)) {
+ 		dd_dev_info(dd, "PCI device is not PCI Express capable\n");
+ 		return;
+ 	}
++>>>>>>> 828bcbdc975f (IB/hfi1: Unsuccessful PCIe caps tuning should not fail driver load)
  	rc_mpss = parent->pcie_mpss;
  	rc_mps = ffs(pcie_get_mps(parent)) - 8;
  	/* Find out supported and configured values for endpoint (us) */
* Unmerged path drivers/infiniband/hw/hfi1/pcie.c
