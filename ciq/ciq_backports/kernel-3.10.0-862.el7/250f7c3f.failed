sysfs: introduce [__]sysfs_remove()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 250f7c3fee52b71457b4aa2cafadbd9f8b320b31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/250f7c3f.failed

Given a sysfs_dirent, there is no reason to have multiple versions of
removal functions.  A function which removes the specified
sysfs_dirent and its descendants is enough.

This patch intorduces [__}sysfs_remove() which replaces all internal
variations of removal functions.  This will be the only removal
function in the planned new sysfs_dirent based interface.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 250f7c3fee52b71457b4aa2cafadbd9f8b320b31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/dir.c
index fd502d3fc9fc,b518afd0d11e..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -804,41 -776,92 +805,128 @@@ const struct inode_operations sysfs_dir
  	.setxattr	= sysfs_setxattr,
  };
  
++<<<<<<< HEAD
 +static void remove_dir(struct sysfs_dirent *sd)
 +{
 +	struct sysfs_addrm_cxt acxt;
 +
 +	sysfs_addrm_start(&acxt, sd->s_parent);
 +	sysfs_remove_one(&acxt, sd);
 +	sysfs_addrm_finish(&acxt);
 +}
 +
 +void sysfs_remove_subdir(struct sysfs_dirent *sd)
 +{
 +	remove_dir(sd);
 +}
 +
++=======
+ static struct sysfs_dirent *sysfs_leftmost_descendant(struct sysfs_dirent *pos)
+ {
+ 	struct sysfs_dirent *last;
+ 
+ 	while (true) {
+ 		struct rb_node *rbn;
+ 
+ 		last = pos;
+ 
+ 		if (sysfs_type(pos) != SYSFS_DIR)
+ 			break;
+ 
+ 		rbn = rb_first(&pos->s_dir.children);
+ 		if (!rbn)
+ 			break;
+ 
+ 		pos = to_sysfs_dirent(rbn);
+ 	}
+ 
+ 	return last;
+ }
+ 
+ /**
+  * sysfs_next_descendant_post - find the next descendant for post-order walk
+  * @pos: the current position (%NULL to initiate traversal)
+  * @root: sysfs_dirent whose descendants to walk
+  *
+  * Find the next descendant to visit for post-order traversal of @root's
+  * descendants.  @root is included in the iteration and the last node to be
+  * visited.
+  */
+ static struct sysfs_dirent *sysfs_next_descendant_post(struct sysfs_dirent *pos,
+ 						       struct sysfs_dirent *root)
+ {
+ 	struct rb_node *rbn;
+ 
+ 	lockdep_assert_held(&sysfs_mutex);
+ 
+ 	/* if first iteration, visit leftmost descendant which may be root */
+ 	if (!pos)
+ 		return sysfs_leftmost_descendant(root);
  
- static void __sysfs_remove_dir(struct sysfs_dirent *dir_sd)
+ 	/* if we visited @root, we're done */
+ 	if (pos == root)
+ 		return NULL;
+ 
+ 	/* if there's an unvisited sibling, visit its leftmost descendant */
+ 	rbn = rb_next(&pos->s_rb);
+ 	if (rbn)
+ 		return sysfs_leftmost_descendant(to_sysfs_dirent(rbn));
+ 
+ 	/* no sibling left, visit parent */
+ 	return pos->s_parent;
+ }
++>>>>>>> 250f7c3fee52 (sysfs: introduce [__]sysfs_remove())
+ 
+ void __sysfs_remove(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
  {
++<<<<<<< HEAD
 +	struct sysfs_addrm_cxt acxt;
 +	struct rb_node *pos;
++=======
+ 	struct sysfs_dirent *pos, *next;
++>>>>>>> 250f7c3fee52 (sysfs: introduce [__]sysfs_remove())
  
- 	if (!dir_sd)
+ 	if (!sd)
  		return;
  
++<<<<<<< HEAD
 +	pr_debug("sysfs %s: removing dir\n", dir_sd->s_name);
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	pos = rb_first(&dir_sd->s_dir.children);
 +	while (pos) {
 +		struct sysfs_dirent *sd = to_sysfs_dirent(pos);
 +		pos = rb_next(pos);
 +		if (sysfs_type(sd) != SYSFS_DIR)
 +			sysfs_remove_one(&acxt, sd);
 +	}
++=======
+ 	pr_debug("sysfs %s: removing\n", sd->s_name);
+ 
+ 	next = NULL;
+ 	do {
+ 		pos = next;
+ 		next = sysfs_next_descendant_post(pos, sd);
+ 		if (pos)
+ 			sysfs_remove_one(acxt, pos);
+ 	} while (next);
+ }
+ 
+ /**
+  * sysfs_remove - remove a sysfs_dirent recursively
+  * @sd: the sysfs_dirent to remove
+  *
+  * Remove @sd along with all its subdirectories and files.
+  */
+ void sysfs_remove(struct sysfs_dirent *sd)
+ {
+ 	struct sysfs_addrm_cxt acxt;
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	__sysfs_remove(&acxt, sd);
++>>>>>>> 250f7c3fee52 (sysfs: introduce [__]sysfs_remove())
  	sysfs_addrm_finish(&acxt);
 +
 +	remove_dir(dir_sd);
  }
  
  /**
@@@ -858,12 -880,14 +946,15 @@@ void sysfs_remove_dir(struct kobject * 
  	kobj->sd = NULL;
  	spin_unlock(&sysfs_assoc_lock);
  
- 	__sysfs_remove_dir(sd);
+ 	if (sd) {
+ 		WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
+ 		sysfs_remove(sd);
+ 	}
  }
  
 -int sysfs_rename(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent_sd,
 -		 const char *new_name, const void *new_ns)
 +int sysfs_rename(struct sysfs_dirent *sd,
 +	struct sysfs_dirent *new_parent_sd, const void *new_ns,
 +	const char *new_name)
  {
  	int error;
  
diff --cc fs/sysfs/sysfs.h
index b6deca3e301d,4b1d8258b071..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -165,11 -153,13 +165,21 @@@ extern const struct inode_operations sy
  struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd);
  struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
  void sysfs_put_active(struct sysfs_dirent *sd);
++<<<<<<< HEAD
 +void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 +		       struct sysfs_dirent *parent_sd);
 +int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +void sysfs_remove_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
++=======
+ void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
+ int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+ 		    struct sysfs_dirent *parent_sd);
+ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+ 		  struct sysfs_dirent *parent_sd);
+ void __sysfs_remove(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
+ void sysfs_remove(struct sysfs_dirent *sd);
++>>>>>>> 250f7c3fee52 (sysfs: introduce [__]sysfs_remove())
  void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
  
  struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
@@@ -184,10 -171,9 +194,9 @@@ void release_sysfs_dirent(struct sysfs_
  
  int sysfs_create_subdir(struct kobject *kobj, const char *name,
  			struct sysfs_dirent **p_sd);
- void sysfs_remove_subdir(struct sysfs_dirent *sd);
  
  int sysfs_rename(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent_sd,
 -		 const char *new_name, const void *new_ns);
 +		 const void *ns, const char *new_name);
  
  static inline struct sysfs_dirent *__sysfs_get(struct sysfs_dirent *sd)
  {
* Unmerged path fs/sysfs/dir.c
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 1a6e16c0db91..f8047e7e0ff3 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -110,7 +110,7 @@ static int internal_create_group(struct kobject *kobj, int update,
 	error = create_files(sd, kobj, grp, update);
 	if (error) {
 		if (grp->name)
-			sysfs_remove_subdir(sd);
+			sysfs_remove(sd);
 	}
 	sysfs_put(sd);
 	return error;
@@ -218,7 +218,7 @@ void sysfs_remove_group(struct kobject *kobj,
 
 	remove_files(sd, kobj, grp);
 	if (grp->name)
-		sysfs_remove_subdir(sd);
+		sysfs_remove(sd);
 
 	sysfs_put(sd);
 }
diff --git a/fs/sysfs/inode.c b/fs/sysfs/inode.c
index 15a606d56f5d..59c15bb10022 100644
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@ -327,7 +327,7 @@ int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const void *ns, const cha
 
 	sd = sysfs_find_dirent(dir_sd, ns, name);
 	if (sd)
-		sysfs_remove_one(&acxt, sd);
+		__sysfs_remove(&acxt, sd);
 
 	sysfs_addrm_finish(&acxt);
 
* Unmerged path fs/sysfs/sysfs.h
