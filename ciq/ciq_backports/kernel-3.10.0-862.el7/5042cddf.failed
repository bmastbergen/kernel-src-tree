IB/hfi1: Use filedata rather than filepointer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 5042cddfd058a2db419ba7aaadc866e8dccca06c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5042cddf.failed

Since almost all functions that use the hfi1_filedata get the pointer
from the file pointer, simplify by only passing the hfi1_filedata pointer.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 5042cddfd058a2db419ba7aaadc866e8dccca06c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/file_ops.c
#	drivers/infiniband/hw/hfi1/user_exp_rcv.c
#	drivers/infiniband/hw/hfi1/user_exp_rcv.h
#	drivers/infiniband/hw/hfi1/user_sdma.h
diff --cc drivers/infiniband/hw/hfi1/file_ops.c
index 47a09c151236,ab798a81d6b4..000000000000
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@@ -70,31 -70,38 +70,60 @@@
  /*
   * File operation functions
   */
 -static int hfi1_file_open(struct inode *inode, struct file *fp);
 -static int hfi1_file_close(struct inode *inode, struct file *fp);
 -static ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from);
 -static unsigned int hfi1_poll(struct file *fp, struct poll_table_struct *pt);
 -static int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma);
 -
 +static int hfi1_file_open(struct inode *, struct file *);
 +static int hfi1_file_close(struct inode *, struct file *);
 +static ssize_t hfi1_aio_write(struct kiocb *, const struct iovec *,
 +			      unsigned long, loff_t);
 +static unsigned int hfi1_poll(struct file *, struct poll_table_struct *);
 +static int hfi1_file_mmap(struct file *, struct vm_area_struct *);
 +
++<<<<<<< HEAD
 +static u64 kvirt_to_phys(void *);
 +static int assign_ctxt(struct file *, struct hfi1_user_info *);
 +static int init_subctxts(struct hfi1_ctxtdata *, const struct hfi1_user_info *);
 +static int user_init(struct file *);
 +static int get_ctxt_info(struct file *, void __user *, __u32);
 +static int get_base_info(struct file *, void __user *, __u32);
 +static int setup_ctxt(struct file *);
 +static int setup_subctxt(struct hfi1_ctxtdata *);
 +static int get_user_context(struct file *, struct hfi1_user_info *, int);
 +static int find_shared_ctxt(struct file *, const struct hfi1_user_info *);
 +static int allocate_ctxt(struct file *, struct hfi1_devdata *,
 +			 struct hfi1_user_info *);
 +static unsigned int poll_urgent(struct file *, struct poll_table_struct *);
 +static unsigned int poll_next(struct file *, struct poll_table_struct *);
 +static int user_event_ack(struct hfi1_ctxtdata *, int, unsigned long);
 +static int set_ctxt_pkey(struct hfi1_ctxtdata *, unsigned, u16);
 +static int manage_rcvq(struct hfi1_ctxtdata *, unsigned, int);
 +static int vma_fault(struct vm_area_struct *, struct vm_fault *);
++=======
+ static u64 kvirt_to_phys(void *addr);
+ static int assign_ctxt(struct file *fp, struct hfi1_user_info *uinfo);
+ static int init_subctxts(struct hfi1_ctxtdata *uctxt,
+ 			 const struct hfi1_user_info *uinfo);
+ static int user_init(struct hfi1_filedata *fd);
+ static int get_ctxt_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int get_base_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int setup_ctxt(struct hfi1_filedata *fd);
+ static int setup_subctxt(struct hfi1_ctxtdata *uctxt);
+ static int get_user_context(struct hfi1_filedata *fd,
+ 			    struct hfi1_user_info *uinfo, int devno);
+ static int find_shared_ctxt(struct hfi1_filedata *fd,
+ 			    const struct hfi1_user_info *uinfo);
+ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
+ 			 struct hfi1_user_info *uinfo);
+ static unsigned int poll_urgent(struct file *fp, struct poll_table_struct *pt);
+ static unsigned int poll_next(struct file *fp, struct poll_table_struct *pt);
+ static int user_event_ack(struct hfi1_ctxtdata *uctxt, int subctxt,
+ 			  unsigned long events);
+ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
+ 			 u16 pkey);
+ static int manage_rcvq(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
+ 		       int start_stop);
+ static int vma_fault(struct vm_fault *vmf);
++>>>>>>> 5042cddfd058 (IB/hfi1: Use filedata rather than filepointer)
  static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
  			    unsigned long arg);
  
@@@ -431,7 -438,7 +460,11 @@@ static ssize_t hfi1_aio_write(struct ki
  		unsigned long count = 0;
  
  		ret = hfi1_user_sdma_process_request(
++<<<<<<< HEAD
 +			kiocb->ki_filp,	(struct iovec *)(iovec + done),
++=======
+ 			fd, (struct iovec *)(from->iov + done),
++>>>>>>> 5042cddfd058 (IB/hfi1: Use filedata rather than filepointer)
  			dim, &count);
  		if (ret) {
  			reqs = ret;
diff --cc drivers/infiniband/hw/hfi1/user_exp_rcv.c
index c7f13df471c4,22ffda8bf65f..000000000000
--- a/drivers/infiniband/hw/hfi1/user_exp_rcv.c
+++ b/drivers/infiniband/hw/hfi1/user_exp_rcv.c
@@@ -82,20 -82,25 +82,42 @@@ struct tid_pageset 
  		 (unsigned long)(len) - 1) & PAGE_MASK) -	       \
  	       ((unsigned long)vaddr & PAGE_MASK)) >> PAGE_SHIFT))
  
++<<<<<<< HEAD
 +static void unlock_exp_tids(struct hfi1_ctxtdata *, struct exp_tid_set *,
 +			    struct hfi1_filedata *);
 +static u32 find_phys_blocks(struct page **, unsigned, struct tid_pageset *);
 +static int set_rcvarray_entry(struct file *, unsigned long, u32,
 +			      struct tid_group *, struct page **, unsigned);
 +static int tid_rb_insert(void *, struct mmu_rb_node *);
 +static void cacheless_tid_rb_remove(struct hfi1_filedata *fdata,
 +				    struct tid_rb_node *tnode);
 +static void tid_rb_remove(void *, struct mmu_rb_node *);
 +static int tid_rb_invalidate(void *, struct mmu_rb_node *);
 +static int program_rcvarray(struct file *, unsigned long, struct tid_group *,
 +			    struct tid_pageset *, unsigned, u16, struct page **,
 +			    u32 *, unsigned *, unsigned *);
 +static int unprogram_rcvarray(struct file *, u32, struct tid_group **);
++=======
+ static void unlock_exp_tids(struct hfi1_ctxtdata *uctxt,
+ 			    struct exp_tid_set *set,
+ 			    struct hfi1_filedata *fd);
+ static u32 find_phys_blocks(struct page **pages, unsigned npages,
+ 			    struct tid_pageset *list);
+ static int set_rcvarray_entry(struct hfi1_filedata *fd, unsigned long vaddr,
+ 			      u32 rcventry, struct tid_group *grp,
+ 			      struct page **pages, unsigned npages);
+ static int tid_rb_insert(void *arg, struct mmu_rb_node *node);
+ static void cacheless_tid_rb_remove(struct hfi1_filedata *fdata,
+ 				    struct tid_rb_node *tnode);
+ static void tid_rb_remove(void *arg, struct mmu_rb_node *node);
+ static int tid_rb_invalidate(void *arg, struct mmu_rb_node *mnode);
+ static int program_rcvarray(struct hfi1_filedata *fd, unsigned long vaddr,
+ 			    struct tid_group *grp, struct tid_pageset *sets,
+ 			    unsigned start, u16 count, struct page **pages,
+ 			    u32 *tidlist, unsigned *tididx, unsigned *pmapped);
+ static int unprogram_rcvarray(struct hfi1_filedata *fd, u32 tidinfo,
+ 			      struct tid_group **grp);
++>>>>>>> 5042cddfd058 (IB/hfi1: Use filedata rather than filepointer)
  static void clear_tid_node(struct hfi1_filedata *fd, struct tid_rb_node *node);
  
  static struct mmu_rb_ops tid_rb_ops = {
diff --cc drivers/infiniband/hw/hfi1/user_exp_rcv.h
index d1d7d3d3bd44,9787511b30b4..000000000000
--- a/drivers/infiniband/hw/hfi1/user_exp_rcv.h
+++ b/drivers/infiniband/hw/hfi1/user_exp_rcv.h
@@@ -71,10 -71,13 +71,21 @@@
  	} while (0)
  
  void hfi1_user_exp_rcv_grp_free(struct hfi1_ctxtdata *uctxt);
++<<<<<<< HEAD
 +int hfi1_user_exp_rcv_init(struct file *);
 +int hfi1_user_exp_rcv_free(struct hfi1_filedata *);
 +int hfi1_user_exp_rcv_setup(struct file *, struct hfi1_tid_info *);
 +int hfi1_user_exp_rcv_clear(struct file *, struct hfi1_tid_info *);
 +int hfi1_user_exp_rcv_invalid(struct file *, struct hfi1_tid_info *);
++=======
+ int hfi1_user_exp_rcv_init(struct hfi1_filedata *fd);
+ int hfi1_user_exp_rcv_free(struct hfi1_filedata *fd);
+ int hfi1_user_exp_rcv_setup(struct hfi1_filedata *fd,
+ 			    struct hfi1_tid_info *tinfo);
+ int hfi1_user_exp_rcv_clear(struct hfi1_filedata *fd,
+ 			    struct hfi1_tid_info *tinfo);
+ int hfi1_user_exp_rcv_invalid(struct hfi1_filedata *fd,
+ 			      struct hfi1_tid_info *tinfo);
++>>>>>>> 5042cddfd058 (IB/hfi1: Use filedata rather than filepointer)
  
  #endif /* _HFI1_USER_EXP_RCV_H */
diff --cc drivers/infiniband/hw/hfi1/user_sdma.h
index 39001714f551,9181d7cbe8f6..000000000000
--- a/drivers/infiniband/hw/hfi1/user_sdma.h
+++ b/drivers/infiniband/hw/hfi1/user_sdma.h
@@@ -78,7 -80,11 +78,18 @@@ struct hfi1_user_sdma_comp_q 
  	struct hfi1_sdma_comp_entry *comps;
  };
  
++<<<<<<< HEAD
 +int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *, struct file *);
 +int hfi1_user_sdma_free_queues(struct hfi1_filedata *);
 +int hfi1_user_sdma_process_request(struct file *, struct iovec *, unsigned long,
 +				   unsigned long *);
++=======
+ int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt,
+ 				struct hfi1_filedata *fd);
+ int hfi1_user_sdma_free_queues(struct hfi1_filedata *fd);
+ int hfi1_user_sdma_process_request(struct hfi1_filedata *fd,
+ 				   struct iovec *iovec, unsigned long dim,
+ 				   unsigned long *count);
+ 
+ #endif /* _HFI1_USER_SDMA_H */
++>>>>>>> 5042cddfd058 (IB/hfi1: Use filedata rather than filepointer)
* Unmerged path drivers/infiniband/hw/hfi1/file_ops.c
* Unmerged path drivers/infiniband/hw/hfi1/user_exp_rcv.c
* Unmerged path drivers/infiniband/hw/hfi1/user_exp_rcv.h
diff --git a/drivers/infiniband/hw/hfi1/user_sdma.c b/drivers/infiniband/hw/hfi1/user_sdma.c
index b26045b15ba3..385aac219cfc 100644
--- a/drivers/infiniband/hw/hfi1/user_sdma.c
+++ b/drivers/infiniband/hw/hfi1/user_sdma.c
@@ -370,9 +370,9 @@ static void sdma_kmem_cache_ctor(void *obj)
 	memset(tx, 0, sizeof(*tx));
 }
 
-int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt, struct file *fp)
+int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt,
+				struct hfi1_filedata *fd)
 {
-	struct hfi1_filedata *fd;
 	int ret = 0;
 	char buf[64];
 	struct hfi1_devdata *dd;
@@ -380,13 +380,11 @@ int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt, struct file *fp)
 	struct hfi1_user_sdma_pkt_q *pq;
 	unsigned long flags;
 
-	if (!uctxt || !fp) {
+	if (!uctxt || !fd) {
 		ret = -EBADF;
 		goto done;
 	}
 
-	fd = fp->private_data;
-
 	if (!hfi1_sdma_comp_ring_size) {
 		ret = -EINVAL;
 		goto done;
@@ -534,11 +532,11 @@ static u8 dlid_to_selector(u16 dlid)
 	return mapping[hash];
 }
 
-int hfi1_user_sdma_process_request(struct file *fp, struct iovec *iovec,
-				   unsigned long dim, unsigned long *count)
+int hfi1_user_sdma_process_request(struct hfi1_filedata *fd,
+				   struct iovec *iovec, unsigned long dim,
+				   unsigned long *count)
 {
 	int ret = 0, i;
-	struct hfi1_filedata *fd = fp->private_data;
 	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 	struct hfi1_user_sdma_pkt_q *pq = fd->pq;
 	struct hfi1_user_sdma_comp_q *cq = fd->cq;
* Unmerged path drivers/infiniband/hw/hfi1/user_sdma.h
