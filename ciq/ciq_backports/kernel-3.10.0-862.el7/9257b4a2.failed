iommu/iova: introduce per-cpu caching to iova allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] iova: introduce per-cpu caching to iova allocation (Jerry Snitselaar) [1411581]
Rebuild_FUZZ: 94.34%
commit-author Omer Peleg <omer@cs.technion.ac.il>
commit 9257b4a206fc0229dd5f84b78e4d1ebf3f91d270
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9257b4a2.failed

IOVA allocation has two problems that impede high-throughput I/O.
First, it can do a linear search over the allocated IOVA ranges.
Second, the rbtree spinlock that serializes IOVA allocations becomes
contended.

Address these problems by creating an API for caching allocated IOVA
ranges, so that the IOVA allocator isn't accessed frequently.  This
patch adds a per-CPU cache, from which CPUs can alloc/free IOVAs
without taking the rbtree spinlock.  The per-CPU caches are backed by
a global cache, to avoid invoking the (linear-time) IOVA allocator
without needing to make the per-CPU cache size excessive.  This design
is based on magazines, as described in "Magazines and Vmem: Extending
the Slab Allocator to Many CPUs and Arbitrary Resources" (currently
available at https://www.usenix.org/legacy/event/usenix01/bonwick.html)

Adding caching on top of the existing rbtree allocator maintains the
property that IOVAs are densely packed in the IO virtual address space,
which is important for keeping IOMMU page table usage low.

To keep the cache size reasonable, we bound the IOVA space a CPU can
cache by 32 MiB (we cache a bounded number of IOVA ranges, and only
ranges of size <= 128 KiB).  The shared global cache is bounded at
4 MiB of IOVA space.

	Signed-off-by: Omer Peleg <omer@cs.technion.ac.il>
[mad@cs.technion.ac.il: rebased, cleaned up and reworded the commit message]
	Signed-off-by: Adam Morrison <mad@cs.technion.ac.il>
	Reviewed-by: Shaohua Li <shli@fb.com>
	Reviewed-by: Ben Serebrin <serebrin@google.com>
[dwmw2: split out VT-d part into a separate patch]
	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 9257b4a206fc0229dd5f84b78e4d1ebf3f91d270)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iova.c
diff --cc drivers/iommu/iova.c
index d4833981e720,ba764a0835d3..000000000000
--- a/drivers/iommu/iova.c
+++ b/drivers/iommu/iova.c
@@@ -38,7 -49,9 +49,8 @@@ init_iova_domain(struct iova_domain *io
  	iovad->granule = granule;
  	iovad->start_pfn = start_pfn;
  	iovad->dma_32bit_pfn = pfn_32bit;
+ 	init_iova_rcaches(iovad);
  }
 -EXPORT_SYMBOL_GPL(init_iova_domain);
  
  static struct rb_node *
  __get_cached_rbnode(struct iova_domain *iovad, unsigned long *limit_pfn)
@@@ -286,22 -301,15 +298,14 @@@ alloc_iova(struct iova_domain *iovad, u
  
  	return new_iova;
  }
 -EXPORT_SYMBOL_GPL(alloc_iova);
  
- /**
-  * find_iova - find's an iova for a given pfn
-  * @iovad: - iova domain in question.
-  * @pfn: - page frame number
-  * This function finds and returns an iova belonging to the
-  * given doamin which matches the given pfn.
-  */
- struct iova *find_iova(struct iova_domain *iovad, unsigned long pfn)
+ static struct iova *
+ private_find_iova(struct iova_domain *iovad, unsigned long pfn)
  {
- 	unsigned long flags;
- 	struct rb_node *node;
+ 	struct rb_node *node = iovad->rbroot.rb_node;
+ 
+ 	assert_spin_locked(&iovad->iova_rbtree_lock);
  
- 	/* Take the lock so that no other thread is manipulating the rbtree */
- 	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
- 	node = iovad->rbroot.rb_node;
  	while (node) {
  		struct iova *iova = container_of(node, struct iova, node);
  
@@@ -323,9 -324,36 +320,39 @@@
  			node = node->rb_right;
  	}
  
- 	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
  	return NULL;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void private_free_iova(struct iova_domain *iovad, struct iova *iova)
+ {
+ 	assert_spin_locked(&iovad->iova_rbtree_lock);
+ 	__cached_rbnode_delete_update(iovad, iova);
+ 	rb_erase(&iova->node, &iovad->rbroot);
+ 	free_iova_mem(iova);
+ }
+ 
+ /**
+  * find_iova - finds an iova for a given pfn
+  * @iovad: - iova domain in question.
+  * @pfn: - page frame number
+  * This function finds and returns an iova belonging to the
+  * given doamin which matches the given pfn.
+  */
+ struct iova *find_iova(struct iova_domain *iovad, unsigned long pfn)
+ {
+ 	unsigned long flags;
+ 	struct iova *iova;
+ 
+ 	/* Take the lock so that no other thread is manipulating the rbtree */
+ 	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
+ 	iova = private_find_iova(iovad, pfn);
+ 	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
+ 	return iova;
+ }
+ EXPORT_SYMBOL_GPL(find_iova);
++>>>>>>> 9257b4a206fc (iommu/iova: introduce per-cpu caching to iova allocation)
  
  /**
   * __free_iova - frees the given iova
@@@ -339,11 -367,10 +366,9 @@@ __free_iova(struct iova_domain *iovad, 
  	unsigned long flags;
  
  	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
- 	__cached_rbnode_delete_update(iovad, iova);
- 	rb_erase(&iova->node, &iovad->rbroot);
+ 	private_free_iova(iovad, iova);
  	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
- 	free_iova_mem(iova);
  }
 -EXPORT_SYMBOL_GPL(__free_iova);
  
  /**
   * free_iova - finds and frees the iova for a given pfn
@@@ -361,7 -388,65 +386,64 @@@ free_iova(struct iova_domain *iovad, un
  		__free_iova(iovad, iova);
  
  }
 -EXPORT_SYMBOL_GPL(free_iova);
  
+ /**
+  * alloc_iova_fast - allocates an iova from rcache
+  * @iovad: - iova domain in question
+  * @size: - size of page frames to allocate
+  * @limit_pfn: - max limit address
+  * This function tries to satisfy an iova allocation from the rcache,
+  * and falls back to regular allocation on failure.
+ */
+ unsigned long
+ alloc_iova_fast(struct iova_domain *iovad, unsigned long size,
+ 		unsigned long limit_pfn)
+ {
+ 	bool flushed_rcache = false;
+ 	unsigned long iova_pfn;
+ 	struct iova *new_iova;
+ 
+ 	iova_pfn = iova_rcache_get(iovad, size, limit_pfn);
+ 	if (iova_pfn)
+ 		return iova_pfn;
+ 
+ retry:
+ 	new_iova = alloc_iova(iovad, size, limit_pfn, true);
+ 	if (!new_iova) {
+ 		unsigned int cpu;
+ 
+ 		if (flushed_rcache)
+ 			return 0;
+ 
+ 		/* Try replenishing IOVAs by flushing rcache. */
+ 		flushed_rcache = true;
+ 		for_each_online_cpu(cpu)
+ 			free_cpu_cached_iovas(cpu, iovad);
+ 		goto retry;
+ 	}
+ 
+ 	return new_iova->pfn_lo;
+ }
+ EXPORT_SYMBOL_GPL(alloc_iova_fast);
+ 
+ /**
+  * free_iova_fast - free iova pfn range into rcache
+  * @iovad: - iova domain in question.
+  * @pfn: - pfn that is allocated previously
+  * @size: - # of pages in range
+  * This functions frees an iova range by trying to put it into the rcache,
+  * falling back to regular iova deallocation via free_iova() if this fails.
+  */
+ void
+ free_iova_fast(struct iova_domain *iovad, unsigned long pfn, unsigned long size)
+ {
+ 	if (iova_rcache_insert(iovad, pfn, size))
+ 		return;
+ 
+ 	free_iova(iovad, pfn);
+ }
+ EXPORT_SYMBOL_GPL(free_iova_fast);
+ 
  /**
   * put_iova_domain - destroys the iova doamin
   * @iovad: - iova domain in question.
* Unmerged path drivers/iommu/iova.c
diff --git a/include/linux/iova.h b/include/linux/iova.h
index 92f7177db2ce..f27bb2c62fca 100644
--- a/include/linux/iova.h
+++ b/include/linux/iova.h
@@ -19,8 +19,21 @@
 /* iova structure */
 struct iova {
 	struct rb_node	node;
-	unsigned long	pfn_hi; /* IOMMU dish out addr hi */
-	unsigned long	pfn_lo; /* IOMMU dish out addr lo */
+	unsigned long	pfn_hi; /* Highest allocated pfn */
+	unsigned long	pfn_lo; /* Lowest allocated pfn */
+};
+
+struct iova_magazine;
+struct iova_cpu_rcache;
+
+#define IOVA_RANGE_CACHE_MAX_SIZE 6	/* log of max cached IOVA range size (in pages) */
+#define MAX_GLOBAL_MAGS 32	/* magazines per bin */
+
+struct iova_rcache {
+	spinlock_t lock;
+	unsigned long depot_size;
+	struct iova_magazine *depot[MAX_GLOBAL_MAGS];
+	struct iova_cpu_rcache __percpu *cpu_rcaches;
 };
 
 /* holds all the iova translations for a domain */
@@ -31,6 +44,7 @@ struct iova_domain {
 	unsigned long	granule;	/* pfn granularity for this domain */
 	unsigned long	start_pfn;	/* Lower limit for this domain */
 	unsigned long	dma_32bit_pfn;
+	struct iova_rcache rcaches[IOVA_RANGE_CACHE_MAX_SIZE];	/* IOVA range caches */
 };
 
 static inline unsigned long iova_size(struct iova *iova)
@@ -78,6 +92,10 @@ void __free_iova(struct iova_domain *iovad, struct iova *iova);
 struct iova *alloc_iova(struct iova_domain *iovad, unsigned long size,
 	unsigned long limit_pfn,
 	bool size_aligned);
+void free_iova_fast(struct iova_domain *iovad, unsigned long pfn,
+		    unsigned long size);
+unsigned long alloc_iova_fast(struct iova_domain *iovad, unsigned long size,
+			      unsigned long limit_pfn);
 struct iova *reserve_iova(struct iova_domain *iovad, unsigned long pfn_lo,
 	unsigned long pfn_hi);
 void copy_reserved_iova(struct iova_domain *from, struct iova_domain *to);
@@ -87,5 +105,6 @@ struct iova *find_iova(struct iova_domain *iovad, unsigned long pfn);
 void put_iova_domain(struct iova_domain *iovad);
 struct iova *split_and_remove_iova(struct iova_domain *iovad,
 	struct iova *iova, unsigned long pfn_lo, unsigned long pfn_hi);
+void free_cpu_cached_iovas(unsigned int cpu, struct iova_domain *iovad);
 
 #endif
