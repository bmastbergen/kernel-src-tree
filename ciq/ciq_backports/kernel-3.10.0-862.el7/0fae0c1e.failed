crypto: testmgr - fix !x==y confusion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [crypto] testmgr - fix !x==y confusion (Neil Horman) [1475478]
Rebuild_FUZZ: 87.88%
commit-author Yanjiang Jin <yanjiang.jin@windriver.com>
commit 0fae0c1e1d7991ce0dbefdd1c35c14e9d0025cc2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0fae0c1e.failed

"if (!ret == template[i].fail)" is confusing to compilers (gcc5):

crypto/testmgr.c: In function '__test_aead':
crypto/testmgr.c:531:12: warning: logical not is only applied to the
left hand side of comparison [-Wlogical-not-parentheses]
   if (!ret == template[i].fail) {
            ^

Let there be 'if (template[i].fail == !ret) '.

	Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 0fae0c1e1d7991ce0dbefdd1c35c14e9d0025cc2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/testmgr.c
diff --cc crypto/testmgr.c
index 756940dfe87a,c2a8bd38ef1f..000000000000
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@@ -435,148 -627,275 +435,308 @@@ static int __test_aead(struct crypto_ae
  	iv_len = crypto_aead_ivsize(tfm);
  
  	for (i = 0, j = 0; i < tcount; i++) {
 -		if (template[i].np)
 -			continue;
 -
 -		j++;
 -
 -		/* some templates have no input data but they will
 -		 * touch input
 -		 */
 -		input = xbuf[0];
 -		input += align_offset;
 -		assoc = axbuf[0];
 -
 -		ret = -EINVAL;
 -		if (WARN_ON(align_offset + template[i].ilen >
 -			    PAGE_SIZE || template[i].alen > PAGE_SIZE))
 -			goto out;
 -
 -		memcpy(input, template[i].input, template[i].ilen);
 -		memcpy(assoc, template[i].assoc, template[i].alen);
 -		if (template[i].iv)
 -			memcpy(iv, template[i].iv, iv_len);
 -		else
 -			memset(iv, 0, iv_len);
 +		if (!template[i].np) {
 +			j++;
  
 -		crypto_aead_clear_flags(tfm, ~0);
 -		if (template[i].wk)
 -			crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +			/* some tepmplates have no input data but they will
 +			 * touch input
 +			 */
 +			input = xbuf[0];
 +			assoc = axbuf[0];
  
 -		if (template[i].klen > MAX_KEYLEN) {
 -			pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
 -			       d, j, algo, template[i].klen,
 -			       MAX_KEYLEN);
  			ret = -EINVAL;
 -			goto out;
 -		}
 -		memcpy(key, template[i].key, template[i].klen);
 +			if (WARN_ON(template[i].ilen > PAGE_SIZE ||
 +				    template[i].alen > PAGE_SIZE))
 +				goto out;
  
++<<<<<<< HEAD
 +			memcpy(input, template[i].input, template[i].ilen);
 +			memcpy(assoc, template[i].assoc, template[i].alen);
 +			if (template[i].iv)
 +				memcpy(iv, template[i].iv, iv_len);
 +			else
 +				memset(iv, 0, iv_len);
++=======
+ 		ret = crypto_aead_setkey(tfm, key, template[i].klen);
+ 		if (template[i].fail == !ret) {
+ 			pr_err("alg: aead%s: setkey failed on test %d for %s: flags=%x\n",
+ 			       d, j, algo, crypto_aead_get_flags(tfm));
+ 			goto out;
+ 		} else if (ret)
+ 			continue;
++>>>>>>> 0fae0c1e1d79 (crypto: testmgr - fix !x==y confusion)
  
 -		authsize = abs(template[i].rlen - template[i].ilen);
 -		ret = crypto_aead_setauthsize(tfm, authsize);
 -		if (ret) {
 -			pr_err("alg: aead%s: Failed to set authsize to %u on test %d for %s\n",
 -			       d, authsize, j, algo);
 -			goto out;
 -		}
 +			crypto_aead_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_aead_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
  
 -		k = !!template[i].alen;
 -		sg_init_table(sg, k + 1);
 -		sg_set_buf(&sg[0], assoc, template[i].alen);
 -		sg_set_buf(&sg[k], input,
 -			   template[i].ilen + (enc ? authsize : 0));
 -		output = input;
 +			key = template[i].key;
  
 -		if (diff_dst) {
 -			sg_init_table(sgout, k + 1);
 -			sg_set_buf(&sgout[0], assoc, template[i].alen);
 +			ret = crypto_aead_setkey(tfm, key,
 +						 template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: aead%s: setkey failed on test %d for %s: flags=%x\n",
 +				       d, j, algo, crypto_aead_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
  
 -			output = xoutbuf[0];
 -			output += align_offset;
 -			sg_set_buf(&sgout[k], output,
 -				   template[i].rlen + (enc ? 0 : authsize));
 -		}
 +			authsize = abs(template[i].rlen - template[i].ilen);
 +			ret = crypto_aead_setauthsize(tfm, authsize);
 +			if (ret) {
 +				pr_err("alg: aead%s: Failed to set authsize to %u on test %d for %s\n",
 +				       d, authsize, j, algo);
 +				goto out;
 +			}
  
 -		aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 -				       template[i].ilen, iv);
 +			sg_init_one(&sg[0], input,
 +				    template[i].ilen + (enc ? authsize : 0));
  
 -		aead_request_set_ad(req, template[i].alen);
 +			if (diff_dst) {
 +				output = xoutbuf[0];
 +				sg_init_one(&sgout[0], output,
 +					    template[i].ilen +
 +						(enc ? authsize : 0));
 +			} else {
 +				output = input;
 +			}
  
 -		ret = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
 +			sg_init_one(&asg[0], assoc, template[i].alen);
  
 -		switch (ret) {
 -		case 0:
 -			if (template[i].novrfy) {
 -				/* verification was supposed to fail */
 -				pr_err("alg: aead%s: %s failed on test %d for %s: ret was 0, expected -EBADMSG\n",
 -				       d, e, j, algo);
 -				/* so really, we got a bad message */
 -				ret = -EBADMSG;
 +			aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 +					       template[i].ilen, iv);
 +
 +			aead_request_set_assoc(req, asg, template[i].alen);
 +
 +			ret = enc ?
 +				crypto_aead_encrypt(req) :
 +				crypto_aead_decrypt(req);
 +
 +			switch (ret) {
 +			case 0:
 +				if (template[i].novrfy) {
 +					/* verification was supposed to fail */
 +					pr_err("alg: aead%s: %s failed on test %d for %s: ret was 0, expected -EBADMSG\n",
 +					       d, e, j, algo);
 +					/* so really, we got a bad message */
 +					ret = -EBADMSG;
 +					goto out;
 +				}
 +				break;
 +			case -EINPROGRESS:
 +			case -EBUSY:
 +				wait_for_completion(&result.completion);
 +				INIT_COMPLETION(result.completion);
 +				ret = result.err;
 +				if (!ret)
 +					break;
 +			case -EBADMSG:
 +				if (template[i].novrfy)
 +					/* verification failure was expected */
 +					continue;
 +				/* fall through */
 +			default:
 +				pr_err("alg: aead%s: %s failed on test %d for %s: ret=%d\n",
 +				       d, e, j, algo, -ret);
  				goto out;
  			}
 -			break;
 -		case -EINPROGRESS:
 -		case -EBUSY:
 -			wait_for_completion(&result.completion);
 -			reinit_completion(&result.completion);
 -			ret = result.err;
 -			if (!ret)
 -				break;
 -		case -EBADMSG:
 -			if (template[i].novrfy)
 -				/* verification failure was expected */
 -				continue;
 -			/* fall through */
 -		default:
 -			pr_err("alg: aead%s: %s failed on test %d for %s: ret=%d\n",
 -			       d, e, j, algo, -ret);
 -			goto out;
 -		}
  
 -		q = output;
 -		if (memcmp(q, template[i].result, template[i].rlen)) {
 -			pr_err("alg: aead%s: Test %d failed on %s for %s\n",
 -			       d, j, e, algo);
 -			hexdump(q, template[i].rlen);
 -			ret = -EINVAL;
 -			goto out;
 +			q = output;
 +			if (memcmp(q, template[i].result, template[i].rlen)) {
 +				pr_err("alg: aead%s: Test %d failed on %s for %s\n",
 +				       d, j, e, algo);
 +				hexdump(q, template[i].rlen);
 +				ret = -EINVAL;
 +				goto out;
 +			}
  		}
  	}
  
  	for (i = 0, j = 0; i < tcount; i++) {
 -		/* alignment tests are only done with continuous buffers */
 -		if (align_offset != 0)
 -			break;
 +		if (template[i].np) {
 +			j++;
  
++<<<<<<< HEAD
 +			if (template[i].iv)
 +				memcpy(iv, template[i].iv, iv_len);
++=======
+ 		if (!template[i].np)
+ 			continue;
+ 
+ 		j++;
+ 
+ 		if (template[i].iv)
+ 			memcpy(iv, template[i].iv, iv_len);
+ 		else
+ 			memset(iv, 0, MAX_IVLEN);
+ 
+ 		crypto_aead_clear_flags(tfm, ~0);
+ 		if (template[i].wk)
+ 			crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+ 		if (template[i].klen > MAX_KEYLEN) {
+ 			pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
+ 			       d, j, algo, template[i].klen, MAX_KEYLEN);
+ 			ret = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(key, template[i].key, template[i].klen);
+ 
+ 		ret = crypto_aead_setkey(tfm, key, template[i].klen);
+ 		if (template[i].fail == !ret) {
+ 			pr_err("alg: aead%s: setkey failed on chunk test %d for %s: flags=%x\n",
+ 			       d, j, algo, crypto_aead_get_flags(tfm));
+ 			goto out;
+ 		} else if (ret)
+ 			continue;
+ 
+ 		authsize = abs(template[i].rlen - template[i].ilen);
+ 
+ 		ret = -EINVAL;
+ 		sg_init_table(sg, template[i].anp + template[i].np);
+ 		if (diff_dst)
+ 			sg_init_table(sgout, template[i].anp + template[i].np);
+ 
+ 		ret = -EINVAL;
+ 		for (k = 0, temp = 0; k < template[i].anp; k++) {
+ 			if (WARN_ON(offset_in_page(IDX[k]) +
+ 				    template[i].atap[k] > PAGE_SIZE))
+ 				goto out;
+ 			sg_set_buf(&sg[k],
+ 				   memcpy(axbuf[IDX[k] >> PAGE_SHIFT] +
+ 					  offset_in_page(IDX[k]),
+ 					  template[i].assoc + temp,
+ 					  template[i].atap[k]),
+ 				   template[i].atap[k]);
+ 			if (diff_dst)
+ 				sg_set_buf(&sgout[k],
+ 					   axbuf[IDX[k] >> PAGE_SHIFT] +
+ 					   offset_in_page(IDX[k]),
+ 					   template[i].atap[k]);
+ 			temp += template[i].atap[k];
+ 		}
+ 
+ 		for (k = 0, temp = 0; k < template[i].np; k++) {
+ 			if (WARN_ON(offset_in_page(IDX[k]) +
+ 				    template[i].tap[k] > PAGE_SIZE))
+ 				goto out;
+ 
+ 			q = xbuf[IDX[k] >> PAGE_SHIFT] + offset_in_page(IDX[k]);
+ 			memcpy(q, template[i].input + temp, template[i].tap[k]);
+ 			sg_set_buf(&sg[template[i].anp + k],
+ 				   q, template[i].tap[k]);
+ 
+ 			if (diff_dst) {
+ 				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
+ 				    offset_in_page(IDX[k]);
+ 
+ 				memset(q, 0, template[i].tap[k]);
+ 
+ 				sg_set_buf(&sgout[template[i].anp + k],
+ 					   q, template[i].tap[k]);
+ 			}
+ 
+ 			n = template[i].tap[k];
+ 			if (k == template[i].np - 1 && enc)
+ 				n += authsize;
+ 			if (offset_in_page(q) + n < PAGE_SIZE)
+ 				q[n] = 0;
+ 
+ 			temp += template[i].tap[k];
+ 		}
+ 
+ 		ret = crypto_aead_setauthsize(tfm, authsize);
+ 		if (ret) {
+ 			pr_err("alg: aead%s: Failed to set authsize to %u on chunk test %d for %s\n",
+ 			       d, authsize, j, algo);
+ 			goto out;
+ 		}
+ 
+ 		if (enc) {
+ 			if (WARN_ON(sg[template[i].anp + k - 1].offset +
+ 				    sg[template[i].anp + k - 1].length +
+ 				    authsize > PAGE_SIZE)) {
+ 				ret = -EINVAL;
+ 				goto out;
+ 			}
+ 
+ 			if (diff_dst)
+ 				sgout[template[i].anp + k - 1].length +=
+ 					authsize;
+ 			sg[template[i].anp + k - 1].length += authsize;
+ 		}
+ 
+ 		aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
+ 				       template[i].ilen,
+ 				       iv);
+ 
+ 		aead_request_set_ad(req, template[i].alen);
+ 
+ 		ret = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
+ 
+ 		switch (ret) {
+ 		case 0:
+ 			if (template[i].novrfy) {
+ 				/* verification was supposed to fail */
+ 				pr_err("alg: aead%s: %s failed on chunk test %d for %s: ret was 0, expected -EBADMSG\n",
+ 				       d, e, j, algo);
+ 				/* so really, we got a bad message */
+ 				ret = -EBADMSG;
+ 				goto out;
+ 			}
+ 			break;
+ 		case -EINPROGRESS:
+ 		case -EBUSY:
+ 			wait_for_completion(&result.completion);
+ 			reinit_completion(&result.completion);
+ 			ret = result.err;
+ 			if (!ret)
+ 				break;
+ 		case -EBADMSG:
+ 			if (template[i].novrfy)
+ 				/* verification failure was expected */
+ 				continue;
+ 			/* fall through */
+ 		default:
+ 			pr_err("alg: aead%s: %s failed on chunk test %d for %s: ret=%d\n",
+ 			       d, e, j, algo, -ret);
+ 			goto out;
+ 		}
+ 
+ 		ret = -EINVAL;
+ 		for (k = 0, temp = 0; k < template[i].np; k++) {
+ 			if (diff_dst)
+ 				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
+ 				    offset_in_page(IDX[k]);
++>>>>>>> 0fae0c1e1d79 (crypto: testmgr - fix !x==y confusion)
  			else
 +				memset(iv, 0, MAX_IVLEN);
 +
 +			crypto_aead_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_aead_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +			key = template[i].key;
 +
 +			ret = crypto_aead_setkey(tfm, key, template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: aead%s: setkey failed on chunk test %d for %s: flags=%x\n",
 +				       d, j, algo, crypto_aead_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
 +
 +			authsize = abs(template[i].rlen - template[i].ilen);
 +
 +			ret = -EINVAL;
 +			sg_init_table(sg, template[i].np);
 +			if (diff_dst)
 +				sg_init_table(sgout, template[i].np);
 +			for (k = 0, temp = 0; k < template[i].np; k++) {
 +				if (WARN_ON(offset_in_page(IDX[k]) +
 +					    template[i].tap[k] > PAGE_SIZE))
 +					goto out;
 +
  				q = xbuf[IDX[k] >> PAGE_SHIFT] +
  				    offset_in_page(IDX[k]);
  
@@@ -889,72 -1117,75 +1049,96 @@@ static int __test_skcipher(struct crypt
  		else
  			memset(iv, 0, MAX_IVLEN);
  
++<<<<<<< HEAD
 +		if (fips_enabled && template[i].fips_skip)
++=======
+ 		j++;
+ 		ret = -EINVAL;
+ 		if (WARN_ON(align_offset + template[i].ilen > PAGE_SIZE))
+ 			goto out;
+ 
+ 		data = xbuf[0];
+ 		data += align_offset;
+ 		memcpy(data, template[i].input, template[i].ilen);
+ 
+ 		crypto_skcipher_clear_flags(tfm, ~0);
+ 		if (template[i].wk)
+ 			crypto_skcipher_set_flags(tfm,
+ 						  CRYPTO_TFM_REQ_WEAK_KEY);
+ 
+ 		ret = crypto_skcipher_setkey(tfm, template[i].key,
+ 					     template[i].klen);
+ 		if (template[i].fail == !ret) {
+ 			pr_err("alg: skcipher%s: setkey failed on test %d for %s: flags=%x\n",
+ 			       d, j, algo, crypto_skcipher_get_flags(tfm));
+ 			goto out;
+ 		} else if (ret)
++>>>>>>> 0fae0c1e1d79 (crypto: testmgr - fix !x==y confusion)
  			continue;
  
 -		sg_init_one(&sg[0], data, template[i].ilen);
 -		if (diff_dst) {
 -			data = xoutbuf[0];
 -			data += align_offset;
 -			sg_init_one(&sgout[0], data, template[i].ilen);
 -		}
 +		if (!(template[i].np) || (template[i].also_non_np)) {
 +			j++;
  
 -		skcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 -					   template[i].ilen, iv);
 -		ret = enc ? crypto_skcipher_encrypt(req) :
 -			    crypto_skcipher_decrypt(req);
 +			ret = -EINVAL;
 +			if (WARN_ON(template[i].ilen > PAGE_SIZE))
 +				goto out;
  
 -		switch (ret) {
 -		case 0:
 -			break;
 -		case -EINPROGRESS:
 -		case -EBUSY:
 -			wait_for_completion(&result.completion);
 -			reinit_completion(&result.completion);
 -			ret = result.err;
 -			if (!ret)
 -				break;
 -			/* fall through */
 -		default:
 -			pr_err("alg: skcipher%s: %s failed on test %d for %s: ret=%d\n",
 -			       d, e, j, algo, -ret);
 -			goto out;
 -		}
 +			data = xbuf[0];
 +			memcpy(data, template[i].input, template[i].ilen);
  
 -		q = data;
 -		if (memcmp(q, template[i].result, template[i].rlen)) {
 -			pr_err("alg: skcipher%s: Test %d failed (invalid result) on %s for %s\n",
 -			       d, j, e, algo);
 -			hexdump(q, template[i].rlen);
 -			ret = -EINVAL;
 -			goto out;
 -		}
 +			crypto_ablkcipher_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_ablkcipher_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
  
 -		if (template[i].iv_out &&
 -		    memcmp(iv, template[i].iv_out,
 -			   crypto_skcipher_ivsize(tfm))) {
 -			pr_err("alg: skcipher%s: Test %d failed (invalid output IV) on %s for %s\n",
 -			       d, j, e, algo);
 -			hexdump(iv, crypto_skcipher_ivsize(tfm));
 -			ret = -EINVAL;
 -			goto out;
 +			ret = crypto_ablkcipher_setkey(tfm, template[i].key,
 +						       template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: skcipher%s: setkey failed on test %d for %s: flags=%x\n",
 +				       d, j, algo,
 +				       crypto_ablkcipher_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
 +
 +			sg_init_one(&sg[0], data, template[i].ilen);
 +			if (diff_dst) {
 +				data = xoutbuf[0];
 +				sg_init_one(&sgout[0], data, template[i].ilen);
 +			}
 +
 +			ablkcipher_request_set_crypt(req, sg,
 +						     (diff_dst) ? sgout : sg,
 +						     template[i].ilen, iv);
 +			ret = enc ?
 +				crypto_ablkcipher_encrypt(req) :
 +				crypto_ablkcipher_decrypt(req);
 +
 +			switch (ret) {
 +			case 0:
 +				break;
 +			case -EINPROGRESS:
 +			case -EBUSY:
 +				wait_for_completion(&result.completion);
 +				INIT_COMPLETION(result.completion);
 +				ret = result.err;
 +				if (!ret)
 +					break;
 +				/* fall through */
 +			default:
 +				pr_err("alg: skcipher%s: %s failed on test %d for %s: ret=%d\n",
 +				       d, e, j, algo, -ret);
 +				goto out;
 +			}
 +
 +			q = data;
 +			if (memcmp(q, template[i].result, template[i].rlen)) {
 +				pr_err("alg: skcipher%s: Test %d failed on %s for %s\n",
 +				       d, j, e, algo);
 +				hexdump(q, template[i].rlen);
 +				ret = -EINVAL;
 +				goto out;
 +			}
  		}
  	}
  
@@@ -966,86 -1203,92 +1150,102 @@@
  		else
  			memset(iv, 0, MAX_IVLEN);
  
++<<<<<<< HEAD
 +		if (fips_enabled && template[i].fips_skip)
++=======
+ 		j++;
+ 		crypto_skcipher_clear_flags(tfm, ~0);
+ 		if (template[i].wk)
+ 			crypto_skcipher_set_flags(tfm,
+ 						  CRYPTO_TFM_REQ_WEAK_KEY);
+ 
+ 		ret = crypto_skcipher_setkey(tfm, template[i].key,
+ 					     template[i].klen);
+ 		if (template[i].fail == !ret) {
+ 			pr_err("alg: skcipher%s: setkey failed on chunk test %d for %s: flags=%x\n",
+ 			       d, j, algo, crypto_skcipher_get_flags(tfm));
+ 			goto out;
+ 		} else if (ret)
++>>>>>>> 0fae0c1e1d79 (crypto: testmgr - fix !x==y confusion)
  			continue;
  
 -		temp = 0;
 -		ret = -EINVAL;
 -		sg_init_table(sg, template[i].np);
 -		if (diff_dst)
 -			sg_init_table(sgout, template[i].np);
 -		for (k = 0; k < template[i].np; k++) {
 -			if (WARN_ON(offset_in_page(IDX[k]) +
 -				    template[i].tap[k] > PAGE_SIZE))
 -				goto out;
 +		if (template[i].np) {
 +			j++;
  
 -			q = xbuf[IDX[k] >> PAGE_SHIFT] + offset_in_page(IDX[k]);
 +			crypto_ablkcipher_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_ablkcipher_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
  
 -			memcpy(q, template[i].input + temp, template[i].tap[k]);
 +			ret = crypto_ablkcipher_setkey(tfm, template[i].key,
 +						       template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: skcipher%s: setkey failed on chunk test %d for %s: flags=%x\n",
 +				       d, j, algo,
 +				       crypto_ablkcipher_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
  
 -			if (offset_in_page(q) + template[i].tap[k] < PAGE_SIZE)
 -				q[template[i].tap[k]] = 0;
 +			temp = 0;
 +			ret = -EINVAL;
 +			sg_init_table(sg, template[i].np);
 +			if (diff_dst)
 +				sg_init_table(sgout, template[i].np);
 +			for (k = 0; k < template[i].np; k++) {
 +				if (WARN_ON(offset_in_page(IDX[k]) +
 +					    template[i].tap[k] > PAGE_SIZE))
 +					goto out;
  
 -			sg_set_buf(&sg[k], q, template[i].tap[k]);
 -			if (diff_dst) {
 -				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
 +				q = xbuf[IDX[k] >> PAGE_SHIFT] +
  				    offset_in_page(IDX[k]);
  
 -				sg_set_buf(&sgout[k], q, template[i].tap[k]);
 +				memcpy(q, template[i].input + temp,
 +				       template[i].tap[k]);
  
 -				memset(q, 0, template[i].tap[k]);
 -				if (offset_in_page(q) +
 -				    template[i].tap[k] < PAGE_SIZE)
 +				if (offset_in_page(q) + template[i].tap[k] <
 +				    PAGE_SIZE)
  					q[template[i].tap[k]] = 0;
 -			}
  
 -			temp += template[i].tap[k];
 -		}
 +				sg_set_buf(&sg[k], q, template[i].tap[k]);
 +				if (diff_dst) {
 +					q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
 +					    offset_in_page(IDX[k]);
  
 -		skcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 -					   template[i].ilen, iv);
 +					sg_set_buf(&sgout[k], q,
 +						   template[i].tap[k]);
  
 -		ret = enc ? crypto_skcipher_encrypt(req) :
 -			    crypto_skcipher_decrypt(req);
 +					memset(q, 0, template[i].tap[k]);
 +					if (offset_in_page(q) +
 +					    template[i].tap[k] < PAGE_SIZE)
 +						q[template[i].tap[k]] = 0;
 +				}
  
 -		switch (ret) {
 -		case 0:
 -			break;
 -		case -EINPROGRESS:
 -		case -EBUSY:
 -			wait_for_completion(&result.completion);
 -			reinit_completion(&result.completion);
 -			ret = result.err;
 -			if (!ret)
 -				break;
 -			/* fall through */
 -		default:
 -			pr_err("alg: skcipher%s: %s failed on chunk test %d for %s: ret=%d\n",
 -			       d, e, j, algo, -ret);
 -			goto out;
 -		}
 +				temp += template[i].tap[k];
 +			}
  
 -		temp = 0;
 -		ret = -EINVAL;
 -		for (k = 0; k < template[i].np; k++) {
 -			if (diff_dst)
 -				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
 -				    offset_in_page(IDX[k]);
 -			else
 -				q = xbuf[IDX[k] >> PAGE_SHIFT] +
 -				    offset_in_page(IDX[k]);
 +			ablkcipher_request_set_crypt(req, sg,
 +					(diff_dst) ? sgout : sg,
 +					template[i].ilen, iv);
  
 -			if (memcmp(q, template[i].result + temp,
 -				   template[i].tap[k])) {
 -				pr_err("alg: skcipher%s: Chunk test %d failed on %s at page %u for %s\n",
 -				       d, j, e, k, algo);
 -				hexdump(q, template[i].tap[k]);
 +			ret = enc ?
 +				crypto_ablkcipher_encrypt(req) :
 +				crypto_ablkcipher_decrypt(req);
 +
 +			switch (ret) {
 +			case 0:
 +				break;
 +			case -EINPROGRESS:
 +			case -EBUSY:
 +				wait_for_completion(&result.completion);
 +				INIT_COMPLETION(result.completion);
 +				ret = result.err;
 +				if (!ret)
 +					break;
 +				/* fall through */
 +			default:
 +				pr_err("alg: skcipher%s: %s failed on chunk test %d for %s: ret=%d\n",
 +				       d, e, j, algo, -ret);
  				goto out;
  			}
  
* Unmerged path crypto/testmgr.c
