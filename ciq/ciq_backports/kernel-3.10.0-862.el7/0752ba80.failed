locks: don't check for race with close when setting OFD lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jeff.layton@primarydata.com>
commit 0752ba807b04ccd69cb4bc8bbf829a80ee208a3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0752ba80.failed

We don't clean out OFD locks on close(), so there's no need to check
for a race with them here. They'll get cleaned out at the same time
that flock locks are.

	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Acked-by: "J. Bruce Fields" <bfields@fieldses.org>
(cherry picked from commit 0752ba807b04ccd69cb4bc8bbf829a80ee208a3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 20dcff562a1d,e72077d5a664..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -2137,22 -2219,27 +2137,42 @@@ again
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
- 	 * Attempt to detect a close/fcntl race and recover by
- 	 * releasing the lock that was just acquired.
+ 	 * Attempt to detect a close/fcntl race and recover by releasing the
+ 	 * lock that was just acquired. There is no need to do that when we're
+ 	 * unlocking though, or for OFD locks.
  	 */
++<<<<<<< HEAD
 +	/*
 +	 * we need that spin_lock here - it prevents reordering between
 +	 * update of inode->i_flock and check for it done in close().
 +	 * rcu_read_lock() wouldn't do.
 +	 */
 +	spin_lock(&current->files->file_lock);
 +	f = fcheck(fd);
 +	spin_unlock(&current->files->file_lock);
 +	if (!error && f != filp && flock.l_type != F_UNLCK) {
 +		flock.l_type = F_UNLCK;
 +		goto again;
++=======
+ 	if (!error && file_lock->fl_type != F_UNLCK &&
+ 	    !(file_lock->fl_flags & FL_OFDLCK)) {
+ 		/*
+ 		 * We need that spin_lock here - it prevents reordering between
+ 		 * update of i_flctx->flc_posix and check for it done in
+ 		 * close(). rcu_read_lock() wouldn't do.
+ 		 */
+ 		spin_lock(&current->files->file_lock);
+ 		f = fcheck(fd);
+ 		spin_unlock(&current->files->file_lock);
+ 		if (f != filp) {
+ 			file_lock->fl_type = F_UNLCK;
+ 			error = do_lock_file_wait(filp, cmd, file_lock);
+ 			WARN_ON_ONCE(error);
+ 			error = -EBADF;
+ 		}
++>>>>>>> 0752ba807b04 (locks: don't check for race with close when setting OFD lock)
  	}
 +
  out:
  	locks_free_lock(file_lock);
  	return error;
@@@ -2239,17 -2363,27 +2259,37 @@@ again
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
- 	 * Attempt to detect a close/fcntl race and recover by
- 	 * releasing the lock that was just acquired.
+ 	 * Attempt to detect a close/fcntl race and recover by releasing the
+ 	 * lock that was just acquired. There is no need to do that when we're
+ 	 * unlocking though, or for OFD locks.
  	 */
++<<<<<<< HEAD
 +	spin_lock(&current->files->file_lock);
 +	f = fcheck(fd);
 +	spin_unlock(&current->files->file_lock);
 +	if (!error && f != filp && flock.l_type != F_UNLCK) {
 +		flock.l_type = F_UNLCK;
 +		goto again;
++=======
+ 	if (!error && file_lock->fl_type != F_UNLCK &&
+ 	    !(file_lock->fl_flags & FL_OFDLCK)) {
+ 		/*
+ 		 * We need that spin_lock here - it prevents reordering between
+ 		 * update of i_flctx->flc_posix and check for it done in
+ 		 * close(). rcu_read_lock() wouldn't do.
+ 		 */
+ 		spin_lock(&current->files->file_lock);
+ 		f = fcheck(fd);
+ 		spin_unlock(&current->files->file_lock);
+ 		if (f != filp) {
+ 			file_lock->fl_type = F_UNLCK;
+ 			error = do_lock_file_wait(filp, cmd, file_lock);
+ 			WARN_ON_ONCE(error);
+ 			error = -EBADF;
+ 		}
++>>>>>>> 0752ba807b04 (locks: don't check for race with close when setting OFD lock)
  	}
 +
  out:
  	locks_free_lock(file_lock);
  	return error;
* Unmerged path fs/locks.c
