s390/pci: improve unreg_ioat error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] pci: improve unreg_ioat error handling (Hendrik Brueckner) [1486403]
Rebuild_FUZZ: 93.83%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 725708349172f00b86e2bac5c03de360b79aaf65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/72570834.failed

DMA tables are freed in zpci_dma_exit_device regardless of the return
code of zpci_unregister_ioat. This could lead to a use after free. On
the other hand during function hot-unplug, zpci_unregister_ioat will
always fail since the function is already gone.

So let zpci_unregister_ioat report success when the function is gone
but don't cleanup the dma table when a function could still have it
in access.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 725708349172f00b86e2bac5c03de360b79aaf65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci_dma.c
diff --cc arch/s390/pci/pci_dma.c
index 115b5e43452a,8eb1cc341dab..000000000000
--- a/arch/s390/pci/pci_dma.c
+++ b/arch/s390/pci/pci_dma.c
@@@ -505,10 -594,23 +505,25 @@@ out
  
  void zpci_dma_exit_device(struct zpci_dev *zdev)
  {
++<<<<<<< HEAD
 +	zpci_unregister_ioat(zdev, 0);
 +	dma_cleanup_tables(zdev);
++=======
+ 	/*
+ 	 * At this point, if the device is part of an IOMMU domain, this would
+ 	 * be a strong hint towards a bug in the IOMMU API (common) code and/or
+ 	 * simultaneous access via IOMMU and DMA API. So let's issue a warning.
+ 	 */
+ 	WARN_ON(zdev->s390_domain);
+ 
+ 	if (zpci_unregister_ioat(zdev, 0))
+ 		return;
+ 
+ 	dma_cleanup_tables(zdev->dma_table);
+ 	zdev->dma_table = NULL;
++>>>>>>> 725708349172 (s390/pci: improve unreg_ioat error handling)
  	vfree(zdev->iommu_bitmap);
  	zdev->iommu_bitmap = NULL;
 -	vfree(zdev->lazy_bitmap);
 -	zdev->lazy_bitmap = NULL;
 -
  	zdev->next_bit = 0;
  }
  
diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c
index 833b01424c9d..bb4c54614ba2 100644
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -170,19 +170,28 @@ static int mod_pci(struct zpci_dev *zdev, int fn, u8 dmaas, struct mod_pci_args
 int zpci_register_ioat(struct zpci_dev *zdev, u8 dmaas,
 		       u64 base, u64 limit, u64 iota)
 {
-	struct mod_pci_args args = { base, limit, iota, 0 };
+	u64 req = ZPCI_CREATE_REQ(zdev->fh, dmaas, ZPCI_MOD_FC_REG_IOAT);
+	struct zpci_fib fib = {0};
+	u8 status;
 
 	WARN_ON_ONCE(iota & 0x3fff);
-	args.iota |= ZPCI_IOTA_RTTO_FLAG;
-	return mod_pci(zdev, ZPCI_MOD_FC_REG_IOAT, dmaas, &args);
+	fib.pba = base;
+	fib.pal = limit;
+	fib.iota = iota | ZPCI_IOTA_RTTO_FLAG;
+	return zpci_mod_fc(req, &fib, &status) ? -EIO : 0;
 }
 
 /* Modify PCI: Unregister I/O address translation parameters */
 int zpci_unregister_ioat(struct zpci_dev *zdev, u8 dmaas)
 {
-	struct mod_pci_args args = { 0, 0, 0, 0 };
+	u64 req = ZPCI_CREATE_REQ(zdev->fh, dmaas, ZPCI_MOD_FC_DEREG_IOAT);
+	struct zpci_fib fib = {0};
+	u8 cc, status;
 
-	return mod_pci(zdev, ZPCI_MOD_FC_DEREG_IOAT, dmaas, &args);
+	cc = zpci_mod_fc(req, &fib, &status);
+	if (cc == 3) /* Function already gone. */
+		cc = 0;
+	return cc ? -EIO : 0;
 }
 
 /* Modify PCI: Unregister adapter interruptions */
* Unmerged path arch/s390/pci/pci_dma.c
