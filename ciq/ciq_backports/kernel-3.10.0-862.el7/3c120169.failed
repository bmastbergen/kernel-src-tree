dm table: replace while loops with for loops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 3c12016910061c2a19d985fba7f7dec19d6a3a09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3c120169.failed

Also remove some unnecessary use of uninitialized_var().

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 3c12016910061c2a19d985fba7f7dec19d6a3a09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
diff --cc drivers/md/dm-table.c
index b394f2714da2,7fb29db478cd..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -634,14 -627,7 +634,18 @@@ static int validate_hardware_logical_bl
  
  	struct dm_target *uninitialized_var(ti);
  	struct queue_limits ti_limits;
++<<<<<<< HEAD
 +	struct queue_limits_aux ti_limits_aux;
 +	unsigned i = 0;
++=======
+ 	unsigned i;
++>>>>>>> 3c1201691006 (dm table: replace while loops with for loops)
 +
 +	/* 
 +	 * Initialize limits_aux pointer to stack queue_limits_aux
 +	 * members.
 +	 */
 +	ti_limits.limits_aux = &ti_limits_aux;
  
  	/*
  	 * Check each entry in the table in turn.
@@@ -1346,23 -1345,16 +1351,31 @@@ bool dm_table_has_no_data_devices(struc
  int dm_calculate_queue_limits(struct dm_table *table,
  			      struct queue_limits *limits)
  {
- 	struct dm_target *uninitialized_var(ti);
+ 	struct dm_target *ti;
  	struct queue_limits ti_limits;
++<<<<<<< HEAD
 +	struct queue_limits_aux ti_limits_aux;
 +	unsigned i = 0;
 +
 +	blk_set_stacking_limits(limits);
 +
 +	/* 
 +	 * Initialize limits_aux pointer to stack queue_limits_aux
 +	 * members.
 +	 */
 +	ti_limits.limits_aux = &ti_limits_aux;
 +
 +	while (i < dm_table_get_num_targets(table)) {
++=======
+ 	unsigned i;
+ 
+ 	blk_set_stacking_limits(limits);
+ 
+ 	for (i = 0; i < dm_table_get_num_targets(table); i++) {
++>>>>>>> 3c1201691006 (dm table: replace while loops with for loops)
  		blk_set_stacking_limits(&ti_limits);
  
- 		ti = dm_table_get_target(table, i++);
+ 		ti = dm_table_get_target(table, i);
  
  		if (!ti->type->iterate_devices)
  			goto combine_limits;
@@@ -1431,16 -1427,16 +1444,16 @@@ static void dm_table_set_integrity(stru
  static int device_flush_capable(struct dm_target *ti, struct dm_dev *dev,
  				sector_t start, sector_t len, void *data)
  {
 -	unsigned long flush = (unsigned long) data;
 +	unsigned flush = (*(unsigned *)data);
  	struct request_queue *q = bdev_get_queue(dev->bdev);
  
 -	return q && (q->queue_flags & flush);
 +	return q && (q->flush_flags & flush);
  }
  
 -static bool dm_table_supports_flush(struct dm_table *t, unsigned long flush)
 +static bool dm_table_supports_flush(struct dm_table *t, unsigned flush)
  {
  	struct dm_target *ti;
- 	unsigned i = 0;
+ 	unsigned i;
  
  	/*
  	 * Require at least one underlying device to support flushes.
* Unmerged path drivers/md/dm-table.c
