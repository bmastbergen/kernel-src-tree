netvsc: change logic for change mtu and set_queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit ea383bf146be1e190f1d696e7db060afa8c93c31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ea383bf1.failed

Use device detach/attach to ensure that no packets are handed
to device during state changes. Call rndis_filter_open/close
directly as part of later VF related changes.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ea383bf146be1e190f1d696e7db060afa8c93c31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,5d541a1462c2..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -195,6 -199,8 +195,11 @@@ int netvsc_recv_callback(struct net_dev
  			 const struct ndis_tcp_ip_checksum_info *csum_info,
  			 const struct ndis_pkt_8021q_info *vlan);
  void netvsc_channel_cb(void *context);
++<<<<<<< HEAD
++=======
+ int netvsc_poll(struct napi_struct *napi, int budget);
+ bool rndis_filter_opened(const struct netvsc_device *nvdev);
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
  int rndis_filter_open(struct netvsc_device *nvdev);
  int rndis_filter_close(struct netvsc_device *nvdev);
  int rndis_filter_device_add(struct hv_device *dev,
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,82e41c056e53..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -741,84 -740,44 +741,104 @@@ static int netvsc_set_channels(struct n
  {
  	struct net_device_context *net_device_ctx = netdev_priv(net);
  	struct hv_device *dev = net_device_ctx->device_ctx;
++<<<<<<< HEAD
 +	struct netvsc_device *nvdev = net_device_ctx->nvdev;
 +	struct netvsc_device_info device_info;
 +	u32 num_chn;
 +	u32 max_chn;
 +	int ret = 0;
 +	bool recovering = false;
++=======
+ 	struct netvsc_device *nvdev = rtnl_dereference(net_device_ctx->nvdev);
+ 	unsigned int count = channels->combined_count;
+ 	bool was_opened;
+ 	int ret;
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
  
 -	/* We do not support separate count for rx, tx, or other */
 -	if (count == 0 ||
 -	    channels->rx_count || channels->tx_count || channels->other_count)
 -		return -EINVAL;
 -
 -	if (count > net->num_tx_queues || count > VRSS_CHANNEL_MAX)
 -		return -EINVAL;
 -
 -	if (!nvdev || nvdev->destroy)
 +	if (net_device_ctx->start_remove || !nvdev || nvdev->destroy)
  		return -ENODEV;
  
 -	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5)
 -		return -EINVAL;
 +	num_chn = nvdev->num_chn;
 +	max_chn = min_t(u32, nvdev->max_chn, num_online_cpus());
  
 -	if (count > nvdev->max_chn)
 +	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5) {
 +		pr_info("vRSS unsupported before NVSP Version 5\n");
  		return -EINVAL;
++<<<<<<< HEAD
 +	}
++=======
+ 
+ 	was_opened = rndis_filter_opened(nvdev);
+ 	if (was_opened)
+ 		rndis_filter_close(nvdev);
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
 +
 +	/* We do not support rx, tx, or other */
 +	if (!channels ||
 +	    channels->rx_count ||
 +	    channels->tx_count ||
 +	    channels->other_count ||
 +	    (channels->combined_count < 1))
 +		return -EINVAL;
  
 -	rndis_filter_device_remove(dev, nvdev);
 -
 -	ret = netvsc_set_queues(net, dev, count);
 -	if (ret == 0)
 -		nvdev->num_chn = count;
 -	else
 -		netvsc_set_queues(net, dev, nvdev->num_chn);
 +	if (channels->combined_count > max_chn) {
 +		pr_info("combined channels too high, using %d\n", max_chn);
 +		channels->combined_count = max_chn;
 +	}
  
++<<<<<<< HEAD
 +	ret = netvsc_close(net);
 +	if (ret)
 +		goto out;
++=======
+ 	nvdev = rtnl_dereference(net_device_ctx->nvdev);
+ 	if (was_opened)
+ 		rndis_filter_open(nvdev);
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
 +
 + do_set:
 +	net_device_ctx->start_remove = true;
 +	rndis_filter_device_remove(dev);
  
 +	nvdev->num_chn = channels->combined_count;
 +
 +	memset(&device_info, 0, sizeof(device_info));
 +	device_info.num_chn = nvdev->num_chn; /* passed to RNDIS */
 +	device_info.ring_size = ring_size;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
 +
 +	ret = rndis_filter_device_add(dev, &device_info);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 +	nvdev = net_device_ctx->nvdev;
 +
 +	ret = netif_set_real_num_tx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set tx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 +	ret = netif_set_real_num_rx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set rx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 + out:
 +	netvsc_open(net);
 +	net_device_ctx->start_remove = false;
  	/* We may have missed link change notifications */
  	net_device_ctx->last_reconfig = 0;
  	schedule_delayed_work(&net_device_ctx->dwork, 0);
@@@ -893,81 -843,85 +913,100 @@@ static int netvsc_set_link_ksettings(st
  static int netvsc_change_mtu(struct net_device *ndev, int mtu)
  {
  	struct net_device_context *ndevctx = netdev_priv(ndev);
 -	struct netvsc_device *nvdev = rtnl_dereference(ndevctx->nvdev);
 +	struct netvsc_device *nvdev = ndevctx->nvdev;
  	struct hv_device *hdev = ndevctx->device_ctx;
  	struct netvsc_device_info device_info;
++<<<<<<< HEAD
 +	int limit = ETH_DATA_LEN;
 +	u32 num_chn;
 +	int ret = 0;
++=======
+ 	bool was_opened;
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
  
 -	if (!nvdev || nvdev->destroy)
 +	if (ndevctx->start_remove || !nvdev || nvdev->destroy)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	if (nvdev->nvsp_version >= NVSP_PROTOCOL_VERSION_2)
 +		limit = NETVSC_MTU - ETH_HLEN;
++=======
+ 	netif_device_detach(ndev);
+ 	was_opened = rndis_filter_opened(nvdev);
+ 	if (was_opened)
+ 		rndis_filter_close(nvdev);
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
  
 -	memset(&device_info, 0, sizeof(device_info));
 -	device_info.ring_size = ring_size;
 -	device_info.num_chn = nvdev->num_chn;
 -	device_info.max_num_vrss_chns = nvdev->num_chn;
 +	if (mtu < NETVSC_MTU_MIN || mtu > limit)
 +		return -EINVAL;
  
 -	rndis_filter_device_remove(hdev, nvdev);
 +	ret = netvsc_close(ndev);
 +	if (ret)
 +		goto out;
  
 -	/* 'nvdev' has been freed in rndis_filter_device_remove() ->
 -	 * netvsc_device_remove () -> free_netvsc_device().
 -	 * We mustn't access it before it's re-created in
 -	 * rndis_filter_device_add() -> netvsc_device_add().
 -	 */
 +	num_chn = nvdev->num_chn;
 +
 +	ndevctx->start_remove = true;
 +	rndis_filter_device_remove(hdev);
  
  	ndev->mtu = mtu;
  
 +	memset(&device_info, 0, sizeof(device_info));
 +	device_info.ring_size = ring_size;
 +	device_info.num_chn = num_chn;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
  	rndis_filter_device_add(hdev, &device_info);
+ 	nvdev = rtnl_dereference(ndevctx->nvdev);
  
++<<<<<<< HEAD
 +out:
 +	netvsc_open(ndev);
 +	ndevctx->start_remove = false;
++=======
+ 	if (was_opened)
+ 		rndis_filter_open(nvdev);
+ 
+ 	netif_device_attach(ndev);
++>>>>>>> ea383bf146be (netvsc: change logic for change mtu and set_queues)
  
  	/* We may have missed link change notifications */
  	schedule_delayed_work(&ndevctx->dwork, 0);
  
- 	return ret;
+ 	return 0;
  }
  
 -static void netvsc_get_stats64(struct net_device *net,
 -			       struct rtnl_link_stats64 *t)
 +static struct rtnl_link_stats64 *netvsc_get_stats64(struct net_device *net,
 +						    struct rtnl_link_stats64 *t)
  {
  	struct net_device_context *ndev_ctx = netdev_priv(net);
 -	struct netvsc_device *nvdev = rcu_dereference_rtnl(ndev_ctx->nvdev);
 -	int i;
 -
 -	if (!nvdev)
 -		return;
 -
 -	for (i = 0; i < nvdev->num_chn; i++) {
 -		const struct netvsc_channel *nvchan = &nvdev->chan_table[i];
 -		const struct netvsc_stats *stats;
 -		u64 packets, bytes, multicast;
 +	int cpu;
 +
 +	for_each_possible_cpu(cpu) {
 +		struct netvsc_stats *tx_stats = per_cpu_ptr(ndev_ctx->tx_stats,
 +							    cpu);
 +		struct netvsc_stats *rx_stats = per_cpu_ptr(ndev_ctx->rx_stats,
 +							    cpu);
 +		u64 tx_packets, tx_bytes, rx_packets, rx_bytes, rx_multicast;
  		unsigned int start;
  
 -		stats = &nvchan->tx_stats;
  		do {
 -			start = u64_stats_fetch_begin_irq(&stats->syncp);
 -			packets = stats->packets;
 -			bytes = stats->bytes;
 -		} while (u64_stats_fetch_retry_irq(&stats->syncp, start));
 -
 -		t->tx_bytes	+= bytes;
 -		t->tx_packets	+= packets;
 +			start = u64_stats_fetch_begin_irq(&tx_stats->syncp);
 +			tx_packets = tx_stats->packets;
 +			tx_bytes = tx_stats->bytes;
 +		} while (u64_stats_fetch_retry_irq(&tx_stats->syncp, start));
  
 -		stats = &nvchan->rx_stats;
  		do {
 -			start = u64_stats_fetch_begin_irq(&stats->syncp);
 -			packets = stats->packets;
 -			bytes = stats->bytes;
 -			multicast = stats->multicast + stats->broadcast;
 -		} while (u64_stats_fetch_retry_irq(&stats->syncp, start));
 -
 -		t->rx_bytes	+= bytes;
 -		t->rx_packets	+= packets;
 -		t->multicast	+= multicast;
 +			start = u64_stats_fetch_begin_irq(&rx_stats->syncp);
 +			rx_packets = rx_stats->packets;
 +			rx_bytes = rx_stats->bytes;
 +			rx_multicast = rx_stats->multicast + rx_stats->broadcast;
 +		} while (u64_stats_fetch_retry_irq(&rx_stats->syncp, start));
 +
 +		t->tx_bytes	+= tx_bytes;
 +		t->tx_packets	+= tx_packets;
 +		t->rx_bytes	+= rx_bytes;
 +		t->rx_packets	+= rx_packets;
 +		t->multicast	+= rx_multicast;
  	}
  
  	t->tx_dropped	= net->stats.tx_dropped;
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc_drv.c
diff --git a/drivers/net/hyperv/rndis_filter.c b/drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92..a9af6043c868 100644
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@ -1174,3 +1174,8 @@ int rndis_filter_close(struct netvsc_device *nvdev)
 
 	return rndis_filter_close_device(nvdev->extension);
 }
+
+bool rndis_filter_opened(const struct netvsc_device *nvdev)
+{
+	return atomic_read(&nvdev->open_cnt) > 0;
+}
