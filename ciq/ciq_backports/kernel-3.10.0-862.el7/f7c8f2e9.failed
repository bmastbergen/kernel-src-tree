IB/uverbs: Make use of ib_modify_qp variant to avoid resolving DMAC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Parav Pandit <parav@mellanox.com>
commit f7c8f2e9ddc71db0ae344f3ffb19df03ef32b719
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f7c8f2e9.failed

This patch makes use of IB core's ib_modify_qp_with_udata function that
also resolves the DMAC and handles udata.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f7c8f2e9ddc71db0ae344f3ffb19df03ef32b719)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index e8bf8301dd79,3f55d18a3791..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -2379,62 -1963,55 +2379,72 @@@ static int modify_qp(struct ib_uverbs_f
  	attr->alt_timeout	  = cmd->base.alt_timeout;
  	attr->rate_limit	  = cmd->rate_limit;
  
 -	attr->ah_attr.type = rdma_ah_find_type(qp->device,
 -					       cmd->base.dest.port_num);
  	if (cmd->base.dest.is_global) {
 -		rdma_ah_set_grh(&attr->ah_attr, NULL,
 -				cmd->base.dest.flow_label,
 -				cmd->base.dest.sgid_index,
 -				cmd->base.dest.hop_limit,
 -				cmd->base.dest.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr->ah_attr, cmd->base.dest.dgid);
 +		memcpy(attr->ah_attr.grh.dgid.raw, cmd->base.dest.dgid, 16);
 +		attr->ah_attr.grh.flow_label	= cmd->base.dest.flow_label;
 +		attr->ah_attr.grh.sgid_index	= cmd->base.dest.sgid_index;
 +		attr->ah_attr.grh.hop_limit	= cmd->base.dest.hop_limit;
 +		attr->ah_attr.grh.traffic_class	= cmd->base.dest.traffic_class;
 +		attr->ah_attr.ah_flags		= IB_AH_GRH;
  	} else {
 -		rdma_ah_set_ah_flags(&attr->ah_attr, 0);
 +		attr->ah_attr.ah_flags = 0;
  	}
 -	rdma_ah_set_dlid(&attr->ah_attr, cmd->base.dest.dlid);
 -	rdma_ah_set_sl(&attr->ah_attr, cmd->base.dest.sl);
 -	rdma_ah_set_path_bits(&attr->ah_attr, cmd->base.dest.src_path_bits);
 -	rdma_ah_set_static_rate(&attr->ah_attr, cmd->base.dest.static_rate);
 -	rdma_ah_set_port_num(&attr->ah_attr,
 -			     cmd->base.dest.port_num);
 +	attr->ah_attr.dlid		= cmd->base.dest.dlid;
 +	attr->ah_attr.sl		= cmd->base.dest.sl;
 +	attr->ah_attr.src_path_bits	= cmd->base.dest.src_path_bits;
 +	attr->ah_attr.static_rate	= cmd->base.dest.static_rate;
 +	attr->ah_attr.port_num		= cmd->base.dest.port_num;
  
 -	attr->alt_ah_attr.type = rdma_ah_find_type(qp->device,
 -						   cmd->base.dest.port_num);
  	if (cmd->base.alt_dest.is_global) {
 -		rdma_ah_set_grh(&attr->alt_ah_attr, NULL,
 -				cmd->base.alt_dest.flow_label,
 -				cmd->base.alt_dest.sgid_index,
 -				cmd->base.alt_dest.hop_limit,
 -				cmd->base.alt_dest.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr->alt_ah_attr,
 -				     cmd->base.alt_dest.dgid);
 +		memcpy(attr->alt_ah_attr.grh.dgid.raw,
 +		       cmd->base.alt_dest.dgid, 16);
 +		attr->alt_ah_attr.grh.flow_label =
 +				cmd->base.alt_dest.flow_label;
 +		attr->alt_ah_attr.grh.sgid_index =
 +				cmd->base.alt_dest.sgid_index;
 +		attr->alt_ah_attr.grh.hop_limit =
 +				cmd->base.alt_dest.hop_limit;
 +		attr->alt_ah_attr.grh.traffic_class =
 +				cmd->base.alt_dest.traffic_class;
 +		attr->alt_ah_attr.ah_flags = IB_AH_GRH;
 +	} else {
 +		attr->alt_ah_attr.ah_flags = 0;
 +	}
 +	attr->alt_ah_attr.dlid		    = cmd->base.alt_dest.dlid;
 +	attr->alt_ah_attr.sl		    = cmd->base.alt_dest.sl;
 +	attr->alt_ah_attr.src_path_bits	    = cmd->base.alt_dest.src_path_bits;
 +	attr->alt_ah_attr.static_rate	    = cmd->base.alt_dest.static_rate;
 +	attr->alt_ah_attr.port_num	    = cmd->base.alt_dest.port_num;
 +
++<<<<<<< HEAD
 +	if (qp->real_qp == qp) {
 +		if (cmd->base.attr_mask & IB_QP_AV) {
 +			ret = ib_resolve_eth_dmac(qp->device, &attr->ah_attr);
 +			if (ret)
 +				goto release_qp;
 +		}
 +		ret = qp->device->modify_qp(qp, attr,
 +					    modify_qp_mask(qp->qp_type,
 +							   cmd->base.attr_mask),
 +					    udata);
  	} else {
 -		rdma_ah_set_ah_flags(&attr->alt_ah_attr, 0);
 +		ret = ib_modify_qp(qp, attr,
 +				   modify_qp_mask(qp->qp_type,
 +						  cmd->base.attr_mask));
  	}
  
 -	rdma_ah_set_dlid(&attr->alt_ah_attr, cmd->base.alt_dest.dlid);
 -	rdma_ah_set_sl(&attr->alt_ah_attr, cmd->base.alt_dest.sl);
 -	rdma_ah_set_path_bits(&attr->alt_ah_attr,
 -			      cmd->base.alt_dest.src_path_bits);
 -	rdma_ah_set_static_rate(&attr->alt_ah_attr,
 -				cmd->base.alt_dest.static_rate);
 -	rdma_ah_set_port_num(&attr->alt_ah_attr,
 -			     cmd->base.alt_dest.port_num);
 +release_qp:
 +	put_qp_read(qp);
  
++=======
+ 	ret = ib_modify_qp_with_udata(qp, attr,
+ 				      modify_qp_mask(qp->qp_type,
+ 						     cmd->base.attr_mask),
+ 				      udata);
+ 
+ release_qp:
+ 	uobj_put_obj_read(qp);
++>>>>>>> f7c8f2e9ddc7 (IB/uverbs: Make use of ib_modify_qp variant to avoid resolving DMAC)
  out:
  	kfree(attr);
  
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
