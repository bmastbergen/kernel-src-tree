s390/diag: add diag26c support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] diag: add diag26c support (Hendrik Brueckner) [1479463]
Rebuild_FUZZ: 90.91%
commit-author Julian Wiedmann <jwi@linux.vnet.ibm.com>
commit 1b030478166cdbdffe9bcffadc32558b4b511869
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1b030478.failed

Implement support for the hypervisor diagnose 0x26c
('Access Certain System Information').
It passes a request buffer and a subfunction code, and receives
a response buffer and a return code.

Also add the scaffolding for the 'MAC Services' subfunction.
It may be used by network devices to obtain a hypervisor-managed
MAC address.

	Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
	Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1b030478166cdbdffe9bcffadc32558b4b511869)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/diag.h
#	arch/s390/kernel/diag.c
diff --cc arch/s390/include/asm/diag.h
index 7e91c58072e2,88162bb5c190..000000000000
--- a/arch/s390/include/asm/diag.h
+++ b/arch/s390/include/asm/diag.h
@@@ -8,6 -8,36 +8,39 @@@
  #ifndef _ASM_S390_DIAG_H
  #define _ASM_S390_DIAG_H
  
++<<<<<<< HEAD
++=======
+ #include <linux/if_ether.h>
+ #include <linux/percpu.h>
+ 
+ enum diag_stat_enum {
+ 	DIAG_STAT_X008,
+ 	DIAG_STAT_X00C,
+ 	DIAG_STAT_X010,
+ 	DIAG_STAT_X014,
+ 	DIAG_STAT_X044,
+ 	DIAG_STAT_X064,
+ 	DIAG_STAT_X09C,
+ 	DIAG_STAT_X0DC,
+ 	DIAG_STAT_X204,
+ 	DIAG_STAT_X210,
+ 	DIAG_STAT_X224,
+ 	DIAG_STAT_X250,
+ 	DIAG_STAT_X258,
+ 	DIAG_STAT_X26C,
+ 	DIAG_STAT_X288,
+ 	DIAG_STAT_X2C4,
+ 	DIAG_STAT_X2FC,
+ 	DIAG_STAT_X304,
+ 	DIAG_STAT_X308,
+ 	DIAG_STAT_X500,
+ 	NR_DIAG_STAT
+ };
+ 
+ void diag_stat_inc(enum diag_stat_enum nr);
+ void diag_stat_inc_norecursion(enum diag_stat_enum nr);
+ 
++>>>>>>> 1b030478166c (s390/diag: add diag26c support)
  /*
   * Diagnose 10: Release page range
   */
@@@ -49,4 -80,177 +82,180 @@@ struct diag210 
  
  extern int diag210(struct diag210 *addr);
  
++<<<<<<< HEAD
++=======
+ /* bit is set in flags, when physical cpu info is included in diag 204 data */
+ #define DIAG204_LPAR_PHYS_FLG 0x80
+ #define DIAG204_LPAR_NAME_LEN 8		/* lpar name len in diag 204 data */
+ #define DIAG204_CPU_NAME_LEN 16		/* type name len of cpus in diag224 name table */
+ 
+ /* diag 204 subcodes */
+ enum diag204_sc {
+ 	DIAG204_SUBC_STIB4 = 4,
+ 	DIAG204_SUBC_RSI = 5,
+ 	DIAG204_SUBC_STIB6 = 6,
+ 	DIAG204_SUBC_STIB7 = 7
+ };
+ 
+ /* The two available diag 204 data formats */
+ enum diag204_format {
+ 	DIAG204_INFO_SIMPLE = 0,
+ 	DIAG204_INFO_EXT = 0x00010000
+ };
+ 
+ enum diag204_cpu_flags {
+ 	DIAG204_CPU_ONLINE = 0x20,
+ 	DIAG204_CPU_CAPPED = 0x40,
+ };
+ 
+ struct diag204_info_blk_hdr {
+ 	__u8  npar;
+ 	__u8  flags;
+ 	__u16 tslice;
+ 	__u16 phys_cpus;
+ 	__u16 this_part;
+ 	__u64 curtod;
+ } __packed;
+ 
+ struct diag204_x_info_blk_hdr {
+ 	__u8  npar;
+ 	__u8  flags;
+ 	__u16 tslice;
+ 	__u16 phys_cpus;
+ 	__u16 this_part;
+ 	__u64 curtod1;
+ 	__u64 curtod2;
+ 	char reserved[40];
+ } __packed;
+ 
+ struct diag204_part_hdr {
+ 	__u8 pn;
+ 	__u8 cpus;
+ 	char reserved[6];
+ 	char part_name[DIAG204_LPAR_NAME_LEN];
+ } __packed;
+ 
+ struct diag204_x_part_hdr {
+ 	__u8  pn;
+ 	__u8  cpus;
+ 	__u8  rcpus;
+ 	__u8  pflag;
+ 	__u32 mlu;
+ 	char  part_name[DIAG204_LPAR_NAME_LEN];
+ 	char  lpc_name[8];
+ 	char  os_name[8];
+ 	__u64 online_cs;
+ 	__u64 online_es;
+ 	__u8  upid;
+ 	__u8  reserved:3;
+ 	__u8  mtid:5;
+ 	char  reserved1[2];
+ 	__u32 group_mlu;
+ 	char  group_name[8];
+ 	char  hardware_group_name[8];
+ 	char  reserved2[24];
+ } __packed;
+ 
+ struct diag204_cpu_info {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	__u8  cflag;
+ 	__u16 weight;
+ 	__u64 acc_time;
+ 	__u64 lp_time;
+ } __packed;
+ 
+ struct diag204_x_cpu_info {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	__u8  cflag;
+ 	__u16 weight;
+ 	__u64 acc_time;
+ 	__u64 lp_time;
+ 	__u16 min_weight;
+ 	__u16 cur_weight;
+ 	__u16 max_weight;
+ 	char  reseved2[2];
+ 	__u64 online_time;
+ 	__u64 wait_time;
+ 	__u32 pma_weight;
+ 	__u32 polar_weight;
+ 	__u32 cpu_type_cap;
+ 	__u32 group_cpu_type_cap;
+ 	char  reserved3[32];
+ } __packed;
+ 
+ struct diag204_phys_hdr {
+ 	char reserved1[1];
+ 	__u8 cpus;
+ 	char reserved2[6];
+ 	char mgm_name[8];
+ } __packed;
+ 
+ struct diag204_x_phys_hdr {
+ 	char reserved1[1];
+ 	__u8 cpus;
+ 	char reserved2[6];
+ 	char mgm_name[8];
+ 	char reserved3[80];
+ } __packed;
+ 
+ struct diag204_phys_cpu {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	char  reserved2[3];
+ 	__u64 mgm_time;
+ 	char  reserved3[8];
+ } __packed;
+ 
+ struct diag204_x_phys_cpu {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	char  reserved2[1];
+ 	__u16 weight;
+ 	__u64 mgm_time;
+ 	char  reserved3[80];
+ } __packed;
+ 
+ struct diag204_x_part_block {
+ 	struct diag204_x_part_hdr hdr;
+ 	struct diag204_x_cpu_info cpus[];
+ } __packed;
+ 
+ struct diag204_x_phys_block {
+ 	struct diag204_x_phys_hdr hdr;
+ 	struct diag204_x_phys_cpu cpus[];
+ } __packed;
+ 
+ enum diag26c_sc {
+ 	DIAG26C_MAC_SERVICES = 0x00000030
+ };
+ 
+ enum diag26c_version {
+ 	DIAG26C_VERSION2 = 0x00000002	/* z/VM 5.4.0 */
+ };
+ 
+ #define DIAG26C_GET_MAC	0x0000
+ struct diag26c_mac_req {
+ 	u32	resp_buf_len;
+ 	u32	resp_version;
+ 	u16	op_code;
+ 	u16	devno;
+ 	u8	res[4];
+ };
+ 
+ struct diag26c_mac_resp {
+ 	u32	version;
+ 	u8	mac[ETH_ALEN];
+ 	u8	res[2];
+ } __aligned(8);
+ 
+ int diag204(unsigned long subcode, unsigned long size, void *addr);
+ int diag224(void *ptr);
+ int diag26c(void *req, void *resp, enum diag26c_sc subcode);
++>>>>>>> 1b030478166c (s390/diag: add diag26c support)
  #endif /* _ASM_S390_DIAG_H */
diff --cc arch/s390/kernel/diag.c
index 8237fc07ac79,349914571772..000000000000
--- a/arch/s390/kernel/diag.c
+++ b/arch/s390/kernel/diag.c
@@@ -5,8 -5,134 +5,133 @@@
   * Author(s): Michael Holzheu <holzheu@de.ibm.com>
   */
  
 -#include <linux/export.h>
 -#include <linux/init.h>
 -#include <linux/cpu.h>
 -#include <linux/seq_file.h>
 -#include <linux/debugfs.h>
 +#include <linux/module.h>
  #include <asm/diag.h>
++<<<<<<< HEAD
++=======
+ #include <asm/trace/diag.h>
+ 
+ struct diag_stat {
+ 	unsigned int counter[NR_DIAG_STAT];
+ };
+ 
+ static DEFINE_PER_CPU(struct diag_stat, diag_stat);
+ 
+ struct diag_desc {
+ 	int code;
+ 	char *name;
+ };
+ 
+ static const struct diag_desc diag_map[NR_DIAG_STAT] = {
+ 	[DIAG_STAT_X008] = { .code = 0x008, .name = "Console Function" },
+ 	[DIAG_STAT_X00C] = { .code = 0x00c, .name = "Pseudo Timer" },
+ 	[DIAG_STAT_X010] = { .code = 0x010, .name = "Release Pages" },
+ 	[DIAG_STAT_X014] = { .code = 0x014, .name = "Spool File Services" },
+ 	[DIAG_STAT_X044] = { .code = 0x044, .name = "Voluntary Timeslice End" },
+ 	[DIAG_STAT_X064] = { .code = 0x064, .name = "NSS Manipulation" },
+ 	[DIAG_STAT_X09C] = { .code = 0x09c, .name = "Relinquish Timeslice" },
+ 	[DIAG_STAT_X0DC] = { .code = 0x0dc, .name = "Appldata Control" },
+ 	[DIAG_STAT_X204] = { .code = 0x204, .name = "Logical-CPU Utilization" },
+ 	[DIAG_STAT_X210] = { .code = 0x210, .name = "Device Information" },
+ 	[DIAG_STAT_X224] = { .code = 0x224, .name = "EBCDIC-Name Table" },
+ 	[DIAG_STAT_X250] = { .code = 0x250, .name = "Block I/O" },
+ 	[DIAG_STAT_X258] = { .code = 0x258, .name = "Page-Reference Services" },
+ 	[DIAG_STAT_X26C] = { .code = 0x26c, .name = "Certain System Information" },
+ 	[DIAG_STAT_X288] = { .code = 0x288, .name = "Time Bomb" },
+ 	[DIAG_STAT_X2C4] = { .code = 0x2c4, .name = "FTP Services" },
+ 	[DIAG_STAT_X2FC] = { .code = 0x2fc, .name = "Guest Performance Data" },
+ 	[DIAG_STAT_X304] = { .code = 0x304, .name = "Partition-Resource Service" },
+ 	[DIAG_STAT_X308] = { .code = 0x308, .name = "List-Directed IPL" },
+ 	[DIAG_STAT_X500] = { .code = 0x500, .name = "Virtio Service" },
+ };
+ 
+ static int show_diag_stat(struct seq_file *m, void *v)
+ {
+ 	struct diag_stat *stat;
+ 	unsigned long n = (unsigned long) v - 1;
+ 	int cpu, prec, tmp;
+ 
+ 	get_online_cpus();
+ 	if (n == 0) {
+ 		seq_puts(m, "         ");
+ 
+ 		for_each_online_cpu(cpu) {
+ 			prec = 10;
+ 			for (tmp = 10; cpu >= tmp; tmp *= 10)
+ 				prec--;
+ 			seq_printf(m, "%*s%d", prec, "CPU", cpu);
+ 		}
+ 		seq_putc(m, '\n');
+ 	} else if (n <= NR_DIAG_STAT) {
+ 		seq_printf(m, "diag %03x:", diag_map[n-1].code);
+ 		for_each_online_cpu(cpu) {
+ 			stat = &per_cpu(diag_stat, cpu);
+ 			seq_printf(m, " %10u", stat->counter[n-1]);
+ 		}
+ 		seq_printf(m, "    %s\n", diag_map[n-1].name);
+ 	}
+ 	put_online_cpus();
+ 	return 0;
+ }
+ 
+ static void *show_diag_stat_start(struct seq_file *m, loff_t *pos)
+ {
+ 	return *pos <= nr_cpu_ids ? (void *)((unsigned long) *pos + 1) : NULL;
+ }
+ 
+ static void *show_diag_stat_next(struct seq_file *m, void *v, loff_t *pos)
+ {
+ 	++*pos;
+ 	return show_diag_stat_start(m, pos);
+ }
+ 
+ static void show_diag_stat_stop(struct seq_file *m, void *v)
+ {
+ }
+ 
+ static const struct seq_operations show_diag_stat_sops = {
+ 	.start	= show_diag_stat_start,
+ 	.next	= show_diag_stat_next,
+ 	.stop	= show_diag_stat_stop,
+ 	.show	= show_diag_stat,
+ };
+ 
+ static int show_diag_stat_open(struct inode *inode, struct file *file)
+ {
+ 	return seq_open(file, &show_diag_stat_sops);
+ }
+ 
+ static const struct file_operations show_diag_stat_fops = {
+ 	.open		= show_diag_stat_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= seq_release,
+ };
+ 
+ 
+ static int __init show_diag_stat_init(void)
+ {
+ 	debugfs_create_file("diag_stat", 0400, NULL, NULL,
+ 			    &show_diag_stat_fops);
+ 	return 0;
+ }
+ 
+ device_initcall(show_diag_stat_init);
+ 
+ void diag_stat_inc(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ 	trace_s390_diagnose(diag_map[nr].code);
+ }
+ EXPORT_SYMBOL(diag_stat_inc);
+ 
+ void diag_stat_inc_norecursion(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ 	trace_s390_diagnose_norecursion(diag_map[nr].code);
+ }
+ EXPORT_SYMBOL(diag_stat_inc_norecursion);
++>>>>>>> 1b030478166c (s390/diag: add diag26c support)
  
  /*
   * Diagnose 14: Input spool file manipulation
@@@ -79,3 -222,46 +204,49 @@@ int diag210(struct diag210 *addr
  	return ccode;
  }
  EXPORT_SYMBOL(diag210);
++<<<<<<< HEAD
++=======
+ 
+ int diag224(void *ptr)
+ {
+ 	int rc = -EOPNOTSUPP;
+ 
+ 	diag_stat_inc(DIAG_STAT_X224);
+ 	asm volatile(
+ 		"	diag	%1,%2,0x224\n"
+ 		"0:	lhi	%0,0x0\n"
+ 		"1:\n"
+ 		EX_TABLE(0b,1b)
+ 		: "+d" (rc) :"d" (0), "d" (ptr) : "memory");
+ 	return rc;
+ }
+ EXPORT_SYMBOL(diag224);
+ 
+ /*
+  * Diagnose 26C: Access Certain System Information
+  */
+ static inline int __diag26c(void *req, void *resp, enum diag26c_sc subcode)
+ {
+ 	register unsigned long _req asm("2") = (addr_t) req;
+ 	register unsigned long _resp asm("3") = (addr_t) resp;
+ 	register unsigned long _subcode asm("4") = subcode;
+ 	register unsigned long _rc asm("5") = -EOPNOTSUPP;
+ 
+ 	asm volatile(
+ 		"	sam31\n"
+ 		"	diag	%[rx],%[ry],0x26c\n"
+ 		"0:	sam64\n"
+ 		EX_TABLE(0b,0b)
+ 		: "+d" (_rc)
+ 		: [rx] "d" (_req), "d" (_resp), [ry] "d" (_subcode)
+ 		: "cc", "memory");
+ 	return _rc;
+ }
+ 
+ int diag26c(void *req, void *resp, enum diag26c_sc subcode)
+ {
+ 	diag_stat_inc(DIAG_STAT_X26C);
+ 	return __diag26c(req, resp, subcode);
+ }
+ EXPORT_SYMBOL(diag26c);
++>>>>>>> 1b030478166c (s390/diag: add diag26c support)
* Unmerged path arch/s390/include/asm/diag.h
* Unmerged path arch/s390/kernel/diag.c
