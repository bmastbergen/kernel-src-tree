networking: convert many more places to skb_put_zero()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] convert many more places to skb_put_zero() (Jiri Benc) [1497085]
Rebuild_FUZZ: 87.50%
commit-author Johannes Berg <johannes.berg@intel.com>
commit b080db585384b9f037e015c0c28d1ad33be41dfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b080db58.failed

There were many places that my previous spatch didn't find,
as pointed out by yuan linyu in various patches.

The following spatch found many more and also removes the
now unnecessary casts:

    @@
    identifier p, p2;
    expression len;
    expression skb;
    type t, t2;
    @@
    (
    -p = skb_put(skb, len);
    +p = skb_put_zero(skb, len);
    |
    -p = (t)skb_put(skb, len);
    +p = skb_put_zero(skb, len);
    )
    ... when != p
    (
    p2 = (t2)p;
    -memset(p2, 0, len);
    |
    -memset(p, 0, len);
    )

    @@
    type t, t2;
    identifier p, p2;
    expression skb;
    @@
    t *p;
    ...
    (
    -p = skb_put(skb, sizeof(t));
    +p = skb_put_zero(skb, sizeof(t));
    |
    -p = (t *)skb_put(skb, sizeof(t));
    +p = skb_put_zero(skb, sizeof(t));
    )
    ... when != p
    (
    p2 = (t2)p;
    -memset(p2, 0, sizeof(*p));
    |
    -memset(p, 0, sizeof(*p));
    )

    @@
    expression skb, len;
    @@
    -memset(skb_put(skb, len), 0, len);
    +skb_put_zero(skb, len);

Apply it to the tree (with one manual fixup to keep the
comment in vxlan.c, which spatch removed.)

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b080db585384b9f037e015c0c28d1ad33be41dfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb3/iwch_cm.c
#	drivers/net/usb/cdc_ncm.c
#	drivers/net/wireless/quantenna/qtnfmac/commands.c
#	drivers/usb/gadget/f_ncm.c
#	net/batman-adv/bat_v_elp.c
#	net/ncsi/ncsi-cmd.c
#	net/qrtr/qrtr.c
#	net/rxrpc/sendmsg.c
diff --cc drivers/infiniband/hw/cxgb3/iwch_cm.c
index 07da19ccfd00,f4c23a74f18c..000000000000
--- a/drivers/infiniband/hw/cxgb3/iwch_cm.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_cm.c
@@@ -417,7 -417,7 +417,11 @@@ static int send_abort(struct iwch_ep *e
  	}
  	skb->priority = CPL_PRIORITY_DATA;
  	set_arp_failure_handler(skb, abort_arp_failure);
++<<<<<<< HEAD
 +	req = (struct cpl_abort_req *) skb_put(skb, sizeof(*req));
++=======
+ 	req = skb_put_zero(skb, sizeof(*req));
++>>>>>>> b080db585384 (networking: convert many more places to skb_put_zero())
  	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ));
  	req->wr.wr_lo = htonl(V_WR_TID(ep->hwtid));
  	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ABORT_REQ, ep->hwtid));
diff --cc drivers/net/usb/cdc_ncm.c
index afbfc0f656f3,7f02954772c6..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -1246,11 -1245,13 +1246,19 @@@ cdc_ncm_fill_tx_frame(struct usbnet *de
  	 * a ZLP after full sized NTBs.
  	 */
  	if (!(dev->driver_info->flags & FLAG_SEND_ZLP) &&
++<<<<<<< HEAD
 +	    skb_out->len > ctx->min_tx_pkt)
 +		memset(skb_put(skb_out, ctx->tx_max - skb_out->len), 0,
 +		       ctx->tx_max - skb_out->len);
 +	else if (skb_out->len < ctx->tx_max && (skb_out->len % dev->maxpacket) == 0)
++=======
+ 	    skb_out->len > ctx->min_tx_pkt) {
+ 		padding_count = ctx->tx_max - skb_out->len;
+ 		skb_put_zero(skb_out, padding_count);
+ 	} else if (skb_out->len < ctx->tx_max &&
+ 		   (skb_out->len % dev->maxpacket) == 0) {
++>>>>>>> b080db585384 (networking: convert many more places to skb_put_zero())
  		*skb_put(skb_out, 1) = 0;	/* force short packet */
 -	}
  
  	/* set final frame length */
  	nth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;
diff --cc drivers/usb/gadget/f_ncm.c
index ee19bc8d0040,2882c6d3ae66..000000000000
--- a/drivers/usb/gadget/f_ncm.c
+++ b/drivers/usb/gadget/f_ncm.c
@@@ -859,98 -957,240 +859,216 @@@ static int ncm_get_alt(struct usb_funct
  
  	if (intf == ncm->ctrl_id)
  		return 0;
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +	return ncm->port.in_ep->driver_data ? 1 : 0;
++=======
+ 	return ncm->port.in_ep->enabled ? 1 : 0;
+ }
+ 
+ static struct sk_buff *package_for_tx(struct f_ncm *ncm)
+ {
+ 	__le16		*ntb_iter;
+ 	struct sk_buff	*skb2 = NULL;
+ 	unsigned	ndp_pad;
+ 	unsigned	ndp_index;
+ 	unsigned	new_len;
+ 
+ 	const struct ndp_parser_opts *opts = ncm->parser_opts;
+ 	const int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
+ 	const int dgram_idx_len = 2 * 2 * opts->dgram_item_len;
+ 
+ 	/* Stop the timer */
+ 	hrtimer_try_to_cancel(&ncm->task_timer);
+ 
+ 	ndp_pad = ALIGN(ncm->skb_tx_data->len, ndp_align) -
+ 			ncm->skb_tx_data->len;
+ 	ndp_index = ncm->skb_tx_data->len + ndp_pad;
+ 	new_len = ndp_index + dgram_idx_len + ncm->skb_tx_ndp->len;
+ 
+ 	/* Set the final BlockLength and wNdpIndex */
+ 	ntb_iter = (void *) ncm->skb_tx_data->data;
+ 	/* Increment pointer to BlockLength */
+ 	ntb_iter += 2 + 1 + 1;
+ 	put_ncm(&ntb_iter, opts->block_length, new_len);
+ 	put_ncm(&ntb_iter, opts->ndp_index, ndp_index);
+ 
+ 	/* Set the final NDP wLength */
+ 	new_len = opts->ndp_size +
+ 			(ncm->ndp_dgram_count * dgram_idx_len);
+ 	ncm->ndp_dgram_count = 0;
+ 	/* Increment from start to wLength */
+ 	ntb_iter = (void *) ncm->skb_tx_ndp->data;
+ 	ntb_iter += 2;
+ 	put_unaligned_le16(new_len, ntb_iter);
+ 
+ 	/* Merge the skbs */
+ 	swap(skb2, ncm->skb_tx_data);
+ 	if (ncm->skb_tx_data) {
+ 		dev_consume_skb_any(ncm->skb_tx_data);
+ 		ncm->skb_tx_data = NULL;
+ 	}
+ 
+ 	/* Insert NDP alignment. */
+ 	ntb_iter = skb_put_zero(skb2, ndp_pad);
+ 
+ 	/* Copy NTB across. */
+ 	ntb_iter = (void *) skb_put(skb2, ncm->skb_tx_ndp->len);
+ 	memcpy(ntb_iter, ncm->skb_tx_ndp->data, ncm->skb_tx_ndp->len);
+ 	dev_consume_skb_any(ncm->skb_tx_ndp);
+ 	ncm->skb_tx_ndp = NULL;
+ 
+ 	/* Insert zero'd datagram. */
+ 	ntb_iter = skb_put_zero(skb2, dgram_idx_len);
+ 
+ 	return skb2;
++>>>>>>> b080db585384 (networking: convert many more places to skb_put_zero()):drivers/usb/gadget/function/f_ncm.c
  }
  
  static struct sk_buff *ncm_wrap_ntb(struct gether *port,
  				    struct sk_buff *skb)
  {
  	struct f_ncm	*ncm = func_to_ncm(&port->func);
 -	struct sk_buff	*skb2 = NULL;
 +	struct sk_buff	*skb2;
  	int		ncb_len = 0;
 -	__le16		*ntb_data;
 -	__le16		*ntb_ndp;
 -	int		dgram_pad;
 -
 +	__le16		*tmp;
 +	int		div;
 +	int		rem;
 +	int		pad;
 +	int		ndp_align;
 +	int		ndp_pad;
  	unsigned	max_size = ncm->port.fixed_in_len;
  	const struct ndp_parser_opts *opts = ncm->parser_opts;
 -	const int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
 -	const int div = le16_to_cpu(ntb_parameters.wNdpInDivisor);
 -	const int rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);
 -	const int dgram_idx_len = 2 * 2 * opts->dgram_item_len;
 +	unsigned	crc_len = ncm->is_crc ? sizeof(uint32_t) : 0;
 +
 +	div = le16_to_cpu(ntb_parameters.wNdpInDivisor);
 +	rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);
 +	ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
 +
 +	ncb_len += opts->nth_size;
 +	ndp_pad = ALIGN(ncb_len, ndp_align) - ncb_len;
 +	ncb_len += ndp_pad;
 +	ncb_len += opts->ndp_size;
 +	ncb_len += 2 * 2 * opts->dgram_item_len; /* Datagram entry */
 +	ncb_len += 2 * 2 * opts->dgram_item_len; /* Zero datagram entry */
 +	pad = ALIGN(ncb_len, div) + rem - ncb_len;
 +	ncb_len += pad;
  
 -	if (!skb && !ncm->skb_tx_data)
 +	if (ncb_len + skb->len + crc_len > max_size) {
 +		dev_kfree_skb_any(skb);
  		return NULL;
 +	}
  
 -	if (skb) {
 -		/* Add the CRC if required up front */
 -		if (ncm->is_crc) {
 -			uint32_t	crc;
 -			__le16		*crc_pos;
 -
 -			crc = ~crc32_le(~0,
 -					skb->data,
 -					skb->len);
 -			crc_pos = (void *) skb_put(skb, sizeof(uint32_t));
 -			put_unaligned_le32(crc, crc_pos);
 -		}
 +	skb2 = skb_copy_expand(skb, ncb_len,
 +			       max_size - skb->len - ncb_len - crc_len,
 +			       GFP_ATOMIC);
 +	dev_kfree_skb_any(skb);
 +	if (!skb2)
 +		return NULL;
  
 -		/* If the new skb is too big for the current NCM NTB then
 -		 * set the current stored skb to be sent now and clear it
 -		 * ready for new data.
 -		 * NOTE: Assume maximum align for speed of calculation.
 -		 */
 -		if (ncm->skb_tx_data
 -		    && (ncm->ndp_dgram_count >= TX_MAX_NUM_DPE
 -		    || (ncm->skb_tx_data->len +
 -		    div + rem + skb->len +
 -		    ncm->skb_tx_ndp->len + ndp_align + (2 * dgram_idx_len))
 -		    > max_size)) {
 -			skb2 = package_for_tx(ncm);
 -			if (!skb2)
 -				goto err;
 -		}
 +	skb = skb2;
  
 -		if (!ncm->skb_tx_data) {
 -			ncb_len = opts->nth_size;
 -			dgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;
 -			ncb_len += dgram_pad;
 +	tmp = (void *) skb_push(skb, ncb_len);
 +	memset(tmp, 0, ncb_len);
  
 -			/* Create a new skb for the NTH and datagrams. */
 -			ncm->skb_tx_data = alloc_skb(max_size, GFP_ATOMIC);
 -			if (!ncm->skb_tx_data)
 -				goto err;
 +	put_unaligned_le32(opts->nth_sign, tmp); /* dwSignature */
 +	tmp += 2;
 +	/* wHeaderLength */
 +	put_unaligned_le16(opts->nth_size, tmp++);
 +	tmp++; /* skip wSequence */
 +	put_ncm(&tmp, opts->block_length, skb->len); /* (d)wBlockLength */
 +	/* (d)wFpIndex */
 +	/* the first pointer is right after the NTH + align */
 +	put_ncm(&tmp, opts->fp_index, opts->nth_size + ndp_pad);
 +
 +	tmp = (void *)tmp + ndp_pad;
  
 +	/* NDP */
 +	put_unaligned_le32(ncm->ndp_sign, tmp); /* dwSignature */
 +	tmp += 2;
 +	/* wLength */
 +	put_unaligned_le16(ncb_len - opts->nth_size - pad, tmp++);
 +
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +	tmp += opts->reserved1;
 +	tmp += opts->next_fp_index; /* skip reserved (d)wNextFpIndex */
 +	tmp += opts->reserved2;
++=======
+ 			ncm->skb_tx_data->dev = ncm->netdev;
+ 			ntb_data = skb_put_zero(ncm->skb_tx_data, ncb_len);
+ 			/* dwSignature */
+ 			put_unaligned_le32(opts->nth_sign, ntb_data);
+ 			ntb_data += 2;
+ 			/* wHeaderLength */
+ 			put_unaligned_le16(opts->nth_size, ntb_data++);
 -
 -			/* Allocate an skb for storing the NDP,
 -			 * TX_MAX_NUM_DPE should easily suffice for a
 -			 * 16k packet.
 -			 */
 -			ncm->skb_tx_ndp = alloc_skb((int)(opts->ndp_size
 -						    + opts->dpe_size
 -						    * TX_MAX_NUM_DPE),
 -						    GFP_ATOMIC);
 -			if (!ncm->skb_tx_ndp)
 -				goto err;
 -
++>>>>>>> b080db585384 (networking: convert many more places to skb_put_zero()):drivers/usb/gadget/function/f_ncm.c
 +
 +	if (ncm->is_crc) {
 +		uint32_t crc;
 +
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +		crc = ~crc32_le(~0,
 +				skb->data + ncb_len,
 +				skb->len - ncb_len);
 +		put_unaligned_le32(crc, skb->data + skb->len);
 +		skb_put(skb, crc_len);
++=======
+ 			ncm->skb_tx_ndp->dev = ncm->netdev;
+ 			ntb_ndp = (void *) skb_put(ncm->skb_tx_ndp,
+ 						    opts->ndp_size);
+ 			memset(ntb_ndp, 0, ncb_len);
+ 			/* dwSignature */
+ 			put_unaligned_le32(ncm->ndp_sign, ntb_ndp);
+ 			ntb_ndp += 2;
+ 
+ 			/* There is always a zeroed entry */
+ 			ncm->ndp_dgram_count = 1;
+ 
+ 			/* Note: we skip opts->next_ndp_index */
+ 		}
+ 
+ 		/* Delay the timer. */
+ 		hrtimer_start(&ncm->task_timer, TX_TIMEOUT_NSECS,
+ 			      HRTIMER_MODE_REL);
+ 
+ 		/* Add the datagram position entries */
+ 		ntb_ndp = skb_put_zero(ncm->skb_tx_ndp, dgram_idx_len);
+ 
+ 		ncb_len = ncm->skb_tx_data->len;
+ 		dgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;
+ 		ncb_len += dgram_pad;
+ 
+ 		/* (d)wDatagramIndex */
+ 		put_ncm(&ntb_ndp, opts->dgram_item_len, ncb_len);
+ 		/* (d)wDatagramLength */
+ 		put_ncm(&ntb_ndp, opts->dgram_item_len, skb->len);
+ 		ncm->ndp_dgram_count++;
+ 
+ 		/* Add the new data to the skb */
+ 		ntb_data = skb_put_zero(ncm->skb_tx_data, dgram_pad);
+ 		ntb_data = (void *) skb_put(ncm->skb_tx_data, skb->len);
+ 		memcpy(ntb_data, skb->data, skb->len);
+ 		dev_consume_skb_any(skb);
+ 		skb = NULL;
+ 
+ 	} else if (ncm->skb_tx_data && ncm->timer_force_tx) {
+ 		/* If the tx was requested because of a timeout then send */
+ 		skb2 = package_for_tx(ncm);
+ 		if (!skb2)
+ 			goto err;
++>>>>>>> b080db585384 (networking: convert many more places to skb_put_zero()):drivers/usb/gadget/function/f_ncm.c
  	}
  
 -	return skb2;
 -
 -err:
 -	ncm->netdev->stats.tx_dropped++;
 -
 -	if (skb)
 -		dev_kfree_skb_any(skb);
 -	if (ncm->skb_tx_data)
 -		dev_kfree_skb_any(ncm->skb_tx_data);
 -	if (ncm->skb_tx_ndp)
 -		dev_kfree_skb_any(ncm->skb_tx_ndp);
 -
 -	return NULL;
 -}
 -
 -/*
 - * This transmits the NTB if there are frames waiting.
 - */
 -static void ncm_tx_tasklet(unsigned long data)
 -{
 -	struct f_ncm	*ncm = (void *)data;
 -
 -	if (ncm->timer_stopping)
 -		return;
 -
 -	/* Only send if data is available. */
 -	if (ncm->skb_tx_data) {
 -		ncm->timer_force_tx = true;
 -
 -		/* XXX This allowance of a NULL skb argument to ndo_start_xmit
 -		 * XXX is not sane.  The gadget layer should be redesigned so
 -		 * XXX that the dev->wrap() invocations to build SKBs is transparent
 -		 * XXX and performed in some way outside of the ndo_start_xmit
 -		 * XXX interface.
 -		 */
 -		ncm->netdev->netdev_ops->ndo_start_xmit(NULL, ncm->netdev);
 +	/* (d)wDatagramIndex[0] */
 +	put_ncm(&tmp, opts->dgram_item_len, ncb_len);
 +	/* (d)wDatagramLength[0] */
 +	put_ncm(&tmp, opts->dgram_item_len, skb->len - ncb_len);
 +	/* (d)wDatagramIndex[1] and  (d)wDatagramLength[1] already zeroed */
  
 -		ncm->timer_force_tx = false;
 -	}
 -}
 +	if (skb->len > MAX_TX_NONFIXED)
 +		memset(skb_put(skb, max_size - skb->len),
 +		       0, max_size - skb->len);
  
 -/*
 - * The transmit should only be run if no skb data has been sent
 - * for a certain duration.
 - */
 -static enum hrtimer_restart ncm_tx_timeout(struct hrtimer *data)
 -{
 -	struct f_ncm *ncm = container_of(data, struct f_ncm, task_timer);
 -	tasklet_schedule(&ncm->tx_tasklet);
 -	return HRTIMER_NORESTART;
 +	return skb;
  }
  
  static int ncm_unwrap_ntb(struct gether *port,
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/commands.c
* Unmerged path net/batman-adv/bat_v_elp.c
* Unmerged path net/ncsi/ncsi-cmd.c
* Unmerged path net/qrtr/qrtr.c
* Unmerged path net/rxrpc/sendmsg.c
diff --git a/drivers/infiniband/hw/cxgb3/cxio_hal.c b/drivers/infiniband/hw/cxgb3/cxio_hal.c
index f26676f2f3b2..334430b44a6c 100644
--- a/drivers/infiniband/hw/cxgb3/cxio_hal.c
+++ b/drivers/infiniband/hw/cxgb3/cxio_hal.c
@@ -143,8 +143,7 @@ static int cxio_hal_clear_qp_ctx(struct cxio_rdev *rdev_p, u32 qpid)
 		PDBG("%s alloc_skb failed\n", __func__);
 		return -ENOMEM;
 	}
-	wqe = (struct t3_modify_qp_wr *) skb_put(skb, sizeof(*wqe));
-	memset(wqe, 0, sizeof(*wqe));
+	wqe = skb_put_zero(skb, sizeof(*wqe));
 	build_fw_riwrh((struct fw_riwrh *) wqe, T3_WR_QP_MOD,
 		       T3_COMPLETION_FLAG | T3_NOTIFY_FLAG, 0, qpid, 7,
 		       T3_SOPEOP);
@@ -562,8 +561,7 @@ static int cxio_hal_init_ctrl_qp(struct cxio_rdev *rdev_p)
 	ctx1 |= ((u64) (V_EC_BASE_HI((u32) base_addr & 0xf) | V_EC_RESPQ(0) |
 			V_EC_TYPE(0) | V_EC_GEN(1) |
 			V_EC_UP_TOKEN(T3_CTL_QP_TID) | F_EC_VALID)) << 32;
-	wqe = (struct t3_modify_qp_wr *) skb_put(skb, sizeof(*wqe));
-	memset(wqe, 0, sizeof(*wqe));
+	wqe = skb_put_zero(skb, sizeof(*wqe));
 	build_fw_riwrh((struct fw_riwrh *) wqe, T3_WR_QP_MOD, 0, 0,
 		       T3_CTL_QP_TID, 7, T3_SOPEOP);
 	wqe->flags = cpu_to_be32(MODQP_WRITE_EC);
* Unmerged path drivers/infiniband/hw/cxgb3/iwch_cm.c
diff --git a/drivers/infiniband/hw/cxgb3/iwch_qp.c b/drivers/infiniband/hw/cxgb3/iwch_qp.c
index d939980a708f..cceea40de0b2 100644
--- a/drivers/infiniband/hw/cxgb3/iwch_qp.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_qp.c
@@ -670,8 +670,7 @@ int iwch_post_zb_read(struct iwch_ep *ep)
 		printk(KERN_ERR "%s cannot send zb_read!!\n", __func__);
 		return -ENOMEM;
 	}
-	wqe = (union t3_wr *)skb_put(skb, sizeof(struct t3_rdma_read_wr));
-	memset(wqe, 0, sizeof(struct t3_rdma_read_wr));
+	wqe = skb_put_zero(skb, sizeof(struct t3_rdma_read_wr));
 	wqe->read.rdmaop = T3_READ_REQ;
 	wqe->read.reserved[0] = 0;
 	wqe->read.reserved[1] = 0;
@@ -702,8 +701,7 @@ int iwch_post_terminate(struct iwch_qp *qhp, struct respQ_msg_t *rsp_msg)
 		printk(KERN_ERR "%s cannot send TERMINATE!\n", __func__);
 		return -ENOMEM;
 	}
-	wqe = (union t3_wr *)skb_put(skb, 40);
-	memset(wqe, 0, 40);
+	wqe = skb_put_zero(skb, 40);
 	wqe->send.rdmaop = T3_TERMINATE;
 
 	/* immediate data length */
diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c
index c5a62399c28c..7728c410a25b 100644
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -927,8 +927,7 @@ static int send_mpa_req(struct c4iw_ep *ep, struct sk_buff *skb,
 	}
 	set_wr_txq(skb, CPL_PRIORITY_DATA, ep->txq_idx);
 
-	req = (struct fw_ofld_tx_data_wr *)skb_put(skb, wrlen);
-	memset(req, 0, wrlen);
+	req = skb_put_zero(skb, wrlen);
 	req->op_to_immdlen = cpu_to_be32(
 		FW_WR_OP_V(FW_OFLD_TX_DATA_WR) |
 		FW_WR_COMPL_F |
@@ -1033,8 +1032,7 @@ static int send_mpa_reject(struct c4iw_ep *ep, const void *pdata, u8 plen)
 	}
 	set_wr_txq(skb, CPL_PRIORITY_DATA, ep->txq_idx);
 
-	req = (struct fw_ofld_tx_data_wr *)skb_put(skb, wrlen);
-	memset(req, 0, wrlen);
+	req = skb_put_zero(skb, wrlen);
 	req->op_to_immdlen = cpu_to_be32(
 		FW_WR_OP_V(FW_OFLD_TX_DATA_WR) |
 		FW_WR_COMPL_F |
@@ -1113,8 +1111,7 @@ static int send_mpa_reply(struct c4iw_ep *ep, const void *pdata, u8 plen)
 	}
 	set_wr_txq(skb, CPL_PRIORITY_DATA, ep->txq_idx);
 
-	req = (struct fw_ofld_tx_data_wr *) skb_put(skb, wrlen);
-	memset(req, 0, wrlen);
+	req = skb_put_zero(skb, wrlen);
 	req->op_to_immdlen = cpu_to_be32(
 		FW_WR_OP_V(FW_OFLD_TX_DATA_WR) |
 		FW_WR_COMPL_F |
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
index 5621dcfda4f1..b3587495cb31 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
@@ -172,7 +172,7 @@ static struct sk_buff *mlx5e_test_get_udp_skb(struct mlx5e_priv *priv)
 	mlxh->magic = cpu_to_be64(MLX5E_TEST_MAGIC);
 	strlcpy(mlxh->text, mlx5e_test_text, sizeof(mlxh->text));
 	datalen -= sizeof(*mlxh);
-	memset(skb_put(skb, datalen), 0, datalen);
+	skb_put_zero(skb, datalen);
 
 	skb->csum = 0;
 	skb->ip_summed = CHECKSUM_PARTIAL;
* Unmerged path drivers/net/usb/cdc_ncm.c
diff --git a/drivers/net/usb/kalmia.c b/drivers/net/usb/kalmia.c
index 3e37724d30ae..d1c2f5b37893 100644
--- a/drivers/net/usb/kalmia.c
+++ b/drivers/net/usb/kalmia.c
@@ -217,7 +217,7 @@ done:
 	remainder = skb->len % KALMIA_ALIGN_SIZE;
 	if (remainder > 0) {
 		padlen = KALMIA_ALIGN_SIZE - remainder;
-		memset(skb_put(skb, padlen), 0, padlen);
+		skb_put_zero(skb, padlen);
 	}
 
 	netdev_dbg(dev->net,
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index fcdb95049162..cd5101ba2ea3 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1522,10 +1522,8 @@ static struct sk_buff *vxlan_na_create(struct sk_buff *request,
 	skb_pull(reply, sizeof(struct ipv6hdr));
 	skb_reset_transport_header(reply);
 
-	na = (struct nd_msg *)skb_put(reply, sizeof(*na) + na_olen);
-
 	/* Neighbor Advertisement */
-	memset(na, 0, sizeof(*na)+na_olen);
+	na = skb_put_zero(reply, sizeof(*na) + na_olen);
 	na->icmph.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT;
 	na->icmph.icmp6_router = isrouter;
 	na->icmph.icmp6_override = 1;
diff --git a/drivers/net/wireless/ath/ath9k/channel.c b/drivers/net/wireless/ath/ath9k/channel.c
index b84539d89f1a..373b1e9457fd 100644
--- a/drivers/net/wireless/ath/ath9k/channel.c
+++ b/drivers/net/wireless/ath/ath9k/channel.c
@@ -1526,8 +1526,7 @@ void ath9k_beacon_add_noa(struct ath_softc *sc, struct ath_vif *avp,
 	hdr[1] = sizeof(noa_ie_hdr) + noa_len - 2;
 	hdr[7] = noa_len;
 
-	noa = (void *) skb_put(skb, noa_len);
-	memset(noa, 0, noa_len);
+	noa = skb_put_zero(skb, noa_len);
 
 	noa->index = avp->noa_index;
 	noa->oppps_ctwindow = ath9k_get_ctwin(sc, avp);
diff --git a/drivers/net/wireless/hostap/hostap_ap.c b/drivers/net/wireless/hostap/hostap_ap.c
index d6033a8e5dea..47c1cd25f97f 100644
--- a/drivers/net/wireless/hostap/hostap_ap.c
+++ b/drivers/net/wireless/hostap/hostap_ap.c
@@ -998,12 +998,10 @@ static void prism2_send_mgmt(struct net_device *dev,
 
 	fc = type_subtype;
 	hdrlen = hostap_80211_get_hdrlen(cpu_to_le16(type_subtype));
-	hdr = (struct ieee80211_hdr *) skb_put(skb, hdrlen);
+	hdr = skb_put_zero(skb, hdrlen);
 	if (body)
 		memcpy(skb_put(skb, body_len), body, body_len);
 
-	memset(hdr, 0, hdrlen);
-
 	/* FIX: ctrl::ack sending used special HFA384X_TX_CTRL_802_11
 	 * tx_control instead of using local->tx_control */
 
@@ -1325,8 +1323,7 @@ static char * ap_auth_make_challenge(struct ap_data *ap)
 	}
 
 	skb_reserve(skb, ap->crypt->extra_mpdu_prefix_len);
-	memset(skb_put(skb, WLAN_AUTH_CHALLENGE_LEN), 0,
-	       WLAN_AUTH_CHALLENGE_LEN);
+	skb_put_zero(skb, WLAN_AUTH_CHALLENGE_LEN);
 	if (ap->crypt->encrypt_mpdu(skb, 0, ap->crypt_priv)) {
 		dev_kfree_skb(skb);
 		kfree(tmpbuf);
diff --git a/drivers/net/wireless/hostap/hostap_main.c b/drivers/net/wireless/hostap/hostap_main.c
index 15f0fad39add..09151306eca9 100644
--- a/drivers/net/wireless/hostap/hostap_main.c
+++ b/drivers/net/wireless/hostap/hostap_main.c
@@ -1053,9 +1053,7 @@ int prism2_sta_send_mgmt(local_info_t *local, u8 *dst, u16 stype,
 	if (skb == NULL)
 		return -ENOMEM;
 
-	mgmt = (struct hostap_ieee80211_mgmt *)
-		skb_put(skb, IEEE80211_MGMT_HDR_LEN);
-	memset(mgmt, 0, IEEE80211_MGMT_HDR_LEN);
+	mgmt = skb_put_zero(skb, IEEE80211_MGMT_HDR_LEN);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);
 	memcpy(mgmt->da, dst, ETH_ALEN);
 	memcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);
diff --git a/drivers/net/wireless/marvell/mwifiex/cmdevt.c b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
index e7a21443647e..1a2154d128c1 100644
--- a/drivers/net/wireless/marvell/mwifiex/cmdevt.c
+++ b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
@@ -600,8 +600,7 @@ int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,
 		return -1;
 	}
 
-	memset(skb_put(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command)),
-	       0, sizeof(struct host_cmd_ds_command));
+	skb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));
 
 	cmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);
 	cmd_ptr->command = cpu_to_le16(cmd_no);
diff --git a/drivers/net/wireless/marvell/mwifiex/tdls.c b/drivers/net/wireless/marvell/mwifiex/tdls.c
index df9704de0715..6b8ec7296c2f 100644
--- a/drivers/net/wireless/marvell/mwifiex/tdls.c
+++ b/drivers/net/wireless/marvell/mwifiex/tdls.c
@@ -391,8 +391,7 @@ mwifiex_tdls_add_wmm_param_ie(struct mwifiex_private *priv, struct sk_buff *skb)
 	u8 ac_be[] = {0x03, 0xa4, 0x00, 0x00};
 	u8 ac_bk[] = {0x27, 0xa4, 0x00, 0x00};
 
-	wmm = (void *)skb_put(skb, sizeof(*wmm));
-	memset(wmm, 0, sizeof(*wmm));
+	wmm = skb_put_zero(skb, sizeof(*wmm));
 
 	wmm->element_id = WLAN_EID_VENDOR_SPECIFIC;
 	wmm->len = sizeof(*wmm) - 2;
diff --git a/drivers/net/wireless/p54/txrx.c b/drivers/net/wireless/p54/txrx.c
index f95de0d16216..931976baf5af 100644
--- a/drivers/net/wireless/p54/txrx.c
+++ b/drivers/net/wireless/p54/txrx.c
@@ -911,8 +911,7 @@ void p54_tx_80211(struct ieee80211_hw *dev,
 		}
 		/* reserve some space for ICV */
 		len += info->control.hw_key->icv_len;
-		memset(skb_put(skb, info->control.hw_key->icv_len), 0,
-		       info->control.hw_key->icv_len);
+		skb_put_zero(skb, info->control.hw_key->icv_len);
 	} else {
 		txhdr->key_type = 0;
 		txhdr->key_len = 0;
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/commands.c
diff --git a/drivers/net/wireless/realtek/rtlwifi/base.c b/drivers/net/wireless/realtek/rtlwifi/base.c
index 264466f59c57..47d26e49d293 100644
--- a/drivers/net/wireless/realtek/rtlwifi/base.c
+++ b/drivers/net/wireless/realtek/rtlwifi/base.c
@@ -1782,8 +1782,7 @@ static struct sk_buff *rtl_make_smps_action(struct ieee80211_hw *hw,
 		return NULL;
 
 	skb_reserve(skb, hw->extra_tx_headroom);
-	action_frame = (void *)skb_put(skb, 27);
-	memset(action_frame, 0, 27);
+	action_frame = skb_put_zero(skb, 27);
 	memcpy(action_frame->da, da, ETH_ALEN);
 	memcpy(action_frame->sa, rtlefuse->dev_addr, ETH_ALEN);
 	memcpy(action_frame->bssid, bssid, ETH_ALEN);
@@ -1913,8 +1912,7 @@ struct sk_buff *rtl_make_del_ba(struct ieee80211_hw *hw,
 		return NULL;
 
 	skb_reserve(skb, hw->extra_tx_headroom);
-	action_frame = (void *)skb_put(skb, 34);
-	memset(action_frame, 0, 34);
+	action_frame = skb_put_zero(skb, 34);
 	memcpy(action_frame->sa, sa, ETH_ALEN);
 	memcpy(action_frame->da, rtlefuse->dev_addr, ETH_ALEN);
 	memcpy(action_frame->bssid, bssid, ETH_ALEN);
diff --git a/drivers/net/wireless/ti/wlcore/cmd.c b/drivers/net/wireless/ti/wlcore/cmd.c
index c9e060795d13..4a5624dd5233 100644
--- a/drivers/net/wireless/ti/wlcore/cmd.c
+++ b/drivers/net/wireless/ti/wlcore/cmd.c
@@ -1210,8 +1210,7 @@ int wl1271_cmd_build_arp_rsp(struct wl1271 *wl, struct wl12xx_vif *wlvif)
 
 	skb_reserve(skb, sizeof(*hdr) + WL1271_EXTRA_SPACE_MAX);
 
-	tmpl = (struct wl12xx_arp_rsp_template *)skb_put(skb, sizeof(*tmpl));
-	memset(tmpl, 0, sizeof(*tmpl));
+	tmpl = skb_put_zero(skb, sizeof(*tmpl));
 
 	/* llc layer */
 	memcpy(tmpl->llc_hdr, rfc1042_header, sizeof(rfc1042_header));
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 953111a502ee..4fdfd8c8457d 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -1307,13 +1307,12 @@ static struct sk_buff *wl12xx_alloc_dummy_packet(struct wl1271 *wl)
 
 	skb_reserve(skb, sizeof(struct wl1271_tx_hw_descr));
 
-	hdr = (struct ieee80211_hdr_3addr *) skb_put(skb, sizeof(*hdr));
-	memset(hdr, 0, sizeof(*hdr));
+	hdr = skb_put_zero(skb, sizeof(*hdr));
 	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
 					 IEEE80211_STYPE_NULLFUNC |
 					 IEEE80211_FCTL_TODS);
 
-	memset(skb_put(skb, dummy_packet_size), 0, dummy_packet_size);
+	skb_put_zero(skb, dummy_packet_size);
 
 	/* Dummy packets require the TID to be management */
 	skb->priority = WL1271_TID_MGMT;
diff --git a/drivers/scsi/fcoe/fcoe_ctlr.c b/drivers/scsi/fcoe/fcoe_ctlr.c
index e66be71c54e0..bcfa02ede5a1 100644
--- a/drivers/scsi/fcoe/fcoe_ctlr.c
+++ b/drivers/scsi/fcoe/fcoe_ctlr.c
@@ -657,8 +657,7 @@ static int fcoe_ctlr_encaps(struct fcoe_ctlr *fip, struct fc_lport *lport,
 
 	if (op != ELS_LS_RJT) {
 		dlen += sizeof(*mac);
-		mac = (struct fip_mac_desc *)skb_put(skb, sizeof(*mac));
-		memset(mac, 0, sizeof(*mac));
+		mac = skb_put_zero(skb, sizeof(*mac));
 		mac->fd_desc.fip_dtype = FIP_DT_MAC;
 		mac->fd_desc.fip_dlen = sizeof(*mac) / FIP_BPW;
 		if (dtype != FIP_DT_FLOGI && dtype != FIP_DT_FDISC) {
diff --git a/drivers/scsi/libfc/fc_libfc.c b/drivers/scsi/libfc/fc_libfc.c
index 8d65a51a7598..27cf5fa2e5e5 100644
--- a/drivers/scsi/libfc/fc_libfc.c
+++ b/drivers/scsi/libfc/fc_libfc.c
@@ -178,7 +178,7 @@ void fc_fill_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,
 		fill = -fr_len(fp) & 3;
 		if (fill) {
 			/* TODO, this may be a problem with fragmented skb */
-			memset(skb_put(fp_skb(fp), fill), 0, fill);
+			skb_put_zero(fp_skb(fp), fill);
 			f_ctl |= fill;
 		}
 		fr_eof(fp) = FC_EOF_T;
* Unmerged path drivers/usb/gadget/f_ncm.c
diff --git a/net/atm/signaling.c b/net/atm/signaling.c
index 4176887e72eb..6408fdbdb05c 100644
--- a/net/atm/signaling.c
+++ b/net/atm/signaling.c
@@ -171,8 +171,7 @@ void sigd_enq2(struct atm_vcc *vcc, enum atmsvc_msg_type type,
 	pr_debug("%d (0x%p)\n", (int)type, vcc);
 	while (!(skb = alloc_skb(sizeof(struct atmsvc_msg), GFP_KERNEL)))
 		schedule();
-	msg = (struct atmsvc_msg *)skb_put(skb, sizeof(struct atmsvc_msg));
-	memset(msg, 0, sizeof(*msg));
+	msg = skb_put_zero(skb, sizeof(struct atmsvc_msg));
 	msg->type = type;
 	*(struct atm_vcc **) &msg->vcc = vcc;
 	*(struct atm_vcc **) &msg->listen_vcc = listen_vcc;
* Unmerged path net/batman-adv/bat_v_elp.c
diff --git a/net/bridge/netfilter/nft_reject_bridge.c b/net/bridge/netfilter/nft_reject_bridge.c
index d0acfe36b2b9..308d85539a6e 100644
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@ -122,8 +122,7 @@ static void nft_reject_br_send_v4_unreach(struct sk_buff *oldskb,
 				   sysctl_ip_default_ttl);
 
 	skb_reset_transport_header(nskb);
-	icmph = (struct icmphdr *)skb_put(nskb, sizeof(struct icmphdr));
-	memset(icmph, 0, sizeof(*icmph));
+	icmph = skb_put_zero(nskb, sizeof(struct icmphdr));
 	icmph->type     = ICMP_DEST_UNREACH;
 	icmph->code	= code;
 
@@ -234,8 +233,7 @@ static void nft_reject_br_send_v6_unreach(struct net *net,
 				     net->ipv6.devconf_all->hop_limit);
 
 	skb_reset_transport_header(nskb);
-	icmp6h = (struct icmp6hdr *)skb_put(nskb, sizeof(struct icmp6hdr));
-	memset(icmp6h, 0, sizeof(*icmp6h));
+	icmp6h = skb_put_zero(nskb, sizeof(struct icmp6hdr));
 	icmp6h->icmp6_type = ICMPV6_DEST_UNREACH;
 	icmp6h->icmp6_code = code;
 
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index 41f73b70de68..b113e76b1c43 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -2618,7 +2618,7 @@ static void pktgen_finalize_skb(struct pktgen_dev *pkt_dev, struct sk_buff *skb,
 	datalen -= sizeof(*pgh);
 
 	if (pkt_dev->nfrags <= 0) {
-		memset(skb_put(skb, datalen), 0, datalen);
+		skb_put_zero(skb, datalen);
 	} else {
 		int frags = pkt_dev->nfrags;
 		int i, len;
@@ -2629,7 +2629,7 @@ static void pktgen_finalize_skb(struct pktgen_dev *pkt_dev, struct sk_buff *skb,
 			frags = MAX_SKB_FRAGS;
 		len = datalen - frags * PAGE_SIZE;
 		if (len > 0) {
-			memset(skb_put(skb, len), 0, len);
+			skb_put_zero(skb, len);
 			datalen = frags * PAGE_SIZE;
 		}
 
diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
index efa1138fa523..58002c7141f1 100644
--- a/net/ipv4/ipconfig.c
+++ b/net/ipv4/ipconfig.c
@@ -805,8 +805,7 @@ static void __init ic_bootp_send_if(struct ic_device *d, unsigned long jiffies_d
 	if (!skb)
 		return;
 	skb_reserve(skb, hlen);
-	b = (struct bootp_pkt *) skb_put(skb, sizeof(struct bootp_pkt));
-	memset(b, 0, sizeof(struct bootp_pkt));
+	b = skb_put_zero(skb, sizeof(struct bootp_pkt));
 
 	/* Construct IP header */
 	skb_reset_network_header(skb);
diff --git a/net/ipv4/netfilter/nf_reject_ipv4.c b/net/ipv4/netfilter/nf_reject_ipv4.c
index 9fda46481259..94094b98a6ac 100644
--- a/net/ipv4/netfilter/nf_reject_ipv4.c
+++ b/net/ipv4/netfilter/nf_reject_ipv4.c
@@ -73,8 +73,7 @@ void nf_reject_ip_tcphdr_put(struct sk_buff *nskb, const struct sk_buff *oldskb,
 	struct tcphdr *tcph;
 
 	skb_reset_transport_header(nskb);
-	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
-	memset(tcph, 0, sizeof(*tcph));
+	tcph = skb_put_zero(nskb, sizeof(struct tcphdr));
 	tcph->source	= oth->dest;
 	tcph->dest	= oth->source;
 	tcph->doff	= sizeof(struct tcphdr) / 4;
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index d23b12acac9f..12441398d59e 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -1998,8 +1998,7 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 
 	memcpy(skb_put(skb, sizeof(ra)), ra, sizeof(ra));
 
-	hdr = (struct mld_msg *) skb_put(skb, sizeof(struct mld_msg));
-	memset(hdr, 0, sizeof(struct mld_msg));
+	hdr = skb_put_zero(skb, sizeof(struct mld_msg));
 	hdr->mld_type = type;
 	hdr->mld_mca = *addr;
 
diff --git a/net/key/af_key.c b/net/key/af_key.c
index 1a0fd71903fe..2dd3b20b0f8b 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -2908,8 +2908,7 @@ static void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)
 
 		if (aalg_tmpl_set(t, aalg) && aalg->available) {
 			struct sadb_comb *c;
-			c = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));
-			memset(c, 0, sizeof(*c));
+			c = skb_put_zero(skb, sizeof(struct sadb_comb));
 			p->sadb_prop_len += sizeof(struct sadb_comb)/8;
 			c->sadb_comb_auth = aalg->desc.sadb_alg_id;
 			c->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;
@@ -3435,8 +3434,7 @@ static int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *
 	size_req = (sizeof(struct sadb_x_kmaddress) +
 		    pfkey_sockaddr_pair_size(family));
 
-	kma = (struct sadb_x_kmaddress *)skb_put(skb, size_req);
-	memset(kma, 0, size_req);
+	kma = skb_put_zero(skb, size_req);
 	kma->sadb_x_kmaddress_len = size_req / 8;
 	kma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;
 	kma->sadb_x_kmaddress_reserved = k->reserved;
@@ -3462,8 +3460,7 @@ static int set_ipsecrequest(struct sk_buff *skb,
 	size_req = sizeof(struct sadb_x_ipsecrequest) +
 		   pfkey_sockaddr_pair_size(family);
 
-	rq = (struct sadb_x_ipsecrequest *)skb_put(skb, size_req);
-	memset(rq, 0, size_req);
+	rq = skb_put_zero(skb, size_req);
 	rq->sadb_x_ipsecrequest_len = size_req;
 	rq->sadb_x_ipsecrequest_proto = proto;
 	rq->sadb_x_ipsecrequest_mode = mode;
diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c
index 4456559cb056..a54b3584b8da 100644
--- a/net/mac80211/agg-rx.c
+++ b/net/mac80211/agg-rx.c
@@ -213,8 +213,7 @@ static void ieee80211_send_addba_resp(struct ieee80211_sub_if_data *sdata, u8 *d
 		return;
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
-	memset(mgmt, 0, 24);
+	mgmt = skb_put_zero(skb, 24);
 	memcpy(mgmt->da, da, ETH_ALEN);
 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
 	if (sdata->vif.type == NL80211_IFTYPE_AP ||
diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c
index 45319cc01121..1cddedf11033 100644
--- a/net/mac80211/agg-tx.c
+++ b/net/mac80211/agg-tx.c
@@ -76,8 +76,7 @@ static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
 		return;
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
-	memset(mgmt, 0, 24);
+	mgmt = skb_put_zero(skb, 24);
 	memcpy(mgmt->da, da, ETH_ALEN);
 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
 	if (sdata->vif.type == NL80211_IFTYPE_AP ||
@@ -125,8 +124,7 @@ void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)
 		return;
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
-	bar = (struct ieee80211_bar *)skb_put(skb, sizeof(*bar));
-	memset(bar, 0, sizeof(*bar));
+	bar = skb_put_zero(skb, sizeof(*bar));
 	bar->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |
 					 IEEE80211_STYPE_BACK_REQ);
 	memcpy(bar->ra, ra, ETH_ALEN);
diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c
index 8f5fff8b2040..c813207bb123 100644
--- a/net/mac80211/debugfs_netdev.c
+++ b/net/mac80211/debugfs_netdev.c
@@ -330,8 +330,7 @@ static ssize_t ieee80211_if_parse_tkip_mic_test(
 		return -ENOMEM;
 	skb_reserve(skb, local->hw.extra_tx_headroom);
 
-	hdr = (struct ieee80211_hdr *) skb_put(skb, 24);
-	memset(hdr, 0, 24);
+	hdr = skb_put_zero(skb, 24);
 	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);
 
 	switch (sdata->vif.type) {
@@ -367,7 +366,7 @@ static ssize_t ieee80211_if_parse_tkip_mic_test(
 	 * The exact contents does not matter since the recipient is required
 	 * to drop this because of the Michael MIC failure.
 	 */
-	memset(skb_put(skb, 50), 0, 50);
+	skb_put_zero(skb, 50);
 
 	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_TKIP_MIC_FAILURE;
 
diff --git a/net/mac80211/ht.c b/net/mac80211/ht.c
index f4a528773563..ed5eb446153f 100644
--- a/net/mac80211/ht.c
+++ b/net/mac80211/ht.c
@@ -374,8 +374,7 @@ void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
 		return;
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
-	memset(mgmt, 0, 24);
+	mgmt = skb_put_zero(skb, 24);
 	memcpy(mgmt->da, da, ETH_ALEN);
 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
 	if (sdata->vif.type == NL80211_IFTYPE_AP ||
diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c
index 6e7b6a07b7d5..b92b12aef931 100644
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -709,8 +709,7 @@ ieee80211_mesh_build_beacon(struct ieee80211_if_mesh *ifmsh)
 	bcn->head = ((u8 *) bcn) + sizeof(*bcn);
 
 	/* fill in the head */
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);
-	memset(mgmt, 0, hdr_len);
+	mgmt = skb_put_zero(skb, hdr_len);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					  IEEE80211_STYPE_BEACON);
 	eth_broadcast_addr(mgmt->da);
diff --git a/net/mac80211/mesh_hwmp.c b/net/mac80211/mesh_hwmp.c
index b747c9645e43..8a7d76e3d188 100644
--- a/net/mac80211/mesh_hwmp.c
+++ b/net/mac80211/mesh_hwmp.c
@@ -119,8 +119,7 @@ static int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,
 	if (!skb)
 		return -1;
 	skb_reserve(skb, local->tx_headroom);
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);
-	memset(mgmt, 0, hdr_len);
+	mgmt = skb_put_zero(skb, hdr_len);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					  IEEE80211_STYPE_ACTION);
 
@@ -256,8 +255,7 @@ int mesh_path_error_tx(struct ieee80211_sub_if_data *sdata,
 	if (!skb)
 		return -1;
 	skb_reserve(skb, local->tx_headroom + sdata->encrypt_headroom);
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);
-	memset(mgmt, 0, hdr_len);
+	mgmt = skb_put_zero(skb, hdr_len);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					  IEEE80211_STYPE_ACTION);
 
diff --git a/net/mac80211/mesh_plink.c b/net/mac80211/mesh_plink.c
index fcba70e57073..c0c99b79ae07 100644
--- a/net/mac80211/mesh_plink.c
+++ b/net/mac80211/mesh_plink.c
@@ -236,8 +236,7 @@ static int mesh_plink_frame_tx(struct ieee80211_sub_if_data *sdata,
 		return err;
 	info = IEEE80211_SKB_CB(skb);
 	skb_reserve(skb, local->tx_headroom);
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);
-	memset(mgmt, 0, hdr_len);
+	mgmt = skb_put_zero(skb, hdr_len);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					  IEEE80211_STYPE_ACTION);
 	memcpy(mgmt->da, da, ETH_ALEN);
diff --git a/net/mac80211/mesh_ps.c b/net/mac80211/mesh_ps.c
index 90a268abea17..96c987e641b3 100644
--- a/net/mac80211/mesh_ps.c
+++ b/net/mac80211/mesh_ps.c
@@ -39,7 +39,7 @@ static struct sk_buff *mps_qos_null_get(struct sta_info *sta)
 	nullfunc->seq_ctrl = 0;
 	/* no address resolution for this frame -> set addr 1 immediately */
 	memcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);
-	memset(skb_put(skb, 2), 0, 2); /* append QoS control field */
+	skb_put_zero(skb, 2); /* append QoS control field */
 	ieee80211_mps_set_frame_flags(sdata, sta, nullfunc);
 
 	return skb;
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 09a4a5a88fcf..a8c5f1ba3256 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -676,8 +676,7 @@ static void ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
 	if (ifmgd->flags & IEEE80211_STA_ENABLE_RRM)
 		capab |= WLAN_CAPABILITY_RADIO_MEASURE;
 
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
-	memset(mgmt, 0, 24);
+	mgmt = skb_put_zero(skb, 24);
 	memcpy(mgmt->da, assoc_data->bss->bssid, ETH_ALEN);
 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
 	memcpy(mgmt->bssid, assoc_data->bss->bssid, ETH_ALEN);
@@ -945,8 +944,7 @@ static void ieee80211_send_4addr_nullfunc(struct ieee80211_local *local,
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
 
-	nullfunc = (struct ieee80211_hdr *) skb_put(skb, 30);
-	memset(nullfunc, 0, 30);
+	nullfunc = skb_put_zero(skb, 30);
 	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC |
 			 IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);
 	nullfunc->frame_control = fc;
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index b5bcf5c606e4..5b34bc060b7a 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -2731,8 +2731,7 @@ static void ieee80211_process_sa_query_req(struct ieee80211_sub_if_data *sdata,
 		return;
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
-	resp = (struct ieee80211_mgmt *) skb_put(skb, 24);
-	memset(resp, 0, 24);
+	resp = skb_put_zero(skb, 24);
 	memcpy(resp->da, mgmt->sa, ETH_ALEN);
 	memcpy(resp->sa, sdata->vif.addr, ETH_ALEN);
 	memcpy(resp->bssid, sdata->u.mgd.bssid, ETH_ALEN);
diff --git a/net/mac80211/spectmgmt.c b/net/mac80211/spectmgmt.c
index 97f4c9d6b54c..db4cffee177a 100644
--- a/net/mac80211/spectmgmt.c
+++ b/net/mac80211/spectmgmt.c
@@ -186,8 +186,7 @@ static void ieee80211_send_refuse_measurement_request(struct ieee80211_sub_if_da
 		return;
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
-	msr_report = (struct ieee80211_mgmt *)skb_put(skb, 24);
-	memset(msr_report, 0, 24);
+	msr_report = skb_put_zero(skb, 24);
 	memcpy(msr_report->da, da, ETH_ALEN);
 	memcpy(msr_report->sa, sdata->vif.addr, ETH_ALEN);
 	memcpy(msr_report->bssid, bssid, ETH_ALEN);
diff --git a/net/mac80211/tdls.c b/net/mac80211/tdls.c
index afca7d103684..c697b077292c 100644
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@ -269,8 +269,7 @@ static void ieee80211_tdls_add_wmm_param_ie(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_tx_queue_params *txq;
 	int i;
 
-	wmm = (void *)skb_put(skb, sizeof(*wmm));
-	memset(wmm, 0, sizeof(*wmm));
+	wmm = skb_put_zero(skb, sizeof(*wmm));
 
 	wmm->element_id = WLAN_EID_VENDOR_SPECIFIC;
 	wmm->len = sizeof(*wmm) - 2;
@@ -829,8 +828,7 @@ ieee80211_prep_tdls_direct(struct wiphy *wiphy, struct net_device *dev,
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct ieee80211_mgmt *mgmt;
 
-	mgmt = (void *)skb_put(skb, 24);
-	memset(mgmt, 0, 24);
+	mgmt = skb_put_zero(skb, 24);
 	memcpy(mgmt->da, peer, ETH_ALEN);
 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
 	memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index ba8d7db0a071..c672fb9ef486 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -3041,7 +3041,7 @@ static bool ieee80211_amsdu_realloc_pad(struct ieee80211_local *local,
 
 	if (padding) {
 		*subframe_len += padding;
-		memset(skb_put(skb, padding), 0, padding);
+		skb_put_zero(skb, padding);
 	}
 
 	return true;
@@ -4368,8 +4368,7 @@ struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
 
-	pspoll = (struct ieee80211_pspoll *) skb_put(skb, sizeof(*pspoll));
-	memset(pspoll, 0, sizeof(*pspoll));
+	pspoll = skb_put_zero(skb, sizeof(*pspoll));
 	pspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |
 					    IEEE80211_STYPE_PSPOLL);
 	pspoll->aid = cpu_to_le16(ifmgd->aid);
@@ -4406,9 +4405,7 @@ struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
 
-	nullfunc = (struct ieee80211_hdr_3addr *) skb_put(skb,
-							  sizeof(*nullfunc));
-	memset(nullfunc, 0, sizeof(*nullfunc));
+	nullfunc = skb_put_zero(skb, sizeof(*nullfunc));
 	nullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
 					      IEEE80211_STYPE_NULLFUNC |
 					      IEEE80211_FCTL_TODS);
@@ -4440,8 +4437,7 @@ struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
 
 	skb_reserve(skb, local->hw.extra_tx_headroom);
 
-	hdr = (struct ieee80211_hdr_3addr *) skb_put(skb, sizeof(*hdr));
-	memset(hdr, 0, sizeof(*hdr));
+	hdr = skb_put_zero(skb, sizeof(*hdr));
 	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					 IEEE80211_STYPE_PROBE_REQ);
 	eth_broadcast_addr(hdr->addr1);
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index ac59fbd280df..8deea5d19d37 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -1237,8 +1237,7 @@ void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
 
 	skb_reserve(skb, local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN);
 
-	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24 + 6);
-	memset(mgmt, 0, 24 + 6);
+	mgmt = skb_put_zero(skb, 24 + 6);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					  IEEE80211_STYPE_AUTH);
 	memcpy(mgmt->da, da, ETH_ALEN);
@@ -2958,8 +2957,7 @@ int ieee80211_send_action_csa(struct ieee80211_sub_if_data *sdata,
 		return -ENOMEM;
 
 	skb_reserve(skb, local->tx_headroom);
-	mgmt = (struct ieee80211_mgmt *)skb_put(skb, hdr_len);
-	memset(mgmt, 0, hdr_len);
+	mgmt = skb_put_zero(skb, hdr_len);
 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					  IEEE80211_STYPE_ACTION);
 
* Unmerged path net/ncsi/ncsi-cmd.c
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index 30364aefec96..750cfe129f5a 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -411,7 +411,7 @@ static void pad_packet(struct datapath *dp, struct sk_buff *skb)
 		size_t plen = NLA_ALIGN(skb->len) - skb->len;
 
 		if (plen > 0)
-			memset(skb_put(skb, plen), 0, plen);
+			skb_put_zero(skb, plen);
 	}
 }
 
* Unmerged path net/qrtr/qrtr.c
* Unmerged path net/rxrpc/sendmsg.c
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 16f21de6025f..4119a2eb69d8 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -576,7 +576,7 @@ int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
 
 			padding = SCTP_PAD4(chunk->skb->len) - chunk->skb->len;
 			if (padding)
-				memset(skb_put(chunk->skb, padding), 0, padding);
+				skb_put_zero(chunk->skb, padding);
 
 			/* if this is the auth chunk that we are adding,
 			 * store pointer where it will be added and put
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 6ae26a49919a..fceca3b69365 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -1492,10 +1492,9 @@ void *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)
 	int chunklen = ntohs(chunk->chunk_hdr->length);
 	int padlen = SCTP_PAD4(chunklen) - chunklen;
 
-	padding = skb_put(chunk->skb, padlen);
+	padding = skb_put_zero(chunk->skb, padlen);
 	target = skb_put(chunk->skb, len);
 
-	memset(padding, 0, padlen);
 	memcpy(target, data, len);
 
 	/* Adjust the chunk length field.  */
