ipvs: update real-server binding of outgoing connections in SIP-pe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Marco Angaroni <marcoangaroni@gmail.com>
commit 3ec10d3a2ba591c87da94219c1e46b02ae97757a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3ec10d3a.failed

Previous patch that introduced handling of outgoing packets in SIP
persistent-engine did not call ip_vs_check_template() in case packet was
matching a connection template. Assumption was that real-server was
healthy, since it was sending a packet just in that moment.

There are however real-server fault conditions requiring that association
between call-id and real-server (represented by connection template)
gets updated. Here is an example of the sequence of events:
  1) RS1 is a back2back user agent that handled call-id1 and call-id2
  2) RS1 is down and was marked as unavailable
  3) new message from outside comes to IPVS with call-id1
  4) IPVS reschedules the message to RS2, which becomes new call handler
  5) RS2 forwards the message outside, translating call-id1 to call-id2
  6) inside pe->conn_out() IPVS matches call-id2 with existing template
  7) IPVS does not change association call-id2 <-> RS1
  8) new message comes from client with call-id2
  9) IPVS reschedules the message to a real-server potentially different
     from RS2, which is now the correct destination

This patch introduces ip_vs_check_template() call in the handling of
outgoing packets for SIP-pe. And also introduces a second optional
argument for ip_vs_check_template() that allows to check if dest
associated to a connection template is the same dest that was identified
as the source of the packet. This is to change the real-server bound to a
particular call-id independently from its availability status: the idea
is that it's more reliable, for in->out direction (where internal
network can be considered trusted), to always associate a call-id with
the last real-server that used it in one of its messages. Think about
above sequence of events where, just after step 5, RS1 returns instead
to be available.

Comparison of dests is done by simply comparing pointers to struct
ip_vs_dest; there should be no cases where struct ip_vs_dest keeps its
memory address, but represent a different real-server in terms of
ip-address / port.

Fixes: 39b972231536 ("ipvs: handle connections started by real-servers")
	Signed-off-by: Marco Angaroni <marcoangaroni@gmail.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit 3ec10d3a2ba591c87da94219c1e46b02ae97757a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_vs.h
#	net/netfilter/ipvs/ip_vs_core.c
diff --cc include/net/ip_vs.h
index e1599adc052f,cd6018a9ee24..000000000000
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@@ -1205,9 -1231,9 +1205,15 @@@ void ip_vs_conn_expire_now(struct ip_vs
  
  const char *ip_vs_state_name(__u16 proto, int state);
  
++<<<<<<< HEAD
 +void ip_vs_tcp_conn_listen(struct net *net, struct ip_vs_conn *cp);
 +int ip_vs_check_template(struct ip_vs_conn *ct);
 +void ip_vs_random_dropentry(struct net *net);
++=======
+ void ip_vs_tcp_conn_listen(struct ip_vs_conn *cp);
+ int ip_vs_check_template(struct ip_vs_conn *ct, struct ip_vs_dest *cdest);
+ void ip_vs_random_dropentry(struct netns_ipvs *ipvs);
++>>>>>>> 3ec10d3a2ba5 (ipvs: update real-server binding of outgoing connections in SIP-pe)
  int ip_vs_conn_init(void);
  void ip_vs_conn_cleanup(void);
  
diff --cc net/netfilter/ipvs/ip_vs_core.c
index f1576576eb85,2c1b498a7a27..000000000000
--- a/net/netfilter/ipvs/ip_vs_core.c
+++ b/net/netfilter/ipvs/ip_vs_core.c
@@@ -1051,6 -1104,144 +1051,147 @@@ static inline bool is_new_conn_expected
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /* Generic function to create new connections for outgoing RS packets
+  *
+  * Pre-requisites for successful connection creation:
+  * 1) Virtual Service is NOT fwmark based:
+  *    In fwmark-VS actual vaddr and vport are unknown to IPVS
+  * 2) Real Server and Virtual Service were NOT configured without port:
+  *    This is to allow match of different VS to the same RS ip-addr
+  */
+ struct ip_vs_conn *ip_vs_new_conn_out(struct ip_vs_service *svc,
+ 				      struct ip_vs_dest *dest,
+ 				      struct sk_buff *skb,
+ 				      const struct ip_vs_iphdr *iph,
+ 				      __be16 dport,
+ 				      __be16 cport)
+ {
+ 	struct ip_vs_conn_param param;
+ 	struct ip_vs_conn *ct = NULL, *cp = NULL;
+ 	const union nf_inet_addr *vaddr, *daddr, *caddr;
+ 	union nf_inet_addr snet;
+ 	__be16 vport;
+ 	unsigned int flags;
+ 
+ 	EnterFunction(12);
+ 	vaddr = &svc->addr;
+ 	vport = svc->port;
+ 	daddr = &iph->saddr;
+ 	caddr = &iph->daddr;
+ 
+ 	/* check pre-requisites are satisfied */
+ 	if (svc->fwmark)
+ 		return NULL;
+ 	if (!vport || !dport)
+ 		return NULL;
+ 
+ 	/* for persistent service first create connection template */
+ 	if (svc->flags & IP_VS_SVC_F_PERSISTENT) {
+ 		/* apply netmask the same way ingress-side does */
+ #ifdef CONFIG_IP_VS_IPV6
+ 		if (svc->af == AF_INET6)
+ 			ipv6_addr_prefix(&snet.in6, &caddr->in6,
+ 					 (__force __u32)svc->netmask);
+ 		else
+ #endif
+ 			snet.ip = caddr->ip & svc->netmask;
+ 		/* fill params and create template if not existent */
+ 		if (ip_vs_conn_fill_param_persist(svc, skb, iph->protocol,
+ 						  &snet, 0, vaddr,
+ 						  vport, &param) < 0)
+ 			return NULL;
+ 		ct = ip_vs_ct_in_get(&param);
+ 		/* check if template exists and points to the same dest */
+ 		if (!ct || !ip_vs_check_template(ct, dest)) {
+ 			ct = ip_vs_conn_new(&param, dest->af, daddr, dport,
+ 					    IP_VS_CONN_F_TEMPLATE, dest, 0);
+ 			if (!ct) {
+ 				kfree(param.pe_data);
+ 				return NULL;
+ 			}
+ 			ct->timeout = svc->timeout;
+ 		} else {
+ 			kfree(param.pe_data);
+ 		}
+ 	}
+ 
+ 	/* connection flags */
+ 	flags = ((svc->flags & IP_VS_SVC_F_ONEPACKET) &&
+ 		 iph->protocol == IPPROTO_UDP) ? IP_VS_CONN_F_ONE_PACKET : 0;
+ 	/* create connection */
+ 	ip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,
+ 			      caddr, cport, vaddr, vport, &param);
+ 	cp = ip_vs_conn_new(&param, dest->af, daddr, dport, flags, dest, 0);
+ 	if (!cp) {
+ 		if (ct)
+ 			ip_vs_conn_put(ct);
+ 		return NULL;
+ 	}
+ 	if (ct) {
+ 		ip_vs_control_add(cp, ct);
+ 		ip_vs_conn_put(ct);
+ 	}
+ 	ip_vs_conn_stats(cp, svc);
+ 
+ 	/* return connection (will be used to handle outgoing packet) */
+ 	IP_VS_DBG_BUF(6, "New connection RS-initiated:%c c:%s:%u v:%s:%u "
+ 		      "d:%s:%u conn->flags:%X conn->refcnt:%d\n",
+ 		      ip_vs_fwd_tag(cp),
+ 		      IP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),
+ 		      IP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),
+ 		      IP_VS_DBG_ADDR(cp->af, &cp->daddr), ntohs(cp->dport),
+ 		      cp->flags, atomic_read(&cp->refcnt));
+ 	LeaveFunction(12);
+ 	return cp;
+ }
+ 
+ /* Handle outgoing packets which are considered requests initiated by
+  * real servers, so that subsequent responses from external client can be
+  * routed to the right real server.
+  * Used also for outgoing responses in OPS mode.
+  *
+  * Connection management is handled by persistent-engine specific callback.
+  */
+ static struct ip_vs_conn *__ip_vs_rs_conn_out(unsigned int hooknum,
+ 					      struct netns_ipvs *ipvs,
+ 					      int af, struct sk_buff *skb,
+ 					      const struct ip_vs_iphdr *iph)
+ {
+ 	struct ip_vs_dest *dest;
+ 	struct ip_vs_conn *cp = NULL;
+ 	__be16 _ports[2], *pptr;
+ 
+ 	if (hooknum == NF_INET_LOCAL_IN)
+ 		return NULL;
+ 
+ 	pptr = frag_safe_skb_hp(skb, iph->len,
+ 				sizeof(_ports), _ports, iph);
+ 	if (!pptr)
+ 		return NULL;
+ 
+ 	rcu_read_lock();
+ 	dest = ip_vs_find_real_service(ipvs, af, iph->protocol,
+ 				       &iph->saddr, pptr[0]);
+ 	if (dest) {
+ 		struct ip_vs_service *svc;
+ 		struct ip_vs_pe *pe;
+ 
+ 		svc = rcu_dereference(dest->svc);
+ 		if (svc) {
+ 			pe = rcu_dereference(svc->pe);
+ 			if (pe && pe->conn_out)
+ 				cp = pe->conn_out(svc, dest, skb, iph,
+ 						  pptr[0], pptr[1]);
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return cp;
+ }
+ 
++>>>>>>> 3ec10d3a2ba5 (ipvs: update real-server binding of outgoing connections in SIP-pe)
  /* Handle response packets: rewrite addresses and send away...
   */
  static unsigned int
* Unmerged path include/net/ip_vs.h
diff --git a/net/netfilter/ipvs/ip_vs_conn.c b/net/netfilter/ipvs/ip_vs_conn.c
index 69b1996c49f4..5a9464ad9bc5 100644
--- a/net/netfilter/ipvs/ip_vs_conn.c
+++ b/net/netfilter/ipvs/ip_vs_conn.c
@@ -738,7 +738,7 @@ static int expire_quiescent_template(struct netns_ipvs *ipvs,
  *	If available, return 1, otherwise invalidate this connection
  *	template and return 0.
  */
-int ip_vs_check_template(struct ip_vs_conn *ct)
+int ip_vs_check_template(struct ip_vs_conn *ct, struct ip_vs_dest *cdest)
 {
 	struct ip_vs_dest *dest = ct->dest;
 	struct netns_ipvs *ipvs = net_ipvs(ip_vs_conn_net(ct));
@@ -748,7 +748,8 @@ int ip_vs_check_template(struct ip_vs_conn *ct)
 	 */
 	if ((dest == NULL) ||
 	    !(dest->flags & IP_VS_DEST_F_AVAILABLE) ||
-	    expire_quiescent_template(ipvs, dest)) {
+	    expire_quiescent_template(ipvs, dest) ||
+	    (cdest && (dest != cdest))) {
 		IP_VS_DBG_BUF(9, "check_template: dest not available for "
 			      "protocol %s s:%s:%d v:%s:%d "
 			      "-> d:%s:%d\n",
* Unmerged path net/netfilter/ipvs/ip_vs_core.c
