scsi: smartpqi: make ioaccel references consistent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] smartpqi: make ioaccel references consistent (Don Brace) [1457414]
Rebuild_FUZZ: 93.62%
commit-author Kevin Barnett <kevin.barnett@hpe.com>
commit 588a63fea1c28009fe17f194941fb8d8b101b44e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/588a63fe.failed

 - make all references to RAID bypass consistent throughout driver.

	Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 588a63fea1c28009fe17f194941fb8d8b101b44e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi_init.c
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index f2c47dadec6b,5f1c607905bf..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -1459,22 -1449,62 +1457,47 @@@ static enum pqi_find_result pqi_scsi_fi
  static void pqi_dev_info(struct pqi_ctrl_info *ctrl_info,
  	char *action, struct pqi_scsi_dev *device)
  {
 -	ssize_t count;
 -	char buffer[PQI_DEV_INFO_BUFFER_LENGTH];
 -
 -	count = snprintf(buffer, PQI_DEV_INFO_BUFFER_LENGTH,
 -		"%d:%d:", ctrl_info->scsi_host->host_no, device->bus);
 -
 -	if (device->target_lun_valid)
 -		count += snprintf(buffer + count,
 -			PQI_DEV_INFO_BUFFER_LENGTH - count,
 -			"%d:%d",
 -			device->target,
 -			device->lun);
 -	else
 -		count += snprintf(buffer + count,
 -			PQI_DEV_INFO_BUFFER_LENGTH - count,
 -			"-:-");
 -
 -	if (pqi_is_logical_device(device))
 -		count += snprintf(buffer + count,
 -			PQI_DEV_INFO_BUFFER_LENGTH - count,
 -			" %08x%08x",
 -			*((u32 *)&device->scsi3addr),
 -			*((u32 *)&device->scsi3addr[4]));
 -	else
 -		count += snprintf(buffer + count,
 -			PQI_DEV_INFO_BUFFER_LENGTH - count,
 -			" %016llx", device->sas_address);
 -
 -	count += snprintf(buffer + count, PQI_DEV_INFO_BUFFER_LENGTH - count,
 -		" %s %.8s %.16s ",
 +	dev_info(&ctrl_info->pci_dev->dev,
 +		"%s scsi %d:%d:%d:%d: %s %.8s %.16s %-12s SSDSmartPathCap%c En%c Exp%c qd=%d\n",
 +		action,
 +		ctrl_info->scsi_host->host_no,
 +		device->bus,
 +		device->target,
 +		device->lun,
  		scsi_device_type(device->devtype),
  		device->vendor,
++<<<<<<< HEAD
 +		device->model,
 +		pqi_is_logical_device(device) ?
 +			pqi_raid_level_to_string(device->raid_level) : "",
 +		device->offload_configured ? '+' : '-',
 +		device->offload_enabled_pending ? '+' : '-',
 +		device->expose_device ? '+' : '-',
 +		device->queue_depth);
++=======
+ 		device->model);
+ 
+ 	if (pqi_is_logical_device(device)) {
+ 		if (device->devtype == TYPE_DISK)
+ 			count += snprintf(buffer + count,
+ 				PQI_DEV_INFO_BUFFER_LENGTH - count,
+ 				"SSDSmartPathCap%c En%c %-12s",
+ 				device->raid_bypass_configured ? '+' : '-',
+ 				device->raid_bypass_enabled ? '+' : '-',
+ 				pqi_raid_level_to_string(device->raid_level));
+ 	} else {
+ 		count += snprintf(buffer + count,
+ 			PQI_DEV_INFO_BUFFER_LENGTH - count,
+ 			"AIO%c", device->aio_enabled ? '+' : '-');
+ 		if (device->devtype == TYPE_DISK ||
+ 			device->devtype == TYPE_ZBC)
+ 			count += snprintf(buffer + count,
+ 				PQI_DEV_INFO_BUFFER_LENGTH - count,
+ 				" qd=%-6d", device->queue_depth);
+ 	}
+ 
+ 	dev_info(&ctrl_info->pci_dev->dev, "%s %s\n", action, buffer);
++>>>>>>> 588a63fea1c2 (scsi: smartpqi: make ioaccel references consistent)
  }
  
  /* Assumes the SCSI device list lock is held. */
@@@ -1639,13 -1667,6 +1662,16 @@@ static void pqi_update_device_list(stru
  		device->keep_device = true;
  	}
  
++<<<<<<< HEAD
 +	pqi_update_all_logical_drive_queue_depths(ctrl_info);
 +
 +	list_for_each_entry(device, &ctrl_info->scsi_device_list,
 +		scsi_device_list_entry)
 +		device->offload_enabled =
 +			device->offload_enabled_pending;
 +
++=======
++>>>>>>> 588a63fea1c2 (scsi: smartpqi: make ioaccel references consistent)
  	spin_unlock_irqrestore(&ctrl_info->scsi_device_list_lock, flags);
  
  	/* Remove all devices that have gone away. */
@@@ -2428,10 -2440,11 +2454,15 @@@ static inline void pqi_aio_path_disable
  	struct pqi_scsi_dev *device;
  
  	device = io_request->scmd->device->hostdata;
++<<<<<<< HEAD
 +	device->offload_enabled = false;
++=======
+ 	device->raid_bypass_enabled = false;
+ 	device->aio_enabled = false;
++>>>>>>> 588a63fea1c2 (scsi: smartpqi: make ioaccel references consistent)
  }
  
 -static inline void pqi_take_device_offline(struct scsi_device *sdev, char *path)
 +static inline void pqi_take_device_offline(struct scsi_device *sdev)
  {
  	struct pqi_ctrl_info *ctrl_info;
  	struct pqi_scsi_dev *device;
@@@ -4782,14 -4994,11 +4813,19 @@@ static int pqi_scsi_queue_command(struc
  
  	if (pqi_is_logical_device(device)) {
  		raid_bypassed = false;
++<<<<<<< HEAD
 +		if (device->offload_enabled &&
 +			scmd->request->cmd_type == REQ_TYPE_FS) {
++=======
+ 		if (device->raid_bypass_enabled &&
+ 				!blk_rq_is_passthrough(scmd->request)) {
++>>>>>>> 588a63fea1c2 (scsi: smartpqi: make ioaccel references consistent)
  			rc = pqi_raid_bypass_submit_scsi_cmd(ctrl_info, device,
  				scmd, queue_group);
 -			if (rc == 0 || rc == SCSI_MLQUEUE_HOST_BUSY)
 +			if (rc == 0 ||
 +				rc == SCSI_MLQUEUE_HOST_BUSY ||
 +				rc == SAM_STAT_CHECK_CONDITION ||
 +				rc == SAM_STAT_RESERVATION_CONFLICT)
  				raid_bypassed = true;
  		}
  		if (!raid_bypassed)
diff --git a/drivers/scsi/smartpqi/smartpqi.h b/drivers/scsi/smartpqi/smartpqi.h
index 5acdb3969532..d11e72e3f95b 100644
--- a/drivers/scsi/smartpqi/smartpqi.h
+++ b/drivers/scsi/smartpqi/smartpqi.h
@@ -753,12 +753,11 @@ struct pqi_scsi_dev {
 	u8	bay;
 	u8	box[8];
 	u16	phys_connector[8];
-	int	offload_configured;	/* I/O accel RAID offload configured */
-	int	offload_enabled;	/* I/O accel RAID offload enabled */
-	int	offload_enabled_pending;
-	int	offload_to_mirror;	/* Send next I/O accelerator RAID */
-					/* offload request to mirror drive. */
-	struct raid_map *raid_map;	/* I/O accelerator RAID map */
+	bool	raid_bypass_configured;	/* RAID bypass configured */
+	bool	raid_bypass_enabled;	/* RAID bypass enabled */
+	int	offload_to_mirror;	/* Send next RAID bypass request */
+					/* to mirror drive. */
+	struct raid_map *raid_map;	/* RAID bypass map */
 
 	struct pqi_sas_port *sas_port;
 	struct scsi_device *sdev;
@@ -775,7 +774,7 @@ struct pqi_scsi_dev {
 #define SCSI_VPD_SUPPORTED_PAGES	0x0	/* standard page */
 #define SCSI_VPD_DEVICE_ID		0x83	/* standard page */
 #define CISS_VPD_LV_DEVICE_GEOMETRY	0xc1	/* vendor-specific page */
-#define CISS_VPD_LV_OFFLOAD_STATUS	0xc2	/* vendor-specific page */
+#define CISS_VPD_LV_BYPASS_STATUS	0xc2	/* vendor-specific page */
 #define CISS_VPD_LV_STATUS		0xc3	/* vendor-specific page */
 
 #define VPD_PAGE	(1 << 8)
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
