drm/ttm: fix ttm_bo_cleanup_refs_or_queue once more

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christian König <christian.koenig@amd.com>
commit 378e2d5b504fe0231c557751e58b80fcf717cc20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/378e2d5b.failed

With shared reservation objects __ttm_bo_reserve() can easily fail even on
destroyed BOs. This prevents correct handling when we need to individualize
the reservation object.

Fix this by individualizing the object before even trying to reserve it.

	Signed-off-by: Christian König <christian.koenig@amd.com>
	Acked-by: Chunming Zhou <david1.zhou@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 378e2d5b504fe0231c557751e58b80fcf717cc20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ttm/ttm_bo.c
diff --cc drivers/gpu/drm/ttm/ttm_bo.c
index 86e3b233b722,bee77d31895b..000000000000
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@@ -447,24 -438,32 +447,47 @@@ static void ttm_bo_cleanup_refs_or_queu
  {
  	struct ttm_bo_device *bdev = bo->bdev;
  	struct ttm_bo_global *glob = bo->glob;
 +	int put_count;
  	int ret;
  
+ 	ret = ttm_bo_individualize_resv(bo);
+ 	if (ret) {
+ 		/* Last resort, if we fail to allocate memory for the
+ 		 * fences block for the BO to become idle
+ 		 */
+ 		reservation_object_wait_timeout_rcu(bo->resv, true, false,
+ 						    30 * HZ);
+ 		spin_lock(&glob->lru_lock);
+ 		goto error;
+ 	}
+ 
  	spin_lock(&glob->lru_lock);
  	ret = __ttm_bo_reserve(bo, false, true, NULL);
- 
  	if (!ret) {
++<<<<<<< HEAD
 +		if (!ttm_bo_wait(bo, false, true)) {
 +			put_count = ttm_bo_del_from_lru(bo);
 +
 +			spin_unlock(&glob->lru_lock);
 +			ttm_bo_cleanup_memtype_use(bo);
 +
 +			ttm_bo_list_ref_sub(bo, put_count, true);
 +
 +			return;
 +		} else
 +			ttm_bo_flush_all_fences(bo);
++=======
+ 		if (reservation_object_test_signaled_rcu(&bo->ttm_resv, true)) {
+ 			ttm_bo_del_from_lru(bo);
+ 			spin_unlock(&glob->lru_lock);
+ 			if (bo->resv != &bo->ttm_resv)
+ 				reservation_object_unlock(&bo->ttm_resv);
+ 			ttm_bo_cleanup_memtype_use(bo);
+ 			return;
+ 		}
+ 
+ 		ttm_bo_flush_all_fences(bo);
++>>>>>>> 378e2d5b504f (drm/ttm: fix ttm_bo_cleanup_refs_or_queue once more)
  
  		/*
  		 * Make NO_EVICT bos immediately available to
* Unmerged path drivers/gpu/drm/ttm/ttm_bo.c
