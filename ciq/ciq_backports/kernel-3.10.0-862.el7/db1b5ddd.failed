IB/core: Rename uverbs event file structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matan Barak <matanb@mellanox.com>
commit db1b5ddd53365a07a7754803bdba370ebb84ba19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/db1b5ddd.failed

Previously, ib_uverbs_event_file was suffixed by _file as it contained
the actual file information. Since it's now only used as base struct
for ib_uverbs_async_event_file and ib_uverbs_completion_event_file,
we change its name to ib_uverbs_event_queue. This represents its
logical role better.

Fixes: 1e7710f3f656 ('IB/core: Change completion channel to use the reworked objects schema')
	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Reviewed-by: Sean Hefty <sean.hefty@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit db1b5ddd53365a07a7754803bdba370ebb84ba19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_main.c
#	drivers/infiniband/core/uverbs_std_types.c
diff --cc drivers/infiniband/core/uverbs.h
index e1bedf0bac04,a3230b6ab766..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -101,18 -102,26 +102,39 @@@ struct ib_uverbs_device 
  	struct list_head			uverbs_events_file_list;
  };
  
++<<<<<<< HEAD
 +struct ib_uverbs_event_file {
 +	struct kref				ref;
 +	int					is_async;
 +	struct ib_uverbs_file		       *uverbs_file;
++=======
+ struct ib_uverbs_event_queue {
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	spinlock_t				lock;
  	int					is_closed;
  	wait_queue_head_t			poll_wait;
  	struct fasync_struct		       *async_queue;
  	struct list_head			event_list;
++<<<<<<< HEAD
 +	struct list_head			list;
 +};
 +
++=======
+ };
+ 
+ struct ib_uverbs_async_event_file {
+ 	struct ib_uverbs_event_queue		ev_queue;
+ 	struct ib_uverbs_file		       *uverbs_file;
+ 	struct kref				ref;
+ 	struct list_head			list;
+ };
+ 
+ struct ib_uverbs_completion_event_file {
+ 	struct ib_uobject_file			uobj_file;
+ 	struct ib_uverbs_event_queue		ev_queue;
+ };
+ 
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  struct ib_uverbs_file {
  	struct kref				ref;
  	struct mutex				mutex;
@@@ -176,29 -191,14 +198,36 @@@ struct ib_ucq_object 
  	u32			async_events_reported;
  };
  
++<<<<<<< HEAD
 +extern spinlock_t ib_uverbs_idr_lock;
 +extern struct idr ib_uverbs_pd_idr;
 +extern struct idr ib_uverbs_mr_idr;
 +extern struct idr ib_uverbs_mw_idr;
 +extern struct idr ib_uverbs_ah_idr;
 +extern struct idr ib_uverbs_cq_idr;
 +extern struct idr ib_uverbs_qp_idr;
 +extern struct idr ib_uverbs_srq_idr;
 +extern struct idr ib_uverbs_xrcd_idr;
 +extern struct idr ib_uverbs_rule_idr;
 +extern struct idr ib_uverbs_wq_idr;
 +extern struct idr ib_uverbs_rwq_ind_tbl_idr;
 +
 +void idr_remove_uobj(struct idr *idp, struct ib_uobject *uobj);
 +
 +struct file *ib_uverbs_alloc_event_file(struct ib_uverbs_file *uverbs_file,
 +					struct ib_device *ib_dev,
 +					int is_async);
++=======
+ extern const struct file_operations uverbs_event_fops;
+ void ib_uverbs_init_event_queue(struct ib_uverbs_event_queue *ev_queue);
+ struct file *ib_uverbs_alloc_async_event_file(struct ib_uverbs_file *uverbs_file,
+ 					      struct ib_device *ib_dev);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  void ib_uverbs_free_async_event_file(struct ib_uverbs_file *uverbs_file);
 +struct ib_uverbs_event_file *ib_uverbs_lookup_comp_file(int fd);
  
  void ib_uverbs_release_ucq(struct ib_uverbs_file *file,
 -			   struct ib_uverbs_completion_event_file *ev_file,
 +			   struct ib_uverbs_event_file *ev_file,
  			   struct ib_ucq_object *uobj);
  void ib_uverbs_release_uevent(struct ib_uverbs_file *file,
  			      struct ib_uevent_object *uobj);
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 9f5575bf9d2c,e2fee045f03b..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -1333,16 -935,15 +1333,24 @@@ ssize_t ib_uverbs_create_comp_channel(s
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
 -	uobj = uobj_alloc(uobj_get_type(comp_channel), file->ucontext);
 -	if (IS_ERR(uobj))
 -		return PTR_ERR(uobj);
 +	ret = get_unused_fd_flags(O_CLOEXEC);
 +	if (ret < 0)
 +		return ret;
 +	resp.fd = ret;
  
++<<<<<<< HEAD
 +	filp = ib_uverbs_alloc_event_file(file, ib_dev, 0);
 +	if (IS_ERR(filp)) {
 +		put_unused_fd(resp.fd);
 +		return PTR_ERR(filp);
 +	}
++=======
+ 	resp.fd = uobj->id;
+ 
+ 	ev_file = container_of(uobj, struct ib_uverbs_completion_event_file,
+ 			       uobj_file.uobj);
+ 	ib_uverbs_init_event_queue(&ev_file->ev_queue);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  
  	if (copy_to_user((void __user *) (unsigned long) cmd.response,
  			 &resp, sizeof resp)) {
@@@ -1416,7 -1015,7 +1424,11 @@@ static struct ib_ucq_object *create_cq(
  	cq->uobject       = &obj->uobject;
  	cq->comp_handler  = ib_uverbs_comp_handler;
  	cq->event_handler = ib_uverbs_cq_event_handler;
++<<<<<<< HEAD
 +	cq->cq_context    = ev_file;
++=======
+ 	cq->cq_context    = &ev_file->ev_queue;
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	atomic_set(&cq->usecnt, 0);
  
  	obj->uobject.object = cq;
@@@ -1716,31 -1302,28 +1728,31 @@@ ssize_t ib_uverbs_destroy_cq(struct ib_
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
 -	uobj  = uobj_get_write(uobj_get_type(cq), cmd.cq_handle,
 -			       file->ucontext);
 -	if (IS_ERR(uobj))
 -		return PTR_ERR(uobj);
 -
 -	/*
 -	 * Make sure we don't free the memory in remove_commit as we still
 -	 * needs the uobject memory to create the response.
 -	 */
 -	uverbs_uobject_get(uobj);
 +	uobj = idr_write_uobj(&ib_uverbs_cq_idr, cmd.cq_handle, file->ucontext);
 +	if (!uobj)
 +		return -EINVAL;
  	cq      = uobj->object;
- 	ev_file = cq->cq_context;
+ 	ev_queue = cq->cq_context;
  	obj     = container_of(cq->uobject, struct ib_ucq_object, uobject);
  
 -	memset(&resp, 0, sizeof(resp));
 +	ret = ib_destroy_cq(cq);
 +	if (!ret)
 +		uobj->live = 0;
 +
 +	put_uobj_write(uobj);
  
 -	ret = uobj_remove_commit(uobj);
 -	if (ret) {
 -		uverbs_uobject_put(uobj);
 +	if (ret)
  		return ret;
 -	}
  
 +	idr_remove_uobj(&ib_uverbs_cq_idr, uobj);
 +
 +	mutex_lock(&file->mutex);
 +	list_del(&uobj->list);
 +	mutex_unlock(&file->mutex);
 +
 +	ib_uverbs_release_ucq(file, ev_file, obj);
 +
 +	memset(&resp, 0, sizeof resp);
  	resp.comp_events_reported  = obj->comp_events_reported;
  	resp.async_events_reported = obj->async_events_reported;
  
diff --cc drivers/infiniband/core/uverbs_main.c
index 1b7098d63376,3a9883d1257e..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -182,22 -171,22 +182,38 @@@ void ib_uverbs_release_ucq(struct ib_uv
  	struct ib_uverbs_event *evt, *tmp;
  
  	if (ev_file) {
++<<<<<<< HEAD
 +		spin_lock_irq(&ev_file->lock);
++=======
+ 		spin_lock_irq(&ev_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  		list_for_each_entry_safe(evt, tmp, &uobj->comp_list, obj_list) {
  			list_del(&evt->list);
  			kfree(evt);
  		}
++<<<<<<< HEAD
 +		spin_unlock_irq(&ev_file->lock);
++=======
+ 		spin_unlock_irq(&ev_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  
 -		uverbs_uobject_put(&ev_file->uobj_file.uobj);
 +		kref_put(&ev_file->ref, ib_uverbs_release_event_file);
  	}
  
++<<<<<<< HEAD
 +	spin_lock_irq(&file->async_file->lock);
++=======
+ 	spin_lock_irq(&file->async_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	list_for_each_entry_safe(evt, tmp, &uobj->async_list, obj_list) {
  		list_del(&evt->list);
  		kfree(evt);
  	}
++<<<<<<< HEAD
 +	spin_unlock_irq(&file->async_file->lock);
++=======
+ 	spin_unlock_irq(&file->async_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  }
  
  void ib_uverbs_release_uevent(struct ib_uverbs_file *file,
@@@ -205,16 -194,16 +221,24 @@@
  {
  	struct ib_uverbs_event *evt, *tmp;
  
++<<<<<<< HEAD
 +	spin_lock_irq(&file->async_file->lock);
++=======
+ 	spin_lock_irq(&file->async_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	list_for_each_entry_safe(evt, tmp, &uobj->event_list, obj_list) {
  		list_del(&evt->list);
  		kfree(evt);
  	}
++<<<<<<< HEAD
 +	spin_unlock_irq(&file->async_file->lock);
++=======
+ 	spin_unlock_irq(&file->async_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  }
  
 -void ib_uverbs_detach_umcast(struct ib_qp *qp,
 -			     struct ib_uqp_object *uobj)
 +static void ib_uverbs_detach_umcast(struct ib_qp *qp,
 +				    struct ib_uqp_object *uobj)
  {
  	struct ib_uverbs_mcast_entry *mcast, *tmp;
  
@@@ -372,18 -253,19 +396,26 @@@ static void ib_uverbs_release_file(stru
  	kfree(file);
  }
  
++<<<<<<< HEAD
 +static ssize_t ib_uverbs_event_read(struct file *filp, char __user *buf,
 +				    size_t count, loff_t *pos)
++=======
+ static ssize_t ib_uverbs_event_read(struct ib_uverbs_event_queue *ev_queue,
+ 				    struct ib_uverbs_file *uverbs_file,
+ 				    struct file *filp, char __user *buf,
+ 				    size_t count, loff_t *pos,
+ 				    size_t eventsz)
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  {
 +	struct ib_uverbs_event_file *file = filp->private_data;
  	struct ib_uverbs_event *event;
 +	int eventsz;
  	int ret = 0;
  
- 	spin_lock_irq(&file->lock);
+ 	spin_lock_irq(&ev_queue->lock);
  
- 	while (list_empty(&file->event_list)) {
- 		spin_unlock_irq(&file->lock);
+ 	while (list_empty(&ev_queue->event_list)) {
+ 		spin_unlock_irq(&ev_queue->lock);
  
  		if (filp->f_flags & O_NONBLOCK)
  			return -EAGAIN;
@@@ -398,20 -280,15 +430,25 @@@
  			return -ERESTARTSYS;
  
  		/* If device was disassociated and no event exists set an error */
++<<<<<<< HEAD
 +		if (list_empty(&file->event_list) &&
 +		    !file->uverbs_file->device->ib_dev)
++=======
+ 		if (list_empty(&ev_queue->event_list) &&
+ 		    !uverbs_file->device->ib_dev)
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  			return -EIO;
  
- 		spin_lock_irq(&file->lock);
+ 		spin_lock_irq(&ev_queue->lock);
  	}
  
- 	event = list_entry(file->event_list.next, struct ib_uverbs_event, list);
+ 	event = list_entry(ev_queue->event_list.next, struct ib_uverbs_event, list);
  
 +	if (file->is_async)
 +		eventsz = sizeof (struct ib_uverbs_async_event_desc);
 +	else
 +		eventsz = sizeof (struct ib_uverbs_comp_event_desc);
 +
  	if (eventsz > count) {
  		ret   = -EINVAL;
  		event = NULL;
@@@ -437,65 -314,136 +474,158 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static unsigned int ib_uverbs_event_poll(struct file *filp,
++=======
+ static ssize_t ib_uverbs_async_event_read(struct file *filp, char __user *buf,
+ 					  size_t count, loff_t *pos)
+ {
+ 	struct ib_uverbs_async_event_file *file = filp->private_data;
+ 
+ 	return ib_uverbs_event_read(&file->ev_queue, file->uverbs_file, filp,
+ 				    buf, count, pos,
+ 				    sizeof(struct ib_uverbs_async_event_desc));
+ }
+ 
+ static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
+ 					 size_t count, loff_t *pos)
+ {
+ 	struct ib_uverbs_completion_event_file *comp_ev_file =
+ 		filp->private_data;
+ 
+ 	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
+ 				    comp_ev_file->uobj_file.ufile, filp,
+ 				    buf, count, pos,
+ 				    sizeof(struct ib_uverbs_comp_event_desc));
+ }
+ 
+ static unsigned int ib_uverbs_event_poll(struct ib_uverbs_event_queue *ev_queue,
+ 					 struct file *filp,
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  					 struct poll_table_struct *wait)
  {
  	unsigned int pollflags = 0;
 +	struct ib_uverbs_event_file *file = filp->private_data;
  
- 	poll_wait(filp, &file->poll_wait, wait);
+ 	poll_wait(filp, &ev_queue->poll_wait, wait);
  
- 	spin_lock_irq(&file->lock);
- 	if (!list_empty(&file->event_list))
+ 	spin_lock_irq(&ev_queue->lock);
+ 	if (!list_empty(&ev_queue->event_list))
  		pollflags = POLLIN | POLLRDNORM;
- 	spin_unlock_irq(&file->lock);
+ 	spin_unlock_irq(&ev_queue->lock);
  
  	return pollflags;
  }
  
++<<<<<<< HEAD
 +static int ib_uverbs_event_fasync(int fd, struct file *filp, int on)
++=======
+ static unsigned int ib_uverbs_async_event_poll(struct file *filp,
+ 					       struct poll_table_struct *wait)
  {
- 	struct ib_uverbs_event_file *file = filp->private_data;
+ 	return ib_uverbs_event_poll(filp->private_data, filp, wait);
+ }
+ 
+ static unsigned int ib_uverbs_comp_event_poll(struct file *filp,
+ 					      struct poll_table_struct *wait)
+ {
+ 	struct ib_uverbs_completion_event_file *comp_ev_file =
+ 		filp->private_data;
+ 
+ 	return ib_uverbs_event_poll(&comp_ev_file->ev_queue, filp, wait);
+ }
  
- 	return fasync_helper(fd, filp, on, &file->async_queue);
+ static int ib_uverbs_async_event_fasync(int fd, struct file *filp, int on)
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
+ {
+ 	struct ib_uverbs_event_queue *ev_queue = filp->private_data;
+ 
+ 	return fasync_helper(fd, filp, on, &ev_queue->async_queue);
  }
  
 -static int ib_uverbs_comp_event_fasync(int fd, struct file *filp, int on)
 +static int ib_uverbs_event_close(struct inode *inode, struct file *filp)
  {
++<<<<<<< HEAD
 +	struct ib_uverbs_event_file *file = filp->private_data;
 +	struct ib_uverbs_event *entry, *tmp;
 +	int closed_already = 0;
 +
 +	mutex_lock(&file->uverbs_file->device->lists_mutex);
 +	spin_lock_irq(&file->lock);
 +	closed_already = file->is_closed;
 +	file->is_closed = 1;
 +	list_for_each_entry_safe(entry, tmp, &file->event_list, list) {
++=======
+ 	struct ib_uverbs_completion_event_file *comp_ev_file =
+ 		filp->private_data;
+ 
+ 	return fasync_helper(fd, filp, on, &comp_ev_file->ev_queue.async_queue);
+ }
+ 
+ static int ib_uverbs_async_event_close(struct inode *inode, struct file *filp)
+ {
+ 	struct ib_uverbs_async_event_file *file = filp->private_data;
+ 	struct ib_uverbs_file *uverbs_file = file->uverbs_file;
+ 	struct ib_uverbs_event *entry, *tmp;
+ 	int closed_already = 0;
+ 
+ 	mutex_lock(&uverbs_file->device->lists_mutex);
+ 	spin_lock_irq(&file->ev_queue.lock);
+ 	closed_already = file->ev_queue.is_closed;
+ 	file->ev_queue.is_closed = 1;
+ 	list_for_each_entry_safe(entry, tmp, &file->ev_queue.event_list, list) {
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  		if (entry->counter)
  			list_del(&entry->obj_list);
  		kfree(entry);
  	}
++<<<<<<< HEAD
 +	spin_unlock_irq(&file->lock);
++=======
+ 	spin_unlock_irq(&file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	if (!closed_already) {
  		list_del(&file->list);
 -		ib_unregister_event_handler(&uverbs_file->event_handler);
 +		if (file->is_async)
 +			ib_unregister_event_handler(&file->uverbs_file->
 +				event_handler);
  	}
 -	mutex_unlock(&uverbs_file->device->lists_mutex);
 +	mutex_unlock(&file->uverbs_file->device->lists_mutex);
  
 -	kref_put(&uverbs_file->ref, ib_uverbs_release_file);
 -	kref_put(&file->ref, ib_uverbs_release_async_event_file);
 +	kref_put(&file->uverbs_file->ref, ib_uverbs_release_file);
 +	kref_put(&file->ref, ib_uverbs_release_event_file);
  
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct file_operations uverbs_event_fops = {
++=======
+ static int ib_uverbs_comp_event_close(struct inode *inode, struct file *filp)
+ {
+ 	struct ib_uverbs_completion_event_file *file = filp->private_data;
+ 	struct ib_uverbs_event *entry, *tmp;
+ 
+ 	spin_lock_irq(&file->ev_queue.lock);
+ 	list_for_each_entry_safe(entry, tmp, &file->ev_queue.event_list, list) {
+ 		if (entry->counter)
+ 			list_del(&entry->obj_list);
+ 		kfree(entry);
+ 	}
+ 	spin_unlock_irq(&file->ev_queue.lock);
+ 
+ 	uverbs_close_fd(filp);
+ 
+ 	return 0;
+ }
+ 
+ const struct file_operations uverbs_event_fops = {
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	.owner	 = THIS_MODULE,
 -	.read	 = ib_uverbs_comp_event_read,
 -	.poll    = ib_uverbs_comp_event_poll,
 -	.release = ib_uverbs_comp_event_close,
 -	.fasync  = ib_uverbs_comp_event_fasync,
 -	.llseek	 = no_llseek,
 -};
 -
 -static const struct file_operations uverbs_async_event_fops = {
 -	.owner	 = THIS_MODULE,
 -	.read	 = ib_uverbs_async_event_read,
 -	.poll    = ib_uverbs_async_event_poll,
 -	.release = ib_uverbs_async_event_close,
 -	.fasync  = ib_uverbs_async_event_fasync,
 +	.read	 = ib_uverbs_event_read,
 +	.poll    = ib_uverbs_event_poll,
 +	.release = ib_uverbs_event_close,
 +	.fasync  = ib_uverbs_event_fasync,
  	.llseek	 = no_llseek,
  };
  
@@@ -542,15 -490,15 +672,25 @@@ static void ib_uverbs_async_handler(str
  	struct ib_uverbs_event *entry;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&file->async_file->lock, flags);
 +	if (file->async_file->is_closed) {
 +		spin_unlock_irqrestore(&file->async_file->lock, flags);
++=======
+ 	spin_lock_irqsave(&file->async_file->ev_queue.lock, flags);
+ 	if (file->async_file->ev_queue.is_closed) {
+ 		spin_unlock_irqrestore(&file->async_file->ev_queue.lock, flags);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  		return;
  	}
  
  	entry = kmalloc(sizeof *entry, GFP_ATOMIC);
  	if (!entry) {
++<<<<<<< HEAD
 +		spin_unlock_irqrestore(&file->async_file->lock, flags);
++=======
+ 		spin_unlock_irqrestore(&file->async_file->ev_queue.lock, flags);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  		return;
  	}
  
@@@ -559,13 -507,13 +699,23 @@@
  	entry->desc.async.reserved   = 0;
  	entry->counter               = counter;
  
++<<<<<<< HEAD
 +	list_add_tail(&entry->list, &file->async_file->event_list);
 +	if (obj_list)
 +		list_add_tail(&entry->obj_list, obj_list);
 +	spin_unlock_irqrestore(&file->async_file->lock, flags);
 +
 +	wake_up_interruptible(&file->async_file->poll_wait);
 +	kill_fasync(&file->async_file->async_queue, SIGIO, POLL_IN);
++=======
+ 	list_add_tail(&entry->list, &file->async_file->ev_queue.event_list);
+ 	if (obj_list)
+ 		list_add_tail(&entry->obj_list, obj_list);
+ 	spin_unlock_irqrestore(&file->async_file->ev_queue.lock, flags);
+ 
+ 	wake_up_interruptible(&file->async_file->ev_queue.poll_wait);
+ 	kill_fasync(&file->async_file->ev_queue.async_queue, SIGIO, POLL_IN);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  }
  
  void ib_uverbs_cq_event_handler(struct ib_event *event, void *context_ptr)
@@@ -632,11 -580,19 +782,27 @@@ void ib_uverbs_free_async_event_file(st
  	file->async_file = NULL;
  }
  
++<<<<<<< HEAD
 +struct file *ib_uverbs_alloc_event_file(struct ib_uverbs_file *uverbs_file,
 +					struct ib_device	*ib_dev,
 +					int is_async)
 +{
 +	struct ib_uverbs_event_file *ev_file;
++=======
+ void ib_uverbs_init_event_queue(struct ib_uverbs_event_queue *ev_queue)
+ {
+ 	spin_lock_init(&ev_queue->lock);
+ 	INIT_LIST_HEAD(&ev_queue->event_list);
+ 	init_waitqueue_head(&ev_queue->poll_wait);
+ 	ev_queue->is_closed   = 0;
+ 	ev_queue->async_queue = NULL;
+ }
+ 
+ struct file *ib_uverbs_alloc_async_event_file(struct ib_uverbs_file *uverbs_file,
+ 					      struct ib_device	*ib_dev)
+ {
+ 	struct ib_uverbs_async_event_file *ev_file;
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	struct file *filp;
  	int ret;
  
@@@ -644,16 -600,11 +810,20 @@@
  	if (!ev_file)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	kref_init(&ev_file->ref);
 +	spin_lock_init(&ev_file->lock);
 +	INIT_LIST_HEAD(&ev_file->event_list);
 +	init_waitqueue_head(&ev_file->poll_wait);
++=======
+ 	ib_uverbs_init_event_queue(&ev_file->ev_queue);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	ev_file->uverbs_file = uverbs_file;
  	kref_get(&ev_file->uverbs_file->ref);
 -	kref_init(&ev_file->ref);
 -	filp = anon_inode_getfile("[infinibandevent]", &uverbs_async_event_fops,
 +	ev_file->async_queue = NULL;
 +	ev_file->is_closed   = 0;
 +
 +	filp = anon_inode_getfile("[infinibandevent]", &uverbs_event_fops,
  				  ev_file, O_RDONLY);
  	if (IS_ERR(filp))
  		goto err_put_refs;
@@@ -1258,21 -1184,20 +1428,32 @@@ static void ib_uverbs_free_hw_resources
  	while (!list_empty(&uverbs_dev->uverbs_events_file_list)) {
  		event_file = list_first_entry(&uverbs_dev->
  					      uverbs_events_file_list,
 -					      struct ib_uverbs_async_event_file,
 +					      struct ib_uverbs_event_file,
  					      list);
++<<<<<<< HEAD
 +		spin_lock_irq(&event_file->lock);
 +		event_file->is_closed = 1;
 +		spin_unlock_irq(&event_file->lock);
++=======
+ 		spin_lock_irq(&event_file->ev_queue.lock);
+ 		event_file->ev_queue.is_closed = 1;
+ 		spin_unlock_irq(&event_file->ev_queue.lock);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  
  		list_del(&event_file->list);
 -		ib_unregister_event_handler(
 -			&event_file->uverbs_file->event_handler);
 -		event_file->uverbs_file->event_handler.device =
 -			NULL;
 +		if (event_file->is_async) {
 +			ib_unregister_event_handler(&event_file->uverbs_file->
 +						    event_handler);
 +			event_file->uverbs_file->event_handler.device = NULL;
 +		}
  
++<<<<<<< HEAD
 +		wake_up_interruptible(&event_file->poll_wait);
 +		kill_fasync(&event_file->async_queue, SIGIO, POLL_IN);
++=======
+ 		wake_up_interruptible(&event_file->ev_queue.poll_wait);
+ 		kill_fasync(&event_file->ev_queue.async_queue, SIGIO, POLL_IN);
++>>>>>>> db1b5ddd5336 (IB/core: Rename uverbs event file structure)
  	}
  	mutex_unlock(&uverbs_dev->lists_mutex);
  }
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_main.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
