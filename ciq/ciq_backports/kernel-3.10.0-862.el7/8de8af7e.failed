Drivers: hv: vmbus: Move the extracting of Hypervisor version information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Move the extracting of Hypervisor version information (Vitaly Kuznetsov) [1410023]
Rebuild_FUZZ: 90.23%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 8de8af7e0873c4fdac2205327dff922819e16657
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8de8af7e.failed

As part of the effort to separate out architecture specific code,
extract hypervisor version information in an architecture specific
file.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8de8af7e0873c4fdac2205327dff922819e16657)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/hv.c
#	drivers/hv/hyperv_vmbus.h
diff --cc drivers/hv/hv.c
index f6a591c69dfd,9985a347ed03..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -43,103 -43,6 +43,106 @@@ struct hv_context hv_context = 
  #define HV_MIN_DELTA_TICKS 1
  
  /*
++<<<<<<< HEAD
 + * query_hypervisor_info - Get version info of the windows hypervisor
 + */
 +unsigned int host_info_eax;
 +unsigned int host_info_ebx;
 +unsigned int host_info_ecx;
 +unsigned int host_info_edx;
 +
 +static int query_hypervisor_info(void)
 +{
 +	unsigned int eax;
 +	unsigned int ebx;
 +	unsigned int ecx;
 +	unsigned int edx;
 +	unsigned int max_leaf;
 +	unsigned int op;
 +
 +	/*
 +	* Its assumed that this is called after confirming that Viridian
 +	* is present. Query id and revision.
 +	*/
 +	eax = 0;
 +	ebx = 0;
 +	ecx = 0;
 +	edx = 0;
 +	op = HVCPUID_VENDOR_MAXFUNCTION;
 +	cpuid(op, &eax, &ebx, &ecx, &edx);
 +
 +	max_leaf = eax;
 +
 +	if (max_leaf >= HVCPUID_VERSION) {
 +		eax = 0;
 +		ebx = 0;
 +		ecx = 0;
 +		edx = 0;
 +		op = HVCPUID_VERSION;
 +		cpuid(op, &eax, &ebx, &ecx, &edx);
 +		host_info_eax = eax;
 +		host_info_ebx = ebx;
 +		host_info_ecx = ecx;
 +		host_info_edx = edx;
 +	}
 +	return max_leaf;
 +}
 +
 +#ifdef CONFIG_X86_64
 +static cycle_t read_hv_clock_tsc(struct clocksource *arg)
 +{
 +	cycle_t current_tick;
 +	struct ms_hyperv_tsc_page *tsc_pg = hv_context.tsc_page;
 +
 +	if (tsc_pg->tsc_sequence != 0) {
 +		/*
 +		 * Use the tsc page to compute the value.
 +		 */
 +
 +		while (1) {
 +			cycle_t tmp;
 +			u32 sequence = tsc_pg->tsc_sequence;
 +			u64 cur_tsc;
 +			u64 scale = tsc_pg->tsc_scale;
 +			s64 offset = tsc_pg->tsc_offset;
 +
 +			cur_tsc = rdtsc();
 +			/* current_tick = ((cur_tsc *scale) >> 64) + offset */
 +			asm("mulq %3"
 +				: "=d" (current_tick), "=a" (tmp)
 +				: "a" (cur_tsc), "r" (scale));
 +
 +			current_tick += offset;
 +			if (tsc_pg->tsc_sequence == sequence)
 +				return current_tick;
 +
 +			if (tsc_pg->tsc_sequence != 0)
 +				continue;
 +			/*
 +			 * Fallback using MSR method.
 +			 */
 +			break;
 +		}
 +	}
 +	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 +	return current_tick;
 +}
 +
 +static struct clocksource hyperv_cs_tsc = {
 +		.name           = "hyperv_clocksource_tsc_page",
 +		.rating         = 425,
 +		.read           = read_hv_clock_tsc,
 +		.mask           = CLOCKSOURCE_MASK(64),
 +		.flags          = CLOCK_SOURCE_IS_CONTINUOUS,
 +};
 +
 +static struct clocksource *hyperv_cs_old;
 +#endif
 +
 +
 +/*
++=======
++>>>>>>> 8de8af7e0873 (Drivers: hv: vmbus: Move the extracting of Hypervisor version information)
   * hv_init - Main initialization routine.
   *
   * This routine must be called before any other routines in here are called
diff --cc drivers/hv/hyperv_vmbus.h
index 058c591c09f6,a7e35c842fed..000000000000
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@@ -544,20 -425,6 +525,23 @@@ extern int hv_synic_cleanup(unsigned in
  
  extern void hv_synic_clockevents_cleanup(void);
  
++<<<<<<< HEAD
 +extern void hv_clockevents_bind(int cpu);
 +
 +extern void hv_clockevents_unbind(int cpu);
 +
 +extern int hv_synic_cpu_used(unsigned int cpu);
 +
 +/*
 + * Host version information.
 + */
 +extern unsigned int host_info_eax;
 +extern unsigned int host_info_ebx;
 +extern unsigned int host_info_ecx;
 +extern unsigned int host_info_edx;
 +
++=======
++>>>>>>> 8de8af7e0873 (Drivers: hv: vmbus: Move the extracting of Hypervisor version information)
  /* Interface */
  
  
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 766df316b67a..2db328503780 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -6,6 +6,25 @@
 #include <linux/clocksource.h>
 #include <asm/hyperv.h>
 
+/*
+ * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
+ * is set by CPUID(HVCPUID_VERSION_FEATURES).
+ */
+enum hv_cpuid_function {
+	HVCPUID_VERSION_FEATURES		= 0x00000001,
+	HVCPUID_VENDOR_MAXFUNCTION		= 0x40000000,
+	HVCPUID_INTERFACE			= 0x40000001,
+
+	/*
+	 * The remaining functions depend on the value of
+	 * HVCPUID_INTERFACE
+	 */
+	HVCPUID_VERSION				= 0x40000002,
+	HVCPUID_FEATURES			= 0x40000003,
+	HVCPUID_ENLIGHTENMENT_INFO		= 0x40000004,
+	HVCPUID_IMPLEMENTATION_LIMITS		= 0x40000005,
+};
+
 struct ms_hyperv_info {
 	u32 features;
 	u32 misc_features;
diff --git a/arch/x86/kernel/cpu/mshyperv.c b/arch/x86/kernel/cpu/mshyperv.c
index 13eadd65c578..23b28747c964 100644
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@ -163,6 +163,11 @@ static unsigned char hv_get_nmi_reason(void)
 
 static void __init ms_hyperv_init_platform(void)
 {
+	int hv_host_info_eax;
+	int hv_host_info_ebx;
+	int hv_host_info_ecx;
+	int hv_host_info_edx;
+
 	/*
 	 * Extract the features and hints
 	 */
@@ -173,6 +178,21 @@ static void __init ms_hyperv_init_platform(void)
 	printk(KERN_INFO "HyperV: features 0x%x, hints 0x%x\n",
 	       ms_hyperv.features, ms_hyperv.hints);
 
+	/*
+	 * Extract host information.
+	 */
+	if (cpuid_eax(HVCPUID_VENDOR_MAXFUNCTION) >= HVCPUID_VERSION) {
+		hv_host_info_eax = cpuid_eax(HVCPUID_VERSION);
+		hv_host_info_ebx = cpuid_ebx(HVCPUID_VERSION);
+		hv_host_info_ecx = cpuid_ecx(HVCPUID_VERSION);
+		hv_host_info_edx = cpuid_edx(HVCPUID_VERSION);
+
+		pr_info("Hyper-V Host Build:%d-%d.%d-%d-%d.%d\n",
+			hv_host_info_eax, hv_host_info_ebx >> 16,
+			hv_host_info_ebx & 0xFFFF, hv_host_info_ecx,
+			hv_host_info_edx >> 24, hv_host_info_edx & 0xFFFFFF);
+	}
+
 #ifdef CONFIG_X86_LOCAL_APIC
 	if (ms_hyperv.features & HV_X64_MSR_APIC_FREQUENCY_AVAILABLE) {
 		/*
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 9b72ebcd37bc..307a5a8937f6 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -221,11 +221,8 @@ int vmbus_connect(void)
 		goto cleanup;
 
 	vmbus_proto_version = version;
-	pr_info("Hyper-V Host Build:%d-%d.%d-%d-%d.%d; Vmbus version:%d.%d\n",
-		    host_info_eax, host_info_ebx >> 16,
-		    host_info_ebx & 0xFFFF, host_info_ecx,
-		    host_info_edx >> 24, host_info_edx & 0xFFFFFF,
-		    version >> 16, version & 0xFFFF);
+	pr_info("Vmbus version:%d.%d\n",
+		version >> 16, version & 0xFFFF);
 
 	kfree(msginfo);
 	return 0;
* Unmerged path drivers/hv/hv.c
* Unmerged path drivers/hv/hyperv_vmbus.h
