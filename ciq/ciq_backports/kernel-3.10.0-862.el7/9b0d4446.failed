net: sched: avoid atomic swap in tcf_exts_change

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: avoid atomic swap in tcf_exts_change (Ivan Vecera) [1445420]
Rebuild_FUZZ: 94.51%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 9b0d4446b56904b59ae3809913b0ac760fa941a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9b0d4446.failed

tcf_exts_change is always called on newly created exts, which are not used
on fastpath. Therefore, simple struct copy is enough.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9b0d4446b56904b59ae3809913b0ac760fa941a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 1dc6d123ed94,e655221c654e..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -589,17 -883,13 +589,23 @@@ int tcf_exts_validate(struct net *net, 
  }
  EXPORT_SYMBOL(tcf_exts_validate);
  
- void tcf_exts_change(struct tcf_proto *tp, struct tcf_exts *dst,
- 		     struct tcf_exts *src)
+ void tcf_exts_change(struct tcf_exts *dst, struct tcf_exts *src)
  {
  #ifdef CONFIG_NET_CLS_ACT
++<<<<<<< HEAD
 +	LIST_HEAD(tmp);
 +	tcf_tree_lock(tp);
 +	list_splice_init(&dst->actions, &tmp);
 +	list_splice(&src->actions, &dst->actions);
 +	dst->type = src->type;
 +	tcf_tree_unlock(tp);
 +	tcf_action_destroy(&tmp, TCA_ACT_UNBIND);
++=======
+ 	struct tcf_exts old = *dst;
+ 
+ 	*dst = *src;
+ 	tcf_exts_destroy(&old);
++>>>>>>> 9b0d4446b569 (net: sched: avoid atomic swap in tcf_exts_change)
  #endif
  }
  EXPORT_SYMBOL(tcf_exts_change);
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index 09f92f9cf4d7..1f2eb66d40c6 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -153,8 +153,7 @@ int tcf_exts_validate(struct net *net, struct tcf_proto *tp,
 		      struct nlattr **tb, struct nlattr *rate_tlv,
 		      struct tcf_exts *exts, bool ovr);
 void tcf_exts_destroy(struct tcf_exts *exts);
-void tcf_exts_change(struct tcf_proto *tp, struct tcf_exts *dst,
-		     struct tcf_exts *src);
+void tcf_exts_change(struct tcf_exts *dst, struct tcf_exts *src);
 int tcf_exts_dump(struct sk_buff *skb, struct tcf_exts *exts);
 int tcf_exts_dump_stats(struct sk_buff *skb, struct tcf_exts *exts);
 int tcf_exts_get_dev(struct net_device *dev, struct tcf_exts *exts,
* Unmerged path net/sched/cls_api.c
diff --git a/net/sched/cls_rsvp.h b/net/sched/cls_rsvp.h
index 29d6409252c7..e6de6a20f0a9 100644
--- a/net/sched/cls_rsvp.h
+++ b/net/sched/cls_rsvp.h
@@ -510,7 +510,7 @@ static int rsvp_change(struct net *net, struct sk_buff *in_skb,
 			tcf_bind_filter(tp, &n->res, base);
 		}
 
-		tcf_exts_change(tp, &n->exts, &e);
+		tcf_exts_change(&n->exts, &e);
 		rsvp_replace(tp, n, handle);
 		return 0;
 	}
@@ -581,7 +581,7 @@ insert:
 			if (f->tunnelhdr == 0)
 				tcf_bind_filter(tp, &f->res, base);
 
-			tcf_exts_change(tp, &f->exts, &e);
+			tcf_exts_change(&f->exts, &e);
 
 			fp = &s->ht[h2];
 			for (nfp = rtnl_dereference(*fp); nfp;
diff --git a/net/sched/cls_tcindex.c b/net/sched/cls_tcindex.c
index 5f0af005d12e..22b96d750ded 100644
--- a/net/sched/cls_tcindex.c
+++ b/net/sched/cls_tcindex.c
@@ -382,9 +382,9 @@ tcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,
 	}
 
 	if (old_r)
-		tcf_exts_change(tp, &r->exts, &e);
+		tcf_exts_change(&r->exts, &e);
 	else
-		tcf_exts_change(tp, &cr.exts, &e);
+		tcf_exts_change(&cr.exts, &e);
 
 	if (old_r && old_r != r)
 		tcindex_filter_result_init(old_r);
@@ -397,7 +397,7 @@ tcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,
 		struct tcindex_filter *nfp;
 		struct tcindex_filter __rcu **fp;
 
-		tcf_exts_change(tp, &f->result.exts, &r->exts);
+		tcf_exts_change(&f->result.exts, &r->exts);
 
 		fp = cp->h + (handle % cp->hash);
 		for (nfp = rtnl_dereference(*fp);
