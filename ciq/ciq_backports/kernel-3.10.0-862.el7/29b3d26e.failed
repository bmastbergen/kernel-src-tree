nvmet-fc: remove use of FC-specific error codes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author James Smart <jsmart2021@gmail.com>
commit 29b3d26ecc8046838de88205b7c4b182ac27ff65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/29b3d26e.failed

The FC-NVME target transport used the FC-specific error codes in
return codes when the transport or lldd failed. Instead of using the
FC-specific values, now use a generic value (NVME_SC_INTERNAL).

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 29b3d26ecc8046838de88205b7c4b182ac27ff65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/fc.c
diff --cc drivers/nvme/target/fc.c
index 58773994b97a,088f07250d76..000000000000
--- a/drivers/nvme/target/fc.c
+++ b/drivers/nvme/target/fc.c
@@@ -1795,10 -1906,12 +1795,19 @@@ nvmet_fc_transfer_fcp_data(struct nvmet
  		 */
  		fod->abort = true;
  
++<<<<<<< HEAD
 +		if (op == NVMET_FCOP_WRITEDATA)
 +			nvmet_req_complete(&fod->req,
 +					NVME_SC_FC_TRANSPORT_ERROR);
 +		else /* NVMET_FCOP_READDATA or NVMET_FCOP_READDATA_RSP */ {
++=======
+ 		if (op == NVMET_FCOP_WRITEDATA) {
+ 			spin_lock_irqsave(&fod->flock, flags);
+ 			fod->writedataactive = false;
+ 			spin_unlock_irqrestore(&fod->flock, flags);
+ 			nvmet_req_complete(&fod->req, NVME_SC_INTERNAL);
+ 		} else /* NVMET_FCOP_READDATA or NVMET_FCOP_READDATA_RSP */ {
++>>>>>>> 29b3d26ecc80 (nvmet-fc: remove use of FC-specific error codes)
  			fcpreq->fcp_error = ret;
  			fcpreq->transferred_length = 0;
  			nvmet_fc_xmt_fcp_op_done(fod->fcpreq);
@@@ -1806,10 -1919,33 +1815,36 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool
+ __nvmet_fc_fod_op_abort(struct nvmet_fc_fcp_iod *fod, bool abort)
+ {
+ 	struct nvmefc_tgt_fcp_req *fcpreq = fod->fcpreq;
+ 	struct nvmet_fc_tgtport *tgtport = fod->tgtport;
+ 
+ 	/* if in the middle of an io and we need to tear down */
+ 	if (abort) {
+ 		if (fcpreq->op == NVMET_FCOP_WRITEDATA) {
+ 			nvmet_req_complete(&fod->req, NVME_SC_INTERNAL);
+ 			return true;
+ 		}
+ 
+ 		nvmet_fc_abort_op(tgtport, fod);
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * actual done handler for FCP operations when completed by the lldd
+  */
++>>>>>>> 29b3d26ecc80 (nvmet-fc: remove use of FC-specific error codes)
  static void
 -nvmet_fc_fod_op_done(struct nvmet_fc_fcp_iod *fod)
 +nvmet_fc_xmt_fcp_op_done(struct nvmefc_tgt_fcp_req *fcpreq)
  {
 -	struct nvmefc_tgt_fcp_req *fcpreq = fod->fcpreq;
 +	struct nvmet_fc_fcp_iod *fod = fcpreq->nvmet_fc_private;
  	struct nvmet_fc_tgtport *tgtport = fod->tgtport;
  	unsigned long flags;
  	bool abort;
@@@ -1832,10 -1958,15 +1867,18 @@@
  	switch (fcpreq->op) {
  
  	case NVMET_FCOP_WRITEDATA:
 -		if (__nvmet_fc_fod_op_abort(fod, abort))
 -			return;
 -		if (fcpreq->fcp_error ||
 +		if (abort || fcpreq->fcp_error ||
  		    fcpreq->transferred_length != fcpreq->transfer_length) {
++<<<<<<< HEAD
 +			nvmet_req_complete(&fod->req,
 +					NVME_SC_FC_TRANSPORT_ERROR);
++=======
+ 			spin_lock(&fod->flock);
+ 			fod->abort = true;
+ 			spin_unlock(&fod->flock);
+ 
+ 			nvmet_req_complete(&fod->req, NVME_SC_INTERNAL);
++>>>>>>> 29b3d26ecc80 (nvmet-fc: remove use of FC-specific error codes)
  			return;
  		}
  
* Unmerged path drivers/nvme/target/fc.c
