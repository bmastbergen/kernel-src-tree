jump_label: remove bug.h, atomic.h dependencies for HAVE_JUMP_LABEL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jason Baron <jbaron@akamai.com>
commit 1f69bf9c6137602cd028c96b4f8329121ec89231
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1f69bf9c.failed

The current jump_label.h includes bug.h for things such as WARN_ON().
This makes the header problematic for inclusion by kernel.h or any
headers that kernel.h includes, since bug.h includes kernel.h (circular
dependency).  The inclusion of atomic.h is similarly problematic.  Thus,
this should make jump_label.h 'includable' from most places.

Link: http://lkml.kernel.org/r/7060ce35ddd0d20b33bf170685e6b0fab816bdf2.1467837322.git.jbaron@akamai.com
	Signed-off-by: Jason Baron <jbaron@akamai.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Chris Metcalf <cmetcalf@mellanox.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Joe Perches <joe@perches.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1f69bf9c6137602cd028c96b4f8329121ec89231)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/jump_label.h
diff --cc include/linux/jump_label.h
index e96be7245717,661af564fae8..000000000000
--- a/include/linux/jump_label.h
+++ b/include/linux/jump_label.h
@@@ -78,24 -114,11 +77,32 @@@ enum jump_label_type 
  
  struct module;
  
++<<<<<<< HEAD
 +#include <linux/atomic.h>
 +#ifdef HAVE_JUMP_LABEL
 +
 +#define JUMP_LABEL_TRUE_BRANCH 1UL
 +
 +static
 +inline struct jump_entry *jump_label_get_entries(struct static_key *key)
 +{
 +	return (struct jump_entry *)((unsigned long)key->entries
 +						& ~JUMP_LABEL_TRUE_BRANCH);
 +}
 +
 +static inline bool jump_label_get_branch_default(struct static_key *key)
 +{
 +	if ((unsigned long)key->entries & JUMP_LABEL_TRUE_BRANCH)
 +		return true;
 +	return false;
 +}
++=======
+ #ifdef HAVE_JUMP_LABEL
+ 
+ #define JUMP_TYPE_FALSE	0UL
+ #define JUMP_TYPE_TRUE	1UL
+ #define JUMP_TYPE_MASK	1UL
++>>>>>>> 1f69bf9c6137 (jump_label: remove bug.h, atomic.h dependencies for HAVE_JUMP_LABEL)
  
  static __always_inline bool static_key_false(struct static_key *key)
  {
@@@ -121,17 -144,33 +128,46 @@@ extern int jump_label_text_reserved(voi
  extern void static_key_slow_inc(struct static_key *key);
  extern void static_key_slow_dec(struct static_key *key);
  extern void jump_label_apply_nops(struct module *mod);
+ extern int static_key_count(struct static_key *key);
+ extern void static_key_enable(struct static_key *key);
+ extern void static_key_disable(struct static_key *key);
  
++<<<<<<< HEAD
 +#define STATIC_KEY_INIT_TRUE ((struct static_key) \
 +	{ .enabled = ATOMIC_INIT(1), .entries = (void *)1 })
 +#define STATIC_KEY_INIT_FALSE ((struct static_key) \
 +	{ .enabled = ATOMIC_INIT(0), .entries = (void *)0 })
 +
 +#else  /* !HAVE_JUMP_LABEL */
 +
 +struct static_key {
 +	atomic_t enabled;
 +};
++=======
+ /*
+  * We should be using ATOMIC_INIT() for initializing .enabled, but
+  * the inclusion of atomic.h is problematic for inclusion of jump_label.h
+  * in 'low-level' headers. Thus, we are initializing .enabled with a
+  * raw value, but have added a BUILD_BUG_ON() to catch any issues in
+  * jump_label_init() see: kernel/jump_label.c.
+  */
+ #define STATIC_KEY_INIT_TRUE					\
+ 	{ .enabled = { 1 },					\
+ 	  .entries = (void *)JUMP_TYPE_TRUE }
+ #define STATIC_KEY_INIT_FALSE					\
+ 	{ .enabled = { 0 },					\
+ 	  .entries = (void *)JUMP_TYPE_FALSE }
+ 
+ #else  /* !HAVE_JUMP_LABEL */
+ 
+ #include <linux/atomic.h>
+ #include <linux/bug.h>
+ 
+ static inline int static_key_count(struct static_key *key)
+ {
+ 	return atomic_read(&key->enabled);
+ }
++>>>>>>> 1f69bf9c6137 (jump_label: remove bug.h, atomic.h dependencies for HAVE_JUMP_LABEL)
  
  static __always_inline void jump_label_init(void)
  {
@@@ -177,19 -216,174 +213,184 @@@ static inline int jump_label_apply_nops
  	return 0;
  }
  
 -static inline void static_key_enable(struct static_key *key)
 -{
 -	int count = static_key_count(key);
++<<<<<<< HEAD
 +#define STATIC_KEY_INIT_TRUE ((struct static_key) \
 +		{ .enabled = ATOMIC_INIT(1) })
 +#define STATIC_KEY_INIT_FALSE ((struct static_key) \
 +		{ .enabled = ATOMIC_INIT(0) })
  
 -	WARN_ON_ONCE(count < 0 || count > 1);
 +#endif	/* HAVE_JUMP_LABEL */
  
 -	if (!count)
 -		static_key_slow_inc(key);
 +#define STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
 +#define jump_label_enabled static_key_enabled
 +
 +static inline bool static_key_enabled(struct static_key *key)
++=======
++static inline void static_key_enable(struct static_key *key)
++>>>>>>> 1f69bf9c6137 (jump_label: remove bug.h, atomic.h dependencies for HAVE_JUMP_LABEL)
 +{
 +	return (atomic_read(&key->enabled) > 0);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void static_key_disable(struct static_key *key)
+ {
+ 	int count = static_key_count(key);
+ 
+ 	WARN_ON_ONCE(count < 0 || count > 1);
+ 
+ 	if (count)
+ 		static_key_slow_dec(key);
+ }
+ 
+ #define STATIC_KEY_INIT_TRUE	{ .enabled = ATOMIC_INIT(1) }
+ #define STATIC_KEY_INIT_FALSE	{ .enabled = ATOMIC_INIT(0) }
+ 
+ #endif	/* HAVE_JUMP_LABEL */
+ 
+ #define STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
+ #define jump_label_enabled static_key_enabled
+ 
+ /* -------------------------------------------------------------------------- */
+ 
+ /*
+  * Two type wrappers around static_key, such that we can use compile time
+  * type differentiation to emit the right code.
+  *
+  * All the below code is macros in order to play type games.
+  */
+ 
+ struct static_key_true {
+ 	struct static_key key;
+ };
+ 
+ struct static_key_false {
+ 	struct static_key key;
+ };
+ 
+ #define STATIC_KEY_TRUE_INIT  (struct static_key_true) { .key = STATIC_KEY_INIT_TRUE,  }
+ #define STATIC_KEY_FALSE_INIT (struct static_key_false){ .key = STATIC_KEY_INIT_FALSE, }
+ 
+ #define DEFINE_STATIC_KEY_TRUE(name)	\
+ 	struct static_key_true name = STATIC_KEY_TRUE_INIT
+ 
+ #define DEFINE_STATIC_KEY_FALSE(name)	\
+ 	struct static_key_false name = STATIC_KEY_FALSE_INIT
+ 
+ extern bool ____wrong_branch_error(void);
+ 
+ #define static_key_enabled(x)							\
+ ({										\
+ 	if (!__builtin_types_compatible_p(typeof(*x), struct static_key) &&	\
+ 	    !__builtin_types_compatible_p(typeof(*x), struct static_key_true) &&\
+ 	    !__builtin_types_compatible_p(typeof(*x), struct static_key_false))	\
+ 		____wrong_branch_error();					\
+ 	static_key_count((struct static_key *)x) > 0;				\
+ })
+ 
+ #ifdef HAVE_JUMP_LABEL
+ 
+ /*
+  * Combine the right initial value (type) with the right branch order
+  * to generate the desired result.
+  *
+  *
+  * type\branch|	likely (1)	      |	unlikely (0)
+  * -----------+-----------------------+------------------
+  *            |                       |
+  *  true (1)  |	   ...		      |	   ...
+  *            |    NOP		      |	   JMP L
+  *            |    <br-stmts>	      |	1: ...
+  *            |	L: ...		      |
+  *            |			      |
+  *            |			      |	L: <br-stmts>
+  *            |			      |	   jmp 1b
+  *            |                       |
+  * -----------+-----------------------+------------------
+  *            |                       |
+  *  false (0) |	   ...		      |	   ...
+  *            |    JMP L	      |	   NOP
+  *            |    <br-stmts>	      |	1: ...
+  *            |	L: ...		      |
+  *            |			      |
+  *            |			      |	L: <br-stmts>
+  *            |			      |	   jmp 1b
+  *            |                       |
+  * -----------+-----------------------+------------------
+  *
+  * The initial value is encoded in the LSB of static_key::entries,
+  * type: 0 = false, 1 = true.
+  *
+  * The branch type is encoded in the LSB of jump_entry::key,
+  * branch: 0 = unlikely, 1 = likely.
+  *
+  * This gives the following logic table:
+  *
+  *	enabled	type	branch	  instuction
+  * -----------------------------+-----------
+  *	0	0	0	| NOP
+  *	0	0	1	| JMP
+  *	0	1	0	| NOP
+  *	0	1	1	| JMP
+  *
+  *	1	0	0	| JMP
+  *	1	0	1	| NOP
+  *	1	1	0	| JMP
+  *	1	1	1	| NOP
+  *
+  * Which gives the following functions:
+  *
+  *   dynamic: instruction = enabled ^ branch
+  *   static:  instruction = type ^ branch
+  *
+  * See jump_label_type() / jump_label_init_type().
+  */
+ 
+ #define static_branch_likely(x)							\
+ ({										\
+ 	bool branch;								\
+ 	if (__builtin_types_compatible_p(typeof(*x), struct static_key_true))	\
+ 		branch = !arch_static_branch(&(x)->key, true);			\
+ 	else if (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \
+ 		branch = !arch_static_branch_jump(&(x)->key, true);		\
+ 	else									\
+ 		branch = ____wrong_branch_error();				\
+ 	branch;									\
+ })
+ 
+ #define static_branch_unlikely(x)						\
+ ({										\
+ 	bool branch;								\
+ 	if (__builtin_types_compatible_p(typeof(*x), struct static_key_true))	\
+ 		branch = arch_static_branch_jump(&(x)->key, false);		\
+ 	else if (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \
+ 		branch = arch_static_branch(&(x)->key, false);			\
+ 	else									\
+ 		branch = ____wrong_branch_error();				\
+ 	branch;									\
+ })
+ 
+ #else /* !HAVE_JUMP_LABEL */
+ 
+ #define static_branch_likely(x)		likely(static_key_enabled(&(x)->key))
+ #define static_branch_unlikely(x)	unlikely(static_key_enabled(&(x)->key))
+ 
+ #endif /* HAVE_JUMP_LABEL */
+ 
+ /*
+  * Advanced usage; refcount, branch is enabled when: count != 0
+  */
+ 
+ #define static_branch_inc(x)		static_key_slow_inc(&(x)->key)
+ #define static_branch_dec(x)		static_key_slow_dec(&(x)->key)
+ 
+ /*
+  * Normal usage; boolean enable/disable.
+  */
+ 
+ #define static_branch_enable(x)		static_key_enable(&(x)->key)
+ #define static_branch_disable(x)	static_key_disable(&(x)->key)
+ 
++>>>>>>> 1f69bf9c6137 (jump_label: remove bug.h, atomic.h dependencies for HAVE_JUMP_LABEL)
  #endif	/* _LINUX_JUMP_LABEL_H */
 -
 -#endif /* __ASSEMBLY__ */
* Unmerged path include/linux/jump_label.h
diff --git a/kernel/jump_label.c b/kernel/jump_label.c
index 7d4d0a917d13..adf618fdaefb 100644
--- a/kernel/jump_label.c
+++ b/kernel/jump_label.c
@@ -14,6 +14,7 @@
 #include <linux/err.h>
 #include <linux/static_key.h>
 #include <linux/jump_label_ratelimit.h>
+#include <linux/bug.h>
 
 #ifdef HAVE_JUMP_LABEL
 
@@ -56,6 +57,49 @@ jump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)
 
 static void jump_label_update(struct static_key *key, int enable);
 
+/*
+ * There are similar definitions for the !HAVE_JUMP_LABEL case in jump_label.h.
+ * The use of 'atomic_read()' requires atomic.h and its problematic for some
+ * kernel headers such as kernel.h and others. Since static_key_count() is not
+ * used in the branch statements as it is for the !HAVE_JUMP_LABEL case its ok
+ * to have it be a function here. Similarly, for 'static_key_enable()' and
+ * 'static_key_disable()', which require bug.h. This should allow jump_label.h
+ * to be included from most/all places for HAVE_JUMP_LABEL.
+ */
+int static_key_count(struct static_key *key)
+{
+	/*
+	 * -1 means the first static_key_slow_inc() is in progress.
+	 *  static_key_enabled() must return true, so return 1 here.
+	 */
+	int n = atomic_read(&key->enabled);
+
+	return n >= 0 ? n : 1;
+}
+EXPORT_SYMBOL_GPL(static_key_count);
+
+void static_key_enable(struct static_key *key)
+{
+	int count = static_key_count(key);
+
+	WARN_ON_ONCE(count < 0 || count > 1);
+
+	if (!count)
+		static_key_slow_inc(key);
+}
+EXPORT_SYMBOL_GPL(static_key_enable);
+
+void static_key_disable(struct static_key *key)
+{
+	int count = static_key_count(key);
+
+	WARN_ON_ONCE(count < 0 || count > 1);
+
+	if (count)
+		static_key_slow_dec(key);
+}
+EXPORT_SYMBOL_GPL(static_key_disable);
+
 void static_key_slow_inc(struct static_key *key)
 {
 	STATIC_KEY_CHECK_USE();
@@ -203,6 +247,15 @@ void __init jump_label_init(void)
 	struct static_key *key = NULL;
 	struct jump_entry *iter;
 
+	/*
+	 * Since we are initializing the static_key.enabled field with
+	 * with the 'raw' int values (to avoid pulling in atomic.h) in
+	 * jump_label.h, let's make sure that is safe. There are only two
+	 * cases to check since we initialize to 0 or 1.
+	 */
+	BUILD_BUG_ON((int)ATOMIC_INIT(0) != 0);
+	BUILD_BUG_ON((int)ATOMIC_INIT(1) != 1);
+
 	jump_label_lock();
 	jump_label_sort_entries(iter_start, iter_stop);
 
