radix-tree: rename radix_tree_is_indirect_ptr()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit b194d16c27af905d6e3552f4851bc7d9fee4e90f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b194d16c.failed

As with indirect_to_ptr(), ptr_to_indirect() and
RADIX_TREE_INDIRECT_PTR, change radix_tree_is_indirect_ptr() to
radix_tree_is_internal_node().

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b194d16c27af905d6e3552f4851bc7d9fee4e90f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/radix-tree.h
#	lib/radix-tree.c
diff --cc include/linux/radix-tree.h
index f94b73d0f147,bad63105e37e..000000000000
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@@ -52,9 -48,18 +52,22 @@@
  #define RADIX_TREE_EXCEPTIONAL_ENTRY	2
  #define RADIX_TREE_EXCEPTIONAL_SHIFT	2
  
++<<<<<<< HEAD
 +static inline int radix_tree_is_indirect_ptr(void *ptr)
++=======
+ #define RADIX_DAX_MASK	0xf
+ #define RADIX_DAX_SHIFT	4
+ #define RADIX_DAX_PTE  (0x4 | RADIX_TREE_EXCEPTIONAL_ENTRY)
+ #define RADIX_DAX_PMD  (0x8 | RADIX_TREE_EXCEPTIONAL_ENTRY)
+ #define RADIX_DAX_TYPE(entry) ((unsigned long)entry & RADIX_DAX_MASK)
+ #define RADIX_DAX_SECTOR(entry) (((unsigned long)entry >> RADIX_DAX_SHIFT))
+ #define RADIX_DAX_ENTRY(sector, pmd) ((void *)((unsigned long)sector << \
+ 		RADIX_DAX_SHIFT | (pmd ? RADIX_DAX_PMD : RADIX_DAX_PTE)))
+ 
+ static inline int radix_tree_is_internal_node(void *ptr)
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  {
 -	return (int)((unsigned long)ptr & RADIX_TREE_INTERNAL_NODE);
 +	return (int)((unsigned long)ptr & RADIX_TREE_INDIRECT_PTR);
  }
  
  /*** radix-tree API starts here ***/
@@@ -222,7 -224,7 +235,11 @@@ static inline void *radix_tree_deref_sl
   */
  static inline int radix_tree_deref_retry(void *arg)
  {
++<<<<<<< HEAD
 +	return unlikely((unsigned long)arg & RADIX_TREE_INDIRECT_PTR);
++=======
+ 	return unlikely(radix_tree_is_internal_node(arg));
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  }
  
  /**
@@@ -444,12 -462,27 +461,28 @@@ static __always_inline void *
  radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned flags)
  {
  	if (flags & RADIX_TREE_ITER_TAGGED) {
 -		void *canon = slot;
 -
  		iter->tags >>= 1;
++<<<<<<< HEAD
++=======
+ 		if (unlikely(!iter->tags))
+ 			return NULL;
+ 		while (IS_ENABLED(CONFIG_RADIX_TREE_MULTIORDER) &&
+ 					radix_tree_is_internal_node(slot[1])) {
+ 			if (entry_to_node(slot[1]) == canon) {
+ 				iter->tags >>= 1;
+ 				iter->index = __radix_tree_iter_add(iter, 1);
+ 				slot++;
+ 				continue;
+ 			}
+ 			iter->next_index = __radix_tree_iter_add(iter, 1);
+ 			return NULL;
+ 		}
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		if (likely(iter->tags & 1ul)) {
 -			iter->index = __radix_tree_iter_add(iter, 1);
 +			iter->index++;
  			return slot + 1;
  		}
 -		if (!(flags & RADIX_TREE_ITER_CONTIG)) {
 +		if (!(flags & RADIX_TREE_ITER_CONTIG) && likely(iter->tags)) {
  			unsigned offset = __ffs(iter->tags);
  
  			iter->tags >>= offset;
@@@ -457,11 -490,21 +490,24 @@@
  			return slot + offset + 1;
  		}
  	} else {
 -		long count = radix_tree_chunk_size(iter);
 -		void *canon = slot;
 +		long size = radix_tree_chunk_size(iter);
  
 -		while (--count > 0) {
 +		while (--size > 0) {
  			slot++;
++<<<<<<< HEAD
 +			iter->index++;
++=======
+ 			iter->index = __radix_tree_iter_add(iter, 1);
+ 
+ 			if (IS_ENABLED(CONFIG_RADIX_TREE_MULTIORDER) &&
+ 			    radix_tree_is_internal_node(*slot)) {
+ 				if (entry_to_node(*slot) == canon)
+ 					continue;
+ 				iter->next_index = iter->index;
+ 				break;
+ 			}
+ 
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  			if (likely(*slot))
  				return slot;
  			if (flags & RADIX_TREE_ITER_CONTIG) {
diff --cc lib/radix-tree.c
index 467d6e0a3a58,b65c83036ca4..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -233,9 -230,9 +233,9 @@@ static void dump_node(struct radix_tree
  		if (is_sibling_entry(node, entry)) {
  			pr_debug("radix sblng %p offset %ld val %p indices %ld-%ld\n",
  					entry, i,
 -					*(void **)entry_to_node(entry),
 +					*(void **)indirect_to_ptr(entry),
  					first, last);
- 		} else if (!radix_tree_is_indirect_ptr(entry)) {
+ 		} else if (!radix_tree_is_internal_node(entry)) {
  			pr_debug("radix entry %p offset %ld indices %ld-%ld\n",
  					entry, i, first, last);
  		} else {
@@@ -248,13 -244,12 +248,13 @@@
  /* For debug */
  static void radix_tree_dump(struct radix_tree_root *root)
  {
 -	pr_debug("radix root: %p rnode %p tags %x\n",
 -			root, root->rnode,
 +	pr_debug("radix root: %p height %d rnode %p tags %x\n",
 +			root, root->height, root->rnode,
  			root->gfp_mask >> __GFP_BITS_SHIFT);
- 	if (!radix_tree_is_indirect_ptr(root->rnode))
+ 	if (!radix_tree_is_internal_node(root->rnode))
  		return;
 -	dump_node(entry_to_node(root->rnode), 0);
 +	dump_node(indirect_to_ptr(root->rnode), 0,
 +				(root->height - 1) * RADIX_TREE_MAP_SHIFT, 0);
  }
  #endif
  
@@@ -281,17 -285,24 +281,24 @@@ radix_tree_node_alloc(struct radix_tree
  		 * succeed in getting a node here (and never reach
  		 * kmem_cache_alloc)
  		 */
 -		rtp = this_cpu_ptr(&radix_tree_preloads);
 +		rtp = &__get_cpu_var(radix_tree_preloads);
  		if (rtp->nr) {
 -			ret = rtp->nodes;
 -			rtp->nodes = ret->private_data;
 -			ret->private_data = NULL;
 +			ret = rtp->nodes[rtp->nr - 1];
 +			rtp->nodes[rtp->nr - 1] = NULL;
  			rtp->nr--;
  		}
 -		/*
 -		 * Update the allocation stack trace as this is more useful
 -		 * for debugging.
 -		 */
 -		kmemleak_update_trace(ret);
 -		goto out;
  	}
++<<<<<<< HEAD
 +	if (ret == NULL)
 +		ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);
 +
 +	BUG_ON(radix_tree_is_indirect_ptr(ret));
++=======
+ 	ret = kmem_cache_alloc(radix_tree_node_cachep,
+ 			       gfp_mask | __GFP_ACCOUNT);
+ out:
+ 	BUG_ON(radix_tree_is_internal_node(ret));
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  	return ret;
  }
  
@@@ -408,11 -421,10 +415,16 @@@ static unsigned radix_tree_load_root(st
  
  	*nodep = node;
  
++<<<<<<< HEAD
 +	if (likely(radix_tree_is_indirect_ptr(node))) {
 +		node = indirect_to_ptr(node);
++=======
+ 	if (likely(radix_tree_is_internal_node(node))) {
+ 		node = entry_to_node(node);
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		*maxindex = node_maxindex(node);
 -		return node->shift + RADIX_TREE_MAP_SHIFT;
 +		return (node->path & RADIX_TREE_HEIGHT_MASK) *
 +			RADIX_TREE_MAP_SHIFT;
  	}
  
  	*maxindex = 0;
@@@ -451,25 -462,20 +463,30 @@@ static int radix_tree_extend(struct rad
  				tag_set(node, tag, 0);
  		}
  
 -		BUG_ON(shift > BITS_PER_LONG);
 -		node->shift = shift;
 -		node->offset = 0;
 +		/* Increase the height.  */
 +		newheight = root->height+1;
 +		BUG_ON(newheight & ~RADIX_TREE_HEIGHT_MASK);
 +		node->path = newheight;
  		node->count = 1;
  		node->parent = NULL;
++<<<<<<< HEAD
 +		slot = root->rnode;
 +		if (radix_tree_is_indirect_ptr(slot)) {
 +			slot = indirect_to_ptr(slot);
 +			slot->parent = node;
 +			slot = ptr_to_indirect(slot);
 +		}
++=======
+ 		if (radix_tree_is_internal_node(slot))
+ 			entry_to_node(slot)->parent = node;
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		node->slots[0] = slot;
 -		slot = node_to_entry(node);
 -		rcu_assign_pointer(root->rnode, slot);
 -		shift += RADIX_TREE_MAP_SHIFT;
 -	} while (shift <= maxshift);
 +		node = ptr_to_indirect(node);
 +		rcu_assign_pointer(root->rnode, node);
 +		root->height = newheight;
 +	} while (height > root->height);
  out:
 -	return maxshift + RADIX_TREE_MAP_SHIFT;
 +	return height * RADIX_TREE_MAP_SHIFT;
  }
  
  /**
@@@ -525,13 -530,12 +542,18 @@@ int __radix_tree_create(struct radix_tr
  			slot->parent = node;
  			if (node) {
  				rcu_assign_pointer(node->slots[offset],
 -							node_to_entry(slot));
 +							ptr_to_indirect(slot));
  				node->count++;
 +				slot->path |= offset << RADIX_TREE_HEIGHT_SHIFT;
  			} else
  				rcu_assign_pointer(root->rnode,
++<<<<<<< HEAD
 +							ptr_to_indirect(slot));
 +		} else if (!radix_tree_is_indirect_ptr(slot))
++=======
+ 							node_to_entry(slot));
+ 		} else if (!radix_tree_is_internal_node(slot))
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  			break;
  
  		/* Go a level down */
@@@ -882,14 -895,19 +904,25 @@@ void **radix_tree_next_chunk(struct rad
  	if (!index && iter->index)
  		return NULL;
  
++<<<<<<< HEAD
 +	rnode = rcu_dereference_raw(root->rnode);
 +	if (radix_tree_is_indirect_ptr(rnode)) {
 +		rnode = indirect_to_ptr(rnode);
 +	} else if (rnode && !index) {
++=======
+  restart:
+ 	shift = radix_tree_load_root(root, &rnode, &maxindex);
+ 	if (index > maxindex)
+ 		return NULL;
+ 
+ 	if (radix_tree_is_internal_node(rnode)) {
+ 		rnode = entry_to_node(rnode);
+ 	} else if (rnode) {
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		/* Single-slot tree */
 -		iter->index = index;
 -		iter->next_index = maxindex + 1;
 +		iter->index = 0;
 +		iter->next_index = 1;
  		iter->tags = 1;
 -		__set_iter_shift(iter, shift);
  		return (void **)&root->rnode;
  	} else
  		return NULL;
@@@ -930,18 -952,15 +963,18 @@@ restart
  				return NULL;
  			if (offset == RADIX_TREE_MAP_SIZE)
  				goto restart;
 -			slot = rcu_dereference_raw(node->slots[offset]);
  		}
  
 -		if ((slot == NULL) || (slot == RADIX_TREE_RETRY))
 +		/* This is leaf-node */
 +		if (!shift)
 +			break;
 +
 +		slot = rcu_dereference_raw(node->slots[offset]);
 +		if (slot == NULL)
  			goto restart;
- 		if (!radix_tree_is_indirect_ptr(slot))
+ 		if (!radix_tree_is_internal_node(slot))
  			break;
 -
 -		node = entry_to_node(slot);
 +		node = indirect_to_ptr(slot);
  		shift -= RADIX_TREE_MAP_SHIFT;
  		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
  	}
@@@ -1020,7 -1039,7 +1053,11 @@@ unsigned long radix_tree_range_tag_if_t
  		*first_indexp = last_index + 1;
  		return 0;
  	}
++<<<<<<< HEAD
 +	if (height == 0) {
++=======
+ 	if (!radix_tree_is_internal_node(slot)) {
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		*first_indexp = last_index + 1;
  		root_tag_set(root, settag);
  		return 1;
@@@ -1031,24 -1050,19 +1068,32 @@@
  
  	for (;;) {
  		unsigned long upindex;
 -		unsigned offset;
 +		int offset;
  
  		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		offset = radix_tree_descend(node, &slot, offset);
 -		if (!slot)
 +		if (!slot->slots[offset])
  			goto next;
 -		if (!tag_get(node, iftag, offset))
 +		if (!tag_get(slot, iftag, offset))
  			goto next;
++<<<<<<< HEAD
 +		if (shift) {
 +			node = slot;
 +			slot = slot->slots[offset];
 +			if (radix_tree_is_indirect_ptr(slot)) {
 +				slot = indirect_to_ptr(slot);
 +				shift -= RADIX_TREE_MAP_SHIFT;
 +				continue;
 +			} else {
 +				slot = node;
 +				node = node->parent;
 +			}
++=======
+ 		/* Sibling slots never have tags set on them */
+ 		if (radix_tree_is_internal_node(slot)) {
+ 			node = entry_to_node(slot);
+ 			shift -= RADIX_TREE_MAP_SHIFT;
+ 			continue;
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		}
  
  		/* tag the leaf */
@@@ -1278,54 -1294,44 +1323,70 @@@ EXPORT_SYMBOL(radix_tree_gang_lookup_ta
   * This linear search is at present only useful to shmem_unuse_inode().
   */
  static unsigned long __locate(struct radix_tree_node *slot, void *item,
 -			      unsigned long index, struct locate_info *info)
 +			      unsigned long index, unsigned long *found_index)
  {
 -	unsigned int shift;
 +	unsigned int shift, height;
  	unsigned long i;
  
 -	shift = slot->shift + RADIX_TREE_MAP_SHIFT;
 -
 -	do {
 -		shift -= RADIX_TREE_MAP_SHIFT;
 +	height = slot->path & RADIX_TREE_HEIGHT_MASK;
 +	shift = (height-1) * RADIX_TREE_MAP_SHIFT;
  
 -		for (i = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		     i < RADIX_TREE_MAP_SIZE;
 -		     i++, index += (1UL << shift)) {
 -			struct radix_tree_node *node =
 -					rcu_dereference_raw(slot->slots[i]);
 -			if (node == RADIX_TREE_RETRY)
 +	for ( ; height > 1; height--) {
 +		i = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		for (;;) {
 +			if (slot->slots[i] != NULL)
 +				break;
 +			index &= ~((1UL << shift) - 1);
 +			index += 1UL << shift;
 +			if (index == 0)
 +				goto out;	/* 32-bit wraparound */
 +			i++;
 +			if (i == RADIX_TREE_MAP_SIZE)
  				goto out;
++<<<<<<< HEAD
++=======
+ 			if (!radix_tree_is_internal_node(node)) {
+ 				if (node == item) {
+ 					info->found_index = index;
+ 					info->stop = true;
+ 					goto out;
+ 				}
+ 				continue;
+ 			}
+ 			node = entry_to_node(node);
+ 			if (is_sibling_entry(slot, node))
+ 				continue;
+ 			slot = node;
+ 			break;
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  		}
 -		if (i == RADIX_TREE_MAP_SIZE)
 -			break;
 -	} while (shift);
  
 +		slot = rcu_dereference_raw(slot->slots[i]);
 +		if (slot == NULL)
 +			goto out;
 +		if (!radix_tree_is_indirect_ptr(slot)) {
 +			if (slot == item) {
 +				*found_index = index + i;
 +				index = 0;
 +			} else {
 +				index += shift;
 +			}
 +			goto out;
 +		}
 +		slot = indirect_to_ptr(slot);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +	}
 +
 +	/* Bottom level: check items */
 +	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
 +		if (slot->slots[i] == item) {
 +			*found_index = index + i;
 +			index = 0;
 +			goto out;
 +		}
 +	}
 +	index += RADIX_TREE_MAP_SIZE;
  out:
 -	if ((index == 0) && (i == RADIX_TREE_MAP_SIZE))
 -		info->stop = true;
  	return index;
  }
  
@@@ -1348,10 -1357,10 +1409,10 @@@ unsigned long radix_tree_locate_item(st
  	do {
  		rcu_read_lock();
  		node = rcu_dereference_raw(root->rnode);
- 		if (!radix_tree_is_indirect_ptr(node)) {
+ 		if (!radix_tree_is_internal_node(node)) {
  			rcu_read_unlock();
  			if (node == item)
 -				info.found_index = 0;
 +				found_index = 0;
  			break;
  		}
  
@@@ -1388,8 -1398,9 +1449,14 @@@ static inline bool radix_tree_shrink(st
  		struct radix_tree_node *to_free = root->rnode;
  		struct radix_tree_node *slot;
  
++<<<<<<< HEAD
 +		BUG_ON(!radix_tree_is_indirect_ptr(to_free));
 +		to_free = indirect_to_ptr(to_free);
++=======
+ 		if (!radix_tree_is_internal_node(to_free))
+ 			break;
+ 		to_free = entry_to_node(to_free);
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  
  		/*
  		 * The candidate node has more than one child, or its child
@@@ -1401,6 -1412,11 +1468,14 @@@
  		slot = to_free->slots[0];
  		if (!slot)
  			break;
++<<<<<<< HEAD
++=======
+ 		if (!radix_tree_is_internal_node(slot) && to_free->shift)
+ 			break;
+ 
+ 		if (radix_tree_is_internal_node(slot))
+ 			entry_to_node(slot)->parent = NULL;
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  
  		/*
  		 * We don't need rcu_assign_pointer(), since we are simply
@@@ -1438,9 -1445,8 +1513,14 @@@
  		 * also results in a stale slot). So tag the slot as indirect
  		 * to force callers to retry.
  		 */
++<<<<<<< HEAD
 +		if (root->height == 0)
 +			*((unsigned long *)&to_free->slots[0]) |=
 +						RADIX_TREE_INDIRECT_PTR;
++=======
+ 		if (!radix_tree_is_internal_node(slot))
+ 			to_free->slots[0] = RADIX_TREE_RETRY;
++>>>>>>> b194d16c27af (radix-tree: rename radix_tree_is_indirect_ptr())
  
  		radix_tree_node_free(to_free);
  		shrunk = true;
* Unmerged path include/linux/radix-tree.h
* Unmerged path lib/radix-tree.c
diff --git a/tools/testing/radix-tree/test.c b/tools/testing/radix-tree/test.c
index eefa9383f83f..494086872145 100644
--- a/tools/testing/radix-tree/test.c
+++ b/tools/testing/radix-tree/test.c
@@ -186,7 +186,7 @@ static int verify_node(struct radix_tree_node *slot, unsigned int tag,
 void verify_tag_consistency(struct radix_tree_root *root, unsigned int tag)
 {
 	struct radix_tree_node *node = root->rnode;
-	if (!radix_tree_is_indirect_ptr(node))
+	if (!radix_tree_is_internal_node(node))
 		return;
 	verify_node(node, tag, !!root_tag_get(root, tag));
 }
@@ -215,7 +215,7 @@ void tree_verify_min_height(struct radix_tree_root *root, int maxindex)
 {
 	unsigned shift;
 	struct radix_tree_node *node = root->rnode;
-	if (!radix_tree_is_indirect_ptr(node)) {
+	if (!radix_tree_is_internal_node(node)) {
 		assert(maxindex == 0);
 		return;
 	}
