ovl: don't set origin on broken lower hardlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit fbaf94ee3cd5cfa85fe2d4d04be968820cb00556
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fbaf94ee.failed

When copying up a file that has multiple hard links we need to break any
association with the origin file.  This makes copy-up be essentially an
atomic replace.

The new file has nothing to do with the old one (except having the same
data and metadata initially), so don't set the overlay.origin attribute.

We can relax this in the future when we are able to index upper object by
origin.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Fixes: 3a1e819b4e80 ("ovl: store file handle of lower inode on copy up")
(cherry picked from commit fbaf94ee3cd5cfa85fe2d4d04be968820cb00556)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,a2a65120c9d0..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -330,24 -389,43 +330,39 @@@ static int ovl_copy_up_locked(struct de
  	if (err)
  		goto out_cleanup;
  
++<<<<<<< HEAD
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
 +	if (err)
 +		goto out_cleanup;
++=======
+ 	/*
+ 	 * Store identifier of lower inode in upper inode xattr to
+ 	 * allow lookup of the copy up origin inode.
+ 	 *
+ 	 * Don't set origin when we are breaking the association with a lower
+ 	 * hard link.
+ 	 */
+ 	if (S_ISDIR(stat->mode) || stat->nlink == 1) {
+ 		err = ovl_set_origin(dentry, lowerpath->dentry, temp);
+ 		if (err)
+ 			goto out_cleanup;
+ 	}
++>>>>>>> fbaf94ee3cd5 (ovl: don't set origin on broken lower hardlink)
  
 -	upper = lookup_one_len(dentry->d_name.name, upperdir,
 -			       dentry->d_name.len);
 -	if (IS_ERR(upper)) {
 -		err = PTR_ERR(upper);
 -		upper = NULL;
 -		goto out_cleanup;
 -	}
 -
 -	if (tmpfile)
 -		err = ovl_do_link(temp, udir, upper, true);
 -	else
 -		err = ovl_do_rename(wdir, temp, udir, upper, 0);
 -	if (err)
 -		goto out_cleanup;
 -
 -	newdentry = dget(tmpfile ? upper : temp);
  	ovl_dentry_update(dentry, newdentry);
  	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
  
 -	/* Restore timestamps on parent (best effort) */
 -	ovl_set_timestamps(upperdir, pstat);
 -out:
 -	dput(temp);
 +	/*
 +	 * Non-directores become opaque when copied up.
 +	 */
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
  	dput(upper);
 +out1:
 +	dput(newdentry);
 +out:
  	return err;
  
  out_cleanup:
* Unmerged path fs/overlayfs/copy_up.c
