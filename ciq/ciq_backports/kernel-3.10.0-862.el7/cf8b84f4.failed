kvm: nVMX: Prepare for checkpointing L2 state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jim Mattson <jmattson@google.com>
commit cf8b84f48a5936f558a7a415f1d2f42161bf73eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cf8b84f4.failed

Split prepare_vmcs12 into two parts: the part that stores the current L2
guest state and the part that sets up the exit information fields. The
former will be used when checkpointing the vCPU's VMX state.

Modify prepare_vmcs02 so that it can construct a vmcs02 midway through
L2 execution, using the checkpointed L2 guest state saved into the
cached vmcs12 above.

	Signed-off-by: Jim Mattson <jmattson@google.com>
[Rebasing: add from_vmentry argument to prepare_vmcs02 instead of using
 vmx->nested.nested_run_pending, because it is no longer 1 at the
 point prepare_vmcs02 is called. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit cf8b84f48a5936f558a7a415f1d2f42161bf73eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 7c4249d4c052,4b4b59b34d44..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9940,6 -10358,16 +9947,19 @@@ static int prepare_vmcs02(struct kvm_vc
  	vmx_set_cr4(vcpu, vmcs12->guest_cr4);
  	vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));
  
++<<<<<<< HEAD
++=======
+ 	if (from_vmentry &&
+ 	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER))
+ 		vcpu->arch.efer = vmcs12->guest_ia32_efer;
+ 	else if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)
+ 		vcpu->arch.efer |= (EFER_LMA | EFER_LME);
+ 	else
+ 		vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);
+ 	/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */
+ 	vmx_set_efer(vcpu, vcpu->arch.efer);
+ 
++>>>>>>> cf8b84f48a59 (kvm: nVMX: Prepare for checkpointing L2 state)
  	/* Shadow page tables on either EPT or shadow page tables. */
  	if (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_ept_enabled,
  				entry_failure_code))
@@@ -10426,6 -10851,27 +10438,30 @@@ static void sync_vmcs12(struct kvm_vcp
  	vmcs12->guest_sysenter_eip = vmcs_readl(GUEST_SYSENTER_EIP);
  	if (kvm_mpx_supported())
  		vmcs12->guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);
++<<<<<<< HEAD
++=======
+ 	if (nested_cpu_has_xsaves(vmcs12))
+ 		vmcs12->xss_exit_bitmap = vmcs_read64(XSS_EXIT_BITMAP);
+ }
+ 
+ /*
+  * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits
+  * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),
+  * and this function updates it to reflect the changes to the guest state while
+  * L2 was running (and perhaps made some exits which were handled directly by L0
+  * without going back to L1), and to reflect the exit reason.
+  * Note that we do not have to copy here all VMCS fields, just those that
+  * could have changed by the L2 guest or the exit - i.e., the guest-state and
+  * exit-information fields only. Other fields are modified by L1 with VMWRITE,
+  * which already writes to vmcs12 directly.
+  */
+ static void prepare_vmcs12(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
+ 			   u32 exit_reason, u32 exit_intr_info,
+ 			   unsigned long exit_qualification)
+ {
+ 	/* update guest state fields: */
+ 	sync_vmcs12(vcpu, vmcs12);
++>>>>>>> cf8b84f48a59 (kvm: nVMX: Prepare for checkpointing L2 state)
  
  	/* update exit information fields: */
  
* Unmerged path arch/x86/kvm/vmx.c
