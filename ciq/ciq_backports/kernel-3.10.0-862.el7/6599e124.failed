scsi: lpfc: Fix nvmet node ref count handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix nvmet node ref count handling (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 92.86%
commit-author James Smart <jsmart2021@gmail.com>
commit 6599e12428a8b3b182e91818cb7b73ab29e7daff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6599e124.failed

When unloading the driver, the NVMET driver would wait the full 30
seconds for its UNMAPPED initiator node to get removed before continuing
with the unload process.  NVMEI worked correctly.

For each rport put into UNMAPPED or MAPPED state by NVMET, the driver
puts a reference on the NDLP.  The difference is that NVMEI has a
unregister call for its rports and the extra reference is removed in the
unregister process.  For NVMET, the driver has to remove the reference
explicitly when dropping out of UNMAPPED or MAPPED because there is no
unregister call.

Add a call to lpfc_nlp_put on the ndlp when NVMET and the old state was
UNMAPPED or MAPPED.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6599e12428a8b3b182e91818cb7b73ab29e7daff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_hbadisc.c
diff --cc drivers/scsi/lpfc/lpfc_hbadisc.c
index 79d58e5464d6,db2d0e692ddf..000000000000
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@@ -4049,23 -4159,58 +4049,43 @@@ lpfc_nlp_state_cleanup(struct lpfc_vpor
  	if (new_state == NLP_STE_NPR_NODE)
  		ndlp->nlp_flag &= ~NLP_RCV_PLOGI;
  
++<<<<<<< HEAD
 +	/* Transport interface */
 +	if (ndlp->rport && (old_state == NLP_STE_MAPPED_NODE ||
 +			    old_state == NLP_STE_UNMAPPED_NODE)) {
 +		vport->phba->nport_event_cnt++;
 +		lpfc_unregister_remote_port(ndlp);
++=======
+ 	/* FCP and NVME Transport interface */
+ 	if ((old_state == NLP_STE_MAPPED_NODE ||
+ 	     old_state == NLP_STE_UNMAPPED_NODE)) {
+ 		if (ndlp->rport) {
+ 			vport->phba->nport_event_cnt++;
+ 			lpfc_unregister_remote_port(ndlp);
+ 		}
+ 
+ 		if (ndlp->nlp_fc4_type & NLP_FC4_NVME) {
+ 			vport->phba->nport_event_cnt++;
+ 			if (vport->phba->nvmet_support == 0)
+ 				/* Start devloss */
+ 				lpfc_nvme_unregister_port(vport, ndlp);
+ 			else
+ 				/* NVMET has no upcall. */
+ 				lpfc_nlp_put(ndlp);
+ 		}
++>>>>>>> 6599e12428a8 (scsi: lpfc: Fix nvmet node ref count handling)
  	}
  
 -	/* FCP and NVME Transport interfaces */
 -
  	if (new_state ==  NLP_STE_MAPPED_NODE ||
  	    new_state == NLP_STE_UNMAPPED_NODE) {
 -		if (ndlp->nlp_fc4_type & NLP_FC4_FCP ||
 -		    ndlp->nlp_DID == Fabric_DID ||
 -		    ndlp->nlp_DID == NameServer_DID ||
 -		    ndlp->nlp_DID == FDMI_DID) {
 -			vport->phba->nport_event_cnt++;
 -			/*
 -			 * Tell the fc transport about the port, if we haven't
 -			 * already. If we have, and it's a scsi entity, be
 -			 */
 -			lpfc_register_remote_port(vport, ndlp);
 -		}
 -		/* Notify the NVME transport of this new rport. */
 -		if (ndlp->nlp_fc4_type & NLP_FC4_NVME) {
 -			if (vport->phba->nvmet_support == 0) {
 -				/* Register this rport with the transport.
 -				 * Initiators take the NDLP ref count in
 -				 * the register.
 -				 */
 -				vport->phba->nport_event_cnt++;
 -				lpfc_nvme_register_port(vport, ndlp);
 -			} else {
 -				/* Just take an NDLP ref count since the
 -				 * target does not register rports.
 -				 */
 -				lpfc_nlp_get(ndlp);
 -			}
 -		}
 +		vport->phba->nport_event_cnt++;
 +		/*
 +		 * Tell the fc transport about the port, if we haven't
 +		 * already. If we have, and it's a scsi entity, be
 +		 * sure to unblock any attached scsi devices
 +		 */
 +		lpfc_register_remote_port(vport, ndlp);
  	}
 -
  	if ((new_state ==  NLP_STE_MAPPED_NODE) &&
  		(vport->stat_data_enabled)) {
  		/*
* Unmerged path drivers/scsi/lpfc/lpfc_hbadisc.c
