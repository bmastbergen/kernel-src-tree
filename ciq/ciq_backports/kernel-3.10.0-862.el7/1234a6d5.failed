scsi: lpfc: Fix crash receiving ELS while detaching driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix crash receiving ELS while detaching driver (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 94.55%
commit-author Dick Kennedy <dick.kennedy@broadcom.com>
commit 1234a6d54fed8a00091968c4eb2fb52e1cbb8e2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1234a6d5.failed

The driver crashes when attempting to use a freed ndpl pointer.

The pci_remove_one handler runs on a separate kernel thread. The order
of the removal is starting by freeing all of the ndlps and then
disabling interrupts. In between these two events the driver can still
receive an ELS and process it. When it tries to use the ndlp pointer
will be NULL

Change the order of the pci_remove_one vs disable interrupts so that
interrupts are disabled before the ndlp's are freed.

	Cc: <stable@vger.kernel.org> # 4.12+
	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1234a6d54fed8a00091968c4eb2fb52e1cbb8e2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_attr.c
#	drivers/scsi/lpfc/lpfc_bsg.c
#	drivers/scsi/lpfc/lpfc_els.c
#	drivers/scsi/lpfc/lpfc_hbadisc.c
#	drivers/scsi/lpfc/lpfc_nportdisc.c
#	drivers/scsi/lpfc/lpfc_sli.c
diff --cc drivers/scsi/lpfc/lpfc_attr.c
index e030a290e43b,dc6519b2c53a..000000000000
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@@ -2828,9 -3132,10 +2828,13 @@@ lpfc_txq_hw_show(struct device *dev, st
  {
  	struct Scsi_Host  *shost = class_to_shost(dev);
  	struct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;
 -	struct lpfc_sli_ring *pring = lpfc_phba_elsring(phba);
  
  	return snprintf(buf, PAGE_SIZE, "%d\n",
++<<<<<<< HEAD
 +		phba->sli.ring[LPFC_ELS_RING].txq_max);
++=======
+ 			pring ? pring->txq_max : 0);
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  }
  
  static DEVICE_ATTR(txq_hw, S_IRUGO,
@@@ -2841,9 -3146,10 +2845,13 @@@ lpfc_txcmplq_hw_show(struct device *dev
  {
  	struct Scsi_Host  *shost = class_to_shost(dev);
  	struct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;
 -	struct lpfc_sli_ring *pring = lpfc_phba_elsring(phba);
  
  	return snprintf(buf, PAGE_SIZE, "%d\n",
++<<<<<<< HEAD
 +		phba->sli.ring[LPFC_ELS_RING].txcmplq_max);
++=======
+ 			pring ? pring->txcmplq_max : 0);
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  }
  
  static DEVICE_ATTR(txcmplq_hw, S_IRUGO,
diff --cc drivers/scsi/lpfc/lpfc_bsg.c
index cb9e36397846,d89816222b23..000000000000
--- a/drivers/scsi/lpfc/lpfc_bsg.c
+++ b/drivers/scsi/lpfc/lpfc_bsg.c
@@@ -5333,6 -5420,10 +5333,13 @@@ lpfc_bsg_timeout(struct fc_bsg_job *job
  	LIST_HEAD(completions);
  	struct lpfc_iocbq *check_iocb, *next_iocb;
  
++<<<<<<< HEAD
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 	if (unlikely(!pring))
+ 		return -EIO;
+ 
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  	/* if job's driver data is NULL, the command completed or is in the
  	 * the process of completing.  In this case, return status to request
  	 * so the timeout is retried.  This avoids double completion issues
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 896be78956d8,3ebf6ccba6e6..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -7183,7 -7429,10 +7183,14 @@@ lpfc_els_timeout_handler(struct lpfc_vp
  
  	timeout = (uint32_t)(phba->fc_ratov << 1);
  
++<<<<<<< HEAD
 +	pring = &phba->sli.ring[LPFC_ELS_RING];
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 	if (unlikely(!pring))
+ 		return;
+ 
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  	if ((phba->pport->load_flag & FC_UNLOADING))
  		return;
  	spin_lock_irq(&phba->hbalock);
@@@ -9045,8 -9308,13 +9052,11 @@@ void lpfc_fabric_abort_nport(struct lpf
  	LIST_HEAD(completions);
  	struct lpfc_hba  *phba = ndlp->phba;
  	struct lpfc_iocbq *tmp_iocb, *piocb;
 -	struct lpfc_sli_ring *pring;
 -
 -	pring = lpfc_phba_elsring(phba);
 +	struct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];
  
+ 	if (unlikely(!pring))
+ 		return;
+ 
  	spin_lock_irq(&phba->hbalock);
  	list_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,
  				 list) {
diff --cc drivers/scsi/lpfc/lpfc_hbadisc.c
index 79d58e5464d6,499df9d17339..000000000000
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@@ -3290,7 -3323,10 +3290,14 @@@ lpfc_mbx_cmpl_read_topology(struct lpfc
  	uint8_t attn_type;
  
  	/* Unblock ELS traffic */
++<<<<<<< HEAD
 +	phba->sli.ring[LPFC_ELS_RING].flag &= ~LPFC_STOP_IOCB_EVENT;
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 	if (pring)
+ 		pring->flag &= ~LPFC_STOP_IOCB_EVENT;
+ 
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  	/* Check for error */
  	if (mb->mbxStatus) {
  		lpfc_printf_log(phba, KERN_INFO, LOG_LINK_EVENT,
@@@ -5217,7 -5430,9 +5224,13 @@@ lpfc_free_tx(struct lpfc_hba *phba, str
  	struct lpfc_sli_ring *pring;
  
  	psli = &phba->sli;
++<<<<<<< HEAD
 +	pring = &psli->ring[LPFC_ELS_RING];
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 	if (unlikely(!pring))
+ 		return;
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  
  	/* Error matching iocb on txq or txcmplq
  	 * First check the txq.
diff --cc drivers/scsi/lpfc/lpfc_nportdisc.c
index 7ae2f18f5f51,b6957d944b9a..000000000000
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@@ -204,10 -210,15 +204,19 @@@ in
  lpfc_els_abort(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)
  {
  	LIST_HEAD(abort_list);
 -	struct lpfc_sli_ring *pring;
 +	struct lpfc_sli  *psli = &phba->sli;
 +	struct lpfc_sli_ring *pring = &psli->ring[LPFC_ELS_RING];
  	struct lpfc_iocbq *iocb, *next_iocb;
  
++<<<<<<< HEAD
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 
+ 	/* In case of error recovery path, we might have a NULL pring here */
+ 	if (unlikely(!pring))
+ 		return;
+ 
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  	/* Abort outstanding I/O on NPort <nlp_DID> */
  	lpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_DISCOVERY,
  			 "2819 Abort outstanding I/O on NPort x%x "
diff --cc drivers/scsi/lpfc/lpfc_sli.c
index afe166ddbf5a,8026a327820f..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@@ -11784,6 -12507,10 +11792,13 @@@ lpfc_sli4_els_wcqe_to_rspiocbq(struct l
  	struct lpfc_wcqe_complete *wcqe;
  	unsigned long iflags;
  
++<<<<<<< HEAD
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 	if (unlikely(!pring))
+ 		return NULL;
+ 
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  	wcqe = &irspiocbq->cq_event.cqe.wcqe_cmpl;
  	spin_lock_irqsave(&pring->ring_lock, iflags);
  	pring->stats.iocb_event++;
@@@ -17217,6 -18700,10 +17232,13 @@@ lpfc_drain_txq(struct lpfc_hba *phba
  	union lpfc_wqe *wqe = (union lpfc_wqe *) &wqe128;
  	uint32_t txq_cnt = 0;
  
++<<<<<<< HEAD
++=======
+ 	pring = lpfc_phba_elsring(phba);
+ 	if (unlikely(!pring))
+ 		return 0;
+ 
++>>>>>>> 1234a6d54fed (scsi: lpfc: Fix crash receiving ELS while detaching driver)
  	spin_lock_irqsave(&pring->ring_lock, iflags);
  	list_for_each_entry(piocbq, &pring->txq, list) {
  		txq_cnt++;
* Unmerged path drivers/scsi/lpfc/lpfc_attr.c
* Unmerged path drivers/scsi/lpfc/lpfc_bsg.c
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
* Unmerged path drivers/scsi/lpfc/lpfc_hbadisc.c
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index 178fd4fd8506..8ed0945d46b4 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -10766,10 +10766,6 @@ lpfc_pci_remove_one_s4(struct pci_dev *pdev)
 	/* Remove FC host and then SCSI host with the physical port */
 	fc_remove_host(shost);
 	scsi_remove_host(shost);
-
-	/* Perform cleanup on the physical port */
-	lpfc_cleanup(vport);
-
 	/*
 	 * Bring down the SLI Layer. This step disables all interrupts,
 	 * clears the rings, discards all mailbox commands, and resets
@@ -10778,6 +10774,10 @@ lpfc_pci_remove_one_s4(struct pci_dev *pdev)
 	lpfc_debugfs_terminate(vport);
 	lpfc_sli4_hba_unset(phba);
 
+	/* Perform cleanup on the physical port */
+	lpfc_cleanup(vport);
+
+
 	lpfc_stop_hba_timers(phba);
 	spin_lock_irq(&phba->hbalock);
 	list_del_init(&vport->listentry);
* Unmerged path drivers/scsi/lpfc/lpfc_nportdisc.c
* Unmerged path drivers/scsi/lpfc/lpfc_sli.c
