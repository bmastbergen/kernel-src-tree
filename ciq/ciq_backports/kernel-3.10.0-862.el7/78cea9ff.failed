qed: Drop the 's' from num_ports_in_engines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tomer Tayar <Tomer.Tayar@cavium.com>
commit 78cea9ffaa34d289212a2444c2e357f7dabcf674
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/78cea9ff.failed

The parameter reflects the number of physical ports connected to a single
engine, not all.

	Signed-off-by: Tomer Tayar <Tomer.Tayar@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 78cea9ffaa34d289212a2444c2e357f7dabcf674)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
#	drivers/net/ethernet/qlogic/qed/qed_ptp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index 7bfba0756fb1,51ae9071f3df..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -2220,12 -2101,170 +2220,173 @@@ static const char *qed_hw_get_resc_name
  	}
  }
  
 -static int
 -__qed_hw_set_soft_resc_size(struct qed_hwfn *p_hwfn,
 -			    struct qed_ptt *p_ptt,
 -			    enum qed_resources res_id,
 -			    u32 resc_max_val, u32 *p_mcp_resp)
 +static int qed_hw_set_resc_info(struct qed_hwfn *p_hwfn,
 +				enum qed_resources res_id)
  {
++<<<<<<< HEAD
 +	u32 dflt_resc_num = 0, dflt_resc_start = 0, mcp_resp, mcp_param;
 +	u32 *p_resc_num, *p_resc_start;
 +	struct resource_info resc_info;
++=======
+ 	int rc;
+ 
+ 	rc = qed_mcp_set_resc_max_val(p_hwfn, p_ptt, res_id,
+ 				      resc_max_val, p_mcp_resp);
+ 	if (rc) {
+ 		DP_NOTICE(p_hwfn,
+ 			  "MFW response failure for a max value setting of resource %d [%s]\n",
+ 			  res_id, qed_hw_get_resc_name(res_id));
+ 		return rc;
+ 	}
+ 
+ 	if (*p_mcp_resp != FW_MSG_CODE_RESOURCE_ALLOC_OK)
+ 		DP_INFO(p_hwfn,
+ 			"Failed to set the max value of resource %d [%s]. mcp_resp = 0x%08x.\n",
+ 			res_id, qed_hw_get_resc_name(res_id), *p_mcp_resp);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qed_hw_set_soft_resc_size(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
+ {
+ 	bool b_ah = QED_IS_AH(p_hwfn->cdev);
+ 	u32 resc_max_val, mcp_resp;
+ 	u8 res_id;
+ 	int rc;
+ 
+ 	for (res_id = 0; res_id < QED_MAX_RESC; res_id++) {
+ 		switch (res_id) {
+ 		case QED_LL2_QUEUE:
+ 			resc_max_val = MAX_NUM_LL2_RX_QUEUES;
+ 			break;
+ 		case QED_RDMA_CNQ_RAM:
+ 			/* No need for a case for QED_CMDQS_CQS since
+ 			 * CNQ/CMDQS are the same resource.
+ 			 */
+ 			resc_max_val = NUM_OF_CMDQS_CQS;
+ 			break;
+ 		case QED_RDMA_STATS_QUEUE:
+ 			resc_max_val = b_ah ? RDMA_NUM_STATISTIC_COUNTERS_K2
+ 			    : RDMA_NUM_STATISTIC_COUNTERS_BB;
+ 			break;
+ 		case QED_BDQ:
+ 			resc_max_val = BDQ_NUM_RESOURCES;
+ 			break;
+ 		default:
+ 			continue;
+ 		}
+ 
+ 		rc = __qed_hw_set_soft_resc_size(p_hwfn, p_ptt, res_id,
+ 						 resc_max_val, &mcp_resp);
+ 		if (rc)
+ 			return rc;
+ 
+ 		/* There's no point to continue to the next resource if the
+ 		 * command is not supported by the MFW.
+ 		 * We do continue if the command is supported but the resource
+ 		 * is unknown to the MFW. Such a resource will be later
+ 		 * configured with the default allocation values.
+ 		 */
+ 		if (mcp_resp == FW_MSG_CODE_UNSUPPORTED)
+ 			return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ int qed_hw_get_dflt_resc(struct qed_hwfn *p_hwfn,
+ 			 enum qed_resources res_id,
+ 			 u32 *p_resc_num, u32 *p_resc_start)
+ {
+ 	u8 num_funcs = p_hwfn->num_funcs_on_engine;
+ 	bool b_ah = QED_IS_AH(p_hwfn->cdev);
+ 	struct qed_sb_cnt_info sb_cnt_info;
+ 
+ 	switch (res_id) {
+ 	case QED_L2_QUEUE:
+ 		*p_resc_num = (b_ah ? MAX_NUM_L2_QUEUES_K2 :
+ 			       MAX_NUM_L2_QUEUES_BB) / num_funcs;
+ 		break;
+ 	case QED_VPORT:
+ 		*p_resc_num = (b_ah ? MAX_NUM_VPORTS_K2 :
+ 			       MAX_NUM_VPORTS_BB) / num_funcs;
+ 		break;
+ 	case QED_RSS_ENG:
+ 		*p_resc_num = (b_ah ? ETH_RSS_ENGINE_NUM_K2 :
+ 			       ETH_RSS_ENGINE_NUM_BB) / num_funcs;
+ 		break;
+ 	case QED_PQ:
+ 		*p_resc_num = (b_ah ? MAX_QM_TX_QUEUES_K2 :
+ 			       MAX_QM_TX_QUEUES_BB) / num_funcs;
+ 		*p_resc_num &= ~0x7;	/* The granularity of the PQs is 8 */
+ 		break;
+ 	case QED_RL:
+ 		*p_resc_num = MAX_QM_GLOBAL_RLS / num_funcs;
+ 		break;
+ 	case QED_MAC:
+ 	case QED_VLAN:
+ 		/* Each VFC resource can accommodate both a MAC and a VLAN */
+ 		*p_resc_num = ETH_NUM_MAC_FILTERS / num_funcs;
+ 		break;
+ 	case QED_ILT:
+ 		*p_resc_num = (b_ah ? PXP_NUM_ILT_RECORDS_K2 :
+ 			       PXP_NUM_ILT_RECORDS_BB) / num_funcs;
+ 		break;
+ 	case QED_LL2_QUEUE:
+ 		*p_resc_num = MAX_NUM_LL2_RX_QUEUES / num_funcs;
+ 		break;
+ 	case QED_RDMA_CNQ_RAM:
+ 	case QED_CMDQS_CQS:
+ 		/* CNQ/CMDQS are the same resource */
+ 		*p_resc_num = NUM_OF_CMDQS_CQS / num_funcs;
+ 		break;
+ 	case QED_RDMA_STATS_QUEUE:
+ 		*p_resc_num = (b_ah ? RDMA_NUM_STATISTIC_COUNTERS_K2 :
+ 			       RDMA_NUM_STATISTIC_COUNTERS_BB) / num_funcs;
+ 		break;
+ 	case QED_BDQ:
+ 		if (p_hwfn->hw_info.personality != QED_PCI_ISCSI &&
+ 		    p_hwfn->hw_info.personality != QED_PCI_FCOE)
+ 			*p_resc_num = 0;
+ 		else
+ 			*p_resc_num = 1;
+ 		break;
+ 	case QED_SB:
+ 		memset(&sb_cnt_info, 0, sizeof(sb_cnt_info));
+ 		qed_int_get_num_sbs(p_hwfn, &sb_cnt_info);
+ 		*p_resc_num = sb_cnt_info.sb_cnt;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (res_id) {
+ 	case QED_BDQ:
+ 		if (!*p_resc_num)
+ 			*p_resc_start = 0;
+ 		else if (p_hwfn->cdev->num_ports_in_engine == 4)
+ 			*p_resc_start = p_hwfn->port_id;
+ 		else if (p_hwfn->hw_info.personality == QED_PCI_ISCSI)
+ 			*p_resc_start = p_hwfn->port_id;
+ 		else if (p_hwfn->hw_info.personality == QED_PCI_FCOE)
+ 			*p_resc_start = p_hwfn->port_id + 2;
+ 		break;
+ 	default:
+ 		*p_resc_start = *p_resc_num * p_hwfn->enabled_func_idx;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int __qed_hw_set_resc_info(struct qed_hwfn *p_hwfn,
+ 				  enum qed_resources res_id)
+ {
+ 	u32 dflt_resc_num = 0, dflt_resc_start = 0;
+ 	u32 mcp_resp, *p_resc_num, *p_resc_start;
++>>>>>>> 78cea9ffaa34 (qed: Drop the 's' from num_ports_in_engines)
  	int rc;
  
  	p_resc_num = &RESC_NUM(p_hwfn, res_id);
@@@ -3974,3 -4060,17 +4135,20 @@@ int qed_device_num_engines(struct qed_d
  {
  	return QED_IS_BB(cdev) ? 2 : 1;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int qed_device_num_ports(struct qed_dev *cdev)
+ {
+ 	/* in CMT always only one port */
+ 	if (cdev->num_hwfns > 1)
+ 		return 1;
+ 
+ 	return cdev->num_ports_in_engine * qed_device_num_engines(cdev);
+ }
+ 
+ int qed_device_get_port_id(struct qed_dev *cdev)
+ {
+ 	return (QED_LEADING_HWFN(cdev)->abs_pf_id) % qed_device_num_ports(cdev);
+ }
++>>>>>>> 78cea9ffaa34 (qed: Drop the 's' from num_ports_in_engines)
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ptp.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed.h b/drivers/net/ethernet/qlogic/qed/qed.h
index 94f6dd236e7f..f1446379cad9 100644
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@ -597,7 +597,7 @@ struct qed_dev {
 #define CHIP_BOND_ID_SHIFT              0
 
 	u8				num_engines;
-	u8				num_ports_in_engines;
+	u8				num_ports_in_engine;
 	u8				num_funcs_in_port;
 
 	u8				path_id;
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.h b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
index ff91a2eb7d60..52b0a55f4752 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@ -481,7 +481,7 @@ int qed_mcp_bist_nvm_test_get_image_att(struct qed_hwfn *p_hwfn,
 #define MCP_PF_ID(p_hwfn) MCP_PF_ID_BY_REL(p_hwfn, (p_hwfn)->rel_pf_id)
 
 #define MFW_PORT(_p_hwfn)       ((_p_hwfn)->abs_pf_id %			  \
-				 ((_p_hwfn)->cdev->num_ports_in_engines * \
+				 ((_p_hwfn)->cdev->num_ports_in_engine * \
 				  qed_device_num_engines((_p_hwfn)->cdev)))
 
 struct qed_mcp_info {
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ptp.c
