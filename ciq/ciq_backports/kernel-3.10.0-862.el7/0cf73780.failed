hv_netvsc: netvsc_teardown_gpadl() split

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 0cf737808ae7cb25e952be619db46b9147a92f46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0cf73780.failed

It was found that in some cases host refuses to teardown GPADL for send/
receive buffers (probably when some work with these buffere is scheduled or
ongoing). Change the teardown logic to be:
1) Send NVSP_MSG1_TYPE_REVOKE_* messages
2) Close the channel
3) Teardown GPADLs.
This seems to work reliably.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0cf737808ae7cb25e952be619db46b9147a92f46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 05d0110585ac,bfc79698b8f4..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -99,37 -95,16 +99,41 @@@ static void free_netvsc_device(struct n
  	kfree(nvdev);
  }
  
 -static void free_netvsc_device_rcu(struct netvsc_device *nvdev)
 +static struct netvsc_device *get_outbound_net_device(struct hv_device *device)
 +{
 +	struct netvsc_device *net_device = hv_device_to_netvsc_device(device);
 +
 +	if (net_device && net_device->destroy)
 +		net_device = NULL;
 +
 +	return net_device;
 +}
 +
 +static struct netvsc_device *get_inbound_net_device(struct hv_device *device)
  {
 -	call_rcu(&nvdev->rcu, free_netvsc_device);
 +	struct netvsc_device *net_device = hv_device_to_netvsc_device(device);
 +
 +	if (!net_device)
 +		goto get_in_err;
 +
 +	if (net_device->destroy &&
 +	    atomic_read(&net_device->num_outstanding_sends) == 0 &&
 +	    atomic_read(&net_device->num_outstanding_recvs) == 0)
 +		net_device = NULL;
 +
 +get_in_err:
 +	return net_device;
  }
  
- static void netvsc_destroy_buf(struct hv_device *device)
+ static void netvsc_revoke_buf(struct hv_device *device,
+ 			      struct netvsc_device *net_device)
  {
  	struct nvsp_message *revoke_packet;
  	struct net_device *ndev = hv_get_drvdata(device);
++<<<<<<< HEAD
 +	struct netvsc_device *net_device = net_device_to_netvsc_device(ndev);
++=======
++>>>>>>> 0cf737808ae7 (hv_netvsc: netvsc_teardown_gpadl() split)
  	int ret;
  
  	/*
@@@ -169,36 -144,9 +173,39 @@@
  				"revoke receive buffer to netvsp\n");
  			return;
  		}
 +	}
 +
++<<<<<<< HEAD
 +	/* Teardown the gpadl on the vsp end */
 +	if (net_device->recv_buf_gpadl_handle) {
 +		ret = vmbus_teardown_gpadl(device->channel,
 +					   net_device->recv_buf_gpadl_handle);
 +
 +		/* If we failed here, we might as well return and have a leak
 +		 * rather than continue and a bugchk
 +		 */
 +		if (ret != 0) {
 +			netdev_err(ndev,
 +				   "unable to teardown receive buffer's gpadl\n");
 +			return;
 +		}
 +		net_device->recv_buf_gpadl_handle = 0;
 +	}
 +
 +	if (net_device->recv_buf) {
 +		/* Free up the receive buffer */
 +		vfree(net_device->recv_buf);
 +		net_device->recv_buf = NULL;
 +	}
 +
 +	if (net_device->recv_section) {
  		net_device->recv_section_cnt = 0;
 +		kfree(net_device->recv_section);
 +		net_device->recv_section = NULL;
  	}
  
++=======
++>>>>>>> 0cf737808ae7 (hv_netvsc: netvsc_teardown_gpadl() split)
  	/* Deal with the send buffer we may have setup.
  	 * If we got a  send section size, it means we received a
  	 * NVSP_MSG1_TYPE_SEND_SEND_BUF_COMPLETE msg (ie sent
@@@ -237,8 -185,37 +244,36 @@@
  				   "revoke send buffer to netvsp\n");
  			return;
  		}
 -		net_device->send_section_cnt = 0;
  	}
- 	/* Teardown the gpadl on the vsp end */
+ }
+ 
+ static void netvsc_teardown_gpadl(struct hv_device *device,
+ 				  struct netvsc_device *net_device)
+ {
+ 	struct net_device *ndev = hv_get_drvdata(device);
+ 	int ret;
+ 
+ 	if (net_device->recv_buf_gpadl_handle) {
+ 		ret = vmbus_teardown_gpadl(device->channel,
+ 					   net_device->recv_buf_gpadl_handle);
+ 
+ 		/* If we failed here, we might as well return and have a leak
+ 		 * rather than continue and a bugchk
+ 		 */
+ 		if (ret != 0) {
+ 			netdev_err(ndev,
+ 				   "unable to teardown receive buffer's gpadl\n");
+ 			return;
+ 		}
+ 		net_device->recv_buf_gpadl_handle = 0;
+ 	}
+ 
+ 	if (net_device->recv_buf) {
+ 		/* Free up the receive buffer */
+ 		vfree(net_device->recv_buf);
+ 		net_device->recv_buf = NULL;
+ 	}
+ 
  	if (net_device->send_buf_gpadl_handle) {
  		ret = vmbus_teardown_gpadl(device->channel,
  					   net_device->send_buf_gpadl_handle);
@@@ -575,11 -552,15 +606,11 @@@ void netvsc_device_remove(struct hv_dev
  {
  	struct net_device *ndev = hv_get_drvdata(device);
  	struct net_device_context *net_device_ctx = netdev_priv(ndev);
 -	struct netvsc_device *net_device
 -		= rtnl_dereference(net_device_ctx->nvdev);
 -	int i;
 -
 -	cancel_work_sync(&net_device->subchan_work);
 +	struct netvsc_device *net_device = net_device_ctx->nvdev;
  
- 	netvsc_disconnect_vsp(device);
+ 	netvsc_revoke_buf(device, net_device);
  
 -	RCU_INIT_POINTER(net_device_ctx->nvdev, NULL);
 +	net_device_ctx->nvdev = NULL;
  
  	/*
  	 * At this point, no one should be accessing net_device
@@@ -590,9 -571,14 +621,18 @@@
  	/* Now, we can close the channel safely */
  	vmbus_close(device->channel);
  
++<<<<<<< HEAD
++=======
+ 	netvsc_teardown_gpadl(device, net_device);
+ 
+ 	/* And dissassociate NAPI context from device */
+ 	for (i = 0; i < net_device->num_chn; i++)
+ 		netif_napi_del(&net_device->chan_table[i].napi);
+ 
++>>>>>>> 0cf737808ae7 (hv_netvsc: netvsc_teardown_gpadl() split)
  	/* Release all resources */
 -	free_netvsc_device_rcu(net_device);
 +	vfree(net_device->sub_cb_buf);
 +	free_netvsc_device(net_device);
  }
  
  #define RING_AVAIL_PERCENT_HIWATER 20
* Unmerged path drivers/net/hyperv/netvsc.c
