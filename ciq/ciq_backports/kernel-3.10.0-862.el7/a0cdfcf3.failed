packet: deliver VLAN TPID to userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Atzm Watanabe <atzm@stratosphere.co.jp>
commit a0cdfcf39362410d5ea983f4daf67b38de129408
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a0cdfcf3.failed

This enables userspace to get VLAN TPID as well as the VLAN TCI.

	Signed-off-by: Atzm Watanabe <atzm@stratosphere.co.jp>
	Acked-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a0cdfcf39362410d5ea983f4daf67b38de129408)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/packet/af_packet.c
diff --cc net/packet/af_packet.c
index c5a5aa0095f4,dd3840846ce2..000000000000
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@@ -932,11 -975,13 +932,19 @@@ static void prb_clear_rxhash(struct tpa
  static void prb_fill_vlan_info(struct tpacket_kbdq_core *pkc,
  			struct tpacket3_hdr *ppd)
  {
++<<<<<<< HEAD
 +	if (skb_vlan_tag_present(pkc->skb)) {
 +		ppd->hv1.tp_vlan_tci = skb_vlan_tag_get(pkc->skb);
 +		ppd->tp_status = TP_STATUS_VLAN_VALID;
++=======
+ 	if (vlan_tx_tag_present(pkc->skb)) {
+ 		ppd->hv1.tp_vlan_tci = vlan_tx_tag_get(pkc->skb);
+ 		ppd->hv1.tp_vlan_tpid = ntohs(pkc->skb->vlan_proto);
+ 		ppd->tp_status = TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;
++>>>>>>> a0cdfcf39362 (packet: deliver VLAN TPID to userspace)
  	} else {
  		ppd->hv1.tp_vlan_tci = 0;
+ 		ppd->hv1.tp_vlan_tpid = 0;
  		ppd->tp_status = TP_STATUS_AVAILABLE;
  	}
  }
@@@ -1925,11 -1926,13 +1934,19 @@@ static int tpacket_rcv(struct sk_buff *
  		h.h2->tp_net = netoff;
  		h.h2->tp_sec = ts.tv_sec;
  		h.h2->tp_nsec = ts.tv_nsec;
++<<<<<<< HEAD
 +		if (skb_vlan_tag_present(skb)) {
 +			h.h2->tp_vlan_tci = skb_vlan_tag_get(skb);
 +			status |= TP_STATUS_VLAN_VALID;
++=======
+ 		if (vlan_tx_tag_present(skb)) {
+ 			h.h2->tp_vlan_tci = vlan_tx_tag_get(skb);
+ 			h.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);
+ 			status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;
++>>>>>>> a0cdfcf39362 (packet: deliver VLAN TPID to userspace)
  		} else {
  			h.h2->tp_vlan_tci = 0;
+ 			h.h2->tp_vlan_tpid = 0;
  		}
  		memset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));
  		hdrlen = sizeof(*h.h2);
@@@ -2965,13 -2878,14 +2982,20 @@@ static int packet_recvmsg(struct kiocb 
  		aux.tp_snaplen = skb->len;
  		aux.tp_mac = 0;
  		aux.tp_net = skb_network_offset(skb);
++<<<<<<< HEAD
 +		if (skb_vlan_tag_present(skb)) {
 +			aux.tp_vlan_tci = skb_vlan_tag_get(skb);
 +			aux.tp_status |= TP_STATUS_VLAN_VALID;
++=======
+ 		if (vlan_tx_tag_present(skb)) {
+ 			aux.tp_vlan_tci = vlan_tx_tag_get(skb);
+ 			aux.tp_vlan_tpid = ntohs(skb->vlan_proto);
+ 			aux.tp_status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;
++>>>>>>> a0cdfcf39362 (packet: deliver VLAN TPID to userspace)
  		} else {
  			aux.tp_vlan_tci = 0;
+ 			aux.tp_vlan_tpid = 0;
  		}
- 		aux.tp_padding = 0;
  		put_cmsg(msg, SOL_PACKET, PACKET_AUXDATA, sizeof(aux), &aux);
  	}
  
diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 854d4e37701a..f8c98dc6537f 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -83,17 +83,18 @@ struct tpacket_auxdata {
 	__u16		tp_mac;
 	__u16		tp_net;
 	__u16		tp_vlan_tci;
-	__u16		tp_padding;
+	__u16		tp_vlan_tpid;
 };
 
 /* Rx ring - header status */
-#define TP_STATUS_KERNEL	      0
-#define TP_STATUS_USER		(1 << 0)
-#define TP_STATUS_COPY		(1 << 1)
-#define TP_STATUS_LOSING	(1 << 2)
-#define TP_STATUS_CSUMNOTREADY	(1 << 3)
-#define TP_STATUS_VLAN_VALID	(1 << 4) /* auxdata has valid tp_vlan_tci */
-#define TP_STATUS_BLK_TMO	(1 << 5)
+#define TP_STATUS_KERNEL		      0
+#define TP_STATUS_USER			(1 << 0)
+#define TP_STATUS_COPY			(1 << 1)
+#define TP_STATUS_LOSING		(1 << 2)
+#define TP_STATUS_CSUMNOTREADY		(1 << 3)
+#define TP_STATUS_VLAN_VALID		(1 << 4) /* auxdata has valid tp_vlan_tci */
+#define TP_STATUS_BLK_TMO		(1 << 5)
+#define TP_STATUS_VLAN_TPID_VALID	(1 << 6) /* auxdata has valid tp_vlan_tpid */
 
 /* Tx ring - header status */
 #define TP_STATUS_AVAILABLE	      0
@@ -132,12 +133,15 @@ struct tpacket2_hdr {
 	__u32		tp_sec;
 	__u32		tp_nsec;
 	__u16		tp_vlan_tci;
-	__u8		tp_padding[6];
+	__u16		tp_vlan_tpid;
+	__u8		tp_padding[4];
 };
 
 struct tpacket_hdr_variant1 {
 	__u32	tp_rxhash;
 	__u32	tp_vlan_tci;
+	__u16	tp_vlan_tpid;
+	__u16	tp_padding;
 };
 
 struct tpacket3_hdr {
@@ -153,7 +157,7 @@ struct tpacket3_hdr {
 	union {
 		struct tpacket_hdr_variant1 hv1;
 	};
-	__u8		tp_padding[12];
+	__u8		tp_padding[8];
 };
 
 struct tpacket_bd_ts {
* Unmerged path net/packet/af_packet.c
