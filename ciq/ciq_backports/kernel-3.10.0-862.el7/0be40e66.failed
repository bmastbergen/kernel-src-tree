nfp: keep MIP object around

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 0be40e66e72a544e2d4a5bca9328463ebf2c55df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0be40e66.failed

Microcode Information Page contains some useful information, like
application firmware build name.  Keep it around, similar to RTSym
and HWInfo.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0be40e66e72a544e2d4a5bca9328463ebf2c55df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_main.h
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.c
index 813e29b99369,4e59dcb78c36..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.c
@@@ -362,7 -373,10 +362,14 @@@ static int nfp_pci_probe(struct pci_de
  
  	err = nfp_nsp_init(pdev, pf);
  	if (err)
++<<<<<<< HEAD
 +		goto err_cpp_free;
++=======
+ 		goto err_devlink_unreg;
+ 
+ 	pf->mip = nfp_mip_open(pf->cpp);
+ 	pf->rtbl = __nfp_rtsym_table_read(pf->cpp, pf->mip);
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  
  	err = nfp_pcie_sriov_read_nfd_limit(pf);
  	if (err)
@@@ -377,6 -397,10 +384,11 @@@
  err_sriov_unlimit:
  	pci_sriov_set_totalvfs(pf->pdev, 0);
  err_fw_unload:
++<<<<<<< HEAD
++=======
+ 	kfree(pf->rtbl);
+ 	nfp_mip_close(pf->mip);
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  	if (pf->fw_loaded)
  		nfp_fw_unload(pf);
  	kfree(pf->eth_tbl);
@@@ -402,6 -436,10 +414,13 @@@ static void nfp_pci_remove(struct pci_d
  	nfp_pcie_sriov_disable(pdev);
  	pci_sriov_set_totalvfs(pf->pdev, 0);
  
++<<<<<<< HEAD
++=======
+ 	devlink_unregister(devlink);
+ 
+ 	kfree(pf->rtbl);
+ 	nfp_mip_close(pf->mip);
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  	if (pf->fw_loaded)
  		nfp_fw_unload(pf);
  
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.h
index 1ac430fbaa18,88724f8d0dcd..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.h
@@@ -52,6 -54,11 +52,14 @@@ struct pci_dev
  struct nfp_cpp;
  struct nfp_cpp_area;
  struct nfp_eth_table;
++<<<<<<< HEAD
++=======
+ struct nfp_hwinfo;
+ struct nfp_mip;
+ struct nfp_net;
+ struct nfp_nsp_identify;
+ struct nfp_rtsym_table;
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  
  /**
   * struct nfp_pf - NFP PF-specific device structure
@@@ -64,12 -72,20 +72,19 @@@
   * @limit_vfs:		Number of VFs supported by firmware (~0 for PCI limit)
   * @num_vfs:		Number of SR-IOV VFs enabled
   * @fw_loaded:		Is the firmware loaded?
++<<<<<<< HEAD
++=======
+  * @ctrl_vnic:		Pointer to the control vNIC if available
+  * @mip:		MIP handle
+  * @rtbl:		RTsym table
+  * @hwinfo:		HWInfo table
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
   * @eth_tbl:		NSP ETH table
 - * @nspi:		NSP identification info
 - * @hwmon_dev:		pointer to hwmon device
   * @ddir:		Per-device debugfs directory
 - * @max_data_vnics:	Number of data vNICs app firmware supports
 - * @num_vnics:		Number of vNICs spawned
 - * @vnics:		Linked list of vNIC structures (struct nfp_net)
 - * @ports:		Linked list of port structures (struct nfp_port)
 + * @num_ports:		Number of adapter ports
 + * @ports:		Linked list of port structures (struct nfp_net)
 + * @port_lock:		Protects @ports, @num_ports, @num_netdevs
   * @port_refresh_work:	Work entry for taking netdevs out
 - * @lock:		Protects all fields which may change after probe
   */
  struct nfp_pf {
  	struct pci_dev *pdev;
@@@ -87,7 -105,15 +102,15 @@@
  
  	bool fw_loaded;
  
++<<<<<<< HEAD
++=======
+ 	struct nfp_net *ctrl_vnic;
+ 
+ 	const struct nfp_mip *mip;
+ 	struct nfp_rtsym_table *rtbl;
+ 	struct nfp_hwinfo *hwinfo;
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  	struct nfp_eth_table *eth_tbl;
 -	struct nfp_nsp_identify *nspi;
 -
 -	struct device *hwmon_dev;
  
  	struct dentry *ddir;
  
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
index 988badd230d1,c7266baec0eb..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
@@@ -87,9 -87,16 +87,23 @@@ struct nfp_rtsym 
  	int domain;
  };
  
++<<<<<<< HEAD
 +int nfp_rtsym_count(struct nfp_cpp *cpp);
 +const struct nfp_rtsym *nfp_rtsym_get(struct nfp_cpp *cpp, int idx);
 +const struct nfp_rtsym *nfp_rtsym_lookup(struct nfp_cpp *cpp, const char *name);
 +u64 nfp_rtsym_read_le(struct nfp_cpp *cpp, const char *name, int *error);
++=======
+ struct nfp_rtsym_table;
+ 
+ struct nfp_rtsym_table *nfp_rtsym_table_read(struct nfp_cpp *cpp);
+ struct nfp_rtsym_table *
+ __nfp_rtsym_table_read(struct nfp_cpp *cpp, const struct nfp_mip *mip);
+ int nfp_rtsym_count(struct nfp_rtsym_table *rtbl);
+ const struct nfp_rtsym *nfp_rtsym_get(struct nfp_rtsym_table *rtbl, int idx);
+ const struct nfp_rtsym *
+ nfp_rtsym_lookup(struct nfp_rtsym_table *rtbl, const char *name);
+ u64 nfp_rtsym_read_le(struct nfp_rtsym_table *rtbl, const char *name,
+ 		      int *error);
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  
  #endif /* NFP_NFFW_H */
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
index bdfbfe4752ce,203f9cbae0fb..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
@@@ -105,26 -107,36 +105,41 @@@ nfp_rtsym_sw_entry_init(struct nfp_rtsy
  		sw->domain = -1;
  }
  
 -struct nfp_rtsym_table *nfp_rtsym_table_read(struct nfp_cpp *cpp)
 +static int nfp_rtsymtab_probe(struct nfp_cpp *cpp)
+ {
+ 	struct nfp_rtsym_table *rtbl;
+ 	const struct nfp_mip *mip;
+ 
+ 	mip = nfp_mip_open(cpp);
+ 	rtbl = __nfp_rtsym_table_read(cpp, mip);
+ 	nfp_mip_close(mip);
+ 
+ 	return rtbl;
+ }
+ 
+ struct nfp_rtsym_table *
+ __nfp_rtsym_table_read(struct nfp_cpp *cpp, const struct nfp_mip *mip)
  {
  	const u32 dram = NFP_CPP_ID(NFP_CPP_TARGET_MU, NFP_CPP_ACTION_RW, 0) |
  		NFP_ISL_EMEM0;
  	u32 strtab_addr, symtab_addr, strtab_size, symtab_size;
  	struct nfp_rtsym_entry *rtsymtab;
++<<<<<<< HEAD
 +	struct nfp_rtsym_cache *cache;
 +	const struct nfp_mip *mip;
++=======
+ 	struct nfp_rtsym_table *cache;
++>>>>>>> 0be40e66e72a (nfp: keep MIP object around)
  	int err, n, size;
  
- 	mip = nfp_mip_open(cpp);
  	if (!mip)
 -		return NULL;
 +		return -EIO;
  
  	nfp_mip_strtab(mip, &strtab_addr, &strtab_size);
  	nfp_mip_symtab(mip, &symtab_addr, &symtab_size);
- 	nfp_mip_close(mip);
  
  	if (!symtab_size || !strtab_size || symtab_size % sizeof(*rtsymtab))
 -		return NULL;
 +		return -ENXIO;
  
  	/* Align to 64 bits */
  	symtab_size = round_up(symtab_size, 8);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
