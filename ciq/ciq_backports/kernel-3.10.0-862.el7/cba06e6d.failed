scsi: cxlflash: Implement IRQ polling for RRQ processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Implement IRQ polling for RRQ processing (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 94.34%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit cba06e6de4038cd44a3e93a92ad982c372b8a14e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cba06e6d.failed

Currently, RRQ processing takes place on hardware interrupt context. This can
be a heavy burden in some environments due to the overhead encountered while
completing RRQ entries. In an effort to improve system performance, use the
IRQ polling API to schedule this processing on softirq context.

This function will be disabled by default until starting values can be
established for the hardware supported by this driver.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit cba06e6de4038cd44a3e93a92ad982c372b8a14e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,3ff05f15b417..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -183,6 -203,28 +186,31 @@@ struct afu 
  
  };
  
++<<<<<<< HEAD
++=======
+ static inline bool afu_is_irqpoll_enabled(struct afu *afu)
+ {
+ 	return !!afu->irqpoll_weight;
+ }
+ 
+ static inline bool afu_is_cmd_mode(struct afu *afu, u64 cmd_mode)
+ {
+ 	u64 afu_cap = afu->interface_version >> SISL_INTVER_CAP_SHIFT;
+ 
+ 	return afu_cap & cmd_mode;
+ }
+ 
+ static inline bool afu_is_sq_cmd_mode(struct afu *afu)
+ {
+ 	return afu_is_cmd_mode(afu, SISL_INTVER_CAP_SQ_CMD_MODE);
+ }
+ 
+ static inline bool afu_is_ioarrin_cmd_mode(struct afu *afu)
+ {
+ 	return afu_is_cmd_mode(afu, SISL_INTVER_CAP_IOARRIN_CMD_MODE);
+ }
+ 
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
  static inline u64 lun_to_lunid(u64 lun)
  {
  	__be64 lun_id;
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,30d68af87d1d..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -587,15 -553,8 +587,20 @@@ static void free_mem(struct cxlflash_cf
   *
   * Safe to call with AFU in a partially allocated/initialized state.
   *
++<<<<<<< HEAD
 + * Cleans up all state associated with the command queue, and unmaps
 + * the MMIO space.
 + *
 + *  - complete() will take care of commands we initiated (they'll be checked
 + *  in as part of the cleanup that occurs after the completion)
 + *
 + *  - cmd_checkin() will take care of entries that we did not initiate and that
 + *  have not (and will not) complete because they are sitting on a [now stale]
 + *  hardware queue
++=======
+  * Cancels scheduled worker threads, waits for any active internal AFU
+  * commands to timeout, disables IRQ polling and then unmaps the MMIO space.
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
   */
  static void stop_afu(struct cxlflash_cfg *cfg)
  {
@@@ -606,13 -563,10 +611,20 @@@
  	cancel_work_sync(&cfg->work_q);
  
  	if (likely(afu)) {
++<<<<<<< HEAD
 +		for (i = 0; i < CXLFLASH_NUM_CMDS; i++) {
 +			cmd = &afu->cmd[i];
 +			complete(&cmd->cevent);
 +			if (!atomic_read(&cmd->free))
 +				cmd_checkin(cmd);
 +		}
 +
++=======
+ 		while (atomic_read(&afu->cmds_active))
+ 			ssleep(1);
+ 		if (afu_is_irqpoll_enabled(afu))
+ 			irq_poll_disable(&afu->irqpoll);
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
  		if (likely(afu->afu_map)) {
  			cxl_psa_unmap((void __iomem *)afu->afu_map);
  			afu->afu_map = NULL;
@@@ -1210,17 -1157,22 +1222,28 @@@ cxlflash_sync_err_irq_exit
  }
  
  /**
++<<<<<<< HEAD
 + * cxlflash_rrq_irq() - interrupt handler for read-response queue (normal path)
 + * @irq:	Interrupt number.
 + * @data:	Private data provided at interrupt registration, the AFU.
++=======
+  * process_hrrq() - process the read-response queue
+  * @afu:	AFU associated with the host.
+  * @doneq:	Queue of commands harvested from the RRQ.
+  * @budget:	Threshold of RRQ entries to process.
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
   *
 - * This routine must be called holding the disabled RRQ spin lock.
 - *
 - * Return: The number of entries processed.
 + * Return: Always return IRQ_HANDLED.
   */
++<<<<<<< HEAD
 +static irqreturn_t cxlflash_rrq_irq(int irq, void *data)
++=======
+ static int process_hrrq(struct afu *afu, struct list_head *doneq, int budget)
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
  {
 +	struct afu *afu = (struct afu *)data;
  	struct afu_cmd *cmd;
 -	struct sisl_ioasa *ioasa;
 -	struct sisl_ioarcb *ioarcb;
  	bool toggle = afu->toggle;
 -	int num_hrrq = 0;
  	u64 entry,
  	    *hrrq_start = afu->hrrq_start,
  	    *hrrq_end = afu->hrrq_end,
@@@ -1243,11 -1204,91 +1266,97 @@@
  			hrrq_curr = hrrq_start;
  			toggle ^= SISL_RESP_HANDLE_T_BIT;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		atomic_inc(&afu->hsq_credits);
+ 		num_hrrq++;
+ 
+ 		if (budget > 0 && num_hrrq >= budget)
+ 			break;
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
  	}
  
  	afu->hrrq_curr = hrrq_curr;
  	afu->toggle = toggle;
  
++<<<<<<< HEAD
++=======
+ 	return num_hrrq;
+ }
+ 
+ /**
+  * process_cmd_doneq() - process a queue of harvested RRQ commands
+  * @doneq:	Queue of completed commands.
+  *
+  * Note that upon return the queue can no longer be trusted.
+  */
+ static void process_cmd_doneq(struct list_head *doneq)
+ {
+ 	struct afu_cmd *cmd, *tmp;
+ 
+ 	WARN_ON(list_empty(doneq));
+ 
+ 	list_for_each_entry_safe(cmd, tmp, doneq, queue)
+ 		cmd_complete(cmd);
+ }
+ 
+ /**
+  * cxlflash_irqpoll() - process a queue of harvested RRQ commands
+  * @irqpoll:	IRQ poll structure associated with queue to poll.
+  * @budget:	Threshold of RRQ entries to process per poll.
+  *
+  * Return: The number of entries processed.
+  */
+ static int cxlflash_irqpoll(struct irq_poll *irqpoll, int budget)
+ {
+ 	struct afu *afu = container_of(irqpoll, struct afu, irqpoll);
+ 	unsigned long hrrq_flags;
+ 	LIST_HEAD(doneq);
+ 	int num_entries = 0;
+ 
+ 	spin_lock_irqsave(&afu->hrrq_slock, hrrq_flags);
+ 
+ 	num_entries = process_hrrq(afu, &doneq, budget);
+ 	if (num_entries < budget)
+ 		irq_poll_complete(irqpoll);
+ 
+ 	spin_unlock_irqrestore(&afu->hrrq_slock, hrrq_flags);
+ 
+ 	process_cmd_doneq(&doneq);
+ 	return num_entries;
+ }
+ 
+ /**
+  * cxlflash_rrq_irq() - interrupt handler for read-response queue (normal path)
+  * @irq:	Interrupt number.
+  * @data:	Private data provided at interrupt registration, the AFU.
+  *
+  * Return: IRQ_HANDLED or IRQ_NONE when no ready entries found.
+  */
+ static irqreturn_t cxlflash_rrq_irq(int irq, void *data)
+ {
+ 	struct afu *afu = (struct afu *)data;
+ 	unsigned long hrrq_flags;
+ 	LIST_HEAD(doneq);
+ 	int num_entries = 0;
+ 
+ 	spin_lock_irqsave(&afu->hrrq_slock, hrrq_flags);
+ 
+ 	if (afu_is_irqpoll_enabled(afu)) {
+ 		irq_poll_sched(&afu->irqpoll);
+ 		spin_unlock_irqrestore(&afu->hrrq_slock, hrrq_flags);
+ 		return IRQ_HANDLED;
+ 	}
+ 
+ 	num_entries = process_hrrq(afu, &doneq, -1);
+ 	spin_unlock_irqrestore(&afu->hrrq_slock, hrrq_flags);
+ 
+ 	if (num_entries == 0)
+ 		return IRQ_NONE;
+ 
+ 	process_cmd_doneq(&doneq);
++>>>>>>> cba06e6de403 (scsi: cxlflash: Implement IRQ polling for RRQ processing)
  	return IRQ_HANDLED;
  }
  
@@@ -1588,10 -1614,27 +1697,15 @@@ static int start_afu(struct cxlflash_cf
  	afu->hrrq_end = &afu->rrq_entry[NUM_RRQ_ENTRY - 1];
  	afu->hrrq_curr = afu->hrrq_start;
  	afu->toggle = 1;
 -	spin_lock_init(&afu->hrrq_slock);
 -
 -	/* Initialize SQ */
 -	if (afu_is_sq_cmd_mode(afu)) {
 -		memset(&afu->sq, 0, sizeof(afu->sq));
 -		afu->hsq_start = &afu->sq[0];
 -		afu->hsq_end = &afu->sq[NUM_SQ_ENTRY - 1];
 -		afu->hsq_curr = afu->hsq_start;
 -
 -		spin_lock_init(&afu->hsq_slock);
 -		atomic_set(&afu->hsq_credits, NUM_SQ_ENTRY - 1);
 -	}
  
+ 	/* Initialize IRQ poll */
+ 	if (afu_is_irqpoll_enabled(afu))
+ 		irq_poll_init(&afu->irqpoll, afu->irqpoll_weight,
+ 			      cxlflash_irqpoll);
+ 
  	rc = init_global(cfg);
  
 -	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
 +	pr_debug("%s: returning rc=%d\n", __func__, rc);
  	return rc;
  }
  
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
