scsi: lpfc: Fix handling of FCP and NVME FC4 types in Pt2Pt topology

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix handling of FCP and NVME FC4 types in Pt2Pt topology (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 95.38%
commit-author Dick Kennedy <dick.kennedy@broadcom.com>
commit 8db1c2b3e7fa1b1a75a8dddc77bf516acfc03e8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8db1c2b3.failed

After link bounce in a NVME Pt2Pt config, the driver managed to map the
same nport twice, resulting in multiple device nodes for the same
namespace.

In Pt2Pt, the driver must send PRLI's for both (scsi) FCP and NVME
rather than using fabric aids. The driver was inconsistent on handling
various PRLI completions, especially rejects, which had reject codes
cross the different protocol PRLI completions.

Fixed to perform the following: if nvmet mode (fc port can only be a
nvme target) - rejects all unsolicitly FCP PRLI's. Never issues a FCP
PRLI.

The multiple protocol PRLI's are sent simultaneously. However, driver
will now only state transition after both PRLI's are complete. New flags
were added to aid tracking the responses from the different PRLI's.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8db1c2b3e7fa1b1a75a8dddc77bf516acfc03e8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_disc.h
#	drivers/scsi/lpfc/lpfc_nportdisc.c
diff --cc drivers/scsi/lpfc/lpfc_disc.h
index 361f5b3d9d93,f9a566eaef04..000000000000
--- a/drivers/scsi/lpfc/lpfc_disc.h
+++ b/drivers/scsi/lpfc/lpfc_disc.h
@@@ -139,6 -158,8 +139,11 @@@ struct lpfc_node_rrq 
  #define NLP_LOGO_SND       0x00000100	/* sent LOGO request for this entry */
  #define NLP_RNID_SND       0x00000400	/* sent RNID request for this entry */
  #define NLP_ELS_SND_MASK   0x000007e0	/* sent ELS request for this entry */
++<<<<<<< HEAD
++=======
+ #define NLP_NVMET_RECOV    0x00001000   /* NVMET auditing node for recovery. */
+ #define NLP_FCP_PRLI_RJT   0x00002000   /* Rport does not support FCP PRLI. */
++>>>>>>> 8db1c2b3e7fa (scsi: lpfc: Fix handling of FCP and NVME FC4 types in Pt2Pt topology)
  #define NLP_DEFER_RM       0x00010000	/* Remove this ndlp if no longer used */
  #define NLP_DELAY_TMO      0x00020000	/* delay timeout is running for node */
  #define NLP_NPR_2B_DISC    0x00040000	/* node is included in num_disc_nodes */
diff --cc drivers/scsi/lpfc/lpfc_nportdisc.c
index 7ae2f18f5f51,f3ad7cac355d..000000000000
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@@ -1750,7 -1894,30 +1750,32 @@@ lpfc_cmpl_prli_prli_issue(struct lpfc_v
  		    vport->cfg_restrict_login) {
  			goto out;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		/* When the rport rejected the FCP PRLI as unsupported.
+ 		 * This should only happen in Pt2Pt so an NVME PRLI
+ 		 * should be outstanding still.
+ 		 */
+ 		if (npr && ndlp->nlp_flag & NLP_FCP_PRLI_RJT) {
+ 			ndlp->nlp_fc4_type &= ~NLP_FC4_FCP;
+ 			goto out_err;
+ 		}
+ 
+ 		/* The LS Req had some error.  Don't let this be a
+ 		 * target.
+ 		 */
+ 		if ((ndlp->fc4_prli_sent == 1) &&
+ 		    (ndlp->nlp_state == NLP_STE_PRLI_ISSUE) &&
+ 		    (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_FCP_INITIATOR)))
+ 			/* The FCP PRLI completed successfully but
+ 			 * the NVME PRLI failed.  Since they are sent in
+ 			 * succession, allow the FCP to complete.
+ 			 */
+ 			goto out_err;
+ 
++>>>>>>> 8db1c2b3e7fa (scsi: lpfc: Fix handling of FCP and NVME FC4 types in Pt2Pt topology)
  		ndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;
 -		ndlp->nlp_type |= NLP_FCP_INITIATOR;
  		lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
  		return ndlp->nlp_state;
  	}
* Unmerged path drivers/scsi/lpfc/lpfc_disc.h
diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c
index 78403404be57..e0690ec90df4 100644
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@ -1962,6 +1962,7 @@ int
 lpfc_issue_els_plogi(struct lpfc_vport *vport, uint32_t did, uint8_t retry)
 {
 	struct lpfc_hba  *phba = vport->phba;
+	struct Scsi_Host *shost;
 	struct serv_parm *sp;
 	struct lpfc_nodelist *ndlp;
 	struct lpfc_iocbq *elsiocb;
@@ -1980,6 +1981,11 @@ lpfc_issue_els_plogi(struct lpfc_vport *vport, uint32_t did, uint8_t retry)
 	if (!elsiocb)
 		return 1;
 
+	shost = lpfc_shost_from_vport(vport);
+	spin_lock_irq(shost->host_lock);
+	ndlp->nlp_flag &= ~NLP_FCP_PRLI_RJT;
+	spin_unlock_irq(shost->host_lock);
+
 	pcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);
 
 	/* For PLOGI request, remainder of payload is service parameters */
@@ -3315,6 +3321,21 @@ lpfc_els_retry(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
 				goto out_retry;
 			}
 			break;
+		case LSRJT_CMD_UNSUPPORTED:
+			/* lpfc nvmet returns this type of LS_RJT when it
+			 * receives an FCP PRLI because lpfc nvmet only
+			 * support NVME.  ELS request is terminated for FCP4
+			 * on this rport.
+			 */
+			if (stat.un.b.lsRjtRsnCodeExp ==
+			    LSEXP_REQ_UNSUPPORTED && cmd == ELS_CMD_PRLI) {
+				spin_lock_irq(shost->host_lock);
+				ndlp->nlp_flag |= NLP_FCP_PRLI_RJT;
+				spin_unlock_irq(shost->host_lock);
+				retry = 0;
+				goto out_retry;
+			}
+			break;
 		}
 		break;
 
@@ -7796,6 +7817,13 @@ lpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,
 			rjt_exp = LSEXP_NOTHING_MORE;
 			break;
 		}
+
+		/* NVMET accepts NVME PRLI only.  Reject FCP PRLI */
+		if (cmd == ELS_CMD_PRLI && phba->nvmet_support) {
+			rjt_err = LSRJT_CMD_UNSUPPORTED;
+			rjt_exp = LSEXP_REQ_UNSUPPORTED;
+			break;
+		}
 		lpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLI);
 		break;
 	case ELS_CMD_LIRR:
* Unmerged path drivers/scsi/lpfc/lpfc_nportdisc.c
