iommu/amd: Make call-sites of get_device_id aware of its return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] amd: Make call-sites of get_device_id aware of its return value (Jerry Snitselaar) [1411581]
Rebuild_FUZZ: 95.45%
commit-author Wan Zongshun <Vincent.Wan@amd.com>
commit 7aba6cb9ee9db7849d0bf57891d9c7feb4e89457
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7aba6cb9.failed

This patch is to make the call-sites of get_device_id aware of its
return value.

	Signed-off-by: Wan Zongshun <Vincent.Wan@amd.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 7aba6cb9ee9db7849d0bf57891d9c7feb4e89457)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu.c
diff --cc drivers/iommu/amd_iommu.c
index 6eeb01f55cdf,400867f01d35..000000000000
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@@ -416,7 -346,7 +420,11 @@@ static int iommu_init_device(struct dev
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct iommu_dev_data *dev_data;
++<<<<<<< HEAD
 +	u16 alias;
++=======
+ 	int devid;
++>>>>>>> 7aba6cb9ee9d (iommu/amd: Make call-sites of get_device_id aware of its return value)
  
  	if (dev->archdata.iommu)
  		return 0;
@@@ -3882,227 -3837,311 +3913,244 @@@ static void free_irte(u16 devid, int in
  	iommu_completion_wait(iommu);
  }
  
 -static int get_devid(struct irq_alloc_info *info)
 +static int setup_ioapic_entry(int irq, struct IO_APIC_route_entry *entry,
 +			      unsigned int destination, int vector,
 +			      struct io_apic_irq_attr *attr)
  {
 -	int devid = -1;
 +	struct irq_remap_table *table;
 +	struct irq_2_irte *irte_info;
 +	struct irq_cfg *cfg;
 +	union irte irte;
 +	int ioapic_id;
 +	int index;
 +	int devid;
 +	int ret;
  
 -	switch (info->type) {
 -	case X86_IRQ_ALLOC_TYPE_IOAPIC:
 -		devid     = get_ioapic_devid(info->ioapic_id);
 -		break;
 -	case X86_IRQ_ALLOC_TYPE_HPET:
 -		devid     = get_hpet_devid(info->hpet_id);
 -		break;
 -	case X86_IRQ_ALLOC_TYPE_MSI:
 -	case X86_IRQ_ALLOC_TYPE_MSIX:
 -		devid = get_device_id(&info->msi_dev->dev);
 -		break;
 -	default:
 -		BUG_ON(1);
 -		break;
 -	}
 +	cfg = irq_get_chip_data(irq);
 +	if (!cfg)
 +		return -EINVAL;
 +
 +	irte_info = &cfg->irq_2_irte;
 +	ioapic_id = mpc_ioapic_id(attr->ioapic);
 +	devid     = get_ioapic_devid(ioapic_id);
 +
 +	if (devid < 0)
 +		return devid;
 +
 +	table = get_irq_table(devid, true);
 +	if (table == NULL)
 +		return -ENOMEM;
 +
 +	index = attr->ioapic_pin;
 +
 +	/* Setup IRQ remapping info */
 +	cfg->remapped	      = 1;
 +	irte_info->devid      = devid;
 +	irte_info->index      = index;
 +
 +	/* Setup IRTE for IOMMU */
 +	irte.val		= 0;
 +	irte.fields.vector      = vector;
 +	irte.fields.int_type    = apic->irq_delivery_mode;
 +	irte.fields.destination = destination;
 +	irte.fields.dm          = apic->irq_dest_mode;
 +	irte.fields.valid       = 1;
 +
 +	ret = modify_irte(devid, index, irte);
 +	if (ret)
 +		return ret;
 +
 +	/* Setup IOAPIC entry */
 +	memset(entry, 0, sizeof(*entry));
 +
 +	entry->vector        = index;
 +	entry->mask          = 0;
 +	entry->trigger       = attr->trigger;
 +	entry->polarity      = attr->polarity;
  
 -	return devid;
 +	/*
 +	 * Mask level triggered irqs.
 +	 */
 +	if (attr->trigger)
 +		entry->mask = 1;
 +
 +	return 0;
  }
  
 -static struct irq_domain *get_ir_irq_domain(struct irq_alloc_info *info)
 +static int set_affinity(struct irq_data *data, const struct cpumask *mask,
 +			bool force)
  {
 -	struct amd_iommu *iommu;
 -	int devid;
 +	struct irq_2_irte *irte_info;
 +	unsigned int dest, irq;
 +	struct irq_cfg *cfg;
 +	union irte irte;
 +	int err;
  
 -	if (!info)
 -		return NULL;
 +	if (!config_enabled(CONFIG_SMP))
 +		return -1;
  
 -	devid = get_devid(info);
 -	if (devid >= 0) {
 -		iommu = amd_iommu_rlookup_table[devid];
 -		if (iommu)
 -			return iommu->ir_domain;
 +	cfg       = data->chip_data;
 +	irq       = data->irq;
 +	irte_info = &cfg->irq_2_irte;
 +
 +	if (!cpumask_intersects(mask, cpu_online_mask))
 +		return -EINVAL;
 +
 +	if (get_irte(irte_info->devid, irte_info->index, &irte))
 +		return -EBUSY;
 +
 +	if (assign_irq_vector(irq, cfg, mask))
 +		return -EBUSY;
 +
 +	err = apic->cpu_mask_to_apicid_and(cfg->domain, mask, &dest);
 +	if (err) {
 +		if (assign_irq_vector(irq, cfg, data->affinity))
 +			pr_err("AMD-Vi: Failed to recover vector for irq %d\n", irq);
 +		return err;
  	}
  
 -	return NULL;
 +	irte.fields.vector      = cfg->vector;
 +	irte.fields.destination = dest;
 +
 +	modify_irte(irte_info->devid, irte_info->index, irte);
 +
 +	if (cfg->move_in_progress)
 +		send_cleanup_vector(cfg);
 +
 +	cpumask_copy(data->affinity, mask);
 +
 +	return 0;
  }
  
 -static struct irq_domain *get_irq_domain(struct irq_alloc_info *info)
 +static int free_irq(int irq)
  {
 -	struct amd_iommu *iommu;
 -	int devid;
 +	struct irq_2_irte *irte_info;
 +	struct irq_cfg *cfg;
  
 -	if (!info)
 -		return NULL;
 +	cfg = irq_get_chip_data(irq);
 +	if (!cfg)
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	irte_info = &cfg->irq_2_irte;
++=======
+ 	switch (info->type) {
+ 	case X86_IRQ_ALLOC_TYPE_MSI:
+ 	case X86_IRQ_ALLOC_TYPE_MSIX:
+ 		devid = get_device_id(&info->msi_dev->dev);
+ 		if (IS_ERR_VALUE(devid))
+ 			return NULL;
+ 
+ 		iommu = amd_iommu_rlookup_table[devid];
+ 		if (iommu)
+ 			return iommu->msi_domain;
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> 7aba6cb9ee9d (iommu/amd: Make call-sites of get_device_id aware of its return value)
  
 -	return NULL;
 -}
 +	free_irte(irte_info->devid, irte_info->index);
  
 -struct irq_remap_ops amd_iommu_irq_ops = {
 -	.prepare		= amd_iommu_prepare,
 -	.enable			= amd_iommu_enable,
 -	.disable		= amd_iommu_disable,
 -	.reenable		= amd_iommu_reenable,
 -	.enable_faulting	= amd_iommu_enable_faulting,
 -	.get_ir_irq_domain	= get_ir_irq_domain,
 -	.get_irq_domain		= get_irq_domain,
 -};
 +	return 0;
 +}
  
 -static void irq_remapping_prepare_irte(struct amd_ir_data *data,
 -				       struct irq_cfg *irq_cfg,
 -				       struct irq_alloc_info *info,
 -				       int devid, int index, int sub_handle)
 +static void compose_msi_msg(struct pci_dev *pdev,
 +			    unsigned int irq, unsigned int dest,
 +			    struct msi_msg *msg, u8 hpet_id)
  {
 -	struct irq_2_irte *irte_info = &data->irq_2_irte;
 -	struct msi_msg *msg = &data->msi_entry;
 -	union irte *irte = &data->irte_entry;
 -	struct IO_APIC_route_entry *entry;
 +	struct irq_2_irte *irte_info;
 +	struct irq_cfg *cfg;
 +	union irte irte;
  
 -	data->irq_2_irte.devid = devid;
 -	data->irq_2_irte.index = index + sub_handle;
 +	cfg = irq_get_chip_data(irq);
 +	if (!cfg)
 +		return;
  
 -	/* Setup IRTE for IOMMU */
 -	irte->val = 0;
 -	irte->fields.vector      = irq_cfg->vector;
 -	irte->fields.int_type    = apic->irq_delivery_mode;
 -	irte->fields.destination = irq_cfg->dest_apicid;
 -	irte->fields.dm          = apic->irq_dest_mode;
 -	irte->fields.valid       = 1;
 +	irte_info = &cfg->irq_2_irte;
  
 -	switch (info->type) {
 -	case X86_IRQ_ALLOC_TYPE_IOAPIC:
 -		/* Setup IOAPIC entry */
 -		entry = info->ioapic_entry;
 -		info->ioapic_entry = NULL;
 -		memset(entry, 0, sizeof(*entry));
 -		entry->vector        = index;
 -		entry->mask          = 0;
 -		entry->trigger       = info->ioapic_trigger;
 -		entry->polarity      = info->ioapic_polarity;
 -		/* Mask level triggered irqs. */
 -		if (info->ioapic_trigger)
 -			entry->mask = 1;
 -		break;
 +	irte.val		= 0;
 +	irte.fields.vector	= cfg->vector;
 +	irte.fields.int_type    = apic->irq_delivery_mode;
 +	irte.fields.destination	= dest;
 +	irte.fields.dm		= apic->irq_dest_mode;
 +	irte.fields.valid	= 1;
  
 -	case X86_IRQ_ALLOC_TYPE_HPET:
 -	case X86_IRQ_ALLOC_TYPE_MSI:
 -	case X86_IRQ_ALLOC_TYPE_MSIX:
 -		msg->address_hi = MSI_ADDR_BASE_HI;
 -		msg->address_lo = MSI_ADDR_BASE_LO;
 -		msg->data = irte_info->index;
 -		break;
 +	modify_irte(irte_info->devid, irte_info->index, irte);
  
 -	default:
 -		BUG_ON(1);
 -		break;
 -	}
 +	msg->address_hi = MSI_ADDR_BASE_HI;
 +	msg->address_lo = MSI_ADDR_BASE_LO;
 +	msg->data       = irte_info->index;
  }
  
 -static int irq_remapping_alloc(struct irq_domain *domain, unsigned int virq,
 -			       unsigned int nr_irqs, void *arg)
 +static int msi_alloc_irq(struct pci_dev *pdev, int irq, int nvec)
  {
 -	struct irq_alloc_info *info = arg;
 -	struct irq_data *irq_data;
 -	struct amd_ir_data *data;
  	struct irq_cfg *cfg;
 -	int i, ret, devid;
 -	int index = -1;
 +	int index;
 +	u16 devid;
  
 -	if (!info)
 -		return -EINVAL;
 -	if (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_MSI &&
 -	    info->type != X86_IRQ_ALLOC_TYPE_MSIX)
 +	if (!pdev)
  		return -EINVAL;
  
 -	/*
 -	 * With IRQ remapping enabled, don't need contiguous CPU vectors
 -	 * to support multiple MSI interrupts.
 -	 */
 -	if (info->type == X86_IRQ_ALLOC_TYPE_MSI)
 -		info->flags &= ~X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
 -
 -	devid = get_devid(info);
 -	if (devid < 0)
 +	cfg = irq_get_chip_data(irq);
 +	if (!cfg)
  		return -EINVAL;
  
 -	ret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);
 -	if (ret < 0)
 -		return ret;
 +	devid = get_device_id(&pdev->dev);
 +	index = alloc_irq_index(cfg, devid, nvec);
  
 -	if (info->type == X86_IRQ_ALLOC_TYPE_IOAPIC) {
 -		if (get_irq_table(devid, true))
 -			index = info->ioapic_pin;
 -		else
 -			ret = -ENOMEM;
 -	} else {
 -		index = alloc_irq_index(devid, nr_irqs);
 -	}
 -	if (index < 0) {
 -		pr_warn("Failed to allocate IRTE\n");
 -		goto out_free_parent;
 -	}
 -
 -	for (i = 0; i < nr_irqs; i++) {
 -		irq_data = irq_domain_get_irq_data(domain, virq + i);
 -		cfg = irqd_cfg(irq_data);
 -		if (!irq_data || !cfg) {
 -			ret = -EINVAL;
 -			goto out_free_data;
 -		}
 -
 -		ret = -ENOMEM;
 -		data = kzalloc(sizeof(*data), GFP_KERNEL);
 -		if (!data)
 -			goto out_free_data;
 -
 -		irq_data->hwirq = (devid << 16) + i;
 -		irq_data->chip_data = data;
 -		irq_data->chip = &amd_ir_chip;
 -		irq_remapping_prepare_irte(data, cfg, info, devid, index, i);
 -		irq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);
 -	}
 -
 -	return 0;
 -
 -out_free_data:
 -	for (i--; i >= 0; i--) {
 -		irq_data = irq_domain_get_irq_data(domain, virq + i);
 -		if (irq_data)
 -			kfree(irq_data->chip_data);
 -	}
 -	for (i = 0; i < nr_irqs; i++)
 -		free_irte(devid, index + i);
 -out_free_parent:
 -	irq_domain_free_irqs_common(domain, virq, nr_irqs);
 -	return ret;
 +	return index < 0 ? MAX_IRQS_PER_TABLE : index;
  }
  
 -static void irq_remapping_free(struct irq_domain *domain, unsigned int virq,
 -			       unsigned int nr_irqs)
 +static int msi_setup_irq(struct pci_dev *pdev, unsigned int irq,
 +			 int index, int offset)
  {
  	struct irq_2_irte *irte_info;
 -	struct irq_data *irq_data;
 -	struct amd_ir_data *data;
 -	int i;
 -
 -	for (i = 0; i < nr_irqs; i++) {
 -		irq_data = irq_domain_get_irq_data(domain, virq  + i);
 -		if (irq_data && irq_data->chip_data) {
 -			data = irq_data->chip_data;
 -			irte_info = &data->irq_2_irte;
 -			free_irte(irte_info->devid, irte_info->index);
 -			kfree(data);
 -		}
 -	}
 -	irq_domain_free_irqs_common(domain, virq, nr_irqs);
 -}
 -
 -static void irq_remapping_activate(struct irq_domain *domain,
 -				   struct irq_data *irq_data)
 -{
 -	struct amd_ir_data *data = irq_data->chip_data;
 -	struct irq_2_irte *irte_info = &data->irq_2_irte;
 -
 -	modify_irte(irte_info->devid, irte_info->index, data->irte_entry);
 -}
 -
 -static void irq_remapping_deactivate(struct irq_domain *domain,
 -				     struct irq_data *irq_data)
 -{
 -	struct amd_ir_data *data = irq_data->chip_data;
 -	struct irq_2_irte *irte_info = &data->irq_2_irte;
 -	union irte entry;
 -
 -	entry.val = 0;
 -	modify_irte(irte_info->devid, irte_info->index, data->irte_entry);
 -}
 +	struct irq_cfg *cfg;
 +	u16 devid;
  
 -static struct irq_domain_ops amd_ir_domain_ops = {
 -	.alloc = irq_remapping_alloc,
 -	.free = irq_remapping_free,
 -	.activate = irq_remapping_activate,
 -	.deactivate = irq_remapping_deactivate,
 -};
 +	if (!pdev)
 +		return -EINVAL;
  
 -static int amd_ir_set_affinity(struct irq_data *data,
 -			       const struct cpumask *mask, bool force)
 -{
 -	struct amd_ir_data *ir_data = data->chip_data;
 -	struct irq_2_irte *irte_info = &ir_data->irq_2_irte;
 -	struct irq_cfg *cfg = irqd_cfg(data);
 -	struct irq_data *parent = data->parent_data;
 -	int ret;
 +	cfg = irq_get_chip_data(irq);
 +	if (!cfg)
 +		return -EINVAL;
  
 -	ret = parent->chip->irq_set_affinity(parent, mask, force);
 -	if (ret < 0 || ret == IRQ_SET_MASK_OK_DONE)
 -		return ret;
 +	if (index >= MAX_IRQS_PER_TABLE)
 +		return 0;
  
 -	/*
 -	 * Atomically updates the IRTE with the new destination, vector
 -	 * and flushes the interrupt entry cache.
 -	 */
 -	ir_data->irte_entry.fields.vector = cfg->vector;
 -	ir_data->irte_entry.fields.destination = cfg->dest_apicid;
 -	modify_irte(irte_info->devid, irte_info->index, ir_data->irte_entry);
 +	devid		= get_device_id(&pdev->dev);
 +	irte_info	= &cfg->irq_2_irte;
  
 -	/*
 -	 * After this point, all the interrupts will start arriving
 -	 * at the new destination. So, time to cleanup the previous
 -	 * vector allocation.
 -	 */
 -	send_cleanup_vector(cfg);
 +	cfg->remapped	      = 1;
 +	irte_info->devid      = devid;
 +	irte_info->index      = index + offset;
  
 -	return IRQ_SET_MASK_OK_DONE;
 +	return 0;
  }
  
 -static void ir_compose_msi_msg(struct irq_data *irq_data, struct msi_msg *msg)
 +static int alloc_hpet_msi(unsigned int irq, unsigned int id)
  {
 -	struct amd_ir_data *ir_data = irq_data->chip_data;
 +	struct irq_2_irte *irte_info;
 +	struct irq_cfg *cfg;
 +	int index, devid;
  
 -	*msg = ir_data->msi_entry;
 -}
 +	cfg = irq_get_chip_data(irq);
 +	if (!cfg)
 +		return -EINVAL;
  
 -static struct irq_chip amd_ir_chip = {
 -	.irq_ack = ir_ack_apic_edge,
 -	.irq_set_affinity = amd_ir_set_affinity,
 -	.irq_compose_msi_msg = ir_compose_msi_msg,
 -};
 +	irte_info = &cfg->irq_2_irte;
 +	devid     = get_hpet_devid(id);
 +	if (devid < 0)
 +		return devid;
  
 -int amd_iommu_create_irq_domain(struct amd_iommu *iommu)
 -{
 -	iommu->ir_domain = irq_domain_add_tree(NULL, &amd_ir_domain_ops, iommu);
 -	if (!iommu->ir_domain)
 -		return -ENOMEM;
 +	index = alloc_irq_index(cfg, devid, 1);
 +	if (index < 0)
 +		return index;
  
 -	iommu->ir_domain->parent = arch_get_ir_parent_domain();
 -	iommu->msi_domain = arch_create_msi_irq_domain(iommu->ir_domain);
 +	cfg->remapped	      = 1;
 +	irte_info->devid      = devid;
 +	irte_info->index      = index;
  
  	return 0;
  }
* Unmerged path drivers/iommu/amd_iommu.c
