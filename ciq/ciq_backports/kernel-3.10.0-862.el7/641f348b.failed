IB/hfi1: Allow MgmtAllowed on B2B setups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Sokolowski <jan.sokolowski@intel.com>
commit 641f348bbdf1dcd30870bef8b0bd663aaf24f2ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/641f348b.failed

HFI's are hard-wired to send Device Info frames with
MgmtAllowed bit set to 0. This means in B2B setups,
MgmtAllowed would never be allowed, which prevents
remote opa management tools from working properly.

Assume MgmtAllowed if a neighbor is also an HFI.

Fixes: 98b9ee2002a8 ("IB/hfi1: Cache neighbor secure data after link up")
	Reviewed-by: Sebastian Sanchez <sebastian.sanchez@intel.com>
	Reviewed-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Jan Sokolowski <jan.sokolowski@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 641f348bbdf1dcd30870bef8b0bd663aaf24f2ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/intr.c
diff --cc drivers/infiniband/hw/hfi1/intr.c
index 7f9af9c3d9e6,387305b768e9..000000000000
--- a/drivers/infiniband/hw/hfi1/intr.c
+++ b/drivers/infiniband/hw/hfi1/intr.c
@@@ -52,6 -53,42 +52,45 @@@
  #include "common.h"
  #include "sdma.h"
  
++<<<<<<< HEAD
++=======
+ #define LINK_UP_DELAY  500  /* in microseconds */
+ 
+ static void set_mgmt_allowed(struct hfi1_pportdata *ppd)
+ {
+ 	u32 frame;
+ 	struct hfi1_devdata *dd = ppd->dd;
+ 
+ 	if (ppd->neighbor_type == NEIGHBOR_TYPE_HFI) {
+ 		ppd->mgmt_allowed = 1;
+ 	} else {
+ 		read_8051_config(dd, REMOTE_LNI_INFO, GENERAL_CONFIG, &frame);
+ 		ppd->mgmt_allowed = (frame >> MGMT_ALLOWED_SHIFT)
+ 		& MGMT_ALLOWED_MASK;
+ 	}
+ }
+ 
+ /*
+  * Our neighbor has indicated that we are allowed to act as a fabric
+  * manager, so place the full management partition key in the second
+  * (0-based) pkey array position. Note that we should already have
+  * the limited management partition key in array element 1, and also
+  * that the port is not yet up when add_full_mgmt_pkey() is invoked.
+  */
+ static void add_full_mgmt_pkey(struct hfi1_pportdata *ppd)
+ {
+ 	struct hfi1_devdata *dd = ppd->dd;
+ 
+ 	/* Sanity check - ppd->pkeys[2] should be 0, or already initialized */
+ 	if (!((ppd->pkeys[2] == 0) || (ppd->pkeys[2] == FULL_MGMT_P_KEY)))
+ 		dd_dev_warn(dd, "%s pkey[2] already set to 0x%x, resetting it to 0x%x\n",
+ 			    __func__, ppd->pkeys[2], FULL_MGMT_P_KEY);
+ 	ppd->pkeys[2] = FULL_MGMT_P_KEY;
+ 	(void)hfi1_set_ib_cfg(ppd, HFI1_IB_CFG_PKEYS, 0);
+ 	hfi1_event_pkey_change(ppd->dd, ppd->port);
+ }
+ 
++>>>>>>> 641f348bbdf1 (IB/hfi1: Allow MgmtAllowed on B2B setups)
  /**
   * format_hwmsg - format a single hwerror message
   * @msg message buffer
@@@ -150,6 -194,18 +189,21 @@@ void handle_linkup_change(struct hfi1_d
  			    ppd->neighbor_guid, ppd->neighbor_type,
  			    ppd->neighbor_port_number);
  
++<<<<<<< HEAD
++=======
+ 		/* HW needs LINK_UP_DELAY to settle, give it that chance */
+ 		udelay(LINK_UP_DELAY);
+ 
+ 		/*
+ 		 * 'MgmtAllowed' information, which is exchanged during
+ 		 * LNI, is available at this point.
+ 		 */
+ 		set_mgmt_allowed(ppd);
+ 
+ 		if (ppd->mgmt_allowed)
+ 			add_full_mgmt_pkey(ppd);
+ 
++>>>>>>> 641f348bbdf1 (IB/hfi1: Allow MgmtAllowed on B2B setups)
  		/* physical link went up */
  		ppd->linkup = 1;
  		ppd->offline_disabled_reason =
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index 5021a888d4a0..273fcc1394cd 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -1036,7 +1036,6 @@ static void read_vc_local_link_width(struct hfi1_devdata *dd, u8 *misc_bits,
 				     u8 *flag_bits, u16 *link_widths);
 static void read_remote_device_id(struct hfi1_devdata *dd, u16 *device_id,
 				  u8 *device_rev);
-static void read_mgmt_allowed(struct hfi1_devdata *dd, u8 *mgmt_allowed);
 static void read_local_lni(struct hfi1_devdata *dd, u8 *enable_lane_rx);
 static int read_tx_settings(struct hfi1_devdata *dd, u8 *enable_lane_tx,
 			    u8 *tx_polarity_inversion,
@@ -7139,27 +7138,6 @@ static int lcb_to_port_ltp(int lcb_crc)
 	return port_ltp;
 }
 
-/*
- * Our neighbor has indicated that we are allowed to act as a fabric
- * manager, so place the full management partition key in the second
- * (0-based) pkey array position (see OPAv1, section 20.2.2.6.8). Note
- * that we should already have the limited management partition key in
- * array element 1, and also that the port is not yet up when
- * add_full_mgmt_pkey() is invoked.
- */
-static void add_full_mgmt_pkey(struct hfi1_pportdata *ppd)
-{
-	struct hfi1_devdata *dd = ppd->dd;
-
-	/* Sanity check - ppd->pkeys[2] should be 0, or already initialized */
-	if (!((ppd->pkeys[2] == 0) || (ppd->pkeys[2] == FULL_MGMT_P_KEY)))
-		dd_dev_warn(dd, "%s pkey[2] already set to 0x%x, resetting it to 0x%x\n",
-			    __func__, ppd->pkeys[2], FULL_MGMT_P_KEY);
-	ppd->pkeys[2] = FULL_MGMT_P_KEY;
-	(void)hfi1_set_ib_cfg(ppd, HFI1_IB_CFG_PKEYS, 0);
-	hfi1_event_pkey_change(ppd->dd, ppd->port);
-}
-
 static void clear_full_mgmt_pkey(struct hfi1_pportdata *ppd)
 {
 	if (ppd->pkeys[2] != 0) {
@@ -7356,11 +7334,7 @@ void handle_verify_cap(struct work_struct *work)
 			      &partner_supported_crc);
 	read_vc_remote_link_width(dd, &remote_tx_rate, &link_widths);
 	read_remote_device_id(dd, &device_id, &device_rev);
-	/*
-	 * And the 'MgmtAllowed' information, which is exchanged during
-	 * LNI, is also be available at this point.
-	 */
-	read_mgmt_allowed(dd, &ppd->mgmt_allowed);
+
 	/* print the active widths */
 	get_link_widths(dd, &active_tx, &active_rx);
 	dd_dev_info(dd,
@@ -7488,9 +7462,6 @@ void handle_verify_cap(struct work_struct *work)
 	write_csr(dd, DC_LCB_ERR_EN, 0); /* mask LCB errors */
 	set_8051_lcb_access(dd);
 
-	if (ppd->mgmt_allowed)
-		add_full_mgmt_pkey(ppd);
-
 	/* tell the 8051 to go to LinkUp */
 	set_link_state(ppd, HLS_GOING_UP);
 }
@@ -8854,14 +8825,6 @@ static void read_local_lni(struct hfi1_devdata *dd, u8 *enable_lane_rx)
 	*enable_lane_rx = (frame >> ENABLE_LANE_RX_SHIFT) & ENABLE_LANE_RX_MASK;
 }
 
-static void read_mgmt_allowed(struct hfi1_devdata *dd, u8 *mgmt_allowed)
-{
-	u32 frame;
-
-	read_8051_config(dd, REMOTE_LNI_INFO, GENERAL_CONFIG, &frame);
-	*mgmt_allowed = (frame >> MGMT_ALLOWED_SHIFT) & MGMT_ALLOWED_MASK;
-}
-
 static void read_last_local_state(struct hfi1_devdata *dd, u32 *lls)
 {
 	read_8051_config(dd, LAST_LOCAL_STATE_COMPLETE, GENERAL_CONFIG, lls);
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index fc983f61b376..118db4f89d3e 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -93,6 +93,9 @@
 #define DROP_PACKET_OFF		0
 #define DROP_PACKET_ON		1
 
+#define NEIGHBOR_TYPE_HFI		0
+#define NEIGHBOR_TYPE_SWITCH	1
+
 extern unsigned long hfi1_cap_mask;
 #define HFI1_CAP_KGET_MASK(mask, cap) ((mask) & HFI1_CAP_##cap)
 #define HFI1_CAP_UGET_MASK(mask, cap) \
* Unmerged path drivers/infiniband/hw/hfi1/intr.c
