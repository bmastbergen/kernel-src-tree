iomap: expose iomap_apply outside iomap.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit befb503ca6e648cc5ed3e3a472d5b5887a60e0f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/befb503c.failed

This allows the DAX code to use it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit befb503ca6e648cc5ed3e3a472d5b5887a60e0f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/internal.h
diff --cc fs/internal.h
index c58979ac0a78,859178692ce4..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -155,3 -153,25 +156,28 @@@ extern const struct file_operations pip
   */
  extern void group_pin_kill(struct hlist_head *p);
  extern void mnt_pin_kill(struct mount *m);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * fs/nsfs.c
+  */
+ extern struct dentry_operations ns_dentry_operations;
+ 
+ /*
+  * fs/ioctl.c
+  */
+ extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
+ 		    unsigned long arg);
+ extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ 
+ /*
+  * iomap support:
+  */
+ typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
+ 		void *data, struct iomap *iomap);
+ 
+ loff_t iomap_apply(struct inode *inode, loff_t pos, loff_t length,
+ 		unsigned flags, struct iomap_ops *ops, void *data,
+ 		iomap_actor_t actor);
++>>>>>>> befb503ca6e6 (iomap: expose iomap_apply outside iomap.c)
* Unmerged path fs/internal.h
diff --git a/fs/iomap.c b/fs/iomap.c
index 3be51de876d2..9f358fa1e749 100644
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@ -27,9 +27,6 @@
 #include <linux/dax.h>
 #include "internal.h"
 
-typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
-		void *data, struct iomap *iomap);
-
 /*
  * Execute a iomap write on a segment of the mapping that spans a
  * contiguous range of pages that have identical block mapping state.
@@ -41,7 +38,7 @@ typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
  * resources they require in the iomap_begin call, and release them in the
  * iomap_end call.
  */
-static loff_t
+loff_t
 iomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,
 		struct iomap_ops *ops, void *data, iomap_actor_t actor)
 {
