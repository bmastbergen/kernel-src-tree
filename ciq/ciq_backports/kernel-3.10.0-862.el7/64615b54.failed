i40e: add private flag to control source pruning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mitch Williams <mitch.a.williams@intel.com>
commit 64615b5418bac1d3b3a50a83fb2e42091fe299fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/64615b54.failed

By default, our devices do source pruning, that is, they drop receive
packets that have the source MAC matching one of the receive filters.
Unfortunately, this breaks ARP monitoring in channel bonding, as the
bonding driver expects devices to receive ARPs containing their own
source address.

Add an ethtool private flag to control this feature.

Also, remove the netif_running() check when we process our private
flags. It's OK to reset when the device is closed and in most cases we
need the reset the apply these changes.

	Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 64615b5418bac1d3b3a50a83fb2e42091fe299fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 5c730ad07ab8,c78448daa7a1..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -443,19 -451,9 +443,24 @@@ struct i40e_pf 
  #define I40E_FLAG_CLIENT_RESET			BIT_ULL(54)
  #define I40E_FLAG_TEMP_LINK_POLLING		BIT_ULL(55)
  #define I40E_FLAG_CLIENT_L2_CHANGE		BIT_ULL(56)
++<<<<<<< HEAD
 +#define I40E_FLAG_WOL_MC_MAGIC_PKT_WAKE		BIT_ULL(57)
++=======
+ #define I40E_FLAG_LEGACY_RX			BIT_ULL(58)
+ #define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT_ULL(59)
++>>>>>>> 64615b5418ba (i40e: add private flag to control source pruning)
 +
 +	/* Tracks features that are disabled due to hw limitations.
 +	 * If a bit is set here, it means that the corresponding
 +	 * bit in the 'flags' field is cleared i.e that feature
 +	 * is disabled
 +	 */
 +	u64 hw_disabled_flags;
 +
 +#ifdef I40E_FCOE
 +	struct i40e_fcoe fcoe;
  
 +#endif /* I40E_FCOE */
  	struct i40e_client_instance *cinst;
  	bool stat_offsets_loaded;
  	struct i40e_hw_port_stats stats;
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 4199c3555275,6203d362438c..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -246,7 -225,10 +246,14 @@@ static const struct i40e_priv_flags i40
  	I40E_PRIV_FLAG("LinkPolling", I40E_FLAG_LINK_POLLING_ENABLED, 0),
  	I40E_PRIV_FLAG("flow-director-atr", I40E_FLAG_FD_ATR_ENABLED, 0),
  	I40E_PRIV_FLAG("veb-stats", I40E_FLAG_VEB_STATS_ENABLED, 0),
++<<<<<<< HEAD
 +	I40E_PRIV_FLAG("hw-atr-eviction", I40E_FLAG_HW_ATR_EVICT_CAPABLE, 0),
++=======
+ 	I40E_PRIV_FLAG("hw-atr-eviction", I40E_FLAG_HW_ATR_EVICT_ENABLED, 0),
+ 	I40E_PRIV_FLAG("legacy-rx", I40E_FLAG_LEGACY_RX, 0),
+ 	I40E_PRIV_FLAG("disable-source-pruning",
+ 		       I40E_FLAG_SOURCE_PRUNING_DISABLED, 0),
++>>>>>>> 64615b5418ba (i40e: add private flag to control source pruning)
  };
  
  #define I40E_PRIV_FLAGS_STR_LEN ARRAY_SIZE(i40e_gstrings_priv_flags)
@@@ -4177,8 -4191,10 +4184,15 @@@ flags_complete
  	/* Issue reset to cause things to take effect, as additional bits
  	 * are added we will need to create a mask of bits requiring reset
  	 */
++<<<<<<< HEAD
 +	if (changed_flags & I40E_FLAG_VEB_STATS_ENABLED)
 +		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED));
++=======
+ 	if (changed_flags & (I40E_FLAG_VEB_STATS_ENABLED |
+ 			     I40E_FLAG_LEGACY_RX |
+ 			     I40E_FLAG_SOURCE_PRUNING_DISABLED))
+ 		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED), true);
++>>>>>>> 64615b5418ba (i40e: add private flag to control source pruning)
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 0ae1cb9ef058..4f8e28448560 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -9705,6 +9705,31 @@ static int i40e_add_vsi(struct i40e_vsi *vsi)
 
 		enabled_tc = i40e_pf_get_tc_map(pf);
 
+		/* Source pruning is enabled by default, so the flag is
+		 * negative logic - if it's set, we need to fiddle with
+		 * the VSI to disable source pruning.
+		 */
+		if (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED) {
+			memset(&ctxt, 0, sizeof(ctxt));
+			ctxt.seid = pf->main_vsi_seid;
+			ctxt.pf_num = pf->hw.pf_id;
+			ctxt.vf_num = 0;
+			ctxt.info.valid_sections |=
+				     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);
+			ctxt.info.switch_id =
+				   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_LOCAL_LB);
+			ret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);
+			if (ret) {
+				dev_info(&pf->pdev->dev,
+					 "update vsi failed, err %s aq_err %s\n",
+					 i40e_stat_str(&pf->hw, ret),
+					 i40e_aq_str(&pf->hw,
+						     pf->hw.aq.asq_last_status));
+				ret = -ENOENT;
+				goto err;
+			}
+		}
+
 		/* MFP mode setup queue map and update VSI */
 		if ((pf->flags & I40E_FLAG_MFP_ENABLED) &&
 		    !(pf->hw.func_caps.iscsi)) { /* NIC type PF */
