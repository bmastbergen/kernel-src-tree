mm/swapfile.c: fix swap space leak in error path of swap_free_entries()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] swapfile.c: fix swap space leak in error path of swap_free_entries() (Jerome Marchand) [1400689]
Rebuild_FUZZ: 97.84%
commit-author Huang Ying <ying.huang@intel.com>
commit 0ccfece6ed507738c0e7e4414c3688b78d4e3756
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0ccfece6.failed

In swapcache_free_entries(), if swap_info_get_cont() returns NULL,
something wrong occurs for the swap entry.  But we should still continue
to free the following swap entries in the array instead of skip them to
avoid swap space leak.  This is just problem in error path, where system
may be in an inconsistent state, but it is still good to fix it.

Link: http://lkml.kernel.org/r/20170421124739.24534-1-ying.huang@intel.com
	Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
	Acked-by: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0ccfece6ed507738c0e7e4414c3688b78d4e3756)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/swapfile.c
diff --cc mm/swapfile.c
index 44c2eac6b890,b86b2aca3fb9..000000000000
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@@ -641,18 -1054,35 +641,43 @@@ void swap_free(swp_entry_t entry
  /*
   * Called after dropping swapcache to decrease refcnt to swap entries.
   */
 -void swapcache_free(swp_entry_t entry)
 +void swapcache_free(swp_entry_t entry, struct page *page)
  {
  	struct swap_info_struct *p;
 +	unsigned char count;
  
 -	p = _swap_info_get(entry);
 +	p = swap_info_get(entry);
  	if (p) {
++<<<<<<< HEAD
 +		count = swap_entry_free(p, entry, SWAP_HAS_CACHE);
 +		if (page)
 +			mem_cgroup_uncharge_swapcache(page, entry, count != 0);
++=======
+ 		if (!__swap_entry_free(p, entry, SWAP_HAS_CACHE))
+ 			free_swap_slot(entry);
+ 	}
+ }
+ 
+ void swapcache_free_entries(swp_entry_t *entries, int n)
+ {
+ 	struct swap_info_struct *p, *prev;
+ 	int i;
+ 
+ 	if (n <= 0)
+ 		return;
+ 
+ 	prev = NULL;
+ 	p = NULL;
+ 	for (i = 0; i < n; ++i) {
+ 		p = swap_info_get_cont(entries[i], prev);
+ 		if (p)
+ 			swap_entry_free(p, entries[i]);
+ 		prev = p;
+ 	}
+ 	if (p)
++>>>>>>> 0ccfece6ed50 (mm/swapfile.c: fix swap space leak in error path of swap_free_entries())
  		spin_unlock(&p->lock);
 +	}
  }
  
  /*
* Unmerged path mm/swapfile.c
