nfp: make sure debug accesses don't depend on netdevs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 042f4ba62ff5fbe1428639187578bae39f513e23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/042f4ba6.failed

We want to be able to inspect the state of descriptor rings of
the control vNIC, so it will use the same interface as data vNICs.

Make sure the code doesn't use netdevs to determine state
of the rings and names things appropriately.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 042f4ba62ff5fbe1428639187578bae39f513e23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
index fddf57c8c945,40217ece5fcb..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
@@@ -54,7 -54,7 +54,11 @@@ static int nfp_net_debugfs_rx_q_read(st
  		goto out;
  	nn = r_vec->nfp_net;
  	rx_ring = r_vec->rx_ring;
++<<<<<<< HEAD
 +	if (!netif_running(nn->netdev))
++=======
+ 	if (!nfp_net_running(nn))
++>>>>>>> 042f4ba62ff5 (nfp: make sure debug accesses don't depend on netdevs)
  		goto out;
  
  	rxd_cnt = rx_ring->cnt;
@@@ -126,11 -131,14 +130,15 @@@ static int nfp_net_debugfs_tx_q_read(st
  
  	rtnl_lock();
  
 -	if (debugfs_real_fops(file->file) == &nfp_tx_q_fops)
 -		tx_ring = r_vec->tx_ring;
 -	else
 -		tx_ring = r_vec->xdp_ring;
 -	if (!r_vec->nfp_net || !tx_ring)
 +	if (!r_vec->nfp_net || !r_vec->tx_ring)
  		goto out;
  	nn = r_vec->nfp_net;
++<<<<<<< HEAD
 +	tx_ring = r_vec->tx_ring;
 +	if (!netif_running(nn->netdev))
++=======
+ 	if (!nfp_net_running(nn))
++>>>>>>> 042f4ba62ff5 (nfp: make sure debug accesses don't depend on netdevs)
  		goto out;
  
  	txd_cnt = tx_ring->cnt;
@@@ -193,7 -209,10 +201,14 @@@ void nfp_net_debugfs_port_add(struct nf
  	if (IS_ERR_OR_NULL(nfp_dir))
  		return;
  
++<<<<<<< HEAD
 +	sprintf(name, "port%d", id);
++=======
+ 	if (nfp_net_is_data_vnic(nn))
+ 		sprintf(name, "vnic%d", id);
+ 	else
+ 		strcpy(name, "ctrl-vnic");
++>>>>>>> 042f4ba62ff5 (nfp: make sure debug accesses don't depend on netdevs)
  	nn->debugfs_dir = debugfs_create_dir(name, ddir);
  	if (IS_ERR_OR_NULL(nn->debugfs_dir))
  		return;
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net.h b/drivers/net/ethernet/netronome/nfp/nfp_net.h
index 600c79f39fe0..b1169b29b113 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@ -730,6 +730,17 @@ static inline u32 nfp_qcp_wr_ptr_read(u8 __iomem *q)
 	return _nfp_qcp_read(q, NFP_QCP_WRITE_PTR);
 }
 
+static inline bool nfp_net_is_data_vnic(struct nfp_net *nn)
+{
+	WARN_ON_ONCE(!nn->dp.netdev && nn->port);
+	return !!nn->dp.netdev;
+}
+
+static inline bool nfp_net_running(struct nfp_net *nn)
+{
+	return nn->dp.ctrl & NFP_NET_CFG_CTRL_ENABLE;
+}
+
 /* Globals */
 extern const char nfp_driver_version[];
 
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
