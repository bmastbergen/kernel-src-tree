IB/hfi1: Send MAD traps until repressed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit bf90aadd630c2c9f7f965ba1e90d41b5b46db7c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bf90aadd.failed

A trap should be sent to the FM until the FM sends a repress message.
This is in line with the IBTA 13.4.9.

Add the ability to resend traps until a repress message is received.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Michael N. Henry <michael.n.henry@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit bf90aadd630c2c9f7f965ba1e90d41b5b46db7c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/mad.c
diff --cc drivers/infiniband/hw/hfi1/mad.c
index d59426fb9866,0a3e2dfdf56e..000000000000
--- a/drivers/infiniband/hw/hfi1/mad.c
+++ b/drivers/infiniband/hw/hfi1/mad.c
@@@ -109,16 -243,20 +243,24 @@@ static void send_trap(struct hfi1_ibpor
  	u32 qpn = ppd_from_ibp(ibp)->sm_trap_qp;
  
  	agent = ibp->rvp.send_agent;
- 	if (!agent)
+ 	if (!agent) {
+ 		cleanup_traps(ibp, trap);
  		return;
+ 	}
  
  	/* o14-3.2.1 */
++<<<<<<< HEAD
 +	if (ppd_from_ibp(ibp)->lstate != IB_PORT_ACTIVE)
++=======
+ 	if (driver_lstate(ppd_from_ibp(ibp)) != IB_PORT_ACTIVE) {
+ 		cleanup_traps(ibp, trap);
++>>>>>>> bf90aadd630c (IB/hfi1: Send MAD traps until repressed)
  		return;
+ 	}
  
- 	/* o14-2 */
- 	if (ibp->rvp.trap_timeout && time_before(jiffies,
- 						 ibp->rvp.trap_timeout))
+ 	/* Add the trap to the list if necessary and see if we can send it */
+ 	trap = check_and_add_trap(ibp, trap);
+ 	if (!trap)
  		return;
  
  	pkey_idx = hfi1_lookup_pkey_idx(ibp, LIM_MGMT_P_KEY);
@@@ -180,37 -369,34 +373,56 @@@ static struct trap_node *create_trap_no
  }
  
  /*
 - * Send a bad P_Key trap (ch. 14.3.8).
 + * Send a bad [PQ]_Key trap (ch. 14.3.8).
   */
 -void hfi1_bad_pkey(struct hfi1_ibport *ibp, u32 key, u32 sl,
 -		   u32 qp1, u32 qp2, u16 lid1, u16 lid2)
 +void hfi1_bad_pqkey(struct hfi1_ibport *ibp, __be16 trap_num, u32 key, u32 sl,
 +		    u32 qp1, u32 qp2, u16 lid1, u16 lid2)
  {
- 	struct opa_mad_notice_attr data;
+ 	struct trap_node *trap;
  	u32 lid = ppd_from_ibp(ibp)->lid;
  	u32 _lid1 = lid1;
  	u32 _lid2 = lid2;
  
++<<<<<<< HEAD
 +	memset(&data, 0, sizeof(data));
 +
 +	if (trap_num == OPA_TRAP_BAD_P_KEY)
 +		ibp->rvp.pkey_violations++;
 +	else
 +		ibp->rvp.qkey_violations++;
++=======
++>>>>>>> bf90aadd630c (IB/hfi1: Send MAD traps until repressed)
  	ibp->rvp.n_pkt_drops++;
 -	ibp->rvp.pkey_violations++;
  
++<<<<<<< HEAD
 +	/* Send violation trap */
 +	data.generic_type = IB_NOTICE_TYPE_SECURITY;
 +	data.prod_type_lsb = IB_NOTICE_PROD_CA;
 +	data.trap_num = trap_num;
 +	data.issuer_lid = cpu_to_be32(lid);
 +	data.ntc_257_258.lid1 = cpu_to_be32(_lid1);
 +	data.ntc_257_258.lid2 = cpu_to_be32(_lid2);
 +	data.ntc_257_258.key = cpu_to_be32(key);
 +	data.ntc_257_258.sl = sl << 3;
 +	data.ntc_257_258.qp1 = cpu_to_be32(qp1);
 +	data.ntc_257_258.qp2 = cpu_to_be32(qp2);
++=======
+ 	trap = create_trap_node(IB_NOTICE_TYPE_SECURITY, OPA_TRAP_BAD_P_KEY,
+ 				lid);
+ 	if (!trap)
+ 		return;
++>>>>>>> bf90aadd630c (IB/hfi1: Send MAD traps until repressed)
  
- 	send_trap(ibp, &data, sizeof(data));
+ 	/* Send violation trap */
+ 	trap->data.ntc_257_258.lid1 = cpu_to_be32(_lid1);
+ 	trap->data.ntc_257_258.lid2 = cpu_to_be32(_lid2);
+ 	trap->data.ntc_257_258.key = cpu_to_be32(key);
+ 	trap->data.ntc_257_258.sl = sl << 3;
+ 	trap->data.ntc_257_258.qp1 = cpu_to_be32(qp1);
+ 	trap->data.ntc_257_258.qp2 = cpu_to_be32(qp2);
+ 
+ 	trap->len = sizeof(trap->data);
+ 	send_trap(ibp, trap);
  }
  
  /*
* Unmerged path drivers/infiniband/hw/hfi1/mad.c
diff --git a/drivers/infiniband/hw/hfi1/mad.h b/drivers/infiniband/hw/hfi1/mad.h
index a4e2506bd5ca..4c1245072093 100644
--- a/drivers/infiniband/hw/hfi1/mad.h
+++ b/drivers/infiniband/hw/hfi1/mad.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2015, 2016 Intel Corporation.
+ * Copyright(c) 2015 - 2017 Intel Corporation.
  *
  * This file is provided under a dual BSD/GPLv2 license.  When using or
  * redistributing this file, you may do so under either license.
@@ -428,5 +428,6 @@ struct sc2vlnt {
 		    COUNTER_MASK(1, 4))
 
 void hfi1_event_pkey_change(struct hfi1_devdata *dd, u8 port);
+void hfi1_handle_trap_timer(unsigned long data);
 
 #endif				/* _HFI1_MAD_H */
diff --git a/drivers/infiniband/hw/hfi1/verbs.c b/drivers/infiniband/hw/hfi1/verbs.c
index 06ac08cf82a6..f9b25c7538c0 100644
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@ -1541,6 +1541,11 @@ static void init_ibport(struct hfi1_pportdata *ppd)
 		ibp->sc_to_sl[i] = i;
 	}
 
+	for (i = 0; i < RVT_MAX_TRAP_LISTS ; i++)
+		INIT_LIST_HEAD(&ibp->rvp.trap_lists[i].list);
+	setup_timer(&ibp->rvp.trap_timer, hfi1_handle_trap_timer,
+		    (unsigned long)ibp);
+
 	spin_lock_init(&ibp->rvp.lock);
 	/* Set the prefix to the default value (see ch. 4.1.1) */
 	ibp->rvp.gid_prefix = IB_DEFAULT_GID_PREFIX;
diff --git a/include/rdma/rdma_vt.h b/include/rdma/rdma_vt.h
index 2b925099bac5..c96158c3b173 100644
--- a/include/rdma/rdma_vt.h
+++ b/include/rdma/rdma_vt.h
@@ -57,11 +57,21 @@
 #include <linux/list.h>
 #include <linux/hash.h>
 #include <rdma/ib_verbs.h>
+#include <rdma/ib_mad.h>
 #include <rdma/rdmavt_mr.h>
 #include <rdma/rdmavt_qp.h>
 
 #define RVT_MAX_PKEY_VALUES 16
 
+#define RVT_MAX_TRAP_LEN 100 /* Limit pending trap list */
+#define RVT_MAX_TRAP_LISTS ((IB_NOTICE_TYPE_INFO & 0x0F) + 1)
+#define RVT_TRAP_TIMEOUT 4096 /* 4.096 usec */
+
+struct trap_list {
+	u32 list_len;
+	struct list_head list;
+};
+
 struct rvt_ibport {
 	struct rvt_qp __rcu *qp[2];
 	struct ib_mad_agent *send_agent;	/* agent for SMI (traps) */
@@ -128,6 +138,13 @@ struct rvt_ibport {
 	u16 *pkey_table;
 
 	struct rvt_ah *sm_ah;
+
+	/*
+	 * Keep a list of traps that have not been repressed.  They will be
+	 * resent based on trap_timer.
+	 */
+	struct trap_list trap_lists[RVT_MAX_TRAP_LISTS];
+	struct timer_list trap_timer;
 };
 
 #define RVT_CQN_MAX 16 /* maximum length of cq name */
