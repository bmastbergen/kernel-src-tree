iommu/vt-d: Fix infinite loop in free_all_cpu_cached_iovas

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] vt-d: Fix infinite loop in free_all_cpu_cached_iovas (Jerry Snitselaar) [1499325]
Rebuild_FUZZ: 94.55%
commit-author Aaron Campbell <aaron@monkey.org>
commit 0caa7616a6aca449dd68b58cb29bd491d296c2d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0caa7616.failed

Per VT-d spec Section 10.4.2 ("Capability Register"), the maximum
number of possible domains is 64K; indeed this is the maximum value
that the cap_ndoms() macro will expand to.  Since the value 65536
will not fix in a u16, the 'did' variable must be promoted to an
int, otherwise the test for < 65536 will always be true and the
loop will never end.

The symptom, in my case, was a hung machine during suspend.

Fixes: 3bd4f9112f87 ("iommu/vt-d: Fix overflow of iommu->domains array")
	Signed-off-by: Aaron Campbell <aaron@monkey.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 0caa7616a6aca449dd68b58cb29bd491d296c2d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 5612d2bd2e03,323dac9900ba..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -4432,15 -4595,47 +4432,34 @@@ static struct notifier_block intel_iomm
  	.priority = 0
  };
  
 -static void free_all_cpu_cached_iovas(unsigned int cpu)
 +static void intel_disable_iommus(void)
  {
 -	int i;
 +	struct intel_iommu *iommu = NULL;
 +	struct dmar_drhd_unit *drhd;
  
++<<<<<<< HEAD
 +	for_each_iommu(iommu, drhd)
 +		iommu_disable_translation(iommu);
++=======
+ 	for (i = 0; i < g_num_of_iommus; i++) {
+ 		struct intel_iommu *iommu = g_iommus[i];
+ 		struct dmar_domain *domain;
+ 		int did;
+ 
+ 		if (!iommu)
+ 			continue;
+ 
+ 		for (did = 0; did < cap_ndoms(iommu->cap); did++) {
+ 			domain = get_iommu_domain(iommu, (u16)did);
+ 
+ 			if (!domain)
+ 				continue;
+ 			free_cpu_cached_iovas(cpu, &domain->iovad);
+ 		}
+ 	}
++>>>>>>> 0caa7616a6ac (iommu/vt-d: Fix infinite loop in free_all_cpu_cached_iovas)
  }
  
 -static int intel_iommu_cpu_notifier(struct notifier_block *nfb,
 -				    unsigned long action, void *v)
 -{
 -	unsigned int cpu = (unsigned long)v;
 -
 -	switch (action) {
 -	case CPU_DEAD:
 -	case CPU_DEAD_FROZEN:
 -		free_all_cpu_cached_iovas(cpu);
 -		flush_unmaps_timeout(cpu);
 -		break;
 -	}
 -	return NOTIFY_OK;
 -}
 -
 -static struct notifier_block intel_iommu_cpu_nb = {
 -	.notifier_call = intel_iommu_cpu_notifier,
 -};
 -
  static ssize_t intel_iommu_show_version(struct device *dev,
  					struct device_attribute *attr,
  					char *buf)
* Unmerged path drivers/iommu/intel-iommu.c
