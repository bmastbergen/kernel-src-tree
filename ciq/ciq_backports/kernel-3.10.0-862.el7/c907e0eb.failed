memremap: add MEMREMAP_WC flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Brian Starkey <brian.starkey@arm.com>
commit c907e0eb43a522de60fb651c011c553f87273222
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c907e0eb.failed

Add a flag to memremap() for writecombine mappings.  Mappings satisfied
by this flag will not be cached, however writes may be delayed or
combined into more efficient bursts.  This is most suitable for buffers
written sequentially by the CPU for use by other DMA devices.

	Signed-off-by: Brian Starkey <brian.starkey@arm.com>
	Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c907e0eb43a522de60fb651c011c553f87273222)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/memremap.c
diff --cc kernel/memremap.c
index 6504d174d101,a6d382312e6f..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -47,9 -45,11 +47,11 @@@ static void *try_ram_remap(resource_siz
   *
   * memremap() is "ioremap" for cases where it is known that the resource
   * being mapped does not have i/o side effects and the __iomem
-  * annotation is not applicable.
+  * annotation is not applicable. In the case of multiple flags, the different
+  * mapping types will be attempted in the order listed below until one of
+  * them succeeds.
   *
 - * MEMREMAP_WB - matches the default mapping for System RAM on
 + * MEMREMAP_WB - matches the default mapping for "System RAM" on
   * the architecture.  This is usually a read-allocate write-back cache.
   * Morever, if MEMREMAP_WB is specified and the requested remap region is RAM
   * memremap() will bypass establishing a new mapping and instead return
@@@ -58,7 -58,11 +60,15 @@@
   * MEMREMAP_WT - establish a mapping whereby writes either bypass the
   * cache or are written through to memory and never exist in a
   * cache-dirty state with respect to program visibility.  Attempts to
++<<<<<<< HEAD
 + * map "System RAM" with this mapping type will fail.
++=======
+  * map System RAM with this mapping type will fail.
+  *
+  * MEMREMAP_WC - establish a writecombine mapping, whereby writes may
+  * be coalesced together (e.g. in the CPU's write buffers), but is otherwise
+  * uncached. Attempts to map System RAM with this mapping type will fail.
++>>>>>>> c907e0eb43a5 (memremap: add MEMREMAP_WC flag)
   */
  void *memremap(resource_size_t offset, size_t size, unsigned long flags)
  {
@@@ -98,11 -105,12 +108,14 @@@
  		return NULL;
  	}
  
 -	if (!addr && (flags & MEMREMAP_WT))
 -		addr = ioremap_wt(offset, size);
 +	if (!addr && (flags & MEMREMAP_WT)) {
 +		flags &= ~MEMREMAP_WT;
 +		addr = ioremap_nocache(offset, size);
 +	}
  
+ 	if (!addr && (flags & MEMREMAP_WC))
+ 		addr = ioremap_wc(offset, size);
+ 
  	return addr;
  }
  EXPORT_SYMBOL(memremap);
diff --git a/include/linux/io.h b/include/linux/io.h
index 5b05b6bf2378..ba80a2333e97 100644
--- a/include/linux/io.h
+++ b/include/linux/io.h
@@ -122,6 +122,7 @@ enum {
 	/* See memremap() kernel-doc for usage description... */
 	MEMREMAP_WB = 1 << 0,
 	MEMREMAP_WT = 1 << 1,
+	MEMREMAP_WC = 1 << 2,
 };
 
 void *memremap(resource_size_t offset, size_t size, unsigned long flags);
* Unmerged path kernel/memremap.c
