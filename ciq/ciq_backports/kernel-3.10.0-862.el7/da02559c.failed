X.509: Support leap seconds

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author David Howells <dhowells@redhat.com>
commit da02559c9f864c8d62f524c1e0b64173711a16ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/da02559c.failed

The format of ASN.1 GeneralizedTime seems to be specified by ISO 8601
[X.680 46.3] and this apparently supports leap seconds (ie. the seconds
field is 60).  It's not entirely clear that ASN.1 expects it, but we can
relax the seconds check slightly for GeneralizedTime.

This results in us passing a time with sec as 60 to mktime64(), which
handles it as being a duplicate of the 0th second of the next minute.

We can't really do otherwise without giving the kernel much greater
knowledge of where all the leap seconds are.  Unfortunately, this would
require change the mapping of the kernel's current-time-in-seconds.

UTCTime, however, only supports a seconds value in the range 00-59, but for
the sake of simplicity allow this with UTCTime also.

Without this patch, certain X.509 certificates will be rejected,
potentially making a kernel unbootable.

	Reported-by: Rudolf Polzer <rpolzer@google.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Acked-by: Arnd Bergmann <arnd@arndb.de>
cc: David Woodhouse <David.Woodhouse@intel.com>
cc: John Stultz <john.stultz@linaro.org>
(cherry picked from commit da02559c9f864c8d62f524c1e0b64173711a16ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/x509_cert_parser.c
diff --cc crypto/asymmetric_keys/x509_cert_parser.c
index ac72348c186a,99ff5382b627..000000000000
--- a/crypto/asymmetric_keys/x509_cert_parser.c
+++ b/crypto/asymmetric_keys/x509_cert_parser.c
@@@ -533,6 -508,29 +533,32 @@@ static int x509_note_time(struct tm *tm
  	if (*p != 'Z')
  		goto unsupported_time;
  
++<<<<<<< HEAD
++=======
+ 	if (year < 1970 ||
+ 	    mon < 1 || mon > 12)
+ 		goto invalid_time;
+ 
+ 	mon_len = month_lengths[mon - 1];
+ 	if (mon == 2) {
+ 		if (year % 4 == 0) {
+ 			mon_len = 29;
+ 			if (year % 100 == 0) {
+ 				mon_len = 28;
+ 				if (year % 400 == 0)
+ 					mon_len = 29;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (day < 1 || day > mon_len ||
+ 	    hour > 23 ||
+ 	    min > 59 ||
+ 	    sec > 60) /* ISO 8601 permits leap seconds [X.680 46.3] */
+ 		goto invalid_time;
+ 
+ 	*_t = mktime64(year, mon, day, hour, min, sec);
++>>>>>>> da02559c9f86 (X.509: Support leap seconds)
  	return 0;
  
  unsupported_time:
* Unmerged path crypto/asymmetric_keys/x509_cert_parser.c
