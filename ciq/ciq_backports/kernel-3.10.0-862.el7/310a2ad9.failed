virtchnl: rename i40e to generic virtchnl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 310a2ad92e3fd9139e3641464f1de113fa89825b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/310a2ad9.failed

This morphs all the i40e and i40evf references to/in virtchnl.h
to be generic, using only automated methods. Updates all the
callers to use the new names.  A followup patch provides separate
clean ups for messy line conversions from these "automatic"
changes, to make them more reviewable.

Was executed with the following sed script:
sed -i -f transform_script drivers/net/ethernet/intel/i40e/i40e_client.c
sed -i -f transform_script drivers/net/ethernet/intel/i40e/i40e_prototype.h
sed -i -f transform_script drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
sed -i -f transform_script drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
sed -i -f transform_script drivers/net/ethernet/intel/i40evf/i40e_common.c
sed -i -f transform_script drivers/net/ethernet/intel/i40evf/i40e_prototype.h
sed -i -f transform_script drivers/net/ethernet/intel/i40evf/i40evf.h
sed -i -f transform_script drivers/net/ethernet/intel/i40evf/i40evf_client.c
sed -i -f transform_script drivers/net/ethernet/intel/i40evf/i40evf_main.c
sed -i -f transform_script drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
sed -i -f transform_script include/linux/avf/virtchnl.h

transform_script:
----8<----
s/I40E_VIRTCHNL_SUPPORTED_QTYPES/SAVE_ME_SUPPORTED_QTYPES/g
s/I40E_VIRTCHNL_VF_CAP/SAVE_ME_VF_CAP/g

s/I40E_VIRTCHNL_/VIRTCHNL_/g
s/i40e_virtchnl_/virtchnl_/g
s/i40e_vfr_/virtchnl_vfr_/g
s/I40E_VFR_/VIRTCHNL_VFR_/g

s/VIRTCHNL_OP_ADD_ETHER_ADDRESS/VIRTCHNL_OP_ADD_ETH_ADDR/g
s/VIRTCHNL_OP_DEL_ETHER_ADDRESS/VIRTCHNL_OP_DEL_ETH_ADDR/g
s/VIRTCHNL_OP_FCOE/VIRTCHNL_OP_RSVD/g

s/SAVE_ME_SUPPORTED_QTYPES/I40E_VIRTCHNL_SUPPORTED_QTYPES/g
s/SAVE_ME_VF_CAP/I40E_VIRTCHNL_VF_CAP/g
----8<----

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 310a2ad92e3fd9139e3641464f1de113fa89825b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
#	drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index f469a3d68beb,9f361e810990..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -415,13 -418,10 +415,13 @@@ static int i40e_config_iwarp_qvlist(str
  	u32 next_q_idx, next_q_type;
  	u32 msix_vf, size;
  
- 	size = sizeof(struct i40e_virtchnl_iwarp_qvlist_info) +
- 	       (sizeof(struct i40e_virtchnl_iwarp_qv_info) *
+ 	size = sizeof(struct virtchnl_iwarp_qvlist_info) +
+ 	       (sizeof(struct virtchnl_iwarp_qv_info) *
  						(qvlist_info->num_vectors - 1));
  	vf->qvlist_info = kzalloc(size, GFP_KERNEL);
 +	if (!vf->qvlist_info)
 +		return -ENOMEM;
 +
  	vf->qvlist_info->num_vectors = qvlist_info->num_vectors;
  
  	msix_vf = pf->hw.func_caps.num_msix_vectors_vf;
@@@ -1425,50 -1524,55 +1425,61 @@@ static int i40e_vc_get_vf_resources_msg
  	if (VF_IS_V11(vf))
  		vf->driver_caps = *(u32 *)msg;
  	else
- 		vf->driver_caps = I40E_VIRTCHNL_VF_OFFLOAD_L2 |
- 				  I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG |
- 				  I40E_VIRTCHNL_VF_OFFLOAD_VLAN;
+ 		vf->driver_caps = VIRTCHNL_VF_OFFLOAD_L2 |
+ 				  VIRTCHNL_VF_OFFLOAD_RSS_REG |
+ 				  VIRTCHNL_VF_OFFLOAD_VLAN;
  
- 	vfres->vf_offload_flags = I40E_VIRTCHNL_VF_OFFLOAD_L2;
+ 	vfres->vf_offload_flags = VIRTCHNL_VF_OFFLOAD_L2;
  	vsi = pf->vsi[vf->lan_vsi_idx];
  	if (!vsi->info.pvid)
- 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_VLAN;
+ 		vfres->vf_offload_flags |= VIRTCHNL_VF_OFFLOAD_VLAN;
  
  	if (i40e_vf_client_capable(pf, vf->vf_id) &&
- 	    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_IWARP)) {
- 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_IWARP;
+ 	    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_IWARP)) {
+ 		vfres->vf_offload_flags |= VIRTCHNL_VF_OFFLOAD_IWARP;
  		set_bit(I40E_VF_STATE_IWARPENA, &vf->vf_states);
 +	} else {
 +		clear_bit(I40E_VF_STATE_IWARPENA, &vf->vf_states);
  	}
  
- 	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF) {
- 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF;
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PF) {
+ 		vfres->vf_offload_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PF;
  	} else {
  		if ((pf->flags & I40E_FLAG_RSS_AQ_CAPABLE) &&
- 		    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ))
+ 		    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_AQ))
  			vfres->vf_offload_flags |=
- 					I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ;
+ 					VIRTCHNL_VF_OFFLOAD_RSS_AQ;
  		else
  			vfres->vf_offload_flags |=
- 					I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG;
+ 					VIRTCHNL_VF_OFFLOAD_RSS_REG;
  	}
  
  	if (pf->flags & I40E_FLAG_MULTIPLE_TCP_UDP_RSS_PCTYPE) {
- 		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
+ 		if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
  			vfres->vf_offload_flags |=
- 				I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
+ 				VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
  	}
  
++<<<<<<< HEAD
 +	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING) {
++=======
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP)
+ 		vfres->vf_offload_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP;
+ 
+ 	if ((pf->flags & I40E_FLAG_OUTER_UDP_CSUM_CAPABLE) &&
+ 	    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
+ 		vfres->vf_offload_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;
+ 
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_POLLING) {
++>>>>>>> 310a2ad92e3f (virtchnl: rename i40e to generic virtchnl)
  		if (pf->flags & I40E_FLAG_MFP_ENABLED) {
  			dev_err(&pf->pdev->dev,
  				"VF %d requested polling mode: this feature is supported only when the device is running in single function per port (SFP) mode\n",
  				 vf->vf_id);
 -			ret = I40E_ERR_PARAM;
 +			aq_ret = I40E_ERR_PARAM;
  			goto err;
  		}
- 		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING;
+ 		vfres->vf_offload_flags |= VIRTCHNL_VF_OFFLOAD_RX_POLLING;
  	}
  
  	if (pf->flags & I40E_FLAG_WB_ON_ITR_CAPABLE) {
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
index b2807c7c498e,b57ffffce141..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
@@@ -86,8 -87,7 +86,12 @@@ struct i40e_vf 
  	/* VF Port Extender (PE) stag if used */
  	u16 stag;
  
++<<<<<<< HEAD
 +	struct i40e_virtchnl_ether_addr default_lan_addr;
 +	struct i40e_virtchnl_ether_addr default_fcoe_addr;
++=======
+ 	struct virtchnl_ether_addr default_lan_addr;
++>>>>>>> 310a2ad92e3f (virtchnl: rename i40e to generic virtchnl)
  	u16 port_vlan_id;
  	bool pf_set_mac;	/* The VMM admin set the VF MAC address */
  	bool trusted;
diff --cc drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
index 5770352322ef,a8b616121960..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
@@@ -151,22 -151,24 +151,37 @@@ struct virtchnl_vsi_resource 
  	u8 default_mac_addr[ETH_ALEN];
  };
  /* VF offload flags */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +#define I40E_VIRTCHNL_VF_OFFLOAD_L2		0x00000001
 +#define I40E_VIRTCHNL_VF_OFFLOAD_IWARP		0x00000002
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ		0x00000008
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG	0x00000010
 +#define I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR	0x00000020
 +#define I40E_VIRTCHNL_VF_OFFLOAD_VLAN		0x00010000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING	0x00020000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2	0x00040000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF		0X00080000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00100000
- 
- #define I40E_VF_BASE_MODE_OFFLOADS (I40E_VIRTCHNL_VF_OFFLOAD_L2 | \
- 				    I40E_VIRTCHNL_VF_OFFLOAD_VLAN | \
- 				    I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF)
- 
- struct i40e_virtchnl_vf_resource {
++=======
+ #define VIRTCHNL_VF_OFFLOAD_L2		0x00000001
+ #define VIRTCHNL_VF_OFFLOAD_IWARP		0x00000002
+ #define VIRTCHNL_VF_OFFLOAD_FCOE		0x00000004
+ #define VIRTCHNL_VF_OFFLOAD_RSS_AQ		0x00000008
+ #define VIRTCHNL_VF_OFFLOAD_RSS_REG	0x00000010
+ #define VIRTCHNL_VF_OFFLOAD_WB_ON_ITR	0x00000020
+ #define VIRTCHNL_VF_OFFLOAD_VLAN		0x00010000
+ #define VIRTCHNL_VF_OFFLOAD_RX_POLLING	0x00020000
+ #define VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2	0x00040000
+ #define VIRTCHNL_VF_OFFLOAD_RSS_PF		0X00080000
+ #define VIRTCHNL_VF_OFFLOAD_ENCAP		0X00100000
+ #define VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00200000
++>>>>>>> 310a2ad92e3f (virtchnl: rename i40e to generic virtchnl):include/linux/avf/virtchnl.h
+ 
+ #define I40E_VF_BASE_MODE_OFFLOADS (VIRTCHNL_VF_OFFLOAD_L2 | \
+ 				    VIRTCHNL_VF_OFFLOAD_VLAN | \
+ 				    VIRTCHNL_VF_OFFLOAD_RSS_PF)
+ 
+ struct virtchnl_vf_resource {
  	u16 num_vsis;
  	u16 num_queue_pairs;
  	u16 max_vectors;
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 92233e4beca5,5d7b613e0d62..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -2393,46 -2418,52 +2393,74 @@@ int i40evf_process_config(struct i40evf
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	netdev->hw_enc_features |= NETIF_F_SG			|
 +				   NETIF_F_IP_CSUM		|
 +				   NETIF_F_IPV6_CSUM		|
 +				   NETIF_F_HIGHDMA		|
 +				   NETIF_F_SOFT_FEATURES	|
 +				   NETIF_F_TSO			|
 +				   NETIF_F_TSO_ECN		|
 +				   NETIF_F_TSO6			|
++=======
+ 	hw_enc_features = NETIF_F_SG			|
+ 			  NETIF_F_IP_CSUM		|
+ 			  NETIF_F_IPV6_CSUM		|
+ 			  NETIF_F_HIGHDMA		|
+ 			  NETIF_F_SOFT_FEATURES	|
+ 			  NETIF_F_TSO			|
+ 			  NETIF_F_TSO_ECN		|
+ 			  NETIF_F_TSO6			|
+ 			  NETIF_F_SCTP_CRC		|
+ 			  NETIF_F_RXHASH		|
+ 			  NETIF_F_RXCSUM		|
+ 			  0;
+ 
+ 	/* advertise to stack only if offloads for encapsulated packets is
+ 	 * supported
+ 	 */
+ 	if (vfres->vf_offload_flags & VIRTCHNL_VF_OFFLOAD_ENCAP) {
+ 		hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL	|
++>>>>>>> 310a2ad92e3f (virtchnl: rename i40e to generic virtchnl)
  				   NETIF_F_GSO_GRE		|
  				   NETIF_F_GSO_GRE_CSUM		|
 -				   NETIF_F_GSO_IPXIP4		|
 -				   NETIF_F_GSO_IPXIP6		|
 +				   NETIF_F_GSO_IPIP		|
 +				   NETIF_F_GSO_SIT		|
 +				   NETIF_F_GSO_UDP_TUNNEL	|
  				   NETIF_F_GSO_UDP_TUNNEL_CSUM	|
  				   NETIF_F_GSO_PARTIAL		|
 +				   NETIF_F_SCTP_CRC		|
 +				   NETIF_F_RXHASH		|
 +				   NETIF_F_RXCSUM		|
  				   0;
  
++<<<<<<< HEAD
 +	if (!(adapter->flags & I40EVF_FLAG_OUTER_UDP_CSUM_CAPABLE))
 +		netdev->gso_partial_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;
 +
 +	netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
++=======
+ 		if (!(vfres->vf_offload_flags &
+ 		      VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
+ 			netdev->gso_partial_features |=
+ 				NETIF_F_GSO_UDP_TUNNEL_CSUM;
++>>>>>>> 310a2ad92e3f (virtchnl: rename i40e to generic virtchnl)
  
 -		netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
 -		netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
 -		netdev->hw_enc_features |= hw_enc_features;
 -	}
  	/* record features VLANs can make use of */
 -	netdev->vlan_features |= hw_enc_features | NETIF_F_TSO_MANGLEID;
 +	netdev->vlan_features |= netdev->hw_enc_features |
 +				 NETIF_F_TSO_MANGLEID;
  
  	/* Write features and hw_features separately to avoid polluting
 -	 * with, or dropping, features that are set when we registered.
 +	 * with, or dropping, features that are set when we registgered.
  	 */
 -	hw_features = hw_enc_features;
 +	netdev->hw_features |= netdev->hw_enc_features;
  
 -	netdev->hw_features |= hw_features;
 +	netdev->features |= netdev->hw_enc_features | I40EVF_VLAN_FEATURES;
 +	netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
  
 -	netdev->features |= hw_features | I40EVF_VLAN_FEATURES;
 +	/* disable VLAN features if not supported */
 +	if (!(vfres->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_VLAN))
 +		netdev->features ^= I40EVF_VLAN_FEATURES;
  
  	adapter->vsi.id = adapter->vsi_res->vsi_id;
  
@@@ -2573,12 -2604,9 +2601,12 @@@ static void i40evf_init_task(struct wor
  		goto err_alloc;
  	}
  
 +	if (hw->mac.type == I40E_MAC_X722_VF)
 +		adapter->flags |= I40EVF_FLAG_OUTER_UDP_CSUM_CAPABLE;
 +
  	if (i40evf_process_config(adapter))
  		goto err_alloc;
- 	adapter->current_op = I40E_VIRTCHNL_OP_UNKNOWN;
+ 	adapter->current_op = VIRTCHNL_OP_UNKNOWN;
  
  	adapter->flags |= I40EVF_FLAG_RX_CSUM_ENABLED;
  
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index aec9d82a87bd,90a17b0347b9..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@@ -152,15 -152,17 +152,27 @@@ int i40evf_send_vf_config_msg(struct i4
  {
  	u32 caps;
  
++<<<<<<< HEAD
 +	caps = I40E_VIRTCHNL_VF_OFFLOAD_L2 |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_VLAN |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR |
 +	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
- 
- 	adapter->current_op = I40E_VIRTCHNL_OP_GET_VF_RESOURCES;
++=======
+ 	caps = VIRTCHNL_VF_OFFLOAD_L2 |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_PF |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_AQ |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_REG |
+ 	       VIRTCHNL_VF_OFFLOAD_VLAN |
+ 	       VIRTCHNL_VF_OFFLOAD_WB_ON_ITR |
+ 	       VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2 |
+ 	       VIRTCHNL_VF_OFFLOAD_ENCAP |
+ 	       VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;
++>>>>>>> 310a2ad92e3f (virtchnl: rename i40e to generic virtchnl)
+ 
+ 	adapter->current_op = VIRTCHNL_OP_GET_VF_RESOURCES;
  	adapter->aq_required &= ~I40EVF_FLAG_AQ_GET_CONFIG;
  	if (PF_IS_V11(adapter))
  		return i40evf_send_pf_msg(adapter,
@@@ -230,12 -232,12 +242,12 @@@ out
   **/
  void i40evf_configure_queues(struct i40evf_adapter *adapter)
  {
- 	struct i40e_virtchnl_vsi_queue_config_info *vqci;
- 	struct i40e_virtchnl_queue_pair_info *vqpi;
+ 	struct virtchnl_vsi_queue_config_info *vqci;
+ 	struct virtchnl_queue_pair_info *vqpi;
  	int pairs = adapter->num_active_queues;
 -	int i, len, max_frame = I40E_MAX_RXBUFFER;
 +	int i, len;
  
- 	if (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {
+ 	if (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {
  		/* bail because we already have a command pending */
  		dev_err(&adapter->pdev->dev, "Cannot configure queues, command %d pending\n",
  			adapter->current_op);
diff --git a/drivers/net/ethernet/intel/i40e/i40e_client.c b/drivers/net/ethernet/intel/i40e/i40e_client.c
index 5115ed5f2149..a4e72b0a0193 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_client.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_client.c
@@ -565,7 +565,7 @@ static int i40e_client_virtchnl_send(struct i40e_info *ldev,
 	struct i40e_hw *hw = &pf->hw;
 	i40e_status err;
 
-	err = i40e_aq_send_msg_to_vf(hw, vf_id, I40E_VIRTCHNL_OP_IWARP,
+	err = i40e_aq_send_msg_to_vf(hw, vf_id, VIRTCHNL_OP_IWARP,
 				     0, msg, len, NULL);
 	if (err)
 		dev_err(&pf->pdev->dev, "Unable to send iWarp message to VF, error %d, aq status %d\n",
diff --git a/drivers/net/ethernet/intel/i40e/i40e_prototype.h b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
index 76c14d36f162..b7373d640ad4 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
@@ -334,10 +334,10 @@ static inline struct i40e_rx_ptype_decoded decode_rx_desc_ptype(u8 ptype)
 
 /* i40e_common for VF drivers*/
 void i40e_vf_parse_hw_config(struct i40e_hw *hw,
-			     struct i40e_virtchnl_vf_resource *msg);
+			     struct virtchnl_vf_resource *msg);
 i40e_status i40e_vf_reset(struct i40e_hw *hw);
 i40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,
-				enum i40e_virtchnl_ops v_opcode,
+				enum virtchnl_ops v_opcode,
 				i40e_status v_retval,
 				u8 *msg, u16 msglen,
 				struct i40e_asq_cmd_details *cmd_details);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_common.c b/drivers/net/ethernet/intel/i40evf/i40e_common.c
index 6729624fda5b..8ae45994a640 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_common.c
@@ -1054,7 +1054,7 @@ do_retry:
  * completion before returning.
  **/
 i40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,
-				enum i40e_virtchnl_ops v_opcode,
+				enum virtchnl_ops v_opcode,
 				i40e_status v_retval,
 				u8 *msg, u16 msglen,
 				struct i40e_asq_cmd_details *cmd_details)
@@ -1092,9 +1092,9 @@ i40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,
  * with appropriate information.
  **/
 void i40e_vf_parse_hw_config(struct i40e_hw *hw,
-			     struct i40e_virtchnl_vf_resource *msg)
+			     struct virtchnl_vf_resource *msg)
 {
-	struct i40e_virtchnl_vsi_resource *vsi_res;
+	struct virtchnl_vsi_resource *vsi_res;
 	int i;
 
 	vsi_res = &msg->vsi_res[0];
@@ -1104,7 +1104,7 @@ void i40e_vf_parse_hw_config(struct i40e_hw *hw,
 	hw->dev_caps.num_tx_qp = msg->num_queue_pairs;
 	hw->dev_caps.num_msix_vectors_vf = msg->max_vectors;
 	hw->dev_caps.dcb = msg->vf_offload_flags &
-			   I40E_VIRTCHNL_VF_OFFLOAD_L2;
+			   VIRTCHNL_VF_OFFLOAD_L2;
 	hw->dev_caps.fcoe = 0;
 	for (i = 0; i < msg->num_vsis; i++) {
 		if (vsi_res->vsi_type == I40E_VSI_SRIOV) {
@@ -1127,7 +1127,7 @@ void i40e_vf_parse_hw_config(struct i40e_hw *hw,
  **/
 i40e_status i40e_vf_reset(struct i40e_hw *hw)
 {
-	return i40e_aq_send_msg_to_pf(hw, I40E_VIRTCHNL_OP_RESET_VF,
+	return i40e_aq_send_msg_to_pf(hw, VIRTCHNL_OP_RESET_VF,
 				      0, NULL, 0, NULL);
 }
 
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_prototype.h b/drivers/net/ethernet/intel/i40evf/i40e_prototype.h
index 741223d5d809..4c1eb1dce317 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_prototype.h
@@ -87,10 +87,10 @@ static inline struct i40e_rx_ptype_decoded decode_rx_desc_ptype(u8 ptype)
 
 /* i40e_common for VF drivers*/
 void i40e_vf_parse_hw_config(struct i40e_hw *hw,
-			     struct i40e_virtchnl_vf_resource *msg);
+			     struct virtchnl_vf_resource *msg);
 i40e_status i40e_vf_reset(struct i40e_hw *hw);
 i40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,
-				enum i40e_virtchnl_ops v_opcode,
+				enum virtchnl_ops v_opcode,
 				i40e_status v_retval,
 				u8 *msg, u16 msglen,
 				struct i40e_asq_cmd_details *cmd_details);
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf.h b/drivers/net/ethernet/intel/i40evf/i40evf.h
index 1a29de1e6baa..4a89f3bda349 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@ -263,25 +263,25 @@ struct i40evf_adapter {
 	bool netdev_registered;
 	bool link_up;
 	enum i40e_aq_link_speed link_speed;
-	enum i40e_virtchnl_ops current_op;
+	enum virtchnl_ops current_op;
 #define CLIENT_ALLOWED(_a) ((_a)->vf_res ? \
 			    (_a)->vf_res->vf_offload_flags & \
-				I40E_VIRTCHNL_VF_OFFLOAD_IWARP : \
+				VIRTCHNL_VF_OFFLOAD_IWARP : \
 			    0)
 #define CLIENT_ENABLED(_a) ((_a)->cinst)
 /* RSS by the PF should be preferred over RSS via other methods. */
 #define RSS_PF(_a) ((_a)->vf_res->vf_offload_flags & \
-		    I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF)
+		    VIRTCHNL_VF_OFFLOAD_RSS_PF)
 #define RSS_AQ(_a) ((_a)->vf_res->vf_offload_flags & \
-		    I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ)
+		    VIRTCHNL_VF_OFFLOAD_RSS_AQ)
 #define RSS_REG(_a) (!((_a)->vf_res->vf_offload_flags & \
-		       (I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ | \
-			I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF)))
+		       (VIRTCHNL_VF_OFFLOAD_RSS_AQ | \
+			VIRTCHNL_VF_OFFLOAD_RSS_PF)))
 #define VLAN_ALLOWED(_a) ((_a)->vf_res->vf_offload_flags & \
-			  I40E_VIRTCHNL_VF_OFFLOAD_VLAN)
-	struct i40e_virtchnl_vf_resource *vf_res; /* incl. all VSIs */
-	struct i40e_virtchnl_vsi_resource *vsi_res; /* our LAN VSI */
-	struct i40e_virtchnl_version_info pf_version;
+			  VIRTCHNL_VF_OFFLOAD_VLAN)
+	struct virtchnl_vf_resource *vf_res; /* incl. all VSIs */
+	struct virtchnl_vsi_resource *vsi_res; /* our LAN VSI */
+	struct virtchnl_version_info pf_version;
 #define PF_IS_V11(_a) (((_a)->pf_version.major == 1) && \
 		       ((_a)->pf_version.minor == 1))
 	u16 msg_enable;
@@ -347,7 +347,7 @@ void i40evf_set_hena(struct i40evf_adapter *adapter);
 void i40evf_set_rss_key(struct i40evf_adapter *adapter);
 void i40evf_set_rss_lut(struct i40evf_adapter *adapter);
 void i40evf_virtchnl_completion(struct i40evf_adapter *adapter,
-				enum i40e_virtchnl_ops v_opcode,
+				enum virtchnl_ops v_opcode,
 				i40e_status v_retval, u8 *msg, u16 msglen);
 int i40evf_config_rss(struct i40evf_adapter *adapter);
 int i40evf_lan_add_device(struct i40evf_adapter *adapter);
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_client.c b/drivers/net/ethernet/intel/i40evf/i40evf_client.c
index ee737680a0e9..93cf5fd17d91 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_client.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_client.c
@@ -120,7 +120,7 @@ static int i40evf_client_release_qvlist(struct i40e_info *ldev)
 		return -EAGAIN;
 
 	err = i40e_aq_send_msg_to_pf(&adapter->hw,
-			I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP,
+			VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP,
 			I40E_SUCCESS, NULL, 0, NULL);
 
 	if (err)
@@ -410,7 +410,7 @@ static u32 i40evf_client_virtchnl_send(struct i40e_info *ldev,
 	if (adapter->aq_required)
 		return -EAGAIN;
 
-	err = i40e_aq_send_msg_to_pf(&adapter->hw, I40E_VIRTCHNL_OP_IWARP,
+	err = i40e_aq_send_msg_to_pf(&adapter->hw, VIRTCHNL_OP_IWARP,
 				     I40E_SUCCESS, msg, len, NULL);
 	if (err)
 		dev_err(&adapter->pdev->dev, "Unable to send iWarp message to PF, error %d, aq status %d\n",
@@ -431,7 +431,7 @@ static int i40evf_client_setup_qvlist(struct i40e_info *ldev,
 				      struct i40e_client *client,
 				      struct i40e_qvlist_info *qvlist_info)
 {
-	struct i40e_virtchnl_iwarp_qvlist_info *v_qvlist_info;
+	struct virtchnl_iwarp_qvlist_info *v_qvlist_info;
 	struct i40evf_adapter *adapter = ldev->vf;
 	struct i40e_qv_info *qv_info;
 	i40e_status err;
@@ -453,14 +453,14 @@ static int i40evf_client_setup_qvlist(struct i40e_info *ldev,
 			return -EINVAL;
 	}
 
-	v_qvlist_info = (struct i40e_virtchnl_iwarp_qvlist_info *)qvlist_info;
-	msg_size = sizeof(struct i40e_virtchnl_iwarp_qvlist_info) +
-			(sizeof(struct i40e_virtchnl_iwarp_qv_info) *
+	v_qvlist_info = (struct virtchnl_iwarp_qvlist_info *)qvlist_info;
+	msg_size = sizeof(struct virtchnl_iwarp_qvlist_info) +
+			(sizeof(struct virtchnl_iwarp_qv_info) *
 			(v_qvlist_info->num_vectors - 1));
 
-	adapter->client_pending |= BIT(I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP);
+	adapter->client_pending |= BIT(VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP);
 	err = i40e_aq_send_msg_to_pf(&adapter->hw,
-			I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP,
+			VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP,
 			I40E_SUCCESS, (u8 *)v_qvlist_info, msg_size, NULL);
 
 	if (err) {
@@ -474,7 +474,7 @@ static int i40evf_client_setup_qvlist(struct i40e_info *ldev,
 	for (i = 0; i < 5; i++) {
 		msleep(100);
 		if (!(adapter->client_pending &
-		      BIT(I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP))) {
+		      BIT(VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP))) {
 			err = 0;
 			break;
 		}
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
