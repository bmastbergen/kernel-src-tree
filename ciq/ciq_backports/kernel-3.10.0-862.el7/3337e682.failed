tools arch x86: Include asm/cmpxchg.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 3337e682d9f3043bb0b925d976558ed5c41b0a09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3337e682.failed

Will be included from atomic.h and used in refcount.h

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Elena Reshetova <elena.reshetova@intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-pzrydfee75mhq64kazxmf9it@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 3337e682d9f3043bb0b925d976558ed5c41b0a09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/MANIFEST
diff --cc tools/perf/MANIFEST
index 64db9555396e,e2c52190cf28..000000000000
--- a/tools/perf/MANIFEST
+++ b/tools/perf/MANIFEST
@@@ -12,6 -12,18 +12,21 @@@ tools/arch/sparc/include/asm/barrier_32
  tools/arch/sparc/include/asm/barrier_64.h
  tools/arch/tile/include/asm/barrier.h
  tools/arch/x86/include/asm/barrier.h
++<<<<<<< HEAD
++=======
+ tools/arch/x86/include/asm/cmpxchg.h
+ tools/arch/x86/include/asm/cpufeatures.h
+ tools/arch/x86/include/asm/disabled-features.h
+ tools/arch/x86/include/asm/required-features.h
+ tools/arch/x86/include/uapi/asm/svm.h
+ tools/arch/x86/include/uapi/asm/vmx.h
+ tools/arch/x86/include/uapi/asm/kvm.h
+ tools/arch/x86/include/uapi/asm/kvm_perf.h
+ tools/arch/x86/lib/memcpy_64.S
+ tools/arch/x86/lib/memset_64.S
+ tools/arch/s390/include/uapi/asm/kvm_perf.h
+ tools/arch/s390/include/uapi/asm/sie.h
++>>>>>>> 3337e682d9f3 (tools arch x86: Include asm/cmpxchg.h)
  tools/arch/xtensa/include/asm/barrier.h
  tools/scripts
  tools/build
diff --git a/tools/arch/x86/include/asm/cmpxchg.h b/tools/arch/x86/include/asm/cmpxchg.h
new file mode 100644
index 000000000000..f5253260f3cc
--- /dev/null
+++ b/tools/arch/x86/include/asm/cmpxchg.h
@@ -0,0 +1,89 @@
+#ifndef TOOLS_ASM_X86_CMPXCHG_H
+#define TOOLS_ASM_X86_CMPXCHG_H
+
+#include <linux/compiler.h>
+
+/*
+ * Non-existant functions to indicate usage errors at link time
+ * (or compile-time if the compiler implements __compiletime_error().
+ */
+extern void __cmpxchg_wrong_size(void)
+	__compiletime_error("Bad argument size for cmpxchg");
+
+/*
+ * Constants for operation sizes. On 32-bit, the 64-bit size it set to
+ * -1 because sizeof will never return -1, thereby making those switch
+ * case statements guaranteeed dead code which the compiler will
+ * eliminate, and allowing the "missing symbol in the default case" to
+ * indicate a usage error.
+ */
+#define __X86_CASE_B	1
+#define __X86_CASE_W	2
+#define __X86_CASE_L	4
+#ifdef __x86_64__
+#define __X86_CASE_Q	8
+#else
+#define	__X86_CASE_Q	-1		/* sizeof will never return -1 */
+#endif
+
+/*
+ * Atomic compare and exchange.  Compare OLD with MEM, if identical,
+ * store NEW in MEM.  Return the initial value in MEM.  Success is
+ * indicated by comparing RETURN with OLD.
+ */
+#define __raw_cmpxchg(ptr, old, new, size, lock)			\
+({									\
+	__typeof__(*(ptr)) __ret;					\
+	__typeof__(*(ptr)) __old = (old);				\
+	__typeof__(*(ptr)) __new = (new);				\
+	switch (size) {							\
+	case __X86_CASE_B:						\
+	{								\
+		volatile u8 *__ptr = (volatile u8 *)(ptr);		\
+		asm volatile(lock "cmpxchgb %2,%1"			\
+			     : "=a" (__ret), "+m" (*__ptr)		\
+			     : "q" (__new), "0" (__old)			\
+			     : "memory");				\
+		break;							\
+	}								\
+	case __X86_CASE_W:						\
+	{								\
+		volatile u16 *__ptr = (volatile u16 *)(ptr);		\
+		asm volatile(lock "cmpxchgw %2,%1"			\
+			     : "=a" (__ret), "+m" (*__ptr)		\
+			     : "r" (__new), "0" (__old)			\
+			     : "memory");				\
+		break;							\
+	}								\
+	case __X86_CASE_L:						\
+	{								\
+		volatile u32 *__ptr = (volatile u32 *)(ptr);		\
+		asm volatile(lock "cmpxchgl %2,%1"			\
+			     : "=a" (__ret), "+m" (*__ptr)		\
+			     : "r" (__new), "0" (__old)			\
+			     : "memory");				\
+		break;							\
+	}								\
+	case __X86_CASE_Q:						\
+	{								\
+		volatile u64 *__ptr = (volatile u64 *)(ptr);		\
+		asm volatile(lock "cmpxchgq %2,%1"			\
+			     : "=a" (__ret), "+m" (*__ptr)		\
+			     : "r" (__new), "0" (__old)			\
+			     : "memory");				\
+		break;							\
+	}								\
+	default:							\
+		__cmpxchg_wrong_size();					\
+	}								\
+	__ret;								\
+})
+
+#define __cmpxchg(ptr, old, new, size)					\
+	__raw_cmpxchg((ptr), (old), (new), (size), LOCK_PREFIX)
+
+#define cmpxchg(ptr, old, new)						\
+	__cmpxchg(ptr, old, new, sizeof(*(ptr)))
+
+
+#endif	/* TOOLS_ASM_X86_CMPXCHG_H */
* Unmerged path tools/perf/MANIFEST
diff --git a/tools/scripts/Makefile.include b/tools/scripts/Makefile.include
index 602135c2e66a..e75ef456b3dc 100644
--- a/tools/scripts/Makefile.include
+++ b/tools/scripts/Makefile.include
@@ -43,6 +43,15 @@ ifneq ($(CC), clang)
 EXTRA_WARNINGS += -Wstrict-aliasing=3
 endif
 
+# Hack to avoid type-punned warnings on old systems such as RHEL5:
+# We should be changing CFLAGS and checking gcc version, but this
+# will do for now and keep the above -Wstrict-aliasing=3 in place
+# in newer systems.
+# Needed for the __raw_cmpxchg in tools/arch/x86/include/asm/cmpxchg.h
+ifneq ($(filter 3.%,$(MAKE_VERSION)),)  # make-3
+EXTRA_WARNINGS += -fno-strict-aliasing
+endif
+
 ifneq ($(findstring $(MAKEFLAGS), w),w)
 PRINT_DIR = --no-print-directory
 else
