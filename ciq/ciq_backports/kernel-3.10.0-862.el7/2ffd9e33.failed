x86/hyper-v: Use hypercall for remote TLB flush

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] hyper-v: Use hypercall for remote TLB flush (Vitaly Kuznetsov) [1465471]
Rebuild_FUZZ: 95.56%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 2ffd9e33ce4af4e8cfa3e17bf493defe8474e2eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2ffd9e33.failed

Hyper-V host can suggest us to use hypercall for doing remote TLB flush,
this is supposed to work faster than IPIs.

Implementation details: to do HvFlushVirtualAddress{Space,List} hypercalls
we need to put the input somewhere in memory and we don't really want to
have memory allocation on each call so we pre-allocate per cpu memory areas
on boot.

pv_ops patching is happening very early so we need to separate
hyperv_setup_mmu_ops() and hyper_alloc_mmu().

It is possible and easy to implement local TLB flushing too and there is
even a hint for that. However, I don't see a room for optimization on the
host side as both hypercall and native tlb flush will result in vmexit. The
hint is also not set on modern Hyper-V versions.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Jork Loeser <Jork.Loeser@microsoft.com>
	Cc: K. Y. Srinivasan <kys@microsoft.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Simon Xiao <sixiao@microsoft.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: devel@linuxdriverproject.org
Link: http://lkml.kernel.org/r/20170802160921.21791-8-vkuznets@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 2ffd9e33ce4af4e8cfa3e17bf493defe8474e2eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,1a8eb550c40f..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -56,8 -137,52 +56,55 @@@ void hyperv_init(void
  
  	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
  	hypercall_msr.enable = 1;
 -	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hv_hypercall_pg);
 +	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);
  	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
++<<<<<<< HEAD
++=======
+ 
+ 	hyper_alloc_mmu();
+ 
+ 	/*
+ 	 * Register Hyper-V specific clocksource.
+ 	 */
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ 	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
+ 		union hv_x64_msr_hypercall_contents tsc_msr;
+ 
+ 		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
+ 		if (!tsc_pg)
+ 			goto register_msr_cs;
+ 
+ 		hyperv_cs = &hyperv_cs_tsc;
+ 
+ 		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 
+ 		tsc_msr.enable = 1;
+ 		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
+ 
+ 		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 
+ 		hyperv_cs_tsc.archdata.vclock_mode = VCLOCK_HVCLOCK;
+ 
+ 		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+ 		return;
+ 	}
+ register_msr_cs:
+ #endif
+ 	/*
+ 	 * For 32 bit guests just use the MSR based mechanism for reading
+ 	 * the partition counter.
+ 	 */
+ 
+ 	hyperv_cs = &hyperv_cs_msr;
+ 	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
+ 		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
+ 
+ 	return;
+ 
+ free_vp_index:
+ 	kfree(hv_vp_index);
+ 	hv_vp_index = NULL;
++>>>>>>> 2ffd9e33ce4a (x86/hyper-v: Use hypercall for remote TLB flush)
  }
  
  /*
diff --cc arch/x86/include/asm/mshyperv.h
index c86331fdc4b0,0d4b01c5e438..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -83,6 -169,208 +83,74 @@@ void hv_setup_crash_handler(void (*hand
  void hv_remove_crash_handler(void);
  
  #if IS_ENABLED(CONFIG_HYPERV)
 -extern struct clocksource *hyperv_cs;
 -extern void *hv_hypercall_pg;
 -
 -static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
 -{
 -	u64 input_address = input ? virt_to_phys(input) : 0;
 -	u64 output_address = output ? virt_to_phys(output) : 0;
 -	u64 hv_status;
 -	register void *__sp asm(_ASM_SP);
 -
 -#ifdef CONFIG_X86_64
 -	if (!hv_hypercall_pg)
 -		return U64_MAX;
 -
 -	__asm__ __volatile__("mov %4, %%r8\n"
 -			     "call *%5"
 -			     : "=a" (hv_status), "+r" (__sp),
 -			       "+c" (control), "+d" (input_address)
 -			     :  "r" (output_address), "m" (hv_hypercall_pg)
 -			     : "cc", "memory", "r8", "r9", "r10", "r11");
 -#else
 -	u32 input_address_hi = upper_32_bits(input_address);
 -	u32 input_address_lo = lower_32_bits(input_address);
 -	u32 output_address_hi = upper_32_bits(output_address);
 -	u32 output_address_lo = lower_32_bits(output_address);
 -
 -	if (!hv_hypercall_pg)
 -		return U64_MAX;
 -
 -	__asm__ __volatile__("call *%7"
 -			     : "=A" (hv_status),
 -			       "+c" (input_address_lo), "+r" (__sp)
 -			     : "A" (control),
 -			       "b" (input_address_hi),
 -			       "D"(output_address_hi), "S"(output_address_lo),
 -			       "m" (hv_hypercall_pg)
 -			     : "cc", "memory");
 -#endif /* !x86_64 */
 -	return hv_status;
 -}
 -
 -#define HV_HYPERCALL_RESULT_MASK	GENMASK_ULL(15, 0)
 -#define HV_HYPERCALL_FAST_BIT		BIT(16)
 -#define HV_HYPERCALL_VARHEAD_OFFSET	17
 -#define HV_HYPERCALL_REP_COMP_OFFSET	32
 -#define HV_HYPERCALL_REP_COMP_MASK	GENMASK_ULL(43, 32)
 -#define HV_HYPERCALL_REP_START_OFFSET	48
 -#define HV_HYPERCALL_REP_START_MASK	GENMASK_ULL(59, 48)
 -
 -/* Fast hypercall with 8 bytes of input and no output */
 -static inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)
 -{
 -	u64 hv_status, control = (u64)code | HV_HYPERCALL_FAST_BIT;
 -	register void *__sp asm(_ASM_SP);
 -
 -#ifdef CONFIG_X86_64
 -	{
 -		__asm__ __volatile__("call *%4"
 -				     : "=a" (hv_status), "+r" (__sp),
 -				       "+c" (control), "+d" (input1)
 -				     : "m" (hv_hypercall_pg)
 -				     : "cc", "r8", "r9", "r10", "r11");
 -	}
 -#else
 -	{
 -		u32 input1_hi = upper_32_bits(input1);
 -		u32 input1_lo = lower_32_bits(input1);
 -
 -		__asm__ __volatile__ ("call *%5"
 -				      : "=A"(hv_status),
 -					"+c"(input1_lo),
 -					"+r"(__sp)
 -				      :	"A" (control),
 -					"b" (input1_hi),
 -					"m" (hv_hypercall_pg)
 -				      : "cc", "edi", "esi");
 -	}
 -#endif
 -		return hv_status;
 -}
 -
 -/*
 - * Rep hypercalls. Callers of this functions are supposed to ensure that
 - * rep_count and varhead_size comply with Hyper-V hypercall definition.
 - */
 -static inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,
 -				      void *input, void *output)
 -{
 -	u64 control = code;
 -	u64 status;
 -	u16 rep_comp;
 -
 -	control |= (u64)varhead_size << HV_HYPERCALL_VARHEAD_OFFSET;
 -	control |= (u64)rep_count << HV_HYPERCALL_REP_COMP_OFFSET;
 -
 -	do {
 -		status = hv_do_hypercall(control, input, output);
 -		if ((status & HV_HYPERCALL_RESULT_MASK) != HV_STATUS_SUCCESS)
 -			return status;
 -
 -		/* Bits 32-43 of status have 'Reps completed' data. */
 -		rep_comp = (status & HV_HYPERCALL_REP_COMP_MASK) >>
 -			HV_HYPERCALL_REP_COMP_OFFSET;
 -
 -		control &= ~HV_HYPERCALL_REP_START_MASK;
 -		control |= (u64)rep_comp << HV_HYPERCALL_REP_START_OFFSET;
 -
 -		touch_nmi_watchdog();
 -	} while (rep_comp < rep_count);
 -
 -	return status;
 -}
 -
 -/*
 - * Hypervisor's notion of virtual processor ID is different from
 - * Linux' notion of CPU ID. This information can only be retrieved
 - * in the context of the calling CPU. Setup a map for easy access
 - * to this information.
 - */
 -extern u32 *hv_vp_index;
 -
 -/**
 - * hv_cpu_number_to_vp_number() - Map CPU to VP.
 - * @cpu_number: CPU number in Linux terms
 - *
 - * This function returns the mapping between the Linux processor
 - * number and the hypervisor's virtual processor number, useful
 - * in making hypercalls and such that talk about specific
 - * processors.
 - *
 - * Return: Virtual processor number in Hyper-V terms
 - */
 -static inline int hv_cpu_number_to_vp_number(int cpu_number)
 -{
 -	return hv_vp_index[cpu_number];
 -}
 -
  void hyperv_init(void);
++<<<<<<< HEAD
++=======
+ void hyperv_setup_mmu_ops(void);
+ void hyper_alloc_mmu(void);
+ void hyperv_report_panic(struct pt_regs *regs);
+ bool hv_is_hypercall_page_setup(void);
+ void hyperv_cleanup(void);
+ #else /* CONFIG_HYPERV */
+ static inline void hyperv_init(void) {}
+ static inline bool hv_is_hypercall_page_setup(void) { return false; }
+ static inline void hyperv_cleanup(void) {}
+ static inline void hyperv_setup_mmu_ops(void) {}
+ #endif /* CONFIG_HYPERV */
+ 
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
+ static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
+ {
+ 	u64 scale, offset, cur_tsc;
+ 	u32 sequence;
+ 
+ 	/*
+ 	 * The protocol for reading Hyper-V TSC page is specified in Hypervisor
+ 	 * Top-Level Functional Specification ver. 3.0 and above. To get the
+ 	 * reference time we must do the following:
+ 	 * - READ ReferenceTscSequence
+ 	 *   A special '0' value indicates the time source is unreliable and we
+ 	 *   need to use something else. The currently published specification
+ 	 *   versions (up to 4.0b) contain a mistake and wrongly claim '-1'
+ 	 *   instead of '0' as the special value, see commit c35b82ef0294.
+ 	 * - ReferenceTime =
+ 	 *        ((RDTSC() * ReferenceTscScale) >> 64) + ReferenceTscOffset
+ 	 * - READ ReferenceTscSequence again. In case its value has changed
+ 	 *   since our first reading we need to discard ReferenceTime and repeat
+ 	 *   the whole sequence as the hypervisor was updating the page in
+ 	 *   between.
+ 	 */
+ 	do {
+ 		sequence = READ_ONCE(tsc_pg->tsc_sequence);
+ 		if (!sequence)
+ 			return U64_MAX;
+ 		/*
+ 		 * Make sure we read sequence before we read other values from
+ 		 * TSC page.
+ 		 */
+ 		smp_rmb();
+ 
+ 		scale = READ_ONCE(tsc_pg->tsc_scale);
+ 		offset = READ_ONCE(tsc_pg->tsc_offset);
+ 		cur_tsc = rdtsc_ordered();
+ 
+ 		/*
+ 		 * Make sure we read sequence after we read all other values
+ 		 * from TSC page.
+ 		 */
+ 		smp_rmb();
+ 
+ 	} while (READ_ONCE(tsc_pg->tsc_sequence) != sequence);
+ 
+ 	return mul_u64_u64_shr(cur_tsc, scale, 64) + offset;
+ }
+ 
+ #else
+ static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
+ {
+ 	return NULL;
+ }
++>>>>>>> 2ffd9e33ce4a (x86/hyper-v: Use hypercall for remote TLB flush)
  #endif
  #endif
diff --git a/arch/x86/hyperv/Makefile b/arch/x86/hyperv/Makefile
index 171ae09864d7..367a8203cfcf 100644
--- a/arch/x86/hyperv/Makefile
+++ b/arch/x86/hyperv/Makefile
@@ -1 +1 @@
-obj-y		:= hv_init.o
+obj-y		:= hv_init.o mmu.o
* Unmerged path arch/x86/hyperv/hv_init.c
diff --git a/arch/x86/hyperv/mmu.c b/arch/x86/hyperv/mmu.c
new file mode 100644
index 000000000000..9419a20b1d75
--- /dev/null
+++ b/arch/x86/hyperv/mmu.c
@@ -0,0 +1,138 @@
+#define pr_fmt(fmt)  "Hyper-V: " fmt
+
+#include <linux/hyperv.h>
+#include <linux/log2.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include <asm/fpu/api.h>
+#include <asm/mshyperv.h>
+#include <asm/msr.h>
+#include <asm/tlbflush.h>
+
+/* HvFlushVirtualAddressSpace, HvFlushVirtualAddressList hypercalls */
+struct hv_flush_pcpu {
+	u64 address_space;
+	u64 flags;
+	u64 processor_mask;
+	u64 gva_list[];
+};
+
+/* Each gva in gva_list encodes up to 4096 pages to flush */
+#define HV_TLB_FLUSH_UNIT (4096 * PAGE_SIZE)
+
+static struct hv_flush_pcpu __percpu *pcpu_flush;
+
+/*
+ * Fills in gva_list starting from offset. Returns the number of items added.
+ */
+static inline int fill_gva_list(u64 gva_list[], int offset,
+				unsigned long start, unsigned long end)
+{
+	int gva_n = offset;
+	unsigned long cur = start, diff;
+
+	do {
+		diff = end > cur ? end - cur : 0;
+
+		gva_list[gva_n] = cur & PAGE_MASK;
+		/*
+		 * Lower 12 bits encode the number of additional
+		 * pages to flush (in addition to the 'cur' page).
+		 */
+		if (diff >= HV_TLB_FLUSH_UNIT)
+			gva_list[gva_n] |= ~PAGE_MASK;
+		else if (diff)
+			gva_list[gva_n] |= (diff - 1) >> PAGE_SHIFT;
+
+		cur += HV_TLB_FLUSH_UNIT;
+		gva_n++;
+
+	} while (cur < end);
+
+	return gva_n - offset;
+}
+
+static void hyperv_flush_tlb_others(const struct cpumask *cpus,
+				    const struct flush_tlb_info *info)
+{
+	int cpu, vcpu, gva_n, max_gvas;
+	struct hv_flush_pcpu *flush;
+	u64 status = U64_MAX;
+	unsigned long flags;
+
+	if (!pcpu_flush || !hv_hypercall_pg)
+		goto do_native;
+
+	if (cpumask_empty(cpus))
+		return;
+
+	local_irq_save(flags);
+
+	flush = this_cpu_ptr(pcpu_flush);
+
+	if (info->mm) {
+		flush->address_space = virt_to_phys(info->mm->pgd);
+		flush->flags = 0;
+	} else {
+		flush->address_space = 0;
+		flush->flags = HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES;
+	}
+
+	flush->processor_mask = 0;
+	if (cpumask_equal(cpus, cpu_present_mask)) {
+		flush->flags |= HV_FLUSH_ALL_PROCESSORS;
+	} else {
+		for_each_cpu(cpu, cpus) {
+			vcpu = hv_cpu_number_to_vp_number(cpu);
+			if (vcpu >= 64)
+				goto do_native;
+
+			__set_bit(vcpu, (unsigned long *)
+				  &flush->processor_mask);
+		}
+	}
+
+	/*
+	 * We can flush not more than max_gvas with one hypercall. Flush the
+	 * whole address space if we were asked to do more.
+	 */
+	max_gvas = (PAGE_SIZE - sizeof(*flush)) / sizeof(flush->gva_list[0]);
+
+	if (info->end == TLB_FLUSH_ALL) {
+		flush->flags |= HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY;
+		status = hv_do_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE,
+					 flush, NULL);
+	} else if (info->end &&
+		   ((info->end - info->start)/HV_TLB_FLUSH_UNIT) > max_gvas) {
+		status = hv_do_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE,
+					 flush, NULL);
+	} else {
+		gva_n = fill_gva_list(flush->gva_list, 0,
+				      info->start, info->end);
+		status = hv_do_rep_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST,
+					     gva_n, 0, flush, NULL);
+	}
+
+	local_irq_restore(flags);
+
+	if (!(status & HV_HYPERCALL_RESULT_MASK))
+		return;
+do_native:
+	native_flush_tlb_others(cpus, info);
+}
+
+void hyperv_setup_mmu_ops(void)
+{
+	if (ms_hyperv.hints & HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED) {
+		pr_info("Using hypercall for remote TLB flush\n");
+		pv_mmu_ops.flush_tlb_others = hyperv_flush_tlb_others;
+		setup_clear_cpu_cap(X86_FEATURE_PCID);
+	}
+}
+
+void hyper_alloc_mmu(void)
+{
+	if (ms_hyperv.hints & HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED)
+		pcpu_flush = __alloc_percpu(PAGE_SIZE, PAGE_SIZE);
+}
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/arch/x86/include/uapi/asm/hyperv.h b/arch/x86/include/uapi/asm/hyperv.h
index bd4aafaa6956..3d496a26e51f 100644
--- a/arch/x86/include/uapi/asm/hyperv.h
+++ b/arch/x86/include/uapi/asm/hyperv.h
@@ -221,6 +221,8 @@
 		(~((1ull << HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT) - 1))
 
 /* Declare the various hypercall operations. */
+#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE	0x0002
+#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST	0x0003
 #define HVCALL_NOTIFY_LONG_SPIN_WAIT		0x0008
 
 #define HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE		0x00000001
@@ -236,6 +238,11 @@
 #define HV_PROCESSOR_POWER_STATE_C2		2
 #define HV_PROCESSOR_POWER_STATE_C3		3
 
+#define HV_FLUSH_ALL_PROCESSORS			BIT(0)
+#define HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES	BIT(1)
+#define HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY	BIT(2)
+#define HV_FLUSH_USE_EXTENDED_RANGE_FORMAT	BIT(3)
+
 /* hypercall status code */
 #define HV_STATUS_SUCCESS			0
 #define HV_STATUS_INVALID_HYPERCALL_CODE	2
diff --git a/arch/x86/kernel/cpu/mshyperv.c b/arch/x86/kernel/cpu/mshyperv.c
index c6f16658fa88..c780db6f5eba 100644
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@ -252,6 +252,7 @@ static void __init ms_hyperv_init_platform(void)
 	 * Setup the hook to get control post apic initialization.
 	 */
 	x86_platform.apic_post_init = hyperv_init;
+	hyperv_setup_mmu_ops();
 #endif
 }
 
diff --git a/drivers/hv/Kconfig b/drivers/hv/Kconfig
index 0403b51d20ba..4743a250a86f 100644
--- a/drivers/hv/Kconfig
+++ b/drivers/hv/Kconfig
@@ -3,6 +3,7 @@ menu "Microsoft Hyper-V guest support"
 config HYPERV
 	tristate "Microsoft Hyper-V client drivers"
 	depends on X86 && ACPI && PCI && X86_LOCAL_APIC && HYPERVISOR_GUEST
+	select PARAVIRT
 	help
 	  Select this option to run Linux as a Hyper-V client operating
 	  system.
