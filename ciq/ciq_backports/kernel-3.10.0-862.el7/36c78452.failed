qla2xxx: Add DebugFS node for target sess list.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add DebugFS node for target sess list (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 98.92%
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit 36c7845282eef0104ba6ecc6761ba1dce57b2b87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/36c78452.failed

 #cat  /sys/kernel/debug/qla2xxx/qla2xxx_31/tgt_sess
 qla2xxx_31
 Port ID   Port Name                Handle
 ff:fc:01  21:fd:00:05:33:c7:ec:16  0
 01:0e:00  21:00:00:24:ff:7b:8a:e4  1
 01:0f:00  21:00:00:24:ff:7b:8a:e5  2
 ....

(Drop ->check_initiator_node_acl() parameter usage - nab)

	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 36c7845282eef0104ba6ecc6761ba1dce57b2b87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_dfs.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index e18cc36570ad,e6c5bcf24162..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2968,9 -2928,26 +2968,21 @@@ struct qlt_hw_data 
  	uint8_t saved_add_firmware_options[2];
  
  	uint8_t tgt_node_name[WWN_SIZE];
++<<<<<<< HEAD
++=======
+ 
+ 	struct dentry *dfs_tgt_sess;
+ 	struct list_head q_full_list;
+ 	uint32_t num_pend_cmds;
+ 	uint32_t num_qfull_cmds_alloc;
+ 	uint32_t num_qfull_cmds_dropped;
+ 	spinlock_t q_full_lock;
+ 	uint32_t leak_exchg_thresh_hold;
+ 	spinlock_t sess_lock;
++>>>>>>> 36c7845282ee (qla2xxx: Add DebugFS node for target sess list.)
  	int rspq_vector_cpuid;
 -	spinlock_t atio_lock ____cacheline_aligned;
  };
  
 -#define MAX_QFULL_CMDS_ALLOC	8192
 -#define Q_FULL_THRESH_HOLD_PERCENT 90
 -#define Q_FULL_THRESH_HOLD(ha) \
 -	((ha->cur_fw_xcb_count/100) * Q_FULL_THRESH_HOLD_PERCENT)
 -
 -#define LEAK_EXCHG_THRESH_HOLD_PERCENT 75	/* 75 percent */
 -
  /*
   * Qlogic host adapter specific data structure.
  */
diff --cc drivers/scsi/qla2xxx/qla_dfs.c
index 2ca39b8e7166,34272fde8a5b..000000000000
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@@ -13,6 -13,126 +13,129 @@@ static struct dentry *qla2x00_dfs_root
  static atomic_t qla2x00_dfs_root_count;
  
  static int
++<<<<<<< HEAD
++=======
+ qla2x00_dfs_tgt_sess_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct qla_tgt_sess *sess = NULL;
+ 	struct qla_tgt *tgt= vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n",vha->host_str);
+ 	if (tgt) {
+ 		seq_printf(s, "Port ID   Port Name                Handle\n");
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		list_for_each_entry(sess, &tgt->sess_list, sess_list_entry) {
+ 			seq_printf(s, "%02x:%02x:%02x  %8phC  %d\n",
+ 					   sess->s_id.b.domain,sess->s_id.b.area,
+ 					   sess->s_id.b.al_pa,	sess->port_name,
+ 					   sess->loop_id);
+ 		}
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_sess_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 	return single_open(file, qla2x00_dfs_tgt_sess_show, vha);
+ }
+ 
+ 
+ static const struct file_operations dfs_tgt_sess_ops = {
+ 	.open		= qla2x00_dfs_tgt_sess_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	seq_puts(s, "FW Resource count\n\n");
+ 	seq_printf(s, "Original TGT exchg count[%d]\n",
+ 	    ha->orig_fw_tgt_xcb_count);
+ 	seq_printf(s, "current TGT exchg count[%d]\n",
+ 	    ha->cur_fw_tgt_xcb_count);
+ 	seq_printf(s, "original Initiator Exchange count[%d]\n",
+ 	    ha->orig_fw_xcb_count);
+ 	seq_printf(s, "Current Initiator Exchange count[%d]\n",
+ 	    ha->cur_fw_xcb_count);
+ 	seq_printf(s, "Original IOCB count[%d]\n", ha->orig_fw_iocb_count);
+ 	seq_printf(s, "Current IOCB count[%d]\n", ha->cur_fw_iocb_count);
+ 	seq_printf(s, "MAX VP count[%d]\n", ha->max_npiv_vports);
+ 	seq_printf(s, "MAX FCF count[%d]\n", ha->fw_max_fcf_count);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_fw_resource_cnt_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_fw_resource_cnt_show, vha);
+ }
+ 
+ static const struct file_operations dfs_fw_resource_cnt_ops = {
+ 	.open           = qla_dfs_fw_resource_cnt_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
+ qla_dfs_tgt_counters_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 
+ 	seq_puts(s, "Target Counters\n");
+ 	seq_printf(s, "qla_core_sbt_cmd = %lld\n",
+ 		vha->tgt_counters.qla_core_sbt_cmd);
+ 	seq_printf(s, "qla_core_ret_sta_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_sta_ctio);
+ 	seq_printf(s, "qla_core_ret_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_ctio);
+ 	seq_printf(s, "core_qla_que_buf = %lld\n",
+ 		vha->tgt_counters.core_qla_que_buf);
+ 	seq_printf(s, "core_qla_snd_status = %lld\n",
+ 		vha->tgt_counters.core_qla_snd_status);
+ 	seq_printf(s, "core_qla_free_cmd = %lld\n",
+ 		vha->tgt_counters.core_qla_free_cmd);
+ 	seq_printf(s, "num alloc iocb failed = %lld\n",
+ 		vha->tgt_counters.num_alloc_iocb_failed);
+ 	seq_printf(s, "num term exchange sent = %lld\n",
+ 		vha->tgt_counters.num_term_xchg_sent);
+ 	seq_printf(s, "num Q full sent = %lld\n",
+ 		vha->tgt_counters.num_q_full_sent);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_tgt_counters_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_tgt_counters_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_counters_ops = {
+ 	.open           = qla_dfs_tgt_counters_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
++>>>>>>> 36c7845282ee (qla2xxx: Add DebugFS node for target sess list.)
  qla2x00_dfs_fce_show(struct seq_file *s, void *unused)
  {
  	scsi_qla_host_t *vha = s->private;
@@@ -161,6 -306,22 +293,25 @@@ in
  qla2x00_dfs_remove(scsi_qla_host_t *vha)
  {
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 
+ 	if (ha->tgt.dfs_tgt_sess) {
+ 		debugfs_remove(ha->tgt.dfs_tgt_sess);
+ 		ha->tgt.dfs_tgt_sess = NULL;
+ 	}
+ 
+ 	if (ha->dfs_fw_resource_cnt) {
+ 		debugfs_remove(ha->dfs_fw_resource_cnt);
+ 		ha->dfs_fw_resource_cnt = NULL;
+ 	}
+ 
+ 	if (ha->dfs_tgt_counters) {
+ 		debugfs_remove(ha->dfs_tgt_counters);
+ 		ha->dfs_tgt_counters = NULL;
+ 	}
+ 
++>>>>>>> 36c7845282ee (qla2xxx: Add DebugFS node for target sess list.)
  	if (ha->dfs_fce) {
  		debugfs_remove(ha->dfs_fce);
  		ha->dfs_fce = NULL;
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 94564b5245d8,985231900aca..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -366,11 -641,12 +366,12 @@@ void qlt_unreg_sess(struct qla_tgt_ses
  {
  	struct scsi_qla_host *vha = sess->vha;
  
- 	vha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);
+ 	if (sess->se_sess)
+ 		vha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);
  
 -	if (!list_empty(&sess->del_list_entry))
 -		list_del_init(&sess->del_list_entry);
 -	sess->deleted = QLA_SESS_DELETION_IN_PROGRESS;
 +	list_del(&sess->sess_list_entry);
 +	if (sess->deleted)
 +		list_del(&sess->del_list_entry);
  
  	INIT_WORK(&sess->free_work, qlt_free_session_done);
  	schedule_work(&sess->free_work);
@@@ -652,47 -848,24 +653,59 @@@ static void qlt_del_sess_work_fn(struc
  	while (!list_empty(&tgt->del_sess_list)) {
  		sess = list_entry(tgt->del_sess_list.next, typeof(*sess),
  		    del_list_entry);
 -		elapsed = jiffies;
 -		if (time_after_eq(elapsed, sess->expires)) {
 -			/* No turning back */
 -			list_del_init(&sess->del_list_entry);
 -			sess->deleted = QLA_SESS_DELETION_IN_PROGRESS;
 +		if (time_after_eq(jiffies, sess->expires)) {
 +			bool cancel;
 +
++<<<<<<< HEAD
 +			qlt_undelete_sess(sess);
 +
 +			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +			cancel = qlt_check_fcport_exist(vha, sess);
 +
 +			if (cancel) {
 +				if (sess->deleted) {
 +					/*
 +					 * sess was again deleted while we were
 +					 * discovering it
 +					 */
 +					spin_lock_irqsave(&ha->hardware_lock,
 +					    flags);
 +					continue;
 +				}
 +
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf049,
 +				    "qla_target(%d): cancel deletion of "
 +				    "session for port %02x:%02x:%02x:%02x:%02x:"
 +				    "%02x:%02x:%02x (loop ID %d), because "
 +				    " it isn't deleted by firmware",
 +				    vha->vp_idx, sess->port_name[0],
 +				    sess->port_name[1], sess->port_name[2],
 +				    sess->port_name[3], sess->port_name[4],
 +				    sess->port_name[5], sess->port_name[6],
 +				    sess->port_name[7], sess->loop_id);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,
 +				    "Timeout: sess %p about to be deleted\n",
 +				    sess);
 +				ha->tgt.tgt_ops->shutdown_sess(sess);
 +				ha->tgt.tgt_ops->put_sess(sess);
 +			}
  
 +			spin_lock_irqsave(&ha->hardware_lock, flags);
++=======
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,
+ 			    "Timeout: sess %p about to be deleted\n",
+ 			    sess);
+ 			if (sess->se_sess) {
+ 				ha->tgt.tgt_ops->shutdown_sess(sess);
+ 				ha->tgt.tgt_ops->put_sess(sess);
+ 			} else {
+ 				qlt_unreg_sess(sess);
+ 			}
++>>>>>>> 36c7845282ee (qla2xxx: Add DebugFS node for target sess list.)
  		} else {
  			schedule_delayed_work(&tgt->sess_del_work,
 -			    sess->expires - elapsed);
 +			    jiffies - sess->expires);
  			break;
  		}
  	}
@@@ -760,28 -950,16 +781,31 @@@ static struct qla_tgt_sess *qlt_create_
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf006,
  	    "Adding sess %p to tgt %p via ->check_initiator_node_acl()\n",
 -	    sess, vha->vha_tgt.qla_tgt);
 +	    sess, ha->tgt.qla_tgt);
 +
++<<<<<<< HEAD
 +	be_sid[0] = sess->s_id.b.domain;
 +	be_sid[1] = sess->s_id.b.area;
 +	be_sid[2] = sess->s_id.b.al_pa;
 +	/*
 +	 * Determine if this fc_port->port_name is allowed to access
 +	 * target mode using explict NodeACLs+MappedLUNs, or using
 +	 * TPG demo mode.  If this is successful a target mode FC nexus
 +	 * is created.
 +	 */
 +	if (ha->tgt.tgt_ops->check_initiator_node_acl(vha,
 +	    &fcport->port_name[0], sess, &be_sid[0], fcport->loop_id) < 0) {
 +		kfree(sess);
 +		return NULL;
 +	}
 +	/*
 +	 * Take an extra reference to ->sess_kref here to handle qla_tgt_sess
 +	 * access across ->hardware_lock reaquire.
 +	 */
 +	kref_get(&sess->se_sess->sess_kref);
  
++=======
++>>>>>>> 36c7845282ee (qla2xxx: Add DebugFS node for target sess list.)
  	sess->conf_compl_supported = (fcport->flags & FCF_CONF_COMP_SUPPORTED);
  	BUILD_BUG_ON(sizeof(sess->port_name) != sizeof(fcport->port_name));
  	memcpy(sess->port_name, fcport->port_name, sizeof(sess->port_name));
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_dfs.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
