nvme-fc: mark two symbols static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: mark two symbols static (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 91.53%
commit-author Christoph Hellwig <hch@lst.de>
commit baee29ac17e6363c9ec843de6b83afc95932e9c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/baee29ac.failed

Found by sparse.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
(cherry picked from commit baee29ac17e6363c9ec843de6b83afc95932e9c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index ab495bc8c3fb,e73862ebb8b4..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1137,7 -1236,28 +1137,32 @@@ nvme_fc_exit_aen_ops(struct nvme_fc_ctr
  	}
  }
  
++<<<<<<< HEAD
 +void
++=======
+ static inline int
+ __nvme_fc_fcpop_chk_teardowns(struct nvme_fc_ctrl *ctrl,
+ 		struct nvme_fc_fcp_op *op)
+ {
+ 	unsigned long flags;
+ 	bool complete_rq = false;
+ 
+ 	spin_lock_irqsave(&ctrl->lock, flags);
+ 	if (unlikely(op->flags & FCOP_FLAGS_TERMIO)) {
+ 		if (ctrl->flags & FCCTRL_TERMIO)
+ 			ctrl->iocnt--;
+ 	}
+ 	if (op->flags & FCOP_FLAGS_RELEASED)
+ 		complete_rq = true;
+ 	else
+ 		op->flags |= FCOP_FLAGS_COMPLETE;
+ 	spin_unlock_irqrestore(&ctrl->lock, flags);
+ 
+ 	return complete_rq;
+ }
+ 
+ static void
++>>>>>>> baee29ac17e6 (nvme-fc: mark two symbols static)
  nvme_fc_fcpio_done(struct nvmefc_fcp_req *req)
  {
  	struct nvme_fc_fcp_op *op = fcp_req_to_fcp_op(req);
@@@ -1604,27 -1746,29 +1629,27 @@@ nvme_fc_free_nvme_ctrl(struct nvme_ctr
  	nvme_fc_ctrl_put(ctrl);
  }
  
 -static void
 -nvme_fc_error_recovery(struct nvme_fc_ctrl *ctrl, char *errmsg)
 +
 +static int
 +__nvme_fc_abort_op(struct nvme_fc_ctrl *ctrl, struct nvme_fc_fcp_op *op)
  {
 -	dev_warn(ctrl->ctrl.device,
 -		"NVME-FC{%d}: transport association error detected: %s\n",
 -		ctrl->cnum, errmsg);
 -	dev_info(ctrl->ctrl.device,
 -		"NVME-FC{%d}: resetting controller\n", ctrl->cnum);
 +	int state;
  
 -	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_RECONNECTING)) {
 -		dev_err(ctrl->ctrl.device,
 -			"NVME-FC{%d}: error_recovery: Couldn't change state "
 -			"to RECONNECTING\n", ctrl->cnum);
 -		return;
 +	state = atomic_xchg(&op->state, FCPOP_STATE_ABORTED);
 +	if (state != FCPOP_STATE_ACTIVE) {
 +		atomic_set(&op->state, state);
 +		return -ECANCELED; /* fail */
  	}
  
 -	if (!queue_work(nvme_fc_wq, &ctrl->reset_work))
 -		dev_err(ctrl->ctrl.device,
 -			"NVME-FC{%d}: error_recovery: Failed to schedule "
 -			"reset work\n", ctrl->cnum);
 +	ctrl->lport->ops->fcp_abort(&ctrl->lport->localport,
 +					&ctrl->rport->remoteport,
 +					op->queue->lldd_handle,
 +					&op->fcp_req);
 +
 +	return 0;
  }
  
- enum blk_eh_timer_return
+ static enum blk_eh_timer_return
  nvme_fc_timeout(struct request *rq, bool reserved)
  {
  	struct nvme_fc_fcp_op *op = blk_mq_rq_to_pdu(rq);
* Unmerged path drivers/nvme/host/fc.c
