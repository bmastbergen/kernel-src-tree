pinctrl: intel: Configure GPIO chip IRQ as wakeup interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [pinctrl] intel: Configure GPIO chip IRQ as wakeup interrupts (David Arcari) [1467490]
Rebuild_FUZZ: 91.89%
commit-author Nilesh Bacchewar <nilesh.bacchewar@intel.com>
commit 01dabe91b1fef93130207e1a04bdf0a092a9fb21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/01dabe91.failed

On some Intel BXT platform, wake-up from suspend-to-idle on pressing
power-button is not working. Its noticed that gpio-keys driver marking the
second level IRQ/power-button as wake capable but Intel pintctrl
driver is missing to mark GPIO chip/controller IRQ which first level IRQ
as wake cable if its GPIO pin IRQ is wakeble. So, though the first level
IRQ gets generated on power-button press, since it is not marked as
wake capable resume/wake-up flow is not happening.
Intel pintctrl/GPIO driver need to mark GPIO chip/controller IRQ (first
level IRQ) as wake capable iff GPIO pin's IRQ (second level IRQ) is marked
as wake cable.

Changes in v2:
 - Add missing irq initialisation.

	Signed-off-by: Nilesh Bacchewar <nilesh.bacchewar@intel.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 01dabe91b1fef93130207e1a04bdf0a092a9fb21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-intel.c
diff --cc drivers/pinctrl/intel/pinctrl-intel.c
index 49ce785b1a2d,63387a40b973..000000000000
--- a/drivers/pinctrl/intel/pinctrl-intel.c
+++ b/drivers/pinctrl/intel/pinctrl-intel.c
@@@ -103,9 -98,9 +104,10 @@@ struct intel_pinctrl 
  	struct intel_community *communities;
  	size_t ncommunities;
  	struct intel_pinctrl_context context;
+ 	int irq;
  };
  
 +#define gpiochip_to_pinctrl(c)	container_of(c, struct intel_pinctrl, chip)
  #define pin_to_padno(c, p)	((p) - (c)->pin_base)
  
  static struct intel_community *intel_get_community(struct intel_pinctrl *pctrl,
@@@ -809,39 -794,13 +811,40 @@@ static int intel_gpio_irq_type(struct i
  static int intel_gpio_irq_wake(struct irq_data *d, unsigned int on)
  {
  	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++<<<<<<< HEAD
 +	struct intel_pinctrl *pctrl = gpiochip_to_pinctrl(gc);
 +	const struct intel_community *community;
++=======
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(gc);
++>>>>>>> 01dabe91b1fe (pinctrl: intel: Configure GPIO chip IRQ as wakeup interrupts)
  	unsigned pin = irqd_to_hwirq(d);
- 	unsigned padno, gpp, gpp_offset;
- 	unsigned long flags;
- 	u32 gpe_en;
  
++<<<<<<< HEAD
 +	community = intel_get_community(pctrl, pin);
 +	if (!community)
 +		return -EINVAL;
 +
 +	raw_spin_lock_irqsave(&pctrl->lock, flags);
 +
 +	padno = pin_to_padno(community, pin);
 +	gpp = padno / NPADS_IN_GPP;
 +	gpp_offset = padno % NPADS_IN_GPP;
 +
 +	/* Clear the existing wake status */
 +	writel(BIT(gpp_offset), community->regs + GPI_GPE_STS + gpp * 4);
 +
 +	/*
 +	 * The controller will generate wake when GPE of the corresponding
 +	 * pad is enabled and it is not routed to SCI (GPIROUTSCI is not
 +	 * set).
 +	 */
 +	gpe_en = readl(community->regs + GPI_GPE_EN + gpp * 4);
++=======
++>>>>>>> 01dabe91b1fe (pinctrl: intel: Configure GPIO chip IRQ as wakeup interrupts)
  	if (on)
- 		gpe_en |= BIT(gpp_offset);
+ 		enable_irq_wake(pctrl->irq);
  	else
- 		gpe_en &= ~BIT(gpp_offset);
- 	writel(gpe_en, community->regs + GPI_GPE_EN + gpp * 4);
- 
- 	raw_spin_unlock_irqrestore(&pctrl->lock, flags);
+ 		disable_irq_wake(pctrl->irq);
  
  	dev_dbg(pctrl->dev, "%sable wake for pin %u\n", on ? "en" : "dis", pin);
  	return 0;
@@@ -934,10 -879,11 +937,11 @@@ static int intel_gpio_probe(struct inte
  
  	pctrl->chip.ngpio = pctrl->soc->npins;
  	pctrl->chip.label = dev_name(pctrl->dev);
 -	pctrl->chip.parent = pctrl->dev;
 +	pctrl->chip.dev = pctrl->dev;
  	pctrl->chip.base = -1;
+ 	pctrl->irq = irq;
  
 -	ret = gpiochip_add_data(&pctrl->chip, pctrl);
 +	ret = gpiochip_add(&pctrl->chip);
  	if (ret) {
  		dev_err(pctrl->dev, "failed to register gpiochip\n");
  		return ret;
* Unmerged path drivers/pinctrl/intel/pinctrl-intel.c
