blk-flush: use blk_mq_request_bypass_insert()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ming Lei <ming.lei@redhat.com>
commit 598906f814280762157629ba8833bf5cb11def74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/598906f8.failed

In the following patch, we will use RQF_FLUSH_SEQ to decide:

1) if the flag isn't set, the flush rq need to be inserted via
blk_insert_flush()

2) otherwise, the flush rq need to be dispatched directly since
it is in flush machinery now.

So we use blk_mq_request_bypass_insert() for requests of bypassing
flush machinery, just like the legacy path did.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 598906f814280762157629ba8833bf5cb11def74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-flush.c
diff --cc block/blk-flush.c
index d39239cb6a4c,a9773d2075ac..000000000000
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@@ -422,9 -462,9 +422,15 @@@ void blk_insert_flush(struct request *r
  	 */
  	if ((policy & REQ_FSEQ_DATA) &&
  	    !(policy & (REQ_FSEQ_PREFLUSH | REQ_FSEQ_POSTFLUSH))) {
++<<<<<<< HEAD
 +		if (q->mq_ops) {
 +			blk_mq_insert_request(rq, false, true, false);
 +		} else
++=======
+ 		if (q->mq_ops)
+ 			blk_mq_request_bypass_insert(rq, false);
+ 		else
++>>>>>>> 598906f81428 (blk-flush: use blk_mq_request_bypass_insert())
  			list_add_tail(&rq->queuelist, &q->queue_head);
  		return;
  	}
* Unmerged path block/blk-flush.c
