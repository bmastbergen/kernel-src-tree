ALSA: x86: Remove _v[12] suffices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: x86: Remove _v[12] suffices (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 91.80%
commit-author Takashi Iwai <tiwai@suse.de>
commit 4151ee845ad8230d18ac4a0e0bf1037180c6d2d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4151ee84.failed

Although we dropped the most of the obsoleted *_v1 definitions and
codes, some codes still keep the _v1 or _v2 suffices.  Now they are
ripped off.

The only thing to be done carefully here is the definition of control
offsets.  The original code defines enum hdmi_ctrl_reg_offset_v1 and
a few new elements just for v2 on its top.  After this cleanup, we
remove the old AUD_HDMI_STATUS and AUD_HDMIW_INFOFR definitions and
replace with the v2 values.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 4151ee845ad8230d18ac4a0e0bf1037180c6d2d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index f2f54691cb43,84b374cc183f..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -259,28 -249,43 +259,46 @@@ static int had_read_modify_aud_config_v
  		channels = substream->runtime->channels;
  	else
  		channels = 2;
- 	cfg_val.cfg_regx_v2.num_ch = channels - 2;
+ 	cfg_val.cfg_regx.num_ch = channels - 2;
  
  	data = data | cfg_val.cfg_regval;
- 	mask = mask | AUD_CONFIG_CH_MASK_V2;
+ 	mask = mask | AUD_CONFIG_CH_MASK;
  
 -	dev_dbg(intelhaddata->dev, "%s : data = %x, mask =%x\n",
 -		__func__, data, mask);
 +	pr_debug("%s : data = %x, mask =%x\n", __func__, data, mask);
  
  	return had_read_modify(intelhaddata, AUD_CONFIG, data, mask);
  }
  
 -static void snd_intelhad_enable_audio_int(struct snd_intelhad *ctx, bool enable)
 +void snd_intelhad_enable_audio(struct snd_pcm_substream *substream, u8 enable)
  {
++<<<<<<< HEAD
 +	had_read_modify_aud_config_v2(substream, enable, BIT(0));
++=======
+ 	u32 status_reg;
+ 
+ 	if (enable) {
+ 		mid_hdmi_audio_read(ctx, AUD_HDMI_STATUS, &status_reg);
+ 		status_reg |= HDMI_AUDIO_BUFFER_DONE | HDMI_AUDIO_UNDERRUN;
+ 		mid_hdmi_audio_write(ctx, AUD_HDMI_STATUS, status_reg);
+ 		mid_hdmi_audio_read(ctx, AUD_HDMI_STATUS, &status_reg);
+ 	}
+ }
+ 
+ static void snd_intelhad_enable_audio(struct snd_intelhad *intelhaddata,
+ 				      bool enable)
+ {
+ 	had_read_modify_aud_config_v2(intelhaddata, enable ? BIT(0) : 0,
+ 				      BIT(0));
++>>>>>>> 4151ee845ad8 (ALSA: x86: Remove _v[12] suffices)
  }
  
  static void snd_intelhad_reset_audio(struct snd_intelhad *intelhaddata,
  				     u8 reset)
  {
- 	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, reset);
+ 	had_write_register(intelhaddata, AUD_HDMI_STATUS, reset);
  }
  
 -/*
 +/**
   * initialize audio channel status registers
   * This function is called in the prepare callback
   */
@@@ -292,13 -297,11 +310,18 @@@ static int had_prog_status_reg(struct s
  	union aud_ch_status_1 ch_stat1 = {.status_1_regval = 0};
  	int format;
  
 +	pr_debug("Entry %s\n", __func__);
 +
  	ch_stat0.status_0_regx.lpcm_id = (intelhaddata->aes_bits &
 -					  IEC958_AES0_NONAUDIO) >> 1;
 +						IEC958_AES0_NONAUDIO)>>1;
  	ch_stat0.status_0_regx.clk_acc = (intelhaddata->aes_bits &
++<<<<<<< HEAD
 +						IEC958_AES3_CON_CLOCK)>>4;
 +	cfg_val.cfg_regx_v2.val_bit = ch_stat0.status_0_regx.lpcm_id;
++=======
+ 					  IEC958_AES3_CON_CLOCK) >> 4;
+ 	cfg_val.cfg_regx.val_bit = ch_stat0.status_0_regx.lpcm_id;
++>>>>>>> 4151ee845ad8 (ALSA: x86: Remove _v[12] suffices)
  
  	switch (substream->runtime->rate) {
  	case AUD_SAMPLE_RATE_32:
@@@ -924,16 -916,16 +947,22 @@@ void snd_intelhad_handle_underrun(struc
  	/* Handle Underrun interrupt within Audio Unit */
  	had_write_register(intelhaddata, AUD_CONFIG, 0);
  	/* Reset buffer pointers */
++<<<<<<< HEAD
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, 1);
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, 0);
 +	/**
++=======
+ 	had_write_register(intelhaddata, AUD_HDMI_STATUS, 1);
+ 	had_write_register(intelhaddata, AUD_HDMI_STATUS, 0);
+ 	/*
++>>>>>>> 4151ee845ad8 (ALSA: x86: Remove _v[12] suffices)
  	 * The interrupt status 'sticky' bits might not be cleared by
  	 * setting '1' to that bit once...
  	 */
  	do { /* clear bit30, 31 AUD_HDMI_STATUS */
- 		had_read_register(intelhaddata, AUD_HDMI_STATUS_v2,
+ 		had_read_register(intelhaddata, AUD_HDMI_STATUS,
  				  &hdmi_status);
 -		dev_dbg(intelhaddata->dev, "HDMI status =0x%x\n", hdmi_status);
 +		pr_debug("HDMI status =0x%x\n", hdmi_status);
  		if (hdmi_status & AUD_CONFIG_MASK_UNDERRUN) {
  			i++;
  			had_write_register(intelhaddata,
@@@ -1575,62 -1807,197 +1604,165 @@@ static struct snd_kcontrol_new had_cont
  	.put =          had_iec958_put
  };
  
++<<<<<<< HEAD
++=======
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad *ctx = dev_id;
+ 	u32 audio_stat, audio_reg;
+ 
+ 	audio_reg = AUD_HDMI_STATUS;
+ 	mid_hdmi_audio_read(ctx, audio_reg, &audio_stat);
+ 
+ 	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_UNDERRUN);
+ 		had_process_buffer_underrun(ctx);
+ 	}
+ 
+ 	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_BUFFER_DONE);
+ 		had_process_buffer_done(ctx);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
+ 
+ 	schedule_work(&ctx->hdmi_audio_wq);
+ }
+ 
+ static void had_audio_wq(struct work_struct *work)
+ {
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 
+ 	if (!pdata->hdmi_connected) {
+ 		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 
+ 		if (ctx->state != hdmi_connector_status_connected) {
+ 			dev_dbg(ctx->dev, "%s: Already Unplugged!\n",
+ 				__func__);
+ 			return;
+ 		}
+ 
+ 		ctx->state = hdmi_connector_status_disconnected;
+ 		had_process_hot_unplug(ctx);
+ 
+ 	} else {
+ 		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
+ 
+ 		switch (eld->pipe_id) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(ctx->dev, "Invalid pipe %d\n",
+ 				eld->pipe_id);
+ 			break;
+ 		}
+ 
+ 		memcpy(&ctx->eld, eld->eld_data, sizeof(ctx->eld));
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		ctx->state = hdmi_connector_status_connected;
+ 
+ 		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, eld->port_id,	pdata->tmds_clock_speed);
+ 
+ 		if (pdata->tmds_clock_speed) {
+ 			ctx->tmds_clock_speed = pdata->tmds_clock_speed;
+ 			ctx->dp_output = pdata->dp_output;
+ 			ctx->link_rate = pdata->link_rate;
+ 
+ 			/* Process mode change if stream is active */
+ 			if (ctx->stream_data.stream_type == HAD_RUNNING_STREAM)
+ 				hdmi_audio_mode_change(ctx);
+ 		}
+ 	}
+ }
+ 
+ /* release resources */
+ static void hdmi_lpe_audio_free(struct snd_card *card)
+ {
+ 	struct snd_intelhad *ctx = card->private_data;
+ 
+ 	cancel_work_sync(&ctx->hdmi_audio_wq);
+ 
+ 	if (ctx->mmio_start)
+ 		iounmap(ctx->mmio_start);
+ 	if (ctx->irq >= 0)
+ 		free_irq(ctx->irq, ctx);
+ }
+ 
++>>>>>>> 4151ee845ad8 (ALSA: x86: Remove _v[12] suffices)
  /*
 - * hdmi_lpe_audio_probe - start bridge with i915
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
 + *
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
 -	struct snd_card *card;
 -	struct snd_intelhad *ctx;
 +	int retval;
  	struct snd_pcm *pcm;
 -	struct intel_hdmi_lpe_audio_pdata *pdata;
 -	int irq;
 -	struct resource *res_mmio;
 -	int ret;
 -	unsigned long flags;
 -
 -	dev_dbg(&pdev->dev, "dma_mask: %p\n", pdev->dev.dma_mask);
 -
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	pr_debug("Enter %s\n", __func__);
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	/* create a card instance with ALSA framework */
 -	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
 -			   THIS_MODULE, sizeof(*ctx), &card);
 -	if (ret)
 -		return ret;
 -
 -	ctx = card->private_data;
 -	spin_lock_init(&ctx->had_spinlock);
 -	ctx->drv_status = HAD_DRV_DISCONNECTED;
 -	ctx->dev = &pdev->dev;
 -	ctx->card = card;
 -	ctx->flag_underrun = false;
 -	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 -	strcpy(card->driver, INTEL_HAD);
 -	strcpy(card->shortname, INTEL_HAD);
 -
 -	ctx->irq = -1;
 -	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
 -	INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
 -	ctx->state = hdmi_connector_status_disconnected;
 -
 -	card->private_free = hdmi_lpe_audio_free;
 -
 -	/* assume pipe A as default */
 -	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -
 -	platform_set_drvdata(pdev, ctx);
 -
 -	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
 -		__func__, (unsigned int)res_mmio->start,
 -		(unsigned int)res_mmio->end);
 -
 -	ctx->mmio_start = ioremap_nocache(res_mmio->start,
 -					  (size_t)(resource_size(res_mmio)));
 -	if (!ctx->mmio_start) {
 -		dev_err(&pdev->dev, "Could not get ioremap\n");
 -		ret = -EACCES;
 -		goto err;
 -	}
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
  
 -	/* setup interrupt handler */
 -	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
 -			  pdev->name, ctx);
 -	if (ret < 0) {
 -		dev_err(&pdev->dev, "request_irq failed\n");
 -		goto err;
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 -	ctx->irq = irq;
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
  
 -	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 -			  MAX_CAP_STREAMS, &pcm);
 -	if (ret)
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
 +
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
* Unmerged path sound/x86/intel_hdmi_audio.c
diff --git a/sound/x86/intel_hdmi_audio.h b/sound/x86/intel_hdmi_audio.h
index 32a2fb766e47..a169dd4c292b 100644
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@ -71,7 +71,7 @@ struct platform_device;
 #define LAYOUT0			0
 #define LAYOUT1			1
 #define SWAP_LFE_CENTER		0x00fac4c8
-#define AUD_CONFIG_CH_MASK_V2	0x70
+#define AUD_CONFIG_CH_MASK	0x70
 
 struct pcm_stream_info {
 	int		str_id;
diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57..2066aad400ba 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -276,7 +276,7 @@ enum hdmi_ctrl_reg_offset_common {
 	AUDIO_HDMI_CONFIG_C = 0x900,
 };
 /* HDMI controller register offsets */
-enum hdmi_ctrl_reg_offset_v1 {
+enum hdmi_ctrl_reg_offset {
 	AUD_CONFIG		= 0x0,
 	AUD_CH_STATUS_0		= 0x08,
 	AUD_CH_STATUS_1		= 0x0C,
@@ -294,18 +294,8 @@ enum hdmi_ctrl_reg_offset_v1 {
 	AUD_BUF_D_ADDR		= 0x58,
 	AUD_BUF_D_LENGTH	= 0x5c,
 	AUD_CNTL_ST		= 0x60,
-	AUD_HDMI_STATUS		= 0x68,
-	AUD_HDMIW_INFOFR	= 0x114,
-};
-
-/*
- * Delta changes in HDMI controller register offsets
- * compare to v1 version
- */
-
-enum hdmi_ctrl_reg_offset_v2 {
-	AUD_HDMI_STATUS_v2	= 0x64,
-	AUD_HDMIW_INFOFR_v2	= 0x68,
+	AUD_HDMI_STATUS		= 0x64, /* v2 */
+	AUD_HDMIW_INFOFR	= 0x68, /* v2 */
 };
 
 /*
@@ -373,7 +363,7 @@ union aud_cfg {
 		u32 bogus_sample:1;
 		u32 dp_modei:1;
 		u32 rsvd:16;
-	} cfg_regx_v2;
+	} cfg_regx;
 	u32 cfg_regval;
 };
 
@@ -429,7 +419,7 @@ union aud_hdmi_cts {
 		u32 cts_val:24;
 		u32 en_cts_prog:1;
 		u32 rsvd:7;
-	} cts_regx_v2;
+	} cts_regx;
 	u32 cts_regval;
 };
 
@@ -445,7 +435,7 @@ union aud_hdmi_n_enable {
 		u32 n_val:24;
 		u32 en_n_prog:1;
 		u32 rsvd:7;
-	} n_regx_v2;
+	} n_regx;
 	u32 n_regval;
 };
 
@@ -463,7 +453,7 @@ union aud_buf_config {
 		u32 rsvd0:5;
 		u32 aud_delay:8;
 		u32 rsvd1:8;
-	} buf_cfg_regx_v2;
+	} buf_cfg_regx;
 	u32 buf_cfgval;
 };
 
