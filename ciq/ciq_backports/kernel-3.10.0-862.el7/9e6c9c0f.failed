i40e: Fix state flags for bit set and clean operations of PF

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mauro S. M. Rodrigues <maurosr@linux.vnet.ibm.com>
commit 9e6c9c0f2ce67534fda1fdd305fb5da3defece3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9e6c9c0f.failed

Commit 0da36b9774cc ("i40e: use DECLARE_BITMAP for state fields")
introduced changes in the way i40e works with state flags converting
them to bitmaps using kernel bitmap API. This change introduced a
regression due to a mistaken substitution using __I40E_VSI_DOWN instead
of __I40E_DOWN when testing state of a PF at i40e_reset_subtask()
function. This caused a flood in the kernel log with the follow message:

[49.013] i40e 0002:01:00.0: bad reset request 0x00000020

Commit d19cb64b9222 ("i40e: separate PF and VSI state flags")
also introduced some misuse of the VSI and PF flags, so both could be
considered as the offenders.

This patch simply fixes the flags where it makes sense by changing
__I40E_VSI_DOWN to __I40E_DOWN.

Fixes: 0da36b9774cc ("i40e: use DECLARE_BITMAP for state fields")
Fixes: d19cb64b9222 ("i40e: separate PF and VSI state flags")

	Reviewed-by: "Guilherme G. Piccoli" <gpiccoli@linux.vnet.ibm.com>
	Signed-off-by: "Mauro S. M. Rodrigues" <maurosr@linux.vnet.ibm.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 9e6c9c0f2ce67534fda1fdd305fb5da3defece3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index f0ba3da9c566,150caf6ca2b4..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -286,8 -295,8 +286,13 @@@ struct i40e_vsi *i40e_find_vsi_from_id(
   **/
  void i40e_service_event_schedule(struct i40e_pf *pf)
  {
++<<<<<<< HEAD
 +	if (!test_bit(__I40E_DOWN, &pf->state) &&
 +	    !test_bit(__I40E_RESET_RECOVERY_PENDING, &pf->state))
++=======
+ 	if (!test_bit(__I40E_DOWN, pf->state) &&
+ 	    !test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		queue_work(i40e_wq, &pf->service_task);
  }
  
@@@ -3701,7 -3611,7 +3706,11 @@@ static irqreturn_t i40e_intr(int irq, v
  		 * this is not a performance path and napi_schedule()
  		 * can deal with rescheduling.
  		 */
++<<<<<<< HEAD
 +		if (!test_bit(__I40E_DOWN, &pf->state))
++=======
+ 		if (!test_bit(__I40E_DOWN, pf->state))
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  			napi_schedule_irqoff(&q_vector->napi);
  	}
  
@@@ -3777,7 -3687,7 +3786,11 @@@
  enable_intr:
  	/* re-enable interrupt causes */
  	wr32(hw, I40E_PFINT_ICR0_ENA, ena_mask);
++<<<<<<< HEAD
 +	if (!test_bit(__I40E_DOWN, &pf->state)) {
++=======
+ 	if (!test_bit(__I40E_DOWN, pf->state)) {
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		i40e_service_event_schedule(pf);
  		i40e_irq_dynamic_enable_icr0(pf, false);
  	}
@@@ -6292,10 -6203,10 +6305,14 @@@ static void i40e_fdir_reinit_subtask(st
  {
  
  	/* if interface is down do nothing */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &pf->state))
++=======
+ 	if (test_bit(__I40E_DOWN, pf->state))
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		return;
  
 -	if (test_bit(__I40E_FD_FLUSH_REQUESTED, pf->state))
 +	if (test_bit(__I40E_FD_FLUSH_REQUESTED, &pf->state))
  		i40e_fdir_flush_and_replay(pf);
  
  	i40e_fdir_check_and_reenable(pf);
@@@ -6436,8 -6344,8 +6453,13 @@@ static void i40e_watchdog_subtask(struc
  	int i;
  
  	/* if interface is down do nothing */
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN, &pf->state) ||
 +	    test_bit(__I40E_CONFIG_BUSY, &pf->state))
++=======
+ 	if (test_bit(__I40E_DOWN, pf->state) ||
+ 	    test_bit(__I40E_CONFIG_BUSY, pf->state))
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		return;
  
  	/* make sure we don't do these things too often */
@@@ -6476,26 -6383,25 +6498,32 @@@ static void i40e_reset_subtask(struct i
  {
  	u32 reset_flags = 0;
  
 -	if (test_bit(__I40E_REINIT_REQUESTED, pf->state)) {
 +	rtnl_lock();
 +	if (test_bit(__I40E_REINIT_REQUESTED, &pf->state)) {
  		reset_flags |= BIT(__I40E_REINIT_REQUESTED);
 -		clear_bit(__I40E_REINIT_REQUESTED, pf->state);
 +		clear_bit(__I40E_REINIT_REQUESTED, &pf->state);
  	}
 -	if (test_bit(__I40E_PF_RESET_REQUESTED, pf->state)) {
 +	if (test_bit(__I40E_PF_RESET_REQUESTED, &pf->state)) {
  		reset_flags |= BIT(__I40E_PF_RESET_REQUESTED);
 -		clear_bit(__I40E_PF_RESET_REQUESTED, pf->state);
 +		clear_bit(__I40E_PF_RESET_REQUESTED, &pf->state);
  	}
 -	if (test_bit(__I40E_CORE_RESET_REQUESTED, pf->state)) {
 +	if (test_bit(__I40E_CORE_RESET_REQUESTED, &pf->state)) {
  		reset_flags |= BIT(__I40E_CORE_RESET_REQUESTED);
 -		clear_bit(__I40E_CORE_RESET_REQUESTED, pf->state);
 +		clear_bit(__I40E_CORE_RESET_REQUESTED, &pf->state);
  	}
 -	if (test_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state)) {
 +	if (test_bit(__I40E_GLOBAL_RESET_REQUESTED, &pf->state)) {
  		reset_flags |= BIT(__I40E_GLOBAL_RESET_REQUESTED);
 -		clear_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state);
 +		clear_bit(__I40E_GLOBAL_RESET_REQUESTED, &pf->state);
  	}
++<<<<<<< HEAD
 +	if (test_bit(__I40E_DOWN_REQUESTED, &pf->state)) {
 +		reset_flags |= BIT(__I40E_DOWN_REQUESTED);
 +		clear_bit(__I40E_DOWN_REQUESTED, &pf->state);
++=======
+ 	if (test_bit(__I40E_DOWN_REQUESTED, pf->state)) {
+ 		reset_flags |= BIT(__I40E_DOWN_REQUESTED);
+ 		clear_bit(__I40E_DOWN_REQUESTED, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  	}
  
  	/* If there's a recovery already waiting, it takes
@@@ -6508,12 -6415,12 +6536,21 @@@
  
  	/* If we're already down or resetting, just bail */
  	if (reset_flags &&
++<<<<<<< HEAD
 +	    !test_bit(__I40E_DOWN, &pf->state) &&
 +	    !test_bit(__I40E_CONFIG_BUSY, &pf->state))
 +		i40e_do_reset(pf, reset_flags);
 +
 +unlock:
 +	rtnl_unlock();
++=======
+ 	    !test_bit(__I40E_DOWN, pf->state) &&
+ 	    !test_bit(__I40E_CONFIG_BUSY, pf->state)) {
+ 		rtnl_lock();
+ 		i40e_do_reset(pf, reset_flags, true);
+ 		rtnl_unlock();
+ 	}
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  }
  
  /**
@@@ -7054,31 -6968,41 +7091,35 @@@ static void i40e_send_version(struct i4
  }
  
  /**
 - * i40e_reset - wait for core reset to finish reset, reset pf if corer not seen
 + * i40e_reset_and_rebuild - reset and rebuild using a saved config
   * @pf: board private structure
 + * @reinit: if the Main VSI needs to re-initialized.
   **/
 -static int i40e_reset(struct i40e_pf *pf)
 +static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit)
  {
  	struct i40e_hw *hw = &pf->hw;
 +	u8 set_fc_aq_fail = 0;
  	i40e_status ret;
 +	u32 val;
 +	u32 v;
  
++<<<<<<< HEAD
 +	/* Now we wait for GRST to settle out.
 +	 * We don't have to delete the VEBs or VSIs from the hw switch
 +	 * because the reset will make them disappear.
 +	 */
  	ret = i40e_pf_reset(hw);
  	if (ret) {
  		dev_info(&pf->pdev->dev, "PF reset failed, %d\n", ret);
 -		set_bit(__I40E_RESET_FAILED, pf->state);
 -		clear_bit(__I40E_RESET_RECOVERY_PENDING, pf->state);
 -	} else {
 -		pf->pfr_count++;
 +		set_bit(__I40E_RESET_FAILED, &pf->state);
 +		goto clear_recovery;
  	}
 -	return ret;
 -}
 -
 -/**
 - * i40e_rebuild - rebuild using a saved config
 - * @pf: board private structure
 - * @reinit: if the Main VSI needs to re-initialized.
 - * @lock_acquired: indicates whether or not the lock has been acquired
 - * before this function was called.
 - **/
 -static void i40e_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired)
 -{
 -	struct i40e_hw *hw = &pf->hw;
 -	u8 set_fc_aq_fail = 0;
 -	i40e_status ret;
 -	u32 val;
 -	int v;
 +	pf->pfr_count++;
  
 +	if (test_bit(__I40E_DOWN, &pf->state))
++=======
+ 	if (test_bit(__I40E_DOWN, pf->state))
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		goto clear_recovery;
  	dev_dbg(&pf->pdev->dev, "Rebuilding internal switch\n");
  
@@@ -9881,7 -9767,7 +9922,11 @@@ int i40e_vsi_release(struct i40e_vsi *v
  		return -ENODEV;
  	}
  	if (vsi == pf->vsi[pf->lan_vsi] &&
++<<<<<<< HEAD
 +	    !test_bit(__I40E_DOWN, &pf->state)) {
++=======
+ 	    !test_bit(__I40E_DOWN, pf->state)) {
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		dev_info(&pf->pdev->dev, "Can't remove PF VSI\n");
  		return -ENODEV;
  	}
@@@ -11150,7 -11003,7 +11195,11 @@@ static int i40e_probe(struct pci_dev *p
  	}
  	pf->next_vsi = 0;
  	pf->pdev = pdev;
++<<<<<<< HEAD
 +	set_bit(__I40E_DOWN, &pf->state);
++=======
+ 	set_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  
  	hw = &pf->hw;
  	hw->back = pf;
@@@ -11454,7 -11293,7 +11503,11 @@@
  	 * before setting up the misc vector or we get a race and the vector
  	 * ends up disabled forever.
  	 */
++<<<<<<< HEAD
 +	clear_bit(__I40E_DOWN, &pf->state);
++=======
+ 	clear_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  
  	/* In case of MSIX we are going to setup the misc vector right here
  	 * to handle admin queue events etc. In case of legacy and MSI
@@@ -11614,7 -11448,7 +11667,11 @@@
  
  	/* Unwind what we've done if something failed in the setup */
  err_vsis:
++<<<<<<< HEAD
 +	set_bit(__I40E_DOWN, &pf->state);
++=======
+ 	set_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  	i40e_clear_interrupt_scheme(pf);
  	kfree(pf->vsi);
  err_switch_setup:
@@@ -11665,8 -11499,8 +11722,13 @@@ static void i40e_remove(struct pci_dev 
  	i40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), 0);
  
  	/* no more scheduling of any task */
++<<<<<<< HEAD
 +	set_bit(__I40E_SUSPENDED, &pf->state);
 +	set_bit(__I40E_DOWN, &pf->state);
++=======
+ 	set_bit(__I40E_SUSPENDED, pf->state);
+ 	set_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  	if (pf->service_timer.data)
  		del_timer_sync(&pf->service_timer);
  	if (pf->service_task.func)
@@@ -11905,10 -11739,10 +11967,15 @@@ static void i40e_shutdown(struct pci_de
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
  	struct i40e_hw *hw = &pf->hw;
  
++<<<<<<< HEAD
 +	set_bit(__I40E_SUSPENDED, &pf->state);
 +	set_bit(__I40E_DOWN, &pf->state);
++=======
+ 	set_bit(__I40E_SUSPENDED, pf->state);
+ 	set_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  	rtnl_lock();
 -	i40e_prep_for_reset(pf, true);
 +	i40e_prep_for_reset(pf);
  	rtnl_unlock();
  
  	wr32(hw, I40E_PFPM_APM, (pf->wol_en ? I40E_PFPM_APM_APME_MASK : 0));
@@@ -11954,8 -11788,8 +12021,13 @@@ static int i40e_suspend(struct pci_dev 
  	struct i40e_hw *hw = &pf->hw;
  	int retval = 0;
  
++<<<<<<< HEAD
 +	set_bit(__I40E_SUSPENDED, &pf->state);
 +	set_bit(__I40E_DOWN, &pf->state);
++=======
+ 	set_bit(__I40E_SUSPENDED, pf->state);
+ 	set_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  
  	if (pf->wol_en && (pf->flags & I40E_FLAG_WOL_MC_MAGIC_PKT_WAKE))
  		i40e_enable_mc_magic_wake(pf);
@@@ -12006,10 -11840,10 +12078,15 @@@ static int i40e_resume(struct pci_dev *
  	pci_wake_from_d3(pdev, false);
  
  	/* handling the reset will rebuild the device state */
++<<<<<<< HEAD
 +	if (test_and_clear_bit(__I40E_SUSPENDED, &pf->state)) {
 +		clear_bit(__I40E_DOWN, &pf->state);
++=======
+ 	if (test_and_clear_bit(__I40E_SUSPENDED, pf->state)) {
+ 		clear_bit(__I40E_DOWN, pf->state);
++>>>>>>> 9e6c9c0f2ce6 (i40e: Fix state flags for bit set and clean operations of PF)
  		rtnl_lock();
 -		i40e_reset_and_rebuild(pf, false, true);
 +		i40e_reset_and_rebuild(pf, false);
  		rtnl_unlock();
  	}
  
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
