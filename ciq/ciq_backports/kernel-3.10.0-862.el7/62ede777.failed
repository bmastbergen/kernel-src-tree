Add OPA extended LID support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hiatt, Don <don.hiatt@intel.com>
commit 62ede7779904bc75bdd84f1ff0016113956ce3b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/62ede777.failed

This patch series primarily increases sizes of variables that hold
lid values from 16 to 32 bits. Additionally, it adds a check in
the IB mad stack to verify a properly formatted MAD when OPA
extended LIDs are used.

	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 62ede7779904bc75bdd84f1ff0016113956ce3b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cm.c
#	drivers/infiniband/core/user_mad.c
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/hw/hfi1/mad.c
#	drivers/infiniband/hw/mlx4/alias_GUID.c
#	drivers/infiniband/hw/mlx4/mad.c
#	drivers/infiniband/hw/mlx5/mad.c
#	drivers/infiniband/hw/mthca/mthca_cmd.c
#	drivers/infiniband/hw/mthca/mthca_mad.c
#	drivers/infiniband/sw/rdmavt/cq.c
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/cm.c
index ea27dc1ae666,fa3b0a428195..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -1696,7 -1770,7 +1696,11 @@@ static void cm_process_routed_req(struc
  {
  	if (!cm_req_get_primary_subnet_local(req_msg)) {
  		if (req_msg->primary_local_lid == IB_LID_PERMISSIVE) {
++<<<<<<< HEAD
 +			req_msg->primary_local_lid = cpu_to_be16(wc->slid);
++=======
+ 			req_msg->primary_local_lid = ib_lid_be16(wc->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  			cm_req_set_primary_sl(req_msg, wc->sl);
  		}
  
@@@ -1706,7 -1780,7 +1710,11 @@@
  
  	if (!cm_req_get_alt_subnet_local(req_msg)) {
  		if (req_msg->alt_local_lid == IB_LID_PERMISSIVE) {
++<<<<<<< HEAD
 +			req_msg->alt_local_lid = cpu_to_be16(wc->slid);
++=======
+ 			req_msg->alt_local_lid = ib_lid_be16(wc->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  			cm_req_set_alt_sl(req_msg, wc->sl);
  		}
  
diff --cc drivers/infiniband/core/user_mad.c
index 7241acee2674,c1696e6084b2..000000000000
--- a/drivers/infiniband/core/user_mad.c
+++ b/drivers/infiniband/core/user_mad.c
@@@ -229,7 -229,7 +229,11 @@@ static void recv_handler(struct ib_mad_
  	packet->mad.hdr.status	   = 0;
  	packet->mad.hdr.length	   = hdr_size(file) + mad_recv_wc->mad_len;
  	packet->mad.hdr.qpn	   = cpu_to_be32(mad_recv_wc->wc->src_qp);
++<<<<<<< HEAD
 +	packet->mad.hdr.lid	   = cpu_to_be16(mad_recv_wc->wc->slid);
++=======
+ 	packet->mad.hdr.lid	   = ib_lid_be16(mad_recv_wc->wc->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	packet->mad.hdr.sl	   = mad_recv_wc->wc->sl;
  	packet->mad.hdr.path_bits  = mad_recv_wc->wc->dlid_path_bits;
  	packet->mad.hdr.pkey_index = mad_recv_wc->wc->pkey_index;
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 4761b0709900,a21881e22bad..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -514,8 -275,14 +514,19 @@@ ssize_t ib_uverbs_query_port(struct ib_
  	resp.bad_pkey_cntr   = attr.bad_pkey_cntr;
  	resp.qkey_viol_cntr  = attr.qkey_viol_cntr;
  	resp.pkey_tbl_len    = attr.pkey_tbl_len;
++<<<<<<< HEAD
 +	resp.lid 	     = attr.lid;
 +	resp.sm_lid 	     = attr.sm_lid;
++=======
+ 
+ 	if (rdma_cap_opa_ah(ib_dev, cmd.port_num)) {
+ 		resp.lid     = OPA_TO_IB_UCAST_LID(attr.lid);
+ 		resp.sm_lid  = OPA_TO_IB_UCAST_LID(attr.sm_lid);
+ 	} else {
+ 		resp.lid     = ib_lid_cpu16(attr.lid);
+ 		resp.sm_lid  = ib_lid_cpu16(attr.sm_lid);
+ 	}
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	resp.lmc 	     = attr.lmc;
  	resp.max_vl_num      = attr.max_vl_num;
  	resp.sm_sl 	     = attr.sm_sl;
@@@ -1613,7 -1206,10 +1624,14 @@@ static int copy_wc_to_user(void __user 
  	tmp.src_qp		= wc->src_qp;
  	tmp.wc_flags		= wc->wc_flags;
  	tmp.pkey_index		= wc->pkey_index;
++<<<<<<< HEAD
 +	tmp.slid		= wc->slid;
++=======
+ 	if (rdma_cap_opa_ah(ib_dev, wc->port_num))
+ 		tmp.slid	= OPA_TO_IB_UCAST_LID(wc->slid);
+ 	else
+ 		tmp.slid	= ib_lid_cpu16(wc->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	tmp.sl			= wc->sl;
  	tmp.dlid_path_bits	= wc->dlid_path_bits;
  	tmp.port_num		= wc->port_num;
diff --cc drivers/infiniband/hw/hfi1/mad.c
index d59426fb9866,11be4d19e607..000000000000
--- a/drivers/infiniband/hw/hfi1/mad.c
+++ b/drivers/infiniband/hw/hfi1/mad.c
@@@ -4026,7 -4216,7 +4026,11 @@@ static int opa_local_smp_check(struct h
  			       const struct ib_wc *in_wc)
  {
  	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
++<<<<<<< HEAD
 +	u16 slid = in_wc->slid;
++=======
+ 	u16 slid = ib_lid_cpu16(in_wc->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	u16 pkey;
  
  	if (in_wc->pkey_index >= ARRAY_SIZE(ppd->pkeys))
diff --cc drivers/infiniband/hw/mlx4/alias_GUID.c
index 06020c54db20,0e4f60cfc59d..000000000000
--- a/drivers/infiniband/hw/mlx4/alias_GUID.c
+++ b/drivers/infiniband/hw/mlx4/alias_GUID.c
@@@ -527,7 -528,7 +527,11 @@@ static int set_guid_rec(struct ib_devic
  
  	memset(&guid_info_rec, 0, sizeof (struct ib_sa_guidinfo_rec));
  
++<<<<<<< HEAD
 +	guid_info_rec.lid = cpu_to_be16(attr.lid);
++=======
+ 	guid_info_rec.lid = ib_lid_be16(attr.lid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	guid_info_rec.block_num = index;
  
  	memcpy(guid_info_rec.guid_info_list, rec_det->all_recs,
diff --cc drivers/infiniband/hw/mlx4/mad.c
index caa3f0bb11f1,0793a21d76f4..000000000000
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@@ -169,7 -169,7 +169,11 @@@ int mlx4_MAD_IFC(struct mlx4_ib_dev *de
  
  		op_modifier |= 0x4;
  
++<<<<<<< HEAD
 +		in_modifier |= in_wc->slid << 16;
++=======
+ 		in_modifier |= ib_lid_cpu16(in_wc->slid) << 16;
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	}
  
  	err = mlx4_cmd_box(dev->dev, inmailbox->dma, outmailbox->dma, in_modifier,
@@@ -621,7 -625,7 +625,11 @@@ int mlx4_ib_send_to_slave(struct mlx4_i
  		memcpy((char *)&tun_mad->hdr.slid_mac_47_32, &(wc->smac[4]), 2);
  	} else {
  		tun_mad->hdr.sl_vid = cpu_to_be16(((u16)(wc->sl)) << 12);
++<<<<<<< HEAD
 +		tun_mad->hdr.slid_mac_47_32 = cpu_to_be16(wc->slid);
++=======
+ 		tun_mad->hdr.slid_mac_47_32 = ib_lid_be16(wc->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	}
  
  	ib_dma_sync_single_for_device(&dev->ib_dev,
@@@ -822,7 -826,7 +830,11 @@@ static int ib_process_mad(struct ib_dev
  		}
  	}
  
++<<<<<<< HEAD
 +	slid = in_wc ? in_wc->slid : be16_to_cpu(IB_LID_PERMISSIVE);
++=======
+ 	slid = in_wc ? ib_lid_cpu16(in_wc->slid) : be16_to_cpu(IB_LID_PERMISSIVE);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  
  	if (in_mad->mad_hdr.method == IB_MGMT_METHOD_TRAP && slid == 0) {
  		forward_trap(to_mdev(ibdev), port_num, in_mad);
@@@ -856,7 -860,7 +868,11 @@@
  	    in_mad->mad_hdr.method == IB_MGMT_METHOD_SET &&
  	    in_mad->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO &&
  	    !ib_query_port(ibdev, port_num, &pattr))
++<<<<<<< HEAD
 +		prev_lid = pattr.lid;
++=======
+ 		prev_lid = ib_lid_cpu16(pattr.lid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  
  	err = mlx4_MAD_IFC(to_mdev(ibdev),
  			   (mad_flags & IB_MAD_IGNORE_MKEY ? MLX4_MAD_IFC_IGNORE_MKEY : 0) |
diff --cc drivers/infiniband/hw/mlx5/mad.c
index 57d77c97c8c4,18cfe5bf0fa3..000000000000
--- a/drivers/infiniband/hw/mlx5/mad.c
+++ b/drivers/infiniband/hw/mlx5/mad.c
@@@ -78,7 -78,7 +78,11 @@@ static int process_mad(struct ib_devic
  	u16 slid;
  	int err;
  
++<<<<<<< HEAD
 +	slid = in_wc ? in_wc->slid : be16_to_cpu(IB_LID_PERMISSIVE);
++=======
+ 	slid = in_wc ? ib_lid_cpu16(in_wc->slid) : be16_to_cpu(IB_LID_PERMISSIVE);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  
  	if (in_mad->mad_hdr.method == IB_MGMT_METHOD_TRAP && slid == 0)
  		return IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;
diff --cc drivers/infiniband/hw/mthca/mthca_cmd.c
index 9d83a53c0c67,d0f062fc2a4b..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_cmd.c
+++ b/drivers/infiniband/hw/mthca/mthca_cmd.c
@@@ -1921,7 -1921,7 +1921,11 @@@ int mthca_MAD_IFC(struct mthca_dev *dev
  			(in_wc->wc_flags & IB_WC_GRH ? 0x80 : 0);
  		MTHCA_PUT(inbox, val,               MAD_IFC_G_PATH_OFFSET);
  
++<<<<<<< HEAD
 +		MTHCA_PUT(inbox, in_wc->slid,       MAD_IFC_RLID_OFFSET);
++=======
+ 		MTHCA_PUT(inbox, ib_lid_cpu16(in_wc->slid), MAD_IFC_RLID_OFFSET);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  		MTHCA_PUT(inbox, in_wc->pkey_index, MAD_IFC_PKEY_OFFSET);
  
  		if (in_grh)
@@@ -1929,7 -1929,7 +1933,11 @@@
  
  		op_modifier |= 0x4;
  
++<<<<<<< HEAD
 +		in_modifier |= in_wc->slid << 16;
++=======
+ 		in_modifier |= ib_lid_cpu16(in_wc->slid) << 16;
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	}
  
  	err = mthca_cmd_box(dev, inmailbox->dma, outmailbox->dma,
diff --cc drivers/infiniband/hw/mthca/mthca_mad.c
index 9139405c4810,093f7755c843..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_mad.c
+++ b/drivers/infiniband/hw/mthca/mthca_mad.c
@@@ -204,7 -205,7 +204,11 @@@ int mthca_process_mad(struct ib_device 
  		      u16 *out_mad_pkey_index)
  {
  	int err;
++<<<<<<< HEAD
 +	u16 slid = in_wc ? in_wc->slid : be16_to_cpu(IB_LID_PERMISSIVE);
++=======
+ 	u16 slid = in_wc ? ib_lid_cpu16(in_wc->slid) : be16_to_cpu(IB_LID_PERMISSIVE);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  	u16 prev_lid = 0;
  	struct ib_port_attr pattr;
  	const struct ib_mad *in_mad = (const struct ib_mad *)in;
@@@ -255,7 -256,7 +259,11 @@@
  	    in_mad->mad_hdr.method == IB_MGMT_METHOD_SET &&
  	    in_mad->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO &&
  	    !ib_query_port(ibdev, port_num, &pattr))
++<<<<<<< HEAD
 +		prev_lid = pattr.lid;
++=======
+ 		prev_lid = ib_lid_cpu16(pattr.lid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  
  	err = mthca_MAD_IFC(to_mdev(ibdev),
  			    mad_flags & IB_MAD_IGNORE_MKEY,
diff --cc drivers/infiniband/sw/rdmavt/cq.c
index de39ada79f77,97d71e49c092..000000000000
--- a/drivers/infiniband/sw/rdmavt/cq.c
+++ b/drivers/infiniband/sw/rdmavt/cq.c
@@@ -107,7 -107,7 +107,11 @@@ void rvt_cq_enter(struct rvt_cq *cq, st
  		wc->uqueue[head].src_qp = entry->src_qp;
  		wc->uqueue[head].wc_flags = entry->wc_flags;
  		wc->uqueue[head].pkey_index = entry->pkey_index;
++<<<<<<< HEAD
 +		wc->uqueue[head].slid = entry->slid;
++=======
+ 		wc->uqueue[head].slid = ib_lid_cpu16(entry->slid);
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  		wc->uqueue[head].sl = entry->sl;
  		wc->uqueue[head].dlid_path_bits = entry->dlid_path_bits;
  		wc->uqueue[head].port_num = entry->port_num;
diff --cc include/rdma/ib_verbs.h
index 9d98b1e7b1da,70a183179224..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -3510,5 -3570,205 +3510,209 @@@ void ib_drain_sq(struct ib_qp *qp)
  void ib_drain_qp(struct ib_qp *qp);
  
  int ib_resolve_eth_dmac(struct ib_device *device,
++<<<<<<< HEAD
 +			struct ib_ah_attr *ah_attr);
++=======
+ 			struct rdma_ah_attr *ah_attr);
+ int ib_get_eth_speed(struct ib_device *dev, u8 port_num, u8 *speed, u8 *width);
+ 
+ static inline u8 *rdma_ah_retrieve_dmac(struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_ROCE)
+ 		return attr->roce.dmac;
+ 	return NULL;
+ }
+ 
+ static inline void rdma_ah_set_dlid(struct rdma_ah_attr *attr, u32 dlid)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		attr->ib.dlid = (u16)dlid;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		attr->opa.dlid = dlid;
+ }
+ 
+ static inline u32 rdma_ah_get_dlid(const struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		return attr->ib.dlid;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		return attr->opa.dlid;
+ 	return 0;
+ }
+ 
+ static inline void rdma_ah_set_sl(struct rdma_ah_attr *attr, u8 sl)
+ {
+ 	attr->sl = sl;
+ }
+ 
+ static inline u8 rdma_ah_get_sl(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->sl;
+ }
+ 
+ static inline void rdma_ah_set_path_bits(struct rdma_ah_attr *attr,
+ 					 u8 src_path_bits)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		attr->ib.src_path_bits = src_path_bits;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		attr->opa.src_path_bits = src_path_bits;
+ }
+ 
+ static inline u8 rdma_ah_get_path_bits(const struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		return attr->ib.src_path_bits;
+ 	else if (attr->type == RDMA_AH_ATTR_TYPE_OPA)
+ 		return attr->opa.src_path_bits;
+ 	return 0;
+ }
+ 
+ static inline void rdma_ah_set_port_num(struct rdma_ah_attr *attr, u8 port_num)
+ {
+ 	attr->port_num = port_num;
+ }
+ 
+ static inline u8 rdma_ah_get_port_num(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->port_num;
+ }
+ 
+ static inline void rdma_ah_set_static_rate(struct rdma_ah_attr *attr,
+ 					   u8 static_rate)
+ {
+ 	attr->static_rate = static_rate;
+ }
+ 
+ static inline u8 rdma_ah_get_static_rate(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->static_rate;
+ }
+ 
+ static inline void rdma_ah_set_ah_flags(struct rdma_ah_attr *attr,
+ 					enum ib_ah_flags flag)
+ {
+ 	attr->ah_flags = flag;
+ }
+ 
+ static inline enum ib_ah_flags
+ 		rdma_ah_get_ah_flags(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->ah_flags;
+ }
+ 
+ static inline const struct ib_global_route
+ 		*rdma_ah_read_grh(const struct rdma_ah_attr *attr)
+ {
+ 	return &attr->grh;
+ }
+ 
+ /*To retrieve and modify the grh */
+ static inline struct ib_global_route
+ 		*rdma_ah_retrieve_grh(struct rdma_ah_attr *attr)
+ {
+ 	return &attr->grh;
+ }
+ 
+ static inline void rdma_ah_set_dgid_raw(struct rdma_ah_attr *attr, void *dgid)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	memcpy(grh->dgid.raw, dgid, sizeof(grh->dgid));
+ }
+ 
+ static inline void rdma_ah_set_subnet_prefix(struct rdma_ah_attr *attr,
+ 					     __be64 prefix)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	grh->dgid.global.subnet_prefix = prefix;
+ }
+ 
+ static inline void rdma_ah_set_interface_id(struct rdma_ah_attr *attr,
+ 					    __be64 if_id)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	grh->dgid.global.interface_id = if_id;
+ }
+ 
+ static inline void rdma_ah_set_grh(struct rdma_ah_attr *attr,
+ 				   union ib_gid *dgid, u32 flow_label,
+ 				   u8 sgid_index, u8 hop_limit,
+ 				   u8 traffic_class)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	attr->ah_flags = IB_AH_GRH;
+ 	if (dgid)
+ 		grh->dgid = *dgid;
+ 	grh->flow_label = flow_label;
+ 	grh->sgid_index = sgid_index;
+ 	grh->hop_limit = hop_limit;
+ 	grh->traffic_class = traffic_class;
+ }
+ 
+ /*Get AH type */
+ static inline enum rdma_ah_attr_type rdma_ah_find_type(struct ib_device *dev,
+ 						       u32 port_num)
+ {
+ 	if ((rdma_protocol_roce(dev, port_num)) ||
+ 	    (rdma_protocol_iwarp(dev, port_num)))
+ 		return RDMA_AH_ATTR_TYPE_ROCE;
+ 	else if ((rdma_protocol_ib(dev, port_num)) &&
+ 		 (rdma_cap_opa_ah(dev, port_num)))
+ 		return RDMA_AH_ATTR_TYPE_OPA;
+ 	else
+ 		return RDMA_AH_ATTR_TYPE_IB;
+ }
+ 
+ /**
+  * ib_lid_cpu16 - Return lid in 16bit CPU encoding.
+  *     In the current implementation the only way to get
+  *     get the 32bit lid is from other sources for OPA.
+  *     For IB, lids will always be 16bits so cast the
+  *     value accordingly.
+  *
+  * @lid: A 32bit LID
+  */
+ static inline u16 ib_lid_cpu16(u32 lid)
+ {
+ 	WARN_ON_ONCE(lid & 0xFFFF0000);
+ 	return (u16)lid;
+ }
+ 
+ /**
+  * ib_lid_be16 - Return lid in 16bit BE encoding.
+  *
+  * @lid: A 32bit LID
+  */
+ static inline __be16 ib_lid_be16(u32 lid)
+ {
+ 	WARN_ON_ONCE(lid & 0xFFFF0000);
+ 	return cpu_to_be16((u16)lid);
+ }
+ 
+ /**
+  * ib_get_vector_affinity - Get the affinity mappings of a given completion
+  *   vector
+  * @device:         the rdma device
+  * @comp_vector:    index of completion vector
+  *
+  * Returns NULL on failure, otherwise a corresponding cpu map of the
+  * completion vector (returns all-cpus map if the device driver doesn't
+  * implement get_vector_affinity).
+  */
+ static inline const struct cpumask *
+ ib_get_vector_affinity(struct ib_device *device, int comp_vector)
+ {
+ 	if (comp_vector < 0 || comp_vector >= device->num_comp_vectors ||
+ 	    !device->get_vector_affinity)
+ 		return NULL;
+ 
+ 	return device->get_vector_affinity(device, comp_vector);
+ 
+ }
+ 
++>>>>>>> 62ede7779904 (Add OPA extended LID support)
  #endif /* IB_VERBS_H */
* Unmerged path drivers/infiniband/core/cm.c
* Unmerged path drivers/infiniband/core/user_mad.c
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/hw/hfi1/mad.c
* Unmerged path drivers/infiniband/hw/mlx4/alias_GUID.c
* Unmerged path drivers/infiniband/hw/mlx4/mad.c
* Unmerged path drivers/infiniband/hw/mlx5/mad.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_cmd.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_mad.c
* Unmerged path drivers/infiniband/sw/rdmavt/cq.c
* Unmerged path include/rdma/ib_verbs.h
