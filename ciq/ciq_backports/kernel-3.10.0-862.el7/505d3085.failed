scripts/spelling.txt: add "overide" pattern and fix typo instances

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Masahiro Yamada <yamada.masahiro@socionext.com>
commit 505d3085d7120a9f4cd0d6ffaa876968854b3baa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/505d3085.failed

Fix typos and add the following to the scripts/spelling.txt:

  overide||override

While we are here, fix the doubled "address" in the touched line
Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt.

Also, fix the comment block style in the touched hunks in
drivers/media/dvb-frontends/drx39xyj/drx_driver.h.

Link: http://lkml.kernel.org/r/1481573103-11329-21-git-send-email-yamada.masahiro@socionext.com
	Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 505d3085d7120a9f4cd0d6ffaa876968854b3baa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt
#	drivers/media/dvb-frontends/drx39xyj/drx_driver.h
#	drivers/net/ethernet/qlogic/qlge/qlge.h
#	include/dt-bindings/sound/cs42l42.h
#	kernel/trace/trace_stack.c
#	scripts/spelling.txt
#	tools/lguest/lguest.c
#	tools/lib/bpf/Makefile
diff --cc drivers/net/ethernet/qlogic/qlge/qlge.h
index b6c8e2c3437e,84ac50f92c9c..000000000000
--- a/drivers/net/ethernet/qlogic/qlge/qlge.h
+++ b/drivers/net/ethernet/qlogic/qlge/qlge.h
@@@ -1162,8 -1162,8 +1162,13 @@@ struct ob_mac_tso_iocb_rsp 
  struct ib_mac_iocb_rsp {
  	u8 opcode;		/* 0x20 */
  	u8 flags1;
++<<<<<<< HEAD
 +#define IB_MAC_IOCB_RSP_OI	0x01	/* Overide intr delay */
 +#define IB_MAC_IOCB_RSP_I	0x02	/* Disble Intr Generation */
++=======
+ #define IB_MAC_IOCB_RSP_OI	0x01	/* Override intr delay */
+ #define IB_MAC_IOCB_RSP_I	0x02	/* Disable Intr Generation */
++>>>>>>> 505d3085d712 (scripts/spelling.txt: add "overide" pattern and fix typo instances)
  #define IB_MAC_CSUM_ERR_MASK 0x1c	/* A mask to use for csum errs */
  #define IB_MAC_IOCB_RSP_TE	0x04	/* Checksum error */
  #define IB_MAC_IOCB_RSP_NU	0x08	/* No checksum rcvd */
diff --cc kernel/trace/trace_stack.c
index b20428c5efe2,5fb1f2c87e6b..000000000000
--- a/kernel/trace/trace_stack.c
+++ b/kernel/trace/trace_stack.c
@@@ -50,14 -41,44 +50,49 @@@ static DEFINE_MUTEX(stack_sysctl_mutex)
  int stack_tracer_enabled;
  static int last_stack_tracer_enabled;
  
++<<<<<<< HEAD
 +static inline void
++=======
+ void stack_trace_print(void)
+ {
+ 	long i;
+ 	int size;
+ 
+ 	pr_emerg("        Depth    Size   Location    (%d entries)\n"
+ 			   "        -----    ----   --------\n",
+ 			   stack_trace_max.nr_entries);
+ 
+ 	for (i = 0; i < stack_trace_max.nr_entries; i++) {
+ 		if (stack_dump_trace[i] == ULONG_MAX)
+ 			break;
+ 		if (i+1 == stack_trace_max.nr_entries ||
+ 				stack_dump_trace[i+1] == ULONG_MAX)
+ 			size = stack_trace_index[i];
+ 		else
+ 			size = stack_trace_index[i] - stack_trace_index[i+1];
+ 
+ 		pr_emerg("%3ld) %8d   %5d   %pS\n", i, stack_trace_index[i],
+ 				size, (void *)stack_dump_trace[i]);
+ 	}
+ }
+ 
+ /*
+  * When arch-specific code overrides this function, the following
+  * data should be filled up, assuming stack_trace_max_lock is held to
+  * prevent concurrent updates.
+  *     stack_trace_index[]
+  *     stack_trace_max
+  *     stack_trace_max_size
+  */
+ void __weak
++>>>>>>> 505d3085d712 (scripts/spelling.txt: add "overide" pattern and fix typo instances)
  check_stack(unsigned long ip, unsigned long *stack)
  {
 -	unsigned long this_size, flags; unsigned long *p, *top, *start;
 +	unsigned long this_size, flags;
 +	unsigned long *p, *top, *start;
  	static int tracer_frame;
  	int frame_size = ACCESS_ONCE(tracer_frame);
 -	int i, x;
 +	int i;
  
  	this_size = ((unsigned long)stack) & (THREAD_SIZE-1);
  	this_size = THREAD_SIZE - this_size;
diff --cc tools/lguest/lguest.c
index 07a03452c227,5d19fdf80292..000000000000
--- a/tools/lguest/lguest.c
+++ b/tools/lguest/lguest.c
@@@ -997,10 -1187,663 +997,332 @@@ static void reset_device(struct device 
  	signal(SIGCHLD, (void *)kill_launcher);
  }
  
++<<<<<<< HEAD
++=======
+ static void cleanup_devices(void)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 1; i < MAX_PCI_DEVICES; i++) {
+ 		struct device *d = devices.pci[i];
+ 		if (!d)
+ 			continue;
+ 		reset_device(d);
+ 	}
+ 
+ 	/* If we saved off the original terminal settings, restore them now. */
+ 	if (orig_term.c_lflag & (ISIG|ICANON|ECHO))
+ 		tcsetattr(STDIN_FILENO, TCSANOW, &orig_term);
+ }
+ 
+ /*L:217
+  * We do PCI.  This is mainly done to let us test the kernel virtio PCI
+  * code.
+  */
+ 
+ /* Linux expects a PCI host bridge: ours is a dummy, and first on the bus. */
+ static struct device pci_host_bridge;
+ 
+ static void init_pci_host_bridge(void)
+ {
+ 	pci_host_bridge.name = "PCI Host Bridge";
+ 	pci_host_bridge.config.class = 0x06; /* bridge */
+ 	pci_host_bridge.config.subclass = 0; /* host bridge */
+ 	devices.pci[0] = &pci_host_bridge;
+ }
+ 
+ /* The IO ports used to read the PCI config space. */
+ #define PCI_CONFIG_ADDR 0xCF8
+ #define PCI_CONFIG_DATA 0xCFC
+ 
+ /*
+  * Not really portable, but does help readability: this is what the Guest
+  * writes to the PCI_CONFIG_ADDR IO port.
+  */
+ union pci_config_addr {
+ 	struct {
+ 		unsigned mbz: 2;
+ 		unsigned offset: 6;
+ 		unsigned funcnum: 3;
+ 		unsigned devnum: 5;
+ 		unsigned busnum: 8;
+ 		unsigned reserved: 7;
+ 		unsigned enabled : 1;
+ 	} bits;
+ 	u32 val;
+ };
+ 
+ /*
+  * We cache what they wrote to the address port, so we know what they're
+  * talking about when they access the data port.
+  */
+ static union pci_config_addr pci_config_addr;
+ 
+ static struct device *find_pci_device(unsigned int index)
+ {
+ 	return devices.pci[index];
+ }
+ 
+ /* PCI can do 1, 2 and 4 byte reads; we handle that here. */
+ static void ioread(u16 off, u32 v, u32 mask, u32 *val)
+ {
+ 	assert(off < 4);
+ 	assert(mask == 0xFF || mask == 0xFFFF || mask == 0xFFFFFFFF);
+ 	*val = (v >> (off * 8)) & mask;
+ }
+ 
+ /* PCI can do 1, 2 and 4 byte writes; we handle that here. */
+ static void iowrite(u16 off, u32 v, u32 mask, u32 *dst)
+ {
+ 	assert(off < 4);
+ 	assert(mask == 0xFF || mask == 0xFFFF || mask == 0xFFFFFFFF);
+ 	*dst &= ~(mask << (off * 8));
+ 	*dst |= (v & mask) << (off * 8);
+ }
+ 
+ /*
+  * Where PCI_CONFIG_DATA accesses depends on the previous write to
+  * PCI_CONFIG_ADDR.
+  */
+ static struct device *dev_and_reg(u32 *reg)
+ {
+ 	if (!pci_config_addr.bits.enabled)
+ 		return NULL;
+ 
+ 	if (pci_config_addr.bits.funcnum != 0)
+ 		return NULL;
+ 
+ 	if (pci_config_addr.bits.busnum != 0)
+ 		return NULL;
+ 
+ 	if (pci_config_addr.bits.offset * 4 >= sizeof(struct pci_config))
+ 		return NULL;
+ 
+ 	*reg = pci_config_addr.bits.offset;
+ 	return find_pci_device(pci_config_addr.bits.devnum);
+ }
+ 
+ /*
+  * We can get invalid combinations of values while they're writing, so we
+  * only fault if they try to write with some invalid bar/offset/length.
+  */
+ static bool valid_bar_access(struct device *d,
+ 			     struct virtio_pci_cfg_cap_u32 *cfg_access)
+ {
+ 	/* We only have 1 bar (BAR0) */
+ 	if (cfg_access->cap.bar != 0)
+ 		return false;
+ 
+ 	/* Check it's within BAR0. */
+ 	if (cfg_access->cap.offset >= d->mmio_size
+ 	    || cfg_access->cap.offset + cfg_access->cap.length > d->mmio_size)
+ 		return false;
+ 
+ 	/* Check length is 1, 2 or 4. */
+ 	if (cfg_access->cap.length != 1
+ 	    && cfg_access->cap.length != 2
+ 	    && cfg_access->cap.length != 4)
+ 		return false;
+ 
+ 	/*
+ 	 * 4.1.4.7.2:
+ 	 *
+ 	 *  The driver MUST NOT write a cap.offset which is not a multiple of
+ 	 *  cap.length (ie. all accesses MUST be aligned).
+ 	 */
+ 	if (cfg_access->cap.offset % cfg_access->cap.length != 0)
+ 		return false;
+ 
+ 	/* Return pointer into word in BAR0. */
+ 	return true;
+ }
+ 
+ /* Is this accessing the PCI config address port?. */
+ static bool is_pci_addr_port(u16 port)
+ {
+ 	return port >= PCI_CONFIG_ADDR && port < PCI_CONFIG_ADDR + 4;
+ }
+ 
+ static bool pci_addr_iowrite(u16 port, u32 mask, u32 val)
+ {
+ 	iowrite(port - PCI_CONFIG_ADDR, val, mask,
+ 		&pci_config_addr.val);
+ 	verbose("PCI%s: %#x/%x: bus %u dev %u func %u reg %u\n",
+ 		pci_config_addr.bits.enabled ? "" : " DISABLED",
+ 		val, mask,
+ 		pci_config_addr.bits.busnum,
+ 		pci_config_addr.bits.devnum,
+ 		pci_config_addr.bits.funcnum,
+ 		pci_config_addr.bits.offset);
+ 	return true;
+ }
+ 
+ static void pci_addr_ioread(u16 port, u32 mask, u32 *val)
+ {
+ 	ioread(port - PCI_CONFIG_ADDR, pci_config_addr.val, mask, val);
+ }
+ 
+ /* Is this accessing the PCI config data port?. */
+ static bool is_pci_data_port(u16 port)
+ {
+ 	return port >= PCI_CONFIG_DATA && port < PCI_CONFIG_DATA + 4;
+ }
+ 
+ static void emulate_mmio_write(struct device *d, u32 off, u32 val, u32 mask);
+ 
+ static bool pci_data_iowrite(u16 port, u32 mask, u32 val)
+ {
+ 	u32 reg, portoff;
+ 	struct device *d = dev_and_reg(&reg);
+ 
+ 	/* Complain if they don't belong to a device. */
+ 	if (!d)
+ 		return false;
+ 
+ 	/* They can do 1 byte writes, etc. */
+ 	portoff = port - PCI_CONFIG_DATA;
+ 
+ 	/*
+ 	 * PCI uses a weird way to determine the BAR size: the OS
+ 	 * writes all 1's, and sees which ones stick.
+ 	 */
+ 	if (&d->config_words[reg] == &d->config.bar[0]) {
+ 		int i;
+ 
+ 		iowrite(portoff, val, mask, &d->config.bar[0]);
+ 		for (i = 0; (1 << i) < d->mmio_size; i++)
+ 			d->config.bar[0] &= ~(1 << i);
+ 		return true;
+ 	} else if ((&d->config_words[reg] > &d->config.bar[0]
+ 		    && &d->config_words[reg] <= &d->config.bar[6])
+ 		   || &d->config_words[reg] == &d->config.expansion_rom_addr) {
+ 		/* Allow writing to any other BAR, or expansion ROM */
+ 		iowrite(portoff, val, mask, &d->config_words[reg]);
+ 		return true;
+ 		/* We let them override latency timer and cacheline size */
+ 	} else if (&d->config_words[reg] == (void *)&d->config.cacheline_size) {
+ 		/* Only let them change the first two fields. */
+ 		if (mask == 0xFFFFFFFF)
+ 			mask = 0xFFFF;
+ 		iowrite(portoff, val, mask, &d->config_words[reg]);
+ 		return true;
+ 	} else if (&d->config_words[reg] == (void *)&d->config.command
+ 		   && mask == 0xFFFF) {
+ 		/* Ignore command writes. */
+ 		return true;
+ 	} else if (&d->config_words[reg]
+ 		   == (void *)&d->config.cfg_access.cap.bar
+ 		   || &d->config_words[reg]
+ 		   == &d->config.cfg_access.cap.length
+ 		   || &d->config_words[reg]
+ 		   == &d->config.cfg_access.cap.offset) {
+ 
+ 		/*
+ 		 * The VIRTIO_PCI_CAP_PCI_CFG capability
+ 		 * provides a backdoor to access the MMIO
+ 		 * regions without mapping them.  Weird, but
+ 		 * useful.
+ 		 */
+ 		iowrite(portoff, val, mask, &d->config_words[reg]);
+ 		return true;
+ 	} else if (&d->config_words[reg] == &d->config.cfg_access.pci_cfg_data) {
+ 		u32 write_mask;
+ 
+ 		/*
+ 		 * 4.1.4.7.1:
+ 		 *
+ 		 *  Upon detecting driver write access to pci_cfg_data, the
+ 		 *  device MUST execute a write access at offset cap.offset at
+ 		 *  BAR selected by cap.bar using the first cap.length bytes
+ 		 *  from pci_cfg_data.
+ 		 */
+ 
+ 		/* Must be bar 0 */
+ 		if (!valid_bar_access(d, &d->config.cfg_access))
+ 			return false;
+ 
+ 		iowrite(portoff, val, mask, &d->config.cfg_access.pci_cfg_data);
+ 
+ 		/*
+ 		 * Now emulate a write.  The mask we use is set by
+ 		 * len, *not* this write!
+ 		 */
+ 		write_mask = (1ULL<<(8*d->config.cfg_access.cap.length)) - 1;
+ 		verbose("Window writing %#x/%#x to bar %u, offset %u len %u\n",
+ 			d->config.cfg_access.pci_cfg_data, write_mask,
+ 			d->config.cfg_access.cap.bar,
+ 			d->config.cfg_access.cap.offset,
+ 			d->config.cfg_access.cap.length);
+ 
+ 		emulate_mmio_write(d, d->config.cfg_access.cap.offset,
+ 				   d->config.cfg_access.pci_cfg_data,
+ 				   write_mask);
+ 		return true;
+ 	}
+ 
+ 	/*
+ 	 * 4.1.4.1:
+ 	 *
+ 	 *  The driver MUST NOT write into any field of the capability
+ 	 *  structure, with the exception of those with cap_type
+ 	 *  VIRTIO_PCI_CAP_PCI_CFG...
+ 	 */
+ 	return false;
+ }
+ 
+ static u32 emulate_mmio_read(struct device *d, u32 off, u32 mask);
+ 
+ static void pci_data_ioread(u16 port, u32 mask, u32 *val)
+ {
+ 	u32 reg;
+ 	struct device *d = dev_and_reg(&reg);
+ 
+ 	if (!d)
+ 		return;
+ 
+ 	/* Read through the PCI MMIO access window is special */
+ 	if (&d->config_words[reg] == &d->config.cfg_access.pci_cfg_data) {
+ 		u32 read_mask;
+ 
+ 		/*
+ 		 * 4.1.4.7.1:
+ 		 *
+ 		 *  Upon detecting driver read access to pci_cfg_data, the
+ 		 *  device MUST execute a read access of length cap.length at
+ 		 *  offset cap.offset at BAR selected by cap.bar and store the
+ 		 *  first cap.length bytes in pci_cfg_data.
+ 		 */
+ 		/* Must be bar 0 */
+ 		if (!valid_bar_access(d, &d->config.cfg_access))
+ 			bad_driver(d,
+ 			     "Invalid cfg_access to bar%u, offset %u len %u",
+ 			     d->config.cfg_access.cap.bar,
+ 			     d->config.cfg_access.cap.offset,
+ 			     d->config.cfg_access.cap.length);
+ 
+ 		/*
+ 		 * Read into the window.  The mask we use is set by
+ 		 * len, *not* this read!
+ 		 */
+ 		read_mask = (1ULL<<(8*d->config.cfg_access.cap.length))-1;
+ 		d->config.cfg_access.pci_cfg_data
+ 			= emulate_mmio_read(d,
+ 					    d->config.cfg_access.cap.offset,
+ 					    read_mask);
+ 		verbose("Window read %#x/%#x from bar %u, offset %u len %u\n",
+ 			d->config.cfg_access.pci_cfg_data, read_mask,
+ 			d->config.cfg_access.cap.bar,
+ 			d->config.cfg_access.cap.offset,
+ 			d->config.cfg_access.cap.length);
+ 	}
+ 	ioread(port - PCI_CONFIG_DATA, d->config_words[reg], mask, val);
+ }
+ 
++>>>>>>> 505d3085d712 (scripts/spelling.txt: add "overide" pattern and fix typo instances)
  /*L:216
 - * This is where we emulate a handful of Guest instructions.  It's ugly
 - * and we used to do it in the kernel but it grew over time.
 - */
 -
 -/*
 - * We use the ptrace syscall's pt_regs struct to talk about registers
 - * to lguest: these macros convert the names to the offsets.
 - */
 -#define getreg(name) getreg_off(offsetof(struct user_regs_struct, name))
 -#define setreg(name, val) \
 -	setreg_off(offsetof(struct user_regs_struct, name), (val))
 -
 -static u32 getreg_off(size_t offset)
 -{
 -	u32 r;
 -	unsigned long args[] = { LHREQ_GETREG, offset };
 -
 -	if (pwrite(lguest_fd, args, sizeof(args), cpu_id) < 0)
 -		err(1, "Getting register %u", offset);
 -	if (pread(lguest_fd, &r, sizeof(r), cpu_id) != sizeof(r))
 -		err(1, "Reading register %u", offset);
 -
 -	return r;
 -}
 -
 -static void setreg_off(size_t offset, u32 val)
 -{
 -	unsigned long args[] = { LHREQ_SETREG, offset, val };
 -
 -	if (pwrite(lguest_fd, args, sizeof(args), cpu_id) < 0)
 -		err(1, "Setting register %u", offset);
 -}
 -
 -/* Get register by instruction encoding */
 -static u32 getreg_num(unsigned regnum, u32 mask)
 -{
 -	/* 8 bit ops use regnums 4-7 for high parts of word */
 -	if (mask == 0xFF && (regnum & 0x4))
 -		return getreg_num(regnum & 0x3, 0xFFFF) >> 8;
 -
 -	switch (regnum) {
 -	case 0: return getreg(eax) & mask;
 -	case 1: return getreg(ecx) & mask;
 -	case 2: return getreg(edx) & mask;
 -	case 3: return getreg(ebx) & mask;
 -	case 4: return getreg(esp) & mask;
 -	case 5: return getreg(ebp) & mask;
 -	case 6: return getreg(esi) & mask;
 -	case 7: return getreg(edi) & mask;
 -	}
 -	abort();
 -}
 -
 -/* Set register by instruction encoding */
 -static void setreg_num(unsigned regnum, u32 val, u32 mask)
 -{
 -	/* Don't try to set bits out of range */
 -	assert(~(val & ~mask));
 -
 -	/* 8 bit ops use regnums 4-7 for high parts of word */
 -	if (mask == 0xFF && (regnum & 0x4)) {
 -		/* Construct the 16 bits we want. */
 -		val = (val << 8) | getreg_num(regnum & 0x3, 0xFF);
 -		setreg_num(regnum & 0x3, val, 0xFFFF);
 -		return;
 -	}
 -
 -	switch (regnum) {
 -	case 0: setreg(eax, val | (getreg(eax) & ~mask)); return;
 -	case 1: setreg(ecx, val | (getreg(ecx) & ~mask)); return;
 -	case 2: setreg(edx, val | (getreg(edx) & ~mask)); return;
 -	case 3: setreg(ebx, val | (getreg(ebx) & ~mask)); return;
 -	case 4: setreg(esp, val | (getreg(esp) & ~mask)); return;
 -	case 5: setreg(ebp, val | (getreg(ebp) & ~mask)); return;
 -	case 6: setreg(esi, val | (getreg(esi) & ~mask)); return;
 -	case 7: setreg(edi, val | (getreg(edi) & ~mask)); return;
 -	}
 -	abort();
 -}
 -
 -/* Get bytes of displacement appended to instruction, from r/m encoding */
 -static u32 insn_displacement_len(u8 mod_reg_rm)
 -{
 -	/* Switch on the mod bits */
 -	switch (mod_reg_rm >> 6) {
 -	case 0:
 -		/* If mod == 0, and r/m == 101, 16-bit displacement follows */
 -		if ((mod_reg_rm & 0x7) == 0x5)
 -			return 2;
 -		/* Normally, mod == 0 means no literal displacement */
 -		return 0;
 -	case 1:
 -		/* One byte displacement */
 -		return 1;
 -	case 2:
 -		/* Four byte displacement */
 -		return 4;
 -	case 3:
 -		/* Register mode */
 -		return 0;
 -	}
 -	abort();
 -}
 -
 -static void emulate_insn(const u8 insn[])
 -{
 -	unsigned long args[] = { LHREQ_TRAP, 13 };
 -	unsigned int insnlen = 0, in = 0, small_operand = 0, byte_access;
 -	unsigned int eax, port, mask;
 -	/*
 -	 * Default is to return all-ones on IO port reads, which traditionally
 -	 * means "there's nothing there".
 -	 */
 -	u32 val = 0xFFFFFFFF;
 -
 -	/*
 -	 * This must be the Guest kernel trying to do something, not userspace!
 -	 * The bottom two bits of the CS segment register are the privilege
 -	 * level.
 -	 */
 -	if ((getreg(xcs) & 3) != 0x1)
 -		goto no_emulate;
 -
 -	/* Decoding x86 instructions is icky. */
 -
 -	/*
 -	 * Around 2.6.33, the kernel started using an emulation for the
 -	 * cmpxchg8b instruction in early boot on many configurations.  This
 -	 * code isn't paravirtualized, and it tries to disable interrupts.
 -	 * Ignore it, which will Mostly Work.
 -	 */
 -	if (insn[insnlen] == 0xfa) {
 -		/* "cli", or Clear Interrupt Enable instruction.  Skip it. */
 -		insnlen = 1;
 -		goto skip_insn;
 -	}
 -
 -	/*
 -	 * 0x66 is an "operand prefix".  It means a 16, not 32 bit in/out.
 -	 */
 -	if (insn[insnlen] == 0x66) {
 -		small_operand = 1;
 -		/* The instruction is 1 byte so far, read the next byte. */
 -		insnlen = 1;
 -	}
 -
 -	/* If the lower bit isn't set, it's a single byte access */
 -	byte_access = !(insn[insnlen] & 1);
 -
 -	/*
 -	 * Now we can ignore the lower bit and decode the 4 opcodes
 -	 * we need to emulate.
 -	 */
 -	switch (insn[insnlen] & 0xFE) {
 -	case 0xE4: /* in     <next byte>,%al */
 -		port = insn[insnlen+1];
 -		insnlen += 2;
 -		in = 1;
 -		break;
 -	case 0xEC: /* in     (%dx),%al */
 -		port = getreg(edx) & 0xFFFF;
 -		insnlen += 1;
 -		in = 1;
 -		break;
 -	case 0xE6: /* out    %al,<next byte> */
 -		port = insn[insnlen+1];
 -		insnlen += 2;
 -		break;
 -	case 0xEE: /* out    %al,(%dx) */
 -		port = getreg(edx) & 0xFFFF;
 -		insnlen += 1;
 -		break;
 -	default:
 -		/* OK, we don't know what this is, can't emulate. */
 -		goto no_emulate;
 -	}
 -
 -	/* Set a mask of the 1, 2 or 4 bytes, depending on size of IO */
 -	if (byte_access)
 -		mask = 0xFF;
 -	else if (small_operand)
 -		mask = 0xFFFF;
 -	else
 -		mask = 0xFFFFFFFF;
 -
 -	/*
 -	 * If it was an "IN" instruction, they expect the result to be read
 -	 * into %eax, so we change %eax.
 -	 */
 -	eax = getreg(eax);
 -
 -	if (in) {
 -		/* This is the PS/2 keyboard status; 1 means ready for output */
 -		if (port == 0x64)
 -			val = 1;
 -		else if (is_pci_addr_port(port))
 -			pci_addr_ioread(port, mask, &val);
 -		else if (is_pci_data_port(port))
 -			pci_data_ioread(port, mask, &val);
 -
 -		/* Clear the bits we're about to read */
 -		eax &= ~mask;
 -		/* Copy bits in from val. */
 -		eax |= val & mask;
 -		/* Now update the register. */
 -		setreg(eax, eax);
 -	} else {
 -		if (is_pci_addr_port(port)) {
 -			if (!pci_addr_iowrite(port, mask, eax))
 -				goto bad_io;
 -		} else if (is_pci_data_port(port)) {
 -			if (!pci_data_iowrite(port, mask, eax))
 -				goto bad_io;
 -		}
 -		/* There are many other ports, eg. CMOS clock, serial
 -		 * and parallel ports, so we ignore them all. */
 -	}
 -
 -	verbose("IO %s of %x to %u: %#08x\n",
 -		in ? "IN" : "OUT", mask, port, eax);
 -skip_insn:
 -	/* Finally, we've "done" the instruction, so move past it. */
 -	setreg(eip, getreg(eip) + insnlen);
 -	return;
 -
 -bad_io:
 -	warnx("Attempt to %s port %u (%#x mask)",
 -	      in ? "read from" : "write to", port, mask);
 -
 -no_emulate:
 -	/* Inject trap into Guest. */
 -	if (write(lguest_fd, args, sizeof(args)) < 0)
 -		err(1, "Reinjecting trap 13 for fault at %#x", getreg(eip));
 -}
 -
 -static struct device *find_mmio_region(unsigned long paddr, u32 *off)
 -{
 -	unsigned int i;
 -
 -	for (i = 1; i < MAX_PCI_DEVICES; i++) {
 -		struct device *d = devices.pci[i];
 -
 -		if (!d)
 -			continue;
 -		if (paddr < d->mmio_addr)
 -			continue;
 -		if (paddr >= d->mmio_addr + d->mmio_size)
 -			continue;
 -		*off = paddr - d->mmio_addr;
 -		return d;
 -	}
 -	return NULL;
 -}
 -
 -/* FIXME: Use vq array. */
 -static struct virtqueue *vq_by_num(struct device *d, u32 num)
 -{
 -	struct virtqueue *vq = d->vq;
 -
 -	while (num-- && vq)
 -		vq = vq->next;
 -
 -	return vq;
 -}
 -
 -static void save_vq_config(const struct virtio_pci_common_cfg *cfg,
 -			   struct virtqueue *vq)
 -{
 -	vq->pci_config = *cfg;
 -}
 -
 -static void restore_vq_config(struct virtio_pci_common_cfg *cfg,
 -			      struct virtqueue *vq)
 -{
 -	/* Only restore the per-vq part */
 -	size_t off = offsetof(struct virtio_pci_common_cfg, queue_size);
 -
 -	memcpy((void *)cfg + off, (void *)&vq->pci_config + off,
 -	       sizeof(*cfg) - off);
 -}
 -
 -/*
 - * 4.1.4.3.2:
 - *
 - *  The driver MUST configure the other virtqueue fields before
 - *  enabling the virtqueue with queue_enable.
 - *
 - * When they enable the virtqueue, we check that their setup is valid.
 + * This actually creates the thread which services the virtqueue for a device.
   */
 -static void check_virtqueue(struct device *d, struct virtqueue *vq)
 -{
 -	/* Because lguest is 32 bit, all the descriptor high bits must be 0 */
 -	if (vq->pci_config.queue_desc_hi
 -	    || vq->pci_config.queue_avail_hi
 -	    || vq->pci_config.queue_used_hi)
 -		bad_driver_vq(vq, "invalid 64-bit queue address");
 -
 -	/*
 -	 * 2.4.1:
 -	 *
 -	 *  The driver MUST ensure that the physical address of the first byte
 -	 *  of each virtqueue part is a multiple of the specified alignment
 -	 *  value in the above table.
 -	 */
 -	if (vq->pci_config.queue_desc_lo % 16
 -	    || vq->pci_config.queue_avail_lo % 2
 -	    || vq->pci_config.queue_used_lo % 4)
 -		bad_driver_vq(vq, "invalid alignment in queue addresses");
 -
 -	/* Initialize the virtqueue and check they're all in range. */
 -	vq->vring.num = vq->pci_config.queue_size;
 -	vq->vring.desc = check_pointer(vq->dev,
 -				       vq->pci_config.queue_desc_lo,
 -				       sizeof(*vq->vring.desc) * vq->vring.num);
 -	vq->vring.avail = check_pointer(vq->dev,
 -					vq->pci_config.queue_avail_lo,
 -					sizeof(*vq->vring.avail)
 -					+ (sizeof(vq->vring.avail->ring[0])
 -					   * vq->vring.num));
 -	vq->vring.used = check_pointer(vq->dev,
 -				       vq->pci_config.queue_used_lo,
 -				       sizeof(*vq->vring.used)
 -				       + (sizeof(vq->vring.used->ring[0])
 -					  * vq->vring.num));
 -
 -	/*
 -	 * 2.4.9.1:
 -	 *
 -	 *   The driver MUST initialize flags in the used ring to 0
 -	 *   when allocating the used ring.
 -	 */
 -	if (vq->vring.used->flags != 0)
 -		bad_driver_vq(vq, "invalid initial used.flags %#x",
 -			      vq->vring.used->flags);
 -}
 -
 -static void start_virtqueue(struct virtqueue *vq)
 +static void create_thread(struct virtqueue *vq)
  {
  	/*
  	 * Create stack for thread.  Since the stack grows upwards, we point
* Unmerged path Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt
* Unmerged path drivers/media/dvb-frontends/drx39xyj/drx_driver.h
* Unmerged path include/dt-bindings/sound/cs42l42.h
* Unmerged path scripts/spelling.txt
* Unmerged path tools/lib/bpf/Makefile
* Unmerged path Documentation/devicetree/bindings/regulator/ti-abb-regulator.txt
diff --git a/drivers/block/paride/pcd.c b/drivers/block/paride/pcd.c
index e76bdc074dbe..bfda68e1fde0 100644
--- a/drivers/block/paride/pcd.c
+++ b/drivers/block/paride/pcd.c
@@ -50,7 +50,7 @@
                         the slower the port i/o.  In some cases, setting
                         this to zero will speed up the device. (default -1)
                         
-            major       You may use this parameter to overide the
+            major       You may use this parameter to override the
                         default major number (46) that this driver
                         will use.  Be sure to change the device
                         name as well.
diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c
index 2af41011d13f..d05177193d51 100644
--- a/drivers/block/paride/pd.c
+++ b/drivers/block/paride/pd.c
@@ -61,7 +61,7 @@
                         first drive found.
 			
 
-            major       You may use this parameter to overide the
+            major       You may use this parameter to override the
                         default major number (45) that this driver
                         will use.  Be sure to change the device
                         name as well.
diff --git a/drivers/block/paride/pf.c b/drivers/block/paride/pf.c
index f5c86d523ba0..99c9912524e1 100644
--- a/drivers/block/paride/pf.c
+++ b/drivers/block/paride/pf.c
@@ -59,7 +59,7 @@
                         the slower the port i/o.  In some cases, setting
                         this to zero will speed up the device. (default -1)
 
-	    major	You may use this parameter to overide the
+	    major	You may use this parameter to override the
 			default major number (47) that this driver
 			will use.  Be sure to change the device
 			name as well.
diff --git a/drivers/block/paride/pg.c b/drivers/block/paride/pg.c
index 4a27b1de5fcb..8bffb3489bb1 100644
--- a/drivers/block/paride/pg.c
+++ b/drivers/block/paride/pg.c
@@ -84,7 +84,7 @@
 			the slower the port i/o.  In some cases, setting
 			this to zero will speed up the device. (default -1)
 
-	    major	You may use this parameter to overide the
+	    major	You may use this parameter to override the
 			default major number (97) that this driver
 			will use.  Be sure to change the device
 			name as well.
diff --git a/drivers/block/paride/pt.c b/drivers/block/paride/pt.c
index 2596042eb987..6a0faa3d19a2 100644
--- a/drivers/block/paride/pt.c
+++ b/drivers/block/paride/pt.c
@@ -61,7 +61,7 @@
                         the slower the port i/o.  In some cases, setting
                         this to zero will speed up the device. (default -1)
 
-	    major	You may use this parameter to overide the
+	    major	You may use this parameter to override the
 			default major number (96) that this driver
 			will use.  Be sure to change the device
 			name as well.
* Unmerged path drivers/media/dvb-frontends/drx39xyj/drx_driver.h
* Unmerged path drivers/net/ethernet/qlogic/qlge/qlge.h
* Unmerged path include/dt-bindings/sound/cs42l42.h
diff --git a/include/net/irda/timer.h b/include/net/irda/timer.h
index cb2615ccf761..d784f242cf7b 100644
--- a/include/net/irda/timer.h
+++ b/include/net/irda/timer.h
@@ -59,7 +59,7 @@ struct lap_cb;
  *  Slot timer must never exceed 85 ms, and must always be at least 25 ms, 
  *  suggested to  75-85 msec by IrDA lite. This doesn't work with a lot of
  *  devices, and other stackes uses a lot more, so it's best we do it as well
- *  (Note : this is the default value and sysctl overides it - Jean II)
+ *  (Note : this is the default value and sysctl overrides it - Jean II)
  */
 #define SLOT_TIMEOUT            (90*HZ/1000)
 
* Unmerged path kernel/trace/trace_stack.c
* Unmerged path scripts/spelling.txt
* Unmerged path tools/lguest/lguest.c
* Unmerged path tools/lib/bpf/Makefile
diff --git a/tools/lib/traceevent/Makefile b/tools/lib/traceevent/Makefile
index 47076b15eebe..9b8555ea3459 100644
--- a/tools/lib/traceevent/Makefile
+++ b/tools/lib/traceevent/Makefile
@@ -135,7 +135,7 @@ else
   Q = @
 endif
 
-# Disable command line variables (CFLAGS) overide from top
+# Disable command line variables (CFLAGS) override from top
 # level Makefile (perf), otherwise build Makefile will get
 # the same command line setup.
 MAKEOVERRIDES=
diff --git a/tools/lib/traceevent/event-parse.h b/tools/lib/traceevent/event-parse.h
index 66342804161c..0c03538df74c 100644
--- a/tools/lib/traceevent/event-parse.h
+++ b/tools/lib/traceevent/event-parse.h
@@ -140,7 +140,7 @@ struct pevent_plugin_option {
  *   struct pevent_plugin_option PEVENT_PLUGIN_OPTIONS[] = {
  *	{
  *		.name = "option-name",
- *		.plugin_alias = "overide-file-name", (optional)
+ *		.plugin_alias = "override-file-name", (optional)
  *		.description = "description of option to show users",
  *	},
  *	{
