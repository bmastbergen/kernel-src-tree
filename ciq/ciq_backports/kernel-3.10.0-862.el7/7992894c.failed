hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mohammed Gamal <mgamal@redhat.com>
commit 7992894c305eaf504d005529637ff8283d0a849d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7992894c.failed

Split each of the functions into two for each of send/recv buffers.
This will be needed in order to implement a fine-grained messaging
sequence to the host so that we accommodate the requirements of
different Windows versions

Fixes: 0ef58b0a05c12 ("hv_netvsc: change GPAD teardown order on older versions")
	Signed-off-by: Mohammed Gamal <mgamal@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7992894c305eaf504d005529637ff8283d0a849d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 05d0110585ac,f4df5def8f62..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -99,37 -104,16 +99,45 @@@ static void free_netvsc_device(struct n
  	kfree(nvdev);
  }
  
 -static void free_netvsc_device_rcu(struct netvsc_device *nvdev)
 +static struct netvsc_device *get_outbound_net_device(struct hv_device *device)
  {
 -	call_rcu(&nvdev->rcu, free_netvsc_device);
 +	struct netvsc_device *net_device = hv_device_to_netvsc_device(device);
 +
 +	if (net_device && net_device->destroy)
 +		net_device = NULL;
 +
 +	return net_device;
  }
  
++<<<<<<< HEAD
 +static struct netvsc_device *get_inbound_net_device(struct hv_device *device)
 +{
 +	struct netvsc_device *net_device = hv_device_to_netvsc_device(device);
 +
 +	if (!net_device)
 +		goto get_in_err;
 +
 +	if (net_device->destroy &&
 +	    atomic_read(&net_device->num_outstanding_sends) == 0 &&
 +	    atomic_read(&net_device->num_outstanding_recvs) == 0)
 +		net_device = NULL;
 +
 +get_in_err:
 +	return net_device;
 +}
 +
 +static void netvsc_destroy_buf(struct hv_device *device)
++=======
+ static void netvsc_revoke_recv_buf(struct hv_device *device,
+ 				   struct netvsc_device *net_device)
++>>>>>>> 7992894c305e (hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl())
  {
- 	struct nvsp_message *revoke_packet;
  	struct net_device *ndev = hv_get_drvdata(device);
++<<<<<<< HEAD
 +	struct netvsc_device *net_device = net_device_to_netvsc_device(ndev);
++=======
+ 	struct nvsp_message *revoke_packet;
++>>>>>>> 7992894c305e (hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl())
  	int ret;
  
  	/*
@@@ -169,35 -155,16 +177,43 @@@
  				"revoke receive buffer to netvsp\n");
  			return;
  		}
 +	}
 +
 +	/* Teardown the gpadl on the vsp end */
 +	if (net_device->recv_buf_gpadl_handle) {
 +		ret = vmbus_teardown_gpadl(device->channel,
 +					   net_device->recv_buf_gpadl_handle);
 +
 +		/* If we failed here, we might as well return and have a leak
 +		 * rather than continue and a bugchk
 +		 */
 +		if (ret != 0) {
 +			netdev_err(ndev,
 +				   "unable to teardown receive buffer's gpadl\n");
 +			return;
 +		}
 +		net_device->recv_buf_gpadl_handle = 0;
 +	}
 +
 +	if (net_device->recv_buf) {
 +		/* Free up the receive buffer */
 +		vfree(net_device->recv_buf);
 +		net_device->recv_buf = NULL;
 +	}
 +
 +	if (net_device->recv_section) {
  		net_device->recv_section_cnt = 0;
 +		kfree(net_device->recv_section);
 +		net_device->recv_section = NULL;
  	}
+ }
+ 
+ static void netvsc_revoke_send_buf(struct hv_device *device,
+ 				   struct netvsc_device *net_device)
+ {
+ 	struct net_device *ndev = hv_get_drvdata(device);
+ 	struct nvsp_message *revoke_packet;
+ 	int ret;
  
  	/* Deal with the send buffer we may have setup.
  	 * If we got a  send section size, it means we received a
@@@ -237,8 -206,38 +253,41 @@@
  				   "revoke send buffer to netvsp\n");
  			return;
  		}
 -		net_device->send_section_cnt = 0;
  	}
++<<<<<<< HEAD
 +	/* Teardown the gpadl on the vsp end */
++=======
+ }
+ 
+ static void netvsc_teardown_recv_gpadl(struct hv_device *device,
+ 				       struct netvsc_device *net_device)
+ {
+ 	struct net_device *ndev = hv_get_drvdata(device);
+ 	int ret;
+ 
+ 	if (net_device->recv_buf_gpadl_handle) {
+ 		ret = vmbus_teardown_gpadl(device->channel,
+ 					   net_device->recv_buf_gpadl_handle);
+ 
+ 		/* If we failed here, we might as well return and have a leak
+ 		 * rather than continue and a bugchk
+ 		 */
+ 		if (ret != 0) {
+ 			netdev_err(ndev,
+ 				   "unable to teardown receive buffer's gpadl\n");
+ 			return;
+ 		}
+ 		net_device->recv_buf_gpadl_handle = 0;
+ 	}
+ }
+ 
+ static void netvsc_teardown_send_gpadl(struct hv_device *device,
+ 				       struct netvsc_device *net_device)
+ {
+ 	struct net_device *ndev = hv_get_drvdata(device);
+ 	int ret;
+ 
++>>>>>>> 7992894c305e (hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl())
  	if (net_device->send_buf_gpadl_handle) {
  		ret = vmbus_teardown_gpadl(device->channel,
  					   net_device->send_buf_gpadl_handle);
@@@ -439,7 -452,10 +488,14 @@@ static int netvsc_init_buf(struct hv_de
  	goto exit;
  
  cleanup:
++<<<<<<< HEAD
 +	netvsc_destroy_buf(device);
++=======
+ 	netvsc_revoke_recv_buf(device, net_device);
+ 	netvsc_revoke_send_buf(device, net_device);
+ 	netvsc_teardown_recv_gpadl(device, net_device);
+ 	netvsc_teardown_send_gpadl(device, net_device);
++>>>>>>> 7992894c305e (hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl())
  
  exit:
  	return ret;
@@@ -575,11 -588,18 +631,16 @@@ void netvsc_device_remove(struct hv_dev
  {
  	struct net_device *ndev = hv_get_drvdata(device);
  	struct net_device_context *net_device_ctx = netdev_priv(ndev);
 -	struct netvsc_device *net_device
 -		= rtnl_dereference(net_device_ctx->nvdev);
 -	int i;
 +	struct netvsc_device *net_device = net_device_ctx->nvdev;
  
++<<<<<<< HEAD
 +	netvsc_disconnect_vsp(device);
++=======
+ 	netvsc_revoke_recv_buf(device, net_device);
+ 	netvsc_revoke_send_buf(device, net_device);
++>>>>>>> 7992894c305e (hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl())
  
 -	RCU_INIT_POINTER(net_device_ctx->nvdev, NULL);
 -
 -	/* And disassociate NAPI context from device */
 -	for (i = 0; i < net_device->num_chn; i++)
 -		netif_napi_del(&net_device->chan_table[i].napi);
 +	net_device_ctx->nvdev = NULL;
  
  	/*
  	 * At this point, no one should be accessing net_device
@@@ -587,12 -607,22 +648,29 @@@
  	 */
  	netdev_dbg(ndev, "net device safe to remove\n");
  
++<<<<<<< HEAD
++	/* Now, we can close the channel safely */
++	vmbus_close(device->channel);
++
++=======
+ 	/* older versions require that buffer be revoked before close */
+ 	if (vmbus_proto_version < VERSION_WIN10) {
+ 		netvsc_teardown_recv_gpadl(device, net_device);
+ 		netvsc_teardown_send_gpadl(device, net_device);
+ 	}
+ 
  	/* Now, we can close the channel safely */
  	vmbus_close(device->channel);
  
+ 	if (vmbus_proto_version >= VERSION_WIN10) {
+ 		netvsc_teardown_recv_gpadl(device, net_device);
+ 		netvsc_teardown_send_gpadl(device, net_device);
+ 	}
+ 
++>>>>>>> 7992894c305e (hv_netvsc: Split netvsc_revoke_buf() and netvsc_teardown_gpadl())
  	/* Release all resources */
 -	free_netvsc_device_rcu(net_device);
 +	vfree(net_device->sub_cb_buf);
 +	free_netvsc_device(net_device);
  }
  
  #define RING_AVAIL_PERCENT_HIWATER 20
* Unmerged path drivers/net/hyperv/netvsc.c
