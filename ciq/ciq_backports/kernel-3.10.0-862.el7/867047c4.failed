netvsc: fix warnings reported by lockdep

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 867047c4512aa65fb4cf66b253b51b830c7fa172
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/867047c4.failed

This includes a bunch of fixups for issues reported by
lockdep.
   * ethtool routines can assume RTNL
   * send is done with RCU lock (and BH disable)
   * avoid refetching internal device struct (netvsc)
     instead pass it as a parameter.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 867047c4512aa65fb4cf66b253b51b830c7fa172)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/netvsc_drv.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,fb62ea632914..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -208,8 -217,8 +208,13 @@@ int rndis_filter_receive(struct net_dev
  			 struct vmbus_channel *channel,
  			 void *data, u32 buflen);
  
++<<<<<<< HEAD
 +int rndis_filter_set_packet_filter(struct rndis_device *dev, u32 new_filter);
 +int rndis_filter_set_device_mac(struct net_device *ndev, char *mac);
++=======
+ int rndis_filter_set_device_mac(struct netvsc_device *ndev,
+ 				const char *mac);
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  
  void netvsc_switch_datapath(struct net_device *nv_dev, bool vf);
  
diff --cc drivers/net/hyperv/netvsc.c
index 3170ba757106,94c00acac58a..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -859,10 -831,11 +859,16 @@@ int netvsc_send(struct hv_device *devic
  		struct hv_page_buffer **pb,
  		struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct netvsc_device *net_device;
++=======
+ 	struct netvsc_device *net_device
+ 		= rcu_dereference_bh(ndev_ctx->nvdev);
+ 	struct hv_device *device = ndev_ctx->device_ctx;
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  	int ret = 0;
 -	struct netvsc_channel *nvchan;
 +	struct vmbus_channel *out_channel;
 +	u16 q_idx = packet->q_idx;
  	u32 pktlen = packet->total_data_buflen, msd_len = 0;
  	unsigned int section_index = NETVSC_INVALID_INDEX;
  	struct multi_send_data *msdp;
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,a04f2efbbc25..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -1028,17 -986,51 +1033,27 @@@ static void netvsc_get_ethtool_stats(st
  				     struct ethtool_stats *stats, u64 *data)
  {
  	struct net_device_context *ndc = netdev_priv(dev);
++<<<<<<< HEAD
++=======
+ 	struct netvsc_device *nvdev = rtnl_dereference(ndc->nvdev);
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  	const void *nds = &ndc->eth_stats;
 -	const struct netvsc_stats *qstats;
 -	unsigned int start;
 -	u64 packets, bytes;
 -	int i, j;
 -
 -	if (!nvdev)
 -		return;
 +	int i;
  
 -	for (i = 0; i < NETVSC_GLOBAL_STATS_LEN; i++)
 +	for (i = 0; i < ARRAY_SIZE(netvsc_stats); i++)
  		data[i] = *(unsigned long *)(nds + netvsc_stats[i].offset);
 -
 -	for (j = 0; j < nvdev->num_chn; j++) {
 -		qstats = &nvdev->chan_table[j].tx_stats;
 -
 -		do {
 -			start = u64_stats_fetch_begin_irq(&qstats->syncp);
 -			packets = qstats->packets;
 -			bytes = qstats->bytes;
 -		} while (u64_stats_fetch_retry_irq(&qstats->syncp, start));
 -		data[i++] = packets;
 -		data[i++] = bytes;
 -
 -		qstats = &nvdev->chan_table[j].rx_stats;
 -		do {
 -			start = u64_stats_fetch_begin_irq(&qstats->syncp);
 -			packets = qstats->packets;
 -			bytes = qstats->bytes;
 -		} while (u64_stats_fetch_retry_irq(&qstats->syncp, start));
 -		data[i++] = packets;
 -		data[i++] = bytes;
 -	}
  }
  
  static void netvsc_get_strings(struct net_device *dev, u32 stringset, u8 *data)
  {
++<<<<<<< HEAD
++=======
+ 	struct net_device_context *ndc = netdev_priv(dev);
+ 	struct netvsc_device *nvdev = rtnl_dereference(ndc->nvdev);
+ 	u8 *p = data;
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  	int i;
  
 -	if (!nvdev)
 -		return;
 -
  	switch (stringset) {
  	case ETH_SS_STATS:
  		for (i = 0; i < ARRAY_SIZE(netvsc_stats); i++)
@@@ -1077,7 -1082,10 +1092,14 @@@ netvsc_get_rxnfc(struct net_device *dev
  		 u32 *rules)
  {
  	struct net_device_context *ndc = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct netvsc_device *nvdev = ndc->nvdev;
++=======
+ 	struct netvsc_device *nvdev = rtnl_dereference(ndc->nvdev);
+ 
+ 	if (!nvdev)
+ 		return -ENODEV;
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  
  	switch (info->cmd) {
  	case ETHTOOL_GRXRINGS:
@@@ -1124,10 -1132,13 +1146,15 @@@ static int netvsc_get_rxfh(struct net_d
  			   u8 *hfunc)
  {
  	struct net_device_context *ndc = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct netvsc_device *ndev = ndc->nvdev;
 +	struct rndis_device *rndis_dev = ndev->extension;
++=======
+ 	struct netvsc_device *ndev = rtnl_dereference(ndc->nvdev);
+ 	struct rndis_device *rndis_dev;
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  	int i;
  
 -	if (!ndev)
 -		return -ENODEV;
 -
  	if (hfunc)
  		*hfunc = ETH_RSS_HASH_TOP;	/* Toeplitz */
  
diff --cc drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92,bf21ea92c743..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -241,7 -244,10 +241,14 @@@ static int rndis_filter_send_request(st
  			pb[0].len;
  	}
  
++<<<<<<< HEAD
 +	ret = netvsc_send(net_device_ctx->device_ctx, packet, NULL, &pb, NULL);
++=======
+ 	rcu_read_lock_bh();
+ 	ret = netvsc_send(net_device_ctx, packet, NULL, &pb, NULL);
+ 	rcu_read_unlock_bh();
+ 
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  	return ret;
  }
  
@@@ -468,7 -475,33 +476,37 @@@ static int rndis_filter_query_device(st
  	query->info_buflen = 0;
  	query->dev_vc_handle = 0;
  
++<<<<<<< HEAD
 +	if (oid == OID_GEN_RECEIVE_SCALE_CAPABILITIES) {
++=======
+ 	if (oid == OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES) {
+ 		struct ndis_offload *hwcaps;
+ 		u32 nvsp_version = nvdev->nvsp_version;
+ 		u8 ndis_rev;
+ 		size_t size;
+ 
+ 		if (nvsp_version >= NVSP_PROTOCOL_VERSION_5) {
+ 			ndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_3;
+ 			size = NDIS_OFFLOAD_SIZE;
+ 		} else if (nvsp_version >= NVSP_PROTOCOL_VERSION_4) {
+ 			ndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_2;
+ 			size = NDIS_OFFLOAD_SIZE_6_1;
+ 		} else {
+ 			ndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_1;
+ 			size = NDIS_OFFLOAD_SIZE_6_0;
+ 		}
+ 
+ 		request->request_msg.msg_len += size;
+ 		query->info_buflen = size;
+ 		hwcaps = (struct ndis_offload *)
+ 			((unsigned long)query + query->info_buf_offset);
+ 
+ 		hwcaps->header.type = NDIS_OBJECT_TYPE_OFFLOAD;
+ 		hwcaps->header.revision = ndis_rev;
+ 		hwcaps->header.size = size;
+ 
+ 	} else if (oid == OID_GEN_RECEIVE_SCALE_CAPABILITIES) {
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  		struct ndis_recv_scale_cap *cap;
  
  		request->request_msg.msg_len +=
@@@ -509,7 -542,47 +547,51 @@@ cleanup
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int rndis_filter_query_device_mac(struct rndis_device *dev)
++=======
+ /* Get the hardware offload capabilities */
+ static int
+ rndis_query_hwcaps(struct rndis_device *dev, struct netvsc_device *net_device,
+ 		   struct ndis_offload *caps)
+ {
+ 	u32 caps_len = sizeof(*caps);
+ 	int ret;
+ 
+ 	memset(caps, 0, sizeof(*caps));
+ 
+ 	ret = rndis_filter_query_device(dev, net_device,
+ 					OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES,
+ 					caps, &caps_len);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (caps->header.type != NDIS_OBJECT_TYPE_OFFLOAD) {
+ 		netdev_warn(dev->ndev, "invalid NDIS objtype %#x\n",
+ 			    caps->header.type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (caps->header.revision < NDIS_OFFLOAD_PARAMETERS_REVISION_1) {
+ 		netdev_warn(dev->ndev, "invalid NDIS objrev %x\n",
+ 			    caps->header.revision);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (caps->header.size > caps_len ||
+ 	    caps->header.size < NDIS_OFFLOAD_SIZE_6_0) {
+ 		netdev_warn(dev->ndev,
+ 			    "invalid NDIS objsize %u, data size %u\n",
+ 			    caps->header.size, caps_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int rndis_filter_query_device_mac(struct rndis_device *dev,
+ 					 struct netvsc_device *net_device)
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  {
  	u32 size = ETH_ALEN;
  
@@@ -780,7 -851,30 +859,34 @@@ int rndis_filter_set_packet_filter(stru
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int rndis_filter_init_device(struct rndis_device *dev)
++=======
+ static void rndis_set_multicast(struct work_struct *w)
+ {
+ 	struct rndis_device *rdev
+ 		= container_of(w, struct rndis_device, mcast_work);
+ 
+ 	if (rdev->ndev->flags & IFF_PROMISC)
+ 		rndis_filter_set_packet_filter(rdev,
+ 					       NDIS_PACKET_TYPE_PROMISCUOUS);
+ 	else
+ 		rndis_filter_set_packet_filter(rdev,
+ 					       NDIS_PACKET_TYPE_BROADCAST |
+ 					       NDIS_PACKET_TYPE_ALL_MULTICAST |
+ 					       NDIS_PACKET_TYPE_DIRECTED);
+ }
+ 
+ void rndis_filter_update(struct netvsc_device *nvdev)
+ {
+ 	struct rndis_device *rdev = nvdev->extension;
+ 
+ 	schedule_work(&rdev->mcast_work);
+ }
+ 
+ static int rndis_filter_init_device(struct rndis_device *dev,
+ 				    struct netvsc_device *nvdev)
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  {
  	struct rndis_request *request;
  	struct rndis_initialize_request *init;
@@@ -906,19 -1017,25 +1011,24 @@@ static void netvsc_sc_open(struct vmbus
  {
  	struct net_device *ndev =
  		hv_get_drvdata(new_sc->primary_channel->device_obj);
- 	struct netvsc_device *nvscdev = net_device_to_netvsc_device(ndev);
+ 	struct net_device_context *ndev_ctx = netdev_priv(ndev);
+ 	struct netvsc_device *nvscdev;
  	u16 chn_index = new_sc->offermsg.offer.sub_channel_index;
 -	struct netvsc_channel *nvchan;
  	int ret;
 +	unsigned long flags;
  
- 	if (chn_index >= nvscdev->num_chn)
+ 	/* This is safe because this callback only happens when
+ 	 * new device is being setup and waiting on the channel_init_wait.
+ 	 */
+ 	nvscdev = rcu_dereference_raw(ndev_ctx->nvdev);
+ 	if (!nvscdev || chn_index >= nvscdev->num_chn)
  		return;
  
 -	nvchan = nvscdev->chan_table + chn_index;
 -	nvchan->mrc.buf
 -		= vzalloc(NETVSC_RECVSLOT_MAX * sizeof(struct recv_comp_data));
 +	set_per_channel_state(new_sc, nvscdev->sub_cb_buf + (chn_index - 1) *
 +			      NETVSC_PACKET_SIZE);
  
 -	if (!nvchan->mrc.buf)
 -		return;
 +	nvscdev->mrc[chn_index].buf = vzalloc(NETVSC_RECVSLOT_MAX *
 +					      sizeof(struct recv_comp_data));
  
  	/* Because the device uses NAPI, all the interrupt batching and
  	 * control is done via Net softirq, not the channel handling
@@@ -985,11 -1102,9 +1095,17 @@@ int rndis_filter_device_add(struct hv_d
  	rndis_device->ndev = net;
  
  	/* Send the rndis initialization message */
++<<<<<<< HEAD
 +	ret = rndis_filter_init_device(rndis_device);
 +	if (ret != 0) {
 +		rndis_filter_device_remove(dev);
 +		return ret;
 +	}
++=======
+ 	ret = rndis_filter_init_device(rndis_device, net_device);
+ 	if (ret != 0)
+ 		goto err_dev_remv;
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  
  	/* Get the MTU from the host */
  	size = sizeof(u32);
@@@ -1000,44 -1115,84 +1116,59 @@@
  		net->mtu = mtu;
  
  	/* Get the mac address */
++<<<<<<< HEAD
 +	ret = rndis_filter_query_device_mac(rndis_device);
 +	if (ret != 0) {
 +		rndis_filter_device_remove(dev);
 +		return ret;
 +	}
 +
 +	memcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);
 +
 +	/* Turn on the offloads; the host supports all of the relevant
 +	 * offloads.
 +	 */
++=======
+ 	ret = rndis_filter_query_device_mac(rndis_device, net_device);
+ 	if (ret != 0)
+ 		goto err_dev_remv;
+ 
+ 	memcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);
+ 
+ 	/* Find HW offload capabilities */
+ 	ret = rndis_query_hwcaps(rndis_device, net_device, &hwcaps);
+ 	if (ret != 0)
+ 		goto err_dev_remv;
+ 
+ 	/* A value of zero means "no change"; now turn on what we want. */
++>>>>>>> 867047c4512a (netvsc: fix warnings reported by lockdep)
  	memset(&offloads, 0, sizeof(struct ndis_offload_params));
 -
 -	/* Linux does not care about IP checksum, always does in kernel */
 -	offloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_DISABLED;
 -
 -	/* Compute tx offload settings based on hw capabilities */
 -	net->hw_features = NETIF_F_RXCSUM;
 -
 -	if ((hwcaps.csum.ip4_txcsum & NDIS_TXCSUM_ALL_TCP4) == NDIS_TXCSUM_ALL_TCP4) {
 -		/* Can checksum TCP */
 -		net->hw_features |= NETIF_F_IP_CSUM;
 -		net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV4_TCP;
 -
 -		offloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 -
 -		if (hwcaps.lsov2.ip4_encap & NDIS_OFFLOAD_ENCAP_8023) {
 -			offloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
 -			net->hw_features |= NETIF_F_TSO;
 -
 -			if (hwcaps.lsov2.ip4_maxsz < gso_max_size)
 -				gso_max_size = hwcaps.lsov2.ip4_maxsz;
 -		}
 -
 -		if (hwcaps.csum.ip4_txcsum & NDIS_TXCSUM_CAP_UDP4) {
 -			offloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 -			net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV4_UDP;
 -		}
 -	}
 -
 -	if ((hwcaps.csum.ip6_txcsum & NDIS_TXCSUM_ALL_TCP6) == NDIS_TXCSUM_ALL_TCP6) {
 -		net->hw_features |= NETIF_F_IPV6_CSUM;
 -
 -		offloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 -		net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV6_TCP;
 -
 -		if ((hwcaps.lsov2.ip6_encap & NDIS_OFFLOAD_ENCAP_8023) &&
 -		    (hwcaps.lsov2.ip6_opts & NDIS_LSOV2_CAP_IP6) == NDIS_LSOV2_CAP_IP6) {
 -			offloads.lso_v2_ipv6 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
 -			net->hw_features |= NETIF_F_TSO6;
 -
 -			if (hwcaps.lsov2.ip6_maxsz < gso_max_size)
 -				gso_max_size = hwcaps.lsov2.ip6_maxsz;
 -		}
 -
 -		if (hwcaps.csum.ip6_txcsum & NDIS_TXCSUM_CAP_UDP6) {
 -			offloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 -			net_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV6_UDP;
 -		}
 -	}
 -
 -	netif_set_gso_max_size(net, gso_max_size);
 -
 -	ret = rndis_filter_set_offload_params(net, net_device, &offloads);
 +	/* A value of zero means "no change"; now turn on what we
 +	 * want.
 +	 */
 +	offloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
 +	offloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
 +
 +	ret = rndis_filter_set_offload_params(net, &offloads);
  	if (ret)
  		goto err_dev_remv;
  
- 	rndis_filter_query_device_link_status(rndis_device);
+ 	rndis_filter_query_device_link_status(rndis_device, net_device);
  
 +	device_info->link_state = rndis_device->link_state;
 +
  	netdev_dbg(net, "Device MAC %pM link state %s\n",
  		   rndis_device->hw_mac_adr,
 -		   rndis_device->link_state ? "down" : "up");
 +		   device_info->link_state ? "down" : "up");
  
  	if (net_device->nvsp_version < NVSP_PROTOCOL_VERSION_5)
 -		return net_device;
 +		return 0;
  
- 	rndis_filter_query_link_speed(rndis_device);
+ 	rndis_filter_query_link_speed(rndis_device, net_device);
  
  	/* vRSS setup */
  	memset(&rsscap, 0, rsscap_size);
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/netvsc_drv.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
