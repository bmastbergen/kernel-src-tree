networking: make skb_push & __skb_push return void pointers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] make skb_push & __skb_push return void pointers (Jiri Benc) [1497085]
Rebuild_FUZZ: 88.68%
commit-author Johannes Berg <johannes.berg@intel.com>
commit d58ff35122847a83ba55394e2ae3a1527b6febf5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d58ff351.failed

It seems like a historic accident that these return unsigned char *,
and in many places that means casts are required, more often than not.

Make these functions return void * and remove all the casts across
the tree, adding a (u8 *) cast only where the unsigned char pointer
was used directly, all done with the following spatch:

    @@
    expression SKB, LEN;
    typedef u8;
    identifier fn = { skb_push, __skb_push, skb_push_rcsum };
    @@
    - *(fn(SKB, LEN))
    + *(u8 *)fn(SKB, LEN)

    @@
    expression E, SKB, LEN;
    identifier fn = { skb_push, __skb_push, skb_push_rcsum };
    type T;
    @@
    - E = ((T *)(fn(SKB, LEN)))
    + E = fn(SKB, LEN)

    @@
    expression SKB, LEN;
    identifier fn = { skb_push, __skb_push, skb_push_rcsum };
    @@
    - fn(SKB, LEN)[0]
    + *(u8 *)fn(SKB, LEN)

Note that the last part there converts from push(...)[0] to the
more idiomatic *(u8 *)push(...).

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d58ff35122847a83ba55394e2ae3a1527b6febf5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c
#	drivers/infiniband/ulp/opa_vnic/opa_vnic_netdev.c
#	drivers/net/arcnet/arc-rawmode.c
#	drivers/net/arcnet/capmode.c
#	drivers/net/arcnet/rfc1051.c
#	drivers/net/arcnet/rfc1201.c
#	drivers/net/ethernet/broadcom/bcmsysport.c
#	drivers/net/geneve.c
#	drivers/net/gtp.c
#	drivers/net/macsec.c
#	drivers/net/usb/qmi_wwan.c
#	drivers/net/vrf.c
#	drivers/net/wireless/mac80211_hwsim.c
#	drivers/net/wireless/mediatek/mt7601u/tx.c
#	drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
#	drivers/net/wireless/st/cw1200/txrx.c
#	drivers/nfc/fdp/i2c.c
#	drivers/nfc/nfcmrvl/main.c
#	drivers/nfc/pn533.c
#	drivers/nfc/st-nci/ndlc.c
#	drivers/nfc/st21nfca/core.c
#	drivers/nfc/st21nfca/dep.c
#	drivers/nfc/st21nfca/i2c.c
#	drivers/s390/net/qeth_l3_main.c
#	drivers/staging/wilc1000/linux_mon.c
#	drivers/staging/wlan-ng/p80211conv.c
#	include/linux/skbuff.h
#	net/core/pktgen.c
#	net/ipv4/esp4.c
#	net/ipv6/esp6.c
#	net/ipv6/exthdrs.c
#	net/ipv6/ip6_output.c
#	net/ncsi/ncsi-cmd.c
#	net/nfc/digital_dep.c
#	net/nfc/digital_technology.c
#	net/nfc/nci/hci.c
#	net/nfc/nci/spi.c
#	net/sctp/output.c
diff --cc drivers/net/arcnet/arc-rawmode.c
index 705e6ce2eb90,8c651fdee039..000000000000
--- a/drivers/net/arcnet/arc-rawmode.c
+++ b/drivers/net/arcnet/arc-rawmode.c
@@@ -31,58 -33,7 +31,89 @@@
  #include <net/arp.h>
  #include <linux/netdevice.h>
  #include <linux/skbuff.h>
 -#include "arcdevice.h"
 +#include <linux/arcdevice.h>
 +
 +#define VERSION "arcnet: raw mode (`r') encapsulation support loaded.\n"
 +
 +
 +static void rx(struct net_device *dev, int bufnum,
 +	       struct archdr *pkthdr, int length);
 +static int build_header(struct sk_buff *skb, struct net_device *dev,
++<<<<<<< HEAD
 +			unsigned short type, uint8_t daddr);
++=======
++			unsigned short type, uint8_t daddr)
++{
++	int hdr_size = ARC_HDR_SIZE;
++	struct archdr *pkt = skb_push(skb, hdr_size);
++
++	/* Set the source hardware address.
++	 *
++	 * This is pretty pointless for most purposes, but it can help in
++	 * debugging.  ARCnet does not allow us to change the source address
++	 * in the actual packet sent.
++	 */
++	pkt->hard.source = *dev->dev_addr;
++
++	/* see linux/net/ethernet/eth.c to see where I got the following */
++
++	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
++		/* FIXME: fill in the last byte of the dest ipaddr here
++		 * to better comply with RFC1051 in "noarp" mode.
++		 */
++		pkt->hard.dest = 0;
++		return hdr_size;
++	}
++	/* otherwise, just fill it in and go! */
++	pkt->hard.dest = daddr;
++
++	return hdr_size;	/* success */
++}
++
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
 +static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 +		      int bufnum);
 +
 +static struct ArcProto rawmode_proto =
 +{
 +	.suffix		= 'r',
 +	.mtu		= XMTU,
 +	.rx		= rx,
 +	.build_header	= build_header,
 +	.prepare_tx	= prepare_tx,
 +	.continue_tx    = NULL,
 +	.ack_tx         = NULL
 +};
 +
 +
 +static int __init arcnet_raw_init(void)
 +{
 +	int count;
 +
 +	printk(VERSION);
 +
 +	for (count = 0; count < 256; count++)
 +		if (arc_proto_map[count] == arc_proto_default)
 +			arc_proto_map[count] = &rawmode_proto;
 +
 +	/* for raw mode, we only set the bcast proto if there's no better one */
 +	if (arc_bcast_proto == arc_proto_default)
 +		arc_bcast_proto = &rawmode_proto;
 +
 +	arc_proto_default = &rawmode_proto;
 +	return 0;
 +}
 +
 +static void __exit arcnet_raw_exit(void)
 +{
 +	arcnet_unregister_proto(&rawmode_proto);
 +}
 +
 +module_init(arcnet_raw_init);
 +module_exit(arcnet_raw_exit);
 +
 +MODULE_LICENSE("GPL");
 +
  
  /* packet receiver */
  static void rx(struct net_device *dev, int bufnum,
diff --cc drivers/net/arcnet/capmode.c
index 42fce91b71fc,a80f4eb9262d..000000000000
--- a/drivers/net/arcnet/capmode.c
+++ b/drivers/net/arcnet/capmode.c
@@@ -101,12 -101,12 +101,16 @@@ static int build_header(struct sk_buff 
  			uint8_t daddr)
  {
  	int hdr_size = ARC_HDR_SIZE;
++<<<<<<< HEAD
 +	struct archdr *pkt = (struct archdr *) skb_push(skb, hdr_size);
++=======
+ 	struct archdr *pkt = skb_push(skb, hdr_size);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  
 -	arc_printk(D_PROTO, dev, "Preparing header for cap packet %x.\n",
 -		   *((int *)&pkt->soft.cap.cookie[0]));
 -
 -	/* Set the source hardware address.
 +	BUGMSG(D_PROTO, "Preparing header for cap packet %x.\n",
 +	       *((int*)&pkt->soft.cap.cookie[0]));
 +	/*
 +	 * Set the source hardware address.
  	 *
  	 * This is pretty pointless for most purposes, but it can help in
  	 * debugging.  ARCnet does not allow us to change the source address in
diff --cc drivers/net/arcnet/rfc1051.c
index f81db4070a57,a7752a5b647f..000000000000
--- a/drivers/net/arcnet/rfc1051.c
+++ b/drivers/net/arcnet/rfc1051.c
@@@ -169,7 -162,7 +169,11 @@@ static int build_header(struct sk_buff 
  			unsigned short type, uint8_t daddr)
  {
  	int hdr_size = ARC_HDR_SIZE + RFC1051_HDR_SIZE;
++<<<<<<< HEAD
 +	struct archdr *pkt = (struct archdr *) skb_push(skb, hdr_size);
++=======
+ 	struct archdr *pkt = skb_push(skb, hdr_size);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	struct arc_rfc1051 *soft = &pkt->soft.rfc1051;
  
  	/* set the protocol ID according to RFC1051 */
diff --cc drivers/net/arcnet/rfc1201.c
index b71431aae084,a4c856282674..000000000000
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@@ -376,7 -379,7 +376,11 @@@ static int build_header(struct sk_buff 
  {
  	struct arcnet_local *lp = netdev_priv(dev);
  	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
++<<<<<<< HEAD
 +	struct archdr *pkt = (struct archdr *) skb_push(skb, hdr_size);
++=======
+ 	struct archdr *pkt = skb_push(skb, hdr_size);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
  
  	/* set the protocol ID according to RFC1201 */
diff --cc drivers/net/geneve.c
index c4c93ccffa85,d586ad93aaff..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -713,9 -687,8 +713,14 @@@ static int geneve6_build_skb(struct dst
  	if (err)
  		goto free_dst;
  
++<<<<<<< HEAD
 +	gnvh = (struct genevehdr *)__skb_push(skb, sizeof(*gnvh) + opt_len);
 +	geneve_build_header(gnvh, tun_flags, vni, opt_len, opt);
 +
++=======
+ 	gnvh = __skb_push(skb, sizeof(*gnvh) + info->options_len);
+ 	geneve_build_header(gnvh, info);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
  	return 0;
  
diff --cc drivers/net/macsec.c
index 8665a14a86f9,e370d7c894cb..000000000000
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@@ -694,7 -696,8 +694,12 @@@ static struct sk_buff *macsec_encrypt(s
  
  	unprotected_len = skb->len;
  	eth = eth_hdr(skb);
++<<<<<<< HEAD
 +	hh = (struct macsec_eth_header *)skb_push(skb, macsec_extra_len(tx_sc->send_sci));
++=======
+ 	sci_present = send_sci(secy);
+ 	hh = skb_push(skb, macsec_extra_len(sci_present));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	memmove(hh, eth, 2 * ETH_ALEN);
  
  	pn = tx_sa_update_pn(tx_sa, secy);
diff --cc drivers/net/usb/qmi_wwan.c
index 24d5272cdce5,5894e3c9468f..000000000000
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@@ -63,6 -65,191 +63,194 @@@ enum qmi_wwan_quirks 
  	QMI_WWAN_QUIRK_DTR = 1 << 0,	/* needs "set DTR" request */
  };
  
++<<<<<<< HEAD
++=======
+ struct qmimux_hdr {
+ 	u8 pad;
+ 	u8 mux_id;
+ 	__be16 pkt_len;
+ };
+ 
+ struct qmimux_priv {
+ 	struct net_device *real_dev;
+ 	u8 mux_id;
+ };
+ 
+ static int qmimux_open(struct net_device *dev)
+ {
+ 	struct qmimux_priv *priv = netdev_priv(dev);
+ 	struct net_device *real_dev = priv->real_dev;
+ 
+ 	if (!(priv->real_dev->flags & IFF_UP))
+ 		return -ENETDOWN;
+ 
+ 	if (netif_carrier_ok(real_dev))
+ 		netif_carrier_on(dev);
+ 	return 0;
+ }
+ 
+ static int qmimux_stop(struct net_device *dev)
+ {
+ 	netif_carrier_off(dev);
+ 	return 0;
+ }
+ 
+ static netdev_tx_t qmimux_start_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct qmimux_priv *priv = netdev_priv(dev);
+ 	unsigned int len = skb->len;
+ 	struct qmimux_hdr *hdr;
+ 
+ 	hdr = skb_push(skb, sizeof(struct qmimux_hdr));
+ 	hdr->pad = 0;
+ 	hdr->mux_id = priv->mux_id;
+ 	hdr->pkt_len = cpu_to_be16(len);
+ 	skb->dev = priv->real_dev;
+ 	return dev_queue_xmit(skb);
+ }
+ 
+ static const struct net_device_ops qmimux_netdev_ops = {
+ 	.ndo_open       = qmimux_open,
+ 	.ndo_stop       = qmimux_stop,
+ 	.ndo_start_xmit = qmimux_start_xmit,
+ };
+ 
+ static void qmimux_setup(struct net_device *dev)
+ {
+ 	dev->header_ops      = NULL;  /* No header */
+ 	dev->type            = ARPHRD_NONE;
+ 	dev->hard_header_len = 0;
+ 	dev->addr_len        = 0;
+ 	dev->flags           = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+ 	dev->netdev_ops      = &qmimux_netdev_ops;
+ 	dev->needs_free_netdev = true;
+ }
+ 
+ static struct net_device *qmimux_find_dev(struct usbnet *dev, u8 mux_id)
+ {
+ 	struct qmimux_priv *priv;
+ 	struct list_head *iter;
+ 	struct net_device *ldev;
+ 
+ 	rcu_read_lock();
+ 	netdev_for_each_upper_dev_rcu(dev->net, ldev, iter) {
+ 		priv = netdev_priv(ldev);
+ 		if (priv->mux_id == mux_id) {
+ 			rcu_read_unlock();
+ 			return ldev;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 	return NULL;
+ }
+ 
+ static bool qmimux_has_slaves(struct usbnet *dev)
+ {
+ 	return !list_empty(&dev->net->adj_list.upper);
+ }
+ 
+ static int qmimux_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+ {
+ 	unsigned int len, offset = sizeof(struct qmimux_hdr);
+ 	struct qmimux_hdr *hdr;
+ 	struct net_device *net;
+ 	struct sk_buff *skbn;
+ 
+ 	while (offset < skb->len) {
+ 		hdr = (struct qmimux_hdr *)skb->data;
+ 		len = be16_to_cpu(hdr->pkt_len);
+ 
+ 		/* drop the packet, bogus length */
+ 		if (offset + len > skb->len)
+ 			return 0;
+ 
+ 		/* control packet, we do not know what to do */
+ 		if (hdr->pad & 0x80)
+ 			goto skip;
+ 
+ 		net = qmimux_find_dev(dev, hdr->mux_id);
+ 		if (!net)
+ 			goto skip;
+ 		skbn = netdev_alloc_skb(net, len);
+ 		if (!skbn)
+ 			return 0;
+ 		skbn->dev = net;
+ 
+ 		switch (skb->data[offset] & 0xf0) {
+ 		case 0x40:
+ 			skbn->protocol = htons(ETH_P_IP);
+ 			break;
+ 		case 0x60:
+ 			skbn->protocol = htons(ETH_P_IPV6);
+ 			break;
+ 		default:
+ 			/* not ip - do not know what to do */
+ 			goto skip;
+ 		}
+ 
+ 		skb_put_data(skbn, skb->data + offset, len);
+ 		if (netif_rx(skbn) != NET_RX_SUCCESS)
+ 			return 0;
+ 
+ skip:
+ 		offset += len + sizeof(struct qmimux_hdr);
+ 	}
+ 	return 1;
+ }
+ 
+ static int qmimux_register_device(struct net_device *real_dev, u8 mux_id)
+ {
+ 	struct net_device *new_dev;
+ 	struct qmimux_priv *priv;
+ 	int err;
+ 
+ 	new_dev = alloc_netdev(sizeof(struct qmimux_priv),
+ 			       "qmimux%d", NET_NAME_UNKNOWN, qmimux_setup);
+ 	if (!new_dev)
+ 		return -ENOBUFS;
+ 
+ 	dev_net_set(new_dev, dev_net(real_dev));
+ 	priv = netdev_priv(new_dev);
+ 	priv->mux_id = mux_id;
+ 	priv->real_dev = real_dev;
+ 
+ 	err = register_netdevice(new_dev);
+ 	if (err < 0)
+ 		goto out_free_newdev;
+ 
+ 	/* Account for reference in struct qmimux_priv_priv */
+ 	dev_hold(real_dev);
+ 
+ 	err = netdev_upper_dev_link(real_dev, new_dev);
+ 	if (err)
+ 		goto out_unregister_netdev;
+ 
+ 	netif_stacked_transfer_operstate(real_dev, new_dev);
+ 
+ 	return 0;
+ 
+ out_unregister_netdev:
+ 	unregister_netdevice(new_dev);
+ 	dev_put(real_dev);
+ 
+ out_free_newdev:
+ 	free_netdev(new_dev);
+ 	return err;
+ }
+ 
+ static void qmimux_unregister_device(struct net_device *dev)
+ {
+ 	struct qmimux_priv *priv = netdev_priv(dev);
+ 	struct net_device *real_dev = priv->real_dev;
+ 
+ 	netdev_upper_dev_unlink(real_dev, dev);
+ 	unregister_netdevice(dev);
+ 
+ 	/* Get rid of the reference to real_dev */
+ 	dev_put(real_dev);
+ }
+ 
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  static void qmi_wwan_netdev_setup(struct net_device *net)
  {
  	struct usbnet *dev = netdev_priv(net);
diff --cc drivers/net/wireless/mac80211_hwsim.c
index cb34c7895f2a,c8852acc1462..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -707,6 -1127,53 +707,56 @@@ static void mac80211_hwsim_tx_iter(voi
  	data->receive = true;
  }
  
++<<<<<<< HEAD
++=======
+ static void mac80211_hwsim_add_vendor_rtap(struct sk_buff *skb)
+ {
+ 	/*
+ 	 * To enable this code, #define the HWSIM_RADIOTAP_OUI,
+ 	 * e.g. like this:
+ 	 * #define HWSIM_RADIOTAP_OUI "\x02\x00\x00"
+ 	 * (but you should use a valid OUI, not that)
+ 	 *
+ 	 * If anyone wants to 'donate' a radiotap OUI/subns code
+ 	 * please send a patch removing this #ifdef and changing
+ 	 * the values accordingly.
+ 	 */
+ #ifdef HWSIM_RADIOTAP_OUI
+ 	struct ieee80211_vendor_radiotap *rtap;
+ 
+ 	/*
+ 	 * Note that this code requires the headroom in the SKB
+ 	 * that was allocated earlier.
+ 	 */
+ 	rtap = skb_push(skb, sizeof(*rtap) + 8 + 4);
+ 	rtap->oui[0] = HWSIM_RADIOTAP_OUI[0];
+ 	rtap->oui[1] = HWSIM_RADIOTAP_OUI[1];
+ 	rtap->oui[2] = HWSIM_RADIOTAP_OUI[2];
+ 	rtap->subns = 127;
+ 
+ 	/*
+ 	 * Radiotap vendor namespaces can (and should) also be
+ 	 * split into fields by using the standard radiotap
+ 	 * presence bitmap mechanism. Use just BIT(0) here for
+ 	 * the presence bitmap.
+ 	 */
+ 	rtap->present = BIT(0);
+ 	/* We have 8 bytes of (dummy) data */
+ 	rtap->len = 8;
+ 	/* For testing, also require it to be aligned */
+ 	rtap->align = 8;
+ 	/* And also test that padding works, 4 bytes */
+ 	rtap->pad = 4;
+ 	/* push the data */
+ 	memcpy(rtap->data, "ABCDEFGH", 8);
+ 	/* make sure to clear padding, mac80211 doesn't */
+ 	memset(rtap->data + 8, 0, 4);
+ 
+ 	IEEE80211_SKB_RXCB(skb)->flag |= RX_FLAG_RADIOTAP_VENDOR_DATA;
+ #endif
+ }
+ 
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  static bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,
  					  struct sk_buff *skb,
  					  struct ieee80211_channel *chan)
diff --cc drivers/nfc/pn533.c
index 8f6f2baa930d,6a711b5b9490..000000000000
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@@ -2241,6 -2019,98 +2241,101 @@@ _error
  	return rc;
  }
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
++=======
+ /*
+  * Receive an incoming pn533 frame. skb contains only header and payload.
+  * If skb == NULL, it is a notification that the link below is dead.
+  */
+ void pn533_recv_frame(struct pn533 *dev, struct sk_buff *skb, int status)
+ {
+ 	if (!dev->cmd)
+ 		goto sched_wq;
+ 
+ 	dev->cmd->status = status;
+ 
+ 	if (status != 0) {
+ 		dev_dbg(dev->dev, "%s: Error received: %d\n", __func__, status);
+ 		goto sched_wq;
+ 	}
+ 
+ 	if (skb == NULL) {
+ 		pr_err("NULL Frame -> link is dead\n");
+ 		goto sched_wq;
+ 	}
+ 
+ 	if (pn533_rx_frame_is_ack(skb->data)) {
+ 		dev_dbg(dev->dev, "%s: Received ACK frame\n", __func__);
+ 		dev_kfree_skb(skb);
+ 		return;
+ 	}
+ 
+ 	print_hex_dump_debug("PN533 RX: ", DUMP_PREFIX_NONE, 16, 1, skb->data,
+ 			     dev->ops->rx_frame_size(skb->data), false);
+ 
+ 	if (!dev->ops->rx_is_frame_valid(skb->data, dev)) {
+ 		nfc_err(dev->dev, "Received an invalid frame\n");
+ 		dev->cmd->status = -EIO;
+ 	} else if (!pn533_rx_frame_is_cmd_response(dev, skb->data)) {
+ 		nfc_err(dev->dev, "It it not the response to the last command\n");
+ 		dev->cmd->status = -EIO;
+ 	}
+ 
+ 	dev->cmd->resp = skb;
+ 
+ sched_wq:
+ 	queue_work(dev->wq, &dev->cmd_complete_work);
+ }
+ EXPORT_SYMBOL(pn533_recv_frame);
+ 
+ /* Split the Tx skb into small chunks */
+ static int pn533_fill_fragment_skbs(struct pn533 *dev, struct sk_buff *skb)
+ {
+ 	struct sk_buff *frag;
+ 	int  frag_size;
+ 
+ 	do {
+ 		/* Remaining size */
+ 		if (skb->len > PN533_CMD_DATAFRAME_MAXLEN)
+ 			frag_size = PN533_CMD_DATAFRAME_MAXLEN;
+ 		else
+ 			frag_size = skb->len;
+ 
+ 		/* Allocate and reserve */
+ 		frag = pn533_alloc_skb(dev, frag_size);
+ 		if (!frag) {
+ 			skb_queue_purge(&dev->fragment_skb);
+ 			break;
+ 		}
+ 
+ 		if (!dev->tgt_mode) {
+ 			/* Reserve the TG/MI byte */
+ 			skb_reserve(frag, 1);
+ 
+ 			/* MI + TG */
+ 			if (frag_size  == PN533_CMD_DATAFRAME_MAXLEN)
+ 				*(u8 *)skb_push(frag, sizeof(u8)) =
+ 						(PN533_CMD_MI_MASK | 1);
+ 			else
+ 				*(u8 *)skb_push(frag, sizeof(u8)) =  1; /* TG */
+ 		}
+ 
+ 		skb_put_data(frag, skb->data, frag_size);
+ 
+ 		/* Reduce the size of incoming buffer */
+ 		skb_pull(skb, frag_size);
+ 
+ 		/* Add this to skb_queue */
+ 		skb_queue_tail(&dev->fragment_skb, frag);
+ 
+ 	} while (skb->len > 0);
+ 
+ 	dev_kfree_skb(skb);
+ 
+ 	return skb_queue_len(&dev->fragment_skb);
+ }
+ 
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers):drivers/nfc/pn533/pn533.c
  static int pn533_transceive(struct nfc_dev *nfc_dev,
  			    struct nfc_target *target, struct sk_buff *skb,
  			    data_exchange_cb_t cb, void *cb_context)
@@@ -2287,7 -2148,20 +2382,24 @@@
  			break;
  		}
  	default:
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +		*skb_push(skb, sizeof(u8)) =  1; /*TG*/
++=======
+ 		/* jumbo frame ? */
+ 		if (skb->len > PN533_CMD_DATAEXCH_DATA_MAXLEN) {
+ 			rc = pn533_fill_fragment_skbs(dev, skb);
+ 			if (rc <= 0)
+ 				goto error;
+ 
+ 			skb = skb_dequeue(&dev->fragment_skb);
+ 			if (!skb) {
+ 				rc = -EIO;
+ 				goto error;
+ 			}
+ 		} else {
+ 			*(u8 *)skb_push(skb, sizeof(u8)) =  1; /* TG */
+ 		}
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers):drivers/nfc/pn533/pn533.c
  
  		rc = pn533_send_data_async(dev, PN533_CMD_IN_DATA_EXCHANGE,
  					   skb, pn533_data_exchange_complete,
diff --cc drivers/s390/net/qeth_l3_main.c
index e0c0709219ee,3062cde33a3d..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -2899,26 -2713,30 +2899,30 @@@ static int qeth_l3_hard_start_xmit(stru
  	/* fix hardware limitation: as long as we do not have sbal
  	 * chaining we can not send long frag lists
  	 */
 -	if ((card->info.type != QETH_CARD_TYPE_IQD) &&
 -	    ((use_tso && !qeth_l3_get_elements_no_tso(card, new_skb, 1)) ||
 -	     (!use_tso && !qeth_get_elements_no(card, new_skb, 0, 0)))) {
 -		int lin_rc = skb_linearize(new_skb);
 -
 -		if (card->options.performance_stats) {
 -			if (lin_rc)
 -				card->perf_stats.tx_linfail++;
 -			else
 +	if (large_send) {
 +		if (qeth_l3_tso_elements(new_skb) + 1 > 16) {
 +			if (skb_linearize(new_skb))
 +				goto tx_drop;
 +			if (card->options.performance_stats)
  				card->perf_stats.tx_lin++;
  		}
 -		if (lin_rc)
 -			goto tx_drop;
  	}
  
++<<<<<<< HEAD
 +	if (large_send && (cast_type == RTN_UNSPEC)) {
 +		hdr = (struct qeth_hdr *)skb_push(new_skb,
 +						sizeof(struct qeth_hdr_tso));
++=======
+ 	if (use_tso) {
+ 		hdr = skb_push(new_skb, sizeof(struct qeth_hdr_tso));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  		memset(hdr, 0, sizeof(struct qeth_hdr_tso));
  		qeth_l3_fill_header(card, hdr, new_skb, ipv, cast_type);
  		qeth_tso_fill_header(card, hdr, new_skb);
 -		hdr_elements++;
 +		elements_needed++;
  	} else {
  		if (data_offset < 0) {
- 			hdr = (struct qeth_hdr *)skb_push(new_skb,
- 						sizeof(struct qeth_hdr));
+ 			hdr = skb_push(new_skb, sizeof(struct qeth_hdr));
  			qeth_l3_fill_header(card, hdr, new_skb, ipv,
  						cast_type);
  		} else {
diff --cc drivers/staging/wlan-ng/p80211conv.c
index 3df753b51e89,fc8ad33ade9f..000000000000
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@@ -144,15 -145,13 +144,19 @@@ int skb_ether_to_p80211(wlandevice_t *w
  			/* it's DIXII, time for some conversion */
  
  			/* trim off ethernet header */
 -			skb_pull(skb, ETH_HLEN);
 +			skb_pull(skb, WLAN_ETHHDR_LEN);
  
  			/* tack on SNAP */
++<<<<<<< HEAD
 +			e_snap =
 +			    (struct wlan_snap *) skb_push(skb,
 +				sizeof(struct wlan_snap));
++=======
+ 			e_snap = skb_push(skb, sizeof(struct wlan_snap));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  			e_snap->type = htons(proto);
 -			if (ethconv == WLAN_ETHCONV_8021h &&
 -			    p80211_stt_findproto(proto)) {
 +			if (ethconv == WLAN_ETHCONV_8021h
 +			    && p80211_stt_findproto(proto)) {
  				memcpy(e_snap->oui, oui_8021h,
  				       WLAN_IEEE_OUI_LEN);
  			} else {
@@@ -161,9 -160,7 +165,13 @@@
  			}
  
  			/* tack on llc */
++<<<<<<< HEAD
 +			e_llc =
 +			    (struct wlan_llc *) skb_push(skb,
 +				sizeof(struct wlan_llc));
++=======
+ 			e_llc = skb_push(skb, sizeof(struct wlan_llc));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
  			e_llc->ssap = 0xAA;
  			e_llc->ctl = 0x03;
@@@ -405,9 -403,9 +413,15 @@@ int skb_p80211_to_ether(wlandevice_t *w
  		skb_pull(skb, payload_offset);
  
  		/* create 802.3 header at beginning of skb. */
++<<<<<<< HEAD
 +		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
 +		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
 +		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
++=======
+ 		e_hdr = skb_push(skb, ETH_HLEN);
+ 		ether_addr_copy(e_hdr->daddr, daddr);
+ 		ether_addr_copy(e_hdr->saddr, saddr);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  		e_hdr->type = htons(payload_length);
  
  		/* chop off the 802.11 CRC */
@@@ -445,10 -444,10 +459,14 @@@
  		skb_pull(skb, sizeof(struct wlan_snap));
  
  		/* create 802.3 header at beginning of skb. */
++<<<<<<< HEAD
 +		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
++=======
+ 		e_hdr = skb_push(skb, ETH_HLEN);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  		e_hdr->type = e_snap->type;
 -		ether_addr_copy(e_hdr->daddr, daddr);
 -		ether_addr_copy(e_hdr->saddr, saddr);
 +		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
 +		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
  
  		/* chop off the 802.11 CRC */
  		skb_trim(skb, skb->len - WLAN_CRC_LEN);
@@@ -472,9 -471,9 +490,15 @@@
  		skb_pull(skb, payload_offset);
  
  		/* create 802.3 header at beginning of skb. */
++<<<<<<< HEAD
 +		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
 +		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
 +		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
++=======
+ 		e_hdr = skb_push(skb, ETH_HLEN);
+ 		ether_addr_copy(e_hdr->daddr, daddr);
+ 		ether_addr_copy(e_hdr->saddr, saddr);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  		e_hdr->type = htons(payload_length);
  
  		/* chop off the 802.11 CRC */
diff --cc include/linux/skbuff.h
index 28aefdf34562,46bd514e719c..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -1928,8 -1904,27 +1928,32 @@@ static inline unsigned char *__skb_put(
  	return tmp;
  }
  
++<<<<<<< HEAD
 +unsigned char *skb_push(struct sk_buff *skb, unsigned int len);
 +static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
++=======
+ static inline void *skb_put_zero(struct sk_buff *skb, unsigned int len)
+ {
+ 	void *tmp = skb_put(skb, len);
+ 
+ 	memset(tmp, 0, len);
+ 
+ 	return tmp;
+ }
+ 
+ static inline void *skb_put_data(struct sk_buff *skb, const void *data,
+ 				 unsigned int len)
+ {
+ 	void *tmp = skb_put(skb, len);
+ 
+ 	memcpy(tmp, data, len);
+ 
+ 	return tmp;
+ }
+ 
+ void *skb_push(struct sk_buff *skb, unsigned int len);
+ static inline void *__skb_push(struct sk_buff *skb, unsigned int len)
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  {
  	skb->data -= len;
  	skb->len  += len;
diff --cc net/core/pktgen.c
index 22d5c06199fd,2dd42c5b0366..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -2575,9 -2675,9 +2575,15 @@@ static int process_ipsec(struct pktgen_
  				goto err;
  			}
  			/* restore ll */
++<<<<<<< HEAD
 +			eth = (__u8 *) skb_push(skb, ETH_HLEN);
 +			memcpy(eth, pkt_dev->hh, 12);
 +			*(u16 *) &eth[12] = protocol;
++=======
+ 			eth = skb_push(skb, ETH_HLEN);
+ 			memcpy(eth, pkt_dev->hh, 2 * ETH_ALEN);
+ 			eth->h_proto = protocol;
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  
  			/* Update IPv4 header len as well as checksum value */
  			iph = ip_hdr(skb);
@@@ -2744,8 -2844,8 +2750,13 @@@ static struct sk_buff *fill_packet_ipv4
  	skb_reserve(skb, 16);
  
  	/*  Reserve for ethernet and IP header  */
++<<<<<<< HEAD
 +	eth = (__u8 *) skb_push(skb, 14);
 +	mpls = (__be32 *)skb_put(skb, pkt_dev->nr_labels*sizeof(__u32));
++=======
+ 	eth = skb_push(skb, 14);
+ 	mpls = skb_put(skb, pkt_dev->nr_labels * sizeof(__u32));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	if (pkt_dev->nr_labels)
  		mpls_push(mpls, pkt_dev);
  
@@@ -2872,8 -2972,8 +2883,13 @@@ static struct sk_buff *fill_packet_ipv6
  	skb_reserve(skb, 16);
  
  	/*  Reserve for ethernet and IP header  */
++<<<<<<< HEAD
 +	eth = (__u8 *) skb_push(skb, 14);
 +	mpls = (__be32 *)skb_put(skb, pkt_dev->nr_labels*sizeof(__u32));
++=======
+ 	eth = skb_push(skb, 14);
+ 	mpls = skb_put(skb, pkt_dev->nr_labels * sizeof(__u32));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	if (pkt_dev->nr_labels)
  		mpls_push(mpls, pkt_dev);
  
diff --cc net/ipv4/esp4.c
index 9cf3f9a29479,1f18b4650253..000000000000
--- a/net/ipv4/esp4.c
+++ b/net/ipv4/esp4.c
@@@ -369,6 -593,37 +369,40 @@@ static void esp_input_done(struct crypt
  	xfrm_input_resume(skb, esp_input_done2(skb, err));
  }
  
++<<<<<<< HEAD
++=======
+ static void esp_input_restore_header(struct sk_buff *skb)
+ {
+ 	esp_restore_header(skb, 0);
+ 	__skb_pull(skb, 4);
+ }
+ 
+ static void esp_input_set_header(struct sk_buff *skb, __be32 *seqhi)
+ {
+ 	struct xfrm_state *x = xfrm_input_state(skb);
+ 	struct ip_esp_hdr *esph = (struct ip_esp_hdr *)skb->data;
+ 
+ 	/* For ESN we move the header forward by 4 bytes to
+ 	 * accomodate the high bits.  We will move it back after
+ 	 * decryption.
+ 	 */
+ 	if ((x->props.flags & XFRM_STATE_ESN)) {
+ 		esph = skb_push(skb, 4);
+ 		*seqhi = esph->spi;
+ 		esph->spi = esph->seq_no;
+ 		esph->seq_no = XFRM_SKB_CB(skb)->seq.input.hi;
+ 	}
+ }
+ 
+ static void esp_input_done_esn(struct crypto_async_request *base, int err)
+ {
+ 	struct sk_buff *skb = base->data;
+ 
+ 	esp_input_restore_header(skb);
+ 	esp_input_done(base, err);
+ }
+ 
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  /*
   * Note: detecting truncated vs. non-truncated authentication data is very
   * expensive, so we only support truncated data, which is the recommended
diff --cc net/ipv6/esp6.c
index 1824a6cf9bf2,d8b40ff4b2e6..000000000000
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@@ -320,7 -519,38 +320,42 @@@ static void esp_input_done(struct crypt
  {
  	struct sk_buff *skb = base->data;
  
++<<<<<<< HEAD
 +	xfrm_input_resume(skb, esp_input_done2(skb, err));
++=======
+ 	xfrm_input_resume(skb, esp6_input_done2(skb, err));
+ }
+ 
+ static void esp_input_restore_header(struct sk_buff *skb)
+ {
+ 	esp_restore_header(skb, 0);
+ 	__skb_pull(skb, 4);
+ }
+ 
+ static void esp_input_set_header(struct sk_buff *skb, __be32 *seqhi)
+ {
+ 	struct xfrm_state *x = xfrm_input_state(skb);
+ 	struct ip_esp_hdr *esph = (struct ip_esp_hdr *)skb->data;
+ 
+ 	/* For ESN we move the header forward by 4 bytes to
+ 	 * accomodate the high bits.  We will move it back after
+ 	 * decryption.
+ 	 */
+ 	if ((x->props.flags & XFRM_STATE_ESN)) {
+ 		esph = skb_push(skb, 4);
+ 		*seqhi = esph->spi;
+ 		esph->spi = esph->seq_no;
+ 		esph->seq_no = XFRM_SKB_CB(skb)->seq.input.hi;
+ 	}
+ }
+ 
+ static void esp_input_done_esn(struct crypto_async_request *base, int err)
+ {
+ 	struct sk_buff *skb = base->data;
+ 
+ 	esp_input_restore_header(skb);
+ 	esp_input_done(base, err);
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  }
  
  static int esp6_input(struct xfrm_state *x, struct sk_buff *skb)
diff --cc net/ipv6/exthdrs.c
index 33dbd6c1a00d,0460af226011..000000000000
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@@ -677,9 -863,67 +677,70 @@@ static void ipv6_push_rthdr(struct sk_b
  	*proto = NEXTHDR_ROUTING;
  }
  
++<<<<<<< HEAD
++=======
+ static void ipv6_push_rthdr4(struct sk_buff *skb, u8 *proto,
+ 			     struct ipv6_rt_hdr *opt,
+ 			     struct in6_addr **addr_p, struct in6_addr *saddr)
+ {
+ 	struct ipv6_sr_hdr *sr_phdr, *sr_ihdr;
+ 	int plen, hops;
+ 
+ 	sr_ihdr = (struct ipv6_sr_hdr *)opt;
+ 	plen = (sr_ihdr->hdrlen + 1) << 3;
+ 
+ 	sr_phdr = skb_push(skb, plen);
+ 	memcpy(sr_phdr, sr_ihdr, sizeof(struct ipv6_sr_hdr));
+ 
+ 	hops = sr_ihdr->first_segment + 1;
+ 	memcpy(sr_phdr->segments + 1, sr_ihdr->segments + 1,
+ 	       (hops - 1) * sizeof(struct in6_addr));
+ 
+ 	sr_phdr->segments[0] = **addr_p;
+ 	*addr_p = &sr_ihdr->segments[hops - 1];
+ 
+ #ifdef CONFIG_IPV6_SEG6_HMAC
+ 	if (sr_has_hmac(sr_phdr)) {
+ 		struct net *net = NULL;
+ 
+ 		if (skb->dev)
+ 			net = dev_net(skb->dev);
+ 		else if (skb->sk)
+ 			net = sock_net(skb->sk);
+ 
+ 		WARN_ON(!net);
+ 
+ 		if (net)
+ 			seg6_push_hmac(net, saddr, sr_phdr);
+ 	}
+ #endif
+ 
+ 	sr_phdr->nexthdr = *proto;
+ 	*proto = NEXTHDR_ROUTING;
+ }
+ 
+ static void ipv6_push_rthdr(struct sk_buff *skb, u8 *proto,
+ 			    struct ipv6_rt_hdr *opt,
+ 			    struct in6_addr **addr_p, struct in6_addr *saddr)
+ {
+ 	switch (opt->type) {
+ 	case IPV6_SRCRT_TYPE_0:
+ 	case IPV6_SRCRT_STRICT:
+ 	case IPV6_SRCRT_TYPE_2:
+ 		ipv6_push_rthdr0(skb, proto, opt, addr_p, saddr);
+ 		break;
+ 	case IPV6_SRCRT_TYPE_4:
+ 		ipv6_push_rthdr4(skb, proto, opt, addr_p, saddr);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  static void ipv6_push_exthdr(struct sk_buff *skb, u8 *proto, u8 type, struct ipv6_opt_hdr *opt)
  {
- 	struct ipv6_opt_hdr *h = (struct ipv6_opt_hdr *)skb_push(skb, ipv6_optlen(opt));
+ 	struct ipv6_opt_hdr *h = skb_push(skb, ipv6_optlen(opt));
  
  	memcpy(h, opt, ipv6_optlen(opt));
  	h->nexthdr = *proto;
diff --cc net/ipv6/ip6_output.c
index b1ac560a24f7,8b8efb0e55bf..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -613,11 -675,14 +613,15 @@@ int ip6_fragment(struct sock *sk, struc
  		if (!tmp_hdr) {
  			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
  				      IPSTATS_MIB_FRAGFAILS);
 -			err = -ENOMEM;
 -			goto fail;
 +			return -ENOMEM;
  		}
 -		frag = skb_shinfo(skb)->frag_list;
 -		skb_frag_list_init(skb);
  
  		__skb_pull(skb, hlen);
++<<<<<<< HEAD
 +		fh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));
++=======
+ 		fh = __skb_push(skb, sizeof(struct frag_hdr));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  		__skb_push(skb, hlen);
  		skb_reset_network_header(skb);
  		memcpy(skb_network_header(skb), tmp_hdr, hlen);
@@@ -641,7 -706,7 +645,11 @@@
  			if (frag) {
  				frag->ip_summed = CHECKSUM_NONE;
  				skb_reset_transport_header(frag);
++<<<<<<< HEAD
 +				fh = (struct frag_hdr*)__skb_push(frag, sizeof(struct frag_hdr));
++=======
+ 				fh = __skb_push(frag, sizeof(struct frag_hdr));
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  				__skb_push(frag, hlen);
  				skb_reset_network_header(frag);
  				memcpy(skb_network_header(frag), tmp_hdr,
diff --cc net/sctp/output.c
index 16f21de6025f,89cee1482d35..000000000000
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@@ -734,10 -522,114 +734,118 @@@ int sctp_packet_transmit(struct sctp_pa
  			sk_setup_caps(sk, tp->dst);
  		}
  		rcu_read_unlock();
++<<<<<<< HEAD
++=======
+ 		goto chksum;
+ 	}
+ 
+ 	if (sctp_checksum_disable)
+ 		return 1;
+ 
+ 	if (!(skb_dst(head)->dev->features & NETIF_F_SCTP_CRC) ||
+ 	    dst_xfrm(skb_dst(head)) || packet->ipfragok) {
+ 		struct sctphdr *sh =
+ 			(struct sctphdr *)skb_transport_header(head);
+ 
+ 		sh->checksum = sctp_compute_cksum(head, 0);
+ 	} else {
+ chksum:
+ 		head->ip_summed = CHECKSUM_PARTIAL;
+ 		head->csum_not_inet = 1;
+ 		head->csum_start = skb_transport_header(head) - head->head;
+ 		head->csum_offset = offsetof(struct sctphdr, checksum);
+ 	}
+ 
+ 	return pkt_count;
+ }
+ 
+ /* All packets are sent to the network through this function from
+  * sctp_outq_tail().
+  *
+  * The return value is always 0 for now.
+  */
+ int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
+ {
+ 	struct sctp_transport *tp = packet->transport;
+ 	struct sctp_association *asoc = tp->asoc;
+ 	struct sctp_chunk *chunk, *tmp;
+ 	int pkt_count, gso = 0;
+ 	struct dst_entry *dst;
+ 	struct sk_buff *head;
+ 	struct sctphdr *sh;
+ 	struct sock *sk;
+ 
+ 	pr_debug("%s: packet:%p\n", __func__, packet);
+ 	if (list_empty(&packet->chunk_list))
+ 		return 0;
+ 	chunk = list_entry(packet->chunk_list.next, struct sctp_chunk, list);
+ 	sk = chunk->skb->sk;
+ 
+ 	/* check gso */
+ 	if (packet->size > tp->pathmtu && !packet->ipfragok) {
+ 		if (!sk_can_gso(sk)) {
+ 			pr_err_once("Trying to GSO but underlying device doesn't support it.");
+ 			goto out;
+ 		}
+ 		gso = 1;
+ 	}
+ 
+ 	/* alloc head skb */
+ 	head = alloc_skb((gso ? packet->overhead : packet->size) +
+ 			 MAX_HEADER, gfp);
+ 	if (!head)
+ 		goto out;
+ 	skb_reserve(head, packet->overhead + MAX_HEADER);
+ 	sctp_packet_set_owner_w(head, sk);
+ 
+ 	/* set sctp header */
+ 	sh = skb_push(head, sizeof(struct sctphdr));
+ 	skb_reset_transport_header(head);
+ 	sh->source = htons(packet->source_port);
+ 	sh->dest = htons(packet->destination_port);
+ 	sh->vtag = htonl(packet->vtag);
+ 	sh->checksum = 0;
+ 
+ 	/* drop packet if no dst */
+ 	dst = dst_clone(tp->dst);
+ 	if (!dst) {
+ 		IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);
+ 		kfree_skb(head);
+ 		goto out;
+ 	}
+ 	skb_dst_set(head, dst);
+ 
+ 	/* pack up chunks */
+ 	pkt_count = sctp_packet_pack(packet, head, gso, gfp);
+ 	if (!pkt_count) {
+ 		kfree_skb(head);
+ 		goto out;
+ 	}
+ 	pr_debug("***sctp_transmit_packet*** skb->len:%d\n", head->len);
+ 
+ 	/* start autoclose timer */
+ 	if (packet->has_data && sctp_state(asoc, ESTABLISHED) &&
+ 	    asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {
+ 		struct timer_list *timer =
+ 			&asoc->timers[SCTP_EVENT_TIMEOUT_AUTOCLOSE];
+ 		unsigned long timeout =
+ 			asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE];
+ 
+ 		if (!mod_timer(timer, jiffies + timeout))
+ 			sctp_association_hold(asoc);
+ 	}
+ 
+ 	/* sctp xmit */
+ 	tp->af_specific->ecn_capable(sk);
+ 	if (asoc) {
+ 		asoc->stats.opackets += pkt_count;
+ 		if (asoc->peer.last_sent_to != tp)
+ 			asoc->peer.last_sent_to = tp;
++>>>>>>> d58ff3512284 (networking: make skb_push & __skb_push return void pointers)
  	}
  	head->ignore_df = packet->ipfragok;
 -	if (tp->dst_pending_confirm)
 +	confirm = tp->dst_pending_confirm;
 +	if (confirm)
  		skb_set_dst_pending_confirm(head, 1);
  	/* neighbour should be confirmed on successful transmission or
  	 * positive error
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_netdev.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
* Unmerged path drivers/net/gtp.c
* Unmerged path drivers/net/vrf.c
* Unmerged path drivers/net/wireless/mediatek/mt7601u/tx.c
* Unmerged path drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
* Unmerged path drivers/net/wireless/st/cw1200/txrx.c
* Unmerged path drivers/nfc/fdp/i2c.c
* Unmerged path drivers/nfc/nfcmrvl/main.c
* Unmerged path drivers/nfc/st-nci/ndlc.c
* Unmerged path drivers/nfc/st21nfca/core.c
* Unmerged path drivers/nfc/st21nfca/dep.c
* Unmerged path drivers/nfc/st21nfca/i2c.c
* Unmerged path drivers/staging/wilc1000/linux_mon.c
* Unmerged path net/ncsi/ncsi-cmd.c
* Unmerged path net/nfc/digital_dep.c
* Unmerged path net/nfc/digital_technology.c
* Unmerged path net/nfc/nci/hci.c
* Unmerged path net/nfc/nci/spi.c
diff --git a/drivers/atm/solos-pci.c b/drivers/atm/solos-pci.c
index 32784d18d1f7..f3e3bd7d3dac 100644
--- a/drivers/atm/solos-pci.c
+++ b/drivers/atm/solos-pci.c
@@ -1160,7 +1160,7 @@ static int psend(struct atm_vcc *vcc, struct sk_buff *skb)
 		}
 	}
 
-	header = (void *)skb_push(skb, sizeof(*header));
+	header = skb_push(skb, sizeof(*header));
 
 	/* This does _not_ include the size of the header */
 	header->size = cpu_to_le16(pktlen);
diff --git a/drivers/bluetooth/bpa10x.c b/drivers/bluetooth/bpa10x.c
index a9932fe57d92..48d10cb5c9a1 100644
--- a/drivers/bluetooth/bpa10x.c
+++ b/drivers/bluetooth/bpa10x.c
@@ -297,7 +297,7 @@ static int bpa10x_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
 		return -ENOMEM;
 
 	/* Prepend skb with frame type */
-	*skb_push(skb, 1) = hci_skb_pkt_type(skb);
+	*(u8 *)skb_push(skb, 1) = hci_skb_pkt_type(skb);
 
 	switch (hci_skb_pkt_type(skb)) {
 	case HCI_COMMAND_PKT:
diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 35f4a36ca58d..d783b5cb5568 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -219,7 +219,7 @@ static int fwnet_header_create(struct sk_buff *skb, struct net_device *net,
 {
 	struct fwnet_header *h;
 
-	h = (struct fwnet_header *)skb_push(skb, sizeof(*h));
+	h = skb_push(skb, sizeof(*h));
 	put_unaligned_be16(type, &h->h_proto);
 
 	if (net->flags & (IFF_LOOPBACK | IFF_NOARP)) {
@@ -974,16 +974,14 @@ static int fwnet_send_packet(struct fwnet_packet_task *ptask)
 	tx_len = ptask->max_payload;
 	switch (fwnet_get_hdr_lf(&ptask->hdr)) {
 	case RFC2374_HDR_UNFRAG:
-		bufhdr = (struct rfc2734_header *)
-				skb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);
+		bufhdr = skb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);
 		put_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);
 		break;
 
 	case RFC2374_HDR_FIRSTFRAG:
 	case RFC2374_HDR_INTFRAG:
 	case RFC2374_HDR_LASTFRAG:
-		bufhdr = (struct rfc2734_header *)
-				skb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);
+		bufhdr = skb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);
 		put_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);
 		put_unaligned_be32(ptask->hdr.w1, &bufhdr->w1);
 		break;
diff --git a/drivers/infiniband/hw/cxgb3/iwch_cm.c b/drivers/infiniband/hw/cxgb3/iwch_cm.c
index 07da19ccfd00..982163f1cce4 100644
--- a/drivers/infiniband/hw/cxgb3/iwch_cm.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_cm.c
@@ -514,7 +514,7 @@ static void send_mpa_req(struct iwch_ep *ep, struct sk_buff *skb)
 	set_arp_failure_handler(skb, arp_failure_discard);
 	skb_reset_transport_header(skb);
 	len = skb->len;
-	req = (struct tx_data_wr *) skb_push(skb, sizeof(*req));
+	req = skb_push(skb, sizeof(*req));
 	req->wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_TX_DATA)|F_WR_COMPL);
 	req->wr_lo = htonl(V_WR_TID(ep->hwtid));
 	req->len = htonl(len);
@@ -565,7 +565,7 @@ static int send_mpa_reject(struct iwch_ep *ep, const void *pdata, u8 plen)
 	skb->priority = CPL_PRIORITY_DATA;
 	set_arp_failure_handler(skb, arp_failure_discard);
 	skb_reset_transport_header(skb);
-	req = (struct tx_data_wr *) skb_push(skb, sizeof(*req));
+	req = skb_push(skb, sizeof(*req));
 	req->wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_TX_DATA)|F_WR_COMPL);
 	req->wr_lo = htonl(V_WR_TID(ep->hwtid));
 	req->len = htonl(mpalen);
@@ -616,7 +616,7 @@ static int send_mpa_reply(struct iwch_ep *ep, const void *pdata, u8 plen)
 	set_arp_failure_handler(skb, arp_failure_discard);
 	skb_reset_transport_header(skb);
 	len = skb->len;
-	req = (struct tx_data_wr *) skb_push(skb, sizeof(*req));
+	req = skb_push(skb, sizeof(*req));
 	req->wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_TX_DATA)|F_WR_COMPL);
 	req->wr_lo = htonl(V_WR_TID(ep->hwtid));
 	req->len = htonl(len);
diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c
index c5a62399c28c..383c748dfc58 100644
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -3754,7 +3754,7 @@ static void build_cpl_pass_accept_req(struct sk_buff *skb, int stid , u8 tos)
 	tcp_clear_options(&tmp_opt);
 	tcp_parse_options(skb, &tmp_opt, 0, NULL);
 
-	req = (struct cpl_pass_accept_req *)__skb_push(skb, sizeof(*req));
+	req = __skb_push(skb, sizeof(*req));
 	memset(req, 0, sizeof(*req));
 	req->l2info = cpu_to_be16(SYN_INTF_V(intf) |
 			 SYN_MAC_IDX_V(RX_MACIDX_G(
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 00363cc87a5d..55aa7a11b36e 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -725,7 +725,7 @@ static void push_pseudo_header(struct sk_buff *skb, const char *daddr)
 {
 	struct ipoib_pseudo_header *phdr;
 
-	phdr = (struct ipoib_pseudo_header *)skb_push(skb, sizeof(*phdr));
+	phdr = skb_push(skb, sizeof(*phdr));
 	memcpy(phdr->hwaddr, daddr, INFINIBAND_ALEN);
 }
 
@@ -1161,7 +1161,7 @@ static int ipoib_hard_header(struct sk_buff *skb,
 {
 	struct ipoib_header *header;
 
-	header = (struct ipoib_header *) skb_push(skb, sizeof *header);
+	header = skb_push(skb, sizeof *header);
 
 	header->proto = htons(type);
 	header->reserved = 0;
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_netdev.c
diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c
index 38ceac5053a0..e1dac1625b74 100644
--- a/drivers/isdn/i4l/isdn_ppp.c
+++ b/drivers/isdn/i4l/isdn_ppp.c
@@ -1283,7 +1283,7 @@ isdn_ppp_xmit(struct sk_buff *skb, struct net_device *netdev)
 	/* check if we should pass this packet
 	 * the filter instructions are constructed assuming
 	 * a four-byte PPP header on each packet */
-	*skb_push(skb, 4) = 1; /* indicate outbound */
+	*(u8 *)skb_push(skb, 4) = 1; /* indicate outbound */
 
 	{
 		__be16 *p = (__be16 *)skb->data;
* Unmerged path drivers/net/arcnet/arc-rawmode.c
* Unmerged path drivers/net/arcnet/capmode.c
* Unmerged path drivers/net/arcnet/rfc1051.c
* Unmerged path drivers/net/arcnet/rfc1201.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
diff --git a/drivers/net/ethernet/chelsio/cxgb/sge.c b/drivers/net/ethernet/chelsio/cxgb/sge.c
index 922df2ea94e7..df1d66383b66 100644
--- a/drivers/net/ethernet/chelsio/cxgb/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb/sge.c
@@ -1803,7 +1803,7 @@ netdev_tx_t t1_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		eth_type = skb_network_offset(skb) == ETH_HLEN ?
 			CPL_ETH_II : CPL_ETH_II_VLAN;
 
-		hdr = (struct cpl_tx_pkt_lso *)skb_push(skb, sizeof(*hdr));
+		hdr = skb_push(skb, sizeof(*hdr));
 		hdr->opcode = CPL_TX_PKT_LSO;
 		hdr->ip_csum_dis = hdr->l4_csum_dis = 0;
 		hdr->ip_hdr_words = ip_hdr(skb)->ihl;
@@ -1851,7 +1851,7 @@ netdev_tx_t t1_start_xmit(struct sk_buff *skb, struct net_device *dev)
 			}
 		}
 
-		cpl = (struct cpl_tx_pkt *)__skb_push(skb, sizeof(*cpl));
+		cpl = __skb_push(skb, sizeof(*cpl));
 		cpl->opcode = CPL_TX_PKT;
 		cpl->ip_csum_dis = 1;    /* SW calculates IP csum */
 		cpl->l4_csum_dis = skb->ip_summed == CHECKSUM_PARTIAL ? 0 : 1;
diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 8c3c26ff4738..db1b353de94d 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -1995,7 +1995,7 @@ static int gfar_enet_open(struct net_device *dev)
 
 static inline struct txfcb *gfar_add_fcb(struct sk_buff *skb)
 {
-	struct txfcb *fcb = (struct txfcb *)skb_push(skb, GMAC_FCB_LEN);
+	struct txfcb *fcb = skb_push(skb, GMAC_FCB_LEN);
 
 	memset(fcb, 0, GMAC_FCB_LEN);
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
index 5621dcfda4f1..46325566f05b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
@@ -132,7 +132,7 @@ static struct sk_buff *mlx5e_test_get_udp_skb(struct mlx5e_priv *priv)
 	skb_reserve(skb, NET_IP_ALIGN);
 
 	/*  Reserve for ethernet and IP header  */
-	ethh = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+	ethh = skb_push(skb, ETH_HLEN);
 	skb_reset_mac_header(skb);
 
 	skb_set_network_header(skb, skb->len);
diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c
index f9a24a063e1b..70686ad5d124 100644
--- a/drivers/net/ethernet/sun/niu.c
+++ b/drivers/net/ethernet/sun/niu.c
@@ -6675,7 +6675,7 @@ static netdev_tx_t niu_start_xmit(struct sk_buff *skb,
 	headroom = align + sizeof(struct tx_pkt_hdr);
 
 	ehdr = (struct ethhdr *) skb->data;
-	tp = (struct tx_pkt_hdr *) skb_push(skb, headroom);
+	tp = skb_push(skb, headroom);
 
 	len = skb->len - sizeof(struct tx_pkt_hdr);
 	tp->flags = cpu_to_le64(niu_compute_tx_flags(skb, ehdr, align, len));
diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_net.c b/drivers/net/ethernet/toshiba/ps3_gelic_net.c
index ad32af67e618..7c32ec320309 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_net.c
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_net.c
@@ -754,7 +754,7 @@ static struct sk_buff *gelic_put_vlan_tag(struct sk_buff *skb,
 			return NULL;
 		dev_kfree_skb_any(sk_tmp);
 	}
-	veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);
+	veth = skb_push(skb, VLAN_HLEN);
 
 	/* Move the mac addresses to the top of buffer */
 	memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);
* Unmerged path drivers/net/geneve.c
* Unmerged path drivers/net/gtp.c
diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 91d46c3c11b0..98910ac9cc7d 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1426,7 +1426,7 @@ static netdev_tx_t rr_start_xmit(struct sk_buff *skb,
 		skb = new_skb;
 	}
 
-	ifield = (u32 *)skb_push(skb, 8);
+	ifield = skb_push(skb, 8);
 
 	ifield[0] = 0;
 	ifield[1] = hcb->ifield;
* Unmerged path drivers/net/macsec.c
diff --git a/drivers/net/ppp/ppp_async.c b/drivers/net/ppp/ppp_async.c
index 9c889e0303dd..8711f2af34a8 100644
--- a/drivers/net/ppp/ppp_async.c
+++ b/drivers/net/ppp/ppp_async.c
@@ -802,7 +802,7 @@ process_input_packet(struct asyncppp *ap)
 	proto = p[0];
 	if (proto & 1) {
 		/* protocol is compressed */
-		skb_push(skb, 1)[0] = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
 	} else {
 		if (skb->len < 2)
 			goto err;
diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
index 565165b4d88a..68ba33970572 100644
--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -1181,7 +1181,7 @@ ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
 		/* check if we should pass this packet */
 		/* the filter instructions are constructed assuming
 		   a four-byte PPP header on each packet */
-		*skb_push(skb, 2) = 1;
+		*(u8 *)skb_push(skb, 2) = 1;
 		if (ppp->pass_filter &&
 		    sk_run_filter(skb, ppp->pass_filter) == 0) {
 			if (ppp->debug & 1)
@@ -1815,7 +1815,7 @@ ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)
 			if (skb_unclone(skb, GFP_ATOMIC))
 				goto err;
 
-			*skb_push(skb, 2) = 0;
+			*(u8 *)skb_push(skb, 2) = 0;
 			if (ppp->pass_filter &&
 			    sk_run_filter(skb, ppp->pass_filter) == 0) {
 				if (ppp->debug & 1)
@@ -1947,7 +1947,7 @@ ppp_receive_mp_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)
 	 * Do protocol ID decompression on the first fragment of each packet.
 	 */
 	if ((PPP_MP_CB(skb)->BEbits & B) && (skb->data[0] & 1))
-		*skb_push(skb, 1) = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
 
 	/*
 	 * Expand sequence number to 32 bits, making it as close
diff --git a/drivers/net/ppp/ppp_synctty.c b/drivers/net/ppp/ppp_synctty.c
index 925d3e295bac..0741ba835986 100644
--- a/drivers/net/ppp/ppp_synctty.c
+++ b/drivers/net/ppp/ppp_synctty.c
@@ -712,7 +712,7 @@ ppp_sync_input(struct syncppp *ap, const unsigned char *buf,
 	/* decompress protocol field if compressed */
 	if (p[0] & 1) {
 		/* protocol is compressed */
-		skb_push(skb, 1)[0] = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
 	} else if (skb->len < 2)
 		goto err;
 
diff --git a/drivers/net/ppp/pptp.c b/drivers/net/ppp/pptp.c
index 7521b5f8be9c..2cb8f2ee2349 100644
--- a/drivers/net/ppp/pptp.c
+++ b/drivers/net/ppp/pptp.c
@@ -328,7 +328,7 @@ allow_packet:
 
 		if ((*skb->data) & 1) {
 			/* protocol is compressed */
-			skb_push(skb, 1)[0] = 0;
+			*(u8 *)skb_push(skb, 1) = 0;
 		}
 
 		skb->ip_summed = CHECKSUM_NONE;
diff --git a/drivers/net/usb/gl620a.c b/drivers/net/usb/gl620a.c
index 1cc24e6f23e2..cbb55123f35a 100644
--- a/drivers/net/usb/gl620a.c
+++ b/drivers/net/usb/gl620a.c
@@ -175,7 +175,7 @@ genelink_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
 	}
 
 	// attach the packet count to the header
-	packet_count = (__le32 *) skb_push(skb, (4 + 4*1));
+	packet_count = skb_push(skb, (4 + 4 * 1));
 	packet_len = packet_count + 1;
 
 	*packet_count = cpu_to_le32(1);
diff --git a/drivers/net/usb/int51x1.c b/drivers/net/usb/int51x1.c
index 4ff70b22c6ee..c26774ac382f 100644
--- a/drivers/net/usb/int51x1.c
+++ b/drivers/net/usb/int51x1.c
@@ -106,7 +106,7 @@ static struct sk_buff *int51x1_tx_fixup(struct usbnet *dev,
 	pack_len += need_tail;
 	pack_len &= 0x07ff;
 
-	len = (__le16 *) __skb_push(skb, INT51X1_HEADER_SIZE);
+	len = __skb_push(skb, INT51X1_HEADER_SIZE);
 	*len = cpu_to_le16(pack_len);
 
 	if(need_tail)
diff --git a/drivers/net/usb/kaweth.c b/drivers/net/usb/kaweth.c
index 66b34ddbe216..9c56c8e8fbeb 100644
--- a/drivers/net/usb/kaweth.c
+++ b/drivers/net/usb/kaweth.c
@@ -817,7 +817,7 @@ static netdev_tx_t kaweth_start_xmit(struct sk_buff *skb,
 		}
 	}
 
-	private_header = (__le16 *)__skb_push(skb, 2);
+	private_header = __skb_push(skb, 2);
 	*private_header = cpu_to_le16(skb->len-2);
 	kaweth->tx_skb = skb;
 
diff --git a/drivers/net/usb/lg-vl600.c b/drivers/net/usb/lg-vl600.c
index 5714107533bb..809e658b1a0b 100644
--- a/drivers/net/usb/lg-vl600.c
+++ b/drivers/net/usb/lg-vl600.c
@@ -304,7 +304,7 @@ encapsulate:
 	memset(&packet->dummy, 0, sizeof(packet->dummy));
 	packet->len = cpu_to_le32(orig_len);
 
-	frame = (struct vl600_frame_hdr *) skb_push(skb, sizeof(*frame));
+	frame = skb_push(skb, sizeof(*frame));
 	memset(frame, 0, sizeof(*frame));
 	frame->len = cpu_to_le32(full_len);
 	frame->serial = cpu_to_le32(serial++);
diff --git a/drivers/net/usb/net1080.c b/drivers/net/usb/net1080.c
index 4cbdb1307f3e..dc2abced965c 100644
--- a/drivers/net/usb/net1080.c
+++ b/drivers/net/usb/net1080.c
@@ -475,7 +475,7 @@ net1080_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
 
 encapsulate:
 	/* header first */
-	header = (struct nc_header *) skb_push(skb, sizeof *header);
+	header = skb_push(skb, sizeof *header);
 	header->hdr_len = cpu_to_le16(sizeof (*header));
 	header->packet_len = cpu_to_le16(len);
 	header->packet_id = cpu_to_le16((u16)dev->xid++);
* Unmerged path drivers/net/usb/qmi_wwan.c
diff --git a/drivers/net/usb/rndis_host.c b/drivers/net/usb/rndis_host.c
index 4f4f71b2966b..bff240f06991 100644
--- a/drivers/net/usb/rndis_host.c
+++ b/drivers/net/usb/rndis_host.c
@@ -577,7 +577,7 @@ rndis_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
 	 * packets; Linux minimizes wasted bandwidth through tx queues.
 	 */
 fill:
-	hdr = (void *) __skb_push(skb, sizeof *hdr);
+	hdr = __skb_push(skb, sizeof *hdr);
 	memset(hdr, 0, sizeof *hdr);
 	hdr->msg_type = cpu_to_le32(RNDIS_MSG_PACKET);
 	hdr->msg_len = cpu_to_le32(skb->len);
* Unmerged path drivers/net/vrf.c
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index fcdb95049162..24feffee66bf 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1759,7 +1759,7 @@ static int vxlan_build_skb(struct sk_buff *skb, struct dst_entry *dst,
 	if (err)
 		goto out_free;
 
-	vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));
+	vxh = __skb_push(skb, sizeof(*vxh));
 	vxh->vx_flags = VXLAN_HF_VNI;
 	vxh->vx_vni = vxlan_vni_field(vni);
 
diff --git a/drivers/net/wimax/i2400m/netdev.c b/drivers/net/wimax/i2400m/netdev.c
index 47ef231a031a..da3cc95a3290 100644
--- a/drivers/net/wimax/i2400m/netdev.c
+++ b/drivers/net/wimax/i2400m/netdev.c
@@ -221,7 +221,7 @@ void i2400m_tx_prep_header(struct sk_buff *skb)
 {
 	struct i2400m_pl_data_hdr *pl_hdr;
 	skb_pull(skb, ETH_HLEN);
-	pl_hdr = (struct i2400m_pl_data_hdr *) skb_push(skb, sizeof(*pl_hdr));
+	pl_hdr = skb_push(skb, sizeof(*pl_hdr));
 	pl_hdr->reserved = 0;
 }
 
diff --git a/drivers/net/wireless/adm8211.c b/drivers/net/wireless/adm8211.c
index 2b0d1966552a..1bb9d72ae990 100644
--- a/drivers/net/wireless/adm8211.c
+++ b/drivers/net/wireless/adm8211.c
@@ -1685,7 +1685,7 @@ static void adm8211_tx(struct ieee80211_hw *dev,
 	skb_pull(skb, hdrlen);
 	payload_len = skb->len;
 
-	txhdr = (struct adm8211_tx_hdr *) skb_push(skb, sizeof(*txhdr));
+	txhdr = skb_push(skb, sizeof(*txhdr));
 	memset(txhdr, 0, sizeof(*txhdr));
 	memcpy(txhdr->da, ieee80211_get_DA(hdr), ETH_ALEN);
 	txhdr->signal = plcp_signal;
diff --git a/drivers/net/wireless/ath/ar5523/ar5523.c b/drivers/net/wireless/ath/ar5523/ar5523.c
index f92050617ae6..f0edfd40b957 100644
--- a/drivers/net/wireless/ath/ar5523/ar5523.c
+++ b/drivers/net/wireless/ath/ar5523/ar5523.c
@@ -831,8 +831,8 @@ static void ar5523_tx_work_locked(struct ar5523 *ar)
 		data->ar = ar;
 		data->urb = urb;
 
-		desc = (struct ar5523_tx_desc *)skb_push(skb, sizeof(*desc));
-		chunk = (struct ar5523_chunk *)skb_push(skb, sizeof(*chunk));
+		desc = skb_push(skb, sizeof(*desc));
+		chunk = skb_push(skb, sizeof(*chunk));
 
 		chunk->seqnum = 0;
 		chunk->flags = UATH_CFLAGS_FINAL;
diff --git a/drivers/net/wireless/ath/ath6kl/htc_pipe.c b/drivers/net/wireless/ath/ath6kl/htc_pipe.c
index 756fe52a12c8..d4572a3185a2 100644
--- a/drivers/net/wireless/ath/ath6kl/htc_pipe.c
+++ b/drivers/net/wireless/ath/ath6kl/htc_pipe.c
@@ -228,8 +228,7 @@ static int htc_issue_packets(struct htc_target *target,
 		payload_len = packet->act_len;
 
 		/* setup HTC frame header */
-		htc_hdr = (struct htc_frame_hdr *) skb_push(skb,
-							    sizeof(*htc_hdr));
+		htc_hdr = skb_push(skb, sizeof(*htc_hdr));
 		if (!htc_hdr) {
 			WARN_ON_ONCE(1);
 			status = -EINVAL;
diff --git a/drivers/net/wireless/ath/ath9k/hif_usb.c b/drivers/net/wireless/ath/ath9k/hif_usb.c
index 12aa8abbcba4..0d9687a2aa98 100644
--- a/drivers/net/wireless/ath/ath9k/hif_usb.c
+++ b/drivers/net/wireless/ath/ath9k/hif_usb.c
@@ -199,7 +199,7 @@ static int hif_usb_send_mgmt(struct hif_device_usb *hif_dev,
 	cmd->skb = skb;
 	cmd->hif_dev = hif_dev;
 
-	hdr = (__le16 *) skb_push(skb, 4);
+	hdr = skb_push(skb, 4);
 	*hdr++ = cpu_to_le16(skb->len - 4);
 	*hdr++ = cpu_to_le16(ATH_USB_TX_STREAM_MODE_TAG);
 
diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.c b/drivers/net/wireless/ath/ath9k/htc_hst.c
index 8e6dae23669b..6d87f42850d4 100644
--- a/drivers/net/wireless/ath/ath9k/htc_hst.c
+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c
@@ -26,8 +26,7 @@ static int htc_issue_send(struct htc_target *target, struct sk_buff* skb,
 	struct htc_endpoint *endpoint = &target->endpoint[epid];
 	int status;
 
-	hdr = (struct htc_frame_hdr *)
-		skb_push(skb, sizeof(struct htc_frame_hdr));
+	hdr = skb_push(skb, sizeof(struct htc_frame_hdr));
 	hdr->endpoint_id = epid;
 	hdr->flags = flags;
 	hdr->payload_len = cpu_to_be16(len);
diff --git a/drivers/net/wireless/ath/ath9k/wmi.c b/drivers/net/wireless/ath/ath9k/wmi.c
index 9c16e2a6d185..a191bbf4d07e 100644
--- a/drivers/net/wireless/ath/ath9k/wmi.c
+++ b/drivers/net/wireless/ath/ath9k/wmi.c
@@ -277,7 +277,7 @@ static int ath9k_wmi_cmd_issue(struct wmi *wmi,
 	struct wmi_cmd_hdr *hdr;
 	unsigned long flags;
 
-	hdr = (struct wmi_cmd_hdr *) skb_push(skb, sizeof(struct wmi_cmd_hdr));
+	hdr = skb_push(skb, sizeof(struct wmi_cmd_hdr));
 	hdr->command_id = cpu_to_be16(cmd);
 	hdr->seq_no = cpu_to_be16(++wmi->tx_seq_id);
 
diff --git a/drivers/net/wireless/ath/carl9170/tx.c b/drivers/net/wireless/ath/carl9170/tx.c
index 2bf04c9edc98..0cb5b58925dc 100644
--- a/drivers/net/wireless/ath/carl9170/tx.c
+++ b/drivers/net/wireless/ath/carl9170/tx.c
@@ -991,7 +991,7 @@ static int carl9170_tx_prepare(struct ar9170 *ar,
 	else
 		cvif = NULL;
 
-	txc = (void *)skb_push(skb, sizeof(*txc));
+	txc = skb_push(skb, sizeof(*txc));
 	memset(txc, 0, sizeof(*txc));
 
 	SET_VAL(CARL9170_TX_SUPER_MISC_QUEUE, txc->s.misc, hw_queue);
diff --git a/drivers/net/wireless/ath/wil6210/txrx.c b/drivers/net/wireless/ath/wil6210/txrx.c
index 072182e527e6..e6a70a498e37 100644
--- a/drivers/net/wireless/ath/wil6210/txrx.c
+++ b/drivers/net/wireless/ath/wil6210/txrx.c
@@ -342,7 +342,7 @@ static void wil_rx_add_radiotap_header(struct wil6210_priv *wil,
 		return;
 	}
 
-	rtap_vendor = (void *)skb_push(skb, rtap_len);
+	rtap_vendor = skb_push(skb, rtap_len);
 	memset(rtap_vendor, 0, rtap_len);
 
 	rtap_vendor->rtap.rthdr.it_version = PKTHDR_RADIOTAP_VERSION;
diff --git a/drivers/net/wireless/hostap/hostap_80211_rx.c b/drivers/net/wireless/hostap/hostap_80211_rx.c
index d39e3e24077b..6e614f53d46a 100644
--- a/drivers/net/wireless/hostap/hostap_80211_rx.c
+++ b/drivers/net/wireless/hostap/hostap_80211_rx.c
@@ -131,8 +131,7 @@ int prism2_rx_80211(struct net_device *dev, struct sk_buff *skb,
 
 	if (prism_header == 1) {
 		struct linux_wlan_ng_prism_hdr *hdr;
-		hdr = (struct linux_wlan_ng_prism_hdr *)
-			skb_push(skb, phdrlen);
+		hdr = skb_push(skb, phdrlen);
 		memset(hdr, 0, phdrlen);
 		hdr->msgcode = LWNG_CAP_DID_BASE;
 		hdr->msglen = sizeof(*hdr);
@@ -153,8 +152,7 @@ hdr->f.status = s; hdr->f.len = l; hdr->f.data = d
 #undef LWNG_SETVAL
 	} else if (prism_header == 2) {
 		struct linux_wlan_ng_cap_hdr *hdr;
-		hdr = (struct linux_wlan_ng_cap_hdr *)
-			skb_push(skb, phdrlen);
+		hdr = skb_push(skb, phdrlen);
 		memset(hdr, 0, phdrlen);
 		hdr->version    = htonl(LWNG_CAPHDR_VERSION);
 		hdr->length     = htonl(phdrlen);
@@ -172,7 +170,7 @@ hdr->f.status = s; hdr->f.len = l; hdr->f.data = d
 		hdr->encoding   = htonl(1); /* cck */
 	} else if (prism_header == 3) {
 		struct hostap_radiotap_rx *hdr;
-		hdr = (struct hostap_radiotap_rx *)skb_push(skb, phdrlen);
+		hdr = skb_push(skb, phdrlen);
 		memset(hdr, 0, phdrlen);
 		hdr->hdr.it_len = cpu_to_le16(phdrlen);
 		hdr->hdr.it_present =
diff --git a/drivers/net/wireless/libertas/rx.c b/drivers/net/wireless/libertas/rx.c
index c7366b07b568..1ce57f1b0325 100644
--- a/drivers/net/wireless/libertas/rx.c
+++ b/drivers/net/wireless/libertas/rx.c
@@ -260,7 +260,7 @@ static int process_rxed_802_11_packet(struct lbs_private *priv,
 		goto done;
 	}
 
-	pradiotap_hdr = (void *)skb_push(skb, sizeof(struct rx_radiotap_hdr));
+	pradiotap_hdr = skb_push(skb, sizeof(struct rx_radiotap_hdr));
 	memcpy(pradiotap_hdr, &radiotap_hdr, sizeof(struct rx_radiotap_hdr));
 
 	priv->cur_rate = lbs_fw_index_to_data_rate(prxpd->rx_rate);
diff --git a/drivers/net/wireless/libertas_tf/main.c b/drivers/net/wireless/libertas_tf/main.c
index 088de9d25c39..2457d9ad3ec0 100644
--- a/drivers/net/wireless/libertas_tf/main.c
+++ b/drivers/net/wireless/libertas_tf/main.c
@@ -267,7 +267,7 @@ static void lbtf_tx_work(struct work_struct *work)
 
 	len = skb->len;
 	info  = IEEE80211_SKB_CB(skb);
-	txpd = (struct txpd *)  skb_push(skb, sizeof(struct txpd));
+	txpd = skb_push(skb, sizeof(struct txpd));
 
 	if (priv->surpriseremoved) {
 		dev_kfree_skb_any(skb);
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
* Unmerged path drivers/net/wireless/mediatek/mt7601u/tx.c
diff --git a/drivers/net/wireless/orinoco/main.c b/drivers/net/wireless/orinoco/main.c
index 38ec8d19ac29..289526bc8ab0 100644
--- a/drivers/net/wireless/orinoco/main.c
+++ b/drivers/net/wireless/orinoco/main.c
@@ -407,7 +407,7 @@ int orinoco_process_xmit_skb(struct sk_buff *skb,
 		memcpy(hdr.encap, encaps_hdr, sizeof(encaps_hdr));
 
 		/* Make room for the new header, and copy it in */
-		eh = (struct ethhdr *) skb_push(skb, ENCAPS_OVERHEAD);
+		eh = skb_push(skb, ENCAPS_OVERHEAD);
 		memcpy(eh, &hdr, sizeof(hdr));
 	}
 
@@ -1044,11 +1044,10 @@ static void orinoco_rx(struct net_device *dev,
 		/* These indicate a SNAP within 802.2 LLC within
 		   802.11 frame which we'll need to de-encapsulate to
 		   the original EthernetII frame. */
-		hdr = (struct ethhdr *)skb_push(skb,
-						ETH_HLEN - ENCAPS_OVERHEAD);
+		hdr = skb_push(skb, ETH_HLEN - ENCAPS_OVERHEAD);
 	} else {
 		/* 802.3 frame - prepend 802.3 header as is */
-		hdr = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+		hdr = skb_push(skb, ETH_HLEN);
 		hdr->h_proto = htons(length);
 	}
 	memcpy(hdr->h_dest, desc->addr1, ETH_ALEN);
diff --git a/drivers/net/wireless/p54/txrx.c b/drivers/net/wireless/p54/txrx.c
index f95de0d16216..85630c8b624c 100644
--- a/drivers/net/wireless/p54/txrx.c
+++ b/drivers/net/wireless/p54/txrx.c
@@ -816,8 +816,8 @@ void p54_tx_80211(struct ieee80211_hw *dev,
 		}
 	}
 
-	txhdr = (struct p54_tx_data *) skb_push(skb, sizeof(*txhdr) + padding);
-	hdr = (struct p54_hdr *) skb_push(skb, sizeof(*hdr));
+	txhdr = skb_push(skb, sizeof(*txhdr) + padding);
+	hdr = skb_push(skb, sizeof(*hdr));
 
 	if (padding)
 		hdr_flags |= P54_HDR_FLAG_DATA_ALIGN;
diff --git a/drivers/net/wireless/prism54/islpci_eth.c b/drivers/net/wireless/prism54/islpci_eth.c
index 799e148d0370..ed678a5804d0 100644
--- a/drivers/net/wireless/prism54/islpci_eth.c
+++ b/drivers/net/wireless/prism54/islpci_eth.c
@@ -277,10 +277,7 @@ islpci_monitor_rx(islpci_private *priv, struct sk_buff **skb)
 		}
 
 		/* make room for the new header and fill it. */
-		avs =
-		    (struct avs_80211_1_header *) skb_push(*skb,
-							   sizeof (struct
-								   avs_80211_1_header));
+		avs = skb_push(*skb, sizeof(struct avs_80211_1_header));
 
 		avs->version = cpu_to_be32(P80211CAPTURE_VERSION);
 		avs->length = cpu_to_be32(sizeof (struct avs_80211_1_header));
diff --git a/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c b/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c
index 231f84db9ab0..57af6779a447 100644
--- a/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c
+++ b/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c
@@ -278,8 +278,7 @@ static void rtl8187_tx(struct ieee80211_hw *dev,
 	}
 
 	if (!priv->is_rtl8187b) {
-		struct rtl8187_tx_hdr *hdr =
-			(struct rtl8187_tx_hdr *)skb_push(skb, sizeof(*hdr));
+		struct rtl8187_tx_hdr *hdr = skb_push(skb, sizeof(*hdr));
 		hdr->flags = cpu_to_le32(flags);
 		hdr->len = 0;
 		hdr->rts_duration = rts_dur;
@@ -292,8 +291,7 @@ static void rtl8187_tx(struct ieee80211_hw *dev,
 		unsigned int epmap[4] = { 6, 7, 5, 4 };
 		u16 fc = le16_to_cpu(tx_hdr->frame_control);
 
-		struct rtl8187b_tx_hdr *hdr =
-			(struct rtl8187b_tx_hdr *)skb_push(skb, sizeof(*hdr));
+		struct rtl8187b_tx_hdr *hdr = skb_push(skb, sizeof(*hdr));
 		struct ieee80211_rate *txrate =
 			ieee80211_get_tx_rate(dev, info);
 		memset(hdr, 0, sizeof(*hdr));
* Unmerged path drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/trx.c b/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/trx.c
index 95880fe4106e..bf6a3fb577c2 100644
--- a/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/trx.c
+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/trx.c
@@ -516,7 +516,7 @@ void rtl92cu_tx_fill_desc(struct ieee80211_hw *hw,
 
 	seq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;
 	rtl_get_tcb_desc(hw, info, sta, skb, tcb_desc);
-	txdesc = (u8 *)skb_push(skb, RTL_TX_HEADER_SIZE);
+	txdesc = skb_push(skb, RTL_TX_HEADER_SIZE);
 	memset(txdesc, 0, RTL_TX_HEADER_SIZE);
 	SET_TX_DESC_PKT_SIZE(txdesc, pktlen);
 	SET_TX_DESC_LINIP(txdesc, 0);
* Unmerged path drivers/net/wireless/st/cw1200/txrx.c
diff --git a/drivers/net/wireless/ti/wl1251/tx.c b/drivers/net/wireless/ti/wl1251/tx.c
index 28121c590a2b..b60c0c3ffbdd 100644
--- a/drivers/net/wireless/ti/wl1251/tx.c
+++ b/drivers/net/wireless/ti/wl1251/tx.c
@@ -156,8 +156,7 @@ static int wl1251_tx_fill_hdr(struct wl1251 *wl, struct sk_buff *skb,
 		return id;
 
 	fc = *(u16 *)skb->data;
-	tx_hdr = (struct tx_double_buffer_desc *) skb_push(skb,
-							   sizeof(*tx_hdr));
+	tx_hdr = skb_push(skb, sizeof(*tx_hdr));
 
 	tx_hdr->length = cpu_to_le16(skb->len - sizeof(*tx_hdr));
 	rate = ieee80211_get_tx_rate(wl->hw, control);
diff --git a/drivers/net/wireless/ti/wlcore/cmd.c b/drivers/net/wireless/ti/wlcore/cmd.c
index c9e060795d13..3c3bf4fb0365 100644
--- a/drivers/net/wireless/ti/wlcore/cmd.c
+++ b/drivers/net/wireless/ti/wlcore/cmd.c
@@ -1260,7 +1260,7 @@ int wl1271_cmd_build_arp_rsp(struct wl1271 *wl, struct wl12xx_vif *wlvif)
 		memset(skb_push(skb, sizeof(__le16)), 0, sizeof(__le16));
 
 	/* mac80211 header */
-	hdr = (struct ieee80211_hdr_3addr *)skb_push(skb, sizeof(*hdr));
+	hdr = skb_push(skb, sizeof(*hdr));
 	memset(hdr, 0, sizeof(*hdr));
 	fc = IEEE80211_FTYPE_DATA | IEEE80211_FCTL_TODS;
 	if (wlvif->sta.qos)
diff --git a/drivers/net/wireless/ti/wlcore/tx.c b/drivers/net/wireless/ti/wlcore/tx.c
index 004d02e71f01..7892dd4156fa 100644
--- a/drivers/net/wireless/ti/wlcore/tx.c
+++ b/drivers/net/wireless/ti/wlcore/tx.c
@@ -208,8 +208,7 @@ static int wl1271_tx_allocate(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 	total_blocks = wlcore_hw_calc_tx_blocks(wl, total_len, spare_blocks);
 
 	if (total_blocks <= wl->tx_blocks_available) {
-		desc = (struct wl1271_tx_hw_descr *)skb_push(
-			skb, total_len - skb->len);
+		desc = skb_push(skb, total_len - skb->len);
 
 		wlcore_hw_set_tx_desc_blocks(wl, desc, total_blocks,
 					     spare_blocks);
diff --git a/drivers/net/wireless/zd1211rw/zd_mac.c b/drivers/net/wireless/zd1211rw/zd_mac.c
index c6208a7988e4..577bc28d98a2 100644
--- a/drivers/net/wireless/zd1211rw/zd_mac.c
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c
@@ -870,8 +870,7 @@ static int fill_ctrlset(struct zd_mac *mac,
 	unsigned int frag_len = skb->len + FCS_LEN;
 	unsigned int packet_length;
 	struct ieee80211_rate *txrate;
-	struct zd_ctrlset *cs = (struct zd_ctrlset *)
-		skb_push(skb, sizeof(struct zd_ctrlset));
+	struct zd_ctrlset *cs = skb_push(skb, sizeof(struct zd_ctrlset));
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
 	ZD_ASSERT(frag_len <= 0xffff);
* Unmerged path drivers/nfc/fdp/i2c.c
diff --git a/drivers/nfc/microread/i2c.c b/drivers/nfc/microread/i2c.c
index 101089495bf8..082b451ed834 100644
--- a/drivers/nfc/microread/i2c.c
+++ b/drivers/nfc/microread/i2c.c
@@ -72,7 +72,7 @@ static void microread_i2c_add_len_crc(struct sk_buff *skb)
 	int len;
 
 	len = skb->len;
-	*skb_push(skb, 1) = len;
+	*(u8 *)skb_push(skb, 1) = len;
 
 	for (i = 0; i < skb->len; i++)
 		crc = crc ^ skb->data[i];
diff --git a/drivers/nfc/microread/microread.c b/drivers/nfc/microread/microread.c
index 3420d833db17..6b7cc80e8527 100644
--- a/drivers/nfc/microread/microread.c
+++ b/drivers/nfc/microread/microread.c
@@ -419,7 +419,7 @@ static int microread_im_transceive(struct nfc_hci_dev *hdev,
 	pr_info("data exchange to gate 0x%x\n", target->hci_reader_gate);
 
 	if (target->hci_reader_gate == MICROREAD_GATE_ID_P2P_INITIATOR) {
-		*skb_push(skb, 1) = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
 
 		return nfc_hci_send_event(hdev, target->hci_reader_gate,
 				     MICROREAD_EVT_P2P_INITIATOR_EXCHANGE_TO_RF,
@@ -453,7 +453,7 @@ static int microread_im_transceive(struct nfc_hci_dev *hdev,
 		return 1;
 	}
 
-	*skb_push(skb, 1) = control_bits;
+	*(u8 *)skb_push(skb, 1) = control_bits;
 
 	info->async_cb_type = MICROREAD_CB_TYPE_READER_ALL;
 	info->async_cb = cb;
* Unmerged path drivers/nfc/nfcmrvl/main.c
* Unmerged path drivers/nfc/pn533.c
diff --git a/drivers/nfc/pn544/i2c.c b/drivers/nfc/pn544/i2c.c
index 8cf64c19f022..46060b0eebdc 100644
--- a/drivers/nfc/pn544/i2c.c
+++ b/drivers/nfc/pn544/i2c.c
@@ -162,7 +162,7 @@ static void pn544_hci_i2c_add_len_crc(struct sk_buff *skb)
 	int len;
 
 	len = skb->len + 2;
-	*skb_push(skb, 1) = len;
+	*(u8 *)skb_push(skb, 1) = len;
 
 	crc = crc_ccitt(0xffff, skb->data, skb->len);
 	crc = ~crc;
diff --git a/drivers/nfc/pn544/pn544.c b/drivers/nfc/pn544/pn544.c
index 9c5f16e7baef..891ced86ee65 100644
--- a/drivers/nfc/pn544/pn544.c
+++ b/drivers/nfc/pn544/pn544.c
@@ -648,8 +648,8 @@ static int pn544_hci_im_transceive(struct nfc_hci_dev *hdev,
 		} else
 			return 1;
 	case PN544_RF_READER_F_GATE:
-		*skb_push(skb, 1) = 0;
-		*skb_push(skb, 1) = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
 
 		info->async_cb_type = PN544_CB_TYPE_READER_F;
 		info->async_cb = cb;
@@ -664,7 +664,7 @@ static int pn544_hci_im_transceive(struct nfc_hci_dev *hdev,
 					      PN544_JEWEL_RAW_CMD, skb->data,
 					      skb->len, cb, cb_context);
 	case PN544_RF_READER_NFCIP1_INITIATOR_GATE:
-		*skb_push(skb, 1) = 0;
+		*(u8 *)skb_push(skb, 1) = 0;
 
 		return nfc_hci_send_event(hdev, target->hci_reader_gate,
 					PN544_HCI_EVT_SND_DATA, skb->data,
@@ -679,7 +679,7 @@ static int pn544_hci_tm_send(struct nfc_hci_dev *hdev, struct sk_buff *skb)
 	int r;
 
 	/* Set default false for multiple information chaining */
-	*skb_push(skb, 1) = 0;
+	*(u8 *)skb_push(skb, 1) = 0;
 
 	r = nfc_hci_send_event(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,
 			       PN544_HCI_EVT_SND_DATA, skb->data, skb->len);
* Unmerged path drivers/nfc/st-nci/ndlc.c
* Unmerged path drivers/nfc/st21nfca/core.c
* Unmerged path drivers/nfc/st21nfca/dep.c
* Unmerged path drivers/nfc/st21nfca/i2c.c
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index 106233e4f578..75c9cb242847 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -868,8 +868,7 @@ static int qeth_l2_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 						sizeof(struct qeth_hdr));
 			if (!new_skb)
 				goto tx_drop;
-			hdr = (struct qeth_hdr *)skb_push(new_skb,
-						sizeof(struct qeth_hdr));
+			hdr = skb_push(new_skb, sizeof(struct qeth_hdr));
 			skb_set_mac_header(new_skb, sizeof(struct qeth_hdr));
 			qeth_l2_fill_header(card, hdr, new_skb, cast_type);
 			if (new_skb->ip_summed == CHECKSUM_PARTIAL)
* Unmerged path drivers/s390/net/qeth_l3_main.c
diff --git a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
index 8642783e3ab2..f56732065f4a 100644
--- a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
+++ b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
@@ -352,7 +352,7 @@ static inline void make_tx_data_wr(struct cxgbi_sock *csk, struct sk_buff *skb,
 	struct l2t_entry *l2t = csk->l2t;
 
 	skb_reset_transport_header(skb);
-	req = (struct tx_data_wr *)__skb_push(skb, sizeof(*req));
+	req = __skb_push(skb, sizeof(*req));
 	req->wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_TX_DATA) |
 			(req_completion ? F_WR_COMPL : 0));
 	req->wr_lo = htonl(V_WR_TID(csk->tid));
diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index 27d8753ea466..586a7086cb0e 100644
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -641,7 +641,7 @@ static inline void make_tx_data_wr(struct cxgbi_sock *csk, struct sk_buff *skb,
 	unsigned int wr_ulp_mode = 0, val;
 	bool imm = is_ofld_imm(skb);
 
-	req = (struct fw_ofld_tx_data_wr *)__skb_push(skb, sizeof(*req));
+	req = __skb_push(skb, sizeof(*req));
 
 	if (imm) {
 		req->op_to_immdlen = htonl(FW_WR_OP_V(FW_OFLD_TX_DATA_WR) |
diff --git a/drivers/scsi/fcoe/fcoe_ctlr.c b/drivers/scsi/fcoe/fcoe_ctlr.c
index e66be71c54e0..0883f6f020df 100644
--- a/drivers/scsi/fcoe/fcoe_ctlr.c
+++ b/drivers/scsi/fcoe/fcoe_ctlr.c
@@ -623,7 +623,7 @@ static int fcoe_ctlr_encaps(struct fcoe_ctlr *fip, struct fc_lport *lport,
 	fh = (struct fc_frame_header *)skb->data;
 	op = *(u8 *)(fh + 1);
 	dlen = sizeof(struct fip_encaps) + skb->len;	/* len before push */
-	cap = (struct fip_encaps_head *)skb_push(skb, sizeof(*cap));
+	cap = skb_push(skb, sizeof(*cap));
 	memset(cap, 0, sizeof(*cap));
 
 	if (lport->point_to_multipoint) {
diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c
index 362bf1f33a17..07f5eb07d027 100644
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@ -1002,8 +1002,7 @@ void fnic_eth_send(struct fcoe_ctlr *fip, struct sk_buff *skb)
 
 	if (!fnic->vlan_hw_insert) {
 		eth_hdr = (struct ethhdr *)skb_mac_header(skb);
-		vlan_hdr = (struct vlan_ethhdr *)skb_push(skb,
-				sizeof(*vlan_hdr) - sizeof(*eth_hdr));
+		vlan_hdr = skb_push(skb, sizeof(*vlan_hdr) - sizeof(*eth_hdr));
 		memcpy(vlan_hdr, eth_hdr, 2 * ETH_ALEN);
 		vlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);
 		vlan_hdr->h_vlan_encapsulated_proto = eth_hdr->h_proto;
@@ -1069,7 +1068,7 @@ static int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)
 
 	if (!fnic->vlan_hw_insert) {
 		eth_hdr_len = sizeof(*vlan_hdr) + sizeof(*fcoe_hdr);
-		vlan_hdr = (struct vlan_ethhdr *)skb_push(skb, eth_hdr_len);
+		vlan_hdr = skb_push(skb, eth_hdr_len);
 		eth_hdr = (struct ethhdr *)vlan_hdr;
 		vlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);
 		vlan_hdr->h_vlan_encapsulated_proto = htons(ETH_P_FCOE);
@@ -1077,7 +1076,7 @@ static int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)
 		fcoe_hdr = (struct fcoe_hdr *)(vlan_hdr + 1);
 	} else {
 		eth_hdr_len = sizeof(*eth_hdr) + sizeof(*fcoe_hdr);
-		eth_hdr = (struct ethhdr *)skb_push(skb, eth_hdr_len);
+		eth_hdr = skb_push(skb, eth_hdr_len);
 		eth_hdr->h_proto = htons(ETH_P_FCOE);
 		fcoe_hdr = (struct fcoe_hdr *)(eth_hdr + 1);
 	}
diff --git a/drivers/scsi/qedf/qedf_fip.c b/drivers/scsi/qedf/qedf_fip.c
index 5dde777df0fc..c0fd2da3183f 100644
--- a/drivers/scsi/qedf/qedf_fip.c
+++ b/drivers/scsi/qedf/qedf_fip.c
@@ -125,8 +125,7 @@ void qedf_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)
 	sub = fiph->fip_subcode;
 
 	if (!qedf->vlan_hw_insert) {
-		vlan_hdr = (struct vlan_ethhdr *)skb_push(skb, sizeof(*vlan_hdr)
-		    - sizeof(*eth_hdr));
+		vlan_hdr = skb_push(skb, sizeof(*vlan_hdr) - sizeof(*eth_hdr));
 		memcpy(vlan_hdr, eth_hdr, 2 * ETH_ALEN);
 		vlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);
 		vlan_hdr->h_vlan_encapsulated_proto = eth_hdr->h_proto;
* Unmerged path drivers/staging/wilc1000/linux_mon.c
* Unmerged path drivers/staging/wlan-ng/p80211conv.c
diff --git a/drivers/target/iscsi/cxgbit/cxgbit_target.c b/drivers/target/iscsi/cxgbit/cxgbit_target.c
index cca421d3a85f..e3b9e3241e6c 100644
--- a/drivers/target/iscsi/cxgbit/cxgbit_target.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_target.c
@@ -166,7 +166,7 @@ cxgbit_cpl_tx_data_iso(struct sk_buff *skb, struct cxgbit_iso_info *iso_info)
 	unsigned int fslice = !!(iso_info->flags & CXGBIT_ISO_FSLICE);
 	unsigned int lslice = !!(iso_info->flags & CXGBIT_ISO_LSLICE);
 
-	cpl = (struct cpl_tx_data_iso *)__skb_push(skb, sizeof(*cpl));
+	cpl = __skb_push(skb, sizeof(*cpl));
 
 	cpl->op_to_scsi = htonl(CPL_TX_DATA_ISO_OP_V(CPL_TX_DATA_ISO) |
 			CPL_TX_DATA_ISO_FIRST_V(fslice) |
@@ -213,8 +213,7 @@ cxgbit_tx_data_wr(struct cxgbit_sock *csk, struct sk_buff *skb, u32 dlen,
 	if (cxgbit_is_ofld_imm(skb))
 		immlen += dlen;
 
-	req = (struct fw_ofld_tx_data_wr *)__skb_push(skb,
-							hdr_size);
+	req = __skb_push(skb, hdr_size);
 	req->op_to_immdlen = cpu_to_be32(FW_WR_OP_V(opcode) |
 					FW_WR_COMPL_V(compl) |
 					FW_WR_IMMDLEN_V(immlen));
diff --git a/drivers/usb/gadget/rndis.c b/drivers/usb/gadget/rndis.c
index 9ee4fe81378b..36c0f8dc1970 100644
--- a/drivers/usb/gadget/rndis.c
+++ b/drivers/usb/gadget/rndis.c
@@ -941,7 +941,7 @@ void rndis_add_hdr(struct sk_buff *skb)
 
 	if (!skb)
 		return;
-	header = (void *)skb_push(skb, sizeof(*header));
+	header = skb_push(skb, sizeof(*header));
 	memset(header, 0, sizeof *header);
 	header->MessageType = cpu_to_le32(RNDIS_MSG_PACKET);
 	header->MessageLength = cpu_to_le32(skb->len);
diff --git a/include/linux/if_vlan.h b/include/linux/if_vlan.h
index 3a545ed01b7d..41fe434c6633 100644
--- a/include/linux/if_vlan.h
+++ b/include/linux/if_vlan.h
@@ -306,7 +306,7 @@ static inline int __vlan_insert_tag(struct sk_buff *skb,
 	if (skb_cow_head(skb, VLAN_HLEN) < 0)
 		return -ENOMEM;
 
-	veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);
+	veth = skb_push(skb, VLAN_HLEN);
 
 	/* Move the mac addresses to the beginning of the new header. */
 	memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);
* Unmerged path include/linux/skbuff.h
diff --git a/net/802/fc.c b/net/802/fc.c
index 05eea6b98bb8..afc022d5939a 100644
--- a/net/802/fc.c
+++ b/net/802/fc.c
@@ -49,7 +49,7 @@ static int fc_header(struct sk_buff *skb, struct net_device *dev,
 		struct fcllc *fcllc;
 
 		hdr_len = sizeof(struct fch_hdr) + sizeof(struct fcllc);
-		fch = (struct fch_hdr *)skb_push(skb, hdr_len);
+		fch = skb_push(skb, hdr_len);
 		fcllc = (struct fcllc *)(fch+1);
 		fcllc->dsap = fcllc->ssap = EXTENDED_SAP;
 		fcllc->llc = UI_CMD;
@@ -59,7 +59,7 @@ static int fc_header(struct sk_buff *skb, struct net_device *dev,
 	else
 	{
 		hdr_len = sizeof(struct fch_hdr);
-		fch = (struct fch_hdr *)skb_push(skb, hdr_len);
+		fch = skb_push(skb, hdr_len);
 	}
 
 	if(saddr)
diff --git a/net/802/fddi.c b/net/802/fddi.c
index 9cda40661e0d..5655d8e2372a 100644
--- a/net/802/fddi.c
+++ b/net/802/fddi.c
@@ -58,7 +58,7 @@ static int fddi_header(struct sk_buff *skb, struct net_device *dev,
 
 	if(type != ETH_P_IP && type != ETH_P_IPV6 && type != ETH_P_ARP)
 		hl=FDDI_K_8022_HLEN-3;
-	fddi = (struct fddihdr *)skb_push(skb, hl);
+	fddi = skb_push(skb, hl);
 	fddi->fc			 = FDDI_FC_K_ASYNC_LLC_DEF;
 	if(type == ETH_P_IP || type == ETH_P_IPV6 || type == ETH_P_ARP)
 	{
diff --git a/net/802/hippi.c b/net/802/hippi.c
index a97a3bde77bb..dc320610fa51 100644
--- a/net/802/hippi.c
+++ b/net/802/hippi.c
@@ -47,7 +47,7 @@ static int hippi_header(struct sk_buff *skb, struct net_device *dev,
 			unsigned short type,
 			const void *daddr, const void *saddr, unsigned int len)
 {
-	struct hippi_hdr *hip = (struct hippi_hdr *)skb_push(skb, HIPPI_HLEN);
+	struct hippi_hdr *hip = skb_push(skb, HIPPI_HLEN);
 	struct hippi_cb *hcb = (struct hippi_cb *) skb->cb;
 
 	if (!len){
diff --git a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c
index 314c2f99b67e..7b929be536be 100644
--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@ -90,7 +90,7 @@ static int vlan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,
 	int rc;
 
 	if (!(vlan->flags & VLAN_FLAG_REORDER_HDR)) {
-		vhdr = (struct vlan_hdr *) skb_push(skb, VLAN_HLEN);
+		vhdr = skb_push(skb, VLAN_HLEN);
 
 		vlan_tci = vlan->vlan_id;
 		vlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb->priority);
diff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c
index d7c02df293b0..e36702dbc1b3 100644
--- a/net/appletalk/ddp.c
+++ b/net/appletalk/ddp.c
@@ -1531,7 +1531,7 @@ static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,
 		 * The push leaves us with a ddephdr not an shdr, and
 		 * handily the port bytes in the right place preset.
 		 */
-		ddp = (struct ddpehdr *) skb_push(skb, sizeof(*ddp) - 4);
+		ddp = skb_push(skb, sizeof(*ddp) - 4);
 
 		/* Now fill in the long header */
 
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 1cf964d43259..6b34cac40004 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -1562,7 +1562,7 @@ static int ax25_sendmsg(struct kiocb *iocb, struct socket *sock,
 
 	/* Add the PID if one is not supplied by the user in the skb */
 	if (!ax25->pidincl)
-		*skb_push(skb, 1) = sk->sk_protocol;
+		*(u8 *)skb_push(skb, 1) = sk->sk_protocol;
 
 	if (sk->sk_type == SOCK_SEQPACKET) {
 		/* Connected mode sockets go via the LAPB machine */
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 23832f088804..9fa047f926f4 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -332,7 +332,7 @@ void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb)
 		return;
 
 	/* Put header before the data */
-	hdr = (void *)skb_push(skb_copy, HCI_MON_HDR_SIZE);
+	hdr = skb_push(skb_copy, HCI_MON_HDR_SIZE);
 	hdr->opcode = opcode;
 	hdr->index = cpu_to_le16(hdev->id);
 	hdr->len = cpu_to_le16(skb->len);
@@ -383,7 +383,7 @@ void hci_send_monitor_ctrl_event(struct hci_dev *hdev, u16 event,
 
 		skb->tstamp = tstamp;
 
-		hdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);
+		hdr = skb_push(skb, HCI_MON_HDR_SIZE);
 		hdr->opcode = cpu_to_le16(HCI_MON_CTRL_EVENT);
 		hdr->index = index;
 		hdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);
@@ -467,7 +467,7 @@ static struct sk_buff *create_monitor_event(struct hci_dev *hdev, int event)
 
 	__net_timestamp(skb);
 
-	hdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr = skb_push(skb, HCI_MON_HDR_SIZE);
 	hdr->opcode = opcode;
 	hdr->index = cpu_to_le16(hdev->id);
 	hdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);
@@ -522,7 +522,7 @@ static struct sk_buff *create_monitor_ctrl_open(struct sock *sk)
 
 	__net_timestamp(skb);
 
-	hdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr = skb_push(skb, HCI_MON_HDR_SIZE);
 	hdr->opcode = cpu_to_le16(HCI_MON_CTRL_OPEN);
 	if (hci_pi(sk)->hdev)
 		hdr->index = cpu_to_le16(hci_pi(sk)->hdev->id);
@@ -560,7 +560,7 @@ static struct sk_buff *create_monitor_ctrl_close(struct sock *sk)
 
 	__net_timestamp(skb);
 
-	hdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr = skb_push(skb, HCI_MON_HDR_SIZE);
 	hdr->opcode = cpu_to_le16(HCI_MON_CTRL_CLOSE);
 	if (hci_pi(sk)->hdev)
 		hdr->index = cpu_to_le16(hci_pi(sk)->hdev->id);
@@ -590,7 +590,7 @@ static struct sk_buff *create_monitor_ctrl_command(struct sock *sk, u16 index,
 
 	__net_timestamp(skb);
 
-	hdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr = skb_push(skb, HCI_MON_HDR_SIZE);
 	hdr->opcode = cpu_to_le16(HCI_MON_CTRL_COMMAND);
 	hdr->index = cpu_to_le16(index);
 	hdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);
diff --git a/net/bluetooth/mgmt_util.c b/net/bluetooth/mgmt_util.c
index c933bd08c1fe..a970fffcaec1 100644
--- a/net/bluetooth/mgmt_util.c
+++ b/net/bluetooth/mgmt_util.c
@@ -48,7 +48,7 @@ static struct sk_buff *create_monitor_ctrl_event(__le16 index, u32 cookie,
 
 	__net_timestamp(skb);
 
-	hdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);
+	hdr = skb_push(skb, HCI_MON_HDR_SIZE);
 	hdr->opcode = cpu_to_le16(HCI_MON_CTRL_EVENT);
 	hdr->index = index;
 	hdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);
diff --git a/net/bluetooth/rfcomm/core.c b/net/bluetooth/rfcomm/core.c
index d434e0dab83e..ec118ea01f38 100644
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -1149,10 +1149,10 @@ static void rfcomm_make_uih(struct sk_buff *skb, u8 addr)
 	u8 *crc;
 
 	if (len > 127) {
-		hdr = (void *) skb_push(skb, 4);
+		hdr = skb_push(skb, 4);
 		put_unaligned(cpu_to_le16(__len16(len)), (__le16 *) &hdr->len);
 	} else {
-		hdr = (void *) skb_push(skb, 3);
+		hdr = skb_push(skb, 3);
 		hdr->len = __len8(len);
 	}
 	hdr->addr = addr;
diff --git a/net/bridge/netfilter/nft_reject_bridge.c b/net/bridge/netfilter/nft_reject_bridge.c
index d0acfe36b2b9..aa5dcb782716 100644
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@ -29,7 +29,7 @@ static void nft_reject_br_push_etherhdr(struct sk_buff *oldskb,
 {
 	struct ethhdr *eth;
 
-	eth = (struct ethhdr *)skb_push(nskb, ETH_HLEN);
+	eth = skb_push(nskb, ETH_HLEN);
 	skb_reset_mac_header(nskb);
 	ether_addr_copy(eth->h_source, eth_hdr(oldskb)->h_dest);
 	ether_addr_copy(eth->h_dest, eth_hdr(oldskb)->h_source);
diff --git a/net/core/netpoll.c b/net/core/netpoll.c
index ecceba3bc8e2..d03c4ac755ec 100644
--- a/net/core/netpoll.c
+++ b/net/core/netpoll.c
@@ -433,7 +433,7 @@ void netpoll_send_udp(struct netpoll *np, const char *msg, int len)
 		ip6h->saddr = np->local_ip.in6;
 		ip6h->daddr = np->remote_ip.in6;
 
-		eth = (struct ethhdr *) skb_push(skb, ETH_HLEN);
+		eth = skb_push(skb, ETH_HLEN);
 		skb_reset_mac_header(skb);
 		skb->protocol = eth->h_proto = htons(ETH_P_IPV6);
 	} else {
@@ -462,7 +462,7 @@ void netpoll_send_udp(struct netpoll *np, const char *msg, int len)
 		put_unaligned(np->remote_ip.ip, &(iph->daddr));
 		iph->check    = ip_fast_csum((unsigned char *)iph, iph->ihl);
 
-		eth = (struct ethhdr *) skb_push(skb, ETH_HLEN);
+		eth = skb_push(skb, ETH_HLEN);
 		skb_reset_mac_header(skb);
 		skb->protocol = eth->h_proto = htons(ETH_P_IP);
 	}
* Unmerged path net/core/pktgen.c
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 1810381d0deb..5fac5dafb769 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -1482,7 +1482,7 @@ EXPORT_SYMBOL(skb_put);
  *	start. If this would exceed the total buffer headroom the kernel will
  *	panic. A pointer to the first byte of the extra data is returned.
  */
-unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
+void *skb_push(struct sk_buff *skb, unsigned int len)
 {
 	skb->data -= len;
 	skb->len  += len;
diff --git a/net/dccp/options.c b/net/dccp/options.c
index a58e0b634050..fa0f6018a5ac 100644
--- a/net/dccp/options.c
+++ b/net/dccp/options.c
@@ -516,7 +516,7 @@ int dccp_insert_option_mandatory(struct sk_buff *skb)
 		return -1;
 
 	DCCP_SKB_CB(skb)->dccpd_opt_len++;
-	*skb_push(skb, 1) = DCCPO_MANDATORY;
+	*(u8 *)skb_push(skb, 1) = DCCPO_MANDATORY;
 	return 0;
 }
 
diff --git a/net/decnet/dn_dev.c b/net/decnet/dn_dev.c
index 35fbe0932018..8f89a784f12a 100644
--- a/net/decnet/dn_dev.c
+++ b/net/decnet/dn_dev.c
@@ -857,7 +857,7 @@ static void dn_send_endnode_hello(struct net_device *dev, struct dn_ifaddr *ifa)
 	msg->datalen = 0x02;
 	memset(msg->data, 0xAA, 2);
 
-	pktlen = (__le16 *)skb_push(skb,2);
+	pktlen = skb_push(skb, 2);
 	*pktlen = cpu_to_le16(skb->len - 2);
 
 	skb_reset_network_header(skb);
@@ -949,7 +949,7 @@ static void dn_send_router_hello(struct net_device *dev, struct dn_ifaddr *ifa)
 
 	skb_trim(skb, (27 + *i2));
 
-	pktlen = (__le16 *)skb_push(skb, 2);
+	pktlen = skb_push(skb, 2);
 	*pktlen = cpu_to_le16(skb->len - 2);
 
 	skb_reset_network_header(skb);
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index 071ff5a0f796..38510f038242 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -84,7 +84,7 @@ int eth_header(struct sk_buff *skb, struct net_device *dev,
 	       unsigned short type,
 	       const void *daddr, const void *saddr, unsigned int len)
 {
-	struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+	struct ethhdr *eth = skb_push(skb, ETH_HLEN);
 
 	if (type != ETH_P_802_3 && type != ETH_P_802_2)
 		eth->h_proto = htons(type);
* Unmerged path net/ipv4/esp4.c
diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c
index 87f8ae919464..8ea7d7902a75 100644
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@ -584,7 +584,7 @@ static int ipgre_header(struct sk_buff *skb, struct net_device *dev,
 	struct iphdr *iph;
 	struct gre_base_hdr *greh;
 
-	iph = (struct iphdr *)skb_push(skb, t->hlen + sizeof(*iph));
+	iph = skb_push(skb, t->hlen + sizeof(*iph));
 	greh = (struct gre_base_hdr *)(iph+1);
 	greh->flags = gre_tnl_flags_to_gre_flags(t->parms.o_flags);
 	greh->protocol = htons(type);
* Unmerged path net/ipv6/esp6.c
* Unmerged path net/ipv6/exthdrs.c
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index 98dccbd41025..0fb798744163 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -937,7 +937,7 @@ static int ip6gre_header(struct sk_buff *skb, struct net_device *dev,
 			const void *daddr, const void *saddr, unsigned int len)
 {
 	struct ip6_tnl *t = netdev_priv(dev);
-	struct ipv6hdr *ipv6h = (struct ipv6hdr *)skb_push(skb, t->hlen);
+	struct ipv6hdr *ipv6h = skb_push(skb, t->hlen);
 	__be16 *p = (__be16 *)(ipv6h+1);
 
 	ip6_flow_hdr(ipv6h, 0, t->fl.u.ip6.flowlabel);
* Unmerged path net/ipv6/ip6_output.c
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index e43484357cd2..c7824e4e5fd9 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -816,7 +816,7 @@ static void tcp_v6_send_response(struct sock *sk, struct sk_buff *skb, u32 seq,
 
 	skb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);
 
-	t1 = (struct tcphdr *) skb_push(buff, tot_len);
+	t1 = skb_push(buff, tot_len);
 	skb_reset_transport_header(buff);
 
 	/* Swap the send and the receive. */
diff --git a/net/irda/irnet/irnet_irda.c b/net/irda/irnet/irnet_irda.c
index 7f17a8020e8a..e390bceeb2f8 100644
--- a/net/irda/irnet/irnet_irda.c
+++ b/net/irda/irnet/irnet_irda.c
@@ -1065,7 +1065,7 @@ irnet_data_indication(void *	instance,
   if(p[0] & 1)
     {
       /* protocol is compressed */
-      skb_push(skb, 1)[0] = 0;
+      *(u8 *)skb_push(skb, 1) = 0;
     }
   else
     if(skb->len < 2)
diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c
index 3ce286e6e2d4..8932b4f2a1dc 100644
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -323,8 +323,7 @@ static int afiucv_hs_send(struct iucv_message *imsg, struct sock *sock,
 	int err, confirm_recv = 0;
 
 	memset(skb->head, 0, ETH_HLEN);
-	phs_hdr = (struct af_iucv_trans_hdr *)skb_push(skb,
-					sizeof(struct af_iucv_trans_hdr));
+	phs_hdr = skb_push(skb, sizeof(struct af_iucv_trans_hdr));
 	skb_reset_mac_header(skb);
 	skb_reset_network_header(skb);
 	skb_push(skb, ETH_HLEN);
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index b5bcf5c606e4..119f27a99a58 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -285,7 +285,7 @@ ieee80211_add_rx_radiotap_header(struct ieee80211_local *local,
 	if (!(has_fcs && ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)))
 		mpdulen += FCS_LEN;
 
-	rthdr = (struct ieee80211_radiotap_header *)skb_push(skb, rtap_len);
+	rthdr = skb_push(skb, rtap_len);
 	memset(rthdr, 0, rtap_len - rtap.len - rtap.pad);
 	it_present = &rthdr->it_present;
 
diff --git a/net/mac80211/status.c b/net/mac80211/status.c
index 05ccd55b5d83..90f8a6184583 100644
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -287,7 +287,7 @@ ieee80211_add_tx_radiotap_header(struct ieee80211_local *local,
 	unsigned char *pos;
 	u16 txflags;
 
-	rthdr = (struct ieee80211_radiotap_header *) skb_push(skb, rtap_len);
+	rthdr = skb_push(skb, rtap_len);
 
 	memset(rthdr, 0, rtap_len);
 	rthdr->it_len = cpu_to_le16(rtap_len);
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index ba8d7db0a071..98d13938fb3c 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2705,7 +2705,7 @@ static struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,
 	if (ieee80211_is_data_qos(fc)) {
 		__le16 *qos_control;
 
-		qos_control = (__le16 *) skb_push(skb, 2);
+		qos_control = skb_push(skb, 2);
 		memcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);
 		/*
 		 * Maybe we could actually set some fields here, for now just
@@ -3344,7 +3344,7 @@ static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
 	}
 
 	memcpy(&eth, skb->data, ETH_HLEN - 2);
-	hdr = (void *)skb_push(skb, extra_head);
+	hdr = skb_push(skb, extra_head);
 	memcpy(skb->data, fast_tx->hdr, fast_tx->hdr_len);
 	memcpy(skb->data + fast_tx->da_offs, eth.h_dest, ETH_ALEN);
 	memcpy(skb->data + fast_tx->sa_offs, eth.h_source, ETH_ALEN);
* Unmerged path net/ncsi/ncsi-cmd.c
* Unmerged path net/nfc/digital_dep.c
* Unmerged path net/nfc/digital_technology.c
diff --git a/net/nfc/hci/core.c b/net/nfc/hci/core.c
index 91020b210d87..539bda1e60f0 100644
--- a/net/nfc/hci/core.c
+++ b/net/nfc/hci/core.c
@@ -642,7 +642,7 @@ static int hci_transceive(struct nfc_dev *nfc_dev, struct nfc_target *target,
 				break;
 		}
 
-		*skb_push(skb, 1) = 0;	/* CTR, see spec:10.2.2.1 */
+		*(u8 *)skb_push(skb, 1) = 0;	/* CTR, see spec:10.2.2.1 */
 
 		hdev->async_cb_type = HCI_CB_TYPE_TRANSCEIVE;
 		hdev->async_cb = cb;
diff --git a/net/nfc/hci/llc_shdlc.c b/net/nfc/hci/llc_shdlc.c
index 27b313befc35..b015bf8c244d 100644
--- a/net/nfc/hci/llc_shdlc.c
+++ b/net/nfc/hci/llc_shdlc.c
@@ -162,7 +162,7 @@ static int llc_shdlc_send_s_frame(struct llc_shdlc *shdlc,
 	if (skb == NULL)
 		return -ENOMEM;
 
-	*skb_push(skb, 1) = SHDLC_CONTROL_HEAD_S | (sframe_type << 3) | nr;
+	*(u8 *)skb_push(skb, 1) = SHDLC_CONTROL_HEAD_S | (sframe_type << 3) | nr;
 
 	r = shdlc->xmit_to_drv(shdlc->hdev, skb);
 
@@ -180,7 +180,7 @@ static int llc_shdlc_send_u_frame(struct llc_shdlc *shdlc,
 
 	pr_debug("uframe_modifier=%d\n", uframe_modifier);
 
-	*skb_push(skb, 1) = SHDLC_CONTROL_HEAD_U | uframe_modifier;
+	*(u8 *)skb_push(skb, 1) = SHDLC_CONTROL_HEAD_U | uframe_modifier;
 
 	r = shdlc->xmit_to_drv(shdlc->hdev, skb);
 
@@ -553,8 +553,8 @@ static void llc_shdlc_handle_send_queue(struct llc_shdlc *shdlc)
 
 		skb = skb_dequeue(&shdlc->send_q);
 
-		*skb_push(skb, 1) = SHDLC_CONTROL_HEAD_I | (shdlc->ns << 3) |
-				    shdlc->nr;
+		*(u8 *)skb_push(skb, 1) = SHDLC_CONTROL_HEAD_I | (shdlc->ns << 3) |
+					shdlc->nr;
 
 		pr_debug("Sending I-Frame %d, waiting to rcv %d\n", shdlc->ns,
 			 shdlc->nr);
diff --git a/net/nfc/nci/data.c b/net/nfc/nci/data.c
index 76c48c5324f8..aa9f34e92f62 100644
--- a/net/nfc/nci/data.c
+++ b/net/nfc/nci/data.c
@@ -73,7 +73,7 @@ static inline void nci_push_data_hdr(struct nci_dev *ndev,
 	struct nci_data_hdr *hdr;
 	int plen = skb->len;
 
-	hdr = (struct nci_data_hdr *) skb_push(skb, NCI_DATA_HDR_SIZE);
+	hdr = skb_push(skb, NCI_DATA_HDR_SIZE);
 	hdr->conn_id = conn_id;
 	hdr->rfu = 0;
 	hdr->plen = plen;
* Unmerged path net/nfc/nci/hci.c
* Unmerged path net/nfc/nci/spi.c
diff --git a/net/nfc/rawsock.c b/net/nfc/rawsock.c
index 8035242138e0..18a5059e3dc3 100644
--- a/net/nfc/rawsock.c
+++ b/net/nfc/rawsock.c
@@ -123,7 +123,7 @@ error:
 
 static int rawsock_add_header(struct sk_buff *skb)
 {
-	*skb_push(skb, NFC_HEADER_SIZE) = 0;
+	*(u8 *)skb_push(skb, NFC_HEADER_SIZE) = 0;
 
 	return 0;
 }
* Unmerged path net/sctp/output.c
diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index 79c69c73e74b..527be21cbea4 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -778,8 +778,8 @@ sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,
 		auth.skb = chunk->auth_chunk;
 		auth.asoc = chunk->asoc;
 		auth.sctp_hdr = chunk->sctp_hdr;
-		auth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,
-					    sizeof(sctp_chunkhdr_t));
+		auth.chunk_hdr = skb_push(chunk->auth_chunk,
+					  sizeof(sctp_chunkhdr_t));
 		skb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));
 		auth.transport = chunk->transport;
 
diff --git a/net/sctp/ulpevent.c b/net/sctp/ulpevent.c
index 3ab0672709c6..3104178f9213 100644
--- a/net/sctp/ulpevent.c
+++ b/net/sctp/ulpevent.c
@@ -160,8 +160,7 @@ struct sctp_ulpevent  *sctp_ulpevent_make_assoc_change(
 		sctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);
 
 		/* Include the notification structure */
-		sac = (struct sctp_assoc_change *)
-			skb_push(skb, sizeof(struct sctp_assoc_change));
+		sac = skb_push(skb, sizeof(struct sctp_assoc_change));
 
 		/* Trim the buffer to the right length.  */
 		skb_trim(skb, sizeof(struct sctp_assoc_change) +
@@ -409,7 +408,7 @@ sctp_ulpevent_make_remote_error(const struct sctp_association *asoc,
 	event = sctp_skb2event(skb);
 	sctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);
 
-	sre = (struct sctp_remote_error *) skb_push(skb, sizeof(*sre));
+	sre = skb_push(skb, sizeof(*sre));
 
 	/* Trim the buffer to the right length.  */
 	skb_trim(skb, sizeof(*sre) + elen);
@@ -460,8 +459,7 @@ struct sctp_ulpevent *sctp_ulpevent_make_send_failed(
 	event = sctp_skb2event(skb);
 	sctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);
 
-	ssf = (struct sctp_send_failed *)
-		skb_push(skb, sizeof(struct sctp_send_failed));
+	ssf = skb_push(skb, sizeof(struct sctp_send_failed));
 
 	/* Socket Extensions for SCTP
 	 * 5.3.1.4 SCTP_SEND_FAILED
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 68e5f2ecee1a..8da9b42790d7 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -520,7 +520,7 @@ int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,
 	pskb_pull(skb, hdrlen);
 
 	if (!ehdr)
-		ehdr = (struct ethhdr *) skb_push(skb, sizeof(struct ethhdr));
+		ehdr = skb_push(skb, sizeof(struct ethhdr));
 	memcpy(ehdr, &tmp, sizeof(tmp));
 
 	return 0;
