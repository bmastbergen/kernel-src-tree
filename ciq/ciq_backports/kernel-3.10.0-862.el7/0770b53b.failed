vxlan: simplify vxlan xmit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author pravin shelar <pshelar@ovn.org>
commit 0770b53bd276a7b7846a185ec8a8f1188f135f7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0770b53b.failed

Existing vxlan xmit function handles two distinct cases.
1. vxlan net device
2. vxlan lwt device.
By seperating initialization these two cases the egress path
looks better.

	Signed-off-by: Pravin B Shelar <pshelar@ovn.org>
	Acked-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0770b53bd276a7b7846a185ec8a8f1188f135f7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index f909b180e18b,d536a9340cd5..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1903,17 -1980,15 +1903,20 @@@ static void vxlan_xmit_one(struct sk_bu
  	struct dst_cache *dst_cache;
  	struct ip_tunnel_info *info;
  	struct vxlan_dev *vxlan = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct sock *sk;
 +	struct rtable *rt = NULL;
 +	const struct iphdr *old_iph;
++=======
+ 	const struct iphdr *old_iph = ip_hdr(skb);
++>>>>>>> 0770b53bd276 (vxlan: simplify vxlan xmit)
  	union vxlan_addr *dst;
  	union vxlan_addr remote_ip, local_ip;
  	union vxlan_addr *src;
  	struct vxlan_metadata _md;
  	struct vxlan_metadata *md = &_md;
  	__be16 src_port = 0, dst_port;
 -	struct dst_entry *ndst = NULL;
  	__be32 vni, label;
- 	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
  	u32 flags = vxlan->flags;
@@@ -1977,65 -2051,43 +1979,81 @@@
  		tos = info->key.tos;
  		label = info->key.label;
  		udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);
- 
- 		if (info->options_len)
- 			md = ip_tunnel_info_opts(info);
- 	} else {
- 		md->gbp = skb->mark;
  	}
+ 	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
+ 				     vxlan->cfg.port_max, true);
  
  	if (dst->sa.sa_family == AF_INET) {
++<<<<<<< HEAD
 +		if (!vxlan->vn4_sock)
 +			goto drop;
 +		sk = vxlan->vn4_sock->sock->sk;
++=======
+ 		struct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);
+ 		struct rtable *rt;
+ 		__be16 df = 0;
++>>>>>>> 0770b53bd276 (vxlan: simplify vxlan xmit)
  
 -		rt = vxlan_get_route(vxlan, dev, sock4, skb,
 +		rt = vxlan_get_route(vxlan, skb,
  				     rdst ? rdst->remote_ifindex : 0, tos,
  				     dst->sin.sin_addr.s_addr,
  				     &src->sin.sin_addr.s_addr,
  				     dst_cache, info);
 -		if (IS_ERR(rt))
 +		if (IS_ERR(rt)) {
 +			netdev_dbg(dev, "no route to %pI4\n",
 +				   &dst->sin.sin_addr.s_addr);
 +			dev->stats.tx_carrier_errors++;
  			goto tx_error;
++<<<<<<< HEAD
++=======
+ 
+ 		/* Bypass encapsulation if the destination is local */
+ 		if (!info) {
+ 			err = encap_bypass_if_local(skb, dev, vxlan, dst,
+ 						    dst_port, vni, &rt->dst,
+ 						    rt->rt_flags);
+ 			if (err)
+ 				return;
+ 		} else if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT) {
+ 			df = htons(IP_DF);
++>>>>>>> 0770b53bd276 (vxlan: simplify vxlan xmit)
  		}
  
 -		ndst = &rt->dst;
 +		if (rt->dst.dev == dev) {
 +			netdev_dbg(dev, "circular route to %pI4\n",
 +				   &dst->sin.sin_addr.s_addr);
 +			dev->stats.collisions++;
 +			goto rt_tx_error;
 +		}
 +
 +		/* Bypass encapsulation if the destination is local */
 +		if (!info && rt->rt_flags & RTCF_LOCAL &&
 +		    !(rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
 +			struct vxlan_dev *dst_vxlan;
 +
 +			ip_rt_put(rt);
 +			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
 +						   dst->sa.sa_family, dst_port,
 +						   vxlan->flags);
 +			if (!dst_vxlan)
 +				goto tx_error;
 +			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
 +			return;
 +		}
 +
 +		if (!info)
 +			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM_TX);
 +		else if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)
 +			df = htons(IP_DF);
 +
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
 -		err = vxlan_build_skb(skb, ndst, sizeof(struct iphdr),
 +		err = vxlan_build_skb(skb, &rt->dst, sizeof(struct iphdr),
  				      vni, md, flags, udp_sum);
  		if (err < 0)
 -			goto tx_error;
 +			goto xmit_tx_error;
  
- 		udp_tunnel_xmit_skb(rt, sk, skb, src->sin.sin_addr.s_addr,
+ 		udp_tunnel_xmit_skb(rt, sock4->sock->sk, skb, src->sin.sin_addr.s_addr,
  				    dst->sin.sin_addr.s_addr, tos, ttl, df,
  				    src_port, dst_port, xnet, !udp_sum);
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -2059,44 -2104,25 +2077,62 @@@
  			goto tx_error;
  		}
  
++<<<<<<< HEAD
 +		if (ndst->dev == dev) {
 +			netdev_dbg(dev, "circular route to %pI6\n",
 +				   &dst->sin6.sin6_addr);
 +			dst_release(ndst);
 +			dev->stats.collisions++;
 +			goto tx_error;
++=======
+ 		if (!info) {
+ 			u32 rt6i_flags = ((struct rt6_info *)ndst)->rt6i_flags;
+ 
+ 			err = encap_bypass_if_local(skb, dev, vxlan, dst,
+ 						    dst_port, vni, ndst,
+ 						    rt6i_flags);
+ 			if (err)
+ 				return;
++>>>>>>> 0770b53bd276 (vxlan: simplify vxlan xmit)
 +		}
 +
 +		/* Bypass encapsulation if the destination is local */
 +		rt6i_flags = ((struct rt6_info *)ndst)->rt6i_flags;
 +		if (!info && rt6i_flags & RTF_LOCAL &&
 +		    !(rt6i_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
 +			struct vxlan_dev *dst_vxlan;
 +
 +			dst_release(ndst);
 +			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
 +						   dst->sa.sa_family, dst_port,
 +						   vxlan->flags);
 +			if (!dst_vxlan)
 +				goto tx_error;
 +			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
 +			return;
  		}
  
 +		if (!info)
 +			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
 +
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
  		skb_scrub_packet(skb, xnet);
  		err = vxlan_build_skb(skb, ndst, sizeof(struct ipv6hdr),
  				      vni, md, flags, udp_sum);
++<<<<<<< HEAD
 +		if (err < 0) {
 +			dst_release(ndst);
 +			dev->stats.tx_errors++;
 +			return;
 +		}
 +		udp_tunnel6_xmit_skb(ndst, sk, skb, dev,
++=======
+ 		if (err < 0)
+ 			goto tx_error;
+ 
+ 		udp_tunnel6_xmit_skb(ndst, sock6->sock->sk, skb, dev,
++>>>>>>> 0770b53bd276 (vxlan: simplify vxlan xmit)
  				     &src->sin6.sin6_addr,
  				     &dst->sin6.sin6_addr, tos, ttl,
  				     label, src_port, dst_port, !udp_sum);
* Unmerged path drivers/net/vxlan.c
