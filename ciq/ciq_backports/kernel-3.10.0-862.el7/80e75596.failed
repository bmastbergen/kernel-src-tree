efi: Convert efi_call_virt() to efi_call_virt_pointer()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alex Thorlton <athorlton@sgi.com>
commit 80e75596079f0a41f905836ad0ccaac68ba33612
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/80e75596.failed

This commit makes a few slight modifications to the efi_call_virt() macro
to get it to work with function pointers that are stored in locations
other than efi.systab->runtime, and renames the macro to
efi_call_virt_pointer().  The majority of the changes here are to pull
these macros up into header files so that they can be accessed from
outside of drivers/firmware/efi/runtime-wrappers.c.

The most significant change not directly related to the code move is to
add an extra "p" argument into the appropriate efi_call macros, and use
that new argument in place of the, formerly hard-coded,
efi.systab->runtime pointer.

The last piece of the puzzle was to add an efi_call_virt() macro back into
drivers/firmware/efi/runtime-wrappers.c to wrap around the new
efi_call_virt_pointer() macro - this was mainly to keep the code from
looking too cluttered by adding a bunch of extra references to
efi.systab->runtime everywhere.

Note that I also broke up the code in the efi_call_virt_pointer() macro a
bit in the process of moving it.

	Signed-off-by: Alex Thorlton <athorlton@sgi.com>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dimitri Sivanich <sivanich@sgi.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Roy Franz <roy.franz@linaro.org>
	Cc: Russ Anderson <rja@sgi.com>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: linux-arm-kernel@lists.infradead.org
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/1466839230-12781-5-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 80e75596079f0a41f905836ad0ccaac68ba33612)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/include/asm/efi.h
#	arch/arm64/include/asm/efi.h
#	arch/x86/include/asm/efi.h
#	drivers/firmware/efi/runtime-wrappers.c
#	include/linux/efi.h
diff --cc arch/x86/include/asm/efi.h
index d1a2aa8edaf2,55b4596ef688..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -30,13 -41,10 +30,20 @@@ extern unsigned long asmlinkage efi_cal
  /*
   * Wrap all the virtual calls in a way that forces the parameters on the stack.
   */
++<<<<<<< HEAD
 +
 +/* Use this macro if your virtual returns a non-void value */
 +#define efi_call_virt(f, args...) \
 +	((efi_##f##_t __attribute__((regparm(0)))*)efi.systab->runtime->f)(args)
 +
 +/* Use this macro if your virtual call does not return any value */
 +#define __efi_call_virt(f, args...) efi_call_virt(f, args)
++=======
+ #define arch_efi_call_virt(p, f, args...)				\
+ ({									\
+ 	((efi_##f##_t __attribute__((regparm(0)))*) p->f)(args);	\
+ })
++>>>>>>> 80e75596079f (efi: Convert efi_call_virt() to efi_call_virt_pointer())
  
  #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
  
@@@ -48,25 -56,58 +55,48 @@@ extern u64 asmlinkage efi_call(void *fp
  
  #define efi_call_phys(f, args...)		efi_call((f), args)
  
 -/*
 - * Scratch space used for switching the pagetable in the EFI stub
 - */
 -struct efi_scratch {
 -	u64	r15;
 -	u64	prev_cr3;
 -	pgd_t	*efi_pgt;
 -	bool	use_pgd;
 -	u64	phys_stack;
 -} __packed;
 -
 -#define arch_efi_call_virt_setup()					\
 +#define efi_call_virt(f, ...)						\
  ({									\
 +	efi_status_t __s;						\
 +									\
  	efi_sync_low_kernel_mappings();					\
  	preempt_disable();						\
++<<<<<<< HEAD
 +	__s = efi_call((void *)efi.systab->runtime->f, __VA_ARGS__);	\
++=======
+ 	__kernel_fpu_begin();						\
+ 									\
+ 	if (efi_scratch.use_pgd) {					\
+ 		efi_scratch.prev_cr3 = read_cr3();			\
+ 		write_cr3((unsigned long)efi_scratch.efi_pgt);		\
+ 		__flush_tlb_all();					\
+ 	}								\
+ })
+ 
+ #define arch_efi_call_virt(p, f, args...)				\
+ 	efi_call((void *)p->f, args)					\
+ 
+ #define arch_efi_call_virt_teardown()					\
+ ({									\
+ 	if (efi_scratch.use_pgd) {					\
+ 		write_cr3(efi_scratch.prev_cr3);			\
+ 		__flush_tlb_all();					\
+ 	}								\
+ 									\
+ 	__kernel_fpu_end();						\
++>>>>>>> 80e75596079f (efi: Convert efi_call_virt() to efi_call_virt_pointer())
  	preempt_enable();						\
 +	__s;								\
  })
  
 -extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 -					u32 type, u64 attribute);
 -
 -#ifdef CONFIG_KASAN
  /*
 - * CONFIG_KASAN may redefine memset to __memset.  __memset function is present
 - * only in kernel binary.  Since the EFI stub linked into a separate binary it
 - * doesn't have __memset().  So we should use standard memset from
 - * arch/x86/boot/compressed/string.c.  The same applies to memcpy and memmove.
 + * All X86_64 virt calls return non-void values. Thus, use non-void call for
 + * virt calls that would be void on X86_32.
   */
 -#undef memcpy
 -#undef memset
 -#undef memmove
 -#endif
 +#define __efi_call_virt(f, args...) efi_call_virt(f, args)
 +
 +extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 +					u32 type, u64 attribute);
  
  #endif /* CONFIG_X86_32 */
  
diff --cc include/linux/efi.h
index 0dc4ddccc847,75d148dc9c3f..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1213,4 -1431,104 +1213,107 @@@ static inline int efi_runtime_map_copy(
  
  #endif
  
++<<<<<<< HEAD
++=======
+ /* prototypes shared between arch specific and generic stub code */
+ 
+ #define pr_efi(sys_table, msg)     efi_printk(sys_table, "EFI stub: "msg)
+ #define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
+ 
+ void efi_printk(efi_system_table_t *sys_table_arg, char *str);
+ 
+ void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,
+ 	      unsigned long addr);
+ 
+ char *efi_convert_cmdline(efi_system_table_t *sys_table_arg,
+ 			  efi_loaded_image_t *image, int *cmd_line_len);
+ 
+ efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
+ 				efi_memory_desc_t **map,
+ 				unsigned long *map_size,
+ 				unsigned long *desc_size,
+ 				u32 *desc_ver,
+ 				unsigned long *key_ptr);
+ 
+ efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
+ 			   unsigned long size, unsigned long align,
+ 			   unsigned long *addr);
+ 
+ efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,
+ 			    unsigned long size, unsigned long align,
+ 			    unsigned long *addr, unsigned long max);
+ 
+ efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,
+ 				 unsigned long *image_addr,
+ 				 unsigned long image_size,
+ 				 unsigned long alloc_size,
+ 				 unsigned long preferred_addr,
+ 				 unsigned long alignment);
+ 
+ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
+ 				  efi_loaded_image_t *image,
+ 				  char *cmd_line, char *option_string,
+ 				  unsigned long max_addr,
+ 				  unsigned long *load_addr,
+ 				  unsigned long *load_size);
+ 
+ efi_status_t efi_parse_options(char *cmdline);
+ 
+ efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
+ 			   struct screen_info *si, efi_guid_t *proto,
+ 			   unsigned long size);
+ 
+ bool efi_runtime_disabled(void);
+ extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
+ 
+ /*
+  * Arch code can implement the following three template macros, avoiding
+  * reptition for the void/non-void return cases of {__,}efi_call_virt():
+  *
+  *  * arch_efi_call_virt_setup()
+  *
+  *    Sets up the environment for the call (e.g. switching page tables,
+  *    allowing kernel-mode use of floating point, if required).
+  *
+  *  * arch_efi_call_virt()
+  *
+  *    Performs the call. The last expression in the macro must be the call
+  *    itself, allowing the logic to be shared by the void and non-void
+  *    cases.
+  *
+  *  * arch_efi_call_virt_teardown()
+  *
+  *    Restores the usual kernel environment once the call has returned.
+  */
+ 
+ #define efi_call_virt_pointer(p, f, args...)				\
+ ({									\
+ 	efi_status_t __s;						\
+ 	unsigned long __flags;						\
+ 									\
+ 	arch_efi_call_virt_setup();					\
+ 									\
+ 	local_save_flags(__flags);					\
+ 	__s = arch_efi_call_virt(p, f, args);				\
+ 	efi_call_virt_check_flags(__flags, __stringify(f));		\
+ 									\
+ 	arch_efi_call_virt_teardown();					\
+ 									\
+ 	__s;								\
+ })
+ 
+ #define __efi_call_virt_pointer(p, f, args...)				\
+ ({									\
+ 	unsigned long __flags;						\
+ 									\
+ 	arch_efi_call_virt_setup();					\
+ 									\
+ 	local_save_flags(__flags);					\
+ 	arch_efi_call_virt(p, f, args);					\
+ 	efi_call_virt_check_flags(__flags, __stringify(f));		\
+ 									\
+ 	arch_efi_call_virt_teardown();					\
+ })
+ 
++>>>>>>> 80e75596079f (efi: Convert efi_call_virt() to efi_call_virt_pointer())
  #endif /* _LINUX_EFI_H */
* Unmerged path arch/arm/include/asm/efi.h
* Unmerged path arch/arm64/include/asm/efi.h
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
* Unmerged path arch/arm/include/asm/efi.h
* Unmerged path arch/arm64/include/asm/efi.h
* Unmerged path arch/x86/include/asm/efi.h
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
* Unmerged path include/linux/efi.h
