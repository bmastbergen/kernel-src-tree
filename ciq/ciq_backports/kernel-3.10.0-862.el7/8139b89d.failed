s390/zcrypt: use system work queue for ap_scan_bus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: use system work queue for ap_scan_bus (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 94.74%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 8139b89d7cc5f53cff63a72c8e226385f34a70a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8139b89d.failed

There is a system work queue system_long_wq for long running work.
Use this work queue for the AP bus scan loop.

Reviewd-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 8139b89d7cc5f53cff63a72c8e226385f34a70a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,9cb3dfbcaddb..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -97,12 -76,12 +97,16 @@@ static DEFINE_SPINLOCK(ap_device_list_l
  static LIST_HEAD(ap_device_list);
  
  /*
-  * Workqueue & timer for bus rescan.
+  * Workqueue timer for bus rescan.
   */
- static struct workqueue_struct *ap_work_queue;
  static struct timer_list ap_config_timer;
  static int ap_config_time = AP_CONFIG_TIME;
++<<<<<<< HEAD
 +static DECLARE_WORK(ap_config_work, ap_scan_bus);
++=======
+ static void ap_scan_bus(struct work_struct *);
+ static DECLARE_WORK(ap_scan_work, ap_scan_bus);
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  
  /*
   * Tasklet & timer for AP request polling and interrupts
@@@ -878,58 -1234,74 +882,101 @@@ static int ap_bus_suspend(struct devic
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int ap_bus_resume(struct device *dev)
++=======
+ static int ap_dev_resume(struct device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static void ap_bus_suspend(void)
+ {
+ 	ap_suspend_flag = 1;
+ 	/*
+ 	 * Disable scanning for devices, thus we do not want to scan
+ 	 * for them after removing.
+ 	 */
+ 	flush_work(&ap_scan_work);
+ 	tasklet_disable(&ap_tasklet);
+ }
+ 
+ static int __ap_devices_unregister(struct device *dev, void *dummy)
+ {
+ 	device_unregister(dev);
+ 	return 0;
+ }
+ 
+ static void ap_bus_resume(void)
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  {
 +	struct ap_device *ap_dev = to_ap_dev(dev);
  	int rc;
  
 -	/* Unconditionally remove all AP devices */
 -	bus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_devices_unregister);
 -	/* Reset thin interrupt setting */
 -	if (ap_interrupts_available() && !ap_using_interrupts()) {
 -		rc = register_adapter_interrupt(&ap_airq);
 -		ap_airq_flag = (rc == 0);
 +	if (ap_suspend_flag) {
 +		ap_suspend_flag = 0;
 +		if (ap_interrupts_available()) {
 +			if (!ap_using_interrupts()) {
 +				rc = register_adapter_interrupt(&ap_airq);
 +				ap_airq_flag = (rc == 0);
 +			}
 +		} else {
 +			if (ap_using_interrupts()) {
 +				unregister_adapter_interrupt(&ap_airq);
 +				ap_airq_flag = 0;
 +			}
 +		}
 +		ap_query_configuration();
 +		if (!user_set_domain) {
 +			ap_domain_index = -1;
 +			ap_select_domain();
 +		}
 +		init_timer(&ap_config_timer);
 +		ap_config_timer.function = ap_config_timeout;
 +		ap_config_timer.data = 0;
 +		ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +		add_timer(&ap_config_timer);
 +		ap_work_queue = create_singlethread_workqueue("kapwork");
 +		if (!ap_work_queue)
 +			return -ENOMEM;
 +		tasklet_enable(&ap_tasklet);
 +		if (!ap_using_interrupts())
 +			ap_schedule_poll_timer();
 +		else
 +			tasklet_schedule(&ap_tasklet);
 +		if (ap_thread_flag)
 +			rc = ap_poll_thread_start();
 +		else
 +			rc = 0;
 +	} else
 +		rc = 0;
 +	if (AP_QID_QUEUE(ap_dev->qid) != ap_domain_index) {
 +		spin_lock_bh(&ap_dev->lock);
 +		ap_dev->qid = AP_MKQID(AP_QID_DEVICE(ap_dev->qid),
 +				       ap_domain_index);
 +		spin_unlock_bh(&ap_dev->lock);
  	}
++<<<<<<< HEAD
 +	queue_work(ap_work_queue, &ap_config_work);
++=======
+ 	if (!ap_interrupts_available() && ap_using_interrupts()) {
+ 		unregister_adapter_interrupt(&ap_airq);
+ 		ap_airq_flag = 0;
+ 	}
+ 	/* Reset domain */
+ 	if (!user_set_domain)
+ 		ap_domain_index = -1;
+ 	/* Get things going again */
+ 	ap_suspend_flag = 0;
+ 	if (ap_airq_flag)
+ 		xchg(ap_airq.lsi_ptr, 0);
+ 	tasklet_enable(&ap_tasklet);
+ 	queue_work(system_long_wq, &ap_scan_work);
+ }
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  
 -static int ap_power_event(struct notifier_block *this, unsigned long event,
 -			  void *ptr)
 -{
 -	switch (event) {
 -	case PM_HIBERNATION_PREPARE:
 -	case PM_SUSPEND_PREPARE:
 -		ap_bus_suspend();
 -		break;
 -	case PM_POST_HIBERNATION:
 -	case PM_POST_SUSPEND:
 -		ap_bus_resume();
 -		break;
 -	default:
 -		break;
 -	}
 -	return NOTIFY_DONE;
 +	return rc;
  }
 -static struct notifier_block ap_power_notifier = {
 -	.notifier_call = ap_power_event,
 -};
  
  static struct bus_type ap_bus_type = {
  	.name = "ap",
@@@ -1034,11 -1401,12 +1081,17 @@@ EXPORT_SYMBOL(ap_driver_unregister)
  
  void ap_bus_force_rescan(void)
  {
 -	if (ap_suspend_flag)
 -		return;
 +	/* reconfigure the AP bus rescan timer. */
 +	mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);
  	/* processing a asynchronous bus rescan */
++<<<<<<< HEAD
 +	queue_work(ap_work_queue, &ap_config_work);
 +	flush_work(&ap_config_work);
++=======
+ 	del_timer(&ap_config_timer);
+ 	queue_work(system_long_wq, &ap_scan_work);
+ 	flush_work(&ap_scan_work);
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  }
  EXPORT_SYMBOL(ap_bus_force_rescan);
  
@@@ -1538,476 -1682,20 +1591,482 @@@ static void ap_scan_bus(struct work_str
  		/* Add device attributes. */
  		rc = sysfs_create_group(&ap_dev->device.kobj,
  					&ap_dev_attr_group);
 -		if (rc) {
 +		if (!rc) {
 +			spin_lock_bh(&ap_dev->lock);
 +			ap_dev->unregistered = AP_DEV_REGISTERED;
 +			spin_unlock_bh(&ap_dev->lock);
 +		}
 +		else
  			device_unregister(&ap_dev->device);
 +	}
 +}
 +
 +static void
 +ap_config_timeout(unsigned long ptr)
 +{
++<<<<<<< HEAD
 +	queue_work(ap_work_queue, &ap_config_work);
 +	ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +	add_timer(&ap_config_timer);
 +}
 +
 +/**
 + * ap_poll_read(): Receive pending reply messages from an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_read(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->queue_count <= 0)
 +		return 0;
 +	status = __ap_recv(ap_dev->qid, &ap_dev->reply->psmid,
 +			   ap_dev->reply->message, ap_dev->reply->length);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		ap_dev->interrupt = status.int_enabled;
 +		atomic_dec(&ap_poll_requests);
 +		ap_decrease_queue_count(ap_dev);
 +		list_for_each_entry(ap_msg, &ap_dev->pendingq, list) {
 +			if (ap_msg->psmid != ap_dev->reply->psmid)
 +				continue;
 +			list_del_init(&ap_msg->list);
 +			ap_dev->pendingq_count--;
 +			ap_msg->receive(ap_dev, ap_msg, ap_dev->reply);
 +			break;
 +		}
 +		if (ap_dev->queue_count > 0)
 +			*flags |= 1;
 +		break;
 +	case AP_RESPONSE_NO_PENDING_REPLY:
 +		ap_dev->interrupt = status.int_enabled;
 +		if (status.queue_empty) {
 +			/* The card shouldn't forget requests but who knows. */
 +			atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +			ap_dev->queue_count = 0;
 +			list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +			ap_dev->requestq_count += ap_dev->pendingq_count;
 +			ap_dev->pendingq_count = 0;
 +		} else
 +			*flags |= 2;
 +		break;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_write(): Send messages from the request queue to an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_write(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->requestq_count <= 0 ||
 +	    (ap_dev->queue_count >= ap_dev->queue_depth) ||
 +	    (ap_dev->reset == AP_RESET_IN_PROGRESS))
 +		return 0;
 +	/* Start the next request on the queue. */
 +	ap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);
 +	status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +			   ap_msg->message, ap_msg->length, ap_msg->special);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		atomic_inc(&ap_poll_requests);
 +		ap_increase_queue_count(ap_dev);
 +		list_move_tail(&ap_msg->list, &ap_dev->pendingq);
 +		ap_dev->requestq_count--;
 +		ap_dev->pendingq_count++;
 +		if (ap_dev->queue_count < ap_dev->queue_depth &&
 +		    ap_dev->requestq_count > 0)
 +			*flags |= 1;
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +		__ap_schedule_poll_timer();
 +	case AP_RESPONSE_Q_FULL:
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_MESSAGE_TOO_BIG:
 +	case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		return -EINVAL;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_queue(): Poll AP device for pending replies and send new messages.
 + * Check if the queue has a pending reset. In case it's done re-enable
 + * interrupts, otherwise reschedule the poll_timer for another attempt.
 + * @ap_dev: pointer to the bus device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Poll AP device for pending replies and send new messages. If either
 + * ap_poll_read or ap_poll_write returns -ENODEV unregister the device.
 + * Returns 0.
 + */
 +static inline int ap_poll_queue(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc, depth, type;
 +	struct ap_queue_status status;
 +
 +
 +	if (ap_dev->reset == AP_RESET_IN_PROGRESS) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			ap_dev->reset = AP_RESET_IGNORE;
 +			if (ap_using_interrupts()) {
 +				rc = ap_queue_enable_interruption(
 +					ap_dev, ap_airq.lsi_ptr);
 +				if (!rc)
 +					ap_dev->interrupt = AP_INTR_IN_PROGRESS;
 +				else if (rc == -ENODEV) {
 +					pr_err("Registering adapter interrupts for "
 +					"AP %d failed\n", AP_QID_DEVICE(ap_dev->qid));
 +					return rc;
 +				}
 +			}
 +			/* fall through */
 +		case AP_RESPONSE_BUSY:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			*flags |= AP_POLL_AFTER_TIMEOUT;
 +			break;
 +		case AP_RESPONSE_Q_NOT_AVAIL:
 +		case AP_RESPONSE_DECONFIGURED:
 +		case AP_RESPONSE_CHECKSTOPPED:
 +			return -ENODEV;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	if ((ap_dev->reset != AP_RESET_IN_PROGRESS) &&
 +		(ap_dev->interrupt == AP_INTR_IN_PROGRESS)) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		if (ap_using_interrupts()) {
 +			if (status.int_enabled == 1)
 +				ap_dev->interrupt = AP_INTR_ENABLED;
 +			else
 +				*flags |= AP_POLL_AFTER_TIMEOUT;
 +		} else
 +			ap_dev->interrupt = AP_INTR_DISABLED;
 +	}
 +
 +	rc = ap_poll_read(ap_dev, flags);
 +	if (rc)
 +		return rc;
 +	return ap_poll_write(ap_dev, flags);
 +}
 +
 +/**
 + * __ap_queue_message(): Queue a message to a device.
 + * @ap_dev: pointer to the AP device
 + * @ap_msg: the message to be queued
 + *
 + * Queue a message to a device. Returns 0 if successful.
 + */
 +static int __ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_queue_status status;
 +
 +	if (list_empty(&ap_dev->requestq) &&
 +	    (ap_dev->queue_count < ap_dev->queue_depth) &&
 +	    (ap_dev->reset != AP_RESET_IN_PROGRESS)) {
 +		status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +				   ap_msg->message, ap_msg->length,
 +				   ap_msg->special);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			list_add_tail(&ap_msg->list, &ap_dev->pendingq);
 +			atomic_inc(&ap_poll_requests);
 +			ap_dev->pendingq_count++;
 +			ap_increase_queue_count(ap_dev);
 +			ap_dev->total_request_count++;
 +			break;
 +		case AP_RESPONSE_Q_FULL:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +			ap_dev->requestq_count++;
 +			ap_dev->total_request_count++;
 +			return -EBUSY;
 +		case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		case AP_RESPONSE_MESSAGE_TOO_BIG:
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EINVAL));
 +			return -EINVAL;
 +		default:	/* Device is gone. */
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +			return -ENODEV;
 +		}
 +	} else {
 +		list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +		ap_dev->requestq_count++;
 +		ap_dev->total_request_count++;
 +		return -EBUSY;
 +	}
 +	ap_schedule_poll_timer();
 +	return 0;
 +}
 +
 +void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	unsigned long flags;
 +	int rc;
 +
 +	/* For asynchronous message handling a valid receive-callback
 +	 * is required. */
 +	BUG_ON(!ap_msg->receive);
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!ap_dev->unregistered) {
 +		/* Make room on the queue by polling for finished requests. */
 +		rc = ap_poll_queue(ap_dev, &flags);
 +		if (!rc)
 +			rc = __ap_queue_message(ap_dev, ap_msg);
 +		if (!rc)
 +			wake_up(&ap_poll_wait);
 +		if (rc == -ENODEV) {
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		}
 +	} else if (ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		rc = -ENODEV;
 +	} else { /* device registration in progress */
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EBUSY));
 +		rc = -EBUSY;
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +
 +	/* no device_unregister(), let ap_scan_bus() do the job */
 +}
 +EXPORT_SYMBOL(ap_queue_message);
 +
 +/**
 + * ap_cancel_message(): Cancel a crypto request.
 + * @ap_dev: The AP device that has the message queued
 + * @ap_msg: The message that is to be removed
 + *
 + * Cancel a crypto request. This is done by removing the request
 + * from the device pending or request queue. Note that the
 + * request stays on the AP queue. When it finishes the message
 + * reply will be discarded because the psmid can't be found.
 + */
 +void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_message *tmp;
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!list_empty(&ap_msg->list)) {
 +		list_for_each_entry(tmp, &ap_dev->pendingq, list)
 +			if (tmp->psmid == ap_msg->psmid) {
 +				ap_dev->pendingq_count--;
 +				goto found;
 +			}
 +		ap_dev->requestq_count--;
 +	found:
 +		list_del_init(&ap_msg->list);
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +}
 +EXPORT_SYMBOL(ap_cancel_message);
 +
 +/**
 + * ap_poll_timeout(): AP receive polling for finished AP requests.
 + * @unused: Unused pointer.
 + *
 + * Schedules the AP tasklet using a high resolution timer.
 + */
 +static enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)
 +{
 +	tasklet_schedule(&ap_tasklet);
 +	return HRTIMER_NORESTART;
 +}
 +
 +/**
 + * ap_reset(): Reset a not responding AP device.
 + * @ap_dev: Pointer to the AP device
 + *
 + * Reset a not responding AP device and move all requests from the
 + * pending queue to the request queue.
 + */
 +static void ap_reset(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +	ap_dev->queue_count = 0;
 +	list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +	ap_dev->requestq_count += ap_dev->pendingq_count;
 +	ap_dev->pendingq_count = 0;
 +	rc = ap_init_queue(ap_dev);
 +	if (rc == -ENODEV)
 +		ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +	else
 +		*flags |= AP_POLL_AFTER_TIMEOUT;
 +}
 +
 +static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	if (!ap_dev->unregistered) {
 +		rc = ap_poll_queue(ap_dev, flags);
 +		if (rc == -ENODEV)
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +		if (ap_dev->reset == AP_RESET_DO)
 +			ap_reset(ap_dev, flags);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_all(): Poll all AP devices.
 + * @dummy: Unused variable
 + *
 + * Poll all AP devices on the bus in a round robin fashion. Continue
 + * polling until bit 2^0 of the control flags is not set. If bit 2^1
 + * of the control flags has been set arm the poll timer.
 + */
 +static void ap_poll_all(unsigned long dummy)
 +{
 +	unsigned long flags;
 +	struct ap_device *ap_dev;
 +
 +	/* Reset the indicator if interrupts are used. Thus new interrupts can
 +	 * be received. Doing it in the beginning of the tasklet is therefor
 +	 * important that no requests on any AP get lost.
 +	 */
 +	if (ap_using_interrupts())
 +		xchg(ap_airq.lsi_ptr, 0);
 +	do {
 +		flags = 0;
 +		spin_lock(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock(&ap_device_list_lock);
 +	} while (flags & AP_POLL_IMMEDIATELY);
 +	if (flags & AP_POLL_AFTER_TIMEOUT)
 +		__ap_schedule_poll_timer();
 +}
 +
 +/**
 + * ap_poll_thread(): Thread that polls for finished requests.
 + * @data: Unused pointer
 + *
 + * AP bus poll thread. The purpose of this thread is to poll for
 + * finished requests in a loop if there is a "free" cpu - that is
 + * a cpu that doesn't have anything better to do. The polling stops
 + * as soon as there is another task or if all messages have been
 + * delivered.
 + */
 +static int ap_poll_thread(void *data)
 +{
 +	DECLARE_WAITQUEUE(wait, current);
 +	unsigned long flags;
 +	int requests;
 +	struct ap_device *ap_dev;
 +
 +	set_user_nice(current, 19);
 +	while (1) {
 +		if (ap_suspend_flag)
 +			return 0;
 +		if (need_resched()) {
 +			schedule();
  			continue;
  		}
 +		add_wait_queue(&ap_poll_wait, &wait);
 +		set_current_state(TASK_INTERRUPTIBLE);
 +		if (kthread_should_stop())
 +			break;
 +		requests = atomic_read(&ap_poll_requests);
 +		if (requests <= 0)
 +			schedule();
 +		set_current_state(TASK_RUNNING);
 +		remove_wait_queue(&ap_poll_wait, &wait);
 +
 +		flags = 0;
 +		spin_lock_bh(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock_bh(&ap_device_list_lock);
  	}
 -out:
 -	mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);
 +	set_current_state(TASK_RUNNING);
 +	remove_wait_queue(&ap_poll_wait, &wait);
 +	return 0;
  }
  
 -static void ap_config_timeout(unsigned long ptr)
 +static int ap_poll_thread_start(void)
  {
 +	int rc;
 +
 +	if (ap_using_interrupts() || ap_suspend_flag)
 +		return 0;
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (!ap_poll_kthread) {
 +		ap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");
 +		rc = IS_ERR(ap_poll_kthread) ? PTR_ERR(ap_poll_kthread) : 0;
 +		if (rc)
 +			ap_poll_kthread = NULL;
 +	}
 +	else
 +		rc = 0;
 +	mutex_unlock(&ap_poll_thread_mutex);
 +	return rc;
 +}
 +
 +static void ap_poll_thread_stop(void)
 +{
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (ap_poll_kthread) {
 +		kthread_stop(ap_poll_kthread);
 +		ap_poll_kthread = NULL;
 +	}
 +	mutex_unlock(&ap_poll_thread_mutex);
 +}
 +
 +/**
 + * ap_request_timeout(): Handling of request timeouts
 + * @data: Holds the AP device.
 + *
 + * Handles request timeouts.
 + */
 +static void ap_request_timeout(unsigned long data)
 +{
 +	struct ap_device *ap_dev = (struct ap_device *) data;
 +
 +	if (ap_dev->reset == AP_RESET_ARMED) {
 +		ap_dev->reset = AP_RESET_DO;
 +
 +		if (ap_using_interrupts())
 +			tasklet_schedule(&ap_tasklet);
 +	}
++=======
+ 	if (ap_suspend_flag)
+ 		return;
+ 	queue_work(system_long_wq, &ap_scan_work);
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  }
  
  static void ap_reset_domain(void)
@@@ -2086,24 -1783,11 +2145,29 @@@ int __init ap_module_init(void
  	if (rc)
  		goto out_bus;
  
++<<<<<<< HEAD
 +	ap_work_queue = create_singlethread_workqueue("kapwork");
 +	if (!ap_work_queue) {
 +		rc = -ENOMEM;
 +		goto out_root;
 +	}
 +
 +	ap_query_configuration();
 +	if (ap_select_domain() == 0)
 +		ap_scan_bus(NULL);
++=======
+ 	/* Setup the AP bus rescan timer. */
+ 	setup_timer(&ap_config_timer, ap_config_timeout, 0);
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  
 -	/*
 -	 * Setup the high resultion poll timer.
 +	/* Setup the AP bus rescan timer. */
 +	init_timer(&ap_config_timer);
 +	ap_config_timer.function = ap_config_timeout;
 +	ap_config_timer.data = 0;
 +	ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +	add_timer(&ap_config_timer);
 +
 +	/* Setup the high resultion poll timer.
  	 * If we are running under z/VM adjust polling to z/VM polling rate.
  	 */
  	if (MACHINE_IS_VM)
@@@ -2119,13 -1803,18 +2183,20 @@@
  			goto out_work;
  	}
  
++<<<<<<< HEAD
++=======
+ 	rc = register_pm_notifier(&ap_power_notifier);
+ 	if (rc)
+ 		goto out_pm;
+ 
+ 	queue_work(system_long_wq, &ap_scan_work);
+ 
++>>>>>>> 8139b89d7cc5 (s390/zcrypt: use system work queue for ap_scan_bus)
  	return 0;
  
 -out_pm:
 -	ap_poll_thread_stop();
  out_work:
 +	del_timer_sync(&ap_config_timer);
  	hrtimer_cancel(&ap_poll_timer);
- 	destroy_workqueue(ap_work_queue);
- out_root:
  	root_device_unregister(ap_root_device);
  out_bus:
  	while (i--)
@@@ -2157,18 -1841,14 +2228,17 @@@ void ap_module_exit(void
  	ap_poll_thread_stop();
  	del_timer_sync(&ap_config_timer);
  	hrtimer_cancel(&ap_poll_timer);
- 	destroy_workqueue(ap_work_queue);
  	tasklet_kill(&ap_tasklet);
 -	bus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_devices_unregister);
 +	while ((dev = bus_find_device(&ap_bus_type, NULL, NULL,
 +		    __ap_match_all)))
 +	{
 +		device_unregister(dev);
 +		put_device(dev);
 +	}
  	for (i = 0; ap_bus_attrs[i]; i++)
  		bus_remove_file(&ap_bus_type, ap_bus_attrs[i]);
 -	unregister_pm_notifier(&ap_power_notifier);
  	root_device_unregister(ap_root_device);
  	bus_unregister(&ap_bus_type);
 -	kfree(ap_configuration);
  	unregister_reset_call(&ap_reset_call);
  	if (ap_using_interrupts())
  		unregister_adapter_interrupt(&ap_airq);
* Unmerged path drivers/s390/crypto/ap_bus.c
