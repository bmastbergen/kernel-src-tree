Fix extra line print in rqpair debug print.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix extra line print in rqpair debug print (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 92.31%
commit-author James Smart <jsmart2021@gmail.com>
commit afbb38fedaa25935b963b07cc10f72a25bb3acbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/afbb38fe.failed

An extra blank line was being added the the rqpair printing.

Remove the extra line feed.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
(cherry picked from commit afbb38fedaa25935b963b07cc10f72a25bb3acbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_debugfs.c
diff --cc drivers/scsi/lpfc/lpfc_debugfs.c
index e6cf568b0f02,55a8d8ffcfd4..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@@ -1988,6 -3027,201 +1988,204 @@@ error_out
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ __lpfc_idiag_print_wq(struct lpfc_queue *qp, char *wqtype,
+ 			char *pbuffer, int len)
+ {
+ 	if (!qp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\t%s WQ info: ", wqtype);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"AssocCQID[%04d]: WQ-STAT[oflow:x%x posted:x%llx]\n",
+ 			qp->assoc_qid, qp->q_cnt_1,
+ 			(unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\tWQID[%02d], QE-CNT[%04d], QE-SIZE[%04d], "
+ 			"HOST-IDX[%04d], PORT-IDX[%04d]",
+ 			qp->queue_id, qp->entry_count,
+ 			qp->entry_size, qp->host_index,
+ 			qp->hba_index);
+ 	len +=  snprintf(pbuffer + len,
+ 			LPFC_QUE_INFO_GET_BUF_SIZE - len, "\n");
+ 	return len;
+ }
+ 
+ static int
+ lpfc_idiag_wqs_for_cq(struct lpfc_hba *phba, char *wqtype, char *pbuffer,
+ 		int *len, int max_cnt, int cq_id)
+ {
+ 	struct lpfc_queue *qp;
+ 	int qidx;
+ 
+ 	for (qidx = 0; qidx < phba->cfg_fcp_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.fcp_wq[qidx];
+ 		if (qp->assoc_qid != cq_id)
+ 			continue;
+ 		*len = __lpfc_idiag_print_wq(qp, wqtype, pbuffer, *len);
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 	for (qidx = 0; qidx < phba->cfg_nvme_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.nvme_wq[qidx];
+ 		if (qp->assoc_qid != cq_id)
+ 			continue;
+ 		*len = __lpfc_idiag_print_wq(qp, wqtype, pbuffer, *len);
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ static int
+ __lpfc_idiag_print_cq(struct lpfc_queue *qp, char *cqtype,
+ 			char *pbuffer, int len)
+ {
+ 	if (!qp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t%s CQ info: ", cqtype);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"AssocEQID[%02d]: CQ STAT[max:x%x relw:x%x "
+ 			"xabt:x%x wq:x%llx]\n",
+ 			qp->assoc_qid, qp->q_cnt_1, qp->q_cnt_2,
+ 			qp->q_cnt_3, (unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\tCQID[%02d], QE-CNT[%04d], QE-SIZE[%04d], "
+ 			"HOST-IDX[%04d], PORT-IDX[%04d]",
+ 			qp->queue_id, qp->entry_count,
+ 			qp->entry_size, qp->host_index,
+ 			qp->hba_index);
+ 
+ 	len +=  snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len, "\n");
+ 
+ 	return len;
+ }
+ 
+ static int
+ __lpfc_idiag_print_rqpair(struct lpfc_queue *qp, struct lpfc_queue *datqp,
+ 			char *rqtype, char *pbuffer, int len)
+ {
+ 	if (!qp || !datqp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\t%s RQ info: ", rqtype);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"AssocCQID[%02d]: RQ-STAT[nopost:x%x nobuf:x%x "
+ 			"trunc:x%x rcv:x%llx]\n",
+ 			qp->assoc_qid, qp->q_cnt_1, qp->q_cnt_2,
+ 			qp->q_cnt_3, (unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\tHQID[%02d], QE-CNT[%04d], QE-SIZE[%04d], "
+ 			"HOST-IDX[%04d], PORT-IDX[%04d]\n",
+ 			qp->queue_id, qp->entry_count, qp->entry_size,
+ 			qp->host_index, qp->hba_index);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\t\tDQID[%02d], QE-CNT[%04d], QE-SIZE[%04d], "
+ 			"HOST-IDX[%04d], PORT-IDX[%04d]\n",
+ 			datqp->queue_id, datqp->entry_count,
+ 			datqp->entry_size, datqp->host_index,
+ 			datqp->hba_index);
+ 	return len;
+ }
+ 
+ static int
+ lpfc_idiag_cqs_for_eq(struct lpfc_hba *phba, char *pbuffer,
+ 		int *len, int max_cnt, int eqidx, int eq_id)
+ {
+ 	struct lpfc_queue *qp;
+ 	int qidx, rc;
+ 
+ 	for (qidx = 0; qidx < phba->cfg_fcp_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.fcp_cq[qidx];
+ 		if (qp->assoc_qid != eq_id)
+ 			continue;
+ 
+ 		*len = __lpfc_idiag_print_cq(qp, "FCP", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		rc = lpfc_idiag_wqs_for_cq(phba, "FCP", pbuffer, len,
+ 				max_cnt, qp->queue_id);
+ 		if (rc)
+ 			return 1;
+ 	}
+ 
+ 	for (qidx = 0; qidx < phba->cfg_nvme_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.nvme_cq[qidx];
+ 		if (qp->assoc_qid != eq_id)
+ 			continue;
+ 
+ 		*len = __lpfc_idiag_print_cq(qp, "NVME", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		rc = lpfc_idiag_wqs_for_cq(phba, "NVME", pbuffer, len,
+ 				max_cnt, qp->queue_id);
+ 		if (rc)
+ 			return 1;
+ 	}
+ 
+ 	if (eqidx < phba->cfg_nvmet_mrq) {
+ 		/* NVMET CQset */
+ 		qp = phba->sli4_hba.nvmet_cqset[eqidx];
+ 		*len = __lpfc_idiag_print_cq(qp, "NVMET CQset", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		/* RQ header */
+ 		qp = phba->sli4_hba.nvmet_mrq_hdr[eqidx];
+ 		*len = __lpfc_idiag_print_rqpair(qp,
+ 				phba->sli4_hba.nvmet_mrq_data[eqidx],
+ 				"NVMET MRQ", pbuffer, *len);
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ __lpfc_idiag_print_eq(struct lpfc_queue *qp, char *eqtype,
+ 			char *pbuffer, int len)
+ {
+ 	if (!qp)
+ 		return len;
+ 
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"\n%s EQ info: EQ-STAT[max:x%x noE:x%x "
+ 			"bs:x%x proc:x%llx]\n",
+ 			eqtype, qp->q_cnt_1, qp->q_cnt_2, qp->q_cnt_3,
+ 			(unsigned long long)qp->q_cnt_4);
+ 	len += snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,
+ 			"EQID[%02d], QE-CNT[%04d], QE-SIZE[%04d], "
+ 			"HOST-IDX[%04d], PORT-IDX[%04d]",
+ 			qp->queue_id, qp->entry_count, qp->entry_size,
+ 			qp->host_index, qp->hba_index);
+ 	len +=  snprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len, "\n");
+ 
+ 	return len;
+ }
+ 
++>>>>>>> afbb38fedaa2 (Fix extra line print in rqpair debug print.)
  /**
   * lpfc_idiag_queinfo_read - idiag debugfs read queue information
   * @file: The file pointer to read from.
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.c
