net_sched: fix a memory leak in tc action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 18fcf49f87f4b280d3cd695fc77766004b223af5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/18fcf49f.failed

Fixes: ddf97ccdd7cb ("net_sched: add network namespace support for tc actions")
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Tested-by: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 18fcf49f87f4b280d3cd695fc77766004b223af5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
diff --cc include/net/act_api.h
index 7eba1aba336b,03e322b30218..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -114,19 -104,51 +114,61 @@@ struct tc_action_ops 
  	int     (*init)(struct net *net, struct nlattr *nla,
  			struct nlattr *est, struct tc_action *act, int ovr,
  			int bind);
 -	int     (*walk)(struct net *, struct sk_buff *,
 -			struct netlink_callback *, int, struct tc_action *);
 +	int     (*walk)(struct sk_buff *, struct netlink_callback *, int, struct tc_action *);
 +	void	(*stats_update)(struct tc_action *, u64, u32, u64);
 +	int	(*get_dev)(const struct tc_action *a, struct net *net,
 +			   struct net_device **mirred_dev);
  };
  
++<<<<<<< HEAD
 +int tcf_hash_search(struct tc_action *a, u32 index);
 +u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats);
++=======
+ struct tc_action_net {
+ 	struct tcf_hashinfo *hinfo;
+ 	const struct tc_action_ops *ops;
+ };
+ 
+ static inline
+ int tc_action_net_init(struct tc_action_net *tn, const struct tc_action_ops *ops,
+ 		       unsigned int mask)
+ {
+ 	int err = 0;
+ 
+ 	tn->hinfo = kmalloc(sizeof(*tn->hinfo), GFP_KERNEL);
+ 	if (!tn->hinfo)
+ 		return -ENOMEM;
+ 	tn->ops = ops;
+ 	err = tcf_hashinfo_init(tn->hinfo, mask);
+ 	if (err)
+ 		kfree(tn->hinfo);
+ 	return err;
+ }
+ 
+ void tcf_hashinfo_destroy(const struct tc_action_ops *ops,
+ 			  struct tcf_hashinfo *hinfo);
+ 
+ static inline void tc_action_net_exit(struct tc_action_net *tn)
+ {
+ 	tcf_hashinfo_destroy(tn->ops, tn->hinfo);
+ 	kfree(tn->hinfo);
+ }
+ 
+ int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
+ 		       struct netlink_callback *cb, int type,
+ 		       struct tc_action *a);
+ int tcf_hash_search(struct tc_action_net *tn, struct tc_action *a, u32 index);
+ u32 tcf_hash_new_index(struct tc_action_net *tn);
+ int tcf_hash_check(struct tc_action_net *tn, u32 index, struct tc_action *a,
+ 		   int bind);
+ int tcf_hash_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		    struct tc_action *a, int size, int bind, bool cpustats);
++>>>>>>> 18fcf49f87f4 (net_sched: fix a memory leak in tc action)
  void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 -void tcf_hash_insert(struct tc_action_net *tn, struct tc_action *a);
 +void tcf_hash_insert(struct tc_action *a);
  
  int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
  
* Unmerged path include/net/act_api.h
