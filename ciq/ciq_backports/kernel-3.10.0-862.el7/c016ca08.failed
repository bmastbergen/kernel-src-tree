efi: Add NV memory attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Robert Elliott <elliott@hpe.com>
commit c016ca08f89c6c78ed815f025262bdb87aba3f4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c016ca08.failed

Add the NV memory attribute introduced in UEFI 2.5 and add a
column for it in the types and attributes string used when
printing the UEFI memory map.

old:
  efi: mem61: [type=14            |   |  |  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)

new:
  efi: mem61: [type=14            |   |  |NV|  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)

	Signed-off-by: Robert Elliott <elliott@hpe.com>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Reviewed-by: Laszlo Ersek <lersek@redhat.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/1454364428-494-13-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c016ca08f89c6c78ed815f025262bdb87aba3f4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
diff --cc drivers/firmware/efi/efi.c
index 298ffe5c759a,f4370485c26a..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -374,9 -393,246 +374,184 @@@ int __init efi_config_init(efi_config_t
  		if (!match_config_table(&guid, table, common_tables))
  			match_config_table(&guid, table, arch_tables);
  
++<<<<<<< HEAD
  		tablep += sz;
 -	}
 -	pr_cont("\n");
 -	set_bit(EFI_CONFIG_TABLES, &efi.flags);
 -
 -	/* Parse the EFI Properties table if it exists */
 -	if (efi.properties_table != EFI_INVALID_TABLE_ADDR) {
 -		efi_properties_table_t *tbl;
 -
 -		tbl = early_memremap(efi.properties_table, sizeof(*tbl));
 -		if (tbl == NULL) {
 -			pr_err("Could not map Properties table!\n");
 -			return -ENOMEM;
 -		}
 -
 -		if (tbl->memory_protection_attribute &
 -		    EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA)
 -			set_bit(EFI_NX_PE_DATA, &efi.flags);
 -
 -		early_memunmap(tbl, sizeof(*tbl));
 -	}
 -
 -	return 0;
 -}
 -
 -int __init efi_config_init(efi_config_table_type_t *arch_tables)
 -{
 -	void *config_tables;
 -	int sz, ret;
 -
 -	if (efi_enabled(EFI_64BIT))
 -		sz = sizeof(efi_config_table_64_t);
 -	else
 -		sz = sizeof(efi_config_table_32_t);
 -
 -	/*
 -	 * Let's see what config tables the firmware passed to us.
 -	 */
 -	config_tables = early_memremap(efi.systab->tables,
 -				       efi.systab->nr_tables * sz);
 -	if (config_tables == NULL) {
 -		pr_err("Could not map Configuration table!\n");
 -		return -ENOMEM;
 -	}
 -
 -	ret = efi_config_parse_tables(config_tables, efi.systab->nr_tables, sz,
 -				      arch_tables);
 -
 -	early_memunmap(config_tables, efi.systab->nr_tables * sz);
 -	return ret;
 -}
 -
 -#ifdef CONFIG_EFI_VARS_MODULE
 -static int __init efi_load_efivars(void)
 -{
 -	struct platform_device *pdev;
 -
 -	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 -		return 0;
 -
 -	pdev = platform_device_register_simple("efivars", 0, NULL, 0);
 -	return IS_ERR(pdev) ? PTR_ERR(pdev) : 0;
 -}
 -device_initcall(efi_load_efivars);
 -#endif
 -
 -#ifdef CONFIG_EFI_PARAMS_FROM_FDT
 -
++=======
+ #define UEFI_PARAM(name, prop, field)			   \
+ 	{						   \
+ 		{ name },				   \
+ 		{ prop },				   \
+ 		offsetof(struct efi_fdt_params, field),    \
+ 		FIELD_SIZEOF(struct efi_fdt_params, field) \
+ 	}
+ 
+ static __initdata struct {
+ 	const char name[32];
+ 	const char propname[32];
+ 	int offset;
+ 	int size;
+ } dt_params[] = {
+ 	UEFI_PARAM("System Table", "linux,uefi-system-table", system_table),
+ 	UEFI_PARAM("MemMap Address", "linux,uefi-mmap-start", mmap),
+ 	UEFI_PARAM("MemMap Size", "linux,uefi-mmap-size", mmap_size),
+ 	UEFI_PARAM("MemMap Desc. Size", "linux,uefi-mmap-desc-size", desc_size),
+ 	UEFI_PARAM("MemMap Desc. Version", "linux,uefi-mmap-desc-ver", desc_ver)
+ };
+ 
+ struct param_info {
+ 	int found;
+ 	void *params;
+ };
+ 
+ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
+ 				       int depth, void *data)
+ {
+ 	struct param_info *info = data;
+ 	const void *prop;
+ 	void *dest;
+ 	u64 val;
+ 	int i, len;
+ 
+ 	if (depth != 1 || strcmp(uname, "chosen") != 0)
+ 		return 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
+ 		prop = of_get_flat_dt_prop(node, dt_params[i].propname, &len);
+ 		if (!prop)
+ 			return 0;
+ 		dest = info->params + dt_params[i].offset;
+ 		info->found++;
+ 
+ 		val = of_read_number(prop, len / sizeof(u32));
+ 
+ 		if (dt_params[i].size == sizeof(u32))
+ 			*(u32 *)dest = val;
+ 		else
+ 			*(u64 *)dest = val;
+ 
+ 		if (efi_enabled(EFI_DBG))
+ 			pr_info("  %s: 0x%0*llx\n", dt_params[i].name,
+ 				dt_params[i].size * 2, val);
+ 	}
+ 	return 1;
+ }
+ 
+ int __init efi_get_fdt_params(struct efi_fdt_params *params)
+ {
+ 	struct param_info info;
+ 	int ret;
+ 
+ 	pr_info("Getting EFI parameters from FDT:\n");
+ 
+ 	info.found = 0;
+ 	info.params = params;
+ 
+ 	ret = of_scan_flat_dt(fdt_find_uefi_params, &info);
+ 	if (!info.found)
+ 		pr_info("UEFI not found.\n");
+ 	else if (!ret)
+ 		pr_err("Can't find '%s' in device tree!\n",
+ 		       dt_params[info.found].name);
+ 
+ 	return ret;
+ }
+ #endif /* CONFIG_EFI_PARAMS_FROM_FDT */
+ 
+ static __initdata char memory_type_name[][20] = {
+ 	"Reserved",
+ 	"Loader Code",
+ 	"Loader Data",
+ 	"Boot Code",
+ 	"Boot Data",
+ 	"Runtime Code",
+ 	"Runtime Data",
+ 	"Conventional Memory",
+ 	"Unusable Memory",
+ 	"ACPI Reclaim Memory",
+ 	"ACPI Memory NVS",
+ 	"Memory Mapped I/O",
+ 	"MMIO Port Space",
+ 	"PAL Code"
+ };
+ 
+ char * __init efi_md_typeattr_format(char *buf, size_t size,
+ 				     const efi_memory_desc_t *md)
+ {
+ 	char *pos;
+ 	int type_len;
+ 	u64 attr;
+ 
+ 	pos = buf;
+ 	if (md->type >= ARRAY_SIZE(memory_type_name))
+ 		type_len = snprintf(pos, size, "[type=%u", md->type);
+ 	else
+ 		type_len = snprintf(pos, size, "[%-*s",
+ 				    (int)(sizeof(memory_type_name[0]) - 1),
+ 				    memory_type_name[md->type]);
+ 	if (type_len >= size)
+ 		return buf;
+ 
+ 	pos += type_len;
+ 	size -= type_len;
+ 
+ 	attr = md->attribute;
+ 	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
+ 		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
+ 		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
+ 		     EFI_MEMORY_NV |
+ 		     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))
+ 		snprintf(pos, size, "|attr=0x%016llx]",
+ 			 (unsigned long long)attr);
+ 	else
+ 		snprintf(pos, size,
+ 			 "|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+ 			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
+ 			 attr & EFI_MEMORY_MORE_RELIABLE ? "MR" : "",
+ 			 attr & EFI_MEMORY_NV      ? "NV"  : "",
+ 			 attr & EFI_MEMORY_XP      ? "XP"  : "",
+ 			 attr & EFI_MEMORY_RP      ? "RP"  : "",
+ 			 attr & EFI_MEMORY_WP      ? "WP"  : "",
+ 			 attr & EFI_MEMORY_RO      ? "RO"  : "",
+ 			 attr & EFI_MEMORY_UCE     ? "UCE" : "",
+ 			 attr & EFI_MEMORY_WB      ? "WB"  : "",
+ 			 attr & EFI_MEMORY_WT      ? "WT"  : "",
+ 			 attr & EFI_MEMORY_WC      ? "WC"  : "",
+ 			 attr & EFI_MEMORY_UC      ? "UC"  : "");
+ 	return buf;
+ }
+ 
+ /*
+  * efi_mem_attributes - lookup memmap attributes for physical address
+  * @phys_addr: the physical address to lookup
+  *
+  * Search in the EFI memory map for the region covering
+  * @phys_addr. Returns the EFI memory attributes if the region
+  * was found in the memory map, 0 otherwise.
+  *
+  * Despite being marked __weak, most architectures should *not*
+  * override this function. It is __weak solely for the benefit
+  * of ia64 which has a funky EFI memory map that doesn't work
+  * the same way as other architectures.
+  */
+ u64 __weak efi_mem_attributes(unsigned long phys_addr)
+ {
+ 	struct efi_memory_map *map;
+ 	efi_memory_desc_t *md;
+ 	void *p;
+ 
+ 	if (!efi_enabled(EFI_MEMMAP))
+ 		return 0;
+ 
+ 	map = efi.memmap;
+ 	for (p = map->map; p < map->map_end; p += map->desc_size) {
+ 		md = p;
+ 		if ((md->phys_addr <= phys_addr) &&
+ 		    (phys_addr < (md->phys_addr +
+ 		    (md->num_pages << EFI_PAGE_SHIFT))))
+ 			return md->attribute;
++>>>>>>> c016ca08f89c (efi: Add NV memory attribute)
  	}
 +	pr_cont("\n");
 +	early_iounmap(config_tables, efi.systab->nr_tables * sz);
  	return 0;
  }
* Unmerged path drivers/firmware/efi/efi.c
diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0dc4ddccc847..468fcb4774c8 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -95,6 +95,7 @@ typedef	struct {
 #define EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	/* write-protect */
 #define EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	/* read-protect */
 #define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */
+#define EFI_MEMORY_NV		((u64)0x0000000000008000ULL)	/* non-volatile */
 #define EFI_MEMORY_MORE_RELIABLE \
 				((u64)0x0000000000010000ULL)	/* higher reliability */
 #define EFI_MEMORY_RUNTIME	((u64)0x8000000000000000ULL)	/* range requires runtime mapping */
