net: add function to retrieve original skb device using NAPI ID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] add function to retrieve original skb device using NAPI ID (Hangbin Liu) [1421164]
Rebuild_FUZZ: 95.87%
commit-author Miroslav Lichvar <mlichvar@redhat.com>
commit 90b602f80397657429373ca009f98aec4dd3c553
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/90b602f8.failed

Since commit b68581778cd0 ("net: Make skb->skb_iif always track
skb->dev") skbs don't have the original index of the interface which
received the packet. This information is now needed for a new control
message related to hardware timestamping.

Instead of adding a new field to skb, we can find the device by the NAPI
ID if it is available, i.e. CONFIG_NET_RX_BUSY_POLL is enabled and the
driver is using NAPI. Add dev_get_by_napi_id() and also skb_napi_id() to
hide the CONFIG_NET_RX_BUSY_POLL ifdef.

CC: Richard Cochran <richardcochran@gmail.com>
	Suggested-by: Willem de Bruijn <willemb@google.com>
	Acked-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 90b602f80397657429373ca009f98aec4dd3c553)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/dev.c
diff --cc include/linux/skbuff.h
index 28aefdf34562,8acce7143f6a..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -921,6 -849,24 +921,27 @@@ static inline struct rtable *skb_rtable
  	return (struct rtable *)skb_dst(skb);
  }
  
++<<<<<<< HEAD
++=======
+ /* For mangling skb->pkt_type from user space side from applications
+  * such as nft, tc, etc, we only allow a conservative subset of
+  * possible pkt_types to be set.
+ */
+ static inline bool skb_pkt_type_ok(u32 ptype)
+ {
+ 	return ptype <= PACKET_OTHERHOST;
+ }
+ 
+ static inline unsigned int skb_napi_id(const struct sk_buff *skb)
+ {
+ #ifdef CONFIG_NET_RX_BUSY_POLL
+ 	return skb->napi_id;
+ #else
+ 	return 0;
+ #endif
+ }
+ 
++>>>>>>> 90b602f80397 (net: add function to retrieve original skb device using NAPI ID)
  void kfree_skb(struct sk_buff *skb);
  void kfree_skb_list(struct sk_buff *segs);
  void skb_tx_error(struct sk_buff *skb);
diff --cc net/core/dev.c
index a40c9678b9f6,3d98fbf4cbb0..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -153,6 -160,10 +153,13 @@@ struct list_head ptype_all __read_mostl
  static struct list_head offload_base __read_mostly;
  
  static int netif_rx_internal(struct sk_buff *skb);
++<<<<<<< HEAD
++=======
+ static int call_netdevice_notifiers_info(unsigned long val,
+ 					 struct net_device *dev,
+ 					 struct netdev_notifier_info *info);
+ static struct napi_struct *napi_by_id(unsigned int napi_id);
++>>>>>>> 90b602f80397 (net: add function to retrieve original skb device using NAPI ID)
  
  /*
   * The @dev_base_head list is protected by @dev_base_lock and the rtnl
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index f2e995a93118..3f5a51dac077 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2506,6 +2506,7 @@ static inline int dev_recursion_level(void)
 struct net_device *dev_get_by_index(struct net *net, int ifindex);
 struct net_device *__dev_get_by_index(struct net *net, int ifindex);
 struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex);
+struct net_device *dev_get_by_napi_id(unsigned int napi_id);
 int netdev_get_name(struct net *net, char *name, int ifindex);
 int dev_restart(struct net_device *dev);
 #ifdef CONFIG_NETPOLL_TRAP
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/dev.c
