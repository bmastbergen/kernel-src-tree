ALSA: x86: Flatten two abstraction layers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit da8648097497505d05d8cff6892351f99c029791
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/da864809.failed

This is the final stage for a big clean-up series.  Here we flatten
the two layers into one.  Formerly, the implementation was split to
HDMI "shell" that talks with the platform device, and HDMI audio part
that communicates via caps and other event handlers.  All these would
be good if there were multiple instantiations or if there were data
protection.  But neither are true in our case.  That said, it'll be
easier to have a flat driver structure in the end.

In this patch, the former struct hdmi_lpe_audio_ctx is forged into the
existing struct snd_intelhad.  The latter has already a few members
that are basically the copy from the former.  Only a few new members
for the lowlevel I/O are added by this change.

Then, the had_get_caps() and had_set_caps() are simply replaced with
the direct calls to copy the data in the struct fields.  Also, the
had_event_handler() calls are replaced with the direct call for each
event as well.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit da8648097497505d05d8cff6892351f99c029791)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
#	sound/x86/intel_hdmi_audio.h
#	sound/x86/intel_hdmi_audio_if.c
#	sound/x86/intel_hdmi_lpe_audio.c
#	sound/x86/intel_hdmi_lpe_audio.h
diff --cc sound/x86/intel_hdmi_audio.c
index f2f54691cb43,1594f826cf31..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -168,28 -170,16 +170,36 @@@ int had_get_hwstate(struct snd_intelha
  	return 0;
  }
  
- int had_get_caps(struct snd_intelhad *intelhaddata,
- 		 enum had_caps_list query, void *caps)
+ static inline void
+ mid_hdmi_audio_read(struct snd_intelhad *ctx, u32 reg, u32 *val)
  {
++<<<<<<< HEAD
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_get_caps(query, caps);
 +
 +	return retval;
++=======
+ 	*val = ioread32(ctx->mmio_start + ctx->had_config_offset + reg);
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  }
  
- int had_set_caps(struct snd_intelhad *intelhaddata,
- 		 enum had_caps_list set_element, void *caps)
+ static inline void
+ mid_hdmi_audio_write(struct snd_intelhad *ctx, u32 reg, u32 val)
  {
++<<<<<<< HEAD
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_set_caps(set_element, caps);
 +
 +	return retval;
++=======
+ 	iowrite32(val, ctx->mmio_start + ctx->had_config_offset + reg);
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  }
  
  int had_read_register(struct snd_intelhad *intelhaddata, u32 offset, u32 *data)
@@@ -197,10 -187,20 +207,25 @@@
  	int retval;
  
  	retval = had_get_hwstate(intelhaddata);
++<<<<<<< HEAD
 +	if (!retval)
 +		retval = mid_hdmi_audio_read(offset, data);
++=======
+ 	if (retval)
+ 		return retval;
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  
- 	return retval;
+ 	mid_hdmi_audio_read(intelhaddata, offset, data);
+ 	return 0;
+ }
+ 
+ static void fixup_dp_config(struct snd_intelhad *intelhaddata,
+ 			    u32 offset, u32 *data)
+ {
+ 	if (intelhaddata->dp_output) {
+ 		if (offset == AUD_CONFIG && (*data & AUD_CONFIG_VALID_BIT))
+ 			*data |= AUD_CONFIG_DP_MODE | AUD_CONFIG_BLOCK_BIT;
+ 	}
  }
  
  int had_write_register(struct snd_intelhad *intelhaddata, u32 offset, u32 data)
@@@ -208,27 -208,37 +233,50 @@@
  	int retval;
  
  	retval = had_get_hwstate(intelhaddata);
++<<<<<<< HEAD
 +	if (!retval)
 +		retval = mid_hdmi_audio_write(offset, data);
++=======
+ 	if (retval)
+ 		return retval;
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  
- 	return retval;
+ 	fixup_dp_config(intelhaddata, offset, &data);
+ 	mid_hdmi_audio_write(intelhaddata, offset, data);
+ 	return 0;
  }
  
  int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
  		    u32 data, u32 mask)
  {
++<<<<<<< HEAD
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_rmw(offset, data, mask);
++=======
+ 	u32 val_tmp;
+ 	int retval;
  
- 	return retval;
+ 	retval = had_get_hwstate(intelhaddata);
+ 	if (retval)
+ 		return retval;
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
+ 
+ 	mid_hdmi_audio_read(intelhaddata, offset, &val_tmp);
+ 	val_tmp &= ~mask;
+ 	val_tmp |= (data & mask);
+ 
+ 	fixup_dp_config(intelhaddata, offset, &val_tmp);
+ 	mid_hdmi_audio_write(intelhaddata, offset, val_tmp);
+ 	return 0;
  }
- /**
-  * function to read-modify
-  * AUD_CONFIG register on VLV2.The had_read_modify() function should not
-  * directly be used on VLV2 for updating AUD_CONFIG register.
+ 
+ /*
+  * function to read-modify AUD_CONFIG register on VLV2.
+  * The had_read_modify() function should not directly be used on VLV2 for
+  * updating AUD_CONFIG register.
   * This is because:
   * Bit6 of AUD_CONFIG register is writeonly due to a silicon bug on VLV2
   * HDMI IP. As a result a read-modify of AUD_CONFIG regiter will always
@@@ -1575,62 -1548,200 +1611,243 @@@ static struct snd_kcontrol_new had_cont
  	.put =          had_iec958_put
  };
  
- /*
-  * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
-  *
-  * @devptr: platform device
-  * @had_ret: pointer to store the created snd_intelhad object
-  *
-  * This function is called when the platform device is probed. This function
-  * creates and registers the sound card with ALSA
-  */
- int hdmi_audio_probe(struct platform_device *devptr,
- 		     struct snd_intelhad **had_ret)
+ static void _had_wq(struct work_struct *work)
  {
++<<<<<<< HEAD
 +	int retval;
 +	struct snd_pcm *pcm;
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
++=======
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
+ 
+ 	had_process_hot_plug(ctx);
+ }
+ 
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad *ctx = dev_id;
+ 	u32 audio_stat, audio_reg;
+ 
+ 	audio_reg = AUD_HDMI_STATUS_v2;
+ 	mid_hdmi_audio_read(ctx, audio_reg, &audio_stat);
+ 
+ 	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_UNDERRUN);
+ 		had_process_buffer_underrun(ctx);
+ 	}
+ 
+ 	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_BUFFER_DONE);
+ 		had_process_buffer_done(ctx);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = pdev->dev.platform_data;
+ 
+ 	if (pdata->hdmi_connected != true) {
+ 
+ 		dev_dbg(&pdev->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 
+ 		if (ctx->state == hdmi_connector_status_connected) {
+ 
+ 			ctx->state = hdmi_connector_status_disconnected;
+ 
+ 			had_process_hot_unplug(ctx);
+ 		} else
+ 			dev_dbg(&pdev->dev, "%s: Already Unplugged!\n",
+ 				__func__);
+ 
+ 	} else {
+ 		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
+ 
+ 		switch (eld->pipe_id) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(&pdev->dev, "Invalid pipe %d\n",
+ 				eld->pipe_id);
+ 			break;
+ 		}
+ 
+ 		memcpy(&ctx->eld, eld->eld_data, sizeof(ctx->eld));
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		ctx->state = hdmi_connector_status_connected;
+ 
+ 		dev_dbg(&pdev->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, eld->port_id,	pdata->tmds_clock_speed);
+ 
+ 		if (pdata->tmds_clock_speed) {
+ 			ctx->tmds_clock_speed = pdata->tmds_clock_speed;
+ 			ctx->dp_output = pdata->dp_output;
+ 			ctx->link_rate = pdata->link_rate;
+ 
+ 			/* Process mode change if stream is active */
+ 			if (ctx->stream_data.stream_type == HAD_RUNNING_STREAM)
+ 				hdmi_audio_mode_change(ctx);
+ 		}
+ 	}
+ }
+ 
+ /* release resources */
+ static void hdmi_lpe_audio_free(struct snd_card *card)
+ {
+ 	struct snd_intelhad *ctx = card->private_data;
+ 
+ 	if (ctx->mmio_start)
+ 		iounmap(ctx->mmio_start);
+ 	if (ctx->irq >= 0)
+ 		free_irq(ctx->irq, ctx);
+ }
  
- 	pr_debug("Enter %s\n", __func__);
+ /*
+  * hdmi_lpe_audio_probe - start bridge with i915
+  *
+  * This function is called when the i915 driver creates the
+  * hdmi-lpe-audio platform device. Card creation is deferred until a
+  * hot plug event is received
+  */
+ static int hdmi_lpe_audio_probe(struct platform_device *pdev)
+ {
+ 	struct snd_card *card;
+ 	struct snd_intelhad *ctx;
+ 	struct snd_pcm *pcm;
+ 	struct intel_hdmi_lpe_audio_pdata *pdata;
+ 	int irq;
+ 	struct resource *res_mmio;
+ 	int ret;
+ 	unsigned long flags;
+ 
+ 	dev_dbg(&pdev->dev, "Enter %s\n", __func__);
+ 	dev_dbg(&pdev->dev, "dma_mask: %p\n", pdev->dev.dma_mask);
+ 
+ 	pdata = pdev->dev.platform_data;
+ 	if (!pdata) {
+ 		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
+ 		return -EINVAL;
+ 	}
  
+ 	/* get resources */
+ 	irq = platform_get_irq(pdev, 0);
+ 	if (irq < 0) {
+ 		dev_err(&pdev->dev, "Could not get irq resource\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!res_mmio) {
+ 		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
+ 		return -ENXIO;
+ 	}
+ 
++<<<<<<< HEAD
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
 +
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
 +
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
 +	}
 +
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
 +
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
++=======
+ 	/* create a card instance with ALSA framework */
+ 	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
+ 			   THIS_MODULE, sizeof(*ctx), &card);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ctx = card->private_data;
+ 	spin_lock_init(&ctx->had_spinlock);
+ 	ctx->drv_status = HAD_DRV_DISCONNECTED;
+ 	ctx->dev = &pdev->dev;
+ 	ctx->card = card;
+ 	ctx->card_id = hdmi_card_id;
+ 	ctx->card_index = card->number;
+ 	ctx->flag_underrun = 0;
+ 	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
+ 	strcpy(card->driver, INTEL_HAD);
+ 	strcpy(card->shortname, INTEL_HAD);
+ 
+ 	ctx->irq = -1;
+ 	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
+ 	INIT_WORK(&ctx->hdmi_audio_wq, _had_wq);
+ 	ctx->state = hdmi_connector_status_disconnected;
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
+ 
+ 	card->private_free = hdmi_lpe_audio_free;
+ 
+ 	/* assume pipe A as default */
+ 	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 
+ 	platform_set_drvdata(pdev, ctx);
+ 
+ 	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
+ 		__func__, (unsigned int)res_mmio->start,
+ 		(unsigned int)res_mmio->end);
+ 
+ 	ctx->mmio_start = ioremap_nocache(res_mmio->start,
+ 					  (size_t)(resource_size(res_mmio)));
+ 	if (!ctx->mmio_start) {
+ 		dev_err(&pdev->dev, "Could not get ioremap\n");
+ 		ret = -EACCES;
+ 		goto err;
+ 	}
  
- 	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
- 						MAX_CAP_STREAMS, &pcm);
- 	if (retval)
+ 	/* setup interrupt handler */
+ 	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
+ 			  pdev->name, ctx);
+ 	if (ret < 0) {
+ 		dev_err(&pdev->dev, "request_irq failed\n");
+ 		goto err;
+ 	}
+ 
+ 	ctx->irq = irq;
+ 
+ 	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
+ 			  MAX_CAP_STREAMS, &pcm);
+ 	if (ret)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
@@@ -1645,93 -1756,66 +1862,121 @@@
  	 * memory allocated is based on size, not max value
  	 * thus using same argument for max & size
  	 */
- 	retval = snd_pcm_lib_preallocate_pages_for_all(pcm,
+ 	snd_pcm_lib_preallocate_pages_for_all(pcm,
  			SNDRV_DMA_TYPE_DEV, NULL,
  			HAD_MAX_BUFFER, HAD_MAX_BUFFER);
++<<<<<<< HEAD
 +
 +	if (card->dev == NULL)
 +		pr_debug("card->dev is NULL!!!!! Should not be this case\n");
 +	else if (card->dev->dma_mask == NULL)
 +		pr_debug("hdmi_audio_probe dma_mask is NULL!!!!!\n");
 +	else
 +		pr_debug("hdmi_audio_probe dma_mask is : %p\n",
 +				card->dev->dma_mask);
 +
 +	if (retval)
 +		goto err;
 +
 +	/* internal function call to register device with ALSA */
 +	retval = snd_intelhad_create(intelhaddata, card);
 +	if (retval)
 +		goto err;
 +
 +	card->private_data = &intelhaddata;
 +	retval = snd_card_register(card);
 +	if (retval)
 +		goto err;
++=======
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  
  	/* IEC958 controls */
- 	retval = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958_mask,
- 						intelhaddata));
- 	if (retval < 0)
+ 	ret = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958_mask, ctx));
+ 	if (ret < 0)
  		goto err;
- 	retval = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958,
- 						intelhaddata));
- 	if (retval < 0)
+ 	ret = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958, ctx));
+ 	if (ret < 0)
  		goto err;
  
  	init_channel_allocations();
  
  	/* Register channel map controls */
- 	retval = had_register_chmap_ctls(intelhaddata, pcm);
- 	if (retval < 0)
+ 	ret = had_register_chmap_ctls(ctx, pcm);
+ 	if (ret < 0)
  		goto err;
  
++<<<<<<< HEAD
 +	intelhaddata->dev = &devptr->dev;
 +	pm_runtime_set_active(intelhaddata->dev);
 +	pm_runtime_enable(intelhaddata->dev);
++=======
+ 	ret = snd_card_register(card);
+ 	if (ret)
+ 		goto err;
  
- 	*had_ret = intelhaddata;
+ 	spin_lock_irqsave(&pdata->lpe_audio_slock, flags);
+ 	pdata->notify_audio_lpe = notify_audio_lpe;
+ 	if (pdata->notify_pending) {
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
+ 
+ 		dev_dbg(&pdev->dev, "%s: handle pending notification\n", __func__);
+ 		notify_audio_lpe(pdev);
+ 		pdata->notify_pending = false;
+ 	}
+ 	spin_unlock_irqrestore(&pdata->lpe_audio_slock, flags);
+ 
+ 	pm_runtime_set_active(&pdev->dev);
+ 	pm_runtime_enable(&pdev->dev);
+ 
+ 	schedule_work(&ctx->hdmi_audio_wq);
  
  	return 0;
 -
  err:
  	snd_card_free(card);
++<<<<<<< HEAD
 +free_hadstream:
 +	kfree(had_stream);
 +	pm_runtime_disable(intelhaddata->dev);
 +	intelhaddata->dev = NULL;
 +free_haddata:
 +	kfree(intelhaddata);
 +	intelhaddata = NULL;
 +	pr_err("Error returned from %s api %#x\n", __func__, retval);
 +	return retval;
++=======
+ 	return ret;
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  }
  
  /*
-  * hdmi_audio_remove - removes the alsa card
+  * hdmi_lpe_audio_remove - stop bridge with i915
   *
-  *@haddata: pointer to HAD private data
-  *
-  * This function is called when the hdmi cable is un-plugged. This function
-  * free the sound card.
+  * This function is called when the platform device is destroyed. The sound
+  * card should have been removed on hot plug event.
   */
- int hdmi_audio_remove(struct snd_intelhad *intelhaddata)
+ static int hdmi_lpe_audio_remove(struct platform_device *pdev)
  {
- 	int caps;
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
  
- 	pr_debug("Enter %s\n", __func__);
+ 	dev_dbg(&pdev->dev, "Enter %s\n", __func__);
  
++<<<<<<< HEAD
 +	if (!intelhaddata)
 +		return 0;
 +
 +	if (intelhaddata->drv_status != HAD_DRV_DISCONNECTED) {
 +		caps = HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE;
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO_INT, &caps);
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO, NULL);
 +	}
 +	snd_card_free(intelhaddata->card);
 +	kfree(intelhaddata->private_data);
 +	kfree(intelhaddata);
++=======
+ 	if (ctx->drv_status != HAD_DRV_DISCONNECTED)
+ 		snd_intelhad_enable_audio_int(ctx, false);
+ 	snd_card_free(ctx->card);
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  	return 0;
  }
  
diff --cc sound/x86/intel_hdmi_audio.h
index 32a2fb766e47,6efa846f98c9..000000000000
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@@ -142,16 -142,27 +142,36 @@@ struct snd_intelhad 
  	unsigned int	*audio_reg_base;
  	unsigned int	audio_cfg_offset;
  	int underrun_count;
+ 	enum hdmi_connector_status state;
+ 	int tmds_clock_speed;
+ 	int link_rate;
+ 
+ 	/* internal stuff */
+ 	int irq;
+ 	void __iomem *mmio_start;
+ 	unsigned int had_config_offset;
+ 	int hdmi_audio_interrupt_mask;
+ 	struct work_struct hdmi_audio_wq;
  };
  
++<<<<<<< HEAD
 +int had_event_handler(enum had_event_type event_type, void *data);
 +
 +int hdmi_audio_query(void *drv_data, struct hdmi_audio_event event);
 +int hdmi_audio_suspend(void *drv_data);
 +int hdmi_audio_resume(void *drv_data);
 +int hdmi_audio_mode_change(struct snd_pcm_substream *substream);
++=======
+ int hdmi_lpe_audio_suspend(struct platform_device *pdev, pm_message_t state);
+ int hdmi_lpe_audio_resume(struct platform_device *pdev);
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  extern struct snd_pcm_ops snd_intelhad_playback_ops;
  
+ int had_process_buffer_done(struct snd_intelhad *intelhaddata);
+ int had_process_buffer_underrun(struct snd_intelhad *intelhaddata);
+ int had_process_hot_plug(struct snd_intelhad *intelhaddata);
+ int had_process_hot_unplug(struct snd_intelhad *intelhaddata);
+ 
  int snd_intelhad_init_audio_ctrl(struct snd_pcm_substream *substream,
  					struct snd_intelhad *intelhaddata,
  					int flag_silence);
diff --cc sound/x86/intel_hdmi_audio_if.c
index 8e3a0943332b,327650dd1723..000000000000
--- a/sound/x86/intel_hdmi_audio_if.c
+++ b/sound/x86/intel_hdmi_audio_if.c
@@@ -33,75 -33,20 +33,84 @@@
  #include "intel_hdmi_audio.h"
  #include "intel_hdmi_lpe_audio.h"
  
++<<<<<<< HEAD
 +/**
 + * hdmi_audio_query - hdmi audio query function
 + *
 + *@haddata: pointer to HAD private data
 + *@event: audio event for which this method is invoked
 + *
 + * This function is called by client driver to query the
 + * hdmi audio.
 + */
 +int hdmi_audio_query(void *haddata, struct hdmi_audio_event event)
 +{
 +	struct snd_pcm_substream *substream = NULL;
 +	struct had_pvt_data *had_stream;
 +	unsigned long flag_irqs;
 +	struct snd_intelhad *intelhaddata = (struct snd_intelhad *)haddata;
 +
 +	if (intelhaddata->stream_info.had_substream)
 +		substream = intelhaddata->stream_info.had_substream;
 +	had_stream = intelhaddata->private_data;
 +	switch (event.type) {
 +	case HAD_EVENT_QUERY_IS_AUDIO_BUSY:
 +		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 +
 +		if ((had_stream->stream_type == HAD_RUNNING_STREAM) ||
 +			substream) {
 +			spin_unlock_irqrestore(&intelhaddata->had_spinlock,
 +						flag_irqs);
 +			pr_debug("Audio stream active\n");
 +			return -EBUSY;
 +		}
 +		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 +	break;
 +
 +	case HAD_EVENT_QUERY_IS_AUDIO_SUSPENDED:
 +		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 +		if (intelhaddata->drv_status == HAD_DRV_SUSPENDED) {
 +			spin_unlock_irqrestore(&intelhaddata->had_spinlock,
 +						flag_irqs);
 +			pr_debug("Audio is suspended\n");
 +			return 1;
 +		}
 +		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 +	break;
 +
 +	default:
 +		pr_debug("error un-handled event !!\n");
 +		return -EINVAL;
 +	break;
 +
 +	}
 +
 +	return 0;
 +}
 +
 +/**
 + * hdmi_audio_suspend - power management suspend function
++=======
+ /*
+  * hdmi_lpe_audio_suspend - power management suspend function
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
   *
-  *@haddata: pointer to HAD private data
+  * @pdev: platform device
   *
   * This function is called by client driver to suspend the
   * hdmi audio.
   */
- int hdmi_audio_suspend(void *haddata)
+ int hdmi_lpe_audio_suspend(struct platform_device *pdev, pm_message_t state)
  {
++<<<<<<< HEAD
 +	int caps, retval = 0;
 +	struct had_pvt_data *had_stream;
++=======
+ 	struct had_stream_data *had_stream;
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  	unsigned long flag_irqs;
  	struct snd_pcm_substream *substream;
- 	struct snd_intelhad *intelhaddata = (struct snd_intelhad *)haddata;
+ 	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
  
  	pr_debug("Enter:%s\n", __func__);
  
@@@ -411,9 -343,8 +407,8 @@@ int had_process_hot_plug(struct snd_int
  
  int had_process_hot_unplug(struct snd_intelhad *intelhaddata)
  {
- 	int caps, retval = 0;
  	enum intel_had_aud_buf_type buf_id;
 -	struct had_stream_data *had_stream;
 +	struct had_pvt_data *had_stream;
  	unsigned long flag_irqs;
  
  	pr_debug("Enter:%s\n", __func__);
@@@ -459,74 -385,6 +449,77 @@@
  	intelhaddata->audio_reg_base = NULL;
  	pr_debug("%s: unlocked -> returned\n", __func__);
  
- 	return retval;
+ 	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * had_event_handler - Call back function to handle events
 + *
 + * @event_type: Event type to handle
 + * @data: data related to the event_type
 + *
 + * This function is invoked to handle HDMI events from client driver.
 + */
 +int had_event_handler(enum had_event_type event_type, void *data)
 +{
 +	int retval = 0;
 +	struct snd_intelhad *intelhaddata = data;
 +	enum intel_had_aud_buf_type buf_id;
 +	struct snd_pcm_substream *substream;
 +	struct had_pvt_data *had_stream;
 +	unsigned long flag_irqs;
 +
 +	buf_id = intelhaddata->curr_buf;
 +	had_stream = intelhaddata->private_data;
 +
 +	/* Switching to a function can drop atomicity even in INTR context.
 +	 * Thus, a big lock is acquired to maintain atomicity.
 +	 * This can be optimized later.
 +	 * Currently, only buffer_done/_underrun executes in INTR context.
 +	 * Also, locking is implemented separately to avoid real contention
 +	 * of data(struct intelhaddata) between IRQ/SOFT_IRQ/PROCESS context.
 +	 */
 +	substream = intelhaddata->stream_info.had_substream;
 +	switch (event_type) {
 +	case HAD_EVENT_AUDIO_BUFFER_DONE:
 +		retval = had_process_buffer_done(intelhaddata);
 +	break;
 +
 +	case HAD_EVENT_AUDIO_BUFFER_UNDERRUN:
 +		retval = had_process_buffer_underrun(intelhaddata);
 +	break;
 +
 +	case HAD_EVENT_HOT_PLUG:
 +		retval = had_process_hot_plug(intelhaddata);
 +	break;
 +
 +	case HAD_EVENT_HOT_UNPLUG:
 +		retval = had_process_hot_unplug(intelhaddata);
 +	break;
 +
 +	case HAD_EVENT_MODE_CHANGING:
 +		pr_debug(" called _event_handler with _MODE_CHANGE event\n");
 +		/* Process only if stream is active & cable Plugged-in */
 +		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 +		if (intelhaddata->drv_status >= HAD_DRV_DISCONNECTED) {
 +			spin_unlock_irqrestore(&intelhaddata->had_spinlock,
 +					flag_irqs);
 +			break;
 +		}
 +		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 +		if ((had_stream->stream_type == HAD_RUNNING_STREAM)
 +				&& substream)
 +			retval = hdmi_audio_mode_change(substream);
 +	break;
 +
 +	default:
 +		pr_debug("error un-handled event !!\n");
 +		retval = -EINVAL;
 +	break;
 +
 +	}
 +	return retval;
 +}
++=======
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
diff --cc sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57,8f320b4aa3b7..000000000000
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@@ -634,23 -635,4 +635,26 @@@ enum had_event_type 
  	HAD_EVENT_QUERY_IS_AUDIO_SUSPENDED,
  };
  
++<<<<<<< HEAD
 +/*
 + * HDMI Display Controller Audio Interface
 + *
 + */
 +struct hdmi_audio_event {
 +	int type;
 +};
 +
 +void mid_hdmi_audio_signal_event(enum had_event_type event);
 +
 +int mid_hdmi_audio_read(u32 reg, u32 *val);
 +int mid_hdmi_audio_write(u32 reg, u32 val);
 +int mid_hdmi_audio_rmw(u32 reg, u32 val, u32 mask);
 +
 +int mid_hdmi_audio_get_caps(enum had_caps_list get_element,
 +			    void *capabilities);
 +int mid_hdmi_audio_set_caps(enum had_caps_list set_element,
 +			    void *capabilties);
 +
++=======
++>>>>>>> da8648097497 (ALSA: x86: Flatten two abstraction layers)
  #endif
* Unmerged path sound/x86/intel_hdmi_lpe_audio.c
diff --git a/sound/x86/Makefile b/sound/x86/Makefile
index 85ea22a2cf28..3c0bf63333e6 100644
--- a/sound/x86/Makefile
+++ b/sound/x86/Makefile
@@ -1,6 +1,5 @@
 snd-hdmi-lpe-audio-objs += \
 	intel_hdmi_audio.o \
-	intel_hdmi_audio_if.o \
-	intel_hdmi_lpe_audio.o
+	intel_hdmi_audio_if.o
 
 obj-$(CONFIG_HDMI_LPE_AUDIO) += snd-hdmi-lpe-audio.o
* Unmerged path sound/x86/intel_hdmi_audio.c
* Unmerged path sound/x86/intel_hdmi_audio.h
* Unmerged path sound/x86/intel_hdmi_audio_if.c
* Unmerged path sound/x86/intel_hdmi_lpe_audio.c
* Unmerged path sound/x86/intel_hdmi_lpe_audio.h
