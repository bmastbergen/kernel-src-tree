netvsc: make sure and unregister datapath

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 7b83f52047e8a3d551a9495b0267df5d0754c5bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7b83f520.failed

Go back to switching datapath directly in the notifier callback.
Otherwise datapath might not get switched on unregister.

No need for calling the NOTIFY_PEERS notifier since that is only for
a gratitious ARP/ND packet; but that is not required with Hyper-V
because both VF and synthetic NIC have the same MAC address.

	Reported-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Fixes: 0c195567a8f6 ("netvsc: transparent VF management")
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7b83f52047e8a3d551a9495b0267df5d0754c5bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,d1ea99a12cf2..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -703,20 -720,31 +703,23 @@@ struct net_device_context 
  	u32 speed;
  	struct netvsc_ethtool_stats eth_stats;
  
 +	/* the device is going away */
 +	bool start_remove;
 +
  	/* State to manage the associated VF interface. */
  	struct net_device __rcu *vf_netdev;
++<<<<<<< HEAD
++=======
+ 	struct netvsc_vf_pcpu_stats __percpu *vf_stats;
+ 	struct work_struct vf_takeover;
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  
  	/* 1: allocated, serial number is valid. 0: not allocated */
  	u32 vf_alloc;
  	/* Serial number of the VF to team with */
  	u32 vf_serial;
- 
- 	bool datapath;	/* 0 - synthetic, 1 - VF nic */
  };
  
 -/* Per channel data */
 -struct netvsc_channel {
 -	struct vmbus_channel *channel;
 -	struct netvsc_device *net_device;
 -	const struct vmpacket_descriptor *desc;
 -	struct napi_struct napi;
 -	struct multi_send_data msd;
 -	struct multi_recv_comp mrc;
 -	atomic_t queue_sends;
 -
 -	struct netvsc_stats tx_stats;
 -	struct netvsc_stats rx_stats;
 -};
 -
  /* Per netvsc device */
  struct netvsc_device {
  	u32 nvsp_version;
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,eb0023f55fe1..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -1394,59 -1651,47 +1394,94 @@@ static int netvsc_register_vf(struct ne
  
  static int netvsc_vf_up(struct net_device *vf_netdev)
  {
++<<<<<<< HEAD
++=======
+ 	struct net_device_context *net_device_ctx;
+ 	struct netvsc_device *netvsc_dev;
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  	struct net_device *ndev;
 +	struct netvsc_device *netvsc_dev;
 +	struct net_device_context *net_device_ctx;
  
  	ndev = get_netvsc_byref(vf_netdev);
  	if (!ndev)
  		return NOTIFY_DONE;
  
  	net_device_ctx = netdev_priv(ndev);
++<<<<<<< HEAD
 +	netvsc_dev = net_device_ctx->nvdev;
 +
 +	netdev_info(ndev, "VF up: %s\n", vf_netdev->name);
 +
 +	/*
 +	 * Open the device before switching data path.
 +	 */
 +	rndis_filter_open(netvsc_dev);
 +
 +	/*
 +	 * notify the host to switch the data path.
 +	 */
 +	netvsc_switch_datapath(ndev, true);
 +	netdev_info(ndev, "Data path switched to VF: %s\n", vf_netdev->name);
 +
 +	netif_carrier_off(ndev);
 +
 +	/* Now notify peers through VF device. */
 +	call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, vf_netdev);
 +
++=======
+ 	netvsc_dev = rtnl_dereference(net_device_ctx->nvdev);
+ 	if (!netvsc_dev)
+ 		return NOTIFY_DONE;
+ 
+ 	/* Bump refcount when datapath is acvive - Why? */
+ 	rndis_filter_open(netvsc_dev);
+ 
+ 	/* notify the host to switch the data path. */
+ 	netvsc_switch_datapath(ndev, true);
+ 	netdev_info(ndev, "Data path switched to VF: %s\n", vf_netdev->name);
+ 
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  	return NOTIFY_OK;
  }
  
  static int netvsc_vf_down(struct net_device *vf_netdev)
  {
++<<<<<<< HEAD
 +	struct net_device *ndev;
 +	struct netvsc_device *netvsc_dev;
 +	struct net_device_context *net_device_ctx;
++=======
+ 	struct net_device_context *net_device_ctx;
+ 	struct netvsc_device *netvsc_dev;
+ 	struct net_device *ndev;
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  
  	ndev = get_netvsc_byref(vf_netdev);
  	if (!ndev)
  		return NOTIFY_DONE;
  
  	net_device_ctx = netdev_priv(ndev);
++<<<<<<< HEAD
 +	netvsc_dev = net_device_ctx->nvdev;
 +
 +	netdev_info(ndev, "VF down: %s\n", vf_netdev->name);
 +	netvsc_switch_datapath(ndev, false);
 +	netdev_info(ndev, "Data path switched from VF: %s\n", vf_netdev->name);
 +	rndis_filter_close(netvsc_dev);
 +	netif_carrier_on(ndev);
 +
 +	/* Now notify peers through netvsc device. */
 +	call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, ndev);
++=======
+ 	netvsc_dev = rtnl_dereference(net_device_ctx->nvdev);
+ 	if (!netvsc_dev)
+ 		return NOTIFY_DONE;
+ 
+ 	netvsc_switch_datapath(ndev, false);
+ 	netdev_info(ndev, "Data path switched from VF: %s\n", vf_netdev->name);
+ 	rndis_filter_close(netvsc_dev);
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  
  	return NOTIFY_OK;
  }
@@@ -1461,6 -1706,7 +1496,10 @@@ static int netvsc_unregister_vf(struct 
  		return NOTIFY_DONE;
  
  	net_device_ctx = netdev_priv(ndev);
++<<<<<<< HEAD
++=======
+ 	cancel_work_sync(&net_device_ctx->vf_takeover);
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  
  	netdev_info(ndev, "VF unregistering: %s\n", vf_netdev->name);
  
@@@ -1516,13 -1748,15 +1555,22 @@@ static int netvsc_probe(struct hv_devic
  
  	spin_lock_init(&net_device_ctx->lock);
  	INIT_LIST_HEAD(&net_device_ctx->reconfig_events);
++<<<<<<< HEAD
++=======
+ 	INIT_WORK(&net_device_ctx->vf_takeover, netvsc_vf_setup);
+ 
+ 	net_device_ctx->vf_stats
+ 		= netdev_alloc_pcpu_stats(struct netvsc_vf_pcpu_stats);
+ 	if (!net_device_ctx->vf_stats)
+ 		goto no_stats;
++>>>>>>> 7b83f52047e8 (netvsc: make sure and unregister datapath)
  
  	net->netdev_ops = &device_ops;
 -	net->ethtool_ops = &ethtool_ops;
 +
 +	net->hw_features = NETVSC_HW_FEATURES;
 +	net->features = NETVSC_HW_FEATURES | NETIF_F_HW_VLAN_CTAG_TX;
 +
 +	SET_ETHTOOL_OPS(net, &ethtool_ops);
  	SET_NETDEV_DEV(net, &dev->device);
  
  	/* We always need headroom for rndis header */
* Unmerged path drivers/net/hyperv/hyperv_net.h
diff --git a/drivers/net/hyperv/netvsc.c b/drivers/net/hyperv/netvsc.c
index 52667f48ba1c..4afc67aa4759 100644
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@ -57,8 +57,6 @@ void netvsc_switch_datapath(struct net_device *ndev, bool vf)
 			       sizeof(struct nvsp_message),
 			       (unsigned long)init_pkt,
 			       VM_PKT_DATA_INBAND, 0);
-
-	net_device_ctx->datapath = vf;
 }
 
 static struct netvsc_device *alloc_net_device(void)
* Unmerged path drivers/net/hyperv/netvsc_drv.c
