ibmvnic: Move login and queue negotiation into ibmvnic_open

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author John Allen <jallen@linux.vnet.ibm.com>
commit bd0b6723139416fd22acd5849b93edbd32d561f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bd0b6723.failed

VNIC server expects LINK_STATE_UP to be sent within 30s of the login. If we
exceed the timeout, VNIC server will attempt to fail over. Since time
between probe and open of the device is indeterminate, move login and queue
negotiation into ibmvnic open so we can guarantee that login and sending
LINK_STATE_UP occur within the 30s window.

	Signed-off-by: John Allen <jallen@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd0b6723139416fd22acd5849b93edbd32d561f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 6a325c61534d,61d9d4045b4c..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -3707,27 -3740,7 +3747,31 @@@ static void handle_crq_init_rsp(struct 
  		goto task_failed;
  	}
  
++<<<<<<< HEAD
 +	do {
 +		if (adapter->renegotiate) {
 +			adapter->renegotiate = false;
 +			release_sub_crqs_no_irqs(adapter);
 +
 +			reinit_completion(&adapter->init_done);
 +			send_cap_queries(adapter);
 +			if (!wait_for_completion_timeout(&adapter->init_done,
 +							 timeout)) {
 +				dev_err(dev, "Passive init timeout\n");
 +				goto task_failed;
 +			}
 +		}
 +	} while (adapter->renegotiate);
 +	rc = init_sub_crq_irqs(adapter);
 +
 +	if (rc)
 +		goto task_failed;
 +
 +	netdev->real_num_tx_queues = adapter->req_tx_queues;
 +	netdev->mtu = adapter->req_mtu;
++=======
+ 	netdev->mtu = adapter->req_mtu - ETH_HLEN;
++>>>>>>> bd0b67231394 (ibmvnic: Move login and queue negotiation into ibmvnic_open)
  
  	if (adapter->failover) {
  		adapter->failover = false;
@@@ -3847,27 -3860,7 +3891,31 @@@ static int ibmvnic_probe(struct vio_de
  	if (!wait_for_completion_timeout(&adapter->init_done, timeout))
  		return 0;
  
++<<<<<<< HEAD
 +	do {
 +		if (adapter->renegotiate) {
 +			adapter->renegotiate = false;
 +			release_sub_crqs_no_irqs(adapter);
 +
 +			reinit_completion(&adapter->init_done);
 +			send_cap_queries(adapter);
 +			if (!wait_for_completion_timeout(&adapter->init_done,
 +							 timeout))
 +				return 0;
 +		}
 +	} while (adapter->renegotiate);
 +
 +	rc = init_sub_crq_irqs(adapter);
 +	if (rc) {
 +		dev_err(&dev->dev, "failed to initialize sub crq irqs\n");
 +		goto free_debugfs;
 +	}
 +
 +	netdev->real_num_tx_queues = adapter->req_tx_queues;
 +	netdev->mtu = adapter->req_mtu;
++=======
+ 	netdev->mtu = adapter->req_mtu - ETH_HLEN;
++>>>>>>> bd0b67231394 (ibmvnic: Move login and queue negotiation into ibmvnic_open)
  
  	rc = register_netdev(netdev);
  	if (rc) {
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
