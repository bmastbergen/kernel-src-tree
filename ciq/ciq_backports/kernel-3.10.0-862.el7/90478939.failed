locks: require that flock->l_pid be set to 0 for file-private locks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit 90478939dce096ed5b239cad16237dca0a59d66f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/90478939.failed

Neil Brown suggested potentially overloading the l_pid value as a "lock
context" field for file-private locks. While I don't think we will
probably want to do that here, it's probably a good idea to ensure that
in the future we could extend this API without breaking existing
callers.

Typically the l_pid value is ignored for incoming struct flock
arguments, serving mainly as a place to return the pid of the owner if
there is a conflicting lock. For file-private locks, require that it
currently be set to 0 and return EINVAL if it isn't. If we eventually
want to make a non-zero l_pid mean something, then this will help ensure
that we don't break legacy programs that are using file-private locks.

	Cc: Neil Brown <neilb@suse.de>
	Signed-off-by: Jeff Layton <jlayton@redhat.com>
(cherry picked from commit 90478939dce096ed5b239cad16237dca0a59d66f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 20dcff562a1d,09d6c8c33c81..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -2009,6 -1930,16 +2009,19 @@@ int fcntl_getlk(struct file *filp, unsi
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_GETLKP) {
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK;
+ 		file_lock.fl_flags |= FL_FILE_PVT;
+ 		file_lock.fl_owner = (fl_owner_t)filp;
+ 	}
+ 
++>>>>>>> 90478939dce0 (locks: require that flock->l_pid be set to 0 for file-private locks)
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2130,10 -2059,34 +2143,38 @@@ again
  	error = flock_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW) {
++=======
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_FILE_PVT flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_SETLKP:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_SETLKPW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW:
++>>>>>>> 90478939dce0 (locks: require that flock->l_pid be set to 0 for file-private locks)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2179,6 -2132,16 +2220,19 @@@ int fcntl_getlk64(struct file *filp, un
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_GETLKP) {
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK64;
+ 		file_lock.fl_flags |= FL_FILE_PVT;
+ 		file_lock.fl_owner = (fl_owner_t)filp;
+ 	}
+ 
++>>>>>>> 90478939dce0 (locks: require that flock->l_pid be set to 0 for file-private locks)
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2232,10 -2194,34 +2286,38 @@@ again
  	error = flock64_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW64) {
++=======
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_FILE_PVT flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_SETLKP:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK64;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_SETLKPW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW64;
+ 		file_lock->fl_flags |= FL_FILE_PVT;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW64:
++>>>>>>> 90478939dce0 (locks: require that flock->l_pid be set to 0 for file-private locks)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
* Unmerged path fs/locks.c
