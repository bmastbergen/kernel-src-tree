[readdir] switch dcache_readdir() users to ->iterate()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] switch dcache_readdir() users to ->iterate() ("Eric W. Biederman") [1487751]
Rebuild_FUZZ: 89.80%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 5f99f4e79abc64ed9d93a4b0158b21c64ff7f478
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5f99f4e7.failed

new helpers - dir_emit_dot(file, ctx, dentry), dir_emit_dotdot(file, ctx),
dir_emit_dots(file, ctx).

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 5f99f4e79abc64ed9d93a4b0158b21c64ff7f478)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
diff --cc include/linux/fs.h
index 4086333a0708,40293a6ce804..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1741,6 -1506,11 +1741,14 @@@ int fiemap_check_flags(struct fiemap_ex
   * to have different dirent layouts depending on the binary type.
   */
  typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
++<<<<<<< HEAD
++=======
+ struct dir_context {
+ 	filldir_t actor;
+ 	loff_t pos;
+ };
+ 
++>>>>>>> 5f99f4e79abc ([readdir] switch dcache_readdir() users to ->iterate())
  struct block_device_operations;
  
  /* These macros are for out of kernel modules to test that
@@@ -3234,29 -2695,35 +3242,61 @@@ static inline void inode_has_no_xattr(s
  		inode->i_flags |= S_NOSEC;
  }
  
++<<<<<<< HEAD
 +static inline const struct inode_operations_wrapper *get_iop_wrapper(struct inode *inode,
 +								     unsigned version)
 +{
 +	const struct inode_operations_wrapper *wrapper;
 +		
 +	if (!IS_IOPS_WRAPPER(inode))
 +		return NULL;
 +	wrapper = container_of(inode->i_op, const struct inode_operations_wrapper, ops);
 +	if (wrapper->version < version)
 +		return NULL;
 +	return wrapper;
 +}
 +
 +static inline iop_rename2_t get_rename2_iop(struct inode *inode)
 +{
 +	const struct inode_operations_wrapper *wrapper = get_iop_wrapper(inode, 0);
 +	return wrapper ? wrapper->rename2 : NULL;
 +}
 +
 +static inline iop_dentry_open_t get_dentry_open_iop(struct inode *inode)
 +{
 +	const struct inode_operations_wrapper *wrapper = get_iop_wrapper(inode, 0);
 +	return wrapper ? wrapper->dentry_open : NULL;
++=======
+ static inline bool dir_emit(struct dir_context *ctx,
+ 			    const char *name, int namelen,
+ 			    u64 ino, unsigned type)
+ {
+ 	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
+ }
+ static inline bool dir_emit_dot(struct file *file, struct dir_context *ctx)
+ {
+ 	return ctx->actor(ctx, ".", 1, ctx->pos,
+ 			  file->f_path.dentry->d_inode->i_ino, DT_DIR) == 0;
+ }
+ static inline bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)
+ {
+ 	return ctx->actor(ctx, "..", 2, ctx->pos,
+ 			  parent_ino(file->f_path.dentry), DT_DIR) == 0;
+ }
+ static inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)
+ {
+ 	if (ctx->pos == 0) {
+ 		if (!dir_emit_dot(file, ctx))
+ 			return false;
+ 		ctx->pos = 1;
+ 	}
+ 	if (ctx->pos == 1) {
+ 		if (!dir_emit_dotdot(file, ctx))
+ 			return false;
+ 		ctx->pos = 2;
+ 	}
+ 	return true;
++>>>>>>> 5f99f4e79abc ([readdir] switch dcache_readdir() users to ->iterate())
  }
  
  #endif /* _LINUX_FS_H */
diff --git a/arch/powerpc/platforms/cell/spufs/inode.c b/arch/powerpc/platforms/cell/spufs/inode.c
index 35f77a42bedf..f3900427ffab 100644
--- a/arch/powerpc/platforms/cell/spufs/inode.c
+++ b/arch/powerpc/platforms/cell/spufs/inode.c
@@ -238,7 +238,7 @@ const struct file_operations spufs_context_fops = {
 	.release	= spufs_dir_close,
 	.llseek		= dcache_dir_lseek,
 	.read		= generic_read_dir,
-	.readdir	= dcache_readdir,
+	.iterate	= dcache_readdir,
 	.fsync		= noop_fsync,
 };
 EXPORT_SYMBOL_GPL(spufs_context_fops);
diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c
index adbd3657dc66..4932ac4cad74 100644
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -39,7 +39,7 @@ const struct file_operations autofs4_root_operations = {
 	.open		= dcache_dir_open,
 	.release	= dcache_dir_close,
 	.read		= generic_read_dir,
-	.readdir	= dcache_readdir,
+	.iterate	= dcache_readdir,
 	.llseek		= dcache_dir_lseek,
 	.unlocked_ioctl	= autofs4_root_ioctl,
 #ifdef CONFIG_COMPAT
@@ -51,7 +51,7 @@ const struct file_operations autofs4_dir_operations = {
 	.open		= autofs4_dir_open,
 	.release	= dcache_dir_close,
 	.read		= generic_read_dir,
-	.readdir	= dcache_readdir,
+	.iterate	= dcache_readdir,
 	.llseek		= dcache_dir_lseek,
 };
 
diff --git a/fs/libfs.c b/fs/libfs.c
index 23fbb25d1c9f..794467671d73 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -143,60 +143,40 @@ static inline unsigned char dt_type(struct inode *inode)
  * both impossible due to the lock on directory.
  */
 
-int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
+int dcache_readdir(struct file *file, struct dir_context *ctx)
 {
-	struct dentry *dentry = filp->f_path.dentry;
-	struct dentry *cursor = filp->private_data;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *cursor = file->private_data;
 	struct list_head *p, *q = &cursor->d_u.d_child;
-	ino_t ino;
-	int i = filp->f_pos;
 
-	switch (i) {
-		case 0:
-			ino = dentry->d_inode->i_ino;
-			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
-				break;
-			filp->f_pos++;
-			i++;
-			/* fallthrough */
-		case 1:
-			ino = parent_ino(dentry);
-			if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
-				break;
-			filp->f_pos++;
-			i++;
-			/* fallthrough */
-		default:
-			spin_lock(&dentry->d_lock);
-			if (filp->f_pos == 2)
-				list_move(q, &dentry->d_subdirs);
-
-			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
-				struct dentry *next;
-				next = list_entry(p, struct dentry, d_u.d_child);
-				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
-				if (!simple_positive(next)) {
-					spin_unlock(&next->d_lock);
-					continue;
-				}
+	if (!dir_emit_dots(file, ctx))
+		return 0;
+	spin_lock(&dentry->d_lock);
+	if (ctx->pos == 2)
+		list_move(q, &dentry->d_subdirs);
+
+	for (p = q->next; p != &dentry->d_subdirs; p = p->next) {
+		struct dentry *next = list_entry(p, struct dentry, d_u.d_child);
+		spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
+		if (!simple_positive(next)) {
+			spin_unlock(&next->d_lock);
+			continue;
+		}
 
-				spin_unlock(&next->d_lock);
-				spin_unlock(&dentry->d_lock);
-				if (filldir(dirent, next->d_name.name, 
-					    next->d_name.len, filp->f_pos, 
-					    next->d_inode->i_ino, 
-					    dt_type(next->d_inode)) < 0)
-					return 0;
-				spin_lock(&dentry->d_lock);
-				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
-				/* next is still alive */
-				list_move(q, p);
-				spin_unlock(&next->d_lock);
-				p = q;
-				filp->f_pos++;
-			}
-			spin_unlock(&dentry->d_lock);
+		spin_unlock(&next->d_lock);
+		spin_unlock(&dentry->d_lock);
+		if (!dir_emit(ctx, next->d_name.name, next->d_name.len,
+			      next->d_inode->i_ino, dt_type(next->d_inode)))
+			return 0;
+		spin_lock(&dentry->d_lock);
+		spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
+		/* next is still alive */
+		list_move(q, p);
+		spin_unlock(&next->d_lock);
+		p = q;
+		ctx->pos++;
 	}
+	spin_unlock(&dentry->d_lock);
 	return 0;
 }
 EXPORT_SYMBOL(dcache_readdir);
@@ -212,7 +192,7 @@ const struct file_operations simple_dir_operations = {
 	.release	= dcache_dir_close,
 	.llseek		= dcache_dir_lseek,
 	.read		= generic_read_dir,
-	.readdir	= dcache_readdir,
+	.iterate	= dcache_readdir,
 	.fsync		= noop_fsync,
 };
 EXPORT_SYMBOL(simple_dir_operations);
* Unmerged path include/linux/fs.h
