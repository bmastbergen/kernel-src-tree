nfp: explicitly check if application FW is loaded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit d557ee6bdc6dc4df2ab8e00c2127120b4acbdfca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d557ee6b.failed

We support application FW being either loaded automatically at
boot from flash or (more commonly) by the driver from disk.
If FW is not found on disk and nothing is preloaded users are
faced with this unintuitive error:

nfp 0000:04:00.0: nfp: Failed to find PF symbol _pf0_net_bar0

We can do better.  Since we rely on symbol table being present -
check early if it could be correctly read out of from the device
and if not print a more informative message.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d557ee6bdc6dc4df2ab8e00c2127120b4acbdfca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,3169400dd474..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -435,15 -456,186 +435,167 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  	return 0;
  
  err_prev_deinit:
 -	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_clean_vnic(pf, nn);
 -	return err;
 -}
 -
 -static int
 -nfp_net_pf_app_init(struct nfp_pf *pf, u8 __iomem *qc_bar, unsigned int stride)
 -{
 -	u8 __iomem *ctrl_bar;
 -	int err;
 -
 -	pf->app = nfp_app_alloc(pf, nfp_net_pf_get_app_id(pf));
 -	if (IS_ERR(pf->app))
 -		return PTR_ERR(pf->app);
 -
 -	err = nfp_app_init(pf->app);
 -	if (err)
 -		goto err_free;
 -
 -	if (!nfp_app_needs_ctrl_vnic(pf->app))
 -		return 0;
 -
 -	ctrl_bar = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%u_net_ctrl_bar",
 -					NFP_PF_CSR_SLICE_SIZE,
 -					&pf->ctrl_vnic_bar);
 -	if (IS_ERR(ctrl_bar)) {
 -		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
 -		err = PTR_ERR(ctrl_bar);
 -		goto err_free;
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
  	}
++<<<<<<< HEAD
 +	nfp_net_irqs_disable(pf->pdev);
 +err_vec_free:
 +	kfree(pf->irq_entries);
 +err_nn_free:
 +	nfp_net_pf_free_netdevs(pf);
++=======
+ 
+ 	pf->ctrl_vnic =	nfp_net_pf_alloc_vnic(pf, false, ctrl_bar, qc_bar,
+ 					      stride, 0);
+ 	if (IS_ERR(pf->ctrl_vnic)) {
+ 		err = PTR_ERR(pf->ctrl_vnic);
+ 		goto err_unmap;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap:
+ 	nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ err_free:
+ 	nfp_app_free(pf->app);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_clean(struct nfp_pf *pf)
+ {
+ 	if (pf->ctrl_vnic) {
+ 		nfp_net_pf_free_vnic(pf, pf->ctrl_vnic);
+ 		nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ 	}
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ }
+ 
+ static int nfp_net_pf_app_start_ctrl(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	if (!pf->ctrl_vnic)
+ 		return 0;
+ 	err = nfp_net_pf_init_vnic(pf, pf->ctrl_vnic, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_ctrl_open(pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_clean_ctrl;
+ 
+ 	return 0;
+ 
+ err_clean_ctrl:
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop_ctrl(struct nfp_pf *pf)
+ {
+ 	if (!pf->ctrl_vnic)
+ 		return;
+ 	nfp_ctrl_close(pf->ctrl_vnic);
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ }
+ 
+ static int nfp_net_pf_app_start(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	err = nfp_net_pf_app_start_ctrl(pf);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_app_start(pf->app, pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_ctrl_stop;
+ 
+ 	return 0;
+ 
+ err_ctrl_stop:
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop(struct nfp_pf *pf)
+ {
+ 	nfp_app_stop(pf->app);
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ }
+ 
+ static void nfp_net_pci_unmap_mem(struct nfp_pf *pf)
+ {
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ 	nfp_cpp_area_release_free(pf->qc_area);
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
+ }
+ 
+ static int nfp_net_pci_map_mem(struct nfp_pf *pf)
+ {
+ 	u32 ctrl_bar_sz;
+ 	u8 __iomem *mem;
+ 	int err;
+ 
+ 	ctrl_bar_sz = pf->max_data_vnics * NFP_PF_CSR_SLICE_SIZE;
+ 	mem = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%d_net_bar0",
+ 				   ctrl_bar_sz, &pf->data_vnic_bar);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
+ 		return PTR_ERR(mem);
+ 	}
+ 
+ 	pf->mac_stats_mem = nfp_net_pf_map_rtsym(pf, "net.macstats",
+ 						 "_mac_stats",
+ 						 NFP_MAC_STATS_SIZE *
+ 						 (pf->eth_tbl->max_index + 1),
+ 						 &pf->mac_stats_bar);
+ 	if (IS_ERR(pf->mac_stats_mem)) {
+ 		if (PTR_ERR(pf->mac_stats_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->mac_stats_mem);
+ 			goto err_unmap_ctrl;
+ 		}
+ 		pf->mac_stats_mem = NULL;
+ 	}
+ 
+ 	pf->vf_cfg_mem = nfp_net_pf_map_rtsym(pf, "net.vfcfg",
+ 					      "_pf%d_net_vf_bar",
+ 					      NFP_NET_CFG_BAR_SZ *
+ 					      pf->limit_vfs, &pf->vf_cfg_bar);
+ 	if (IS_ERR(pf->vf_cfg_mem)) {
+ 		if (PTR_ERR(pf->vf_cfg_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->vf_cfg_mem);
+ 			goto err_unmap_mac_stats;
+ 		}
+ 		pf->vf_cfg_mem = NULL;
+ 	}
+ 
+ 	mem = nfp_net_map_area(pf->cpp, "net.qc", 0, 0,
+ 			       NFP_PCIE_QUEUE(0), NFP_QCP_QUEUE_AREA_SZ,
+ 			       &pf->qc_area);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to map Queue Controller area.\n");
+ 		err = PTR_ERR(mem);
+ 		goto err_unmap_vf_cfg;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap_vf_cfg:
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ err_unmap_mac_stats:
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ err_unmap_ctrl:
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
++>>>>>>> d557ee6bdc6d (nfp: explicitly check if application FW is loaded)
  	return err;
  }
  
@@@ -544,13 -783,28 +696,28 @@@ int nfp_net_pci_probe(struct nfp_pf *pf
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	mutex_lock(&pf->port_lock);
 +	pf->num_ports = nfp_net_pf_get_num_ports(pf);
++=======
+ 	if (!pf->rtbl) {
+ 		nfp_err(pf->cpp, "No %s, giving up.\n",
+ 			pf->fw_loaded ? "symbol table" : "firmware found");
+ 		return -EPROBE_DEFER;
+ 	}
+ 
+ 	mutex_lock(&pf->lock);
+ 	pf->max_data_vnics = nfp_net_pf_get_num_ports(pf);
+ 	if ((int)pf->max_data_vnics < 0) {
+ 		err = pf->max_data_vnics;
+ 		goto err_unlock;
+ 	}
++>>>>>>> d557ee6bdc6d (nfp: explicitly check if application FW is loaded)
  
 -	err = nfp_net_pci_map_mem(pf);
 -	if (err)
 +	ctrl_bar = nfp_net_pf_map_ctrl_bar(pf);
 +	if (!ctrl_bar) {
 +		err = pf->fw_loaded ? -EINVAL : -EPROBE_DEFER;
  		goto err_unlock;
 -
 -	ctrl_bar = nfp_cpp_area_iomem(pf->data_vnic_bar);
 -	qc_bar = nfp_cpp_area_iomem(pf->qc_area);
 -	if (!ctrl_bar || !qc_bar) {
 -		err = -EIO;
 -		goto err_unmap;
  	}
  
  	nfp_net_get_fw_version(&fw_ver, ctrl_bar);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
