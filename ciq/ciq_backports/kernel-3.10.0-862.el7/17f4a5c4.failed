i2c: move acpi code back into the core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [i2c] move acpi code back into the core (Gopal Tiwari) [1456705]
Rebuild_FUZZ: 92.96%
commit-author Wolfram Sang <wsa@the-dreams.de>
commit 17f4a5c47f28de9ea59182f48d07f8c44ee5dcc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/17f4a5c4.failed

Commit 5d98e61d337c ("I2C/ACPI: Add i2c ACPI operation region support")
renamed the i2c-core module. This may cause regressions for
distributions, so put the ACPI code back into the core.

	Reported-by: Jean Delvare <jdelvare@suse.de>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
	Tested-by: Lan Tianyu <tianyu.lan@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 17f4a5c47f28de9ea59182f48d07f8c44ee5dcc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/i2c/Makefile
#	drivers/i2c/i2c-acpi.c
#	drivers/i2c/i2c-core.c
#	include/linux/i2c.h
diff --cc MAINTAINERS
index e55ff8ec86c9,e3682d0dea1e..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -4097,8 -4472,14 +4097,17 @@@ F:	include/linux/i2c-*.
  F:	include/uapi/linux/i2c.h
  F:	include/uapi/linux/i2c-*.h
  
++<<<<<<< HEAD
++=======
+ I2C ACPI SUPPORT
+ M:	Mika Westerberg <mika.westerberg@linux.intel.com>
+ L:	linux-i2c@vger.kernel.org
+ L:	linux-acpi@vger.kernel.org
+ S:	Maintained
+ 
++>>>>>>> 17f4a5c47f28 (i2c: move acpi code back into the core)
  I2C-TAOS-EVM DRIVER
 -M:	Jean Delvare <jdelvare@suse.de>
 +M:	Jean Delvare <khali@linux-fr.org>
  L:	linux-i2c@vger.kernel.org
  S:	Maintained
  F:	Documentation/i2c/busses/i2c-taos-evm
diff --cc drivers/i2c/Makefile
index a1f590cbb435,1722f50f2473..000000000000
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@@ -2,11 -2,8 +2,14 @@@
  # Makefile for the i2c core.
  #
  
++<<<<<<< HEAD
 +i2ccore-y := i2c-core.o
 +i2ccore-$(CONFIG_I2C_ACPI)	+= i2c-acpi.o
 +
++=======
++>>>>>>> 17f4a5c47f28 (i2c: move acpi code back into the core)
  obj-$(CONFIG_I2C_BOARDINFO)	+= i2c-boardinfo.o
- obj-$(CONFIG_I2C)		+= i2ccore.o
+ obj-$(CONFIG_I2C)		+= i2c-core.o
  obj-$(CONFIG_I2C_SMBUS)		+= i2c-smbus.o
  obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
  obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
diff --cc drivers/i2c/i2c-core.c
index dc4010bd2179,b696ac7e6d86..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -57,6 -68,370 +59,373 @@@ static DEFINE_IDR(i2c_adapter_idr)
  static struct device_type i2c_client_type;
  static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);
  
++<<<<<<< HEAD
++=======
+ static struct static_key i2c_trace_msg = STATIC_KEY_INIT_FALSE;
+ 
+ void i2c_transfer_trace_reg(void)
+ {
+ 	static_key_slow_inc(&i2c_trace_msg);
+ }
+ 
+ void i2c_transfer_trace_unreg(void)
+ {
+ 	static_key_slow_dec(&i2c_trace_msg);
+ }
+ 
+ #if defined(CONFIG_ACPI)
+ struct acpi_i2c_handler_data {
+ 	struct acpi_connection_info info;
+ 	struct i2c_adapter *adapter;
+ };
+ 
+ struct gsb_buffer {
+ 	u8	status;
+ 	u8	len;
+ 	union {
+ 		u16	wdata;
+ 		u8	bdata;
+ 		u8	data[0];
+ 	};
+ } __packed;
+ 
+ static int acpi_i2c_add_resource(struct acpi_resource *ares, void *data)
+ {
+ 	struct i2c_board_info *info = data;
+ 
+ 	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+ 		struct acpi_resource_i2c_serialbus *sb;
+ 
+ 		sb = &ares->data.i2c_serial_bus;
+ 		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {
+ 			info->addr = sb->slave_address;
+ 			if (sb->access_mode == ACPI_I2C_10BIT_MODE)
+ 				info->flags |= I2C_CLIENT_TEN;
+ 		}
+ 	} else if (info->irq < 0) {
+ 		struct resource r;
+ 
+ 		if (acpi_dev_resource_interrupt(ares, 0, &r))
+ 			info->irq = r.start;
+ 	}
+ 
+ 	/* Tell the ACPI core to skip this resource */
+ 	return 1;
+ }
+ 
+ static acpi_status acpi_i2c_add_device(acpi_handle handle, u32 level,
+ 				       void *data, void **return_value)
+ {
+ 	struct i2c_adapter *adapter = data;
+ 	struct list_head resource_list;
+ 	struct i2c_board_info info;
+ 	struct acpi_device *adev;
+ 	int ret;
+ 
+ 	if (acpi_bus_get_device(handle, &adev))
+ 		return AE_OK;
+ 	if (acpi_bus_get_status(adev) || !adev->status.present)
+ 		return AE_OK;
+ 
+ 	memset(&info, 0, sizeof(info));
+ 	info.acpi_node.companion = adev;
+ 	info.irq = -1;
+ 
+ 	INIT_LIST_HEAD(&resource_list);
+ 	ret = acpi_dev_get_resources(adev, &resource_list,
+ 				     acpi_i2c_add_resource, &info);
+ 	acpi_dev_free_resource_list(&resource_list);
+ 
+ 	if (ret < 0 || !info.addr)
+ 		return AE_OK;
+ 
+ 	adev->power.flags.ignore_parent = true;
+ 	strlcpy(info.type, dev_name(&adev->dev), sizeof(info.type));
+ 	if (!i2c_new_device(adapter, &info)) {
+ 		adev->power.flags.ignore_parent = false;
+ 		dev_err(&adapter->dev,
+ 			"failed to add I2C device %s from ACPI\n",
+ 			dev_name(&adev->dev));
+ 	}
+ 
+ 	return AE_OK;
+ }
+ 
+ /**
+  * acpi_i2c_register_devices - enumerate I2C slave devices behind adapter
+  * @adap: pointer to adapter
+  *
+  * Enumerate all I2C slave devices behind this adapter by walking the ACPI
+  * namespace. When a device is found it will be added to the Linux device
+  * model and bound to the corresponding ACPI handle.
+  */
+ static void acpi_i2c_register_devices(struct i2c_adapter *adap)
+ {
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 
+ 	if (!adap->dev.parent)
+ 		return;
+ 
+ 	handle = ACPI_HANDLE(adap->dev.parent);
+ 	if (!handle)
+ 		return;
+ 
+ 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+ 				     acpi_i2c_add_device, NULL,
+ 				     adap, NULL);
+ 	if (ACPI_FAILURE(status))
+ 		dev_warn(&adap->dev, "failed to enumerate I2C slaves\n");
+ }
+ 
+ #else /* CONFIG_ACPI */
+ static inline void acpi_i2c_register_devices(struct i2c_adapter *adap) { }
+ #endif /* CONFIG_ACPI */
+ 
+ #ifdef CONFIG_ACPI_I2C_OPREGION
+ static int acpi_gsb_i2c_read_bytes(struct i2c_client *client,
+ 		u8 cmd, u8 *data, u8 data_len)
+ {
+ 
+ 	struct i2c_msg msgs[2];
+ 	int ret;
+ 	u8 *buffer;
+ 
+ 	buffer = kzalloc(data_len, GFP_KERNEL);
+ 	if (!buffer)
+ 		return AE_NO_MEMORY;
+ 
+ 	msgs[0].addr = client->addr;
+ 	msgs[0].flags = client->flags;
+ 	msgs[0].len = 1;
+ 	msgs[0].buf = &cmd;
+ 
+ 	msgs[1].addr = client->addr;
+ 	msgs[1].flags = client->flags | I2C_M_RD;
+ 	msgs[1].len = data_len;
+ 	msgs[1].buf = buffer;
+ 
+ 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+ 	if (ret < 0)
+ 		dev_err(&client->adapter->dev, "i2c read failed\n");
+ 	else
+ 		memcpy(data, buffer, data_len);
+ 
+ 	kfree(buffer);
+ 	return ret;
+ }
+ 
+ static int acpi_gsb_i2c_write_bytes(struct i2c_client *client,
+ 		u8 cmd, u8 *data, u8 data_len)
+ {
+ 
+ 	struct i2c_msg msgs[1];
+ 	u8 *buffer;
+ 	int ret = AE_OK;
+ 
+ 	buffer = kzalloc(data_len + 1, GFP_KERNEL);
+ 	if (!buffer)
+ 		return AE_NO_MEMORY;
+ 
+ 	buffer[0] = cmd;
+ 	memcpy(buffer + 1, data, data_len);
+ 
+ 	msgs[0].addr = client->addr;
+ 	msgs[0].flags = client->flags;
+ 	msgs[0].len = data_len + 1;
+ 	msgs[0].buf = buffer;
+ 
+ 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+ 	if (ret < 0)
+ 		dev_err(&client->adapter->dev, "i2c write failed\n");
+ 
+ 	kfree(buffer);
+ 	return ret;
+ }
+ 
+ static acpi_status
+ acpi_i2c_space_handler(u32 function, acpi_physical_address command,
+ 			u32 bits, u64 *value64,
+ 			void *handler_context, void *region_context)
+ {
+ 	struct gsb_buffer *gsb = (struct gsb_buffer *)value64;
+ 	struct acpi_i2c_handler_data *data = handler_context;
+ 	struct acpi_connection_info *info = &data->info;
+ 	struct acpi_resource_i2c_serialbus *sb;
+ 	struct i2c_adapter *adapter = data->adapter;
+ 	struct i2c_client client;
+ 	struct acpi_resource *ares;
+ 	u32 accessor_type = function >> 16;
+ 	u8 action = function & ACPI_IO_MASK;
+ 	acpi_status ret = AE_OK;
+ 	int status;
+ 
+ 	ret = acpi_buffer_to_resource(info->connection, info->length, &ares);
+ 	if (ACPI_FAILURE(ret))
+ 		return ret;
+ 
+ 	if (!value64 || ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+ 		ret = AE_BAD_PARAMETER;
+ 		goto err;
+ 	}
+ 
+ 	sb = &ares->data.i2c_serial_bus;
+ 	if (sb->type != ACPI_RESOURCE_SERIAL_TYPE_I2C) {
+ 		ret = AE_BAD_PARAMETER;
+ 		goto err;
+ 	}
+ 
+ 	memset(&client, 0, sizeof(client));
+ 	client.adapter = adapter;
+ 	client.addr = sb->slave_address;
+ 	client.flags = 0;
+ 
+ 	if (sb->access_mode == ACPI_I2C_10BIT_MODE)
+ 		client.flags |= I2C_CLIENT_TEN;
+ 
+ 	switch (accessor_type) {
+ 	case ACPI_GSB_ACCESS_ATTRIB_SEND_RCV:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_byte(&client);
+ 			if (status >= 0) {
+ 				gsb->bdata = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_byte(&client, gsb->bdata);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_BYTE:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_byte_data(&client, command);
+ 			if (status >= 0) {
+ 				gsb->bdata = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_byte_data(&client, command,
+ 					gsb->bdata);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_WORD:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_word_data(&client, command);
+ 			if (status >= 0) {
+ 				gsb->wdata = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_word_data(&client, command,
+ 					gsb->wdata);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_BLOCK:
+ 		if (action == ACPI_READ) {
+ 			status = i2c_smbus_read_block_data(&client, command,
+ 					gsb->data);
+ 			if (status >= 0) {
+ 				gsb->len = status;
+ 				status = 0;
+ 			}
+ 		} else {
+ 			status = i2c_smbus_write_block_data(&client, command,
+ 					gsb->len, gsb->data);
+ 		}
+ 		break;
+ 
+ 	case ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE:
+ 		if (action == ACPI_READ) {
+ 			status = acpi_gsb_i2c_read_bytes(&client, command,
+ 					gsb->data, info->access_length);
+ 			if (status > 0)
+ 				status = 0;
+ 		} else {
+ 			status = acpi_gsb_i2c_write_bytes(&client, command,
+ 					gsb->data, info->access_length);
+ 		}
+ 		break;
+ 
+ 	default:
+ 		pr_info("protocol(0x%02x) is not supported.\n", accessor_type);
+ 		ret = AE_BAD_PARAMETER;
+ 		goto err;
+ 	}
+ 
+ 	gsb->status = status;
+ 
+  err:
+ 	ACPI_FREE(ares);
+ 	return ret;
+ }
+ 
+ 
+ static int acpi_i2c_install_space_handler(struct i2c_adapter *adapter)
+ {
+ 	acpi_handle handle = ACPI_HANDLE(adapter->dev.parent);
+ 	struct acpi_i2c_handler_data *data;
+ 	acpi_status status;
+ 
+ 	if (!handle)
+ 		return -ENODEV;
+ 
+ 	data = kzalloc(sizeof(struct acpi_i2c_handler_data),
+ 			    GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	data->adapter = adapter;
+ 	status = acpi_bus_attach_private_data(handle, (void *)data);
+ 	if (ACPI_FAILURE(status)) {
+ 		kfree(data);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	status = acpi_install_address_space_handler(handle,
+ 				ACPI_ADR_SPACE_GSBUS,
+ 				&acpi_i2c_space_handler,
+ 				NULL,
+ 				data);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&adapter->dev, "Error installing i2c space handler\n");
+ 		acpi_bus_detach_private_data(handle);
+ 		kfree(data);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void acpi_i2c_remove_space_handler(struct i2c_adapter *adapter)
+ {
+ 	acpi_handle handle = ACPI_HANDLE(adapter->dev.parent);
+ 	struct acpi_i2c_handler_data *data;
+ 	acpi_status status;
+ 
+ 	if (!handle)
+ 		return;
+ 
+ 	acpi_remove_address_space_handler(handle,
+ 				ACPI_ADR_SPACE_GSBUS,
+ 				&acpi_i2c_space_handler);
+ 
+ 	status = acpi_bus_get_private_data(handle, (void **)&data);
+ 	if (ACPI_SUCCESS(status))
+ 		kfree(data);
+ 
+ 	acpi_bus_detach_private_data(handle);
+ }
+ #else /* CONFIG_ACPI_I2C_OPREGION */
+ static inline void acpi_i2c_remove_space_handler(struct i2c_adapter *adapter)
+ { }
+ 
+ static inline int acpi_i2c_install_space_handler(struct i2c_adapter *adapter)
+ { return 0; }
+ #endif /* CONFIG_ACPI_I2C_OPREGION */
+ 
++>>>>>>> 17f4a5c47f28 (i2c: move acpi code back into the core)
  /* ------------------------------------------------------------------------- */
  
  static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
diff --cc include/linux/i2c.h
index 021a03407cda,b556e0ab946f..000000000000
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@@ -645,16 -577,4 +645,19 @@@ static inline struct i2c_adapter *of_fi
  }
  #endif /* CONFIG_OF */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_I2C_ACPI
 +int acpi_i2c_install_space_handler(struct i2c_adapter *adapter);
 +void acpi_i2c_remove_space_handler(struct i2c_adapter *adapter);
 +void acpi_i2c_register_devices(struct i2c_adapter *adap);
 +#else
 +static inline void acpi_i2c_register_devices(struct i2c_adapter *adap) { }
 +static inline void acpi_i2c_remove_space_handler(struct i2c_adapter *adapter)
 +{ }
 +static inline int acpi_i2c_install_space_handler(struct i2c_adapter *adapter)
 +{ return 0; }
 +#endif
 +
++=======
++>>>>>>> 17f4a5c47f28 (i2c: move acpi code back into the core)
  #endif /* _LINUX_I2C_H */
* Unmerged path drivers/i2c/i2c-acpi.c
* Unmerged path MAINTAINERS
* Unmerged path drivers/i2c/Makefile
* Unmerged path drivers/i2c/i2c-acpi.c
* Unmerged path drivers/i2c/i2c-core.c
* Unmerged path include/linux/i2c.h
