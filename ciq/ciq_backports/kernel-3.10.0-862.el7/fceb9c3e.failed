geneve: avoid using stale geneve socket.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] geneve: avoid using stale geneve socket (Jakub Sitnicki) [1467288]
Rebuild_FUZZ: 98.73%
commit-author pravin shelar <pshelar@ovn.org>
commit fceb9c3e38252992bbf1a3028cc2f7b871211533
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fceb9c3e.failed

This patch is similar to earlier vxlan patch.
Geneve device close operation frees geneve socket. This
operation can race with geneve-xmit function which
dereferences geneve socket. Following patch uses RCU
mechanism to avoid this situation.

	Signed-off-by: Pravin B Shelar <pshelar@ovn.org>
	Acked-by: John W. Linville <linville@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fceb9c3e38252992bbf1a3028cc2f7b871211533)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index c4c93ccffa85,42edd7b7902f..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -53,22 -53,14 +53,22 @@@ union geneve_addr 
  
  static union geneve_addr geneve_remote_unspec = { .sa.sa_family = AF_UNSPEC, };
  
 +struct geneve_dev_node {
 +	struct hlist_node hlist;
 +	struct geneve_dev *geneve;
 +};
 +
  /* Pseudo network device */
  struct geneve_dev {
 -	struct hlist_node  hlist;	/* vni hash table */
 +	struct geneve_dev_node hlist4;	/* vni hash table for IPv4 socket */
 +#if IS_ENABLED(CONFIG_IPV6)
 +	struct geneve_dev_node hlist6;	/* vni hash table for IPv6 socket */
 +#endif
  	struct net	   *net;	/* netns for packet i/o */
  	struct net_device  *dev;	/* netdev for geneve tunnel */
- 	struct geneve_sock *sock4;	/* IPv4 socket used for geneve tunnel */
+ 	struct geneve_sock __rcu *sock4;	/* IPv4 socket used for geneve tunnel */
  #if IS_ENABLED(CONFIG_IPV6)
- 	struct geneve_sock *sock6;	/* IPv6 socket used for geneve tunnel */
+ 	struct geneve_sock __rcu *sock6;	/* IPv6 socket used for geneve tunnel */
  #endif
  	u8                 vni[3];	/* virtual network ID for tunnel */
  	u8                 ttl;		/* TTL override */
@@@ -594,19 -595,14 +604,27 @@@ out
  	gs->collect_md = geneve->collect_md;
  	gs->flags = geneve->flags;
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +	if (ipv6) {
 +		geneve->sock6 = gs;
 +		node = &geneve->hlist6;
 +	} else
 +#endif
 +	{
 +		geneve->sock4 = gs;
 +		node = &geneve->hlist4;
 +	}
 +	node->geneve = geneve;
++=======
+ 	if (ipv6)
+ 		rcu_assign_pointer(geneve->sock6, gs);
+ 	else
+ #endif
+ 		rcu_assign_pointer(geneve->sock4, gs);
++>>>>>>> fceb9c3e3825 (geneve: avoid using stale geneve socket.)
  
  	hash = geneve_net_vni_hash(geneve->vni);
 -	hlist_add_head_rcu(&geneve->hlist, &gs->vni_list[hash]);
 +	hlist_add_head_rcu(&node->hlist, &gs->vni_list[hash]);
  	return 0;
  }
  
@@@ -858,8 -857,9 +881,8 @@@ static netdev_tx_t geneve_xmit_skb(stru
  				   struct ip_tunnel_info *info)
  {
  	struct geneve_dev *geneve = netdev_priv(dev);
- 	struct geneve_sock *gs4 = geneve->sock4;
+ 	struct geneve_sock *gs4;
  	struct rtable *rt = NULL;
 -	const struct iphdr *iip; /* interior IP header */
  	int err = -EINVAL;
  	struct flowi4 fl4;
  	__u8 tos, ttl;
@@@ -945,8 -951,9 +972,12 @@@ static netdev_tx_t geneve6_xmit_skb(str
  				    struct ip_tunnel_info *info)
  {
  	struct geneve_dev *geneve = netdev_priv(dev);
- 	struct geneve_sock *gs6 = geneve->sock6;
  	struct dst_entry *dst = NULL;
++<<<<<<< HEAD
++=======
+ 	const struct iphdr *iip; /* interior IP header */
+ 	struct geneve_sock *gs6;
++>>>>>>> fceb9c3e3825 (geneve: avoid using stale geneve socket.)
  	int err = -EINVAL;
  	struct flowi6 fl6;
  	__u8 prio, ttl;
* Unmerged path drivers/net/geneve.c
