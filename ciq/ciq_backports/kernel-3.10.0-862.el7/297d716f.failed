power_supply: Change ownership from driver to core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Krzysztof Kozlowski <k.kozlowski@samsung.com>
commit 297d716f6260cc9421d971b124ca196b957ee458
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/297d716f.failed

Change the ownership of power_supply structure from each driver
implementing the class to the power supply core.

The patch changes power_supply_register() function thus all drivers
implementing power supply class are adjusted.

Each driver provides the implementation of power supply. However it
should not be the owner of power supply class instance because it is
exposed by core to other subsystems with power_supply_get_by_name().
These other subsystems have no knowledge when the driver will unregister
the power supply. This leads to several issues when driver is unbound -
mostly because user of power supply accesses freed memory.

Instead let the core own the instance of struct 'power_supply'.  Other
users of this power supply will still access valid memory because it
will be freed when device reference count reaches 0. Currently this
means "it will leak" but power_supply_put() call in next patches will
solve it.

This solves invalid memory references in following race condition
scenario:

Thread 1: charger manager
Thread 2: power supply driver, used by charger manager

THREAD 1 (charger manager)         THREAD 2 (power supply driver)
==========================         ==============================
psy = power_supply_get_by_name()
                                   Driver unbind, .remove
                                     power_supply_unregister()
                                     Device fully removed
psy->get_property()

The 'get_property' call is executed in invalid context because the driver was
unbound and struct 'power_supply' memory was freed.

This could be observed easily with charger manager driver (here compiled
with max17040 fuel gauge):

$ cat /sys/devices/virtual/power_supply/cm-battery/capacity &
$ echo "1-0036" > /sys/bus/i2c/drivers/max17040/unbind
[   55.725123] Unable to handle kernel NULL pointer dereference at virtual address 00000000
[   55.732584] pgd = d98d4000
[   55.734060] [00000000] *pgd=5afa2831, *pte=00000000, *ppte=00000000
[   55.740318] Internal error: Oops: 80000007 [#1] PREEMPT SMP ARM
[   55.746210] Modules linked in:
[   55.749259] CPU: 1 PID: 2936 Comm: cat Tainted: G        W       3.19.0-rc1-next-20141226-00048-gf79f475f3c44-dirty #1496
[   55.760190] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
[   55.766270] task: d9b76f00 ti: daf54000 task.ti: daf54000
[   55.771647] PC is at 0x0
[   55.774182] LR is at charger_get_property+0x2f4/0x36c
[   55.779201] pc : [<00000000>]    lr : [<c034b0b4>]    psr: 60000013
[   55.779201] sp : daf55e90  ip : 00000003  fp : 00000000
[   55.790657] r10: 00000000  r9 : c06e2878  r8 : d9b26c68
[   55.795865] r7 : dad81610  r6 : daec7410  r5 : daf55ebc  r4 : 00000000
[   55.802367] r3 : 00000000  r2 : daf55ebc  r1 : 0000002a  r0 : d9b26c68
[   55.808879] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
[   55.815994] Control: 10c5387d  Table: 598d406a  DAC: 00000015
[   55.821723] Process cat (pid: 2936, stack limit = 0xdaf54210)
[   55.827451] Stack: (0xdaf55e90 to 0xdaf56000)
[   55.831795] 5e80:                                     60000013 c01459c4 0000002a c06f8ef8
[   55.839956] 5ea0: db651000 c06f8ef8 daebac00 c04cb668 daebac08 c0346864 00000000 c01459c4
[   55.848115] 5ec0: d99eaa80 c06f8ef8 00000fff 00001000 db651000 c027f25c c027f240 d99eaa80
[   55.856274] 5ee0: d9a06c00 c0146218 daf55f18 00001000 d99eaa80 db4c18c0 00000001 00000001
[   55.864468] 5f00: daf55f80 c0144c78 c0144c54 c0107f90 00015000 d99eaab0 00000000 00000000
[   55.872603] 5f20: 000051c7 00000000 db4c18c0 c04a9370 00015000 00001000 daf55f80 00001000
[   55.880763] 5f40: daf54000 00015000 00000000 c00e53dc db4c18c0 c00e548c 0000000d 00008124
[   55.888937] 5f60: 00000001 00000000 00000000 db4c18c0 db4c18c0 00001000 00015000 c00e5550
[   55.897099] 5f80: 00000000 00000000 00001000 00001000 00015000 00000003 00000003 c000f364
[   55.905239] 5fa0: 00000000 c000f1a0 00001000 00015000 00000003 00015000 00001000 0001333c
[   55.913399] 5fc0: 00001000 00015000 00000003 00000003 00000002 00000000 00000000 00000000
[   55.921560] 5fe0: 7fffe000 be999850 0000a225 b6f3c19c 60000010 00000003 00000000 00000000
[   55.929744] [<c034b0b4>] (charger_get_property) from [<c0346864>] (power_supply_show_property+0x48/0x20c)
[   55.939286] [<c0346864>] (power_supply_show_property) from [<c027f25c>] (dev_attr_show+0x1c/0x48)
[   55.948130] [<c027f25c>] (dev_attr_show) from [<c0146218>] (sysfs_kf_seq_show+0x84/0x104)
[   55.956298] [<c0146218>] (sysfs_kf_seq_show) from [<c0144c78>] (kernfs_seq_show+0x24/0x28)
[   55.964536] [<c0144c78>] (kernfs_seq_show) from [<c0107f90>] (seq_read+0x1b0/0x484)
[   55.972172] [<c0107f90>] (seq_read) from [<c00e53dc>] (__vfs_read+0x18/0x4c)
[   55.979188] [<c00e53dc>] (__vfs_read) from [<c00e548c>] (vfs_read+0x7c/0x100)
[   55.986304] [<c00e548c>] (vfs_read) from [<c00e5550>] (SyS_read+0x40/0x8c)
[   55.993164] [<c00e5550>] (SyS_read) from [<c000f1a0>] (ret_fast_syscall+0x0/0x48)
[   56.000626] Code: bad PC value
[   56.011652] ---[ end trace 7b64343fbdae8ef1 ]---

	Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
	Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

[for the nvec part]
	Reviewed-by: Marc Dietrich <marvin24@gmx.de>

[for compal-laptop.c]
	Acked-by: Darren Hart <dvhart@linux.intel.com>

[for the mfd part]
	Acked-by: Lee Jones <lee.jones@linaro.org>

[for the hid part]
	Acked-by: Jiri Kosina <jkosina@suse.cz>

[for the acpi part]
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

	Signed-off-by: Sebastian Reichel <sre@kernel.org>
(cherry picked from commit 297d716f6260cc9421d971b124ca196b957ee458)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/ac.c
#	drivers/acpi/battery.c
#	drivers/acpi/sbs.c
#	drivers/hid/hid-input.c
#	drivers/hid/hid-sony.c
#	drivers/hid/hid-wiimote-modules.c
#	drivers/hid/hid-wiimote.h
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/platform/x86/compal-laptop.c
#	drivers/power/88pm860x_battery.c
#	drivers/power/88pm860x_charger.c
#	drivers/power/ab8500_btemp.c
#	drivers/power/ab8500_charger.c
#	drivers/power/ab8500_fg.c
#	drivers/power/abx500_chargalg.c
#	drivers/power/axp288_fuel_gauge.c
#	drivers/power/bq2415x_charger.c
#	drivers/power/bq24190_charger.c
#	drivers/power/bq24735-charger.c
#	drivers/power/bq27x00_battery.c
#	drivers/power/charger-manager.c
#	drivers/power/collie_battery.c
#	drivers/power/da9030_battery.c
#	drivers/power/da9052-battery.c
#	drivers/power/da9150-charger.c
#	drivers/power/ds2760_battery.c
#	drivers/power/ds2780_battery.c
#	drivers/power/ds2781_battery.c
#	drivers/power/ds2782_battery.c
#	drivers/power/generic-adc-battery.c
#	drivers/power/goldfish_battery.c
#	drivers/power/gpio-charger.c
#	drivers/power/intel_mid_battery.c
#	drivers/power/ipaq_micro_battery.c
#	drivers/power/isp1704_charger.c
#	drivers/power/jz4740-battery.c
#	drivers/power/lp8727_charger.c
#	drivers/power/lp8788-charger.c
#	drivers/power/ltc2941-battery-gauge.c
#	drivers/power/max14577_charger.c
#	drivers/power/max17040_battery.c
#	drivers/power/max17042_battery.c
#	drivers/power/max77693_charger.c
#	drivers/power/max8903_charger.c
#	drivers/power/max8925_power.c
#	drivers/power/max8997_charger.c
#	drivers/power/max8998_charger.c
#	drivers/power/olpc_battery.c
#	drivers/power/pcf50633-charger.c
#	drivers/power/pda_power.c
#	drivers/power/pm2301_charger.c
#	drivers/power/pmu_battery.c
#	drivers/power/power_supply_core.c
#	drivers/power/power_supply_leds.c
#	drivers/power/power_supply_sysfs.c
#	drivers/power/rt5033_battery.c
#	drivers/power/rx51_battery.c
#	drivers/power/s3c_adc_battery.c
#	drivers/power/sbs-battery.c
#	drivers/power/smb347-charger.c
#	drivers/power/test_power.c
#	drivers/power/tosa_battery.c
#	drivers/power/tps65090-charger.c
#	drivers/power/twl4030_charger.c
#	drivers/power/twl4030_madc_battery.c
#	drivers/power/wm831x_backup.c
#	drivers/power/wm831x_power.c
#	drivers/power/wm8350_power.c
#	drivers/power/wm97xx_battery.c
#	drivers/power/z2_battery.c
#	drivers/staging/nvec/nvec_power.c
#	include/linux/mfd/rt5033.h
#	include/linux/power_supply.h
diff --cc drivers/acpi/ac.c
index 4f4e741d34b2,bbcc2b5a70d4..000000000000
--- a/drivers/acpi/ac.c
+++ b/drivers/acpi/ac.c
@@@ -92,12 -95,14 +92,13 @@@ static struct acpi_driver acpi_ac_drive
  };
  
  struct acpi_ac {
- 	struct power_supply charger;
+ 	struct power_supply *charger;
+ 	struct power_supply_desc charger_desc;
  	struct acpi_device * device;
  	unsigned long long state;
 -	struct notifier_block battery_nb;
  };
  
- #define to_acpi_ac(x) container_of(x, struct acpi_ac, charger)
+ #define to_acpi_ac(x) power_supply_get_drvdata(x)
  
  #ifdef CONFIG_ACPI_PROCFS_POWER
  static const struct file_operations acpi_ac_fops = {
@@@ -318,19 -343,24 +320,38 @@@ static int acpi_ac_add(struct acpi_devi
  	if (result)
  		goto end;
  
++<<<<<<< HEAD
++=======
+ 	psy_cfg.drv_data = ac;
+ 
+ 	ac->charger_desc.name = acpi_device_bid(device);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  #ifdef CONFIG_ACPI_PROCFS_POWER
 -	result = acpi_ac_add_fs(ac);
 +	result = acpi_ac_add_fs(device);
 +#endif
  	if (result)
  		goto end;
++<<<<<<< HEAD
 +	ac->charger.name = acpi_device_bid(device);
 +	ac->charger.type = POWER_SUPPLY_TYPE_MAINS;
 +	ac->charger.properties = ac_props;
 +	ac->charger.num_properties = ARRAY_SIZE(ac_props);
 +	ac->charger.get_property = get_ac_property;
 +	result = power_supply_register(&ac->device->dev, &ac->charger);
 +	if (result)
++=======
+ #endif
+ 	ac->charger_desc.type = POWER_SUPPLY_TYPE_MAINS;
+ 	ac->charger_desc.properties = ac_props;
+ 	ac->charger_desc.num_properties = ARRAY_SIZE(ac_props);
+ 	ac->charger_desc.get_property = get_ac_property;
+ 	ac->charger = power_supply_register(&ac->device->dev,
+ 					    &ac->charger_desc, &psy_cfg);
+ 	if (IS_ERR(ac->charger)) {
+ 		result = PTR_ERR(ac->charger);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto end;
+ 	}
  
  	printk(KERN_INFO PREFIX "%s [%s] (%s)\n",
  	       acpi_device_name(device), acpi_device_bid(device),
@@@ -365,9 -397,11 +386,9 @@@ static int acpi_ac_resume(struct devic
  	if (acpi_ac_get_state(ac))
  		return 0;
  	if (old_state != ac->state)
- 		kobject_uevent(&ac->charger.dev->kobj, KOBJ_CHANGE);
+ 		kobject_uevent(&ac->charger->dev.kobj, KOBJ_CHANGE);
  	return 0;
  }
 -#else
 -#define acpi_ac_resume NULL
  #endif
  
  static int acpi_ac_remove(struct acpi_device *device)
@@@ -380,10 -414,11 +401,16 @@@
  
  	ac = acpi_driver_data(device);
  
++<<<<<<< HEAD
 +	if (ac->charger.dev)
 +		power_supply_unregister(&ac->charger);
++=======
+ 	power_supply_unregister(ac->charger);
+ 	unregister_acpi_notifier(&ac->battery_nb);
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  #ifdef CONFIG_ACPI_PROCFS_POWER
 -	acpi_ac_remove_fs(ac);
 +	acpi_ac_remove_fs(device);
  #endif
  
  	kfree(ac);
diff --cc drivers/acpi/battery.c
index 32ab08a3c680,fdc16ce9d272..000000000000
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@@ -598,14 -621,20 +599,25 @@@ static int sysfs_add_battery(struct acp
  			ARRAY_SIZE(energy_battery_props);
  	}
  
- 	battery->bat.name = acpi_device_bid(battery->device);
- 	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
- 	battery->bat.get_property = acpi_battery_get_property;
+ 	battery->bat_desc.name = acpi_device_bid(battery->device);
+ 	battery->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	battery->bat_desc.get_property = acpi_battery_get_property;
  
++<<<<<<< HEAD
 +	result = power_supply_register(&battery->device->dev, &battery->bat);
 +	if (result)
++=======
+ 	battery->bat = power_supply_register_no_ws(&battery->device->dev,
+ 				&battery->bat_desc, &psy_cfg);
+ 
+ 	if (IS_ERR(battery->bat)) {
+ 		int result = PTR_ERR(battery->bat);
+ 
+ 		battery->bat = NULL;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		return result;
- 	return device_create_file(battery->bat.dev, &alarm_attr);
+ 	}
+ 	return device_create_file(&battery->bat->dev, &alarm_attr);
  }
  
  static void sysfs_remove_battery(struct acpi_battery *battery)
@@@ -1028,7 -1072,15 +1040,19 @@@ static void acpi_battery_notify(struct 
  
  	if (!battery)
  		return;
++<<<<<<< HEAD
 +	old = battery->bat.dev;
++=======
+ 	old = battery->bat;
+ 	/*
+ 	* On Acer Aspire V5-573G notifications are sometimes triggered too
+ 	* early. For example, when AC is unplugged and notification is
+ 	* triggered, battery state is still reported as "Full", and changes to
+ 	* "Discharging" only after short delay, without any notification.
+ 	*/
+ 	if (battery_notification_delay_ms > 0)
+ 		msleep(battery_notification_delay_ms);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	if (event == ACPI_BATTERY_NOTIFY_INFO)
  		acpi_battery_refresh(battery);
  	acpi_battery_update(battery, false);
@@@ -1037,9 -1087,10 +1061,9 @@@
  	acpi_bus_generate_netlink_event(device->pnp.device_class,
  					dev_name(&device->dev), event,
  					acpi_battery_present(battery));
 -	acpi_notifier_call_chain(device, event, acpi_battery_present(battery));
  	/* acpi_battery_update could remove power_supply object */
- 	if (old && battery->bat.dev)
- 		power_supply_changed(&battery->bat);
+ 	if (old && battery->bat)
+ 		power_supply_changed(battery->bat);
  }
  
  static int battery_notify(struct notifier_block *nb,
diff --cc drivers/acpi/sbs.c
index b6241eeb1132,cd827625cf07..000000000000
--- a/drivers/acpi/sbs.c
+++ b/drivers/acpi/sbs.c
@@@ -82,11 -74,9 +82,12 @@@ static const struct acpi_device_id sbs_
  MODULE_DEVICE_TABLE(acpi, sbs_device_ids);
  
  struct acpi_battery {
- 	struct power_supply bat;
+ 	struct power_supply *bat;
+ 	struct power_supply_desc bat_desc;
  	struct acpi_sbs *sbs;
 +#ifdef CONFIG_ACPI_PROCFS_POWER
 +	struct proc_dir_entry *proc_entry;
 +#endif
  	unsigned long update_time;
  	char name[8];
  	char manufacturer_name[ACPI_SBS_BLOCK_MAX];
@@@ -126,9 -113,10 +127,9 @@@ struct acpi_sbs 
  	u8 batteries_supported:4;
  	u8 manager_present:1;
  	u8 charger_present:1;
 -	u8 charger_exists:1;
  };
  
- #define to_acpi_sbs(x) container_of(x, struct acpi_sbs, charger)
+ #define to_acpi_sbs(x) power_supply_get_drvdata(x)
  
  static int acpi_sbs_remove(struct acpi_device *device);
  static int acpi_battery_get_state(struct acpi_battery *battery);
@@@ -781,28 -537,27 +790,46 @@@ static int acpi_battery_add(struct acpi
  		return result;
  
  	sprintf(battery->name, ACPI_BATTERY_DIR_NAME, id);
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI_PROCFS_POWER
 +	acpi_sbs_add_fs(&battery->proc_entry, acpi_battery_dir,
 +			battery->name, &acpi_battery_info_fops,
 +			&acpi_battery_state_fops, &acpi_battery_alarm_fops,
 +			battery);
 +#endif
 +	battery->bat.name = battery->name;
 +	battery->bat.type = POWER_SUPPLY_TYPE_BATTERY;
++=======
+ 	battery->bat_desc.name = battery->name;
+ 	battery->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	if (!acpi_battery_mode(battery)) {
- 		battery->bat.properties = sbs_charge_battery_props;
- 		battery->bat.num_properties =
+ 		battery->bat_desc.properties = sbs_charge_battery_props;
+ 		battery->bat_desc.num_properties =
  		    ARRAY_SIZE(sbs_charge_battery_props);
  	} else {
- 		battery->bat.properties = sbs_energy_battery_props;
- 		battery->bat.num_properties =
+ 		battery->bat_desc.properties = sbs_energy_battery_props;
+ 		battery->bat_desc.num_properties =
  		    ARRAY_SIZE(sbs_energy_battery_props);
  	}
++<<<<<<< HEAD
 +	battery->bat.get_property = acpi_sbs_battery_get_property;
 +	result = power_supply_register(&sbs->device->dev, &battery->bat);
 +	if (result)
 +		goto end;
 +	result = device_create_file(battery->bat.dev, &alarm_attr);
++=======
+ 	battery->bat_desc.get_property = acpi_sbs_battery_get_property;
+ 	battery->bat = power_supply_register(&sbs->device->dev,
+ 					&battery->bat_desc, &psy_cfg);
+ 	if (IS_ERR(battery->bat)) {
+ 		result = PTR_ERR(battery->bat);
+ 		battery->bat = NULL;
+ 		goto end;
+ 	}
+ 
+ 	result = device_create_file(&battery->bat->dev, &alarm_attr);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	if (result)
  		goto end;
  	battery->have_sysfs_alarm = 1;
@@@ -817,15 -572,11 +844,15 @@@ static void acpi_battery_remove(struct 
  {
  	struct acpi_battery *battery = &sbs->battery[id];
  
- 	if (battery->bat.dev) {
+ 	if (battery->bat) {
  		if (battery->have_sysfs_alarm)
- 			device_remove_file(battery->bat.dev, &alarm_attr);
- 		power_supply_unregister(&battery->bat);
+ 			device_remove_file(&battery->bat->dev, &alarm_attr);
+ 		power_supply_unregister(battery->bat);
  	}
 +#ifdef CONFIG_ACPI_PROCFS_POWER
 +	proc_remove(battery->proc_entry);
 +	battery->proc_entry = NULL;
 +#endif
  }
  
  static int acpi_charger_add(struct acpi_sbs *sbs)
@@@ -835,19 -587,14 +863,30 @@@
  	result = acpi_ac_get_present(sbs);
  	if (result)
  		goto end;
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI_PROCFS_POWER
 +	result = acpi_sbs_add_fs(&sbs->charger_entry, acpi_ac_dir,
 +				 ACPI_AC_DIR_NAME, NULL,
 +				 &acpi_ac_state_fops, NULL, sbs);
 +	if (result)
 +		goto end;
 +#endif
 +	sbs->charger.name = "sbs-charger";
 +	sbs->charger.type = POWER_SUPPLY_TYPE_MAINS;
 +	sbs->charger.properties = sbs_ac_props;
 +	sbs->charger.num_properties = ARRAY_SIZE(sbs_ac_props);
 +	sbs->charger.get_property = sbs_get_ac_property;
 +	power_supply_register(&sbs->device->dev, &sbs->charger);
++=======
+ 
+ 	sbs->charger_exists = 1;
+ 	sbs->charger = power_supply_register(&sbs->device->dev,
+ 					&acpi_sbs_charger_desc, &psy_cfg);
+ 	if (IS_ERR(sbs->charger)) {
+ 		result = PTR_ERR(sbs->charger);
+ 		sbs->charger = NULL;
+ 	}
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	printk(KERN_INFO PREFIX "%s [%s]: AC Adapter [%s] (%s)\n",
  	       ACPI_SBS_DEVICE_NAME, acpi_device_bid(sbs->device),
  	       ACPI_AC_DIR_NAME, sbs->charger_present ? "on-line" : "off-line");
@@@ -857,12 -604,8 +896,17 @@@
  
  static void acpi_charger_remove(struct acpi_sbs *sbs)
  {
++<<<<<<< HEAD
 +	if (sbs->charger.dev)
 +		power_supply_unregister(&sbs->charger);
 +#ifdef CONFIG_ACPI_PROCFS_POWER
 +	proc_remove(sbs->charger_entry);
 +	sbs->charger_entry = NULL;
 +#endif
++=======
+ 	if (sbs->charger)
+ 		power_supply_unregister(sbs->charger);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  }
  
  static void acpi_sbs_callback(void *context)
@@@ -872,15 -615,13 +916,23 @@@
  	struct acpi_battery *bat;
  	u8 saved_charger_state = sbs->charger_present;
  	u8 saved_battery_state;
++<<<<<<< HEAD
 +	acpi_ac_get_present(sbs);
 +	if (sbs->charger_present != saved_charger_state) {
 +#ifdef CONFIG_ACPI_PROC_EVENT
 +		acpi_bus_generate_proc_event4(ACPI_AC_CLASS, ACPI_AC_DIR_NAME,
 +					      ACPI_SBS_NOTIFY_STATUS,
 +					      sbs->charger_present);
 +#endif
 +		kobject_uevent(&sbs->charger.dev->kobj, KOBJ_CHANGE);
++=======
+ 
+ 	if (sbs->charger_exists) {
+ 		acpi_ac_get_present(sbs);
+ 		if (sbs->charger_present != saved_charger_state)
+ 			kobject_uevent(&sbs->charger->dev.kobj, KOBJ_CHANGE);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
 -
  	if (sbs->manager_present) {
  		for (id = 0; id < MAX_SBS_BAT; ++id) {
  			if (!(sbs->batteries_supported & (1 << id)))
@@@ -890,13 -631,7 +942,17 @@@
  			acpi_battery_read(bat);
  			if (saved_battery_state == bat->present)
  				continue;
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI_PROC_EVENT
 +			acpi_bus_generate_proc_event4(ACPI_BATTERY_CLASS,
 +						      bat->name,
 +						      ACPI_SBS_NOTIFY_STATUS,
 +						      bat->present);
 +#endif
 +			kobject_uevent(&bat->bat.dev->kobj, KOBJ_CHANGE);
++=======
+ 			kobject_uevent(&bat->bat->dev.kobj, KOBJ_CHANGE);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		}
  	}
  }
diff --cc drivers/hid/hid-input.c
index e2633c085b36,5d5a8c42645f..000000000000
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@@ -433,14 -445,16 +439,24 @@@ static bool hidinput_setup_battery(stru
  	dev->battery_report_type = report_type;
  	dev->battery_report_id = field->report->id;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&dev->dev, battery);
 +	if (ret != 0) {
 +		hid_warn(dev, "can't register power supply: %d\n", ret);
 +		kfree(battery->name);
 +		battery->name = NULL;
++=======
+ 	dev->battery = power_supply_register(&dev->dev, psy_desc, &psy_cfg);
+ 	if (IS_ERR(dev->battery)) {
+ 		hid_warn(dev, "can't register power supply: %ld\n",
+ 				PTR_ERR(dev->battery));
+ 		kfree(psy_desc->name);
+ 		kfree(psy_desc);
+ 		dev->battery = NULL;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
  
- 	power_supply_powers(battery, &dev->dev);
+ 	power_supply_powers(dev->battery, &dev->dev);
  
  out:
  	return true;
diff --cc drivers/hid/hid-sony.c
index 6b28b4814cad,65007ec2d96e..000000000000
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@@ -23,43 -39,851 +23,66 @@@
  
  #include "hid-ids.h"
  
 -#define VAIO_RDESC_CONSTANT       BIT(0)
 -#define SIXAXIS_CONTROLLER_USB    BIT(1)
 -#define SIXAXIS_CONTROLLER_BT     BIT(2)
 -#define BUZZ_CONTROLLER           BIT(3)
 -#define PS3REMOTE                 BIT(4)
 -#define DUALSHOCK4_CONTROLLER_USB BIT(5)
 -#define DUALSHOCK4_CONTROLLER_BT  BIT(6)
 -
 -#define SIXAXIS_CONTROLLER (SIXAXIS_CONTROLLER_USB | SIXAXIS_CONTROLLER_BT)
 -#define DUALSHOCK4_CONTROLLER (DUALSHOCK4_CONTROLLER_USB |\
 -				DUALSHOCK4_CONTROLLER_BT)
 -#define SONY_LED_SUPPORT (SIXAXIS_CONTROLLER | BUZZ_CONTROLLER |\
 -				DUALSHOCK4_CONTROLLER)
 -#define SONY_BATTERY_SUPPORT (SIXAXIS_CONTROLLER | DUALSHOCK4_CONTROLLER)
 -#define SONY_FF_SUPPORT (SIXAXIS_CONTROLLER | DUALSHOCK4_CONTROLLER)
 -
 -#define MAX_LEDS 4
 -
 -static __u8 sixaxis_rdesc[] = {
 -	0x05, 0x01,         /*  Usage Page (Desktop),               */
 -	0x09, 0x04,         /*  Usage (Joystik),                    */
 -	0xA1, 0x01,         /*  Collection (Application),           */
 -	0xA1, 0x02,         /*      Collection (Logical),           */
 -	0x85, 0x01,         /*          Report ID (1),              */
 -	0x75, 0x08,         /*          Report Size (8),            */
 -	0x95, 0x01,         /*          Report Count (1),           */
 -	0x15, 0x00,         /*          Logical Minimum (0),        */
 -	0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
 -	0x81, 0x03,         /*          Input (Constant, Variable), */
 -	0x75, 0x01,         /*          Report Size (1),            */
 -	0x95, 0x13,         /*          Report Count (19),          */
 -	0x15, 0x00,         /*          Logical Minimum (0),        */
 -	0x25, 0x01,         /*          Logical Maximum (1),        */
 -	0x35, 0x00,         /*          Physical Minimum (0),       */
 -	0x45, 0x01,         /*          Physical Maximum (1),       */
 -	0x05, 0x09,         /*          Usage Page (Button),        */
 -	0x19, 0x01,         /*          Usage Minimum (01h),        */
 -	0x29, 0x13,         /*          Usage Maximum (13h),        */
 -	0x81, 0x02,         /*          Input (Variable),           */
 -	0x75, 0x01,         /*          Report Size (1),            */
 -	0x95, 0x0D,         /*          Report Count (13),          */
 -	0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
 -	0x81, 0x03,         /*          Input (Constant, Variable), */
 -	0x15, 0x00,         /*          Logical Minimum (0),        */
 -	0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
 -	0x05, 0x01,         /*          Usage Page (Desktop),       */
 -	0x09, 0x01,         /*          Usage (Pointer),            */
 -	0xA1, 0x00,         /*          Collection (Physical),      */
 -	0x75, 0x08,         /*              Report Size (8),        */
 -	0x95, 0x04,         /*              Report Count (4),       */
 -	0x35, 0x00,         /*              Physical Minimum (0),   */
 -	0x46, 0xFF, 0x00,   /*              Physical Maximum (255), */
 -	0x09, 0x30,         /*              Usage (X),              */
 -	0x09, 0x31,         /*              Usage (Y),              */
 -	0x09, 0x32,         /*              Usage (Z),              */
 -	0x09, 0x35,         /*              Usage (Rz),             */
 -	0x81, 0x02,         /*              Input (Variable),       */
 -	0xC0,               /*          End Collection,             */
 -	0x05, 0x01,         /*          Usage Page (Desktop),       */
 -	0x95, 0x13,         /*          Report Count (19),          */
 -	0x09, 0x01,         /*          Usage (Pointer),            */
 -	0x81, 0x02,         /*          Input (Variable),           */
 -	0x95, 0x0C,         /*          Report Count (12),          */
 -	0x81, 0x01,         /*          Input (Constant),           */
 -	0x75, 0x10,         /*          Report Size (16),           */
 -	0x95, 0x04,         /*          Report Count (4),           */
 -	0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */
 -	0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */
 -	0x09, 0x01,         /*          Usage (Pointer),            */
 -	0x81, 0x02,         /*          Input (Variable),           */
 -	0xC0,               /*      End Collection,                 */
 -	0xA1, 0x02,         /*      Collection (Logical),           */
 -	0x85, 0x02,         /*          Report ID (2),              */
 -	0x75, 0x08,         /*          Report Size (8),            */
 -	0x95, 0x30,         /*          Report Count (48),          */
 -	0x09, 0x01,         /*          Usage (Pointer),            */
 -	0xB1, 0x02,         /*          Feature (Variable),         */
 -	0xC0,               /*      End Collection,                 */
 -	0xA1, 0x02,         /*      Collection (Logical),           */
 -	0x85, 0xEE,         /*          Report ID (238),            */
 -	0x75, 0x08,         /*          Report Size (8),            */
 -	0x95, 0x30,         /*          Report Count (48),          */
 -	0x09, 0x01,         /*          Usage (Pointer),            */
 -	0xB1, 0x02,         /*          Feature (Variable),         */
 -	0xC0,               /*      End Collection,                 */
 -	0xA1, 0x02,         /*      Collection (Logical),           */
 -	0x85, 0xEF,         /*          Report ID (239),            */
 -	0x75, 0x08,         /*          Report Size (8),            */
 -	0x95, 0x30,         /*          Report Count (48),          */
 -	0x09, 0x01,         /*          Usage (Pointer),            */
 -	0xB1, 0x02,         /*          Feature (Variable),         */
 -	0xC0,               /*      End Collection,                 */
 -	0xC0                /*  End Collection                      */
 -};
 -
 -/*
 - * The default descriptor doesn't provide mapping for the accelerometers
 - * or orientation sensors.  This fixed descriptor maps the accelerometers
 - * to usage values 0x40, 0x41 and 0x42 and maps the orientation sensors
 - * to usage values 0x43, 0x44 and 0x45.
 - */
 -static u8 dualshock4_usb_rdesc[] = {
 -	0x05, 0x01,         /*  Usage Page (Desktop),               */
 -	0x09, 0x05,         /*  Usage (Gamepad),                    */
 -	0xA1, 0x01,         /*  Collection (Application),           */
 -	0x85, 0x01,         /*      Report ID (1),                  */
 -	0x09, 0x30,         /*      Usage (X),                      */
 -	0x09, 0x31,         /*      Usage (Y),                      */
 -	0x09, 0x32,         /*      Usage (Z),                      */
 -	0x09, 0x35,         /*      Usage (Rz),                     */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x26, 0xFF, 0x00,   /*      Logical Maximum (255),          */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x04,         /*      Report Count (4),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x39,         /*      Usage (Hat Switch),             */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x25, 0x07,         /*      Logical Maximum (7),            */
 -	0x35, 0x00,         /*      Physical Minimum (0),           */
 -	0x46, 0x3B, 0x01,   /*      Physical Maximum (315),         */
 -	0x65, 0x14,         /*      Unit (Degrees),                 */
 -	0x75, 0x04,         /*      Report Size (4),                */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0x81, 0x42,         /*      Input (Variable, Null State),   */
 -	0x65, 0x00,         /*      Unit,                           */
 -	0x05, 0x09,         /*      Usage Page (Button),            */
 -	0x19, 0x01,         /*      Usage Minimum (01h),            */
 -	0x29, 0x0E,         /*      Usage Maximum (0Eh),            */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x25, 0x01,         /*      Logical Maximum (1),            */
 -	0x75, 0x01,         /*      Report Size (1),                */
 -	0x95, 0x0E,         /*      Report Count (14),              */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x06, 0x00, 0xFF,   /*      Usage Page (FF00h),             */
 -	0x09, 0x20,         /*      Usage (20h),                    */
 -	0x75, 0x06,         /*      Report Size (6),                */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x25, 0x3F,         /*      Logical Maximum (63),           */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x05, 0x01,         /*      Usage Page (Desktop),           */
 -	0x09, 0x33,         /*      Usage (Rx),                     */
 -	0x09, 0x34,         /*      Usage (Ry),                     */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x26, 0xFF, 0x00,   /*      Logical Maximum (255),          */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x02,         /*      Report Count (2),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x06, 0x00, 0xFF,   /*      Usage Page (FF00h),             */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x05, 0x01,         /*      Usage Page (Desktop),           */
 -	0x19, 0x40,         /*      Usage Minimum (40h),            */
 -	0x29, 0x42,         /*      Usage Maximum (42h),            */
 -	0x16, 0x00, 0x80,   /*      Logical Minimum (-32768),       */
 -	0x26, 0x00, 0x7F,   /*      Logical Maximum (32767),        */
 -	0x75, 0x10,         /*      Report Size (16),               */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x19, 0x43,         /*      Usage Minimum (43h),            */
 -	0x29, 0x45,         /*      Usage Maximum (45h),            */
 -	0x16, 0x00, 0xE0,   /*      Logical Minimum (-8192),        */
 -	0x26, 0xFF, 0x1F,   /*      Logical Maximum (8191),         */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x06, 0x00, 0xFF,   /*      Usage Page (FF00h),             */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x26, 0xFF, 0x00,   /*      Logical Maximum (255),          */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x27,         /*      Report Count (39),              */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x85, 0x05,         /*      Report ID (5),                  */
 -	0x09, 0x22,         /*      Usage (22h),                    */
 -	0x95, 0x1F,         /*      Report Count (31),              */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x04,         /*      Report ID (4),                  */
 -	0x09, 0x23,         /*      Usage (23h),                    */
 -	0x95, 0x24,         /*      Report Count (36),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x02,         /*      Report ID (2),                  */
 -	0x09, 0x24,         /*      Usage (24h),                    */
 -	0x95, 0x24,         /*      Report Count (36),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x08,         /*      Report ID (8),                  */
 -	0x09, 0x25,         /*      Usage (25h),                    */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x10,         /*      Report ID (16),                 */
 -	0x09, 0x26,         /*      Usage (26h),                    */
 -	0x95, 0x04,         /*      Report Count (4),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x11,         /*      Report ID (17),                 */
 -	0x09, 0x27,         /*      Usage (27h),                    */
 -	0x95, 0x02,         /*      Report Count (2),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x12,         /*      Report ID (18),                 */
 -	0x06, 0x02, 0xFF,   /*      Usage Page (FF02h),             */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x95, 0x0F,         /*      Report Count (15),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x13,         /*      Report ID (19),                 */
 -	0x09, 0x22,         /*      Usage (22h),                    */
 -	0x95, 0x16,         /*      Report Count (22),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x14,         /*      Report ID (20),                 */
 -	0x06, 0x05, 0xFF,   /*      Usage Page (FF05h),             */
 -	0x09, 0x20,         /*      Usage (20h),                    */
 -	0x95, 0x10,         /*      Report Count (16),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x15,         /*      Report ID (21),                 */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x95, 0x2C,         /*      Report Count (44),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x06, 0x80, 0xFF,   /*      Usage Page (FF80h),             */
 -	0x85, 0x80,         /*      Report ID (128),                */
 -	0x09, 0x20,         /*      Usage (20h),                    */
 -	0x95, 0x06,         /*      Report Count (6),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x81,         /*      Report ID (129),                */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x95, 0x06,         /*      Report Count (6),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x82,         /*      Report ID (130),                */
 -	0x09, 0x22,         /*      Usage (22h),                    */
 -	0x95, 0x05,         /*      Report Count (5),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x83,         /*      Report ID (131),                */
 -	0x09, 0x23,         /*      Usage (23h),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x84,         /*      Report ID (132),                */
 -	0x09, 0x24,         /*      Usage (24h),                    */
 -	0x95, 0x04,         /*      Report Count (4),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x85,         /*      Report ID (133),                */
 -	0x09, 0x25,         /*      Usage (25h),                    */
 -	0x95, 0x06,         /*      Report Count (6),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x86,         /*      Report ID (134),                */
 -	0x09, 0x26,         /*      Usage (26h),                    */
 -	0x95, 0x06,         /*      Report Count (6),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x87,         /*      Report ID (135),                */
 -	0x09, 0x27,         /*      Usage (27h),                    */
 -	0x95, 0x23,         /*      Report Count (35),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x88,         /*      Report ID (136),                */
 -	0x09, 0x28,         /*      Usage (28h),                    */
 -	0x95, 0x22,         /*      Report Count (34),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x89,         /*      Report ID (137),                */
 -	0x09, 0x29,         /*      Usage (29h),                    */
 -	0x95, 0x02,         /*      Report Count (2),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x90,         /*      Report ID (144),                */
 -	0x09, 0x30,         /*      Usage (30h),                    */
 -	0x95, 0x05,         /*      Report Count (5),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x91,         /*      Report ID (145),                */
 -	0x09, 0x31,         /*      Usage (31h),                    */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x92,         /*      Report ID (146),                */
 -	0x09, 0x32,         /*      Usage (32h),                    */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x93,         /*      Report ID (147),                */
 -	0x09, 0x33,         /*      Usage (33h),                    */
 -	0x95, 0x0C,         /*      Report Count (12),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA0,         /*      Report ID (160),                */
 -	0x09, 0x40,         /*      Usage (40h),                    */
 -	0x95, 0x06,         /*      Report Count (6),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA1,         /*      Report ID (161),                */
 -	0x09, 0x41,         /*      Usage (41h),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA2,         /*      Report ID (162),                */
 -	0x09, 0x42,         /*      Usage (42h),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA3,         /*      Report ID (163),                */
 -	0x09, 0x43,         /*      Usage (43h),                    */
 -	0x95, 0x30,         /*      Report Count (48),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA4,         /*      Report ID (164),                */
 -	0x09, 0x44,         /*      Usage (44h),                    */
 -	0x95, 0x0D,         /*      Report Count (13),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA5,         /*      Report ID (165),                */
 -	0x09, 0x45,         /*      Usage (45h),                    */
 -	0x95, 0x15,         /*      Report Count (21),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA6,         /*      Report ID (166),                */
 -	0x09, 0x46,         /*      Usage (46h),                    */
 -	0x95, 0x15,         /*      Report Count (21),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xF0,         /*      Report ID (240),                */
 -	0x09, 0x47,         /*      Usage (47h),                    */
 -	0x95, 0x3F,         /*      Report Count (63),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xF1,         /*      Report ID (241),                */
 -	0x09, 0x48,         /*      Usage (48h),                    */
 -	0x95, 0x3F,         /*      Report Count (63),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xF2,         /*      Report ID (242),                */
 -	0x09, 0x49,         /*      Usage (49h),                    */
 -	0x95, 0x0F,         /*      Report Count (15),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA7,         /*      Report ID (167),                */
 -	0x09, 0x4A,         /*      Usage (4Ah),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA8,         /*      Report ID (168),                */
 -	0x09, 0x4B,         /*      Usage (4Bh),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA9,         /*      Report ID (169),                */
 -	0x09, 0x4C,         /*      Usage (4Ch),                    */
 -	0x95, 0x08,         /*      Report Count (8),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xAA,         /*      Report ID (170),                */
 -	0x09, 0x4E,         /*      Usage (4Eh),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xAB,         /*      Report ID (171),                */
 -	0x09, 0x4F,         /*      Usage (4Fh),                    */
 -	0x95, 0x39,         /*      Report Count (57),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xAC,         /*      Report ID (172),                */
 -	0x09, 0x50,         /*      Usage (50h),                    */
 -	0x95, 0x39,         /*      Report Count (57),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xAD,         /*      Report ID (173),                */
 -	0x09, 0x51,         /*      Usage (51h),                    */
 -	0x95, 0x0B,         /*      Report Count (11),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xAE,         /*      Report ID (174),                */
 -	0x09, 0x52,         /*      Usage (52h),                    */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xAF,         /*      Report ID (175),                */
 -	0x09, 0x53,         /*      Usage (53h),                    */
 -	0x95, 0x02,         /*      Report Count (2),               */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xB0,         /*      Report ID (176),                */
 -	0x09, 0x54,         /*      Usage (54h),                    */
 -	0x95, 0x3F,         /*      Report Count (63),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0xC0                /*  End Collection                      */
 -};
 -
 -/*
 - * The default behavior of the Dualshock 4 is to send reports using report
 - * type 1 when running over Bluetooth. However, when feature report 2 is
 - * requested during the controller initialization it starts sending input
 - * reports in report 17.  Since report 17 is undefined in the default HID
 - * descriptor the button and axis definitions must be moved to report 17 or
 - * the HID layer won't process the received input.
 - */
 -static u8 dualshock4_bt_rdesc[] = {
 -	0x05, 0x01,         /*  Usage Page (Desktop),               */
 -	0x09, 0x05,         /*  Usage (Gamepad),                    */
 -	0xA1, 0x01,         /*  Collection (Application),           */
 -	0x85, 0x01,         /*      Report ID (1),                  */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x0A,         /*      Report Count (9),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x06, 0x04, 0xFF,   /*      Usage Page (FF04h),             */
 -	0x85, 0x02,         /*      Report ID (2),                  */
 -	0x09, 0x24,         /*      Usage (24h),                    */
 -	0x95, 0x24,         /*      Report Count (36),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA3,         /*      Report ID (163),                */
 -	0x09, 0x25,         /*      Usage (25h),                    */
 -	0x95, 0x30,         /*      Report Count (48),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x05,         /*      Report ID (5),                  */
 -	0x09, 0x26,         /*      Usage (26h),                    */
 -	0x95, 0x28,         /*      Report Count (40),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x06,         /*      Report ID (6),                  */
 -	0x09, 0x27,         /*      Usage (27h),                    */
 -	0x95, 0x34,         /*      Report Count (52),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x07,         /*      Report ID (7),                  */
 -	0x09, 0x28,         /*      Usage (28h),                    */
 -	0x95, 0x30,         /*      Report Count (48),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x08,         /*      Report ID (8),                  */
 -	0x09, 0x29,         /*      Usage (29h),                    */
 -	0x95, 0x2F,         /*      Report Count (47),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x06, 0x03, 0xFF,   /*      Usage Page (FF03h),             */
 -	0x85, 0x03,         /*      Report ID (3),                  */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x95, 0x26,         /*      Report Count (38),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x04,         /*      Report ID (4),                  */
 -	0x09, 0x22,         /*      Usage (22h),                    */
 -	0x95, 0x2E,         /*      Report Count (46),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xF0,         /*      Report ID (240),                */
 -	0x09, 0x47,         /*      Usage (47h),                    */
 -	0x95, 0x3F,         /*      Report Count (63),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xF1,         /*      Report ID (241),                */
 -	0x09, 0x48,         /*      Usage (48h),                    */
 -	0x95, 0x3F,         /*      Report Count (63),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xF2,         /*      Report ID (242),                */
 -	0x09, 0x49,         /*      Usage (49h),                    */
 -	0x95, 0x0F,         /*      Report Count (15),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x11,         /*      Report ID (17),                 */
 -	0x06, 0x00, 0xFF,   /*      Usage Page (FF00h),             */
 -	0x09, 0x20,         /*      Usage (20h),                    */
 -	0x95, 0x02,         /*      Report Count (2),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x05, 0x01,         /*      Usage Page (Desktop),           */
 -	0x09, 0x30,         /*      Usage (X),                      */
 -	0x09, 0x31,         /*      Usage (Y),                      */
 -	0x09, 0x32,         /*      Usage (Z),                      */
 -	0x09, 0x35,         /*      Usage (Rz),                     */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x26, 0xFF, 0x00,   /*      Logical Maximum (255),          */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x04,         /*      Report Count (4),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x39,         /*      Usage (Hat Switch),             */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x25, 0x07,         /*      Logical Maximum (7),            */
 -	0x75, 0x04,         /*      Report Size (4),                */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0x81, 0x42,         /*      Input (Variable, Null State),   */
 -	0x05, 0x09,         /*      Usage Page (Button),            */
 -	0x19, 0x01,         /*      Usage Minimum (01h),            */
 -	0x29, 0x0E,         /*      Usage Maximum (0Eh),            */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x25, 0x01,         /*      Logical Maximum (1),            */
 -	0x75, 0x01,         /*      Report Size (1),                */
 -	0x95, 0x0E,         /*      Report Count (14),              */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x75, 0x06,         /*      Report Size (6),                */
 -	0x95, 0x01,         /*      Report Count (1),               */
 -	0x81, 0x01,         /*      Input (Constant),               */
 -	0x05, 0x01,         /*      Usage Page (Desktop),           */
 -	0x09, 0x33,         /*      Usage (Rx),                     */
 -	0x09, 0x34,         /*      Usage (Ry),                     */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x26, 0xFF, 0x00,   /*      Logical Maximum (255),          */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x02,         /*      Report Count (2),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x06, 0x00, 0xFF,   /*      Usage Page (FF00h),             */
 -	0x09, 0x20,         /*      Usage (20h),                    */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x05, 0x01,         /*      Usage Page (Desktop),           */
 -	0x19, 0x40,         /*      Usage Minimum (40h),            */
 -	0x29, 0x42,         /*      Usage Maximum (42h),            */
 -	0x16, 0x00, 0x80,   /*      Logical Minimum (-32768),       */
 -	0x26, 0x00, 0x7F,   /*      Logical Maximum (32767),        */
 -	0x75, 0x10,         /*      Report Size (16),               */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x19, 0x43,         /*      Usage Minimum (43h),            */
 -	0x29, 0x45,         /*      Usage Maximum (45h),            */
 -	0x16, 0x00, 0xE0,   /*      Logical Minimum (-8192),        */
 -	0x26, 0xFF, 0x1F,   /*      Logical Maximum (8191),         */
 -	0x95, 0x03,         /*      Report Count (3),               */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x06, 0x00, 0xFF,   /*      Usage Page (FF00h),             */
 -	0x09, 0x20,         /*      Usage (20h),                    */
 -	0x15, 0x00,         /*      Logical Minimum (0),            */
 -	0x26, 0xFF, 0x00,   /*      Logical Maximum (255),          */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x31,         /*      Report Count (51),              */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x21,         /*      Usage (21h),                    */
 -	0x75, 0x08,         /*      Report Size (8),                */
 -	0x95, 0x4D,         /*      Report Count (77),              */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x12,         /*      Report ID (18),                 */
 -	0x09, 0x22,         /*      Usage (22h),                    */
 -	0x95, 0x8D,         /*      Report Count (141),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x23,         /*      Usage (23h),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x13,         /*      Report ID (19),                 */
 -	0x09, 0x24,         /*      Usage (24h),                    */
 -	0x95, 0xCD,         /*      Report Count (205),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x25,         /*      Usage (25h),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x14,         /*      Report ID (20),                 */
 -	0x09, 0x26,         /*      Usage (26h),                    */
 -	0x96, 0x0D, 0x01,   /*      Report Count (269),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x27,         /*      Usage (27h),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x15,         /*      Report ID (21),                 */
 -	0x09, 0x28,         /*      Usage (28h),                    */
 -	0x96, 0x4D, 0x01,   /*      Report Count (333),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x29,         /*      Usage (29h),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x16,         /*      Report ID (22),                 */
 -	0x09, 0x2A,         /*      Usage (2Ah),                    */
 -	0x96, 0x8D, 0x01,   /*      Report Count (397),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x2B,         /*      Usage (2Bh),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x17,         /*      Report ID (23),                 */
 -	0x09, 0x2C,         /*      Usage (2Ch),                    */
 -	0x96, 0xCD, 0x01,   /*      Report Count (461),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x2D,         /*      Usage (2Dh),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x18,         /*      Report ID (24),                 */
 -	0x09, 0x2E,         /*      Usage (2Eh),                    */
 -	0x96, 0x0D, 0x02,   /*      Report Count (525),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x2F,         /*      Usage (2Fh),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x85, 0x19,         /*      Report ID (25),                 */
 -	0x09, 0x30,         /*      Usage (30h),                    */
 -	0x96, 0x22, 0x02,   /*      Report Count (546),             */
 -	0x81, 0x02,         /*      Input (Variable),               */
 -	0x09, 0x31,         /*      Usage (31h),                    */
 -	0x91, 0x02,         /*      Output (Variable),              */
 -	0x06, 0x80, 0xFF,   /*      Usage Page (FF80h),             */
 -	0x85, 0x82,         /*      Report ID (130),                */
 -	0x09, 0x22,         /*      Usage (22h),                    */
 -	0x95, 0x3F,         /*      Report Count (63),              */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x83,         /*      Report ID (131),                */
 -	0x09, 0x23,         /*      Usage (23h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x84,         /*      Report ID (132),                */
 -	0x09, 0x24,         /*      Usage (24h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x90,         /*      Report ID (144),                */
 -	0x09, 0x30,         /*      Usage (30h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x91,         /*      Report ID (145),                */
 -	0x09, 0x31,         /*      Usage (31h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x92,         /*      Report ID (146),                */
 -	0x09, 0x32,         /*      Usage (32h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0x93,         /*      Report ID (147),                */
 -	0x09, 0x33,         /*      Usage (33h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA0,         /*      Report ID (160),                */
 -	0x09, 0x40,         /*      Usage (40h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0x85, 0xA4,         /*      Report ID (164),                */
 -	0x09, 0x44,         /*      Usage (44h),                    */
 -	0xB1, 0x02,         /*      Feature (Variable),             */
 -	0xC0                /*  End Collection                      */
 -};
 -
 -static __u8 ps3remote_rdesc[] = {
 -	0x05, 0x01,          /* GUsagePage Generic Desktop */
 -	0x09, 0x05,          /* LUsage 0x05 [Game Pad] */
 -	0xA1, 0x01,          /* MCollection Application (mouse, keyboard) */
 -
 -	 /* Use collection 1 for joypad buttons */
 -	 0xA1, 0x02,         /* MCollection Logical (interrelated data) */
 -
 -	  /* Ignore the 1st byte, maybe it is used for a controller
 -	   * number but it's not needed for correct operation */
 -	  0x75, 0x08,        /* GReportSize 0x08 [8] */
 -	  0x95, 0x01,        /* GReportCount 0x01 [1] */
 -	  0x81, 0x01,        /* MInput 0x01 (Const[0] Arr[1] Abs[2]) */
 -
 -	  /* Bytes from 2nd to 4th are a bitmap for joypad buttons, for these
 -	   * buttons multiple keypresses are allowed */
 -	  0x05, 0x09,        /* GUsagePage Button */
 -	  0x19, 0x01,        /* LUsageMinimum 0x01 [Button 1 (primary/trigger)] */
 -	  0x29, 0x18,        /* LUsageMaximum 0x18 [Button 24] */
 -	  0x14,              /* GLogicalMinimum [0] */
 -	  0x25, 0x01,        /* GLogicalMaximum 0x01 [1] */
 -	  0x75, 0x01,        /* GReportSize 0x01 [1] */
 -	  0x95, 0x18,        /* GReportCount 0x18 [24] */
 -	  0x81, 0x02,        /* MInput 0x02 (Data[0] Var[1] Abs[2]) */
 -
 -	  0xC0,              /* MEndCollection */
 -
 -	 /* Use collection 2 for remote control buttons */
 -	 0xA1, 0x02,         /* MCollection Logical (interrelated data) */
 -
 -	  /* 5th byte is used for remote control buttons */
 -	  0x05, 0x09,        /* GUsagePage Button */
 -	  0x18,              /* LUsageMinimum [No button pressed] */
 -	  0x29, 0xFE,        /* LUsageMaximum 0xFE [Button 254] */
 -	  0x14,              /* GLogicalMinimum [0] */
 -	  0x26, 0xFE, 0x00,  /* GLogicalMaximum 0x00FE [254] */
 -	  0x75, 0x08,        /* GReportSize 0x08 [8] */
 -	  0x95, 0x01,        /* GReportCount 0x01 [1] */
 -	  0x80,              /* MInput  */
 -
 -	  /* Ignore bytes from 6th to 11th, 6th to 10th are always constant at
 -	   * 0xff and 11th is for press indication */
 -	  0x75, 0x08,        /* GReportSize 0x08 [8] */
 -	  0x95, 0x06,        /* GReportCount 0x06 [6] */
 -	  0x81, 0x01,        /* MInput 0x01 (Const[0] Arr[1] Abs[2]) */
 -
 -	  /* 12th byte is for battery strength */
 -	  0x05, 0x06,        /* GUsagePage Generic Device Controls */
 -	  0x09, 0x20,        /* LUsage 0x20 [Battery Strength] */
 -	  0x14,              /* GLogicalMinimum [0] */
 -	  0x25, 0x05,        /* GLogicalMaximum 0x05 [5] */
 -	  0x75, 0x08,        /* GReportSize 0x08 [8] */
 -	  0x95, 0x01,        /* GReportCount 0x01 [1] */
 -	  0x81, 0x02,        /* MInput 0x02 (Data[0] Var[1] Abs[2]) */
 -
 -	  0xC0,              /* MEndCollection */
 -
 -	 0xC0                /* MEndCollection [Game Pad] */
 -};
 -
 -static const unsigned int ps3remote_keymap_joypad_buttons[] = {
 -	[0x01] = KEY_SELECT,
 -	[0x02] = BTN_THUMBL,		/* L3 */
 -	[0x03] = BTN_THUMBR,		/* R3 */
 -	[0x04] = BTN_START,
 -	[0x05] = KEY_UP,
 -	[0x06] = KEY_RIGHT,
 -	[0x07] = KEY_DOWN,
 -	[0x08] = KEY_LEFT,
 -	[0x09] = BTN_TL2,		/* L2 */
 -	[0x0a] = BTN_TR2,		/* R2 */
 -	[0x0b] = BTN_TL,		/* L1 */
 -	[0x0c] = BTN_TR,		/* R1 */
 -	[0x0d] = KEY_OPTION,		/* options/triangle */
 -	[0x0e] = KEY_BACK,		/* back/circle */
 -	[0x0f] = BTN_0,			/* cross */
 -	[0x10] = KEY_SCREEN,		/* view/square */
 -	[0x11] = KEY_HOMEPAGE,		/* PS button */
 -	[0x14] = KEY_ENTER,
 -};
 -static const unsigned int ps3remote_keymap_remote_buttons[] = {
 -	[0x00] = KEY_1,
 -	[0x01] = KEY_2,
 -	[0x02] = KEY_3,
 -	[0x03] = KEY_4,
 -	[0x04] = KEY_5,
 -	[0x05] = KEY_6,
 -	[0x06] = KEY_7,
 -	[0x07] = KEY_8,
 -	[0x08] = KEY_9,
 -	[0x09] = KEY_0,
 -	[0x0e] = KEY_ESC,		/* return */
 -	[0x0f] = KEY_CLEAR,
 -	[0x16] = KEY_EJECTCD,
 -	[0x1a] = KEY_MENU,		/* top menu */
 -	[0x28] = KEY_TIME,
 -	[0x30] = KEY_PREVIOUS,
 -	[0x31] = KEY_NEXT,
 -	[0x32] = KEY_PLAY,
 -	[0x33] = KEY_REWIND,		/* scan back */
 -	[0x34] = KEY_FORWARD,		/* scan forward */
 -	[0x38] = KEY_STOP,
 -	[0x39] = KEY_PAUSE,
 -	[0x40] = KEY_CONTEXT_MENU,	/* pop up/menu */
 -	[0x60] = KEY_FRAMEBACK,		/* slow/step back */
 -	[0x61] = KEY_FRAMEFORWARD,	/* slow/step forward */
 -	[0x63] = KEY_SUBTITLE,
 -	[0x64] = KEY_AUDIO,
 -	[0x65] = KEY_ANGLE,
 -	[0x70] = KEY_INFO,		/* display */
 -	[0x80] = KEY_BLUE,
 -	[0x81] = KEY_RED,
 -	[0x82] = KEY_GREEN,
 -	[0x83] = KEY_YELLOW,
 -};
 -
 -static const unsigned int buzz_keymap[] = {
 -	/*
 -	 * The controller has 4 remote buzzers, each with one LED and 5
 -	 * buttons.
 -	 * 
 -	 * We use the mapping chosen by the controller, which is:
 -	 *
 -	 * Key          Offset
 -	 * -------------------
 -	 * Buzz              1
 -	 * Blue              5
 -	 * Orange            4
 -	 * Green             3
 -	 * Yellow            2
 -	 *
 -	 * So, for example, the orange button on the third buzzer is mapped to
 -	 * BTN_TRIGGER_HAPPY14
 -	 */
 -	[ 1] = BTN_TRIGGER_HAPPY1,
 -	[ 2] = BTN_TRIGGER_HAPPY2,
 -	[ 3] = BTN_TRIGGER_HAPPY3,
 -	[ 4] = BTN_TRIGGER_HAPPY4,
 -	[ 5] = BTN_TRIGGER_HAPPY5,
 -	[ 6] = BTN_TRIGGER_HAPPY6,
 -	[ 7] = BTN_TRIGGER_HAPPY7,
 -	[ 8] = BTN_TRIGGER_HAPPY8,
 -	[ 9] = BTN_TRIGGER_HAPPY9,
 -	[10] = BTN_TRIGGER_HAPPY10,
 -	[11] = BTN_TRIGGER_HAPPY11,
 -	[12] = BTN_TRIGGER_HAPPY12,
 -	[13] = BTN_TRIGGER_HAPPY13,
 -	[14] = BTN_TRIGGER_HAPPY14,
 -	[15] = BTN_TRIGGER_HAPPY15,
 -	[16] = BTN_TRIGGER_HAPPY16,
 -	[17] = BTN_TRIGGER_HAPPY17,
 -	[18] = BTN_TRIGGER_HAPPY18,
 -	[19] = BTN_TRIGGER_HAPPY19,
 -	[20] = BTN_TRIGGER_HAPPY20,
 -};
 +#define VAIO_RDESC_CONSTANT     (1 << 0)
 +#define SIXAXIS_CONTROLLER_USB  (1 << 1)
 +#define SIXAXIS_CONTROLLER_BT   (1 << 2)
  
 -static enum power_supply_property sony_battery_props[] = {
 -	POWER_SUPPLY_PROP_PRESENT,
 -	POWER_SUPPLY_PROP_CAPACITY,
 -	POWER_SUPPLY_PROP_SCOPE,
 -	POWER_SUPPLY_PROP_STATUS,
 +static const u8 sixaxis_rdesc_fixup[] = {
 +	0x95, 0x13, 0x09, 0x01, 0x81, 0x02, 0x95, 0x0C,
 +	0x81, 0x01, 0x75, 0x10, 0x95, 0x04, 0x26, 0xFF,
 +	0x03, 0x46, 0xFF, 0x03, 0x09, 0x01, 0x81, 0x02
  };
  
 -struct sixaxis_led {
 -	__u8 time_enabled; /* the total time the led is active (0xff means forever) */
 -	__u8 duty_length;  /* how long a cycle is in deciseconds (0 means "really fast") */
 -	__u8 enabled;
 -	__u8 duty_off; /* % of duty_length the led is off (0xff means 100%) */
 -	__u8 duty_on;  /* % of duty_length the led is on (0xff mean 100%) */
 -} __packed;
 -
 -struct sixaxis_rumble {
 -	__u8 padding;
 -	__u8 right_duration; /* Right motor duration (0xff means forever) */
 -	__u8 right_motor_on; /* Right (small) motor on/off, only supports values of 0 or 1 (off/on) */
 -	__u8 left_duration;    /* Left motor duration (0xff means forever) */
 -	__u8 left_motor_force; /* left (large) motor, supports force values from 0 to 255 */
 -} __packed;
 -
 -struct sixaxis_output_report {
 -	__u8 report_id;
 -	struct sixaxis_rumble rumble;
 -	__u8 padding[4];
 -	__u8 leds_bitmap; /* bitmap of enabled LEDs: LED_1 = 0x02, LED_2 = 0x04, ... */
 -	struct sixaxis_led led[4];    /* LEDx at (4 - x) */
 -	struct sixaxis_led _reserved; /* LED5, not actually soldered */
 -} __packed;
 -
 -union sixaxis_output_report_01 {
 -	struct sixaxis_output_report data;
 -	__u8 buf[36];
 +static const u8 sixaxis_rdesc_fixup2[] = {
 +	0x05, 0x01, 0x09, 0x04, 0xa1, 0x01, 0xa1, 0x02,
 +	0x85, 0x01, 0x75, 0x08, 0x95, 0x01, 0x15, 0x00,
 +	0x26, 0xff, 0x00, 0x81, 0x03, 0x75, 0x01, 0x95,
 +	0x13, 0x15, 0x00, 0x25, 0x01, 0x35, 0x00, 0x45,
 +	0x01, 0x05, 0x09, 0x19, 0x01, 0x29, 0x13, 0x81,
 +	0x02, 0x75, 0x01, 0x95, 0x0d, 0x06, 0x00, 0xff,
 +	0x81, 0x03, 0x15, 0x00, 0x26, 0xff, 0x00, 0x05,
 +	0x01, 0x09, 0x01, 0xa1, 0x00, 0x75, 0x08, 0x95,
 +	0x04, 0x35, 0x00, 0x46, 0xff, 0x00, 0x09, 0x30,
 +	0x09, 0x31, 0x09, 0x32, 0x09, 0x35, 0x81, 0x02,
 +	0xc0, 0x05, 0x01, 0x95, 0x13, 0x09, 0x01, 0x81,
 +	0x02, 0x95, 0x0c, 0x81, 0x01, 0x75, 0x10, 0x95,
 +	0x04, 0x26, 0xff, 0x03, 0x46, 0xff, 0x03, 0x09,
 +	0x01, 0x81, 0x02, 0xc0, 0xa1, 0x02, 0x85, 0x02,
 +	0x75, 0x08, 0x95, 0x30, 0x09, 0x01, 0xb1, 0x02,
 +	0xc0, 0xa1, 0x02, 0x85, 0xee, 0x75, 0x08, 0x95,
 +	0x30, 0x09, 0x01, 0xb1, 0x02, 0xc0, 0xa1, 0x02,
 +	0x85, 0xef, 0x75, 0x08, 0x95, 0x30, 0x09, 0x01,
 +	0xb1, 0x02, 0xc0, 0xc0,
  };
  
 -#define DS4_REPORT_0x02_SIZE 37
 -#define DS4_REPORT_0x05_SIZE 32
 -#define DS4_REPORT_0x11_SIZE 78
 -#define DS4_REPORT_0x81_SIZE 7
 -#define SIXAXIS_REPORT_0xF2_SIZE 18
 -
 -static spinlock_t sony_dev_list_lock;
 -static LIST_HEAD(sony_device_list);
 -static DEFINE_IDA(sony_device_id_allocator);
 -
  struct sony_sc {
 -	spinlock_t lock;
 -	struct list_head list_node;
 -	struct hid_device *hdev;
 -	struct led_classdev *leds[MAX_LEDS];
  	unsigned long quirks;
++<<<<<<< HEAD
++=======
+ 	struct work_struct state_worker;
+ 	struct power_supply *battery;
+ 	struct power_supply_desc battery_desc;
+ 	int device_id;
+ 	__u8 *output_report_dmabuf;
+ 
+ #ifdef CONFIG_SONY_FF
+ 	__u8 left;
+ 	__u8 right;
+ #endif
+ 
+ 	__u8 mac_address[6];
+ 	__u8 worker_initialized;
+ 	__u8 cable_state;
+ 	__u8 battery_charging;
+ 	__u8 battery_capacity;
+ 	__u8 led_state[MAX_LEDS];
+ 	__u8 led_delay_on[MAX_LEDS];
+ 	__u8 led_delay_off[MAX_LEDS];
+ 	__u8 led_count;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  };
  
 -static __u8 *sixaxis_fixup(struct hid_device *hdev, __u8 *rdesc,
 -			     unsigned int *rsize)
 -{
 -	*rsize = sizeof(sixaxis_rdesc);
 -	return sixaxis_rdesc;
 -}
 -
 -static __u8 *ps3remote_fixup(struct hid_device *hdev, __u8 *rdesc,
 -			     unsigned int *rsize)
 -{
 -	*rsize = sizeof(ps3remote_rdesc);
 -	return ps3remote_rdesc;
 -}
 -
 -static int ps3remote_mapping(struct hid_device *hdev, struct hid_input *hi,
 -			     struct hid_field *field, struct hid_usage *usage,
 -			     unsigned long **bit, int *max)
 -{
 -	unsigned int key = usage->hid & HID_USAGE;
 -
 -	if ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)
 -		return -1;
 -
 -	switch (usage->collection_index) {
 -	case 1:
 -		if (key >= ARRAY_SIZE(ps3remote_keymap_joypad_buttons))
 -			return -1;
 -
 -		key = ps3remote_keymap_joypad_buttons[key];
 -		if (!key)
 -			return -1;
 -		break;
 -	case 2:
 -		if (key >= ARRAY_SIZE(ps3remote_keymap_remote_buttons))
 -			return -1;
 -
 -		key = ps3remote_keymap_remote_buttons[key];
 -		if (!key)
 -			return -1;
 -		break;
 -	default:
 -		return -1;
 -	}
 -
 -	hid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);
 -	return 1;
 -}
 -
 +/* Sony Vaio VGX has wrongly mouse pointer declared as constant */
  static __u8 *sony_report_fixup(struct hid_device *hdev, __u8 *rdesc,
  		unsigned int *rsize)
  {
@@@ -149,9 -1150,790 +172,786 @@@ static int sixaxis_set_operational_usb(
  
  static int sixaxis_set_operational_bt(struct hid_device *hdev)
  {
 -	static const __u8 report[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };
 -	__u8 *buf;
 -	int ret;
 -
 -	buf = kmemdup(report, sizeof(report), GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -
 -	ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(report),
 +	unsigned char buf[] = { 0xf4,  0x42, 0x03, 0x00, 0x00 };
 +	return hid_hw_raw_request(hdev, buf[0], buf, sizeof(buf),
  				  HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
++<<<<<<< HEAD
++=======
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Requesting feature report 0x02 in Bluetooth mode changes the state of the
+  * controller so that it sends full input reports of type 0x11.
+  */
+ static int dualshock4_set_operational_bt(struct hid_device *hdev)
+ {
+ 	__u8 *buf;
+ 	int ret;
+ 
+ 	buf = kmalloc(DS4_REPORT_0x02_SIZE, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	ret = hid_hw_raw_request(hdev, 0x02, buf, DS4_REPORT_0x02_SIZE,
+ 				HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_set_leds_from_id(int id, __u8 values[MAX_LEDS])
+ {
+ 	static const __u8 sixaxis_leds[10][4] = {
+ 				{ 0x01, 0x00, 0x00, 0x00 },
+ 				{ 0x00, 0x01, 0x00, 0x00 },
+ 				{ 0x00, 0x00, 0x01, 0x00 },
+ 				{ 0x00, 0x00, 0x00, 0x01 },
+ 				{ 0x01, 0x00, 0x00, 0x01 },
+ 				{ 0x00, 0x01, 0x00, 0x01 },
+ 				{ 0x00, 0x00, 0x01, 0x01 },
+ 				{ 0x01, 0x00, 0x01, 0x01 },
+ 				{ 0x00, 0x01, 0x01, 0x01 },
+ 				{ 0x01, 0x01, 0x01, 0x01 }
+ 	};
+ 
+ 	BUG_ON(MAX_LEDS < ARRAY_SIZE(sixaxis_leds[0]));
+ 
+ 	if (id < 0)
+ 		return;
+ 
+ 	id %= 10;
+ 	memcpy(values, sixaxis_leds[id], sizeof(sixaxis_leds[id]));
+ }
+ 
+ static void dualshock4_set_leds_from_id(int id, __u8 values[MAX_LEDS])
+ {
+ 	/* The first 4 color/index entries match what the PS4 assigns */
+ 	static const __u8 color_code[7][3] = {
+ 			/* Blue   */	{ 0x00, 0x00, 0x01 },
+ 			/* Red	  */	{ 0x01, 0x00, 0x00 },
+ 			/* Green  */	{ 0x00, 0x01, 0x00 },
+ 			/* Pink   */	{ 0x02, 0x00, 0x01 },
+ 			/* Orange */	{ 0x02, 0x01, 0x00 },
+ 			/* Teal   */	{ 0x00, 0x01, 0x01 },
+ 			/* White  */	{ 0x01, 0x01, 0x01 }
+ 	};
+ 
+ 	BUG_ON(MAX_LEDS < ARRAY_SIZE(color_code[0]));
+ 
+ 	if (id < 0)
+ 		return;
+ 
+ 	id %= 7;
+ 	memcpy(values, color_code[id], sizeof(color_code[id]));
+ }
+ 
+ static void buzz_set_leds(struct hid_device *hdev, const __u8 *leds)
+ {
+ 	struct list_head *report_list =
+ 		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+ 	struct hid_report *report = list_entry(report_list->next,
+ 		struct hid_report, list);
+ 	__s32 *value = report->field[0]->value;
+ 
+ 	value[0] = 0x00;
+ 	value[1] = leds[0] ? 0xff : 0x00;
+ 	value[2] = leds[1] ? 0xff : 0x00;
+ 	value[3] = leds[2] ? 0xff : 0x00;
+ 	value[4] = leds[3] ? 0xff : 0x00;
+ 	value[5] = 0x00;
+ 	value[6] = 0x00;
+ 	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
+ }
+ 
+ static void sony_set_leds(struct sony_sc *sc, const __u8 *leds, int count)
+ {
+ 	int n;
+ 
+ 	BUG_ON(count > MAX_LEDS);
+ 
+ 	if (sc->quirks & BUZZ_CONTROLLER && count == 4) {
+ 		buzz_set_leds(sc->hdev, leds);
+ 	} else {
+ 		for (n = 0; n < count; n++)
+ 			sc->led_state[n] = leds[n];
+ 		schedule_work(&sc->state_worker);
+ 	}
+ }
+ 
+ static void sony_led_set_brightness(struct led_classdev *led,
+ 				    enum led_brightness value)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 	int force_update;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * The Sixaxis on USB will override any LED settings sent to it
+ 	 * and keep flashing all of the LEDs until the PS button is pressed.
+ 	 * Updates, even if redundant, must be always be sent to the
+ 	 * controller to avoid having to toggle the state of an LED just to
+ 	 * stop the flashing later on.
+ 	 */
+ 	force_update = !!(drv_data->quirks & SIXAXIS_CONTROLLER_USB);
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n] && (force_update ||
+ 			(value != drv_data->led_state[n] ||
+ 			drv_data->led_delay_on[n] ||
+ 			drv_data->led_delay_off[n]))) {
+ 
+ 			drv_data->led_state[n] = value;
+ 
+ 			/* Setting the brightness stops the blinking */
+ 			drv_data->led_delay_on[n] = 0;
+ 			drv_data->led_delay_off[n] = 0;
+ 
+ 			sony_set_leds(drv_data, drv_data->led_state,
+ 					drv_data->led_count);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static enum led_brightness sony_led_get_brightness(struct led_classdev *led)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data;
+ 
+ 	int n;
+ 
+ 	drv_data = hid_get_drvdata(hdev);
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return LED_OFF;
+ 	}
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			return drv_data->led_state[n];
+ 	}
+ 
+ 	return LED_OFF;
+ }
+ 
+ static int sony_led_blink_set(struct led_classdev *led, unsigned long *delay_on,
+ 				unsigned long *delay_off)
+ {
+ 	struct device *dev = led->dev->parent;
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct sony_sc *drv_data = hid_get_drvdata(hdev);
+ 	int n;
+ 	__u8 new_on, new_off;
+ 
+ 	if (!drv_data) {
+ 		hid_err(hdev, "No device data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Max delay is 255 deciseconds or 2550 milliseconds */
+ 	if (*delay_on > 2550)
+ 		*delay_on = 2550;
+ 	if (*delay_off > 2550)
+ 		*delay_off = 2550;
+ 
+ 	/* Blink at 1 Hz if both values are zero */
+ 	if (!*delay_on && !*delay_off)
+ 		*delay_on = *delay_off = 500;
+ 
+ 	new_on = *delay_on / 10;
+ 	new_off = *delay_off / 10;
+ 
+ 	for (n = 0; n < drv_data->led_count; n++) {
+ 		if (led == drv_data->leds[n])
+ 			break;
+ 	}
+ 
+ 	/* This LED is not registered on this device */
+ 	if (n >= drv_data->led_count)
+ 		return -EINVAL;
+ 
+ 	/* Don't schedule work if the values didn't change */
+ 	if (new_on != drv_data->led_delay_on[n] ||
+ 		new_off != drv_data->led_delay_off[n]) {
+ 		drv_data->led_delay_on[n] = new_on;
+ 		drv_data->led_delay_off[n] = new_off;
+ 		schedule_work(&drv_data->state_worker);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void sony_leds_remove(struct sony_sc *sc)
+ {
+ 	struct led_classdev *led;
+ 	int n;
+ 
+ 	BUG_ON(!(sc->quirks & SONY_LED_SUPPORT));
+ 
+ 	for (n = 0; n < sc->led_count; n++) {
+ 		led = sc->leds[n];
+ 		sc->leds[n] = NULL;
+ 		if (!led)
+ 			continue;
+ 		led_classdev_unregister(led);
+ 		kfree(led);
+ 	}
+ 
+ 	sc->led_count = 0;
+ }
+ 
+ static int sony_leds_init(struct sony_sc *sc)
+ {
+ 	struct hid_device *hdev = sc->hdev;
+ 	int n, ret = 0;
+ 	int use_ds4_names;
+ 	struct led_classdev *led;
+ 	size_t name_sz;
+ 	char *name;
+ 	size_t name_len;
+ 	const char *name_fmt;
+ 	static const char * const ds4_name_str[] = { "red", "green", "blue",
+ 						  "global" };
+ 	__u8 initial_values[MAX_LEDS] = { 0 };
+ 	__u8 max_brightness[MAX_LEDS] = { [0 ... (MAX_LEDS - 1)] = 1 };
+ 	__u8 use_hw_blink[MAX_LEDS] = { 0 };
+ 
+ 	BUG_ON(!(sc->quirks & SONY_LED_SUPPORT));
+ 
+ 	if (sc->quirks & BUZZ_CONTROLLER) {
+ 		sc->led_count = 4;
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::buzz#");
+ 		name_fmt = "%s::buzz%d";
+ 		/* Validate expected report characteristics. */
+ 		if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))
+ 			return -ENODEV;
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {
+ 		dualshock4_set_leds_from_id(sc->device_id, initial_values);
+ 		initial_values[3] = 1;
+ 		sc->led_count = 4;
+ 		memset(max_brightness, 255, 3);
+ 		use_hw_blink[3] = 1;
+ 		use_ds4_names = 1;
+ 		name_len = 0;
+ 		name_fmt = "%s:%s";
+ 	} else {
+ 		sixaxis_set_leds_from_id(sc->device_id, initial_values);
+ 		sc->led_count = 4;
+ 		memset(use_hw_blink, 1, 4);
+ 		use_ds4_names = 0;
+ 		name_len = strlen("::sony#");
+ 		name_fmt = "%s::sony%d";
+ 	}
+ 
+ 	/*
+ 	 * Clear LEDs as we have no way of reading their initial state. This is
+ 	 * only relevant if the driver is loaded after somebody actively set the
+ 	 * LEDs to on
+ 	 */
+ 	sony_set_leds(sc, initial_values, sc->led_count);
+ 
+ 	name_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;
+ 
+ 	for (n = 0; n < sc->led_count; n++) {
+ 
+ 		if (use_ds4_names)
+ 			name_sz = strlen(dev_name(&hdev->dev)) + strlen(ds4_name_str[n]) + 2;
+ 
+ 		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
+ 		if (!led) {
+ 			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
+ 			ret = -ENOMEM;
+ 			goto error_leds;
+ 		}
+ 
+ 		name = (void *)(&led[1]);
+ 		if (use_ds4_names)
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev),
+ 			ds4_name_str[n]);
+ 		else
+ 			snprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);
+ 		led->name = name;
+ 		led->brightness = initial_values[n];
+ 		led->max_brightness = max_brightness[n];
+ 		led->brightness_get = sony_led_get_brightness;
+ 		led->brightness_set = sony_led_set_brightness;
+ 
+ 		if (use_hw_blink[n])
+ 			led->blink_set = sony_led_blink_set;
+ 
+ 		sc->leds[n] = led;
+ 
+ 		ret = led_classdev_register(&hdev->dev, led);
+ 		if (ret) {
+ 			hid_err(hdev, "Failed to register LED %d\n", n);
+ 			sc->leds[n] = NULL;
+ 			kfree(led);
+ 			goto error_leds;
+ 		}
+ 	}
+ 
+ 	return ret;
+ 
+ error_leds:
+ 	sony_leds_remove(sc);
+ 
+ 	return ret;
+ }
+ 
+ static void sixaxis_state_worker(struct work_struct *work)
+ {
+ 	static const union sixaxis_output_report_01 default_report = {
+ 		.buf = {
+ 			0x01,
+ 			0x00, 0xff, 0x00, 0xff, 0x00,
+ 			0x00, 0x00, 0x00, 0x00, 0x00,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0xff, 0x27, 0x10, 0x00, 0x32,
+ 			0x00, 0x00, 0x00, 0x00, 0x00
+ 		}
+ 	};
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct sixaxis_output_report *report =
+ 		(struct sixaxis_output_report *)sc->output_report_dmabuf;
+ 	int n;
+ 
+ 	/* Initialize the report with default values */
+ 	memcpy(report, &default_report, sizeof(struct sixaxis_output_report));
+ 
+ #ifdef CONFIG_SONY_FF
+ 	report->rumble.right_motor_on = sc->right ? 1 : 0;
+ 	report->rumble.left_motor_force = sc->left;
+ #endif
+ 
+ 	report->leds_bitmap |= sc->led_state[0] << 1;
+ 	report->leds_bitmap |= sc->led_state[1] << 2;
+ 	report->leds_bitmap |= sc->led_state[2] << 3;
+ 	report->leds_bitmap |= sc->led_state[3] << 4;
+ 
+ 	/* Set flag for all leds off, required for 3rd party INTEC controller */
+ 	if ((report->leds_bitmap & 0x1E) == 0)
+ 		report->leds_bitmap |= 0x20;
+ 
+ 	/*
+ 	 * The LEDs in the report are indexed in reverse order to their
+ 	 * corresponding light on the controller.
+ 	 * Index 0 = LED 4, index 1 = LED 3, etc...
+ 	 *
+ 	 * In the case of both delay values being zero (blinking disabled) the
+ 	 * default report values should be used or the controller LED will be
+ 	 * always off.
+ 	 */
+ 	for (n = 0; n < 4; n++) {
+ 		if (sc->led_delay_on[n] || sc->led_delay_off[n]) {
+ 			report->led[3 - n].duty_off = sc->led_delay_off[n];
+ 			report->led[3 - n].duty_on = sc->led_delay_on[n];
+ 		}
+ 	}
+ 
+ 	hid_hw_raw_request(sc->hdev, report->report_id, (__u8 *)report,
+ 			sizeof(struct sixaxis_output_report),
+ 			HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static void dualshock4_state_worker(struct work_struct *work)
+ {
+ 	struct sony_sc *sc = container_of(work, struct sony_sc, state_worker);
+ 	struct hid_device *hdev = sc->hdev;
+ 	__u8 *buf = sc->output_report_dmabuf;
+ 	int offset;
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		memset(buf, 0, DS4_REPORT_0x05_SIZE);
+ 		buf[0] = 0x05;
+ 		buf[1] = 0xFF;
+ 		offset = 4;
+ 	} else {
+ 		memset(buf, 0, DS4_REPORT_0x11_SIZE);
+ 		buf[0] = 0x11;
+ 		buf[1] = 0xB0;
+ 		buf[3] = 0x0F;
+ 		offset = 6;
+ 	}
+ 
+ #ifdef CONFIG_SONY_FF
+ 	buf[offset++] = sc->right;
+ 	buf[offset++] = sc->left;
+ #else
+ 	offset += 2;
+ #endif
+ 
+ 	/* LED 3 is the global control */
+ 	if (sc->led_state[3]) {
+ 		buf[offset++] = sc->led_state[0];
+ 		buf[offset++] = sc->led_state[1];
+ 		buf[offset++] = sc->led_state[2];
+ 	} else {
+ 		offset += 3;
+ 	}
+ 
+ 	/* If both delay values are zero the DualShock 4 disables blinking. */
+ 	buf[offset++] = sc->led_delay_on[3];
+ 	buf[offset++] = sc->led_delay_off[3];
+ 
+ 	if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		hid_hw_output_report(hdev, buf, DS4_REPORT_0x05_SIZE);
+ 	else
+ 		hid_hw_raw_request(hdev, 0x11, buf, DS4_REPORT_0x11_SIZE,
+ 				HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);
+ }
+ 
+ static int sony_allocate_output_report(struct sony_sc *sc)
+ {
+ 	if (sc->quirks & SIXAXIS_CONTROLLER)
+ 		sc->output_report_dmabuf =
+ 			kmalloc(sizeof(union sixaxis_output_report_01),
+ 				GFP_KERNEL);
+ 	else if (sc->quirks & DUALSHOCK4_CONTROLLER_BT)
+ 		sc->output_report_dmabuf = kmalloc(DS4_REPORT_0x11_SIZE,
+ 						GFP_KERNEL);
+ 	else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)
+ 		sc->output_report_dmabuf = kmalloc(DS4_REPORT_0x05_SIZE,
+ 						GFP_KERNEL);
+ 	else
+ 		return 0;
+ 
+ 	if (!sc->output_report_dmabuf)
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_SONY_FF
+ static int sony_play_effect(struct input_dev *dev, void *data,
+ 			    struct ff_effect *effect)
+ {
+ 	struct hid_device *hid = input_get_drvdata(dev);
+ 	struct sony_sc *sc = hid_get_drvdata(hid);
+ 
+ 	if (effect->type != FF_RUMBLE)
+ 		return 0;
+ 
+ 	sc->left = effect->u.rumble.strong_magnitude / 256;
+ 	sc->right = effect->u.rumble.weak_magnitude / 256;
+ 
+ 	schedule_work(&sc->state_worker);
+ 	return 0;
+ }
+ 
+ static int sony_init_ff(struct sony_sc *sc)
+ {
+ 	struct hid_input *hidinput = list_entry(sc->hdev->inputs.next,
+ 						struct hid_input, list);
+ 	struct input_dev *input_dev = hidinput->input;
+ 
+ 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+ 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
+ }
+ 
+ #else
+ static int sony_init_ff(struct sony_sc *sc)
+ {
+ 	return 0;
+ }
+ 
+ #endif
+ 
+ static int sony_battery_get_property(struct power_supply *psy,
+ 				     enum power_supply_property psp,
+ 				     union power_supply_propval *val)
+ {
+ 	struct sony_sc *sc = power_supply_get_drvdata(psy);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 	u8 battery_charging, battery_capacity, cable_state;
+ 
+ 	spin_lock_irqsave(&sc->lock, flags);
+ 	battery_charging = sc->battery_charging;
+ 	battery_capacity = sc->battery_capacity;
+ 	cable_state = sc->cable_state;
+ 	spin_unlock_irqrestore(&sc->lock, flags);
+ 
+ 	switch (psp) {
+ 	case POWER_SUPPLY_PROP_PRESENT:
+ 		val->intval = 1;
+ 		break;
+ 	case POWER_SUPPLY_PROP_SCOPE:
+ 		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 		break;
+ 	case POWER_SUPPLY_PROP_CAPACITY:
+ 		val->intval = battery_capacity;
+ 		break;
+ 	case POWER_SUPPLY_PROP_STATUS:
+ 		if (battery_charging)
+ 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+ 		else
+ 			if (battery_capacity == 100 && cable_state)
+ 				val->intval = POWER_SUPPLY_STATUS_FULL;
+ 			else
+ 				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int sony_battery_probe(struct sony_sc *sc)
+ {
+ 	struct power_supply_config psy_cfg = { .drv_data = sc, };
+ 	struct hid_device *hdev = sc->hdev;
+ 	int ret;
+ 
+ 	/*
+ 	 * Set the default battery level to 100% to avoid low battery warnings
+ 	 * if the battery is polled before the first device report is received.
+ 	 */
+ 	sc->battery_capacity = 100;
+ 
+ 	sc->battery_desc.properties = sony_battery_props;
+ 	sc->battery_desc.num_properties = ARRAY_SIZE(sony_battery_props);
+ 	sc->battery_desc.get_property = sony_battery_get_property;
+ 	sc->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	sc->battery_desc.use_for_apm = 0;
+ 	sc->battery_desc.name = kasprintf(GFP_KERNEL,
+ 					  "sony_controller_battery_%pMR",
+ 					  sc->mac_address);
+ 	if (!sc->battery_desc.name)
+ 		return -ENOMEM;
+ 
+ 	sc->battery = power_supply_register(&hdev->dev, &sc->battery_desc,
+ 					    &psy_cfg);
+ 	if (IS_ERR(sc->battery)) {
+ 		ret = PTR_ERR(sc->battery);
+ 		hid_err(hdev, "Unable to register battery device\n");
+ 		goto err_free;
+ 	}
+ 
+ 	power_supply_powers(sc->battery, &hdev->dev);
+ 	return 0;
+ 
+ err_free:
+ 	kfree(sc->battery_desc.name);
+ 	sc->battery_desc.name = NULL;
+ 	return ret;
+ }
+ 
+ static void sony_battery_remove(struct sony_sc *sc)
+ {
+ 	if (!sc->battery_desc.name)
+ 		return;
+ 
+ 	power_supply_unregister(sc->battery);
+ 	kfree(sc->battery_desc.name);
+ 	sc->battery_desc.name = NULL;
+ }
+ 
+ /*
+  * If a controller is plugged in via USB while already connected via Bluetooth
+  * it will show up as two devices. A global list of connected controllers and
+  * their MAC addresses is maintained to ensure that a device is only connected
+  * once.
+  */
+ static int sony_check_add_dev_list(struct sony_sc *sc)
+ {
+ 	struct sony_sc *entry;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 
+ 	list_for_each_entry(entry, &sony_device_list, list_node) {
+ 		ret = memcmp(sc->mac_address, entry->mac_address,
+ 				sizeof(sc->mac_address));
+ 		if (!ret) {
+ 			ret = -EEXIST;
+ 			hid_info(sc->hdev, "controller with MAC address %pMR already connected\n",
+ 				sc->mac_address);
+ 			goto unlock;
+ 		}
+ 	}
+ 
+ 	ret = 0;
+ 	list_add(&(sc->list_node), &sony_device_list);
+ 
+ unlock:
+ 	spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	return ret;
+ }
+ 
+ static void sony_remove_dev_list(struct sony_sc *sc)
+ {
+ 	unsigned long flags;
+ 
+ 	if (sc->list_node.next) {
+ 		spin_lock_irqsave(&sony_dev_list_lock, flags);
+ 		list_del(&(sc->list_node));
+ 		spin_unlock_irqrestore(&sony_dev_list_lock, flags);
+ 	}
+ }
+ 
+ static int sony_get_bt_devaddr(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/* HIDP stores the device MAC address as a string in the uniq field. */
+ 	ret = strlen(sc->hdev->uniq);
+ 	if (ret != 17)
+ 		return -EINVAL;
+ 
+ 	ret = sscanf(sc->hdev->uniq,
+ 		"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+ 		&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],
+ 		&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);
+ 
+ 	if (ret != 6)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int sony_check_add(struct sony_sc *sc)
+ {
+ 	__u8 *buf = NULL;
+ 	int n, ret;
+ 
+ 	if ((sc->quirks & DUALSHOCK4_CONTROLLER_BT) ||
+ 	    (sc->quirks & SIXAXIS_CONTROLLER_BT)) {
+ 		/*
+ 		 * sony_get_bt_devaddr() attempts to parse the Bluetooth MAC
+ 		 * address from the uniq string where HIDP stores it.
+ 		 * As uniq cannot be guaranteed to be a MAC address in all cases
+ 		 * a failure of this function should not prevent the connection.
+ 		 */
+ 		if (sony_get_bt_devaddr(sc) < 0) {
+ 			hid_warn(sc->hdev, "UNIQ does not contain a MAC address; duplicate check skipped\n");
+ 			return 0;
+ 		}
+ 	} else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {
+ 		buf = kmalloc(DS4_REPORT_0x81_SIZE, GFP_KERNEL);
+ 		if (!buf)
+ 			return -ENOMEM;
+ 
+ 		/*
+ 		 * The MAC address of a DS4 controller connected via USB can be
+ 		 * retrieved with feature report 0x81. The address begins at
+ 		 * offset 1.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0x81, buf,
+ 				DS4_REPORT_0x81_SIZE, HID_FEATURE_REPORT,
+ 				HID_REQ_GET_REPORT);
+ 
+ 		if (ret != DS4_REPORT_0x81_SIZE) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0x81 with the DualShock 4 MAC address\n");
+ 			ret = ret < 0 ? ret : -EINVAL;
+ 			goto out_free;
+ 		}
+ 
+ 		memcpy(sc->mac_address, &buf[1], sizeof(sc->mac_address));
+ 	} else if (sc->quirks & SIXAXIS_CONTROLLER_USB) {
+ 		buf = kmalloc(SIXAXIS_REPORT_0xF2_SIZE, GFP_KERNEL);
+ 		if (!buf)
+ 			return -ENOMEM;
+ 
+ 		/*
+ 		 * The MAC address of a Sixaxis controller connected via USB can
+ 		 * be retrieved with feature report 0xf2. The address begins at
+ 		 * offset 4.
+ 		 */
+ 		ret = hid_hw_raw_request(sc->hdev, 0xf2, buf,
+ 				SIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,
+ 				HID_REQ_GET_REPORT);
+ 
+ 		if (ret != SIXAXIS_REPORT_0xF2_SIZE) {
+ 			hid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");
+ 			ret = ret < 0 ? ret : -EINVAL;
+ 			goto out_free;
+ 		}
+ 
+ 		/*
+ 		 * The Sixaxis device MAC in the report is big-endian and must
+ 		 * be byte-swapped.
+ 		 */
+ 		for (n = 0; n < 6; n++)
+ 			sc->mac_address[5-n] = buf[4+n];
+ 	} else {
+ 		return 0;
+ 	}
+ 
+ 	ret = sony_check_add_dev_list(sc);
+ 
+ out_free:
+ 
+ 	kfree(buf);
+ 
+ 	return ret;
+ }
+ 
+ static int sony_set_device_id(struct sony_sc *sc)
+ {
+ 	int ret;
+ 
+ 	/*
+ 	 * Only DualShock 4 or Sixaxis controllers get an id.
+ 	 * All others are set to -1.
+ 	 */
+ 	if ((sc->quirks & SIXAXIS_CONTROLLER) ||
+ 	    (sc->quirks & DUALSHOCK4_CONTROLLER)) {
+ 		ret = ida_simple_get(&sony_device_id_allocator, 0, 0,
+ 					GFP_KERNEL);
+ 		if (ret < 0) {
+ 			sc->device_id = -1;
+ 			return ret;
+ 		}
+ 		sc->device_id = ret;
+ 	} else {
+ 		sc->device_id = -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void sony_release_device_id(struct sony_sc *sc)
+ {
+ 	if (sc->device_id >= 0) {
+ 		ida_simple_remove(&sony_device_id_allocator, sc->device_id);
+ 		sc->device_id = -1;
+ 	}
+ }
+ 
+ static inline void sony_init_work(struct sony_sc *sc,
+ 					void (*worker)(struct work_struct *))
+ {
+ 	if (!sc->worker_initialized)
+ 		INIT_WORK(&sc->state_worker, worker);
+ 
+ 	sc->worker_initialized = 1;
+ }
+ 
+ static inline void sony_cancel_work_sync(struct sony_sc *sc)
+ {
+ 	if (sc->worker_initialized)
+ 		cancel_work_sync(&sc->state_worker);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  }
  
  static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
diff --cc drivers/hid/hid-wiimote.h
index 0ebe7e45b305,875694d43e4d..000000000000
--- a/drivers/hid/hid-wiimote.h
+++ b/drivers/hid/hid-wiimote.h
@@@ -73,19 -146,66 +73,26 @@@ struct wiimote_data 
  	struct led_classdev *leds[4];
  	struct input_dev *accel;
  	struct input_dev *ir;
++<<<<<<< HEAD
 +	struct power_supply battery;
 +	struct wiimote_ext *ext;
++=======
+ 	struct power_supply *battery;
+ 	struct power_supply_desc battery_desc;
+ 	struct input_dev *mp;
+ 	struct timer_list timer;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	struct wiimote_debug *debug;
  
 -	union {
 -		struct input_dev *input;
 -	} extension;
 +	spinlock_t qlock;
 +	__u8 head;
 +	__u8 tail;
 +	struct wiimote_buf outq[WIIMOTE_BUFSIZE];
 +	struct work_struct worker;
  
 -	struct wiimote_queue queue;
  	struct wiimote_state state;
 -	struct work_struct init_worker;
 -};
 -
 -/* wiimote modules */
 -
 -enum wiimod_module {
 -	WIIMOD_KEYS,
 -	WIIMOD_RUMBLE,
 -	WIIMOD_BATTERY,
 -	WIIMOD_LED1,
 -	WIIMOD_LED2,
 -	WIIMOD_LED3,
 -	WIIMOD_LED4,
 -	WIIMOD_ACCEL,
 -	WIIMOD_IR,
 -	WIIMOD_BUILTIN_MP,
 -	WIIMOD_NO_MP,
 -	WIIMOD_NUM,
 -	WIIMOD_NULL = WIIMOD_NUM,
 -};
 -
 -#define WIIMOD_FLAG_INPUT		0x0001
 -#define WIIMOD_FLAG_EXT8		0x0002
 -#define WIIMOD_FLAG_EXT16		0x0004
 -
 -struct wiimod_ops {
 -	__u16 flags;
 -	unsigned long arg;
 -	int (*probe) (const struct wiimod_ops *ops,
 -		      struct wiimote_data *wdata);
 -	void (*remove) (const struct wiimod_ops *ops,
 -			struct wiimote_data *wdata);
 -
 -	void (*in_keys) (struct wiimote_data *wdata, const __u8 *keys);
 -	void (*in_accel) (struct wiimote_data *wdata, const __u8 *accel);
 -	void (*in_ir) (struct wiimote_data *wdata, const __u8 *ir, bool packed,
 -		       unsigned int id);
 -	void (*in_mp) (struct wiimote_data *wdata, const __u8 *mp);
 -	void (*in_ext) (struct wiimote_data *wdata, const __u8 *ext);
  };
  
 -extern const struct wiimod_ops *wiimod_table[WIIMOD_NUM];
 -extern const struct wiimod_ops *wiimod_ext_table[WIIMOTE_EXT_NUM];
 -extern const struct wiimod_ops wiimod_mp;
 -
 -/* wiimote requests */
 -
  enum wiiproto_reqs {
  	WIIPROTO_REQ_NULL = 0x0,
  	WIIPROTO_REQ_RUMBLE = 0x10,
diff --cc drivers/hid/wacom.h
index ca5f42fe2797,0d0d0dd89d17..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -155,26 -118,24 +155,38 @@@ struct wacom 
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
  	} led;
++<<<<<<< HEAD
 +	struct wacom_battery battery;
 +	bool resources;
++=======
+ 	bool led_initialized;
+ 	struct power_supply *battery;
+ 	struct power_supply *ac;
+ 	struct power_supply_desc battery_desc;
+ 	struct power_supply_desc ac_desc;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  };
  
 -static inline void wacom_schedule_work(struct wacom_wac *wacom_wac)
 -{
 -	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
 -	schedule_work(&wacom->work);
 -}
 -
 -static inline void wacom_notify_battery(struct wacom_wac *wacom_wac)
 +static inline void wacom_schedule_work(struct wacom_wac *wacom_wac,
 +				       enum wacom_worker which)
  {
  	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
  
++<<<<<<< HEAD
 +	switch (which) {
 +	case WACOM_WORKER_WIRELESS:
 +		schedule_work(&wacom->wireless_work);
 +		break;
 +	case WACOM_WORKER_BATTERY:
 +		schedule_work(&wacom->battery_work);
 +		break;
 +	case WACOM_WORKER_REMOTE:
 +		schedule_work(&wacom->remote_work);
 +		break;
 +	}
++=======
+ 	power_supply_changed(wacom->battery);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  }
  
  extern const struct hid_device_id wacom_ids[];
diff --cc drivers/hid/wacom_sys.c
index dd37aa8d4f5d,ba9af470bea0..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1155,7 -944,7 +1155,11 @@@ static int wacom_battery_get_property(s
  				      enum power_supply_property psp,
  				      union power_supply_propval *val)
  {
++<<<<<<< HEAD
 +	struct wacom_battery *battery = container_of(psy, struct wacom_battery, battery);
++=======
+ 	struct wacom *wacom = power_supply_get_drvdata(psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	int ret = 0;
  
  	switch (psp) {
@@@ -1190,70 -972,85 +1194,129 @@@
  	return ret;
  }
  
 -static int wacom_ac_get_property(struct power_supply *psy,
 -				enum power_supply_property psp,
 -				union power_supply_propval *val)
 +static int __wacom_initialize_battery(struct wacom *wacom,
 +				      struct wacom_battery *battery)
  {
++<<<<<<< HEAD
 +	static atomic_t battery_no = ATOMIC_INIT(0);
 +	struct device *dev = &wacom->hdev->dev;
 +	int error;
 +	unsigned long n;
++=======
+ 	struct wacom *wacom = power_supply_get_drvdata(psy);
+ 	int ret = 0;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
 -	switch (psp) {
 -	case POWER_SUPPLY_PROP_PRESENT:
 -		/* fall through */
 -	case POWER_SUPPLY_PROP_ONLINE:
 -		val->intval = wacom->wacom_wac.ps_connected;
 -		break;
 -	case POWER_SUPPLY_PROP_SCOPE:
 -		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
 -		break;
 -	default:
 -		ret = -EINVAL;
 -		break;
 -	}
 -	return ret;
 +	/*
 +	 * Disabling power_supply code for RHEL-7.4 due lack of more intrusive
 +	 * changes. This will be fixed in RHEL-7.5
 +	 */
 +	if (wacom->wacom_wac.features.type == REMOTE ||
 +	    wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)
 +		return 0;
 +
 +	if (!devres_open_group(dev, &wacom->battery, GFP_KERNEL))
 +		return -ENOMEM;
 +
 +	battery->wacom = wacom;
 +
 +	n = atomic_inc_return(&battery_no) - 1;
 +
 +	wacom->battery.battery.properties = wacom_battery_props;
 +	wacom->battery.battery.num_properties = ARRAY_SIZE(wacom_battery_props);
 +	wacom->battery.battery.get_property = wacom_battery_get_property;
 +	sprintf(wacom->battery.bat_name, "wacom_battery_%ld", n);
 +	wacom->battery.battery.name = wacom->battery.bat_name;
 +	wacom->battery.battery.type = POWER_SUPPLY_TYPE_USB;
 +	wacom->battery.battery.use_for_apm = 0;
 +
 +	error = devm_power_supply_register(&wacom->hdev->dev,
 +					   &wacom->battery.battery);
 +	if (error)
 +		goto err;
 +
 +	power_supply_powers(&wacom->battery.battery, &wacom->hdev->dev);
 +
 +	devres_close_group(dev, &wacom->battery);
 +	return 0;
 +
 +err:
 +	devres_release_group(dev, &wacom->battery);
 +	return error;
  }
  
  static int wacom_initialize_battery(struct wacom *wacom)
  {
++<<<<<<< HEAD
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)
 +		return __wacom_initialize_battery(wacom, &wacom->battery);
++=======
+ 	static atomic_t battery_no = ATOMIC_INIT(0);
+ 	struct power_supply_config psy_cfg = { .drv_data = wacom, };
+ 	unsigned long n;
+ 
+ 	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) {
+ 		struct power_supply_desc *bat_desc = &wacom->battery_desc;
+ 		struct power_supply_desc *ac_desc = &wacom->ac_desc;
+ 		n = atomic_inc_return(&battery_no) - 1;
+ 
+ 		bat_desc->properties = wacom_battery_props;
+ 		bat_desc->num_properties = ARRAY_SIZE(wacom_battery_props);
+ 		bat_desc->get_property = wacom_battery_get_property;
+ 		sprintf(wacom->wacom_wac.bat_name, "wacom_battery_%ld", n);
+ 		bat_desc->name = wacom->wacom_wac.bat_name;
+ 		bat_desc->type = POWER_SUPPLY_TYPE_BATTERY;
+ 		bat_desc->use_for_apm = 0;
+ 
+ 		ac_desc->properties = wacom_ac_props;
+ 		ac_desc->num_properties = ARRAY_SIZE(wacom_ac_props);
+ 		ac_desc->get_property = wacom_ac_get_property;
+ 		sprintf(wacom->wacom_wac.ac_name, "wacom_ac_%ld", n);
+ 		ac_desc->name = wacom->wacom_wac.ac_name;
+ 		ac_desc->type = POWER_SUPPLY_TYPE_MAINS;
+ 		ac_desc->use_for_apm = 0;
+ 
+ 		wacom->battery = power_supply_register(&wacom->hdev->dev,
+ 					      &wacom->battery_desc, &psy_cfg);
+ 		if (IS_ERR(wacom->battery))
+ 			return PTR_ERR(wacom->battery);
+ 
+ 		power_supply_powers(wacom->battery, &wacom->hdev->dev);
+ 
+ 		wacom->ac = power_supply_register(&wacom->hdev->dev,
+ 						  &wacom->ac_desc,
+ 						  &psy_cfg);
+ 		if (IS_ERR(wacom->ac)) {
+ 			power_supply_unregister(wacom->battery);
+ 			return PTR_ERR(wacom->ac);
+ 		}
+ 
+ 		power_supply_powers(wacom->ac, &wacom->hdev->dev);
+ 	}
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
  
  static void wacom_destroy_battery(struct wacom *wacom)
  {
++<<<<<<< HEAD
 +	if (wacom->wacom_wac.features.type == REMOTE ||
 +	    wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)
 +		return;
 +
 +	if (wacom->battery.battery.dev) {
 +		devres_release_group(&wacom->hdev->dev,
 +				     &wacom->battery);
 +		wacom->battery.battery.dev = NULL;
++=======
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     wacom->battery) {
+ 		power_supply_unregister(wacom->battery);
+ 		wacom->battery = NULL;
+ 		power_supply_unregister(wacom->ac);
+ 		wacom->ac = NULL;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
  }
  
diff --cc drivers/platform/x86/compal-laptop.c
index 475cc5242511,b4e94471f3d5..000000000000
--- a/drivers/platform/x86/compal-laptop.c
+++ b/drivers/platform/x86/compal-laptop.c
@@@ -1019,6 -1012,8 +1021,11 @@@ static int compal_probe(struct platform
  {
  	int err;
  	struct compal_data *data;
++<<<<<<< HEAD
++=======
+ 	struct device *hwmon_dev;
+ 	struct power_supply_config psy_cfg = {};
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	if (!extra_features)
  		return 0;
@@@ -1047,7 -1039,13 +1054,17 @@@
  
  	/* Power supply */
  	initialize_power_supply_data(data);
++<<<<<<< HEAD
 +	power_supply_register(&compal_device->dev, &data->psy);
++=======
+ 	psy_cfg.drv_data = data;
+ 	data->psy = power_supply_register(&compal_device->dev, &psy_bat_desc,
+ 					  &psy_cfg);
+ 	if (IS_ERR(data->psy)) {
+ 		err = PTR_ERR(data->psy);
+ 		goto remove;
+ 	}
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	platform_set_drvdata(pdev, data);
  
@@@ -1078,13 -1080,9 +1095,17 @@@ static int compal_remove(struct platfor
  	pwm_disable_control();
  
  	data = platform_get_drvdata(pdev);
++<<<<<<< HEAD
 +	hwmon_device_unregister(data->hwmon_dev);
 +	power_supply_unregister(&data->psy);
++=======
+ 	power_supply_unregister(data->psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
 +
 +	platform_set_drvdata(pdev, NULL);
 +	kfree(data);
  
 -	sysfs_remove_group(&pdev->dev.kobj, &compal_platform_attr_group);
 +	sysfs_remove_group(&pdev->dev.kobj, &compal_attribute_group);
  
  	return 0;
  }
diff --cc drivers/power/88pm860x_battery.c
index d338c1c4e8c8,d49579b227ec..000000000000
--- a/drivers/power/88pm860x_battery.c
+++ b/drivers/power/88pm860x_battery.c
@@@ -953,10 -954,11 +954,18 @@@ static int pm860x_battery_probe(struct 
  	else
  		info->resistor = 300;	/* set default internal resistor */
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &info->battery);
 +	if (ret)
 +		return ret;
 +	info->battery.dev->parent = &pdev->dev;
++=======
+ 	info->battery = power_supply_register(&pdev->dev, &pm860x_battery_desc,
+ 					      NULL);
+ 	if (IS_ERR(info->battery))
+ 		return PTR_ERR(info->battery);
+ 	info->battery->dev.parent = &pdev->dev;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	ret = request_threaded_irq(info->irq_cc, NULL,
  				pm860x_coulomb_handler, IRQF_ONESHOT,
@@@ -991,8 -993,7 +1000,12 @@@ static int pm860x_battery_remove(struc
  
  	free_irq(info->irq_batt, info);
  	free_irq(info->irq_cc, info);
++<<<<<<< HEAD
 +	power_supply_unregister(&info->battery);
 +	platform_set_drvdata(pdev, NULL);
++=======
+ 	power_supply_unregister(info->battery);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
diff --cc drivers/power/88pm860x_charger.c
index 36fb4b5a4b0d,a7f32a5b2299..000000000000
--- a/drivers/power/88pm860x_charger.c
+++ b/drivers/power/88pm860x_charger.c
@@@ -685,16 -696,15 +692,27 @@@ static int pm860x_charger_probe(struct 
  	mutex_init(&info->lock);
  	platform_set_drvdata(pdev, info);
  
++<<<<<<< HEAD
 +	info->usb.name = "usb";
 +	info->usb.type = POWER_SUPPLY_TYPE_USB;
 +	info->usb.supplied_to = pm860x_supplied_to;
 +	info->usb.num_supplicants = ARRAY_SIZE(pm860x_supplied_to);
 +	info->usb.properties = pm860x_usb_props;
 +	info->usb.num_properties = ARRAY_SIZE(pm860x_usb_props);
 +	info->usb.get_property = pm860x_usb_get_prop;
 +	ret = power_supply_register(&pdev->dev, &info->usb);
 +	if (ret)
++=======
+ 	psy_cfg.drv_data = info;
+ 	psy_cfg.supplied_to = pm860x_supplied_to;
+ 	psy_cfg.num_supplicants = ARRAY_SIZE(pm860x_supplied_to);
+ 	info->usb = power_supply_register(&pdev->dev, &pm860x_charger_desc,
+ 					  &psy_cfg);
+ 	if (IS_ERR(info->usb)) {
+ 		ret = PTR_ERR(info->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto out;
+ 	}
  
  	pm860x_init_charger(info);
  
@@@ -711,6 -721,7 +729,10 @@@
  	return 0;
  
  out_irq:
++<<<<<<< HEAD
++=======
+ 	power_supply_unregister(info->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	while (--i >= 0)
  		free_irq(info->irq[i], info);
  out:
@@@ -722,8 -733,7 +744,12 @@@ static int pm860x_charger_remove(struc
  	struct pm860x_charger_info *info = platform_get_drvdata(pdev);
  	int i;
  
++<<<<<<< HEAD
 +	platform_set_drvdata(pdev, NULL);
 +	power_supply_unregister(&info->usb);
++=======
+ 	power_supply_unregister(info->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	free_irq(info->irq[0], info);
  	for (i = 0; i < info->irq_nums; i++)
  		free_irq(info->irq[i], info);
diff --cc drivers/power/ab8500_btemp.c
index d412d34bf3df,8f8044e1acf3..000000000000
--- a/drivers/power/ab8500_btemp.c
+++ b/drivers/power/ab8500_btemp.c
@@@ -934,11 -929,11 +929,11 @@@ static int ab8500_btemp_get_ext_psy_dat
  		return 0;
  
  	/* Go through all properties for the psy */
- 	for (j = 0; j < ext->num_properties; j++) {
+ 	for (j = 0; j < ext->desc->num_properties; j++) {
  		enum power_supply_property prop;
- 		prop = ext->properties[j];
+ 		prop = ext->desc->properties[j];
  
 -		if (power_supply_get_property(ext, prop, &ret))
 +		if (ext->get_property(ext, prop, &ret))
  			continue;
  
  		switch (prop) {
@@@ -1044,8 -1039,7 +1039,12 @@@ static int ab8500_btemp_remove(struct p
  	destroy_workqueue(di->btemp_wq);
  
  	flush_scheduled_work();
++<<<<<<< HEAD
 +	power_supply_unregister(&di->btemp_psy);
 +	platform_set_drvdata(pdev, NULL);
++=======
+ 	power_supply_unregister(di->btemp_psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
@@@ -1090,17 -1094,9 +1098,23 @@@ static int ab8500_btemp_probe(struct pl
  
  	di->initialized = false;
  
++<<<<<<< HEAD
 +	/* BTEMP supply */
 +	di->btemp_psy.name = "ab8500_btemp";
 +	di->btemp_psy.type = POWER_SUPPLY_TYPE_BATTERY;
 +	di->btemp_psy.properties = ab8500_btemp_props;
 +	di->btemp_psy.num_properties = ARRAY_SIZE(ab8500_btemp_props);
 +	di->btemp_psy.get_property = ab8500_btemp_get_property;
 +	di->btemp_psy.supplied_to = supply_interface;
 +	di->btemp_psy.num_supplicants = ARRAY_SIZE(supply_interface);
 +	di->btemp_psy.external_power_changed =
 +		ab8500_btemp_external_power_changed;
 +
++=======
+ 	psy_cfg.supplied_to = supply_interface;
+ 	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+ 	psy_cfg.drv_data = di;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	/* Create a work queue for the btemp */
  	di->btemp_wq =
@@@ -1141,9 -1137,11 +1155,16 @@@
  	}
  
  	/* Register BTEMP power supply class */
++<<<<<<< HEAD
 +	ret = power_supply_register(di->dev, &di->btemp_psy);
 +	if (ret) {
++=======
+ 	di->btemp_psy = power_supply_register(di->dev, &ab8500_btemp_desc,
+ 					      &psy_cfg);
+ 	if (IS_ERR(di->btemp_psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(di->dev, "failed to register BTEMP psy\n");
+ 		ret = PTR_ERR(di->btemp_psy);
  		goto free_btemp_wq;
  	}
  
diff --cc drivers/power/ab8500_charger.c
index a558318b169c,e388171f4e58..000000000000
--- a/drivers/power/ab8500_charger.c
+++ b/drivers/power/ab8500_charger.c
@@@ -1945,11 -1953,11 +1945,11 @@@ static int ab8500_charger_get_ext_psy_d
  		return 0;
  
  	/* Go through all properties for the psy */
- 	for (j = 0; j < ext->num_properties; j++) {
+ 	for (j = 0; j < ext->desc->num_properties; j++) {
  		enum power_supply_property prop;
- 		prop = ext->properties[j];
+ 		prop = ext->desc->properties[j];
  
 -		if (power_supply_get_property(ext, prop, &ret))
 +		if (ext->get_property(ext, prop, &ret))
  			continue;
  
  		switch (prop) {
@@@ -3420,13 -3428,11 +3420,13 @@@ static int ab8500_charger_remove(struc
  
  	flush_scheduled_work();
  	if (di->usb_chg.enabled)
- 		power_supply_unregister(&di->usb_chg.psy);
+ 		power_supply_unregister(di->usb_chg.psy);
  
  	if (di->ac_chg.enabled && !di->ac_chg.external)
- 		power_supply_unregister(&di->ac_chg.psy);
+ 		power_supply_unregister(di->ac_chg.psy);
  
 +	platform_set_drvdata(pdev, NULL);
 +
  	return 0;
  }
  
@@@ -3440,6 -3462,7 +3456,10 @@@ static int ab8500_charger_probe(struct 
  {
  	struct device_node *np = pdev->dev.of_node;
  	struct abx500_bm_data *plat = pdev->dev.platform_data;
++<<<<<<< HEAD
++=======
+ 	struct power_supply_config ac_psy_cfg = {}, usb_psy_cfg = {};
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	struct ab8500_charger *di;
  	int irq, i, charger_status, ret = 0, ch_stat;
  
@@@ -3477,15 -3500,15 +3497,27 @@@
  	di->autopower = false;
  	di->invalid_charger_detect_state = 0;
  
++<<<<<<< HEAD
 +	/* AC supply */
 +	/* power_supply base class */
 +	di->ac_chg.psy.name = "ab8500_ac";
 +	di->ac_chg.psy.type = POWER_SUPPLY_TYPE_MAINS;
 +	di->ac_chg.psy.properties = ab8500_charger_ac_props;
 +	di->ac_chg.psy.num_properties = ARRAY_SIZE(ab8500_charger_ac_props);
 +	di->ac_chg.psy.get_property = ab8500_charger_ac_get_property;
 +	di->ac_chg.psy.supplied_to = supply_interface;
 +	di->ac_chg.psy.num_supplicants = ARRAY_SIZE(supply_interface),
++=======
+ 	/* AC and USB supply config */
+ 	ac_psy_cfg.supplied_to = supply_interface;
+ 	ac_psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+ 	ac_psy_cfg.drv_data = &di->ac_chg;
+ 	usb_psy_cfg.supplied_to = supply_interface;
+ 	usb_psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+ 	usb_psy_cfg.drv_data = &di->usb_chg;
+ 
+ 	/* AC supply */
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	/* ux500_charger sub-class */
  	di->ac_chg.ops.enable = &ab8500_charger_ac_en;
  	di->ac_chg.ops.check_enable = &ab8500_charger_ac_check_enable;
@@@ -3505,14 -3528,6 +3537,17 @@@
  			&charger_notifier_list, &charger_nb);
  
  	/* USB supply */
++<<<<<<< HEAD
 +	/* power_supply base class */
 +	di->usb_chg.psy.name = "ab8500_usb";
 +	di->usb_chg.psy.type = POWER_SUPPLY_TYPE_USB;
 +	di->usb_chg.psy.properties = ab8500_charger_usb_props;
 +	di->usb_chg.psy.num_properties = ARRAY_SIZE(ab8500_charger_usb_props);
 +	di->usb_chg.psy.get_property = ab8500_charger_usb_get_property;
 +	di->usb_chg.psy.supplied_to = supply_interface;
 +	di->usb_chg.psy.num_supplicants = ARRAY_SIZE(supply_interface),
++=======
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	/* ux500_charger sub-class */
  	di->usb_chg.ops.enable = &ab8500_charger_usb_en;
  	di->usb_chg.ops.check_enable = &ab8500_charger_usb_check_enable;
@@@ -3610,18 -3625,24 +3645,34 @@@
  
  	/* Register AC charger class */
  	if (di->ac_chg.enabled) {
++<<<<<<< HEAD
 +		ret = power_supply_register(di->dev, &di->ac_chg.psy);
 +		if (ret) {
++=======
+ 		di->ac_chg.psy = power_supply_register(di->dev,
+ 						       &ab8500_ac_chg_desc,
+ 						       &ac_psy_cfg);
+ 		if (IS_ERR(di->ac_chg.psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			dev_err(di->dev, "failed to register AC charger\n");
+ 			ret = PTR_ERR(di->ac_chg.psy);
  			goto free_charger_wq;
  		}
  	}
  
  	/* Register USB charger class */
  	if (di->usb_chg.enabled) {
++<<<<<<< HEAD
 +		ret = power_supply_register(di->dev, &di->usb_chg.psy);
 +		if (ret) {
++=======
+ 		di->usb_chg.psy = power_supply_register(di->dev,
+ 							&ab8500_usb_chg_desc,
+ 							&usb_psy_cfg);
+ 		if (IS_ERR(di->usb_chg.psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			dev_err(di->dev, "failed to register USB charger\n");
+ 			ret = PTR_ERR(di->usb_chg.psy);
  			goto free_ac;
  		}
  	}
diff --cc drivers/power/ab8500_fg.c
index c5391f5c372d,3830dade5d69..000000000000
--- a/drivers/power/ab8500_fg.c
+++ b/drivers/power/ab8500_fg.c
@@@ -2195,11 -2191,11 +2190,11 @@@ static int ab8500_fg_get_ext_psy_data(s
  		return 0;
  
  	/* Go through all properties for the psy */
- 	for (j = 0; j < ext->num_properties; j++) {
+ 	for (j = 0; j < ext->desc->num_properties; j++) {
  		enum power_supply_property prop;
- 		prop = ext->properties[j];
+ 		prop = ext->desc->properties[j];
  
 -		if (power_supply_get_property(ext, prop, &ret))
 +		if (ext->get_property(ext, prop, &ret))
  			continue;
  
  		switch (prop) {
@@@ -2967,43 -2921,38 +2934,61 @@@ static struct device_attribute ab8505_f
  		ab8505_powercut_enable_status_read, NULL),
  };
  
 -static int ab8500_fg_sysfs_psy_create_attrs(struct ab8500_fg *di)
 +static int ab8500_fg_sysfs_psy_create_attrs(struct device *dev)
  {
 -	unsigned int i;
 +	unsigned int i, j;
 +	struct power_supply *psy = dev_get_drvdata(dev);
 +	struct ab8500_fg *di;
 +
 +	di = to_ab8500_fg_device_info(psy);
  
  	if (((is_ab8505(di->parent) || is_ab9540(di->parent)) &&
 -	     abx500_get_chip_id(di->dev) >= AB8500_CUT2P0)
 +	     abx500_get_chip_id(dev->parent) >= AB8500_CUT2P0)
  	    || is_ab8540(di->parent)) {
++<<<<<<< HEAD
 +		for (j = 0; j < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); j++)
 +			if (device_create_file(dev, &ab8505_fg_sysfs_psy_attrs[j]))
++=======
+ 		for (i = 0; i < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); i++)
+ 			if (device_create_file(&di->fg_psy->dev,
+ 					       &ab8505_fg_sysfs_psy_attrs[i]))
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  				goto sysfs_psy_create_attrs_failed_ab8505;
  	}
  	return 0;
  sysfs_psy_create_attrs_failed_ab8505:
++<<<<<<< HEAD
 +	dev_err(dev, "Failed creating sysfs psy attrs for ab8505.\n");
 +	while (j--)
 +		device_remove_file(dev, &ab8505_fg_sysfs_psy_attrs[i]);
++=======
+ 	dev_err(&di->fg_psy->dev, "Failed creating sysfs psy attrs for ab8505.\n");
+ 	while (i--)
+ 		device_remove_file(&di->fg_psy->dev,
+ 				   &ab8505_fg_sysfs_psy_attrs[i]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return -EIO;
  }
  
 -static void ab8500_fg_sysfs_psy_remove_attrs(struct ab8500_fg *di)
 +static void ab8500_fg_sysfs_psy_remove_attrs(struct device *dev)
  {
  	unsigned int i;
 +	struct power_supply *psy = dev_get_drvdata(dev);
 +	struct ab8500_fg *di;
 +
 +	di = to_ab8500_fg_device_info(psy);
  
  	if (((is_ab8505(di->parent) || is_ab9540(di->parent)) &&
 -	     abx500_get_chip_id(di->dev) >= AB8500_CUT2P0)
 +	     abx500_get_chip_id(dev->parent) >= AB8500_CUT2P0)
  	    || is_ab8540(di->parent)) {
  		for (i = 0; i < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); i++)
++<<<<<<< HEAD
 +			(void)device_remove_file(dev, &ab8505_fg_sysfs_psy_attrs[i]);
++=======
+ 			(void)device_remove_file(&di->fg_psy->dev,
+ 						 &ab8505_fg_sysfs_psy_attrs[i]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
  }
  
@@@ -3068,9 -3017,8 +3053,14 @@@ static int ab8500_fg_remove(struct plat
  	ab8500_fg_sysfs_exit(di);
  
  	flush_scheduled_work();
++<<<<<<< HEAD
 +	ab8500_fg_sysfs_psy_remove_attrs(di->fg_psy.dev);
 +	power_supply_unregister(&di->fg_psy);
 +	platform_set_drvdata(pdev, NULL);
++=======
+ 	ab8500_fg_sysfs_psy_remove_attrs(di);
+ 	power_supply_unregister(di->fg_psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return ret;
  }
  
@@@ -3123,14 -3084,9 +3122,20 @@@ static int ab8500_fg_probe(struct platf
  	di->parent = dev_get_drvdata(pdev->dev.parent);
  	di->gpadc = ab8500_gpadc_get("ab8500-gpadc.0");
  
++<<<<<<< HEAD
 +	di->fg_psy.name = "ab8500_fg";
 +	di->fg_psy.type = POWER_SUPPLY_TYPE_BATTERY;
 +	di->fg_psy.properties = ab8500_fg_props;
 +	di->fg_psy.num_properties = ARRAY_SIZE(ab8500_fg_props);
 +	di->fg_psy.get_property = ab8500_fg_get_property;
 +	di->fg_psy.supplied_to = supply_interface;
 +	di->fg_psy.num_supplicants = ARRAY_SIZE(supply_interface),
 +	di->fg_psy.external_power_changed = ab8500_fg_external_power_changed;
++=======
+ 	psy_cfg.supplied_to = supply_interface;
+ 	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+ 	psy_cfg.drv_data = di;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	di->bat_cap.max_mah_design = MILLI_TO_MICRO *
  		di->bm->bat_type[di->bm->batt_id].charge_full_design;
@@@ -3191,9 -3147,10 +3196,15 @@@
  	di->flags.batt_id_received = false;
  
  	/* Register FG power supply class */
++<<<<<<< HEAD
 +	ret = power_supply_register(di->dev, &di->fg_psy);
 +	if (ret) {
++=======
+ 	di->fg_psy = power_supply_register(di->dev, &ab8500_fg_desc, &psy_cfg);
+ 	if (IS_ERR(di->fg_psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(di->dev, "failed to register FG psy\n");
+ 		ret = PTR_ERR(di->fg_psy);
  		goto free_inst_curr_wq;
  	}
  
@@@ -3256,13 -3228,15 +3267,13 @@@
  	return ret;
  
  free_irq:
- 	power_supply_unregister(&di->fg_psy);
+ 	power_supply_unregister(di->fg_psy);
  
 -	/* We also have to free all registered irqs */
 -	for (i = 0; i < ARRAY_SIZE(ab8500_fg_irq_th); i++) {
 -		irq = platform_get_irq_byname(pdev, ab8500_fg_irq_th[i].name);
 +	/* We also have to free all successfully registered irqs */
 +	for (i = i - 1; i >= 0; i--) {
 +		irq = platform_get_irq_byname(pdev, ab8500_fg_irq[i].name);
  		free_irq(irq, di);
  	}
 -	irq = platform_get_irq_byname(pdev, ab8500_fg_irq_bh[0].name);
 -	free_irq(irq, di);
  free_inst_curr_wq:
  	destroy_workqueue(di->fg_wq);
  	return ret;
diff --cc drivers/power/abx500_chargalg.c
index 9863e423602c,541f702e0451..000000000000
--- a/drivers/power/abx500_chargalg.c
+++ b/drivers/power/abx500_chargalg.c
@@@ -1007,19 -1004,21 +1004,21 @@@ static int abx500_chargalg_get_ext_psy_
  	}
  
  	/* Go through all properties for the psy */
- 	for (j = 0; j < ext->num_properties; j++) {
+ 	for (j = 0; j < ext->desc->num_properties; j++) {
  		enum power_supply_property prop;
- 		prop = ext->properties[j];
+ 		prop = ext->desc->properties[j];
  
- 		/* Initialize chargers if not already done */
+ 		/*
+ 		 * Initialize chargers if not already done.
+ 		 * The ab8500_charger*/
  		if (!di->ac_chg &&
- 			ext->type == POWER_SUPPLY_TYPE_MAINS)
+ 			ext->desc->type == POWER_SUPPLY_TYPE_MAINS)
  			di->ac_chg = psy_to_ux500_charger(ext);
  		else if (!di->usb_chg &&
- 			ext->type == POWER_SUPPLY_TYPE_USB)
+ 			ext->desc->type == POWER_SUPPLY_TYPE_USB)
  			di->usb_chg = psy_to_ux500_charger(ext);
  
 -		if (power_supply_get_property(ext, prop, &ret))
 +		if (ext->get_property(ext, prop, &ret))
  			continue;
  		switch (prop) {
  		case POWER_SUPPLY_PROP_PRESENT:
@@@ -2034,8 -2031,7 +2031,12 @@@ static int abx500_chargalg_remove(struc
  	/* Delete the work queue */
  	destroy_workqueue(di->chargalg_wq);
  
++<<<<<<< HEAD
 +	power_supply_unregister(&di->chargalg_psy);
 +	platform_set_drvdata(pdev, NULL);
++=======
+ 	power_supply_unregister(di->chargalg_psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
@@@ -2075,16 -2081,9 +2085,22 @@@ static int abx500_chargalg_probe(struc
  	di->dev = &pdev->dev;
  	di->parent = dev_get_drvdata(pdev->dev.parent);
  
++<<<<<<< HEAD
 +	/* chargalg supply */
 +	di->chargalg_psy.name = "abx500_chargalg";
 +	di->chargalg_psy.type = POWER_SUPPLY_TYPE_BATTERY;
 +	di->chargalg_psy.properties = abx500_chargalg_props;
 +	di->chargalg_psy.num_properties = ARRAY_SIZE(abx500_chargalg_props);
 +	di->chargalg_psy.get_property = abx500_chargalg_get_property;
 +	di->chargalg_psy.supplied_to = supply_interface;
 +	di->chargalg_psy.num_supplicants = ARRAY_SIZE(supply_interface),
 +	di->chargalg_psy.external_power_changed =
 +		abx500_chargalg_external_power_changed;
++=======
+ 	psy_cfg.supplied_to = supply_interface;
+ 	psy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);
+ 	psy_cfg.drv_data = di;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	/* Initilialize safety timer */
  	hrtimer_init(&di->safety_timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);
@@@ -2116,9 -2115,11 +2132,16 @@@
  	di->chg_info.prev_conn_chg = -1;
  
  	/* Register chargalg power supply class */
++<<<<<<< HEAD
 +	ret = power_supply_register(di->dev, &di->chargalg_psy);
 +	if (ret) {
++=======
+ 	di->chargalg_psy = power_supply_register(di->dev, &abx500_chargalg_desc,
+ 						 &psy_cfg);
+ 	if (IS_ERR(di->chargalg_psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(di->dev, "failed to register chargalg psy\n");
+ 		ret = PTR_ERR(di->chargalg_psy);
  		goto free_chargalg_wq;
  	}
  
diff --cc drivers/power/bq2415x_charger.c
index 0727f9256138,c745d278815d..000000000000
--- a/drivers/power/bq2415x_charger.c
+++ b/drivers/power/bq2415x_charger.c
@@@ -168,10 -166,13 +168,11 @@@ static char *bq2415x_chip_name[] = 
  struct bq2415x_device {
  	struct device *dev;
  	struct bq2415x_platform_data init_data;
- 	struct power_supply charger;
+ 	struct power_supply *charger;
+ 	struct power_supply_desc charger_desc;
  	struct delayed_work work;
 -	struct power_supply *notify_psy;
 -	struct notifier_block nb;
  	enum bq2415x_mode reported_mode;/* mode reported by hook function */
 -	enum bq2415x_mode mode;		/* currently configured mode */
 +	enum bq2415x_mode mode;		/* current configured mode */
  	enum bq2415x_chip chip;
  	const char *timer_error;
  	char *model;
@@@ -857,6 -886,11 +858,14 @@@ static void bq2415x_timer_work(struct w
  	int error;
  	int boost;
  
++<<<<<<< HEAD
++=======
+ 	if (bq->automode > 0 && (bq->reported_mode != bq->mode)) {
+ 		sysfs_notify(&bq->charger->dev.kobj, NULL, "reported_mode");
+ 		bq2415x_set_mode(bq, bq->reported_mode);
+ 	}
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	if (!bq->autotimer)
  		return;
  
@@@ -1019,10 -1054,11 +1029,16 @@@ static int bq2415x_power_supply_init(st
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(bq->dev, &bq->charger);
 +	if (ret) {
++=======
+ 	bq->charger = power_supply_register(bq->dev, &bq->charger_desc,
+ 					    &psy_cfg);
+ 	if (IS_ERR(bq->charger)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		kfree(bq->model);
- 		return ret;
+ 		return PTR_ERR(bq->charger);
  	}
  
  	return 0;
diff --cc drivers/power/bq27x00_battery.c
index 26037ca7efb4,a57433de5c24..000000000000
--- a/drivers/power/bq27x00_battery.c
+++ b/drivers/power/bq27x00_battery.c
@@@ -454,10 -530,11 +454,17 @@@ static void bq27x00_update(struct bq27x
  			di->charge_design_full = bq27x00_battery_read_ilmd(di);
  	}
  
++<<<<<<< HEAD
 +	if (memcmp(&di->cache, &cache, sizeof(cache)) != 0) {
++=======
+ 	if (di->cache.capacity != cache.capacity)
+ 		power_supply_changed(di->bat);
+ 
+ 	if (memcmp(&di->cache, &cache, sizeof(cache)) != 0)
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		di->cache = cache;
 +		power_supply_changed(&di->bat);
 +	}
  
  	di->last_update = jiffies;
  }
@@@ -690,26 -764,41 +694,51 @@@ static void bq27x00_external_power_chan
  	schedule_delayed_work(&di->work, 0);
  }
  
- static int bq27x00_powersupply_init(struct bq27x00_device_info *di)
+ static int bq27x00_powersupply_init(struct bq27x00_device_info *di,
+ 				    const char *name)
  {
  	int ret;
+ 	struct power_supply_desc *psy_desc;
+ 	struct power_supply_config psy_cfg = { .drv_data = di, };
  
- 	di->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	psy_desc = devm_kzalloc(di->dev, sizeof(*psy_desc), GFP_KERNEL);
+ 	if (!psy_desc)
+ 		return -ENOMEM;
+ 
+ 	psy_desc->name = name;
+ 	psy_desc->type = POWER_SUPPLY_TYPE_BATTERY;
  	if (di->chip == BQ27425) {
++<<<<<<< HEAD
 +		di->bat.properties = bq27425_battery_props;
 +		di->bat.num_properties = ARRAY_SIZE(bq27425_battery_props);
++=======
+ 		psy_desc->properties = bq27425_battery_props;
+ 		psy_desc->num_properties = ARRAY_SIZE(bq27425_battery_props);
+ 	} else if (di->chip == BQ27742) {
+ 		psy_desc->properties = bq27742_battery_props;
+ 		psy_desc->num_properties = ARRAY_SIZE(bq27742_battery_props);
+ 	} else if (di->chip == BQ27510) {
+ 		psy_desc->properties = bq27510_battery_props;
+ 		psy_desc->num_properties = ARRAY_SIZE(bq27510_battery_props);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	} else {
- 		di->bat.properties = bq27x00_battery_props;
- 		di->bat.num_properties = ARRAY_SIZE(bq27x00_battery_props);
+ 		psy_desc->properties = bq27x00_battery_props;
+ 		psy_desc->num_properties = ARRAY_SIZE(bq27x00_battery_props);
  	}
- 	di->bat.get_property = bq27x00_battery_get_property;
- 	di->bat.external_power_changed = bq27x00_external_power_changed;
+ 	psy_desc->get_property = bq27x00_battery_get_property;
+ 	psy_desc->external_power_changed = bq27x00_external_power_changed;
  
  	INIT_DELAYED_WORK(&di->work, bq27x00_battery_poll);
  	mutex_init(&di->lock);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(di->dev, &di->bat);
 +	if (ret) {
++=======
+ 	di->bat = power_supply_register_no_ws(di->dev, psy_desc, &psy_cfg);
+ 	if (IS_ERR(di->bat)) {
+ 		ret = PTR_ERR(di->bat);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(di->dev, "failed to register battery: %d\n", ret);
  		return ret;
  	}
@@@ -801,10 -890,10 +830,10 @@@ static int bq27x00_battery_probe(struc
  	if (!name) {
  		dev_err(&client->dev, "failed to allocate device name\n");
  		retval = -ENOMEM;
- 		goto batt_failed_1;
+ 		goto batt_failed;
  	}
  
 -	di = devm_kzalloc(&client->dev, sizeof(*di), GFP_KERNEL);
 +	di = kzalloc(sizeof(*di), GFP_KERNEL);
  	if (!di) {
  		dev_err(&client->dev, "failed to allocate device info data\n");
  		retval = -ENOMEM;
@@@ -814,22 -903,17 +843,29 @@@
  	di->id = num;
  	di->dev = &client->dev;
  	di->chip = id->driver_data;
- 	di->bat.name = name;
  	di->bus.read = &bq27x00_read_i2c;
  
- 	retval = bq27x00_powersupply_init(di);
+ 	retval = bq27x00_powersupply_init(di, name);
  	if (retval)
++<<<<<<< HEAD
 +		goto batt_failed_3;
++=======
+ 		goto batt_failed;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	i2c_set_clientdata(client, di);
  
  	return 0;
  
++<<<<<<< HEAD
 +batt_failed_3:
 +	kfree(di);
 +batt_failed_2:
 +	kfree(name);
 +batt_failed_1:
++=======
+ batt_failed:
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	mutex_lock(&battery_mutex);
  	idr_remove(&battery_id, num);
  	mutex_unlock(&battery_mutex);
@@@ -933,7 -1015,7 +967,11 @@@ static int bq27000_battery_probe(struc
  {
  	struct bq27x00_device_info *di;
  	struct bq27000_platform_data *pdata = pdev->dev.platform_data;
++<<<<<<< HEAD
 +	int ret;
++=======
+ 	const char *name;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	if (!pdata) {
  		dev_err(&pdev->dev, "no platform_data supplied\n");
@@@ -956,20 -1038,10 +994,24 @@@
  	di->dev = &pdev->dev;
  	di->chip = BQ27000;
  
- 	di->bat.name = pdata->name ?: dev_name(&pdev->dev);
+ 	name = pdata->name ?: dev_name(&pdev->dev);
  	di->bus.read = &bq27000_read_platform;
  
++<<<<<<< HEAD
 +	ret = bq27x00_powersupply_init(di);
 +	if (ret)
 +		goto err_free;
 +
 +	return 0;
 +
 +err_free:
 +	platform_set_drvdata(pdev, NULL);
 +	kfree(di);
 +
 +	return ret;
++=======
+ 	return bq27x00_powersupply_init(di, name);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  }
  
  static int bq27000_battery_remove(struct platform_device *pdev)
diff --cc drivers/power/charger-manager.c
index 98de1ddce458,5c47409c6889..000000000000
--- a/drivers/power/charger-manager.c
+++ b/drivers/power/charger-manager.c
@@@ -766,9 -864,9 +766,8 @@@ static int charger_get_property(struct 
  		enum power_supply_property psp,
  		union power_supply_propval *val)
  {
- 	struct charger_manager *cm = container_of(psy,
- 			struct charger_manager, charger_psy);
+ 	struct charger_manager *cm = power_supply_get_drvdata(psy);
  	struct charger_desc *desc = cm->desc;
 -	struct power_supply *fuel_gauge;
  	int ret = 0;
  	int uV;
  
@@@ -1423,16 -1395,14 +1422,16 @@@ static int charger_manager_register_sys
  				!chargers_externally_control)
  			chargers_externally_control = 0;
  
 -		dev_info(cm->dev, "'%s' regulator's externally_control is %d\n",
 -			 charger->regulator_name, charger->externally_control);
 +		dev_info(cm->dev, "'%s' regulator's externally_control"
 +				"is %d\n", charger->regulator_name,
 +				charger->externally_control);
  
- 		ret = sysfs_create_group(&cm->charger_psy.dev->kobj,
+ 		ret = sysfs_create_group(&cm->charger_psy->dev.kobj,
  					&charger->attr_g);
  		if (ret < 0) {
 -			dev_err(cm->dev, "Cannot create sysfs entry of %s regulator\n",
 -				charger->regulator_name);
 +			dev_err(cm->dev, "Cannot create sysfs entry"
 +					"of %s regulator\n",
 +					charger->regulator_name);
  			ret = -EINVAL;
  			goto err;
  		}
@@@ -1451,47 -1418,215 +1450,244 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int cm_init_thermal_data(struct charger_manager *cm,
+ 		struct power_supply *fuel_gauge)
+ {
+ 	struct charger_desc *desc = cm->desc;
+ 	union power_supply_propval val;
+ 	int ret;
+ 
+ 	/* Verify whether fuel gauge provides battery temperature */
+ 	ret = power_supply_get_property(fuel_gauge,
+ 					POWER_SUPPLY_PROP_TEMP, &val);
+ 
+ 	if (!ret) {
+ 		cm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =
+ 				POWER_SUPPLY_PROP_TEMP;
+ 		cm->charger_psy_desc.num_properties++;
+ 		cm->desc->measure_battery_temp = true;
+ 	}
+ #ifdef CONFIG_THERMAL
+ 	if (ret && desc->thermal_zone) {
+ 		cm->tzd_batt =
+ 			thermal_zone_get_zone_by_name(desc->thermal_zone);
+ 		if (IS_ERR(cm->tzd_batt))
+ 			return PTR_ERR(cm->tzd_batt);
+ 
+ 		/* Use external thermometer */
+ 		cm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =
+ 				POWER_SUPPLY_PROP_TEMP_AMBIENT;
+ 		cm->charger_psy_desc.num_properties++;
+ 		cm->desc->measure_battery_temp = true;
+ 		ret = 0;
+ 	}
+ #endif
+ 	if (cm->desc->measure_battery_temp) {
+ 		/* NOTICE : Default allowable minimum charge temperature is 0 */
+ 		if (!desc->temp_max)
+ 			desc->temp_max = CM_DEFAULT_CHARGE_TEMP_MAX;
+ 		if (!desc->temp_diff)
+ 			desc->temp_diff = CM_DEFAULT_RECHARGE_TEMP_DIFF;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static struct of_device_id charger_manager_match[] = {
+ 	{
+ 		.compatible = "charger-manager",
+ 	},
+ 	{},
+ };
+ 
+ static struct charger_desc *of_cm_parse_desc(struct device *dev)
+ {
+ 	struct charger_desc *desc;
+ 	struct device_node *np = dev->of_node;
+ 	u32 poll_mode = CM_POLL_DISABLE;
+ 	u32 battery_stat = CM_NO_BATTERY;
+ 	int num_chgs = 0;
+ 
+ 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+ 	if (!desc)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	of_property_read_string(np, "cm-name", &desc->psy_name);
+ 
+ 	of_property_read_u32(np, "cm-poll-mode", &poll_mode);
+ 	desc->polling_mode = poll_mode;
+ 
+ 	of_property_read_u32(np, "cm-poll-interval",
+ 				&desc->polling_interval_ms);
+ 
+ 	of_property_read_u32(np, "cm-fullbatt-vchkdrop-ms",
+ 					&desc->fullbatt_vchkdrop_ms);
+ 	of_property_read_u32(np, "cm-fullbatt-vchkdrop-volt",
+ 					&desc->fullbatt_vchkdrop_uV);
+ 	of_property_read_u32(np, "cm-fullbatt-voltage", &desc->fullbatt_uV);
+ 	of_property_read_u32(np, "cm-fullbatt-soc", &desc->fullbatt_soc);
+ 	of_property_read_u32(np, "cm-fullbatt-capacity",
+ 					&desc->fullbatt_full_capacity);
+ 
+ 	of_property_read_u32(np, "cm-battery-stat", &battery_stat);
+ 	desc->battery_present = battery_stat;
+ 
+ 	/* chargers */
+ 	of_property_read_u32(np, "cm-num-chargers", &num_chgs);
+ 	if (num_chgs) {
+ 		/* Allocate empty bin at the tail of array */
+ 		desc->psy_charger_stat = devm_kzalloc(dev, sizeof(char *)
+ 						* (num_chgs + 1), GFP_KERNEL);
+ 		if (desc->psy_charger_stat) {
+ 			int i;
+ 			for (i = 0; i < num_chgs; i++)
+ 				of_property_read_string_index(np, "cm-chargers",
+ 						i, &desc->psy_charger_stat[i]);
+ 		} else {
+ 			return ERR_PTR(-ENOMEM);
+ 		}
+ 	}
+ 
+ 	of_property_read_string(np, "cm-fuel-gauge", &desc->psy_fuel_gauge);
+ 
+ 	of_property_read_string(np, "cm-thermal-zone", &desc->thermal_zone);
+ 
+ 	of_property_read_u32(np, "cm-battery-cold", &desc->temp_min);
+ 	if (of_get_property(np, "cm-battery-cold-in-minus", NULL))
+ 		desc->temp_min *= -1;
+ 	of_property_read_u32(np, "cm-battery-hot", &desc->temp_max);
+ 	of_property_read_u32(np, "cm-battery-temp-diff", &desc->temp_diff);
+ 
+ 	of_property_read_u32(np, "cm-charging-max",
+ 				&desc->charging_max_duration_ms);
+ 	of_property_read_u32(np, "cm-discharging-max",
+ 				&desc->discharging_max_duration_ms);
+ 
+ 	/* battery charger regualtors */
+ 	desc->num_charger_regulators = of_get_child_count(np);
+ 	if (desc->num_charger_regulators) {
+ 		struct charger_regulator *chg_regs;
+ 		struct device_node *child;
+ 
+ 		chg_regs = devm_kzalloc(dev, sizeof(*chg_regs)
+ 					* desc->num_charger_regulators,
+ 					GFP_KERNEL);
+ 		if (!chg_regs)
+ 			return ERR_PTR(-ENOMEM);
+ 
+ 		desc->charger_regulators = chg_regs;
+ 
+ 		for_each_child_of_node(np, child) {
+ 			struct charger_cable *cables;
+ 			struct device_node *_child;
+ 
+ 			of_property_read_string(child, "cm-regulator-name",
+ 					&chg_regs->regulator_name);
+ 
+ 			/* charger cables */
+ 			chg_regs->num_cables = of_get_child_count(child);
+ 			if (chg_regs->num_cables) {
+ 				cables = devm_kzalloc(dev, sizeof(*cables)
+ 						* chg_regs->num_cables,
+ 						GFP_KERNEL);
+ 				if (!cables)
+ 					return ERR_PTR(-ENOMEM);
+ 
+ 				chg_regs->cables = cables;
+ 
+ 				for_each_child_of_node(child, _child) {
+ 					of_property_read_string(_child,
+ 					"cm-cable-name", &cables->name);
+ 					of_property_read_string(_child,
+ 					"cm-cable-extcon",
+ 					&cables->extcon_name);
+ 					of_property_read_u32(_child,
+ 					"cm-cable-min",
+ 					&cables->min_uA);
+ 					of_property_read_u32(_child,
+ 					"cm-cable-max",
+ 					&cables->max_uA);
+ 					cables++;
+ 				}
+ 			}
+ 			chg_regs++;
+ 		}
+ 	}
+ 	return desc;
+ }
+ 
+ static inline struct charger_desc *cm_get_drv_data(struct platform_device *pdev)
+ {
+ 	if (pdev->dev.of_node)
+ 		return of_cm_parse_desc(&pdev->dev);
+ 	return dev_get_platdata(&pdev->dev);
+ }
+ 
+ static enum alarmtimer_restart cm_timer_func(struct alarm *alarm, ktime_t now)
+ {
+ 	cm_timer_set = false;
+ 	return ALARMTIMER_NORESTART;
+ }
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  static int charger_manager_probe(struct platform_device *pdev)
  {
 -	struct charger_desc *desc = cm_get_drv_data(pdev);
 +	struct charger_desc *desc = dev_get_platdata(&pdev->dev);
  	struct charger_manager *cm;
  	int ret = 0, i = 0;
  	int j = 0;
  	union power_supply_propval val;
++<<<<<<< HEAD
++=======
+ 	struct power_supply *fuel_gauge;
+ 	struct power_supply_config psy_cfg = {};
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
 +
 +	if (g_desc && !rtc_dev && g_desc->rtc_name) {
 +		rtc_dev = rtc_class_open(g_desc->rtc_name);
 +		if (IS_ERR_OR_NULL(rtc_dev)) {
 +			rtc_dev = NULL;
 +			dev_err(&pdev->dev, "Cannot get RTC %s.\n",
 +				g_desc->rtc_name);
 +			ret = -ENODEV;
 +			goto err_alloc;
 +		}
 +	}
  
 -	if (IS_ERR(desc)) {
 -		dev_err(&pdev->dev, "No platform data (desc) found\n");
 -		return -ENODEV;
 +	if (!desc) {
 +		dev_err(&pdev->dev, "No platform data (desc) found.\n");
 +		ret = -ENODEV;
 +		goto err_alloc;
  	}
  
 -	cm = devm_kzalloc(&pdev->dev,
 -			sizeof(struct charger_manager),	GFP_KERNEL);
 -	if (!cm)
 -		return -ENOMEM;
 +	cm = kzalloc(sizeof(struct charger_manager), GFP_KERNEL);
 +	if (!cm) {
 +		dev_err(&pdev->dev, "Cannot allocate memory.\n");
 +		ret = -ENOMEM;
 +		goto err_alloc;
 +	}
  
  	/* Basic Values. Unspecified are Null or 0 */
  	cm->dev = &pdev->dev;
++<<<<<<< HEAD
 +	cm->desc = kmemdup(desc, sizeof(struct charger_desc), GFP_KERNEL);
 +	if (!cm->desc) {
 +		dev_err(&pdev->dev, "Cannot allocate memory.\n");
 +		ret = -ENOMEM;
 +		goto err_alloc_desc;
++=======
+ 	cm->desc = desc;
+ 	psy_cfg.drv_data = cm;
+ 
+ 	/* Initialize alarm timer */
+ 	if (alarmtimer_get_rtcdev()) {
+ 		cm_timer = devm_kzalloc(cm->dev, sizeof(*cm_timer), GFP_KERNEL);
+ 		alarm_init(cm_timer, ALARM_BOOTTIME, cm_timer_func);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
 +	cm->last_temp_mC = INT_MIN; /* denotes "unmeasured, yet" */
  
  	/*
  	 * The following two do not need to be errors.
@@@ -1590,55 -1706,50 +1786,75 @@@
  		strncpy(cm->psy_name_buf, psy_default.name, PSY_NAME_MAX);
  	else
  		strncpy(cm->psy_name_buf, desc->psy_name, PSY_NAME_MAX);
- 	cm->charger_psy.name = cm->psy_name_buf;
+ 	cm->charger_psy_desc.name = cm->psy_name_buf;
  
  	/* Allocate for psy properties because they may vary */
++<<<<<<< HEAD
 +	cm->charger_psy.properties = kzalloc(sizeof(enum power_supply_property)
 +				* (ARRAY_SIZE(default_charger_props) +
 +				NUM_CHARGER_PSY_OPTIONAL),
 +				GFP_KERNEL);
 +	if (!cm->charger_psy.properties) {
 +		dev_err(&pdev->dev, "Cannot allocate for psy properties.\n");
 +		ret = -ENOMEM;
 +		goto err_chg_stat;
 +	}
 +	memcpy(cm->charger_psy.properties, default_charger_props,
++=======
+ 	cm->charger_psy_desc.properties = devm_kzalloc(&pdev->dev,
+ 				sizeof(enum power_supply_property)
+ 				* (ARRAY_SIZE(default_charger_props) +
+ 				NUM_CHARGER_PSY_OPTIONAL), GFP_KERNEL);
+ 	if (!cm->charger_psy_desc.properties)
+ 		return -ENOMEM;
+ 
+ 	memcpy(cm->charger_psy_desc.properties, default_charger_props,
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		sizeof(enum power_supply_property) *
  		ARRAY_SIZE(default_charger_props));
- 	cm->charger_psy.num_properties = psy_default.num_properties;
+ 	cm->charger_psy_desc.num_properties = psy_default.num_properties;
  
  	/* Find which optional psy-properties are available */
 -	if (!power_supply_get_property(fuel_gauge,
 +	if (!cm->fuel_gauge->get_property(cm->fuel_gauge,
  					  POWER_SUPPLY_PROP_CHARGE_NOW, &val)) {
- 		cm->charger_psy.properties[cm->charger_psy.num_properties] =
+ 		cm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =
  				POWER_SUPPLY_PROP_CHARGE_NOW;
- 		cm->charger_psy.num_properties++;
+ 		cm->charger_psy_desc.num_properties++;
  	}
 -	if (!power_supply_get_property(fuel_gauge,
 +	if (!cm->fuel_gauge->get_property(cm->fuel_gauge,
  					  POWER_SUPPLY_PROP_CURRENT_NOW,
  					  &val)) {
- 		cm->charger_psy.properties[cm->charger_psy.num_properties] =
+ 		cm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =
  				POWER_SUPPLY_PROP_CURRENT_NOW;
- 		cm->charger_psy.num_properties++;
+ 		cm->charger_psy_desc.num_properties++;
  	}
  
 -	ret = cm_init_thermal_data(cm, fuel_gauge);
 -	if (ret) {
 -		dev_err(&pdev->dev, "Failed to initialize thermal data\n");
 -		cm->desc->measure_battery_temp = false;
 +	if (desc->measure_battery_temp) {
 +		cm->charger_psy.properties[cm->charger_psy.num_properties] =
 +				POWER_SUPPLY_PROP_TEMP;
 +		cm->charger_psy.num_properties++;
 +	} else {
 +		cm->charger_psy.properties[cm->charger_psy.num_properties] =
 +				POWER_SUPPLY_PROP_TEMP_AMBIENT;
 +		cm->charger_psy.num_properties++;
  	}
  
  	INIT_DELAYED_WORK(&cm->fullbatt_vchk_work, fullbatt_vchk);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(NULL, &cm->charger_psy);
 +	if (ret) {
 +		dev_err(&pdev->dev, "Cannot register charger-manager with"
 +				" name \"%s\".\n", cm->charger_psy.name);
 +		goto err_register;
++=======
+ 	cm->charger_psy = power_supply_register(NULL, &cm->charger_psy_desc,
+ 						&psy_cfg);
+ 	if (IS_ERR(cm->charger_psy)) {
+ 		dev_err(&pdev->dev, "Cannot register charger-manager with name \"%s\"\n",
+ 			cm->charger_psy->desc->name);
+ 		return PTR_ERR(cm->charger_psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
  
  	/* Register extcon device for charger cable */
@@@ -1677,10 -1795,8 +1893,10 @@@ err_reg_sysfs
  		struct charger_regulator *charger;
  
  		charger = &desc->charger_regulators[i];
- 		sysfs_remove_group(&cm->charger_psy.dev->kobj,
+ 		sysfs_remove_group(&cm->charger_psy->dev.kobj,
  				&charger->attr_g);
 +
 +		kfree(charger->attr_g.name);
  	}
  err_reg_extcon:
  	for (i = 0; i < desc->num_charger_regulators; i++) {
@@@ -1695,17 -1813,8 +1911,22 @@@
  		regulator_put(desc->charger_regulators[i].consumer);
  	}
  
++<<<<<<< HEAD
 +	power_supply_unregister(&cm->charger_psy);
 +err_register:
 +	kfree(cm->charger_psy.properties);
 +err_chg_stat:
 +	kfree(cm->charger_stat);
 +err_no_charger_stat:
 +err_no_charger:
 +	kfree(cm->desc);
 +err_alloc_desc:
 +	kfree(cm);
 +err_alloc:
++=======
+ 	power_supply_unregister(cm->charger_psy);
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return ret;
  }
  
@@@ -1896,8 -2003,8 +2117,13 @@@ static bool find_power_supply(struct ch
  	int i;
  	bool found = false;
  
++<<<<<<< HEAD
 +	for (i = 0; cm->charger_stat[i]; i++) {
 +		if (psy == cm->charger_stat[i]) {
++=======
+ 	for (i = 0; cm->desc->psy_charger_stat[i]; i++) {
+ 		if (!strcmp(psy->desc->name, cm->desc->psy_charger_stat[i])) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			found = true;
  			break;
  		}
diff --cc drivers/power/collie_battery.c
index c58d0e31bdef,2da9ed8ccbb5..000000000000
--- a/drivers/power/collie_battery.c
+++ b/drivers/power/collie_battery.c
@@@ -323,24 -338,40 +327,56 @@@ static int collie_bat_probe(struct ucb1
  
  	INIT_WORK(&bat_work, collie_bat_work);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&dev->ucb->dev, &collie_bat_main.psy);
 +	if (ret)
 +		goto err_psy_reg_main;
 +	ret = power_supply_register(&dev->ucb->dev, &collie_bat_bu.psy);
 +	if (ret)
++=======
+ 	psy_main_cfg.drv_data = &collie_bat_main;
+ 	collie_bat_main.psy = power_supply_register(&dev->ucb->dev,
+ 						    &collie_bat_main_desc,
+ 						    &psy_main_cfg);
+ 	if (IS_ERR(collie_bat_main.psy)) {
+ 		ret = PTR_ERR(collie_bat_main.psy);
+ 		goto err_psy_reg_main;
+ 	}
+ 
+ 	psy_main_cfg.drv_data = &collie_bat_bu;
+ 	collie_bat_bu.psy = power_supply_register(&dev->ucb->dev,
+ 						  &collie_bat_bu_desc,
+ 						  &psy_bu_cfg);
+ 	if (IS_ERR(collie_bat_bu.psy)) {
+ 		ret = PTR_ERR(collie_bat_bu.psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_psy_reg_bu;
+ 	}
  
  	ret = request_irq(gpio_to_irq(COLLIE_GPIO_CO),
  				collie_bat_gpio_isr,
  				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
  				"main full", &collie_bat_main);
++<<<<<<< HEAD
 +	if (!ret) {
 +		schedule_work(&bat_work);
 +		return 0;
 +	}
 +	power_supply_unregister(&collie_bat_bu.psy);
++=======
+ 	if (ret)
+ 		goto err_irq;
+ 
+ 	device_init_wakeup(&ucb->dev, 1);
+ 	schedule_work(&bat_work);
+ 
+ 	return 0;
+ 
+ err_irq:
+ 	power_supply_unregister(collie_bat_bu.psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  err_psy_reg_bu:
- 	power_supply_unregister(&collie_bat_main.psy);
+ 	power_supply_unregister(collie_bat_main.psy);
  err_psy_reg_main:
  
  	/* see comment in collie_bat_remove */
diff --cc drivers/power/da9030_battery.c
index ae6c41835ee6,5ca0f4d90792..000000000000
--- a/drivers/power/da9030_battery.c
+++ b/drivers/power/da9030_battery.c
@@@ -541,9 -542,13 +542,18 @@@ static int da9030_battery_probe(struct 
  		goto err_notifier;
  
  	da9030_battery_setup_psy(charger);
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &charger->psy);
 +	if (ret)
++=======
+ 	psy_cfg.drv_data = charger;
+ 	charger->psy = power_supply_register(&pdev->dev, &charger->psy_desc,
+ 					     &psy_cfg);
+ 	if (IS_ERR(charger->psy)) {
+ 		ret = PTR_ERR(charger->psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_ps_register;
+ 	}
  
  	charger->debug_file = da9030_bat_create_debugfs(charger);
  	platform_set_drvdata(pdev, charger);
diff --cc drivers/power/da9052-battery.c
index f8f4c0f7c17d,830ec46fe7d0..000000000000
--- a/drivers/power/da9052-battery.c
+++ b/drivers/power/da9052-battery.c
@@@ -625,9 -626,11 +626,16 @@@ static s32 da9052_bat_probe(struct plat
  		}
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &bat->psy);
 +	 if (ret)
++=======
+ 	bat->psy = power_supply_register(&pdev->dev, &psy_desc, &psy_cfg);
+ 	if (IS_ERR(bat->psy)) {
+ 		ret = PTR_ERR(bat->psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err;
+ 	}
  
  	platform_set_drvdata(pdev, bat);
  	return 0;
diff --cc drivers/power/ds2760_battery.c
index 85b4e6eca0b1,80f73ccb77ab..000000000000
--- a/drivers/power/ds2760_battery.c
+++ b/drivers/power/ds2760_battery.c
@@@ -555,9 -556,10 +556,15 @@@ static int ds2760_battery_probe(struct 
  	if (current_accum)
  		ds2760_battery_set_current_accum(di, current_accum);
  
++<<<<<<< HEAD
 +	retval = power_supply_register(&pdev->dev, &di->bat);
 +	if (retval) {
++=======
+ 	di->bat = power_supply_register(&pdev->dev, &di->bat_desc, &psy_cfg);
+ 	if (IS_ERR(di->bat)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(di->dev, "failed to register battery\n");
+ 		retval = PTR_ERR(di->bat);
  		goto batt_failed;
  	}
  
diff --cc drivers/power/ds2780_battery.c
index 9f418fa879e5,a7a0427343f3..000000000000
--- a/drivers/power/ds2780_battery.c
+++ b/drivers/power/ds2780_battery.c
@@@ -770,15 -772,19 +772,24 @@@ static int ds2780_battery_probe(struct 
  
  	dev_info->dev			= &pdev->dev;
  	dev_info->w1_dev		= pdev->dev.parent;
- 	dev_info->bat.name		= dev_name(&pdev->dev);
- 	dev_info->bat.type		= POWER_SUPPLY_TYPE_BATTERY;
- 	dev_info->bat.properties	= ds2780_battery_props;
- 	dev_info->bat.num_properties	= ARRAY_SIZE(ds2780_battery_props);
- 	dev_info->bat.get_property	= ds2780_battery_get_property;
+ 	dev_info->bat_desc.name		= dev_name(&pdev->dev);
+ 	dev_info->bat_desc.type		= POWER_SUPPLY_TYPE_BATTERY;
+ 	dev_info->bat_desc.properties	= ds2780_battery_props;
+ 	dev_info->bat_desc.num_properties = ARRAY_SIZE(ds2780_battery_props);
+ 	dev_info->bat_desc.get_property	= ds2780_battery_get_property;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &dev_info->bat);
 +	if (ret) {
++=======
+ 	psy_cfg.drv_data		= dev_info;
+ 
+ 	dev_info->bat = power_supply_register(&pdev->dev, &dev_info->bat_desc,
+ 					      &psy_cfg);
+ 	if (IS_ERR(dev_info->bat)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(dev_info->dev, "failed to register battery\n");
+ 		ret = PTR_ERR(dev_info->bat);
  		goto fail;
  	}
  
diff --cc drivers/power/ds2781_battery.c
index 0a5acc6fc6f0,56d583dae908..000000000000
--- a/drivers/power/ds2781_battery.c
+++ b/drivers/power/ds2781_battery.c
@@@ -763,15 -765,19 +765,24 @@@ static int ds2781_battery_probe(struct 
  
  	dev_info->dev			= &pdev->dev;
  	dev_info->w1_dev		= pdev->dev.parent;
- 	dev_info->bat.name		= dev_name(&pdev->dev);
- 	dev_info->bat.type		= POWER_SUPPLY_TYPE_BATTERY;
- 	dev_info->bat.properties	= ds2781_battery_props;
- 	dev_info->bat.num_properties	= ARRAY_SIZE(ds2781_battery_props);
- 	dev_info->bat.get_property	= ds2781_battery_get_property;
+ 	dev_info->bat_desc.name		= dev_name(&pdev->dev);
+ 	dev_info->bat_desc.type		= POWER_SUPPLY_TYPE_BATTERY;
+ 	dev_info->bat_desc.properties	= ds2781_battery_props;
+ 	dev_info->bat_desc.num_properties = ARRAY_SIZE(ds2781_battery_props);
+ 	dev_info->bat_desc.get_property	= ds2781_battery_get_property;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &dev_info->bat);
 +	if (ret) {
++=======
+ 	psy_cfg.drv_data		= dev_info;
+ 
+ 	dev_info->bat = power_supply_register(&pdev->dev, &dev_info->bat_desc,
+ 						&psy_cfg);
+ 	if (IS_ERR(dev_info->bat)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(dev_info->dev, "failed to register battery\n");
+ 		ret = PTR_ERR(dev_info->bat);
  		goto fail;
  	}
  
diff --cc drivers/power/ds2782_battery.c
index 563174891c90,ed4d756d21e4..000000000000
--- a/drivers/power/ds2782_battery.c
+++ b/drivers/power/ds2782_battery.c
@@@ -428,9 -428,11 +432,16 @@@ static int ds278x_battery_probe(struct 
  
  	INIT_DELAYED_WORK(&info->bat_work, ds278x_bat_work);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&client->dev, &info->battery);
 +	if (ret) {
++=======
+ 	info->battery = power_supply_register(&client->dev,
+ 					      &info->battery_desc, &psy_cfg);
+ 	if (IS_ERR(info->battery)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&client->dev, "failed to register battery\n");
+ 		ret = PTR_ERR(info->battery);
  		goto fail_register;
  	} else {
  		schedule_delayed_work(&info->bat_work, DS278x_DELAY);
diff --cc drivers/power/generic-adc-battery.c
index 8cb5d7f67ace,fedc5818fab7..000000000000
--- a/drivers/power/generic-adc-battery.c
+++ b/drivers/power/generic-adc-battery.c
@@@ -308,11 -314,13 +312,18 @@@ static int gab_probe(struct platform_de
  	 * as come channels may be not be supported by the device.So
  	 * we need to take care of that.
  	 */
- 	psy->num_properties = ARRAY_SIZE(gab_props) + index;
+ 	psy_desc->num_properties = ARRAY_SIZE(gab_props) + index;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, psy);
 +	if (ret)
++=======
+ 	adc_bat->psy = power_supply_register(&pdev->dev, psy_desc, &psy_cfg);
+ 	if (IS_ERR(adc_bat->psy)) {
+ 		ret = PTR_ERR(adc_bat->psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_reg_fail;
+ 	}
  
  	INIT_DELAYED_WORK(&adc_bat->bat_work, gab_work);
  
diff --cc drivers/power/goldfish_battery.c
index 29eba88a2963,a50bb988c69a..000000000000
--- a/drivers/power/goldfish_battery.c
+++ b/drivers/power/goldfish_battery.c
@@@ -195,14 -197,17 +197,28 @@@ static int goldfish_battery_probe(struc
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &data->ac);
 +	if (ret)
 +		return ret;
 +
 +	ret = power_supply_register(&pdev->dev, &data->battery);
 +	if (ret) {
 +		power_supply_unregister(&data->ac);
 +		return ret;
++=======
+ 	psy_cfg.drv_data = data;
+ 
+ 	data->ac = power_supply_register(&pdev->dev, &ac_desc, &psy_cfg);
+ 	if (IS_ERR(data->ac))
+ 		return PTR_ERR(data->ac);
+ 
+ 	data->battery = power_supply_register(&pdev->dev, &battery_desc,
+ 						&psy_cfg);
+ 	if (IS_ERR(data->battery)) {
+ 		power_supply_unregister(data->ac);
+ 		return PTR_ERR(data->battery);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
  
  	platform_set_drvdata(pdev, data);
diff --cc drivers/power/gpio-charger.c
index e9883eeeee76,c5869b1941ac..000000000000
--- a/drivers/power/gpio-charger.c
+++ b/drivers/power/gpio-charger.c
@@@ -28,8 -30,10 +28,9 @@@
  struct gpio_charger {
  	const struct gpio_charger_platform_data *pdata;
  	unsigned int irq;
 -	bool wakeup_enabled;
  
- 	struct power_supply charger;
+ 	struct power_supply *charger;
+ 	struct power_supply_desc charger_desc;
  };
  
  static irqreturn_t gpio_charger_irq(int irq, void *devid)
@@@ -71,8 -75,62 +72,8 @@@ static enum power_supply_property gpio_
  static int gpio_charger_probe(struct platform_device *pdev)
  {
  	const struct gpio_charger_platform_data *pdata = pdev->dev.platform_data;
 -	struct power_supply_config psy_cfg = {};
  	struct gpio_charger *gpio_charger;
- 	struct power_supply *charger;
+ 	struct power_supply_desc *charger_desc;
  	int ret;
  	int irq;
  
@@@ -93,15 -156,18 +94,28 @@@
  		return -ENOMEM;
  	}
  
- 	charger = &gpio_charger->charger;
+ 	charger_desc = &gpio_charger->charger_desc;
  
++<<<<<<< HEAD
 +	charger->name = pdata->name ? pdata->name : "gpio-charger";
 +	charger->type = pdata->type;
 +	charger->properties = gpio_charger_properties;
 +	charger->num_properties = ARRAY_SIZE(gpio_charger_properties);
 +	charger->get_property = gpio_charger_get_property;
 +	charger->supplied_to = pdata->supplied_to;
 +	charger->num_supplicants = pdata->num_supplicants;
++=======
+ 	charger_desc->name = pdata->name ? pdata->name : "gpio-charger";
+ 	charger_desc->type = pdata->type;
+ 	charger_desc->properties = gpio_charger_properties;
+ 	charger_desc->num_properties = ARRAY_SIZE(gpio_charger_properties);
+ 	charger_desc->get_property = gpio_charger_get_property;
+ 
+ 	psy_cfg.supplied_to = pdata->supplied_to;
+ 	psy_cfg.num_supplicants = pdata->num_supplicants;
+ 	psy_cfg.of_node = pdev->dev.of_node;
+ 	psy_cfg.drv_data = gpio_charger;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	ret = gpio_request(pdata->gpio, dev_name(&pdev->dev));
  	if (ret) {
@@@ -116,8 -182,10 +130,15 @@@
  
  	gpio_charger->pdata = pdata;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, charger);
 +	if (ret < 0) {
++=======
+ 	gpio_charger->charger = power_supply_register(&pdev->dev,
+ 						      charger_desc, &psy_cfg);
+ 	if (IS_ERR(gpio_charger->charger)) {
+ 		ret = PTR_ERR(gpio_charger->charger);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&pdev->dev, "Failed to register power supply: %d\n",
  			ret);
  		goto err_gpio_free;
@@@ -166,7 -245,9 +187,13 @@@ static int gpio_charger_resume(struct d
  	struct platform_device *pdev = to_platform_device(dev);
  	struct gpio_charger *gpio_charger = platform_get_drvdata(pdev);
  
++<<<<<<< HEAD
 +	power_supply_changed(&gpio_charger->charger);
++=======
+ 	if (device_may_wakeup(dev) && gpio_charger->wakeup_enabled)
+ 		disable_irq_wake(gpio_charger->irq);
+ 	power_supply_changed(gpio_charger->charger);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
diff --cc drivers/power/intel_mid_battery.c
index 18d136b443ee,9fa4acc107ca..000000000000
--- a/drivers/power/intel_mid_battery.c
+++ b/drivers/power/intel_mid_battery.c
@@@ -687,13 -706,8 +706,18 @@@ static int probe(int irq, struct devic
  	}
  
  	/* register pmic-batt with power supply subsystem */
++<<<<<<< HEAD
 +	pbi->batt.name = "pmic-batt";
 +	pbi->batt.type = POWER_SUPPLY_TYPE_BATTERY;
 +	pbi->batt.properties = pmic_battery_props;
 +	pbi->batt.num_properties = ARRAY_SIZE(pmic_battery_props);
 +	pbi->batt.get_property = pmic_battery_get_property;
 +	retval = power_supply_register(dev, &pbi->batt);
 +	if (retval) {
++=======
+ 	pbi->batt = power_supply_register(dev, &pmic_usb_desc, &psy_cfg);
+ 	if (IS_ERR(pbi->batt)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(dev,
  			"%s(): failed to register pmic battery device with power supply subsystem\n",
  				__func__);
@@@ -707,13 -722,8 +732,18 @@@
  	queue_delayed_work(pbi->monitor_wqueue, &pbi->monitor_battery, HZ * 1);
  
  	/* register pmic-usb with power supply subsystem */
++<<<<<<< HEAD
 +	pbi->usb.name = "pmic-usb";
 +	pbi->usb.type = POWER_SUPPLY_TYPE_USB;
 +	pbi->usb.properties = pmic_usb_props;
 +	pbi->usb.num_properties = ARRAY_SIZE(pmic_usb_props);
 +	pbi->usb.get_property = pmic_usb_get_property;
 +	retval = power_supply_register(dev, &pbi->usb);
 +	if (retval) {
++=======
+ 	pbi->usb = power_supply_register(dev, &pmic_batt_desc, &psy_cfg);
+ 	if (IS_ERR(pbi->usb)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(dev,
  			"%s(): failed to register pmic usb device with power supply subsystem\n",
  				__func__);
diff --cc drivers/power/isp1704_charger.c
index fc04d191579b,f2a7d970388f..000000000000
--- a/drivers/power/isp1704_charger.c
+++ b/drivers/power/isp1704_charger.c
@@@ -240,50 -248,47 +241,73 @@@ static void isp1704_charger_work(struc
  		container_of(data, struct isp1704_charger, work);
  	static DEFINE_MUTEX(lock);
  
 +	event = isp->event;
 +	power = isp->max_power;
 +
  	mutex_lock(&lock);
  
 -	switch (isp->phy->last_event) {
 +	if (event != USB_EVENT_NONE)
 +		isp1704_charger_set_power(isp, 1);
 +
 +	switch (event) {
  	case USB_EVENT_VBUS:
 -		/* do not call wall charger detection more times */
 -		if (!isp->present) {
 -			isp->online = true;
 -			isp->present = 1;
 -			isp1704_charger_set_power(isp, 1);
 +		isp->online = true;
  
++<<<<<<< HEAD
 +		/* detect charger */
 +		detect = isp1704_charger_detect(isp);
++=======
+ 			/* detect wall charger */
+ 			if (isp1704_charger_detect_dcp(isp)) {
+ 				isp->psy_desc.type = POWER_SUPPLY_TYPE_USB_DCP;
+ 				isp->current_max = 1800;
+ 			} else {
+ 				isp->psy_desc.type = POWER_SUPPLY_TYPE_USB;
+ 				isp->current_max = 500;
+ 			}
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
 -			/* enable data pullups */
 -			if (isp->phy->otg->gadget)
 -				usb_gadget_connect(isp->phy->otg->gadget);
 +		if (detect) {
 +			isp->present = detect;
 +			isp->psy.type = isp1704_charger_type(isp);
  		}
  
++<<<<<<< HEAD
 +		switch (isp->psy.type) {
 +		case POWER_SUPPLY_TYPE_USB_DCP:
 +			isp->current_max = 1800;
 +			break;
 +		case POWER_SUPPLY_TYPE_USB_CDP:
++=======
+ 		if (isp->psy_desc.type != POWER_SUPPLY_TYPE_USB_DCP) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			/*
  			 * Only 500mA here or high speed chirp
  			 * handshaking may break
  			 */
++<<<<<<< HEAD
 +			isp->current_max = 500;
 +			/* FALLTHROUGH */
 +		case POWER_SUPPLY_TYPE_USB:
 +		default:
 +			/* enable data pullups */
 +			if (isp->phy->otg->gadget)
 +				usb_gadget_connect(isp->phy->otg->gadget);
++=======
+ 			if (isp->current_max > 500)
+ 				isp->current_max = 500;
+ 
+ 			if (isp->current_max > 100)
+ 				isp->psy_desc.type = POWER_SUPPLY_TYPE_USB_CDP;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		}
  		break;
  	case USB_EVENT_NONE:
  		isp->online = false;
 +		isp->current_max = 0;
  		isp->present = 0;
  		isp->current_max = 0;
- 		isp->psy.type = POWER_SUPPLY_TYPE_USB;
+ 		isp->psy_desc.type = POWER_SUPPLY_TYPE_USB;
  
  		/*
  		 * Disable data pullups. We need to prevent the controller from
@@@ -410,7 -403,35 +433,8 @@@ static int isp1704_charger_probe(struc
  {
  	struct isp1704_charger	*isp;
  	int			ret = -ENODEV;
+ 	struct power_supply_config psy_cfg = {};
  
 -	struct isp1704_charger_data *pdata = dev_get_platdata(&pdev->dev);
 -	struct device_node *np = pdev->dev.of_node;
 -
 -	if (np) {
 -		int gpio = of_get_named_gpio(np, "nxp,enable-gpio", 0);
 -
 -		if (gpio < 0)
 -			return gpio;
 -
 -		pdata = devm_kzalloc(&pdev->dev,
 -			sizeof(struct isp1704_charger_data), GFP_KERNEL);
 -		pdata->enable_gpio = gpio;
 -
 -		dev_info(&pdev->dev, "init gpio %d\n", pdata->enable_gpio);
 -
 -		ret = devm_gpio_request_one(&pdev->dev, pdata->enable_gpio,
 -					GPIOF_OUT_INIT_HIGH, "isp1704_reset");
 -		if (ret)
 -			goto fail0;
 -	}
 -
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "missing platform data!\n");
 -		return -ENODEV;
 -	}
 -
 -
  	isp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);
  	if (!isp)
  		return -ENOMEM;
@@@ -428,15 -455,19 +452,24 @@@
  	if (ret < 0)
  		goto fail1;
  
- 	isp->psy.name		= "isp1704";
- 	isp->psy.type		= POWER_SUPPLY_TYPE_USB;
- 	isp->psy.properties	= power_props;
- 	isp->psy.num_properties	= ARRAY_SIZE(power_props);
- 	isp->psy.get_property	= isp1704_charger_get_property;
+ 	isp->psy_desc.name		= "isp1704";
+ 	isp->psy_desc.type		= POWER_SUPPLY_TYPE_USB;
+ 	isp->psy_desc.properties	= power_props;
+ 	isp->psy_desc.num_properties	= ARRAY_SIZE(power_props);
+ 	isp->psy_desc.get_property	= isp1704_charger_get_property;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(isp->dev, &isp->psy);
 +	if (ret)
++=======
+ 	psy_cfg.drv_data		= isp;
+ 
+ 	isp->psy = power_supply_register(isp->dev, &isp->psy_desc, &psy_cfg);
+ 	if (IS_ERR(isp->psy)) {
+ 		ret = PTR_ERR(isp->psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto fail1;
+ 	}
  
  	/*
  	 * REVISIT: using work in order to allow the usb notifications to be
@@@ -472,10 -503,9 +505,10 @@@
  
  	return 0;
  fail2:
- 	power_supply_unregister(&isp->psy);
+ 	power_supply_unregister(isp->psy);
  fail1:
  	isp1704_charger_set_power(isp, 0);
 +	usb_put_phy(isp->phy);
  fail0:
  	dev_err(&pdev->dev, "failed to register isp1704 with error %d\n", ret);
  
@@@ -487,8 -517,7 +520,12 @@@ static int isp1704_charger_remove(struc
  	struct isp1704_charger *isp = platform_get_drvdata(pdev);
  
  	usb_unregister_notifier(isp->phy, &isp->nb);
++<<<<<<< HEAD
 +	power_supply_unregister(&isp->psy);
 +	usb_put_phy(isp->phy);
++=======
+ 	power_supply_unregister(isp->psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	isp1704_charger_set_power(isp, 0);
  
  	return 0;
diff --cc drivers/power/jz4740-battery.c
index c675553d4647,abdfc21ec13f..000000000000
--- a/drivers/power/jz4740-battery.c
+++ b/drivers/power/jz4740-battery.c
@@@ -330,9 -335,11 +335,16 @@@ static int jz_battery_probe(struct plat
  	else
  		jz4740_adc_set_config(pdev->dev.parent, JZ_ADC_CONFIG_BAT_MB, 0);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &jz_battery->battery);
 +	if (ret) {
++=======
+ 	jz_battery->battery = power_supply_register(&pdev->dev, battery_desc,
+ 							&psy_cfg);
+ 	if (IS_ERR(jz_battery->battery)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&pdev->dev, "power supply battery register failed.\n");
+ 		ret = PTR_ERR(jz_battery->battery);
  		goto err_free_charge_irq;
  	}
  
diff --cc drivers/power/lp8727_charger.c
index 5ef41b819172,7e741f1d3cd5..000000000000
--- a/drivers/power/lp8727_charger.c
+++ b/drivers/power/lp8727_charger.c
@@@ -417,8 -418,34 +417,33 @@@ static void lp8727_charger_changed(stru
  	}
  }
  
+ static const struct power_supply_desc lp8727_ac_desc = {
+ 	.name			= "ac",
+ 	.type			= POWER_SUPPLY_TYPE_MAINS,
+ 	.properties		= lp8727_charger_prop,
+ 	.num_properties		= ARRAY_SIZE(lp8727_charger_prop),
+ 	.get_property		= lp8727_charger_get_property,
+ };
+ 
+ static const struct power_supply_desc lp8727_usb_desc = {
+ 	.name			= "usb",
+ 	.type			= POWER_SUPPLY_TYPE_USB,
+ 	.properties		= lp8727_charger_prop,
+ 	.num_properties		= ARRAY_SIZE(lp8727_charger_prop),
+ 	.get_property		= lp8727_charger_get_property,
+ };
+ 
+ static const struct power_supply_desc lp8727_batt_desc = {
+ 	.name			= "main_batt",
+ 	.type			= POWER_SUPPLY_TYPE_BATTERY,
+ 	.properties		= lp8727_battery_prop,
+ 	.num_properties		= ARRAY_SIZE(lp8727_battery_prop),
+ 	.get_property		= lp8727_battery_get_property,
+ 	.external_power_changed	= lp8727_charger_changed,
+ };
+ 
  static int lp8727_register_psy(struct lp8727_chg *pchg)
  {
 -	struct power_supply_config psy_cfg = {}; /* Only for ac and usb */
  	struct lp8727_psy *psy;
  
  	psy = devm_kzalloc(pchg->dev, sizeof(*psy), GFP_KERNEL);
@@@ -427,36 -454,20 +452,53 @@@
  
  	pchg->psy = psy;
  
++<<<<<<< HEAD
 +	psy->ac.name = "ac";
 +	psy->ac.type = POWER_SUPPLY_TYPE_MAINS;
 +	psy->ac.properties = lp8727_charger_prop;
 +	psy->ac.num_properties = ARRAY_SIZE(lp8727_charger_prop);
 +	psy->ac.get_property = lp8727_charger_get_property;
 +	psy->ac.supplied_to = battery_supplied_to;
 +	psy->ac.num_supplicants = ARRAY_SIZE(battery_supplied_to);
 +
 +	if (power_supply_register(pchg->dev, &psy->ac))
 +		goto err_psy_ac;
 +
 +	psy->usb.name = "usb";
 +	psy->usb.type = POWER_SUPPLY_TYPE_USB;
 +	psy->usb.properties = lp8727_charger_prop;
 +	psy->usb.num_properties = ARRAY_SIZE(lp8727_charger_prop);
 +	psy->usb.get_property = lp8727_charger_get_property;
 +	psy->usb.supplied_to = battery_supplied_to;
 +	psy->usb.num_supplicants = ARRAY_SIZE(battery_supplied_to);
 +
 +	if (power_supply_register(pchg->dev, &psy->usb))
 +		goto err_psy_usb;
 +
 +	psy->batt.name = "main_batt";
 +	psy->batt.type = POWER_SUPPLY_TYPE_BATTERY;
 +	psy->batt.properties = lp8727_battery_prop;
 +	psy->batt.num_properties = ARRAY_SIZE(lp8727_battery_prop);
 +	psy->batt.get_property = lp8727_battery_get_property;
 +	psy->batt.external_power_changed = lp8727_charger_changed;
 +
 +	if (power_supply_register(pchg->dev, &psy->batt))
++=======
+ 	psy_cfg.supplied_to = battery_supplied_to;
+ 	psy_cfg.num_supplicants = ARRAY_SIZE(battery_supplied_to);
+ 
+ 	psy->ac = power_supply_register(pchg->dev, &lp8727_ac_desc, &psy_cfg);
+ 	if (IS_ERR(psy->ac))
+ 		goto err_psy_ac;
+ 
+ 	psy->usb = power_supply_register(pchg->dev, &lp8727_usb_desc,
+ 					 &psy_cfg);
+ 	if (IS_ERR(psy->usb))
+ 		goto err_psy_usb;
+ 
+ 	psy->batt = power_supply_register(pchg->dev, &lp8727_batt_desc, NULL);
+ 	if (IS_ERR(psy->batt))
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_psy_batt;
  
  	return 0;
@@@ -476,11 -487,65 +518,11 @@@ static void lp8727_unregister_psy(struc
  	if (!psy)
  		return;
  
- 	power_supply_unregister(&psy->ac);
- 	power_supply_unregister(&psy->usb);
- 	power_supply_unregister(&psy->batt);
+ 	power_supply_unregister(psy->ac);
+ 	power_supply_unregister(psy->usb);
+ 	power_supply_unregister(psy->batt);
  }
  
 -#ifdef CONFIG_OF
 -static struct lp8727_chg_param
 -*lp8727_parse_charge_pdata(struct device *dev, struct device_node *np)
 -{
 -	struct lp8727_chg_param *param;
 -
 -	param = devm_kzalloc(dev, sizeof(*param), GFP_KERNEL);
 -	if (!param)
 -		goto out;
 -
 -	of_property_read_u8(np, "eoc-level", (u8 *)&param->eoc_level);
 -	of_property_read_u8(np, "charging-current", (u8 *)&param->ichg);
 -out:
 -	return param;
 -}
 -
 -static int lp8727_parse_dt(struct device *dev)
 -{
 -	struct device_node *np = dev->of_node;
 -	struct device_node *child;
 -	struct lp8727_platform_data *pdata;
 -	const char *type;
 -
 -	/* If charging parameter is not defined, just skip parsing the dt */
 -	if (of_get_child_count(np) == 0)
 -		goto out;
 -
 -	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 -	if (!pdata)
 -		return -ENOMEM;
 -
 -	of_property_read_u32(np, "debounce-ms", &pdata->debounce_msec);
 -
 -	for_each_child_of_node(np, child) {
 -		of_property_read_string(child, "charger-type", &type);
 -
 -		if (!strcmp(type, "ac"))
 -			pdata->ac = lp8727_parse_charge_pdata(dev, child);
 -
 -		if (!strcmp(type, "usb"))
 -			pdata->usb = lp8727_parse_charge_pdata(dev, child);
 -	}
 -
 -	dev->platform_data = pdata;
 -out:
 -	return 0;
 -}
 -#else
 -static int lp8727_parse_dt(struct device *dev)
 -{
 -	return 0;
 -}
 -#endif
 -
  static int lp8727_probe(struct i2c_client *cl, const struct i2c_device_id *id)
  {
  	struct lp8727_chg *pchg;
diff --cc drivers/power/lp8788-charger.c
index ed49b50b220b,f5a48fd68b01..000000000000
--- a/drivers/power/lp8788-charger.c
+++ b/drivers/power/lp8788-charger.c
@@@ -400,25 -416,23 +416,43 @@@ static const struct power_supply_desc l
  static int lp8788_psy_register(struct platform_device *pdev,
  				struct lp8788_charger *pchg)
  {
++<<<<<<< HEAD
 +	pchg->charger.name = LP8788_CHARGER_NAME;
 +	pchg->charger.type = POWER_SUPPLY_TYPE_MAINS;
 +	pchg->charger.properties = lp8788_charger_prop;
 +	pchg->charger.num_properties = ARRAY_SIZE(lp8788_charger_prop);
 +	pchg->charger.get_property = lp8788_charger_get_property;
 +	pchg->charger.supplied_to = battery_supplied_to;
 +	pchg->charger.num_supplicants = ARRAY_SIZE(battery_supplied_to);
 +
 +	if (power_supply_register(&pdev->dev, &pchg->charger))
 +		return -EPERM;
 +
 +	pchg->battery.name = LP8788_BATTERY_NAME;
 +	pchg->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 +	pchg->battery.properties = lp8788_battery_prop;
 +	pchg->battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 +	pchg->battery.get_property = lp8788_battery_get_property;
 +
 +	if (power_supply_register(&pdev->dev, &pchg->battery))
++=======
+ 	struct power_supply_config charger_cfg = {};
+ 
+ 	charger_cfg.supplied_to = battery_supplied_to;
+ 	charger_cfg.num_supplicants = ARRAY_SIZE(battery_supplied_to);
+ 
+ 	pchg->charger = power_supply_register(&pdev->dev,
+ 					      &lp8788_psy_charger_desc,
+ 					      &charger_cfg);
+ 	if (IS_ERR(pchg->charger))
+ 		return -EPERM;
+ 
+ 	pchg->battery = power_supply_register(&pdev->dev,
+ 					      &lp8788_psy_battery_desc, NULL);
+ 	if (IS_ERR(pchg->battery)) {
+ 		power_supply_unregister(pchg->charger);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		return -EPERM;
 -	}
  
  	return 0;
  }
diff --cc drivers/power/max17040_battery.c
index c7ff6d67f158,8689c80202b5..000000000000
--- a/drivers/power/max17040_battery.c
+++ b/drivers/power/max17040_battery.c
@@@ -215,17 -224,13 +222,24 @@@ static int max17040_probe(struct i2c_cl
  	chip->pdata = client->dev.platform_data;
  
  	i2c_set_clientdata(client, chip);
+ 	psy_cfg.drv_data = chip;
  
++<<<<<<< HEAD
 +	chip->battery.name		= "battery";
 +	chip->battery.type		= POWER_SUPPLY_TYPE_BATTERY;
 +	chip->battery.get_property	= max17040_get_property;
 +	chip->battery.properties	= max17040_battery_props;
 +	chip->battery.num_properties	= ARRAY_SIZE(max17040_battery_props);
 +
 +	ret = power_supply_register(&client->dev, &chip->battery);
 +	if (ret) {
++=======
+ 	chip->battery = power_supply_register(&client->dev,
+ 				&max17040_battery_desc, &psy_cfg);
+ 	if (IS_ERR(chip->battery)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&client->dev, "failed: power supply register\n");
- 		return ret;
+ 		return PTR_ERR(chip->battery);
  	}
  
  	max17040_reset(client);
diff --cc drivers/power/max17042_battery.c
index d664ef58afa7,e5645ea6f9d8..000000000000
--- a/drivers/power/max17042_battery.c
+++ b/drivers/power/max17042_battery.c
@@@ -67,7 -68,8 +67,12 @@@
  
  struct max17042_chip {
  	struct i2c_client *client;
++<<<<<<< HEAD
 +	struct power_supply battery;
++=======
+ 	struct regmap *regmap;
+ 	struct power_supply *battery;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	enum max170xx_chip_type chip_type;
  	struct max17042_platform_data *pdata;
  	struct work_struct work;
@@@ -123,9 -96,10 +128,14 @@@ static int max17042_get_property(struc
  			    enum power_supply_property psp,
  			    union power_supply_propval *val)
  {
++<<<<<<< HEAD
 +	struct max17042_chip *chip = container_of(psy,
 +				struct max17042_chip, battery);
++=======
+ 	struct max17042_chip *chip = power_supply_get_drvdata(psy);
+ 	struct regmap *map = chip->regmap;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	int ret;
 -	u32 data;
  
  	if (!chip->init_complete)
  		return -EAGAIN;
@@@ -682,13 -655,38 +692,40 @@@ max17042_get_pdata(struct device *dev
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static const struct regmap_config max17042_regmap_config = {
+ 	.reg_bits = 8,
+ 	.val_bits = 16,
+ 	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+ };
+ 
+ static const struct power_supply_desc max17042_psy_desc = {
+ 	.name		= "max170xx_battery",
+ 	.type		= POWER_SUPPLY_TYPE_BATTERY,
+ 	.get_property	= max17042_get_property,
+ 	.properties	= max17042_battery_props,
+ 	.num_properties	= ARRAY_SIZE(max17042_battery_props),
+ };
+ 
+ static const struct power_supply_desc max17042_no_current_sense_psy_desc = {
+ 	.name		= "max170xx_battery",
+ 	.type		= POWER_SUPPLY_TYPE_BATTERY,
+ 	.get_property	= max17042_get_property,
+ 	.properties	= max17042_battery_props,
+ 	.num_properties	= ARRAY_SIZE(max17042_battery_props) - 2,
+ };
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  static int max17042_probe(struct i2c_client *client,
  			const struct i2c_device_id *id)
  {
  	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+ 	const struct power_supply_desc *max17042_desc = &max17042_psy_desc;
+ 	struct power_supply_config psy_cfg = {};
  	struct max17042_chip *chip;
  	int ret;
 -	int i;
 -	u32 val;
 +	int reg;
  
  	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))
  		return -EIO;
@@@ -705,12 -709,13 +742,13 @@@
  	}
  
  	i2c_set_clientdata(client, chip);
+ 	psy_cfg.drv_data = chip;
  
 -	regmap_read(chip->regmap, MAX17042_DevName, &val);
 -	if (val == MAX17042_IC_VERSION) {
 +	ret = max17042_read_reg(chip->client, MAX17042_DevName);
 +	if (ret == MAX17042_IC_VERSION) {
  		dev_dbg(&client->dev, "chip type max17042 detected\n");
  		chip->chip_type = MAX17042;
 -	} else if (val == MAX17047_IC_VERSION) {
 +	} else if (ret == MAX17047_IC_VERSION) {
  		dev_dbg(&client->dev, "chip type max17047/50 detected\n");
  		chip->chip_type = MAX17047;
  	} else {
@@@ -733,30 -732,33 +765,42 @@@
  		chip->pdata->r_sns = MAX17042_DEFAULT_SNS_RESISTOR;
  
  	if (chip->pdata->init_data)
 -		for (i = 0; i < chip->pdata->num_init_data; i++)
 -			regmap_write(chip->regmap,
 -					chip->pdata->init_data[i].addr,
 -					chip->pdata->init_data[i].data);
 +		max17042_set_reg(client, chip->pdata->init_data,
 +				chip->pdata->num_init_data);
  
  	if (!chip->pdata->enable_current_sense) {
 -		regmap_write(chip->regmap, MAX17042_CGAIN, 0x0000);
 -		regmap_write(chip->regmap, MAX17042_MiscCFG, 0x0003);
 -		regmap_write(chip->regmap, MAX17042_LearnCFG, 0x0007);
 +		max17042_write_reg(client, MAX17042_CGAIN, 0x0000);
 +		max17042_write_reg(client, MAX17042_MiscCFG, 0x0003);
 +		max17042_write_reg(client, MAX17042_LearnCFG, 0x0007);
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&client->dev, &chip->battery);
 +	if (ret) {
++=======
+ 	chip->battery = power_supply_register(&client->dev, max17042_desc,
+ 						&psy_cfg);
+ 	if (IS_ERR(chip->battery)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&client->dev, "failed: power supply register\n");
- 		return ret;
+ 		return PTR_ERR(chip->battery);
  	}
  
  	if (client->irq) {
  		ret = request_threaded_irq(client->irq, NULL,
++<<<<<<< HEAD
 +						max17042_thread_handler,
 +						IRQF_TRIGGER_FALLING,
 +						chip->battery.name, chip);
++=======
+ 					max17042_thread_handler,
+ 					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+ 					chip->battery->desc->name, chip);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		if (!ret) {
 -			regmap_update_bits(chip->regmap, MAX17042_CONFIG,
 -					CONFIG_ALRT_BIT_ENBL,
 -					CONFIG_ALRT_BIT_ENBL);
 +			reg =  max17042_read_reg(client, MAX17042_CONFIG);
 +			reg |= CONFIG_ALRT_BIT_ENBL;
 +			max17042_write_reg(client, MAX17042_CONFIG, reg);
  			max17042_set_soc_threshold(chip, 1);
  		} else {
  			client->irq = 0;
diff --cc drivers/power/max8903_charger.c
index 08f0d7909b6b,bf2b4b3a7cae..000000000000
--- a/drivers/power/max8903_charger.c
+++ b/drivers/power/max8903_charger.c
@@@ -280,17 -281,20 +281,25 @@@ static int max8903_probe(struct platfor
  	data->ta_in = ta_in;
  	data->usb_in = usb_in;
  
- 	data->psy.name = "max8903_charger";
- 	data->psy.type = (ta_in) ? POWER_SUPPLY_TYPE_MAINS :
+ 	data->psy_desc.name = "max8903_charger";
+ 	data->psy_desc.type = (ta_in) ? POWER_SUPPLY_TYPE_MAINS :
  			((usb_in) ? POWER_SUPPLY_TYPE_USB :
  			 POWER_SUPPLY_TYPE_BATTERY);
- 	data->psy.get_property = max8903_get_property;
- 	data->psy.properties = max8903_charger_props;
- 	data->psy.num_properties = ARRAY_SIZE(max8903_charger_props);
+ 	data->psy_desc.get_property = max8903_get_property;
+ 	data->psy_desc.properties = max8903_charger_props;
+ 	data->psy_desc.num_properties = ARRAY_SIZE(max8903_charger_props);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(dev, &data->psy);
 +	if (ret) {
++=======
+ 	psy_cfg.drv_data = data;
+ 
+ 	data->psy = power_supply_register(dev, &data->psy_desc, &psy_cfg);
+ 	if (IS_ERR(data->psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(dev, "failed: power supply register.\n");
+ 		ret = PTR_ERR(data->psy);
  		goto err;
  	}
  
diff --cc drivers/power/max8925_power.c
index 0ee1e14f76e9,57eb5c2bfc21..000000000000
--- a/drivers/power/max8925_power.c
+++ b/drivers/power/max8925_power.c
@@@ -498,40 -527,29 +522,64 @@@ static int max8925_power_probe(struct p
  	info->adc = chip->adc;
  	platform_set_drvdata(pdev, info);
  
++<<<<<<< HEAD
 +	info->ac.name = "max8925-ac";
 +	info->ac.type = POWER_SUPPLY_TYPE_MAINS;
 +	info->ac.properties = max8925_ac_props;
 +	info->ac.num_properties = ARRAY_SIZE(max8925_ac_props);
 +	info->ac.get_property = max8925_ac_get_prop;
 +	info->ac.supplied_to = pdata->supplied_to;
 +	info->ac.num_supplicants = pdata->num_supplicants;
 +	ret = power_supply_register(&pdev->dev, &info->ac);
 +	if (ret)
++=======
+ 	psy_cfg.supplied_to = pdata->supplied_to;
+ 	psy_cfg.num_supplicants = pdata->num_supplicants;
+ 
+ 	info->ac = power_supply_register(&pdev->dev, &ac_desc, &psy_cfg);
+ 	if (IS_ERR(info->ac)) {
+ 		ret = PTR_ERR(info->ac);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto out;
- 	info->ac.dev->parent = &pdev->dev;
+ 	}
+ 	info->ac->dev.parent = &pdev->dev;
  
++<<<<<<< HEAD
 +	info->usb.name = "max8925-usb";
 +	info->usb.type = POWER_SUPPLY_TYPE_USB;
 +	info->usb.properties = max8925_usb_props;
 +	info->usb.num_properties = ARRAY_SIZE(max8925_usb_props);
 +	info->usb.get_property = max8925_usb_get_prop;
 +	info->usb.supplied_to = pdata->supplied_to;
 +	info->usb.num_supplicants = pdata->num_supplicants;
 +
 +	ret = power_supply_register(&pdev->dev, &info->usb);
 +	if (ret)
++=======
+ 	info->usb = power_supply_register(&pdev->dev, &usb_desc, &psy_cfg);
+ 	if (IS_ERR(info->usb)) {
+ 		ret = PTR_ERR(info->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto out_usb;
- 	info->usb.dev->parent = &pdev->dev;
+ 	}
+ 	info->usb->dev.parent = &pdev->dev;
  
++<<<<<<< HEAD
 +	info->battery.name = "max8925-battery";
 +	info->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 +	info->battery.properties = max8925_battery_props;
 +	info->battery.num_properties = ARRAY_SIZE(max8925_battery_props);
 +	info->battery.get_property = max8925_bat_get_prop;
 +	ret = power_supply_register(&pdev->dev, &info->battery);
 +	if (ret)
++=======
+ 	info->battery = power_supply_register(&pdev->dev, &battery_desc, NULL);
+ 	if (IS_ERR(info->battery)) {
+ 		ret = PTR_ERR(info->battery);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto out_battery;
- 	info->battery.dev->parent = &pdev->dev;
+ 	}
+ 	info->battery->dev.parent = &pdev->dev;
  
  	info->batt_detect = pdata->batt_detect;
  	info->topoff_threshold = pdata->topoff_threshold;
diff --cc drivers/power/max8997_charger.c
index 4bdedfed936d,0b2eab571528..000000000000
--- a/drivers/power/max8997_charger.c
+++ b/drivers/power/max8997_charger.c
@@@ -156,10 -159,14 +159,19 @@@ static int max8997_battery_probe(struc
  	charger->dev = &pdev->dev;
  	charger->iodev = iodev;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &charger->battery);
 +	if (ret) {
++=======
+ 	psy_cfg.drv_data = charger;
+ 
+ 	charger->battery = power_supply_register(&pdev->dev,
+ 						 &max8997_battery_desc,
+ 						 &psy_cfg);
+ 	if (IS_ERR(charger->battery)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&pdev->dev, "failed: power supply register\n");
- 		return ret;
+ 		return PTR_ERR(charger->battery);
  	}
  
  	return 0;
diff --cc drivers/power/max8998_charger.c
index 5017470c2fc9,47448d4bc6cd..000000000000
--- a/drivers/power/max8998_charger.c
+++ b/drivers/power/max8998_charger.c
@@@ -161,15 -169,15 +169,21 @@@ static int max8998_battery_probe(struc
  		goto err;
  	}
  
- 	max8998->battery.name = "max8998_pmic";
- 	max8998->battery.type = POWER_SUPPLY_TYPE_BATTERY;
- 	max8998->battery.get_property = max8998_battery_get_property;
- 	max8998->battery.properties = max8998_battery_props;
- 	max8998->battery.num_properties = ARRAY_SIZE(max8998_battery_props);
+ 	psy_cfg.drv_data = max8998;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(max8998->dev, &max8998->battery);
 +	if (ret) {
 +		dev_err(max8998->dev, "failed: power supply register\n");
++=======
+ 	max8998->battery = power_supply_register(max8998->dev,
+ 						 &max8998_battery_desc,
+ 						 &psy_cfg);
+ 	if (IS_ERR(max8998->battery)) {
+ 		ret = PTR_ERR(max8998->battery);
+ 		dev_err(max8998->dev, "failed: power supply register: %d\n",
+ 			ret);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err;
  	}
  
diff --cc drivers/power/olpc_battery.c
index 1ec810ada5ed,a944338a39de..000000000000
--- a/drivers/power/olpc_battery.c
+++ b/drivers/power/olpc_battery.c
@@@ -619,23 -623,25 +623,36 @@@ static int olpc_battery_probe(struct pl
  
  	/* Ignore the status. It doesn't actually matter */
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &olpc_ac);
 +	if (ret)
 +		return ret;
++=======
+ 	olpc_ac = power_supply_register(&pdev->dev, &olpc_ac_desc, NULL);
+ 	if (IS_ERR(olpc_ac))
+ 		return PTR_ERR(olpc_ac);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	if (olpc_board_at_least(olpc_board_pre(0xd0))) { /* XO-1.5 */
- 		olpc_bat.properties = olpc_xo15_bat_props;
- 		olpc_bat.num_properties = ARRAY_SIZE(olpc_xo15_bat_props);
+ 		olpc_bat_desc.properties = olpc_xo15_bat_props;
+ 		olpc_bat_desc.num_properties = ARRAY_SIZE(olpc_xo15_bat_props);
  	} else { /* XO-1 */
- 		olpc_bat.properties = olpc_xo1_bat_props;
- 		olpc_bat.num_properties = ARRAY_SIZE(olpc_xo1_bat_props);
+ 		olpc_bat_desc.properties = olpc_xo1_bat_props;
+ 		olpc_bat_desc.num_properties = ARRAY_SIZE(olpc_xo1_bat_props);
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &olpc_bat);
 +	if (ret)
++=======
+ 	olpc_bat = power_supply_register(&pdev->dev, &olpc_bat_desc, NULL);
+ 	if (IS_ERR(olpc_bat)) {
+ 		ret = PTR_ERR(olpc_bat);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto battery_failed;
+ 	}
  
- 	ret = device_create_bin_file(olpc_bat.dev, &olpc_bat_eeprom);
+ 	ret = device_create_bin_file(&olpc_bat->dev, &olpc_bat_eeprom);
  	if (ret)
  		goto eeprom_failed;
  
diff --cc drivers/power/pcf50633-charger.c
index 17fd77f24b2a,d05597b4e40f..000000000000
--- a/drivers/power/pcf50633-charger.c
+++ b/drivers/power/pcf50633-charger.c
@@@ -366,8 -365,33 +365,32 @@@ static const u8 mbc_irq_handlers[] = 
  	PCF50633_IRQ_LOWBAT,
  };
  
+ static const struct power_supply_desc pcf50633_mbc_adapter_desc = {
+ 	.name		= "adapter",
+ 	.type		= POWER_SUPPLY_TYPE_MAINS,
+ 	.properties	= power_props,
+ 	.num_properties	= ARRAY_SIZE(power_props),
+ 	.get_property	= &adapter_get_property,
+ };
+ 
+ static const struct power_supply_desc pcf50633_mbc_usb_desc = {
+ 	.name		= "usb",
+ 	.type		= POWER_SUPPLY_TYPE_USB,
+ 	.properties	= power_props,
+ 	.num_properties	= ARRAY_SIZE(power_props),
+ 	.get_property	= usb_get_property,
+ };
+ 
+ static const struct power_supply_desc pcf50633_mbc_ac_desc = {
+ 	.name		= "ac",
+ 	.type		= POWER_SUPPLY_TYPE_MAINS,
+ 	.properties	= power_props,
+ 	.num_properties	= ARRAY_SIZE(power_props),
+ 	.get_property	= ac_get_property,
+ };
+ 
  static int pcf50633_mbc_probe(struct platform_device *pdev)
  {
 -	struct power_supply_config psy_cfg = {};
  	struct pcf50633_mbc *mbc;
  	int ret;
  	int i;
@@@ -385,49 -409,36 +408,76 @@@
  		pcf50633_register_irq(mbc->pcf, mbc_irq_handlers[i],
  					pcf50633_mbc_irq_handler, mbc);
  
++<<<<<<< HEAD
 +	/* Create power supplies */
 +	mbc->adapter.name		= "adapter";
 +	mbc->adapter.type		= POWER_SUPPLY_TYPE_MAINS;
 +	mbc->adapter.properties		= power_props;
 +	mbc->adapter.num_properties	= ARRAY_SIZE(power_props);
 +	mbc->adapter.get_property	= &adapter_get_property;
 +	mbc->adapter.supplied_to	= mbc->pcf->pdata->batteries;
 +	mbc->adapter.num_supplicants	= mbc->pcf->pdata->num_batteries;
 +
 +	mbc->usb.name			= "usb";
 +	mbc->usb.type			= POWER_SUPPLY_TYPE_USB;
 +	mbc->usb.properties		= power_props;
 +	mbc->usb.num_properties		= ARRAY_SIZE(power_props);
 +	mbc->usb.get_property		= usb_get_property;
 +	mbc->usb.supplied_to		= mbc->pcf->pdata->batteries;
 +	mbc->usb.num_supplicants	= mbc->pcf->pdata->num_batteries;
 +
 +	mbc->ac.name			= "ac";
 +	mbc->ac.type			= POWER_SUPPLY_TYPE_MAINS;
 +	mbc->ac.properties		= power_props;
 +	mbc->ac.num_properties		= ARRAY_SIZE(power_props);
 +	mbc->ac.get_property		= ac_get_property;
 +	mbc->ac.supplied_to		= mbc->pcf->pdata->batteries;
 +	mbc->ac.num_supplicants		= mbc->pcf->pdata->num_batteries;
 +
 +	ret = power_supply_register(&pdev->dev, &mbc->adapter);
 +	if (ret) {
++=======
+ 	psy_cfg.supplied_to		= mbc->pcf->pdata->batteries;
+ 	psy_cfg.num_supplicants		= mbc->pcf->pdata->num_batteries;
+ 	psy_cfg.drv_data		= mbc;
+ 
+ 	/* Create power supplies */
+ 	mbc->adapter = power_supply_register(&pdev->dev,
+ 					     &pcf50633_mbc_adapter_desc,
+ 					     &psy_cfg);
+ 	if (IS_ERR(mbc->adapter)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(mbc->pcf->dev, "failed to register adapter\n");
+ 		ret = PTR_ERR(mbc->adapter);
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &mbc->usb);
 +	if (ret) {
++=======
+ 	mbc->usb = power_supply_register(&pdev->dev, &pcf50633_mbc_usb_desc,
+ 					 &psy_cfg);
+ 	if (IS_ERR(mbc->usb)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(mbc->pcf->dev, "failed to register usb\n");
- 		power_supply_unregister(&mbc->adapter);
+ 		power_supply_unregister(mbc->adapter);
+ 		ret = PTR_ERR(mbc->usb);
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &mbc->ac);
 +	if (ret) {
++=======
+ 	mbc->ac = power_supply_register(&pdev->dev, &pcf50633_mbc_ac_desc,
+ 					&psy_cfg);
+ 	if (IS_ERR(mbc->ac)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(mbc->pcf->dev, "failed to register ac\n");
- 		power_supply_unregister(&mbc->adapter);
- 		power_supply_unregister(&mbc->usb);
+ 		power_supply_unregister(mbc->adapter);
+ 		power_supply_unregister(mbc->usb);
+ 		ret = PTR_ERR(mbc->ac);
  		return ret;
  	}
  
diff --cc drivers/power/pda_power.c
index 0c52e2a0d90c,dfe1ee89f7c7..000000000000
--- a/drivers/power/pda_power.c
+++ b/drivers/power/pda_power.c
@@@ -80,21 -81,17 +81,21 @@@ static char *pda_power_supplied_to[] = 
  	"backup-battery",
  };
  
- static struct power_supply pda_psy_ac = {
+ static const struct power_supply_desc pda_psy_ac_desc = {
  	.name = "ac",
  	.type = POWER_SUPPLY_TYPE_MAINS,
 +	.supplied_to = pda_power_supplied_to,
 +	.num_supplicants = ARRAY_SIZE(pda_power_supplied_to),
  	.properties = pda_power_props,
  	.num_properties = ARRAY_SIZE(pda_power_props),
  	.get_property = pda_power_get_property,
  };
  
- static struct power_supply pda_psy_usb = {
+ static const struct power_supply_desc pda_psy_usb_desc = {
  	.name = "usb",
  	.type = POWER_SUPPLY_TYPE_USB,
 +	.supplied_to = pda_power_supplied_to,
 +	.num_supplicants = ARRAY_SIZE(pda_power_supplied_to),
  	.properties = pda_power_props,
  	.num_properties = ARRAY_SIZE(pda_power_props),
  	.get_property = pda_power_get_property,
@@@ -326,10 -325,12 +327,17 @@@ static int pda_power_probe(struct platf
  #endif
  
  	if (pdata->is_ac_online) {
++<<<<<<< HEAD
 +		ret = power_supply_register(&pdev->dev, &pda_psy_ac);
 +		if (ret) {
++=======
+ 		pda_psy_ac = power_supply_register(&pdev->dev,
+ 						   &pda_psy_ac_desc, &psy_cfg);
+ 		if (IS_ERR(pda_psy_ac)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			dev_err(dev, "failed to register %s power supply\n",
- 				pda_psy_ac.name);
+ 				pda_psy_ac_desc.name);
+ 			ret = PTR_ERR(pda_psy_ac);
  			goto ac_supply_failed;
  		}
  
@@@ -347,10 -348,13 +355,18 @@@
  	}
  
  	if (pdata->is_usb_online) {
++<<<<<<< HEAD
 +		ret = power_supply_register(&pdev->dev, &pda_psy_usb);
 +		if (ret) {
++=======
+ 		pda_psy_usb = power_supply_register(&pdev->dev,
+ 						    &pda_psy_usb_desc,
+ 						    &psy_cfg);
+ 		if (IS_ERR(pda_psy_usb)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			dev_err(dev, "failed to register %s power supply\n",
- 				pda_psy_usb.name);
+ 				pda_psy_usb_desc.name);
+ 			ret = PTR_ERR(pda_psy_usb);
  			goto usb_supply_failed;
  		}
  
diff --cc drivers/power/pm2301_charger.c
index fef56e2041b3,cc0893ffbf7e..000000000000
--- a/drivers/power/pm2301_charger.c
+++ b/drivers/power/pm2301_charger.c
@@@ -1050,13 -1043,14 +1050,24 @@@ static int pm2xxx_wall_charger_probe(st
  
  	/* AC supply */
  	/* power_supply base class */
++<<<<<<< HEAD
 +	pm2->ac_chg.psy.name = pm2->pdata->label;
 +	pm2->ac_chg.psy.type = POWER_SUPPLY_TYPE_MAINS;
 +	pm2->ac_chg.psy.properties = pm2xxx_charger_ac_props;
 +	pm2->ac_chg.psy.num_properties = ARRAY_SIZE(pm2xxx_charger_ac_props);
 +	pm2->ac_chg.psy.get_property = pm2xxx_charger_ac_get_property;
 +	pm2->ac_chg.psy.supplied_to = pm2->pdata->supplied_to;
 +	pm2->ac_chg.psy.num_supplicants = pm2->pdata->num_supplicants;
++=======
+ 	pm2->ac_chg_desc.name = pm2->pdata->label;
+ 	pm2->ac_chg_desc.type = POWER_SUPPLY_TYPE_MAINS;
+ 	pm2->ac_chg_desc.properties = pm2xxx_charger_ac_props;
+ 	pm2->ac_chg_desc.num_properties = ARRAY_SIZE(pm2xxx_charger_ac_props);
+ 	pm2->ac_chg_desc.get_property = pm2xxx_charger_ac_get_property;
+ 
+ 	psy_cfg.supplied_to = pm2->pdata->supplied_to;
+ 	psy_cfg.num_supplicants = pm2->pdata->num_supplicants;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	/* pm2xxx_charger sub-class */
  	pm2->ac_chg.ops.enable = &pm2xxx_charger_ac_en;
  	pm2->ac_chg.ops.kick_wd = &pm2xxx_charger_watchdog_kick;
@@@ -1101,9 -1095,11 +1112,16 @@@
  	}
  
  	/* Register AC charger class */
++<<<<<<< HEAD
 +	ret = power_supply_register(pm2->dev, &pm2->ac_chg.psy);
 +	if (ret) {
++=======
+ 	pm2->ac_chg.psy = power_supply_register(pm2->dev, &pm2->ac_chg_desc,
+ 						&psy_cfg);
+ 	if (IS_ERR(pm2->ac_chg.psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(pm2->dev, "failed to register AC charger\n");
+ 		ret = PTR_ERR(pm2->ac_chg.psy);
  		goto free_regulator;
  	}
  
diff --cc drivers/power/pmu_battery.c
index 023d24993b87,9c8d5253812c..000000000000
--- a/drivers/power/pmu_battery.c
+++ b/drivers/power/pmu_battery.c
@@@ -152,25 -155,32 +155,42 @@@ static int __init pmu_bat_init(void
  		goto pdev_register_failed;
  	}
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&bat_pdev->dev, &pmu_ac);
 +	if (ret)
++=======
+ 	pmu_ac = power_supply_register(&bat_pdev->dev, &pmu_ac_desc, NULL);
+ 	if (IS_ERR(pmu_ac)) {
+ 		ret = PTR_ERR(pmu_ac);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto ac_register_failed;
+ 	}
  
  	for (i = 0; i < pmu_battery_count; i++) {
+ 		struct power_supply_config psy_cfg = {};
  		struct pmu_battery_dev *pbat = kzalloc(sizeof(*pbat),
  						       GFP_KERNEL);
  		if (!pbat)
  			break;
  
  		sprintf(pbat->name, "PMU_battery_%d", i);
- 		pbat->bat.name = pbat->name;
- 		pbat->bat.properties = pmu_bat_props;
- 		pbat->bat.num_properties = ARRAY_SIZE(pmu_bat_props);
- 		pbat->bat.get_property = pmu_bat_get_property;
+ 		pbat->bat_desc.name = pbat->name;
+ 		pbat->bat_desc.properties = pmu_bat_props;
+ 		pbat->bat_desc.num_properties = ARRAY_SIZE(pmu_bat_props);
+ 		pbat->bat_desc.get_property = pmu_bat_get_property;
  		pbat->pbi = &pmu_batteries[i];
+ 		psy_cfg.drv_data = pbat;
  
++<<<<<<< HEAD
 +		ret = power_supply_register(&bat_pdev->dev, &pbat->bat);
 +		if (ret) {
++=======
+ 		pbat->bat = power_supply_register(&bat_pdev->dev,
+ 						  &pbat->bat_desc,
+ 						  &psy_cfg);
+ 		if (IS_ERR(pbat->bat)) {
+ 			ret = PTR_ERR(pbat->bat);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			kfree(pbat);
  			goto battery_register_failed;
  		}
diff --cc drivers/power/power_supply_core.c
index 0d8164e2f763,e51405b176c8..000000000000
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@@ -71,25 -75,35 +71,36 @@@ static void power_supply_changed_work(s
  	struct power_supply *psy = container_of(work, struct power_supply,
  						changed_work);
  
- 	dev_dbg(psy->dev, "%s\n", __func__);
+ 	dev_dbg(&psy->dev, "%s\n", __func__);
  
  	spin_lock_irqsave(&psy->changed_lock, flags);
 -	/*
 -	 * Check 'changed' here to avoid issues due to race between
 -	 * power_supply_changed() and this routine. In worst case
 -	 * power_supply_changed() can be called again just before we take above
 -	 * lock. During the first call of this routine we will mark 'changed' as
 -	 * false and it will stay false for the next call as well.
 -	 */
 -	if (likely(psy->changed)) {
 +	if (psy->changed) {
  		psy->changed = false;
  		spin_unlock_irqrestore(&psy->changed_lock, flags);
  		class_for_each_device(power_supply_class, NULL, psy,
  				      __power_supply_changed_work);
  		power_supply_update_leds(psy);
++<<<<<<< HEAD
 +		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
++=======
+ 		atomic_notifier_call_chain(&power_supply_notifier,
+ 				PSY_EVENT_PROP_CHANGED, psy);
+ 		kobject_uevent(&psy->dev.kobj, KOBJ_CHANGE);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		spin_lock_irqsave(&psy->changed_lock, flags);
  	}
 -
  	/*
 -	 * Hold the wakeup_source until all events are processed.
 -	 * power_supply_changed() might have called again and have set 'changed'
 -	 * to true.
 +	 * Dependent power supplies (e.g. battery) may have changed state
 +	 * as a result of this event, so poll again and hold the
 +	 * wakeup_source until all events are processed.
  	 */
++<<<<<<< HEAD
 +	if (!psy->changed)
 +		pm_relax(psy->dev);
++=======
+ 	if (likely(!psy->changed))
+ 		pm_relax(&psy->dev);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	spin_unlock_irqrestore(&psy->changed_lock, flags);
  }
  
@@@ -121,15 -135,17 +132,15 @@@ static int __power_supply_populate_supp
  	do {
  		np = of_parse_phandle(psy->of_node, "power-supplies", i++);
  		if (!np)
 -			break;
 +			continue;
  
  		if (np == epsy->of_node) {
- 			dev_info(psy->dev, "%s: Found supply : %s\n",
- 				psy->name, epsy->name);
- 			psy->supplied_from[i-1] = (char *)epsy->name;
+ 			dev_info(&psy->dev, "%s: Found supply : %s\n",
+ 				psy->desc->name, epsy->desc->name);
+ 			psy->supplied_from[i-1] = (char *)epsy->desc->name;
  			psy->num_supplies++;
 -			of_node_put(np);
  			break;
  		}
 -		of_node_put(np);
  	} while (np);
  
  	return 0;
@@@ -207,27 -214,34 +218,37 @@@ static int power_supply_check_supplies(
  
  		np = of_parse_phandle(psy->of_node, "power-supplies", cnt++);
  		if (!np)
 -			break;
 +			continue;
  
  		ret = power_supply_find_supply_from_node(np);
 -		of_node_put(np);
 -
  		if (ret) {
++<<<<<<< HEAD
 +			dev_dbg(psy->dev, "Failed to find supply, defer!\n");
 +			return -EPROBE_DEFER;
++=======
+ 			dev_dbg(&psy->dev, "Failed to find supply!\n");
+ 			return ret;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		}
  	} while (np);
  
 -	/* Missing valid "power-supplies" entries */
 -	if (cnt == 1)
 -		return 0;
 -
  	/* All supplies found, allocate char ** array for filling */
- 	psy->supplied_from = devm_kzalloc(psy->dev, sizeof(psy->supplied_from),
+ 	psy->supplied_from = devm_kzalloc(&psy->dev, sizeof(psy->supplied_from),
  					  GFP_KERNEL);
  	if (!psy->supplied_from) {
- 		dev_err(psy->dev, "Couldn't allocate memory for supply list\n");
+ 		dev_err(&psy->dev, "Couldn't allocate memory for supply list\n");
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	*psy->supplied_from = devm_kzalloc(psy->dev, sizeof(char *) * cnt,
++=======
+ 	*psy->supplied_from = devm_kzalloc(&psy->dev,
+ 					   sizeof(char *) * (cnt - 1),
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  					   GFP_KERNEL);
  	if (!*psy->supplied_from) {
- 		dev_err(psy->dev, "Couldn't allocate memory for supply list\n");
+ 		dev_err(&psy->dev, "Couldn't allocate memory for supply list\n");
  		return -ENOMEM;
  	}
  
@@@ -247,10 -261,9 +268,16 @@@ static int __power_supply_am_i_supplied
  	struct power_supply *epsy = dev_get_drvdata(dev);
  
  	if (__power_supply_is_supplied_by(epsy, psy))
++<<<<<<< HEAD
 +		if (!epsy->get_property(epsy, POWER_SUPPLY_PROP_ONLINE, &ret)) {
 +			if (ret.intval)
 +				return ret.intval;
 +		}
++=======
+ 		if (!epsy->desc->get_property(epsy, POWER_SUPPLY_PROP_ONLINE,
+ 					&ret))
+ 			return ret.intval;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
@@@ -275,12 -288,11 +302,18 @@@ static int __power_supply_is_system_sup
  	unsigned int *count = data;
  
  	(*count)++;
++<<<<<<< HEAD
 +	if (psy->type != POWER_SUPPLY_TYPE_BATTERY) {
 +		if (psy->get_property(psy, POWER_SUPPLY_PROP_ONLINE, &ret))
 +			return 0;
 +		if (ret.intval)
++=======
+ 	if (psy->desc->type != POWER_SUPPLY_TYPE_BATTERY)
+ 		if (!psy->desc->get_property(psy, POWER_SUPPLY_PROP_ONLINE,
+ 					&ret))
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			return ret.intval;
 -
 +	}
  	return 0;
  }
  
@@@ -305,8 -317,10 +338,15 @@@ EXPORT_SYMBOL_GPL(power_supply_is_syste
  
  int power_supply_set_battery_charged(struct power_supply *psy)
  {
++<<<<<<< HEAD
 +	if (psy->type == POWER_SUPPLY_TYPE_BATTERY && psy->set_charged) {
 +		psy->set_charged(psy);
++=======
+ 	if (atomic_read(&psy->use_cnt) >= 0 &&
+ 			psy->desc->type == POWER_SUPPLY_TYPE_BATTERY &&
+ 			psy->desc->set_charged) {
+ 		psy->desc->set_charged(psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		return 0;
  	}
  
@@@ -331,18 -345,100 +371,91 @@@ struct power_supply *power_supply_get_b
  }
  EXPORT_SYMBOL_GPL(power_supply_get_by_name);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_OF
+ static int power_supply_match_device_node(struct device *dev, const void *data)
+ {
+ 	return dev->parent && dev->parent->of_node == data;
+ }
+ 
+ struct power_supply *power_supply_get_by_phandle(struct device_node *np,
+ 							const char *property)
+ {
+ 	struct device_node *power_supply_np;
+ 	struct device *dev;
+ 
+ 	power_supply_np = of_parse_phandle(np, property, 0);
+ 	if (!power_supply_np)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	dev = class_find_device(power_supply_class, NULL, power_supply_np,
+ 						power_supply_match_device_node);
+ 
+ 	of_node_put(power_supply_np);
+ 
+ 	return dev ? dev_get_drvdata(dev) : NULL;
+ }
+ EXPORT_SYMBOL_GPL(power_supply_get_by_phandle);
+ #endif /* CONFIG_OF */
+ 
+ int power_supply_get_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    union power_supply_propval *val)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->get_property(psy, psp, val);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_get_property);
+ 
+ int power_supply_set_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    const union power_supply_propval *val)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 || !psy->desc->set_property)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->set_property(psy, psp, val);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_set_property);
+ 
+ int power_supply_property_is_writeable(struct power_supply *psy,
+ 					enum power_supply_property psp)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 ||
+ 			!psy->desc->property_is_writeable)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->property_is_writeable(psy, psp);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_property_is_writeable);
+ 
+ void power_supply_external_power_changed(struct power_supply *psy)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 ||
+ 			!psy->desc->external_power_changed)
+ 		return;
+ 
+ 	psy->desc->external_power_changed(psy);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_external_power_changed);
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  int power_supply_powers(struct power_supply *psy, struct device *dev)
  {
- 	return sysfs_create_link(&psy->dev->kobj, &dev->kobj, "powers");
+ 	return sysfs_create_link(&psy->dev.kobj, &dev->kobj, "powers");
  }
  EXPORT_SYMBOL_GPL(power_supply_powers);
  
  static void power_supply_dev_release(struct device *dev)
  {
+ 	struct power_supply *psy = container_of(dev, struct power_supply, dev);
  	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
- 	kfree(dev);
+ 	kfree(psy);
  }
  
 -int power_supply_reg_notifier(struct notifier_block *nb)
 -{
 -	return atomic_notifier_chain_register(&power_supply_notifier, nb);
 -}
 -EXPORT_SYMBOL_GPL(power_supply_reg_notifier);
 -
 -void power_supply_unreg_notifier(struct notifier_block *nb)
 -{
 -	atomic_notifier_chain_unregister(&power_supply_notifier, nb);
 -}
 -EXPORT_SYMBOL_GPL(power_supply_unreg_notifier);
 -
  #ifdef CONFIG_THERMAL
  static int power_supply_read_temp(struct thermal_zone_device *tzd,
  		unsigned long *temp)
@@@ -370,14 -466,15 +483,26 @@@ static int psy_register_thermal(struct 
  {
  	int i;
  
++<<<<<<< HEAD
 +	/* Register battery zone device psy reports temperature */
 +	for (i = 0; i < psy->num_properties; i++) {
 +		if (psy->properties[i] == POWER_SUPPLY_PROP_TEMP) {
 +			psy->tzd = thermal_zone_device_register(psy->name, 0, 0,
 +					psy, &psy_tzd_ops, NULL, 0, 0);
 +			if (IS_ERR(psy->tzd))
 +				return PTR_ERR(psy->tzd);
 +			break;
++=======
+ 	if (psy->desc->no_thermal)
+ 		return 0;
+ 
+ 	/* Register battery zone device psy reports temperature */
+ 	for (i = 0; i < psy->desc->num_properties; i++) {
+ 		if (psy->desc->properties[i] == POWER_SUPPLY_PROP_TEMP) {
+ 			psy->tzd = thermal_zone_device_register(psy->desc->name,
+ 					0, 0, psy, &psy_tzd_ops, NULL, 0, 0);
+ 			return PTR_ERR_OR_ZERO(psy->tzd);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		}
  	}
  	return 0;
@@@ -449,15 -546,13 +574,15 @@@ static int psy_register_cooler(struct p
  	int i;
  
  	/* Register for cooling device if psy can control charging */
- 	for (i = 0; i < psy->num_properties; i++) {
- 		if (psy->properties[i] ==
+ 	for (i = 0; i < psy->desc->num_properties; i++) {
+ 		if (psy->desc->properties[i] ==
  				POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT) {
  			psy->tcd = thermal_cooling_device_register(
- 							(char *)psy->name,
+ 							(char *)psy->desc->name,
  							psy, &psy_tcd_ops);
 -			return PTR_ERR_OR_ZERO(psy->tcd);
 +			if (IS_ERR(psy->tcd))
 +				return PTR_ERR(psy->tcd);
 +			break;
  		}
  	}
  	return 0;
@@@ -489,14 -584,21 +614,25 @@@ static void psy_unregister_cooler(struc
  }
  #endif
  
++<<<<<<< HEAD
 +int __power_supply_register(struct device *parent, struct power_supply *psy, bool ws)
++=======
+ static struct power_supply *__must_check
+ __power_supply_register(struct device *parent,
+ 				   const struct power_supply_desc *desc,
+ 				   const struct power_supply_config *cfg,
+ 				   bool ws)
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  {
  	struct device *dev;
+ 	struct power_supply *psy;
  	int rc;
  
- 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
- 	if (!dev)
- 		return -ENOMEM;
+ 	psy = kzalloc(sizeof(*psy), GFP_KERNEL);
+ 	if (!psy)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	dev = &psy->dev;
  
  	device_initialize(dev);
  
@@@ -505,7 -607,18 +641,22 @@@
  	dev->parent = parent;
  	dev->release = power_supply_dev_release;
  	dev_set_drvdata(dev, psy);
++<<<<<<< HEAD
 +	psy->dev = dev;
++=======
+ 	psy->desc = desc;
+ 	atomic_inc(&psy->use_cnt);
+ 	if (cfg) {
+ 		psy->drv_data = cfg->drv_data;
+ 		psy->of_node = cfg->of_node;
+ 		psy->supplied_to = cfg->supplied_to;
+ 		psy->num_supplicants = cfg->num_supplicants;
+ 	}
+ 
+ 	rc = dev_set_name(dev, "%s", desc->name);
+ 	if (rc)
+ 		goto dev_set_name_failed;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	INIT_WORK(&psy->changed_work, power_supply_changed_work);
  
@@@ -542,32 -651,62 +693,82 @@@
  
  	power_supply_changed(psy);
  
++<<<<<<< HEAD
 +	goto success;
++=======
+ 	return psy;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  create_triggers_failed:
  	psy_unregister_cooler(psy);
  register_cooler_failed:
  	psy_unregister_thermal(psy);
  register_thermal_failed:
 +wakeup_init_failed:
  	device_del(dev);
 +kobject_set_name_failed:
  device_add_failed:
 -wakeup_init_failed:
  check_supplies_failed:
 -dev_set_name_failed:
  	put_device(dev);
++<<<<<<< HEAD
 +success:
 +	return rc;
 +}
 +
 +int power_supply_register(struct device *parent, struct power_supply *psy)
 +{
 +	return __power_supply_register(parent, psy, true);
 +}
 +EXPORT_SYMBOL_GPL(power_supply_register);
 +
 +int power_supply_register_no_ws(struct device *parent, struct power_supply *psy)
 +{
 +	return __power_supply_register(parent, psy, false);
++=======
+ 	return ERR_PTR(rc);
+ }
+ 
+ /**
+  * power_supply_register() - Register new power supply
+  * @parent:	Device to be a parent of power supply's device
+  * @desc:	Description of power supply, must be valid through whole
+  *		lifetime of this power supply
+  * @cfg:	Run-time specific configuration accessed during registering,
+  *		may be NULL
+  *
+  * Return: A pointer to newly allocated power_supply on success
+  * or ERR_PTR otherwise.
+  * Use power_supply_unregister() on returned power_supply pointer to release
+  * resources.
+  */
+ struct power_supply *__must_check power_supply_register(struct device *parent,
+ 		const struct power_supply_desc *desc,
+ 		const struct power_supply_config *cfg)
+ {
+ 	return __power_supply_register(parent, desc, cfg, true);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_register);
+ 
+ /**
+  * power_supply_register() - Register new non-waking-source power supply
+  * @parent:	Device to be a parent of power supply's device
+  * @desc:	Description of power supply, must be valid through whole
+  *		lifetime of this power supply
+  * @cfg:	Run-time specific configuration accessed during registering,
+  *		may be NULL
+  *
+  * Return: A pointer to newly allocated power_supply on success
+  * or ERR_PTR otherwise.
+  * Use power_supply_unregister() on returned power_supply pointer to release
+  * resources.
+  */
+ struct power_supply *__must_check
+ power_supply_register_no_ws(struct device *parent,
+ 		const struct power_supply_desc *desc,
+ 		const struct power_supply_config *cfg)
+ {
+ 	return __power_supply_register(parent, desc, cfg, false);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  }
  EXPORT_SYMBOL_GPL(power_supply_register_no_ws);
  
@@@ -578,18 -717,34 +779,44 @@@ static void devm_power_supply_release(s
  	power_supply_unregister(*psy);
  }
  
++<<<<<<< HEAD
 +int devm_power_supply_register(struct device *parent, struct power_supply *psy)
++=======
+ /**
+  * power_supply_register() - Register managed power supply
+  * @parent:	Device to be a parent of power supply's device
+  * @desc:	Description of power supply, must be valid through whole
+  *		lifetime of this power supply
+  * @cfg:	Run-time specific configuration accessed during registering,
+  *		may be NULL
+  *
+  * Return: A pointer to newly allocated power_supply on success
+  * or ERR_PTR otherwise.
+  * The returned power_supply pointer will be automatically unregistered
+  * on driver detach.
+  */
+ struct power_supply *__must_check
+ devm_power_supply_register(struct device *parent,
+ 		const struct power_supply_desc *desc,
+ 		const struct power_supply_config *cfg)
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  {
- 	struct power_supply **ptr = devres_alloc(devm_power_supply_release,
- 						 sizeof(*ptr), GFP_KERNEL);
- 	int ret;
+ 	struct power_supply **ptr, *psy;
+ 
+ 	ptr = devres_alloc(devm_power_supply_release, sizeof(*ptr), GFP_KERNEL);
  
  	if (!ptr)
++<<<<<<< HEAD
 +		return -ENOMEM;
 +	ret = __power_supply_register(parent, psy, true);
 +	if (ret < 0)
++=======
+ 		return ERR_PTR(-ENOMEM);
+ 	psy = __power_supply_register(parent, desc, cfg, true);
+ 	if (IS_ERR(psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		devres_free(ptr);
- 	else {
+ 	} else {
  		*ptr = psy;
  		devres_add(parent, ptr);
  	}
@@@ -597,18 -752,34 +824,44 @@@
  }
  EXPORT_SYMBOL_GPL(devm_power_supply_register);
  
++<<<<<<< HEAD
 +int devm_power_supply_register_no_ws(struct device *parent, struct power_supply *psy)
++=======
+ /**
+  * power_supply_register() - Register managed non-waking-source power supply
+  * @parent:	Device to be a parent of power supply's device
+  * @desc:	Description of power supply, must be valid through whole
+  *		lifetime of this power supply
+  * @cfg:	Run-time specific configuration accessed during registering,
+  *		may be NULL
+  *
+  * Return: A pointer to newly allocated power_supply on success
+  * or ERR_PTR otherwise.
+  * The returned power_supply pointer will be automatically unregistered
+  * on driver detach.
+  */
+ struct power_supply *__must_check
+ devm_power_supply_register_no_ws(struct device *parent,
+ 		const struct power_supply_desc *desc,
+ 		const struct power_supply_config *cfg)
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  {
- 	struct power_supply **ptr = devres_alloc(devm_power_supply_release,
- 						 sizeof(*ptr), GFP_KERNEL);
- 	int ret;
+ 	struct power_supply **ptr, *psy;
+ 
+ 	ptr = devres_alloc(devm_power_supply_release, sizeof(*ptr), GFP_KERNEL);
  
  	if (!ptr)
++<<<<<<< HEAD
 +		return -ENOMEM;
 +	ret = __power_supply_register(parent, psy, false);
 +	if (ret < 0)
++=======
+ 		return ERR_PTR(-ENOMEM);
+ 	psy = __power_supply_register(parent, desc, cfg, false);
+ 	if (IS_ERR(psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		devres_free(ptr);
- 	else {
+ 	} else {
  		*ptr = psy;
  		devres_add(parent, ptr);
  	}
@@@ -616,10 -787,18 +869,17 @@@
  }
  EXPORT_SYMBOL_GPL(devm_power_supply_register_no_ws);
  
+ /**
+  * power_supply_unregister() - Remove this power supply from system
+  * @psy:	Pointer to power supply to unregister
+  *
+  * Remove this power supply from the system. The resources of power supply
+  * will be freed here or on last power_supply_put() call.
+  */
  void power_supply_unregister(struct power_supply *psy)
  {
 -	WARN_ON(atomic_dec_return(&psy->use_cnt));
  	cancel_work_sync(&psy->changed_work);
- 	sysfs_remove_link(&psy->dev->kobj, "powers");
+ 	sysfs_remove_link(&psy->dev.kobj, "powers");
  	power_supply_remove_triggers(psy);
  	psy_unregister_cooler(psy);
  	psy_unregister_thermal(psy);
diff --cc drivers/power/power_supply_leds.c
index 995f966ed5b7,2d41a43fc81a..000000000000
--- a/drivers/power/power_supply_leds.c
+++ b/drivers/power/power_supply_leds.c
@@@ -57,10 -57,8 +57,10 @@@ static void power_supply_update_bat_led
  
  static int power_supply_create_bat_triggers(struct power_supply *psy)
  {
 +	int rc = 0;
 +
  	psy->charging_full_trig_name = kasprintf(GFP_KERNEL,
- 					"%s-charging-or-full", psy->name);
+ 					"%s-charging-or-full", psy->desc->name);
  	if (!psy->charging_full_trig_name)
  		goto charging_full_failed;
  
@@@ -132,11 -128,10 +132,16 @@@ static void power_supply_update_gen_led
  
  static int power_supply_create_gen_triggers(struct power_supply *psy)
  {
++<<<<<<< HEAD
 +	int rc = 0;
 +
 +	psy->online_trig_name = kasprintf(GFP_KERNEL, "%s-online", psy->name);
++=======
+ 	psy->online_trig_name = kasprintf(GFP_KERNEL, "%s-online",
+ 					  psy->desc->name);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	if (!psy->online_trig_name)
 -		return -ENOMEM;
 +		goto online_failed;
  
  	led_trigger_register_simple(psy->online_trig_name, &psy->online_trig);
  
diff --cc drivers/power/power_supply_sysfs.c
index 29178f78d73c,9134e3d2d95e..000000000000
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@@ -73,19 -73,20 +73,26 @@@ static ssize_t power_supply_show_proper
  	const ptrdiff_t off = attr - power_supply_attrs;
  	union power_supply_propval value;
  
++<<<<<<< HEAD
 +	if (off == POWER_SUPPLY_PROP_TYPE)
 +		value.intval = psy->type;
 +	else
 +		ret = psy->get_property(psy, off, &value);
++=======
+ 	if (off == POWER_SUPPLY_PROP_TYPE) {
+ 		value.intval = psy->desc->type;
+ 	} else {
+ 		ret = power_supply_get_property(psy, off, &value);
 -
 -		if (ret < 0) {
 -			if (ret == -ENODATA)
 -				dev_dbg(dev, "driver has no data for `%s' property\n",
 -					attr->attr.name);
 -			else if (ret != -ENODEV)
 -				dev_err(dev, "driver failed to report `%s' property: %zd\n",
 -					attr->attr.name, ret);
 -			return ret;
 -		}
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
 +
 +	if (ret < 0) {
 +		if (ret == -ENODATA)
 +			dev_dbg(dev, "driver has no data for `%s' property\n",
 +				attr->attr.name);
 +		else if (ret != -ENODEV)
 +			dev_err(dev, "driver failed to report `%s' property: %zd\n",
 +				attr->attr.name, ret);
 +		return ret;
  	}
  
  	if (off == POWER_SUPPLY_PROP_STATUS)
@@@ -124,7 -125,7 +131,11 @@@ static ssize_t power_supply_store_prope
  
  	value.intval = long_val;
  
++<<<<<<< HEAD
 +	ret = psy->set_property(psy, off, &value);
++=======
+ 	ret = psy->desc->set_property(psy, off, &value);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	if (ret < 0)
  		return ret;
  
@@@ -210,12 -218,12 +221,17 @@@ static umode_t power_supply_attr_is_vis
  	if (attrno == POWER_SUPPLY_PROP_TYPE)
  		return mode;
  
- 	for (i = 0; i < psy->num_properties; i++) {
- 		int property = psy->properties[i];
+ 	for (i = 0; i < psy->desc->num_properties; i++) {
+ 		int property = psy->desc->properties[i];
  
  		if (property == attrno) {
++<<<<<<< HEAD
 +			if (psy->property_is_writeable &&
 +			    psy->property_is_writeable(psy, property) > 0)
++=======
+ 			if (psy->desc->property_is_writeable &&
+ 			    power_supply_property_is_writeable(psy, property) > 0)
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  				mode |= S_IWUSR;
  
  			return mode;
diff --cc drivers/power/rx51_battery.c
index cbde1d6d3228,ac6206951d58..000000000000
--- a/drivers/power/rx51_battery.c
+++ b/drivers/power/rx51_battery.c
@@@ -27,7 -27,13 +27,15 @@@
  
  struct rx51_device_info {
  	struct device *dev;
++<<<<<<< HEAD
 +	struct power_supply bat;
++=======
+ 	struct power_supply *bat;
+ 	struct power_supply_desc bat_desc;
+ 	struct iio_channel *channel_temp;
+ 	struct iio_channel *channel_bsi;
+ 	struct iio_channel *channel_vbat;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  };
  
  /*
@@@ -209,27 -214,61 +217,67 @@@ static int rx51_battery_probe(struct pl
  
  	platform_set_drvdata(pdev, di);
  
++<<<<<<< HEAD
 +	di->bat.name = dev_name(&pdev->dev);
 +	di->bat.type = POWER_SUPPLY_TYPE_BATTERY;
 +	di->bat.properties = rx51_battery_props;
 +	di->bat.num_properties = ARRAY_SIZE(rx51_battery_props);
 +	di->bat.get_property = rx51_battery_get_property;
++=======
+ 	di->dev = &pdev->dev;
+ 	di->bat_desc.name = dev_name(&pdev->dev);
+ 	di->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	di->bat_desc.properties = rx51_battery_props;
+ 	di->bat_desc.num_properties = ARRAY_SIZE(rx51_battery_props);
+ 	di->bat_desc.get_property = rx51_battery_get_property;
+ 
+ 	psy_cfg.drv_data = di;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
 -	di->channel_temp = iio_channel_get(di->dev, "temp");
 -	if (IS_ERR(di->channel_temp)) {
 -		ret = PTR_ERR(di->channel_temp);
 -		goto error;
 +	ret = power_supply_register(di->dev, &di->bat);
 +	if (ret) {
 +		platform_set_drvdata(pdev, NULL);
 +		return ret;
  	}
  
++<<<<<<< HEAD
++=======
+ 	di->channel_bsi  = iio_channel_get(di->dev, "bsi");
+ 	if (IS_ERR(di->channel_bsi)) {
+ 		ret = PTR_ERR(di->channel_bsi);
+ 		goto error_channel_temp;
+ 	}
+ 
+ 	di->channel_vbat = iio_channel_get(di->dev, "vbat");
+ 	if (IS_ERR(di->channel_vbat)) {
+ 		ret = PTR_ERR(di->channel_vbat);
+ 		goto error_channel_bsi;
+ 	}
+ 
+ 	di->bat = power_supply_register(di->dev, &di->bat_desc, &psy_cfg);
+ 	if (IS_ERR(di->bat)) {
+ 		ret = PTR_ERR(di->bat);
+ 		goto error_channel_vbat;
+ 	}
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
 -
 -error_channel_vbat:
 -	iio_channel_release(di->channel_vbat);
 -error_channel_bsi:
 -	iio_channel_release(di->channel_bsi);
 -error_channel_temp:
 -	iio_channel_release(di->channel_temp);
 -error:
 -
 -	return ret;
  }
  
  static int rx51_battery_remove(struct platform_device *pdev)
  {
  	struct rx51_device_info *di = platform_get_drvdata(pdev);
  
++<<<<<<< HEAD
 +	power_supply_unregister(&di->bat);
 +	platform_set_drvdata(pdev, NULL);
++=======
+ 	power_supply_unregister(di->bat);
+ 
+ 	iio_channel_release(di->channel_vbat);
+ 	iio_channel_release(di->channel_bsi);
+ 	iio_channel_release(di->channel_temp);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
diff --cc drivers/power/s3c_adc_battery.c
index 5948ce058bdd,0ffe5cd3abf6..000000000000
--- a/drivers/power/s3c_adc_battery.c
+++ b/drivers/power/s3c_adc_battery.c
@@@ -310,16 -310,25 +310,35 @@@ static int s3c_adc_bat_probe(struct pla
  	main_bat.cable_plugged = 0;
  	main_bat.status = POWER_SUPPLY_STATUS_DISCHARGING;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &main_bat.psy);
 +	if (ret)
++=======
+ 	main_bat.psy = power_supply_register(&pdev->dev, &main_bat_desc, NULL);
+ 	if (IS_ERR(main_bat.psy)) {
+ 		ret = PTR_ERR(main_bat.psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_reg_main;
+ 	}
  	if (pdata->backup_volt_mult) {
+ 		const struct power_supply_config psy_cfg
+ 						= { .drv_data = &backup_bat, };
+ 
  		backup_bat.client = client;
  		backup_bat.pdata = pdev->dev.platform_data;
  		backup_bat.volt_value = -1;
++<<<<<<< HEAD
 +		ret = power_supply_register(&pdev->dev, &backup_bat.psy);
 +		if (ret)
++=======
+ 		backup_bat.psy = power_supply_register(&pdev->dev,
+ 						       &backup_bat_desc,
+ 						       &psy_cfg);
+ 		if (IS_ERR(backup_bat.psy)) {
+ 			ret = PTR_ERR(backup_bat.psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			goto err_reg_backup;
+ 		}
  	}
  
  	INIT_DELAYED_WORK(&bat_work, s3c_adc_bat_work);
diff --cc drivers/power/sbs-battery.c
index c8c78a74e75a,de1178659d4b..000000000000
--- a/drivers/power/sbs-battery.c
+++ b/drivers/power/sbs-battery.c
@@@ -679,31 -805,31 +684,38 @@@ static int sbs_probe(struct i2c_client 
  	const struct i2c_device_id *id)
  {
  	struct sbs_info *chip;
+ 	struct power_supply_desc *sbs_desc;
  	struct sbs_platform_data *pdata = client->dev.platform_data;
 -	struct power_supply_config psy_cfg = {};
  	int rc;
  	int irq;
- 	char *name;
  
- 	name = kasprintf(GFP_KERNEL, "sbs-%s", dev_name(&client->dev));
- 	if (!name) {
- 		dev_err(&client->dev, "Failed to allocate device name\n");
+ 	sbs_desc = devm_kmemdup(&client->dev, &sbs_default_desc,
+ 			sizeof(*sbs_desc), GFP_KERNEL);
+ 	if (!sbs_desc)
+ 		return -ENOMEM;
+ 
+ 	sbs_desc->name = devm_kasprintf(&client->dev, GFP_KERNEL, "sbs-%s",
+ 			dev_name(&client->dev));
+ 	if (!sbs_desc->name)
  		return -ENOMEM;
- 	}
  
  	chip = kzalloc(sizeof(struct sbs_info), GFP_KERNEL);
- 	if (!chip) {
- 		rc = -ENOMEM;
- 		goto exit_free_name;
- 	}
+ 	if (!chip)
+ 		return -ENOMEM;
  
  	chip->client = client;
  	chip->enable_detection = false;
  	chip->gpio_detect = false;
++<<<<<<< HEAD
 +	chip->power_supply.name = name;
 +	chip->power_supply.type = POWER_SUPPLY_TYPE_BATTERY;
 +	chip->power_supply.properties = sbs_properties;
 +	chip->power_supply.num_properties = ARRAY_SIZE(sbs_properties);
 +	chip->power_supply.get_property = sbs_get_property;
++=======
+ 	psy_cfg.of_node = client->dev.of_node;
+ 	psy_cfg.drv_data = chip;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	/* ignore first notification of external change, it is generated
  	 * from the power_supply_register call back
  	 */
@@@ -770,10 -895,12 +781,17 @@@ skip_gpio
  		goto exit_psupply;
  	}
  
++<<<<<<< HEAD
 +	rc = power_supply_register(&client->dev, &chip->power_supply);
 +	if (rc) {
++=======
+ 	chip->power_supply = power_supply_register(&client->dev, sbs_desc,
+ 						   &psy_cfg);
+ 	if (IS_ERR(chip->power_supply)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&client->dev,
  			"%s: Failed to register power supply\n", __func__);
+ 		rc = PTR_ERR(chip->power_supply);
  		goto exit_psupply;
  	}
  
diff --cc drivers/power/smb347-charger.c
index acf84e80fe98,0b60a0b5878b..000000000000
--- a/drivers/power/smb347-charger.c
+++ b/drivers/power/smb347-charger.c
@@@ -1193,6 -1215,7 +1214,10 @@@ static int smb347_probe(struct i2c_clie
  {
  	static char *battery[] = { "smb347-battery" };
  	const struct smb347_charger_platform_data *pdata;
++<<<<<<< HEAD
++=======
+ 	struct power_supply_config mains_usb_cfg = {}, battery_cfg = {};
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	struct device *dev = &client->dev;
  	struct smb347_charger *smb;
  	int ret;
@@@ -1222,49 -1245,35 +1247,73 @@@
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	if (smb->pdata->use_mains) {
 +		smb->mains.name = "smb347-mains";
 +		smb->mains.type = POWER_SUPPLY_TYPE_MAINS;
 +		smb->mains.get_property = smb347_mains_get_property;
 +		smb->mains.properties = smb347_mains_properties;
 +		smb->mains.num_properties = ARRAY_SIZE(smb347_mains_properties);
 +		smb->mains.supplied_to = battery;
 +		smb->mains.num_supplicants = ARRAY_SIZE(battery);
 +		ret = power_supply_register(dev, &smb->mains);
 +		if (ret < 0)
 +			return ret;
 +	}
 +
 +	if (smb->pdata->use_usb) {
 +		smb->usb.name = "smb347-usb";
 +		smb->usb.type = POWER_SUPPLY_TYPE_USB;
 +		smb->usb.get_property = smb347_usb_get_property;
 +		smb->usb.properties = smb347_usb_properties;
 +		smb->usb.num_properties = ARRAY_SIZE(smb347_usb_properties);
 +		smb->usb.supplied_to = battery;
 +		smb->usb.num_supplicants = ARRAY_SIZE(battery);
 +		ret = power_supply_register(dev, &smb->usb);
 +		if (ret < 0) {
++=======
+ 	mains_usb_cfg.supplied_to = battery;
+ 	mains_usb_cfg.num_supplicants = ARRAY_SIZE(battery);
+ 	mains_usb_cfg.drv_data = smb;
+ 	if (smb->pdata->use_mains) {
+ 		smb->mains = power_supply_register(dev, &smb347_mains_desc,
+ 						   &mains_usb_cfg);
+ 		if (IS_ERR(smb->mains))
+ 			return PTR_ERR(smb->mains);
+ 	}
+ 
+ 	if (smb->pdata->use_usb) {
+ 		smb->usb = power_supply_register(dev, &smb347_usb_desc,
+ 						 &mains_usb_cfg);
+ 		if (IS_ERR(smb->usb)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			if (smb->pdata->use_mains)
- 				power_supply_unregister(&smb->mains);
- 			return ret;
+ 				power_supply_unregister(smb->mains);
+ 			return PTR_ERR(smb->usb);
  		}
  	}
  
++<<<<<<< HEAD
 +	smb->battery.name = "smb347-battery";
 +	smb->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 +	smb->battery.get_property = smb347_battery_get_property;
 +	smb->battery.properties = smb347_battery_properties;
 +	smb->battery.num_properties = ARRAY_SIZE(smb347_battery_properties);
 +
 +
 +	ret = power_supply_register(dev, &smb->battery);
 +	if (ret < 0) {
++=======
+ 	battery_cfg.drv_data = smb;
+ 	smb->battery = power_supply_register(dev, &smb347_battery_desc,
+ 					     &battery_cfg);
+ 	if (IS_ERR(smb->battery)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		if (smb->pdata->use_usb)
- 			power_supply_unregister(&smb->usb);
+ 			power_supply_unregister(smb->usb);
  		if (smb->pdata->use_mains)
- 			power_supply_unregister(&smb->mains);
- 		return ret;
+ 			power_supply_unregister(smb->mains);
+ 		return PTR_ERR(smb->battery);
  	}
  
  	/*
diff --cc drivers/power/test_power.c
index 0152f35dca5c,f986e0cca7ac..000000000000
--- a/drivers/power/test_power.c
+++ b/drivers/power/test_power.c
@@@ -146,12 -153,12 +146,19 @@@ static char *test_power_ac_supplied_to[
  	"test_battery",
  };
  
++<<<<<<< HEAD
 +static struct power_supply test_power_supplies[] = {
 +	{
++=======
+ static struct power_supply *test_power_supplies[TEST_POWER_NUM];
+ 
+ static const struct power_supply_desc test_power_desc[] = {
+ 	[TEST_AC] = {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		.name = "test_ac",
  		.type = POWER_SUPPLY_TYPE_MAINS,
 +		.supplied_to = test_power_ac_supplied_to,
 +		.num_supplicants = ARRAY_SIZE(test_power_ac_supplied_to),
  		.properties = test_power_ac_props,
  		.num_properties = ARRAY_SIZE(test_power_ac_props),
  		.get_property = test_power_get_ac_property,
@@@ -178,11 -198,17 +185,19 @@@ static int __init test_power_init(void
  	int i;
  	int ret;
  
 -	BUILD_BUG_ON(TEST_POWER_NUM != ARRAY_SIZE(test_power_supplies));
 -	BUILD_BUG_ON(TEST_POWER_NUM != ARRAY_SIZE(test_power_configs));
 -
  	for (i = 0; i < ARRAY_SIZE(test_power_supplies); i++) {
++<<<<<<< HEAD
 +		ret = power_supply_register(NULL, &test_power_supplies[i]);
 +		if (ret) {
++=======
+ 		test_power_supplies[i] = power_supply_register(NULL,
+ 						&test_power_desc[i],
+ 						&test_power_configs[i]);
+ 		if (IS_ERR(test_power_supplies[i])) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  			pr_err("%s: failed to register %s\n", __func__,
- 				test_power_supplies[i].name);
+ 				test_power_desc[i].name);
+ 			ret = PTR_ERR(test_power_supplies[i]);
  			goto failed;
  		}
  	}
@@@ -309,7 -335,7 +324,11 @@@ static inline void signal_power_supply_
  static int param_set_ac_online(const char *key, const struct kernel_param *kp)
  {
  	ac_online = map_get_value(map_ac_online, key, ac_online);
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[0]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_AC]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -322,7 -348,7 +341,11 @@@ static int param_get_ac_online(char *bu
  static int param_set_usb_online(const char *key, const struct kernel_param *kp)
  {
  	usb_online = map_get_value(map_ac_online, key, usb_online);
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[2]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_USB]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -336,7 -362,7 +359,11 @@@ static int param_set_battery_status(con
  					const struct kernel_param *kp)
  {
  	battery_status = map_get_value(map_status, key, battery_status);
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[1]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_BATTERY]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -350,7 -376,7 +377,11 @@@ static int param_set_battery_health(con
  					const struct kernel_param *kp)
  {
  	battery_health = map_get_value(map_health, key, battery_health);
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[1]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_BATTERY]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -364,7 -390,7 +395,11 @@@ static int param_set_battery_present(co
  					const struct kernel_param *kp)
  {
  	battery_present = map_get_value(map_present, key, battery_present);
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[0]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_AC]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -380,7 -406,7 +415,11 @@@ static int param_set_battery_technology
  {
  	battery_technology = map_get_value(map_technology, key,
  						battery_technology);
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[1]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_BATTERY]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -401,7 -427,7 +440,11 @@@ static int param_set_battery_capacity(c
  		return -EINVAL;
  
  	battery_capacity = tmp;
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[1]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_BATTERY]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
@@@ -416,7 -442,7 +459,11 @@@ static int param_set_battery_voltage(co
  		return -EINVAL;
  
  	battery_voltage = tmp;
++<<<<<<< HEAD
 +	signal_power_supply_changed(&test_power_supplies[1]);
++=======
+ 	signal_power_supply_changed(test_power_supplies[TEST_BATTERY]);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	return 0;
  }
  
diff --cc drivers/power/tosa_battery.c
index 0224de50c540,6e88c1b37945..000000000000
--- a/drivers/power/tosa_battery.c
+++ b/drivers/power/tosa_battery.c
@@@ -358,15 -366,31 +366,42 @@@ static int tosa_bat_probe(struct platfo
  
  	INIT_WORK(&bat_work, tosa_bat_work);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&dev->dev, &tosa_bat_main.psy);
 +	if (ret)
 +		goto err_psy_reg_main;
 +	ret = power_supply_register(&dev->dev, &tosa_bat_jacket.psy);
 +	if (ret)
 +		goto err_psy_reg_jacket;
 +	ret = power_supply_register(&dev->dev, &tosa_bat_bu.psy);
 +	if (ret)
++=======
+ 	main_psy_cfg.drv_data = &tosa_bat_main;
+ 	tosa_bat_main.psy = power_supply_register(&dev->dev,
+ 						  &tosa_bat_main_desc,
+ 						  &main_psy_cfg);
+ 	if (IS_ERR(tosa_bat_main.psy)) {
+ 		ret = PTR_ERR(tosa_bat_main.psy);
+ 		goto err_psy_reg_main;
+ 	}
+ 
+ 	jacket_psy_cfg.drv_data = &tosa_bat_jacket;
+ 	tosa_bat_jacket.psy = power_supply_register(&dev->dev,
+ 						    &tosa_bat_jacket_desc,
+ 						    &jacket_psy_cfg);
+ 	if (IS_ERR(tosa_bat_jacket.psy)) {
+ 		ret = PTR_ERR(tosa_bat_jacket.psy);
+ 		goto err_psy_reg_jacket;
+ 	}
+ 
+ 	bu_psy_cfg.drv_data = &tosa_bat_bu;
+ 	tosa_bat_bu.psy = power_supply_register(&dev->dev, &tosa_bat_bu_desc,
+ 						&bu_psy_cfg);
+ 	if (IS_ERR(tosa_bat_bu.psy)) {
+ 		ret = PTR_ERR(tosa_bat_bu.psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_psy_reg_bu;
+ 	}
  
  	ret = request_irq(gpio_to_irq(TOSA_GPIO_BAT0_CRG),
  				tosa_bat_gpio_isr,
diff --cc drivers/power/tps65090-charger.c
index 9fbca310a2ad,dcf9a3ca53d5..000000000000
--- a/drivers/power/tps65090-charger.c
+++ b/drivers/power/tps65090-charger.c
@@@ -45,7 -41,9 +45,13 @@@ struct tps65090_charger 
  	int	ac_online;
  	int	prev_ac_online;
  	int	irq;
++<<<<<<< HEAD
 +	struct power_supply	ac;
++=======
+ 	struct task_struct	*poll_task;
+ 	bool			passive_mode;
+ 	struct power_supply	*ac;
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	struct tps65090_platform_data *pdata;
  };
  
@@@ -154,8 -177,19 +159,8 @@@ static irqreturn_t tps65090_charger_isr
  		charger->ac_online = 0;
  	}
  
 -	/* Clear interrupts. */
 -	if (!charger->passive_mode) {
 -		ret = tps65090_write(charger->dev->parent,
 -				     TPS65090_REG_INTR_STS, 0x00);
 -		if (ret < 0) {
 -			dev_err(charger->dev,
 -				"%s(): Error in writing reg 0x%x\n",
 -				__func__, TPS65090_REG_INTR_STS);
 -		}
 -	}
 -
  	if (charger->prev_ac_online != charger->ac_online)
- 		power_supply_changed(&charger->ac);
+ 		power_supply_changed(charger->ac);
  
  	return IRQ_HANDLED;
  }
@@@ -185,14 -215,27 +190,22 @@@ static struct tps65090_platform_data 
  	return pdata;
  
  }
 -
 -static int tps65090_charger_poll_task(void *data)
 +#else
 +static struct tps65090_platform_data *
 +		tps65090_parse_dt_charger_data(struct platform_device *pdev)
  {
 -	set_freezable();
 -
 -	while (!kthread_should_stop()) {
 -		schedule_timeout_interruptible(POLL_INTERVAL);
 -		try_to_freeze();
 -		tps65090_charger_isr(-1, data);
 -	}
 -	return 0;
 +	return NULL;
  }
 +#endif
  
+ static const struct power_supply_desc tps65090_charger_desc = {
+ 	.name			= "tps65090-ac",
+ 	.type			= POWER_SUPPLY_TYPE_MAINS,
+ 	.get_property		= tps65090_ac_get_property,
+ 	.properties		= tps65090_ac_props,
+ 	.num_properties		= ARRAY_SIZE(tps65090_ac_props),
+ };
+ 
  static int tps65090_charger_probe(struct platform_device *pdev)
  {
  	struct tps65090_charger *cdata;
@@@ -223,18 -267,16 +236,29 @@@
  	cdata->dev			= &pdev->dev;
  	cdata->pdata			= pdata;
  
++<<<<<<< HEAD
 +	cdata->ac.name			= "tps65090-ac";
 +	cdata->ac.type			= POWER_SUPPLY_TYPE_MAINS;
 +	cdata->ac.get_property		= tps65090_ac_get_property;
 +	cdata->ac.properties		= tps65090_ac_props;
 +	cdata->ac.num_properties	= ARRAY_SIZE(tps65090_ac_props);
 +	cdata->ac.supplied_to		= pdata->supplied_to;
 +	cdata->ac.num_supplicants	= pdata->num_supplicants;
 +
 +	ret = power_supply_register(&pdev->dev, &cdata->ac);
 +	if (ret) {
++=======
+ 	psy_cfg.supplied_to		= pdata->supplied_to;
+ 	psy_cfg.num_supplicants		= pdata->num_supplicants;
+ 	psy_cfg.of_node			= pdev->dev.of_node;
+ 	psy_cfg.drv_data		= cdata;
+ 
+ 	cdata->ac = power_supply_register(&pdev->dev, &tps65090_charger_desc,
+ 			&psy_cfg);
+ 	if (IS_ERR(cdata->ac)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&pdev->dev, "failed: power supply register\n");
- 		return ret;
+ 		return PTR_ERR(cdata->ac);
  	}
  
  	irq = platform_get_irq(pdev, 0);
@@@ -270,31 -300,51 +294,37 @@@
  	}
  
  	if (status1 != 0) {
 -		ret = tps65090_enable_charging(cdata);
 +		ret = tps65090_enable_charging(cdata, 1);
  		if (ret < 0) {
  			dev_err(cdata->dev, "error enabling charger\n");
 -			goto fail_unregister_supply;
 +			goto fail_free_irq;
  		}
  		cdata->ac_online = 1;
- 		power_supply_changed(&cdata->ac);
+ 		power_supply_changed(cdata->ac);
  	}
  
 -	if (irq != -ENXIO) {
 -		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
 -			tps65090_charger_isr, 0, "tps65090-charger", cdata);
 -		if (ret) {
 -			dev_err(cdata->dev,
 -				"Unable to register irq %d err %d\n", irq,
 -				ret);
 -			goto fail_unregister_supply;
 -		}
 -	} else {
 -		cdata->poll_task = kthread_run(tps65090_charger_poll_task,
 -					      cdata, "ktps65090charger");
 -		cdata->passive_mode = true;
 -		if (IS_ERR(cdata->poll_task)) {
 -			ret = PTR_ERR(cdata->poll_task);
 -			dev_err(cdata->dev,
 -				"Unable to run kthread err %d\n", ret);
 -			goto fail_unregister_supply;
 -		}
 -	}
 -
  	return 0;
  
 +fail_free_irq:
 +	devm_free_irq(cdata->dev, irq, cdata);
  fail_unregister_supply:
- 	power_supply_unregister(&cdata->ac);
+ 	power_supply_unregister(cdata->ac);
  
  	return ret;
  }
  
  static int tps65090_charger_remove(struct platform_device *pdev)
  {
 -	struct tps65090_charger *cdata = platform_get_drvdata(pdev);
 +	struct tps65090_charger *cdata = dev_get_drvdata(&pdev->dev);
  
++<<<<<<< HEAD
 +	devm_free_irq(cdata->dev, cdata->irq, cdata);
 +	power_supply_unregister(&cdata->ac);
++=======
+ 	if (cdata->irq == -ENXIO)
+ 		kthread_stop(cdata->poll_task);
+ 	power_supply_unregister(cdata->ac);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  	return 0;
  }
diff --cc drivers/power/twl4030_charger.c
index bed458172dd2,02a522cb7753..000000000000
--- a/drivers/power/twl4030_charger.c
+++ b/drivers/power/twl4030_charger.c
@@@ -490,6 -530,50 +490,53 @@@ static enum power_supply_property twl40
  	POWER_SUPPLY_PROP_CURRENT_NOW,
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_OF
+ static const struct twl4030_bci_platform_data *
+ twl4030_bci_parse_dt(struct device *dev)
+ {
+ 	struct device_node *np = dev->of_node;
+ 	struct twl4030_bci_platform_data *pdata;
+ 	u32 num;
+ 
+ 	if (!np)
+ 		return NULL;
+ 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return pdata;
+ 
+ 	if (of_property_read_u32(np, "ti,bb-uvolt", &num) == 0)
+ 		pdata->bb_uvolt = num;
+ 	if (of_property_read_u32(np, "ti,bb-uamp", &num) == 0)
+ 		pdata->bb_uamp = num;
+ 	return pdata;
+ }
+ #else
+ static inline const struct twl4030_bci_platform_data *
+ twl4030_bci_parse_dt(struct device *dev)
+ {
+ 	return NULL;
+ }
+ #endif
+ 
+ static const struct power_supply_desc twl4030_bci_ac_desc = {
+ 	.name		= "twl4030_ac",
+ 	.type		= POWER_SUPPLY_TYPE_MAINS,
+ 	.properties	= twl4030_charger_props,
+ 	.num_properties	= ARRAY_SIZE(twl4030_charger_props),
+ 	.get_property	= twl4030_bci_get_property,
+ };
+ 
+ static const struct power_supply_desc twl4030_bci_usb_desc = {
+ 	.name		= "twl4030_usb",
+ 	.type		= POWER_SUPPLY_TYPE_USB,
+ 	.properties	= twl4030_charger_props,
+ 	.num_properties	= ARRAY_SIZE(twl4030_charger_props),
+ 	.get_property	= twl4030_bci_get_property,
+ };
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  static int __init twl4030_bci_probe(struct platform_device *pdev)
  {
  	struct twl4030_bci *bci;
@@@ -505,30 -592,29 +552,39 @@@
  	bci->irq_chg = platform_get_irq(pdev, 0);
  	bci->irq_bci = platform_get_irq(pdev, 1);
  
 -	/* Only proceed further *IF* battery is physically present */
 -	ret = twl4030_is_battery_present(bci);
 -	if  (ret) {
 -		dev_crit(&pdev->dev, "Battery was not detected:%d\n", ret);
 -		goto fail_no_battery;
 -	}
 -
  	platform_set_drvdata(pdev, bci);
++<<<<<<< HEAD
 +
 +	bci->ac.name = "twl4030_ac";
 +	bci->ac.type = POWER_SUPPLY_TYPE_MAINS;
 +	bci->ac.properties = twl4030_charger_props;
 +	bci->ac.num_properties = ARRAY_SIZE(twl4030_charger_props);
 +	bci->ac.get_property = twl4030_bci_get_property;
 +
 +	ret = power_supply_register(&pdev->dev, &bci->ac);
 +	if (ret) {
++=======
+ 
+ 	bci->ac = power_supply_register(&pdev->dev, &twl4030_bci_ac_desc,
+ 					NULL);
+ 	if (IS_ERR(bci->ac)) {
+ 		ret = PTR_ERR(bci->ac);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&pdev->dev, "failed to register ac: %d\n", ret);
  		goto fail_register_ac;
  	}
  
- 	bci->usb.name = "twl4030_usb";
- 	bci->usb.type = POWER_SUPPLY_TYPE_USB;
- 	bci->usb.properties = twl4030_charger_props;
- 	bci->usb.num_properties = ARRAY_SIZE(twl4030_charger_props);
- 	bci->usb.get_property = twl4030_bci_get_property;
- 
  	bci->usb_reg = regulator_get(bci->dev, "bci3v1");
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&pdev->dev, &bci->usb);
 +	if (ret) {
++=======
+ 	bci->usb = power_supply_register(&pdev->dev, &twl4030_bci_usb_desc,
+ 					 NULL);
+ 	if (IS_ERR(bci->usb)) {
+ 		ret = PTR_ERR(bci->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		dev_err(&pdev->dev, "failed to register usb: %d\n", ret);
  		goto fail_register_usb;
  	}
@@@ -590,11 -679,11 +646,11 @@@ fail_unmask_interrupts
  fail_bci_irq:
  	free_irq(bci->irq_chg, bci);
  fail_chg_irq:
- 	power_supply_unregister(&bci->usb);
+ 	power_supply_unregister(bci->usb);
  fail_register_usb:
- 	power_supply_unregister(&bci->ac);
+ 	power_supply_unregister(bci->ac);
  fail_register_ac:
 -fail_no_battery:
 +	platform_set_drvdata(pdev, NULL);
  	kfree(bci);
  
  	return ret;
@@@ -620,9 -709,8 +676,14 @@@ static int __exit twl4030_bci_remove(st
  	}
  	free_irq(bci->irq_bci, bci);
  	free_irq(bci->irq_chg, bci);
++<<<<<<< HEAD
 +	power_supply_unregister(&bci->usb);
 +	power_supply_unregister(&bci->ac);
 +	platform_set_drvdata(pdev, NULL);
++=======
+ 	power_supply_unregister(bci->usb);
+ 	power_supply_unregister(bci->ac);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	kfree(bci);
  
  	return 0;
diff --cc drivers/power/wm831x_backup.c
index 56fb509f4be0,2e33109ca8c7..000000000000
--- a/drivers/power/wm831x_backup.c
+++ b/drivers/power/wm831x_backup.c
@@@ -192,14 -189,15 +189,24 @@@ static int wm831x_backup_probe(struct p
  		snprintf(devdata->name, sizeof(devdata->name),
  			 "wm831x-backup");
  
++<<<<<<< HEAD
 +	backup->name = devdata->name;
 +	backup->type = POWER_SUPPLY_TYPE_BATTERY;
 +	backup->properties = wm831x_backup_props;
 +	backup->num_properties = ARRAY_SIZE(wm831x_backup_props);
 +	backup->get_property = wm831x_backup_get_prop;
 +	ret = power_supply_register(&pdev->dev, backup);
- 
- 	return ret;
++=======
+ 	devdata->backup_desc.name = devdata->name;
+ 	devdata->backup_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+ 	devdata->backup_desc.properties = wm831x_backup_props;
+ 	devdata->backup_desc.num_properties = ARRAY_SIZE(wm831x_backup_props);
+ 	devdata->backup_desc.get_property = wm831x_backup_get_prop;
+ 	devdata->backup = power_supply_register(&pdev->dev,
+ 						&devdata->backup_desc, NULL);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
+ 
+ 	return PTR_ERR_OR_ZERO(devdata->backup);
  }
  
  static int wm831x_backup_remove(struct platform_device *pdev)
diff --cc drivers/power/wm831x_power.c
index 3bed2f55cf7d,0161bdabd5a3..000000000000
--- a/drivers/power/wm831x_power.c
+++ b/drivers/power/wm831x_power.c
@@@ -531,23 -527,28 +527,48 @@@ static int wm831x_power_probe(struct pl
  	 */
  	wm831x_config_battery(wm831x);
  
++<<<<<<< HEAD
 +	wall->name = power->wall_name;
 +	wall->type = POWER_SUPPLY_TYPE_MAINS;
 +	wall->properties = wm831x_wall_props;
 +	wall->num_properties = ARRAY_SIZE(wm831x_wall_props);
 +	wall->get_property = wm831x_wall_get_prop;
 +	ret = power_supply_register(&pdev->dev, wall);
 +	if (ret)
++=======
+ 	power->wall_desc.name = power->wall_name;
+ 	power->wall_desc.type = POWER_SUPPLY_TYPE_MAINS;
+ 	power->wall_desc.properties = wm831x_wall_props;
+ 	power->wall_desc.num_properties = ARRAY_SIZE(wm831x_wall_props);
+ 	power->wall_desc.get_property = wm831x_wall_get_prop;
+ 	power->wall = power_supply_register(&pdev->dev, &power->wall_desc,
+ 					    NULL);
+ 	if (IS_ERR(power->wall)) {
+ 		ret = PTR_ERR(power->wall);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_kmalloc;
+ 	}
  
++<<<<<<< HEAD
 +	usb->name = power->usb_name,
 +	usb->type = POWER_SUPPLY_TYPE_USB;
 +	usb->properties = wm831x_usb_props;
 +	usb->num_properties = ARRAY_SIZE(wm831x_usb_props);
 +	usb->get_property = wm831x_usb_get_prop;
 +	ret = power_supply_register(&pdev->dev, usb);
 +	if (ret)
++=======
+ 	power->usb_desc.name = power->usb_name,
+ 	power->usb_desc.type = POWER_SUPPLY_TYPE_USB;
+ 	power->usb_desc.properties = wm831x_usb_props;
+ 	power->usb_desc.num_properties = ARRAY_SIZE(wm831x_usb_props);
+ 	power->usb_desc.get_property = wm831x_usb_get_prop;
+ 	power->usb = power_supply_register(&pdev->dev, &power->usb_desc, NULL);
+ 	if (IS_ERR(power->usb)) {
+ 		ret = PTR_ERR(power->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err_wall;
+ 	}
  
  	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_CONTROL_1);
  	if (ret < 0)
@@@ -555,14 -556,18 +576,29 @@@
  	power->have_battery = ret & WM831X_CHG_ENA;
  
  	if (power->have_battery) {
++<<<<<<< HEAD
 +		    battery->name = power->battery_name;
 +		    battery->properties = wm831x_bat_props;
 +		    battery->num_properties = ARRAY_SIZE(wm831x_bat_props);
 +		    battery->get_property = wm831x_bat_get_prop;
 +		    battery->use_for_apm = 1;
 +		    ret = power_supply_register(&pdev->dev, battery);
 +		    if (ret)
 +			    goto err_usb;
++=======
+ 		power->battery_desc.name = power->battery_name;
+ 		power->battery_desc.properties = wm831x_bat_props;
+ 		power->battery_desc.num_properties = ARRAY_SIZE(wm831x_bat_props);
+ 		power->battery_desc.get_property = wm831x_bat_get_prop;
+ 		power->battery_desc.use_for_apm = 1;
+ 		power->battery = power_supply_register(&pdev->dev,
+ 						       &power->battery_desc,
+ 						       NULL);
+ 		if (IS_ERR(power->battery)) {
+ 			ret = PTR_ERR(power->battery);
+ 			goto err_usb;
+ 		}
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	}
  
  	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "SYSLO"));
diff --cc drivers/power/wm8350_power.c
index b3607e2906d2,5c5880664e09..000000000000
--- a/drivers/power/wm8350_power.c
+++ b/drivers/power/wm8350_power.c
@@@ -447,37 -471,24 +471,53 @@@ static int wm8350_power_probe(struct pl
  	struct wm8350 *wm8350 = platform_get_drvdata(pdev);
  	struct wm8350_power *power = &wm8350->power;
  	struct wm8350_charger_policy *policy = power->policy;
- 	struct power_supply *usb = &power->usb;
- 	struct power_supply *battery = &power->battery;
- 	struct power_supply *ac = &power->ac;
  	int ret;
  
++<<<<<<< HEAD
 +	ac->name = "wm8350-ac";
 +	ac->type = POWER_SUPPLY_TYPE_MAINS;
 +	ac->properties = wm8350_ac_props;
 +	ac->num_properties = ARRAY_SIZE(wm8350_ac_props);
 +	ac->get_property = wm8350_ac_get_prop;
 +	ret = power_supply_register(&pdev->dev, ac);
 +	if (ret)
 +		return ret;
 +
 +	battery->name = "wm8350-battery";
 +	battery->properties = wm8350_bat_props;
 +	battery->num_properties = ARRAY_SIZE(wm8350_bat_props);
 +	battery->get_property = wm8350_bat_get_property;
 +	battery->use_for_apm = 1;
 +	ret = power_supply_register(&pdev->dev, battery);
 +	if (ret)
++=======
+ 	power->ac = power_supply_register(&pdev->dev, &wm8350_ac_desc, NULL);
+ 	if (IS_ERR(power->ac))
+ 		return PTR_ERR(power->ac);
+ 
+ 	power->battery = power_supply_register(&pdev->dev, &wm8350_battery_desc,
+ 					       NULL);
+ 	if (IS_ERR(power->battery)) {
+ 		ret = PTR_ERR(power->battery);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto battery_failed;
+ 	}
  
++<<<<<<< HEAD
 +	usb->name = "wm8350-usb",
 +	usb->type = POWER_SUPPLY_TYPE_USB;
 +	usb->properties = wm8350_usb_props;
 +	usb->num_properties = ARRAY_SIZE(wm8350_usb_props);
 +	usb->get_property = wm8350_usb_get_prop;
 +	ret = power_supply_register(&pdev->dev, usb);
 +	if (ret)
++=======
+ 	power->usb = power_supply_register(&pdev->dev, &wm8350_usb_desc, NULL);
+ 	if (IS_ERR(power->usb)) {
+ 		ret = PTR_ERR(power->usb);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto usb_failed;
+ 	}
  
  	ret = device_create_file(&pdev->dev, &dev_attr_charger_state);
  	if (ret < 0)
diff --cc drivers/power/wm97xx_battery.c
index 58f7348e6c22,c2f09ed35050..000000000000
--- a/drivers/power/wm97xx_battery.c
+++ b/drivers/power/wm97xx_battery.c
@@@ -237,18 -238,20 +238,25 @@@ static int wm97xx_bat_probe(struct plat
  		dev_info(&dev->dev, "Please consider setting proper battery "
  				"name in platform definition file, falling "
  				"back to name \"wm97xx-batt\"\n");
- 		bat_ps.name = "wm97xx-batt";
+ 		bat_psy_desc.name = "wm97xx-batt";
  	} else
- 		bat_ps.name = pdata->batt_name;
+ 		bat_psy_desc.name = pdata->batt_name;
  
- 	bat_ps.properties = prop;
- 	bat_ps.num_properties = props;
+ 	bat_psy_desc.properties = prop;
+ 	bat_psy_desc.num_properties = props;
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&dev->dev, &bat_ps);
 +	if (!ret)
++=======
+ 	bat_psy = power_supply_register(&dev->dev, &bat_psy_desc, NULL);
+ 	if (!IS_ERR(bat_psy)) {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		schedule_work(&bat_work);
- 	else
+ 	} else {
+ 		ret = PTR_ERR(bat_psy);
  		goto err4;
+ 	}
  
  	return 0;
  err4:
diff --cc drivers/power/z2_battery.c
index 814d2e31f0c9,b201e3facf73..000000000000
--- a/drivers/power/z2_battery.c
+++ b/drivers/power/z2_battery.c
@@@ -230,9 -234,13 +234,18 @@@ static int z2_batt_probe(struct i2c_cli
  
  	INIT_WORK(&charger->bat_work, z2_batt_work);
  
++<<<<<<< HEAD
 +	ret = power_supply_register(&client->dev, &charger->batt_ps);
 +	if (ret)
++=======
+ 	charger->batt_ps = power_supply_register(&client->dev,
+ 						 &charger->batt_ps_desc,
+ 						 &psy_cfg);
+ 	if (IS_ERR(charger->batt_ps)) {
+ 		ret = PTR_ERR(charger->batt_ps);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  		goto err4;
+ 	}
  
  	schedule_work(&charger->bat_work);
  
diff --cc drivers/staging/nvec/nvec_power.c
index aacfcd6954a3,30b66c3c9b73..000000000000
--- a/drivers/staging/nvec/nvec_power.c
+++ b/drivers/staging/nvec/nvec_power.c
@@@ -225,7 -225,8 +225,12 @@@ static int nvec_power_get_property(stru
  				   enum power_supply_property psp,
  				   union power_supply_propval *val)
  {
++<<<<<<< HEAD
 +	struct nvec_power *power = dev_get_drvdata(psy->dev->parent);
++=======
+ 	struct nvec_power *power = dev_get_drvdata(psy->dev.parent);
+ 
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	switch (psp) {
  	case POWER_SUPPLY_PROP_ONLINE:
  		val->intval = power->on;
@@@ -330,11 -331,9 +335,11 @@@ static const struct power_supply_desc n
  	.get_property = nvec_battery_get_property,
  };
  
- static struct power_supply nvec_psy = {
+ static const struct power_supply_desc nvec_psy_desc = {
  	.name = "ac",
  	.type = POWER_SUPPLY_TYPE_MAINS,
 +	.supplied_to = nvec_power_supplied_to,
 +	.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to),
  	.properties = nvec_power_props,
  	.num_properties = ARRAY_SIZE(nvec_power_props),
  	.get_property = nvec_power_get_property,
@@@ -372,9 -371,11 +377,10 @@@ static void nvec_power_poll(struct work
  
  static int nvec_power_probe(struct platform_device *pdev)
  {
- 	struct power_supply *psy;
+ 	struct power_supply **psy;
+ 	const struct power_supply_desc *psy_desc;
  	struct nvec_power *power;
  	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
 -	struct power_supply_config psy_cfg = {};
  
  	power = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);
  	if (power == NULL)
@@@ -386,6 -387,9 +392,12 @@@
  	switch (pdev->id) {
  	case AC:
  		psy = &nvec_psy;
++<<<<<<< HEAD
++=======
+ 		psy_desc = &nvec_psy_desc;
+ 		psy_cfg.supplied_to = nvec_power_supplied_to;
+ 		psy_cfg.num_supplicants = ARRAY_SIZE(nvec_power_supplied_to);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  
  		power->notifier.notifier_call = nvec_power_notifier;
  
@@@ -406,7 -411,9 +419,13 @@@
  	if (pdev->id == BAT)
  		get_bat_mfg_data(power);
  
++<<<<<<< HEAD
 +	return power_supply_register(&pdev->dev, psy);
++=======
+ 	*psy = power_supply_register(&pdev->dev, psy_desc, &psy_cfg);
+ 
+ 	return PTR_ERR_OR_ZERO(*psy);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  }
  
  static int nvec_power_remove(struct platform_device *pdev)
diff --cc include/linux/power_supply.h
index b5a0d5291835,ea15eb68f609..000000000000
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@@ -164,20 -175,31 +165,45 @@@ union power_supply_propval 
  };
  
  struct device_node;
+ struct power_supply;
  
++<<<<<<< HEAD
 +struct power_supply {
++=======
+ /* Run-time specific power supply configuration */
+ struct power_supply_config {
+ 	struct device_node *of_node;
+ 	/* Driver private data */
+ 	void *drv_data;
+ 
+ 	char **supplied_to;
+ 	size_t num_supplicants;
+ };
+ 
+ /* Description of power supply */
+ struct power_supply_desc {
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	const char *name;
  	enum power_supply_type type;
  	enum power_supply_property *properties;
  	size_t num_properties;
  
++<<<<<<< HEAD
 +	char **supplied_to;
 +	size_t num_supplicants;
 +
 +	char **supplied_from;
 +	size_t num_supplies;
 +	struct device_node *of_node;
 +
++=======
+ 	/*
+ 	 * Functions for drivers implementing power supply class.
+ 	 * These shouldn't be called directly by other drivers for accessing
+ 	 * this power supply. Instead use power_supply_*() functions (for
+ 	 * example power_supply_get_property()).
+ 	 */
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  	int (*get_property)(struct power_supply *psy,
  			    enum power_supply_property psp,
  			    union power_supply_propval *val);
@@@ -189,8 -211,25 +215,19 @@@
  	void (*external_power_changed)(struct power_supply *psy);
  	void (*set_charged)(struct power_supply *psy);
  
 -	/*
 -	 * Set if thermal zone should not be created for this power supply.
 -	 * For example for virtual supplies forwarding calls to actual
 -	 * sensors or other supplies.
 -	 */
 -	bool no_thermal;
  	/* For APM emulation, think legacy userspace. */
  	int use_for_apm;
+ };
+ 
+ struct power_supply {
+ 	const struct power_supply_desc *desc;
+ 
+ 	char **supplied_to;
+ 	size_t num_supplicants;
+ 
+ 	char **supplied_from;
+ 	size_t num_supplies;
+ 	struct device_node *of_node;
  
  	/* Driver private data */
  	void *drv_data;
@@@ -249,14 -300,32 +286,43 @@@ extern int power_supply_is_system_suppl
  static inline int power_supply_is_system_supplied(void) { return -ENOSYS; }
  #endif
  
++<<<<<<< HEAD
 +extern int power_supply_register(struct device *parent,
 +				 struct power_supply *psy);
 +extern int power_supply_register_no_ws(struct device *parent,
 +				 struct power_supply *psy);
 +extern int devm_power_supply_register(struct device *parent,
 +				 struct power_supply *psy);
 +extern int devm_power_supply_register_no_ws(struct device *parent,
 +				 struct power_supply *psy);
++=======
+ extern int power_supply_get_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    union power_supply_propval *val);
+ extern int power_supply_set_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    const union power_supply_propval *val);
+ extern int power_supply_property_is_writeable(struct power_supply *psy,
+ 					enum power_supply_property psp);
+ extern void power_supply_external_power_changed(struct power_supply *psy);
+ 
+ extern struct power_supply *__must_check
+ power_supply_register(struct device *parent,
+ 				 const struct power_supply_desc *desc,
+ 				 const struct power_supply_config *cfg);
+ extern struct power_supply *__must_check
+ power_supply_register_no_ws(struct device *parent,
+ 				 const struct power_supply_desc *desc,
+ 				 const struct power_supply_config *cfg);
+ extern struct power_supply *__must_check
+ devm_power_supply_register(struct device *parent,
+ 				 const struct power_supply_desc *desc,
+ 				 const struct power_supply_config *cfg);
+ extern struct power_supply *__must_check
+ devm_power_supply_register_no_ws(struct device *parent,
+ 				 const struct power_supply_desc *desc,
+ 				 const struct power_supply_config *cfg);
++>>>>>>> 297d716f6260 (power_supply: Change ownership from driver to core)
  extern void power_supply_unregister(struct power_supply *psy);
  extern int power_supply_powers(struct power_supply *psy, struct device *dev);
  
* Unmerged path drivers/hid/hid-wiimote-modules.c
* Unmerged path drivers/power/axp288_fuel_gauge.c
* Unmerged path drivers/power/bq24190_charger.c
* Unmerged path drivers/power/bq24735-charger.c
* Unmerged path drivers/power/da9150-charger.c
* Unmerged path drivers/power/ipaq_micro_battery.c
* Unmerged path drivers/power/ltc2941-battery-gauge.c
* Unmerged path drivers/power/max14577_charger.c
* Unmerged path drivers/power/max77693_charger.c
* Unmerged path drivers/power/rt5033_battery.c
* Unmerged path drivers/power/twl4030_madc_battery.c
* Unmerged path include/linux/mfd/rt5033.h
diff --git a/arch/x86/platform/olpc/olpc-xo1-sci.c b/arch/x86/platform/olpc/olpc-xo1-sci.c
index 9a2e590dd202..e4ed28bbf79d 100644
--- a/arch/x86/platform/olpc/olpc-xo1-sci.c
+++ b/arch/x86/platform/olpc/olpc-xo1-sci.c
@@ -61,7 +61,7 @@ static void battery_status_changed(void)
 
 	if (psy) {
 		power_supply_changed(psy);
-		put_device(psy->dev);
+		put_device(&psy->dev);
 	}
 }
 
@@ -71,7 +71,7 @@ static void ac_status_changed(void)
 
 	if (psy) {
 		power_supply_changed(psy);
-		put_device(psy->dev);
+		put_device(&psy->dev);
 	}
 }
 
diff --git a/arch/x86/platform/olpc/olpc-xo15-sci.c b/arch/x86/platform/olpc/olpc-xo15-sci.c
index fef7d0ba7e3a..d4bab59c05f5 100644
--- a/arch/x86/platform/olpc/olpc-xo15-sci.c
+++ b/arch/x86/platform/olpc/olpc-xo15-sci.c
@@ -91,7 +91,7 @@ static void battery_status_changed(void)
 
 	if (psy) {
 		power_supply_changed(psy);
-		put_device(psy->dev);
+		put_device(&psy->dev);
 	}
 }
 
@@ -101,7 +101,7 @@ static void ac_status_changed(void)
 
 	if (psy) {
 		power_supply_changed(psy);
-		put_device(psy->dev);
+		put_device(&psy->dev);
 	}
 }
 
* Unmerged path drivers/acpi/ac.c
* Unmerged path drivers/acpi/battery.c
* Unmerged path drivers/acpi/sbs.c
* Unmerged path drivers/hid/hid-input.c
* Unmerged path drivers/hid/hid-sony.c
* Unmerged path drivers/hid/hid-wiimote-modules.c
* Unmerged path drivers/hid/hid-wiimote.h
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/platform/x86/compal-laptop.c
* Unmerged path drivers/power/88pm860x_battery.c
* Unmerged path drivers/power/88pm860x_charger.c
* Unmerged path drivers/power/ab8500_btemp.c
* Unmerged path drivers/power/ab8500_charger.c
* Unmerged path drivers/power/ab8500_fg.c
* Unmerged path drivers/power/abx500_chargalg.c
diff --git a/drivers/power/apm_power.c b/drivers/power/apm_power.c
index 39763015b360..0d5056dfb789 100644
--- a/drivers/power/apm_power.c
+++ b/drivers/power/apm_power.c
@@ -48,7 +48,7 @@ static int __find_main_battery(struct device *dev, void *data)
 
 	bp->bat = dev_get_drvdata(dev);
 
-	if (bp->bat->use_for_apm) {
+	if (bp->bat->desc->use_for_apm) {
 		/* nice, we explicitly asked to report this battery. */
 		bp->main = bp->bat;
 		return 1;
* Unmerged path drivers/power/axp288_fuel_gauge.c
* Unmerged path drivers/power/bq2415x_charger.c
* Unmerged path drivers/power/bq24190_charger.c
* Unmerged path drivers/power/bq24735-charger.c
* Unmerged path drivers/power/bq27x00_battery.c
* Unmerged path drivers/power/charger-manager.c
* Unmerged path drivers/power/collie_battery.c
* Unmerged path drivers/power/da9030_battery.c
* Unmerged path drivers/power/da9052-battery.c
* Unmerged path drivers/power/da9150-charger.c
* Unmerged path drivers/power/ds2760_battery.c
* Unmerged path drivers/power/ds2780_battery.c
* Unmerged path drivers/power/ds2781_battery.c
* Unmerged path drivers/power/ds2782_battery.c
* Unmerged path drivers/power/generic-adc-battery.c
* Unmerged path drivers/power/goldfish_battery.c
* Unmerged path drivers/power/gpio-charger.c
* Unmerged path drivers/power/intel_mid_battery.c
* Unmerged path drivers/power/ipaq_micro_battery.c
* Unmerged path drivers/power/isp1704_charger.c
* Unmerged path drivers/power/jz4740-battery.c
* Unmerged path drivers/power/lp8727_charger.c
* Unmerged path drivers/power/lp8788-charger.c
* Unmerged path drivers/power/ltc2941-battery-gauge.c
* Unmerged path drivers/power/max14577_charger.c
* Unmerged path drivers/power/max17040_battery.c
* Unmerged path drivers/power/max17042_battery.c
* Unmerged path drivers/power/max77693_charger.c
* Unmerged path drivers/power/max8903_charger.c
* Unmerged path drivers/power/max8925_power.c
* Unmerged path drivers/power/max8997_charger.c
* Unmerged path drivers/power/max8998_charger.c
* Unmerged path drivers/power/olpc_battery.c
* Unmerged path drivers/power/pcf50633-charger.c
* Unmerged path drivers/power/pda_power.c
* Unmerged path drivers/power/pm2301_charger.c
diff --git a/drivers/power/pm2301_charger.h b/drivers/power/pm2301_charger.h
index 8ce3cc0195df..24181cf9717b 100644
--- a/drivers/power/pm2301_charger.h
+++ b/drivers/power/pm2301_charger.h
@@ -486,6 +486,7 @@ struct pm2xxx_charger {
 	struct work_struct check_main_thermal_prot_work;
 	struct delayed_work check_hw_failure_work;
 	struct ux500_charger ac_chg;
+	struct power_supply_desc ac_chg_desc;
 	struct pm2xxx_charger_event_flags flags;
 };
 
* Unmerged path drivers/power/pmu_battery.c
* Unmerged path drivers/power/power_supply_core.c
* Unmerged path drivers/power/power_supply_leds.c
* Unmerged path drivers/power/power_supply_sysfs.c
* Unmerged path drivers/power/rt5033_battery.c
* Unmerged path drivers/power/rx51_battery.c
* Unmerged path drivers/power/s3c_adc_battery.c
* Unmerged path drivers/power/sbs-battery.c
* Unmerged path drivers/power/smb347-charger.c
* Unmerged path drivers/power/test_power.c
* Unmerged path drivers/power/tosa_battery.c
* Unmerged path drivers/power/tps65090-charger.c
* Unmerged path drivers/power/twl4030_charger.c
* Unmerged path drivers/power/twl4030_madc_battery.c
* Unmerged path drivers/power/wm831x_backup.c
* Unmerged path drivers/power/wm831x_power.c
* Unmerged path drivers/power/wm8350_power.c
* Unmerged path drivers/power/wm97xx_battery.c
* Unmerged path drivers/power/z2_battery.c
* Unmerged path drivers/staging/nvec/nvec_power.c
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 2f007bf563d8..7b5f62adaeb7 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -493,10 +493,10 @@ struct hid_device {							/* device report descriptor */
 #ifdef CONFIG_HID_BATTERY_STRENGTH
 	/*
 	 * Power supply information for HID devices which report
-	 * battery strength. power_supply is registered iff
-	 * battery.name is non-NULL.
+	 * battery strength. power_supply was successfully registered if
+	 * battery is non-NULL.
 	 */
-	struct power_supply battery;
+	struct power_supply *battery;
 	__s32 battery_min;
 	__s32 battery_max;
 	__s32 battery_report_type;
diff --git a/include/linux/mfd/abx500/ux500_chargalg.h b/include/linux/mfd/abx500/ux500_chargalg.h
index 234c99143bf7..67703f23e7ba 100644
--- a/include/linux/mfd/abx500/ux500_chargalg.h
+++ b/include/linux/mfd/abx500/ux500_chargalg.h
@@ -9,8 +9,13 @@
 
 #include <linux/power_supply.h>
 
-#define psy_to_ux500_charger(x) container_of((x), \
-		struct ux500_charger, psy)
+/*
+ * Valid only for supplies of type:
+ * - POWER_SUPPLY_TYPE_MAINS,
+ * - POWER_SUPPLY_TYPE_USB,
+ * because only them store as drv_data pointer to struct ux500_charger.
+ */
+#define psy_to_ux500_charger(x) power_supply_get_drvdata(psy)
 
 /* Forward declaration */
 struct ux500_charger;
@@ -35,7 +40,7 @@ struct ux500_charger_ops {
  * @power_path		USB power path support
  */
 struct ux500_charger {
-	struct power_supply psy;
+	struct power_supply *psy;
 	struct ux500_charger_ops ops;
 	int max_out_volt;
 	int max_out_curr;
* Unmerged path include/linux/mfd/rt5033.h
diff --git a/include/linux/mfd/wm8350/supply.h b/include/linux/mfd/wm8350/supply.h
index 2b9479310bbd..8dc93673e34a 100644
--- a/include/linux/mfd/wm8350/supply.h
+++ b/include/linux/mfd/wm8350/supply.h
@@ -123,9 +123,9 @@ struct wm8350_charger_policy {
 
 struct wm8350_power {
 	struct platform_device *pdev;
-	struct power_supply battery;
-	struct power_supply usb;
-	struct power_supply ac;
+	struct power_supply *battery;
+	struct power_supply *usb;
+	struct power_supply *ac;
 	struct wm8350_charger_policy *policy;
 
 	int rev_g_coeff;
diff --git a/include/linux/power/charger-manager.h b/include/linux/power/charger-manager.h
index 0e86840eb603..50485f53c19a 100644
--- a/include/linux/power/charger-manager.h
+++ b/include/linux/power/charger-manager.h
@@ -259,7 +259,8 @@ struct charger_manager {
 	int last_temp_mC;
 
 	char psy_name_buf[PSY_NAME_MAX + 1];
-	struct power_supply charger_psy;
+	struct power_supply_desc charger_psy_desc;
+	struct power_supply *charger_psy;
 
 	bool status_save_ext_pwr_inserted;
 	bool status_save_batt;
* Unmerged path include/linux/power_supply.h
