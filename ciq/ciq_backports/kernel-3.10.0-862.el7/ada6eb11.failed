vmbus: only reschedule tasklet if time limit exceeded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit ada6eb11137be0baf846e00fca40fc096ba85a28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ada6eb11.failed

The change to reschedule tasklet if more data arrives in ring buffer
can cause performance regression if host timing is such that the
next response happens in small window.

Go back to a modified version of the original looping behavior.
If the race occurs in a small time, then loop. But if the tasklet
has been running for a long interval due to flood, then reschedule
the tasklet to allow migration to ksoftirqd.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ada6eb11137be0baf846e00fca40fc096ba85a28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/connection.c
diff --cc drivers/hv/connection.c
index 9b72ebcd37bc,fce27fb141cc..000000000000
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@@ -323,114 -295,48 +323,159 @@@ struct vmbus_channel *relid2channel(u3
  }
  
  /*
++<<<<<<< HEAD
 + * process_chn_event - Process a channel event notification
++=======
+  * vmbus_on_event - Process a channel event notification
+  *
+  * For batched channels (default) optimize host to guest signaling
+  * by ensuring:
+  * 1. While reading the channel, we disable interrupts from host.
+  * 2. Ensure that we process all posted messages from the host
+  *    before returning from this callback.
+  * 3. Once we return, enable signaling from the host. Once this
+  *    state is set we check to see if additional packets are
+  *    available to read. In this case we repeat the process.
+  *    If this tasklet has been running for a long time
+  *    then reschedule ourselves.
++>>>>>>> ada6eb11137b (vmbus: only reschedule tasklet if time limit exceeded)
 + */
 +static void process_chn_event(u32 relid)
 +{
++<<<<<<< HEAD
 +	struct vmbus_channel *channel;
 +	void *arg;
 +	bool read_state;
 +	u32 bytes_to_read;
 +
 +	/*
 +	 * Find the channel based on this relid and invokes the
 +	 * channel callback to process the event
 +	 */
 +	channel = pcpu_relid2channel(relid);
 +
 +	if (!channel)
 +		return;
 +
 +	/*
 +	 * A channel once created is persistent even when there
 +	 * is no driver handling the device. An unloading driver
 +	 * sets the onchannel_callback to NULL on the same CPU
 +	 * as where this interrupt is handled (in an interrupt context).
 +	 * Thus, checking and invoking the driver specific callback takes
 +	 * care of orderly unloading of the driver.
 +	 */
 +
 +	if (channel->onchannel_callback != NULL) {
 +		arg = channel->channel_callback_context;
 +		read_state = channel->batched_reading;
 +		/*
 +		 * This callback reads the messages sent by the host.
 +		 * We can optimize host to guest signaling by ensuring:
 +		 * 1. While reading the channel, we disable interrupts from
 +		 *    host.
 +		 * 2. Ensure that we process all posted messages from the host
 +		 *    before returning from this callback.
 +		 * 3. Once we return, enable signaling from the host. Once this
 +		 *    state is set we check to see if additional packets are
 +		 *    available to read. In this case we repeat the process.
 +		 */
 +
 +		do {
 +			if (read_state)
 +				hv_begin_read(&channel->inbound);
 +			channel->onchannel_callback(arg);
 +			if (read_state)
 +				bytes_to_read = hv_end_read(&channel->inbound);
 +			else
 +				bytes_to_read = 0;
 +		} while (read_state && (bytes_to_read != 0));
 +	}
 +}
 +
 +/*
 + * vmbus_on_event - Handler for events
   */
  void vmbus_on_event(unsigned long data)
  {
 +	u32 dword;
 +	u32 maxdword;
 +	int bit;
 +	u32 relid;
 +	u32 *recv_int_page = NULL;
 +	void *page_addr;
 +	int cpu = smp_processor_id();
 +	union hv_synic_event_flags *event;
 +
 +	if (vmbus_proto_version < VERSION_WIN8) {
 +		maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
 +		recv_int_page = vmbus_connection.recv_int_page;
 +	} else {
 +		/*
 +		 * When the host is win8 and beyond, the event page
 +		 * can be directly checked to get the id of the channel
 +		 * that has the interrupt pending.
 +		 */
 +		maxdword = HV_EVENT_FLAGS_DWORD_COUNT;
 +		page_addr = hv_context.synic_event_page[cpu];
 +		event = (union hv_synic_event_flags *)page_addr +
 +						 VMBUS_MESSAGE_SINT;
 +		recv_int_page = event->flags32;
 +	}
 +
 +
 +
 +	/* Check events */
 +	if (!recv_int_page)
 +		return;
 +	for (dword = 0; dword < maxdword; dword++) {
 +		if (!recv_int_page[dword])
 +			continue;
 +		for (bit = 0; bit < 32; bit++) {
 +			if (sync_test_and_clear_bit(bit,
 +				(unsigned long *)&recv_int_page[dword])) {
 +				relid = (dword << 5) + bit;
 +
 +				if (relid == 0)
 +					/*
 +					 * Special case - vmbus
 +					 * channel protocol msg
 +					 */
 +					continue;
 +
 +				process_chn_event(relid);
 +			}
 +		}
 +	}
++=======
+ 	struct vmbus_channel *channel = (void *) data;
+ 	unsigned long time_limit = jiffies + 2;
+ 
+ 	do {
+ 		void (*callback_fn)(void *);
+ 
+ 		/* A channel once created is persistent even when
+ 		 * there is no driver handling the device. An
+ 		 * unloading driver sets the onchannel_callback to NULL.
+ 		 */
+ 		callback_fn = READ_ONCE(channel->onchannel_callback);
+ 		if (unlikely(callback_fn == NULL))
+ 			return;
+ 
+ 		(*callback_fn)(channel->channel_callback_context);
+ 
+ 		if (channel->callback_mode != HV_CALL_BATCHED)
+ 			return;
+ 
+ 		if (likely(hv_end_read(&channel->inbound) == 0))
+ 			return;
+ 
+ 		hv_begin_read(&channel->inbound);
+ 	} while (likely(time_before(jiffies, time_limit)));
+ 
+ 	/* The time limit (2 jiffies) has been reached */
+ 	tasklet_schedule(&channel->callback_event);
++>>>>>>> ada6eb11137b (vmbus: only reschedule tasklet if time limit exceeded)
  }
  
  /*
* Unmerged path drivers/hv/connection.c
