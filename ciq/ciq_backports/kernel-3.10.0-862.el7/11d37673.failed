s390/crypto: use basic blocks for ap bus inline assemblies

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] crypto: use basic blocks for ap bus inline assemblies (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 95.50%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 11d376730384a07568b56ca8d43989d25e585760
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/11d37673.failed

Use only simple inline assemblies which consist of a single basic
block if the register asm construct is being used.

Otherwise gcc would generate broken code if the compiler option
--sanitize-coverage=trace-pc would be used.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 11d376730384a07568b56ca8d43989d25e585760)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,4feb27215ab6..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -179,13 -164,24 +179,26 @@@ static int ap_interrupts_available(void
   *
   * Returns 1 if AP configuration information is available.
   */
 +#ifdef CONFIG_64BIT
  static int ap_configuration_available(void)
  {
 -	return test_facility(12);
 +	return test_facility(2) && test_facility(12);
  }
 +#endif
  
+ static inline struct ap_queue_status
+ __pqap_tapq(ap_qid_t qid, unsigned long *info)
+ {
+ 	register unsigned long reg0 asm ("0") = qid;
+ 	register struct ap_queue_status reg1 asm ("1");
+ 	register unsigned long reg2 asm ("2") = 0UL;
+ 
+ 	asm volatile(".long 0xb2af0000"		/* PQAP(TAPQ) */
+ 		     : "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");
+ 	*info = reg2;
+ 	return reg1;
+ }
+ 
  /**
   * ap_test_queue(): Test adjunct processor queue.
   * @qid: The AP queue number
@@@ -195,35 -190,17 +208,43 @@@
   * Returns AP queue status structure.
   */
  static inline struct ap_queue_status
 -ap_test_queue(ap_qid_t qid, unsigned long *info)
 +ap_test_queue(ap_qid_t qid, int *queue_depth, int *device_type)
  {
- 	register unsigned long reg0 asm ("0") = qid;
- 	register struct ap_queue_status reg1 asm ("1");
- 	register unsigned long reg2 asm ("2") = 0UL;
+ 	struct ap_queue_status aqs;
+ 	unsigned long _info;
  
++<<<<<<< HEAD
 +	asm volatile(".long 0xb2af0000"		/* PQAP(TAPQ) */
 +		     : "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");
 +	*device_type = (int) (reg2 >> 24);
 +	*queue_depth = (int) (reg2 & 0xff);
 +	return reg1;
++=======
+ 	if (test_facility(15))
+ 		qid |= 1UL << 23;		/* set APFT T bit*/
+ 	aqs = __pqap_tapq(qid, &_info);
+ 	if (info)
+ 		*info = _info;
+ 	return aqs;
++>>>>>>> 11d376730384 (s390/crypto: use basic blocks for ap bus inline assemblies)
 +}
 +
 +/**
 + * ap_query_facilities(): PQAP(TAPQ) query facilities.
 + * @qid: The AP queue number
 + *
 + * Returns content of general register 2 after the PQAP(TAPQ)
 + * instruction was called.
 + */
 +static inline unsigned long ap_query_facilities(ap_qid_t qid)
 +{
 +	register unsigned long reg0 asm ("0") = qid | 0x00800000UL;
 +	register unsigned long reg1 asm ("1");
 +	register unsigned long reg2 asm ("2") = 0UL;
 +
 +	asm volatile(".long 0xb2af0000"  /* PQAP(TAPQ) */
 +		     : "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");
 +	return reg2;
  }
  
  /**
@@@ -266,31 -242,13 +287,40 @@@ ap_queue_interruption_control(ap_qid_t 
  		: "cc" );
  	return reg1_out;
  }
 +#endif
 +
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +static inline struct ap_queue_status
 +__ap_query_functions(ap_qid_t qid, unsigned int *functions)
 +{
 +	register unsigned long reg0 asm ("0") = 0UL | qid | (1UL << 23);
 +	register struct ap_queue_status reg1 asm ("1") = AP_QUEUE_STATUS_INVALID;
 +	register unsigned long reg2 asm ("2");
 +
 +	asm volatile(
 +		".long 0xb2af0000\n"		/* PQAP(TAPQ) */
 +		"0:\n"
 +		EX_TABLE(0b, 0b)
 +		: "+d" (reg0), "+d" (reg1), "=d" (reg2)
 +		:
 +		: "cc");
 +
 +	*functions = (unsigned int)(reg2 >> 32);
 +	return reg1;
 +}
 +#endif
  
 +#ifdef CONFIG_64BIT
 +static inline int __ap_query_configuration(struct ap_config_info *config)
++=======
+ /**
+  * ap_query_configuration(): Get AP configuration data
+  *
+  * Returns 0 on success, or -EOPNOTSUPP.
+  */
+ static inline int __ap_query_configuration(void)
++>>>>>>> 11d376730384 (s390/crypto: use basic blocks for ap bus inline assemblies)
  {
  	register unsigned long reg0 asm ("0") = 0x04000000UL;
  	register unsigned long reg1 asm ("1") = -EINVAL;
@@@ -307,46 -265,69 +337,53 @@@
  
  	return reg1;
  }
 +#endif
  
+ static inline int ap_query_configuration(void)
+ {
+ 	if (!ap_configuration)
+ 		return -EOPNOTSUPP;
+ 	return __ap_query_configuration();
+ }
+ 
  /**
 - * ap_init_configuration(): Allocate and query configuration array.
 + * ap_query_functions(): Query supported functions.
 + * @qid: The AP queue number
 + * @functions: Pointer to functions field.
 + *
 + * Returns
 + *   0	     on success.
 + *   -ENODEV  if queue not valid.
 + *   -EBUSY   if device busy.
 + *   -EINVAL  if query function is not supported
   */
 -static void ap_init_configuration(void)
 +static int ap_query_functions(ap_qid_t qid, unsigned int *functions)
  {
 -	if (!ap_configuration_available())
 -		return;
 -
 -	ap_configuration = kzalloc(sizeof(*ap_configuration), GFP_KERNEL);
 -	if (!ap_configuration)
 -		return;
 -	if (ap_query_configuration() != 0) {
 -		kfree(ap_configuration);
 -		ap_configuration = NULL;
 -		return;
 -	}
 -}
 +#ifdef CONFIG_64BIT
 +	struct ap_queue_status status;
  
 -/*
 - * ap_test_config(): helper function to extract the nrth bit
 - *		     within the unsigned int array field.
 - */
 -static inline int ap_test_config(unsigned int *field, unsigned int nr)
 -{
 -	return ap_test_bit((field + (nr >> 5)), (nr & 0x1f));
 -}
 +	status = __ap_query_functions(qid, functions);
  
 -/*
 - * ap_test_config_card_id(): Test, whether an AP card ID is configured.
 - * @id AP card ID
 - *
 - * Returns 0 if the card is not configured
 - *	   1 if the card is configured or
 - *	     if the configuration information is not available
 - */
 -static inline int ap_test_config_card_id(unsigned int id)
 -{
 -	if (!ap_configuration)	/* QCI not supported */
 -		return 1;
 -	return ap_test_config(ap_configuration->apm, id);
 -}
 +	if (ap_queue_status_invalid_test(&status))
 +		return -ENODEV;
  
 -/*
 - * ap_test_config_domain(): Test, whether an AP usage domain is configured.
 - * @domain AP usage domain ID
 - *
 - * Returns 0 if the usage domain is not configured
 - *	   1 if the usage domain is configured or
 - *	     if the configuration information is not available
 - */
 -static inline int ap_test_config_domain(unsigned int domain)
 -{
 -	if (!ap_configuration)	/* QCI not supported */
 -		return domain < 16;
 -	return ap_test_config(ap_configuration->aqm, domain);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		return 0;
 +	case AP_RESPONSE_Q_NOT_AVAIL:
 +	case AP_RESPONSE_DECONFIGURED:
 +	case AP_RESPONSE_CHECKSTOPPED:
 +	case AP_RESPONSE_INVALID_ADDRESS:
 +		return -ENODEV;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +	case AP_RESPONSE_BUSY:
 +	case AP_RESPONSE_OTHERWISE_CHANGED:
 +	default:
 +		return -EBUSY;
 +	}
 +#else
 +	return -EINVAL;
 +#endif
  }
  
  /**
@@@ -378,11 -360,28 +415,31 @@@ static int ap_queue_enable_interruption
  	default:
  		return -EBUSY;
  	}
 +#else
 +	return -EINVAL;
 +#endif
  }
  
+ static inline struct ap_queue_status
+ __nqap(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length)
+ {
+ 	typedef struct { char _[length]; } msgblock;
+ 	register unsigned long reg0 asm ("0") = qid | 0x40000000UL;
+ 	register struct ap_queue_status reg1 asm ("1");
+ 	register unsigned long reg2 asm ("2") = (unsigned long) msg;
+ 	register unsigned long reg3 asm ("3") = (unsigned long) length;
+ 	register unsigned long reg4 asm ("4") = (unsigned int) (psmid >> 32);
+ 	register unsigned long reg5 asm ("5") = psmid & 0xffffffff;
+ 
+ 	asm volatile (
+ 		"0: .long 0xb2ad0042\n"		/* NQAP */
+ 		"   brc   2,0b"
+ 		: "+d" (reg0), "=d" (reg1), "+d" (reg2), "+d" (reg3)
+ 		: "d" (reg4), "d" (reg5), "m" (*(msgblock *) msg)
+ 		: "cc");
+ 	return reg1;
+ }
+ 
  /**
   * __ap_send(): Send message to adjunct processor queue.
   * @qid: The AP queue number
@@@ -400,24 -399,9 +457,20 @@@ static inline struct ap_queue_statu
  __ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length,
  	  unsigned int special)
  {
++<<<<<<< HEAD
 +	typedef struct { char _[length]; } msgblock;
 +	register unsigned long reg0 asm ("0") = qid | 0x40000000UL;
 +	register struct ap_queue_status reg1 asm ("1");
 +	register unsigned long reg2 asm ("2") = (unsigned long) msg;
 +	register unsigned long reg3 asm ("3") = (unsigned long) length;
 +	register unsigned long reg4 asm ("4") = (unsigned int) (psmid >> 32);
 +	register unsigned long reg5 asm ("5") = (unsigned int) psmid;
 +
++=======
++>>>>>>> 11d376730384 (s390/crypto: use basic blocks for ap bus inline assemblies)
  	if (special == 1)
- 		reg0 |= 0x400000UL;
- 
- 	asm volatile (
- 		"0: .long 0xb2ad0042\n"		/* NQAP */
- 		"   brc   2,0b"
- 		: "+d" (reg0), "=d" (reg1), "+d" (reg2), "+d" (reg3)
- 		: "d" (reg4), "d" (reg5), "m" (*(msgblock *) msg)
- 		: "cc" );
- 	return reg1;
+ 		qid |= 0x400000UL;
+ 	return __nqap(qid, psmid, msg, length);
  }
  
  int ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length)
* Unmerged path drivers/s390/crypto/ap_bus.c
