dlm: use per-attribute show and store methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] use per-attribute show and store methods (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 94.12%
commit-author Christoph Hellwig <hch@lst.de>
commit 9ae0f367df5d0d7be09fad1e2e5b080f6a45ca6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9ae0f367.failed

To simplify the configfs interface and remove boilerplate code that also
causes binary bloat.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: David Teigland <teigland@redhat.com
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 9ae0f367df5d0d7be09fad1e2e5b080f6a45ca6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dlm/config.c
diff --cc fs/dlm/config.c
index 7d58d5b112b5,8e294fbbac39..000000000000
--- a/fs/dlm/config.c
+++ b/fs/dlm/config.c
@@@ -135,11 -109,14 +109,19 @@@ static ssize_t cluster_cluster_name_sho
  	return sprintf(buf, "%s\n", cl->cl_cluster_name);
  }
  
- static ssize_t cluster_cluster_name_write(struct dlm_cluster *cl,
+ static ssize_t cluster_cluster_name_store(struct config_item *item,
  					  const char *buf, size_t len)
  {
++<<<<<<< HEAD
 +	strncpy(dlm_config.ci_cluster_name, buf, DLM_LOCKSPACE_LEN);
 +	strncpy(cl->cl_cluster_name, buf, DLM_LOCKSPACE_LEN);
++=======
+ 	struct dlm_cluster *cl = config_item_to_cluster(item);
+ 
+ 	strlcpy(dlm_config.ci_cluster_name, buf,
+ 				sizeof(dlm_config.ci_cluster_name));
+ 	strlcpy(cl->cl_cluster_name, buf, sizeof(cl->cl_cluster_name));
++>>>>>>> 9ae0f367df5d (dlm: use per-attribute show and store methods)
  	return len;
  }
  
@@@ -684,64 -575,34 +578,42 @@@ void dlm_config_exit(void
   * Functions for user space to read/write attributes
   */
  
- static ssize_t show_cluster(struct config_item *i, struct configfs_attribute *a,
- 			    char *buf)
- {
- 	struct dlm_cluster *cl = config_item_to_cluster(i);
- 	struct cluster_attribute *cla =
- 			container_of(a, struct cluster_attribute, attr);
- 	return cla->show ? cla->show(cl, buf) : 0;
- }
- 
- static ssize_t store_cluster(struct config_item *i,
- 			     struct configfs_attribute *a,
- 			     const char *buf, size_t len)
- {
- 	struct dlm_cluster *cl = config_item_to_cluster(i);
- 	struct cluster_attribute *cla =
- 		container_of(a, struct cluster_attribute, attr);
- 	return cla->store ? cla->store(cl, buf, len) : -EINVAL;
- }
- 
- static ssize_t show_comm(struct config_item *i, struct configfs_attribute *a,
- 			 char *buf)
- {
- 	struct dlm_comm *cm = config_item_to_comm(i);
- 	struct comm_attribute *cma =
- 			container_of(a, struct comm_attribute, attr);
- 	return cma->show ? cma->show(cm, buf) : 0;
- }
- 
- static ssize_t store_comm(struct config_item *i, struct configfs_attribute *a,
- 			  const char *buf, size_t len)
- {
- 	struct dlm_comm *cm = config_item_to_comm(i);
- 	struct comm_attribute *cma =
- 		container_of(a, struct comm_attribute, attr);
- 	return cma->store ? cma->store(cm, buf, len) : -EINVAL;
- }
- 
- static ssize_t comm_nodeid_read(struct dlm_comm *cm, char *buf)
+ static ssize_t comm_nodeid_show(struct config_item *item, char *buf)
  {
- 	return sprintf(buf, "%d\n", cm->nodeid);
+ 	return sprintf(buf, "%d\n", config_item_to_comm(item)->nodeid);
  }
  
- static ssize_t comm_nodeid_write(struct dlm_comm *cm, const char *buf,
+ static ssize_t comm_nodeid_store(struct config_item *item, const char *buf,
  				 size_t len)
  {
++<<<<<<< HEAD
 +	cm->nodeid = simple_strtol(buf, NULL, 0);
++=======
+ 	int rc = kstrtoint(buf, 0, &config_item_to_comm(item)->nodeid);
+ 
+ 	if (rc)
+ 		return rc;
++>>>>>>> 9ae0f367df5d (dlm: use per-attribute show and store methods)
  	return len;
  }
  
- static ssize_t comm_local_read(struct dlm_comm *cm, char *buf)
+ static ssize_t comm_local_show(struct config_item *item, char *buf)
  {
- 	return sprintf(buf, "%d\n", cm->local);
+ 	return sprintf(buf, "%d\n", config_item_to_comm(item)->local);
  }
  
- static ssize_t comm_local_write(struct dlm_comm *cm, const char *buf,
+ static ssize_t comm_local_store(struct config_item *item, const char *buf,
  				size_t len)
  {
++<<<<<<< HEAD
 +	cm->local= simple_strtol(buf, NULL, 0);
++=======
+ 	struct dlm_comm *cm = config_item_to_comm(item);
+ 	int rc = kstrtoint(buf, 0, &cm->local);
+ 
+ 	if (rc)
+ 		return rc;
++>>>>>>> 9ae0f367df5d (dlm: use per-attribute show and store methods)
  	if (cm->local && !local_comm)
  		local_comm = cm;
  	return len;
@@@ -818,48 -682,50 +693,51 @@@ static ssize_t comm_addr_list_show(stru
  	return 4096 - allowance;
  }
  
- static ssize_t show_node(struct config_item *i, struct configfs_attribute *a,
- 			 char *buf)
- {
- 	struct dlm_node *nd = config_item_to_node(i);
- 	struct node_attribute *nda =
- 			container_of(a, struct node_attribute, attr);
- 	return nda->show ? nda->show(nd, buf) : 0;
- }
+ CONFIGFS_ATTR(comm_, nodeid);
+ CONFIGFS_ATTR(comm_, local);
+ CONFIGFS_ATTR_WO(comm_, addr);
+ CONFIGFS_ATTR_RO(comm_, addr_list);
  
- static ssize_t store_node(struct config_item *i, struct configfs_attribute *a,
- 			  const char *buf, size_t len)
- {
- 	struct dlm_node *nd = config_item_to_node(i);
- 	struct node_attribute *nda =
- 		container_of(a, struct node_attribute, attr);
- 	return nda->store ? nda->store(nd, buf, len) : -EINVAL;
- }
+ static struct configfs_attribute *comm_attrs[] = {
+ 	[COMM_ATTR_NODEID] = &comm_attr_nodeid,
+ 	[COMM_ATTR_LOCAL] = &comm_attr_local,
+ 	[COMM_ATTR_ADDR] = &comm_attr_addr,
+ 	[COMM_ATTR_ADDR_LIST] = &comm_attr_addr_list,
+ 	NULL,
+ };
  
- static ssize_t node_nodeid_read(struct dlm_node *nd, char *buf)
+ static ssize_t node_nodeid_show(struct config_item *item, char *buf)
  {
- 	return sprintf(buf, "%d\n", nd->nodeid);
+ 	return sprintf(buf, "%d\n", config_item_to_node(item)->nodeid);
  }
  
- static ssize_t node_nodeid_write(struct dlm_node *nd, const char *buf,
+ static ssize_t node_nodeid_store(struct config_item *item, const char *buf,
  				 size_t len)
  {
+ 	struct dlm_node *nd = config_item_to_node(item);
  	uint32_t seq = 0;
 -	int rc = kstrtoint(buf, 0, &nd->nodeid);
 -
 -	if (rc)
 -		return rc;
 +	nd->nodeid = simple_strtol(buf, NULL, 0);
  	dlm_comm_seq(nd->nodeid, &seq);
  	nd->comm_seq = seq;
  	return len;
  }
  
- static ssize_t node_weight_read(struct dlm_node *nd, char *buf)
+ static ssize_t node_weight_show(struct config_item *item, char *buf)
  {
- 	return sprintf(buf, "%d\n", nd->weight);
+ 	return sprintf(buf, "%d\n", config_item_to_node(item)->weight);
  }
  
- static ssize_t node_weight_write(struct dlm_node *nd, const char *buf,
+ static ssize_t node_weight_store(struct config_item *item, const char *buf,
  				 size_t len)
  {
++<<<<<<< HEAD
 +	nd->weight = simple_strtol(buf, NULL, 0);
++=======
+ 	int rc = kstrtoint(buf, 0, &config_item_to_node(item)->weight);
+ 
+ 	if (rc)
+ 		return rc;
++>>>>>>> 9ae0f367df5d (dlm: use per-attribute show and store methods)
  	return len;
  }
  
* Unmerged path fs/dlm/config.c
