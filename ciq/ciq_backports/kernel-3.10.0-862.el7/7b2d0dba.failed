x86/mm/pkeys: Pass VMA down in to fault signal generation code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mm/pkeys: Pass VMA down in to fault signal generation code (Rui Wang) [1272615]
Rebuild_FUZZ: 96.67%
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit 7b2d0dbac4890c8ca4a8acc57709639fc8b158e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7b2d0dba.failed

During a page fault, we look up the VMA to ensure that the fault
is in a region with a valid mapping.  But, in the top-level page
fault code we don't need the VMA for much else.  Once we have
decided that an access is bad, we are going to send a signal no
matter what and do not need the VMA any more.  So we do not pass
it down in to the signal generation code.

But, for protection keys, we need the VMA.  It tells us *which*
protection key we violated if we get a PF_PK.  So, we need to
pass the VMA down and fill in siginfo->si_pkey.

	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave@sr71.net>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/20160212210211.AD3B36A3@viggo.jf.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 7b2d0dbac4890c8ca4a8acc57709639fc8b158e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/fault.c
diff --cc arch/x86/mm/fault.c
index 1977abf5754c,3c51c66b65fc..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -644,9 -655,10 +645,11 @@@ no_context(struct pt_regs *regs, unsign
  	   unsigned long address, int signal, int si_code)
  {
  	struct task_struct *tsk = current;
 +	unsigned long *stackend;
  	unsigned long flags;
  	int sig;
+ 	/* No context means no VMA to pass down */
+ 	struct vm_area_struct *vma = NULL;
  
  	/* Are we prepared to handle this kernel fault? */
  	if (fixup_exception(regs)) {
@@@ -656,8 -682,13 +659,9 @@@
  			tsk->thread.cr2 = address;
  
  			/* XXX: hwpoison faults will set the wrong code. */
- 			force_sig_info_fault(signal, si_code, address, tsk, 0);
+ 			force_sig_info_fault(signal, si_code, address,
+ 					     tsk, vma, 0);
  		}
 -
 -		/*
 -		 * Barring that, we can do the fixup and be happy.
 -		 */
  		return;
  	}
  
@@@ -877,7 -909,9 +883,13 @@@ mm_fault_error(struct pt_regs *regs, un
  	} else {
  		if (fault & (VM_FAULT_SIGBUS|VM_FAULT_HWPOISON|
  			     VM_FAULT_HWPOISON_LARGE))
++<<<<<<< HEAD
 +			do_sigbus(regs, error_code, address, fault);
++=======
+ 			do_sigbus(regs, error_code, address, vma, fault);
+ 		else if (fault & VM_FAULT_SIGSEGV)
+ 			bad_area_nosemaphore(regs, error_code, address, vma);
++>>>>>>> 7b2d0dbac489 (x86/mm/pkeys: Pass VMA down in to fault signal generation code)
  		else
  			BUG();
  	}
@@@ -1074,19 -1137,17 +1086,30 @@@ __do_page_fault(struct pt_regs *regs, u
  	if (unlikely(error_code & PF_RSVD))
  		pgtable_bad(regs, error_code, address);
  
++<<<<<<< HEAD
 +	if (static_cpu_has(X86_FEATURE_SMAP)) {
 +		if (unlikely(smap_violation(error_code, regs))) {
 +			bad_area_nosemaphore(regs, error_code, address);
 +			return;
 +		}
++=======
+ 	if (unlikely(smap_violation(error_code, regs))) {
+ 		bad_area_nosemaphore(regs, error_code, address, NULL);
+ 		return;
++>>>>>>> 7b2d0dbac489 (x86/mm/pkeys: Pass VMA down in to fault signal generation code)
  	}
  
  	/*
  	 * If we're in an interrupt, have no user context or are running
 -	 * in a region with pagefaults disabled then we must not take the fault
 +	 * in an atomic region then we must not take the fault:
  	 */
++<<<<<<< HEAD
 +	if (unlikely(in_atomic() || !mm)) {
 +		bad_area_nosemaphore(regs, error_code, address);
++=======
+ 	if (unlikely(faulthandler_disabled() || !mm)) {
+ 		bad_area_nosemaphore(regs, error_code, address, NULL);
++>>>>>>> 7b2d0dbac489 (x86/mm/pkeys: Pass VMA down in to fault signal generation code)
  		return;
  	}
  
* Unmerged path arch/x86/mm/fault.c
