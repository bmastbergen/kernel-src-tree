kvm: vmx: hook preemption timer support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yunhong Jiang <yunhong.jiang@intel.com>
commit 64672c95ea4c2f7096e519e826076867e8ef0938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/64672c95.failed

Hook the VMX preemption timer to the "hv timer" functionality added
by the previous patch.  This includes: checking if the feature is
supported, if the feature is broken on the CPU, the hooks to
setup/clean the VMX preemption timer, arming the timer on vmentry
and handling the vmexit.

A module parameter states if the VMX preemption timer should be
utilized.

	Signed-off-by: Yunhong Jiang <yunhong.jiang@intel.com>
[Move hv_deadline_tsc to struct vcpu_vmx, use -1 as the "unset" value.
 Put all VMX bits here.  Enable it by default #yolo. - Paolo]
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 64672c95ea4c2f7096e519e826076867e8ef0938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 04ec8bdd2903,e185649fb8b7..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -607,15 -604,14 +614,18 @@@ struct vcpu_vmx 
  #define PML_ENTITY_NUM		512
  	struct page *pml_pg;
  
+ 	/* apic deadline value in host tsc */
+ 	u64 hv_deadline_tsc;
+ 
  	u64 current_tsc_ratio;
  
 -	bool guest_pkru_valid;
 -	u32 guest_pkru;
 -	u32 host_pkru;
 +	/*
 +	 * Only bits masked by msr_ia32_feature_control_valid_bits can be set in
 +	 * msr_ia32_feature_control. FEATURE_CONTROL_LOCKED is always included
 +	 * in msr_ia32_feature_control_valid_bits.
 +	 */
 +	u64 msr_ia32_feature_control;
 +	u64 msr_ia32_feature_control_valid_bits;
  };
  
  enum segment_cache_field {
@@@ -6258,10 -6458,19 +6327,21 @@@ static __init int hardware_setup(void
  		kvm_x86_ops->enable_log_dirty_pt_masked = NULL;
  	}
  
+ 	if (cpu_has_vmx_preemption_timer() && enable_preemption_timer) {
+ 		u64 vmx_msr;
+ 
+ 		rdmsrl(MSR_IA32_VMX_MISC, vmx_msr);
+ 		cpu_preemption_timer_multi =
+ 			 vmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;
+ 	} else {
+ 		kvm_x86_ops->set_hv_timer = NULL;
+ 		kvm_x86_ops->cancel_hv_timer = NULL;
+ 	}
+ 
  	kvm_set_posted_intr_wakeup_handler(wakeup_handler);
  
 +	kvm_mce_cap_supported |= MCG_LMCE_P;
 +
  	return alloc_kvm_area();
  
  out8:
@@@ -7480,6 -7637,19 +7560,22 @@@ static int handle_pml_full(struct kvm_v
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ static int handle_pcommit(struct kvm_vcpu *vcpu)
+ {
+ 	/* we never catch pcommit instruct for L1 guest. */
+ 	WARN_ON(1);
+ 	return 1;
+ }
+ 
+ static int handle_preemption_timer(struct kvm_vcpu *vcpu)
+ {
+ 	kvm_lapic_expired_hv_timer(vcpu);
+ 	return 1;
+ }
+ 
++>>>>>>> 64672c95ea4c (kvm: vmx: hook preemption timer support)
  /*
   * The exit handlers return 1 if the exit was handled fully and guest execution
   * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
@@@ -7527,7 -7697,11 +7623,12 @@@ static int (*const kvm_vmx_exit_handler
  	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,
  	[EXIT_REASON_INVEPT]                  = handle_invept,
  	[EXIT_REASON_INVVPID]                 = handle_invvpid,
 -	[EXIT_REASON_XSAVES]                  = handle_xsaves,
 -	[EXIT_REASON_XRSTORS]                 = handle_xrstors,
  	[EXIT_REASON_PML_FULL]		      = handle_pml_full,
++<<<<<<< HEAD
++=======
+ 	[EXIT_REASON_PCOMMIT]                 = handle_pcommit,
+ 	[EXIT_REASON_PREEMPTION_TIMER]	      = handle_preemption_timer,
++>>>>>>> 64672c95ea4c (kvm: vmx: hook preemption timer support)
  };
  
  static const int kvm_vmx_max_exit_handlers =
@@@ -10994,7 -11212,10 +11181,14 @@@ static struct kvm_x86_ops vmx_x86_ops 
  
  	.update_pi_irte = vmx_update_pi_irte,
  
++<<<<<<< HEAD
 +	.setup_mce = vmx_setup_mce,
++=======
+ #ifdef CONFIG_X86_64
+ 	.set_hv_timer = vmx_set_hv_timer,
+ 	.cancel_hv_timer = vmx_cancel_hv_timer,
+ #endif
++>>>>>>> 64672c95ea4c (kvm: vmx: hook preemption timer support)
  };
  
  static int __init vmx_init(void)
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 7223dfd6e387..01c56f1db7de 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1028,6 +1028,8 @@ extern u32  kvm_max_guest_tsc_khz;
 extern u8   kvm_tsc_scaling_ratio_frac_bits;
 /* maximum allowed value of TSC scaling ratio */
 extern u64  kvm_max_tsc_scaling_ratio;
+/* 1ull << kvm_tsc_scaling_ratio_frac_bits */
+extern u64  kvm_default_tsc_scaling_ratio;
 
 extern u64 kvm_mce_cap_supported;
 
* Unmerged path arch/x86/kvm/vmx.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index db49db518a51..b94912e148ee 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -119,7 +119,8 @@ u8   __read_mostly kvm_tsc_scaling_ratio_frac_bits;
 EXPORT_SYMBOL_GPL(kvm_tsc_scaling_ratio_frac_bits);
 u64  __read_mostly kvm_max_tsc_scaling_ratio;
 EXPORT_SYMBOL_GPL(kvm_max_tsc_scaling_ratio);
-static u64 __read_mostly kvm_default_tsc_scaling_ratio;
+u64 __read_mostly kvm_default_tsc_scaling_ratio;
+EXPORT_SYMBOL_GPL(kvm_default_tsc_scaling_ratio);
 
 /* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */
 static u32 __read_mostly tsc_tolerance_ppm = 250;
