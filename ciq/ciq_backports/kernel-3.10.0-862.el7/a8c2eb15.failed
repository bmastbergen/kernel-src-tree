net/mlx5e: Stop NAPI when irq balancer changes affinity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Stop NAPI when irq balancer changes affinity (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.23%
commit-author Tariq Toukan <tariqt@mellanox.com>
commit a8c2eb15797a0f0bf17734d365da7bdc3e263155
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a8c2eb15.failed

NAPI context keeps rescheduling on same CPU as long as it's busy.
This doesn't give the oppurtunity for changes in irq affinities
to take effect.
Fix that by calling napi_complete_done() upon a change in affinity.
This would stop the NAPI and reschedule it on the new CPU.

	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a8c2eb15797a0f0bf17734d365da7bdc3e263155)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 9035c90d5238,20f34131d4e5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -1478,14 -1756,14 +1478,20 @@@ static int mlx5e_open_channel(struct ml
  			      struct mlx5e_channel_param *cparam,
  			      struct mlx5e_channel **cp)
  {
 -	struct mlx5e_cq_moder icocq_moder = {0, 0};
 +	struct mlx5e_cq_moder icosq_cq_moder = {0, 0};
  	struct net_device *netdev = priv->netdev;
 +	struct mlx5e_cq_moder rx_cq_profile;
  	int cpu = mlx5e_get_cpu(priv, ix);
  	struct mlx5e_channel *c;
++<<<<<<< HEAD
 +	struct mlx5e_sq *sq;
 +	int err;
 +	int i;
++=======
+ 	unsigned int irq;
+ 	int err;
+ 	int eqn;
++>>>>>>> a8c2eb15797a (net/mlx5e: Stop NAPI when irq balancer changes affinity)
  
  	c = kzalloc_node(sizeof(*c), GFP_KERNEL, cpu_to_node(cpu));
  	if (!c)
@@@ -1497,18 -1777,15 +1503,21 @@@
  	c->pdev     = &priv->mdev->pdev->dev;
  	c->netdev   = priv->netdev;
  	c->mkey_be  = cpu_to_be32(priv->mdev->mlx5e_res.mkey.key);
 -	c->num_tc   = params->num_tc;
 -	c->xdp      = !!params->xdp_prog;
 +	c->num_tc   = priv->params.num_tc;
 +
 +	if (priv->params.rx_am_enabled)
 +		rx_cq_profile = mlx5e_am_get_def_profile(priv->params.rx_cq_period_mode);
 +	else
 +		rx_cq_profile = priv->params.rx_cq_moderation;
 +
 +	mlx5e_build_channeltc_to_txq_map(priv, ix);
  
+ 	mlx5_vector2eqn(priv->mdev, ix, &eqn, &irq);
+ 	c->irq_desc = irq_to_desc(irq);
+ 
  	netif_napi_add(netdev, &c->napi, mlx5e_napi_poll, 64);
  
 -	err = mlx5e_open_cq(c, icocq_moder, &cparam->icosq_cq, &c->icosq.cq);
 +	err = mlx5e_open_cq(c, &cparam->icosq_cq, &c->icosq.cq, icosq_cq_moder);
  	if (err)
  		goto err_napi_del;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
index a75c0268e502,e906b754415c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
@@@ -30,79 -30,18 +30,92 @@@
   * SOFTWARE.
   */
  
+ #include <linux/irq.h>
  #include "en.h"
  
++<<<<<<< HEAD
 +struct mlx5_cqe64 *mlx5e_get_cqe(struct mlx5e_cq *cq)
 +{
 +	struct mlx5_cqwq *wq = &cq->wq;
 +	u32 ci = mlx5_cqwq_get_ci(wq);
 +	struct mlx5_cqe64 *cqe = mlx5_cqwq_get_wqe(wq, ci);
 +	u8 cqe_ownership_bit = cqe->op_own & MLX5_CQE_OWNER_MASK;
 +	u8 sw_ownership_val = mlx5_cqwq_get_wrap_cnt(wq) & 1;
 +
 +	if (cqe_ownership_bit != sw_ownership_val)
 +		return NULL;
 +
 +	/* ensure cqe content is read after cqe ownership bit */
 +	dma_rmb();
 +
 +	return cqe;
 +}
 +
 +static void mlx5e_poll_ico_cq(struct mlx5e_cq *cq)
 +{
 +	struct mlx5e_sq *sq = container_of(cq, struct mlx5e_sq, cq);
 +	struct mlx5_wq_cyc *wq;
 +	struct mlx5_cqe64 *cqe;
 +	u16 sqcc;
 +
 +	if (unlikely(!test_bit(MLX5E_SQ_STATE_ENABLED, &sq->state)))
 +		return;
 +
 +	cqe = mlx5e_get_cqe(cq);
 +	if (likely(!cqe))
 +		return;
 +
 +	wq = &sq->wq;
 +
 +	/* sq->cc must be updated only after mlx5_cqwq_update_db_record(),
 +	 * otherwise a cq overrun may occur
 +	 */
 +	sqcc = sq->cc;
 +
 +	do {
 +		u16 ci = be16_to_cpu(cqe->wqe_counter) & wq->sz_m1;
 +		struct mlx5e_ico_wqe_info *icowi = &sq->db.ico_wqe[ci];
 +
 +		mlx5_cqwq_pop(&cq->wq);
 +		sqcc += icowi->num_wqebbs;
 +
 +		if (unlikely((cqe->op_own >> 4) != MLX5_CQE_REQ)) {
 +			WARN_ONCE(true, "mlx5e: Bad OP in ICOSQ CQE: 0x%x\n",
 +				  cqe->op_own);
 +			break;
 +		}
 +
 +		switch (icowi->opcode) {
 +		case MLX5_OPCODE_NOP:
 +			break;
 +		case MLX5_OPCODE_UMR:
 +			mlx5e_post_rx_mpwqe(&sq->channel->rq);
 +			break;
 +		default:
 +			WARN_ONCE(true,
 +				  "mlx5e: Bad OPCODE in ICOSQ WQE info: 0x%x\n",
 +				  icowi->opcode);
 +		}
 +
 +	} while ((cqe = mlx5e_get_cqe(cq)));
 +
 +	mlx5_cqwq_update_db_record(&cq->wq);
 +
 +	/* ensure cq space is freed before enabling more cqes */
 +	wmb();
 +
 +	sq->cc = sqcc;
++=======
+ static inline bool mlx5e_channel_no_affinity_change(struct mlx5e_channel *c)
+ {
+ 	int current_cpu = smp_processor_id();
+ 	const struct cpumask *aff;
+ 	struct irq_data *idata;
+ 
+ 	idata = irq_desc_get_irq_data(c->irq_desc);
+ 	aff = irq_data_get_affinity_mask(idata);
+ 	return cpumask_test_cpu(current_cpu, aff);
++>>>>>>> a8c2eb15797a (net/mlx5e: Stop NAPI when irq balancer changes affinity)
  }
  
  int mlx5e_napi_poll(struct napi_struct *napi, int budget)
@@@ -121,20 -58,20 +134,24 @@@
  	work_done = mlx5e_poll_rx_cq(&c->rq.cq, budget);
  	busy |= work_done == budget;
  
 -	busy |= c->rq.post_wqes(&c->rq);
 +	mlx5e_poll_ico_cq(&c->icosq.cq);
 +
 +	busy |= mlx5e_post_rx_wqes(&c->rq);
  
- 	if (busy)
- 		return budget;
+ 	if (busy) {
+ 		if (likely(mlx5e_channel_no_affinity_change(c)))
+ 			return budget;
+ 		if (work_done == budget)
+ 			work_done--;
+ 	}
  
 -	if (unlikely(!napi_complete_done(napi, work_done)))
 +	napi_complete_done(napi, work_done);
 +
 +	/* avoid losing completion event during/after polling cqs */
 +	if (test_bit(MLX5E_CHANNEL_NAPI_SCHED, &c->flags)) {
 +		napi_schedule(napi);
  		return work_done;
 +	}
  
  	for (i = 0; i < c->num_tc; i++)
  		mlx5e_cq_arm(&c->sq[i].cq);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 54fbcbad0e6e..8f0d17a08f49 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -509,6 +509,9 @@ struct mlx5e_channel {
 	u8                         num_tc;
 	unsigned long              flags;
 
+	/* data path - accessed per napi poll */
+	struct irq_desc *irq_desc;
+
 	/* control */
 	struct mlx5e_priv         *priv;
 	int                        ix;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
