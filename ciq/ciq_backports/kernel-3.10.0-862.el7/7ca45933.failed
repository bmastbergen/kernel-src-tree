netvsc: fix netvsc_set_channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 7ca4593338e19595cad48fa8dcd1da28c81352d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7ca45933.failed

The number of channels returned by rndis_filter_device_add maybe
less than the number requested. Therefore set correct real
number of queues.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7ca4593338e19595cad48fa8dcd1da28c81352d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,e212cbeb6333..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -741,84 -718,55 +741,120 @@@ static int netvsc_set_channels(struct n
  {
  	struct net_device_context *net_device_ctx = netdev_priv(net);
  	struct hv_device *dev = net_device_ctx->device_ctx;
++<<<<<<< HEAD
 +	struct netvsc_device *nvdev = net_device_ctx->nvdev;
 +	struct netvsc_device_info device_info;
 +	u32 num_chn;
 +	u32 max_chn;
 +	int ret = 0;
 +	bool recovering = false;
++=======
+ 	struct netvsc_device *nvdev = rtnl_dereference(net_device_ctx->nvdev);
+ 	unsigned int orig, count = channels->combined_count;
+ 	struct netvsc_device_info device_info;
+ 	bool was_opened;
+ 	int ret = 0;
++>>>>>>> 7ca4593338e1 (netvsc: fix netvsc_set_channels)
  
 -	/* We do not support separate count for rx, tx, or other */
 -	if (count == 0 ||
 -	    channels->rx_count || channels->tx_count || channels->other_count)
 -		return -EINVAL;
 -
 -	if (count > net->num_tx_queues || count > VRSS_CHANNEL_MAX)
 -		return -EINVAL;
 -
 -	if (!nvdev || nvdev->destroy)
 +	if (net_device_ctx->start_remove || !nvdev || nvdev->destroy)
  		return -ENODEV;
  
 -	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5)
 +	num_chn = nvdev->num_chn;
 +	max_chn = min_t(u32, nvdev->max_chn, num_online_cpus());
 +
 +	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5) {
 +		pr_info("vRSS unsupported before NVSP Version 5\n");
  		return -EINVAL;
 +	}
  
 -	if (count > nvdev->max_chn)
 +	/* We do not support rx, tx, or other */
 +	if (!channels ||
 +	    channels->rx_count ||
 +	    channels->tx_count ||
 +	    channels->other_count ||
 +	    (channels->combined_count < 1))
  		return -EINVAL;
  
 +	if (channels->combined_count > max_chn) {
 +		pr_info("combined channels too high, using %d\n", max_chn);
 +		channels->combined_count = max_chn;
 +	}
 +
++<<<<<<< HEAD
 +	ret = netvsc_close(net);
 +	if (ret)
 +		goto out;
++=======
+ 	orig = nvdev->num_chn;
+ 	was_opened = rndis_filter_opened(nvdev);
+ 	if (was_opened)
+ 		rndis_filter_close(nvdev);
++>>>>>>> 7ca4593338e1 (netvsc: fix netvsc_set_channels)
 +
 + do_set:
 +	net_device_ctx->start_remove = true;
 +	rndis_filter_device_remove(dev);
  
 -	rndis_filter_device_remove(dev, nvdev);
++<<<<<<< HEAD
 +	nvdev->num_chn = channels->combined_count;
  
 +	memset(&device_info, 0, sizeof(device_info));
 +	device_info.num_chn = nvdev->num_chn; /* passed to RNDIS */
 +	device_info.ring_size = ring_size;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
++=======
+ 	memset(&device_info, 0, sizeof(device_info));
+ 	device_info.num_chn = count;
+ 	device_info.ring_size = ring_size;
+ 	device_info.max_num_vrss_chns = count;
+ 
+ 	nvdev = rndis_filter_device_add(dev, &device_info);
+ 	if (!IS_ERR(nvdev)) {
+ 		netif_set_real_num_tx_queues(net, nvdev->num_chn);
+ 		netif_set_real_num_rx_queues(net, nvdev->num_chn);
+ 		ret = PTR_ERR(nvdev);
+ 	} else {
+ 		device_info.num_chn = orig;
+ 		device_info.max_num_vrss_chns = count;
+ 		rndis_filter_device_add(dev, &device_info);
+ 	}
+ 
+ 	if (was_opened)
+ 		rndis_filter_open(nvdev);
++>>>>>>> 7ca4593338e1 (netvsc: fix netvsc_set_channels)
 +
 +	ret = rndis_filter_device_add(dev, &device_info);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 +	nvdev = net_device_ctx->nvdev;
  
 +	ret = netif_set_real_num_tx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set tx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 +	ret = netif_set_real_num_rx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set rx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
 +
 + out:
 +	netvsc_open(net);
 +	net_device_ctx->start_remove = false;
  	/* We may have missed link change notifications */
  	net_device_ctx->last_reconfig = 0;
  	schedule_delayed_work(&net_device_ctx->dwork, 0);
@@@ -893,42 -832,42 +929,48 @@@ static int netvsc_set_link_ksettings(st
  static int netvsc_change_mtu(struct net_device *ndev, int mtu)
  {
  	struct net_device_context *ndevctx = netdev_priv(ndev);
 -	struct netvsc_device *nvdev = rtnl_dereference(ndevctx->nvdev);
 +	struct netvsc_device *nvdev = ndevctx->nvdev;
  	struct hv_device *hdev = ndevctx->device_ctx;
 -	int orig_mtu = ndev->mtu;
  	struct netvsc_device_info device_info;
 -	bool was_opened;
 +	int limit = ETH_DATA_LEN;
 +	u32 num_chn;
  	int ret = 0;
  
 -	if (!nvdev || nvdev->destroy)
 +	if (ndevctx->start_remove || !nvdev || nvdev->destroy)
  		return -ENODEV;
  
 -	netif_device_detach(ndev);
 -	was_opened = rndis_filter_opened(nvdev);
 -	if (was_opened)
 -		rndis_filter_close(nvdev);
 +	if (nvdev->nvsp_version >= NVSP_PROTOCOL_VERSION_2)
 +		limit = NETVSC_MTU - ETH_HLEN;
  
++<<<<<<< HEAD
 +	if (mtu < NETVSC_MTU_MIN || mtu > limit)
 +		return -EINVAL;
++=======
+ 	memset(&device_info, 0, sizeof(device_info));
+ 	device_info.ring_size = ring_size;
+ 	device_info.num_chn = nvdev->num_chn;
++>>>>>>> 7ca4593338e1 (netvsc: fix netvsc_set_channels)
  
 -	rndis_filter_device_remove(hdev, nvdev);
 +	ret = netvsc_close(ndev);
 +	if (ret)
 +		goto out;
  
 -	ndev->mtu = mtu;
 +	num_chn = nvdev->num_chn;
  
 -	nvdev = rndis_filter_device_add(hdev, &device_info);
 -	if (IS_ERR(nvdev)) {
 -		ret = PTR_ERR(nvdev);
 +	ndevctx->start_remove = true;
 +	rndis_filter_device_remove(hdev);
  
 -		/* Attempt rollback to original MTU */
 -		ndev->mtu = orig_mtu;
 -		rndis_filter_device_add(hdev, &device_info);
 -	}
 +	ndev->mtu = mtu;
  
 -	if (was_opened)
 -		rndis_filter_open(nvdev);
 +	memset(&device_info, 0, sizeof(device_info));
 +	device_info.ring_size = ring_size;
 +	device_info.num_chn = num_chn;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
 +	rndis_filter_device_add(hdev, &device_info);
  
 -	netif_device_attach(ndev);
 +out:
 +	netvsc_open(ndev);
 +	ndevctx->start_remove = false;
  
  	/* We may have missed link change notifications */
  	schedule_delayed_work(&ndevctx->dwork, 0);
* Unmerged path drivers/net/hyperv/netvsc_drv.c
