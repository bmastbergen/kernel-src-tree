swiotlb: Add warnings for use of bounce buffers with SME

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 648babb7078c6310d2af5b8aa01f086030916968
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/648babb7.failed

Add warnings to let the user know when bounce buffers are being used for
DMA when SME is active.  Since the bounce buffers are not in encrypted
memory, these notifications are to allow the user to determine some
appropriate action - if necessary.  Actions can range from utilizing an
IOMMU, replacing the device with another device that can support 64-bit
DMA, ignoring the message if the device isn't used much, etc.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Larry Woodman <lwoodman@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Toshimitsu Kani <toshi.kani@hpe.com>
	Cc: kasan-dev@googlegroups.com
	Cc: kvm@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-efi@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/d112564053c3f2e86ca634a8d4fa4abc0eb53a6a.1500319216.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 648babb7078c6310d2af5b8aa01f086030916968)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/dma-mapping.h
diff --cc include/linux/dma-mapping.h
index fe4bb5f6dd29,fce2369ecf82..000000000000
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@@ -5,9 -5,70 +5,73 @@@
  #include <linux/string.h>
  #include <linux/device.h>
  #include <linux/err.h>
 -#include <linux/dma-debug.h>
 +#include <linux/dma-attrs.h>
  #include <linux/dma-direction.h>
  #include <linux/scatterlist.h>
++<<<<<<< HEAD
++=======
+ #include <linux/kmemcheck.h>
+ #include <linux/bug.h>
+ #include <linux/mem_encrypt.h>
+ 
+ /**
+  * List of possible attributes associated with a DMA mapping. The semantics
+  * of each attribute should be defined in Documentation/DMA-attributes.txt.
+  *
+  * DMA_ATTR_WRITE_BARRIER: DMA to a memory region with this attribute
+  * forces all pending DMA writes to complete.
+  */
+ #define DMA_ATTR_WRITE_BARRIER		(1UL << 0)
+ /*
+  * DMA_ATTR_WEAK_ORDERING: Specifies that reads and writes to the mapping
+  * may be weakly ordered, that is that reads and writes may pass each other.
+  */
+ #define DMA_ATTR_WEAK_ORDERING		(1UL << 1)
+ /*
+  * DMA_ATTR_WRITE_COMBINE: Specifies that writes to the mapping may be
+  * buffered to improve performance.
+  */
+ #define DMA_ATTR_WRITE_COMBINE		(1UL << 2)
+ /*
+  * DMA_ATTR_NON_CONSISTENT: Lets the platform to choose to return either
+  * consistent or non-consistent memory as it sees fit.
+  */
+ #define DMA_ATTR_NON_CONSISTENT		(1UL << 3)
+ /*
+  * DMA_ATTR_NO_KERNEL_MAPPING: Lets the platform to avoid creating a kernel
+  * virtual mapping for the allocated buffer.
+  */
+ #define DMA_ATTR_NO_KERNEL_MAPPING	(1UL << 4)
+ /*
+  * DMA_ATTR_SKIP_CPU_SYNC: Allows platform code to skip synchronization of
+  * the CPU cache for the given buffer assuming that it has been already
+  * transferred to 'device' domain.
+  */
+ #define DMA_ATTR_SKIP_CPU_SYNC		(1UL << 5)
+ /*
+  * DMA_ATTR_FORCE_CONTIGUOUS: Forces contiguous allocation of the buffer
+  * in physical memory.
+  */
+ #define DMA_ATTR_FORCE_CONTIGUOUS	(1UL << 6)
+ /*
+  * DMA_ATTR_ALLOC_SINGLE_PAGES: This is a hint to the DMA-mapping subsystem
+  * that it's probably not worth the time to try to allocate memory to in a way
+  * that gives better TLB efficiency.
+  */
+ #define DMA_ATTR_ALLOC_SINGLE_PAGES	(1UL << 7)
+ /*
+  * DMA_ATTR_NO_WARN: This tells the DMA-mapping subsystem to suppress
+  * allocation failure reports (similarly to __GFP_NOWARN).
+  */
+ #define DMA_ATTR_NO_WARN	(1UL << 8)
+ 
+ /*
+  * DMA_ATTR_PRIVILEGED: used to indicate that the buffer is fully
+  * accessible at an elevated privilege level (and ideally inaccessible or
+  * at least read-only at lesser-privileged levels).
+  */
+ #define DMA_ATTR_PRIVILEGED		(1UL << 9)
++>>>>>>> 648babb7078c (swiotlb: Add warnings for use of bounce buffers with SME)
  
  /*
   * A dma_addr_t can hold any valid DMA or bus address for the platform.
@@@ -85,10 -153,430 +149,405 @@@ static inline int is_device_dma_capable
  	return dev->dma_mask != NULL && *dev->dma_mask != DMA_MASK_NONE;
  }
  
 -#ifdef CONFIG_HAVE_GENERIC_DMA_COHERENT
 -/*
 - * These three functions are only for dma allocator.
 - * Don't use them in device drivers.
 - */
 -int dma_alloc_from_coherent(struct device *dev, ssize_t size,
 -				       dma_addr_t *dma_handle, void **ret);
 -int dma_release_from_coherent(struct device *dev, int order, void *vaddr);
 -
 -int dma_mmap_from_coherent(struct device *dev, struct vm_area_struct *vma,
 -			    void *cpu_addr, size_t size, int *ret);
 -#else
 -#define dma_alloc_from_coherent(dev, size, handle, ret) (0)
 -#define dma_release_from_coherent(dev, order, vaddr) (0)
 -#define dma_mmap_from_coherent(dev, vma, vaddr, order, ret) (0)
 -#endif /* CONFIG_HAVE_GENERIC_DMA_COHERENT */
 -
  #ifdef CONFIG_HAS_DMA
  #include <asm/dma-mapping.h>
 -static inline const struct dma_map_ops *get_dma_ops(struct device *dev)
 -{
 -	if (dev && dev->dma_ops)
 -		return dev->dma_ops;
 -	return get_arch_dma_ops(dev ? dev->bus : NULL);
 -}
 -
 -static inline void set_dma_ops(struct device *dev,
 -			       const struct dma_map_ops *dma_ops)
 -{
 -	dev->dma_ops = dma_ops;
 -}
  #else
++<<<<<<< HEAD
 +#include <asm-generic/dma-mapping-broken.h>
++=======
+ /*
+  * Define the dma api to allow compilation but not linking of
+  * dma dependent code.  Code that depends on the dma-mapping
+  * API needs to set 'depends on HAS_DMA' in its Kconfig
+  */
+ extern const struct dma_map_ops bad_dma_ops;
+ static inline const struct dma_map_ops *get_dma_ops(struct device *dev)
+ {
+ 	return &bad_dma_ops;
+ }
+ #endif
+ 
+ static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
+ 					      size_t size,
+ 					      enum dma_data_direction dir,
+ 					      unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	dma_addr_t addr;
+ 
+ 	kmemcheck_mark_initialized(ptr, size);
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	addr = ops->map_page(dev, virt_to_page(ptr),
+ 			     offset_in_page(ptr), size,
+ 			     dir, attrs);
+ 	debug_dma_map_page(dev, virt_to_page(ptr),
+ 			   offset_in_page(ptr), size,
+ 			   dir, addr, true);
+ 	return addr;
+ }
+ 
+ static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
+ 					  size_t size,
+ 					  enum dma_data_direction dir,
+ 					  unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->unmap_page)
+ 		ops->unmap_page(dev, addr, size, dir, attrs);
+ 	debug_dma_unmap_page(dev, addr, size, dir, true);
+ }
+ 
+ /*
+  * dma_maps_sg_attrs returns 0 on error and > 0 on success.
+  * It should never return a value < 0.
+  */
+ static inline int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,
+ 				   int nents, enum dma_data_direction dir,
+ 				   unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	int i, ents;
+ 	struct scatterlist *s;
+ 
+ 	for_each_sg(sg, s, nents, i)
+ 		kmemcheck_mark_initialized(sg_virt(s), s->length);
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	ents = ops->map_sg(dev, sg, nents, dir, attrs);
+ 	BUG_ON(ents < 0);
+ 	debug_dma_map_sg(dev, sg, nents, ents, dir);
+ 
+ 	return ents;
+ }
+ 
+ static inline void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,
+ 				      int nents, enum dma_data_direction dir,
+ 				      unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	debug_dma_unmap_sg(dev, sg, nents, dir);
+ 	if (ops->unmap_sg)
+ 		ops->unmap_sg(dev, sg, nents, dir, attrs);
+ }
+ 
+ static inline dma_addr_t dma_map_page_attrs(struct device *dev,
+ 					    struct page *page,
+ 					    size_t offset, size_t size,
+ 					    enum dma_data_direction dir,
+ 					    unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	dma_addr_t addr;
+ 
+ 	kmemcheck_mark_initialized(page_address(page) + offset, size);
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	addr = ops->map_page(dev, page, offset, size, dir, attrs);
+ 	debug_dma_map_page(dev, page, offset, size, dir, addr, false);
+ 
+ 	return addr;
+ }
+ 
+ static inline void dma_unmap_page_attrs(struct device *dev,
+ 					dma_addr_t addr, size_t size,
+ 					enum dma_data_direction dir,
+ 					unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->unmap_page)
+ 		ops->unmap_page(dev, addr, size, dir, attrs);
+ 	debug_dma_unmap_page(dev, addr, size, dir, false);
+ }
+ 
+ static inline dma_addr_t dma_map_resource(struct device *dev,
+ 					  phys_addr_t phys_addr,
+ 					  size_t size,
+ 					  enum dma_data_direction dir,
+ 					  unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	dma_addr_t addr;
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 
+ 	/* Don't allow RAM to be mapped */
+ 	BUG_ON(pfn_valid(PHYS_PFN(phys_addr)));
+ 
+ 	addr = phys_addr;
+ 	if (ops->map_resource)
+ 		addr = ops->map_resource(dev, phys_addr, size, dir, attrs);
+ 
+ 	debug_dma_map_resource(dev, phys_addr, size, dir, addr);
+ 
+ 	return addr;
+ }
+ 
+ static inline void dma_unmap_resource(struct device *dev, dma_addr_t addr,
+ 				      size_t size, enum dma_data_direction dir,
+ 				      unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->unmap_resource)
+ 		ops->unmap_resource(dev, addr, size, dir, attrs);
+ 	debug_dma_unmap_resource(dev, addr, size, dir);
+ }
+ 
+ static inline void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,
+ 					   size_t size,
+ 					   enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->sync_single_for_cpu)
+ 		ops->sync_single_for_cpu(dev, addr, size, dir);
+ 	debug_dma_sync_single_for_cpu(dev, addr, size, dir);
+ }
+ 
+ static inline void dma_sync_single_for_device(struct device *dev,
+ 					      dma_addr_t addr, size_t size,
+ 					      enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->sync_single_for_device)
+ 		ops->sync_single_for_device(dev, addr, size, dir);
+ 	debug_dma_sync_single_for_device(dev, addr, size, dir);
+ }
+ 
+ static inline void dma_sync_single_range_for_cpu(struct device *dev,
+ 						 dma_addr_t addr,
+ 						 unsigned long offset,
+ 						 size_t size,
+ 						 enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->sync_single_for_cpu)
+ 		ops->sync_single_for_cpu(dev, addr + offset, size, dir);
+ 	debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, dir);
+ }
+ 
+ static inline void dma_sync_single_range_for_device(struct device *dev,
+ 						    dma_addr_t addr,
+ 						    unsigned long offset,
+ 						    size_t size,
+ 						    enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->sync_single_for_device)
+ 		ops->sync_single_for_device(dev, addr + offset, size, dir);
+ 	debug_dma_sync_single_range_for_device(dev, addr, offset, size, dir);
+ }
+ 
+ static inline void
+ dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
+ 		    int nelems, enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->sync_sg_for_cpu)
+ 		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
+ 	debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
+ }
+ 
+ static inline void
+ dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
+ 		       int nelems, enum dma_data_direction dir)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!valid_dma_direction(dir));
+ 	if (ops->sync_sg_for_device)
+ 		ops->sync_sg_for_device(dev, sg, nelems, dir);
+ 	debug_dma_sync_sg_for_device(dev, sg, nelems, dir);
+ 
+ }
+ 
+ #define dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, 0)
+ #define dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, 0)
+ #define dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, 0)
+ #define dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, 0)
+ #define dma_map_page(d, p, o, s, r) dma_map_page_attrs(d, p, o, s, r, 0)
+ #define dma_unmap_page(d, a, s, r) dma_unmap_page_attrs(d, a, s, r, 0)
+ 
+ extern int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
+ 			   void *cpu_addr, dma_addr_t dma_addr, size_t size);
+ 
+ void *dma_common_contiguous_remap(struct page *page, size_t size,
+ 			unsigned long vm_flags,
+ 			pgprot_t prot, const void *caller);
+ 
+ void *dma_common_pages_remap(struct page **pages, size_t size,
+ 			unsigned long vm_flags, pgprot_t prot,
+ 			const void *caller);
+ void dma_common_free_remap(void *cpu_addr, size_t size, unsigned long vm_flags);
+ 
+ /**
+  * dma_mmap_attrs - map a coherent DMA allocation into user space
+  * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+  * @vma: vm_area_struct describing requested user mapping
+  * @cpu_addr: kernel CPU-view address returned from dma_alloc_attrs
+  * @handle: device-view address returned from dma_alloc_attrs
+  * @size: size of memory originally requested in dma_alloc_attrs
+  * @attrs: attributes of mapping properties requested in dma_alloc_attrs
+  *
+  * Map a coherent DMA buffer previously allocated by dma_alloc_attrs
+  * into user space.  The coherent DMA buffer must not be freed by the
+  * driver until the user space mapping has been released.
+  */
+ static inline int
+ dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma, void *cpu_addr,
+ 	       dma_addr_t dma_addr, size_t size, unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	BUG_ON(!ops);
+ 	if (ops->mmap)
+ 		return ops->mmap(dev, vma, cpu_addr, dma_addr, size, attrs);
+ 	return dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);
+ }
+ 
+ #define dma_mmap_coherent(d, v, c, h, s) dma_mmap_attrs(d, v, c, h, s, 0)
+ 
+ int
+ dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
+ 		       void *cpu_addr, dma_addr_t dma_addr, size_t size);
+ 
+ static inline int
+ dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt, void *cpu_addr,
+ 		      dma_addr_t dma_addr, size_t size,
+ 		      unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	BUG_ON(!ops);
+ 	if (ops->get_sgtable)
+ 		return ops->get_sgtable(dev, sgt, cpu_addr, dma_addr, size,
+ 					attrs);
+ 	return dma_common_get_sgtable(dev, sgt, cpu_addr, dma_addr, size);
+ }
+ 
+ #define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, 0)
+ 
+ #ifndef arch_dma_alloc_attrs
+ #define arch_dma_alloc_attrs(dev, flag)	(true)
+ #endif
+ 
+ static inline void *dma_alloc_attrs(struct device *dev, size_t size,
+ 				       dma_addr_t *dma_handle, gfp_t flag,
+ 				       unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 	void *cpu_addr;
+ 
+ 	BUG_ON(!ops);
+ 
+ 	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
+ 		return cpu_addr;
+ 
+ 	if (!arch_dma_alloc_attrs(&dev, &flag))
+ 		return NULL;
+ 	if (!ops->alloc)
+ 		return NULL;
+ 
+ 	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
+ 	debug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr);
+ 	return cpu_addr;
+ }
+ 
+ static inline void dma_free_attrs(struct device *dev, size_t size,
+ 				     void *cpu_addr, dma_addr_t dma_handle,
+ 				     unsigned long attrs)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!ops);
+ 	WARN_ON(irqs_disabled());
+ 
+ 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
+ 		return;
+ 
+ 	if (!ops->free || !cpu_addr)
+ 		return;
+ 
+ 	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
+ 	ops->free(dev, size, cpu_addr, dma_handle, attrs);
+ }
+ 
+ static inline void *dma_alloc_coherent(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, gfp_t flag)
+ {
+ 	return dma_alloc_attrs(dev, size, dma_handle, flag, 0);
+ }
+ 
+ static inline void dma_free_coherent(struct device *dev, size_t size,
+ 		void *cpu_addr, dma_addr_t dma_handle)
+ {
+ 	return dma_free_attrs(dev, size, cpu_addr, dma_handle, 0);
+ }
+ 
+ static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, gfp_t gfp)
+ {
+ 	return dma_alloc_attrs(dev, size, dma_handle, gfp,
+ 			       DMA_ATTR_NON_CONSISTENT);
+ }
+ 
+ static inline void dma_free_noncoherent(struct device *dev, size_t size,
+ 		void *cpu_addr, dma_addr_t dma_handle)
+ {
+ 	dma_free_attrs(dev, size, cpu_addr, dma_handle,
+ 		       DMA_ATTR_NON_CONSISTENT);
+ }
+ 
+ static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+ {
+ 	debug_dma_mapping_error(dev, dma_addr);
+ 
+ 	if (get_dma_ops(dev)->mapping_error)
+ 		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
+ 	return 0;
+ }
+ 
+ static inline void dma_check_mask(struct device *dev, u64 mask)
+ {
+ 	if (sme_active() && (mask < (((u64)sme_get_me_mask() << 1) - 1)))
+ 		dev_warn(dev, "SME is active, device will require DMA bounce buffers\n");
+ }
+ 
+ static inline int dma_supported(struct device *dev, u64 mask)
+ {
+ 	const struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	if (!ops)
+ 		return 0;
+ 	if (!ops->dma_supported)
+ 		return 1;
+ 	return ops->dma_supported(dev, mask);
+ }
+ 
+ #ifndef HAVE_ARCH_DMA_SET_MASK
+ static inline int dma_set_mask(struct device *dev, u64 mask)
+ {
+ 	if (!dev->dma_mask || !dma_supported(dev, mask))
+ 		return -EIO;
+ 
+ 	dma_check_mask(dev, mask);
+ 
+ 	*dev->dma_mask = mask;
+ 	return 0;
+ }
++>>>>>>> 648babb7078c (swiotlb: Add warnings for use of bounce buffers with SME)
  #endif
  
  static inline u64 dma_get_mask(struct device *dev)
* Unmerged path include/linux/dma-mapping.h
diff --git a/lib/swiotlb.c b/lib/swiotlb.c
index 542ff4e0a8d4..52b23a2fd4b8 100644
--- a/lib/swiotlb.c
+++ b/lib/swiotlb.c
@@ -427,6 +427,9 @@ phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,
 	if (no_iotlb_memory)
 		panic("Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer");
 
+	if (sme_active())
+		pr_warn_once("SME is active and system is using DMA bounce buffers\n");
+
 	mask = dma_get_seg_boundary(hwdev);
 
 	tbl_dma_addr &= mask;
