KVM, pkeys: save/restore PKRU when guest/host switches

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Xiao Guangrong <guangrong.xiao@linux.intel.com>
commit 1be0e61c1f255faaeab04a390e00c8b9b9042870
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1be0e61c.failed

Currently XSAVE state of host is not restored after VM-exit and PKRU
is managed by XSAVE so the PKRU from guest is still controlling the
memory access even if the CPU is running the code of host. This is
not safe as KVM needs to access the memory of userspace (e,g QEMU) to
do some emulation.

So we save/restore PKRU when guest/host switches.

	Signed-off-by: Huaitong Han <huaitong.han@intel.com>
	Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 1be0e61c1f255faaeab04a390e00c8b9b9042870)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index b425151c6b77,87664775b51e..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -609,13 -599,9 +609,19 @@@ struct vcpu_vmx 
  
  	u64 current_tsc_ratio;
  
++<<<<<<< HEAD
 +	/*
 +	 * Only bits masked by msr_ia32_feature_control_valid_bits can be set in
 +	 * msr_ia32_feature_control. FEATURE_CONTROL_LOCKED is always included
 +	 * in msr_ia32_feature_control_valid_bits.
 +	 */
 +	u64 msr_ia32_feature_control;
 +	u64 msr_ia32_feature_control_valid_bits;
++=======
+ 	bool guest_pkru_valid;
+ 	u32 guest_pkru;
+ 	u32 host_pkru;
++>>>>>>> 1be0e61c1f25 (KVM, pkeys: save/restore PKRU when guest/host switches)
  };
  
  enum segment_cache_field {
@@@ -2054,12 -2112,6 +2060,15 @@@ static void vmx_vcpu_pi_load(struct kvm
  			new.control) != old.control);
  }
  
++<<<<<<< HEAD
 +static void decache_tsc_multiplier(struct vcpu_vmx *vmx)
 +{
 +	vmx->current_tsc_ratio = vmx->vcpu.arch.tsc_scaling_ratio;
 +	vmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);
 +}
 +
++=======
++>>>>>>> 1be0e61c1f25 (KVM, pkeys: save/restore PKRU when guest/host switches)
  /*
   * Switches to specified vcpu, until a matching vcpu_put(), but assumes
   * vcpu mutex is already taken.
@@@ -2114,10 -2166,13 +2123,11 @@@ static void vmx_vcpu_load(struct kvm_vc
  
  	/* Setup TSC multiplier */
  	if (kvm_has_tsc_control &&
 -	    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio) {
 -		vmx->current_tsc_ratio = vcpu->arch.tsc_scaling_ratio;
 -		vmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);
 -	}
 +	    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)
 +		decache_tsc_multiplier(vmx);
  
  	vmx_vcpu_pi_load(vcpu, cpu);
+ 	vmx->host_pkru = read_pkru();
  }
  
  static void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/vmx.c
