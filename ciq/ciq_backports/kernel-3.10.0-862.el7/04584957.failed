geneve/vxlan: offload ports on register/unregister events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 04584957b5f9b036caa9603525e12d1840d42d58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/04584957.failed

This improves consistency of handling when moving a netdev to another
netns. Most drivers currently do a full reset when the device goes up,
so that will flush the offload state anyway.

	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04584957b5f9b036caa9603525e12d1840d42d58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
#	drivers/net/vxlan.c
diff --cc drivers/net/geneve.c
index c4c93ccffa85,745d57ae95d7..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -1520,9 -1566,14 +1520,20 @@@ static int geneve_netdevice_event(struc
  {
  	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
  
++<<<<<<< HEAD
 +	if (event == NETDEV_OFFLOAD_PUSH_GENEVE ||
 +	    event == NETDEV_UDP_TUNNEL_PUSH_INFO)
 +		geneve_push_rx_ports(dev);
++=======
+ 	if (event == NETDEV_UDP_TUNNEL_PUSH_INFO ||
+ 	    event == NETDEV_UDP_TUNNEL_DROP_INFO) {
+ 		geneve_offload_rx_ports(dev, event == NETDEV_UDP_TUNNEL_PUSH_INFO);
+ 	} else if (event == NETDEV_UNREGISTER) {
+ 		geneve_offload_rx_ports(dev, false);
+ 	} else if (event == NETDEV_REGISTER) {
+ 		geneve_offload_rx_ports(dev, true);
+ 	}
++>>>>>>> 04584957b5f9 (geneve/vxlan: offload ports on register/unregister events)
  
  	return NOTIFY_DONE;
  }
diff --cc drivers/net/vxlan.c
index 740e6d79f5f2,dbca067540d0..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -3261,11 -3638,15 +3261,21 @@@ static int vxlan_netdevice_event(struc
  	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
  	struct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);
  
- 	if (event == NETDEV_UNREGISTER)
+ 	if (event == NETDEV_UNREGISTER) {
+ 		vxlan_offload_rx_ports(dev, false);
  		vxlan_handle_lowerdev_unregister(vn, dev);
++<<<<<<< HEAD
 +	else if (event == NETDEV_OFFLOAD_PUSH_VXLAN ||
 +		 event == NETDEV_UDP_TUNNEL_PUSH_INFO)
 +		vxlan_push_rx_ports(dev);
++=======
+ 	} else if (event == NETDEV_REGISTER) {
+ 		vxlan_offload_rx_ports(dev, true);
+ 	} else if (event == NETDEV_UDP_TUNNEL_PUSH_INFO ||
+ 		   event == NETDEV_UDP_TUNNEL_DROP_INFO) {
+ 		vxlan_offload_rx_ports(dev, event == NETDEV_UDP_TUNNEL_PUSH_INFO);
+ 	}
++>>>>>>> 04584957b5f9 (geneve/vxlan: offload ports on register/unregister events)
  
  	return NOTIFY_DONE;
  }
* Unmerged path drivers/net/geneve.c
* Unmerged path drivers/net/vxlan.c
