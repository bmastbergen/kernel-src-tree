bnxt_en: export a common switchdev PARENT_ID for all reps of an adapter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sathya Perla <sathya.perla@broadcom.com>
commit dd4ea1da12495e1b3c400a28df11528892199f68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dd4ea1da.failed

Currently the driver exports different switchdev PARENT_IDs for
representors belonging to different SR-IOV PF-pools of an adapter.
This is not correct as the adapter can switch across all vports
of an adapter. This patch fixes this by exporting a common switchdev
PARENT_ID for all reps of an adapter. The PCIE DSN is used as the id.

	Signed-off-by: Sathya Perla <sathya.perla@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dd4ea1da12495e1b3c400a28df11528892199f68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index c325a10cc99e,6b7e99675571..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -7189,11 -8073,102 +7189,106 @@@ static void bnxt_udp_tunnel_del(struct 
  		return;
  	}
  
 -	bnxt_queue_sp_work(bp);
 +	schedule_work(&bp->sp_task);
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+ 			       struct net_device *dev, u32 filter_mask,
+ 			       int nlflags)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 
+ 	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, bp->br_mode, 0, 0,
+ 				       nlflags, filter_mask, NULL);
+ }
+ 
+ static int bnxt_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
+ 			       u16 flags)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	struct nlattr *attr, *br_spec;
+ 	int rem, rc = 0;
+ 
+ 	if (bp->hwrm_spec_code < 0x10708 || !BNXT_SINGLE_PF(bp))
+ 		return -EOPNOTSUPP;
+ 
+ 	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
+ 	if (!br_spec)
+ 		return -EINVAL;
+ 
+ 	nla_for_each_nested(attr, br_spec, rem) {
+ 		u16 mode;
+ 
+ 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
+ 			continue;
+ 
+ 		if (nla_len(attr) < sizeof(mode))
+ 			return -EINVAL;
+ 
+ 		mode = nla_get_u16(attr);
+ 		if (mode == bp->br_mode)
+ 			break;
+ 
+ 		rc = bnxt_hwrm_set_br_mode(bp, mode);
+ 		if (!rc)
+ 			bp->br_mode = mode;
+ 		break;
+ 	}
+ 	return rc;
+ }
+ 
+ static int bnxt_get_phys_port_name(struct net_device *dev, char *buf,
+ 				   size_t len)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	int rc;
+ 
+ 	/* The PF and it's VF-reps only support the switchdev framework */
+ 	if (!BNXT_PF(bp))
+ 		return -EOPNOTSUPP;
+ 
+ 	rc = snprintf(buf, len, "p%d", bp->pf.port_id);
+ 
+ 	if (rc >= len)
+ 		return -EOPNOTSUPP;
+ 	return 0;
+ }
+ 
+ int bnxt_port_attr_get(struct bnxt *bp, struct switchdev_attr *attr)
+ {
+ 	if (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* The PF and it's VF-reps only support the switchdev framework */
+ 	if (!BNXT_PF(bp))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (attr->id) {
+ 	case SWITCHDEV_ATTR_ID_PORT_PARENT_ID:
+ 		attr->u.ppid.id_len = sizeof(bp->switch_id);
+ 		memcpy(attr->u.ppid.id, bp->switch_id, attr->u.ppid.id_len);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_swdev_port_attr_get(struct net_device *dev,
+ 				    struct switchdev_attr *attr)
+ {
+ 	return bnxt_port_attr_get(netdev_priv(dev), attr);
+ }
+ 
+ static const struct switchdev_ops bnxt_switchdev_ops = {
+ 	.switchdev_port_attr_get	= bnxt_swdev_port_attr_get
+ };
+ 
++>>>>>>> dd4ea1da1249 (bnxt_en: export a common switchdev PARENT_ID for all reps of an adapter)
  static const struct net_device_ops bnxt_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= bnxt_open,
  	.ndo_start_xmit		= bnxt_start_xmit,
  	.ndo_stop		= bnxt_close,
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index db9012ea3731,1989c470172c..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1201,6 -1363,16 +1201,19 @@@ struct bnxt 
  
  	u8			num_leds;
  	struct bnxt_led_info	leds[BNXT_MAX_LED];
++<<<<<<< HEAD
++=======
+ 
+ 	struct bpf_prog		*xdp_prog;
+ 
+ 	/* devlink interface and vf-rep structs */
+ 	struct devlink		*dl;
+ 	enum devlink_eswitch_mode eswitch_mode;
+ 	struct bnxt_vf_rep	**vf_reps; /* array of vf-rep ptrs */
+ 	u16			*cfa_code_map; /* cfa_code -> vf_idx map */
+ 	u8			switch_id[8];
+ 	struct bnxt_tc_info	*tc_info;
++>>>>>>> dd4ea1da1249 (bnxt_en: export a common switchdev PARENT_ID for all reps of an adapter)
  };
  
  #define BNXT_RX_STATS_OFFSET(counter)			\
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_vfr.h
