media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic

jira LE-1907
cve CVE-2017-13166
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [media] v4l2-compat-ioctl32.c: refactor compat ioctl32 logic fixup (Jarod Wilson) [1548430] {CVE-2017-13166}
Rebuild_FUZZ: 88.89%
commit-author Daniel Mentz <danielmentz@google.com>
commit a1dfb4c48cc1e64eeb7800a27c66a6f7e88d075a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a1dfb4c4.failed

The 32-bit compat v4l2 ioctl handling is implemented based on its 64-bit
equivalent. It converts 32-bit data structures into its 64-bit
equivalents and needs to provide the data to the 64-bit ioctl in user
space memory which is commonly allocated using
compat_alloc_user_space().

However, due to how that function is implemented, it can only be called
a single time for every syscall invocation.

Supposedly to avoid this limitation, the existing code uses a mix of
memory from the kernel stack and memory allocated through
compat_alloc_user_space().

Under normal circumstances, this would not work, because the 64-bit
ioctl expects all pointers to point to user space memory. As a
workaround, set_fs(KERNEL_DS) is called to temporarily disable this
extra safety check and allow kernel pointers. However, this might
introduce a security vulnerability: The result of the 32-bit to 64-bit
conversion is writeable by user space because the output buffer has been
allocated via compat_alloc_user_space(). A malicious user space process
could then manipulate pointers inside this output buffer, and due to the
previous set_fs(KERNEL_DS) call, functions like get_user() or put_user()
no longer prevent kernel memory access.

The new approach is to pre-calculate the total amount of user space
memory that is needed, allocate it using compat_alloc_user_space() and
then divide up the allocated memory to accommodate all data structures
that need to be converted.

An alternative approach would have been to retain the union type karg
that they allocated on the kernel stack in do_video_ioctl(), copy all
data from user space into karg and then back to user space. However, we
decided against this approach because it does not align with other
compat syscall implementations. Instead, we tried to replicate the
get_user/put_user pairs as found in other places in the kernel:

    if (get_user(clipcount, &up->clipcount) ||
        put_user(clipcount, &kp->clipcount)) return -EFAULT;

Notes from hans.verkuil@cisco.com:

This patch was taken from:
    https://github.com/LineageOS/android_kernel_samsung_apq8084/commit/97b733953c06e4f0398ade18850f0817778255f7

Clearly nobody could be bothered to upstream this patch or at minimum
tell us :-( We only heard about this a week ago.

This patch was rebased and cleaned up. Compared to the original I
also swapped the order of the convert_in_user arguments so that they
matched copy_in_user. It was hard to review otherwise. I also replaced
the ALLOC_USER_SPACE/ALLOC_AND_GET by a normal function.

Fixes: 6b5a9492ca ("v4l: introduce string control support.")

	Signed-off-by: Daniel Mentz <danielmentz@google.com>
Co-developed-by: Hans Verkuil <hans.verkuil@cisco.com>
	Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
	Cc: <stable@vger.kernel.org>      # for v4.15 and up
	Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
(cherry picked from commit a1dfb4c48cc1e64eeb7800a27c66a6f7e88d075a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/v4l2-core/v4l2-compat-ioctl32.c
diff --cc drivers/media/v4l2-core/v4l2-compat-ioctl32.c
index f1295519f285,bdb5c226d01c..000000000000
--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
@@@ -18,8 -18,18 +18,16 @@@
  #include <linux/videodev2.h>
  #include <linux/v4l2-subdev.h>
  #include <media/v4l2-dev.h>
 -#include <media/v4l2-fh.h>
 -#include <media/v4l2-ctrls.h>
  #include <media/v4l2-ioctl.h>
  
+ /* Use the same argument order as copy_in_user */
+ #define assign_in_user(to, from)					\
+ ({									\
+ 	typeof(*from) __assign_tmp;					\
+ 									\
+ 	get_user(__assign_tmp, from) || put_user(__assign_tmp, to);	\
+ })
+ 
  static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
  {
  	long ret = -ENOIOCTLCMD;
@@@ -43,107 -53,78 +51,171 @@@ struct v4l2_window32 
  	compat_caddr_t		clips; /* actually struct v4l2_clip32 * */
  	__u32			clipcount;
  	compat_caddr_t		bitmap;
 -	__u8                    global_alpha;
  };
  
- static int get_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)
+ static int get_v4l2_window32(struct v4l2_window __user *kp,
+ 			     struct v4l2_window32 __user *up,
+ 			     void __user *aux_buf, u32 aux_space)
  {
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_window32)) ||
 +		copy_from_user(&kp->w, &up->w, sizeof(up->w)) ||
 +		get_user(kp->field, &up->field) ||
 +		get_user(kp->chromakey, &up->chromakey) ||
 +		get_user(kp->clipcount, &up->clipcount))
 +			return -EFAULT;
 +	if (kp->clipcount > 2048)
 +		return -EINVAL;
 +	if (kp->clipcount) {
 +		struct v4l2_clip32 __user *uclips;
 +		struct v4l2_clip __user *kclips;
 +		int n = kp->clipcount;
 +		compat_caddr_t p;
 +
 +		if (get_user(p, &up->clips))
 +			return -EFAULT;
 +		uclips = compat_ptr(p);
 +		kclips = compat_alloc_user_space(n * sizeof(struct v4l2_clip));
 +		kp->clips = kclips;
 +		while (--n >= 0) {
 +			if (copy_in_user(&kclips->c, &uclips->c, sizeof(uclips->c)))
 +				return -EFAULT;
 +			if (put_user(n ? kclips + 1 : NULL, &kclips->next))
 +				return -EFAULT;
 +			uclips += 1;
 +			kclips += 1;
 +		}
 +	} else
 +		kp->clips = NULL;
++=======
+ 	struct v4l2_clip32 __user *uclips;
+ 	struct v4l2_clip __user *kclips;
+ 	compat_caddr_t p;
+ 	u32 clipcount;
+ 
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    copy_in_user(&kp->w, &up->w, sizeof(up->w)) ||
+ 	    assign_in_user(&kp->field, &up->field) ||
+ 	    assign_in_user(&kp->chromakey, &up->chromakey) ||
+ 	    assign_in_user(&kp->global_alpha, &up->global_alpha) ||
+ 	    get_user(clipcount, &up->clipcount) ||
+ 	    put_user(clipcount, &kp->clipcount))
+ 		return -EFAULT;
+ 	if (clipcount > 2048)
+ 		return -EINVAL;
+ 	if (!clipcount)
+ 		return put_user(NULL, &kp->clips);
+ 
+ 	if (get_user(p, &up->clips))
+ 		return -EFAULT;
+ 	uclips = compat_ptr(p);
+ 	if (aux_space < clipcount * sizeof(*kclips))
+ 		return -EFAULT;
+ 	kclips = aux_buf;
+ 	if (put_user(kclips, &kp->clips))
+ 		return -EFAULT;
+ 
+ 	while (clipcount--) {
+ 		if (copy_in_user(&kclips->c, &uclips->c, sizeof(uclips->c)))
+ 			return -EFAULT;
+ 		if (put_user(clipcount ? kclips + 1 : NULL, &kclips->next))
+ 			return -EFAULT;
+ 		uclips++;
+ 		kclips++;
+ 	}
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return 0;
  }
  
- static int put_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)
+ static int put_v4l2_window32(struct v4l2_window __user *kp,
+ 			     struct v4l2_window32 __user *up)
  {
++<<<<<<< HEAD
 +	if (copy_to_user(&up->w, &kp->w, sizeof(kp->w)) ||
 +		put_user(kp->field, &up->field) ||
 +		put_user(kp->chromakey, &up->chromakey) ||
 +		put_user(kp->clipcount, &up->clipcount))
++=======
+ 	struct v4l2_clip __user *kclips = kp->clips;
+ 	struct v4l2_clip32 __user *uclips;
+ 	compat_caddr_t p;
+ 	u32 clipcount;
+ 
+ 	if (copy_in_user(&up->w, &kp->w, sizeof(kp->w)) ||
+ 	    assign_in_user(&up->field, &kp->field) ||
+ 	    assign_in_user(&up->chromakey, &kp->chromakey) ||
+ 	    assign_in_user(&up->global_alpha, &kp->global_alpha) ||
+ 	    get_user(clipcount, &kp->clipcount) ||
+ 	    put_user(clipcount, &up->clipcount))
+ 		return -EFAULT;
+ 	if (!clipcount)
+ 		return 0;
+ 
+ 	if (get_user(p, &up->clips))
+ 		return -EFAULT;
+ 	uclips = compat_ptr(p);
+ 	while (clipcount--) {
+ 		if (copy_in_user(&uclips->c, &kclips->c, sizeof(uclips->c)))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			return -EFAULT;
 -		uclips++;
 -		kclips++;
 -	}
 +	return 0;
 +}
 +
 +static inline int get_v4l2_pix_format(struct v4l2_pix_format *kp, struct v4l2_pix_format __user *up)
 +{
 +	if (copy_from_user(kp, up, sizeof(struct v4l2_pix_format)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int get_v4l2_pix_format_mplane(struct v4l2_pix_format_mplane *kp,
 +				struct v4l2_pix_format_mplane __user *up)
 +{
 +	if (copy_from_user(kp, up, sizeof(struct v4l2_pix_format_mplane)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int put_v4l2_pix_format(struct v4l2_pix_format *kp, struct v4l2_pix_format __user *up)
 +{
 +	if (copy_to_user(up, kp, sizeof(struct v4l2_pix_format)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int put_v4l2_pix_format_mplane(struct v4l2_pix_format_mplane *kp,
 +				struct v4l2_pix_format_mplane __user *up)
 +{
 +	if (copy_to_user(up, kp, sizeof(struct v4l2_pix_format_mplane)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int get_v4l2_vbi_format(struct v4l2_vbi_format *kp, struct v4l2_vbi_format __user *up)
 +{
 +	if (copy_from_user(kp, up, sizeof(struct v4l2_vbi_format)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int put_v4l2_vbi_format(struct v4l2_vbi_format *kp, struct v4l2_vbi_format __user *up)
 +{
 +	if (copy_to_user(up, kp, sizeof(struct v4l2_vbi_format)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int get_v4l2_sliced_vbi_format(struct v4l2_sliced_vbi_format *kp, struct v4l2_sliced_vbi_format __user *up)
 +{
 +	if (copy_from_user(kp, up, sizeof(struct v4l2_sliced_vbi_format)))
 +		return -EFAULT;
 +	return 0;
 +}
 +
 +static inline int put_v4l2_sliced_vbi_format(struct v4l2_sliced_vbi_format *kp, struct v4l2_sliced_vbi_format __user *up)
 +{
 +	if (copy_to_user(up, kp, sizeof(struct v4l2_sliced_vbi_format)))
 +		return -EFAULT;
  	return 0;
  }
  
@@@ -176,87 -159,165 +248,231 @@@ struct v4l2_create_buffers32 
  	__u32			reserved[8];
  };
  
- static int __get_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
+ static int __bufsize_v4l2_format(struct v4l2_format32 __user *up, u32 *size)
  {
++<<<<<<< HEAD
 +	switch (kp->type) {
 +	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 +	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 +		return get_v4l2_pix_format(&kp->fmt.pix, &up->fmt.pix);
 +	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
 +	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
 +		return get_v4l2_pix_format_mplane(&kp->fmt.pix_mp,
 +						  &up->fmt.pix_mp);
 +	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 +	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
 +		return get_v4l2_window32(&kp->fmt.win, &up->fmt.win);
 +	case V4L2_BUF_TYPE_VBI_CAPTURE:
 +	case V4L2_BUF_TYPE_VBI_OUTPUT:
 +		return get_v4l2_vbi_format(&kp->fmt.vbi, &up->fmt.vbi);
 +	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
 +	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
 +		return get_v4l2_sliced_vbi_format(&kp->fmt.sliced, &up->fmt.sliced);
 +	default:
 +		printk(KERN_INFO "compat_ioctl32: unexpected VIDIOC_FMT type %d\n",
 +								kp->type);
 +		return -EINVAL;
++=======
+ 	u32 type;
+ 
+ 	if (get_user(type, &up->type))
+ 		return -EFAULT;
+ 
+ 	switch (type) {
+ 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+ 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY: {
+ 		u32 clipcount;
+ 
+ 		if (get_user(clipcount, &up->fmt.win.clipcount))
+ 			return -EFAULT;
+ 		if (clipcount > 2048)
+ 			return -EINVAL;
+ 		*size = clipcount * sizeof(struct v4l2_clip);
+ 		return 0;
+ 	}
+ 	default:
+ 		*size = 0;
+ 		return 0;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	}
  }
  
- static int get_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
+ static int bufsize_v4l2_format(struct v4l2_format32 __user *up, u32 *size)
  {
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_format32)) ||
 +			get_user(kp->type, &up->type))
 +			return -EFAULT;
 +	return __get_v4l2_format32(kp, up);
++=======
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)))
+ 		return -EFAULT;
+ 	return __bufsize_v4l2_format(up, size);
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  }
  
- static int get_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)
+ static int __get_v4l2_format32(struct v4l2_format __user *kp,
+ 			       struct v4l2_format32 __user *up,
+ 			       void __user *aux_buf, u32 aux_space)
  {
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_create_buffers32)) ||
 +	    copy_from_user(kp, up, offsetof(struct v4l2_create_buffers32, format.fmt)))
 +			return -EFAULT;
 +	return __get_v4l2_format32(&kp->format, &up->format);
 +}
 +
 +static int __put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
 +{
 +	switch (kp->type) {
 +	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 +	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 +		return put_v4l2_pix_format(&kp->fmt.pix, &up->fmt.pix);
 +	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
 +	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
 +		return put_v4l2_pix_format_mplane(&kp->fmt.pix_mp,
 +						  &up->fmt.pix_mp);
++=======
+ 	u32 type;
+ 
+ 	if (get_user(type, &up->type) || put_user(type, &kp->type))
+ 		return -EFAULT;
+ 
+ 	switch (type) {
+ 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+ 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+ 		return copy_in_user(&kp->fmt.pix, &up->fmt.pix,
+ 				    sizeof(kp->fmt.pix)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+ 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+ 		return copy_in_user(&kp->fmt.pix_mp, &up->fmt.pix_mp,
+ 				    sizeof(kp->fmt.pix_mp)) ? -EFAULT : 0;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
  	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
- 		return put_v4l2_window32(&kp->fmt.win, &up->fmt.win);
+ 		return get_v4l2_window32(&kp->fmt.win, &up->fmt.win,
+ 					 aux_buf, aux_space);
  	case V4L2_BUF_TYPE_VBI_CAPTURE:
  	case V4L2_BUF_TYPE_VBI_OUTPUT:
++<<<<<<< HEAD
 +		return put_v4l2_vbi_format(&kp->fmt.vbi, &up->fmt.vbi);
 +	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
 +	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
 +		return put_v4l2_sliced_vbi_format(&kp->fmt.sliced, &up->fmt.sliced);
++=======
+ 		return copy_in_user(&kp->fmt.vbi, &up->fmt.vbi,
+ 				    sizeof(kp->fmt.vbi)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+ 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+ 		return copy_in_user(&kp->fmt.sliced, &up->fmt.sliced,
+ 				    sizeof(kp->fmt.sliced)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_SDR_CAPTURE:
+ 	case V4L2_BUF_TYPE_SDR_OUTPUT:
+ 		return copy_in_user(&kp->fmt.sdr, &up->fmt.sdr,
+ 				    sizeof(kp->fmt.sdr)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_META_CAPTURE:
+ 		return copy_in_user(&kp->fmt.meta, &up->fmt.meta,
+ 				    sizeof(kp->fmt.meta)) ? -EFAULT : 0;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	default:
 +		printk(KERN_INFO "compat_ioctl32: unexpected VIDIOC_FMT type %d\n",
 +								kp->type);
  		return -EINVAL;
  	}
  }
  
- static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
+ static int get_v4l2_format32(struct v4l2_format __user *kp,
+ 			     struct v4l2_format32 __user *up,
+ 			     void __user *aux_buf, u32 aux_space)
+ {
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)))
+ 		return -EFAULT;
+ 	return __get_v4l2_format32(kp, up, aux_buf, aux_space);
+ }
+ 
+ static int bufsize_v4l2_create(struct v4l2_create_buffers32 __user *up,
+ 			       u32 *size)
+ {
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)))
+ 		return -EFAULT;
+ 	return __bufsize_v4l2_format(&up->format, size);
+ }
+ 
+ static int get_v4l2_create32(struct v4l2_create_buffers __user *kp,
+ 			     struct v4l2_create_buffers32 __user *up,
+ 			     void __user *aux_buf, u32 aux_space)
+ {
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    copy_in_user(kp, up,
+ 			 offsetof(struct v4l2_create_buffers32, format)))
+ 		return -EFAULT;
+ 	return __get_v4l2_format32(&kp->format, &up->format,
+ 				   aux_buf, aux_space);
+ }
+ 
+ static int __put_v4l2_format32(struct v4l2_format __user *kp,
+ 			       struct v4l2_format32 __user *up)
+ {
+ 	u32 type;
+ 
+ 	if (get_user(type, &kp->type))
+ 		return -EFAULT;
+ 
+ 	switch (type) {
+ 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+ 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+ 		return copy_in_user(&up->fmt.pix, &kp->fmt.pix,
+ 				    sizeof(kp->fmt.pix)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+ 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+ 		return copy_in_user(&up->fmt.pix_mp, &kp->fmt.pix_mp,
+ 				    sizeof(kp->fmt.pix_mp)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+ 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
+ 		return put_v4l2_window32(&kp->fmt.win, &up->fmt.win);
+ 	case V4L2_BUF_TYPE_VBI_CAPTURE:
+ 	case V4L2_BUF_TYPE_VBI_OUTPUT:
+ 		return copy_in_user(&up->fmt.vbi, &kp->fmt.vbi,
+ 				    sizeof(kp->fmt.vbi)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+ 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+ 		return copy_in_user(&up->fmt.sliced, &kp->fmt.sliced,
+ 				    sizeof(kp->fmt.sliced)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_SDR_CAPTURE:
+ 	case V4L2_BUF_TYPE_SDR_OUTPUT:
+ 		return copy_in_user(&up->fmt.sdr, &kp->fmt.sdr,
+ 				    sizeof(kp->fmt.sdr)) ? -EFAULT : 0;
+ 	case V4L2_BUF_TYPE_META_CAPTURE:
+ 		return copy_in_user(&up->fmt.meta, &kp->fmt.meta,
+ 				    sizeof(kp->fmt.meta)) ? -EFAULT : 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int put_v4l2_format32(struct v4l2_format __user *kp,
+ 			     struct v4l2_format32 __user *up)
  {
 -	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_format32)) ||
 +		put_user(kp->type, &up->type))
  		return -EFAULT;
  	return __put_v4l2_format32(kp, up);
  }
  
- static int put_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)
+ static int put_v4l2_create32(struct v4l2_create_buffers __user *kp,
+ 			     struct v4l2_create_buffers32 __user *up)
  {
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_create_buffers32)) ||
 +	    copy_to_user(up, kp, offsetof(struct v4l2_create_buffers32, format.fmt)))
 +			return -EFAULT;
++=======
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    copy_in_user(up, kp,
+ 			 offsetof(struct v4l2_create_buffers32, format)) ||
+ 	    copy_in_user(up->reserved, kp->reserved, sizeof(kp->reserved)))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return __put_v4l2_format32(&kp->format, &up->format);
  }
  
@@@ -269,25 -330,28 +485,44 @@@ struct v4l2_standard32 
  	__u32		     reserved[4];
  };
  
- static int get_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32 __user *up)
+ static int get_v4l2_standard32(struct v4l2_standard __user *kp,
+ 			       struct v4l2_standard32 __user *up)
  {
  	/* other fields are not set by the user, nor used by the driver */
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_standard32)) ||
 +		get_user(kp->index, &up->index))
++=======
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    assign_in_user(&kp->index, &up->index))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		return -EFAULT;
  	return 0;
  }
  
- static int put_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32 __user *up)
+ static int put_v4l2_standard32(struct v4l2_standard __user *kp,
+ 			       struct v4l2_standard32 __user *up)
  {
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_standard32)) ||
 +		put_user(kp->index, &up->index) ||
 +		copy_to_user(up->id, &kp->id, sizeof(__u64)) ||
 +		copy_to_user(up->name, kp->name, 24) ||
 +		copy_to_user(&up->frameperiod, &kp->frameperiod, sizeof(kp->frameperiod)) ||
 +		put_user(kp->framelines, &up->framelines) ||
 +		copy_to_user(up->reserved, kp->reserved, 4 * sizeof(__u32)))
 +			return -EFAULT;
++=======
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    assign_in_user(&up->index, &kp->index) ||
+ 	    assign_in_user(&up->id, &kp->id) ||
+ 	    copy_in_user(up->name, kp->name, sizeof(up->name)) ||
+ 	    copy_in_user(&up->frameperiod, &kp->frameperiod,
+ 			 sizeof(up->frameperiod)) ||
+ 	    assign_in_user(&up->framelines, &kp->framelines) ||
+ 	    copy_in_user(up->reserved, kp->reserved, sizeof(up->reserved)))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return 0;
  }
  
@@@ -326,54 -390,67 +561,90 @@@ struct v4l2_buffer32 
  	__u32			reserved;
  };
  
++<<<<<<< HEAD
 +static int get_v4l2_plane32(struct v4l2_plane *up, struct v4l2_plane32 *up32,
 +				enum v4l2_memory memory)
++=======
+ static int get_v4l2_plane32(struct v4l2_plane __user *up,
+ 			    struct v4l2_plane32 __user *up32,
+ 			    enum v4l2_memory memory)
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  {
- 	void __user *up_pln;
- 	compat_long_t p;
+ 	compat_ulong_t p;
  
  	if (copy_in_user(up, up32, 2 * sizeof(__u32)) ||
 -	    copy_in_user(&up->data_offset, &up32->data_offset,
 -			 sizeof(up->data_offset)))
 +		copy_in_user(&up->data_offset, &up32->data_offset,
 +				sizeof(__u32)))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	if (memory == V4L2_MEMORY_USERPTR) {
 +		if (get_user(p, &up32->m.userptr))
 +			return -EFAULT;
 +		up_pln = compat_ptr(p);
 +		if (put_user((unsigned long)up_pln, &up->m.userptr))
++=======
+ 	switch (memory) {
+ 	case V4L2_MEMORY_MMAP:
+ 	case V4L2_MEMORY_OVERLAY:
+ 		if (copy_in_user(&up->m.mem_offset, &up32->m.mem_offset,
+ 				 sizeof(up32->m.mem_offset)))
+ 			return -EFAULT;
+ 		break;
+ 	case V4L2_MEMORY_USERPTR:
+ 		if (get_user(p, &up32->m.userptr) ||
+ 		    put_user((unsigned long)compat_ptr(p), &up->m.userptr))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			return -EFAULT;
 -		break;
 -	case V4L2_MEMORY_DMABUF:
 -		if (copy_in_user(&up->m.fd, &up32->m.fd, sizeof(up32->m.fd)))
 +	} else if (memory == V4L2_MEMORY_DMABUF) {
 +		if (copy_in_user(&up->m.fd, &up32->m.fd, sizeof(int)))
 +			return -EFAULT;
 +	} else {
 +		if (copy_in_user(&up->m.mem_offset, &up32->m.mem_offset,
 +					sizeof(__u32)))
  			return -EFAULT;
 -		break;
  	}
  
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int put_v4l2_plane32(struct v4l2_plane *up, struct v4l2_plane32 *up32,
 +				enum v4l2_memory memory)
++=======
+ static int put_v4l2_plane32(struct v4l2_plane __user *up,
+ 			    struct v4l2_plane32 __user *up32,
+ 			    enum v4l2_memory memory)
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  {
 -	unsigned long p;
 -
  	if (copy_in_user(up32, up, 2 * sizeof(__u32)) ||
 -	    copy_in_user(&up32->data_offset, &up->data_offset,
 -			 sizeof(up->data_offset)))
 +		copy_in_user(&up32->data_offset, &up->data_offset,
 +				sizeof(__u32)))
  		return -EFAULT;
  
 -	switch (memory) {
 -	case V4L2_MEMORY_MMAP:
 -	case V4L2_MEMORY_OVERLAY:
 +	/* For MMAP, driver might've set up the offset, so copy it back.
 +	 * USERPTR stays the same (was userspace-provided), so no copying. */
 +	if (memory == V4L2_MEMORY_MMAP)
  		if (copy_in_user(&up32->m.mem_offset, &up->m.mem_offset,
 -				 sizeof(up->m.mem_offset)))
 +					sizeof(__u32)))
  			return -EFAULT;
++<<<<<<< HEAD
 +	/* For DMABUF, driver might've set up the fd, so copy it back. */
 +	if (memory == V4L2_MEMORY_DMABUF)
 +		if (copy_in_user(&up32->m.fd, &up->m.fd,
 +					sizeof(int)))
++=======
+ 		break;
+ 	case V4L2_MEMORY_USERPTR:
+ 		if (get_user(p, &up->m.userptr) ||
+ 		    put_user((compat_ulong_t)ptr_to_compat((__force void *)p),
+ 			     &up32->m.userptr))
+ 			return -EFAULT;
+ 		break;
+ 	case V4L2_MEMORY_DMABUF:
+ 		if (copy_in_user(&up32->m.fd, &up->m.fd, sizeof(up->m.fd)))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			return -EFAULT;
 -		break;
 -	}
  
  	return 0;
  }
@@@ -383,81 -490,86 +684,151 @@@ static int get_v4l2_buffer32(struct v4l
  	struct v4l2_plane32 __user *uplane32;
  	struct v4l2_plane __user *uplane;
  	compat_caddr_t p;
 +	int num_planes;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_buffer32)) ||
 +		get_user(kp->index, &up->index) ||
 +		get_user(kp->type, &up->type) ||
 +		get_user(kp->flags, &up->flags) ||
 +		get_user(kp->memory, &up->memory))
 +			return -EFAULT;
 +
 +	if (V4L2_TYPE_IS_OUTPUT(kp->type))
 +		if (get_user(kp->bytesused, &up->bytesused) ||
 +			get_user(kp->field, &up->field) ||
 +			get_user(kp->timestamp.tv_sec, &up->timestamp.tv_sec) ||
 +			get_user(kp->timestamp.tv_usec,
 +					&up->timestamp.tv_usec))
 +			return -EFAULT;
 +
 +	if (V4L2_TYPE_IS_MULTIPLANAR(kp->type)) {
 +		if (get_user(kp->length, &up->length))
 +			return -EFAULT;
 +
 +		num_planes = kp->length;
 +		if (num_planes == 0) {
 +			kp->m.planes = NULL;
 +			/* num_planes == 0 is legal, e.g. when userspace doesn't
 +			 * need planes array on DQBUF*/
 +			return 0;
++=======
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    assign_in_user(&kp->index, &up->index) ||
+ 	    get_user(type, &up->type) ||
+ 	    put_user(type, &kp->type) ||
+ 	    assign_in_user(&kp->flags, &up->flags) ||
+ 	    get_user(memory, &up->memory) ||
+ 	    put_user(memory, &kp->memory) ||
+ 	    get_user(length, &up->length) ||
+ 	    put_user(length, &kp->length))
+ 		return -EFAULT;
+ 
+ 	if (V4L2_TYPE_IS_OUTPUT(type))
+ 		if (assign_in_user(&kp->bytesused, &up->bytesused) ||
+ 		    assign_in_user(&kp->field, &up->field) ||
+ 		    assign_in_user(&kp->timestamp.tv_sec,
+ 				   &up->timestamp.tv_sec) ||
+ 		    assign_in_user(&kp->timestamp.tv_usec,
+ 				   &up->timestamp.tv_usec))
+ 			return -EFAULT;
+ 
+ 	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {
+ 		u32 num_planes = length;
+ 
+ 		if (num_planes == 0) {
+ 			/*
+ 			 * num_planes == 0 is legal, e.g. when userspace doesn't
+ 			 * need planes array on DQBUF
+ 			 */
+ 			return put_user(NULL, &kp->m.planes);
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		}
+ 		if (num_planes > VIDEO_MAX_PLANES)
+ 			return -EINVAL;
  
  		if (get_user(p, &up->m.planes))
  			return -EFAULT;
  
  		uplane32 = compat_ptr(p);
  		if (!access_ok(VERIFY_READ, uplane32,
++<<<<<<< HEAD
 +				num_planes * sizeof(struct v4l2_plane32)))
 +			return -EFAULT;
 +
 +		/* We don't really care if userspace decides to kill itself
 +		 * by passing a very big num_planes value */
 +		uplane = compat_alloc_user_space(num_planes *
 +						sizeof(struct v4l2_plane));
 +		kp->m.planes = uplane;
 +
 +		while (--num_planes >= 0) {
 +			ret = get_v4l2_plane32(uplane, uplane32, kp->memory);
++=======
+ 			       num_planes * sizeof(*uplane32)))
+ 			return -EFAULT;
+ 
+ 		/*
+ 		 * We don't really care if userspace decides to kill itself
+ 		 * by passing a very big num_planes value
+ 		 */
+ 		if (aux_space < num_planes * sizeof(*uplane))
+ 			return -EFAULT;
+ 
+ 		uplane = aux_buf;
+ 		if (put_user((__force struct v4l2_plane *)uplane,
+ 			     &kp->m.planes))
+ 			return -EFAULT;
+ 
+ 		while (num_planes--) {
+ 			ret = get_v4l2_plane32(uplane, uplane32, memory);
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			if (ret)
  				return ret;
- 			++uplane;
- 			++uplane32;
+ 			uplane++;
+ 			uplane32++;
  		}
  	} else {
- 		switch (kp->memory) {
+ 		switch (memory) {
  		case V4L2_MEMORY_MMAP:
++<<<<<<< HEAD
 +			if (get_user(kp->length, &up->length) ||
 +				get_user(kp->m.offset, &up->m.offset))
 +				return -EFAULT;
 +			break;
 +		case V4L2_MEMORY_USERPTR:
 +			{
 +			compat_long_t tmp;
 +
 +			if (get_user(kp->length, &up->length) ||
 +			    get_user(tmp, &up->m.userptr))
 +				return -EFAULT;
 +
 +			kp->m.userptr = (unsigned long)compat_ptr(tmp);
 +			}
 +			break;
 +		case V4L2_MEMORY_OVERLAY:
 +			if (get_user(kp->m.offset, &up->m.offset))
 +				return -EFAULT;
 +			break;
++=======
+ 		case V4L2_MEMORY_OVERLAY:
+ 			if (assign_in_user(&kp->m.offset, &up->m.offset))
+ 				return -EFAULT;
+ 			break;
+ 		case V4L2_MEMORY_USERPTR: {
+ 			compat_ulong_t userptr;
+ 
+ 			if (get_user(userptr, &up->m.userptr) ||
+ 			    put_user((unsigned long)compat_ptr(userptr),
+ 				     &kp->m.userptr))
+ 				return -EFAULT;
+ 			break;
+ 		}
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		case V4L2_MEMORY_DMABUF:
- 			if (get_user(kp->m.fd, &up->m.fd))
+ 			if (assign_in_user(&kp->m.fd, &up->m.fd))
  				return -EFAULT;
  			break;
  		}
@@@ -471,32 -587,37 +846,60 @@@ static int put_v4l2_buffer32(struct v4l
  	struct v4l2_plane32 __user *uplane32;
  	struct v4l2_plane __user *uplane;
  	compat_caddr_t p;
- 	int num_planes;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_buffer32)) ||
 +		put_user(kp->index, &up->index) ||
 +		put_user(kp->type, &up->type) ||
 +		put_user(kp->flags, &up->flags) ||
 +		put_user(kp->memory, &up->memory))
 +			return -EFAULT;
 +
 +	if (put_user(kp->bytesused, &up->bytesused) ||
 +		put_user(kp->field, &up->field) ||
 +		put_user(kp->timestamp.tv_sec, &up->timestamp.tv_sec) ||
 +		put_user(kp->timestamp.tv_usec, &up->timestamp.tv_usec) ||
 +		copy_to_user(&up->timecode, &kp->timecode, sizeof(struct v4l2_timecode)) ||
 +		put_user(kp->sequence, &up->sequence) ||
 +		put_user(kp->reserved2, &up->reserved2) ||
 +		put_user(kp->reserved, &up->reserved))
 +			return -EFAULT;
++=======
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    assign_in_user(&up->index, &kp->index) ||
+ 	    get_user(type, &kp->type) ||
+ 	    put_user(type, &up->type) ||
+ 	    assign_in_user(&up->flags, &kp->flags) ||
+ 	    get_user(memory, &kp->memory) ||
+ 	    put_user(memory, &up->memory))
+ 		return -EFAULT;
+ 
+ 	if (assign_in_user(&up->bytesused, &kp->bytesused) ||
+ 	    assign_in_user(&up->field, &kp->field) ||
+ 	    assign_in_user(&up->timestamp.tv_sec, &kp->timestamp.tv_sec) ||
+ 	    assign_in_user(&up->timestamp.tv_usec, &kp->timestamp.tv_usec) ||
+ 	    copy_in_user(&up->timecode, &kp->timecode, sizeof(kp->timecode)) ||
+ 	    assign_in_user(&up->sequence, &kp->sequence) ||
+ 	    assign_in_user(&up->reserved2, &kp->reserved2) ||
+ 	    assign_in_user(&up->reserved, &kp->reserved) ||
+ 	    get_user(length, &kp->length) ||
+ 	    put_user(length, &up->length))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
+ 
+ 	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {
+ 		u32 num_planes = length;
  
- 	if (V4L2_TYPE_IS_MULTIPLANAR(kp->type)) {
- 		num_planes = kp->length;
  		if (num_planes == 0)
  			return 0;
  
++<<<<<<< HEAD
 +		uplane = kp->m.planes;
++=======
+ 		if (get_user(uplane, ((__force struct v4l2_plane __user **)&kp->m.planes)))
+ 			return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		if (get_user(p, &up->m.planes))
  			return -EFAULT;
  		uplane32 = compat_ptr(p);
@@@ -509,19 -630,14 +912,28 @@@
  			++uplane32;
  		}
  	} else {
- 		switch (kp->memory) {
+ 		switch (memory) {
  		case V4L2_MEMORY_MMAP:
++<<<<<<< HEAD
 +			if (put_user(kp->length, &up->length) ||
 +				put_user(kp->m.offset, &up->m.offset))
 +				return -EFAULT;
 +			break;
 +		case V4L2_MEMORY_USERPTR:
 +			if (put_user(kp->length, &up->length) ||
 +				put_user(kp->m.userptr, &up->m.userptr))
 +				return -EFAULT;
 +			break;
 +		case V4L2_MEMORY_OVERLAY:
 +			if (put_user(kp->m.offset, &up->m.offset))
++=======
+ 		case V4L2_MEMORY_OVERLAY:
+ 			if (assign_in_user(&up->m.offset, &kp->m.offset))
+ 				return -EFAULT;
+ 			break;
+ 		case V4L2_MEMORY_USERPTR:
+ 			if (assign_in_user(&up->m.userptr, &kp->m.userptr))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  				return -EFAULT;
  			break;
  		case V4L2_MEMORY_DMABUF:
@@@ -537,34 -653,46 +949,56 @@@
  struct v4l2_framebuffer32 {
  	__u32			capability;
  	__u32			flags;
 -	compat_caddr_t		base;
 -	struct {
 -		__u32		width;
 -		__u32		height;
 -		__u32		pixelformat;
 -		__u32		field;
 -		__u32		bytesperline;
 -		__u32		sizeimage;
 -		__u32		colorspace;
 -		__u32		priv;
 -	} fmt;
 +	compat_caddr_t 		base;
 +	struct v4l2_pix_format	fmt;
  };
  
- static int get_v4l2_framebuffer32(struct v4l2_framebuffer *kp, struct v4l2_framebuffer32 __user *up)
+ static int get_v4l2_framebuffer32(struct v4l2_framebuffer __user *kp,
+ 				  struct v4l2_framebuffer32 __user *up)
  {
- 	u32 tmp;
+ 	compat_caddr_t tmp;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_framebuffer32)) ||
 +		get_user(tmp, &up->base) ||
 +		get_user(kp->capability, &up->capability) ||
 +		get_user(kp->flags, &up->flags))
 +			return -EFAULT;
 +	kp->base = compat_ptr(tmp);
 +	get_v4l2_pix_format(&kp->fmt, &up->fmt);
++=======
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    get_user(tmp, &up->base) ||
+ 	    put_user((__force void *)compat_ptr(tmp), &kp->base) ||
+ 	    assign_in_user(&kp->capability, &up->capability) ||
+ 	    assign_in_user(&kp->flags, &up->flags) ||
+ 	    copy_in_user(&kp->fmt, &up->fmt, sizeof(kp->fmt)))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return 0;
  }
  
- static int put_v4l2_framebuffer32(struct v4l2_framebuffer *kp, struct v4l2_framebuffer32 __user *up)
+ static int put_v4l2_framebuffer32(struct v4l2_framebuffer __user *kp,
+ 				  struct v4l2_framebuffer32 __user *up)
  {
- 	u32 tmp = (u32)((unsigned long)kp->base);
+ 	void *base;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_framebuffer32)) ||
 +		put_user(tmp, &up->base) ||
 +		put_user(kp->capability, &up->capability) ||
 +		put_user(kp->flags, &up->flags))
 +			return -EFAULT;
 +	put_v4l2_pix_format(&kp->fmt, &up->fmt);
++=======
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    get_user(base, &kp->base) ||
+ 	    put_user(ptr_to_compat(base), &up->base) ||
+ 	    assign_in_user(&up->capability, &kp->capability) ||
+ 	    assign_in_user(&up->flags, &kp->flags) ||
+ 	    copy_in_user(&up->fmt, &kp->fmt, sizeof(kp->fmt)))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return 0;
  }
  
@@@ -574,23 -702,28 +1008,35 @@@ struct v4l2_input32 
  	__u32	     type;		/*  Type of input */
  	__u32	     audioset;		/*  Associated audios (bitfield) */
  	__u32        tuner;             /*  Associated tuner */
 -	compat_u64   std;
 +	v4l2_std_id  std;
  	__u32	     status;
 -	__u32	     capabilities;
 -	__u32	     reserved[3];
 -};
 +	__u32	     reserved[4];
 +} __attribute__ ((packed));
  
- /* The 64-bit v4l2_input struct has extra padding at the end of the struct.
-    Otherwise it is identical to the 32-bit version. */
- static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
+ /*
+  * The 64-bit v4l2_input struct has extra padding at the end of the struct.
+  * Otherwise it is identical to the 32-bit version.
+  */
+ static inline int get_v4l2_input32(struct v4l2_input __user *kp,
+ 				   struct v4l2_input32 __user *up)
  {
++<<<<<<< HEAD
 +	if (copy_from_user(kp, up, sizeof(struct v4l2_input32)))
++=======
+ 	if (copy_in_user(kp, up, sizeof(*up)))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		return -EFAULT;
  	return 0;
  }
  
- static inline int put_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
+ static inline int put_v4l2_input32(struct v4l2_input __user *kp,
+ 				   struct v4l2_input32 __user *up)
  {
++<<<<<<< HEAD
 +	if (copy_to_user(up, kp, sizeof(struct v4l2_input32)))
++=======
+ 	if (copy_in_user(up, kp, sizeof(*up)))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		return -EFAULT;
  	return 0;
  }
@@@ -614,53 -747,95 +1060,115 @@@ struct v4l2_ext_control32 
  	};
  } __attribute__ ((packed));
  
 -/* Return true if this control is a pointer type. */
 -static inline bool ctrl_is_pointer(struct file *file, u32 id)
 -{
 -	struct video_device *vdev = video_devdata(file);
 -	struct v4l2_fh *fh = NULL;
 -	struct v4l2_ctrl_handler *hdl = NULL;
 -	struct v4l2_query_ext_ctrl qec = { id };
 -	const struct v4l2_ioctl_ops *ops = vdev->ioctl_ops;
 -
 -	if (test_bit(V4L2_FL_USES_V4L2_FH, &vdev->flags))
 -		fh = file->private_data;
 -
 -	if (fh && fh->ctrl_handler)
 -		hdl = fh->ctrl_handler;
 -	else if (vdev->ctrl_handler)
 -		hdl = vdev->ctrl_handler;
 -
 -	if (hdl) {
 -		struct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, id);
 +/* The following function really belong in v4l2-common, but that causes
 +   a circular dependency between modules. We need to think about this, but
 +   for now this will do. */
  
 -		return ctrl && ctrl->is_ptr;
 +/* Return non-zero if this control is a pointer type. Currently only
 +   type STRING is a pointer type. */
 +static inline int ctrl_is_pointer(u32 id)
 +{
 +	switch (id) {
 +	case V4L2_CID_RDS_TX_PS_NAME:
 +	case V4L2_CID_RDS_TX_RADIO_TEXT:
 +		return 1;
 +	default:
 +		return 0;
  	}
 -
 -	if (!ops->vidioc_query_ext_ctrl)
 -		return false;
 -
 -	return !ops->vidioc_query_ext_ctrl(file, fh, &qec) &&
 -		(qec.flags & V4L2_CTRL_FLAG_HAS_PAYLOAD);
  }
  
++<<<<<<< HEAD
 +static int get_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext_controls32 __user *up)
 +{
 +	struct v4l2_ext_control32 __user *ucontrols;
 +	struct v4l2_ext_control __user *kcontrols;
 +	int n;
 +	compat_caddr_t p;
 +
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_ext_controls32)) ||
 +		get_user(kp->ctrl_class, &up->ctrl_class) ||
 +		get_user(kp->count, &up->count) ||
 +		get_user(kp->error_idx, &up->error_idx) ||
 +		copy_from_user(kp->reserved, up->reserved, sizeof(kp->reserved)))
 +			return -EFAULT;
 +	n = kp->count;
 +	if (n == 0) {
 +		kp->controls = NULL;
 +		return 0;
 +	}
 +	if (get_user(p, &up->controls))
 +		return -EFAULT;
 +	ucontrols = compat_ptr(p);
 +	if (!access_ok(VERIFY_READ, ucontrols,
 +			n * sizeof(struct v4l2_ext_control32)))
 +		return -EFAULT;
 +	kcontrols = compat_alloc_user_space(n * sizeof(struct v4l2_ext_control));
 +	kp->controls = kcontrols;
 +	while (--n >= 0) {
 +		if (copy_in_user(kcontrols, ucontrols, sizeof(*ucontrols)))
 +			return -EFAULT;
 +		if (ctrl_is_pointer(kcontrols->id)) {
++=======
+ static int bufsize_v4l2_ext_controls(struct v4l2_ext_controls32 __user *up,
+ 				     u32 *size)
+ {
+ 	u32 count;
+ 
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    get_user(count, &up->count))
+ 		return -EFAULT;
+ 	if (count > V4L2_CID_MAX_CTRLS)
+ 		return -EINVAL;
+ 	*size = count * sizeof(struct v4l2_ext_control);
+ 	return 0;
+ }
+ 
+ static int get_v4l2_ext_controls32(struct file *file,
+ 				   struct v4l2_ext_controls __user *kp,
+ 				   struct v4l2_ext_controls32 __user *up,
+ 				   void __user *aux_buf, u32 aux_space)
+ {
+ 	struct v4l2_ext_control32 __user *ucontrols;
+ 	struct v4l2_ext_control __user *kcontrols;
+ 	u32 count;
+ 	u32 n;
+ 	compat_caddr_t p;
+ 
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    assign_in_user(&kp->which, &up->which) ||
+ 	    get_user(count, &up->count) ||
+ 	    put_user(count, &kp->count) ||
+ 	    assign_in_user(&kp->error_idx, &up->error_idx) ||
+ 	    copy_in_user(kp->reserved, up->reserved, sizeof(kp->reserved)))
+ 		return -EFAULT;
+ 
+ 	if (count == 0)
+ 		return put_user(NULL, &kp->controls);
+ 	if (count > V4L2_CID_MAX_CTRLS)
+ 		return -EINVAL;
+ 	if (get_user(p, &up->controls))
+ 		return -EFAULT;
+ 	ucontrols = compat_ptr(p);
+ 	if (!access_ok(VERIFY_READ, ucontrols, count * sizeof(*ucontrols)))
+ 		return -EFAULT;
+ 	if (aux_space < count * sizeof(*kcontrols))
+ 		return -EFAULT;
+ 	kcontrols = aux_buf;
+ 	if (put_user((__force struct v4l2_ext_control *)kcontrols,
+ 		     &kp->controls))
+ 		return -EFAULT;
+ 
+ 	for (n = 0; n < count; n++) {
+ 		u32 id;
+ 
+ 		if (copy_in_user(kcontrols, ucontrols, sizeof(*ucontrols)))
+ 			return -EFAULT;
+ 
+ 		if (get_user(id, &kcontrols->id))
+ 			return -EFAULT;
+ 
+ 		if (ctrl_is_pointer(file, id)) {
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			void __user *s;
  
  			if (get_user(p, &ucontrols->string))
@@@ -675,39 -850,55 +1183,87 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int put_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext_controls32 __user *up)
 +{
 +	struct v4l2_ext_control32 __user *ucontrols;
 +	struct v4l2_ext_control __user *kcontrols = kp->controls;
 +	int n = kp->count;
 +	compat_caddr_t p;
 +
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_ext_controls32)) ||
 +		put_user(kp->ctrl_class, &up->ctrl_class) ||
 +		put_user(kp->count, &up->count) ||
 +		put_user(kp->error_idx, &up->error_idx) ||
 +		copy_to_user(up->reserved, kp->reserved, sizeof(up->reserved)))
 +			return -EFAULT;
 +	if (!kp->count)
 +		return 0;
++=======
+ static int put_v4l2_ext_controls32(struct file *file,
+ 				   struct v4l2_ext_controls __user *kp,
+ 				   struct v4l2_ext_controls32 __user *up)
+ {
+ 	struct v4l2_ext_control32 __user *ucontrols;
+ 	struct v4l2_ext_control __user *kcontrols;
+ 	u32 count;
+ 	u32 n;
+ 	compat_caddr_t p;
+ 
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    assign_in_user(&up->which, &kp->which) ||
+ 	    get_user(count, &kp->count) ||
+ 	    put_user(count, &up->count) ||
+ 	    assign_in_user(&up->error_idx, &kp->error_idx) ||
+ 	    copy_in_user(up->reserved, kp->reserved, sizeof(up->reserved)) ||
+ 	    get_user(kcontrols, &kp->controls))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  
+ 	if (!count)
+ 		return 0;
  	if (get_user(p, &up->controls))
  		return -EFAULT;
  	ucontrols = compat_ptr(p);
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, ucontrols,
 +			n * sizeof(struct v4l2_ext_control32)))
 +		return -EFAULT;
 +
 +	while (--n >= 0) {
 +		unsigned size = sizeof(*ucontrols);
 +
 +		/* Do not modify the pointer when copying a pointer control.
 +		   The contents of the pointer was changed, not the pointer
 +		   itself. */
 +		if (ctrl_is_pointer(kcontrols->id))
++=======
+ 	if (!access_ok(VERIFY_WRITE, ucontrols, count * sizeof(*ucontrols)))
+ 		return -EFAULT;
+ 
+ 	for (n = 0; n < count; n++) {
+ 		unsigned int size = sizeof(*ucontrols);
+ 		u32 id;
+ 
+ 		if (get_user(id, &kcontrols->id) ||
+ 		    put_user(id, &ucontrols->id) ||
+ 		    assign_in_user(&ucontrols->size, &kcontrols->size) ||
+ 		    copy_in_user(&ucontrols->reserved2, &kcontrols->reserved2,
+ 				 sizeof(ucontrols->reserved2)))
+ 			return -EFAULT;
+ 
+ 		/*
+ 		 * Do not modify the pointer when copying a pointer control.
+ 		 * The contents of the pointer was changed, not the pointer
+ 		 * itself.
+ 		 */
+ 		if (ctrl_is_pointer(file, id))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			size -= sizeof(ucontrols->value64);
+ 
  		if (copy_in_user(ucontrols, kcontrols, size))
  			return -EFAULT;
+ 
  		ucontrols++;
  		kcontrols++;
  	}
@@@ -726,17 -918,19 +1282,31 @@@ struct v4l2_event32 
  	__u32				reserved[8];
  };
  
- static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *up)
+ static int put_v4l2_event32(struct v4l2_event __user *kp,
+ 			    struct v4l2_event32 __user *up)
  {
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_event32)) ||
 +		put_user(kp->type, &up->type) ||
 +		copy_to_user(&up->u, &kp->u, sizeof(kp->u)) ||
 +		put_user(kp->pending, &up->pending) ||
 +		put_user(kp->sequence, &up->sequence) ||
 +		put_compat_timespec(&kp->timestamp, &up->timestamp) ||
 +		put_user(kp->id, &up->id) ||
 +		copy_to_user(up->reserved, kp->reserved, 8 * sizeof(__u32)))
 +			return -EFAULT;
++=======
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    assign_in_user(&up->type, &kp->type) ||
+ 	    copy_in_user(&up->u, &kp->u, sizeof(kp->u)) ||
+ 	    assign_in_user(&up->pending, &kp->pending) ||
+ 	    assign_in_user(&up->sequence, &kp->sequence) ||
+ 	    assign_in_user(&up->timestamp.tv_sec, &kp->timestamp.tv_sec) ||
+ 	    assign_in_user(&up->timestamp.tv_nsec, &kp->timestamp.tv_nsec) ||
+ 	    assign_in_user(&up->id, &kp->id) ||
+ 	    copy_in_user(up->reserved, kp->reserved, sizeof(up->reserved)))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return 0;
  }
  
@@@ -748,32 -942,35 +1318,64 @@@ struct v4l2_subdev_edid32 
  	compat_caddr_t edid;
  };
  
++<<<<<<< HEAD
 +static int get_v4l2_subdev_edid32(struct v4l2_subdev_edid *kp, struct v4l2_subdev_edid32 __user *up)
++=======
+ static int get_v4l2_edid32(struct v4l2_edid __user *kp,
+ 			   struct v4l2_edid32 __user *up)
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  {
- 	u32 tmp;
+ 	compat_uptr_t tmp;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_subdev_edid32)) ||
 +		get_user(kp->pad, &up->pad) ||
 +		get_user(kp->start_block, &up->start_block) ||
 +		get_user(kp->blocks, &up->blocks) ||
 +		get_user(tmp, &up->edid) ||
 +		copy_from_user(kp->reserved, up->reserved, sizeof(kp->reserved)))
 +			return -EFAULT;
 +	kp->edid = compat_ptr(tmp);
 +	return 0;
 +}
 +
 +static int put_v4l2_subdev_edid32(struct v4l2_subdev_edid *kp, struct v4l2_subdev_edid32 __user *up)
++=======
+ 	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
+ 	    assign_in_user(&kp->pad, &up->pad) ||
+ 	    assign_in_user(&kp->start_block, &up->start_block) ||
+ 	    assign_in_user(&kp->blocks, &up->blocks) ||
+ 	    get_user(tmp, &up->edid) ||
+ 	    put_user(compat_ptr(tmp), &kp->edid) ||
+ 	    copy_in_user(kp->reserved, up->reserved, sizeof(kp->reserved)))
+ 		return -EFAULT;
+ 	return 0;
+ }
+ 
+ static int put_v4l2_edid32(struct v4l2_edid __user *kp,
+ 			   struct v4l2_edid32 __user *up)
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  {
- 	u32 tmp = (u32)((unsigned long)kp->edid);
+ 	void *edid;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_subdev_edid32)) ||
 +		put_user(kp->pad, &up->pad) ||
 +		put_user(kp->start_block, &up->start_block) ||
 +		put_user(kp->blocks, &up->blocks) ||
 +		put_user(tmp, &up->edid) ||
 +		copy_to_user(kp->reserved, up->reserved, sizeof(kp->reserved)))
 +			return -EFAULT;
++=======
+ 	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
+ 	    assign_in_user(&up->pad, &kp->pad) ||
+ 	    assign_in_user(&up->start_block, &kp->start_block) ||
+ 	    assign_in_user(&up->blocks, &kp->blocks) ||
+ 	    get_user(edid, &kp->edid) ||
+ 	    put_user(ptr_to_compat(edid), &up->edid) ||
+ 	    copy_in_user(up->reserved, kp->reserved, sizeof(up->reserved)))
+ 		return -EFAULT;
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	return 0;
  }
  
@@@ -805,22 -1002,23 +1407,39 @@@
  #define VIDIOC_G_OUTPUT32	_IOR ('V', 46, s32)
  #define VIDIOC_S_OUTPUT32	_IOWR('V', 47, s32)
  
+ static int alloc_userspace(unsigned int size, u32 aux_space,
+ 			   void __user **up_native)
+ {
+ 	*up_native = compat_alloc_user_space(size + aux_space);
+ 	if (!*up_native)
+ 		return -ENOMEM;
+ 	if (clear_user(*up_native, size))
+ 		return -EFAULT;
+ 	return 0;
+ }
+ 
  static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
  {
++<<<<<<< HEAD
 +	union {
 +		struct v4l2_format v2f;
 +		struct v4l2_buffer v2b;
 +		struct v4l2_framebuffer v2fb;
 +		struct v4l2_input v2i;
 +		struct v4l2_standard v2s;
 +		struct v4l2_ext_controls v2ecs;
 +		struct v4l2_event v2ev;
 +		struct v4l2_create_buffers v2crt;
 +		struct v4l2_subdev_edid v2edid;
 +		unsigned long vx;
 +		int vi;
 +	} karg;
++=======
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	void __user *up = compat_ptr(arg);
+ 	void __user *up_native = NULL;
+ 	void __user *aux_buf;
+ 	u32 aux_space;
  	int compatible_arg = 1;
  	long err = 0;
  
@@@ -868,9 -1070,11 +1491,17 @@@
  		compatible_arg = 0;
  		break;
  
++<<<<<<< HEAD
 +	case VIDIOC_SUBDEV_G_EDID:
 +	case VIDIOC_SUBDEV_S_EDID:
 +		err = get_v4l2_subdev_edid32(&karg.v2edid, up);
++=======
+ 	case VIDIOC_G_EDID:
+ 	case VIDIOC_S_EDID:
+ 		err = alloc_userspace(sizeof(struct v4l2_edid), 0, &up_native);
+ 		if (!err)
+ 			err = get_v4l2_edid32(up_native, up);
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		compatible_arg = 0;
  		break;
  
@@@ -916,7 -1154,15 +1581,19 @@@
  	case VIDIOC_G_EXT_CTRLS:
  	case VIDIOC_S_EXT_CTRLS:
  	case VIDIOC_TRY_EXT_CTRLS:
++<<<<<<< HEAD
 +		err = get_v4l2_ext_controls32(&karg.v2ecs, up);
++=======
+ 		err = bufsize_v4l2_ext_controls(up, &aux_space);
+ 		if (!err)
+ 			err = alloc_userspace(sizeof(struct v4l2_ext_controls),
+ 					      aux_space, &up_native);
+ 		if (!err) {
+ 			aux_buf = up_native + sizeof(struct v4l2_ext_controls);
+ 			err = get_v4l2_ext_controls32(file, up_native, up,
+ 						      aux_buf, aux_space);
+ 		}
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		compatible_arg = 0;
  		break;
  	case VIDIOC_DQEVENT:
@@@ -928,22 -1175,26 +1606,36 @@@
  
  	if (compatible_arg)
  		err = native_ioctl(file, cmd, (unsigned long)up);
- 	else {
- 		mm_segment_t old_fs = get_fs();
- 
- 		set_fs(KERNEL_DS);
- 		err = native_ioctl(file, cmd, (unsigned long)&karg);
- 		set_fs(old_fs);
- 	}
+ 	else
+ 		err = native_ioctl(file, cmd, (unsigned long)up_native);
  
++<<<<<<< HEAD
 +	/* Special case: even after an error we need to put the
 +	   results back for these ioctls since the error_idx will
 +	   contain information on which control failed. */
++=======
+ 	if (err == -ENOTTY)
+ 		return err;
+ 
+ 	/*
+ 	 * Special case: even after an error we need to put the
+ 	 * results back for these ioctls since the error_idx will
+ 	 * contain information on which control failed.
+ 	 */
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  	switch (cmd) {
  	case VIDIOC_G_EXT_CTRLS:
  	case VIDIOC_S_EXT_CTRLS:
  	case VIDIOC_TRY_EXT_CTRLS:
++<<<<<<< HEAD
 +		if (put_v4l2_ext_controls32(&karg.v2ecs, up))
++=======
+ 		if (put_v4l2_ext_controls32(file, up_native, up))
+ 			err = -EFAULT;
+ 		break;
+ 	case VIDIOC_S_EDID:
+ 		if (put_v4l2_edid32(up_native, up))
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  			err = -EFAULT;
  		break;
  	}
@@@ -963,12 -1216,11 +1657,17 @@@
  		break;
  
  	case VIDIOC_DQEVENT:
- 		err = put_v4l2_event32(&karg.v2ev, up);
+ 		err = put_v4l2_event32(up_native, up);
  		break;
  
++<<<<<<< HEAD
 +	case VIDIOC_SUBDEV_G_EDID:
 +	case VIDIOC_SUBDEV_S_EDID:
 +		err = put_v4l2_subdev_edid32(&karg.v2edid, up);
++=======
+ 	case VIDIOC_G_EDID:
+ 		err = put_v4l2_edid32(up_native, up);
++>>>>>>> a1dfb4c48cc1 (media: v4l2-compat-ioctl32.c: refactor compat ioctl32 logic)
  		break;
  
  	case VIDIOC_G_FMT:
@@@ -978,9 -1230,10 +1677,9 @@@
  		break;
  
  	case VIDIOC_CREATE_BUFS:
- 		err = put_v4l2_create32(&karg.v2crt, up);
+ 		err = put_v4l2_create32(up_native, up);
  		break;
  
 -	case VIDIOC_PREPARE_BUF:
  	case VIDIOC_QUERYBUF:
  	case VIDIOC_QBUF:
  	case VIDIOC_DQBUF:
* Unmerged path drivers/media/v4l2-core/v4l2-compat-ioctl32.c
