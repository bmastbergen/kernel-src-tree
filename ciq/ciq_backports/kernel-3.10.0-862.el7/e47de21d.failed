s390/zcrypt: Fixed attrition of AP adapters and domains

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: Fixed attrition of AP adapters and domains (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 95.24%
commit-author Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
commit e47de21dd35bad6d1e71482a66699cd04e83ea40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e47de21d.failed

Currently the first eligible AP adapter respectively domain will be
selected to service requests. In case of sequential workload, the
very same adapter/domain will be used.

The adapter/domain selection algorithm now considers the completed
transactions per adaper/domain and therefore ensures a homogeneous
utilization.

	Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit e47de21dd35bad6d1e71482a66699cd04e83ea40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.h
#	drivers/s390/crypto/ap_card.c
#	drivers/s390/crypto/ap_queue.c
#	drivers/s390/crypto/zcrypt_api.c
diff --cc drivers/s390/crypto/ap_bus.h
index 2da8ecdc7a5f,4dc7c88fb054..000000000000
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@@ -203,6 -186,44 +203,47 @@@ struct ap_device 
  
  #define to_ap_dev(x) container_of((x), struct ap_device, device)
  
++<<<<<<< HEAD
++=======
+ struct ap_card {
+ 	struct ap_device ap_dev;
+ 	struct list_head list;		/* Private list of AP cards. */
+ 	struct list_head queues;	/* List of assoc. AP queues */
+ 	void *private;			/* ap driver private pointer. */
+ 	int raw_hwtype;			/* AP raw hardware type. */
+ 	unsigned int functions;		/* AP device function bitfield. */
+ 	int queue_depth;		/* AP queue depth.*/
+ 	int id;				/* AP card number. */
+ 	atomic_t total_request_count;	/* # requests ever for this AP device.*/
+ };
+ 
+ #define to_ap_card(x) container_of((x), struct ap_card, ap_dev.device)
+ 
+ struct ap_queue {
+ 	struct ap_device ap_dev;
+ 	struct list_head list;		/* Private list of AP queues. */
+ 	struct ap_card *card;		/* Ptr to assoc. AP card. */
+ 	spinlock_t lock;		/* Per device lock. */
+ 	void *private;			/* ap driver private pointer. */
+ 	ap_qid_t qid;			/* AP queue id. */
+ 	int interrupt;			/* indicate if interrupts are enabled */
+ 	int queue_count;		/* # messages currently on AP queue. */
+ 	enum ap_state state;		/* State of the AP device. */
+ 	int pendingq_count;		/* # requests on pendingq list. */
+ 	int requestq_count;		/* # requests on requestq list. */
+ 	int total_request_count;	/* # requests ever for this AP device.*/
+ 	int request_timeout;		/* Request timout in jiffies. */
+ 	struct timer_list timeout;	/* Timer for request timeouts. */
+ 	struct list_head pendingq;	/* List of message sent to AP queue. */
+ 	struct list_head requestq;	/* List of message yet to be sent. */
+ 	struct ap_message *reply;	/* Per device reply message. */
+ };
+ 
+ #define to_ap_queue(x) container_of((x), struct ap_queue, ap_dev.device)
+ 
+ typedef enum ap_wait (ap_func_t)(struct ap_queue *queue);
+ 
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  struct ap_message {
  	struct list_head list;		/* Request queueing. */
  	unsigned long long psmid;	/* Message id. */
diff --cc drivers/s390/crypto/zcrypt_api.c
index 5282fcf3e2f5,c7b5e70f2938..000000000000
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@@ -415,6 -160,62 +415,65 @@@ static int zcrypt_release(struct inode 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct zcrypt_queue *zcrypt_pick_queue(struct zcrypt_card *zc,
+ 						     struct zcrypt_queue *zq,
+ 						     unsigned int weight)
+ {
+ 	if (!zq || !try_module_get(zq->queue->ap_dev.drv->driver.owner))
+ 		return NULL;
+ 	zcrypt_queue_get(zq);
+ 	get_device(&zq->queue->ap_dev.device);
+ 	atomic_add(weight, &zc->load);
+ 	atomic_add(weight, &zq->load);
+ 	zq->request_count++;
+ 	return zq;
+ }
+ 
+ static inline void zcrypt_drop_queue(struct zcrypt_card *zc,
+ 				     struct zcrypt_queue *zq,
+ 				     unsigned int weight)
+ {
+ 	struct module *mod = zq->queue->ap_dev.drv->driver.owner;
+ 
+ 	zq->request_count--;
+ 	atomic_sub(weight, &zc->load);
+ 	atomic_sub(weight, &zq->load);
+ 	put_device(&zq->queue->ap_dev.device);
+ 	zcrypt_queue_put(zq);
+ 	module_put(mod);
+ }
+ 
+ static inline bool zcrypt_card_compare(struct zcrypt_card *zc,
+ 				       struct zcrypt_card *pref_zc,
+ 				       unsigned weight, unsigned pref_weight)
+ {
+ 	if (!pref_zc)
+ 		return 0;
+ 	weight += atomic_read(&zc->load);
+ 	pref_weight += atomic_read(&pref_zc->load);
+ 	if (weight == pref_weight)
+ 		return atomic_read(&zc->card->total_request_count) >
+ 			atomic_read(&pref_zc->card->total_request_count);
+ 	return weight > pref_weight;
+ }
+ 
+ static inline bool zcrypt_queue_compare(struct zcrypt_queue *zq,
+ 					struct zcrypt_queue *pref_zq,
+ 					unsigned weight, unsigned pref_weight)
+ {
+ 	if (!pref_zq)
+ 		return 0;
+ 	weight += atomic_read(&zq->load);
+ 	pref_weight += atomic_read(&pref_zq->load);
+ 	if (weight == pref_weight)
+ 		return &zq->queue->total_request_count >
+ 			&pref_zq->queue->total_request_count;
+ 	return weight > pref_weight;
+ }
+ 
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  /*
   * zcrypt ioctls.
   */
@@@ -432,34 -236,50 +491,55 @@@ static long zcrypt_rsa_modexpo(struct i
  	 */
  	mex->outputdatalength = mex->inputdatalength;
  
 -	rc = get_rsa_modex_fc(mex, &func_code);
 -	if (rc)
 -		return rc;
 -
 -	pref_zc = NULL;
 -	pref_zq = NULL;
 -	spin_lock(&zcrypt_list_lock);
 -	for_each_zcrypt_card(zc) {
 -		/* Check for online accelarator and CCA cards */
 -		if (!zc->online || !(zc->card->functions & 0x18000000))
 +	spin_lock_bh(&zcrypt_device_lock);
 +	list_for_each_entry(zdev, &zcrypt_device_list, list) {
 +		if (!zdev->online ||
 +		    !zdev->ops->rsa_modexpo ||
 +		    zdev->min_mod_size > mex->inputdatalength ||
 +		    zdev->max_mod_size < mex->inputdatalength)
  			continue;
++<<<<<<< HEAD
 +		zcrypt_device_get(zdev);
 +		get_device(&zdev->ap_dev->device);
 +		zdev->request_count++;
 +		__zcrypt_decrease_preference(zdev);
 +		if (try_module_get(zdev->ap_dev->drv->driver.owner)) {
 +			spin_unlock_bh(&zcrypt_device_lock);
 +			rc = zdev->ops->rsa_modexpo(zdev, mex);
 +			spin_lock_bh(&zcrypt_device_lock);
 +			module_put(zdev->ap_dev->drv->driver.owner);
++=======
+ 		/* Check for size limits */
+ 		if (zc->min_mod_size > mex->inputdatalength ||
+ 		    zc->max_mod_size < mex->inputdatalength)
+ 			continue;
+ 		/* get weight index of the card device	*/
+ 		weight = zc->speed_rating[func_code];
+ 		if (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))
+ 			continue;
+ 		for_each_zcrypt_queue(zq, zc) {
+ 			/* check if device is online and eligible */
+ 			if (!zq->online)
+ 				continue;
+ 			if (zcrypt_queue_compare(zq, pref_zq,
+ 						 weight, pref_weight))
+ 				continue;
+ 			pref_zc = zc;
+ 			pref_zq = zq;
+ 			pref_weight = weight;
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  		}
 +		else
 +			rc = -EAGAIN;
 +		zdev->request_count--;
 +		__zcrypt_increase_preference(zdev);
 +		put_device(&zdev->ap_dev->device);
 +		zcrypt_device_put(zdev);
 +		spin_unlock_bh(&zcrypt_device_lock);
 +		return rc;
  	}
 -	pref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	if (!pref_zq)
 -		return -ENODEV;
 -
 -	rc = pref_zq->ops->rsa_modexpo(pref_zq, mex);
 -
 -	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	return rc;
 +	spin_unlock_bh(&zcrypt_device_lock);
 +	return -ENODEV;
  }
  
  static long zcrypt_rsa_crt(struct ica_rsa_modexpo_crt *crt)
@@@ -477,125 -299,133 +557,169 @@@
  	 */
  	crt->outputdatalength = crt->inputdatalength;
  
 -	rc = get_rsa_crt_fc(crt, &func_code);
 -	if (rc)
 -		return rc;
 -
 -	pref_zc = NULL;
 -	pref_zq = NULL;
 -	spin_lock(&zcrypt_list_lock);
 -	for_each_zcrypt_card(zc) {
 -		/* Check for online accelarator and CCA cards */
 -		if (!zc->online || !(zc->card->functions & 0x18000000))
 +	copied = 0;
 + restart:
 +	spin_lock_bh(&zcrypt_device_lock);
 +	list_for_each_entry(zdev, &zcrypt_device_list, list) {
 +		if (!zdev->online ||
 +		    !zdev->ops->rsa_modexpo_crt ||
 +		    zdev->min_mod_size > crt->inputdatalength ||
 +		    zdev->max_mod_size < crt->inputdatalength)
  			continue;
++<<<<<<< HEAD
 +		if (zdev->short_crt && crt->inputdatalength > 240) {
 +			/*
 +			 * Check inputdata for leading zeros for cards
 +			 * that can't handle np_prime, bp_key, or
 +			 * u_mult_inv > 128 bytes.
 +			 */
 +			if (copied == 0) {
 +				unsigned int len;
 +				spin_unlock_bh(&zcrypt_device_lock);
 +				/* len is max 256 / 2 - 120 = 8
 +				 * For bigger device just assume len of leading
 +				 * 0s is 8 as stated in the requirements for
 +				 * ica_rsa_modexpo_crt struct in zcrypt.h.
 +				 */
 +				if (crt->inputdatalength <= 256)
 +					len = crt->inputdatalength / 2 - 120;
 +				else
 +					len = 8;
 +				if (len > sizeof(z1))
 +					return -EFAULT;
 +				z1 = z2 = z3 = 0;
 +				if (copy_from_user(&z1, crt->np_prime, len) ||
 +				    copy_from_user(&z2, crt->bp_key, len) ||
 +				    copy_from_user(&z3, crt->u_mult_inv, len))
 +					return -EFAULT;
 +				z1 = z2 = z3 = 0;
 +				copied = 1;
 +				/*
 +				 * We have to restart device lookup -
 +				 * the device list may have changed by now.
 +				 */
 +				goto restart;
 +			}
 +			if (z1 != 0ULL || z2 != 0ULL || z3 != 0ULL)
 +				/* The device can't handle this request. */
 +				continue;
++=======
+ 		/* Check for size limits */
+ 		if (zc->min_mod_size > crt->inputdatalength ||
+ 		    zc->max_mod_size < crt->inputdatalength)
+ 			continue;
+ 		/* get weight index of the card device	*/
+ 		weight = zc->speed_rating[func_code];
+ 		if (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))
+ 			continue;
+ 		for_each_zcrypt_queue(zq, zc) {
+ 			/* check if device is online and eligible */
+ 			if (!zq->online)
+ 				continue;
+ 			if (zcrypt_queue_compare(zq, pref_zq,
+ 						 weight, pref_weight))
+ 				continue;
+ 			pref_zc = zc;
+ 			pref_zq = zq;
+ 			pref_weight = weight;
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  		}
 +		zcrypt_device_get(zdev);
 +		get_device(&zdev->ap_dev->device);
 +		zdev->request_count++;
 +		__zcrypt_decrease_preference(zdev);
 +		if (try_module_get(zdev->ap_dev->drv->driver.owner)) {
 +			spin_unlock_bh(&zcrypt_device_lock);
 +			rc = zdev->ops->rsa_modexpo_crt(zdev, crt);
 +			spin_lock_bh(&zcrypt_device_lock);
 +			module_put(zdev->ap_dev->drv->driver.owner);
 +		}
 +		else
 +			rc = -EAGAIN;
 +		zdev->request_count--;
 +		__zcrypt_increase_preference(zdev);
 +		put_device(&zdev->ap_dev->device);
 +		zcrypt_device_put(zdev);
 +		spin_unlock_bh(&zcrypt_device_lock);
 +		return rc;
  	}
 -	pref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	if (!pref_zq)
 -		return -ENODEV;
 -
 -	rc = pref_zq->ops->rsa_modexpo_crt(pref_zq, crt);
 -
 -	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	return rc;
 +	spin_unlock_bh(&zcrypt_device_lock);
 +	return -ENODEV;
  }
  
  static long zcrypt_send_cprb(struct ica_xcRB *xcRB)
  {
 -	struct zcrypt_card *zc, *pref_zc;
 -	struct zcrypt_queue *zq, *pref_zq;
 -	struct ap_message ap_msg;
 -	unsigned int weight, pref_weight;
 -	unsigned int func_code;
 -	unsigned short *domain;
 +	struct zcrypt_device *zdev;
  	int rc;
  
 -	rc = get_cprb_fc(xcRB, &ap_msg, &func_code, &domain);
 -	if (rc)
 -		return rc;
 -
 -	pref_zc = NULL;
 -	pref_zq = NULL;
 -	spin_lock(&zcrypt_list_lock);
 -	for_each_zcrypt_card(zc) {
 -		/* Check for online CCA cards */
 -		if (!zc->online || !(zc->card->functions & 0x10000000))
 +	spin_lock_bh(&zcrypt_device_lock);
 +	list_for_each_entry(zdev, &zcrypt_device_list, list) {
 +		if (!zdev->online || !zdev->ops->send_cprb ||
 +		   (zdev->ops->variant == MSGTYPE06_VARIANT_EP11) ||
 +		   (xcRB->user_defined != AUTOSELECT &&
 +		    AP_QID_DEVICE(zdev->ap_dev->qid) != xcRB->user_defined))
  			continue;
++<<<<<<< HEAD
 +		zcrypt_device_get(zdev);
 +		get_device(&zdev->ap_dev->device);
 +		zdev->request_count++;
 +		__zcrypt_decrease_preference(zdev);
 +		if (try_module_get(zdev->ap_dev->drv->driver.owner)) {
 +			spin_unlock_bh(&zcrypt_device_lock);
 +			rc = zdev->ops->send_cprb(zdev, xcRB);
 +			spin_lock_bh(&zcrypt_device_lock);
 +			module_put(zdev->ap_dev->drv->driver.owner);
++=======
+ 		/* Check for user selected CCA card */
+ 		if (xcRB->user_defined != AUTOSELECT &&
+ 		    xcRB->user_defined != zc->card->id)
+ 			continue;
+ 		/* get weight index of the card device	*/
+ 		weight = speed_idx_cca(func_code) * zc->speed_rating[SECKEY];
+ 		if (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))
+ 			continue;
+ 		for_each_zcrypt_queue(zq, zc) {
+ 			/* check if device is online and eligible */
+ 			if (!zq->online ||
+ 			    ((*domain != (unsigned short) AUTOSELECT) &&
+ 			     (*domain != AP_QID_QUEUE(zq->queue->qid))))
+ 				continue;
+ 			if (zcrypt_queue_compare(zq, pref_zq,
+ 						 weight, pref_weight))
+ 				continue;
+ 			pref_zc = zc;
+ 			pref_zq = zq;
+ 			pref_weight = weight;
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  		}
 +		else
 +			rc = -EAGAIN;
 +		zdev->request_count--;
 +		__zcrypt_increase_preference(zdev);
 +		put_device(&zdev->ap_dev->device);
 +		zcrypt_device_put(zdev);
 +		spin_unlock_bh(&zcrypt_device_lock);
 +		return rc;
  	}
 -	pref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	if (!pref_zq)
 -		return -ENODEV;
 -
 -	/* in case of auto select, provide the correct domain */
 -	if (*domain == (unsigned short) AUTOSELECT)
 -		*domain = AP_QID_QUEUE(pref_zq->queue->qid);
 -
 -	rc = pref_zq->ops->send_cprb(pref_zq, xcRB, &ap_msg);
 -
 -	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -	return rc;
 +	spin_unlock_bh(&zcrypt_device_lock);
 +	return -ENODEV;
  }
  
 -static bool is_desired_ep11_card(unsigned int dev_id,
 -				 unsigned short target_num,
 -				 struct ep11_target_dev *targets)
 -{
 -	while (target_num-- > 0) {
 -		if (dev_id == targets->ap_id)
 -			return true;
 -		targets++;
 -	}
 -	return false;
 -}
 +struct ep11_target_dev_list {
 +	unsigned short		targets_num;
 +	struct ep11_target_dev	*targets;
 +};
  
 -static bool is_desired_ep11_queue(unsigned int dev_qid,
 -				  unsigned short target_num,
 -				  struct ep11_target_dev *targets)
 +static bool is_desired_ep11dev(unsigned int dev_qid,
 +			       struct ep11_target_dev_list dev_list)
  {
 -	while (target_num-- > 0) {
 -		if (AP_MKQID(targets->ap_id, targets->dom_id) == dev_qid)
 +	int n;
 +
 +	for (n = 0; n < dev_list.targets_num; n++, dev_list.targets++) {
 +		if ((AP_QID_DEVICE(dev_qid) == dev_list.targets->ap_id) &&
 +		    (AP_QID_QUEUE(dev_qid) == dev_list.targets->dom_id)) {
  			return true;
 -		targets++;
 +		}
  	}
  	return false;
  }
@@@ -630,70 -458,108 +754,121 @@@ static long zcrypt_send_ep11_cprb(struc
  			return -EFAULT;
  	}
  
 -	rc = get_ep11cprb_fc(xcrb, &ap_msg, &func_code);
 -	if (rc)
 -		goto out_free;
 +	spin_lock_bh(&zcrypt_device_lock);
 +	list_for_each_entry(zdev, &zcrypt_device_list, list) {
 +		/* check if device is eligible */
 +		if (!zdev->online ||
 +		    zdev->ops->variant != MSGTYPE06_VARIANT_EP11)
 +			continue;
  
 -	pref_zc = NULL;
 -	pref_zq = NULL;
 -	spin_lock(&zcrypt_list_lock);
 -	for_each_zcrypt_card(zc) {
 -		/* Check for online EP11 cards */
 -		if (!zc->online || !(zc->card->functions & 0x04000000))
 +		/* check if device is selected as valid target */
 +		if (!is_desired_ep11dev(zdev->ap_dev->qid, ep11_dev_list) &&
 +		    !autoselect)
  			continue;
++<<<<<<< HEAD
 +
 +		zcrypt_device_get(zdev);
 +		get_device(&zdev->ap_dev->device);
 +		zdev->request_count++;
 +		__zcrypt_decrease_preference(zdev);
 +		if (try_module_get(zdev->ap_dev->drv->driver.owner)) {
 +			spin_unlock_bh(&zcrypt_device_lock);
 +			rc = zdev->ops->send_ep11_cprb(zdev, xcrb);
 +			spin_lock_bh(&zcrypt_device_lock);
 +			module_put(zdev->ap_dev->drv->driver.owner);
 +		} else {
 +			rc = -EAGAIN;
 +		  }
 +		zdev->request_count--;
 +		__zcrypt_increase_preference(zdev);
 +		put_device(&zdev->ap_dev->device);
 +		zcrypt_device_put(zdev);
 +		spin_unlock_bh(&zcrypt_device_lock);
 +		return rc;
++=======
+ 		/* Check for user selected EP11 card */
+ 		if (targets &&
+ 		    !is_desired_ep11_card(zc->card->id, target_num, targets))
+ 			continue;
+ 		/* get weight index of the card device	*/
+ 		weight = speed_idx_ep11(func_code) * zc->speed_rating[SECKEY];
+ 		if (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))
+ 			continue;
+ 		for_each_zcrypt_queue(zq, zc) {
+ 			/* check if device is online and eligible */
+ 			if (!zq->online ||
+ 			    (targets &&
+ 			     !is_desired_ep11_queue(zq->queue->qid,
+ 						    target_num, targets)))
+ 				continue;
+ 			if (zcrypt_queue_compare(zq, pref_zq,
+ 						 weight, pref_weight))
+ 				continue;
+ 			pref_zc = zc;
+ 			pref_zq = zq;
+ 			pref_weight = weight;
+ 		}
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  	}
 -	pref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	if (!pref_zq) {
 -		rc = -ENODEV;
 -		goto out_free;
 -	}
 -
 -	rc = pref_zq->ops->send_ep11_cprb(pref_zq, xcrb, &ap_msg);
 -
 -	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -out_free:
 -	kfree(targets);
 -	return rc;
 +	spin_unlock_bh(&zcrypt_device_lock);
 +	return -ENODEV;
  }
  
  static long zcrypt_rng(char *buffer)
  {
 -	struct zcrypt_card *zc, *pref_zc;
 -	struct zcrypt_queue *zq, *pref_zq;
 -	unsigned int weight, pref_weight;
 -	unsigned int func_code;
 -	struct ap_message ap_msg;
 -	unsigned int domain;
 +	struct zcrypt_device *zdev;
  	int rc;
  
 -	rc = get_rng_fc(&ap_msg, &func_code, &domain);
 -	if (rc)
 +	spin_lock_bh(&zcrypt_device_lock);
 +	list_for_each_entry(zdev, &zcrypt_device_list, list) {
 +		if (!zdev->online || !zdev->ops->rng)
 +			continue;
 +		zcrypt_device_get(zdev);
 +		get_device(&zdev->ap_dev->device);
 +		zdev->request_count++;
 +		__zcrypt_decrease_preference(zdev);
 +		if (try_module_get(zdev->ap_dev->drv->driver.owner)) {
 +			spin_unlock_bh(&zcrypt_device_lock);
 +			rc = zdev->ops->rng(zdev, buffer);
 +			spin_lock_bh(&zcrypt_device_lock);
 +			module_put(zdev->ap_dev->drv->driver.owner);
 +		} else
 +			rc = -EAGAIN;
 +		zdev->request_count--;
 +		__zcrypt_increase_preference(zdev);
 +		put_device(&zdev->ap_dev->device);
 +		zcrypt_device_put(zdev);
 +		spin_unlock_bh(&zcrypt_device_lock);
  		return rc;
++<<<<<<< HEAD
++=======
+ 
+ 	pref_zc = NULL;
+ 	pref_zq = NULL;
+ 	spin_lock(&zcrypt_list_lock);
+ 	for_each_zcrypt_card(zc) {
+ 		/* Check for online CCA cards */
+ 		if (!zc->online || !(zc->card->functions & 0x10000000))
+ 			continue;
+ 		/* get weight index of the card device	*/
+ 		weight = zc->speed_rating[func_code];
+ 		if (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))
+ 			continue;
+ 		for_each_zcrypt_queue(zq, zc) {
+ 			/* check if device is online and eligible */
+ 			if (!zq->online)
+ 				continue;
+ 			if (zcrypt_queue_compare(zq, pref_zq,
+ 						 weight, pref_weight))
+ 				continue;
+ 			pref_zc = zc;
+ 			pref_zq = zq;
+ 			pref_weight = weight;
+ 		}
++>>>>>>> e47de21dd35b (s390/zcrypt: Fixed attrition of AP adapters and domains)
  	}
 -	pref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -
 -	if (!pref_zq)
 -		return -ENODEV;
 -
 -	rc = pref_zq->ops->rng(pref_zq, buffer, &ap_msg);
 -
 -	spin_lock(&zcrypt_list_lock);
 -	zcrypt_drop_queue(pref_zc, pref_zq, weight);
 -	spin_unlock(&zcrypt_list_lock);
 -	return rc;
 +	spin_unlock_bh(&zcrypt_device_lock);
 +	return -ENODEV;
  }
  
  static void zcrypt_device_status_mask(struct zcrypt_device_matrix *matrix)
* Unmerged path drivers/s390/crypto/ap_card.c
* Unmerged path drivers/s390/crypto/ap_queue.c
* Unmerged path drivers/s390/crypto/ap_bus.h
* Unmerged path drivers/s390/crypto/ap_card.c
* Unmerged path drivers/s390/crypto/ap_queue.c
* Unmerged path drivers/s390/crypto/zcrypt_api.c
