i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stefan Assmann <sassmann@kpanic.de>
commit fbb113f773482496d601e0bd934e680b35876016
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fbb113f7.failed

The current name of vf_offload_flags indicates that the bitmap is
limited to offload related features. Make this more generic by renaming
it to vf_cap_flags, which allows for other capabilities besides
offloading to be added.

	Signed-off-by: Stefan Assmann <sassmann@kpanic.de>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit fbb113f773482496d601e0bd934e680b35876016)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
#	drivers/net/ethernet/intel/i40evf/i40e_common.c
#	drivers/net/ethernet/intel/i40evf/i40evf.h
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
#	include/linux/avf/virtchnl.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index f469a3d68beb,057c77be96e4..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1422,45 -1521,48 +1422,83 @@@ static int i40e_vc_get_vf_resources_msg
  		len = 0;
  		goto err;
  	}
 -	if (VF_IS_V11(&vf->vf_ver))
 +	if (VF_IS_V11(vf))
  		vf->driver_caps = *(u32 *)msg;
  	else
 -		vf->driver_caps = VIRTCHNL_VF_OFFLOAD_L2 |
 -				  VIRTCHNL_VF_OFFLOAD_RSS_REG |
 -				  VIRTCHNL_VF_OFFLOAD_VLAN;
 +		vf->driver_caps = I40E_VIRTCHNL_VF_OFFLOAD_L2 |
 +				  I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG |
 +				  I40E_VIRTCHNL_VF_OFFLOAD_VLAN;
 +
++<<<<<<< HEAD
 +	vfres->vf_offload_flags = I40E_VIRTCHNL_VF_OFFLOAD_L2;
 +	vsi = pf->vsi[vf->lan_vsi_idx];
 +	if (!vsi->info.pvid)
 +		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_VLAN;
 +
 +	if (i40e_vf_client_capable(pf, vf->vf_id) &&
 +	    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_IWARP)) {
 +		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_IWARP;
 +		set_bit(I40E_VF_STATE_IWARPENA, &vf->vf_states);
 +	} else {
 +		clear_bit(I40E_VF_STATE_IWARPENA, &vf->vf_states);
 +	}
  
 +	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF) {
 +		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF;
 +	} else {
 +		if ((pf->flags & I40E_FLAG_RSS_AQ_CAPABLE) &&
 +		    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ))
 +			vfres->vf_offload_flags |=
 +					I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ;
 +		else
 +			vfres->vf_offload_flags |=
 +					I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG;
 +	}
 +
 +	if (pf->flags & I40E_FLAG_MULTIPLE_TCP_UDP_RSS_PCTYPE) {
 +		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
 +			vfres->vf_offload_flags |=
 +				I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
 +	}
 +
 +	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING) {
++=======
+ 	vfres->vf_cap_flags = VIRTCHNL_VF_OFFLOAD_L2;
+ 	vsi = pf->vsi[vf->lan_vsi_idx];
+ 	if (!vsi->info.pvid)
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_VLAN;
+ 
+ 	if (i40e_vf_client_capable(pf, vf->vf_id) &&
+ 	    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_IWARP)) {
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_IWARP;
+ 		set_bit(I40E_VF_STATE_IWARPENA, &vf->vf_states);
+ 	}
+ 
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PF) {
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_PF;
+ 	} else {
+ 		if ((pf->hw_features & I40E_HW_RSS_AQ_CAPABLE) &&
+ 		    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_AQ))
+ 			vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_AQ;
+ 		else
+ 			vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RSS_REG;
+ 	}
+ 
+ 	if (pf->hw_features & I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE) {
+ 		if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
+ 			vfres->vf_cap_flags |=
+ 				VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
+ 	}
+ 
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP)
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP;
+ 
+ 	if ((pf->hw_features & I40E_HW_OUTER_UDP_CSUM_CAPABLE) &&
+ 	    (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;
+ 
+ 	if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_RX_POLLING) {
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  		if (pf->flags & I40E_FLAG_MFP_ENABLED) {
  			dev_err(&pf->pdev->dev,
  				"VF %d requested polling mode: this feature is supported only when the device is running in single function per port (SFP) mode\n",
@@@ -1468,13 -1570,13 +1506,23 @@@
  			aq_ret = I40E_ERR_PARAM;
  			goto err;
  		}
++<<<<<<< HEAD
 +		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING;
 +	}
 +
 +	if (pf->flags & I40E_FLAG_WB_ON_ITR_CAPABLE) {
 +		if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
 +			vfres->vf_offload_flags |=
 +					I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;
++=======
+ 		vfres->vf_cap_flags |= VIRTCHNL_VF_OFFLOAD_RX_POLLING;
+ 	}
+ 
+ 	if (pf->hw_features & I40E_HW_WB_ON_ITR_CAPABLE) {
+ 		if (vf->driver_caps & VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
+ 			vfres->vf_cap_flags |=
+ 					VIRTCHNL_VF_OFFLOAD_WB_ON_ITR;
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  	}
  
  	vfres->num_vsis = num_vsis;
diff --cc drivers/net/ethernet/intel/i40evf/i40e_common.c
index 3eef86cde05e,d69c2e44cd1a..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_common.c
@@@ -1172,11 -1104,11 +1172,16 @@@ void i40e_vf_parse_hw_config(struct i40
  	hw->dev_caps.num_rx_qp = msg->num_queue_pairs;
  	hw->dev_caps.num_tx_qp = msg->num_queue_pairs;
  	hw->dev_caps.num_msix_vectors_vf = msg->max_vectors;
++<<<<<<< HEAD
 +	hw->dev_caps.dcb = msg->vf_offload_flags &
 +			   I40E_VIRTCHNL_VF_OFFLOAD_L2;
++=======
+ 	hw->dev_caps.dcb = msg->vf_cap_flags &
+ 			   VIRTCHNL_VF_OFFLOAD_L2;
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  	hw->dev_caps.fcoe = 0;
  	for (i = 0; i < msg->num_vsis; i++) {
 -		if (vsi_res->vsi_type == VIRTCHNL_VSI_SRIOV) {
 +		if (vsi_res->vsi_type == I40E_VSI_SRIOV) {
  			ether_addr_copy(hw->mac.perm_addr,
  					vsi_res->default_mac_addr);
  			ether_addr_copy(hw->mac.addr,
diff --cc drivers/net/ethernet/intel/i40evf/i40evf.h
index 9b6fa8fbd0a9,d310544c6c6e..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@@ -275,26 -274,26 +275,46 @@@ struct i40evf_adapter 
  	struct work_struct watchdog_task;
  	bool netdev_registered;
  	bool link_up;
 -	enum virtchnl_link_speed link_speed;
 -	enum virtchnl_ops current_op;
 +	enum i40e_aq_link_speed link_speed;
 +	enum i40e_virtchnl_ops current_op;
  #define CLIENT_ALLOWED(_a) ((_a)->vf_res ? \
++<<<<<<< HEAD
 +			    (_a)->vf_res->vf_offload_flags & \
 +				I40E_VIRTCHNL_VF_OFFLOAD_IWARP : \
 +			    0)
 +#define CLIENT_ENABLED(_a) ((_a)->cinst)
 +/* RSS by the PF should be preferred over RSS via other methods. */
 +#define RSS_PF(_a) ((_a)->vf_res->vf_offload_flags & \
 +		    I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF)
 +#define RSS_AQ(_a) ((_a)->vf_res->vf_offload_flags & \
 +		    I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ)
 +#define RSS_REG(_a) (!((_a)->vf_res->vf_offload_flags & \
 +		       (I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ | \
 +			I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF)))
 +#define VLAN_ALLOWED(_a) ((_a)->vf_res->vf_offload_flags & \
 +			  I40E_VIRTCHNL_VF_OFFLOAD_VLAN)
 +	struct i40e_virtchnl_vf_resource *vf_res; /* incl. all VSIs */
 +	struct i40e_virtchnl_vsi_resource *vsi_res; /* our LAN VSI */
 +	struct i40e_virtchnl_version_info pf_version;
++=======
+ 			    (_a)->vf_res->vf_cap_flags & \
+ 				VIRTCHNL_VF_OFFLOAD_IWARP : \
+ 			    0)
+ #define CLIENT_ENABLED(_a) ((_a)->cinst)
+ /* RSS by the PF should be preferred over RSS via other methods. */
+ #define RSS_PF(_a) ((_a)->vf_res->vf_cap_flags & \
+ 		    VIRTCHNL_VF_OFFLOAD_RSS_PF)
+ #define RSS_AQ(_a) ((_a)->vf_res->vf_cap_flags & \
+ 		    VIRTCHNL_VF_OFFLOAD_RSS_AQ)
+ #define RSS_REG(_a) (!((_a)->vf_res->vf_cap_flags & \
+ 		       (VIRTCHNL_VF_OFFLOAD_RSS_AQ | \
+ 			VIRTCHNL_VF_OFFLOAD_RSS_PF)))
+ #define VLAN_ALLOWED(_a) ((_a)->vf_res->vf_cap_flags & \
+ 			  VIRTCHNL_VF_OFFLOAD_VLAN)
+ 	struct virtchnl_vf_resource *vf_res; /* incl. all VSIs */
+ 	struct virtchnl_vsi_resource *vsi_res; /* our LAN VSI */
+ 	struct virtchnl_version_info pf_version;
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  #define PF_IS_V11(_a) (((_a)->pf_version.major == 1) && \
  		       ((_a)->pf_version.minor == 1))
  	u16 msg_enable;
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index f8dfa5667a70,4a36c2ee3837..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -1366,8 -1418,8 +1366,13 @@@ static int i40evf_init_rss(struct i40ev
  
  	if (!RSS_PF(adapter)) {
  		/* Enable PCTYPES for RSS, TCP/UDP with IPv4/IPv6 */
++<<<<<<< HEAD
 +		if (adapter->vf_res->vf_offload_flags &
 +		    I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
++=======
+ 		if (adapter->vf_res->vf_cap_flags &
+ 		    VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  			adapter->hena = I40E_DEFAULT_RSS_HENA_EXPANDED;
  		else
  			adapter->hena = I40E_DEFAULT_RSS_HENA;
@@@ -2323,7 -2371,7 +2328,11 @@@ static netdev_features_t i40evf_fix_fea
  	struct i40evf_adapter *adapter = netdev_priv(netdev);
  
  	features &= ~I40EVF_VLAN_FEATURES;
++<<<<<<< HEAD
 +	if (adapter->vf_res->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_VLAN)
++=======
+ 	if (adapter->vf_res->vf_cap_flags & VIRTCHNL_VF_OFFLOAD_VLAN)
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  		features |= I40EVF_VLAN_FEATURES;
  	return features;
  }
@@@ -2392,46 -2442,52 +2401,74 @@@ int i40evf_process_config(struct i40evf
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	netdev->hw_enc_features |= NETIF_F_SG			|
 +				   NETIF_F_IP_CSUM		|
 +				   NETIF_F_IPV6_CSUM		|
 +				   NETIF_F_HIGHDMA		|
 +				   NETIF_F_SOFT_FEATURES	|
 +				   NETIF_F_TSO			|
 +				   NETIF_F_TSO_ECN		|
 +				   NETIF_F_TSO6			|
++=======
+ 	hw_enc_features = NETIF_F_SG			|
+ 			  NETIF_F_IP_CSUM		|
+ 			  NETIF_F_IPV6_CSUM		|
+ 			  NETIF_F_HIGHDMA		|
+ 			  NETIF_F_SOFT_FEATURES	|
+ 			  NETIF_F_TSO			|
+ 			  NETIF_F_TSO_ECN		|
+ 			  NETIF_F_TSO6			|
+ 			  NETIF_F_SCTP_CRC		|
+ 			  NETIF_F_RXHASH		|
+ 			  NETIF_F_RXCSUM		|
+ 			  0;
+ 
+ 	/* advertise to stack only if offloads for encapsulated packets is
+ 	 * supported
+ 	 */
+ 	if (vfres->vf_cap_flags & VIRTCHNL_VF_OFFLOAD_ENCAP) {
+ 		hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL	|
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  				   NETIF_F_GSO_GRE		|
  				   NETIF_F_GSO_GRE_CSUM		|
 -				   NETIF_F_GSO_IPXIP4		|
 -				   NETIF_F_GSO_IPXIP6		|
 +				   NETIF_F_GSO_IPIP		|
 +				   NETIF_F_GSO_SIT		|
 +				   NETIF_F_GSO_UDP_TUNNEL	|
  				   NETIF_F_GSO_UDP_TUNNEL_CSUM	|
  				   NETIF_F_GSO_PARTIAL		|
 +				   NETIF_F_SCTP_CRC		|
 +				   NETIF_F_RXHASH		|
 +				   NETIF_F_RXCSUM		|
  				   0;
  
++<<<<<<< HEAD
 +	if (!(adapter->flags & I40EVF_FLAG_OUTER_UDP_CSUM_CAPABLE))
 +		netdev->gso_partial_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;
 +
 +	netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
++=======
+ 		if (!(vfres->vf_cap_flags &
+ 		      VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
+ 			netdev->gso_partial_features |=
+ 				NETIF_F_GSO_UDP_TUNNEL_CSUM;
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  
 -		netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
 -		netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
 -		netdev->hw_enc_features |= hw_enc_features;
 -	}
  	/* record features VLANs can make use of */
 -	netdev->vlan_features |= hw_enc_features | NETIF_F_TSO_MANGLEID;
 +	netdev->vlan_features |= netdev->hw_enc_features |
 +				 NETIF_F_TSO_MANGLEID;
  
  	/* Write features and hw_features separately to avoid polluting
 -	 * with, or dropping, features that are set when we registered.
 +	 * with, or dropping, features that are set when we registgered.
  	 */
 -	hw_features = hw_enc_features;
 +	netdev->hw_features |= netdev->hw_enc_features;
  
 -	netdev->hw_features |= hw_features;
 +	netdev->features |= netdev->hw_enc_features | I40EVF_VLAN_FEATURES;
 +	netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
  
 -	netdev->features |= hw_features | I40EVF_VLAN_FEATURES;
 +	/* disable VLAN features if not supported */
 +	if (!(vfres->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_VLAN))
 +		netdev->features ^= I40EVF_VLAN_FEATURES;
  
  	adapter->vsi.id = adapter->vsi_res->vsi_id;
  
@@@ -2440,7 -2496,7 +2477,11 @@@
  	adapter->vsi.work_limit = I40E_DEFAULT_IRQ_WORK;
  	vsi->netdev = adapter->netdev;
  	vsi->qs_handle = adapter->vsi_res->qset_handle;
++<<<<<<< HEAD
 +	if (vfres->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF) {
++=======
+ 	if (vfres->vf_cap_flags & VIRTCHNL_VF_OFFLOAD_RSS_PF) {
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  		adapter->rss_key_size = vfres->rss_key_size;
  		adapter->rss_lut_size = vfres->rss_lut_size;
  	} else {
@@@ -2607,8 -2664,8 +2648,13 @@@ static void i40evf_init_task(struct wor
  	if (err)
  		goto err_sw_init;
  	i40evf_map_rings_to_vectors(adapter);
++<<<<<<< HEAD
 +	if (adapter->vf_res->vf_offload_flags &
 +	    I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
++=======
+ 	if (adapter->vf_res->vf_cap_flags &
+ 	    VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
++>>>>>>> fbb113f77348 (i40e/i40evf: rename vf_offload_flags to vf_cap_flags in struct virtchnl_vf_resource)
  		adapter->flags |= I40EVF_FLAG_WB_ON_ITR_CAPABLE;
  
  	err = i40evf_request_misc_irq(adapter);
* Unmerged path include/linux/avf/virtchnl.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_common.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
* Unmerged path include/linux/avf/virtchnl.h
