net/mlx5e: Use short attribute form when adding/deleting offloaded TC flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Use short attribute form when adding/deleting offloaded TC flows (Kamal Heib) [1456687 1456694]
Rebuild_FUZZ: 97.26%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 513f8f7fc049361976062c770a1ffb43b01c73d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/513f8f7f.failed

Instead of going through flow->nic/esw_attr for each usage, assign
an attr pointer per the context (nic or esw) and use that.

This patch doesn't add any functionality.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 513f8f7fc049361976062c770a1ffb43b01c73d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 073b0fc8f526,a9feddc31667..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -165,6 -188,10 +166,13 @@@ static void mlx5e_tc_del_nic_flow(struc
  		mlx5_destroy_flow_table(priv->fs.tc.t);
  		priv->fs.tc.t = NULL;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
+ 		mlx5_modify_header_dealloc(priv->mdev,
+ 					   attr->mod_hdr_id);
++>>>>>>> 513f8f7fc049 (net/mlx5e: Use short attribute form when adding/deleting offloaded TC flows)
  }
  
  static void mlx5e_detach_encap(struct mlx5e_priv *priv,
@@@ -193,6 -232,10 +201,13 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  	return rule;
  
  err_add_rule:
++<<<<<<< HEAD
++=======
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
+ 		mlx5_modify_header_dealloc(priv->mdev,
+ 					   attr->mod_hdr_id);
+ err_mod_hdr:
++>>>>>>> 513f8f7fc049 (net/mlx5e: Use short attribute form when adding/deleting offloaded TC flows)
  	mlx5_eswitch_del_vlan_action(esw, attr);
  err_add_vlan:
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
@@@ -205,14 -247,128 +220,137 @@@ static void mlx5e_tc_del_fdb_flow(struc
  				  struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  
++<<<<<<< HEAD
 +	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED)
 +		mlx5_eswitch_del_offloaded_rule(esw, flow->rule, flow->esw_attr);
++=======
+ 	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 		flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
+ 		mlx5_eswitch_del_offloaded_rule(esw, flow->rule, attr);
+ 	}
++>>>>>>> 513f8f7fc049 (net/mlx5e: Use short attribute form when adding/deleting offloaded TC flows)
  
- 	mlx5_eswitch_del_vlan_action(esw, flow->esw_attr);
+ 	mlx5_eswitch_del_vlan_action(esw, attr);
  
++<<<<<<< HEAD
 +	if (flow->esw_attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
 +		mlx5e_detach_encap(priv, flow);
++=======
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP) {
+ 		mlx5e_detach_encap(priv, flow);
+ 		kvfree(attr->parse_attr);
+ 	}
+ 
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
+ 		mlx5_modify_header_dealloc(priv->mdev,
+ 					   attr->mod_hdr_id);
+ }
+ 
+ void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
+ 			      struct mlx5e_encap_entry *e)
+ {
+ 	struct mlx5e_tc_flow *flow;
+ 	int err;
+ 
+ 	err = mlx5_encap_alloc(priv->mdev, e->tunnel_type,
+ 			       e->encap_size, e->encap_header,
+ 			       &e->encap_id);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "Failed to offload cached encapsulation header, %d\n",
+ 			       err);
+ 		return;
+ 	}
+ 	e->flags |= MLX5_ENCAP_ENTRY_VALID;
+ 	mlx5e_rep_queue_neigh_stats_work(priv);
+ 
+ 	list_for_each_entry(flow, &e->flows, encap) {
+ 		flow->esw_attr->encap_id = e->encap_id;
+ 		flow->rule = mlx5e_tc_add_fdb_flow(priv,
+ 						   flow->esw_attr->parse_attr,
+ 						   flow);
+ 		if (IS_ERR(flow->rule)) {
+ 			err = PTR_ERR(flow->rule);
+ 			mlx5_core_warn(priv->mdev, "Failed to update cached encapsulation flow, %d\n",
+ 				       err);
+ 			continue;
+ 		}
+ 		flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
+ 	}
+ }
+ 
+ void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
+ 			      struct mlx5e_encap_entry *e)
+ {
+ 	struct mlx5e_tc_flow *flow;
+ 	struct mlx5_fc *counter;
+ 
+ 	list_for_each_entry(flow, &e->flows, encap) {
+ 		if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 			flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
+ 			counter = mlx5_flow_rule_counter(flow->rule);
+ 			mlx5_del_flow_rules(flow->rule);
+ 			mlx5_fc_destroy(priv->mdev, counter);
+ 		}
+ 	}
+ 
+ 	if (e->flags & MLX5_ENCAP_ENTRY_VALID) {
+ 		e->flags &= ~MLX5_ENCAP_ENTRY_VALID;
+ 		mlx5_encap_dealloc(priv->mdev, e->encap_id);
+ 	}
+ }
+ 
+ void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe)
+ {
+ 	struct mlx5e_neigh *m_neigh = &nhe->m_neigh;
+ 	u64 bytes, packets, lastuse = 0;
+ 	struct mlx5e_tc_flow *flow;
+ 	struct mlx5e_encap_entry *e;
+ 	struct mlx5_fc *counter;
+ 	struct neigh_table *tbl;
+ 	bool neigh_used = false;
+ 	struct neighbour *n;
+ 
+ 	if (m_neigh->family == AF_INET)
+ 		tbl = &arp_tbl;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (m_neigh->family == AF_INET6)
+ 		tbl = ipv6_stub->nd_tbl;
+ #endif
+ 	else
+ 		return;
+ 
+ 	list_for_each_entry(e, &nhe->encap_list, encap_list) {
+ 		if (!(e->flags & MLX5_ENCAP_ENTRY_VALID))
+ 			continue;
+ 		list_for_each_entry(flow, &e->flows, encap) {
+ 			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 				counter = mlx5_flow_rule_counter(flow->rule);
+ 				mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
+ 				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
+ 					neigh_used = true;
+ 					break;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	if (neigh_used) {
+ 		nhe->reported_lastuse = jiffies;
+ 
+ 		/* find the relevant neigh according to the cached device and
+ 		 * dst ip pair
+ 		 */
+ 		n = neigh_lookup(tbl, &m_neigh->dst_ip, m_neigh->dev);
+ 		if (!n) {
+ 			WARN(1, "The neighbour already freed\n");
+ 			return;
+ 		}
+ 
+ 		neigh_event_send(n, NULL);
+ 		neigh_release(n);
+ 	}
++>>>>>>> 513f8f7fc049 (net/mlx5e: Use short attribute form when adding/deleting offloaded TC flows)
  }
  
  static void mlx5e_detach_encap(struct mlx5e_priv *priv,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
