ovl: persistent inode number for directories

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit b7a807dc2010334e62e0afd89d6f7a8913eb14ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b7a807dc.failed

stat(2) on overlay directories reports the overlay temp inode
number, which is constant across copy up, but is not persistent.

When all layers are on the same fs, report the copy up origin inode
number for directories.

This inode number is persistent, unique across the overlay mount and
constant across copy up.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit b7a807dc2010334e62e0afd89d6f7a8913eb14ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
diff --cc fs/overlayfs/dir.c
index c82fdefe6d3b,0c5e79966957..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -136,13 -149,40 +136,45 @@@ static int ovl_dir_getattr(struct vfsmo
  
  	type = ovl_path_real(dentry, &realpath);
  	old_cred = ovl_override_creds(dentry->d_sb);
++<<<<<<< HEAD
 +	err = vfs_getattr(&realpath, stat);
 +	revert_creds(old_cred);
++=======
+ 	err = vfs_getattr(&realpath, stat, request_mask, flags);
++>>>>>>> b7a807dc2010 (ovl: persistent inode number for directories)
  	if (err)
- 		return err;
+ 		goto out;
  
+ 	/*
+ 	 * When all layers are on the same fs, use the copy-up-origin st_ino,
+ 	 * which is persistent, unique and constant across copy up.
+ 	 *
+ 	 * Otherwise the pair {real st_ino; overlay st_dev} is not unique, so
+ 	 * use the non persistent overlay st_ino.
+ 	 */
+ 	if (ovl_same_sb(dentry->d_sb)) {
+ 		if (OVL_TYPE_ORIGIN(type)) {
+ 			struct kstat lowerstat;
+ 
+ 			ovl_path_lower(dentry, &realpath);
+ 			err = vfs_getattr(&realpath, &lowerstat,
+ 					  STATX_INO, flags);
+ 			if (err)
+ 				goto out;
+ 
+ 			WARN_ON_ONCE(stat->dev != lowerstat.dev);
+ 			stat->ino = lowerstat.ino;
+ 		}
+ 	} else {
+ 		stat->ino = dentry->d_inode->i_ino;
+ 	}
+ 
+ 	/*
+ 	 * Always use the overlay st_dev for directories, so 'find -xdev' will
+ 	 * scan the entire overlay mount and won't cross the overlay mount
+ 	 * boundaries.
+ 	 */
  	stat->dev = dentry->d_sb->s_dev;
- 	stat->ino = dentry->d_inode->i_ino;
  
  	/*
  	 * It's probably not worth it to count subdirs to get the
* Unmerged path fs/overlayfs/dir.c
