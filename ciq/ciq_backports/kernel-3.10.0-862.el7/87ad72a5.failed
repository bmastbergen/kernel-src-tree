nvme-pci: implement host memory buffer support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] pci: implement host memory buffer support (David Milburn) [1454365 1456486 1457880]
Rebuild_FUZZ: 94.25%
commit-author Christoph Hellwig <hch@lst.de>
commit 87ad72a59a38d1df217cfd95bc222a2edfe5d399
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/87ad72a5.failed

If a controller supports the host memory buffer we try to provide
it with the requested size up to an upper cap set as a module
parameter.  We try to give as few as possible descriptors, eventually
working our way down.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
(cherry picked from commit 87ad72a59a38d1df217cfd95bc222a2edfe5d399)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index f136fc3284bb,73d9b412f291..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -101,8 -109,30 +106,23 @@@ struct nvme_dev 
  	u32 cmbloc;
  	struct nvme_ctrl ctrl;
  	struct completion ioq_wait;
++<<<<<<< HEAD
++=======
+ 
+ 	/* shadow doorbell buffer support: */
+ 	u32 *dbbuf_dbs;
+ 	dma_addr_t dbbuf_dbs_dma_addr;
+ 	u32 *dbbuf_eis;
+ 	dma_addr_t dbbuf_eis_dma_addr;
+ 
+ 	/* host memory buffer support: */
+ 	u64 host_mem_size;
+ 	u32 nr_host_mem_descs;
+ 	struct nvme_host_mem_buf_desc *host_mem_descs;
+ 	void **host_mem_desc_bufs;
++>>>>>>> 87ad72a59a38 (nvme-pci: implement host memory buffer support)
  };
  
 -static inline unsigned int sq_idx(unsigned int qid, u32 stride)
 -{
 -	return qid * 2 * stride;
 -}
 -
 -static inline unsigned int cq_idx(unsigned int qid, u32 stride)
 -{
 -	return (qid * 2 + 1) * stride;
 -}
 -
  static inline struct nvme_dev *to_nvme_dev(struct nvme_ctrl *ctrl)
  {
  	return container_of(ctrl, struct nvme_dev, ctrl);
@@@ -1708,6 -2109,27 +1896,30 @@@ static void nvme_reset_work(struct work
  	if (result)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (dev->ctrl.oacs & NVME_CTRL_OACS_SEC_SUPP) {
+ 		if (!dev->ctrl.opal_dev)
+ 			dev->ctrl.opal_dev =
+ 				init_opal_dev(&dev->ctrl, &nvme_sec_submit);
+ 		else if (was_suspend)
+ 			opal_unlock_from_suspend(dev->ctrl.opal_dev);
+ 	} else {
+ 		free_opal_dev(dev->ctrl.opal_dev);
+ 		dev->ctrl.opal_dev = NULL;
+ 	}
+ 
+ 	if (dev->ctrl.oacs & NVME_CTRL_OACS_DBBUF_SUPP) {
+ 		result = nvme_dbbuf_dma_alloc(dev);
+ 		if (result)
+ 			dev_warn(dev->dev,
+ 				 "unable to allocate dma for dbbuf\n");
+ 	}
+ 
+ 	if (dev->ctrl.hmpre)
+ 		nvme_setup_host_mem(dev);
+ 
++>>>>>>> 87ad72a59a38 (nvme-pci: implement host memory buffer support)
  	result = nvme_setup_io_queues(dev);
  	if (result)
  		goto out;
@@@ -1928,7 -2370,7 +2140,11 @@@ static void nvme_remove(struct pci_dev 
  	flush_work(&dev->reset_work);
  	nvme_uninit_ctrl(&dev->ctrl);
  	nvme_dev_disable(dev, true);
++<<<<<<< HEAD
 +	flush_work(&dev->reset_work);
++=======
+ 	nvme_free_host_mem(dev);
++>>>>>>> 87ad72a59a38 (nvme-pci: implement host memory buffer support)
  	nvme_dev_remove_admin(dev);
  	nvme_free_queues(dev, 0);
  	nvme_release_prp_pools(dev);
* Unmerged path drivers/nvme/host/pci.c
