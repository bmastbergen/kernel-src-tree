vfs: introduce inode 'inuse' lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit ad0af7104dadccd55cd2b390271677fac142650f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ad0af710.failed

Added an i_state flag I_INUSE and helpers to set/clear/test the bit.

The 'inuse' lock is an 'advisory' inode lock, that can be used to extend
exclusive create protection beyond parent->i_mutex lock among cooperating
users.

This is going to be used by overlayfs to get exclusive ownership on upper
and work dirs among overlayfs mounts.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit ad0af7104dadccd55cd2b390271677fac142650f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/util.c
#	include/linux/fs.h
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,5e958427463d..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -193,46 +151,63 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 -struct inode *ovl_inode_upper(struct inode *inode);
 -struct inode *ovl_inode_lower(struct inode *inode);
 -struct inode *ovl_inode_real(struct inode *inode);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+ 		    struct dentry *lowerdentry);
+ void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+ 		       const char *name, const void *value, size_t size,
+ 		       int xerr);
+ int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_set_flag(unsigned long flag, struct inode *inode);
+ bool ovl_test_flag(unsigned long flag, struct inode *inode);
+ bool ovl_inuse_trylock(struct dentry *dentry);
+ void ovl_inuse_unlock(struct dentry *dentry);
+ 
+ static inline bool ovl_is_impuredir(struct dentry *dentry)
+ {
+ 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+ }
+ 
+ 
+ /* namei.c */
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> ad0af7104dad (vfs: introduce inode 'inuse' lock)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
diff --cc include/linux/fs.h
index 4086333a0708,75a5fafaf096..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2007,6 -1925,14 +2007,17 @@@ struct super_operations 
   *
   * I_DIO_WAKEUP		Never set.  Only used as a key for wait_on_bit().
   *
++<<<<<<< HEAD
++=======
+  * I_WB_SWITCH		Cgroup bdi_writeback switching in progress.  Used to
+  *			synchronize competing switching instances and to tell
+  *			wb stat updates to grab mapping->tree_lock.  See
+  *			inode_switch_wb_work_fn() for details.
+  *
+  * I_OVL_INUSE		Used by overlayfs to get exclusive ownership on upper
+  *			and work dirs among overlayfs mounts.
+  *
++>>>>>>> ad0af7104dad (vfs: introduce inode 'inuse' lock)
   * Q: What is the difference between I_WILL_FREE and I_FREEING?
   */
  #define I_DIRTY_SYNC		(1 << 0)
@@@ -2021,10 -1947,16 +2032,18 @@@
  #define I_SYNC			(1 << __I_SYNC)
  #define I_REFERENCED		(1 << 8)
  #define __I_DIO_WAKEUP		9
 -#define I_DIO_WAKEUP		(1 << __I_DIO_WAKEUP)
 +#define I_DIO_WAKEUP		(1 << I_DIO_WAKEUP)
  #define I_LINKABLE		(1 << 10)
++<<<<<<< HEAD
++=======
+ #define I_DIRTY_TIME		(1 << 11)
+ #define __I_DIRTY_TIME_EXPIRED	12
+ #define I_DIRTY_TIME_EXPIRED	(1 << __I_DIRTY_TIME_EXPIRED)
+ #define I_WB_SWITCH		(1 << 13)
+ #define I_OVL_INUSE			(1 << 14)
++>>>>>>> ad0af7104dad (vfs: introduce inode 'inuse' lock)
  
  #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 -#define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)
  
  extern void __mark_inode_dirty(struct inode *, int);
  static inline void mark_inode_dirty(struct inode *inode)
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/util.c
* Unmerged path include/linux/fs.h
