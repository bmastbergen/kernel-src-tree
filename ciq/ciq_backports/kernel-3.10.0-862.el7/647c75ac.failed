RDMA/netlink: Convert LS to doit callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Leon Romanovsky <leonro@mellanox.com>
commit 647c75ac59a48a54dafd4475d14a645a0025a4f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/647c75ac.failed

RDMA_NL_LS protocol is actually does not dump anything,
but sets data and it should be handled by doit callback.

This patch actually converts RDMA_NL_LS to doit callback, while
preserving IWCM and RDMA_CM flows through netlink_dump_start().

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
(cherry picked from commit 647c75ac59a48a54dafd4475d14a645a0025a4f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/device.c
#	drivers/infiniband/core/netlink.c
diff --cc drivers/infiniband/core/device.c
index a4559eda966e,5272c3806c39..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -997,29 -1146,21 +997,43 @@@ struct net_device *ib_get_net_dev_by_pa
  }
  EXPORT_SYMBOL(ib_get_net_dev_by_params);
  
 -static const struct rdma_nl_cbs ibnl_ls_cb_table[] = {
 +static struct ibnl_client_cbs ibnl_ls_cb_table[] = {
  	[RDMA_NL_LS_OP_RESOLVE] = {
++<<<<<<< HEAD
 +		.dump = ib_nl_handle_resolve_resp,
 +		.module = THIS_MODULE },
 +	[RDMA_NL_LS_OP_SET_TIMEOUT] = {
 +		.dump = ib_nl_handle_set_timeout,
 +		.module = THIS_MODULE },
 +	[RDMA_NL_LS_OP_IP_RESOLVE] = {
 +		.dump = ib_nl_handle_ip_res_resp,
 +		.module = THIS_MODULE },
++=======
+ 		.doit = ib_nl_handle_resolve_resp,
+ 		.flags = RDMA_NL_ADMIN_PERM,
+ 	},
+ 	[RDMA_NL_LS_OP_SET_TIMEOUT] = {
+ 		.doit = ib_nl_handle_set_timeout,
+ 		.flags = RDMA_NL_ADMIN_PERM,
+ 	},
+ 	[RDMA_NL_LS_OP_IP_RESOLVE] = {
+ 		.doit = ib_nl_handle_ip_res_resp,
+ 		.flags = RDMA_NL_ADMIN_PERM,
+ 	},
++>>>>>>> 647c75ac59a4 (RDMA/netlink: Convert LS to doit callback)
  };
  
 +static int ib_add_ibnl_clients(void)
 +{
 +	return ibnl_add_client(RDMA_NL_LS, ARRAY_SIZE(ibnl_ls_cb_table),
 +			       ibnl_ls_cb_table);
 +}
 +
 +static void ib_remove_ibnl_clients(void)
 +{
 +	ibnl_remove_client(RDMA_NL_LS);
 +}
 +
  static int __init ib_core_init(void)
  {
  	int ret;
diff --cc drivers/infiniband/core/netlink.c
index 66c3e82b1b77,145ad5343780..000000000000
--- a/drivers/infiniband/core/netlink.c
+++ b/drivers/infiniband/core/netlink.c
@@@ -131,71 -147,85 +131,95 @@@ int ibnl_put_attr(struct sk_buff *skb, 
  }
  EXPORT_SYMBOL(ibnl_put_attr);
  
 -static int rdma_nl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,
 -			   struct netlink_ext_ack *extack)
 +static int ibnl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
  {
 +	struct ibnl_client *client;
  	int type = nlh->nlmsg_type;
 -	unsigned int index = RDMA_NL_GET_CLIENT(type);
 +	int index = RDMA_NL_GET_CLIENT(type);
  	unsigned int op = RDMA_NL_GET_OP(type);
++<<<<<<< HEAD
++=======
+ 	const struct rdma_nl_cbs *cb_table;
 -
 -	if (!is_nl_valid(index, op))
 -		return -EINVAL;
 -
++>>>>>>> 647c75ac59a4 (RDMA/netlink: Convert LS to doit callback)
 +
 +	list_for_each_entry(client, &client_list, list) {
 +		if (client->index == index) {
 +			if (op >= client->nops || !client->cb_table[op].dump)
 +				return -EINVAL;
 +
++<<<<<<< HEAD
 +			/*
 +			 * For response or local service set_timeout request,
 +			 * there is no need to use netlink_dump_start.
 +			 */
 +			if (!(nlh->nlmsg_flags & NLM_F_REQUEST) ||
 +			    (index == RDMA_NL_LS &&
 +			     op == RDMA_NL_LS_OP_SET_TIMEOUT)) {
 +				struct netlink_callback cb = {
 +					.skb = skb,
 +					.nlh = nlh,
 +					.dump = client->cb_table[op].dump,
 +					.module = client->cb_table[op].module,
 +				};
++=======
+ 	cb_table = rdma_nl_types[index].cb_table;
++>>>>>>> 647c75ac59a4 (RDMA/netlink: Convert LS to doit callback)
 +
 +				return cb.dump(skb, &cb);
 +			}
 +
++<<<<<<< HEAD
 +			{
 +				struct netlink_dump_control c = {
 +					.dump = client->cb_table[op].dump,
 +					.module = client->cb_table[op].module,
 +				};
 +				return netlink_dump_start(nls, skb, nlh, &c);
 +			}
 +		}
 +	}
  
 -	if ((cb_table[op].flags & RDMA_NL_ADMIN_PERM) &&
 -	    !netlink_capable(skb, CAP_NET_ADMIN))
 -		return -EPERM;
 -
 +	pr_info("Index %d wasn't found in client list\n", index);
 +	return -EINVAL;
++=======
+ 	/* FIXME: Convert IWCM to properly handle doit callbacks */
+ 	if ((nlh->nlmsg_flags & NLM_F_DUMP) || index == RDMA_NL_RDMA_CM ||
+ 	    index == RDMA_NL_IWCM) {
+ 		struct netlink_dump_control c = {
+ 			.dump = cb_table[op].dump,
+ 		};
+ 		return netlink_dump_start(nls, skb, nlh, &c);
+ 	}
+ 
+ 	if (cb_table[op].doit)
+ 		return cb_table[op].doit(skb, nlh, extack);
+ 
+ 	return 0;
++>>>>>>> 647c75ac59a4 (RDMA/netlink: Convert LS to doit callback)
  }
  
 -/*
 - * This function is similar to netlink_rcv_skb with one exception:
 - * It calls to the callback for the netlink messages without NLM_F_REQUEST
 - * flag. These messages are intended for RDMA_NL_LS consumer, so it is allowed
 - * for that consumer only.
 - */
 -static int rdma_nl_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,
 -						   struct nlmsghdr *,
 -						   struct netlink_ext_ack *))
 +static void ibnl_rcv_reply_skb(struct sk_buff *skb)
  {
 -	struct netlink_ext_ack extack = {};
  	struct nlmsghdr *nlh;
 -	int err;
 +	int msglen;
  
 +	/*
 +	 * Process responses until there is no more message or the first
 +	 * request. Generally speaking, it is not recommended to mix responses
 +	 * with requests.
 +	 */
  	while (skb->len >= nlmsg_total_size(0)) {
 -		int msglen;
 -
  		nlh = nlmsg_hdr(skb);
 -		err = 0;
  
  		if (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)
 -			return 0;
 +			return;
 +
 +		/* Handle response only */
 +		if (nlh->nlmsg_flags & NLM_F_REQUEST)
 +			return;
 +
 +		ibnl_rcv_msg(skb, nlh);
  
 -		/*
 -		 * Generally speaking, the only requests are handled
 -		 * by the kernel, but RDMA_NL_LS is different, because it
 -		 * runs backward netlink scheme. Kernel initiates messages
 -		 * and waits for reply with data to keep pathrecord cache
 -		 * in sync.
 -		 */
 -		if (!(nlh->nlmsg_flags & NLM_F_REQUEST) &&
 -		    (RDMA_NL_GET_CLIENT(nlh->nlmsg_type) != RDMA_NL_LS))
 -			goto ack;
 -
 -		/* Skip control messages */
 -		if (nlh->nlmsg_type < NLMSG_MIN_TYPE)
 -			goto ack;
 -
 -		err = cb(skb, nlh, &extack);
 -		if (err == -EINTR)
 -			goto skip;
 -
 -ack:
 -		if (nlh->nlmsg_flags & NLM_F_ACK || err)
 -			netlink_ack(skb, nlh, err, &extack);
 -
 -skip:
  		msglen = NLMSG_ALIGN(nlh->nlmsg_len);
  		if (msglen > skb->len)
  			msglen = skb->len;
diff --git a/drivers/infiniband/core/addr.c b/drivers/infiniband/core/addr.c
index 27485694190c..9065f3434324 100644
--- a/drivers/infiniband/core/addr.c
+++ b/drivers/infiniband/core/addr.c
@@ -130,10 +130,9 @@ static void ib_nl_process_good_ip_rsep(const struct nlmsghdr *nlh)
 }
 
 int ib_nl_handle_ip_res_resp(struct sk_buff *skb,
-			     struct netlink_callback *cb)
+			     struct nlmsghdr *nlh,
+			     struct netlink_ext_ack *extack)
 {
-	const struct nlmsghdr *nlh = (struct nlmsghdr *)cb->nlh;
-
 	if ((nlh->nlmsg_flags & NLM_F_REQUEST) ||
 	    !(NETLINK_CB(skb).sk) ||
 	    !netlink_capable(skb, CAP_NET_ADMIN))
diff --git a/drivers/infiniband/core/core_priv.h b/drivers/infiniband/core/core_priv.h
index fb6b0ab22857..e7ddd1693103 100644
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@ -158,11 +158,14 @@ void ibnl_cleanup(void);
 int ibnl_chk_listeners(unsigned int group);
 
 int ib_nl_handle_resolve_resp(struct sk_buff *skb,
-			      struct netlink_callback *cb);
+			      struct nlmsghdr *nlh,
+			      struct netlink_ext_ack *extack);
 int ib_nl_handle_set_timeout(struct sk_buff *skb,
-			     struct netlink_callback *cb);
+			     struct nlmsghdr *nlh,
+			     struct netlink_ext_ack *extack);
 int ib_nl_handle_ip_res_resp(struct sk_buff *skb,
-			     struct netlink_callback *cb);
+			     struct nlmsghdr *nlh,
+			     struct netlink_ext_ack *extack);
 
 int ib_get_cached_subnet_prefix(struct ib_device *device,
 				u8                port_num,
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path drivers/infiniband/core/netlink.c
diff --git a/drivers/infiniband/core/sa_query.c b/drivers/infiniband/core/sa_query.c
index 2eb90b156b94..58cca3a92aa3 100644
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@ -791,9 +791,9 @@ static void ib_nl_request_timeout(struct work_struct *work)
 }
 
 int ib_nl_handle_set_timeout(struct sk_buff *skb,
-			     struct netlink_callback *cb)
+			     struct nlmsghdr *nlh,
+			     struct netlink_ext_ack *extack)
 {
-	const struct nlmsghdr *nlh = (struct nlmsghdr *)cb->nlh;
 	int timeout, delta, abs_delta;
 	const struct nlattr *attr;
 	unsigned long flags;
@@ -868,9 +868,9 @@ static inline int ib_nl_is_good_resolve_resp(const struct nlmsghdr *nlh)
 }
 
 int ib_nl_handle_resolve_resp(struct sk_buff *skb,
-			      struct netlink_callback *cb)
+			      struct nlmsghdr *nlh,
+			      struct netlink_ext_ack *extack)
 {
-	const struct nlmsghdr *nlh = (struct nlmsghdr *)cb->nlh;
 	unsigned long flags;
 	struct ib_sa_query *query;
 	struct ib_mad_send_buf *send_buf;
