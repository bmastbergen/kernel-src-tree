vxlan: correctly set vxlan->net when creating the device in a netns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 889ce937c98f1f969137a8a2ee78627c1537d4b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/889ce937.failed

Commit a985343ba906 ("vxlan: refactor verification and application of
configuration") modified vxlan device creation, and replaced the
assignment of vxlan->net to src_net with dev_net(netdev) in ->setup().

But dev_net(netdev) is not the same as src_net. At the time ->setup()
is called, dev_net hasn't been set yet, so we end up creating the
socket for the vxlan device in init_net.

Fix this by bringing back the assignment of vxlan->net during device
creation.

Fixes: a985343ba906 ("vxlan: refactor verification and application of configuration")
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Reviewed-by: Matthias Schiffer <mschiffer@universe-factory.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 889ce937c98f1f969137a8a2ee78627c1537d4b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 740e6d79f5f2,47d6e65851aa..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2804,16 -2914,140 +2804,74 @@@ static int vxlan_dev_configure(struct n
  		 */
  		if ((conf->flags & ~VXLAN_F_ALLOWED_GPE) ||
  		    !(conf->flags & VXLAN_F_COLLECT_METADATA)) {
 +			pr_info("unsupported combination of extensions\n");
  			return -EINVAL;
  		}
 -	}
 -
 -	if (!conf->remote_ip.sa.sa_family && !conf->saddr.sa.sa_family) {
 -		/* Unless IPv6 is explicitly requested, assume IPv4 */
 -		conf->remote_ip.sa.sa_family = AF_INET;
 -		conf->saddr.sa.sa_family = AF_INET;
 -	} else if (!conf->remote_ip.sa.sa_family) {
 -		conf->remote_ip.sa.sa_family = conf->saddr.sa.sa_family;
 -	} else if (!conf->saddr.sa.sa_family) {
 -		conf->saddr.sa.sa_family = conf->remote_ip.sa.sa_family;
 -	}
  
 -	if (conf->saddr.sa.sa_family != conf->remote_ip.sa.sa_family)
 -		return -EINVAL;
 -
 -	if (vxlan_addr_multicast(&conf->saddr))
 -		return -EINVAL;
 -
 -	if (conf->saddr.sa.sa_family == AF_INET6) {
 -		if (!IS_ENABLED(CONFIG_IPV6))
 -			return -EPFNOSUPPORT;
 -		use_ipv6 = true;
 -		conf->flags |= VXLAN_F_IPV6;
 -
 -		if (!(conf->flags & VXLAN_F_COLLECT_METADATA)) {
 -			int local_type =
 -				ipv6_addr_type(&conf->saddr.sin6.sin6_addr);
 -			int remote_type =
 -				ipv6_addr_type(&conf->remote_ip.sin6.sin6_addr);
 -
 -			if (local_type & IPV6_ADDR_LINKLOCAL) {
 -				if (!(remote_type & IPV6_ADDR_LINKLOCAL) &&
 -				    (remote_type != IPV6_ADDR_ANY))
 -					return -EINVAL;
 -
 -				conf->flags |= VXLAN_F_IPV6_LINKLOCAL;
 -			} else {
 -				if (remote_type ==
 -				    (IPV6_ADDR_UNICAST | IPV6_ADDR_LINKLOCAL))
 -					return -EINVAL;
 -
 -				conf->flags &= ~VXLAN_F_IPV6_LINKLOCAL;
 -			}
 -		}
 -	}
 -
 -	if (conf->label && !use_ipv6)
 -		return -EINVAL;
 -
 -	if (conf->remote_ifindex) {
 -		struct net_device *lowerdev;
 -
 -		lowerdev = __dev_get_by_index(src_net, conf->remote_ifindex);
 -		if (!lowerdev)
 -			return -ENODEV;
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -		if (use_ipv6) {
 -			struct inet6_dev *idev = __in6_dev_get(lowerdev);
 -			if (idev && idev->cnf.disable_ipv6)
 -				return -EPERM;
 -		}
 -#endif
 -
 -		*lower = lowerdev;
 +		vxlan_raw_setup(dev);
  	} else {
 -		if (vxlan_addr_multicast(&conf->remote_ip))
 -			return -EINVAL;
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -		if (conf->flags & VXLAN_F_IPV6_LINKLOCAL)
 -			return -EINVAL;
 -#endif
 -
 -		*lower = NULL;
 +		vxlan_ether_setup(dev);
  	}
  
++<<<<<<< HEAD
 +	vxlan->net = src_net;
++=======
+ 	if (!conf->dst_port) {
+ 		if (conf->flags & VXLAN_F_GPE)
+ 			conf->dst_port = htons(4790); /* IANA VXLAN-GPE port */
+ 		else
+ 			conf->dst_port = htons(vxlan_port);
+ 	}
+ 
+ 	if (!conf->age_interval)
+ 		conf->age_interval = FDB_AGE_DEFAULT;
+ 
+ 	list_for_each_entry(tmp, &vn->vxlan_list, next) {
+ 		if (tmp == old)
+ 			continue;
+ 
+ 		if (tmp->cfg.vni != conf->vni)
+ 			continue;
+ 		if (tmp->cfg.dst_port != conf->dst_port)
+ 			continue;
+ 		if ((tmp->cfg.flags & (VXLAN_F_RCV_FLAGS | VXLAN_F_IPV6)) !=
+ 		    (conf->flags & (VXLAN_F_RCV_FLAGS | VXLAN_F_IPV6)))
+ 			continue;
+ 
+ 		if ((conf->flags & VXLAN_F_IPV6_LINKLOCAL) &&
+ 		    tmp->cfg.remote_ifindex != conf->remote_ifindex)
+ 			continue;
+ 
+ 		return -EEXIST;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vxlan_config_apply(struct net_device *dev,
+ 			       struct vxlan_config *conf,
+ 			       struct net_device *lowerdev,
+ 			       struct net *src_net,
+ 			       bool changelink)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct vxlan_rdst *dst = &vxlan->default_dst;
+ 	unsigned short needed_headroom = ETH_HLEN;
+ 	bool use_ipv6 = !!(conf->flags & VXLAN_F_IPV6);
+ 	int max_mtu = ETH_MAX_MTU;
+ 
+ 	if (!changelink) {
+ 		if (conf->flags & VXLAN_F_GPE)
+ 			vxlan_raw_setup(dev);
+ 		else
+ 			vxlan_ether_setup(dev);
+ 
+ 		if (conf->mtu)
+ 			dev->mtu = conf->mtu;
+ 
+ 		vxlan->net = src_net;
+ 	}
++>>>>>>> 889ce937c98f (vxlan: correctly set vxlan->net when creating the device in a netns)
  
  	dst->remote_vni = conf->vni;
  
@@@ -2882,28 -3075,35 +2940,50 @@@
  	dev->needed_headroom = needed_headroom;
  
  	memcpy(&vxlan->cfg, conf, sizeof(*conf));
 -}
 +	if (!vxlan->cfg.dst_port) {
 +		if (conf->flags & VXLAN_F_GPE)
 +			vxlan->cfg.dst_port = htons(4790); /* IANA VXLAN-GPE port */
 +		else
 +			vxlan->cfg.dst_port = default_port;
 +	}
 +	vxlan->flags |= conf->flags;
  
 -static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,
 -			       struct vxlan_config *conf,
 -			       bool changelink)
 -{
 -	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	struct net_device *lowerdev;
 -	int ret;
 +	if (!vxlan->cfg.age_interval)
 +		vxlan->cfg.age_interval = FDB_AGE_DEFAULT;
  
++<<<<<<< HEAD
 +	list_for_each_entry(tmp, &vn->vxlan_list, next) {
 +		if (tmp->cfg.vni == conf->vni &&
 +		    (tmp->default_dst.remote_ip.sa.sa_family == AF_INET6 ||
 +		     tmp->cfg.saddr.sa.sa_family == AF_INET6) == use_ipv6 &&
 +		    tmp->cfg.dst_port == vxlan->cfg.dst_port &&
 +		    (tmp->flags & VXLAN_F_RCV_FLAGS) ==
 +		    (vxlan->flags & VXLAN_F_RCV_FLAGS)) {
 +			pr_info("duplicate VNI %u\n", be32_to_cpu(conf->vni));
 +			return -EEXIST;
 +		}
 +	}
++=======
+ 	ret = vxlan_config_validate(src_net, conf, &lowerdev, vxlan);
+ 	if (ret)
+ 		return ret;
+ 
+ 	vxlan_config_apply(dev, conf, lowerdev, src_net, changelink);
+ 
+ 	return 0;
+ }
+ 
+ static int __vxlan_dev_create(struct net *net, struct net_device *dev,
+ 			      struct vxlan_config *conf)
+ {
+ 	struct vxlan_net *vn = net_generic(net, vxlan_net_id);
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	int err;
+ 
+ 	err = vxlan_dev_configure(net, dev, conf, false);
+ 	if (err)
+ 		return err;
++>>>>>>> 889ce937c98f (vxlan: correctly set vxlan->net when creating the device in a netns)
  
  	dev->ethtool_ops = &vxlan_ethtool_ops;
  
* Unmerged path drivers/net/vxlan.c
