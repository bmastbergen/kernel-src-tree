ovl: hash overlay non-dir inodes by copy up origin

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit b9ac5c274b8c9d642567022c0e319bca4db31956
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b9ac5c27.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit b9ac5c274b8c9d642567022c0e319bca4db31956)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/inode.c
index e60c6d748742,d9fe07defca3..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -436,18 -467,75 +436,87 @@@ static int ovl_inode_set(struct inode *
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode)
 +
++=======
+ static bool ovl_verify_inode(struct inode *inode, struct dentry *lowerdentry,
+ 			     struct dentry *upperdentry)
+ {
+ 	struct inode *lowerinode = lowerdentry ? d_inode(lowerdentry) : NULL;
+ 
+ 	/* Lower (origin) inode must match, even if NULL */
+ 	if (ovl_inode_lower(inode) != lowerinode)
+ 		return false;
+ 
+ 	/*
+ 	 * Allow non-NULL __upperdentry in inode even if upperdentry is NULL.
+ 	 * This happens when finding a lower alias for a copied up hard link.
+ 	 */
+ 	if (upperdentry && ovl_inode_upper(inode) != d_inode(upperdentry))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry)
++>>>>>>> b9ac5c274b8c (ovl: hash overlay non-dir inodes by copy up origin)
  {
 -	struct dentry *lowerdentry = ovl_dentry_lower(dentry);
 -	struct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;
  	struct inode *inode;
  
++<<<<<<< HEAD
 +	inode = iget5_locked(sb, (unsigned long) realinode,
 +			     ovl_inode_test, ovl_inode_set, realinode);
 +	if (inode && inode->i_state & I_NEW) {
 +		ovl_fill_inode(inode, realinode->i_mode);
 +		set_nlink(inode, realinode->i_nlink);
++=======
+ 	if (!realinode)
+ 		realinode = d_inode(lowerdentry);
+ 
+ 	if (!S_ISDIR(realinode->i_mode) &&
+ 	    (upperdentry || (lowerdentry && ovl_indexdir(dentry->d_sb)))) {
+ 		struct inode *key = d_inode(lowerdentry ?: upperdentry);
+ 
+ 		inode = iget5_locked(dentry->d_sb, (unsigned long) key,
+ 				     ovl_inode_test, ovl_inode_set, key);
+ 		if (!inode)
+ 			goto out_nomem;
+ 		if (!(inode->i_state & I_NEW)) {
+ 			/*
+ 			 * Verify that the underlying files stored in the inode
+ 			 * match those in the dentry.
+ 			 */
+ 			if (!ovl_verify_inode(inode, lowerdentry, upperdentry)) {
+ 				iput(inode);
+ 				inode = ERR_PTR(-ESTALE);
+ 				goto out;
+ 			}
+ 
+ 			dput(upperdentry);
+ 			goto out;
+ 		}
+ 
+ 		set_nlink(inode, realinode->i_nlink);
+ 	} else {
+ 		inode = new_inode(dentry->d_sb);
+ 		if (!inode)
+ 			goto out_nomem;
+ 	}
+ 	ovl_fill_inode(inode, realinode->i_mode, realinode->i_rdev);
+ 	ovl_inode_init(inode, upperdentry, lowerdentry);
+ 
+ 	if (upperdentry && ovl_is_impuredir(upperdentry))
+ 		ovl_set_flag(OVL_IMPURE, inode);
+ 
+ 	if (inode->i_state & I_NEW)
++>>>>>>> b9ac5c274b8c (ovl: hash overlay non-dir inodes by copy up origin)
  		unlock_new_inode(inode);
 -out:
 +	}
 +
  	return inode;
+ 
+ out_nomem:
+ 	inode = ERR_PTR(-ENOMEM);
+ 	goto out;
  }
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/util.c
