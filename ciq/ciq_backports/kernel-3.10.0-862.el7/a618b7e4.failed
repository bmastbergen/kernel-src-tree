IB/hfi1: Move saving PCI values to a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bartlomiej Dudek <bartlomiej.dudek@intel.com>
commit a618b7e40af2b2b751790d602ffa93800b594eca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a618b7e4.failed

During PCIe initialization some registers' values from
PCI config space are saved in order to restore them later
(i.e. after reset). Restoring those value is done by a
function called restore_pci_variables, while saving them
is put directly into function hfi1_pcie_ddinit.
Move saving values to a separate function in the image
of restoring functionality.

	Reviewed-by: Jakub Byczkowski <jakub.byczkowski@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Bartlomiej Dudek <bartlomiej.dudek@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit a618b7e40af2b2b751790d602ffa93800b594eca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/hfi.h
#	drivers/infiniband/hw/hfi1/pcie.c
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index 9e4a63b05006,2d32c5c314a3..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -1830,14 -1828,14 +1830,21 @@@ void hfi1_verbs_unregister_sysfs(struc
  /* Hook for sysfs read of QSFP */
  int qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len);
  
 -int hfi1_pcie_init(struct pci_dev *pdev, const struct pci_device_id *ent);
 -void hfi1_pcie_cleanup(struct pci_dev *pdev);
 -int hfi1_pcie_ddinit(struct hfi1_devdata *dd, struct pci_dev *pdev);
 +int hfi1_pcie_init(struct pci_dev *, const struct pci_device_id *);
 +void hfi1_pcie_cleanup(struct pci_dev *);
 +int hfi1_pcie_ddinit(struct hfi1_devdata *, struct pci_dev *);
  void hfi1_pcie_ddcleanup(struct hfi1_devdata *);
++<<<<<<< HEAD
 +int pcie_speeds(struct hfi1_devdata *);
 +void request_msix(struct hfi1_devdata *, u32 *, struct hfi1_msix_entry *);
 +void hfi1_enable_intx(struct pci_dev *);
 +void restore_pci_variables(struct hfi1_devdata *dd);
++=======
+ int pcie_speeds(struct hfi1_devdata *dd);
+ int request_msix(struct hfi1_devdata *dd, u32 msireq);
+ int restore_pci_variables(struct hfi1_devdata *dd);
+ int save_pci_variables(struct hfi1_devdata *dd);
++>>>>>>> a618b7e40af2 (IB/hfi1: Move saving PCI values to a separate function)
  int do_pcie_gen3_transition(struct hfi1_devdata *dd);
  int parse_platform_config(struct hfi1_devdata *dd);
  int get_platform_config_field(struct hfi1_devdata *dd,
diff --cc drivers/infiniband/hw/hfi1/pcie.c
index 6a9f6f9819e1,82447b7cdda1..000000000000
--- a/drivers/infiniband/hw/hfi1/pcie.c
+++ b/drivers/infiniband/hw/hfi1/pcie.c
@@@ -195,31 -210,24 +195,47 @@@ int hfi1_pcie_ddinit(struct hfi1_devdat
  	dd->physaddr = addr;        /* used for io_remap, etc. */
  
  	/*
 -	 * Map the chip's RcvArray as write-combining to allow us
 +	 * Re-map the chip's RcvArray as write-combining to allow us
  	 * to write an entire cacheline worth of entries in one shot.
 +	 * If this re-map fails, just continue - the RcvArray programming
 +	 * function will handle both cases.
  	 */
 +	dd->chip_rcv_array_count = read_csr(dd, RCV_ARRAY_CNT);
  	dd->rcvarray_wc = ioremap_wc(addr + RCV_ARRAY,
  				     dd->chip_rcv_array_count * 8);
++<<<<<<< HEAD
 +	dd_dev_info(dd, "WC Remapped RcvArray: %p\n", dd->rcvarray_wc);
 +	/*
 +	 * Save BARs and command to rewrite after device reset.
 +	 */
 +	pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0, &dd->pcibar0);
 +	pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1, &dd->pcibar1);
 +	pci_read_config_dword(dd->pcidev, PCI_ROM_ADDRESS, &dd->pci_rom);
 +	pci_read_config_word(dd->pcidev, PCI_COMMAND, &dd->pci_command);
 +	pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL, &dd->pcie_devctl);
 +	pcie_capability_read_word(dd->pcidev, PCI_EXP_LNKCTL, &dd->pcie_lnkctl);
 +	pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL2,
 +				  &dd->pcie_devctl2);
 +	pci_read_config_dword(dd->pcidev, PCI_CFG_MSIX0, &dd->pci_msix0);
 +	pci_read_config_dword(dd->pcidev, PCIE_CFG_SPCIE1, &dd->pci_lnkctl3);
 +	pci_read_config_dword(dd->pcidev, PCIE_CFG_TPH2, &dd->pci_tph2);
 +
 +	return 0;
++=======
+ 	if (!dd->rcvarray_wc) {
+ 		dd_dev_err(dd, "WC mapping of receive array failed\n");
+ 		goto nomem;
+ 	}
+ 	dd_dev_info(dd, "WC RcvArray: %p for %x\n",
+ 		    dd->rcvarray_wc, dd->chip_rcv_array_count * 8);
+ 
+ 	dd->flags |= HFI1_PRESENT;	/* chip.c CSR routines now work */
+ 	return 0;
+ nomem:
+ 	ret = -ENOMEM;
+ 	hfi1_pcie_ddcleanup(dd);
+ 	return ret;
++>>>>>>> a618b7e40af2 (IB/hfi1: Move saving PCI values to a separate function)
  }
  
  /*
@@@ -394,21 -375,121 +410,79 @@@ void hfi1_enable_intx(struct pci_dev *p
  }
  
  /* restore command and BARs after a reset has wiped them out */
 -int restore_pci_variables(struct hfi1_devdata *dd)
 +void restore_pci_variables(struct hfi1_devdata *dd)
  {
 -	int ret = 0;
 -
 -	ret = pci_write_config_word(dd->pcidev, PCI_COMMAND, dd->pci_command);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,
 -				     dd->pcibar0);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,
 -				     dd->pcibar1);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_ROM_ADDRESS, dd->pci_rom);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL,
 -					 dd->pcie_devctl);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_write_word(dd->pcidev, PCI_EXP_LNKCTL,
 -					 dd->pcie_lnkctl);
 -	if (ret)
 -		goto error;
 -
 -	ret = pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL2,
 -					 dd->pcie_devctl2);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCI_CFG_MSIX0, dd->pci_msix0);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_SPCIE1,
 -				     dd->pci_lnkctl3);
 -	if (ret)
 -		goto error;
 -
 -	ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2, dd->pci_tph2);
 -	if (ret)
 -		goto error;
 -
 -	return 0;
 -
 -error:
 -	dd_dev_err(dd, "Unable to write to PCI config\n");
 -	return ret;
 +	pci_write_config_word(dd->pcidev, PCI_COMMAND, dd->pci_command);
 +	pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0, dd->pcibar0);
 +	pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1, dd->pcibar1);
 +	pci_write_config_dword(dd->pcidev, PCI_ROM_ADDRESS, dd->pci_rom);
 +	pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL, dd->pcie_devctl);
 +	pcie_capability_write_word(dd->pcidev, PCI_EXP_LNKCTL, dd->pcie_lnkctl);
 +	pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL2,
 +				   dd->pcie_devctl2);
 +	pci_write_config_dword(dd->pcidev, PCI_CFG_MSIX0, dd->pci_msix0);
 +	pci_write_config_dword(dd->pcidev, PCIE_CFG_SPCIE1, dd->pci_lnkctl3);
 +	pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2, dd->pci_tph2);
  }
  
+ /* Save BARs and command to rewrite after device reset */
+ int save_pci_variables(struct hfi1_devdata *dd)
+ {
+ 	int ret = 0;
+ 
+ 	ret = pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,
+ 				    &dd->pcibar0);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,
+ 				    &dd->pcibar1);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pci_read_config_dword(dd->pcidev, PCI_ROM_ADDRESS, &dd->pci_rom);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pci_read_config_word(dd->pcidev, PCI_COMMAND, &dd->pci_command);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL,
+ 					&dd->pcie_devctl);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_LNKCTL,
+ 					&dd->pcie_lnkctl);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL2,
+ 					&dd->pcie_devctl2);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pci_read_config_dword(dd->pcidev, PCI_CFG_MSIX0, &dd->pci_msix0);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_SPCIE1,
+ 				    &dd->pci_lnkctl3);
+ 	if (ret)
+ 		goto error;
+ 
+ 	ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_TPH2, &dd->pci_tph2);
+ 	if (ret)
+ 		goto error;
+ 
+ 	return 0;
+ 
+ error:
+ 	dd_dev_err(dd, "Unable to read from PCI config\n");
+ 	return ret;
+ }
+ 
  /*
   * BIOS may not set PCIe bus-utilization parameters for best performance.
   * Check and optionally adjust them to maximize our throughput.
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index d0e164a01a3c..3788ed43c475 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -14798,6 +14798,11 @@ struct hfi1_devdata *hfi1_init_dd(struct pci_dev *pdev,
 	if (ret < 0)
 		goto bail_free;
 
+	/* Save PCI space registers to rewrite after device reset */
+	ret = save_pci_variables(dd);
+	if (ret < 0)
+		goto bail_cleanup;
+
 	/* verify that reads actually work, save revision for reset check */
 	dd->revision = read_csr(dd, CCE_REVISION);
 	if (dd->revision == ~(u64)0) {
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
* Unmerged path drivers/infiniband/hw/hfi1/pcie.c
