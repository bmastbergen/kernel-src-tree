IB/hfi1: Pass the context pointer rather than the index

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 2250563e2c935d6401a2203be4de4ca2cf0db183
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2250563e.failed

The hfi1_rcvctrl() function receives an index which it then converts
to an rcd.  Since most functions have the rcd, use that instead.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Reviewed-by: Sebastian Sanchez <sebastian.sanchez@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2250563e2c935d6401a2203be4de4ca2cf0db183)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.c
#	drivers/infiniband/hw/hfi1/chip.h
#	drivers/infiniband/hw/hfi1/file_ops.c
diff --cc drivers/infiniband/hw/hfi1/chip.c
index f57caa8b4d09,a62ef4acdca4..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@@ -11682,13 -11722,13 +11682,17 @@@ static u32 encoded_size(u32 size
  	return 0x1;	/* if invalid, go with the minimum size */
  }
  
++<<<<<<< HEAD
 +void hfi1_rcvctrl(struct hfi1_devdata *dd, unsigned int op, int ctxt)
++=======
+ void hfi1_rcvctrl(struct hfi1_devdata *dd, unsigned int op,
+ 		  struct hfi1_ctxtdata *rcd)
++>>>>>>> 2250563e2c93 (IB/hfi1: Pass the context pointer rather than the index)
  {
- 	struct hfi1_ctxtdata *rcd;
  	u64 rcvctrl, reg;
  	int did_enable = 0;
+ 	u16 ctxt;
  
- 	rcd = dd->rcd[ctxt];
  	if (!rcd)
  		return;
  
diff --cc drivers/infiniband/hw/hfi1/chip.h
index 8a7b218d745f,bef6301d825d..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@@ -1351,15 -1352,17 +1351,20 @@@ int hfi1_init_ctxt(struct send_context 
  void hfi1_put_tid(struct hfi1_devdata *dd, u32 index,
  		  u32 type, unsigned long pa, u16 order);
  void hfi1_quiet_serdes(struct hfi1_pportdata *ppd);
++<<<<<<< HEAD
 +void hfi1_rcvctrl(struct hfi1_devdata *dd, unsigned int op, int ctxt);
++=======
+ void hfi1_rcvctrl(struct hfi1_devdata *dd, unsigned int op,
+ 		  struct hfi1_ctxtdata *rcd);
++>>>>>>> 2250563e2c93 (IB/hfi1: Pass the context pointer rather than the index)
  u32 hfi1_read_cntrs(struct hfi1_devdata *dd, char **namep, u64 **cntrp);
  u32 hfi1_read_portcntrs(struct hfi1_pportdata *ppd, char **namep, u64 **cntrp);
 +u8 hfi1_ibphys_portstate(struct hfi1_pportdata *ppd);
  int hfi1_get_ib_cfg(struct hfi1_pportdata *ppd, int which);
  int hfi1_set_ib_cfg(struct hfi1_pportdata *ppd, int which, u32 val);
 -int hfi1_set_ctxt_jkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd,
 -		       u16 jkey);
 -int hfi1_clear_ctxt_jkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt);
 -int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt,
 -		       u16 pkey);
 +int hfi1_set_ctxt_jkey(struct hfi1_devdata *dd, unsigned ctxt, u16 jkey);
 +int hfi1_clear_ctxt_jkey(struct hfi1_devdata *dd, unsigned ctxt);
 +int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, unsigned ctxt, u16 pkey);
  int hfi1_clear_ctxt_pkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt);
  void hfi1_read_link_quality(struct hfi1_devdata *dd, u8 *link_quality);
  void hfi1_init_vnic_rsm(struct hfi1_devdata *dd);
diff --cc drivers/infiniband/hw/hfi1/file_ops.c
index 32dd4a920494,7be75e0d4f7e..000000000000
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@@ -785,34 -792,26 +784,34 @@@ static int hfi1_file_close(struct inod
  		     HFI1_RCVCTRL_TAILUPD_DIS |
  		     HFI1_RCVCTRL_ONE_PKT_EGR_DIS |
  		     HFI1_RCVCTRL_NO_RHQ_DROP_DIS |
- 		     HFI1_RCVCTRL_NO_EGR_DROP_DIS, uctxt->ctxt);
+ 		     HFI1_RCVCTRL_NO_EGR_DROP_DIS, uctxt);
  	/* Clear the context's J_KEY */
 -	hfi1_clear_ctxt_jkey(dd, uctxt);
 +	hfi1_clear_ctxt_jkey(dd, uctxt->ctxt);
  	/*
 -	 * If a send context is allocated, reset context integrity
 -	 * checks to default and disable the send context.
 +	 * Reset context integrity checks to default.
 +	 * (writes to CSRs probably belong in chip.c)
  	 */
 -	if (uctxt->sc) {
 -		set_pio_integrity(uctxt->sc);
 -		sc_disable(uctxt->sc);
 -	}
 +	write_kctxt_csr(dd, uctxt->sc->hw_context, SEND_CTXT_CHECK_ENABLE,
 +			hfi1_pkt_default_send_ctxt_mask(dd, uctxt->sc->type));
 +	sc_disable(uctxt->sc);
  	spin_unlock_irqrestore(&dd->uctxt_lock, flags);
  
 -	hfi1_free_ctxt_rcv_groups(uctxt);
 +	dd->rcd[uctxt->ctxt] = NULL;
 +
 +	hfi1_user_exp_rcv_grp_free(uctxt);
  	hfi1_clear_ctxt_pkey(dd, uctxt);
  
 +	uctxt->rcvwait_to = 0;
 +	uctxt->piowait_to = 0;
 +	uctxt->rcvnowait = 0;
 +	uctxt->pionowait = 0;
  	uctxt->event_flags = 0;
 -	mutex_unlock(&hfi1_mutex);
  
 -	deallocate_ctxt(uctxt);
 +	hfi1_stats.sps_ctxts--;
 +	if (++dd->freectxts == dd->num_user_contexts)
 +		aspm_enable_all(dd);
 +	mutex_unlock(&hfi1_mutex);
 +	hfi1_free_ctxtdata(dd, uctxt);
  done:
  	mmdrop(fdata->mm);
  	kobject_put(&dd->kobj);
@@@ -1163,21 -1197,13 +1162,25 @@@ static int user_init(struct file *fp
  		rcvctrl_ops |= HFI1_RCVCTRL_TAILUPD_ENB;
  	else
  		rcvctrl_ops |= HFI1_RCVCTRL_TAILUPD_DIS;
++<<<<<<< HEAD
 +	hfi1_rcvctrl(uctxt->dd, rcvctrl_ops, uctxt->ctxt);
 +
 +	/* Notify any waiting slaves */
 +	if (uctxt->subctxt_cnt) {
 +		clear_bit(HFI1_CTXT_MASTER_UNINIT, &uctxt->event_flags);
 +		wake_up(&uctxt->wait);
 +	}
 +
 +	return 0;
++=======
+ 	hfi1_rcvctrl(uctxt->dd, rcvctrl_ops, uctxt);
++>>>>>>> 2250563e2c93 (IB/hfi1: Pass the context pointer rather than the index)
  }
  
 -static int get_ctxt_info(struct hfi1_filedata *fd, void __user *ubase,
 -			 __u32 len)
 +static int get_ctxt_info(struct file *fp, void __user *ubase, __u32 len)
  {
  	struct hfi1_ctxt_info cinfo;
 +	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt = fd->uctxt;
  	int ret = 0;
  
* Unmerged path drivers/infiniband/hw/hfi1/chip.c
* Unmerged path drivers/infiniband/hw/hfi1/chip.h
* Unmerged path drivers/infiniband/hw/hfi1/file_ops.c
diff --git a/drivers/infiniband/hw/hfi1/init.c b/drivers/infiniband/hw/hfi1/init.c
index d1e1227c533d..4c7e3c7d62a2 100644
--- a/drivers/infiniband/hw/hfi1/init.c
+++ b/drivers/infiniband/hw/hfi1/init.c
@@ -572,8 +572,8 @@ static int init_after_reset(struct hfi1_devdata *dd)
 	 */
 	for (i = 0; i < dd->num_rcv_contexts; i++)
 		hfi1_rcvctrl(dd, HFI1_RCVCTRL_CTXT_DIS |
-				  HFI1_RCVCTRL_INTRAVAIL_DIS |
-				  HFI1_RCVCTRL_TAILUPD_DIS, i);
+			     HFI1_RCVCTRL_INTRAVAIL_DIS |
+			     HFI1_RCVCTRL_TAILUPD_DIS, dd->rcd[i]);
 	pio_send_control(dd, PSC_GLOBAL_DISABLE);
 	for (i = 0; i < dd->num_send_contexts; i++)
 		sc_disable(dd->send_contexts[i].sc);
@@ -603,7 +603,7 @@ static void enable_chip(struct hfi1_devdata *dd)
 			rcvmask |= HFI1_RCVCTRL_NO_RHQ_DROP_ENB;
 		if (HFI1_CAP_KGET_MASK(dd->rcd[i]->flags, NODROP_EGR_FULL))
 			rcvmask |= HFI1_RCVCTRL_NO_EGR_DROP_ENB;
-		hfi1_rcvctrl(dd, rcvmask, i);
+		hfi1_rcvctrl(dd, rcvmask, dd->rcd[i]);
 		sc_enable(dd->rcd[i]->sc);
 	}
 }
@@ -883,10 +883,10 @@ static void shutdown_device(struct hfi1_devdata *dd)
 		ppd = dd->pport + pidx;
 		for (i = 0; i < dd->num_rcv_contexts; i++)
 			hfi1_rcvctrl(dd, HFI1_RCVCTRL_TAILUPD_DIS |
-					  HFI1_RCVCTRL_CTXT_DIS |
-					  HFI1_RCVCTRL_INTRAVAIL_DIS |
-					  HFI1_RCVCTRL_PKEY_DIS |
-					  HFI1_RCVCTRL_ONE_PKT_EGR_DIS, i);
+				     HFI1_RCVCTRL_CTXT_DIS |
+				     HFI1_RCVCTRL_INTRAVAIL_DIS |
+				     HFI1_RCVCTRL_PKEY_DIS |
+				     HFI1_RCVCTRL_ONE_PKT_EGR_DIS, dd->rcd[i]);
 		/*
 		 * Gracefully stop all sends allowing any in progress to
 		 * trickle out first.
diff --git a/drivers/infiniband/hw/hfi1/intr.c b/drivers/infiniband/hw/hfi1/intr.c
index 57bb88377b24..8946767e83eb 100644
--- a/drivers/infiniband/hw/hfi1/intr.c
+++ b/drivers/infiniband/hw/hfi1/intr.c
@@ -195,7 +195,7 @@ void handle_user_interrupt(struct hfi1_ctxtdata *rcd)
 
 	if (test_and_clear_bit(HFI1_CTXT_WAITING_RCV, &rcd->event_flags)) {
 		wake_up_interruptible(&rcd->wait);
-		hfi1_rcvctrl(dd, HFI1_RCVCTRL_INTRAVAIL_DIS, rcd->ctxt);
+		hfi1_rcvctrl(dd, HFI1_RCVCTRL_INTRAVAIL_DIS, rcd);
 	} else if (test_and_clear_bit(HFI1_CTXT_WAITING_URG,
 							&rcd->event_flags)) {
 		rcd->urgent++;
diff --git a/drivers/infiniband/hw/hfi1/vnic_main.c b/drivers/infiniband/hw/hfi1/vnic_main.c
index b1572c795c35..1aca67b4009a 100644
--- a/drivers/infiniband/hw/hfi1/vnic_main.c
+++ b/drivers/infiniband/hw/hfi1/vnic_main.c
@@ -99,7 +99,7 @@ static int setup_vnic_ctxt(struct hfi1_devdata *dd, struct hfi1_ctxtdata *uctxt)
 	if (HFI1_CAP_KGET_MASK(uctxt->flags, DMA_RTAIL))
 		rcvctrl_ops |= HFI1_RCVCTRL_TAILUPD_ENB;
 
-	hfi1_rcvctrl(uctxt->dd, rcvctrl_ops, uctxt->ctxt);
+	hfi1_rcvctrl(uctxt->dd, rcvctrl_ops, uctxt);
 
 	uctxt->is_vnic = true;
 done:
@@ -190,7 +190,7 @@ static void deallocate_vnic_ctxt(struct hfi1_devdata *dd,
 		     HFI1_RCVCTRL_INTRAVAIL_DIS |
 		     HFI1_RCVCTRL_ONE_PKT_EGR_DIS |
 		     HFI1_RCVCTRL_NO_RHQ_DROP_DIS |
-		     HFI1_RCVCTRL_NO_EGR_DROP_DIS, uctxt->ctxt);
+		     HFI1_RCVCTRL_NO_EGR_DROP_DIS, uctxt);
 	/*
 	 * VNIC contexts are allocated from user context pool.
 	 * Release them back to user context pool.
