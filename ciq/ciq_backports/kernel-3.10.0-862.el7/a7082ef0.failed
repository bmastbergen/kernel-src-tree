mlx5: hide unused functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit a7082ef066f022c9bdeaae8d23ec2c119fecf7d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a7082ef0.failed

Fix sparse warnings in recent ipoib support.
The RDMA functions are not used yet, hide behind #ifdef.
Based on comment, they will eventually be local so make static.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a7082ef066f022c9bdeaae8d23ec2c119fecf7d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
index 4180820bcac0,3c84e36af018..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
@@@ -89,9 -285,118 +89,120 @@@ static const struct mlx5e_profile mlx5i
  	.max_tc		   = MLX5I_MAX_NUM_TC,
  };
  
++<<<<<<< HEAD
 +/* IPoIB RDMA netdev callbacks */
++=======
+ /* mlx5i netdev NDos */
  
- int mlx5i_xmit(struct net_device *dev, struct sk_buff *skb,
+ static int mlx5i_dev_init(struct net_device *dev)
+ {
+ 	struct mlx5e_priv    *priv   = mlx5i_epriv(dev);
+ 	struct mlx5i_priv    *ipriv  = priv->ppriv;
+ 
+ 	/* Set dev address using underlay QP */
+ 	dev->dev_addr[1] = (ipriv->qp.qpn >> 16) & 0xff;
+ 	dev->dev_addr[2] = (ipriv->qp.qpn >>  8) & 0xff;
+ 	dev->dev_addr[3] = (ipriv->qp.qpn) & 0xff;
+ 
+ 	return 0;
+ }
+ 
+ static void mlx5i_dev_cleanup(struct net_device *dev)
+ {
+ 	struct mlx5e_priv    *priv   = mlx5i_epriv(dev);
+ 	struct mlx5_core_dev *mdev   = priv->mdev;
+ 	struct mlx5i_priv    *ipriv  = priv->ppriv;
+ 	struct mlx5_qp_context context;
+ 
+ 	/* detach qp from flow-steering by reset it */
+ 	mlx5_core_qp_modify(mdev, MLX5_CMD_OP_2RST_QP, 0, &context, &ipriv->qp);
+ }
+ 
+ static int mlx5i_open(struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = mlx5i_epriv(netdev);
+ 	int err;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 
+ 	set_bit(MLX5E_STATE_OPENED, &priv->state);
+ 
+ 	err = mlx5e_open_channels(priv, &priv->channels);
+ 	if (err)
+ 		goto err_clear_state_opened_flag;
+ 
+ 	mlx5e_refresh_tirs(priv, false);
+ 	mlx5e_activate_priv_channels(priv);
+ 	mutex_unlock(&priv->state_lock);
+ 	return 0;
+ 
+ err_clear_state_opened_flag:
+ 	clear_bit(MLX5E_STATE_OPENED, &priv->state);
+ 	mutex_unlock(&priv->state_lock);
+ 	return err;
+ }
+ 
+ static int mlx5i_close(struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = mlx5i_epriv(netdev);
+ 
+ 	/* May already be CLOSED in case a previous configuration operation
+ 	 * (e.g RX/TX queue size change) that involves close&open failed.
+ 	 */
+ 	mutex_lock(&priv->state_lock);
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 		goto unlock;
+ 
+ 	clear_bit(MLX5E_STATE_OPENED, &priv->state);
+ 
+ 	netif_carrier_off(priv->netdev);
+ 	mlx5e_deactivate_priv_channels(priv);
+ 	mlx5e_close_channels(&priv->channels);
+ unlock:
+ 	mutex_unlock(&priv->state_lock);
+ 	return 0;
+ }
+ 
+ #ifdef notusedyet
+ /* IPoIB RDMA netdev callbacks */
+ static int mlx5i_attach_mcast(struct net_device *netdev, struct ib_device *hca,
+ 			      union ib_gid *gid, u16 lid, int set_qkey)
+ {
+ 	struct mlx5e_priv    *epriv = mlx5i_epriv(netdev);
+ 	struct mlx5_core_dev *mdev  = epriv->mdev;
+ 	struct mlx5i_priv    *ipriv = epriv->ppriv;
+ 	int err;
+ 
+ 	mlx5_core_dbg(mdev, "attaching QPN 0x%x, MGID %pI6\n", ipriv->qp.qpn, gid->raw);
+ 	err = mlx5_core_attach_mcg(mdev, gid, ipriv->qp.qpn);
+ 	if (err)
+ 		mlx5_core_warn(mdev, "failed attaching QPN 0x%x, MGID %pI6\n",
+ 			       ipriv->qp.qpn, gid->raw);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5i_detach_mcast(struct net_device *netdev, struct ib_device *hca,
+ 			      union ib_gid *gid, u16 lid)
+ {
+ 	struct mlx5e_priv    *epriv = mlx5i_epriv(netdev);
+ 	struct mlx5_core_dev *mdev  = epriv->mdev;
+ 	struct mlx5i_priv    *ipriv = epriv->ppriv;
+ 	int err;
+ 
+ 	mlx5_core_dbg(mdev, "detaching QPN 0x%x, MGID %pI6\n", ipriv->qp.qpn, gid->raw);
+ 
+ 	err = mlx5_core_detach_mcg(mdev, gid, ipriv->qp.qpn);
+ 	if (err)
+ 		mlx5_core_dbg(mdev, "failed dettaching QPN 0x%x, MGID %pI6\n",
+ 			      ipriv->qp.qpn, gid->raw);
+ 
+ 	return err;
+ }
++>>>>>>> a7082ef066f0 (mlx5: hide unused functions)
+ 
+ static int mlx5i_xmit(struct net_device *dev, struct sk_buff *skb,
  	       struct ib_ah *address, u32 dqpn, u32 dqkey)
  {
  	struct mlx5e_priv *epriv = mlx5i_epriv(dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
