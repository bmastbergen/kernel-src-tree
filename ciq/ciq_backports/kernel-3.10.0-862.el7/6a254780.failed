gfs2: Use rhashtable walk interface in glock_hash_walk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 6a25478077d987edc5e2f880590a2bc5fcab4441
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6a254780.failed

The function glock_hash_walk walks the rhashtable by hand.  This
is broken because if it catches the hash table in the middle of
a rehash, then it will miss entries.

This patch replaces the manual walk by using the rhashtable walk
interface.

Fixes: 88ffbf3e037e ("GFS2: Use resizable hash table for glocks")
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6a25478077d987edc5e2f880590a2bc5fcab4441)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 9164fefd0b3c,70e94170af85..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -1433,14 -1428,16 +1436,27 @@@ static struct shrinker glock_shrinker 
  static void glock_hash_walk(glock_examiner examiner, const struct gfs2_sbd *sdp)
  {
  	struct gfs2_glock *gl;
++<<<<<<< HEAD
 +	struct rhash_head *pos, *next;
 +	const struct bucket_table *tbl;
 +	int i;
 +
 +	rcu_read_lock();
 +	tbl = rht_dereference_rcu(gl_hash_table.tbl, &gl_hash_table);
 +	for (i = 0; i < tbl->size; i++) {
 +		rht_for_each_entry_safe(gl, pos, next, tbl, i, gl_node) {
++=======
+ 	struct rhashtable_iter iter;
+ 
+ 	rhashtable_walk_enter(&gl_hash_table, &iter);
+ 
+ 	do {
+ 		gl = ERR_PTR(rhashtable_walk_start(&iter));
+ 		if (gl)
+ 			continue;
+ 
+ 		while ((gl = rhashtable_walk_next(&iter)) && !IS_ERR(gl))
++>>>>>>> 6a25478077d9 (gfs2: Use rhashtable walk interface in glock_hash_walk)
  			if ((gl->gl_name.ln_sbd == sdp) &&
  			    lockref_get_not_dead(&gl->gl_lockref))
  				examiner(gl);
* Unmerged path fs/gfs2/glock.c
