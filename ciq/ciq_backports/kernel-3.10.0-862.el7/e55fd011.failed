split dentry_kill()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit e55fd011549eae01a230e3cace6f4d031b6a3453
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e55fd011.failed

... into trylocks and everything else.  The latter (actual killing)
is __dentry_kill().

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit e55fd011549eae01a230e3cace6f4d031b6a3453)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index e518a196fb4f,1577c14dfb4e..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -441,34 -441,12 +441,37 @@@ void d_drop(struct dentry *dentry
  }
  EXPORT_SYMBOL(d_drop);
  
++<<<<<<< HEAD
 +/*
 + * Finish off a dentry we've decided to kill.
 + * dentry->d_lock must be held, returns with it unlocked.
 + * If ref is non-zero, then decrement the refcount too.
 + * Returns dentry requiring refcount drop, or NULL if we're done.
 + */
 +static inline struct dentry *dentry_kill(struct dentry *dentry)
 +	__releases(dentry->d_lock)
 +{
 +	struct inode *inode;
 +	struct dentry *parent;
 +
 +	inode = dentry->d_inode;
 +	if (inode && !spin_trylock(&inode->i_lock)) {
 +relock:
 +		spin_unlock(&dentry->d_lock);
 +		cpu_relax();
 +		return dentry; /* try again with same dentry */
 +	}
 +	if (IS_ROOT(dentry))
 +		parent = NULL;
 +	else
++=======
+ static void __dentry_kill(struct dentry *dentry)
+ {
+ 	struct dentry *parent = NULL;
+ 	bool can_free = true;
+ 	if (!IS_ROOT(dentry))
++>>>>>>> e55fd011549e (split dentry_kill())
  		parent = dentry->d_parent;
- 	if (parent && !spin_trylock(&parent->d_lock)) {
- 		if (inode)
- 			spin_unlock(&inode->i_lock);
- 		goto relock;
- 	}
  
  	/*
  	 * The dentry is now unrecoverably dead to the world.
@@@ -482,10 -460,74 +485,75 @@@
  	if ((dentry->d_flags & DCACHE_OP_PRUNE) && !d_unhashed(dentry))
  		dentry->d_op->d_prune(dentry);
  
 -	if (dentry->d_flags & DCACHE_LRU_LIST) {
 -		if (!(dentry->d_flags & DCACHE_SHRINK_LIST))
 -			d_lru_del(dentry);
 -	}
 +	dentry_lru_del(dentry);
  	/* if it was on the hash then remove it */
  	__d_drop(dentry);
++<<<<<<< HEAD
 +	return d_kill(dentry, parent);
++=======
+ 	list_del(&dentry->d_u.d_child);
+ 	/*
+ 	 * Inform d_walk() that we are no longer attached to the
+ 	 * dentry tree
+ 	 */
+ 	dentry->d_flags |= DCACHE_DENTRY_KILLED;
+ 	if (parent)
+ 		spin_unlock(&parent->d_lock);
+ 	dentry_iput(dentry);
+ 	/*
+ 	 * dentry_iput drops the locks, at which point nobody (except
+ 	 * transient RCU lookups) can reach this dentry.
+ 	 */
+ 	BUG_ON((int)dentry->d_lockref.count > 0);
+ 	this_cpu_dec(nr_dentry);
+ 	if (dentry->d_op && dentry->d_op->d_release)
+ 		dentry->d_op->d_release(dentry);
+ 
+ 	spin_lock(&dentry->d_lock);
+ 	if (dentry->d_flags & DCACHE_SHRINK_LIST) {
+ 		dentry->d_flags |= DCACHE_MAY_FREE;
+ 		can_free = false;
+ 	}
+ 	spin_unlock(&dentry->d_lock);
+ 	if (likely(can_free))
+ 		dentry_free(dentry);
+ }
+ 
+ /*
+  * Finish off a dentry we've decided to kill.
+  * dentry->d_lock must be held, returns with it unlocked.
+  * If ref is non-zero, then decrement the refcount too.
+  * Returns dentry requiring refcount drop, or NULL if we're done.
+  */
+ static struct dentry *
+ dentry_kill(struct dentry *dentry, int unlock_on_failure)
+ 	__releases(dentry->d_lock)
+ {
+ 	struct inode *inode = dentry->d_inode;
+ 	struct dentry *parent = NULL;
+ 
+ 	if (inode && unlikely(!spin_trylock(&inode->i_lock)))
+ 		goto failed;
+ 
+ 	if (!IS_ROOT(dentry)) {
+ 		parent = dentry->d_parent;
+ 		if (unlikely(!spin_trylock(&parent->d_lock))) {
+ 			if (inode)
+ 				spin_unlock(&inode->i_lock);
+ 			goto failed;
+ 		}
+ 	}
+ 
+ 	__dentry_kill(dentry);
+ 	return parent;
+ 
+ failed:
+ 	if (unlock_on_failure) {
+ 		spin_unlock(&dentry->d_lock);
+ 		cpu_relax();
+ 	}
+ 	return dentry; /* try again with same dentry */
++>>>>>>> e55fd011549e (split dentry_kill())
  }
  
  /* 
* Unmerged path fs/dcache.c
