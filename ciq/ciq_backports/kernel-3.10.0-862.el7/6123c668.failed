netvsc: delay setup of VF device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 6123c66854c174e4982f98195100c1d990f9e5e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6123c668.failed

When VF device is discovered, delay bring it automatically up in
order to allow userspace to some simple changes (like renaming).

	Reported-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6123c66854c174e4982f98195100c1d990f9e5e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,a57e37641dc5..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -703,11 -720,10 +703,16 @@@ struct net_device_context 
  	u32 speed;
  	struct netvsc_ethtool_stats eth_stats;
  
 +	/* the device is going away */
 +	bool start_remove;
 +
  	/* State to manage the associated VF interface. */
  	struct net_device __rcu *vf_netdev;
++<<<<<<< HEAD
++=======
+ 	struct netvsc_vf_pcpu_stats __percpu *vf_stats;
+ 	struct delayed_work vf_takeover;
++>>>>>>> 6123c66854c1 (netvsc: delay setup of VF device)
  
  	/* 1: allocated, serial number is valid. 0: not allocated */
  	u32 vf_alloc;
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,e059375a6d8c..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -45,14 -47,7 +45,18 @@@
  
  #define RING_SIZE_MIN 64
  #define LINKCHANGE_INT (2 * HZ)
++<<<<<<< HEAD
 +#define NETVSC_HW_FEATURES	(NETIF_F_RXCSUM | \
 +				 NETIF_F_SG | \
 +				 NETIF_F_TSO | \
 +				 NETIF_F_TSO6 | \
 +				 NETIF_F_HW_CSUM)
 +
 +/* Restrict GSO size to account for NVGRE */
 +#define NETVSC_GSO_MAX_SIZE	62768
++=======
+ #define VF_TAKEOVER_INT (HZ / 10)
++>>>>>>> 6123c66854c1 (netvsc: delay setup of VF device)
  
  static int ring_size = 128;
  module_param(ring_size, int, S_IRUGO);
@@@ -1358,6 -1512,108 +1362,111 @@@ static struct net_device *get_netvsc_by
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /* Called when VF is injecting data into network stack.
+  * Change the associated network device from VF to netvsc.
+  * note: already called with rcu_read_lock
+  */
+ static rx_handler_result_t netvsc_vf_handle_frame(struct sk_buff **pskb)
+ {
+ 	struct sk_buff *skb = *pskb;
+ 	struct net_device *ndev = rcu_dereference(skb->dev->rx_handler_data);
+ 	struct net_device_context *ndev_ctx = netdev_priv(ndev);
+ 	struct netvsc_vf_pcpu_stats *pcpu_stats
+ 		 = this_cpu_ptr(ndev_ctx->vf_stats);
+ 
+ 	skb->dev = ndev;
+ 
+ 	u64_stats_update_begin(&pcpu_stats->syncp);
+ 	pcpu_stats->rx_packets++;
+ 	pcpu_stats->rx_bytes += skb->len;
+ 	u64_stats_update_end(&pcpu_stats->syncp);
+ 
+ 	return RX_HANDLER_ANOTHER;
+ }
+ 
+ static int netvsc_vf_join(struct net_device *vf_netdev,
+ 			  struct net_device *ndev)
+ {
+ 	struct net_device_context *ndev_ctx = netdev_priv(ndev);
+ 	int ret;
+ 
+ 	ret = netdev_rx_handler_register(vf_netdev,
+ 					 netvsc_vf_handle_frame, ndev);
+ 	if (ret != 0) {
+ 		netdev_err(vf_netdev,
+ 			   "can not register netvsc VF receive handler (err = %d)\n",
+ 			   ret);
+ 		goto rx_handler_failed;
+ 	}
+ 
+ 	ret = netdev_upper_dev_link(vf_netdev, ndev);
+ 	if (ret != 0) {
+ 		netdev_err(vf_netdev,
+ 			   "can not set master device %s (err = %d)\n",
+ 			   ndev->name, ret);
+ 		goto upper_link_failed;
+ 	}
+ 
+ 	/* set slave flag before open to prevent IPv6 addrconf */
+ 	vf_netdev->flags |= IFF_SLAVE;
+ 
+ 	schedule_delayed_work(&ndev_ctx->vf_takeover, VF_TAKEOVER_INT);
+ 
+ 	call_netdevice_notifiers(NETDEV_JOIN, vf_netdev);
+ 
+ 	netdev_info(vf_netdev, "joined to %s\n", ndev->name);
+ 	return 0;
+ 
+ upper_link_failed:
+ 	netdev_rx_handler_unregister(vf_netdev);
+ rx_handler_failed:
+ 	return ret;
+ }
+ 
+ static void __netvsc_vf_setup(struct net_device *ndev,
+ 			      struct net_device *vf_netdev)
+ {
+ 	int ret;
+ 
+ 	/* Align MTU of VF with master */
+ 	ret = dev_set_mtu(vf_netdev, ndev->mtu);
+ 	if (ret)
+ 		netdev_warn(vf_netdev,
+ 			    "unable to change mtu to %u\n", ndev->mtu);
+ 
+ 	if (netif_running(ndev)) {
+ 		ret = dev_open(vf_netdev);
+ 		if (ret)
+ 			netdev_warn(vf_netdev,
+ 				    "unable to open: %d\n", ret);
+ 	}
+ }
+ 
+ /* Setup VF as slave of the synthetic device.
+  * Runs in workqueue to avoid recursion in netlink callbacks.
+  */
+ static void netvsc_vf_setup(struct work_struct *w)
+ {
+ 	struct net_device_context *ndev_ctx
+ 		= container_of(w, struct net_device_context, vf_takeover.work);
+ 	struct net_device *ndev = hv_get_drvdata(ndev_ctx->device_ctx);
+ 	struct net_device *vf_netdev;
+ 
+ 	if (!rtnl_trylock()) {
+ 		schedule_delayed_work(&ndev_ctx->vf_takeover, 0);
+ 		return;
+ 	}
+ 
+ 	vf_netdev = rtnl_dereference(ndev_ctx->vf_netdev);
+ 	if (vf_netdev)
+ 		__netvsc_vf_setup(ndev, vf_netdev);
+ 
+ 	rtnl_unlock();
+ }
+ 
++>>>>>>> 6123c66854c1 (netvsc: delay setup of VF device)
  static int netvsc_register_vf(struct net_device *vf_netdev)
  {
  	struct net_device *ndev;
@@@ -1461,6 -1707,7 +1570,10 @@@ static int netvsc_unregister_vf(struct 
  		return NOTIFY_DONE;
  
  	net_device_ctx = netdev_priv(ndev);
++<<<<<<< HEAD
++=======
+ 	cancel_delayed_work_sync(&net_device_ctx->vf_takeover);
++>>>>>>> 6123c66854c1 (netvsc: delay setup of VF device)
  
  	netdev_info(ndev, "VF unregistering: %s\n", vf_netdev->name);
  
@@@ -1516,13 -1749,15 +1629,22 @@@ static int netvsc_probe(struct hv_devic
  
  	spin_lock_init(&net_device_ctx->lock);
  	INIT_LIST_HEAD(&net_device_ctx->reconfig_events);
++<<<<<<< HEAD
++=======
+ 	INIT_DELAYED_WORK(&net_device_ctx->vf_takeover, netvsc_vf_setup);
+ 
+ 	net_device_ctx->vf_stats
+ 		= netdev_alloc_pcpu_stats(struct netvsc_vf_pcpu_stats);
+ 	if (!net_device_ctx->vf_stats)
+ 		goto no_stats;
++>>>>>>> 6123c66854c1 (netvsc: delay setup of VF device)
  
  	net->netdev_ops = &device_ops;
 -	net->ethtool_ops = &ethtool_ops;
 +
 +	net->hw_features = NETVSC_HW_FEATURES;
 +	net->features = NETVSC_HW_FEATURES | NETIF_F_HW_VLAN_CTAG_TX;
 +
 +	SET_ETHTOOL_OPS(net, &ethtool_ops);
  	SET_NETDEV_DEV(net, &dev->device);
  
  	/* We always need headroom for rndis header */
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc_drv.c
