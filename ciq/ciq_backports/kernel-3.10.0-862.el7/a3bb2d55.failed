ext4: Don't clear SGID when inheriting ACLs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit a3bb2d5587521eea6dab2d05326abb0afb460abd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a3bb2d55.failed

When new directory 'DIR1' is created in a directory 'DIR0' with SGID bit
set, DIR1 is expected to have SGID bit set (and owning group equal to
the owning group of 'DIR0'). However when 'DIR0' also has some default
ACLs that 'DIR1' inherits, setting these ACLs will result in SGID bit on
'DIR1' to get cleared if user is not member of the owning group.

Fix the problem by moving posix_acl_update_mode() out of
__ext4_set_acl() into ext4_set_acl(). That way the function will not be
called when inheriting ACLs which is what we want as it prevents SGID
bit clearing and the mode has been properly set by posix_acl_create()
anyway.

Fixes: 073931017b49d9458aa351605b43a7e34598caef
CC: stable@vger.kernel.org
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit a3bb2d5587521eea6dab2d05326abb0afb460abd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/acl.c
diff --cc fs/ext4/acl.c
index c844f1bfb451,46ff2229ff5e..000000000000
--- a/fs/ext4/acl.c
+++ b/fs/ext4/acl.c
@@@ -203,20 -189,10 +203,26 @@@ ext4_set_acl(handle_t *handle, struct i
  	void *value = NULL;
  	size_t size = 0;
  	int error;
++<<<<<<< HEAD
 +
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
++=======
++>>>>>>> a3bb2d558752 (ext4: Don't clear SGID when inheriting ACLs)
  
  	switch (type) {
  	case ACL_TYPE_ACCESS:
  		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
++<<<<<<< HEAD
 +		if (acl) {
 +			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
 +			if (error)
 +				return error;
 +			inode->i_ctime = ext4_current_time(inode);
 +			ext4_mark_inode_dirty(handle, inode);
 +		}
++=======
++>>>>>>> a3bb2d558752 (ext4: Don't clear SGID when inheriting ACLs)
  		break;
  
  	case ACL_TYPE_DEFAULT:
@@@ -235,15 -211,58 +241,64 @@@
  	}
  
  	error = ext4_xattr_set_handle(handle, inode, name_index, "",
 -				      value, size, xattr_flags);
 +				      value, size, 0);
  
  	kfree(value);
 -	if (!error) {
 +	if (!error)
  		set_cached_acl(inode, type, acl);
++<<<<<<< HEAD
++=======
+ 	}
++>>>>>>> a3bb2d558752 (ext4: Don't clear SGID when inheriting ACLs)
+ 
+ 	return error;
+ }
+ 
++<<<<<<< HEAD
++=======
+ int
+ ext4_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+ {
+ 	handle_t *handle;
+ 	int error, credits, retries = 0;
+ 	size_t acl_size = acl ? ext4_acl_size(acl->a_count) : 0;
+ 	umode_t mode = inode->i_mode;
+ 	int update_mode = 0;
+ 
+ 	error = dquot_initialize(inode);
+ 	if (error)
+ 		return error;
+ retry:
+ 	error = ext4_xattr_set_credits(inode, acl_size, false /* is_create */,
+ 				       &credits);
+ 	if (error)
+ 		return error;
+ 
+ 	handle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);
+ 	if (IS_ERR(handle))
+ 		return PTR_ERR(handle);
  
+ 	if ((type == ACL_TYPE_ACCESS) && acl) {
+ 		error = posix_acl_update_mode(inode, &mode, &acl);
+ 		if (error)
+ 			goto out_stop;
+ 		update_mode = 1;
+ 	}
+ 
+ 	error = __ext4_set_acl(handle, inode, type, acl, 0 /* xattr_flags */);
+ 	if (!error && update_mode) {
+ 		inode->i_mode = mode;
+ 		inode->i_ctime = current_time(inode);
+ 		ext4_mark_inode_dirty(handle, inode);
+ 	}
+ out_stop:
+ 	ext4_journal_stop(handle);
+ 	if (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
+ 		goto retry;
  	return error;
  }
  
++>>>>>>> a3bb2d558752 (ext4: Don't clear SGID when inheriting ACLs)
  /*
   * Initialize the ACLs of a new inode. Called from ext4_new_inode.
   *
* Unmerged path fs/ext4/acl.c
