mlxsw: spectrum_router: Fix rif counter freeing routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit 6b1206bbbce6092b2ec412125300889e6e551bc2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6b1206bb.failed

During rif counter freeing the counter index can be invalid. Add check
of validity before freeing the counter.

Fixes: e0c0afd8aa4e ("mlxsw: spectrum: Support for counters on router interfaces")
	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6b1206bbbce6092b2ec412125300889e6e551bc2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index f8e7036e3f4a,9f89c4137d21..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -58,10 -63,162 +58,161 @@@ struct mlxsw_sp_rif 
  	struct mlxsw_sp_fid *f;
  	unsigned char addr[ETH_ALEN];
  	int mtu;
 -	u16 rif_index;
 +	u16 rif;
  	u16 vr_id;
 -	unsigned int counter_ingress;
 -	bool counter_ingress_valid;
 -	unsigned int counter_egress;
 -	bool counter_egress_valid;
  };
  
++<<<<<<< HEAD
++=======
+ static unsigned int *
+ mlxsw_sp_rif_p_counter_get(struct mlxsw_sp_rif *rif,
+ 			   enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return &rif->counter_egress;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return &rif->counter_ingress;
+ 	}
+ 	return NULL;
+ }
+ 
+ static bool
+ mlxsw_sp_rif_counter_valid_get(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return rif->counter_egress_valid;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return rif->counter_ingress_valid;
+ 	}
+ 	return false;
+ }
+ 
+ static void
+ mlxsw_sp_rif_counter_valid_set(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir,
+ 			       bool valid)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		rif->counter_egress_valid = valid;
+ 		break;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		rif->counter_ingress_valid = valid;
+ 		break;
+ 	}
+ }
+ 
+ static int mlxsw_sp_rif_counter_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,
+ 				     unsigned int counter_index, bool enable,
+ 				     enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 	bool is_egress = false;
+ 	int err;
+ 
+ 	if (dir == MLXSW_SP_RIF_COUNTER_EGRESS)
+ 		is_egress = true;
+ 	mlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	mlxsw_reg_ritr_counter_pack(ritr_pl, counter_index, enable,
+ 				    is_egress);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_rif *rif,
+ 				   enum mlxsw_sp_rif_counter_dir dir, u64 *cnt)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 	unsigned int *p_counter_index;
+ 	bool valid;
+ 	int err;
+ 
+ 	valid = mlxsw_sp_rif_counter_valid_get(rif, dir);
+ 	if (!valid)
+ 		return -EINVAL;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, *p_counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_NOP);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ 	if (err)
+ 		return err;
+ 	*cnt = mlxsw_reg_ricnt_good_unicast_packets_get(ricnt_pl);
+ 	return 0;
+ }
+ 
+ static int mlxsw_sp_rif_counter_clear(struct mlxsw_sp *mlxsw_sp,
+ 				      unsigned int counter_index)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_CLEAR);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_alloc(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 	int err;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	err = mlxsw_sp_counter_alloc(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 				     p_counter_index);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_rif_counter_clear(mlxsw_sp, *p_counter_index);
+ 	if (err)
+ 		goto err_counter_clear;
+ 
+ 	err = mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 					*p_counter_index, true, dir);
+ 	if (err)
+ 		goto err_counter_edit;
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, true);
+ 	return 0;
+ 
+ err_counter_edit:
+ err_counter_clear:
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_rif_counter_free(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 
+ 	if (!mlxsw_sp_rif_counter_valid_get(rif, dir))
+ 		return;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (WARN_ON(!p_counter_index))
+ 		return;
+ 	mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 				  *p_counter_index, false, dir);
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, false);
+ }
+ 
++>>>>>>> 6b1206bbbce6 (mlxsw: spectrum_router: Fix rif counter freeing routine)
  static struct mlxsw_sp_rif *
  mlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,
  			 const struct net_device *dev);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
