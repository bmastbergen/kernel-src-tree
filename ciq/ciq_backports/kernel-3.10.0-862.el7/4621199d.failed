nfp: reuse ring free code on close

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 4621199dbfb188e4871520569233f7c7528ab439
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4621199d.failed

On the close path reuse the ring free helpers introduced for runtime
reconfiguration.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4621199dbfb188e4871520569233f7c7528ab439)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,23419883cfd4..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2121,79 -2452,6 +2121,88 @@@ err_free_exn
  	return err;
  }
  
 +/**
 + * nfp_net_close_stack() - Quiescent the stack (part of close)
 + * @nn:	     NFP Net device to reconfigure
 + */
 +static void nfp_net_close_stack(struct nfp_net *nn)
 +{
 +	unsigned int r;
 +
 +	disable_irq(nn->irq_entries[NFP_NET_IRQ_LSC_IDX].vector);
 +	netif_carrier_off(nn->netdev);
 +	nn->link_up = false;
 +
 +	for (r = 0; r < nn->num_r_vecs; r++) {
 +		disable_irq(nn->r_vecs[r].irq_vector);
 +		napi_disable(&nn->r_vecs[r].napi);
 +	}
 +
 +	netif_tx_disable(nn->netdev);
 +}
 +
 +/**
 + * nfp_net_close_free_all() - Free all runtime resources
 + * @nn:      NFP Net device to reconfigure
 + */
 +static void nfp_net_close_free_all(struct nfp_net *nn)
 +{
 +	unsigned int r;
 +
++<<<<<<< HEAD
 +	for (r = 0; r < nn->num_rx_rings; r++) {
 +		nfp_net_rx_ring_bufs_free(nn, &nn->rx_rings[r]);
 +		nfp_net_rx_ring_free(&nn->rx_rings[r]);
 +	}
 +	for (r = 0; r < nn->num_tx_rings; r++)
 +		nfp_net_tx_ring_free(&nn->tx_rings[r]);
 +	for (r = 0; r < nn->num_r_vecs; r++)
 +		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
 +
 +	kfree(nn->rx_rings);
 +	kfree(nn->tx_rings);
 +
++=======
++	nfp_net_tx_rings_free(&nn->dp);
++	nfp_net_rx_rings_free(&nn->dp);
++
++	for (r = 0; r < nn->dp.num_r_vecs; r++)
++		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
++
++>>>>>>> 4621199dbfb1 (nfp: reuse ring free code on close)
 +	nfp_net_aux_irq_free(nn, NFP_NET_CFG_LSC, NFP_NET_IRQ_LSC_IDX);
 +	nfp_net_aux_irq_free(nn, NFP_NET_CFG_EXN, NFP_NET_IRQ_EXN_IDX);
 +}
 +
 +/**
 + * nfp_net_netdev_close() - Called when the device is downed
 + * @netdev:      netdev structure
 + */
 +static int nfp_net_netdev_close(struct net_device *netdev)
 +{
 +	struct nfp_net *nn = netdev_priv(netdev);
 +
 +	if (!(nn->ctrl & NFP_NET_CFG_CTRL_ENABLE)) {
 +		nn_err(nn, "Dev is not up: 0x%08x\n", nn->ctrl);
 +		return 0;
 +	}
 +
 +	/* Step 1: Disable RX and TX rings from the Linux kernel perspective
 +	 */
 +	nfp_net_close_stack(nn);
 +
 +	/* Step 2: Tell NFP
 +	 */
 +	nfp_net_clear_config_and_disable(nn);
 +
 +	/* Step 3: Free resources
 +	 */
 +	nfp_net_close_free_all(nn);
 +
 +	nn_dbg(nn, "%s down", netdev->name);
 +	return 0;
 +}
 +
  static void nfp_net_set_rx_mode(struct net_device *netdev)
  {
  	struct nfp_net *nn = netdev_priv(netdev);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
