target/pr: cleanup core_scsi3_pr_seq_non_holder

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 9fcb57f39c0cde70bcccdc1d998d3060297e911c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9fcb57f3.failed

Clean up the mess of registered variables, and pass the isid mismatch
flag explicitly instead of overloading the registration type.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 9fcb57f39c0cde70bcccdc1d998d3060297e911c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_pr.c
diff --cc drivers/target/target_core_pr.c
index a255afc452a9,1e89679ad606..000000000000
--- a/drivers/target/target_core_pr.c
+++ b/drivers/target/target_core_pr.c
@@@ -314,28 -312,31 +314,46 @@@ out
   * This function is called by those initiator ports who are *NOT*
   * the active PR reservation holder when a reservation is present.
   */
- static int core_scsi3_pr_seq_non_holder(
- 	struct se_cmd *cmd,
- 	u32 pr_reg_type)
+ static int core_scsi3_pr_seq_non_holder(struct se_cmd *cmd, u32 pr_reg_type,
+ 					bool isid_mismatch)
  {
  	unsigned char *cdb = cmd->t_task_cdb;
- 	struct se_dev_entry *se_deve;
  	struct se_session *se_sess = cmd->se_sess;
++<<<<<<< HEAD
 +	int other_cdb = 0, ignore_reg;
++=======
+ 	struct se_node_acl *nacl = se_sess->se_node_acl;
+ 	int other_cdb = 0;
++>>>>>>> 9fcb57f39c0c (target/pr: cleanup core_scsi3_pr_seq_non_holder)
  	int registered_nexus = 0, ret = 1; /* Conflict by default */
  	int all_reg = 0, reg_only = 0; /* ALL_REG, REG_ONLY */
  	int we = 0; /* Write Exclusive */
  	int legacy = 0; /* Act like a legacy device and return
  			 * RESERVATION CONFLICT on some CDBs */
  
++<<<<<<< HEAD
 +	se_deve = se_sess->se_node_acl->device_list[cmd->orig_fe_lun];
 +	/*
 +	 * Determine if the registration should be ignored due to
 +	 * non-matching ISIDs in target_scsi3_pr_reservation_check().
 +	 */
 +	ignore_reg = (pr_reg_type & 0x80000000);
 +	if (ignore_reg)
 +		pr_reg_type &= ~0x80000000;
++=======
+ 	if (isid_mismatch) {
+ 		registered_nexus = 0;
+ 	} else {
+ 		struct se_dev_entry *se_deve;
+ 
+ 		rcu_read_lock();
+ 		se_deve = target_nacl_find_deve(nacl, cmd->orig_fe_lun);
+ 		if (se_deve)
+ 			registered_nexus = test_bit(DEF_PR_REG_ACTIVE,
+ 						    &se_deve->deve_flags);
+ 		rcu_read_unlock();
+ 	}
++>>>>>>> 9fcb57f39c0c (target/pr: cleanup core_scsi3_pr_seq_non_holder)
  
  	switch (pr_reg_type) {
  	case PR_TYPE_WRITE_EXCLUSIVE:
@@@ -345,8 -346,6 +363,11 @@@
  		 * Some commands are only allowed for the persistent reservation
  		 * holder.
  		 */
++<<<<<<< HEAD
 +		if ((se_deve->def_pr_registered) && !(ignore_reg))
 +			registered_nexus = 1;
++=======
++>>>>>>> 9fcb57f39c0c (target/pr: cleanup core_scsi3_pr_seq_non_holder)
  		break;
  	case PR_TYPE_WRITE_EXCLUSIVE_REGONLY:
  		we = 1;
@@@ -355,8 -354,6 +376,11 @@@
  		 * Some commands are only allowed for registered I_T Nexuses.
  		 */
  		reg_only = 1;
++<<<<<<< HEAD
 +		if ((se_deve->def_pr_registered) && !(ignore_reg))
 +			registered_nexus = 1;
++=======
++>>>>>>> 9fcb57f39c0c (target/pr: cleanup core_scsi3_pr_seq_non_holder)
  		break;
  	case PR_TYPE_WRITE_EXCLUSIVE_ALLREG:
  		we = 1;
@@@ -365,8 -362,6 +389,11 @@@
  		 * Each registered I_T Nexus is a reservation holder.
  		 */
  		all_reg = 1;
++<<<<<<< HEAD
 +		if ((se_deve->def_pr_registered) && !(ignore_reg))
 +			registered_nexus = 1;
++=======
++>>>>>>> 9fcb57f39c0c (target/pr: cleanup core_scsi3_pr_seq_non_holder)
  		break;
  	default:
  		return -EINVAL;
* Unmerged path drivers/target/target_core_pr.c
