s390/zcrypt: remove support for PCICC and PCICA cards

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: remove support for PCICC and PCICA cards (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 95.05%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit b96a9e5140d4d6253e499bd18c35a7d085ac46e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b96a9e51.failed

Remove the code for really old crypt cards, PCICC and PCICA.
These cards have been out of service for several years.

Reviewd-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit b96a9e5140d4d6253e499bd18c35a7d085ac46e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/zcrypt_pcica.c
#	drivers/s390/crypto/zcrypt_pcicc.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,1d61c8698425..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1322,109 -1591,6 +1322,112 @@@ static int ap_select_domain(void
  }
  
  /**
++<<<<<<< HEAD
 + * ap_probe_device_type(): Find the device type of an AP.
 + * @ap_dev: pointer to the AP device.
 + *
 + * Find the device type if query queue returned a device type of 0.
 + */
 +static int ap_probe_device_type(struct ap_device *ap_dev)
 +{
 +	static unsigned char msg[] = {
 +		0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x58,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x01,0x00,0x43,0x43,0x41,0x2d,0x41,0x50,
 +		0x50,0x4c,0x20,0x20,0x20,0x01,0x01,0x01,
 +		0x00,0x00,0x00,0x00,0x50,0x4b,0x00,0x00,
 +		0x00,0x00,0x01,0x1c,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x05,0xb8,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x70,0x00,0x41,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x54,0x32,0x01,0x00,0xa0,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0xb8,0x05,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
 +		0x49,0x43,0x53,0x46,0x20,0x20,0x20,0x20,
 +		0x50,0x4b,0x0a,0x00,0x50,0x4b,0x43,0x53,
 +		0x2d,0x31,0x2e,0x32,0x37,0x00,0x11,0x22,
 +		0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,
 +		0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,
 +		0x99,0x00,0x11,0x22,0x33,0x44,0x55,0x66,
 +		0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,
 +		0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,
 +		0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,
 +		0x11,0x22,0x33,0x5d,0x00,0x5b,0x00,0x77,
 +		0x88,0x1e,0x00,0x00,0x57,0x00,0x00,0x00,
 +		0x00,0x04,0x00,0x00,0x4f,0x00,0x00,0x00,
 +		0x03,0x02,0x00,0x00,0x40,0x01,0x00,0x01,
 +		0xce,0x02,0x68,0x2d,0x5f,0xa9,0xde,0x0c,
 +		0xf6,0xd2,0x7b,0x58,0x4b,0xf9,0x28,0x68,
 +		0x3d,0xb4,0xf4,0xef,0x78,0xd5,0xbe,0x66,
 +		0x63,0x42,0xef,0xf8,0xfd,0xa4,0xf8,0xb0,
 +		0x8e,0x29,0xc2,0xc9,0x2e,0xd8,0x45,0xb8,
 +		0x53,0x8c,0x6f,0x4e,0x72,0x8f,0x6c,0x04,
 +		0x9c,0x88,0xfc,0x1e,0xc5,0x83,0x55,0x57,
 +		0xf7,0xdd,0xfd,0x4f,0x11,0x36,0x95,0x5d,
 +	};
 +	struct ap_queue_status status;
 +	unsigned long long psmid;
 +	char *reply;
 +	int rc, i;
 +
 +	reply = (void *) get_zeroed_page(GFP_KERNEL);
 +	if (!reply) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +
 +	status = __ap_send(ap_dev->qid, 0x0102030405060708ULL,
 +			   msg, sizeof(msg), 0);
 +	if (status.response_code != AP_RESPONSE_NORMAL) {
 +		rc = -ENODEV;
 +		goto out_free;
 +	}
 +
 +	/* Wait for the test message to complete. */
 +	for (i = 0; i < 6; i++) {
 +		mdelay(300);
 +		status = __ap_recv(ap_dev->qid, &psmid, reply, 4096);
 +		if (status.response_code == AP_RESPONSE_NORMAL &&
 +		    psmid == 0x0102030405060708ULL)
 +			break;
 +	}
 +	if (i < 6) {
 +		/* Got an answer. */
 +		if (reply[0] == 0x00 && reply[1] == 0x86)
 +			ap_dev->device_type = AP_DEVICE_TYPE_PCICC;
 +		else
 +			ap_dev->device_type = AP_DEVICE_TYPE_PCICA;
 +		rc = 0;
 +	} else
 +		rc = -ENODEV;
 +
 +out_free:
 +	free_page((unsigned long) reply);
 +out:
 +	return rc;
 +}
 +
 +static void ap_interrupt_handler(struct airq_struct *airq)
 +{
 +	inc_irq_stat(IRQIO_APB);
 +	tasklet_schedule(&ap_tasklet);
 +}
 +
 +/**
++=======
++>>>>>>> b96a9e5140d4 (s390/zcrypt: remove support for PCICC and PCICA cards)
   * __ap_scan_bus(): Scan the AP bus.
   * @dev: Pointer to device
   * @data: Pointer to data
@@@ -1500,27 -1653,6 +1503,30 @@@ static void ap_scan_bus(struct work_str
  		INIT_LIST_HEAD(&ap_dev->list);
  		setup_timer(&ap_dev->timeout, ap_request_timeout,
  			    (unsigned long) ap_dev);
++<<<<<<< HEAD
 +		switch (device_type) {
 +		case 0:
 +			/* device type probing for old cards */
 +			if (ap_probe_device_type(ap_dev)) {
 +				kfree(ap_dev);
 +				continue;
 +			}
 +			break;
 +		default:
 +			ap_dev->device_type = device_type;
 +		}
 +		ap_dev->raw_hwtype = device_type;
 +		/* CEX6 toleration: map to CEX5 */
 +		if (device_type == AP_DEVICE_TYPE_CEX6)
 +			ap_dev->device_type = AP_DEVICE_TYPE_CEX5;
 +
 +		rc = ap_query_functions(qid, &device_functions);
 +		if (!rc)
 +			ap_dev->functions = device_functions;
 +		else
 +			ap_dev->functions = 0u;
++=======
++>>>>>>> b96a9e5140d4 (s390/zcrypt: remove support for PCICC and PCICA cards)
  
  		ap_dev->device.bus = &ap_bus_type;
  		ap_dev->device.parent = ap_root_device;
* Unmerged path drivers/s390/crypto/zcrypt_pcica.c
* Unmerged path drivers/s390/crypto/zcrypt_pcicc.c
diff --git a/drivers/s390/crypto/Makefile b/drivers/s390/crypto/Makefile
index 771faf7094d6..57f710b3c8a4 100644
--- a/drivers/s390/crypto/Makefile
+++ b/drivers/s390/crypto/Makefile
@@ -3,6 +3,6 @@
 #
 
 ap-objs := ap_bus.o
-obj-$(CONFIG_ZCRYPT) += ap.o zcrypt_api.o zcrypt_pcicc.o zcrypt_pcixcc.o
-obj-$(CONFIG_ZCRYPT) += zcrypt_pcica.o zcrypt_cex2a.o zcrypt_cex4.o
+obj-$(CONFIG_ZCRYPT) += ap.o zcrypt_api.o zcrypt_pcixcc.o
+obj-$(CONFIG_ZCRYPT) += zcrypt_cex2a.o zcrypt_cex4.o
 obj-$(CONFIG_ZCRYPT) += zcrypt_msgtype6.o zcrypt_msgtype50.o
* Unmerged path drivers/s390/crypto/ap_bus.c
* Unmerged path drivers/s390/crypto/zcrypt_pcica.c
diff --git a/drivers/s390/crypto/zcrypt_pcica.h b/drivers/s390/crypto/zcrypt_pcica.h
deleted file mode 100644
index 9a59155cad51..000000000000
--- a/drivers/s390/crypto/zcrypt_pcica.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- *  zcrypt 2.1.0
- *
- *  Copyright IBM Corp. 2001, 2006
- *  Author(s): Robert Burroughs
- *	       Eric Rossman (edrossma@us.ibm.com)
- *
- *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
- *  Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef _ZCRYPT_PCICA_H_
-#define _ZCRYPT_PCICA_H_
-
-/**
- * The type 4 message family is associated with a PCICA card.
- *
- * The four members of the family are described below.
- *
- * Note that all unsigned char arrays are right-justified and left-padded
- * with zeroes.
- *
- * Note that all reserved fields must be zeroes.
- */
-struct type4_hdr {
-	unsigned char  reserved1;
-	unsigned char  msg_type_code;	/* 0x04 */
-	unsigned short msg_len;
-	unsigned char  request_code;	/* 0x40 */
-	unsigned char  msg_fmt;
-	unsigned short reserved2;
-} __attribute__((packed));
-
-#define TYPE4_TYPE_CODE 0x04
-#define TYPE4_REQU_CODE 0x40
-
-#define TYPE4_SME_FMT 0x00
-#define TYPE4_LME_FMT 0x10
-#define TYPE4_SCR_FMT 0x40
-#define TYPE4_LCR_FMT 0x50
-
-/* Mod-Exp, with a small modulus */
-struct type4_sme {
-	struct type4_hdr header;
-	unsigned char	 message[128];
-	unsigned char	 exponent[128];
-	unsigned char	 modulus[128];
-} __attribute__((packed));
-
-/* Mod-Exp, with a large modulus */
-struct type4_lme {
-	struct type4_hdr header;
-	unsigned char	 message[256];
-	unsigned char	 exponent[256];
-	unsigned char	 modulus[256];
-} __attribute__((packed));
-
-/* CRT, with a small modulus */
-struct type4_scr {
-	struct type4_hdr header;
-	unsigned char	 message[128];
-	unsigned char	 dp[72];
-	unsigned char	 dq[64];
-	unsigned char	 p[72];
-	unsigned char	 q[64];
-	unsigned char	 u[72];
-} __attribute__((packed));
-
-/* CRT, with a large modulus */
-struct type4_lcr {
-	struct type4_hdr header;
-	unsigned char	 message[256];
-	unsigned char	 dp[136];
-	unsigned char	 dq[128];
-	unsigned char	 p[136];
-	unsigned char	 q[128];
-	unsigned char	 u[136];
-} __attribute__((packed));
-
-/**
- * The type 84 response family is associated with a PCICA card.
- *
- * Note that all unsigned char arrays are right-justified and left-padded
- * with zeroes.
- *
- * Note that all reserved fields must be zeroes.
- */
-
-struct type84_hdr {
-	unsigned char  reserved1;
-	unsigned char  code;
-	unsigned short len;
-	unsigned char  reserved2[4];
-} __attribute__((packed));
-
-#define TYPE84_RSP_CODE 0x84
-
-int zcrypt_pcica_init(void);
-void zcrypt_pcica_exit(void);
-
-#endif /* _ZCRYPT_PCICA_H_ */
* Unmerged path drivers/s390/crypto/zcrypt_pcicc.c
diff --git a/drivers/s390/crypto/zcrypt_pcicc.h b/drivers/s390/crypto/zcrypt_pcicc.h
deleted file mode 100644
index 7fe27e15075b..000000000000
--- a/drivers/s390/crypto/zcrypt_pcicc.h
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *  zcrypt 2.1.0
- *
- *  Copyright IBM Corp. 2001, 2006
- *  Author(s): Robert Burroughs
- *	       Eric Rossman (edrossma@us.ibm.com)
- *
- *  Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
- *  Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef _ZCRYPT_PCICC_H_
-#define _ZCRYPT_PCICC_H_
-
-/**
- * The type 6 message family is associated with PCICC or PCIXCC cards.
- *
- * It contains a message header followed by a CPRB, both of which
- * are described below.
- *
- * Note that all reserved fields must be zeroes.
- */
-struct type6_hdr {
-	unsigned char reserved1;	/* 0x00				*/
-	unsigned char type;		/* 0x06				*/
-	unsigned char reserved2[2];	/* 0x0000			*/
-	unsigned char right[4];		/* 0x00000000			*/
-	unsigned char reserved3[2];	/* 0x0000			*/
-	unsigned char reserved4[2];	/* 0x0000			*/
-	unsigned char apfs[4];		/* 0x00000000			*/
-	unsigned int  offset1;		/* 0x00000058 (offset to CPRB)	*/
-	unsigned int  offset2;		/* 0x00000000			*/
-	unsigned int  offset3;		/* 0x00000000			*/
-	unsigned int  offset4;		/* 0x00000000			*/
-	unsigned char agent_id[16];	/* PCICC:			*/
-					/*    0x0100			*/
-					/*    0x4343412d4150504c202020	*/
-					/*    0x010101			*/
-					/* PCIXCC:			*/
-					/*    0x4341000000000000	*/
-					/*    0x0000000000000000	*/
-	unsigned char rqid[2];		/* rqid.  internal to 603	*/
-	unsigned char reserved5[2];	/* 0x0000			*/
-	unsigned char function_code[2];	/* for PKD, 0x5044 (ascii 'PD')	*/
-	unsigned char reserved6[2];	/* 0x0000			*/
-	unsigned int  ToCardLen1;	/* (request CPRB len + 3) & -4	*/
-	unsigned int  ToCardLen2;	/* db len 0x00000000 for PKD	*/
-	unsigned int  ToCardLen3;	/* 0x00000000			*/
-	unsigned int  ToCardLen4;	/* 0x00000000			*/
-	unsigned int  FromCardLen1;	/* response buffer length	*/
-	unsigned int  FromCardLen2;	/* db len 0x00000000 for PKD	*/
-	unsigned int  FromCardLen3;	/* 0x00000000			*/
-	unsigned int  FromCardLen4;	/* 0x00000000			*/
-} __attribute__((packed));
-
-/**
- * CPRB
- *	  Note that all shorts, ints and longs are little-endian.
- *	  All pointer fields are 32-bits long, and mean nothing
- *
- *	  A request CPRB is followed by a request_parameter_block.
- *
- *	  The request (or reply) parameter block is organized thus:
- *	    function code
- *	    VUD block
- *	    key block
- */
-struct CPRB {
-	unsigned short cprb_len;	/* CPRB length			 */
-	unsigned char cprb_ver_id;	/* CPRB version id.		 */
-	unsigned char pad_000;		/* Alignment pad byte.		 */
-	unsigned char srpi_rtcode[4];	/* SRPI return code LELONG	 */
-	unsigned char srpi_verb;	/* SRPI verb type		 */
-	unsigned char flags;		/* flags			 */
-	unsigned char func_id[2];	/* function id			 */
-	unsigned char checkpoint_flag;	/*				 */
-	unsigned char resv2;		/* reserved			 */
-	unsigned short req_parml;	/* request parameter buffer	 */
-					/* length 16-bit little endian	 */
-	unsigned char req_parmp[4];	/* request parameter buffer	 *
-					 * pointer (means nothing: the	 *
-					 * parameter buffer follows	 *
-					 * the CPRB).			 */
-	unsigned char req_datal[4];	/* request data buffer		 */
-					/* length	  ULELONG	 */
-	unsigned char req_datap[4];	/* request data buffer		 */
-					/* pointer			 */
-	unsigned short rpl_parml;	/* reply  parameter buffer	 */
-					/* length 16-bit little endian	 */
-	unsigned char pad_001[2];	/* Alignment pad bytes. ULESHORT */
-	unsigned char rpl_parmp[4];	/* reply parameter buffer	 *
-					 * pointer (means nothing: the	 *
-					 * parameter buffer follows	 *
-					 * the CPRB).			 */
-	unsigned char rpl_datal[4];	/* reply data buffer len ULELONG */
-	unsigned char rpl_datap[4];	/* reply data buffer		 */
-					/* pointer			 */
-	unsigned short ccp_rscode;	/* server reason code	ULESHORT */
-	unsigned short ccp_rtcode;	/* server return code	ULESHORT */
-	unsigned char repd_parml[2];	/* replied parameter len ULESHORT*/
-	unsigned char mac_data_len[2];	/* Mac Data Length	ULESHORT */
-	unsigned char repd_datal[4];	/* replied data length	ULELONG	 */
-	unsigned char req_pc[2];	/* PC identifier		 */
-	unsigned char res_origin[8];	/* resource origin		 */
-	unsigned char mac_value[8];	/* Mac Value			 */
-	unsigned char logon_id[8];	/* Logon Identifier		 */
-	unsigned char usage_domain[2];	/* cdx				 */
-	unsigned char resv3[18];	/* reserved for requestor	 */
-	unsigned short svr_namel;	/* server name length  ULESHORT	 */
-	unsigned char svr_name[8];	/* server name			 */
-} __attribute__((packed));
-
-/**
- * The type 86 message family is associated with PCICC and PCIXCC cards.
- *
- * It contains a message header followed by a CPRB.  The CPRB is
- * the same as the request CPRB, which is described above.
- *
- * If format is 1, an error condition exists and no data beyond
- * the 8-byte message header is of interest.
- *
- * The non-error message is shown below.
- *
- * Note that all reserved fields must be zeroes.
- */
-struct type86_hdr {
-	unsigned char reserved1;	/* 0x00				*/
-	unsigned char type;		/* 0x86				*/
-	unsigned char format;		/* 0x01 (error) or 0x02 (ok)	*/
-	unsigned char reserved2;	/* 0x00				*/
-	unsigned char reply_code;	/* reply code (see above)	*/
-	unsigned char reserved3[3];	/* 0x000000			*/
-} __attribute__((packed));
-
-#define TYPE86_RSP_CODE 0x86
-#define TYPE86_FMT2	0x02
-
-struct type86_fmt2_ext {
-	unsigned char	  reserved[4];	/* 0x00000000			*/
-	unsigned char	  apfs[4];	/* final status			*/
-	unsigned int	  count1;	/* length of CPRB + parameters	*/
-	unsigned int	  offset1;	/* offset to CPRB		*/
-	unsigned int	  count2;	/* 0x00000000			*/
-	unsigned int	  offset2;	/* db offset 0x00000000 for PKD	*/
-	unsigned int	  count3;	/* 0x00000000			*/
-	unsigned int	  offset3;	/* 0x00000000			*/
-	unsigned int	  count4;	/* 0x00000000			*/
-	unsigned int	  offset4;	/* 0x00000000			*/
-} __attribute__((packed));
-
-struct function_and_rules_block {
-	unsigned char function_code[2];
-	unsigned short ulen;
-	unsigned char only_rule[8];
-} __attribute__((packed));
-
-int zcrypt_pcicc_init(void);
-void zcrypt_pcicc_exit(void);
-
-#endif /* _ZCRYPT_PCICC_H_ */
