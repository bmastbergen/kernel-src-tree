fsnotify: Move object pointer to fsnotify_mark_connector

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 86ffe245c430f07f95d5d28d3b694ea72f4492e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/86ffe245.failed

Move pointer to inode / vfsmount from mark itself to the
fsnotify_mark_connector structure. This is another step on the path
towards decoupling inode / vfsmount lifetime from notification mark
lifetime.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 86ffe245c430f07f95d5d28d3b694ea72f4492e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fdinfo.c
#	fs/notify/fsnotify.h
#	fs/notify/inode_mark.c
#	fs/notify/mark.c
#	fs/notify/vfsmount_mark.c
#	include/linux/fsnotify_backend.h
#	kernel/audit_tree.c
diff --cc fs/notify/fdinfo.c
index ce5103ba1dff,dd63aa9a6f9a..000000000000
--- a/fs/notify/fdinfo.c
+++ b/fs/notify/fdinfo.c
@@@ -79,14 -75,12 +79,19 @@@ static int inotify_fdinfo(struct seq_fi
  {
  	struct inotify_inode_mark *inode_mark;
  	struct inode *inode;
 +	int ret = 0;
  
++<<<<<<< HEAD
 +	if (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE) ||
 +	    !(mark->flags & FSNOTIFY_MARK_FLAG_INODE))
 +		return 0;
++=======
+ 	if (!(mark->connector->flags & FSNOTIFY_OBJ_TYPE_INODE))
+ 		return;
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  
  	inode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);
- 	inode = igrab(mark->inode);
+ 	inode = igrab(mark->connector->inode);
  	if (inode) {
  		/*
  		 * IN_ALL_EVENTS represents all of the mask bits
@@@ -129,29 -115,25 +134,29 @@@ static int fanotify_fdinfo(struct seq_f
  	if (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)
  		mflags |= FAN_MARK_IGNORED_SURV_MODIFY;
  
- 	if (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {
- 		inode = igrab(mark->inode);
+ 	if (mark->connector->flags & FSNOTIFY_OBJ_TYPE_INODE) {
+ 		inode = igrab(mark->connector->inode);
  		if (!inode)
 -			return;
 -		seq_printf(m, "fanotify ino:%lx sdev:%x mflags:%x mask:%x ignored_mask:%x ",
 -			   inode->i_ino, inode->i_sb->s_dev,
 -			   mflags, mark->mask, mark->ignored_mask);
 -		show_mark_fhandle(m, inode);
 -		seq_putc(m, '\n');
 +			goto out;
 +		ret = seq_printf(m, "fanotify ino:%lx sdev:%x "
 +				 "mflags:%x mask:%x ignored_mask:%x ",
 +				 inode->i_ino, inode->i_sb->s_dev,
 +				 mflags, mark->mask, mark->ignored_mask);
 +		ret |= show_mark_fhandle(m, inode);
 +		ret |= seq_putc(m, '\n');
  		iput(inode);
- 	} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT) {
- 		struct mount *mnt = real_mount(mark->mnt);
+ 	} else if (mark->connector->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT) {
+ 		struct mount *mnt = real_mount(mark->connector->mnt);
  
 -		seq_printf(m, "fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\n",
 -			   mnt->mnt_id, mflags, mark->mask, mark->ignored_mask);
 +		ret = seq_printf(m, "fanotify mnt_id:%x mflags:%x mask:%x "
 +				 "ignored_mask:%x\n", mnt->mnt_id, mflags,
 +				 mark->mask, mark->ignored_mask);
  	}
 +out:
 +	return ret;
  }
  
 -void fanotify_show_fdinfo(struct seq_file *m, struct file *f)
 +int fanotify_show_fdinfo(struct seq_file *m, struct file *f)
  {
  	struct fsnotify_group *group = f->private_data;
  	unsigned int flags = 0;
diff --cc fs/notify/fsnotify.h
index 0a3bc2cf192c,dd1a6798c9cd..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -24,8 -24,9 +24,9 @@@ extern int fsnotify_compare_groups(stru
  extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
  						__u32 mask);
  /* Add mark to a proper place in mark list */
 -extern int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
 +extern int fsnotify_add_mark_list(struct hlist_head *head,
  				  struct fsnotify_mark *mark,
+ 				  struct inode *inode, struct vfsmount *mnt,
  				  int allow_dups);
  /* add a mark to an inode */
  extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
@@@ -41,10 -42,12 +42,19 @@@ extern void fsnotify_destroy_vfsmount_m
  /* inode specific destruction of a mark */
  extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
  /* Find mark belonging to given group in the list of marks */
++<<<<<<< HEAD
 +extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 +						struct fsnotify_group *group);
 +/* Destroy all marks in the given list protected by 'lock' */
 +extern void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock);
++=======
+ extern struct fsnotify_mark *fsnotify_find_mark(
+ 					struct fsnotify_mark_connector *conn,
+ 					struct fsnotify_group *group);
+ /* Destroy all marks connected via given connector protected by 'lock' */
+ extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn,
+ 				   spinlock_t *lock);
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  /* run the list of all marks associated with inode and destroy them */
  static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
  {
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,1644ba09efd4..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -132,10 -129,9 +129,16 @@@ int fsnotify_add_inode_mark(struct fsno
  	assert_spin_locked(&mark->lock);
  
  	spin_lock(&inode->i_lock);
++<<<<<<< HEAD
 +	mark->inode = inode;
 +	ret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,
 +				     allow_dups);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
++=======
+ 	ret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark, inode,
+ 				     NULL, allow_dups);
+ 	inode->i_fsnotify_mask = fsnotify_recalc_mask(inode->i_fsnotify_marks);
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  	spin_unlock(&inode->i_lock);
  
  	return ret;
diff --cc fs/notify/mark.c
index 44836e539169,3d6e7a8e58be..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -304,17 -322,60 +304,73 @@@ int fsnotify_compare_groups(struct fsno
  	return -1;
  }
  
++<<<<<<< HEAD
 +/* Add mark into proper place in given list of marks */
 +int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,
 +			   int allow_dups)
++=======
+ static int fsnotify_attach_connector_to_object(
+ 					struct fsnotify_mark_connector **connp,
+ 					struct inode *inode,
+ 					struct vfsmount *mnt)
+ {
+ 	struct fsnotify_mark_connector *conn;
+ 
+ 	conn = kmem_cache_alloc(fsnotify_mark_connector_cachep, GFP_ATOMIC);
+ 	if (!conn)
+ 		return -ENOMEM;
+ 	INIT_HLIST_HEAD(&conn->list);
+ 	if (inode) {
+ 		conn->flags = FSNOTIFY_OBJ_TYPE_INODE;
+ 		conn->inode = inode;
+ 	} else {
+ 		conn->flags = FSNOTIFY_OBJ_TYPE_VFSMOUNT;
+ 		conn->mnt = mnt;
+ 	}
+ 	/*
+ 	 * Make sure 'conn' initialization is visible. Matches
+ 	 * lockless_dereference() in fsnotify().
+ 	 */
+ 	smp_wmb();
+ 	*connp = conn;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Add mark into proper place in given list of marks. These marks may be used
+  * for the fsnotify backend to determine which event types should be delivered
+  * to which group and for which inodes. These marks are ordered according to
+  * priority, highest number first, and then by the group's location in memory.
+  */
+ int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
+ 			   struct fsnotify_mark *mark, struct inode *inode,
+ 			   struct vfsmount *mnt, int allow_dups)
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  {
  	struct fsnotify_mark *lmark, *last = NULL;
 -	struct fsnotify_mark_connector *conn;
  	int cmp;
++<<<<<<< HEAD
 +
 +	/* is mark the first mark? */
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&mark->obj_list, head);
 +		return 0;
++=======
+ 	int err;
+ 
+ 	if (!*connp) {
+ 		err = fsnotify_attach_connector_to_object(connp, inode, mnt);
+ 		if (err)
+ 			return err;
+ 	}
+ 	conn = *connp;
+ 
+ 	/* is mark the first mark? */
+ 	if (hlist_empty(&conn->list)) {
+ 		hlist_add_head_rcu(&mark->obj_list, &conn->list);
+ 		goto added;
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  	}
  
  	/* should mark be in the middle of the current list? */
diff --cc fs/notify/vfsmount_mark.c
index a8fcab68faef,e04e33ef02d4..000000000000
--- a/fs/notify/vfsmount_mark.c
+++ b/fs/notify/vfsmount_mark.c
@@@ -58,9 -58,9 +58,9 @@@ void fsnotify_destroy_vfsmount_mark(str
  	spin_lock(&mnt->mnt_root->d_lock);
  
  	hlist_del_init_rcu(&mark->obj_list);
- 	mark->mnt = NULL;
+ 	mark->connector = NULL;
  
 -	m->mnt_fsnotify_mask = fsnotify_recalc_mask(m->mnt_fsnotify_marks);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
  	spin_unlock(&mnt->mnt_root->d_lock);
  }
  
@@@ -99,9 -97,9 +97,15 @@@ int fsnotify_add_vfsmount_mark(struct f
  	assert_spin_locked(&mark->lock);
  
  	spin_lock(&mnt->mnt_root->d_lock);
++<<<<<<< HEAD
 +	mark->mnt = mnt;
 +	ret = fsnotify_add_mark_list(&m->mnt_fsnotify_marks, mark, allow_dups);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
++=======
+ 	ret = fsnotify_add_mark_list(&m->mnt_fsnotify_marks, mark, NULL, mnt,
+ 				     allow_dups);
+ 	m->mnt_fsnotify_mask = fsnotify_recalc_mask(m->mnt_fsnotify_marks);
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  	spin_unlock(&mnt->mnt_root->d_lock);
  
  	return ret;
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,06f9a2cc1463..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -195,6 -195,22 +195,25 @@@ struct fsnotify_group 
  #define FSNOTIFY_EVENT_INODE	2
  
  /*
++<<<<<<< HEAD
++=======
+  * Inode / vfsmount point to this structure which tracks all marks attached to
+  * the inode / vfsmount. The structure is freed only when inode / vfsmount gets
+  * freed.
+  */
+ struct fsnotify_mark_connector {
+ #define FSNOTIFY_OBJ_TYPE_INODE		0x01
+ #define FSNOTIFY_OBJ_TYPE_VFSMOUNT	0x02
+ 	unsigned int flags;	/* Type of object [lock] */
+ 	union {	/* Object pointer [lock] */
+ 		struct inode *inode;
+ 		struct vfsmount *mnt;
+ 	};
+ 	struct hlist_head list;
+ };
+ 
+ /*
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
   * A mark is simply an object attached to an in core inode which allows an
   * fsnotify listener to indicate they are either no longer interested in events
   * of a type matching mask or only interested in those events.
@@@ -360,11 -356,12 +375,11 @@@ extern void fsnotify_free_mark(struct f
  extern void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group);
  /* run all the marks in a group, and clear all of the inode marks */
  extern void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group);
- /* run all the marks in a group, and clear all of the marks where mark->flags & flags is true*/
+ /* run all the marks in a group, and clear all of the marks attached to given object type */
  extern void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group, unsigned int flags);
 -extern void fsnotify_connector_free(struct fsnotify_mark_connector **connp);
  extern void fsnotify_get_mark(struct fsnotify_mark *mark);
  extern void fsnotify_put_mark(struct fsnotify_mark *mark);
 -extern void fsnotify_unmount_inodes(struct super_block *sb);
 +extern void fsnotify_unmount_inodes(struct list_head *list);
  
  /* put here because inotify does some weird stuff when destroying watches */
  extern void fsnotify_init_event(struct fsnotify_event *event,
diff --cc kernel/audit_tree.c
index 4dfdb945bae9,c3b5fcb8eca4..000000000000
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@@ -162,21 -163,51 +162,58 @@@ enum {HASH_SIZE = 128}
  static struct list_head chunk_hash_heads[HASH_SIZE];
  static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);
  
 -/* Function to return search key in our hash from inode. */
 -static unsigned long inode_to_key(const struct inode *inode)
 +static inline struct list_head *chunk_hash(const struct inode *inode)
  {
++<<<<<<< HEAD
 +	unsigned long n = (unsigned long)inode / L1_CACHE_BYTES;
++=======
+ 	return (unsigned long)inode;
+ }
+ 
+ /*
+  * Function to return search key in our hash from chunk. Key 0 is special and
+  * should never be present in the hash.
+  *
+  * Must be called with chunk->mark.lock held to protect from connector
+  * becoming NULL.
+  */
+ static unsigned long __chunk_to_key(struct audit_chunk *chunk)
+ {
+ 	if (!chunk->mark.connector)
+ 		return 0;
+ 	return (unsigned long)chunk->mark.connector->inode;
+ }
+ 
+ static unsigned long chunk_to_key(struct audit_chunk *chunk)
+ {
+ 	unsigned long key;
+ 
+ 	spin_lock(&chunk->mark.lock);
+ 	key = __chunk_to_key(chunk);
+ 	spin_unlock(&chunk->mark.lock);
+ 	return key;
+ }
+ 
+ static inline struct list_head *chunk_hash(unsigned long key)
+ {
+ 	unsigned long n = key / L1_CACHE_BYTES;
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  	return chunk_hash_heads + n % HASH_SIZE;
  }
  
  /* hash_lock & entry->lock is held by caller */
  static void insert_hash(struct audit_chunk *chunk)
  {
++<<<<<<< HEAD
 +	struct fsnotify_mark *entry = &chunk->mark;
++=======
+ 	unsigned long key = __chunk_to_key(chunk);
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  	struct list_head *list;
  
 -	if (!(chunk->mark.flags & FSNOTIFY_MARK_FLAG_ATTACHED))
 +	if (!entry->inode)
  		return;
 -	list = chunk_hash(key);
 +	list = chunk_hash(entry->inode);
  	list_add_rcu(&chunk->hash, list);
  }
  
@@@ -260,8 -291,8 +297,13 @@@ static void untag_chunk(struct node *p
  	if (!new)
  		goto Fallback;
  
++<<<<<<< HEAD
 +	if (fsnotify_add_mark_locked(&new->mark,
 +				     entry->group, entry->inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark_locked(&new->mark, entry->group,
+ 				     entry->connector->inode, NULL, 1)) {
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  		fsnotify_put_mark(&new->mark);
  		goto Fallback;
  	}
@@@ -401,8 -432,8 +443,13 @@@ static int tag_chunk(struct inode *inod
  		return -ENOENT;
  	}
  
++<<<<<<< HEAD
 +	if (fsnotify_add_mark_locked(chunk_entry,
 +				     old_entry->group, old_entry->inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark_locked(chunk_entry, old_entry->group,
+ 			     old_entry->connector->inode, NULL, 1)) {
++>>>>>>> 86ffe245c430 (fsnotify: Move object pointer to fsnotify_mark_connector)
  		spin_unlock(&old_entry->lock);
  		mutex_unlock(&old_entry->group->mark_mutex);
  		fsnotify_put_mark(chunk_entry);
diff --git a/fs/notify/dnotify/dnotify.c b/fs/notify/dnotify/dnotify.c
index 38696275be90..24cb278d45ed 100644
--- a/fs/notify/dnotify/dnotify.c
+++ b/fs/notify/dnotify/dnotify.c
@@ -69,8 +69,8 @@ static void dnotify_recalc_inode_mask(struct fsnotify_mark *fsn_mark)
 	if (old_mask == new_mask)
 		return;
 
-	if (fsn_mark->inode)
-		fsnotify_recalc_inode_mask(fsn_mark->inode);
+	if (fsn_mark->connector)
+		fsnotify_recalc_inode_mask(fsn_mark->connector->inode);
 }
 
 /*
* Unmerged path fs/notify/fdinfo.c
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/inode_mark.c
* Unmerged path fs/notify/mark.c
* Unmerged path fs/notify/vfsmount_mark.c
* Unmerged path include/linux/fsnotify_backend.h
* Unmerged path kernel/audit_tree.c
