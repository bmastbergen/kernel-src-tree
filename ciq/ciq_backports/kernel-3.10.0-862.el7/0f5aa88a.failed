ceph: do not modify fi->frag in need_reset_readdir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nicolas Iooss <nicolas.iooss_linux@m4x.org>
commit 0f5aa88a7bb28b73253fb42b3df8202142769f39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0f5aa88a.failed

Commit f3c4ebe65ea1 ("ceph: using hash value to compose dentry offset")
modified "if (fpos_frag(new_pos) != fi->frag)" to "if (fi->frag |=
fpos_frag(new_pos))" in need_reset_readdir(), thus replacing a
comparison operator with an assignment one.

This looks like a typo which is reported by clang when building the
kernel with some warning flags:

    fs/ceph/dir.c:600:22: error: using the result of an assignment as a
    condition without parentheses [-Werror,-Wparentheses]
            } else if (fi->frag |= fpos_frag(new_pos)) {
                       ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~
    fs/ceph/dir.c:600:22: note: place parentheses around the assignment
    to silence this warning
            } else if (fi->frag |= fpos_frag(new_pos)) {
                                ^
                       (                             )
    fs/ceph/dir.c:600:22: note: use '!=' to turn this compound
    assignment into an inequality comparison
            } else if (fi->frag |= fpos_frag(new_pos)) {
                                ^~
                                !=

Fixes: f3c4ebe65ea1 ("ceph: using hash value to compose dentry offset")
	Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 0f5aa88a7bb28b73253fb42b3df8202142769f39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
diff --cc fs/ceph/dir.c
index bca45948d385,df4b3e6fa563..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -485,6 -584,30 +485,33 @@@ static void reset_readdir(struct ceph_f
  	fi->flags &= ~CEPH_F_ATEND;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * discard buffered readdir content on seekdir(0), or seek to new frag,
+  * or seek prior to current chunk
+  */
+ static bool need_reset_readdir(struct ceph_file_info *fi, loff_t new_pos)
+ {
+ 	struct ceph_mds_reply_info_parsed *rinfo;
+ 	loff_t chunk_offset;
+ 	if (new_pos == 0)
+ 		return true;
+ 	if (is_hash_order(new_pos)) {
+ 		/* no need to reset last_name for a forward seek when
+ 		 * dentries are sotred in hash order */
+ 	} else if (fi->frag != fpos_frag(new_pos)) {
+ 		return true;
+ 	}
+ 	rinfo = fi->last_readdir ? &fi->last_readdir->r_reply_info : NULL;
+ 	if (!rinfo || !rinfo->dir_nr)
+ 		return true;
+ 	chunk_offset = rinfo->dir_entries[0].offset;
+ 	return new_pos < chunk_offset ||
+ 	       is_hash_order(new_pos) != is_hash_order(chunk_offset);
+ }
+ 
++>>>>>>> 0f5aa88a7bb2 (ceph: do not modify fi->frag in need_reset_readdir())
  static loff_t ceph_dir_llseek(struct file *file, loff_t offset, int whence)
  {
  	struct ceph_file_info *fi = file->private_data;
* Unmerged path fs/ceph/dir.c
