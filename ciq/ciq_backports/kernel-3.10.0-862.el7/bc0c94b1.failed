target: Drop unnecessary core_tpg_register TFO parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Drop unnecessary core_tpg_register TFO parameter (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 92.31%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit bc0c94b1404b225b19b6b53a0e508f43e269ed1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bc0c94b1.failed

This patch drops unnecessary target_core_fabric_ops parameter usage
for core_tpg_register() during fabric driver TFO->fabric_make_tpg()
se_portal_group creation callback execution.

Instead, use the existing se_wwn->wwn_tf->tf_ops pointer to ensure
fabric driver is really using the same TFO provided at module_init
time.

Also go ahead and drop the forward TFO declarations tree-wide, and
handling the special case for iscsi-target discovery TPG.

	Cc: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit bc0c94b1404b225b19b6b53a0e508f43e269ed1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srpt/ib_srpt.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
#	drivers/target/iscsi/iscsi_target_configfs.c
#	drivers/target/iscsi/iscsi_target_tpg.c
#	drivers/target/loopback/tcm_loop.c
#	drivers/target/sbp/sbp_target.c
#	drivers/target/target_core_tpg.c
#	drivers/target/tcm_fc/tfc_conf.c
#	drivers/usb/gadget/tcm_usb_gadget.c
#	drivers/vhost/scsi.c
#	drivers/xen/xen-scsiback.c
#	include/target/target_core_fabric.h
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 72146d165e84,cea207e8b5d2..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -93,19 -92,64 +93,23 @@@ MODULE_PARM_DESC(srpt_service_guid
  		 " instead of using the node_guid of the first HCA.");
  
  static struct ib_client srpt_client;
++<<<<<<< HEAD
 +static struct target_fabric_configfs *srpt_target;
 +static void srpt_release_cmd(struct se_cmd *se_cmd);
 +static void srpt_free_ch(struct kref *kref);
++=======
+ static void srpt_release_channel(struct srpt_rdma_ch *ch);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  static int srpt_queue_status(struct se_cmd *cmd);
 +static void srpt_recv_done(struct ib_cq *cq, struct ib_wc *wc);
 +static void srpt_send_done(struct ib_cq *cq, struct ib_wc *wc);
 +static void srpt_process_wait_list(struct srpt_rdma_ch *ch);
  
 -/**
 - * opposite_dma_dir() - Swap DMA_TO_DEVICE and DMA_FROM_DEVICE.
 - */
 -static inline
 -enum dma_data_direction opposite_dma_dir(enum dma_data_direction dir)
 -{
 -	switch (dir) {
 -	case DMA_TO_DEVICE:	return DMA_FROM_DEVICE;
 -	case DMA_FROM_DEVICE:	return DMA_TO_DEVICE;
 -	default:		return dir;
 -	}
 -}
 -
 -/**
 - * srpt_sdev_name() - Return the name associated with the HCA.
 - *
 - * Examples are ib0, ib1, ...
 - */
 -static inline const char *srpt_sdev_name(struct srpt_device *sdev)
 -{
 -	return sdev->device->name;
 -}
 -
 -static enum rdma_ch_state srpt_get_ch_state(struct srpt_rdma_ch *ch)
 -{
 -	unsigned long flags;
 -	enum rdma_ch_state state;
 -
 -	spin_lock_irqsave(&ch->spinlock, flags);
 -	state = ch->state;
 -	spin_unlock_irqrestore(&ch->spinlock, flags);
 -	return state;
 -}
 -
 -static enum rdma_ch_state
 -srpt_set_ch_state(struct srpt_rdma_ch *ch, enum rdma_ch_state new_state)
 -{
 -	unsigned long flags;
 -	enum rdma_ch_state prev;
 -
 -	spin_lock_irqsave(&ch->spinlock, flags);
 -	prev = ch->state;
 -	ch->state = new_state;
 -	spin_unlock_irqrestore(&ch->spinlock, flags);
 -	return prev;
 -}
 -
 -/**
 - * srpt_test_and_set_ch_state() - Test and set the channel state.
 - *
 - * Returns true if and only if the channel state has been set to the new state.
 +/*
 + * The only allowed channel state changes are those that change the channel
 + * state into a state with a higher numerical value. Hence the new > prev test.
   */
 -static bool
 -srpt_test_and_set_ch_state(struct srpt_rdma_ch *ch, enum rdma_ch_state old,
 -			   enum rdma_ch_state new)
 +static bool srpt_set_ch_state(struct srpt_rdma_ch *ch, enum rdma_ch_state new)
  {
  	unsigned long flags;
  	enum rdma_ch_state prev;
@@@ -3151,8 -3732,7 +3155,12 @@@ static struct se_portal_group *srpt_mak
  	int res;
  
  	/* Initialize sport->port_wwn and sport->port_tpg_1 */
++<<<<<<< HEAD
 +	res = core_tpg_register(&srpt_target->tf_ops, &sport->port_wwn,
 +			&sport->port_tpg_1, sport, TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	res = core_tpg_register(&sport->port_wwn, &sport->port_tpg_1, SCSI_PROTOCOL_SRP);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (res)
  		return ERR_PTR(res);
  
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,e14a7fd7d810..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -56,20 -52,6 +56,23 @@@
  static struct workqueue_struct *tcm_qla2xxx_free_wq;
  static struct workqueue_struct *tcm_qla2xxx_cmd_wq;
  
++<<<<<<< HEAD
 +/* Local pointer to allocated TCM configfs fabric module */
 +static struct target_fabric_configfs *tcm_qla2xxx_fabric_configfs;
 +static struct target_fabric_configfs *tcm_qla2xxx_npiv_fabric_configfs;
 +
 +static int tcm_qla2xxx_check_true(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static int tcm_qla2xxx_check_false(struct se_portal_group *se_tpg)
 +{
 +	return 0;
 +}
 +
++=======
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  /*
   * Parse WWN.
   * If strict, we require lower-case hex and colon separators to be sure
@@@ -1056,8 -1001,7 +1059,12 @@@ static struct se_portal_group *tcm_qla2
  	tpg->tpg_attrib.cache_dynamic_acls = 1;
  	tpg->tpg_attrib.demo_mode_login_only = 1;
  
++<<<<<<< HEAD
 +	ret = core_tpg_register(&tcm_qla2xxx_fabric_configfs->tf_ops, wwn,
 +				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0) {
  		kfree(tpg);
  		return NULL;
@@@ -1119,8 -1111,16 +1126,21 @@@ static struct se_portal_group *tcm_qla2
  	tpg->lport = lport;
  	tpg->lport_tpgt = tpgt;
  
++<<<<<<< HEAD
 +	ret = core_tpg_register(&tcm_qla2xxx_npiv_fabric_configfs->tf_ops, wwn,
 +				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	/*
+ 	 * By default allow READ-ONLY TPG demo-mode access w/ cached dynamic
+ 	 * NodeACLs
+ 	 */
+ 	tpg->tpg_attrib.generate_node_acls = 1;
+ 	tpg->tpg_attrib.demo_mode_write_protect = 1;
+ 	tpg->tpg_attrib.cache_dynamic_acls = 1;
+ 	tpg->tpg_attrib.demo_mode_login_only = 1;
+ 
+ 	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0) {
  		kfree(tpg);
  		return NULL;
diff --cc drivers/target/iscsi/iscsi_target_configfs.c
index e02616d0c024,c1898c84b3d2..000000000000
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@@ -1551,10 -1419,7 +1551,14 @@@ static struct se_portal_group *lio_targ
  	if (!tpg)
  		return NULL;
  
++<<<<<<< HEAD
 +	ret = core_tpg_register(
 +			&lio_target_fabric_configfs->tf_ops,
 +			wwn, &tpg->tpg_se_tpg, tpg,
 +			TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	ret = core_tpg_register(wwn, &tpg->tpg_se_tpg, SCSI_PROTOCOL_ISCSI);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0)
  		return NULL;
  
diff --cc drivers/target/iscsi/iscsi_target_tpg.c
index 7005d3d54fdd,968068ffcb1c..000000000000
--- a/drivers/target/iscsi/iscsi_target_tpg.c
+++ b/drivers/target/iscsi/iscsi_target_tpg.c
@@@ -67,11 -66,12 +67,20 @@@ int iscsit_load_discovery_tpg(void
  		pr_err("Unable to allocate struct iscsi_portal_group\n");
  		return -1;
  	}
++<<<<<<< HEAD
 +
 +	ret = core_tpg_register(
 +			&lio_target_fabric_configfs->tf_ops,
 +			NULL, &tpg->tpg_se_tpg, tpg,
 +			TRANSPORT_TPG_TYPE_DISCOVERY);
++=======
+ 	/*
+ 	 * Save iscsi_ops pointer for special case discovery TPG that
+ 	 * doesn't exist as se_wwn->wwn_group within configfs.
+ 	 */
+ 	tpg->tpg_se_tpg.se_tpg_tfo = &iscsi_ops;
+ 	ret = core_tpg_register(NULL, &tpg->tpg_se_tpg, -1);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0) {
  		kfree(tpg);
  		return -1;
diff --cc drivers/target/loopback/tcm_loop.c
index d49ba0b7387a,bd9d11a6f823..000000000000
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@@ -41,9 -40,6 +41,12 @@@
  
  #define to_tcm_loop_hba(hba)	container_of(hba, struct tcm_loop_hba, dev)
  
++<<<<<<< HEAD
 +/* Local pointer to allocated TCM configfs fabric module */
 +static struct target_fabric_configfs *tcm_loop_fabric_configfs;
 +
++=======
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  static struct workqueue_struct *tcm_loop_workqueue;
  static struct kmem_cache *tcm_loop_cmd_cache;
  
@@@ -1262,9 -1079,7 +1265,13 @@@ static struct se_portal_group *tcm_loop
  	/*
  	 * Register the tl_tpg as a emulated SAS TCM Target Endpoint
  	 */
++<<<<<<< HEAD
 +	ret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,
 +			wwn, &tl_tpg->tl_se_tpg, tl_tpg,
 +			TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	ret = core_tpg_register(wwn, &tl_tpg->tl_se_tpg, tl_hba->tl_proto_id);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0)
  		return ERR_PTR(-ENOMEM);
  
diff --cc drivers/target/sbp/sbp_target.c
index b33c121ab56c,42f82d32ca85..000000000000
--- a/drivers/target/sbp/sbp_target.c
+++ b/drivers/target/sbp/sbp_target.c
@@@ -2197,9 -2055,7 +2197,13 @@@ static struct se_portal_group *sbp_make
  		goto out_free_tpg;
  	}
  
++<<<<<<< HEAD
 +	ret = core_tpg_register(&sbp_fabric_configfs->tf_ops, wwn,
 +			&tpg->se_tpg, (void *)tpg,
 +			TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_SBP);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0)
  		goto out_unreg_mgt_agt;
  
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,2e77eebe1671..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -647,64 -487,35 +648,96 @@@ static void core_tpg_lun_ref_release(st
  	complete(&lun->lun_ref_comp);
  }
  
++<<<<<<< HEAD
 +static int core_tpg_setup_virtual_lun0(struct se_portal_group *se_tpg)
++=======
+ int core_tpg_register(
+ 	struct se_wwn *se_wwn,
+ 	struct se_portal_group *se_tpg,
+ 	int proto_id)
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  {
 +	/* Set in core_dev_setup_virtual_lun0() */
 +	struct se_device *dev = g_lun0_dev;
 +	struct se_lun *lun = &se_tpg->tpg_virt_lun0;
 +	u32 lun_access = TRANSPORT_LUNFLAGS_READ_ONLY;
  	int ret;
  
++<<<<<<< HEAD
 +	lun->unpacked_lun = 0;
 +	lun->lun_status = TRANSPORT_LUN_STATUS_FREE;
 +	atomic_set(&lun->lun_acl_count, 0);
 +	init_completion(&lun->lun_shutdown_comp);
 +	INIT_LIST_HEAD(&lun->lun_acl_list);
 +	spin_lock_init(&lun->lun_acl_lock);
 +	spin_lock_init(&lun->lun_sep_lock);
 +	init_completion(&lun->lun_ref_comp);
 +
 +	ret = core_tpg_add_lun(se_tpg, lun, lun_access, dev);
 +	if (ret < 0)
 +		return ret;
 +
 +	return 0;
 +}
 +
 +int core_tpg_register(
 +	struct target_core_fabric_ops *tfo,
 +	struct se_wwn *se_wwn,
 +	struct se_portal_group *se_tpg,
 +	void *tpg_fabric_ptr,
 +	int se_tpg_type)
 +{
 +	struct se_lun *lun;
 +	u32 i;
 +
 +	se_tpg->tpg_lun_list = array_zalloc(TRANSPORT_MAX_LUNS_PER_TPG,
 +			sizeof(struct se_lun), GFP_KERNEL);
 +	if (!se_tpg->tpg_lun_list) {
 +		pr_err("Unable to allocate struct se_portal_group->"
 +				"tpg_lun_list\n");
 +		return -ENOMEM;
 +	}
 +
 +	for (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {
 +		lun = se_tpg->tpg_lun_list[i];
 +		lun->unpacked_lun = i;
 +		lun->lun_link_magic = SE_LUN_LINK_MAGIC;
 +		lun->lun_status = TRANSPORT_LUN_STATUS_FREE;
 +		atomic_set(&lun->lun_acl_count, 0);
 +		init_completion(&lun->lun_shutdown_comp);
 +		INIT_LIST_HEAD(&lun->lun_acl_list);
 +		spin_lock_init(&lun->lun_acl_lock);
 +		spin_lock_init(&lun->lun_sep_lock);
 +		init_completion(&lun->lun_ref_comp);
 +	}
 +
 +	se_tpg->se_tpg_type = se_tpg_type;
 +	se_tpg->se_tpg_fabric_ptr = tpg_fabric_ptr;
 +	se_tpg->se_tpg_tfo = tfo;
++=======
+ 	if (!se_tpg)
+ 		return -EINVAL;
+ 	/*
+ 	 * For the typical case where core_tpg_register() is called by a
+ 	 * fabric driver from target_core_fabric_ops->fabric_make_tpg()
+ 	 * configfs context, use the original tf_ops pointer already saved
+ 	 * by target-core in target_fabric_make_wwn().
+ 	 *
+ 	 * Otherwise, for special cases like iscsi-target discovery TPGs
+ 	 * the caller is responsible for setting ->se_tpg_tfo ahead of
+ 	 * calling core_tpg_register().
+ 	 */
+ 	if (se_wwn)
+ 		se_tpg->se_tpg_tfo = se_wwn->wwn_tf->tf_ops;
+ 
+ 	if (!se_tpg->se_tpg_tfo) {
+ 		pr_err("Unable to locate se_tpg->se_tpg_tfo pointer\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	INIT_HLIST_HEAD(&se_tpg->tpg_lun_hlist);
+ 	se_tpg->proto_id = proto_id;
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	se_tpg->se_tpg_wwn = se_wwn;
  	atomic_set(&se_tpg->tpg_pr_ref_count, 0);
  	INIT_LIST_HEAD(&se_tpg->acl_node_list);
@@@ -726,11 -542,11 +759,19 @@@
  	list_add_tail(&se_tpg->se_tpg_node, &tpg_list);
  	spin_unlock_bh(&tpg_lock);
  
++<<<<<<< HEAD
 +	pr_debug("TARGET_CORE[%s]: Allocated %s struct se_portal_group for"
 +		" endpoint: %s, Portal Tag: %u\n", tfo->get_fabric_name(),
 +		(se_tpg->se_tpg_type == TRANSPORT_TPG_TYPE_NORMAL) ?
 +		"Normal" : "Discovery", (tfo->tpg_get_wwn(se_tpg) == NULL) ?
 +		"None" : tfo->tpg_get_wwn(se_tpg), tfo->tpg_get_tag(se_tpg));
++=======
+ 	pr_debug("TARGET_CORE[%s]: Allocated portal_group for endpoint: %s, "
+ 		 "Proto: %d, Portal Tag: %u\n", se_tpg->se_tpg_tfo->get_fabric_name(),
+ 		se_tpg->se_tpg_tfo->tpg_get_wwn(se_tpg) ?
+ 		se_tpg->se_tpg_tfo->tpg_get_wwn(se_tpg) : NULL,
+ 		se_tpg->proto_id, se_tpg->se_tpg_tfo->tpg_get_tag(se_tpg));
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  
  	return 0;
  }
diff --cc drivers/target/tcm_fc/tfc_conf.c
index 8f5b91a74d09,80a4477fa7ee..000000000000
--- a/drivers/target/tcm_fc/tfc_conf.c
+++ b/drivers/target/tcm_fc/tfc_conf.c
@@@ -48,8 -47,6 +48,11 @@@
  
  #include "tcm_fc.h"
  
++<<<<<<< HEAD
 +struct target_fabric_configfs *ft_configfs;
 +
++=======
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  static LIST_HEAD(ft_wwn_list);
  DEFINE_MUTEX(ft_lport_lock);
  
@@@ -337,8 -280,7 +340,12 @@@ static struct se_portal_group *ft_add_t
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	ret = core_tpg_register(&ft_configfs->tf_ops, wwn, &tpg->se_tpg,
 +				tpg, TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0) {
  		destroy_workqueue(wq);
  		kfree(tpg);
diff --cc drivers/usb/gadget/tcm_usb_gadget.c
index 7cacd6ae818e,4ff426edf22a..000000000000
--- a/drivers/usb/gadget/tcm_usb_gadget.c
+++ b/drivers/usb/gadget/tcm_usb_gadget.c
@@@ -29,8 -28,6 +29,11 @@@
  
  USB_GADGET_COMPOSITE_OPTIONS();
  
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +static struct target_fabric_configfs *usbg_fabric_configfs;
 +
++=======
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  static inline struct f_uas *to_f_uas(struct usb_function *f)
  {
  	return container_of(f, struct f_uas, function);
@@@ -1572,9 -1412,11 +1575,17 @@@ static struct se_portal_group *usbg_mak
  	tpg->tport = tport;
  	tpg->tport_tpgt = tpgt;
  
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +	ret = core_tpg_register(&usbg_fabric_configfs->tf_ops, wwn,
 +				&tpg->se_tpg, tpg,
 +				TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	/*
+ 	 * SPC doesn't assign a protocol identifier for USB-SCSI, so we
+ 	 * pretend to be SAS..
+ 	 */
+ 	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_SAS);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  	if (ret < 0) {
  		destroy_workqueue(tpg->workqueue);
  		kfree(tpg);
diff --cc drivers/vhost/scsi.c
index 65142d377371,450aece0227c..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -202,22 -206,19 +202,26 @@@ struct vhost_scsi 
  	int vs_events_nr; /* num of pending events, protected by vq->mutex */
  };
  
++<<<<<<< HEAD
 +/* Local pointer to allocated TCM configfs fabric module */
 +static struct target_fabric_configfs *tcm_vhost_fabric_configfs;
++=======
+ static struct workqueue_struct *vhost_scsi_workqueue;
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
 +
 +static struct workqueue_struct *tcm_vhost_workqueue;
  
 -/* Global spinlock to protect vhost_scsi TPG list for vhost IOCTL access */
 -static DEFINE_MUTEX(vhost_scsi_mutex);
 -static LIST_HEAD(vhost_scsi_list);
 +/* Global spinlock to protect tcm_vhost TPG list for vhost IOCTL access */
 +static DEFINE_MUTEX(tcm_vhost_mutex);
 +static LIST_HEAD(tcm_vhost_list);
  
 -static int iov_num_pages(void __user *iov_base, size_t iov_len)
 +static int iov_num_pages(struct iovec *iov)
  {
 -	return (PAGE_ALIGN((unsigned long)iov_base + iov_len) -
 -	       ((unsigned long)iov_base & PAGE_MASK)) >> PAGE_SHIFT;
 +	return (PAGE_ALIGN((unsigned long)iov->iov_base + iov->iov_len) -
 +	       ((unsigned long)iov->iov_base & PAGE_MASK)) >> PAGE_SHIFT;
  }
  
 -static void vhost_scsi_done_inflight(struct kref *kref)
 +void tcm_vhost_done_inflight(struct kref *kref)
  {
  	struct vhost_scsi_inflight *inflight;
  
@@@ -1869,8 -2000,7 +1873,12 @@@ static struct se_portal_group *tcm_vhos
  	tpg->tport = tport;
  	tpg->tport_tpgt = tpgt;
  
++<<<<<<< HEAD
 +	ret = core_tpg_register(&tcm_vhost_fabric_configfs->tf_ops, wwn,
 +				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	ret = core_tpg_register(wwn, &tpg->se_tpg, tport->tport_proto_id);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  	if (ret < 0) {
  		kfree(tpg);
  		return NULL;
diff --cc include/target/target_core_fabric.h
index c9a57a197803,d6216b761333..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -162,41 -161,9 +162,45 @@@ int	core_tpg_set_initiator_node_queue_d
  		unsigned char *, u32, int);
  int	core_tpg_set_initiator_node_tag(struct se_portal_group *,
  		struct se_node_acl *, const char *);
++<<<<<<< HEAD
 +int	core_tpg_register(struct target_core_fabric_ops *, struct se_wwn *,
 +		struct se_portal_group *, void *, int);
++=======
+ int	core_tpg_register(struct se_wwn *, struct se_portal_group *, int);
++>>>>>>> bc0c94b1404b (target: Drop unnecessary core_tpg_register TFO parameter)
  int	core_tpg_deregister(struct se_portal_group *);
  
 +/* SAS helpers */
 +u8	sas_get_fabric_proto_ident(struct se_portal_group *);
 +u32	sas_get_pr_transport_id(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *, unsigned char *);
 +u32	sas_get_pr_transport_id_len(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *);
 +char	*sas_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 +		u32 *, char **);
 +
 +/* FC helpers */
 +u8	fc_get_fabric_proto_ident(struct se_portal_group *);
 +u32	fc_get_pr_transport_id(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *, unsigned char *);
 +u32	fc_get_pr_transport_id_len(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *);
 +char	*fc_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 +		u32 *, char **);
 +
 +/* iSCSI helpers */
 +u8	iscsi_get_fabric_proto_ident(struct se_portal_group *);
 +u32	iscsi_get_pr_transport_id(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *, unsigned char *);
 +u32	iscsi_get_pr_transport_id_len(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *);
 +char	*iscsi_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 +		u32 *, char **);
 +
 +int	target_alloc_sgl(struct scatterlist **sgl, unsigned int *nents,
 +		u32 length, bool zero_page, bool chainable);
 +void	target_free_sgl(struct scatterlist *sgl, int nents);
 +
  /*
   * The LIO target core uses DMA_TO_DEVICE to mean that data is going
   * to the target (eg handling a WRITE) and DMA_FROM_DEVICE to mean
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
* Unmerged path drivers/target/iscsi/iscsi_target_configfs.c
* Unmerged path drivers/target/iscsi/iscsi_target_tpg.c
* Unmerged path drivers/target/loopback/tcm_loop.c
* Unmerged path drivers/target/sbp/sbp_target.c
* Unmerged path drivers/target/target_core_tpg.c
* Unmerged path drivers/target/tcm_fc/tfc_conf.c
* Unmerged path drivers/usb/gadget/tcm_usb_gadget.c
* Unmerged path drivers/vhost/scsi.c
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path include/target/target_core_fabric.h
