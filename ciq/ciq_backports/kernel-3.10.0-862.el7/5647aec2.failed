ALSA: x86: Embed snd_intelhad into snd_card

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 5647aec26640ffdf099d51b3403eaeac10d74147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5647aec2.failed

Instead of allocating snd_intelhad struct, use the card's private_data
and embed it.  It simplifies the code a lot.

While we're at it, embed had_stream into snd_intelhad struct instead
of individually allocating, and rename had_pvt_data to a bit more
specific name, had_stream_data.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 5647aec26640ffdf099d51b3403eaeac10d74147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index f2f54691cb43,dfc4452afee1..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -1594,20 -1574,13 +1569,28 @@@ int hdmi_audio_probe(struct platform_de
  
  	pr_debug("Enter %s\n", __func__);
  
++<<<<<<< HEAD
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
 +
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
 +
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
 +	}
++=======
+ 	/* create a card instance with ALSA framework */
+ 	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
+ 			      THIS_MODULE, sizeof(*intelhaddata), &card);
+ 	if (retval)
+ 		return retval;
++>>>>>>> 5647aec26640 (ALSA: x86: Embed snd_intelhad into snd_card)
  
+ 	intelhaddata = card->private_data;
  	spin_lock_init(&intelhaddata->had_spinlock);
  	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
  	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
* Unmerged path sound/x86/intel_hdmi_audio.c
diff --git a/sound/x86/intel_hdmi_audio.h b/sound/x86/intel_hdmi_audio.h
index 32a2fb766e47..98a004499f3c 100644
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@ -95,7 +95,7 @@ struct had_stream_pvt {
 	ssize_t				dbg_cum_bytes;
 };
 
-struct had_pvt_data {
+struct had_stream_data {
 	enum had_status_stream		stream_type;
 };
 
@@ -133,7 +133,7 @@ struct snd_intelhad {
 	int		valid_buf_cnt;
 	unsigned int	aes_bits;
 	int flag_underrun;
-	struct had_pvt_data *private_data;
+	struct had_stream_data stream_data;
 	spinlock_t had_spinlock;
 	enum		intel_had_aud_buf_type buff_done;
 	struct device *dev;
diff --git a/sound/x86/intel_hdmi_audio_if.c b/sound/x86/intel_hdmi_audio_if.c
index 8e3a0943332b..caf982e55ec6 100644
--- a/sound/x86/intel_hdmi_audio_if.c
+++ b/sound/x86/intel_hdmi_audio_if.c
@@ -45,13 +45,13 @@
 int hdmi_audio_query(void *haddata, struct hdmi_audio_event event)
 {
 	struct snd_pcm_substream *substream = NULL;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	unsigned long flag_irqs;
 	struct snd_intelhad *intelhaddata = (struct snd_intelhad *)haddata;
 
 	if (intelhaddata->stream_info.had_substream)
 		substream = intelhaddata->stream_info.had_substream;
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 	switch (event.type) {
 	case HAD_EVENT_QUERY_IS_AUDIO_BUSY:
 		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
@@ -98,14 +98,14 @@ int hdmi_audio_query(void *haddata, struct hdmi_audio_event event)
 int hdmi_audio_suspend(void *haddata)
 {
 	int caps, retval = 0;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	unsigned long flag_irqs;
 	struct snd_pcm_substream *substream;
 	struct snd_intelhad *intelhaddata = (struct snd_intelhad *)haddata;
 
 	pr_debug("Enter:%s\n", __func__);
 
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 	substream = intelhaddata->stream_info.had_substream;
 
 	if (intelhaddata->dev->power.runtime_status != RPM_SUSPENDED) {
@@ -199,10 +199,10 @@ static inline int had_chk_intrmiss(struct snd_intelhad *intelhaddata,
 	int i, intr_count = 0;
 	enum intel_had_aud_buf_type buff_done;
 	u32 buf_size, buf_addr;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	unsigned long flag_irqs;
 
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 
 	buff_done = buf_id;
 
@@ -244,12 +244,12 @@ int had_process_buffer_done(struct snd_intelhad *intelhaddata)
 	enum intel_had_aud_buf_type buff_done;
 	struct pcm_stream_info *stream;
 	u32 buf_size;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	int intr_count;
 	enum had_status_stream		stream_type;
 	unsigned long flag_irqs;
 
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 	stream = &intelhaddata->stream_info;
 	intr_count = 1;
 
@@ -331,12 +331,12 @@ int had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
 {
 	enum intel_had_aud_buf_type buf_id;
 	struct pcm_stream_info *stream;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	enum had_status_stream stream_type;
 	unsigned long flag_irqs;
 	int drv_status;
 
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 	stream = &intelhaddata->stream_info;
 
 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
@@ -372,13 +372,13 @@ int had_process_hot_plug(struct snd_intelhad *intelhaddata)
 {
 	enum intel_had_aud_buf_type buf_id;
 	struct snd_pcm_substream *substream;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	unsigned long flag_irqs;
 
 	pr_debug("Enter:%s\n", __func__);
 
 	substream = intelhaddata->stream_info.had_substream;
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 
 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 	if (intelhaddata->drv_status == HAD_DRV_CONNECTED) {
@@ -413,12 +413,12 @@ int had_process_hot_unplug(struct snd_intelhad *intelhaddata)
 {
 	int caps, retval = 0;
 	enum intel_had_aud_buf_type buf_id;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	unsigned long flag_irqs;
 
 	pr_debug("Enter:%s\n", __func__);
 
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 	buf_id = intelhaddata->curr_buf;
 
 	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
@@ -476,11 +476,11 @@ int had_event_handler(enum had_event_type event_type, void *data)
 	struct snd_intelhad *intelhaddata = data;
 	enum intel_had_aud_buf_type buf_id;
 	struct snd_pcm_substream *substream;
-	struct had_pvt_data *had_stream;
+	struct had_stream_data *had_stream;
 	unsigned long flag_irqs;
 
 	buf_id = intelhaddata->curr_buf;
-	had_stream = intelhaddata->private_data;
+	had_stream = &intelhaddata->stream_data;
 
 	/* Switching to a function can drop atomicity even in INTR context.
 	 * Thus, a big lock is acquired to maintain atomicity.
