bnxt_en: Fix IRQ coalescing regression.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Fix IRQ coalescing regression (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.70%
commit-author Michael Chan <michael.chan@broadcom.com>
commit b153cbc507946f52d5aa687fd64f45d82cb36a3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b153cbc5.failed

Recent IRQ coalescing clean up has removed a guard-rail for the max DMA
buffer coalescing value.  This is a 6-bit value and must not be 0.  We
already have a check for 0 but 64 is equivalent to 0 and will cause
non-stop interrupts.  Fix it by adding the proper check.

Fixes: f8503969d27b ("bnxt_en: Refactor and simplify coalescing code.")
	Reported-by: Andy Gospodarek <gospo@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b153cbc507946f52d5aa687fd64f45d82cb36a3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index c325a10cc99e,4e3d569bf32e..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4243,19 -4513,70 +4243,58 @@@ int bnxt_hwrm_reserve_tx_rings(struct b
  	return rc;
  }
  
 -static int bnxt_hwrm_check_tx_rings(struct bnxt *bp, int tx_rings)
 -{
 -	struct hwrm_func_cfg_input req = {0};
 -	int rc;
 -
 -	if (bp->hwrm_spec_code < 0x10801)
 -		return 0;
 -
 -	if (BNXT_VF(bp))
 -		return 0;
 -
 -	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FUNC_CFG, -1, -1);
 -	req.fid = cpu_to_le16(0xffff);
 -	req.flags = cpu_to_le32(FUNC_CFG_REQ_FLAGS_TX_ASSETS_TEST);
 -	req.enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_NUM_TX_RINGS);
 -	req.num_tx_rings = cpu_to_le16(tx_rings);
 -	rc = hwrm_send_message_silent(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
 -	if (rc)
 -		return -ENOMEM;
 -	return 0;
 -}
 -
 -static void bnxt_hwrm_set_coal_params(struct bnxt_coal *hw_coal,
 +static void bnxt_hwrm_set_coal_params(struct bnxt *bp, u32 max_bufs,
 +	u32 buf_tmrs, u16 flags,
  	struct hwrm_ring_cmpl_ring_cfg_aggint_params_input *req)
  {
++<<<<<<< HEAD
++=======
+ 	u16 val, tmr, max, flags;
+ 
+ 	max = hw_coal->bufs_per_record * 128;
+ 	if (hw_coal->budget)
+ 		max = hw_coal->bufs_per_record * hw_coal->budget;
+ 
+ 	val = clamp_t(u16, hw_coal->coal_bufs, 1, max);
+ 	req->num_cmpl_aggr_int = cpu_to_le16(val);
+ 
+ 	/* This is a 6-bit value and must not be 0, or we'll get non stop IRQ */
+ 	val = min_t(u16, val, 63);
+ 	req->num_cmpl_dma_aggr = cpu_to_le16(val);
+ 
+ 	/* This is a 6-bit value and must not be 0, or we'll get non stop IRQ */
+ 	val = clamp_t(u16, hw_coal->coal_bufs_irq, 1, 63);
+ 	req->num_cmpl_dma_aggr_during_int = cpu_to_le16(val);
+ 
+ 	tmr = BNXT_USEC_TO_COAL_TIMER(hw_coal->coal_ticks);
+ 	tmr = max_t(u16, tmr, 1);
+ 	req->int_lat_tmr_max = cpu_to_le16(tmr);
+ 
+ 	/* min timer set to 1/2 of interrupt timer */
+ 	val = tmr / 2;
+ 	req->int_lat_tmr_min = cpu_to_le16(val);
+ 
+ 	/* buf timer set to 1/4 of interrupt timer */
+ 	val = max_t(u16, tmr / 4, 1);
+ 	req->cmpl_aggr_dma_tmr = cpu_to_le16(val);
+ 
+ 	tmr = BNXT_USEC_TO_COAL_TIMER(hw_coal->coal_ticks_irq);
+ 	tmr = max_t(u16, tmr, 1);
+ 	req->cmpl_aggr_dma_tmr_during_int = cpu_to_le16(tmr);
+ 
+ 	flags = RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_TIMER_RESET;
+ 	if (hw_coal->idle_thresh && hw_coal->coal_ticks < hw_coal->idle_thresh)
+ 		flags |= RING_CMPL_RING_CFG_AGGINT_PARAMS_REQ_FLAGS_RING_IDLE;
++>>>>>>> b153cbc50794 (bnxt_en: Fix IRQ coalescing regression.)
  	req->flags = cpu_to_le16(flags);
 +	req->num_cmpl_dma_aggr = cpu_to_le16((u16)max_bufs);
 +	req->num_cmpl_dma_aggr_during_int = cpu_to_le16(max_bufs >> 16);
 +	req->cmpl_aggr_dma_tmr = cpu_to_le16((u16)buf_tmrs);
 +	req->cmpl_aggr_dma_tmr_during_int = cpu_to_le16(buf_tmrs >> 16);
 +	/* Minimum time between 2 interrupts set to buf_tmr x 2 */
 +	req->int_lat_tmr_min = cpu_to_le16((u16)buf_tmrs * 2);
 +	req->int_lat_tmr_max = cpu_to_le16((u16)buf_tmrs * 4);
 +	req->num_cmpl_aggr_int = cpu_to_le16((u16)max_bufs * 4);
  }
  
  int bnxt_hwrm_set_coal(struct bnxt *bp)
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
