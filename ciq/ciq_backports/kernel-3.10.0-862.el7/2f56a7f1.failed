qla2xxx: Enable Exchange offload support.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Enable Exchange offload support (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 98.77%
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit 2f56a7f1b5d8cf3d8bc84cc08dda09c991b698a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2f56a7f1.failed

This patch enables Exchange offload support in Qlogic ISP.
To enable exchange offload with Qlogic ISP24XX/25XX/26XX,
set module parameter ql2xexchoffld to any non-zero number.
This will alow ISP firmware to store exchange data structures
used by firmware to host memory provided by driver. ISP firmware
can supports upto 32k total active exchanges.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Giridhar Malavali <giridhar.malavali@qlogic.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 2f56a7f1b5d8cf3d8bc84cc08dda09c991b698a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.c
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index 866e7a991a8e,e8b38dbac7d4..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -11,14 -11,12 +11,23 @@@
   * ----------------------------------------------------------------------
   * |             Level            |   Last Value Used  |     Holes	|
   * ----------------------------------------------------------------------
++<<<<<<< HEAD
 + * | Module Init and Probe        |       0x0193       | 0x0146         |
 + * | Mailbox commands             |       0x1199       | 0x111a-0x111b  |
 + * |                              |                    | 0x1155-0x1158  |
 + * |                              |                    | 0x1018-0x1019  |
 + * |                              |                    | 0x1115-0x1116  |
 + * |                              |                    | 0x10ca,0x1193  |
 + * | Device Discovery             |       0x2095       | 0x2016         |
 + * |                              |                    | 0x2020-0x2022, |
++=======
+  * | Module Init and Probe        |       0x017f       | 0x0146         |
+  * |                              |                    | 0x015b-0x0160	|
+  * |                              |                    | 0x016e-0x0170  |
+  * | Mailbox commands             |       0x1192       |		|
+  * |                              |                    |		|
+  * | Device Discovery             |       0x2016       | 0x2020-0x2022, |
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
   * |                              |                    | 0x2011-0x2012, |
   * |                              |                    | 0x2099-0x20a4  |
   * | Queue Command and IO tracing |       0x3075       | 0x300b         |
@@@ -61,18 -59,14 +70,23 @@@
   * |                              |                    | 0xb13a,0xb142  |
   * |                              |                    | 0xb13c-0xb140  |
   * |                              |                    | 0xb149		|
++<<<<<<< HEAD
 + * | MultiQ                       |       0xc010       |		|
 + * | Misc                         |       0xd300       | 0xd016-0xd017	|
 + * |                              |                    | 0xd021,0xd024	|
 + * |                              |                    | 0xd025,0xd029	|
 + * |                              |                    | 0xd02a,0xd02e	|
 + * |                              |                    | 0xd031-0xd0ff	|
++=======
+  * | MultiQ                       |       0xc00c       |		|
+  * | Misc                         |       0xd300       | 0xd031-0xd0ff	|
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
   * |                              |                    | 0xd101-0xd1fe	|
 - * |                              |                    | 0xd214-0xd2fe	|
 - * | Target Mode		  |	  0xe080       |		|
 - * | Target Mode Management	  |	  0xf096       | 0xf002		|
 + * |                              |                    | 0xd213-0xd2fe	|
 + * | Target Mode		  |	  0xe070       | 0xe021		|
 + * | Target Mode Management	  |	  0xf072       | 0xf002-0xf003	|
   * |                              |                    | 0xf046-0xf049  |
 - * | Target Mode Task Management  |	  0x1000d      |		|
 + * | Target Mode Task Management  |	  0x1000b      |		|
   * ----------------------------------------------------------------------
   */
  
diff --cc drivers/scsi/qla2xxx/qla_def.h
index e18cc36570ad,d31401c5a7eb..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -273,8 -272,10 +273,9 @@@
  #define RESPONSE_ENTRY_CNT_MQ		128	/* Number of response entries.*/
  #define ATIO_ENTRY_CNT_24XX		4096	/* Number of ATIO entries. */
  #define RESPONSE_ENTRY_CNT_FX00		256     /* Number of response entries.*/
+ #define EXTENDED_EXCH_ENTRY_CNT		32768   /* Entries for offload case */
  
  struct req_que;
 -struct qla_tgt_sess;
  
  /*
   * (sd.h is not exported, hence local inclusion)
@@@ -3013,11 -2964,12 +3014,16 @@@ struct qla_hw_data 
  		uint32_t	isp82xx_no_md_cap:1;
  		uint32_t	host_shutting_down:1;
  		uint32_t	idc_compl_status:1;
 +
  		uint32_t        mr_reset_hdlr_active:1;
  		uint32_t        mr_intr_valid:1;
 -
 +		uint32_t	dport_enabled:1;
  		uint32_t	fawwpn_enabled:1;
++<<<<<<< HEAD
++=======
+ 		uint32_t	exlogins_enabled:1;
+ 		uint32_t	exchoffld_enabled:1;
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  		/* 35 bits */
  	} flags;
  
@@@ -3296,6 -3241,21 +3302,24 @@@
  	void		*async_pd;
  	dma_addr_t	async_pd_dma;
  
++<<<<<<< HEAD
++=======
+ #define ENABLE_EXTENDED_LOGIN	BIT_7
+ 
+ 	/* Extended Logins  */
+ 	void		*exlogin_buf;
+ 	dma_addr_t	exlogin_buf_dma;
+ 	int		exlogin_size;
+ 
+ #define ENABLE_EXCHANGE_OFFLD	BIT_2
+ 
+ 	/* Exchange Offload */
+ 	void		*exchoffld_buf;
+ 	dma_addr_t	exchoffld_buf_dma;
+ 	int		exchoffld_size;
+ 	int 		exchoffld_count;
+ 
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  	void		*swl;
  
  	/* These are used by mailbox operations. */
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,3dc323caaa95..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -118,10 -114,11 +118,15 @@@ extern int ql2xenabledif
  extern int ql2xenablehba_err_chk;
  extern int ql2xtargetreset;
  extern int ql2xdontresethba;
 -extern uint64_t ql2xmaxlun;
 +extern unsigned int ql2xmaxlun;
  extern int ql2xmdcapmask;
  extern int ql2xmdenable;
++<<<<<<< HEAD
 +extern int ql2xfwholdabts;
++=======
+ extern int ql2xexlogins;
+ extern int ql2xexchoffld;
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  
  extern int qla2x00_loop_reset(scsi_qla_host_t *);
  extern void qla2x00_abort_all_cmds(scsi_qla_host_t *, int);
@@@ -140,6 -137,10 +145,13 @@@ extern int qla2x00_post_async_adisc_wor
      uint16_t *);
  extern int qla2x00_post_async_adisc_done_work(struct scsi_qla_host *,
      fc_port_t *, uint16_t *);
++<<<<<<< HEAD
++=======
+ extern int qla2x00_set_exlogins_buffer(struct scsi_qla_host *);
+ extern void qla2x00_free_exlogin_buffer(struct qla_hw_data *);
+ extern int qla2x00_set_exchoffld_buffer(struct scsi_qla_host *);
+ extern void qla2x00_free_exchoffld_buffer(struct qla_hw_data *);
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  
  extern int qla81xx_restart_mpi_firmware(scsi_qla_host_t *);
  
@@@ -782,4 -771,11 +794,14 @@@ extern void qla82xx_mbx_completion(scsi
  extern int qla8044_abort_isp(scsi_qla_host_t *);
  extern int qla8044_check_fw_alive(struct scsi_qla_host *);
  
++<<<<<<< HEAD
++=======
+ extern void qlt_host_reset_handler(struct qla_hw_data *ha);
+ extern int qla_get_exlogin_status(scsi_qla_host_t *, uint16_t *,
+ 	uint16_t *);
+ extern int qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr);
+ extern int qla_get_exchoffld_status(scsi_qla_host_t *, uint16_t *, uint16_t *);
+ extern int qla_set_exchoffld_mem_cfg(scsi_qla_host_t *, dma_addr_t);
+ 
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,b3ed3b3ff55e..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1841,9 -1843,23 +1841,29 @@@ qla2x00_setup_chip(scsi_qla_host_t *vha
  			ql_dbg(ql_dbg_init, vha, 0x00ca,
  			    "Starting firmware.\n");
  
++<<<<<<< HEAD
 +			rval = qla2x00_execute_fw(vha, srisc_address);
 +			/* Retrieve firmware information. */
 +			if (rval == QLA_SUCCESS) {
++=======
+ 			if (ql2xexlogins)
+ 				ha->flags.exlogins_enabled = 1;
+ 
+ 			if (ql2xexchoffld)
+ 				ha->flags.exchoffld_enabled = 1;
+ 
+ 			rval = qla2x00_execute_fw(vha, srisc_address);
+ 			/* Retrieve firmware information. */
+ 			if (rval == QLA_SUCCESS) {
+ 				rval = qla2x00_set_exlogins_buffer(vha);
+ 				if (rval != QLA_SUCCESS)
+ 					goto failed;
+ 
+ 				rval = qla2x00_set_exchoffld_buffer(vha);
+ 				if (rval != QLA_SUCCESS)
+ 					goto failed;
+ 
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  enable_82xx_npiv:
  				fw_major_version = ha->fw_major_version;
  				if (IS_P3P_TYPE(ha))
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index b8143a854ee5,c7ca2235c60a..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -527,6 -489,13 +527,16 @@@ qla2x00_execute_fw(scsi_qla_host_t *vha
  			    EXTENDED_BB_CREDITS);
  		} else
  			mcp->mb[4] = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		if (ha->flags.exlogins_enabled)
+ 			mcp->mb[4] |= ENABLE_EXTENDED_LOGIN;
+ 
+ 		if (ha->flags.exchoffld_enabled)
+ 			mcp->mb[4] |= ENABLE_EXCHANGE_OFFLD;
+ 
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  		mcp->out_mb |= MBX_4|MBX_3|MBX_2|MBX_1;
  		mcp->in_mb |= MBX_1;
  	} else {
@@@ -559,6 -528,226 +569,229 @@@
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * qla_get_exlogin_status
+  *	Get extended login status
+  *	uses the memory offload control/status Mailbox
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	fwopt:		firmware options
+  *
+  * Returns:
+  *	qla2x00 local function status
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define	FETCH_XLOGINS_STAT	0x8
+ int
+ qla_get_exlogin_status(scsi_qla_host_t *vha, uint16_t *buf_sz,
+ 	uint16_t *ex_logins_cnt)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118f,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = FETCH_XLOGINS_STAT;
+ 	mcp->out_mb = MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_10|MBX_4|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1115, "Failed=%x.\n", rval);
+ 	} else {
+ 		*buf_sz = mcp->mb[4];
+ 		*ex_logins_cnt = mcp->mb[10];
+ 
+ 		ql_log(ql_log_info, vha, 0x1190,
+ 		    "buffer size 0x%x, exchange login count=%d\n",
+ 		    mcp->mb[4], mcp->mb[10]);
+ 
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1116,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+  * qla_set_exlogin_mem_cfg
+  *	set extended login memory configuration
+  *	Mbx needs to be issues before init_cb is set
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	buffer:		buffer pointer
+  *	phys_addr:	physical address of buffer
+  *	size:		size of buffer
+  *	TARGET_QUEUE_LOCK must be released
+  *	ADAPTER_STATE_LOCK must be release
+  *
+  * Returns:
+  *	qla2x00 local funxtion status code.
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define CONFIG_XLOGINS_MEM	0x3
+ int
+ qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr)
+ {
+ 	int		rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	int configured_count;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111a,
+ 	    "Entered %s.\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = CONFIG_XLOGINS_MEM;
+ 	mcp->mb[2] = MSW(phys_addr);
+ 	mcp->mb[3] = LSW(phys_addr);
+ 	mcp->mb[6] = MSW(MSD(phys_addr));
+ 	mcp->mb[7] = LSW(MSD(phys_addr));
+ 	mcp->mb[8] = MSW(ha->exlogin_size);
+ 	mcp->mb[9] = LSW(ha->exlogin_size);
+ 	mcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_11|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		/*EMPTY*/
+ 		ql_dbg(ql_dbg_mbx, vha, 0x111b, "Failed=%x.\n", rval);
+ 	} else {
+ 		configured_count = mcp->mb[11];
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118c,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+  * qla_get_exchoffld_status
+  *	Get exchange offload status
+  *	uses the memory offload control/status Mailbox
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	fwopt:		firmware options
+  *
+  * Returns:
+  *	qla2x00 local function status
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define	FETCH_XCHOFFLD_STAT	0x2
+ int
+ qla_get_exchoffld_status(scsi_qla_host_t *vha, uint16_t *buf_sz,
+ 	uint16_t *ex_logins_cnt)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1019,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = FETCH_XCHOFFLD_STAT;
+ 	mcp->out_mb = MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_10|MBX_4|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1155, "Failed=%x.\n", rval);
+ 	} else {
+ 		*buf_sz = mcp->mb[4];
+ 		*ex_logins_cnt = mcp->mb[10];
+ 
+ 		ql_log(ql_log_info, vha, 0x118e,
+ 		    "buffer size 0x%x, exchange offload count=%d\n",
+ 		    mcp->mb[4], mcp->mb[10]);
+ 
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1156,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+  * qla_set_exchoffld_mem_cfg
+  *	Set exchange offload memory configuration
+  *	Mbx needs to be issues before init_cb is set
+  *
+  * Input:
+  *	ha:		adapter state pointer.
+  *	buffer:		buffer pointer
+  *	phys_addr:	physical address of buffer
+  *	size:		size of buffer
+  *	TARGET_QUEUE_LOCK must be released
+  *	ADAPTER_STATE_LOCK must be release
+  *
+  * Returns:
+  *	qla2x00 local funxtion status code.
+  *
+  * Context:
+  *	Kernel context.
+  */
+ #define CONFIG_XCHOFFLD_MEM	0x3
+ int
+ qla_set_exchoffld_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr)
+ {
+ 	int		rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1157,
+ 	    "Entered %s.\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+ 	mcp->mb[1] = CONFIG_XCHOFFLD_MEM;
+ 	mcp->mb[2] = MSW(phys_addr);
+ 	mcp->mb[3] = LSW(phys_addr);
+ 	mcp->mb[6] = MSW(MSD(phys_addr));
+ 	mcp->mb[7] = LSW(MSD(phys_addr));
+ 	mcp->mb[8] = MSW(ha->exlogin_size);
+ 	mcp->mb[9] = LSW(ha->exlogin_size);
+ 	mcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_11|MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval != QLA_SUCCESS) {
+ 		/*EMPTY*/
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1158, "Failed=%x.\n", rval);
+ 	} else {
+ 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1192,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
   * qla2x00_get_fw_version
   *	Get firmware version.
   *
@@@ -633,6 -821,16 +866,19 @@@ qla2x00_get_fw_version(scsi_qla_host_t 
  		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x112f,
  		    "%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\n",
  		    __func__, mcp->mb[17], mcp->mb[16]);
++<<<<<<< HEAD
++=======
+ 
+ 		if (ha->fw_attributes_h & 0x4)
+ 			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118d,
+ 			    "%s: Firmware supports Extended Login 0x%x\n",
+ 			    __func__, ha->fw_attributes_h);
+ 
+ 		if (ha->fw_attributes_h & 0x8)
+ 			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1191,
+ 			    "%s: Firmware supports Exchange Offload 0x%x\n",
+ 			    __func__, ha->fw_attributes_h);
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  	}
  
  	if (IS_QLA27XX(ha)) {
diff --cc drivers/scsi/qla2xxx/qla_os.c
index ae651df67490,266dd746841a..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -217,13 -221,18 +217,19 @@@ MODULE_PARM_DESC(ql2xmdenable
  		"0 - MiniDump disabled. "
  		"1 (Default) - MiniDump enabled.");
  
 -int ql2xexlogins = 0;
 -module_param(ql2xexlogins, uint, S_IRUGO|S_IWUSR);
 -MODULE_PARM_DESC(ql2xexlogins,
 -		 "Number of extended Logins. "
 -		 "0 (Default)- Disabled.");
 +int ql2xfwholdabts = 0;
 +module_param(ql2xfwholdabts, int, S_IRUGO);
 +MODULE_PARM_DESC(ql2xfwholdabts,
 +		"Allow FW to hold status IOCB until ABTS rsp received. "
 +		"0 (Default) Do not set fw option. "
 +		"1 - Set fw option to hold ABTS.");
  
+ int ql2xexchoffld = 0;
+ module_param(ql2xexchoffld, uint, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(ql2xexchoffld,
+ 		 "Number of exchanges to offload. "
+ 		 "0 (Default)- Disabled.");
+ 
  /*
   * SCSI host template entry points
   */
@@@ -3479,6 -3140,14 +3485,17 @@@ qla2x00_remove_one(struct pci_dev *pdev
  
  	base_vha->flags.online = 0;
  
++<<<<<<< HEAD
++=======
+ 	/* free DMA memory */
+ 	if (ha->exlogin_buf)
+ 		qla2x00_free_exlogin_buffer(ha);
+ 
+ 	/* free DMA memory */
+ 	if (ha->exchoffld_buf)
+ 		qla2x00_free_exchoffld_buffer(ha);
+ 
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  	qla2x00_destroy_deferred_work(ha);
  
  	qlt_remove_target(ha, base_vha);
@@@ -3951,6 -3607,140 +3968,143 @@@ fail
  	return -ENOMEM;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ qla2x00_set_exlogins_buffer(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	uint16_t	size, max_cnt, temp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	/* Return if we don't need to alloacate any extended logins */
+ 	if (!ql2xexlogins)
+ 		return QLA_SUCCESS;
+ 
+ 	ql_log(ql_log_info, vha, 0xd021, "EXLOGIN count: %d.\n", ql2xexlogins);
+ 	max_cnt = 0;
+ 	rval = qla_get_exlogin_status(vha, &size, &max_cnt);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd029,
+ 		    "Failed to get exlogin status.\n");
+ 		return rval;
+ 	}
+ 
+ 	temp = (ql2xexlogins > max_cnt) ? max_cnt : ql2xexlogins;
+ 	ha->exlogin_size = (size * temp);
+ 	ql_log(ql_log_info, vha, 0xd024,
+ 		"EXLOGIN: max_logins=%d, portdb=0x%x, total=%d.\n",
+ 		max_cnt, size, temp);
+ 
+ 	ql_log(ql_log_info, vha, 0xd025, "EXLOGIN: requested size=0x%x\n",
+ 		ha->exlogin_size);
+ 
+ 	/* Get consistent memory for extended logins */
+ 	ha->exlogin_buf = dma_alloc_coherent(&ha->pdev->dev,
+ 	    ha->exlogin_size, &ha->exlogin_buf_dma, GFP_KERNEL);
+ 	if (!ha->exlogin_buf) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd02a,
+ 		    "Failed to allocate memory for exlogin_buf_dma.\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* Now configure the dma buffer */
+ 	rval = qla_set_exlogin_mem_cfg(vha, ha->exlogin_buf_dma);
+ 	if (rval) {
+ 		ql_log(ql_log_fatal, vha, 0x00cf,
+ 		    "Setup extended login buffer  ****FAILED****.\n");
+ 		qla2x00_free_exlogin_buffer(ha);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+ * qla2x00_free_exlogin_buffer
+ *
+ * Input:
+ *	ha = adapter block pointer
+ */
+ void
+ qla2x00_free_exlogin_buffer(struct qla_hw_data *ha)
+ {
+ 	if (ha->exlogin_buf) {
+ 		dma_free_coherent(&ha->pdev->dev, ha->exlogin_size,
+ 		    ha->exlogin_buf, ha->exlogin_buf_dma);
+ 		ha->exlogin_buf = NULL;
+ 		ha->exlogin_size = 0;
+ 	}
+ }
+ 
+ int
+ qla2x00_set_exchoffld_buffer(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	uint16_t	size, max_cnt, temp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	/* Return if we don't need to alloacate any extended logins */
+ 	if (!ql2xexchoffld)
+ 		return QLA_SUCCESS;
+ 
+ 	ql_log(ql_log_info, vha, 0xd014,
+ 	    "Exchange offload count: %d.\n", ql2xexlogins);
+ 
+ 	max_cnt = 0;
+ 	rval = qla_get_exchoffld_status(vha, &size, &max_cnt);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd012,
+ 		    "Failed to get exlogin status.\n");
+ 		return rval;
+ 	}
+ 
+ 	temp = (ql2xexchoffld > max_cnt) ? max_cnt : ql2xexchoffld;
+ 	ha->exchoffld_size = (size * temp);
+ 	ql_log(ql_log_info, vha, 0xd016,
+ 		"Exchange offload: max_count=%d, buffers=0x%x, total=%d.\n",
+ 		max_cnt, size, temp);
+ 
+ 	ql_log(ql_log_info, vha, 0xd017,
+ 	    "Exchange Buffers requested size = 0x%x\n", ha->exchoffld_size);
+ 
+ 	/* Get consistent memory for extended logins */
+ 	ha->exchoffld_buf = dma_alloc_coherent(&ha->pdev->dev,
+ 	    ha->exchoffld_size, &ha->exchoffld_buf_dma, GFP_KERNEL);
+ 	if (!ha->exchoffld_buf) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd013,
+ 		    "Failed to allocate memory for exchoffld_buf_dma.\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* Now configure the dma buffer */
+ 	rval = qla_set_exchoffld_mem_cfg(vha, ha->exchoffld_buf_dma);
+ 	if (rval) {
+ 		ql_log(ql_log_fatal, vha, 0xd02e,
+ 		    "Setup exchange offload buffer ****FAILED****.\n");
+ 		qla2x00_free_exchoffld_buffer(ha);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+ * qla2x00_free_exchoffld_buffer
+ *
+ * Input:
+ *	ha = adapter block pointer
+ */
+ void
+ qla2x00_free_exchoffld_buffer(struct qla_hw_data *ha)
+ {
+ 	if (ha->exchoffld_buf) {
+ 		dma_free_coherent(&ha->pdev->dev, ha->exchoffld_size,
+ 		    ha->exchoffld_buf, ha->exchoffld_buf_dma);
+ 		ha->exchoffld_buf = NULL;
+ 		ha->exchoffld_size = 0;
+ 	}
+ }
+ 
++>>>>>>> 2f56a7f1b5d8 (qla2xxx: Enable Exchange offload support.)
  /*
  * qla2x00_free_fw_dump
  *	Frees fw dump stuff.
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
