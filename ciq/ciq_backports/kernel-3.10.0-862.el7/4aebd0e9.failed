KVM: SVM: introduce disable_nmi_singlestep helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ladi Prosek <lprosek@redhat.com>
commit 4aebd0e9ca3776368813239018287021002b8973
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4aebd0e9.failed

Just moving the code to a new helper in preparation for following
commits.

	Signed-off-by: Ladi Prosek <lprosek@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4aebd0e9ca3776368813239018287021002b8973)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index 673cbc167bdc,7dda9c4ee485..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -925,6 -963,63 +925,66 @@@ static void svm_disable_lbrv(struct vcp
  	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void disable_nmi_singlestep(struct vcpu_svm *svm)
+ {
+ 	svm->nmi_singlestep = false;
+ 	if (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))
+ 		svm->vmcb->save.rflags &=
+ 			~(X86_EFLAGS_TF | X86_EFLAGS_RF);
+ }
+ 
+ /* Note:
+  * This hash table is used to map VM_ID to a struct kvm_arch,
+  * when handling AMD IOMMU GALOG notification to schedule in
+  * a particular vCPU.
+  */
+ #define SVM_VM_DATA_HASH_BITS	8
+ static DEFINE_HASHTABLE(svm_vm_data_hash, SVM_VM_DATA_HASH_BITS);
+ static DEFINE_SPINLOCK(svm_vm_data_hash_lock);
+ 
+ /* Note:
+  * This function is called from IOMMU driver to notify
+  * SVM to schedule in a particular vCPU of a particular VM.
+  */
+ static int avic_ga_log_notifier(u32 ga_tag)
+ {
+ 	unsigned long flags;
+ 	struct kvm_arch *ka = NULL;
+ 	struct kvm_vcpu *vcpu = NULL;
+ 	u32 vm_id = AVIC_GATAG_TO_VMID(ga_tag);
+ 	u32 vcpu_id = AVIC_GATAG_TO_VCPUID(ga_tag);
+ 
+ 	pr_debug("SVM: %s: vm_id=%#x, vcpu_id=%#x\n", __func__, vm_id, vcpu_id);
+ 
+ 	spin_lock_irqsave(&svm_vm_data_hash_lock, flags);
+ 	hash_for_each_possible(svm_vm_data_hash, ka, hnode, vm_id) {
+ 		struct kvm *kvm = container_of(ka, struct kvm, arch);
+ 		struct kvm_arch *vm_data = &kvm->arch;
+ 
+ 		if (vm_data->avic_vm_id != vm_id)
+ 			continue;
+ 		vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);
+ 		break;
+ 	}
+ 	spin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);
+ 
+ 	if (!vcpu)
+ 		return 0;
+ 
+ 	/* Note:
+ 	 * At this point, the IOMMU should have already set the pending
+ 	 * bit in the vAPIC backing page. So, we just need to schedule
+ 	 * in the vcpu.
+ 	 */
+ 	if (vcpu->mode == OUTSIDE_GUEST_MODE)
+ 		kvm_vcpu_wake_up(vcpu);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4aebd0e9ca37 (KVM: SVM: introduce disable_nmi_singlestep helper)
  static __init int svm_hardware_setup(void)
  {
  	int cpu;
* Unmerged path arch/x86/kvm/svm.c
