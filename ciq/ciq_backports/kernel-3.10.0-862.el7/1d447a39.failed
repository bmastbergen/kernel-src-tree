net/mlx5e: Extendable vport representor netdev private data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Extendable vport representor netdev private data (Don Dutile) [1499362 1456694]
Rebuild_FUZZ: 96.49%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 1d447a39142e0eaf8526fcb37699e6b8cce5eaa8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1d447a39.failed

Make representor netdev private data extendable by adding new struct
"mlx5e_rep_priv" and use it as the rep netdev private data struct
instead of directly pointing to mlx5_eswitch_rep.

Added new en_rep.h header file to contain all representor related
definitions and prototypes, and moved all representor specific logic
into en_rep.c.

Needed for downstream patches to extend representor functionality to
support neighbour update.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
(cherry picked from commit 1d447a39142e0eaf8526fcb37699e6b8cce5eaa8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index f6e3d4bf0928,0099a3e397bc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -886,48 -989,43 +886,70 @@@ void mlx5e_destroy_tir(struct mlx5_core
  		       struct mlx5e_tir *tir);
  int mlx5e_create_mdev_resources(struct mlx5_core_dev *mdev);
  void mlx5e_destroy_mdev_resources(struct mlx5_core_dev *mdev);
 -int mlx5e_refresh_tirs(struct mlx5e_priv *priv, bool enable_uc_lb);
 -
 +int mlx5e_refresh_tirs_self_loopback(struct mlx5_core_dev *mdev,
 +				     bool enable_uc_lb);
 +
++<<<<<<< HEAD
 +struct mlx5_eswitch_rep;
 +int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
 +			 struct mlx5_eswitch_rep *rep);
 +void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
 +			    struct mlx5_eswitch_rep *rep);
 +int mlx5e_nic_rep_load(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep);
 +void mlx5e_nic_rep_unload(struct mlx5_eswitch *esw,
 +			  struct mlx5_eswitch_rep *rep);
 +int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 +void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 +int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 +void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 +void mlx5e_update_hw_rep_counters(struct mlx5e_priv *priv);
++=======
+ /* common netdev helpers */
+ int mlx5e_create_indirect_rqt(struct mlx5e_priv *priv);
+ 
+ int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv);
+ void mlx5e_destroy_indirect_tirs(struct mlx5e_priv *priv);
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  
  int mlx5e_create_direct_rqts(struct mlx5e_priv *priv);
 -void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv);
 +void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
  int mlx5e_create_direct_tirs(struct mlx5e_priv *priv);
  void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv);
 -void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
 -
 -int mlx5e_create_ttc_table(struct mlx5e_priv *priv, u32 underlay_qpn);
 -void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv);
 -
 -int mlx5e_create_tis(struct mlx5_core_dev *mdev, int tc,
 -		     u32 underlay_qpn, u32 *tisn);
 -void mlx5e_destroy_tis(struct mlx5_core_dev *mdev, u32 tisn);
 -
  int mlx5e_create_tises(struct mlx5e_priv *priv);
  void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
  int mlx5e_close(struct net_device *netdev);
  int mlx5e_open(struct net_device *netdev);
  void mlx5e_update_stats_work(struct work_struct *work);
 +struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
 +				       const struct mlx5e_profile *profile,
 +				       void *ppriv);
 +void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv);
 +int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 +void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
  u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout);
 -
 +void mlx5e_add_vxlan_port(struct net_device *netdev,
 +			  struct udp_tunnel_info *ti);
 +void mlx5e_del_vxlan_port(struct net_device *netdev,
 +			  struct udp_tunnel_info *ti);
 +
++<<<<<<< HEAD
 +int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev,
 +			    void *sp);
 +bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 +
 +bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 +bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv);
++=======
+ /* mlx5e generic netdev management API */
+ struct net_device*
+ mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
+ 		    void *ppriv);
+ int mlx5e_attach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_detach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_destroy_netdev(struct mlx5e_priv *priv);
+ void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
+ 			    struct mlx5e_params *params,
+ 			    u16 max_channels);
+ 
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,1afaca96a30d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -34,9 -34,11 +34,14 @@@
  #include <net/pkt_cls.h>
  #include <linux/mlx5/fs.h>
  #include <net/vxlan.h>
++<<<<<<< HEAD
++=======
+ #include <linux/bpf.h>
+ #include "eswitch.h"
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  #include "en.h"
  #include "en_tc.h"
- #include "eswitch.h"
+ #include "en_rep.h"
  #include "vxlan.h"
  
  struct mlx5e_rq_param {
@@@ -3613,21 -4128,22 +3618,38 @@@ static void mlx5e_nic_enable(struct mlx
  {
  	struct net_device *netdev = priv->netdev;
  	struct mlx5_core_dev *mdev = priv->mdev;
++<<<<<<< HEAD
 +	struct mlx5_eswitch *esw = mdev->priv.eswitch;
 +	struct mlx5_eswitch_rep rep;
++=======
+ 	u16 max_mtu;
+ 
+ 	mlx5e_init_l2_addr(priv);
+ 
+ 	/* MTU range: 68 - hw-specific max */
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	mlx5_query_port_max_mtu(priv->mdev, &max_mtu, 1);
+ 	netdev->max_mtu = MLX5E_HW2SW_MTU(max_mtu);
+ 	mlx5e_set_dev_port_mtu(priv);
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  
  	mlx5_lag_add(mdev, netdev);
  
  	mlx5e_enable_async_events(priv);
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_GEN(mdev, vport_group_manager)) {
 +		mlx5_query_nic_vport_mac_address(mdev, 0, rep.hw_id);
 +		rep.load = mlx5e_nic_rep_load;
 +		rep.unload = mlx5e_nic_rep_unload;
 +		rep.vport = FDB_UPLINK_VPORT;
 +		rep.netdev = netdev;
 +		mlx5_eswitch_register_vport_rep(esw, 0, &rep);
 +	}
++=======
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		mlx5e_register_vport_reps(priv);
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  
  	if (netdev->reg_state != NETREG_REGISTERED)
  		return;
@@@ -3645,11 -4167,18 +3667,15 @@@
  static void mlx5e_nic_disable(struct mlx5e_priv *priv)
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
- 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
  
 -	rtnl_lock();
 -	if (netif_running(priv->netdev))
 -		mlx5e_close(priv->netdev);
 -	netif_device_detach(priv->netdev);
 -	rtnl_unlock();
 -
  	queue_work(priv->wq, &priv->set_rx_mode_work);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  	if (MLX5_CAP_GEN(mdev, vport_group_manager))
- 		mlx5_eswitch_unregister_vport_rep(esw, 0);
+ 		mlx5e_unregister_vport_reps(priv);
+ 
  	mlx5e_disable_async_events(priv);
  	mlx5_lag_remove(mdev);
  }
@@@ -3926,7 -4412,8 +3961,12 @@@ static void mlx5e_remove(struct mlx5_co
  
  	unregister_netdev(priv->netdev);
  	mlx5e_detach(mdev, vpriv);
++<<<<<<< HEAD
 +	mlx5e_destroy_netdev(mdev, priv);
++=======
+ 	mlx5e_destroy_netdev(priv);
+ 	kfree(ppriv);
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  }
  
  static void *mlx5e_get_netdev(void *vpriv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d,8e82b11afd99..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -182,20 -187,21 +185,20 @@@ int mlx5e_attr_get(struct net_device *d
  }
  
  int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv)
- 
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
- 	struct mlx5_eswitch_rep *rep = priv->ppriv;
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
  	struct mlx5e_channel *c;
 -	int n, tc, num_sqs = 0;
 -	int err = -ENOMEM;
 +	int n, tc, err, num_sqs = 0;
  	u16 *sqs;
  
 -	sqs = kcalloc(priv->channels.num * priv->channels.params.num_tc, sizeof(u16), GFP_KERNEL);
 +	sqs = kcalloc(priv->params.num_channels * priv->params.num_tc, sizeof(u16), GFP_KERNEL);
  	if (!sqs)
 -		goto out;
 +		return -ENOMEM;
  
 -	for (n = 0; n < priv->channels.num; n++) {
 -		c = priv->channels.c[n];
 +	for (n = 0; n < priv->params.num_channels; n++) {
 +		c = priv->channel[n];
  		for (tc = 0; tc < c->num_tc; tc++)
  			sqs[num_sqs++] = c->sq[tc].sqn;
  	}
@@@ -323,9 -318,10 +312,10 @@@ bool mlx5e_is_uplink_rep(struct mlx5e_p
  	return false;
  }
  
 -static bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv)
 +bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv)
  {
- 	struct mlx5_eswitch_rep *rep = (struct mlx5_eswitch_rep *)priv->ppriv;
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
  
  	if (rep && rep->vport != FDB_UPLINK_VPORT)
  		return true;
@@@ -469,23 -454,20 +459,28 @@@ static void mlx5e_init_rep(struct mlx5_
  static int mlx5e_init_rep_rx(struct mlx5e_priv *priv)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++<<<<<<< HEAD
 +	struct mlx5_eswitch_rep *rep = priv->ppriv;
 +	struct mlx5_core_dev *mdev = priv->mdev;
++=======
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  	struct mlx5_flow_handle *flow_rule;
  	int err;
 -
 -	mlx5e_init_l2_addr(priv);
 +	int i;
  
  	err = mlx5e_create_direct_rqts(priv);
 -	if (err)
 +	if (err) {
 +		mlx5_core_warn(mdev, "create direct rqts failed, %d\n", err);
  		return err;
 +	}
  
  	err = mlx5e_create_direct_tirs(priv);
 -	if (err)
 +	if (err) {
 +		mlx5_core_warn(mdev, "create direct tirs failed, %d\n", err);
  		goto err_destroy_direct_rqts;
 +	}
  
  	flow_rule = mlx5_eswitch_create_vport_rx_rule(esw,
  						      rep->vport,
@@@ -514,8 -495,8 +509,13 @@@ err_destroy_direct_rqts
  
  static void mlx5e_cleanup_rep_rx(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	struct mlx5_eswitch_rep *rep = priv->ppriv;
 +	int i;
++=======
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5_eswitch_rep *rep = rpriv->rep;
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  
  	mlx5e_tc_cleanup(priv);
  	mlx5_del_flow_rules(rep->vport_rx_rule);
@@@ -567,8 -582,9 +600,9 @@@ mlx5e_vport_rep_load(struct mlx5_eswitc
  	}
  
  	rep->netdev = netdev;
+ 	rpriv->rep = rep;
  
 -	err = mlx5e_attach_netdev(netdev_priv(netdev));
 +	err = mlx5e_attach_netdev(esw->dev, netdev);
  	if (err) {
  		pr_warn("Failed to attach representor netdev for vport %d\n",
  			rep->vport);
@@@ -585,21 -601,81 +619,91 @@@
  	return 0;
  
  err_detach_netdev:
 -	mlx5e_detach_netdev(netdev_priv(netdev));
 +	mlx5e_detach_netdev(esw->dev, netdev);
  
  err_destroy_netdev:
++<<<<<<< HEAD
 +	mlx5e_destroy_netdev(esw->dev, netdev_priv(netdev));
 +
++=======
+ 	mlx5e_destroy_netdev(netdev_priv(netdev));
+ 	kfree(rpriv);
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  	return err;
  
  }
  
- void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
- 			    struct mlx5_eswitch_rep *rep)
+ static void
+ mlx5e_vport_rep_unload(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
  {
  	struct net_device *netdev = rep->netdev;
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	void *ppriv = priv->ppriv;
  
  	unregister_netdev(netdev);
++<<<<<<< HEAD
 +	mlx5e_detach_netdev(esw->dev, netdev);
 +	mlx5e_destroy_netdev(esw->dev, netdev_priv(netdev));
++=======
+ 	mlx5e_detach_netdev(priv);
+ 	mlx5e_destroy_netdev(priv);
+ 	kfree(ppriv); /* mlx5e_rep_priv */
+ }
+ 
+ static void mlx5e_rep_register_vf_vports(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 	u8 mac[ETH_ALEN];
+ 
+ 	mlx5_query_nic_vport_mac_address(mdev, 0, mac);
+ 
+ 	for (vport = 1; vport < total_vfs; vport++) {
+ 		struct mlx5_eswitch_rep rep;
+ 
+ 		rep.load = mlx5e_vport_rep_load;
+ 		rep.unload = mlx5e_vport_rep_unload;
+ 		rep.vport = vport;
+ 		ether_addr_copy(rep.hw_id, mac);
+ 		mlx5_eswitch_register_vport_rep(esw, vport, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_rep_unregister_vf_vports(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ }
+ 
+ void mlx5e_register_vport_reps(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep rep;
+ 
+ 	mlx5_query_nic_vport_mac_address(mdev, 0, rep.hw_id);
+ 	rep.load = mlx5e_nic_rep_load;
+ 	rep.unload = mlx5e_nic_rep_unload;
+ 	rep.vport = FDB_UPLINK_VPORT;
+ 	rep.netdev = priv->netdev;
+ 	mlx5_eswitch_register_vport_rep(esw, 0, &rep); /* UPLINK PF vport*/
+ 
+ 	mlx5e_rep_register_vf_vports(priv); /* VFs vports */
+ }
+ 
+ void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 
+ 	mlx5e_rep_unregister_vf_vports(priv); /* VFs vports */
+ 	mlx5_eswitch_unregister_vport_rep(esw, 0); /* UPLINK PF*/
++>>>>>>> 1d447a39142e (net/mlx5e: Extendable vport representor netdev private data)
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
new file mode 100644
index 000000000000..b6595a699dc1
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2017, Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __MLX5E_REP_H__
+#define __MLX5E_REP_H__
+
+#include "eswitch.h"
+#include "en.h"
+
+struct mlx5e_rep_priv {
+	struct mlx5_eswitch_rep *rep;
+};
+
+void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
+bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
+int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
+void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
+
+int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
+bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
+
+int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
+void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
+
+#endif /* __MLX5E_REP_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index 6ec114011e25..acdb0c2c97e0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@ -38,6 +38,7 @@
 #include "en.h"
 #include "en_tc.h"
 #include "eswitch.h"
+#include "en_rep.h"
 #include "ipoib.h"
 
 static inline bool mlx5e_rx_hw_stamp(struct mlx5e_tstamp *tstamp)
@@ -707,7 +708,8 @@ void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe)
 {
 	struct net_device *netdev = rq->netdev;
 	struct mlx5e_priv *priv = netdev_priv(netdev);
-	struct mlx5_eswitch_rep *rep = priv->ppriv;
+	struct mlx5e_rep_priv *rpriv  = priv->ppriv;
+	struct mlx5_eswitch_rep *rep = rpriv->rep;
 	struct mlx5e_rx_wqe *wqe;
 	struct sk_buff *skb;
 	__be16 wqe_counter_be;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 29674f9689a9..72ef2e9fcb7d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -45,6 +45,7 @@
 #include <net/vxlan.h>
 #include "en.h"
 #include "en_tc.h"
+#include "en_rep.h"
 #include "eswitch.h"
 #include "vxlan.h"
 
@@ -653,16 +654,18 @@ static int parse_cls_flower(struct mlx5e_priv *priv,
 {
 	struct mlx5_core_dev *dev = priv->mdev;
 	struct mlx5_eswitch *esw = dev->priv.eswitch;
-	struct mlx5_eswitch_rep *rep = priv->ppriv;
+	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+	struct mlx5_eswitch_rep *rep;
 	u8 min_inline;
 	int err;
 
 	err = __parse_cls_flower(priv, spec, f, &min_inline);
 
-	if (!err && (flow->flags & MLX5E_TC_FLOW_ESWITCH) &&
-	    rep->vport != FDB_UPLINK_VPORT) {
-		if (esw->offloads.inline_mode != MLX5_INLINE_MODE_NONE &&
-		    esw->offloads.inline_mode < min_inline) {
+	if (!err && (flow->flags & MLX5E_TC_FLOW_ESWITCH)) {
+		rep = rpriv->rep;
+		if (rep->vport != FDB_UPLINK_VPORT &&
+		    (esw->offloads.inline_mode != MLX5_INLINE_MODE_NONE &&
+		    esw->offloads.inline_mode < min_inline)) {
 			netdev_warn(priv->netdev,
 				    "Flow is not offloaded due to min inline setting, required %d actual %d\n",
 				    min_inline, esw->offloads.inline_mode);
@@ -1105,6 +1108,7 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 				struct mlx5e_tc_flow *flow)
 {
 	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
+	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 	struct ip_tunnel_info *info = NULL;
 	const struct tc_action *a;
 	bool encap = false;
@@ -1114,7 +1118,7 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 		return -EINVAL;
 
 	memset(attr, 0, sizeof(*attr));
-	attr->in_rep = priv->ppriv;
+	attr->in_rep = rpriv->rep;
 
 	tc_for_each_action(a, exts) {
 		if (is_tcf_gact_shot(a)) {
@@ -1135,7 +1139,8 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 				attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 					MLX5_FLOW_CONTEXT_ACTION_COUNT;
 				out_priv = netdev_priv(out_dev);
-				attr->out_rep = out_priv->ppriv;
+				rpriv = out_priv->ppriv;
+				attr->out_rep = rpriv->rep;
 			} else if (encap) {
 				err = mlx5e_attach_encap(priv, info,
 							 out_dev, attr);
@@ -1146,7 +1151,8 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 					MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 					MLX5_FLOW_CONTEXT_ACTION_COUNT;
 				out_priv = netdev_priv(attr->encap->out_dev);
-				attr->out_rep = out_priv->ppriv;
+				rpriv = out_priv->ppriv;
+				attr->out_rep = rpriv->rep;
 			} else {
 				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
 				       priv->netdev->name, out_dev->name);
