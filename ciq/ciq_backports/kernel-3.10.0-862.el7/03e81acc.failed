power_supply: Increment power supply use counter when obtaining references

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Krzysztof Kozlowski <k.kozlowski@samsung.com>
commit 03e81acce5568c7105dc5bef6984c8b0edfe8d45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/03e81acc.failed

Increment the power_supply.use_cnt usage counter on:
 - power_supply_get_by_phandle()
 - power_supply_get_by_name()
and decrement it on power_supply_put() call.

This helps tracking of valid usage of power supply instance by
consumers. The usage counter itself also allows safe calling of
power_supply_get_property-like functions even when driver unregisters
this power supply.

	Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
	Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Sebastian Reichel <sre@kernel.org>
(cherry picked from commit 03e81acce5568c7105dc5bef6984c8b0edfe8d45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/power/power_supply_core.c
diff --cc drivers/power/power_supply_core.c
index 0d8164e2f763,2ed4a4a6b3c5..000000000000
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@@ -319,11 -333,23 +319,12 @@@ static int power_supply_match_device_by
  	const char *name = data;
  	struct power_supply *psy = dev_get_drvdata(dev);
  
 -	return strcmp(psy->desc->name, name) == 0;
 +	return strcmp(psy->name, name) == 0;
  }
  
 -/**
 - * power_supply_get_by_name() - Search for a power supply and returns its ref
 - * @name: Power supply name to fetch
 - *
 - * If power supply was found, it increases reference count for the
 - * internal power supply's device. The user should power_supply_put()
 - * after usage.
 - *
 - * Return: On success returns a reference to a power supply with
 - * matching name equals to @name, a NULL otherwise.
 - */
  struct power_supply *power_supply_get_by_name(const char *name)
  {
+ 	struct power_supply *psy = NULL;
  	struct device *dev = class_find_device(power_supply_class, NULL, name,
  					power_supply_match_device_by_name);
  
@@@ -331,9 -362,112 +337,115 @@@
  }
  EXPORT_SYMBOL_GPL(power_supply_get_by_name);
  
++<<<<<<< HEAD
++=======
+ /**
+  * power_supply_put() - Drop reference obtained with power_supply_get_by_name
+  * @psy: Reference to put
+  *
+  * The reference to power supply should be put before unregistering
+  * the power supply.
+  */
+ void power_supply_put(struct power_supply *psy)
+ {
+ 	might_sleep();
+ 
+ 	atomic_dec(&psy->use_cnt);
+ 	put_device(&psy->dev);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_put);
+ 
+ #ifdef CONFIG_OF
+ static int power_supply_match_device_node(struct device *dev, const void *data)
+ {
+ 	return dev->parent && dev->parent->of_node == data;
+ }
+ 
+ /**
+  * power_supply_get_by_phandle() - Search for a power supply and returns its ref
+  * @np: Pointer to device node holding phandle property
+  * @phandle_name: Name of property holding a power supply name
+  *
+  * If power supply was found, it increases reference count for the
+  * internal power supply's device. The user should power_supply_put()
+  * after usage.
+  *
+  * Return: On success returns a reference to a power supply with
+  * matching name equals to value under @property, NULL or ERR_PTR otherwise.
+  */
+ struct power_supply *power_supply_get_by_phandle(struct device_node *np,
+ 							const char *property)
+ {
+ 	struct device_node *power_supply_np;
+ 	struct power_supply *psy = NULL;
+ 	struct device *dev;
+ 
+ 	power_supply_np = of_parse_phandle(np, property, 0);
+ 	if (!power_supply_np)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	dev = class_find_device(power_supply_class, NULL, power_supply_np,
+ 						power_supply_match_device_node);
+ 
+ 	of_node_put(power_supply_np);
+ 
+ 	if (dev) {
+ 		psy = dev_get_drvdata(dev);
+ 		atomic_inc(&psy->use_cnt);
+ 	}
+ 
+ 	return psy;
+ }
+ EXPORT_SYMBOL_GPL(power_supply_get_by_phandle);
+ #endif /* CONFIG_OF */
+ 
+ int power_supply_get_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    union power_supply_propval *val)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->get_property(psy, psp, val);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_get_property);
+ 
+ int power_supply_set_property(struct power_supply *psy,
+ 			    enum power_supply_property psp,
+ 			    const union power_supply_propval *val)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 || !psy->desc->set_property)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->set_property(psy, psp, val);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_set_property);
+ 
+ int power_supply_property_is_writeable(struct power_supply *psy,
+ 					enum power_supply_property psp)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 ||
+ 			!psy->desc->property_is_writeable)
+ 		return -ENODEV;
+ 
+ 	return psy->desc->property_is_writeable(psy, psp);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_property_is_writeable);
+ 
+ void power_supply_external_power_changed(struct power_supply *psy)
+ {
+ 	if (atomic_read(&psy->use_cnt) <= 0 ||
+ 			!psy->desc->external_power_changed)
+ 		return;
+ 
+ 	psy->desc->external_power_changed(psy);
+ }
+ EXPORT_SYMBOL_GPL(power_supply_external_power_changed);
+ 
++>>>>>>> 03e81acce556 (power_supply: Increment power supply use counter when obtaining references)
  int power_supply_powers(struct power_supply *psy, struct device *dev)
  {
 -	return sysfs_create_link(&psy->dev.kobj, &dev->kobj, "powers");
 +	return sysfs_create_link(&psy->dev->kobj, &dev->kobj, "powers");
  }
  EXPORT_SYMBOL_GPL(power_supply_powers);
  
* Unmerged path drivers/power/power_supply_core.c
