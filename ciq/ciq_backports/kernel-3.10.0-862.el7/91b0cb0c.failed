ALSA: x86: Rename drv_status to connected

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 91b0cb0cc07bcb5114df2897531f4ea41c148c8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/91b0cb0c.failed

After the rewrite of the runtime PM code, we have only two driver
status: CONNECTED and DISCONNECTED.  So it's clearer to use a boolean
flag, and name it easier one, "connected".

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 91b0cb0cc07bcb5114df2897531f4ea41c148c8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
#	sound/x86/intel_hdmi_audio.h
#	sound/x86/intel_hdmi_lpe_audio.h
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,c83f02c2593e..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -154,81 -156,101 +154,107 @@@ static const struct snd_pcm_hardware sn
  	.fifo_size = HAD_FIFO_SIZE,
  };
  
 -/* Get the active PCM substream;
 - * Call had_substream_put() for unreferecing.
 - * Don't call this inside had_spinlock, as it takes by itself
 - */
 -static struct snd_pcm_substream *
 -had_substream_get(struct snd_intelhad *intelhaddata)
 -{
 -	struct snd_pcm_substream *substream;
 -	unsigned long flags;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
 -	substream = intelhaddata->stream_info.substream;
 -	if (substream)
 -		intelhaddata->stream_info.substream_refcount++;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
 -	return substream;
 -}
 -
 -/* Unref the active PCM substream;
 - * Don't call this inside had_spinlock, as it takes by itself
 - */
 -static void had_substream_put(struct snd_intelhad *intelhaddata)
 -{
 -	unsigned long flags;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
 -	intelhaddata->stream_info.substream_refcount--;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
 -}
 -
  /* Register access functions */
 -static inline void
 -mid_hdmi_audio_read(struct snd_intelhad *ctx, u32 reg, u32 *val)
 -{
 -	*val = ioread32(ctx->mmio_start + ctx->had_config_offset + reg);
 -}
  
 -static inline void
 -mid_hdmi_audio_write(struct snd_intelhad *ctx, u32 reg, u32 val)
 +int had_get_hwstate(struct snd_intelhad *intelhaddata)
  {
++<<<<<<< HEAD
 +	/* Check for device presence -SW state */
 +	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 +		pr_debug("%s:Device not connected:%d\n", __func__,
 +				intelhaddata->drv_status);
++=======
+ 	iowrite32(val, ctx->mmio_start + ctx->had_config_offset + reg);
+ }
+ 
+ static int had_read_register(struct snd_intelhad *intelhaddata,
+ 			     u32 offset, u32 *data)
+ {
+ 	if (!intelhaddata->connected)
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  		return -ENODEV;
 -
 -	mid_hdmi_audio_read(intelhaddata, offset, data);
 -	return 0;
 -}
 -
 -static void fixup_dp_config(struct snd_intelhad *intelhaddata,
 -			    u32 offset, u32 *data)
 -{
 -	if (intelhaddata->dp_output) {
 -		if (offset == AUD_CONFIG && (*data & AUD_CONFIG_VALID_BIT))
 -			*data |= AUD_CONFIG_DP_MODE | AUD_CONFIG_BLOCK_BIT;
  	}
 -}
  
++<<<<<<< HEAD
++=======
+ static int had_write_register(struct snd_intelhad *intelhaddata,
+ 			      u32 offset, u32 data)
+ {
+ 	if (!intelhaddata->connected)
+ 		return -ENODEV;
+ 
+ 	fixup_dp_config(intelhaddata, offset, &data);
+ 	mid_hdmi_audio_write(intelhaddata, offset, data);
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  	return 0;
  }
  
 -static int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
 -			   u32 data, u32 mask)
 +int had_get_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list query, void *caps)
  {
 -	u32 val_tmp;
 +	int retval;
  
++<<<<<<< HEAD
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_get_caps(query, caps);
++=======
+ 	if (!intelhaddata->connected)
+ 		return -ENODEV;
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  
 -	mid_hdmi_audio_read(intelhaddata, offset, &val_tmp);
 -	val_tmp &= ~mask;
 -	val_tmp |= (data & mask);
 +	return retval;
 +}
  
 -	fixup_dp_config(intelhaddata, offset, &val_tmp);
 -	mid_hdmi_audio_write(intelhaddata, offset, val_tmp);
 -	return 0;
 +int had_set_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list set_element, void *caps)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_set_caps(set_element, caps);
 +
 +	return retval;
  }
  
 -/*
 - * enable / disable audio configuration
 - *
 - * The had_read_modify() function should not directly be used on VLV2 for
 - * updating AUD_CONFIG register.
 +int had_read_register(struct snd_intelhad *intelhaddata, u32 offset, u32 *data)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_read(offset, data);
 +
 +	return retval;
 +}
 +
 +int had_write_register(struct snd_intelhad *intelhaddata, u32 offset, u32 data)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_write(offset, data);
 +
 +	return retval;
 +}
 +
 +int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
 +		    u32 data, u32 mask)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_rmw(offset, data, mask);
 +
 +	return retval;
 +}
 +/**
 + * function to read-modify
 + * AUD_CONFIG register on VLV2.The had_read_modify() function should not
 + * directly be used on VLV2 for updating AUD_CONFIG register.
   * This is because:
   * Bit6 of AUD_CONFIG register is writeonly due to a silicon bug on VLV2
   * HDMI IP. As a result a read-modify of AUD_CONFIG regiter will always
@@@ -552,18 -570,22 +578,18 @@@ static int had_chmap_ctl_get(struct snd
  {
  	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
  	struct snd_intelhad *intelhaddata = info->private_data;
 -	int i;
 +	int i = 0;
  	const struct snd_pcm_chmap_elem *chmap;
  
- 	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED)
+ 	if (!intelhaddata->connected)
  		return -ENODEV;
 -
 -	mutex_lock(&intelhaddata->mutex);
 -	if (!intelhaddata->chmap->chmap) {
 -		mutex_unlock(&intelhaddata->mutex);
 +	if (intelhaddata->chmap->chmap ==  NULL)
  		return -ENODATA;
 -	}
 -
  	chmap = intelhaddata->chmap->chmap;
 -	for (i = 0; i < chmap->channels; i++)
 +	for (i = 0; i < chmap->channels; i++) {
  		ucontrol->value.integer.value[i] = chmap->map[i];
 -	mutex_unlock(&intelhaddata->mutex);
 +		pr_debug("chmap->map[%d] = %d\n", i, chmap->map[i]);
 +	}
  
  	return 0;
  }
@@@ -955,29 -961,18 +981,35 @@@ static int snd_intelhad_open(struct snd
  {
  	struct snd_intelhad *intelhaddata;
  	struct snd_pcm_runtime *runtime;
 +	struct had_stream_pvt *stream;
 +	struct had_pvt_data *had_stream;
  	int retval;
  
 +	pr_debug("snd_intelhad_open called\n");
  	intelhaddata = snd_pcm_substream_chip(substream);
 +	had_stream = intelhaddata->private_data;
  	runtime = substream->runtime;
 +	intelhaddata->underrun_count = 0;
  
 -	pm_runtime_get_sync(intelhaddata->dev);
 +	pm_runtime_get(intelhaddata->dev);
  
++<<<<<<< HEAD
 +	if (had_get_hwstate(intelhaddata)) {
 +		pr_err("%s: HDMI cable plugged-out\n", __func__);
++=======
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "%s: HDMI cable plugged-out\n",
+ 			__func__);
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  		retval = -ENODEV;
 -		goto error;
 +		goto exit_put_handle;
 +	}
 +
 +	/* Check, if device already in use */
 +	if (runtime->private_data) {
 +		pr_err("Device already in use\n");
 +		retval = -EBUSY;
 +		goto exit_put_handle;
  	}
  
  	/* set the runtime hw parameter with local snd_pcm_hardware struct */
@@@ -1185,11 -1095,12 +1217,17 @@@ static int snd_intelhad_pcm_trigger(str
  
  	switch (cmd) {
  	case SNDRV_PCM_TRIGGER_START:
 -	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 -	case SNDRV_PCM_TRIGGER_RESUME:
 +		pr_debug("Trigger Start\n");
 +
  		/* Disable local INTRs till register prgmng is done */
++<<<<<<< HEAD
 +		if (had_get_hwstate(intelhaddata)) {
 +			pr_err("_START: HDMI cable plugged-out\n");
++=======
+ 		if (!intelhaddata->connected) {
+ 			dev_dbg(intelhaddata->dev,
+ 				"_START: HDMI cable plugged-out\n");
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  			retval = -ENODEV;
  			break;
  		}
@@@ -1263,10 -1149,10 +1301,16 @@@ static int snd_intelhad_pcm_prepare(str
  
  	intelhaddata = snd_pcm_substream_chip(substream);
  	runtime = substream->runtime;
 +	had_stream = intelhaddata->private_data;
  
++<<<<<<< HEAD
 +	if (had_get_hwstate(intelhaddata)) {
 +		pr_err("%s: HDMI cable plugged-out\n", __func__);
++=======
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "%s: HDMI cable plugged-out\n",
+ 			__func__);
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  		retval = -ENODEV;
  		goto prep_end;
  	}
@@@ -1352,14 -1217,10 +1396,18 @@@ static snd_pcm_uframes_t snd_intelhad_p
  	u32 t;
  	int buf_id;
  
 +	/* pr_debug("snd_intelhad_pcm_pointer called\n"); */
 +
  	intelhaddata = snd_pcm_substream_chip(substream);
  
++<<<<<<< HEAD
 +	if (intelhaddata->flag_underrun) {
 +		intelhaddata->flag_underrun = 0;
++=======
+ 	if (!intelhaddata->connected)
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  		return SNDRV_PCM_POS_XRUN;
 +	}
  
  	/* Use a hw register to calculate sub-period position reports.
  	 * This makes PulseAudio happier.
@@@ -1461,55 -1324,256 +1509,307 @@@ out
  	return retval;
  }
  
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
 +	.open =		snd_intelhad_open,
 +	.close =	snd_intelhad_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_intelhad_hw_params,
 +	.hw_free =	snd_intelhad_hw_free,
 +	.prepare =	snd_intelhad_pcm_prepare,
 +	.trigger =	snd_intelhad_pcm_trigger,
 +	.pointer =	snd_intelhad_pcm_pointer,
 +	.mmap =	snd_intelhad_pcm_mmap,
 +};
 +
 +/**
 + * snd_intelhad_create - to crete alsa card instance
 + *
 + * @intelhaddata: pointer to internal context
 + * @card: pointer to card
 + *
 + * This function is called when the hdmi cable is plugged in
 + */
 +static int snd_intelhad_create(
 +		struct snd_intelhad *intelhaddata,
 +		struct snd_card *card)
 +{
 +	int retval;
 +	static struct snd_device_ops ops = {
 +	};
 +
 +	pr_debug("snd_intelhad_create called\n");
 +
 +	if (!intelhaddata)
 +		return -EINVAL;
 +
 +	/* ALSA api to register the device */
 +	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelhaddata, &ops);
 +	return retval;
 +}
++<<<<<<< HEAD
 +/**
 + * snd_intelhad_pcm_free - to free the memory allocated
 + *
 + * @pcm: pointer to pcm instance
 + * This function is called when the device is removed
++=======
++
+ static inline int had_chk_intrmiss(struct snd_intelhad *intelhaddata,
+ 		enum intel_had_aud_buf_type buf_id)
+ {
+ 	int i, intr_count = 0;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	u32 buf_size, buf_addr;
+ 
+ 	buff_done = buf_id;
+ 
+ 	intr_count = snd_intelhad_read_len(intelhaddata);
+ 	if (intr_count > 1) {
+ 		/* In case of active playback */
+ 		dev_err(intelhaddata->dev,
+ 			"Driver detected %d missed buffer done interrupt(s)\n",
+ 			(intr_count - 1));
+ 		if (intr_count > 3)
+ 			return intr_count;
+ 
+ 		buf_id += (intr_count - 1);
+ 		/* Reprogram registers*/
+ 		for (i = buff_done; i < buf_id; i++) {
+ 			int j = i % 4;
+ 
+ 			buf_size = intelhaddata->buf_info[j].buf_size;
+ 			buf_addr = intelhaddata->buf_info[j].buf_addr;
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_LENGTH +
+ 					   (j * HAD_REG_WIDTH), buf_size);
+ 			had_write_register(intelhaddata,
+ 					   AUD_BUF_A_ADDR+(j * HAD_REG_WIDTH),
+ 					   (buf_addr | BIT(0) | BIT(1)));
+ 		}
+ 		buf_id = buf_id % 4;
+ 		intelhaddata->buff_done = buf_id;
+ 	}
+ 
+ 	return intr_count;
+ }
+ 
+ /* called from irq handler */
+ static int had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	u32 len = 1;
+ 	enum intel_had_aud_buf_type buf_id;
+ 	enum intel_had_aud_buf_type buff_done;
+ 	struct pcm_stream_info *stream;
+ 	struct snd_pcm_substream *substream;
+ 	u32 buf_size;
+ 	int intr_count;
+ 	unsigned long flags;
+ 
+ 	stream = &intelhaddata->stream_info;
+ 	intr_count = 1;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	if (!intelhaddata->connected) {
+ 		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	buff_done = intelhaddata->buff_done;
+ 	buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 
+ 	/* Every debug statement has an implication
+ 	 * of ~5msec. Thus, avoid having >3 debug statements
+ 	 * for each buffer_done handling.
+ 	 */
+ 
+ 	/* Check for any intr_miss in case of active playback */
+ 	if (stream->running) {
+ 		intr_count = had_chk_intrmiss(intelhaddata, buf_id);
+ 		if (!intr_count || (intr_count > 3)) {
+ 			spin_unlock_irqrestore(&intelhaddata->had_spinlock,
+ 					       flags);
+ 			dev_err(intelhaddata->dev,
+ 				"HAD SW state in non-recoverable mode\n");
+ 			return 0;
+ 		}
+ 		buf_id += (intr_count - 1);
+ 		buf_id = buf_id % 4;
+ 	}
+ 
+ 	intelhaddata->buf_info[buf_id].is_valid = true;
+ 	if (intelhaddata->valid_buf_cnt-1 == buf_id) {
+ 		if (stream->running)
+ 			intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 	} else
+ 		intelhaddata->curr_buf = buf_id + 1;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "HDMI cable plugged-out\n");
+ 		return 0;
+ 	}
+ 
+ 	/* Reprogram the registers with addr and length */
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			   buf_size);
+ 	had_write_register(intelhaddata,
+ 			   AUD_BUF_A_ADDR + (buf_id * HAD_REG_WIDTH),
+ 			   intelhaddata->buf_info[buf_id].buf_addr |
+ 			   BIT(0) | BIT(1));
+ 
+ 	had_read_register(intelhaddata,
+ 			  AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
+ 			  &len);
+ 	dev_dbg(intelhaddata->dev, "%s:Enabled buf[%d]\n", __func__, buf_id);
+ 
+ 	/* In case of actual data,
+ 	 * report buffer_done to above ALSA layer
+ 	 */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		buf_size = intelhaddata->buf_info[buf_id].buf_size;
+ 		intelhaddata->stream_info.buffer_rendered +=
+ 			(intr_count * buf_size);
+ 		snd_pcm_period_elapsed(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* called from irq handler */
+ static int had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct pcm_stream_info *stream;
+ 	struct snd_pcm_substream *substream;
+ 	unsigned long flags;
+ 	int connected;
+ 
+ 	stream = &intelhaddata->stream_info;
+ 
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	connected = intelhaddata->connected;
+ 	if (stream->running)
+ 		intelhaddata->curr_buf = HAD_BUF_TYPE_A;
+ 
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 
+ 	dev_dbg(intelhaddata->dev, "Enter:%s buf_id=%d, stream_running=%d\n",
+ 			__func__, buf_id, stream->running);
+ 
+ 	snd_intelhad_handle_underrun(intelhaddata);
+ 
+ 	if (!connected) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"%s:Device already disconnected\n", __func__);
+ 		return 0;
+ 	}
+ 
+ 	/* Report UNDERRUN error to above layers */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		snd_pcm_stop_xrun(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* process hot plug, called from wq with mutex locked */
+ static void had_process_hot_plug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct snd_pcm_substream *substream;
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	if (intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		return;
+ 	}
+ 
+ 	buf_id = intelhaddata->curr_buf;
+ 	intelhaddata->buff_done = buf_id;
+ 	intelhaddata->connected = true;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	dev_dbg(intelhaddata->dev, "Processing HOT_PLUG, buf_id = %d\n",
+ 		buf_id);
+ 
+ 	/* Safety check */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"Force to stop the active stream by disconnection\n");
+ 		/* Set runtime->state to hw_params done */
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ }
+ 
+ /* process hot unplug, called from wq with mutex locked */
+ static void had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	enum intel_had_aud_buf_type buf_id;
+ 	struct snd_pcm_substream *substream;
+ 
+ 	buf_id = intelhaddata->curr_buf;
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		goto out;
+ 
+ 	}
+ 
+ 	/* Disable Audio */
+ 	snd_intelhad_enable_audio_int(intelhaddata, false);
+ 	snd_intelhad_enable_audio(substream, intelhaddata, false);
+ 
+ 	intelhaddata->connected = false;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	/* Report to above ALSA layer */
+ 	if (substream)
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 
+  out:
+ 	if (substream)
+ 		had_substream_put(intelhaddata);
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ }
+ 
+ /*
+  * ALSA iec958 and ELD controls
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
   */
 +static void snd_intelhad_pcm_free(struct snd_pcm *pcm)
 +{
 +	pr_debug("Freeing PCM preallocated pages\n");
 +	snd_pcm_lib_preallocate_free_for_all(pcm);
 +}
  
  static int had_iec958_info(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_info *uinfo)
@@@ -1552,85 -1620,284 +1852,97 @@@ static int had_iec958_put(struct snd_kc
  		(ucontrol->value.iec958.status[1] << 8) |
  		(ucontrol->value.iec958.status[2] << 16) |
  		(ucontrol->value.iec958.status[3] << 24);
 -	mutex_lock(&intelhaddata->mutex);
  	if (intelhaddata->aes_bits != val) {
  		intelhaddata->aes_bits = val;
 -		changed = 1;
 +		return 1;
  	}
 -	mutex_unlock(&intelhaddata->mutex);
 -	return changed;
 +	return 1;
  }
  
 -static int had_ctl_eld_info(struct snd_kcontrol *kcontrol,
 -			    struct snd_ctl_elem_info *uinfo)
 -{
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
 -	uinfo->count = HDMI_MAX_ELD_BYTES;
 -	return 0;
 -}
 -
 -static int had_ctl_eld_get(struct snd_kcontrol *kcontrol,
 -			   struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);
 -
 -	mutex_lock(&intelhaddata->mutex);
 -	memcpy(ucontrol->value.bytes.data, intelhaddata->eld,
 -	       HDMI_MAX_ELD_BYTES);
 -	mutex_unlock(&intelhaddata->mutex);
 -	return 0;
 -}
 -
 -static const struct snd_kcontrol_new had_controls[] = {
 -	{
 -		.access = SNDRV_CTL_ELEM_ACCESS_READ,
 -		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 -		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, MASK),
 -		.info = had_iec958_info, /* shared */
 -		.get = had_iec958_mask_get,
 -	},
 -	{
 -		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 -		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
 -		.info = had_iec958_info,
 -		.get = had_iec958_get,
 -		.put = had_iec958_put,
 -	},
 -	{
 -		.access = (SNDRV_CTL_ELEM_ACCESS_READ |
 -			   SNDRV_CTL_ELEM_ACCESS_VOLATILE),
 -		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 -		.name = "ELD",
 -		.info = had_ctl_eld_info,
 -		.get = had_ctl_eld_get,
 -	},
 +static struct snd_kcontrol_new had_control_iec958_mask = {
 +	.access =   SNDRV_CTL_ELEM_ACCESS_READ,
 +	.iface =    SNDRV_CTL_ELEM_IFACE_PCM,
 +	.name =     SNDRV_CTL_NAME_IEC958("", PLAYBACK, MASK),
 +	.info =     had_iec958_info, /* shared */
 +	.get =      had_iec958_mask_get,
  };
  
 -/*
 - * audio interrupt handler
 - */
 -static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
 -{
 -	struct snd_intelhad *ctx = dev_id;
 -	u32 audio_stat, audio_reg;
 -
 -	audio_reg = AUD_HDMI_STATUS;
 -	mid_hdmi_audio_read(ctx, audio_reg, &audio_stat);
 -
 -	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
 -		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_UNDERRUN);
 -		had_process_buffer_underrun(ctx);
 -	}
 -
 -	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
 -		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_BUFFER_DONE);
 -		had_process_buffer_done(ctx);
 -	}
 -
 -	return IRQ_HANDLED;
 -}
 -
 -/*
 - * monitor plug/unplug notification from i915; just kick off the work
 - */
 -static void notify_audio_lpe(struct platform_device *pdev)
 -{
 -	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
 -
 -	schedule_work(&ctx->hdmi_audio_wq);
 -}
 -
 -/* the work to handle monitor hot plug/unplug */
 -static void had_audio_wq(struct work_struct *work)
 -{
 -	struct snd_intelhad *ctx =
 -		container_of(work, struct snd_intelhad, hdmi_audio_wq);
 -	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
 -
 -	pm_runtime_get_sync(ctx->dev);
 -	mutex_lock(&ctx->mutex);
 -	if (!pdata->hdmi_connected) {
 -		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
 -			__func__);
 -		memset(ctx->eld, 0, sizeof(ctx->eld)); /* clear the old ELD */
 -		had_process_hot_unplug(ctx);
 -	} else {
 -		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
 -
 -		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
 -			__func__, eld->port_id,	pdata->tmds_clock_speed);
 -
 -		switch (eld->pipe_id) {
 -		case 0:
 -			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -			break;
 -		case 1:
 -			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
 -			break;
 -		case 2:
 -			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
 -			break;
 -		default:
 -			dev_dbg(ctx->dev, "Invalid pipe %d\n",
 -				eld->pipe_id);
 -			break;
 -		}
 -
 -		memcpy(ctx->eld, eld->eld_data, sizeof(ctx->eld));
 -
 -		ctx->dp_output = pdata->dp_output;
 -		ctx->tmds_clock_speed = pdata->tmds_clock_speed;
 -		ctx->link_rate = pdata->link_rate;
 -
 -		had_process_hot_plug(ctx);
 -
 -		/* Process mode change if stream is active */
 -		hdmi_audio_mode_change(ctx);
 -	}
 -	mutex_unlock(&ctx->mutex);
 -	pm_runtime_put(ctx->dev);
 -}
 -
 -/*
 - * PM callbacks
 - */
 -
 -static int hdmi_lpe_audio_runtime_suspend(struct device *dev)
 -{
 -	struct snd_intelhad *ctx = dev_get_drvdata(dev);
 -	struct snd_pcm_substream *substream;
 -
 -	substream = had_substream_get(ctx);
 -	if (substream) {
 -		snd_pcm_suspend(substream);
 -		had_substream_put(ctx);
 -	}
 -
 -	return 0;
 -}
 -
 -static int hdmi_lpe_audio_suspend(struct device *dev)
 -{
 -	struct snd_intelhad *ctx = dev_get_drvdata(dev);
 -	int err;
 -
 -	err = hdmi_lpe_audio_runtime_suspend(dev);
 -	if (!err)
 -		snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D3hot);
 -	return err;
 -}
 -
 -static int hdmi_lpe_audio_resume(struct device *dev)
 -{
 -	struct snd_intelhad *ctx = dev_get_drvdata(dev);
 -
 -	snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D0);
 -	return 0;
 -}
 -
 -/* release resources */
 -static void hdmi_lpe_audio_free(struct snd_card *card)
 -{
 -	struct snd_intelhad *ctx = card->private_data;
 -
 -	cancel_work_sync(&ctx->hdmi_audio_wq);
 -
 -	if (ctx->mmio_start)
 -		iounmap(ctx->mmio_start);
 -	if (ctx->irq >= 0)
 -		free_irq(ctx->irq, ctx);
 -}
 +static struct snd_kcontrol_new had_control_iec958 = {
 +	.iface =    SNDRV_CTL_ELEM_IFACE_PCM,
 +	.name =         SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
 +	.info =         had_iec958_info,
 +	.get =          had_iec958_get,
 +	.put =          had_iec958_put
 +};
  
  /*
 - * hdmi_lpe_audio_probe - start bridge with i915
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
 + *
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
 -	struct snd_card *card;
 -	struct snd_intelhad *ctx;
 +	int retval;
  	struct snd_pcm *pcm;
 -	struct intel_hdmi_lpe_audio_pdata *pdata;
 -	int irq;
 -	struct resource *res_mmio;
 -	int i, ret;
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
  
 -	dev_dbg(&pdev->dev, "dma_mask: %p\n", pdev->dev.dma_mask);
 +	pr_debug("Enter %s\n", __func__);
  
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 -	/* create a card instance with ALSA framework */
 -	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
 -			   THIS_MODULE, sizeof(*ctx), &card);
 -	if (ret)
 -		return ret;
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
  
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
++<<<<<<< HEAD
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
++=======
+ 	ctx = card->private_data;
+ 	spin_lock_init(&ctx->had_spinlock);
+ 	mutex_init(&ctx->mutex);
+ 	ctx->connected = false;
+ 	ctx->dev = &pdev->dev;
+ 	ctx->card = card;
+ 	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
+ 	strcpy(card->driver, INTEL_HAD);
+ 	strcpy(card->shortname, INTEL_HAD);
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  
 -	ctx->irq = -1;
 -	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
 -	INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
 -
 -	card->private_free = hdmi_lpe_audio_free;
 -
 -	/* assume pipe A as default */
 -	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -
 -	platform_set_drvdata(pdev, ctx);
 -
 -	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
 -		__func__, (unsigned int)res_mmio->start,
 -		(unsigned int)res_mmio->end);
 -
 -	ctx->mmio_start = ioremap_nocache(res_mmio->start,
 -					  (size_t)(resource_size(res_mmio)));
 -	if (!ctx->mmio_start) {
 -		dev_err(&pdev->dev, "Could not get ioremap\n");
 -		ret = -EACCES;
 -		goto err;
 -	}
 -
 -	/* setup interrupt handler */
 -	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
 -			  pdev->name, ctx);
 -	if (ret < 0) {
 -		dev_err(&pdev->dev, "request_irq failed\n");
 -		goto err;
 -	}
 -
 -	ctx->irq = irq;
 -
 -	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 -			  MAX_CAP_STREAMS, &pcm);
 -	if (ret)
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
@@@ -1708,30 -1952,17 +2020,36 @@@ free_haddata
  }
  
  /*
 - * hdmi_lpe_audio_remove - stop bridge with i915
 + * hdmi_audio_remove - removes the alsa card
 + *
 + *@haddata: pointer to HAD private data
   *
 - * This function is called when the platform device is destroyed.
 + * This function is called when the hdmi cable is un-plugged. This function
 + * free the sound card.
   */
 -static int hdmi_lpe_audio_remove(struct platform_device *pdev)
 +int hdmi_audio_remove(struct snd_intelhad *intelhaddata)
  {
 -	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
 +	int caps;
 +
++<<<<<<< HEAD
 +	pr_debug("Enter %s\n", __func__);
  
 +	if (!intelhaddata)
 +		return 0;
 +
 +	if (intelhaddata->drv_status != HAD_DRV_DISCONNECTED) {
 +		caps = HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE;
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO_INT, &caps);
 +		had_set_caps(intelhaddata, HAD_SET_DISABLE_AUDIO, NULL);
 +	}
 +	snd_card_free(intelhaddata->card);
 +	kfree(intelhaddata->private_data);
 +	kfree(intelhaddata);
++=======
+ 	if (ctx->connected)
+ 		snd_intelhad_enable_audio_int(ctx, false);
+ 	snd_card_free(ctx->card);
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  	return 0;
  }
  
diff --cc sound/x86/intel_hdmi_audio.h
index 32a2fb766e47,9f713a8a88bc..000000000000
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@@ -103,12 -80,10 +103,16 @@@ struct had_pvt_data 
   * struct snd_intelhad - intelhad driver structure
   *
   * @card: ptr to hold card details
++<<<<<<< HEAD
 + * @card_index: sound card index
 + * @card_id: detected sound card id
 + * @drv_status: driver status
++=======
+  * @connected: the monitor connection status
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
   * @buf_info: ring buffer info
   * @stream_info: stream information
 - * @eld: holds ELD info
 + * @eeld: holds EELD info
   * @curr_buf: pointer to hold current active ring buf
   * @valid_buf_cnt: ring buffer count for stream
   * @had_spinlock: driver lock
@@@ -122,12 -95,10 +126,16 @@@
   */
  struct snd_intelhad {
  	struct snd_card	*card;
++<<<<<<< HEAD
 +	int		card_index;
 +	char		*card_id;
 +	enum had_drv_status	drv_status;
++=======
+ 	bool		connected;
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  	struct		ring_buf_info buf_info[HAD_NUM_OF_RING_BUFS];
  	struct		pcm_stream_info stream_info;
 -	unsigned char	eld[HDMI_MAX_ELD_BYTES];
 +	union otm_hdmi_eld_t	eeld;
  	bool dp_output;
  	enum		intel_had_aud_buf_type curr_buf;
  	int		valid_buf_cnt;
diff --cc sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57,be9783910a3a..000000000000
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@@ -95,164 -82,6 +95,167 @@@
  /* Naud Value */
  #define DP_NAUD_VAL					32768
  
++<<<<<<< HEAD
 +/* _AUD_CONFIG register MASK */
 +#define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
 +#define AUD_CONFIG_MASK_SRDBG		0x00000002
 +#define AUD_CONFIG_MASK_FUNCRST		0x00000001
 +
 +#define MAX_CNT			0xFF
 +#define HAD_SUSPEND_DELAY	1000
 +
 +#define OTM_HDMI_ELD_SIZE 128
 +
 +union otm_hdmi_eld_t {
 +	unsigned char eld_data[OTM_HDMI_ELD_SIZE];
 +	struct {
 +		/* Byte[0] = ELD Version Number */
 +		union {
 +			unsigned char   byte0;
 +			struct {
 +				unsigned char reserved:3; /* Reserf */
 +				unsigned char eld_ver:5; /* ELD Version Number */
 +				/* 00000b - reserved
 +				 * 00001b - first rev, obsoleted
 +				 * 00010b - version 2, supporting CEA version
 +				 *			861D or below
 +				 * 00011b:11111b - reserved
 +				 * for future
 +				 */
 +			};
 +		};
 +
 +		/* Byte[1] = Vendor Version Field */
 +		union {
 +			unsigned char vendor_version;
 +			struct {
 +				unsigned char reserved1:3;
 +				unsigned char veld_ver:5; /* Version number of the ELD
 +						     * extension. This value is
 +						     * provisioned and unique to
 +						     * each vendor.
 +						     */
 +			};
 +		};
 +
 +		/* Byte[2] = Baseline Length field */
 +		unsigned char baseline_eld_length; /* Length of the Baseline structure
 +					      *	divided by Four.
 +					      */
 +
 +		/* Byte [3] = Reserved for future use */
 +		unsigned char byte3;
 +
 +		/* Starting of the BaseLine EELD structure
 +		 * Byte[4] = Monitor Name Length
 +		 */
 +		union {
 +			unsigned char byte4;
 +			struct {
 +				unsigned char mnl:5;
 +				unsigned char cea_edid_rev_id:3;
 +			};
 +		};
 +
 +		/* Byte[5] = Capabilities */
 +		union {
 +			unsigned char capabilities;
 +			struct {
 +				unsigned char hdcp:1; /* HDCP support */
 +				unsigned char ai_support:1;   /* AI support */
 +				unsigned char connection_type:2; /* Connection type
 +							    * 00 - HDMI
 +							    * 01 - DP
 +							    * 10 -11  Reserved
 +							    * for future
 +							    * connection types
 +							    */
 +				unsigned char sadc:4; /* Indicates number of 3 bytes
 +						 * Short Audio Descriptors.
 +						 */
 +			};
 +		};
 +
 +		/* Byte[6] = Audio Synch Delay */
 +		unsigned char audio_synch_delay; /* Amount of time reported by the
 +					    * sink that the video trails audio
 +					    * in milliseconds.
 +					    */
 +
 +		/* Byte[7] = Speaker Allocation Block */
 +		union {
 +			unsigned char speaker_allocation_block;
 +			struct {
 +				unsigned char flr:1; /*Front Left and Right channels*/
 +				unsigned char lfe:1; /*Low Frequency Effect channel*/
 +				unsigned char fc:1;  /*Center transmission channel*/
 +				unsigned char rlr:1; /*Rear Left and Right channels*/
 +				unsigned char rc:1; /*Rear Center channel*/
 +				unsigned char flrc:1; /*Front left and Right of Center
 +						 *transmission channels
 +						 */
 +				unsigned char rlrc:1; /*Rear left and Right of Center
 +						 *transmission channels
 +						 */
 +				unsigned char reserved3:1; /* Reserved */
 +			};
 +		};
 +
 +		/* Byte[8 - 15] - 8 Byte port identification value */
 +		unsigned char port_id_value[8];
 +
 +		/* Byte[16 - 17] - 2 Byte Manufacturer ID */
 +		unsigned char manufacturer_id[2];
 +
 +		/* Byte[18 - 19] - 2 Byte Product ID */
 +		unsigned char product_id[2];
 +
 +		/* Byte [20-83] - 64 Bytes of BaseLine Data */
 +		unsigned char mn_sand_sads[64]; /* This will include
 +					   * - ASCII string of Monitor name
 +					   * - List of 3 byte SADs
 +					   * - Zero padding
 +					   */
 +
 +		/* Vendor ELD Block should continue here!
 +		 * No Vendor ELD block defined as of now.
 +		 */
 +	} __packed;
 +};
 +
 +/**
 + * enum had_status - Audio stream states
 + *
 + * @STREAM_INIT: Stream initialized
 + * @STREAM_RUNNING: Stream running
 + * @STREAM_PAUSED: Stream paused
 + * @STREAM_DROPPED: Stream dropped
 + */
 +enum had_stream_status {
 +	STREAM_INIT = 0,
 +	STREAM_RUNNING = 1,
 +	STREAM_PAUSED = 2,
 +	STREAM_DROPPED = 3
 +};
 +
 +/**
 + * enum had_status_stream - HAD stream states
 + */
 +enum had_status_stream {
 +	HAD_INIT = 0,
 +	HAD_RUNNING_STREAM,
 +};
 +
 +enum had_drv_status {
 +	HAD_DRV_CONNECTED,
 +	HAD_DRV_RUNNING,
 +	HAD_DRV_DISCONNECTED,
 +	HAD_DRV_SUSPENDED,
 +	HAD_DRV_ERR,
 +};
 +
++=======
++>>>>>>> 91b0cb0cc07b (ALSA: x86: Rename drv_status to connected)
  /* enum intel_had_aud_buf_type - HDMI controller ring buffer types */
  enum intel_had_aud_buf_type {
  	HAD_BUF_TYPE_A = 0,
* Unmerged path sound/x86/intel_hdmi_audio.c
* Unmerged path sound/x86/intel_hdmi_audio.h
* Unmerged path sound/x86/intel_hdmi_lpe_audio.h
