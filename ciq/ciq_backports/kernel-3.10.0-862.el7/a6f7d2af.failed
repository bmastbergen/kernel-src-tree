net/mlx5: Add support for multiple RoCE enable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add support for multiple RoCE enable (Kamal Heib) [1456677 1456694]
Rebuild_FUZZ: 95.45%
commit-author Ilan Tayari <ilant@mellanox.com>
commit a6f7d2aff623bb7572d4bca1caf5820e0cd5a586
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a6f7d2af.failed

Previously, only mlx5_ib enabled RoCE on the port, but FPGA needs it as
well.
Add support for counting number of enables, so that FPGA and IB can work
in parallel and independently.
Program the HW to enable RoCE on the first enable call, and program to
disable RoCE on the last disable call.

	Signed-off-by: Ilan Tayari <ilant@mellanox.com>
	Reviewed-by: Boris Pismenny <borisp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a6f7d2aff623bb7572d4bca1caf5820e0cd5a586)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mlx5/driver.h
diff --cc include/linux/mlx5/driver.h
index a9905f6fdc14,32b0835d4491..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -683,6 -775,13 +683,16 @@@ struct mlx5_core_dev 
  	atomic_t		num_qps;
  	u32			issi;
  	struct mlx5e_resources  mlx5e_res;
++<<<<<<< HEAD
++=======
+ 	struct {
+ 		struct mlx5_rsvd_gids	reserved_gids;
+ 		atomic_t                roce_en;
+ 	} roce;
+ #ifdef CONFIG_MLX5_FPGA
+ 	struct mlx5_fpga_device *fpga;
+ #endif
++>>>>>>> a6f7d2aff623 (net/mlx5: Add support for multiple RoCE enable)
  #ifdef CONFIG_RFS_ACCEL
  	struct cpu_rmap         *rmap;
  #endif
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vport.c b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 7f226b68da75..427b8eafb18c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@ -997,12 +997,16 @@ static int mlx5_nic_vport_update_roce_state(struct mlx5_core_dev *mdev,
 
 int mlx5_nic_vport_enable_roce(struct mlx5_core_dev *mdev)
 {
+	if (atomic_inc_return(&mdev->roce.roce_en) != 1)
+		return 0;
 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_ENABLED);
 }
 EXPORT_SYMBOL_GPL(mlx5_nic_vport_enable_roce);
 
 int mlx5_nic_vport_disable_roce(struct mlx5_core_dev *mdev)
 {
+	if (atomic_dec_return(&mdev->roce.roce_en) != 0)
+		return 0;
 	return mlx5_nic_vport_update_roce_state(mdev, MLX5_VPORT_ROCE_DISABLED);
 }
 EXPORT_SYMBOL_GPL(mlx5_nic_vport_disable_roce);
* Unmerged path include/linux/mlx5/driver.h
