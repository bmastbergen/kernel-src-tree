efi: Move facility flags to struct efi

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matt Fleming <matt.fleming@intel.com>
commit 3e909599215456928e6b42a04f11c2517881570b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3e909599.failed

As we grow support for more EFI architectures they're going to want the
ability to query which EFI features are available on the running system.
Instead of storing this information in an architecture-specific place,
stick it in the global 'struct efi', which is already the central
location for EFI state.

While we're at it, let's change the return value of efi_enabled() to be
bool and replace all references to 'facility' with 'feature', which is
the usual word used to describe the attributes of the running system.

	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 3e909599215456928e6b42a04f11c2517881570b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi.c
#	include/linux/efi.h
diff --cc arch/x86/platform/efi/efi.c
index 4d93a076e476,821562984452..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -68,9 -67,7 +68,13 @@@ struct efi_memory_map memmap
  static struct efi efi_phys __initdata;
  static efi_system_table_t efi_systab __initdata;
  
++<<<<<<< HEAD
 +unsigned long x86_efi_facility;
 +
 +static efi_config_table_type_t arch_tables[] __initdata = {
++=======
+ static __initdata efi_config_table_type_t arch_tables[] = {
++>>>>>>> 3e9095992154 (efi: Move facility flags to struct efi)
  #ifdef CONFIG_X86_UV
  	{UV_SYSTEM_TABLE_GUID, "UVsystab", &efi.uv_systab},
  #endif
@@@ -79,16 -76,7 +83,20 @@@
  
  u64 efi_setup;		/* efi setup_data physical address */
  
++<<<<<<< HEAD
 +/*
 + * Returns 1 if 'facility' is enabled, 0 otherwise.
 + */
 +int efi_enabled(int facility)
 +{
 +	return test_bit(facility, &x86_efi_facility) != 0;
 +}
 +EXPORT_SYMBOL(efi_enabled);
 +
 +static bool disable_runtime __initdata = false;
++=======
+ static bool __initdata disable_runtime = false;
++>>>>>>> 3e9095992154 (efi: Move facility flags to struct efi)
  static int __init setup_noefi(char *arg)
  {
  	disable_runtime = true;
@@@ -797,23 -751,14 +805,23 @@@ void __init efi_init(void
  	else {
  		if (disable_runtime || efi_runtime_init())
  			return;
- 		set_bit(EFI_RUNTIME_SERVICES, &x86_efi_facility);
+ 		set_bit(EFI_RUNTIME_SERVICES, &efi.flags);
  	}
 +
  	if (efi_memmap_init())
  		return;
  
- 	set_bit(EFI_MEMMAP, &x86_efi_facility);
+ 	set_bit(EFI_MEMMAP, &efi.flags);
  
 +#ifdef CONFIG_X86_32
 +	if (efi_is_native()) {
 +		x86_platform.get_wallclock = efi_get_time;
 +		x86_platform.set_wallclock = efi_set_rtc_mmss;
 +	}
 +#endif
  	print_efi_memmap();
 +
 +	efi_esrt_init();
  }
  
  void __init efi_late_init(void)
diff --cc include/linux/efi.h
index 0dc4ddccc847,214833b4a97d..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -849,10 -573,7 +849,14 @@@ extern struct efi 
  	efi_reset_system_t *reset_system;
  	efi_set_virtual_address_map_t *set_virtual_address_map;
  	struct efi_memory_map *memmap;
++<<<<<<< HEAD
 +	/* SMBIOS table (64 bit entry point) */
 +	RH_KABI_EXTEND(unsigned long smbios3)
 +	/* ESRT table */
 +	RH_KABI_EXTEND(unsigned long esrt)
++=======
+ 	unsigned long flags;
++>>>>>>> 3e9095992154 (efi: Move facility flags to struct efi)
  } efi;
  
  static inline int
diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
index 2215cd26512d..8cfb2943d183 100644
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@ -71,7 +71,6 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
 #endif /* CONFIG_X86_32 */
 
 extern int add_efi_memmap;
-extern unsigned long x86_efi_facility;
 extern struct efi_scratch efi_scratch;
 extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
 extern int efi_memblock_x86_reserve_range(void);
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index dcb7e8a78aab..98a6c7db05d6 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -1043,11 +1043,11 @@ void __init setup_arch(char **cmdline_p)
 #ifdef CONFIG_EFI
 	if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,
 		     "EL32", 4)) {
-		set_bit(EFI_BOOT, &x86_efi_facility);
+		set_bit(EFI_BOOT, &efi.flags);
 	} else if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,
 		     "EL64", 4)) {
-		set_bit(EFI_BOOT, &x86_efi_facility);
-		set_bit(EFI_64BIT, &x86_efi_facility);
+		set_bit(EFI_BOOT, &efi.flags);
+		set_bit(EFI_64BIT, &efi.flags);
 	}
 
 	if (efi_enabled(EFI_BOOT))
* Unmerged path arch/x86/platform/efi/efi.c
* Unmerged path include/linux/efi.h
