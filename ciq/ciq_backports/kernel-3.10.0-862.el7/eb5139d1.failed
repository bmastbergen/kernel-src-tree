cpufreq: intel_pstate: Support HWP processors in all operation modes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Support HWP processors in all operation modes (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 92.91%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit eb5139d1a2272487b223c4879ecd2a1b48c2250e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/eb5139d1.failed

Currently, some processors supporting HWP are only supported by
intel_pstate if HWP is actually going to be used and not supported
otherwise which is confusing.

Specifically, they are not supported if "intel_pstate=no_hwp" is
passed to the kernel in the command line or if the driver is started
in the passive mode ("intel_pstate=passive").

There is no real reason for that, because everything about those
processor is known anyway and the driver can work with them in all
modes, so make that happen, but use the load-based P-state selection
algorithm for the active mode "powersave" policy with them.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit eb5139d1a2272487b223c4879ecd2a1b48c2250e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 9b85edc571c0,87725e2ac3ac..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1746,28 -2627,34 +1746,56 @@@ static const struct x86_cpu_id hwp_supp
  
  static int __init intel_pstate_init(void)
  {
++<<<<<<< HEAD
 +	int cpu, rc = 0;
 +	const struct x86_cpu_id *id;
 +	struct cpu_defaults *cpu_info;
++=======
+ 	int rc;
++>>>>>>> eb5139d1a227 (cpufreq: intel_pstate: Support HWP processors in all operation modes)
  
  	if (no_load)
  		return -ENODEV;
  
- 	if (x86_match_cpu(hwp_support_ids) && !no_hwp) {
+ 	if (x86_match_cpu(hwp_support_ids)) {
  		copy_cpu_funcs(&core_params.funcs);
++<<<<<<< HEAD
 +		hwp_active++;
 +		goto hwp_cpu_matched;
 +	}
 +
 +	id = x86_match_cpu(intel_pstate_cpu_ids);
 +	if (!id)
 +		return -ENODEV;
 +
 +	cpu_info = (struct cpu_defaults *)id->driver_data;
 +
 +	copy_pid_params(&cpu_info->pid_policy);
 +	copy_cpu_funcs(&cpu_info->funcs);
 +
++=======
+ 		if (no_hwp) {
+ 			pstate_funcs.get_target_pstate = get_target_pstate_use_cpu_load;
+ 		} else {
+ 			hwp_active++;
+ 			intel_pstate.attr = hwp_cpufreq_attrs;
+ 			goto hwp_cpu_matched;
+ 		}
+ 	} else {
+ 		const struct x86_cpu_id *id;
+ 		struct cpu_defaults *cpu_def;
+ 
+ 		id = x86_match_cpu(intel_pstate_cpu_ids);
+ 		if (!id)
+ 			return -ENODEV;
+ 
+ 		cpu_def = (struct cpu_defaults *)id->driver_data;
+ 
+ 		copy_pid_params(&cpu_def->pid_policy);
+ 		copy_cpu_funcs(&cpu_def->funcs);
+ 	}
+ 
++>>>>>>> eb5139d1a227 (cpufreq: intel_pstate: Support HWP processors in all operation modes)
  	if (intel_pstate_msrs_not_valid())
  		return -ENODEV;
  
* Unmerged path drivers/cpufreq/intel_pstate.c
