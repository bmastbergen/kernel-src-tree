ALSA: x86: Minor code rearrangement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 2d42c033aec9f8e7e175c551ae62ea3f4dc200b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2d42c033.failed

Put the stuff in the right order; notification should be at the end of
the action.

Also dropped a superfluous debug print and incorrect comments.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 2d42c033aec9f8e7e175c551ae62ea3f4dc200b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,dd3baabd1e82..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -1458,55 -1365,75 +1458,120 @@@ out
  	return retval;
  }
  
 -/* process hot plug, called from wq with mutex locked */
 -static void had_process_hot_plug(struct snd_intelhad *intelhaddata)
 -{
 -	struct snd_pcm_substream *substream;
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
 +	.open =		snd_intelhad_open,
 +	.close =	snd_intelhad_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_intelhad_hw_params,
 +	.hw_free =	snd_intelhad_hw_free,
 +	.prepare =	snd_intelhad_pcm_prepare,
 +	.trigger =	snd_intelhad_pcm_trigger,
 +	.pointer =	snd_intelhad_pcm_pointer,
 +	.mmap =	snd_intelhad_pcm_mmap,
 +};
  
++<<<<<<< HEAD
 +/**
 + * snd_intelhad_create - to crete alsa card instance
 + *
 + * @intelhaddata: pointer to internal context
 + * @card: pointer to card
 + *
 + * This function is called when the hdmi cable is plugged in
++=======
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	if (intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		return;
+ 	}
+ 
+ 	intelhaddata->connected = true;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ 
+ 	/* Report to above ALSA layer */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		snd_pcm_stop_xrun(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	snd_jack_report(intelhaddata->jack, SND_JACK_AVOUT);
+ }
+ 
+ /* process hot unplug, called from wq with mutex locked */
+ static void had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		return;
+ 
+ 	}
+ 
+ 	/* Disable Audio */
+ 	had_enable_audio(intelhaddata, false);
+ 
+ 	intelhaddata->connected = false;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ 
+ 	/* Report to above ALSA layer */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		snd_pcm_stop_xrun(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	snd_jack_report(intelhaddata->jack, 0);
+ }
+ 
+ /*
+  * ALSA iec958 and ELD controls
++>>>>>>> 2d42c033aec9 (ALSA: x86: Minor code rearrangement)
   */
 +static int snd_intelhad_create(
 +		struct snd_intelhad *intelhaddata,
 +		struct snd_card *card)
 +{
 +	int retval;
 +	static struct snd_device_ops ops = {
 +	};
 +
 +	pr_debug("snd_intelhad_create called\n");
 +
 +	if (!intelhaddata)
 +		return -EINVAL;
 +
 +	/* ALSA api to register the device */
 +	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelhaddata, &ops);
 +	return retval;
 +}
 +/**
 + * snd_intelhad_pcm_free - to free the memory allocated
 + *
 + * @pcm: pointer to pcm instance
 + * This function is called when the device is removed
 + */
 +static void snd_intelhad_pcm_free(struct snd_pcm *pcm)
 +{
 +	pr_debug("Freeing PCM preallocated pages\n");
 +	snd_pcm_lib_preallocate_free_for_all(pcm);
 +}
  
  static int had_iec958_info(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_info *uinfo)
* Unmerged path sound/x86/intel_hdmi_audio.c
