scsi: cxlflash: Cleanup queuecommand()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Cleanup queuecommand() (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 91.43%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 9d89326c6660bc287b74983b51239460da10e189
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9d89326c.failed

The queuecommand routine is disorganized where it populates the
private command and also contains some logic/statements that are
not needed given that cxlflash devices do not (and likely never
will) support scatter-gather.

Restructure the code to remove the unnecessary logic and create an
organized flow:

	handle state -> DMA map -> populate command -> send command

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Acked-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9d89326c6660bc287b74983b51239460da10e189)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/main.c
index d8aaf45b8306,4e70c9a30afc..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -458,15 -387,16 +458,19 @@@ static int cxlflash_queuecommand(struc
  	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)host->hostdata;
  	struct afu *afu = cfg->afu;
  	struct device *dev = &cfg->dev->dev;
++<<<<<<< HEAD
 +	struct afu_cmd *cmd;
++=======
+ 	struct afu_cmd *cmd = sc_to_afucz(scp);
+ 	struct scatterlist *sg = scsi_sglist(scp);
++>>>>>>> 9d89326c6660 (scsi: cxlflash: Cleanup queuecommand())
  	u32 port_sel = scp->device->channel + 1;
- 	int nseg, i, ncount;
- 	struct scatterlist *sg;
+ 	u16 req_flags = SISL_REQ_FLAGS_SUP_UNDERRUN;
  	ulong lock_flags;
- 	short lflag = 0;
+ 	int nseg = 0;
  	int rc = 0;
 -	int kref_got = 0;
  
 -	dev_dbg_ratelimited(dev, "%s: (scp=%p) %d/%d/%d/%llu "
 +	dev_dbg_ratelimited(dev, "%s: (scp=%p) %d/%d/%d/%d "
  			    "cdb=(%08X-%08X-%08X-%08X)\n",
  			    __func__, scp, host->host_no, scp->device->channel,
  			    scp->device->id, scp->device->lun,
@@@ -502,53 -432,41 +506,72 @@@
  		break;
  	}
  
 -	kref_get(&cfg->afu->mapcount);
 -	kref_got = 1;
 +	cmd = cmd_checkout(afu);
 +	if (unlikely(!cmd)) {
 +		dev_err(dev, "%s: could not get a free command\n", __func__);
 +		rc = SCSI_MLQUEUE_HOST_BUSY;
 +		goto out;
 +	}
  
+ 	if (likely(sg)) {
+ 		nseg = scsi_dma_map(scp);
+ 		if (unlikely(nseg < 0)) {
+ 			dev_err(dev, "%s: Fail DMA map!\n", __func__);
+ 			rc = SCSI_MLQUEUE_HOST_BUSY;
+ 			goto out;
+ 		}
+ 
+ 		cmd->rcb.data_len = sg_dma_len(sg);
+ 		cmd->rcb.data_ea = sg_dma_address(sg);
+ 	}
+ 
+ 	cmd->rcb.scp = scp;
+ 	cmd->parent = afu;
+ 
  	cmd->rcb.ctx_id = afu->ctx_hndl;
 -	cmd->rcb.msi = SISL_MSI_RRQ_UPDATED;
  	cmd->rcb.port_sel = port_sel;
  	cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);
  
  	if (scp->sc_data_direction == DMA_TO_DEVICE)
- 		lflag = SISL_REQ_FLAGS_HOST_WRITE;
- 	else
- 		lflag = SISL_REQ_FLAGS_HOST_READ;
+ 		req_flags |= SISL_REQ_FLAGS_HOST_WRITE;
  
++<<<<<<< HEAD
 +	cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
 +			      SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
 +
 +	/* Stash the scp in the reserved field, for reuse during interrupt */
 +	cmd->rcb.scp = scp;
 +
 +	nseg = scsi_dma_map(scp);
 +	if (unlikely(nseg < 0)) {
 +		dev_err(dev, "%s: Fail DMA map! nseg=%d\n",
 +			__func__, nseg);
 +		rc = SCSI_MLQUEUE_HOST_BUSY;
 +		goto out;
 +	}
 +
 +	ncount = scsi_sg_count(scp);
 +	scsi_for_each_sg(scp, sg, ncount, i) {
 +		cmd->rcb.data_len = sg_dma_len(sg);
 +		cmd->rcb.data_ea = sg_dma_address(sg);
 +	}
 +
 +	/* Copy the CDB from the scsi_cmnd passed in */
++=======
+ 	cmd->rcb.req_flags = req_flags;
++>>>>>>> 9d89326c6660 (scsi: cxlflash: Cleanup queuecommand())
  	memcpy(cmd->rcb.cdb, scp->cmnd, sizeof(cmd->rcb.cdb));
  
- 	/* Send the command */
  	rc = send_cmd(afu, cmd);
 -	if (unlikely(rc))
 +	if (unlikely(rc)) {
 +		cmd_checkin(cmd);
  		scsi_dma_unmap(scp);
++<<<<<<< HEAD
 +	}
 +
++=======
++>>>>>>> 9d89326c6660 (scsi: cxlflash: Cleanup queuecommand())
  out:
 -	if (kref_got)
 -		kref_put(&afu->mapcount, afu_unmap);
  	pr_devel("%s: returning rc=%d\n", __func__, rc);
  	return rc;
  }
* Unmerged path drivers/scsi/cxlflash/main.c
