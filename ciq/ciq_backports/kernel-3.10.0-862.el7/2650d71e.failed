target: move transport ID handling to the core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] move transport ID handling to the core (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 90.48%
commit-author Christoph Hellwig <hch@lst.de>
commit 2650d71e244fb3637b5f58a0080682a8bf9c7091
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2650d71e.failed

Now that struct se_portal_group contains a protocol identifier field we can
take all the code to format an parse protocol identifiers in CDBs into common
code instead of leaving this to low-level drivers.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 2650d71e244fb3637b5f58a0080682a8bf9c7091)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/target/tcm_mod_builder.py
#	drivers/infiniband/ulp/srpt/ib_srpt.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
#	drivers/target/iscsi/iscsi_target_configfs.c
#	drivers/target/loopback/tcm_loop.c
#	drivers/target/sbp/sbp_target.c
#	drivers/target/target_core_configfs.c
#	drivers/target/target_core_fabric_lib.c
#	drivers/target/target_core_pr.c
#	drivers/target/tcm_fc/tfc_conf.c
#	drivers/usb/gadget/tcm_usb_gadget.c
#	drivers/vhost/scsi.c
#	drivers/xen/xen-scsiback.c
#	include/target/target_core_fabric.h
diff --cc Documentation/target/tcm_mod_builder.py
index 3fe0d812dcec,0dbd70cccde1..000000000000
--- a/Documentation/target/tcm_mod_builder.py
+++ b/Documentation/target/tcm_mod_builder.py
@@@ -370,15 -291,12 +364,18 @@@ def tcm_mod_build_configfs(proto_ident
  	buf += "	NULL,\n"
  	buf += "};\n\n"
  
 -	buf += "static const struct target_core_fabric_ops " + fabric_mod_name + "_ops = {\n"
 -	buf += "	.module				= THIS_MODULE,\n"
 -	buf += "	.name				= " + fabric_mod_name + ",\n"
 +	buf += "static struct target_core_fabric_ops " + fabric_mod_name + "_ops = {\n"
  	buf += "	.get_fabric_name		= " + fabric_mod_name + "_get_fabric_name,\n"
 +	buf += "	.get_fabric_proto_ident		= " + fabric_mod_name + "_get_fabric_proto_ident,\n"
  	buf += "	.tpg_get_wwn			= " + fabric_mod_name + "_get_fabric_wwn,\n"
  	buf += "	.tpg_get_tag			= " + fabric_mod_name + "_get_tag,\n"
++<<<<<<< HEAD
 +	buf += "	.tpg_get_default_depth		= " + fabric_mod_name + "_get_default_depth,\n"
 +	buf += "	.tpg_get_pr_transport_id	= " + fabric_mod_name + "_get_pr_transport_id,\n"
 +	buf += "	.tpg_get_pr_transport_id_len	= " + fabric_mod_name + "_get_pr_transport_id_len,\n"
 +	buf += "	.tpg_parse_pr_out_transport_id	= " + fabric_mod_name + "_parse_pr_out_transport_id,\n"
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	buf += "	.tpg_check_demo_mode		= " + fabric_mod_name + "_check_false,\n"
  	buf += "	.tpg_check_demo_mode_cache	= " + fabric_mod_name + "_check_true,\n"
  	buf += "	.tpg_check_demo_mode_write_protect = " + fabric_mod_name + "_check_true,\n"
@@@ -648,150 -469,6 +645,153 @@@ def tcm_mod_dump_fabric_ops(proto_ident
  			buf += "}\n\n"
  			bufi += "u16 " + fabric_mod_name + "_get_tag(struct se_portal_group *);\n"
  
++<<<<<<< HEAD
 +		if re.search('get_default_depth', fo):
 +			buf += "u32 " + fabric_mod_name + "_get_default_depth(struct se_portal_group *se_tpg)\n"
 +			buf += "{\n"
 +			buf += "	return 1;\n"
 +			buf += "}\n\n"
 +			bufi += "u32 " + fabric_mod_name + "_get_default_depth(struct se_portal_group *);\n"
 +
 +		if re.search('get_pr_transport_id\)\(', fo):
 +			buf += "u32 " + fabric_mod_name + "_get_pr_transport_id(\n"
 +			buf += "	struct se_portal_group *se_tpg,\n"
 +			buf += "	struct se_node_acl *se_nacl,\n"
 +			buf += "	struct t10_pr_registration *pr_reg,\n"
 +			buf += "	int *format_code,\n"
 +			buf += "	unsigned char *buf)\n"
 +			buf += "{\n"
 +			buf += "	struct " + fabric_mod_name + "_tpg *tpg = container_of(se_tpg,\n"
 +			buf += "				struct " + fabric_mod_name + "_tpg, se_tpg);\n"
 +			buf += "	struct " + fabric_mod_name + "_" + fabric_mod_port + " *" + fabric_mod_port + " = tpg->" + fabric_mod_port + ";\n"
 +			buf += "	int ret = 0;\n\n"
 +			buf += "	switch (" + fabric_mod_port + "->" + fabric_mod_port + "_proto_id) {\n"
 +			if proto_ident == "FC":
 +				buf += "	case SCSI_PROTOCOL_FCP:\n"
 +				buf += "	default:\n"
 +				buf += "		ret = fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n"
 +				buf += "					format_code, buf);\n"
 +				buf += "		break;\n"
 +			elif proto_ident == "SAS":
 +				buf += "	case SCSI_PROTOCOL_SAS:\n"
 +				buf += "	default:\n"
 +				buf += "		ret = sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n"
 +				buf += "					format_code, buf);\n"
 +				buf += "		break;\n"
 +			elif proto_ident == "iSCSI":
 +				buf += "	case SCSI_PROTOCOL_ISCSI:\n"
 +				buf += "	default:\n"
 +				buf += "		ret = iscsi_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\n"
 +				buf += "					format_code, buf);\n"
 +				buf += "		break;\n"
 +
 +			buf += "	}\n\n"
 +			buf += "	return ret;\n"
 +			buf += "}\n\n"
 +			bufi += "u32 " + fabric_mod_name + "_get_pr_transport_id(struct se_portal_group *,\n"
 +			bufi += "			struct se_node_acl *, struct t10_pr_registration *,\n"
 +			bufi += "			int *, unsigned char *);\n"
 +
 +		if re.search('get_pr_transport_id_len\)\(', fo):
 +			buf += "u32 " + fabric_mod_name + "_get_pr_transport_id_len(\n"
 +			buf += "	struct se_portal_group *se_tpg,\n"
 +			buf += "	struct se_node_acl *se_nacl,\n"
 +			buf += "	struct t10_pr_registration *pr_reg,\n"
 +			buf += "	int *format_code)\n"
 +			buf += "{\n"
 +			buf += "	struct " + fabric_mod_name + "_tpg *tpg = container_of(se_tpg,\n"
 +			buf += "				struct " + fabric_mod_name + "_tpg, se_tpg);\n"
 +			buf += "	struct " + fabric_mod_name + "_" + fabric_mod_port + " *" + fabric_mod_port + " = tpg->" + fabric_mod_port + ";\n"
 +			buf += "	int ret = 0;\n\n"
 +			buf += "	switch (" + fabric_mod_port + "->" + fabric_mod_port + "_proto_id) {\n"
 +			if proto_ident == "FC":
 +				buf += "	case SCSI_PROTOCOL_FCP:\n"
 +				buf += "	default:\n"
 +				buf += "		ret = fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n"
 +				buf += "					format_code);\n"
 +				buf += "		break;\n"
 +			elif proto_ident == "SAS":
 +				buf += "	case SCSI_PROTOCOL_SAS:\n"
 +				buf += "	default:\n"
 +				buf += "		ret = sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n"
 +				buf += "					format_code);\n"
 +				buf += "		break;\n"
 +			elif proto_ident == "iSCSI":
 +				buf += "	case SCSI_PROTOCOL_ISCSI:\n"
 +				buf += "	default:\n"
 +				buf += "		ret = iscsi_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\n"
 +				buf += "					format_code);\n"
 +				buf += "		break;\n"
 +
 +
 +			buf += "	}\n\n"
 +			buf += "	return ret;\n"
 +			buf += "}\n\n"
 +			bufi += "u32 " + fabric_mod_name + "_get_pr_transport_id_len(struct se_portal_group *,\n"
 +			bufi += "			struct se_node_acl *, struct t10_pr_registration *,\n"
 +			bufi += "			int *);\n"
 +
 +		if re.search('parse_pr_out_transport_id\)\(', fo):
 +			buf += "char *" + fabric_mod_name + "_parse_pr_out_transport_id(\n"
 +			buf += "	struct se_portal_group *se_tpg,\n"
 +			buf += "	const char *buf,\n"
 +			buf += "	u32 *out_tid_len,\n"
 +			buf += "	char **port_nexus_ptr)\n"
 +			buf += "{\n"
 +			buf += "	struct " + fabric_mod_name + "_tpg *tpg = container_of(se_tpg,\n"
 +			buf += "				struct " + fabric_mod_name + "_tpg, se_tpg);\n"
 +			buf += "	struct " + fabric_mod_name + "_" + fabric_mod_port + " *" + fabric_mod_port + " = tpg->" + fabric_mod_port + ";\n"
 +			buf += "	char *tid = NULL;\n\n"
 +			buf += "	switch (" + fabric_mod_port + "->" + fabric_mod_port + "_proto_id) {\n"
 +			if proto_ident == "FC":
 +				buf += "	case SCSI_PROTOCOL_FCP:\n"
 +				buf += "	default:\n"
 +				buf += "		tid = fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n"
 +				buf += "					port_nexus_ptr);\n"
 +			elif proto_ident == "SAS":
 +				buf += "	case SCSI_PROTOCOL_SAS:\n"
 +				buf += "	default:\n"
 +				buf += "		tid = sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n"
 +				buf += "					port_nexus_ptr);\n"
 +			elif proto_ident == "iSCSI":
 +				buf += "	case SCSI_PROTOCOL_ISCSI:\n"
 +				buf += "	default:\n"
 +				buf += "		tid = iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n"
 +				buf += "					port_nexus_ptr);\n"
 +
 +			buf += "	}\n\n"
 +			buf += "	return tid;\n"
 +			buf += "}\n\n"
 +			bufi += "char *" + fabric_mod_name + "_parse_pr_out_transport_id(struct se_portal_group *,\n"
 +			bufi +=	"			const char *, u32 *, char **);\n"
 +
 +		if re.search('alloc_fabric_acl\)\(', fo):
 +			buf += "struct se_node_acl *" + fabric_mod_name + "_alloc_fabric_acl(struct se_portal_group *se_tpg)\n"
 +			buf += "{\n"
 +			buf += "	struct " + fabric_mod_name + "_nacl *nacl;\n\n"
 +			buf += "	nacl = kzalloc(sizeof(struct " + fabric_mod_name + "_nacl), GFP_KERNEL);\n"
 +			buf += "	if (!nacl) {\n"
 +			buf += "		printk(KERN_ERR \"Unable to allocate struct " + fabric_mod_name + "_nacl\\n\");\n"
 +			buf += "		return NULL;\n"
 +			buf += "	}\n\n"
 +			buf += "	return &nacl->se_node_acl;\n"
 +			buf += "}\n\n"
 +			bufi += "struct se_node_acl *" + fabric_mod_name + "_alloc_fabric_acl(struct se_portal_group *);\n"
 +
 +		if re.search('release_fabric_acl\)\(', fo):
 +			buf += "void " + fabric_mod_name + "_release_fabric_acl(\n"
 +			buf += "	struct se_portal_group *se_tpg,\n"
 +			buf += "	struct se_node_acl *se_nacl)\n"
 +			buf += "{\n"
 +			buf += "	struct " + fabric_mod_name + "_nacl *nacl = container_of(se_nacl,\n"
 +			buf += "			struct " + fabric_mod_name + "_nacl, se_node_acl);\n"
 +			buf += "	kfree(nacl);\n"
 +			buf += "}\n\n"
 +			bufi += "void " + fabric_mod_name + "_release_fabric_acl(struct se_portal_group *,\n"
 +			bufi +=	"			struct se_node_acl *);\n"
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  		if re.search('tpg_get_inst_index\)\(', fo):
  			buf += "u32 " + fabric_mod_name + "_tpg_get_inst_index(struct se_portal_group *se_tpg)\n"
  			buf += "{\n"
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 72146d165e84,98e00360f97e..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -2702,69 -3406,6 +2702,72 @@@ static u16 srpt_get_tag(struct se_porta
  	return 1;
  }
  
++<<<<<<< HEAD
 +static u32 srpt_get_default_depth(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static u32 srpt_get_pr_transport_id(struct se_portal_group *se_tpg,
 +				    struct se_node_acl *se_nacl,
 +				    struct t10_pr_registration *pr_reg,
 +				    int *format_code, unsigned char *buf)
 +{
 +	struct srpt_node_acl *nacl;
 +	struct spc_rdma_transport_id *tr_id;
 +
 +	nacl = container_of(se_nacl, struct srpt_node_acl, nacl);
 +	tr_id = (void *)buf;
 +	tr_id->protocol_identifier = SCSI_TRANSPORTID_PROTOCOLID_SRP;
 +	memcpy(tr_id->i_port_id, nacl->i_port_id, sizeof(tr_id->i_port_id));
 +	return sizeof(*tr_id);
 +}
 +
 +static u32 srpt_get_pr_transport_id_len(struct se_portal_group *se_tpg,
 +					struct se_node_acl *se_nacl,
 +					struct t10_pr_registration *pr_reg,
 +					int *format_code)
 +{
 +	*format_code = 0;
 +	return sizeof(struct spc_rdma_transport_id);
 +}
 +
 +static char *srpt_parse_pr_out_transport_id(struct se_portal_group *se_tpg,
 +					    const char *buf, u32 *out_tid_len,
 +					    char **port_nexus_ptr)
 +{
 +	struct spc_rdma_transport_id *tr_id;
 +
 +	*port_nexus_ptr = NULL;
 +	*out_tid_len = sizeof(struct spc_rdma_transport_id);
 +	tr_id = (void *)buf;
 +	return (char *)tr_id->i_port_id;
 +}
 +
 +static struct se_node_acl *srpt_alloc_fabric_acl(struct se_portal_group *se_tpg)
 +{
 +	struct srpt_node_acl *nacl;
 +
 +	nacl = kzalloc(sizeof(struct srpt_node_acl), GFP_KERNEL);
 +	if (!nacl) {
 +		pr_err("Unable to allocate struct srpt_node_acl\n");
 +		return NULL;
 +	}
 +
 +	return &nacl->nacl;
 +}
 +
 +static void srpt_release_fabric_acl(struct se_portal_group *se_tpg,
 +				    struct se_node_acl *se_nacl)
 +{
 +	struct srpt_node_acl *nacl;
 +
 +	nacl = container_of(se_nacl, struct srpt_node_acl, nacl);
 +	kfree(nacl);
 +}
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  static u32 srpt_tpg_get_inst_index(struct se_portal_group *se_tpg)
  {
  	return 1;
@@@ -3219,15 -3817,13 +3222,18 @@@ static struct configfs_attribute *srpt_
  	NULL,
  };
  
 -static const struct target_core_fabric_ops srpt_template = {
 -	.module				= THIS_MODULE,
 -	.name				= "srpt",
 -	.node_acl_size			= sizeof(struct srpt_node_acl),
 +static struct target_core_fabric_ops srpt_template = {
  	.get_fabric_name		= srpt_get_fabric_name,
 +	.get_fabric_proto_ident		= srpt_get_fabric_proto_ident,
  	.tpg_get_wwn			= srpt_get_fabric_wwn,
  	.tpg_get_tag			= srpt_get_tag,
++<<<<<<< HEAD
 +	.tpg_get_default_depth		= srpt_get_default_depth,
 +	.tpg_get_pr_transport_id	= srpt_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= srpt_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= srpt_parse_pr_out_transport_id,
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	.tpg_check_demo_mode		= srpt_check_false,
  	.tpg_check_demo_mode_cache	= srpt_check_true,
  	.tpg_check_demo_mode_write_protect = srpt_check_true,
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,bd0f9eb67901..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -237,78 -206,6 +237,81 @@@ static u16 tcm_qla2xxx_get_tag(struct s
  	return tpg->lport_tpgt;
  }
  
++<<<<<<< HEAD
 +static u32 tcm_qla2xxx_get_default_depth(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static u32 tcm_qla2xxx_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code,
 +	unsigned char *buf)
 +{
 +	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
 +				struct tcm_qla2xxx_tpg, se_tpg);
 +	struct tcm_qla2xxx_lport *lport = tpg->lport;
 +	int ret = 0;
 +
 +	switch (lport->lport_proto_id) {
 +	case SCSI_PROTOCOL_FCP:
 +	default:
 +		ret = fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +static u32 tcm_qla2xxx_get_pr_transport_id_len(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
 +{
 +	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
 +				struct tcm_qla2xxx_tpg, se_tpg);
 +	struct tcm_qla2xxx_lport *lport = tpg->lport;
 +	int ret = 0;
 +
 +	switch (lport->lport_proto_id) {
 +	case SCSI_PROTOCOL_FCP:
 +	default:
 +		ret = fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +static char *tcm_qla2xxx_parse_pr_out_transport_id(
 +	struct se_portal_group *se_tpg,
 +	const char *buf,
 +	u32 *out_tid_len,
 +	char **port_nexus_ptr)
 +{
 +	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
 +				struct tcm_qla2xxx_tpg, se_tpg);
 +	struct tcm_qla2xxx_lport *lport = tpg->lport;
 +	char *tid = NULL;
 +
 +	switch (lport->lport_proto_id) {
 +	case SCSI_PROTOCOL_FCP:
 +	default:
 +		tid = fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +		break;
 +	}
 +
 +	return tid;
 +}
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  static int tcm_qla2xxx_check_demo_mode(struct se_portal_group *se_tpg)
  {
  	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
@@@ -1732,15 -1839,13 +1735,18 @@@ static struct configfs_attribute *tcm_q
  	NULL,
  };
  
 -static const struct target_core_fabric_ops tcm_qla2xxx_ops = {
 -	.module				= THIS_MODULE,
 -	.name				= "qla2xxx",
 -	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
 +static struct target_core_fabric_ops tcm_qla2xxx_ops = {
  	.get_fabric_name		= tcm_qla2xxx_get_fabric_name,
 +	.get_fabric_proto_ident		= tcm_qla2xxx_get_fabric_proto_ident,
  	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
  	.tpg_get_tag			= tcm_qla2xxx_get_tag,
++<<<<<<< HEAD
 +	.tpg_get_default_depth		= tcm_qla2xxx_get_default_depth,
 +	.tpg_get_pr_transport_id	= tcm_qla2xxx_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= tcm_qla2xxx_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= tcm_qla2xxx_parse_pr_out_transport_id,
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
  	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
  	.tpg_check_demo_mode_write_protect =
@@@ -1774,31 -1879,28 +1780,39 @@@
  	.fabric_drop_wwn		= tcm_qla2xxx_drop_lport,
  	.fabric_make_tpg		= tcm_qla2xxx_make_tpg,
  	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
 -	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,
 -
 -	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
 -	.tfc_tpg_base_attrs		= tcm_qla2xxx_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= tcm_qla2xxx_tpg_attrib_attrs,
 +	.fabric_post_link		= NULL,
 +	.fabric_pre_unlink		= NULL,
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= tcm_qla2xxx_make_nodeacl,
 +	.fabric_drop_nodeacl		= tcm_qla2xxx_drop_nodeacl,
  };
  
 -static const struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
 -	.module				= THIS_MODULE,
 -	.name				= "qla2xxx_npiv",
 -	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
 +static struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
  	.get_fabric_name		= tcm_qla2xxx_npiv_get_fabric_name,
 +	.get_fabric_proto_ident		= tcm_qla2xxx_get_fabric_proto_ident,
  	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
  	.tpg_get_tag			= tcm_qla2xxx_get_tag,
++<<<<<<< HEAD
 +	.tpg_get_default_depth		= tcm_qla2xxx_get_default_depth,
 +	.tpg_get_pr_transport_id	= tcm_qla2xxx_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= tcm_qla2xxx_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= tcm_qla2xxx_parse_pr_out_transport_id,
 +	.tpg_check_demo_mode		= tcm_qla2xxx_check_false,
 +	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_true,
 +	.tpg_check_demo_mode_write_protect = tcm_qla2xxx_check_true,
 +	.tpg_check_prod_mode_write_protect = tcm_qla2xxx_check_false,
++=======
+ 	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect = tcm_qla2xxx_check_demo_mode,
+ 	.tpg_check_prod_mode_write_protect =
+ 	    tcm_qla2xxx_check_prod_write_protect,
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	.tpg_check_demo_mode_login_only	= tcm_qla2xxx_check_demo_mode_login_only,
 +	.tpg_alloc_fabric_acl		= tcm_qla2xxx_alloc_fabric_acl,
 +	.tpg_release_fabric_acl		= tcm_qla2xxx_release_fabric_acl,
  	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
 -	.check_stop_free                = tcm_qla2xxx_check_stop_free,
  	.release_cmd			= tcm_qla2xxx_release_cmd,
  	.put_session			= tcm_qla2xxx_put_session,
  	.shutdown_session		= tcm_qla2xxx_shutdown_session,
diff --cc drivers/target/iscsi/iscsi_target_configfs.c
index e02616d0c024,bd8af8764f4b..000000000000
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@@ -2051,115 -1913,55 +2051,157 @@@ static void lio_release_cmd(struct se_c
  	iscsit_release_cmd(cmd);
  }
  
++<<<<<<< HEAD
 +/* End functions for target_core_fabric_ops */
++=======
+ const struct target_core_fabric_ops iscsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "iscsi",
+ 	.node_acl_size			= sizeof(struct iscsi_node_acl),
+ 	.get_fabric_name		= iscsi_get_fabric_name,
+ 	.tpg_get_wwn			= lio_tpg_get_endpoint_wwn,
+ 	.tpg_get_tag			= lio_tpg_get_tag,
+ 	.tpg_get_default_depth		= lio_tpg_get_default_depth,
+ 	.tpg_check_demo_mode		= lio_tpg_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= lio_tpg_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 			lio_tpg_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 			lio_tpg_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= &lio_tpg_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= lio_tpg_get_inst_index,
+ 	.check_stop_free		= lio_check_stop_free,
+ 	.release_cmd			= lio_release_cmd,
+ 	.shutdown_session		= lio_tpg_shutdown_session,
+ 	.close_session			= lio_tpg_close_session,
+ 	.sess_get_index			= lio_sess_get_index,
+ 	.sess_get_initiator_sid		= lio_sess_get_initiator_sid,
+ 	.write_pending			= lio_write_pending,
+ 	.write_pending_status		= lio_write_pending_status,
+ 	.set_default_node_attributes	= lio_set_default_node_attributes,
+ 	.get_task_tag			= iscsi_get_task_tag,
+ 	.get_cmd_state			= iscsi_get_cmd_state,
+ 	.queue_data_in			= lio_queue_data_in,
+ 	.queue_status			= lio_queue_status,
+ 	.queue_tm_rsp			= lio_queue_tm_rsp,
+ 	.aborted_task			= lio_aborted_task,
+ 	.fabric_make_wwn		= lio_target_call_coreaddtiqn,
+ 	.fabric_drop_wwn		= lio_target_call_coredeltiqn,
+ 	.fabric_make_tpg		= lio_target_tiqn_addtpg,
+ 	.fabric_drop_tpg		= lio_target_tiqn_deltpg,
+ 	.fabric_make_np			= lio_target_call_addnptotpg,
+ 	.fabric_drop_np			= lio_target_call_delnpfromtpg,
+ 	.fabric_init_nodeacl		= lio_target_init_nodeacl,
+ 	.fabric_cleanup_nodeacl		= lio_target_cleanup_nodeacl,
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  
 -	.tfc_discovery_attrs		= lio_target_discovery_auth_attrs,
 -	.tfc_wwn_attrs			= lio_target_wwn_attrs,
 -	.tfc_tpg_base_attrs		= lio_target_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= lio_target_tpg_attrib_attrs,
 -	.tfc_tpg_auth_attrs		= lio_target_tpg_auth_attrs,
 -	.tfc_tpg_param_attrs		= lio_target_tpg_param_attrs,
 -	.tfc_tpg_np_base_attrs		= lio_target_portal_attrs,
 -	.tfc_tpg_nacl_base_attrs	= lio_target_initiator_attrs,
 -	.tfc_tpg_nacl_attrib_attrs	= lio_target_nacl_attrib_attrs,
 -	.tfc_tpg_nacl_auth_attrs	= lio_target_nacl_auth_attrs,
 -	.tfc_tpg_nacl_param_attrs	= lio_target_nacl_param_attrs,
 -};
 +int iscsi_target_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	lio_target_fabric_configfs = NULL;
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "iscsi");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() for"
 +				" LIO-Target failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod..
 +	 */
 +	fabric->tf_ops.get_fabric_name = &iscsi_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &iscsi_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &lio_tpg_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &lio_tpg_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &lio_tpg_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &iscsi_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +				&iscsi_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +				&iscsi_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &lio_tpg_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +				&lio_tpg_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +				&lio_tpg_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +				&lio_tpg_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &lio_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl = &lio_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &lio_tpg_get_inst_index;
 +	fabric->tf_ops.check_stop_free = &lio_check_stop_free,
 +	fabric->tf_ops.release_cmd = &lio_release_cmd;
 +	fabric->tf_ops.shutdown_session = &lio_tpg_shutdown_session;
 +	fabric->tf_ops.close_session = &lio_tpg_close_session;
 +	fabric->tf_ops.sess_get_index = &lio_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = &lio_sess_get_initiator_sid;
 +	fabric->tf_ops.write_pending = &lio_write_pending;
 +	fabric->tf_ops.write_pending_status = &lio_write_pending_status;
 +	fabric->tf_ops.set_default_node_attributes =
 +				&lio_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &iscsi_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &iscsi_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &lio_queue_data_in;
 +	fabric->tf_ops.queue_status = &lio_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &lio_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &lio_aborted_task;
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &lio_target_call_coreaddtiqn;
 +	fabric->tf_ops.fabric_drop_wwn = &lio_target_call_coredeltiqn;
 +	fabric->tf_ops.fabric_make_tpg = &lio_target_tiqn_addtpg;
 +	fabric->tf_ops.fabric_drop_tpg = &lio_target_tiqn_deltpg;
 +	fabric->tf_ops.fabric_post_link	= NULL;
 +	fabric->tf_ops.fabric_pre_unlink = NULL;
 +	fabric->tf_ops.fabric_make_np = &lio_target_call_addnptotpg;
 +	fabric->tf_ops.fabric_drop_np = &lio_target_call_delnpfromtpg;
 +	fabric->tf_ops.fabric_make_nodeacl = &lio_target_make_nodeacl;
 +	fabric->tf_ops.fabric_drop_nodeacl = &lio_target_drop_nodeacl;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 * sturct config_item_type's
 +	 */
 +	fabric->tf_cit_tmpl.tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_auth_cit.ct_attrs = lio_target_tpg_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
 +
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" LIO-Target failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return ret;
 +	}
 +
 +	lio_target_fabric_configfs = fabric;
 +	pr_debug("LIO_TARGET[0] - Set fabric ->"
 +			" lio_target_fabric_configfs\n");
 +	return 0;
 +}
 +
 +
 +void iscsi_target_deregister_configfs(void)
 +{
 +	if (!lio_target_fabric_configfs)
 +		return;
 +	/*
 +	 * Shutdown discovery sessions and disable discovery TPG
 +	 */
 +	if (iscsit_global->discovery_tpg)
 +		iscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);
 +
 +	target_fabric_configfs_deregister(lio_target_fabric_configfs);
 +	lio_target_fabric_configfs = NULL;
 +	pr_debug("LIO_TARGET[0] - Cleared"
 +				" lio_target_fabric_configfs\n");
 +}
diff --cc drivers/target/loopback/tcm_loop.c
index d49ba0b7387a,b788406977f6..000000000000
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@@ -608,100 -542,6 +608,103 @@@ static u16 tcm_loop_get_tag(struct se_p
  	return tl_tpg(se_tpg)->tl_tpgt;
  }
  
++<<<<<<< HEAD
 +static u32 tcm_loop_get_default_depth(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static u32 tcm_loop_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code,
 +	unsigned char *buf)
 +{
 +	struct tcm_loop_hba *tl_hba = tl_tpg(se_tpg)->tl_hba;
 +
 +	switch (tl_hba->tl_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +		return sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +	case SCSI_PROTOCOL_FCP:
 +		return fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +	case SCSI_PROTOCOL_ISCSI:
 +		return iscsi_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +	default:
 +		pr_err("Unknown tl_proto_id: 0x%02x, using"
 +			" SAS emulation\n", tl_hba->tl_proto_id);
 +		break;
 +	}
 +
 +	return sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +			format_code, buf);
 +}
 +
 +static u32 tcm_loop_get_pr_transport_id_len(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
 +{
 +	struct tcm_loop_hba *tl_hba = tl_tpg(se_tpg)->tl_hba;
 +
 +	switch (tl_hba->tl_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +		return sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +	case SCSI_PROTOCOL_FCP:
 +		return fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +	case SCSI_PROTOCOL_ISCSI:
 +		return iscsi_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +	default:
 +		pr_err("Unknown tl_proto_id: 0x%02x, using"
 +			" SAS emulation\n", tl_hba->tl_proto_id);
 +		break;
 +	}
 +
 +	return sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +			format_code);
 +}
 +
 +/*
 + * Used for handling SCSI fabric dependent TransportIDs in SPC-3 and above
 + * Persistent Reservation SPEC_I_PT=1 and PROUT REGISTER_AND_MOVE operations.
 + */
 +static char *tcm_loop_parse_pr_out_transport_id(
 +	struct se_portal_group *se_tpg,
 +	const char *buf,
 +	u32 *out_tid_len,
 +	char **port_nexus_ptr)
 +{
 +	struct tcm_loop_hba *tl_hba = tl_tpg(se_tpg)->tl_hba;
 +
 +	switch (tl_hba->tl_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +		return sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	case SCSI_PROTOCOL_FCP:
 +		return fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	case SCSI_PROTOCOL_ISCSI:
 +		return iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	default:
 +		pr_err("Unknown tl_proto_id: 0x%02x, using"
 +			" SAS emulation\n", tl_hba->tl_proto_id);
 +		break;
 +	}
 +
 +	return sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +			port_nexus_ptr);
 +}
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  /*
   * Returning (1) here allows for target_core_mod struct se_node_acl to be generated
   * based upon the incoming fabric dependent SCSI Initiator Port
@@@ -1411,129 -1237,44 +1414,170 @@@ static struct configfs_attribute *tcm_l
  
  /* End items for tcm_loop_cit */
  
++<<<<<<< HEAD
 +static int tcm_loop_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +	/*
 +	 * Set the TCM Loop HBA counter to zero
 +	 */
 +	tcm_loop_hba_no_cnt = 0;
 +	/*
 +	 * Register the top level struct config_item_type with TCM core
 +	 */
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "loopback");
 +	if (IS_ERR(fabric)) {
 +		pr_err("tcm_loop_register_configfs() failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod
 +	 */
 +	fabric->tf_ops.get_fabric_name = &tcm_loop_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &tcm_loop_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &tcm_loop_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &tcm_loop_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &tcm_loop_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &tcm_loop_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +					&tcm_loop_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +					&tcm_loop_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &tcm_loop_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +					&tcm_loop_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +					&tcm_loop_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +					&tcm_loop_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prot_fabric_only =
 +					&tcm_loop_check_prot_fabric_only;
 +	/*
 +	 * The TCM loopback fabric module runs in demo-mode to a local
 +	 * virtual SCSI device, so fabric dependent initator ACLs are
 +	 * not required.
 +	 */
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &tcm_loop_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl =
 +					&tcm_loop_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &tcm_loop_get_inst_index;
 +	/*
 +	 * Used for setting up remaining TCM resources in process context
 +	 */
 +	fabric->tf_ops.check_stop_free = &tcm_loop_check_stop_free;
 +	fabric->tf_ops.release_cmd = &tcm_loop_release_cmd;
 +	fabric->tf_ops.shutdown_session = &tcm_loop_shutdown_session;
 +	fabric->tf_ops.close_session = &tcm_loop_close_session;
 +	fabric->tf_ops.sess_get_index = &tcm_loop_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = NULL;
 +	fabric->tf_ops.write_pending = &tcm_loop_write_pending;
 +	fabric->tf_ops.write_pending_status = &tcm_loop_write_pending_status;
 +	/*
 +	 * Not used for TCM loopback
 +	 */
 +	fabric->tf_ops.set_default_node_attributes =
 +					&tcm_loop_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &tcm_loop_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &tcm_loop_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &tcm_loop_queue_data_in;
 +	fabric->tf_ops.queue_status = &tcm_loop_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &tcm_loop_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &tcm_loop_aborted_task;
 +
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &tcm_loop_make_scsi_hba;
 +	fabric->tf_ops.fabric_drop_wwn = &tcm_loop_drop_scsi_hba;
 +	fabric->tf_ops.fabric_make_tpg = &tcm_loop_make_naa_tpg;
 +	fabric->tf_ops.fabric_drop_tpg = &tcm_loop_drop_naa_tpg;
 +	/*
 +	 * fabric_post_link() and fabric_pre_unlink() are used for
 +	 * registration and release of TCM Loop Virtual SCSI LUNs.
 +	 */
 +	fabric->tf_ops.fabric_post_link = &tcm_loop_port_link;
 +	fabric->tf_ops.fabric_pre_unlink = &tcm_loop_port_unlink;
 +	fabric->tf_ops.fabric_make_np = NULL;
 +	fabric->tf_ops.fabric_drop_np = NULL;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = tcm_loop_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	/*
 +	 * Once fabric->tf_ops has been setup, now register the fabric for
 +	 * use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" TCM_Loop failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return -1;
 +	}
 +	/*
 +	 * Setup our local pointer to *fabric.
 +	 */
 +	tcm_loop_fabric_configfs = fabric;
 +	pr_debug("TCM_LOOP[0] - Set fabric ->"
 +			" tcm_loop_fabric_configfs\n");
 +	return 0;
 +}
 +
 +static void tcm_loop_deregister_configfs(void)
 +{
 +	if (!tcm_loop_fabric_configfs)
 +		return;
 +
 +	target_fabric_configfs_deregister(tcm_loop_fabric_configfs);
 +	tcm_loop_fabric_configfs = NULL;
 +	pr_debug("TCM_LOOP[0] - Cleared"
 +				" tcm_loop_fabric_configfs\n");
 +}
++=======
+ static const struct target_core_fabric_ops loop_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "loopback",
+ 	.get_fabric_name		= tcm_loop_get_fabric_name,
+ 	.tpg_get_wwn			= tcm_loop_get_endpoint_wwn,
+ 	.tpg_get_tag			= tcm_loop_get_tag,
+ 	.tpg_check_demo_mode		= tcm_loop_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= tcm_loop_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 				tcm_loop_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 				tcm_loop_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= tcm_loop_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= tcm_loop_get_inst_index,
+ 	.check_stop_free		= tcm_loop_check_stop_free,
+ 	.release_cmd			= tcm_loop_release_cmd,
+ 	.shutdown_session		= tcm_loop_shutdown_session,
+ 	.close_session			= tcm_loop_close_session,
+ 	.sess_get_index			= tcm_loop_sess_get_index,
+ 	.write_pending			= tcm_loop_write_pending,
+ 	.write_pending_status		= tcm_loop_write_pending_status,
+ 	.set_default_node_attributes	= tcm_loop_set_default_node_attributes,
+ 	.get_task_tag			= tcm_loop_get_task_tag,
+ 	.get_cmd_state			= tcm_loop_get_cmd_state,
+ 	.queue_data_in			= tcm_loop_queue_data_in,
+ 	.queue_status			= tcm_loop_queue_status,
+ 	.queue_tm_rsp			= tcm_loop_queue_tm_rsp,
+ 	.aborted_task			= tcm_loop_aborted_task,
+ 	.fabric_make_wwn		= tcm_loop_make_scsi_hba,
+ 	.fabric_drop_wwn		= tcm_loop_drop_scsi_hba,
+ 	.fabric_make_tpg		= tcm_loop_make_naa_tpg,
+ 	.fabric_drop_tpg		= tcm_loop_drop_naa_tpg,
+ 	.fabric_post_link		= tcm_loop_port_link,
+ 	.fabric_pre_unlink		= tcm_loop_port_unlink,
+ 	.tfc_wwn_attrs			= tcm_loop_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= tcm_loop_tpg_attrs,
+ 	.tfc_tpg_attrib_attrs		= tcm_loop_tpg_attrib_attrs,
+ };
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  
  static int __init tcm_loop_fabric_init(void)
  {
diff --cc drivers/target/sbp/sbp_target.c
index b33c121ab56c,89f172dc8678..000000000000
--- a/drivers/target/sbp/sbp_target.c
+++ b/drivers/target/sbp/sbp_target.c
@@@ -1850,85 -1832,6 +1850,88 @@@ static int sbp_check_stop_free(struct s
  	return 1;
  }
  
++<<<<<<< HEAD
 +/*
 + * Handlers for Serial Bus Protocol 2/3 (SBP-2 / SBP-3)
 + */
 +static u8 sbp_get_fabric_proto_ident(struct se_portal_group *se_tpg)
 +{
 +	/*
 +	 * Return a IEEE 1394 SCSI Protocol identifier for loopback operations
 +	 * This is defined in section 7.5.1 Table 362 in spc4r17
 +	 */
 +	return SCSI_PROTOCOL_SBP;
 +}
 +
 +static u32 sbp_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code,
 +	unsigned char *buf)
 +{
 +	int ret;
 +
 +	/*
 +	 * Set PROTOCOL IDENTIFIER to 3h for SBP
 +	 */
 +	buf[0] = SCSI_PROTOCOL_SBP;
 +	/*
 +	 * From spc4r17, 7.5.4.4 TransportID for initiator ports using SCSI
 +	 * over IEEE 1394
 +	 */
 +	ret = hex2bin(&buf[8], se_nacl->initiatorname, 8);
 +	if (ret < 0)
 +		pr_debug("sbp transport_id: invalid hex string\n");
 +
 +	/*
 +	 * The IEEE 1394 Transport ID is a hardcoded 24-byte length
 +	 */
 +	return 24;
 +}
 +
 +static u32 sbp_get_pr_transport_id_len(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
 +{
 +	*format_code = 0;
 +	/*
 +	 * From spc4r17, 7.5.4.4 TransportID for initiator ports using SCSI
 +	 * over IEEE 1394
 +	 *
 +	 * The SBP Transport ID is a hardcoded 24-byte length
 +	 */
 +	return 24;
 +}
 +
 +/*
 + * Used for handling SCSI fabric dependent TransportIDs in SPC-3 and above
 + * Persistent Reservation SPEC_I_PT=1 and PROUT REGISTER_AND_MOVE operations.
 + */
 +static char *sbp_parse_pr_out_transport_id(
 +	struct se_portal_group *se_tpg,
 +	const char *buf,
 +	u32 *out_tid_len,
 +	char **port_nexus_ptr)
 +{
 +	/*
 +	 * Assume the FORMAT CODE 00b from spc4r17, 7.5.4.4 TransportID
 +	 * for initiator ports using SCSI over SBP Serial SCSI Protocol
 +	 *
 +	 * The TransportID for a IEEE 1394 Initiator Port is of fixed size of
 +	 * 24 bytes, and IEEE 1394 does not contain a I_T nexus identifier,
 +	 * so we return the **port_nexus_ptr set to NULL.
 +	 */
 +	*port_nexus_ptr = NULL;
 +	*out_tid_len = 24;
 +
 +	return (char *)&buf[8];
 +}
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  static int sbp_count_se_tpg_luns(struct se_portal_group *tpg)
  {
  	int i, count = 0;
@@@ -2485,15 -2359,12 +2488,18 @@@ static struct configfs_attribute *sbp_t
  	NULL,
  };
  
 -static const struct target_core_fabric_ops sbp_ops = {
 -	.module				= THIS_MODULE,
 -	.name				= "sbp",
 +static struct target_core_fabric_ops sbp_ops = {
  	.get_fabric_name		= sbp_get_fabric_name,
 +	.get_fabric_proto_ident		= sbp_get_fabric_proto_ident,
  	.tpg_get_wwn			= sbp_get_fabric_wwn,
  	.tpg_get_tag			= sbp_get_tag,
++<<<<<<< HEAD
 +	.tpg_get_default_depth		= sbp_get_default_depth,
 +	.tpg_get_pr_transport_id	= sbp_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= sbp_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= sbp_parse_pr_out_transport_id,
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	.tpg_check_demo_mode		= sbp_check_true,
  	.tpg_check_demo_mode_cache	= sbp_check_true,
  	.tpg_check_demo_mode_write_protect = sbp_check_false,
diff --cc drivers/target/target_core_configfs.c
index 372df6e87bcb,5e2649fc6919..000000000000
--- a/drivers/target/target_core_configfs.c
+++ b/drivers/target/target_core_configfs.c
@@@ -391,18 -326,6 +391,21 @@@ static int target_fabric_tf_ops_check
  		pr_err("Missing tfo->tpg_get_tag()\n");
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +	if (!tfo->tpg_get_default_depth) {
 +		pr_err("Missing tfo->tpg_get_default_depth()\n");
 +		return -EINVAL;
 +	}
 +	if (!tfo->tpg_get_pr_transport_id) {
 +		pr_err("Missing tfo->tpg_get_pr_transport_id()\n");
 +		return -EINVAL;
 +	}
 +	if (!tfo->tpg_get_pr_transport_id_len) {
 +		pr_err("Missing tfo->tpg_get_pr_transport_id_len()\n");
 +		return -EINVAL;
 +	}
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	if (!tfo->tpg_check_demo_mode) {
  		pr_err("Missing tfo->tpg_check_demo_mode()\n");
  		return -EINVAL;
diff --cc drivers/target/target_core_fabric_lib.c
index 35bfe77160d8,89720b2f37c2..000000000000
--- a/drivers/target/target_core_fabric_lib.c
+++ b/drivers/target/target_core_fabric_lib.c
@@@ -39,119 -44,26 +44,115 @@@
  #include "target_core_internal.h"
  #include "target_core_pr.h"
  
++<<<<<<< HEAD
 +/*
 + * Handlers for Serial Attached SCSI (SAS)
 + */
 +u8 sas_get_fabric_proto_ident(struct se_portal_group *se_tpg)
 +{
 +	/*
 +	 * Return a SAS Serial SCSI Protocol identifier for loopback operations
 +	 * This is defined in  section 7.5.1 Table 362 in spc4r17
 +	 */
 +	return 0x6;
 +}
 +EXPORT_SYMBOL(sas_get_fabric_proto_ident);
 +
 +u32 sas_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
++=======
+ 
+ static int sas_get_pr_transport_id(
+ 	struct se_node_acl *nacl,
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	int *format_code,
  	unsigned char *buf)
  {
- 	unsigned char *ptr;
  	int ret;
  
- 	/*
- 	 * Set PROTOCOL IDENTIFIER to 6h for SAS
- 	 */
- 	buf[0] = 0x06;
- 	/*
- 	 * From spc4r17, 7.5.4.7 TransportID for initiator ports using SCSI
- 	 * over SAS Serial SCSI Protocol
- 	 */
- 	ptr = &se_nacl->initiatorname[4]; /* Skip over 'naa. prefix */
- 
- 	ret = hex2bin(&buf[4], ptr, 8);
- 	if (ret < 0)
- 		pr_debug("sas transport_id: invalid hex string\n");
+ 	/* Skip over 'naa. prefix */
+ 	ret = hex2bin(&buf[4], &nacl->initiatorname[4], 8);
+ 	if (ret) {
+ 		pr_debug("%s: invalid hex string\n", __func__);
+ 		return ret;
+ 	}
  
- 	/*
- 	 * The SAS Transport ID is a hardcoded 24-byte length
- 	 */
  	return 24;
  }
- EXPORT_SYMBOL(sas_get_pr_transport_id);
  
- u32 sas_get_pr_transport_id_len(
- 	struct se_portal_group *se_tpg,
+ static int fc_get_pr_transport_id(
  	struct se_node_acl *se_nacl,
++<<<<<<< HEAD
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
 +{
 +	*format_code = 0;
 +	/*
 +	 * From spc4r17, 7.5.4.7 TransportID for initiator ports using SCSI
 +	 * over SAS Serial SCSI Protocol
 +	 *
 +	 * The SAS Transport ID is a hardcoded 24-byte length
 +	 */
 +	return 24;
 +}
 +EXPORT_SYMBOL(sas_get_pr_transport_id_len);
 +
 +/*
 + * Used for handling SCSI fabric dependent TransportIDs in SPC-3 and above
 + * Persistent Reservation SPEC_I_PT=1 and PROUT REGISTER_AND_MOVE operations.
 + */
 +char *sas_parse_pr_out_transport_id(
 +	struct se_portal_group *se_tpg,
 +	const char *buf,
 +	u32 *out_tid_len,
 +	char **port_nexus_ptr)
 +{
 +	/*
 +	 * Assume the FORMAT CODE 00b from spc4r17, 7.5.4.7 TransportID
 +	 * for initiator ports using SCSI over SAS Serial SCSI Protocol
 +	 *
 +	 * The TransportID for a SAS Initiator Port is of fixed size of
 +	 * 24 bytes, and SAS does not contain a I_T nexus identifier,
 +	 * so we return the **port_nexus_ptr set to NULL.
 +	 */
 +	*port_nexus_ptr = NULL;
 +	*out_tid_len = 24;
 +
 +	return (char *)&buf[4];
 +}
 +EXPORT_SYMBOL(sas_parse_pr_out_transport_id);
 +
 +/*
 + * Handlers for Fibre Channel Protocol (FCP)
 + */
 +u8 fc_get_fabric_proto_ident(struct se_portal_group *se_tpg)
 +{
 +	return 0x0;	/* 0 = fcp-2 per SPC4 section 7.5.1 */
 +}
 +EXPORT_SYMBOL(fc_get_fabric_proto_ident);
 +
 +u32 fc_get_pr_transport_id_len(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
 +{
 +	*format_code = 0;
 +	/*
 +	 * The FC Transport ID is a hardcoded 24-byte length
 +	 */
 +	return 24;
 +}
 +EXPORT_SYMBOL(fc_get_pr_transport_id_len);
 +
 +u32 fc_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	int *format_code,
  	unsigned char *buf)
  {
@@@ -185,42 -93,52 +182,71 @@@
  	 */
  	return 24;
  }
- EXPORT_SYMBOL(fc_get_pr_transport_id);
  
- char *fc_parse_pr_out_transport_id(
- 	struct se_portal_group *se_tpg,
- 	const char *buf,
- 	u32 *out_tid_len,
- 	char **port_nexus_ptr)
+ static int sbp_get_pr_transport_id(
+ 	struct se_node_acl *nacl,
+ 	int *format_code,
+ 	unsigned char *buf)
  {
- 	/*
- 	 * The TransportID for a FC N Port is of fixed size of
- 	 * 24 bytes, and FC does not contain a I_T nexus identifier,
- 	 * so we return the **port_nexus_ptr set to NULL.
- 	 */
- 	*port_nexus_ptr = NULL;
- 	*out_tid_len = 24;
+ 	int ret;
+ 
+ 	ret = hex2bin(&buf[8], nacl->initiatorname, 8);
+ 	if (ret) {
+ 		pr_debug("%s: invalid hex string\n", __func__);
+ 		return ret;
+ 	}
  
- 	 return (char *)&buf[8];
+ 	return 24;
  }
- EXPORT_SYMBOL(fc_parse_pr_out_transport_id);
  
++<<<<<<< HEAD
 +/*
 + * Handlers for Internet Small Computer Systems Interface (iSCSI)
 + */
 +
 +u8 iscsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
 +{
 +	/*
 +	 * This value is defined for "Internet SCSI (iSCSI)"
 +	 * in spc4r17 section 7.5.1 Table 362
 +	 */
 +	return 0x5;
 +}
 +EXPORT_SYMBOL(iscsi_get_fabric_proto_ident);
 +
 +u32 iscsi_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
++=======
+ static int srp_get_pr_transport_id(
+ 	struct se_node_acl *nacl,
+ 	int *format_code,
+ 	unsigned char *buf)
+ {
+ 	const char *p;
+ 	unsigned len, count, leading_zero_bytes;
+ 	int rc;
+ 
+ 	p = nacl->initiatorname;
+ 	if (strncasecmp(p, "0x", 2) == 0)
+ 		p += 2;
+ 	len = strlen(p);
+ 	if (len % 2)
+ 		return -EINVAL;
+ 
+ 	count = min(len / 2, 16U);
+ 	leading_zero_bytes = 16 - count;
+ 	memset(buf + 8, 0, leading_zero_bytes);
+ 	rc = hex2bin(buf + 8 + leading_zero_bytes, p, count);
+ 	if (rc < 0) {
+ 		pr_debug("hex2bin failed for %s: %d\n", __func__, rc);
+ 		return rc;
+ 	}
+ 
+ 	return 24;
+ }
+ 
+ static int iscsi_get_pr_transport_id(
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	struct se_node_acl *se_nacl,
  	struct t10_pr_registration *pr_reg,
  	int *format_code,
diff --cc drivers/target/target_core_pr.c
index a255afc452a9,d396b3b87025..000000000000
--- a/drivers/target/target_core_pr.c
+++ b/drivers/target/target_core_pr.c
@@@ -1461,9 -1445,8 +1461,14 @@@ core_scsi3_decode_spec_i_port
  	struct t10_pr_registration *pr_reg_tmp, *pr_reg_tmp_safe;
  	LIST_HEAD(tid_dest_list);
  	struct pr_transport_id_holder *tidh_new, *tidh, *tidh_tmp;
++<<<<<<< HEAD
 +	struct target_core_fabric_ops *tmp_tf_ops;
 +	unsigned char *buf;
 +	unsigned char *ptr, *i_str = NULL, proto_ident, tmp_proto_ident;
++=======
+ 	unsigned char *buf, *ptr, proto_ident;
+ 	const unsigned char *i_str;
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	char *iport_ptr = NULL, i_buf[PR_REG_ISID_ID_LEN];
  	sense_reason_t ret;
  	u32 tpdl, tid_len = 0;
@@@ -1549,12 -1532,7 +1554,16 @@@
  			tmp_tpg = tmp_port->sep_tpg;
  			if (!tmp_tpg)
  				continue;
++<<<<<<< HEAD
 +			tmp_tf_ops = tmp_tpg->se_tpg_tfo;
 +			if (!tmp_tf_ops)
 +				continue;
 +			if (!tmp_tf_ops->get_fabric_proto_ident ||
 +			    !tmp_tf_ops->tpg_parse_pr_out_transport_id)
 +				continue;
++=======
+ 
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  			/*
  			 * Look for the matching proto_ident provided by
  			 * the received TransportID
diff --cc drivers/target/tcm_fc/tfc_conf.c
index 8f5b91a74d09,6ad7404b7dd1..000000000000
--- a/drivers/target/tcm_fc/tfc_conf.c
+++ b/drivers/target/tcm_fc/tfc_conf.c
@@@ -506,15 -447,13 +506,18 @@@ static u32 ft_tpg_get_inst_index(struc
  	return ft_tpg(se_tpg)->index;
  }
  
 -static const struct target_core_fabric_ops ft_fabric_ops = {
 -	.module =			THIS_MODULE,
 -	.name =				"fc",
 -	.node_acl_size =		sizeof(struct ft_node_acl),
 +static struct target_core_fabric_ops ft_fabric_ops = {
  	.get_fabric_name =		ft_get_fabric_name,
 +	.get_fabric_proto_ident =	fc_get_fabric_proto_ident,
  	.tpg_get_wwn =			ft_get_fabric_wwn,
  	.tpg_get_tag =			ft_get_tag,
++<<<<<<< HEAD
 +	.tpg_get_default_depth =	ft_get_default_depth,
 +	.tpg_get_pr_transport_id =	fc_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len =	fc_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id = fc_parse_pr_out_transport_id,
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	.tpg_check_demo_mode =		ft_check_false,
  	.tpg_check_demo_mode_cache =	ft_check_false,
  	.tpg_check_demo_mode_write_protect = ft_check_false,
diff --cc drivers/usb/gadget/tcm_usb_gadget.c
index 7cacd6ae818e,77cdbb56e1d5..000000000000
--- a/drivers/usb/gadget/tcm_usb_gadget.c
+++ b/drivers/usb/gadget/tcm_usb_gadget.c
@@@ -1307,99 -1290,6 +1307,102 @@@ static u16 usbg_get_tag(struct se_porta
  	return tpg->tport_tpgt;
  }
  
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +static u32 usbg_get_default_depth(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static u32 usbg_get_pr_transport_id(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code,
 +	unsigned char *buf)
 +{
 +	struct usbg_tpg *tpg = container_of(se_tpg,
 +				struct usbg_tpg, se_tpg);
 +	struct usbg_tport *tport = tpg->tport;
 +	int ret = 0;
 +
 +	switch (tport->tport_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +	default:
 +		ret = sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +static u32 usbg_get_pr_transport_id_len(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
 +{
 +	struct usbg_tpg *tpg = container_of(se_tpg,
 +				struct usbg_tpg, se_tpg);
 +	struct usbg_tport *tport = tpg->tport;
 +	int ret = 0;
 +
 +	switch (tport->tport_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +	default:
 +		ret = sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +static char *usbg_parse_pr_out_transport_id(
 +	struct se_portal_group *se_tpg,
 +	const char *buf,
 +	u32 *out_tid_len,
 +	char **port_nexus_ptr)
 +{
 +	struct usbg_tpg *tpg = container_of(se_tpg,
 +				struct usbg_tpg, se_tpg);
 +	struct usbg_tport *tport = tpg->tport;
 +	char *tid = NULL;
 +
 +	switch (tport->tport_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +	default:
 +		tid = sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	}
 +
 +	return tid;
 +}
 +
 +static struct se_node_acl *usbg_alloc_fabric_acl(struct se_portal_group *se_tpg)
 +{
 +	struct usbg_nacl *nacl;
 +
 +	nacl = kzalloc(sizeof(struct usbg_nacl), GFP_KERNEL);
 +	if (!nacl) {
 +		printk(KERN_ERR "Unable to allocate struct usbg_nacl\n");
 +		return NULL;
 +	}
 +
 +	return &nacl->se_node_acl;
 +}
 +
 +static void usbg_release_fabric_acl(
 +	struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl)
 +{
 +	struct usbg_nacl *nacl = container_of(se_nacl,
 +			struct usbg_nacl, se_node_acl);
 +	kfree(nacl);
 +}
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  static u32 usbg_tpg_get_inst_index(struct se_portal_group *se_tpg)
  {
  	return 1;
@@@ -1572,9 -1425,12 +1575,18 @@@ static struct se_portal_group *usbg_mak
  	tpg->tport = tport;
  	tpg->tport_tpgt = tpgt;
  
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +	ret = core_tpg_register(&usbg_fabric_configfs->tf_ops, wwn,
 +				&tpg->se_tpg, tpg,
 +				TRANSPORT_TPG_TYPE_NORMAL);
++=======
+ 	/*
+ 	 * SPC doesn't assign a protocol identifier for USB-SCSI, so we
+ 	 * pretend to be SAS..
+ 	 */
+ 	ret = core_tpg_register(&usbg_ops, wwn, &tpg->se_tpg,
+ 				SCSI_PROTOCOL_SAS);
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  	if (ret < 0) {
  		destroy_workqueue(tpg->workqueue);
  		kfree(tpg);
@@@ -1869,15 -1720,12 +1881,18 @@@ static int usbg_check_stop_free(struct 
  	return 1;
  }
  
 -static const struct target_core_fabric_ops usbg_ops = {
 -	.module				= THIS_MODULE,
 -	.name				= "usb_gadget",
 +static struct target_core_fabric_ops usbg_ops = {
  	.get_fabric_name		= usbg_get_fabric_name,
 +	.get_fabric_proto_ident		= usbg_get_fabric_proto_ident,
  	.tpg_get_wwn			= usbg_get_fabric_wwn,
  	.tpg_get_tag			= usbg_get_tag,
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +	.tpg_get_default_depth		= usbg_get_default_depth,
 +	.tpg_get_pr_transport_id	= usbg_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= usbg_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= usbg_parse_pr_out_transport_id,
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  	.tpg_check_demo_mode		= usbg_check_true,
  	.tpg_check_demo_mode_cache	= usbg_check_false,
  	.tpg_check_demo_mode_write_protect = usbg_check_false,
diff --cc drivers/vhost/scsi.c
index 65142d377371,db9f4b474214..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -323,132 -304,40 +323,136 @@@ static u16 tcm_vhost_get_tag(struct se_
  	return tpg->tport_tpgt;
  }
  
 -static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
++<<<<<<< HEAD
 +static u32 tcm_vhost_get_default_depth(struct se_portal_group *se_tpg)
  {
 -	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
 -				struct vhost_scsi_tpg, se_tpg);
 +	return 1;
 +}
  
 -	return tpg->tv_fabric_prot_type;
 +static u32 tcm_vhost_get_pr_transport_id(struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code,
 +	unsigned char *buf)
 +{
 +	struct tcm_vhost_tpg *tpg = container_of(se_tpg,
 +				struct tcm_vhost_tpg, se_tpg);
 +	struct tcm_vhost_tport *tport = tpg->tport;
 +
 +	switch (tport->tport_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +		return sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +	case SCSI_PROTOCOL_FCP:
 +		return fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +	case SCSI_PROTOCOL_ISCSI:
 +		return iscsi_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +					format_code, buf);
 +	default:
 +		pr_err("Unknown tport_proto_id: 0x%02x, using"
 +			" SAS emulation\n", tport->tport_proto_id);
 +		break;
 +	}
 +
 +	return sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,
 +			format_code, buf);
  }
  
 -static u32 vhost_scsi_tpg_get_inst_index(struct se_portal_group *se_tpg)
 +static u32 tcm_vhost_get_pr_transport_id_len(struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl,
 +	struct t10_pr_registration *pr_reg,
 +	int *format_code)
  {
 -	return 1;
 +	struct tcm_vhost_tpg *tpg = container_of(se_tpg,
 +				struct tcm_vhost_tpg, se_tpg);
 +	struct tcm_vhost_tport *tport = tpg->tport;
 +
 +	switch (tport->tport_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +		return sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +	case SCSI_PROTOCOL_FCP:
 +		return fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +	case SCSI_PROTOCOL_ISCSI:
 +		return iscsi_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +					format_code);
 +	default:
 +		pr_err("Unknown tport_proto_id: 0x%02x, using"
 +			" SAS emulation\n", tport->tport_proto_id);
 +		break;
 +	}
 +
 +	return sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,
 +			format_code);
  }
  
 -static void vhost_scsi_release_cmd(struct se_cmd *se_cmd)
 +static char *tcm_vhost_parse_pr_out_transport_id(struct se_portal_group *se_tpg,
 +	const char *buf,
 +	u32 *out_tid_len,
 +	char **port_nexus_ptr)
  {
 -	struct vhost_scsi_cmd *tv_cmd = container_of(se_cmd,
 -				struct vhost_scsi_cmd, tvc_se_cmd);
 -	struct se_session *se_sess = tv_cmd->tvc_nexus->tvn_se_sess;
 -	int i;
 +	struct tcm_vhost_tpg *tpg = container_of(se_tpg,
 +				struct tcm_vhost_tpg, se_tpg);
 +	struct tcm_vhost_tport *tport = tpg->tport;
  
 -	if (tv_cmd->tvc_sgl_count) {
 -		for (i = 0; i < tv_cmd->tvc_sgl_count; i++)
 -			put_page(sg_page(&tv_cmd->tvc_sgl[i]));
 +	switch (tport->tport_proto_id) {
 +	case SCSI_PROTOCOL_SAS:
 +		return sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	case SCSI_PROTOCOL_FCP:
 +		return fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	case SCSI_PROTOCOL_ISCSI:
 +		return iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +					port_nexus_ptr);
 +	default:
 +		pr_err("Unknown tport_proto_id: 0x%02x, using"
 +			" SAS emulation\n", tport->tport_proto_id);
 +		break;
  	}
 -	if (tv_cmd->tvc_prot_sgl_count) {
 -		for (i = 0; i < tv_cmd->tvc_prot_sgl_count; i++)
 -			put_page(sg_page(&tv_cmd->tvc_prot_sgl[i]));
 +
 +	return sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,
 +			port_nexus_ptr);
 +}
 +
 +static struct se_node_acl *tcm_vhost_alloc_fabric_acl(
 +	struct se_portal_group *se_tpg)
++=======
++static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
 +{
 +	struct tcm_vhost_nacl *nacl;
 +
 +	nacl = kzalloc(sizeof(struct tcm_vhost_nacl), GFP_KERNEL);
 +	if (!nacl) {
 +		pr_err("Unable to allocate struct tcm_vhost_nacl\n");
 +		return NULL;
  	}
  
 -	vhost_scsi_put_inflight(tv_cmd->inflight);
 -	percpu_ida_free(&se_sess->sess_tag_pool, se_cmd->map_tag);
 +	return &nacl->se_node_acl;
  }
  
 -static int vhost_scsi_shutdown_session(struct se_session *se_sess)
 +static void tcm_vhost_release_fabric_acl(struct se_portal_group *se_tpg,
 +	struct se_node_acl *se_nacl)
 +{
 +	struct tcm_vhost_nacl *nacl = container_of(se_nacl,
 +			struct tcm_vhost_nacl, se_node_acl);
 +	kfree(nacl);
 +}
 +
 +static u32 tcm_vhost_tpg_get_inst_index(struct se_portal_group *se_tpg)
 +{
 +	return 1;
 +}
 +
 +static void tcm_vhost_release_cmd(struct se_cmd *se_cmd)
 +{
 +	return;
 +}
 +
 +static int tcm_vhost_shutdown_session(struct se_session *se_sess)
  {
  	return 0;
  }
@@@ -1989,35 -2127,33 +1993,55 @@@ static struct configfs_attribute *tcm_v
  	NULL,
  };
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops tcm_vhost_ops = {
 +	.get_fabric_name		= tcm_vhost_get_fabric_name,
 +	.get_fabric_proto_ident		= tcm_vhost_get_fabric_proto_ident,
 +	.tpg_get_wwn			= tcm_vhost_get_fabric_wwn,
 +	.tpg_get_tag			= tcm_vhost_get_tag,
 +	.tpg_get_default_depth		= tcm_vhost_get_default_depth,
 +	.tpg_get_pr_transport_id	= tcm_vhost_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= tcm_vhost_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= tcm_vhost_parse_pr_out_transport_id,
 +	.tpg_check_demo_mode		= tcm_vhost_check_true,
 +	.tpg_check_demo_mode_cache	= tcm_vhost_check_true,
 +	.tpg_check_demo_mode_write_protect = tcm_vhost_check_false,
 +	.tpg_check_prod_mode_write_protect = tcm_vhost_check_false,
 +	.tpg_alloc_fabric_acl		= tcm_vhost_alloc_fabric_acl,
 +	.tpg_release_fabric_acl		= tcm_vhost_release_fabric_acl,
 +	.tpg_get_inst_index		= tcm_vhost_tpg_get_inst_index,
 +	.release_cmd			= tcm_vhost_release_cmd,
 +	.shutdown_session		= tcm_vhost_shutdown_session,
 +	.close_session			= tcm_vhost_close_session,
 +	.sess_get_index			= tcm_vhost_sess_get_index,
++=======
+ static struct target_core_fabric_ops vhost_scsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "vhost",
+ 	.get_fabric_name		= vhost_scsi_get_fabric_name,
+ 	.tpg_get_wwn			= vhost_scsi_get_fabric_wwn,
+ 	.tpg_get_tag			= vhost_scsi_get_tpgt,
+ 	.tpg_check_demo_mode		= vhost_scsi_check_true,
+ 	.tpg_check_demo_mode_cache	= vhost_scsi_check_true,
+ 	.tpg_check_demo_mode_write_protect = vhost_scsi_check_false,
+ 	.tpg_check_prod_mode_write_protect = vhost_scsi_check_false,
+ 	.tpg_check_prot_fabric_only	= vhost_scsi_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= vhost_scsi_tpg_get_inst_index,
+ 	.release_cmd			= vhost_scsi_release_cmd,
+ 	.check_stop_free		= vhost_scsi_check_stop_free,
+ 	.shutdown_session		= vhost_scsi_shutdown_session,
+ 	.close_session			= vhost_scsi_close_session,
+ 	.sess_get_index			= vhost_scsi_sess_get_index,
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  	.sess_get_initiator_sid		= NULL,
 -	.write_pending			= vhost_scsi_write_pending,
 -	.write_pending_status		= vhost_scsi_write_pending_status,
 -	.set_default_node_attributes	= vhost_scsi_set_default_node_attrs,
 -	.get_task_tag			= vhost_scsi_get_task_tag,
 -	.get_cmd_state			= vhost_scsi_get_cmd_state,
 -	.queue_data_in			= vhost_scsi_queue_data_in,
 -	.queue_status			= vhost_scsi_queue_status,
 -	.queue_tm_rsp			= vhost_scsi_queue_tm_rsp,
 -	.aborted_task			= vhost_scsi_aborted_task,
 +	.write_pending			= tcm_vhost_write_pending,
 +	.write_pending_status		= tcm_vhost_write_pending_status,
 +	.set_default_node_attributes	= tcm_vhost_set_default_node_attrs,
 +	.get_task_tag			= tcm_vhost_get_task_tag,
 +	.get_cmd_state			= tcm_vhost_get_cmd_state,
 +	.queue_data_in			= tcm_vhost_queue_data_in,
 +	.queue_status			= tcm_vhost_queue_status,
 +	.queue_tm_rsp			= tcm_vhost_queue_tm_rsp,
  	/*
  	 * Setup callers for generic logic in target_core_fabric_configfs.c
  	 */
diff --cc include/target/target_core_fabric.h
index c9a57a197803,a420f434c6c5..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -162,41 -164,10 +153,44 @@@ int	core_tpg_set_initiator_node_queue_d
  		unsigned char *, u32, int);
  int	core_tpg_set_initiator_node_tag(struct se_portal_group *,
  		struct se_node_acl *, const char *);
 -int	core_tpg_register(const struct target_core_fabric_ops *,
 -		struct se_wwn *, struct se_portal_group *, int);
 +int	core_tpg_register(struct target_core_fabric_ops *, struct se_wwn *,
 +		struct se_portal_group *, void *, int);
  int	core_tpg_deregister(struct se_portal_group *);
  
++<<<<<<< HEAD
 +/* SAS helpers */
 +u8	sas_get_fabric_proto_ident(struct se_portal_group *);
 +u32	sas_get_pr_transport_id(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *, unsigned char *);
 +u32	sas_get_pr_transport_id_len(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *);
 +char	*sas_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 +		u32 *, char **);
 +
 +/* FC helpers */
 +u8	fc_get_fabric_proto_ident(struct se_portal_group *);
 +u32	fc_get_pr_transport_id(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *, unsigned char *);
 +u32	fc_get_pr_transport_id_len(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *);
 +char	*fc_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 +		u32 *, char **);
 +
 +/* iSCSI helpers */
 +u8	iscsi_get_fabric_proto_ident(struct se_portal_group *);
 +u32	iscsi_get_pr_transport_id(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *, unsigned char *);
 +u32	iscsi_get_pr_transport_id_len(struct se_portal_group *, struct se_node_acl *,
 +		struct t10_pr_registration *, int *);
 +char	*iscsi_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 +		u32 *, char **);
 +
 +int	target_alloc_sgl(struct scatterlist **sgl, unsigned int *nents,
 +		u32 length, bool zero_page, bool chainable);
 +void	target_free_sgl(struct scatterlist *sgl, int nents);
 +
++=======
++>>>>>>> 2650d71e244f (target: move transport ID handling to the core)
  /*
   * The LIO target core uses DMA_TO_DEVICE to mean that data is going
   * to the target (eg handling a WRITE) and DMA_FROM_DEVICE to mean
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path Documentation/target/tcm_mod_builder.py
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.h b/drivers/infiniband/ulp/srpt/ib_srpt.h
index 9077ca1e51ce..4024fe8476e8 100644
--- a/drivers/infiniband/ulp/srpt/ib_srpt.h
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.h
@@ -379,22 +379,4 @@ struct srpt_node_acl {
 	struct list_head	list;
 };
 
-/*
- * SRP-releated SCSI persistent reservation definitions.
- *
- * See also SPC4r28, section 7.6.1 (Protocol specific parameters introduction).
- * See also SPC4r28, section 7.6.4.5 (TransportID for initiator ports using
- * SCSI over an RDMA interface).
- */
-
-enum {
-	SCSI_TRANSPORTID_PROTOCOLID_SRP	= 4,
-};
-
-struct spc_rdma_transport_id {
-	uint8_t protocol_identifier;
-	uint8_t reserved[7];
-	uint8_t i_port_id[16];
-};
-
 #endif				/* IB_SRPT_H */
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.h b/drivers/scsi/qla2xxx/tcm_qla2xxx.h
index fe758517da6d..ee260b3453f8 100644
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.h
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.h
@@ -47,8 +47,6 @@ struct tcm_qla2xxx_fc_loopid {
 };
 
 struct tcm_qla2xxx_lport {
-	/* SCSI protocol the lport is providing */
-	u8 lport_proto_id;
 	/* Binary World Wide unique Port Name for FC Target Lport */
 	u64 lport_wwpn;
 	/* Binary World Wide unique Port Name for FC NPIV Target Lport */
* Unmerged path drivers/target/iscsi/iscsi_target_configfs.c
* Unmerged path drivers/target/loopback/tcm_loop.c
* Unmerged path drivers/target/sbp/sbp_target.c
* Unmerged path drivers/target/target_core_configfs.c
* Unmerged path drivers/target/target_core_fabric_lib.c
diff --git a/drivers/target/target_core_internal.h b/drivers/target/target_core_internal.h
index 874a9bc988d8..3b754276d664 100644
--- a/drivers/target/target_core_internal.h
+++ b/drivers/target/target_core_internal.h
@@ -41,6 +41,15 @@ struct se_device *target_alloc_device(struct se_hba *hba, const char *name);
 int	target_configure_device(struct se_device *dev);
 void	target_free_device(struct se_device *);
 
+/* target_core_fabric_lib.c */
+int	target_get_pr_transport_id_len(struct se_node_acl *nacl,
+		struct t10_pr_registration *pr_reg, int *format_code);
+int	target_get_pr_transport_id(struct se_node_acl *nacl,
+		struct t10_pr_registration *pr_reg, int *format_code,
+		unsigned char *buf);
+const char *target_parse_pr_out_transport_id(struct se_portal_group *tpg,
+		const char *buf, u32 *out_tid_len, char **port_nexus_ptr);
+
 /* target_core_hba.c */
 struct se_hba *core_alloc_hba(const char *, u32, u32);
 int	core_delete_hba(struct se_hba *);
* Unmerged path drivers/target/target_core_pr.c
* Unmerged path drivers/target/tcm_fc/tfc_conf.c
* Unmerged path drivers/usb/gadget/tcm_usb_gadget.c
diff --git a/drivers/usb/gadget/tcm_usb_gadget.h b/drivers/usb/gadget/tcm_usb_gadget.h
index 8289219925b8..bba2532e97f6 100644
--- a/drivers/usb/gadget/tcm_usb_gadget.h
+++ b/drivers/usb/gadget/tcm_usb_gadget.h
@@ -53,8 +53,6 @@ struct usbg_tpg {
 };
 
 struct usbg_tport {
-	/* SCSI protocol the tport is providing */
-	u8 tport_proto_id;
 	/* Binary World Wide unique Port Name for SAS Target port */
 	u64 tport_wwpn;
 	/* ASCII formatted WWPN for SAS Target port */
* Unmerged path drivers/vhost/scsi.c
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path include/target/target_core_fabric.h
