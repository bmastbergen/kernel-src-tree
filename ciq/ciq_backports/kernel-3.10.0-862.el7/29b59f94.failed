NFSv4: change nfs4_do_setattr to take an open_context instead of a nfs4_state.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] nfsv4: change nfs4_do_setattr to take an open_context instead of a nfs4_state (Benjamin Coddington) [1476826]
Rebuild_FUZZ: 99.35%
commit-author NeilBrown <neilb@suse.com>
commit 29b59f94169374c412cedf60c77073df4e68ce51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/29b59f94.failed

The open_context can always lead directly to the state, and is always easily
available, so this is a straightforward change.
Doing this makes more information available to _nfs4_do_setattr() for use
in the next patch.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 29b59f94169374c412cedf60c77073df4e68ce51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index b211a49fc834,3ab4dd5f7cfb..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -2911,14 -2944,13 +2911,14 @@@ static int _nfs4_do_setattr(struct inod
  
  	if (nfs4_copy_delegation_stateid(inode, fmode, &arg->stateid, &delegation_cred)) {
  		/* Use that stateid */
- 	} else if (truncate && state != NULL) {
+ 	} else if (truncate && ctx != NULL) {
  		struct nfs_lockowner lockowner = {
  			.l_owner = current->files,
 +			.l_pid = current->tgid,
  		};
- 		if (!nfs4_valid_open_stateid(state))
+ 		if (!nfs4_valid_open_stateid(ctx->state))
  			return -EBADF;
- 		if (nfs4_select_rw_stateid(state, FMODE_WRITE, &lockowner,
+ 		if (nfs4_select_rw_stateid(ctx->state, FMODE_WRITE, &lockowner,
  				&arg->stateid, &delegation_cred) == -EIO)
  			return -EBADF;
  	} else
@@@ -2941,9 -2973,10 +2941,16 @@@ static int nfs4_do_setattr(struct inod
  			   struct nfs4_label *olabel)
  {
  	struct nfs_server *server = NFS_SERVER(inode);
++<<<<<<< HEAD
 +	struct nfs_setattrargs	arg = {
 +		.fh		= NFS_FH(inode),
 +		.iap		= sattr,
++=======
+ 	struct nfs4_state *state = ctx ? ctx->state : NULL;
+         struct nfs_setattrargs  arg = {
+                 .fh             = NFS_FH(inode),
+                 .iap            = sattr,
++>>>>>>> 29b59f941693 (NFSv4: change nfs4_do_setattr to take an open_context instead of a nfs4_state.)
  		.server		= server,
  		.bitmask = server->attr_bitmask,
  		.label		= ilabel,
@@@ -3659,9 -3723,9 +3666,9 @@@ static in
  nfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
  		  struct iattr *sattr)
  {
 -	struct inode *inode = d_inode(dentry);
 +	struct inode *inode = dentry->d_inode;
  	struct rpc_cred *cred = NULL;
- 	struct nfs4_state *state = NULL;
+ 	struct nfs_open_context *ctx = NULL;
  	struct nfs4_label *label = NULL;
  	int status;
  
* Unmerged path fs/nfs/nfs4proc.c
