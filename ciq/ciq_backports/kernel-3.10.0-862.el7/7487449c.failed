IPv4: early demux can return an error code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit 7487449c86c65202b3b725c4524cb48dd65e4e6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7487449c.failed

Currently no error is emitted, but this infrastructure will
used by the next patch to allow source address validation
for mcast sockets.
Since early demux can do a route lookup and an ipv4 route
lookup can return an error code this is consistent with the
current ipv4 route infrastructure.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7487449c86c65202b3b725c4524cb48dd65e4e6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/protocol.h
#	include/net/udp.h
#	net/ipv4/ip_input.c
#	net/ipv4/udp.c
diff --cc include/net/protocol.h
index 426b64ab0ae7,4fc75f7ae23b..000000000000
--- a/include/net/protocol.h
+++ b/include/net/protocol.h
@@@ -39,7 -39,8 +39,12 @@@
  
  /* This is used to register protocols. */
  struct net_protocol {
++<<<<<<< HEAD
 +	void			(*early_demux)(struct sk_buff *skb);
++=======
+ 	int			(*early_demux)(struct sk_buff *skb);
+ 	int			(*early_demux_handler)(struct sk_buff *skb);
++>>>>>>> 7487449c86c6 (IPv4: early demux can return an error code)
  	int			(*handler)(struct sk_buff *skb);
  	void			(*err_handler)(struct sk_buff *skb, u32 info);
  	unsigned int		no_policy:1,
diff --cc include/net/udp.h
index 886fb5efc132,6c759c8594e2..000000000000
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@@ -246,44 -259,47 +246,60 @@@ static inline struct sk_buff *skb_recv_
  	return __skb_recv_udp(sk, flags, noblock, &peeked, &off, err);
  }
  
++<<<<<<< HEAD
 +void udp_v4_early_demux(struct sk_buff *skb);
 +extern int udp_get_port(struct sock *sk, unsigned short snum,
 +			int (*saddr_cmp)(const struct sock *,
 +					 const struct sock *));
 +extern void udp_err(struct sk_buff *, u32);
 +extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,
 +			    struct msghdr *msg, size_t len);
 +extern int udp_push_pending_frames(struct sock *sk);
 +extern void udp_flush_pending_frames(struct sock *sk);
 +extern void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst);
 +extern int udp_rcv(struct sk_buff *skb);
 +extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
++=======
+ int udp_v4_early_demux(struct sk_buff *skb);
+ bool udp_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst);
+ int udp_get_port(struct sock *sk, unsigned short snum,
+ 		 int (*saddr_cmp)(const struct sock *,
+ 				  const struct sock *));
+ void udp_err(struct sk_buff *, u32);
+ int udp_abort(struct sock *sk, int err);
+ int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len);
+ int udp_push_pending_frames(struct sock *sk);
+ void udp_flush_pending_frames(struct sock *sk);
+ void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst);
+ int udp_rcv(struct sk_buff *skb);
+ int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
++>>>>>>> 7487449c86c6 (IPv4: early demux can return an error code)
  int udp_init_sock(struct sock *sk);
 -int __udp_disconnect(struct sock *sk, int flags);
 -int udp_disconnect(struct sock *sk, int flags);
 -unsigned int udp_poll(struct file *file, struct socket *sock, poll_table *wait);
 -struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
 -				       netdev_features_t features,
 -				       bool is_ipv6);
 -int udp_lib_getsockopt(struct sock *sk, int level, int optname,
 -		       char __user *optval, int __user *optlen);
 -int udp_lib_setsockopt(struct sock *sk, int level, int optname,
 -		       char __user *optval, unsigned int optlen,
 -		       int (*push_pending_frames)(struct sock *));
 -struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 -			     __be32 daddr, __be16 dport, int dif);
 -struct sock *__udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 -			       __be32 daddr, __be16 dport, int dif, int sdif,
 -			       struct udp_table *tbl, struct sk_buff *skb);
 +extern int udp_disconnect(struct sock *sk, int flags);
 +extern unsigned int udp_poll(struct file *file, struct socket *sock,
 +			     poll_table *wait);
 +extern struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
 +					      netdev_features_t features,
 +					      bool is_ipv6);
 +extern int udp_lib_getsockopt(struct sock *sk, int level, int optname,
 +			      char __user *optval, int __user *optlen);
 +extern int udp_lib_setsockopt(struct sock *sk, int level, int optname,
 +			      char __user *optval, unsigned int optlen,
 +			      int (*push_pending_frames)(struct sock *));
 +extern struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 +				    __be32 daddr, __be16 dport,
 +				    int dif);
 +extern struct sock *__udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 +				    __be32 daddr, __be16 dport,
 +				    int dif, struct udp_table *tbl);
  struct sock *udp4_lib_lookup_skb(struct sk_buff *skb,
  				 __be16 sport, __be16 dport);
 -struct sock *udp6_lib_lookup(struct net *net,
 -			     const struct in6_addr *saddr, __be16 sport,
 -			     const struct in6_addr *daddr, __be16 dport,
 -			     int dif);
 -struct sock *__udp6_lib_lookup(struct net *net,
 -			       const struct in6_addr *saddr, __be16 sport,
 -			       const struct in6_addr *daddr, __be16 dport,
 -			       int dif, int sdif, struct udp_table *tbl,
 -			       struct sk_buff *skb);
 +extern struct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
 +				    const struct in6_addr *daddr, __be16 dport,
 +				    int dif);
 +extern struct sock *__udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
 +				    const struct in6_addr *daddr, __be16 dport,
 +				    int dif, struct udp_table *tbl);
  struct sock *udp6_lib_lookup_skb(struct sk_buff *skb,
  				 __be16 sport, __be16 dport);
  
diff --cc net/ipv4/ip_input.c
index 765cf7509b67,57fc13c6ab2b..000000000000
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@@ -308,21 -308,33 +308,35 @@@ drop
  	return true;
  }
  
 -static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 +int sysctl_ip_early_demux __read_mostly = 1;
 +EXPORT_SYMBOL(sysctl_ip_early_demux);
 +
 +static int ip_rcv_finish(struct sock *sk, struct sk_buff *skb)
  {
  	const struct iphdr *iph = ip_hdr(skb);
++<<<<<<< HEAD
 +	struct rtable *rt;
++=======
+ 	int (*edemux)(struct sk_buff *skb);
+ 	struct net_device *dev = skb->dev;
+ 	struct rtable *rt;
+ 	int err;
++>>>>>>> 7487449c86c6 (IPv4: early demux can return an error code)
  
 -	/* if ingress device is enslaved to an L3 master device pass the
 -	 * skb to its handler for processing
 -	 */
 -	skb = l3mdev_ip_rcv(skb);
 -	if (!skb)
 -		return NET_RX_SUCCESS;
 -
 -	if (net->ipv4.sysctl_ip_early_demux &&
 -	    !skb_dst(skb) &&
 -	    !skb->sk &&
 -	    !ip_is_fragment(iph)) {
 +	if (sysctl_ip_early_demux && !skb_dst(skb) && skb->sk == NULL) {
  		const struct net_protocol *ipprot;
  		int protocol = iph->protocol;
  
  		ipprot = rcu_dereference(inet_protos[protocol]);
++<<<<<<< HEAD
 +		if (ipprot && ipprot->early_demux) {
 +			ipprot->early_demux(skb);
++=======
+ 		if (ipprot && (edemux = READ_ONCE(ipprot->early_demux))) {
+ 			err = edemux(skb);
+ 			if (unlikely(err))
+ 				goto drop_error;
++>>>>>>> 7487449c86c6 (IPv4: early demux can return an error code)
  			/* must reload iph, skb->head might have changed */
  			iph = ip_hdr(skb);
  		}
@@@ -333,14 -345,10 +347,21 @@@
  	 *	how the packet travels inside Linux networking.
  	 */
  	if (!skb_valid_dst(skb)) {
++<<<<<<< HEAD
 +		int err = ip_route_input_noref(skb, iph->daddr, iph->saddr,
 +					       iph->tos, skb->dev);
 +		if (unlikely(err)) {
 +			if (err == -EXDEV)
 +				NET_INC_STATS_BH(dev_net(skb->dev),
 +						 LINUX_MIB_IPRPFILTER);
 +			goto drop;
 +		}
++=======
+ 		err = ip_route_input_noref(skb, iph->daddr, iph->saddr,
+ 					   iph->tos, dev);
+ 		if (unlikely(err))
+ 			goto drop_error;
++>>>>>>> 7487449c86c6 (IPv4: early demux can return an error code)
  	}
  
  #ifdef CONFIG_IP_ROUTE_CLASSID
diff --cc net/ipv4/udp.c
index c6e2b198be79,9b30f821fe96..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -2028,22 -2218,10 +2028,22 @@@ static struct sock *__udp4_lib_demux_lo
  		/* Only check first socket in chain */
  		break;
  	}
 -	return NULL;
 +
 +	if (result) {
 +		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 +			result = NULL;
 +		else if (unlikely(!INET_MATCH(sk, net, acookie,
 +					      rmt_addr, loc_addr,
 +					      ports, dif))) {
 +			sock_put(result);
 +			result = NULL;
 +		}
 +	}
 +	rcu_read_unlock();
 +	return result;
  }
  
- void udp_v4_early_demux(struct sk_buff *skb)
+ int udp_v4_early_demux(struct sk_buff *skb)
  {
  	struct net *net = dev_net(skb->dev);
  	const struct iphdr *iph;
@@@ -2076,16 -2255,15 +2076,21 @@@
  		}
  
  		sk = __udp4_lib_mcast_demux_lookup(net, uh->dest, iph->daddr,
 -						   uh->source, iph->saddr,
 -						   dif, sdif);
 +						   uh->source, iph->saddr, dif);
  	} else if (skb->pkt_type == PACKET_HOST) {
  		sk = __udp4_lib_demux_lookup(net, uh->dest, iph->daddr,
 -					     uh->source, iph->saddr, dif, sdif);
 +					     uh->source, iph->saddr, dif);
 +	} else {
 +		return;
  	}
  
++<<<<<<< HEAD
 +	if (!sk)
 +		return;
++=======
+ 	if (!sk || !refcount_inc_not_zero(&sk->sk_refcnt))
+ 		return 0;
++>>>>>>> 7487449c86c6 (IPv4: early demux can return an error code)
  
  	skb->sk = sk;
  	skb->destructor = sock_efree;
@@@ -2094,14 -2272,13 +2099,15 @@@
  	if (dst)
  		dst = dst_check(dst, 0);
  	if (dst) {
 -		/* set noref for now.
 -		 * any place which wants to hold dst has to call
 -		 * dst_hold_safe()
 -		 */
 -		skb_dst_set_noref(skb, dst);
 +		/* DST_NOCACHE can not be used without taking a reference */
 +		if (dst->flags & DST_NOCACHE) {
 +			if (likely(atomic_inc_not_zero(&dst->__refcnt)))
 +				skb_dst_set(skb, dst);
 +		} else {
 +			skb_dst_set_noref(skb, dst);
 +		}
  	}
+ 	return 0;
  }
  
  int udp_rcv(struct sk_buff *skb)
* Unmerged path include/net/protocol.h
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 516e6d399627..6b1d87284a89 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -362,7 +362,7 @@ void tcp_v4_err(struct sk_buff *skb, u32);
 
 void tcp_shutdown (struct sock *sk, int how);
 
-void tcp_v4_early_demux(struct sk_buff *skb);
+int tcp_v4_early_demux(struct sk_buff *skb);
 int tcp_v4_rcv(struct sk_buff *skb);
 
 int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
* Unmerged path include/net/udp.h
* Unmerged path net/ipv4/ip_input.c
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 47a597740e73..129581e2e89c 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -1517,23 +1517,23 @@ csum_err:
 }
 EXPORT_SYMBOL(tcp_v4_do_rcv);
 
-void tcp_v4_early_demux(struct sk_buff *skb)
+int tcp_v4_early_demux(struct sk_buff *skb)
 {
 	const struct iphdr *iph;
 	const struct tcphdr *th;
 	struct sock *sk;
 
 	if (skb->pkt_type != PACKET_HOST)
-		return;
+		return 0;
 
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))
-		return;
+		return 0;
 
 	iph = ip_hdr(skb);
 	th = tcp_hdr(skb);
 
 	if (th->doff < sizeof(struct tcphdr) / 4)
-		return;
+		return 0;
 
 	sk = __inet_lookup_established(dev_net(skb->dev), &tcp_hashinfo,
 				       iph->saddr, th->source,
@@ -1552,6 +1552,7 @@ void tcp_v4_early_demux(struct sk_buff *skb)
 				skb_dst_set_noref(skb, dst);
 		}
 	}
+	return 0;
 }
 
 /* Packet is added to VJ-style prequeue for processing in process
* Unmerged path net/ipv4/udp.c
