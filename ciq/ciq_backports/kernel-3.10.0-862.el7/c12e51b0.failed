radix-tree: replace node->height with node->shift

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit c12e51b07b3ac4c188fd91a82f96840fdb9cca6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c12e51b0.failed

node->shift represents the shift necessary for looking in the slots
array at this level.  It is equal to the old (node->height - 1) *
RADIX_TREE_MAP_SHIFT.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c12e51b07b3ac4c188fd91a82f96840fdb9cca6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/radix-tree.h
#	lib/radix-tree.c
diff --cc include/linux/radix-tree.h
index f94b73d0f147,037458257e12..000000000000
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@@ -86,7 -89,8 +86,12 @@@ static inline int radix_tree_is_indirec
  #define RADIX_TREE_COUNT_MASK	((1UL << RADIX_TREE_COUNT_SHIFT) - 1)
  
  struct radix_tree_node {
++<<<<<<< HEAD
 +	unsigned int	path;	/* Offset in parent & height from the bottom */
++=======
+ 	unsigned char	shift;	/* Bits remaining in each slot */
+ 	unsigned char	offset;	/* Slot offset in parent */
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  	unsigned int	count;
  	union {
  		struct {
diff --cc lib/radix-tree.c
index c40bb30382f1,648da9080418..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -219,10 -223,10 +219,17 @@@ static void dump_node(struct radix_tree
  {
  	unsigned long i;
  
++<<<<<<< HEAD
 +	pr_debug("radix node: %p offset %d tags %lx %lx %lx path %x count %d parent %p\n",
 +		node, offset,
 +		node->tags[0][0], node->tags[1][0], node->tags[2][0],
 +		node->path, node->count, node->parent);
++=======
+ 	pr_debug("radix node: %p offset %d tags %lx %lx %lx shift %d count %d parent %p\n",
+ 		node, node->offset,
+ 		node->tags[0][0], node->tags[1][0], node->tags[2][0],
+ 		node->shift, node->count, node->parent);
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  
  	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
  		unsigned long first = index | (i << shift);
@@@ -396,9 -419,14 +403,18 @@@ static inline unsigned long radix_tree_
  	return height_to_maxindex[height];
  }
  
+ static inline unsigned long shift_maxindex(unsigned int shift)
+ {
+ 	return (RADIX_TREE_MAP_SIZE << shift) - 1;
+ }
+ 
  static inline unsigned long node_maxindex(struct radix_tree_node *node)
  {
++<<<<<<< HEAD
 +	return radix_tree_maxindex(node->path & RADIX_TREE_HEIGHT_MASK);
++=======
+ 	return shift_maxindex(node->shift);
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  }
  
  static unsigned radix_tree_load_root(struct radix_tree_root *root,
@@@ -411,8 -439,7 +427,12 @@@
  	if (likely(radix_tree_is_indirect_ptr(node))) {
  		node = indirect_to_ptr(node);
  		*maxindex = node_maxindex(node);
++<<<<<<< HEAD
 +		return (node->path & RADIX_TREE_HEIGHT_MASK) *
 +			RADIX_TREE_MAP_SHIFT;
++=======
+ 		return node->shift + RADIX_TREE_MAP_SHIFT;
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  	}
  
  	*maxindex = 0;
@@@ -452,9 -480,10 +472,16 @@@ static int radix_tree_extend(struct rad
  		}
  
  		/* Increase the height.  */
++<<<<<<< HEAD
 +		newheight = root->height+1;
 +		BUG_ON(newheight & ~RADIX_TREE_HEIGHT_MASK);
 +		node->path = newheight;
++=======
+ 		newheight = root->height;
+ 		BUG_ON(newheight > BITS_PER_LONG);
+ 		node->shift = newheight * RADIX_TREE_MAP_SHIFT;
+ 		node->offset = 0;
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  		node->count = 1;
  		node->parent = NULL;
  		slot = root->rnode;
@@@ -513,15 -542,16 +540,19 @@@ int __radix_tree_create(struct radix_tr
  		}
  	}
  
- 	height = root->height;
- 
  	offset = 0;			/* uninitialised var warning */
  	while (shift > order) {
+ 		shift -= RADIX_TREE_MAP_SHIFT;
  		if (slot == NULL) {
  			/* Have to add a child node.  */
 -			slot = radix_tree_node_alloc(root);
 -			if (!slot)
 +			if (!(slot = radix_tree_node_alloc(root)))
  				return -ENOMEM;
++<<<<<<< HEAD
 +			slot->path = height;
++=======
+ 			slot->shift = shift;
+ 			slot->offset = offset;
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  			slot->parent = node;
  			if (node) {
  				rcu_assign_pointer(node->slots[offset],
@@@ -535,13 -564,12 +566,17 @@@
  			break;
  
  		/* Go a level down */
++<<<<<<< HEAD
 +		height--;
 +		shift -= RADIX_TREE_MAP_SHIFT;
++=======
+ 		node = indirect_to_ptr(slot);
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		offset = radix_tree_descend(node, &slot, offset);
 +		node = indirect_to_ptr(slot);
 +		slot = node->slots[offset];
  	}
  
 -#ifdef CONFIG_RADIX_TREE_MULTIORDER
  	/* Insert pointers to the canonical entry */
  	if (order > shift) {
  		int i, n = 1 << (order - shift);
@@@ -1278,54 -1319,44 +1313,58 @@@ EXPORT_SYMBOL(radix_tree_gang_lookup_ta
   * This linear search is at present only useful to shmem_unuse_inode().
   */
  static unsigned long __locate(struct radix_tree_node *slot, void *item,
 -			      unsigned long index, struct locate_info *info)
 +			      unsigned long index, unsigned long *found_index)
  {
 -	unsigned int shift;
 +	unsigned int shift, height;
  	unsigned long i;
  
++<<<<<<< HEAD
 +	height = slot->path & RADIX_TREE_HEIGHT_MASK;
 +	shift = (height-1) * RADIX_TREE_MAP_SHIFT;
++=======
+ 	shift = slot->shift + RADIX_TREE_MAP_SHIFT;
++>>>>>>> c12e51b07b3a (radix-tree: replace node->height with node->shift)
  
 -	do {
 -		shift -= RADIX_TREE_MAP_SHIFT;
 -
 -		for (i = (index >> shift) & RADIX_TREE_MAP_MASK;
 -		     i < RADIX_TREE_MAP_SIZE;
 -		     i++, index += (1UL << shift)) {
 -			struct radix_tree_node *node =
 -					rcu_dereference_raw(slot->slots[i]);
 -			if (node == RADIX_TREE_RETRY)
 +	for ( ; height > 1; height--) {
 +		i = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		for (;;) {
 +			if (slot->slots[i] != NULL)
 +				break;
 +			index &= ~((1UL << shift) - 1);
 +			index += 1UL << shift;
 +			if (index == 0)
 +				goto out;	/* 32-bit wraparound */
 +			i++;
 +			if (i == RADIX_TREE_MAP_SIZE)
  				goto out;
 -			if (!radix_tree_is_indirect_ptr(node)) {
 -				if (node == item) {
 -					info->found_index = index;
 -					info->stop = true;
 -					goto out;
 -				}
 -				continue;
 +		}
 +
 +		slot = rcu_dereference_raw(slot->slots[i]);
 +		if (slot == NULL)
 +			goto out;
 +		if (!radix_tree_is_indirect_ptr(slot)) {
 +			if (slot == item) {
 +				*found_index = index + i;
 +				index = 0;
 +			} else {
 +				index += shift;
  			}
 -			node = indirect_to_ptr(node);
 -			if (is_sibling_entry(slot, node))
 -				continue;
 -			slot = node;
 -			break;
 +			goto out;
  		}
 -		if (i == RADIX_TREE_MAP_SIZE)
 -			break;
 -	} while (shift);
 +		slot = indirect_to_ptr(slot);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +	}
  
 +	/* Bottom level: check items */
 +	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
 +		if (slot->slots[i] == item) {
 +			*found_index = index + i;
 +			index = 0;
 +			goto out;
 +		}
 +	}
 +	index += RADIX_TREE_MAP_SIZE;
  out:
 -	if ((index == 0) && (i == RADIX_TREE_MAP_SIZE))
 -		info->stop = true;
  	return index;
  }
  
* Unmerged path include/linux/radix-tree.h
* Unmerged path lib/radix-tree.c
