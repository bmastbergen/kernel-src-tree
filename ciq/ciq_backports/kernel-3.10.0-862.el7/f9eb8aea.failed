net_sched: transform qdisc running bit into a seqcount

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Dumazet <edumazet@google.com>
commit f9eb8aea2a1e12fc2f584d1627deeb957435a801
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f9eb8aea.failed

Instead of using a single bit (__QDISC___STATE_RUNNING)
in sch->__state, use a seqcount.

This adds lockdep support, but more importantly it will allow us
to sample qdisc/class statistics without having to grab qdisc root lock.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Cong Wang <xiyou.wangcong@gmail.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9eb8aea2a1e12fc2f584d1627deeb957435a801)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/ppp/ppp_generic.c
#	drivers/net/team/team.c
#	include/linux/netdevice.h
#	net/bluetooth/6lowpan.c
#	net/core/dev.c
#	net/ieee802154/6lowpan/core.c
#	net/l2tp/l2tp_eth.c
#	net/sched/sch_generic.c
diff --cc drivers/net/bonding/bond_main.c
index c4b097d4719d,681af31a60ed..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -4675,6 -4607,28 +4675,31 @@@ static int bond_check_params(struct bon
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static struct lock_class_key bonding_netdev_xmit_lock_key;
+ static struct lock_class_key bonding_netdev_addr_lock_key;
+ static struct lock_class_key bonding_tx_busylock_key;
+ static struct lock_class_key bonding_qdisc_running_key;
+ 
+ static void bond_set_lockdep_class_one(struct net_device *dev,
+ 				       struct netdev_queue *txq,
+ 				       void *_unused)
+ {
+ 	lockdep_set_class(&txq->_xmit_lock,
+ 			  &bonding_netdev_xmit_lock_key);
+ }
+ 
+ static void bond_set_lockdep_class(struct net_device *dev)
+ {
+ 	lockdep_set_class(&dev->addr_list_lock,
+ 			  &bonding_netdev_addr_lock_key);
+ 	netdev_for_each_tx_queue(dev, bond_set_lockdep_class_one, NULL);
+ 	dev->qdisc_tx_busylock = &bonding_tx_busylock_key;
+ 	dev->qdisc_running_key = &bonding_qdisc_running_key;
+ }
+ 
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  /* Called from registration process */
  static int bond_init(struct net_device *bond_dev)
  {
diff --cc drivers/net/ppp/ppp_generic.c
index 565165b4d88a,aeabaa42317f..000000000000
--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@@ -1058,9 -1312,13 +1058,19 @@@ ppp_get_stats64(struct net_device *dev
  	return stats64;
  }
  
++<<<<<<< HEAD
 +static int ppp_dev_init(struct net_device *dev)
 +{
 +	netdev_lockdep_set_classes(dev);
++=======
+ static struct lock_class_key ppp_tx_busylock;
+ static struct lock_class_key ppp_qdisc_running_key;
+ 
+ static int ppp_dev_init(struct net_device *dev)
+ {
+ 	dev->qdisc_tx_busylock = &ppp_tx_busylock;
+ 	dev->qdisc_running_key = &ppp_qdisc_running_key;
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  	return 0;
  }
  
diff --cc drivers/net/team/team.c
index 93f6926b4b66,00eb38956a2c..000000000000
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@@ -1570,6 -1574,26 +1570,29 @@@ static const struct team_option team_op
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static struct lock_class_key team_netdev_xmit_lock_key;
+ static struct lock_class_key team_netdev_addr_lock_key;
+ static struct lock_class_key team_tx_busylock_key;
+ static struct lock_class_key team_qdisc_running_key;
+ 
+ static void team_set_lockdep_class_one(struct net_device *dev,
+ 				       struct netdev_queue *txq,
+ 				       void *unused)
+ {
+ 	lockdep_set_class(&txq->_xmit_lock, &team_netdev_xmit_lock_key);
+ }
+ 
+ static void team_set_lockdep_class(struct net_device *dev)
+ {
+ 	lockdep_set_class(&dev->addr_list_lock, &team_netdev_addr_lock_key);
+ 	netdev_for_each_tx_queue(dev, team_set_lockdep_class_one, NULL);
+ 	dev->qdisc_tx_busylock = &team_tx_busylock_key;
+ 	dev->qdisc_running_key = &team_qdisc_running_key;
+ }
+ 
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  static int team_init(struct net_device *dev)
  {
  	struct team *team = netdev_priv(dev);
diff --cc include/linux/netdevice.h
index f2e995a93118,59d7e06d88d5..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1815,104 -1848,23 +1815,111 @@@ struct net_device 
  	u16			gso_max_segs;
  
  #ifdef CONFIG_DCB
 +	/* Data Center Bridging netlink ops */
  	const struct dcbnl_rtnl_ops *dcbnl_ops;
  #endif
 -	u8			num_tc;
 -	struct netdev_tc_txq	tc_to_txq[TC_MAX_QUEUE];
 -	u8			prio_tc_map[TC_BITMASK + 1];
 +	u8 num_tc;
 +	struct netdev_tc_txq tc_to_txq[TC_MAX_QUEUE];
 +	u8 prio_tc_map[TC_BITMASK + 1];
  
  #if IS_ENABLED(CONFIG_FCOE)
 +	/* max exchange id for FCoE LRO by ddp */
  	unsigned int		fcoe_ddp_xid;
  #endif
 -#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)
 +#if IS_ENABLED(CONFIG_NETPRIO_CGROUP)
  	struct netprio_map __rcu *priomap;
  #endif
++<<<<<<< HEAD
 +	/* phy device may attach itself for hardware timestamping */
 +	struct phy_device *phydev;
 +
 +	struct lock_class_key *qdisc_tx_busylock;
 +
 +	/* group the device belongs to */
 +	int group;
 +
 +	/* RHEL: e1000e was the only in-tree driver that used this */
 +	RH_KABI_DEPRECATE(struct pm_qos_request, pm_qos_req)
 +
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, unsigned long	gro_flush_timeout)
 +	RH_KABI_USE_P(2, atomic_long_t  rx_nohandler) /* inactive slave drops */
 +#ifndef __GENKSYMS__
 +	struct list_head	lower_dev_list;
 +
 +	/* directly linked devices, like slaves for bonding */
 +	struct {
 +		struct list_head upper;
 +		struct list_head lower;
 +	} adj_list;
 +
 +	/*
 +	 * RHEL ONLY: upstream has a matching all_adj_list that replaces
 +	 * upper_dev_list and lower_dev_list directly, but making that
 +	 * replacement would be a kabi nightmare, even more than we've
 +	 * already got right here.
 +	 */
 +#else
 +	/*
 +	 * struct list_head contains two pointers, no easy way to make use of
 +	 * two reserved pointers in a single RH_KABI_* macro, so we're going
 +	 * old school and using __GENKSYMS wrappers directly here.
 +	 */
 +	RH_KABI_USE_P(3, lower_dev_list.prev)
 +	RH_KABI_USE_P(4, lower_dev_list.next)
 +	RH_KABI_USE_P(5, adj_list.upper.prev)
 +	RH_KABI_USE_P(6, adj_list.upper.next)
 +	RH_KABI_USE_P(7, adj_list.lower.prev)
 +	RH_KABI_USE_P(8, adj_list.lower.next)
 +#endif
 +	RH_KABI_USE_P(9, const struct forwarding_accel_ops *fwd_ops)
 +	RH_KABI_USE_P(10, const struct dcbnl_rtnl_ops_ext *dcbnl_ops_ext)
 +	RH_KABI_USE_P(11, struct wpan_dev *ieee802154_ptr)
 +#ifndef __GENKSYMS__
 +	/*
 +	 * We can't use the RH_KABI_* helpers cleanly here, since
 +	 * list_head requires two reserved fields.
 +	 * Mark them as used anyway.
 +	 */
 +	struct list_head	close_list;
 +#else
 +	RH_KABI_USE_P(12, close_list.prev)
 +	RH_KABI_USE_P(13, close_list.next)
 +#endif
 +	RH_KABI_USE_P(14, const struct switchdev_ops *switchdev_ops)
 +	RH_KABI_USE_P(15, netdev_features_t gso_partial_features)
 +	RH_KABI_USE_P(16, struct net_device_extended *extended)
++=======
+ 	struct phy_device	*phydev;
+ 	struct lock_class_key	*qdisc_tx_busylock;
+ 	struct lock_class_key	*qdisc_running_key;
+ 	bool			proto_down;
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
 +};
 +
 +/* RHEL specific: Extension of struct net_device. Place new fields at the
 + * end of this struct. Be careful, we're not guarded by the automatic kABI
 + * checks, yet any changes here are kABI protected.
 + * This means only appends to this structure are allowed. Changes are
 + * generally disallowed with the exception of field renames (but not type
 + * changes nor any shuffling!).
 + *
 + *	@ndisc_ops:	Includes callbacks for different IPv6 neighbour
 + *			discovery handling. Necessary for e.g. 6LoWPAN.
 + *
 + */
 +struct net_device_extended {
 +#if IS_ENABLED(CONFIG_IPV6)
 +	const struct ndisc_ops *ndisc_ops;
 +#endif
  };
 +
  #define to_net_dev(d) container_of(d, struct net_device, dev)
  
  #define	NETDEV_ALIGN		32
diff --cc net/bluetooth/6lowpan.c
index 7437e9825acd,977a11e418d0..000000000000
--- a/net/bluetooth/6lowpan.c
+++ b/net/bluetooth/6lowpan.c
@@@ -627,9 -627,22 +627,28 @@@ static netdev_tx_t bt_xmit(struct sk_bu
  	return err < 0 ? NET_XMIT_DROP : err;
  }
  
++<<<<<<< HEAD
 +static int bt_dev_init(struct net_device *dev)
 +{
 +	netdev_lockdep_set_classes(dev);
++=======
+ static struct lock_class_key bt_tx_busylock;
+ static struct lock_class_key bt_netdev_xmit_lock_key;
+ static struct lock_class_key bt_qdisc_running_key;
+ 
+ static void bt_set_lockdep_class_one(struct net_device *dev,
+ 				     struct netdev_queue *txq,
+ 				     void *_unused)
+ {
+ 	lockdep_set_class(&txq->_xmit_lock, &bt_netdev_xmit_lock_key);
+ }
+ 
+ static int bt_dev_init(struct net_device *dev)
+ {
+ 	netdev_for_each_tx_queue(dev, bt_set_lockdep_class_one, NULL);
+ 	dev->qdisc_tx_busylock = &bt_tx_busylock;
+ 	dev->qdisc_running_key = &bt_qdisc_running_key;
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  
  	return 0;
  }
diff --cc net/core/dev.c
index 75255cb2d9d9,e0bcc39f4a7d..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -3050,8 -3075,8 +3050,13 @@@ static inline int __dev_xmit_skb(struc
  	/*
  	 * Heuristic to force contended enqueues to serialize on a
  	 * separate lock before trying to get qdisc main lock.
++<<<<<<< HEAD
 +	 * This permits __QDISC_STATE_RUNNING owner to get the lock more often
 +	 * and dequeue packets faster.
++=======
+ 	 * This permits qdisc->running owner to get the lock more
+ 	 * often and dequeue packets faster.
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  	 */
  	contended = qdisc_is_running(q);
  	if (unlikely(contended))
diff --cc net/ieee802154/6lowpan/core.c
index 61c83075fcd0,14aa5effd29a..000000000000
--- a/net/ieee802154/6lowpan/core.c
+++ b/net/ieee802154/6lowpan/core.c
@@@ -58,9 -58,23 +58,29 @@@ static struct header_ops lowpan_header_
  	.create	= lowpan_header_create,
  };
  
++<<<<<<< HEAD
 +static int lowpan_dev_init(struct net_device *ldev)
 +{
 +	netdev_lockdep_set_classes(ldev);
++=======
+ static struct lock_class_key lowpan_tx_busylock;
+ static struct lock_class_key lowpan_netdev_xmit_lock_key;
+ static struct lock_class_key lowpan_qdisc_running_key;
+ 
+ static void lowpan_set_lockdep_class_one(struct net_device *ldev,
+ 					 struct netdev_queue *txq,
+ 					 void *_unused)
+ {
+ 	lockdep_set_class(&txq->_xmit_lock,
+ 			  &lowpan_netdev_xmit_lock_key);
+ }
+ 
+ static int lowpan_dev_init(struct net_device *ldev)
+ {
+ 	netdev_for_each_tx_queue(ldev, lowpan_set_lockdep_class_one, NULL);
+ 	ldev->qdisc_tx_busylock = &lowpan_tx_busylock;
+ 	ldev->qdisc_running_key = &lowpan_qdisc_running_key;
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  
  	return 0;
  }
diff --cc net/l2tp/l2tp_eth.c
index 0ce7a542fcfb,c00d72d182fa..000000000000
--- a/net/l2tp/l2tp_eth.c
+++ b/net/l2tp/l2tp_eth.c
@@@ -67,14 -67,18 +67,26 @@@ static inline struct l2tp_eth_net *l2tp
  	return net_generic(net, l2tp_eth_net_id);
  }
  
++<<<<<<< HEAD
++=======
+ static struct lock_class_key l2tp_eth_tx_busylock;
+ static struct lock_class_key l2tp_qdisc_running_key;
+ 
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  static int l2tp_eth_dev_init(struct net_device *dev)
  {
  	struct l2tp_eth *priv = netdev_priv(dev);
  
  	priv->dev = dev;
  	eth_hw_addr_random(dev);
++<<<<<<< HEAD
 +	memset(&dev->broadcast[0], 0xff, 6);
 +	netdev_lockdep_set_classes(dev);
++=======
+ 	eth_broadcast_addr(dev->broadcast);
+ 	dev->qdisc_tx_busylock = &l2tp_eth_tx_busylock;
+ 	dev->qdisc_running_key = &l2tp_qdisc_running_key;
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
  
  	return 0;
  }
diff --cc net/sched/sch_generic.c
index e276704c5e88,cebea73e70ac..000000000000
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@@ -110,38 -108,9 +110,38 @@@ static struct sk_buff *dequeue_skb(stru
  	return skb;
  }
  
 +static inline int handle_dev_cpu_collision(struct sk_buff *skb,
 +					   struct netdev_queue *dev_queue,
 +					   struct Qdisc *q)
 +{
 +	int ret;
 +
 +	if (unlikely(dev_queue->xmit_lock_owner == smp_processor_id())) {
 +		/*
 +		 * Same CPU holding the lock. It may be a transient
 +		 * configuration error, when hard_start_xmit() recurses. We
 +		 * detect it by checking xmit owner and drop the packet when
 +		 * deadloop is detected. Return OK to try the next skb.
 +		 */
 +		kfree_skb_list(skb);
 +		net_warn_ratelimited("Dead loop on netdevice %s, fix it urgently!\n",
 +				     dev_queue->dev->name);
 +		ret = qdisc_qlen(q);
 +	} else {
 +		/*
 +		 * Another cpu is holding lock, requeue & delay xmits for
 +		 * some time.
 +		 */
 +		__this_cpu_inc(softnet_data.cpu_collision);
 +		ret = dev_requeue_skb(skb, q);
 +	}
 +
 +	return ret;
 +}
 +
  /*
   * Transmit possibly several skbs, and handle the return status as
-  * required. Holding the __QDISC___STATE_RUNNING bit guarantees that
+  * required. Owning running seqcount bit guarantees that
   * only one CPU can execute this function.
   *
   * Returns to the caller:
@@@ -197,7 -163,7 +197,11 @@@ int sch_direct_xmit(struct sk_buff *skb
  /*
   * NOTE: Called under qdisc_lock(q) with locally disabled BH.
   *
++<<<<<<< HEAD
 + * __QDISC_STATE_RUNNING guarantees only one CPU can process
++=======
+  * running seqcount guarantees only one CPU can process
++>>>>>>> f9eb8aea2a1e (net_sched: transform qdisc running bit into a seqcount)
   * this qdisc at a time. qdisc_lock(q) serializes queue accesses for
   * this queue.
   *
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/ppp/ppp_generic.c
* Unmerged path drivers/net/team/team.c
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index b90f5c9d5148..73b4c390685a 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -29,13 +29,6 @@ enum qdisc_state_t {
 	__QDISC_STATE_THROTTLED,
 };
 
-/*
- * following bits are only changed while qdisc lock is held
- */
-enum qdisc___state_t {
-	__QDISC___STATE_RUNNING = 1,
-};
-
 struct qdisc_size_table {
 	struct rcu_head		rcu;
 	struct list_head	list;
@@ -90,7 +83,7 @@ struct Qdisc {
 	unsigned long		state;
 	struct sk_buff_head	q;
 	struct gnet_stats_basic_packed bstats;
-	unsigned int		__state;
+	seqcount_t		running;
 	struct gnet_stats_queue	qstats;
 	struct rcu_head		rcu_head;
 	int			padded;
@@ -106,20 +99,20 @@ struct Qdisc {
 
 static inline bool qdisc_is_running(const struct Qdisc *qdisc)
 {
-	return (qdisc->__state & __QDISC___STATE_RUNNING) ? true : false;
+	return (raw_read_seqcount(&qdisc->running) & 1) ? true : false;
 }
 
 static inline bool qdisc_run_begin(struct Qdisc *qdisc)
 {
 	if (qdisc_is_running(qdisc))
 		return false;
-	qdisc->__state |= __QDISC___STATE_RUNNING;
+	write_seqcount_begin(&qdisc->running);
 	return true;
 }
 
 static inline void qdisc_run_end(struct Qdisc *qdisc)
 {
-	qdisc->__state &= ~__QDISC___STATE_RUNNING;
+	write_seqcount_end(&qdisc->running);
 }
 
 static inline bool qdisc_may_bulk(const struct Qdisc *qdisc)
* Unmerged path net/bluetooth/6lowpan.c
* Unmerged path net/core/dev.c
* Unmerged path net/ieee802154/6lowpan/core.c
* Unmerged path net/l2tp/l2tp_eth.c
* Unmerged path net/sched/sch_generic.c
