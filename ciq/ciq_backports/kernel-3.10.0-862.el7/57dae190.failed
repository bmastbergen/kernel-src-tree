target: Drop legacy se_cmd->task_stop_comp + REQUEST_STOP usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Drop legacy se_cmd->task_stop_comp + REQUEST_STOP usage (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 93.22%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 57dae19065bde296dfdf08b8e46c102a671ff741
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/57dae190.failed

With CMD_T_FABRIC_STOP + se_cmd->cmd_wait_set usage in place,
go ahead and drop left-over CMD_T_REQUEST_STOP checks in
target_complete_cmd() and unused target_stop_cmd().

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Quinn Tran <quinn.tran@qlogic.com>
	Cc: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: Andy Grover <agrover@redhat.com>
	Cc: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 57dae19065bde296dfdf08b8e46c102a671ff741)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_internal.h
#	drivers/target/target_core_transport.c
diff --cc drivers/target/target_core_internal.h
index 874a9bc988d8,db4412fe6b8a..000000000000
--- a/drivers/target/target_core_internal.h
+++ b/drivers/target/target_core_internal.h
@@@ -79,8 -141,7 +79,12 @@@ void	transport_dump_vpd_proto_id(struc
  int	transport_dump_vpd_assoc(struct t10_vpd *, unsigned char *, int);
  int	transport_dump_vpd_ident_type(struct t10_vpd *, unsigned char *, int);
  int	transport_dump_vpd_ident(struct t10_vpd *, unsigned char *, int);
++<<<<<<< HEAD
 +bool	target_stop_cmd(struct se_cmd *cmd, unsigned long *flags);
 +int	transport_clear_lun_ref(struct se_lun *);
++=======
+ void	transport_clear_lun_ref(struct se_lun *);
++>>>>>>> 57dae19065bd (target: Drop legacy se_cmd->task_stop_comp + REQUEST_STOP usage)
  void	transport_send_task_abort(struct se_cmd *);
  sense_reason_t	target_cmd_size_check(struct se_cmd *cmd, unsigned int size);
  void	target_qf_do_work(struct work_struct *work);
diff --cc drivers/target/target_core_transport.c
index 68bc47c2e404,d92cb644d8f9..000000000000
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@@ -723,19 -688,10 +723,10 @@@ void target_complete_cmd(struct se_cmd 
  		dev->transport->transport_complete(cmd,
  				cmd->t_data_sg,
  				transport_get_sense_buffer(cmd));
 -		if (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)
 -			success = 1;
  	}
 +	if (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)
 +		success = 1;
  
- 	/*
- 	 * See if we are waiting to complete for an exception condition.
- 	 */
- 	if (cmd->transport_state & CMD_T_REQUEST_STOP) {
- 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
- 		complete(&cmd->task_stop_comp);
- 		return;
- 	}
- 
  	/*
  	 * Check for case where an explicit ABORT_TASK has been received
  	 * and transport_wait_for_tasks() will be waiting for completion..
@@@ -1616,31 -1624,6 +1606,34 @@@ int target_submit_tmr(struct se_cmd *se
  EXPORT_SYMBOL(target_submit_tmr);
  
  /*
++<<<<<<< HEAD
 + * If the cmd is active, request it to be stopped and sleep until it
 + * has completed.
 + */
 +bool target_stop_cmd(struct se_cmd *cmd, unsigned long *flags)
 +{
 +	bool was_active = false;
 +
 +	if (cmd->transport_state & CMD_T_BUSY) {
 +		cmd->transport_state |= CMD_T_REQUEST_STOP;
 +		spin_unlock_irqrestore(&cmd->t_state_lock, *flags);
 +
 +		pr_debug("cmd %p waiting to complete\n", cmd);
 +		wait_for_completion(&cmd->task_stop_comp);
 +		pr_debug("cmd %p stopped successfully\n", cmd);
 +
 +		spin_lock_irqsave(&cmd->t_state_lock, *flags);
 +		cmd->transport_state &= ~CMD_T_REQUEST_STOP;
 +		cmd->transport_state &= ~CMD_T_BUSY;
 +		was_active = true;
 +	}
 +
 +	return was_active;
 +}
 +
 +/*
++=======
++>>>>>>> 57dae19065bd (target: Drop legacy se_cmd->task_stop_comp + REQUEST_STOP usage)
   * Handle SAM-esque emulation for generic transport request failures.
   */
  void transport_generic_request_failure(struct se_cmd *cmd,
* Unmerged path drivers/target/target_core_internal.h
* Unmerged path drivers/target/target_core_transport.c
diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h
index 6a27f0cf6579..cd373c22e48f 100644
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@ -532,7 +532,6 @@ struct se_cmd {
 #define CMD_T_SENT		(1 << 4)
 #define CMD_T_STOP		(1 << 5)
 #define CMD_T_DEV_ACTIVE	(1 << 7)
-#define CMD_T_REQUEST_STOP	(1 << 8)
 #define CMD_T_BUSY		(1 << 9)
 	spinlock_t		t_state_lock;
 	struct completion	t_transport_stop_comp;
@@ -550,9 +549,6 @@ struct se_cmd {
 	struct list_head	state_list;
 	bool			state_active;
 
-	/* old task stop completion, consider merging with some of the above */
-	struct completion	task_stop_comp;
-
 	/* backend private data */
 	void			*priv;
 
