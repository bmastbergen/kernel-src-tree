net: sched: introduce multichain support for filters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: introduce multichain support for filters (Ivan Vecera) [1445420]
Rebuild_FUZZ: 94.95%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 5bc1701881e395cec51811d07ec6961f3d1b2612
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5bc17018.failed

Instead of having only one filter per block, introduce a list of chains
for every block. Create chain 0 by default. UAPI is extended so the user
can specify which chain he wants to change. If the new attribute is not
specified, chain 0 is used. That allows to maintain backward
compatibility. If chain does not exist and user wants to manipulate with
it, new chain is created with specified index. Also, when last filter is
removed from the chain, the chain is destroyed.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5bc1701881e395cec51811d07ec6961f3d1b2612)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	include/net/sch_generic.h
#	include/uapi/linux/rtnetlink.h
#	net/sched/cls_api.c
diff --cc include/net/pkt_cls.h
index ddbf01b80b4c,2c213a69c196..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -17,6 -17,34 +17,37 @@@ struct tcf_walker 
  int register_tcf_proto_ops(struct tcf_proto_ops *ops);
  int unregister_tcf_proto_ops(struct tcf_proto_ops *ops);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_CLS
+ struct tcf_chain *tcf_chain_get(struct tcf_block *block, u32 chain_index);
+ void tcf_chain_put(struct tcf_chain *chain);
+ int tcf_block_get(struct tcf_block **p_block,
+ 		  struct tcf_proto __rcu **p_filter_chain);
+ void tcf_block_put(struct tcf_block *block);
+ int tcf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
+ 		 struct tcf_result *res, bool compat_mode);
+ 
+ #else
+ static inline
+ int tcf_block_get(struct tcf_block **p_block,
+ 		  struct tcf_proto __rcu **p_filter_chain)
+ {
+ 	return 0;
+ }
+ 
+ static inline void tcf_block_put(struct tcf_block *block)
+ {
+ }
+ 
+ static inline int tcf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
+ 			       struct tcf_result *res, bool compat_mode)
+ {
+ 	return TC_ACT_UNSPEC;
+ }
+ #endif
+ 
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  static inline unsigned long
  __cls_set_class(unsigned long *clp, unsigned long cl)
  {
diff --cc include/net/sch_generic.h
index 7b71681b10fc,569b5654c30c..000000000000
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@@ -238,7 -237,8 +239,12 @@@ struct tcf_proto 
  	struct Qdisc		*q;
  	void			*data;
  	const struct tcf_proto_ops	*ops;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(struct rcu_head		rcu)
++=======
+ 	struct tcf_chain	*chain;
+ 	struct rcu_head		rcu;
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  };
  
  struct qdisc_skb_cb {
@@@ -249,6 -249,19 +255,22 @@@
  	unsigned char		data[QDISC_CB_PRIV_LEN];
  };
  
++<<<<<<< HEAD
++=======
+ struct tcf_chain {
+ 	struct tcf_proto __rcu *filter_chain;
+ 	struct tcf_proto __rcu **p_filter_chain;
+ 	struct list_head list;
+ 	struct tcf_block *block;
+ 	u32 index; /* chain index */
+ 	unsigned int refcnt;
+ };
+ 
+ struct tcf_block {
+ 	struct list_head chain_list;
+ };
+ 
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  static inline void qdisc_cb_private_validate(const struct sk_buff *skb, int sz)
  {
  	struct qdisc_skb_cb *qcb;
diff --cc include/uapi/linux/rtnetlink.h
index d8701000036f,6487b21b2c1e..000000000000
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@@ -539,6 -548,8 +539,11 @@@ enum 
  	TCA_STATS2,
  	TCA_STAB,
  	TCA_PAD,
++<<<<<<< HEAD
++=======
+ 	TCA_DUMP_INVISIBLE,
+ 	TCA_CHAIN,
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  	__TCA_MAX
  };
  
diff --cc net/sched/cls_api.c
index 1dc6d123ed94,adacaf299c4a..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -124,7 -124,270 +124,274 @@@ static inline u32 tcf_auto_prio(struct 
  	if (tp)
  		first = tp->prio - 1;
  
++<<<<<<< HEAD
 +	return first;
++=======
+ 	return TC_H_MAJ(first);
+ }
+ 
+ static struct tcf_proto *tcf_proto_create(const char *kind, u32 protocol,
+ 					  u32 prio, u32 parent, struct Qdisc *q,
+ 					  struct tcf_chain *chain)
+ {
+ 	struct tcf_proto *tp;
+ 	int err;
+ 
+ 	tp = kzalloc(sizeof(*tp), GFP_KERNEL);
+ 	if (!tp)
+ 		return ERR_PTR(-ENOBUFS);
+ 
+ 	err = -ENOENT;
+ 	tp->ops = tcf_proto_lookup_ops(kind);
+ 	if (!tp->ops) {
+ #ifdef CONFIG_MODULES
+ 		rtnl_unlock();
+ 		request_module("cls_%s", kind);
+ 		rtnl_lock();
+ 		tp->ops = tcf_proto_lookup_ops(kind);
+ 		/* We dropped the RTNL semaphore in order to perform
+ 		 * the module load. So, even if we succeeded in loading
+ 		 * the module we have to replay the request. We indicate
+ 		 * this using -EAGAIN.
+ 		 */
+ 		if (tp->ops) {
+ 			module_put(tp->ops->owner);
+ 			err = -EAGAIN;
+ 		} else {
+ 			err = -ENOENT;
+ 		}
+ 		goto errout;
+ #endif
+ 	}
+ 	tp->classify = tp->ops->classify;
+ 	tp->protocol = protocol;
+ 	tp->prio = prio;
+ 	tp->classid = parent;
+ 	tp->q = q;
+ 	tp->chain = chain;
+ 
+ 	err = tp->ops->init(tp);
+ 	if (err) {
+ 		module_put(tp->ops->owner);
+ 		goto errout;
+ 	}
+ 	return tp;
+ 
+ errout:
+ 	kfree(tp);
+ 	return ERR_PTR(err);
+ }
+ 
+ static void tcf_proto_destroy(struct tcf_proto *tp)
+ {
+ 	tp->ops->destroy(tp);
+ 	module_put(tp->ops->owner);
+ 	kfree_rcu(tp, rcu);
+ }
+ 
+ static struct tcf_chain *tcf_chain_create(struct tcf_block *block,
+ 					  u32 chain_index)
+ {
+ 	struct tcf_chain *chain;
+ 
+ 	chain = kzalloc(sizeof(*chain), GFP_KERNEL);
+ 	if (!chain)
+ 		return NULL;
+ 	list_add_tail(&chain->list, &block->chain_list);
+ 	chain->block = block;
+ 	chain->index = chain_index;
+ 	chain->refcnt = 1;
+ 	return chain;
+ }
+ 
+ static void tcf_chain_destroy(struct tcf_chain *chain)
+ {
+ 	struct tcf_proto *tp;
+ 
+ 	list_del(&chain->list);
+ 	while ((tp = rtnl_dereference(chain->filter_chain)) != NULL) {
+ 		RCU_INIT_POINTER(chain->filter_chain, tp->next);
+ 		tcf_proto_destroy(tp);
+ 	}
+ 	kfree(chain);
+ }
+ 
+ struct tcf_chain *tcf_chain_get(struct tcf_block *block, u32 chain_index)
+ {
+ 	struct tcf_chain *chain;
+ 
+ 	list_for_each_entry(chain, &block->chain_list, list) {
+ 		if (chain->index == chain_index) {
+ 			chain->refcnt++;
+ 			return chain;
+ 		}
+ 	}
+ 	return tcf_chain_create(block, chain_index);
+ }
+ EXPORT_SYMBOL(tcf_chain_get);
+ 
+ void tcf_chain_put(struct tcf_chain *chain)
+ {
+ 	/* Destroy unused chain, with exception of chain 0, which is the
+ 	 * default one and has to be always present.
+ 	 */
+ 	if (--chain->refcnt == 0 && !chain->filter_chain && chain->index != 0)
+ 		tcf_chain_destroy(chain);
+ }
+ EXPORT_SYMBOL(tcf_chain_put);
+ 
+ static void
+ tcf_chain_filter_chain_ptr_set(struct tcf_chain *chain,
+ 			       struct tcf_proto __rcu **p_filter_chain)
+ {
+ 	chain->p_filter_chain = p_filter_chain;
+ }
+ 
+ int tcf_block_get(struct tcf_block **p_block,
+ 		  struct tcf_proto __rcu **p_filter_chain)
+ {
+ 	struct tcf_block *block = kzalloc(sizeof(*block), GFP_KERNEL);
+ 	struct tcf_chain *chain;
+ 	int err;
+ 
+ 	if (!block)
+ 		return -ENOMEM;
+ 	INIT_LIST_HEAD(&block->chain_list);
+ 	/* Create chain 0 by default, it has to be always present. */
+ 	chain = tcf_chain_create(block, 0);
+ 	if (!chain) {
+ 		err = -ENOMEM;
+ 		goto err_chain_create;
+ 	}
+ 	tcf_chain_filter_chain_ptr_set(chain, p_filter_chain);
+ 	*p_block = block;
+ 	return 0;
+ 
+ err_chain_create:
+ 	kfree(block);
+ 	return err;
+ }
+ EXPORT_SYMBOL(tcf_block_get);
+ 
+ void tcf_block_put(struct tcf_block *block)
+ {
+ 	struct tcf_chain *chain, *tmp;
+ 
+ 	if (!block)
+ 		return;
+ 
+ 	list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
+ 		tcf_chain_destroy(chain);
+ 	kfree(block);
+ }
+ EXPORT_SYMBOL(tcf_block_put);
+ 
+ /* Main classifier routine: scans classifier chain attached
+  * to this qdisc, (optionally) tests for protocol and asks
+  * specific classifiers.
+  */
+ int tcf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
+ 		 struct tcf_result *res, bool compat_mode)
+ {
+ 	__be16 protocol = tc_skb_protocol(skb);
+ #ifdef CONFIG_NET_CLS_ACT
+ 	const int max_reclassify_loop = 4;
+ 	const struct tcf_proto *old_tp = tp;
+ 	int limit = 0;
+ 
+ reclassify:
+ #endif
+ 	for (; tp; tp = rcu_dereference_bh(tp->next)) {
+ 		int err;
+ 
+ 		if (tp->protocol != protocol &&
+ 		    tp->protocol != htons(ETH_P_ALL))
+ 			continue;
+ 
+ 		err = tp->classify(skb, tp, res);
+ #ifdef CONFIG_NET_CLS_ACT
+ 		if (unlikely(err == TC_ACT_RECLASSIFY && !compat_mode))
+ 			goto reset;
+ #endif
+ 		if (err >= 0)
+ 			return err;
+ 	}
+ 
+ 	return TC_ACT_UNSPEC; /* signal: continue lookup */
+ #ifdef CONFIG_NET_CLS_ACT
+ reset:
+ 	if (unlikely(limit++ >= max_reclassify_loop)) {
+ 		net_notice_ratelimited("%s: reclassify loop, rule prio %u, protocol %02x\n",
+ 				       tp->q->ops->id, tp->prio & 0xffff,
+ 				       ntohs(tp->protocol));
+ 		return TC_ACT_SHOT;
+ 	}
+ 
+ 	tp = old_tp;
+ 	protocol = tc_skb_protocol(skb);
+ 	goto reclassify;
+ #endif
+ }
+ EXPORT_SYMBOL(tcf_classify);
+ 
+ struct tcf_chain_info {
+ 	struct tcf_proto __rcu **pprev;
+ 	struct tcf_proto __rcu *next;
+ };
+ 
+ static struct tcf_proto *tcf_chain_tp_prev(struct tcf_chain_info *chain_info)
+ {
+ 	return rtnl_dereference(*chain_info->pprev);
+ }
+ 
+ static void tcf_chain_tp_insert(struct tcf_chain *chain,
+ 				struct tcf_chain_info *chain_info,
+ 				struct tcf_proto *tp)
+ {
+ 	if (chain->p_filter_chain &&
+ 	    *chain_info->pprev == chain->filter_chain)
+ 		*chain->p_filter_chain = tp;
+ 	RCU_INIT_POINTER(tp->next, tcf_chain_tp_prev(chain_info));
+ 	rcu_assign_pointer(*chain_info->pprev, tp);
+ }
+ 
+ static void tcf_chain_tp_remove(struct tcf_chain *chain,
+ 				struct tcf_chain_info *chain_info,
+ 				struct tcf_proto *tp)
+ {
+ 	struct tcf_proto *next = rtnl_dereference(chain_info->next);
+ 
+ 	if (chain->p_filter_chain && tp == chain->filter_chain)
+ 		*chain->p_filter_chain = next;
+ 	RCU_INIT_POINTER(*chain_info->pprev, next);
+ }
+ 
+ static struct tcf_proto *tcf_chain_tp_find(struct tcf_chain *chain,
+ 					   struct tcf_chain_info *chain_info,
+ 					   u32 protocol, u32 prio,
+ 					   bool prio_allocate)
+ {
+ 	struct tcf_proto **pprev;
+ 	struct tcf_proto *tp;
+ 
+ 	/* Check the chain for existence of proto-tcf with this priority */
+ 	for (pprev = &chain->filter_chain;
+ 	     (tp = rtnl_dereference(*pprev)); pprev = &tp->next) {
+ 		if (tp->prio >= prio) {
+ 			if (tp->prio == prio) {
+ 				if (prio_allocate ||
+ 				    (tp->protocol != protocol && protocol))
+ 					return ERR_PTR(-EINVAL);
+ 			} else {
+ 				tp = NULL;
+ 			}
+ 			break;
+ 		}
+ 	}
+ 	chain_info->pprev = pprev;
+ 	chain_info->next = tp ? tp->next : NULL;
+ 	return tp;
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  }
  
  /* Add/change/delete/get a filter node */
@@@ -136,15 -400,15 +403,22 @@@ static int tc_ctl_tfilter(struct sk_buf
  	struct tcmsg *t;
  	u32 protocol;
  	u32 prio;
 -	bool prio_allocate;
 +	u32 nprio;
  	u32 parent;
+ 	u32 chain_index;
  	struct net_device *dev;
  	struct Qdisc  *q;
++<<<<<<< HEAD
 +	struct tcf_proto __rcu **back;
 +	struct tcf_proto __rcu **chain;
 +	struct tcf_proto *next;
++=======
+ 	struct tcf_chain_info chain_info;
+ 	struct tcf_chain *chain = NULL;
+ 	struct tcf_block *block;
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  	struct tcf_proto *tp;
 +	const struct tcf_proto_ops *tp_ops;
  	const struct Qdisc_class_ops *cops;
  	unsigned long cl;
  	unsigned long fh;
@@@ -221,13 -487,26 +495,29 @@@ replay
  	}
  
  	/* And the last stroke */
 -	block = cops->tcf_block(q, cl);
 -	if (!block) {
 -		err = -EINVAL;
 +	chain = cops->tcf_chain(q, cl);
 +	err = -EINVAL;
 +	if (chain == NULL)
  		goto errout;
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	chain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;
+ 	if (chain_index > TC_ACT_EXT_VAL_MASK) {
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 	chain = tcf_chain_get(block, chain_index);
+ 	if (!chain) {
+ 		err = -ENOMEM;
+ 		goto errout;
+ 	}
+ 
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  	if (n->nlmsg_type == RTM_DELTFILTER && prio == 0) {
  		tfilter_notify_chain(net, skb, n, chain, RTM_DELTFILTER);
 -		tcf_chain_destroy(chain);
 +		tcf_destroy_chain(chain);
  		err = 0;
  		goto errout;
  	}
@@@ -308,10 -532,20 +598,22 @@@
  			goto errout;
  		}
  
++<<<<<<< HEAD
++=======
+ 		if (prio_allocate)
+ 			prio = tcf_auto_prio(tcf_chain_tp_prev(&chain_info));
+ 
+ 		tp = tcf_proto_create(nla_data(tca[TCA_KIND]),
+ 				      protocol, prio, parent, q, chain);
+ 		if (IS_ERR(tp)) {
+ 			err = PTR_ERR(tp);
+ 			goto errout;
+ 		}
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  		tp_created = 1;
 -	} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {
 -		err = -EINVAL;
 +
 +	} else if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind))
  		goto errout;
 -	}
  
  	fh = tp->ops->get(tp, t->tcm_handle);
  
@@@ -458,19 -697,68 +764,79 @@@ static int tcf_node_dump(struct tcf_pro
  			     RTM_NEWTFILTER);
  }
  
++<<<<<<< HEAD
++=======
+ static bool tcf_chain_dump(struct tcf_chain *chain, struct sk_buff *skb,
+ 			   struct netlink_callback *cb,
+ 			   long index_start, long *p_index)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct tcmsg *tcm = nlmsg_data(cb->nlh);
+ 	struct tcf_dump_args arg;
+ 	struct tcf_proto *tp;
+ 
+ 	for (tp = rtnl_dereference(chain->filter_chain);
+ 	     tp; tp = rtnl_dereference(tp->next), (*p_index)++) {
+ 		if (*p_index < index_start)
+ 			continue;
+ 		if (TC_H_MAJ(tcm->tcm_info) &&
+ 		    TC_H_MAJ(tcm->tcm_info) != tp->prio)
+ 			continue;
+ 		if (TC_H_MIN(tcm->tcm_info) &&
+ 		    TC_H_MIN(tcm->tcm_info) != tp->protocol)
+ 			continue;
+ 		if (*p_index > index_start)
+ 			memset(&cb->args[1], 0,
+ 			       sizeof(cb->args) - sizeof(cb->args[0]));
+ 		if (cb->args[1] == 0) {
+ 			if (tcf_fill_node(net, skb, tp, 0,
+ 					  NETLINK_CB(cb->skb).portid,
+ 					  cb->nlh->nlmsg_seq, NLM_F_MULTI,
+ 					  RTM_NEWTFILTER) <= 0)
+ 				return false;
+ 
+ 			cb->args[1] = 1;
+ 		}
+ 		if (!tp->ops->walk)
+ 			continue;
+ 		arg.w.fn = tcf_node_dump;
+ 		arg.skb = skb;
+ 		arg.cb = cb;
+ 		arg.w.stop = 0;
+ 		arg.w.skip = cb->args[1] - 1;
+ 		arg.w.count = 0;
+ 		tp->ops->walk(tp, &arg.w);
+ 		cb->args[1] = arg.w.count + 1;
+ 		if (arg.w.stop)
+ 			return false;
+ 	}
+ 	return true;
+ }
+ 
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  /* called with RTNL */
  static int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	struct net *net = sock_net(skb->sk);
++<<<<<<< HEAD
 +	int t;
 +	int s_t;
++=======
+ 	struct nlattr *tca[TCA_MAX + 1];
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  	struct net_device *dev;
  	struct Qdisc *q;
 -	struct tcf_block *block;
 -	struct tcf_chain *chain;
 +	struct tcf_proto *tp, __rcu **chain;
  	struct tcmsg *tcm = nlmsg_data(cb->nlh);
  	unsigned long cl = 0;
  	const struct Qdisc_class_ops *cops;
++<<<<<<< HEAD
 +	struct tcf_dump_args arg;
++=======
+ 	long index_start;
+ 	long index;
+ 	int err;
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  
  	if (nlmsg_len(cb->nlh) < sizeof(*tcm))
  		return skb->len;
@@@ -494,49 -787,22 +865,64 @@@
  		if (cl == 0)
  			goto errout;
  	}
 -	block = cops->tcf_block(q, cl);
 -	if (!block)
 +	chain = cops->tcf_chain(q, cl);
 +	if (chain == NULL)
  		goto errout;
  
++<<<<<<< HEAD
 +	s_t = cb->args[0];
 +
 +	for (tp = rtnl_dereference(*chain), t = 0;
 +	     tp; tp = rtnl_dereference(tp->next), t++) {
 +		if (t < s_t)
 +			continue;
 +		if (TC_H_MAJ(tcm->tcm_info) &&
 +		    TC_H_MAJ(tcm->tcm_info) != tp->prio)
 +			continue;
 +		if (TC_H_MIN(tcm->tcm_info) &&
 +		    TC_H_MIN(tcm->tcm_info) != tp->protocol)
 +			continue;
 +		if (t > s_t)
 +			memset(&cb->args[1], 0,
 +			       sizeof(cb->args)-sizeof(cb->args[0]));
 +		if (cb->args[1] == 0) {
 +			if (tcf_fill_node(net, skb, tp, 0,
 +					  NETLINK_CB(cb->skb).portid,
 +					  cb->nlh->nlmsg_seq, NLM_F_MULTI,
 +					  RTM_NEWTFILTER) <= 0)
 +				break;
 +
 +			cb->args[1] = 1;
 +		}
 +		if (tp->ops->walk == NULL)
 +			continue;
 +		arg.w.fn = tcf_node_dump;
 +		arg.skb = skb;
 +		arg.cb = cb;
 +		arg.w.stop = 0;
 +		arg.w.skip = cb->args[1] - 1;
 +		arg.w.count = 0;
 +		tp->ops->walk(tp, &arg.w);
 +		cb->args[1] = arg.w.count + 1;
 +		if (arg.w.stop)
 +			break;
 +	}
 +
 +	cb->args[0] = t;
++=======
+ 	index_start = cb->args[0];
+ 	index = 0;
+ 
+ 	list_for_each_entry(chain, &block->chain_list, list) {
+ 		if (tca[TCA_CHAIN] &&
+ 		    nla_get_u32(tca[TCA_CHAIN]) != chain->index)
+ 			continue;
+ 		if (!tcf_chain_dump(chain, skb, cb, index_start, &index))
+ 			break;
+ 	}
+ 
+ 	cb->args[0] = index;
++>>>>>>> 5bc1701881e3 (net: sched: introduce multichain support for filters)
  
  errout:
  	if (cl)
* Unmerged path include/net/pkt_cls.h
* Unmerged path include/net/sch_generic.h
* Unmerged path include/uapi/linux/rtnetlink.h
* Unmerged path net/sched/cls_api.c
