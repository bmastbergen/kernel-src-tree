iommu/amd: Detect and enable guest vAPIC support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] amd: Detect and enable guest vAPIC support (Jerry Snitselaar) [1411581]
Rebuild_FUZZ: 93.33%
commit-author Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
commit 3928aa3f5775fc4e40117077e97d73d8526039c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3928aa3f.failed

This patch introduces a new IOMMU driver parameter, amd_iommu_guest_ir,
which can be used to specify different interrupt remapping mode for
passthrough devices to VM guest:
    * legacy: Legacy interrupt remapping (w/ 32-bit IRTE)
    * vapic : Guest vAPIC interrupt remapping (w/ GA mode 128-bit IRTE)

Note that in vapic mode, it can also supports legacy interrupt remapping
for non-passthrough devices with the 128-bit IRTE.

	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 3928aa3f5775fc4e40117077e97d73d8526039c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu_init.c
diff --cc drivers/iommu/amd_iommu_init.c
index d1b313b945cf,c3afd8669bfb..000000000000
--- a/drivers/iommu/amd_iommu_init.c
+++ b/drivers/iommu/amd_iommu_init.c
@@@ -1240,7 -1250,34 +1242,38 @@@ static int __init init_iommu_one(struc
  	iommu->cap_ptr = h->cap_ptr;
  	iommu->pci_seg = h->pci_seg;
  	iommu->mmio_phys = h->mmio_phys;
++<<<<<<< HEAD
 +	iommu->mmio_base = iommu_map_mmio_space(h->mmio_phys);
++=======
+ 
+ 	switch (h->type) {
+ 	case 0x10:
+ 		/* Check if IVHD EFR contains proper max banks/counters */
+ 		if ((h->efr_attr != 0) &&
+ 		    ((h->efr_attr & (0xF << 13)) != 0) &&
+ 		    ((h->efr_attr & (0x3F << 17)) != 0))
+ 			iommu->mmio_phys_end = MMIO_REG_END_OFFSET;
+ 		else
+ 			iommu->mmio_phys_end = MMIO_CNTR_CONF_OFFSET;
+ 		if (((h->efr_attr & (0x1 << IOMMU_FEAT_GASUP_SHIFT)) == 0))
+ 			amd_iommu_guest_ir = AMD_IOMMU_GUEST_IR_LEGACY;
+ 		break;
+ 	case 0x11:
+ 	case 0x40:
+ 		if (h->efr_reg & (1 << 9))
+ 			iommu->mmio_phys_end = MMIO_REG_END_OFFSET;
+ 		else
+ 			iommu->mmio_phys_end = MMIO_CNTR_CONF_OFFSET;
+ 		if (((h->efr_reg & (0x1 << IOMMU_EFR_GASUP_SHIFT)) == 0))
+ 			amd_iommu_guest_ir = AMD_IOMMU_GUEST_IR_LEGACY;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	iommu->mmio_base = iommu_map_mmio_space(iommu->mmio_phys,
+ 						iommu->mmio_phys_end);
++>>>>>>> 3928aa3f5775 (iommu/amd: Detect and enable guest vAPIC support)
  	if (!iommu->mmio_base)
  		return -ENOMEM;
  
@@@ -1487,11 -1565,18 +1529,22 @@@ static void print_iommu_info(void
  				if (iommu_feature(iommu, (1ULL << i)))
  					pr_cont(" %s", feat_str[i]);
  			}
++<<<<<<< HEAD
 +		pr_cont("\n");
++=======
+ 
+ 			if (iommu->features & FEATURE_GAM_VAPIC)
+ 				pr_cont(" GA_vAPIC");
+ 
+ 			pr_cont("\n");
++>>>>>>> 3928aa3f5775 (iommu/amd: Detect and enable guest vAPIC support)
  		}
  	}
- 	if (irq_remapping_enabled)
+ 	if (irq_remapping_enabled) {
  		pr_info("AMD-Vi: Interrupt remapping enabled\n");
+ 		if (AMD_IOMMU_GUEST_IR_VAPIC(amd_iommu_guest_ir))
+ 			pr_info("AMD-Vi: virtual APIC enabled\n");
+ 	}
  }
  
  static int __init amd_iommu_init_pci(void)
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 1d9178db9795..52ea5983b850 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -367,6 +367,15 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			driver will print ACPI tables for AMD IOMMU during
 			IOMMU initialization.
 
+	amd_iommu_intr=	[HW,X86-64]
+			Specifies one of the following AMD IOMMU interrupt
+			remapping modes:
+			legacy     - Use legacy interrupt remapping mode.
+			vapic      - Use virtual APIC mode, which allows IOMMU
+			             to inject interrupts directly into guest.
+			             This mode requires kvm-amd.avic=1.
+			             (Default when IOMMU HW support is present.)
+
 	amijoy.map=	[HW,JOY] Amiga joystick support
 			Map of devices attached to JOY0DAT and JOY1DAT
 			Format: <a>,<b>
* Unmerged path drivers/iommu/amd_iommu_init.c
diff --git a/drivers/iommu/amd_iommu_proto.h b/drivers/iommu/amd_iommu_proto.h
index a3b5a778d824..25ea6e27397d 100644
--- a/drivers/iommu/amd_iommu_proto.h
+++ b/drivers/iommu/amd_iommu_proto.h
@@ -38,6 +38,7 @@ extern int amd_iommu_enable(void);
 extern void amd_iommu_disable(void);
 extern int amd_iommu_reenable(int);
 extern int amd_iommu_enable_faulting(void);
+extern int amd_iommu_guest_ir;
 
 /* IOMMUv2 specific functions */
 struct iommu_domain;
diff --git a/drivers/iommu/amd_iommu_types.h b/drivers/iommu/amd_iommu_types.h
index c9e00df52a4f..0eef560edbb4 100644
--- a/drivers/iommu/amd_iommu_types.h
+++ b/drivers/iommu/amd_iommu_types.h
@@ -91,6 +91,7 @@
 #define FEATURE_GA		(1ULL<<7)
 #define FEATURE_HE		(1ULL<<8)
 #define FEATURE_PC		(1ULL<<9)
+#define FEATURE_GAM_VAPIC	(1ULL<<21)
 
 #define FEATURE_PASID_SHIFT	32
 #define FEATURE_PASID_MASK	(0x1fULL << FEATURE_PASID_SHIFT)
@@ -145,6 +146,8 @@
 #define CONTROL_PPFINT_EN       0x0eULL
 #define CONTROL_PPR_EN          0x0fULL
 #define CONTROL_GT_EN           0x10ULL
+#define CONTROL_GA_EN           0x11ULL
+#define CONTROL_GAM_EN          0x19ULL
 
 #define CTRL_INV_TO_MASK	(7 << CONTROL_INV_TIMEOUT)
 #define CTRL_INV_TO_NONE	0
@@ -328,6 +331,12 @@
 #define IOMMU_CAP_NPCACHE 26
 #define IOMMU_CAP_EFR     27
 
+/* IOMMU Feature Reporting Field (for IVHD type 10h */
+#define IOMMU_FEAT_GASUP_SHIFT	6
+
+/* IOMMU Extended Feature Register (EFR) */
+#define IOMMU_EFR_GASUP_SHIFT	7
+
 #define MAX_DOMAIN_ID 65536
 
 /* Protection domain flags */
@@ -668,4 +677,19 @@ static inline int get_hpet_devid(int id)
 	return -EINVAL;
 }
 
+enum amd_iommu_intr_mode_type {
+	AMD_IOMMU_GUEST_IR_LEGACY,
+
+	/* This mode is not visible to users. It is used when
+	 * we cannot fully enable vAPIC and fallback to only support
+	 * legacy interrupt remapping via 128-bit IRTE.
+	 */
+	AMD_IOMMU_GUEST_IR_LEGACY_GA,
+	AMD_IOMMU_GUEST_IR_VAPIC,
+};
+
+#define AMD_IOMMU_GUEST_IR_GA(x)	(x == AMD_IOMMU_GUEST_IR_VAPIC || \
+					 x == AMD_IOMMU_GUEST_IR_LEGACY_GA)
+
+#define AMD_IOMMU_GUEST_IR_VAPIC(x)	(x == AMD_IOMMU_GUEST_IR_VAPIC)
 #endif /* _ASM_X86_AMD_IOMMU_TYPES_H */
