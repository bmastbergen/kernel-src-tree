IB/hfi1: Remove pstate from hfi1_pportdata

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Byczkowski <jakub.byczkowski@intel.com>
commit d392a673e718767049824f99c76bb483d893b881
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d392a673.failed

Do not track physical state separately from host_link_state.
Deduce physical state from host_link_state when required.
Change cache_physical_state to log_physical_state to make
sure host_link_state reflects hardwares physical state properly.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Jakub Byczkowski <jakub.byczkowski@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit d392a673e718767049824f99c76bb483d893b881)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.c
#	drivers/infiniband/hw/hfi1/chip.h
#	drivers/infiniband/hw/hfi1/hfi.h
#	drivers/infiniband/hw/hfi1/mad.c
diff --cc drivers/infiniband/hw/hfi1/chip.c
index 7d6d914ddcf9,eb27c7fbfebd..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@@ -1065,13 -1065,18 +1065,20 @@@ static int do_8051_command(struct hfi1_
  static int read_idle_sma(struct hfi1_devdata *dd, u64 *data);
  static int thermal_init(struct hfi1_devdata *dd);
  
 -static void update_statusp(struct hfi1_pportdata *ppd, u32 state);
  static int wait_logical_linkstate(struct hfi1_pportdata *ppd, u32 state,
  				  int msecs);
++<<<<<<< HEAD
++=======
+ static void log_state_transition(struct hfi1_pportdata *ppd, u32 state);
+ static void log_physical_state(struct hfi1_pportdata *ppd, u32 state);
+ static int wait_physical_linkstate(struct hfi1_pportdata *ppd, u32 state,
+ 				   int msecs);
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  static void read_planned_down_reason_code(struct hfi1_devdata *dd, u8 *pdrrc);
  static void read_link_down_reason(struct hfi1_devdata *dd, u8 *ldr);
 -static void handle_temp_err(struct hfi1_devdata *dd);
 -static void dc_shutdown(struct hfi1_devdata *dd);
 -static void dc_start(struct hfi1_devdata *dd);
 +static void handle_temp_err(struct hfi1_devdata *);
 +static void dc_shutdown(struct hfi1_devdata *);
 +static void dc_start(struct hfi1_devdata *);
  static int qos_rmt_entries(struct hfi1_devdata *dd, unsigned int *mp,
  			   unsigned int *np);
  static void clear_full_mgmt_pkey(struct hfi1_pportdata *ppd);
@@@ -10669,6 -10721,8 +10676,11 @@@ int set_link_state(struct hfi1_pportdat
  		 */
  		if (ret)
  			goto_offline(ppd, 0);
++<<<<<<< HEAD
++=======
+ 		else
+ 			log_physical_state(ppd, PLS_POLLING);
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  		break;
  	case HLS_DN_DISABLE:
  		/* link is disabled */
@@@ -10710,6 -10771,7 +10722,10 @@@
  		if (ppd->host_link_state != HLS_DN_POLL)
  			goto unexpected;
  		ppd->host_link_state = HLS_VERIFY_CAP;
++<<<<<<< HEAD
++=======
+ 		log_physical_state(ppd, PLS_CONFIGPHY_VERIFYCAP);
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  		break;
  	case HLS_GOING_UP:
  		if (ppd->host_link_state != HLS_VERIFY_CAP)
@@@ -12672,32 -12723,85 +12688,92 @@@ static int wait_logical_linkstate(struc
  
  	timeout = jiffies + msecs_to_jiffies(msecs);
  	while (1) {
 -		new_state = chip_to_opa_lstate(ppd->dd,
 -					       read_logical_state(ppd->dd));
 -		if (new_state == state)
 +		if (get_logical_state(ppd) == state)
 +			return 0;
 +		if (time_after(jiffies, timeout))
  			break;
 -		if (time_after(jiffies, timeout)) {
 -			dd_dev_err(ppd->dd,
 -				   "timeout waiting for link state 0x%x\n",
 -				   state);
 -			return -ETIMEDOUT;
 -		}
  		msleep(20);
  	}
 +	dd_dev_err(ppd->dd, "timeout waiting for link state 0x%x\n", state);
  
 -	update_statusp(ppd, state);
 -	dd_dev_info(ppd->dd,
 -		    "logical state changed to %s (0x%x)\n",
 -		    opa_lstate_name(state),
 -		    state);
 -	return 0;
 +	return -ETIMEDOUT;
  }
  
++<<<<<<< HEAD
 +u8 hfi1_ibphys_portstate(struct hfi1_pportdata *ppd)
 +{
 +	u32 pstate;
 +	u32 ib_pstate;
 +
 +	pstate = read_physical_state(ppd->dd);
 +	ib_pstate = chip_to_opa_pstate(ppd->dd, pstate);
 +	if (ppd->last_pstate != ib_pstate) {
 +		dd_dev_info(ppd->dd,
 +			    "%s: physical state changed to %s (0x%x), phy 0x%x\n",
 +			    __func__, opa_pstate_name(ib_pstate), ib_pstate,
 +			    pstate);
 +		ppd->last_pstate = ib_pstate;
 +	}
 +	return ib_pstate;
++=======
+ static void log_state_transition(struct hfi1_pportdata *ppd, u32 state)
+ {
+ 	u32 ib_pstate = chip_to_opa_pstate(ppd->dd, state);
+ 
+ 	dd_dev_info(ppd->dd,
+ 		    "physical state changed to %s (0x%x), phy 0x%x\n",
+ 		    opa_pstate_name(ib_pstate), ib_pstate, state);
+ }
+ 
+ /*
+  * Read the physical hardware link state and check if it matches host
+  * drivers anticipated state.
+  */
+ static void log_physical_state(struct hfi1_pportdata *ppd, u32 state)
+ {
+ 	u32 read_state = read_physical_state(ppd->dd);
+ 
+ 	if (read_state == state) {
+ 		log_state_transition(ppd, state);
+ 	} else {
+ 		dd_dev_err(ppd->dd,
+ 			   "anticipated phy link state 0x%x, read 0x%x\n",
+ 			   state, read_state);
+ 	}
+ }
+ 
+ /*
+  * wait_physical_linkstate - wait for an physical link state change to occur
+  * @ppd: port device
+  * @state: the state to wait for
+  * @msecs: the number of milliseconds to wait
+  *
+  * Wait up to msecs milliseconds for physical link state change to occur.
+  * Returns 0 if state reached, otherwise -ETIMEDOUT.
+  */
+ static int wait_physical_linkstate(struct hfi1_pportdata *ppd, u32 state,
+ 				   int msecs)
+ {
+ 	u32 read_state;
+ 	unsigned long timeout;
+ 
+ 	timeout = jiffies + msecs_to_jiffies(msecs);
+ 	while (1) {
+ 		read_state = read_physical_state(ppd->dd);
+ 		if (read_state == state)
+ 			break;
+ 		if (time_after(jiffies, timeout)) {
+ 			dd_dev_err(ppd->dd,
+ 				   "timeout waiting for phy link state 0x%x\n",
+ 				   state);
+ 			return -ETIMEDOUT;
+ 		}
+ 		usleep_range(1950, 2050); /* sleep 2ms-ish */
+ 	}
+ 
+ 	log_state_transition(ppd, state);
+ 	return 0;
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  }
  
  #define CLEAR_STATIC_RATE_CONTROL_SMASK(r) \
@@@ -14804,7 -14905,6 +14880,10 @@@ struct hfi1_devdata *hfi1_init_dd(struc
  		/* start in offline */
  		ppd->host_link_state = HLS_DN_OFFLINE;
  		init_vl_arb_caches(ppd);
++<<<<<<< HEAD
 +		ppd->last_pstate = 0xff; /* invalid value */
++=======
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  	}
  
  	dd->link_default = HLS_DN_POLL;
diff --cc drivers/infiniband/hw/hfi1/chip.h
index 91c2eda4de60,b8345a60a0fb..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@@ -740,11 -747,10 +740,18 @@@ int is_ax(struct hfi1_devdata *dd)
  int is_bx(struct hfi1_devdata *dd);
  u32 read_physical_state(struct hfi1_devdata *dd);
  u32 chip_to_opa_pstate(struct hfi1_devdata *dd, u32 chip_pstate);
++<<<<<<< HEAD
 +u32 get_logical_state(struct hfi1_pportdata *ppd);
 +const char *opa_lstate_name(u32 lstate);
 +const char *opa_pstate_name(u32 pstate);
 +u32 driver_physical_state(struct hfi1_pportdata *ppd);
 +u32 driver_logical_state(struct hfi1_pportdata *ppd);
++=======
+ const char *opa_lstate_name(u32 lstate);
+ const char *opa_pstate_name(u32 pstate);
+ u32 driver_pstate(struct hfi1_pportdata *ppd);
+ u32 driver_lstate(struct hfi1_pportdata *ppd);
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  
  int acquire_lcb_access(struct hfi1_devdata *dd, int sleep_ok);
  int release_lcb_access(struct hfi1_devdata *dd, int sleep_ok);
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index 8f4007275430,b15749eab921..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -665,7 -758,6 +665,10 @@@ struct hfi1_pportdata 
  	u8 link_enabled;	/* link enabled? */
  	u8 linkinit_reason;
  	u8 local_tx_rate;	/* rate given to 8051 firmware */
++<<<<<<< HEAD
 +	u8 last_pstate;		/* info only */
++=======
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  	u8 qsfp_retry_count;
  
  	/* placeholders for IB MAD packet settings */
@@@ -1317,21 -1427,6 +1320,24 @@@ static inline __le32 *get_rhf_addr(stru
  
  int hfi1_reset_device(int);
  
++<<<<<<< HEAD
 +/* return the driver's idea of the logical OPA port state */
 +static inline u32 driver_lstate(struct hfi1_pportdata *ppd)
 +{
 +	/*
 +	 * The driver does some processing from the time the logical
 +	 * link state is at INIT to the time the SM can be notified
 +	 * as such. Return IB_PORT_DOWN until the software state
 +	 * is ready.
 +	 */
 +	if (ppd->lstate == IB_PORT_INIT && !(ppd->host_link_state & HLS_UP))
 +		return IB_PORT_DOWN;
 +	else
 +		return ppd->lstate;
 +}
 +
++=======
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  void receive_interrupt_work(struct work_struct *work);
  
  /* extract service channel from header and rhf */
diff --cc drivers/infiniband/hw/hfi1/mad.c
index d59426fb9866,4849130d49bc..000000000000
--- a/drivers/infiniband/hw/hfi1/mad.c
+++ b/drivers/infiniband/hw/hfi1/mad.c
@@@ -926,8 -1181,8 +926,13 @@@ static int physical_transition_allowed(
  static int port_states_transition_allowed(struct hfi1_pportdata *ppd,
  					  u32 logical_new, u32 physical_new)
  {
++<<<<<<< HEAD
 +	u32 physical_old = driver_physical_state(ppd);
 +	u32 logical_old = driver_logical_state(ppd);
++=======
+ 	u32 physical_old = driver_pstate(ppd);
+ 	u32 logical_old = driver_lstate(ppd);
++>>>>>>> d392a673e718 (IB/hfi1: Remove pstate from hfi1_pportdata)
  	int ret, logical_allowed, physical_allowed;
  
  	ret = logical_transition_allowed(logical_old, logical_new);
* Unmerged path drivers/infiniband/hw/hfi1/chip.c
* Unmerged path drivers/infiniband/hw/hfi1/chip.h
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
* Unmerged path drivers/infiniband/hw/hfi1/mad.c
