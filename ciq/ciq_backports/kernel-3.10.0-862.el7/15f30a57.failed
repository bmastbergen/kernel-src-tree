qla2xxx: Use IOCB interface to submit non-critical MBX.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Use IOCB interface to submit non-critical MBX (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 99.08%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 15f30a5752287f20c7de428423c34bc51cfbe465
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/15f30a57.failed

The Mailbox interface is currently over subscribed. We like
to reserve the Mailbox interface for the chip managment and
link initialization. Any non essential Mailbox command will
be routed through the IOCB interface. The IOCB interface is
able to absorb more commands.

Following commands are being routed through IOCB interface

- Get ID List (007Ch)
- Get Port DB (0064h)
- Get Link Priv Stats (006Dh)

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 15f30a5752287f20c7de428423c34bc51cfbe465)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mbx.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,ae38b7a789b1..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -363,6 -394,20 +363,23 @@@ struct srb_iocb 
  			__le16 comp_status;
  			struct completion comp;
  		} abt;
++<<<<<<< HEAD
++=======
+ 		struct ct_arg ctarg;
+ #define MAX_IOCB_MB_REG 28
+ #define SIZEOF_IOCB_MB_REG (MAX_IOCB_MB_REG * sizeof(uint16_t))
+ 		struct {
+ 			__le16 in_mb[MAX_IOCB_MB_REG];	/* from FW */
+ 			__le16 out_mb[MAX_IOCB_MB_REG];	/* to FW */
+ 			void *out, *in;
+ 			dma_addr_t out_dma, in_dma;
+ 			struct completion comp;
+ 			int rc;
+ 		} mbx;
+ 		struct {
+ 			struct imm_ntfy_from_isp *ntfy;
+ 		} nack;
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  	} u;
  
  	struct timer_list timer;
@@@ -390,16 -440,19 +407,16 @@@ typedef struct srb 
  	uint32_t handle;
  	uint16_t flags;
  	uint16_t type;
- 	char *name;
+ 	const char *name;
  	int iocbs;
  	struct qla_qpair *qpair;
 -	u32 gen1;	/* scratch */
 -	u32 gen2;	/* scratch */
  	union {
  		struct srb_iocb iocb_cmd;
 -		struct bsg_job *bsg_job;
 +		struct fc_bsg_job *bsg_job;
  		struct srb_cmd scmd;
  	} u;
 -	void (*done)(void *, int);
 -	void (*free)(void *);
 +	void (*done)(void *, void *, int);
 +	void (*free)(void *, void *);
  } srb_t;
  
  #define GET_CMD_SP(sp) (sp->u.scmd.cmd)
@@@ -3014,12 -3360,16 +3031,14 @@@ struct qla_hw_data 
  		uint32_t	isp82xx_no_md_cap:1;
  		uint32_t	host_shutting_down:1;
  		uint32_t	idc_compl_status:1;
 +
  		uint32_t        mr_reset_hdlr_active:1;
  		uint32_t        mr_intr_valid:1;
 -
 -		uint32_t        dport_enabled:1;
 +		uint32_t	dport_enabled:1;
  		uint32_t	fawwpn_enabled:1;
 -		uint32_t	exlogins_enabled:1;
 -		uint32_t	exchoffld_enabled:1;
  		/* 35 bits */
+ 
+ 		uint32_t	fw_started:1;
  	} flags;
  
  	/* This spinlock is used to protect "io transactions", you must
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,323b912b47f7..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -167,9 -186,14 +167,20 @@@ extern int qla2x00_post_uevent_work(str
  
  extern int qla2x00_post_uevent_work(struct scsi_qla_host *, u32);
  extern void qla2x00_disable_board_on_pci_error(struct work_struct *);
++<<<<<<< HEAD
 +extern void qla2x00_sp_compl(void *, void *, int);
 +extern void qla2xxx_qpair_sp_free_dma(void *, void *);
 +extern void qla2xxx_qpair_sp_compl(void *, void *, int);
++=======
+ extern void qla2x00_sp_compl(void *, int);
+ extern void qla2xxx_qpair_sp_free_dma(void *);
+ extern void qla2xxx_qpair_sp_compl(void *, int);
+ extern int qla24xx_post_upd_fcport_work(struct scsi_qla_host *, fc_port_t *);
+ void qla2x00_handle_login_done_event(struct scsi_qla_host *, fc_port_t *,
+ 	uint16_t *);
+ int qla24xx_post_gnl_work(struct scsi_qla_host *, fc_port_t *);
+ int qla24xx_async_abort_cmd(srb_t *);
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  
  /*
   * Global Functions in qla_mid.c source file.
@@@ -344,7 -369,7 +355,11 @@@ qla2x00_get_link_status(scsi_qla_host_
  
  extern int
  qla24xx_get_isp_stats(scsi_qla_host_t *, struct link_statistics *,
++<<<<<<< HEAD
 +	dma_addr_t, uint);
++=======
+     dma_addr_t, uint16_t);
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  
  extern int qla24xx_abort_command(srb_t *);
  extern int qla24xx_async_abort_command(srb_t *);
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,b1bfa63f7d4e..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -274,6 -318,815 +274,817 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *conflict_fcport;
+ 	struct get_name_list_extended *e;
+ 	u16 i, n, found = 0, loop_id;
+ 	port_id_t id;
+ 	u64 wwn;
+ 	u8 opt = 0;
+ 
+ 	fcport = ea->fcport;
+ 
+ 	if (ea->rc) { /* rval */
+ 		if (fcport->login_retry == 0) {
+ 			fcport->login_retry = vha->hw->login_retry_count;
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				"GNL failed Port login retry %8phN, retry cnt=%d.\n",
+ 				fcport->port_name, fcport->login_retry);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC rscn gen changed rscn %d|%d \n",
+ 		    __func__, fcport->port_name,
+ 		    fcport->last_rscn_gen, fcport->rscn_gen);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	} else if (fcport->last_login_gen != fcport->login_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s %8phC login gen changed login %d|%d \n",
+ 			__func__, fcport->port_name,
+ 			fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	n = ea->data[0] / sizeof(struct get_name_list_extended);
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %d %8phC n %d %02x%02x%02x lid %d \n",
+ 	    __func__, __LINE__, fcport->port_name, n,
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa, fcport->loop_id);
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		if (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))
+ 			continue;
+ 
+ 		found = 1;
+ 		id.b.domain = e->port_id[2];
+ 		id.b.area = e->port_id[1];
+ 		id.b.al_pa = e->port_id[0];
+ 		id.b.rsvd_1 = 0;
+ 
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		loop_id = (loop_id & 0x7fff);
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s found %8phC CLS [%d|%d] ID[%02x%02x%02x|%02x%02x%02x] lid[%d|%d]\n",
+ 			   __func__, fcport->port_name,
+ 			e->current_login_state, fcport->fw_login_state,
+ 			id.b.domain, id.b.area, id.b.al_pa,
+ 			fcport->d_id.b.domain, fcport->d_id.b.area,
+ 			fcport->d_id.b.al_pa, loop_id, fcport->loop_id);
+ 
+ 		if ((id.b24 != fcport->d_id.b24) ||
+ 		    ((fcport->loop_id != FC_NO_LOOP_ID) &&
+ 			(fcport->loop_id != loop_id))) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post del sess\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qlt_schedule_sess_for_deletion(fcport, 1);
+ 			return;
+ 		}
+ 
+ 		fcport->loop_id = loop_id;
+ 
+ 		wwn = wwn_to_u64(fcport->port_name);
+ 		qlt_find_sess_invalidate_other(vha, wwn,
+ 			id, loop_id, &conflict_fcport);
+ 
+ 		if (conflict_fcport) {
+ 			/*
+ 			 * Another share fcport share the same loop_id &
+ 			 * nport id. Conflict fcport needs to finish
+ 			 * cleanup before this fcport can proceed to login.
+ 			 */
+ 			conflict_fcport->conflict = fcport;
+ 			fcport->login_pause = 1;
+ 		}
+ 
+ 		switch (e->current_login_state) {
+ 		case DSC_LS_PRLI_COMP:
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			opt = PDO_FORCE_ADISC;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 			break;
+ 
+ 		case DSC_LS_PORT_UNAVAIL:
+ 		default:
+ 			if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 				qla2x00_find_new_loop_id(vha, fcport);
+ 				fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 			}
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		/* fw has no record of this port */
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			qla2x00_find_new_loop_id(vha, fcport);
+ 			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		} else {
+ 			for (i = 0; i < n; i++) {
+ 				e = &vha->gnl.l[i];
+ 				id.b.domain = e->port_id[0];
+ 				id.b.area = e->port_id[1];
+ 				id.b.al_pa = e->port_id[2];
+ 				id.b.rsvd_1 = 0;
+ 				loop_id = le16_to_cpu(e->nport_handle);
+ 
+ 				if (fcport->d_id.b24 == id.b24) {
+ 					conflict_fcport =
+ 					    qla2x00_find_fcport_by_wwpn(vha,
+ 						e->port_name, 0);
+ 
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__,
+ 					    conflict_fcport->port_name);
+ 					qlt_schedule_sess_for_deletion
+ 						(conflict_fcport, 1);
+ 				}
+ 
+ 				if (fcport->loop_id == loop_id) {
+ 					/* FW already picked this loop id for another fcport */
+ 					qla2x00_find_new_loop_id(vha, fcport);
+ 				}
+ 			}
+ 		}
+ 		qla24xx_fcport_handle_login(vha, fcport);
+ 	}
+ } /* gnl_event */
+ 
+ static void
+ qla24xx_async_gnl_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	unsigned long flags;
+ 	struct fc_port *fcport = NULL, *tf;
+ 	u16 i, n = 0, loop_id;
+ 	struct event_arg ea;
+ 	struct get_name_list_extended *e;
+ 	u64 wwn;
+ 	struct list_head h;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],
+ 	    sp->u.iocb_cmd.u.mbx.in_mb[2]);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GNL_DONE;
+ 
+ 	if (sp->u.iocb_cmd.u.mbx.in_mb[1] >=
+ 	    sizeof(struct get_name_list_extended)) {
+ 		n = sp->u.iocb_cmd.u.mbx.in_mb[1] /
+ 		    sizeof(struct get_name_list_extended);
+ 		ea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1]; /* amnt xfered */
+ 	}
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		/* mask out reserve bit */
+ 		loop_id = (loop_id & 0x7fff);
+ 		set_bit(loop_id, vha->hw->loop_id_map);
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		ql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,
+ 		    "%s %8phC %02x:%02x:%02x state %d/%d lid %x \n",
+ 		    __func__, (void *)&wwn, e->port_id[2], e->port_id[1],
+ 		    e->port_id[0], e->current_login_state, e->last_login_state,
+ 		    (loop_id & 0x7fff));
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	vha->gnl.sent = 0;
+ 
+ 	INIT_LIST_HEAD(&h);
+ 	fcport = tf = NULL;
+ 	if (!list_empty(&vha->gnl.fcports))
+ 		list_splice_init(&vha->gnl.fcports, &h);
+ 
+ 	list_for_each_entry_safe(fcport, tf, &h, gnl_entry) {
+ 		list_del_init(&fcport->gnl_entry);
+ 		fcport->flags &= ~FCF_ASYNC_SENT;
+ 		ea.fcport = fcport;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	unsigned long flags;
+ 	u16 *mb;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-gnlist WWPN %8phC \n", fcport->port_name);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GNL;
+ 	fcport->last_rscn_gen = fcport->rscn_gen;
+ 	fcport->last_login_gen = fcport->login_gen;
+ 
+ 	list_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);
+ 	if (vha->gnl.sent) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		rval = QLA_SUCCESS;
+ 		goto done;
+ 	}
+ 	vha->gnl.sent = 1;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gnlist";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_PORT_NODE_NAME_LIST;
+ 	mb[1] = BIT_2 | BIT_3;
+ 	mb[2] = MSW(vha->gnl.ldma);
+ 	mb[3] = LSW(vha->gnl.ldma);
+ 	mb[6] = MSW(MSD(vha->gnl.ldma));
+ 	mb[7] = LSW(MSD(vha->gnl.ldma));
+ 	mb[8] = vha->gnl.size;
+ 	mb[9] = vha->vp_idx;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 
+ 	sp->done = qla24xx_async_gnl_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s - OUT WWPN %8phC hndl %x\n",
+ 		sp->name, fcport->port_name, sp->handle);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GNL);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla24xx_async_gpdb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct port_database_24xx *pd;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;
+ 	int rval = QLA_SUCCESS;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, fcport->port_name, mb[1], mb[2]);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res) {
+ 		rval = res;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
+ 
+ 	rval = __qla24xx_parse_gpdb(vha, fcport, pd);
+ 
+ gpd_error_out:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPDB_DONE;
+ 	ea.rc = rval;
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	dma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,
+ 		sp->u.iocb_cmd.u.mbx.in_dma);
+ 
+ 	sp->free(sp);
+ }
+ 
+ static int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+     u8 opt)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPDB);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	e->u.fcport.opt = opt;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	u16 *mb;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GPDB;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gpdb";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_GET_PORT_DATABASE;
+ 	mb[1] = fcport->loop_id;
+ 	mb[2] = MSW(pd_dma);
+ 	mb[3] = LSW(pd_dma);
+ 	mb[6] = MSW(MSD(pd_dma));
+ 	mb[7] = LSW(MSD(pd_dma));
+ 	mb[9] = vha->vp_idx;
+ 	mb[10] = opt;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 	mbx->u.mbx.in = (void *)pd;
+ 	mbx->u.mbx.in_dma = pd_dma;
+ 
+ 	sp->done = qla24xx_async_gpdb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hndl %x opt %x\n",
+ 		sp->name, fcport->port_name, sp->handle, opt);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ 
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	qla24xx_post_gpdb_work(vha, fcport, opt);
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	int rval = ea->rc;
+ 	fc_port_t *fcport = ea->fcport;
+ 	unsigned long flags;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
+ 	    fcport->disc_state, fcport->fw_login_state, rval);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 		return;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	ea->fcport->login_gen++;
+ 	ea->fcport->deleted = 0;
+ 	ea->fcport->logout_on_delete = 1;
+ 
+ 	if (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {
+ 		vha->fcport_count++;
+ 		ea->fcport->login_succ = 1;
+ 
+ 		if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 		    !vha->hw->flags.gpsc_supported) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_upd_fcport_work(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gpsc fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_gpsc_work(vha, fcport);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ } /* gpdb event */
+ 
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	if (fcport->login_retry == 0)
+ 		return 0;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND)
+ 		return 0;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
+ 	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
+ 	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
+ 	    fcport->loop_id);
+ 
+ 	fcport->login_retry--;
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return 0;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
+ 		if (time_before_eq(jiffies, fcport->plogi_nack_done_deadline))
+ 			return 0;
+ 	}
+ 
+ 	/* for pure Target Mode. Login will not be initiated */
+ 	if (vha->host->active_mode == MODE_TARGET)
+ 		return 0;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return 0;
+ 	}
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gnl\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_async_gnl(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 		break;
+ 
+ 	case DSC_GNL:
+ 		if (fcport->login_pause) {
+ 			fcport->last_rscn_gen = fcport->rscn_gen;
+ 			fcport->last_login_gen = fcport->login_gen;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
+ 		}
+ 
+ 		if (fcport->flags & FCF_FCP2_DEVICE) {
+ 			u8 opt = PDO_FORCE_ADISC;
+ 
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 			fcport->disc_state = DSC_GPDB;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 
+ 		break;
+ 
+ 	case DSC_LOGIN_FAILED:
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gidpn \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		break;
+ 
+ 	case DSC_LOGIN_COMPLETE:
+ 		/* recheck login state */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gpdb_work(vha, fcport, PDO_FORCE_ADISC);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_rscn_event(fc_port_t *fcport, struct event_arg *ea)
+ {
+ 	fcport->rscn_gen++;
+ 
+ 	ql_dbg(ql_dbg_disc, fcport->vha, 0xffff,
+ 		"%s %8phC DS %d LS %d\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state);
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT)
+ 		return;
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 	case DSC_LOGIN_COMPLETE:
+ 		qla24xx_post_gidpn_work(fcport->vha, fcport);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,
+ 	u8 *port_name, void *pla)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.new_sess.id = *id;
+ 	e->u.new_sess.pla = pla;
+ 	memcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ int qla24xx_handle_delete_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	switch (vha->host->active_mode) {
+ 	case MODE_INITIATOR:
+ 	case MODE_DUAL:
+ 		if (fcport->scan_state == QLA_FCPORT_FOUND)
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 		break;
+ 
+ 	case MODE_TARGET:
+ 	default:
+ 		/* no-op */
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_relogin_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state, fcport->login_pause,
+ 		fcport->deleted, fcport->conflict,
+ 		fcport->last_rscn_gen, fcport->rscn_gen,
+ 		fcport->last_login_gen, fcport->login_gen,
+ 		fcport->flags);
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
+ 		if (time_before_eq(jiffies, fcport->plogi_nack_done_deadline))
+ 			return;
+ 	}
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		fcport->login_retry++;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_async_gidpn(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	qla24xx_fcport_handle_login(vha, fcport);
+ }
+ 
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *f, *tf;
+ 	uint32_t id = 0, mask, rid;
+ 	int rc;
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 
+ 		qla24xx_handle_relogin_event(vha, ea);
+ 		break;
+ 	case FCME_RSCN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 		switch (ea->id.b.rsvd_1) {
+ 		case RSCN_PORT_ADDR:
+ 			fcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);
+ 			if (!fcport) {
+ 				/* cable moved */
+ 				rc = qla24xx_post_gpnid_work(vha, &ea->id);
+ 				if (rc) {
+ 					ql_log(ql_log_warn, vha, 0xffff,
+ 						"RSCN GPNID work failed %02x%02x%02x\n",
+ 						ea->id.b.domain, ea->id.b.area,
+ 						ea->id.b.al_pa);
+ 				}
+ 			} else {
+ 				ea->fcport = fcport;
+ 				qla24xx_handle_rscn_event(fcport, ea);
+ 			}
+ 			break;
+ 		case RSCN_AREA_ADDR:
+ 		case RSCN_DOM_ADDR:
+ 			if (ea->id.b.rsvd_1 == RSCN_AREA_ADDR) {
+ 				mask = 0xffff00;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Area 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			} else {
+ 				mask = 0xff0000;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Domain 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			}
+ 
+ 			rid = ea->id.b24 & mask;
+ 			list_for_each_entry_safe(f, tf, &vha->vp_fcports,
+ 			    list) {
+ 				id = f->d_id.b24 & mask;
+ 				if (rid == id) {
+ 					ea->fcport = f;
+ 					qla24xx_handle_rscn_event(f, ea);
+ 				}
+ 			}
+ 			break;
+ 		case RSCN_FAB_ADDR:
+ 		default:
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 				"RSCN: Fabric was affected. Addr format %d\n",
+ 				ea->id.b.rsvd_1);
+ 			qla2x00_mark_all_devices_lost(vha, 1);
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 		}
+ 		break;
+ 	case FCME_GIDPN_DONE:
+ 		qla24xx_handle_gidpn_event(vha, ea);
+ 		break;
+ 	case FCME_GNL_DONE:
+ 		qla24xx_handle_gnl_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPSC_DONE:
+ 		qla24xx_post_upd_fcport_work(vha, ea->fcport);
+ 		break;
+ 	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
+ 		qla24xx_handle_plogi_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPDB_DONE:
+ 		qla24xx_handle_gpdb_event(vha, ea);
+ 		break;
+ 	case FCME_GPNID_DONE:
+ 		qla24xx_handle_gpnid_event(vha, ea);
+ 		break;
+ 	case FCME_DELETE_DONE:
+ 		qla24xx_handle_delete_done_event(vha, ea);
+ 		break;
+ 	default:
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
@@@ -370,10 -1224,10 +1181,10 @@@ qla24xx_abort_sp_done(void *data, void 
  	complete(&abt->u.abt.comp);
  }
  
- static int
+ int
  qla24xx_async_abort_cmd(srb_t *cmd_sp)
  {
 -	scsi_qla_host_t *vha = cmd_sp->vha;
 +	scsi_qla_host_t *vha = cmd_sp->fcport->vha;
  	fc_port_t *fcport = cmd_sp->fcport;
  	struct srb_iocb *abt_iocb;
  	srb_t *sp;
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 5ffd1682f367,3953c8d6af69..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -2544,8 -2692,8 +2544,13 @@@ qla24xx_abort_iocb_entry(scsi_qla_host_
  		return;
  
  	abt = &sp->u.iocb_cmd;
++<<<<<<< HEAD
 +	abt->u.abt.comp_status = le32_to_cpu(pkt->nport_handle);
 +	sp->done(vha, sp, 0);
++=======
+ 	abt->u.abt.comp_status = le16_to_cpu(pkt->nport_handle);
+ 	sp->done(sp, 0);
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  }
  
  /**
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index b8143a854ee5,e40ed570d3c1..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -10,6 -10,65 +10,68 @@@
  #include <linux/delay.h>
  #include <linux/gfp.h>
  
++<<<<<<< HEAD
++=======
+ static struct mb_cmd_name {
+ 	uint16_t cmd;
+ 	const char *str;
+ } mb_str[] = {
+ 	{MBC_GET_PORT_DATABASE,		"GPDB"},
+ 	{MBC_GET_ID_LIST,		"GIDList"},
+ 	{MBC_GET_LINK_PRIV_STATS,	"Stats"},
+ };
+ 
+ static const char *mb_to_str(uint16_t cmd)
+ {
+ 	int i;
+ 	struct mb_cmd_name *e;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mb_str); i++) {
+ 		e = mb_str + i;
+ 		if (cmd == e->cmd)
+ 			return e->str;
+ 	}
+ 	return "unknown";
+ }
+ 
+ static struct rom_cmd {
+ 	uint16_t cmd;
+ } rom_cmds[] = {
+ 	{ MBC_LOAD_RAM },
+ 	{ MBC_EXECUTE_FIRMWARE },
+ 	{ MBC_READ_RAM_WORD },
+ 	{ MBC_MAILBOX_REGISTER_TEST },
+ 	{ MBC_VERIFY_CHECKSUM },
+ 	{ MBC_GET_FIRMWARE_VERSION },
+ 	{ MBC_LOAD_RISC_RAM },
+ 	{ MBC_DUMP_RISC_RAM },
+ 	{ MBC_LOAD_RISC_RAM_EXTENDED },
+ 	{ MBC_DUMP_RISC_RAM_EXTENDED },
+ 	{ MBC_WRITE_RAM_WORD_EXTENDED },
+ 	{ MBC_READ_RAM_EXTENDED },
+ 	{ MBC_GET_RESOURCE_COUNTS },
+ 	{ MBC_SET_FIRMWARE_OPTION },
+ 	{ MBC_MID_INITIALIZE_FIRMWARE },
+ 	{ MBC_GET_FIRMWARE_STATE },
+ 	{ MBC_GET_MEM_OFFLOAD_CNTRL_STAT },
+ 	{ MBC_GET_RETRY_COUNT },
+ 	{ MBC_TRACE_CONTROL },
+ };
+ 
+ static int is_rom_cmd(uint16_t cmd)
+ {
+ 	int i;
+ 	struct  rom_cmd *wc;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(rom_cmds); i++) {
+ 		wc = rom_cmds + i;
+ 		if (wc->cmd == cmd)
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  
  /*
   * qla2x00_mailbox_command
@@@ -2623,7 -2840,7 +2685,11 @@@ qla2x00_get_link_status(scsi_qla_host_
  
  int
  qla24xx_get_isp_stats(scsi_qla_host_t *vha, struct link_statistics *stats,
++<<<<<<< HEAD
 +	dma_addr_t stats_dma, uint options)
++=======
+     dma_addr_t stats_dma, uint16_t options)
++>>>>>>> 15f30a575228 (qla2xxx: Use IOCB interface to submit non-critical MBX.)
  {
  	int rval;
  	mbx_cmd_t mc;
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef..80ddf8db1ad8 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -505,7 +505,7 @@ static int qla24xx_get_loop_id(struct scsi_qla_host *vha, const uint8_t *s_id,
 	}
 
 	/* Get list of logged in devices */
-	rc = qla2x00_get_id_list(vha, gid_list, gid_list_dma, &entries);
+	rc = qla24xx_gidlist_wait(vha, gid_list, gid_list_dma, &entries);
 	if (rc != QLA_SUCCESS) {
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf045,
 		    "qla_target(%d): get_id_list() failed: %x\n",
@@ -4061,7 +4061,7 @@ static fc_port_t *qlt_get_port_database(struct scsi_qla_host *vha,
 
 	fcport->loop_id = loop_id;
 
-	rc = qla2x00_get_port_database(vha, fcport, 0);
+	rc = qla24xx_gpdb_wait(vha, fcport, 0);
 	if (rc != QLA_SUCCESS) {
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf070,
 		    "qla_target(%d): Failed to retrieve fcport "
