nfp: fix ethtool stats gather retry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit c3d64ad4fea66d07e878b248b803ccd12c45e18c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c3d64ad4.failed

The while loop fetching 64 bit ethtool statistics may have
to retry multiple times, it shouldn't modify the outside state.

Fixes: 4c3523623dc0 ("net: add driver for Netronome NFP4000/NFP6000 NIC VFs")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c3d64ad4fea66d07e878b248b803ccd12c45e18c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index 69f458e0de89,dc016dfec64d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@@ -323,6 -412,190 +323,193 @@@ static int nfp_net_set_ringparam(struc
  	return nfp_net_set_ring_size(nn, rxd_cnt, txd_cnt);
  }
  
++<<<<<<< HEAD
++=======
+ static __printf(2, 3) u8 *nfp_pr_et(u8 *data, const char *fmt, ...)
+ {
+ 	va_list args;
+ 
+ 	va_start(args, fmt);
+ 	vsnprintf(data, ETH_GSTRING_LEN, fmt, args);
+ 	va_end(args);
+ 
+ 	return data + ETH_GSTRING_LEN;
+ }
+ 
+ static unsigned int nfp_vnic_get_sw_stats_count(struct net_device *netdev)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	return NN_ET_RVEC_GATHER_STATS + nn->dp.num_r_vecs * 3;
+ }
+ 
+ static u8 *nfp_vnic_get_sw_stats_strings(struct net_device *netdev, u8 *data)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	int i;
+ 
+ 	for (i = 0; i < nn->dp.num_r_vecs; i++) {
+ 		data = nfp_pr_et(data, "rvec_%u_rx_pkts", i);
+ 		data = nfp_pr_et(data, "rvec_%u_tx_pkts", i);
+ 		data = nfp_pr_et(data, "rvec_%u_tx_busy", i);
+ 	}
+ 
+ 	data = nfp_pr_et(data, "hw_rx_csum_ok");
+ 	data = nfp_pr_et(data, "hw_rx_csum_inner_ok");
+ 	data = nfp_pr_et(data, "hw_rx_csum_err");
+ 	data = nfp_pr_et(data, "hw_tx_csum");
+ 	data = nfp_pr_et(data, "hw_tx_inner_csum");
+ 	data = nfp_pr_et(data, "tx_gather");
+ 	data = nfp_pr_et(data, "tx_lso");
+ 
+ 	return data;
+ }
+ 
+ static u64 *nfp_vnic_get_sw_stats(struct net_device *netdev, u64 *data)
+ {
+ 	u64 gathered_stats[NN_ET_RVEC_GATHER_STATS] = {};
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	u64 tmp[NN_ET_RVEC_GATHER_STATS];
+ 	unsigned int i, j;
+ 
+ 	for (i = 0; i < nn->dp.num_r_vecs; i++) {
+ 		unsigned int start;
+ 
+ 		do {
+ 			start = u64_stats_fetch_begin(&nn->r_vecs[i].rx_sync);
+ 			data[0] = nn->r_vecs[i].rx_pkts;
+ 			tmp[0] = nn->r_vecs[i].hw_csum_rx_ok;
+ 			tmp[1] = nn->r_vecs[i].hw_csum_rx_inner_ok;
+ 			tmp[2] = nn->r_vecs[i].hw_csum_rx_error;
+ 		} while (u64_stats_fetch_retry(&nn->r_vecs[i].rx_sync, start));
+ 
+ 		do {
+ 			start = u64_stats_fetch_begin(&nn->r_vecs[i].tx_sync);
+ 			data[1] = nn->r_vecs[i].tx_pkts;
+ 			data[2] = nn->r_vecs[i].tx_busy;
+ 			tmp[3] = nn->r_vecs[i].hw_csum_tx;
+ 			tmp[4] = nn->r_vecs[i].hw_csum_tx_inner;
+ 			tmp[5] = nn->r_vecs[i].tx_gather;
+ 			tmp[6] = nn->r_vecs[i].tx_lso;
+ 		} while (u64_stats_fetch_retry(&nn->r_vecs[i].tx_sync, start));
+ 
+ 		data += 3;
+ 
+ 		for (j = 0; j < NN_ET_RVEC_GATHER_STATS; j++)
+ 			gathered_stats[j] += tmp[j];
+ 	}
+ 
+ 	for (j = 0; j < NN_ET_RVEC_GATHER_STATS; j++)
+ 		*data++ = gathered_stats[j];
+ 
+ 	return data;
+ }
+ 
+ static unsigned int
+ nfp_vnic_get_hw_stats_count(unsigned int rx_rings, unsigned int tx_rings)
+ {
+ 	return NN_ET_GLOBAL_STATS_LEN + (rx_rings + tx_rings) * 2;
+ }
+ 
+ static u8 *
+ nfp_vnic_get_hw_stats_strings(u8 *data, unsigned int rx_rings,
+ 			      unsigned int tx_rings, bool repr)
+ {
+ 	int swap_off, i;
+ 
+ 	BUILD_BUG_ON(NN_ET_GLOBAL_STATS_LEN < NN_ET_SWITCH_STATS_LEN * 2);
+ 	/* If repr is true first add SWITCH_STATS_LEN and then subtract it
+ 	 * effectively swapping the RX and TX statistics (giving us the RX
+ 	 * and TX from perspective of the switch).
+ 	 */
+ 	swap_off = repr * NN_ET_SWITCH_STATS_LEN;
+ 
+ 	for (i = 0; i < NN_ET_SWITCH_STATS_LEN; i++)
+ 		data = nfp_pr_et(data, nfp_net_et_stats[i + swap_off].name);
+ 
+ 	for (i = NN_ET_SWITCH_STATS_LEN; i < NN_ET_SWITCH_STATS_LEN * 2; i++)
+ 		data = nfp_pr_et(data, nfp_net_et_stats[i - swap_off].name);
+ 
+ 	for (i = NN_ET_SWITCH_STATS_LEN * 2; i < NN_ET_GLOBAL_STATS_LEN; i++)
+ 		data = nfp_pr_et(data, nfp_net_et_stats[i].name);
+ 
+ 	for (i = 0; i < tx_rings; i++) {
+ 		data = nfp_pr_et(data, "txq_%u_pkts", i);
+ 		data = nfp_pr_et(data, "txq_%u_bytes", i);
+ 	}
+ 
+ 	for (i = 0; i < rx_rings; i++) {
+ 		data = nfp_pr_et(data, "rxq_%u_pkts", i);
+ 		data = nfp_pr_et(data, "rxq_%u_bytes", i);
+ 	}
+ 
+ 	return data;
+ }
+ 
+ static u64 *
+ nfp_vnic_get_hw_stats(u64 *data, u8 __iomem *mem,
+ 		      unsigned int rx_rings, unsigned int tx_rings)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < NN_ET_GLOBAL_STATS_LEN; i++)
+ 		*data++ = readq(mem + nfp_net_et_stats[i].off);
+ 
+ 	for (i = 0; i < tx_rings; i++) {
+ 		*data++ = readq(mem + NFP_NET_CFG_TXR_STATS(i));
+ 		*data++ = readq(mem + NFP_NET_CFG_TXR_STATS(i) + 8);
+ 	}
+ 
+ 	for (i = 0; i < rx_rings; i++) {
+ 		*data++ = readq(mem + NFP_NET_CFG_RXR_STATS(i));
+ 		*data++ = readq(mem + NFP_NET_CFG_RXR_STATS(i) + 8);
+ 	}
+ 
+ 	return data;
+ }
+ 
+ static unsigned int nfp_mac_get_stats_count(struct net_device *netdev)
+ {
+ 	struct nfp_port *port;
+ 
+ 	port = nfp_port_from_netdev(netdev);
+ 	if (!__nfp_port_get_eth_port(port) || !port->eth_stats)
+ 		return 0;
+ 
+ 	return ARRAY_SIZE(nfp_mac_et_stats);
+ }
+ 
+ static u8 *nfp_mac_get_stats_strings(struct net_device *netdev, u8 *data)
+ {
+ 	struct nfp_port *port;
+ 	unsigned int i;
+ 
+ 	port = nfp_port_from_netdev(netdev);
+ 	if (!__nfp_port_get_eth_port(port) || !port->eth_stats)
+ 		return data;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(nfp_mac_et_stats); i++)
+ 		data = nfp_pr_et(data, "mac.%s", nfp_mac_et_stats[i].name);
+ 
+ 	return data;
+ }
+ 
+ static u64 *nfp_mac_get_stats(struct net_device *netdev, u64 *data)
+ {
+ 	struct nfp_port *port;
+ 	unsigned int i;
+ 
+ 	port = nfp_port_from_netdev(netdev);
+ 	if (!__nfp_port_get_eth_port(port) || !port->eth_stats)
+ 		return data;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(nfp_mac_et_stats); i++)
+ 		*data++ = readq(port->eth_stats + nfp_mac_et_stats[i].off);
+ 
+ 	return data;
+ }
+ 
++>>>>>>> c3d64ad4fea6 (nfp: fix ethtool stats gather retry)
  static void nfp_net_get_strings(struct net_device *netdev,
  				u32 stringset, u8 *data)
  {
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
