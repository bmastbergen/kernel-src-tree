sysfs, kernfs: remove sysfs_add_one()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 2d0cfbec2a95c16818960fda1dfa815fd1a62070
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2d0cfbec.failed

sysfs_add_one() is a wrapper around __sysfs_add_one() which prints out
duplicate name warning if __sysfs_add_one() fails with -EEXIST.  The
previous kernfs conversions moved all dup warnings to sysfs interface
functions and sysfs_add_one() doesn't have any user left.

Remove sysfs_add_one() and update __sysfs_add_one() to take its name.

This patch doesn't make any functional changes.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2d0cfbec2a95c16818960fda1dfa815fd1a62070)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/file.c
#	fs/sysfs/symlink.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/dir.c
index fd502d3fc9fc,e88e9a94a083..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -413,13 -395,14 +413,13 @@@ void sysfs_addrm_start(struct sysfs_add
  }
  
  /**
-  *	__sysfs_add_one - add sysfs_dirent to parent without warning
+  *	sysfs_add_one - add sysfs_dirent to parent without warning
   *	@acxt: addrm context to use
   *	@sd: sysfs_dirent to be added
 - *	@parent_sd: the parent sysfs_dirent to add @sd to
   *
 - *	Get @parent_sd and set @sd->s_parent to it and increment nlink of
 - *	the parent inode if @sd is a directory and link into the children
 - *	list of the parent.
 + *	Get @acxt->parent_sd and set sd->s_parent to it and increment
 + *	nlink of parent inode if @sd is a directory and link into the
 + *	children list of the parent.
   *
   *	This function should be called between calls to
   *	sysfs_addrm_start() and sysfs_addrm_finish() and should be
@@@ -432,8 -415,10 +432,13 @@@
   *	0 on success, -EEXIST if entry with the given name already
   *	exists.
   */
++<<<<<<< HEAD
 +int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
++=======
+ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+ 		  struct sysfs_dirent *parent_sd)
++>>>>>>> 2d0cfbec2a95 (sysfs, kernfs: remove sysfs_add_one())
  {
 -	bool has_ns = parent_sd->s_flags & SYSFS_FLAG_NS;
  	struct sysfs_inode_attrs *ps_iattr;
  	int ret;
  
@@@ -482,47 -470,24 +487,50 @@@ static char *sysfs_pathname(struct sysf
  	return path;
  }
  
 -void sysfs_warn_dup(struct sysfs_dirent *parent, const char *name)
 +/**
++<<<<<<< HEAD
 + *	sysfs_add_one - add sysfs_dirent to parent
 + *	@acxt: addrm context to use
 + *	@sd: sysfs_dirent to be added
 + *
 + *	Get @acxt->parent_sd and set sd->s_parent to it and increment
 + *	nlink of parent inode if @sd is a directory and link into the
 + *	children list of the parent.
 + *
 + *	This function should be called between calls to
 + *	sysfs_addrm_start() and sysfs_addrm_finish() and should be
 + *	passed the same @acxt as passed to sysfs_addrm_start().
 + *
 + *	LOCKING:
 + *	Determined by sysfs_addrm_start().
 + *
 + *	RETURNS:
 + *	0 on success, -EEXIST if entry with the given name already
 + *	exists.
 + */
 +int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
  {
 -	char *path;
 +	int ret;
  
 -	path = kzalloc(PATH_MAX, GFP_KERNEL);
 -	if (path) {
 -		sysfs_pathname(parent, path);
 -		strlcat(path, "/", PATH_MAX);
 -		strlcat(path, name, PATH_MAX);
 +	ret = __sysfs_add_one(acxt, sd);
 +	if (ret == -EEXIST) {
 +		char *path = kzalloc(PATH_MAX, GFP_KERNEL);
 +		WARN(1, KERN_WARNING
 +		     "sysfs: cannot create duplicate filename '%s'\n",
 +		     (path == NULL) ? sd->s_name
 +				    : (sysfs_pathname(acxt->parent_sd, path),
 +				       strlcat(path, "/", PATH_MAX),
 +				       strlcat(path, sd->s_name, PATH_MAX),
 +				       path));
 +		kfree(path);
  	}
  
 -	WARN(1, KERN_WARNING "sysfs: cannot create duplicate filename '%s'\n",
 -	     path ? path : name);
 -
 -	kfree(path);
 +	return ret;
  }
  
  /**
++=======
++>>>>>>> 2d0cfbec2a95 (sysfs, kernfs: remove sysfs_add_one())
   *	sysfs_remove_one - remove sysfs_dirent from parent
   *	@acxt: addrm context to use
   *	@sd: sysfs_dirent to be removed
@@@ -675,30 -654,21 +683,35 @@@ static int create_dir(struct kobject *k
  	/* allocate */
  	sd = sysfs_new_dirent(name, mode, SYSFS_DIR);
  	if (!sd)
 -		return ERR_PTR(-ENOMEM);
 +		return -ENOMEM;
  
 +	sd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);
  	sd->s_ns = ns;
 -	sd->priv = priv;
 +	sd->s_dir.kobj = kobj;
  
  	/* link in */
++<<<<<<< HEAD
 +	sysfs_addrm_start(&acxt, parent_sd);
 +	rc = sysfs_add_one(&acxt, sd);
++=======
+ 	sysfs_addrm_start(&acxt);
+ 	rc = sysfs_add_one(&acxt, sd, parent);
++>>>>>>> 2d0cfbec2a95 (sysfs, kernfs: remove sysfs_add_one())
  	sysfs_addrm_finish(&acxt);
  
 -	if (!rc)
 -		return sd;
 +	if (rc == 0)
 +		*p_sd = sd;
 +	else
 +		sysfs_put(sd);
 +
 +	return rc;
 +}
  
 -	sysfs_put(sd);
 -	return ERR_PTR(rc);
 +int sysfs_create_subdir(struct kobject *kobj, const char *name,
 +			struct sysfs_dirent **p_sd)
 +{
 +	return create_dir(kobj, kobj->sd,
 +			  KOBJ_NS_TYPE_NONE, NULL, name, p_sd);
  }
  
  /**
diff --cc fs/sysfs/file.c
index d8887c896abc,9852450867cf..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -483,99 -870,167 +483,114 @@@ void sysfs_notify(struct kobject *k, co
  }
  EXPORT_SYMBOL_GPL(sysfs_notify);
  
 -const struct file_operations kernfs_file_operations = {
 -	.read		= kernfs_file_read,
 -	.write		= kernfs_file_write,
 +const struct file_operations sysfs_file_operations = {
 +	.read		= sysfs_read_file,
 +	.write		= sysfs_write_file,
  	.llseek		= generic_file_llseek,
 -	.mmap		= kernfs_file_mmap,
 -	.open		= kernfs_file_open,
 -	.release	= kernfs_file_release,
 -	.poll		= kernfs_file_poll,
 +	.open		= sysfs_open_file,
 +	.release	= sysfs_release,
 +	.poll		= sysfs_poll,
  };
  
 -static const struct kernfs_ops sysfs_file_kfops_empty = {
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_ro = {
 -	.seq_show	= sysfs_kf_seq_show,
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_wo = {
 -	.write		= sysfs_kf_write,
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_rw = {
 -	.seq_show	= sysfs_kf_seq_show,
 -	.write		= sysfs_kf_write,
 -};
 -
 -static const struct kernfs_ops sysfs_bin_kfops_ro = {
 -	.read		= sysfs_kf_bin_read,
 -};
 -
 -static const struct kernfs_ops sysfs_bin_kfops_wo = {
 -	.write		= sysfs_kf_bin_write,
 -};
 -
 -static const struct kernfs_ops sysfs_bin_kfops_rw = {
 -	.read		= sysfs_kf_bin_read,
 -	.write		= sysfs_kf_bin_write,
 -	.mmap		= sysfs_kf_bin_mmap,
 -};
 -
 -int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
 -			   const struct attribute *attr, bool is_bin,
 -			   umode_t mode, const void *ns)
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
  {
 -	const struct kernfs_ops *ops;
 -	struct sysfs_dirent *sd;
 -	loff_t size;
 -
 -	if (!is_bin) {
 -		struct kobject *kobj = dir_sd->priv;
 -		const struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;
 -
 -		/* every kobject with an attribute needs a ktype assigned */
 -		if (WARN(!sysfs_ops, KERN_ERR
 -			 "missing sysfs attribute operations for kobject: %s\n",
 -			 kobject_name(kobj)))
 -			return -EINVAL;
 -
 -		if (sysfs_ops->show && sysfs_ops->store)
 -			ops = &sysfs_file_kfops_rw;
 -		else if (sysfs_ops->show)
 -			ops = &sysfs_file_kfops_ro;
 -		else if (sysfs_ops->store)
 -			ops = &sysfs_file_kfops_wo;
 -		else
 -			ops = &sysfs_file_kfops_empty;
 -
 -		size = PAGE_SIZE;
 -	} else {
 -		struct bin_attribute *battr = (void *)attr;
 -
 -		if ((battr->read && battr->write) || battr->mmap)
 -			ops = &sysfs_bin_kfops_rw;
 -		else if (battr->read)
 -			ops = &sysfs_bin_kfops_ro;
 -		else if (battr->write)
 -			ops = &sysfs_bin_kfops_wo;
 -		else
 -			ops = &sysfs_file_kfops_empty;
 -
 -		size = battr->size;
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
  	}
  
 -	sd = kernfs_create_file_ns(dir_sd, attr->name, mode, size,
 -				   ops, (void *)attr, ns);
 -	if (IS_ERR(sd)) {
 -		if (PTR_ERR(sd) == -EEXIST)
 -			sysfs_warn_dup(dir_sd, attr->name);
 -		return PTR_ERR(sd);
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR
 +		     "missing sysfs namespace attribute operation for kobject: %s\n",
 +		     kobject_name(kobj));
  	}
 -	return 0;
 +	*pns = ns;
 +	return err;
  }
  
 -/**
 - * kernfs_create_file_ns - create a file
 - * @parent: directory to create the file in
 - * @name: name of the file
 - * @mode: mode of the file
 - * @size: size of the file
 - * @ops: kernfs operations for the file
 - * @priv: private data for the file
 - * @ns: optional namespace tag of the file
 - *
 - * Returns the created node on success, ERR_PTR() value on error.
 - */
 -struct sysfs_dirent *kernfs_create_file_ns(struct sysfs_dirent *parent,
 -					   const char *name,
 -					   umode_t mode, loff_t size,
 -					   const struct kernfs_ops *ops,
 -					   void *priv, const void *ns)
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
  {
 +	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
 +	const void *ns;
  	int rc;
  
 -	sd = sysfs_new_dirent(name, (mode & S_IALLUGO) | S_IFREG,
 -			      SYSFS_KOBJ_ATTR);
 +	rc = sysfs_attr_ns(dir_sd->s_dir.kobj, attr, &ns);
 +	if (rc)
 +		return rc;
 +
 +	sd = sysfs_new_dirent(attr->name, mode, type);
  	if (!sd)
 -		return ERR_PTR(-ENOMEM);
 +		return -ENOMEM;
  
 -	sd->s_attr.ops = ops;
 -	sd->s_attr.size = size;
  	sd->s_ns = ns;
 -	sd->priv = priv;
 +	sd->s_attr.attr = (void *)attr;
  	sysfs_dirent_init_lockdep(sd);
  
++<<<<<<< HEAD
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	rc = sysfs_add_one(&acxt, sd);
++=======
+ 	/*
+ 	 * sd->s_attr.ops is accesible only while holding active ref.  We
+ 	 * need to know whether some ops are implemented outside active
+ 	 * ref.  Cache their existence in flags.
+ 	 */
+ 	if (ops->seq_show)
+ 		sd->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+ 	if (ops->mmap)
+ 		sd->s_flags |= SYSFS_FLAG_HAS_MMAP;
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	rc = sysfs_add_one(&acxt, sd, parent);
++>>>>>>> 2d0cfbec2a95 (sysfs, kernfs: remove sysfs_add_one())
  	sysfs_addrm_finish(&acxt);
  
 -	if (rc) {
 +	if (rc)
  		sysfs_put(sd);
 -		return ERR_PTR(rc);
 -	}
 -	return sd;
 +
 +	return rc;
  }
  
 +
  int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,
 -		   bool is_bin)
 +		   int type)
  {
 -	return sysfs_add_file_mode_ns(dir_sd, attr, is_bin, attr->mode, NULL);
 +	return sysfs_add_file_mode(dir_sd, attr, type, attr->mode);
  }
  
 +
  /**
 - * sysfs_create_file_ns - create an attribute file for an object with custom ns
 - * @kobj: object we're creating for
 - * @attr: attribute descriptor
 - * @ns: namespace the new file should belong to
 + *	sysfs_create_file - create an attribute file for an object.
 + *	@kobj:	object we're creating for.
 + *	@attr:	attribute descriptor.
   */
 -int sysfs_create_file_ns(struct kobject *kobj, const struct attribute *attr,
 -			 const void *ns)
 +int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)
  {
  	BUG_ON(!kobj || !kobj->sd || !attr);
  
diff --cc fs/sysfs/symlink.c
index 9fab2e7f7357,76efeab6db4e..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -21,6 -21,43 +21,46 @@@
  
  #include "sysfs.h"
  
++<<<<<<< HEAD
++=======
+ /**
+  * kernfs_create_link - create a symlink
+  * @parent: directory to create the symlink in
+  * @name: name of the symlink
+  * @target: target node for the symlink to point to
+  *
+  * Returns the created node on success, ERR_PTR() value on error.
+  */
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target)
+ {
+ 	struct sysfs_dirent *sd;
+ 	struct sysfs_addrm_cxt acxt;
+ 	int error;
+ 
+ 	sd = sysfs_new_dirent(name, S_IFLNK|S_IRWXUGO, SYSFS_KOBJ_LINK);
+ 	if (!sd)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (parent->s_flags & SYSFS_FLAG_NS)
+ 		sd->s_ns = target->s_ns;
+ 	sd->s_symlink.target_sd = target;
+ 	sysfs_get(target);	/* ref owned by symlink */
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	error = sysfs_add_one(&acxt, sd, parent);
+ 	sysfs_addrm_finish(&acxt);
+ 
+ 	if (!error)
+ 		return sd;
+ 
+ 	sysfs_put(sd);
+ 	return ERR_PTR(error);
+ }
+ 
+ 
++>>>>>>> 2d0cfbec2a95 (sysfs, kernfs: remove sysfs_add_one())
  static int sysfs_do_create_link_sd(struct sysfs_dirent *parent_sd,
  				   struct kobject *target,
  				   const char *name, int warn)
diff --cc fs/sysfs/sysfs.h
index e18c3f38727c,a6542d27bd9b..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -164,11 -165,10 +164,18 @@@ extern const struct inode_operations sy
  
  struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
  void sysfs_put_active(struct sysfs_dirent *sd);
++<<<<<<< HEAD
 +void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 +		       struct sysfs_dirent *parent_sd);
 +int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +void sysfs_remove_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
++=======
+ void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
+ void sysfs_warn_dup(struct sysfs_dirent *parent, const char *name);
+ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+ 		  struct sysfs_dirent *parent_sd);
++>>>>>>> 2d0cfbec2a95 (sysfs, kernfs: remove sysfs_add_one())
  void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
  
  struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/file.c
* Unmerged path fs/sysfs/symlink.c
* Unmerged path fs/sysfs/sysfs.h
