ibmvnic: Remove inflight list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit 661a26227621b9a602a816fa29451e53c5ba006b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/661a2622.failed

The inflight list used to track memory that is allocated for crq that are
inflight is not needed. The one piece of the inflight list that does need
to be cleaned at module exit is the error buffer list which is already
attached to the adapter struct.

This patch removes the inflight list and moves checking the error buffer
list to ibmvnic_remove.

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 661a26227621b9a602a816fa29451e53c5ba006b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
#	drivers/net/ethernet/ibm/ibmvnic.h
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index a3af32d0c439,18673e2fe91b..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -441,20 -498,171 +441,171 @@@ static int ibmvnic_open(struct net_devi
  		tx_pool->consumer_index = 0;
  		tx_pool->producer_index = 0;
  	}
 -
 -	return 0;
 -}
 -
 -static void release_bounce_buffer(struct ibmvnic_adapter *adapter)
 -{
 -	struct device *dev = &adapter->vdev->dev;
 -
 +	adapter->bounce_buffer_size =
 +	    (netdev->mtu + ETH_HLEN - 1) / PAGE_SIZE + 1;
 +	adapter->bounce_buffer = kmalloc(adapter->bounce_buffer_size,
 +					 GFP_KERNEL);
  	if (!adapter->bounce_buffer)
 -		return;
 +		goto bounce_alloc_failed;
  
 -	if (!dma_mapping_error(dev, adapter->bounce_buffer_dma)) {
 -		dma_unmap_single(dev, adapter->bounce_buffer_dma,
 -				 adapter->bounce_buffer_size,
 -				 DMA_BIDIRECTIONAL);
 -		adapter->bounce_buffer_dma = DMA_ERROR_CODE;
 +	adapter->bounce_buffer_dma = dma_map_single(dev, adapter->bounce_buffer,
 +						    adapter->bounce_buffer_size,
 +						    DMA_TO_DEVICE);
 +	if (dma_mapping_error(dev, adapter->bounce_buffer_dma)) {
 +		dev_err(dev, "Couldn't map tx bounce buffer\n");
 +		goto bounce_map_failed;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	kfree(adapter->bounce_buffer);
+ 	adapter->bounce_buffer = NULL;
+ }
+ 
+ static int init_bounce_buffer(struct net_device *netdev)
+ {
+ 	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
+ 	struct device *dev = &adapter->vdev->dev;
+ 	char *buf;
+ 	int buf_sz;
+ 	dma_addr_t map_addr;
+ 
+ 	buf_sz = (netdev->mtu + ETH_HLEN - 1) / PAGE_SIZE + 1;
+ 	buf = kmalloc(adapter->bounce_buffer_size, GFP_KERNEL);
+ 	if (!buf)
+ 		return -1;
+ 
+ 	map_addr = dma_map_single(dev, buf, buf_sz, DMA_TO_DEVICE);
+ 	if (dma_mapping_error(dev, map_addr)) {
+ 		dev_err(dev, "Couldn't map bounce buffer\n");
+ 		kfree(buf);
+ 		return -1;
+ 	}
+ 
+ 	adapter->bounce_buffer = buf;
+ 	adapter->bounce_buffer_size = buf_sz;
+ 	adapter->bounce_buffer_dma = map_addr;
+ 	return 0;
+ }
+ 
+ static void release_error_buffers(struct ibmvnic_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->vdev->dev;
+ 	struct ibmvnic_error_buff *error_buff, *tmp;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&adapter->error_list_lock, flags);
+ 	list_for_each_entry_safe(error_buff, tmp, &adapter->errors, list) {
+ 		list_del(&error_buff->list);
+ 		dma_unmap_single(dev, error_buff->dma, error_buff->len,
+ 				 DMA_FROM_DEVICE);
+ 		kfree(error_buff->buff);
+ 		kfree(error_buff);
+ 	}
+ 	spin_unlock_irqrestore(&adapter->error_list_lock, flags);
+ }
+ 
+ static int ibmvnic_login(struct net_device *netdev)
+ {
+ 	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
+ 	unsigned long timeout = msecs_to_jiffies(30000);
+ 	struct device *dev = &adapter->vdev->dev;
+ 
+ 	do {
+ 		if (adapter->renegotiate) {
+ 			adapter->renegotiate = false;
+ 			release_sub_crqs(adapter);
+ 
+ 			reinit_completion(&adapter->init_done);
+ 			send_cap_queries(adapter);
+ 			if (!wait_for_completion_timeout(&adapter->init_done,
+ 							 timeout)) {
+ 				dev_err(dev, "Capabilities query timeout\n");
+ 				return -1;
+ 			}
+ 		}
+ 
+ 		reinit_completion(&adapter->init_done);
+ 		send_login(adapter);
+ 		if (!wait_for_completion_timeout(&adapter->init_done,
+ 						 timeout)) {
+ 			dev_err(dev, "Login timeout\n");
+ 			return -1;
+ 		}
+ 	} while (adapter->renegotiate);
+ 
+ 	return 0;
+ }
+ 
+ static void release_resources(struct ibmvnic_adapter *adapter)
+ {
+ 	release_bounce_buffer(adapter);
+ 	release_tx_pools(adapter);
+ 	release_rx_pools(adapter);
+ 
+ 	release_sub_crqs(adapter);
+ 	release_crq_queue(adapter);
+ 
+ 	release_stats_token(adapter);
+ 	release_error_buffers(adapter);
+ }
+ 
+ static int ibmvnic_open(struct net_device *netdev)
+ {
+ 	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
+ 	struct device *dev = &adapter->vdev->dev;
+ 	union ibmvnic_crq crq;
+ 	int rc = 0;
+ 	int i;
+ 
+ 	if (adapter->is_closed) {
+ 		rc = ibmvnic_init(adapter);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	rc = ibmvnic_login(netdev);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = netif_set_real_num_tx_queues(netdev, adapter->req_tx_queues);
+ 	if (rc) {
+ 		dev_err(dev, "failed to set the number of tx queues\n");
+ 		return -1;
+ 	}
+ 
+ 	rc = init_sub_crq_irqs(adapter);
+ 	if (rc) {
+ 		dev_err(dev, "failed to initialize sub crq irqs\n");
+ 		return -1;
+ 	}
+ 
+ 	adapter->map_id = 1;
+ 	adapter->napi = kcalloc(adapter->req_rx_queues,
+ 				sizeof(struct napi_struct), GFP_KERNEL);
+ 	if (!adapter->napi)
+ 		goto ibmvnic_open_fail;
+ 	for (i = 0; i < adapter->req_rx_queues; i++) {
+ 		netif_napi_add(netdev, &adapter->napi[i], ibmvnic_poll,
+ 			       NAPI_POLL_WEIGHT);
+ 		napi_enable(&adapter->napi[i]);
+ 	}
+ 
+ 	send_map_query(adapter);
+ 
+ 	rc = init_rx_pools(netdev);
+ 	if (rc)
+ 		goto ibmvnic_open_fail;
+ 
+ 	rc = init_tx_pools(netdev);
+ 	if (rc)
+ 		goto ibmvnic_open_fail;
+ 
+ 	rc = init_bounce_buffer(netdev);
+ 	if (rc)
+ 		goto ibmvnic_open_fail;
+ 
++>>>>>>> 661a26227621 (ibmvnic: Remove inflight list)
  	replenish_pools(adapter);
  
  	/* We're ready to receive frames, enable the sub-crq interrupts and
@@@ -2757,521 -2804,6 +2875,524 @@@ out
  	}
  }
  
++<<<<<<< HEAD
 +static void handle_control_ras_rsp(union ibmvnic_crq *crq,
 +				   struct ibmvnic_adapter *adapter)
 +{
 +	u8 correlator = crq->control_ras_rsp.correlator;
 +	struct device *dev = &adapter->vdev->dev;
 +	bool found = false;
 +	int i;
 +
 +	if (crq->control_ras_rsp.rc.code) {
 +		dev_warn(dev, "Control ras failed rc=%d\n",
 +			 crq->control_ras_rsp.rc.code);
 +		return;
 +	}
 +
 +	for (i = 0; i < adapter->ras_comp_num; i++) {
 +		if (adapter->ras_comps[i].correlator == correlator) {
 +			found = true;
 +			break;
 +		}
 +	}
 +
 +	if (!found) {
 +		dev_warn(dev, "Correlator not found on control_ras_rsp\n");
 +		return;
 +	}
 +
 +	switch (crq->control_ras_rsp.op) {
 +	case IBMVNIC_TRACE_LEVEL:
 +		adapter->ras_comps[i].trace_level = crq->control_ras.level;
 +		break;
 +	case IBMVNIC_ERROR_LEVEL:
 +		adapter->ras_comps[i].error_check_level =
 +		    crq->control_ras.level;
 +		break;
 +	case IBMVNIC_TRACE_PAUSE:
 +		adapter->ras_comp_int[i].paused = 1;
 +		break;
 +	case IBMVNIC_TRACE_RESUME:
 +		adapter->ras_comp_int[i].paused = 0;
 +		break;
 +	case IBMVNIC_TRACE_ON:
 +		adapter->ras_comps[i].trace_on = 1;
 +		break;
 +	case IBMVNIC_TRACE_OFF:
 +		adapter->ras_comps[i].trace_on = 0;
 +		break;
 +	case IBMVNIC_CHG_TRACE_BUFF_SZ:
 +		/* trace_buff_sz is 3 bytes, stuff it into an int */
 +		((u8 *)(&adapter->ras_comps[i].trace_buff_size))[0] = 0;
 +		((u8 *)(&adapter->ras_comps[i].trace_buff_size))[1] =
 +		    crq->control_ras_rsp.trace_buff_sz[0];
 +		((u8 *)(&adapter->ras_comps[i].trace_buff_size))[2] =
 +		    crq->control_ras_rsp.trace_buff_sz[1];
 +		((u8 *)(&adapter->ras_comps[i].trace_buff_size))[3] =
 +		    crq->control_ras_rsp.trace_buff_sz[2];
 +		break;
 +	default:
 +		dev_err(dev, "invalid op %d on control_ras_rsp",
 +			crq->control_ras_rsp.op);
 +	}
 +}
 +
 +static ssize_t trace_read(struct file *file, char __user *user_buf, size_t len,
 +			  loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	struct device *dev = &adapter->vdev->dev;
 +	struct ibmvnic_fw_trace_entry *trace;
 +	int num = ras_comp_int->num;
 +	union ibmvnic_crq crq;
 +	dma_addr_t trace_tok;
 +
 +	if (*ppos >= be32_to_cpu(adapter->ras_comps[num].trace_buff_size))
 +		return 0;
 +
 +	trace =
 +	    dma_alloc_coherent(dev,
 +			       be32_to_cpu(adapter->ras_comps[num].
 +					   trace_buff_size), &trace_tok,
 +			       GFP_KERNEL);
 +	if (!trace) {
 +		dev_err(dev, "Couldn't alloc trace buffer\n");
 +		return 0;
 +	}
 +
 +	memset(&crq, 0, sizeof(crq));
 +	crq.collect_fw_trace.first = IBMVNIC_CRQ_CMD;
 +	crq.collect_fw_trace.cmd = COLLECT_FW_TRACE;
 +	crq.collect_fw_trace.correlator = adapter->ras_comps[num].correlator;
 +	crq.collect_fw_trace.ioba = cpu_to_be32(trace_tok);
 +	crq.collect_fw_trace.len = adapter->ras_comps[num].trace_buff_size;
 +
 +	init_completion(&adapter->fw_done);
 +	ibmvnic_send_crq(adapter, &crq);
 +	wait_for_completion(&adapter->fw_done);
 +
 +	if (*ppos + len > be32_to_cpu(adapter->ras_comps[num].trace_buff_size))
 +		len =
 +		    be32_to_cpu(adapter->ras_comps[num].trace_buff_size) -
 +		    *ppos;
 +
 +	copy_to_user(user_buf, &((u8 *)trace)[*ppos], len);
 +
 +	dma_free_coherent(dev,
 +			  be32_to_cpu(adapter->ras_comps[num].trace_buff_size),
 +			  trace, trace_tok);
 +	*ppos += len;
 +	return len;
 +}
 +
 +static const struct file_operations trace_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= simple_open,
 +	.read		= trace_read,
 +};
 +
 +static ssize_t paused_read(struct file *file, char __user *user_buf, size_t len,
 +			   loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	char buff[5]; /*  1 or 0 plus \n and \0 */
 +	int size;
 +
 +	size = sprintf(buff, "%d\n", adapter->ras_comp_int[num].paused);
 +
 +	if (*ppos >= size)
 +		return 0;
 +
 +	copy_to_user(user_buf, buff, size);
 +	*ppos += size;
 +	return size;
 +}
 +
 +static ssize_t paused_write(struct file *file, const char __user *user_buf,
 +			    size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	union ibmvnic_crq crq;
 +	unsigned long val;
 +	char buff[9]; /* decimal max int plus \n and \0 */
 +
 +	copy_from_user(buff, user_buf, sizeof(buff));
 +	val = kstrtoul(buff, 10, NULL);
 +
 +	adapter->ras_comp_int[num].paused = val ? 1 : 0;
 +
 +	memset(&crq, 0, sizeof(crq));
 +	crq.control_ras.first = IBMVNIC_CRQ_CMD;
 +	crq.control_ras.cmd = CONTROL_RAS;
 +	crq.control_ras.correlator = adapter->ras_comps[num].correlator;
 +	crq.control_ras.op = val ? IBMVNIC_TRACE_PAUSE : IBMVNIC_TRACE_RESUME;
 +	ibmvnic_send_crq(adapter, &crq);
 +
 +	return len;
 +}
 +
 +static const struct file_operations paused_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= simple_open,
 +	.read		= paused_read,
 +	.write		= paused_write,
 +};
 +
 +static ssize_t tracing_read(struct file *file, char __user *user_buf,
 +			    size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	char buff[5]; /*  1 or 0 plus \n and \0 */
 +	int size;
 +
 +	size = sprintf(buff, "%d\n", adapter->ras_comps[num].trace_on);
 +
 +	if (*ppos >= size)
 +		return 0;
 +
 +	copy_to_user(user_buf, buff, size);
 +	*ppos += size;
 +	return size;
 +}
 +
 +static ssize_t tracing_write(struct file *file, const char __user *user_buf,
 +			     size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	union ibmvnic_crq crq;
 +	unsigned long val;
 +	char buff[9]; /* decimal max int plus \n and \0 */
 +
 +	copy_from_user(buff, user_buf, sizeof(buff));
 +	val = kstrtoul(buff, 10, NULL);
 +
 +	memset(&crq, 0, sizeof(crq));
 +	crq.control_ras.first = IBMVNIC_CRQ_CMD;
 +	crq.control_ras.cmd = CONTROL_RAS;
 +	crq.control_ras.correlator = adapter->ras_comps[num].correlator;
 +	crq.control_ras.op = val ? IBMVNIC_TRACE_ON : IBMVNIC_TRACE_OFF;
 +
 +	return len;
 +}
 +
 +static const struct file_operations tracing_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= simple_open,
 +	.read		= tracing_read,
 +	.write		= tracing_write,
 +};
 +
 +static ssize_t error_level_read(struct file *file, char __user *user_buf,
 +				size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	char buff[5]; /* decimal max char plus \n and \0 */
 +	int size;
 +
 +	size = sprintf(buff, "%d\n", adapter->ras_comps[num].error_check_level);
 +
 +	if (*ppos >= size)
 +		return 0;
 +
 +	copy_to_user(user_buf, buff, size);
 +	*ppos += size;
 +	return size;
 +}
 +
 +static ssize_t error_level_write(struct file *file, const char __user *user_buf,
 +				 size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	union ibmvnic_crq crq;
 +	unsigned long val;
 +	char buff[9]; /* decimal max int plus \n and \0 */
 +
 +	copy_from_user(buff, user_buf, sizeof(buff));
 +	val = kstrtoul(buff, 10, NULL);
 +
 +	if (val > 9)
 +		val = 9;
 +
 +	memset(&crq, 0, sizeof(crq));
 +	crq.control_ras.first = IBMVNIC_CRQ_CMD;
 +	crq.control_ras.cmd = CONTROL_RAS;
 +	crq.control_ras.correlator = adapter->ras_comps[num].correlator;
 +	crq.control_ras.op = IBMVNIC_ERROR_LEVEL;
 +	crq.control_ras.level = val;
 +	ibmvnic_send_crq(adapter, &crq);
 +
 +	return len;
 +}
 +
 +static const struct file_operations error_level_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= simple_open,
 +	.read		= error_level_read,
 +	.write		= error_level_write,
 +};
 +
 +static ssize_t trace_level_read(struct file *file, char __user *user_buf,
 +				size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	char buff[5]; /* decimal max char plus \n and \0 */
 +	int size;
 +
 +	size = sprintf(buff, "%d\n", adapter->ras_comps[num].trace_level);
 +	if (*ppos >= size)
 +		return 0;
 +
 +	copy_to_user(user_buf, buff, size);
 +	*ppos += size;
 +	return size;
 +}
 +
 +static ssize_t trace_level_write(struct file *file, const char __user *user_buf,
 +				 size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	union ibmvnic_crq crq;
 +	unsigned long val;
 +	char buff[9]; /* decimal max int plus \n and \0 */
 +
 +	copy_from_user(buff, user_buf, sizeof(buff));
 +	val = kstrtoul(buff, 10, NULL);
 +	if (val > 9)
 +		val = 9;
 +
 +	memset(&crq, 0, sizeof(crq));
 +	crq.control_ras.first = IBMVNIC_CRQ_CMD;
 +	crq.control_ras.cmd = CONTROL_RAS;
 +	crq.control_ras.correlator =
 +	    adapter->ras_comps[ras_comp_int->num].correlator;
 +	crq.control_ras.op = IBMVNIC_TRACE_LEVEL;
 +	crq.control_ras.level = val;
 +	ibmvnic_send_crq(adapter, &crq);
 +
 +	return len;
 +}
 +
 +static const struct file_operations trace_level_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= simple_open,
 +	.read		= trace_level_read,
 +	.write		= trace_level_write,
 +};
 +
 +static ssize_t trace_buff_size_read(struct file *file, char __user *user_buf,
 +				    size_t len, loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	int num = ras_comp_int->num;
 +	char buff[9]; /* decimal max int plus \n and \0 */
 +	int size;
 +
 +	size = sprintf(buff, "%d\n", adapter->ras_comps[num].trace_buff_size);
 +	if (*ppos >= size)
 +		return 0;
 +
 +	copy_to_user(user_buf, buff, size);
 +	*ppos += size;
 +	return size;
 +}
 +
 +static ssize_t trace_buff_size_write(struct file *file,
 +				     const char __user *user_buf, size_t len,
 +				     loff_t *ppos)
 +{
 +	struct ibmvnic_fw_comp_internal *ras_comp_int = file->private_data;
 +	struct ibmvnic_adapter *adapter = ras_comp_int->adapter;
 +	union ibmvnic_crq crq;
 +	unsigned long val;
 +	char buff[9]; /* decimal max int plus \n and \0 */
 +
 +	copy_from_user(buff, user_buf, sizeof(buff));
 +	val = kstrtoul(buff, 10, NULL);
 +
 +	memset(&crq, 0, sizeof(crq));
 +	crq.control_ras.first = IBMVNIC_CRQ_CMD;
 +	crq.control_ras.cmd = CONTROL_RAS;
 +	crq.control_ras.correlator =
 +	    adapter->ras_comps[ras_comp_int->num].correlator;
 +	crq.control_ras.op = IBMVNIC_CHG_TRACE_BUFF_SZ;
 +	/* trace_buff_sz is 3 bytes, stuff an int into it */
 +	crq.control_ras.trace_buff_sz[0] = ((u8 *)(&val))[5];
 +	crq.control_ras.trace_buff_sz[1] = ((u8 *)(&val))[6];
 +	crq.control_ras.trace_buff_sz[2] = ((u8 *)(&val))[7];
 +	ibmvnic_send_crq(adapter, &crq);
 +
 +	return len;
 +}
 +
 +static const struct file_operations trace_size_ops = {
 +	.owner		= THIS_MODULE,
 +	.open		= simple_open,
 +	.read		= trace_buff_size_read,
 +	.write		= trace_buff_size_write,
 +};
 +
 +static void handle_request_ras_comps_rsp(union ibmvnic_crq *crq,
 +					 struct ibmvnic_adapter *adapter)
 +{
 +	struct device *dev = &adapter->vdev->dev;
 +	struct dentry *dir_ent;
 +	struct dentry *ent;
 +	int i;
 +
 +	debugfs_remove_recursive(adapter->ras_comps_ent);
 +
 +	adapter->ras_comps_ent = debugfs_create_dir("ras_comps",
 +						    adapter->debugfs_dir);
 +	if (!adapter->ras_comps_ent || IS_ERR(adapter->ras_comps_ent)) {
 +		dev_info(dev, "debugfs create ras_comps dir failed\n");
 +		return;
 +	}
 +
 +	for (i = 0; i < adapter->ras_comp_num; i++) {
 +		dir_ent = debugfs_create_dir(adapter->ras_comps[i].name,
 +					     adapter->ras_comps_ent);
 +		if (!dir_ent || IS_ERR(dir_ent)) {
 +			dev_info(dev, "debugfs create %s dir failed\n",
 +				 adapter->ras_comps[i].name);
 +			continue;
 +		}
 +
 +		adapter->ras_comp_int[i].adapter = adapter;
 +		adapter->ras_comp_int[i].num = i;
 +		adapter->ras_comp_int[i].desc_blob.data =
 +		    &adapter->ras_comps[i].description;
 +		adapter->ras_comp_int[i].desc_blob.size =
 +		    sizeof(adapter->ras_comps[i].description);
 +
 +		/* Don't need to remember the dentry's because the debugfs dir
 +		 * gets removed recursively
 +		 */
 +		ent = debugfs_create_blob("description", S_IRUGO, dir_ent,
 +					  &adapter->ras_comp_int[i].desc_blob);
 +		ent = debugfs_create_file("trace_buf_size", S_IRUGO | S_IWUSR,
 +					  dir_ent, &adapter->ras_comp_int[i],
 +					  &trace_size_ops);
 +		ent = debugfs_create_file("trace_level",
 +					  S_IRUGO |
 +					  (adapter->ras_comps[i].trace_level !=
 +					   0xFF  ? S_IWUSR : 0),
 +					   dir_ent, &adapter->ras_comp_int[i],
 +					   &trace_level_ops);
 +		ent = debugfs_create_file("error_level",
 +					  S_IRUGO |
 +					  (adapter->
 +					   ras_comps[i].error_check_level !=
 +					   0xFF ? S_IWUSR : 0),
 +					  dir_ent, &adapter->ras_comp_int[i],
 +					  &trace_level_ops);
 +		ent = debugfs_create_file("tracing", S_IRUGO | S_IWUSR,
 +					  dir_ent, &adapter->ras_comp_int[i],
 +					  &tracing_ops);
 +		ent = debugfs_create_file("paused", S_IRUGO | S_IWUSR,
 +					  dir_ent, &adapter->ras_comp_int[i],
 +					  &paused_ops);
 +		ent = debugfs_create_file("trace", S_IRUGO, dir_ent,
 +					  &adapter->ras_comp_int[i],
 +					  &trace_ops);
 +	}
 +}
 +
 +static void handle_request_ras_comp_num_rsp(union ibmvnic_crq *crq,
 +					    struct ibmvnic_adapter *adapter)
 +{
 +	int len = adapter->ras_comp_num * sizeof(struct ibmvnic_fw_component);
 +	struct device *dev = &adapter->vdev->dev;
 +	union ibmvnic_crq newcrq;
 +
 +	adapter->ras_comps = dma_alloc_coherent(dev, len,
 +						&adapter->ras_comps_tok,
 +						GFP_KERNEL);
 +	if (!adapter->ras_comps) {
 +		if (!firmware_has_feature(FW_FEATURE_CMO))
 +			dev_err(dev, "Couldn't alloc fw comps buffer\n");
 +		return;
 +	}
 +
 +	adapter->ras_comp_int = kmalloc(adapter->ras_comp_num *
 +					sizeof(struct ibmvnic_fw_comp_internal),
 +					GFP_KERNEL);
 +	if (!adapter->ras_comp_int)
 +		dma_free_coherent(dev, len, adapter->ras_comps,
 +				  adapter->ras_comps_tok);
 +
 +	memset(&newcrq, 0, sizeof(newcrq));
 +	newcrq.request_ras_comps.first = IBMVNIC_CRQ_CMD;
 +	newcrq.request_ras_comps.cmd = REQUEST_RAS_COMPS;
 +	newcrq.request_ras_comps.ioba = cpu_to_be32(adapter->ras_comps_tok);
 +	newcrq.request_ras_comps.len = cpu_to_be32(len);
 +	ibmvnic_send_crq(adapter, &newcrq);
 +}
 +
 +static void ibmvnic_free_inflight(struct ibmvnic_adapter *adapter)
 +{
 +	struct ibmvnic_inflight_cmd *inflight_cmd, *tmp1;
 +	struct device *dev = &adapter->vdev->dev;
 +	struct ibmvnic_error_buff *error_buff, *tmp2;
 +	unsigned long flags;
 +	unsigned long flags2;
 +
 +	spin_lock_irqsave(&adapter->inflight_lock, flags);
 +	list_for_each_entry_safe(inflight_cmd, tmp1, &adapter->inflight, list) {
 +		switch (inflight_cmd->crq.generic.cmd) {
 +		case LOGIN:
 +			dma_unmap_single(dev, adapter->login_buf_token,
 +					 adapter->login_buf_sz,
 +					 DMA_BIDIRECTIONAL);
 +			dma_unmap_single(dev, adapter->login_rsp_buf_token,
 +					 adapter->login_rsp_buf_sz,
 +					 DMA_BIDIRECTIONAL);
 +			kfree(adapter->login_rsp_buf);
 +			kfree(adapter->login_buf);
 +			break;
 +		case REQUEST_DUMP:
 +			complete(&adapter->fw_done);
 +			break;
 +		case REQUEST_ERROR_INFO:
 +			spin_lock_irqsave(&adapter->error_list_lock, flags2);
 +			list_for_each_entry_safe(error_buff, tmp2,
 +						 &adapter->errors, list) {
 +				dma_unmap_single(dev, error_buff->dma,
 +						 error_buff->len,
 +						 DMA_FROM_DEVICE);
 +				kfree(error_buff->buff);
 +				list_del(&error_buff->list);
 +				kfree(error_buff);
 +			}
 +			spin_unlock_irqrestore(&adapter->error_list_lock,
 +					       flags2);
 +			break;
 +		}
 +		list_del(&inflight_cmd->list);
 +		kfree(inflight_cmd);
 +	}
 +	spin_unlock_irqrestore(&adapter->inflight_lock, flags);
 +}
 +
++=======
++>>>>>>> 661a26227621 (ibmvnic: Remove inflight list)
  static void ibmvnic_xport_event(struct work_struct *work)
  {
  	struct ibmvnic_adapter *adapter = container_of(work,
@@@ -3795,71 -3274,17 +3915,69 @@@ static int ibmvnic_probe(struct vio_de
  
  	spin_lock_init(&adapter->stats_lock);
  
 +	rc = ibmvnic_init_crq_queue(adapter);
 +	if (rc) {
 +		dev_err(&dev->dev, "Couldn't initialize crq. rc=%d\n", rc);
 +		goto free_netdev;
 +	}
 +
  	INIT_LIST_HEAD(&adapter->errors);
- 	INIT_LIST_HEAD(&adapter->inflight);
  	spin_lock_init(&adapter->error_list_lock);
- 	spin_lock_init(&adapter->inflight_lock);
  
 -	rc = ibmvnic_init(adapter);
 +	adapter->stats_token = dma_map_single(&dev->dev, &adapter->stats,
 +					      sizeof(struct ibmvnic_statistics),
 +					      DMA_FROM_DEVICE);
 +	if (dma_mapping_error(&dev->dev, adapter->stats_token)) {
 +		if (!firmware_has_feature(FW_FEATURE_CMO))
 +			dev_err(&dev->dev, "Couldn't map stats buffer\n");
 +		rc = -ENOMEM;
 +		goto free_crq;
 +	}
 +
 +	snprintf(buf, sizeof(buf), "ibmvnic_%x", dev->unit_address);
 +	ent = debugfs_create_dir(buf, NULL);
 +	if (!ent || IS_ERR(ent)) {
 +		dev_info(&dev->dev, "debugfs create directory failed\n");
 +		adapter->debugfs_dir = NULL;
 +	} else {
 +		adapter->debugfs_dir = ent;
 +		ent = debugfs_create_file("dump", S_IRUGO, adapter->debugfs_dir,
 +					  netdev, &ibmvnic_dump_ops);
 +		if (!ent || IS_ERR(ent)) {
 +			dev_info(&dev->dev,
 +				 "debugfs create dump file failed\n");
 +			adapter->debugfs_dump = NULL;
 +		} else {
 +			adapter->debugfs_dump = ent;
 +		}
 +	}
 +
 +	init_completion(&adapter->init_done);
 +	ibmvnic_send_crq_init(adapter);
 +	if (!wait_for_completion_timeout(&adapter->init_done, timeout))
 +		return 0;
 +
 +	do {
 +		if (adapter->renegotiate) {
 +			adapter->renegotiate = false;
 +			release_sub_crqs_no_irqs(adapter);
 +
 +			reinit_completion(&adapter->init_done);
 +			send_cap_queries(adapter);
 +			if (!wait_for_completion_timeout(&adapter->init_done,
 +							 timeout))
 +				return 0;
 +		}
 +	} while (adapter->renegotiate);
 +
 +	rc = init_sub_crq_irqs(adapter);
  	if (rc) {
 -		free_netdev(netdev);
 -		return rc;
 +		dev_err(&dev->dev, "failed to initialize sub crq irqs\n");
 +		goto free_debugfs;
  	}
  
 -	netdev->mtu = adapter->req_mtu - ETH_HLEN;
 -	adapter->is_closed = false;
 +	netdev->real_num_tx_queues = adapter->req_tx_queues;
 +	netdev->mtu = adapter->req_mtu;
  
  	rc = register_netdev(netdev);
  	if (rc) {
diff --cc drivers/net/ethernet/ibm/ibmvnic.h
index bbf6ef1ce2a3,8fbe05d2710a..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.h
+++ b/drivers/net/ethernet/ibm/ibmvnic.h
@@@ -925,18 -913,6 +925,21 @@@ struct ibmvnic_error_buff 
  	__be32 error_id;
  };
  
++<<<<<<< HEAD
 +struct ibmvnic_fw_comp_internal {
 +	struct ibmvnic_adapter *adapter;
 +	int num;
 +	struct debugfs_blob_wrapper desc_blob;
 +	int paused;
 +};
 +
 +struct ibmvnic_inflight_cmd {
 +	union ibmvnic_crq crq;
 +	struct list_head list;
 +};
 +
++=======
++>>>>>>> 661a26227621 (ibmvnic: Remove inflight list)
  struct ibmvnic_adapter {
  	struct vio_dev *vdev;
  	struct net_device *netdev;
@@@ -995,23 -971,8 +998,19 @@@
  	struct list_head errors;
  	spinlock_t error_list_lock;
  
 +	/* debugfs */
 +	struct dentry *debugfs_dir;
 +	struct dentry *debugfs_dump;
  	struct completion fw_done;
 +	char *dump_data;
 +	dma_addr_t dump_data_token;
 +	int dump_data_size;
 +	int ras_comp_num;
 +	struct ibmvnic_fw_component *ras_comps;
 +	struct ibmvnic_fw_comp_internal *ras_comp_int;
 +	dma_addr_t ras_comps_tok;
 +	struct dentry *ras_comps_ent;
  
- 	/* in-flight commands that allocate and/or map memory*/
- 	struct list_head inflight;
- 	spinlock_t inflight_lock;
- 
  	/* partner capabilities */
  	u64 min_tx_queues;
  	u64 min_rx_queues;
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.h
