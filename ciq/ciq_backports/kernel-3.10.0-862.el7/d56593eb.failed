x86/intel_rdt: Turn off most RDT features on Skylake

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt: Turn off most RDT features on Skylake (Jiri Olsa) [1486121]
Rebuild_FUZZ: 96.00%
commit-author Tony Luck <tony.luck@intel.com>
commit d56593eb5eda8f593db92927059697bbf89bc4b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d56593eb.failed

Errata list is included in this document:
https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/6th-gen-x-series-spec-update.pdf
with more details in:
https://www.intel.com/content/www/us/en/processors/xeon/scalable/xeon-scalable-spec-update.html

But the tl;dr summary (using tags from first of the documents) is:
SKZ4  MBM does not accurately track write bandwidth
SKZ17 CMT counters may not count accurately
SKZ18 CAT may not restrict cacheline allocation under certain conditions
SKZ19 MBM counters may undercount

Disable all these features on Skylake models. Users who understand the
errata may re-enable using boot command line options.

	Signed-off-by: Tony Luck <tony.luck@intel.com>
	Cc: Fenghua" <fenghua.yu@intel.com>
	Cc: Ravi V" <ravi.v.shankar@intel.com>
	Cc: "Peter Zijlstra" <peterz@infradead.org>
	Cc: "Stephane Eranian" <eranian@google.com>
	Cc: "Andi Kleen" <ak@linux.intel.com>
	Cc: "David Carrillo-Cisneros" <davidcc@google.com>
	Cc: Vikas Shivappa <vikas.shivappa@linux.intel.com>
Link: http://lkml.kernel.org/r/3aea0a3bae219062c812668bd9b7b8f1a25003ba.1503512900.git.tony.luck@intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit d56593eb5eda8f593db92927059697bbf89bc4b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt.c
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index ad087dd4421e,cd5fc61ba450..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -398,68 -618,170 +398,113 @@@ static int intel_rdt_offline_cpu(unsign
  	return 0;
  }
  
 -/*
 - * Choose a width for the resource name and resource data based on the
 - * resource that has widest name and cbm.
 - */
 -static __init void rdt_init_padding(void)
 +static int
 +rdt_cpu_notify(struct notifier_block *self, unsigned long action, void *hcpu)
  {
 -	struct rdt_resource *r;
 -	int cl;
 +       unsigned int cpu = (long)hcpu;
  
 -	for_each_alloc_capable_rdt_resource(r) {
 -		cl = strlen(r->name);
 -		if (cl > max_name_width)
 -			max_name_width = cl;
 +       switch (action & ~CPU_TASKS_FROZEN) {
  
 -		if (r->data_width > max_data_width)
 -			max_data_width = r->data_width;
 -	}
 -}
 +       case CPU_ONLINE:
 +       case CPU_DOWN_FAILED:
 +               intel_rdt_online_cpu(cpu, true);
 +               break;
  
 -enum {
 -	RDT_FLAG_CMT,
 -	RDT_FLAG_MBM_TOTAL,
 -	RDT_FLAG_MBM_LOCAL,
 -	RDT_FLAG_L3_CAT,
 -	RDT_FLAG_L3_CDP,
 -	RDT_FLAG_L2_CAT,
 -	RDT_FLAG_MBA,
 -};
 +       case CPU_UP_CANCELED:
 +       case CPU_DOWN_PREPARE:
 +               intel_rdt_offline_cpu(cpu);
 +               break;
 +       default:
 +               break;
 +       }
  
 -#define RDT_OPT(idx, n, f)	\
 -[idx] = {			\
 -	.name = n,		\
 -	.flag = f		\
 +       return NOTIFY_OK;
  }
  
 -struct rdt_options {
 -	char	*name;
 -	int	flag;
 -	bool	force_off, force_on;
 -};
 -
 -static struct rdt_options rdt_options[]  __initdata = {
 -	RDT_OPT(RDT_FLAG_CMT,	    "cmt",	X86_FEATURE_CQM_OCCUP_LLC),
 -	RDT_OPT(RDT_FLAG_MBM_TOTAL, "mbmtotal", X86_FEATURE_CQM_MBM_TOTAL),
 -	RDT_OPT(RDT_FLAG_MBM_LOCAL, "mbmlocal", X86_FEATURE_CQM_MBM_LOCAL),
 -	RDT_OPT(RDT_FLAG_L3_CAT,    "l3cat",	X86_FEATURE_CAT_L3),
 -	RDT_OPT(RDT_FLAG_L3_CDP,    "l3cdp",	X86_FEATURE_CDP_L3),
 -	RDT_OPT(RDT_FLAG_L2_CAT,    "l2cat",	X86_FEATURE_CAT_L2),
 -	RDT_OPT(RDT_FLAG_MBA,	    "mba",	X86_FEATURE_MBA),
 -};
 -#define NUM_RDT_OPTIONS ARRAY_SIZE(rdt_options)
 -
 -static int __init set_rdt_options(char *str)
 +static void __init rdt_cpu_setup(void *dummy)
  {
 -	struct rdt_options *o;
 -	bool force_off;
 -	char *tok;
 -
 -	if (*str == '=')
 -		str++;
 -	while ((tok = strsep(&str, ",")) != NULL) {
 -		force_off = *tok == '!';
 -		if (force_off)
 -			tok++;
 -		for (o = rdt_options; o < &rdt_options[NUM_RDT_OPTIONS]; o++) {
 -			if (strcmp(tok, o->name) == 0) {
 -				if (force_off)
 -					o->force_off = true;
 -				else
 -					o->force_on = true;
 -				break;
 -			}
 -		}
 -	}
 -	return 1;
 -}
 -__setup("rdt", set_rdt_options);
 +	struct rdt_resource *r;
 +	int i;
  
 -static bool __init rdt_cpu_has(int flag)
 -{
 -	bool ret = boot_cpu_has(flag);
 -	struct rdt_options *o;
 +	clear_closid(smp_processor_id());
  
 -	if (!ret)
 -		return ret;
 +	for_each_capable_rdt_resource(r) {
 +		for (i = 0; i < r->num_closid; i++) {
 +			int idx = cbm_idx(r, i);
  
 -	for (o = rdt_options; o < &rdt_options[NUM_RDT_OPTIONS]; o++) {
 -		if (flag == o->flag) {
 -			if (o->force_off)
 -				ret = false;
 -			if (o->force_on)
 -				ret = true;
 -			break;
 +			wrmsrl(r->msr_base + idx, r->max_cbm);
  		}
  	}
 -	return ret;
  }
  
 -static __init bool get_rdt_alloc_resources(void)
 -{
 -	bool ret = false;
 -
 -	if (rdt_alloc_capable)
 -		return true;
 +static struct notifier_block rdt_cpu_nb = {
 +	.notifier_call  = rdt_cpu_notify,
 +	.priority	= -INT_MAX,
 +};
  
 -	if (!boot_cpu_has(X86_FEATURE_RDT_A))
 -		return false;
 +static int __init rdt_notifier_init(void)
 +{
 +	unsigned int cpu;
  
 -	if (rdt_cpu_has(X86_FEATURE_CAT_L3)) {
 -		rdt_get_cache_alloc_cfg(1, &rdt_resources_all[RDT_RESOURCE_L3]);
 -		if (rdt_cpu_has(X86_FEATURE_CDP_L3)) {
 -			rdt_get_cdp_l3_config(RDT_RESOURCE_L3DATA);
 -			rdt_get_cdp_l3_config(RDT_RESOURCE_L3CODE);
 -		}
 -		ret = true;
 -	}
 -	if (rdt_cpu_has(X86_FEATURE_CAT_L2)) {
 -		/* CPUID 0x10.2 fields are same format at 0x10.1 */
 -		rdt_get_cache_alloc_cfg(2, &rdt_resources_all[RDT_RESOURCE_L2]);
 -		ret = true;
 +	for_each_online_cpu(cpu) {
 +		intel_rdt_online_cpu(cpu, false);
 +		/*
 +		 * RHEL7 - The upstream hotplug notification invokes the
 +		 *         callbacks on related cpus, but that's not the
 +		 *         case of the RHEL7 notification support.
 +		 *         Following call ensures we run all the msr
 +		 *         initialization setup on related cpus.
 +		 */
 +		smp_call_function_single(cpu, rdt_cpu_setup, NULL, 1);
  	}
  
++<<<<<<< HEAD
 +	__register_cpu_notifier(&rdt_cpu_nb);
 +	return 0;
++=======
+ 	if (rdt_cpu_has(X86_FEATURE_MBA)) {
+ 		if (rdt_get_mem_config(&rdt_resources_all[RDT_RESOURCE_MBA]))
+ 			ret = true;
+ 	}
+ 	return ret;
+ }
+ 
+ static __init bool get_rdt_mon_resources(void)
+ {
+ 	if (rdt_cpu_has(X86_FEATURE_CQM_OCCUP_LLC))
+ 		rdt_mon_features |= (1 << QOS_L3_OCCUP_EVENT_ID);
+ 	if (rdt_cpu_has(X86_FEATURE_CQM_MBM_TOTAL))
+ 		rdt_mon_features |= (1 << QOS_L3_MBM_TOTAL_EVENT_ID);
+ 	if (rdt_cpu_has(X86_FEATURE_CQM_MBM_LOCAL))
+ 		rdt_mon_features |= (1 << QOS_L3_MBM_LOCAL_EVENT_ID);
+ 
+ 	if (!rdt_mon_features)
+ 		return false;
+ 
+ 	return !rdt_get_mon_l3_config(&rdt_resources_all[RDT_RESOURCE_L3]);
+ }
+ 
+ static __init void rdt_quirks(void)
+ {
+ 	switch (boot_cpu_data.x86_model) {
+ 	case INTEL_FAM6_HASWELL_X:
+ 		if (!rdt_options[RDT_FLAG_L3_CAT].force_off)
+ 			cache_alloc_hsw_probe();
+ 		break;
+ 	case INTEL_FAM6_SKYLAKE_X:
+ 		if (boot_cpu_data.x86_mask <= 4)
+ 			set_rdt_options("!cmt,!mbmtotal,!mbmlocal,!l3cat");
+ 	}
+ }
+ 
+ static __init bool get_rdt_resources(void)
+ {
+ 	rdt_quirks();
+ 	rdt_alloc_capable = get_rdt_alloc_resources();
+ 	rdt_mon_capable = get_rdt_mon_resources();
+ 
+ 	return (rdt_mon_capable || rdt_alloc_capable);
++>>>>>>> d56593eb5eda (x86/intel_rdt: Turn off most RDT features on Skylake)
  }
  
  static int __init intel_rdt_late_init(void)
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
