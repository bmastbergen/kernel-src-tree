net/mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs (Don Dutile) [1456694 1499362]
Rebuild_FUZZ: 96.49%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit aff2615763f206f897146e0ee1ddae8e22055ae3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/aff26157.failed

One is sufficient since Blue Flame is not supported anymore.
This will also come in handy for switchdev mode to save resources, since
VF representors will use same single UAR as well for their own SQs.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aff2615763f206f897146e0ee1ddae8e22055ae3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 16c2c2d53ebb,22e4bad03f05..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -468,7 -483,6 +468,10 @@@ struct mlx5e_sq 
  
  	/* control path */
  	struct mlx5_wq_ctrl        wq_ctrl;
++<<<<<<< HEAD
 +	struct mlx5_uar            uar;
++=======
++>>>>>>> aff2615763f2 (net/mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs)
  	struct mlx5e_channel      *channel;
  	int                        tc;
  	u32                        rate_limit;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index edb21d8194bc,49c1769d13b9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -951,31 -1016,19 +951,35 @@@ static int mlx5e_create_sq(struct mlx5e
  	sq->mkey_be   = c->mkey_be;
  	sq->channel   = c;
  	sq->tc        = tc;
+ 	sq->uar_map   = mdev->mlx5e_res.bfreg.map;
  
++<<<<<<< HEAD
 +	err = mlx5_alloc_map_uar(mdev, &sq->uar, !!MLX5_CAP_GEN(mdev, bf));
 +	if (err)
 +		return err;
 +
 +	sq->uar_map = sq->bfreg.map;
++=======
++>>>>>>> aff2615763f2 (net/mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs)
  	param->wq.db_numa_node = cpu_to_node(c->cpu);
  
  	err = mlx5_wq_cyc_create(mdev, &param->wq, sqc_wq, &sq->wq,
  				 &sq->wq_ctrl);
  	if (err)
- 		goto err_unmap_free_uar;
+ 		return err;
  
  	sq->wq.db       = &sq->wq.db[MLX5_SND_DBR];
 -
 +	if (sq->uar.bf_map) {
 +		set_bit(MLX5E_SQ_STATE_BF_ENABLE, &sq->state);
 +		sq->uar_map = sq->uar.bf_map;
 +	} else {
 +		sq->uar_map = sq->uar.map;
 +	}
 +	sq->bf_buf_size = (1 << MLX5_CAP_GEN(mdev, log_bf_reg_size)) / 2;
  	sq->max_inline  = param->max_inline;
 -	sq->min_inline_mode = param->min_inline_mode;
 +	sq->min_inline_mode =
 +		MLX5_CAP_ETH(mdev, wqe_inline_mode) == MLX5_CAP_INLINE_MODE_VPORT_CONTEXT ?
 +		param->min_inline_mode : 0;
  
  	err = mlx5e_alloc_sq_db(sq, cpu_to_node(c->cpu));
  	if (err)
@@@ -1001,20 -1049,13 +1005,23 @@@
  err_sq_wq_destroy:
  	mlx5_wq_destroy(&sq->wq_ctrl);
  
++<<<<<<< HEAD
 +err_unmap_free_uar:
 +	mlx5_unmap_free_uar(mdev, &sq->uar);
 +
++=======
++>>>>>>> aff2615763f2 (net/mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs)
  	return err;
  }
  
  static void mlx5e_destroy_sq(struct mlx5e_sq *sq)
  {
- 	struct mlx5e_channel *c = sq->channel;
- 	struct mlx5e_priv *priv = c->priv;
- 
  	mlx5e_free_sq_db(sq);
  	mlx5_wq_destroy(&sq->wq_ctrl);
++<<<<<<< HEAD
 +	mlx5_unmap_free_uar(priv->mdev, &sq->uar);
++=======
++>>>>>>> aff2615763f2 (net/mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs)
  }
  
  static int mlx5e_enable_sq(struct mlx5e_sq *sq, struct mlx5e_sq_param *param)
@@@ -1048,7 -1092,7 +1055,11 @@@
  	MLX5_SET(sqc,  sqc, tis_lst_sz, param->type == MLX5E_SQ_ICO ? 0 : 1);
  
  	MLX5_SET(wq,   wq, wq_type,       MLX5_WQ_TYPE_CYCLIC);
++<<<<<<< HEAD
 +	MLX5_SET(wq,   wq, uar_page,      sq->uar.index);
++=======
+ 	MLX5_SET(wq,   wq, uar_page,      mdev->mlx5e_res.bfreg.index);
++>>>>>>> aff2615763f2 (net/mlx5e: Single bfreg (UAR) for all mlx5e SQs and netdevs)
  	MLX5_SET(wq,   wq, log_wq_pg_sz,  sq->wq_ctrl.buf.page_shift -
  					  MLX5_ADAPTER_PAGE_SHIFT);
  	MLX5_SET64(wq, wq, dbr_addr,      sq->wq_ctrl.db.dma);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
index f175518ff07a..ec5503efa3cc 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
@@ -113,10 +113,18 @@ int mlx5e_create_mdev_resources(struct mlx5_core_dev *mdev)
 		goto err_dealloc_transport_domain;
 	}
 
+	err = mlx5_alloc_bfreg(mdev, &res->bfreg, false, false);
+	if (err) {
+		mlx5_core_err(mdev, "alloc bfreg failed, %d\n", err);
+		goto err_destroy_mkey;
+	}
+
 	INIT_LIST_HEAD(&mdev->mlx5e_res.td.tirs_list);
 
 	return 0;
 
+err_destroy_mkey:
+	mlx5_core_destroy_mkey(mdev, &res->mkey);
 err_dealloc_transport_domain:
 	mlx5_core_dealloc_transport_domain(mdev, res->td.tdn);
 err_dealloc_pd:
@@ -131,6 +139,7 @@ void mlx5e_destroy_mdev_resources(struct mlx5_core_dev *mdev)
 {
 	struct mlx5e_resources *res = &mdev->mlx5e_res;
 
+	mlx5_free_bfreg(mdev, &res->bfreg);
 	mlx5_core_destroy_mkey(mdev, &res->mkey);
 	mlx5_core_dealloc_transport_domain(mdev, res->td.tdn);
 	mlx5_core_dealloc_pd(mdev, res->pdn);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 61d8bec93f9f..06af8c3a0fec 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -641,6 +641,7 @@ struct mlx5e_resources {
 	u32                        pdn;
 	struct mlx5_td             td;
 	struct mlx5_core_mkey      mkey;
+	struct mlx5_sq_bfreg       bfreg;
 };
 
 struct mlx5_core_dev {
