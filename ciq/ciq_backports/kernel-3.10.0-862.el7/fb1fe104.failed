cpufreq: intel_pstate: Operation mode control from sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Operation mode control from sysfs (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 91.26%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit fb1fe1041c04ee5ba362cf239e83a7c559beb0f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fb1fe104.failed

Make it possible to change the operation mode of intel_pstate with
the help of a new sysfs attribute called "status".

There are three possible configurations that can be selected using
this attribute:

 "off"     - The driver is not in use at this time.
 "active"  - The driver works as a P-state governor (default).
 "passive" - The driver works as a regular cpufreq one and collaborates
             with the generic cpufreq governors (it sets P-states as
             requested by those governors).  [This is the same mode
             the driver can be started in by passing intel_pstate=passive
             in the kernel command line.]

The current setting is returned by reads from this attribute.  Writing
one of the above strings to it changes the operation mode as indicated
by that string, if possible.

If HW-managed P-states (HWP) feature is enabled, it is not possible
to change the driver's operation mode and attempts to write to this
attribute will fail.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit fb1fe1041c04ee5ba362cf239e83a7c559beb0f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/cpu-freq/intel-pstate.txt
#	drivers/cpufreq/intel_pstate.c
diff --cc Documentation/cpu-freq/intel-pstate.txt
index be8d4006bf76,3fdcdfd968ba..000000000000
--- a/Documentation/cpu-freq/intel-pstate.txt
+++ b/Documentation/cpu-freq/intel-pstate.txt
@@@ -1,62 -1,191 +1,123 @@@
 -Intel P-State driver
 +Intel P-state driver
  --------------------
  
 -This driver provides an interface to control the P-State selection for the
 -SandyBridge+ Intel processors.
 -
 -The following document explains P-States:
 -http://events.linuxfoundation.org/sites/events/files/slides/LinuxConEurope_2015.pdf
 -As stated in the document, P-State doesn’t exactly mean a frequency. However, for
 -the sake of the relationship with cpufreq, P-State and frequency are used
 -interchangeably.
 -
 -Understanding the cpufreq core governors and policies are important before
 -discussing more details about the Intel P-State driver. Based on what callbacks
 -a cpufreq driver provides to the cpufreq core, it can support two types of
 -drivers:
 -- with target_index() callback: In this mode, the drivers using cpufreq core
 -simply provide the minimum and maximum frequency limits and an additional
 -interface target_index() to set the current frequency. The cpufreq subsystem
 -has a number of scaling governors ("performance", "powersave", "ondemand",
 -etc.). Depending on which governor is in use, cpufreq core will call for
 -transitions to a specific frequency using target_index() callback.
 -- setpolicy() callback: In this mode, drivers do not provide target_index()
 -callback, so cpufreq core can't request a transition to a specific frequency.
 -The driver provides minimum and maximum frequency limits and callbacks to set a
 -policy. The policy in cpufreq sysfs is referred to as the "scaling governor".
 -The cpufreq core can request the driver to operate in any of the two policies:
 -"performance" and "powersave". The driver decides which frequency to use based
 -on the above policy selection considering minimum and maximum frequency limits.
 -
 -The Intel P-State driver falls under the latter category, which implements the
 -setpolicy() callback. This driver decides what P-State to use based on the
 -requested policy from the cpufreq core. If the processor is capable of
 -selecting its next P-State internally, then the driver will offload this
 -responsibility to the processor (aka HWP: Hardware P-States). If not, the
 -driver implements algorithms to select the next P-State.
 -
 -Since these policies are implemented in the driver, they are not same as the
 -cpufreq scaling governors implementation, even if they have the same name in
 -the cpufreq sysfs (scaling_governors). For example the "performance" policy is
 -similar to cpufreq’s "performance" governor, but "powersave" is completely
 -different than the cpufreq "powersave" governor. The strategy here is similar
 -to cpufreq "ondemand", where the requested P-State is related to the system load.
 -
 -Sysfs Interface
 -
 -In addition to the frequency-controlling interfaces provided by the cpufreq
 -core, the driver provides its own sysfs files to control the P-State selection.
 -These files have been added to /sys/devices/system/cpu/intel_pstate/.
 -Any changes made to these files are applicable to all CPUs (even in a
 -multi-package system, Refer to later section on placing "Per-CPU limits").
 -
 -      max_perf_pct: Limits the maximum P-State that will be requested by
 -      the driver. It states it as a percentage of the available performance. The
 -      available (P-State) performance may be reduced by the no_turbo
 +This driver provides an interface to control the P state selection for
 +SandyBridge+ Intel processors.  The driver can operate two different
 +modes based on the processor model, legacy mode and Hardware P state (HWP)
 +mode.
 +
 +In legacy mode, the Intel P-state implements two internal governors,
 +performance and powersave, that differ from the general cpufreq governors of
 +the same name (the general cpufreq governors implement target(), whereas the
 +internal Intel P-state governors implement setpolicy()).  The internal
 +performance governor sets the max_perf_pct and min_perf_pct to 100; that is,
 +the governor selects the highest available P state to maximize the performance
 +of the core.  The internal powersave governor selects the appropriate P state
 +based on the current load on the CPU.
 +
 +In HWP mode P state selection is implemented in the processor
 +itself. The driver provides the interfaces between the cpufreq core and
 +the processor to control P state selection based on user preferences
 +and reporting frequency to the cpufreq core.  In this mode the
 +internal Intel P-state governor code is disabled.
 +
 +In addition to the interfaces provided by the cpufreq core for
 +controlling frequency the driver provides sysfs files for
 +controlling P state selection. These files have been added to
 +/sys/devices/system/cpu/intel_pstate/
 +
 +      max_perf_pct: limits the maximum P state that will be requested by
 +      the driver stated as a percentage of the available performance. The
 +      available (P states) performance may be reduced by the no_turbo
        setting described below.
  
 -      min_perf_pct: Limits the minimum P-State that will be requested by
 -      the driver. It states it as a percentage of the max (non-turbo)
 +      min_perf_pct: limits the minimum P state that will be  requested by
 +      the driver stated as a percentage of the max (non-turbo)
        performance level.
  
 -      no_turbo: Limits the driver to selecting P-State below the turbo
 +      no_turbo: limits the driver to selecting P states below the turbo
        frequency range.
  
 -      turbo_pct: Displays the percentage of the total performance that
 -      is supported by hardware that is in the turbo range. This number
 +      turbo_pct: displays the percentage of the total performance that
 +      is supported by hardware that is in the turbo range.  This number
        is independent of whether turbo has been disabled or not.
  
 -      num_pstates: Displays the number of P-States that are supported
 -      by hardware. This number is independent of whether turbo has
 +      num_pstates: displays the number of pstates that are supported
 +      by hardware.  This number is independent of whether turbo has
        been disabled or not.
  
++<<<<<<< HEAD
++=======
+ For example, if a system has these parameters:
+ 	Max 1 core turbo ratio: 0x21 (Max 1 core ratio is the maximum P-State)
+ 	Max non turbo ratio: 0x17
+ 	Minimum ratio : 0x08 (Here the ratio is called max efficiency ratio)
+ 
+ Sysfs will show :
+ 	max_perf_pct:100, which corresponds to 1 core ratio
+ 	min_perf_pct:24, max_efficiency_ratio / max 1 Core ratio
+ 	no_turbo:0, turbo is not disabled
+ 	num_pstates:26 = (max 1 Core ratio - Max Efficiency Ratio + 1)
+ 	turbo_pct:39 = (max 1 core ratio - max non turbo ratio) / num_pstates
+ 
+ Refer to "Intel® 64 and IA-32 Architectures Software Developer’s Manual
+ Volume 3: System Programming Guide" to understand ratios.
+ 
+ There is one more sysfs attribute in /sys/devices/system/cpu/intel_pstate/
+ that can be used for controlling the operation mode of the driver:
+ 
+       status: Three settings are possible:
+       "off"     - The driver is not in use at this time.
+       "active"  - The driver works as a P-state governor (default).
+       "passive" - The driver works as a regular cpufreq one and collaborates
+                   with the generic cpufreq governors (it sets P-states as
+                   requested by those governors).
+       The current setting is returned by reads from this attribute.  Writing one
+       of the above strings to it changes the operation mode as indicated by that
+       string, if possible.  If HW-managed P-states (HWP) are enabled, it is not
+       possible to change the driver's operation mode and attempts to write to
+       this attribute will fail.
+ 
+ cpufreq sysfs for Intel P-State
+ 
+ Since this driver registers with cpufreq, cpufreq sysfs is also presented.
+ There are some important differences, which need to be considered.
+ 
+ scaling_cur_freq: This displays the real frequency which was used during
+ the last sample period instead of what is requested. Some other cpufreq driver,
+ like acpi-cpufreq, displays what is requested (Some changes are on the
+ way to fix this for acpi-cpufreq driver). The same is true for frequencies
+ displayed at /proc/cpuinfo.
+ 
+ scaling_governor: This displays current active policy. Since each CPU has a
+ cpufreq sysfs, it is possible to set a scaling governor to each CPU. But this
+ is not possible with Intel P-States, as there is one common policy for all
+ CPUs. Here, the last requested policy will be applicable to all CPUs. It is
+ suggested that one use the cpupower utility to change policy to all CPUs at the
+ same time.
+ 
+ scaling_setspeed: This attribute can never be used with Intel P-State.
+ 
+ scaling_max_freq/scaling_min_freq: This interface can be used similarly to
+ the max_perf_pct/min_perf_pct of Intel P-State sysfs. However since frequencies
+ are converted to nearest possible P-State, this is prone to rounding errors.
+ This method is not preferred to limit performance.
+ 
+ affected_cpus: Not used
+ related_cpus: Not used
+ 
++>>>>>>> fb1fe1041c04 (cpufreq: intel_pstate: Operation mode control from sysfs)
  For contemporary Intel processors, the frequency is controlled by the
 -processor itself and the P-State exposed to software is related to
 +processor itself and the P-states exposed to software are related to
  performance levels.  The idea that frequency can be set to a single
 -frequency is fictional for Intel Core processors. Even if the scaling
 -driver selects a single P-State, the actual frequency the processor
 +frequency is fiction for Intel Core processors. Even if the scaling
 +driver selects a single P state the actual frequency the processor
  will run at is selected by the processor itself.
  
 -Per-CPU limits
 -
 -The kernel command line option "intel_pstate=per_cpu_perf_limits" forces
 -the intel_pstate driver to use per-CPU performance limits.  When it is set,
 -the sysfs control interface described above is subject to limitations.
 -- The following controls are not available for both read and write
 -	/sys/devices/system/cpu/intel_pstate/max_perf_pct
 -	/sys/devices/system/cpu/intel_pstate/min_perf_pct
 -- The following controls can be used to set performance limits, as far as the
 -architecture of the processor permits:
 -	/sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
 -	/sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq
 -	/sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
 -- User can still observe turbo percent and number of P-States from
 -	/sys/devices/system/cpu/intel_pstate/turbo_pct
 -	/sys/devices/system/cpu/intel_pstate/num_pstates
 -- User can read write system wide turbo status
 -	/sys/devices/system/cpu/no_turbo
 -
 -Support of energy performance hints
 -It is possible to provide hints to the HWP algorithms in the processor
 -to be more performance centric to more energy centric. When the driver
 -is using HWP, two additional cpufreq sysfs attributes are presented for
 -each logical CPU.
 -These attributes are:
 -	- energy_performance_available_preferences
 -	- energy_performance_preference
 -
 -To get list of supported hints:
 -$ cat energy_performance_available_preferences
 -    default performance balance_performance balance_power power
 -
 -The current preference can be read or changed via cpufreq sysfs
 -attribute "energy_performance_preference". Reading from this attribute
 -will display current effective setting. User can write any of the valid
 -preference string to this attribute. User can always restore to power-on
 -default by writing "default".
 -
 -Since threads can migrate to different CPUs, this is possible that the
 -new CPU may have different energy performance preference than the previous
 -one. To avoid such issues, either threads can be pinned to specific CPUs
 -or set the same energy performance preference value to all CPUs.
 -
 -Tuning Intel P-State driver
 -
 -When the performance can be tuned using PID (Proportional Integral
 -Derivative) controller, debugfs files are provided for adjusting performance.
 -They are presented under:
 -/sys/kernel/debug/pstate_snb/
 +For legacy mode debugfs files have also been added to allow tuning of
 +the internal governor algorythm. These files are located at
 +/sys/kernel/debug/pstate_snb/ These files are NOT present in HWP mode.
  
 -The PID tunable parameters are:
        deadband
        d_gain_pct
        i_gain_pct
diff --cc drivers/cpufreq/intel_pstate.c
index e5b33d3c3e3c,c783151b71e9..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -449,9 -541,8 +449,8 @@@ static void intel_pstate_exit_perf_limi
  
  	acpi_processor_unregister_performance(policy->cpu);
  }
- 
  #else
 -static inline void intel_pstate_init_acpi_perf_limits(struct cpufreq_policy *policy)
 +static void intel_pstate_init_acpi_perf_limits(struct cpufreq_policy *policy)
  {
  }
  
@@@ -770,9 -1293,8 +820,10 @@@ define_one_global_ro(turbo_pct)
  define_one_global_ro(num_pstates);
  
  static struct attribute *intel_pstate_attributes[] = {
+ 	&status.attr,
  	&no_turbo.attr,
 +	&max_perf_pct.attr,
 +	&min_perf_pct.attr,
  	&turbo_pct.attr,
  	&num_pstates.attr,
  	NULL
@@@ -1538,6 -2264,227 +1589,230 @@@ static struct cpufreq_driver intel_psta
  	.name		= "intel_pstate",
  };
  
++<<<<<<< HEAD
++=======
+ static int intel_cpufreq_verify_policy(struct cpufreq_policy *policy)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 	struct perf_limits *perf_limits = limits;
+ 
+ 	update_turbo_state();
+ 	policy->cpuinfo.max_freq = limits->turbo_disabled ?
+ 			cpu->pstate.max_freq : cpu->pstate.turbo_freq;
+ 
+ 	cpufreq_verify_within_cpu_limits(policy);
+ 
+ 	if (per_cpu_limits)
+ 		perf_limits = cpu->perf_limits;
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
+ 	intel_pstate_update_perf_limits(policy, perf_limits);
+ 
+ 	mutex_unlock(&intel_pstate_limits_lock);
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int intel_cpufreq_turbo_update(struct cpudata *cpu,
+ 					       struct cpufreq_policy *policy,
+ 					       unsigned int target_freq)
+ {
+ 	unsigned int max_freq;
+ 
+ 	update_turbo_state();
+ 
+ 	max_freq = limits->no_turbo || limits->turbo_disabled ?
+ 			cpu->pstate.max_freq : cpu->pstate.turbo_freq;
+ 	policy->cpuinfo.max_freq = max_freq;
+ 	if (policy->max > max_freq)
+ 		policy->max = max_freq;
+ 
+ 	if (target_freq > max_freq)
+ 		target_freq = max_freq;
+ 
+ 	return target_freq;
+ }
+ 
+ static int intel_cpufreq_target(struct cpufreq_policy *policy,
+ 				unsigned int target_freq,
+ 				unsigned int relation)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 	struct cpufreq_freqs freqs;
+ 	int target_pstate;
+ 
+ 	freqs.old = policy->cur;
+ 	freqs.new = intel_cpufreq_turbo_update(cpu, policy, target_freq);
+ 
+ 	cpufreq_freq_transition_begin(policy, &freqs);
+ 	switch (relation) {
+ 	case CPUFREQ_RELATION_L:
+ 		target_pstate = DIV_ROUND_UP(freqs.new, cpu->pstate.scaling);
+ 		break;
+ 	case CPUFREQ_RELATION_H:
+ 		target_pstate = freqs.new / cpu->pstate.scaling;
+ 		break;
+ 	default:
+ 		target_pstate = DIV_ROUND_CLOSEST(freqs.new, cpu->pstate.scaling);
+ 		break;
+ 	}
+ 	target_pstate = intel_pstate_prepare_request(cpu, target_pstate);
+ 	if (target_pstate != cpu->pstate.current_pstate) {
+ 		cpu->pstate.current_pstate = target_pstate;
+ 		wrmsrl_on_cpu(policy->cpu, MSR_IA32_PERF_CTL,
+ 			      pstate_funcs.get_val(cpu, target_pstate));
+ 	}
+ 	cpufreq_freq_transition_end(policy, &freqs, false);
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int intel_cpufreq_fast_switch(struct cpufreq_policy *policy,
+ 					      unsigned int target_freq)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 	int target_pstate;
+ 
+ 	target_freq = intel_cpufreq_turbo_update(cpu, policy, target_freq);
+ 	target_pstate = DIV_ROUND_UP(target_freq, cpu->pstate.scaling);
+ 	intel_pstate_update_pstate(cpu, target_pstate);
+ 	return target_freq;
+ }
+ 
+ static int intel_cpufreq_cpu_init(struct cpufreq_policy *policy)
+ {
+ 	int ret = __intel_pstate_cpu_init(policy);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	policy->cpuinfo.transition_latency = INTEL_CPUFREQ_TRANSITION_LATENCY;
+ 	/* This reflects the intel_pstate_get_cpu_pstates() setting. */
+ 	policy->cur = policy->cpuinfo.min_freq;
+ 
+ 	return 0;
+ }
+ 
+ static struct cpufreq_driver intel_cpufreq = {
+ 	.flags		= CPUFREQ_CONST_LOOPS,
+ 	.verify		= intel_cpufreq_verify_policy,
+ 	.target		= intel_cpufreq_target,
+ 	.fast_switch	= intel_cpufreq_fast_switch,
+ 	.init		= intel_cpufreq_cpu_init,
+ 	.exit		= intel_pstate_cpu_exit,
+ 	.stop_cpu	= intel_cpufreq_stop_cpu,
+ 	.name		= "intel_cpufreq",
+ };
+ 
+ static struct cpufreq_driver *intel_pstate_driver = &intel_pstate;
+ 
+ static void intel_pstate_driver_cleanup(void)
+ {
+ 	unsigned int cpu;
+ 
+ 	get_online_cpus();
+ 	for_each_online_cpu(cpu) {
+ 		if (all_cpu_data[cpu]) {
+ 			if (intel_pstate_driver == &intel_pstate)
+ 				intel_pstate_clear_update_util_hook(cpu);
+ 
+ 			kfree(all_cpu_data[cpu]);
+ 			all_cpu_data[cpu] = NULL;
+ 		}
+ 	}
+ 	put_online_cpus();
+ }
+ 
+ static int intel_pstate_register_driver(void)
+ {
+ 	int ret;
+ 
+ 	ret = cpufreq_register_driver(intel_pstate_driver);
+ 	if (ret) {
+ 		intel_pstate_driver_cleanup();
+ 		return ret;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 	driver_registered = true;
+ 	mutex_unlock(&intel_pstate_limits_lock);
+ 
+ 	if (intel_pstate_driver == &intel_pstate && !hwp_active &&
+ 	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
+ 		intel_pstate_debug_expose_params();
+ 
+ 	return 0;
+ }
+ 
+ static int intel_pstate_unregister_driver(void)
+ {
+ 	if (hwp_active)
+ 		return -EBUSY;
+ 
+ 	if (intel_pstate_driver == &intel_pstate && !hwp_active &&
+ 	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
+ 		intel_pstate_debug_hide_params();
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 	driver_registered = false;
+ 	mutex_unlock(&intel_pstate_limits_lock);
+ 
+ 	cpufreq_unregister_driver(intel_pstate_driver);
+ 	intel_pstate_driver_cleanup();
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t intel_pstate_show_status(char *buf)
+ {
+ 	if (!driver_registered)
+ 		return sprintf(buf, "off\n");
+ 
+ 	return sprintf(buf, "%s\n", intel_pstate_driver == &intel_pstate ?
+ 					"active" : "passive");
+ }
+ 
+ static int intel_pstate_update_status(const char *buf, size_t size)
+ {
+ 	int ret;
+ 
+ 	if (size == 3 && !strncmp(buf, "off", size))
+ 		return driver_registered ?
+ 			intel_pstate_unregister_driver() : -EINVAL;
+ 
+ 	if (size == 6 && !strncmp(buf, "active", size)) {
+ 		if (driver_registered) {
+ 			if (intel_pstate_driver == &intel_pstate)
+ 				return 0;
+ 
+ 			ret = intel_pstate_unregister_driver();
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		intel_pstate_driver = &intel_pstate;
+ 		return intel_pstate_register_driver();
+ 	}
+ 
+ 	if (size == 7 && !strncmp(buf, "passive", size)) {
+ 		if (driver_registered) {
+ 			if (intel_pstate_driver != &intel_pstate)
+ 				return 0;
+ 
+ 			ret = intel_pstate_unregister_driver();
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		intel_pstate_driver = &intel_cpufreq;
+ 		return intel_pstate_register_driver();
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> fb1fe1041c04 (cpufreq: intel_pstate: Operation mode control from sysfs)
  static int no_load __initdata;
  static int no_hwp __initdata;
  static int hwp_only __initdata;
@@@ -1710,9 -2672,9 +1985,13 @@@ static const struct x86_cpu_id hwp_supp
  
  static int __init intel_pstate_init(void)
  {
- 	int cpu, rc = 0;
  	const struct x86_cpu_id *id;
++<<<<<<< HEAD
 +	struct cpu_defaults *cpu_info;
++=======
+ 	struct cpu_defaults *cpu_def;
+ 	int rc = 0;
++>>>>>>> fb1fe1041c04 (cpufreq: intel_pstate: Operation mode control from sysfs)
  
  	if (no_load)
  		return -ENODEV;
@@@ -1743,43 -2706,29 +2022,61 @@@ hwp_cpu_matched
  	if (intel_pstate_platform_pwr_mgmt_exists())
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	pr_info("Intel P-state driver initializing.\n");
++=======
+ 	if (!hwp_active && hwp_only)
+ 		return -ENOTSUPP;
+ 
+ 	pr_info("Intel P-state driver initializing\n");
++>>>>>>> fb1fe1041c04 (cpufreq: intel_pstate: Operation mode control from sysfs)
  
  	all_cpu_data = vzalloc(sizeof(void *) * num_possible_cpus());
  	if (!all_cpu_data)
  		return -ENOMEM;
  
- 	if (!hwp_active && hwp_only)
- 		goto out;
- 
  	intel_pstate_request_control_from_smm();
  
++<<<<<<< HEAD
 +	rc = cpufreq_register_driver(&intel_pstate_driver);
 +	if (rc)
 +		goto out;
 +
 +	if (intel_pstate_driver == &intel_pstate && !hwp_active &&
 +	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
 +		intel_pstate_debug_expose_params();
++=======
+ 	intel_pstate_sysfs_expose_params();
+ 
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 	rc = intel_pstate_register_driver();
+ 	mutex_unlock(&intel_pstate_driver_lock);
+ 	if (rc)
+ 		return rc;
++>>>>>>> fb1fe1041c04 (cpufreq: intel_pstate: Operation mode control from sysfs)
 +
 +	intel_pstate_sysfs_expose_params();
  
  	if (hwp_active)
 -		pr_info("HWP enabled\n");
 +		pr_info("intel_pstate: HWP enabled\n");
 +
++<<<<<<< HEAD
 +	return rc;
 +out:
 +	get_online_cpus();
 +	for_each_online_cpu(cpu) {
 +		if (all_cpu_data[cpu]) {
 +			del_timer_sync(&all_cpu_data[cpu]->timer);
 +			kfree(all_cpu_data[cpu]);
 +		}
 +	}
  
 +	put_online_cpus();
 +	vfree(all_cpu_data);
 +	return -ENODEV;
++=======
+ 	return 0;
++>>>>>>> fb1fe1041c04 (cpufreq: intel_pstate: Operation mode control from sysfs)
  }
  device_initcall(intel_pstate_init);
  
* Unmerged path Documentation/cpu-freq/intel-pstate.txt
* Unmerged path drivers/cpufreq/intel_pstate.c
