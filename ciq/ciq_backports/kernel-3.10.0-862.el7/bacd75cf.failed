i40e/i40evf: Add capability exchange for outer checksum

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Preethi Banala <preethi.banala@intel.com>
commit bacd75cfac8af9fc91b7fde4b0cad8960c77986f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bacd75cf.failed

This patch adds a capability negotiation between VF and PF using ENCAP/
ENCAP_CSUM offload flags in order for the VF to support outer checksum
and TSO offloads for encapsulated packets. These capabilities were assumed
by default and enabled in current hardware. Going forward, these features
needs to be negotiated with PF before advertising to the stack.
Additionally, strip out the mac.type checks for X722 since outer checksums
are enabled based on the ENCAP_CSUM offload negotiation flag and maintain
consistency between drivers in how the features are configured.

Change-ID: Ie380a6f57eca557a2bb575b66b12fae36d308920
	Signed-off-by: Preethi Banala <preethi.banala@intel.com>
	Signed-off-by: Alan Brady <alan.brady@intel.com>
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit bacd75cfac8af9fc91b7fde4b0cad8960c77986f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 3d3ef732a6d1,7147c67a939d..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -9500,25 -9265,23 +9502,45 @@@ static int i40e_config_netdev(struct i4
  	np = netdev_priv(netdev);
  	np->vsi = vsi;
  
++<<<<<<< HEAD
 +	netdev->hw_enc_features |= NETIF_F_SG			|
 +				   NETIF_F_IP_CSUM		|
 +				   NETIF_F_IPV6_CSUM		|
 +				   NETIF_F_HIGHDMA		|
 +				   NETIF_F_SOFT_FEATURES	|
 +				   NETIF_F_TSO			|
 +				   NETIF_F_TSO_ECN		|
 +				   NETIF_F_TSO6			|
 +				   NETIF_F_GSO_GRE		|
 +				   NETIF_F_GSO_GRE_CSUM		|
 +				   NETIF_F_GSO_IPIP		|
 +				   NETIF_F_GSO_SIT		|
 +				   NETIF_F_GSO_UDP_TUNNEL	|
 +				   NETIF_F_GSO_UDP_TUNNEL_CSUM	|
 +				   NETIF_F_GSO_PARTIAL		|
 +				   NETIF_F_SCTP_CRC		|
 +				   NETIF_F_RXHASH		|
 +				   NETIF_F_RXCSUM		|
 +				   0;
++=======
+ 	hw_enc_features = NETIF_F_SG			|
+ 			  NETIF_F_IP_CSUM		|
+ 			  NETIF_F_IPV6_CSUM		|
+ 			  NETIF_F_HIGHDMA		|
+ 			  NETIF_F_SOFT_FEATURES		|
+ 			  NETIF_F_TSO			|
+ 			  NETIF_F_TSO_ECN		|
+ 			  NETIF_F_TSO6			|
+ 			  NETIF_F_GSO_GRE		|
+ 			  NETIF_F_GSO_GRE_CSUM		|
+ 			  NETIF_F_GSO_PARTIAL		|
+ 			  NETIF_F_GSO_UDP_TUNNEL	|
+ 			  NETIF_F_GSO_UDP_TUNNEL_CSUM	|
+ 			  NETIF_F_SCTP_CRC		|
+ 			  NETIF_F_RXHASH		|
+ 			  NETIF_F_RXCSUM		|
+ 			  0;
++>>>>>>> bacd75cfac8a (i40e/i40evf: Add capability exchange for outer checksum)
  
  	if (!(pf->flags & I40E_FLAG_OUTER_UDP_CSUM_CAPABLE))
  		netdev->gso_partial_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 4df10e9d6551,c690aba8e8d1..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -2402,46 -2414,52 +2404,58 @@@ int i40evf_process_config(struct i40evf
  		return -ENODEV;
  	}
  
- 	netdev->hw_enc_features |= NETIF_F_SG			|
- 				   NETIF_F_IP_CSUM		|
- 				   NETIF_F_IPV6_CSUM		|
- 				   NETIF_F_HIGHDMA		|
- 				   NETIF_F_SOFT_FEATURES	|
- 				   NETIF_F_TSO			|
- 				   NETIF_F_TSO_ECN		|
- 				   NETIF_F_TSO6			|
+ 	hw_enc_features = NETIF_F_SG			|
+ 			  NETIF_F_IP_CSUM		|
+ 			  NETIF_F_IPV6_CSUM		|
+ 			  NETIF_F_HIGHDMA		|
+ 			  NETIF_F_SOFT_FEATURES	|
+ 			  NETIF_F_TSO			|
+ 			  NETIF_F_TSO_ECN		|
+ 			  NETIF_F_TSO6			|
+ 			  NETIF_F_SCTP_CRC		|
+ 			  NETIF_F_RXHASH		|
+ 			  NETIF_F_RXCSUM		|
+ 			  0;
+ 
+ 	/* advertise to stack only if offloads for encapsulated packets is
+ 	 * supported
+ 	 */
+ 	if (vfres->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_ENCAP) {
+ 		hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL	|
  				   NETIF_F_GSO_GRE		|
  				   NETIF_F_GSO_GRE_CSUM		|
++<<<<<<< HEAD
 +				   NETIF_F_GSO_IPIP		|
 +				   NETIF_F_GSO_SIT		|
 +				   NETIF_F_GSO_UDP_TUNNEL	|
++=======
+ 				   NETIF_F_GSO_IPXIP4		|
+ 				   NETIF_F_GSO_IPXIP6		|
++>>>>>>> bacd75cfac8a (i40e/i40evf: Add capability exchange for outer checksum)
  				   NETIF_F_GSO_UDP_TUNNEL_CSUM	|
  				   NETIF_F_GSO_PARTIAL		|
- 				   NETIF_F_SCTP_CRC		|
- 				   NETIF_F_RXHASH		|
- 				   NETIF_F_RXCSUM		|
  				   0;
  
- 	if (!(adapter->flags & I40EVF_FLAG_OUTER_UDP_CSUM_CAPABLE))
- 		netdev->gso_partial_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;
- 
- 	netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
+ 		if (!(vfres->vf_offload_flags &
+ 		      I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
+ 			netdev->gso_partial_features |=
+ 				NETIF_F_GSO_UDP_TUNNEL_CSUM;
  
+ 		netdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;
+ 		netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
+ 		netdev->hw_enc_features |= hw_enc_features;
+ 	}
  	/* record features VLANs can make use of */
- 	netdev->vlan_features |= netdev->hw_enc_features |
- 				 NETIF_F_TSO_MANGLEID;
+ 	netdev->vlan_features |= hw_enc_features | NETIF_F_TSO_MANGLEID;
  
  	/* Write features and hw_features separately to avoid polluting
- 	 * with, or dropping, features that are set when we registgered.
+ 	 * with, or dropping, features that are set when we registered.
  	 */
- 	netdev->hw_features |= netdev->hw_enc_features;
+ 	hw_features = hw_enc_features;
  
- 	netdev->features |= netdev->hw_enc_features | I40EVF_VLAN_FEATURES;
- 	netdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;
+ 	netdev->hw_features |= hw_features;
  
- 	/* disable VLAN features if not supported */
- 	if (!(vfres->vf_offload_flags & I40E_VIRTCHNL_VF_OFFLOAD_VLAN))
- 		netdev->features ^= I40EVF_VLAN_FEATURES;
+ 	netdev->features |= hw_features | I40EVF_VLAN_FEATURES;
  
  	adapter->vsi.id = adapter->vsi_res->vsi_id;
  
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h b/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
index 974ba2baf6ea..8552192a5bde 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
@@ -163,7 +163,8 @@ struct i40e_virtchnl_vsi_resource {
 #define I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING	0x00020000
 #define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2	0x00040000
 #define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF		0X00080000
-#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00100000
+#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP		0X00100000
+#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00200000
 
 #define I40E_VF_BASE_MODE_OFFLOADS (I40E_VIRTCHNL_VF_OFFLOAD_L2 | \
 				    I40E_VIRTCHNL_VF_OFFLOAD_VLAN | \
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index ab4c7ffb8d61..f4b574154783 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@ -1462,6 +1462,13 @@ static int i40e_vc_get_vf_resources_msg(struct i40e_vf *vf, u8 *msg)
 				I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
 	}
 
+	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_ENCAP)
+		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_ENCAP;
+
+	if ((pf->flags & I40E_FLAG_OUTER_UDP_CSUM_CAPABLE) &&
+	    (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM))
+		vfres->vf_offload_flags |= I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;
+
 	if (vf->driver_caps & I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING) {
 		if (pf->flags & I40E_FLAG_MFP_ENABLED) {
 			dev_err(&pf->pdev->dev,
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h b/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
index f431fbc4a3e7..c5ad0388c3d5 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
@@ -163,7 +163,8 @@ struct i40e_virtchnl_vsi_resource {
 #define I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING	0x00020000
 #define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2	0x00040000
 #define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF		0X00080000
-#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00100000
+#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP		0X00100000
+#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00200000
 
 #define I40E_VF_BASE_MODE_OFFLOADS (I40E_VIRTCHNL_VF_OFFLOAD_L2 | \
 				    I40E_VIRTCHNL_VF_OFFLOAD_VLAN | \
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index 4bc2488bf709..c551a7ab19fb 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@ -159,7 +159,9 @@ int i40evf_send_vf_config_msg(struct i40evf_adapter *adapter)
 	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG |
 	       I40E_VIRTCHNL_VF_OFFLOAD_VLAN |
 	       I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR |
-	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2;
+	       I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2 |
+	       I40E_VIRTCHNL_VF_OFFLOAD_ENCAP |
+	       I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM;
 
 	adapter->current_op = I40E_VIRTCHNL_OP_GET_VF_RESOURCES;
 	adapter->aq_required &= ~I40EVF_FLAG_AQ_GET_CONFIG;
