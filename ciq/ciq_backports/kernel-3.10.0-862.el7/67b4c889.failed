[CIFS] Minor cleanup of xattr query function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] Minor cleanup of xattr query function (Leif Sahlberg) [1110709]
Rebuild_FUZZ: 91.36%
commit-author Steve French <smfrench@gmail.com>
commit 67b4c889cc835a2a6e2ff4e20544a33e37e2875d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/67b4c889.failed

Some minor cleanup of cifs query xattr functions (will also make
SMB3 xattr implementation cleaner as well).

	Signed-off-by: Steve French <steve.french@primarydata.com>
(cherry picked from commit 67b4c889cc835a2a6e2ff4e20544a33e37e2875d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/xattr.c
diff --cc fs/cifs/xattr.c
index 2e99ffdf4d21,3cb5c9e2d4e7..000000000000
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@@ -235,39 -212,61 +235,44 @@@ ssize_t cifs_getxattr(struct dentry *di
  
  	xid = get_xid();
  
 -	full_path = build_path_from_dentry(dentry);
 +	full_path = build_path_from_dentry(direntry);
  	if (full_path == NULL) {
  		rc = -ENOMEM;
 -		goto out;
 +		goto get_ea_exit;
  	}
 -
 +	/* return dos attributes as pseudo xattr */
  	/* return alt name if available as pseudo attr */
 -	switch (handler->flags) {
 -	case XATTR_USER:
 -		cifs_dbg(FYI, "%s:querying user xattr %s\n", __func__, name);
 -		if (strcmp(name, CIFS_XATTR_ATTRIB) == 0) {
 -			rc = cifs_attrib_get(dentry, inode, value, size);
 -			break;
 -		} else if (strcmp(name, CIFS_XATTR_CREATETIME) == 0) {
 -			rc = cifs_creation_time_get(dentry, inode, value, size);
 -			break;
 -		}
 -
 +	if (ea_name == NULL) {
 +		cifs_dbg(FYI, "Null xattr names not supported\n");
 +	} else if (strncmp(ea_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)
 +		   == 0) {
  		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
 -			goto out;
 +			goto get_ea_exit;
  
 +		if (strcmp(ea_name, CIFS_XATTR_DOS_ATTRIB) == 0) {
 +			cifs_dbg(FYI, "attempt to query cifs inode metadata\n");
 +			/* revalidate/getattr then populate from inode */
 +		} /* BB add else when above is implemented */
 +		ea_name += XATTR_USER_PREFIX_LEN; /* skip past user. prefix */
  		if (pTcon->ses->server->ops->query_all_EAs)
  			rc = pTcon->ses->server->ops->query_all_EAs(xid, pTcon,
++<<<<<<< HEAD
 +				full_path, ea_name, ea_value, buf_size,
 +				cifs_sb->local_nls, cifs_remap(cifs_sb));
 +	} else if (strncmp(ea_name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {
 +		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
 +			goto get_ea_exit;
++=======
+ 				full_path, name, value, size, cifs_sb);
+ 		break;
++>>>>>>> 67b4c889cc83 ([CIFS] Minor cleanup of xattr query function)
  
 -	case XATTR_CIFS_ACL: {
 -#ifdef CONFIG_CIFS_ACL
 -		u32 acllen;
 -		struct cifs_ntsd *pacl;
 -
 -		if (pTcon->ses->server->ops->get_acl == NULL)
 -			goto out; /* rc already EOPNOTSUPP */
 -
 -		pacl = pTcon->ses->server->ops->get_acl(cifs_sb,
 -				inode, full_path, &acllen);
 -		if (IS_ERR(pacl)) {
 -			rc = PTR_ERR(pacl);
 -			cifs_dbg(VFS, "%s: error %zd getting sec desc\n",
 -				 __func__, rc);
 -		} else {
 -			if (value) {
 -				if (acllen > size)
 -					acllen = -ERANGE;
 -				else
 -					memcpy(value, pacl, acllen);
 -			}
 -			rc = acllen;
 -			kfree(pacl);
 -		}
 -#endif  /* CONFIG_CIFS_ACL */
 -		break;
 -	}
 -
 -	case XATTR_ACL_ACCESS:
 +		ea_name += XATTR_OS2_PREFIX_LEN; /* skip past os2. prefix */
 +		if (pTcon->ses->server->ops->query_all_EAs)
 +			rc = pTcon->ses->server->ops->query_all_EAs(xid, pTcon,
 +				full_path, ea_name, ea_value, buf_size,
 +				cifs_sb->local_nls, cifs_remap(cifs_sb));
 +	} else if (strcmp(ea_name, XATTR_NAME_POSIX_ACL_ACCESS) == 0) {
  #ifdef CONFIG_CIFS_POSIX
  		if (sb->s_flags & MS_POSIXACL)
  			rc = CIFSSMBGetPosixACL(xid, pTcon, full_path,
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a6a7b3af79ed..261372f13369 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -415,7 +415,7 @@ struct smb_version_operations {
 	int (*validate_negotiate)(const unsigned int, struct cifs_tcon *);
 	ssize_t (*query_all_EAs)(const unsigned int, struct cifs_tcon *,
 			const unsigned char *, const unsigned char *, char *,
-			size_t, const struct nls_table *, int);
+			size_t, struct cifs_sb_info *);
 	int (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,
 			const char *, const void *, const __u16,
 			const struct nls_table *, int);
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
index 56e78412bf1f..905bab400521 100644
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -480,8 +480,7 @@ extern int CIFSSMBCopy(unsigned int xid,
 extern ssize_t CIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,
 			const unsigned char *searchName,
 			const unsigned char *ea_name, char *EAData,
-			size_t bufsize, const struct nls_table *nls_codepage,
-			int remap_special_chars);
+			size_t bufsize, struct cifs_sb_info *cifs_sb);
 extern int CIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,
 		const char *fileName, const char *ea_name,
 		const void *ea_value, const __u16 ea_value_len,
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 9752794d2e10..b7a2bc4cecd3 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -6079,11 +6079,13 @@ ssize_t
 CIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,
 		const unsigned char *searchName, const unsigned char *ea_name,
 		char *EAData, size_t buf_size,
-		const struct nls_table *nls_codepage, int remap)
+		struct cifs_sb_info *cifs_sb)
 {
 		/* BB assumes one setup word */
 	TRANSACTION2_QPI_REQ *pSMB = NULL;
 	TRANSACTION2_QPI_RSP *pSMBr = NULL;
+	int remap = cifs_remap(cifs_sb);
+	struct nls_table *nls_codepage = cifs_sb->local_nls;
 	int rc = 0;
 	int bytes_returned;
 	int list_len;
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index b24dc972c205..145925855d09 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -562,8 +562,7 @@ static int cifs_sfu_mode(struct cifs_fattr *fattr, const unsigned char *path,
 
 	rc = tcon->ses->server->ops->query_all_EAs(xid, tcon, path,
 			"SETFILEBITS", ea_value, 4 /* size of buf */,
-			cifs_sb->local_nls,
-			cifs_remap(cifs_sb));
+			cifs_sb);
 	cifs_put_tlink(tlink);
 	if (rc < 0)
 		return (int)rc;
* Unmerged path fs/cifs/xattr.c
