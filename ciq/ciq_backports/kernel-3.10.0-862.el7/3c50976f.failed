scsi: smartpqi: add lockup action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] smartpqi: add lockup action (Don Brace) [1457414]
Rebuild_FUZZ: 90.00%
commit-author Kevin Barnett <kevin.barnett@hpe.com>
commit 3c50976f33f30cf00baea9d518bd3e7ddd01ecc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3c50976f.failed

add support for actions to take when controller goes offline.

	Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3c50976f33f30cf00baea9d518bd3e7ddd01ecc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi_init.c
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index a3837a6f86ae,15bb8c1602b4..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -24,10 -24,11 +24,11 @@@
  #include <linux/sched.h>
  #include <linux/rtc.h>
  #include <linux/bcd.h>
+ #include <linux/reboot.h>
  #include <linux/cciss_ioctl.h>
 -#include <linux/blk-mq-pci.h>
  #include <scsi/scsi_host.h>
  #include <scsi/scsi_cmnd.h>
 +#include <scsi/scsi_tcq.h>
  #include <scsi/scsi_device.h>
  #include <scsi/scsi_eh.h>
  #include <scsi/scsi_transport_sas.h>
@@@ -5956,7 -6213,22 +6036,26 @@@ static void pqi_remove_ctrl(struct pqi_
  	pqi_free_ctrl_resources(ctrl_info);
  }
  
++<<<<<<< HEAD
 +static void pqi_print_ctrl_info(struct pci_dev *pdev,
++=======
+ static void pqi_perform_lockup_action(void)
+ {
+ 	switch (pqi_lockup_action) {
+ 	case PANIC:
+ 		panic("FATAL: Smart Family Controller lockup detected");
+ 		break;
+ 	case REBOOT:
+ 		emergency_restart();
+ 		break;
+ 	case NONE:
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void pqi_print_ctrl_info(struct pci_dev *pci_dev,
++>>>>>>> 3c50976f33f3 (scsi: smartpqi: add lockup action)
  	const struct pci_device_id *id)
  {
  	char *ctrl_description;
@@@ -6060,6 -6333,95 +6159,98 @@@ error
  		"unable to flush controller cache\n");
  }
  
++<<<<<<< HEAD
++=======
+ static void pqi_process_lockup_action_param(void)
+ {
+ 	unsigned int i;
+ 
+ 	if (!pqi_lockup_action_param)
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pqi_lockup_actions); i++) {
+ 		if (strcmp(pqi_lockup_action_param,
+ 			pqi_lockup_actions[i].name) == 0) {
+ 			pqi_lockup_action = pqi_lockup_actions[i].action;
+ 			return;
+ 		}
+ 	}
+ 
+ 	pr_warn("%s: invalid lockup action setting \"%s\" - supported settings: none, reboot, panic\n",
+ 		DRIVER_NAME_SHORT, pqi_lockup_action_param);
+ }
+ 
+ static void pqi_process_module_params(void)
+ {
+ 	pqi_process_lockup_action_param();
+ }
+ 
+ #if defined(CONFIG_PM)
+ 
+ static int pqi_suspend(struct pci_dev *pci_dev, pm_message_t state)
+ {
+ 	struct pqi_ctrl_info *ctrl_info;
+ 
+ 	ctrl_info = pci_get_drvdata(pci_dev);
+ 
+ 	pqi_disable_events(ctrl_info);
+ 	pqi_cancel_update_time_worker(ctrl_info);
+ 	pqi_cancel_rescan_worker(ctrl_info);
+ 	pqi_wait_until_scan_finished(ctrl_info);
+ 	pqi_wait_until_lun_reset_finished(ctrl_info);
+ 	pqi_flush_cache(ctrl_info);
+ 	pqi_ctrl_block_requests(ctrl_info);
+ 	pqi_ctrl_wait_until_quiesced(ctrl_info);
+ 	pqi_wait_until_inbound_queues_empty(ctrl_info);
+ 	pqi_ctrl_wait_for_pending_io(ctrl_info);
+ 	pqi_stop_heartbeat_timer(ctrl_info);
+ 
+ 	if (state.event == PM_EVENT_FREEZE)
+ 		return 0;
+ 
+ 	pci_save_state(pci_dev);
+ 	pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));
+ 
+ 	ctrl_info->controller_online = false;
+ 	ctrl_info->pqi_mode_enabled = false;
+ 
+ 	return 0;
+ }
+ 
+ static int pqi_resume(struct pci_dev *pci_dev)
+ {
+ 	int rc;
+ 	struct pqi_ctrl_info *ctrl_info;
+ 
+ 	ctrl_info = pci_get_drvdata(pci_dev);
+ 
+ 	if (pci_dev->current_state != PCI_D0) {
+ 		ctrl_info->max_hw_queue_index = 0;
+ 		pqi_free_interrupts(ctrl_info);
+ 		pqi_change_irq_mode(ctrl_info, IRQ_MODE_INTX);
+ 		rc = request_irq(pci_irq_vector(pci_dev, 0), pqi_irq_handler,
+ 			IRQF_SHARED, DRIVER_NAME_SHORT,
+ 			&ctrl_info->queue_groups[0]);
+ 		if (rc) {
+ 			dev_err(&ctrl_info->pci_dev->dev,
+ 				"irq %u init failed with error %d\n",
+ 				pci_dev->irq, rc);
+ 			return rc;
+ 		}
+ 		pqi_start_heartbeat_timer(ctrl_info);
+ 		pqi_ctrl_unblock_requests(ctrl_info);
+ 		return 0;
+ 	}
+ 
+ 	pci_set_power_state(pci_dev, PCI_D0);
+ 	pci_restore_state(pci_dev);
+ 
+ 	return pqi_ctrl_init_resume(ctrl_info);
+ }
+ 
+ #endif /* CONFIG_PM */
+ 
++>>>>>>> 3c50976f33f3 (scsi: smartpqi: add lockup action)
  /* Define the PCI IDs for the controllers that we support. */
  static const struct pci_device_id pqi_pci_id_table[] = {
  	{
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
