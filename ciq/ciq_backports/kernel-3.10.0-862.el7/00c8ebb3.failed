libceph: NULL deref on osdmap_apply_incremental() error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 00c8ebb360937bbc5da02929d62fcbf6a72801eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/00c8ebb3.failed

There are hidden gotos in the ceph_decode_* macros.  We need to set the
"err" variable on these error paths otherwise we end up returning
ERR_PTR(0) which is NULL.  It causes NULL dereferences in the callers.

Fixes: 6f428df47dae ("libceph: pg_upmap[_items] infrastructure")
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
[idryomov@gmail.com: similar bug in osdmap_decode(), changelog tweak]
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 00c8ebb360937bbc5da02929d62fcbf6a72801eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osdmap.c
diff --cc net/ceph/osdmap.c
index 0d8d639bdfdc,3ffc7a1fd8b1..000000000000
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@@ -1457,6 -1540,26 +1457,29 @@@ static int osdmap_decode(void **p, voi
  	if (err)
  		goto bad;
  
++<<<<<<< HEAD
++=======
+ 	*p += len;
+ 	if (struct_v >= 3) {
+ 		/* erasure_code_profiles */
+ 		ceph_decode_skip_map_of_map(p, end, string, string, string,
+ 					    e_inval);
+ 	}
+ 
+ 	if (struct_v >= 4) {
+ 		err = decode_pg_upmap(p, end, map);
+ 		if (err)
+ 			goto bad;
+ 
+ 		err = decode_pg_upmap_items(p, end, map);
+ 		if (err)
+ 			goto bad;
+ 	} else {
+ 		WARN_ON(!RB_EMPTY_ROOT(&map->pg_upmap));
+ 		WARN_ON(!RB_EMPTY_ROOT(&map->pg_upmap_items));
+ 	}
+ 
++>>>>>>> 00c8ebb36093 (libceph: NULL deref on osdmap_apply_incremental() error path)
  	/* ignore the rest */
  	*p = end;
  
@@@ -1719,6 -1822,32 +1742,35 @@@ struct ceph_osdmap *osdmap_apply_increm
  			goto bad;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (struct_v >= 3) {
+ 		/* new_erasure_code_profiles */
+ 		ceph_decode_skip_map_of_map(p, end, string, string, string,
+ 					    e_inval);
+ 		/* old_erasure_code_profiles */
+ 		ceph_decode_skip_set(p, end, string, e_inval);
+ 	}
+ 
+ 	if (struct_v >= 4) {
+ 		err = decode_new_pg_upmap(p, end, map);
+ 		if (err)
+ 			goto bad;
+ 
+ 		err = decode_old_pg_upmap(p, end, map);
+ 		if (err)
+ 			goto bad;
+ 
+ 		err = decode_new_pg_upmap_items(p, end, map);
+ 		if (err)
+ 			goto bad;
+ 
+ 		err = decode_old_pg_upmap_items(p, end, map);
+ 		if (err)
+ 			goto bad;
+ 	}
+ 
++>>>>>>> 00c8ebb36093 (libceph: NULL deref on osdmap_apply_incremental() error path)
  	/* ignore the rest */
  	*p = end;
  
* Unmerged path net/ceph/osdmap.c
