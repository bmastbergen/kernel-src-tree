nfp: don't keep count for free buffers delayed kick

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 9ed9ea7084f34fcb1d962a4fbd012fe8a2942df8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9ed9ea70.failed

We only kick RX free buffer queue controller every NFP_NET_FL_BATCH
(currently 16) entries.  This means that we will always kick the QC
when write ring index is divisable by NFP_NET_FL_BATCH.  There is
no need to keep counts.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9ed9ea7084f34fcb1d962a4fbd012fe8a2942df8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 600c79f39fe0,cb7114309656..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -298,11 -327,7 +298,14 @@@ struct nfp_net_rx_buf 
   * @rd_p:       FL/RX ring read pointer (free running)
   * @idx:        Ring index from Linux's perspective
   * @fl_qcidx:   Queue Controller Peripheral (QCP) queue index for the freelist
 + * @rx_qcidx:   Queue Controller Peripheral (QCP) queue index for the RX queue
   * @qcp_fl:     Pointer to base of the QCP freelist queue
++<<<<<<< HEAD
 + * @qcp_rx:     Pointer to base of the QCP RX queue
 + * @wr_ptr_add: Accumulated number of buffers to add to QCP write pointer
 + *              (used for free list batching)
++=======
++>>>>>>> 9ed9ea7084f3 (nfp: don't keep count for free buffers delayed kick)
   * @rxbufs:     Array of transmitted FL/RX buffers
   * @rxds:       Virtual address of FL/RX ring in host memory
   * @dma:        DMA address of the FL/RX ring
@@@ -317,13 -340,10 +320,17 @@@ struct nfp_net_rx_ring 
  	u32 wr_p;
  	u32 rd_p;
  
++<<<<<<< HEAD
 +	u16 idx;
 +	u16 wr_ptr_add;
++=======
+ 	u32 idx;
++>>>>>>> 9ed9ea7084f3 (nfp: don't keep count for free buffers delayed kick)
  
  	int fl_qcidx;
 +	int rx_qcidx;
  	u8 __iomem *qcp_fl;
 +	u8 __iomem *qcp_rx;
  
  	struct nfp_net_rx_buf *rxbufs;
  	struct nfp_net_rx_desc *rxds;
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7..a00677460fa7 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@ -1138,14 +1138,12 @@ static void nfp_net_rx_give_one(struct nfp_net_rx_ring *rx_ring,
 	nfp_desc_set_dma_addr(&rx_ring->rxds[wr_idx].fld, dma_addr);
 
 	rx_ring->wr_p++;
-	rx_ring->wr_ptr_add++;
-	if (rx_ring->wr_ptr_add >= NFP_NET_FL_BATCH) {
+	if (!(rx_ring->wr_p % NFP_NET_FL_BATCH)) {
 		/* Update write pointer of the freelist queue. Make
 		 * sure all writes are flushed before telling the hardware.
 		 */
 		wmb();
-		nfp_qcp_wr_ptr_add(rx_ring->qcp_fl, rx_ring->wr_ptr_add);
-		rx_ring->wr_ptr_add = 0;
+		nfp_qcp_wr_ptr_add(rx_ring->qcp_fl, NFP_NET_FL_BATCH);
 	}
 }
 
@@ -1171,7 +1169,6 @@ static void nfp_net_rx_ring_reset(struct nfp_net_rx_ring *rx_ring)
 	memset(rx_ring->rxds, 0, sizeof(*rx_ring->rxds) * rx_ring->cnt);
 	rx_ring->wr_p = 0;
 	rx_ring->rd_p = 0;
-	rx_ring->wr_ptr_add = 0;
 }
 
 /**
