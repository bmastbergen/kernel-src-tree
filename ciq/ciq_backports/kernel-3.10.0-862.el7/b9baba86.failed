KVM, pkeys: expose CPUID/CR4 to guest

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Huaitong Han <huaitong.han@intel.com>
commit b9baba861489041b37b54fc7ee0b0006b5327151
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b9baba86.failed

X86_FEATURE_PKU is referred to as "PKU" in the hardware documentation:
CPUID.7.0.ECX[3]:PKU. X86_FEATURE_OSPKE is software support for pkeys,
enumerated with CPUID.7.0.ECX[4]:OSPKE, and it reflects the setting of
CR4.PKE(bit 22).

This patch disables CPUID:PKU without ept, because pkeys is not yet
implemented for shadow paging.

	Signed-off-by: Huaitong Han <huaitong.han@intel.com>
	Reviewed-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b9baba861489041b37b54fc7ee0b0006b5327151)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
diff --cc arch/x86/kvm/cpuid.c
index 0031611e021e,8efb839948e5..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -358,25 -360,19 +368,28 @@@ static inline int __do_cpuid_ent(struc
  		F(PMM) | F(PMM_EN);
  
  	/* cpuid 7.0.ebx */
 -	const u32 kvm_cpuid_7_0_ebx_x86_features =
 +	const u32 kvm_supported_word9_x86_features =
  		F(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
  		F(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |
 -		F(ADX) | F(SMAP) | F(AVX512F) | F(AVX512PF) | F(AVX512ER) |
 -		F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(PCOMMIT);
 +		F(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |
 +		F(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |
 +		F(SHA_NI) | F(AVX512BW) | F(AVX512VL);
  
  	/* cpuid 0xD.1.eax */
 -	const u32 kvm_cpuid_D_1_eax_x86_features =
 -		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;
 +	const u32 kvm_supported_word10_x86_features =
 +		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1);
 +
 +	/* cpuid 7.0.ecx*/
 +	const u32 kvm_cpuid_7_0_ecx_x86_features =
 +		F(AVX512VBMI) | F(AVX512_VPOPCNTDQ);
 +
 +	/* cpuid 7.0.edx*/
 +	const u32 kvm_cpuid_7_0_edx_x86_features =
 +		KF(AVX512_4VNNIW) | KF(AVX512_4FMAPS);
  
+ 	/* cpuid 7.0.ecx*/
+ 	const u32 kvm_cpuid_7_0_ecx_x86_features = F(PKU) | 0 /*OSPKE*/;
+ 
  	/* all calls to cpuid_count() should be made on the same cpu */
  	get_cpu();
  
@@@ -456,14 -452,15 +469,26 @@@
  			entry->ebx |= F(TSC_ADJUST);
  			entry->ecx &= kvm_cpuid_7_0_ecx_x86_features;
  			cpuid_mask(&entry->ecx, CPUID_7_ECX);
++<<<<<<< HEAD
 +			entry->edx &= kvm_cpuid_7_0_edx_x86_features;
 +			entry->edx &= get_scattered_cpuid_leaf(7, 0, CPUID_EDX);
 +		} else {
 +			entry->ebx = 0;
 +			entry->ecx = 0;
 +			entry->edx = 0;
 +		}
 +		entry->eax = 0;
++=======
+ 			/* PKU is not yet implemented for shadow paging. */
+ 			if (!tdp_enabled)
+ 				entry->ecx &= ~F(PKU);
+ 		} else {
+ 			entry->ebx = 0;
+ 			entry->ecx = 0;
+ 		}
+ 		entry->eax = 0;
+ 		entry->edx = 0;
++>>>>>>> b9baba861489 (KVM, pkeys: expose CPUID/CR4 to guest)
  		break;
  	}
  	case 9:
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 98670a995e4c..3227101d3483 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -61,7 +61,8 @@
 			  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \
 			  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \
 			  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \
-			  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE | X86_CR4_SMAP))
+			  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE | X86_CR4_SMAP \
+			  | X86_CR4_PKE))
 
 #define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)
 
* Unmerged path arch/x86/kvm/cpuid.c
diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h
index 352d95b42afe..51ed3322d703 100644
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@ -79,6 +79,14 @@ static inline bool guest_cpuid_has_fsgsbase(struct kvm_vcpu *vcpu)
 	return best && (best->ebx & bit(X86_FEATURE_FSGSBASE));
 }
 
+static inline bool guest_cpuid_has_pku(struct kvm_vcpu *vcpu)
+{
+	struct kvm_cpuid_entry2 *best;
+
+	best = kvm_find_cpuid_entry(vcpu, 7, 0);
+	return best && (best->ecx & bit(X86_FEATURE_PKU));
+}
+
 static inline bool guest_cpuid_has_longmode(struct kvm_vcpu *vcpu)
 {
 	struct kvm_cpuid_entry2 *best;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index c4ed332ff031..3daa4a6a64f7 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -737,7 +737,7 @@ int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 {
 	unsigned long old_cr4 = kvm_read_cr4(vcpu);
 	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |
-				   X86_CR4_SMEP | X86_CR4_SMAP;
+				   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;
 
 	if (cr4 & CR4_RESERVED_BITS)
 		return 1;
@@ -754,6 +754,9 @@ int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 	if (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))
 		return 1;
 
+	if (!guest_cpuid_has_pku(vcpu) && (cr4 & X86_CR4_PKE))
+		return 1;
+
 	if (is_long_mode(vcpu)) {
 		if (!(cr4 & X86_CR4_PAE))
 			return 1;
@@ -779,7 +782,7 @@ int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 	    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))
 		kvm_mmu_reset_context(vcpu);
 
-	if ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)
+	if ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))
 		kvm_update_cpuid(vcpu);
 
 	return 0;
@@ -7206,7 +7209,7 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 
 	mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;
 	kvm_x86_ops->set_cr4(vcpu, sregs->cr4);
-	if (sregs->cr4 & X86_CR4_OSXSAVE)
+	if (sregs->cr4 & (X86_CR4_OSXSAVE | X86_CR4_PKE))
 		kvm_update_cpuid(vcpu);
 
 	idx = srcu_read_lock(&vcpu->kvm->srcu);
