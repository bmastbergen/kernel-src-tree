atlantic: fix iommu errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Pavel Belous <pavel.belous@aquantia.com>
commit c7545689244b50c562b1fbbc71905fba224c8a05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c7545689.failed

Call skb_frag_dma_map multiple times if tx length is greater than
device max and avoid processing tx ring until entire packet has been
sent.

	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: Pavel Belous <pavel.belous@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c7545689244b50c562b1fbbc71905fba224c8a05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ring.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ring.c
index c2f095db277a,0654e0c76bc2..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.c
@@@ -105,6 -104,38 +105,41 @@@ int aq_ring_init(struct aq_ring_s *self
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool aq_ring_dx_in_range(unsigned int h, unsigned int i,
+ 				       unsigned int t)
+ {
+ 	return (h < t) ? ((h < i) && (i < t)) : ((h < i) || (i < t));
+ }
+ 
+ void aq_ring_update_queue_state(struct aq_ring_s *ring)
+ {
+ 	if (aq_ring_avail_dx(ring) <= AQ_CFG_SKB_FRAGS_MAX)
+ 		aq_ring_queue_stop(ring);
+ 	else if (aq_ring_avail_dx(ring) > AQ_CFG_RESTART_DESC_THRES)
+ 		aq_ring_queue_wake(ring);
+ }
+ 
+ void aq_ring_queue_wake(struct aq_ring_s *ring)
+ {
+ 	struct net_device *ndev = aq_nic_get_ndev(ring->aq_nic);
+ 
+ 	if (__netif_subqueue_stopped(ndev, ring->idx)) {
+ 		netif_wake_subqueue(ndev, ring->idx);
+ 		ring->stats.tx.queue_restarts++;
+ 	}
+ }
+ 
+ void aq_ring_queue_stop(struct aq_ring_s *ring)
+ {
+ 	struct net_device *ndev = aq_nic_get_ndev(ring->aq_nic);
+ 
+ 	if (!__netif_subqueue_stopped(ndev, ring->idx))
+ 		netif_stop_subqueue(ndev, ring->idx);
+ }
+ 
++>>>>>>> c7545689244b (atlantic: fix iommu errors)
  void aq_ring_tx_clean(struct aq_ring_s *self)
  {
  	struct device *dev = aq_nic_get_dev(self->aq_nic);
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 315b49f79c74..87fb3a5f1259 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@ -476,6 +476,7 @@ static unsigned int aq_nic_map_skb(struct aq_nic_s *self,
 	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
 	unsigned int frag_count = 0U;
 	unsigned int dx = ring->sw_tail;
+	struct aq_ring_buff_s *first = NULL;
 	struct aq_ring_buff_s *dx_buff = &ring->buff_ring[dx];
 
 	if (unlikely(skb_is_gso(skb))) {
@@ -486,6 +487,7 @@ static unsigned int aq_nic_map_skb(struct aq_nic_s *self,
 		dx_buff->len_l4 = tcp_hdrlen(skb);
 		dx_buff->mss = skb_shinfo(skb)->gso_size;
 		dx_buff->is_txc = 1U;
+		dx_buff->eop_index = 0xffffU;
 
 		dx_buff->is_ipv6 =
 			(ip_hdr(skb)->version == 6) ? 1U : 0U;
@@ -505,6 +507,7 @@ static unsigned int aq_nic_map_skb(struct aq_nic_s *self,
 	if (unlikely(dma_mapping_error(aq_nic_get_dev(self), dx_buff->pa)))
 		goto exit;
 
+	first = dx_buff;
 	dx_buff->len_pkt = skb->len;
 	dx_buff->is_sop = 1U;
 	dx_buff->is_mapped = 1U;
@@ -533,40 +536,46 @@ static unsigned int aq_nic_map_skb(struct aq_nic_s *self,
 
 	for (; nr_frags--; ++frag_count) {
 		unsigned int frag_len = 0U;
+		unsigned int buff_offset = 0U;
+		unsigned int buff_size = 0U;
 		dma_addr_t frag_pa;
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[frag_count];
 
 		frag_len = skb_frag_size(frag);
-		frag_pa = skb_frag_dma_map(aq_nic_get_dev(self), frag, 0,
-					   frag_len, DMA_TO_DEVICE);
 
-		if (unlikely(dma_mapping_error(aq_nic_get_dev(self), frag_pa)))
-			goto mapping_error;
+		while (frag_len) {
+			if (frag_len > AQ_CFG_TX_FRAME_MAX)
+				buff_size = AQ_CFG_TX_FRAME_MAX;
+			else
+				buff_size = frag_len;
+
+			frag_pa = skb_frag_dma_map(aq_nic_get_dev(self),
+						   frag,
+						   buff_offset,
+						   buff_size,
+						   DMA_TO_DEVICE);
+
+			if (unlikely(dma_mapping_error(aq_nic_get_dev(self),
+						       frag_pa)))
+				goto mapping_error;
 
-		while (frag_len > AQ_CFG_TX_FRAME_MAX) {
 			dx = aq_ring_next_dx(ring, dx);
 			dx_buff = &ring->buff_ring[dx];
 
 			dx_buff->flags = 0U;
-			dx_buff->len = AQ_CFG_TX_FRAME_MAX;
+			dx_buff->len = buff_size;
 			dx_buff->pa = frag_pa;
 			dx_buff->is_mapped = 1U;
+			dx_buff->eop_index = 0xffffU;
+
+			frag_len -= buff_size;
+			buff_offset += buff_size;
 
-			frag_len -= AQ_CFG_TX_FRAME_MAX;
-			frag_pa += AQ_CFG_TX_FRAME_MAX;
 			++ret;
 		}
-
-		dx = aq_ring_next_dx(ring, dx);
-		dx_buff = &ring->buff_ring[dx];
-
-		dx_buff->flags = 0U;
-		dx_buff->len = frag_len;
-		dx_buff->pa = frag_pa;
-		dx_buff->is_mapped = 1U;
-		++ret;
 	}
 
+	first->eop_index = dx;
 	dx_buff->is_eop = 1U;
 	dx_buff->skb = skb;
 	goto exit;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ring.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_ring.h b/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
index 782176c5f4f8..5811b715b58a 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ring.h
@@ -65,7 +65,7 @@ struct __packed aq_ring_buff_s {
 	};
 	union {
 		struct {
-			u32 len:16;
+			u16 len;
 			u32 is_ip_cso:1;
 			u32 is_udp_cso:1;
 			u32 is_tcp_cso:1;
@@ -77,8 +77,10 @@ struct __packed aq_ring_buff_s {
 			u32 is_cleaned:1;
 			u32 is_error:1;
 			u32 rsvd3:6;
+			u16 eop_index;
+			u16 rsvd4;
 		};
-		u32 flags;
+		u64 flags;
 	};
 };
 
