IB/hfi1: Search shared contexts on the opened device, not all devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 5fbded483c699823a7cca001a5c27ddc4d73370f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5fbded48.failed

The search for available shared contexts walks each registered hfi1
device.  This search is too broad because other devices may not
be on the same fabric, and using its contexts could cause unexpected
behavior.

Removed walking the list of devices, limiting the search to the opened
device.  With the device walk removed, the hfi1_devdata (dd) is not
available. Added it to the hfi1_filedata for reference.

With this change, hfi1_count_units() was rendered obsolete and was
removed.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 5fbded483c699823a7cca001a5c27ddc4d73370f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/file_ops.c
#	drivers/infiniband/hw/hfi1/hfi.h
diff --cc drivers/infiniband/hw/hfi1/file_ops.c
index 47a09c151236,9574fc4722ff..000000000000
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@@ -70,31 -70,37 +70,59 @@@
  /*
   * File operation functions
   */
 -static int hfi1_file_open(struct inode *inode, struct file *fp);
 -static int hfi1_file_close(struct inode *inode, struct file *fp);
 -static ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from);
 -static unsigned int hfi1_poll(struct file *fp, struct poll_table_struct *pt);
 -static int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma);
 -
 +static int hfi1_file_open(struct inode *, struct file *);
 +static int hfi1_file_close(struct inode *, struct file *);
 +static ssize_t hfi1_aio_write(struct kiocb *, const struct iovec *,
 +			      unsigned long, loff_t);
 +static unsigned int hfi1_poll(struct file *, struct poll_table_struct *);
 +static int hfi1_file_mmap(struct file *, struct vm_area_struct *);
 +
++<<<<<<< HEAD
 +static u64 kvirt_to_phys(void *);
 +static int assign_ctxt(struct file *, struct hfi1_user_info *);
 +static int init_subctxts(struct hfi1_ctxtdata *, const struct hfi1_user_info *);
 +static int user_init(struct file *);
 +static int get_ctxt_info(struct file *, void __user *, __u32);
 +static int get_base_info(struct file *, void __user *, __u32);
 +static int setup_ctxt(struct file *);
 +static int setup_subctxt(struct hfi1_ctxtdata *);
 +static int get_user_context(struct file *, struct hfi1_user_info *, int);
 +static int find_shared_ctxt(struct file *, const struct hfi1_user_info *);
 +static int allocate_ctxt(struct file *, struct hfi1_devdata *,
 +			 struct hfi1_user_info *);
 +static unsigned int poll_urgent(struct file *, struct poll_table_struct *);
 +static unsigned int poll_next(struct file *, struct poll_table_struct *);
 +static int user_event_ack(struct hfi1_ctxtdata *, int, unsigned long);
 +static int set_ctxt_pkey(struct hfi1_ctxtdata *, unsigned, u16);
 +static int manage_rcvq(struct hfi1_ctxtdata *, unsigned, int);
 +static int vma_fault(struct vm_area_struct *, struct vm_fault *);
++=======
+ static u64 kvirt_to_phys(void *addr);
+ static int assign_ctxt(struct hfi1_filedata *fd, struct hfi1_user_info *uinfo);
+ static int init_subctxts(struct hfi1_ctxtdata *uctxt,
+ 			 const struct hfi1_user_info *uinfo);
+ static int user_init(struct hfi1_filedata *fd);
+ static int get_ctxt_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int get_base_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int setup_ctxt(struct hfi1_filedata *fd);
+ static int setup_subctxt(struct hfi1_ctxtdata *uctxt);
+ 
+ static int find_shared_ctxt(struct hfi1_filedata *fd,
+ 			    const struct hfi1_user_info *uinfo);
+ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
+ 			 struct hfi1_user_info *uinfo);
+ static unsigned int poll_urgent(struct file *fp, struct poll_table_struct *pt);
+ static unsigned int poll_next(struct file *fp, struct poll_table_struct *pt);
+ static int user_event_ack(struct hfi1_ctxtdata *uctxt, int subctxt,
+ 			  unsigned long events);
+ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
+ 			 u16 pkey);
+ static int manage_rcvq(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
+ 		       int start_stop);
+ static int vma_fault(struct vm_fault *vmf);
++>>>>>>> 5fbded483c69 (IB/hfi1: Search shared contexts on the opened device, not all devices)
  static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
  			    unsigned long arg);
  
@@@ -187,7 -196,8 +218,12 @@@ static int hfi1_file_open(struct inode 
  	if (fd) {
  		fd->rec_cpu_num = -1; /* no cpu affinity by default */
  		fd->mm = current->mm;
++<<<<<<< HEAD
 +		atomic_inc(&fd->mm->mm_count);
++=======
+ 		mmgrab(fd->mm);
+ 		fd->dd = dd;
++>>>>>>> 5fbded483c69 (IB/hfi1: Search shared contexts on the opened device, not all devices)
  		fp->private_data = fd;
  	} else {
  		fp->private_data = NULL;
@@@ -230,16 -240,16 +266,16 @@@ static long hfi1_file_ioctl(struct fil
  				   sizeof(uinfo)))
  			return -EFAULT;
  
- 		ret = assign_ctxt(fp, &uinfo);
+ 		ret = assign_ctxt(fd, &uinfo);
  		if (ret < 0)
  			return ret;
 -		ret = setup_ctxt(fd);
 +		ret = setup_ctxt(fp);
  		if (ret)
  			return ret;
 -		ret = user_init(fd);
 +		ret = user_init(fp);
  		break;
  	case HFI1_IOCTL_CTXT_INFO:
 -		ret = get_ctxt_info(fd, (void __user *)(unsigned long)arg,
 +		ret = get_ctxt_info(fp, (void __user *)(unsigned long)arg,
  				    sizeof(struct hfi1_ctxt_info));
  		break;
  	case HFI1_IOCTL_USER_INFO:
@@@ -856,9 -866,7 +892,13 @@@ static int assign_ctxt(struct hfi1_file
  	mutex_lock(&hfi1_mutex);
  	/* First, lets check if we need to setup a shared context? */
  	if (uinfo->subctxt_cnt) {
++<<<<<<< HEAD
 +		struct hfi1_filedata *fd = fp->private_data;
 +
 +		ret = find_shared_ctxt(fp, uinfo);
++=======
+ 		ret = find_shared_ctxt(fd, uinfo);
++>>>>>>> 5fbded483c69 (IB/hfi1: Search shared contexts on the opened device, not all devices)
  		if (ret < 0)
  			goto done_unlock;
  		if (ret) {
@@@ -871,96 -879,59 +911,98 @@@
  	 * We execute the following block if we couldn't find a
  	 * shared context or if context sharing is not required.
  	 */
++<<<<<<< HEAD
 +	if (!ret) {
 +		i_minor = iminor(file_inode(fp)) - HFI1_USER_MINOR_BASE;
 +		ret = get_user_context(fp, uinfo, i_minor);
 +	}
++=======
+ 	if (!ret)
+ 		ret = allocate_ctxt(fd, fd->dd, uinfo);
+ 
++>>>>>>> 5fbded483c69 (IB/hfi1: Search shared contexts on the opened device, not all devices)
  done_unlock:
  	mutex_unlock(&hfi1_mutex);
  done:
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int get_user_context(struct file *fp, struct hfi1_user_info *uinfo,
 +			    int devno)
 +{
 +	struct hfi1_devdata *dd = NULL;
 +	int devmax, npresent, nup;
 +
 +	devmax = hfi1_count_units(&npresent, &nup);
 +	if (!npresent)
 +		return -ENXIO;
 +
 +	if (!nup)
 +		return -ENETDOWN;
 +
 +	dd = hfi1_lookup(devno);
 +	if (!dd)
 +		return -ENODEV;
 +	else if (!dd->freectxts)
 +		return -EBUSY;
 +
 +	return allocate_ctxt(fp, dd, uinfo);
 +}
 +
 +static int find_shared_ctxt(struct file *fp,
 +			    const struct hfi1_user_info *uinfo)
 +{
 +	int devmax, ndev, i;
 +	int ret = 0;
 +	struct hfi1_filedata *fd = fp->private_data;
++=======
+ static int find_shared_ctxt(struct hfi1_filedata *fd,
+ 			    const struct hfi1_user_info *uinfo)
+ {
+ 	int i;
+ 	struct hfi1_devdata *dd = fd->dd;
++>>>>>>> 5fbded483c69 (IB/hfi1: Search shared contexts on the opened device, not all devices)
  
- 	devmax = hfi1_count_units(NULL, NULL);
+ 	for (i = dd->first_dyn_alloc_ctxt; i < dd->num_rcv_contexts; i++) {
+ 		struct hfi1_ctxtdata *uctxt = dd->rcd[i];
  
- 	for (ndev = 0; ndev < devmax; ndev++) {
- 		struct hfi1_devdata *dd = hfi1_lookup(ndev);
+ 		/* Skip ctxts which are not yet open */
+ 		if (!uctxt || !uctxt->cnt)
+ 			continue;
  
- 		if (!(dd && (dd->flags & HFI1_PRESENT) && dd->kregbase))
+ 		/* Skip dynamically allocted kernel contexts */
+ 		if (uctxt->sc && (uctxt->sc->type == SC_KERNEL))
  			continue;
- 		for (i = dd->first_dyn_alloc_ctxt;
- 		     i < dd->num_rcv_contexts; i++) {
- 			struct hfi1_ctxtdata *uctxt = dd->rcd[i];
- 
- 			/* Skip ctxts which are not yet open */
- 			if (!uctxt || !uctxt->cnt)
- 				continue;
- 
- 			/* Skip dynamically allocted kernel contexts */
- 			if (uctxt->sc && (uctxt->sc->type == SC_KERNEL))
- 				continue;
- 
- 			/* Skip ctxt if it doesn't match the requested one */
- 			if (memcmp(uctxt->uuid, uinfo->uuid,
- 				   sizeof(uctxt->uuid)) ||
- 			    uctxt->jkey != generate_jkey(current_uid()) ||
- 			    uctxt->subctxt_id != uinfo->subctxt_id ||
- 			    uctxt->subctxt_cnt != uinfo->subctxt_cnt)
- 				continue;
- 
- 			/* Verify the sharing process matches the master */
- 			if (uctxt->userversion != uinfo->userversion ||
- 			    uctxt->cnt >= uctxt->subctxt_cnt) {
- 				ret = -EINVAL;
- 				goto done;
- 			}
- 			fd->uctxt = uctxt;
- 			fd->subctxt  = uctxt->cnt++;
- 			uctxt->active_slaves |= 1 << fd->subctxt;
- 			ret = 1;
- 			goto done;
+ 
+ 		/* Skip ctxt if it doesn't match the requested one */
+ 		if (memcmp(uctxt->uuid, uinfo->uuid,
+ 			   sizeof(uctxt->uuid)) ||
+ 		    uctxt->jkey != generate_jkey(current_uid()) ||
+ 		    uctxt->subctxt_id != uinfo->subctxt_id ||
+ 		    uctxt->subctxt_cnt != uinfo->subctxt_cnt)
+ 			continue;
+ 
+ 		/* Verify the sharing process matches the master */
+ 		if (uctxt->userversion != uinfo->userversion ||
+ 		    uctxt->cnt >= uctxt->subctxt_cnt) {
+ 			return -EINVAL;
  		}
+ 		fd->uctxt = uctxt;
+ 		fd->subctxt  = uctxt->cnt++;
+ 		uctxt->active_slaves |= 1 << fd->subctxt;
+ 		return 1;
  	}
  
- done:
- 	return ret;
+ 	return 0;
  }
  
 -static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
 +static int allocate_ctxt(struct file *fp, struct hfi1_devdata *dd,
  			 struct hfi1_user_info *uinfo)
  {
 +	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt;
- 	unsigned ctxt;
+ 	unsigned int ctxt;
  	int ret, numa;
  
  	if (dd->flags & HFI1_FROZEN) {
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index b1aefd5ddffe,e0c4c5ed7721..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -1271,12 -1264,11 +1272,16 @@@ struct hfi1_devdata *hfi1_lookup(int un
  extern u32 hfi1_cpulist_count;
  extern unsigned long *hfi1_cpulist;
  
++<<<<<<< HEAD
 +int hfi1_init(struct hfi1_devdata *, int);
 +int hfi1_count_units(int *npresentp, int *nupp);
++=======
+ int hfi1_init(struct hfi1_devdata *dd, int reinit);
++>>>>>>> 5fbded483c69 (IB/hfi1: Search shared contexts on the opened device, not all devices)
  int hfi1_count_active_units(void);
  
 -int hfi1_diag_add(struct hfi1_devdata *dd);
 -void hfi1_diag_remove(struct hfi1_devdata *dd);
 +int hfi1_diag_add(struct hfi1_devdata *);
 +void hfi1_diag_remove(struct hfi1_devdata *);
  void handle_linkup_change(struct hfi1_devdata *dd, u32 linkup);
  
  void handle_user_interrupt(struct hfi1_ctxtdata *rcd);
diff --git a/drivers/infiniband/hw/hfi1/driver.c b/drivers/infiniband/hw/hfi1/driver.c
index 500b129ed565..316811ea1880 100644
--- a/drivers/infiniband/hw/hfi1/driver.c
+++ b/drivers/infiniband/hw/hfi1/driver.c
@@ -210,42 +210,6 @@ int hfi1_count_active_units(void)
 	return nunits_active;
 }
 
-/*
- * Return count of all units, optionally return in arguments
- * the number of usable (present) units, and the number of
- * ports that are up.
- */
-int hfi1_count_units(int *npresentp, int *nupp)
-{
-	int nunits = 0, npresent = 0, nup = 0;
-	struct hfi1_devdata *dd;
-	unsigned long flags;
-	int pidx;
-	struct hfi1_pportdata *ppd;
-
-	spin_lock_irqsave(&hfi1_devs_lock, flags);
-
-	list_for_each_entry(dd, &hfi1_dev_list, list) {
-		nunits++;
-		if ((dd->flags & HFI1_PRESENT) && dd->kregbase)
-			npresent++;
-		for (pidx = 0; pidx < dd->num_pports; ++pidx) {
-			ppd = dd->pport + pidx;
-			if (ppd->lid && ppd->linkup)
-				nup++;
-		}
-	}
-
-	spin_unlock_irqrestore(&hfi1_devs_lock, flags);
-
-	if (npresentp)
-		*npresentp = npresent;
-	if (nupp)
-		*nupp = nup;
-
-	return nunits;
-}
-
 /*
  * Get address of eager buffer from it's index (allocated in chunks, not
  * contiguous).
* Unmerged path drivers/infiniband/hw/hfi1/file_ops.c
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
