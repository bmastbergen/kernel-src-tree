net: ping: check minimum size on ICMP header length

jira LE-1907
cve CVE-2016-8399
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] ping: check minimum size on ICMP header length (Matteo Croce) [1481573] {CVE-2016-8399}
Rebuild_FUZZ: 94.85%
commit-author Kees Cook <keescook@chromium.org>
commit 0eab121ef8750a5c8637d51534d5e9143fb0633f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0eab121e.failed

Prior to commit c0371da6047a ("put iov_iter into msghdr") in v3.19, there
was no check that the iovec contained enough bytes for an ICMP header,
and the read loop would walk across neighboring stack contents. Since the
iov_iter conversion, bad arguments are noticed, but the returned error is
EFAULT. Returning EINVAL is a clearer error and also solves the problem
prior to v3.19.

This was found using trinity with KASAN on v3.18:

BUG: KASAN: stack-out-of-bounds in memcpy_fromiovec+0x60/0x114 at addr ffffffc071077da0
Read of size 8 by task trinity-c2/9623
page:ffffffbe034b9a08 count:0 mapcount:0 mapping:          (null) index:0x0
flags: 0x0()
page dumped because: kasan: bad access detected
CPU: 0 PID: 9623 Comm: trinity-c2 Tainted: G    BU         3.18.0-dirty #15
Hardware name: Google Tegra210 Smaug Rev 1,3+ (DT)
Call trace:
[<ffffffc000209c98>] dump_backtrace+0x0/0x1ac arch/arm64/kernel/traps.c:90
[<ffffffc000209e54>] show_stack+0x10/0x1c arch/arm64/kernel/traps.c:171
[<     inline     >] __dump_stack lib/dump_stack.c:15
[<ffffffc000f18dc4>] dump_stack+0x7c/0xd0 lib/dump_stack.c:50
[<     inline     >] print_address_description mm/kasan/report.c:147
[<     inline     >] kasan_report_error mm/kasan/report.c:236
[<ffffffc000373dcc>] kasan_report+0x380/0x4b8 mm/kasan/report.c:259
[<     inline     >] check_memory_region mm/kasan/kasan.c:264
[<ffffffc00037352c>] __asan_load8+0x20/0x70 mm/kasan/kasan.c:507
[<ffffffc0005b9624>] memcpy_fromiovec+0x5c/0x114 lib/iovec.c:15
[<     inline     >] memcpy_from_msg include/linux/skbuff.h:2667
[<ffffffc000ddeba0>] ping_common_sendmsg+0x50/0x108 net/ipv4/ping.c:674
[<ffffffc000dded30>] ping_v4_sendmsg+0xd8/0x698 net/ipv4/ping.c:714
[<ffffffc000dc91dc>] inet_sendmsg+0xe0/0x12c net/ipv4/af_inet.c:749
[<     inline     >] __sock_sendmsg_nosec net/socket.c:624
[<     inline     >] __sock_sendmsg net/socket.c:632
[<ffffffc000cab61c>] sock_sendmsg+0x124/0x164 net/socket.c:643
[<     inline     >] SYSC_sendto net/socket.c:1797
[<ffffffc000cad270>] SyS_sendto+0x178/0x1d8 net/socket.c:1761

CVE-2016-8399

	Reported-by: Qidan He <i@flanker017.me>
Fixes: c319b4d76b9e ("net: ipv4: add IPPROTO_ICMP socket kind")
	Cc: stable@vger.kernel.org
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0eab121ef8750a5c8637d51534d5e9143fb0633f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ping.c
diff --cc net/ipv4/ping.c
index b242283a3f00,96b8e2b95731..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -460,8 -650,52 +460,57 @@@ static int ping_push_pending_frames(str
  	return ip_push_pending_frames(sk, fl4);
  }
  
++<<<<<<< HEAD
 +static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 +			size_t len)
++=======
+ int ping_common_sendmsg(int family, struct msghdr *msg, size_t len,
+ 			void *user_icmph, size_t icmph_len) {
+ 	u8 type, code;
+ 
+ 	if (len > 0xFFFF)
+ 		return -EMSGSIZE;
+ 
+ 	/* Must have at least a full ICMP header. */
+ 	if (len < icmph_len)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 *	Check the flags.
+ 	 */
+ 
+ 	/* Mirror BSD error message compatibility */
+ 	if (msg->msg_flags & MSG_OOB)
+ 		return -EOPNOTSUPP;
+ 
+ 	/*
+ 	 *	Fetch the ICMP header provided by the userland.
+ 	 *	iovec is modified! The ICMP header is consumed.
+ 	 */
+ 	if (memcpy_from_msg(user_icmph, msg, icmph_len))
+ 		return -EFAULT;
+ 
+ 	if (family == AF_INET) {
+ 		type = ((struct icmphdr *) user_icmph)->type;
+ 		code = ((struct icmphdr *) user_icmph)->code;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (family == AF_INET6) {
+ 		type = ((struct icmp6hdr *) user_icmph)->icmp6_type;
+ 		code = ((struct icmp6hdr *) user_icmph)->icmp6_code;
+ #endif
+ 	} else {
+ 		BUG();
+ 	}
+ 
+ 	if (!ping_supported(family, type, code))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(ping_common_sendmsg);
+ 
+ static int ping_v4_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
++>>>>>>> 0eab121ef875 (net: ping: check minimum size on ICMP header length)
  {
  	struct net *net = sock_net(sk);
  	struct flowi4 fl4;
* Unmerged path net/ipv4/ping.c
