dmaengine: dw: fix regression in dw_probe() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: dmaengine: dw: fix regression in dw_probe() function (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 94.55%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 8be4f523b48087765defd18483c66b268b3286e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8be4f523.failed

The commit dbde5c29 "dw_dmac: use devm_* functions to simplify code" turns
probe function to use devm_* helpers and simultaneously brings a regression.

We have to 1) call clk_disable_unprepare() on error path, and 2) check error
code of clk_enable_prepare(). First part was done in the original code, second
one is an update.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit 8be4f523b48087765defd18483c66b268b3286e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dw_dmac.c
diff --cc drivers/dma/dw_dmac.c
index 5d0ba000e772,d539019fbe60..000000000000
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@@ -1666,37 -1486,31 +1666,54 @@@ static int dw_probe(struct platform_dev
  	int			err;
  	int			i;
  
 -	dw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);
 -	if (!dw)
 -		return -ENOMEM;
 +	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +	if (!io)
 +		return -EINVAL;
  
 -	dw->regs = chip->regs;
 -	chip->dw = dw;
 +	irq = platform_get_irq(pdev, 0);
 +	if (irq < 0)
 +		return irq;
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	regs = devm_ioremap_resource(&pdev->dev, io);
 +	if (IS_ERR(regs))
 +		return PTR_ERR(regs);
++=======
+ 	dw->clk = devm_clk_get(chip->dev, "hclk");
+ 	if (IS_ERR(dw->clk))
+ 		return PTR_ERR(dw->clk);
+ 	err = clk_prepare_enable(dw->clk);
+ 	if (err)
+ 		return err;
++>>>>>>> 8be4f523b480 (dmaengine: dw: fix regression in dw_probe() function):drivers/dma/dw/core.c
  
 -	dw_params = dma_read_byaddr(chip->regs, DW_PARAMS);
 +	/* Apply default dma_mask if needed */
 +	if (!pdev->dev.dma_mask) {
 +		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
 +		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 +	}
 +
 +	dw_params = dma_read_byaddr(regs, DW_PARAMS);
  	autocfg = dw_params >> DW_PARAMS_EN & 0x1;
  
 -	dev_dbg(chip->dev, "DW_PARAMS: 0x%08x\n", dw_params);
 +	dev_dbg(&pdev->dev, "DW_PARAMS: 0x%08x\n", dw_params);
 +
 +	pdata = dev_get_platdata(&pdev->dev);
 +	if (!pdata)
 +		pdata = dw_dma_parse_dt(pdev);
  
  	if (!pdata && autocfg) {
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 +		if (!pdata)
 +			return -ENOMEM;
++=======
+ 		pdata = devm_kzalloc(chip->dev, sizeof(*pdata), GFP_KERNEL);
+ 		if (!pdata) {
+ 			err = -ENOMEM;
+ 			goto err_pdata;
+ 		}
++>>>>>>> 8be4f523b480 (dmaengine: dw: fix regression in dw_probe() function):drivers/dma/dw/core.c
  
  		/* Fill platform data with the default values */
  		pdata->is_private = true;
@@@ -1710,17 -1526,12 +1729,26 @@@
  	else
  		nr_channels = pdata->nr_channels;
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	size = sizeof(struct dw_dma) + nr_channels * sizeof(struct dw_dma_chan);
 +	dw = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
 +	if (!dw)
 +		return -ENOMEM;
++=======
+ 	dw->chan = devm_kcalloc(chip->dev, nr_channels, sizeof(*dw->chan),
+ 				GFP_KERNEL);
+ 	if (!dw->chan) {
+ 		err = -ENOMEM;
+ 		goto err_pdata;
+ 	}
++>>>>>>> 8be4f523b480 (dmaengine: dw: fix regression in dw_probe() function):drivers/dma/dw/core.c
 +
 +	dw->clk = devm_clk_get(&pdev->dev, "hclk");
 +	if (IS_ERR(dw->clk))
 +		return PTR_ERR(dw->clk);
 +	clk_prepare_enable(dw->clk);
 +
 +	dw->regs = regs;
  
  	/* Get hardware configuration parameters */
  	if (autocfg) {
@@@ -1745,23 -1556,22 +1773,37 @@@
  	/* Disable BLOCK interrupts as well */
  	channel_clear_bit(dw, MASK.BLOCK, dw->all_chan_mask);
  
 +	err = devm_request_irq(&pdev->dev, irq, dw_dma_interrupt, 0,
 +			       "dw_dmac", dw);
 +	if (err)
 +		return err;
 +
 +	platform_set_drvdata(pdev, dw);
 +
  	/* Create a pool of consistent memory blocks for hardware descriptors */
 -	dw->desc_pool = dmam_pool_create("dw_dmac_desc_pool", chip->dev,
 +	dw->desc_pool = dmam_pool_create("dw_dmac_desc_pool", &pdev->dev,
  					 sizeof(struct dw_desc), 4, 0);
  	if (!dw->desc_pool) {
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +		dev_err(&pdev->dev, "No memory for descriptors dma pool\n");
 +		return -ENOMEM;
++=======
+ 		dev_err(chip->dev, "No memory for descriptors dma pool\n");
+ 		err = -ENOMEM;
+ 		goto err_pdata;
++>>>>>>> 8be4f523b480 (dmaengine: dw: fix regression in dw_probe() function):drivers/dma/dw/core.c
  	}
  
  	tasklet_init(&dw->tasklet, dw_dma_tasklet, (unsigned long)dw);
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
++=======
+ 	err = request_irq(chip->irq, dw_dma_interrupt, IRQF_SHARED,
+ 			  "dw_dmac", dw);
+ 	if (err)
+ 		goto err_pdata;
+ 
++>>>>>>> 8be4f523b480 (dmaengine: dw: fix regression in dw_probe() function):drivers/dma/dw/core.c
  	INIT_LIST_HEAD(&dw->dma.channels);
  	for (i = 0; i < nr_channels; i++) {
  		struct dw_dma_chan	*dwc = &dw->chan[i];
@@@ -1854,27 -1664,19 +1896,31 @@@
  
  	dma_async_device_register(&dw->dma);
  
 +	if (pdev->dev.of_node) {
 +		err = of_dma_controller_register(pdev->dev.of_node,
 +						 dw_dma_of_xlate, dw);
 +		if (err)
 +			dev_err(&pdev->dev,
 +				"could not register of_dma_controller\n");
 +	}
 +
 +	if (ACPI_HANDLE(&pdev->dev))
 +		dw_dma_acpi_controller_register(dw);
 +
  	return 0;
+ 
+ err_pdata:
+ 	clk_disable_unprepare(dw->clk);
+ 	return err;
  }
 -EXPORT_SYMBOL_GPL(dw_dma_probe);
  
 -int dw_dma_remove(struct dw_dma_chip *chip)
 +static int dw_remove(struct platform_device *pdev)
  {
 -	struct dw_dma		*dw = chip->dw;
 +	struct dw_dma		*dw = platform_get_drvdata(pdev);
  	struct dw_dma_chan	*dwc, *_dwc;
  
 +	if (pdev->dev.of_node)
 +		of_dma_controller_free(pdev->dev.of_node);
  	dw_dma_off(dw);
  	dma_async_device_unregister(&dw->dma);
  
@@@ -1886,12 -1689,15 +1932,14 @@@
  		channel_clear_bit(dw, CH_EN, dwc->mask);
  	}
  
+ 	clk_disable_unprepare(dw->clk);
+ 
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(dw_dma_remove);
  
 -void dw_dma_shutdown(struct dw_dma_chip *chip)
 +static void dw_shutdown(struct platform_device *pdev)
  {
 -	struct dw_dma *dw = chip->dw;
 +	struct dw_dma	*dw = platform_get_drvdata(pdev);
  
  	dw_dma_off(dw);
  	clk_disable_unprepare(dw->clk);
* Unmerged path drivers/dma/dw_dmac.c
