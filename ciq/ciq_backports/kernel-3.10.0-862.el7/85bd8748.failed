ALSA: x86: Support S32 format

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 85bd8748ca23a25f6dc56154d9a61d87ae07a807
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/85bd8748.failed

The hardware has the support for the left-aligned 24bit format in
32bit packet.  This corresponds to S32 format in ALSA.  We need to set
the msbits restriction as well to inform user-space that only MSB
24bit are available.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 85bd8748ca23a25f6dc56154d9a61d87ae07a807)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,e8f8be2f590b..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -127,11 -130,13 +127,18 @@@ static const struct channel_map_table m
  };
  
  /* hardware capability structure */
 -static const struct snd_pcm_hardware had_pcm_hardware = {
 +static const struct snd_pcm_hardware snd_intel_hadstream = {
  	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
  		SNDRV_PCM_INFO_MMAP |
++<<<<<<< HEAD
 +		SNDRV_PCM_INFO_MMAP_VALID),
 +	.formats = SNDRV_PCM_FMTBIT_S24,
++=======
+ 		SNDRV_PCM_INFO_MMAP_VALID |
+ 		SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),
+ 	.formats = (SNDRV_PCM_FMTBIT_S24_LE |
+ 		    SNDRV_PCM_FMTBIT_S32_LE),
++>>>>>>> 85bd8748ca23 (ALSA: x86: Support S32 format)
  	.rates = SNDRV_PCM_RATE_32000 |
  		SNDRV_PCM_RATE_44100 |
  		SNDRV_PCM_RATE_48000 |
@@@ -284,18 -247,15 +291,24 @@@ static void snd_intelhad_reset_audio(st
  static int had_prog_status_reg(struct snd_pcm_substream *substream,
  			struct snd_intelhad *intelhaddata)
  {
++<<<<<<< HEAD
 +	union aud_cfg cfg_val = {.cfg_regval = 0};
 +	union aud_ch_status_0 ch_stat0 = {.status_0_regval = 0};
 +	union aud_ch_status_1 ch_stat1 = {.status_1_regval = 0};
 +	int format;
++=======
+ 	union aud_cfg cfg_val = {.regval = 0};
+ 	union aud_ch_status_0 ch_stat0 = {.regval = 0};
+ 	union aud_ch_status_1 ch_stat1 = {.regval = 0};
++>>>>>>> 85bd8748ca23 (ALSA: x86: Support S32 format)
  
 -	ch_stat0.regx.lpcm_id = (intelhaddata->aes_bits &
 -					  IEC958_AES0_NONAUDIO) >> 1;
 -	ch_stat0.regx.clk_acc = (intelhaddata->aes_bits &
 -					  IEC958_AES3_CON_CLOCK) >> 4;
 -	cfg_val.regx.val_bit = ch_stat0.regx.lpcm_id;
 +	pr_debug("Entry %s\n", __func__);
 +
 +	ch_stat0.status_0_regx.lpcm_id = (intelhaddata->aes_bits &
 +						IEC958_AES0_NONAUDIO)>>1;
 +	ch_stat0.status_0_regx.clk_acc = (intelhaddata->aes_bits &
 +						IEC958_AES3_CON_CLOCK)>>4;
 +	cfg_val.cfg_regx_v2.val_bit = ch_stat0.status_0_regx.lpcm_id;
  
  	switch (substream->runtime->rate) {
  	case AUD_SAMPLE_RATE_32:
@@@ -324,26 -284,29 +337,43 @@@
  	default:
  		/* control should never come here */
  		return -EINVAL;
 -	}
 +	break;
  
 +	}
  	had_write_register(intelhaddata,
 -			   AUD_CH_STATUS_0, ch_stat0.regval);
 +			   AUD_CH_STATUS_0, ch_stat0.status_0_regval);
  
++<<<<<<< HEAD
 +	format = substream->runtime->format;
 +
 +	if (format == SNDRV_PCM_FORMAT_S16_LE) {
 +		ch_stat1.status_1_regx.max_wrd_len = MAX_SMPL_WIDTH_20;
 +		ch_stat1.status_1_regx.wrd_len = SMPL_WIDTH_16BITS;
 +	} else if (format == SNDRV_PCM_FORMAT_S24_LE) {
 +		ch_stat1.status_1_regx.max_wrd_len = MAX_SMPL_WIDTH_24;
 +		ch_stat1.status_1_regx.wrd_len = SMPL_WIDTH_24BITS;
 +	} else {
 +		ch_stat1.status_1_regx.max_wrd_len = 0;
 +		ch_stat1.status_1_regx.wrd_len = 0;
++=======
+ 	switch (substream->runtime->format) {
+ #if 0 /* FIXME: not supported yet */
+ 	case SNDRV_PCM_FORMAT_S16_LE:
+ 		ch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_20;
+ 		ch_stat1.regx.wrd_len = SMPL_WIDTH_16BITS;
+ 		break;
+ #endif
+ 	case SNDRV_PCM_FORMAT_S24_LE:
+ 	case SNDRV_PCM_FORMAT_S32_LE:
+ 		ch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_24;
+ 		ch_stat1.regx.wrd_len = SMPL_WIDTH_24BITS;
+ 		break;
+ 	default:
+ 		return -EINVAL;
++>>>>>>> 85bd8748ca23 (ALSA: x86: Support S32 format)
  	}
 -
  	had_write_register(intelhaddata,
 -			   AUD_CH_STATUS_1, ch_stat1.regval);
 +			   AUD_CH_STATUS_1, ch_stat1.status_1_regval);
  	return 0;
  }
  
@@@ -361,20 -324,31 +391,36 @@@ static int snd_intelhad_audio_ctrl(stru
  
  	had_prog_status_reg(substream, intelhaddata);
  
 -	buf_cfg.regx.audio_fifo_watermark = FIFO_THRESHOLD;
 -	buf_cfg.regx.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 -	buf_cfg.regx.aud_delay = 0;
 -	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.regval);
 +	buf_cfg.buf_cfg_regx_v2.audio_fifo_watermark = FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.aud_delay = 0;
 +	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.buf_cfgval);
  
  	channels = substream->runtime->channels;
 -	cfg_val.regx.num_ch = channels - 2;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
  	if (channels <= 2)
 -		cfg_val.regx.layout = LAYOUT0;
 +		cfg_val.cfg_regx_v2.layout = LAYOUT0;
  	else
 -		cfg_val.regx.layout = LAYOUT1;
 +		cfg_val.cfg_regx_v2.layout = LAYOUT1;
  
++<<<<<<< HEAD
 +	cfg_val.cfg_regx_v2.val_bit = 1;
 +	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.cfg_regval);
++=======
+ 	if (substream->runtime->format == SNDRV_PCM_FORMAT_S32_LE)
+ 		cfg_val.regx.left_align = 1;
+ 
+ 	cfg_val.regx.val_bit = 1;
+ 
+ 	/* fix up the DP bits */
+ 	if (intelhaddata->dp_output) {
+ 		cfg_val.regx.dp_modei = 1;
+ 		cfg_val.regx.set = 1;
+ 	}
+ 
+ 	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.regval);
+ 	intelhaddata->aud_config = cfg_val;
++>>>>>>> 85bd8748ca23 (ALSA: x86: Support S32 format)
  	return 0;
  }
  
@@@ -998,17 -1053,22 +1044,32 @@@ static int snd_intelhad_open(struct snd
  	 */
  	retval = snd_pcm_hw_constraint_step(substream->runtime, 0,
  			SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);
++<<<<<<< HEAD
 +	if (retval < 0) {
 +		pr_err("%s:step_size=64 failed,err=%d\n", __func__, retval);
 +		goto exit_err;
 +	}
++=======
+ 	if (retval < 0)
+ 		goto error;
+ 
+ 	retval = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+ 	if (retval < 0)
+ 		goto error;
+ 
+ 	/* expose PCM substream */
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	intelhaddata->stream_info.substream = substream;
+ 	intelhaddata->stream_info.substream_refcount++;
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
++>>>>>>> 85bd8748ca23 (ALSA: x86: Support S32 format)
  
  	return retval;
 - error:
 +exit_err:
 +	kfree(stream);
 +exit_put_handle:
  	pm_runtime_put(intelhaddata->dev);
 +	runtime->private_data = NULL;
  	return retval;
  }
  
* Unmerged path sound/x86/intel_hdmi_audio.c
