scsi: cxlflash: Remove AFU command lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Remove AFU command lock (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 91.67%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 9ba848acbf4fbc6d99a0992df9ef5eb1b4842ba9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9ba848ac.failed

The original design of the cxlflash driver required AFU commands
to convey state information across multiple threads. The IOASA
"host use" byte was used to track if a command was done, errored,
or timed out. A per-command spin lock was used to serialize access
to this byte. As this is no longer required with the introduction
of completions and various refactoring over time, the spin lock,
state tracking, and associated code can be removed. To support the
simplification, the wait_resp() routine is refactored to return a
success or failure. Additionally, as the simplification to the
AFU internal command routine, explicit assignments of AFU command
fields to zero are removed as the memory is zeroed upon allocation.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Acked-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9ba848acbf4fbc6d99a0992df9ef5eb1b4842ba9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,bed8e60f312e..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -132,11 -128,8 +127,13 @@@ struct cxlflash_cfg 
  struct afu_cmd {
  	struct sisl_ioarcb rcb;	/* IOARCB (cache line aligned) */
  	struct sisl_ioasa sa;	/* IOASA must follow IOARCB */
- 	spinlock_t slock;
- 	struct completion cevent;
  	struct afu *parent;
++<<<<<<< HEAD
 +	int slot;
 +	atomic_t free;
++=======
+ 	struct completion cevent;
++>>>>>>> 9ba848acbf4f (scsi: cxlflash: Remove AFU command lock)
  
  	u8 cmd_tmf:1;
  
diff --cc drivers/scsi/cxlflash/main.c
index d8aaf45b8306,db770301c30a..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -403,8 -330,9 +397,12 @@@ static int send_tmf(struct afu *afu, st
  	cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
  			      SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
  
 -	/* Stash the scp in the command, for reuse during interrupt */
 +	/* Stash the scp in the reserved field, for reuse during interrupt */
  	cmd->rcb.scp = scp;
++<<<<<<< HEAD
++=======
+ 	cmd->parent = afu;
++>>>>>>> 9ba848acbf4f (scsi: cxlflash: Remove AFU command lock)
  
  	/* Copy the CDB from the cmd passed in */
  	memcpy(cmd->rcb.cdb, &tmfcmd, sizeof(tmfcmd));
@@@ -523,6 -458,7 +521,10 @@@ static int cxlflash_queuecommand(struc
  
  	/* Stash the scp in the reserved field, for reuse during interrupt */
  	cmd->rcb.scp = scp;
++<<<<<<< HEAD
++=======
+ 	cmd->parent = afu;
++>>>>>>> 9ba848acbf4f (scsi: cxlflash: Remove AFU command lock)
  
  	nseg = scsi_dma_map(scp);
  	if (unlikely(nseg < 0)) {
@@@ -1847,13 -1745,11 +1844,10 @@@ int cxlflash_afu_sync(struct afu *afu, 
  	if (unlikely(rc))
  		goto out;
  
- 	wait_resp(afu, cmd);
- 
- 	/* Set on timeout */
- 	if (unlikely((cmd->sa.ioasc != 0) ||
- 		     (cmd->sa.host_use_b[0] & B_ERROR)))
+ 	rc = wait_resp(afu, cmd);
+ 	if (unlikely(rc))
  		rc = -1;
  out:
 -	atomic_dec(&afu->cmds_active);
  	mutex_unlock(&sync_active);
  	kfree(buf);
  	pr_debug("%s: returning rc=%d\n", __func__, rc);
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
