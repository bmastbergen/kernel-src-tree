IB/mlx5: Support IB_SRQT_TM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Artemy Kovalyov <artemyko@mellanox.com>
commit 3fd3307ef34fc9f7198af9249c763cf7a4ac653f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3fd3307e.failed

Pass to mlx5_core flag to enable rendezvous offload, list_size and CQ
when SRQ created with IB_SRQT_TM.

	Signed-off-by: Artemy Kovalyov <artemyko@mellanox.com>
	Reviewed-by: Yossi Itigin <yosefe@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 3fd3307ef34fc9f7198af9249c763cf7a4ac653f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/srq.c
diff --cc drivers/infiniband/hw/mlx5/srq.c
index 7cb145f9a6db,6d5fadad9090..000000000000
--- a/drivers/infiniband/hw/mlx5/srq.c
+++ b/drivers/infiniband/hw/mlx5/srq.c
@@@ -292,13 -292,28 +292,32 @@@ struct ib_srq *mlx5_ib_create_srq(struc
  	in.wqe_shift = srq->msrq.wqe_shift - 4;
  	if (srq->wq_sig)
  		in.flags |= MLX5_SRQ_FLAG_WQ_SIG;
 -
 -	if (init_attr->srq_type == IB_SRQT_XRC)
 +	if (init_attr->srq_type == IB_SRQT_XRC) {
  		in.xrcd = to_mxrcd(init_attr->ext.xrc.xrcd)->xrcdn;
 -	else
 +		in.cqn = to_mcq(init_attr->ext.xrc.cq)->mcq.cqn;
 +	} else if (init_attr->srq_type == IB_SRQT_BASIC) {
  		in.xrcd = to_mxrcd(dev->devr.x0)->xrcdn;
++<<<<<<< HEAD
++=======
+ 
+ 	if (init_attr->srq_type == IB_SRQT_TM) {
+ 		in.tm_log_list_size =
+ 			ilog2(init_attr->ext.tag_matching.max_num_tags) + 1;
+ 		if (in.tm_log_list_size >
+ 		    MLX5_CAP_GEN(dev->mdev, log_tag_matching_list_sz)) {
+ 			mlx5_ib_dbg(dev, "TM SRQ max_num_tags exceeding limit\n");
+ 			err = -EINVAL;
+ 			goto err_usr_kern_srq;
+ 		}
+ 		in.flags |= MLX5_SRQ_FLAG_RNDV;
+ 	}
+ 
+ 	if (ib_srq_has_cq(init_attr->srq_type))
+ 		in.cqn = to_mcq(init_attr->ext.cq)->mcq.cqn;
+ 	else
++>>>>>>> 3fd3307ef34f (IB/mlx5: Support IB_SRQT_TM)
  		in.cqn = to_mcq(dev->devr.c0)->mcq.cqn;
 +	}
  
  	in.pd = to_mpd(pd)->pdn;
  	in.db_record = srq->db.dma;
diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c
index 5e9ea8585cac..86d594365b82 100644
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@ -1727,10 +1727,15 @@ static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 
 	MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));
 
-	if (qp->sq.wqe_cnt)
+	if (qp->sq.wqe_cnt) {
 		MLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));
-	else
+	} else {
 		MLX5_SET(qpc, qpc, no_sq, 1);
+		if (init_attr->srq &&
+		    init_attr->srq->srq_type == IB_SRQT_TM)
+			MLX5_SET(qpc, qpc, offload_type,
+				 MLX5_QPC_OFFLOAD_TYPE_RNDV);
+	}
 
 	/* Set default resources */
 	switch (init_attr->qp_type) {
* Unmerged path drivers/infiniband/hw/mlx5/srq.c
