intel_pstate: Update cpu_frequency tracepoint every time

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit bc95a454b6dcf6aa464deef86e18c1770b8682b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bc95a454.failed

Currently, intel_pstate only updates the cpu_frequency tracepoint
if the new P-state to set is different from the current one, but
that causes powertop to report 100% idle on an 100% loaded system
sometimes.

Prevent that from happening by updating the cpu_frequency tracepoint
every time intel_pstate_update_pstate() is called.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>-
(cherry picked from commit bc95a454b6dcf6aa464deef86e18c1770b8682b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index cdec04ba80ec,9c8a78f9ddce..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1091,24 -1132,19 +1091,40 @@@ static void intel_pstate_get_min_max(st
  	*min = clamp_t(int, min_perf, cpu->pstate.min_pstate, max_perf);
  }
  
++<<<<<<< HEAD
 +static void intel_pstate_set_pstate(struct cpudata *cpu, int pstate)
 +{
 +	int max_perf, min_perf;
 +
 +	update_turbo_state();
 +
 +	intel_pstate_get_min_max(cpu, &min_perf, &max_perf);
 +
 +	pstate = clamp_t(int, pstate, min_perf, max_perf);
 +
 +	if (pstate == cpu->pstate.current_pstate)
 +		return;
 +
 +	trace_cpu_frequency(pstate * cpu->pstate.scaling, cpu->cpu);
 +
 +	cpu->pstate.current_pstate = pstate;
 +
 +	pstate_funcs.set(cpu, pstate);
++=======
+ static void intel_pstate_set_min_pstate(struct cpudata *cpu)
+ {
+ 	int pstate = cpu->pstate.min_pstate;
+ 
+ 	trace_cpu_frequency(pstate * cpu->pstate.scaling, cpu->cpu);
+ 	cpu->pstate.current_pstate = pstate;
+ 	/*
+ 	 * Generally, there is no guarantee that this code will always run on
+ 	 * the CPU being updated, so force the register update to run on the
+ 	 * right CPU.
+ 	 */
+ 	wrmsrl_on_cpu(cpu->cpu, MSR_IA32_PERF_CTL,
+ 		      pstate_funcs.get_val(cpu, pstate));
++>>>>>>> bc95a454b6dc (intel_pstate: Update cpu_frequency tracepoint every time)
  }
  
  static void intel_pstate_get_cpu_pstates(struct cpudata *cpu)
@@@ -1270,11 -1282,27 +1286,32 @@@ static inline int32_t get_target_pstate
  	} else {
  		sample_ratio = div_fp(100 * cpu->sample.mperf, cpu->sample.tsc);
  		if (sample_ratio < int_tofp(1))
 -			perf_scaled = 0;
 +			core_busy = 0;
  	}
  
++<<<<<<< HEAD
 +	cpu->sample.busy_scaled = core_busy;
 +	return cpu->pstate.current_pstate - pid_calc(&cpu->pid, core_busy);
++=======
+ 	cpu->sample.busy_scaled = perf_scaled;
+ 	return cpu->pstate.current_pstate - pid_calc(&cpu->pid, perf_scaled);
+ }
+ 
+ static inline void intel_pstate_update_pstate(struct cpudata *cpu, int pstate)
+ {
+ 	int max_perf, min_perf;
+ 
+ 	update_turbo_state();
+ 
+ 	intel_pstate_get_min_max(cpu, &min_perf, &max_perf);
+ 	pstate = clamp_t(int, pstate, min_perf, max_perf);
+ 	trace_cpu_frequency(pstate * cpu->pstate.scaling, cpu->cpu);
+ 	if (pstate == cpu->pstate.current_pstate)
+ 		return;
+ 
+ 	cpu->pstate.current_pstate = pstate;
+ 	wrmsrl(MSR_IA32_PERF_CTL, pstate_funcs.get_val(cpu, pstate));
++>>>>>>> bc95a454b6dc (intel_pstate: Update cpu_frequency tracepoint every time)
  }
  
  static inline void intel_pstate_adjust_busy_pstate(struct cpudata *cpu)
* Unmerged path drivers/cpufreq/intel_pstate.c
