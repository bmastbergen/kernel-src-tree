nvme-fc: fix status code handling in nvme_fc_fcpio_done

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: fix status code handling in nvme_fc_fcpio_done (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 95.24%
commit-author Christoph Hellwig <hch@lst.de>
commit d663b69ff378e4990e35e274ab0813c4641ab564
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d663b69f.failed

nvme_complete_async_event expects the little endian status code
including the phase bit, and a new completion handler I plan to
introduce will do so as well.

Change the status variable into the little endian format with the
phase bit used in the NVMe CQE to fix / enable this.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit d663b69ff378e4990e35e274ab0813c4641ab564)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index ab495bc8c3fb,aad7f9c0be32..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1146,7 -1147,7 +1146,11 @@@ nvme_fc_fcpio_done(struct nvmefc_fcp_re
  	struct nvme_fc_ctrl *ctrl = op->ctrl;
  	struct nvme_fc_queue *queue = op->queue;
  	struct nvme_completion *cqe = &op->rsp_iu.cqe;
++<<<<<<< HEAD
 +	u16 status;
++=======
+ 	__le16 status = cpu_to_le16(NVME_SC_SUCCESS << 1);
++>>>>>>> d663b69ff378 (nvme-fc: fix status code handling in nvme_fc_fcpio_done)
  
  	/*
  	 * WARNING:
@@@ -1181,9 -1182,9 +1185,15 @@@
  				sizeof(op->rsp_iu), DMA_FROM_DEVICE);
  
  	if (atomic_read(&op->state) == FCPOP_STATE_ABORTED)
++<<<<<<< HEAD
 +		status = NVME_SC_ABORT_REQ | NVME_SC_DNR;
 +	else
 +		status = freq->status;
++=======
+ 		status = cpu_to_le16((NVME_SC_ABORT_REQ | NVME_SC_DNR) << 1);
+ 	else if (freq->status)
+ 		status = cpu_to_le16(NVME_SC_FC_TRANSPORT_ERROR << 1);
++>>>>>>> d663b69ff378 (nvme-fc: fix status code handling in nvme_fc_fcpio_done)
  
  	/*
  	 * For the linux implementation, if we have an unsuccesful
@@@ -1211,7 -1212,7 +1221,11 @@@
  		 */
  		if (freq->transferred_length !=
  			be32_to_cpu(op->cmd_iu.data_len)) {
++<<<<<<< HEAD
 +			status = -EIO;
++=======
+ 			status = cpu_to_le16(NVME_SC_FC_TRANSPORT_ERROR << 1);
++>>>>>>> d663b69ff378 (nvme-fc: fix status code handling in nvme_fc_fcpio_done)
  			goto done;
  		}
  		op->nreq.result.u64 = 0;
@@@ -1226,8 -1227,9 +1240,12 @@@
  					(freq->rcv_rsplen / 4) ||
  			     be32_to_cpu(op->rsp_iu.xfrd_len) !=
  					freq->transferred_length ||
 -			     op->rsp_iu.status_code ||
  			     op->rqno != le16_to_cpu(cqe->command_id))) {
++<<<<<<< HEAD
 +			status = -EIO;
++=======
+ 			status = cpu_to_le16(NVME_SC_FC_TRANSPORT_ERROR << 1);
++>>>>>>> d663b69ff378 (nvme-fc: fix status code handling in nvme_fc_fcpio_done)
  			goto done;
  		}
  		op->nreq.result = cqe->result;
@@@ -1235,7 -1237,7 +1253,11 @@@
  		break;
  
  	default:
++<<<<<<< HEAD
 +		status = -EIO;
++=======
+ 		status = cpu_to_le16(NVME_SC_FC_TRANSPORT_ERROR << 1);
++>>>>>>> d663b69ff378 (nvme-fc: fix status code handling in nvme_fc_fcpio_done)
  		goto done;
  	}
  
* Unmerged path drivers/nvme/host/fc.c
