radix-tree: miscellaneous fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 2fcd9005cc03ab09ea2a940515ed728d43df66c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2fcd9005.failed

Typos, whitespace, grammar, line length, using the correct types, etc.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2fcd9005cc03ab09ea2a940515ed728d43df66c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index c40bb30382f1,75944e42e4a0..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -65,8 -66,9 +65,14 @@@ static struct kmem_cache *radix_tree_no
   * Per-cpu pool of preloaded nodes
   */
  struct radix_tree_preload {
++<<<<<<< HEAD
 +	int nr;
 +	struct radix_tree_node *nodes[RADIX_TREE_PRELOAD_SIZE];
++=======
+ 	unsigned nr;
+ 	/* nodes->private_data points to next preallocated node */
+ 	struct radix_tree_node *nodes;
++>>>>>>> 2fcd9005cc03 (radix-tree: miscellaneous fixes)
  };
  static DEFINE_PER_CPU(struct radix_tree_preload, radix_tree_preloads) = { 0, };
  
@@@ -160,9 -159,14 +166,9 @@@ static inline void root_tag_clear_all(s
  
  static inline int root_tag_get(struct radix_tree_root *root, unsigned int tag)
  {
- 	return (__force unsigned)root->gfp_mask & (1 << (tag + __GFP_BITS_SHIFT));
+ 	return (__force int)root->gfp_mask & (1 << (tag + __GFP_BITS_SHIFT));
  }
  
 -static inline unsigned root_tags_get(struct radix_tree_root *root)
 -{
 -	return (__force unsigned)root->gfp_mask >> __GFP_BITS_SHIFT;
 -}
 -
  /*
   * Returns 1 if any slot in the node has this tag set.
   * Otherwise returns 0.
@@@ -269,13 -273,22 +275,13 @@@ radix_tree_node_alloc(struct radix_tree
  	gfp_t gfp_mask = root_gfp_mask(root);
  
  	/*
- 	 * Preload code isn't irq safe and it doesn't make sence to use
- 	 * preloading in the interrupt anyway as all the allocations have to
- 	 * be atomic. So just do normal allocation when in interrupt.
+ 	 * Preload code isn't irq safe and it doesn't make sense to use
+ 	 * preloading during an interrupt anyway as all the allocations have
+ 	 * to be atomic. So just do normal allocation when in interrupt.
  	 */
 -	if (!gfpflags_allow_blocking(gfp_mask) && !in_interrupt()) {
 +	if (!(gfp_mask & __GFP_WAIT) && !in_interrupt()) {
  		struct radix_tree_preload *rtp;
  
 -		/*
 -		 * Even if the caller has preloaded, try to allocate from the
 -		 * cache first for the new node to get accounted.
 -		 */
 -		ret = kmem_cache_alloc(radix_tree_node_cachep,
 -				       gfp_mask | __GFP_ACCOUNT | __GFP_NOWARN);
 -		if (ret)
 -			goto out;
 -
  		/*
  		 * Provided the caller has preloaded here, we will always
  		 * succeed in getting a node here (and never reach
@@@ -1610,23 -1652,23 +1619,40 @@@ static __init void radix_tree_init_maxi
  }
  
  static int radix_tree_callback(struct notifier_block *nfb,
-                             unsigned long action,
-                             void *hcpu)
+ 				unsigned long action, void *hcpu)
  {
++<<<<<<< HEAD
 +       int cpu = (long)hcpu;
 +       struct radix_tree_preload *rtp;
 +
 +       /* Free per-cpu pool of perloaded nodes */
 +       if (action == CPU_DEAD || action == CPU_DEAD_FROZEN) {
 +               rtp = &per_cpu(radix_tree_preloads, cpu);
 +               while (rtp->nr) {
 +                       kmem_cache_free(radix_tree_node_cachep,
 +                                       rtp->nodes[rtp->nr-1]);
 +                       rtp->nodes[rtp->nr-1] = NULL;
 +                       rtp->nr--;
 +               }
 +       }
 +       return NOTIFY_OK;
++=======
+ 	int cpu = (long)hcpu;
+ 	struct radix_tree_preload *rtp;
+ 	struct radix_tree_node *node;
+ 
+ 	/* Free per-cpu pool of preloaded nodes */
+ 	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN) {
+ 		rtp = &per_cpu(radix_tree_preloads, cpu);
+ 		while (rtp->nr) {
+ 			node = rtp->nodes;
+ 			rtp->nodes = node->private_data;
+ 			kmem_cache_free(radix_tree_node_cachep, node);
+ 			rtp->nr--;
+ 		}
+ 	}
+ 	return NOTIFY_OK;
++>>>>>>> 2fcd9005cc03 (radix-tree: miscellaneous fixes)
  }
  
  void __init radix_tree_init(void)
* Unmerged path lib/radix-tree.c
