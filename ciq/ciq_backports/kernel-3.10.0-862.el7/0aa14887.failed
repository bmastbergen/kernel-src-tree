scsi: cxlflash: Hide FC internals behind common access routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Hide FC internals behind common access routine (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 94.92%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 0aa14887c60c27e3385295ee85f5ac079ae2ffb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0aa14887.failed

As staging to support FC-related updates to the SISlite specification,
introduce helper routines to obtain references to FC resources that exist
within the global map. This will allow changes to the underlying global map
structure without impacting existing code paths.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0aa14887c60c27e3385295ee85f5ac079ae2ffb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
#	drivers/scsi/cxlflash/vlun.c
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,e198605c3ded..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -731,23 -684,25 +731,34 @@@ static void notify_shutdown(struct cxlf
  		return;
  	}
  
- 	global = &afu->afu_map->global;
- 
  	/* Notify AFU */
++<<<<<<< HEAD
 +	for (i = 0; i < NUM_FC_PORTS; i++) {
 +		reg = readq_be(&global->fc_regs[i][FC_CONFIG2 / 8]);
++=======
+ 	for (i = 0; i < cfg->num_fc_ports; i++) {
+ 		fc_port_regs = get_fc_port_regs(cfg, i);
+ 
+ 		reg = readq_be(&fc_port_regs[FC_CONFIG2 / 8]);
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  		reg |= SISL_FC_SHUTDOWN_NORMAL;
- 		writeq_be(reg, &global->fc_regs[i][FC_CONFIG2 / 8]);
+ 		writeq_be(reg, &fc_port_regs[FC_CONFIG2 / 8]);
  	}
  
  	if (!wait)
  		return;
  
  	/* Wait up to 1.5 seconds for shutdown processing to complete */
++<<<<<<< HEAD
 +	for (i = 0; i < NUM_FC_PORTS; i++) {
++=======
+ 	for (i = 0; i < cfg->num_fc_ports; i++) {
+ 		fc_port_regs = get_fc_port_regs(cfg, i);
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  		retry_cnt = 0;
+ 
  		while (true) {
- 			status = readq_be(&global->fc_regs[i][FC_STATUS / 8]);
+ 			status = readq_be(&fc_port_regs[FC_STATUS / 8]);
  			if (status & SISL_STATUS_SHUTDOWN_COMPLETE)
  				break;
  			if (++retry_cnt >= MC_RETRY_CNT) {
@@@ -1126,6 -1072,8 +1137,11 @@@ static const struct asyc_intr_info *fin
   */
  static void afu_err_intr_init(struct afu *afu)
  {
++<<<<<<< HEAD
++=======
+ 	struct cxlflash_cfg *cfg = afu->parent;
+ 	__be64 __iomem *fc_port_regs;
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	int i;
  	u64 reg;
  
@@@ -1158,13 -1107,14 +1175,21 @@@
  	reg &= SISL_FC_INTERNAL_MASK;
  	if (afu->internal_lun)
  		reg |= ((u64)(afu->internal_lun - 1) << SISL_FC_INTERNAL_SHIFT);
- 	writeq_be(reg, &afu->afu_map->global.fc_regs[0][FC_CONFIG2 / 8]);
+ 	writeq_be(reg, &fc_port_regs[FC_CONFIG2 / 8]);
  
  	/* now clear FC errors */
++<<<<<<< HEAD
 +	for (i = 0; i < NUM_FC_PORTS; i++) {
 +		writeq_be(0xFFFFFFFFU,
 +			  &afu->afu_map->global.fc_regs[i][FC_ERROR / 8]);
 +		writeq_be(0, &afu->afu_map->global.fc_regs[i][FC_ERRCAP / 8]);
++=======
+ 	for (i = 0; i < cfg->num_fc_ports; i++) {
+ 		fc_port_regs = get_fc_port_regs(cfg, i);
+ 
+ 		writeq_be(0xFFFFFFFFU, &fc_port_regs[FC_ERROR / 8]);
+ 		writeq_be(0, &fc_port_regs[FC_ERRCAP / 8]);
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	}
  
  	/* sync interrupts for master's IOARRIN write */
@@@ -1289,10 -1335,11 +1315,11 @@@ static irqreturn_t cxlflash_async_err_i
  			continue;
  
  		port = info->port;
+ 		fc_port_regs = get_fc_port_regs(cfg, port);
  
 -		dev_err(dev, "%s: FC Port %d -> %s, fc_status=%016llx\n",
 +		dev_err(dev, "%s: FC Port %d -> %s, fc_status 0x%08llX\n",
  			__func__, port, info->desc,
- 		       readq_be(&global->fc_regs[port][FC_STATUS / 8]));
+ 		       readq_be(&fc_port_regs[FC_STATUS / 8]));
  
  		/*
  		 * Do link reset first, some OTHER errors will set FC_ERROR
@@@ -1314,11 -1361,11 +1341,11 @@@
  			 * should be the same and tracing one is sufficient.
  			 */
  
 -			dev_err(dev, "%s: fc %d: clearing fc_error=%016llx\n",
 +			dev_err(dev, "%s: fc %d: clearing fc_error 0x%08llX\n",
  				__func__, port, reg);
  
- 			writeq_be(reg, &global->fc_regs[port][FC_ERROR / 8]);
- 			writeq_be(0, &global->fc_regs[port][FC_ERRCAP / 8]);
+ 			writeq_be(reg, &fc_port_regs[FC_ERROR / 8]);
+ 			writeq_be(0, &fc_port_regs[FC_ERRCAP / 8]);
  		}
  
  		if (info->action & SCAN_HOST) {
@@@ -1487,7 -1528,8 +1514,12 @@@ static int init_global(struct cxlflash_
  {
  	struct afu *afu = cfg->afu;
  	struct device *dev = &cfg->dev->dev;
++<<<<<<< HEAD
 +	u64 wwpn[NUM_FC_PORTS];	/* wwpn of AFU ports */
++=======
+ 	__be64 __iomem *fc_port_regs;
+ 	u64 wwpn[MAX_FC_PORTS];	/* wwpn of AFU ports */
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	int i = 0, num_ports = 0;
  	int rc = 0;
  	u64 reg;
@@@ -2022,22 -2063,30 +2052,26 @@@ static int cxlflash_change_queue_depth(
  /**
   * cxlflash_show_port_status() - queries and presents the current port status
   * @port:	Desired port for status reporting.
 - * @cfg:	Internal structure associated with the host.
 + * @afu:	AFU owning the specified port.
   * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.
   *
 - * Return: The size of the ASCII string returned in @buf or -EINVAL.
 + * Return: The size of the ASCII string returned in @buf.
   */
 -static ssize_t cxlflash_show_port_status(u32 port,
 -					 struct cxlflash_cfg *cfg,
 -					 char *buf)
 +static ssize_t cxlflash_show_port_status(u32 port, struct afu *afu, char *buf)
  {
++<<<<<<< HEAD
++=======
+ 	struct device *dev = &cfg->dev->dev;
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	char *disp_status;
  	u64 status;
- 	__be64 __iomem *fc_regs;
+ 	__be64 __iomem *fc_port_regs;
  
 -	WARN_ON(port >= MAX_FC_PORTS);
 -
 -	if (port >= cfg->num_fc_ports) {
 -		dev_info(dev, "%s: Port %d not supported on this card.\n",
 -			__func__, port);
 -		return -EINVAL;
 -	}
 +	if (port >= NUM_FC_PORTS)
 +		return 0;
  
- 	fc_regs = &afu->afu_map->global.fc_regs[port][0];
- 	status = readq_be(&fc_regs[FC_MTIP_STATUS / 8]);
+ 	fc_port_regs = get_fc_port_regs(cfg, port);
+ 	status = readq_be(&fc_port_regs[FC_MTIP_STATUS / 8]);
  	status &= FC_MTIP_STATUS_MASK;
  
  	if (status == FC_MTIP_STATUS_ONLINE)
@@@ -2175,27 -2220,34 +2209,36 @@@ static ssize_t ioctl_version_show(struc
  /**
   * cxlflash_show_port_lun_table() - queries and presents the port LUN table
   * @port:	Desired port for status reporting.
 - * @cfg:	Internal structure associated with the host.
 + * @afu:	AFU owning the specified port.
   * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.
   *
 - * Return: The size of the ASCII string returned in @buf or -EINVAL.
 + * Return: The size of the ASCII string returned in @buf.
   */
  static ssize_t cxlflash_show_port_lun_table(u32 port,
 -					    struct cxlflash_cfg *cfg,
 +					    struct afu *afu,
  					    char *buf)
  {
++<<<<<<< HEAD
++=======
+ 	struct device *dev = &cfg->dev->dev;
+ 	__be64 __iomem *fc_port_luns;
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	int i;
  	ssize_t bytes = 0;
- 	__be64 __iomem *fc_port;
  
 -	WARN_ON(port >= MAX_FC_PORTS);
 -
 -	if (port >= cfg->num_fc_ports) {
 -		dev_info(dev, "%s: Port %d not supported on this card.\n",
 -			__func__, port);
 -		return -EINVAL;
 -	}
 +	if (port >= NUM_FC_PORTS)
 +		return 0;
  
- 	fc_port = &afu->afu_map->global.fc_port[port][0];
+ 	fc_port_luns = get_fc_port_luns(cfg, port);
  
  	for (i = 0; i < CXLFLASH_NUM_VLUNS; i++)
  		bytes += scnprintf(buf + bytes, PAGE_SIZE - bytes,
++<<<<<<< HEAD
 +				   "%03d: %016llX\n", i, readq_be(&fc_port[i]));
++=======
+ 				   "%03d: %016llx\n",
+ 				   i, readq_be(&fc_port_luns[i]));
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	return bytes;
  }
  
diff --cc drivers/scsi/cxlflash/vlun.c
index 90c5d7f5278e,90b5c19f81f0..000000000000
--- a/drivers/scsi/cxlflash/vlun.c
+++ b/drivers/scsi/cxlflash/vlun.c
@@@ -812,10 -819,10 +812,16 @@@ int cxlflash_vlun_resize(struct scsi_de
  void cxlflash_restore_luntable(struct cxlflash_cfg *cfg)
  {
  	struct llun_info *lli, *temp;
 +	u32 chan;
  	u32 lind;
++<<<<<<< HEAD
 +	struct afu *afu = cfg->afu;
 +	struct sisl_global_map __iomem *agm = &afu->afu_map->global;
++=======
+ 	int k;
+ 	struct device *dev = &cfg->dev->dev;
+ 	__be64 __iomem *fc_port_luns;
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  
  	mutex_lock(&global.mutex);
  
@@@ -824,20 -831,14 +830,29 @@@
  			continue;
  
  		lind = lli->lun_index;
 -		dev_dbg(dev, "%s: Virtual LUNs on slot %d:\n", __func__, lind);
  
++<<<<<<< HEAD
 +		if (lli->port_sel == BOTH_PORTS) {
 +			writeq_be(lli->lun_id[0], &agm->fc_port[0][lind]);
 +			writeq_be(lli->lun_id[1], &agm->fc_port[1][lind]);
 +			pr_debug("%s: Virtual LUN on slot %d  id0=%llx, "
 +				 "id1=%llx\n", __func__, lind,
 +				 lli->lun_id[0], lli->lun_id[1]);
 +		} else {
 +			chan = PORT2CHAN(lli->port_sel);
 +			writeq_be(lli->lun_id[chan], &agm->fc_port[chan][lind]);
 +			pr_debug("%s: Virtual LUN on slot %d chan=%d, "
 +				 "id=%llx\n", __func__, lind, chan,
 +				 lli->lun_id[chan]);
 +		}
++=======
+ 		for (k = 0; k < cfg->num_fc_ports; k++)
+ 			if (lli->port_sel & (1 << k)) {
+ 				fc_port_luns = get_fc_port_luns(cfg, k);
+ 				writeq_be(lli->lun_id[k], &fc_port_luns[lind]);
+ 				dev_dbg(dev, "\t%d=%llx\n", k, lli->lun_id[k]);
+ 			}
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  	}
  
  	mutex_unlock(&global.mutex);
@@@ -858,9 -873,11 +873,15 @@@ static int init_luntable(struct cxlflas
  {
  	u32 chan;
  	u32 lind;
 -	u32 nports;
  	int rc = 0;
++<<<<<<< HEAD
 +	struct afu *afu = cfg->afu;
 +	struct sisl_global_map __iomem *agm = &afu->afu_map->global;
++=======
+ 	int k;
+ 	struct device *dev = &cfg->dev->dev;
+ 	__be64 __iomem *fc_port_luns;
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  
  	mutex_lock(&global.mutex);
  
@@@ -879,27 -907,35 +900,42 @@@
  		}
  
  		lind = lli->lun_index = cfg->promote_lun_index;
++<<<<<<< HEAD
 +		writeq_be(lli->lun_id[0], &agm->fc_port[0][lind]);
 +		writeq_be(lli->lun_id[1], &agm->fc_port[1][lind]);
++=======
+ 		dev_dbg(dev, "%s: Virtual LUNs on slot %d:\n", __func__, lind);
+ 
+ 		for (k = 0; k < cfg->num_fc_ports; k++) {
+ 			if (!(lli->port_sel & (1 << k)))
+ 				continue;
+ 
+ 			fc_port_luns = get_fc_port_luns(cfg, k);
+ 			writeq_be(lli->lun_id[k], &fc_port_luns[lind]);
+ 			dev_dbg(dev, "\t%d=%llx\n", k, lli->lun_id[k]);
+ 		}
+ 
++>>>>>>> 0aa14887c60c (scsi: cxlflash: Hide FC internals behind common access routine)
  		cfg->promote_lun_index++;
 +		pr_debug("%s: Virtual LUN on slot %d  id0=%llx, id1=%llx\n",
 +			 __func__, lind, lli->lun_id[0], lli->lun_id[1]);
  	} else {
  		/*
 -		 * When LUN is visible only from one port, we will put
 +		 * If this LUN is visible only from one port, we will put
  		 * it in the bottom half of the LUN table.
  		 */
 -		chan = PORTMASK2CHAN(lli->port_sel);
 +		chan = PORT2CHAN(lli->port_sel);
  		if (cfg->promote_lun_index == cfg->last_lun_index[chan]) {
  			rc = -ENOSPC;
  			goto out;
  		}
  
  		lind = lli->lun_index = cfg->last_lun_index[chan];
- 		writeq_be(lli->lun_id[chan], &agm->fc_port[chan][lind]);
+ 		fc_port_luns = get_fc_port_luns(cfg, chan);
+ 		writeq_be(lli->lun_id[chan], &fc_port_luns[lind]);
  		cfg->last_lun_index[chan]--;
 -		dev_dbg(dev, "%s: Virtual LUNs on slot %d:\n\t%d=%llx\n",
 -			__func__, lind, chan, lli->lun_id[chan]);
 +		pr_debug("%s: Virtual LUN on slot %d  chan=%d, id=%llx\n",
 +			 __func__, lind, chan, lli->lun_id[chan]);
  	}
  
  	lli->in_table = true;
diff --git a/drivers/scsi/cxlflash/common.h b/drivers/scsi/cxlflash/common.h
index 811927d91c5c..c5ad67df419a 100644
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@ -191,6 +191,20 @@ static inline u64 lun_to_lunid(u64 lun)
 	return be64_to_cpu(lun_id);
 }
 
+static inline __be64 __iomem *get_fc_port_regs(struct cxlflash_cfg *cfg, int i)
+{
+	struct afu *afu = cfg->afu;
+
+	return &afu->afu_map->global.fc_regs[i][0];
+}
+
+static inline __be64 __iomem *get_fc_port_luns(struct cxlflash_cfg *cfg, int i)
+{
+	struct afu *afu = cfg->afu;
+
+	return &afu->afu_map->global.fc_port[i][0];
+}
+
 int cxlflash_afu_sync(struct afu *, ctx_hndl_t, res_hndl_t, u8);
 void cxlflash_list_init(void);
 void cxlflash_term_global_luns(void);
* Unmerged path drivers/scsi/cxlflash/main.c
* Unmerged path drivers/scsi/cxlflash/vlun.c
