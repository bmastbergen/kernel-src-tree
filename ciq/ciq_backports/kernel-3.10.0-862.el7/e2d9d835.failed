openvswitch: pass mac_proto to ovs_vport_send

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit e2d9d8358cb961340ef88620b6a25ba4557033d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e2d9d835.failed

We'll need it to alter packets sent to ARPHRD_NONE interfaces.

Change do_output() to use the actual L2 header size of the packet when
deciding on the minimum cutlen. The assumption here is that what matters is
not the output interface hard_header_len but rather the L2 header of the
particular packet. For example, ARPHRD_NONE tunnels that encapsulate
Ethernet should get at least the Ethernet header.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e2d9d8358cb961340ef88620b6a25ba4557033d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/actions.c
#	net/openvswitch/vport.h
diff --cc net/openvswitch/actions.c
index 3e99057f11b4,dc8bb97e2258..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -708,8 -714,9 +710,14 @@@ static void prepare_frag(struct vport *
  	skb_pull(skb, hlen);
  }
  
++<<<<<<< HEAD
 +static void ovs_fragment(struct vport *vport, struct sk_buff *skb, u16 mru,
 +			 __be16 ethertype)
++=======
+ static void ovs_fragment(struct net *net, struct vport *vport,
+ 			 struct sk_buff *skb, u16 mru,
+ 			 struct sw_flow_key *key)
++>>>>>>> e2d9d8358cb9 (openvswitch: pass mac_proto to ovs_vport_send)
  {
  	u16 orig_network_offset = 0;
  
@@@ -736,9 -744,9 +745,9 @@@
  		skb_dst_set_noref(skb, &ovs_dst);
  		IPCB(skb)->frag_max_size = mru;
  
 -		ip_do_fragment(net, skb->sk, skb, ovs_vport_output);
 +		ip_do_fragment(skb->sk, skb, ovs_vport_output);
  		refdst_drop(orig_dst);
- 	} else if (ethertype == htons(ETH_P_IPV6)) {
+ 	} else if (key->eth.type == htons(ETH_P_IPV6)) {
  		const struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();
  		unsigned long orig_dst;
  		struct rt6_info ovs_rt;
@@@ -789,18 -798,11 +799,22 @@@ static void do_output(struct datapath *
  
  		if (likely(!mru ||
  		           (skb->len <= mru + vport->dev->hard_header_len))) {
- 			ovs_vport_send(vport, skb);
+ 			ovs_vport_send(vport, skb, ovs_key_mac_proto(key));
  		} else if (mru <= vport->dev->mtu) {
 -			struct net *net = read_pnet(&dp->net);
 +			__be16 ethertype = key->eth.type;
 +
++<<<<<<< HEAD
 +			if (!is_flow_key_valid(key)) {
 +				if (eth_p_mpls(skb->protocol))
 +					ethertype = skb->inner_protocol;
 +				else
 +					ethertype = vlan_get_protocol(skb);
 +			}
  
 +			ovs_fragment(vport, skb, mru, ethertype);
++=======
+ 			ovs_fragment(net, vport, skb, mru, key);
++>>>>>>> e2d9d8358cb9 (openvswitch: pass mac_proto to ovs_vport_send)
  		} else {
  			kfree_skb(skb);
  		}
diff --cc net/openvswitch/vport.h
index f8405b223923,cda66c26ad08..000000000000
--- a/net/openvswitch/vport.h
+++ b/net/openvswitch/vport.h
@@@ -197,7 -197,6 +197,11 @@@ int __ovs_vport_ops_register(struct vpo
  	})
  
  void ovs_vport_ops_unregister(struct vport_ops *ops);
++<<<<<<< HEAD
 +
 +void ovs_vport_send(struct vport *vport, struct sk_buff *skb);
++=======
+ void ovs_vport_send(struct vport *vport, struct sk_buff *skb, u8 mac_proto);
++>>>>>>> e2d9d8358cb9 (openvswitch: pass mac_proto to ovs_vport_send)
  
  #endif /* vport.h */
* Unmerged path net/openvswitch/actions.c
diff --git a/net/openvswitch/vport.c b/net/openvswitch/vport.c
index 3e131f6868f2..898ed377b5cc 100644
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@ -481,7 +481,7 @@ static unsigned int packet_length(const struct sk_buff *skb,
 	return length;
 }
 
-void ovs_vport_send(struct vport *vport, struct sk_buff *skb)
+void ovs_vport_send(struct vport *vport, struct sk_buff *skb, u8 mac_proto)
 {
 	int mtu = vport->dev->mtu;
 
* Unmerged path net/openvswitch/vport.h
