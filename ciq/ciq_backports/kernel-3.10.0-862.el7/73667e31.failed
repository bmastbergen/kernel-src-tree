x86/hyperv: Hide unused label

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 73667e31a153a66da97feb1584726222504924f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/73667e31.failed

This new 32-bit warning just showed up:

arch/x86/hyperv/hv_init.c: In function 'hyperv_init':
arch/x86/hyperv/hv_init.c:167:1: error: label 'register_msr_cs' defined but not used [-Werror=unused-label]

The easiest solution is to move the label up into the existing #ifdef that
has the goto.

Fixes: dee863b571b0 ("hv: export current Hyper-V clocksource")
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Acked-by: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: devel@linuxdriverproject.org
	Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
Link: http://lkml.kernel.org/r/20170214211736.2641241-1-arnd@arndb.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 73667e31a153a66da97feb1584726222504924f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,8bef70e7f3cc..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -58,8 -135,61 +58,44 @@@ void hyperv_init(void
  	hypercall_msr.enable = 1;
  	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);
  	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Register Hyper-V specific clocksource.
+ 	 */
+ #ifdef CONFIG_X86_64
+ 	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
+ 		union hv_x64_msr_hypercall_contents tsc_msr;
+ 
+ 		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
+ 		if (!tsc_pg)
+ 			goto register_msr_cs;
+ 
+ 		hyperv_cs = &hyperv_cs_tsc;
+ 
+ 		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 
+ 		tsc_msr.enable = 1;
+ 		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
+ 
+ 		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+ 		return;
+ 	}
+ register_msr_cs:
+ #endif
+ 	/*
+ 	 * For 32 bit guests just use the MSR based mechanism for reading
+ 	 * the partition counter.
+ 	 */
+ 
+ 	hyperv_cs = &hyperv_cs_msr;
+ 	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
+ 		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
++>>>>>>> 73667e31a153 (x86/hyperv: Hide unused label)
  }
  
 -/*
 - * This routine is called before kexec/kdump, it does the required cleanup.
 - */
 -void hyperv_cleanup(void)
 -{
 -	union hv_x64_msr_hypercall_contents hypercall_msr;
 -
 -	/* Reset our OS id */
 -	wrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);
 -
 -	/* Reset the hypercall page */
 -	hypercall_msr.as_uint64 = 0;
 -	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 -
 -	/* Reset the TSC page */
 -	hypercall_msr.as_uint64 = 0;
 -	wrmsrl(HV_X64_MSR_REFERENCE_TSC, hypercall_msr.as_uint64);
 -}
 -EXPORT_SYMBOL_GPL(hyperv_cleanup);
 -
  /*
   * hv_do_hypercall- Invoke the specified hypercall
   */
* Unmerged path arch/x86/hyperv/hv_init.c
