ovl: handle rename when upper doesn't support xattr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 21a228781104ae6fed7e720137ab024575071feb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/21a22878.failed

On failure to set opaque/redirect xattr on rename, skip setting xattr and
return -EXDEV.

On failure to set opaque xattr when creating a new directory, -EIO is
returned instead of -EOPNOTSUPP.

Any failure to set those xattr will be recorded in super block and
then setting any xattr on upper won't be attempted again.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 21a228781104ae6fed7e720137ab024575071feb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/dir.c
index 09ee239b1762,80e0e202a346..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -121,40 -127,28 +121,61 @@@ int ovl_create_real(struct inode *dir, 
  	return err;
  }
  
++<<<<<<< HEAD
 +static int ovl_set_opaque(struct dentry *upperdentry)
 +{
 +	return ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, "y", 1, 0);
 +}
 +
 +static int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,
 +			 struct kstat *stat)
++=======
+ static int ovl_set_opaque_xerr(struct dentry *dentry, struct dentry *upper,
+ 			       int xerr)
++>>>>>>> 21a228781104 (ovl: handle rename when upper doesn't support xattr)
  {
  	int err;
 +	enum ovl_path_type type;
 +	struct path realpath;
 +	const struct cred *old_cred;
  
++<<<<<<< HEAD
 +	type = ovl_path_real(dentry, &realpath);
 +	old_cred = ovl_override_creds(dentry->d_sb);
 +	err = vfs_getattr(&realpath, stat);
 +	revert_creds(old_cred);
 +	if (err)
 +		return err;
++=======
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_OPAQUE, "y", 1, xerr);
+ 	if (!err)
+ 		ovl_dentry_set_opaque(dentry);
++>>>>>>> 21a228781104 (ovl: handle rename when upper doesn't support xattr)
  
 -	return err;
 +	stat->dev = dentry->d_sb->s_dev;
 +	stat->ino = dentry->d_inode->i_ino;
 +
 +	/*
 +	 * It's probably not worth it to count subdirs to get the
 +	 * correct link count.  nlink=1 seems to pacify 'find' and
 +	 * other utilities.
 +	 */
 +	if (OVL_TYPE_MERGE(type))
 +		stat->nlink = 1;
 +
 +	return 0;
  }
  
+ static int ovl_set_opaque(struct dentry *dentry, struct dentry *upperdentry)
+ {
+ 	/*
+ 	 * Fail with -EIO when trying to create opaque dir and upper doesn't
+ 	 * support xattrs. ovl_rename() calls ovl_set_opaque_xerr(-EXDEV) to
+ 	 * return a specific error for noxattr case.
+ 	 */
+ 	return ovl_set_opaque_xerr(dentry, upperdentry, -EIO);
+ }
+ 
  /* Common operations required to be done after creation of file on upper */
  static void ovl_instantiate(struct dentry *dentry, struct inode *inode,
  			    struct dentry *newdentry, bool hardlink)
@@@ -813,6 -772,107 +834,110 @@@ static int ovl_rmdir(struct inode *dir
  	return ovl_do_remove(dentry, true);
  }
  
++<<<<<<< HEAD
++=======
+ static bool ovl_type_merge_or_lower(struct dentry *dentry)
+ {
+ 	enum ovl_path_type type = ovl_path_type(dentry);
+ 
+ 	return OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type);
+ }
+ 
+ static bool ovl_can_move(struct dentry *dentry)
+ {
+ 	return ovl_redirect_dir(dentry->d_sb) ||
+ 		!d_is_dir(dentry) || !ovl_type_merge_or_lower(dentry);
+ }
+ 
+ static char *ovl_get_redirect(struct dentry *dentry, bool samedir)
+ {
+ 	char *buf, *ret;
+ 	struct dentry *d, *tmp;
+ 	int buflen = ovl_redirect_max + 1;
+ 
+ 	if (samedir) {
+ 		ret = kstrndup(dentry->d_name.name, dentry->d_name.len,
+ 			       GFP_KERNEL);
+ 		goto out;
+ 	}
+ 
+ 	buf = ret = kmalloc(buflen, GFP_TEMPORARY);
+ 	if (!buf)
+ 		goto out;
+ 
+ 	buflen--;
+ 	buf[buflen] = '\0';
+ 	for (d = dget(dentry); !IS_ROOT(d);) {
+ 		const char *name;
+ 		int thislen;
+ 
+ 		spin_lock(&d->d_lock);
+ 		name = ovl_dentry_get_redirect(d);
+ 		if (name) {
+ 			thislen = strlen(name);
+ 		} else {
+ 			name = d->d_name.name;
+ 			thislen = d->d_name.len;
+ 		}
+ 
+ 		/* If path is too long, fall back to userspace move */
+ 		if (thislen + (name[0] != '/') > buflen) {
+ 			ret = ERR_PTR(-EXDEV);
+ 			spin_unlock(&d->d_lock);
+ 			goto out_put;
+ 		}
+ 
+ 		buflen -= thislen;
+ 		memcpy(&buf[buflen], name, thislen);
+ 		tmp = dget_dlock(d->d_parent);
+ 		spin_unlock(&d->d_lock);
+ 
+ 		dput(d);
+ 		d = tmp;
+ 
+ 		/* Absolute redirect: finished */
+ 		if (buf[buflen] == '/')
+ 			break;
+ 		buflen--;
+ 		buf[buflen] = '/';
+ 	}
+ 	ret = kstrdup(&buf[buflen], GFP_KERNEL);
+ out_put:
+ 	dput(d);
+ 	kfree(buf);
+ out:
+ 	return ret ? ret : ERR_PTR(-ENOMEM);
+ }
+ 
+ static int ovl_set_redirect(struct dentry *dentry, bool samedir)
+ {
+ 	int err;
+ 	const char *redirect = ovl_dentry_get_redirect(dentry);
+ 
+ 	if (redirect && (samedir || redirect[0] == '/'))
+ 		return 0;
+ 
+ 	redirect = ovl_get_redirect(dentry, samedir);
+ 	if (IS_ERR(redirect))
+ 		return PTR_ERR(redirect);
+ 
+ 	err = ovl_check_setxattr(dentry, ovl_dentry_upper(dentry),
+ 				 OVL_XATTR_REDIRECT,
+ 				 redirect, strlen(redirect), -EXDEV);
+ 	if (!err) {
+ 		spin_lock(&dentry->d_lock);
+ 		ovl_dentry_set_redirect(dentry, redirect);
+ 		spin_unlock(&dentry->d_lock);
+ 	} else {
+ 		kfree(redirect);
+ 		pr_warn_ratelimited("overlay: failed to set redirect (%i)\n", err);
+ 		/* Fall back to userspace copy-up */
+ 		err = -EXDEV;
+ 	}
+ 	return err;
+ }
+ 
++>>>>>>> 21a228781104 (ovl: handle rename when upper doesn't support xattr)
  static int ovl_rename(struct inode *olddir, struct dentry *old,
  		      struct inode *newdir, struct dentry *new,
  		      unsigned int flags)
@@@ -957,18 -996,22 +1082,35 @@@
  	if (WARN_ON(olddentry->d_inode == newdentry->d_inode))
  		goto out_dput;
  
++<<<<<<< HEAD
 +	if (is_dir && !old_opaque && ovl_lower_positive(new)) {
 +		err = ovl_set_opaque(olddentry);
++=======
+ 	err = 0;
+ 	if (is_dir) {
+ 		if (ovl_type_merge_or_lower(old))
+ 			err = ovl_set_redirect(old, samedir);
+ 		else if (!old_opaque && ovl_type_merge(new->d_parent))
+ 			err = ovl_set_opaque_xerr(old, olddentry, -EXDEV);
++>>>>>>> 21a228781104 (ovl: handle rename when upper doesn't support xattr)
  		if (err)
  			goto out_dput;
 +		ovl_dentry_set_opaque(old, true);
  	}
++<<<<<<< HEAD
 +	if (!overwrite &&
 +	    new_is_dir && !new_opaque && ovl_lower_positive(old)) {
 +		err = ovl_set_opaque(newdentry);
++=======
+ 	if (!overwrite && new_is_dir) {
+ 		if (ovl_type_merge_or_lower(new))
+ 			err = ovl_set_redirect(new, samedir);
+ 		else if (!new_opaque && ovl_type_merge(old->d_parent))
+ 			err = ovl_set_opaque_xerr(new, newdentry, -EXDEV);
++>>>>>>> 21a228781104 (ovl: handle rename when upper doesn't support xattr)
  		if (err)
  			goto out_dput;
 +		ovl_dentry_set_opaque(new, true);
  	}
  
  	err = ovl_do_rename(old_upperdir->d_inode, olddentry,
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,505b18b56330..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -200,29 +151,49 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_inode_init(struct inode *inode, struct inode *realinode,
+ 		    bool is_upper);
+ void ovl_inode_update(struct inode *inode, struct inode *upperinode);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ 
+ /* namei.c */
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> 21a228781104 (ovl: handle rename when upper doesn't support xattr)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/util.c
