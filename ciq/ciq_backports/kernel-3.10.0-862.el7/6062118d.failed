net/mlx5: FPGA, Add FW commands for FPGA QPs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: FPGA, Add FW commands for FPGA QPs (Kamal Heib) [1456677 1456694]
Rebuild_FUZZ: 95.24%
commit-author Ilan Tayari <ilant@mellanox.com>
commit 6062118d5cd2b90369278cdf831aeffb84ae3943
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6062118d.failed

The FPGA QP is a high-bandwidth communication channel between the host
CPU and the FPGA device. It allows performing DMA operations between
host memory and the FPGA logic via the ConnectX chip.

Add ConnectX FW commands which create and manipulate FPGA QPs.

	Signed-off-by: Ilan Tayari <ilant@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6062118d5cd2b90369278cdf831aeffb84ae3943)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
#	include/linux/mlx5/mlx5_ifc_fpga.h
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,8308ccbad85a..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -30,33 -30,133 +30,138 @@@
   * SOFTWARE.
   */
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
++=======
+ #include <linux/etherdevice.h>
+ #include <linux/mlx5/cmd.h>
+ #include <linux/mlx5/driver.h>
+ #include <linux/mlx5/device.h>
++>>>>>>> 6062118d5cd2 (net/mlx5: FPGA, Add FW commands for FPGA QPs):drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.c
  
 -#include "mlx5_core.h"
 -#include "fpga/cmd.h"
 -
 -int mlx5_fpga_caps(struct mlx5_core_dev *dev, u32 *caps)
 -{
 -	u32 in[MLX5_ST_SZ_DW(fpga_cap)] = {0};
 -
 -	return mlx5_core_access_reg(dev, in, sizeof(in), caps,
 -				    MLX5_ST_SZ_BYTES(fpga_cap),
 -				    MLX5_REG_FPGA_CAP, 0, 0);
 -}
 +#include "ipath_kernel.h"
  
 -int mlx5_fpga_query(struct mlx5_core_dev *dev, struct mlx5_fpga_query *query)
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
  {
 -	u32 in[MLX5_ST_SZ_DW(fpga_ctrl)] = {0};
 -	u32 out[MLX5_ST_SZ_DW(fpga_ctrl)];
 -	int err;
 -
 -	err = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),
 -				   MLX5_REG_FPGA_CTRL, 0, false);
 -	if (err)
 -		return err;
 -
 -	query->status = MLX5_GET(fpga_ctrl, out, status);
 -	query->admin_image = MLX5_GET(fpga_ctrl, out, flash_select_admin);
 -	query->oper_image = MLX5_GET(fpga_ctrl, out, flash_select_oper);
  	return 0;
  }
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
 +{
 +	return 1;
++=======
+ int mlx5_fpga_create_qp(struct mlx5_core_dev *dev, void *fpga_qpc,
+ 			u32 *fpga_qpn)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(fpga_create_qp_in)] = {0};
+ 	u32 out[MLX5_ST_SZ_DW(fpga_create_qp_out)];
+ 	int ret;
+ 
+ 	MLX5_SET(fpga_create_qp_in, in, opcode, MLX5_CMD_OP_FPGA_CREATE_QP);
+ 	memcpy(MLX5_ADDR_OF(fpga_create_qp_in, in, fpga_qpc), fpga_qpc,
+ 	       MLX5_FLD_SZ_BYTES(fpga_create_qp_in, fpga_qpc));
+ 
+ 	ret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ 	if (ret)
+ 		return ret;
+ 
+ 	memcpy(fpga_qpc, MLX5_ADDR_OF(fpga_create_qp_out, out, fpga_qpc),
+ 	       MLX5_FLD_SZ_BYTES(fpga_create_qp_out, fpga_qpc));
+ 	*fpga_qpn = MLX5_GET(fpga_create_qp_out, out, fpga_qpn);
+ 	return ret;
+ }
+ 
+ int mlx5_fpga_modify_qp(struct mlx5_core_dev *dev, u32 fpga_qpn,
+ 			enum mlx5_fpga_qpc_field_select fields,
+ 			void *fpga_qpc)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(fpga_modify_qp_in)] = {0};
+ 	u32 out[MLX5_ST_SZ_DW(fpga_modify_qp_out)];
+ 
+ 	MLX5_SET(fpga_modify_qp_in, in, opcode, MLX5_CMD_OP_FPGA_MODIFY_QP);
+ 	MLX5_SET(fpga_modify_qp_in, in, field_select, fields);
+ 	MLX5_SET(fpga_modify_qp_in, in, fpga_qpn, fpga_qpn);
+ 	memcpy(MLX5_ADDR_OF(fpga_modify_qp_in, in, fpga_qpc), fpga_qpc,
+ 	       MLX5_FLD_SZ_BYTES(fpga_modify_qp_in, fpga_qpc));
+ 
+ 	return mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ }
+ 
+ int mlx5_fpga_query_qp(struct mlx5_core_dev *dev,
+ 		       u32 fpga_qpn, void *fpga_qpc)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(fpga_query_qp_in)] = {0};
+ 	u32 out[MLX5_ST_SZ_DW(fpga_query_qp_out)];
+ 	int ret;
+ 
+ 	MLX5_SET(fpga_query_qp_in, in, opcode, MLX5_CMD_OP_FPGA_QUERY_QP);
+ 	MLX5_SET(fpga_query_qp_in, in, fpga_qpn, fpga_qpn);
+ 
+ 	ret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ 	if (ret)
+ 		return ret;
+ 
+ 	memcpy(fpga_qpc, MLX5_ADDR_OF(fpga_query_qp_out, in, fpga_qpc),
+ 	       MLX5_FLD_SZ_BYTES(fpga_query_qp_out, fpga_qpc));
+ 	return ret;
+ }
+ 
+ int mlx5_fpga_destroy_qp(struct mlx5_core_dev *dev, u32 fpga_qpn)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(fpga_destroy_qp_in)] = {0};
+ 	u32 out[MLX5_ST_SZ_DW(fpga_destroy_qp_out)];
+ 
+ 	MLX5_SET(fpga_destroy_qp_in, in, opcode, MLX5_CMD_OP_FPGA_DESTROY_QP);
+ 	MLX5_SET(fpga_destroy_qp_in, in, fpga_qpn, fpga_qpn);
+ 
+ 	return mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ }
+ 
+ int mlx5_fpga_query_qp_counters(struct mlx5_core_dev *dev, u32 fpga_qpn,
+ 				bool clear, struct mlx5_fpga_qp_counters *data)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(fpga_query_qp_counters_in)] = {0};
+ 	u32 out[MLX5_ST_SZ_DW(fpga_query_qp_counters_out)];
+ 	int ret;
+ 
+ 	MLX5_SET(fpga_query_qp_counters_in, in, opcode,
+ 		 MLX5_CMD_OP_FPGA_QUERY_QP_COUNTERS);
+ 	MLX5_SET(fpga_query_qp_counters_in, in, clear, clear);
+ 	MLX5_SET(fpga_query_qp_counters_in, in, fpga_qpn, fpga_qpn);
+ 
+ 	ret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ 	if (ret)
+ 		return ret;
+ 
+ 	data->rx_ack_packets = MLX5_GET64(fpga_query_qp_counters_out, out,
+ 					  rx_ack_packets);
+ 	data->rx_send_packets = MLX5_GET64(fpga_query_qp_counters_out, out,
+ 					   rx_send_packets);
+ 	data->tx_ack_packets = MLX5_GET64(fpga_query_qp_counters_out, out,
+ 					  tx_ack_packets);
+ 	data->tx_send_packets = MLX5_GET64(fpga_query_qp_counters_out, out,
+ 					   tx_send_packets);
+ 	data->rx_total_drop = MLX5_GET64(fpga_query_qp_counters_out, out,
+ 					 rx_total_drop);
+ 
+ 	return ret;
++>>>>>>> 6062118d5cd2 (net/mlx5: FPGA, Add FW commands for FPGA QPs):drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.c
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
index 89bca182464c,b851580d846f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
@@@ -30,24 -30,51 +30,52 @@@
   * SOFTWARE.
   */
  
 -#ifndef __MLX5_FPGA_H__
 -#define __MLX5_FPGA_H__
 +#ifndef __MLX5E_IPOB_H__
 +#define __MLX5E_IPOB_H__
  
 -#include <linux/mlx5/driver.h>
 +#include <linux/mlx5/fs.h>
 +#include "en.h"
  
 -enum mlx5_fpga_image {
 -	MLX5_FPGA_IMAGE_USER = 0,
 -	MLX5_FPGA_IMAGE_FACTORY,
 -};
 +#define MLX5I_MAX_NUM_TC 1
  
 -enum mlx5_fpga_status {
 -	MLX5_FPGA_STATUS_SUCCESS = 0,
 -	MLX5_FPGA_STATUS_FAILURE = 1,
 -	MLX5_FPGA_STATUS_IN_PROGRESS = 2,
 -	MLX5_FPGA_STATUS_NONE = 0xFFFF,
 +/* ipoib rdma netdev's private data structure */
 +struct mlx5i_priv {
 +	struct mlx5_core_qp qp;
 +	char  *mlx5e_priv[0];
  };
  
 -struct mlx5_fpga_query {
 -	enum mlx5_fpga_image admin_image;
 -	enum mlx5_fpga_image oper_image;
 -	enum mlx5_fpga_status status;
 -};
 +/* Extract mlx5e_priv from IPoIB netdev */
 +#define mlx5i_epriv(netdev) ((void *)(((struct mlx5i_priv *)netdev_priv(netdev))->mlx5e_priv))
 +
 +netdev_tx_t mlx5i_sq_xmit(struct mlx5e_txqsq *sq, struct sk_buff *skb,
 +			  struct mlx5_av *av, u32 dqpn, u32 dqkey);
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
 +#endif /* __MLX5E_IPOB_H__ */
++=======
+ enum mlx5_fpga_qpc_field_select {
+ 	MLX5_FPGA_QPC_STATE = BIT(0),
+ };
+ 
+ struct mlx5_fpga_qp_counters {
+ 	u64 rx_ack_packets;
+ 	u64 rx_send_packets;
+ 	u64 tx_ack_packets;
+ 	u64 tx_send_packets;
+ 	u64 rx_total_drop;
+ };
+ 
+ int mlx5_fpga_caps(struct mlx5_core_dev *dev, u32 *caps);
+ int mlx5_fpga_query(struct mlx5_core_dev *dev, struct mlx5_fpga_query *query);
+ 
+ int mlx5_fpga_create_qp(struct mlx5_core_dev *dev, void *fpga_qpc,
+ 			u32 *fpga_qpn);
+ int mlx5_fpga_modify_qp(struct mlx5_core_dev *dev, u32 fpga_qpn,
+ 			enum mlx5_fpga_qpc_field_select fields, void *fpga_qpc);
+ int mlx5_fpga_query_qp(struct mlx5_core_dev *dev, u32 fpga_qpn, void *fpga_qpc);
+ int mlx5_fpga_query_qp_counters(struct mlx5_core_dev *dev, u32 fpga_qpn,
+ 				bool clear, struct mlx5_fpga_qp_counters *data);
+ int mlx5_fpga_destroy_qp(struct mlx5_core_dev *dev, u32 fpga_qpn);
+ 
+ #endif /* __MLX5_FPGA_H__ */
++>>>>>>> 6062118d5cd2 (net/mlx5: FPGA, Add FW commands for FPGA QPs):drivers/net/ethernet/mellanox/mlx5/core/fpga/cmd.h
* Unmerged path include/linux/mlx5/mlx5_ifc_fpga.h
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index 3442081306c0..12314a7a5f57 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -309,6 +309,7 @@ static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,
 	case MLX5_CMD_OP_SET_FLOW_TABLE_ROOT:
 	case MLX5_CMD_OP_DEALLOC_ENCAP_HEADER:
 	case MLX5_CMD_OP_DEALLOC_MODIFY_HEADER_CONTEXT:
+	case MLX5_CMD_OP_FPGA_DESTROY_QP:
 		return MLX5_CMD_STAT_OK;
 
 	case MLX5_CMD_OP_QUERY_HCA_CAP:
@@ -421,6 +422,10 @@ static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,
 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
 	case MLX5_CMD_OP_ALLOC_ENCAP_HEADER:
 	case MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT:
+	case MLX5_CMD_OP_FPGA_CREATE_QP:
+	case MLX5_CMD_OP_FPGA_MODIFY_QP:
+	case MLX5_CMD_OP_FPGA_QUERY_QP:
+	case MLX5_CMD_OP_FPGA_QUERY_QP_COUNTERS:
 		*status = MLX5_DRIVER_STATUS_ABORTED;
 		*synd = MLX5_DRIVER_SYND;
 		return -EIO;
@@ -587,6 +592,11 @@ const char *mlx5_command_str(int command)
 	MLX5_COMMAND_STR_CASE(DEALLOC_ENCAP_HEADER);
 	MLX5_COMMAND_STR_CASE(ALLOC_MODIFY_HEADER_CONTEXT);
 	MLX5_COMMAND_STR_CASE(DEALLOC_MODIFY_HEADER_CONTEXT);
+	MLX5_COMMAND_STR_CASE(FPGA_CREATE_QP);
+	MLX5_COMMAND_STR_CASE(FPGA_MODIFY_QP);
+	MLX5_COMMAND_STR_CASE(FPGA_QUERY_QP);
+	MLX5_COMMAND_STR_CASE(FPGA_QUERY_QP_COUNTERS);
+	MLX5_COMMAND_STR_CASE(FPGA_DESTROY_QP);
 	default: return "unknown command opcode";
 	}
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index fc41d24d9548..5807866d213c 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -230,6 +230,11 @@ enum {
 	MLX5_CMD_OP_DEALLOC_ENCAP_HEADER          = 0x93e,
 	MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT   = 0x940,
 	MLX5_CMD_OP_DEALLOC_MODIFY_HEADER_CONTEXT = 0x941,
+	MLX5_CMD_OP_FPGA_CREATE_QP                = 0x960,
+	MLX5_CMD_OP_FPGA_MODIFY_QP                = 0x961,
+	MLX5_CMD_OP_FPGA_QUERY_QP                 = 0x962,
+	MLX5_CMD_OP_FPGA_DESTROY_QP               = 0x963,
+	MLX5_CMD_OP_FPGA_QUERY_QP_COUNTERS        = 0x964,
 	MLX5_CMD_OP_MAX
 };
 
* Unmerged path include/linux/mlx5/mlx5_ifc_fpga.h
