qed: Rename some ll2 related defines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kalderon, Michal <Michal.Kalderon@cavium.com>
commit 526d1d05e456c9cfc077694d18b5f521e2338f18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/526d1d05.failed

Make some names more generic as they will be used by iWARP too.

	Signed-off-by: Michal Kalderon <Michal.Kalderon@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: Ariel Elior <Ariel.Elior@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 526d1d05e456c9cfc077694d18b5f521e2338f18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_ll2.c
#	include/linux/qed/qed_ll2_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_ll2.c
index 6b0af0a3aa1a,e235fb267ab9..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_ll2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_ll2.c
@@@ -315,7 -309,7 +315,11 @@@ static void qed_ll2_txq_flush(struct qe
  		list_del(&p_pkt->list_entry);
  		b_last_packet = list_empty(&p_tx->active_descq);
  		list_add_tail(&p_pkt->list_entry, &p_tx->free_descq);
++<<<<<<< HEAD
 +		if (p_ll2_conn->conn.conn_type == QED_LL2_TYPE_ISCSI_OOO) {
++=======
+ 		if (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO) {
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  			struct qed_ooo_buffer *p_buffer;
  
  			p_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;
@@@ -587,7 -532,7 +591,11 @@@ static void qed_ll2_rxq_flush(struct qe
  
  		list_move_tail(&p_pkt->list_entry, &p_rx->free_descq);
  
++<<<<<<< HEAD
 +		if (p_ll2_conn->conn.conn_type == QED_LL2_TYPE_ISCSI_OOO) {
++=======
+ 		if (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO) {
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  			struct qed_ooo_buffer *p_buffer;
  
  			p_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;
@@@ -1084,11 -890,10 +1092,10 @@@ static int qed_sp_ll2_rx_queue_start(st
  	DMA_REGPAIR_LE(p_ramrod->cqe_pbl_addr,
  		       qed_chain_get_pbl_phys(&p_rx->rcq_chain));
  
 -	p_ramrod->drop_ttl0_flg = p_ll2_conn->input.rx_drop_ttl0_flg;
 -	p_ramrod->inner_vlan_removal_en = p_ll2_conn->input.rx_vlan_removal_en;
 +	p_ramrod->drop_ttl0_flg = p_ll2_conn->conn.rx_drop_ttl0_flg;
 +	p_ramrod->inner_vlan_removal_en = p_ll2_conn->conn.rx_vlan_removal_en;
  	p_ramrod->queue_id = p_ll2_conn->queue_id;
- 	p_ramrod->main_func_queue = (conn_type == QED_LL2_TYPE_ISCSI_OOO) ? 0
- 									  : 1;
+ 	p_ramrod->main_func_queue = (conn_type == QED_LL2_TYPE_OOO) ? 0 : 1;
  
  	if ((IS_MF_DEFAULT(p_hwfn) || IS_MF_SI(p_hwfn)) &&
  	    p_ramrod->main_func_queue && (conn_type != QED_LL2_TYPE_ROCE)) {
@@@ -1118,7 -923,7 +1125,11 @@@ static int qed_sp_ll2_tx_queue_start(st
  	if (!QED_LL2_TX_REGISTERED(p_ll2_conn))
  		return 0;
  
++<<<<<<< HEAD
 +	if (p_ll2_conn->conn.conn_type == QED_LL2_TYPE_ISCSI_OOO)
++=======
+ 	if (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO)
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  		p_ll2_conn->tx_stats_en = 0;
  	else
  		p_ll2_conn->tx_stats_en = 1;
@@@ -1148,11 -953,11 +1159,16 @@@
  	pbl_size = qed_chain_get_page_cnt(&p_tx->txq_chain);
  	p_ramrod->pbl_size = cpu_to_le16(pbl_size);
  
++<<<<<<< HEAD
 +	switch (p_ll2_conn->conn.tx_tc) {
 +	case LB_TC:
++=======
+ 	switch (p_ll2_conn->input.tx_tc) {
+ 	case PURE_LB_TC:
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  		pq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_LB);
  		break;
- 	case OOO_LB_TC:
+ 	case PKT_LB_TC:
  		pq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OOO);
  		break;
  	default:
@@@ -1327,18 -1132,102 +1343,107 @@@ out
  	return rc;
  }
  
 -static int
 -qed_ll2_acquire_connection_ooo(struct qed_hwfn *p_hwfn,
 -			       struct qed_ll2_info *p_ll2_info, u16 mtu)
 +int qed_ll2_acquire_connection(struct qed_hwfn *p_hwfn,
 +			       struct qed_ll2_conn *p_params,
 +			       u16 rx_num_desc,
 +			       u16 tx_num_desc,
 +			       u8 *p_connection_handle)
  {
++<<<<<<< HEAD
++=======
+ 	struct qed_ooo_buffer *p_buf = NULL;
+ 	void *p_virt;
+ 	u16 buf_idx;
+ 	int rc = 0;
+ 
+ 	if (p_ll2_info->input.conn_type != QED_LL2_TYPE_OOO)
+ 		return rc;
+ 
+ 	/* Correct number of requested OOO buffers if needed */
+ 	if (!p_ll2_info->input.rx_num_ooo_buffers) {
+ 		u16 num_desc = p_ll2_info->input.rx_num_desc;
+ 
+ 		if (!num_desc)
+ 			return -EINVAL;
+ 		p_ll2_info->input.rx_num_ooo_buffers = num_desc * 2;
+ 	}
+ 
+ 	for (buf_idx = 0; buf_idx < p_ll2_info->input.rx_num_ooo_buffers;
+ 	     buf_idx++) {
+ 		p_buf = kzalloc(sizeof(*p_buf), GFP_KERNEL);
+ 		if (!p_buf) {
+ 			rc = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		p_buf->rx_buffer_size = mtu + 26 + ETH_CACHE_LINE_SIZE;
+ 		p_buf->rx_buffer_size = (p_buf->rx_buffer_size +
+ 					 ETH_CACHE_LINE_SIZE - 1) &
+ 					~(ETH_CACHE_LINE_SIZE - 1);
+ 		p_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,
+ 					    p_buf->rx_buffer_size,
+ 					    &p_buf->rx_buffer_phys_addr,
+ 					    GFP_KERNEL);
+ 		if (!p_virt) {
+ 			kfree(p_buf);
+ 			rc = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		p_buf->rx_buffer_virt_addr = p_virt;
+ 		qed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info, p_buf);
+ 	}
+ 
+ 	DP_VERBOSE(p_hwfn, QED_MSG_LL2,
+ 		   "Allocated [%04x] LL2 OOO buffers [each of size 0x%08x]\n",
+ 		   p_ll2_info->input.rx_num_ooo_buffers, p_buf->rx_buffer_size);
+ 
+ out:
+ 	return rc;
+ }
+ 
+ static int
+ qed_ll2_set_cbs(struct qed_ll2_info *p_ll2_info, const struct qed_ll2_cbs *cbs)
+ {
+ 	if (!cbs || (!cbs->rx_comp_cb ||
+ 		     !cbs->rx_release_cb ||
+ 		     !cbs->tx_comp_cb || !cbs->tx_release_cb || !cbs->cookie))
+ 		return -EINVAL;
+ 
+ 	p_ll2_info->cbs.rx_comp_cb = cbs->rx_comp_cb;
+ 	p_ll2_info->cbs.rx_release_cb = cbs->rx_release_cb;
+ 	p_ll2_info->cbs.tx_comp_cb = cbs->tx_comp_cb;
+ 	p_ll2_info->cbs.tx_release_cb = cbs->tx_release_cb;
+ 	p_ll2_info->cbs.cookie = cbs->cookie;
+ 
+ 	return 0;
+ }
+ 
+ static enum core_error_handle
+ qed_ll2_get_error_choice(enum qed_ll2_error_handle err)
+ {
+ 	switch (err) {
+ 	case QED_LL2_DROP_PACKET:
+ 		return LL2_DROP_PACKET;
+ 	case QED_LL2_DO_NOTHING:
+ 		return LL2_DO_NOTHING;
+ 	case QED_LL2_ASSERT:
+ 		return LL2_ASSERT;
+ 	default:
+ 		return LL2_DO_NOTHING;
+ 	}
+ }
+ 
+ int qed_ll2_acquire_connection(void *cxt, struct qed_ll2_acquire_data *data)
+ {
+ 	struct qed_hwfn *p_hwfn = cxt;
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  	qed_int_comp_cb_t comp_rx_cb, comp_tx_cb;
  	struct qed_ll2_info *p_ll2_info = NULL;
 -	u8 i, *p_tx_max;
  	int rc;
 +	u8 i;
  
 -	if (!data->p_connection_handle || !p_hwfn->p_ll2_info)
 +	if (!p_connection_handle || !p_hwfn->p_ll2_info)
  		return -EINVAL;
  
  	/* Find a free connection to be used */
@@@ -1373,7 -1279,7 +1478,11 @@@
  		goto q_allocate_fail;
  
  	/* Register callbacks for the Rx/Tx queues */
++<<<<<<< HEAD
 +	if (p_params->conn_type == QED_LL2_TYPE_ISCSI_OOO) {
++=======
+ 	if (data->input.conn_type == QED_LL2_TYPE_OOO) {
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  		comp_rx_cb = qed_ll2_lb_rxq_completion;
  		comp_tx_cb = qed_ll2_lb_txq_completion;
  	} else {
@@@ -1425,8 -1334,20 +1534,21 @@@ static int qed_ll2_establish_connection
  	return qed_sp_ll2_rx_queue_start(p_hwfn, p_ll2_conn, action_on_error);
  }
  
 -static void
 -qed_ll2_establish_connection_ooo(struct qed_hwfn *p_hwfn,
 -				 struct qed_ll2_info *p_ll2_conn)
 +int qed_ll2_establish_connection(struct qed_hwfn *p_hwfn, u8 connection_handle)
  {
++<<<<<<< HEAD
++=======
+ 	if (p_ll2_conn->input.conn_type != QED_LL2_TYPE_OOO)
+ 		return;
+ 
+ 	qed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);
+ 	qed_ooo_submit_rx_buffers(p_hwfn, p_ll2_conn);
+ }
+ 
+ int qed_ll2_establish_connection(void *cxt, u8 connection_handle)
+ {
+ 	struct qed_hwfn *p_hwfn = cxt;
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  	struct qed_ll2_info *p_ll2_conn;
  	struct qed_ll2_rx_queue *p_rx;
  	struct qed_ll2_tx_queue *p_tx;
@@@ -1867,10 -1793,10 +1989,14 @@@ int qed_ll2_terminate_connection(struc
  		qed_ll2_rxq_flush(p_hwfn, connection_handle);
  	}
  
++<<<<<<< HEAD
 +	if (p_ll2_conn->conn.conn_type == QED_LL2_TYPE_ISCSI_OOO)
++=======
+ 	if (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO)
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  		qed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);
  
 -	if (p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE) {
 +	if (p_ll2_conn->conn.conn_type == QED_LL2_TYPE_FCOE) {
  		qed_llh_remove_protocol_filter(p_hwfn, p_ptt,
  					       0x8906, 0,
  					       QED_LLH_FILTER_ETHERTYPE);
@@@ -1884,8 -1810,28 +2010,30 @@@ out
  	return rc;
  }
  
 -static void qed_ll2_release_connection_ooo(struct qed_hwfn *p_hwfn,
 -					   struct qed_ll2_info *p_ll2_conn)
 +void qed_ll2_release_connection(struct qed_hwfn *p_hwfn, u8 connection_handle)
  {
++<<<<<<< HEAD
++=======
+ 	struct qed_ooo_buffer *p_buffer;
+ 
+ 	if (p_ll2_conn->input.conn_type != QED_LL2_TYPE_OOO)
+ 		return;
+ 
+ 	qed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);
+ 	while ((p_buffer = qed_ooo_get_free_buffer(p_hwfn,
+ 						   p_hwfn->p_ooo_info))) {
+ 		dma_free_coherent(&p_hwfn->cdev->pdev->dev,
+ 				  p_buffer->rx_buffer_size,
+ 				  p_buffer->rx_buffer_virt_addr,
+ 				  p_buffer->rx_buffer_phys_addr);
+ 		kfree(p_buffer);
+ 	}
+ }
+ 
+ void qed_ll2_release_connection(void *cxt, u8 connection_handle)
+ {
+ 	struct qed_hwfn *p_hwfn = cxt;
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  	struct qed_ll2_info *p_ll2_conn = NULL;
  
  	p_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);
@@@ -2078,14 -2036,80 +2226,83 @@@ static void qed_ll2_register_cb_ops(str
  	cdev->ll2->cb_cookie = cookie;
  }
  
++<<<<<<< HEAD
++=======
+ struct qed_ll2_cbs ll2_cbs = {
+ 	.rx_comp_cb = &qed_ll2b_complete_rx_packet,
+ 	.rx_release_cb = &qed_ll2b_release_rx_packet,
+ 	.tx_comp_cb = &qed_ll2b_complete_tx_packet,
+ 	.tx_release_cb = &qed_ll2b_complete_tx_packet,
+ };
+ 
+ static void qed_ll2_set_conn_data(struct qed_dev *cdev,
+ 				  struct qed_ll2_acquire_data *data,
+ 				  struct qed_ll2_params *params,
+ 				  enum qed_ll2_conn_type conn_type,
+ 				  u8 *handle, bool lb)
+ {
+ 	memset(data, 0, sizeof(*data));
+ 
+ 	data->input.conn_type = conn_type;
+ 	data->input.mtu = params->mtu;
+ 	data->input.rx_num_desc = QED_LL2_RX_SIZE;
+ 	data->input.rx_drop_ttl0_flg = params->drop_ttl0_packets;
+ 	data->input.rx_vlan_removal_en = params->rx_vlan_stripping;
+ 	data->input.tx_num_desc = QED_LL2_TX_SIZE;
+ 	data->p_connection_handle = handle;
+ 	data->cbs = &ll2_cbs;
+ 	ll2_cbs.cookie = QED_LEADING_HWFN(cdev);
+ 
+ 	if (lb) {
+ 		data->input.tx_tc = PKT_LB_TC;
+ 		data->input.tx_dest = QED_LL2_TX_DEST_LB;
+ 	} else {
+ 		data->input.tx_tc = 0;
+ 		data->input.tx_dest = QED_LL2_TX_DEST_NW;
+ 	}
+ }
+ 
+ static int qed_ll2_start_ooo(struct qed_dev *cdev,
+ 			     struct qed_ll2_params *params)
+ {
+ 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
+ 	u8 *handle = &hwfn->pf_params.iscsi_pf_params.ll2_ooo_queue_id;
+ 	struct qed_ll2_acquire_data data;
+ 	int rc;
+ 
+ 	qed_ll2_set_conn_data(cdev, &data, params,
+ 			      QED_LL2_TYPE_OOO, handle, true);
+ 
+ 	rc = qed_ll2_acquire_connection(hwfn, &data);
+ 	if (rc) {
+ 		DP_INFO(cdev, "Failed to acquire LL2 OOO connection\n");
+ 		goto out;
+ 	}
+ 
+ 	rc = qed_ll2_establish_connection(hwfn, *handle);
+ 	if (rc) {
+ 		DP_INFO(cdev, "Failed to establist LL2 OOO connection\n");
+ 		goto fail;
+ 	}
+ 
+ 	return 0;
+ 
+ fail:
+ 	qed_ll2_release_connection(hwfn, *handle);
+ out:
+ 	*handle = QED_LL2_UNUSED_HANDLE;
+ 	return rc;
+ }
+ 
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  static int qed_ll2_start(struct qed_dev *cdev, struct qed_ll2_params *params)
  {
 +	struct qed_ll2_conn ll2_info;
  	struct qed_ll2_buffer *buffer, *tmp_buffer;
  	enum qed_ll2_conn_type conn_type;
 -	struct qed_ll2_acquire_data data;
  	struct qed_ptt *p_ptt;
  	int rc, i;
 -
 +	u8 gsi_enable = 1;
  
  	/* Initialize LL2 locks & lists */
  	INIT_LIST_HEAD(&cdev->ll2->list);
diff --cc include/linux/qed/qed_ll2_if.h
index 056ac007dd12,c9c56bc42a82..000000000000
--- a/include/linux/qed/qed_ll2_if.h
+++ b/include/linux/qed/qed_ll2_if.h
@@@ -43,6 -43,17 +43,20 @@@
  #include <linux/slab.h>
  #include <linux/qed/qed_if.h>
  
++<<<<<<< HEAD
++=======
+ enum qed_ll2_conn_type {
+ 	QED_LL2_TYPE_FCOE,
+ 	QED_LL2_TYPE_ISCSI,
+ 	QED_LL2_TYPE_TEST,
+ 	QED_LL2_TYPE_OOO,
+ 	QED_LL2_TYPE_RESERVED2,
+ 	QED_LL2_TYPE_ROCE,
+ 	QED_LL2_TYPE_RESERVED3,
+ 	MAX_QED_LL2_RX_CONN_TYPE
+ };
+ 
++>>>>>>> 526d1d05e456 (qed: Rename some ll2 related defines)
  enum qed_ll2_roce_flavor_type {
  	QED_LL2_ROCE,
  	QED_LL2_RROCE,
diff --git a/drivers/net/ethernet/qlogic/qed/qed.h b/drivers/net/ethernet/qlogic/qed/qed.h
index 848905e401aa..5247aafdeb7a 100644
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@ -719,7 +719,7 @@ static inline u8 qed_concrete_to_sw_fid(struct qed_dev *cdev,
 }
 
 #define PURE_LB_TC 8
-#define OOO_LB_TC 9
+#define PKT_LB_TC 9
 
 int qed_configure_vport_wfq(struct qed_dev *cdev, u16 vp_id, u32 rate);
 void qed_configure_vp_wfq_on_link_change(struct qed_dev *cdev,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ll2.c
* Unmerged path include/linux/qed/qed_ll2_if.h
