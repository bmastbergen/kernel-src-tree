qla2xxx: Properly initialize IO statistics.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Properly initialize IO statistics (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 98.82%
commit-author Joe Carnuccio <joe.carnuccio@qlogic.com>
commit fc90adaf05ada86d3fcd145045eac32ad81f41e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fc90adaf.failed

Properly initialize IO statistics to avoid initial 0xFFFFFFF (-1) values.

Cleanup/simplify usage of pointer to statistics structure.

	Signed-off-by: Joe Carnuccio <joe.carnuccio@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit fc90adaf05ada86d3fcd145045eac32ad81f41e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7d14b62f83a6,bff9689f5ca9..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -179,9 -208,35 +179,39 @@@ struct scsi_qla_host *qlt_find_host_by_
  	return NULL;
  }
  
 -static inline void qlt_incr_num_pend_cmds(struct scsi_qla_host *vha)
 +void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
 +	struct atio_from_isp *atio)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 
+ 	vha->hw->tgt.num_pend_cmds++;
+ 	if (vha->hw->tgt.num_pend_cmds > vha->qla_stats.stat_max_pend_cmds)
+ 		vha->qla_stats.stat_max_pend_cmds =
+ 			vha->hw->tgt.num_pend_cmds;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ static inline void qlt_decr_num_pend_cmds(struct scsi_qla_host *vha)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 	vha->hw->tgt.num_pend_cmds--;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ 
+ static bool qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint8_t ha_locked)
+ {
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe072,
+ 		"%s: qla_target(%d): type %x ox_id %04x\n",
+ 		__func__, vha->vp_idx, atio->u.raw.entry_type,
+ 		be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));
+ 
++>>>>>>> fc90adaf05ad (qla2xxx: Properly initialize IO statistics.)
  	switch (atio->u.raw.entry_type) {
  	case ATIO_TYPE7:
  	{
@@@ -3635,6 -5203,189 +3665,192 @@@ static void qlt_send_busy(struct scsi_q
  	/* Memory Barrier */
  	wmb();
  	qla2x00_start_iocbs(vha, vha->req);
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ /*
+  * This routine is used to allocate a command for either a QFull condition
+  * (ie reply SAM_STAT_BUSY) or to terminate an exchange that did not go
+  * out previously.
+  */
+ static void
+ qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull)
+ {
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_tgt_sess *sess;
+ 	struct se_session *se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	if (unlikely(tgt->tgt_stop)) {
+ 		ql_dbg(ql_dbg_io, vha, 0x300a,
+ 			"New command while device %p is shutting down\n", tgt);
+ 		return;
+ 	}
+ 
+ 	if ((vha->hw->tgt.num_qfull_cmds_alloc + 1) > MAX_QFULL_CMDS_ALLOC) {
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0x3068,
+ 			"qla_target(%d): %s: QFull CMD dropped[%d]\n",
+ 			vha->vp_idx, __func__,
+ 			vha->hw->tgt.num_qfull_cmds_dropped);
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	sess = ha->tgt.tgt_ops->find_sess_by_s_id
+ 		(vha, atio->u.isp24.fcp_hdr.s_id);
+ 	if (!sess)
+ 		return;
+ 
+ 	se_sess = sess->se_sess;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	if (!cmd) {
+ 		ql_dbg(ql_dbg_io, vha, 0x3009,
+ 			"qla_target(%d): %s: Allocation of cmd failed\n",
+ 			vha->vp_idx, __func__);
+ 
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 
+ 	qlt_incr_num_pend_cmds(vha);
+ 	INIT_LIST_HEAD(&cmd->cmd_list);
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	cmd->vha = vha;
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 	cmd->q_full = 1;
+ 
+ 	if (qfull) {
+ 		cmd->q_full = 1;
+ 		/* NOTE: borrowing the state field to carry the status */
+ 		cmd->state = status;
+ 	} else
+ 		cmd->term_exchg = 1;
+ 
+ 	list_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);
+ 
+ 	vha->hw->tgt.num_qfull_cmds_alloc++;
+ 	if (vha->hw->tgt.num_qfull_cmds_alloc >
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc)
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc =
+ 			vha->hw->tgt.num_qfull_cmds_alloc;
+ }
+ 
+ int
+ qlt_free_qfull_cmds(struct scsi_qla_host *vha)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 	struct list_head free_list;
+ 	int rc = 0;
+ 
+ 	if (list_empty(&ha->tgt.q_full_list))
+ 		return 0;
+ 
+ 	INIT_LIST_HEAD(&free_list);
+ 
+ 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
+ 
+ 	if (list_empty(&ha->tgt.q_full_list)) {
+ 		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &ha->tgt.q_full_list, cmd_list) {
+ 		if (cmd->q_full)
+ 			/* cmd->state is a borrowed field to hold status */
+ 			rc = __qlt_send_busy(vha, &cmd->atio, cmd->state);
+ 		else if (cmd->term_exchg)
+ 			rc = __qlt_send_term_exchange(vha, NULL, &cmd->atio);
+ 
+ 		if (rc == -ENOMEM)
+ 			break;
+ 
+ 		if (cmd->q_full)
+ 			ql_dbg(ql_dbg_io, vha, 0x3006,
+ 			    "%s: busy sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else if (cmd->term_exchg)
+ 			ql_dbg(ql_dbg_io, vha, 0x3007,
+ 			    "%s: Term exchg sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else
+ 			ql_dbg(ql_dbg_io, vha, 0x3008,
+ 			    "%s: Unexpected cmd in QFull list %p\n", __func__,
+ 			    cmd);
+ 
+ 		list_del(&cmd->cmd_list);
+ 		list_add_tail(&cmd->cmd_list, &free_list);
+ 
+ 		/* piggy back on hardware_lock for protection */
+ 		vha->hw->tgt.num_qfull_cmds_alloc--;
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ 
+ 	cmd = NULL;
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 		list_del(&cmd->cmd_list);
+ 		/* This cmd was never sent to TCM.  There is no need
+ 		 * to schedule free or call free_cmd
+ 		 */
+ 		qlt_free_cmd(cmd);
+ 	}
+ 	return rc;
+ }
+ 
+ static void
+ qlt_send_busy(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status)
+ {
+ 	int rc = 0;
+ 
+ 	rc = __qlt_send_busy(vha, atio, status);
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, atio, status, 1);
+ }
+ 
+ static int
+ qlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t status;
+ 
+ 	if (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))
+ 		return 0;
+ 
+ 	status = temp_sam_status;
+ 	qlt_send_busy(vha, atio, status);
+ 	return 1;
++>>>>>>> fc90adaf05ad (qla2xxx: Properly initialize IO statistics.)
  }
  
  /* ha->hardware_lock supposed to be held on entry */
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index 23b15e5afee2..5d5dc49b739c 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -1786,10 +1786,9 @@ qla2x00_get_fc_host_stats(struct Scsi_Host *shost)
 	int rval;
 	struct link_statistics *stats;
 	dma_addr_t stats_dma;
-	struct fc_host_statistics *pfc_host_stat;
+	struct fc_host_statistics *p = &vha->fc_host_stat;
 
-	pfc_host_stat = &vha->fc_host_stat;
-	memset(pfc_host_stat, -1, sizeof(struct fc_host_statistics));
+	memset(p, -1, sizeof(*p));
 
 	if (IS_QLAFX00(vha->hw))
 		goto done;
@@ -1825,37 +1824,37 @@ qla2x00_get_fc_host_stats(struct Scsi_Host *shost)
 	if (rval != QLA_SUCCESS)
 		goto done_free;
 
-	pfc_host_stat->link_failure_count = stats->link_fail_cnt;
-	pfc_host_stat->loss_of_sync_count = stats->loss_sync_cnt;
-	pfc_host_stat->loss_of_signal_count = stats->loss_sig_cnt;
-	pfc_host_stat->prim_seq_protocol_err_count = stats->prim_seq_err_cnt;
-	pfc_host_stat->invalid_tx_word_count = stats->inval_xmit_word_cnt;
-	pfc_host_stat->invalid_crc_count = stats->inval_crc_cnt;
+	p->link_failure_count = stats->link_fail_cnt;
+	p->loss_of_sync_count = stats->loss_sync_cnt;
+	p->loss_of_signal_count = stats->loss_sig_cnt;
+	p->prim_seq_protocol_err_count = stats->prim_seq_err_cnt;
+	p->invalid_tx_word_count = stats->inval_xmit_word_cnt;
+	p->invalid_crc_count = stats->inval_crc_cnt;
 	if (IS_FWI2_CAPABLE(ha)) {
-		pfc_host_stat->lip_count = stats->lip_cnt;
-		pfc_host_stat->tx_frames = stats->tx_frames;
-		pfc_host_stat->rx_frames = stats->rx_frames;
-		pfc_host_stat->dumped_frames = stats->discarded_frames;
-		pfc_host_stat->nos_count = stats->nos_rcvd;
-		pfc_host_stat->error_frames =
+		p->lip_count = stats->lip_cnt;
+		p->tx_frames = stats->tx_frames;
+		p->rx_frames = stats->rx_frames;
+		p->dumped_frames = stats->discarded_frames;
+		p->nos_count = stats->nos_rcvd;
+		p->error_frames =
 			stats->dropped_frames + stats->discarded_frames;
-		pfc_host_stat->rx_words = vha->qla_stats.input_bytes;
-		pfc_host_stat->tx_words = vha->qla_stats.output_bytes;
+		p->rx_words = vha->qla_stats.input_bytes;
+		p->tx_words = vha->qla_stats.output_bytes;
 	}
-	pfc_host_stat->fcp_control_requests = vha->qla_stats.control_requests;
-	pfc_host_stat->fcp_input_requests = vha->qla_stats.input_requests;
-	pfc_host_stat->fcp_output_requests = vha->qla_stats.output_requests;
-	pfc_host_stat->fcp_input_megabytes = vha->qla_stats.input_bytes >> 20;
-	pfc_host_stat->fcp_output_megabytes = vha->qla_stats.output_bytes >> 20;
-	pfc_host_stat->seconds_since_last_reset =
+	p->fcp_control_requests = vha->qla_stats.control_requests;
+	p->fcp_input_requests = vha->qla_stats.input_requests;
+	p->fcp_output_requests = vha->qla_stats.output_requests;
+	p->fcp_input_megabytes = vha->qla_stats.input_bytes >> 20;
+	p->fcp_output_megabytes = vha->qla_stats.output_bytes >> 20;
+	p->seconds_since_last_reset =
 		get_jiffies_64() - vha->qla_stats.jiffies_at_last_reset;
-	do_div(pfc_host_stat->seconds_since_last_reset, HZ);
+	do_div(p->seconds_since_last_reset, HZ);
 
 done_free:
 	dma_free_coherent(&ha->pdev->dev, sizeof(struct link_statistics),
 	    stats, stats_dma);
 done:
-	return pfc_host_stat;
+	return p;
 }
 
 static void
@@ -1867,6 +1866,7 @@ qla2x00_reset_host_stats(struct Scsi_Host *shost)
 	struct link_statistics *stats;
 	dma_addr_t stats_dma;
 
+	memset(&vha->qla_stats, 0, sizeof(vha->qla_stats));
 	memset(&vha->fc_host_stat, 0, sizeof(vha->fc_host_stat));
 
 	vha->qla_stats.jiffies_at_last_reset = get_jiffies_64();
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index e18cc36570ad..d73ca077c97a 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -3478,7 +3478,6 @@ struct qla_hw_data {
 	int             cur_vport_count;
 
 	struct qla_chip_state_84xx *cs84xx;
-	struct qla_statistics qla_stats;
 	struct isp_operations *isp_ops;
 	struct workqueue_struct *wq;
 	struct qlfc_fw fw_buf;
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5..c7491d4406aa 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -619,6 +619,9 @@ qla2x00_initialize_adapter(scsi_qla_host_t *vha)
 	struct qla_hw_data *ha = vha->hw;
 	struct req_que *req = ha->req_q_map[0];
 
+	memset(&vha->qla_stats, 0, sizeof(vha->qla_stats));
+	memset(&vha->fc_host_stat, 0, sizeof(vha->fc_host_stat));
+
 	/* Clear adapter flags. */
 	vha->flags.online = 0;
 	ha->flags.chip_reset_done = 0;
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
