mnt: fs_fully_visible enforce noexec and nosuid  if !SB_I_NOEXEC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] mnt: fs_fully_visible enforce noexec and nosuid if !SB_I_NOEXEC ("Eric W. Biederman") [1487751]
Rebuild_FUZZ: 99.21%
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 77b1a97d218277d55a15016826d1fd79290f1df2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/77b1a97d.failed

The filesystems proc and sysfs do not have executable files do not
have exectuable files today and portions of userspace break if we do
enforce nosuid and noexec consistency of nosuid and noexec flags
between previous mounts and new mounts of proc and sysfs.

Add the code to enforce consistency of the nosuid and noexec flags,
and use the presence of SB_I_NOEXEC to signal that there is no need to
bother.

This results in a completely userspace invisible change that makes it
clear fs_fully_visible can only skip the enforcement of noexec and
nosuid because it is known the filesystems in question do not support
executables.

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 77b1a97d218277d55a15016826d1fd79290f1df2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index c3276b690896,ce428cadd41f..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -3301,23 -3189,79 +3301,86 @@@ void update_mnt_policy(struct user_name
  
  	down_read(&namespace_sem);
  	list_for_each_entry(mnt, &ns->list, mnt_list) {
++<<<<<<< HEAD
 +		switch (mnt->mnt.mnt_sb->s_magic) {
 +		case SYSFS_MAGIC:
 +			userns->may_mount_sysfs = true;
 +			break;
 +		case PROC_SUPER_MAGIC:
 +			userns->may_mount_proc = true;
 +			break;
 +		}
 +		if (userns->may_mount_sysfs && userns->may_mount_proc)
 +			break;
++=======
+ 		struct mount *child;
+ 		int mnt_flags;
+ 
+ 		if (mnt->mnt.mnt_sb->s_type != type)
+ 			continue;
+ 
+ 		/* This mount is not fully visible if it's root directory
+ 		 * is not the root directory of the filesystem.
+ 		 */
+ 		if (mnt->mnt.mnt_root != mnt->mnt.mnt_sb->s_root)
+ 			continue;
+ 
+ 		/* Read the mount flags and filter out flags that
+ 		 * may safely be ignored.
+ 		 */
+ 		mnt_flags = mnt->mnt.mnt_flags;
+ 		if (mnt->mnt.mnt_sb->s_iflags & SB_I_NOEXEC)
+ 			mnt_flags &= ~(MNT_LOCK_NOSUID | MNT_LOCK_NOEXEC);
+ 
+ 		/* Verify the mount flags are equal to or more permissive
+ 		 * than the proposed new mount.
+ 		 */
+ 		if ((mnt_flags & MNT_LOCK_READONLY) &&
+ 		    !(new_flags & MNT_READONLY))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NODEV) &&
+ 		    !(new_flags & MNT_NODEV))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NOSUID) &&
+ 		    !(new_flags & MNT_NOSUID))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NOEXEC) &&
+ 		    !(new_flags & MNT_NOEXEC))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_ATIME) &&
+ 		    ((mnt_flags & MNT_ATIME_MASK) != (new_flags & MNT_ATIME_MASK)))
+ 			continue;
+ 
+ 		/* This mount is not fully visible if there are any
+ 		 * locked child mounts that cover anything except for
+ 		 * empty directories.
+ 		 */
+ 		list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {
+ 			struct inode *inode = child->mnt_mountpoint->d_inode;
+ 			/* Only worry about locked mounts */
+ 			if (!(mnt_flags & MNT_LOCKED))
+ 				continue;
+ 			/* Is the directory permanetly empty? */
+ 			if (!is_empty_dir_inode(inode))
+ 				goto next;
+ 		}
+ 		/* Preserve the locked attributes */
+ 		*new_mnt_flags |= mnt_flags & (MNT_LOCK_READONLY | \
+ 					       MNT_LOCK_NODEV    | \
+ 					       MNT_LOCK_NOSUID   | \
+ 					       MNT_LOCK_NOEXEC   | \
+ 					       MNT_LOCK_ATIME);
+ 		visible = true;
+ 		goto found;
+ 	next:	;
++>>>>>>> 77b1a97d2182 (mnt: fs_fully_visible enforce noexec and nosuid  if !SB_I_NOEXEC)
  	}
 -found:
  	up_read(&namespace_sem);
 -	return visible;
  }
  
 -static struct ns_common *mntns_get(struct task_struct *task)
 +static void *mntns_get(struct task_struct *task)
  {
 -	struct ns_common *ns = NULL;
 +	struct mnt_namespace *ns = NULL;
  	struct nsproxy *nsproxy;
  
  	task_lock(task);
* Unmerged path fs/namespace.c
