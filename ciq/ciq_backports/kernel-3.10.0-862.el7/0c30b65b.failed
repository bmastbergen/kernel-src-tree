cpufreq: intel_pstate: Expose global sysfs attributes upfront

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Expose global sysfs attributes upfront (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 92.04%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 0c30b65b3c8e5b8c72f39497aa8c61a662b6bcc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0c30b65b.failed

Expose the intel_pstate's global sysfs attributes before registering
the driver to prepare for the addition of an attribute that also will
have to work if the driver is not registered.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 0c30b65b3c8e5b8c72f39497aa8c61a662b6bcc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index e5b33d3c3e3c,2d8a51733a51..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -265,7 -356,10 +265,9 @@@ static inline int32_t get_target_pstate
  static struct pstate_adjust_policy pid_params __read_mostly;
  static struct pstate_funcs pstate_funcs __read_mostly;
  static int hwp_active __read_mostly;
 -static bool per_cpu_limits __read_mostly;
  
+ static bool driver_registered __read_mostly;
+ 
  #ifdef CONFIG_ACPI
  static bool acpi_ppc;
  #endif
@@@ -342,6 -396,9 +344,12 @@@ static struct perf_limits *limits = &pe
  static struct perf_limits *limits = &powersave_limits;
  #endif
  
++<<<<<<< HEAD
++=======
+ static DEFINE_MUTEX(intel_pstate_driver_lock);
+ static DEFINE_MUTEX(intel_pstate_limits_lock);
+ 
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  #ifdef CONFIG_ACPI
  
  static bool intel_pstate_get_ppc_enable_status(void)
@@@ -656,8 -1069,11 +671,11 @@@ static ssize_t show_turbo_pct(struct ko
  
  	total = cpu->pstate.turbo_pstate - cpu->pstate.min_pstate + 1;
  	no_turbo = cpu->pstate.max_pstate - cpu->pstate.min_pstate + 1;
 -	turbo_fp = div_fp(no_turbo, total);
 +	turbo_fp = div_fp(int_tofp(no_turbo), int_tofp(total));
  	turbo_pct = 100 - fp_toint(mul_fp(turbo_fp, int_tofp(100)));
+ 
+ 	mutex_unlock(&intel_pstate_driver_lock);
+ 
  	return sprintf(buf, "%u\n", turbo_pct);
  }
  
@@@ -696,17 -1131,31 +733,36 @@@ static ssize_t store_no_turbo(struct ko
  	if (ret != 1)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	update_turbo_state();
 +	if (limits->turbo_disabled) {
 +		pr_warn("Turbo disabled by BIOS or unavailable on processor\n");
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!driver_registered) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
+ 	update_turbo_state();
+ 	if (limits->turbo_disabled) {
+ 		pr_warn("Turbo disabled by BIOS or unavailable on processor\n");
+ 		mutex_unlock(&intel_pstate_limits_lock);
+ 		mutex_unlock(&intel_pstate_driver_lock);
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  		return -EPERM;
  	}
  
  	limits->no_turbo = clamp_t(int, input, 0, 1);
  
 -	mutex_unlock(&intel_pstate_limits_lock);
 -
 -	intel_pstate_update_policies();
 +	if (hwp_active)
 +		intel_pstate_hwp_set_online_cpus();
  
+ 	mutex_unlock(&intel_pstate_driver_lock);
+ 
  	return count;
  }
  
@@@ -720,6 -1169,15 +776,18 @@@ static ssize_t store_max_perf_pct(struc
  	if (ret != 1)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!driver_registered) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  	limits->max_sysfs_pct = clamp_t(int, input, 0 , 100);
  	limits->max_perf_pct = min(limits->max_policy_pct,
  				   limits->max_sysfs_pct);
@@@ -727,11 -1185,14 +795,16 @@@
  				   limits->max_perf_pct);
  	limits->max_perf_pct = max(limits->min_perf_pct,
  				   limits->max_perf_pct);
 -	limits->max_perf = div_ext_fp(limits->max_perf_pct, 100);
 -
 -	mutex_unlock(&intel_pstate_limits_lock);
 -
 -	intel_pstate_update_policies();
 +	limits->max_perf = div_fp(int_tofp(limits->max_perf_pct),
 +				  int_tofp(100));
  
++<<<<<<< HEAD
 +	if (hwp_active)
 +		intel_pstate_hwp_set_online_cpus();
++=======
+ 	mutex_unlock(&intel_pstate_driver_lock);
+ 
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  	return count;
  }
  
@@@ -745,6 -1206,15 +818,18 @@@ static ssize_t store_min_perf_pct(struc
  	if (ret != 1)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!driver_registered) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  	limits->min_sysfs_pct = clamp_t(int, input, 0 , 100);
  	limits->min_perf_pct = max(limits->min_policy_pct,
  				   limits->min_sysfs_pct);
@@@ -752,11 -1222,14 +837,16 @@@
  				   limits->min_perf_pct);
  	limits->min_perf_pct = min(limits->max_perf_pct,
  				   limits->min_perf_pct);
 -	limits->min_perf = div_ext_fp(limits->min_perf_pct, 100);
 -
 -	mutex_unlock(&intel_pstate_limits_lock);
 -
 -	intel_pstate_update_policies();
 +	limits->min_perf = div_fp(int_tofp(limits->min_perf_pct),
 +				  int_tofp(100));
  
++<<<<<<< HEAD
 +	if (hwp_active)
 +		intel_pstate_hwp_set_online_cpus();
++=======
+ 	mutex_unlock(&intel_pstate_driver_lock);
+ 
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  	return count;
  }
  
@@@ -1754,7 -2561,9 +1844,13 @@@ hwp_cpu_matched
  
  	intel_pstate_request_control_from_smm();
  
++<<<<<<< HEAD
 +	rc = cpufreq_register_driver(&intel_pstate_driver);
++=======
+ 	intel_pstate_sysfs_expose_params();
+ 
+ 	rc = cpufreq_register_driver(intel_pstate_driver);
++>>>>>>> 0c30b65b3c8e (cpufreq: intel_pstate: Expose global sysfs attributes upfront)
  	if (rc)
  		goto out;
  
@@@ -1762,10 -2575,8 +1862,8 @@@
  	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
  		intel_pstate_debug_expose_params();
  
- 	intel_pstate_sysfs_expose_params();
- 
  	if (hwp_active)
 -		pr_info("HWP enabled\n");
 +		pr_info("intel_pstate: HWP enabled\n");
  
  	return rc;
  out:
* Unmerged path drivers/cpufreq/intel_pstate.c
