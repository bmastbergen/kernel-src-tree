ima: log message to module appraisal error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bruno E. O. Meneguele <bmeneguele@gmail.com>
commit 9c655be0644429b71396347887b43676ab4f6781
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9c655be0.failed

Simple but useful message log to the user in case of module appraise is
forced and fails due to the lack of file descriptor, that might be
caused by kmod calls to compressed modules.

	Signed-off-by: Bruno E. O. Meneguele <brdeoliv@redhat.com>
	Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
(cherry picked from commit 9c655be0644429b71396347887b43676ab4f6781)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/integrity/ima/ima_main.c
diff --cc security/integrity/ima/ima_main.c
index fef94c88960b,21330d0455b0..000000000000
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@@ -271,10 -366,70 +271,74 @@@ int ima_file_check(struct file *file, i
  EXPORT_SYMBOL_GPL(ima_file_check);
  
  /**
 - * ima_post_path_mknod - mark as a new inode
 - * @dentry: newly created dentry
 + * ima_module_check - based on policy, collect/store/appraise measurement.
 + * @file: pointer to the file to be measured/appraised
   *
++<<<<<<< HEAD
 + * Measure/appraise kernel modules based on policy.
++=======
+  * Mark files created via the mknodat syscall as new, so that the
+  * file data can be written later.
+  */
+ void ima_post_path_mknod(struct dentry *dentry)
+ {
+ 	struct integrity_iint_cache *iint;
+ 	struct inode *inode = dentry->d_inode;
+ 	int must_appraise;
+ 
+ 	must_appraise = ima_must_appraise(inode, MAY_ACCESS, FILE_CHECK);
+ 	if (!must_appraise)
+ 		return;
+ 
+ 	iint = integrity_inode_get(inode);
+ 	if (iint)
+ 		iint->flags |= IMA_NEW_FILE;
+ }
+ 
+ /**
+  * ima_read_file - pre-measure/appraise hook decision based on policy
+  * @file: pointer to the file to be measured/appraised/audit
+  * @read_id: caller identifier
+  *
+  * Permit reading a file based on policy. The policy rules are written
+  * in terms of the policy identifier.  Appraising the integrity of
+  * a file requires a file descriptor.
+  *
+  * For permission return 0, otherwise return -EACCES.
+  */
+ int ima_read_file(struct file *file, enum kernel_read_file_id read_id)
+ {
+ 	bool sig_enforce = is_module_sig_enforced();
+ 
+ 	if (!file && read_id == READING_MODULE) {
+ 		if (!sig_enforce && (ima_appraise & IMA_APPRAISE_MODULES) &&
+ 		    (ima_appraise & IMA_APPRAISE_ENFORCE)) {
+ 			pr_err("impossible to appraise a module without a file descriptor. sig_enforce kernel parameter might help\n");
+ 			return -EACCES;	/* INTEGRITY_UNKNOWN */
+ 		}
+ 		return 0;	/* We rely on module signature checking */
+ 	}
+ 	return 0;
+ }
+ 
+ static int read_idmap[READING_MAX_ID] = {
+ 	[READING_FIRMWARE] = FIRMWARE_CHECK,
+ 	[READING_MODULE] = MODULE_CHECK,
+ 	[READING_KEXEC_IMAGE] = KEXEC_KERNEL_CHECK,
+ 	[READING_KEXEC_INITRAMFS] = KEXEC_INITRAMFS_CHECK,
+ 	[READING_POLICY] = POLICY_CHECK
+ };
+ 
+ /**
+  * ima_post_read_file - in memory collect/appraise/audit measurement
+  * @file: pointer to the file to be measured/appraised/audit
+  * @buf: pointer to in memory file contents
+  * @size: size of in memory file contents
+  * @read_id: caller identifier
+  *
+  * Measure/appraise/audit in memory file based on policy.  Policy rules
+  * are written in terms of a policy identifier.
++>>>>>>> 9c655be06444 (ima: log message to module appraisal error)
   *
   * On success return 0.  On integrity appraisal error, assuming the file
   * is in policy and IMA-appraisal is in enforcing mode, return -EACCES.
* Unmerged path security/integrity/ima/ima_main.c
