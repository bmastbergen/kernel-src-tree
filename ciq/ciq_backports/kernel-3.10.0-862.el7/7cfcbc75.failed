mlxsw: spectrum_router: Add support for setting counters on neighbors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit 7cfcbc7591e30aeebbfd3f7b0ff615b5ee4f1da7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7cfcbc75.failed

Add support for setting counters on neighbors based on dpipe's host table
counter status. This patch also adds the ability for getting the counter
value, which will be used by the dpipe host table implementation in the
next patches.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7cfcbc7591e30aeebbfd3f7b0ff615b5ee4f1da7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	net/tipc/config.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 6908726c154c,abccd84235eb..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -613,6 -911,53 +615,56 @@@ static const struct rhashtable_params m
  	.key_len = sizeof(struct mlxsw_sp_neigh_key),
  };
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_neigh_entry *
+ mlxsw_sp_rif_neigh_next(struct mlxsw_sp_rif *rif,
+ 			struct mlxsw_sp_neigh_entry *neigh_entry)
+ {
+ 	if (!neigh_entry) {
+ 		if (list_empty(&rif->neigh_list))
+ 			return NULL;
+ 		else
+ 			return list_first_entry(&rif->neigh_list,
+ 						typeof(*neigh_entry),
+ 						rif_list_node);
+ 	}
+ 	if (neigh_entry->rif_list_node.next == &rif->neigh_list)
+ 		return NULL;
+ 	return list_next_entry(neigh_entry, rif_list_node);
+ }
+ 
+ int mlxsw_sp_neigh_entry_type(struct mlxsw_sp_neigh_entry *neigh_entry)
+ {
+ 	return neigh_entry->key.n->tbl->family;
+ }
+ 
+ unsigned char *
+ mlxsw_sp_neigh_entry_ha(struct mlxsw_sp_neigh_entry *neigh_entry)
+ {
+ 	return neigh_entry->ha;
+ }
+ 
+ u32 mlxsw_sp_neigh4_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry)
+ {
+ 	struct neighbour *n;
+ 
+ 	n = neigh_entry->key.n;
+ 	return ntohl(*((__be32 *) n->primary_key));
+ }
+ 
+ int mlxsw_sp_neigh_counter_get(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_neigh_entry *neigh_entry,
+ 			       u64 *p_counter)
+ {
+ 	if (!neigh_entry->counter_valid)
+ 		return -EINVAL;
+ 
+ 	return mlxsw_sp_flow_counter_get(mlxsw_sp, neigh_entry->counter_index,
+ 					 p_counter, NULL);
+ }
+ 
++>>>>>>> 7cfcbc7591e3 (mlxsw: spectrum_router: Add support for setting counters on neighbors)
  static struct mlxsw_sp_neigh_entry *
  mlxsw_sp_neigh_entry_alloc(struct mlxsw_sp *mlxsw_sp, struct neighbour *n,
  			   u16 rif)
@@@ -672,7 -1052,8 +759,12 @@@ mlxsw_sp_neigh_entry_create(struct mlxs
  	if (err)
  		goto err_neigh_entry_insert;
  
++<<<<<<< HEAD
 +	list_add(&neigh_entry->rif_list_node, &r->neigh_list);
++=======
+ 	mlxsw_sp_neigh_counter_alloc(mlxsw_sp, neigh_entry);
+ 	list_add(&neigh_entry->rif_list_node, &rif->neigh_list);
++>>>>>>> 7cfcbc7591e3 (mlxsw: spectrum_router: Add support for setting counters on neighbors)
  
  	return neigh_entry;
  
@@@ -974,10 -1373,42 +1067,45 @@@ mlxsw_sp_router_neigh_entry_op4(struct 
  
  	mlxsw_reg_rauht_pack4(rauht_pl, op, neigh_entry->rif, neigh_entry->ha,
  			      dip);
+ 	if (neigh_entry->counter_valid)
+ 		mlxsw_reg_rauht_pack_counter(rauht_pl,
+ 					     neigh_entry->counter_index);
+ 	mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rauht), rauht_pl);
+ }
+ 
+ static void
++<<<<<<< HEAD
++=======
+ mlxsw_sp_router_neigh_entry_op6(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_neigh_entry *neigh_entry,
+ 				enum mlxsw_reg_rauht_op op)
+ {
+ 	struct neighbour *n = neigh_entry->key.n;
+ 	char rauht_pl[MLXSW_REG_RAUHT_LEN];
+ 	const char *dip = n->primary_key;
+ 
+ 	mlxsw_reg_rauht_pack6(rauht_pl, op, neigh_entry->rif, neigh_entry->ha,
+ 			      dip);
+ 	if (neigh_entry->counter_valid)
+ 		mlxsw_reg_rauht_pack_counter(rauht_pl,
+ 					     neigh_entry->counter_index);
  	mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rauht), rauht_pl);
  }
  
+ static bool mlxsw_sp_neigh_ipv6_ignore(struct neighbour *n)
+ {
+ 	/* Packets with a link-local destination address are trapped
+ 	 * after LPM lookup and never reach the neighbour table, so
+ 	 * there is no need to program such neighbours to the device.
+ 	 */
+ 	if (ipv6_addr_type((struct in6_addr *) &n->primary_key) &
+ 	    IPV6_ADDR_LINKLOCAL)
+ 		return true;
+ 	return false;
+ }
+ 
  static void
++>>>>>>> 7cfcbc7591e3 (mlxsw: spectrum_router: Add support for setting counters on neighbors)
  mlxsw_sp_neigh_entry_update(struct mlxsw_sp *mlxsw_sp,
  			    struct mlxsw_sp_neigh_entry *neigh_entry,
  			    bool adding)
diff --cc net/tipc/config.h
index 1f252f3fa058,aafae469be3a..000000000000
--- a/net/tipc/config.h
+++ b/net/tipc/config.h
@@@ -34,39 -32,45 +34,48 @@@
   * POSSIBILITY OF SUCH DAMAGE.
   */
  
 -#ifndef _MLXSW_ROUTER_H_
 -#define _MLXSW_ROUTER_H_
 +#ifndef _TIPC_CONFIG_H
 +#define _TIPC_CONFIG_H
  
 -#include "spectrum.h"
 +/* ---------------------------------------------------------------------- */
  
 -enum mlxsw_sp_rif_counter_dir {
 -	MLXSW_SP_RIF_COUNTER_INGRESS,
 -	MLXSW_SP_RIF_COUNTER_EGRESS,
 -};
 +#include "link.h"
  
 -struct mlxsw_sp_neigh_entry;
 +struct sk_buff *tipc_cfg_reply_alloc(int payload_size);
 +int tipc_cfg_append_tlv(struct sk_buff *buf, int tlv_type,
 +			void *tlv_data, int tlv_data_size);
 +struct sk_buff *tipc_cfg_reply_string_type(u16 tlv_type, char *string);
  
 -struct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,
 -					   u16 rif_index);
 -u16 mlxsw_sp_rif_index(const struct mlxsw_sp_rif *rif);
 -int mlxsw_sp_rif_dev_ifindex(const struct mlxsw_sp_rif *rif);
 -int mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,
 -				   struct mlxsw_sp_rif *rif,
 -				   enum mlxsw_sp_rif_counter_dir dir,
 -				   u64 *cnt);
 -void mlxsw_sp_rif_counter_free(struct mlxsw_sp *mlxsw_sp,
 -			       struct mlxsw_sp_rif *rif,
 -			       enum mlxsw_sp_rif_counter_dir dir);
 -int mlxsw_sp_rif_counter_alloc(struct mlxsw_sp *mlxsw_sp,
 -			       struct mlxsw_sp_rif *rif,
 -			       enum mlxsw_sp_rif_counter_dir dir);
 -struct mlxsw_sp_neigh_entry *
 -mlxsw_sp_rif_neigh_next(struct mlxsw_sp_rif *rif,
 -			struct mlxsw_sp_neigh_entry *neigh_entry);
 -int mlxsw_sp_neigh_entry_type(struct mlxsw_sp_neigh_entry *neigh_entry);
 -unsigned char *
 -mlxsw_sp_neigh_entry_ha(struct mlxsw_sp_neigh_entry *neigh_entry);
 -u32 mlxsw_sp_neigh4_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry);
 +static inline struct sk_buff *tipc_cfg_reply_none(void)
 +{
 +	return tipc_cfg_reply_alloc(0);
 +}
  
++<<<<<<< HEAD:net/tipc/config.h
 +static inline struct sk_buff *tipc_cfg_reply_error_string(char *string)
 +{
 +	return tipc_cfg_reply_string_type(TIPC_TLV_ERROR_STRING, string);
 +}
++=======
+ #define mlxsw_sp_rif_neigh_for_each(neigh_entry, rif)				\
+ 	for (neigh_entry = mlxsw_sp_rif_neigh_next(rif, NULL); neigh_entry;	\
+ 	     neigh_entry = mlxsw_sp_rif_neigh_next(rif, neigh_entry))
+ int mlxsw_sp_neigh_counter_get(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_neigh_entry *neigh_entry,
+ 			       u64 *p_counter);
++>>>>>>> 7cfcbc7591e3 (mlxsw: spectrum_router: Add support for setting counters on neighbors):drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
 +
 +static inline struct sk_buff *tipc_cfg_reply_ultra_string(char *string)
 +{
 +	return tipc_cfg_reply_string_type(TIPC_TLV_ULTRA_STRING, string);
 +}
 +
 +struct sk_buff *tipc_cfg_do_cmd(u32 orig_node, u16 cmd,
 +				const void *req_tlv_area, int req_tlv_space,
 +				int headroom);
 +
 +int  tipc_cfg_init(void);
 +void tipc_cfg_reinit(void);
 +void tipc_cfg_stop(void);
  
 -#endif /* _MLXSW_ROUTER_H_*/
 +#endif
diff --git a/drivers/net/ethernet/mellanox/mlxsw/reg.h b/drivers/net/ethernet/mellanox/mlxsw/reg.h
index 572b761897ae..bc2a332774e9 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/reg.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/reg.h
@@ -5218,6 +5218,14 @@ static inline void mlxsw_reg_rauht_pack6(char *payload,
 	mlxsw_reg_rauht_dip6_memcpy_to(payload, dip);
 }
 
+static inline void mlxsw_reg_rauht_pack_counter(char *payload,
+						u64 counter_index)
+{
+	mlxsw_reg_rauht_counter_index_set(payload, counter_index);
+	mlxsw_reg_rauht_counter_set_type_set(payload,
+					     MLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS_BYTES);
+}
+
 /* RALEU - Router Algorithmic LPM ECMP Update Register
  * ---------------------------------------------------
  * The register enables updating the ECMP section in the action for multiple
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 238c7e108f48..a2c2849da9fa 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -384,8 +384,10 @@ int mlxsw_sp_flow_counter_get(struct mlxsw_sp *mlxsw_sp,
 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(mgpc), mgpc_pl);
 	if (err)
 		return err;
-	*packets = mlxsw_reg_mgpc_packet_counter_get(mgpc_pl);
-	*bytes = mlxsw_reg_mgpc_byte_counter_get(mgpc_pl);
+	if (packets)
+		*packets = mlxsw_reg_mgpc_packet_counter_get(mgpc_pl);
+	if (bytes)
+		*bytes = mlxsw_reg_mgpc_byte_counter_get(mgpc_pl);
 	return 0;
 }
 
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path net/tipc/config.h
