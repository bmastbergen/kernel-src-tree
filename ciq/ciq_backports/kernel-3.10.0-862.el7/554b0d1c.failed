cpuset: inherit ancestor's masks if effective_{cpus, mems} becomes empty

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Li Zefan <lizefan@huawei.com>
commit 554b0d1c845e42ef01d7f6f5f24b3e4c6129ce8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/554b0d1c.failed

We're going to have separate user-configured masks and effective ones.

Eventually configured masks can only be changed by writing cpuset.cpus
and cpuset.mems, and they won't be restricted by parent cpuset. While
effective masks reflect cpu/memory hotplug and hierachical restriction,
and these are the real masks that apply to the tasks in the cpuset.

We calculate effective mask this way:
  - top cpuset's effective_mask == online_mask, otherwise
  - cpuset's effective_mask == configured_mask & parent effective_mask,
    if the result is empty, it inherits parent effective mask.

Those behavior changes are for default hierarchy only. For legacy
hierarchy, effective_mask and configured_mask are the same, so we won't
break old interfaces.

To make cs->effective_{cpus,mems} to be effective masks, we need to
  - update the effective masks at hotplug
  - update the effective masks at config change
  - take on ancestor's mask when the effective mask is empty

The last item is done here.

This won't introduce behavior change.

	Signed-off-by: Li Zefan <lizefan@huawei.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 554b0d1c845e42ef01d7f6f5f24b3e4c6129ce8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cpuset.c
diff --cc kernel/cpuset.c
index 650413f2caa8,f8340026d01c..000000000000
--- a/kernel/cpuset.c
+++ b/kernel/cpuset.c
@@@ -866,23 -866,31 +866,41 @@@ static void update_tasks_cpumask(struc
   *
   * Called with cpuset_mutex held
   */
 -static void update_cpumasks_hier(struct cpuset *cs, struct cpumask *new_cpus)
 +static void update_tasks_cpumask_hier(struct cpuset *root_cs,
 +				      bool update_root, struct ptr_heap *heap)
  {
  	struct cpuset *cp;
 -	struct cgroup_subsys_state *pos_css;
 +	struct cgroup *pos_cgrp;
 +
 +	if (update_root)
 +		update_tasks_cpumask(root_cs, heap);
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cpuset_for_each_descendant_pre(cp, pos_cgrp, root_cs) {
 +		/* skip the whole subtree if @cp have some CPU */
 +		if (!cpumask_empty(cp->cpus_allowed)) {
 +			pos_cgrp = cgroup_rightmost_descendant(pos_cgrp);
++=======
+ 	cpuset_for_each_descendant_pre(cp, pos_css, cs) {
+ 		struct cpuset *parent = parent_cs(cp);
+ 
+ 		cpumask_and(new_cpus, cp->cpus_allowed, parent->effective_cpus);
+ 
+ 		/*
+ 		 * If it becomes empty, inherit the effective mask of the
+ 		 * parent, which is guaranteed to have some CPUs.
+ 		 */
+ 		if (cpumask_empty(new_cpus))
+ 			cpumask_copy(new_cpus, parent->effective_cpus);
+ 
+ 		/* Skip the whole subtree if the cpumask remains the same. */
+ 		if (cpumask_equal(new_cpus, cp->effective_cpus)) {
+ 			pos_css = css_rightmost_descendant(pos_css);
++>>>>>>> 554b0d1c845e (cpuset: inherit ancestor's masks if effective_{cpus, mems} becomes empty)
  			continue;
  		}
 -
 -		if (!css_tryget_online(&cp->css))
 +		if (!css_tryget(&cp->css))
  			continue;
  		rcu_read_unlock();
  
@@@ -1120,23 -1119,31 +1138,41 @@@ static void update_tasks_nodemask(struc
   *
   * Called with cpuset_mutex held
   */
 -static void update_nodemasks_hier(struct cpuset *cs, nodemask_t *new_mems)
 +static void update_tasks_nodemask_hier(struct cpuset *root_cs,
 +				       bool update_root, struct ptr_heap *heap)
  {
  	struct cpuset *cp;
 -	struct cgroup_subsys_state *pos_css;
 +	struct cgroup *pos_cgrp;
 +
 +	if (update_root)
 +		update_tasks_nodemask(root_cs, heap);
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	cpuset_for_each_descendant_pre(cp, pos_cgrp, root_cs) {
 +		/* skip the whole subtree if @cp have some CPU */
 +		if (!nodes_empty(cp->mems_allowed)) {
 +			pos_cgrp = cgroup_rightmost_descendant(pos_cgrp);
++=======
+ 	cpuset_for_each_descendant_pre(cp, pos_css, cs) {
+ 		struct cpuset *parent = parent_cs(cp);
+ 
+ 		nodes_and(*new_mems, cp->mems_allowed, parent->effective_mems);
+ 
+ 		/*
+ 		 * If it becomes empty, inherit the effective mask of the
+ 		 * parent, which is guaranteed to have some MEMs.
+ 		 */
+ 		if (nodes_empty(*new_mems))
+ 			*new_mems = parent->effective_mems;
+ 
+ 		/* Skip the whole subtree if the nodemask remains the same. */
+ 		if (nodes_equal(*new_mems, cp->effective_mems)) {
+ 			pos_css = css_rightmost_descendant(pos_css);
++>>>>>>> 554b0d1c845e (cpuset: inherit ancestor's masks if effective_{cpus, mems} becomes empty)
  			continue;
  		}
 -
 -		if (!css_tryget_online(&cp->css))
 +		if (!css_tryget(&cp->css))
  			continue;
  		rcu_read_unlock();
  
* Unmerged path kernel/cpuset.c
