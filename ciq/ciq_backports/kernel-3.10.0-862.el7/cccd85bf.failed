s390/zcrypt: Rework debug feature invocations.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: Rework debug feature invocations (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 93.02%
commit-author Harald Freudenberger <freude@linux.vnet.ibm.com>
commit cccd85bfb7bf6787302435c669ceec23b5a5301c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cccd85bf.failed

Rework the debug feature calls and initialization.  There
are now two debug feature entries used by the zcrypt code.
The first is 'ap' with all the AP bus related stuff and the
second is 'zcrypt' with all the zcrypt and devices and
driver related entries. However, there isn't much traffic on
both debug features. The ap bus code emits only some debug
info and for zcrypt devices on appearance and disappearance
there is an entry written.

The new dbf invocations use the sprintf buffer layout,
whereas the old implementation used the ascii dbf buffer.
There are now 5*8=40 bytes used for each entry, resulting in
5 parameters per call. As the sprintf buffer needs a format
string the first parameter provides this and so up to 4 more
parameters can be used. Alltogehter the new layout should be
much more human readable for customers and test.

	Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit cccd85bfb7bf6787302435c669ceec23b5a5301c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/zcrypt_api.c
#	drivers/s390/crypto/zcrypt_api.h
#	drivers/s390/crypto/zcrypt_card.c
#	drivers/s390/crypto/zcrypt_debug.h
#	drivers/s390/crypto/zcrypt_error.h
#	drivers/s390/crypto/zcrypt_msgtype50.c
#	drivers/s390/crypto/zcrypt_msgtype6.c
#	drivers/s390/crypto/zcrypt_queue.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,6d75984a3d85..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -45,25 -46,12 +45,34 @@@
  #include <linux/ktime.h>
  #include <asm/facility.h>
  #include <linux/crypto.h>
++<<<<<<< HEAD
 +
 +#include "ap_bus.h"
 +
 +/* Some prototypes. */
 +static void ap_scan_bus(struct work_struct *);
 +static void ap_poll_all(unsigned long);
 +static enum hrtimer_restart ap_poll_timeout(struct hrtimer *);
 +static int ap_poll_thread_start(void);
 +static void ap_poll_thread_stop(void);
 +static void ap_request_timeout(unsigned long);
 +static inline void ap_schedule_poll_timer(void);
 +static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags);
 +static int ap_device_remove(struct device *dev);
 +static int ap_device_probe(struct device *dev);
 +static void ap_interrupt_handler(struct airq_struct *airq);
 +static void ap_reset(struct ap_device *ap_dev, unsigned long *flags);
 +static void ap_config_timeout(unsigned long ptr);
 +static int ap_select_domain(void);
 +static void ap_query_configuration(void);
++=======
+ #include <linux/mod_devicetable.h>
+ #include <linux/debugfs.h>
+ 
+ #include "ap_bus.h"
+ #include "ap_asm.h"
+ #include "ap_debug.h"
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
  /*
   * Module description.
@@@ -86,23 -75,27 +95,33 @@@ static int ap_thread_flag = 0
  module_param_named(poll_thread, ap_thread_flag, int, S_IRUSR|S_IRGRP);
  MODULE_PARM_DESC(poll_thread, "Turn on/off poll thread, default is 0 (off).");
  
 -static struct device *ap_root_device;
 -
 -DEFINE_SPINLOCK(ap_list_lock);
 -LIST_HEAD(ap_card_list);
 +int ap_hwrng_seed = 1;
 +EXPORT_SYMBOL(ap_hwrng_seed);
 +module_param_named(hwrng_seed, ap_hwrng_seed, int, S_IRUSR|S_IRGRP);
 +MODULE_PARM_DESC(hwrng_seed, "Turn on/off hwrng auto seed, default is 1 (on).");
  
 +static struct device *ap_root_device = NULL;
  static struct ap_config_info *ap_configuration;
 -static bool initialised;
 +static DEFINE_SPINLOCK(ap_device_list_lock);
 +static LIST_HEAD(ap_device_list);
  
  /*
++<<<<<<< HEAD
 + * Workqueue & timer for bus rescan.
++=======
+  * AP bus related debug feature things.
+  */
+ static struct dentry *ap_dbf_root;
+ debug_info_t *ap_dbf_info;
+ 
+ /*
+  * Workqueue timer for bus rescan.
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
   */
 +static struct workqueue_struct *ap_work_queue;
  static struct timer_list ap_config_timer;
  static int ap_config_time = AP_CONFIG_TIME;
 -static void ap_scan_bus(struct work_struct *);
 -static DECLARE_WORK(ap_scan_work, ap_scan_bus);
 +static DECLARE_WORK(ap_config_work, ap_scan_bus);
  
  /*
   * Tasklet & timer for AP request polling and interrupts
@@@ -878,58 -563,107 +897,114 @@@ static int ap_bus_suspend(struct devic
  	return 0;
  }
  
 -static int ap_dev_resume(struct device *dev)
 +static int ap_bus_resume(struct device *dev)
  {
  	struct ap_device *ap_dev = to_ap_dev(dev);
++<<<<<<< HEAD
 +	int rc;
 +
 +	if (ap_suspend_flag) {
 +		ap_suspend_flag = 0;
 +		if (ap_interrupts_available()) {
 +			if (!ap_using_interrupts()) {
 +				rc = register_adapter_interrupt(&ap_airq);
 +				ap_airq_flag = (rc == 0);
 +			}
 +		} else {
 +			if (ap_using_interrupts()) {
 +				unregister_adapter_interrupt(&ap_airq);
 +				ap_airq_flag = 0;
 +			}
 +		}
 +		ap_query_configuration();
 +		if (!user_set_domain) {
 +			ap_domain_index = -1;
 +			ap_select_domain();
 +		}
 +		init_timer(&ap_config_timer);
 +		ap_config_timer.function = ap_config_timeout;
 +		ap_config_timer.data = 0;
 +		ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +		add_timer(&ap_config_timer);
 +		ap_work_queue = create_singlethread_workqueue("kapwork");
 +		if (!ap_work_queue)
 +			return -ENOMEM;
 +		tasklet_enable(&ap_tasklet);
 +		if (!ap_using_interrupts())
 +			ap_schedule_poll_timer();
 +		else
 +			tasklet_schedule(&ap_tasklet);
 +		if (ap_thread_flag)
 +			rc = ap_poll_thread_start();
 +		else
 +			rc = 0;
 +	} else
 +		rc = 0;
 +	if (AP_QID_QUEUE(ap_dev->qid) != ap_domain_index) {
 +		spin_lock_bh(&ap_dev->lock);
 +		ap_dev->qid = AP_MKQID(AP_QID_DEVICE(ap_dev->qid),
 +				       ap_domain_index);
 +		spin_unlock_bh(&ap_dev->lock);
 +	}
 +	queue_work(ap_work_queue, &ap_config_work);
++=======
+ 
+ 	if (ap_dev->drv && ap_dev->drv->resume)
+ 		ap_dev->drv->resume(ap_dev);
+ 	return 0;
+ }
+ 
+ static void ap_bus_suspend(void)
+ {
+ 	AP_DBF(DBF_DEBUG, "ap_bus_suspend running\n");
+ 
+ 	ap_suspend_flag = 1;
+ 	/*
+ 	 * Disable scanning for devices, thus we do not want to scan
+ 	 * for them after removing.
+ 	 */
+ 	flush_work(&ap_scan_work);
+ 	tasklet_disable(&ap_tasklet);
+ }
+ 
+ static int __ap_card_devices_unregister(struct device *dev, void *dummy)
+ {
+ 	if (is_card_dev(dev))
+ 		device_unregister(dev);
+ 	return 0;
+ }
+ 
+ static int __ap_queue_devices_unregister(struct device *dev, void *dummy)
+ {
+ 	if (is_queue_dev(dev))
+ 		device_unregister(dev);
+ 	return 0;
+ }
+ 
+ static int __ap_queue_devices_with_id_unregister(struct device *dev, void *data)
+ {
+ 	if (is_queue_dev(dev) &&
+ 	    AP_QID_CARD(to_ap_queue(dev)->qid) == (int)(long) data)
+ 		device_unregister(dev);
+ 	return 0;
+ }
+ 
+ static void ap_bus_resume(void)
+ {
+ 	int rc;
+ 
+ 	AP_DBF(DBF_DEBUG, "ap_bus_resume running\n");
+ 
+ 	/* remove all queue devices */
+ 	bus_for_each_dev(&ap_bus_type, NULL, NULL,
+ 			 __ap_queue_devices_unregister);
+ 	/* remove all card devices */
+ 	bus_for_each_dev(&ap_bus_type, NULL, NULL,
+ 			 __ap_card_devices_unregister);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
 -	/* Reset thin interrupt setting */
 -	if (ap_interrupts_available() && !ap_using_interrupts()) {
 -		rc = register_adapter_interrupt(&ap_airq);
 -		ap_airq_flag = (rc == 0);
 -	}
 -	if (!ap_interrupts_available() && ap_using_interrupts()) {
 -		unregister_adapter_interrupt(&ap_airq);
 -		ap_airq_flag = 0;
 -	}
 -	/* Reset domain */
 -	if (!user_set_domain)
 -		ap_domain_index = -1;
 -	/* Get things going again */
 -	ap_suspend_flag = 0;
 -	if (ap_airq_flag)
 -		xchg(ap_airq.lsi_ptr, 0);
 -	tasklet_enable(&ap_tasklet);
 -	queue_work(system_long_wq, &ap_scan_work);
 -}
 -
 -static int ap_power_event(struct notifier_block *this, unsigned long event,
 -			  void *ptr)
 -{
 -	switch (event) {
 -	case PM_HIBERNATION_PREPARE:
 -	case PM_SUSPEND_PREPARE:
 -		ap_bus_suspend();
 -		break;
 -	case PM_POST_HIBERNATION:
 -	case PM_POST_SUSPEND:
 -		ap_bus_resume();
 -		break;
 -	default:
 -		break;
 -	}
 -	return NOTIFY_DONE;
 +	return rc;
  }
 -static struct notifier_block ap_power_notifier = {
 -	.notifier_call = ap_power_event,
 -};
 -
 -static SIMPLE_DEV_PM_OPS(ap_bus_pm_ops, ap_dev_suspend, ap_dev_resume);
  
  static struct bus_type ap_bus_type = {
  	.name = "ap",
@@@ -1095,7 -743,24 +1170,28 @@@ static ssize_t ap_domain_show(struct bu
  	return snprintf(buf, PAGE_SIZE, "%d\n", ap_domain_index);
  }
  
++<<<<<<< HEAD
 +static BUS_ATTR(ap_domain, 0444, ap_domain_show, NULL);
++=======
+ static ssize_t ap_domain_store(struct bus_type *bus,
+ 			       const char *buf, size_t count)
+ {
+ 	int domain;
+ 
+ 	if (sscanf(buf, "%i\n", &domain) != 1 ||
+ 	    domain < 0 || domain > ap_max_domain_id)
+ 		return -EINVAL;
+ 	spin_lock_bh(&ap_domain_lock);
+ 	ap_domain_index = domain;
+ 	spin_unlock_bh(&ap_domain_lock);
+ 
+ 	AP_DBF(DBF_DEBUG, "store new default domain=%d\n", domain);
+ 
+ 	return count;
+ }
+ 
+ static BUS_ATTR(ap_domain, 0644, ap_domain_show, ap_domain_store);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
  static ssize_t ap_control_domain_mask_show(struct bus_type *bus, char *buf)
  {
@@@ -1425,589 -966,155 +1521,729 @@@ static void ap_interrupt_handler(struc
  }
  
  /**
 - * ap_scan_bus(): Scan the AP bus for new devices
 - * Runs periodically, workqueue timer (ap_config_time)
 + * __ap_scan_bus(): Scan the AP bus.
 + * @dev: Pointer to device
 + * @data: Pointer to data
 + *
 + * Scan the AP bus for new devices.
   */
 -static void ap_scan_bus(struct work_struct *unused)
 +static int __ap_scan_bus(struct device *dev, void *data)
  {
++<<<<<<< HEAD
 +	return to_ap_dev(dev)->qid == (ap_qid_t)(unsigned long) data;
++=======
+ 	struct ap_queue *aq;
+ 	struct ap_card *ac;
+ 	struct device *dev;
+ 	ap_qid_t qid;
+ 	int depth = 0, type = 0;
+ 	unsigned int functions = 0;
+ 	int rc, id, dom, borked, domains;
+ 
+ 	AP_DBF(DBF_DEBUG, "ap_scan_bus running\n");
+ 
+ 	ap_query_configuration();
+ 	if (ap_select_domain() != 0)
+ 		goto out;
+ 
+ 	for (id = 0; id < AP_DEVICES; id++) {
+ 		/* check if device is registered */
+ 		dev = bus_find_device(&ap_bus_type, NULL,
+ 				      (void *)(long) id,
+ 				      __match_card_device_with_id);
+ 		ac = dev ? to_ap_card(dev) : NULL;
+ 		if (!ap_test_config_card_id(id)) {
+ 			if (dev) {
+ 				/* Card device has been removed from
+ 				 * configuration, remove the belonging
+ 				 * queue devices.
+ 				 */
+ 				bus_for_each_dev(&ap_bus_type, NULL,
+ 					(void *)(long) id,
+ 					__ap_queue_devices_with_id_unregister);
+ 				/* now remove the card device */
+ 				device_unregister(dev);
+ 				put_device(dev);
+ 			}
+ 			continue;
+ 		}
+ 		/* According to the configuration there should be a card
+ 		 * device, so check if there is at least one valid queue
+ 		 * and maybe create queue devices and the card device.
+ 		 */
+ 		domains = 0;
+ 		for (dom = 0; dom < AP_DOMAINS; dom++) {
+ 			qid = AP_MKQID(id, dom);
+ 			dev = bus_find_device(&ap_bus_type, NULL,
+ 					      (void *)(long) qid,
+ 					      __match_queue_device_with_qid);
+ 			aq = dev ? to_ap_queue(dev) : NULL;
+ 			if (!ap_test_config_domain(dom)) {
+ 				if (dev) {
+ 					/* Queue device exists but has been
+ 					 * removed from configuration.
+ 					 */
+ 					device_unregister(dev);
+ 					put_device(dev);
+ 				}
+ 				continue;
+ 			}
+ 			rc = ap_query_queue(qid, &depth, &type, &functions);
+ 			if (dev) {
+ 				spin_lock_bh(&aq->lock);
+ 				if (rc == -ENODEV ||
+ 				    /* adapter reconfiguration */
+ 				    (ac && ac->functions != functions))
+ 					aq->state = AP_STATE_BORKED;
+ 				borked = aq->state == AP_STATE_BORKED;
+ 				spin_unlock_bh(&aq->lock);
+ 				if (borked)	/* Remove broken device */
+ 					device_unregister(dev);
+ 				put_device(dev);
+ 				if (!borked) {
+ 					domains++;
+ 					continue;
+ 				}
+ 			}
+ 			if (rc)
+ 				continue;
+ 			/* new queue device needed */
+ 			if (!ac) {
+ 				/* but first create the card device */
+ 				ac = ap_card_create(id, depth,
+ 						    type, functions);
+ 				if (!ac)
+ 					continue;
+ 				ac->ap_dev.device.bus = &ap_bus_type;
+ 				ac->ap_dev.device.parent = ap_root_device;
+ 				dev_set_name(&ac->ap_dev.device,
+ 					     "card%02x", id);
+ 				/* Register card with AP bus */
+ 				rc = device_register(&ac->ap_dev.device);
+ 				if (rc) {
+ 					put_device(&ac->ap_dev.device);
+ 					ac = NULL;
+ 					break;
+ 				}
+ 				/* get it and thus adjust reference counter */
+ 				get_device(&ac->ap_dev.device);
+ 				/* Add card device to card list */
+ 				spin_lock_bh(&ap_list_lock);
+ 				list_add(&ac->list, &ap_card_list);
+ 				spin_unlock_bh(&ap_list_lock);
+ 			}
+ 			/* now create the new queue device */
+ 			aq = ap_queue_create(qid, type);
+ 			if (!aq)
+ 				continue;
+ 			aq->card = ac;
+ 			aq->ap_dev.device.bus = &ap_bus_type;
+ 			aq->ap_dev.device.parent = &ac->ap_dev.device;
+ 			dev_set_name(&aq->ap_dev.device,
+ 				     "%02x.%04x", id, dom);
+ 			/* Add queue device to card queue list */
+ 			spin_lock_bh(&ap_list_lock);
+ 			list_add(&aq->list, &ac->queues);
+ 			spin_unlock_bh(&ap_list_lock);
+ 			/* Start with a device reset */
+ 			spin_lock_bh(&aq->lock);
+ 			ap_wait(ap_sm_event(aq, AP_EVENT_POLL));
+ 			spin_unlock_bh(&aq->lock);
+ 			/* Register device */
+ 			rc = device_register(&aq->ap_dev.device);
+ 			if (rc) {
+ 				spin_lock_bh(&ap_list_lock);
+ 				list_del_init(&aq->list);
+ 				spin_unlock_bh(&ap_list_lock);
+ 				put_device(&aq->ap_dev.device);
+ 				continue;
+ 			}
+ 			domains++;
+ 		} /* end domain loop */
+ 		if (ac) {
+ 			/* remove card dev if there are no queue devices */
+ 			if (!domains)
+ 				device_unregister(&ac->ap_dev.device);
+ 			put_device(&ac->ap_dev.device);
+ 		}
+ 	} /* end device loop */
+ out:
+ 	mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  }
  
 -static void ap_config_timeout(unsigned long ptr)
 +static void ap_device_release(struct device *dev)
  {
 -	if (ap_suspend_flag)
 +	struct ap_device *ap_dev = to_ap_dev(dev);
 +
 +	kfree(ap_dev);
 +}
 +
 +static void ap_scan_bus(struct work_struct *unused)
 +{
 +	struct ap_device *ap_dev;
 +	struct device *dev;
 +	ap_qid_t qid;
 +	int queue_depth = 0, device_type = 0;
 +	unsigned int device_functions;
 +	int rc, i;
 +
 +	ap_query_configuration();
 +	if (ap_select_domain() != 0) {
  		return;
 -	queue_work(system_long_wq, &ap_scan_work);
 +	}
 +	for (i = 0; i < AP_DEVICES; i++) {
 +		qid = AP_MKQID(i, ap_domain_index);
 +		dev = bus_find_device(&ap_bus_type, NULL,
 +				      (void *)(unsigned long)qid,
 +				      __ap_scan_bus);
 +		if (ap_test_config_card_id(i))
 +			rc = ap_query_queue(qid, &queue_depth, &device_type);
 +		else
 +			rc = -ENODEV;
 +		if (dev) {
 +			ap_dev = to_ap_dev(dev);
 +			spin_lock_bh(&ap_dev->lock);
 +			if (rc == -ENODEV ||
 +			    ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +				spin_unlock_bh(&ap_dev->lock);
 +				if (ap_dev->unregistered == AP_DEV_UNREGISTERED)
 +					i--;
 +				device_unregister(dev);
 +				put_device(dev);
 +				continue;
 +			}
 +			spin_unlock_bh(&ap_dev->lock);
 +			put_device(dev);
 +			continue;
 +		}
 +		if (rc)
 +			continue;
 +		ap_dev = kzalloc(sizeof(*ap_dev), GFP_KERNEL);
 +		if (!ap_dev)
 +			break;
 +		ap_dev->qid = qid;
 +		rc = ap_init_queue(ap_dev);
 +		if ((rc != 0) && (rc != -EBUSY)) {
 +			kfree(ap_dev);
 +			continue;
 +		}
 +		ap_dev->queue_depth = queue_depth;
 +		ap_dev->unregistered = AP_DEV_REGIST_IN_PROGRESS;
 +		spin_lock_init(&ap_dev->lock);
 +		INIT_LIST_HEAD(&ap_dev->pendingq);
 +		INIT_LIST_HEAD(&ap_dev->requestq);
 +		INIT_LIST_HEAD(&ap_dev->list);
 +		setup_timer(&ap_dev->timeout, ap_request_timeout,
 +			    (unsigned long) ap_dev);
 +		switch (device_type) {
 +		case 0:
 +			/* device type probing for old cards */
 +			if (ap_probe_device_type(ap_dev)) {
 +				kfree(ap_dev);
 +				continue;
 +			}
 +			break;
 +		default:
 +			ap_dev->device_type = device_type;
 +		}
 +		ap_dev->raw_hwtype = device_type;
 +		/* CEX6 toleration: map to CEX5 */
 +		if (device_type == AP_DEVICE_TYPE_CEX6)
 +			ap_dev->device_type = AP_DEVICE_TYPE_CEX5;
 +
 +		rc = ap_query_functions(qid, &device_functions);
 +		if (!rc)
 +			ap_dev->functions = device_functions;
 +		else
 +			ap_dev->functions = 0u;
 +
 +		ap_dev->device.bus = &ap_bus_type;
 +		ap_dev->device.parent = ap_root_device;
 +		if (dev_set_name(&ap_dev->device, "card%02x",
 +				 AP_QID_DEVICE(ap_dev->qid))) {
 +			kfree(ap_dev);
 +			continue;
 +		}
 +		ap_dev->device.release = ap_device_release;
 +		rc = device_register(&ap_dev->device);
 +		if (rc) {
 +			put_device(&ap_dev->device);
 +			continue;
 +		}
 +		/* Add device attributes. */
 +		rc = sysfs_create_group(&ap_dev->device.kobj,
 +					&ap_dev_attr_group);
 +		if (!rc) {
 +			spin_lock_bh(&ap_dev->lock);
 +			ap_dev->unregistered = AP_DEV_REGISTERED;
 +			spin_unlock_bh(&ap_dev->lock);
 +		}
 +		else
 +			device_unregister(&ap_dev->device);
 +	}
 +}
 +
 +static void
 +ap_config_timeout(unsigned long ptr)
 +{
 +	queue_work(ap_work_queue, &ap_config_work);
 +	ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +	add_timer(&ap_config_timer);
 +}
 +
 +/**
 + * ap_poll_read(): Receive pending reply messages from an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_read(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->queue_count <= 0)
 +		return 0;
 +	status = __ap_recv(ap_dev->qid, &ap_dev->reply->psmid,
 +			   ap_dev->reply->message, ap_dev->reply->length);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		ap_dev->interrupt = status.int_enabled;
 +		atomic_dec(&ap_poll_requests);
 +		ap_decrease_queue_count(ap_dev);
 +		list_for_each_entry(ap_msg, &ap_dev->pendingq, list) {
 +			if (ap_msg->psmid != ap_dev->reply->psmid)
 +				continue;
 +			list_del_init(&ap_msg->list);
 +			ap_dev->pendingq_count--;
 +			ap_msg->receive(ap_dev, ap_msg, ap_dev->reply);
 +			break;
 +		}
 +		if (ap_dev->queue_count > 0)
 +			*flags |= 1;
 +		break;
 +	case AP_RESPONSE_NO_PENDING_REPLY:
 +		ap_dev->interrupt = status.int_enabled;
 +		if (status.queue_empty) {
 +			/* The card shouldn't forget requests but who knows. */
 +			atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +			ap_dev->queue_count = 0;
 +			list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +			ap_dev->requestq_count += ap_dev->pendingq_count;
 +			ap_dev->pendingq_count = 0;
 +		} else
 +			*flags |= 2;
 +		break;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_write(): Send messages from the request queue to an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_write(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->requestq_count <= 0 ||
 +	    (ap_dev->queue_count >= ap_dev->queue_depth) ||
 +	    (ap_dev->reset == AP_RESET_IN_PROGRESS))
 +		return 0;
 +	/* Start the next request on the queue. */
 +	ap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);
 +	status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +			   ap_msg->message, ap_msg->length, ap_msg->special);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		atomic_inc(&ap_poll_requests);
 +		ap_increase_queue_count(ap_dev);
 +		list_move_tail(&ap_msg->list, &ap_dev->pendingq);
 +		ap_dev->requestq_count--;
 +		ap_dev->pendingq_count++;
 +		if (ap_dev->queue_count < ap_dev->queue_depth &&
 +		    ap_dev->requestq_count > 0)
 +			*flags |= 1;
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +		__ap_schedule_poll_timer();
 +	case AP_RESPONSE_Q_FULL:
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_MESSAGE_TOO_BIG:
 +	case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		return -EINVAL;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_queue(): Poll AP device for pending replies and send new messages.
 + * Check if the queue has a pending reset. In case it's done re-enable
 + * interrupts, otherwise reschedule the poll_timer for another attempt.
 + * @ap_dev: pointer to the bus device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Poll AP device for pending replies and send new messages. If either
 + * ap_poll_read or ap_poll_write returns -ENODEV unregister the device.
 + * Returns 0.
 + */
 +static inline int ap_poll_queue(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc, depth, type;
 +	struct ap_queue_status status;
 +
 +
 +	if (ap_dev->reset == AP_RESET_IN_PROGRESS) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			ap_dev->reset = AP_RESET_IGNORE;
 +			if (ap_using_interrupts()) {
 +				rc = ap_queue_enable_interruption(
 +					ap_dev, ap_airq.lsi_ptr);
 +				if (!rc)
 +					ap_dev->interrupt = AP_INTR_IN_PROGRESS;
 +				else if (rc == -ENODEV) {
 +					pr_err("Registering adapter interrupts for "
 +					"AP %d failed\n", AP_QID_DEVICE(ap_dev->qid));
 +					return rc;
 +				}
 +			}
 +			/* fall through */
 +		case AP_RESPONSE_BUSY:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			*flags |= AP_POLL_AFTER_TIMEOUT;
 +			break;
 +		case AP_RESPONSE_Q_NOT_AVAIL:
 +		case AP_RESPONSE_DECONFIGURED:
 +		case AP_RESPONSE_CHECKSTOPPED:
 +			return -ENODEV;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	if ((ap_dev->reset != AP_RESET_IN_PROGRESS) &&
 +		(ap_dev->interrupt == AP_INTR_IN_PROGRESS)) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		if (ap_using_interrupts()) {
 +			if (status.int_enabled == 1)
 +				ap_dev->interrupt = AP_INTR_ENABLED;
 +			else
 +				*flags |= AP_POLL_AFTER_TIMEOUT;
 +		} else
 +			ap_dev->interrupt = AP_INTR_DISABLED;
 +	}
 +
 +	rc = ap_poll_read(ap_dev, flags);
 +	if (rc)
 +		return rc;
 +	return ap_poll_write(ap_dev, flags);
 +}
 +
 +/**
 + * __ap_queue_message(): Queue a message to a device.
 + * @ap_dev: pointer to the AP device
 + * @ap_msg: the message to be queued
 + *
 + * Queue a message to a device. Returns 0 if successful.
 + */
 +static int __ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_queue_status status;
 +
 +	if (list_empty(&ap_dev->requestq) &&
 +	    (ap_dev->queue_count < ap_dev->queue_depth) &&
 +	    (ap_dev->reset != AP_RESET_IN_PROGRESS)) {
 +		status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +				   ap_msg->message, ap_msg->length,
 +				   ap_msg->special);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			list_add_tail(&ap_msg->list, &ap_dev->pendingq);
 +			atomic_inc(&ap_poll_requests);
 +			ap_dev->pendingq_count++;
 +			ap_increase_queue_count(ap_dev);
 +			ap_dev->total_request_count++;
 +			break;
 +		case AP_RESPONSE_Q_FULL:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +			ap_dev->requestq_count++;
 +			ap_dev->total_request_count++;
 +			return -EBUSY;
 +		case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		case AP_RESPONSE_MESSAGE_TOO_BIG:
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EINVAL));
 +			return -EINVAL;
 +		default:	/* Device is gone. */
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +			return -ENODEV;
 +		}
 +	} else {
 +		list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +		ap_dev->requestq_count++;
 +		ap_dev->total_request_count++;
 +		return -EBUSY;
 +	}
 +	ap_schedule_poll_timer();
 +	return 0;
 +}
 +
 +void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	unsigned long flags;
 +	int rc;
 +
 +	/* For asynchronous message handling a valid receive-callback
 +	 * is required. */
 +	BUG_ON(!ap_msg->receive);
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!ap_dev->unregistered) {
 +		/* Make room on the queue by polling for finished requests. */
 +		rc = ap_poll_queue(ap_dev, &flags);
 +		if (!rc)
 +			rc = __ap_queue_message(ap_dev, ap_msg);
 +		if (!rc)
 +			wake_up(&ap_poll_wait);
 +		if (rc == -ENODEV) {
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		}
 +	} else if (ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		rc = -ENODEV;
 +	} else { /* device registration in progress */
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EBUSY));
 +		rc = -EBUSY;
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +
 +	/* no device_unregister(), let ap_scan_bus() do the job */
 +}
 +EXPORT_SYMBOL(ap_queue_message);
 +
 +/**
 + * ap_cancel_message(): Cancel a crypto request.
 + * @ap_dev: The AP device that has the message queued
 + * @ap_msg: The message that is to be removed
 + *
 + * Cancel a crypto request. This is done by removing the request
 + * from the device pending or request queue. Note that the
 + * request stays on the AP queue. When it finishes the message
 + * reply will be discarded because the psmid can't be found.
 + */
 +void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_message *tmp;
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!list_empty(&ap_msg->list)) {
 +		list_for_each_entry(tmp, &ap_dev->pendingq, list)
 +			if (tmp->psmid == ap_msg->psmid) {
 +				ap_dev->pendingq_count--;
 +				goto found;
 +			}
 +		ap_dev->requestq_count--;
 +	found:
 +		list_del_init(&ap_msg->list);
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +}
 +EXPORT_SYMBOL(ap_cancel_message);
 +
 +/**
 + * ap_poll_timeout(): AP receive polling for finished AP requests.
 + * @unused: Unused pointer.
 + *
 + * Schedules the AP tasklet using a high resolution timer.
 + */
 +static enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)
 +{
 +	tasklet_schedule(&ap_tasklet);
 +	return HRTIMER_NORESTART;
 +}
 +
 +/**
 + * ap_reset(): Reset a not responding AP device.
 + * @ap_dev: Pointer to the AP device
 + *
 + * Reset a not responding AP device and move all requests from the
 + * pending queue to the request queue.
 + */
 +static void ap_reset(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +	ap_dev->queue_count = 0;
 +	list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +	ap_dev->requestq_count += ap_dev->pendingq_count;
 +	ap_dev->pendingq_count = 0;
 +	rc = ap_init_queue(ap_dev);
 +	if (rc == -ENODEV)
 +		ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +	else
 +		*flags |= AP_POLL_AFTER_TIMEOUT;
 +}
 +
 +static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	if (!ap_dev->unregistered) {
 +		rc = ap_poll_queue(ap_dev, flags);
 +		if (rc == -ENODEV)
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +		if (ap_dev->reset == AP_RESET_DO)
 +			ap_reset(ap_dev, flags);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_all(): Poll all AP devices.
 + * @dummy: Unused variable
 + *
 + * Poll all AP devices on the bus in a round robin fashion. Continue
 + * polling until bit 2^0 of the control flags is not set. If bit 2^1
 + * of the control flags has been set arm the poll timer.
 + */
 +static void ap_poll_all(unsigned long dummy)
 +{
 +	unsigned long flags;
 +	struct ap_device *ap_dev;
 +
 +	/* Reset the indicator if interrupts are used. Thus new interrupts can
 +	 * be received. Doing it in the beginning of the tasklet is therefor
 +	 * important that no requests on any AP get lost.
 +	 */
 +	if (ap_using_interrupts())
 +		xchg(ap_airq.lsi_ptr, 0);
 +	do {
 +		flags = 0;
 +		spin_lock(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock(&ap_device_list_lock);
 +	} while (flags & AP_POLL_IMMEDIATELY);
 +	if (flags & AP_POLL_AFTER_TIMEOUT)
 +		__ap_schedule_poll_timer();
 +}
 +
 +/**
 + * ap_poll_thread(): Thread that polls for finished requests.
 + * @data: Unused pointer
 + *
 + * AP bus poll thread. The purpose of this thread is to poll for
 + * finished requests in a loop if there is a "free" cpu - that is
 + * a cpu that doesn't have anything better to do. The polling stops
 + * as soon as there is another task or if all messages have been
 + * delivered.
 + */
 +static int ap_poll_thread(void *data)
 +{
 +	DECLARE_WAITQUEUE(wait, current);
 +	unsigned long flags;
 +	int requests;
 +	struct ap_device *ap_dev;
 +
 +	set_user_nice(current, 19);
 +	while (1) {
 +		if (ap_suspend_flag)
 +			return 0;
 +		if (need_resched()) {
 +			schedule();
 +			continue;
 +		}
 +		add_wait_queue(&ap_poll_wait, &wait);
 +		set_current_state(TASK_INTERRUPTIBLE);
 +		if (kthread_should_stop())
 +			break;
 +		requests = atomic_read(&ap_poll_requests);
 +		if (requests <= 0)
 +			schedule();
 +		set_current_state(TASK_RUNNING);
 +		remove_wait_queue(&ap_poll_wait, &wait);
 +
 +		flags = 0;
 +		spin_lock_bh(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock_bh(&ap_device_list_lock);
 +	}
 +	set_current_state(TASK_RUNNING);
 +	remove_wait_queue(&ap_poll_wait, &wait);
 +	return 0;
 +}
 +
 +static int ap_poll_thread_start(void)
 +{
 +	int rc;
 +
 +	if (ap_using_interrupts() || ap_suspend_flag)
 +		return 0;
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (!ap_poll_kthread) {
 +		ap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");
 +		rc = IS_ERR(ap_poll_kthread) ? PTR_ERR(ap_poll_kthread) : 0;
 +		if (rc)
 +			ap_poll_kthread = NULL;
 +	}
 +	else
 +		rc = 0;
 +	mutex_unlock(&ap_poll_thread_mutex);
 +	return rc;
 +}
 +
 +static void ap_poll_thread_stop(void)
 +{
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (ap_poll_kthread) {
 +		kthread_stop(ap_poll_kthread);
 +		ap_poll_kthread = NULL;
 +	}
 +	mutex_unlock(&ap_poll_thread_mutex);
 +}
 +
 +/**
 + * ap_request_timeout(): Handling of request timeouts
 + * @data: Holds the AP device.
 + *
 + * Handles request timeouts.
 + */
 +static void ap_request_timeout(unsigned long data)
 +{
 +	struct ap_device *ap_dev = (struct ap_device *) data;
 +
 +	if (ap_dev->reset == AP_RESET_ARMED) {
 +		ap_dev->reset = AP_RESET_DO;
 +
 +		if (ap_using_interrupts())
 +			tasklet_schedule(&ap_tasklet);
 +	}
  }
  
  static void ap_reset_domain(void)
@@@ -2045,12 -1170,30 +2298,36 @@@ void ap_debug_exit(void
   */
  int __init ap_module_init(void)
  {
 -	int max_domain_id;
  	int rc, i;
  
++<<<<<<< HEAD
 +	if (ap_domain_index < -1 || ap_domain_index >= AP_DOMAINS) {
 +		pr_warning("%d is not a valid cryptographic domain\n",
 +			   ap_domain_index);
 +		return -EINVAL;
++=======
+ 	rc = ap_debug_init();
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (ap_instructions_available() != 0) {
+ 		pr_warn("The hardware system does not support AP instructions\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Get AP configuration data if available */
+ 	ap_init_configuration();
+ 
+ 	if (ap_configuration)
+ 		max_domain_id = ap_max_domain_id ? : (AP_DOMAINS - 1);
+ 	else
+ 		max_domain_id = 15;
+ 	if (ap_domain_index < -1 || ap_domain_index > max_domain_id) {
+ 		pr_warn("%d is not a valid cryptographic domain\n",
+ 			ap_domain_index);
+ 		rc = -EINVAL;
+ 		goto out_free;
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  	}
  	/* In resume callback we need to know if the user had set the domain.
  	 * If so, we can not just reset it.
diff --cc drivers/s390/crypto/zcrypt_api.c
index 0d5282ef176d,7ca25e77bd6a..000000000000
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@@ -41,10 -41,11 +41,10 @@@
  #include <linux/debugfs.h>
  #include <asm/debug.h>
  
- #include "zcrypt_debug.h"
  #include "zcrypt_api.h"
+ #include "zcrypt_debug.h"
  
  #include "zcrypt_msgtype6.h"
 -#include "zcrypt_msgtype50.h"
  
  /*
   * Module description.
@@@ -63,63 -69,11 +63,69 @@@ static atomic_t zcrypt_rescan_count = A
  atomic_t zcrypt_rescan_req = ATOMIC_INIT(0);
  EXPORT_SYMBOL(zcrypt_rescan_req);
  
 +static int zcrypt_rng_device_add(void);
 +static void zcrypt_rng_device_remove(void);
 +
 +static DEFINE_SPINLOCK(zcrypt_ops_list_lock);
  static LIST_HEAD(zcrypt_ops_list);
  
++<<<<<<< HEAD
 +static debug_info_t *zcrypt_dbf_common;
 +static debug_info_t *zcrypt_dbf_devices;
 +static struct dentry *debugfs_root;
 +
 +/*
 + * Device attributes common for all crypto devices.
 + */
 +static ssize_t zcrypt_type_show(struct device *dev,
 +				struct device_attribute *attr, char *buf)
 +{
 +	struct zcrypt_device *zdev = to_ap_dev(dev)->private;
 +	return snprintf(buf, PAGE_SIZE, "%s\n", zdev->type_string);
 +}
 +
 +static DEVICE_ATTR(type, 0444, zcrypt_type_show, NULL);
 +
 +static ssize_t zcrypt_online_show(struct device *dev,
 +				  struct device_attribute *attr, char *buf)
 +{
 +	struct zcrypt_device *zdev = to_ap_dev(dev)->private;
 +	return snprintf(buf, PAGE_SIZE, "%d\n", zdev->online);
 +}
 +
 +static ssize_t zcrypt_online_store(struct device *dev,
 +				   struct device_attribute *attr,
 +				   const char *buf, size_t count)
 +{
 +	struct zcrypt_device *zdev = to_ap_dev(dev)->private;
 +	int online;
 +
 +	if (sscanf(buf, "%d\n", &online) != 1 || online < 0 || online > 1)
 +		return -EINVAL;
 +	zdev->online = online;
 +	ZCRYPT_DBF_DEV(DBF_INFO, zdev, "dev%04xo%dman", zdev->ap_dev->qid,
 +		       zdev->online);
 +	if (!online)
 +		ap_flush_queue(zdev->ap_dev);
 +	return count;
 +}
 +
 +static DEVICE_ATTR(online, 0644, zcrypt_online_show, zcrypt_online_store);
 +
 +static struct attribute * zcrypt_device_attrs[] = {
 +	&dev_attr_type.attr,
 +	&dev_attr_online.attr,
 +	NULL,
 +};
 +
 +static struct attribute_group zcrypt_device_attr_group = {
 +	.attrs = zcrypt_device_attrs,
 +};
++=======
+ /* Zcrypt related debug feature stuff. */
+ static struct dentry *zcrypt_dbf_root;
+ debug_info_t *zcrypt_dbf_info;
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
  /**
   * Process a rescan of the transport layer.
@@@ -1461,26 -1362,19 +1467,39 @@@ static void zcrypt_rng_device_remove(vo
  
  int __init zcrypt_debug_init(void)
  {
++<<<<<<< HEAD
 +	debugfs_root = debugfs_create_dir("zcrypt", NULL);
 +
 +	zcrypt_dbf_common = debug_register("zcrypt_common", 1, 1, 16);
 +	debug_register_view(zcrypt_dbf_common, &debug_hex_ascii_view);
 +	debug_set_level(zcrypt_dbf_common, DBF_ERR);
 +
 +	zcrypt_dbf_devices = debug_register("zcrypt_devices", 1, 1, 16);
 +	debug_register_view(zcrypt_dbf_devices, &debug_hex_ascii_view);
 +	debug_set_level(zcrypt_dbf_devices, DBF_ERR);
++=======
+ 	zcrypt_dbf_root = debugfs_create_dir("zcrypt", NULL);
+ 	zcrypt_dbf_info = debug_register("zcrypt", 1, 1,
+ 					 DBF_MAX_SPRINTF_ARGS * sizeof(long));
+ 	debug_register_view(zcrypt_dbf_info, &debug_sprintf_view);
+ 	debug_set_level(zcrypt_dbf_info, DBF_ERR);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
  	return 0;
  }
  
  void zcrypt_debug_exit(void)
  {
++<<<<<<< HEAD
 +	debugfs_remove(debugfs_root);
 +	if (zcrypt_dbf_common)
 +		debug_unregister(zcrypt_dbf_common);
 +	if (zcrypt_dbf_devices)
 +		debug_unregister(zcrypt_dbf_devices);
++=======
+ 	debugfs_remove(zcrypt_dbf_root);
+ 	debug_unregister(zcrypt_dbf_info);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  }
  
  /**
@@@ -1527,6 -1424,8 +1546,11 @@@ void zcrypt_api_exit(void
  {
  	remove_proc_entry("driver/z90crypt", NULL);
  	misc_deregister(&zcrypt_misc_device);
++<<<<<<< HEAD
++=======
+ 	zcrypt_msgtype6_exit();
+ 	zcrypt_msgtype50_exit();
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  	zcrypt_debug_exit();
  }
  
diff --cc drivers/s390/crypto/zcrypt_api.h
index e2dfadd228c1,274a59051534..000000000000
--- a/drivers/s390/crypto/zcrypt_api.h
+++ b/drivers/s390/crypto/zcrypt_api.h
@@@ -110,33 -127,68 +110,91 @@@ struct zcrypt_device 
  	char *type_string;		/* User space device name. */
  	int min_mod_size;		/* Min number of bits. */
  	int max_mod_size;		/* Max number of bits. */
++<<<<<<< HEAD
 +	int short_crt;			/* Card has crt length restriction. */
 +	int speed_rating;		/* Speed of the crypto device. */
++=======
+ 	int max_exp_bit_length;
+ 	int speed_rating[NUM_OPS];	/* Speed idx of crypto ops. */
+ 	atomic_t load;			/* Utilization of the crypto device */
+ 
+ 	int request_count;		/* # current requests. */
+ };
+ 
+ struct zcrypt_queue {
+ 	struct list_head list;		/* Device list. */
+ 	struct kref refcount;		/* device refcounting */
+ 	struct zcrypt_card *zcard;
+ 	struct zcrypt_ops *ops;		/* Crypto operations. */
+ 	struct ap_queue *queue;		/* The "real" ap queue device. */
+ 	int online;			/* User online/offline */
+ 
+ 	atomic_t load;			/* Utilization of the crypto device */
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
  	int request_count;		/* # current requests. */
  
  	struct ap_message reply;	/* Per-device reply structure. */
++<<<<<<< HEAD
 +	int max_exp_bit_length;
 +
 +	debug_info_t *dbf_area;		/* debugging */
++=======
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  };
  
  /* transport layer rescanning */
  extern atomic_t zcrypt_rescan_req;
  
++<<<<<<< HEAD
 +struct zcrypt_device *zcrypt_device_alloc(size_t);
 +void zcrypt_device_free(struct zcrypt_device *);
 +void zcrypt_device_get(struct zcrypt_device *);
 +int zcrypt_device_put(struct zcrypt_device *);
 +int zcrypt_device_register(struct zcrypt_device *);
 +void zcrypt_device_unregister(struct zcrypt_device *);
++=======
+ extern spinlock_t zcrypt_list_lock;
+ extern int zcrypt_device_count;
+ extern struct list_head zcrypt_card_list;
+ 
+ #define for_each_zcrypt_card(_zc) \
+ 	list_for_each_entry(_zc, &zcrypt_card_list, list)
+ 
+ #define for_each_zcrypt_queue(_zq, _zc) \
+ 	list_for_each_entry(_zq, &(_zc)->zqueues, list)
+ 
+ struct zcrypt_card *zcrypt_card_alloc(void);
+ void zcrypt_card_free(struct zcrypt_card *);
+ void zcrypt_card_get(struct zcrypt_card *);
+ int zcrypt_card_put(struct zcrypt_card *);
+ int zcrypt_card_register(struct zcrypt_card *);
+ void zcrypt_card_unregister(struct zcrypt_card *);
+ struct zcrypt_card *zcrypt_card_get_best(unsigned int *,
+ 					 unsigned int, unsigned int);
+ void zcrypt_card_put_best(struct zcrypt_card *, unsigned int);
+ 
+ struct zcrypt_queue *zcrypt_queue_alloc(size_t);
+ void zcrypt_queue_free(struct zcrypt_queue *);
+ void zcrypt_queue_get(struct zcrypt_queue *);
+ int zcrypt_queue_put(struct zcrypt_queue *);
+ int zcrypt_queue_register(struct zcrypt_queue *);
+ void zcrypt_queue_unregister(struct zcrypt_queue *);
+ void zcrypt_queue_force_online(struct zcrypt_queue *, int);
+ struct zcrypt_queue *zcrypt_queue_get_best(unsigned int, unsigned int);
+ void  zcrypt_queue_put_best(struct zcrypt_queue *, unsigned int);
+ 
+ int zcrypt_rng_device_add(void);
+ void zcrypt_rng_device_remove(void);
+ 
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  void zcrypt_msgtype_register(struct zcrypt_ops *);
  void zcrypt_msgtype_unregister(struct zcrypt_ops *);
 -struct zcrypt_ops *zcrypt_msgtype(unsigned char *, int);
 +struct zcrypt_ops *zcrypt_msgtype_request(unsigned char *, int);
 +void zcrypt_msgtype_release(struct zcrypt_ops *);
  int zcrypt_api_init(void);
  void zcrypt_api_exit(void);
 +long zcrypt_send_cprb(struct ica_xcRB *xcRB);
 +void zcrypt_device_status_mask(struct zcrypt_device_matrix *devstatus);
  
  #endif /* _ZCRYPT_API_H_ */
diff --cc drivers/s390/crypto/zcrypt_debug.h
index 841ea72e4a4e,13e38defb6b8..000000000000
--- a/drivers/s390/crypto/zcrypt_debug.h
+++ b/drivers/s390/crypto/zcrypt_debug.h
@@@ -6,52 -7,21 +7,68 @@@
  #define ZCRYPT_DEBUG_H
  
  #include <asm/debug.h>
- #include "zcrypt_api.h"
  
++<<<<<<< HEAD
 +/* that gives us 15 characters in the text event views */
 +#define ZCRYPT_DBF_LEN	16
 +
 +/* sort out low debug levels early to avoid wasted sprints */
 +static inline int zcrypt_dbf_passes(debug_info_t *dbf_grp, int level)
 +{
 +	return (level <= dbf_grp->level);
 +}
 +
 +#define DBF_ERR		3	/* error conditions	*/
 +#define DBF_WARN	4	/* warning conditions	*/
 +#define DBF_INFO	6	/* informational	*/
++=======
+ #define DBF_ERR		3	/* error conditions   */
+ #define DBF_WARN	4	/* warning conditions */
+ #define DBF_INFO	5	/* informational      */
+ #define DBF_DEBUG	6	/* for debugging only */
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
+ #define RC2ERR(rc) ((rc) ? DBF_ERR : DBF_INFO)
  #define RC2WARN(rc) ((rc) ? DBF_WARN : DBF_INFO)
  
++<<<<<<< HEAD
 +#define ZCRYPT_DBF_COMMON(level, text...) \
 +	do { \
 +		if (zcrypt_dbf_passes(zcrypt_dbf_common, level)) { \
 +			char debug_buffer[ZCRYPT_DBF_LEN]; \
 +			snprintf(debug_buffer, ZCRYPT_DBF_LEN, text); \
 +			debug_text_event(zcrypt_dbf_common, level, \
 +					 debug_buffer); \
 +		} \
 +	} while (0)
 +
 +#define ZCRYPT_DBF_DEVICES(level, text...) \
 +	do { \
 +		if (zcrypt_dbf_passes(zcrypt_dbf_devices, level)) { \
 +			char debug_buffer[ZCRYPT_DBF_LEN]; \
 +			snprintf(debug_buffer, ZCRYPT_DBF_LEN, text); \
 +			debug_text_event(zcrypt_dbf_devices, level, \
 +					 debug_buffer); \
 +		} \
 +	} while (0)
 +
 +#define ZCRYPT_DBF_DEV(level, device, text...) \
 +	do { \
 +		if (zcrypt_dbf_passes(device->dbf_area, level)) { \
 +			char debug_buffer[ZCRYPT_DBF_LEN]; \
 +			snprintf(debug_buffer, ZCRYPT_DBF_LEN, text); \
 +			debug_text_event(device->dbf_area, level, \
 +					 debug_buffer); \
 +		} \
 +	} while (0)
++=======
+ #define DBF_MAX_SPRINTF_ARGS 5
+ 
+ #define ZCRYPT_DBF(...)					\
+ 	debug_sprintf_event(zcrypt_dbf_info, ##__VA_ARGS__)
+ 
+ extern debug_info_t *zcrypt_dbf_info;
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  
  int zcrypt_debug_init(void);
  void zcrypt_debug_exit(void);
diff --cc drivers/s390/crypto/zcrypt_error.h
index a9c4d2d160af,13df60209ed3..000000000000
--- a/drivers/s390/crypto/zcrypt_error.h
+++ b/drivers/s390/crypto/zcrypt_error.h
@@@ -114,32 -119,32 +119,58 @@@ static inline int convert_error(struct 
  		 * and then repeat the request.
  		 */
  		atomic_set(&zcrypt_rescan_req, 1);
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%drc%d",
 +			AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online,
 +			ehdr->reply_code);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       card, queue);
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
+ 			   card, queue, ehdr->reply_code);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;
  	case REP82_ERROR_TRANSPORT_FAIL:
  	case REP82_ERROR_MACHINE_FAILURE:
  	//   REP88_ERROR_MODULE_FAILURE		// '10' CEX2A
  		/* If a card fails disable it and repeat the request. */
  		atomic_set(&zcrypt_rescan_req, 1);
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%drc%d",
 +			AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online,
 +			ehdr->reply_code);
 +		return -EAGAIN;
 +	default:
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%drc%d",
 +			AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online,
 +			ehdr->reply_code);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       card, queue);
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
+ 			   card, queue, ehdr->reply_code);
+ 		return -EAGAIN;
+ 	default:
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       card, queue);
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x reply=0x%02x => online=0 rc=EAGAIN\n",
+ 			   card, queue, ehdr->reply_code);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
  }
diff --cc drivers/s390/crypto/zcrypt_msgtype50.c
index 64cd342bbc8d,6dd5d7c58dd0..000000000000
--- a/drivers/s390/crypto/zcrypt_msgtype50.c
+++ b/drivers/s390/crypto/zcrypt_msgtype50.c
@@@ -334,16 -363,18 +334,28 @@@ static int convert_type80(struct zcrypt
  
  	if (t80h->len < sizeof(*t80h) + outputdatalength) {
  		/* The result is too short, the CEX2A card may not do that.. */
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%drc%d",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid),
 +			       zdev->online, t80h->code);
 +
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   t80h->code);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
 -	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
 +	if (zdev->user_space_type == ZCRYPT_CEX2A)
  		BUG_ON(t80h->len > CEX2A_MAX_RESPONSE_SIZE);
  	else
  		BUG_ON(t80h->len > CEX3A_MAX_RESPONSE_SIZE);
@@@ -359,19 -390,25 +371,33 @@@ static int convert_response(struct zcry
  			    unsigned int outputdatalength)
  {
  	/* Response type byte is the second byte in the response. */
- 	switch (((unsigned char *) reply->message)[1]) {
+ 	unsigned char rtype = ((unsigned char *) reply->message)[1];
+ 
+ 	switch (rtype) {
  	case TYPE82_RSP_CODE:
  	case TYPE88_RSP_CODE:
 -		return convert_error(zq, reply);
 +		return convert_error(zdev, reply);
  	case TYPE80_RSP_CODE:
 -		return convert_type80(zq, reply,
 +		return convert_type80(zdev, reply,
  				      outputdata, outputdatalength);
  	default: /* Unknown response type, this should NEVER EVER happen */
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%dfail",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   (unsigned int) rtype);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
  }
diff --cc drivers/s390/crypto/zcrypt_msgtype6.c
index 9adcfa43d01d,e5563ffeb839..000000000000
--- a/drivers/s390/crypto/zcrypt_msgtype6.c
+++ b/drivers/s390/crypto/zcrypt_msgtype6.c
@@@ -556,26 -638,37 +556,53 @@@ static int convert_type86_ica(struct zc
  	service_rc = msg->cprbx.ccp_rtcode;
  	if (unlikely(service_rc != 0)) {
  		service_rs = msg->cprbx.ccp_rscode;
- 		if (service_rc == 8 && service_rs == 66)
- 			return -EINVAL;
- 		if (service_rc == 8 && service_rs == 65)
- 			return -EINVAL;
- 		if (service_rc == 8 && service_rs == 770)
+ 		if ((service_rc == 8 && service_rs == 66) ||
+ 		    (service_rc == 8 && service_rs == 65) ||
+ 		    (service_rc == 8 && service_rs == 72) ||
+ 		    (service_rc == 8 && service_rs == 770) ||
+ 		    (service_rc == 12 && service_rs == 769)) {
+ 			ZCRYPT_DBF(DBF_DEBUG,
+ 				   "device=%02x.%04x rc/rs=%d/%d => rc=EINVAL\n",
+ 				   AP_QID_CARD(zq->queue->qid),
+ 				   AP_QID_QUEUE(zq->queue->qid),
+ 				   (int) service_rc, (int) service_rs);
  			return -EINVAL;
+ 		}
  		if (service_rc == 8 && service_rs == 783) {
++<<<<<<< HEAD
 +			zdev->min_mod_size = PCIXCC_MIN_MOD_SIZE_OLD;
 +			return -EAGAIN;
 +		}
 +		if (service_rc == 12 && service_rs == 769)
 +			return -EINVAL;
 +		if (service_rc == 8 && service_rs == 72)
 +			return -EINVAL;
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%drc%d",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online,
 +			       msg->hdr.reply_code);
++=======
+ 			zq->zcard->min_mod_size =
+ 				PCIXCC_MIN_MOD_SIZE_OLD;
+ 			ZCRYPT_DBF(DBF_DEBUG,
+ 				   "device=%02x.%04x rc/rs=%d/%d => rc=EAGAIN\n",
+ 				   AP_QID_CARD(zq->queue->qid),
+ 				   AP_QID_QUEUE(zq->queue->qid),
+ 				   (int) service_rc, (int) service_rs);
+ 			return -EAGAIN;
+ 		}
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x rc/rs=%d/%d => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   (int) service_rc, (int) service_rs);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
  	data = msg->text;
@@@ -690,11 -783,10 +717,10 @@@ static int convert_response_ica(struct 
  {
  	struct type86x_reply *msg = reply->message;
  
- 	/* Response type byte is the second byte in the response. */
- 	switch (((unsigned char *) reply->message)[1]) {
+ 	switch (msg->hdr.type) {
  	case TYPE82_RSP_CODE:
  	case TYPE88_RSP_CODE:
 -		return convert_error(zq, reply);
 +		return convert_error(zdev, reply);
  	case TYPE86_RSP_CODE:
  		if (msg->cprbx.ccp_rtcode &&
  		   (msg->cprbx.ccp_rscode == 0x14f) &&
@@@ -713,11 -805,15 +739,23 @@@
  		/* Fall through, no break, incorrect cprb version is an unknown
  		 * response */
  	default: /* Unknown response type, this should NEVER EVER happen */
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%dfail",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   (int) msg->hdr.type);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
  }
@@@ -745,11 -840,15 +782,23 @@@ static int convert_response_xcrb(struc
  		 * response */
  	default: /* Unknown response type, this should NEVER EVER happen */
  		xcRB->status = 0x0008044DL; /* HDD_InvalidParm */
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%dfail",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   (int) msg->hdr.type);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
  }
@@@ -759,23 -858,26 +808,34 @@@ static int convert_response_ep11_xcrb(s
  {
  	struct type86_ep11_reply *msg = reply->message;
  
- 	/* Response type byte is the second byte in the response. */
- 	switch (((unsigned char *)reply->message)[1]) {
+ 	switch (msg->hdr.type) {
  	case TYPE82_RSP_CODE:
  	case TYPE87_RSP_CODE:
 -		return convert_error(zq, reply);
 +		return convert_error(zdev, reply);
  	case TYPE86_RSP_CODE:
  		if (msg->hdr.reply_code)
 -			return convert_error(zq, reply);
 +			return convert_error(zdev, reply);
  		if (msg->cprbx.cprb_ver_id == 0x04)
 -			return convert_type86_ep11_xcrb(zq, reply, xcRB);
 +			return convert_type86_ep11_xcrb(zdev, reply, xcRB);
  	/* Fall through, no break, incorrect cprb version is an unknown resp.*/
  	default: /* Unknown response type, this should NEVER EVER happen */
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%dfail",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   (int) msg->hdr.type);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN; /* repeat the request on a different device. */
  	}
  }
@@@ -798,11 -900,15 +858,23 @@@ static int convert_response_rng(struct 
  		/* Fall through, no break, incorrect cprb version is an unknown
  		 * response */
  	default: /* Unknown response type, this should NEVER EVER happen */
++<<<<<<< HEAD
 +		zdev->online = 0;
 +		pr_err("Cryptographic device %x failed and was set offline\n",
 +		       AP_QID_DEVICE(zdev->ap_dev->qid));
 +		ZCRYPT_DBF_DEV(DBF_ERR, zdev, "dev%04xo%dfail",
 +			       AP_QID_DEVICE(zdev->ap_dev->qid), zdev->online);
++=======
+ 		zq->online = 0;
+ 		pr_err("Cryptographic device %02x.%04x failed and was set offline\n",
+ 		       AP_QID_CARD(zq->queue->qid),
+ 		       AP_QID_QUEUE(zq->queue->qid));
+ 		ZCRYPT_DBF(DBF_ERR,
+ 			   "device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",
+ 			   AP_QID_CARD(zq->queue->qid),
+ 			   AP_QID_QUEUE(zq->queue->qid),
+ 			   (int) msg->hdr.type);
++>>>>>>> cccd85bfb7bf (s390/zcrypt: Rework debug feature invocations.)
  		return -EAGAIN;	/* repeat the request on a different device. */
  	}
  }
* Unmerged path drivers/s390/crypto/zcrypt_card.c
* Unmerged path drivers/s390/crypto/zcrypt_queue.c
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/crypto/ap_debug.h b/drivers/s390/crypto/ap_debug.h
new file mode 100644
index 000000000000..78dbff842dae
--- /dev/null
+++ b/drivers/s390/crypto/ap_debug.h
@@ -0,0 +1,28 @@
+/*
+ *  Copyright IBM Corp. 2016
+ *  Author(s): Harald Freudenberger <freude@de.ibm.com>
+ */
+#ifndef AP_DEBUG_H
+#define AP_DEBUG_H
+
+#include <asm/debug.h>
+
+#define DBF_ERR		3	/* error conditions   */
+#define DBF_WARN	4	/* warning conditions */
+#define DBF_INFO	5	/* informational      */
+#define DBF_DEBUG	6	/* for debugging only */
+
+#define RC2ERR(rc) ((rc) ? DBF_ERR : DBF_INFO)
+#define RC2WARN(rc) ((rc) ? DBF_WARN : DBF_INFO)
+
+#define DBF_MAX_SPRINTF_ARGS 5
+
+#define AP_DBF(...)					\
+	debug_sprintf_event(ap_dbf_info, ##__VA_ARGS__)
+
+extern debug_info_t *ap_dbf_info;
+
+int ap_debug_init(void);
+void ap_debug_exit(void);
+
+#endif /* AP_DEBUG_H */
* Unmerged path drivers/s390/crypto/zcrypt_api.c
* Unmerged path drivers/s390/crypto/zcrypt_api.h
* Unmerged path drivers/s390/crypto/zcrypt_card.c
* Unmerged path drivers/s390/crypto/zcrypt_debug.h
* Unmerged path drivers/s390/crypto/zcrypt_error.h
* Unmerged path drivers/s390/crypto/zcrypt_msgtype50.c
* Unmerged path drivers/s390/crypto/zcrypt_msgtype6.c
* Unmerged path drivers/s390/crypto/zcrypt_queue.c
