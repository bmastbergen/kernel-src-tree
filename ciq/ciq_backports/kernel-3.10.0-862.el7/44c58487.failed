IB/core: Define 'ib' and 'roce' rdma_ah_attr types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
commit 44c58487d51a0dc43d96f1dc864f0461ec6a346a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/44c58487.failed

rdma_ah_attr can now be either ib or roce allowing
core components to use one type or the other and also
to define attributes unique to a specific type. struct
ib_ah is also initialized with the type when its first
created. This ensures that calls such as modify_ah
dont modify the type of the address handle attribute.

	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Don Hiatt <don.hiatt@intel.com>
	Reviewed-by: Sean Hefty <sean.hefty@intel.com>
	Reviewed-by: Niranjana Vishwanathapura <niranjana.vishwanathapura@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 44c58487d51a0dc43d96f1dc864f0461ec6a346a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cm.c
#	drivers/infiniband/core/multicast.c
#	drivers/infiniband/core/sa_query.c
#	drivers/infiniband/core/user_mad.c
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/verbs.c
#	drivers/infiniband/hw/bnxt_re/ib_verbs.c
#	drivers/infiniband/hw/hfi1/verbs.c
#	drivers/infiniband/hw/hns/hns_roce_hw_v1.c
#	drivers/infiniband/hw/mlx4/ah.c
#	drivers/infiniband/hw/mlx4/mad.c
#	drivers/infiniband/hw/mlx4/qp.c
#	drivers/infiniband/hw/mlx5/ah.c
#	drivers/infiniband/hw/mlx5/qp.c
#	drivers/infiniband/hw/mthca/mthca_av.c
#	drivers/infiniband/hw/mthca/mthca_mad.c
#	drivers/infiniband/hw/mthca/mthca_qp.c
#	drivers/infiniband/hw/ocrdma/ocrdma_ah.c
#	drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
#	drivers/infiniband/hw/qedr/verbs.c
#	drivers/infiniband/hw/qib/qib_verbs.c
#	drivers/infiniband/hw/vmw_pvrdma/pvrdma_misc.c
#	drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
#	drivers/infiniband/sw/rxe/rxe_av.c
#	drivers/infiniband/ulp/ipoib/ipoib_multicast.c
#	drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
#	include/rdma/ib_verbs.h
#	net/smc/smc_ib.c
diff --cc drivers/infiniband/core/cm.c
index 6535f09dc575,d35c2ded6cbd..000000000000
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@@ -1760,11 -1761,14 +1760,19 @@@ static int cm_req_handler(struct cm_wor
  	cm_process_routed_req(req_msg, work->mad_recv_wc->wc);
  	cm_format_paths_from_req(req_msg, &work->path[0], &work->path[1]);
  
++<<<<<<< HEAD
 +	memcpy(work->path[0].dmac, cm_id_priv->av.ah_attr.dmac, ETH_ALEN);
 +	work->path[0].hop_limit = cm_id_priv->av.ah_attr.grh.hop_limit;
++=======
+ 	if (cm_id_priv->av.ah_attr.type == RDMA_AH_ATTR_TYPE_ROCE)
+ 		memcpy(work->path[0].dmac, cm_id_priv->av.ah_attr.roce.dmac,
+ 		       ETH_ALEN);
+ 	grh = rdma_ah_read_grh(&cm_id_priv->av.ah_attr);
+ 	work->path[0].hop_limit = grh->hop_limit;
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	ret = ib_get_cached_gid(work->port->cm_dev->ib_device,
  				work->port->port_num,
 -				grh->sgid_index,
 +				cm_id_priv->av.ah_attr.grh.sgid_index,
  				&gid, &gid_attr);
  	if (!ret) {
  		if (gid_attr.ndev) {
diff --cc drivers/infiniband/core/multicast.c
index 322cb67b07a9,45f2f095f793..000000000000
--- a/drivers/infiniband/core/multicast.c
+++ b/drivers/infiniband/core/multicast.c
@@@ -743,19 -743,18 +743,23 @@@ int ib_init_ah_from_mcmember(struct ib_
  		return ret;
  
  	memset(ah_attr, 0, sizeof *ah_attr);
++<<<<<<< HEAD
 +	ah_attr->dlid = be16_to_cpu(rec->mlid);
 +	ah_attr->sl = rec->sl;
 +	ah_attr->port_num = port_num;
 +	ah_attr->static_rate = rec->rate;
++=======
+ 	ah_attr->type = rdma_ah_find_type(device, port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
 -	rdma_ah_set_dlid(ah_attr, be16_to_cpu(rec->mlid));
 -	rdma_ah_set_sl(ah_attr, rec->sl);
 -	rdma_ah_set_port_num(ah_attr, port_num);
 -	rdma_ah_set_static_rate(ah_attr, rec->rate);
 +	ah_attr->ah_flags = IB_AH_GRH;
 +	ah_attr->grh.dgid = rec->mgid;
 +
 +	ah_attr->grh.sgid_index = (u8) gid_index;
 +	ah_attr->grh.flow_label = be32_to_cpu(rec->flow_label);
 +	ah_attr->grh.hop_limit = rec->hop_limit;
 +	ah_attr->grh.traffic_class = rec->traffic_class;
  
 -	rdma_ah_set_grh(ah_attr, &rec->mgid,
 -			be32_to_cpu(rec->flow_label),
 -			(u8)gid_index,
 -			rec->hop_limit,
 -			rec->traffic_class);
  	return 0;
  }
  EXPORT_SYMBOL(ib_init_ah_from_mcmember);
diff --cc drivers/infiniband/core/sa_query.c
index 17b24d8a34e1,23ba90d55c63..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -1007,13 -1108,14 +1007,17 @@@ int ib_init_ah_from_path(struct ib_devi
  	struct net_device *ndev = NULL;
  
  	memset(ah_attr, 0, sizeof *ah_attr);
++<<<<<<< HEAD
 +	ah_attr->dlid = be16_to_cpu(rec->dlid);
 +	ah_attr->sl = rec->sl;
 +	ah_attr->src_path_bits = be16_to_cpu(rec->slid) &
 +				 get_src_path_mask(device, port_num);
 +	ah_attr->port_num = port_num;
 +	ah_attr->static_rate = rec->rate;
++=======
+ 	ah_attr->type = rdma_ah_find_type(device, port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
 -	rdma_ah_set_dlid(ah_attr, be16_to_cpu(rec->dlid));
 -	rdma_ah_set_sl(ah_attr, rec->sl);
 -	rdma_ah_set_path_bits(ah_attr, be16_to_cpu(rec->slid) &
 -			      get_src_path_mask(device, port_num));
 -	rdma_ah_set_port_num(ah_attr, port_num);
 -	rdma_ah_set_static_rate(ah_attr, rec->rate);
  	use_roce = rdma_cap_eth_ah(device, port_num);
  
  	if (use_roce) {
@@@ -1837,18 -2030,21 +1841,26 @@@ static void update_sm_ah(struct work_st
  		pr_err("Couldn't find index for default PKey\n");
  
  	memset(&ah_attr, 0, sizeof(ah_attr));
++<<<<<<< HEAD
 +	ah_attr.dlid     = port_attr.sm_lid;
 +	ah_attr.sl       = port_attr.sm_sl;
 +	ah_attr.port_num = port->port_num;
++=======
+ 	ah_attr.type = rdma_ah_find_type(port->agent->device,
+ 					 port->port_num);
+ 	rdma_ah_set_dlid(&ah_attr, port_attr.sm_lid);
+ 	rdma_ah_set_sl(&ah_attr, port_attr.sm_sl);
+ 	rdma_ah_set_port_num(&ah_attr, port->port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	if (port_attr.grh_required) {
 -		rdma_ah_set_ah_flags(&ah_attr, IB_AH_GRH);
 -
 -		rdma_ah_set_subnet_prefix(&ah_attr,
 -					  cpu_to_be64(port_attr.subnet_prefix));
 -		rdma_ah_set_interface_id(&ah_attr,
 -					 cpu_to_be64(IB_SA_WELL_KNOWN_GUID));
 +		ah_attr.ah_flags = IB_AH_GRH;
 +		ah_attr.grh.dgid.global.subnet_prefix =
 +			cpu_to_be64(port_attr.subnet_prefix);
 +		ah_attr.grh.dgid.global.interface_id =
 +			cpu_to_be64(IB_SA_WELL_KNOWN_GUID);
  	}
  
 -	new_ah->ah = rdma_create_ah(port->agent->qp->pd, &ah_attr);
 +	new_ah->ah = ib_create_ah(port->agent->qp->pd, &ah_attr);
  	if (IS_ERR(new_ah->ah)) {
  		pr_warn("Couldn't create new SM AH\n");
  		kfree(new_ah);
diff --cc drivers/infiniband/core/user_mad.c
index 7241acee2674,200422d24299..000000000000
--- a/drivers/infiniband/core/user_mad.c
+++ b/drivers/infiniband/core/user_mad.c
@@@ -489,20 -491,22 +489,29 @@@ static ssize_t ib_umad_write(struct fil
  	}
  
  	memset(&ah_attr, 0, sizeof ah_attr);
++<<<<<<< HEAD
 +	ah_attr.dlid          = be16_to_cpu(packet->mad.hdr.lid);
 +	ah_attr.sl            = packet->mad.hdr.sl;
 +	ah_attr.src_path_bits = packet->mad.hdr.path_bits;
 +	ah_attr.port_num      = file->port->port_num;
++=======
+ 	ah_attr.type = rdma_ah_find_type(file->port->ib_dev,
+ 					 file->port->port_num);
+ 	rdma_ah_set_dlid(&ah_attr, be16_to_cpu(packet->mad.hdr.lid));
+ 	rdma_ah_set_sl(&ah_attr, packet->mad.hdr.sl);
+ 	rdma_ah_set_path_bits(&ah_attr, packet->mad.hdr.path_bits);
+ 	rdma_ah_set_port_num(&ah_attr, file->port->port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	if (packet->mad.hdr.grh_present) {
 -		rdma_ah_set_grh(&ah_attr, NULL,
 -				be32_to_cpu(packet->mad.hdr.flow_label),
 -				packet->mad.hdr.gid_index,
 -				packet->mad.hdr.hop_limit,
 -				packet->mad.hdr.traffic_class);
 -		rdma_ah_set_dgid_raw(&ah_attr, packet->mad.hdr.gid);
 +		ah_attr.ah_flags = IB_AH_GRH;
 +		memcpy(ah_attr.grh.dgid.raw, packet->mad.hdr.gid, 16);
 +		ah_attr.grh.sgid_index	   = packet->mad.hdr.gid_index;
 +		ah_attr.grh.flow_label	   = be32_to_cpu(packet->mad.hdr.flow_label);
 +		ah_attr.grh.hop_limit	   = packet->mad.hdr.hop_limit;
 +		ah_attr.grh.traffic_class  = packet->mad.hdr.traffic_class;
  	}
  
 -	ah = rdma_create_ah(agent->qp->pd, &ah_attr);
 +	ah = ib_create_ah(agent->qp->pd, &ah_attr);
  	if (IS_ERR(ah)) {
  		ret = PTR_ERR(ah);
  		goto err_up;
diff --cc drivers/infiniband/core/uverbs_cmd.c
index dfaa691d6dee,70b7fb156414..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -2374,42 -1954,47 +2374,46 @@@ static int modify_qp(struct ib_uverbs_f
  	attr->alt_timeout	  = cmd->base.alt_timeout;
  	attr->rate_limit	  = cmd->rate_limit;
  
+ 	attr->ah_attr.type = rdma_ah_find_type(qp->device,
+ 					       cmd->base.dest.port_num);
  	if (cmd->base.dest.is_global) {
 -		rdma_ah_set_grh(&attr->ah_attr, NULL,
 -				cmd->base.dest.flow_label,
 -				cmd->base.dest.sgid_index,
 -				cmd->base.dest.hop_limit,
 -				cmd->base.dest.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr->ah_attr, cmd->base.dest.dgid);
 +		memcpy(attr->ah_attr.grh.dgid.raw, cmd->base.dest.dgid, 16);
 +		attr->ah_attr.grh.flow_label	= cmd->base.dest.flow_label;
 +		attr->ah_attr.grh.sgid_index	= cmd->base.dest.sgid_index;
 +		attr->ah_attr.grh.hop_limit	= cmd->base.dest.hop_limit;
 +		attr->ah_attr.grh.traffic_class	= cmd->base.dest.traffic_class;
 +		attr->ah_attr.ah_flags		= IB_AH_GRH;
  	} else {
 -		rdma_ah_set_ah_flags(&attr->ah_attr, 0);
 +		attr->ah_attr.ah_flags = 0;
  	}
 -	rdma_ah_set_dlid(&attr->ah_attr, cmd->base.dest.dlid);
 -	rdma_ah_set_sl(&attr->ah_attr, cmd->base.dest.sl);
 -	rdma_ah_set_path_bits(&attr->ah_attr, cmd->base.dest.src_path_bits);
 -	rdma_ah_set_static_rate(&attr->ah_attr, cmd->base.dest.static_rate);
 -	rdma_ah_set_port_num(&attr->ah_attr,
 -			     cmd->base.dest.port_num);
 +	attr->ah_attr.dlid		= cmd->base.dest.dlid;
 +	attr->ah_attr.sl		= cmd->base.dest.sl;
 +	attr->ah_attr.src_path_bits	= cmd->base.dest.src_path_bits;
 +	attr->ah_attr.static_rate	= cmd->base.dest.static_rate;
 +	attr->ah_attr.port_num		= cmd->base.dest.port_num;
  
+ 	attr->alt_ah_attr.type = rdma_ah_find_type(qp->device,
+ 						   cmd->base.dest.port_num);
  	if (cmd->base.alt_dest.is_global) {
 -		rdma_ah_set_grh(&attr->alt_ah_attr, NULL,
 -				cmd->base.alt_dest.flow_label,
 -				cmd->base.alt_dest.sgid_index,
 -				cmd->base.alt_dest.hop_limit,
 -				cmd->base.alt_dest.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr->alt_ah_attr,
 -				     cmd->base.alt_dest.dgid);
 +		memcpy(attr->alt_ah_attr.grh.dgid.raw,
 +		       cmd->base.alt_dest.dgid, 16);
 +		attr->alt_ah_attr.grh.flow_label =
 +				cmd->base.alt_dest.flow_label;
 +		attr->alt_ah_attr.grh.sgid_index =
 +				cmd->base.alt_dest.sgid_index;
 +		attr->alt_ah_attr.grh.hop_limit =
 +				cmd->base.alt_dest.hop_limit;
 +		attr->alt_ah_attr.grh.traffic_class =
 +				cmd->base.alt_dest.traffic_class;
 +		attr->alt_ah_attr.ah_flags = IB_AH_GRH;
  	} else {
 -		rdma_ah_set_ah_flags(&attr->alt_ah_attr, 0);
 +		attr->alt_ah_attr.ah_flags = 0;
  	}
 -
 -	rdma_ah_set_dlid(&attr->alt_ah_attr, cmd->base.alt_dest.dlid);
 -	rdma_ah_set_sl(&attr->alt_ah_attr, cmd->base.alt_dest.sl);
 -	rdma_ah_set_path_bits(&attr->alt_ah_attr,
 -			      cmd->base.alt_dest.src_path_bits);
 -	rdma_ah_set_static_rate(&attr->alt_ah_attr,
 -				cmd->base.alt_dest.static_rate);
 -	rdma_ah_set_port_num(&attr->alt_ah_attr,
 -			     cmd->base.alt_dest.port_num);
 +	attr->alt_ah_attr.dlid		    = cmd->base.alt_dest.dlid;
 +	attr->alt_ah_attr.sl		    = cmd->base.alt_dest.sl;
 +	attr->alt_ah_attr.src_path_bits	    = cmd->base.alt_dest.src_path_bits;
 +	attr->alt_ah_attr.static_rate	    = cmd->base.alt_dest.static_rate;
 +	attr->alt_ah_attr.port_num	    = cmd->base.alt_dest.port_num;
  
  	if (qp->real_qp == qp) {
  		if (cmd->base.attr_mask & IB_QP_AV) {
@@@ -2973,22 -2555,25 +2977,32 @@@ ssize_t ib_uverbs_create_ah(struct ib_u
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	attr.dlid 	       = cmd.attr.dlid;
 +	attr.sl 	       = cmd.attr.sl;
 +	attr.src_path_bits     = cmd.attr.src_path_bits;
 +	attr.static_rate       = cmd.attr.static_rate;
 +	attr.port_num 	       = cmd.attr.port_num;
 +	memset(&attr.dmac, 0, sizeof(attr.dmac));
++=======
+ 	attr.type = rdma_ah_find_type(ib_dev, cmd.attr.port_num);
+ 	rdma_ah_set_dlid(&attr, cmd.attr.dlid);
+ 	rdma_ah_set_sl(&attr, cmd.attr.sl);
+ 	rdma_ah_set_path_bits(&attr, cmd.attr.src_path_bits);
+ 	rdma_ah_set_static_rate(&attr, cmd.attr.static_rate);
+ 	rdma_ah_set_port_num(&attr, cmd.attr.port_num);
+ 
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	if (cmd.attr.is_global) {
 -		rdma_ah_set_grh(&attr, NULL, cmd.attr.grh.flow_label,
 -				cmd.attr.grh.sgid_index,
 -				cmd.attr.grh.hop_limit,
 -				cmd.attr.grh.traffic_class);
 -		rdma_ah_set_dgid_raw(&attr, cmd.attr.grh.dgid);
 +		attr.ah_flags          = IB_AH_GRH;
 +		attr.grh.flow_label    = cmd.attr.grh.flow_label;
 +		attr.grh.sgid_index    = cmd.attr.grh.sgid_index;
 +		attr.grh.hop_limit     = cmd.attr.grh.hop_limit;
 +		attr.grh.traffic_class = cmd.attr.grh.traffic_class;
 +		memcpy(attr.grh.dgid.raw, cmd.attr.grh.dgid, 16);
  	} else {
 -		rdma_ah_set_ah_flags(&attr, 0);
 +		attr.ah_flags = 0;
  	}
 -	dmac = rdma_ah_retrieve_dmac(&attr);
 -	if (dmac)
 -		memset(dmac, 0, ETH_ALEN);
  
  	ah = pd->device->create_ah(pd, &attr, &udata);
  
diff --cc drivers/infiniband/core/verbs.c
index 207e5c2457cc,4792f5209ac2..000000000000
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@@ -571,8 -571,11 +573,11 @@@ struct ib_ah *ib_create_ah_from_wc(stru
  }
  EXPORT_SYMBOL(ib_create_ah_from_wc);
  
 -int rdma_modify_ah(struct ib_ah *ah, struct rdma_ah_attr *ah_attr)
 +int ib_modify_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr)
  {
+ 	if (ah->type != ah_attr->type)
+ 		return -EINVAL;
+ 
  	return ah->device->modify_ah ?
  		ah->device->modify_ah(ah, ah_attr) :
  		-ENOSYS;
@@@ -1201,19 -1204,22 +1206,30 @@@ int ib_modify_qp_is_ok(enum ib_qp_stat
  EXPORT_SYMBOL(ib_modify_qp_is_ok);
  
  int ib_resolve_eth_dmac(struct ib_device *device,
 -			struct rdma_ah_attr *ah_attr)
 +			struct ib_ah_attr *ah_attr)
  {
  	int           ret = 0;
 -	struct ib_global_route *grh;
  
 -	if (!rdma_is_port_valid(device, rdma_ah_get_port_num(ah_attr)))
 +	if (!rdma_is_port_valid(device, ah_attr->port_num))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!rdma_cap_eth_ah(device, ah_attr->port_num))
 +		return 0;
 +
 +	if (rdma_link_local_addr((struct in6_addr *)ah_attr->grh.dgid.raw)) {
 +		rdma_get_ll_mac((struct in6_addr *)ah_attr->grh.dgid.raw,
 +				ah_attr->dmac);
++=======
+ 	if (ah_attr->type != RDMA_AH_ATTR_TYPE_ROCE)
+ 		return 0;
+ 
+ 	grh = rdma_ah_retrieve_grh(ah_attr);
+ 
+ 	if (rdma_link_local_addr((struct in6_addr *)grh->dgid.raw)) {
+ 		rdma_get_ll_mac((struct in6_addr *)grh->dgid.raw,
+ 				ah_attr->roce.dmac);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	} else {
  		union ib_gid		sgid;
  		struct ib_gid_attr	sgid_attr;
@@@ -1233,10 -1239,10 +1249,17 @@@
  
  		ifindex = sgid_attr.ndev->ifindex;
  
++<<<<<<< HEAD
 +		ret = rdma_addr_find_l2_eth_by_grh(&sgid,
 +						   &ah_attr->grh.dgid,
 +						   ah_attr->dmac,
 +						   NULL, &ifindex, &hop_limit);
++=======
+ 		ret =
+ 		rdma_addr_find_l2_eth_by_grh(&sgid, &grh->dgid,
+ 					     ah_attr->roce.dmac,
+ 					     NULL, &ifindex, &hop_limit);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
  		dev_put(sgid_attr.ndev);
  
diff --cc drivers/infiniband/hw/bnxt_re/ib_verbs.c
index 33af2e3de399,7ba9e699d7ab..000000000000
--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.c
+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.c
@@@ -595,8 -596,8 +595,13 @@@ struct ib_ah *bnxt_re_create_ah(struct 
  			ah->qplib_ah.nw_type = CMDQ_CREATE_AH_TYPE_V1;
  			break;
  		}
++<<<<<<< HEAD
 +		rc = rdma_addr_find_l2_eth_by_grh(&sgid, &ah_attr->grh.dgid,
 +						  ah_attr->dmac, &vlan_tag,
++=======
+ 		rc = rdma_addr_find_l2_eth_by_grh(&sgid, &grh->dgid,
+ 						  ah_attr->roce.dmac, &vlan_tag,
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  						  &sgid_attr.ndev->ifindex,
  						  NULL);
  		if (rc) {
@@@ -643,15 -644,15 +648,27 @@@ int bnxt_re_query_ah(struct ib_ah *ib_a
  {
  	struct bnxt_re_ah *ah = container_of(ib_ah, struct bnxt_re_ah, ib_ah);
  
++<<<<<<< HEAD
 +	memcpy(ah_attr->grh.dgid.raw, ah->qplib_ah.dgid.data,
 +	       sizeof(union ib_gid));
 +	ah_attr->grh.sgid_index = ah->qplib_ah.host_sgid_index;
 +	ah_attr->grh.traffic_class = ah->qplib_ah.traffic_class;
 +	ah_attr->sl = ah->qplib_ah.sl;
 +	memcpy(ah_attr->dmac, ah->qplib_ah.dmac, ETH_ALEN);
 +	ah_attr->ah_flags = IB_AH_GRH;
 +	ah_attr->port_num = 1;
 +	ah_attr->static_rate = 0;
++=======
+ 	ah_attr->type = ib_ah->type;
+ 	rdma_ah_set_sl(ah_attr, ah->qplib_ah.sl);
+ 	memcpy(ah_attr->roce.dmac, ah->qplib_ah.dmac, ETH_ALEN);
+ 	rdma_ah_set_grh(ah_attr, NULL, 0,
+ 			ah->qplib_ah.host_sgid_index,
+ 			0, ah->qplib_ah.traffic_class);
+ 	rdma_ah_set_dgid_raw(ah_attr, ah->qplib_ah.dgid.data);
+ 	rdma_ah_set_port_num(ah_attr, 1);
+ 	rdma_ah_set_static_rate(ah_attr, 0);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	return 0;
  }
  
@@@ -1272,18 -1276,16 +1289,28 @@@ int bnxt_re_modify_qp(struct ib_qp *ib_
  		 * each GID entry. Avoiding this duplicte entry in HW. Dividing
  		 * the GID index by 2 for RoCE V2
  		 */
++<<<<<<< HEAD
 +		qp->qplib_qp.ah.sgid_index =
 +					qp_attr->ah_attr.grh.sgid_index / 2;
 +		qp->qplib_qp.ah.host_sgid_index =
 +					qp_attr->ah_attr.grh.sgid_index;
 +		qp->qplib_qp.ah.hop_limit = qp_attr->ah_attr.grh.hop_limit;
 +		qp->qplib_qp.ah.traffic_class =
 +					qp_attr->ah_attr.grh.traffic_class;
 +		qp->qplib_qp.ah.sl = qp_attr->ah_attr.sl;
 +		ether_addr_copy(qp->qplib_qp.ah.dmac, qp_attr->ah_attr.dmac);
++=======
+ 		qp->qplib_qp.ah.sgid_index = grh->sgid_index / 2;
+ 		qp->qplib_qp.ah.host_sgid_index = grh->sgid_index;
+ 		qp->qplib_qp.ah.hop_limit = grh->hop_limit;
+ 		qp->qplib_qp.ah.traffic_class = grh->traffic_class;
+ 		qp->qplib_qp.ah.sl = rdma_ah_get_sl(&qp_attr->ah_attr);
+ 		ether_addr_copy(qp->qplib_qp.ah.dmac,
+ 				qp_attr->ah_attr.roce.dmac);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
  		status = ib_get_cached_gid(&rdev->ibdev, 1,
 -					   grh->sgid_index,
 +					   qp_attr->ah_attr.grh.sgid_index,
  					   &sgid, &sgid_attr);
  		if (!status && sgid_attr.ndev) {
  			memcpy(qp->qplib_qp.smac, sgid_attr.ndev->dev_addr,
@@@ -1423,14 -1425,14 +1450,25 @@@ int bnxt_re_query_qp(struct ib_qp *ib_q
  	qp_attr->qp_access_flags = __to_ib_access_flags(qplib_qp.access);
  	qp_attr->pkey_index = qplib_qp.pkey_index;
  	qp_attr->qkey = qplib_qp.qkey;
++<<<<<<< HEAD
 +	memcpy(qp_attr->ah_attr.grh.dgid.raw, qplib_qp.ah.dgid.data,
 +	       sizeof(qplib_qp.ah.dgid.data));
 +	qp_attr->ah_attr.grh.flow_label = qplib_qp.ah.flow_label;
 +	qp_attr->ah_attr.grh.sgid_index = qplib_qp.ah.host_sgid_index;
 +	qp_attr->ah_attr.grh.hop_limit = qplib_qp.ah.hop_limit;
 +	qp_attr->ah_attr.grh.traffic_class = qplib_qp.ah.traffic_class;
 +	qp_attr->ah_attr.sl = qplib_qp.ah.sl;
 +	ether_addr_copy(qp_attr->ah_attr.dmac, qplib_qp.ah.dmac);
++=======
+ 	qp_attr->ah_attr.type = RDMA_AH_ATTR_TYPE_ROCE;
+ 	rdma_ah_set_grh(&qp_attr->ah_attr, NULL, qplib_qp.ah.flow_label,
+ 			qplib_qp.ah.host_sgid_index,
+ 			qplib_qp.ah.hop_limit,
+ 			qplib_qp.ah.traffic_class);
+ 	rdma_ah_set_dgid_raw(&qp_attr->ah_attr, qplib_qp.ah.dgid.data);
+ 	rdma_ah_set_sl(&qp_attr->ah_attr, qplib_qp.ah.sl);
+ 	ether_addr_copy(qp_attr->ah_attr.roce.dmac, qplib_qp.ah.dmac);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	qp_attr->path_mtu = __to_ib_mtu(qplib_qp.path_mtu);
  	qp_attr->timeout = qplib_qp.timeout;
  	qp_attr->retry_cnt = qplib_qp.retry_cnt;
diff --cc drivers/infiniband/hw/hfi1/verbs.c
index 1cf5f1c1aa2f,90e7b77d68e8..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@@ -1507,13 -1508,17 +1507,22 @@@ static void hfi1_notify_new_ah(struct i
  
  struct ib_ah *hfi1_create_qp0_ah(struct hfi1_ibport *ibp, u16 dlid)
  {
 -	struct rdma_ah_attr attr;
 +	struct ib_ah_attr attr;
  	struct ib_ah *ah = ERR_PTR(-EINVAL);
  	struct rvt_qp *qp0;
+ 	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
+ 	struct hfi1_devdata *dd = dd_from_ppd(ppd);
+ 	u8 port_num = ppd->port;
  
  	memset(&attr, 0, sizeof(attr));
++<<<<<<< HEAD
 +	attr.dlid = dlid;
 +	attr.port_num = ppd_from_ibp(ibp)->port;
++=======
+ 	attr.type = rdma_ah_find_type(&dd->verbs_dev.rdi.ibdev, port_num);
+ 	rdma_ah_set_dlid(&attr, dlid);
+ 	rdma_ah_set_port_num(&attr, ppd_from_ibp(ibp)->port);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	rcu_read_lock();
  	qp0 = rcu_dereference(ibp->rvp.qp[0]);
  	if (qp0)
diff --cc drivers/infiniband/hw/mlx4/ah.c
index 077c33d2dc75,538c46a73248..000000000000
--- a/drivers/infiniband/hw/mlx4/ah.c
+++ b/drivers/infiniband/hw/mlx4/ah.c
@@@ -86,10 -96,10 +86,10 @@@ static struct ib_ah *create_iboe_ah(str
  		is_mcast = 1;
  		rdma_get_mcast_mac(&in6, ah->av.eth.mac);
  	} else {
- 		memcpy(ah->av.eth.mac, ah_attr->dmac, ETH_ALEN);
+ 		memcpy(ah->av.eth.mac, ah_attr->roce.dmac, ETH_ALEN);
  	}
 -	ret = ib_get_cached_gid(pd->device, rdma_ah_get_port_num(ah_attr),
 -				grh->sgid_index, &sgid, &gid_attr);
 +	ret = ib_get_cached_gid(pd->device, ah_attr->port_num,
 +				ah_attr->grh.sgid_index, &sgid, &gid_attr);
  	if (ret)
  		return ERR_PTR(ret);
  	eth_zero_addr(ah->av.eth.s_mac);
@@@ -140,8 -154,8 +140,13 @@@ struct ib_ah *mlx4_ib_create_ah(struct 
  	if (!ah)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	if (rdma_port_get_link_layer(pd->device, ah_attr->port_num) == IB_LINK_LAYER_ETHERNET) {
 +		if (!(ah_attr->ah_flags & IB_AH_GRH)) {
++=======
+ 	if (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {
+ 		if (!(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH)) {
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  			ret = ERR_PTR(-EINVAL);
  		} else {
  			/*
@@@ -163,34 -177,40 +168,57 @@@
  		return create_ib_ah(pd, ah_attr, ah); /* never fails */
  }
  
 -int mlx4_ib_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr)
 +int mlx4_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)
  {
  	struct mlx4_ib_ah *ah = to_mah(ibah);
- 	enum rdma_link_layer ll;
+ 	int port_num = be32_to_cpu(ah->av.ib.port_pd) >> 24;
  
  	memset(ah_attr, 0, sizeof *ah_attr);
++<<<<<<< HEAD
 +	ah_attr->port_num = be32_to_cpu(ah->av.ib.port_pd) >> 24;
 +	ll = rdma_port_get_link_layer(ibah->device, ah_attr->port_num);
 +	if (ll == IB_LINK_LAYER_ETHERNET)
 +		ah_attr->sl = be32_to_cpu(ah->av.eth.sl_tclass_flowlabel) >> 29;
 +	else
 +		ah_attr->sl = be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;
 +
 +	ah_attr->dlid = ll == IB_LINK_LAYER_INFINIBAND ? be16_to_cpu(ah->av.ib.dlid) : 0;
 +	if (ah->av.ib.stat_rate)
 +		ah_attr->static_rate = ah->av.ib.stat_rate - MLX4_STAT_RATE_OFFSET;
 +	ah_attr->src_path_bits = ah->av.ib.g_slid & 0x7F;
 +
++=======
+ 	ah_attr->type = ibah->type;
+ 
+ 	if (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {
+ 		rdma_ah_set_dlid(ah_attr, 0);
+ 		rdma_ah_set_sl(ah_attr,
+ 			       be32_to_cpu(ah->av.eth.sl_tclass_flowlabel)
+ 			       >> 29);
+ 	} else {
+ 		rdma_ah_set_dlid(ah_attr, be16_to_cpu(ah->av.ib.dlid));
+ 		rdma_ah_set_sl(ah_attr,
+ 			       be32_to_cpu(ah->av.ib.sl_tclass_flowlabel)
+ 			       >> 28);
+ 	}
+ 
+ 	rdma_ah_set_port_num(ah_attr, port_num);
+ 	if (ah->av.ib.stat_rate)
+ 		rdma_ah_set_static_rate(ah_attr,
+ 					ah->av.ib.stat_rate -
+ 					MLX4_STAT_RATE_OFFSET);
+ 	rdma_ah_set_path_bits(ah_attr, ah->av.ib.g_slid & 0x7F);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	if (mlx4_ib_ah_grh_present(ah)) {
 -		u32 tc_fl = be32_to_cpu(ah->av.ib.sl_tclass_flowlabel);
 -
 -		rdma_ah_set_grh(ah_attr, NULL,
 -				tc_fl & 0xfffff, ah->av.ib.gid_index,
 -				ah->av.ib.hop_limit,
 -				tc_fl >> 20);
 -		rdma_ah_set_dgid_raw(ah_attr, ah->av.ib.dgid);
 +		ah_attr->ah_flags = IB_AH_GRH;
 +
 +		ah_attr->grh.traffic_class =
 +			be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 20;
 +		ah_attr->grh.flow_label =
 +			be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) & 0xfffff;
 +		ah_attr->grh.hop_limit  = ah->av.ib.hop_limit;
 +		ah_attr->grh.sgid_index = ah->av.ib.gid_index;
 +		memcpy(ah_attr->grh.dgid.raw, ah->av.ib.dgid, 16);
  	}
  
  	return 0;
diff --cc drivers/infiniband/hw/mlx4/mad.c
index db564ccc0f92,b4694717f6f3..000000000000
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@@ -196,12 -196,13 +196,19 @@@ static void update_sm_ah(struct mlx4_ib
  		return;
  
  	memset(&ah_attr, 0, sizeof ah_attr);
++<<<<<<< HEAD
 +	ah_attr.dlid     = lid;
 +	ah_attr.sl       = sl;
 +	ah_attr.port_num = port_num;
++=======
+ 	ah_attr.type = rdma_ah_find_type(&dev->ib_dev, port_num);
+ 	rdma_ah_set_dlid(&ah_attr, lid);
+ 	rdma_ah_set_sl(&ah_attr, sl);
+ 	rdma_ah_set_port_num(&ah_attr, port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
 -	new_ah = rdma_create_ah(dev->send_agent[port_num - 1][0]->qp->pd,
 -				&ah_attr);
 +	new_ah = ib_create_ah(dev->send_agent[port_num - 1][0]->qp->pd,
 +			      &ah_attr);
  	if (IS_ERR(new_ah))
  		return;
  
@@@ -555,15 -556,18 +562,21 @@@ int mlx4_ib_send_to_slave(struct mlx4_i
  	/* create ah. Just need an empty one with the port num for the post send.
  	 * The driver will set the force loopback bit in post_send */
  	memset(&attr, 0, sizeof attr);
++<<<<<<< HEAD
 +	attr.port_num = port;
++=======
+ 	attr.type = rdma_ah_find_type(&dev->ib_dev, port);
+ 
+ 	rdma_ah_set_port_num(&attr, port);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	if (is_eth) {
  		union ib_gid sgid;
 -		union ib_gid dgid;
  
 -		if (get_gids_from_l3_hdr(grh, &sgid, &dgid))
 +		if (get_gids_from_l3_hdr(grh, &sgid, &attr.grh.dgid))
  			return -EINVAL;
 -		rdma_ah_set_grh(&attr, &dgid, 0, 0, 0, 0);
 +		attr.ah_flags = IB_AH_GRH;
  	}
 -	ah = rdma_create_ah(tun_ctx->pd, &attr);
 +	ah = ib_create_ah(tun_ctx->pd, &attr);
  	if (IS_ERR(ah))
  		return -ENOMEM;
  
diff --cc drivers/infiniband/hw/mlx4/qp.c
index c34eebc7db65,996e9058e515..000000000000
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@@ -1417,15 -1417,15 +1415,20 @@@ static int _mlx4_set_path(struct mlx4_i
  
  		path->grh_mylmc |= 1 << 7;
  		path->mgid_index = real_sgid_index;
 -		path->hop_limit  = grh->hop_limit;
 +		path->hop_limit  = ah->grh.hop_limit;
  		path->tclass_flowlabel =
 -			cpu_to_be32((grh->traffic_class << 20) |
 -				    (grh->flow_label));
 -		memcpy(path->rgid, grh->dgid.raw, 16);
 +			cpu_to_be32((ah->grh.traffic_class << 20) |
 +				    (ah->grh.flow_label));
 +		memcpy(path->rgid, ah->grh.dgid.raw, 16);
  	}
  
++<<<<<<< HEAD
 +	if (is_eth) {
 +		if (!(ah->ah_flags & IB_AH_GRH))
++=======
+ 	if (ah->type == RDMA_AH_ATTR_TYPE_ROCE) {
+ 		if (!(rdma_ah_get_ah_flags(ah) & IB_AH_GRH))
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  			return -1;
  
  		path->sched_queue = MLX4_IB_DEFAULT_SCHED_QUEUE |
@@@ -1488,8 -1488,7 +1491,12 @@@
  		} else {
  			smac_index = smac_info->smac_index;
  		}
++<<<<<<< HEAD
 +
 +		memcpy(path->dmac, ah->dmac, 6);
++=======
+ 		memcpy(path->dmac, ah->roce.dmac, 6);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  		path->ackto = MLX4_IB_LINK_TYPE_ETH;
  		/* put MAC table smac index for IBoE */
  		path->grh_mylmc = (u8) (smac_index) | 0x80;
@@@ -3394,39 -3395,37 +3401,55 @@@ static int to_ib_qp_access_flags(int ml
  	return ib_flags;
  }
  
 -static void to_rdma_ah_attr(struct mlx4_ib_dev *ibdev,
 -			    struct rdma_ah_attr *ah_attr,
 -			    struct mlx4_qp_path *path)
 +static void to_ib_ah_attr(struct mlx4_ib_dev *ibdev, struct ib_ah_attr *ib_ah_attr,
 +				struct mlx4_qp_path *path)
  {
  	struct mlx4_dev *dev = ibdev->dev;
++<<<<<<< HEAD
 +	int is_eth;
 +
 +	memset(ib_ah_attr, 0, sizeof *ib_ah_attr);
 +	ib_ah_attr->port_num	  = path->sched_queue & 0x40 ? 2 : 1;
 +
 +	if (ib_ah_attr->port_num == 0 || ib_ah_attr->port_num > dev->caps.num_ports)
 +		return;
 +
 +	is_eth = rdma_port_get_link_layer(&ibdev->ib_dev, ib_ah_attr->port_num) ==
 +		IB_LINK_LAYER_ETHERNET;
 +	if (is_eth)
 +		ib_ah_attr->sl = ((path->sched_queue >> 3) & 0x7) |
 +		((path->sched_queue & 4) << 1);
 +	else
 +		ib_ah_attr->sl = (path->sched_queue >> 2) & 0xf;
++=======
+ 	u8 port_num = path->sched_queue & 0x40 ? 2 : 1;
+ 
+ 	memset(ah_attr, 0, sizeof(*ah_attr));
+ 	ah_attr->type = rdma_ah_find_type(&ibdev->ib_dev, port_num);
+ 	if (port_num == 0 || port_num > dev->caps.num_ports)
+ 		return;
+ 
+ 	if (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE)
+ 		rdma_ah_set_sl(ah_attr, ((path->sched_queue >> 3) & 0x7) |
+ 			       ((path->sched_queue & 4) << 1));
+ 	else
+ 		rdma_ah_set_sl(ah_attr, (path->sched_queue >> 2) & 0xf);
+ 	rdma_ah_set_port_num(ah_attr, port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
 -	rdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));
 -	rdma_ah_set_path_bits(ah_attr, path->grh_mylmc & 0x7f);
 -	rdma_ah_set_static_rate(ah_attr,
 -				path->static_rate ? path->static_rate - 5 : 0);
 -	if (path->grh_mylmc & (1 << 7)) {
 -		rdma_ah_set_grh(ah_attr, NULL,
 -				be32_to_cpu(path->tclass_flowlabel) & 0xfffff,
 -				path->mgid_index,
 -				path->hop_limit,
 -				(be32_to_cpu(path->tclass_flowlabel)
 -				 >> 20) & 0xff);
 -		rdma_ah_set_dgid_raw(ah_attr, path->rgid);
 +	ib_ah_attr->dlid	  = be16_to_cpu(path->rlid);
 +	ib_ah_attr->src_path_bits = path->grh_mylmc & 0x7f;
 +	ib_ah_attr->static_rate   = path->static_rate ? path->static_rate - 5 : 0;
 +	ib_ah_attr->ah_flags      = (path->grh_mylmc & (1 << 7)) ? IB_AH_GRH : 0;
 +	if (ib_ah_attr->ah_flags) {
 +		ib_ah_attr->grh.sgid_index = path->mgid_index;
 +		ib_ah_attr->grh.hop_limit  = path->hop_limit;
 +		ib_ah_attr->grh.traffic_class =
 +			(be32_to_cpu(path->tclass_flowlabel) >> 20) & 0xff;
 +		ib_ah_attr->grh.flow_label =
 +			be32_to_cpu(path->tclass_flowlabel) & 0xfffff;
 +		memcpy(ib_ah_attr->grh.dgid.raw,
 +			path->rgid, sizeof ib_ah_attr->grh.dgid.raw);
  	}
  }
  
diff --cc drivers/infiniband/hw/mlx5/ah.c
index d090e96f6f01,3363e29157f6..000000000000
--- a/drivers/infiniband/hw/mlx5/ah.c
+++ b/drivers/infiniband/hw/mlx5/ah.c
@@@ -34,31 -34,33 +34,36 @@@
  
  static struct ib_ah *create_ib_ah(struct mlx5_ib_dev *dev,
  				  struct mlx5_ib_ah *ah,
++<<<<<<< HEAD
 +				  struct ib_ah_attr *ah_attr,
 +				  enum rdma_link_layer ll)
++=======
+ 				  struct rdma_ah_attr *ah_attr)
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  {
 -	if (rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) {
 -		const struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);
 -
 -		memcpy(ah->av.rgid, &grh->dgid, 16);
 -		ah->av.grh_gid_fl = cpu_to_be32(grh->flow_label |
 +	if (ah_attr->ah_flags & IB_AH_GRH) {
 +		memcpy(ah->av.rgid, &ah_attr->grh.dgid, 16);
 +		ah->av.grh_gid_fl = cpu_to_be32(ah_attr->grh.flow_label |
  						(1 << 30) |
 -						grh->sgid_index << 20);
 -		ah->av.hop_limit = grh->hop_limit;
 -		ah->av.tclass = grh->traffic_class;
 +						ah_attr->grh.sgid_index << 20);
 +		ah->av.hop_limit = ah_attr->grh.hop_limit;
 +		ah->av.tclass = ah_attr->grh.traffic_class;
  	}
  
 -	ah->av.stat_rate_sl = (rdma_ah_get_static_rate(ah_attr) << 4);
 +	ah->av.stat_rate_sl = (ah_attr->static_rate << 4);
  
- 	if (ll == IB_LINK_LAYER_ETHERNET) {
- 		memcpy(ah->av.rmac, ah_attr->dmac, sizeof(ah_attr->dmac));
+ 	if (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {
+ 		memcpy(ah->av.rmac, ah_attr->roce.dmac,
+ 		       sizeof(ah_attr->roce.dmac));
  		ah->av.udp_sport =
 -		mlx5_get_roce_udp_sport(dev,
 -					rdma_ah_get_port_num(ah_attr),
 -					rdma_ah_read_grh(ah_attr)->sgid_index);
 -		ah->av.stat_rate_sl |= (rdma_ah_get_sl(ah_attr) & 0x7) << 1;
 +			mlx5_get_roce_udp_sport(dev,
 +						ah_attr->port_num,
 +						ah_attr->grh.sgid_index);
 +		ah->av.stat_rate_sl |= (ah_attr->sl & 0x7) << 1;
  	} else {
 -		ah->av.rlid = cpu_to_be16(rdma_ah_get_dlid(ah_attr));
 -		ah->av.fl_mlid = rdma_ah_get_path_bits(ah_attr) & 0x7f;
 -		ah->av.stat_rate_sl |= (rdma_ah_get_sl(ah_attr) & 0xf);
 +		ah->av.rlid = cpu_to_be16(ah_attr->dlid);
 +		ah->av.fl_mlid = ah_attr->src_path_bits & 0x7f;
 +		ah->av.stat_rate_sl |= (ah_attr->sl & 0xf);
  	}
  
  	return &ah->ibah;
@@@ -70,14 -72,13 +75,19 @@@ struct ib_ah *mlx5_ib_create_ah(struct 
  {
  	struct mlx5_ib_ah *ah;
  	struct mlx5_ib_dev *dev = to_mdev(pd->device);
- 	enum rdma_link_layer ll;
+ 	enum rdma_ah_attr_type ah_type = ah_attr->type;
  
++<<<<<<< HEAD
 +	ll = pd->device->get_link_layer(pd->device, ah_attr->port_num);
 +
 +	if (ll == IB_LINK_LAYER_ETHERNET && !(ah_attr->ah_flags & IB_AH_GRH))
++=======
+ 	if ((ah_type == RDMA_AH_ATTR_TYPE_ROCE) &&
+ 	    !(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH))
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  		return ERR_PTR(-EINVAL);
  
- 	if (ll == IB_LINK_LAYER_ETHERNET && udata) {
+ 	if (ah_type == RDMA_AH_ATTR_TYPE_ROCE && udata) {
  		int err;
  		struct mlx5_ib_create_ah_resp resp = {};
  		u32 min_resp_len = offsetof(typeof(resp), dmac) +
@@@ -102,10 -103,10 +112,10 @@@
  	if (!ah)
  		return ERR_PTR(-ENOMEM);
  
- 	return create_ib_ah(dev, ah, ah_attr, ll); /* never fails */
+ 	return create_ib_ah(dev, ah, ah_attr); /* never fails */
  }
  
 -int mlx5_ib_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr)
 +int mlx5_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)
  {
  	struct mlx5_ib_ah *ah = to_mah(ibah);
  	u32 tmp;
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 5d46e93692b2,93959e1e43a3..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -2239,9 -2211,11 +2239,13 @@@ static int mlx5_set_path(struct mlx5_ib
  			 u32 path_flags, const struct ib_qp_attr *attr,
  			 bool alt)
  {
++<<<<<<< HEAD
 +	enum rdma_link_layer ll = rdma_port_get_link_layer(&dev->ib_dev, port);
++=======
+ 	const struct ib_global_route *grh = rdma_ah_read_grh(ah);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	int err;
  	enum ib_gid_type gid_type;
 -	u8 ah_flags = rdma_ah_get_ah_flags(ah);
 -	u8 sl = rdma_ah_get_sl(ah);
  
  	if (attr_mask & IB_QP_PKEY_INDEX)
  		path->pkey_index = cpu_to_be16(alt ? attr->alt_pkey_index :
@@@ -2257,19 -2231,19 +2261,24 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (ll == IB_LINK_LAYER_ETHERNET) {
 +		if (!(ah->ah_flags & IB_AH_GRH))
++=======
+ 	if (ah->type == RDMA_AH_ATTR_TYPE_ROCE) {
+ 		if (!(ah_flags & IB_AH_GRH))
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  			return -EINVAL;
 -		err = mlx5_get_roce_gid_type(dev, port, grh->sgid_index,
 +		err = mlx5_get_roce_gid_type(dev, port, ah->grh.sgid_index,
  					     &gid_type);
  		if (err)
  			return err;
- 		memcpy(path->rmac, ah->dmac, sizeof(ah->dmac));
+ 		memcpy(path->rmac, ah->roce.dmac, sizeof(ah->roce.dmac));
  		path->udp_sport = mlx5_get_roce_udp_sport(dev, port,
 -							  grh->sgid_index);
 -		path->dci_cfi_prio_sl = (sl & 0x7) << 4;
 +							  ah->grh.sgid_index);
 +		path->dci_cfi_prio_sl = (ah->sl & 0x7) << 4;
  		if (gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)
 -			path->ecn_dscp = (grh->traffic_class >> 2) & 0x3f;
 +			path->ecn_dscp = (ah->grh.traffic_class >> 2) & 0x3f;
  	} else {
  		path->fl_free_ar = (path_flags & MLX5_PATH_FLAG_FL) ? 0x80 : 0;
  		path->fl_free_ar |=
@@@ -4329,28 -4257,30 +4338,35 @@@ static void to_ib_ah_attr(struct mlx5_i
  {
  	struct mlx5_core_dev *dev = ibdev->mdev;
  
 -	memset(ah_attr, 0, sizeof(*ah_attr));
 +	memset(ib_ah_attr, 0, sizeof(*ib_ah_attr));
 +	ib_ah_attr->port_num	  = path->port;
  
++<<<<<<< HEAD
 +	if (ib_ah_attr->port_num == 0 ||
 +	    ib_ah_attr->port_num > MLX5_CAP_GEN(dev, num_ports))
++=======
+ 	ah_attr->type = rdma_ah_find_type(&ibdev->ib_dev, path->port);
+ 	rdma_ah_set_port_num(ah_attr, path->port);
+ 	if (rdma_ah_get_port_num(ah_attr) == 0 ||
+ 	    rdma_ah_get_port_num(ah_attr) > MLX5_CAP_GEN(dev, num_ports))
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  		return;
  
 -	rdma_ah_set_port_num(ah_attr, path->port);
 -	rdma_ah_set_sl(ah_attr, path->dci_cfi_prio_sl & 0xf);
 -
 -	rdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));
 -	rdma_ah_set_path_bits(ah_attr, path->grh_mlid & 0x7f);
 -	rdma_ah_set_static_rate(ah_attr,
 -				path->static_rate ? path->static_rate - 5 : 0);
 -	if (path->grh_mlid & (1 << 7)) {
 -		u32 tc_fl = be32_to_cpu(path->tclass_flowlabel);
 +	ib_ah_attr->sl = path->dci_cfi_prio_sl & 0xf;
  
 -		rdma_ah_set_grh(ah_attr, NULL,
 -				tc_fl & 0xfffff,
 -				path->mgid_index,
 -				path->hop_limit,
 -				(tc_fl >> 20) & 0xff);
 -		rdma_ah_set_dgid_raw(ah_attr, path->rgid);
 +	ib_ah_attr->dlid	  = be16_to_cpu(path->rlid);
 +	ib_ah_attr->src_path_bits = path->grh_mlid & 0x7f;
 +	ib_ah_attr->static_rate   = path->static_rate ? path->static_rate - 5 : 0;
 +	ib_ah_attr->ah_flags      = (path->grh_mlid & (1 << 7)) ? IB_AH_GRH : 0;
 +	if (ib_ah_attr->ah_flags) {
 +		ib_ah_attr->grh.sgid_index = path->mgid_index;
 +		ib_ah_attr->grh.hop_limit  = path->hop_limit;
 +		ib_ah_attr->grh.traffic_class =
 +			(be32_to_cpu(path->tclass_flowlabel) >> 20) & 0xff;
 +		ib_ah_attr->grh.flow_label =
 +			be32_to_cpu(path->tclass_flowlabel) & 0xfffff;
 +		memcpy(ib_ah_attr->grh.dgid.raw,
 +		       path->rgid, sizeof(ib_ah_attr->grh.dgid.raw));
  	}
  }
  
diff --cc drivers/infiniband/hw/mthca/mthca_av.c
index c9f0f364f484,2aec9908c40a..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_av.c
+++ b/drivers/infiniband/hw/mthca/mthca_av.c
@@@ -297,23 -303,24 +297,36 @@@ int mthca_ah_query(struct ib_ah *ibah, 
  		return -ENOSYS;
  
  	memset(attr, 0, sizeof *attr);
++<<<<<<< HEAD
 +	attr->dlid          = be16_to_cpu(ah->av->dlid);
 +	attr->sl            = be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 28;
 +	attr->port_num      = be32_to_cpu(ah->av->port_pd) >> 24;
 +	attr->static_rate   = mthca_rate_to_ib(dev, ah->av->msg_sr & 0x7,
 +					       attr->port_num);
 +	attr->src_path_bits = ah->av->g_slid & 0x7F;
 +	attr->ah_flags      = mthca_ah_grh_present(ah) ? IB_AH_GRH : 0;
++=======
+ 	attr->type = ibah->type;
+ 	rdma_ah_set_dlid(attr, be16_to_cpu(ah->av->dlid));
+ 	rdma_ah_set_sl(attr, be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 28);
+ 	rdma_ah_set_port_num(attr, port_num);
+ 	rdma_ah_set_static_rate(attr,
+ 				mthca_rate_to_ib(dev, ah->av->msg_sr & 0x7,
+ 						 port_num));
+ 	rdma_ah_set_path_bits(attr, ah->av->g_slid & 0x7F);
+ 	if (mthca_ah_grh_present(ah)) {
+ 		u32 tc_fl = be32_to_cpu(ah->av->sl_tclass_flowlabel);
 -
 -		rdma_ah_set_grh(attr, NULL,
 -				tc_fl & 0xfffff,
 -				ah->av->gid_index &
 -				(dev->limits.gid_table_len - 1),
 -				ah->av->hop_limit,
 -				(tc_fl >> 20) & 0xff);
 -		rdma_ah_set_dgid_raw(attr, ah->av->dgid);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
 +
 +	if (attr->ah_flags) {
 +		attr->grh.traffic_class =
 +			be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 20;
 +		attr->grh.flow_label =
 +			be32_to_cpu(ah->av->sl_tclass_flowlabel) & 0xfffff;
 +		attr->grh.hop_limit  = ah->av->hop_limit;
 +		attr->grh.sgid_index = ah->av->gid_index &
 +				       (dev->limits.gid_table_len - 1);
 +		memcpy(attr->grh.dgid.raw, ah->av->dgid, 16);
  	}
  
  	return 0;
diff --cc drivers/infiniband/hw/mthca/mthca_mad.c
index 9139405c4810,7df3db71777a..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_mad.c
+++ b/drivers/infiniband/hw/mthca/mthca_mad.c
@@@ -82,12 -82,13 +82,19 @@@ static void update_sm_ah(struct mthca_d
  		return;
  
  	memset(&ah_attr, 0, sizeof ah_attr);
++<<<<<<< HEAD
 +	ah_attr.dlid     = lid;
 +	ah_attr.sl       = sl;
 +	ah_attr.port_num = port_num;
++=======
+ 	ah_attr.type = rdma_ah_find_type(&dev->ib_dev, port_num);
+ 	rdma_ah_set_dlid(&ah_attr, lid);
+ 	rdma_ah_set_sl(&ah_attr, sl);
+ 	rdma_ah_set_port_num(&ah_attr, port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
 -	new_ah = rdma_create_ah(dev->send_agent[port_num - 1][0]->qp->pd,
 -				&ah_attr);
 +	new_ah = ib_create_ah(dev->send_agent[port_num - 1][0]->qp->pd,
 +			      &ah_attr);
  	if (IS_ERR(new_ah))
  		return;
  
diff --cc drivers/infiniband/hw/mthca/mthca_qp.c
index 96e5fb91fb48,d21960cd9a49..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_qp.c
+++ b/drivers/infiniband/hw/mthca/mthca_qp.c
@@@ -393,31 -393,36 +393,36 @@@ static int to_ib_qp_access_flags(int mt
  	return ib_flags;
  }
  
 -static void to_rdma_ah_attr(struct mthca_dev *dev,
 -			    struct rdma_ah_attr *ah_attr,
 -			    struct mthca_qp_path *path)
 +static void to_ib_ah_attr(struct mthca_dev *dev, struct ib_ah_attr *ib_ah_attr,
 +				struct mthca_qp_path *path)
  {
 -	u8 port_num = (be32_to_cpu(path->port_pkey) >> 24) & 0x3;
 +	memset(ib_ah_attr, 0, sizeof *ib_ah_attr);
 +	ib_ah_attr->port_num 	  = (be32_to_cpu(path->port_pkey) >> 24) & 0x3;
  
 -	memset(ah_attr, 0, sizeof(*ah_attr));
 -
 -	if (port_num == 0 || port_num > dev->limits.num_ports)
 +	if (ib_ah_attr->port_num == 0 || ib_ah_attr->port_num > dev->limits.num_ports)
  		return;
++<<<<<<< HEAD
++=======
+ 	ah_attr->type = rdma_ah_find_type(&dev->ib_dev, port_num);
+ 	rdma_ah_set_port_num(ah_attr, port_num);
 -
 -	rdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));
 -	rdma_ah_set_sl(ah_attr, be32_to_cpu(path->sl_tclass_flowlabel) >> 28);
 -	rdma_ah_set_path_bits(ah_attr, path->g_mylmc & 0x7f);
 -	rdma_ah_set_static_rate(ah_attr,
 -				mthca_rate_to_ib(dev,
 -						 path->static_rate & 0xf,
 -						 port_num));
 -	if (path->g_mylmc & (1 << 7)) {
 -		u32 tc_fl = be32_to_cpu(path->sl_tclass_flowlabel);
 -
 -		rdma_ah_set_grh(ah_attr, NULL,
 -				tc_fl & 0xfffff,
 -				path->mgid_index &
 -				(dev->limits.gid_table_len - 1),
 -				path->hop_limit,
 -				(tc_fl >> 20) & 0xff);
 -		rdma_ah_set_dgid_raw(ah_attr, path->rgid);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
 +
 +	ib_ah_attr->dlid     	  = be16_to_cpu(path->rlid);
 +	ib_ah_attr->sl       	  = be32_to_cpu(path->sl_tclass_flowlabel) >> 28;
 +	ib_ah_attr->src_path_bits = path->g_mylmc & 0x7f;
 +	ib_ah_attr->static_rate   = mthca_rate_to_ib(dev,
 +						     path->static_rate & 0xf,
 +						     ib_ah_attr->port_num);
 +	ib_ah_attr->ah_flags      = (path->g_mylmc & (1 << 7)) ? IB_AH_GRH : 0;
 +	if (ib_ah_attr->ah_flags) {
 +		ib_ah_attr->grh.sgid_index = path->mgid_index & (dev->limits.gid_table_len - 1);
 +		ib_ah_attr->grh.hop_limit  = path->hop_limit;
 +		ib_ah_attr->grh.traffic_class =
 +			(be32_to_cpu(path->sl_tclass_flowlabel) >> 20) & 0xff;
 +		ib_ah_attr->grh.flow_label =
 +			be32_to_cpu(path->sl_tclass_flowlabel) & 0xfffff;
 +		memcpy(ib_ah_attr->grh.dgid.raw,
 +			path->rgid, sizeof ib_ah_attr->grh.dgid.raw);
  	}
  }
  
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_ah.c
index 63e73d6e67f0,d0249e463338..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_ah.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_ah.c
@@@ -165,11 -167,14 +165,16 @@@ struct ib_ah *ocrdma_create_ah(struct i
  	struct ib_gid_attr sgid_attr;
  	struct ocrdma_pd *pd = get_ocrdma_pd(ibpd);
  	struct ocrdma_dev *dev = get_ocrdma_dev(ibpd->device);
 -	const struct ib_global_route *grh;
  	union ib_gid sgid;
  
++<<<<<<< HEAD
 +	if (!(attr->ah_flags & IB_AH_GRH))
++=======
+ 	if ((attr->type != RDMA_AH_ATTR_TYPE_ROCE) ||
+ 	    !(rdma_ah_get_ah_flags(attr) & IB_AH_GRH))
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  		return ERR_PTR(-EINVAL);
  
 -	grh = rdma_ah_read_grh(attr);
  	if (atomic_cmpxchg(&dev->update_sl, 1, 0))
  		ocrdma_init_service_level(dev);
  
@@@ -197,10 -202,11 +202,18 @@@
  	ah->hdr_type = ib_gid_to_network_type(sgid_attr.gid_type, &sgid);
  
  	if ((pd->uctx) &&
++<<<<<<< HEAD
 +	    (!rdma_is_multicast_addr((struct in6_addr *)attr->grh.dgid.raw)) &&
 +	    (!rdma_link_local_addr((struct in6_addr *)attr->grh.dgid.raw))) {
 +		status = rdma_addr_find_l2_eth_by_grh(&sgid, &attr->grh.dgid,
 +						      attr->dmac, &vlan_tag,
++=======
+ 	    (!rdma_is_multicast_addr((struct in6_addr *)grh->dgid.raw)) &&
+ 	    (!rdma_link_local_addr((struct in6_addr *)grh->dgid.raw))) {
+ 		status = rdma_addr_find_l2_eth_by_grh(&sgid, &grh->dgid,
+ 						      attr->roce.dmac,
+ 						      &vlan_tag,
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  						      &sgid_attr.ndev->ifindex,
  						      NULL);
  		if (status) {
@@@ -253,7 -259,8 +266,12 @@@ int ocrdma_query_ah(struct ib_ah *ibah
  	struct ocrdma_ah *ah = get_ocrdma_ah(ibah);
  	struct ocrdma_av *av = ah->av;
  	struct ocrdma_grh *grh;
++<<<<<<< HEAD
 +	attr->ah_flags |= IB_AH_GRH;
++=======
+ 
+ 	attr->type = ibah->type;
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	if (ah->av->valid & OCRDMA_AV_VALID) {
  		grh = (struct ocrdma_grh *)((u8 *)ah->av +
  				sizeof(struct ocrdma_eth_vlan));
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index 5323e7c2184c,2f30bda8457a..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@@ -1600,23 -1598,24 +1600,27 @@@ int ocrdma_query_qp(struct ib_qp *ibqp
  	qp_attr->cap.max_recv_sge = qp->rq.max_sges;
  	qp_attr->cap.max_inline_data = qp->max_inline_data;
  	qp_init_attr->cap = qp_attr->cap;
++<<<<<<< HEAD
 +	memcpy(&qp_attr->ah_attr.grh.dgid, &params.dgid[0],
 +	       sizeof(params.dgid));
 +	qp_attr->ah_attr.grh.flow_label = params.rnt_rc_sl_fl &
 +	    OCRDMA_QP_PARAMS_FLOW_LABEL_MASK;
 +	qp_attr->ah_attr.grh.sgid_index = qp->sgid_idx;
 +	qp_attr->ah_attr.grh.hop_limit = (params.hop_lmt_rq_psn &
 +					  OCRDMA_QP_PARAMS_HOP_LMT_MASK) >>
 +						OCRDMA_QP_PARAMS_HOP_LMT_SHIFT;
 +	qp_attr->ah_attr.grh.traffic_class = (params.tclass_sq_psn &
 +					      OCRDMA_QP_PARAMS_TCLASS_MASK) >>
 +						OCRDMA_QP_PARAMS_TCLASS_SHIFT;
++=======
+ 	qp_attr->ah_attr.type = RDMA_AH_ATTR_TYPE_ROCE;
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  
 -	rdma_ah_set_grh(&qp_attr->ah_attr, NULL,
 -			params.rnt_rc_sl_fl &
 -			  OCRDMA_QP_PARAMS_FLOW_LABEL_MASK,
 -			qp->sgid_idx,
 -			(params.hop_lmt_rq_psn &
 -			 OCRDMA_QP_PARAMS_HOP_LMT_MASK) >>
 -			 OCRDMA_QP_PARAMS_HOP_LMT_SHIFT,
 -			(params.tclass_sq_psn &
 -			 OCRDMA_QP_PARAMS_TCLASS_MASK) >>
 -			 OCRDMA_QP_PARAMS_TCLASS_SHIFT);
 -	rdma_ah_set_dgid_raw(&qp_attr->ah_attr, &params.dgid[0]);
 -
 -	rdma_ah_set_port_num(&qp_attr->ah_attr, 1);
 -	rdma_ah_set_sl(&qp_attr->ah_attr, (params.rnt_rc_sl_fl &
 -					   OCRDMA_QP_PARAMS_SL_MASK) >>
 -					   OCRDMA_QP_PARAMS_SL_SHIFT);
 +	qp_attr->ah_attr.ah_flags = IB_AH_GRH;
 +	qp_attr->ah_attr.port_num = 1;
 +	qp_attr->ah_attr.sl = (params.rnt_rc_sl_fl &
 +			       OCRDMA_QP_PARAMS_SL_MASK) >>
 +				OCRDMA_QP_PARAMS_SL_SHIFT;
  	qp_attr->timeout = (params.ack_to_rnr_rtc_dest_qpn &
  			    OCRDMA_QP_PARAMS_ACK_TIMEOUT_MASK) >>
  				OCRDMA_QP_PARAMS_ACK_TIMEOUT_SHIFT;
diff --cc drivers/infiniband/hw/qedr/verbs.c
index 7349c6d43581,17685cfea6a2..000000000000
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@@ -2026,17 -2029,13 +2026,27 @@@ int qedr_query_qp(struct ib_qp *ibqp
  	qp_attr->cap.max_inline_data = ROCE_REQ_MAX_INLINE_DATA_SIZE;
  	qp_init_attr->cap = qp_attr->cap;
  
++<<<<<<< HEAD
 +	memcpy(&qp_attr->ah_attr.grh.dgid.raw[0], &params.dgid.bytes[0],
 +	       sizeof(qp_attr->ah_attr.grh.dgid.raw));
 +
 +	qp_attr->ah_attr.grh.flow_label = params.flow_label;
 +	qp_attr->ah_attr.grh.sgid_index = qp->sgid_idx;
 +	qp_attr->ah_attr.grh.hop_limit = params.hop_limit_ttl;
 +	qp_attr->ah_attr.grh.traffic_class = params.traffic_class_tos;
 +
 +	qp_attr->ah_attr.ah_flags = IB_AH_GRH;
 +	qp_attr->ah_attr.port_num = 1;
 +	qp_attr->ah_attr.sl = 0;
++=======
+ 	qp_attr->ah_attr.type = RDMA_AH_ATTR_TYPE_ROCE;
+ 	rdma_ah_set_grh(&qp_attr->ah_attr, NULL,
+ 			params.flow_label, qp->sgid_idx,
+ 			params.hop_limit_ttl, params.traffic_class_tos);
+ 	rdma_ah_set_dgid_raw(&qp_attr->ah_attr, &params.dgid.bytes[0]);
+ 	rdma_ah_set_port_num(&qp_attr->ah_attr, 1);
+ 	rdma_ah_set_sl(&qp_attr->ah_attr, 0);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	qp_attr->timeout = params.timeout;
  	qp_attr->rnr_retry = params.rnr_retry;
  	qp_attr->retry_cnt = params.retry_cnt;
diff --cc drivers/infiniband/hw/qib/qib_verbs.c
index f1ccc4aa53fa,ac42dce7e281..000000000000
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@@ -1363,13 -1364,17 +1363,24 @@@ static void qib_notify_new_ah(struct ib
  
  struct ib_ah *qib_create_qp0_ah(struct qib_ibport *ibp, u16 dlid)
  {
 -	struct rdma_ah_attr attr;
 +	struct ib_ah_attr attr;
  	struct ib_ah *ah = ERR_PTR(-EINVAL);
  	struct rvt_qp *qp0;
++<<<<<<< HEAD
 +
 +	memset(&attr, 0, sizeof(attr));
 +	attr.dlid = dlid;
 +	attr.port_num = ppd_from_ibp(ibp)->port;
++=======
+ 	struct qib_pportdata *ppd = ppd_from_ibp(ibp);
+ 	struct qib_devdata *dd = dd_from_ppd(ppd);
+ 	u8 port_num = ppd->port;
+ 
+ 	memset(&attr, 0, sizeof(attr));
+ 	attr.type = rdma_ah_find_type(&dd->verbs_dev.rdi.ibdev, port_num);
+ 	rdma_ah_set_dlid(&attr, dlid);
+ 	rdma_ah_set_port_num(&attr, port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	rcu_read_lock();
  	qp0 = rcu_dereference(ibp->rvp.qp[0]);
  	if (qp0)
diff --cc drivers/infiniband/sw/rxe/rxe_av.c
index 88a4a7f15fbd,5bddf469361b..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_av.c
+++ b/drivers/infiniband/sw/rxe/rxe_av.c
@@@ -66,11 -68,12 +66,18 @@@ int rxe_av_from_attr(struct rxe_dev *rx
  }
  
  int rxe_av_to_attr(struct rxe_dev *rxe, struct rxe_av *av,
 -		   struct rdma_ah_attr *attr)
 +		   struct ib_ah_attr *attr)
  {
++<<<<<<< HEAD
 +	memcpy(&attr->grh, &av->grh, sizeof(av->grh));
 +	attr->ah_flags = IB_AH_GRH;
 +	attr->port_num = av->port_num;
++=======
+ 	attr->type = RDMA_AH_ATTR_TYPE_ROCE;
+ 	memcpy(rdma_ah_retrieve_grh(attr), &av->grh, sizeof(av->grh));
+ 	rdma_ah_set_ah_flags(attr, IB_AH_GRH);
+ 	rdma_ah_set_port_num(attr, av->port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	return 0;
  }
  
diff --cc drivers/infiniband/ulp/ipoib/ipoib_multicast.c
index aa3bf170bf6c,057f58e6afca..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@@ -268,39 -274,34 +268,48 @@@ static int ipoib_mcast_join_finish(stru
  		}
  	}
  
++<<<<<<< HEAD
 +	{
 +		struct ib_ah_attr av = {
 +			.dlid	       = be16_to_cpu(mcast->mcmember.mlid),
 +			.port_num      = priv->port,
 +			.sl	       = mcast->mcmember.sl,
 +			.ah_flags      = IB_AH_GRH,
 +			.static_rate   = mcast->mcmember.rate,
 +			.grh	       = {
 +				.flow_label    = be32_to_cpu(mcast->mcmember.flow_label),
 +				.hop_limit     = mcast->mcmember.hop_limit,
 +				.sgid_index    = 0,
 +				.traffic_class = mcast->mcmember.traffic_class
 +			}
 +		};
 +		av.grh.dgid = mcast->mcmember.mgid;
++=======
+ 	memset(&av, 0, sizeof(av));
+ 	av.type = rdma_ah_find_type(priv->ca, priv->port);
+ 	rdma_ah_set_dlid(&av, be16_to_cpu(mcast->mcmember.mlid)),
+ 	rdma_ah_set_port_num(&av, priv->port);
+ 	rdma_ah_set_sl(&av, mcast->mcmember.sl);
+ 	rdma_ah_set_static_rate(&av, mcast->mcmember.rate);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
 +
 +		ah = ipoib_create_ah(dev, priv->pd, &av);
 +		if (IS_ERR(ah)) {
 +			ipoib_warn(priv, "ib_address_create failed %ld\n",
 +				-PTR_ERR(ah));
 +			/* use original error */
 +			return PTR_ERR(ah);
 +		}
 +		spin_lock_irq(&priv->lock);
 +		mcast->ah = ah;
 +		spin_unlock_irq(&priv->lock);
  
 -	rdma_ah_set_grh(&av, &mcast->mcmember.mgid,
 -			be32_to_cpu(mcast->mcmember.flow_label),
 -			0, mcast->mcmember.hop_limit,
 -			mcast->mcmember.traffic_class);
 -
 -	ah = ipoib_create_ah(dev, priv->pd, &av);
 -	if (IS_ERR(ah)) {
 -		ipoib_warn(priv, "ib_address_create failed %ld\n",
 -			   -PTR_ERR(ah));
 -		/* use original error */
 -		return PTR_ERR(ah);
 +		ipoib_dbg_mcast(priv, "MGID %pI6 AV %p, LID 0x%04x, SL %d\n",
 +				mcast->mcmember.mgid.raw,
 +				mcast->ah->ah,
 +				be16_to_cpu(mcast->mcmember.mlid),
 +				mcast->mcmember.sl);
  	}
 -	spin_lock_irq(&priv->lock);
 -	mcast->ah = ah;
 -	spin_unlock_irq(&priv->lock);
 -
 -	ipoib_dbg_mcast(priv, "MGID %pI6 AV %p, LID 0x%04x, SL %d\n",
 -			mcast->mcmember.mgid.raw,
 -			mcast->ah->ah,
 -			be16_to_cpu(mcast->mcmember.mlid),
 -			mcast->mcmember.sl);
  
  	/* actually send any queued packets */
  	netif_tx_lock_bh(dev);
diff --cc drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
index cee49aa6676c,875694f9a7f9..000000000000
--- a/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
+++ b/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
@@@ -757,8 -757,10 +757,15 @@@ void opa_vnic_vema_send_trap(struct opa
  	class = &port->class_port_info;
  	/* Set up address handle */
  	memset(&ah_attr, 0, sizeof(ah_attr));
++<<<<<<< HEAD
 +	ah_attr.sl = GET_TRAP_SL_FROM_CLASS_PORT_INFO(class->trap_sl_rsvd);
 +	ah_attr.port_num = port->port_num;
++=======
+ 	ah_attr.type = rdma_ah_find_type(ibp, port->port_num);
+ 	rdma_ah_set_sl(&ah_attr,
+ 		       GET_TRAP_SL_FROM_CLASS_PORT_INFO(class->trap_sl_rsvd));
+ 	rdma_ah_set_port_num(&ah_attr, port->port_num);
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  	trap_lid = be32_to_cpu(class->trap_lid);
  	/*
  	 * check for trap lid validity, must not be zero
diff --cc include/rdma/ib_verbs.h
index 767ceffc3be4,803927b31742..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -838,15 -840,31 +838,35 @@@ struct ib_mr_status 
   */
  __attribute_const__ enum ib_rate mult_to_ib_rate(int mult);
  
++<<<<<<< HEAD
++struct ib_ah_attr {
++=======
+ enum rdma_ah_attr_type {
+ 	RDMA_AH_ATTR_TYPE_IB,
+ 	RDMA_AH_ATTR_TYPE_ROCE,
+ };
+ 
  struct ib_ah_attr {
- 	struct ib_global_route	grh;
  	u16			dlid;
- 	u8			sl;
  	u8			src_path_bits;
+ };
+ 
+ struct roce_ah_attr {
+ 	u8			dmac[ETH_ALEN];
+ };
+ 
+ struct rdma_ah_attr {
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
+ 	struct ib_global_route	grh;
+ 	u8			sl;
  	u8			static_rate;
- 	u8			ah_flags;
  	u8			port_num;
- 	u8			dmac[ETH_ALEN];
+ 	u8			ah_flags;
+ 	enum rdma_ah_attr_type type;
+ 	union {
+ 		struct ib_ah_attr ib;
+ 		struct roce_ah_attr roce;
+ 	};
  };
  
  enum ib_wc_status {
@@@ -3501,5 -3481,145 +3522,149 @@@ void ib_drain_sq(struct ib_qp *qp)
  void ib_drain_qp(struct ib_qp *qp);
  
  int ib_resolve_eth_dmac(struct ib_device *device,
++<<<<<<< HEAD
 +			struct ib_ah_attr *ah_attr);
++=======
+ 			struct rdma_ah_attr *ah_attr);
+ 
+ static inline u8 *rdma_ah_retrieve_dmac(struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_ROCE)
+ 		return attr->roce.dmac;
+ 	return NULL;
+ }
+ 
+ static inline void rdma_ah_set_dlid(struct rdma_ah_attr *attr, u16 dlid)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		attr->ib.dlid = dlid;
+ }
+ 
+ static inline u16 rdma_ah_get_dlid(const struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		return attr->ib.dlid;
+ 	return 0;
+ }
+ 
+ static inline void rdma_ah_set_sl(struct rdma_ah_attr *attr, u8 sl)
+ {
+ 	attr->sl = sl;
+ }
+ 
+ static inline u8 rdma_ah_get_sl(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->sl;
+ }
+ 
+ static inline void rdma_ah_set_path_bits(struct rdma_ah_attr *attr,
+ 					 u8 src_path_bits)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		attr->ib.src_path_bits = src_path_bits;
+ }
+ 
+ static inline u8 rdma_ah_get_path_bits(const struct rdma_ah_attr *attr)
+ {
+ 	if (attr->type == RDMA_AH_ATTR_TYPE_IB)
+ 		return attr->ib.src_path_bits;
+ 	return 0;
+ }
+ 
+ static inline void rdma_ah_set_port_num(struct rdma_ah_attr *attr, u8 port_num)
+ {
+ 	attr->port_num = port_num;
+ }
+ 
+ static inline u8 rdma_ah_get_port_num(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->port_num;
+ }
+ 
+ static inline void rdma_ah_set_static_rate(struct rdma_ah_attr *attr,
+ 					   u8 static_rate)
+ {
+ 	attr->static_rate = static_rate;
+ }
+ 
+ static inline u8 rdma_ah_get_static_rate(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->static_rate;
+ }
+ 
+ static inline void rdma_ah_set_ah_flags(struct rdma_ah_attr *attr,
+ 					enum ib_ah_flags flag)
+ {
+ 	attr->ah_flags = flag;
+ }
+ 
+ static inline enum ib_ah_flags
+ 		rdma_ah_get_ah_flags(const struct rdma_ah_attr *attr)
+ {
+ 	return attr->ah_flags;
+ }
+ 
+ static inline const struct ib_global_route
+ 		*rdma_ah_read_grh(const struct rdma_ah_attr *attr)
+ {
+ 	return &attr->grh;
+ }
+ 
+ /*To retrieve and modify the grh */
+ static inline struct ib_global_route
+ 		*rdma_ah_retrieve_grh(struct rdma_ah_attr *attr)
+ {
+ 	return &attr->grh;
+ }
+ 
+ static inline void rdma_ah_set_dgid_raw(struct rdma_ah_attr *attr, void *dgid)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	memcpy(grh->dgid.raw, dgid, sizeof(grh->dgid));
+ }
+ 
+ static inline void rdma_ah_set_subnet_prefix(struct rdma_ah_attr *attr,
+ 					     __be64 prefix)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	grh->dgid.global.subnet_prefix = prefix;
+ }
+ 
+ static inline void rdma_ah_set_interface_id(struct rdma_ah_attr *attr,
+ 					    __be64 if_id)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	grh->dgid.global.interface_id = if_id;
+ }
+ 
+ static inline void rdma_ah_set_grh(struct rdma_ah_attr *attr,
+ 				   union ib_gid *dgid, u32 flow_label,
+ 				   u8 sgid_index, u8 hop_limit,
+ 				   u8 traffic_class)
+ {
+ 	struct ib_global_route *grh = rdma_ah_retrieve_grh(attr);
+ 
+ 	attr->ah_flags = IB_AH_GRH;
+ 	if (dgid)
+ 		grh->dgid = *dgid;
+ 	grh->flow_label = flow_label;
+ 	grh->sgid_index = sgid_index;
+ 	grh->hop_limit = hop_limit;
+ 	grh->traffic_class = traffic_class;
+ }
+ 
+ /*Get AH type */
+ static inline enum rdma_ah_attr_type rdma_ah_find_type(struct ib_device *dev,
+ 						       u32 port_num)
+ {
+ 	if ((rdma_protocol_roce(dev, port_num)) ||
+ 	    (rdma_protocol_iwarp(dev, port_num)))
+ 		return RDMA_AH_ATTR_TYPE_ROCE;
+ 	else
+ 		return RDMA_AH_ATTR_TYPE_IB;
+ }
++>>>>>>> 44c58487d51a (IB/core: Define 'ib' and 'roce' rdma_ah_attr types)
  #endif /* IB_VERBS_H */
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v1.c
* Unmerged path drivers/infiniband/hw/vmw_pvrdma/pvrdma_misc.c
* Unmerged path drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
* Unmerged path net/smc/smc_ib.c
* Unmerged path drivers/infiniband/core/cm.c
* Unmerged path drivers/infiniband/core/multicast.c
* Unmerged path drivers/infiniband/core/sa_query.c
* Unmerged path drivers/infiniband/core/user_mad.c
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/verbs.c
* Unmerged path drivers/infiniband/hw/bnxt_re/ib_verbs.c
* Unmerged path drivers/infiniband/hw/hfi1/verbs.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v1.c
* Unmerged path drivers/infiniband/hw/mlx4/ah.c
* Unmerged path drivers/infiniband/hw/mlx4/mad.c
* Unmerged path drivers/infiniband/hw/mlx4/qp.c
* Unmerged path drivers/infiniband/hw/mlx5/ah.c
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_av.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_mad.c
* Unmerged path drivers/infiniband/hw/mthca/mthca_qp.c
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma.h b/drivers/infiniband/hw/ocrdma/ocrdma.h
index 45bdfa0e3b2b..9afed5bd38d2 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma.h
+++ b/drivers/infiniband/hw/ocrdma/ocrdma.h
@@ -537,7 +537,7 @@ static inline int ocrdma_resolve_dmac(struct ocrdma_dev *dev,
 	else if (rdma_link_local_addr(&in6))
 		rdma_get_ll_mac(&in6, mac_addr);
 	else
-		memcpy(mac_addr, ah_attr->dmac, ETH_ALEN);
+		memcpy(mac_addr, ah_attr->roce.dmac, ETH_ALEN);
 	return 0;
 }
 
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_ah.c
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
diff --git a/drivers/infiniband/hw/qedr/qedr_cm.c b/drivers/infiniband/hw/qedr/qedr_cm.c
index a6280ce3e2a5..8e58af2e62d4 100644
--- a/drivers/infiniband/hw/qedr/qedr_cm.c
+++ b/drivers/infiniband/hw/qedr/qedr_cm.c
@@ -307,7 +307,7 @@ static inline int qedr_gsi_build_header(struct qedr_dev *dev,
 	}
 
 	/* ENET + VLAN headers */
-	ether_addr_copy(udh->eth.dmac_h, ah_attr->dmac);
+	ether_addr_copy(udh->eth.dmac_h, ah_attr->roce.dmac);
 	ether_addr_copy(udh->eth.smac_h, dev->ndev->dev_addr);
 	if (has_vlan) {
 		udh->eth.type = htons(ETH_P_8021Q);
* Unmerged path drivers/infiniband/hw/qedr/verbs.c
* Unmerged path drivers/infiniband/hw/qib/qib_verbs.c
* Unmerged path drivers/infiniband/hw/vmw_pvrdma/pvrdma_misc.c
* Unmerged path drivers/infiniband/hw/vmw_pvrdma/pvrdma_verbs.c
* Unmerged path drivers/infiniband/sw/rxe/rxe_av.c
diff --git a/drivers/infiniband/sw/rxe/rxe_verbs.c b/drivers/infiniband/sw/rxe/rxe_verbs.c
index c50ff1706044..abb951e2fa36 100644
--- a/drivers/infiniband/sw/rxe/rxe_verbs.c
+++ b/drivers/infiniband/sw/rxe/rxe_verbs.c
@@ -375,6 +375,7 @@ static int rxe_query_ah(struct ib_ah *ibah, struct ib_ah_attr *attr)
 	struct rxe_ah *ah = to_rah(ibah);
 
 	memset(attr, 0, sizeof(*attr));
+	attr->type = ibah->type;
 	rxe_av_to_attr(rxe, &ah->av, attr);
 	return 0;
 }
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_multicast.c
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c
* Unmerged path include/rdma/ib_verbs.h
* Unmerged path net/smc/smc_ib.c
