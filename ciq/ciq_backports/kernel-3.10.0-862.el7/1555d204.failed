devlink: Support for pipeline debug (dpipe)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit 1555d204e743b6956d2be294a317121f6112238d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1555d204.failed

The pipeline debug is used to export the pipeline abstractions for the
main objects - tables, headers and entries. The only support for set is
for changing the counter parameter on specific table.

The basic structures:

Header - can represent a real protocol header information or internal
         metadata. Generic protocol headers like IPv4 can be shared
         between drivers. Each driver can add local headers.

Field - part of a header. Can represent protocol field or specific ASIC
        metadata field. Hardware special metadata fields can be mapped
        to different resources, for example switch ASIC ports can have
        internal number which from the systems point of view is mapped
        to netdeivce ifindex.

Match - represent specific match rule. Can describe match on specific
        field or header. The header index should be specified as well
        in order to support several header instances of the same type
        (tunneling).

Action - represents specific action rule. Actions can describe operations
         on specific field values for example like set, increment, etc.
         And header operation like add and delete.

Value - represents value which can be associated with specific match or
        action.

Table - represents a hardware block which can be described with match/
        action behavior. The match/action can be done on the packets
        data or on the internal metadata that it gathered along the
        packets traversal throw the pipeline which is vendor specific
        and should be exported in order to provide understanding of
        ASICs behavior.

Entry - represents single record in a specific table. The entry is
        identified by specific combination of values for match/action.

Prior to accessing the tables/entries the drivers provide the header/
field data base which is used by driver to user-space. The data base
is split between the shared headers and unique headers.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1555d204e743b6956d2be294a317121f6112238d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/devlink.h
#	net/core/devlink.c
diff --cc include/uapi/linux/devlink.h
index 9014c33d4e77,b47bee277347..000000000000
--- a/include/uapi/linux/devlink.h
+++ b/include/uapi/linux/devlink.h
@@@ -57,10 -57,20 +57,26 @@@ enum devlink_command 
  	DEVLINK_CMD_SB_OCC_SNAPSHOT,
  	DEVLINK_CMD_SB_OCC_MAX_CLEAR,
  
++<<<<<<< HEAD
 +	DEVLINK_CMD_ESWITCH_MODE_GET,
 +	DEVLINK_CMD_ESWITCH_MODE_SET,
 +	/* add new commands above here */
++=======
+ 	DEVLINK_CMD_ESWITCH_GET,
+ #define DEVLINK_CMD_ESWITCH_MODE_GET /* obsolete, never use this! */ \
+ 	DEVLINK_CMD_ESWITCH_GET
  
+ 	DEVLINK_CMD_ESWITCH_SET,
+ #define DEVLINK_CMD_ESWITCH_MODE_SET /* obsolete, never use this! */ \
+ 	DEVLINK_CMD_ESWITCH_SET
+ 
+ 	DEVLINK_CMD_DPIPE_TABLE_GET,
+ 	DEVLINK_CMD_DPIPE_ENTRIES_GET,
+ 	DEVLINK_CMD_DPIPE_HEADERS_GET,
+ 	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET,
++>>>>>>> 1555d204e743 (devlink: Support for pipeline debug (dpipe))
+ 
+ 	/* add new commands above here */
  	__DEVLINK_CMD_MAX,
  	DEVLINK_CMD_MAX = __DEVLINK_CMD_MAX - 1
  };
diff --cc net/core/devlink.c
index a17fcd87f267,24b766003a61..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -1648,6 -2310,62 +2328,65 @@@ static const struct genl_ops devlink_nl
  				  DEVLINK_NL_FLAG_NEED_SB |
  				  DEVLINK_NL_FLAG_LOCK_PORTS,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.cmd = DEVLINK_CMD_ESWITCH_GET,
+ 		.doit = devlink_nl_cmd_eswitch_get_doit,
+ 		.policy = devlink_nl_policy,
+ 		.flags = GENL_ADMIN_PERM,
+ 		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
+ 	},
+ 	{
+ 		.cmd = DEVLINK_CMD_ESWITCH_SET,
+ 		.doit = devlink_nl_cmd_eswitch_set_doit,
+ 		.policy = devlink_nl_policy,
+ 		.flags = GENL_ADMIN_PERM,
+ 		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
+ 	},
+ 	{
+ 		.cmd = DEVLINK_CMD_DPIPE_TABLE_GET,
+ 		.doit = devlink_nl_cmd_dpipe_table_get,
+ 		.policy = devlink_nl_policy,
+ 		.flags = GENL_ADMIN_PERM,
+ 		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
+ 	},
+ 	{
+ 		.cmd = DEVLINK_CMD_DPIPE_ENTRIES_GET,
+ 		.doit = devlink_nl_cmd_dpipe_entries_get,
+ 		.policy = devlink_nl_policy,
+ 		.flags = GENL_ADMIN_PERM,
+ 		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
+ 	},
+ 	{
+ 		.cmd = DEVLINK_CMD_DPIPE_HEADERS_GET,
+ 		.doit = devlink_nl_cmd_dpipe_headers_get,
+ 		.policy = devlink_nl_policy,
+ 		.flags = GENL_ADMIN_PERM,
+ 		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
+ 	},
+ 	{
+ 		.cmd = DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET,
+ 		.doit = devlink_nl_cmd_dpipe_table_counters_set,
+ 		.policy = devlink_nl_policy,
+ 		.flags = GENL_ADMIN_PERM,
+ 		.internal_flags = DEVLINK_NL_FLAG_NEED_DEVLINK,
+ 	},
+ };
+ 
+ static struct genl_family devlink_nl_family __ro_after_init = {
+ 	.name		= DEVLINK_GENL_NAME,
+ 	.version	= DEVLINK_GENL_VERSION,
+ 	.maxattr	= DEVLINK_ATTR_MAX,
+ 	.netnsok	= true,
+ 	.pre_doit	= devlink_nl_pre_doit,
+ 	.post_doit	= devlink_nl_post_doit,
+ 	.module		= THIS_MODULE,
+ 	.ops		= devlink_nl_ops,
+ 	.n_ops		= ARRAY_SIZE(devlink_nl_ops),
+ 	.mcgrps		= devlink_nl_mcgrps,
+ 	.n_mcgrps	= ARRAY_SIZE(devlink_nl_mcgrps),
++>>>>>>> 1555d204e743 (devlink: Support for pipeline debug (dpipe))
  };
  
  /**
@@@ -1870,11 -2589,136 +2610,138 @@@ void devlink_sb_unregister(struct devli
  }
  EXPORT_SYMBOL_GPL(devlink_sb_unregister);
  
+ /**
+  *	devlink_dpipe_headers_register - register dpipe headers
+  *
+  *	@devlink: devlink
+  *	@dpipe_headers: dpipe header array
+  *
+  *	Register the headers supported by hardware.
+  */
+ int devlink_dpipe_headers_register(struct devlink *devlink,
+ 				   struct devlink_dpipe_headers *dpipe_headers)
+ {
+ 	mutex_lock(&devlink_mutex);
+ 	devlink->dpipe_headers = dpipe_headers;
+ 	mutex_unlock(&devlink_mutex);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(devlink_dpipe_headers_register);
+ 
+ /**
+  *	devlink_dpipe_headers_unregister - unregister dpipe headers
+  *
+  *	@devlink: devlink
+  *
+  *	Unregister the headers supported by hardware.
+  */
+ void devlink_dpipe_headers_unregister(struct devlink *devlink)
+ {
+ 	mutex_lock(&devlink_mutex);
+ 	devlink->dpipe_headers = NULL;
+ 	mutex_unlock(&devlink_mutex);
+ }
+ EXPORT_SYMBOL_GPL(devlink_dpipe_headers_unregister);
+ 
+ /**
+  *	devlink_dpipe_table_counter_enabled - check if counter allocation
+  *					      required
+  *	@devlink: devlink
+  *	@table_name: tables name
+  *
+  *	Used by driver to check if counter allocation is required.
+  *	After counter allocation is turned on the table entries
+  *	are updated to include counter statistics.
+  *
+  *	After that point on the driver must respect the counter
+  *	state so that each entry added to the table is added
+  *	with a counter.
+  */
+ bool devlink_dpipe_table_counter_enabled(struct devlink *devlink,
+ 					 const char *table_name)
+ {
+ 	struct devlink_dpipe_table *table;
+ 	bool enabled;
+ 
+ 	rcu_read_lock();
+ 	table = devlink_dpipe_table_find(&devlink->dpipe_table_list,
+ 					 table_name);
+ 	enabled = false;
+ 	if (table)
+ 		enabled = table->counters_enabled;
+ 	rcu_read_unlock();
+ 	return enabled;
+ }
+ EXPORT_SYMBOL_GPL(devlink_dpipe_table_counter_enabled);
+ 
+ /**
+  *	devlink_dpipe_table_register - register dpipe table
+  *
+  *	@devlink: devlink
+  *	@table_name: table name
+  *	@table_ops: table ops
+  *	@priv: priv
+  *	@size: size
+  *	@counter_control_extern: external control for counters
+  */
+ int devlink_dpipe_table_register(struct devlink *devlink,
+ 				 const char *table_name,
+ 				 struct devlink_dpipe_table_ops *table_ops,
+ 				 void *priv, u64 size,
+ 				 bool counter_control_extern)
+ {
+ 	struct devlink_dpipe_table *table;
+ 
+ 	if (devlink_dpipe_table_find(&devlink->dpipe_table_list, table_name))
+ 		return -EEXIST;
+ 
+ 	table = kzalloc(sizeof(*table), GFP_KERNEL);
+ 	if (!table)
+ 		return -ENOMEM;
+ 
+ 	table->name = table_name;
+ 	table->table_ops = table_ops;
+ 	table->priv = priv;
+ 	table->size = size;
+ 	table->counter_control_extern = counter_control_extern;
+ 
+ 	mutex_lock(&devlink_mutex);
+ 	list_add_tail_rcu(&table->list, &devlink->dpipe_table_list);
+ 	mutex_unlock(&devlink_mutex);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(devlink_dpipe_table_register);
+ 
+ /**
+  *	devlink_dpipe_table_unregister - unregister dpipe table
+  *
+  *	@devlink: devlink
+  *	@table_name: table name
+  */
+ void devlink_dpipe_table_unregister(struct devlink *devlink,
+ 				    const char *table_name)
+ {
+ 	struct devlink_dpipe_table *table;
+ 
+ 	mutex_lock(&devlink_mutex);
+ 	table = devlink_dpipe_table_find(&devlink->dpipe_table_list,
+ 					 table_name);
+ 	if (!table)
+ 		goto unlock;
+ 	list_del_rcu(&table->list);
+ 	mutex_unlock(&devlink_mutex);
+ 	kfree_rcu(table, rcu);
+ 	return;
+ unlock:
+ 	mutex_unlock(&devlink_mutex);
+ }
+ EXPORT_SYMBOL_GPL(devlink_dpipe_table_unregister);
+ 
  static int __init devlink_module_init(void)
  {
 -	return genl_register_family(&devlink_nl_family);
 +	return genl_register_family_with_ops_groups(&devlink_nl_family,
 +						    devlink_nl_ops,
 +						    devlink_nl_mcgrps);
  }
  
  static void __exit devlink_module_exit(void)
diff --git a/include/net/devlink.h b/include/net/devlink.h
index c838fd57d82c..d11bb8e0fd70 100644
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@ -25,6 +25,8 @@ struct devlink {
 	struct list_head list;
 	struct list_head port_list;
 	struct list_head sb_list;
+	struct list_head dpipe_table_list;
+	struct devlink_dpipe_headers *dpipe_headers;
 	const struct devlink_ops *ops;
 	struct device *dev;
 	possible_net_t _net;
@@ -49,6 +51,178 @@ struct devlink_sb_pool_info {
 	enum devlink_sb_threshold_type threshold_type;
 };
 
+/**
+ * struct devlink_dpipe_field - dpipe field object
+ * @name: field name
+ * @id: index inside the headers field array
+ * @bitwidth: bitwidth
+ * @mapping_type: mapping type
+ */
+struct devlink_dpipe_field {
+	const char *name;
+	unsigned int id;
+	unsigned int bitwidth;
+	enum devlink_dpipe_field_mapping_type mapping_type;
+};
+
+/**
+ * struct devlink_dpipe_header - dpipe header object
+ * @name: header name
+ * @id: index, global/local detrmined by global bit
+ * @fields: fields
+ * @fields_count: number of fields
+ * @global: indicates if header is shared like most protocol header
+ *	    or driver specific
+ */
+struct devlink_dpipe_header {
+	const char *name;
+	unsigned int id;
+	struct devlink_dpipe_field *fields;
+	unsigned int fields_count;
+	bool global;
+};
+
+/**
+ * struct devlink_dpipe_match - represents match operation
+ * @type: type of match
+ * @header_index: header index (packets can have several headers of same
+ *		  type like in case of tunnels)
+ * @header: header
+ * @fieled_id: field index
+ */
+struct devlink_dpipe_match {
+	enum devlink_dpipe_match_type type;
+	unsigned int header_index;
+	struct devlink_dpipe_header *header;
+	unsigned int field_id;
+};
+
+/**
+ * struct devlink_dpipe_action - represents action operation
+ * @type: type of action
+ * @header_index: header index (packets can have several headers of same
+ *		  type like in case of tunnels)
+ * @header: header
+ * @fieled_id: field index
+ */
+struct devlink_dpipe_action {
+	enum devlink_dpipe_action_type type;
+	unsigned int header_index;
+	struct devlink_dpipe_header *header;
+	unsigned int field_id;
+};
+
+/**
+ * struct devlink_dpipe_value - represents value of match/action
+ * @action: action
+ * @match: match
+ * @mapping_value: in case the field has some mapping this value
+ *                 specified the mapping value
+ * @mapping_valid: specify if mapping value is valid
+ * @value_size: value size
+ * @value: value
+ * @mask: bit mask
+ */
+struct devlink_dpipe_value {
+	union {
+		struct devlink_dpipe_action *action;
+		struct devlink_dpipe_match *match;
+	};
+	unsigned int mapping_value;
+	bool mapping_valid;
+	unsigned int value_size;
+	void *value;
+	void *mask;
+};
+
+/**
+ * struct devlink_dpipe_entry - table entry object
+ * @index: index of the entry in the table
+ * @match_values: match values
+ * @matche_values_count: count of matches tuples
+ * @action_values: actions values
+ * @action_values_count: count of actions values
+ * @counter: value of counter
+ * @counter_valid: Specify if value is valid from hardware
+ */
+struct devlink_dpipe_entry {
+	u64 index;
+	struct devlink_dpipe_value *match_values;
+	unsigned int match_values_count;
+	struct devlink_dpipe_value *action_values;
+	unsigned int action_values_count;
+	u64 counter;
+	bool counter_valid;
+};
+
+/**
+ * struct devlink_dpipe_dump_ctx - context provided to driver in order
+ *				   to dump
+ * @info: info
+ * @cmd: devlink command
+ * @skb: skb
+ * @nest: top attribute
+ * @hdr: hdr
+ */
+struct devlink_dpipe_dump_ctx {
+	struct genl_info *info;
+	enum devlink_command cmd;
+	struct sk_buff *skb;
+	struct nlattr *nest;
+	void *hdr;
+};
+
+struct devlink_dpipe_table_ops;
+
+/**
+ * struct devlink_dpipe_table - table object
+ * @priv: private
+ * @name: table name
+ * @size: maximum number of entries
+ * @counters_enabled: indicates if counters are active
+ * @counter_control_extern: indicates if counter control is in dpipe or
+ *			    external tool
+ * @table_ops: table operations
+ * @rcu: rcu
+ */
+struct devlink_dpipe_table {
+	void *priv;
+	struct list_head list;
+	const char *name;
+	u64 size;
+	bool counters_enabled;
+	bool counter_control_extern;
+	struct devlink_dpipe_table_ops *table_ops;
+	struct rcu_head rcu;
+};
+
+/**
+ * struct devlink_dpipe_table_ops - dpipe_table ops
+ * @actions_dump - dumps all tables actions
+ * @matches_dump - dumps all tables matches
+ * @entries_dump - dumps all active entries in the table
+ * @counters_set_update - when changing the counter status hardware sync
+ *			  maybe needed to allocate/free counter related
+ *			  resources
+ */
+struct devlink_dpipe_table_ops {
+	int (*actions_dump)(void *priv, struct sk_buff *skb);
+	int (*matches_dump)(void *priv, struct sk_buff *skb);
+	int (*entries_dump)(void *priv, bool counters_enabled,
+			    struct devlink_dpipe_dump_ctx *dump_ctx);
+	int (*counters_set_update)(void *priv, bool enable);
+};
+
+/**
+ * struct devlink_dpipe_headers - dpipe headers
+ * @headers - header array can be shared (global bit) or driver specific
+ * @headers_count - count of headers
+ */
+struct devlink_dpipe_headers {
+	struct devlink_dpipe_header **headers;
+	unsigned int headers_count;
+};
+
 struct devlink_ops {
 	size_t priv_size;
 	int (*port_type_set)(struct devlink_port *devlink_port,
@@ -133,6 +307,26 @@ int devlink_sb_register(struct devlink *devlink, unsigned int sb_index,
 			u16 egress_pools_count, u16 ingress_tc_count,
 			u16 egress_tc_count);
 void devlink_sb_unregister(struct devlink *devlink, unsigned int sb_index);
+int devlink_dpipe_table_register(struct devlink *devlink,
+				 const char *table_name,
+				 struct devlink_dpipe_table_ops *table_ops,
+				 void *priv, u64 size,
+				 bool counter_control_extern);
+void devlink_dpipe_table_unregister(struct devlink *devlink,
+				    const char *table_name);
+int devlink_dpipe_headers_register(struct devlink *devlink,
+				   struct devlink_dpipe_headers *dpipe_headers);
+void devlink_dpipe_headers_unregister(struct devlink *devlink);
+bool devlink_dpipe_table_counter_enabled(struct devlink *devlink,
+					 const char *table_name);
+int devlink_dpipe_entry_ctx_prepare(struct devlink_dpipe_dump_ctx *dump_ctx);
+int devlink_dpipe_entry_ctx_append(struct devlink_dpipe_dump_ctx *dump_ctx,
+				   struct devlink_dpipe_entry *entry);
+int devlink_dpipe_entry_ctx_close(struct devlink_dpipe_dump_ctx *dump_ctx);
+int devlink_dpipe_action_put(struct sk_buff *skb,
+			     struct devlink_dpipe_action *action);
+int devlink_dpipe_match_put(struct sk_buff *skb,
+			    struct devlink_dpipe_match *match);
 
 #else
 
@@ -201,6 +395,71 @@ static inline void devlink_sb_unregister(struct devlink *devlink,
 {
 }
 
+static inline int
+devlink_dpipe_table_register(struct devlink *devlink,
+			     const char *table_name,
+			     struct devlink_dpipe_table_ops *table_ops,
+			     void *priv, u64 size,
+			     bool counter_control_extern)
+{
+	return 0;
+}
+
+static inline void devlink_dpipe_table_unregister(struct devlink *devlink,
+						  const char *table_name)
+{
+}
+
+static inline int devlink_dpipe_headers_register(struct devlink *devlink,
+						 struct devlink_dpipe_headers *
+						 dpipe_headers)
+{
+	return 0;
+}
+
+static inline void devlink_dpipe_headers_unregister(struct devlink *devlink)
+{
+}
+
+static inline bool devlink_dpipe_table_counter_enabled(struct devlink *devlink,
+						       const char *table_name)
+{
+	return false;
+}
+
+static inline int
+devlink_dpipe_entry_ctx_prepare(struct devlink_dpipe_dump_ctx *dump_ctx)
+{
+	return 0;
+}
+
+static inline int
+devlink_dpipe_entry_ctx_append(struct devlink_dpipe_dump_ctx *dump_ctx,
+			       struct devlink_dpipe_entry *entry)
+{
+	return 0;
+}
+
+static inline int
+devlink_dpipe_entry_ctx_close(struct devlink_dpipe_dump_ctx *dump_ctx)
+{
+	return 0;
+}
+
+static inline int
+devlink_dpipe_action_put(struct sk_buff *skb,
+			 struct devlink_dpipe_action *action)
+{
+	return 0;
+}
+
+static inline int
+devlink_dpipe_match_put(struct sk_buff *skb,
+			struct devlink_dpipe_match *match)
+{
+	return 0;
+}
+
 #endif
 
 #endif /* _NET_DEVLINK_H_ */
* Unmerged path include/uapi/linux/devlink.h
* Unmerged path net/core/devlink.c
