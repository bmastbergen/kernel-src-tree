net: sched: make default fifo qdiscs appear in the dump

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: make default fifo qdiscs appear in the dump (Ivan Vecera) [1445420]
Rebuild_FUZZ: 95.24%
commit-author Jiri Kosina <jkosina@suse.cz>
commit 49b499718fa1b0d639663cfd03085b9bfd23cdc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/49b49971.failed

The original reason [1] for having hidden qdiscs (potential scalability
issues in qdisc_match_from_root() with single linked list in case of large
amount of qdiscs) has been invalidated by 59cc1f61f0 ("net: sched: convert
qdisc linked list to hashtable").

This allows us for bringing more clarity and determinism into the dump by
making default pfifo qdiscs visible.

We're not turning this on by default though, at it was deemed [2] too
intrusive / unnecessary change of default behavior towards userspace.
Instead, TCA_DUMP_INVISIBLE netlink attribute is introduced, which allows
applications to request complete qdisc hierarchy dump, including the
ones that have always been implicit/invisible.

Singleton noop_qdisc stays invisible, as teaching the whole infrastructure
about singletons would require quite some surgery with very little gain
(seeing no qdisc or seeing noop qdisc in the dump is probably setting
the same user expectation).

[1] http://lkml.kernel.org/r/1460732328.10638.74.camel@edumazet-glaptop3.roam.corp.google.com
[2] http://lkml.kernel.org/r/20161021.105935.1907696543877061916.davem@davemloft.net

	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 49b499718fa1b0d639663cfd03085b9bfd23cdc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_sched.h
#	net/sched/sch_api.c
#	net/sched/sch_generic.c
#	net/sched/sch_mq.c
#	net/sched/sch_mqprio.c
diff --cc include/net/pkt_sched.h
index 7caa99b482c6,bec46f63f10c..000000000000
--- a/include/net/pkt_sched.h
+++ b/include/net/pkt_sched.h
@@@ -90,8 -92,8 +90,13 @@@ int unregister_qdisc(struct Qdisc_ops *
  void qdisc_get_default(char *id, size_t len);
  int qdisc_set_default(const char *id);
  
++<<<<<<< HEAD
 +void qdisc_list_add(struct Qdisc *q);
 +void qdisc_list_del(struct Qdisc *q);
++=======
+ void qdisc_hash_add(struct Qdisc *q, bool invisible);
+ void qdisc_hash_del(struct Qdisc *q);
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  struct Qdisc *qdisc_lookup(struct net_device *dev, u32 handle);
  struct Qdisc *qdisc_lookup_class(struct net_device *dev, u32 handle);
  struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r,
diff --cc net/sched/sch_api.c
index ed3bc037a800,62567bfe52c7..000000000000
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@@ -272,19 -274,21 +272,29 @@@ static struct Qdisc *qdisc_match_from_r
  	return NULL;
  }
  
++<<<<<<< HEAD
 +void qdisc_list_add(struct Qdisc *q)
++=======
+ void qdisc_hash_add(struct Qdisc *q, bool invisible)
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  {
  	if ((q->parent != TC_H_ROOT) && !(q->flags & TCQ_F_INGRESS)) {
  		struct Qdisc *root = qdisc_dev(q)->qdisc;
  
  		WARN_ON_ONCE(root == &noop_qdisc);
  		ASSERT_RTNL();
++<<<<<<< HEAD
 +		list_add_tail_rcu(&q->list, &root->list);
++=======
+ 		hash_add_rcu(qdisc_dev(q)->qdisc_hash, &q->hash, q->handle);
+ 		if (invisible)
+ 			q->flags |= TCQ_F_INVISIBLE;
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  	}
  }
 -EXPORT_SYMBOL(qdisc_hash_add);
 +EXPORT_SYMBOL(qdisc_list_add);
  
 -void qdisc_hash_del(struct Qdisc *q)
 +void qdisc_list_del(struct Qdisc *q)
  {
  	if ((q->parent != TC_H_ROOT) && !(q->flags & TCQ_F_INGRESS)) {
  		ASSERT_RTNL();
@@@ -1001,7 -1005,7 +1011,11 @@@ static struct Qdisc *qdisc_create(struc
  				goto err_out4;
  		}
  
++<<<<<<< HEAD
 +		qdisc_list_add(sch);
++=======
+ 		qdisc_hash_add(sch, false);
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  
  		return sch;
  	}
@@@ -1436,7 -1446,8 +1455,12 @@@ err_out
  
  static int tc_dump_qdisc_root(struct Qdisc *root, struct sk_buff *skb,
  			      struct netlink_callback *cb,
++<<<<<<< HEAD
 +			      int *q_idx_p, int s_q_idx)
++=======
+ 			      int *q_idx_p, int s_q_idx, bool recur,
+ 			      bool dump_invisible)
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  {
  	int ret = 0, q_idx = *q_idx_p;
  	struct Qdisc *q;
@@@ -1497,13 -1528,15 +1530,23 @@@ static int tc_dump_qdisc(struct sk_buf
  			s_q_idx = 0;
  		q_idx = 0;
  
++<<<<<<< HEAD
 +		if (tc_dump_qdisc_root(dev->qdisc, skb, cb, &q_idx, s_q_idx) < 0)
++=======
+ 		if (tc_dump_qdisc_root(dev->qdisc, skb, cb, &q_idx, s_q_idx,
+ 				       true, tca[TCA_DUMP_INVISIBLE]) < 0)
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  			goto done;
  
  		dev_queue = dev_ingress_queue(dev);
  		if (dev_queue &&
  		    tc_dump_qdisc_root(dev_queue->qdisc_sleeping, skb, cb,
++<<<<<<< HEAD
 +				       &q_idx, s_q_idx) < 0)
++=======
+ 				       &q_idx, s_q_idx, false,
+ 				       tca[TCA_DUMP_INVISIBLE]) < 0)
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  			goto done;
  
  cont:
diff --cc net/sched/sch_generic.c
index 57cbfa322683,3e64d23e098c..000000000000
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@@ -767,6 -793,10 +767,13 @@@ static void attach_default_qdiscs(struc
  			qdisc->ops->attach(qdisc);
  		}
  	}
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_SCHED
+ 	if (dev->qdisc)
+ 		qdisc_hash_add(dev->qdisc, false);
+ #endif
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  }
  
  static void transition_one_qdisc(struct net_device *dev,
diff --cc net/sched/sch_mq.c
index c066b0e74b88,cadfdd4f1e52..000000000000
--- a/net/sched/sch_mq.c
+++ b/net/sched/sch_mq.c
@@@ -84,7 -84,7 +84,11 @@@ static void mq_attach(struct Qdisc *sch
  			qdisc_destroy(old);
  #ifdef CONFIG_NET_SCHED
  		if (ntx < dev->real_num_tx_queues)
++<<<<<<< HEAD
 +			qdisc_list_add(qdisc);
++=======
+ 			qdisc_hash_add(qdisc, false);
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  #endif
  
  	}
diff --cc net/sched/sch_mqprio.c
index 748ea1bbc507,b851e209da4d..000000000000
--- a/net/sched/sch_mqprio.c
+++ b/net/sched/sch_mqprio.c
@@@ -184,7 -175,7 +184,11 @@@ static void mqprio_attach(struct Qdisc 
  		if (old)
  			qdisc_destroy(old);
  		if (ntx < dev->real_num_tx_queues)
++<<<<<<< HEAD
 +			qdisc_list_add(qdisc);
++=======
+ 			qdisc_hash_add(qdisc, false);
++>>>>>>> 49b499718fa1 (net: sched: make default fifo qdiscs appear in the dump)
  	}
  	kfree(priv->qdiscs);
  	priv->qdiscs = NULL;
* Unmerged path include/net/pkt_sched.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 7b71681b10fc..5708c93df7b9 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -63,6 +63,7 @@ struct Qdisc {
 #define TCQ_F_NOPARENT		0x40 /* root of its hierarchy :
 				      * qdisc_tree_decrease_qlen() should stop.
 				      */
+#define TCQ_F_INVISIBLE		0x80 /* invisible by default in dump */
 	u32			limit;
 	const struct Qdisc_ops	*ops;
 	struct qdisc_size_table	__rcu *stab;
diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
index d8701000036f..3602da03c491 100644
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -539,6 +539,7 @@ enum {
 	TCA_STATS2,
 	TCA_STAB,
 	TCA_PAD,
+	TCA_DUMP_INVISIBLE,
 	__TCA_MAX
 };
 
* Unmerged path net/sched/sch_api.c
diff --git a/net/sched/sch_cbq.c b/net/sched/sch_cbq.c
index 24f30ccfced6..97dbf1a60195 100644
--- a/net/sched/sch_cbq.c
+++ b/net/sched/sch_cbq.c
@@ -1184,6 +1184,8 @@ static int cbq_init(struct Qdisc *sch, struct nlattr *opt)
 				      sch->handle);
 	if (!q->link.q)
 		q->link.q = &noop_qdisc;
+	else
+		qdisc_hash_add(q->link.q, true);
 
 	q->link.priority = TC_CBQ_MAXPRIO - 1;
 	q->link.priority2 = TC_CBQ_MAXPRIO - 1;
@@ -1623,6 +1625,9 @@ cbq_change_class(struct Qdisc *sch, u32 classid, u32 parentid, struct nlattr **t
 	cl->q = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops, classid);
 	if (!cl->q)
 		cl->q = &noop_qdisc;
+	else
+		qdisc_hash_add(cl->q, true);
+
 	cl->common.classid = classid;
 	cl->tparent = parent;
 	cl->qdisc = sch;
diff --git a/net/sched/sch_drr.c b/net/sched/sch_drr.c
index c44f9d3bf69e..6c27599d4e96 100644
--- a/net/sched/sch_drr.c
+++ b/net/sched/sch_drr.c
@@ -117,6 +117,8 @@ static int drr_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 					       &pfifo_qdisc_ops, classid);
 	if (cl->qdisc == NULL)
 		cl->qdisc = &noop_qdisc;
+	else
+		qdisc_hash_add(cl->qdisc, true);
 
 	if (tca[TCA_RATE]) {
 		err = gen_replace_estimator(&cl->bstats, NULL, &cl->rate_est,
diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c
index 667dc2b20143..0578515d9bd4 100644
--- a/net/sched/sch_dsmark.c
+++ b/net/sched/sch_dsmark.c
@@ -382,6 +382,8 @@ static int dsmark_init(struct Qdisc *sch, struct nlattr *opt)
 	p->q = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops, sch->handle);
 	if (p->q == NULL)
 		p->q = &noop_qdisc;
+	else
+		qdisc_hash_add(p->q, true);
 
 	pr_debug("dsmark_init: qdisc %p\n", p->q);
 
* Unmerged path net/sched/sch_generic.c
diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c
index 4ffeb7ff2b61..ef5717319ca0 100644
--- a/net/sched/sch_hfsc.c
+++ b/net/sched/sch_hfsc.c
@@ -1066,6 +1066,8 @@ hfsc_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 				      &pfifo_qdisc_ops, classid);
 	if (cl->qdisc == NULL)
 		cl->qdisc = &noop_qdisc;
+	else
+		qdisc_hash_add(cl->qdisc, true);
 	INIT_LIST_HEAD(&cl->children);
 	cl->vt_tree = RB_ROOT;
 	cl->cf_tree = RB_ROOT;
@@ -1425,6 +1427,8 @@ hfsc_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
 					  sch->handle);
 	if (q->root.qdisc == NULL)
 		q->root.qdisc = &noop_qdisc;
+	else
+		qdisc_hash_add(q->root.qdisc, true);
 	INIT_LIST_HEAD(&q->root.children);
 	q->root.vt_tree = RB_ROOT;
 	q->root.cf_tree = RB_ROOT;
diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c
index 2abcfb74a823..dc4796d05a4a 100644
--- a/net/sched/sch_htb.c
+++ b/net/sched/sch_htb.c
@@ -1464,6 +1464,8 @@ static int htb_change_class(struct Qdisc *sch, u32 classid,
 		qdisc_class_hash_insert(&q->clhash, &cl->common);
 		if (parent)
 			parent->children++;
+		if (cl->un.leaf.q != &noop_qdisc)
+			qdisc_hash_add(cl->un.leaf.q, true);
 	} else {
 		if (tca[TCA_RATE]) {
 			err = gen_replace_estimator(&cl->bstats, NULL,
* Unmerged path net/sched/sch_mq.c
* Unmerged path net/sched/sch_mqprio.c
diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c
index 759faafd074d..66f8387a7c78 100644
--- a/net/sched/sch_multiq.c
+++ b/net/sched/sch_multiq.c
@@ -238,6 +238,8 @@ static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)
 				sch_tree_lock(sch);
 				old = q->queues[i];
 				q->queues[i] = child;
+				if (child != &noop_qdisc)
+					qdisc_hash_add(child, true);
 
 				if (old != &noop_qdisc) {
 					qdisc_tree_reduce_backlog(old,
diff --git a/net/sched/sch_prio.c b/net/sched/sch_prio.c
index bda93ee4f685..7d893df958df 100644
--- a/net/sched/sch_prio.c
+++ b/net/sched/sch_prio.c
@@ -211,8 +211,11 @@ static int prio_tune(struct Qdisc *sch, struct nlattr *opt)
 		qdisc_destroy(child);
 	}
 
-	for (i = oldbands; i < q->bands; i++)
+	for (i = oldbands; i < q->bands; i++) {
 		q->queues[i] = queues[i];
+		if (q->queues[i] != &noop_qdisc)
+			qdisc_hash_add(q->queues[i], true);
+	}
 
 	sch_tree_unlock(sch);
 	return 0;
diff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c
index c65d929a9687..90e6fba8e101 100644
--- a/net/sched/sch_qfq.c
+++ b/net/sched/sch_qfq.c
@@ -494,6 +494,8 @@ static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 			goto destroy_class;
 	}
 
+	if (cl->qdisc != &noop_qdisc)
+		qdisc_hash_add(cl->qdisc, true);
 	sch_tree_lock(sch);
 	qdisc_class_hash_insert(&q->clhash, &cl->common);
 	sch_tree_unlock(sch);
diff --git a/net/sched/sch_red.c b/net/sched/sch_red.c
index 91578bdd378c..043ede6ed860 100644
--- a/net/sched/sch_red.c
+++ b/net/sched/sch_red.c
@@ -210,6 +210,8 @@ static int red_change(struct Qdisc *sch, struct nlattr *opt)
 			return PTR_ERR(child);
 	}
 
+	if (child != &noop_qdisc)
+		qdisc_hash_add(child, true);
 	sch_tree_lock(sch);
 	q->flags = ctl->flags;
 	q->limit = ctl->limit;
diff --git a/net/sched/sch_sfb.c b/net/sched/sch_sfb.c
index ba31a5b026c4..fc51a43a0e11 100644
--- a/net/sched/sch_sfb.c
+++ b/net/sched/sch_sfb.c
@@ -511,6 +511,8 @@ static int sfb_change(struct Qdisc *sch, struct nlattr *opt)
 	if (IS_ERR(child))
 		return PTR_ERR(child);
 
+	if (child != &noop_qdisc)
+		qdisc_hash_add(child, true);
 	sch_tree_lock(sch);
 
 	qdisc_tree_reduce_backlog(q->qdisc, q->qdisc->q.qlen,
diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c
index 63a8f2654e58..f99f6ac0177a 100644
--- a/net/sched/sch_tbf.c
+++ b/net/sched/sch_tbf.c
@@ -414,6 +414,8 @@ static int tbf_change(struct Qdisc *sch, struct nlattr *opt)
 					  q->qdisc->qstats.backlog);
 		qdisc_destroy(q->qdisc);
 		q->qdisc = child;
+		if (child != &noop_qdisc);
+			qdisc_hash_add(child, true);
 	}
 	q->limit = qopt->limit;
 	if (tb[TCA_TBF_PBURST])
