xfs: eliminate duplicate icreate tx reservation functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Brian Foster <bfoster@redhat.com>
commit c017cb5ddfd6326032570d5eba83308c8a9c13a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c017cb5d.failed

The create transaction reservation calculation has two different
branches of code depending on whether the filesystem is a v5 format
fs or older. Each branch considers the max reservation between the
allocation case (new chunk allocation + record insert) and the
modify case (chunk exists, record modification) of inode allocation.

The modify case is the same for both superblock versions with the
exception of the finobt. The finobt helper checks the feature bit,
however, and so the modify case already shares the same code.

Now that inode chunk allocation has been refactored into a helper
that checks the superblock version to calculate the appropriate
reservation for the create transaction, the only remaining
difference between the create and icreate branches is the call to
the finobt helper. As noted above, the finobt helper is a no-op when
the feature is not enabled. Therefore, these branches are
effectively duplicate and can be condensed.

Remove the xfs_calc_create_*() branch of functions and update the
various callers to use the xfs_calc_icreate_*() variant. The latter
creates the same reservation size for v4 create transactions as the
removed branch. As such, this patch does not result in transaction
reservation changes.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit c017cb5ddfd6326032570d5eba83308c8a9c13a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_trans_resv.c
diff --cc fs/xfs/libxfs/xfs_trans_resv.c
index 1b754cb1e8ae,5f17641f040f..000000000000
--- a/fs/xfs/libxfs/xfs_trans_resv.c
+++ b/fs/xfs/libxfs/xfs_trans_resv.c
@@@ -352,45 -410,16 +352,54 @@@ xfs_calc_create_resv_modify
  		xfs_calc_buf_res(1, mp->m_sb.sb_sectsize) +
  		(uint)XFS_FSB_TO_B(mp, 1) +
  		xfs_calc_buf_res(XFS_DIROP_LOG_COUNT(mp), XFS_FSB_TO_B(mp, 1)) +
 -		xfs_calc_finobt_res(mp);
 +		xfs_calc_finobt_res(mp, 1, 1);
 +}
 +
 +/*
++<<<<<<< HEAD
 + * For create we can allocate some inodes giving:
 + *    the agi and agf of the ag getting the new inodes: 2 * sectorsize
 + *    the superblock for the nlink flag: sector size
 + *    the inode blocks allocated: mp->m_ialloc_blks * blocksize
 + *    the inode btree: max depth * blocksize
 + *    the allocation btrees: 2 trees * (max depth - 1) * block size
 + */
 +STATIC uint
 +xfs_calc_create_resv_alloc(
 +	struct xfs_mount	*mp)
 +{
 +	return xfs_calc_buf_res(2, mp->m_sb.sb_sectsize) +
 +		mp->m_sb.sb_sectsize +
 +		xfs_calc_buf_res(mp->m_ialloc_blks, XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 +				 XFS_FSB_TO_B(mp, 1));
 +}
 +
 +STATIC uint
 +__xfs_calc_create_reservation(
 +	struct xfs_mount	*mp)
 +{
 +	return XFS_DQUOT_LOGRES(mp) +
 +		MAX(xfs_calc_create_resv_alloc(mp),
 +		    xfs_calc_create_resv_modify(mp));
  }
  
  /*
 + * For icreate we can allocate some inodes giving:
 + *    the agi and agf of the ag getting the new inodes: 2 * sectorsize
 + *    the superblock for the nlink flag: sector size
 + *    the inode btree: max depth * blocksize
 + *    the allocation btrees: 2 trees * (max depth - 1) * block size
 + *    the finobt (record insertion)
++=======
+  * For icreate we can allocate some inodes giving:
+  *    the agi and agf of the ag getting the new inodes: 2 * sectorsize
+  *    the superblock for the nlink flag: sector size
+  *    the inode chunk (allocation, optional init)
+  *    the inobt (record insertion)
+  *    the finobt (optional, record insertion)
++>>>>>>> c017cb5ddfd6 (xfs: eliminate duplicate icreate tx reservation functions)
   */
  STATIC uint
  xfs_calc_icreate_resv_alloc(
@@@ -456,8 -470,8 +451,13 @@@ STATIC uin
  xfs_calc_symlink_reservation(
  	struct xfs_mount	*mp)
  {
++<<<<<<< HEAD
 +	return xfs_calc_create_reservation(mp) +
 +	       xfs_calc_buf_res(1, MAXPATHLEN);
++=======
+ 	return xfs_calc_icreate_reservation(mp) +
+ 	       xfs_calc_buf_res(1, XFS_SYMLINK_MAXLEN);
++>>>>>>> c017cb5ddfd6 (xfs: eliminate duplicate icreate tx reservation functions)
  }
  
  /*
* Unmerged path fs/xfs/libxfs/xfs_trans_resv.c
