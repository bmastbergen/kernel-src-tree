genirq: Add a helper to spread an affinity mask for MSI/MSI-X vectors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 5e385a6ef31fbbf2acbda770aecc2bc2ff933d17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5e385a6e.failed

This is lifted from the blk-mq code and adopted to use the affinity mask
concept just introduced in the irq handling code.  It tries to keep the
algorithm the same as the one current used by blk-mq, but improvements
like assining vectors on a per-node basis instead of just per sibling
are possible with this simple move and refactoring.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Cc: linux-block@vger.kernel.org
	Cc: linux-pci@vger.kernel.org
	Cc: linux-nvme@lists.infradead.org
	Cc: axboe@fb.com
	Cc: agordeev@redhat.com
Link: http://lkml.kernel.org/r/1467621574-8277-7-git-send-email-hch@lst.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 5e385a6ef31fbbf2acbda770aecc2bc2ff933d17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/interrupt.h
#	kernel/irq/Makefile
diff --cc include/linux/interrupt.h
index 775c38a0baff,b6683f0ffc9f..000000000000
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@@ -318,9 -304,20 +320,25 @@@ static inline int irq_set_affinity_hint
  {
  	return -EINVAL;
  }
 +#endif /* CONFIG_SMP && CONFIG_GENERIC_HARDIRQS */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_GENERIC_HARDIRQS
++=======
+ static inline int
+ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
+ {
+ 	return 0;
+ }
+ 
+ static inline struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs)
+ {
+ 	*nr_vecs = 1;
+ 	return NULL;
+ }
+ #endif /* CONFIG_SMP */
+ 
++>>>>>>> 5e385a6ef31f (genirq: Add a helper to spread an affinity mask for MSI/MSI-X vectors)
  /*
   * Special lockdep variants of irq disabling/enabling.
   * These should be used for locking constructs that
diff --cc kernel/irq/Makefile
index fff17381f0af,1d3ee3169202..000000000000
--- a/kernel/irq/Makefile
+++ b/kernel/irq/Makefile
@@@ -5,4 -5,8 +5,10 @@@ obj-$(CONFIG_GENERIC_IRQ_PROBE) += auto
  obj-$(CONFIG_IRQ_DOMAIN) += irqdomain.o
  obj-$(CONFIG_PROC_FS) += proc.o
  obj-$(CONFIG_GENERIC_PENDING_IRQ) += migration.o
 -obj-$(CONFIG_GENERIC_IRQ_MIGRATION) += cpuhotplug.o
  obj-$(CONFIG_PM_SLEEP) += pm.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_GENERIC_MSI_IRQ) += msi.o
+ obj-$(CONFIG_GENERIC_IRQ_IPI) += ipi.o
+ obj-$(CONFIG_SMP) += affinity.o
++>>>>>>> 5e385a6ef31f (genirq: Add a helper to spread an affinity mask for MSI/MSI-X vectors)
* Unmerged path include/linux/interrupt.h
* Unmerged path kernel/irq/Makefile
diff --git a/kernel/irq/affinity.c b/kernel/irq/affinity.c
new file mode 100644
index 000000000000..f68959341c0f
--- /dev/null
+++ b/kernel/irq/affinity.c
@@ -0,0 +1,61 @@
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+
+static int get_first_sibling(unsigned int cpu)
+{
+	unsigned int ret;
+
+	ret = cpumask_first(topology_sibling_cpumask(cpu));
+	if (ret < nr_cpu_ids)
+		return ret;
+	return cpu;
+}
+
+/*
+ * Take a map of online CPUs and the number of available interrupt vectors
+ * and generate an output cpumask suitable for spreading MSI/MSI-X vectors
+ * so that they are distributed as good as possible around the CPUs.  If
+ * more vectors than CPUs are available we'll map one to each CPU,
+ * otherwise we map one to the first sibling of each socket.
+ *
+ * If there are more vectors than CPUs we will still only have one bit
+ * set per CPU, but interrupt code will keep on assigning the vectors from
+ * the start of the bitmap until we run out of vectors.
+ */
+struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs)
+{
+	struct cpumask *affinity_mask;
+	unsigned int max_vecs = *nr_vecs;
+
+	if (max_vecs == 1)
+		return NULL;
+
+	affinity_mask = kzalloc(cpumask_size(), GFP_KERNEL);
+	if (!affinity_mask) {
+		*nr_vecs = 1;
+		return NULL;
+	}
+
+	if (max_vecs >= num_online_cpus()) {
+		cpumask_copy(affinity_mask, cpu_online_mask);
+		*nr_vecs = num_online_cpus();
+	} else {
+		unsigned int vecs = 0, cpu;
+
+		for_each_online_cpu(cpu) {
+			if (cpu == get_first_sibling(cpu)) {
+				cpumask_set_cpu(cpu, affinity_mask);
+				vecs++;
+			}
+
+			if (--max_vecs == 0)
+				break;
+		}
+		*nr_vecs = vecs;
+	}
+
+	return affinity_mask;
+}
