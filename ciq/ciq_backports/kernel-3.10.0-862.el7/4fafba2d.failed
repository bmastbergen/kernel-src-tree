drm/i915/gvt: move write protect handler out of mmio emulation function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Zhenyu Wang <zhenyuw@linux.intel.com>
commit 4fafba2d73fcaf1b433c26e753a98ad4b231754a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4fafba2d.failed

It's a bit confusing that page write protect handler is live in
mmio emulation handler. This moves it to stand alone gvt ops.

Also remove unnecessary check of write protected page access
in mmio read handler and cleanup handling of failsafe case.

v2: rebase

	Reviewed-by: Xiong Zhang <xiong.y.zhang@intel.com>
	Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
(cherry picked from commit 4fafba2d73fcaf1b433c26e753a98ad4b231754a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gvt/gvt.c
#	drivers/gpu/drm/i915/gvt/gvt.h
#	drivers/gpu/drm/i915/gvt/mmio.c
diff --cc drivers/gpu/drm/i915/gvt/gvt.c
index 36f440d872f1,fac54f32d33f..000000000000
--- a/drivers/gpu/drm/i915/gvt/gvt.c
+++ b/drivers/gpu/drm/i915/gvt/gvt.c
@@@ -54,6 -179,11 +54,14 @@@ static const struct intel_gvt_ops intel
  	.vgpu_reset = intel_gvt_reset_vgpu,
  	.vgpu_activate = intel_gvt_activate_vgpu,
  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,
++<<<<<<< HEAD
++=======
+ 	.gvt_find_vgpu_type = intel_gvt_find_vgpu_type,
+ 	.get_gvt_attrs = intel_get_gvt_attrs,
+ 	.vgpu_query_plane = intel_vgpu_query_plane,
+ 	.vgpu_get_dmabuf = intel_vgpu_get_dmabuf,
+ 	.write_protect_handler = intel_vgpu_write_protect_handler,
++>>>>>>> 4fafba2d73fc (drm/i915/gvt: move write protect handler out of mmio emulation function)
  };
  
  /**
diff --cc drivers/gpu/drm/i915/gvt/gvt.h
index 083073febd8f,7dc7a80213a8..000000000000
--- a/drivers/gpu/drm/i915/gvt/gvt.h
+++ b/drivers/gpu/drm/i915/gvt/gvt.h
@@@ -459,6 -540,14 +459,17 @@@ struct intel_gvt_ops 
  	void (*vgpu_reset)(struct intel_vgpu *);
  	void (*vgpu_activate)(struct intel_vgpu *);
  	void (*vgpu_deactivate)(struct intel_vgpu *);
++<<<<<<< HEAD
++=======
+ 	struct intel_vgpu_type *(*gvt_find_vgpu_type)(struct intel_gvt *gvt,
+ 			const char *name);
+ 	bool (*get_gvt_attrs)(struct attribute ***type_attrs,
+ 			struct attribute_group ***intel_vgpu_type_groups);
+ 	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);
+ 	int (*vgpu_get_dmabuf)(struct intel_vgpu *vgpu, unsigned int);
+ 	int (*write_protect_handler)(struct intel_vgpu *, u64, void *,
+ 				     unsigned int);
++>>>>>>> 4fafba2d73fc (drm/i915/gvt: move write protect handler out of mmio emulation function)
  };
  
  
diff --cc drivers/gpu/drm/i915/gvt/mmio.c
index 236bdb200bed,562b5ad857a4..000000000000
--- a/drivers/gpu/drm/i915/gvt/mmio.c
+++ b/drivers/gpu/drm/i915/gvt/mmio.c
@@@ -117,25 -117,6 +117,28 @@@ static void failsafe_emulate_mmio_rw(st
  		else
  			memcpy(pt, p_data, bytes);
  
++<<<<<<< HEAD
 +	} else if (atomic_read(&vgpu->gtt.n_write_protected_guest_page)) {
 +		struct intel_vgpu_guest_page *gp;
 +
 +		/* Since we enter the failsafe mode early during guest boot,
 +		 * guest may not have chance to set up its ppgtt table, so
 +		 * there should not be any wp pages for guest. Keep the wp
 +		 * related code here in case we need to handle it in furture.
 +		 */
 +		gp = intel_vgpu_find_guest_page(vgpu, pa >> PAGE_SHIFT);
 +		if (gp) {
 +			/* remove write protection to prevent furture traps */
 +			intel_vgpu_clean_guest_page(vgpu, gp);
 +			if (read)
 +				intel_gvt_hypervisor_read_gpa(vgpu, pa,
 +						p_data, bytes);
 +			else
 +				intel_gvt_hypervisor_write_gpa(vgpu, pa,
 +						p_data, bytes);
 +		}
++=======
++>>>>>>> 4fafba2d73fc (drm/i915/gvt: move write protect handler out of mmio emulation function)
  	}
  	mutex_unlock(&gvt->lock);
  }
@@@ -167,28 -146,9 +170,31 @@@ int intel_vgpu_emulate_mmio_read(struc
  
  	if (vgpu_gpa_is_aperture(vgpu, pa)) {
  		ret = vgpu_aperture_rw(vgpu, pa, p_data, bytes, true);
 -		goto out;
 +		mutex_unlock(&gvt->lock);
 +		return ret;
 +	}
 +
++<<<<<<< HEAD
 +	if (atomic_read(&vgpu->gtt.n_write_protected_guest_page)) {
 +		struct intel_vgpu_guest_page *gp;
 +
 +		gp = intel_vgpu_find_guest_page(vgpu, pa >> PAGE_SHIFT);
 +		if (gp) {
 +			ret = intel_gvt_hypervisor_read_gpa(vgpu, pa,
 +					p_data, bytes);
 +			if (ret) {
 +				gvt_vgpu_err("guest page read error %d, "
 +					"gfn 0x%lx, pa 0x%llx, var 0x%x, len %d\n",
 +					ret, gp->gfn, pa, *(u32 *)p_data,
 +					bytes);
 +			}
 +			mutex_unlock(&gvt->lock);
 +			return ret;
 +		}
  	}
  
++=======
++>>>>>>> 4fafba2d73fc (drm/i915/gvt: move write protect handler out of mmio emulation function)
  	offset = intel_vgpu_gpa_to_mmio_offset(vgpu, pa);
  
  	if (WARN_ON(bytes > 8))
@@@ -290,28 -224,9 +296,31 @@@ int intel_vgpu_emulate_mmio_write(struc
  
  	if (vgpu_gpa_is_aperture(vgpu, pa)) {
  		ret = vgpu_aperture_rw(vgpu, pa, p_data, bytes, false);
 -		goto out;
 +		mutex_unlock(&gvt->lock);
 +		return ret;
  	}
  
++<<<<<<< HEAD
 +	if (atomic_read(&vgpu->gtt.n_write_protected_guest_page)) {
 +		struct intel_vgpu_guest_page *gp;
 +
 +		gp = intel_vgpu_find_guest_page(vgpu, pa >> PAGE_SHIFT);
 +		if (gp) {
 +			ret = gp->handler(gp, pa, p_data, bytes);
 +			if (ret) {
 +				gvt_err("guest page write error %d, "
 +					"gfn 0x%lx, pa 0x%llx, "
 +					"var 0x%x, len %d\n",
 +					ret, gp->gfn, pa,
 +					*(u32 *)p_data, bytes);
 +			}
 +			mutex_unlock(&gvt->lock);
 +			return ret;
 +		}
 +	}
 +
++=======
++>>>>>>> 4fafba2d73fc (drm/i915/gvt: move write protect handler out of mmio emulation function)
  	offset = intel_vgpu_gpa_to_mmio_offset(vgpu, pa);
  
  	if (WARN_ON(bytes > 8))
diff --git a/drivers/gpu/drm/i915/gvt/gtt.c b/drivers/gpu/drm/i915/gvt/gtt.c
index e6c78004a4e2..40a36ee842ee 100644
--- a/drivers/gpu/drm/i915/gvt/gtt.c
+++ b/drivers/gpu/drm/i915/gvt/gtt.c
@@ -1879,6 +1879,39 @@ int intel_vgpu_emulate_gtt_mmio_write(struct intel_vgpu *vgpu, unsigned int off,
 	return ret;
 }
 
+int intel_vgpu_write_protect_handler(struct intel_vgpu *vgpu, u64 pa,
+				     void *p_data, unsigned int bytes)
+{
+	struct intel_gvt *gvt = vgpu->gvt;
+	int ret = 0;
+
+	if (atomic_read(&vgpu->gtt.n_tracked_guest_page)) {
+		struct intel_vgpu_page_track *t;
+
+		mutex_lock(&gvt->lock);
+
+		t = intel_vgpu_find_tracked_page(vgpu, pa >> PAGE_SHIFT);
+		if (t) {
+			if (unlikely(vgpu->failsafe)) {
+				/* remove write protection to prevent furture traps */
+				intel_vgpu_clean_page_track(vgpu, t);
+			} else {
+				ret = t->handler(t, pa, p_data, bytes);
+				if (ret) {
+					gvt_err("guest page write error %d, "
+						"gfn 0x%lx, pa 0x%llx, "
+						"var 0x%x, len %d\n",
+						ret, t->gfn, pa,
+						*(u32 *)p_data, bytes);
+				}
+			}
+		}
+		mutex_unlock(&gvt->lock);
+	}
+	return ret;
+}
+
+
 static int alloc_scratch_pages(struct intel_vgpu *vgpu,
 		intel_gvt_gtt_type_t type)
 {
diff --git a/drivers/gpu/drm/i915/gvt/gtt.h b/drivers/gpu/drm/i915/gvt/gtt.h
index f88eb5e89bea..376b63e8afd7 100644
--- a/drivers/gpu/drm/i915/gvt/gtt.h
+++ b/drivers/gpu/drm/i915/gvt/gtt.h
@@ -308,4 +308,7 @@ int intel_vgpu_emulate_gtt_mmio_read(struct intel_vgpu *vgpu,
 int intel_vgpu_emulate_gtt_mmio_write(struct intel_vgpu *vgpu,
 	unsigned int off, void *p_data, unsigned int bytes);
 
+int intel_vgpu_write_protect_handler(struct intel_vgpu *vgpu, u64 pa,
+				     void *p_data, unsigned int bytes);
+
 #endif /* _GVT_GTT_H_ */
* Unmerged path drivers/gpu/drm/i915/gvt/gvt.c
* Unmerged path drivers/gpu/drm/i915/gvt/gvt.h
diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c b/drivers/gpu/drm/i915/gvt/kvmgt.c
index 53aff91a1e88..0ba3175cdb36 100644
--- a/drivers/gpu/drm/i915/gvt/kvmgt.c
+++ b/drivers/gpu/drm/i915/gvt/kvmgt.c
@@ -1264,8 +1264,8 @@ static void kvmgt_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa,
 					struct kvmgt_guest_info, track_node);
 
 	if (kvmgt_gfn_is_write_protected(info, gpa_to_gfn(gpa)))
-		intel_gvt_ops->emulate_mmio_write(info->vgpu, gpa,
-					(void *)val, len);
+		intel_gvt_ops->write_protect_handler(info->vgpu, gpa,
+						     (void *)val, len);
 }
 
 static void kvmgt_page_track_flush_slot(struct kvm *kvm,
* Unmerged path drivers/gpu/drm/i915/gvt/mmio.c
