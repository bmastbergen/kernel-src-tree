bnxt_en: Optimize doorbell write operations for newer chips.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Optimize doorbell write operations for newer chips (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 99.16%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 434c975a8fe2f70b70ac09ea5ddd008e0528adfa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/434c975a.failed

Older chips require the doorbells to be written twice, but newer chips
do not.  Add a new common function bnxt_db_write() to write all
doorbells appropriately depending on the chip.  Eliminating the extra
doorbell on newer chips has a significant performance improvement
on pktgen.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 434c975a8fe2f70b70ac09ea5ddd008e0528adfa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index b41e6d6e15a2,d7c1295c16cf..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -1689,6 -1770,17 +1688,20 @@@ static int bnxt_poll_work(struct bnxt *
  			break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (event & BNXT_TX_EVENT) {
+ 		struct bnxt_tx_ring_info *txr = bnapi->tx_ring;
+ 		void __iomem *db = txr->tx_doorbell;
+ 		u16 prod = txr->tx_prod;
+ 
+ 		/* Sync BD data before updating doorbell */
+ 		wmb();
+ 
+ 		bnxt_db_write(bp, db, DB_KEY_TX | prod);
+ 	}
+ 
++>>>>>>> 434c975a8fe2 (bnxt_en: Optimize doorbell write operations for newer chips.)
  	cpr->cp_raw_cons = raw_cons;
  	/* ACK completion ring before freeing tx ring and producing new
  	 * buffers in rx/agg rings to prevent overflowing the completion
@@@ -1769,16 -1857,14 +1778,14 @@@ static int bnxt_poll_nitroa0(struct nap
  
  	cpr->cp_raw_cons = raw_cons;
  	BNXT_CP_DB(cpr->cp_doorbell, cpr->cp_raw_cons);
- 	writel(DB_KEY_RX | rxr->rx_prod, rxr->rx_doorbell);
- 	writel(DB_KEY_RX | rxr->rx_prod, rxr->rx_doorbell);
+ 	bnxt_db_write(bp, rxr->rx_doorbell, DB_KEY_RX | rxr->rx_prod);
  
- 	if (event & BNXT_AGG_EVENT) {
- 		writel(DB_KEY_RX | rxr->rx_agg_prod, rxr->rx_agg_doorbell);
- 		writel(DB_KEY_RX | rxr->rx_agg_prod, rxr->rx_agg_doorbell);
- 	}
+ 	if (event & BNXT_AGG_EVENT)
+ 		bnxt_db_write(bp, rxr->rx_agg_doorbell,
+ 			      DB_KEY_RX | rxr->rx_agg_prod);
  
  	if (!bnxt_has_work(bp, cpr) && rx_pkts < budget) {
 -		napi_complete_done(napi, rx_pkts);
 +		napi_complete(napi);
  		BNXT_CP_DB_REARM(cpr->cp_doorbell, cpr->cp_raw_cons);
  	}
  	return rx_pkts;
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index c299c1ab5b3b,5984423499e6..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -993,8 -1018,11 +993,13 @@@ struct bnxt 
  	#define BNXT_FLAG_ROCE_CAP	(BNXT_FLAG_ROCEV1_CAP |	\
  					 BNXT_FLAG_ROCEV2_CAP)
  	#define BNXT_FLAG_NO_AGG_RINGS	0x20000
 -	#define BNXT_FLAG_RX_PAGE_MODE	0x40000
  	#define BNXT_FLAG_FW_LLDP_AGENT	0x80000
  	#define BNXT_FLAG_MULTI_HOST	0x100000
++<<<<<<< HEAD
++=======
+ 	#define BNXT_FLAG_SHORT_CMD	0x200000
+ 	#define BNXT_FLAG_DOUBLE_DB	0x400000
++>>>>>>> 434c975a8fe2 (bnxt_en: Optimize doorbell write operations for newer chips.)
  	#define BNXT_FLAG_CHIP_NITRO_A0	0x1000000
  
  	#define BNXT_FLAG_ALL_CONFIG_FEATS (BNXT_FLAG_TPA |		\
@@@ -1209,7 -1246,31 +1214,33 @@@
  #define SFF_MODULE_ID_QSFP28			0x11
  #define BNXT_MAX_PHY_I2C_RESP_SIZE		64
  
++<<<<<<< HEAD
++=======
+ static inline u32 bnxt_tx_avail(struct bnxt *bp, struct bnxt_tx_ring_info *txr)
+ {
+ 	/* Tell compiler to fetch tx indices from memory. */
+ 	barrier();
+ 
+ 	return bp->tx_ring_size -
+ 		((txr->tx_prod - txr->tx_cons) & bp->tx_ring_mask);
+ }
+ 
+ /* For TX and RX ring doorbells */
+ static inline void bnxt_db_write(struct bnxt *bp, void __iomem *db, u32 val)
+ {
+ 	writel(val, db);
+ 	if (bp->flags & BNXT_FLAG_DOUBLE_DB)
+ 		writel(val, db);
+ }
+ 
+ extern const u16 bnxt_lhint_arr[];
+ 
+ int bnxt_alloc_rx_data(struct bnxt *bp, struct bnxt_rx_ring_info *rxr,
+ 		       u16 prod, gfp_t gfp);
+ void bnxt_reuse_rx_data(struct bnxt_rx_ring_info *rxr, u16 cons, void *data);
+ void bnxt_set_tpa_flags(struct bnxt *bp);
++>>>>>>> 434c975a8fe2 (bnxt_en: Optimize doorbell write operations for newer chips.)
  void bnxt_set_ring_params(struct bnxt *);
 -int bnxt_set_rx_skb_mode(struct bnxt *bp, bool page_mode);
  void bnxt_hwrm_cmd_hdr_init(struct bnxt *, void *, u16, u16, u16);
  int _hwrm_send_message(struct bnxt *, void *, u32, int);
  int hwrm_send_message(struct bnxt *, void *, u32, int);
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 992fa0963964,fd1181510b65..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@@ -2193,6 -2190,363 +2193,366 @@@ static int bnxt_set_phys_id(struct net_
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_hwrm_selftest_irq(struct bnxt *bp, u16 cmpl_ring)
+ {
+ 	struct hwrm_selftest_irq_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_IRQ, cmpl_ring, -1);
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_test_irq(struct bnxt *bp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		u16 cmpl_ring = bp->grp_info[i].cp_fw_ring_id;
+ 		int rc;
+ 
+ 		rc = bnxt_hwrm_selftest_irq(bp, cmpl_ring);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_hwrm_mac_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_mac_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_MAC_CFG, -1, -1);
+ 
+ 	req.enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_LPBK);
+ 	if (enable)
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_LOCAL;
+ 	else
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_NONE;
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_disable_an_for_lpbk(struct bnxt *bp,
+ 				    struct hwrm_port_phy_cfg_input *req)
+ {
+ 	struct bnxt_link_info *link_info = &bp->link_info;
+ 	u16 fw_advertising = link_info->advertising;
+ 	u16 fw_speed;
+ 	int rc;
+ 
+ 	if (!link_info->autoneg)
+ 		return 0;
+ 
+ 	fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_1GB;
+ 	if (netif_carrier_ok(bp->dev))
+ 		fw_speed = bp->link_info.link_speed;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_10GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_10GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_25GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_25GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_40GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_40GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_50GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_50GB;
+ 
+ 	req->force_link_speed = cpu_to_le16(fw_speed);
+ 	req->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_FORCE |
+ 				  PORT_PHY_CFG_REQ_FLAGS_RESET_PHY);
+ 	rc = hwrm_send_message(bp, req, sizeof(*req), HWRM_CMD_TIMEOUT);
+ 	req->flags = 0;
+ 	req->force_link_speed = cpu_to_le16(0);
+ 	return rc;
+ }
+ 
+ static int bnxt_hwrm_phy_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_phy_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_PHY_CFG, -1, -1);
+ 
+ 	if (enable) {
+ 		bnxt_disable_an_for_lpbk(bp, &req);
+ 		req.lpbk = PORT_PHY_CFG_REQ_LPBK_LOCAL;
+ 	} else {
+ 		req.lpbk = PORT_PHY_CFG_REQ_LPBK_NONE;
+ 	}
+ 	req.enables = cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_LPBK);
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_rx_loopback(struct bnxt *bp, struct bnxt_napi *bnapi,
+ 			    u32 raw_cons, int pkt_size)
+ {
+ 	struct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;
+ 	struct bnxt_rx_ring_info *rxr = bnapi->rx_ring;
+ 	struct bnxt_sw_rx_bd *rx_buf;
+ 	struct rx_cmp *rxcmp;
+ 	u16 cp_cons, cons;
+ 	u8 *data;
+ 	u32 len;
+ 	int i;
+ 
+ 	cp_cons = RING_CMP(raw_cons);
+ 	rxcmp = (struct rx_cmp *)
+ 		&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
+ 	cons = rxcmp->rx_cmp_opaque;
+ 	rx_buf = &rxr->rx_buf_ring[cons];
+ 	data = rx_buf->data_ptr;
+ 	len = le32_to_cpu(rxcmp->rx_cmp_len_flags_type) >> RX_CMP_LEN_SHIFT;
+ 	if (len != pkt_size)
+ 		return -EIO;
+ 	i = ETH_ALEN;
+ 	if (!ether_addr_equal(data + i, bnapi->bp->dev->dev_addr))
+ 		return -EIO;
+ 	i += ETH_ALEN;
+ 	for (  ; i < pkt_size; i++) {
+ 		if (data[i] != (u8)(i & 0xff))
+ 			return -EIO;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_poll_loopback(struct bnxt *bp, int pkt_size)
+ {
+ 	struct bnxt_napi *bnapi = bp->bnapi[0];
+ 	struct bnxt_cp_ring_info *cpr;
+ 	struct tx_cmp *txcmp;
+ 	int rc = -EIO;
+ 	u32 raw_cons;
+ 	u32 cons;
+ 	int i;
+ 
+ 	cpr = &bnapi->cp_ring;
+ 	raw_cons = cpr->cp_raw_cons;
+ 	for (i = 0; i < 200; i++) {
+ 		cons = RING_CMP(raw_cons);
+ 		txcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];
+ 
+ 		if (!TX_CMP_VALID(txcmp, raw_cons)) {
+ 			udelay(5);
+ 			continue;
+ 		}
+ 
+ 		/* The valid test of the entry must be done first before
+ 		 * reading any further.
+ 		 */
+ 		dma_rmb();
+ 		if (TX_CMP_TYPE(txcmp) == CMP_TYPE_RX_L2_CMP) {
+ 			rc = bnxt_rx_loopback(bp, bnapi, raw_cons, pkt_size);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			break;
+ 		}
+ 		raw_cons = NEXT_RAW_CMP(raw_cons);
+ 	}
+ 	cpr->cp_raw_cons = raw_cons;
+ 	return rc;
+ }
+ 
+ static int bnxt_run_loopback(struct bnxt *bp)
+ {
+ 	struct bnxt_tx_ring_info *txr = &bp->tx_ring[0];
+ 	int pkt_size, i = 0;
+ 	struct sk_buff *skb;
+ 	dma_addr_t map;
+ 	u8 *data;
+ 	int rc;
+ 
+ 	pkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_copy_thresh);
+ 	skb = netdev_alloc_skb(bp->dev, pkt_size);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 	data = skb_put(skb, pkt_size);
+ 	eth_broadcast_addr(data);
+ 	i += ETH_ALEN;
+ 	ether_addr_copy(&data[i], bp->dev->dev_addr);
+ 	i += ETH_ALEN;
+ 	for ( ; i < pkt_size; i++)
+ 		data[i] = (u8)(i & 0xff);
+ 
+ 	map = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,
+ 			     PCI_DMA_TODEVICE);
+ 	if (dma_mapping_error(&bp->pdev->dev, map)) {
+ 		dev_kfree_skb(skb);
+ 		return -EIO;
+ 	}
+ 	bnxt_xmit_xdp(bp, txr, map, pkt_size, 0);
+ 
+ 	/* Sync BD data before updating doorbell */
+ 	wmb();
+ 
+ 	bnxt_db_write(bp, txr->tx_doorbell, DB_KEY_TX | txr->tx_prod);
+ 	rc = bnxt_poll_loopback(bp, pkt_size);
+ 
+ 	dma_unmap_single(&bp->pdev->dev, map, pkt_size, PCI_DMA_TODEVICE);
+ 	dev_kfree_skb(skb);
+ 	return rc;
+ }
+ 
+ static int bnxt_run_fw_tests(struct bnxt *bp, u8 test_mask, u8 *test_results)
+ {
+ 	struct hwrm_selftest_exec_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_exec_input req = {0};
+ 	int rc;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_EXEC, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	resp->test_success = 0;
+ 	req.flags = test_mask;
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), bp->test_info->timeout);
+ 	*test_results = resp->test_success;
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ 	return rc;
+ }
+ 
+ #define BNXT_DRV_TESTS			3
+ #define BNXT_MACLPBK_TEST_IDX		(bp->num_tests - BNXT_DRV_TESTS)
+ #define BNXT_PHYLPBK_TEST_IDX		(BNXT_MACLPBK_TEST_IDX + 1)
+ #define BNXT_IRQ_TEST_IDX		(BNXT_MACLPBK_TEST_IDX + 2)
+ 
+ static void bnxt_self_test(struct net_device *dev, struct ethtool_test *etest,
+ 			   u64 *buf)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	bool offline = false;
+ 	u8 test_results = 0;
+ 	u8 test_mask = 0;
+ 	int rc, i;
+ 
+ 	if (!bp->num_tests || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 	memset(buf, 0, sizeof(u64) * bp->num_tests);
+ 	if (!netif_running(dev)) {
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 		return;
+ 	}
+ 
+ 	if (etest->flags & ETH_TEST_FL_OFFLINE) {
+ 		if (bp->pf.active_vfs) {
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			netdev_warn(dev, "Offline tests cannot be run with active VFs\n");
+ 			return;
+ 		}
+ 		offline = true;
+ 	}
+ 
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if (!(bp->test_info->offline_mask & bit_val))
+ 			test_mask |= bit_val;
+ 		else if (offline)
+ 			test_mask |= bit_val;
+ 	}
+ 	if (!offline) {
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 	} else {
+ 		rc = bnxt_close_nic(bp, false, false);
+ 		if (rc)
+ 			return;
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 
+ 		buf[BNXT_MACLPBK_TEST_IDX] = 1;
+ 		bnxt_hwrm_mac_loopback(bp, true);
+ 		msleep(250);
+ 		rc = bnxt_half_open_nic(bp);
+ 		if (rc) {
+ 			bnxt_hwrm_mac_loopback(bp, false);
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			return;
+ 		}
+ 		if (bnxt_run_loopback(bp))
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		else
+ 			buf[BNXT_MACLPBK_TEST_IDX] = 0;
+ 
+ 		bnxt_hwrm_mac_loopback(bp, false);
+ 		bnxt_hwrm_phy_loopback(bp, true);
+ 		msleep(1000);
+ 		if (bnxt_run_loopback(bp)) {
+ 			buf[BNXT_PHYLPBK_TEST_IDX] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 		bnxt_hwrm_phy_loopback(bp, false);
+ 		bnxt_half_close_nic(bp);
+ 		bnxt_open_nic(bp, false, true);
+ 	}
+ 	if (bnxt_test_irq(bp)) {
+ 		buf[BNXT_IRQ_TEST_IDX] = 1;
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 	}
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if ((test_mask & bit_val) && !(test_results & bit_val)) {
+ 			buf[i] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 	}
+ }
+ 
+ void bnxt_ethtool_init(struct bnxt *bp)
+ {
+ 	struct hwrm_selftest_qlist_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_qlist_input req = {0};
+ 	struct bnxt_test_info *test_info;
+ 	int i, rc;
+ 
+ 	if (bp->hwrm_spec_code < 0x10704 || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_QLIST, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		goto ethtool_init_exit;
+ 
+ 	test_info = kzalloc(sizeof(*bp->test_info), GFP_KERNEL);
+ 	if (!test_info)
+ 		goto ethtool_init_exit;
+ 
+ 	bp->test_info = test_info;
+ 	bp->num_tests = resp->num_tests + BNXT_DRV_TESTS;
+ 	if (bp->num_tests > BNXT_MAX_TEST)
+ 		bp->num_tests = BNXT_MAX_TEST;
+ 
+ 	test_info->offline_mask = resp->offline_tests;
+ 	test_info->timeout = le16_to_cpu(resp->test_timeout);
+ 	if (!test_info->timeout)
+ 		test_info->timeout = HWRM_CMD_TIMEOUT;
+ 	for (i = 0; i < bp->num_tests; i++) {
+ 		char *str = test_info->string[i];
+ 		char *fw_str = resp->test0_name + i * 32;
+ 
+ 		if (i == BNXT_MACLPBK_TEST_IDX) {
+ 			strcpy(str, "Mac loopback test (offline)");
+ 		} else if (i == BNXT_PHYLPBK_TEST_IDX) {
+ 			strcpy(str, "Phy loopback test (offline)");
+ 		} else if (i == BNXT_IRQ_TEST_IDX) {
+ 			strcpy(str, "Interrupt_test (offline)");
+ 		} else {
+ 			strlcpy(str, fw_str, ETH_GSTRING_LEN);
+ 			strncat(str, " test", ETH_GSTRING_LEN - strlen(str));
+ 			if (test_info->offline_mask & (1 << i))
+ 				strncat(str, " (offline)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 			else
+ 				strncat(str, " (online)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 		}
+ 	}
+ 
+ ethtool_init_exit:
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ }
+ 
+ void bnxt_ethtool_free(struct bnxt *bp)
+ {
+ 	kfree(bp->test_info);
+ 	bp->test_info = NULL;
+ }
+ 
++>>>>>>> 434c975a8fe2 (bnxt_en: Optimize doorbell write operations for newer chips.)
  const struct ethtool_ops bnxt_ethtool_ops = {
  	.get_link_ksettings	= bnxt_get_link_ksettings,
  	.set_link_ksettings	= bnxt_set_link_ksettings,
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
