net/mlx5: Delay events till ib registration ends

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Delay events till ib registration ends (Kamal Heib) [1456694]
Rebuild_FUZZ: 95.65%
commit-author Erez Shitrit <erezsh@mellanox.com>
commit 97834eba7c194659a72c5bb0f8c19c7055bb69ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/97834eba.failed

When mlx5_ib registers itself to mlx5_core as an interface, it will
call mlx5_add_device which will call mlx5_ib interface add callback,
in case the latter successfully returns, only then mlx5_core will add
it to the interface list and async events will be forwarded to mlx5_ib.
Between mlx5_ib interface add callback and mlx5_core adding the mlx5_ib
interface to its devices list, arriving mlx5_core events can be missed
by the new mlx5_ib registering interface.

In other words:
thread 1: mlx5_ib: mlx5_register_interface(dev)
thread 1: mlx5_core: mlx5_add_device(dev)
thread 1: mlx5_core: ctx = dev->add => (mlx5_ib)->mlx5_ib_add
thread 2: mlx5_core_event: **new event arrives, forward to dev_list
thread 1: mlx5_core: add_ctx_to_dev_list(ctx)
/* previous event was missed by the new interface.*/
It is ok to miss events before dev->add (mlx5_ib)->mlx5_ib_add_device
but not after.

We fix this race by accumulating the events that come between the
ib_register_device (inside mlx5_add_device->(dev->add)) till the adding
to the list completes and fire them to the new registering interface
after that.

Fixes: f1ee87fe55c8 ("net/mlx5: Organize device list API in one place")
	Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 97834eba7c194659a72c5bb0f8c19c7055bb69ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/dev.c
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/dev.c
index a9dbc28f6b97,ff60cf7342ca..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/dev.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/dev.c
@@@ -71,6 -136,19 +136,22 @@@ void mlx5_add_device(struct mlx5_interf
  	if (dev_ctx->context) {
  		spin_lock_irq(&priv->ctx_lock);
  		list_add_tail(&dev_ctx->list, &priv->ctx_list);
++<<<<<<< HEAD
++=======
+ 
+ 		fire_delayed_event_locked(dev_ctx, dev, priv);
+ 
+ #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
+ 		if (dev_ctx->intf->pfault) {
+ 			if (priv->pfault) {
+ 				mlx5_core_err(dev, "multiple page fault handlers not supported");
+ 			} else {
+ 				priv->pfault_ctx = dev_ctx->context;
+ 				priv->pfault = dev_ctx->intf->pfault;
+ 			}
+ 		}
+ #endif
++>>>>>>> 97834eba7c19 (net/mlx5: Delay events till ib registration ends)
  		spin_unlock_irq(&priv->ctx_lock);
  	} else {
  		kfree(dev_ctx);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index 83ed808b199e,6dbd637b4e66..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1299,6 -1342,23 +1299,26 @@@ static int init_one(struct pci_dev *pde
  	spin_lock_init(&priv->ctx_lock);
  	mutex_init(&dev->pci_status_mutex);
  	mutex_init(&dev->intf_state_mutex);
++<<<<<<< HEAD
++=======
+ 
+ 	INIT_LIST_HEAD(&priv->waiting_events_list);
+ 	priv->is_accum_events = false;
+ 
+ #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
+ 	err = init_srcu_struct(&priv->pfault_srcu);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "init_srcu_struct failed with error code %d\n",
+ 			err);
+ 		goto clean_dev;
+ 	}
+ #endif
+ 	mutex_init(&priv->bfregs.reg_head.lock);
+ 	mutex_init(&priv->bfregs.wc_head.lock);
+ 	INIT_LIST_HEAD(&priv->bfregs.reg_head.list);
+ 	INIT_LIST_HEAD(&priv->bfregs.wc_head.list);
+ 
++>>>>>>> 97834eba7c19 (net/mlx5: Delay events till ib registration ends)
  	err = mlx5_pci_init(dev, priv);
  	if (err) {
  		dev_err(&pdev->dev, "mlx5_pci_init failed with error code %d\n", err);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/dev.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 031f38b662df..be2732489b99 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -615,6 +615,9 @@ struct mlx5_priv {
 	struct list_head        ctx_list;
 	spinlock_t              ctx_lock;
 
+	struct list_head	waiting_events_list;
+	bool			is_accum_events;
+
 	struct mlx5_flow_steering *steering;
 	struct mlx5_eswitch     *eswitch;
 	struct mlx5_core_sriov	sriov;
