x86/intel_rdt/cqm: Add cpus file support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt/cqm: Add cpus file support (Jiri Olsa) [1457533]
Rebuild_FUZZ: 94.74%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit a9fcf8627dc01049c390023bbb0323db3c785b91
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a9fcf862.failed

The cpus file is extended to support resource monitoring. This is used
to over-ride the RMID of the default group when running on specific
CPUs. It works similar to the resource control. The "cpus" and
"cpus_list" file is present in default group, ctrl_mon groups and
monitor groups.

Each "cpus" file or cpu_list file reads a cpumask or list showing which
CPUs belong to the resource group. By default all online cpus belong to
the default root group. A CPU can be present in one "ctrl_mon" and one
"monitor" group simultaneously. They can be added to a resource group by
writing the CPU to the file. When a CPU is added to a ctrl_mon group it
is automatically removed from the previous ctrl_mon group. A CPU can be
added to a monitor group only if it is present in the parent ctrl_mon
group and when a CPU is added to a monitor group, it is automatically
removed from the previous monitor group. When CPUs go offline, they are
automatically removed from the ctrl_mon and monitor groups.

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: peterz@infradead.org
	Cc: eranian@google.com
	Cc: vikas.shivappa@intel.com
	Cc: ak@linux.intel.com
	Cc: davidcc@google.com
	Cc: reinette.chatre@intel.com
Link: http://lkml.kernel.org/r/1501017287-28083-18-git-send-email-vikas.shivappa@linux.intel.com

(cherry picked from commit a9fcf8627dc01049c390023bbb0323db3c785b91)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1c3603d97e9d,89457bba457a..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -202,13 -181,18 +202,28 @@@ static int rdtgroup_cpus_show(struct ke
  /*
   * This is safe against intel_rdt_sched_in() called from __switch_to()
   * because __switch_to() is executed with interrupts disabled. A local call
++<<<<<<< HEAD
 + * from rdt_update_closid() is proteced against __switch_to() because
 + * preemption is disabled.
 + */
 +static void rdt_update_cpu_closid(void *closid)
 +{
 +	if (closid)
 +		this_cpu_write(cpu_closid, *(int *)closid);
++=======
+  * from update_closid_rmid() is proteced against __switch_to() because
+  * preemption is disabled.
+  */
+ static void update_cpu_closid_rmid(void *info)
+ {
+ 	struct rdtgroup *r = info;
+ 
+ 	if (r) {
+ 		this_cpu_write(rdt_cpu_default.closid, r->closid);
+ 		this_cpu_write(rdt_cpu_default.rmid, r->mon.rmid);
+ 	}
+ 
++>>>>>>> a9fcf8627dc0 (x86/intel_rdt/cqm: Add cpus file support)
  	/*
  	 * We cannot unconditionally write the MSR because the current
  	 * executing task might have its own closid selected. Just reuse
@@@ -220,28 -204,128 +235,149 @@@
  /*
   * Update the PGR_ASSOC MSR on all cpus in @cpu_mask,
   *
 - * Per task closids/rmids must have been set up before calling this function.
 + * Per task closids must have been set up before calling this function.
 + *
 + * The per cpu closids are updated with the smp function call, when @closid
 + * is not NULL. If @closid is NULL then all affected percpu closids must
 + * have been set up before calling this function.
   */
  static void
++<<<<<<< HEAD
 +rdt_update_closid(const struct cpumask *cpu_mask, int *closid)
++=======
+ update_closid_rmid(const struct cpumask *cpu_mask, struct rdtgroup *r)
++>>>>>>> a9fcf8627dc0 (x86/intel_rdt/cqm: Add cpus file support)
  {
  	int cpu = get_cpu();
  
  	if (cpumask_test_cpu(cpu, cpu_mask))
++<<<<<<< HEAD
 +		rdt_update_cpu_closid(closid);
 +	smp_call_function_many(cpu_mask, rdt_update_cpu_closid, closid, 1);
 +	put_cpu();
 +}
 +
 +static ssize_t rdtgroup_cpus_write(struct kernfs_open_file *of,
 +				   char *buf, size_t nbytes, loff_t off)
 +{
 +	cpumask_var_t tmpmask, newmask;
 +	struct rdtgroup *rdtgrp, *r;
++=======
+ 		update_cpu_closid_rmid(r);
+ 	smp_call_function_many(cpu_mask, update_cpu_closid_rmid, r, 1);
+ 	put_cpu();
+ }
+ 
+ static int cpus_mon_write(struct rdtgroup *rdtgrp, cpumask_var_t newmask,
+ 			  cpumask_var_t tmpmask)
+ {
+ 	struct rdtgroup *prgrp = rdtgrp->mon.parent, *crgrp;
+ 	struct list_head *head;
+ 
+ 	/* Check whether cpus belong to parent ctrl group */
+ 	cpumask_andnot(tmpmask, newmask, &prgrp->cpu_mask);
+ 	if (cpumask_weight(tmpmask))
+ 		return -EINVAL;
+ 
+ 	/* Check whether cpus are dropped from this group */
+ 	cpumask_andnot(tmpmask, &rdtgrp->cpu_mask, newmask);
+ 	if (cpumask_weight(tmpmask)) {
+ 		/* Give any dropped cpus to parent rdtgroup */
+ 		cpumask_or(&prgrp->cpu_mask, &prgrp->cpu_mask, tmpmask);
+ 		update_closid_rmid(tmpmask, prgrp);
+ 	}
+ 
+ 	/*
+ 	 * If we added cpus, remove them from previous group that owned them
+ 	 * and update per-cpu rmid
+ 	 */
+ 	cpumask_andnot(tmpmask, newmask, &rdtgrp->cpu_mask);
+ 	if (cpumask_weight(tmpmask)) {
+ 		head = &prgrp->mon.crdtgrp_list;
+ 		list_for_each_entry(crgrp, head, mon.crdtgrp_list) {
+ 			if (crgrp == rdtgrp)
+ 				continue;
+ 			cpumask_andnot(&crgrp->cpu_mask, &crgrp->cpu_mask,
+ 				       tmpmask);
+ 		}
+ 		update_closid_rmid(tmpmask, rdtgrp);
+ 	}
+ 
+ 	/* Done pushing/pulling - update this group with new mask */
+ 	cpumask_copy(&rdtgrp->cpu_mask, newmask);
+ 
+ 	return 0;
+ }
+ 
+ static void cpumask_rdtgrp_clear(struct rdtgroup *r, struct cpumask *m)
+ {
+ 	struct rdtgroup *crgrp;
+ 
+ 	cpumask_andnot(&r->cpu_mask, &r->cpu_mask, m);
+ 	/* update the child mon group masks as well*/
+ 	list_for_each_entry(crgrp, &r->mon.crdtgrp_list, mon.crdtgrp_list)
+ 		cpumask_and(&crgrp->cpu_mask, &r->cpu_mask, &crgrp->cpu_mask);
+ }
+ 
+ static int cpus_ctrl_write(struct rdtgroup *rdtgrp, cpumask_var_t newmask,
+ 			   cpumask_var_t tmpmask, cpumask_var_t tmpmask1)
+ {
+ 	struct rdtgroup *r, *crgrp;
+ 	struct list_head *head;
+ 
+ 	/* Check whether cpus are dropped from this group */
+ 	cpumask_andnot(tmpmask, &rdtgrp->cpu_mask, newmask);
+ 	if (cpumask_weight(tmpmask)) {
+ 		/* Can't drop from default group */
+ 		if (rdtgrp == &rdtgroup_default)
+ 			return -EINVAL;
+ 
+ 		/* Give any dropped cpus to rdtgroup_default */
+ 		cpumask_or(&rdtgroup_default.cpu_mask,
+ 			   &rdtgroup_default.cpu_mask, tmpmask);
+ 		update_closid_rmid(tmpmask, &rdtgroup_default);
+ 	}
+ 
+ 	/*
+ 	 * If we added cpus, remove them from previous group and
+ 	 * the prev group's child groups that owned them
+ 	 * and update per-cpu closid/rmid.
+ 	 */
+ 	cpumask_andnot(tmpmask, newmask, &rdtgrp->cpu_mask);
+ 	if (cpumask_weight(tmpmask)) {
+ 		list_for_each_entry(r, &rdt_all_groups, rdtgroup_list) {
+ 			if (r == rdtgrp)
+ 				continue;
+ 			cpumask_and(tmpmask1, &r->cpu_mask, tmpmask);
+ 			if (cpumask_weight(tmpmask1))
+ 				cpumask_rdtgrp_clear(r, tmpmask1);
+ 		}
+ 		update_closid_rmid(tmpmask, rdtgrp);
+ 	}
+ 
+ 	/* Done pushing/pulling - update this group with new mask */
+ 	cpumask_copy(&rdtgrp->cpu_mask, newmask);
+ 
+ 	/*
+ 	 * Clear child mon group masks since there is a new parent mask
+ 	 * now and update the rmid for the cpus the child lost.
+ 	 */
+ 	head = &rdtgrp->mon.crdtgrp_list;
+ 	list_for_each_entry(crgrp, head, mon.crdtgrp_list) {
+ 		cpumask_and(tmpmask, &rdtgrp->cpu_mask, &crgrp->cpu_mask);
+ 		update_closid_rmid(tmpmask, rdtgrp);
+ 		cpumask_clear(&crgrp->cpu_mask);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t rdtgroup_cpus_write(struct kernfs_open_file *of,
+ 				   char *buf, size_t nbytes, loff_t off)
+ {
+ 	cpumask_var_t tmpmask, newmask, tmpmask1;
+ 	struct rdtgroup *rdtgrp;
++>>>>>>> a9fcf8627dc0 (x86/intel_rdt/cqm: Add cpus file support)
  	int ret;
  
  	if (!buf)
@@@ -275,36 -364,12 +416,45 @@@
  		goto unlock;
  	}
  
++<<<<<<< HEAD
 +	/* Check whether cpus are dropped from this group */
 +	cpumask_andnot(tmpmask, &rdtgrp->cpu_mask, newmask);
 +	if (cpumask_weight(tmpmask)) {
 +		/* Can't drop from default group */
 +		if (rdtgrp == &rdtgroup_default) {
 +			ret = -EINVAL;
 +			goto unlock;
 +		}
 +		/* Give any dropped cpus to rdtgroup_default */
 +		cpumask_or(&rdtgroup_default.cpu_mask,
 +			   &rdtgroup_default.cpu_mask, tmpmask);
 +		rdt_update_closid(tmpmask, &rdtgroup_default.closid);
 +	}
 +
 +	/*
 +	 * If we added cpus, remove them from previous group that owned them
 +	 * and update per-cpu closid
 +	 */
 +	cpumask_andnot(tmpmask, newmask, &rdtgrp->cpu_mask);
 +	if (cpumask_weight(tmpmask)) {
 +		list_for_each_entry(r, &rdt_all_groups, rdtgroup_list) {
 +			if (r == rdtgrp)
 +				continue;
 +			cpumask_andnot(&r->cpu_mask, &r->cpu_mask, tmpmask);
 +		}
 +		rdt_update_closid(tmpmask, &rdtgrp->closid);
 +	}
 +
 +	/* Done pushing/pulling - update this group with new mask */
 +	cpumask_copy(&rdtgrp->cpu_mask, newmask);
++=======
+ 	if (rdtgrp->type == RDTCTRL_GROUP)
+ 		ret = cpus_ctrl_write(rdtgrp, newmask, tmpmask, tmpmask1);
+ 	else if (rdtgrp->type == RDTMON_GROUP)
+ 		ret = cpus_mon_write(rdtgrp, newmask, tmpmask);
+ 	else
+ 		ret = -EINVAL;
++>>>>>>> a9fcf8627dc0 (x86/intel_rdt/cqm: Add cpus file support)
  
  unlock:
  	rdtgroup_kn_unlock(of->kn);
@@@ -904,7 -1189,7 +1055,11 @@@ static void rmdir_all_sub(void
  	}
  	/* Notify online CPUs to update per cpu storage and PQR_ASSOC MSR */
  	get_online_cpus();
++<<<<<<< HEAD
 +	rdt_update_closid(cpu_online_mask, &rdtgroup_default.closid);
++=======
+ 	update_closid_rmid(cpu_online_mask, &rdtgroup_default);
++>>>>>>> a9fcf8627dc0 (x86/intel_rdt/cqm: Add cpus file support)
  	put_online_cpus();
  
  	kernfs_remove(kn_info);
@@@ -1039,7 -1450,7 +1194,11 @@@ static int rdtgroup_rmdir(struct kernfs
  	 * task running on them.
  	 */
  	cpumask_or(tmpmask, tmpmask, &rdtgrp->cpu_mask);
++<<<<<<< HEAD
 +	rdt_update_closid(tmpmask, NULL);
++=======
+ 	update_closid_rmid(tmpmask, NULL);
++>>>>>>> a9fcf8627dc0 (x86/intel_rdt/cqm: Add cpus file support)
  
  	rdtgrp->flags = RDT_DELETED;
  	closid_free(rdtgrp->closid);
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
