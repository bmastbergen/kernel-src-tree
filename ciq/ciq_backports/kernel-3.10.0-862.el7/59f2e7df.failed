dma-debug: fix overlap detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 59f2e7df574c78e952d79435de3f4867349403aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/59f2e7df.failed

Commit 0abdd7a81b7e ("dma-debug: introduce debug_dma_assert_idle()") was
reworked to expand the overlap counter to the full range expressable by
3 tag bits, but it has a thinko in treating the overlap counter as a
pure reference count for the entry.

Instead of deleting when the reference-count drops to zero, we need to
delete when the overlap-count drops below zero.  Also, when detecting
overflow we can just test the overlap-count > MAX rather than applying
special meaning to 0.

Regression report available here:
http://marc.info/?l=linux-netdev&m=139073373932386&w=2

This patch, now tested on the original net_dma case, sees the expected
handful of reports before the eventual data corruption occurs.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Reported-by: Sander Eikelenboom <linux@eikelenboom.it>
	Cc: Francois Romieu <romieu@fr.zoreil.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 59f2e7df574c78e952d79435de3f4867349403aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/dma-debug.c
diff --cc lib/dma-debug.c
index d87a17a819d0,2defd1308b04..000000000000
--- a/lib/dma-debug.c
+++ b/lib/dma-debug.c
@@@ -404,6 -424,137 +404,140 @@@ void debug_dma_dump_mappings(struct dev
  EXPORT_SYMBOL(debug_dma_dump_mappings);
  
  /*
++<<<<<<< HEAD
++=======
+  * For each page mapped (initial page in the case of
+  * dma_alloc_coherent/dma_map_{single|page}, or each page in a
+  * scatterlist) insert into this tree using the pfn as the key. At
+  * dma_unmap_{single|sg|page} or dma_free_coherent delete the entry.  If
+  * the pfn already exists at insertion time add a tag as a reference
+  * count for the overlapping mappings.  For now, the overlap tracking
+  * just ensures that 'unmaps' balance 'maps' before marking the pfn
+  * idle, but we should also be flagging overlaps as an API violation.
+  *
+  * Memory usage is mostly constrained by the maximum number of available
+  * dma-debug entries in that we need a free dma_debug_entry before
+  * inserting into the tree.  In the case of dma_map_{single|page} and
+  * dma_alloc_coherent there is only one dma_debug_entry and one pfn to
+  * track per event.  dma_map_sg(), on the other hand,
+  * consumes a single dma_debug_entry, but inserts 'nents' entries into
+  * the tree.
+  *
+  * At any time debug_dma_assert_idle() can be called to trigger a
+  * warning if the given page is in the active set.
+  */
+ static RADIX_TREE(dma_active_pfn, GFP_NOWAIT);
+ static DEFINE_SPINLOCK(radix_lock);
+ #define ACTIVE_PFN_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)
+ 
+ static int active_pfn_read_overlap(unsigned long pfn)
+ {
+ 	int overlap = 0, i;
+ 
+ 	for (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)
+ 		if (radix_tree_tag_get(&dma_active_pfn, pfn, i))
+ 			overlap |= 1 << i;
+ 	return overlap;
+ }
+ 
+ static int active_pfn_set_overlap(unsigned long pfn, int overlap)
+ {
+ 	int i;
+ 
+ 	if (overlap > ACTIVE_PFN_MAX_OVERLAP || overlap < 0)
+ 		return overlap;
+ 
+ 	for (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)
+ 		if (overlap & 1 << i)
+ 			radix_tree_tag_set(&dma_active_pfn, pfn, i);
+ 		else
+ 			radix_tree_tag_clear(&dma_active_pfn, pfn, i);
+ 
+ 	return overlap;
+ }
+ 
+ static void active_pfn_inc_overlap(unsigned long pfn)
+ {
+ 	int overlap = active_pfn_read_overlap(pfn);
+ 
+ 	overlap = active_pfn_set_overlap(pfn, ++overlap);
+ 
+ 	/* If we overflowed the overlap counter then we're potentially
+ 	 * leaking dma-mappings.  Otherwise, if maps and unmaps are
+ 	 * balanced then this overflow may cause false negatives in
+ 	 * debug_dma_assert_idle() as the pfn may be marked idle
+ 	 * prematurely.
+ 	 */
+ 	WARN_ONCE(overlap > ACTIVE_PFN_MAX_OVERLAP,
+ 		  "DMA-API: exceeded %d overlapping mappings of pfn %lx\n",
+ 		  ACTIVE_PFN_MAX_OVERLAP, pfn);
+ }
+ 
+ static int active_pfn_dec_overlap(unsigned long pfn)
+ {
+ 	int overlap = active_pfn_read_overlap(pfn);
+ 
+ 	return active_pfn_set_overlap(pfn, --overlap);
+ }
+ 
+ static int active_pfn_insert(struct dma_debug_entry *entry)
+ {
+ 	unsigned long flags;
+ 	int rc;
+ 
+ 	spin_lock_irqsave(&radix_lock, flags);
+ 	rc = radix_tree_insert(&dma_active_pfn, entry->pfn, entry);
+ 	if (rc == -EEXIST)
+ 		active_pfn_inc_overlap(entry->pfn);
+ 	spin_unlock_irqrestore(&radix_lock, flags);
+ 
+ 	return rc;
+ }
+ 
+ static void active_pfn_remove(struct dma_debug_entry *entry)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&radix_lock, flags);
+ 	/* since we are counting overlaps the final put of the
+ 	 * entry->pfn will occur when the overlap count is 0.
+ 	 * active_pfn_dec_overlap() returns -1 in that case
+ 	 */
+ 	if (active_pfn_dec_overlap(entry->pfn) < 0)
+ 		radix_tree_delete(&dma_active_pfn, entry->pfn);
+ 	spin_unlock_irqrestore(&radix_lock, flags);
+ }
+ 
+ /**
+  * debug_dma_assert_idle() - assert that a page is not undergoing dma
+  * @page: page to lookup in the dma_active_pfn tree
+  *
+  * Place a call to this routine in cases where the cpu touching the page
+  * before the dma completes (page is dma_unmapped) will lead to data
+  * corruption.
+  */
+ void debug_dma_assert_idle(struct page *page)
+ {
+ 	unsigned long flags;
+ 	struct dma_debug_entry *entry;
+ 
+ 	if (!page)
+ 		return;
+ 
+ 	spin_lock_irqsave(&radix_lock, flags);
+ 	entry = radix_tree_lookup(&dma_active_pfn, page_to_pfn(page));
+ 	spin_unlock_irqrestore(&radix_lock, flags);
+ 
+ 	if (!entry)
+ 		return;
+ 
+ 	err_printk(entry->dev, entry,
+ 		   "DMA-API: cpu touching an active dma mapped page "
+ 		   "[pfn=0x%lx]\n", entry->pfn);
+ }
+ 
+ /*
++>>>>>>> 59f2e7df574c (dma-debug: fix overlap detection)
   * Wrapper function for adding an entry to the hash.
   * This function takes care of locking itself.
   */
* Unmerged path lib/dma-debug.c
