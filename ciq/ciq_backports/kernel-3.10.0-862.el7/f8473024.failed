nfp: add helper for mapping runtime symbols

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit f84730240735b15f725ce59d66a663de82650b46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f8473024.failed

Move most of the helper for mapping RTsyms from nfp_net_main.c
to nfpcore.  Use the new helper directly for mapping MAC statistics,
since they don't need to include the PCIe interface ID in the symbol
name.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f84730240735b15f725ce59d66a663de82650b46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,93d6ea183956..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -207,77 -159,44 +207,92 @@@ static unsigned int nfp_net_pf_get_num_
  	return val;
  }
  
 -static int nfp_net_pf_get_num_ports(struct nfp_pf *pf)
 +static unsigned int
 +nfp_net_pf_total_qcs(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +		     unsigned int stride, u32 start_off, u32 num_off)
  {
 -	return nfp_net_pf_rtsym_read_optional(pf, "nfd_cfg_pf%u_num_ports", 1);
 +	unsigned int i, min_qc, max_qc;
 +
 +	min_qc = readl(ctrl_bar + start_off);
 +	max_qc = min_qc;
 +
 +	for (i = 0; i < pf->num_ports; i++) {
 +		/* To make our lives simpler only accept configuration where
 +		 * queues are allocated to PFs in order (queues of PFn all have
 +		 * indexes lower than PFn+1).
 +		 */
 +		if (max_qc > readl(ctrl_bar + start_off))
 +			return 0;
 +
 +		max_qc = readl(ctrl_bar + start_off);
 +		max_qc += readl(ctrl_bar + num_off) * stride;
 +		ctrl_bar += NFP_PF_CSR_SLICE_SIZE;
 +	}
 +
 +	return max_qc - min_qc;
  }
  
 -static int nfp_net_pf_get_app_id(struct nfp_pf *pf)
 +static u8 __iomem *nfp_net_pf_map_ctrl_bar(struct nfp_pf *pf)
  {
++<<<<<<< HEAD
 +	const struct nfp_rtsym *ctrl_sym;
 +	u8 __iomem *ctrl_bar;
++=======
+ 	return nfp_net_pf_rtsym_read_optional(pf, "_pf%u_net_app_id",
+ 					      NFP_APP_CORE_NIC);
+ }
+ 
+ static u8 __iomem *
+ nfp_net_pf_map_rtsym(struct nfp_pf *pf, const char *name, const char *sym_fmt,
+ 		     unsigned int min_size, struct nfp_cpp_area **area)
+ {
++>>>>>>> f84730240735 (nfp: add helper for mapping runtime symbols)
  	char pf_symbol[256];
  
 -	snprintf(pf_symbol, sizeof(pf_symbol), sym_fmt,
 +	snprintf(pf_symbol, sizeof(pf_symbol), "_pf%u_net_bar0",
  		 nfp_cppcore_pcie_unit(pf->cpp));
  
++<<<<<<< HEAD
 +	ctrl_sym = nfp_rtsym_lookup(pf->cpp, pf_symbol);
 +	if (!ctrl_sym) {
 +		dev_err(&pf->pdev->dev,
 +			"Failed to find PF BAR0 symbol %s\n", pf_symbol);
 +		return NULL;
 +	}
 +
 +	if (ctrl_sym->size < pf->num_ports * NFP_PF_CSR_SLICE_SIZE) {
 +		dev_err(&pf->pdev->dev,
 +			"PF BAR0 too small to contain %d ports\n",
 +			pf->num_ports);
 +		return NULL;
 +	}
 +
 +	ctrl_bar = nfp_net_map_area(pf->cpp, "net.ctrl",
 +				    ctrl_sym->domain, ctrl_sym->target,
 +				    ctrl_sym->addr, ctrl_sym->size,
 +				    &pf->ctrl_area);
 +	if (IS_ERR(ctrl_bar)) {
 +		dev_err(&pf->pdev->dev, "Failed to map PF BAR0: %ld\n",
 +			PTR_ERR(ctrl_bar));
 +		return NULL;
 +	}
 +
 +	return ctrl_bar;
++=======
+ 	return nfp_rtsym_map(pf->rtbl, pf_symbol, name, min_size, area);
++>>>>>>> f84730240735 (nfp: add helper for mapping runtime symbols)
  }
  
 -static void nfp_net_pf_free_vnic(struct nfp_pf *pf, struct nfp_net *nn)
 +static void nfp_net_pf_free_netdevs(struct nfp_pf *pf)
  {
 -	nfp_port_free(nn->port);
 -	list_del(&nn->vnic_list);
 -	pf->num_vnics--;
 -	nfp_net_free(nn);
 -}
 +	struct nfp_net *nn;
  
 -static void nfp_net_pf_free_vnics(struct nfp_pf *pf)
 -{
 -	struct nfp_net *nn, *next;
 +	while (!list_empty(&pf->ports)) {
 +		nn = list_first_entry(&pf->ports, struct nfp_net, port_list);
 +		list_del(&nn->port_list);
  
 -	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_free_vnic(pf, nn);
 +		nfp_net_netdev_free(nn);
 +	}
  }
  
  static struct nfp_net *
@@@ -435,15 -385,185 +450,166 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  	return 0;
  
  err_prev_deinit:
 -	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_clean_vnic(pf, nn);
 -	return err;
 -}
 -
 -static int
 -nfp_net_pf_app_init(struct nfp_pf *pf, u8 __iomem *qc_bar, unsigned int stride)
 -{
 -	u8 __iomem *ctrl_bar;
 -	int err;
 -
 -	pf->app = nfp_app_alloc(pf, nfp_net_pf_get_app_id(pf));
 -	if (IS_ERR(pf->app))
 -		return PTR_ERR(pf->app);
 -
 -	err = nfp_app_init(pf->app);
 -	if (err)
 -		goto err_free;
 -
 -	if (!nfp_app_needs_ctrl_vnic(pf->app))
 -		return 0;
 -
 -	ctrl_bar = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%u_net_ctrl_bar",
 -					NFP_PF_CSR_SLICE_SIZE,
 -					&pf->ctrl_vnic_bar);
 -	if (IS_ERR(ctrl_bar)) {
 -		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
 -		err = PTR_ERR(ctrl_bar);
 -		goto err_free;
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
  	}
++<<<<<<< HEAD
 +	nfp_net_irqs_disable(pf->pdev);
 +err_vec_free:
 +	kfree(pf->irq_entries);
 +err_nn_free:
 +	nfp_net_pf_free_netdevs(pf);
++=======
+ 
+ 	pf->ctrl_vnic =	nfp_net_pf_alloc_vnic(pf, false, ctrl_bar, qc_bar,
+ 					      stride, 0);
+ 	if (IS_ERR(pf->ctrl_vnic)) {
+ 		err = PTR_ERR(pf->ctrl_vnic);
+ 		goto err_unmap;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap:
+ 	nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ err_free:
+ 	nfp_app_free(pf->app);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_clean(struct nfp_pf *pf)
+ {
+ 	if (pf->ctrl_vnic) {
+ 		nfp_net_pf_free_vnic(pf, pf->ctrl_vnic);
+ 		nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ 	}
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ }
+ 
+ static int nfp_net_pf_app_start_ctrl(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	if (!pf->ctrl_vnic)
+ 		return 0;
+ 	err = nfp_net_pf_init_vnic(pf, pf->ctrl_vnic, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_ctrl_open(pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_clean_ctrl;
+ 
+ 	return 0;
+ 
+ err_clean_ctrl:
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop_ctrl(struct nfp_pf *pf)
+ {
+ 	if (!pf->ctrl_vnic)
+ 		return;
+ 	nfp_ctrl_close(pf->ctrl_vnic);
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ }
+ 
+ static int nfp_net_pf_app_start(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	err = nfp_net_pf_app_start_ctrl(pf);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_app_start(pf->app, pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_ctrl_stop;
+ 
+ 	return 0;
+ 
+ err_ctrl_stop:
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop(struct nfp_pf *pf)
+ {
+ 	nfp_app_stop(pf->app);
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ }
+ 
+ static void nfp_net_pci_unmap_mem(struct nfp_pf *pf)
+ {
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ 	nfp_cpp_area_release_free(pf->qc_area);
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
+ }
+ 
+ static int nfp_net_pci_map_mem(struct nfp_pf *pf)
+ {
+ 	u8 __iomem *mem;
+ 	u32 min_size;
+ 	int err;
+ 
+ 	min_size = pf->max_data_vnics * NFP_PF_CSR_SLICE_SIZE;
+ 	mem = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%d_net_bar0",
+ 				   min_size, &pf->data_vnic_bar);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
+ 		return PTR_ERR(mem);
+ 	}
+ 
+ 	min_size =  NFP_MAC_STATS_SIZE * (pf->eth_tbl->max_index + 1);
+ 	pf->mac_stats_mem = nfp_rtsym_map(pf->rtbl, "_mac_stats",
+ 					  "net.macstats", min_size,
+ 					  &pf->mac_stats_bar);
+ 	if (IS_ERR(pf->mac_stats_mem)) {
+ 		if (PTR_ERR(pf->mac_stats_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->mac_stats_mem);
+ 			goto err_unmap_ctrl;
+ 		}
+ 		pf->mac_stats_mem = NULL;
+ 	}
+ 
+ 	pf->vf_cfg_mem = nfp_net_pf_map_rtsym(pf, "net.vfcfg",
+ 					      "_pf%d_net_vf_bar",
+ 					      NFP_NET_CFG_BAR_SZ *
+ 					      pf->limit_vfs, &pf->vf_cfg_bar);
+ 	if (IS_ERR(pf->vf_cfg_mem)) {
+ 		if (PTR_ERR(pf->vf_cfg_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->vf_cfg_mem);
+ 			goto err_unmap_mac_stats;
+ 		}
+ 		pf->vf_cfg_mem = NULL;
+ 	}
+ 
+ 	mem = nfp_cpp_map_area(pf->cpp, "net.qc", 0, 0,
+ 			       NFP_PCIE_QUEUE(0), NFP_QCP_QUEUE_AREA_SZ,
+ 			       &pf->qc_area);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to map Queue Controller area.\n");
+ 		err = PTR_ERR(mem);
+ 		goto err_unmap_vf_cfg;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap_vf_cfg:
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ err_unmap_mac_stats:
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ err_unmap_ctrl:
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
++>>>>>>> f84730240735 (nfp: add helper for mapping runtime symbols)
  	return err;
  }
  
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
index 988badd230d1,c9724fb7ea4b..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
@@@ -87,9 -88,20 +87,27 @@@ struct nfp_rtsym 
  	int domain;
  };
  
++<<<<<<< HEAD
 +int nfp_rtsym_count(struct nfp_cpp *cpp);
 +const struct nfp_rtsym *nfp_rtsym_get(struct nfp_cpp *cpp, int idx);
 +const struct nfp_rtsym *nfp_rtsym_lookup(struct nfp_cpp *cpp, const char *name);
 +u64 nfp_rtsym_read_le(struct nfp_cpp *cpp, const char *name, int *error);
++=======
+ struct nfp_rtsym_table;
+ 
+ struct nfp_rtsym_table *nfp_rtsym_table_read(struct nfp_cpp *cpp);
+ struct nfp_rtsym_table *
+ __nfp_rtsym_table_read(struct nfp_cpp *cpp, const struct nfp_mip *mip);
+ int nfp_rtsym_count(struct nfp_rtsym_table *rtbl);
+ const struct nfp_rtsym *nfp_rtsym_get(struct nfp_rtsym_table *rtbl, int idx);
+ const struct nfp_rtsym *
+ nfp_rtsym_lookup(struct nfp_rtsym_table *rtbl, const char *name);
+ 
+ u64 nfp_rtsym_read_le(struct nfp_rtsym_table *rtbl, const char *name,
+ 		      int *error);
+ u8 __iomem *
+ nfp_rtsym_map(struct nfp_rtsym_table *rtbl, const char *name, const char *id,
+ 	      unsigned int min_size, struct nfp_cpp_area **area);
++>>>>>>> f84730240735 (nfp: add helper for mapping runtime symbols)
  
  #endif /* NFP_NFFW_H */
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nffw.h
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
index bdfbfe4752ce..959d02a851df 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
@@ -303,3 +303,30 @@ exit:
 		return ~0ULL;
 	return val;
 }
+
+u8 __iomem *
+nfp_rtsym_map(struct nfp_rtsym_table *rtbl, const char *name, const char *id,
+	      unsigned int min_size, struct nfp_cpp_area **area)
+{
+	const struct nfp_rtsym *sym;
+	u8 __iomem *mem;
+
+	sym = nfp_rtsym_lookup(rtbl, name);
+	if (!sym)
+		return (u8 __iomem *)ERR_PTR(-ENOENT);
+
+	if (sym->size < min_size) {
+		nfp_err(rtbl->cpp, "Symbol %s too small\n", name);
+		return (u8 __iomem *)ERR_PTR(-EINVAL);
+	}
+
+	mem = nfp_cpp_map_area(rtbl->cpp, id, sym->domain, sym->target,
+			       sym->addr, sym->size, area);
+	if (IS_ERR(mem)) {
+		nfp_err(rtbl->cpp, "Failed to map symbol %s: %ld\n",
+			name, PTR_ERR(mem));
+		return mem;
+	}
+
+	return mem;
+}
