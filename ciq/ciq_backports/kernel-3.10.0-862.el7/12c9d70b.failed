mm: fix memory leak in copy_huge_pmd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] fix memory leak in copy_huge_pmd() (Jeff Moyer) [1513722]
Rebuild_FUZZ: 94.44%
commit-author Matthew Wilcox <matthew.r.wilcox@intel.com>
commit 12c9d70bd5056b3ae84746fca973c286f48384cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/12c9d70b.failed

We allocate a pgtable but do not attach it to anything if the PMD is in
a DAX VMA, causing it to leak.

We certainly try to not free pgtables associated with the huge zero page
if the zero page is in a DAX VMA, so I think this is the right solution.
This needs to be properly audited.

	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 12c9d70bd5056b3ae84746fca973c286f48384cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
diff --cc mm/huge_memory.c
index 329799c812d7,36c070167b71..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -942,20 -1076,16 +945,32 @@@ int copy_huge_pmd(struct mm_struct *dst
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	if (unlikely(pmd_trans_splitting(pmd))) {
 +		/* split huge page running from under us */
 +		spin_unlock(src_ptl);
 +		spin_unlock(dst_ptl);
 +		pte_free(dst_mm, pgtable);
 +
 +		wait_split_huge_page(vma->anon_vma, src_pmd); /* src_vma */
 +		goto out;
++=======
+ 	if (!vma_is_dax(vma)) {
+ 		/* thp accounting separate from pmd_devmap accounting */
+ 		src_page = pmd_page(pmd);
+ 		VM_BUG_ON_PAGE(!PageHead(src_page), src_page);
+ 		get_page(src_page);
+ 		page_dup_rmap(src_page, true);
+ 		add_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);
+ 		atomic_long_inc(&dst_mm->nr_ptes);
+ 		pgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);
++>>>>>>> 12c9d70bd505 (mm: fix memory leak in copy_huge_pmd())
  	}
 +	src_page = pmd_page(pmd);
 +	VM_BUG_ON_PAGE(!PageHead(src_page), src_page);
 +	get_page(src_page);
 +	page_dup_rmap(src_page);
 +	add_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);
  
  	pmdp_set_wrprotect(src_mm, addr, src_pmd);
  	pmd = pmd_mkold(pmd_wrprotect(pmd));
* Unmerged path mm/huge_memory.c
