powerpc/perf: Factor out PPMU_ONLY_COUNT_RUN check code from power8

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [powerpc] perf: Factor out PPMU_ONLY_COUNT_RUN check code from power8 (Mauricio Oliveira) [1494439]
Rebuild_FUZZ: 93.65%
commit-author Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
commit 70a7e720998d5beaf0c8abd945234e065a49336b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/70a7e720.failed

There are some hardware events on Power systems which only count when
the processor is not idle, and there are some fixed-function counters
which count such events. For example, the "run cycles" event counts
cycles when the processor is not idle. If the user asks to count
cycles, we can use "run cycles" if this is a per-task event, since the
processor is running when the task is running, by definition. We can't
use "run cycles" if the user asks for "cycles" on a system-wide
counter.

Currently in power8 this check is done using PPMU_ONLY_COUNT_RUN flag
in power8_get_alternatives() function. Based on the flag, events are
switched if needed. This function should also be enabled in power9, so
factor out the code to isa207_get_alternatives().

Fixes: efe881afdd999 ('powerpc/perf: Factor out event_alternative function')
	Reported-by: Anton Blanchard <anton@samba.org>
	Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 70a7e720998d5beaf0c8abd945234e065a49336b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/perf/isa207-common.c
#	arch/powerpc/perf/isa207-common.h
#	arch/powerpc/perf/power8-pmu.c
#	arch/powerpc/perf/power9-pmu.c
diff --cc arch/powerpc/perf/isa207-common.h
index 03205f5354e9,6c737d675792..000000000000
--- a/arch/powerpc/perf/isa207-common.h
+++ b/arch/powerpc/perf/isa207-common.h
@@@ -227,4 -270,28 +227,31 @@@
  #define MAX_ALT				2
  #define MAX_PMU_COUNTERS		6
  
++<<<<<<< HEAD
++=======
+ #define ISA207_SIER_TYPE_SHIFT		15
+ #define ISA207_SIER_TYPE_MASK		(0x7ull << ISA207_SIER_TYPE_SHIFT)
+ 
+ #define ISA207_SIER_LDST_SHIFT		1
+ #define ISA207_SIER_LDST_MASK		(0x7ull << ISA207_SIER_LDST_SHIFT)
+ 
+ #define ISA207_SIER_DATA_SRC_SHIFT	53
+ #define ISA207_SIER_DATA_SRC_MASK	(0x7ull << ISA207_SIER_DATA_SRC_SHIFT)
+ 
+ #define P(a, b)				PERF_MEM_S(a, b)
+ #define PH(a, b)			(P(LVL, HIT) | P(a, b))
+ #define PM(a, b)			(P(LVL, MISS) | P(a, b))
+ 
+ int isa207_get_constraint(u64 event, unsigned long *maskp, unsigned long *valp);
+ int isa207_compute_mmcr(u64 event[], int n_ev,
+ 				unsigned int hwc[], unsigned long mmcr[],
+ 				struct perf_event *pevents[]);
+ void isa207_disable_pmc(unsigned int pmc, unsigned long mmcr[]);
+ int isa207_get_alternatives(u64 event, u64 alt[], int size, unsigned int flags,
+ 					const unsigned int ev_alt[][MAX_ALT]);
+ void isa207_get_mem_data_src(union perf_mem_data_src *dsrc, u32 flags,
+ 							struct pt_regs *regs);
+ void isa207_get_mem_weight(u64 *weight);
+ 
++>>>>>>> 70a7e720998d (powerpc/perf: Factor out PPMU_ONLY_COUNT_RUN check code from power8)
  #endif
diff --cc arch/powerpc/perf/power8-pmu.c
index efad01a0d9b3,c9356955cab4..000000000000
--- a/arch/powerpc/perf/power8-pmu.c
+++ b/arch/powerpc/perf/power8-pmu.c
@@@ -289,67 -48,13 +289,75 @@@ static const unsigned int event_alterna
  	{ PM_RUN_INST_CMPL_ALT,		PM_RUN_INST_CMPL },
  };
  
 +/*
 + * Scan the alternatives table for a match and return the
 + * index into the alternatives table if found, else -1.
 + */
 +static int find_alternative(u64 event)
 +{
 +	int i, j;
 +
 +	for (i = 0; i < ARRAY_SIZE(event_alternatives); ++i) {
 +		if (event < event_alternatives[i][0])
 +			break;
 +
 +		for (j = 0; j < MAX_ALT && event_alternatives[i][j]; ++j)
 +			if (event == event_alternatives[i][j])
 +				return i;
 +	}
 +
 +	return -1;
 +}
 +
  static int power8_get_alternatives(u64 event, unsigned int flags, u64 alt[])
  {
++<<<<<<< HEAD
 +	int i, j, num_alt = 0;
 +	u64 alt_event;
 +
 +	alt[num_alt++] = event;
 +
 +	i = find_alternative(event);
 +	if (i >= 0) {
 +		/* Filter out the original event, it's already in alt[0] */
 +		for (j = 0; j < MAX_ALT; ++j) {
 +			alt_event = event_alternatives[i][j];
 +			if (alt_event && alt_event != event)
 +				alt[num_alt++] = alt_event;
 +		}
 +	}
 +
 +	if (flags & PPMU_ONLY_COUNT_RUN) {
 +		/*
 +		 * We're only counting in RUN state, so PM_CYC is equivalent to
 +		 * PM_RUN_CYC and PM_INST_CMPL === PM_RUN_INST_CMPL.
 +		 */
 +		j = num_alt;
 +		for (i = 0; i < num_alt; ++i) {
 +			switch (alt[i]) {
 +			case PM_CYC:
 +				alt[j++] = PM_RUN_CYC;
 +				break;
 +			case PM_RUN_CYC:
 +				alt[j++] = PM_CYC;
 +				break;
 +			case PM_INST_CMPL:
 +				alt[j++] = PM_RUN_INST_CMPL;
 +				break;
 +			case PM_RUN_INST_CMPL:
 +				alt[j++] = PM_INST_CMPL;
 +				break;
 +			}
 +		}
 +		num_alt = j;
 +	}
++=======
+ 	int num_alt = 0;
+ 
+ 	num_alt = isa207_get_alternatives(event, alt,
+ 					  ARRAY_SIZE(event_alternatives), flags,
+ 					  event_alternatives);
++>>>>>>> 70a7e720998d (powerpc/perf: Factor out PPMU_ONLY_COUNT_RUN check code from power8)
  
  	return num_alt;
  }
* Unmerged path arch/powerpc/perf/isa207-common.c
* Unmerged path arch/powerpc/perf/power9-pmu.c
* Unmerged path arch/powerpc/perf/isa207-common.c
* Unmerged path arch/powerpc/perf/isa207-common.h
* Unmerged path arch/powerpc/perf/power8-pmu.c
* Unmerged path arch/powerpc/perf/power9-pmu.c
