genirq/msi: Make use of affinity aware allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 0972fa57f53525ffa6ced12d703750fc2791e3ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0972fa57.failed

Allow the MSI code to provide affinity hints per MSI descriptor.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: linux-block@vger.kernel.org
	Cc: linux-pci@vger.kernel.org
	Cc: linux-nvme@lists.infradead.org
	Cc: axboe@fb.com
	Cc: agordeev@redhat.com
Link: http://lkml.kernel.org/r/1467621574-8277-6-git-send-email-hch@lst.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 0972fa57f53525ffa6ced12d703750fc2791e3ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/msi.h
#	kernel/irq/msi.c
diff --cc include/linux/msi.h
index d7e73b739119,4f0bfe5912b2..000000000000
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@@ -17,46 -13,144 +17,99 @@@ struct msi_msg 
  /* Helper functions */
  struct irq_data;
  struct msi_desc;
 -struct pci_dev;
 -struct platform_msi_priv_data;
 +void mask_msi_irq(struct irq_data *data);
 +void unmask_msi_irq(struct irq_data *data);
 +void __read_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
  void __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
 +void __write_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
 +void read_msi_msg(unsigned int irq, struct msi_msg *msg);
  void get_cached_msi_msg(unsigned int irq, struct msi_msg *msg);
 +void write_msi_msg(unsigned int irq, struct msi_msg *msg);
 +
++<<<<<<< HEAD
 +struct msi_desc {
 +	struct {
 +		__u8	is_msix	: 1;
 +		__u8	multiple: 3;	/* log2 num of messages allocated */
 +		__u8	maskbit	: 1;	/* mask-pending bit supported ? */
 +		__u8	is_64	: 1;	/* Address size: 0=32bit 1=64bit */
 +		__u8	pos;		/* Deprecated - do not use */
 +		__u16	entry_nr;	/* specific enabled entry */
 +		unsigned default_irq;	/* default pre-assigned irq */
 +	} msi_attrib;
 +
 +	u32 masked;			/* mask bits */
 +	unsigned int irq;
 +	unsigned int nvec_used;		/* number of messages */
 +
 +	/* RHEL KABI: upstream has 'multi_cap' within 'msi_attrib' */
 +	RH_KABI_FILL_HOLE(__u8	multi_cap : 3)	/* log2 num msgs supported */
  
 +	struct list_head list;
++=======
+ typedef void (*irq_write_msi_msg_t)(struct msi_desc *desc,
+ 				    struct msi_msg *msg);
+ 
+ /**
+  * platform_msi_desc - Platform device specific msi descriptor data
+  * @msi_priv_data:	Pointer to platform private data
+  * @msi_index:		The index of the MSI descriptor for multi MSI
+  */
+ struct platform_msi_desc {
+ 	struct platform_msi_priv_data	*msi_priv_data;
+ 	u16				msi_index;
+ };
+ 
+ /**
+  * fsl_mc_msi_desc - FSL-MC device specific msi descriptor data
+  * @msi_index:		The index of the MSI descriptor
+  */
+ struct fsl_mc_msi_desc {
+ 	u16				msi_index;
+ };
+ 
+ /**
+  * struct msi_desc - Descriptor structure for MSI based interrupts
+  * @list:	List head for management
+  * @irq:	The base interrupt number
+  * @nvec_used:	The number of vectors used
+  * @dev:	Pointer to the device which uses this descriptor
+  * @msg:	The last set MSI message cached for reuse
+  * @affinity:	Optional pointer to a cpu affinity mask for this descriptor
+  *
+  * @masked:	[PCI MSI/X] Mask bits
+  * @is_msix:	[PCI MSI/X] True if MSI-X
+  * @multiple:	[PCI MSI/X] log2 num of messages allocated
+  * @multi_cap:	[PCI MSI/X] log2 num of messages supported
+  * @maskbit:	[PCI MSI/X] Mask-Pending bit supported?
+  * @is_64:	[PCI MSI/X] Address size: 0=32bit 1=64bit
+  * @entry_nr:	[PCI MSI/X] Entry which is described by this descriptor
+  * @default_irq:[PCI MSI/X] The default pre-assigned non-MSI irq
+  * @mask_pos:	[PCI MSI]   Mask register position
+  * @mask_base:	[PCI MSI-X] Mask register base address
+  * @platform:	[platform]  Platform device specific msi descriptor data
+  */
+ struct msi_desc {
+ 	/* Shared device/bus type independent data */
+ 	struct list_head		list;
+ 	unsigned int			irq;
+ 	unsigned int			nvec_used;
+ 	struct device			*dev;
+ 	struct msi_msg			msg;
+ 	const struct cpumask		*affinity;
++>>>>>>> 0972fa57f535 (genirq/msi: Make use of affinity aware allocations)
  
  	union {
 -		/* PCI MSI/X specific data */
 -		struct {
 -			u32 masked;
 -			struct {
 -				__u8	is_msix		: 1;
 -				__u8	multiple	: 3;
 -				__u8	multi_cap	: 3;
 -				__u8	maskbit		: 1;
 -				__u8	is_64		: 1;
 -				__u16	entry_nr;
 -				unsigned default_irq;
 -			} msi_attrib;
 -			union {
 -				u8	mask_pos;
 -				void __iomem *mask_base;
 -			};
 -		};
 -
 -		/*
 -		 * Non PCI variants add their data structure here. New
 -		 * entries need to use a named structure. We want
 -		 * proper name spaces for this. The PCI part is
 -		 * anonymous for now as it would require an immediate
 -		 * tree wide cleanup.
 -		 */
 -		struct platform_msi_desc platform;
 -		struct fsl_mc_msi_desc fsl_mc;
 +		void __iomem *mask_base;
 +		u8 mask_pos;
  	};
 -};
 -
 -/* Helpers to hide struct msi_desc implementation details */
 -#define msi_desc_to_dev(desc)		((desc)->dev)
 -#define dev_to_msi_list(dev)		(&(dev)->msi_list)
 -#define first_msi_entry(dev)		\
 -	list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
 -#define for_each_msi_entry(desc, dev)	\
 -	list_for_each_entry((desc), dev_to_msi_list((dev)), list)
 -
 -#ifdef CONFIG_PCI_MSI
 -#define first_pci_msi_entry(pdev)	first_msi_entry(&(pdev)->dev)
 -#define for_each_pci_msi_entry(desc, pdev)	\
 -	for_each_msi_entry((desc), &(pdev)->dev)
 +	struct pci_dev *dev;
  
 -struct pci_dev *msi_desc_to_pci_dev(struct msi_desc *desc);
 -void *msi_desc_to_pci_sysdata(struct msi_desc *desc);
 -#else /* CONFIG_PCI_MSI */
 -static inline void *msi_desc_to_pci_sysdata(struct msi_desc *desc)
 -{
 -	return NULL;
 -}
 -#endif /* CONFIG_PCI_MSI */
 +	/* Last set MSI message */
 +	struct msi_msg msg;
  
 -struct msi_desc *alloc_msi_entry(struct device *dev);
 -void free_msi_entry(struct msi_desc *entry);
 -void __pci_read_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
 -void __pci_write_msi_msg(struct msi_desc *entry, struct msi_msg *msg);
 -void pci_write_msi_msg(unsigned int irq, struct msi_msg *msg);
 -
 -u32 __pci_msix_desc_mask_irq(struct msi_desc *desc, u32 flag);
 -u32 __pci_msi_desc_mask_irq(struct msi_desc *desc, u32 mask, u32 flag);
 -void pci_msi_mask_irq(struct irq_data *data);
 -void pci_msi_unmask_irq(struct irq_data *data);
 -
 -/* Conversion helpers. Should be removed after merging */
 -static inline void __write_msi_msg(struct msi_desc *entry, struct msi_msg *msg)
 -{
 -	__pci_write_msi_msg(entry, msg);
 -}
 -static inline void write_msi_msg(int irq, struct msi_msg *msg)
 -{
 -	pci_write_msi_msg(irq, msg);
 -}
 -static inline void mask_msi_irq(struct irq_data *data)
 -{
 -	pci_msi_mask_irq(data);
 -}
 -static inline void unmask_msi_irq(struct irq_data *data)
 -{
 -	pci_msi_unmask_irq(data);
 -}
 +	struct kobject kobj;	/* Deprecated - do not use */
 +};
  
  /*
   * The arch hooks to setup up msi irqs. Those functions are
* Unmerged path kernel/irq/msi.c
* Unmerged path include/linux/msi.h
* Unmerged path kernel/irq/msi.c
