net_sched: refactor notification code for RTM_DELTFILTER

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 54df2cf819a23dba4bb2c4134ed62659a7d324f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/54df2cf8.failed

It is confusing to use 'unsigned long fh' as both a handle
and a pointer, especially commit 9ee7837449b3
("net sched filters: fix notification of filter delete with proper handle").

This patch introduces tfilter_del_notify() so that we can
pass it as a pointer as before, and we don't need to check
RTM_DELTFILTER in tcf_fill_node() any more.

This prepares for the next patch.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 54df2cf819a23dba4bb2c4134ed62659a7d324f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 1dc6d123ed94,afd099727aea..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -103,15 -104,18 +103,19 @@@ static int tfilter_notify(struct net *n
  			  struct nlmsghdr *n, struct tcf_proto *tp,
  			  unsigned long fh, int event, bool unicast);
  
+ static int tfilter_del_notify(struct net *net, struct sk_buff *oskb,
+ 			      struct nlmsghdr *n, struct tcf_proto *tp,
+ 			      unsigned long fh, bool unicast, bool *last);
+ 
  static void tfilter_notify_chain(struct net *net, struct sk_buff *oskb,
  				 struct nlmsghdr *n,
 -				 struct tcf_chain *chain, int event)
 +				 struct tcf_proto __rcu **chain, int event)
  {
 +	struct tcf_proto __rcu **it_chain;
  	struct tcf_proto *tp;
  
 -	for (tp = rtnl_dereference(chain->filter_chain);
 -	     tp; tp = rtnl_dereference(tp->next))
 +	for (it_chain = chain; (tp = rtnl_dereference(*it_chain)) != NULL;
 +	     it_chain = &tp->next)
  		tfilter_notify(net, oskb, n, tp, 0, event, false);
  }
  
@@@ -341,14 -599,14 +345,25 @@@ replay
  			}
  			break;
  		case RTM_DELTFILTER:
++<<<<<<< HEAD
 +			err = tp->ops->delete(tp, fh);
 +			if (err)
 +				goto errout;
 +			next = rtnl_dereference(tp->next);
 +			tfilter_notify(net, skb, n, tp, t->tcm_handle,
 +				       RTM_DELTFILTER, false);
 +			if (tcf_proto_destroy(tp, false))
 +				RCU_INIT_POINTER(*back, next);
++=======
+ 			err = tfilter_del_notify(net, skb, n, tp, fh, false,
+ 						 &last);
+ 			if (err)
+ 				goto errout;
+ 			if (last) {
+ 				tcf_chain_tp_remove(chain, &chain_info, tp);
+ 				tcf_proto_destroy(tp);
+ 			}
++>>>>>>> 54df2cf819a2 (net_sched: refactor notification code for RTM_DELTFILTER)
  			goto errout;
  		case RTM_GETTFILTER:
  			err = tfilter_notify(net, skb, n, tp, fh,
@@@ -402,9 -660,11 +417,16 @@@ static int tcf_fill_node(struct net *ne
  	tcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);
  	if (nla_put_string(skb, TCA_KIND, tp->ops->kind))
  		goto nla_put_failure;
++<<<<<<< HEAD
 +	tcm->tcm_handle = fh;
 +	if (RTM_DELTFILTER != event) {
++=======
+ 	if (nla_put_u32(skb, TCA_CHAIN, tp->chain->index))
+ 		goto nla_put_failure;
+ 	if (!fh) {
++>>>>>>> 54df2cf819a2 (net_sched: refactor notification code for RTM_DELTFILTER)
  		tcm->tcm_handle = 0;
+ 	} else {
  		if (tp->ops->dump && tp->ops->dump(net, tp, fh, skb, tcm) < 0)
  			goto nla_put_failure;
  	}
* Unmerged path net/sched/cls_api.c
