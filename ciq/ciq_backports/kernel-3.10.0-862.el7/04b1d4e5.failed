net: core: Make the FIB notification chain generic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] core: Make the FIB notification chain generic (Ivan Vecera) [1500886]
Rebuild_FUZZ: 94.74%
commit-author Ido Schimmel <idosch@mellanox.com>
commit 04b1d4e50e82536c12da00ee04a77510c459c844
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/04b1d4e5.failed

The FIB notification chain is currently soley used by IPv4 code.
However, we're going to introduce IPv6 FIB offload support, which
requires these notification as well.

As explained in commit c3852ef7f2f8 ("ipv4: fib: Replay events when
registering FIB notifier"), upon registration to the chain, the callee
receives a full dump of the FIB tables and rules by traversing all the
net namespaces. The integrity of the dump is ensured by a per-namespace
sequence counter that is incremented whenever a change to the tables or
rules occurs.

In order to allow more address families to use the chain, each family is
expected to register its fib_notifier_ops in its pernet init. These
operations allow the common code to read the family's sequence counter
as well as dump its tables and rules in the given net namespace.

Additionally, a 'family' parameter is added to sent notifications, so
that listeners could distinguish between the different families.

Implement the common code that allows listeners to register to the chain
and for address families to register their fib_notifier_ops. Subsequent
patches will implement these operations in IPv6.

In the future, ipmr and ip6mr will be extended to provide these
notifications as well.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04b1d4e50e82536c12da00ee04a77510c459c844)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/ethernet/rocker/rocker_main.c
#	include/net/netns/ipv4.h
#	net/core/Makefile
#	net/ipv4/fib_frontend.c
#	net/ipv4/fib_rules.c
#	net/ipv4/fib_semantics.c
#	net/ipv4/fib_trie.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 2e656326922f,b79f9b67f285..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -45,6 -48,12 +45,15 @@@
  #include <net/neighbour.h>
  #include <net/arp.h>
  #include <net/ip_fib.h>
++<<<<<<< HEAD
++=======
+ #include <net/fib_rules.h>
+ #include <net/l3mdev.h>
+ #include <net/addrconf.h>
+ #include <net/ndisc.h>
+ #include <net/ipv6.h>
+ #include <net/fib_notifier.h>
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  
  #include "spectrum.h"
  #include "core.h"
diff --cc drivers/net/ethernet/rocker/rocker_main.c
index 0a390fa2656a,ef38c1a41bdd..000000000000
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@@ -33,7 -33,9 +33,13 @@@
  #include <net/rtnetlink.h>
  #include <net/netevent.h>
  #include <net/arp.h>
++<<<<<<< HEAD
 +#include <asm-generic/io-64-nonatomic-lo-hi.h>
++=======
+ #include <net/fib_rules.h>
+ #include <net/fib_notifier.h>
+ #include <linux/io-64-nonatomic-lo-hi.h>
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  #include <generated/utsrelease.h>
  
  #include "rocker_hw.h"
diff --cc include/net/netns/ipv4.h
index 4b15ee83774e,20d061c805e3..000000000000
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@@ -86,5 -154,14 +86,17 @@@ struct netns_ipv4 
  	struct fib_rules_ops	*mr_rules_ops;
  #endif
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
+ 	int sysctl_fib_multipath_use_neigh;
+ 	int sysctl_fib_multipath_hash_policy;
+ #endif
+ 
+ 	struct fib_notifier_ops	*notifier_ops;
+ 	unsigned int	fib_seq;	/* protected by rtnl_mutex */
+ 
+ 	atomic_t	rt_genid;
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  };
  #endif
diff --cc net/core/Makefile
index c5db47758796,56d771a887b6..000000000000
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@@ -9,9 -9,9 +9,14 @@@ obj-$(CONFIG_SYSCTL) += sysctl_net_core
  
  obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
  			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
++<<<<<<< HEAD
 +			sock_diag.o dev_ioctl.o tso.o
++=======
+ 			sock_diag.o dev_ioctl.o tso.o sock_reuseport.o \
+ 			fib_notifier.o
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  
 +obj-$(CONFIG_XFRM) += flow.o
  obj-y += net-sysfs.o
  obj-$(CONFIG_PROC_FS) += net-procfs.o
  obj-$(CONFIG_NET_PKTGEN) += pktgen.o
diff --cc net/ipv4/fib_frontend.c
index 30f0d2b5e192,2cba559f14df..000000000000
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@@ -1118,8 -1255,10 +1120,15 @@@ static int __net_init ip_fib_net_init(s
  	size = max_t(size_t, size, L1_CACHE_BYTES);
  
  	net->ipv4.fib_table_hash = kzalloc(size, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (net->ipv4.fib_table_hash == NULL)
 +		return -ENOMEM;
++=======
+ 	if (!net->ipv4.fib_table_hash) {
+ 		err = -ENOMEM;
+ 		goto err_table_hash_alloc;
+ 	}
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  
  	err = fib4_rules_init(net);
  	if (err < 0)
diff --cc net/ipv4/fib_rules.c
index 329dfa168e33,acdbf5a24ac9..000000000000
--- a/net/ipv4/fib_rules.c
+++ b/net/ipv4/fib_rules.c
@@@ -131,20 -186,36 +132,38 @@@ static struct fib_table *fib_empty_tabl
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static int call_fib_rule_notifier(struct notifier_block *nb, struct net *net,
+ 				  enum fib_event_type event_type,
+ 				  struct fib_rule *rule)
+ {
+ 	struct fib_rule_notifier_info info = {
+ 		.rule = rule,
+ 	};
+ 
+ 	return call_fib4_notifier(nb, net, event_type, &info.info);
+ }
+ 
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  static int call_fib_rule_notifiers(struct net *net,
 -				   enum fib_event_type event_type,
 -				   struct fib_rule *rule)
 +				   enum fib_event_type event_type)
  {
 -	struct fib_rule_notifier_info info = {
 -		.rule = rule,
 -	};
 +	struct fib_notifier_info info;
  
++<<<<<<< HEAD
 +	return call_fib_notifiers(net, event_type, &info);
++=======
+ 	return call_fib4_notifiers(net, event_type, &info.info);
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  }
  
 -/* Called with rcu_read_lock() */
  void fib_rules_notify(struct net *net, struct notifier_block *nb)
  {
 -	struct fib_rules_ops *ops = net->ipv4.rules_ops;
 -	struct fib_rule *rule;
 +	struct fib_notifier_info info;
  
 -	list_for_each_entry_rcu(rule, &ops->rules_list, list)
 -		call_fib_rule_notifier(nb, net, FIB_EVENT_RULE_ADD, rule);
 +	if (net->ipv4.fib_has_custom_rules)
 +		call_fib_notifier(nb, net, FIB_EVENT_RULE_ADD, &info);
  }
  
  static const struct nla_policy fib4_rule_policy[FRA_MAX+1] = {
diff --cc net/ipv4/fib_semantics.c
index 22ec44cc4020,632b454ce77c..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -1291,20 -1452,14 +1292,30 @@@ static int call_fib_nh_notifiers(struc
  		if (IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
  		    fib_nh->nh_flags & RTNH_F_LINKDOWN)
  			break;
++<<<<<<< HEAD
 +#endif
 +		return call_fib_notifiers(dev_net(fib_nh->nh_dev), event_type,
 +					  &info.info);
++=======
+ 		return call_fib4_notifiers(dev_net(fib_nh->nh_dev), event_type,
+ 					   &info.info);
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  	case FIB_EVENT_NH_DEL:
 -		if ((in_dev && IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
 +#ifdef RTNH_F_LINKDOWN
 +#error RTNH_F_LINKDOWN has been backported, fix me please!
 +		if ((IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&
  		     fib_nh->nh_flags & RTNH_F_LINKDOWN) ||
  		    (fib_nh->nh_flags & RTNH_F_DEAD))
++<<<<<<< HEAD
 +#else
 +		if (fib_nh->nh_flags & RTNH_F_DEAD)
 +#endif
 +			return call_fib_notifiers(dev_net(fib_nh->nh_dev),
 +						  event_type, &info.info);
++=======
+ 			return call_fib4_notifiers(dev_net(fib_nh->nh_dev),
+ 						   event_type, &info.info);
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  	default:
  		break;
  	}
diff --cc net/ipv4/fib_trie.c
index 0d5341975c29,1a6ffb0dab9c..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -80,6 -81,8 +80,11 @@@
  #include <net/tcp.h>
  #include <net/sock.h>
  #include <net/ip_fib.h>
++<<<<<<< HEAD
++=======
+ #include <net/fib_notifier.h>
+ #include <trace/events/fib.h>
++>>>>>>> 04b1d4e50e82 (net: core: Make the FIB notification chain generic)
  #include "fib_lookup.h"
  
  static int call_fib_entry_notifier(struct notifier_block *nb, struct net *net,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/ethernet/rocker/rocker_main.c
diff --git a/include/net/fib_notifier.h b/include/net/fib_notifier.h
new file mode 100644
index 000000000000..241475224f74
--- /dev/null
+++ b/include/net/fib_notifier.h
@@ -0,0 +1,44 @@
+#ifndef __NET_FIB_NOTIFIER_H
+#define __NET_FIB_NOTIFIER_H
+
+#include <linux/types.h>
+#include <linux/notifier.h>
+#include <net/net_namespace.h>
+
+struct fib_notifier_info {
+	struct net *net;
+	int family;
+};
+
+enum fib_event_type {
+	FIB_EVENT_ENTRY_REPLACE,
+	FIB_EVENT_ENTRY_APPEND,
+	FIB_EVENT_ENTRY_ADD,
+	FIB_EVENT_ENTRY_DEL,
+	FIB_EVENT_RULE_ADD,
+	FIB_EVENT_RULE_DEL,
+	FIB_EVENT_NH_ADD,
+	FIB_EVENT_NH_DEL,
+};
+
+struct fib_notifier_ops {
+	int family;
+	struct list_head list;
+	unsigned int (*fib_seq_read)(struct net *net);
+	int (*fib_dump)(struct net *net, struct notifier_block *nb);
+	struct rcu_head rcu;
+};
+
+int call_fib_notifier(struct notifier_block *nb, struct net *net,
+		      enum fib_event_type event_type,
+		      struct fib_notifier_info *info);
+int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
+		       struct fib_notifier_info *info);
+int register_fib_notifier(struct notifier_block *nb,
+			  void (*cb)(struct notifier_block *nb));
+int unregister_fib_notifier(struct notifier_block *nb);
+struct fib_notifier_ops *
+fib_notifier_ops_register(const struct fib_notifier_ops *tmpl, struct net *net);
+void fib_notifier_ops_unregister(struct fib_notifier_ops *ops);
+
+#endif
diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index c9e0e41061bc..587a53ff169d 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -19,6 +19,7 @@
 #include <net/flow.h>
 #include <linux/seq_file.h>
 #include <linux/rcupdate.h>
+#include <net/fib_notifier.h>
 #include <net/fib_rules.h>
 #include <net/inetpeer.h>
 #include <linux/percpu.h>
@@ -198,10 +199,6 @@ static inline void fib_info_offload_dec(struct fib_info *fi)
 #define FIB_RES_PREFSRC(net, res)	((res).fi->fib_prefsrc ? : \
 					 FIB_RES_SADDR(net, res))
 
-struct fib_notifier_info {
-	struct net *net;
-};
-
 struct fib_entry_notifier_info {
 	struct fib_notifier_info info; /* must be first */
 	u32 dst;
@@ -217,25 +214,14 @@ struct fib_nh_notifier_info {
 	struct fib_nh *fib_nh;
 };
 
-enum fib_event_type {
-	FIB_EVENT_ENTRY_REPLACE,
-	FIB_EVENT_ENTRY_APPEND,
-	FIB_EVENT_ENTRY_ADD,
-	FIB_EVENT_ENTRY_DEL,
-	FIB_EVENT_RULE_ADD,
-	FIB_EVENT_RULE_DEL,
-	FIB_EVENT_NH_ADD,
-	FIB_EVENT_NH_DEL,
-};
-
-int register_fib_notifier(struct notifier_block *nb,
-			  void (*cb)(struct notifier_block *nb));
-int unregister_fib_notifier(struct notifier_block *nb);
-int call_fib_notifier(struct notifier_block *nb, struct net *net,
-		      enum fib_event_type event_type,
-		      struct fib_notifier_info *info);
-int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
+int call_fib4_notifier(struct notifier_block *nb, struct net *net,
+		       enum fib_event_type event_type,
 		       struct fib_notifier_info *info);
+int call_fib4_notifiers(struct net *net, enum fib_event_type event_type,
+			struct fib_notifier_info *info);
+
+int __net_init fib4_notifier_init(struct net *net);
+void __net_exit fib4_notifier_exit(struct net *net);
 
 void fib_notify(struct net *net, struct notifier_block *nb);
 #ifdef CONFIG_IP_MULTIPLE_TABLES
diff --git a/include/net/net_namespace.h b/include/net/net_namespace.h
index 9499054f725e..6225ff727a71 100644
--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@ -78,6 +78,7 @@ struct net {
 	/* core fib_rules */
 	struct list_head	rules_ops;
 
+	struct list_head	fib_notifier_ops;  /* protected by net_mutex */
 
 	struct net_device       *loopback_dev;          /* The loopback */
 	struct netns_core	core;
* Unmerged path include/net/netns/ipv4.h
* Unmerged path net/core/Makefile
diff --git a/net/core/fib_notifier.c b/net/core/fib_notifier.c
new file mode 100644
index 000000000000..292aab83702f
--- /dev/null
+++ b/net/core/fib_notifier.c
@@ -0,0 +1,164 @@
+#include <linux/rtnetlink.h>
+#include <linux/notifier.h>
+#include <linux/rcupdate.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <net/net_namespace.h>
+#include <net/fib_notifier.h>
+
+static ATOMIC_NOTIFIER_HEAD(fib_chain);
+
+int call_fib_notifier(struct notifier_block *nb, struct net *net,
+		      enum fib_event_type event_type,
+		      struct fib_notifier_info *info)
+{
+	info->net = net;
+	return nb->notifier_call(nb, event_type, info);
+}
+EXPORT_SYMBOL(call_fib_notifier);
+
+int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
+		       struct fib_notifier_info *info)
+{
+	info->net = net;
+	return atomic_notifier_call_chain(&fib_chain, event_type, info);
+}
+EXPORT_SYMBOL(call_fib_notifiers);
+
+static unsigned int fib_seq_sum(void)
+{
+	struct fib_notifier_ops *ops;
+	unsigned int fib_seq = 0;
+	struct net *net;
+
+	rtnl_lock();
+	for_each_net(net) {
+		list_for_each_entry(ops, &net->fib_notifier_ops, list)
+			fib_seq += ops->fib_seq_read(net);
+	}
+	rtnl_unlock();
+
+	return fib_seq;
+}
+
+static int fib_net_dump(struct net *net, struct notifier_block *nb)
+{
+	struct fib_notifier_ops *ops;
+
+	list_for_each_entry_rcu(ops, &net->fib_notifier_ops, list) {
+		int err = ops->fib_dump(net, nb);
+
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static bool fib_dump_is_consistent(struct notifier_block *nb,
+				   void (*cb)(struct notifier_block *nb),
+				   unsigned int fib_seq)
+{
+	atomic_notifier_chain_register(&fib_chain, nb);
+	if (fib_seq == fib_seq_sum())
+		return true;
+	atomic_notifier_chain_unregister(&fib_chain, nb);
+	if (cb)
+		cb(nb);
+	return false;
+}
+
+#define FIB_DUMP_MAX_RETRIES 5
+int register_fib_notifier(struct notifier_block *nb,
+			  void (*cb)(struct notifier_block *nb))
+{
+	int retries = 0;
+	int err;
+
+	do {
+		unsigned int fib_seq = fib_seq_sum();
+		struct net *net;
+
+		rcu_read_lock();
+		for_each_net_rcu(net) {
+			err = fib_net_dump(net, nb);
+			if (err)
+				goto err_fib_net_dump;
+		}
+		rcu_read_unlock();
+
+		if (fib_dump_is_consistent(nb, cb, fib_seq))
+			return 0;
+	} while (++retries < FIB_DUMP_MAX_RETRIES);
+
+	return -EBUSY;
+
+err_fib_net_dump:
+	rcu_read_unlock();
+	return err;
+}
+EXPORT_SYMBOL(register_fib_notifier);
+
+int unregister_fib_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&fib_chain, nb);
+}
+EXPORT_SYMBOL(unregister_fib_notifier);
+
+static int __fib_notifier_ops_register(struct fib_notifier_ops *ops,
+				       struct net *net)
+{
+	struct fib_notifier_ops *o;
+
+	list_for_each_entry(o, &net->fib_notifier_ops, list)
+		if (ops->family == o->family)
+			return -EEXIST;
+	list_add_tail_rcu(&ops->list, &net->fib_notifier_ops);
+	return 0;
+}
+
+struct fib_notifier_ops *
+fib_notifier_ops_register(const struct fib_notifier_ops *tmpl, struct net *net)
+{
+	struct fib_notifier_ops *ops;
+	int err;
+
+	ops = kmemdup(tmpl, sizeof(*ops), GFP_KERNEL);
+	if (!ops)
+		return ERR_PTR(-ENOMEM);
+
+	err = __fib_notifier_ops_register(ops, net);
+	if (err)
+		goto err_register;
+
+	return ops;
+
+err_register:
+	kfree(ops);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL(fib_notifier_ops_register);
+
+void fib_notifier_ops_unregister(struct fib_notifier_ops *ops)
+{
+	list_del_rcu(&ops->list);
+	kfree_rcu(ops, rcu);
+}
+EXPORT_SYMBOL(fib_notifier_ops_unregister);
+
+static int __net_init fib_notifier_net_init(struct net *net)
+{
+	INIT_LIST_HEAD(&net->fib_notifier_ops);
+	return 0;
+}
+
+static struct pernet_operations fib_notifier_net_ops = {
+	.init = fib_notifier_net_init,
+};
+
+static int __init fib_notifier_init(void)
+{
+	return register_pernet_subsys(&fib_notifier_net_ops);
+}
+
+subsys_initcall(fib_notifier_init);
* Unmerged path net/ipv4/fib_frontend.c
diff --git a/net/ipv4/fib_notifier.c b/net/ipv4/fib_notifier.c
index e0714d975947..7cf1954bbadc 100644
--- a/net/ipv4/fib_notifier.c
+++ b/net/ipv4/fib_notifier.c
@@ -1,86 +1,66 @@
 #include <linux/rtnetlink.h>
 #include <linux/notifier.h>
-#include <linux/rcupdate.h>
+#include <linux/socket.h>
 #include <linux/kernel.h>
 #include <net/net_namespace.h>
+#include <net/fib_notifier.h>
 #include <net/netns/ipv4.h>
 #include <net/ip_fib.h>
 
-static ATOMIC_NOTIFIER_HEAD(fib_chain);
-
-int call_fib_notifier(struct notifier_block *nb, struct net *net,
-		      enum fib_event_type event_type,
-		      struct fib_notifier_info *info)
+int call_fib4_notifier(struct notifier_block *nb, struct net *net,
+		       enum fib_event_type event_type,
+		       struct fib_notifier_info *info)
 {
-	info->net = net;
-	return nb->notifier_call(nb, event_type, info);
+	info->family = AF_INET;
+	return call_fib_notifier(nb, net, event_type, info);
 }
 
-int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
-		       struct fib_notifier_info *info)
+int call_fib4_notifiers(struct net *net, enum fib_event_type event_type,
+			struct fib_notifier_info *info)
 {
+	ASSERT_RTNL();
+
+	info->family = AF_INET;
 	net->ipv4.fib_seq++;
-	info->net = net;
-	return atomic_notifier_call_chain(&fib_chain, event_type, info);
+	return call_fib_notifiers(net, event_type, info);
 }
 
-static unsigned int fib_seq_sum(void)
+static unsigned int fib4_seq_read(struct net *net)
 {
-	unsigned int fib_seq = 0;
-	struct net *net;
+	ASSERT_RTNL();
 
-	rtnl_lock();
-	for_each_net(net)
-		fib_seq += net->ipv4.fib_seq;
-	rtnl_unlock();
-
-	return fib_seq;
+	return net->ipv4.fib_seq;
 }
 
-static bool fib_dump_is_consistent(struct notifier_block *nb,
-				   void (*cb)(struct notifier_block *nb),
-				   unsigned int fib_seq)
+static int fib4_dump(struct net *net, struct notifier_block *nb)
 {
-	atomic_notifier_chain_register(&fib_chain, nb);
-	if (fib_seq == fib_seq_sum())
-		return true;
-	atomic_notifier_chain_unregister(&fib_chain, nb);
-	if (cb)
-		cb(nb);
-	return false;
+	fib_rules_notify(net, nb);
+	fib_notify(net, nb);
+
+	return 0;
 }
 
-#define FIB_DUMP_MAX_RETRIES 5
-int register_fib_notifier(struct notifier_block *nb,
-			  void (*cb)(struct notifier_block *nb))
-{
-	int retries = 0;
+static const struct fib_notifier_ops fib4_notifier_ops_template = {
+	.family		= AF_INET,
+	.fib_seq_read	= fib4_seq_read,
+	.fib_dump	= fib4_dump,
+};
 
-	do {
-		unsigned int fib_seq = fib_seq_sum();
-		struct net *net;
+int __net_init fib4_notifier_init(struct net *net)
+{
+	struct fib_notifier_ops *ops;
 
-		/* Mutex semantics guarantee that every change done to
-		 * FIB tries before we read the change sequence counter
-		 * is now visible to us.
-		 */
-		rcu_read_lock();
-		for_each_net_rcu(net) {
-			fib_rules_notify(net, nb);
-			fib_notify(net, nb);
-		}
-		rcu_read_unlock();
+	net->ipv4.fib_seq = 0;
 
-		if (fib_dump_is_consistent(nb, cb, fib_seq))
-			return 0;
-	} while (++retries < FIB_DUMP_MAX_RETRIES);
+	ops = fib_notifier_ops_register(&fib4_notifier_ops_template, net);
+	if (IS_ERR(ops))
+		return PTR_ERR(ops);
+	net->ipv4.notifier_ops = ops;
 
-	return -EBUSY;
+	return 0;
 }
-EXPORT_SYMBOL(register_fib_notifier);
 
-int unregister_fib_notifier(struct notifier_block *nb)
+void __net_exit fib4_notifier_exit(struct net *net)
 {
-	return atomic_notifier_chain_unregister(&fib_chain, nb);
+	fib_notifier_ops_unregister(net->ipv4.notifier_ops);
 }
-EXPORT_SYMBOL(unregister_fib_notifier);
* Unmerged path net/ipv4/fib_rules.c
* Unmerged path net/ipv4/fib_semantics.c
* Unmerged path net/ipv4/fib_trie.c
