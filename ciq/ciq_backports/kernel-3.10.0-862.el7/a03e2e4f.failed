fsnotify: Determine lock in fsnotify_destroy_marks()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit a03e2e4f078365428bb4317989cb5d1d6563cfe9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a03e2e4f.failed

Instead of passing spinlock into fsnotify_destroy_marks() determine it
directly in that function from the connector type. This will reduce code
churn when changing lock protecting list of marks.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit a03e2e4f078365428bb4317989cb5d1d6563cfe9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fsnotify.h
#	fs/notify/mark.c
diff --cc fs/notify/fsnotify.h
index 0a3bc2cf192c,225924274f8a..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -39,22 -21,22 +39,38 @@@ extern int fsnotify_add_vfsmount_mark(s
  /* vfsmount specific destruction of a mark */
  extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
  /* inode specific destruction of a mark */
 -extern struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 +extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
  /* Find mark belonging to given group in the list of marks */
++<<<<<<< HEAD
 +extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 +						struct fsnotify_group *group);
 +/* Destroy all marks in the given list protected by 'lock' */
 +extern void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock);
 +/* run the list of all marks associated with inode and destroy them */
 +static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
 +{
 +	fsnotify_destroy_marks(&inode->i_fsnotify_marks, &inode->i_lock);
++=======
+ extern struct fsnotify_mark *fsnotify_find_mark(
+ 					struct fsnotify_mark_connector *conn,
+ 					struct fsnotify_group *group);
+ /* Destroy all marks connected via given connector */
+ extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn);
+ /* run the list of all marks associated with inode and destroy them */
+ static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
+ {
+ 	fsnotify_destroy_marks(inode->i_fsnotify_marks);
++>>>>>>> a03e2e4f0783 (fsnotify: Determine lock in fsnotify_destroy_marks())
  }
  /* run the list of all marks associated with vfsmount and destroy them */
  static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
  {
++<<<<<<< HEAD
 +	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks,
 +			       &mnt->mnt_root->d_lock);
++=======
+ 	fsnotify_destroy_marks(real_mount(mnt)->mnt_fsnotify_marks);
++>>>>>>> a03e2e4f0783 (fsnotify: Determine lock in fsnotify_destroy_marks())
  }
  /* prepare for freeing all marks associated with given group */
  extern void fsnotify_detach_group_marks(struct fsnotify_group *group);
diff --cc fs/notify/mark.c
index 44836e539169,f32ca924c44e..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -499,6 -572,47 +499,50 @@@ void fsnotify_detach_group_marks(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn)
+ {
+ 	struct fsnotify_mark *mark;
+ 	spinlock_t *lock;
+ 
+ 	if (!conn)
+ 		return;
+ 
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		lock = &conn->inode->i_lock;
+ 	else
+ 		lock = &conn->mnt->mnt_root->d_lock;
+ 
+ 	while (1) {
+ 		/*
+ 		 * We have to be careful since we can race with e.g.
+ 		 * fsnotify_clear_marks_by_group() and once we drop 'lock',
+ 		 * mark can get removed from the obj_list and destroyed. But
+ 		 * we are holding mark reference so mark cannot be freed and
+ 		 * calling fsnotify_destroy_mark() more than once is fine.
+ 		 */
+ 		spin_lock(lock);
+ 		if (hlist_empty(&conn->list)) {
+ 			spin_unlock(lock);
+ 			break;
+ 		}
+ 		mark = hlist_entry(conn->list.first, struct fsnotify_mark,
+ 				   obj_list);
+ 		/*
+ 		 * We don't update i_fsnotify_mask / mnt_fsnotify_mask here
+ 		 * since inode / mount is going away anyway. So just remove
+ 		 * mark from the list.
+ 		 */
+ 		hlist_del_init_rcu(&mark->obj_list);
+ 		fsnotify_get_mark(mark);
+ 		spin_unlock(lock);
+ 		fsnotify_destroy_mark(mark, mark->group);
+ 		fsnotify_put_mark(mark);
+ 	}
+ }
+ 
++>>>>>>> a03e2e4f0783 (fsnotify: Determine lock in fsnotify_destroy_marks())
  /*
   * Nothing fancy, just initialize lists and locks and counters.
   */
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/mark.c
