scsi: cxlflash: Schedule asynchronous reset of the host

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Schedule asynchronous reset of the host (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 94.23%
commit-author Uma Krishnan <ukrishn@linux.vnet.ibm.com>
commit 0b09e711189952ff9d411593a8d74ec12a956c57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0b09e711.failed

A context reset failure indicates the AFU is in a bad state. At present,
when such a situation occurs, no further action is taken. This leaves the
adapter in an unusable state with no recoverable actions.

To avoid this situation, context reset failures will be escalated to a host
reset operation. This will be done asynchronously to allow the acting
thread to return to the user with a failure.

	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Acked-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0b09e711189952ff9d411593a8d74ec12a956c57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,e9b61087b72b..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -15,6 -15,8 +15,11 @@@
  #ifndef _CXLFLASH_COMMON_H
  #define _CXLFLASH_COMMON_H
  
++<<<<<<< HEAD
++=======
+ #include <linux/async.h>
+ #include <linux/irq_poll.h>
++>>>>>>> 0b09e7111899 (scsi: cxlflash: Schedule asynchronous reset of the host)
  #include <linux/list.h>
  #include <linux/rwsem.h>
  #include <linux/types.h>
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,20c2c5e111b4..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -599,18 -610,24 +613,20 @@@ static void cxlflash_reset_sync(struct 
   */
  static void stop_afu(struct cxlflash_cfg *cfg)
  {
 -	struct afu *afu = cfg->afu;
 -	struct hwq *hwq;
  	int i;
 +	struct afu *afu = cfg->afu;
 +	struct afu_cmd *cmd;
  
  	cancel_work_sync(&cfg->work_q);
+ 	if (!current_is_async())
+ 		cxlflash_reset_sync(cfg);
  
  	if (likely(afu)) {
 -		while (atomic_read(&afu->cmds_active))
 -			ssleep(1);
 -
 -		if (afu_is_irqpoll_enabled(afu)) {
 -			for (i = 0; i < afu->num_hwqs; i++) {
 -				hwq = get_hwq(afu, i);
 -
 -				irq_poll_disable(&hwq->irqpoll);
 -			}
 +		for (i = 0; i < CXLFLASH_NUM_CMDS; i++) {
 +			cmd = &afu->cmd[i];
 +			complete(&cmd->cevent);
 +			if (!atomic_read(&cmd->free))
 +				cmd_checkin(cmd);
  		}
  
  		if (likely(afu->afu_map)) {
@@@ -1843,58 -2175,29 +1944,71 @@@ int cxlflash_afu_sync(struct afu *afu, 
  	*((__be16 *)&cmd->rcb.cdb[2]) = cpu_to_be16(ctx_hndl_u);
  	*((__be32 *)&cmd->rcb.cdb[4]) = cpu_to_be32(res_hndl_u);
  
 -	rc = afu->send_cmd(afu, cmd);
 -	if (unlikely(rc)) {
 -		rc = -ENOBUFS;
 +	rc = send_cmd(afu, cmd);
 +	if (unlikely(rc))
  		goto out;
 -	}
  
++<<<<<<< HEAD
 +	wait_resp(afu, cmd);
++=======
+ 	rc = wait_resp(afu, cmd);
+ 	if (rc == -ETIMEDOUT) {
+ 		rc = afu->context_reset(hwq);
+ 		if (!rc && ++nretry < 2)
+ 			goto retry;
+ 		cxlflash_schedule_async_reset(cfg);
+ 	}
++>>>>>>> 0b09e7111899 (scsi: cxlflash: Schedule asynchronous reset of the host)
  
 +	/* Set on timeout */
 +	if (unlikely((cmd->sa.ioasc != 0) ||
 +		     (cmd->sa.host_use_b[0] & B_ERROR)))
 +		rc = -1;
  out:
 -	atomic_dec(&afu->cmds_active);
  	mutex_unlock(&sync_active);
  	kfree(buf);
 -	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
 +	pr_debug("%s: returning rc=%d\n", __func__, rc);
  	return rc;
  }
  
  /**
++<<<<<<< HEAD
 + * afu_reset() - resets the AFU
 + * @cfg:	Internal structure associated with the host.
 + *
 + * Return: 0 on success, -errno on failure
 + */
 +static int afu_reset(struct cxlflash_cfg *cfg)
 +{
 +	int rc = 0;
 +	/* Stop the context before the reset. Since the context is
 +	 * no longer available restart it after the reset is complete
 +	 */
 +
 +	term_afu(cfg);
 +
 +	rc = init_afu(cfg);
 +
 +	pr_debug("%s: returning rc=%d\n", __func__, rc);
 +	return rc;
 +}
 +
 +/**
 + * drain_ioctls() - wait until all currently executing ioctls have completed
 + * @cfg:	Internal structure associated with the host.
 + *
 + * Obtain write access to read/write semaphore that wraps ioctl
 + * handling to 'drain' ioctls currently executing.
 + */
 +static void drain_ioctls(struct cxlflash_cfg *cfg)
 +{
 +	down_write(&cfg->ioctl_rwsem);
 +	up_write(&cfg->ioctl_rwsem);
 +}
 +
 +/**
++=======
++>>>>>>> 0b09e7111899 (scsi: cxlflash: Schedule asynchronous reset of the host)
   * cxlflash_eh_device_reset_handler() - reset a single LUN
   * @scp:	SCSI command to send.
   *
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
