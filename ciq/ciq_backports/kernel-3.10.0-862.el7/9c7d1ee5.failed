scsi: cxlflash: Refactor context reset to share reset logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Refactor context reset to share reset logic (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 94.64%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 9c7d1ee5f13a7130f6d3df307ec010e9e003fa98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9c7d1ee5.failed

As staging for supporting hardware with different context reset
registers but a similar reset procedure, refactor the existing context
reset routine to move the reset logic to a common routine. This will
allow hardware with a different reset register to leverage existing
code.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9c7d1ee5f13a7130f6d3df307ec010e9e003fa98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/main.c
index d8aaf45b8306,a990efb27197..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -253,12 -188,11 +253,20 @@@ static void cmd_complete(struct afu_cm
  }
  
  /**
++<<<<<<< HEAD
 + * context_reset() - timeout handler for AFU commands
 + * @cmd:	AFU command that timed out.
 + *
 + * Sends a reset to the AFU.
 + */
 +static void context_reset(struct afu_cmd *cmd)
++=======
+  * context_reset() - reset command owner context via specified register
+  * @cmd:	AFU command that timed out.
+  * @reset_reg:	MMIO register to perform reset.
+  */
+ static void context_reset(struct afu_cmd *cmd, __be64 __iomem *reset_reg)
++>>>>>>> 9c7d1ee5f13a (scsi: cxlflash: Refactor context reset to share reset logic)
  {
  	int nretry = 0;
  	u64 rrin = 0x1;
@@@ -269,20 -202,9 +277,24 @@@
  
  	pr_debug("%s: cmd=%p\n", __func__, cmd);
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&cmd->slock, lock_flags);
 +
 +	/* Already completed? */
 +	if (cmd->sa.host_use_b[0] & B_DONE) {
 +		spin_unlock_irqrestore(&cmd->slock, lock_flags);
 +		return;
 +	}
 +
 +	cmd->sa.host_use_b[0] |= (B_DONE | B_ERROR | B_TIMEOUT);
 +	spin_unlock_irqrestore(&cmd->slock, lock_flags);
 +
 +	writeq_be(rrin, &afu->host_map->ioarrin);
++=======
+ 	writeq_be(rrin, reset_reg);
++>>>>>>> 9c7d1ee5f13a (scsi: cxlflash: Refactor context reset to share reset logic)
  	do {
- 		rrin = readq_be(&afu->host_map->ioarrin);
+ 		rrin = readq_be(reset_reg);
  		if (rrin != 0x1)
  			break;
  		/* Double delay each time */
@@@ -294,7 -216,18 +306,22 @@@
  }
  
  /**
++<<<<<<< HEAD
 + * send_cmd() - sends an AFU command
++=======
+  * context_reset_ioarrin() - reset command owner context via IOARRIN register
+  * @cmd:	AFU command that timed out.
+  */
+ static void context_reset_ioarrin(struct afu_cmd *cmd)
+ {
+ 	struct afu *afu = cmd->parent;
+ 
+ 	context_reset(cmd, &afu->host_map->ioarrin);
+ }
+ 
+ /**
+  * send_cmd_ioarrin() - sends an AFU command via IOARRIN register
++>>>>>>> 9c7d1ee5f13a (scsi: cxlflash: Refactor context reset to share reset logic)
   * @afu:	AFU associated with the host.
   * @cmd:	AFU command to send.
   *
* Unmerged path drivers/scsi/cxlflash/main.c
