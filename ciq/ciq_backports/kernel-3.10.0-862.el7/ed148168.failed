cls_cgroup: use tcf_exts_get_net() before call_rcu()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit ed1481681414e4d4264ad46864d5c1da5ff6ccb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ed148168.failed

Hold netns refcnt before call_rcu() and release it after
the tcf_exts_destroy() is done.

Note, on ->destroy() path we have to respect the return value
of tcf_exts_get_net(), on other paths it should always return
true, so we don't need to care.

	Cc: Lucas Bates <lucasb@mojatatu.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed1481681414e4d4264ad46864d5c1da5ff6ccb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_cgroup.c
diff --cc net/sched/cls_cgroup.c
index 7ce9e5eb9082,309d5899265f..000000000000
--- a/net/sched/cls_cgroup.c
+++ b/net/sched/cls_cgroup.c
@@@ -232,20 -125,18 +238,22 @@@ static int cls_cgroup_change(struct ne
  	if (err < 0)
  		goto errout;
  
 -	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &new->ematches);
 -	if (err < 0)
 +	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &t);
 +	if (err < 0) {
 +		tcf_exts_destroy(&e);
  		goto errout;
 +	}
 +
 +	tcf_exts_change(tp, &new->exts, &e);
 +	tcf_em_tree_change(tp, &new->ematches, &t);
  
  	rcu_assign_pointer(tp->root, new);
- 	if (head)
+ 	if (head) {
+ 		tcf_exts_get_net(&head->exts);
  		call_rcu(&head->rcu, cls_cgroup_destroy_rcu);
+ 	}
  	return 0;
  errout:
 -	tcf_exts_destroy(&new->exts);
  	kfree(new);
  	return err;
  }
@@@ -254,16 -145,16 +262,25 @@@ static bool cls_cgroup_destroy(struct t
  {
  	struct cls_cgroup_head *head = rtnl_dereference(tp->root);
  
 +	if (!force)
 +		return false;
 +
  	/* Head can still be NULL due to cls_cgroup_init(). */
++<<<<<<< HEAD
 +	if (head)
 +		call_rcu(&head->rcu, cls_cgroup_destroy_rcu);
 +	return true;
++=======
+ 	if (head) {
+ 		if (tcf_exts_get_net(&head->exts))
+ 			call_rcu(&head->rcu, cls_cgroup_destroy_rcu);
+ 		else
+ 			__cls_cgroup_destroy(head);
+ 	}
++>>>>>>> ed1481681414 (cls_cgroup: use tcf_exts_get_net() before call_rcu())
  }
  
 -static int cls_cgroup_delete(struct tcf_proto *tp, void *arg, bool *last)
 +static int cls_cgroup_delete(struct tcf_proto *tp, unsigned long arg)
  {
  	return -EOPNOTSUPP;
  }
* Unmerged path net/sched/cls_cgroup.c
