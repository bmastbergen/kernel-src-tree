IB/bnxt_re: Fix frame stack compilation warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Leon Romanovsky <leon@kernel.org>
commit e13547bc181ae6c279adf0df054717787f24ee89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e13547bc.failed

Reduce stack size by dynamically allocating memory instead
of declaring large struct on the stack:

drivers/infiniband/hw/bnxt_re/ib_verbs.c: In function ‘bnxt_re_query_qp’:
drivers/infiniband/hw/bnxt_re/ib_verbs.c:1600:1: warning: the frame size of 1216 bytes is larger than 1024 bytes [-Wframe-larger-than=]
 }
 ^

	Cc: Selvin Xavier <selvin.xavier@broadcom.com>
Fixes: 1ac5a4047975 ("RDMA/bnxt_re: Add bnxt_re RoCE driver")
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Acked-by: Selvin Xavier <selvin.xavier@broadcom.com>
	Reviewed-by: Jonathan Toppins <jtoppins@redhat.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e13547bc181ae6c279adf0df054717787f24ee89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/bnxt_re/ib_verbs.c
diff --cc drivers/infiniband/hw/bnxt_re/ib_verbs.c
index 33af2e3de399,03caf48af8e2..000000000000
--- a/drivers/infiniband/hw/bnxt_re/ib_verbs.c
+++ b/drivers/infiniband/hw/bnxt_re/ib_verbs.c
@@@ -1406,43 -1551,46 +1406,74 @@@ int bnxt_re_query_qp(struct ib_qp *ib_q
  {
  	struct bnxt_re_qp *qp = container_of(ib_qp, struct bnxt_re_qp, ib_qp);
  	struct bnxt_re_dev *rdev = qp->rdev;
- 	struct bnxt_qplib_qp qplib_qp;
+ 	struct bnxt_qplib_qp *qplib_qp;
  	int rc;
  
- 	memset(&qplib_qp, 0, sizeof(struct bnxt_qplib_qp));
- 	qplib_qp.id = qp->qplib_qp.id;
- 	qplib_qp.ah.host_sgid_index = qp->qplib_qp.ah.host_sgid_index;
+ 	qplib_qp = kzalloc(sizeof(*qplib_qp), GFP_KERNEL);
+ 	if (!qplib_qp)
+ 		return -ENOMEM;
+ 
+ 	qplib_qp->id = qp->qplib_qp.id;
+ 	qplib_qp->ah.host_sgid_index = qp->qplib_qp.ah.host_sgid_index;
  
- 	rc = bnxt_qplib_query_qp(&rdev->qplib_res, &qplib_qp);
+ 	rc = bnxt_qplib_query_qp(&rdev->qplib_res, qplib_qp);
  	if (rc) {
  		dev_err(rdev_to_dev(rdev), "Failed to query HW QP");
- 		return rc;
+ 		goto out;
  	}
++<<<<<<< HEAD
 +	qp_attr->qp_state = __to_ib_qp_state(qplib_qp.state);
 +	qp_attr->en_sqd_async_notify = qplib_qp.en_sqd_async_notify ? 1 : 0;
 +	qp_attr->qp_access_flags = __to_ib_access_flags(qplib_qp.access);
 +	qp_attr->pkey_index = qplib_qp.pkey_index;
 +	qp_attr->qkey = qplib_qp.qkey;
 +	memcpy(qp_attr->ah_attr.grh.dgid.raw, qplib_qp.ah.dgid.data,
 +	       sizeof(qplib_qp.ah.dgid.data));
 +	qp_attr->ah_attr.grh.flow_label = qplib_qp.ah.flow_label;
 +	qp_attr->ah_attr.grh.sgid_index = qplib_qp.ah.host_sgid_index;
 +	qp_attr->ah_attr.grh.hop_limit = qplib_qp.ah.hop_limit;
 +	qp_attr->ah_attr.grh.traffic_class = qplib_qp.ah.traffic_class;
 +	qp_attr->ah_attr.sl = qplib_qp.ah.sl;
 +	ether_addr_copy(qp_attr->ah_attr.dmac, qplib_qp.ah.dmac);
 +	qp_attr->path_mtu = __to_ib_mtu(qplib_qp.path_mtu);
 +	qp_attr->timeout = qplib_qp.timeout;
 +	qp_attr->retry_cnt = qplib_qp.retry_cnt;
 +	qp_attr->rnr_retry = qplib_qp.rnr_retry;
 +	qp_attr->min_rnr_timer = qplib_qp.min_rnr_timer;
 +	qp_attr->rq_psn = qplib_qp.rq.psn;
 +	qp_attr->max_rd_atomic = qplib_qp.max_rd_atomic;
 +	qp_attr->sq_psn = qplib_qp.sq.psn;
 +	qp_attr->max_dest_rd_atomic = qplib_qp.max_dest_rd_atomic;
 +	qp_init_attr->sq_sig_type = qplib_qp.sig_type ? IB_SIGNAL_ALL_WR :
 +							IB_SIGNAL_REQ_WR;
 +	qp_attr->dest_qp_num = qplib_qp.dest_qpn;
++=======
+ 	qp_attr->qp_state = __to_ib_qp_state(qplib_qp->state);
+ 	qp_attr->en_sqd_async_notify = qplib_qp->en_sqd_async_notify ? 1 : 0;
+ 	qp_attr->qp_access_flags = __to_ib_access_flags(qplib_qp->access);
+ 	qp_attr->pkey_index = qplib_qp->pkey_index;
+ 	qp_attr->qkey = qplib_qp->qkey;
+ 	qp_attr->ah_attr.type = RDMA_AH_ATTR_TYPE_ROCE;
+ 	rdma_ah_set_grh(&qp_attr->ah_attr, NULL, qplib_qp->ah.flow_label,
+ 			qplib_qp->ah.host_sgid_index,
+ 			qplib_qp->ah.hop_limit,
+ 			qplib_qp->ah.traffic_class);
+ 	rdma_ah_set_dgid_raw(&qp_attr->ah_attr, qplib_qp->ah.dgid.data);
+ 	rdma_ah_set_sl(&qp_attr->ah_attr, qplib_qp->ah.sl);
+ 	ether_addr_copy(qp_attr->ah_attr.roce.dmac, qplib_qp->ah.dmac);
+ 	qp_attr->path_mtu = __to_ib_mtu(qplib_qp->path_mtu);
+ 	qp_attr->timeout = qplib_qp->timeout;
+ 	qp_attr->retry_cnt = qplib_qp->retry_cnt;
+ 	qp_attr->rnr_retry = qplib_qp->rnr_retry;
+ 	qp_attr->min_rnr_timer = qplib_qp->min_rnr_timer;
+ 	qp_attr->rq_psn = qplib_qp->rq.psn;
+ 	qp_attr->max_rd_atomic = qplib_qp->max_rd_atomic;
+ 	qp_attr->sq_psn = qplib_qp->sq.psn;
+ 	qp_attr->max_dest_rd_atomic = qplib_qp->max_dest_rd_atomic;
+ 	qp_init_attr->sq_sig_type = qplib_qp->sig_type ? IB_SIGNAL_ALL_WR :
+ 							 IB_SIGNAL_REQ_WR;
+ 	qp_attr->dest_qp_num = qplib_qp->dest_qpn;
++>>>>>>> e13547bc181a (IB/bnxt_re: Fix frame stack compilation warning)
  
  	qp_attr->cap.max_send_wr = qp->qplib_qp.sq.max_wqe;
  	qp_attr->cap.max_send_sge = qp->qplib_qp.sq.max_sge;
* Unmerged path drivers/infiniband/hw/bnxt_re/ib_verbs.c
