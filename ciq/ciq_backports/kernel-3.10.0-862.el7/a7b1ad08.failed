nfp: allow allocation and initialization of netdev-less vNICs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit a7b1ad0875479e7390eb46e1190e50ffc39707b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a7b1ad08.failed

vNICs used for sending and receiving control messages shouldn't
really have a netdev.  Add the ability to initialize vNICs for
netdev-less operation.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a7b1ad0875479e7390eb46e1190e50ffc39707b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 600c79f39fe0,6b21c4d0ccfa..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -738,11 -831,13 +738,21 @@@ void nfp_net_get_fw_version(struct nfp_
  			    void __iomem *ctrl_bar);
  
  struct nfp_net *
++<<<<<<< HEAD
 +nfp_net_netdev_alloc(struct pci_dev *pdev,
 +		     unsigned int max_tx_rings, unsigned int max_rx_rings);
 +void nfp_net_netdev_free(struct nfp_net *nn);
 +int nfp_net_netdev_init(struct net_device *netdev);
 +void nfp_net_netdev_clean(struct net_device *netdev);
++=======
+ nfp_net_alloc(struct pci_dev *pdev, bool needs_netdev,
+ 	      unsigned int max_tx_rings, unsigned int max_rx_rings);
+ void nfp_net_free(struct nfp_net *nn);
+ 
+ int nfp_net_init(struct nfp_net *nn);
+ void nfp_net_clean(struct nfp_net *nn);
+ 
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  void nfp_net_set_ethtool_ops(struct net_device *netdev);
  void nfp_net_info(struct nfp_net *nn);
  int nfp_net_reconfig(struct nfp_net *nn, u32 update);
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,1cc7425ffd27..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1551,11 -1820,9 +1551,17 @@@ static int nfp_net_tx_ring_alloc(struc
  	if (!tx_ring->txbufs)
  		goto err_alloc;
  
++<<<<<<< HEAD
 +	netif_set_xps_queue(nn->netdev, &r_vec->affinity_mask, tx_ring->idx);
 +
 +	nn_dbg(nn, "TxQ%02d: QCidx=%02d cnt=%d dma=%#llx host=%p\n",
 +	       tx_ring->idx, tx_ring->qcidx,
 +	       tx_ring->cnt, (unsigned long long)tx_ring->dma, tx_ring->txds);
++=======
+ 	if (!tx_ring->is_xdp && dp->netdev)
+ 		netif_set_xps_queue(dp->netdev, &r_vec->affinity_mask,
+ 				    tx_ring->idx);
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  
  	return 0;
  
@@@ -2651,8 -3032,9 +2657,9 @@@ void nfp_net_info(struct nfp_net *nn
  }
  
  /**
 - * nfp_net_alloc() - Allocate netdev and related structure
 + * nfp_net_netdev_alloc() - Allocate netdev and related structure
   * @pdev:         PCI device
+  * @needs_netdev: Whether to allocate a netdev for this vNIC
   * @max_tx_rings: Maximum number of TX rings supported by device
   * @max_rx_rings: Maximum number of RX rings supported by device
   *
@@@ -2661,22 -3044,30 +2669,40 @@@
   *
   * Return: NFP Net device structure, or ERR_PTR on error.
   */
++<<<<<<< HEAD
 +struct nfp_net *nfp_net_netdev_alloc(struct pci_dev *pdev,
 +				     unsigned int max_tx_rings,
 +				     unsigned int max_rx_rings)
++=======
+ struct nfp_net *nfp_net_alloc(struct pci_dev *pdev, bool needs_netdev,
+ 			      unsigned int max_tx_rings,
+ 			      unsigned int max_rx_rings)
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  {
- 	struct net_device *netdev;
  	struct nfp_net *nn;
  
- 	netdev = alloc_etherdev_mqs(sizeof(struct nfp_net),
- 				    max_tx_rings, max_rx_rings);
- 	if (!netdev)
- 		return ERR_PTR(-ENOMEM);
+ 	if (needs_netdev) {
+ 		struct net_device *netdev;
+ 
+ 		netdev = alloc_etherdev_mqs(sizeof(struct nfp_net),
+ 					    max_tx_rings, max_rx_rings);
+ 		if (!netdev)
+ 			return ERR_PTR(-ENOMEM);
  
- 	SET_NETDEV_DEV(netdev, &pdev->dev);
- 	nn = netdev_priv(netdev);
+ 		SET_NETDEV_DEV(netdev, &pdev->dev);
+ 		nn = netdev_priv(netdev);
+ 		nn->dp.netdev = netdev;
+ 	} else {
+ 		nn = vzalloc(sizeof(*nn));
+ 		if (!nn)
+ 			return ERR_PTR(-ENOMEM);
+ 	}
  
++<<<<<<< HEAD
 +	nn->netdev = netdev;
++=======
+ 	nn->dp.dev = &pdev->dev;
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  	nn->pdev = pdev;
  
  	nn->max_tx_rings = max_tx_rings;
@@@ -2702,12 -3095,36 +2728,40 @@@
  }
  
  /**
 - * nfp_net_free() - Undo what @nfp_net_alloc() did
 + * nfp_net_netdev_free() - Undo what @nfp_net_netdev_alloc() did
   * @nn:      NFP Net device to reconfigure
   */
 -void nfp_net_free(struct nfp_net *nn)
 +void nfp_net_netdev_free(struct nfp_net *nn)
  {
++<<<<<<< HEAD
 +	free_netdev(nn->netdev);
++=======
+ 	if (nn->dp.netdev)
+ 		free_netdev(nn->dp.netdev);
+ 	else
+ 		vfree(nn);
+ }
+ 
+ /**
+  * nfp_net_rss_key_sz() - Get current size of the RSS key
+  * @nn:		NFP Net device instance
+  *
+  * Return: size of the RSS key for currently selected hash function.
+  */
+ unsigned int nfp_net_rss_key_sz(struct nfp_net *nn)
+ {
+ 	switch (nn->rss_hfunc) {
+ 	case ETH_RSS_HASH_TOP:
+ 		return NFP_NET_CFG_RSS_KEY_SZ;
+ 	case ETH_RSS_HASH_XOR:
+ 		return 0;
+ 	case ETH_RSS_HASH_CRC32:
+ 		return 4;
+ 	}
+ 
+ 	nn_warn(nn, "Unknown hash function: %u\n", nn->rss_hfunc);
+ 	return 0;
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  }
  
  /**
@@@ -2739,35 -3174,13 +2793,45 @@@ static void nfp_net_irqmod_init(struct 
  	nn->tx_coalesce_max_frames = 64;
  }
  
++<<<<<<< HEAD
 +/**
 + * nfp_net_netdev_init() - Initialise/finalise the netdev structure
 + * @netdev:      netdev structure
 + *
 + * Return: 0 on success or negative errno on error.
 + */
 +int nfp_net_netdev_init(struct net_device *netdev)
 +{
 +	struct nfp_net *nn = netdev_priv(netdev);
 +	int err;
 +
 +	/* Get some of the read-only fields from the BAR */
 +	nn->cap = nn_readl(nn, NFP_NET_CFG_CAP);
 +	nn->max_mtu = nn_readl(nn, NFP_NET_CFG_MAX_MTU);
 +
 +	nfp_net_write_mac_addr(nn);
 +
 +	/* Determine RX packet/metadata boundary offset */
 +	if (nn->fw_ver.major >= 2)
 +		nn->rx_offset = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
 +	else
 +		nn->rx_offset = NFP_NET_RX_OFFSET;
 +
 +	/* Set default MTU and Freelist buffer size */
 +	if (nn->max_mtu < NFP_NET_DEFAULT_MTU)
 +		netdev->mtu = nn->max_mtu;
 +	else
 +		netdev->mtu = NFP_NET_DEFAULT_MTU;
 +	nn->fl_bufsz = nfp_net_calc_fl_bufsz(nn, netdev->mtu);
++=======
+ static void nfp_net_netdev_init(struct nfp_net *nn)
+ {
+ 	struct net_device *netdev = nn->dp.netdev;
+ 
+ 	nfp_net_write_mac_addr(nn, nn->dp.netdev->dev_addr);
+ 
+ 	netdev->mtu = nn->dp.mtu;
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  
  	/* Advertise/enable offloads based on capabilities
  	 *
@@@ -2786,17 -3202,16 +2850,22 @@@
  	}
  	if (nn->cap & NFP_NET_CFG_CTRL_GATHER) {
  		netdev->hw_features |= NETIF_F_SG;
 -		nn->dp.ctrl |= NFP_NET_CFG_CTRL_GATHER;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_GATHER;
  	}
 -	if ((nn->cap & NFP_NET_CFG_CTRL_LSO && nn->fw_ver.major > 2) ||
 -	    nn->cap & NFP_NET_CFG_CTRL_LSO2) {
 +	if ((nn->cap & NFP_NET_CFG_CTRL_LSO) && nn->fw_ver.major > 2) {
  		netdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
 -		nn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_LSO2 ?:
 -					 NFP_NET_CFG_CTRL_LSO;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_LSO;
  	}
++<<<<<<< HEAD
 +	if (nn->cap & NFP_NET_CFG_CTRL_RSS) {
 +		netdev->hw_features |= NETIF_F_RXHASH;
 +		nfp_net_rss_init(nn);
 +		nn->ctrl |= NFP_NET_CFG_CTRL_RSS;
 +	}
++=======
+ 	if (nn->cap & NFP_NET_CFG_CTRL_RSS_ANY)
+ 		netdev->hw_features |= NETIF_F_RXHASH;
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  	if (nn->cap & NFP_NET_CFG_CTRL_VXLAN &&
  	    nn->cap & NFP_NET_CFG_CTRL_NVGRE) {
  		if (nn->cap & NFP_NET_CFG_CTRL_LSO)
@@@ -2820,22 -3239,90 +2889,87 @@@
  
  	netdev->features = netdev->hw_features;
  
 -	if (nfp_app_has_tc(nn->app))
 -		netdev->hw_features |= NETIF_F_HW_TC;
 -
  	/* Advertise but disable TSO by default. */
  	netdev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
 -	nn->dp.ctrl &= ~NFP_NET_CFG_CTRL_LSO_ANY;
 +	nn->dp.ctrl &= ~NFP_NET_CFG_CTRL_LSO;
  
+ 	/* Finalise the netdev setup */
+ 	netdev->netdev_ops = &nfp_net_netdev_ops;
+ 	netdev->watchdog_timeo = msecs_to_jiffies(5 * 1000);
+ 
+ 	/* MTU range: 68 - hw-specific max */
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	netdev->max_mtu = nn->max_mtu;
+ 
+ 	netif_carrier_off(netdev);
+ 
+ 	nfp_net_set_ethtool_ops(netdev);
+ }
+ 
+ /**
+  * nfp_net_init() - Initialise/finalise the nfp_net structure
+  * @nn:		NFP Net device structure
+  *
+  * Return: 0 on success or negative errno on error.
+  */
+ int nfp_net_init(struct nfp_net *nn)
+ {
+ 	int err;
+ 
+ 	nn->dp.rx_dma_dir = DMA_FROM_DEVICE;
+ 
+ 	/* Get some of the read-only fields from the BAR */
+ 	nn->cap = nn_readl(nn, NFP_NET_CFG_CAP);
+ 	nn->max_mtu = nn_readl(nn, NFP_NET_CFG_MAX_MTU);
+ 
+ 	/* Chained metadata is signalled by capabilities except in version 4 */
+ 	nn->dp.chained_metadata_format = nn->fw_ver.major == 4 ||
+ 					 nn->cap & NFP_NET_CFG_CTRL_CHAIN_META;
+ 	if (nn->dp.chained_metadata_format && nn->fw_ver.major != 4)
+ 		nn->cap &= ~NFP_NET_CFG_CTRL_RSS;
+ 
+ 	/* Determine RX packet/metadata boundary offset */
+ 	if (nn->fw_ver.major >= 2) {
+ 		u32 reg;
+ 
+ 		reg = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
+ 		if (reg > NFP_NET_MAX_PREPEND) {
+ 			nn_err(nn, "Invalid rx offset: %d\n", reg);
+ 			return -EINVAL;
+ 		}
+ 		nn->dp.rx_offset = reg;
+ 	} else {
+ 		nn->dp.rx_offset = NFP_NET_RX_OFFSET;
+ 	}
+ 
+ 	/* Set default MTU and Freelist buffer size */
+ 	if (nn->max_mtu < NFP_NET_DEFAULT_MTU)
+ 		nn->dp.mtu = nn->max_mtu;
+ 	else
+ 		nn->dp.mtu = NFP_NET_DEFAULT_MTU;
+ 	nn->dp.fl_bufsz = nfp_net_calc_fl_bufsz(&nn->dp);
+ 
+ 	if (nn->cap & NFP_NET_CFG_CTRL_RSS_ANY) {
+ 		nfp_net_rss_init(nn);
+ 		nn->dp.ctrl |= nn->cap & NFP_NET_CFG_CTRL_RSS2 ?:
+ 					 NFP_NET_CFG_CTRL_RSS;
+ 	}
+ 
  	/* Allow L2 Broadcast and Multicast through by default, if supported */
  	if (nn->cap & NFP_NET_CFG_CTRL_L2BC)
 -		nn->dp.ctrl |= NFP_NET_CFG_CTRL_L2BC;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_L2BC;
  	if (nn->cap & NFP_NET_CFG_CTRL_L2MC)
 -		nn->dp.ctrl |= NFP_NET_CFG_CTRL_L2MC;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_L2MC;
  
  	/* Allow IRQ moderation, if supported */
  	if (nn->cap & NFP_NET_CFG_CTRL_IRQMOD) {
  		nfp_net_irqmod_init(nn);
 -		nn->dp.ctrl |= NFP_NET_CFG_CTRL_IRQMOD;
 +		nn->ctrl |= NFP_NET_CFG_CTRL_IRQMOD;
  	}
  
+ 	if (nn->dp.netdev)
+ 		nfp_net_netdev_init(nn);
+ 
  	/* Stash the re-configuration queue away.  First odd queue in TX Bar */
  	nn->qcp_cfg = nn->tx_bar + NFP_QCP_QUEUE_ADDR_SZ;
  
@@@ -2848,22 -3335,24 +2982,38 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	/* Finalise the netdev setup */
 +	netdev->netdev_ops = &nfp_net_netdev_ops;
 +	netdev->watchdog_timeo = msecs_to_jiffies(5 * 1000);
 +	netif_carrier_off(netdev);
 +
 +	nfp_net_set_ethtool_ops(netdev);
 +	nfp_net_vecs_init(netdev);
++=======
+ 	nfp_net_vecs_init(nn);
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  
- 	return register_netdev(netdev);
+ 	if (!nn->dp.netdev)
+ 		return 0;
+ 	return register_netdev(nn->dp.netdev);
  }
  
  /**
 - * nfp_net_clean() - Undo what nfp_net_init() did.
 - * @nn:		NFP Net device structure
 + * nfp_net_netdev_clean() - Undo what nfp_net_netdev_init() did.
 + * @netdev:      netdev structure
   */
 -void nfp_net_clean(struct nfp_net *nn)
 +void nfp_net_netdev_clean(struct net_device *netdev)
  {
++<<<<<<< HEAD
 +	unregister_netdev(netdev);
++=======
+ 	if (!nn->dp.netdev)
+ 		return;
+ 
+ 	unregister_netdev(nn->dp.netdev);
+ 
+ 	if (nn->dp.xdp_prog)
+ 		bpf_prog_put(nn->dp.xdp_prog);
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  }
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,dd2a99fca716..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -281,9 -303,11 +281,17 @@@ static void nfp_net_pf_free_netdevs(str
  }
  
  static struct nfp_net *
++<<<<<<< HEAD
 +nfp_net_pf_alloc_port_netdev(struct nfp_pf *pf, void __iomem *ctrl_bar,
 +			     void __iomem *tx_bar, void __iomem *rx_bar,
 +			     int stride, struct nfp_net_fw_version *fw_ver)
++=======
+ nfp_net_pf_alloc_vnic(struct nfp_pf *pf, bool needs_netdev,
+ 		      void __iomem *ctrl_bar,
+ 		      void __iomem *tx_bar, void __iomem *rx_bar,
+ 		      int stride, struct nfp_net_fw_version *fw_ver,
+ 		      unsigned int eth_id)
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  {
  	u32 n_tx_rings, n_rx_rings;
  	struct nfp_net *nn;
@@@ -291,8 -316,8 +299,13 @@@
  	n_tx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_TXRINGS);
  	n_rx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_RXRINGS);
  
++<<<<<<< HEAD
 +	/* Allocate and initialise the netdev */
 +	nn = nfp_net_netdev_alloc(pf->pdev, n_tx_rings, n_rx_rings);
++=======
+ 	/* Allocate and initialise the vNIC */
+ 	nn = nfp_net_alloc(pf->pdev, needs_netdev, n_tx_rings, n_rx_rings);
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  	if (IS_ERR(nn))
  		return nn;
  
@@@ -355,8 -396,8 +368,13 @@@ nfp_net_pf_alloc_netdevs(struct nfp_pf 
  		prev_tx_base = tgt_tx_base;
  		prev_rx_base = tgt_rx_base;
  
++<<<<<<< HEAD
 +		nn = nfp_net_pf_alloc_port_netdev(pf, ctrl_bar, tx_bar, rx_bar,
 +						  stride, fw_ver);
++=======
+ 		nn = nfp_net_pf_alloc_vnic(pf, true, ctrl_bar, tx_bar, rx_bar,
+ 					   stride, fw_ver, i);
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  		if (IS_ERR(nn)) {
  			err = PTR_ERR(nn);
  			goto err_free_prev;
diff --cc drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
index bd3cf87f2365,0bf3b0febd07..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
@@@ -201,7 -202,7 +201,11 @@@ static int nfp_netvf_pci_probe(struct p
  	rx_bar_off = NFP_PCIE_QUEUE(startq);
  
  	/* Allocate and initialise the netdev */
++<<<<<<< HEAD
 +	nn = nfp_net_netdev_alloc(pdev, max_tx_rings, max_rx_rings);
++=======
+ 	nn = nfp_net_alloc(pdev, true, max_tx_rings, max_rx_rings);
++>>>>>>> a7b1ad087547 (nfp: allow allocation and initialization of netdev-less vNICs)
  	if (IS_ERR(nn)) {
  		err = PTR_ERR(nn);
  		goto err_ctrl_unmap;
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
