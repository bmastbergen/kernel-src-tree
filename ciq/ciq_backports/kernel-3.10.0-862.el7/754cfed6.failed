ext4: drop the EXT4_STATE_DELALLOC_RESERVED flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 754cfed6bbcfdea6afb14f2686f7f8d71e94d4e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/754cfed6.failed

Having done a full regression test, we can now drop the
DELALLOC_RESERVED state flag.

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 754cfed6bbcfdea6afb14f2686f7f8d71e94d4e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/mballoc.c
diff --cc fs/ext4/mballoc.c
index 343f1ad2e4b3,65cca2881d71..000000000000
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@@ -4417,14 -4410,7 +4417,18 @@@ ext4_fsblk_t ext4_mb_new_blocks(handle_
  	if (IS_NOQUOTA(ar->inode))
  		ar->flags |= EXT4_MB_USE_ROOT_BLOCKS;
  
++<<<<<<< HEAD
 +	/*
 +	 * For delayed allocation, we could skip the ENOSPC and
 +	 * EDQUOT check, as blocks and quotas have been already
 +	 * reserved when data being copied into pagecache.
 +	 */
 +	if (ext4_test_inode_state(ar->inode, EXT4_STATE_DELALLOC_RESERVED))
 +		ar->flags |= EXT4_MB_DELALLOC_RESERVED;
 +	else {
++=======
+ 	if ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {
++>>>>>>> 754cfed6bbcf (ext4: drop the EXT4_STATE_DELALLOC_RESERVED flag)
  		/* Without delayed allocation we need to verify
  		 * there is enough free blocks to do block allocation
  		 * and verify allocation doesn't exceed the quota limits.
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index beaca043ea50..1608d23b8a4c 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1464,7 +1464,6 @@ enum {
 	EXT4_STATE_EXT_MIGRATE,		/* Inode is migrating */
 	EXT4_STATE_DIO_UNWRITTEN,	/* need convert on dio done*/
 	EXT4_STATE_NEWENTRY,		/* File just added to dir */
-	EXT4_STATE_DELALLOC_RESERVED,	/* blks already reserved for delalloc */
 	EXT4_STATE_DIOREAD_LOCK,	/* Disable support for dio read
 					   nolocking */
 	EXT4_STATE_MAY_INLINE_DATA,	/* may have in-inode data */
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index e633520ebfef..b7b386c01526 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -601,14 +601,6 @@ found:
 	 */
 	down_write(&EXT4_I(inode)->i_data_sem);
 
-	/*
-	 * if the caller is from delayed allocation writeout path
-	 * we have already reserved fs blocks for allocation
-	 * let the underlying get_block() function know to
-	 * avoid double accounting
-	 */
-	if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)
-		ext4_set_inode_state(inode, EXT4_STATE_DELALLOC_RESERVED);
 	/*
 	 * We need to check for EXT4 here because migrate
 	 * could have changed the inode type in between
@@ -637,8 +629,6 @@ found:
 			(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))
 			ext4_da_update_reserve_space(inode, retval, 1);
 	}
-	if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)
-		ext4_clear_inode_state(inode, EXT4_STATE_DELALLOC_RESERVED);
 
 	if (retval > 0) {
 		unsigned int status;
@@ -2096,12 +2086,10 @@ static int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)
 	 * in data loss.  So use reserved blocks to allocate metadata if
 	 * possible.
 	 *
-	 * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if the blocks
-	 * in question are delalloc blocks.  This affects functions in many
-	 * different parts of the allocation call path.  This flag exists
-	 * primarily because we don't want to change *many* call functions, so
-	 * ext4_map_blocks() will set the EXT4_STATE_DELALLOC_RESERVED flag
-	 * once the inode's allocation semaphore is taken.
+	 * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if
+	 * the blocks in question are delalloc blocks.  This indicates
+	 * that the blocks and quotas has already been checked when
+	 * the data was copied into the page cache.
 	 */
 	get_blocks_flags = EXT4_GET_BLOCKS_CREATE |
 			   EXT4_GET_BLOCKS_METADATA_NOFAIL;
* Unmerged path fs/ext4/mballoc.c
