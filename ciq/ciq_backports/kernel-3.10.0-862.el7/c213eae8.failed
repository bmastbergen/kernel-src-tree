bnxt_en: Improve VF/PF link change logic.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Improve VF/PF link change logic (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.77%
commit-author Michael Chan <michael.chan@broadcom.com>
commit c213eae8d3cd4c026f348ce4fd64f4754b3acf2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c213eae8.failed

Link status query firmware messages originating from the VFs are forwarded
to the PF.  The driver handles these interactions in a workqueue for the
VF and PF.  The VF driver waits for the response from the PF in the
workqueue.  If the PF and VF driver are running on the same host and the
work for both PF and VF are queued on the same workqueue, the VF driver
may not get the response if the PF work item is queued behind it on the
same workqueue.  This will lead to the VF link query message timing out.

To prevent this, we create a private workqueue for PFs instead of using
the common workqueue.  The VF query and PF response will never be on
the same workqueue.

Fixes: c0c050c58d84 ("bnxt_en: New Broadcom ethernet driver.")
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c213eae8d3cd4c026f348ce4fd64f4754b3acf2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index c38e088f3a51,7906153c5c05..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -7183,11 -7590,106 +7201,11 @@@ static void bnxt_udp_tunnel_del(struct 
  		return;
  	}
  
- 	schedule_work(&bp->sp_task);
+ 	bnxt_queue_sp_work(bp);
  }
  
 -static int bnxt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 -			       struct net_device *dev, u32 filter_mask,
 -			       int nlflags)
 -{
 -	struct bnxt *bp = netdev_priv(dev);
 -
 -	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, bp->br_mode, 0, 0,
 -				       nlflags, filter_mask, NULL);
 -}
 -
 -static int bnxt_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
 -			       u16 flags)
 -{
 -	struct bnxt *bp = netdev_priv(dev);
 -	struct nlattr *attr, *br_spec;
 -	int rem, rc = 0;
 -
 -	if (bp->hwrm_spec_code < 0x10708 || !BNXT_SINGLE_PF(bp))
 -		return -EOPNOTSUPP;
 -
 -	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
 -	if (!br_spec)
 -		return -EINVAL;
 -
 -	nla_for_each_nested(attr, br_spec, rem) {
 -		u16 mode;
 -
 -		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 -			continue;
 -
 -		if (nla_len(attr) < sizeof(mode))
 -			return -EINVAL;
 -
 -		mode = nla_get_u16(attr);
 -		if (mode == bp->br_mode)
 -			break;
 -
 -		rc = bnxt_hwrm_set_br_mode(bp, mode);
 -		if (!rc)
 -			bp->br_mode = mode;
 -		break;
 -	}
 -	return rc;
 -}
 -
 -static int bnxt_get_phys_port_name(struct net_device *dev, char *buf,
 -				   size_t len)
 -{
 -	struct bnxt *bp = netdev_priv(dev);
 -	int rc;
 -
 -	/* The PF and it's VF-reps only support the switchdev framework */
 -	if (!BNXT_PF(bp))
 -		return -EOPNOTSUPP;
 -
 -	rc = snprintf(buf, len, "p%d", bp->pf.port_id);
 -
 -	if (rc >= len)
 -		return -EOPNOTSUPP;
 -	return 0;
 -}
 -
 -int bnxt_port_attr_get(struct bnxt *bp, struct switchdev_attr *attr)
 -{
 -	if (bp->eswitch_mode != DEVLINK_ESWITCH_MODE_SWITCHDEV)
 -		return -EOPNOTSUPP;
 -
 -	/* The PF and it's VF-reps only support the switchdev framework */
 -	if (!BNXT_PF(bp))
 -		return -EOPNOTSUPP;
 -
 -	switch (attr->id) {
 -	case SWITCHDEV_ATTR_ID_PORT_PARENT_ID:
 -		/* In SRIOV each PF-pool (PF + child VFs) serves as a
 -		 * switching domain, the PF's perm mac-addr can be used
 -		 * as the unique parent-id
 -		 */
 -		attr->u.ppid.id_len = ETH_ALEN;
 -		ether_addr_copy(attr->u.ppid.id, bp->pf.mac_addr);
 -		break;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -	return 0;
 -}
 -
 -static int bnxt_swdev_port_attr_get(struct net_device *dev,
 -				    struct switchdev_attr *attr)
 -{
 -	return bnxt_port_attr_get(netdev_priv(dev), attr);
 -}
 -
 -static const struct switchdev_ops bnxt_switchdev_ops = {
 -	.switchdev_port_attr_get	= bnxt_swdev_port_attr_get
 -};
 -
  static const struct net_device_ops bnxt_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= bnxt_open,
  	.ndo_start_xmit		= bnxt_start_xmit,
  	.ndo_stop		= bnxt_close,
@@@ -7229,7 -7735,10 +7247,12 @@@ static void bnxt_remove_one(struct pci_
  
  	pci_disable_pcie_error_reporting(pdev);
  	unregister_netdev(dev);
++<<<<<<< HEAD
 +	cancel_work_sync(&bp->sp_task);
++=======
+ 	bnxt_shutdown_tc(bp);
+ 	bnxt_cancel_sp_work(bp);
++>>>>>>> c213eae8d3cd (bnxt_en: Improve VF/PF link change logic.)
  	bp->sp_event = 0;
  
  	bnxt_clear_int_mode(bp);
@@@ -7626,9 -8156,24 +7649,24 @@@ static int bnxt_init_one(struct pci_de
  	else
  		device_set_wakeup_capable(&pdev->dev, false);
  
++<<<<<<< HEAD
++=======
+ 	if (BNXT_PF(bp)) {
+ 		if (!bnxt_pf_wq) {
+ 			bnxt_pf_wq =
+ 				create_singlethread_workqueue("bnxt_pf_wq");
+ 			if (!bnxt_pf_wq) {
+ 				dev_err(&pdev->dev, "Unable to create workqueue.\n");
+ 				goto init_err_pci_clean;
+ 			}
+ 		}
+ 		bnxt_init_tc(bp);
+ 	}
+ 
++>>>>>>> c213eae8d3cd (bnxt_en: Improve VF/PF link change logic.)
  	rc = register_netdev(dev);
  	if (rc)
 -		goto init_err_cleanup_tc;
 -
 -	if (BNXT_PF(bp))
 -		bnxt_dl_register(bp);
 +		goto init_err_clr_int;
  
  	netdev_info(dev, "%s found at mem %lx, node addr %pM\n",
  		    board_info[ent->driver_data].name,
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
