ACPI / sysfs: Provide quirk mechanism to prevent GPE flooding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Lv Zheng <lv.zheng@intel.com>
commit 9c4aa1eecb48cfac18ed5e3aca9d9ae58fbafc11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9c4aa1ee.failed

Sometimes, the users may require a quirk to be provided from ACPI subsystem
core to prevent a GPE from flooding.
Normally, if a GPE cannot be dispatched, ACPICA core automatically prevents
the GPE from firing. But there are cases the GPE is dispatched by _Lxx/_Exx
provided via AML table, and OSPM is lacking of the knowledge to get
_Lxx/_Exx correctly executed to handle the GPE, thus the GPE flooding may
still occur.

The existing quirk mechanism can be enabled/disabled using the following
commands to prevent such kind of GPE flooding during runtime:
 # echo mask > /sys/firmware/acpi/interrupts/gpe00
 # echo unmask > /sys/firmware/acpi/interrupts/gpe00
To avoid GPE flooding during boot, we need a boot stage mechanism.

This patch provides such a boot stage quirk mechanism to stop this kind of
GPE flooding. This patch doesn't fix any feature gap but since the new
feature gaps could be found in the future endlessly, and can disappear if
the feature gaps are filled, providing a boot parameter rather than a DMI
table should suffice.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=53071
Link: https://bugzilla.kernel.org/show_bug.cgi?id=117481
Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/887793
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 9c4aa1eecb48cfac18ed5e3aca9d9ae58fbafc11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
#	drivers/acpi/internal.h
diff --cc Documentation/kernel-parameters.txt
index f004a8ce83ef,d1eec5ed1134..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -235,6 -106,27 +235,30 @@@ bytes respectively. Such letter suffixe
  			use by PCI
  			Format: <irq>,<irq>...
  
++<<<<<<< HEAD:Documentation/kernel-parameters.txt
++=======
+ 	acpi_mask_gpe=  [HW,ACPI]
+ 			Due to the existence of _Lxx/_Exx, some GPEs triggered
+ 			by unsupported hardware/firmware features can result in
+                         GPE floodings that cannot be automatically disabled by
+                         the GPE dispatcher.
+ 			This facility can be used to prevent such uncontrolled
+ 			GPE floodings.
+ 			Format: <int>
+ 			Support masking of GPEs numbered from 0x00 to 0x7f.
+ 
+ 	acpi_no_auto_serialize	[HW,ACPI]
+ 			Disable auto-serialization of AML methods
+ 			AML control methods that contain the opcodes to create
+ 			named objects will be marked as "Serialized" by the
+ 			auto-serialization feature.
+ 			This feature is enabled by default.
+ 			This option allows to turn off the feature.
+ 
+ 	acpi_no_memhotplug [ACPI] Disable memory hotplug.  Useful for kdump
+ 			   kernels.
+ 
++>>>>>>> 9c4aa1eecb48 (ACPI / sysfs: Provide quirk mechanism to prevent GPE flooding):Documentation/admin-guide/kernel-parameters.txt
  	acpi_no_static_ssdt	[HW,ACPI]
  			Disable installation of static SSDTs at early boot time
  			By default, SSDTs contained in the RSDT/XSDT will be
diff --cc drivers/acpi/internal.h
index 89492f3bf8ce,0c452265c111..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -32,11 -31,19 +32,15 @@@ void acpi_processor_init(void)
  void acpi_platform_init(void);
  void acpi_pnp_init(void);
  void acpi_int340x_thermal_init(void);
 -#ifdef CONFIG_ARM_AMBA
 -void acpi_amba_init(void);
 -#else
 -static inline void acpi_amba_init(void) {}
 -#endif
  int acpi_sysfs_init(void);
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI_CONTAINER
++=======
+ void acpi_gpe_apply_masked_gpes(void);
++>>>>>>> 9c4aa1eecb48 (ACPI / sysfs: Provide quirk mechanism to prevent GPE flooding)
  void acpi_container_init(void);
 -void acpi_memory_hotplug_init(void);
 -#ifdef	CONFIG_ACPI_HOTPLUG_IOAPIC
 -int acpi_ioapic_remove(struct acpi_pci_root *root);
  #else
 -static inline int acpi_ioapic_remove(struct acpi_pci_root *root) { return 0; }
 +static inline void acpi_container_init(void) {}
  #endif
  #ifdef CONFIG_ACPI_DOCK
  void register_dock_dependent_device(struct acpi_device *adev,
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path drivers/acpi/internal.h
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index f22337d9eb20..e0d8351d1665 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2019,6 +2019,7 @@ int __init acpi_scan_init(void)
 		goto out;
 	}
 
+	acpi_gpe_apply_masked_gpes();
 	acpi_update_all_gpes();
 
  out:
diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 43ed9e8705c7..efb17db87e39 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -620,6 +620,62 @@ end:
 	return result ? result : size;
 }
 
+/*
+ * A Quirk Mechanism for GPE Flooding Prevention:
+ *
+ * Quirks may be needed to prevent GPE flooding on a specific GPE. The
+ * flooding typically cannot be detected and automatically prevented by
+ * ACPI_GPE_DISPATCH_NONE check because there is a _Lxx/_Exx prepared in
+ * the AML tables. This normally indicates a feature gap in Linux, thus
+ * instead of providing endless quirk tables, we provide a boot parameter
+ * for those who want this quirk. For example, if the users want to prevent
+ * the GPE flooding for GPE 00, they need to specify the following boot
+ * parameter:
+ *   acpi_mask_gpe=0x00
+ * The masking status can be modified by the following runtime controlling
+ * interface:
+ *   echo unmask > /sys/firmware/acpi/interrupts/gpe00
+ */
+
+/*
+ * Currently, the GPE flooding prevention only supports to mask the GPEs
+ * numbered from 00 to 7f.
+ */
+#define ACPI_MASKABLE_GPE_MAX	0x80
+
+static u64 __initdata acpi_masked_gpes;
+
+static int __init acpi_gpe_set_masked_gpes(char *val)
+{
+	u8 gpe;
+
+	if (kstrtou8(val, 0, &gpe) || gpe > ACPI_MASKABLE_GPE_MAX)
+		return -EINVAL;
+	acpi_masked_gpes |= ((u64)1<<gpe);
+
+	return 1;
+}
+__setup("acpi_mask_gpe=", acpi_gpe_set_masked_gpes);
+
+void __init acpi_gpe_apply_masked_gpes(void)
+{
+	acpi_handle handle;
+	acpi_status status;
+	u8 gpe;
+
+	for (gpe = 0;
+	     gpe < min_t(u8, ACPI_MASKABLE_GPE_MAX, acpi_current_gpe_count);
+	     gpe++) {
+		if (acpi_masked_gpes & ((u64)1<<gpe)) {
+			status = acpi_get_gpe_device(gpe, &handle);
+			if (ACPI_SUCCESS(status)) {
+				pr_info("Masking GPE 0x%x.\n", gpe);
+				(void)acpi_mask_gpe(handle, gpe, TRUE);
+			}
+		}
+	}
+}
+
 void acpi_irq_stats_init(void)
 {
 	acpi_status status;
