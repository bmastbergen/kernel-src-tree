dmi: Mark all struct dmi_system_id instances const

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: dmi: Mark all struct dmi_system_id instances const (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 94.34%
commit-author Christoph Hellwig <hch@lst.de>
commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6faadbbb.failed

... and __initconst if applicable.

Based on similar work for an older kernel in the Grsecurity patch.

[JD: fix toshiba-wmi build]
[JD: add htcpen]
[JD: move __initconst where checkscript wants it]

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jean Delvare <jdelvare@suse.de>
(cherry picked from commit 6faadbbb7f9da70ce484f98f72223c20125a1009)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/reboot.c
#	arch/x86/power/cpu.c
#	drivers/acpi/blacklist.c
#	drivers/acpi/ec.c
#	drivers/acpi/osi.c
#	drivers/acpi/processor_pdc.c
#	drivers/acpi/sleep.c
#	drivers/acpi/video.c
#	drivers/firmware/google/memconsole-x86-legacy.c
#	drivers/hwmon/dell-smm-hwmon.c
#	drivers/input/touchscreen/htcpen.c
#	drivers/leds/leds-clevo-mail.c
#	drivers/leds/leds-ss4200.c
#	drivers/mfd/kempld-core.c
#	drivers/net/ethernet/via/via-rhine.c
#	drivers/pci/quirks.c
#	drivers/platform/chrome/chromeos_laptop.c
#	drivers/platform/chrome/chromeos_pstore.c
#	drivers/platform/chrome/cros_ec_lpc.c
#	drivers/platform/x86/mlx-platform.c
#	drivers/platform/x86/toshiba-wmi.c
#	drivers/tty/serial/pch_uart.c
#	drivers/video/backlight/kb3886_bl.c
diff --cc arch/x86/kernel/reboot.c
index 0a4f24da8fee,54180fa6f66f..000000000000
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@@ -224,254 -150,309 +224,258 @@@ static int __init set_kbd_reboot(const 
  /*
   * This is a single dmi_table handling all reboot quirks.
   */
 -static const struct dmi_system_id reboot_dmi_table[] __initconst = {
 -
 -	/* Acer */
 -	{	/* Handle reboot issue on Acer Aspire one */
 -		.callback = set_kbd_reboot,
 -		.ident = "Acer Aspire One A110",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "AOA110"),
 -		},
 -	},
 -
 -	/* Apple */
 -	{	/* Handle problems with rebooting on Apple MacBook5 */
 -		.callback = set_pci_reboot,
 -		.ident = "Apple MacBook5",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "MacBook5"),
 -		},
 -	},
 -	{	/* Handle problems with rebooting on Apple MacBookPro5 */
 -		.callback = set_pci_reboot,
 -		.ident = "Apple MacBookPro5",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro5"),
 -		},
 -	},
 -	{	/* Handle problems with rebooting on Apple Macmini3,1 */
 -		.callback = set_pci_reboot,
 -		.ident = "Apple Macmini3,1",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Macmini3,1"),
 -		},
 -	},
 -	{	/* Handle problems with rebooting on the iMac9,1. */
 -		.callback = set_pci_reboot,
 -		.ident = "Apple iMac9,1",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "iMac9,1"),
 -		},
 -	},
 -	{	/* Handle problems with rebooting on the iMac10,1. */
 -		.callback = set_pci_reboot,
 -		.ident = "Apple iMac10,1",
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata reboot_dmi_table[] = {
 +	{	/* Handle problems with rebooting on Dell E520's */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell E520",
  		.matches = {
 -		    DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 -		    DMI_MATCH(DMI_PRODUCT_NAME, "iMac10,1"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Dell DM061"),
  		},
  	},
 -
 -	/* ASRock */
 -	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
 -		.callback = set_pci_reboot,
 -		.ident = "ASRock Q1900DC-ITX",
 +	{	/* Handle problems with rebooting on Dell 1300's */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell PowerEdge 1300",
  		.matches = {
 -			DMI_MATCH(DMI_BOARD_VENDOR, "ASRock"),
 -			DMI_MATCH(DMI_BOARD_NAME, "Q1900DC-ITX"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 1300/"),
  		},
  	},
 -
 -	/* ASUS */
 -	{	/* Handle problems with rebooting on ASUS P4S800 */
 +	{	/* Handle problems with rebooting on Dell 300's */
  		.callback = set_bios_reboot,
 -		.ident = "ASUS P4S800",
 +		.ident = "Dell PowerEdge 300",
  		.matches = {
 -			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
 -			DMI_MATCH(DMI_BOARD_NAME, "P4S800"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 300/"),
  		},
  	},
 -	{	/* Handle problems with rebooting on ASUS EeeBook X205TA */
 -		.callback = set_acpi_reboot,
 -		.ident = "ASUS EeeBook X205TA",
 +	{	/* Handle problems with rebooting on Dell Optiplex 745's SFF */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell OptiPlex 745",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "X205TA"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
  		},
  	},
 -	{	/* Handle problems with rebooting on ASUS EeeBook X205TAW */
 -		.callback = set_acpi_reboot,
 -		.ident = "ASUS EeeBook X205TAW",
 +	{	/* Handle problems with rebooting on Dell Optiplex 745's DFF */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell OptiPlex 745",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "X205TAW"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
 +			DMI_MATCH(DMI_BOARD_NAME, "0MM599"),
  		},
  	},
 -
 -	/* Certec */
 -	{       /* Handle problems with rebooting on Certec BPC600 */
 -		.callback = set_pci_reboot,
 -		.ident = "Certec BPC600",
 +	{	/* Handle problems with rebooting on Dell Optiplex 745 with 0KW626 */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell OptiPlex 745",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Certec"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "BPC600"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
 +			DMI_MATCH(DMI_BOARD_NAME, "0KW626"),
  		},
  	},
 -
 -	/* Dell */
 -	{	/* Handle problems with rebooting on Dell DXP061 */
 +	{	/* Handle problems with rebooting on Dell Optiplex 330 with 0KP561 */
  		.callback = set_bios_reboot,
 -		.ident = "Dell DXP061",
 +		.ident = "Dell OptiPlex 330",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Dell DXP061"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 330"),
 +			DMI_MATCH(DMI_BOARD_NAME, "0KP561"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell E520's */
 +	{	/* Handle problems with rebooting on Dell Optiplex 360 with 0T656F */
  		.callback = set_bios_reboot,
 -		.ident = "Dell E520",
 +		.ident = "Dell OptiPlex 360",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Dell DM061"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 360"),
 +			DMI_MATCH(DMI_BOARD_NAME, "0T656F"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the Latitude E5410. */
 -		.callback = set_pci_reboot,
 -		.ident = "Dell Latitude E5410",
 +	{	/* Handle problems with rebooting on Dell OptiPlex 760 with 0G919G */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell OptiPlex 760",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E5410"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 760"),
 +			DMI_MATCH(DMI_BOARD_NAME, "0G919G"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the Latitude E5420. */
 -		.callback = set_pci_reboot,
 -		.ident = "Dell Latitude E5420",
 +	{	/* Handle problems with rebooting on Dell 2400's */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell PowerEdge 2400",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E5420"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 2400"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the Latitude E6320. */
 -		.callback = set_pci_reboot,
 -		.ident = "Dell Latitude E6320",
 +	{	/* Handle problems with rebooting on Dell T5400's */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell Precision T5400",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E6320"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Precision WorkStation T5400"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the Latitude E6420. */
 -		.callback = set_pci_reboot,
 -		.ident = "Dell Latitude E6420",
 +	{	/* Handle problems with rebooting on Dell T7400's */
 +		.callback = set_bios_reboot,
 +		.ident = "Dell Precision T7400",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E6420"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Precision WorkStation T7400"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell Optiplex 330 with 0KP561 */
 +	{	/* Handle problems with rebooting on HP laptops */
  		.callback = set_bios_reboot,
 -		.ident = "Dell OptiPlex 330",
 +		.ident = "HP Compaq Laptop",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 330"),
 -			DMI_MATCH(DMI_BOARD_NAME, "0KP561"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell Optiplex 360 with 0T656F */
 +	{	/* Handle problems with rebooting on Dell XPS710 */
  		.callback = set_bios_reboot,
 -		.ident = "Dell OptiPlex 360",
 +		.ident = "Dell XPS710",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 360"),
 -			DMI_MATCH(DMI_BOARD_NAME, "0T656F"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Dell XPS710"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell Optiplex 745's SFF */
 +	{	/* Handle problems with rebooting on Dell DXP061 */
  		.callback = set_bios_reboot,
 -		.ident = "Dell OptiPlex 745",
 +		.ident = "Dell DXP061",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Dell DXP061"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell Optiplex 745's DFF */
 +	{	/* Handle problems with rebooting on Sony VGN-Z540N */
  		.callback = set_bios_reboot,
 -		.ident = "Dell OptiPlex 745",
 +		.ident = "Sony VGN-Z540N",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
 -			DMI_MATCH(DMI_BOARD_NAME, "0MM599"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "VGN-Z540N"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell Optiplex 745 with 0KW626 */
 +	{	/* Handle problems with rebooting on ASUS P4S800 */
  		.callback = set_bios_reboot,
 -		.ident = "Dell OptiPlex 745",
 +		.ident = "ASUS P4S800",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 745"),
 -			DMI_MATCH(DMI_BOARD_NAME, "0KW626"),
 +			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
 +			DMI_MATCH(DMI_BOARD_NAME, "P4S800"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell OptiPlex 760 with 0G919G */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell OptiPlex 760",
++=======
++static const struct dmi_system_id reboot_dmi_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
 +
 +	{	/* Handle reboot issue on Acer Aspire one */
 +		.callback = set_kbd_reboot,
 +		.ident = "Acer Aspire One A110",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 760"),
 -			DMI_MATCH(DMI_BOARD_NAME, "0G919G"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "AOA110"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the OptiPlex 990. */
 +	{	/* Handle problems with rebooting on Apple MacBook5 */
  		.callback = set_pci_reboot,
 -		.ident = "Dell OptiPlex 990",
 +		.ident = "Apple MacBook5",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 990"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "MacBook5"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell 300's */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell PowerEdge 300",
 +	{	/* Handle problems with rebooting on Apple MacBookPro5 */
 +		.callback = set_pci_reboot,
 +		.ident = "Apple MacBookPro5",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 300/"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro5"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell 1300's */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell PowerEdge 1300",
 +	{	/* Handle problems with rebooting on Apple Macmini3,1 */
 +		.callback = set_pci_reboot,
 +		.ident = "Apple Macmini3,1",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 1300/"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Macmini3,1"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell 2400's */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell PowerEdge 2400",
 +	{	/* Handle problems with rebooting on the iMac9,1. */
 +		.callback = set_pci_reboot,
 +		.ident = "Apple iMac9,1",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "PowerEdge 2400"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "iMac9,1"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the Dell PowerEdge C6100. */
 +	{	/* Handle problems with rebooting on the Latitude E6320. */
  		.callback = set_pci_reboot,
 -		.ident = "Dell PowerEdge C6100",
 +		.ident = "Dell Latitude E6320",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "C6100"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E6320"),
  		},
  	},
 -	{	/* Handle problems with rebooting on the Precision M6600. */
 +	{	/* Handle problems with rebooting on the Latitude E5420. */
  		.callback = set_pci_reboot,
 -		.ident = "Dell Precision M6600",
 +		.ident = "Dell Latitude E5420",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Precision M6600"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E5420"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell T5400's */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell Precision T5400",
 +	{	/* Handle problems with rebooting on the Latitude E6420. */
 +		.callback = set_pci_reboot,
 +		.ident = "Dell Latitude E6420",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Precision WorkStation T5400"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E6420"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell T7400's */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell Precision T7400",
 +	{	/* Handle problems with rebooting on the OptiPlex 990. */
 +		.callback = set_pci_reboot,
 +		.ident = "Dell OptiPlex 990",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Precision WorkStation T7400"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 990"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell XPS710 */
 -		.callback = set_bios_reboot,
 -		.ident = "Dell XPS710",
 +	{	/* Handle problems with rebooting on the Precision M6600. */
 +		.callback = set_pci_reboot,
 +		.ident = "Dell OptiPlex 990",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Dell XPS710"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "Precision M6600"),
  		},
  	},
 -	{	/* Handle problems with rebooting on Dell Optiplex 7450 AIO */
 -		.callback = set_acpi_reboot,
 -		.ident = "Dell OptiPlex 7450 AIO",
 +	{	/* Handle problems with rebooting on the Dell PowerEdge C6100. */
 +		.callback = set_pci_reboot,
 +		.ident = "Dell PowerEdge C6100",
  		.matches = {
  			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 7450 AIO"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "C6100"),
  		},
  	},
 -
 -	/* Hewlett-Packard */
 -	{	/* Handle problems with rebooting on HP laptops */
 -		.callback = set_bios_reboot,
 -		.ident = "HP Compaq Laptop",
 +	{	/* Some C6100 machines were shipped with vendor being 'Dell'. */
 +		.callback = set_pci_reboot,
 +		.ident = "Dell PowerEdge C6100",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq"),
 +			DMI_MATCH(DMI_SYS_VENDOR, "Dell"),
 +			DMI_MATCH(DMI_PRODUCT_NAME, "C6100"),
  		},
  	},
 -
 -	/* Sony */
 -	{	/* Handle problems with rebooting on Sony VGN-Z540N */
 -		.callback = set_bios_reboot,
 -		.ident = "Sony VGN-Z540N",
 +	/* ASRock */
 +	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
 +		.callback = set_pci_reboot,
 +		.ident = "ASRock Q1900DC-ITX",
  		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "VGN-Z540N"),
 +			DMI_MATCH(DMI_BOARD_VENDOR, "ASRock"),
 +			DMI_MATCH(DMI_BOARD_NAME, "Q1900DC-ITX"),
  		},
  	},
 -
  	{ }
  };
  
diff --cc arch/x86/power/cpu.c
index 48463426dafa,84fcfde53f8f..000000000000
--- a/arch/x86/power/cpu.c
+++ b/arch/x86/power/cpu.c
@@@ -357,3 -381,69 +357,72 @@@ static int __init bsp_pm_check_init(voi
  }
  
  core_initcall(bsp_pm_check_init);
++<<<<<<< HEAD
++=======
+ 
+ static int msr_init_context(const u32 *msr_id, const int total_num)
+ {
+ 	int i = 0;
+ 	struct saved_msr *msr_array;
+ 
+ 	if (saved_context.saved_msrs.array || saved_context.saved_msrs.num > 0) {
+ 		pr_err("x86/pm: MSR quirk already applied, please check your DMI match table.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	msr_array = kmalloc_array(total_num, sizeof(struct saved_msr), GFP_KERNEL);
+ 	if (!msr_array) {
+ 		pr_err("x86/pm: Can not allocate memory to save/restore MSRs during suspend.\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0; i < total_num; i++) {
+ 		msr_array[i].info.msr_no	= msr_id[i];
+ 		msr_array[i].valid		= false;
+ 		msr_array[i].info.reg.q		= 0;
+ 	}
+ 	saved_context.saved_msrs.num	= total_num;
+ 	saved_context.saved_msrs.array	= msr_array;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * The following section is a quirk framework for problematic BIOSen:
+  * Sometimes MSRs are modified by the BIOSen after suspended to
+  * RAM, this might cause unexpected behavior after wakeup.
+  * Thus we save/restore these specified MSRs across suspend/resume
+  * in order to work around it.
+  *
+  * For any further problematic BIOSen/platforms,
+  * please add your own function similar to msr_initialize_bdw.
+  */
+ static int msr_initialize_bdw(const struct dmi_system_id *d)
+ {
+ 	/* Add any extra MSR ids into this array. */
+ 	u32 bdw_msr_id[] = { MSR_IA32_THERM_CONTROL };
+ 
+ 	pr_info("x86/pm: %s detected, MSR saving is needed during suspending.\n", d->ident);
+ 	return msr_init_context(bdw_msr_id, ARRAY_SIZE(bdw_msr_id));
+ }
+ 
+ static const struct dmi_system_id msr_save_dmi_table[] = {
+ 	{
+ 	 .callback = msr_initialize_bdw,
+ 	 .ident = "BROADWELL BDX_EP",
+ 	 .matches = {
+ 		DMI_MATCH(DMI_PRODUCT_NAME, "GRANTLEY"),
+ 		DMI_MATCH(DMI_PRODUCT_VERSION, "E63448-400"),
+ 		},
+ 	},
+ 	{}
+ };
+ 
+ static int pm_check_save_msr(void)
+ {
+ 	dmi_check_system(msr_save_dmi_table);
+ 	return 0;
+ }
+ 
+ device_initcall(pm_check_save_msr);
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
diff --cc drivers/acpi/blacklist.c
index 67d8ac3b362a,995c4d8922b1..000000000000
--- a/drivers/acpi/blacklist.c
+++ b/drivers/acpi/blacklist.c
@@@ -35,24 -30,7 +35,28 @@@
  
  #include "internal.h"
  
++<<<<<<< HEAD
 +enum acpi_blacklist_predicates {
 +	all_versions,
 +	less_than_or_equal,
 +	equal,
 +	greater_than_or_equal,
 +};
 +
 +struct acpi_blacklist_item {
 +	char oem_id[7];
 +	char oem_table_id[9];
 +	u32 oem_revision;
 +	char *table;
 +	enum acpi_blacklist_predicates oem_revision_predicate;
 +	char *reason;
 +	u32 is_critical_error;
 +};
 +
 +static struct dmi_system_id acpi_osi_dmi_table[] __initdata;
++=======
+ static const struct dmi_system_id acpi_rev_dmi_table[] __initconst;
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  
  /*
   * POLICY: If *anything* doesn't work, put it on the blacklist.
@@@ -138,80 -79,30 +142,85 @@@ int __init acpi_blacklisted(void
  	return blacklisted;
  }
  #ifdef CONFIG_DMI
 -#ifdef CONFIG_ACPI_REV_OVERRIDE_POSSIBLE
 -static int __init dmi_enable_rev_override(const struct dmi_system_id *d)
 +static int __init dmi_enable_osi_linux(const struct dmi_system_id *d)
 +{
 +	acpi_dmi_osi_linux(1, d);	/* enable */
 +	return 0;
 +}
 +static int __init dmi_disable_osi_vista(const struct dmi_system_id *d)
 +{
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +	acpi_osi_setup("!Windows 2006");
 +	acpi_osi_setup("!Windows 2006 SP1");
 +	acpi_osi_setup("!Windows 2006 SP2");
 +	return 0;
 +}
 +static int __init dmi_disable_osi_win7(const struct dmi_system_id *d)
  {
 -	printk(KERN_NOTICE PREFIX "DMI detected: %s (force ACPI _REV to 5)\n",
 -	       d->ident);
 -	acpi_rev_override_setup(NULL);
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +	acpi_osi_setup("!Windows 2009");
 +	return 0;
 +}
 +static int __init dmi_disable_osi_win8(const struct dmi_system_id *d)
 +{
 +	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 +	acpi_osi_setup("!Windows 2012");
  	return 0;
  }
 -#endif
  
++<<<<<<< HEAD
 +static struct dmi_system_id acpi_osi_dmi_table[] __initdata = {
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Fujitsu Siemens",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "ESPRIMO Mobile V5505"),
 +		},
 +	},
 +	{
++=======
+ static const struct dmi_system_id acpi_rev_dmi_table[] __initconst = {
+ #ifdef CONFIG_ACPI_REV_OVERRIDE_POSSIBLE
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	/*
 -	 * DELL XPS 13 (2015) switches sound between HDA and I2S
 -	 * depending on the ACPI _REV callback. If userspace supports
 -	 * I2S sufficiently (or if you do not care about sound), you
 -	 * can safely disable this quirk.
 +	 * There have a NVIF method in MSI GX723 DSDT need call by Nvidia
 +	 * driver (e.g. nouveau) when user press brightness hotkey.
 +	 * Currently, nouveau driver didn't do the job and it causes there
 +	 * have a infinite while loop in DSDT when user press hotkey.
 +	 * We add MSI GX723's dmi information to this table for workaround
 +	 * this issue.
 +	 * Will remove MSI GX723 from the table after nouveau grows support.
  	 */
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "MSI GX723",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "GX723"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Sony VGN-NS10J_S",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS10J_S"),
 +		},
 +	},
 +	{
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "Sony VGN-SR290J",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR290J"),
 +		},
 +	},
  	{
 -	 .callback = dmi_enable_rev_override,
 -	 .ident = "DELL XPS 13 (2015)",
 -	 .matches = {
 -		      DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -		      DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9343"),
 +	.callback = dmi_disable_osi_vista,
 +	.ident = "VGN-NS50B_L",
 +	.matches = {
 +		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 +		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS50B_L"),
  		},
  	},
  	{
diff --cc drivers/acpi/ec.c
index f26c758e0b35,236b14324780..000000000000
--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@@ -948,49 -1809,31 +948,53 @@@ static int ec_enlarge_storm_threshold(c
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata ec_dmi_table[] = {
++=======
+ static const struct dmi_system_id ec_dmi_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
 -	ec_correct_ecdt, "MSI MS-171F", {
 -	DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star"),
 -	DMI_MATCH(DMI_PRODUCT_NAME, "MS-171F"),}, NULL},
 +	ec_skip_dsdt_scan, "Compal JFL92", {
 +	DMI_MATCH(DMI_BIOS_VENDOR, "COMPAL"),
 +	DMI_MATCH(DMI_BOARD_NAME, "JFL92") }, NULL},
  	{
 -	ec_honor_ecdt_gpe, "ASUS FX502VD", {
 -	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -	DMI_MATCH(DMI_PRODUCT_NAME, "FX502VD"),}, NULL},
 +	ec_flag_msi, "MSI hardware", {
 +	DMI_MATCH(DMI_BIOS_VENDOR, "Micro-Star")}, NULL},
  	{
 -	ec_honor_ecdt_gpe, "ASUS FX502VE", {
 -	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -	DMI_MATCH(DMI_PRODUCT_NAME, "FX502VE"),}, NULL},
 +	ec_flag_msi, "MSI hardware", {
 +	DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star")}, NULL},
  	{
 -	ec_honor_ecdt_gpe, "ASUS GL702VMK", {
 -	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -	DMI_MATCH(DMI_PRODUCT_NAME, "GL702VMK"),}, NULL},
 +	ec_flag_msi, "MSI hardware", {
 +	DMI_MATCH(DMI_CHASSIS_VENDOR, "MICRO-Star")}, NULL},
  	{
 -	ec_honor_ecdt_gpe, "ASUS X550VXK", {
 -	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -	DMI_MATCH(DMI_PRODUCT_NAME, "X550VXK"),}, NULL},
 +	ec_flag_msi, "MSI hardware", {
 +	DMI_MATCH(DMI_CHASSIS_VENDOR, "MICRO-STAR")}, NULL},
  	{
 -	ec_honor_ecdt_gpe, "ASUS X580VD", {
 -	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
 -	DMI_MATCH(DMI_PRODUCT_NAME, "X580VD"),}, NULL},
 +	ec_flag_msi, "Quanta hardware", {
 +	DMI_MATCH(DMI_SYS_VENDOR, "Quanta"),
 +	DMI_MATCH(DMI_PRODUCT_NAME, "TW8/SW8/DW8"),}, NULL},
 +	{
 +	ec_flag_msi, "Quanta hardware", {
 +	DMI_MATCH(DMI_SYS_VENDOR, "Quanta"),
 +	DMI_MATCH(DMI_PRODUCT_NAME, "TW9/SW9"),}, NULL},
 +	{
 +	ec_validate_ecdt, "ASUS hardware", {
 +	DMI_MATCH(DMI_BIOS_VENDOR, "ASUS") }, NULL},
 +	{
 +	ec_validate_ecdt, "ASUS hardware", {
 +	DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer Inc.") }, NULL},
 +	{
 +	ec_enlarge_storm_threshold, "CLEVO hardware", {
 +	DMI_MATCH(DMI_SYS_VENDOR, "CLEVO Co."),
 +	DMI_MATCH(DMI_PRODUCT_NAME, "M720T/M730T"),}, NULL},
 +	{
 +	ec_skip_dsdt_scan, "HP Folio 13", {
 +	DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 +	DMI_MATCH(DMI_PRODUCT_NAME, "HP Folio 13"),}, NULL},
 +	{
 +	ec_validate_ecdt, "ASUS hardware", {
 +	DMI_MATCH(DMI_SYS_VENDOR, "ASUSTek Computer Inc."),
 +	DMI_MATCH(DMI_PRODUCT_NAME, "L4R"),}, NULL},
  	{},
  };
  
diff --cc drivers/acpi/sleep.c
index 59b7e4504972,6804ddab3052..000000000000
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@@ -139,7 -160,7 +139,11 @@@ static int __init init_nvs_nosave(cons
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
++=======
+ static const struct dmi_system_id acpisleep_dmi_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
  	.callback = init_old_suspend_ordering,
  	.ident = "Abit KN9 (nForce4 variant)",
diff --cc drivers/acpi/video.c
index c7d2c80b513e,0972ec0e2eb8..000000000000
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@@ -429,7 -399,26 +429,30 @@@ static int __init video_disable_native_
  	return 0;
  }
  
++<<<<<<< HEAD:drivers/acpi/video.c
 +static struct dmi_system_id video_dmi_table[] __initdata = {
++=======
+ static int video_set_device_id_scheme(const struct dmi_system_id *d)
+ {
+ 	device_id_scheme = true;
+ 	return 0;
+ }
+ 
+ static int video_enable_only_lcd(const struct dmi_system_id *d)
+ {
+ 	only_lcd = true;
+ 	return 0;
+ }
+ 
+ static int video_set_report_key_events(const struct dmi_system_id *id)
+ {
+ 	if (report_key_events == -1)
+ 		report_key_events = (uintptr_t)id->driver_data;
+ 	return 0;
+ }
+ 
+ static const struct dmi_system_id video_dmi_table[] = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const):drivers/acpi/acpi_video.c
  	/*
  	 * Broken _BQC workaround http://bugzilla.kernel.org/show_bug.cgi?id=13121
  	 */
diff --cc drivers/input/touchscreen/htcpen.c
index 6c4fb8436957,8fd909285877..000000000000
--- a/drivers/input/touchscreen/htcpen.c
+++ b/drivers/input/touchscreen/htcpen.c
@@@ -221,7 -219,7 +221,11 @@@ static struct isa_driver htcpen_isa_dri
  	}
  };
  
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata htcshift_dmi_table[] = {
++=======
+ static const struct dmi_system_id htcshift_dmi_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
  		.ident = "Shift",
  		.matches = {
diff --cc drivers/leds/leds-clevo-mail.c
index 6a8405df76a3,492789f56896..000000000000
--- a/drivers/leds/leds-clevo-mail.c
+++ b/drivers/leds/leds-clevo-mail.c
@@@ -40,7 -40,7 +40,11 @@@ static int __init clevo_mail_led_dmi_ca
   * detected as working, but in reality it is not) as low as
   * possible.
   */
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata clevo_mail_led_dmi_table[] = {
++=======
+ static const struct dmi_system_id clevo_mail_led_dmi_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
  		.callback = clevo_mail_led_dmi_callback,
  		.ident = "Clevo D410J",
diff --cc drivers/leds/leds-ss4200.c
index 4e41a22ff21f,a9db8674cd02..000000000000
--- a/drivers/leds/leds-ss4200.c
+++ b/drivers/leds/leds-ss4200.c
@@@ -91,7 -91,7 +91,11 @@@ MODULE_PARM_DESC(nodetect, "Skip DMI-ba
   * detected as working, but in reality it is not) as low as
   * possible.
   */
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata nas_led_whitelist[] = {
++=======
+ static const struct dmi_system_id nas_led_whitelist[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
  		.callback = ss4200_led_dmi_callback,
  		.ident = "Intel SS4200-E",
diff --cc drivers/net/ethernet/via/via-rhine.c
index cbedb26130e8,83e6f76eb965..000000000000
--- a/drivers/net/ethernet/via/via-rhine.c
+++ b/drivers/net/ethernet/via/via-rhine.c
@@@ -2397,7 -2588,17 +2397,21 @@@ static struct pci_driver rhine_driver 
  	.driver.pm	= RHINE_PM_OPS,
  };
  
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata rhine_dmi_table[] = {
++=======
+ static struct platform_driver rhine_driver_platform = {
+ 	.probe		= rhine_init_one_platform,
+ 	.remove		= rhine_remove_one_platform,
+ 	.driver = {
+ 		.name	= DRV_NAME,
+ 		.of_match_table	= rhine_of_tbl,
+ 		.pm		= RHINE_PM_OPS,
+ 	}
+ };
+ 
+ static const struct dmi_system_id rhine_dmi_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
  		.ident = "EPIA-M",
  		.matches = {
diff --cc drivers/pci/quirks.c
index 7908058abb14,a4d33619a7bb..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -1661,7 -1685,43 +1661,33 @@@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_I
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260a, quirk_intel_pcie_pm);
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260b, quirk_intel_pcie_pm);
  
 -static void quirk_radeon_pm(struct pci_dev *dev)
 -{
 -	if (dev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&
 -	    dev->subsystem_device == 0x00e2) {
 -		if (dev->d3_delay < 20) {
 -			dev->d3_delay = 20;
 -			dev_info(&dev->dev, "extending delay after power-on from D3 to %d msec\n",
 -				 dev->d3_delay);
 -		}
 -	}
 -}
 -DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x6741, quirk_radeon_pm);
 -
  #ifdef CONFIG_X86_IO_APIC
++<<<<<<< HEAD
++=======
+ static int dmi_disable_ioapicreroute(const struct dmi_system_id *d)
+ {
+ 	noioapicreroute = 1;
+ 	pr_info("%s detected: disable boot interrupt reroute\n", d->ident);
+ 
+ 	return 0;
+ }
+ 
+ static const struct dmi_system_id boot_interrupt_dmi_table[] = {
+ 	/*
+ 	 * Systems to exclude from boot interrupt reroute quirks
+ 	 */
+ 	{
+ 		.callback = dmi_disable_ioapicreroute,
+ 		.ident = "ASUSTek Computer INC. M2N-LR",
+ 		.matches = {
+ 			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTek Computer INC."),
+ 			DMI_MATCH(DMI_PRODUCT_NAME, "M2N-LR"),
+ 		},
+ 	},
+ 	{}
+ };
+ 
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  /*
   * Boot interrupts on some chipsets cannot be turned off. For these chipsets,
   * remap the original interrupt in the linux kernel to the boot interrupt, so
diff --cc drivers/tty/serial/pch_uart.c
index 80158594c974,d9123f995705..000000000000
--- a/drivers/tty/serial/pch_uart.c
+++ b/drivers/tty/serial/pch_uart.c
@@@ -373,10 -371,56 +373,59 @@@ static const struct file_operations por
  };
  #endif	/* CONFIG_DEBUG_FS */
  
++<<<<<<< HEAD
++=======
+ static const struct dmi_system_id pch_uart_dmi_table[] = {
+ 	{
+ 		.ident = "CM-iTC",
+ 		{
+ 			DMI_MATCH(DMI_BOARD_NAME, "CM-iTC"),
+ 		},
+ 		(void *)CMITC_UARTCLK,
+ 	},
+ 	{
+ 		.ident = "FRI2",
+ 		{
+ 			DMI_MATCH(DMI_BIOS_VERSION, "FRI2"),
+ 		},
+ 		(void *)FRI2_64_UARTCLK,
+ 	},
+ 	{
+ 		.ident = "Fish River Island II",
+ 		{
+ 			DMI_MATCH(DMI_PRODUCT_NAME, "Fish River Island II"),
+ 		},
+ 		(void *)FRI2_48_UARTCLK,
+ 	},
+ 	{
+ 		.ident = "COMe-mTT",
+ 		{
+ 			DMI_MATCH(DMI_BOARD_NAME, "COMe-mTT"),
+ 		},
+ 		(void *)NTC1_UARTCLK,
+ 	},
+ 	{
+ 		.ident = "nanoETXexpress-TT",
+ 		{
+ 			DMI_MATCH(DMI_BOARD_NAME, "nanoETXexpress-TT"),
+ 		},
+ 		(void *)NTC1_UARTCLK,
+ 	},
+ 	{
+ 		.ident = "MinnowBoard",
+ 		{
+ 			DMI_MATCH(DMI_BOARD_NAME, "MinnowBoard"),
+ 		},
+ 		(void *)MINNOW_UARTCLK,
+ 	},
+ 	{ }
+ };
+ 
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  /* Return UART clock, checking for board specific clocks. */
 -static unsigned int pch_uart_get_uartclk(void)
 +static int pch_uart_get_uartclk(void)
  {
 -	const struct dmi_system_id *d;
 +	const char *cmp;
  
  	if (user_uartclk)
  		return user_uartclk;
diff --cc drivers/video/backlight/kb3886_bl.c
index bca6ccc74dfb,96312c3afc07..000000000000
--- a/drivers/video/backlight/kb3886_bl.c
+++ b/drivers/video/backlight/kb3886_bl.c
@@@ -78,7 -78,7 +78,11 @@@ static struct kb3886bl_machinfo *bl_mac
  static unsigned long kb3886bl_flags;
  #define KB3886BL_SUSPENDED     0x01
  
++<<<<<<< HEAD
 +static struct dmi_system_id __initdata kb3886bl_device_table[] = {
++=======
+ static const struct dmi_system_id kb3886bl_device_table[] __initconst = {
++>>>>>>> 6faadbbb7f9d (dmi: Mark all struct dmi_system_id instances const)
  	{
  		.ident = "Sahara Touch-iT",
  		.matches = {
* Unmerged path drivers/acpi/osi.c
* Unmerged path drivers/acpi/processor_pdc.c
* Unmerged path drivers/firmware/google/memconsole-x86-legacy.c
* Unmerged path drivers/hwmon/dell-smm-hwmon.c
* Unmerged path drivers/mfd/kempld-core.c
* Unmerged path drivers/platform/chrome/chromeos_laptop.c
* Unmerged path drivers/platform/chrome/chromeos_pstore.c
* Unmerged path drivers/platform/chrome/cros_ec_lpc.c
* Unmerged path drivers/platform/x86/mlx-platform.c
* Unmerged path drivers/platform/x86/toshiba-wmi.c
diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c
index 6d63719616bb..d2bbf70df5c7 100644
--- a/arch/x86/kernel/acpi/boot.c
+++ b/arch/x86/kernel/acpi/boot.c
@@ -1309,7 +1309,7 @@ static int __init dmi_ignore_irq0_timer_override(const struct dmi_system_id *d)
  * If your system is blacklisted here, but you find that acpi=force
  * works for you, please contact linux-acpi@vger.kernel.org
  */
-static struct dmi_system_id __initdata acpi_dmi_table[] = {
+static const struct dmi_system_id acpi_dmi_table[] __initconst = {
 	/*
 	 * Boxes that need ACPI disabled
 	 */
@@ -1384,7 +1384,7 @@ static struct dmi_system_id __initdata acpi_dmi_table[] = {
 };
 
 /* second table for DMI checks that should run after early-quirks */
-static struct dmi_system_id __initdata acpi_dmi_table_late[] = {
+static const struct dmi_system_id acpi_dmi_table_late[] __initconst = {
 	/*
 	 * HP laptops which use a DSDT reporting as HP/SB400/10000,
 	 * which includes some code which overrides all temperature
diff --git a/arch/x86/kernel/apm_32.c b/arch/x86/kernel/apm_32.c
index 8fdcec62d713..d34b87718e6d 100644
--- a/arch/x86/kernel/apm_32.c
+++ b/arch/x86/kernel/apm_32.c
@@ -2041,7 +2041,7 @@ static int __init swab_apm_power_in_minutes(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata apm_dmi_table[] = {
+static const struct dmi_system_id apm_dmi_table[] __initconst = {
 	{
 		print_if_true,
 		KERN_WARNING "IBM T23 - BIOS 1.03b+ and controller firmware 1.02+ may be needed for Linux APM.",
diff --git a/arch/x86/kernel/io_delay.c b/arch/x86/kernel/io_delay.c
index a979b5bd2fc0..5bf3f81fd975 100644
--- a/arch/x86/kernel/io_delay.c
+++ b/arch/x86/kernel/io_delay.c
@@ -58,7 +58,7 @@ static int __init dmi_io_delay_0xed_port(const struct dmi_system_id *id)
  * Quirk table for systems that misbehave (lock up, etc.) if port
  * 0x80 is used:
  */
-static struct dmi_system_id __initdata io_delay_0xed_port_dmi_table[] = {
+static const struct dmi_system_id io_delay_0xed_port_dmi_table[] __initconst = {
 	{
 		.callback	= dmi_io_delay_0xed_port,
 		.ident		= "Compaq Presario V6000",
* Unmerged path arch/x86/kernel/reboot.c
diff --git a/arch/x86/pci/irq.c b/arch/x86/pci/irq.c
index 5bf04cc280df..87983ea28ea9 100644
--- a/arch/x86/pci/irq.c
+++ b/arch/x86/pci/irq.c
@@ -1091,7 +1091,7 @@ static int __init fix_acer_tm360_irqrouting(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata pciirq_dmi_table[] = {
+static const struct dmi_system_id pciirq_dmi_table[] __initconst = {
 	{
 		.callback = fix_broken_hp_bios_irq9,
 		.ident = "HP Pavilion N5400 Series Laptop",
* Unmerged path arch/x86/power/cpu.c
* Unmerged path drivers/acpi/blacklist.c
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 01b7641ae954..ed838f9115bc 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -61,7 +61,7 @@ static int set_copy_dsdt(const struct dmi_system_id *id)
 	return 0;
 }
 
-static struct dmi_system_id dsdt_dmi_table[] __initdata = {
+static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	/*
 	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
@@ -77,7 +77,7 @@ static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 	{}
 };
 #else
-static struct dmi_system_id dsdt_dmi_table[] __initdata = {
+static const struct dmi_system_id dsdt_dmi_table[] __initconst = {
 	{}
 };
 #endif
* Unmerged path drivers/acpi/ec.c
* Unmerged path drivers/acpi/osi.c
diff --git a/drivers/acpi/pci_slot.c b/drivers/acpi/pci_slot.c
index d678a180ca2a..c60a8bb4e1c2 100644
--- a/drivers/acpi/pci_slot.c
+++ b/drivers/acpi/pci_slot.c
@@ -194,7 +194,7 @@ static int do_sta_before_sun(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id acpi_pci_slot_dmi_table[] __initdata = {
+static const struct dmi_system_id acpi_pci_slot_dmi_table[] __initconst = {
 	/*
 	 * Fujitsu Primequest machines will return 1023 to indicate an
 	 * error if the _SUN method is evaluated on SxFy objects that
* Unmerged path drivers/acpi/processor_pdc.c
* Unmerged path drivers/acpi/sleep.c
diff --git a/drivers/acpi/thermal.c b/drivers/acpi/thermal.c
index 94523c79dc5f..4b5dc282d5e8 100644
--- a/drivers/acpi/thermal.c
+++ b/drivers/acpi/thermal.c
@@ -1202,7 +1202,7 @@ static int thermal_psv(const struct dmi_system_id *d) {
 	return 0;
 }
 
-static struct dmi_system_id thermal_dmi_table[] __initdata = {
+static const struct dmi_system_id thermal_dmi_table[] __initconst = {
 	/*
 	 * Award BIOS on this AOpen makes thermal control almost worthless.
 	 * http://bugzilla.kernel.org/show_bug.cgi?id=8842
* Unmerged path drivers/acpi/video.c
diff --git a/drivers/char/sonypi.c b/drivers/char/sonypi.c
index bf2349dbbf7f..c96148024a54 100644
--- a/drivers/char/sonypi.c
+++ b/drivers/char/sonypi.c
@@ -1497,7 +1497,7 @@ static struct platform_driver sonypi_driver = {
 
 static struct platform_device *sonypi_platform_device;
 
-static struct dmi_system_id __initdata sonypi_dmi_table[] = {
+static const struct dmi_system_id sonypi_dmi_table[] __initconst = {
 	{
 		.ident = "Sony Vaio",
 		.matches = {
diff --git a/drivers/cpufreq/powernow-k7.c b/drivers/cpufreq/powernow-k7.c
index 955870877935..e283e31e8f1e 100644
--- a/drivers/cpufreq/powernow-k7.c
+++ b/drivers/cpufreq/powernow-k7.c
@@ -615,7 +615,7 @@ static int acer_cpufreq_pst(const struct dmi_system_id *d)
  * A BIOS update is all that can save them.
  * Mention this, and disable cpufreq.
  */
-static struct dmi_system_id powernow_dmi_table[] = {
+static const struct dmi_system_id powernow_dmi_table[] = {
 	{
 		.callback = acer_cpufreq_pst,
 		.ident = "Acer Aspire",
diff --git a/drivers/firmware/google/gsmi.c b/drivers/firmware/google/gsmi.c
index acba0b9f4406..5c63754e4837 100644
--- a/drivers/firmware/google/gsmi.c
+++ b/drivers/firmware/google/gsmi.c
@@ -709,7 +709,7 @@ static u32 __init hash_oem_table_id(char s[8])
 	return local_hash_64(input, 32);
 }
 
-static struct dmi_system_id gsmi_dmi_table[] __initdata = {
+static const struct dmi_system_id gsmi_dmi_table[] __initconst = {
 	{
 		.ident = "Google Board",
 		.matches = {
* Unmerged path drivers/firmware/google/memconsole-x86-legacy.c
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c
index 77c649723ad7..b9ab4f49d6be 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c
@@ -171,7 +171,7 @@ nvkm_gpio_fini(struct nvkm_subdev *subdev, bool suspend)
 	return 0;
 }
 
-static struct dmi_system_id gpio_reset_ids[] = {
+static const struct dmi_system_id gpio_reset_ids[] = {
 	{
 		.ident = "Apple Macbook 10,1",
 		.matches = {
diff --git a/drivers/hwmon/acpi_power_meter.c b/drivers/hwmon/acpi_power_meter.c
index 6351aba8819c..9bcecf65b386 100644
--- a/drivers/hwmon/acpi_power_meter.c
+++ b/drivers/hwmon/acpi_power_meter.c
@@ -970,7 +970,7 @@ static int __init enable_cap_knobs(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata pm_dmi_table[] = {
+static const struct dmi_system_id pm_dmi_table[] __initconst = {
 	{
 		enable_cap_knobs, "IBM Active Energy Manager",
 		{
diff --git a/drivers/hwmon/applesmc.c b/drivers/hwmon/applesmc.c
index 3288f13d2d87..cec5b86a8f39 100644
--- a/drivers/hwmon/applesmc.c
+++ b/drivers/hwmon/applesmc.c
@@ -1243,7 +1243,7 @@ static int applesmc_dmi_match(const struct dmi_system_id *id)
  * Note that DMI_MATCH(...,"MacBook") will match "MacBookPro1,1".
  * So we need to put "Apple MacBook Pro" before "Apple MacBook".
  */
-static __initdata struct dmi_system_id applesmc_whitelist[] = {
+static const struct dmi_system_id applesmc_whitelist[] __initconst = {
 	{ applesmc_dmi_match, "Apple MacBook Air", {
 	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
 	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBookAir") },
* Unmerged path drivers/hwmon/dell-smm-hwmon.c
* Unmerged path drivers/input/touchscreen/htcpen.c
* Unmerged path drivers/leds/leds-clevo-mail.c
* Unmerged path drivers/leds/leds-ss4200.c
* Unmerged path drivers/mfd/kempld-core.c
diff --git a/drivers/net/ethernet/marvell/skge.c b/drivers/net/ethernet/marvell/skge.c
index 33aac711c834..5b5d1e5cffe6 100644
--- a/drivers/net/ethernet/marvell/skge.c
+++ b/drivers/net/ethernet/marvell/skge.c
@@ -4144,7 +4144,7 @@ static struct pci_driver skge_driver = {
 	.driver.pm =	SKGE_PM_OPS,
 };
 
-static struct dmi_system_id skge_32bit_dma_boards[] = {
+static const struct dmi_system_id skge_32bit_dma_boards[] = {
 	{
 		.ident = "Gigabyte nForce boards",
 		.matches = {
* Unmerged path drivers/net/ethernet/via/via-rhine.c
diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 31a40b456ec9..ad11eb8b64b0 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -363,7 +363,7 @@ static int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata pcie_portdrv_dmi_table[] = {
+static const struct dmi_system_id pcie_portdrv_dmi_table[] __initconst = {
 	/*
 	 * Boxes that should not use MSI for PCIe PME signaling.
 	 */
* Unmerged path drivers/pci/quirks.c
* Unmerged path drivers/platform/chrome/chromeos_laptop.c
* Unmerged path drivers/platform/chrome/chromeos_pstore.c
* Unmerged path drivers/platform/chrome/cros_ec_lpc.c
diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c
index 475cc5242511..9917977533fa 100644
--- a/drivers/platform/x86/compal-laptop.c
+++ b/drivers/platform/x86/compal-laptop.c
@@ -775,7 +775,7 @@ static int dmi_check_cb_extra(const struct dmi_system_id *id)
 	return 1;
 }
 
-static struct dmi_system_id __initdata compal_dmi_table[] = {
+static const struct dmi_system_id compal_dmi_table[] __initconst = {
 	{
 		.ident = "FL90/IFL90",
 		.matches = {
diff --git a/drivers/platform/x86/hdaps.c b/drivers/platform/x86/hdaps.c
index 777c7e3dda51..4c5950d8bce4 100644
--- a/drivers/platform/x86/hdaps.c
+++ b/drivers/platform/x86/hdaps.c
@@ -515,7 +515,7 @@ static int __init hdaps_dmi_match_invert(const struct dmi_system_id *id)
    "ThinkPad T42p", so the order of the entries matters.
    If your ThinkPad is not recognized, please update to latest
    BIOS. This is especially the case for some R52 ThinkPads. */
-static struct dmi_system_id __initdata hdaps_whitelist[] = {
+static const struct dmi_system_id hdaps_whitelist[] __initconst = {
 	HDAPS_DMI_MATCH_INVERT("IBM", "ThinkPad R50p", HDAPS_BOTH_AXES),
 	HDAPS_DMI_MATCH_NORMAL("IBM", "ThinkPad R50"),
 	HDAPS_DMI_MATCH_NORMAL("IBM", "ThinkPad R51"),
diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 97c2be195efc..e8d3316d1d33 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -227,7 +227,7 @@ static void rtl_teardown_sysfs(void) {
 }
 
 
-static struct dmi_system_id __initdata ibm_rtl_dmi_table[] = {
+static const struct dmi_system_id ibm_rtl_dmi_table[] __initconst = {
 	{                                                  \
 		.matches = {                               \
 			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),  \
diff --git a/drivers/platform/x86/intel_oaktrail.c b/drivers/platform/x86/intel_oaktrail.c
index f6f18cde0f11..cb2874b56fb5 100644
--- a/drivers/platform/x86/intel_oaktrail.c
+++ b/drivers/platform/x86/intel_oaktrail.c
@@ -303,7 +303,7 @@ static int dmi_check_cb(const struct dmi_system_id *id)
 	return 0;
 }
 
-static struct dmi_system_id __initdata oaktrail_dmi_table[] = {
+static const struct dmi_system_id oaktrail_dmi_table[] __initconst = {
 	{
 		.ident = "OakTrail platform",
 		.matches = {
* Unmerged path drivers/platform/x86/mlx-platform.c
diff --git a/drivers/platform/x86/msi-laptop.c b/drivers/platform/x86/msi-laptop.c
index 6b2293875672..3cc0449d7c53 100644
--- a/drivers/platform/x86/msi-laptop.c
+++ b/drivers/platform/x86/msi-laptop.c
@@ -605,7 +605,7 @@ static int dmi_check_cb(const struct dmi_system_id *dmi)
 	return 1;
 }
 
-static struct dmi_system_id __initdata msi_dmi_table[] = {
+static const struct dmi_system_id msi_dmi_table[] __initconst = {
 	{
 		.ident = "MSI S270",
 		.matches = {
diff --git a/drivers/platform/x86/samsung-laptop.c b/drivers/platform/x86/samsung-laptop.c
index d1f030053176..369da9f19f00 100644
--- a/drivers/platform/x86/samsung-laptop.c
+++ b/drivers/platform/x86/samsung-laptop.c
@@ -1435,7 +1435,7 @@ static int __init samsung_dmi_matched(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata samsung_dmi_table[] = {
+static const struct dmi_system_id samsung_dmi_table[] __initconst = {
 	{
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR,
diff --git a/drivers/platform/x86/samsung-q10.c b/drivers/platform/x86/samsung-q10.c
index 1a90b62a71c6..623b96727269 100644
--- a/drivers/platform/x86/samsung-q10.c
+++ b/drivers/platform/x86/samsung-q10.c
@@ -130,7 +130,7 @@ static int __init dmi_check_callback(const struct dmi_system_id *id)
 	return 1;
 }
 
-static struct dmi_system_id __initdata samsungq10_dmi_table[] = {
+static const struct dmi_system_id samsungq10_dmi_table[] __initconst = {
 	{
 		.ident = "Samsung Q10",
 		.matches = {
diff --git a/drivers/platform/x86/sony-laptop.c b/drivers/platform/x86/sony-laptop.c
index 2ac045f27f10..66095bfdf83c 100644
--- a/drivers/platform/x86/sony-laptop.c
+++ b/drivers/platform/x86/sony-laptop.c
@@ -4473,7 +4473,7 @@ static struct acpi_driver sony_pic_driver = {
 	.drv.pm = &sony_pic_pm,
 };
 
-static struct dmi_system_id __initdata sonypi_dmi_table[] = {
+static const struct dmi_system_id sonypi_dmi_table[] __initconst = {
 	{
 		.ident = "Sony Vaio",
 		.matches = {
* Unmerged path drivers/platform/x86/toshiba-wmi.c
diff --git a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
index 9b86a01af631..a1b2736da408 100644
--- a/drivers/pnp/pnpbios/core.c
+++ b/drivers/pnp/pnpbios/core.c
@@ -487,7 +487,7 @@ static int __init exploding_pnp_bios(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id pnpbios_dmi_table[] __initdata = {
+static const struct dmi_system_id pnpbios_dmi_table[] __initconst = {
 	{			/* PnPBIOS GPF on boot */
 	 .callback = exploding_pnp_bios,
 	 .ident = "Higraded P14H",
* Unmerged path drivers/tty/serial/pch_uart.c
* Unmerged path drivers/video/backlight/kb3886_bl.c
diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c
index 58bfbc6c39b5..48a6db64e668 100644
--- a/sound/soc/codecs/rt5645.c
+++ b/sound/soc/codecs/rt5645.c
@@ -3600,7 +3600,7 @@ static const struct rt5645_platform_data buddy_platform_data = {
 	.level_trigger_irq = true,
 };
 
-static struct dmi_system_id dmi_platform_intel_broadwell[] = {
+static const struct dmi_system_id dmi_platform_intel_broadwell[] = {
 	{
 		.ident = "Chrome Buddy",
 		.matches = {
