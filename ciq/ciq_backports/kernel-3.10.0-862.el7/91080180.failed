security/keys: properly zero out sensitive key material in big_key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [security] keys: properly zero out sensitive key material in big_key (David Howells) [1503242]
Rebuild_FUZZ: 92.68%
commit-author Jason A. Donenfeld <Jason@zx2c4.com>
commit 910801809b2e40a4baedd080ef5d80b4a180e70e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/91080180.failed

Error paths forgot to zero out sensitive material, so this patch changes
some kfrees into a kzfrees.

	Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Reviewed-by: Eric Biggers <ebiggers3@gmail.com>
	Cc: Herbert Xu <herbert@gondor.apana.org.au>
	Cc: Kirill Marinushkin <k.marinushkin@gmail.com>
	Cc: security@kernel.org
	Cc: stable@vger.kernel.org
(cherry picked from commit 910801809b2e40a4baedd080ef5d80b4a180e70e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/big_key.c
diff --cc security/keys/big_key.c
index 8137b27d641d,507d6fb86a4f..000000000000
--- a/security/keys/big_key.c
+++ b/security/keys/big_key.c
@@@ -90,6 -194,8 +90,10 @@@ int big_key_instantiate(struct key *key
  		*path = file->f_path;
  		path_get(path);
  		fput(file);
++<<<<<<< HEAD
++=======
+ 		kzfree(data);
++>>>>>>> 910801809b2e (security/keys: properly zero out sensitive key material in big_key)
  	} else {
  		/* Just store the data in a buffer */
  		void *data = kmalloc(datalen, GFP_KERNEL);
@@@ -104,13 -210,27 +108,36 @@@
  
  err_fput:
  	fput(file);
++<<<<<<< HEAD
 +err_quota:
 +	key_payload_reserve(key, 0);
 +error:
++=======
+ err_enckey:
+ 	kzfree(enckey);
+ error:
+ 	kzfree(data);
++>>>>>>> 910801809b2e (security/keys: properly zero out sensitive key material in big_key)
  	return ret;
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Clear preparsement.
+  */
+ void big_key_free_preparse(struct key_preparsed_payload *prep)
+ {
+ 	if (prep->datalen > BIG_KEY_FILE_THRESHOLD) {
+ 		struct path *path = (struct path *)&prep->payload.data[big_key_path];
+ 
+ 		path_put(path);
+ 	}
+ 	kzfree(prep->payload.data[big_key_data]);
+ }
+ 
+ /*
++>>>>>>> 910801809b2e (security/keys: properly zero out sensitive key material in big_key)
   * dispose of the links from a revoked keyring
   * - called with the key sem write-locked
   */
@@@ -134,10 -258,9 +161,15 @@@ void big_key_destroy(struct key *key
  		path_put(path);
  		path->mnt = NULL;
  		path->dentry = NULL;
 +	} else {
 +		kfree(key->payload.data);
 +		key->payload.data = NULL;
  	}
++<<<<<<< HEAD
++=======
+ 	kzfree(key->payload.data[big_key_data]);
+ 	key->payload.data[big_key_data] = NULL;
++>>>>>>> 910801809b2e (security/keys: properly zero out sensitive key material in big_key)
  }
  
  /*
@@@ -168,22 -291,48 +200,27 @@@ long big_key_read(const struct key *key
  		return datalen;
  
  	if (datalen > BIG_KEY_FILE_THRESHOLD) {
 -		struct path *path = (struct path *)&key->payload.data[big_key_path];
 +		struct path *path = (struct path *)&key->payload.data2;
  		struct file *file;
 -		u8 *data;
 -		u8 *enckey = (u8 *)key->payload.data[big_key_data];
 -		size_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));
 -		loff_t pos = 0;
 -
 -		data = kmalloc(enclen, GFP_KERNEL);
 -		if (!data)
 -			return -ENOMEM;
 +		loff_t pos;
  
  		file = dentry_open(path, O_RDONLY, current_cred());
 -		if (IS_ERR(file)) {
 -			ret = PTR_ERR(file);
 -			goto error;
 -		}
 +		if (IS_ERR(file))
 +			return PTR_ERR(file);
  
 -		/* read file to kernel and decrypt */
 -		ret = kernel_read(file, data, enclen, &pos);
 -		if (ret >= 0 && ret != enclen) {
 -			ret = -EIO;
 -			goto err_fput;
 -		}
 -
 -		ret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);
 -		if (ret)
 -			goto err_fput;
 -
 -		ret = datalen;
 -
 -		/* copy decrypted data to user */
 -		if (copy_to_user(buffer, data, datalen) != 0)
 -			ret = -EFAULT;
 -
 -err_fput:
 +		pos = 0;
 +		ret = vfs_read(file, buffer, datalen, &pos);
  		fput(file);
++<<<<<<< HEAD
 +		if (ret >= 0 && ret != datalen)
 +			ret = -EIO;
++=======
+ error:
+ 		kzfree(data);
++>>>>>>> 910801809b2e (security/keys: properly zero out sensitive key material in big_key)
  	} else {
  		ret = datalen;
 -		if (copy_to_user(buffer, key->payload.data[big_key_data],
 -				 datalen) != 0)
 +		if (copy_to_user(buffer, key->payload.data, datalen) != 0)
  			ret = -EFAULT;
  	}
  
* Unmerged path security/keys/big_key.c
