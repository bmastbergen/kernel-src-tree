s390/pgtable: make pmd and pud helper functions available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] pgtable: make pmd and pud helper functions available (Hendrik Brueckner) [1489742]
Rebuild_FUZZ: 95.41%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 9e20b4dac1f58921503109ea38f341ff2b0d21f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9e20b4da.failed

Make pmd_wrprotect() and pmd_mkwrite() available independently from
CONFIG_TRANSPARENT_HUGEPAGE and CONFIG_HUGETLB_PAGE so these can be
used on the kernel mapping.

Also introduce a couple of pud helper functions, namely pud_pfn(),
pud_wrprotect(), pud_mkwrite(), pud_mkdirty() and pud_mkclean()
which only work on the kernel mapping.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 9e20b4dac1f58921503109ea38f341ff2b0d21f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pgtable.h
diff --cc arch/s390/include/asm/pgtable.h
index cff6ed1e6f32,882d6f4aad25..000000000000
--- a/arch/s390/include/asm/pgtable.h
+++ b/arch/s390/include/asm/pgtable.h
@@@ -345,15 -270,20 +345,26 @@@ extern unsigned long MODULES_END
  #define _REGION3_ENTRY		(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_LENGTH)
  #define _REGION3_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_INVALID)
  
++<<<<<<< HEAD
 +#define _REGION3_ENTRY_ORIGIN_LARGE ~0x7fffffffUL /* large page address>     */
 +#define _REGION3_ENTRY_ORIGIN  ~0x7ffUL/* region third table origin>	     */
++=======
+ #define _REGION3_ENTRY_ORIGIN_LARGE ~0x7fffffffUL /* large page address	     */
+ #define _REGION3_ENTRY_ORIGIN  ~0x7ffUL/* region third table origin	     */
+ 
+ #define _REGION3_ENTRY_DIRTY	0x2000	/* SW region dirty bit */
+ #define _REGION3_ENTRY_YOUNG	0x1000	/* SW region young bit */
+ #define _REGION3_ENTRY_LARGE	0x0400	/* RTTE-format control, large page  */
+ #define _REGION3_ENTRY_READ	0x0002	/* SW region read bit */
+ #define _REGION3_ENTRY_WRITE	0x0001	/* SW region write bit */
++>>>>>>> 9e20b4dac1f5 (s390/pgtable: make pmd and pud helper functions available)
  
 -#ifdef CONFIG_MEM_SOFT_DIRTY
 -#define _REGION3_ENTRY_SOFT_DIRTY 0x4000 /* SW region soft dirty bit */
 -#else
 -#define _REGION3_ENTRY_SOFT_DIRTY 0x0000 /* SW region soft dirty bit */
 -#endif
 +#define _REGION3_ENTRY_LARGE	0x400	/* RTTE-format control, large page  */
 +#define _REGION3_ENTRY_RO	0x200	/* page protection bit		    */
 +#define _REGION3_ENTRY_CO	0x100	/* change-recording override	    */
 +
 +#define _REGION_ENTRY_BITS	0xfffffffffffff227UL
 +#define _REGION_ENTRY_BITS_LARGE 0xffffffff8000fe27UL
  
  /* Bits in the segment table entry */
  #define _SEGMENT_ENTRY_BITS	0xfffffffffffffe33UL
@@@ -538,17 -529,28 +549,30 @@@ static inline int pud_large(pud_t pud
  }
  
  static inline unsigned long pud_pfn(pud_t pud)
++<<<<<<< HEAD
++=======
+ {
+ 	unsigned long origin_mask;
+ 
+ 	origin_mask = _REGION3_ENTRY_ORIGIN;
+ 	if (pud_large(pud))
+ 		origin_mask = _REGION3_ENTRY_ORIGIN_LARGE;
+ 	return (pud_val(pud) & origin_mask) >> PAGE_SHIFT;
+ }
+ 
+ static inline int pud_bad(pud_t pud)
++>>>>>>> 9e20b4dac1f5 (s390/pgtable: make pmd and pud helper functions available)
  {
 -	/*
 -	 * With dynamic page table levels the pud can be a region table
 -	 * entry or a segment table entry. Check for the bit that are
 -	 * invalid for either table entry.
 -	 */
 -	unsigned long mask =
 -		~_SEGMENT_ENTRY_ORIGIN & ~_REGION_ENTRY_INVALID &
 -		~_REGION_ENTRY_TYPE_MASK & ~_REGION_ENTRY_LENGTH;
 -	return (pud_val(pud) & mask) != 0;
 +	unsigned long origin_mask;
 +
 +	origin_mask = _REGION3_ENTRY_ORIGIN;
 +	if (pud_large(pud))
 +		origin_mask = _REGION3_ENTRY_ORIGIN_LARGE;
 +	return (pud_val(pud) & origin_mask) >> PAGE_SHIFT;
  }
  
 +#endif /* CONFIG_64BIT */
 +
  static inline int pmd_present(pmd_t pmd)
  {
  	return pmd_val(pmd) != _SEGMENT_ENTRY_INVALID;
@@@ -1357,48 -1033,76 +1381,121 @@@ static inline pmd_t *pmd_offset(pud_t *
  #define pte_offset_map(pmd, address) pte_offset_kernel(pmd, address)
  #define pte_unmap(pte) do { } while (0)
  
++<<<<<<< HEAD
 +static inline void __pmd_idte(unsigned long address, pmd_t *pmdp)
 +{
 +	unsigned long sto = (unsigned long) pmdp -
 +			    pmd_index(address) * sizeof(pmd_t);
 +
 +	if (!(pmd_val(*pmdp) & _SEGMENT_ENTRY_INVALID)) {
 +		asm volatile(
 +			"	.insn	rrf,0xb98e0000,%2,%3,0,0"
 +			: "=m" (*pmdp)
 +			: "m" (*pmdp), "a" (sto),
 +			  "a" ((address & HPAGE_MASK))
 +			: "cc"
 +		);
 +	}
 +}
 +
 +static inline void __pudp_idte(unsigned long address, pud_t *pudp)
 +{
 +#ifdef CONFIG_64BIT
 +	unsigned long r3o;
 +
 +	r3o = (unsigned long) pudp - pud_index(address) * sizeof(pud_t);
 +	r3o |= _ASCE_TYPE_REGION3;
 +	asm volatile(
 +		"	.insn	rrf,0xb98e0000,%2,%3,0,0"
 +		: "=m" (*pudp)
 +		: "m" (*pudp), "a" (r3o), "a" ((address & PUD_MASK))
 +		: "cc");
 +#endif
 +}
 +
 +static inline void __pmd_csp(pmd_t *pmdp)
 +{
 +	register unsigned long reg2 asm("2") = pmd_val(*pmdp);
 +	register unsigned long reg3 asm("3") = pmd_val(*pmdp) |
 +					       _SEGMENT_ENTRY_INVALID;
 +	register unsigned long reg4 asm("4") = ((unsigned long) pmdp) + 5;
 +
 +	asm volatile(
 +		"	csp %1,%3"
 +		: "=m" (*pmdp)
 +		: "d" (reg2), "d" (reg3), "d" (reg4), "m" (*pmdp) : "cc");
++=======
+ static inline pmd_t pmd_wrprotect(pmd_t pmd)
+ {
+ 	pmd_val(pmd) &= ~_SEGMENT_ENTRY_WRITE;
+ 	pmd_val(pmd) |= _SEGMENT_ENTRY_PROTECT;
+ 	return pmd;
+ }
+ 
+ static inline pmd_t pmd_mkwrite(pmd_t pmd)
+ {
+ 	pmd_val(pmd) |= _SEGMENT_ENTRY_WRITE;
+ 	if (pmd_large(pmd) && !(pmd_val(pmd) & _SEGMENT_ENTRY_DIRTY))
+ 		return pmd;
+ 	pmd_val(pmd) &= ~_SEGMENT_ENTRY_PROTECT;
+ 	return pmd;
+ }
+ 
+ static inline pmd_t pmd_mkclean(pmd_t pmd)
+ {
+ 	if (pmd_large(pmd)) {
+ 		pmd_val(pmd) &= ~_SEGMENT_ENTRY_DIRTY;
+ 		pmd_val(pmd) |= _SEGMENT_ENTRY_PROTECT;
+ 	}
+ 	return pmd;
+ }
+ 
+ static inline pmd_t pmd_mkdirty(pmd_t pmd)
+ {
+ 	if (pmd_large(pmd)) {
+ 		pmd_val(pmd) |= _SEGMENT_ENTRY_DIRTY |
+ 				_SEGMENT_ENTRY_SOFT_DIRTY;
+ 		if (pmd_val(pmd) & _SEGMENT_ENTRY_WRITE)
+ 			pmd_val(pmd) &= ~_SEGMENT_ENTRY_PROTECT;
+ 	}
+ 	return pmd;
+ }
+ 
+ static inline pud_t pud_wrprotect(pud_t pud)
+ {
+ 	pud_val(pud) &= ~_REGION3_ENTRY_WRITE;
+ 	pud_val(pud) |= _REGION_ENTRY_PROTECT;
+ 	return pud;
+ }
+ 
+ static inline pud_t pud_mkwrite(pud_t pud)
+ {
+ 	pud_val(pud) |= _REGION3_ENTRY_WRITE;
+ 	if (pud_large(pud) && !(pud_val(pud) & _REGION3_ENTRY_DIRTY))
+ 		return pud;
+ 	pud_val(pud) &= ~_REGION_ENTRY_PROTECT;
+ 	return pud;
+ }
+ 
+ static inline pud_t pud_mkclean(pud_t pud)
+ {
+ 	if (pud_large(pud)) {
+ 		pud_val(pud) &= ~_REGION3_ENTRY_DIRTY;
+ 		pud_val(pud) |= _REGION_ENTRY_PROTECT;
+ 	}
+ 	return pud;
+ }
+ 
+ static inline pud_t pud_mkdirty(pud_t pud)
+ {
+ 	if (pud_large(pud)) {
+ 		pud_val(pud) |= _REGION3_ENTRY_DIRTY |
+ 				_REGION3_ENTRY_SOFT_DIRTY;
+ 		if (pud_val(pud) & _REGION3_ENTRY_WRITE)
+ 			pud_val(pud) &= ~_REGION_ENTRY_PROTECT;
+ 	}
+ 	return pud;
++>>>>>>> 9e20b4dac1f5 (s390/pgtable: make pmd and pud helper functions available)
  }
  
  #if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLB_PAGE)
* Unmerged path arch/s390/include/asm/pgtable.h
