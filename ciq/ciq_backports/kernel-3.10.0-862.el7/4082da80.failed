HID: wacom: generic: add mode change touch key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hid] wacom: generic: add mode change touch key (Aristeu Rozanski) [1475409 1462363]
Rebuild_FUZZ: 94.25%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 4082da80f46a6683439bb0357faadb18f0f5b2a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4082da80.failed

Wacom Cintiq Pro added a touch key to switch the tablet between
display and opaque mode. This patch informs the change by removing
the old devices and creating new ones with proper properties.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Ping Cheng <ping.cheng@wacom.com>
	Tested-by: Aaron Armstrong Skomra <aaron.skomra@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 4082da80f46a6683439bb0357faadb18f0f5b2a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom.h
index 74fdfe34ac8e,c7b9ab1907d8..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -109,10 -110,27 +109,11 @@@ enum wacom_worker 
  	WACOM_WORKER_WIRELESS,
  	WACOM_WORKER_BATTERY,
  	WACOM_WORKER_REMOTE,
+ 	WACOM_WORKER_MODE_CHANGE,
  };
  
 -struct wacom;
 -
 -struct wacom_led {
 -	struct led_classdev cdev;
 -	struct led_trigger trigger;
 -	struct wacom *wacom;
 -	unsigned int group;
 -	unsigned int id;
 -	u8 llv;
 -	u8 hlv;
 -	bool held;
 -};
 -
  struct wacom_group_leds {
  	u8 select; /* status led selector (0..3) */
 -	struct wacom_led *leds;
 -	unsigned int count;
 -	struct device *dev;
  };
  
  struct wacom_battery {
@@@ -149,8 -168,11 +150,13 @@@ struct wacom 
  	struct work_struct remote_work;
  	struct delayed_work init_work;
  	struct wacom_remote *remote;
++<<<<<<< HEAD
++=======
+ 	struct work_struct mode_change_work;
+ 	bool generic_has_leds;
++>>>>>>> 4082da80f46a (HID: wacom: generic: add mode change touch key)
  	struct wacom_leds {
  		struct wacom_group_leds *groups;
 -		unsigned int count;
  		u8 llv;       /* status led brightness no button (1..127) */
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
diff --cc drivers/hid/wacom_wac.c
index f74100faef9b,2c399a423957..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1754,6 -1768,26 +1754,29 @@@ static void wacom_wac_pad_usage_mapping
  		wacom_map_usage(input, usage, field, EV_ABS, ABS_WHEEL, 0);
  		features->device_type |= WACOM_DEVICETYPE_PAD;
  		break;
++<<<<<<< HEAD
++=======
+ 	case WACOM_HID_WD_BUTTONCONFIG:
+ 		wacom_map_usage(input, usage, field, EV_KEY, KEY_BUTTONCONFIG, 0);
+ 		features->device_type |= WACOM_DEVICETYPE_PAD;
+ 		break;
+ 	case WACOM_HID_WD_ONSCREEN_KEYBOARD:
+ 		wacom_map_usage(input, usage, field, EV_KEY, KEY_ONSCREEN_KEYBOARD, 0);
+ 		features->device_type |= WACOM_DEVICETYPE_PAD;
+ 		break;
+ 	case WACOM_HID_WD_CONTROLPANEL:
+ 		wacom_map_usage(input, usage, field, EV_KEY, KEY_CONTROLPANEL, 0);
+ 		features->device_type |= WACOM_DEVICETYPE_PAD;
+ 		break;
+ 	case WACOM_HID_WD_MODE_CHANGE:
+ 		/* do not overwrite previous data */
+ 		if (!wacom_wac->has_mode_change) {
+ 			wacom_wac->has_mode_change = true;
+ 			wacom_wac->is_direct_mode = true;
+ 		}
+ 		features->device_type |= WACOM_DEVICETYPE_PAD;
+ 		break;
++>>>>>>> 4082da80f46a (HID: wacom: generic: add mode change touch key)
  	}
  
  	switch (equivalent_usage & 0xfffffff0) {
@@@ -1821,6 -1857,19 +1844,22 @@@ static void wacom_wac_pad_event(struct 
  			input_sync(wacom_wac->shared->touch_input);
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case WACOM_HID_WD_MODE_CHANGE:
+ 		if (wacom_wac->is_direct_mode != value) {
+ 			wacom_wac->is_direct_mode = value;
+ 			wacom_schedule_work(&wacom->wacom_wac, WACOM_WORKER_MODE_CHANGE);
+ 		}
+ 		break;
+ 
+ 	case WACOM_HID_WD_BUTTONCENTER:
+ 		for (i = 0; i < wacom->led.count; i++)
+ 			wacom_update_led(wacom, features->numbered_buttons,
+ 					 value, i);
+ 		 /* fall through*/
++>>>>>>> 4082da80f46a (HID: wacom: generic: add mode change touch key)
  	default:
  		input_event(input, usage->type, usage->code, value);
  		break;
diff --cc drivers/hid/wacom_wac.h
index dd7c1ba6c1d6,d9669c6116b7..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -118,6 -120,10 +118,13 @@@
  #define WACOM_HID_WD_BATTERY_LEVEL      (WACOM_HID_UP_WACOMDIGITIZER | 0x043b)
  #define WACOM_HID_WD_EXPRESSKEY00       (WACOM_HID_UP_WACOMDIGITIZER | 0x0910)
  #define WACOM_HID_WD_EXPRESSKEYCAP00    (WACOM_HID_UP_WACOMDIGITIZER | 0x0950)
++<<<<<<< HEAD
++=======
+ #define WACOM_HID_WD_MODE_CHANGE        (WACOM_HID_UP_WACOMDIGITIZER | 0x0980)
+ #define WACOM_HID_WD_CONTROLPANEL       (WACOM_HID_UP_WACOMDIGITIZER | 0x0982)
+ #define WACOM_HID_WD_ONSCREEN_KEYBOARD  (WACOM_HID_UP_WACOMDIGITIZER | 0x0983)
+ #define WACOM_HID_WD_BUTTONCONFIG       (WACOM_HID_UP_WACOMDIGITIZER | 0x0986)
++>>>>>>> 4082da80f46a (HID: wacom: generic: add mode change touch key)
  #define WACOM_HID_WD_BUTTONHOME         (WACOM_HID_UP_WACOMDIGITIZER | 0x0990)
  #define WACOM_HID_WD_BUTTONUP           (WACOM_HID_UP_WACOMDIGITIZER | 0x0991)
  #define WACOM_HID_WD_BUTTONDOWN         (WACOM_HID_UP_WACOMDIGITIZER | 0x0992)
* Unmerged path drivers/hid/wacom.h
diff --git a/drivers/hid/wacom_sys.c b/drivers/hid/wacom_sys.c
index a45e86166897..da7acf0ee81b 100644
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@ -324,6 +324,13 @@ static void wacom_post_parse_hid(struct hid_device *hdev,
 
 	if (features->type == HID_GENERIC) {
 		/* Any last-minute generic device setup */
+		if (wacom_wac->has_mode_change) {
+			if (wacom_wac->is_direct_mode)
+				features->device_type |= WACOM_DEVICETYPE_DIRECT;
+			else
+				features->device_type &= ~WACOM_DEVICETYPE_DIRECT;
+		}
+
 		if (features->touch_max > 1) {
 			input_mt_init_slots(wacom_wac->touch_input, wacom_wac->features.touch_max,
 				    INPUT_MT_DIRECT);
@@ -2200,6 +2207,46 @@ static void wacom_remote_work(struct work_struct *work)
 	}
 }
 
+static void wacom_mode_change_work(struct work_struct *work)
+{
+	struct wacom *wacom = container_of(work, struct wacom, mode_change_work);
+	struct wacom_shared *shared = wacom->wacom_wac.shared;
+	struct wacom *wacom1 = NULL;
+	struct wacom *wacom2 = NULL;
+	bool is_direct = wacom->wacom_wac.is_direct_mode;
+	int error = 0;
+
+	if (shared->pen) {
+		wacom1 = hid_get_drvdata(shared->pen);
+		wacom_release_resources(wacom1);
+		hid_hw_stop(wacom1->hdev);
+		wacom1->wacom_wac.has_mode_change = true;
+		wacom1->wacom_wac.is_direct_mode = is_direct;
+	}
+
+	if (shared->touch) {
+		wacom2 = hid_get_drvdata(shared->touch);
+		wacom_release_resources(wacom2);
+		hid_hw_stop(wacom2->hdev);
+		wacom2->wacom_wac.has_mode_change = true;
+		wacom2->wacom_wac.is_direct_mode = is_direct;
+	}
+
+	if (wacom1) {
+		error = wacom_parse_and_register(wacom1, false);
+		if (error)
+			return;
+	}
+
+	if (wacom2) {
+		error = wacom_parse_and_register(wacom2, false);
+		if (error)
+			return;
+	}
+
+	return;
+}
+
 static int wacom_probe(struct hid_device *hdev,
 		const struct hid_device_id *id)
 {
@@ -2244,6 +2291,7 @@ static int wacom_probe(struct hid_device *hdev,
 	INIT_WORK(&wacom->wireless_work, wacom_wireless_work);
 	INIT_WORK(&wacom->battery_work, wacom_battery_work);
 	INIT_WORK(&wacom->remote_work, wacom_remote_work);
+	INIT_WORK(&wacom->mode_change_work, wacom_mode_change_work);
 
 	/* ask for the report descriptor to be loaded by HID */
 	error = hid_parse(hdev);
@@ -2286,6 +2334,7 @@ static void wacom_remove(struct hid_device *hdev)
 	cancel_work_sync(&wacom->wireless_work);
 	cancel_work_sync(&wacom->battery_work);
 	cancel_work_sync(&wacom->remote_work);
+	cancel_work_sync(&wacom->mode_change_work);
 	if (hdev->bus == BUS_BLUETOOTH)
 		device_remove_file(&hdev->dev, &dev_attr_speed);
 
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
