qdisc: add tracepoint qdisc:qdisc_dequeue for dequeued SKBs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit e543002f77f463501d47fab43acf7ba881e9dcaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e543002f.failed

The main purpose of this tracepoint is to monitor bulk dequeue
in the network qdisc layer, as it cannot be deducted from the
existing qdisc stats.

The txq_state can be used for determining the reason for zero packet
dequeues, see enum netdev_queue_state_t.

Notice all packets doesn't necessary activate this tracepoint. As
qdiscs with flag TCQ_F_CAN_BYPASS, can directly invoke
sch_direct_xmit() when qdisc_qlen is zero.

Remember that perf record supports filters like:

 perf record -e qdisc:qdisc_dequeue \
  --filter 'ifindex == 4 && (packets > 1 || txq_state > 0)'

	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e543002f77f463501d47fab43acf7ba881e9dcaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/net-traces.c
#	net/sched/sch_generic.c
diff --cc net/core/net-traces.c
index ba3c0120786c,4f1468ccd056..000000000000
--- a/net/core/net-traces.c
+++ b/net/core/net-traces.c
@@@ -31,6 -31,12 +31,15 @@@
  #include <trace/events/napi.h>
  #include <trace/events/sock.h>
  #include <trace/events/udp.h>
++<<<<<<< HEAD
++=======
+ #include <trace/events/fib.h>
+ #include <trace/events/qdisc.h>
+ #if IS_ENABLED(CONFIG_IPV6)
+ #include <trace/events/fib6.h>
+ EXPORT_TRACEPOINT_SYMBOL_GPL(fib6_table_lookup);
+ #endif
++>>>>>>> e543002f77f4 (qdisc: add tracepoint qdisc:qdisc_dequeue for dequeued SKBs)
  
  EXPORT_TRACEPOINT_SYMBOL_GPL(kfree_skb);
  
diff --cc net/sched/sch_generic.c
index 57cbfa322683,c6b89a34e8d2..000000000000
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@@ -97,16 -127,34 +98,46 @@@ static struct sk_buff *dequeue_skb(stru
  			q->q.qlen--;
  		} else
  			skb = NULL;
++<<<<<<< HEAD
 +		/* skb in gso_skb were already validated */
 +		*validate = false;
 +	} else {
 +		if (!(q->flags & TCQ_F_ONETXQUEUE) ||
 +		    !netif_xmit_frozen_or_stopped(txq)) {
 +			skb = q->dequeue(q);
 +			if (skb && qdisc_may_bulk(q))
 +				try_bulk_dequeue_skb(q, skb, txq, packets);
 +		}
++=======
+ 		goto trace;
  	}
+ 	*validate = true;
+ 	skb = q->skb_bad_txq;
+ 	if (unlikely(skb)) {
+ 		/* check the reason of requeuing without tx lock first */
+ 		txq = skb_get_tx_queue(txq->dev, skb);
+ 		if (!netif_xmit_frozen_or_stopped(txq)) {
+ 			q->skb_bad_txq = NULL;
+ 			qdisc_qstats_backlog_dec(q, skb);
+ 			q->q.qlen--;
+ 			goto bulk;
+ 		}
+ 		skb = NULL;
+ 		goto trace;
+ 	}
+ 	if (!(q->flags & TCQ_F_ONETXQUEUE) ||
+ 	    !netif_xmit_frozen_or_stopped(txq))
+ 		skb = q->dequeue(q);
+ 	if (skb) {
+ bulk:
+ 		if (qdisc_may_bulk(q))
+ 			try_bulk_dequeue_skb(q, skb, txq, packets);
+ 		else
+ 			try_bulk_dequeue_skb_slow(q, skb, packets);
++>>>>>>> e543002f77f4 (qdisc: add tracepoint qdisc:qdisc_dequeue for dequeued SKBs)
+ 	}
+ trace:
+ 	trace_qdisc_dequeue(q, txq, *packets, skb);
  	return skb;
  }
  
diff --git a/include/trace/events/qdisc.h b/include/trace/events/qdisc.h
new file mode 100644
index 000000000000..60d0d8bd336d
--- /dev/null
+++ b/include/trace/events/qdisc.h
@@ -0,0 +1,50 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM qdisc
+
+#if !defined(_TRACE_QDISC_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_QDISC_H_
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/tracepoint.h>
+#include <linux/ftrace.h>
+
+TRACE_EVENT(qdisc_dequeue,
+
+	TP_PROTO(struct Qdisc *qdisc, const struct netdev_queue *txq,
+		 int packets, struct sk_buff *skb),
+
+	TP_ARGS(qdisc, txq, packets, skb),
+
+	TP_STRUCT__entry(
+		__field(	struct Qdisc *,		qdisc	)
+		__field(const	struct netdev_queue *,	txq	)
+		__field(	int,			packets	)
+		__field(	void *,			skbaddr	)
+		__field(	int,			ifindex	)
+		__field(	u32,			handle	)
+		__field(	u32,			parent	)
+		__field(	unsigned long,		txq_state)
+	),
+
+	/* skb==NULL indicate packets dequeued was 0, even when packets==1 */
+	TP_fast_assign(
+		__entry->qdisc		= qdisc;
+		__entry->txq		= txq;
+		__entry->packets	= skb ? packets : 0;
+		__entry->skbaddr	= skb;
+		__entry->ifindex	= txq->dev ? txq->dev->ifindex : 0;
+		__entry->handle		= qdisc->handle;
+		__entry->parent		= qdisc->parent;
+		__entry->txq_state	= txq->state;
+	),
+
+	TP_printk("dequeue ifindex=%d qdisc handle=0x%X parent=0x%X txq_state=0x%lX packets=%d skbaddr=%p",
+		  __entry->ifindex, __entry->handle, __entry->parent,
+		  __entry->txq_state, __entry->packets, __entry->skbaddr )
+);
+
+#endif /* _TRACE_QDISC_H_ */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
* Unmerged path net/core/net-traces.c
* Unmerged path net/sched/sch_generic.c
