s390/trng: Introduce s390 TRNG device driver.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] trng: Introduce s390 TRNG device driver (Hendrik Brueckner) [1375266]
Rebuild_FUZZ: 92.86%
commit-author Harald Freudenberger <freude@linux.vnet.ibm.com>
commit bbcb478e3fefa5d9acff6a5311073fae0809a9c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bbcb478e.failed

This patch introduces a new device driver s390-trng for the
s390 platform which exploits the new PRNO TRNG cpacf
subfunction. The true-random-number-generator is accessible
from userspace, by default visible as /dev/trng. The driver
also registers at the kernel build-in hwrng API to feed the
hwrng with fresh entropy data. This generic device driver
for hardware random data is visible from userspace as
/dev/hwrng.

	Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit bbcb478e3fefa5d9acff6a5311073fae0809a9c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/hw_random/Kconfig
#	drivers/char/hw_random/Makefile
diff --cc drivers/char/hw_random/Kconfig
index 34f8b0c021d5,b9918fb9587d..000000000000
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@@ -250,17 -281,163 +250,166 @@@ config HW_RANDOM_PICOXCEL
  
  	  If unsure, say Y.
  
 -config HW_RANDOM_POWERNV
 -	tristate "PowerNV Random Number Generator support"
 -	depends on PPC_POWERNV
 -	default HW_RANDOM
 +config HW_RANDOM_PPC4XX
 +	tristate "PowerPC 4xx generic true random number generator support"
 +	depends on HW_RANDOM && PPC && 4xx
  	---help---
 -	  This is the driver for Random Number Generator hardware found
 -	  in POWER7+ and above machines for PowerNV platform.
 +	 This driver provides the kernel-side support for the TRNG hardware
 +	 found in the security function of some PowerPC 4xx SoCs.
  
 -	  To compile this driver as a module, choose M here: the
 -	  module will be called powernv-rng.
 +	 To compile this driver as a module, choose M here: the
 +	 module will be called ppc4xx-rng.
  
++<<<<<<< HEAD
 +	 If unsure, say N.
++=======
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_EXYNOS
+ 	tristate "EXYNOS HW random number generator support"
+ 	depends on ARCH_EXYNOS || COMPILE_TEST
+ 	depends on HAS_IOMEM
+ 	default HW_RANDOM
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on EXYNOS SOCs.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called exynos-rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_TPM
+ 	tristate "TPM HW Random Number Generator support"
+ 	depends on TCG_TPM
+ 	default HW_RANDOM
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator in the Trusted Platform Module
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called tpm-rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_HISI
+ 	tristate "Hisilicon Random Number Generator support"
+ 	depends on HW_RANDOM && ARCH_HISI
+ 	default HW_RANDOM
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on Hisilicon Hip04 and Hip05 SoC.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called hisi-rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_MSM
+ 	tristate "Qualcomm SoCs Random Number Generator support"
+ 	depends on HW_RANDOM && ARCH_QCOM
+ 	default HW_RANDOM
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on Qualcomm SoCs.
+ 
+ 	  To compile this driver as a module, choose M here. the
+ 	  module will be called msm-rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_ST
+ 	tristate "ST Microelectronics HW Random Number Generator support"
+ 	depends on HW_RANDOM && ARCH_STI
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on STi series of SoCs.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called st-rng.
+ 
+ config HW_RANDOM_XGENE
+ 	tristate "APM X-Gene True Random Number Generator (TRNG) support"
+ 	depends on HW_RANDOM && ARCH_XGENE
+ 	default HW_RANDOM
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on APM X-Gene SoC.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called xgene_rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_STM32
+ 	tristate "STMicroelectronics STM32 random number generator"
+ 	depends on HW_RANDOM && (ARCH_STM32 || COMPILE_TEST)
+ 	depends on HAS_IOMEM
+ 	help
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on STM32 microcontrollers.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called stm32-rng.
+ 
+ 	  If unsure, say N.
+ 
+ config HW_RANDOM_PIC32
+ 	tristate "Microchip PIC32 Random Number Generator support"
+ 	depends on HW_RANDOM && MACH_PIC32
+ 	default y
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on a PIC32.
+ 
+ 	  To compile this driver as a module, choose M here. the
+ 	  module will be called pic32-rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_MESON
+ 	tristate "Amlogic Meson Random Number Generator support"
+ 	depends on HW_RANDOM
+ 	depends on ARCH_MESON || COMPILE_TEST
+ 	default y
+ 	---help---
+ 	  This driver provides kernel-side support for the Random Number
+ 	  Generator hardware found on Amlogic Meson SoCs.
+ 
+ 	  To compile this driver as a module, choose M here. the
+ 	  module will be called meson-rng.
+ 
+ 	  If unsure, say Y.
+ 
+ config HW_RANDOM_CAVIUM
+        tristate "Cavium ThunderX Random Number Generator support"
+        depends on HW_RANDOM && PCI && (ARM64 || (COMPILE_TEST && 64BIT))
+        default HW_RANDOM
+        ---help---
+          This driver provides kernel-side support for the Random Number
+          Generator hardware found on Cavium SoCs.
+ 
+          To compile this driver as a module, choose M here: the
+          module will be called cavium_rng.
+ 
+          If unsure, say Y.
+ 
+ config HW_RANDOM_S390
+ 	tristate "S390 True Random Number Generator support"
+ 	depends on S390
+ 	default HW_RANDOM
+ 	---help---
+ 	  This driver provides kernel-side support for the True
+ 	  Random Number Generator available as CPACF extension
+ 	  on modern s390 hardware platforms.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called s390-trng.
+ 
+ 	  If unsure, say Y.
+ 
+ endif # HW_RANDOM
++>>>>>>> bbcb478e3fef (s390/trng: Introduce s390 TRNG device driver.)
  
  config UML_RANDOM
  	depends on UML
diff --cc drivers/char/hw_random/Makefile
index d7d2435ff7fa,dd1765246255..000000000000
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@@ -26,5 -25,15 +26,17 @@@ obj-$(CONFIG_HW_RANDOM_PPC4XX) += ppc4x
  obj-$(CONFIG_HW_RANDOM_PSERIES) += pseries-rng.o
  obj-$(CONFIG_HW_RANDOM_POWERNV) += powernv-rng.o
  obj-$(CONFIG_HW_RANDOM_EXYNOS)	+= exynos-rng.o
 -obj-$(CONFIG_HW_RANDOM_HISI)	+= hisi-rng.o
  obj-$(CONFIG_HW_RANDOM_TPM) += tpm-rng.o
  obj-$(CONFIG_HW_RANDOM_BCM2835) += bcm2835-rng.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_HW_RANDOM_IPROC_RNG200) += iproc-rng200.o
+ obj-$(CONFIG_HW_RANDOM_MSM) += msm-rng.o
+ obj-$(CONFIG_HW_RANDOM_ST) += st-rng.o
+ obj-$(CONFIG_HW_RANDOM_XGENE) += xgene-rng.o
+ obj-$(CONFIG_HW_RANDOM_STM32) += stm32-rng.o
+ obj-$(CONFIG_HW_RANDOM_PIC32) += pic32-rng.o
+ obj-$(CONFIG_HW_RANDOM_MESON) += meson-rng.o
+ obj-$(CONFIG_HW_RANDOM_CAVIUM) += cavium-rng.o cavium-rng-vf.o
+ obj-$(CONFIG_HW_RANDOM_S390) += s390-trng.o
++>>>>>>> bbcb478e3fef (s390/trng: Introduce s390 TRNG device driver.)
* Unmerged path drivers/char/hw_random/Kconfig
* Unmerged path drivers/char/hw_random/Makefile
diff --git a/drivers/char/hw_random/s390-trng.c b/drivers/char/hw_random/s390-trng.c
new file mode 100644
index 000000000000..aca48e893fca
--- /dev/null
+++ b/drivers/char/hw_random/s390-trng.c
@@ -0,0 +1,268 @@
+/*
+ * s390 TRNG device driver
+ *
+ * Driver for the TRNG (true random number generation) command
+ * available via CPACF extension MSA 7 on the s390 arch.
+
+ * Copyright IBM Corp. 2017
+ * Author(s): Harald Freudenberger <freude@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License (version 2 only)
+ * as published by the Free Software Foundation.
+ *
+ */
+
+#define KMSG_COMPONENT "trng"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include <linux/hw_random.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/cpufeature.h>
+#include <linux/miscdevice.h>
+#include <linux/debugfs.h>
+#include <linux/atomic.h>
+#include <linux/random.h>
+#include <linux/sched/signal.h>
+#include <asm/debug.h>
+#include <asm/cpacf.h>
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("IBM Corporation");
+MODULE_DESCRIPTION("s390 CPACF TRNG device driver");
+
+
+/* trng related debug feature things */
+
+static debug_info_t *debug_info;
+
+#define DEBUG_DBG(...)	debug_sprintf_event(debug_info, 6, ##__VA_ARGS__)
+#define DEBUG_INFO(...) debug_sprintf_event(debug_info, 5, ##__VA_ARGS__)
+#define DEBUG_WARN(...) debug_sprintf_event(debug_info, 4, ##__VA_ARGS__)
+#define DEBUG_ERR(...)	debug_sprintf_event(debug_info, 3, ##__VA_ARGS__)
+
+
+/* trng helpers */
+
+static atomic64_t trng_dev_counter = ATOMIC64_INIT(0);
+static atomic64_t trng_hwrng_counter = ATOMIC64_INIT(0);
+
+
+/* file io functions */
+
+static int trng_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static ssize_t trng_read(struct file *file, char __user *ubuf,
+			 size_t nbytes, loff_t *ppos)
+{
+	u8 buf[32];
+	u8 *p = buf;
+	unsigned int n;
+	ssize_t ret = 0;
+
+	/*
+	 * use buf for requests <= sizeof(buf),
+	 * otherwise allocate one page and fetch
+	 * pagewise.
+	 */
+
+	if (nbytes > sizeof(buf)) {
+		p = (u8 *) __get_free_page(GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+	}
+
+	while (nbytes) {
+		if (need_resched()) {
+			if (signal_pending(current)) {
+				if (ret == 0)
+					ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+		n = nbytes > PAGE_SIZE ? PAGE_SIZE : nbytes;
+		cpacf_trng(NULL, 0, p, n);
+		atomic64_add(n, &trng_dev_counter);
+		if (copy_to_user(ubuf, p, n)) {
+			ret = -EFAULT;
+			break;
+		}
+		nbytes -= n;
+		ubuf += n;
+		ret += n;
+	}
+
+	if (p != buf)
+		free_page((unsigned long) p);
+
+	DEBUG_DBG("trng_read()=%zd\n", ret);
+	return ret;
+}
+
+
+/* sysfs */
+
+static ssize_t trng_counter_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	u64 dev_counter = atomic64_read(&trng_dev_counter);
+	u64 hwrng_counter = atomic64_read(&trng_hwrng_counter);
+#if IS_ENABLED(CONFIG_ARCH_RANDOM)
+	u64 arch_counter = atomic64_read(&s390_arch_random_counter);
+
+	return snprintf(buf, PAGE_SIZE,
+			"trng:  %llu\n"
+			"hwrng: %llu\n"
+			"arch:  %llu\n"
+			"total: %llu\n",
+			dev_counter, hwrng_counter, arch_counter,
+			dev_counter + hwrng_counter + arch_counter);
+#else
+	return snprintf(buf, PAGE_SIZE,
+			"trng:  %llu\n"
+			"hwrng: %llu\n"
+			"total: %llu\n",
+			dev_counter, hwrng_counter,
+			dev_counter + hwrng_counter);
+#endif
+}
+static DEVICE_ATTR(byte_counter, 0444, trng_counter_show, NULL);
+
+static struct attribute *trng_dev_attrs[] = {
+	&dev_attr_byte_counter.attr,
+	NULL
+};
+
+static const struct attribute_group trng_dev_attr_group = {
+	.attrs = trng_dev_attrs
+};
+
+static const struct attribute_group *trng_dev_attr_groups[] = {
+	&trng_dev_attr_group,
+	NULL
+};
+
+static const struct file_operations trng_fops = {
+	.owner		= THIS_MODULE,
+	.open		= &trng_open,
+	.release	= NULL,
+	.read		= &trng_read,
+	.llseek		= noop_llseek,
+};
+
+static struct miscdevice trng_dev = {
+	.name	= "trng",
+	.minor	= MISC_DYNAMIC_MINOR,
+	.mode	= 0444,
+	.fops	= &trng_fops,
+	.groups = trng_dev_attr_groups,
+};
+
+
+/* hwrng_register */
+
+static inline void _trng_hwrng_read(u8 *buf, size_t len)
+{
+	cpacf_trng(NULL, 0, buf, len);
+	atomic64_add(len, &trng_hwrng_counter);
+}
+
+static int trng_hwrng_data_read(struct hwrng *rng, u32 *data)
+{
+	size_t len = sizeof(*data);
+
+	_trng_hwrng_read((u8 *) data, len);
+
+	DEBUG_DBG("trng_hwrng_data_read()=%zu\n", len);
+
+	return len;
+}
+
+static int trng_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)
+{
+	size_t len = max <= PAGE_SIZE ? max : PAGE_SIZE;
+
+	_trng_hwrng_read((u8 *) data, len);
+
+	DEBUG_DBG("trng_hwrng_read()=%zu\n", len);
+
+	return len;
+}
+
+/*
+ * hwrng register struct
+ * The trng is suppost to have 100% entropy, and thus
+ * we register with a very high quality value.
+ */
+static struct hwrng trng_hwrng_dev = {
+	.name		= "s390-trng",
+	.data_read	= trng_hwrng_data_read,
+	.read		= trng_hwrng_read,
+	.quality	= 999,
+};
+
+
+/* init and exit */
+
+static void __init trng_debug_init(void)
+{
+	debug_info = debug_register("trng", 1, 1, 4 * sizeof(long));
+	debug_register_view(debug_info, &debug_sprintf_view);
+	debug_set_level(debug_info, 3);
+}
+
+static void trng_debug_exit(void)
+{
+	debug_unregister(debug_info);
+}
+
+static int __init trng_init(void)
+{
+	int ret;
+
+	trng_debug_init();
+
+	/* check if subfunction CPACF_PRNO_TRNG is available */
+	if (!cpacf_query_func(CPACF_PRNO, CPACF_PRNO_TRNG)) {
+		DEBUG_INFO("trng_init CPACF_PRNO_TRNG not available\n");
+		ret = -ENODEV;
+		goto out_dbg;
+	}
+
+	ret = misc_register(&trng_dev);
+	if (ret) {
+		DEBUG_WARN("trng_init misc_register() failed rc=%d\n", ret);
+		goto out_dbg;
+	}
+
+	ret = hwrng_register(&trng_hwrng_dev);
+	if (ret) {
+		DEBUG_WARN("trng_init hwrng_register() failed rc=%d\n", ret);
+		goto out_misc;
+	}
+
+	DEBUG_DBG("trng_init successful\n");
+
+	return 0;
+
+out_misc:
+	misc_deregister(&trng_dev);
+out_dbg:
+	trng_debug_exit();
+	return ret;
+}
+
+static void __exit trng_exit(void)
+{
+	hwrng_unregister(&trng_hwrng_dev);
+	misc_deregister(&trng_dev);
+	trng_debug_exit();
+}
+
+module_cpu_feature_match(MSA, trng_init);
+module_exit(trng_exit);
