nvme: Enable autonomous power state transitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] Enable autonomous power state transitions (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 93.18%
commit-author Andy Lutomirski <luto@kernel.org>
commit c5552fde102fcc3f2cf9e502b8ac90e3500d8fdf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c5552fde.failed

NVMe devices can advertise multiple power states.  These states can
be either "operational" (the device is fully functional but possibly
slow) or "non-operational" (the device is asleep until woken up).
Some devices can automatically enter a non-operational state when
idle for a specified amount of time and then automatically wake back
up when needed.

The hardware configuration is a table.  For each state, an entry in
the table indicates the next deeper non-operational state, if any,
to autonomously transition to and the idle time required before
transitioning.

This patch teaches the driver to program APST so that each successive
non-operational state will be entered after an idle time equal to 100%
of the total latency (entry plus exit) associated with that state.
The maximum acceptable latency is controlled using dev_pm_qos
(e.g. power/pm_qos_latency_tolerance_us in sysfs); non-operational
states with total latency greater than this value will not be used.
As a special case, setting the latency tolerance to 0 will disable
APST entirely.  On hardware without APST support, the sysfs file will
not be exposed.

The latency tolerance for newly-probed devices is set by the module
parameter nvme_core.default_ps_max_latency_us.

In theory, the device can expose "default" APST table, but this
doesn't seem to function correctly on my device (Samsung 950), nor
does it seem particularly useful.  There is also an optional
mechanism by which a configuration can be "saved" so it will be
automatically loaded on reset.  This can be configured from
userspace, but it doesn't seem useful to support in the driver.

On my laptop, enabling APST seems to save nearly 1W.

The hardware tables can be decoded in userspace with nvme-cli.
'nvme id-ctrl /dev/nvmeN' will show the power state table and
'nvme get-feature -f 0x0c -H /dev/nvme0' will show the current APST
configuration.

This feature is quirked off on a known-buggy Samsung device.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c5552fde102fcc3f2cf9e502b8ac90e3500d8fdf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	include/linux/nvme.h
diff --cc drivers/nvme/host/core.c
index bd223cb63595,849e85847ad4..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -25,7 -25,8 +25,12 @@@
  #include <linux/pr.h>
  #include <linux/ptrace.h>
  #include <linux/nvme_ioctl.h>
++<<<<<<< HEAD
 +#include <linux/idr.h>
++=======
+ #include <linux/t10-pi.h>
+ #include <linux/pm_qos.h>
++>>>>>>> c5552fde102f (nvme: Enable autonomous power state transitions)
  #include <scsi/sg.h>
  #include <asm/unaligned.h>
  
@@@ -1162,9 -1252,180 +1172,184 @@@ static void nvme_set_queue_limits(struc
  	}
  	if (ctrl->quirks & NVME_QUIRK_STRIPE_SIZE)
  		blk_queue_chunk_sectors(q, ctrl->max_hw_sectors);
 -	blk_queue_virt_boundary(q, ctrl->page_size - 1);
  	if (ctrl->vwc & NVME_CTRL_VWC_PRESENT)
++<<<<<<< HEAD
 +		blk_queue_flush(q, REQ_FLUSH | REQ_FUA);
 +	blk_queue_virt_boundary(q, ctrl->page_size - 1);
++=======
+ 		vwc = true;
+ 	blk_queue_write_cache(q, vwc, vwc);
+ }
+ 
+ static void nvme_configure_apst(struct nvme_ctrl *ctrl)
+ {
+ 	/*
+ 	 * APST (Autonomous Power State Transition) lets us program a
+ 	 * table of power state transitions that the controller will
+ 	 * perform automatically.  We configure it with a simple
+ 	 * heuristic: we are willing to spend at most 2% of the time
+ 	 * transitioning between power states.  Therefore, when running
+ 	 * in any given state, we will enter the next lower-power
+ 	 * non-operational state after waiting 100 * (enlat + exlat)
+ 	 * microseconds, as long as that state's total latency is under
+ 	 * the requested maximum latency.
+ 	 *
+ 	 * We will not autonomously enter any non-operational state for
+ 	 * which the total latency exceeds ps_max_latency_us.  Users
+ 	 * can set ps_max_latency_us to zero to turn off APST.
+ 	 */
+ 
+ 	unsigned apste;
+ 	struct nvme_feat_auto_pst *table;
+ 	int ret;
+ 
+ 	/*
+ 	 * If APST isn't supported or if we haven't been initialized yet,
+ 	 * then don't do anything.
+ 	 */
+ 	if (!ctrl->apsta)
+ 		return;
+ 
+ 	if (ctrl->npss > 31) {
+ 		dev_warn(ctrl->device, "NPSS is invalid; not using APST\n");
+ 		return;
+ 	}
+ 
+ 	table = kzalloc(sizeof(*table), GFP_KERNEL);
+ 	if (!table)
+ 		return;
+ 
+ 	if (ctrl->ps_max_latency_us == 0) {
+ 		/* Turn off APST. */
+ 		apste = 0;
+ 	} else {
+ 		__le64 target = cpu_to_le64(0);
+ 		int state;
+ 
+ 		/*
+ 		 * Walk through all states from lowest- to highest-power.
+ 		 * According to the spec, lower-numbered states use more
+ 		 * power.  NPSS, despite the name, is the index of the
+ 		 * lowest-power state, not the number of states.
+ 		 */
+ 		for (state = (int)ctrl->npss; state >= 0; state--) {
+ 			u64 total_latency_us, transition_ms;
+ 
+ 			if (target)
+ 				table->entries[state] = target;
+ 
+ 			/*
+ 			 * Is this state a useful non-operational state for
+ 			 * higher-power states to autonomously transition to?
+ 			 */
+ 			if (!(ctrl->psd[state].flags &
+ 			      NVME_PS_FLAGS_NON_OP_STATE))
+ 				continue;
+ 
+ 			total_latency_us =
+ 				(u64)le32_to_cpu(ctrl->psd[state].entry_lat) +
+ 				+ le32_to_cpu(ctrl->psd[state].exit_lat);
+ 			if (total_latency_us > ctrl->ps_max_latency_us)
+ 				continue;
+ 
+ 			/*
+ 			 * This state is good.  Use it as the APST idle
+ 			 * target for higher power states.
+ 			 */
+ 			transition_ms = total_latency_us + 19;
+ 			do_div(transition_ms, 20);
+ 			if (transition_ms > (1 << 24) - 1)
+ 				transition_ms = (1 << 24) - 1;
+ 
+ 			target = cpu_to_le64((state << 3) |
+ 					     (transition_ms << 8));
+ 		}
+ 
+ 		apste = 1;
+ 	}
+ 
+ 	ret = nvme_set_features(ctrl, NVME_FEAT_AUTO_PST, apste,
+ 				table, sizeof(*table), NULL);
+ 	if (ret)
+ 		dev_err(ctrl->device, "failed to set APST feature (%d)\n", ret);
+ 
+ 	kfree(table);
+ }
+ 
+ static void nvme_set_latency_tolerance(struct device *dev, s32 val)
+ {
+ 	struct nvme_ctrl *ctrl = dev_get_drvdata(dev);
+ 	u64 latency;
+ 
+ 	switch (val) {
+ 	case PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT:
+ 	case PM_QOS_LATENCY_ANY:
+ 		latency = U64_MAX;
+ 		break;
+ 
+ 	default:
+ 		latency = val;
+ 	}
+ 
+ 	if (ctrl->ps_max_latency_us != latency) {
+ 		ctrl->ps_max_latency_us = latency;
+ 		nvme_configure_apst(ctrl);
+ 	}
+ }
+ 
+ struct nvme_core_quirk_entry {
+ 	/*
+ 	 * NVMe model and firmware strings are padded with spaces.  For
+ 	 * simplicity, strings in the quirk table are padded with NULLs
+ 	 * instead.
+ 	 */
+ 	u16 vid;
+ 	const char *mn;
+ 	const char *fr;
+ 	unsigned long quirks;
+ };
+ 
+ static const struct nvme_core_quirk_entry core_quirks[] = {
+ 	/*
+ 	 * Seen on a Samsung "SM951 NVMe SAMSUNG 256GB": using APST causes
+ 	 * the controller to go out to lunch.  It dies when the watchdog
+ 	 * timer reads CSTS and gets 0xffffffff.
+ 	 */
+ 	{
+ 		.vid = 0x144d,
+ 		.fr = "BXW75D0Q",
+ 		.quirks = NVME_QUIRK_NO_APST,
+ 	},
+ };
+ 
+ /* match is null-terminated but idstr is space-padded. */
+ static bool string_matches(const char *idstr, const char *match, size_t len)
+ {
+ 	size_t matchlen;
+ 
+ 	if (!match)
+ 		return true;
+ 
+ 	matchlen = strlen(match);
+ 	WARN_ON_ONCE(matchlen > len);
+ 
+ 	if (memcmp(idstr, match, matchlen))
+ 		return false;
+ 
+ 	for (; matchlen < len; matchlen++)
+ 		if (idstr[matchlen] != ' ')
+ 			return false;
+ 
+ 	return true;
+ }
+ 
+ static bool quirk_matches(const struct nvme_id_ctrl *id,
+ 			  const struct nvme_core_quirk_entry *q)
+ {
+ 	return q->vid == le16_to_cpu(id->vid) &&
+ 		string_matches(id->mn, q->mn, sizeof(id->mn)) &&
+ 		string_matches(id->fr, q->fr, sizeof(id->fr));
++>>>>>>> c5552fde102f (nvme: Enable autonomous power state transitions)
  }
  
  /*
@@@ -1243,6 -1529,16 +1434,19 @@@ int nvme_init_identify(struct nvme_ctr
  	}
  
  	kfree(id);
++<<<<<<< HEAD
++=======
+ 
+ 	if (ctrl->apsta && !prev_apsta)
+ 		dev_pm_qos_expose_latency_tolerance(ctrl->device);
+ 	else if (!ctrl->apsta && prev_apsta)
+ 		dev_pm_qos_hide_latency_tolerance(ctrl->device);
+ 
+ 	nvme_configure_apst(ctrl);
+ 
+ 	ctrl->identified = true;
+ 
++>>>>>>> c5552fde102f (nvme: Enable autonomous power state transitions)
  	return ret;
  }
  EXPORT_SYMBOL_GPL(nvme_init_identify);
diff --cc include/linux/nvme.h
index 46a43b805258,c43d435d4225..000000000000
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@@ -559,6 -562,29 +559,32 @@@ struct nvme_dsm_range 
  	__le64			slba;
  };
  
++<<<<<<< HEAD
++=======
+ struct nvme_write_zeroes_cmd {
+ 	__u8			opcode;
+ 	__u8			flags;
+ 	__u16			command_id;
+ 	__le32			nsid;
+ 	__u64			rsvd2;
+ 	__le64			metadata;
+ 	union nvme_data_ptr	dptr;
+ 	__le64			slba;
+ 	__le16			length;
+ 	__le16			control;
+ 	__le32			dsmgmt;
+ 	__le32			reftag;
+ 	__le16			apptag;
+ 	__le16			appmask;
+ };
+ 
+ /* Features */
+ 
+ struct nvme_feat_auto_pst {
+ 	__le64 entries[32];
+ };
+ 
++>>>>>>> c5552fde102f (nvme: Enable autonomous power state transitions)
  /* Admin commands */
  
  enum nvme_admin_opcode {
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index edb3488b21b7..189fbdf19d53 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -72,6 +72,11 @@ enum nvme_quirks {
 	 * readiness, which is done by reading the NVME_CSTS_RDY bit.
 	 */
 	NVME_QUIRK_DELAY_BEFORE_CHK_RDY		= (1 << 3),
+
+	/*
+	 * APST should not be used.
+	 */
+	NVME_QUIRK_NO_APST			= (1 << 4),
 };
 
 /*
@@ -138,13 +143,19 @@ struct nvme_ctrl {
 	u32 vs;
 	u32 sgls;
 	u16 kas;
+	u8 npss;
+	u8 apsta;
 	unsigned int kato;
 	bool subsystem;
 	unsigned long quirks;
+	struct nvme_id_power_state psd[32];
 	struct work_struct scan_work;
 	struct work_struct async_event_work;
 	struct delayed_work ka_work;
 
+	/* Power saving configuration */
+	u64 ps_max_latency_us;
+
 	/* Fabrics only */
 	u16 sqsize;
 	u32 ioccsz;
* Unmerged path include/linux/nvme.h
