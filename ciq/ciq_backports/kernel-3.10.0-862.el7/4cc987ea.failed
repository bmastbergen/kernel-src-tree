target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Drop lun_sep_lock for se_lun->lun_se_dev RCU usage (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 92.59%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 4cc987eaff9144182cde88d6d132420c28d3f81b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4cc987ea.failed

With se_port and t10_alua_tg_pt_gp_member being absored into se_lun,
there is no need for an extra lock to protect se_lun->lun_se_dev
assignment.

This patch also converts backend drivers to use call_rcu() release
to allow any se_device readers to complete.  The call_rcu() instead
of kfree_rcu() is required here because se_device is embedded into
the backend driver specific structure.

Also, convert se_lun->lun_stats to use atomic_long_t within the
target_complete_ok_work() completion callback, and add FIXME for
transport_lookup_tmr_lun() with se_lun->lun_ref.

Finally, update sbp_update_unit_directory() special case usage with
proper rcu_dereference_raw() and configfs symlink comment.

	Reported-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Chris Boot <bootc@bootc.net>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 4cc987eaff9144182cde88d6d132420c28d3f81b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/sbp/sbp_target.c
#	drivers/target/target_core_alua.c
#	drivers/target/target_core_device.c
#	drivers/target/target_core_spc.c
#	drivers/target/target_core_stat.c
#	drivers/target/target_core_tpg.c
#	drivers/target/target_core_transport.c
#	drivers/target/target_core_user.c
#	include/target/target_core_base.h
diff --cc drivers/target/sbp/sbp_target.c
index b33c121ab56c,28e3adf1eb85..000000000000
--- a/drivers/target/sbp/sbp_target.c
+++ b/drivers/target/sbp/sbp_target.c
@@@ -2011,18 -1901,15 +2011,26 @@@ static int sbp_update_unit_directory(st
  	/* unit unique ID (leaf is just after LUNs) */
  	data[idx++] = 0x8d000000 | (num_luns + 1);
  
 -	rcu_read_lock();
 -	hlist_for_each_entry_rcu(lun, &tport->tpg->se_tpg.tpg_lun_hlist, link) {
 +	spin_lock(&tport->tpg->se_tpg.tpg_lun_lock);
 +	for (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {
 +		struct se_lun *se_lun = tport->tpg->se_tpg.tpg_lun_list[i];
  		struct se_device *dev;
  		int type;
++<<<<<<< HEAD
 +
 +		if (se_lun->lun_status == TRANSPORT_LUN_STATUS_FREE)
 +			continue;
 +
 +		spin_unlock(&tport->tpg->se_tpg.tpg_lun_lock);
 +
 +		dev = se_lun->lun_se_dev;
++=======
+ 		/*
+ 		 * rcu_dereference_raw protected by se_lun->lun_group symlink
+ 		 * reference to se_device->dev_group.
+ 		 */
+ 		dev = rcu_dereference_raw(lun->lun_se_dev);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  		type = dev->transport->get_device_type(dev);
  
  		/* logical_unit_number */
diff --cc drivers/target/target_core_alua.c
index a73542598e96,0a0087311cfb..000000000000
--- a/drivers/target/target_core_alua.c
+++ b/drivers/target/target_core_alua.c
@@@ -1973,11 -1934,13 +1973,20 @@@ ssize_t core_alua_store_tg_pt_gp_info
  	const char *page,
  	size_t count)
  {
++<<<<<<< HEAD
 +	struct se_portal_group *tpg;
 +	struct se_lun *lun;
 +	struct se_device *dev = port->sep_lun->lun_se_dev;
++=======
+ 	struct se_portal_group *tpg = lun->lun_tpg;
+ 	/*
+ 	 * rcu_dereference_raw protected by se_lun->lun_group symlink
+ 	 * reference to se_device->dev_group.
+ 	 */
+ 	struct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	struct t10_alua_tg_pt_gp *tg_pt_gp = NULL, *tg_pt_gp_new = NULL;
 +	struct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;
  	unsigned char buf[TG_PT_GROUP_NAME_BUF];
  	int move = 0;
  
@@@ -2241,7 -2193,11 +2250,15 @@@ ssize_t core_alua_store_offline_bit
  	const char *page,
  	size_t count)
  {
++<<<<<<< HEAD
 +	struct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;
++=======
+ 	/*
+ 	 * rcu_dereference_raw protected by se_lun->lun_group symlink
+ 	 * reference to se_device->dev_group.
+ 	 */
+ 	struct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	unsigned long tmp;
  	int ret;
  
diff --cc drivers/target/target_core_device.c
index 53dcefb982bc,3baa6cd7fded..000000000000
--- a/drivers/target/target_core_device.c
+++ b/drivers/target/target_core_device.c
@@@ -59,8 -60,8 +59,13 @@@ transport_lookup_cmd_lun(struct se_cmd 
  {
  	struct se_lun *se_lun = NULL;
  	struct se_session *se_sess = se_cmd->se_sess;
++<<<<<<< HEAD
 +	struct se_device *dev;
 +	unsigned long flags;
++=======
+ 	struct se_node_acl *nacl = se_sess->se_node_acl;
+ 	struct se_dev_entry *deve;
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  
  	if (unpacked_lun >= TRANSPORT_MAX_LUNS_PER_TPG)
  		return TCM_NON_EXISTENT_LUN;
@@@ -381,12 -394,14 +392,17 @@@ int core_disable_device_list_for_node
  	struct se_node_acl *nacl,
  	struct se_portal_group *tpg)
  {
 +	struct se_port *port = lun->lun_sep;
 +	struct se_dev_entry *deve = nacl->device_list[mapped_lun];
 +
+ 	/*
+ 	 * rcu_dereference_raw protected by se_lun->lun_group symlink
+ 	 * reference to se_device->dev_group.
+ 	 */
+ 	struct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);
  	/*
  	 * If the MappedLUN entry is being disabled, the entry in
 -	 * lun->lun_deve_list must be removed now before clearing the
 +	 * port->sep_alua_list must be removed now before clearing the
  	 * struct se_dev_entry pointers below as logic in
  	 * core_alua_do_transition_tg_pt() depends on these being present.
  	 *
@@@ -397,30 -412,31 +413,34 @@@
  	 * NodeACL context specific PR metadata for demo-mode
  	 * MappedLUN *deve will be released below..
  	 */
 -	spin_lock_bh(&lun->lun_deve_lock);
 -	list_del(&orig->lun_link);
 -	spin_unlock_bh(&lun->lun_deve_lock);
 +	spin_lock_bh(&port->sep_alua_lock);
 +	list_del(&deve->alua_port_list);
 +	spin_unlock_bh(&port->sep_alua_lock);
  	/*
 -	 * Disable struct se_dev_entry LUN ACL mapping
 +	 * Wait for any in process SPEC_I_PT=1 or REGISTER_AND_MOVE
 +	 * PR operation to complete.
  	 */
 -	core_scsi3_ua_release_all(orig);
 -
 -	hlist_del_rcu(&orig->link);
 -	clear_bit(DEF_PR_REG_ACTIVE, &orig->deve_flags);
 -	rcu_assign_pointer(orig->se_lun, NULL);
 -	rcu_assign_pointer(orig->se_lun_acl, NULL);
 -	orig->lun_flags = 0;
 -	orig->creation_time = 0;
 -	orig->attach_count--;
 +	while (atomic_read(&deve->pr_ref_count) != 0)
 +		cpu_relax();
 +
 +	spin_lock_irq(&nacl->device_list_lock);
  	/*
 -	 * Before firing off RCU callback, wait for any in process SPEC_I_PT=1
 -	 * or REGISTER_AND_MOVE PR operation to complete.
 +	 * Disable struct se_dev_entry LUN ACL mapping
  	 */
 -	kref_put(&orig->pr_kref, target_pr_kref_release);
 -	wait_for_completion(&orig->pr_comp);
 -
 -	kfree_rcu(orig, rcu_head);
 -
 +	core_scsi3_ua_release_all(deve);
 +	deve->se_lun = NULL;
 +	deve->se_lun_acl = NULL;
 +	deve->lun_flags = 0;
 +	deve->creation_time = 0;
 +	deve->attach_count--;
 +	spin_unlock_irq(&nacl->device_list_lock);
 +
++<<<<<<< HEAD
 +	core_scsi3_free_pr_reg_from_nacl(lun->lun_se_dev, nacl);
 +	return 0;
++=======
+ 	core_scsi3_free_pr_reg_from_nacl(dev, nacl);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  }
  
  /*      core_clear_lun_from_tpg():
@@@ -1337,22 -635,16 +1357,31 @@@ struct se_lun_acl *core_dev_init_initia
  int core_dev_add_initiator_node_lun_acl(
  	struct se_portal_group *tpg,
  	struct se_lun_acl *lacl,
 -	struct se_lun *lun,
 +	u32 unpacked_lun,
  	u32 lun_access)
  {
++<<<<<<< HEAD
 +	struct se_lun *lun;
 +	struct se_node_acl *nacl;
++=======
+ 	struct se_node_acl *nacl = lacl->se_lun_nacl;
+ 	/*
+ 	 * rcu_dereference_raw protected by se_lun->lun_group symlink
+ 	 * reference to se_device->dev_group.
+ 	 */
+ 	struct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
 +
 +	lun = core_dev_get_lun(tpg, unpacked_lun);
 +	if (!lun) {
 +		pr_err("%s Logical Unit Number: %u is not active on"
 +			" Target Portal Group: %hu, ignoring request.\n",
 +			tpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,
 +			tpg->se_tpg_tfo->tpg_get_tag(tpg));
 +		return -EINVAL;
 +	}
  
 +	nacl = lacl->se_lun_nacl;
  	if (!nacl)
  		return -EINVAL;
  
@@@ -1479,8 -759,9 +1508,9 @@@ struct se_device *target_alloc_device(s
  
  	dev->dev_link_magic = SE_DEV_LINK_MAGIC;
  	dev->se_hba = hba;
 -	dev->transport = hba->backend->ops;
 +	dev->transport = hba->transport;
  	dev->prot_length = sizeof(struct se_dif_v1_tuple);
+ 	dev->hba_index = hba->hba_index;
  
  	INIT_LIST_HEAD(&dev->dev_list);
  	INIT_LIST_HEAD(&dev->dev_sep_list);
@@@ -1537,12 -818,12 +1567,16 @@@
  	dev->dev_attrib.max_write_same_len = DA_MAX_WRITE_SAME_LEN;
  
  	xcopy_lun = &dev->xcopy_lun;
++<<<<<<< HEAD
 +	xcopy_lun->lun_se_dev = dev;
 +	init_completion(&xcopy_lun->lun_shutdown_comp);
 +	INIT_LIST_HEAD(&xcopy_lun->lun_acl_list);
 +	spin_lock_init(&xcopy_lun->lun_acl_lock);
 +	spin_lock_init(&xcopy_lun->lun_sep_lock);
++=======
+ 	rcu_assign_pointer(xcopy_lun->lun_se_dev, dev);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	init_completion(&xcopy_lun->lun_ref_comp);
 -	INIT_LIST_HEAD(&xcopy_lun->lun_deve_list);
 -	INIT_LIST_HEAD(&xcopy_lun->lun_dev_link);
 -	mutex_init(&xcopy_lun->lun_tg_pt_md_mutex);
 -	xcopy_lun->lun_tpg = &xcopy_pt_tpg;
  
  	return dev;
  }
diff --cc drivers/target/target_core_spc.c
index 7912aa124385,a2b377e06cfa..000000000000
--- a/drivers/target/target_core_spc.c
+++ b/drivers/target/target_core_spc.c
@@@ -712,7 -692,7 +712,11 @@@ spc_emulate_inquiry(struct se_cmd *cmd
  		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
  	}
  
++<<<<<<< HEAD
 +	if (dev == tpg->tpg_virt_lun0.lun_se_dev)
++=======
+ 	if (dev == rcu_access_pointer(tpg->tpg_virt_lun0->lun_se_dev))
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  		buf[0] = 0x3f; /* Not connected */
  	else
  		buf[0] = dev->transport->get_device_type(dev);
diff --cc drivers/target/target_core_stat.c
index 59830a27f502,79c785242375..000000000000
--- a/drivers/target/target_core_stat.c
+++ b/drivers/target/target_core_stat.c
@@@ -543,20 -542,14 +543,28 @@@ static ssize_t target_stat_scsi_port_sh
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	struct se_device *dev = lun->lun_se_dev;
 +	struct se_hba *hba;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	hba = dev->se_hba;
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", hba->hba_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", dev->hba_index);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_PORT_ATTR_RO(inst);
@@@ -565,18 -558,14 +573,26 @@@ static ssize_t target_stat_scsi_port_sh
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	struct se_device *dev = lun->lun_se_dev;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", dev->dev_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", dev->dev_index);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_PORT_ATTR_RO(dev);
@@@ -585,17 -574,14 +601,25 @@@ static ssize_t target_stat_scsi_port_sh
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", sep->sep_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", lun->lun_rtpi);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_PORT_ATTR_RO(indx);
@@@ -604,21 -590,14 +628,29 @@@ static ssize_t target_stat_scsi_port_sh
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_device *dev = lun->lun_se_dev;
 +	struct se_port *sep;
 +	ssize_t ret;
  
 +	if (!dev)
 +		return -ENODEV;
 +
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	ret = snprintf(page, PAGE_SIZE, "%s%u\n", "Device", dev->dev_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%s%u\n", "Device", dev->dev_index);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_PORT_ATTR_RO(role);
@@@ -627,18 -606,16 +659,28 @@@ static ssize_t target_stat_scsi_port_sh
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	/* FIXME: scsiPortBusyStatuses  */
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", 0);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev) {
+ 		/* FIXME: scsiPortBusyStatuses  */
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", 0);
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_PORT_ATTR_RO(busy_count);
@@@ -686,20 -663,14 +728,28 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_device *dev = lun->lun_se_dev;
 +	struct se_port *sep;
 +	struct se_hba *hba;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	hba = dev->se_hba;
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", hba->hba_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", dev->hba_index);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(inst);
@@@ -708,18 -679,14 +758,26 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_device *dev = lun->lun_se_dev;
 +	struct se_port *sep;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", dev->dev_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", dev->dev_index);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(dev);
@@@ -728,17 -695,14 +786,25 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", sep->sep_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", lun->lun_rtpi);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(indx);
@@@ -747,21 -711,17 +813,31 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_portal_group *tpg = lun->lun_tpg;
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	struct se_portal_group *tpg;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	tpg = sep->sep_tpg;
 +
 +	ret = snprintf(page, PAGE_SIZE, "%sPort#%u\n",
 +		tpg->se_tpg_tfo->get_fabric_name(), sep->sep_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%sPort#%u\n",
+ 			tpg->se_tpg_tfo->get_fabric_name(),
+ 			lun->lun_rtpi);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(name);
@@@ -770,22 -730,17 +846,32 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_portal_group *tpg = lun->lun_tpg;
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	struct se_portal_group *tpg;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	tpg = sep->sep_tpg;
 +
 +	ret = snprintf(page, PAGE_SIZE, "%s%s%d\n",
 +		tpg->se_tpg_tfo->tpg_get_wwn(tpg), "+t+",
 +		tpg->se_tpg_tfo->tpg_get_tag(tpg));
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%s%s%d\n",
+ 			tpg->se_tpg_tfo->tpg_get_wwn(tpg), "+t+",
+ 			tpg->se_tpg_tfo->tpg_get_tag(tpg));
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(port_index);
@@@ -794,18 -749,15 +880,27 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
 +
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
  
 +	ret = snprintf(page, PAGE_SIZE, "%llu\n", sep->sep_stats.cmd_pdus);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%lu\n",
+ 			       atomic_long_read(&lun->lun_stats.cmd_pdus));
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(in_cmds);
@@@ -814,19 -766,15 +909,28 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
 +
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
  
 +	ret = snprintf(page, PAGE_SIZE, "%u\n",
 +			(u32)(sep->sep_stats.rx_data_octets >> 20));
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n",
+ 			(u32)(atomic_long_read(&lun->lun_stats.rx_data_octets) >> 20));
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(write_mbytes);
@@@ -835,19 -783,15 +939,28 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
 +
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
  
 +	ret = snprintf(page, PAGE_SIZE, "%u\n",
 +			(u32)(sep->sep_stats.tx_data_octets >> 20));
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n",
+ 				(u32)(atomic_long_read(&lun->lun_stats.tx_data_octets) >> 20));
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(read_mbytes);
@@@ -856,19 -800,16 +969,29 @@@ static ssize_t target_stat_scsi_tgt_por
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +
 +	/* FIXME: scsiTgtPortHsInCommands */
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", 0);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev) {
+ 		/* FIXME: scsiTgtPortHsInCommands */
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", 0);
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TGT_PORT_ATTR_RO(hs_in_cmds);
@@@ -922,21 -863,14 +1045,29 @@@ static ssize_t target_stat_scsi_transpo
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	ssize_t ret = -ENODEV;
 +	struct se_device *dev = lun->lun_se_dev;
 +	struct se_port *sep;
 +	struct se_hba *hba;
 +	ssize_t ret;
 +
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
  
 +	hba = dev->se_hba;
 +	ret = snprintf(page, PAGE_SIZE, "%u\n", hba->hba_index);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n", dev->hba_index);
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TRANSPORT_ATTR_RO(inst);
@@@ -945,21 -879,18 +1076,32 @@@ static ssize_t target_stat_scsi_transpo
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	struct se_portal_group *tpg = lun->lun_tpg;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	struct se_portal_group *tpg;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	tpg = sep->sep_tpg;
 +	/* scsiTransportType */
 +	ret = snprintf(page, PAGE_SIZE, "scsiTransport%s\n",
 +			tpg->se_tpg_tfo->get_fabric_name());
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev) {
+ 		/* scsiTransportType */
+ 		ret = snprintf(page, PAGE_SIZE, "scsiTransport%s\n",
+ 			       tpg->se_tpg_tfo->get_fabric_name());
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TRANSPORT_ATTR_RO(device);
@@@ -968,20 -899,16 +1110,29 @@@ static ssize_t target_stat_scsi_transpo
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
 -	struct se_device *dev;
 -	struct se_portal_group *tpg = lun->lun_tpg;
 -	ssize_t ret = -ENODEV;
 +	struct se_port *sep;
 +	struct se_portal_group *tpg;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	tpg = sep->sep_tpg;
 +	ret = snprintf(page, PAGE_SIZE, "%u\n",
 +			tpg->se_tpg_tfo->tpg_get_inst_index(tpg));
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev)
+ 		ret = snprintf(page, PAGE_SIZE, "%u\n",
+ 			       tpg->se_tpg_tfo->tpg_get_inst_index(tpg));
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TRANSPORT_ATTR_RO(indx);
@@@ -990,26 -917,22 +1141,45 @@@ static ssize_t target_stat_scsi_transpo
  	struct se_port_stat_grps *pgrps, char *page)
  {
  	struct se_lun *lun = container_of(pgrps, struct se_lun, port_stat_grps);
++<<<<<<< HEAD
 +	struct se_device *dev = lun->lun_se_dev;
 +	struct se_port *sep;
 +	struct se_portal_group *tpg;
++=======
+ 	struct se_device *dev;
+ 	struct se_portal_group *tpg = lun->lun_tpg;
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	struct t10_wwn *wwn;
 -	ssize_t ret = -ENODEV;
 +	ssize_t ret;
  
++<<<<<<< HEAD
 +	spin_lock(&lun->lun_sep_lock);
 +	sep = lun->lun_sep;
 +	if (!sep) {
 +		spin_unlock(&lun->lun_sep_lock);
 +		return -ENODEV;
 +	}
 +	tpg = sep->sep_tpg;
 +	wwn = &dev->t10_wwn;
 +	/* scsiTransportDevName */
 +	ret = snprintf(page, PAGE_SIZE, "%s+%s\n",
 +			tpg->se_tpg_tfo->tpg_get_wwn(tpg),
 +			(strlen(wwn->unit_serial)) ? wwn->unit_serial :
 +			wwn->vendor);
 +	spin_unlock(&lun->lun_sep_lock);
++=======
+ 	rcu_read_lock();
+ 	dev = rcu_dereference(lun->lun_se_dev);
+ 	if (dev) {
+ 		wwn = &dev->t10_wwn;
+ 		/* scsiTransportDevName */
+ 		ret = snprintf(page, PAGE_SIZE, "%s+%s\n",
+ 				tpg->se_tpg_tfo->tpg_get_wwn(tpg),
+ 				(strlen(wwn->unit_serial)) ? wwn->unit_serial :
+ 				wwn->vendor);
+ 	}
+ 	rcu_read_unlock();
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return ret;
  }
  DEV_STAT_SCSI_TRANSPORT_ATTR_RO(dev_name);
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,5b30940ccaf2..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -132,15 -97,13 +132,20 @@@ void core_tpg_add_node_to_devs
  	struct se_lun *lun;
  	struct se_device *dev;
  
 -	mutex_lock(&tpg->tpg_lun_mutex);
 -	hlist_for_each_entry_rcu(lun, &tpg->tpg_lun_hlist, link) {
 -		if (lun_orig && lun != lun_orig)
 +	spin_lock(&tpg->tpg_lun_lock);
 +	for (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {
 +		lun = tpg->tpg_lun_list[i];
 +		if (lun->lun_status != TRANSPORT_LUN_STATUS_ACTIVE)
  			continue;
  
++<<<<<<< HEAD
 +		spin_unlock(&tpg->tpg_lun_lock);
 +
 +		dev = lun->lun_se_dev;
++=======
+ 		dev = rcu_dereference_check(lun->lun_se_dev,
+ 					    lockdep_is_held(&tpg->tpg_lun_mutex));
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  		/*
  		 * By default in LIO-Target $FABRIC_MOD,
  		 * demo_mode_write_protect is ON, or READ_ONLY;
@@@ -797,17 -591,24 +802,33 @@@ struct se_lun *core_tpg_alloc_lun
  		return ERR_PTR(-EOVERFLOW);
  	}
  
 -	lun = kzalloc(sizeof(*lun), GFP_KERNEL);
 -	if (!lun) {
 -		pr_err("Unable to allocate se_lun memory\n");
 -		return ERR_PTR(-ENOMEM);
 +	spin_lock(&tpg->tpg_lun_lock);
 +	lun = tpg->tpg_lun_list[unpacked_lun];
 +	if (lun->lun_status == TRANSPORT_LUN_STATUS_ACTIVE) {
 +		pr_err("TPG Logical Unit Number: %u is already active"
 +			" on %s Target Portal Group: %u, ignoring request.\n",
 +			unpacked_lun, tpg->se_tpg_tfo->get_fabric_name(),
 +			tpg->se_tpg_tfo->tpg_get_tag(tpg));
 +		spin_unlock(&tpg->tpg_lun_lock);
 +		return ERR_PTR(-EINVAL);
  	}
++<<<<<<< HEAD
 +	spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	lun->unpacked_lun = unpacked_lun;
+ 	lun->lun_link_magic = SE_LUN_LINK_MAGIC;
+ 	atomic_set(&lun->lun_acl_count, 0);
+ 	init_completion(&lun->lun_ref_comp);
+ 	INIT_LIST_HEAD(&lun->lun_deve_list);
+ 	INIT_LIST_HEAD(&lun->lun_dev_link);
+ 	atomic_set(&lun->lun_tg_pt_secondary_offline, 0);
+ 	spin_lock_init(&lun->lun_deve_lock);
+ 	mutex_init(&lun->lun_tg_pt_md_mutex);
+ 	INIT_LIST_HEAD(&lun->lun_tg_pt_gp_link);
+ 	spin_lock_init(&lun->lun_tg_pt_gp_lock);
+ 	atomic_set(&lun->lun_active, 0);
+ 	lun->lun_tpg = tpg;
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  
  	return lun;
  }
@@@ -823,26 -624,48 +844,54 @@@ int core_tpg_add_lun
  	ret = percpu_ref_init(&lun->lun_ref, core_tpg_lun_ref_release, 0,
  			      GFP_KERNEL);
  	if (ret < 0)
 -		goto out;
 +		return ret;
  
++<<<<<<< HEAD
 +	ret = core_dev_export(dev, tpg, lun);
 +	if (ret < 0) {
 +		percpu_ref_exit(&lun->lun_ref);
 +		return ret;
 +	}
++=======
+ 	ret = core_alloc_rtpi(lun, dev);
+ 	if (ret)
+ 		goto out_kill_ref;
+ 
+ 	if (!(dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH) &&
+ 	    !(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		target_attach_tg_pt_gp(lun, dev->t10_alua.default_tg_pt_gp);
+ 
+ 	mutex_lock(&tpg->tpg_lun_mutex);
+ 
+ 	spin_lock(&dev->se_port_lock);
+ 	lun->lun_index = dev->dev_index;
+ 	rcu_assign_pointer(lun->lun_se_dev, dev);
+ 	dev->export_count++;
+ 	list_add_tail(&lun->lun_dev_link, &dev->dev_sep_list);
+ 	spin_unlock(&dev->se_port_lock);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  
 +	spin_lock(&tpg->tpg_lun_lock);
  	lun->lun_access = lun_access;
 -	if (!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
 -		hlist_add_head_rcu(&lun->link, &tpg->tpg_lun_hlist);
 -	mutex_unlock(&tpg->tpg_lun_mutex);
 +	lun->lun_status = TRANSPORT_LUN_STATUS_ACTIVE;
 +	spin_unlock(&tpg->tpg_lun_lock);
  
  	return 0;
 -
 -out_kill_ref:
 -	percpu_ref_exit(&lun->lun_ref);
 -out:
 -	return ret;
  }
  
  void core_tpg_remove_lun(
  	struct se_portal_group *tpg,
  	struct se_lun *lun)
  {
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * rcu_dereference_raw protected by se_lun->lun_group symlink
+ 	 * reference to se_device->dev_group.
+ 	 */
+ 	struct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);
+ 
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	core_clear_lun_from_tpg(lun, tpg);
  	transport_clear_lun_ref(lun);
  
diff --cc drivers/target/target_core_transport.c
index 9cc3afa0ef11,d8a59122fe3b..000000000000
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@@ -1294,11 -1261,7 +1294,15 @@@ target_setup_cmd_from_cdb(struct se_cm
  		return ret;
  
  	cmd->se_cmd_flags |= SCF_SUPPORTED_SAM_OPCODE;
++<<<<<<< HEAD
 +
 +	spin_lock(&cmd->se_lun->lun_sep_lock);
 +	if (cmd->se_lun->lun_sep)
 +		cmd->se_lun->lun_sep->sep_stats.cmd_pdus++;
 +	spin_unlock(&cmd->se_lun->lun_sep_lock);
++=======
+ 	atomic_long_inc(&cmd->se_lun->lun_stats.cmd_pdus);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	return 0;
  }
  EXPORT_SYMBOL(target_setup_cmd_from_cdb);
@@@ -2120,12 -2057,8 +2124,17 @@@ static void target_complete_ok_work(str
  queue_rsp:
  	switch (cmd->data_direction) {
  	case DMA_FROM_DEVICE:
++<<<<<<< HEAD
 +		spin_lock(&cmd->se_lun->lun_sep_lock);
 +		if (cmd->se_lun->lun_sep) {
 +			cmd->se_lun->lun_sep->sep_stats.tx_data_octets +=
 +					cmd->data_length;
 +		}
 +		spin_unlock(&cmd->se_lun->lun_sep_lock);
++=======
+ 		atomic_long_add(cmd->data_length,
+ 				&cmd->se_lun->lun_stats.tx_data_octets);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  		/*
  		 * Perform READ_STRIP of PI using software emulation when
  		 * backend had PI enabled, if the transport will not be
@@@ -2148,24 -2081,16 +2157,34 @@@
  			goto queue_full;
  		break;
  	case DMA_TO_DEVICE:
++<<<<<<< HEAD
 +		spin_lock(&cmd->se_lun->lun_sep_lock);
 +		if (cmd->se_lun->lun_sep) {
 +			cmd->se_lun->lun_sep->sep_stats.rx_data_octets +=
 +				cmd->data_length;
 +		}
 +		spin_unlock(&cmd->se_lun->lun_sep_lock);
++=======
+ 		atomic_long_add(cmd->data_length,
+ 				&cmd->se_lun->lun_stats.rx_data_octets);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  		/*
  		 * Check if we need to send READ payload for BIDI-COMMAND
  		 */
  		if (cmd->se_cmd_flags & SCF_BIDI) {
++<<<<<<< HEAD
 +			spin_lock(&cmd->se_lun->lun_sep_lock);
 +			if (cmd->se_lun->lun_sep) {
 +				cmd->se_lun->lun_sep->sep_stats.tx_data_octets +=
 +					cmd->data_length;
 +			}
 +			spin_unlock(&cmd->se_lun->lun_sep_lock);
++=======
+ 			atomic_long_add(cmd->data_length,
+ 					&cmd->se_lun->lun_stats.tx_data_octets);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  			ret = cmd->se_tfo->queue_data_in(cmd);
 -			if (ret == -EAGAIN || ret == -ENOMEM)
 +			if (ret)
  				goto queue_full;
  			break;
  		}
diff --cc drivers/target/target_core_user.c
index 7dc2f05f8e5e,949e6165ef8a..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1236,11 -982,8 +1244,16 @@@ static void tcmu_destroy_device(struct 
  		uio_unregister_device(&udev->uio_info);
  		kfree(udev->uio_info.name);
  		kfree(udev->name);
++<<<<<<< HEAD
 +
 +		mutex_lock(&device_mutex);
 +		idr_remove(&devices_idr, udev->dev_index);
 +		mutex_unlock(&device_mutex);
 +	}
++=======
+ 	}
+ 	call_rcu(&dev->rcu_head, tcmu_dev_call_rcu);
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  }
  
  enum {
diff --cc include/target/target_core_base.h
index 7bcf92529421,b82a989a4d3b..000000000000
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@@ -711,21 -689,41 +711,52 @@@ struct se_port_stat_grps 
  	struct config_group scsi_transport_group;
  };
  
++<<<<<<< HEAD
++=======
+ struct scsi_port_stats {
+ 	atomic_long_t	cmd_pdus;
+ 	atomic_long_t	tx_data_octets;
+ 	atomic_long_t	rx_data_octets;
+ };
+ 
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  struct se_lun {
 -	/* RELATIVE TARGET PORT IDENTIFER */
 -	u16			lun_rtpi;
  #define SE_LUN_LINK_MAGIC			0xffff7771
  	u32			lun_link_magic;
 +	/* See transport_lun_status_table */
 +	enum transport_lun_status_table lun_status;
  	u32			lun_access;
  	u32			lun_flags;
  	u32			unpacked_lun;
 -	u32			lun_index;
  	atomic_t		lun_acl_count;
++<<<<<<< HEAD
 +	spinlock_t		lun_acl_lock;
 +	spinlock_t		lun_sep_lock;
 +	struct completion	lun_shutdown_comp;
 +	struct list_head	lun_acl_list;
 +	struct se_device	*lun_se_dev;
 +	struct se_port		*lun_sep;
++=======
+ 	struct se_device __rcu	*lun_se_dev;
+ 
+ 	struct list_head	lun_deve_list;
+ 	spinlock_t		lun_deve_lock;
+ 
+ 	/* ALUA state */
+ 	int			lun_tg_pt_secondary_stat;
+ 	int			lun_tg_pt_secondary_write_md;
+ 	atomic_t		lun_tg_pt_secondary_offline;
+ 	struct mutex		lun_tg_pt_md_mutex;
+ 
+ 	/* ALUA target port group linkage */
+ 	struct list_head	lun_tg_pt_gp_link;
+ 	struct t10_alua_tg_pt_gp *lun_tg_pt_gp;
+ 	spinlock_t		lun_tg_pt_gp_lock;
+ 
+ 	atomic_t		lun_active;
+ 	struct se_portal_group	*lun_tpg;
+ 	struct scsi_port_stats	lun_stats;
++>>>>>>> 4cc987eaff91 (target: Drop lun_sep_lock for se_lun->lun_se_dev RCU usage)
  	struct config_group	lun_group;
  	struct se_port_stat_grps port_stat_grps;
  	struct completion	lun_ref_comp;
* Unmerged path drivers/target/sbp/sbp_target.c
* Unmerged path drivers/target/target_core_alua.c
* Unmerged path drivers/target/target_core_device.c
diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c
index 909f66aed985..ccc28d140191 100644
--- a/drivers/target/target_core_file.c
+++ b/drivers/target/target_core_file.c
@@ -246,6 +246,14 @@ fail:
 	return ret;
 }
 
+static void fd_dev_call_rcu(struct rcu_head *p)
+{
+	struct se_device *dev = container_of(p, struct se_device, rcu_head);
+	struct fd_dev *fd_dev = FD_DEV(dev);
+
+	kfree(fd_dev);
+}
+
 static void fd_free_device(struct se_device *dev)
 {
 	struct fd_dev *fd_dev = FD_DEV(dev);
@@ -254,8 +262,7 @@ static void fd_free_device(struct se_device *dev)
 		filp_close(fd_dev->fd_file, NULL);
 		fd_dev->fd_file = NULL;
 	}
-
-	kfree(fd_dev);
+	call_rcu(&dev->rcu_head, fd_dev_call_rcu);
 }
 
 static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,
diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c
index 4ff1c8404aab..9ddce79b4649 100644
--- a/drivers/target/target_core_iblock.c
+++ b/drivers/target/target_core_iblock.c
@@ -198,6 +198,14 @@ out:
 	return ret;
 }
 
+static void iblock_dev_call_rcu(struct rcu_head *p)
+{
+	struct se_device *dev = container_of(p, struct se_device, rcu_head);
+	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
+
+	kfree(ib_dev);
+}
+
 static void iblock_free_device(struct se_device *dev)
 {
 	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
@@ -207,7 +215,7 @@ static void iblock_free_device(struct se_device *dev)
 	if (ib_dev->ibd_bio_set != NULL)
 		bioset_free(ib_dev->ibd_bio_set);
 
-	kfree(ib_dev);
+	call_rcu(&dev->rcu_head, iblock_dev_call_rcu);
 }
 
 static unsigned long long iblock_emulate_read_cap_with_block_size(
diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c
index 59a8a2963c0e..0a7219fac4a2 100644
--- a/drivers/target/target_core_pscsi.c
+++ b/drivers/target/target_core_pscsi.c
@@ -581,6 +581,14 @@ static int pscsi_configure_device(struct se_device *dev)
 	return -ENODEV;
 }
 
+static void pscsi_dev_call_rcu(struct rcu_head *p)
+{
+	struct se_device *dev = container_of(p, struct se_device, rcu_head);
+	struct pscsi_dev_virt *pdv = PSCSI_DEV(dev);
+
+	kfree(pdv);
+}
+
 static void pscsi_free_device(struct se_device *dev)
 {
 	struct pscsi_dev_virt *pdv = PSCSI_DEV(dev);
@@ -612,8 +620,7 @@ static void pscsi_free_device(struct se_device *dev)
 
 		pdv->pdv_sd = NULL;
 	}
-
-	kfree(pdv);
+	call_rcu(&dev->rcu_head, pscsi_dev_call_rcu);
 }
 
 static void pscsi_transport_complete(struct se_cmd *cmd, struct scatterlist *sg,
diff --git a/drivers/target/target_core_rd.c b/drivers/target/target_core_rd.c
index 55315fd0f5d3..5587297d7c0c 100644
--- a/drivers/target/target_core_rd.c
+++ b/drivers/target/target_core_rd.c
@@ -355,12 +355,20 @@ fail:
 	return ret;
 }
 
+static void rd_dev_call_rcu(struct rcu_head *p)
+{
+	struct se_device *dev = container_of(p, struct se_device, rcu_head);
+	struct rd_dev *rd_dev = RD_DEV(dev);
+
+	kfree(rd_dev);
+}
+
 static void rd_free_device(struct se_device *dev)
 {
 	struct rd_dev *rd_dev = RD_DEV(dev);
 
 	rd_release_device_space(rd_dev);
-	kfree(rd_dev);
+	call_rcu(&dev->rcu_head, rd_dev_call_rcu);
 }
 
 static struct rd_dev_sg_table *rd_get_sg_table(struct rd_dev *rd_dev, u32 page)
* Unmerged path drivers/target/target_core_spc.c
* Unmerged path drivers/target/target_core_stat.c
* Unmerged path drivers/target/target_core_tpg.c
* Unmerged path drivers/target/target_core_transport.c
* Unmerged path drivers/target/target_core_user.c
* Unmerged path include/target/target_core_base.h
