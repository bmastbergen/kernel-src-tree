x86/vdso: Add VCLOCK_HVCLOCK vDSO clock read method

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 90b20432aeb850ef84086a72893cd9411479d896
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/90b20432.failed

Hyper-V TSC page clocksource is suitable for vDSO, however, the protocol
defined by the hypervisor is different from VCLOCK_PVCLOCK. Implement the
required support by adding hvclock_page VVAR.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Dexuan Cui <decui@microsoft.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: devel@linuxdriverproject.org
	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
	Cc: virtualization@lists.linux-foundation.org
Link: http://lkml.kernel.org/r/20170303132142.25595-4-vkuznets@redhat.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 90b20432aeb850ef84086a72893cd9411479d896)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/vdso/vclock_gettime.c
#	arch/x86/entry/vdso/vdso-layout.lds.S
#	arch/x86/entry/vdso/vdso2c.c
#	arch/x86/entry/vdso/vma.c
#	arch/x86/hyperv/hv_init.c
#	arch/x86/include/asm/clocksource.h
#	arch/x86/include/asm/vdso.h
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,2b01421f7d0f..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -58,8 -112,64 +58,47 @@@ void hyperv_init(void
  	hypercall_msr.enable = 1;
  	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);
  	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Register Hyper-V specific clocksource.
+ 	 */
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ 	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
+ 		union hv_x64_msr_hypercall_contents tsc_msr;
+ 
+ 		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
+ 		if (!tsc_pg)
+ 			goto register_msr_cs;
+ 
+ 		hyperv_cs = &hyperv_cs_tsc;
+ 
+ 		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 
+ 		tsc_msr.enable = 1;
+ 		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
+ 
+ 		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 
+ 		hyperv_cs_tsc.archdata.vclock_mode = VCLOCK_HVCLOCK;
+ 
+ 		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+ 		return;
+ 	}
+ register_msr_cs:
+ #endif
+ 	/*
+ 	 * For 32 bit guests just use the MSR based mechanism for reading
+ 	 * the partition counter.
+ 	 */
+ 
+ 	hyperv_cs = &hyperv_cs_msr;
+ 	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
+ 		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
++>>>>>>> 90b20432aeb8 (x86/vdso: Add VCLOCK_HVCLOCK vDSO clock read method)
  }
  
 -/*
 - * This routine is called before kexec/kdump, it does the required cleanup.
 - */
 -void hyperv_cleanup(void)
 -{
 -	union hv_x64_msr_hypercall_contents hypercall_msr;
 -
 -	/* Reset our OS id */
 -	wrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);
 -
 -	/* Reset the hypercall page */
 -	hypercall_msr.as_uint64 = 0;
 -	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 -
 -	/* Reset the TSC page */
 -	hypercall_msr.as_uint64 = 0;
 -	wrmsrl(HV_X64_MSR_REFERENCE_TSC, hypercall_msr.as_uint64);
 -}
 -EXPORT_SYMBOL_GPL(hyperv_cleanup);
 -
  /*
   * hv_do_hypercall- Invoke the specified hypercall
   */
diff --cc arch/x86/include/asm/clocksource.h
index 16a57f4ed64d,47bea8cadbd0..000000000000
--- a/arch/x86/include/asm/clocksource.h
+++ b/arch/x86/include/asm/clocksource.h
@@@ -3,12 -3,11 +3,20 @@@
  #ifndef _ASM_X86_CLOCKSOURCE_H
  #define _ASM_X86_CLOCKSOURCE_H
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +
 +#define VCLOCK_NONE 0  /* No vDSO clock available.	*/
 +#define VCLOCK_TSC  1  /* vDSO should use vread_tsc.	*/
 +#define VCLOCK_HPET 2  /* vDSO should use vread_hpet.	*/
 +#define VCLOCK_PVCLOCK 3 /* vDSO should use vread_pvclock. */
++=======
+ #define VCLOCK_NONE	0	/* No vDSO clock available.		*/
+ #define VCLOCK_TSC	1	/* vDSO should use vread_tsc.		*/
+ #define VCLOCK_PVCLOCK	2	/* vDSO should use vread_pvclock.	*/
+ #define VCLOCK_HVCLOCK	3	/* vDSO should use vread_hvclock.	*/
+ #define VCLOCK_MAX	3
++>>>>>>> 90b20432aeb8 (x86/vdso: Add VCLOCK_HVCLOCK vDSO clock read method)
  
  struct arch_clocksource_data {
  	int vclock_mode;
diff --cc arch/x86/include/asm/vdso.h
index fddb53d63915,bccdf4938ddf..000000000000
--- a/arch/x86/include/asm/vdso.h
+++ b/arch/x86/include/asm/vdso.h
@@@ -1,34 -1,49 +1,72 @@@
  #ifndef _ASM_X86_VDSO_H
  #define _ASM_X86_VDSO_H
  
++<<<<<<< HEAD
++=======
+ #include <asm/page_types.h>
+ #include <linux/linkage.h>
+ #include <linux/init.h>
+ 
+ #ifndef __ASSEMBLER__
+ 
+ #include <linux/mm_types.h>
+ 
+ struct vdso_image {
+ 	void *data;
+ 	unsigned long size;   /* Always a multiple of PAGE_SIZE */
+ 
+ 	unsigned long alt, alt_len;
+ 
+ 	long sym_vvar_start;  /* Negative offset to the vvar area */
+ 
+ 	long sym_vvar_page;
+ 	long sym_hpet_page;
+ 	long sym_pvclock_page;
+ 	long sym_hvclock_page;
+ 	long sym_VDSO32_NOTE_MASK;
+ 	long sym___kernel_sigreturn;
+ 	long sym___kernel_rt_sigreturn;
+ 	long sym___kernel_vsyscall;
+ 	long sym_int80_landing_pad;
+ };
+ 
+ #ifdef CONFIG_X86_64
+ extern const struct vdso_image vdso_image_64;
+ #endif
+ 
+ #ifdef CONFIG_X86_X32
+ extern const struct vdso_image vdso_image_x32;
+ #endif
+ 
++>>>>>>> 90b20432aeb8 (x86/vdso: Add VCLOCK_HVCLOCK vDSO clock read method)
  #if defined CONFIG_X86_32 || defined CONFIG_COMPAT
 -extern const struct vdso_image vdso_image_32;
 -#endif
 +extern const char VDSO32_PRELINK[];
  
 -extern void __init init_vdso_image(const struct vdso_image *image);
 +/*
 + * Given a pointer to the vDSO image, find the pointer to VDSO32_name
 + * as that symbol is defined in the vDSO sources or linker script.
 + */
 +#define VDSO32_SYMBOL(base, name)					\
 +({									\
 +	extern const char VDSO32_##name[];				\
 +	(void __user *)(VDSO32_##name - VDSO32_PRELINK +		\
 +			(unsigned long)(base));				\
 +})
 +#endif
  
 -extern int map_vdso_once(const struct vdso_image *image, unsigned long addr);
 +/*
 + * These symbols are defined with the addresses in the vsyscall page.
 + * See vsyscall-sigreturn.S.
 + */
 +extern void __user __kernel_sigreturn;
 +extern void __user __kernel_rt_sigreturn;
  
 -#endif /* __ASSEMBLER__ */
 +/*
 + * These symbols are defined by vdso32.S to mark the bounds
 + * of the ELF DSO images included therein.
 + */
 +extern const char vdso32_int80_start, vdso32_int80_end;
 +extern const char vdso32_syscall_start, vdso32_syscall_end;
 +extern const char vdso32_sysenter_start, vdso32_sysenter_end;
  
  #endif /* _ASM_X86_VDSO_H */
* Unmerged path arch/x86/entry/vdso/vclock_gettime.c
* Unmerged path arch/x86/entry/vdso/vdso-layout.lds.S
* Unmerged path arch/x86/entry/vdso/vdso2c.c
* Unmerged path arch/x86/entry/vdso/vma.c
* Unmerged path arch/x86/entry/vdso/vclock_gettime.c
* Unmerged path arch/x86/entry/vdso/vdso-layout.lds.S
* Unmerged path arch/x86/entry/vdso/vdso2c.c
* Unmerged path arch/x86/entry/vdso/vma.c
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/include/asm/clocksource.h
* Unmerged path arch/x86/include/asm/vdso.h
