blk-mq: remove non-blocking pass in blk_mq_map_request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 63581af3f31e0dbea112b83f77c4fbb6a10e1406
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/63581af3.failed

bt_get already does a non-blocking pass as well as running the queue
when scheduling internally, no need to duplicate it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 63581af3f31e0dbea112b83f77c4fbb6a10e1406)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 49418900af65,80d483864247..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1313,24 -1206,12 +1313,30 @@@ static struct request *blk_mq_map_reque
  	ctx = blk_mq_get_ctx(q);
  	hctx = q->mq_ops->map_queue(q, ctx->cpu);
  
 -	if (rw_is_sync(bio_op(bio), bio->bi_opf))
 -		op_flags |= REQ_SYNC;
 +	if (rw_is_sync(bio->bi_rw))
 +		rw |= REQ_SYNC;
 +
++<<<<<<< HEAD
 +	trace_block_getrq(q, bio, rw);
 +	blk_mq_set_alloc_data(&alloc_data, q, BLK_MQ_REQ_NOWAIT, ctx, hctx);
 +	rq = __blk_mq_alloc_request(&alloc_data, rw);
 +	if (unlikely(!rq)) {
 +		__blk_mq_run_hw_queue(hctx);
 +		blk_mq_put_ctx(ctx);
 +		trace_block_sleeprq(q, bio, rw);
  
 +		ctx = blk_mq_get_ctx(q);
 +		hctx = q->mq_ops->map_queue(q, ctx->cpu);
 +		blk_mq_set_alloc_data(&alloc_data, q, 0, ctx, hctx);
 +		rq = __blk_mq_alloc_request(&alloc_data, rw);
 +		ctx = alloc_data.ctx;
 +		hctx = alloc_data.hctx;
 +	}
++=======
+ 	trace_block_getrq(q, bio, op);
+ 	blk_mq_set_alloc_data(&alloc_data, q, 0, ctx, hctx);
+ 	rq = __blk_mq_alloc_request(&alloc_data, op, op_flags);
++>>>>>>> 63581af3f31e (blk-mq: remove non-blocking pass in blk_mq_map_request)
  
  	hctx->queued++;
  	data->hctx = hctx;
* Unmerged path block/blk-mq.c
