vxlan: fix ND proxy when skb doesn't have transport header offset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vincent Bernat <vincent@bernat.im>
commit f1fb08f6337ca9e3af371a7994b91a5786ba93f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f1fb08f6.failed

When an incoming frame is tagged or when GRO is disabled, the skb
handled to vxlan_xmit() doesn't contain a valid transport header
offset. This makes ND proxying fail.

We combine two changes: replace use of skb_transport_offset() and ensure
the necessary amount of skb is linear just before using it:

 - In vxlan_xmit(), when determining if we have an ICMPv6 neighbor
   discovery packet, just check if it is an ICMPv6 packet and rely on
   neigh_reduce() to do more checks if this is the case. The use of
   pskb_may_pull() is replaced by skb_header_pointer() for just the IPv6
   header.

 - In neigh_reduce(), add pskb_may_pull() for IPv6 header and neighbor
   discovery message since this was removed from vxlan_xmit(). Replace
   skb_transport_header() with ipv6_hdr() + 1.

 - In vxlan_na_create(), replace first skb_transport_offset() with
   ipv6_hdr() + 1 and second with skb_network_offset() + sizeof(struct
   ipv6hdr). Additionally, ensure we pskb_may_pull() the whole skb as we
   need it to iterate over the options.

	Signed-off-by: Vincent Bernat <vincent@bernat.im>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f1fb08f6337ca9e3af371a7994b91a5786ba93f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 54a89c4b5d81,ebc98bb17a51..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2153,18 -2244,15 +2157,28 @@@ static netdev_tx_t vxlan_xmit(struct sk
  	if (vxlan->flags & VXLAN_F_PROXY) {
  		eth = eth_hdr(skb);
  		if (ntohs(eth->h_proto) == ETH_P_ARP)
 -			return arp_reduce(dev, skb, vni);
 +			return arp_reduce(dev, skb);
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +		else if (ntohs(eth->h_proto) == ETH_P_IPV6 &&
 +			 pskb_may_pull(skb, sizeof(struct ipv6hdr)
 +				       + sizeof(struct nd_msg)) &&
 +			 ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {
 +				struct nd_msg *msg;
 +
 +				msg = (struct nd_msg *)skb_transport_header(skb);
 +				if (msg->icmph.icmp6_code == 0 &&
 +				    msg->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)
 +					return neigh_reduce(dev, skb);
++=======
+ 		else if (ntohs(eth->h_proto) == ETH_P_IPV6) {
+ 			struct ipv6hdr *hdr, _hdr;
+ 			if ((hdr = skb_header_pointer(skb,
+ 						      skb_network_offset(skb),
+ 						      sizeof(_hdr), &_hdr)) &&
+ 			    hdr->nexthdr == IPPROTO_ICMPV6)
+ 				return neigh_reduce(dev, skb, vni);
++>>>>>>> f1fb08f6337c (vxlan: fix ND proxy when skb doesn't have transport header offset)
  		}
  #endif
  	}
* Unmerged path drivers/net/vxlan.c
