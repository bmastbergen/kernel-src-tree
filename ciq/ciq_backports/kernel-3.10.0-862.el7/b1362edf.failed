fsnotify: Remove fsnotify_find_{inode|vfsmount}_mark()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit b1362edfe15b20edd3d116cec521aa420b7afb98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b1362edf.failed

These are very thin wrappers, just remove them. Drop
fs/notify/vfsmount_mark.c as it is empty now.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit b1362edfe15b20edd3d116cec521aa420b7afb98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fsnotify.h
#	fs/notify/inode_mark.c
#	fs/notify/vfsmount_mark.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/fsnotify.h
index ce35f66baf27,bf012e8ecd14..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -21,30 -24,8 +21,35 @@@ extern u32 fsnotify_recalc_mask(struct 
  extern int fsnotify_compare_groups(struct fsnotify_group *a,
  				   struct fsnotify_group *b);
  
++<<<<<<< HEAD
 +extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 +						__u32 mask);
 +/* Add mark to a proper place in mark list */
 +extern int fsnotify_add_mark_list(struct hlist_head *head,
 +				  struct fsnotify_mark *mark,
 +				  int allow_dups);
 +/* add a mark to an inode */
 +extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 +				   struct fsnotify_group *group, struct inode *inode,
 +				   int allow_dups);
 +/* add a mark to a vfsmount */
 +extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 +				      struct fsnotify_group *group, struct vfsmount *mnt,
 +				      int allow_dups);
 +
 +/* vfsmount specific destruction of a mark */
 +extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 +/* inode specific destruction of a mark */
 +extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 +/* Find mark belonging to given group in the list of marks */
 +extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 +						struct fsnotify_group *group);
 +/* Destroy all marks in the given list protected by 'lock' */
 +extern void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock);
++=======
+ /* Destroy all marks connected via given connector */
+ extern void fsnotify_destroy_marks(struct fsnotify_mark_connector __rcu **connp);
++>>>>>>> b1362edfe15b (fsnotify: Remove fsnotify_find_{inode|vfsmount}_mark())
  /* run the list of all marks associated with inode and destroy them */
  static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
  {
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,5cc317bad082..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -30,125 -30,14 +30,128 @@@
  
  #include "../internal.h"
  
++<<<<<<< HEAD
 +/*
 + * Recalculate the inode->i_fsnotify_mask, or the mask of all FS_* event types
 + * any notifier is interested in hearing for this inode.
 + */
 +void fsnotify_recalc_inode_mask(struct inode *inode)
 +{
 +	spin_lock(&inode->i_lock);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	__fsnotify_update_child_dentry_flags(inode);
 +}
 +
 +void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
 +{
 +	struct inode *inode = mark->inode;
 +
 +	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&inode->i_lock);
 +
 +	hlist_del_init_rcu(&mark->obj_list);
 +	mark->inode = NULL;
 +
 +	/*
 +	 * this mark is now off the inode->i_fsnotify_marks list and we
 +	 * hold the inode->i_lock, so this is the perfect time to update the
 +	 * inode->i_fsnotify_mask
 +	 */
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +}
 +
 +/*
 + * Given a group clear all of the inode marks associated with that group.
 + */
 +void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)
 +{
 +	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_INODE);
 +}
 +
 +/*
 + * given a group and inode, find the mark associated with that combination.
 + * if found take a reference to that mark and return it, else return NULL
 + */
 +struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,
 +					       struct inode *inode)
 +{
 +	struct fsnotify_mark *mark;
 +
 +	spin_lock(&inode->i_lock);
 +	mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);
 +	spin_unlock(&inode->i_lock);
 +
 +	return mark;
 +}
 +
 +/*
 + * If we are setting a mark mask on an inode mark we should pin the inode
 + * in memory.
 + */
 +void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,
 +					 __u32 mask)
 +{
 +	struct inode *inode;
 +
 +	assert_spin_locked(&mark->lock);
 +
 +	if (mask &&
 +	    mark->inode &&
 +	    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {
 +		mark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;
 +		inode = igrab(mark->inode);
 +		/*
 +		 * we shouldn't be able to get here if the inode wasn't
 +		 * already safely held in memory.  But bug in case it
 +		 * ever is wrong.
 +		 */
 +		BUG_ON(!inode);
 +	}
 +}
 +
 +/*
 + * Attach an initialized mark to a given inode.
 + * These marks may be used for the fsnotify backend to determine which
 + * event types should be delivered to which group and for which inodes.  These
 + * marks are ordered according to priority, highest number first, and then by
 + * the group's location in memory.
 + */
 +int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 +			    struct fsnotify_group *group, struct inode *inode,
 +			    int allow_dups)
 +{
 +	int ret;
 +
 +	mark->flags |= FSNOTIFY_MARK_FLAG_INODE;
 +
 +	BUG_ON(!mutex_is_locked(&group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&inode->i_lock);
 +	mark->inode = inode;
 +	ret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,
 +				     allow_dups);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> b1362edfe15b (fsnotify: Remove fsnotify_find_{inode|vfsmount}_mark())
  /**
   * fsnotify_unmount_inodes - an sb is unmounting.  handle any watched inodes.
 - * @sb: superblock being unmounted.
 + * @list: list of inodes being unmounted (sb->s_inodes)
   *
   * Called during unmount with no locks held, so needs to be safe against
 - * concurrent modifiers. We temporarily drop sb->s_inode_list_lock and CAN block.
 + * concurrent modifiers. We temporarily drop inode_sb_list_lock and CAN block.
   */
 -void fsnotify_unmount_inodes(struct super_block *sb)
 +void fsnotify_unmount_inodes(struct list_head *list)
  {
  	struct inode *inode, *iput_inode = NULL;
  
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,2ef0e04c5a9d..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -331,19 -338,13 +331,26 @@@ extern struct fsnotify_event *fsnotify_
  
  /* functions used to manipulate the marks attached to inodes */
  
 -/* Calculate mask of events for a list of marks */
 -extern void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
 +/* run all marks associated with a vfsmount and update mnt->mnt_fsnotify_mask */
 +extern void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt);
 +/* run all marks associated with an inode and update inode->i_fsnotify_mask */
 +extern void fsnotify_recalc_inode_mask(struct inode *inode);
  extern void fsnotify_init_mark(struct fsnotify_mark *mark, void (*free_mark)(struct fsnotify_mark *mark));
++<<<<<<< HEAD
 +/* find (and take a reference) to a mark associated with group and inode */
 +extern struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group, struct inode *inode);
 +/* find (and take a reference) to a mark associated with group and vfsmount */
 +extern struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group, struct vfsmount *mnt);
 +/* set the ignored_mask of a mark */
 +extern void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask);
 +/* set the mask of a mark (might pin the object into memory */
 +extern void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask);
++=======
+ /* Find mark belonging to given group in the list of marks */
+ extern struct fsnotify_mark *fsnotify_find_mark(
+ 				struct fsnotify_mark_connector __rcu **connp,
+ 				struct fsnotify_group *group);
++>>>>>>> b1362edfe15b (fsnotify: Remove fsnotify_find_{inode|vfsmount}_mark())
  /* attach the mark to both the group and the inode */
  extern int fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,
  			     struct inode *inode, struct vfsmount *mnt, int allow_dups);
* Unmerged path fs/notify/vfsmount_mark.c
diff --git a/fs/notify/Makefile b/fs/notify/Makefile
index 96d3420d0242..ebb64a0282d1 100644
--- a/fs/notify/Makefile
+++ b/fs/notify/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_FSNOTIFY)		+= fsnotify.o notification.o group.o inode_mark.o \
-				   mark.o vfsmount_mark.o fdinfo.o
+				   mark.o fdinfo.o
 
 obj-y			+= dnotify/
 obj-y			+= inotify/
diff --git a/fs/notify/dnotify/dnotify.c b/fs/notify/dnotify/dnotify.c
index 38696275be90..d3c9ddaa54df 100644
--- a/fs/notify/dnotify/dnotify.c
+++ b/fs/notify/dnotify/dnotify.c
@@ -160,7 +160,7 @@ void dnotify_flush(struct file *filp, fl_owner_t id)
 	if (!S_ISDIR(inode->i_mode))
 		return;
 
-	fsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);
+	fsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, dnotify_group);
 	if (!fsn_mark)
 		return;
 	dn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);
@@ -316,7 +316,7 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
 	mutex_lock(&dnotify_group->mark_mutex);
 
 	/* add the new_fsn_mark or find an old one. */
-	fsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);
+	fsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, dnotify_group);
 	if (fsn_mark) {
 		dn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);
 		spin_lock(&fsn_mark->lock);
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 0bc2e0fd9d85..06fba33a6f9c 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -536,7 +536,8 @@ static int fanotify_remove_vfsmount_mark(struct fsnotify_group *group,
 	int destroy_mark;
 
 	mutex_lock(&group->mark_mutex);
-	fsn_mark = fsnotify_find_vfsmount_mark(group, mnt);
+	fsn_mark = fsnotify_find_mark(&real_mount(mnt)->mnt_fsnotify_marks,
+				      group);
 	if (!fsn_mark) {
 		mutex_unlock(&group->mark_mutex);
 		return -ENOENT;
@@ -565,7 +566,7 @@ static int fanotify_remove_inode_mark(struct fsnotify_group *group,
 	int destroy_mark;
 
 	mutex_lock(&group->mark_mutex);
-	fsn_mark = fsnotify_find_inode_mark(group, inode);
+	fsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);
 	if (!fsn_mark) {
 		mutex_unlock(&group->mark_mutex);
 		return -ENOENT;
@@ -581,7 +582,7 @@ static int fanotify_remove_inode_mark(struct fsnotify_group *group,
 	if (destroy_mark)
 		fsnotify_free_mark(fsn_mark);
 
-	/* matches the fsnotify_find_inode_mark() */
+	/* matches the fsnotify_find_mark() */
 	fsnotify_put_mark(fsn_mark);
 
 	return 0;
@@ -649,7 +650,8 @@ static int fanotify_add_vfsmount_mark(struct fsnotify_group *group,
 	__u32 added;
 
 	mutex_lock(&group->mark_mutex);
-	fsn_mark = fsnotify_find_vfsmount_mark(group, mnt);
+	fsn_mark = fsnotify_find_mark(&real_mount(mnt)->mnt_fsnotify_marks,
+				      group);
 	if (!fsn_mark) {
 		fsn_mark = fanotify_add_new_mark(group, NULL, mnt);
 		if (IS_ERR(fsn_mark)) {
@@ -686,7 +688,7 @@ static int fanotify_add_inode_mark(struct fsnotify_group *group,
 		return 0;
 
 	mutex_lock(&group->mark_mutex);
-	fsn_mark = fsnotify_find_inode_mark(group, inode);
+	fsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);
 	if (!fsn_mark) {
 		fsn_mark = fanotify_add_new_mark(group, inode, NULL);
 		if (IS_ERR(fsn_mark)) {
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/inode_mark.c
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 9881b183eb6d..b71abded9c7a 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -508,7 +508,7 @@ static int inotify_update_existing_watch(struct fsnotify_group *group,
 
 	mask = inotify_arg_to_mask(arg);
 
-	fsn_mark = fsnotify_find_inode_mark(group, inode);
+	fsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);
 	if (!fsn_mark)
 		return -ENOENT;
 
* Unmerged path fs/notify/vfsmount_mark.c
* Unmerged path include/linux/fsnotify_backend.h
diff --git a/kernel/audit_tree.c b/kernel/audit_tree.c
index 4dfdb945bae9..7c7434a8c401 100644
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -365,7 +365,8 @@ static int tag_chunk(struct inode *inode, struct audit_tree *tree)
 	struct node *p;
 	int n;
 
-	old_entry = fsnotify_find_inode_mark(audit_tree_group, inode);
+	old_entry = fsnotify_find_mark(&inode->i_fsnotify_marks,
+				       audit_tree_group);
 	if (!old_entry)
 		return create_chunk(inode, tree);
 
diff --git a/kernel/audit_watch.c b/kernel/audit_watch.c
index 30ee1f1108b2..7830efeb9e55 100644
--- a/kernel/audit_watch.c
+++ b/kernel/audit_watch.c
@@ -102,7 +102,7 @@ static inline struct audit_parent *audit_find_parent(struct inode *inode)
 	struct audit_parent *parent = NULL;
 	struct fsnotify_mark *entry;
 
-	entry = fsnotify_find_inode_mark(audit_watch_group, inode);
+	entry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);
 	if (entry)
 		parent = container_of(entry, struct audit_parent, mark);
 
