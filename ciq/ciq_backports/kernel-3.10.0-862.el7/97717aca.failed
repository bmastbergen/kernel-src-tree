nfp: validate rx offset from the BAR and size down it's field

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 97717aca618a85d9e52327b4509a3b95c2f8f121
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/97717aca.failed

NFP_NET_CFG_RX_OFFSET is 32bit wide, make sure what we read from
there is reasonable for packet headroom.  This allows us to store
the rx_offset in a 8bit variable.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 97717aca618a85d9e52327b4509a3b95c2f8f121)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 1826ee93d1da,5f0547c6efb8..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -417,18 -425,80 +417,88 @@@ static inline bool nfp_net_fw_ver_eq(st
  	       fw_ver->minor == minor;
  }
  
++<<<<<<< HEAD
++=======
+ struct nfp_stat_pair {
+ 	u64 pkts;
+ 	u64 bytes;
+ };
+ 
+ /**
+  * struct nfp_net_dp - NFP network device datapath data structure
+  * @dev:		Backpointer to struct device
+  * @netdev:		Backpointer to net_device structure
+  * @is_vf:		Is the driver attached to a VF?
+  * @bpf_offload_skip_sw:  Offloaded BPF program will not be rerun by cls_bpf
+  * @bpf_offload_xdp:	Offloaded BPF program is XDP
+  * @chained_metadata_format:  Firemware will use new metadata format
+  * @rx_dma_dir:		Mapping direction for RX buffers
+  * @rx_offset:		Offset in the RX buffers where packet data starts
+  * @ctrl:		Local copy of the control register/word.
+  * @fl_bufsz:		Currently configured size of the freelist buffers
+  * @xdp_prog:		Installed XDP program
+  * @tx_rings:		Array of pre-allocated TX ring structures
+  * @rx_rings:		Array of pre-allocated RX ring structures
+  * @ctrl_bar:		Pointer to mapped control BAR
+  *
+  * @txd_cnt:		Size of the TX ring in number of descriptors
+  * @rxd_cnt:		Size of the RX ring in number of descriptors
+  * @num_r_vecs:		Number of used ring vectors
+  * @num_tx_rings:	Currently configured number of TX rings
+  * @num_stack_tx_rings:	Number of TX rings used by the stack (not XDP)
+  * @num_rx_rings:	Currently configured number of RX rings
+  * @mtu:		Device MTU
+  */
+ struct nfp_net_dp {
+ 	struct device *dev;
+ 	struct net_device *netdev;
+ 
+ 	u8 is_vf:1;
+ 	u8 bpf_offload_skip_sw:1;
+ 	u8 bpf_offload_xdp:1;
+ 	u8 chained_metadata_format:1;
+ 
+ 	u8 rx_dma_dir;
+ 
+ 	u8 rx_offset;
+ 
+ 	u32 ctrl;
+ 	u32 fl_bufsz;
+ 
+ 	struct bpf_prog *xdp_prog;
+ 
+ 	struct nfp_net_tx_ring *tx_rings;
+ 	struct nfp_net_rx_ring *rx_rings;
+ 
+ 	u8 __iomem *ctrl_bar;
+ 
+ 	/* Cold data follows */
+ 
+ 	unsigned int txd_cnt;
+ 	unsigned int rxd_cnt;
+ 
+ 	unsigned int num_r_vecs;
+ 
+ 	unsigned int num_tx_rings;
+ 	unsigned int num_stack_tx_rings;
+ 	unsigned int num_rx_rings;
+ 
+ 	unsigned int mtu;
+ };
+ 
++>>>>>>> 97717aca618a (nfp: validate rx offset from the BAR and size down it's field)
  /**
   * struct nfp_net - NFP network device structure
 - * @dp:			Datapath structure
 - * @fw_ver:		Firmware version
 + * @pdev:               Backpointer to PCI device
 + * @netdev:             Backpointer to net_device structure
 + * @is_vf:              Is the driver attached to a VF?
 + * @fw_loaded:          Is the firmware loaded?
 + * @ctrl:               Local copy of the control register/word.
 + * @fl_bufsz:           Currently configured size of the freelist buffers
 + * @rx_offset:		Offset in the RX buffers where packet data starts
 + * @fw_ver:             Firmware version
   * @cap:                Capabilities advertised by the Firmware
   * @max_mtu:            Maximum support MTU advertised by the Firmware
 - * @rss_hfunc:		RSS selected hash function
   * @rss_cfg:            RSS configuration
   * @rss_key:            RSS secret key
   * @rss_itbl:           RSS indirection table
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index e0a7eb1db7a9,513f55dd746b..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2752,10 -3124,18 +2752,25 @@@ int nfp_net_netdev_init(struct net_devi
  	nfp_net_write_mac_addr(nn);
  
  	/* Determine RX packet/metadata boundary offset */
++<<<<<<< HEAD
 +	if (nn->fw_ver.major >= 2)
 +		nn->rx_offset = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
 +	else
 +		nn->rx_offset = NFP_NET_RX_OFFSET;
++=======
+ 	if (nn->fw_ver.major >= 2) {
+ 		u32 reg;
+ 
+ 		reg = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
+ 		if (reg > NFP_NET_MAX_PREPEND) {
+ 			nn_err(nn, "Invalid rx offset: %d\n", reg);
+ 			return -EINVAL;
+ 		}
+ 		nn->dp.rx_offset = reg;
+ 	} else {
+ 		nn->dp.rx_offset = NFP_NET_RX_OFFSET;
+ 	}
++>>>>>>> 97717aca618a (nfp: validate rx offset from the BAR and size down it's field)
  
  	/* Set default MTU and Freelist buffer size */
  	if (nn->max_mtu < NFP_NET_DEFAULT_MTU)
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
