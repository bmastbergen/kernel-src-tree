ceph: pass parent inode info to ceph_encode_dentry_release if we have it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit ca6c8ae0f7930dad7e10664e3b5bc657dd75be60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ca6c8ae0.failed

If we have a parent inode reference already, then we don't need to
go back up the directory tree to find one.

Link: http://tracker.ceph.com/issues/18148
	Signed-off-by: Jeff Layton <jlayton@redhat.com>
	Reviewed-by: Yan, Zheng <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit ca6c8ae0f7930dad7e10664e3b5bc657dd75be60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index 7d842b52f549,4951ab96ffc8..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -3884,9 -3924,10 +3884,14 @@@ int ceph_encode_inode_release(void **p
  }
  
  int ceph_encode_dentry_release(void **p, struct dentry *dentry,
+ 			       struct inode *dir,
  			       int mds, int drop, int unless)
  {
++<<<<<<< HEAD
 +	struct inode *dir = dentry->d_parent->d_inode;
++=======
+ 	struct dentry *parent = NULL;
++>>>>>>> ca6c8ae0f793 (ceph: pass parent inode info to ceph_encode_dentry_release if we have it)
  	struct ceph_mds_request_release *rel = *p;
  	struct ceph_dentry_info *di = ceph_dentry(dentry);
  	int force = 0;
@@@ -3901,9 -3942,14 +3906,20 @@@
  	spin_lock(&dentry->d_lock);
  	if (di->lease_session && di->lease_session->s_mds == mds)
  		force = 1;
++<<<<<<< HEAD
 +	spin_unlock(&dentry->d_lock);
 +
 +	ret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);
++=======
+ 	if (!dir) {
+ 		parent = dget(dentry->d_parent);
+ 		dir = d_inode(parent);
+ 	}
+ 	spin_unlock(&dentry->d_lock);
+ 
+ 	ret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);
+ 	dput(parent);
++>>>>>>> ca6c8ae0f793 (ceph: pass parent inode info to ceph_encode_dentry_release if we have it)
  
  	spin_lock(&dentry->d_lock);
  	if (ret && di->lease_session && di->lease_session->s_mds == mds) {
* Unmerged path fs/ceph/caps.c
diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c
index 33c790140222..53b30a36e967 100644
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@ -1922,10 +1922,13 @@ static struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,
 		      mds, req->r_inode_drop, req->r_inode_unless, 0);
 	if (req->r_dentry_drop)
 		releases += ceph_encode_dentry_release(&p, req->r_dentry,
-		       mds, req->r_dentry_drop, req->r_dentry_unless);
+				req->r_locked_dir, mds, req->r_dentry_drop,
+				req->r_dentry_unless);
 	if (req->r_old_dentry_drop)
 		releases += ceph_encode_dentry_release(&p, req->r_old_dentry,
-		       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);
+				req->r_old_dentry_dir, mds,
+				req->r_old_dentry_drop,
+				req->r_old_dentry_unless);
 	if (req->r_old_inode_drop)
 		releases += ceph_encode_inode_release(&p,
 		      req->r_old_dentry->d_inode,
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index 23add81e0e76..f3271c8e122e 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -904,6 +904,7 @@ extern void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc);
 extern int ceph_encode_inode_release(void **p, struct inode *inode,
 				     int mds, int drop, int unless, int force);
 extern int ceph_encode_dentry_release(void **p, struct dentry *dn,
+				      struct inode *dir,
 				      int mds, int drop, int unless);
 
 extern int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,
