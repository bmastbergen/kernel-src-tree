ovl: remove unused arg from ovl_lookup_temp()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 3d27573ce32b47ba54e6680c77c26a700d67cc16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3d27573c.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 3d27573ce32b47ba54e6680c77c26a700d67cc16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,843ed2a2d7db..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -295,10 -343,18 +295,25 @@@ static int ovl_copy_up_locked(struct de
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
++<<<<<<< HEAD
 +	/* Can't properly set mode on creation because of the umask */
 +	stat->mode &= S_IFMT;
 +	err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
 +	stat->mode = mode;
++=======
+ 	if (tmpfile)
+ 		temp = ovl_do_tmpfile(upperdir, stat->mode);
+ 	else
+ 		temp = ovl_lookup_temp(workdir);
+ 	err = 0;
+ 	if (IS_ERR(temp)) {
+ 		err = PTR_ERR(temp);
+ 		temp = NULL;
+ 	}
+ 
+ 	if (!err && !tmpfile)
+ 		err = ovl_create_real(wdir, temp, &cattr, NULL, true);
++>>>>>>> 3d27573ce32b (ovl: remove unused arg from ovl_lookup_temp())
  
  	if (new_creds) {
  		revert_creds(old_creds);
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,7c56932bfc2f..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -208,10 -261,15 +208,20 @@@ static inline void ovl_copyattr(struct 
  }
  
  /* dir.c */
++<<<<<<< HEAD
 +extern const struct inode_operations_wrapper ovl_dir_inode_operations;
 +struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);
++=======
+ extern const struct inode_operations ovl_dir_inode_operations;
+ struct dentry *ovl_lookup_temp(struct dentry *workdir);
+ struct cattr {
+ 	dev_t rdev;
+ 	umode_t mode;
+ 	const char *link;
+ };
++>>>>>>> 3d27573ce32b (ovl: remove unused arg from ovl_lookup_temp())
  int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 -		    struct cattr *attr,
 +		    struct kstat *stat, const char *link,
  		    struct dentry *hardlink, bool debug);
  void ovl_cleanup(struct inode *dir, struct dentry *dentry);
  
* Unmerged path fs/overlayfs/copy_up.c
diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c
index 09ee239b1762..97cb0fd1f82e 100644
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@ -34,7 +34,7 @@ void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)
 	}
 }
 
-struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)
+struct dentry *ovl_lookup_temp(struct dentry *workdir)
 {
 	struct dentry *temp;
 	char name[20];
@@ -61,7 +61,7 @@ static struct dentry *ovl_whiteout(struct dentry *workdir,
 	struct dentry *whiteout;
 	struct inode *wdir = workdir->d_inode;
 
-	whiteout = ovl_lookup_temp(workdir, dentry);
+	whiteout = ovl_lookup_temp(workdir);
 	if (IS_ERR(whiteout))
 		return whiteout;
 
@@ -257,7 +257,7 @@ static struct dentry *ovl_clear_empty(struct dentry *dentry,
 	if (upper->d_parent->d_inode != udir)
 		goto out_unlock;
 
-	opaquedir = ovl_lookup_temp(workdir, dentry);
+	opaquedir = ovl_lookup_temp(workdir);
 	err = PTR_ERR(opaquedir);
 	if (IS_ERR(opaquedir))
 		goto out_unlock;
@@ -432,7 +432,7 @@ static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,
 	if (err)
 		goto out;
 
-	newdentry = ovl_lookup_temp(workdir, dentry);
+	newdentry = ovl_lookup_temp(workdir);
 	err = PTR_ERR(newdentry);
 	if (IS_ERR(newdentry))
 		goto out_unlock;
* Unmerged path fs/overlayfs/overlayfs.h
