vxlan: support fdb and learning in COLLECT_METADATA mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Roopa Prabhu <roopa@cumulusnetworks.com>
commit 3ad7a4b141ebd6091494913672d7166d5c2764e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3ad7a4b1.failed

Vxlan COLLECT_METADATA mode today solves the per-vni netdev
scalability problem in l3 networks. It expects all forwarding
information to be present in dst_metadata. This patch series
enhances collect metadata mode to include the case where only
vni is present in dst_metadata, and the vxlan driver can then use
the rest of the forwarding information datbase to make forwarding
decisions. There is no change to default COLLECT_METADATA
behaviour. These changes only apply to COLLECT_METADATA when
used with the bridging use-case with a special dst_metadata
tunnel info flag (eg: where vxlan device is part of a bridge).
For all this to work, the vxlan driver will need to now support a
single fdb table hashed by mac + vni. This series essentially makes
this happen.

use-case and workflow:
vxlan collect metadata device participates in bridging vlan
to vn-segments. Bridge driver above the vxlan device,
sends the vni corresponding to the vlan in the dst_metadata.
vxlan driver will lookup forwarding database with (mac + vni)
for the required remote destination information to forward the
packet.

Changes introduced by this patch:
    - allow learning and forwarding database state in vxlan netdev in
      COLLECT_METADATA mode. Current behaviour is not changed
      by default. tunnel info flag IP_TUNNEL_INFO_BRIDGE is used
      to support the new bridge friendly mode.
    - A single fdb table hashed by (mac, vni) to allow fdb entries with
      multiple vnis in the same fdb table
    - rx path already has the vni
    - tx path expects a vni in the packet with dst_metadata
    - prior to this series, fdb remote_dsts carried remote vni and
      the vxlan device carrying the fdb table represented the
      source vni. With the vxlan device now representing multiple vnis,
      this patch adds a src vni attribute to the fdb entry. The remote
      vni already uses NDA_VNI attribute. This patch introduces
      NDA_SRC_VNI netlink attribute to represent the src vni in a multi
      vni fdb table.

iproute2 example (patched and pruned iproute2 output to just show
relevant fdb entries):
example shows same host mac learnt on two vni's.

before (netdev per vni):
$bridge fdb show | grep "00:02:00:00:00:03"
00:02:00:00:00:03 dev vxlan1001 dst 12.0.0.8 self
00:02:00:00:00:03 dev vxlan1000 dst 12.0.0.8 self

after this patch with collect metadata in bridged mode (single netdev):
$bridge fdb show | grep "00:02:00:00:00:03"
00:02:00:00:00:03 dev vxlan0 src_vni 1001 dst 12.0.0.8 self
00:02:00:00:00:03 dev vxlan0 src_vni 1000 dst 12.0.0.8 self

	Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3ad7a4b141ebd6091494913672d7166d5c2764e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 2ed0f4915f35,2374a75dcb55..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -719,25 -740,9 +742,25 @@@ static void vxlan_fdb_destroy(struct vx
  	call_rcu(&f->rcu, vxlan_fdb_free);
  }
  
 +static void vxlan_dst_free(struct rcu_head *head)
 +{
 +	struct vxlan_rdst *rd = container_of(head, struct vxlan_rdst, rcu);
 +
 +	dst_cache_destroy(&rd->dst_cache);
 +	kfree(rd);
 +}
 +
 +static void vxlan_fdb_dst_destroy(struct vxlan_dev *vxlan, struct vxlan_fdb *f,
 +				  struct vxlan_rdst *rd)
 +{
 +	list_del_rcu(&rd->list);
 +	vxlan_fdb_notify(vxlan, f, rd, RTM_DELNEIGH);
 +	call_rcu(&rd->rcu, vxlan_dst_free);
 +}
 +
  static int vxlan_fdb_parse(struct nlattr *tb[], struct vxlan_dev *vxlan,
- 			   union vxlan_addr *ip, __be16 *port, __be32 *vni,
- 			   u32 *ifindex)
+ 			   union vxlan_addr *ip, __be16 *port, __be32 *src_vni,
+ 			   __be32 *vni, u32 *ifindex)
  {
  	struct net *net = dev_net(vxlan->dev);
  	int err;
@@@ -1901,8 -1995,43 +1947,46 @@@ static void vxlan_encap_bypass(struct s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int encap_bypass_if_local(struct sk_buff *skb, struct net_device *dev,
+ 				 struct vxlan_dev *vxlan, union vxlan_addr *daddr,
+ 				 __be16 dst_port, __be32 vni, struct dst_entry *dst,
+ 				 u32 rt_flags)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	/* IPv6 rt-flags are checked against RTF_LOCAL, but the value of
+ 	 * RTF_LOCAL is equal to RTCF_LOCAL. So to keep code simple
+ 	 * we can use RTCF_LOCAL which works for ipv4 and ipv6 route entry.
+ 	 */
+ 	BUILD_BUG_ON(RTCF_LOCAL != RTF_LOCAL);
+ #endif
+ 	/* Bypass encapsulation if the destination is local */
+ 	if (rt_flags & RTCF_LOCAL &&
+ 	    !(rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
+ 		struct vxlan_dev *dst_vxlan;
+ 
+ 		dst_release(dst);
+ 		dst_vxlan = vxlan_find_vni(vxlan->net, vni,
+ 					   daddr->sa.sa_family, dst_port,
+ 					   vxlan->flags);
+ 		if (!dst_vxlan) {
+ 			dev->stats.tx_errors++;
+ 			kfree_skb(skb);
+ 
+ 			return -ENOENT;
+ 		}
+ 		vxlan_encap_bypass(skb, vxlan, dst_vxlan, vni);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 3ad7a4b141eb (vxlan: support fdb and learning in COLLECT_METADATA mode)
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
- 			   struct vxlan_rdst *rdst, bool did_rsc)
+ 			   __be32 default_vni, struct vxlan_rdst *rdst,
+ 			   bool did_rsc)
  {
  	struct dst_cache *dst_cache;
  	struct ip_tunnel_info *info;
@@@ -1927,11 -2054,34 +2011,26 @@@
  	info = skb_tunnel_info(skb);
  
  	if (rdst) {
++<<<<<<< HEAD
 +		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;
 +		vni = rdst->remote_vni;
 +		dst = &rdst->remote_ip;
++=======
+ 		dst = &rdst->remote_ip;
+ 		if (vxlan_addr_any(dst)) {
+ 			if (did_rsc) {
+ 				/* short-circuited back to local bridge */
+ 				vxlan_encap_bypass(skb, vxlan, vxlan, default_vni);
+ 				return;
+ 			}
+ 			goto drop;
+ 		}
+ 
+ 		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;
+ 		vni = (rdst->remote_vni) ? : default_vni;
++>>>>>>> 3ad7a4b141eb (vxlan: support fdb and learning in COLLECT_METADATA mode)
  		src = &vxlan->cfg.saddr;
  		dst_cache = &rdst->dst_cache;
 -		md->gbp = skb->mark;
 -		ttl = vxlan->cfg.ttl;
 -		if (!ttl && vxlan_addr_multicast(dst))
 -			ttl = 1;
 -
 -		tos = vxlan->cfg.tos;
 -		if (tos == 1)
 -			tos = ip_tunnel_get_dsfield(old_iph, skb);
 -
 -		if (dst->sa.sa_family == AF_INET)
 -			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM_TX);
 -		else
 -			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
 -		label = vxlan->cfg.label;
  	} else {
  		if (!info) {
  			WARN_ONCE(1, "%s: Missing encapsulation instructions\n",
* Unmerged path drivers/net/vxlan.c
diff --git a/include/uapi/linux/neighbour.h b/include/uapi/linux/neighbour.h
index e71798f84fb9..76e246b067f8 100644
--- a/include/uapi/linux/neighbour.h
+++ b/include/uapi/linux/neighbour.h
@@ -26,6 +26,7 @@ enum {
 	NDA_IFINDEX,
 	NDA_MASTER,
 	NDA_LINK_NETNSID,
+	NDA_SRC_VNI,
 	__NDA_MAX
 };
 
