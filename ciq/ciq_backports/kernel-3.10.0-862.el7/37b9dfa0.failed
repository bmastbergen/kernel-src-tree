netvsc: Remove redundant use of ipv6_hdr()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mohammed Gamal <mgamal@redhat.com>
commit 37b9dfa0d833227bc65353eec9dd0b00e1545a00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/37b9dfa0.failed

This condition already uses an object of type ipv6hdr in the line above.
Use the object directly instead of calling ipv6_hdr

	Signed-off-by: Mohammed Gamal <mgamal@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 37b9dfa0d833227bc65353eec9dd0b00e1545a00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,c266d427f934..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -312,63 -315,35 +312,70 @@@ static u32 init_page_array(void *hdr, u
  	return slots_used;
  }
  
 -/* Estimate number of page buffers neede to transmit
 - * Need at most 2 for RNDIS header plus skb body and fragments.
 - */
 -static unsigned int netvsc_get_slots(const struct sk_buff *skb)
 +static int count_skb_frag_slots(struct sk_buff *skb)
  {
 -	return PFN_UP(offset_in_page(skb->data) + skb_headlen(skb))
 -		+ skb_shinfo(skb)->nr_frags
 -		+ 2;
 +	int i, frags = skb_shinfo(skb)->nr_frags;
 +	int pages = 0;
 +
 +	for (i = 0; i < frags; i++) {
 +		skb_frag_t *frag = skb_shinfo(skb)->frags + i;
 +		unsigned long size = skb_frag_size(frag);
 +		unsigned long offset = frag->page_offset;
 +
 +		/* Skip unused frames from start of page */
 +		offset &= ~PAGE_MASK;
 +		pages += PFN_UP(offset + size);
 +	}
 +	return pages;
  }
  
 -static u32 net_checksum_info(struct sk_buff *skb)
 +static int netvsc_get_slots(struct sk_buff *skb)
  {
 -	if (skb->protocol == htons(ETH_P_IP)) {
 -		struct iphdr *ip = ip_hdr(skb);
 +	char *data = skb->data;
 +	unsigned int offset = offset_in_page(data);
 +	unsigned int len = skb_headlen(skb);
 +	int slots;
 +	int frag_slots;
 +
 +	slots = DIV_ROUND_UP(offset + len, PAGE_SIZE);
 +	frag_slots = count_skb_frag_slots(skb);
 +	return slots + frag_slots;
 +}
  
 -		if (ip->protocol == IPPROTO_TCP)
 -			return TRANSPORT_INFO_IPV4_TCP;
 -		else if (ip->protocol == IPPROTO_UDP)
 -			return TRANSPORT_INFO_IPV4_UDP;
 -	} else {
 -		struct ipv6hdr *ip6 = ipv6_hdr(skb);
++<<<<<<< HEAD
 +static u32 get_net_transport_info(struct sk_buff *skb, u32 *trans_off)
 +{
 +	u32 ret_val = TRANSPORT_INFO_NOT_IP;
  
 +	if ((eth_hdr(skb)->h_proto != htons(ETH_P_IP)) &&
 +		(eth_hdr(skb)->h_proto != htons(ETH_P_IPV6))) {
 +		goto not_ip;
++=======
+ 		if (ip6->nexthdr == IPPROTO_TCP)
+ 			return TRANSPORT_INFO_IPV6_TCP;
+ 		else if (ip6->nexthdr == IPPROTO_UDP)
+ 			return TRANSPORT_INFO_IPV6_UDP;
++>>>>>>> 37b9dfa0d833 (netvsc: Remove redundant use of ipv6_hdr())
  	}
  
 -	return TRANSPORT_INFO_NOT_IP;
 +	*trans_off = skb_transport_offset(skb);
 +
 +	if ((eth_hdr(skb)->h_proto == htons(ETH_P_IP))) {
 +		struct iphdr *iphdr = ip_hdr(skb);
 +
 +		if (iphdr->protocol == IPPROTO_TCP)
 +			ret_val = TRANSPORT_INFO_IPV4_TCP;
 +		else if (iphdr->protocol == IPPROTO_UDP)
 +			ret_val = TRANSPORT_INFO_IPV4_UDP;
 +	} else {
 +		if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
 +			ret_val = TRANSPORT_INFO_IPV6_TCP;
 +		else if (ipv6_hdr(skb)->nexthdr == IPPROTO_UDP)
 +			ret_val = TRANSPORT_INFO_IPV6_UDP;
 +	}
 +
 +not_ip:
 +	return ret_val;
  }
  
  static int netvsc_start_xmit(struct sk_buff *skb, struct net_device *net)
* Unmerged path drivers/net/hyperv/netvsc_drv.c
