Move platform device creation earlier in the initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 1abf71eef32c7f242fe30ea66a635e297b2c1c8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1abf71ee.failed

Some logs are printed out early using smi->dev, but on a platform device
that is not created until later.  So move the creation of that device
structure earlier in the sequence so it can be used for printing.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
	Tested-by: Corentin Labbe <clabbe.montjoie@gmail.com>
(cherry picked from commit 1abf71eef32c7f242fe30ea66a635e297b2c1c8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 625025a66dc5,751c2815fc2a..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -3481,14 -3502,16 +3481,18 @@@ static int try_smi_init(struct smi_inf
  {
  	int rv = 0;
  	int i;
++<<<<<<< HEAD
 +	struct ipmi_shadow_smi_handlers *shadow_handlers;
++=======
+ 	char *init_name = NULL;
++>>>>>>> 1abf71eef32c (Move platform device creation earlier in the initialization)
  
 -	printk(KERN_INFO PFX "Trying %s-specified %s state"
 -	       " machine at %s address 0x%lx, slave address 0x%x,"
 -	       " irq %d\n",
 -	       ipmi_addr_src_to_str(new_smi->addr_source),
 -	       si_to_str[new_smi->si_type],
 -	       addr_space_to_str[new_smi->io.addr_type],
 -	       new_smi->io.addr_data,
 -	       new_smi->slave_addr, new_smi->irq);
 +	pr_info(PFX "Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n",
 +		ipmi_addr_src_to_str(new_smi->addr_source),
 +		si_to_str[new_smi->si_type],
 +		addr_space_to_str[new_smi->io.addr_type],
 +		new_smi->io.addr_data,
 +		new_smi->slave_addr, new_smi->irq);
  
  	switch (new_smi->si_type) {
  	case SI_KCS:
@@@ -3580,29 -3625,16 +3604,15 @@@
  		atomic_set(&new_smi->req_events, 1);
  	}
  
- 	if (!new_smi->dev) {
- 		/*
- 		 * If we don't already have a device from something
- 		 * else (like PCI), then register a new one.
- 		 */
- 		new_smi->pdev = platform_device_alloc("ipmi_si",
- 						      new_smi->intf_num);
- 		if (!new_smi->pdev) {
- 			printk(KERN_ERR PFX
- 			       "Unable to allocate platform device\n");
- 			goto out_err;
- 		}
- 		new_smi->dev = &new_smi->pdev->dev;
- 		new_smi->dev->driver = &ipmi_driver.driver;
- 
+ 	if (new_smi->pdev) {
  		rv = platform_device_add(new_smi->pdev);
  		if (rv) {
 -			printk(KERN_ERR PFX
 -			       "Unable to register system interface device:"
 -			       " %d\n",
 -			       rv);
 +			dev_err(new_smi->dev,
 +				"Unable to register system interface device: %d\n",
 +				rv);
  			goto out_err;
  		}
 -		new_smi->dev_registered = true;
 +		new_smi->dev_registered = 1;
  	}
  
  	rv = ipmi_register_smi(&handlers,
@@@ -3693,9 -3721,15 +3706,19 @@@ out_err
  
  	if (new_smi->dev_registered) {
  		platform_device_unregister(new_smi->pdev);
++<<<<<<< HEAD
 +		new_smi->dev_registered = 0;
++=======
+ 		new_smi->dev_registered = false;
+ 		new_smi->pdev = NULL;
+ 	} else if (new_smi->pdev) {
+ 		platform_device_put(new_smi->pdev);
+ 		new_smi->pdev = NULL;
++>>>>>>> 1abf71eef32c (Move platform device creation earlier in the initialization)
  	}
  
+ 	kfree(init_name);
+ 
  	return rv;
  }
  
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
