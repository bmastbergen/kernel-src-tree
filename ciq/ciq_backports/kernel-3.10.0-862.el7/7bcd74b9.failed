ovl: check if all layers are on the same fs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 7bcd74b98d7bac3e5149894caaf72de6989af7f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7bcd74b9.failed

Some features can only work when all layers are on the same fs.  Test this
condition during mount time, so features can check them later.

Add helper ovl_same_sb() to return the common super block in case all
layers are on the same fs.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 7bcd74b98d7bac3e5149894caaf72de6989af7f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,c851158324e2..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -141,9 -146,16 +141,21 @@@ static inline struct inode *ovl_inode_r
  	return (struct inode *) (x & ~OVL_ISUPPER_MASK);
  }
  
++<<<<<<< HEAD
++=======
+ /* util.c */
+ int ovl_want_write(struct dentry *dentry);
+ void ovl_drop_write(struct dentry *dentry);
+ struct dentry *ovl_workdir(struct dentry *dentry);
+ const struct cred *ovl_override_creds(struct super_block *sb);
+ struct super_block *ovl_same_sb(struct super_block *sb);
+ struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
+ bool ovl_dentry_remote(struct dentry *dentry);
+ bool ovl_dentry_weird(struct dentry *dentry);
++>>>>>>> 7bcd74b98d7b (ovl: check if all layers are on the same fs)
  enum ovl_path_type ovl_path_type(struct dentry *dentry);
 +u64 ovl_dentry_version_get(struct dentry *dentry);
 +void ovl_dentry_version_inc(struct dentry *dentry);
  void ovl_path_upper(struct dentry *dentry, struct path *path);
  void ovl_path_lower(struct dentry *dentry, struct path *path);
  enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/ovl_entry.h
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index aaf06952d88f..df6a5b0c3bf6 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -1429,11 +1429,19 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 
 		ufs->lower_mnt[ufs->numlower] = mnt;
 		ufs->numlower++;
+
+		/* Check if all lower layers are on same sb */
+		if (i == 0)
+			ufs->same_sb = mnt->mnt_sb;
+		else if (ufs->same_sb != mnt->mnt_sb)
+			ufs->same_sb = NULL;
 	}
 
 	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 	if (!ufs->upper_mnt)
 		sb->s_flags |= MS_RDONLY;
+	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
+		ufs->same_sb = NULL;
 
 	if (remote)
 		sb->s_d_op = &ovl_reval_dentry_operations.ops;
* Unmerged path fs/overlayfs/util.c
