mlxsw: spectrum: Don't lose bridge port device during enslavement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit f0cebd81c9cec7395da71b43b9c02c000068907a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f0cebd81.failed

Currently, when port netdevs (or their uppers) are enslaved to a bridge,
we simply propagate the CHANGEUPPER event all the way down and lose the
context of the actual netdevice used as the bridge port.

This leads to a lot of information hanging off the ports (and vPorts),
which doesn't logically belong there, such as mrouter indication and
unknown unicast flood state.

Following patches are going to put the mlxsw_sp_port struct on diet and
instead introduce a bridge port struct, where the above mentioned
information belongs. But in order to do that, we need to be able to
determine the bridge port netdevice, so propagate it down.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f0cebd81c9cec7395da71b43b9c02c000068907a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 4a2dd98ae919,29d9439f6f12..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -4280,9 -4439,11 +4283,10 @@@ static void mlxsw_sp_port_ovs_leave(str
  	mlxsw_sp_port_vlan_set(mlxsw_sp_port, 2, VLAN_N_VID - 1,
  			       false, false);
  	mlxsw_sp_port_stp_set(mlxsw_sp_port, false);
 -	mlxsw_sp_port_vp_mode_set(mlxsw_sp_port, false);
  }
  
- static int mlxsw_sp_netdevice_port_upper_event(struct net_device *dev,
+ static int mlxsw_sp_netdevice_port_upper_event(struct net_device *lower_dev,
+ 					       struct net_device *dev,
  					       unsigned long event, void *ptr)
  {
  	struct netdev_notifier_changeupper_info *info;
@@@ -4674,9 -4860,13 +4686,11 @@@ err_port_vid_learning_set
  	return err;
  }
  
- static void mlxsw_sp_vport_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
+ static void mlxsw_sp_vport_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_vport,
+ 					struct net_device *brport_dev,
+ 					struct net_device *br_dev)
  {
  	u16 vid = mlxsw_sp_vport_vid_get(mlxsw_sp_vport);
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 -	struct mlxsw_sp_port *mlxsw_sp_port;
  
  	mlxsw_sp_port_vid_learning_set(mlxsw_sp_vport, vid, false);
  
@@@ -4742,14 -4934,12 +4757,21 @@@ static int mlxsw_sp_netdevice_port_vlan
  		if (netif_is_bridge_master(upper_dev)) {
  			if (info->linking)
  				err = mlxsw_sp_vport_bridge_join(mlxsw_sp_vport,
+ 								 vlan_dev,
  								 upper_dev);
  			else
++<<<<<<< HEAD
 +				mlxsw_sp_vport_bridge_leave(mlxsw_sp_vport);
 +		} else if (netif_is_l3_master(upper_dev)) {
 +			if (info->linking)
 +				err = mlxsw_sp_vport_vrf_join(mlxsw_sp_vport);
 +			else
 +				mlxsw_sp_vport_vrf_leave(mlxsw_sp_vport);
++=======
+ 				mlxsw_sp_vport_bridge_leave(mlxsw_sp_vport,
+ 							    vlan_dev,
+ 							    upper_dev);
++>>>>>>> f0cebd81c9ce (mlxsw: spectrum: Don't lose bridge port device during enslavement)
  		} else {
  			err = -EINVAL;
  			WARN_ON(1);
@@@ -4828,14 -4979,12 +4852,20 @@@ static int mlxsw_sp_netdevice_vlan_even
  	u16 vid = vlan_dev_vlan_id(vlan_dev);
  
  	if (mlxsw_sp_port_dev_check(real_dev))
- 		return mlxsw_sp_netdevice_vport_event(real_dev, event, ptr,
- 						      vid);
+ 		return mlxsw_sp_netdevice_port_vlan_event(vlan_dev, real_dev,
+ 							  event, ptr, vid);
  	else if (netif_is_lag_master(real_dev))
++<<<<<<< HEAD
 +		return mlxsw_sp_netdevice_lag_vport_event(real_dev, event, ptr,
 +							  vid);
 +	else if (netif_is_bridge_master(real_dev))
 +		return mlxsw_sp_netdevice_bridge_vlan_event(vlan_dev, event,
 +							    ptr);
++=======
+ 		return mlxsw_sp_netdevice_lag_port_vlan_event(vlan_dev,
+ 							      real_dev, event,
+ 							      ptr, vid);
++>>>>>>> f0cebd81c9ce (mlxsw: spectrum: Don't lose bridge port device during enslavement)
  
  	return 0;
  }
@@@ -4848,8 -5006,10 +4878,8 @@@ static int mlxsw_sp_netdevice_event(str
  
  	if (event == NETDEV_CHANGEADDR || event == NETDEV_CHANGEMTU)
  		err = mlxsw_sp_netdevice_router_port_event(dev);
 -	else if (mlxsw_sp_is_vrf_event(event, ptr))
 -		err = mlxsw_sp_netdevice_vrf_event(dev, event, ptr);
  	else if (mlxsw_sp_port_dev_check(dev))
- 		err = mlxsw_sp_netdevice_port_event(dev, event, ptr);
+ 		err = mlxsw_sp_netdevice_port_event(dev, dev, event, ptr);
  	else if (netif_is_lag_master(dev))
  		err = mlxsw_sp_netdevice_lag_event(dev, event, ptr);
  	else if (netif_is_bridge_master(dev))
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
