mlxsw: spectrum_router: Introduce loopback RIFs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 6ddb7426a7d4429c9df9dada9ebc0cc396d31cc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6ddb7426.failed

When offloading L3 tunnels, an adjacency entry is created that loops the
packet back into the underlay router. Loopback interfaces then hold the
corresponding information and are created for IP-in-IP netdevices.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6ddb7426a7d4429c9df9dada9ebc0cc396d31cc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.h
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index 94b899707d67,84ce83acdc19..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@@ -77,13 -73,20 +77,30 @@@ struct mlxsw_sp_upper 
  	unsigned int ref_count;
  };
  
++<<<<<<< HEAD
 +struct mlxsw_sp_fid {
 +	void (*leave)(struct mlxsw_sp_port *mlxsw_sp_vport);
 +	struct list_head list;
 +	unsigned int ref_count;
 +	struct net_device *dev;
 +	struct mlxsw_sp_rif *r;
 +	u16 fid;
++=======
+ enum mlxsw_sp_rif_type {
+ 	MLXSW_SP_RIF_TYPE_SUBPORT,
+ 	MLXSW_SP_RIF_TYPE_VLAN,
+ 	MLXSW_SP_RIF_TYPE_FID,
+ 	MLXSW_SP_RIF_TYPE_IPIP_LB, /* IP-in-IP loopback. */
+ 	MLXSW_SP_RIF_TYPE_MAX,
+ };
+ 
+ enum mlxsw_sp_fid_type {
+ 	MLXSW_SP_FID_TYPE_8021Q,
+ 	MLXSW_SP_FID_TYPE_8021D,
+ 	MLXSW_SP_FID_TYPE_RFID,
+ 	MLXSW_SP_FID_TYPE_DUMMY,
+ 	MLXSW_SP_FID_TYPE_MAX,
++>>>>>>> 6ddb7426a7d4 (mlxsw: spectrum_router: Introduce loopback RIFs)
  };
  
  struct mlxsw_sp_mid {
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 2055c8543e7b,72e386b647b9..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -46,6 -50,14 +47,17 @@@
  #include <net/neighbour.h>
  #include <net/arp.h>
  #include <net/ip_fib.h>
++<<<<<<< HEAD
++=======
+ #include <net/ip6_fib.h>
+ #include <net/fib_rules.h>
+ #include <net/ip_tunnels.h>
+ #include <net/l3mdev.h>
+ #include <net/addrconf.h>
+ #include <net/ndisc.h>
+ #include <net/ipv6.h>
+ #include <net/fib_notifier.h>
++>>>>>>> 6ddb7426a7d4 (mlxsw: spectrum_router: Introduce loopback RIFs)
  
  #include "spectrum.h"
  #include "core.h"
@@@ -55,13 -99,229 +67,225 @@@ struct mlxsw_sp_rif 
  	struct list_head nexthop_list;
  	struct list_head neigh_list;
  	struct net_device *dev;
 -	struct mlxsw_sp_fid *fid;
 +	struct mlxsw_sp_fid *f;
  	unsigned char addr[ETH_ALEN];
  	int mtu;
 -	u16 rif_index;
 +	u16 rif;
  	u16 vr_id;
 -	const struct mlxsw_sp_rif_ops *ops;
 -	struct mlxsw_sp *mlxsw_sp;
 -
 -	unsigned int counter_ingress;
 -	bool counter_ingress_valid;
 -	unsigned int counter_egress;
 -	bool counter_egress_valid;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_rif_params {
+ 	struct net_device *dev;
+ 	union {
+ 		u16 system_port;
+ 		u16 lag_id;
+ 	};
+ 	u16 vid;
+ 	bool lag;
+ };
+ 
+ struct mlxsw_sp_rif_subport {
+ 	struct mlxsw_sp_rif common;
+ 	union {
+ 		u16 system_port;
+ 		u16 lag_id;
+ 	};
+ 	u16 vid;
+ 	bool lag;
+ };
+ 
+ struct mlxsw_sp_rif_ipip_lb {
+ 	struct mlxsw_sp_rif common;
+ 	struct mlxsw_sp_rif_ipip_lb_config lb_config;
+ 	u16 ul_vr_id; /* Reserved for Spectrum-2. */
+ };
+ 
+ struct mlxsw_sp_rif_params_ipip_lb {
+ 	struct mlxsw_sp_rif_params common;
+ 	struct mlxsw_sp_rif_ipip_lb_config lb_config;
+ };
+ 
+ struct mlxsw_sp_rif_ops {
+ 	enum mlxsw_sp_rif_type type;
+ 	size_t rif_size;
+ 
+ 	void (*setup)(struct mlxsw_sp_rif *rif,
+ 		      const struct mlxsw_sp_rif_params *params);
+ 	int (*configure)(struct mlxsw_sp_rif *rif);
+ 	void (*deconfigure)(struct mlxsw_sp_rif *rif);
+ 	struct mlxsw_sp_fid * (*fid_get)(struct mlxsw_sp_rif *rif);
+ };
+ 
+ static unsigned int *
+ mlxsw_sp_rif_p_counter_get(struct mlxsw_sp_rif *rif,
+ 			   enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return &rif->counter_egress;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return &rif->counter_ingress;
+ 	}
+ 	return NULL;
+ }
+ 
+ static bool
+ mlxsw_sp_rif_counter_valid_get(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return rif->counter_egress_valid;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return rif->counter_ingress_valid;
+ 	}
+ 	return false;
+ }
+ 
+ static void
+ mlxsw_sp_rif_counter_valid_set(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir,
+ 			       bool valid)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		rif->counter_egress_valid = valid;
+ 		break;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		rif->counter_ingress_valid = valid;
+ 		break;
+ 	}
+ }
+ 
+ static int mlxsw_sp_rif_counter_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,
+ 				     unsigned int counter_index, bool enable,
+ 				     enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 	bool is_egress = false;
+ 	int err;
+ 
+ 	if (dir == MLXSW_SP_RIF_COUNTER_EGRESS)
+ 		is_egress = true;
+ 	mlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	mlxsw_reg_ritr_counter_pack(ritr_pl, counter_index, enable,
+ 				    is_egress);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_rif *rif,
+ 				   enum mlxsw_sp_rif_counter_dir dir, u64 *cnt)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 	unsigned int *p_counter_index;
+ 	bool valid;
+ 	int err;
+ 
+ 	valid = mlxsw_sp_rif_counter_valid_get(rif, dir);
+ 	if (!valid)
+ 		return -EINVAL;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, *p_counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_NOP);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ 	if (err)
+ 		return err;
+ 	*cnt = mlxsw_reg_ricnt_good_unicast_packets_get(ricnt_pl);
+ 	return 0;
+ }
+ 
+ static int mlxsw_sp_rif_counter_clear(struct mlxsw_sp *mlxsw_sp,
+ 				      unsigned int counter_index)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_CLEAR);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_alloc(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 	int err;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	err = mlxsw_sp_counter_alloc(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 				     p_counter_index);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_rif_counter_clear(mlxsw_sp, *p_counter_index);
+ 	if (err)
+ 		goto err_counter_clear;
+ 
+ 	err = mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 					*p_counter_index, true, dir);
+ 	if (err)
+ 		goto err_counter_edit;
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, true);
+ 	return 0;
+ 
+ err_counter_edit:
+ err_counter_clear:
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_rif_counter_free(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 
+ 	if (!mlxsw_sp_rif_counter_valid_get(rif, dir))
+ 		return;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (WARN_ON(!p_counter_index))
+ 		return;
+ 	mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 				  *p_counter_index, false, dir);
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, false);
+ }
+ 
+ static void mlxsw_sp_rif_counters_alloc(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct devlink *devlink;
+ 
+ 	devlink = priv_to_devlink(mlxsw_sp->core);
+ 	if (!devlink_dpipe_table_counter_enabled(devlink,
+ 						 MLXSW_SP_DPIPE_TABLE_NAME_ERIF))
+ 		return;
+ 	mlxsw_sp_rif_counter_alloc(mlxsw_sp, rif, MLXSW_SP_RIF_COUNTER_EGRESS);
+ }
+ 
+ static void mlxsw_sp_rif_counters_free(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 
+ 	mlxsw_sp_rif_counter_free(mlxsw_sp, rif, MLXSW_SP_RIF_COUNTER_EGRESS);
+ }
+ 
++>>>>>>> 6ddb7426a7d4 (mlxsw: spectrum_router: Introduce loopback RIFs)
  static struct mlxsw_sp_rif *
  mlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,
  			 const struct net_device *dev);
@@@ -587,9 -893,28 +811,28 @@@ static void mlxsw_sp_vrs_fini(struct ml
  	 */
  	mlxsw_core_flush_owq();
  	mlxsw_sp_router_fib_flush(mlxsw_sp);
 -	kfree(mlxsw_sp->router->vrs);
 +	kfree(mlxsw_sp->router.vrs);
  }
  
+ static struct net_device *
+ __mlxsw_sp_ipip_netdev_ul_dev_get(const struct net_device *ol_dev)
+ {
+ 	struct ip_tunnel *tun = netdev_priv(ol_dev);
+ 	struct net *net = dev_net(ol_dev);
+ 
+ 	return __dev_get_by_index(net, tun->parms.link);
+ }
+ 
+ static u32 mlxsw_sp_ipip_dev_ul_tb_id(const struct net_device *ol_dev)
+ {
+ 	struct net_device *d = __mlxsw_sp_ipip_netdev_ul_dev_get(ol_dev);
+ 
+ 	if (d)
+ 		return l3mdev_fib_table(d) ? : RT_TABLE_MAIN;
+ 	else
+ 		return l3mdev_fib_table(ol_dev) ? : RT_TABLE_MAIN;
+ }
+ 
  struct mlxsw_sp_neigh_key {
  	struct neighbour *n;
  };
@@@ -1615,10 -2268,29 +1858,36 @@@ static void mlxsw_sp_nexthop_neigh_fini
  	neigh_release(n);
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_nexthop_init(struct mlxsw_sp *mlxsw_sp,
 +				 struct mlxsw_sp_nexthop_group *nh_grp,
 +				 struct mlxsw_sp_nexthop *nh,
 +				 struct fib_nh *fib_nh)
++=======
+ static bool mlxsw_sp_netdev_ipip_type(const struct mlxsw_sp *mlxsw_sp,
+ 				      const struct net_device *dev,
+ 				      enum mlxsw_sp_ipip_type *p_type)
+ {
+ 	struct mlxsw_sp_router *router = mlxsw_sp->router;
+ 	const struct mlxsw_sp_ipip_ops *ipip_ops;
+ 	enum mlxsw_sp_ipip_type ipipt;
+ 
+ 	for (ipipt = 0; ipipt < MLXSW_SP_IPIP_TYPE_MAX; ++ipipt) {
+ 		ipip_ops = router->ipip_ops_arr[ipipt];
+ 		if (dev->type == ipip_ops->dev_type) {
+ 			if (p_type)
+ 				*p_type = ipipt;
+ 			return true;
+ 		}
+ 	}
+ 	return false;
+ }
+ 
+ static int mlxsw_sp_nexthop4_init(struct mlxsw_sp *mlxsw_sp,
+ 				  struct mlxsw_sp_nexthop_group *nh_grp,
+ 				  struct mlxsw_sp_nexthop *nh,
+ 				  struct fib_nh *fib_nh)
++>>>>>>> 6ddb7426a7d4 (mlxsw: spectrum_router: Introduce loopback RIFs)
  {
  	struct net_device *dev = fib_nh->nh_dev;
  	struct in_device *in_dev;
@@@ -2888,8 -4419,29 +3157,34 @@@ static bool mlxsw_sp_rif_should_config(
  	return false;
  }
  
++<<<<<<< HEAD
 +#define MLXSW_SP_INVALID_RIF 0xffff
 +static int mlxsw_sp_avail_rif_get(struct mlxsw_sp *mlxsw_sp)
++=======
+ static enum mlxsw_sp_rif_type
+ mlxsw_sp_dev_rif_type(const struct mlxsw_sp *mlxsw_sp,
+ 		      const struct net_device *dev)
+ {
+ 	enum mlxsw_sp_fid_type type;
+ 
+ 	if (mlxsw_sp_netdev_ipip_type(mlxsw_sp, dev, NULL))
+ 		return MLXSW_SP_RIF_TYPE_IPIP_LB;
+ 
+ 	/* Otherwise RIF type is derived from the type of the underlying FID. */
+ 	if (is_vlan_dev(dev) && netif_is_bridge_master(vlan_dev_real_dev(dev)))
+ 		type = MLXSW_SP_FID_TYPE_8021Q;
+ 	else if (netif_is_bridge_master(dev) && br_vlan_enabled(dev))
+ 		type = MLXSW_SP_FID_TYPE_8021Q;
+ 	else if (netif_is_bridge_master(dev))
+ 		type = MLXSW_SP_FID_TYPE_8021D;
+ 	else
+ 		type = MLXSW_SP_FID_TYPE_RFID;
+ 
+ 	return mlxsw_sp_fid_type_rif_type(mlxsw_sp, type);
+ }
+ 
+ static int mlxsw_sp_rif_index_alloc(struct mlxsw_sp *mlxsw_sp, u16 *p_rif_index)
++>>>>>>> 6ddb7426a7d4 (mlxsw: spectrum_router: Introduce loopback RIFs)
  {
  	int i;
  
@@@ -3450,71 -4924,433 +3745,446 @@@ err_rif_edit
  	return err;
  }
  
 -static int mlxsw_sp_port_vrf_join(struct mlxsw_sp *mlxsw_sp,
 -				  struct net_device *l3_dev)
 +int mlxsw_sp_vport_vrf_join(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
 +	struct net_device *dev = mlxsw_sp_vport->dev;
  
 -	/* If netdev is already associated with a RIF, then we need to
 -	 * destroy it and create a new one with the new virtual router ID.
 +	/* In case vPort already has a RIF, then we need to drop it.
 +	 * A new one will be created using the VRF's VR.
  	 */
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (rif)
 -		__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +	if (f && f->r)
 +		mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
 +
 +	return mlxsw_sp_vport_rif_sp_join(mlxsw_sp_vport, dev);
 +}
  
 -	return __mlxsw_sp_inetaddr_event(l3_dev, NETDEV_UP);
 +void mlxsw_sp_vport_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
 +{
 +	mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
 +}
 +
 +int mlxsw_sp_port_vrf_join(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
 +		return -EINVAL;
 +
 +	return mlxsw_sp_vport_vrf_join(mlxsw_sp_vport);
  }
  
 -static void mlxsw_sp_port_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 -				    struct net_device *l3_dev)
 +void mlxsw_sp_port_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_port)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
  
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (!rif)
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
  		return;
 -	__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +
 +	mlxsw_sp_vport_vrf_leave(mlxsw_sp_vport);
  }
  
 -int mlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,
 -				 struct netdev_notifier_changeupper_info *info)
 +int mlxsw_sp_bridge_vrf_join(struct mlxsw_sp *mlxsw_sp,
 +			     struct net_device *l3_dev)
  {
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
 -	int err = 0;
 +	struct mlxsw_sp_fid *f;
  
 -	if (!mlxsw_sp)
 -		return 0;
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return -EINVAL;
  
 -	switch (event) {
 -	case NETDEV_PRECHANGEUPPER:
 -		return 0;
 -	case NETDEV_CHANGEUPPER:
 -		if (info->linking)
 -			err = mlxsw_sp_port_vrf_join(mlxsw_sp, l3_dev);
 -		else
 -			mlxsw_sp_port_vrf_leave(mlxsw_sp, l3_dev);
 -		break;
 -	}
 +	if (f->r)
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
  
 -	return err;
 +	return mlxsw_sp_rif_bridge_create(mlxsw_sp, l3_dev, f);
  }
  
 -static struct mlxsw_sp_rif_subport *
 -mlxsw_sp_rif_subport_rif(const struct mlxsw_sp_rif *rif)
 +void mlxsw_sp_bridge_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 +			       struct net_device *l3_dev)
  {
 -	return container_of(rif, struct mlxsw_sp_rif_subport, common);
 -}
 +	struct mlxsw_sp_fid *f;
  
++<<<<<<< HEAD
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return;
 +	mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
++=======
+ static void mlxsw_sp_rif_subport_setup(struct mlxsw_sp_rif *rif,
+ 				       const struct mlxsw_sp_rif_params *params)
+ {
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	rif_subport->vid = params->vid;
+ 	rif_subport->lag = params->lag;
+ 	if (params->lag)
+ 		rif_subport->lag_id = params->lag_id;
+ 	else
+ 		rif_subport->system_port = params->system_port;
+ }
+ 
+ static int mlxsw_sp_rif_subport_op(struct mlxsw_sp_rif *rif, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_SP_IF,
+ 			    rif->rif_index, rif->vr_id, rif->dev->mtu);
+ 	mlxsw_reg_ritr_mac_pack(ritr_pl, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_sp_if_pack(ritr_pl, rif_subport->lag,
+ 				  rif_subport->lag ? rif_subport->lag_id :
+ 						     rif_subport->system_port,
+ 				  rif_subport->vid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static int mlxsw_sp_rif_subport_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_subport_op(rif, true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(rif->fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_fid_rif_set(rif->fid, rif);
+ 	return 0;
+ 
+ err_rif_fdb_op:
+ 	mlxsw_sp_rif_subport_op(rif, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_subport_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	mlxsw_sp_rif_subport_op(rif, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_subport_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_rfid_get(rif->mlxsw_sp, rif->rif_index);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_subport_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_SUBPORT,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif_subport),
+ 	.setup			= mlxsw_sp_rif_subport_setup,
+ 	.configure		= mlxsw_sp_rif_subport_configure,
+ 	.deconfigure		= mlxsw_sp_rif_subport_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_subport_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_vlan_fid_op(struct mlxsw_sp_rif *rif,
+ 				    enum mlxsw_reg_ritr_if_type type,
+ 				    u16 vid_fid, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, type, rif->rif_index, rif->vr_id,
+ 			    rif->dev->mtu);
+ 	mlxsw_reg_ritr_mac_pack(ritr_pl, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_fid_set(ritr_pl, type, vid_fid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static u8 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp)
+ {
+ 	return mlxsw_core_max_ports(mlxsw_sp->core) + 1;
+ }
+ 
+ static int mlxsw_sp_rif_vlan_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_mc_flood_set;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(rif->fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_fid_rif_set(rif->fid, rif);
+ 	return 0;
+ 
+ err_rif_fdb_op:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_mc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_vlan_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 vid = is_vlan_dev(rif->dev) ? vlan_dev_vlan_id(rif->dev) : 1;
+ 
+ 	return mlxsw_sp_fid_8021q_get(rif->mlxsw_sp, vid);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_vlan_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_VLAN,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_vlan_configure,
+ 	.deconfigure		= mlxsw_sp_rif_vlan_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_vlan_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_fid_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index,
+ 				       true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_mc_flood_set;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	err = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 				  mlxsw_sp_fid_index(rif->fid), true);
+ 	if (err)
+ 		goto err_rif_fdb_op;
+ 
+ 	mlxsw_sp_fid_rif_set(rif->fid, rif);
+ 	return 0;
+ 
+ err_rif_fdb_op:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_mc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_fid_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_fid *fid = rif->fid;
+ 
+ 	mlxsw_sp_fid_rif_set(fid, NULL);
+ 	mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, rif->dev->dev_addr,
+ 			    mlxsw_sp_fid_index(fid), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_8021d_get(rif->mlxsw_sp, rif->dev->ifindex);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_fid_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_FID,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_fid_configure,
+ 	.deconfigure		= mlxsw_sp_rif_fid_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_fid_fid_get,
+ };
+ 
+ static struct mlxsw_sp_rif_ipip_lb *
+ mlxsw_sp_rif_ipip_lb_rif(struct mlxsw_sp_rif *rif)
+ {
+ 	return container_of(rif, struct mlxsw_sp_rif_ipip_lb, common);
+ }
+ 
+ static void
+ mlxsw_sp_rif_ipip_lb_setup(struct mlxsw_sp_rif *rif,
+ 			   const struct mlxsw_sp_rif_params *params)
+ {
+ 	struct mlxsw_sp_rif_params_ipip_lb *params_lb;
+ 	struct mlxsw_sp_rif_ipip_lb *rif_lb;
+ 
+ 	params_lb = container_of(params, struct mlxsw_sp_rif_params_ipip_lb,
+ 				 common);
+ 	rif_lb = mlxsw_sp_rif_ipip_lb_rif(rif);
+ 	rif_lb->lb_config = params_lb->lb_config;
+ }
+ 
+ static int
+ mlxsw_sp_rif_ipip_lb_op(struct mlxsw_sp_rif_ipip_lb *lb_rif,
+ 			struct mlxsw_sp_vr *ul_vr, bool enable)
+ {
+ 	struct mlxsw_sp_rif_ipip_lb_config lb_cf = lb_rif->lb_config;
+ 	struct mlxsw_sp_rif *rif = &lb_rif->common;
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 	u32 saddr4;
+ 
+ 	switch (lb_cf.ul_protocol) {
+ 	case MLXSW_SP_L3_PROTO_IPV4:
+ 		saddr4 = be32_to_cpu(lb_cf.saddr.addr4);
+ 		mlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_LOOPBACK_IF,
+ 				    rif->rif_index, rif->vr_id, rif->dev->mtu);
+ 		mlxsw_reg_ritr_loopback_ipip4_pack(ritr_pl, lb_cf.lb_ipipt,
+ 			    MLXSW_REG_RITR_LOOPBACK_IPIP_OPTIONS_GRE_KEY_PRESET,
+ 			    ul_vr->id, saddr4, lb_cf.okey);
+ 		break;
+ 
+ 	case MLXSW_SP_L3_PROTO_IPV6:
+ 		return -EAFNOSUPPORT;
+ 	}
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static int
+ mlxsw_sp_rif_ipip_lb_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp_rif_ipip_lb *lb_rif = mlxsw_sp_rif_ipip_lb_rif(rif);
+ 	u32 ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(rif->dev);
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_vr *ul_vr;
+ 	int err;
+ 
+ 	ul_vr = mlxsw_sp_vr_get(mlxsw_sp, ul_tb_id);
+ 	if (IS_ERR(ul_vr))
+ 		return PTR_ERR(ul_vr);
+ 
+ 	err = mlxsw_sp_rif_ipip_lb_op(lb_rif, ul_vr, true);
+ 	if (err)
+ 		goto err_loopback_op;
+ 
+ 	lb_rif->ul_vr_id = ul_vr->id;
+ 	++ul_vr->rif_count;
+ 	return 0;
+ 
+ err_loopback_op:
+ 	mlxsw_sp_vr_put(ul_vr);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_ipip_lb_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp_rif_ipip_lb *lb_rif = mlxsw_sp_rif_ipip_lb_rif(rif);
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_vr *ul_vr;
+ 
+ 	ul_vr = &mlxsw_sp->router->vrs[lb_rif->ul_vr_id];
+ 	mlxsw_sp_rif_ipip_lb_op(lb_rif, ul_vr, false);
+ 
+ 	--ul_vr->rif_count;
+ 	mlxsw_sp_vr_put(ul_vr);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_ipip_lb_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_IPIP_LB,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif_ipip_lb),
+ 	.setup                  = mlxsw_sp_rif_ipip_lb_setup,
+ 	.configure		= mlxsw_sp_rif_ipip_lb_configure,
+ 	.deconfigure		= mlxsw_sp_rif_ipip_lb_deconfigure,
+ };
+ 
+ static const struct mlxsw_sp_rif_ops *mlxsw_sp_rif_ops_arr[] = {
+ 	[MLXSW_SP_RIF_TYPE_SUBPORT]	= &mlxsw_sp_rif_subport_ops,
+ 	[MLXSW_SP_RIF_TYPE_VLAN]	= &mlxsw_sp_rif_vlan_ops,
+ 	[MLXSW_SP_RIF_TYPE_FID]		= &mlxsw_sp_rif_fid_ops,
+ 	[MLXSW_SP_RIF_TYPE_IPIP_LB]	= &mlxsw_sp_rif_ipip_lb_ops,
+ };
+ 
+ static int mlxsw_sp_rifs_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	u64 max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);
+ 
+ 	mlxsw_sp->router->rifs = kcalloc(max_rifs,
+ 					 sizeof(struct mlxsw_sp_rif *),
+ 					 GFP_KERNEL);
+ 	if (!mlxsw_sp->router->rifs)
+ 		return -ENOMEM;
+ 
+ 	mlxsw_sp->router->rif_ops_arr = mlxsw_sp_rif_ops_arr;
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_rifs_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
+ 		WARN_ON_ONCE(mlxsw_sp->router->rifs[i]);
+ 
+ 	kfree(mlxsw_sp->router->rifs);
+ }
+ 
+ static int mlxsw_sp_ipips_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	mlxsw_sp->router->ipip_ops_arr = mlxsw_sp_ipip_ops_arr;
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_ipips_fini(struct mlxsw_sp *mlxsw_sp)
+ {
++>>>>>>> 6ddb7426a7d4 (mlxsw: spectrum_router: Introduce loopback RIFs)
  }
  
  static void mlxsw_sp_router_fib_dump_flush(struct notifier_block *nb)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
