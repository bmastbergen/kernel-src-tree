net: l2tp: Make l2tp_ip6 namespace aware

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] l2tp: Make l2tp_ip6 namespace aware (Xin Long) [1465711]
Rebuild_FUZZ: 93.33%
commit-author Shmulik Ladkani <shmulik.ladkani@gmail.com>
commit 0e6b5259824e97a0f7e7b450421ff12865d3b0e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0e6b5259.failed

l2tp_ip6 tunnel and session lookups were still using init_net, although
the l2tp core infrastructure already supports lookups keyed by 'net'.

As a result, l2tp_ip6_recv discarded packets for tunnels/sessions
created in namespaces other than the init_net.

Fix, by using dev_net(skb->dev) or sock_net(sk) where appropriate.

	Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e6b5259824e97a0f7e7b450421ff12865d3b0e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_ip6.c
diff --cc net/l2tp/l2tp_ip6.c
index 636e3095420e,6c54e03fe9c1..000000000000
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@@ -186,23 -189,15 +187,33 @@@ pass_up
  		goto discard;
  
  	tunnel_id = ntohl(*(__be32 *) &skb->data[4]);
++<<<<<<< HEAD
 +	tunnel = l2tp_tunnel_find(&init_net, tunnel_id);
 +	if (tunnel) {
++=======
+ 	tunnel = l2tp_tunnel_find(net, tunnel_id);
+ 	if (tunnel != NULL)
++>>>>>>> 0e6b5259824e (net: l2tp: Make l2tp_ip6 namespace aware)
  		sk = tunnel->sock;
 -	else {
 +		sock_hold(sk);
 +	} else {
  		struct ipv6hdr *iph = ipv6_hdr(skb);
  
  		read_lock_bh(&l2tp_ip6_lock);
++<<<<<<< HEAD
 +
 +		sk = __l2tp_ip6_bind_lookup(&init_net, &iph->daddr, inet6_iif(skb),
 +					    tunnel_id);
 +		if (!sk) {
 +			read_unlock_bh(&l2tp_ip6_lock);
 +			goto discard;
 +		}
 +
 +		sock_hold(sk);
++=======
+ 		sk = __l2tp_ip6_bind_lookup(net, &iph->daddr,
+ 					    0, tunnel_id);
++>>>>>>> 0e6b5259824e (net: l2tp: Make l2tp_ip6 namespace aware)
  		read_unlock_bh(&l2tp_ip6_lock);
  	}
  
@@@ -264,8 -264,8 +275,9 @@@ static int l2tp_ip6_bind(struct sock *s
  	struct inet_sock *inet = inet_sk(sk);
  	struct ipv6_pinfo *np = inet6_sk(sk);
  	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
+ 	struct net *net = sock_net(sk);
  	__be32 v4addr = 0;
 +	int bound_dev_if;
  	int addr_type;
  	int err;
  
@@@ -284,6 -286,13 +296,16 @@@
  	if (addr_type & IPV6_ADDR_MULTICAST)
  		return -EADDRNOTAVAIL;
  
++<<<<<<< HEAD
++=======
+ 	err = -EADDRINUSE;
+ 	read_lock_bh(&l2tp_ip6_lock);
+ 	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
+ 				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
+ 		goto out_in_use;
+ 	read_unlock_bh(&l2tp_ip6_lock);
+ 
++>>>>>>> 0e6b5259824e (net: l2tp: Make l2tp_ip6 namespace aware)
  	lock_sock(sk);
  
  	err = -EINVAL;
* Unmerged path net/l2tp/l2tp_ip6.c
