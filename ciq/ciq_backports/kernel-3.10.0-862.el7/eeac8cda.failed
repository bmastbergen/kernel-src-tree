scsi: cxlflash: return -EFAULT if copy_from_user() fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: return -EFAULT if copy_from_user() fails (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 94.34%
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit eeac8cda2c957e156093933b860eec09e488fe15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/eeac8cda.failed

The copy_from/to_user() functions return the number of bytes remaining
to be copied but we had intended to return -EFAULT here.

Fixes: bc88ac47d5cb ("scsi: cxlflash: Support AFU debug")
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Acked-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit eeac8cda2c957e156093933b860eec09e488fe15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,6a4367cc9caa..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -2382,6 -3218,400 +2382,403 @@@ static void cxlflash_worker_thread(stru
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * cxlflash_chr_open() - character device open handler
+  * @inode:	Device inode associated with this character device.
+  * @file:	File pointer for this device.
+  *
+  * Only users with admin privileges are allowed to open the character device.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int cxlflash_chr_open(struct inode *inode, struct file *file)
+ {
+ 	struct cxlflash_cfg *cfg;
+ 
+ 	if (!capable(CAP_SYS_ADMIN))
+ 		return -EACCES;
+ 
+ 	cfg = container_of(inode->i_cdev, struct cxlflash_cfg, cdev);
+ 	file->private_data = cfg;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * decode_hioctl() - translates encoded host ioctl to easily identifiable string
+  * @cmd:        The host ioctl command to decode.
+  *
+  * Return: A string identifying the decoded host ioctl.
+  */
+ static char *decode_hioctl(int cmd)
+ {
+ 	switch (cmd) {
+ 	case HT_CXLFLASH_LUN_PROVISION:
+ 		return __stringify_1(HT_CXLFLASH_LUN_PROVISION);
+ 	}
+ 
+ 	return "UNKNOWN";
+ }
+ 
+ /**
+  * cxlflash_lun_provision() - host LUN provisioning handler
+  * @cfg:	Internal structure associated with the host.
+  * @arg:	Kernel copy of userspace ioctl data structure.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int cxlflash_lun_provision(struct cxlflash_cfg *cfg,
+ 				  struct ht_cxlflash_lun_provision *lunprov)
+ {
+ 	struct afu *afu = cfg->afu;
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct sisl_ioarcb rcb;
+ 	struct sisl_ioasa asa;
+ 	__be64 __iomem *fc_port_regs;
+ 	u16 port = lunprov->port;
+ 	u16 scmd = lunprov->hdr.subcmd;
+ 	u16 type;
+ 	u64 reg;
+ 	u64 size;
+ 	u64 lun_id;
+ 	int rc = 0;
+ 
+ 	if (!afu_is_lun_provision(afu)) {
+ 		rc = -ENOTSUPP;
+ 		goto out;
+ 	}
+ 
+ 	if (port >= cfg->num_fc_ports) {
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	switch (scmd) {
+ 	case HT_CXLFLASH_LUN_PROVISION_SUBCMD_CREATE_LUN:
+ 		type = SISL_AFU_LUN_PROVISION_CREATE;
+ 		size = lunprov->size;
+ 		lun_id = 0;
+ 		break;
+ 	case HT_CXLFLASH_LUN_PROVISION_SUBCMD_DELETE_LUN:
+ 		type = SISL_AFU_LUN_PROVISION_DELETE;
+ 		size = 0;
+ 		lun_id = lunprov->lun_id;
+ 		break;
+ 	case HT_CXLFLASH_LUN_PROVISION_SUBCMD_QUERY_PORT:
+ 		fc_port_regs = get_fc_port_regs(cfg, port);
+ 
+ 		reg = readq_be(&fc_port_regs[FC_MAX_NUM_LUNS / 8]);
+ 		lunprov->max_num_luns = reg;
+ 		reg = readq_be(&fc_port_regs[FC_CUR_NUM_LUNS / 8]);
+ 		lunprov->cur_num_luns = reg;
+ 		reg = readq_be(&fc_port_regs[FC_MAX_CAP_PORT / 8]);
+ 		lunprov->max_cap_port = reg;
+ 		reg = readq_be(&fc_port_regs[FC_CUR_CAP_PORT / 8]);
+ 		lunprov->cur_cap_port = reg;
+ 
+ 		goto out;
+ 	default:
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	memset(&rcb, 0, sizeof(rcb));
+ 	memset(&asa, 0, sizeof(asa));
+ 	rcb.req_flags = SISL_REQ_FLAGS_AFU_CMD;
+ 	rcb.lun_id = lun_id;
+ 	rcb.msi = SISL_MSI_RRQ_UPDATED;
+ 	rcb.timeout = MC_LUN_PROV_TIMEOUT;
+ 	rcb.ioasa = &asa;
+ 
+ 	rcb.cdb[0] = SISL_AFU_CMD_LUN_PROVISION;
+ 	rcb.cdb[1] = type;
+ 	rcb.cdb[2] = port;
+ 	put_unaligned_be64(size, &rcb.cdb[8]);
+ 
+ 	rc = send_afu_cmd(afu, &rcb);
+ 	if (rc) {
+ 		dev_err(dev, "%s: send_afu_cmd failed rc=%d asc=%08x afux=%x\n",
+ 			__func__, rc, asa.ioasc, asa.afu_extra);
+ 		goto out;
+ 	}
+ 
+ 	if (scmd == HT_CXLFLASH_LUN_PROVISION_SUBCMD_CREATE_LUN) {
+ 		lunprov->lun_id = (u64)asa.lunid_hi << 32 | asa.lunid_lo;
+ 		memcpy(lunprov->wwid, asa.wwid, sizeof(lunprov->wwid));
+ 	}
+ out:
+ 	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
+ 	return rc;
+ }
+ 
+ /**
+  * cxlflash_afu_debug() - host AFU debug handler
+  * @cfg:	Internal structure associated with the host.
+  * @arg:	Kernel copy of userspace ioctl data structure.
+  *
+  * For debug requests requiring a data buffer, always provide an aligned
+  * (cache line) buffer to the AFU to appease any alignment requirements.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int cxlflash_afu_debug(struct cxlflash_cfg *cfg,
+ 			      struct ht_cxlflash_afu_debug *afu_dbg)
+ {
+ 	struct afu *afu = cfg->afu;
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct sisl_ioarcb rcb;
+ 	struct sisl_ioasa asa;
+ 	char *buf = NULL;
+ 	char *kbuf = NULL;
+ 	void __user *ubuf = (__force void __user *)afu_dbg->data_ea;
+ 	u16 req_flags = SISL_REQ_FLAGS_AFU_CMD;
+ 	u32 ulen = afu_dbg->data_len;
+ 	bool is_write = afu_dbg->hdr.flags & HT_CXLFLASH_HOST_WRITE;
+ 	int rc = 0;
+ 
+ 	if (!afu_is_afu_debug(afu)) {
+ 		rc = -ENOTSUPP;
+ 		goto out;
+ 	}
+ 
+ 	if (ulen) {
+ 		req_flags |= SISL_REQ_FLAGS_SUP_UNDERRUN;
+ 
+ 		if (ulen > HT_CXLFLASH_AFU_DEBUG_MAX_DATA_LEN) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 
+ 		if (unlikely(!access_ok(is_write ? VERIFY_READ : VERIFY_WRITE,
+ 					ubuf, ulen))) {
+ 			rc = -EFAULT;
+ 			goto out;
+ 		}
+ 
+ 		buf = kmalloc(ulen + cache_line_size() - 1, GFP_KERNEL);
+ 		if (unlikely(!buf)) {
+ 			rc = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		kbuf = PTR_ALIGN(buf, cache_line_size());
+ 
+ 		if (is_write) {
+ 			req_flags |= SISL_REQ_FLAGS_HOST_WRITE;
+ 
+ 			if (copy_from_user(kbuf, ubuf, ulen)) {
+ 				rc = -EFAULT;
+ 				goto out;
+ 			}
+ 		}
+ 	}
+ 
+ 	memset(&rcb, 0, sizeof(rcb));
+ 	memset(&asa, 0, sizeof(asa));
+ 
+ 	rcb.req_flags = req_flags;
+ 	rcb.msi = SISL_MSI_RRQ_UPDATED;
+ 	rcb.timeout = MC_AFU_DEBUG_TIMEOUT;
+ 	rcb.ioasa = &asa;
+ 
+ 	if (ulen) {
+ 		rcb.data_len = ulen;
+ 		rcb.data_ea = (uintptr_t)kbuf;
+ 	}
+ 
+ 	rcb.cdb[0] = SISL_AFU_CMD_DEBUG;
+ 	memcpy(&rcb.cdb[4], afu_dbg->afu_subcmd,
+ 	       HT_CXLFLASH_AFU_DEBUG_SUBCMD_LEN);
+ 
+ 	rc = send_afu_cmd(afu, &rcb);
+ 	if (rc) {
+ 		dev_err(dev, "%s: send_afu_cmd failed rc=%d asc=%08x afux=%x\n",
+ 			__func__, rc, asa.ioasc, asa.afu_extra);
+ 		goto out;
+ 	}
+ 
+ 	if (ulen && !is_write) {
+ 		if (copy_to_user(ubuf, kbuf, ulen))
+ 			rc = -EFAULT;
+ 	}
+ out:
+ 	kfree(buf);
+ 	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
+ 	return rc;
+ }
+ 
+ /**
+  * cxlflash_chr_ioctl() - character device IOCTL handler
+  * @file:	File pointer for this device.
+  * @cmd:	IOCTL command.
+  * @arg:	Userspace ioctl data structure.
+  *
+  * A read/write semaphore is used to implement a 'drain' of currently
+  * running ioctls. The read semaphore is taken at the beginning of each
+  * ioctl thread and released upon concluding execution. Additionally the
+  * semaphore should be released and then reacquired in any ioctl execution
+  * path which will wait for an event to occur that is outside the scope of
+  * the ioctl (i.e. an adapter reset). To drain the ioctls currently running,
+  * a thread simply needs to acquire the write semaphore.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static long cxlflash_chr_ioctl(struct file *file, unsigned int cmd,
+ 			       unsigned long arg)
+ {
+ 	typedef int (*hioctl) (struct cxlflash_cfg *, void *);
+ 
+ 	struct cxlflash_cfg *cfg = file->private_data;
+ 	struct device *dev = &cfg->dev->dev;
+ 	char buf[sizeof(union cxlflash_ht_ioctls)];
+ 	void __user *uarg = (void __user *)arg;
+ 	struct ht_cxlflash_hdr *hdr;
+ 	size_t size = 0;
+ 	bool known_ioctl = false;
+ 	int idx = 0;
+ 	int rc = 0;
+ 	hioctl do_ioctl = NULL;
+ 
+ 	static const struct {
+ 		size_t size;
+ 		hioctl ioctl;
+ 	} ioctl_tbl[] = {	/* NOTE: order matters here */
+ 	{ sizeof(struct ht_cxlflash_lun_provision),
+ 		(hioctl)cxlflash_lun_provision },
+ 	{ sizeof(struct ht_cxlflash_afu_debug),
+ 		(hioctl)cxlflash_afu_debug },
+ 	};
+ 
+ 	/* Hold read semaphore so we can drain if needed */
+ 	down_read(&cfg->ioctl_rwsem);
+ 
+ 	dev_dbg(dev, "%s: cmd=%u idx=%d tbl_size=%lu\n",
+ 		__func__, cmd, idx, sizeof(ioctl_tbl));
+ 
+ 	switch (cmd) {
+ 	case HT_CXLFLASH_LUN_PROVISION:
+ 	case HT_CXLFLASH_AFU_DEBUG:
+ 		known_ioctl = true;
+ 		idx = _IOC_NR(HT_CXLFLASH_LUN_PROVISION) - _IOC_NR(cmd);
+ 		size = ioctl_tbl[idx].size;
+ 		do_ioctl = ioctl_tbl[idx].ioctl;
+ 
+ 		if (likely(do_ioctl))
+ 			break;
+ 
+ 		/* fall through */
+ 	default:
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (unlikely(copy_from_user(&buf, uarg, size))) {
+ 		dev_err(dev, "%s: copy_from_user() fail "
+ 			"size=%lu cmd=%d (%s) uarg=%p\n",
+ 			__func__, size, cmd, decode_hioctl(cmd), uarg);
+ 		rc = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	hdr = (struct ht_cxlflash_hdr *)&buf;
+ 	if (hdr->version != HT_CXLFLASH_VERSION_0) {
+ 		dev_dbg(dev, "%s: Version %u not supported for %s\n",
+ 			__func__, hdr->version, decode_hioctl(cmd));
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (hdr->rsvd[0] || hdr->rsvd[1] || hdr->return_flags) {
+ 		dev_dbg(dev, "%s: Reserved/rflags populated\n", __func__);
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	rc = do_ioctl(cfg, (void *)&buf);
+ 	if (likely(!rc))
+ 		if (unlikely(copy_to_user(uarg, &buf, size))) {
+ 			dev_err(dev, "%s: copy_to_user() fail "
+ 				"size=%lu cmd=%d (%s) uarg=%p\n",
+ 				__func__, size, cmd, decode_hioctl(cmd), uarg);
+ 			rc = -EFAULT;
+ 		}
+ 
+ 	/* fall through to exit */
+ 
+ out:
+ 	up_read(&cfg->ioctl_rwsem);
+ 	if (unlikely(rc && known_ioctl))
+ 		dev_err(dev, "%s: ioctl %s (%08X) returned rc=%d\n",
+ 			__func__, decode_hioctl(cmd), cmd, rc);
+ 	else
+ 		dev_dbg(dev, "%s: ioctl %s (%08X) returned rc=%d\n",
+ 			__func__, decode_hioctl(cmd), cmd, rc);
+ 	return rc;
+ }
+ 
+ /*
+  * Character device file operations
+  */
+ static const struct file_operations cxlflash_chr_fops = {
+ 	.owner          = THIS_MODULE,
+ 	.open           = cxlflash_chr_open,
+ 	.unlocked_ioctl	= cxlflash_chr_ioctl,
+ 	.compat_ioctl	= cxlflash_chr_ioctl,
+ };
+ 
+ /**
+  * init_chrdev() - initialize the character device for the host
+  * @cfg:	Internal structure associated with the host.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int init_chrdev(struct cxlflash_cfg *cfg)
+ {
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct device *char_dev;
+ 	dev_t devno;
+ 	int minor;
+ 	int rc = 0;
+ 
+ 	minor = cxlflash_get_minor();
+ 	if (unlikely(minor < 0)) {
+ 		dev_err(dev, "%s: Exhausted allowed adapters\n", __func__);
+ 		rc = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	devno = MKDEV(cxlflash_major, minor);
+ 	cdev_init(&cfg->cdev, &cxlflash_chr_fops);
+ 
+ 	rc = cdev_add(&cfg->cdev, devno, 1);
+ 	if (rc) {
+ 		dev_err(dev, "%s: cdev_add failed rc=%d\n", __func__, rc);
+ 		goto err1;
+ 	}
+ 
+ 	char_dev = device_create(cxlflash_class, NULL, devno,
+ 				 NULL, "cxlflash%d", minor);
+ 	if (IS_ERR(char_dev)) {
+ 		rc = PTR_ERR(char_dev);
+ 		dev_err(dev, "%s: device_create failed rc=%d\n",
+ 			__func__, rc);
+ 		goto err2;
+ 	}
+ 
+ 	cfg->chardev = char_dev;
+ out:
+ 	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
+ 	return rc;
+ err2:
+ 	cdev_del(&cfg->cdev);
+ err1:
+ 	cxlflash_put_minor(minor);
+ 	goto out;
+ }
+ 
+ /**
++>>>>>>> eeac8cda2c95 (scsi: cxlflash: return -EFAULT if copy_from_user() fails)
   * cxlflash_probe() - PCI entry point to add host
   * @pdev:	PCI device associated with the host.
   * @dev_id:	PCI device id associated with device.
* Unmerged path drivers/scsi/cxlflash/main.c
