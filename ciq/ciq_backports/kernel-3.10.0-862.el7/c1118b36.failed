x86: kvm: use alternatives for VMCALL vs. VMMCALL if kernel text is read-only

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit c1118b3602c2329671ad5ec8bdf8e374323d6343
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c1118b36.failed

On x86_64, kernel text mappings are mapped read-only with CONFIG_DEBUG_RODATA.
In that case, KVM will fail to patch VMCALL instructions to VMMCALL
as required on AMD processors.

The failure mode is currently a divide-by-zero exception, which obviously
is a KVM bug that has to be fixed.  However, picking the right instruction
between VMCALL and VMMCALL will be faster and will help if you cannot upgrade
the hypervisor.

	Reported-by: Chris Webb <chris@arachsys.com>
	Tested-by: Chris Webb <chris@arachsys.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: x86@kernel.org
	Acked-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c1118b3602c2329671ad5ec8bdf8e374323d6343)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpufeature.h
#	arch/x86/kernel/cpu/amd.c
diff --cc arch/x86/include/asm/cpufeature.h
index 8255ae846f9c,2075e6c34c78..000000000000
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@@ -180,34 -174,35 +180,53 @@@
  
  /*
   * Auxiliary flags: Linux defined - For features scattered in various
 - * CPUID levels like 0x6, 0xA etc, word 7
 + * CPUID levels like 0x6, 0xA etc, word 7.
 + *
 + * Reuse free bits when adding new feature flags!
   */
 -#define X86_FEATURE_IDA		( 7*32+ 0) /* Intel Dynamic Acceleration */
 -#define X86_FEATURE_ARAT	( 7*32+ 1) /* Always Running APIC Timer */
 -#define X86_FEATURE_CPB		( 7*32+ 2) /* AMD Core Performance Boost */
 -#define X86_FEATURE_EPB		( 7*32+ 3) /* IA32_ENERGY_PERF_BIAS support */
 -#define X86_FEATURE_PLN		( 7*32+ 5) /* Intel Power Limit Notification */
 -#define X86_FEATURE_PTS		( 7*32+ 6) /* Intel Package Thermal Status */
 -#define X86_FEATURE_DTHERM	( 7*32+ 7) /* Digital Thermal Sensor */
 -#define X86_FEATURE_HW_PSTATE	( 7*32+ 8) /* AMD HW-PState */
 -#define X86_FEATURE_PROC_FEEDBACK ( 7*32+ 9) /* AMD ProcFeedbackInterface */
 +
 +#define X86_FEATURE_RING3MWAIT	(7*32+ 0) /* Ring 3 MONITOR/MWAIT */
 +#define X86_FEATURE_CPB		(7*32+ 2) /* AMD Core Performance Boost */
 +#define X86_FEATURE_EPB		(7*32+ 3) /* IA32_ENERGY_PERF_BIAS support */
 +#define X86_FEATURE_CAT_L3	(7*32+ 4) /* Cache Allocation Technology L3 */
 +#define X86_FEATURE_CAT_L2	(7*32+ 5) /* Cache Allocation Technology L2 */
 +#define X86_FEATURE_CDP_L3	(7*32+ 6) /* Code and Data Prioritization L3 */
 +
 +#define X86_FEATURE_HW_PSTATE	(7*32+ 8) /* AMD HW-PState */
 +#define X86_FEATURE_PROC_FEEDBACK (7*32+ 9) /* AMD ProcFeedbackInterface */
 +
 +#define X86_FEATURE_INTEL_PT	( 7*32+15) /* Intel Processor Trace */
 +#define X86_FEATURE_AVX512_4VNNIW (7*32+16) /* AVX-512 Neural Network Instructions */
 +#define X86_FEATURE_AVX512_4FMAPS (7*32+17) /* AVX-512 Multiply Accumulation Single precision */
 +#define X86_FEATURE_AVX512_VPOPCNTDQ (16*32+14) /* POPCNT for vectors of DW/QW */
  
  /* Virtualization flags: Linux defined, word 8 */
++<<<<<<< HEAD
 +#define X86_FEATURE_TPR_SHADOW  (8*32+ 0) /* Intel TPR Shadow */
 +#define X86_FEATURE_VNMI        (8*32+ 1) /* Intel Virtual NMI */
 +#define X86_FEATURE_FLEXPRIORITY (8*32+ 2) /* Intel FlexPriority */
 +#define X86_FEATURE_EPT         (8*32+ 3) /* Intel Extended Page Table */
 +#define X86_FEATURE_VPID        (8*32+ 4) /* Intel Virtual Processor ID */
 +
 +#define X86_FEATURE_AVIC	(8*32+15) /* AMD Virtual Interrupt Controller */
++=======
+ #define X86_FEATURE_TPR_SHADOW  ( 8*32+ 0) /* Intel TPR Shadow */
+ #define X86_FEATURE_VNMI        ( 8*32+ 1) /* Intel Virtual NMI */
+ #define X86_FEATURE_FLEXPRIORITY ( 8*32+ 2) /* Intel FlexPriority */
+ #define X86_FEATURE_EPT         ( 8*32+ 3) /* Intel Extended Page Table */
+ #define X86_FEATURE_VPID        ( 8*32+ 4) /* Intel Virtual Processor ID */
+ #define X86_FEATURE_NPT		( 8*32+ 5) /* AMD Nested Page Table support */
+ #define X86_FEATURE_LBRV	( 8*32+ 6) /* AMD LBR Virtualization support */
+ #define X86_FEATURE_SVML	( 8*32+ 7) /* "svm_lock" AMD SVM locking MSR */
+ #define X86_FEATURE_NRIPS	( 8*32+ 8) /* "nrip_save" AMD SVM next_rip save */
+ #define X86_FEATURE_TSCRATEMSR  ( 8*32+ 9) /* "tsc_scale" AMD TSC scaling support */
+ #define X86_FEATURE_VMCBCLEAN   ( 8*32+10) /* "vmcb_clean" AMD VMCB clean bits support */
+ #define X86_FEATURE_FLUSHBYASID ( 8*32+11) /* AMD flush-by-ASID support */
+ #define X86_FEATURE_DECODEASSISTS ( 8*32+12) /* AMD Decode Assists support */
+ #define X86_FEATURE_PAUSEFILTER ( 8*32+13) /* AMD filtered pause intercept */
+ #define X86_FEATURE_PFTHRESHOLD ( 8*32+14) /* AMD pause filter threshold */
+ #define X86_FEATURE_VMMCALL     ( 8*32+15) /* Prefer vmmcall to vmcall */
++>>>>>>> c1118b3602c2 (x86: kvm: use alternatives for VMCALL vs. VMMCALL if kernel text is read-only)
  
  
  /* Intel-defined CPU features, CPUID level 0x00000007:0 (ebx), word 9 */
diff --cc arch/x86/kernel/cpu/amd.c
index 485733876ab9,813d29d00a17..000000000000
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@@ -555,6 -524,17 +555,20 @@@ static void early_init_amd(struct cpuin
  			set_cpu_cap(c, X86_FEATURE_EXTD_APICID);
  	}
  #endif
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * This is only needed to tell the kernel whether to use VMCALL
+ 	 * and VMMCALL.  VMMCALL is never executed except under virt, so
+ 	 * we can set it unconditionally.
+ 	 */
+ 	set_cpu_cap(c, X86_FEATURE_VMMCALL);
+ 
+ 	/* F16h erratum 793, CVE-2013-6885 */
+ 	if (c->x86 == 0x16 && c->x86_model <= 0xf)
+ 		msr_set_bit(MSR_AMD64_LS_CFG, 15);
++>>>>>>> c1118b3602c2 (x86: kvm: use alternatives for VMCALL vs. VMMCALL if kernel text is read-only)
  }
  
  static const int amd_erratum_383[];
* Unmerged path arch/x86/include/asm/cpufeature.h
diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h
index 458fb6602a9f..c1adf33fdd0d 100644
--- a/arch/x86/include/asm/kvm_para.h
+++ b/arch/x86/include/asm/kvm_para.h
@@ -2,6 +2,7 @@
 #define _ASM_X86_KVM_PARA_H
 
 #include <asm/processor.h>
+#include <asm/alternative.h>
 #include <uapi/asm/kvm_para.h>
 
 extern void kvmclock_init(void);
@@ -16,10 +17,15 @@ static inline bool kvm_check_and_clear_guest_paused(void)
 }
 #endif /* CONFIG_KVM_GUEST */
 
-/* This instruction is vmcall.  On non-VT architectures, it will generate a
- * trap that we will then rewrite to the appropriate instruction.
+#ifdef CONFIG_DEBUG_RODATA
+#define KVM_HYPERCALL \
+        ALTERNATIVE(".byte 0x0f,0x01,0xc1", ".byte 0x0f,0x01,0xd9", X86_FEATURE_VMMCALL)
+#else
+/* On AMD processors, vmcall will generate a trap that we will
+ * then rewrite to the appropriate instruction.
  */
 #define KVM_HYPERCALL ".byte 0x0f,0x01,0xc1"
+#endif
 
 /* For KVM hypercalls, a three-byte sequence of either the vmcall or the vmmcall
  * instruction.  The hypervisor may replace it with something else but only the
* Unmerged path arch/x86/kernel/cpu/amd.c
