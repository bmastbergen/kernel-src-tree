ext4: factor out checks from ext4_file_write_iter()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 213bcd9ccbf04b709e4764ad89aaaa66a47785f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/213bcd9c.failed

Factor out checks of 'from' and whether we are overwriting out of
ext4_file_write_iter() so that the function is easier to follow.

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 213bcd9ccbf04b709e4764ad89aaaa66a47785f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/file.c
diff --cc fs/ext4/file.c
index db1bf9992414,9facb4dc5c70..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -92,112 -88,93 +92,172 @@@ ext4_unaligned_aio(struct inode *inode
  	return 0;
  }
  
+ /* Is IO overwriting allocated and initialized blocks? */
+ static bool ext4_overwrite_io(struct inode *inode, loff_t pos, loff_t len)
+ {
+ 	struct ext4_map_blocks map;
+ 	unsigned int blkbits = inode->i_blkbits;
+ 	int err, blklen;
+ 
+ 	if (pos + len > i_size_read(inode))
+ 		return false;
+ 
+ 	map.m_lblk = pos >> blkbits;
+ 	map.m_len = EXT4_MAX_BLOCKS(len, pos, blkbits);
+ 	blklen = map.m_len;
+ 
+ 	err = ext4_map_blocks(NULL, inode, &map, 0);
+ 	/*
+ 	 * 'err==len' means that all of the blocks have been preallocated,
+ 	 * regardless of whether they have been initialized or not. To exclude
+ 	 * unwritten extents, we need to check m_flags.
+ 	 */
+ 	return err == blklen && (map.m_flags & EXT4_MAP_MAPPED);
+ }
+ 
+ static ssize_t ext4_write_checks(struct kiocb *iocb, struct iov_iter *from)
+ {
+ 	struct inode *inode = file_inode(iocb->ki_filp);
+ 	ssize_t ret;
+ 
+ 	ret = generic_write_checks(iocb, from);
+ 	if (ret <= 0)
+ 		return ret;
+ 	/*
+ 	 * If we have encountered a bitmap-format file, the size limit
+ 	 * is smaller than s_maxbytes, which is for extent-mapped files.
+ 	 */
+ 	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
+ 		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
+ 
+ 		if (iocb->ki_pos >= sbi->s_bitmap_maxbytes)
+ 			return -EFBIG;
+ 		iov_iter_truncate(from, sbi->s_bitmap_maxbytes - iocb->ki_pos);
+ 	}
+ 	return iov_iter_count(from);
+ }
+ 
  static ssize_t
 -ext4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 +ext4_file_dio_write(struct kiocb *iocb, const struct iovec *iov,
 +		    unsigned long nr_segs, loff_t pos)
  {
 -	struct inode *inode = file_inode(iocb->ki_filp);
 -	int o_direct = iocb->ki_flags & IOCB_DIRECT;
 +	struct file *file = iocb->ki_filp;
 +	struct inode *inode = file->f_mapping->host;
 +	struct blk_plug plug;
  	int unaligned_aio = 0;
 -	int overwrite = 0;
  	ssize_t ret;
 +	int overwrite = 0;
 +	size_t length = iov_length(iov, nr_segs);
  
++<<<<<<< HEAD
 +	if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&
 +	    !is_sync_kiocb(iocb))
 +		unaligned_aio = ext4_unaligned_aio(inode, iov, nr_segs, pos);
++=======
+ 	inode_lock(inode);
+ 	ret = ext4_write_checks(iocb, from);
+ 	if (ret <= 0)
+ 		goto out;
++>>>>>>> 213bcd9ccbf0 (ext4: factor out checks from ext4_file_write_iter())
  
 -	/*
 -	 * Unaligned direct AIO must be serialized among each other as zeroing
 -	 * of partial blocks of two competing unaligned AIOs can result in data
 -	 * corruption.
 -	 */
 -	if (o_direct && ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&
 -	    !is_sync_kiocb(iocb) &&
 -	    ext4_unaligned_aio(inode, from, iocb->ki_pos)) {
 -		unaligned_aio = 1;
 +	/* Unaligned direct AIO must be serialized; see comment above */
 +	if (unaligned_aio) {
 +		mutex_lock(ext4_aio_mutex(inode));
  		ext4_unwritten_wait(inode);
  	}
  
++<<<<<<< HEAD
 +	BUG_ON(iocb->ki_pos != pos);
 +
 +	mutex_lock(&inode->i_mutex);
 +	blk_start_plug(&plug);
 +
 +	iocb->private = &overwrite;
 +
 +	/* check whether we do a DIO overwrite or not */
 +	if (ext4_should_dioread_nolock(inode) && !unaligned_aio &&
 +	    !file->f_mapping->nrpages && pos + length <= i_size_read(inode)) {
 +		struct ext4_map_blocks map;
 +		unsigned int blkbits = inode->i_blkbits;
 +		int err, len;
 +
 +		map.m_lblk = pos >> blkbits;
 +		map.m_len = (EXT4_BLOCK_ALIGN(pos + length, blkbits) >> blkbits)
 +			- map.m_lblk;
 +		len = map.m_len;
 +
 +		err = ext4_map_blocks(NULL, inode, &map, 0);
 +		/*
 +		 * 'err==len' means that all of blocks has been preallocated no
 +		 * matter they are initialized or not.  For excluding
 +		 * unwritten extents, we need to check m_flags.  There are
 +		 * two conditions that indicate for initialized extents.
 +		 * 1) If we hit extent cache, EXT4_MAP_MAPPED flag is returned;
 +		 * 2) If we do a real lookup, non-flags are returned.
 +		 * So we should check these two conditions.
 +		 */
 +		if (err == len && (map.m_flags & EXT4_MAP_MAPPED))
 +			overwrite = 1;
 +	}
 +
 +	ret = __generic_file_aio_write(iocb, iov, nr_segs, &iocb->ki_pos);
 +	mutex_unlock(&inode->i_mutex);
 +
 +	if (ret > 0) {
 +		ssize_t err;
 +
 +		err = generic_write_sync(file, pos, ret);
 +		if (err < 0 && ret > 0)
 +			ret = err;
 +	}
 +	blk_finish_plug(&plug);
 +
 +	if (unaligned_aio)
 +		mutex_unlock(ext4_aio_mutex(inode));
 +
 +	return ret;
 +}
 +
 +static ssize_t
 +ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 +		unsigned long nr_segs, loff_t pos)
 +{
 +	struct inode *inode = file_inode(iocb->ki_filp);
 +	ssize_t ret;
 +	int overwrite = 0;
 +
 +	/*
 +	 * If we have encountered a bitmap-format file, the size limit
 +	 * is smaller than s_maxbytes, which is for extent-mapped files.
 +	 */
 +
 +	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
 +		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
 +		size_t length = iov_length(iov, nr_segs);
 +
 +		if ((pos > sbi->s_bitmap_maxbytes ||
 +		    (pos == sbi->s_bitmap_maxbytes && length > 0)))
 +			return -EFBIG;
 +
 +		if (pos + length > sbi->s_bitmap_maxbytes) {
 +			nr_segs = iov_shorten((struct iovec *)iov, nr_segs,
 +					      sbi->s_bitmap_maxbytes - pos);
 +		}
 +	}
++=======
+ 	iocb->private = &overwrite;
+ 	/* Check whether we do a DIO overwrite or not */
+ 	if (o_direct && ext4_should_dioread_nolock(inode) && !unaligned_aio &&
+ 	    ext4_overwrite_io(inode, iocb->ki_pos, iov_iter_count(from)))
+ 		overwrite = 1;
++>>>>>>> 213bcd9ccbf0 (ext4: factor out checks from ext4_file_write_iter())
  
 -	ret = __generic_file_write_iter(iocb, from);
 -	inode_unlock(inode);
 -
 -	if (ret > 0)
 -		ret = generic_write_sync(iocb, ret);
 -
 -	return ret;
 +	iocb->private = &overwrite; /* RHEL7 only - prevent DIO race */
 +	if (unlikely(io_is_direct(iocb->ki_filp)))
 +		ret = ext4_file_dio_write(iocb, iov, nr_segs, pos);
 +	else
 +		ret = generic_file_aio_write(iocb, iov, nr_segs, pos);
  
 -out:
 -	inode_unlock(inode);
  	return ret;
  }
  
* Unmerged path fs/ext4/file.c
