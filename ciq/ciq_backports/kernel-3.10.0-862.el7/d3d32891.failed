scsi_dh: add 'rescan' callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit d3d328919f278eda489a482541583f79987ad0e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d3d32891.failed

If a device needs to be rescanned the device_handler might need
to be rechecked, too.
So add a 'rescan' callback to the device handler and call it
upon scsi_rescan_device(). The rescan callback will be invoked
from the Unit Attention handling of ASC/ASCQ 3F 03
(INQUIRY DATA HAS CHANGED).

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d3d328919f278eda489a482541583f79987ad0e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
#	drivers/scsi/scsi_scan.c
#	include/scsi/scsi_dh.h
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,3d994aac2b85..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -658,26 -1026,13 +658,42 @@@ static int alua_prep_fn(struct scsi_dev
  
  }
  
++<<<<<<< HEAD
 +static bool alua_match(struct scsi_device *sdev)
++=======
+ static void alua_rescan(struct scsi_device *sdev)
+ {
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 
+ 	alua_initialize(sdev, h);
+ }
+ 
++/*
++ * alua_bus_attach - Attach device handler
++ * @sdev: device to be attached to
++ */
++static int alua_bus_attach(struct scsi_device *sdev)
++>>>>>>> d3d328919f27 (scsi_dh: add 'rescan' callback)
 +{
 +	return (scsi_device_tpgs(sdev) != 0);
 +}
 +
 +static int alua_bus_attach(struct scsi_device *sdev);
 +static void alua_bus_detach(struct scsi_device *sdev);
 +
 +static struct scsi_device_handler alua_dh = {
 +	.name = ALUA_DH_NAME,
 +	.module = THIS_MODULE,
 +	.attach = alua_bus_attach,
 +	.detach = alua_bus_detach,
 +	.prep_fn = alua_prep_fn,
 +	.check_sense = alua_check_sense,
 +	.activate = alua_activate,
++	.rescan = alua_rescan,
 +	.set_params = alua_set_params,
 +	.match = alua_match,
 +};
 +
  /*
   * alua_bus_attach - Attach device handler
   * @sdev: device to be attached to
diff --cc drivers/scsi/scsi_scan.c
index 9d2bb350e527,97074c91e328..000000000000
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@@ -1627,19 -1525,21 +1628,27 @@@ EXPORT_SYMBOL(scsi_add_device)
  
  void scsi_rescan_device(struct device *dev)
  {
++<<<<<<< HEAD
 +	struct scsi_driver *drv;
 +	
++=======
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 
++>>>>>>> d3d328919f27 (scsi_dh: add 'rescan' callback)
  	device_lock(dev);
  
- 	scsi_attach_vpd(to_scsi_device(dev));
+ 	scsi_attach_vpd(sdev);
+ 
+ 	if (sdev->handler && sdev->handler->rescan)
+ 		sdev->handler->rescan(sdev);
  
 -	if (dev->driver && try_module_get(dev->driver->owner)) {
 -		struct scsi_driver *drv = to_scsi_driver(dev->driver);
 -
 -		if (drv->rescan)
 -			drv->rescan(dev);
 -		module_put(dev->driver->owner);
 +	if (dev->driver) {
 +		drv = to_scsi_driver(dev->driver);
 +		if (try_module_get(drv->owner)) {
 +			if (drv->rescan)
 +				drv->rescan(dev);
 +			module_put(drv->owner);
 +		}
  	}
  	device_unlock(dev);
  }
diff --cc include/scsi/scsi_dh.h
index 620c723ee8ed,c7bba2b24849..000000000000
--- a/include/scsi/scsi_dh.h
+++ b/include/scsi/scsi_dh.h
@@@ -55,11 -55,28 +55,33 @@@ enum 
  	SCSI_DH_NOSYS,
  	SCSI_DH_DRIVER_MAX,
  };
++<<<<<<< HEAD
 +#if defined(CONFIG_SCSI_DH) || defined(CONFIG_SCSI_DH_MODULE)
++=======
+ 
+ typedef void (*activate_complete)(void *, int);
+ struct scsi_device_handler {
+ 	/* Used by the infrastructure */
+ 	struct list_head list; /* list of scsi_device_handlers */
+ 
+ 	/* Filled by the hardware handler */
+ 	struct module *module;
+ 	const char *name;
+ 	int (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
+ 	int (*attach)(struct scsi_device *);
+ 	void (*detach)(struct scsi_device *);
+ 	int (*activate)(struct scsi_device *, activate_complete, void *);
+ 	int (*prep_fn)(struct scsi_device *, struct request *);
+ 	int (*set_params)(struct scsi_device *, const char *);
+ 	void (*rescan)(struct scsi_device *);
+ };
+ 
+ #ifdef CONFIG_SCSI_DH
++>>>>>>> d3d328919f27 (scsi_dh: add 'rescan' callback)
  extern int scsi_dh_activate(struct request_queue *, activate_complete, void *);
 +extern int scsi_dh_handler_exist(const char *);
  extern int scsi_dh_attach(struct request_queue *, const char *);
 +extern void scsi_dh_detach(struct request_queue *);
  extern const char *scsi_dh_attached_handler_name(struct request_queue *, gfp_t);
  extern int scsi_dh_set_params(struct request_queue *, const char *);
  #else
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 09ae8ec23494..68be6efffd72 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2498,6 +2498,7 @@ static void scsi_evt_emit(struct scsi_device *sdev, struct scsi_event *evt)
 		envp[idx++] = "SDEV_MEDIA_CHANGE=1";
 		break;
 	case SDEV_EVT_INQUIRY_CHANGE_REPORTED:
+		scsi_rescan_device(&sdev->sdev_gendev);
 		envp[idx++] = "SDEV_UA=INQUIRY_DATA_HAS_CHANGED";
 		break;
 	case SDEV_EVT_CAPACITY_CHANGE_REPORTED:
* Unmerged path drivers/scsi/scsi_scan.c
* Unmerged path include/scsi/scsi_dh.h
