drm/i915: avoid division by zero on cnl_calc_wrpll_link

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paulo Zanoni <paulo.r.zanoni@intel.com>
commit 0e005888b833ba65dcf2c7aa12958dad6b2b8618
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0e005888.failed

If for some unexpected reason the registers all read zero it's better
to WARN and return instead of dividing by zero and completely freezing
the machine.

I don't expect this to happen in the wild with the current code, but I
accidentally triggered the division by zero while doing some debugging
in an unusual environment.

	Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
	Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20171005213842.11423-2-paulo.r.zanoni@intel.com
(cherry picked from commit 0e005888b833ba65dcf2c7aa12958dad6b2b8618)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index d42007e133bd,b307b6fe1ce3..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -929,6 -1167,65 +929,68 @@@ static int skl_calc_wrpll_link(struct d
  	return dco_freq / (p0 * p1 * p2 * 5);
  }
  
++<<<<<<< HEAD
++=======
+ static int cnl_calc_wrpll_link(struct drm_i915_private *dev_priv,
+ 			       uint32_t pll_id)
+ {
+ 	uint32_t cfgcr0, cfgcr1;
+ 	uint32_t p0, p1, p2, dco_freq, ref_clock;
+ 
+ 	cfgcr0 = I915_READ(CNL_DPLL_CFGCR0(pll_id));
+ 	cfgcr1 = I915_READ(CNL_DPLL_CFGCR1(pll_id));
+ 
+ 	p0 = cfgcr1 & DPLL_CFGCR1_PDIV_MASK;
+ 	p2 = cfgcr1 & DPLL_CFGCR1_KDIV_MASK;
+ 
+ 	if (cfgcr1 & DPLL_CFGCR1_QDIV_MODE(1))
+ 		p1 = (cfgcr1 & DPLL_CFGCR1_QDIV_RATIO_MASK) >>
+ 			DPLL_CFGCR1_QDIV_RATIO_SHIFT;
+ 	else
+ 		p1 = 1;
+ 
+ 
+ 	switch (p0) {
+ 	case DPLL_CFGCR1_PDIV_2:
+ 		p0 = 2;
+ 		break;
+ 	case DPLL_CFGCR1_PDIV_3:
+ 		p0 = 3;
+ 		break;
+ 	case DPLL_CFGCR1_PDIV_5:
+ 		p0 = 5;
+ 		break;
+ 	case DPLL_CFGCR1_PDIV_7:
+ 		p0 = 7;
+ 		break;
+ 	}
+ 
+ 	switch (p2) {
+ 	case DPLL_CFGCR1_KDIV_1:
+ 		p2 = 1;
+ 		break;
+ 	case DPLL_CFGCR1_KDIV_2:
+ 		p2 = 2;
+ 		break;
+ 	case DPLL_CFGCR1_KDIV_4:
+ 		p2 = 4;
+ 		break;
+ 	}
+ 
+ 	ref_clock = dev_priv->cdclk.hw.ref;
+ 
+ 	dco_freq = (cfgcr0 & DPLL_CFGCR0_DCO_INTEGER_MASK) * ref_clock;
+ 
+ 	dco_freq += (((cfgcr0 & DPLL_CFGCR0_DCO_FRACTION_MASK) >>
+ 		      DPLL_CFGCR0_DCO_FRACTION_SHIFT) * ref_clock) / 0x8000;
+ 
+ 	if (WARN_ON(p0 == 0 || p1 == 0 || p2 == 0))
+ 		return 0;
+ 
+ 	return dco_freq / (p0 * p1 * p2 * 5);
+ }
+ 
++>>>>>>> 0e005888b833 (drm/i915: avoid division by zero on cnl_calc_wrpll_link)
  static void ddi_dotclock_get(struct intel_crtc_state *pipe_config)
  {
  	int dotclock;
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
