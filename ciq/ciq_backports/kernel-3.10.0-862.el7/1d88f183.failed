ovl: fix xattr get and set with selinux

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 1d88f183734c0d916428911df006e645a6162cab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1d88f183.failed

inode_doinit_with_dentry() in SELinux wants to read the upper inode's xattr
to get security label, and ovl_xattr_get() calls ovl_dentry_real(), which
depends on dentry->d_inode, but d_inode is null and not initialized yet at
this point resulting in an Oops.

Fix by getting the upperdentry info from the inode directly in this case.

	Reported-by: Eryu Guan <eguan@redhat.com>
Fixes: 09d8b586731b ("ovl: move __upperdentry to ovl_inode")
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 1d88f183734c0d916428911df006e645a6162cab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,e927a62c97ae..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -200,56 +151,34 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
++<<<<<<< HEAD
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
++=======
+ struct dentry *ovl_i_dentry_upper(struct inode *inode);
+ struct inode *ovl_inode_upper(struct inode *inode);
+ struct inode *ovl_inode_lower(struct inode *inode);
+ struct inode *ovl_inode_real(struct inode *inode);
++>>>>>>> 1d88f183734c (ovl: fix xattr get and set with selinux)
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
 +bool ovl_lower_positive(struct dentry *dentry);
  bool ovl_dentry_is_whiteout(struct dentry *dentry);
 -void ovl_dentry_set_opaque(struct dentry *dentry);
 -bool ovl_dentry_has_upper_alias(struct dentry *dentry);
 -void ovl_dentry_set_upper_alias(struct dentry *dentry);
 -bool ovl_redirect_dir(struct super_block *sb);
 -const char *ovl_dentry_get_redirect(struct dentry *dentry);
 -void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 -void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
 -		    struct dentry *lowerdentry);
 -void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
 -void ovl_dentry_version_inc(struct dentry *dentry);
 -u64 ovl_dentry_version_get(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
  bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
  struct file *ovl_path_open(struct path *path, int flags);
 -int ovl_copy_up_start(struct dentry *dentry);
 -void ovl_copy_up_end(struct dentry *dentry);
 -bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
 -int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
 -		       const char *name, const void *value, size_t size,
 -		       int xerr);
 -int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
 -void ovl_set_flag(unsigned long flag, struct inode *inode);
 -bool ovl_test_flag(unsigned long flag, struct inode *inode);
 -bool ovl_inuse_trylock(struct dentry *dentry);
 -void ovl_inuse_unlock(struct dentry *dentry);
 -int ovl_nlink_start(struct dentry *dentry, bool *locked);
 -void ovl_nlink_end(struct dentry *dentry, bool locked);
 -
 -static inline bool ovl_is_impuredir(struct dentry *dentry)
 -{
 -	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
 -}
  
 -
 -/* namei.c */
 -int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 -		      struct dentry *origin, bool is_upper, bool set);
 -int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 -		     unsigned int numlower);
 -int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 -int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
 -bool ovl_lower_positive(struct dentry *dentry);
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
@@@ -181,13 -259,22 +188,13 @@@ void ovl_cache_free(struct list_head *l
  int ovl_check_d_type_supported(struct path *realpath);
  void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
  			 struct dentry *dentry, int level);
 -int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 -			 struct path *lowerstack, unsigned int numlower);
  
  /* inode.c */
 -int ovl_set_nlink_upper(struct dentry *dentry);
 -int ovl_set_nlink_lower(struct dentry *dentry);
 -unsigned int ovl_get_nlink(struct dentry *lowerdentry,
 -			   struct dentry *upperdentry,
 -			   unsigned int fallback);
  int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 -int ovl_getattr(const struct path *path, struct kstat *stat,
 -		u32 request_mask, unsigned int flags);
  int ovl_permission(struct inode *inode, int mask);
- int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
- 		  size_t size, int flags);
- int ovl_xattr_get(struct dentry *dentry, const char *name,
+ int ovl_xattr_set(struct dentry *dentry, struct inode *inode, const char *name,
+ 		  const void *value, size_t size, int flags);
+ int ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,
  		  void *value, size_t size);
  ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
  struct posix_acl *ovl_get_acl(struct inode *inode, int type);
diff --cc fs/overlayfs/super.c
index 311aedaffa1b,d86e89f97201..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -1110,12 -688,11 +1110,16 @@@ static unsigned int ovl_split_lowerdirs
  }
  
  static int __maybe_unused
 -ovl_posix_acl_xattr_get(const struct xattr_handler *handler,
 -			struct dentry *dentry, struct inode *inode,
 -			const char *name, void *buffer, size_t size)
 +ovl_posix_acl_xattr_get(struct dentry *dentry,
 +			const char *name, void *buffer, size_t size,
 +			int handler_flags)
  {
++<<<<<<< HEAD
 +	return ovl_xattr_get(dentry, handler_flags == ACL_TYPE_DEFAULT ? XATTR_NAME_POSIX_ACL_DEFAULT : XATTR_NAME_POSIX_ACL_ACCESS,
 +			     buffer, size);
++=======
+ 	return ovl_xattr_get(dentry, inode, handler->name, buffer, size);
++>>>>>>> 1d88f183734c (ovl: fix xattr get and set with selinux)
  }
  
  static int __maybe_unused
@@@ -1162,10 -742,9 +1166,14 @@@ ovl_posix_acl_xattr_set(struct dentry *
  			return err;
  	}
  
++<<<<<<< HEAD
 +	err = ovl_xattr_set(dentry, handler_flags == ACL_TYPE_DEFAULT ? XATTR_NAME_POSIX_ACL_DEFAULT : XATTR_NAME_POSIX_ACL_ACCESS,
 +			     value, size, flags);
++=======
+ 	err = ovl_xattr_set(dentry, inode, handler->name, value, size, flags);
++>>>>>>> 1d88f183734c (ovl: fix xattr get and set with selinux)
  	if (!err)
 -		ovl_copyattr(ovl_inode_real(inode), inode);
 +		ovl_copyattr(ovl_inode_real(inode, NULL), inode);
  
  	return err;
  
@@@ -1188,18 -768,19 +1196,18 @@@ static int ovl_own_xattr_set(struct den
  	return -EOPNOTSUPP;
  }
  
 -static int ovl_other_xattr_get(const struct xattr_handler *handler,
 -			       struct dentry *dentry, struct inode *inode,
 -			       const char *name, void *buffer, size_t size)
 +static int ovl_other_xattr_get(struct dentry *dentry,
 +			       const char *name, void *buffer, size_t size,
 +			       int handler_flags)
  {
- 	return ovl_xattr_get(dentry, name, buffer, size);
+ 	return ovl_xattr_get(dentry, inode, name, buffer, size);
  }
  
 -static int ovl_other_xattr_set(const struct xattr_handler *handler,
 -			       struct dentry *dentry, struct inode *inode,
 +static int ovl_other_xattr_set(struct dentry *dentry,
  			       const char *name, const void *value,
 -			       size_t size, int flags)
 +			       size_t size, int flags, int handler_flags)
  {
- 	return ovl_xattr_set(dentry, name, value, size, flags);
+ 	return ovl_xattr_set(dentry, inode, name, value, size, flags);
  }
  
  static const struct xattr_handler __maybe_unused
* Unmerged path fs/overlayfs/util.c
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index e60c6d748742..86e717836ac9 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -185,37 +185,38 @@ bool ovl_is_private_xattr(const char *name)
 		       sizeof(OVL_XATTR_PREFIX) - 1) == 0;
 }
 
-int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
-		  size_t size, int flags)
+int ovl_xattr_set(struct dentry *dentry, struct inode *inode, const char *name,
+		  const void *value, size_t size, int flags)
 {
 	int err;
-	struct path realpath;
-	enum ovl_path_type type = ovl_path_real(dentry, &realpath);
+	struct dentry *upperdentry = ovl_i_dentry_upper(inode);
+	struct dentry *realdentry = upperdentry ?: ovl_dentry_lower(dentry);
 	const struct cred *old_cred;
 
 	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
-	if (!value && !OVL_TYPE_UPPER(type)) {
-		err = vfs_getxattr(realpath.dentry, name, NULL, 0);
+	if (!value && !upperdentry) {
+		err = vfs_getxattr(realdentry, name, NULL, 0);
 		if (err < 0)
 			goto out_drop_write;
 	}
 
-	err = ovl_copy_up(dentry);
-	if (err)
-		goto out_drop_write;
+	if (!upperdentry) {
+		err = ovl_copy_up(dentry);
+		if (err)
+			goto out_drop_write;
 
-	if (!OVL_TYPE_UPPER(type))
-		ovl_path_upper(dentry, &realpath);
+		realdentry = ovl_dentry_upper(dentry);
+	}
 
 	old_cred = ovl_override_creds(dentry->d_sb);
 	if (value)
-		err = vfs_setxattr(realpath.dentry, name, value, size, flags);
+		err = vfs_setxattr(realdentry, name, value, size, flags);
 	else {
 		WARN_ON(flags != XATTR_REPLACE);
-		err = vfs_removexattr(realpath.dentry, name);
+		err = vfs_removexattr(realdentry, name);
 	}
 	revert_creds(old_cred);
 
@@ -225,12 +226,13 @@ out:
 	return err;
 }
 
-int ovl_xattr_get(struct dentry *dentry, const char *name,
+int ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,
 		  void *value, size_t size)
 {
-	struct dentry *realdentry = ovl_dentry_real(dentry);
 	ssize_t res;
 	const struct cred *old_cred;
+	struct dentry *realdentry =
+		ovl_i_dentry_upper(inode) ?: ovl_dentry_lower(dentry);
 
 	old_cred = ovl_override_creds(dentry->d_sb);
 	res = vfs_getxattr(realdentry, name, value, size);
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
* Unmerged path fs/overlayfs/util.c
