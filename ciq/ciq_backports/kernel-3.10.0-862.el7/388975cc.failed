sysfs: clean up sysfs_get_dirent()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 388975cccaaf11abd47525f664c76891c440481a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/388975cc.failed

The pre-existing sysfs interfaces which take explicit namespace
argument are weird in that they place the optional @ns in front of
@name which is contrary to the established convention.  For example,
we end up forcing vast majority of sysfs_get_dirent() users to do
sysfs_get_dirent(parent, NULL, name), which is silly and error-prone
especially as @ns and @name may be interchanged without causing
compilation warning.

This renames sysfs_get_dirent() to sysfs_get_dirent_ns() and swap the
positions of @name and @ns, and sysfs_get_dirent() is now a wrapper
around sysfs_get_dirent_ns().  This makes confusions a lot less
likely.

There are other interfaces which take @ns before @name.  They'll be
updated by following patches.

This patch doesn't introduce any functional changes.

v2: EXPORT_SYMBOL_GPL() wasn't updated leading to undefined symbol
    error on module builds.  Reported by build test robot.  Fixed.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Kay Sievers <kay@vrfy.org>
	Cc: Fengguang Wu <fengguang.wu@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 388975cccaaf11abd47525f664c76891c440481a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
#	include/linux/sysfs.h
diff --cc drivers/md/md.c
index 1b4eaa2bb332,8a0d7625681c..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -3599,23 -3546,25 +3599,43 @@@ level_store(struct mddev *mddev, const 
  
  	/* Looks like we have a winner */
  	mddev_suspend(mddev);
++<<<<<<< HEAD
 +	mddev_detach(mddev);
++=======
+ 	mddev->pers->stop(mddev);
+ 	
+ 	if (mddev->pers->sync_request == NULL &&
+ 	    pers->sync_request != NULL) {
+ 		/* need to add the md_redundancy_group */
+ 		if (sysfs_create_group(&mddev->kobj, &md_redundancy_group))
+ 			printk(KERN_WARNING
+ 			       "md: cannot register extra attributes for %s\n",
+ 			       mdname(mddev));
+ 		mddev->sysfs_action = sysfs_get_dirent(mddev->kobj.sd, "sync_action");
+ 	}		
+ 	if (mddev->pers->sync_request != NULL &&
+ 	    pers->sync_request == NULL) {
+ 		/* need to remove the md_redundancy_group */
+ 		if (mddev->to_remove == NULL)
+ 			mddev->to_remove = &md_redundancy_group;
+ 	}
++>>>>>>> 388975cccaaf (sysfs: clean up sysfs_get_dirent())
  
 -	if (mddev->pers->sync_request == NULL &&
 +	spin_lock(&mddev->lock);
 +	oldpers = mddev->pers;
 +	oldpriv = mddev->private;
 +	mddev->pers = pers;
 +	mddev->private = priv;
 +	strlcpy(mddev->clevel, pers->name, sizeof(mddev->clevel));
 +	mddev->level = mddev->new_level;
 +	mddev->layout = mddev->new_layout;
 +	mddev->chunk_sectors = mddev->new_chunk_sectors;
 +	mddev->delta_disks = 0;
 +	mddev->reshape_backwards = 0;
 +	mddev->degraded = 0;
 +	spin_unlock(&mddev->lock);
 +
 +	if (oldpers->sync_request == NULL &&
  	    mddev->external) {
  		/* We are converting from a no-redundancy array
  		 * to a redundancy array and metadata is managed
diff --cc include/linux/sysfs.h
index 85126b01a2f8,6695040a0317..000000000000
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@@ -446,4 -443,28 +445,31 @@@ static inline int __must_check sysfs_in
  
  #endif /* CONFIG_SYSFS */
  
++<<<<<<< HEAD
++=======
+ static inline int __must_check sysfs_create_file(struct kobject *kobj,
+ 						 const struct attribute *attr)
+ {
+ 	return sysfs_create_file_ns(kobj, attr, NULL);
+ }
+ 
+ static inline void sysfs_remove_file(struct kobject *kobj,
+ 				     const struct attribute *attr)
+ {
+ 	return sysfs_remove_file_ns(kobj, attr, NULL);
+ }
+ 
+ static inline int sysfs_rename_link(struct kobject *kobj, struct kobject *target,
+ 				    const char *old_name, const char *new_name)
+ {
+ 	return sysfs_rename_link_ns(kobj, target, old_name, new_name, NULL);
+ }
+ 
+ static inline struct sysfs_dirent *
+ sysfs_get_dirent(struct sysfs_dirent *parent_sd, const unsigned char *name)
+ {
+ 	return sysfs_get_dirent_ns(parent_sd, name, NULL);
+ }
+ 
++>>>>>>> 388975cccaaf (sysfs: clean up sysfs_get_dirent())
  #endif /* _SYSFS_H_ */
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 927a1d077837..17d87624b5af 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -470,7 +470,7 @@ static int gpio_setup_irq(struct gpio_desc *desc, struct device *dev,
 			IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;
 
 	if (!value_sd) {
-		value_sd = sysfs_get_dirent(dev->kobj.sd, NULL, "value");
+		value_sd = sysfs_get_dirent(dev->kobj.sd, "value");
 		if (!value_sd) {
 			ret = -ENODEV;
 			goto err_out;
diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c
index c71f15114155..ed462c551d86 100644
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -1671,9 +1671,9 @@ int bitmap_create(struct mddev *mddev)
 	bitmap->mddev = mddev;
 
 	if (mddev->kobj.sd)
-		bm = sysfs_get_dirent(mddev->kobj.sd, NULL, "bitmap");
+		bm = sysfs_get_dirent(mddev->kobj.sd, "bitmap");
 	if (bm) {
-		bitmap->sysfs_can_clear = sysfs_get_dirent(bm, NULL, "can_clear");
+		bitmap->sysfs_can_clear = sysfs_get_dirent(bm, "can_clear");
 		sysfs_put(bm);
 	} else
 		bitmap->sysfs_can_clear = NULL;
* Unmerged path drivers/md/md.c
diff --git a/drivers/md/md.h b/drivers/md/md.h
index 0d13bf88f41f..e68e81d5214a 100644
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@ -566,7 +566,7 @@ extern struct attribute_group md_bitmap_group;
 static inline struct sysfs_dirent *sysfs_get_dirent_safe(struct sysfs_dirent *sd, char *name)
 {
 	if (sd)
-		return sysfs_get_dirent(sd, NULL, name);
+		return sysfs_get_dirent(sd, name);
 	return sd;
 }
 static inline void sysfs_notify_dirent_safe(struct sysfs_dirent *sd)
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index fd502d3fc9fc..86824c28a8b4 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -635,9 +635,10 @@ struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 }
 
 /**
- *	sysfs_get_dirent - find and get sysfs_dirent with the given name
+ *	sysfs_get_dirent_ns - find and get sysfs_dirent with the given name
  *	@parent_sd: sysfs_dirent to search under
  *	@name: name to look for
+ *	@ns: the namespace tag to use
  *
  *	Look for sysfs_dirent with name @name under @parent_sd and get
  *	it if found.
@@ -648,9 +649,9 @@ struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
  *	RETURNS:
  *	Pointer to sysfs_dirent if found, NULL if not.
  */
-struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
-				      const void *ns,
-				      const unsigned char *name)
+struct sysfs_dirent *sysfs_get_dirent_ns(struct sysfs_dirent *parent_sd,
+					 const unsigned char *name,
+					 const void *ns)
 {
 	struct sysfs_dirent *sd;
 
@@ -661,7 +662,7 @@ struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
 
 	return sd;
 }
-EXPORT_SYMBOL_GPL(sysfs_get_dirent);
+EXPORT_SYMBOL_GPL(sysfs_get_dirent_ns);
 
 static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
 	enum kobj_ns_type type, const void *ns, const char *name,
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 3de7949b1b72..a37465d9942c 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -605,7 +605,7 @@ int sysfs_add_file_to_group(struct kobject *kobj,
 	int error;
 
 	if (group)
-		dir_sd = sysfs_get_dirent(kobj->sd, NULL, group);
+		dir_sd = sysfs_get_dirent(kobj->sd, group);
 	else
 		dir_sd = sysfs_get(kobj->sd);
 
@@ -693,7 +693,7 @@ void sysfs_remove_file_from_group(struct kobject *kobj,
 	struct sysfs_dirent *dir_sd;
 
 	if (group)
-		dir_sd = sysfs_get_dirent(kobj->sd, NULL, group);
+		dir_sd = sysfs_get_dirent(kobj->sd, group);
 	else
 		dir_sd = sysfs_get(kobj->sd);
 	if (dir_sd) {
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 1a6e16c0db91..567cbb23149b 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -206,7 +206,7 @@ void sysfs_remove_group(struct kobject *kobj,
 	struct sysfs_dirent *sd;
 
 	if (grp->name) {
-		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
+		sd = sysfs_get_dirent(dir_sd, grp->name);
 		if (!sd) {
 			WARN(!sd, KERN_WARNING
 			     "sysfs group %p not found for kobject '%s'\n",
@@ -261,7 +261,7 @@ int sysfs_merge_group(struct kobject *kobj,
 	struct attribute *const *attr;
 	int i;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
+	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -288,7 +288,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	struct sysfs_dirent *dir_sd;
 	struct attribute *const *attr;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
+	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
 			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
@@ -310,7 +310,7 @@ int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
 	struct sysfs_dirent *dir_sd;
 	int error = 0;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
+	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -332,7 +332,7 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 {
 	struct sysfs_dirent *dir_sd;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
+	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 	if (dir_sd) {
 		sysfs_hash_and_remove(dir_sd, NULL, link_name);
 		sysfs_put(dir_sd);
diff --git a/fs/sysfs/symlink.c b/fs/sysfs/symlink.c
index 9fab2e7f7357..b41ef68dd258 100644
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@ -205,7 +205,7 @@ int sysfs_rename_link(struct kobject *kobj, struct kobject *targ,
 		old_ns = targ->sd->s_ns;
 
 	result = -ENOENT;
-	sd = sysfs_get_dirent(parent_sd, old_ns, old);
+	sd = sysfs_get_dirent_ns(parent_sd, old, old_ns);
 	if (!sd)
 		goto out;
 
diff --git a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
index b6deca3e301d..f96fd12f6f19 100644
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@ -175,9 +175,6 @@ void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
 struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 				       const void *ns,
 				       const unsigned char *name);
-struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
-				      const void *ns,
-				      const unsigned char *name);
 struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
 
 void release_sysfs_dirent(struct sysfs_dirent *sd);
* Unmerged path include/linux/sysfs.h
