bnxt_en: Add basic XDP support.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add basic XDP support (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.36%
commit-author Michael Chan <michael.chan@broadcom.com>
commit c6d30e8391b85e00eb544e6cf047ee0160ee9938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c6d30e83.failed

Add basic ndo_xdp support to setup and query program, configure the NIC
to run in rx page mode, and support XDP_PASS, XDP_DROP, XDP_ABORTED
actions only.

v3: Pass modified offset and length to stack for XDP_PASS.
    Remove Kconfig option.

v2: Added trace_xdp_exception()
    Added dma_syncs.
    Added XDP headroom support.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Tested-by: Andy Gospodarek <gospo@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c6d30e8391b85e00eb544e6cf047ee0160ee9938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 10385773ecb6,665fe4fbf5d0..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -1415,8 -1494,14 +1421,17 @@@ static int bnxt_rx_pkt(struct bnxt *bp
  			goto next_rx;
  		}
  	} else {
++<<<<<<< HEAD
++=======
+ 		u32 payload;
+ 
+ 		if (rx_buf->data_ptr == data_ptr)
+ 			payload = misc & RX_CMP_PAYLOAD_OFFSET;
+ 		else
+ 			payload = 0;
++>>>>>>> c6d30e8391b8 (bnxt_en: Add basic XDP support.)
  		skb = bp->rx_skb_func(bp, rxr, cons, data, data_ptr, dma_addr,
 -				      payload | len);
 +				      len);
  		if (!skb) {
  			rc = -ENOMEM;
  			goto next_rx;
@@@ -2360,8 -2450,13 +2387,18 @@@ static int bnxt_init_rx_rings(struct bn
  {
  	int i, rc = 0;
  
++<<<<<<< HEAD
 +	bp->rx_offset = BNXT_RX_OFFSET;
 +	bp->rx_dma_offset = BNXT_RX_DMA_OFFSET;
++=======
+ 	if (BNXT_RX_PAGE_MODE(bp)) {
+ 		bp->rx_offset = NET_IP_ALIGN + XDP_PACKET_HEADROOM;
+ 		bp->rx_dma_offset = XDP_PACKET_HEADROOM;
+ 	} else {
+ 		bp->rx_offset = BNXT_RX_OFFSET;
+ 		bp->rx_dma_offset = BNXT_RX_DMA_OFFSET;
+ 	}
++>>>>>>> c6d30e8391b8 (bnxt_en: Add basic XDP support.)
  
  	for (i = 0; i < bp->rx_nr_rings; i++) {
  		rc = bnxt_init_one_rx_ring(bp, i);
@@@ -7042,8 -7126,9 +7079,14 @@@ static const struct net_device_ops bnxt
  #ifdef CONFIG_RFS_ACCEL
  	.ndo_rx_flow_steer	= bnxt_rx_flow_steer,
  #endif
++<<<<<<< HEAD
 +	.extended.ndo_udp_tunnel_add	= bnxt_udp_tunnel_add,
 +	.extended.ndo_udp_tunnel_del	= bnxt_udp_tunnel_del,
++=======
+ 	.ndo_udp_tunnel_add	= bnxt_udp_tunnel_add,
+ 	.ndo_udp_tunnel_del	= bnxt_udp_tunnel_del,
+ 	.ndo_xdp		= bnxt_xdp,
++>>>>>>> c6d30e8391b8 (bnxt_en: Add basic XDP support.)
  };
  
  static void bnxt_remove_one(struct pci_dev *pdev)
@@@ -7063,10 -7148,17 +7106,15 @@@
  	bnxt_hwrm_func_drv_unrgtr(bp);
  	bnxt_free_hwrm_resources(bp);
  	bnxt_dcb_free(bp);
 -	pci_iounmap(pdev, bp->bar2);
 -	pci_iounmap(pdev, bp->bar1);
 -	pci_iounmap(pdev, bp->bar0);
  	kfree(bp->edev);
  	bp->edev = NULL;
++<<<<<<< HEAD
 +	bnxt_cleanup_pci(bp);
++=======
+ 	if (bp->xdp_prog)
+ 		bpf_prog_put(bp->xdp_prog);
++>>>>>>> c6d30e8391b8 (bnxt_en: Add basic XDP support.)
  	free_netdev(dev);
 -
 -	pci_release_regions(pdev);
 -	pci_disable_device(pdev);
  }
  
  static int bnxt_probe_phy(struct bnxt *bp)
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 5e8dec350fca,db4a41069b71..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -417,6 -416,11 +417,14 @@@ struct rx_tpa_end_cmp_ext 
  
  #define BNXT_RX_PAGE_SIZE (1 << BNXT_RX_PAGE_SHIFT)
  
++<<<<<<< HEAD
++=======
+ #define BNXT_MAX_MTU		9500
+ #define BNXT_MAX_PAGE_MODE_MTU	\
+ 	((unsigned int)PAGE_SIZE - VLAN_ETH_HLEN - NET_IP_ALIGN -	\
+ 	 XDP_PACKET_HEADROOM)
+ 
++>>>>>>> c6d30e8391b8 (bnxt_en: Add basic XDP support.)
  #define BNXT_MIN_PKT_SIZE	52
  
  #define BNXT_NUM_TESTS(bp)	0
@@@ -1180,7 -1191,10 +1192,9 @@@ struct bnxt 
  #define SFF_MODULE_ID_QSFP28			0x11
  #define BNXT_MAX_PHY_I2C_RESP_SIZE		64
  
+ void bnxt_reuse_rx_data(struct bnxt_rx_ring_info *rxr, u16 cons, void *data);
+ void bnxt_set_tpa_flags(struct bnxt *bp);
  void bnxt_set_ring_params(struct bnxt *);
 -int bnxt_set_rx_skb_mode(struct bnxt *bp, bool page_mode);
  void bnxt_hwrm_cmd_hdr_init(struct bnxt *, void *, u16, u16, u16);
  int _hwrm_send_message(struct bnxt *, void *, u32, int);
  int hwrm_send_message(struct bnxt *, void *, u32, int);
diff --git a/drivers/net/ethernet/broadcom/bnxt/Makefile b/drivers/net/ethernet/broadcom/bnxt/Makefile
index 6082ed1b5ea0..a7ca45b251cb 100644
--- a/drivers/net/ethernet/broadcom/bnxt/Makefile
+++ b/drivers/net/ethernet/broadcom/bnxt/Makefile
@@ -1,3 +1,3 @@
 obj-$(CONFIG_BNXT) += bnxt_en.o
 
-bnxt_en-y := bnxt.o bnxt_sriov.o bnxt_ethtool.o bnxt_dcb.o bnxt_ulp.o
+bnxt_en-y := bnxt.o bnxt_sriov.o bnxt_ethtool.o bnxt_dcb.o bnxt_ulp.o bnxt_xdp.o
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
new file mode 100644
index 000000000000..b822e461cbde
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
@@ -0,0 +1,157 @@
+/* Broadcom NetXtreme-C/E network driver.
+ *
+ * Copyright (c) 2016-2017 Broadcom Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/bpf.h>
+#include <linux/bpf_trace.h>
+#include <linux/filter.h>
+#include "bnxt_hsi.h"
+#include "bnxt.h"
+#include "bnxt_xdp.h"
+
+/* returns the following:
+ * true    - packet consumed by XDP and new buffer is allocated.
+ * false   - packet should be passed to the stack.
+ */
+bool bnxt_rx_xdp(struct bnxt *bp, struct bnxt_rx_ring_info *rxr, u16 cons,
+		 struct page *page, u8 **data_ptr, unsigned int *len, u8 *event)
+{
+	struct bpf_prog *xdp_prog = READ_ONCE(rxr->xdp_prog);
+	struct bnxt_sw_rx_bd *rx_buf;
+	struct pci_dev *pdev;
+	struct xdp_buff xdp;
+	dma_addr_t mapping;
+	void *orig_data;
+	u32 offset;
+	u32 act;
+
+	if (!xdp_prog)
+		return false;
+
+	pdev = bp->pdev;
+	rx_buf = &rxr->rx_buf_ring[cons];
+	offset = bp->rx_offset;
+
+	xdp.data_hard_start = *data_ptr - offset;
+	xdp.data = *data_ptr;
+	xdp.data_end = *data_ptr + *len;
+	orig_data = xdp.data;
+	mapping = rx_buf->mapping - bp->rx_dma_offset;
+
+	dma_sync_single_for_cpu(&pdev->dev, mapping + offset, *len, bp->rx_dir);
+
+	rcu_read_lock();
+	act = bpf_prog_run_xdp(xdp_prog, &xdp);
+	rcu_read_unlock();
+
+	if (orig_data != xdp.data) {
+		offset = xdp.data - xdp.data_hard_start;
+		*data_ptr = xdp.data_hard_start + offset;
+		*len = xdp.data_end - xdp.data;
+	}
+	switch (act) {
+	case XDP_PASS:
+		return false;
+
+	default:
+		bpf_warn_invalid_xdp_action(act);
+		/* Fall thru */
+	case XDP_ABORTED:
+		trace_xdp_exception(bp->dev, xdp_prog, act);
+		/* Fall thru */
+	case XDP_DROP:
+		bnxt_reuse_rx_data(rxr, cons, page);
+		break;
+	}
+	return true;
+}
+
+/* Under rtnl_lock */
+static int bnxt_xdp_set(struct bnxt *bp, struct bpf_prog *prog)
+{
+	struct net_device *dev = bp->dev;
+	int tx_xdp = 0, rc, tc;
+	struct bpf_prog *old;
+
+	if (prog && bp->dev->mtu > BNXT_MAX_PAGE_MODE_MTU) {
+		netdev_warn(dev, "MTU %d larger than largest XDP supported MTU %d.\n",
+			    bp->dev->mtu, BNXT_MAX_PAGE_MODE_MTU);
+		return -EOPNOTSUPP;
+	}
+	if (!(bp->flags & BNXT_FLAG_SHARED_RINGS)) {
+		netdev_warn(dev, "ethtool rx/tx channels must be combined to support XDP.\n");
+		return -EOPNOTSUPP;
+	}
+	if (prog)
+		tx_xdp = bp->rx_nr_rings;
+
+	tc = netdev_get_num_tc(dev);
+	if (!tc)
+		tc = 1;
+	rc = bnxt_reserve_rings(bp, bp->tx_nr_rings_per_tc, bp->rx_nr_rings,
+				tc, tx_xdp);
+	if (rc) {
+		netdev_warn(dev, "Unable to reserve enough TX rings to support XDP.\n");
+		return rc;
+	}
+	if (netif_running(dev))
+		bnxt_close_nic(bp, true, false);
+
+	old = xchg(&bp->xdp_prog, prog);
+	if (old)
+		bpf_prog_put(old);
+
+	if (prog) {
+		bnxt_set_rx_skb_mode(bp, true);
+	} else {
+		int rx, tx;
+
+		bnxt_set_rx_skb_mode(bp, false);
+		bnxt_get_max_rings(bp, &rx, &tx, true);
+		if (rx > 1) {
+			bp->flags &= ~BNXT_FLAG_NO_AGG_RINGS;
+			bp->dev->hw_features |= NETIF_F_LRO;
+		}
+	}
+	bp->tx_nr_rings_xdp = tx_xdp;
+	bp->tx_nr_rings = bp->tx_nr_rings_per_tc * tc + tx_xdp;
+	bp->cp_nr_rings = max_t(int, bp->tx_nr_rings, bp->rx_nr_rings);
+	bp->num_stat_ctxs = bp->cp_nr_rings;
+	bnxt_set_tpa_flags(bp);
+	bnxt_set_ring_params(bp);
+
+	if (netif_running(dev))
+		return bnxt_open_nic(bp, true, false);
+
+	return 0;
+}
+
+int bnxt_xdp(struct net_device *dev, struct netdev_xdp *xdp)
+{
+	struct bnxt *bp = netdev_priv(dev);
+	int rc;
+
+	switch (xdp->command) {
+	case XDP_SETUP_PROG:
+		rc = bnxt_xdp_set(bp, xdp->prog);
+		break;
+	case XDP_QUERY_PROG:
+		xdp->prog_attached = !!bp->xdp_prog;
+		rc = 0;
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+	return rc;
+}
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.h b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.h
new file mode 100644
index 000000000000..0bb7b7d97ec3
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.h
@@ -0,0 +1,18 @@
+/* Broadcom NetXtreme-C/E network driver.
+ *
+ * Copyright (c) 2016-2017 Broadcom Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef BNXT_XDP_H
+#define BNXT_XDP_H
+
+bool bnxt_rx_xdp(struct bnxt *bp, struct bnxt_rx_ring_info *rxr, u16 cons,
+		 struct page *page, u8 **data_ptr, unsigned int *len,
+		 u8 *event);
+int bnxt_xdp(struct net_device *dev, struct netdev_xdp *xdp);
+
+#endif
