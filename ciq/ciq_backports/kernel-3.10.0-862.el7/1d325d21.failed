ipv6: ip6_fragment: fix headroom tests and skb leak

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Westphal <fw@strlen.de>
commit 1d325d217c7f190a42fb620ead20bb240fc16af0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1d325d21.failed

David Woodhouse reports skb_under_panic when we try to push ethernet
header to fragmented ipv6 skbs:

 skbuff: skb_under_panic: text:c1277f1e len:1294 put:14 head:dec98000
 data:dec97ffc tail:0xdec9850a end:0xdec98f40 dev:br-lan
[..]
ip6_finish_output2+0x196/0x4da

David further debugged this:
  [..] offending fragments were arriving here with skb_headroom(skb)==10.
  Which is reasonable, being the Solos ADSL card's header of 8 bytes
  followed by 2 bytes of PPP frame type.

The problem is that if netfilter ipv6 defragmentation is used, skb_cow()
in ip6_forward will only see reassembled skb.

Therefore, headroom is overestimated by 8 bytes (we pulled fragment
header) and we don't check the skbs in the frag_list either.

We can't do these checks in netfilter defrag since outdev isn't known yet.

Furthermore, existing tests in ip6_fragment did not consider the fragment
or ipv6 header size when checking headroom of the fraglist skbs.

While at it, also fix a skb leak on memory allocation -- ip6_fragment
must consume the skb.

I tested this e1000 driver hacked to not allocate additional headroom
(we end up in slowpath, since LL_RESERVED_SPACE is 16).

If 2 bytes of headroom are allocated, fastpath is taken (14 byte
ethernet header was pulled, so 16 byte headroom available in all
fragments).

	Reported-by: David Woodhouse <dwmw2@infradead.org>
Diagnosed-by: David Woodhouse <dwmw2@infradead.org>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Tested-by: David Woodhouse <David.Woodhouse@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1d325d217c7f190a42fb620ead20bb240fc16af0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index e14ce8c9f4a2,92b1aa38f121..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -570,10 -586,7 +570,14 @@@ int ip6_fragment(struct sock *sk, struc
  	frag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,
  				    &ipv6_hdr(skb)->saddr);
  
++<<<<<<< HEAD
 +	if (skb->ip_summed == CHECKSUM_PARTIAL &&
 +	    (err = skb_checksum_help(skb)))
 +		goto fail;
 +
++=======
+ 	hroom = LL_RESERVED_SPACE(rt->dst.dev);
++>>>>>>> 1d325d217c7f (ipv6: ip6_fragment: fix headroom tests and skb leak)
  	if (skb_has_frag_list(skb)) {
  		int first_len = skb_pagelen(skb);
  		struct sk_buff *frag2;
@@@ -613,11 -625,14 +616,14 @@@
  		if (!tmp_hdr) {
  			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
  				      IPSTATS_MIB_FRAGFAILS);
- 			return -ENOMEM;
+ 			err = -ENOMEM;
+ 			goto fail;
  		}
+ 		frag = skb_shinfo(skb)->frag_list;
+ 		skb_frag_list_init(skb);
  
  		__skb_pull(skb, hlen);
 -		fh = (struct frag_hdr *)__skb_push(skb, sizeof(struct frag_hdr));
 +		fh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));
  		__skb_push(skb, hlen);
  		skb_reset_network_header(skb);
  		memcpy(skb_network_header(skb), tmp_hdr, hlen);
@@@ -710,7 -725,7 +716,11 @@@ slow_path
  	 *	Fragment the datagram.
  	 */
  
++<<<<<<< HEAD
 +	hroom = LL_RESERVED_SPACE(rt->dst.dev);
++=======
+ 	*prevhdr = NEXTHDR_FRAGMENT;
++>>>>>>> 1d325d217c7f (ipv6: ip6_fragment: fix headroom tests and skb leak)
  	troom = rt->dst.dev->needed_tailroom;
  
  	/*
* Unmerged path net/ipv6/ip6_output.c
