namespace.c: constify struct path passed to a bunch of primitives

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit ca71cf71eeda04dc9ad18271504e499013af5415
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ca71cf71.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit ca71cf71eeda04dc9ad18271504e499013af5415)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 84149742b9d6,9ad88a45b3e3..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1177,36 -1159,7 +1177,40 @@@ struct vfsmount *mntget(struct vfsmoun
  }
  EXPORT_SYMBOL(mntget);
  
++<<<<<<< HEAD
 +/* path_is_mountpoint() - Check if path is a mount in the current
 + *                          namespace.
 + *
 + *  d_mountpoint() can only be used reliably to establish if a dentry is
 + *  not mounted in any namespace and that common case is handled inline.
 + *  d_mountpoint() isn't aware of the possibility there may be multiple
 + *  mounts using a given dentry in a different namespace. This function
 + *  checks if the passed in path is a mountpoint rather than the dentry
 + *  alone.
 + */
 +bool path_is_mountpoint(const struct path *path)
 +{
 +	unsigned seq;
 +	bool res;
 +
 +	if (!d_mountpoint(path->dentry))
 +		return false;
 +
 +	rcu_read_lock();
 +	do {
 +		seq = read_seqbegin(&mount_lock);
 +		res = __path_is_mountpoint(path);
 +	} while (read_seqretry(&mount_lock, seq));
 +	rcu_read_unlock();
 +
 +	return res;
 +}
 +EXPORT_SYMBOL(path_is_mountpoint);
 +
 +struct vfsmount *mnt_clone_internal(struct path *path)
++=======
+ struct vfsmount *mnt_clone_internal(const struct path *path)
++>>>>>>> ca71cf71eeda (namespace.c: constify struct path passed to a bunch of primitives)
  {
  	struct mount *p;
  	p = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);
diff --git a/fs/internal.h b/fs/internal.h
index 2b28acd45c7d..98e13f7d86a4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -62,7 +62,7 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 extern void *copy_mount_options(const void __user *);
 extern char *copy_mount_string(const void __user *);
 
-extern struct vfsmount *lookup_mnt(struct path *);
+extern struct vfsmount *lookup_mnt(const struct path *);
 extern int finish_automount(struct vfsmount *, struct path *);
 
 extern int sb_prepare_remount_readonly(struct super_block *);
* Unmerged path fs/namespace.c
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 24213ce025a6..ed7de8386034 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2265,7 +2265,7 @@ extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
 extern long do_mount(const char *, const char __user *,
 		     const char *, unsigned long, void *);
-extern struct vfsmount *collect_mounts(struct path *);
+extern struct vfsmount *collect_mounts(const struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 			  struct vfsmount *);
diff --git a/include/linux/mount.h b/include/linux/mount.h
index 952d044c1eba..602c30eee2d5 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -79,11 +79,11 @@ extern void mnt_drop_write(struct vfsmount *mnt);
 extern void mnt_drop_write_file(struct file *file);
 extern void mntput(struct vfsmount *mnt);
 extern struct vfsmount *mntget(struct vfsmount *mnt);
-extern struct vfsmount *mnt_clone_internal(struct path *path);
+extern struct vfsmount *mnt_clone_internal(const struct path *path);
 extern int __mnt_is_readonly(struct vfsmount *mnt);
 
 struct path;
-extern struct vfsmount *clone_private_mount(struct path *path);
+extern struct vfsmount *clone_private_mount(const struct path *path);
 
 struct file_system_type;
 extern struct vfsmount *vfs_kern_mount(struct file_system_type *type,
