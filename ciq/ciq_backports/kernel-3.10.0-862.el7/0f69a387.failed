target: Fix handling of small allocation lengths in REPORT LUNS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Fix handling of small allocation lengths in REPORT LUNS (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 93.22%
commit-author Roland Dreier <roland@purestorage.com>
commit 0f69a38737538c8a265f75d26996818f98c899e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0f69a387.failed

REPORT LUNS should not fail just because the allocation length is less
than 16.  The relevant section of SPC-4 is:

  4.2.5.6 Allocation length

  The ALLOCATION LENGTH field specifies the maximum number of bytes or
  blocks that an application client has allocated in the Data-In
  Buffer. The ALLOCATION LENGTH field specifies bytes unless a
  different requirement is stated in the command definition.

  An allocation length of zero specifies that no data shall be
  transferred. This condition shall not be considered an error.

So we should just truncate our response rather than return an error.

	Signed-off-by: Roland Dreier <roland@purestorage.com>
	Signed-off-by: Spencer Baugh <sbaugh@catern.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 0f69a38737538c8a265f75d26996818f98c899e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_spc.c
diff --cc drivers/target/target_core_spc.c
index 12f1adf6c7ed,f87d4cef6d39..000000000000
--- a/drivers/target/target_core_spc.c
+++ b/drivers/target/target_core_spc.c
@@@ -1218,17 -1202,14 +1218,25 @@@ sense_reason_t spc_emulate_report_luns(
  {
  	struct se_dev_entry *deve;
  	struct se_session *sess = cmd->se_sess;
++<<<<<<< HEAD
 +	unsigned char *buf;
 +	u32 lun_count = 0, offset = 8, i;
 +
 +	if (cmd->data_length < 16) {
 +		pr_warn("REPORT LUNS allocation length %u too small\n",
 +			cmd->data_length);
 +		return TCM_INVALID_CDB_FIELD;
 +	}
++=======
+ 	struct se_node_acl *nacl;
+ 	struct scsi_lun slun;
+ 	unsigned char *buf;
+ 	u32 lun_count = 0, offset = 8;
+ 	__be32 len;
++>>>>>>> 0f69a3873753 (target: Fix handling of small allocation lengths in REPORT LUNS)
  
  	buf = transport_kmap_data_sg(cmd);
- 	if (!buf)
+ 	if (cmd->data_length && !buf)
  		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
  
  	/*
@@@ -1253,24 -1230,36 +1261,45 @@@
  		 * See SPC2-R20 7.19.
  		 */
  		lun_count++;
- 		if ((offset + 8) > cmd->data_length)
+ 		if (offset >= cmd->data_length)
  			continue;
  
- 		int_to_scsilun(deve->mapped_lun, (struct scsi_lun *)&buf[offset]);
+ 		int_to_scsilun(deve->mapped_lun, &slun);
+ 		memcpy(buf + offset, &slun,
+ 		       min(8u, cmd->data_length - offset));
  		offset += 8;
  	}
 -	rcu_read_unlock();
 +	spin_unlock_irq(&sess->se_node_acl->device_list_lock);
  
  	/*
  	 * See SPC3 r07, page 159.
  	 */
  done:
++<<<<<<< HEAD
 +	lun_count *= 8;
 +	buf[0] = ((lun_count >> 24) & 0xff);
 +	buf[1] = ((lun_count >> 16) & 0xff);
 +	buf[2] = ((lun_count >> 8) & 0xff);
 +	buf[3] = (lun_count & 0xff);
 +	transport_kunmap_data_sg(cmd);
++=======
+ 	/*
+ 	 * If no LUNs are accessible, report virtual LUN 0.
+ 	 */
+ 	if (lun_count == 0) {
+ 		int_to_scsilun(0, &slun);
+ 		if (cmd->data_length > 8)
+ 			memcpy(buf + offset, &slun,
+ 			       min(8u, cmd->data_length - offset));
+ 		lun_count = 1;
+ 	}
+ 
+ 	if (buf) {
+ 		len = cpu_to_be32(lun_count * 8);
+ 		memcpy(buf, &len, min_t(int, sizeof len, cmd->data_length));
+ 		transport_kunmap_data_sg(cmd);
+ 	}
++>>>>>>> 0f69a3873753 (target: Fix handling of small allocation lengths in REPORT LUNS)
  
  	target_complete_cmd_with_length(cmd, GOOD, 8 + lun_count * 8);
  	return 0;
* Unmerged path drivers/target/target_core_spc.c
