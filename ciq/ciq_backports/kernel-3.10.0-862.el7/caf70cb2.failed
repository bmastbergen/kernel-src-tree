ovl: cleanup orphan index entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit caf70cb2ba5dff85ea90f494a30075af92df13b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/caf70cb2.failed

index entry should live only as long as there are upper or lower
hardlinks.

Cleanup orphan index entries on mount and when dropping the last
overlay inode nlink.

When about to cleanup or link up to orphan index and the index inode
nlink > 1, admit that something went wrong and adjust overlay nlink
to index inode nlink - 1 to prevent it from dropping below zero.
This could happen when adding lower hardlinks underneath a mounted
overlay and then trying to unlink them.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit caf70cb2ba5dff85ea90f494a30075af92df13b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/inode.c
index e60c6d748742,69f4fc26ee39..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -414,7 -452,104 +414,108 @@@ static void ovl_fill_inode(struct inod
  	}
  }
  
++<<<<<<< HEAD
 +struct inode *ovl_new_inode(struct super_block *sb, umode_t mode)
++=======
+ /*
+  * With inodes index enabled, an overlay inode nlink counts the union of upper
+  * hardlinks and non-covered lower hardlinks. During the lifetime of a non-pure
+  * upper inode, the following nlink modifying operations can happen:
+  *
+  * 1. Lower hardlink copy up
+  * 2. Upper hardlink created, unlinked or renamed over
+  * 3. Lower hardlink whiteout or renamed over
+  *
+  * For the first, copy up case, the union nlink does not change, whether the
+  * operation succeeds or fails, but the upper inode nlink may change.
+  * Therefore, before copy up, we store the union nlink value relative to the
+  * lower inode nlink in the index inode xattr trusted.overlay.nlink.
+  *
+  * For the second, upper hardlink case, the union nlink should be incremented
+  * or decremented IFF the operation succeeds, aligned with nlink change of the
+  * upper inode. Therefore, before link/unlink/rename, we store the union nlink
+  * value relative to the upper inode nlink in the index inode.
+  *
+  * For the last, lower cover up case, we simplify things by preceding the
+  * whiteout or cover up with copy up. This makes sure that there is an index
+  * upper inode where the nlink xattr can be stored before the copied up upper
+  * entry is unlink.
+  */
+ #define OVL_NLINK_ADD_UPPER	(1 << 0)
+ 
+ /*
+  * On-disk format for indexed nlink:
+  *
+  * nlink relative to the upper inode - "U[+-]NUM"
+  * nlink relative to the lower inode - "L[+-]NUM"
+  */
+ 
+ static int ovl_set_nlink_common(struct dentry *dentry,
+ 				struct dentry *realdentry, const char *format)
+ {
+ 	struct inode *inode = d_inode(dentry);
+ 	struct inode *realinode = d_inode(realdentry);
+ 	char buf[13];
+ 	int len;
+ 
+ 	len = snprintf(buf, sizeof(buf), format,
+ 		       (int) (inode->i_nlink - realinode->i_nlink));
+ 
+ 	return ovl_do_setxattr(ovl_dentry_upper(dentry),
+ 			       OVL_XATTR_NLINK, buf, len, 0);
+ }
+ 
+ int ovl_set_nlink_upper(struct dentry *dentry)
+ {
+ 	return ovl_set_nlink_common(dentry, ovl_dentry_upper(dentry), "U%+i");
+ }
+ 
+ int ovl_set_nlink_lower(struct dentry *dentry)
+ {
+ 	return ovl_set_nlink_common(dentry, ovl_dentry_lower(dentry), "L%+i");
+ }
+ 
+ unsigned int ovl_get_nlink(struct dentry *lowerdentry,
+ 			   struct dentry *upperdentry,
+ 			   unsigned int fallback)
+ {
+ 	int nlink_diff;
+ 	int nlink;
+ 	char buf[13];
+ 	int err;
+ 
+ 	if (!lowerdentry || !upperdentry || d_inode(lowerdentry)->i_nlink == 1)
+ 		return fallback;
+ 
+ 	err = vfs_getxattr(upperdentry, OVL_XATTR_NLINK, &buf, sizeof(buf) - 1);
+ 	if (err < 0)
+ 		goto fail;
+ 
+ 	buf[err] = '\0';
+ 	if ((buf[0] != 'L' && buf[0] != 'U') ||
+ 	    (buf[1] != '+' && buf[1] != '-'))
+ 		goto fail;
+ 
+ 	err = kstrtoint(buf + 1, 10, &nlink_diff);
+ 	if (err < 0)
+ 		goto fail;
+ 
+ 	nlink = d_inode(buf[0] == 'L' ? lowerdentry : upperdentry)->i_nlink;
+ 	nlink += nlink_diff;
+ 
+ 	if (nlink <= 0)
+ 		goto fail;
+ 
+ 	return nlink;
+ 
+ fail:
+ 	pr_warn_ratelimited("overlayfs: failed to get index nlink (%pd2, err=%i)\n",
+ 			    upperdentry, err);
+ 	return fallback;
+ }
+ 
+ struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev)
++>>>>>>> caf70cb2ba5d (ovl: cleanup orphan index entries)
  {
  	struct inode *inode;
  
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,60d26605e039..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -181,9 -257,18 +181,17 @@@ void ovl_cache_free(struct list_head *l
  int ovl_check_d_type_supported(struct path *realpath);
  void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
  			 struct dentry *dentry, int level);
 -int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 -			 struct path *lowerstack, unsigned int numlower);
  
  /* inode.c */
++<<<<<<< HEAD
++=======
+ int ovl_set_nlink_upper(struct dentry *dentry);
+ int ovl_set_nlink_lower(struct dentry *dentry);
+ unsigned int ovl_get_nlink(struct dentry *lowerdentry,
+ 			   struct dentry *upperdentry,
+ 			   unsigned int fallback);
++>>>>>>> caf70cb2ba5d (ovl: cleanup orphan index entries)
  int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 -int ovl_getattr(const struct path *path, struct kstat *stat,
 -		u32 request_mask, unsigned int flags);
  int ovl_permission(struct inode *inode, int mask);
  int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
  		  size_t size, int flags);
diff --cc fs/overlayfs/super.c
index aaf06952d88f,44dc2d6ffe0f..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -1434,11 -1044,51 +1434,54 @@@ static int ovl_fill_super(struct super_
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
  	if (!ufs->upper_mnt)
  		sb->s_flags |= MS_RDONLY;
++<<<<<<< HEAD
++=======
+ 	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
+ 		ufs->same_sb = NULL;
+ 
+ 	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
+ 		/* Verify lower root is upper root origin */
+ 		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
+ 					stack[0].dentry, false, true);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to verify upper root origin\n");
+ 			goto out_put_lower_mnt;
+ 		}
+ 
+ 		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
+ 						   OVL_INDEXDIR_NAME, true);
+ 		err = PTR_ERR(ufs->indexdir);
+ 		if (IS_ERR(ufs->indexdir))
+ 			goto out_put_lower_mnt;
+ 
+ 		if (ufs->indexdir) {
+ 			/* Verify upper root is index dir origin */
+ 			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
+ 						upperpath.dentry, true, true);
+ 			if (err)
+ 				pr_err("overlayfs: failed to verify index dir origin\n");
+ 
+ 			/* Cleanup bad/stale/orphan index entries */
+ 			if (!err)
+ 				err = ovl_indexdir_cleanup(ufs->indexdir,
+ 							   ufs->upper_mnt,
+ 							   stack, numlower);
+ 		}
+ 		if (err || !ufs->indexdir)
+ 			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 		if (err)
+ 			goto out_put_indexdir;
+ 	}
+ 
+ 	/* Show index=off/on in /proc/mounts for any of the reasons above */
+ 	if (!ufs->indexdir)
+ 		ufs->config.index = false;
++>>>>>>> caf70cb2ba5d (ovl: cleanup orphan index entries)
  
  	if (remote)
 -		sb->s_d_op = &ovl_reval_dentry_operations;
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
  	else
 -		sb->s_d_op = &ovl_dentry_operations;
 +		sb->s_d_op = &ovl_dentry_operations.ops;
  
  	ufs->creator_cred = cred = prepare_creds();
  	if (!cred)
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
* Unmerged path fs/overlayfs/util.c
