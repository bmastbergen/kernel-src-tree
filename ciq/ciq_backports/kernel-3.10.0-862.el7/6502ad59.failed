bnxt_en: Add ETH_RESET_AP support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Scott Branden <scott.branden@broadcom.com>
commit 6502ad5963a5307089bed395f63173e34cb251ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6502ad59.failed

Add ETH_RESET_AP support handling to reset the internal
Application Processor(s) of the SmartNIC card.

	Signed-off-by: Scott Branden <scott.branden@broadcom.com>
	Acked-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6502ad5963a5307089bed395f63173e34cb251ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 4f7deb4be26d,fe7599f404bf..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@@ -1378,6 -1372,13 +1378,16 @@@ static int bnxt_firmware_reset(struct n
  	case BNX_DIR_TYPE_BONO_PATCH:
  		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_ROCE;
  		break;
++<<<<<<< HEAD
++=======
+ 	case BNXT_FW_RESET_CHIP:
+ 		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP;
+ 		req.selfrst_status = FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP;
+ 		break;
+ 	case BNXT_FW_RESET_AP:
+ 		req.embedded_proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_AP;
+ 		break;
++>>>>>>> 6502ad5963a5 (bnxt_en: Add ETH_RESET_AP support)
  	default:
  		return -EINVAL;
  	}
@@@ -2204,6 -2205,417 +2214,420 @@@ static int bnxt_set_phys_id(struct net_
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_hwrm_selftest_irq(struct bnxt *bp, u16 cmpl_ring)
+ {
+ 	struct hwrm_selftest_irq_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_IRQ, cmpl_ring, -1);
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_test_irq(struct bnxt *bp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		u16 cmpl_ring = bp->grp_info[i].cp_fw_ring_id;
+ 		int rc;
+ 
+ 		rc = bnxt_hwrm_selftest_irq(bp, cmpl_ring);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_hwrm_mac_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_mac_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_MAC_CFG, -1, -1);
+ 
+ 	req.enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_LPBK);
+ 	if (enable)
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_LOCAL;
+ 	else
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_NONE;
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_disable_an_for_lpbk(struct bnxt *bp,
+ 				    struct hwrm_port_phy_cfg_input *req)
+ {
+ 	struct bnxt_link_info *link_info = &bp->link_info;
+ 	u16 fw_advertising = link_info->advertising;
+ 	u16 fw_speed;
+ 	int rc;
+ 
+ 	if (!link_info->autoneg)
+ 		return 0;
+ 
+ 	fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_1GB;
+ 	if (netif_carrier_ok(bp->dev))
+ 		fw_speed = bp->link_info.link_speed;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_10GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_10GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_25GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_25GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_40GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_40GB;
+ 	else if (fw_advertising & BNXT_LINK_SPEED_MSK_50GB)
+ 		fw_speed = PORT_PHY_CFG_REQ_FORCE_LINK_SPEED_50GB;
+ 
+ 	req->force_link_speed = cpu_to_le16(fw_speed);
+ 	req->flags |= cpu_to_le32(PORT_PHY_CFG_REQ_FLAGS_FORCE |
+ 				  PORT_PHY_CFG_REQ_FLAGS_RESET_PHY);
+ 	rc = hwrm_send_message(bp, req, sizeof(*req), HWRM_CMD_TIMEOUT);
+ 	req->flags = 0;
+ 	req->force_link_speed = cpu_to_le16(0);
+ 	return rc;
+ }
+ 
+ static int bnxt_hwrm_phy_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_phy_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_PHY_CFG, -1, -1);
+ 
+ 	if (enable) {
+ 		bnxt_disable_an_for_lpbk(bp, &req);
+ 		req.lpbk = PORT_PHY_CFG_REQ_LPBK_LOCAL;
+ 	} else {
+ 		req.lpbk = PORT_PHY_CFG_REQ_LPBK_NONE;
+ 	}
+ 	req.enables = cpu_to_le32(PORT_PHY_CFG_REQ_ENABLES_LPBK);
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_rx_loopback(struct bnxt *bp, struct bnxt_napi *bnapi,
+ 			    u32 raw_cons, int pkt_size)
+ {
+ 	struct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;
+ 	struct bnxt_rx_ring_info *rxr = bnapi->rx_ring;
+ 	struct bnxt_sw_rx_bd *rx_buf;
+ 	struct rx_cmp *rxcmp;
+ 	u16 cp_cons, cons;
+ 	u8 *data;
+ 	u32 len;
+ 	int i;
+ 
+ 	cp_cons = RING_CMP(raw_cons);
+ 	rxcmp = (struct rx_cmp *)
+ 		&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
+ 	cons = rxcmp->rx_cmp_opaque;
+ 	rx_buf = &rxr->rx_buf_ring[cons];
+ 	data = rx_buf->data_ptr;
+ 	len = le32_to_cpu(rxcmp->rx_cmp_len_flags_type) >> RX_CMP_LEN_SHIFT;
+ 	if (len != pkt_size)
+ 		return -EIO;
+ 	i = ETH_ALEN;
+ 	if (!ether_addr_equal(data + i, bnapi->bp->dev->dev_addr))
+ 		return -EIO;
+ 	i += ETH_ALEN;
+ 	for (  ; i < pkt_size; i++) {
+ 		if (data[i] != (u8)(i & 0xff))
+ 			return -EIO;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_poll_loopback(struct bnxt *bp, int pkt_size)
+ {
+ 	struct bnxt_napi *bnapi = bp->bnapi[0];
+ 	struct bnxt_cp_ring_info *cpr;
+ 	struct tx_cmp *txcmp;
+ 	int rc = -EIO;
+ 	u32 raw_cons;
+ 	u32 cons;
+ 	int i;
+ 
+ 	cpr = &bnapi->cp_ring;
+ 	raw_cons = cpr->cp_raw_cons;
+ 	for (i = 0; i < 200; i++) {
+ 		cons = RING_CMP(raw_cons);
+ 		txcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];
+ 
+ 		if (!TX_CMP_VALID(txcmp, raw_cons)) {
+ 			udelay(5);
+ 			continue;
+ 		}
+ 
+ 		/* The valid test of the entry must be done first before
+ 		 * reading any further.
+ 		 */
+ 		dma_rmb();
+ 		if (TX_CMP_TYPE(txcmp) == CMP_TYPE_RX_L2_CMP) {
+ 			rc = bnxt_rx_loopback(bp, bnapi, raw_cons, pkt_size);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			break;
+ 		}
+ 		raw_cons = NEXT_RAW_CMP(raw_cons);
+ 	}
+ 	cpr->cp_raw_cons = raw_cons;
+ 	return rc;
+ }
+ 
+ static int bnxt_run_loopback(struct bnxt *bp)
+ {
+ 	struct bnxt_tx_ring_info *txr = &bp->tx_ring[0];
+ 	int pkt_size, i = 0;
+ 	struct sk_buff *skb;
+ 	dma_addr_t map;
+ 	u8 *data;
+ 	int rc;
+ 
+ 	pkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_copy_thresh);
+ 	skb = netdev_alloc_skb(bp->dev, pkt_size);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 	data = skb_put(skb, pkt_size);
+ 	eth_broadcast_addr(data);
+ 	i += ETH_ALEN;
+ 	ether_addr_copy(&data[i], bp->dev->dev_addr);
+ 	i += ETH_ALEN;
+ 	for ( ; i < pkt_size; i++)
+ 		data[i] = (u8)(i & 0xff);
+ 
+ 	map = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,
+ 			     PCI_DMA_TODEVICE);
+ 	if (dma_mapping_error(&bp->pdev->dev, map)) {
+ 		dev_kfree_skb(skb);
+ 		return -EIO;
+ 	}
+ 	bnxt_xmit_xdp(bp, txr, map, pkt_size, 0);
+ 
+ 	/* Sync BD data before updating doorbell */
+ 	wmb();
+ 
+ 	bnxt_db_write(bp, txr->tx_doorbell, DB_KEY_TX | txr->tx_prod);
+ 	rc = bnxt_poll_loopback(bp, pkt_size);
+ 
+ 	dma_unmap_single(&bp->pdev->dev, map, pkt_size, PCI_DMA_TODEVICE);
+ 	dev_kfree_skb(skb);
+ 	return rc;
+ }
+ 
+ static int bnxt_run_fw_tests(struct bnxt *bp, u8 test_mask, u8 *test_results)
+ {
+ 	struct hwrm_selftest_exec_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_exec_input req = {0};
+ 	int rc;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_EXEC, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	resp->test_success = 0;
+ 	req.flags = test_mask;
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), bp->test_info->timeout);
+ 	*test_results = resp->test_success;
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ 	return rc;
+ }
+ 
+ #define BNXT_DRV_TESTS			3
+ #define BNXT_MACLPBK_TEST_IDX		(bp->num_tests - BNXT_DRV_TESTS)
+ #define BNXT_PHYLPBK_TEST_IDX		(BNXT_MACLPBK_TEST_IDX + 1)
+ #define BNXT_IRQ_TEST_IDX		(BNXT_MACLPBK_TEST_IDX + 2)
+ 
+ static void bnxt_self_test(struct net_device *dev, struct ethtool_test *etest,
+ 			   u64 *buf)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	bool offline = false;
+ 	u8 test_results = 0;
+ 	u8 test_mask = 0;
+ 	int rc, i;
+ 
+ 	if (!bp->num_tests || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 	memset(buf, 0, sizeof(u64) * bp->num_tests);
+ 	if (!netif_running(dev)) {
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 		return;
+ 	}
+ 
+ 	if (etest->flags & ETH_TEST_FL_OFFLINE) {
+ 		if (bp->pf.active_vfs) {
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			netdev_warn(dev, "Offline tests cannot be run with active VFs\n");
+ 			return;
+ 		}
+ 		offline = true;
+ 	}
+ 
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if (!(bp->test_info->offline_mask & bit_val))
+ 			test_mask |= bit_val;
+ 		else if (offline)
+ 			test_mask |= bit_val;
+ 	}
+ 	if (!offline) {
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 	} else {
+ 		rc = bnxt_close_nic(bp, false, false);
+ 		if (rc)
+ 			return;
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 
+ 		buf[BNXT_MACLPBK_TEST_IDX] = 1;
+ 		bnxt_hwrm_mac_loopback(bp, true);
+ 		msleep(250);
+ 		rc = bnxt_half_open_nic(bp);
+ 		if (rc) {
+ 			bnxt_hwrm_mac_loopback(bp, false);
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			return;
+ 		}
+ 		if (bnxt_run_loopback(bp))
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		else
+ 			buf[BNXT_MACLPBK_TEST_IDX] = 0;
+ 
+ 		bnxt_hwrm_mac_loopback(bp, false);
+ 		bnxt_hwrm_phy_loopback(bp, true);
+ 		msleep(1000);
+ 		if (bnxt_run_loopback(bp)) {
+ 			buf[BNXT_PHYLPBK_TEST_IDX] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 		bnxt_hwrm_phy_loopback(bp, false);
+ 		bnxt_half_close_nic(bp);
+ 		bnxt_open_nic(bp, false, true);
+ 	}
+ 	if (bnxt_test_irq(bp)) {
+ 		buf[BNXT_IRQ_TEST_IDX] = 1;
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 	}
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if ((test_mask & bit_val) && !(test_results & bit_val)) {
+ 			buf[i] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 	}
+ }
+ 
+ static int bnxt_reset(struct net_device *dev, u32 *flags)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	int rc = 0;
+ 
+ 	if (!BNXT_PF(bp)) {
+ 		netdev_err(dev, "Reset is not supported from a VF\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (pci_vfs_assigned(bp->pdev)) {
+ 		netdev_err(dev,
+ 			   "Reset not allowed when VFs are assigned to VMs\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	if (*flags == ETH_RESET_ALL) {
+ 		/* This feature is not supported in older firmware versions */
+ 		if (bp->hwrm_spec_code < 0x10803)
+ 			return -EOPNOTSUPP;
+ 
+ 		rc = bnxt_firmware_reset(dev, BNXT_FW_RESET_CHIP);
+ 		if (!rc)
+ 			netdev_info(dev, "Reset request successful. Reload driver to complete reset\n");
+ 	} else if (*flags == ETH_RESET_AP) {
+ 		/* This feature is not supported in older firmware versions */
+ 		if (bp->hwrm_spec_code < 0x10803)
+ 			return -EOPNOTSUPP;
+ 
+ 		rc = bnxt_firmware_reset(dev, BNXT_FW_RESET_AP);
+ 		if (!rc)
+ 			netdev_info(dev, "Reset Application Processor request successful.\n");
+ 	} else {
+ 		rc = -EINVAL;
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ void bnxt_ethtool_init(struct bnxt *bp)
+ {
+ 	struct hwrm_selftest_qlist_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_qlist_input req = {0};
+ 	struct bnxt_test_info *test_info;
+ 	struct net_device *dev = bp->dev;
+ 	char *pkglog;
+ 	int i, rc;
+ 
+ 	pkglog = kzalloc(BNX_PKG_LOG_MAX_LENGTH, GFP_KERNEL);
+ 	if (pkglog) {
+ 		char *pkgver;
+ 		int len;
+ 
+ 		pkgver = bnxt_get_pkgver(dev, pkglog, BNX_PKG_LOG_MAX_LENGTH);
+ 		if (pkgver && *pkgver != 0 && isdigit(*pkgver)) {
+ 			len = strlen(bp->fw_ver_str);
+ 			snprintf(bp->fw_ver_str + len, FW_VER_STR_LEN - len - 1,
+ 				 "/pkg %s", pkgver);
+ 		}
+ 		kfree(pkglog);
+ 	}
+ 	if (bp->hwrm_spec_code < 0x10704 || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_QLIST, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		goto ethtool_init_exit;
+ 
+ 	test_info = kzalloc(sizeof(*bp->test_info), GFP_KERNEL);
+ 	if (!test_info)
+ 		goto ethtool_init_exit;
+ 
+ 	bp->test_info = test_info;
+ 	bp->num_tests = resp->num_tests + BNXT_DRV_TESTS;
+ 	if (bp->num_tests > BNXT_MAX_TEST)
+ 		bp->num_tests = BNXT_MAX_TEST;
+ 
+ 	test_info->offline_mask = resp->offline_tests;
+ 	test_info->timeout = le16_to_cpu(resp->test_timeout);
+ 	if (!test_info->timeout)
+ 		test_info->timeout = HWRM_CMD_TIMEOUT;
+ 	for (i = 0; i < bp->num_tests; i++) {
+ 		char *str = test_info->string[i];
+ 		char *fw_str = resp->test0_name + i * 32;
+ 
+ 		if (i == BNXT_MACLPBK_TEST_IDX) {
+ 			strcpy(str, "Mac loopback test (offline)");
+ 		} else if (i == BNXT_PHYLPBK_TEST_IDX) {
+ 			strcpy(str, "Phy loopback test (offline)");
+ 		} else if (i == BNXT_IRQ_TEST_IDX) {
+ 			strcpy(str, "Interrupt_test (offline)");
+ 		} else {
+ 			strlcpy(str, fw_str, ETH_GSTRING_LEN);
+ 			strncat(str, " test", ETH_GSTRING_LEN - strlen(str));
+ 			if (test_info->offline_mask & (1 << i))
+ 				strncat(str, " (offline)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 			else
+ 				strncat(str, " (online)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 		}
+ 	}
+ 
+ ethtool_init_exit:
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ }
+ 
+ void bnxt_ethtool_free(struct bnxt *bp)
+ {
+ 	kfree(bp->test_info);
+ 	bp->test_info = NULL;
+ }
+ 
++>>>>>>> 6502ad5963a5 (bnxt_en: Add ETH_RESET_AP support)
  const struct ethtool_ops bnxt_ethtool_ops = {
  	.get_link_ksettings	= bnxt_get_link_ksettings,
  	.set_link_ksettings	= bnxt_set_link_ksettings,
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
index 27621710e07b,836ef682f24c..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
@@@ -34,6 -34,9 +34,12 @@@ struct bnxt_led_cfg 
  #define BNXT_LED_DFLT_ENABLES(x)			\
  	cpu_to_le32(BNXT_LED_DFLT_ENA << (BNXT_LED_DFLT_ENA_SHIFT * (x)))
  
++<<<<<<< HEAD
++=======
+ #define BNXT_FW_RESET_AP	0xfffe
+ #define BNXT_FW_RESET_CHIP	0xffff
+ 
++>>>>>>> 6502ad5963a5 (bnxt_en: Add ETH_RESET_AP support)
  extern const struct ethtool_ops bnxt_ethtool_ops;
  
  u32 _bnxt_fw_to_ethtool_adv_spds(u16, u8);
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
