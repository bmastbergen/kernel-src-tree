nvme-fc: create fc class and transport device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author James Smart <jsmart2021@gmail.com>
commit 5f5685569ae8fccb0344373d823f2e4c59bb3d8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5f568556.failed

Added a new fc class and a device node for udev events under it.  I
expect the fc class will eventually be the location where the FC SCSI and
FC NVME merge in the future. Therefore names are kept somewhat generic.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 5f5685569ae8fccb0344373d823f2e4c59bb3d8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index 3d6f5a15d0aa,2dc9932e4818..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -199,9 -211,15 +199,16 @@@ static LIST_HEAD(nvme_fc_lport_list)
  static DEFINE_IDA(nvme_fc_local_port_cnt);
  static DEFINE_IDA(nvme_fc_ctrl_cnt);
  
 +static struct workqueue_struct *nvme_fc_wq;
  
  
+ /*
+  * These items are short-term. They will eventually be moved into
+  * a generic FC class. See comments in module init.
+  */
+ static struct class *fc_class;
+ static struct device *fc_udev_device;
+ 
  
  /* *********************** FC-NVME Port Management ************************ */
  
@@@ -2648,13 -3053,50 +2655,60 @@@ static struct nvmf_transport_ops nvme_f
  
  static int __init nvme_fc_init_module(void)
  {
++<<<<<<< HEAD
 +	mark_tech_preview("NVMe over FC", THIS_MODULE);
 +
 +	nvme_fc_wq = create_workqueue("nvme_fc_wq");
 +	if (!nvme_fc_wq)
 +		return -ENOMEM;
 +
 +	return nvmf_register_transport(&nvme_fc_transport);
++=======
+ 	int ret;
+ 
+ 	/*
+ 	 * NOTE:
+ 	 * It is expected that in the future the kernel will combine
+ 	 * the FC-isms that are currently under scsi and now being
+ 	 * added to by NVME into a new standalone FC class. The SCSI
+ 	 * and NVME protocols and their devices would be under this
+ 	 * new FC class.
+ 	 *
+ 	 * As we need something to post FC-specific udev events to,
+ 	 * specifically for nvme probe events, start by creating the
+ 	 * new device class.  When the new standalone FC class is
+ 	 * put in place, this code will move to a more generic
+ 	 * location for the class.
+ 	 */
+ 	fc_class = class_create(THIS_MODULE, "fc");
+ 	if (IS_ERR(fc_class)) {
+ 		pr_err("couldn't register class fc\n");
+ 		return PTR_ERR(fc_class);
+ 	}
+ 
+ 	/*
+ 	 * Create a device for the FC-centric udev events
+ 	 */
+ 	fc_udev_device = device_create(fc_class, NULL, MKDEV(0, 0), NULL,
+ 				"fc_udev_device");
+ 	if (IS_ERR(fc_udev_device)) {
+ 		pr_err("couldn't create fc_udev device!\n");
+ 		ret = PTR_ERR(fc_udev_device);
+ 		goto out_destroy_class;
+ 	}
+ 
+ 	ret = nvmf_register_transport(&nvme_fc_transport);
+ 	if (ret)
+ 		goto out_destroy_device;
+ 
+ 	return 0;
+ 
+ out_destroy_device:
+ 	device_destroy(fc_class, MKDEV(0, 0));
+ out_destroy_class:
+ 	class_destroy(fc_class);
+ 	return ret;
++>>>>>>> 5f5685569ae8 (nvme-fc: create fc class and transport device)
  }
  
  static void __exit nvme_fc_exit_module(void)
@@@ -2665,10 -3107,11 +2719,13 @@@
  
  	nvmf_unregister_transport(&nvme_fc_transport);
  
 +	destroy_workqueue(nvme_fc_wq);
 +
  	ida_destroy(&nvme_fc_local_port_cnt);
  	ida_destroy(&nvme_fc_ctrl_cnt);
+ 
+ 	device_destroy(fc_class, MKDEV(0, 0));
+ 	class_destroy(fc_class);
  }
  
  module_init(nvme_fc_init_module);
* Unmerged path drivers/nvme/host/fc.c
