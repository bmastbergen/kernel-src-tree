nfp: avoid buffer leak when representor is missing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 1691a4c0f4634d50ffeb74373fdeec63495c911e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1691a4c0.failed

When driver receives a muxed frame, but it can't find the representor
netdev it is destined to it will try to "drop" that frame, i.e. reuse
the buffer.  The issue is that the replacement buffer has already been
allocated at this point, and reusing the buffer from received frame
will leak it.  Change the code to put the new buffer on the ring
earlier and not reuse the old buffer (make the buffer parameter
to nfp_net_rx_drop() a NULL).

Fixes: 91bf82ca9eed ("nfp: add support for tx/rx with metadata portid")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1691a4c0f4634d50ffeb74373fdeec63495c911e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index c5dd3ed86a0e,1ff0c577819e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1447,20 -1751,34 +1447,42 @@@ static int nfp_net_rx(struct nfp_net_rx
  			continue;
  		}
  
++<<<<<<< HEAD
 +		nfp_net_dma_unmap_rx(nn, rx_ring->rxbufs[idx].dma_addr,
 +				     nn->fl_bufsz, DMA_FROM_DEVICE);
 +
 +		nfp_net_rx_give_one(rx_ring, new_frag, new_dma_addr);
 +
 +		skb_reserve(skb, data_off);
++=======
+ 		nfp_net_dma_unmap_rx(dp, rxbuf->dma_addr);
+ 
+ 		nfp_net_rx_give_one(dp, rx_ring, new_frag, new_dma_addr);
+ 
+ 		if (likely(!meta.portid)) {
+ 			netdev = dp->netdev;
+ 		} else {
+ 			struct nfp_net *nn;
+ 
+ 			nn = netdev_priv(dp->netdev);
+ 			netdev = nfp_app_repr_get(nn->app, meta.portid);
+ 			if (unlikely(!netdev)) {
+ 				nfp_net_rx_drop(dp, r_vec, rx_ring, NULL, skb);
+ 				continue;
+ 			}
+ 			nfp_repr_inc_rx_stats(netdev, pkt_len);
+ 		}
+ 
+ 		skb_reserve(skb, pkt_off);
++>>>>>>> 1691a4c0f463 (nfp: avoid buffer leak when representor is missing)
  		skb_put(skb, pkt_len);
  
 -		skb->mark = meta.mark;
 -		skb_set_hash(skb, meta.hash, meta.hash_type);
 +		nfp_net_set_hash_desc(nn->netdev, skb, rxd);
  
  		skb_record_rx_queue(skb, rx_ring->idx);
 -		skb->protocol = eth_type_trans(skb, netdev);
 +		skb->protocol = eth_type_trans(skb, nn->netdev);
  
 -		nfp_net_rx_csum(dp, r_vec, rxd, &meta, skb);
 +		nfp_net_rx_csum(nn, r_vec, rxd, skb);
  
  		if (rxd->rxd.flags & PCIE_DESC_RX_VLAN)
  			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
