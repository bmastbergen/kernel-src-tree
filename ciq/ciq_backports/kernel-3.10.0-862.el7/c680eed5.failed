i2c: do not try to load modules for of-registered devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [i2c] do not try to load modules for of-registered devices (Gopal Tiwari) [1456705]
Rebuild_FUZZ: 95.41%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit c680eed5ccd4a1c99ee48cd41f4e5fdfad497dc2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c680eed5.failed

Trying to register an I2C device asynchronously (via async_schedule() call)
results in an ugly warning from request_module() warning about potential
deadlock (because request_module tries to wait for async works to
complete). While we could try to switch to request_module_nowait(), other
buses, as well as I2C itself when not using device tree, do not try to load
modules, but rather rely on the standard infrastructure (udev) to execute
module loading, and we should be doing the same.

	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit c680eed5ccd4a1c99ee48cd41f4e5fdfad497dc2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/i2c-core.c
diff --cc drivers/i2c/i2c-core.c
index dc4010bd2179,72d53e40ebab..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -1075,9 -1254,55 +1075,59 @@@ static inline void acpi_i2c_register_de
  /* OF support code */
  
  #if IS_ENABLED(CONFIG_OF)
++<<<<<<< HEAD
++=======
+ static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,
+ 						 struct device_node *node)
+ {
+ 	struct i2c_client *result;
+ 	struct i2c_board_info info = {};
+ 	struct dev_archdata dev_ad = {};
+ 	const __be32 *addr;
+ 	int len;
+ 
+ 	dev_dbg(&adap->dev, "of_i2c: register %s\n", node->full_name);
+ 
+ 	if (of_modalias_node(node, info.type, sizeof(info.type)) < 0) {
+ 		dev_err(&adap->dev, "of_i2c: modalias failure on %s\n",
+ 			node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	addr = of_get_property(node, "reg", &len);
+ 	if (!addr || (len < sizeof(int))) {
+ 		dev_err(&adap->dev, "of_i2c: invalid reg on %s\n",
+ 			node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	info.addr = be32_to_cpup(addr);
+ 	if (info.addr > (1 << 10) - 1) {
+ 		dev_err(&adap->dev, "of_i2c: invalid addr=%x on %s\n",
+ 			info.addr, node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	info.of_node = of_node_get(node);
+ 	info.archdata = &dev_ad;
+ 
+ 	if (of_get_property(node, "wakeup-source", NULL))
+ 		info.flags |= I2C_CLIENT_WAKE;
+ 
+ 	result = i2c_new_device(adap, &info);
+ 	if (result == NULL) {
+ 		dev_err(&adap->dev, "of_i2c: Failure registering %s\n",
+ 			node->full_name);
+ 		of_node_put(node);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 	return result;
+ }
+ 
++>>>>>>> c680eed5ccd4 (i2c: do not try to load modules for of-registered devices)
  static void of_i2c_register_devices(struct i2c_adapter *adap)
  {
 +	void *result;
  	struct device_node *node;
  
  	/* Only register child devices if the adapter has a node pointer set */
* Unmerged path drivers/i2c/i2c-core.c
