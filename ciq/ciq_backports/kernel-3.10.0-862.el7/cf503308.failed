net/mlx5e: Add missing support for PTP_CLK_REQ_PPS request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add missing support for PTP_CLK_REQ_PPS request (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.43%
commit-author Eugenia Emantayev <eugenia@mellanox.com>
commit cf5033089b078303b102b65e3ccbbfa3ce0f4367
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cf503308.failed

Add the missing option to enable the PTP_CLK_PPS function.
In this case pin should be configured as 1PPS IN first and
then it will be connected to PPS mechanism.
Events will be reported as PTP_CLOCK_PPSUSR events to relevant sysfs.

Fixes: ee7f12205abc ('net/mlx5e: Implement 1PPS support')
	Signed-off-by: Eugenia Emantayev <eugenia@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit cf5033089b078303b102b65e3ccbbfa3ce0f4367)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 08e121a5e7e2,0039b4725405..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -253,6 -266,14 +253,17 @@@ struct mlx5e_dcbx 
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ #define MAX_PIN_NUM	8
+ struct mlx5e_pps {
+ 	u8                         pin_caps[MAX_PIN_NUM];
+ 	struct work_struct         out_work;
+ 	u64                        start[MAX_PIN_NUM];
+ 	u8                         enabled;
+ };
+ 
++>>>>>>> cf5033089b07 (net/mlx5e: Add missing support for PTP_CLK_REQ_PPS request)
  struct mlx5e_tstamp {
  	rwlock_t                   lock;
  	struct cyclecounter        cycles;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
index 4a787dea75a4,ba355c6b6e1f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
@@@ -308,34 -348,62 +308,45 @@@ static int mlx5e_perout_configure(struc
  				   rq->perout.index);
  		if (pin < 0)
  			return -EBUSY;
 +	}
  
 -		pin_mode = MLX5E_PIN_MODE_OUT;
 -		pattern = MLX5E_OUT_PATTERN_PERIODIC;
 -		ts.tv_sec = rq->perout.period.sec;
 -		ts.tv_nsec = rq->perout.period.nsec;
 -		ns = timespec64_to_ns(&ts);
 -
 +	ts.tv_sec = rq->perout.period.sec;
 +	ts.tv_nsec = rq->perout.period.nsec;
 +	ns = timespec64_to_ns(&ts);
 +	if (on)
  		if ((ns >> 1) != 500000000LL)
  			return -EINVAL;
 -
 -		ts.tv_sec = rq->perout.start.sec;
 -		ts.tv_nsec = rq->perout.start.nsec;
 -		ns = timespec64_to_ns(&ts);
 -		cycles_now = mlx5_read_internal_timer(tstamp->mdev);
 -		write_lock_irqsave(&tstamp->lock, flags);
 -		nsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);
 -		nsec_delta = ns - nsec_now;
 -		cycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,
 -					 tstamp->cycles.mult);
 -		write_unlock_irqrestore(&tstamp->lock, flags);
 -		time_stamp = cycles_now + cycles_delta;
 -		field_select = MLX5E_MTPPS_FS_PIN_MODE |
 -			       MLX5E_MTPPS_FS_PATTERN |
 -			       MLX5E_MTPPS_FS_ENABLE |
 -			       MLX5E_MTPPS_FS_TIME_STAMP;
 -	} else {
 -		pin = rq->perout.index;
 -		field_select = MLX5E_MTPPS_FS_ENABLE;
 -	}
 -
 +	ts.tv_sec = rq->perout.start.sec;
 +	ts.tv_nsec = rq->perout.start.nsec;
 +	ns = timespec64_to_ns(&ts);
 +	cycles_now = mlx5_read_internal_timer(tstamp->mdev);
 +	write_lock_irqsave(&tstamp->lock, flags);
 +	nsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);
 +	nsec_delta = ns - nsec_now;
 +	cycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,
 +				 tstamp->cycles.mult);
 +	write_unlock_irqrestore(&tstamp->lock, flags);
 +	time_stamp = cycles_now + cycles_delta;
  	MLX5_SET(mtpps_reg, in, pin, pin);
 -	MLX5_SET(mtpps_reg, in, pin_mode, pin_mode);
 -	MLX5_SET(mtpps_reg, in, pattern, pattern);
 +	MLX5_SET(mtpps_reg, in, pin_mode, MLX5E_PIN_MODE_OUT);
 +	MLX5_SET(mtpps_reg, in, pattern, MLX5E_OUT_PATTERN_PERIODIC);
  	MLX5_SET(mtpps_reg, in, enable, on);
  	MLX5_SET64(mtpps_reg, in, time_stamp, time_stamp);
 -	MLX5_SET(mtpps_reg, in, field_select, field_select);
  
 -	err = mlx5_set_mtpps(priv->mdev, in, sizeof(in));
 -	if (err)
 -		return err;
 -
 -	return mlx5_set_mtppse(priv->mdev, pin, 0,
 -			       MLX5E_EVENT_MODE_REPETETIVE & on);
 +	return mlx5_set_mtpps(priv->mdev, in, sizeof(in));
  }
  
+ static int mlx5e_pps_configure(struct ptp_clock_info *ptp,
+ 			       struct ptp_clock_request *rq,
+ 			       int on)
+ {
+ 	struct mlx5e_tstamp *tstamp =
+ 		container_of(ptp, struct mlx5e_tstamp, ptp_info);
+ 
+ 	tstamp->pps_info.enabled = !!on;
+ 	return 0;
+ }
+ 
  static int mlx5e_ptp_enable(struct ptp_clock_info *ptp,
  			    struct ptp_clock_request *rq,
  			    int on)
@@@ -430,9 -501,43 +444,40 @@@ static void mlx5e_get_pps_caps(struct m
  void mlx5e_pps_event_handler(struct mlx5e_priv *priv,
  			     struct ptp_clock_event *event)
  {
 -	struct net_device *netdev = priv->netdev;
  	struct mlx5e_tstamp *tstamp = &priv->tstamp;
 -	struct timespec64 ts;
 -	u64 nsec_now, nsec_delta;
 -	u64 cycles_now, cycles_delta;
 -	int pin = event->index;
 -	s64 ns;
 -	unsigned long flags;
  
++<<<<<<< HEAD
 +	ptp_clock_event(tstamp->ptp, event);
++=======
+ 	switch (tstamp->ptp_info.pin_config[pin].func) {
+ 	case PTP_PF_EXTTS:
+ 		if (tstamp->pps_info.enabled) {
+ 			event->type = PTP_CLOCK_PPSUSR;
+ 			event->pps_times.ts_real = ns_to_timespec64(event->timestamp);
+ 		} else {
+ 			event->type = PTP_CLOCK_EXTTS;
+ 		}
+ 		ptp_clock_event(tstamp->ptp, event);
+ 		break;
+ 	case PTP_PF_PEROUT:
+ 		mlx5e_ptp_gettime(&tstamp->ptp_info, &ts);
+ 		cycles_now = mlx5_read_internal_timer(tstamp->mdev);
+ 		ts.tv_sec += 1;
+ 		ts.tv_nsec = 0;
+ 		ns = timespec64_to_ns(&ts);
+ 		write_lock_irqsave(&tstamp->lock, flags);
+ 		nsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);
+ 		nsec_delta = ns - nsec_now;
+ 		cycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,
+ 					 tstamp->cycles.mult);
+ 		tstamp->pps_info.start[pin] = cycles_now + cycles_delta;
+ 		queue_work(priv->wq, &tstamp->pps_info.out_work);
+ 		write_unlock_irqrestore(&tstamp->lock, flags);
+ 		break;
+ 	default:
+ 		netdev_err(netdev, "%s: Unhandled event\n", __func__);
+ 	}
++>>>>>>> cf5033089b07 (net/mlx5e: Add missing support for PTP_CLK_REQ_PPS request)
  }
  
  void mlx5e_timestamp_init(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_clock.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 5a367b6ed375..8ccf5a2287e3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -358,7 +358,6 @@ static void mlx5e_async_event(struct mlx5_core_dev *mdev, void *vpriv,
 		break;
 	case MLX5_DEV_EVENT_PPS:
 		eqe = (struct mlx5_eqe *)param;
-		ptp_event.type = PTP_CLOCK_EXTTS;
 		ptp_event.index = eqe->data.pps.pin;
 		ptp_event.timestamp =
 			timecounter_cyc2time(&priv->tstamp.clock,
