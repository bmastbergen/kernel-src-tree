qede: Configure UDP ports in local context.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] qede: Configure UDP ports in local context (Don Dutile) [1462432]
Rebuild_FUZZ: 98.82%
commit-author Chopra, Manish <Manish.Chopra@cavium.com>
commit 327a2b750c486c8e8f390dcff888881ad54d2f23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/327a2b75.failed

This patch configures UDP ports locally instead of
configuring them in deferred context which would be
helpful in synchronizing UDP ports configuration for VFs
which will be enabled in further patches.

	Signed-off-by: Manish Chopra <manish.chopra@cavium.com>
	Signed-off-by: Yuval Mintz <yuval.mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 327a2b750c486c8e8f390dcff888881ad54d2f23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qede/qede_filter.c
#	drivers/net/ethernet/qlogic/qede/qede_main.c
diff --cc drivers/net/ethernet/qlogic/qede/qede_filter.c
index 8c7b25fc9fd0,4fa2c88e9693..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_filter.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_filter.c
@@@ -432,75 -880,158 +432,184 @@@ int qede_set_features(struct net_devic
  	return 0;
  }
  
 -void qede_udp_tunnel_add(struct net_device *dev, struct udp_tunnel_info *ti)
 +#ifdef CONFIG_QEDE_VXLAN
 +void qede_add_vxlan_port(struct net_device *dev,
 +			 sa_family_t sa_family, __be16 port)
  {
  	struct qede_dev *edev = netdev_priv(dev);
++<<<<<<< HEAD
 +	u16 t_port = ntohs(port);
 +
 +	if (edev->vxlan_dst_port)
 +		return;
 +
 +	edev->vxlan_dst_port = t_port;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Added vxlan port=%d", t_port);
 +
 +	set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
 +}
 +
 +void qede_del_vxlan_port(struct net_device *dev,
 +			 sa_family_t sa_family, __be16 port)
 +{
 +	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
 +
 +	if (t_port != edev->vxlan_dst_port)
 +		return;
 +
 +	edev->vxlan_dst_port = 0;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted vxlan port=%d", t_port);
 +
 +	set_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
 +}
 +#endif
 +
 +#ifdef CONFIG_QEDE_GENEVE
 +void qede_add_geneve_port(struct net_device *dev,
 +			  sa_family_t sa_family, __be16 port)
 +{
 +	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
 +
 +	if (edev->geneve_dst_port)
 +		return;
 +
 +	edev->geneve_dst_port = t_port;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Added geneve port=%d", t_port);
 +	set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
++=======
+ 	struct qed_tunn_params tunn_params;
+ 	u16 t_port = ntohs(ti->port);
+ 	int rc;
+ 
+ 	memset(&tunn_params, 0, sizeof(tunn_params));
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (!edev->dev_info.common.vxlan_enable)
+ 			return;
+ 
+ 		if (edev->vxlan_dst_port)
+ 			return;
+ 
+ 		tunn_params.update_vxlan_port = 1;
+ 		tunn_params.vxlan_port = t_port;
+ 
+ 		__qede_lock(edev);
+ 		rc = edev->ops->tunn_config(edev->cdev, &tunn_params);
+ 		__qede_unlock(edev);
+ 
+ 		if (!rc) {
+ 			edev->vxlan_dst_port = t_port;
+ 			DP_VERBOSE(edev, QED_MSG_DEBUG, "Added vxlan port=%d\n",
+ 				   t_port);
+ 		} else {
+ 			DP_NOTICE(edev, "Failed to add vxlan UDP port=%d\n",
+ 				  t_port);
+ 		}
+ 
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (!edev->dev_info.common.geneve_enable)
+ 			return;
+ 
+ 		if (edev->geneve_dst_port)
+ 			return;
+ 
+ 		tunn_params.update_geneve_port = 1;
+ 		tunn_params.geneve_port = t_port;
+ 
+ 		__qede_lock(edev);
+ 		rc = edev->ops->tunn_config(edev->cdev, &tunn_params);
+ 		__qede_unlock(edev);
+ 
+ 		if (!rc) {
+ 			edev->geneve_dst_port = t_port;
+ 			DP_VERBOSE(edev, QED_MSG_DEBUG,
+ 				   "Added geneve port=%d\n", t_port);
+ 		} else {
+ 			DP_NOTICE(edev, "Failed to add geneve UDP port=%d\n",
+ 				  t_port);
+ 		}
+ 
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ }
+ 
+ void qede_udp_tunnel_del(struct net_device *dev,
+ 			 struct udp_tunnel_info *ti)
+ {
+ 	struct qede_dev *edev = netdev_priv(dev);
+ 	struct qed_tunn_params tunn_params;
+ 	u16 t_port = ntohs(ti->port);
+ 
+ 	memset(&tunn_params, 0, sizeof(tunn_params));
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (t_port != edev->vxlan_dst_port)
+ 			return;
+ 
+ 		tunn_params.update_vxlan_port = 1;
+ 		tunn_params.vxlan_port = 0;
+ 
+ 		__qede_lock(edev);
+ 		edev->ops->tunn_config(edev->cdev, &tunn_params);
+ 		__qede_unlock(edev);
+ 
+ 		edev->vxlan_dst_port = 0;
+ 
+ 		DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted vxlan port=%d\n",
+ 			   t_port);
+ 
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (t_port != edev->geneve_dst_port)
+ 			return;
+ 
+ 		tunn_params.update_geneve_port = 1;
+ 		tunn_params.geneve_port = 0;
+ 
+ 		__qede_lock(edev);
+ 		edev->ops->tunn_config(edev->cdev, &tunn_params);
+ 		__qede_unlock(edev);
+ 
+ 		edev->geneve_dst_port = 0;
+ 
+ 		DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted geneve port=%d\n",
+ 			   t_port);
+ 		break;
+ 	default:
+ 		return;
+ 	}
++>>>>>>> 327a2b750c48 (qede: Configure UDP ports in local context.)
  }
  
 -static void qede_xdp_reload_func(struct qede_dev *edev,
 -				 struct qede_reload_args *args)
 -{
 -	struct bpf_prog *old;
 -
 -	old = xchg(&edev->xdp_prog, args->u.new_prog);
 -	if (old)
 -		bpf_prog_put(old);
 -}
 -
 -static int qede_xdp_set(struct qede_dev *edev, struct bpf_prog *prog)
 -{
 -	struct qede_reload_args args;
 -
 -	/* If we're called, there was already a bpf reference increment */
 -	args.func = &qede_xdp_reload_func;
 -	args.u.new_prog = prog;
 -	qede_reload(edev, &args, false);
 -
 -	return 0;
 -}
 -
 -int qede_xdp(struct net_device *dev, struct netdev_xdp *xdp)
 +void qede_del_geneve_port(struct net_device *dev,
 +			  sa_family_t sa_family, __be16 port)
  {
  	struct qede_dev *edev = netdev_priv(dev);
 +	u16 t_port = ntohs(port);
  
 -	if (IS_VF(edev)) {
 -		DP_NOTICE(edev, "VFs don't support XDP\n");
 -		return -EOPNOTSUPP;
 -	}
 +	if (t_port != edev->geneve_dst_port)
 +		return;
  
 -	switch (xdp->command) {
 -	case XDP_SETUP_PROG:
 -		return qede_xdp_set(edev, xdp->prog);
 -	case XDP_QUERY_PROG:
 -		xdp->prog_attached = !!edev->xdp_prog;
 -		return 0;
 -	default:
 -		return -EINVAL;
 -	}
 +	edev->geneve_dst_port = 0;
 +
 +	DP_VERBOSE(edev, QED_MSG_DEBUG, "Deleted geneve port=%d", t_port);
 +	set_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags);
 +	schedule_delayed_work(&edev->sp_task, 0);
  }
 +#endif
  
  static int qede_set_mcast_rx_mac(struct qede_dev *edev,
  				 enum qed_filter_xcast_params_type opcode,
diff --cc drivers/net/ethernet/qlogic/qede/qede_main.c
index 9490909958e8,f57c823730c0..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@@ -777,24 -803,12 +776,33 @@@ static void qede_sp_task(struct work_st
  		if (edev->state == QEDE_STATE_OPEN)
  			qede_config_rx_mode(edev->ndev);
  
++<<<<<<< HEAD
 +	if (test_and_clear_bit(QEDE_SP_VXLAN_PORT_CONFIG, &edev->sp_flags)) {
 +		struct qed_tunn_params tunn_params;
 +
 +		memset(&tunn_params, 0, sizeof(tunn_params));
 +		tunn_params.update_vxlan_port = 1;
 +		tunn_params.vxlan_port = edev->vxlan_dst_port;
 +		qed_ops->tunn_config(cdev, &tunn_params);
 +	}
 +
 +	if (test_and_clear_bit(QEDE_SP_GENEVE_PORT_CONFIG, &edev->sp_flags)) {
 +		struct qed_tunn_params tunn_params;
 +
 +		memset(&tunn_params, 0, sizeof(tunn_params));
 +		tunn_params.update_geneve_port = 1;
 +		tunn_params.geneve_port = edev->geneve_dst_port;
 +		qed_ops->tunn_config(cdev, &tunn_params);
 +	}
 +
++=======
+ #ifdef CONFIG_RFS_ACCEL
+ 	if (test_and_clear_bit(QEDE_SP_ARFS_CONFIG, &edev->sp_flags)) {
+ 		if (edev->state == QEDE_STATE_OPEN)
+ 			qede_process_arfs_filters(edev, false);
+ 	}
+ #endif
++>>>>>>> 327a2b750c48 (qede: Configure UDP ports in local context.)
  	__qede_unlock(edev);
  }
  
diff --git a/drivers/net/ethernet/qlogic/qede/qede.h b/drivers/net/ethernet/qlogic/qede/qede.h
index 01e3fd8091c0..60988e3d67fb 100644
--- a/drivers/net/ethernet/qlogic/qede/qede.h
+++ b/drivers/net/ethernet/qlogic/qede/qede.h
@@ -406,8 +406,6 @@ struct qede_fastpath {
 #define QEDE_TUNN_CSUM_UNNECESSARY	BIT(2)
 
 #define QEDE_SP_RX_MODE			1
-#define QEDE_SP_VXLAN_PORT_CONFIG	2
-#define QEDE_SP_GENEVE_PORT_CONFIG	3
 
 struct qede_reload_args {
 	void (*func)(struct qede_dev *edev, struct qede_reload_args *args);
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_filter.c
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_main.c
