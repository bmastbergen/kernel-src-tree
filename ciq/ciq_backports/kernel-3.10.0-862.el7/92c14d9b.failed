genetlink: simplify genl_notify

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 92c14d9b5ee86fd6cf136c01b6a87353522aebdd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/92c14d9b.failed

The genl_notify function has too many arguments for no real reason - all
callers use genl_info to get them anyway. Just pass the genl_info down to
genl_notify.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92c14d9b5ee86fd6cf136c01b6a87353522aebdd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mac80211_hwsim.c
diff --cc drivers/net/wireless/mac80211_hwsim.c
index cb34c7895f2a,66c963dbc3fd..000000000000
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@@ -1696,8 -2167,484 +1696,484 @@@ static struct ieee80211_ops mac80211_hw
  	.flush = mac80211_hwsim_flush,
  	.get_tsf = mac80211_hwsim_get_tsf,
  	.set_tsf = mac80211_hwsim_set_tsf,
 -	.get_et_sset_count = mac80211_hwsim_get_et_sset_count,
 -	.get_et_stats = mac80211_hwsim_get_et_stats,
 -	.get_et_strings = mac80211_hwsim_get_et_strings,
  };
  
++<<<<<<< HEAD
++=======
+ static struct ieee80211_ops mac80211_hwsim_mchan_ops;
+ 
+ struct hwsim_new_radio_params {
+ 	unsigned int channels;
+ 	const char *reg_alpha2;
+ 	const struct ieee80211_regdomain *regd;
+ 	bool reg_strict;
+ 	bool p2p_device;
+ 	bool use_chanctx;
+ 	bool destroy_on_close;
+ 	const char *hwname;
+ 	bool no_vif;
+ };
+ 
+ static void hwsim_mcast_config_msg(struct sk_buff *mcast_skb,
+ 				   struct genl_info *info)
+ {
+ 	if (info)
+ 		genl_notify(&hwsim_genl_family, mcast_skb, info,
+ 			    HWSIM_MCGRP_CONFIG, GFP_KERNEL);
+ 	else
+ 		genlmsg_multicast(&hwsim_genl_family, mcast_skb, 0,
+ 				  HWSIM_MCGRP_CONFIG, GFP_KERNEL);
+ }
+ 
+ static int append_radio_msg(struct sk_buff *skb, int id,
+ 			    struct hwsim_new_radio_params *param)
+ {
+ 	int ret;
+ 
+ 	ret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (param->channels) {
+ 		ret = nla_put_u32(skb, HWSIM_ATTR_CHANNELS, param->channels);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (param->reg_alpha2) {
+ 		ret = nla_put(skb, HWSIM_ATTR_REG_HINT_ALPHA2, 2,
+ 			      param->reg_alpha2);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (param->regd) {
+ 		int i;
+ 
+ 		for (i = 0; i < ARRAY_SIZE(hwsim_world_regdom_custom); i++) {
+ 			if (hwsim_world_regdom_custom[i] != param->regd)
+ 				continue;
+ 
+ 			ret = nla_put_u32(skb, HWSIM_ATTR_REG_CUSTOM_REG, i);
+ 			if (ret < 0)
+ 				return ret;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (param->reg_strict) {
+ 		ret = nla_put_flag(skb, HWSIM_ATTR_REG_STRICT_REG);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (param->p2p_device) {
+ 		ret = nla_put_flag(skb, HWSIM_ATTR_SUPPORT_P2P_DEVICE);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (param->use_chanctx) {
+ 		ret = nla_put_flag(skb, HWSIM_ATTR_USE_CHANCTX);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	if (param->hwname) {
+ 		ret = nla_put(skb, HWSIM_ATTR_RADIO_NAME,
+ 			      strlen(param->hwname), param->hwname);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void hwsim_mcast_new_radio(int id, struct genl_info *info,
+ 				  struct hwsim_new_radio_params *param)
+ {
+ 	struct sk_buff *mcast_skb;
+ 	void *data;
+ 
+ 	mcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!mcast_skb)
+ 		return;
+ 
+ 	data = genlmsg_put(mcast_skb, 0, 0, &hwsim_genl_family, 0,
+ 			   HWSIM_CMD_NEW_RADIO);
+ 	if (!data)
+ 		goto out_err;
+ 
+ 	if (append_radio_msg(mcast_skb, id, param) < 0)
+ 		goto out_err;
+ 
+ 	genlmsg_end(mcast_skb, data);
+ 
+ 	hwsim_mcast_config_msg(mcast_skb, info);
+ 	return;
+ 
+ out_err:
+ 	genlmsg_cancel(mcast_skb, data);
+ 	nlmsg_free(mcast_skb);
+ }
+ 
+ static int mac80211_hwsim_new_radio(struct genl_info *info,
+ 				    struct hwsim_new_radio_params *param)
+ {
+ 	int err;
+ 	u8 addr[ETH_ALEN];
+ 	struct mac80211_hwsim_data *data;
+ 	struct ieee80211_hw *hw;
+ 	enum ieee80211_band band;
+ 	const struct ieee80211_ops *ops = &mac80211_hwsim_ops;
+ 	int idx;
+ 
+ 	if (WARN_ON(param->channels > 1 && !param->use_chanctx))
+ 		return -EINVAL;
+ 
+ 	spin_lock_bh(&hwsim_radio_lock);
+ 	idx = hwsim_radio_idx++;
+ 	spin_unlock_bh(&hwsim_radio_lock);
+ 
+ 	if (param->use_chanctx)
+ 		ops = &mac80211_hwsim_mchan_ops;
+ 	hw = ieee80211_alloc_hw_nm(sizeof(*data), ops, param->hwname);
+ 	if (!hw) {
+ 		printk(KERN_DEBUG "mac80211_hwsim: ieee80211_alloc_hw failed\n");
+ 		err = -ENOMEM;
+ 		goto failed;
+ 	}
+ 	data = hw->priv;
+ 	data->hw = hw;
+ 
+ 	data->dev = device_create(hwsim_class, NULL, 0, hw, "hwsim%d", idx);
+ 	if (IS_ERR(data->dev)) {
+ 		printk(KERN_DEBUG
+ 		       "mac80211_hwsim: device_create failed (%ld)\n",
+ 		       PTR_ERR(data->dev));
+ 		err = -ENOMEM;
+ 		goto failed_drvdata;
+ 	}
+ 	data->dev->driver = &mac80211_hwsim_driver.driver;
+ 	err = device_bind_driver(data->dev);
+ 	if (err != 0) {
+ 		printk(KERN_DEBUG "mac80211_hwsim: device_bind_driver failed (%d)\n",
+ 		       err);
+ 		goto failed_bind;
+ 	}
+ 
+ 	skb_queue_head_init(&data->pending);
+ 
+ 	SET_IEEE80211_DEV(hw, data->dev);
+ 	eth_zero_addr(addr);
+ 	addr[0] = 0x02;
+ 	addr[3] = idx >> 8;
+ 	addr[4] = idx;
+ 	memcpy(data->addresses[0].addr, addr, ETH_ALEN);
+ 	memcpy(data->addresses[1].addr, addr, ETH_ALEN);
+ 	data->addresses[1].addr[0] |= 0x40;
+ 	hw->wiphy->n_addresses = 2;
+ 	hw->wiphy->addresses = data->addresses;
+ 
+ 	data->channels = param->channels;
+ 	data->use_chanctx = param->use_chanctx;
+ 	data->idx = idx;
+ 	data->destroy_on_close = param->destroy_on_close;
+ 	if (info)
+ 		data->portid = info->snd_portid;
+ 
+ 	if (data->use_chanctx) {
+ 		hw->wiphy->max_scan_ssids = 255;
+ 		hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+ 		hw->wiphy->max_remain_on_channel_duration = 1000;
+ 		/* For channels > 1 DFS is not allowed */
+ 		hw->wiphy->n_iface_combinations = 1;
+ 		hw->wiphy->iface_combinations = &data->if_combination;
+ 		if (param->p2p_device)
+ 			data->if_combination = hwsim_if_comb_p2p_dev[0];
+ 		else
+ 			data->if_combination = hwsim_if_comb[0];
+ 		data->if_combination.num_different_channels = data->channels;
+ 	} else if (param->p2p_device) {
+ 		hw->wiphy->iface_combinations = hwsim_if_comb_p2p_dev;
+ 		hw->wiphy->n_iface_combinations =
+ 			ARRAY_SIZE(hwsim_if_comb_p2p_dev);
+ 	} else {
+ 		hw->wiphy->iface_combinations = hwsim_if_comb;
+ 		hw->wiphy->n_iface_combinations = ARRAY_SIZE(hwsim_if_comb);
+ 	}
+ 
+ 	INIT_DELAYED_WORK(&data->roc_done, hw_roc_done);
+ 	INIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);
+ 
+ 	hw->queues = 5;
+ 	hw->offchannel_tx_hw_queue = 4;
+ 	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+ 				     BIT(NL80211_IFTYPE_AP) |
+ 				     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+ 				     BIT(NL80211_IFTYPE_P2P_GO) |
+ 				     BIT(NL80211_IFTYPE_ADHOC) |
+ 				     BIT(NL80211_IFTYPE_MESH_POINT);
+ 
+ 	if (param->p2p_device)
+ 		hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+ 
+ 	ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
+ 	ieee80211_hw_set(hw, CHANCTX_STA_CSA);
+ 	ieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);
+ 	ieee80211_hw_set(hw, QUEUE_CONTROL);
+ 	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
+ 	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+ 	ieee80211_hw_set(hw, MFP_CAPABLE);
+ 	ieee80211_hw_set(hw, SIGNAL_DBM);
+ 	ieee80211_hw_set(hw, TDLS_WIDER_BW);
+ 	if (rctbl)
+ 		ieee80211_hw_set(hw, SUPPORTS_RC_TABLE);
+ 
+ 	hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |
+ 			    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
+ 			    WIPHY_FLAG_AP_UAPSD |
+ 			    WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+ 	hw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |
+ 			       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |
+ 			       NL80211_FEATURE_STATIC_SMPS |
+ 			       NL80211_FEATURE_DYNAMIC_SMPS |
+ 			       NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;
+ 
+ 	/* ask mac80211 to reserve space for magic */
+ 	hw->vif_data_size = sizeof(struct hwsim_vif_priv);
+ 	hw->sta_data_size = sizeof(struct hwsim_sta_priv);
+ 	hw->chanctx_data_size = sizeof(struct hwsim_chanctx_priv);
+ 
+ 	memcpy(data->channels_2ghz, hwsim_channels_2ghz,
+ 		sizeof(hwsim_channels_2ghz));
+ 	memcpy(data->channels_5ghz, hwsim_channels_5ghz,
+ 		sizeof(hwsim_channels_5ghz));
+ 	memcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));
+ 
+ 	for (band = IEEE80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; band++) {
+ 		struct ieee80211_supported_band *sband = &data->bands[band];
+ 		switch (band) {
+ 		case IEEE80211_BAND_2GHZ:
+ 			sband->channels = data->channels_2ghz;
+ 			sband->n_channels = ARRAY_SIZE(hwsim_channels_2ghz);
+ 			sband->bitrates = data->rates;
+ 			sband->n_bitrates = ARRAY_SIZE(hwsim_rates);
+ 			break;
+ 		case IEEE80211_BAND_5GHZ:
+ 			sband->channels = data->channels_5ghz;
+ 			sband->n_channels = ARRAY_SIZE(hwsim_channels_5ghz);
+ 			sband->bitrates = data->rates + 4;
+ 			sband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;
+ 
+ 			sband->vht_cap.vht_supported = true;
+ 			sband->vht_cap.cap =
+ 				IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
+ 				IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |
+ 				IEEE80211_VHT_CAP_RXLDPC |
+ 				IEEE80211_VHT_CAP_SHORT_GI_80 |
+ 				IEEE80211_VHT_CAP_SHORT_GI_160 |
+ 				IEEE80211_VHT_CAP_TXSTBC |
+ 				IEEE80211_VHT_CAP_RXSTBC_1 |
+ 				IEEE80211_VHT_CAP_RXSTBC_2 |
+ 				IEEE80211_VHT_CAP_RXSTBC_3 |
+ 				IEEE80211_VHT_CAP_RXSTBC_4 |
+ 				IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
+ 			sband->vht_cap.vht_mcs.rx_mcs_map =
+ 				cpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 |
+ 					    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14);
+ 			sband->vht_cap.vht_mcs.tx_mcs_map =
+ 				sband->vht_cap.vht_mcs.rx_mcs_map;
+ 			break;
+ 		default:
+ 			continue;
+ 		}
+ 
+ 		sband->ht_cap.ht_supported = true;
+ 		sband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+ 				    IEEE80211_HT_CAP_GRN_FLD |
+ 				    IEEE80211_HT_CAP_SGI_20 |
+ 				    IEEE80211_HT_CAP_SGI_40 |
+ 				    IEEE80211_HT_CAP_DSSSCCK40;
+ 		sband->ht_cap.ampdu_factor = 0x3;
+ 		sband->ht_cap.ampdu_density = 0x6;
+ 		memset(&sband->ht_cap.mcs, 0,
+ 		       sizeof(sband->ht_cap.mcs));
+ 		sband->ht_cap.mcs.rx_mask[0] = 0xff;
+ 		sband->ht_cap.mcs.rx_mask[1] = 0xff;
+ 		sband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+ 
+ 		hw->wiphy->bands[band] = sband;
+ 	}
+ 
+ 	/* By default all radios belong to the first group */
+ 	data->group = 1;
+ 	mutex_init(&data->mutex);
+ 
+ 	/* Enable frame retransmissions for lossy channels */
+ 	hw->max_rates = 4;
+ 	hw->max_rate_tries = 11;
+ 
+ 	hw->wiphy->vendor_commands = mac80211_hwsim_vendor_commands;
+ 	hw->wiphy->n_vendor_commands =
+ 		ARRAY_SIZE(mac80211_hwsim_vendor_commands);
+ 	hw->wiphy->vendor_events = mac80211_hwsim_vendor_events;
+ 	hw->wiphy->n_vendor_events = ARRAY_SIZE(mac80211_hwsim_vendor_events);
+ 
+ 	if (param->reg_strict)
+ 		hw->wiphy->regulatory_flags |= REGULATORY_STRICT_REG;
+ 	if (param->regd) {
+ 		data->regd = param->regd;
+ 		hw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+ 		wiphy_apply_custom_regulatory(hw->wiphy, param->regd);
+ 		/* give the regulatory workqueue a chance to run */
+ 		schedule_timeout_interruptible(1);
+ 	}
+ 
+ 	if (param->no_vif)
+ 		ieee80211_hw_set(hw, NO_AUTO_VIF);
+ 
+ 	err = ieee80211_register_hw(hw);
+ 	if (err < 0) {
+ 		printk(KERN_DEBUG "mac80211_hwsim: ieee80211_register_hw failed (%d)\n",
+ 		       err);
+ 		goto failed_hw;
+ 	}
+ 
+ 	wiphy_debug(hw->wiphy, "hwaddr %pM registered\n", hw->wiphy->perm_addr);
+ 
+ 	if (param->reg_alpha2) {
+ 		data->alpha2[0] = param->reg_alpha2[0];
+ 		data->alpha2[1] = param->reg_alpha2[1];
+ 		regulatory_hint(hw->wiphy, param->reg_alpha2);
+ 	}
+ 
+ 	data->debugfs = debugfs_create_dir("hwsim", hw->wiphy->debugfsdir);
+ 	debugfs_create_file("ps", 0666, data->debugfs, data, &hwsim_fops_ps);
+ 	debugfs_create_file("group", 0666, data->debugfs, data,
+ 			    &hwsim_fops_group);
+ 	if (!data->use_chanctx)
+ 		debugfs_create_file("dfs_simulate_radar", 0222,
+ 				    data->debugfs,
+ 				    data, &hwsim_simulate_radar);
+ 
+ 	tasklet_hrtimer_init(&data->beacon_timer,
+ 			     mac80211_hwsim_beacon,
+ 			     CLOCK_MONOTONIC_RAW, HRTIMER_MODE_ABS);
+ 
+ 	spin_lock_bh(&hwsim_radio_lock);
+ 	list_add_tail(&data->list, &hwsim_radios);
+ 	spin_unlock_bh(&hwsim_radio_lock);
+ 
+ 	if (idx > 0)
+ 		hwsim_mcast_new_radio(idx, info, param);
+ 
+ 	return idx;
+ 
+ failed_hw:
+ 	device_release_driver(data->dev);
+ failed_bind:
+ 	device_unregister(data->dev);
+ failed_drvdata:
+ 	ieee80211_free_hw(hw);
+ failed:
+ 	return err;
+ }
+ 
+ static void hwsim_mcast_del_radio(int id, const char *hwname,
+ 				  struct genl_info *info)
+ {
+ 	struct sk_buff *skb;
+ 	void *data;
+ 	int ret;
+ 
+ 	skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!skb)
+ 		return;
+ 
+ 	data = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,
+ 			   HWSIM_CMD_DEL_RADIO);
+ 	if (!data)
+ 		goto error;
+ 
+ 	ret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	ret = nla_put(skb, HWSIM_ATTR_RADIO_NAME, strlen(hwname),
+ 		      hwname);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	genlmsg_end(skb, data);
+ 
+ 	hwsim_mcast_config_msg(skb, info);
+ 
+ 	return;
+ 
+ error:
+ 	nlmsg_free(skb);
+ }
+ 
+ static void mac80211_hwsim_del_radio(struct mac80211_hwsim_data *data,
+ 				     const char *hwname,
+ 				     struct genl_info *info)
+ {
+ 	hwsim_mcast_del_radio(data->idx, hwname, info);
+ 	debugfs_remove_recursive(data->debugfs);
+ 	ieee80211_unregister_hw(data->hw);
+ 	device_release_driver(data->dev);
+ 	device_unregister(data->dev);
+ 	ieee80211_free_hw(data->hw);
+ }
+ 
+ static int mac80211_hwsim_get_radio(struct sk_buff *skb,
+ 				    struct mac80211_hwsim_data *data,
+ 				    u32 portid, u32 seq,
+ 				    struct netlink_callback *cb, int flags)
+ {
+ 	void *hdr;
+ 	struct hwsim_new_radio_params param = { };
+ 	int res = -EMSGSIZE;
+ 
+ 	hdr = genlmsg_put(skb, portid, seq, &hwsim_genl_family, flags,
+ 			  HWSIM_CMD_GET_RADIO);
+ 	if (!hdr)
+ 		return -EMSGSIZE;
+ 
+ 	if (cb)
+ 		genl_dump_check_consistent(cb, hdr, &hwsim_genl_family);
+ 
+ 	if (data->alpha2[0] && data->alpha2[1])
+ 		param.reg_alpha2 = data->alpha2;
+ 
+ 	param.reg_strict = !!(data->hw->wiphy->regulatory_flags &
+ 					REGULATORY_STRICT_REG);
+ 	param.p2p_device = !!(data->hw->wiphy->interface_modes &
+ 					BIT(NL80211_IFTYPE_P2P_DEVICE));
+ 	param.use_chanctx = data->use_chanctx;
+ 	param.regd = data->regd;
+ 	param.channels = data->channels;
+ 	param.hwname = wiphy_name(data->hw->wiphy);
+ 
+ 	res = append_radio_msg(skb, data->idx, &param);
+ 	if (res < 0)
+ 		goto out_err;
+ 
+ 	genlmsg_end(skb, hdr);
+ 	return 0;
+ 
+ out_err:
+ 	genlmsg_cancel(skb, hdr);
+ 	return res;
+ }
++>>>>>>> 92c14d9b5ee8 (genetlink: simplify genl_notify)
  
  static void mac80211_hwsim_free(void)
  {
* Unmerged path drivers/net/wireless/mac80211_hwsim.c
diff --git a/include/net/genetlink.h b/include/net/genetlink.h
index f37e06abcb6d..b6b5a29fc0b3 100644
--- a/include/net/genetlink.h
+++ b/include/net/genetlink.h
@@ -184,9 +184,8 @@ _genl_register_family_with_ops_grps(struct genl_family *family,
 					    (grps), ARRAY_SIZE(grps))
 
 int genl_unregister_family(struct genl_family *family);
-void genl_notify(struct genl_family *family,
-		 struct sk_buff *skb, struct net *net, u32 portid,
-		 u32 group, struct nlmsghdr *nlh, gfp_t flags);
+void genl_notify(struct genl_family *family, struct sk_buff *skb,
+		 struct genl_info *info, u32 group, gfp_t flags);
 
 struct sk_buff *genlmsg_new_unicast(size_t payload, struct genl_info *info,
 				    gfp_t flags);
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index a93aabe188f7..d14a85305cac 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -1082,19 +1082,19 @@ int genlmsg_multicast_allns(struct genl_family *family, struct sk_buff *skb,
 }
 EXPORT_SYMBOL(genlmsg_multicast_allns);
 
-void genl_notify(struct genl_family *family,
-		 struct sk_buff *skb, struct net *net, u32 portid, u32 group,
-		 struct nlmsghdr *nlh, gfp_t flags)
+void genl_notify(struct genl_family *family, struct sk_buff *skb,
+		 struct genl_info *info, u32 group, gfp_t flags)
 {
+	struct net *net = genl_info_net(info);
 	struct sock *sk = net->genl_sock;
 	int report = 0;
 
-	if (nlh)
-		report = nlmsg_report(nlh);
+	if (info->nlhdr)
+		report = nlmsg_report(info->nlhdr);
 
 	if (WARN_ON_ONCE(group >= family->n_mcgrps))
 		return;
 	group = family->mcgrp_offset + group;
-	nlmsg_notify(sk, skb, portid, group, report, flags);
+	nlmsg_notify(sk, skb, info->snd_portid, group, report, flags);
 }
 EXPORT_SYMBOL(genl_notify);
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index 30364aefec96..76c429ef2c4d 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -91,8 +91,7 @@ static bool ovs_must_notify(struct genl_family *family, struct genl_info *info,
 static void ovs_notify(struct genl_family *family,
 		       struct sk_buff *skb, struct genl_info *info)
 {
-	genl_notify(family, skb, genl_info_net(info), info->snd_portid,
-		    0, info->nlhdr, GFP_KERNEL);
+	genl_notify(family, skb, info, 0, GFP_KERNEL);
 }
 
 /**
