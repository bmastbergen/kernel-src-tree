qla2xxx: adjust debug flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit e5fdee875f7918b37f7c3fce3025197d8f214a27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e5fdee87.failed

Adjust debug flag to match debug comment.

	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Reviewed-by: Nicholas Bellinger <nab@linux-iscsi.org>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit e5fdee875f7918b37f7c3fce3025197d8f214a27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 34388aa2cf90,cda443462071..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -2464,6 -2978,81 +2464,84 @@@ static struct qla_tgt_cmd *qlt_ctio_to_
  	return cmd;
  }
  
++<<<<<<< HEAD
++=======
+ /* hardware_lock should be held by caller. */
+ static void
+ qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t handle;
+ 
+ 	if (cmd->sg_mapped)
+ 		qlt_unmap_sg(vha, cmd);
+ 
+ 	handle = qlt_make_handle(vha);
+ 
+ 	/* TODO: fix debug message type and ids. */
+ 	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
+ 		ql_dbg(ql_dbg_io, vha, 0xff00,
+ 		    "HOST-ABORT: handle=%d, state=PROCESSED.\n", handle);
+ 	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
+ 		cmd->write_data_transferred = 0;
+ 		cmd->state = QLA_TGT_STATE_DATA_IN;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0xff01,
+ 		    "HOST-ABORT: handle=%d, state=DATA_IN.\n", handle);
+ 
+ 		ha->tgt.tgt_ops->handle_data(cmd);
+ 		return;
+ 	} else if (cmd->state == QLA_TGT_STATE_ABORTED) {
+ 		ql_dbg(ql_dbg_io, vha, 0xff02,
+ 		    "HOST-ABORT: handle=%d, state=ABORTED.\n", handle);
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0xff03,
+ 		    "HOST-ABORT: handle=%d, state=BAD(%d).\n", handle,
+ 		    cmd->state);
+ 		dump_stack();
+ 	}
+ 
+ 	cmd->cmd_flags |= BIT_17;
+ 	ha->tgt.tgt_ops->free_cmd(cmd);
+ }
+ 
+ void
+ qlt_host_reset_handler(struct qla_hw_data *ha)
+ {
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);
+ 	scsi_qla_host_t *vha = NULL;
+ 	struct qla_tgt *tgt = base_vha->vha_tgt.qla_tgt;
+ 	uint32_t i;
+ 
+ 	if (!base_vha->hw->tgt.tgt_ops)
+ 		return;
+ 
+ 	if (!tgt || qla_ini_mode_enabled(base_vha)) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf003,
+ 			"Target mode disabled\n");
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xff10,
+ 	    "HOST-ABORT-HNDLR: base_vha->dpc_flags=%lx.\n",
+ 	    base_vha->dpc_flags);
+ 
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	for (i = 1; i < DEFAULT_OUTSTANDING_COMMANDS + 1; i++) {
+ 		cmd = qlt_get_cmd(base_vha, i);
+ 		if (!cmd)
+ 			continue;
+ 		/* ha->tgt.cmds entry is cleared by qlt_get_cmd. */
+ 		vha = cmd->vha;
+ 		qlt_abort_cmd_on_host_reset(vha, cmd);
+ 	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ }
+ 
+ 
++>>>>>>> e5fdee875f79 (qla2xxx: adjust debug flags)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -2556,21 -3172,28 +2634,27 @@@ static void qlt_do_ctio_completion(stru
  				return;
  		}
  	}
 -skip_term:
  
  	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe01f, "Command %p finished\n", cmd);
++=======
+ 		cmd->cmd_flags |= BIT_12;
++>>>>>>> e5fdee875f79 (qla2xxx: adjust debug flags)
  	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
 -		int rx_status = 0;
 -
  		cmd->state = QLA_TGT_STATE_DATA_IN;
  
 -		if (unlikely(status != CTIO_SUCCESS))
 -			rx_status = -EIO;
 -		else
 +		if (status == CTIO_SUCCESS)
  			cmd->write_data_transferred = 1;
  
  		ha->tgt.tgt_ops->handle_data(cmd);
  		return;
  	} else if (cmd->state == QLA_TGT_STATE_ABORTED) {
+ 		cmd->cmd_flags |= BIT_18;
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01e,
 -		  "Aborted command %p (tag %lld) finished\n", cmd, se_cmd->tag);
 +		    "Aborted command %p (tag %d) finished\n", cmd, cmd->tag);
  	} else {
+ 		cmd->cmd_flags |= BIT_19;
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05c,
  		    "qla_target(%d): A command in state (%d) should "
  		    "not return a CTIO complete\n", vha->vp_idx, cmd->state);
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,dfeeadf92fbb..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -858,6 -934,38 +858,41 @@@ struct qla_tgt_cmd 
  	struct list_head cmd_list;
  
  	struct atio_from_isp atio;
++<<<<<<< HEAD
++=======
+ 	/* t10dif */
+ 	struct scatterlist *prot_sg;
+ 	uint32_t prot_sg_cnt;
+ 	uint32_t blk_sz;
+ 	struct crc_context *ctx;
+ 
+ 	uint64_t jiffies_at_alloc;
+ 	uint64_t jiffies_at_free;
+ 	/* BIT_0 - Atio Arrival / schedule to work
+ 	 * BIT_1 - qlt_do_work
+ 	 * BIT_2 - qlt_do work failed
+ 	 * BIT_3 - xfer rdy/tcm_qla2xxx_write_pending
+ 	 * BIT_4 - read respond/tcm_qla2xx_queue_data_in
+ 	 * BIT_5 - status respond / tcm_qla2xx_queue_status
+ 	 * BIT_6 - tcm request to abort/Term exchange.
+ 	 *	pre_xmit_response->qlt_send_term_exchange
+ 	 * BIT_7 - SRR received (qlt_handle_srr->qlt_xmit_response)
+ 	 * BIT_8 - SRR received (qlt_handle_srr->qlt_rdy_to_xfer)
+ 	 * BIT_9 - SRR received (qla_handle_srr->qlt_send_term_exchange)
+ 	 * BIT_10 - Data in - hanlde_data->tcm_qla2xxx_handle_data
+ 	 * BIT_11 - Data actually going to TCM : tcm_qla2xx_handle_data_work
+ 	 * BIT_12 - good completion - qlt_ctio_do_completion -->free_cmd
+ 	 * BIT_13 - Bad completion -
+ 	 *	qlt_ctio_do_completion --> qlt_term_ctio_exchange
+ 	 * BIT_14 - Back end data received/sent.
+ 	 * BIT_15 - SRR prepare ctio
+ 	 * BIT_16 - complete free
+ 	 * BIT_17 - flush - qlt_abort_cmd_on_host_reset
+ 	 * BIT_18 - completion w/abort status
+ 	 * BIT_19 - completion w/unknown status
+ 	 */
+ 	uint32_t cmd_flags;
++>>>>>>> e5fdee875f79 (qla2xxx: adjust debug flags)
  };
  
  struct qla_tgt_sess_work_param {
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 8e939971fec1,32ff9d15e12d..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -507,9 -374,9 +507,9 @@@ static int tcm_qla2xxx_write_pending(st
  {
  	struct qla_tgt_cmd *cmd = container_of(se_cmd,
  				struct qla_tgt_cmd, se_cmd);
- 
+ 	cmd->cmd_flags |= BIT_3;
  	cmd->bufflen = se_cmd->data_length;
 -	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
 +	cmd->dma_data_direction = tcm_qla2xxx_mapping_dir(se_cmd);
  
  	cmd->sg_cnt = se_cmd->t_data_nents;
  	cmd->sg = se_cmd->t_data_sg;
@@@ -657,6 -546,11 +657,14 @@@ static int tcm_qla2xxx_queue_data_in(st
  	cmd->sg_cnt = se_cmd->t_data_nents;
  	cmd->sg = se_cmd->t_data_sg;
  	cmd->offset = 0;
++<<<<<<< HEAD
++=======
+ 
+ 	cmd->prot_sg_cnt = se_cmd->t_prot_nents;
+ 	cmd->prot_sg = se_cmd->t_prot_sg;
+ 	cmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;
+ 	se_cmd->pi_err = 0;
++>>>>>>> e5fdee875f79 (qla2xxx: adjust debug flags)
  
  	/*
  	 * Now queue completed DATA_IN the qla2xxx LLD and response ring
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
