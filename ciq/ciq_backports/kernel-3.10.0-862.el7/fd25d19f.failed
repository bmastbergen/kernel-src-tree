locking/refcount: Create unchecked atomic_t implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kees Cook <keescook@chromium.org>
commit fd25d19f6b8da315332bb75936605fb45d3ea981
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fd25d19f.failed

Many subsystems will not use refcount_t unless there is a way to build the
kernel so that there is no regression in speed compared to atomic_t. This
adds CONFIG_REFCOUNT_FULL to enable the full refcount_t implementation
which has the validation but is slightly slower. When not enabled,
refcount_t uses the basic unchecked atomic_t routines, which results in
no code changes compared to just using atomic_t directly.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: David Windsor <dwindsor@gmail.com>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Cc: Elena Reshetova <elena.reshetova@intel.com>
	Cc: Eric Biggers <ebiggers3@gmail.com>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Hans Liljestrand <ishkamiel@gmail.com>
	Cc: James Bottomley <James.Bottomley@hansenpartnership.com>
	Cc: Jann Horn <jannh@google.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Manfred Spraul <manfred@colorfullife.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Serge E. Hallyn <serge@hallyn.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: arozansk@redhat.com
	Cc: axboe@kernel.dk
	Cc: linux-arch <linux-arch@vger.kernel.org>
Link: http://lkml.kernel.org/r/20170621200026.GA115679@beast
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit fd25d19f6b8da315332bb75936605fb45d3ea981)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/Kconfig
#	include/linux/refcount.h
#	lib/refcount.c
diff --cc arch/Kconfig
index 4fa0b0631a54,f76b214cf7ad..000000000000
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@@ -595,4 -790,90 +595,93 @@@ config OLD_SIGACTIO
  config COMPAT_OLD_SIGACTION
  	bool
  
++<<<<<<< HEAD
++=======
+ config ARCH_NO_COHERENT_DMA_MMAP
+ 	bool
+ 
+ config CPU_NO_EFFICIENT_FFS
+ 	def_bool n
+ 
+ config HAVE_ARCH_VMAP_STACK
+ 	def_bool n
+ 	help
+ 	  An arch should select this symbol if it can support kernel stacks
+ 	  in vmalloc space.  This means:
+ 
+ 	  - vmalloc space must be large enough to hold many kernel stacks.
+ 	    This may rule out many 32-bit architectures.
+ 
+ 	  - Stacks in vmalloc space need to work reliably.  For example, if
+ 	    vmap page tables are created on demand, either this mechanism
+ 	    needs to work while the stack points to a virtual address with
+ 	    unpopulated page tables or arch code (switch_to() and switch_mm(),
+ 	    most likely) needs to ensure that the stack's page table entries
+ 	    are populated before running on a possibly unpopulated stack.
+ 
+ 	  - If the stack overflows into a guard page, something reasonable
+ 	    should happen.  The definition of "reasonable" is flexible, but
+ 	    instantly rebooting without logging anything would be unfriendly.
+ 
+ config VMAP_STACK
+ 	default y
+ 	bool "Use a virtually-mapped stack"
+ 	depends on HAVE_ARCH_VMAP_STACK && !KASAN
+ 	---help---
+ 	  Enable this if you want the use virtually-mapped kernel stacks
+ 	  with guard pages.  This causes kernel stack overflows to be
+ 	  caught immediately rather than causing difficult-to-diagnose
+ 	  corruption.
+ 
+ 	  This is presently incompatible with KASAN because KASAN expects
+ 	  the stack to map directly to the KASAN shadow map using a formula
+ 	  that is incorrect if the stack is in vmalloc space.
+ 
+ config ARCH_OPTIONAL_KERNEL_RWX
+ 	def_bool n
+ 
+ config ARCH_OPTIONAL_KERNEL_RWX_DEFAULT
+ 	def_bool n
+ 
+ config ARCH_HAS_STRICT_KERNEL_RWX
+ 	def_bool n
+ 
+ config STRICT_KERNEL_RWX
+ 	bool "Make kernel text and rodata read-only" if ARCH_OPTIONAL_KERNEL_RWX
+ 	depends on ARCH_HAS_STRICT_KERNEL_RWX
+ 	default !ARCH_OPTIONAL_KERNEL_RWX || ARCH_OPTIONAL_KERNEL_RWX_DEFAULT
+ 	help
+ 	  If this is set, kernel text and rodata memory will be made read-only,
+ 	  and non-text memory will be made non-executable. This provides
+ 	  protection against certain security exploits (e.g. executing the heap
+ 	  or modifying text)
+ 
+ 	  These features are considered standard security practice these days.
+ 	  You should say Y here in almost all cases.
+ 
+ config ARCH_HAS_STRICT_MODULE_RWX
+ 	def_bool n
+ 
+ config STRICT_MODULE_RWX
+ 	bool "Set loadable kernel module data as NX and text as RO" if ARCH_OPTIONAL_KERNEL_RWX
+ 	depends on ARCH_HAS_STRICT_MODULE_RWX && MODULES
+ 	default !ARCH_OPTIONAL_KERNEL_RWX || ARCH_OPTIONAL_KERNEL_RWX_DEFAULT
+ 	help
+ 	  If this is set, module text and rodata memory will be made read-only,
+ 	  and non-text memory will be made non-executable. This provides
+ 	  protection against certain security exploits (e.g. writing to text)
+ 
+ config ARCH_WANT_RELAX_ORDER
+ 	bool
+ 
+ config REFCOUNT_FULL
+ 	bool "Perform full reference count validation at the expense of speed"
+ 	help
+ 	  Enabling this switches the refcounting infrastructure from a fast
+ 	  unchecked atomic_t implementation to a fully state checked
+ 	  implementation, which can be (slightly) slower but provides protections
+ 	  against various use-after-free conditions that can be used in
+ 	  security flaw exploits.
+ 
++>>>>>>> fd25d19f6b8d (locking/refcount: Create unchecked atomic_t implementation)
  source "kernel/gcov/Kconfig"
* Unmerged path include/linux/refcount.h
* Unmerged path lib/refcount.c
* Unmerged path arch/Kconfig
* Unmerged path include/linux/refcount.h
* Unmerged path lib/refcount.c
