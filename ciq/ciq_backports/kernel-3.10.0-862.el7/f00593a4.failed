cpufreq: intel_pstate: Clarify comment in get_target_pstate_use_performance()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Clarify comment in get_target_pstate_use_performance() (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 93.79%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit f00593a4bdd22e0885db89df8ee8afcc6867994f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f00593a4.failed

Make the comment explaining the meaning of the perf_scaled variable
in get_target_pstate_use_performance() more straightforward.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit f00593a4bdd22e0885db89df8ee8afcc6867994f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 373aa337af34,1c7b91c5805b..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1232,42 -1247,31 +1232,50 @@@ static inline int32_t get_target_pstate
  
  static inline int32_t get_target_pstate_use_performance(struct cpudata *cpu)
  {
 -	int32_t perf_scaled, max_pstate, current_pstate, sample_ratio;
 -	u64 duration_ns;
 +	int32_t core_busy, max_pstate, current_pstate, sample_ratio;
 +	s64 duration_us;
 +	u32 sample_time;
 +
 +	intel_pstate_calc_busy(cpu);
  
  	/*
++<<<<<<< HEAD
 +	 * core_busy is the ratio of actual performance to max
 +	 * max_pstate is the max non turbo pstate available
 +	 * current_pstate was the pstate that was requested during
 +	 * 	the last sample period.
 +	 *
 +	 * We normalize core_busy, which was our actual percent
 +	 * performance to what we requested during the last sample
 +	 * period. The result will be a percentage of busy at a
 +	 * specified pstate.
++=======
+ 	 * perf_scaled is the ratio of the average P-state during the last
+ 	 * sampling period to the P-state requested last time (in percent).
+ 	 *
+ 	 * That measures the system's response to the previous P-state
+ 	 * selection.
++>>>>>>> f00593a4bdd2 (cpufreq: intel_pstate: Clarify comment in get_target_pstate_use_performance())
  	 */
 -	max_pstate = cpu->pstate.max_pstate_physical;
 -	current_pstate = cpu->pstate.current_pstate;
 -	perf_scaled = mul_ext_fp(cpu->sample.core_avg_perf,
 -			       div_fp(100 * max_pstate, current_pstate));
 +	core_busy = cpu->sample.core_pct_busy;
 +	max_pstate = int_tofp(cpu->pstate.max_pstate_physical);
 +	current_pstate = int_tofp(cpu->pstate.current_pstate);
 +	core_busy = mul_fp(core_busy, div_fp(max_pstate, current_pstate));
  
  	/*
 -	 * Since our utilization update callback will not run unless we are
 -	 * in C0, check if the actual elapsed time is significantly greater (3x)
 -	 * than our sample interval.  If it is, then we were idle for a long
 -	 * enough period of time to adjust our performance metric.
 +	 * Since we have a deferred timer, it will not fire unless
 +	 * we are in C0.  So, determine if the actual elapsed time
 +	 * is significantly greater (3x) than our sample interval.  If it
 +	 * is, then we were idle for a long enough period of time
 +	 * to adjust our busyness.
  	 */
 -	duration_ns = cpu->sample.time - cpu->last_sample_time;
 -	if ((s64)duration_ns > pid_params.sample_rate_ns * 3) {
 -		sample_ratio = div_fp(pid_params.sample_rate_ns, duration_ns);
 -		perf_scaled = mul_fp(perf_scaled, sample_ratio);
 +	sample_time = pid_params.sample_rate_ms  * USEC_PER_MSEC;
 +	duration_us = ktime_us_delta(cpu->sample.time,
 +				     cpu->last_sample_time);
 +	if (duration_us > sample_time * 3) {
 +		sample_ratio = div_fp(int_tofp(sample_time),
 +				      int_tofp(duration_us));
 +		core_busy = mul_fp(core_busy, sample_ratio);
  	} else {
  		sample_ratio = div_fp(100 * cpu->sample.mperf, cpu->sample.tsc);
  		if (sample_ratio < int_tofp(1))
* Unmerged path drivers/cpufreq/intel_pstate.c
