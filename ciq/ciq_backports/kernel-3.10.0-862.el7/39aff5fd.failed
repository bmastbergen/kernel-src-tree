xfs: refactor swapext code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 39aff5fdb91e8fee6a2c28910a263a5228619ba2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/39aff5fd.failed

Refactor the swapext function to pull out the fork swapping piece
into a separate function.  In the next patch we'll add in the bit
we need to make it work with rmap filesystems.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 39aff5fdb91e8fee6a2c28910a263a5228619ba2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index e68409b0c53f,b278d62b7152..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1531,29 -1649,156 +1531,176 @@@ xfs_swap_extent_flush
  	return 0;
  }
  
+ /* Swap the extents of two files by swapping data forks. */
+ STATIC int
+ xfs_swap_extent_forks(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_inode	*tip,
+ 	int			*src_log_flags,
+ 	int			*target_log_flags)
+ {
+ 	struct xfs_ifork	tempifp, *ifp, *tifp;
+ 	int			aforkblks = 0;
+ 	int			taforkblks = 0;
+ 	__uint64_t		tmp;
+ 	int			error;
+ 
+ 	/*
+ 	 * Count the number of extended attribute blocks
+ 	 */
+ 	if ( ((XFS_IFORK_Q(ip) != 0) && (ip->i_d.di_anextents > 0)) &&
+ 	     (ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {
+ 		error = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK,
+ 				&aforkblks);
+ 		if (error)
+ 			return error;
+ 	}
+ 	if ( ((XFS_IFORK_Q(tip) != 0) && (tip->i_d.di_anextents > 0)) &&
+ 	     (tip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {
+ 		error = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK,
+ 				&taforkblks);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * Before we've swapped the forks, lets set the owners of the forks
+ 	 * appropriately. We have to do this as we are demand paging the btree
+ 	 * buffers, and so the validation done on read will expect the owner
+ 	 * field to be correctly set. Once we change the owners, we can swap the
+ 	 * inode forks.
+ 	 */
+ 	if (ip->i_d.di_version == 3 &&
+ 	    ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {
+ 		(*target_log_flags) |= XFS_ILOG_DOWNER;
+ 		error = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,
+ 					      tip->i_ino, NULL);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (tip->i_d.di_version == 3 &&
+ 	    tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {
+ 		(*src_log_flags) |= XFS_ILOG_DOWNER;
+ 		error = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,
+ 					      ip->i_ino, NULL);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * Swap the data forks of the inodes
+ 	 */
+ 	ifp = &ip->i_df;
+ 	tifp = &tip->i_df;
+ 	tempifp = *ifp;		/* struct copy */
+ 	*ifp = *tifp;		/* struct copy */
+ 	*tifp = tempifp;	/* struct copy */
+ 
+ 	/*
+ 	 * Fix the on-disk inode values
+ 	 */
+ 	tmp = (__uint64_t)ip->i_d.di_nblocks;
+ 	ip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;
+ 	tip->i_d.di_nblocks = tmp + taforkblks - aforkblks;
+ 
+ 	tmp = (__uint64_t) ip->i_d.di_nextents;
+ 	ip->i_d.di_nextents = tip->i_d.di_nextents;
+ 	tip->i_d.di_nextents = tmp;
+ 
+ 	tmp = (__uint64_t) ip->i_d.di_format;
+ 	ip->i_d.di_format = tip->i_d.di_format;
+ 	tip->i_d.di_format = tmp;
+ 
+ 	/*
+ 	 * The extents in the source inode could still contain speculative
+ 	 * preallocation beyond EOF (e.g. the file is open but not modified
+ 	 * while defrag is in progress). In that case, we need to copy over the
+ 	 * number of delalloc blocks the data fork in the source inode is
+ 	 * tracking beyond EOF so that when the fork is truncated away when the
+ 	 * temporary inode is unlinked we don't underrun the i_delayed_blks
+ 	 * counter on that inode.
+ 	 */
+ 	ASSERT(tip->i_delayed_blks == 0);
+ 	tip->i_delayed_blks = ip->i_delayed_blks;
+ 	ip->i_delayed_blks = 0;
+ 
+ 	switch (ip->i_d.di_format) {
+ 	case XFS_DINODE_FMT_EXTENTS:
+ 		/* If the extents fit in the inode, fix the
+ 		 * pointer.  Otherwise it's already NULL or
+ 		 * pointing to the extent.
+ 		 */
+ 		if (ip->i_d.di_nextents <= XFS_INLINE_EXTS) {
+ 			ifp->if_u1.if_extents =
+ 				ifp->if_u2.if_inline_ext;
+ 		}
+ 		(*src_log_flags) |= XFS_ILOG_DEXT;
+ 		break;
+ 	case XFS_DINODE_FMT_BTREE:
+ 		ASSERT(ip->i_d.di_version < 3 ||
+ 		       (*src_log_flags & XFS_ILOG_DOWNER));
+ 		(*src_log_flags) |= XFS_ILOG_DBROOT;
+ 		break;
+ 	}
+ 
+ 	switch (tip->i_d.di_format) {
+ 	case XFS_DINODE_FMT_EXTENTS:
+ 		/* If the extents fit in the inode, fix the
+ 		 * pointer.  Otherwise it's already NULL or
+ 		 * pointing to the extent.
+ 		 */
+ 		if (tip->i_d.di_nextents <= XFS_INLINE_EXTS) {
+ 			tifp->if_u1.if_extents =
+ 				tifp->if_u2.if_inline_ext;
+ 		}
+ 		(*target_log_flags) |= XFS_ILOG_DEXT;
+ 		break;
+ 	case XFS_DINODE_FMT_BTREE:
+ 		(*target_log_flags) |= XFS_ILOG_DBROOT;
+ 		ASSERT(tip->i_d.di_version < 3 ||
+ 		       (*target_log_flags & XFS_ILOG_DOWNER));
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  int
  xfs_swap_extents(
 -	struct xfs_inode	*ip,	/* target inode */
 -	struct xfs_inode	*tip,	/* tmp inode */
 -	struct xfs_swapext	*sxp)
 +	xfs_inode_t	*ip,	/* target inode */
 +	xfs_inode_t	*tip,	/* tmp inode */
 +	xfs_swapext_t	*sxp)
  {
++<<<<<<< HEAD
 +	xfs_mount_t	*mp = ip->i_mount;
 +	xfs_trans_t	*tp;
 +	xfs_bstat_t	*sbp = &sxp->sx_stat;
 +	xfs_ifork_t	*tempifp, *ifp, *tifp;
 +	int		src_log_flags, target_log_flags;
 +	int		error = 0;
 +	int		aforkblks = 0;
 +	int		taforkblks = 0;
 +	xfs_extnum_t	nextents;
 +	__uint64_t	tmp;
 +	int		lock_flags;
 +
 +	tempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);
 +	if (!tempifp) {
 +		error = -ENOMEM;
 +		goto out;
 +	}
++=======
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	struct xfs_bstat	*sbp = &sxp->sx_stat;
+ 	int			src_log_flags, target_log_flags;
+ 	int			error = 0;
+ 	int			lock_flags;
+ 	struct xfs_ifork	*cowfp;
+ 	__uint64_t		f;
++>>>>>>> 39aff5fdb91e (xfs: refactor swapext code)
  
  	/*
  	 * Lock the inodes against other IO, page faults and truncate to
@@@ -1664,100 -1887,26 +1789,99 @@@
  	 */
  	src_log_flags = XFS_ILOG_CORE;
  	target_log_flags = XFS_ILOG_CORE;
- 	if (ip->i_d.di_version == 3 &&
- 	    ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {
- 		target_log_flags |= XFS_ILOG_DOWNER;
- 		error = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,
- 					      tip->i_ino, NULL);
- 		if (error)
- 			goto out_trans_cancel;
- 	}
  
++<<<<<<< HEAD
 +	if (tip->i_d.di_version == 3 &&
 +	    tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {
 +		src_log_flags |= XFS_ILOG_DOWNER;
 +		error = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,
 +					      ip->i_ino, NULL);
 +		if (error)
 +			goto out_trans_cancel;
 +	}
 +
 +	/*
 +	 * Swap the data forks of the inodes
 +	 */
 +	ifp = &ip->i_df;
 +	tifp = &tip->i_df;
 +	*tempifp = *ifp;	/* struct copy */
 +	*ifp = *tifp;		/* struct copy */
 +	*tifp = *tempifp;	/* struct copy */
 +
 +	/*
 +	 * Fix the on-disk inode values
 +	 */
 +	tmp = (__uint64_t)ip->i_d.di_nblocks;
 +	ip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;
 +	tip->i_d.di_nblocks = tmp + taforkblks - aforkblks;
 +
 +	tmp = (__uint64_t) ip->i_d.di_nextents;
 +	ip->i_d.di_nextents = tip->i_d.di_nextents;
 +	tip->i_d.di_nextents = tmp;
 +
 +	tmp = (__uint64_t) ip->i_d.di_format;
 +	ip->i_d.di_format = tip->i_d.di_format;
 +	tip->i_d.di_format = tmp;
 +
 +	/*
 +	 * The extents in the source inode could still contain speculative
 +	 * preallocation beyond EOF (e.g. the file is open but not modified
 +	 * while defrag is in progress). In that case, we need to copy over the
 +	 * number of delalloc blocks the data fork in the source inode is
 +	 * tracking beyond EOF so that when the fork is truncated away when the
 +	 * temporary inode is unlinked we don't underrun the i_delayed_blks
 +	 * counter on that inode.
 +	 */
 +	ASSERT(tip->i_delayed_blks == 0);
 +	tip->i_delayed_blks = ip->i_delayed_blks;
 +	ip->i_delayed_blks = 0;
 +
 +	switch (ip->i_d.di_format) {
 +	case XFS_DINODE_FMT_EXTENTS:
 +		/* If the extents fit in the inode, fix the
 +		 * pointer.  Otherwise it's already NULL or
 +		 * pointing to the extent.
 +		 */
 +		nextents = ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);
 +		if (nextents <= XFS_INLINE_EXTS) {
 +			ifp->if_u1.if_extents =
 +				ifp->if_u2.if_inline_ext;
 +		}
 +		src_log_flags |= XFS_ILOG_DEXT;
 +		break;
 +	case XFS_DINODE_FMT_BTREE:
 +		ASSERT(ip->i_d.di_version < 3 ||
 +		       (src_log_flags & XFS_ILOG_DOWNER));
 +		src_log_flags |= XFS_ILOG_DBROOT;
 +		break;
 +	}
 +
 +	switch (tip->i_d.di_format) {
 +	case XFS_DINODE_FMT_EXTENTS:
 +		/* If the extents fit in the inode, fix the
 +		 * pointer.  Otherwise it's already NULL or
 +		 * pointing to the extent.
 +		 */
 +		nextents = tip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);
 +		if (nextents <= XFS_INLINE_EXTS) {
 +			tifp->if_u1.if_extents =
 +				tifp->if_u2.if_inline_ext;
 +		}
 +		target_log_flags |= XFS_ILOG_DEXT;
 +		break;
 +	case XFS_DINODE_FMT_BTREE:
 +		target_log_flags |= XFS_ILOG_DBROOT;
 +		ASSERT(tip->i_d.di_version < 3 ||
 +		       (target_log_flags & XFS_ILOG_DOWNER));
 +		break;
 +	}
++=======
+ 	error = xfs_swap_extent_forks(tp, ip, tip, &src_log_flags,
+ 			&target_log_flags);
+ 	if (error)
+ 		goto out_trans_cancel;
 -
 -	/* Do we have to swap reflink flags? */
 -	if ((ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK) ^
 -	    (tip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK)) {
 -		f = ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK;
 -		ip->i_d.di_flags2 &= ~XFS_DIFLAG2_REFLINK;
 -		ip->i_d.di_flags2 |= tip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK;
 -		tip->i_d.di_flags2 &= ~XFS_DIFLAG2_REFLINK;
 -		tip->i_d.di_flags2 |= f & XFS_DIFLAG2_REFLINK;
 -		cowfp = ip->i_cowfp;
 -		ip->i_cowfp = tip->i_cowfp;
 -		tip->i_cowfp = cowfp;
 -		xfs_inode_set_cowblocks_tag(ip);
 -		xfs_inode_set_cowblocks_tag(tip);
 -	}
++>>>>>>> 39aff5fdb91e (xfs: refactor swapext code)
  
  	xfs_trans_log_inode(tp, ip,  src_log_flags);
  	xfs_trans_log_inode(tp, tip, target_log_flags);
* Unmerged path fs/xfs/xfs_bmap_util.c
