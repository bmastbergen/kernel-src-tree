scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Added change to enable ZIO for FC-NVMe devices (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 94.83%
commit-author Duane Grigsby <duane.grigsby@cavium.com>
commit deeae7a69f755c53a68a907f336c5cee54932025
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/deeae7a6.failed

Add support to the driver to set the exchange threshold value for
the number of outstanding AENs.

	Signed-off-by: Duane Grigsby <duane.grigsby@cavium.com>
	Signed-off-by: Darren Trapp <darren.trapp@cavium.com>
	Signed-off-by: Anil Gurumurthy <anil.gurumurthy@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit deeae7a69f755c53a68a907f336c5cee54932025)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.c
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_nvme.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index d4184772f017,7b74973d5788..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -12,16 -12,14 +12,27 @@@
   * |             Level            |   Last Value Used  |     Holes	|
   * ----------------------------------------------------------------------
   * | Module Init and Probe        |       0x0193       | 0x0146         |
++<<<<<<< HEAD
 + * | Mailbox commands             |       0x1199       | 0x111a-0x111b  |
 + * |                              |                    | 0x1155-0x1158  |
 + * |                              |                    | 0x1018-0x1019  |
 + * |                              |                    | 0x1115-0x1116  |
 + * |                              |                    | 0x10ca,0x1193  |
 + * | Device Discovery             |       0x2095       | 0x2016         |
 + * |                              |                    | 0x2020-0x2022, |
 + * |                              |                    | 0x2011-0x2012, |
 + * |                              |                    | 0x2099-0x20a4  |
 + * | Queue Command and IO tracing |       0x3075       | 0x300b         |
++=======
+  * |                              |                    | 0x015b-0x0160	|
+  * |                              |                    | 0x016e		|
+  * | Mailbox commands             |       0x1205       | 0x11a2-0x11ff	|
+  * | Device Discovery             |       0x2134       | 0x210e-0x2116  |
+  * |				  | 		       | 0x211a         |
+  * |                              |                    | 0x211c-0x2128  |
+  * |                              |                    | 0x212a-0x2130  |
+  * | Queue Command and IO tracing |       0x3074       | 0x300b         |
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
   * |                              |                    | 0x3027-0x3028  |
   * |                              |                    | 0x303d-0x3041  |
   * |                              |                    | 0x302d,0x3033  |
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,97dcabc790c9..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -448,6 -477,16 +448,19 @@@ qla2x00_dump_mctp_data(scsi_qla_host_t 
  extern int
  qla26xx_dport_diagnostics(scsi_qla_host_t *, void *, uint, uint);
  
++<<<<<<< HEAD
++=======
+ int qla24xx_send_mb_cmd(struct scsi_qla_host *, mbx_cmd_t *);
+ int qla24xx_gpdb_wait(struct scsi_qla_host *, fc_port_t *, u8);
+ int qla24xx_gidlist_wait(struct scsi_qla_host *, void *, dma_addr_t,
+     uint16_t *);
+ int __qla24xx_parse_gpdb(struct scsi_qla_host *, fc_port_t *,
+ 	struct port_database_24xx *);
+ 
+ extern int qla27xx_get_zio_threshold(scsi_qla_host_t *, uint16_t *);
+ extern int qla27xx_set_zio_threshold(scsi_qla_host_t *, uint16_t);
+ 
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
  /*
   * Global Function Prototypes in qla_isr.c source file.
   */
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 3d56972c1852,317fe6026856..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -1637,7 -1795,80 +1637,84 @@@ qla24xx_tm_iocb_entry(scsi_qla_host_t *
  		ql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5055,
  		    (uint8_t *)sts, sizeof(*sts));
  
++<<<<<<< HEAD
 +	sp->done(vha, sp, 0);
++=======
+ 	sp->done(sp, 0);
+ }
+ 
+ static void
+ qla24xx_nvme_iocb_entry(scsi_qla_host_t *vha, struct req_que *req, void *tsk)
+ {
+ 	const char func[] = "NVME-IOCB";
+ 	fc_port_t *fcport;
+ 	srb_t *sp;
+ 	struct srb_iocb *iocb;
+ 	struct sts_entry_24xx *sts = (struct sts_entry_24xx *)tsk;
+ 	uint16_t        state_flags;
+ 	struct nvmefc_fcp_req *fd;
+ 	uint16_t        ret = 0;
+ 	struct srb_iocb *nvme;
+ 
+ 	sp = qla2x00_get_sp_from_handle(vha, func, req, tsk);
+ 	if (!sp)
+ 		return;
+ 
+ 	iocb = &sp->u.iocb_cmd;
+ 	fcport = sp->fcport;
+ 	iocb->u.nvme.comp_status = le16_to_cpu(sts->comp_status);
+ 	state_flags  = le16_to_cpu(sts->state_flags);
+ 	fd = iocb->u.nvme.desc;
+ 	nvme = &sp->u.iocb_cmd;
+ 
+ 	if (unlikely(nvme->u.nvme.aen_op))
+ 		atomic_dec(&sp->vha->hw->nvme_active_aen_cnt);
+ 
+ 	/*
+ 	 * State flags: Bit 6 and 0.
+ 	 * If 0 is set, we don't care about 6.
+ 	 * both cases resp was dma'd to host buffer
+ 	 * if both are 0, that is good path case.
+ 	 * if six is set and 0 is clear, we need to
+ 	 * copy resp data from status iocb to resp buffer.
+ 	 */
+ 	if (!(state_flags & (SF_FCP_RSP_DMA | SF_NVME_ERSP))) {
+ 		iocb->u.nvme.rsp_pyld_len = 0;
+ 	} else if ((state_flags & SF_FCP_RSP_DMA)) {
+ 		iocb->u.nvme.rsp_pyld_len = le16_to_cpu(sts->nvme_rsp_pyld_len);
+ 	} else if (state_flags & SF_NVME_ERSP) {
+ 		uint32_t *inbuf, *outbuf;
+ 		uint16_t iter;
+ 
+ 		inbuf = (uint32_t *)&sts->nvme_ersp_data;
+ 		outbuf = (uint32_t *)fd->rspaddr;
+ 		iocb->u.nvme.rsp_pyld_len = le16_to_cpu(sts->nvme_rsp_pyld_len);
+ 		iter = iocb->u.nvme.rsp_pyld_len >> 2;
+ 		for (; iter; iter--)
+ 			*outbuf++ = swab32(*inbuf++);
+ 	} else { /* unhandled case */
+ 	    ql_log(ql_log_warn, fcport->vha, 0x503a,
+ 		"NVME-%s error. Unhandled state_flags of %x\n",
+ 		sp->name, state_flags);
+ 	}
+ 
+ 	fd->transferred_length = fd->payload_length -
+ 	    le32_to_cpu(sts->residual_len);
+ 
+ 	if (sts->entry_status) {
+ 		ql_log(ql_log_warn, fcport->vha, 0x5038,
+ 		    "NVME-%s error - hdl=%x entry-status(%x).\n",
+ 		    sp->name, sp->handle, sts->entry_status);
+ 		ret = QLA_FUNCTION_FAILED;
+ 	} else if (sts->comp_status != cpu_to_le16(CS_COMPLETE)) {
+ 		ql_log(ql_log_warn, fcport->vha, 0x5039,
+ 		    "NVME-%s error - hdl=%x completion status(%x) resid=%x  ox_id=%x\n",
+ 		    sp->name, sp->handle, sts->comp_status,
+ 		    le32_to_cpu(sts->residual_len), sts->ox_id);
+ 		ret = QLA_FUNCTION_FAILED;
+ 	}
+ 	sp->done(sp, ret);
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
  }
  
  /**
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 11982e7bd50f,28728c49d8df..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -690,6 -936,24 +690,27 @@@ qla2x00_get_fw_version(scsi_qla_host_t 
  		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x112f,
  		    "%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\n",
  		    __func__, mcp->mb[17], mcp->mb[16]);
++<<<<<<< HEAD
++=======
+ 
+ 		if (ha->fw_attributes_h & 0x4)
+ 			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118d,
+ 			    "%s: Firmware supports Extended Login 0x%x\n",
+ 			    __func__, ha->fw_attributes_h);
+ 
+ 		if (ha->fw_attributes_h & 0x8)
+ 			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1191,
+ 			    "%s: Firmware supports Exchange Offload 0x%x\n",
+ 			    __func__, ha->fw_attributes_h);
+ 
+ 		/*
+ 		 * FW supports nvme and driver load parameter requested nvme.
+ 		 * BIT 26 of fw_attributes indicates NVMe support.
+ 		 */
+ 		if ((ha->fw_attributes_h & 0x400) && ql2xnvmeenable)
+ 			vha->flags.nvme_enabled = 1;
+ 
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
  	}
  
  	if (IS_QLA27XX(ha)) {
@@@ -5658,3 -5842,291 +5679,294 @@@ qla26xx_dport_diagnostics(scsi_qla_host
  
  	return rval;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void qla2x00_async_mb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 
+ 	sp->u.iocb_cmd.u.mbx.rc = res;
+ 
+ 	complete(&sp->u.iocb_cmd.u.mbx.comp);
+ 	/* don't free sp here. Let the caller do the free */
+ }
+ 
+ /*
+  * This mailbox uses the iocb interface to send MB command.
+  * This allows non-critial (non chip setup) command to go
+  * out in parrallel.
+  */
+ int qla24xx_send_mb_cmd(struct scsi_qla_host *vha, mbx_cmd_t *mcp)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	srb_t *sp;
+ 	struct srb_iocb *c;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	sp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = mb_to_str(mcp->mb[0]);
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	memcpy(sp->u.iocb_cmd.u.mbx.out_mb, mcp->mb, SIZEOF_IOCB_MB_REG);
+ 
+ 	c = &sp->u.iocb_cmd;
+ 	c->timeout = qla2x00_async_iocb_timeout;
+ 	init_completion(&c->u.mbx.comp);
+ 
+ 	sp->done = qla2x00_async_mb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1018,
+ 		    "%s: %s Failed submission. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x113f, "MB:%s hndl %x submitted\n",
+ 	    sp->name, sp->handle);
+ 
+ 	wait_for_completion(&c->u.mbx.comp);
+ 	memcpy(mcp->mb, sp->u.iocb_cmd.u.mbx.in_mb, SIZEOF_IOCB_MB_REG);
+ 
+ 	rval = c->u.mbx.rc;
+ 	switch (rval) {
+ 	case QLA_FUNCTION_TIMEOUT:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1140, "%s: %s Timeout. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		break;
+ 	case  QLA_SUCCESS:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119d, "%s: %s done.\n",
+ 		    __func__, sp->name);
+ 		sp->free(sp);
+ 		break;
+ 	default:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119e, "%s: %s Failed. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		sp->free(sp);
+ 		break;
+ 	}
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	return rval;
+ }
+ 
+ /*
+  * qla24xx_gpdb_wait
+  * NOTE: Do not call this routine from DPC thread
+  */
+ int qla24xx_gpdb_wait(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	mbx_cmd_t mc;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd  == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xd047,
+ 		    "Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	memset(&mc, 0, sizeof(mc));
+ 	mc.mb[0] = MBC_GET_PORT_DATABASE;
+ 	mc.mb[1] = cpu_to_le16(fcport->loop_id);
+ 	mc.mb[2] = MSW(pd_dma);
+ 	mc.mb[3] = LSW(pd_dma);
+ 	mc.mb[6] = MSW(MSD(pd_dma));
+ 	mc.mb[7] = LSW(MSD(pd_dma));
+ 	mc.mb[9] = cpu_to_le16(vha->vp_idx);
+ 	mc.mb[10] = cpu_to_le16((uint16_t)opt);
+ 
+ 	rval = qla24xx_send_mb_cmd(vha, &mc);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1193,
+ 		    "%s: %8phC fail\n", __func__, fcport->port_name);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	rval = __qla24xx_parse_gpdb(vha, fcport, pd);
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1197, "%s: %8phC done\n",
+ 	    __func__, fcport->port_name);
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ done:
+ 	return rval;
+ }
+ 
+ int __qla24xx_parse_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport,
+     struct port_database_24xx *pd)
+ {
+ 	int rval = QLA_SUCCESS;
+ 	uint64_t zero = 0;
+ 	u8 current_login_state, last_login_state;
+ 
+ 	if (fcport->fc4f_nvme) {
+ 		current_login_state = pd->current_login_state >> 4;
+ 		last_login_state = pd->last_login_state >> 4;
+ 	} else {
+ 		current_login_state = pd->current_login_state & 0xf;
+ 		last_login_state = pd->last_login_state & 0xf;
+ 	}
+ 
+ 	/* Check for logged in state. */
+ 	if (current_login_state != PDS_PRLI_COMPLETE &&
+ 	    last_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119a,
+ 		    "Unable to verify login-state (%x/%x) for loop_id %x.\n",
+ 		    current_login_state, last_login_state, fcport->loop_id);
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	if (fcport->loop_id == FC_NO_LOOP_ID ||
+ 	    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&
+ 	     memcmp(fcport->port_name, pd->port_name, 8))) {
+ 		/* We lost the device mid way. */
+ 		rval = QLA_NOT_LOGGED_IN;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	/* Names are little-endian. */
+ 	memcpy(fcport->node_name, pd->node_name, WWN_SIZE);
+ 	memcpy(fcport->port_name, pd->port_name, WWN_SIZE);
+ 
+ 	/* Get port_id of device. */
+ 	fcport->d_id.b.domain = pd->port_id[0];
+ 	fcport->d_id.b.area = pd->port_id[1];
+ 	fcport->d_id.b.al_pa = pd->port_id[2];
+ 	fcport->d_id.b.rsvd_1 = 0;
+ 
+ 	if (fcport->fc4f_nvme) {
+ 		fcport->nvme_prli_service_param =
+ 		    pd->prli_nvme_svc_param_word_3;
+ 		fcport->port_type = FCT_NVME;
+ 	} else {
+ 		/* If not target must be initiator or unknown type. */
+ 		if ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 			fcport->port_type = FCT_INITIATOR;
+ 		else
+ 			fcport->port_type = FCT_TARGET;
+ 	}
+ 	/* Passback COS information. */
+ 	fcport->supported_classes = (pd->flags & PDF_CLASS_2) ?
+ 		FC_COS_CLASS2 : FC_COS_CLASS3;
+ 
+ 	if (pd->prli_svc_param_word_3[0] & BIT_7) {
+ 		fcport->flags |= FCF_CONF_COMP_SUPPORTED;
+ 		fcport->conf_compl_supported = 1;
+ 	}
+ 
+ gpd_error_out:
+ 	return rval;
+ }
+ 
+ /*
+  * qla24xx_gidlist__wait
+  * NOTE: don't call this routine from DPC thread.
+  */
+ int qla24xx_gidlist_wait(struct scsi_qla_host *vha,
+ 	void *id_list, dma_addr_t id_list_dma, uint16_t *entries)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	mbx_cmd_t mc;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	memset(&mc, 0, sizeof(mc));
+ 	mc.mb[0] = MBC_GET_ID_LIST;
+ 	mc.mb[2] = MSW(id_list_dma);
+ 	mc.mb[3] = LSW(id_list_dma);
+ 	mc.mb[6] = MSW(MSD(id_list_dma));
+ 	mc.mb[7] = LSW(MSD(id_list_dma));
+ 	mc.mb[8] = 0;
+ 	mc.mb[9] = cpu_to_le16(vha->vp_idx);
+ 
+ 	rval = qla24xx_send_mb_cmd(vha, &mc);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119b,
+ 		    "%s:  fail\n", __func__);
+ 	} else {
+ 		*entries = mc.mb[1];
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119c,
+ 		    "%s:  done\n", __func__);
+ 	}
+ done:
+ 	return rval;
+ }
+ 
+ int qla27xx_set_zio_threshold(scsi_qla_host_t *vha, uint16_t value)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1200,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_SET_ZIO_THRESHOLD;
+ 	mcp->mb[1] = cpu_to_le16(1);
+ 	mcp->mb[2] = cpu_to_le16(value);
+ 	mcp->out_mb = MBX_2 | MBX_1 | MBX_0;
+ 	mcp->in_mb = MBX_2 | MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1201, "%s %x\n",
+ 	    (rval != QLA_SUCCESS) ? "Failed"  : "Done", rval);
+ 
+ 	return rval;
+ }
+ 
+ int qla27xx_get_zio_threshold(scsi_qla_host_t *vha, uint16_t *value)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1203,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0, sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_SET_ZIO_THRESHOLD;
+ 	mcp->mb[1] = cpu_to_le16(0);
+ 	mcp->out_mb = MBX_1 | MBX_0;
+ 	mcp->in_mb = MBX_2 | MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval == QLA_SUCCESS)
+ 		*value = mc.mb[2];
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1205, "%s %x\n",
+ 	    (rval != QLA_SUCCESS) ? "Failed" : "Done", rval);
+ 
+ 	return rval;
+ }
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
diff --cc drivers/scsi/qla2xxx/qla_os.c
index c724f888aca6,d9a115577dc8..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -2650,7 -2746,12 +2650,16 @@@ qla2x00_probe_one(struct pci_dev *pdev
  	ql_dbg_pci(ql_dbg_init, pdev, 0x000a,
  	    "Memory allocated for ha=%p.\n", ha);
  	ha->pdev = pdev;
++<<<<<<< HEAD
 +	ha->tgt.enable_class_2 = ql2xenableclass2;
++=======
+ 	INIT_LIST_HEAD(&ha->tgt.q_full_list);
+ 	spin_lock_init(&ha->tgt.q_full_lock);
+ 	spin_lock_init(&ha->tgt.sess_lock);
+ 	spin_lock_init(&ha->tgt.atio_lock);
+ 
+ 	atomic_set(&ha->nvme_active_aen_cnt, 0);
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
  
  	/* Clear our data area */
  	ha->bars = bars;
@@@ -5635,6 -6033,21 +5655,24 @@@ qla2x00_timer(scsi_qla_host_t *vha
  	if (!list_empty(&vha->work_list))
  		start_dpc++;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * FC-NVME
+ 	 * see if the active AEN count has changed from what was last reported.
+ 	 */
+ 	if (!vha->vp_idx &&
+ 		atomic_read(&ha->nvme_active_aen_cnt) != ha->nvme_last_rptd_aen &&
+ 		ha->zio_mode == QLA_ZIO_MODE_6) {
+ 		ql_log(ql_log_info, vha, 0x3002,
+ 			"nvme: Sched: Set ZIO exchange threshold to %d.\n",
+ 			ha->nvme_last_rptd_aen);
+ 		ha->nvme_last_rptd_aen = atomic_read(&ha->nvme_active_aen_cnt);
+ 		set_bit(SET_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);
+ 		start_dpc++;
+ 	}
+ 
++>>>>>>> deeae7a69f75 (scsi: qla2xxx: Added change to enable ZIO for FC-NVMe devices)
  	/* Schedule the DPC routine if needed */
  	if ((test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) ||
  	    test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags) ||
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812..643001d94933 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -889,6 +889,7 @@ struct mbx_cmd_32 {
 #define MBC_ABORT_TARGET		0x17	/* Abort target (ID). */
 #define MBC_RESET			0x18	/* Reset. */
 #define MBC_GET_ADAPTER_LOOP_ID		0x20	/* Get loop id of ISP2200. */
+#define MBC_GET_SET_ZIO_THRESHOLD	0x21	/* Get/SET ZIO THRESHOLD. */
 #define MBC_GET_RETRY_COUNT		0x22	/* Get f/w retry cnt/delay. */
 #define MBC_DISABLE_VI			0x24	/* Disable VI operation. */
 #define MBC_ENABLE_VI			0x25	/* Enable VI operation. */
@@ -3546,6 +3547,9 @@ struct qla_hw_data {
 
 	struct qlt_hw_data tgt;
 	int	allow_cna_fw_dump;
+
+	atomic_t        nvme_active_aen_cnt;
+	uint16_t        nvme_last_rptd_aen;             /* Last recorded aen count */
 };
 
 /*
@@ -3614,6 +3618,7 @@ typedef struct scsi_qla_host {
 #define FX00_CRITEMP_RECOVERY	25
 #define FX00_HOST_INFO_RESEND	26
 #define QPAIR_ONLINE_CHECK_NEEDED	27
+#define SET_ZIO_THRESHOLD_NEEDED	28
 
 	unsigned long	pci_flags;
 #define PFLG_DISCONNECTED	0	/* PCI device removed */
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
