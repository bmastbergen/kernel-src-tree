scsi: lpfc: Fix System panic after loading the driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix System panic after loading the driver (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 94.00%
commit-author James Smart <jsmart2021@gmail.com>
commit b83d005e63ba2383738c1818691e973761d1e860
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b83d005e.failed

System panic with general protection fault during driver load

The driver uses a static array sli4_hba.handler_name to store the irq
handler names. If the io_channel_irqs exceeds the pre-allocated size
(32+1), then the driver will overwrite other fields of sli4_hba.

Fix: Dynamically allocate handler_name.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b83d005e63ba2383738c1818691e973761d1e860)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
#	drivers/scsi/lpfc/lpfc_sli4.h
diff --cc drivers/scsi/lpfc/lpfc_init.c
index 4d8c754a14fe,a825806036c3..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -9162,59 -9665,43 +9162,70 @@@ static in
  lpfc_sli4_enable_msix(struct lpfc_hba *phba)
  {
  	int vectors, rc, index;
+ 	char *name;
  
  	/* Set up MSI-X multi-message vectors */
 -	vectors = phba->io_channel_irqs;
 -	if (phba->cfg_fof)
 -		vectors++;
 +	for (index = 0; index < phba->cfg_fcp_io_channel; index++)
 +		phba->sli4_hba.msix_entries[index].entry = index;
  
 -	rc = pci_alloc_irq_vectors(phba->pcidev,
 -				(phba->nvmet_support) ? 1 : 2,
 -				vectors, PCI_IRQ_MSIX | PCI_IRQ_AFFINITY);
 -	if (rc < 0) {
 +	/* Configure MSI-X capability structure */
 +	vectors = phba->cfg_fcp_io_channel;
 +	if (phba->cfg_fof) {
 +		phba->sli4_hba.msix_entries[index].entry = index;
 +		vectors++;
 +	}
 +enable_msix_vectors:
 +	rc = pci_enable_msix(phba->pcidev, phba->sli4_hba.msix_entries,
 +			     vectors);
 +	if (rc > 1) {
 +		vectors = rc;
 +		goto enable_msix_vectors;
 +	} else if (rc) {
  		lpfc_printf_log(phba, KERN_INFO, LOG_INIT,
  				"0484 PCI enable MSI-X failed (%d)\n", rc);
 -		goto vec_fail_out;
 +		goto msi_fail_out;
  	}
 -	vectors = rc;
 +
 +	/* Log MSI-X vector assignment */
 +	for (index = 0; index < vectors; index++)
 +		lpfc_printf_log(phba, KERN_INFO, LOG_INIT,
 +				"0489 MSI-X entry[%d]: vector=x%x "
 +				"message=%d\n", index,
 +				phba->sli4_hba.msix_entries[index].vector,
 +				phba->sli4_hba.msix_entries[index].entry);
  
  	/* Assign MSI-X vectors to interrupt handlers */
  	for (index = 0; index < vectors; index++) {
- 		memset(&phba->sli4_hba.handler_name[index], 0, 16);
- 		snprintf((char *)&phba->sli4_hba.handler_name[index],
- 			 LPFC_SLI4_HANDLER_NAME_SZ,
+ 		name = phba->sli4_hba.hba_eq_hdl[index].handler_name;
+ 		memset(name, 0, LPFC_SLI4_HANDLER_NAME_SZ);
+ 		snprintf(name, LPFC_SLI4_HANDLER_NAME_SZ,
  			 LPFC_DRIVER_HANDLER_NAME"%d", index);
  
 -		phba->sli4_hba.hba_eq_hdl[index].idx = index;
 -		phba->sli4_hba.hba_eq_hdl[index].phba = phba;
 -		atomic_set(&phba->sli4_hba.hba_eq_hdl[index].hba_eq_in_use, 1);
 +		phba->sli4_hba.fcp_eq_hdl[index].idx = index;
 +		phba->sli4_hba.fcp_eq_hdl[index].phba = phba;
 +		atomic_set(&phba->sli4_hba.fcp_eq_hdl[index].fcp_eq_in_use, 1);
  		if (phba->cfg_fof && (index == (vectors - 1)))
 -			rc = request_irq(pci_irq_vector(phba->pcidev, index),
 +			rc = request_irq(
 +				phba->sli4_hba.msix_entries[index].vector,
  				 &lpfc_sli4_fof_intr_handler, 0,
++<<<<<<< HEAD
 +				 (char *)&phba->sli4_hba.handler_name[index],
 +				 &phba->sli4_hba.fcp_eq_hdl[index]);
++=======
+ 				 name,
+ 				 &phba->sli4_hba.hba_eq_hdl[index]);
++>>>>>>> b83d005e63ba (scsi: lpfc: Fix System panic after loading the driver)
  		else
 -			rc = request_irq(pci_irq_vector(phba->pcidev, index),
 +			rc = request_irq(
 +				phba->sli4_hba.msix_entries[index].vector,
  				 &lpfc_sli4_hba_intr_handler, 0,
++<<<<<<< HEAD
 +				 (char *)&phba->sli4_hba.handler_name[index],
 +				 &phba->sli4_hba.fcp_eq_hdl[index]);
++=======
+ 				 name,
+ 				 &phba->sli4_hba.hba_eq_hdl[index]);
++>>>>>>> b83d005e63ba (scsi: lpfc: Fix System panic after loading the driver)
  		if (rc) {
  			lpfc_printf_log(phba, KERN_WARNING, LOG_INIT,
  					"0486 MSI-X fast-path (%d) "
diff --cc drivers/scsi/lpfc/lpfc_sli4.h
index 10078254ebc7,28b75e08e044..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli4.h
+++ b/drivers/scsi/lpfc/lpfc_sli4.h
@@@ -379,10 -407,16 +379,16 @@@ struct lpfc_max_cfg_param 
  
  struct lpfc_hba;
  /* SLI4 HBA multi-fcp queue handler struct */
++<<<<<<< HEAD
 +struct lpfc_fcp_eq_hdl {
++=======
+ #define LPFC_SLI4_HANDLER_NAME_SZ	16
+ struct lpfc_hba_eq_hdl {
++>>>>>>> b83d005e63ba (scsi: lpfc: Fix System panic after loading the driver)
  	uint32_t idx;
+ 	char handler_name[LPFC_SLI4_HANDLER_NAME_SZ];
  	struct lpfc_hba *phba;
 -	atomic_t hba_eq_in_use;
 -	struct cpumask *cpumask;
 -	/* CPU affinitsed to or 0xffffffff if multiple */
 -	uint32_t cpu;
 -#define LPFC_MULTI_CPU_AFFINITY 0xffffffff
 +	atomic_t fcp_eq_in_use;
  };
  
  /* Port Capabilities for SLI4 Parameters */
@@@ -445,9 -480,8 +451,8 @@@ struct lpfc_sli4_lnk_info 
  	uint8_t optic_state;
  };
  
 -#define LPFC_SLI4_HANDLER_CNT		(LPFC_HBA_IO_CHAN_MAX+ \
 +#define LPFC_SLI4_HANDLER_CNT		(LPFC_FCP_IO_CHAN_MAX+ \
  					 LPFC_FOF_IO_CHAN_NUM)
- #define LPFC_SLI4_HANDLER_NAME_SZ	16
  
  /* Used for IRQ vector to CPU mapping */
  struct lpfc_vector_map_info {
@@@ -515,15 -549,20 +520,19 @@@ struct lpfc_sli4_hba 
  	uint32_t ue_to_rp;
  	struct lpfc_register sli_intf;
  	struct lpfc_pc_sli4_params pc_sli4_params;
++<<<<<<< HEAD
 +	struct msix_entry *msix_entries;
 +	uint8_t handler_name[LPFC_SLI4_HANDLER_CNT][LPFC_SLI4_HANDLER_NAME_SZ];
 +	struct lpfc_fcp_eq_hdl *fcp_eq_hdl; /* FCP per-WQ handle */
++=======
+ 	struct lpfc_hba_eq_hdl *hba_eq_hdl; /* HBA per-WQ handle */
++>>>>>>> b83d005e63ba (scsi: lpfc: Fix System panic after loading the driver)
  
  	/* Pointers to the constructed SLI4 queues */
 -	struct lpfc_queue **hba_eq;  /* Event queues for HBA */
 -	struct lpfc_queue **fcp_cq;  /* Fast-path FCP compl queue */
 -	struct lpfc_queue **nvme_cq; /* Fast-path NVME compl queue */
 -	struct lpfc_queue **nvmet_cqset; /* Fast-path NVMET CQ Set queues */
 -	struct lpfc_queue **nvmet_mrq_hdr; /* Fast-path NVMET hdr MRQs */
 -	struct lpfc_queue **nvmet_mrq_data; /* Fast-path NVMET data MRQs */
 -	struct lpfc_queue **fcp_wq;  /* Fast-path FCP work queue */
 -	struct lpfc_queue **nvme_wq; /* Fast-path NVME work queue */
 +	struct lpfc_queue **hba_eq;/* Event queues for HBA */
 +	struct lpfc_queue **fcp_cq;/* Fast-path FCP compl queue */
 +	struct lpfc_queue **fcp_wq;/* Fast-path FCP work queue */
  	uint16_t *fcp_cq_map;
 -	uint16_t *nvme_cq_map;
 -	struct list_head lpfc_wq_list;
  
  	struct lpfc_queue *mbx_cq; /* Slow-path mailbox complete queue */
  	struct lpfc_queue *els_cq; /* Slow-path ELS response complete queue */
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
* Unmerged path drivers/scsi/lpfc/lpfc_sli4.h
