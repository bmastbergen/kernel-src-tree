tpm: validate TPM 2.0 commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 58472f5cd4f6ff02488c8da3cdbf719e9dd21e48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/58472f5c.failed

Check for every TPM 2.0 command that the command code is supported and
the command buffer has at least the length that can contain the header
and the handle area.

For ContextSave and FlushContext we mark the body to be part of the
handle area. This gives validation for these commands at zero
cost, including the body of the command.

The more important reason for this is that we can virtualize these
commands in the same way as you would virtualize the handle area of a
command.

	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Tested-by: James Bottomley <James.Bottomley@HansenPartnership.com>
	Reviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>
(cherry picked from commit 58472f5cd4f6ff02488c8da3cdbf719e9dd21e48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm.h
#	drivers/char/tpm/tpm2-cmd.c
diff --cc drivers/char/tpm/tpm.h
index c039c6d97636,dd5f526a62b5..000000000000
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@@ -200,8 -211,8 +211,13 @@@ struct tpm_chip 
  	char ppi_version[TPM_PPI_VERSION_LEN + 1];
  #endif /* CONFIG_ACPI */
  
++<<<<<<< HEAD
 +	/* active locality */
 +	int locality;
++=======
+ 	u32 nr_commands;
+ 	u32 *cc_attrs_tbl;
++>>>>>>> 58472f5cd4f6 (tpm: validate TPM 2.0 commands)
  };
  
  #define to_tpm_chip(d) container_of(d, struct tpm_chip, dev)
@@@ -553,5 -570,5 +569,9 @@@ int tpm2_auto_startup(struct tpm_chip *
  void tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type);
  unsigned long tpm2_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal);
  int tpm2_probe(struct tpm_chip *chip);
++<<<<<<< HEAD
 +ssize_t tpm2_get_pcr_allocation(struct tpm_chip *chip);
++=======
+ int tpm2_find_cc(struct tpm_chip *chip, u32 cc);
++>>>>>>> 58472f5cd4f6 (tpm: validate TPM 2.0 commands)
  #endif
diff --cc drivers/char/tpm/tpm2-cmd.c
index bab83b23d39b,ec05ab373a2b..000000000000
--- a/drivers/char/tpm/tpm2-cmd.c
+++ b/drivers/char/tpm/tpm2-cmd.c
@@@ -1103,3 -1062,123 +1103,126 @@@ out
  
  	return rc;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int tpm2_get_cc_attrs_tbl(struct tpm_chip *chip)
+ {
+ 	struct tpm_buf buf;
+ 	u32 nr_commands;
+ 	u32 *attrs;
+ 	u32 cc;
+ 	int i;
+ 	int rc;
+ 
+ 	rc = tpm2_get_tpm_pt(chip, TPM_PT_TOTAL_COMMANDS, &nr_commands, NULL);
+ 	if (rc)
+ 		goto out;
+ 
+ 	if (nr_commands > 0xFFFFF) {
+ 		rc = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	chip->cc_attrs_tbl = devm_kzalloc(&chip->dev, 4 * nr_commands,
+ 					  GFP_KERNEL);
+ 
+ 	rc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);
+ 	if (rc)
+ 		goto out;
+ 
+ 	tpm_buf_append_u32(&buf, TPM2_CAP_COMMANDS);
+ 	tpm_buf_append_u32(&buf, TPM2_CC_FIRST);
+ 	tpm_buf_append_u32(&buf, nr_commands);
+ 
+ 	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, 9 + 4 * nr_commands,
+ 			      0, NULL);
+ 	if (rc) {
+ 		tpm_buf_destroy(&buf);
+ 		goto out;
+ 	}
+ 
+ 	if (nr_commands !=
+ 	    be32_to_cpup((__be32 *)&buf.data[TPM_HEADER_SIZE + 5])) {
+ 		tpm_buf_destroy(&buf);
+ 		goto out;
+ 	}
+ 
+ 	chip->nr_commands = nr_commands;
+ 
+ 	attrs = (u32 *)&buf.data[TPM_HEADER_SIZE + 9];
+ 	for (i = 0; i < nr_commands; i++, attrs++) {
+ 		chip->cc_attrs_tbl[i] = be32_to_cpup(attrs);
+ 		cc = chip->cc_attrs_tbl[i] & 0xFFFF;
+ 
+ 		if (cc == TPM2_CC_CONTEXT_SAVE || cc == TPM2_CC_FLUSH_CONTEXT) {
+ 			chip->cc_attrs_tbl[i] &=
+ 				~(GENMASK(2, 0) << TPM2_CC_ATTR_CHANDLES);
+ 			chip->cc_attrs_tbl[i] |= 1 << TPM2_CC_ATTR_CHANDLES;
+ 		}
+ 	}
+ 
+ 	tpm_buf_destroy(&buf);
+ 
+ out:
+ 	if (rc > 0)
+ 		rc = -ENODEV;
+ 	return rc;
+ }
+ 
+ /**
+  * tpm2_auto_startup - Perform the standard automatic TPM initialization
+  *                     sequence
+  * @chip: TPM chip to use
+  *
+  * Returns 0 on success, < 0 in case of fatal error.
+  */
+ int tpm2_auto_startup(struct tpm_chip *chip)
+ {
+ 	int rc;
+ 
+ 	rc = tpm_get_timeouts(chip);
+ 	if (rc)
+ 		goto out;
+ 
+ 	rc = tpm2_do_selftest(chip);
+ 	if (rc != 0 && rc != TPM2_RC_INITIALIZE) {
+ 		dev_err(&chip->dev, "TPM self test failed\n");
+ 		goto out;
+ 	}
+ 
+ 	if (rc == TPM2_RC_INITIALIZE) {
+ 		rc = tpm2_startup(chip, TPM2_SU_CLEAR);
+ 		if (rc)
+ 			goto out;
+ 
+ 		rc = tpm2_do_selftest(chip);
+ 		if (rc) {
+ 			dev_err(&chip->dev, "TPM self test failed\n");
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	rc = tpm2_get_pcr_allocation(chip);
+ 	if (rc)
+ 		goto out;
+ 
+ 	rc = tpm2_get_cc_attrs_tbl(chip);
+ 
+ out:
+ 	if (rc > 0)
+ 		rc = -ENODEV;
+ 	return rc;
+ }
+ 
+ int tpm2_find_cc(struct tpm_chip *chip, u32 cc)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < chip->nr_commands; i++)
+ 		if (cc == (chip->cc_attrs_tbl[i] & GENMASK(15, 0)))
+ 			return i;
+ 
+ 	return -1;
+ }
++>>>>>>> 58472f5cd4f6 (tpm: validate TPM 2.0 commands)
diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index c404cae70910..75cb4343ee75 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -328,6 +328,42 @@ unsigned long tpm_calc_ordinal_duration(struct tpm_chip *chip,
 }
 EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);
 
+static bool tpm_validate_command(struct tpm_chip *chip, const u8 *cmd,
+				 size_t len)
+{
+	const struct tpm_input_header *header = (const void *)cmd;
+	int i;
+	u32 cc;
+	u32 attrs;
+	unsigned int nr_handles;
+
+	if (len < TPM_HEADER_SIZE)
+		return false;
+
+	if (chip->flags & TPM_CHIP_FLAG_TPM2 && chip->nr_commands) {
+		cc = be32_to_cpu(header->ordinal);
+
+		i = tpm2_find_cc(chip, cc);
+		if (i < 0) {
+			dev_dbg(&chip->dev, "0x%04X is an invalid command\n",
+				cc);
+			return false;
+		}
+
+		attrs = chip->cc_attrs_tbl[i];
+		nr_handles =
+			4 * ((attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0));
+		if (len < TPM_HEADER_SIZE + 4 * nr_handles)
+			goto err_len;
+	}
+
+	return true;
+err_len:
+	dev_dbg(&chip->dev,
+		"%s: insufficient command length %zu", __func__, len);
+	return false;
+}
+
 /**
  * tmp_transmit - Internal kernel interface to transmit TPM commands.
  *
@@ -349,7 +385,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,
 	unsigned long stop;
 	bool need_locality;
 
-	if (bufsiz < TPM_HEADER_SIZE)
+	if (!tpm_validate_command(chip, buf, bufsiz))
 		return -EINVAL;
 
 	if (bufsiz > TPM_BUFSIZE)
* Unmerged path drivers/char/tpm/tpm.h
* Unmerged path drivers/char/tpm/tpm2-cmd.c
