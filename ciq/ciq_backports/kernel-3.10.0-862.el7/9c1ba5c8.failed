netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 9c1ba5c809381fb9fb779e2cc22a1c878a269ffb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9c1ba5c8.failed

There was a small window when all sets are destroyed and a concurrent
listing of all sets could grab a set which is just being destroyed.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 9c1ba5c809381fb9fb779e2cc22a1c878a269ffb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_core.c
diff --cc net/netfilter/ipset/ip_set_core.c
index 98b197a78f1a,87b4182660ba..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -27,11 -29,21 +27,26 @@@ static LIST_HEAD(ip_set_type_list);		/
  static DEFINE_MUTEX(ip_set_type_mutex);		/* protects ip_set_type_list */
  static DEFINE_RWLOCK(ip_set_ref_lock);		/* protects the set refs */
  
++<<<<<<< HEAD
 +static struct ip_set * __rcu *ip_set_list;	/* all individual sets */
 +static ip_set_id_t ip_set_max = CONFIG_IP_SET_MAX; /* max number of sets */
++=======
+ struct ip_set_net {
+ 	struct ip_set * __rcu *ip_set_list;	/* all individual sets */
+ 	ip_set_id_t	ip_set_max;	/* max number of sets */
+ 	bool		is_deleted;	/* deleted by ip_set_net_exit */
+ 	bool		is_destroyed;	/* all sets are destroyed */
+ };
+ static int ip_set_net_id __read_mostly;
+ 
+ static inline struct ip_set_net *ip_set_pernet(struct net *net)
+ {
+ 	return net_generic(net, ip_set_net_id);
+ }
++>>>>>>> 9c1ba5c80938 (netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.)
  
  #define IP_SET_INC	64
 -#define STRNCMP(a, b)	(strncmp(a, b, IPSET_MAXNAMELEN) == 0)
 +#define STREQ(a, b)	(strncmp(a, b, IPSET_MAXNAMELEN) == 0)
  
  static unsigned int max_sets;
  
@@@ -830,12 -981,9 +845,18 @@@ ip_set_setname_policy[IPSET_ATTR_CMD_MA
  };
  
  static void
++<<<<<<< HEAD
 +ip_set_destroy_set(ip_set_id_t index)
 +{
 +	struct ip_set *set = ip_set(index);
 +
 +	pr_debug("set: %s\n",  set->name);
 +	ip_set(index) = NULL;
++=======
+ ip_set_destroy_set(struct ip_set *set)
+ {
+ 	pr_debug("set: %s\n",  set->name);
++>>>>>>> 9c1ba5c80938 (netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.)
  
  	/* Must call it without holding any lock */
  	set->variant->destroy(set);
@@@ -874,14 -1023,20 +895,26 @@@ ip_set_destroy(struct sock *ctnl, struc
  				goto out;
  			}
  		}
+ 		inst->is_destroyed = true;
  		read_unlock_bh(&ip_set_ref_lock);
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = ip_set(i);
 +			if (s != NULL)
 +				ip_set_destroy_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = ip_set(inst, i);
+ 			if (s) {
+ 				ip_set(inst, i) = NULL;
+ 				ip_set_destroy_set(s);
+ 			}
++>>>>>>> 9c1ba5c80938 (netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.)
  		}
+ 		/* Modified by ip_set_destroy() only, which is serialized */
+ 		inst->is_destroyed = false;
  	} else {
 -		s = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),
 -				    &i);
 +		s = find_set_and_id(nla_data(attr[IPSET_ATTR_SETNAME]), &i);
  		if (s == NULL) {
  			ret = -ENOENT;
  			goto out;
@@@ -889,9 -1044,10 +922,14 @@@
  			ret = -IPSET_ERR_BUSY;
  			goto out;
  		}
+ 		ip_set(inst, i) = NULL;
  		read_unlock_bh(&ip_set_ref_lock);
  
++<<<<<<< HEAD
 +		ip_set_destroy_set(i);
++=======
+ 		ip_set_destroy_set(s);
++>>>>>>> 9c1ba5c80938 (netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.)
  	}
  	return 0;
  out:
@@@ -1121,11 -1285,13 +1159,12 @@@ ip_set_dump_start(struct sk_buff *skb, 
  	struct ip_set *set = NULL;
  	struct nlmsghdr *nlh = NULL;
  	unsigned int flags = NETLINK_CB(cb->skb).portid ? NLM_F_MULTI : 0;
 -	struct ip_set_net *inst = ip_set_pernet(sock_net(skb->sk));
  	u32 dump_type, dump_flags;
+ 	bool is_destroyed;
  	int ret = 0;
  
 -	if (!cb->args[IPSET_CB_DUMP]) {
 -		ret = dump_init(cb, inst);
 +	if (!cb->args[0]) {
 +		ret = dump_init(cb);
  		if (ret < 0) {
  			nlh = nlmsg_hdr(cb->skb);
  			/* We have to create and send the error message
@@@ -1136,19 -1302,23 +1175,31 @@@
  		}
  	}
  
 -	if (cb->args[IPSET_CB_INDEX] >= inst->ip_set_max)
 +	if (cb->args[1] >= ip_set_max)
  		goto out;
  
 -	dump_type = DUMP_TYPE(cb->args[IPSET_CB_DUMP]);
 -	dump_flags = DUMP_FLAGS(cb->args[IPSET_CB_DUMP]);
 -	max = dump_type == DUMP_ONE ? cb->args[IPSET_CB_INDEX] + 1
 -				    : inst->ip_set_max;
 +	dump_type = DUMP_TYPE(cb->args[0]);
 +	dump_flags = DUMP_FLAGS(cb->args[0]);
 +	max = dump_type == DUMP_ONE ? cb->args[1] + 1 : ip_set_max;
  dump_last:
++<<<<<<< HEAD
 +	pr_debug("args[0]: %u %u args[1]: %ld\n",
 +		 dump_type, dump_flags, cb->args[1]);
 +	for (; cb->args[1] < max; cb->args[1]++) {
 +		index = (ip_set_id_t) cb->args[1];
 +		set = ip_set(index);
 +		if (set == NULL) {
++=======
+ 	pr_debug("dump type, flag: %u %u index: %ld\n",
+ 		 dump_type, dump_flags, cb->args[IPSET_CB_INDEX]);
+ 	for (; cb->args[IPSET_CB_INDEX] < max; cb->args[IPSET_CB_INDEX]++) {
+ 		index = (ip_set_id_t) cb->args[IPSET_CB_INDEX];
+ 		write_lock_bh(&ip_set_ref_lock);
+ 		set = ip_set(inst, index);
+ 		is_destroyed = inst->is_destroyed;
+ 		if (!set || is_destroyed) {
+ 			write_unlock_bh(&ip_set_ref_lock);
++>>>>>>> 9c1ba5c80938 (netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.)
  			if (dump_type == DUMP_ONE) {
  				ret = -ENOENT;
  				goto out;
@@@ -1160,14 -1335,17 +1216,17 @@@
  		 */
  		if (dump_type != DUMP_ONE &&
  		    ((dump_type == DUMP_ALL) ==
- 		     !!(set->type->features & IPSET_DUMP_LAST)))
+ 		     !!(set->type->features & IPSET_DUMP_LAST))) {
+ 			write_unlock_bh(&ip_set_ref_lock);
  			continue;
+ 		}
  		pr_debug("List set: %s\n", set->name);
 -		if (!cb->args[IPSET_CB_ARG0]) {
 +		if (!cb->args[2]) {
  			/* Start listing: make sure set won't be destroyed */
  			pr_debug("reference set\n");
- 			__ip_set_get(set);
+ 			set->ref++;
  		}
+ 		write_unlock_bh(&ip_set_ref_lock);
  		nlh = start_msg(skb, NETLINK_CB(cb->skb).portid,
  				cb->nlh->nlmsg_seq, flags,
  				IPSET_CMD_LIST);
@@@ -1801,6 -2015,53 +1860,56 @@@ static struct nf_sockopt_ops so_set __r
  	.owner		= THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ static int __net_init
+ ip_set_net_init(struct net *net)
+ {
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 	struct ip_set **list;
+ 
+ 	inst->ip_set_max = max_sets ? max_sets : CONFIG_IP_SET_MAX;
+ 	if (inst->ip_set_max >= IPSET_INVALID_ID)
+ 		inst->ip_set_max = IPSET_INVALID_ID - 1;
+ 
+ 	list = kzalloc(sizeof(struct ip_set *) * inst->ip_set_max, GFP_KERNEL);
+ 	if (!list)
+ 		return -ENOMEM;
+ 	inst->is_deleted = false;
+ 	inst->is_destroyed = false;
+ 	rcu_assign_pointer(inst->ip_set_list, list);
+ 	return 0;
+ }
+ 
+ static void __net_exit
+ ip_set_net_exit(struct net *net)
+ {
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 
+ 	struct ip_set *set = NULL;
+ 	ip_set_id_t i;
+ 
+ 	inst->is_deleted = true; /* flag for ip_set_nfnl_put */
+ 
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		set = ip_set(inst, i);
+ 		if (set) {
+ 			ip_set(inst, i) = NULL;
+ 			ip_set_destroy_set(set);
+ 		}
+ 	}
+ 	kfree(rcu_dereference_protected(inst->ip_set_list, 1));
+ }
+ 
+ static struct pernet_operations ip_set_net_ops = {
+ 	.init	= ip_set_net_init,
+ 	.exit   = ip_set_net_exit,
+ 	.id	= &ip_set_net_id,
+ 	.size	= sizeof(struct ip_set_net)
+ };
+ 
+ 
++>>>>>>> 9c1ba5c80938 (netfilter: ipset: Make sure listing doesn't grab a set which is just being destroyed.)
  static int __init
  ip_set_init(void)
  {
* Unmerged path net/netfilter/ipset/ip_set_core.c
