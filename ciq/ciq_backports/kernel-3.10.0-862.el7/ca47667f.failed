drm/i915/gen10: Calculate and enable transition WM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kumar, Mahesh <mahesh1.kumar@intel.com>
commit ca47667f523e588318f89c735e127c256de6cb16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ca47667f.failed

GEN > 9 require transition WM to be programmed if IPC is enabled.
This patch calculates & enable transition WM for supported platforms.
If transition WM is enabled, Plane read requests are sent at high
priority until filling above the transition watermark, then the
requests are sent at lower priority until dropping below the level-0 WM.
The lower priority requests allow other memory clients to have better
memory access.

transition minimum is the minimum amount needed for trans_wm to work to
ensure  the demote does not happen before enough data has been read to
meet the level 0 watermark requirements.

transition amount is configurable value. Higher values will
tend to cause longer periods of high priority reads followed by longer
periods of lower priority reads. Tuning to lower values will tend to
cause shorter periods of high and lower priority reads.

Keeping transition amount to 10 in this patch, as suggested by HW team.

Changes since V1:
 - Address review comments from Maarten

	Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
	Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170817134529.2839-4-mahesh1.kumar@intel.com
(cherry picked from commit ca47667f523e588318f89c735e127c256de6cb16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 52c3abe82e2f,3168a5577773..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -3782,19 -4701,29 +3826,45 @@@ static int skl_build_pipe_wm(struct int
  	 */
  	memset(pipe_wm->planes, 0, sizeof(pipe_wm->planes));
  
++<<<<<<< HEAD
 +	for_each_intel_plane_mask(&dev_priv->drm,
 +				  intel_plane,
 +				  cstate->base.plane_mask) {
 +		wm = &pipe_wm->planes[skl_wm_plane_id(intel_plane)];
 +
 +		for (level = 0; level <= max_level; level++) {
 +			ret = skl_compute_wm_level(dev_priv, ddb, cstate,
 +						   intel_plane, level,
 +						   &wm->wm[level]);
 +			if (ret)
 +				return ret;
 +		}
 +		skl_compute_transition_wm(cstate, &wm->trans_wm);
++=======
+ 	drm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) {
+ 		const struct intel_plane_state *intel_pstate =
+ 						to_intel_plane_state(pstate);
+ 		enum plane_id plane_id = to_intel_plane(plane)->id;
+ 		struct skl_wm_params wm_params;
+ 		enum pipe pipe = to_intel_crtc(cstate->base.crtc)->pipe;
+ 		uint16_t ddb_blocks;
+ 
+ 		wm = &pipe_wm->planes[plane_id];
+ 		ddb_blocks = skl_ddb_entry_size(&ddb->plane[pipe][plane_id]);
+ 		memset(&wm_params, 0, sizeof(struct skl_wm_params));
+ 
+ 		ret = skl_compute_plane_wm_params(dev_priv, cstate,
+ 						  intel_pstate, &wm_params);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = skl_compute_wm_levels(dev_priv, ddb, cstate,
+ 					    intel_pstate, &wm_params, wm);
+ 		if (ret)
+ 			return ret;
+ 		skl_compute_transition_wm(cstate, &wm_params, &wm->wm[0],
+ 					  ddb_blocks, &wm->trans_wm);
++>>>>>>> ca47667f523e (drm/i915/gen10: Calculate and enable transition WM)
  	}
  	pipe_wm->linetime = skl_compute_linetime_wm(cstate);
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
