mnt: Simplify mount_too_revealing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit a1935c1738af53249a02290ff7c10e8a6e650a16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a1935c17.failed

Verify all filesystems that we check in mount_too_revealing set
SB_I_NOEXEC and SB_I_NODEV in sb->s_iflags.  That is true for today
and it should remain true in the future.

Remove the now unnecessary checks from mnt_already_visibile that
ensure MNT_LOCK_NOSUID, MNT_LOCK_NOEXEC, and MNT_LOCK_NODEV are
preserved.  Making the code shorter and easier to read.

Relying on SB_I_NOEXEC and SB_I_NODEV instead of the user visible
MNT_NOSUID, MNT_NOEXEC, and MNT_NODEV ensures the many current
systems where proc and sysfs are mounted with "nosuid, nodev, noexec"
and several slightly buggy container applications don't bother to
set those flags continue to work.

	Acked-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit a1935c1738af53249a02290ff7c10e8a6e650a16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 84149742b9d6,b1da7f8182c4..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -3296,23 -3219,87 +3296,101 @@@ void update_mnt_policy(struct user_name
  
  	down_read(&namespace_sem);
  	list_for_each_entry(mnt, &ns->list, mnt_list) {
++<<<<<<< HEAD
 +		switch (mnt->mnt.mnt_sb->s_magic) {
 +		case SYSFS_MAGIC:
 +			userns->may_mount_sysfs = true;
 +			break;
 +		case PROC_SUPER_MAGIC:
 +			userns->may_mount_proc = true;
 +			break;
 +		}
 +		if (userns->may_mount_sysfs && userns->may_mount_proc)
 +			break;
++=======
+ 		struct mount *child;
+ 		int mnt_flags;
+ 
+ 		if (mnt->mnt.mnt_sb->s_type != new->mnt_sb->s_type)
+ 			continue;
+ 
+ 		/* This mount is not fully visible if it's root directory
+ 		 * is not the root directory of the filesystem.
+ 		 */
+ 		if (mnt->mnt.mnt_root != mnt->mnt.mnt_sb->s_root)
+ 			continue;
+ 
+ 		/* A local view of the mount flags */
+ 		mnt_flags = mnt->mnt.mnt_flags;
+ 
+ 		/* Don't miss readonly hidden in the superblock flags */
+ 		if (mnt->mnt.mnt_sb->s_flags & MS_RDONLY)
+ 			mnt_flags |= MNT_LOCK_READONLY;
+ 
+ 		/* Verify the mount flags are equal to or more permissive
+ 		 * than the proposed new mount.
+ 		 */
+ 		if ((mnt_flags & MNT_LOCK_READONLY) &&
+ 		    !(new_flags & MNT_READONLY))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_ATIME) &&
+ 		    ((mnt_flags & MNT_ATIME_MASK) != (new_flags & MNT_ATIME_MASK)))
+ 			continue;
+ 
+ 		/* This mount is not fully visible if there are any
+ 		 * locked child mounts that cover anything except for
+ 		 * empty directories.
+ 		 */
+ 		list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {
+ 			struct inode *inode = child->mnt_mountpoint->d_inode;
+ 			/* Only worry about locked mounts */
+ 			if (!(child->mnt.mnt_flags & MNT_LOCKED))
+ 				continue;
+ 			/* Is the directory permanetly empty? */
+ 			if (!is_empty_dir_inode(inode))
+ 				goto next;
+ 		}
+ 		/* Preserve the locked attributes */
+ 		*new_mnt_flags |= mnt_flags & (MNT_LOCK_READONLY | \
+ 					       MNT_LOCK_ATIME);
+ 		visible = true;
+ 		goto found;
+ 	next:	;
++>>>>>>> a1935c1738af (mnt: Simplify mount_too_revealing)
  	}
 -found:
  	up_read(&namespace_sem);
 -	return visible;
  }
  
 -static bool mount_too_revealing(struct vfsmount *mnt, int *new_mnt_flags)
 +static void *mntns_get(struct task_struct *task)
  {
++<<<<<<< HEAD
 +	struct mnt_namespace *ns = NULL;
++=======
+ 	const unsigned long required_iflags = SB_I_NOEXEC | SB_I_NODEV;
+ 	struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+ 	unsigned long s_iflags;
+ 
+ 	if (ns->user_ns == &init_user_ns)
+ 		return false;
+ 
+ 	/* Can this filesystem be too revealing? */
+ 	s_iflags = mnt->mnt_sb->s_iflags;
+ 	if (!(s_iflags & SB_I_USERNS_VISIBLE))
+ 		return false;
+ 
+ 	if ((s_iflags & required_iflags) != required_iflags) {
+ 		WARN_ONCE(1, "Expected s_iflags to contain 0x%lx\n",
+ 			  required_iflags);
+ 		return true;
+ 	}
+ 
+ 	return !mnt_already_visible(ns, mnt, new_mnt_flags);
+ }
+ 
+ static struct ns_common *mntns_get(struct task_struct *task)
+ {
+ 	struct ns_common *ns = NULL;
++>>>>>>> a1935c1738af (mnt: Simplify mount_too_revealing)
  	struct nsproxy *nsproxy;
  
  	task_lock(task);
* Unmerged path fs/namespace.c
