fs/locks: Use allocation rather than the stack in fcntl_getlk()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] locks: Use allocation rather than the stack in fcntl_getlk() (Benjamin Coddington) [1449486]
Rebuild_FUZZ: 97.56%
commit-author Benjamin Coddington <bcodding@redhat.com>
commit 52306e882f77d3fd73f91435c41373d634acc5d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/52306e88.failed

Struct file_lock is fairly large, so let's save some space on the stack by
using an allocation for struct file_lock in fcntl_getlk(), just as we do
for fcntl_setlk().

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Signed-off-by: Jeff Layton <jlayton@redhat.com>
(cherry picked from commit 52306e882f77d3fd73f91435c41373d634acc5d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
diff --cc fs/locks.c
index 20dcff562a1d,d7daa6c8932f..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -1992,39 -2084,44 +1992,76 @@@ static void posix_lock_to_flock64(struc
  /* Report the first existing lock that would conflict with l.
   * This implements the F_GETLK command of fcntl().
   */
 -int fcntl_getlk(struct file *filp, unsigned int cmd, struct flock *flock)
 +int fcntl_getlk(struct file *filp, unsigned int cmd, struct flock __user *l)
  {
++<<<<<<< HEAD
 +	struct file_lock file_lock;
 +	struct flock flock;
 +	int error;
 +
 +	error = -EFAULT;
 +	if (copy_from_user(&flock, l, sizeof(flock)))
 +		goto out;
++=======
+ 	struct file_lock *fl;
+ 	int error;
+ 
+ 	fl = locks_alloc_lock();
+ 	if (fl == NULL)
+ 		return -ENOMEM;
++>>>>>>> 52306e882f77 (fs/locks: Use allocation rather than the stack in fcntl_getlk())
  	error = -EINVAL;
 -	if (flock->l_type != F_RDLCK && flock->l_type != F_WRLCK)
 +	if ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))
  		goto out;
  
++<<<<<<< HEAD
 +	error = flock_to_posix_lock(filp, &file_lock, &flock);
 +	if (error)
 +		goto out;
 +
 +	error = vfs_test_lock(filp, &file_lock);
 +	if (error)
 +		goto out;
 + 
 +	flock.l_type = file_lock.fl_type;
 +	if (file_lock.fl_type != F_UNLCK) {
 +		error = posix_lock_to_flock(&flock, &file_lock);
++=======
+ 	error = flock_to_posix_lock(filp, fl, flock);
+ 	if (error)
+ 		goto out;
+ 
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK;
+ 		fl->fl_flags |= FL_OFDLCK;
+ 		fl->fl_owner = filp;
+ 	}
+ 
+ 	error = vfs_test_lock(filp, fl);
+ 	if (error)
+ 		goto out;
+  
+ 	flock->l_type = fl->fl_type;
+ 	if (fl->fl_type != F_UNLCK) {
+ 		error = posix_lock_to_flock(flock, fl);
++>>>>>>> 52306e882f77 (fs/locks: Use allocation rather than the stack in fcntl_getlk())
  		if (error)
- 			goto rel_priv;
+ 			goto out;
  	}
++<<<<<<< HEAD
 +	error = -EFAULT;
 +	if (!copy_to_user(l, &flock, sizeof(flock)))
 +		error = 0;
 +rel_priv:
 +	locks_release_private(&file_lock);
++=======
++>>>>>>> 52306e882f77 (fs/locks: Use allocation rather than the stack in fcntl_getlk())
  out:
+ 	locks_free_lock(fl);
  	return error;
  }
  
@@@ -2162,37 -2298,43 +2199,71 @@@ out
  /* Report the first existing lock that would conflict with l.
   * This implements the F_GETLK command of fcntl().
   */
 -int fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 *flock)
 +int fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 __user *l)
  {
++<<<<<<< HEAD
 +	struct file_lock file_lock;
 +	struct flock64 flock;
 +	int error;
 +
 +	error = -EFAULT;
 +	if (copy_from_user(&flock, l, sizeof(flock)))
 +		goto out;
++=======
+ 	struct file_lock *fl;
+ 	int error;
+ 
+ 	fl = locks_alloc_lock();
+ 	if (fl == NULL)
+ 		return -ENOMEM;
+ 
++>>>>>>> 52306e882f77 (fs/locks: Use allocation rather than the stack in fcntl_getlk())
  	error = -EINVAL;
 -	if (flock->l_type != F_RDLCK && flock->l_type != F_WRLCK)
 +	if ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))
 +		goto out;
 +
++<<<<<<< HEAD
 +	error = flock64_to_posix_lock(filp, &file_lock, &flock);
 +	if (error)
  		goto out;
  
 +	error = vfs_test_lock(filp, &file_lock);
 +	if (error)
 +		goto out;
 +
 +	flock.l_type = file_lock.fl_type;
 +	if (file_lock.fl_type != F_UNLCK)
 +		posix_lock_to_flock64(&flock, &file_lock);
 +
 +	error = -EFAULT;
 +	if (!copy_to_user(l, &flock, sizeof(flock)))
 +		error = 0;
++=======
+ 	error = flock64_to_posix_lock(filp, fl, flock);
+ 	if (error)
+ 		goto out;
+ 
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK64;
+ 		fl->fl_flags |= FL_OFDLCK;
+ 		fl->fl_owner = filp;
+ 	}
+ 
+ 	error = vfs_test_lock(filp, fl);
+ 	if (error)
+ 		goto out;
+ 
+ 	flock->l_type = fl->fl_type;
+ 	if (fl->fl_type != F_UNLCK)
+ 		posix_lock_to_flock64(flock, fl);
++>>>>>>> 52306e882f77 (fs/locks: Use allocation rather than the stack in fcntl_getlk())
  
- 	locks_release_private(&file_lock);
  out:
+ 	locks_free_lock(fl);
  	return error;
  }
  
* Unmerged path fs/locks.c
