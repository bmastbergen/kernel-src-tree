target: Drop left-over se_lun->lun_status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Drop left-over se_lun->lun_status (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 89.19%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 4624773765699ac3f4e0b918306b638cba385713
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/46247737.failed

Now that se_portal_group->tpg_lun_hlist is a RCU protected hlist,
go ahead and drop the left-over lun->lun_status usage.

	Reported-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 4624773765699ac3f4e0b918306b638cba385713)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_tpg.c
#	include/target/target_core_base.h
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,91f8ddb6d783..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -132,13 -96,10 +132,20 @@@ void core_tpg_add_node_to_devs
  	struct se_lun *lun;
  	struct se_device *dev;
  
++<<<<<<< HEAD
 +	spin_lock(&tpg->tpg_lun_lock);
 +	for (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {
 +		lun = tpg->tpg_lun_list[i];
 +		if (lun->lun_status != TRANSPORT_LUN_STATUS_ACTIVE)
 +			continue;
 +
 +		spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	mutex_lock(&tpg->tpg_lun_mutex);
+ 	hlist_for_each_entry_rcu(lun, &tpg->tpg_lun_hlist, link) {
+ 		if (lun_orig && lun != lun_orig)
+ 			continue;
++>>>>>>> 462477376569 (target: Drop left-over se_lun->lun_status)
  
  		dev = lun->lun_se_dev;
  		/*
@@@ -656,11 -493,8 +663,10 @@@ static int core_tpg_setup_virtual_lun0(
  	int ret;
  
  	lun->unpacked_lun = 0;
- 	lun->lun_status = TRANSPORT_LUN_STATUS_FREE;
  	atomic_set(&lun->lun_acl_count, 0);
  	init_completion(&lun->lun_shutdown_comp);
 +	INIT_LIST_HEAD(&lun->lun_acl_list);
 +	spin_lock_init(&lun->lun_acl_lock);
  	spin_lock_init(&lun->lun_sep_lock);
  	init_completion(&lun->lun_ref_comp);
  
@@@ -797,17 -598,17 +803,26 @@@ struct se_lun *core_tpg_alloc_lun
  		return ERR_PTR(-EOVERFLOW);
  	}
  
 -	lun = kzalloc(sizeof(*lun), GFP_KERNEL);
 -	if (!lun) {
 -		pr_err("Unable to allocate se_lun memory\n");
 -		return ERR_PTR(-ENOMEM);
 +	spin_lock(&tpg->tpg_lun_lock);
 +	lun = tpg->tpg_lun_list[unpacked_lun];
 +	if (lun->lun_status == TRANSPORT_LUN_STATUS_ACTIVE) {
 +		pr_err("TPG Logical Unit Number: %u is already active"
 +			" on %s Target Portal Group: %u, ignoring request.\n",
 +			unpacked_lun, tpg->se_tpg_tfo->get_fabric_name(),
 +			tpg->se_tpg_tfo->tpg_get_tag(tpg));
 +		spin_unlock(&tpg->tpg_lun_lock);
 +		return ERR_PTR(-EINVAL);
  	}
++<<<<<<< HEAD
 +	spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	lun->unpacked_lun = unpacked_lun;
+ 	lun->lun_link_magic = SE_LUN_LINK_MAGIC;
+ 	atomic_set(&lun->lun_acl_count, 0);
+ 	init_completion(&lun->lun_shutdown_comp);
+ 	spin_lock_init(&lun->lun_sep_lock);
+ 	init_completion(&lun->lun_ref_comp);
++>>>>>>> 462477376569 (target: Drop left-over se_lun->lun_status)
  
  	return lun;
  }
@@@ -831,10 -632,11 +846,16 @@@ int core_tpg_add_lun
  		return ret;
  	}
  
 -	mutex_lock(&tpg->tpg_lun_mutex);
 +	spin_lock(&tpg->tpg_lun_lock);
  	lun->lun_access = lun_access;
++<<<<<<< HEAD
 +	lun->lun_status = TRANSPORT_LUN_STATUS_ACTIVE;
 +	spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	if (!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		hlist_add_head_rcu(&lun->link, &tpg->tpg_lun_hlist);
+ 	mutex_unlock(&tpg->tpg_lun_mutex);
++>>>>>>> 462477376569 (target: Drop left-over se_lun->lun_status)
  
  	return 0;
  }
@@@ -848,9 -652,10 +869,16 @@@ void core_tpg_remove_lun
  
  	core_dev_unexport(lun->lun_se_dev, tpg, lun);
  
++<<<<<<< HEAD
 +	spin_lock(&tpg->tpg_lun_lock);
 +	lun->lun_status = TRANSPORT_LUN_STATUS_FREE;
 +	spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	mutex_lock(&tpg->tpg_lun_mutex);
+ 	if (!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		hlist_del_rcu(&lun->link);
+ 	mutex_unlock(&tpg->tpg_lun_mutex);
++>>>>>>> 462477376569 (target: Drop left-over se_lun->lun_status)
  
  	percpu_ref_exit(&lun->lun_ref);
  }
diff --cc include/target/target_core_base.h
index 7bcf92529421,78ed2a83838c..000000000000
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@@ -125,18 -119,6 +125,21 @@@ enum hba_flags_table 
  	HBA_FLAGS_PSCSI_MODE	= 0x02,
  };
  
++<<<<<<< HEAD
 +/* struct se_lun->lun_status */
 +enum transport_lun_status_table {
 +	TRANSPORT_LUN_STATUS_FREE = 0,
 +	TRANSPORT_LUN_STATUS_ACTIVE = 1,
 +};
 +
 +/* struct se_portal_group->se_tpg_type */
 +enum transport_tpg_type_table {
 +	TRANSPORT_TPG_TYPE_NORMAL = 0,
 +	TRANSPORT_TPG_TYPE_DISCOVERY = 1,
 +};
 +
++=======
++>>>>>>> 462477376569 (target: Drop left-over se_lun->lun_status)
  /* Special transport agnostic struct se_cmd->t_states */
  enum transport_state_table {
  	TRANSPORT_NO_STATE	= 0,
@@@ -712,10 -698,9 +715,8 @@@ struct se_port_stat_grps 
  };
  
  struct se_lun {
 -	u16			lun_rtpi;
  #define SE_LUN_LINK_MAGIC			0xffff7771
  	u32			lun_link_magic;
- 	/* See transport_lun_status_table */
- 	enum transport_lun_status_table lun_status;
  	u32			lun_access;
  	u32			lun_flags;
  	u32			unpacked_lun;
* Unmerged path drivers/target/target_core_tpg.c
* Unmerged path include/target/target_core_base.h
