kvm: vmx: Raise #UD on unsupported RDSEED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jim Mattson <jmattson@google.com>
commit 75f4fc8da9bd3b56f08ff8ba4113e5c57a85c24c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/75f4fc8d.failed

A guest may not be configured to support RDSEED, even when the host
does. If the guest does not support RDSEED, intercept the instruction
and synthesize #UD. Also clear the "allowed-1" bit for RDSEED exiting
in the IA32_VMX_PROCBASED_CTLS2 MSR.

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 75f4fc8da9bd3b56f08ff8ba4113e5c57a85c24c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 35bc7f099719,954e26079cd6..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2634,9 -2818,7 +2634,12 @@@ static void nested_vmx_setup_ctls_msrs(
  		vmx->nested.nested_vmx_secondary_ctls_high);
  	vmx->nested.nested_vmx_secondary_ctls_low = 0;
  	vmx->nested.nested_vmx_secondary_ctls_high &=
++<<<<<<< HEAD
 +		SECONDARY_EXEC_RDRAND | SECONDARY_EXEC_RDSEED |
++=======
++>>>>>>> 75f4fc8da9bd (kvm: vmx: Raise #UD on unsupported RDSEED)
  		SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
 +		SECONDARY_EXEC_RDTSCP |
  		SECONDARY_EXEC_DESC |
  		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
  		SECONDARY_EXEC_APIC_REGISTER_VIRT |
@@@ -3207,8 -3669,12 +3210,14 @@@ static __init int setup_vmcs_config(str
  			SECONDARY_EXEC_APIC_REGISTER_VIRT |
  			SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
  			SECONDARY_EXEC_SHADOW_VMCS |
++<<<<<<< HEAD
++=======
+ 			SECONDARY_EXEC_XSAVES |
+ 			SECONDARY_EXEC_RDSEED |
+ 			SECONDARY_EXEC_RDRAND |
++>>>>>>> 75f4fc8da9bd (kvm: vmx: Raise #UD on unsupported RDSEED)
  			SECONDARY_EXEC_ENABLE_PML |
 -			SECONDARY_EXEC_TSC_SCALING |
 -			SECONDARY_EXEC_ENABLE_VMFUNC;
 +			SECONDARY_EXEC_TSC_SCALING;
  		if (adjust_vmx_controls(min2, opt2,
  					MSR_IA32_VMX_PROCBASED_CTLS2,
  					&_cpu_based_2nd_exec_control) < 0)
@@@ -4766,10 -5274,24 +4775,27 @@@ static u32 vmx_exec_control(struct vcpu
  	return exec_control;
  }
  
 -static bool vmx_rdrand_supported(void)
 +static u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)
  {
++<<<<<<< HEAD
++=======
+ 	return vmcs_config.cpu_based_2nd_exec_ctrl &
+ 		SECONDARY_EXEC_RDRAND;
+ }
+ 
+ static bool vmx_rdseed_supported(void)
+ {
+ 	return vmcs_config.cpu_based_2nd_exec_ctrl &
+ 		SECONDARY_EXEC_RDSEED;
+ }
+ 
+ static void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)
+ {
+ 	struct kvm_vcpu *vcpu = &vmx->vcpu;
+ 
++>>>>>>> 75f4fc8da9bd (kvm: vmx: Raise #UD on unsupported RDSEED)
  	u32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;
 -	if (!cpu_need_virtualize_apic_accesses(vcpu))
 +	if (!cpu_need_virtualize_apic_accesses(&vmx->vcpu))
  		exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
  	if (vmx->vpid == 0)
  		exec_control &= ~SECONDARY_EXEC_ENABLE_VPID;
@@@ -4797,7 -5319,73 +4823,77 @@@
  	if (!enable_pml)
  		exec_control &= ~SECONDARY_EXEC_ENABLE_PML;
  
++<<<<<<< HEAD
 +	return exec_control;
++=======
+ 	if (vmx_rdtscp_supported()) {
+ 		bool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);
+ 		if (!rdtscp_enabled)
+ 			exec_control &= ~SECONDARY_EXEC_RDTSCP;
+ 
+ 		if (nested) {
+ 			if (rdtscp_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDTSCP;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDTSCP;
+ 		}
+ 	}
+ 
+ 	if (vmx_invpcid_supported()) {
+ 		/* Exposing INVPCID only when PCID is exposed */
+ 		bool invpcid_enabled =
+ 			guest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&
+ 			guest_cpuid_has(vcpu, X86_FEATURE_PCID);
+ 
+ 		if (!invpcid_enabled) {
+ 			exec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;
+ 			guest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);
+ 		}
+ 
+ 		if (nested) {
+ 			if (invpcid_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_ENABLE_INVPCID;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_ENABLE_INVPCID;
+ 		}
+ 	}
+ 
+ 	if (vmx_rdrand_supported()) {
+ 		bool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);
+ 		if (rdrand_enabled)
+ 			exec_control &= ~SECONDARY_EXEC_RDRAND;
+ 
+ 		if (nested) {
+ 			if (rdrand_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDRAND;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDRAND;
+ 		}
+ 	}
+ 
+ 	if (vmx_rdseed_supported()) {
+ 		bool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);
+ 		if (rdseed_enabled)
+ 			exec_control &= ~SECONDARY_EXEC_RDSEED;
+ 
+ 		if (nested) {
+ 			if (rdseed_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDSEED;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDSEED;
+ 		}
+ 	}
+ 
+ 	vmx->secondary_exec_control = exec_control;
++>>>>>>> 75f4fc8da9bd (kvm: vmx: Raise #UD on unsupported RDSEED)
  }
  
  static void ept_set_mmio_spte_mask(void)
@@@ -7591,7 -8139,13 +7687,14 @@@ static int (*const kvm_vmx_exit_handler
  	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,
  	[EXIT_REASON_INVEPT]                  = handle_invept,
  	[EXIT_REASON_INVVPID]                 = handle_invvpid,
++<<<<<<< HEAD
++=======
+ 	[EXIT_REASON_RDRAND]                  = handle_invalid_op,
+ 	[EXIT_REASON_RDSEED]                  = handle_invalid_op,
+ 	[EXIT_REASON_XSAVES]                  = handle_xsaves,
+ 	[EXIT_REASON_XRSTORS]                 = handle_xrstors,
++>>>>>>> 75f4fc8da9bd (kvm: vmx: Raise #UD on unsupported RDSEED)
  	[EXIT_REASON_PML_FULL]		      = handle_pml_full,
 -	[EXIT_REASON_VMFUNC]                  = handle_vmfunc,
 -	[EXIT_REASON_PREEMPTION_TIMER]	      = handle_preemption_timer,
  };
  
  static const int kvm_vmx_max_exit_handlers =
* Unmerged path arch/x86/kvm/vmx.c
