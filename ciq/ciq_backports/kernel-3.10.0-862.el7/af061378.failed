mlxsw: spectrum_switchdev: Add support for learning FDB through notification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit af061378924f6d2f368b3769fd59fd95875dc942
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/af061378.failed

Add support for learning FDB through notification. The driver defers
the hardware update via ordered work queue. Support for stacked devices
is also provided. In case of a successful FDB add a notification is
sent back to bridge.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit af061378924f6d2f368b3769fd59fd95875dc942)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.h
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index e33337ab34c4,5ef98d4d0ab6..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@@ -494,14 -343,31 +494,35 @@@ int mlxsw_sp_port_vid_stp_set(struct ml
  int mlxsw_sp_port_vid_learning_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,
  				   bool learn_enable);
  int mlxsw_sp_port_pvid_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_port_vlan *
+ mlxsw_sp_port_vlan_get(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);
+ void mlxsw_sp_port_vlan_put(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan);
+ int mlxsw_sp_port_vlan_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid_begin,
+ 			   u16 vid_end, bool is_member, bool untagged);
+ int mlxsw_sp_flow_counter_get(struct mlxsw_sp *mlxsw_sp,
+ 			      unsigned int counter_index, u64 *packets,
+ 			      u64 *bytes);
+ int mlxsw_sp_flow_counter_alloc(struct mlxsw_sp *mlxsw_sp,
+ 				unsigned int *p_counter_index);
+ void mlxsw_sp_flow_counter_free(struct mlxsw_sp *mlxsw_sp,
+ 				unsigned int counter_index);
+ bool mlxsw_sp_port_dev_check(const struct net_device *dev);
+ struct mlxsw_sp *mlxsw_sp_lower_get(struct net_device *dev);
+ struct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find(struct net_device *dev);
+ struct mlxsw_sp_port *mlxsw_sp_port_lower_dev_hold(struct net_device *dev);
+ void mlxsw_sp_port_dev_put(struct mlxsw_sp_port *mlxsw_sp_port);
+ struct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find_rcu(struct net_device *dev);
++>>>>>>> af061378924f (mlxsw: spectrum_switchdev: Add support for learning FDB through notification)
  
 -/* spectrum_dcb.c */
  #ifdef CONFIG_MLXSW_SPECTRUM_DCB
 +
  int mlxsw_sp_port_dcb_init(struct mlxsw_sp_port *mlxsw_sp_port);
  void mlxsw_sp_port_dcb_fini(struct mlxsw_sp_port *mlxsw_sp_port);
 +
  #else
 +
  static inline int mlxsw_sp_port_dcb_init(struct mlxsw_sp_port *mlxsw_sp_port)
  {
  	return 0;
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index a7736231096b,0297c136d040..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -1486,8 -2050,100 +1523,99 @@@ out
  	mlxsw_sp_fdb_notify_work_schedule(mlxsw_sp);
  }
  
+ struct mlxsw_sp_switchdev_event_work {
+ 	struct work_struct work;
+ 	struct switchdev_notifier_fdb_info fdb_info;
+ 	struct net_device *dev;
+ 	unsigned long event;
+ };
+ 
+ static void mlxsw_sp_switchdev_event_work(struct work_struct *work)
+ {
+ 	struct mlxsw_sp_switchdev_event_work *switchdev_work =
+ 		container_of(work, struct mlxsw_sp_switchdev_event_work, work);
+ 	struct net_device *dev = switchdev_work->dev;
+ 	struct switchdev_notifier_fdb_info *fdb_info;
+ 	struct mlxsw_sp_port *mlxsw_sp_port;
+ 	int err;
+ 
+ 	rtnl_lock();
+ 	mlxsw_sp_port = mlxsw_sp_port_dev_lower_find(dev);
+ 	if (!mlxsw_sp_port)
+ 		goto out;
+ 
+ 	switch (switchdev_work->event) {
+ 	case SWITCHDEV_FDB_ADD_TO_DEVICE:
+ 		fdb_info = &switchdev_work->fdb_info;
+ 		err = mlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, true);
+ 		if (err)
+ 			break;
+ 		mlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,
+ 					    fdb_info->addr,
+ 					    fdb_info->vid, dev);
+ 		break;
+ 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
+ 		fdb_info = &switchdev_work->fdb_info;
+ 		mlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, false);
+ 		break;
+ 	}
+ 
+ out:
+ 	rtnl_unlock();
+ 	kfree(switchdev_work->fdb_info.addr);
+ 	kfree(switchdev_work);
+ 	dev_put(dev);
+ }
+ 
+ /* Called under rcu_read_lock() */
+ static int mlxsw_sp_switchdev_event(struct notifier_block *unused,
+ 				    unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
+ 	struct mlxsw_sp_switchdev_event_work *switchdev_work;
+ 	struct switchdev_notifier_fdb_info *fdb_info = ptr;
+ 
+ 	if (!mlxsw_sp_port_dev_lower_find_rcu(dev))
+ 		return NOTIFY_DONE;
+ 
+ 	switchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);
+ 	if (!switchdev_work)
+ 		return NOTIFY_BAD;
+ 
+ 	INIT_WORK(&switchdev_work->work, mlxsw_sp_switchdev_event_work);
+ 	switchdev_work->dev = dev;
+ 	switchdev_work->event = event;
+ 
+ 	switch (event) {
+ 	case SWITCHDEV_FDB_ADD_TO_DEVICE: /* fall through */
+ 	case SWITCHDEV_FDB_DEL_TO_DEVICE:
+ 		memcpy(&switchdev_work->fdb_info, ptr,
+ 		       sizeof(switchdev_work->fdb_info));
+ 		switchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);
+ 		ether_addr_copy((u8 *)switchdev_work->fdb_info.addr,
+ 				fdb_info->addr);
+ 		/* Take a reference on the device. This can be either
+ 		 * upper device containig mlxsw_sp_port or just a
+ 		 * mlxsw_sp_port
+ 		 */
+ 		dev_hold(dev);
+ 		break;
+ 	default:
+ 		kfree(switchdev_work);
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	mlxsw_core_schedule_work(&switchdev_work->work);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block mlxsw_sp_switchdev_notifier = {
+ 	.notifier_call = mlxsw_sp_switchdev_event,
+ };
+ 
  static int mlxsw_sp_fdb_init(struct mlxsw_sp *mlxsw_sp)
  {
 -	struct mlxsw_sp_bridge *bridge = mlxsw_sp->bridge;
  	int err;
  
  	err = mlxsw_sp_ageing_set(mlxsw_sp, MLXSW_SP_DEFAULT_AGEING_TIME);
@@@ -1495,15 -2151,24 +1623,33 @@@
  		dev_err(mlxsw_sp->bus_info->dev, "Failed to set default ageing time\n");
  		return err;
  	}
++<<<<<<< HEAD
 +	INIT_DELAYED_WORK(&mlxsw_sp->fdb_notify.dw, mlxsw_sp_fdb_notify_work);
 +	mlxsw_sp->fdb_notify.interval = MLXSW_SP_DEFAULT_LEARNING_INTERVAL;
++=======
+ 
+ 	err = register_switchdev_notifier(&mlxsw_sp_switchdev_notifier);
+ 	if (err) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Failed to register switchdev notifier\n");
+ 		return err;
+ 	}
+ 
+ 	INIT_DELAYED_WORK(&bridge->fdb_notify.dw, mlxsw_sp_fdb_notify_work);
+ 	bridge->fdb_notify.interval = MLXSW_SP_DEFAULT_LEARNING_INTERVAL;
++>>>>>>> af061378924f (mlxsw: spectrum_switchdev: Add support for learning FDB through notification)
  	mlxsw_sp_fdb_notify_work_schedule(mlxsw_sp);
  	return 0;
  }
  
  static void mlxsw_sp_fdb_fini(struct mlxsw_sp *mlxsw_sp)
  {
++<<<<<<< HEAD
 +	cancel_delayed_work_sync(&mlxsw_sp->fdb_notify.dw);
++=======
+ 	cancel_delayed_work_sync(&mlxsw_sp->bridge->fdb_notify.dw);
+ 	unregister_switchdev_notifier(&mlxsw_sp_switchdev_notifier);
+ 
++>>>>>>> af061378924f (mlxsw: spectrum_switchdev: Add support for learning FDB through notification)
  }
  
  int mlxsw_sp_switchdev_init(struct mlxsw_sp *mlxsw_sp)
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 4d14e78f2e24..a9e51632d036 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -3759,7 +3759,7 @@ struct mlxsw_sp *mlxsw_sp_lower_get(struct net_device *dev)
 	return mlxsw_sp_port ? mlxsw_sp_port->mlxsw_sp : NULL;
 }
 
-static struct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find_rcu(struct net_device *dev)
+struct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find_rcu(struct net_device *dev)
 {
 	struct mlxsw_sp_port *mlxsw_sp_port;
 
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
