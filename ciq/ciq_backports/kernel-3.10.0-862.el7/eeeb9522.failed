target: Propigate backend read-only to core_tpg_add_lun

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Propigate backend read-only to core_tpg_add_lun (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 92.16%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit eeeb9522231118138be418ff527dc8c9050f4707
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/eeeb9522.failed

This patch adds a DF_READ_ONLY flag that is used by IBLOCK to
signal when a backend has been set to read-only mode, in order
to propigate read-only status up to core_tpg_add_lun() for all
future LUN fabric exports.

With this is place, existing emulation for reporting read-only
in spc_emulate_modesense() and normal transport_lookup_cmd_lun()
TCM_WRITE_PROTECTED status checking just works as expected.

	Reported-by: Joeue Deng <joeue404@gmail.com>
	Reported-by: Andy Grover <agrover@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit eeeb9522231118138be418ff527dc8c9050f4707)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_tpg.c
#	include/target/target_core_base.h
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,5fb9dd7f08bb..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -823,20 -649,39 +823,30 @@@ int core_tpg_add_lun
  	ret = percpu_ref_init(&lun->lun_ref, core_tpg_lun_ref_release, 0,
  			      GFP_KERNEL);
  	if (ret < 0)
 -		goto out;
 -
 -	ret = core_alloc_rtpi(lun, dev);
 -	if (ret)
 -		goto out_kill_ref;
 -
 -	if (!(dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH) &&
 -	    !(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
 -		target_attach_tg_pt_gp(lun, dev->t10_alua.default_tg_pt_gp);
 -
 -	mutex_lock(&tpg->tpg_lun_mutex);
 +		return ret;
  
 -	spin_lock(&dev->se_port_lock);
 -	lun->lun_index = dev->dev_index;
 -	rcu_assign_pointer(lun->lun_se_dev, dev);
 -	dev->export_count++;
 -	list_add_tail(&lun->lun_dev_link, &dev->dev_sep_list);
 -	spin_unlock(&dev->se_port_lock);
 +	ret = core_dev_export(dev, tpg, lun);
 +	if (ret < 0) {
 +		percpu_ref_exit(&lun->lun_ref);
 +		return ret;
 +	}
  
++<<<<<<< HEAD
 +	spin_lock(&tpg->tpg_lun_lock);
 +	lun->lun_access = lun_access;
 +	lun->lun_status = TRANSPORT_LUN_STATUS_ACTIVE;
 +	spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	if (dev->dev_flags & DF_READ_ONLY)
+ 		lun->lun_access = TRANSPORT_LUNFLAGS_READ_ONLY;
+ 	else
+ 		lun->lun_access = lun_access;
+ 	if (!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		hlist_add_head_rcu(&lun->link, &tpg->tpg_lun_hlist);
+ 	mutex_unlock(&tpg->tpg_lun_mutex);
++>>>>>>> eeeb95222311 (target: Propigate backend read-only to core_tpg_add_lun)
  
  	return 0;
 -
 -out_kill_ref:
 -	percpu_ref_exit(&lun->lun_ref);
 -out:
 -	return ret;
  }
  
  void core_tpg_remove_lun(
diff --cc include/target/target_core_base.h
index d06da4551716,5f48754dc36a..000000000000
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@@ -749,7 -730,7 +749,11 @@@ struct se_device 
  #define DF_EMULATED_VPD_UNIT_SERIAL		0x00000004
  #define DF_USING_UDEV_PATH			0x00000008
  #define DF_USING_ALIAS				0x00000010
++<<<<<<< HEAD
 +	u32			dev_port_count;
++=======
+ #define DF_READ_ONLY				0x00000020
++>>>>>>> eeeb95222311 (target: Propigate backend read-only to core_tpg_add_lun)
  	/* Physical device queue depth */
  	u32			queue_depth;
  	/* Used for SPC-2 reservations enforce of ISIDs */
diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c
index 4ff1c8404aab..d1c4dd0fa270 100644
--- a/drivers/target/target_core_iblock.c
+++ b/drivers/target/target_core_iblock.c
@@ -113,6 +113,8 @@ static int iblock_configure_device(struct se_device *dev)
 	mode = FMODE_READ|FMODE_EXCL;
 	if (!ib_dev->ibd_readonly)
 		mode |= FMODE_WRITE;
+	else
+		dev->dev_flags |= DF_READ_ONLY;
 
 	bd = blkdev_get_by_path(ib_dev->ibd_udev_path, mode, ib_dev);
 	if (IS_ERR(bd)) {
* Unmerged path drivers/target/target_core_tpg.c
* Unmerged path include/target/target_core_base.h
