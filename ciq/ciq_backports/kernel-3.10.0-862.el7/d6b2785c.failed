net/mlx5: Cleanup IRQs in case of unload failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [kernel] mlx5: Cleanup IRQs in case of unload failure (Kamal Heib) [1534242]
Rebuild_FUZZ: 95.65%
commit-author Moshe Shemesh <moshe@mellanox.com>
commit d6b2785cd55ee72e9608762650b3ef299f801b1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d6b2785c.failed

When mlx5_stop_eqs fails to destroy any of the eqs it returns with an error.
In such failure flow the function will return without
releasing all EQs irqs and then pci_free_irq_vectors will fail.
Fix by only warn on destroy EQ failure and continue to release other
EQs and their irqs.

It fixes the following kernel trace:
kernel: kernel BUG at drivers/pci/msi.c:352!
...
...
kernel: Call Trace:
kernel: pci_disable_msix+0xd3/0x100
kernel: pci_free_irq_vectors+0xe/0x20
kernel: mlx5_load_one.isra.17+0x9f5/0xec0 [mlx5_core]

Fixes: e126ba97dba9 ("mlx5: Add driver for Mellanox Connect-IB adapters")
	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d6b2785cd55ee72e9608762650b3ef299f801b1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eq.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eq.c
index e96faecb3e7d,ab4d1465b7e4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
@@@ -546,11 -780,24 +546,27 @@@ void mlx5_stop_eqs(struct mlx5_core_de
  	struct mlx5_eq_table *table = &dev->priv.eq_table;
  	int err;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
+ 	if (MLX5_CAP_GEN(dev, pg)) {
+ 		err = mlx5_destroy_unmap_eq(dev, &table->pfault_eq);
+ 		if (err)
+ 			mlx5_core_err(dev, "failed to destroy page fault eq, err(%d)\n",
+ 				      err);
+ 	}
+ #endif
+ 
++>>>>>>> d6b2785cd55e (net/mlx5: Cleanup IRQs in case of unload failure)
  	err = mlx5_destroy_unmap_eq(dev, &table->pages_eq);
  	if (err)
- 		return err;
+ 		mlx5_core_err(dev, "failed to destroy pages eq, err(%d)\n",
+ 			      err);
  
- 	mlx5_destroy_unmap_eq(dev, &table->async_eq);
+ 	err = mlx5_destroy_unmap_eq(dev, &table->async_eq);
+ 	if (err)
+ 		mlx5_core_err(dev, "failed to destroy async eq, err(%d)\n",
+ 			      err);
  	mlx5_cmd_use_polling(dev);
  
  	err = mlx5_destroy_unmap_eq(dev, &table->cmd_eq);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eq.c
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 2c536d21ca92..8e0450f5b056 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -913,7 +913,7 @@ int mlx5_create_map_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq, u8 vecidx,
 		       int nent, u64 mask, const char *name, struct mlx5_uar *uar);
 int mlx5_destroy_unmap_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
 int mlx5_start_eqs(struct mlx5_core_dev *dev);
-int mlx5_stop_eqs(struct mlx5_core_dev *dev);
+void mlx5_stop_eqs(struct mlx5_core_dev *dev);
 int mlx5_vector2eqn(struct mlx5_core_dev *dev, int vector, int *eqn,
 		    unsigned int *irqn);
 int mlx5_core_attach_mcg(struct mlx5_core_dev *dev, union ib_gid *mgid, u32 qpn);
