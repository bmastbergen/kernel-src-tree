dm mpath: avoid that path removal can trigger an infinite loop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 7083abbbfc4fa706ff72d27d33a5214881979336
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7083abbb.failed

If blk_get_request() fails, check whether the failure is due to a path
being removed.  If that is the case, fail the path by triggering a call
to fail_path().  This avoids that the following scenario can be
encountered while removing paths:
* CPU usage of a kworker thread jumps to 100%.
* Removing the DM device becomes impossible.

Delay requeueing if blk_get_request() returns -EBUSY or -EWOULDBLOCK,
and the queue is not dying, because in these cases immediate requeuing
is inappropriate.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: Hannes Reinecke <hare@suse.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 7083abbbfc4fa706ff72d27d33a5214881979336)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-mpath.c
diff --cc drivers/md/dm-mpath.c
index c325423f45d5,f3c79f188747..000000000000
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@@ -532,17 -478,19 +532,23 @@@ static bool must_push_back_bio(struct m
  }
  
  /*
 - * Map cloned requests (request-based multipath)
 + * Map cloned requests
   */
 -static int multipath_clone_and_map(struct dm_target *ti, struct request *rq,
 -				   union map_info *map_context,
 -				   struct request **__clone)
 +static int __multipath_map(struct dm_target *ti, struct request *clone,
 +			   union map_info *map_context,
 +			   struct request *rq, struct request **__clone)
  {
  	struct multipath *m = ti->private;
 -	size_t nr_bytes = blk_rq_bytes(rq);
 +	size_t nr_bytes = clone ? blk_rq_bytes(clone) : blk_rq_bytes(rq);
  	struct pgpath *pgpath;
  	struct block_device *bdev;
++<<<<<<< HEAD
 +	struct dm_mpath_io *mpio;
++=======
+ 	struct dm_mpath_io *mpio = get_mpio(map_context);
+ 	struct request_queue *q;
+ 	struct request *clone;
++>>>>>>> 7083abbbfc4f (dm mpath: avoid that path removal can trigger an infinite loop)
  
  	/* Do we need to select a new pgpath? */
  	pgpath = lockless_dereference(m->current_pgpath);
@@@ -568,33 -512,24 +574,49 @@@
  	mpio->nr_bytes = nr_bytes;
  
  	bdev = pgpath->path.dev->bdev;
++<<<<<<< HEAD
 +
 +	if (clone) {
 +		/*
 +		 * Old request-based interface: allocated clone is passed in.
 +		 * Used by: .request_fn stacked on .request_fn path(s).
 +		 */
 +		clone->q = bdev_get_queue(bdev);
 +		clone->rq_disk = bdev->bd_disk;
 +		clone->cmd_flags |= REQ_FAILFAST_TRANSPORT;
 +	} else {
 +		/*
 +		 * blk-mq request-based interface; used by both:
 +		 * .request_fn stacked on blk-mq path(s) and
 +		 * blk-mq stacked on blk-mq path(s).
 +		 */
 +		clone = blk_mq_alloc_request(bdev_get_queue(bdev),
 +					     rq_data_dir(rq), BLK_MQ_REQ_NOWAIT);
 +		if (IS_ERR(clone)) {
 +			/* EBUSY, ENODEV or EWOULDBLOCK: requeue */
 +			clear_request_fn_mpio(m, map_context);
 +			return DM_MAPIO_DELAY_REQUEUE;
 +		}
 +		clone->bio = clone->biotail = NULL;
 +		clone->rq_disk = bdev->bd_disk;
 +		clone->cmd_flags |= REQ_FAILFAST_TRANSPORT;
 +		*__clone = clone;
++=======
+ 	q = bdev_get_queue(bdev);
+ 	clone = blk_get_request(q, rq->cmd_flags | REQ_NOMERGE, GFP_ATOMIC);
+ 	if (IS_ERR(clone)) {
+ 		/* EBUSY, ENODEV or EWOULDBLOCK: requeue */
+ 		bool queue_dying = blk_queue_dying(q);
+ 		DMERR_LIMIT("blk_get_request() returned %ld%s - requeuing",
+ 			    PTR_ERR(clone), queue_dying ? " (path offline)" : "");
+ 		if (queue_dying) {
+ 			atomic_inc(&m->pg_init_in_progress);
+ 			activate_or_offline_path(pgpath);
+ 			return DM_MAPIO_REQUEUE;
+ 		}
+ 		return DM_MAPIO_DELAY_REQUEUE;
++>>>>>>> 7083abbbfc4f (dm mpath: avoid that path removal can trigger an infinite loop)
  	}
 -	clone->bio = clone->biotail = NULL;
 -	clone->rq_disk = bdev->bd_disk;
 -	clone->cmd_flags |= REQ_FAILFAST_TRANSPORT;
 -	*__clone = clone;
  
  	if (pgpath->pg->ps.type->start_io)
  		pgpath->pg->ps.type->start_io(&pgpath->pg->ps,
* Unmerged path drivers/md/dm-mpath.c
