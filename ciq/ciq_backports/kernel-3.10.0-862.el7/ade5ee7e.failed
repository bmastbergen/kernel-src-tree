drm/i915/cnl: extract cnl_set_procmon_ref_values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paulo Zanoni <paulo.r.zanoni@intel.com>
commit ade5ee7ea55daab37a300374c73aceb3092ccdd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ade5ee7e.failed

Move the part that reads the table and sets registers based on the
table to its own function.

v2: Rebase.

	Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170822000356.17330-2-rodrigo.vivi@intel.com
(cherry picked from commit ade5ee7ea55daab37a300374c73aceb3092ccdd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_runtime_pm.c
diff --cc drivers/gpu/drm/i915/intel_runtime_pm.c
index 87b4af092d54,a3bfb9f27e7a..000000000000
--- a/drivers/gpu/drm/i915/intel_runtime_pm.c
+++ b/drivers/gpu/drm/i915/intel_runtime_pm.c
@@@ -2452,6 -2703,145 +2452,148 @@@ void bxt_display_core_uninit(struct drm
  	intel_power_well_disable(dev_priv, well);
  
  	mutex_unlock(&power_domains->lock);
++<<<<<<< HEAD
++=======
+ 
+ 	usleep_range(10, 30);		/* 10 us delay per Bspec */
+ }
+ 
+ enum {
+ 	PROCMON_0_85V_DOT_0,
+ 	PROCMON_0_95V_DOT_0,
+ 	PROCMON_0_95V_DOT_1,
+ 	PROCMON_1_05V_DOT_0,
+ 	PROCMON_1_05V_DOT_1,
+ };
+ 
+ static const struct cnl_procmon {
+ 	u32 dw1, dw9, dw10;
+ } cnl_procmon_values[] = {
+ 	[PROCMON_0_85V_DOT_0] =
+ 		{ .dw1 = 0x00000000, .dw9 = 0x62AB67BB, .dw10 = 0x51914F96, },
+ 	[PROCMON_0_95V_DOT_0] =
+ 		{ .dw1 = 0x00000000, .dw9 = 0x86E172C7, .dw10 = 0x77CA5EAB, },
+ 	[PROCMON_0_95V_DOT_1] =
+ 		{ .dw1 = 0x00000000, .dw9 = 0x93F87FE1, .dw10 = 0x8AE871C5, },
+ 	[PROCMON_1_05V_DOT_0] =
+ 		{ .dw1 = 0x00000000, .dw9 = 0x98FA82DD, .dw10 = 0x89E46DC1, },
+ 	[PROCMON_1_05V_DOT_1] =
+ 		{ .dw1 = 0x00440000, .dw9 = 0x9A00AB25, .dw10 = 0x8AE38FF1, },
+ };
+ 
+ static void cnl_set_procmon_ref_values(struct drm_i915_private *dev_priv)
+ {
+ 	const struct cnl_procmon *procmon;
+ 	u32 val;
+ 
+ 	val = I915_READ(CNL_PORT_COMP_DW3);
+ 	switch (val & (PROCESS_INFO_MASK | VOLTAGE_INFO_MASK)) {
+ 	default:
+ 		MISSING_CASE(val);
+ 	case VOLTAGE_INFO_0_85V | PROCESS_INFO_DOT_0:
+ 		procmon = &cnl_procmon_values[PROCMON_0_85V_DOT_0];
+ 		break;
+ 	case VOLTAGE_INFO_0_95V | PROCESS_INFO_DOT_0:
+ 		procmon = &cnl_procmon_values[PROCMON_0_95V_DOT_0];
+ 		break;
+ 	case VOLTAGE_INFO_0_95V | PROCESS_INFO_DOT_1:
+ 		procmon = &cnl_procmon_values[PROCMON_0_95V_DOT_1];
+ 		break;
+ 	case VOLTAGE_INFO_1_05V | PROCESS_INFO_DOT_0:
+ 		procmon = &cnl_procmon_values[PROCMON_1_05V_DOT_0];
+ 		break;
+ 	case VOLTAGE_INFO_1_05V | PROCESS_INFO_DOT_1:
+ 		procmon = &cnl_procmon_values[PROCMON_1_05V_DOT_1];
+ 		break;
+ 	}
+ 
+ 	val = I915_READ(CNL_PORT_COMP_DW1);
+ 	val &= ~((0xff << 16) | 0xff);
+ 	val |= procmon->dw1;
+ 	I915_WRITE(CNL_PORT_COMP_DW1, val);
+ 
+ 	I915_WRITE(CNL_PORT_COMP_DW9, procmon->dw9);
+ 	I915_WRITE(CNL_PORT_COMP_DW10, procmon->dw10);
+ }
+ 
+ static void cnl_display_core_init(struct drm_i915_private *dev_priv, bool resume)
+ {
+ 	struct i915_power_domains *power_domains = &dev_priv->power_domains;
+ 	struct i915_power_well *well;
+ 	u32 val;
+ 
+ 	gen9_set_dc_state(dev_priv, DC_STATE_DISABLE);
+ 
+ 	/* 1. Enable PCH Reset Handshake */
+ 	val = I915_READ(HSW_NDE_RSTWRN_OPT);
+ 	val |= RESET_PCH_HANDSHAKE_ENABLE;
+ 	I915_WRITE(HSW_NDE_RSTWRN_OPT, val);
+ 
+ 	/* 2. Enable Comp */
+ 	val = I915_READ(CHICKEN_MISC_2);
+ 	val &= ~CNL_COMP_PWR_DOWN;
+ 	I915_WRITE(CHICKEN_MISC_2, val);
+ 
+ 	cnl_set_procmon_ref_values(dev_priv);
+ 
+ 	val = I915_READ(CNL_PORT_COMP_DW0);
+ 	val |= COMP_INIT;
+ 	I915_WRITE(CNL_PORT_COMP_DW0, val);
+ 
+ 	/* 3. */
+ 	val = I915_READ(CNL_PORT_CL1CM_DW5);
+ 	val |= CL_POWER_DOWN_ENABLE;
+ 	I915_WRITE(CNL_PORT_CL1CM_DW5, val);
+ 
+ 	/*
+ 	 * 4. Enable Power Well 1 (PG1).
+ 	 *    The AUX IO power wells will be enabled on demand.
+ 	 */
+ 	mutex_lock(&power_domains->lock);
+ 	well = lookup_power_well(dev_priv, SKL_DISP_PW_1);
+ 	intel_power_well_enable(dev_priv, well);
+ 	mutex_unlock(&power_domains->lock);
+ 
+ 	/* 5. Enable CD clock */
+ 	cnl_init_cdclk(dev_priv);
+ 
+ 	/* 6. Enable DBUF */
+ 	gen9_dbuf_enable(dev_priv);
+ }
+ 
+ static void cnl_display_core_uninit(struct drm_i915_private *dev_priv)
+ {
+ 	struct i915_power_domains *power_domains = &dev_priv->power_domains;
+ 	struct i915_power_well *well;
+ 	u32 val;
+ 
+ 	gen9_set_dc_state(dev_priv, DC_STATE_DISABLE);
+ 
+ 	/* 1. Disable all display engine functions -> aready done */
+ 
+ 	/* 2. Disable DBUF */
+ 	gen9_dbuf_disable(dev_priv);
+ 
+ 	/* 3. Disable CD clock */
+ 	cnl_uninit_cdclk(dev_priv);
+ 
+ 	/*
+ 	 * 4. Disable Power Well 1 (PG1).
+ 	 *    The AUX IO power wells are toggled on demand, so they are already
+ 	 *    disabled at this point.
+ 	 */
+ 	mutex_lock(&power_domains->lock);
+ 	well = lookup_power_well(dev_priv, SKL_DISP_PW_1);
+ 	intel_power_well_disable(dev_priv, well);
+ 	mutex_unlock(&power_domains->lock);
+ 
+ 	usleep_range(10, 30);		/* 10 us delay per Bspec */
+ 
+ 	/* 5. Disable Comp */
+ 	val = I915_READ(CHICKEN_MISC_2);
+ 	val |= CNL_COMP_PWR_DOWN;
+ 	I915_WRITE(CHICKEN_MISC_2, val);
++>>>>>>> ade5ee7ea55d (drm/i915/cnl: extract cnl_set_procmon_ref_values)
  }
  
  static void chv_phy_control_init(struct drm_i915_private *dev_priv)
* Unmerged path drivers/gpu/drm/i915/intel_runtime_pm.c
