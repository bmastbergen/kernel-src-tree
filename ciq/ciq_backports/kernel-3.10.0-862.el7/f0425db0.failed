nvme: use ctrl->device consistently for logging

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] use ctrl->device consistently for logging (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 93.18%
commit-author Johannes Thumshirn <jthumshirn@suse.de>
commit f0425db00ce4241a635463729317b06406ab6b3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f0425db0.failed

Change the few left over users of ctrl->dev over to using ctrl->device
for logging purposes, so we consistently use the same device.

	Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit f0425db00ce4241a635463729317b06406ab6b3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index b83a9ba5ece8,4554c605f24e..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1200,6 -1637,30 +1200,33 @@@ int nvme_init_identify(struct nvme_ctr
  		return -EIO;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (!ctrl->identified) {
+ 		/*
+ 		 * Check for quirks.  Quirk can depend on firmware version,
+ 		 * so, in principle, the set of quirks present can change
+ 		 * across a reset.  As a possible future enhancement, we
+ 		 * could re-scan for quirks every time we reinitialize
+ 		 * the device, but we'd have to make sure that the driver
+ 		 * behaves intelligently if the quirks change.
+ 		 */
+ 
+ 		int i;
+ 
+ 		for (i = 0; i < ARRAY_SIZE(core_quirks); i++) {
+ 			if (quirk_matches(id, &core_quirks[i]))
+ 				ctrl->quirks |= core_quirks[i].quirks;
+ 		}
+ 	}
+ 
+ 	if (force_apst && (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS)) {
+ 		dev_warn(ctrl->device, "forcibly allowing all power states due to nvme_core.force_apst -- use at your own risk\n");
+ 		ctrl->quirks &= ~NVME_QUIRK_NO_DEEPEST_PS;
+ 	}
+ 
+ 	ctrl->oacs = le16_to_cpu(id->oacs);
++>>>>>>> f0425db00ce4 (nvme: use ctrl->device consistently for logging)
  	ctrl->vid = le16_to_cpu(id->vid);
  	ctrl->oncs = le16_to_cpup(&id->oncs);
  	atomic_set(&ctrl->abort_limit, id->acl + 1);
@@@ -1219,7 -1680,21 +1246,25 @@@
  	ctrl->sgls = le32_to_cpu(id->sgls);
  	ctrl->kas = le16_to_cpu(id->kas);
  
++<<<<<<< HEAD
 +	if (ctrl->ops->is_fabrics) {
++=======
+ 	ctrl->npss = id->npss;
+ 	prev_apsta = ctrl->apsta;
+ 	if (ctrl->quirks & NVME_QUIRK_NO_APST) {
+ 		if (force_apst && id->apsta) {
+ 			dev_warn(ctrl->device, "forcibly allowing APST due to nvme_core.force_apst -- use at your own risk\n");
+ 			ctrl->apsta = 1;
+ 		} else {
+ 			ctrl->apsta = 0;
+ 		}
+ 	} else {
+ 		ctrl->apsta = id->apsta;
+ 	}
+ 	memcpy(ctrl->psd, id->psd, sizeof(ctrl->psd));
+ 
+ 	if (ctrl->ops->flags & NVME_F_FABRICS) {
++>>>>>>> f0425db00ce4 (nvme: use ctrl->device consistently for logging)
  		ctrl->icdoff = le16_to_cpu(id->icdoff);
  		ctrl->ioccsz = le32_to_cpu(id->ioccsz);
  		ctrl->iorcsz = le32_to_cpu(id->iorcsz);
@@@ -1650,6 -2148,21 +1695,24 @@@ static void nvme_alloc_ns(struct nvme_c
  	blk_queue_logical_block_size(ns->queue, 1 << ns->lba_shift);
  	nvme_set_queue_limits(ctrl, ns->queue);
  
++<<<<<<< HEAD
++=======
+ 	sprintf(disk_name, "nvme%dn%d", ctrl->instance, ns->instance);
+ 
+ 	if (nvme_revalidate_ns(ns, &id))
+ 		goto out_free_queue;
+ 
+ 	if (nvme_nvm_ns_supported(ns, id) &&
+ 				nvme_nvm_register(ns, disk_name, node)) {
+ 		dev_warn(ctrl->device, "%s: LightNVM init failure\n", __func__);
+ 		goto out_free_id;
+ 	}
+ 
+ 	disk = alloc_disk_node(0, node);
+ 	if (!disk)
+ 		goto out_free_id;
+ 
++>>>>>>> f0425db00ce4 (nvme: use ctrl->device consistently for logging)
  	disk->fops = &nvme_fops;
  	disk->private_data = ns;
  	disk->queue = ns->queue;
* Unmerged path drivers/nvme/host/core.c
