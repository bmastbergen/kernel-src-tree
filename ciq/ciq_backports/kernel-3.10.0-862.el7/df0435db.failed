ALSA: x86: Use the standard ELD bytes definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit df0435db1db9e385acdc0a354896d2c0e878dbd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/df0435db.failed

We have some constants defined in drm/drm_edid.h, and clean up our own
definitions.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit df0435db1db9e385acdc0a354896d2c0e878dbd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
#	sound/x86/intel_hdmi_audio.h
#	sound/x86/intel_hdmi_lpe_audio.h
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,496d3e92b2a8..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -432,7 -451,7 +432,11 @@@ static int snd_intelhad_channel_allocat
  	 */
  
  	for (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {
++<<<<<<< HEAD
 +		if (intelhaddata->eeld.speaker_allocation_block & (1 << i))
++=======
+ 		if (intelhaddata->eld[DRM_ELD_SPEAKER] & (1 << i))
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  			spk_mask |= eld_speaker_allocation_bits[i];
  	}
  
@@@ -477,11 -496,8 +481,16 @@@ void had_build_channel_allocation_map(s
  		return;
  	}
  
++<<<<<<< HEAD
 +	had_get_caps(intelhaddata, HAD_GET_ELD, &intelhaddata->eeld);
 +	had_get_caps(intelhaddata, HAD_GET_DP_OUTPUT, &intelhaddata->dp_output);
 +
 +	pr_debug("eeld.speaker_allocation_block = %x\n",
 +			intelhaddata->eeld.speaker_allocation_block);
++=======
+ 	dev_dbg(intelhaddata->dev, "eld speaker = %x\n",
+ 		intelhaddata->eld[DRM_ELD_SPEAKER]);
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  
  	/* WA: Fix the max channel supported to 8 */
  
@@@ -492,14 -508,14 +501,22 @@@
  	 */
  
  	/* if 0x2F < eld < 0x4F fall back to 0x2f, else fall back to 0x4F */
++<<<<<<< HEAD
 +	eld_high = intelhaddata->eeld.speaker_allocation_block & eld_high_mask;
++=======
+ 	eld_high = intelhaddata->eld[DRM_ELD_SPEAKER] & eld_high_mask;
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  	if ((eld_high & (eld_high-1)) && (eld_high > 0x1F)) {
  		/* eld_high & (eld_high-1): if more than 1 bit set */
  		/* 0x1F: 7 channels */
  		for (i = 1; i < 4; i++) {
  			high_msb = eld_high & (0x80 >> i);
  			if (high_msb) {
++<<<<<<< HEAD
 +				intelhaddata->eeld.speaker_allocation_block &=
++=======
+ 				intelhaddata->eld[DRM_ELD_SPEAKER] &=
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  					high_msb | 0xF;
  				break;
  			}
@@@ -507,7 -523,7 +524,11 @@@
  	}
  
  	for (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {
++<<<<<<< HEAD
 +		if (intelhaddata->eeld.speaker_allocation_block & (1 << i))
++=======
+ 		if (intelhaddata->eld[DRM_ELD_SPEAKER] & (1 << i))
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  			spk_mask |= eld_speaker_allocation_bits[i];
  	}
  
@@@ -1575,62 -1681,222 +1596,142 @@@ static struct snd_kcontrol_new had_cont
  	.put =          had_iec958_put
  };
  
++<<<<<<< HEAD
++=======
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad *ctx = dev_id;
+ 	u32 audio_stat, audio_reg;
+ 
+ 	audio_reg = AUD_HDMI_STATUS;
+ 	mid_hdmi_audio_read(ctx, audio_reg, &audio_stat);
+ 
+ 	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_UNDERRUN);
+ 		had_process_buffer_underrun(ctx);
+ 	}
+ 
+ 	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 		mid_hdmi_audio_write(ctx, audio_reg, HDMI_AUDIO_BUFFER_DONE);
+ 		had_process_buffer_done(ctx);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
+ 
+ 	schedule_work(&ctx->hdmi_audio_wq);
+ }
+ 
+ static void had_audio_wq(struct work_struct *work)
+ {
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 
+ 	pm_runtime_get_sync(ctx->dev);
+ 	mutex_lock(&ctx->mutex);
+ 	if (!pdata->hdmi_connected) {
+ 		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 		had_process_hot_unplug(ctx);
+ 	} else {
+ 		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
+ 
+ 		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, eld->port_id,	pdata->tmds_clock_speed);
+ 
+ 		switch (eld->pipe_id) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(ctx->dev, "Invalid pipe %d\n",
+ 				eld->pipe_id);
+ 			break;
+ 		}
+ 
+ 		memcpy(ctx->eld, eld->eld_data, sizeof(ctx->eld));
+ 
+ 		ctx->dp_output = pdata->dp_output;
+ 		ctx->tmds_clock_speed = pdata->tmds_clock_speed;
+ 		ctx->link_rate = pdata->link_rate;
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		/* Process mode change if stream is active */
+ 		hdmi_audio_mode_change(ctx);
+ 	}
+ 	mutex_unlock(&ctx->mutex);
+ 	pm_runtime_put(ctx->dev);
+ }
+ 
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  /*
 - * PM callbacks
 - */
 -
 -static int hdmi_lpe_audio_runtime_suspend(struct device *dev)
 -{
 -	struct snd_intelhad *ctx = dev_get_drvdata(dev);
 -	struct snd_pcm_substream *substream;
 -
 -	substream = had_substream_get(ctx);
 -	if (substream) {
 -		snd_pcm_suspend(substream);
 -		had_substream_put(ctx);
 -	}
 -
 -	return 0;
 -}
 -
 -static int hdmi_lpe_audio_suspend(struct device *dev)
 -{
 -	struct snd_intelhad *ctx = dev_get_drvdata(dev);
 -	int err;
 -
 -	err = hdmi_lpe_audio_runtime_suspend(dev);
 -	if (!err)
 -		snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D3hot);
 -	return err;
 -}
 -
 -static int hdmi_lpe_audio_resume(struct device *dev)
 -{
 -	struct snd_intelhad *ctx = dev_get_drvdata(dev);
 -
 -	snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D0);
 -	return 0;
 -}
 -
 -/* release resources */
 -static void hdmi_lpe_audio_free(struct snd_card *card)
 -{
 -	struct snd_intelhad *ctx = card->private_data;
 -
 -	cancel_work_sync(&ctx->hdmi_audio_wq);
 -
 -	if (ctx->mmio_start)
 -		iounmap(ctx->mmio_start);
 -	if (ctx->irq >= 0)
 -		free_irq(ctx->irq, ctx);
 -}
 -
 -/*
 - * hdmi_lpe_audio_probe - start bridge with i915
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
 + *
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
 -	struct snd_card *card;
 -	struct snd_intelhad *ctx;
 +	int retval;
  	struct snd_pcm *pcm;
 -	struct intel_hdmi_lpe_audio_pdata *pdata;
 -	int irq;
 -	struct resource *res_mmio;
 -	int ret;
 -
 -	dev_dbg(&pdev->dev, "dma_mask: %p\n", pdev->dev.dma_mask);
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
  
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	pr_debug("Enter %s\n", __func__);
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 -	}
 -
 -	/* create a card instance with ALSA framework */
 -	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
 -			   THIS_MODULE, sizeof(*ctx), &card);
 -	if (ret)
 -		return ret;
 -
 -	ctx = card->private_data;
 -	spin_lock_init(&ctx->had_spinlock);
 -	mutex_init(&ctx->mutex);
 -	ctx->drv_status = HAD_DRV_DISCONNECTED;
 -	ctx->dev = &pdev->dev;
 -	ctx->card = card;
 -	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 -	strcpy(card->driver, INTEL_HAD);
 -	strcpy(card->shortname, INTEL_HAD);
 -
 -	ctx->irq = -1;
 -	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
 -	INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
 -
 -	card->private_free = hdmi_lpe_audio_free;
 -
 -	/* assume pipe A as default */
 -	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -
 -	platform_set_drvdata(pdev, ctx);
 -
 -	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
 -		__func__, (unsigned int)res_mmio->start,
 -		(unsigned int)res_mmio->end);
 -
 -	ctx->mmio_start = ioremap_nocache(res_mmio->start,
 -					  (size_t)(resource_size(res_mmio)));
 -	if (!ctx->mmio_start) {
 -		dev_err(&pdev->dev, "Could not get ioremap\n");
 -		ret = -EACCES;
 -		goto err;
 -	}
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
  
 -	/* setup interrupt handler */
 -	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
 -			  pdev->name, ctx);
 -	if (ret < 0) {
 -		dev_err(&pdev->dev, "request_irq failed\n");
 -		goto err;
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 -	ctx->irq = irq;
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
  
 -	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 -			  MAX_CAP_STREAMS, &pcm);
 -	if (ret)
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
 +
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
diff --cc sound/x86/intel_hdmi_audio.h
index 32a2fb766e47,4ccaa8b18566..000000000000
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@@ -37,10 -37,9 +37,11 @@@
  #include <sound/asoundef.h>
  #include <sound/control.h>
  #include <sound/pcm.h>
+ #include <drm/drm_edid.h>
  #include "intel_hdmi_lpe_audio.h"
  
 +struct platform_device;
 +
  #define PCM_INDEX		0
  #define MAX_PB_STREAMS		1
  #define MAX_CAP_STREAMS		0
@@@ -127,7 -108,7 +128,11 @@@ struct snd_intelhad 
  	enum had_drv_status	drv_status;
  	struct		ring_buf_info buf_info[HAD_NUM_OF_RING_BUFS];
  	struct		pcm_stream_info stream_info;
++<<<<<<< HEAD
 +	union otm_hdmi_eld_t	eeld;
++=======
+ 	unsigned char	eld[HDMI_MAX_ELD_BYTES];
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  	bool dp_output;
  	enum		intel_had_aud_buf_type curr_buf;
  	int		valid_buf_cnt;
diff --cc sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57,f9c184960b34..000000000000
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@@ -103,148 -104,6 +103,151 @@@
  #define MAX_CNT			0xFF
  #define HAD_SUSPEND_DELAY	1000
  
++<<<<<<< HEAD
 +#define OTM_HDMI_ELD_SIZE 128
 +
 +union otm_hdmi_eld_t {
 +	unsigned char eld_data[OTM_HDMI_ELD_SIZE];
 +	struct {
 +		/* Byte[0] = ELD Version Number */
 +		union {
 +			unsigned char   byte0;
 +			struct {
 +				unsigned char reserved:3; /* Reserf */
 +				unsigned char eld_ver:5; /* ELD Version Number */
 +				/* 00000b - reserved
 +				 * 00001b - first rev, obsoleted
 +				 * 00010b - version 2, supporting CEA version
 +				 *			861D or below
 +				 * 00011b:11111b - reserved
 +				 * for future
 +				 */
 +			};
 +		};
 +
 +		/* Byte[1] = Vendor Version Field */
 +		union {
 +			unsigned char vendor_version;
 +			struct {
 +				unsigned char reserved1:3;
 +				unsigned char veld_ver:5; /* Version number of the ELD
 +						     * extension. This value is
 +						     * provisioned and unique to
 +						     * each vendor.
 +						     */
 +			};
 +		};
 +
 +		/* Byte[2] = Baseline Length field */
 +		unsigned char baseline_eld_length; /* Length of the Baseline structure
 +					      *	divided by Four.
 +					      */
 +
 +		/* Byte [3] = Reserved for future use */
 +		unsigned char byte3;
 +
 +		/* Starting of the BaseLine EELD structure
 +		 * Byte[4] = Monitor Name Length
 +		 */
 +		union {
 +			unsigned char byte4;
 +			struct {
 +				unsigned char mnl:5;
 +				unsigned char cea_edid_rev_id:3;
 +			};
 +		};
 +
 +		/* Byte[5] = Capabilities */
 +		union {
 +			unsigned char capabilities;
 +			struct {
 +				unsigned char hdcp:1; /* HDCP support */
 +				unsigned char ai_support:1;   /* AI support */
 +				unsigned char connection_type:2; /* Connection type
 +							    * 00 - HDMI
 +							    * 01 - DP
 +							    * 10 -11  Reserved
 +							    * for future
 +							    * connection types
 +							    */
 +				unsigned char sadc:4; /* Indicates number of 3 bytes
 +						 * Short Audio Descriptors.
 +						 */
 +			};
 +		};
 +
 +		/* Byte[6] = Audio Synch Delay */
 +		unsigned char audio_synch_delay; /* Amount of time reported by the
 +					    * sink that the video trails audio
 +					    * in milliseconds.
 +					    */
 +
 +		/* Byte[7] = Speaker Allocation Block */
 +		union {
 +			unsigned char speaker_allocation_block;
 +			struct {
 +				unsigned char flr:1; /*Front Left and Right channels*/
 +				unsigned char lfe:1; /*Low Frequency Effect channel*/
 +				unsigned char fc:1;  /*Center transmission channel*/
 +				unsigned char rlr:1; /*Rear Left and Right channels*/
 +				unsigned char rc:1; /*Rear Center channel*/
 +				unsigned char flrc:1; /*Front left and Right of Center
 +						 *transmission channels
 +						 */
 +				unsigned char rlrc:1; /*Rear left and Right of Center
 +						 *transmission channels
 +						 */
 +				unsigned char reserved3:1; /* Reserved */
 +			};
 +		};
 +
 +		/* Byte[8 - 15] - 8 Byte port identification value */
 +		unsigned char port_id_value[8];
 +
 +		/* Byte[16 - 17] - 2 Byte Manufacturer ID */
 +		unsigned char manufacturer_id[2];
 +
 +		/* Byte[18 - 19] - 2 Byte Product ID */
 +		unsigned char product_id[2];
 +
 +		/* Byte [20-83] - 64 Bytes of BaseLine Data */
 +		unsigned char mn_sand_sads[64]; /* This will include
 +					   * - ASCII string of Monitor name
 +					   * - List of 3 byte SADs
 +					   * - Zero padding
 +					   */
 +
 +		/* Vendor ELD Block should continue here!
 +		 * No Vendor ELD block defined as of now.
 +		 */
 +	} __packed;
 +};
 +
 +/**
 + * enum had_status - Audio stream states
 + *
 + * @STREAM_INIT: Stream initialized
 + * @STREAM_RUNNING: Stream running
 + * @STREAM_PAUSED: Stream paused
 + * @STREAM_DROPPED: Stream dropped
 + */
 +enum had_stream_status {
 +	STREAM_INIT = 0,
 +	STREAM_RUNNING = 1,
 +	STREAM_PAUSED = 2,
 +	STREAM_DROPPED = 3
 +};
 +
 +/**
 + * enum had_status_stream - HAD stream states
 + */
 +enum had_status_stream {
 +	HAD_INIT = 0,
 +	HAD_RUNNING_STREAM,
 +};
 +
++=======
++>>>>>>> df0435db1db9 (ALSA: x86: Use the standard ELD bytes definitions)
  enum had_drv_status {
  	HAD_DRV_CONNECTED,
  	HAD_DRV_RUNNING,
* Unmerged path sound/x86/intel_hdmi_audio.c
* Unmerged path sound/x86/intel_hdmi_audio.h
* Unmerged path sound/x86/intel_hdmi_lpe_audio.h
