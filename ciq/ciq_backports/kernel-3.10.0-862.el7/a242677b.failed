fsnotify: Move locking into fsnotify_recalc_mask()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit a242677bb1e6faa9bd82bd33afb2621071258231
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a242677b.failed

Move locking of locks protecting a list of marks into
fsnotify_recalc_mask(). This reduces code churn in the following patch
which changes the lock protecting the list of marks.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit a242677bb1e6faa9bd82bd33afb2621071258231)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/dnotify/dnotify.c
#	fs/notify/fsnotify.h
#	fs/notify/inode_mark.c
#	fs/notify/mark.c
#	fs/notify/vfsmount_mark.c
diff --cc fs/notify/dnotify/dnotify.c
index 38696275be90,41b2a070761c..000000000000
--- a/fs/notify/dnotify/dnotify.c
+++ b/fs/notify/dnotify/dnotify.c
@@@ -69,8 -69,7 +69,12 @@@ static void dnotify_recalc_inode_mask(s
  	if (old_mask == new_mask)
  		return;
  
++<<<<<<< HEAD
 +	if (fsn_mark->inode)
 +		fsnotify_recalc_inode_mask(fsn_mark->inode);
++=======
+ 	fsnotify_recalc_mask(fsn_mark->connector);
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  }
  
  /*
diff --cc fs/notify/fsnotify.h
index 0a3bc2cf192c,96051780d50e..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -14,9 -14,6 +14,12 @@@ extern void fsnotify_flush_notify(struc
  /* protects reads of inode and vfsmount marks list */
  extern struct srcu_struct fsnotify_mark_srcu;
  
++<<<<<<< HEAD
 +/* Calculate mask of events for a list of marks */
 +extern u32 fsnotify_recalc_mask(struct hlist_head *head);
 +
++=======
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  /* compare two groups for sorting of marks lists */
  extern int fsnotify_compare_groups(struct fsnotify_group *a,
  				   struct fsnotify_group *b);
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,9b2f4e6eb8eb..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -30,22 -30,15 +30,22 @@@
  
  #include "../internal.h"
  
- /*
-  * Recalculate the inode->i_fsnotify_mask, or the mask of all FS_* event types
-  * any notifier is interested in hearing for this inode.
-  */
  void fsnotify_recalc_inode_mask(struct inode *inode)
  {
++<<<<<<< HEAD
 +	spin_lock(&inode->i_lock);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	__fsnotify_update_child_dentry_flags(inode);
++=======
+ 	fsnotify_recalc_mask(inode->i_fsnotify_marks);
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  }
  
 -struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
 +void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
  {
 -	struct inode *inode = mark->connector->inode;
 -	bool empty;
 +	struct inode *inode = mark->inode;
  
  	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
  	assert_spin_locked(&mark->lock);
@@@ -53,15 -46,14 +53,23 @@@
  	spin_lock(&inode->i_lock);
  
  	hlist_del_init_rcu(&mark->obj_list);
 -	empty = hlist_empty(&mark->connector->list);
 -	mark->connector = NULL;
 -
 +	mark->inode = NULL;
 +
++<<<<<<< HEAD
 +	/*
 +	 * this mark is now off the inode->i_fsnotify_marks list and we
 +	 * hold the inode->i_lock, so this is the perfect time to update the
 +	 * inode->i_fsnotify_mask
 +	 */
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
++=======
+ 	spin_unlock(&inode->i_lock);
+ 
+ 	fsnotify_recalc_mask(inode->i_fsnotify_marks);
+ 
+ 	return empty ? inode : NULL;
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  }
  
  /*
diff --cc fs/notify/mark.c
index 44836e539169,06faf166c7ae..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -103,15 -105,40 +103,49 @@@ void fsnotify_put_mark(struct fsnotify_
  	}
  }
  
++<<<<<<< HEAD
 +/* Calculate mask of events for a list of marks */
 +u32 fsnotify_recalc_mask(struct hlist_head *head)
++=======
+ static void __fsnotify_recalc_mask(struct fsnotify_mark_connector *conn)
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  {
  	u32 new_mask = 0;
  	struct fsnotify_mark *mark;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry(mark, head, obj_list)
++=======
+ 	hlist_for_each_entry(mark, &conn->list, obj_list)
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  		new_mask |= mark->mask;
- 	return new_mask;
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		conn->inode->i_fsnotify_mask = new_mask;
+ 	else if (conn->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT)
+ 		real_mount(conn->mnt)->mnt_fsnotify_mask = new_mask;
+ }
+ 
+ /*
+  * Calculate mask of events for a list of marks. The caller must make sure
+  * connector cannot disappear under us (usually by holding a mark->lock or
+  * mark->group->mark_mutex for a mark on this list).
+  */
+ void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn)
+ {
+ 	if (!conn)
+ 		return;
+ 
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		spin_lock(&conn->inode->i_lock);
+ 	else
+ 		spin_lock(&conn->mnt->mnt_root->d_lock);
+ 	__fsnotify_recalc_mask(conn);
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE) {
+ 		spin_unlock(&conn->inode->i_lock);
+ 		__fsnotify_update_child_dentry_flags(conn->inode);
+ 	} else {
+ 		spin_unlock(&conn->mnt->mnt_root->d_lock);
+ 	}
  }
  
  /*
@@@ -366,25 -439,14 +400,34 @@@ int fsnotify_add_mark_locked(struct fsn
  	list_add(&mark->g_list, &group->marks_list);
  	atomic_inc(&group->num_marks);
  	fsnotify_get_mark(mark); /* for i_list and g_list */
 +
 +	if (inode) {
 +		ret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);
 +		if (ret)
 +			goto err;
 +	} else if (mnt) {
 +		ret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);
 +		if (ret)
 +			goto err;
 +	} else {
 +		BUG();
 +	}
 +
 +	/* this will pin the object if appropriate */
 +	fsnotify_set_mark_mask_locked(mark, mark->mask);
  	spin_unlock(&mark->lock);
  
++<<<<<<< HEAD
 +	if (inode)
 +		__fsnotify_update_child_dentry_flags(inode);
++=======
+ 	ret = fsnotify_add_mark_list(mark, inode, mnt, allow_dups);
+ 	if (ret)
+ 		goto err;
+ 
+ 	if (mark->mask)
+ 		fsnotify_recalc_mask(mark->connector);
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  
  	return ret;
  err:
diff --cc fs/notify/vfsmount_mark.c
index a8fcab68faef,ffe0d7098cba..000000000000
--- a/fs/notify/vfsmount_mark.c
+++ b/fs/notify/vfsmount_mark.c
@@@ -31,20 -31,12 +31,20 @@@
  
  void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)
  {
 -	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_OBJ_TYPE_VFSMOUNT);
 +	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_VFSMOUNT);
  }
  
- /*
-  * Recalculate the mnt->mnt_fsnotify_mask, or the mask of all FS_* event types
-  * any notifier is interested in hearing for this mount point
-  */
  void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)
  {
++<<<<<<< HEAD
 +	struct mount *m = real_mount(mnt);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
++=======
+ 	fsnotify_recalc_mask(real_mount(mnt)->mnt_fsnotify_marks);
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  }
  
  void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)
@@@ -58,10 -50,11 +58,15 @@@
  	spin_lock(&mnt->mnt_root->d_lock);
  
  	hlist_del_init_rcu(&mark->obj_list);
 -	mark->connector = NULL;
 +	mark->mnt = NULL;
  
++<<<<<<< HEAD
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
++=======
++>>>>>>> a242677bb1e6 (fsnotify: Move locking into fsnotify_recalc_mask())
  	spin_unlock(&mnt->mnt_root->d_lock);
+ 
+ 	fsnotify_recalc_mask(m->mnt_fsnotify_marks);
  }
  
  /*
* Unmerged path fs/notify/dnotify/dnotify.c
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/inode_mark.c
* Unmerged path fs/notify/mark.c
* Unmerged path fs/notify/vfsmount_mark.c
diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h
index 0256909191e5..4ed4d6b62a1b 100644
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@ -331,6 +331,8 @@ extern struct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group
 
 /* functions used to manipulate the marks attached to inodes */
 
+/* Calculate mask of events for a list of marks */
+extern void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
 /* run all marks associated with a vfsmount and update mnt->mnt_fsnotify_mask */
 extern void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt);
 /* run all marks associated with an inode and update inode->i_fsnotify_mask */
