s390/gs: add regset for the guarded storage broadcast control block

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit e525f8a6e696210d15f8b8277d4da12fc4add299
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e525f8a6.failed

The guarded storage interface allows to register a control block for
each thread that is activated with the guarded storage broadcast event.
To retrieve the complete state of a process from the kernel a register
set for the stored broadcast control block is required.

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit e525f8a6e696210d15f8b8277d4da12fc4add299)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/ptrace.c
#	include/uapi/linux/elf.h
diff --cc arch/s390/kernel/ptrace.c
index 490e6f6a7017,488c5bb8dc77..000000000000
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@@ -1201,6 -1149,74 +1201,77 @@@ static int s390_system_call_set(struct 
  				  data, 0, sizeof(unsigned int));
  }
  
++<<<<<<< HEAD
++=======
+ static int s390_gs_cb_get(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  void *kbuf, void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data)
+ 		return -ENODATA;
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+ 				   data, 0, sizeof(struct gs_cb));
+ }
+ 
+ static int s390_gs_cb_set(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  const void *kbuf, const void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data) {
+ 		data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 		if (!data)
+ 			return -ENOMEM;
+ 		target->thread.gs_cb = data;
+ 	}
+ 	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				  data, 0, sizeof(struct gs_cb));
+ }
+ 
+ static int s390_gs_bc_get(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  void *kbuf, void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_bc_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data)
+ 		return -ENODATA;
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+ 				   data, 0, sizeof(struct gs_cb));
+ }
+ 
+ static int s390_gs_bc_set(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  const void *kbuf, const void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_bc_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data) {
+ 		data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 		if (!data)
+ 			return -ENOMEM;
+ 		target->thread.gs_bc_cb = data;
+ 	}
+ 	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				  data, 0, sizeof(struct gs_cb));
+ }
+ 
++>>>>>>> e525f8a6e696 (s390/gs: add regset for the guarded storage broadcast control block)
  static const struct user_regset s390_regsets[] = {
  	{
  		.core_note_type = NT_PRSTATUS,
@@@ -1259,7 -1274,22 +1330,26 @@@
  		.get = s390_vxrs_high_get,
  		.set = s390_vxrs_high_set,
  	},
++<<<<<<< HEAD
 +#endif
++=======
+ 	{
+ 		.core_note_type = NT_S390_GS_CB,
+ 		.n = sizeof(struct gs_cb) / sizeof(__u64),
+ 		.size = sizeof(__u64),
+ 		.align = sizeof(__u64),
+ 		.get = s390_gs_cb_get,
+ 		.set = s390_gs_cb_set,
+ 	},
+ 	{
+ 		.core_note_type = NT_S390_GS_BC,
+ 		.n = sizeof(struct gs_cb) / sizeof(__u64),
+ 		.size = sizeof(__u64),
+ 		.align = sizeof(__u64),
+ 		.get = s390_gs_bc_get,
+ 		.set = s390_gs_bc_set,
+ 	},
++>>>>>>> e525f8a6e696 (s390/gs: add regset for the guarded storage broadcast control block)
  };
  
  static const struct user_regset_view user_s390_view = {
diff --cc include/uapi/linux/elf.h
index 0d8d5e022e25,176b6cb1008d..000000000000
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@@ -406,6 -409,8 +406,11 @@@ typedef struct elf64_shdr 
  #define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
  #define NT_S390_VXRS_LOW	0x309	/* s390 vector registers 0-15 upper half */
  #define NT_S390_VXRS_HIGH	0x30a	/* s390 vector registers 16-31 */
++<<<<<<< HEAD
++=======
+ #define NT_S390_GS_CB	0x30b		/* s390 guarded storage registers */
+ #define NT_S390_GS_BC	0x30c		/* s390 guarded storage broadcast control block */
++>>>>>>> e525f8a6e696 (s390/gs: add regset for the guarded storage broadcast control block)
  #define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
  #define NT_ARM_TLS	0x401		/* ARM TLS register */
  #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
* Unmerged path arch/s390/kernel/ptrace.c
* Unmerged path include/uapi/linux/elf.h
