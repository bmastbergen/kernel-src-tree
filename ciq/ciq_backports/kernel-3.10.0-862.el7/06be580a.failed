hv_netvsc: Simplify the limit check in netvsc_set_channels()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit 06be580ac7b650938cb3f2cf8cd02d73ff96d3e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/06be580a.failed

Because of the following code, net->num_tx_queues equals to
VRSS_CHANNEL_MAX, and max_chn is less than or equals to VRSS_CHANNEL_MAX.

netvsc_drv.c:
alloc_etherdev_mq(sizeof(struct net_device_context),
                                VRSS_CHANNEL_MAX);
rndis_filter.c:
net_device->max_chn = min_t(u32, VRSS_CHANNEL_MAX, num_possible_rss_qs);

So this patch removes the unnecessary limit check before comparing
with "max_chn".

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 06be580ac7b650938cb3f2cf8cd02d73ff96d3e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 5103dca8a92e,fd65d32bf24d..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -739,84 -819,58 +739,93 @@@ static int netvsc_set_channels(struct n
  {
  	struct net_device_context *net_device_ctx = netdev_priv(net);
  	struct hv_device *dev = net_device_ctx->device_ctx;
 -	struct netvsc_device *nvdev = rtnl_dereference(net_device_ctx->nvdev);
 -	unsigned int orig, count = channels->combined_count;
 +	struct netvsc_device *nvdev = net_device_ctx->nvdev;
  	struct netvsc_device_info device_info;
 -	bool was_opened;
 +	u32 num_chn;
 +	u32 max_chn;
  	int ret = 0;
 +	bool recovering = false;
  
++<<<<<<< HEAD
 +	if (net_device_ctx->start_remove || !nvdev || nvdev->destroy)
++=======
+ 	/* We do not support separate count for rx, tx, or other */
+ 	if (count == 0 ||
+ 	    channels->rx_count || channels->tx_count || channels->other_count)
+ 		return -EINVAL;
+ 
+ 	if (!nvdev || nvdev->destroy)
++>>>>>>> 06be580ac7b6 (hv_netvsc: Simplify the limit check in netvsc_set_channels())
  		return -ENODEV;
  
 -	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5)
 +	num_chn = nvdev->num_chn;
 +	max_chn = min_t(u32, nvdev->max_chn, num_online_cpus());
 +
 +	if (nvdev->nvsp_version < NVSP_PROTOCOL_VERSION_5) {
 +		pr_info("vRSS unsupported before NVSP Version 5\n");
  		return -EINVAL;
 +	}
  
 -	if (count > nvdev->max_chn)
 +	/* We do not support rx, tx, or other */
 +	if (!channels ||
 +	    channels->rx_count ||
 +	    channels->tx_count ||
 +	    channels->other_count ||
 +	    (channels->combined_count < 1))
  		return -EINVAL;
  
 -	orig = nvdev->num_chn;
 -	was_opened = rndis_filter_opened(nvdev);
 -	if (was_opened)
 -		rndis_filter_close(nvdev);
 +	if (channels->combined_count > max_chn) {
 +		pr_info("combined channels too high, using %d\n", max_chn);
 +		channels->combined_count = max_chn;
 +	}
 +
 +	ret = netvsc_close(net);
 +	if (ret)
 +		goto out;
 +
 + do_set:
 +	net_device_ctx->start_remove = true;
 +	rndis_filter_device_remove(dev);
 +
 +	nvdev->num_chn = channels->combined_count;
  
  	memset(&device_info, 0, sizeof(device_info));
 -	device_info.num_chn = count;
 +	device_info.num_chn = nvdev->num_chn; /* passed to RNDIS */
  	device_info.ring_size = ring_size;
 -	device_info.send_sections = nvdev->send_section_cnt;
 -	device_info.recv_sections = nvdev->recv_section_cnt;
 +	device_info.max_num_vrss_chns = max_num_vrss_chns;
  
 -	rndis_filter_device_remove(dev, nvdev);
 +	ret = rndis_filter_device_add(dev, &device_info);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "unable to add netvsc device (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
  
 -	nvdev = rndis_filter_device_add(dev, &device_info);
 -	if (!IS_ERR(nvdev)) {
 -		netif_set_real_num_tx_queues(net, nvdev->num_chn);
 -		netif_set_real_num_rx_queues(net, nvdev->num_chn);
 -	} else {
 -		ret = PTR_ERR(nvdev);
 -		device_info.num_chn = orig;
 -		nvdev = rndis_filter_device_add(dev, &device_info);
 +	nvdev = net_device_ctx->nvdev;
  
 -		if (IS_ERR(nvdev)) {
 -			netdev_err(net, "restoring channel setting failed: %ld\n",
 -				   PTR_ERR(nvdev));
 +	ret = netif_set_real_num_tx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set tx queue count (ret %d)\n", ret);
  			return ret;
  		}
 +		goto recover;
  	}
  
 -	if (was_opened)
 -		rndis_filter_open(nvdev);
 +	ret = netif_set_real_num_rx_queues(net, nvdev->num_chn);
 +	if (ret) {
 +		if (recovering) {
 +			netdev_err(net, "could not set rx queue count (ret %d)\n", ret);
 +			return ret;
 +		}
 +		goto recover;
 +	}
  
 + out:
 +	netvsc_open(net);
 +	net_device_ctx->start_remove = false;
  	/* We may have missed link change notifications */
  	net_device_ctx->last_reconfig = 0;
  	schedule_delayed_work(&net_device_ctx->dwork, 0);
* Unmerged path drivers/net/hyperv/netvsc_drv.c
