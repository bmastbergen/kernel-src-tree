ovl: base tmpfile in workdir too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 7ab8b1763fd84ff4e7263ed7f5c728e4cb3f364a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7ab8b176.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 7ab8b1763fd84ff4e7263ed7f5c728e4cb3f364a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,1264f2434047..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -284,9 -327,38 +284,43 @@@ static int ovl_copy_up_locked(struct de
  
  	upper = lookup_one_len(dentry->d_name.name, upperdir,
  			       dentry->d_name.len);
 +	err = PTR_ERR(upper);
  	if (IS_ERR(upper))
++<<<<<<< HEAD
 +		goto out1;
++=======
+ 		return PTR_ERR(upper);
+ 
+ 	if (tmpfile)
+ 		err = ovl_do_link(temp, udir, upper, true);
+ 	else
+ 		err = ovl_do_rename(d_inode(workdir), temp, udir, upper, 0);
+ 
+ 	/* Restore timestamps on parent (best effort) */
+ 	if (!err) {
+ 		ovl_set_timestamps(upperdir, pstat);
+ 		*newdentry = dget(tmpfile ? upper : temp);
+ 	}
+ 	dput(upper);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_tmpfile(struct dentry *workdir, struct dentry *dentry,
+ 			   struct kstat *stat, const char *link, bool tmpfile,
+ 			   struct dentry **tempp)
+ {
+ 	int err;
+ 	struct dentry *temp;
+ 	const struct cred *old_creds = NULL;
+ 	struct cred *new_creds = NULL;
+ 	struct cattr cattr = {
+ 		/* Can't properly set mode on creation because of the umask */
+ 		.mode = stat->mode & S_IFMT,
+ 		.rdev = stat->rdev,
+ 		.link = link
+ 	};
++>>>>>>> 7ab8b1763fd8 (ovl: base tmpfile in workdir too)
  
  	err = security_inode_copy_up(dentry, &new_creds);
  	if (err < 0)
@@@ -295,11 -367,25 +329,22 @@@
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
++<<<<<<< HEAD
 +	/* Can't properly set mode on creation because of the umask */
 +	stat->mode &= S_IFMT;
 +	err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
 +	stat->mode = mode;
++=======
+ 	if (tmpfile) {
+ 		temp = ovl_do_tmpfile(workdir, stat->mode);
+ 		if (IS_ERR(temp))
+ 			goto temp_err;
+ 	} else {
+ 		temp = ovl_lookup_temp(workdir);
+ 		if (IS_ERR(temp))
+ 			goto temp_err;
++>>>>>>> 7ab8b1763fd8 (ovl: base tmpfile in workdir too)
  
 -		err = ovl_create_real(d_inode(workdir), temp, &cattr,
 -				      NULL, true);
 -		if (err) {
 -			dput(temp);
 -			goto out;
 -		}
 -	}
 -	err = 0;
 -	*tempp = temp;
 -out:
  	if (new_creds) {
  		revert_creds(old_creds);
  		put_cred(new_creds);
@@@ -317,37 -412,69 +362,81 @@@
  
  		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
  		if (err)
 -			return err;
 +			goto out_cleanup;
  	}
  
 -	err = ovl_copy_xattr(lowerpath->dentry, temp);
 +	err = ovl_copy_xattr(lowerpath->dentry, newdentry);
  	if (err)
 -		return err;
 +		goto out_cleanup;
  
 -	inode_lock(temp->d_inode);
 -	err = ovl_set_attr(temp, stat);
 -	inode_unlock(temp->d_inode);
 +	mutex_lock(&newdentry->d_inode->i_mutex);
 +	err = ovl_set_attr(newdentry, stat);
 +	mutex_unlock(&newdentry->d_inode->i_mutex);
  	if (err)
 -		return err;
 +		goto out_cleanup;
 +
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
 +	if (err)
 +		goto out_cleanup;
 +
 +	ovl_dentry_update(dentry, newdentry);
 +	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
  
  	/*
 -	 * Store identifier of lower inode in upper inode xattr to
 -	 * allow lookup of the copy up origin inode.
 -	 *
 -	 * Don't set origin when we are breaking the association with a lower
 -	 * hard link.
 +	 * Non-directores become opaque when copied up.
  	 */
++<<<<<<< HEAD
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
 +	dput(upper);
 +out1:
 +	dput(newdentry);
++=======
+ 	if (S_ISDIR(stat->mode) || stat->nlink == 1) {
+ 		err = ovl_set_origin(dentry, lowerpath->dentry, temp);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
+ 			      struct dentry *dentry, struct path *lowerpath,
+ 			      struct kstat *stat, const char *link,
+ 			      struct kstat *pstat, bool tmpfile)
+ {
+ 	struct inode *wdir = workdir->d_inode;
+ 	struct inode *udir = upperdir->d_inode;
+ 	struct dentry *newdentry = NULL;
+ 	struct dentry *temp = NULL;
+ 	int err;
+ 
+ 	err = ovl_get_tmpfile(workdir, dentry, stat, link, tmpfile, &temp);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ovl_copy_up_inode(dentry, temp, lowerpath, stat);
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	if (tmpfile) {
+ 		inode_lock_nested(udir, I_MUTEX_PARENT);
+ 		err = ovl_install_temp(workdir, upperdir, dentry, temp, pstat,
+ 				       tmpfile, &newdentry);
+ 		inode_unlock(udir);
+ 	} else {
+ 		err = ovl_install_temp(workdir, upperdir, dentry, temp, pstat,
+ 				       tmpfile, &newdentry);
+ 	}
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	ovl_inode_update(d_inode(dentry), newdentry);
++>>>>>>> 7ab8b1763fd8 (ovl: base tmpfile in workdir too)
  out:
 -	dput(temp);
  	return err;
  
  out_cleanup:
* Unmerged path fs/overlayfs/copy_up.c
