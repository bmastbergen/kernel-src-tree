ceph: allow dentry_lease_is_valid to work under RCU walk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit 14fb9c9efe3570459b6bddd76a990140917237ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/14fb9c9e.failed

Under rcuwalk, we need to take extra care when dereferencing d_parent.
We want to do that once and pass a pointer to dentry_lease_is_valid.

Also, we must ensure that that function can handle the case where we're
racing with d_release. Check whether "di" is NULL under the d_lock, and
just return 0 if so.

Finally, we still need to kick off a renewal job if the lease is getting
close to expiration. If that's the case, then just drop out of rcuwalk
mode since that could block.

	Signed-off-by: Jeff Layton <jlayton@redhat.com>
	Reviewed-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 14fb9c9efe3570459b6bddd76a990140917237ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
diff --cc fs/ceph/dir.c
index c6a987b935a4,60dcca163ba0..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -1041,12 -1159,19 +1041,28 @@@ static int dentry_lease_is_valid(struc
  			valid = 1;
  			if (di->lease_renew_after &&
  			    time_after(jiffies, di->lease_renew_after)) {
++<<<<<<< HEAD
 +				/* we should renew */
 +				dir = dentry->d_parent->d_inode;
 +				session = ceph_get_mds_session(s);
 +				seq = di->lease_seq;
 +				di->lease_renew_after = 0;
 +				di->lease_renew_from = jiffies;
++=======
+ 				/*
+ 				 * We should renew. If we're in RCU walk mode
+ 				 * though, we can't do that so just return
+ 				 * -ECHILD.
+ 				 */
+ 				if (flags & LOOKUP_RCU) {
+ 					valid = -ECHILD;
+ 				} else {
+ 					session = ceph_get_mds_session(s);
+ 					seq = di->lease_seq;
+ 					di->lease_renew_after = 0;
+ 					di->lease_renew_from = jiffies;
+ 				}
++>>>>>>> 14fb9c9efe35 (ceph: allow dentry_lease_is_valid to work under RCU walk)
  			}
  		}
  	}
@@@ -1101,18 -1225,22 +1117,31 @@@ static int ceph_d_revalidate(struct den
  
  	/* always trust cached snapped dentries, snapdir dentry */
  	if (ceph_snap(dir) != CEPH_NOSNAP) {
 -		dout("d_revalidate %p '%pd' inode %p is SNAPPED\n", dentry,
 -		     dentry, d_inode(dentry));
 +		dout("d_revalidate %p '%.*s' inode %p is SNAPPED\n", dentry,
 +		     dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
  		valid = 1;
 -	} else if (d_really_is_positive(dentry) &&
 -		   ceph_snap(d_inode(dentry)) == CEPH_SNAPDIR) {
 +	} else if (dentry->d_inode &&
 +		   ceph_snap(dentry->d_inode) == CEPH_SNAPDIR) {
  		valid = 1;
++<<<<<<< HEAD
 +	} else if (dentry_lease_is_valid(dentry) ||
 +		   dir_lease_is_valid(dir, dentry)) {
 +		if (dentry->d_inode)
 +			valid = ceph_is_any_caps(dentry->d_inode);
 +		else
 +			valid = 1;
++=======
+ 	} else {
+ 		valid = dentry_lease_is_valid(dentry, flags, dir);
+ 		if (valid == -ECHILD)
+ 			return valid;
+ 		if (valid || dir_lease_is_valid(dir, dentry)) {
+ 			if (d_really_is_positive(dentry))
+ 				valid = ceph_is_any_caps(d_inode(dentry));
+ 			else
+ 				valid = 1;
+ 		}
++>>>>>>> 14fb9c9efe35 (ceph: allow dentry_lease_is_valid to work under RCU walk)
  	}
  
  	if (!valid) {
* Unmerged path fs/ceph/dir.c
