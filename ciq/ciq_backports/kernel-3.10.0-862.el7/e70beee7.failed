target: Pass in transport supported PI at session initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Pass in transport supported PI at session initialization (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 93.33%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit e70beee783d6977d80eede88a3394f02eabddad1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e70beee7.failed

In order to support local WRITE_INSERT + READ_STRIP operations for
non PI enabled fabrics, the fabric driver needs to be able signal
what protection offload operations are supported.

This is done at session initialization time so the modes can be
signaled by individual se_wwn + se_portal_group endpoints, as well
as optionally across different transports on the same endpoint.

For iser-target, set TARGET_PROT_ALL if the underlying ib_device
has already signaled PI offload support, and allow this to be
exposed via a new iscsit_transport->iscsit_get_sup_prot_ops()
callback.

For loopback, set TARGET_PROT_ALL to signal SCSI initiator mode
operation.

For all other drivers, set TARGET_PROT_NORMAL to disable fabric
level PI.

	Cc: Martin K. Petersen <martin.petersen@oracle.com>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Cc: Or Gerlitz <ogerlitz@mellanox.com>
	Cc: Quinn Tran <quinn.tran@qlogic.com>
	Cc: Giridhar Malavali <giridhar.malavali@qlogic.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit e70beee783d6977d80eede88a3394f02eabddad1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/isert/ib_isert.c
#	drivers/target/iscsi/iscsi_target.c
#	drivers/target/iscsi/iscsi_target_login.c
#	drivers/vhost/scsi.c
#	include/target/iscsi/iscsi_transport.h
diff --cc drivers/infiniband/ulp/isert/ib_isert.c
index 98429c0702e6,c98fdb185931..000000000000
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@@ -1901,29 -2192,22 +1901,41 @@@ isert_aborted_task(struct iscsi_conn *c
  
  	if (cmd->data_direction == DMA_TO_DEVICE)
  		iscsit_stop_dataout_timer(cmd);
 +	isert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);
 +}
 +
 +static enum target_prot_op
 +isert_get_sup_prot_ops(struct iscsi_conn *conn)
 +{
 +	struct isert_conn *isert_conn = conn->context;
 +	struct isert_device *device = isert_conn->device;
  
 -	device->unreg_rdma_mem(isert_cmd, isert_conn);
 +	if (conn->tpg->tpg_attrib.t10_pi) {
 +		if (device->pi_capable) {
 +			isert_info("conn %p PI offload enabled\n", isert_conn);
 +			isert_conn->pi_support = true;
 +			return TARGET_PROT_ALL;
 +		}
 +	}
 +
 +	isert_info("conn %p PI offload disabled\n", isert_conn);
 +	isert_conn->pi_support = false;
 +
 +	return TARGET_PROT_NORMAL;
  }
  
+ static enum target_prot_op
+ isert_get_sup_prot_ops(struct iscsi_conn *conn)
+ {
+ 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
+ 	struct isert_device *device = isert_conn->conn_device;
+ 
+ 	if (device->pi_capable)
+ 		return TARGET_PROT_ALL;
+ 
+ 	return TARGET_PROT_NORMAL;
+ }
+ 
  static int
  isert_put_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn,
  		bool nopout_response)
@@@ -2667,7 -3264,6 +2679,10 @@@ static struct iscsit_transport iser_tar
  	.iscsit_queue_data_in	= isert_put_datain,
  	.iscsit_queue_status	= isert_put_response,
  	.iscsit_aborted_task	= isert_aborted_task,
++<<<<<<< HEAD
 +	.iscsit_get_rx_pdu	= isert_get_rx_pdu,
++=======
++>>>>>>> e70beee783d6 (target: Pass in transport supported PI at session initialization)
  	.iscsit_get_sup_prot_ops = isert_get_sup_prot_ops,
  };
  
diff --cc drivers/target/iscsi/iscsi_target.c
index 35209f0a469a,78cab13bbb1b..000000000000
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@@ -499,175 -510,12 +499,180 @@@ void iscsit_aborted_task(struct iscsi_c
  
  	__iscsit_free_cmd(cmd, scsi_cmd, true);
  }
 +EXPORT_SYMBOL(iscsit_aborted_task);
 +
 +static void iscsit_do_crypto_hash_buf(struct ahash_request *, const void *,
 +				      u32, u32, u8 *, u8 *);
 +static void iscsit_tx_thread_wait_for_tcp(struct iscsi_conn *);
 +
 +static int
 +iscsit_xmit_nondatain_pdu(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 +			  const void *data_buf, u32 data_buf_len)
 +{
 +	struct iscsi_hdr *hdr = (struct iscsi_hdr *)cmd->pdu;
 +	struct kvec *iov;
 +	u32 niov = 0, tx_size = ISCSI_HDR_LEN;
 +	int ret;
 +
 +	iov = &cmd->iov_misc[0];
 +	iov[niov].iov_base	= cmd->pdu;
 +	iov[niov++].iov_len	= ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(conn->conn_tx_hash, hdr,
 +					  ISCSI_HDR_LEN, 0, NULL,
 +					  (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +		pr_debug("Attaching CRC32C HeaderDigest"
 +			 " to opcode 0x%x 0x%08x\n",
 +			 hdr->opcode, *header_digest);
 +	}
 +
 +	if (data_buf_len) {
 +		u32 padding = ((-data_buf_len) & 3);
 +
 +		iov[niov].iov_base	= (void *)data_buf;
 +		iov[niov++].iov_len	= data_buf_len;
 +		tx_size += data_buf_len;
 +
 +		if (padding != 0) {
 +			iov[niov].iov_base = &cmd->pad_bytes;
 +			iov[niov++].iov_len = padding;
 +			tx_size += padding;
 +			pr_debug("Attaching %u additional"
 +				 " padding bytes.\n", padding);
 +		}
 +
 +		if (conn->conn_ops->DataDigest) {
 +			iscsit_do_crypto_hash_buf(conn->conn_tx_hash,
 +						  data_buf, data_buf_len,
 +						  padding,
 +						  (u8 *)&cmd->pad_bytes,
 +						  (u8 *)&cmd->data_crc);
 +
 +			iov[niov].iov_base = &cmd->data_crc;
 +			iov[niov++].iov_len = ISCSI_CRC_LEN;
 +			tx_size += ISCSI_CRC_LEN;
 +			pr_debug("Attached DataDigest for %u"
 +				 " bytes opcode 0x%x, CRC 0x%08x\n",
 +				 data_buf_len, hdr->opcode, cmd->data_crc);
 +		}
 +	}
 +
 +	cmd->iov_misc_count = niov;
 +	cmd->tx_size = tx_size;
 +
 +	ret = iscsit_send_tx_data(cmd, conn, 1);
 +	if (ret < 0) {
 +		iscsit_tx_thread_wait_for_tcp(conn);
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int iscsit_map_iovec(struct iscsi_cmd *, struct kvec *, u32, u32);
 +static void iscsit_unmap_iovec(struct iscsi_cmd *);
 +static u32 iscsit_do_crypto_hash_sg(struct ahash_request *, struct iscsi_cmd *,
 +				    u32, u32, u32, u8 *);
 +static int
 +iscsit_xmit_datain_pdu(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 +		       const struct iscsi_datain *datain)
 +{
 +	struct kvec *iov;
 +	u32 iov_count = 0, tx_size = 0;
 +	int ret, iov_ret;
 +
 +	iov = &cmd->iov_data[0];
 +	iov[iov_count].iov_base	= cmd->pdu;
 +	iov[iov_count++].iov_len = ISCSI_HDR_LEN;
 +	tx_size += ISCSI_HDR_LEN;
 +
 +	if (conn->conn_ops->HeaderDigest) {
 +		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
 +
 +		iscsit_do_crypto_hash_buf(conn->conn_tx_hash, cmd->pdu,
 +					  ISCSI_HDR_LEN, 0, NULL,
 +					  (u8 *)header_digest);
 +
 +		iov[0].iov_len += ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +
 +		pr_debug("Attaching CRC32 HeaderDigest for DataIN PDU 0x%08x\n",
 +			 *header_digest);
 +	}
 +
 +	iov_ret = iscsit_map_iovec(cmd, &cmd->iov_data[1],
 +				   datain->offset, datain->length);
 +	if (iov_ret < 0)
 +		return -1;
 +
 +	iov_count += iov_ret;
 +	tx_size += datain->length;
 +
 +	cmd->padding = ((-datain->length) & 3);
 +	if (cmd->padding) {
 +		iov[iov_count].iov_base		= cmd->pad_bytes;
 +		iov[iov_count++].iov_len	= cmd->padding;
 +		tx_size += cmd->padding;
 +
 +		pr_debug("Attaching %u padding bytes\n", cmd->padding);
 +	}
 +
 +	if (conn->conn_ops->DataDigest) {
 +		cmd->data_crc = iscsit_do_crypto_hash_sg(conn->conn_tx_hash,
 +							 cmd, datain->offset,
 +							 datain->length,
 +							 cmd->padding,
 +							 cmd->pad_bytes);
 +
 +		iov[iov_count].iov_base	= &cmd->data_crc;
 +		iov[iov_count++].iov_len = ISCSI_CRC_LEN;
 +		tx_size += ISCSI_CRC_LEN;
 +
 +		pr_debug("Attached CRC32C DataDigest %d bytes, crc 0x%08x\n",
 +			 datain->length + cmd->padding, cmd->data_crc);
 +	}
 +
 +	cmd->iov_data_count = iov_count;
 +	cmd->tx_size = tx_size;
 +
 +	ret = iscsit_fe_sendpage_sg(cmd, conn);
 +
 +	iscsit_unmap_iovec(cmd);
 +
 +	if (ret < 0) {
 +		iscsit_tx_thread_wait_for_tcp(conn);
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int iscsit_xmit_pdu(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 +			   struct iscsi_datain_req *dr, const void *buf,
 +			   u32 buf_len)
 +{
 +	if (dr)
 +		return iscsit_xmit_datain_pdu(conn, cmd, buf);
 +	else
 +		return iscsit_xmit_nondatain_pdu(conn, cmd, buf, buf_len);
 +}
 +
 +static enum target_prot_op iscsit_get_sup_prot_ops(struct iscsi_conn *conn)
 +{
 +	return TARGET_PROT_NORMAL;
 +}
  
+ static enum target_prot_op iscsit_get_sup_prot_ops(struct iscsi_conn *conn)
+ {
+ 	return TARGET_PROT_NORMAL;
+ }
+ 
  static struct iscsit_transport iscsi_target_transport = {
  	.name			= "iSCSI/TCP",
  	.transport_type		= ISCSI_TCP,
@@@ -684,8 -531,6 +689,11 @@@
  	.iscsit_queue_data_in	= iscsit_queue_rsp,
  	.iscsit_queue_status	= iscsit_queue_rsp,
  	.iscsit_aborted_task	= iscsit_aborted_task,
++<<<<<<< HEAD
 +	.iscsit_xmit_pdu	= iscsit_xmit_pdu,
 +	.iscsit_get_rx_pdu	= iscsit_get_rx_pdu,
++=======
++>>>>>>> e70beee783d6 (target: Pass in transport supported PI at session initialization)
  	.iscsit_get_sup_prot_ops = iscsit_get_sup_prot_ops,
  };
  
diff --cc drivers/target/iscsi/iscsi_target_login.c
index c20b561f759f,8739b98f6f93..000000000000
--- a/drivers/target/iscsi/iscsi_target_login.c
+++ b/drivers/target/iscsi/iscsi_target_login.c
@@@ -353,8 -321,9 +354,13 @@@ static int iscsi_login_zero_tsih_s1
  		kfree(sess);
  		return -ENOMEM;
  	}
+ 	sup_pro_ops = conn->conn_transport->iscsit_get_sup_prot_ops(conn);
  
++<<<<<<< HEAD
 +	sess->se_sess = transport_init_session(TARGET_PROT_NORMAL);
++=======
+ 	sess->se_sess = transport_init_session(sup_pro_ops);
++>>>>>>> e70beee783d6 (target: Pass in transport supported PI at session initialization)
  	if (IS_ERR(sess->se_sess)) {
  		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
  				ISCSI_LOGIN_STATUS_NO_RESOURCES);
diff --cc drivers/vhost/scsi.c
index 65142d377371,cf50ce93975b..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -1654,11 -1740,15 +1654,18 @@@ static int tcm_vhost_make_nexus(struct 
  		return -ENOMEM;
  	}
  	/*
 -	 *  Initialize the struct se_session pointer and setup tagpool
 -	 *  for struct tcm_vhost_cmd descriptors
 +	 *  Initialize the struct se_session pointer
  	 */
++<<<<<<< HEAD
 +	tv_nexus->tvn_se_sess = transport_init_session();
++=======
+ 	tv_nexus->tvn_se_sess = transport_init_session_tags(
+ 					TCM_VHOST_DEFAULT_TAGS,
+ 					sizeof(struct tcm_vhost_cmd),
+ 					TARGET_PROT_NORMAL);
++>>>>>>> e70beee783d6 (target: Pass in transport supported PI at session initialization)
  	if (IS_ERR(tv_nexus->tvn_se_sess)) {
 -		mutex_unlock(&tpg->tv_tpg_mutex);
 +		mutex_unlock(&tv_tpg->tv_tpg_mutex);
  		kfree(tv_nexus);
  		return -ENOMEM;
  	}
diff --cc include/target/iscsi/iscsi_transport.h
index 4917a3ae9949,33b487b5da92..000000000000
--- a/include/target/iscsi/iscsi_transport.h
+++ b/include/target/iscsi/iscsi_transport.h
@@@ -23,13 -22,6 +23,16 @@@ struct iscsit_transport 
  	int (*iscsit_queue_data_in)(struct iscsi_conn *, struct iscsi_cmd *);
  	int (*iscsit_queue_status)(struct iscsi_conn *, struct iscsi_cmd *);
  	void (*iscsit_aborted_task)(struct iscsi_conn *, struct iscsi_cmd *);
++<<<<<<< HEAD
 +	int (*iscsit_xmit_pdu)(struct iscsi_conn *, struct iscsi_cmd *,
 +			       struct iscsi_datain_req *, const void *, u32);
 +	void (*iscsit_release_cmd)(struct iscsi_conn *, struct iscsi_cmd *);
 +	void (*iscsit_get_rx_pdu)(struct iscsi_conn *);
 +	int (*iscsit_validate_params)(struct iscsi_conn *);
 +	void (*iscsit_get_r2t_ttt)(struct iscsi_conn *, struct iscsi_cmd *,
 +				   struct iscsi_r2t *);
++=======
++>>>>>>> e70beee783d6 (target: Pass in transport supported PI at session initialization)
  	enum target_prot_op (*iscsit_get_sup_prot_ops)(struct iscsi_conn *);
  };
  
* Unmerged path drivers/infiniband/ulp/isert/ib_isert.c
diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.c b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
index e9c7bfd1510c..457c0b350b3b 100644
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@ -1441,7 +1441,7 @@ static int tcm_qla2xxx_check_initiator_node_acl(
 	}
 	se_tpg = &tpg->se_tpg;
 
-	se_sess = transport_init_session();
+	se_sess = transport_init_session(TARGET_PROT_NORMAL);
 	if (IS_ERR(se_sess)) {
 		pr_err("Unable to initialize struct se_session\n");
 		return PTR_ERR(se_sess);
* Unmerged path drivers/target/iscsi/iscsi_target.c
* Unmerged path drivers/target/iscsi/iscsi_target_login.c
diff --git a/drivers/usb/gadget/tcm_usb_gadget.c b/drivers/usb/gadget/tcm_usb_gadget.c
index 7cacd6ae818e..ea4fd9bcce92 100644
--- a/drivers/usb/gadget/tcm_usb_gadget.c
+++ b/drivers/usb/gadget/tcm_usb_gadget.c
@@ -1727,7 +1727,7 @@ static int tcm_usbg_make_nexus(struct usbg_tpg *tpg, char *name)
 		pr_err("Unable to allocate struct tcm_vhost_nexus\n");
 		goto err_unlock;
 	}
-	tv_nexus->tvn_se_sess = transport_init_session();
+	tv_nexus->tvn_se_sess = transport_init_session(TARGET_PROT_NORMAL);
 	if (IS_ERR(tv_nexus->tvn_se_sess))
 		goto err_free;
 
* Unmerged path drivers/vhost/scsi.c
* Unmerged path include/target/iscsi/iscsi_transport.h
