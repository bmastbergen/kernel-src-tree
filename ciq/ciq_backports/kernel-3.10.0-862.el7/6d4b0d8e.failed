nfp: slice the netdev spawning function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 6d4b0d8ed6d2f9e1741b9abd0ce64c641f890d6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6d4b0d8e.failed

We want to be able to create a special vNIC for control messages.
This vNIC should be created before any netdev is registered to allow
nfp_app logic to exchange messages with the FW app before any netdev
is visible to user space.  Unfortunately we can't enable IRQs until
we know how many vNICs we will need to spawn.

Divide the function which spawns netdevs for vNICs into three parts:
 - vNIC/memory allocation;
 - IRQ allocation;
 - netdev init and register.

This will help us insert the initialization of the control channel
after IRQ allocation but before netdev init and register.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6d4b0d8ed6d2f9e1741b9abd0ce64c641f890d6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,98a99b199674..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -373,59 -382,70 +373,92 @@@ err_free_prev
  	return err;
  }
  
++<<<<<<< HEAD
 +static int
 +nfp_net_pf_spawn_netdevs(struct nfp_pf *pf,
 +			 void __iomem *ctrl_bar, void __iomem *tx_bar,
 +			 void __iomem *rx_bar, int stride,
 +			 struct nfp_net_fw_version *fw_ver)
 +{
 +	unsigned int id, wanted_irqs, num_irqs, ports_left, irqs_left;
 +	struct nfp_net *nn;
 +	int err;
 +
 +	/* Allocate the netdevs and do basic init */
 +	err = nfp_net_pf_alloc_netdevs(pf, ctrl_bar, tx_bar, rx_bar,
 +				       stride, fw_ver);
 +	if (err)
 +		return err;
++=======
+ static void nfp_net_pf_clean_vnic(struct nfp_pf *pf, struct nfp_net *nn)
+ {
+ 	if (nn->port)
+ 		nfp_devlink_port_unregister(nn->port);
+ 	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
+ 	nfp_net_clean(nn);
+ 	nfp_app_vnic_clean(pf->app, nn);
+ }
+ 
+ static int nfp_net_pf_alloc_irqs(struct nfp_pf *pf)
+ {
+ 	unsigned int wanted_irqs, num_irqs, vnics_left, irqs_left;
+ 	struct nfp_net *nn;
++>>>>>>> 6d4b0d8ed6d2 (nfp: slice the netdev spawning function)
  
  	/* Get MSI-X vectors */
  	wanted_irqs = 0;
 -	list_for_each_entry(nn, &pf->vnics, vnic_list)
 -		wanted_irqs += NFP_NET_NON_Q_VECTORS + nn->dp.num_r_vecs;
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		wanted_irqs += NFP_NET_NON_Q_VECTORS + nn->num_r_vecs;
  	pf->irq_entries = kcalloc(wanted_irqs, sizeof(*pf->irq_entries),
  				  GFP_KERNEL);
- 	if (!pf->irq_entries) {
- 		err = -ENOMEM;
- 		goto err_nn_free;
- 	}
+ 	if (!pf->irq_entries)
+ 		return -ENOMEM;
  
  	num_irqs = nfp_net_irqs_alloc(pf->pdev, pf->irq_entries,
 -				      NFP_NET_MIN_VNIC_IRQS * pf->num_vnics,
 +				      NFP_NET_MIN_PORT_IRQS * pf->num_ports,
  				      wanted_irqs);
  	if (!num_irqs) {
- 		nn_warn(nn, "Unable to allocate MSI-X Vectors. Exiting\n");
- 		err = -ENOMEM;
- 		goto err_vec_free;
+ 		nfp_warn(pf->cpp, "Unable to allocate MSI-X vectors\n");
+ 		kfree(pf->irq_entries);
+ 		return -ENOMEM;
  	}
  
 -	/* Distribute IRQs to vNICs */
 +	/* Distribute IRQs to ports */
  	irqs_left = num_irqs;
 -	vnics_left = pf->num_vnics;
 -	list_for_each_entry(nn, &pf->vnics, vnic_list) {
 +	ports_left = pf->num_ports;
 +	list_for_each_entry(nn, &pf->ports, port_list) {
  		unsigned int n;
  
 -		n = DIV_ROUND_UP(irqs_left, vnics_left);
 +		n = DIV_ROUND_UP(irqs_left, ports_left);
  		nfp_net_irqs_assign(nn, &pf->irq_entries[num_irqs - irqs_left],
  				    n);
  		irqs_left -= n;
 -		vnics_left--;
 +		ports_left--;
  	}
  
++<<<<<<< HEAD
 +	/* Finish netdev init and register */
++=======
+ 	return 0;
+ }
+ 
+ static void nfp_net_pf_free_irqs(struct nfp_pf *pf)
+ {
+ 	nfp_net_irqs_disable(pf->pdev);
+ 	kfree(pf->irq_entries);
+ }
+ 
+ static int nfp_net_pf_init_vnics(struct nfp_pf *pf)
+ {
+ 	struct nfp_net *nn;
+ 	unsigned int id;
+ 	int err;
+ 
+ 	/* Finish vNIC init and register */
++>>>>>>> 6d4b0d8ed6d2 (nfp: slice the netdev spawning function)
  	id = 0;
 -	list_for_each_entry(nn, &pf->vnics, vnic_list) {
 -		err = nfp_net_pf_init_vnic(pf, nn, id);
 +	list_for_each_entry(nn, &pf->ports, port_list) {
 +		err = nfp_net_pf_init_port_netdev(pf, nn, id);
  		if (err)
  			goto err_prev_deinit;
  
@@@ -435,15 -455,8 +468,20 @@@
  	return 0;
  
  err_prev_deinit:
++<<<<<<< HEAD
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
 +	}
 +	nfp_net_irqs_disable(pf->pdev);
 +err_vec_free:
 +	kfree(pf->irq_entries);
 +err_nn_free:
 +	nfp_net_pf_free_netdevs(pf);
++=======
+ 	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
+ 		nfp_net_pf_clean_vnic(pf, nn);
++>>>>>>> 6d4b0d8ed6d2 (nfp: slice the netdev spawning function)
  	return err;
  }
  
@@@ -451,75 -489,127 +489,74 @@@ static void nfp_net_pci_remove_finish(s
  {
  	nfp_net_debugfs_dir_clean(&pf->ddir);
  
- 	nfp_net_irqs_disable(pf->pdev);
- 	kfree(pf->irq_entries);
+ 	nfp_net_pf_free_irqs(pf);
  
 -	nfp_net_pf_app_clean(pf);
 -
 -	nfp_cpp_area_release_free(pf->qc_area);
 -	nfp_cpp_area_release_free(pf->data_vnic_bar);
 -}
 -
 -static int
 -nfp_net_eth_port_update(struct nfp_cpp *cpp, struct nfp_port *port,
 -			struct nfp_eth_table *eth_table)
 -{
 -	struct nfp_eth_table_port *eth_port;
 -
 -	ASSERT_RTNL();
 -
 -	eth_port = nfp_net_find_port(eth_table, port->eth_id);
 -	if (!eth_port) {
 -		set_bit(NFP_PORT_CHANGED, &port->flags);
 -		nfp_warn(cpp, "Warning: port #%d not present after reconfig\n",
 -			 port->eth_id);
 -		return -EIO;
 -	}
 -	if (eth_port->override_changed) {
 -		nfp_warn(cpp, "Port #%d config changed, unregistering. Reboot required before port will be operational again.\n", port->eth_id);
 -		port->type = NFP_PORT_INVALID;
 -	}
 -
 -	memcpy(port->eth_port, eth_port, sizeof(*eth_port));
 -
 -	return 0;
 +	nfp_cpp_area_release_free(pf->rx_area);
 +	nfp_cpp_area_release_free(pf->tx_area);
 +	nfp_cpp_area_release_free(pf->ctrl_area);
  }
  
 -int nfp_net_refresh_port_table_sync(struct nfp_pf *pf)
 +static void nfp_net_refresh_netdevs(struct work_struct *work)
  {
 -	struct nfp_eth_table *eth_table;
 +	struct nfp_pf *pf = container_of(work, struct nfp_pf,
 +					 port_refresh_work);
  	struct nfp_net *nn, *next;
 -	struct nfp_port *port;
  
 -	lockdep_assert_held(&pf->lock);
 +	mutex_lock(&pf->port_lock);
  
  	/* Check for nfp_net_pci_remove() racing against us */
 -	if (list_empty(&pf->vnics))
 -		return 0;
 -
 -	/* Update state of all ports */
 -	rtnl_lock();
 -	list_for_each_entry(port, &pf->ports, port_list)
 -		clear_bit(NFP_PORT_CHANGED, &port->flags);
 -
 -	eth_table = nfp_eth_read_ports(pf->cpp);
 -	if (!eth_table) {
 -		list_for_each_entry(port, &pf->ports, port_list)
 -			if (__nfp_port_get_eth_port(port))
 -				set_bit(NFP_PORT_CHANGED, &port->flags);
 -		rtnl_unlock();
 -		nfp_err(pf->cpp, "Error refreshing port config!\n");
 -		return -EIO;
 -	}
 +	if (list_empty(&pf->ports))
 +		goto out;
  
 -	list_for_each_entry(port, &pf->ports, port_list)
 -		if (__nfp_port_get_eth_port(port))
 -			nfp_net_eth_port_update(pf->cpp, port, eth_table);
 -	rtnl_unlock();
 +	list_for_each_entry_safe(nn, next, &pf->ports, port_list) {
 +		if (!nn->eth_port) {
 +			nfp_warn(pf->cpp, "Warning: port not present after reconfig\n");
 +			continue;
 +		}
 +		if (!nn->eth_port->override_changed)
 +			continue;
  
 -	kfree(eth_table);
 +		nn_warn(nn, "Port config changed, unregistering. Reboot required before port will be operational again.\n");
  
 -	/* Shoot off the ports which became invalid */
 -	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {
 -		if (!nn->port || nn->port->type != NFP_PORT_INVALID)
 -			continue;
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->dp.netdev);
  
 -		nfp_net_pf_clean_vnic(pf, nn);
 -		nfp_net_pf_free_vnic(pf, nn);
 +		list_del(&nn->port_list);
 +		pf->num_netdevs--;
 +		nfp_net_netdev_free(nn);
  	}
  
 -	if (list_empty(&pf->vnics))
 +	if (list_empty(&pf->ports))
  		nfp_net_pci_remove_finish(pf);
 -
 -	return 0;
 -}
 -
 -static void nfp_net_refresh_vnics(struct work_struct *work)
 -{
 -	struct nfp_pf *pf = container_of(work, struct nfp_pf,
 -					 port_refresh_work);
 -
 -	mutex_lock(&pf->lock);
 -	nfp_net_refresh_port_table_sync(pf);
 -	mutex_unlock(&pf->lock);
 +out:
 +	mutex_unlock(&pf->port_lock);
  }
  
 -void nfp_net_refresh_port_table(struct nfp_port *port)
 +void nfp_net_refresh_port_config(struct nfp_net *nn)
  {
 -	struct nfp_pf *pf = port->app->pf;
 +	struct nfp_pf *pf = pci_get_drvdata(nn->pdev);
 +	struct nfp_eth_table *old_table;
  
 -	set_bit(NFP_PORT_CHANGED, &port->flags);
 -
 -	schedule_work(&pf->port_refresh_work);
 -}
 +	ASSERT_RTNL();
  
 -int nfp_net_refresh_eth_port(struct nfp_port *port)
 -{
 -	struct nfp_cpp *cpp = port->app->cpp;
 -	struct nfp_eth_table *eth_table;
 -	int ret;
 +	old_table = pf->eth_tbl;
  
 -	clear_bit(NFP_PORT_CHANGED, &port->flags);
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nfp_net_link_changed_read_clear(nn);
  
 -	eth_table = nfp_eth_read_ports(cpp);
 -	if (!eth_table) {
 -		set_bit(NFP_PORT_CHANGED, &port->flags);
 -		nfp_err(cpp, "Error refreshing port state table!\n");
 -		return -EIO;
 +	pf->eth_tbl = nfp_eth_read_ports(pf->cpp);
 +	if (!pf->eth_tbl) {
 +		pf->eth_tbl = old_table;
 +		nfp_err(pf->cpp, "Error refreshing port config!\n");
 +		return;
  	}
  
 -	ret = nfp_net_eth_port_update(cpp, port, eth_table);
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nn->eth_port = nfp_net_find_port(pf, nn->eth_port->eth_index);
  
 -	kfree(eth_table);
 +	kfree(old_table);
  
 -	return ret;
 +	schedule_work(&pf->port_refresh_work);
  }
  
  /*
@@@ -620,24 -690,36 +657,45 @@@ int nfp_net_pci_probe(struct nfp_pf *pf
  
  	pf->ddir = nfp_net_debugfs_device_add(pf->pdev);
  
++<<<<<<< HEAD
 +	err = nfp_net_pf_spawn_netdevs(pf, ctrl_bar, tx_bar, rx_bar,
 +				       stride, &fw_ver);
 +	if (err)
 +		goto err_clean_ddir;
 +
 +	mutex_unlock(&pf->port_lock);
++=======
+ 	/* Allocate the vnics and do basic init */
+ 	err = nfp_net_pf_alloc_vnics(pf, ctrl_bar, qc_bar, stride);
+ 	if (err)
+ 		goto err_clean_ddir;
+ 
+ 	err = nfp_net_pf_alloc_irqs(pf);
+ 	if (err)
+ 		goto err_free_vnics;
+ 
+ 	err = nfp_net_pf_init_vnics(pf);
+ 	if (err)
+ 		goto err_free_irqs;
+ 
+ 	mutex_unlock(&pf->lock);
++>>>>>>> 6d4b0d8ed6d2 (nfp: slice the netdev spawning function)
  
  	return 0;
  
+ err_free_irqs:
+ 	nfp_net_pf_free_irqs(pf);
+ err_free_vnics:
+ 	nfp_net_pf_free_vnics(pf);
  err_clean_ddir:
  	nfp_net_debugfs_dir_clean(&pf->ddir);
 -	nfp_net_pf_app_clean(pf);
 -err_unmap_qc:
 -	nfp_cpp_area_release_free(pf->qc_area);
 +	nfp_cpp_area_release_free(pf->rx_area);
 +err_unmap_tx:
 +	nfp_cpp_area_release_free(pf->tx_area);
  err_ctrl_unmap:
 -	nfp_cpp_area_release_free(pf->data_vnic_bar);
 +	nfp_cpp_area_release_free(pf->ctrl_area);
  err_unlock:
 -	mutex_unlock(&pf->lock);
 +	mutex_unlock(&pf->port_lock);
  	return err;
  }
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
