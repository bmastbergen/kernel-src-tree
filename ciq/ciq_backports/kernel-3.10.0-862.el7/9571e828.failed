mlxsw: reg: Extract mlxsw_reg_ritr_mac_pack()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 9571e828f460161f76dc3aa24f5857076344b2da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9571e828.failed

Unlike other interface types, loopback RIFs do not have MAC address. So
drop the corresponding argument from mlxsw_reg_ritr_pack() and move it
to a new function. Call that from callers of mlxsw_reg_ritr_pack.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9571e828f460161f76dc3aa24f5857076344b2da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 4a30fec5c668,3ddfbe3d0dbe..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -3449,71 -4878,282 +3449,295 @@@ err_rif_edit
  	return err;
  }
  
 -static int mlxsw_sp_port_vrf_join(struct mlxsw_sp *mlxsw_sp,
 -				  struct net_device *l3_dev)
 +int mlxsw_sp_vport_vrf_join(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
 +	struct net_device *dev = mlxsw_sp_vport->dev;
  
 -	/* If netdev is already associated with a RIF, then we need to
 -	 * destroy it and create a new one with the new virtual router ID.
 +	/* In case vPort already has a RIF, then we need to drop it.
 +	 * A new one will be created using the VRF's VR.
  	 */
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (rif)
 -		__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +	if (f && f->r)
 +		mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
 +
 +	return mlxsw_sp_vport_rif_sp_join(mlxsw_sp_vport, dev);
 +}
 +
 +void mlxsw_sp_vport_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
 +{
 +	mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
 +}
 +
 +int mlxsw_sp_port_vrf_join(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
 +		return -EINVAL;
  
 -	return __mlxsw_sp_inetaddr_event(l3_dev, NETDEV_UP);
 +	return mlxsw_sp_vport_vrf_join(mlxsw_sp_vport);
  }
  
 -static void mlxsw_sp_port_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 -				    struct net_device *l3_dev)
 +void mlxsw_sp_port_vrf_leave(struct mlxsw_sp_port *mlxsw_sp_port)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
  
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (!rif)
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, 1);
 +	if (WARN_ON(!mlxsw_sp_vport))
  		return;
 -	__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +
 +	mlxsw_sp_vport_vrf_leave(mlxsw_sp_vport);
  }
  
 -int mlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,
 -				 struct netdev_notifier_changeupper_info *info)
 +int mlxsw_sp_bridge_vrf_join(struct mlxsw_sp *mlxsw_sp,
 +			     struct net_device *l3_dev)
  {
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
 -	int err = 0;
 +	struct mlxsw_sp_fid *f;
  
 -	if (!mlxsw_sp)
 -		return 0;
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return -EINVAL;
  
 -	switch (event) {
 -	case NETDEV_PRECHANGEUPPER:
 -		return 0;
 -	case NETDEV_CHANGEUPPER:
 -		if (info->linking)
 -			err = mlxsw_sp_port_vrf_join(mlxsw_sp, l3_dev);
 -		else
 -			mlxsw_sp_port_vrf_leave(mlxsw_sp, l3_dev);
 -		break;
 -	}
 +	if (f->r)
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
  
 -	return err;
 +	return mlxsw_sp_rif_bridge_create(mlxsw_sp, l3_dev, f);
  }
  
 -static struct mlxsw_sp_rif_subport *
 -mlxsw_sp_rif_subport_rif(const struct mlxsw_sp_rif *rif)
 +void mlxsw_sp_bridge_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 +			       struct net_device *l3_dev)
  {
 -	return container_of(rif, struct mlxsw_sp_rif_subport, common);
 -}
 +	struct mlxsw_sp_fid *f;
  
++<<<<<<< HEAD
 +	f = mlxsw_sp_bridge_fid_get(mlxsw_sp, l3_dev);
 +	if (WARN_ON(!f))
 +		return;
 +	mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
++=======
+ static void mlxsw_sp_rif_subport_setup(struct mlxsw_sp_rif *rif,
+ 				       const struct mlxsw_sp_rif_params *params)
+ {
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	rif_subport->vid = params->vid;
+ 	rif_subport->lag = params->lag;
+ 	if (params->lag)
+ 		rif_subport->lag_id = params->lag_id;
+ 	else
+ 		rif_subport->system_port = params->system_port;
+ }
+ 
+ static int mlxsw_sp_rif_subport_op(struct mlxsw_sp_rif *rif, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	rif_subport = mlxsw_sp_rif_subport_rif(rif);
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_SP_IF,
+ 			    rif->rif_index, rif->vr_id, rif->dev->mtu);
+ 	mlxsw_reg_ritr_mac_pack(ritr_pl, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_sp_if_pack(ritr_pl, rif_subport->lag,
+ 				  rif_subport->lag ? rif_subport->lag_id :
+ 						     rif_subport->system_port,
+ 				  rif_subport->vid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static int mlxsw_sp_rif_subport_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_rif_subport_op(rif, true);
+ }
+ 
+ static void mlxsw_sp_rif_subport_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	mlxsw_sp_rif_subport_op(rif, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_subport_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_rfid_get(rif->mlxsw_sp, rif->rif_index);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_subport_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_SUBPORT,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif_subport),
+ 	.setup			= mlxsw_sp_rif_subport_setup,
+ 	.configure		= mlxsw_sp_rif_subport_configure,
+ 	.deconfigure		= mlxsw_sp_rif_subport_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_subport_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_vlan_fid_op(struct mlxsw_sp_rif *rif,
+ 				    enum mlxsw_reg_ritr_if_type type,
+ 				    u16 vid_fid, bool enable)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 
+ 	mlxsw_reg_ritr_pack(ritr_pl, enable, type, rif->rif_index, rif->vr_id,
+ 			    rif->dev->mtu);
+ 	mlxsw_reg_ritr_mac_pack(ritr_pl, rif->dev->dev_addr);
+ 	mlxsw_reg_ritr_fid_set(ritr_pl, type, vid_fid);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ static u8 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp)
+ {
+ 	return mlxsw_core_max_ports(mlxsw_sp->core) + 1;
+ }
+ 
+ static int mlxsw_sp_rif_vlan_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_mc_flood_set;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	return 0;
+ 
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_mc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_vlan_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);
+ 
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_VLAN_IF, vid, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	u16 vid = is_vlan_dev(rif->dev) ? vlan_dev_vlan_id(rif->dev) : 1;
+ 
+ 	return mlxsw_sp_fid_8021q_get(rif->mlxsw_sp, vid);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_vlan_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_VLAN,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_vlan_configure,
+ 	.deconfigure		= mlxsw_sp_rif_vlan_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_vlan_fid_get,
+ };
+ 
+ static int mlxsw_sp_rif_fid_configure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 	int err;
+ 
+ 	err = mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index,
+ 				       true);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_mc_flood_set;
+ 
+ 	err = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 				     mlxsw_sp_router_port(mlxsw_sp), true);
+ 	if (err)
+ 		goto err_fid_bc_flood_set;
+ 
+ 	return 0;
+ 
+ err_fid_bc_flood_set:
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ err_fid_mc_flood_set:
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_rif_fid_deconfigure(struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
+ 	u16 fid_index = mlxsw_sp_fid_index(rif->fid);
+ 
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,
+ 			       mlxsw_sp_router_port(mlxsw_sp), false);
+ 	mlxsw_sp_rif_vlan_fid_op(rif, MLXSW_REG_RITR_FID_IF, fid_index, false);
+ }
+ 
+ static struct mlxsw_sp_fid *
+ mlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif)
+ {
+ 	return mlxsw_sp_fid_8021d_get(rif->mlxsw_sp, rif->dev->ifindex);
+ }
+ 
+ static const struct mlxsw_sp_rif_ops mlxsw_sp_rif_fid_ops = {
+ 	.type			= MLXSW_SP_RIF_TYPE_FID,
+ 	.rif_size		= sizeof(struct mlxsw_sp_rif),
+ 	.configure		= mlxsw_sp_rif_fid_configure,
+ 	.deconfigure		= mlxsw_sp_rif_fid_deconfigure,
+ 	.fid_get		= mlxsw_sp_rif_fid_fid_get,
+ };
+ 
+ static const struct mlxsw_sp_rif_ops *mlxsw_sp_rif_ops_arr[] = {
+ 	[MLXSW_SP_RIF_TYPE_SUBPORT]	= &mlxsw_sp_rif_subport_ops,
+ 	[MLXSW_SP_RIF_TYPE_VLAN]	= &mlxsw_sp_rif_vlan_ops,
+ 	[MLXSW_SP_RIF_TYPE_FID]		= &mlxsw_sp_rif_fid_ops,
+ };
+ 
+ static int mlxsw_sp_rifs_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	u64 max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);
+ 
+ 	mlxsw_sp->router->rifs = kcalloc(max_rifs,
+ 					 sizeof(struct mlxsw_sp_rif *),
+ 					 GFP_KERNEL);
+ 	if (!mlxsw_sp->router->rifs)
+ 		return -ENOMEM;
+ 
+ 	mlxsw_sp->router->rif_ops_arr = mlxsw_sp_rif_ops_arr;
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_rifs_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++)
+ 		WARN_ON_ONCE(mlxsw_sp->router->rifs[i]);
+ 
+ 	kfree(mlxsw_sp->router->rifs);
++>>>>>>> 9571e828f460 (mlxsw: reg: Extract mlxsw_reg_ritr_mac_pack())
  }
  
  static void mlxsw_sp_router_fib_dump_flush(struct notifier_block *nb)
diff --git a/drivers/net/ethernet/mellanox/mlxsw/reg.h b/drivers/net/ethernet/mellanox/mlxsw/reg.h
index 72da4579518f..4cd0ec05bb74 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/reg.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/reg.h
@@ -4261,8 +4261,7 @@ static inline void mlxsw_reg_ritr_sp_if_pack(char *payload, bool lag,
 
 static inline void mlxsw_reg_ritr_pack(char *payload, bool enable,
 				       enum mlxsw_reg_ritr_if_type type,
-				       u16 rif, u16 vr_id, u16 mtu,
-				       const char *mac)
+				       u16 rif, u16 vr_id, u16 mtu)
 {
 	bool op = enable ? MLXSW_REG_RITR_RIF_CREATE : MLXSW_REG_RITR_RIF_DEL;
 
@@ -4278,6 +4277,10 @@ static inline void mlxsw_reg_ritr_pack(char *payload, bool enable,
 	mlxsw_reg_ritr_lb_en_set(payload, 1);
 	mlxsw_reg_ritr_virtual_router_set(payload, vr_id);
 	mlxsw_reg_ritr_mtu_set(payload, mtu);
+}
+
+static inline void mlxsw_reg_ritr_mac_pack(char *payload, const char *mac)
+{
 	mlxsw_reg_ritr_if_mac_memcpy_to(payload, mac);
 }
 
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
