kvm: vmx: Raise #UD on unsupported RDRAND

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jim Mattson <jmattson@google.com>
commit 45ec368c9addbbf3fb25fc33d3f22f838ec91714
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/45ec368c.failed

A guest may not be configured to support RDRAND, even when the host
does. If the guest does not support RDRAND, intercept the instruction
and synthesize #UD. Also clear the "allowed-1" bit for RDRAND exiting
in the IA32_VMX_PROCBASED_CTLS2 MSR.

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 45ec368c9addbbf3fb25fc33d3f22f838ec91714)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 35bc7f099719,1f2c69de7872..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2634,9 -2818,8 +2634,9 @@@ static void nested_vmx_setup_ctls_msrs(
  		vmx->nested.nested_vmx_secondary_ctls_high);
  	vmx->nested.nested_vmx_secondary_ctls_low = 0;
  	vmx->nested.nested_vmx_secondary_ctls_high &=
- 		SECONDARY_EXEC_RDRAND | SECONDARY_EXEC_RDSEED |
+ 		SECONDARY_EXEC_RDSEED |
  		SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
 +		SECONDARY_EXEC_RDTSCP |
  		SECONDARY_EXEC_DESC |
  		SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
  		SECONDARY_EXEC_APIC_REGISTER_VIRT |
@@@ -3207,8 -3670,11 +3207,13 @@@ static __init int setup_vmcs_config(str
  			SECONDARY_EXEC_APIC_REGISTER_VIRT |
  			SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
  			SECONDARY_EXEC_SHADOW_VMCS |
++<<<<<<< HEAD
++=======
+ 			SECONDARY_EXEC_XSAVES |
+ 			SECONDARY_EXEC_RDRAND |
++>>>>>>> 45ec368c9add (kvm: vmx: Raise #UD on unsupported RDRAND)
  			SECONDARY_EXEC_ENABLE_PML |
 -			SECONDARY_EXEC_TSC_SCALING |
 -			SECONDARY_EXEC_ENABLE_VMFUNC;
 +			SECONDARY_EXEC_TSC_SCALING;
  		if (adjust_vmx_controls(min2, opt2,
  					MSR_IA32_VMX_PROCBASED_CTLS2,
  					&_cpu_based_2nd_exec_control) < 0)
@@@ -4766,10 -5274,18 +4771,20 @@@ static u32 vmx_exec_control(struct vcpu
  	return exec_control;
  }
  
++<<<<<<< HEAD
 +static u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)
++=======
+ static bool vmx_rdrand_supported(void)
+ {
+ 	return vmcs_config.cpu_based_2nd_exec_ctrl &
+ 		SECONDARY_EXEC_RDRAND;
+ }
+ 
+ static void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)
++>>>>>>> 45ec368c9add (kvm: vmx: Raise #UD on unsupported RDRAND)
  {
 -	struct kvm_vcpu *vcpu = &vmx->vcpu;
 -
  	u32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;
 -	if (!cpu_need_virtualize_apic_accesses(vcpu))
 +	if (!cpu_need_virtualize_apic_accesses(&vmx->vcpu))
  		exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
  	if (vmx->vpid == 0)
  		exec_control &= ~SECONDARY_EXEC_ENABLE_VPID;
@@@ -4797,7 -5313,58 +4812,62 @@@
  	if (!enable_pml)
  		exec_control &= ~SECONDARY_EXEC_ENABLE_PML;
  
++<<<<<<< HEAD
 +	return exec_control;
++=======
+ 	if (vmx_rdtscp_supported()) {
+ 		bool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);
+ 		if (!rdtscp_enabled)
+ 			exec_control &= ~SECONDARY_EXEC_RDTSCP;
+ 
+ 		if (nested) {
+ 			if (rdtscp_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDTSCP;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDTSCP;
+ 		}
+ 	}
+ 
+ 	if (vmx_invpcid_supported()) {
+ 		/* Exposing INVPCID only when PCID is exposed */
+ 		bool invpcid_enabled =
+ 			guest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&
+ 			guest_cpuid_has(vcpu, X86_FEATURE_PCID);
+ 
+ 		if (!invpcid_enabled) {
+ 			exec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;
+ 			guest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);
+ 		}
+ 
+ 		if (nested) {
+ 			if (invpcid_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_ENABLE_INVPCID;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_ENABLE_INVPCID;
+ 		}
+ 	}
+ 
+ 	if (vmx_rdrand_supported()) {
+ 		bool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);
+ 		if (rdrand_enabled)
+ 			exec_control &= ~SECONDARY_EXEC_RDRAND;
+ 
+ 		if (nested) {
+ 			if (rdrand_enabled)
+ 				vmx->nested.nested_vmx_secondary_ctls_high |=
+ 					SECONDARY_EXEC_RDRAND;
+ 			else
+ 				vmx->nested.nested_vmx_secondary_ctls_high &=
+ 					~SECONDARY_EXEC_RDRAND;
+ 		}
+ 	}
+ 
+ 	vmx->secondary_exec_control = exec_control;
++>>>>>>> 45ec368c9add (kvm: vmx: Raise #UD on unsupported RDRAND)
  }
  
  static void ept_set_mmio_spte_mask(void)
@@@ -7591,7 -8118,12 +7667,13 @@@ static int (*const kvm_vmx_exit_handler
  	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,
  	[EXIT_REASON_INVEPT]                  = handle_invept,
  	[EXIT_REASON_INVVPID]                 = handle_invvpid,
++<<<<<<< HEAD
++=======
+ 	[EXIT_REASON_RDRAND]                  = handle_invalid_op,
+ 	[EXIT_REASON_XSAVES]                  = handle_xsaves,
+ 	[EXIT_REASON_XRSTORS]                 = handle_xrstors,
++>>>>>>> 45ec368c9add (kvm: vmx: Raise #UD on unsupported RDRAND)
  	[EXIT_REASON_PML_FULL]		      = handle_pml_full,
 -	[EXIT_REASON_VMFUNC]                  = handle_vmfunc,
 -	[EXIT_REASON_PREEMPTION_TIMER]	      = handle_preemption_timer,
  };
  
  static const int kvm_vmx_max_exit_handlers =
* Unmerged path arch/x86/kvm/vmx.c
