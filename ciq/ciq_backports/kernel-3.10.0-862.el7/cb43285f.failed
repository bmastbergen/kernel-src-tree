qla2xxx: Fix stale pointer access.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix stale pointer access (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 98.51%
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit cb43285ff7039fe3c4b0bc476e6d6569c31104f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cb43285f.failed

[ Upstream Commit 84e32a06f4f8756ce9ec3c8dc7e97896575f0771 ]

Commit 84e32a0 ("qla2xxx: Use pci_enable_msix_range() instead of
pci_enable_msix()") introduced a regression when target mode is enabled.
In qla24xx_enable_msix(), ha->max_rsp_queues was incorrectly set
to a value higher than the number of response queues allocated causing
an invalid dereference. Specifically here in qla2x00_init_rings():
    *rsp->in_ptr = 0;

Add additional check to make sure the pointer is valid. following
call stack will be seen

---- 8< ----
RIP: 0010:[<ffffffffa02ccadc>]  [<ffffffffa02ccadc>] qla2x00_init_rings+0xdc/0x320 [qla2xxx]
RSP: 0018:ffff880429447dd8  EFLAGS: 00010082
....
Call Trace:
[<ffffffffa02ceb40>] qla2x00_abort_isp+0x170/0x6b0 [qla2xxx]
[<ffffffffa02c6f77>] qla2x00_do_dpc+0x357/0x7f0 [qla2xxx]
[<ffffffffa02c6c20>] ? qla2x00_relogin+0x260/0x260 [qla2xxx]
[<ffffffff8107d2c9>] kthread+0xc9/0xe0
[<ffffffff8107d200>] ? flush_kthread_worker+0x90/0x90
[<ffffffff8172cc6f>] ret_from_fork+0x3f/0x70
[<ffffffff8107d200>] ? flush_kthread_worker+0x90/0x90
---- 8< ----

	Cc: <stable@vger.kernel.org>
	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit cb43285ff7039fe3c4b0bc476e6d6569c31104f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mid.c
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 61661da1dd7e,4af95479a9db..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -3031,25 -3061,10 +3031,32 @@@ qla24xx_enable_msix(struct qla_hw_data 
  	} else if (ret < ha->msix_count) {
  		ql_log(ql_log_warn, vha, 0x00c6,
  		    "MSI-X: Failed to enable support "
++<<<<<<< HEAD
 +		    "with %d vectors, using %d vectors\n",
 +		    ha->msix_count, ret);
 +		ha->msix_count = ret;
 +		/* Recalculate queue values */
 +		if (ha->mqiobase && ql2xmqsupport) {
 +			ha->max_req_queues = ha->msix_count - 1;
 +
 +			/* ATIOQ needs 1 vector. That's 1 less QPair */
 +			if (QLA_TGT_MODE_ENABLED())
 +				ha->max_req_queues--;
 +
 +			ha->max_rsp_queues = ha->max_req_queues;
 +
 +			ha->max_qpairs = ha->max_req_queues - 1;
 +			ql_dbg_pci(ql_dbg_init, ha->pdev, 0x0190,
 +				"Adjusted Max no of queues pairs: %d.\n",
 +					ha->max_qpairs);
 +		}
 +
++=======
+ 		    "-- %d/%d\n Retry with %d vectors.\n",
+ 		    ha->msix_count, ret, ret);
+ 		ha->msix_count = ret;
+ 		ha->max_rsp_queues = ha->msix_count - 1;
++>>>>>>> cb43285ff703 (qla2xxx: Fix stale pointer access.)
  	}
  	ha->msix_entries = kzalloc(sizeof(struct qla_msix_entry) *
  				ha->msix_count, GFP_KERNEL);
diff --cc drivers/scsi/qla2xxx/qla_mid.c
index e8fb4d809d33,cf7ba52bae66..000000000000
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@@ -599,38 -596,31 +599,64 @@@ qla25xx_delete_queues(struct scsi_qla_h
  	struct req_que *req = NULL;
  	struct rsp_que *rsp = NULL;
  	struct qla_hw_data *ha = vha->hw;
 +	struct qla_qpair *qpair, *tqpair;
  
++<<<<<<< HEAD
 +	if (ql2xmqsupport) {
 +		list_for_each_entry_safe(qpair, tqpair, &vha->qp_list,
 +			qp_list_elem)
 +		qla2xxx_delete_qpair(vha, qpair);
 +	} else {
 +		/* Delete request queues */
 +		for (cnt = 1; cnt < ha->max_req_queues; cnt++) {
 +			req = ha->req_q_map[cnt];
 +			if (req) {
 +				ret = qla25xx_delete_req_que(vha, req);
 +				if (ret != QLA_SUCCESS) {
 +					ql_log(ql_log_warn, vha, 0x00ea,
 +						"Couldn't delete req que %d.\n",
 +						req->id);
 +					return ret;
 +				}
++=======
+ 	/* Delete request queues */
+ 	for (cnt = 1; cnt < ha->max_req_queues; cnt++) {
+ 		req = ha->req_q_map[cnt];
+ 		if (req && test_bit(cnt, ha->req_qid_map)) {
+ 			ret = qla25xx_delete_req_que(vha, req);
+ 			if (ret != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0x00ea,
+ 				    "Couldn't delete req que %d.\n",
+ 				    req->id);
+ 				return ret;
++>>>>>>> cb43285ff703 (qla2xxx: Fix stale pointer access.)
  			}
  		}
 -	}
  
++<<<<<<< HEAD
 +		/* Delete response queues */
 +		for (cnt = 1; cnt < ha->max_rsp_queues; cnt++) {
 +			rsp = ha->rsp_q_map[cnt];
 +			if (rsp) {
 +				ret = qla25xx_delete_rsp_que(vha, rsp);
 +				if (ret != QLA_SUCCESS) {
 +					ql_log(ql_log_warn, vha, 0x00eb,
 +						"Couldn't delete rsp que %d.\n",
 +						rsp->id);
 +					return ret;
 +				}
++=======
+ 	/* Delete response queues */
+ 	for (cnt = 1; cnt < ha->max_rsp_queues; cnt++) {
+ 		rsp = ha->rsp_q_map[cnt];
+ 		if (rsp && test_bit(cnt, ha->rsp_qid_map)) {
+ 			ret = qla25xx_delete_rsp_que(vha, rsp);
+ 			if (ret != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0x00eb,
+ 				    "Couldn't delete rsp que %d.\n",
+ 				    rsp->id);
+ 				return ret;
++>>>>>>> cb43285ff703 (qla2xxx: Fix stale pointer access.)
  			}
  		}
  	}
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index ea8080a1a353..5aca854aad4e 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -2226,7 +2226,7 @@ qla2x00_init_rings(scsi_qla_host_t *vha)
 	/* Clear outstanding commands array. */
 	for (que = 0; que < ha->max_req_queues; que++) {
 		req = ha->req_q_map[que];
-		if (!req)
+		if (!req || !test_bit(que, ha->req_qid_map))
 			continue;
 		req->out_ptr = (void *)(req->ring + req->length);
 		*req->out_ptr = 0;
@@ -2243,7 +2243,7 @@ qla2x00_init_rings(scsi_qla_host_t *vha)
 
 	for (que = 0; que < ha->max_rsp_queues; que++) {
 		rsp = ha->rsp_q_map[que];
-		if (!rsp)
+		if (!rsp || !test_bit(que, ha->rsp_qid_map))
 			continue;
 		rsp->in_ptr = (void *)(rsp->ring + rsp->length);
 		*rsp->in_ptr = 0;
@@ -4883,7 +4883,7 @@ qla25xx_init_queues(struct qla_hw_data *ha)
 
 	for (i = 1; i < ha->max_rsp_queues; i++) {
 		rsp = ha->rsp_q_map[i];
-		if (rsp) {
+		if (rsp && test_bit(i, ha->rsp_qid_map)) {
 			rsp->options &= ~BIT_0;
 			ret = qla25xx_init_rsp_que(base_vha, rsp);
 			if (ret != QLA_SUCCESS)
@@ -4898,8 +4898,8 @@ qla25xx_init_queues(struct qla_hw_data *ha)
 	}
 	for (i = 1; i < ha->max_req_queues; i++) {
 		req = ha->req_q_map[i];
-		if (req) {
-		/* Clear outstanding commands array. */
+		if (req && test_bit(i, ha->req_qid_map)) {
+			/* Clear outstanding commands array. */
 			req->options &= ~BIT_0;
 			ret = qla25xx_init_req_que(base_vha, req);
 			if (ret != QLA_SUCCESS)
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mid.c
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 981cff5a3c12..1bfb1004532c 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -431,6 +431,9 @@ static void qla2x00_free_queues(struct qla_hw_data *ha)
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	for (cnt = 0; cnt < ha->max_req_queues; cnt++) {
+		if (!test_bit(cnt, ha->req_qid_map))
+			continue;
+
 		req = ha->req_q_map[cnt];
 		clear_bit(cnt, ha->req_qid_map);
 		ha->req_q_map[cnt] = NULL;
@@ -446,6 +449,9 @@ static void qla2x00_free_queues(struct qla_hw_data *ha)
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	for (cnt = 0; cnt < ha->max_rsp_queues; cnt++) {
+		if (!test_bit(cnt, ha->rsp_qid_map))
+			continue;
+
 		rsp = ha->rsp_q_map[cnt];
 		clear_bit(cnt, ha->rsp_qid_map);
 		ha->rsp_q_map[cnt] =  NULL;
diff --git a/drivers/scsi/qla2xxx/qla_tmpl.c b/drivers/scsi/qla2xxx/qla_tmpl.c
index 2e0b7a082660..52b232ba888e 100644
--- a/drivers/scsi/qla2xxx/qla_tmpl.c
+++ b/drivers/scsi/qla2xxx/qla_tmpl.c
@@ -402,6 +402,10 @@ qla27xx_fwdt_entry_t263(struct scsi_qla_host *vha,
 	if (ent->t263.queue_type == T263_QUEUE_TYPE_REQ) {
 		for (i = 0; i < vha->hw->max_req_queues; i++) {
 			struct req_que *req = vha->hw->req_q_map[i];
+
+			if (!test_bit(i, vha->hw->req_qid_map))
+				continue;
+
 			if (req || !buf) {
 				length = req ?
 				    req->length : REQUEST_ENTRY_CNT_24XX;
@@ -415,6 +419,10 @@ qla27xx_fwdt_entry_t263(struct scsi_qla_host *vha,
 	} else if (ent->t263.queue_type == T263_QUEUE_TYPE_RSP) {
 		for (i = 0; i < vha->hw->max_rsp_queues; i++) {
 			struct rsp_que *rsp = vha->hw->rsp_q_map[i];
+
+			if (!test_bit(i, vha->hw->rsp_qid_map))
+				continue;
+
 			if (rsp || !buf) {
 				length = rsp ?
 				    rsp->length : RESPONSE_ENTRY_CNT_MQ;
@@ -641,6 +649,10 @@ qla27xx_fwdt_entry_t274(struct scsi_qla_host *vha,
 	if (ent->t274.queue_type == T274_QUEUE_TYPE_REQ_SHAD) {
 		for (i = 0; i < vha->hw->max_req_queues; i++) {
 			struct req_que *req = vha->hw->req_q_map[i];
+
+			if (!test_bit(i, vha->hw->req_qid_map))
+				continue;
+
 			if (req || !buf) {
 				qla27xx_insert16(i, buf, len);
 				qla27xx_insert16(1, buf, len);
@@ -652,6 +664,10 @@ qla27xx_fwdt_entry_t274(struct scsi_qla_host *vha,
 	} else if (ent->t274.queue_type == T274_QUEUE_TYPE_RSP_SHAD) {
 		for (i = 0; i < vha->hw->max_rsp_queues; i++) {
 			struct rsp_que *rsp = vha->hw->rsp_q_map[i];
+
+			if (!test_bit(i, vha->hw->rsp_qid_map))
+				continue;
+
 			if (rsp || !buf) {
 				qla27xx_insert16(i, buf, len);
 				qla27xx_insert16(1, buf, len);
