qla2xxx: Track I-T nexus as single fc_port struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 5d964837c6a743193c63c8912f98834c7457ba5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5d964837.failed

Current code merges qla_tgt_sess and fc_port structure
into single fc_port structure representing same I-T nexus.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
[ bvanassche: fixed spelling of patch description ]
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>

	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 5d964837c6a743193c63c8912f98834c7457ba5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dfs.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_dfs.c
index 2ca39b8e7166,b48cce696bac..000000000000
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@@ -13,6 -13,125 +13,128 @@@ static struct dentry *qla2x00_dfs_root
  static atomic_t qla2x00_dfs_root_count;
  
  static int
++<<<<<<< HEAD
++=======
+ qla2x00_dfs_tgt_sess_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct fc_port *sess = NULL;
+ 	struct qla_tgt *tgt= vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n",vha->host_str);
+ 	if (tgt) {
+ 		seq_printf(s, "Port ID   Port Name                Handle\n");
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		list_for_each_entry(sess, &vha->vp_fcports, list)
+ 			seq_printf(s, "%02x:%02x:%02x  %8phC  %d\n",
+ 			    sess->d_id.b.domain, sess->d_id.b.area,
+ 			    sess->d_id.b.al_pa, sess->port_name,
+ 			    sess->loop_id);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_sess_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 	return single_open(file, qla2x00_dfs_tgt_sess_show, vha);
+ }
+ 
+ 
+ static const struct file_operations dfs_tgt_sess_ops = {
+ 	.open		= qla2x00_dfs_tgt_sess_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	seq_puts(s, "FW Resource count\n\n");
+ 	seq_printf(s, "Original TGT exchg count[%d]\n",
+ 	    ha->orig_fw_tgt_xcb_count);
+ 	seq_printf(s, "current TGT exchg count[%d]\n",
+ 	    ha->cur_fw_tgt_xcb_count);
+ 	seq_printf(s, "original Initiator Exchange count[%d]\n",
+ 	    ha->orig_fw_xcb_count);
+ 	seq_printf(s, "Current Initiator Exchange count[%d]\n",
+ 	    ha->cur_fw_xcb_count);
+ 	seq_printf(s, "Original IOCB count[%d]\n", ha->orig_fw_iocb_count);
+ 	seq_printf(s, "Current IOCB count[%d]\n", ha->cur_fw_iocb_count);
+ 	seq_printf(s, "MAX VP count[%d]\n", ha->max_npiv_vports);
+ 	seq_printf(s, "MAX FCF count[%d]\n", ha->fw_max_fcf_count);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_fw_resource_cnt_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_fw_resource_cnt_show, vha);
+ }
+ 
+ static const struct file_operations dfs_fw_resource_cnt_ops = {
+ 	.open           = qla_dfs_fw_resource_cnt_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
+ qla_dfs_tgt_counters_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 
+ 	seq_puts(s, "Target Counters\n");
+ 	seq_printf(s, "qla_core_sbt_cmd = %lld\n",
+ 		vha->tgt_counters.qla_core_sbt_cmd);
+ 	seq_printf(s, "qla_core_ret_sta_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_sta_ctio);
+ 	seq_printf(s, "qla_core_ret_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_ctio);
+ 	seq_printf(s, "core_qla_que_buf = %lld\n",
+ 		vha->tgt_counters.core_qla_que_buf);
+ 	seq_printf(s, "core_qla_snd_status = %lld\n",
+ 		vha->tgt_counters.core_qla_snd_status);
+ 	seq_printf(s, "core_qla_free_cmd = %lld\n",
+ 		vha->tgt_counters.core_qla_free_cmd);
+ 	seq_printf(s, "num alloc iocb failed = %lld\n",
+ 		vha->tgt_counters.num_alloc_iocb_failed);
+ 	seq_printf(s, "num term exchange sent = %lld\n",
+ 		vha->tgt_counters.num_term_xchg_sent);
+ 	seq_printf(s, "num Q full sent = %lld\n",
+ 		vha->tgt_counters.num_q_full_sent);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_tgt_counters_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_tgt_counters_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_counters_ops = {
+ 	.open           = qla_dfs_tgt_counters_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  qla2x00_dfs_fce_show(struct seq_file *s, void *unused)
  {
  	scsi_qla_host_t *vha = s->private;
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,5978b79d4a61..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -3335,11 -3352,6 +3335,14 @@@ qla2x00_reg_remote_port(scsi_qla_host_
  		    "Unable to allocate fc remote port.\n");
  		return;
  	}
++<<<<<<< HEAD
 +	/*
 +	 * Create target mode FC NEXUS in qla_target.c if target mode is
 +	 * enabled..
 +	 */
 +	qlt_fc_port_added(vha, fcport);
++=======
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  
  	spin_lock_irqsave(fcport->vha->host->host_lock, flags);
  	*((fc_port_t **)rport->dd_data) = fcport;
@@@ -3386,7 -3397,10 +3389,14 @@@ qla2x00_update_fcport(scsi_qla_host_t *
  	qla2x00_set_fcport_state(fcport, FCS_ONLINE);
  	qla2x00_iidma_fcport(vha, fcport);
  	qla24xx_update_fcport_fcp_prio(vha, fcport);
++<<<<<<< HEAD
 +	qla2x00_reg_remote_port(vha, fcport);
++=======
+ 
+ reg_port:
+ 	if (qla_ini_mode_enabled(vha))
+ 		qla2x00_reg_remote_port(vha, fcport);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  /*
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 2aea13d9d71e,834e22197842..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2213,6 -2247,9 +2213,12 @@@ qla24xx_logout_iocb(srb_t *sp, struct l
  	logio->entry_type = LOGINOUT_PORT_IOCB_TYPE;
  	logio->control_flags =
  	    cpu_to_le16(LCF_COMMAND_LOGO|LCF_IMPL_LOGO);
++<<<<<<< HEAD
++=======
+ 	if (!sp->fcport->tgt_session ||
+ 	    !sp->fcport->keep_nport_handle)
+ 		logio->control_flags |= cpu_to_le16(LCF_FREE_NPORT);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	logio->nport_handle = cpu_to_le16(sp->fcport->loop_id);
  	logio->port_id[0] = sp->fcport->d_id.b.al_pa;
  	logio->port_id[1] = sp->fcport->d_id.b.area;
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,40b61a327786..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -93,14 -100,24 +93,14 @@@ enum fcp_resp_rsp_codes 
   */
  /* Predefs for callbacks handed to qla2xxx LLD */
  static void qlt_24xx_atio_pkt(struct scsi_qla_host *ha,
 -	struct atio_from_isp *pkt, uint8_t);
 +	struct atio_from_isp *pkt);
  static void qlt_response_pkt(struct scsi_qla_host *ha, response_t *pkt);
- static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,
+ static int qlt_issue_task_mgmt(struct fc_port *sess, u64 lun,
  	int fn, void *iocb, int flags);
  static void qlt_send_term_exchange(struct scsi_qla_host *ha, struct qla_tgt_cmd
 -	*cmd, struct atio_from_isp *atio, int ha_locked, int ul_abort);
 -static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha,
 -	struct qla_tgt_cmd *cmd);
 -static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
 -	struct atio_from_isp *atio, uint16_t status, int qfull);
 -static void qlt_disable_vha(struct scsi_qla_host *vha);
 -static void qlt_clear_tgt_db(struct qla_tgt *tgt);
 -static void qlt_send_notify_ack(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *ntfy,
 -	uint32_t add_flags, uint16_t resp_code, int resp_code_valid,
 -	uint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);
 -static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *imm, int ha_locked);
 +	*cmd, struct atio_from_isp *atio, int ha_locked);
 +static void qlt_reject_free_srr_imm(struct scsi_qla_host *ha,
 +	struct qla_tgt_srr_imm *imm, int ha_lock);
  /*
   * Global Variables
   */
@@@ -111,19 -128,14 +111,30 @@@ static struct workqueue_struct *qla_tgt
  static DEFINE_MUTEX(qla_tgt_mutex);
  static LIST_HEAD(qla_tgt_glist);
  
++<<<<<<< HEAD
 +/* ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list) */
 +static struct qla_tgt_sess *qlt_find_sess_by_port_name(
 +	struct qla_tgt *tgt,
 +	const uint8_t *port_name)
 +{
 +	struct qla_tgt_sess *sess;
 +
 +	list_for_each_entry(sess, &tgt->sess_list, sess_list_entry) {
 +		if (!memcmp(sess->port_name, port_name, WWN_SIZE))
 +			return sess;
 +	}
 +
 +	return NULL;
++=======
+ /* This API intentionally takes dest as a parameter, rather than returning
+  * int value to avoid caller forgetting to issue wmb() after the store */
+ void qlt_do_generation_tick(struct scsi_qla_host *vha, int *dest)
+ {
+ 	scsi_qla_host_t *base_vha = pci_get_drvdata(vha->hw->pdev);
+ 	*dest = atomic_inc_return(&base_vha->generation_tick);
+ 	/* memory barrier */
+ 	wmb();
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  /* Might release hw lock, then reaquire!! */
@@@ -333,21 -375,240 +344,238 @@@ void qlt_response_pkt_all_vps(struct sc
  
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * All qlt_plogi_ack_t operations are protected by hardware_lock
+  */
+ 
+ /*
+  * This is a zero-base ref-counting solution, since hardware_lock
+  * guarantees that ref_count is not modified concurrently.
+  * Upon successful return content of iocb is undefined
+  */
+ static struct qlt_plogi_ack_t *
+ qlt_plogi_ack_find_add(struct scsi_qla_host *vha, port_id_t *id,
+ 		       struct imm_ntfy_from_isp *iocb)
+ {
+ 	struct qlt_plogi_ack_t *pla;
+ 
+ 	list_for_each_entry(pla, &vha->plogi_ack_list, list) {
+ 		if (pla->id.b24 == id->b24) {
+ 			qlt_send_term_imm_notif(vha, &pla->iocb, 1);
+ 			memcpy(&pla->iocb, iocb, sizeof(pla->iocb));
+ 			return pla;
+ 		}
+ 	}
+ 
+ 	pla = kmem_cache_zalloc(qla_tgt_plogi_cachep, GFP_ATOMIC);
+ 	if (!pla) {
+ 		ql_dbg(ql_dbg_async, vha, 0x5088,
+ 		       "qla_target(%d): Allocation of plogi_ack failed\n",
+ 		       vha->vp_idx);
+ 		return NULL;
+ 	}
+ 
+ 	memcpy(&pla->iocb, iocb, sizeof(pla->iocb));
+ 	pla->id = *id;
+ 	list_add_tail(&pla->list, &vha->plogi_ack_list);
+ 
+ 	return pla;
+ }
+ 
+ static void qlt_plogi_ack_unref(struct scsi_qla_host *vha,
+     struct qlt_plogi_ack_t *pla)
+ {
+ 	struct imm_ntfy_from_isp *iocb = &pla->iocb;
+ 	BUG_ON(!pla->ref_count);
+ 	pla->ref_count--;
+ 
+ 	if (pla->ref_count)
+ 		return;
+ 
+ 	ql_dbg(ql_dbg_async, vha, 0x5089,
+ 	    "Sending PLOGI ACK to wwn %8phC s_id %02x:%02x:%02x loop_id %#04x"
+ 	    " exch %#x ox_id %#x\n", iocb->u.isp24.port_name,
+ 	    iocb->u.isp24.port_id[2], iocb->u.isp24.port_id[1],
+ 	    iocb->u.isp24.port_id[0],
+ 	    le16_to_cpu(iocb->u.isp24.nport_handle),
+ 	    iocb->u.isp24.exchange_address, iocb->ox_id);
+ 	qlt_send_notify_ack(vha, iocb, 0, 0, 0, 0, 0, 0);
+ 
+ 	list_del(&pla->list);
+ 	kmem_cache_free(qla_tgt_plogi_cachep, pla);
+ }
+ 
+ static void
+ qlt_plogi_ack_link(struct scsi_qla_host *vha, struct qlt_plogi_ack_t *pla,
+     struct fc_port *sess, enum qlt_plogi_link_t link)
+ {
+ 	struct imm_ntfy_from_isp *iocb = &pla->iocb;
+ 	/* Inc ref_count first because link might already be pointing at pla */
+ 	pla->ref_count++;
+ 
+ 	if (sess->plogi_link[link])
+ 		qlt_plogi_ack_unref(vha, sess->plogi_link[link]);
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf097,
+ 	    "Linking sess %p [%d] wwn %8phC with PLOGI ACK to wwn %8phC"
+ 	    " s_id %02x:%02x:%02x, ref=%d\n", sess, link, sess->port_name,
+ 	    iocb->u.isp24.port_name, iocb->u.isp24.port_id[2],
+ 	    iocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],
+ 	    pla->ref_count);
+ 
+ 	sess->plogi_link[link] = pla;
+ }
+ 
+ typedef struct {
+ 	/* These fields must be initialized by the caller */
+ 	port_id_t id;
+ 	/*
+ 	 * number of cmds dropped while we were waiting for
+ 	 * initiator to ack LOGO initialize to 1 if LOGO is
+ 	 * triggered by a command, otherwise, to 0
+ 	 */
+ 	int cmd_count;
+ 
+ 	/* These fields are used by callee */
+ 	struct list_head list;
+ } qlt_port_logo_t;
+ 
+ static void
+ qlt_send_first_logo(struct scsi_qla_host *vha, qlt_port_logo_t *logo)
+ {
+ 	qlt_port_logo_t *tmp;
+ 	int res;
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	list_for_each_entry(tmp, &vha->logo_list, list) {
+ 		if (tmp->id.b24 == logo->id.b24) {
+ 			tmp->cmd_count += logo->cmd_count;
+ 			mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 			return;
+ 		}
+ 	}
+ 
+ 	list_add_tail(&logo->list, &vha->logo_list);
+ 
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	res = qla24xx_els_dcmd_iocb(vha, ELS_DCMD_LOGO, logo->id);
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 	list_del(&logo->list);
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf098,
+ 	    "Finished LOGO to %02x:%02x:%02x, dropped %d cmds, res = %#x\n",
+ 	    logo->id.b.domain, logo->id.b.area, logo->id.b.al_pa,
+ 	    logo->cmd_count, res);
+ }
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  static void qlt_free_session_done(struct work_struct *work)
  {
- 	struct qla_tgt_sess *sess = container_of(work, struct qla_tgt_sess,
+ 	struct fc_port *sess = container_of(work, struct fc_port,
  	    free_work);
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
  	struct qla_hw_data *ha = vha->hw;
 -	unsigned long flags;
 -	bool logout_started = false;
 -	fc_port_t fcport;
 -
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,
 -		"%s: se_sess %p / sess %p from port %8phC loop_id %#04x"
 -		" s_id %02x:%02x:%02x logout %d keep %d els_logo %d\n",
 -		__func__, sess->se_sess, sess, sess->port_name, sess->loop_id,
 -		sess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,
 -		sess->logout_on_delete, sess->keep_nport_handle,
 -		sess->send_els_logo);
  
  	BUG_ON(!tgt);
++<<<<<<< HEAD
++=======
+ 
+ 	if (sess->send_els_logo) {
+ 		qlt_port_logo_t logo;
+ 		logo.id = sess->d_id;
+ 		logo.cmd_count = 0;
+ 		qlt_send_first_logo(vha, &logo);
+ 	}
+ 
+ 	if (sess->logout_on_delete) {
+ 		int rc;
+ 
+ 		memset(&fcport, 0, sizeof(fcport));
+ 		fcport.loop_id = sess->loop_id;
+ 		fcport.d_id = sess->d_id;
+ 		memcpy(fcport.port_name, sess->port_name, WWN_SIZE);
+ 		fcport.vha = vha;
+ 
+ 		rc = qla2x00_post_async_logout_work(vha, &fcport, NULL);
+ 		if (rc != QLA_SUCCESS)
+ 			ql_log(ql_log_warn, vha, 0xf085,
+ 			       "Schedule logo failed sess %p rc %d\n",
+ 			       sess, rc);
+ 		else
+ 			logout_started = true;
+ 	}
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	/*
  	 * Release the target session for FC Nexus from fabric module code.
  	 */
  	if (sess->se_sess != NULL)
  		ha->tgt.tgt_ops->free_session(sess);
  
++<<<<<<< HEAD
++=======
+ 	if (logout_started) {
+ 		bool traced = false;
+ 
+ 		while (!ACCESS_ONCE(sess->logout_completed)) {
+ 			if (!traced) {
+ 				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf086,
+ 					"%s: waiting for sess %p logout\n",
+ 					__func__, sess);
+ 				traced = true;
+ 			}
+ 			msleep(100);
+ 		}
+ 
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf087,
+ 			"%s: sess %p logout completed\n",
+ 			__func__, sess);
+ 	}
+ 
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	{
+ 		struct qlt_plogi_ack_t *own =
+ 		    sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN];
+ 		struct qlt_plogi_ack_t *con =
+ 		    sess->plogi_link[QLT_PLOGI_LINK_CONFLICT];
+ 		struct imm_ntfy_from_isp *iocb;
+ 
+ 		if (con) {
+ 			iocb = &con->iocb;
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf099,
+ 				 "se_sess %p / sess %p port %8phC is gone,"
+ 				 " %s (ref=%d), releasing PLOGI for %8phC (ref=%d)\n",
+ 				 sess->se_sess, sess, sess->port_name,
+ 				 own ? "releasing own PLOGI" : "no own PLOGI pending",
+ 				 own ? own->ref_count : -1,
+ 				 iocb->u.isp24.port_name, con->ref_count);
+ 			qlt_plogi_ack_unref(vha, con);
+ 		} else {
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09a,
+ 			    "se_sess %p / sess %p port %8phC is gone, %s (ref=%d)\n",
+ 			    sess->se_sess, sess, sess->port_name,
+ 			    own ? "releasing own PLOGI" :
+ 			    "no own PLOGI pending",
+ 			    own ? own->ref_count : -1);
+ 		}
+ 
+ 		if (own)
+ 			qlt_plogi_ack_unref(vha, own);
+ 	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	sess->se_sess = NULL;
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf001,
  	    "Unregistration of sess %p finished\n", sess);
  
@@@ -361,28 -621,31 +588,53 @@@
  		wake_up_all(&tgt->waitQ);
  }
  
++<<<<<<< HEAD
 +/* ha->hardware_lock supposed to be held on entry */
 +void qlt_unreg_sess(struct qla_tgt_sess *sess)
 +{
 +	struct scsi_qla_host *vha = sess->vha;
 +
 +	vha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);
 +
 +	list_del(&sess->sess_list_entry);
 +	if (sess->deleted)
 +		list_del(&sess->del_list_entry);
++=======
+ /* ha->tgt.sess_lock supposed to be held on entry */
+ void qlt_unreg_sess(struct fc_port *sess)
+ {
+ 	struct scsi_qla_host *vha = sess->vha;
+ 
+ 	ql_dbg(ql_dbg_disc, sess->vha, 0xffff,
+ 	    "%s sess %p for deletion %8phC\n",
+ 	    __func__, sess, sess->port_name);
+ 
+ 	if (sess->se_sess)
+ 		vha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);
+ 
+ 	qla2x00_mark_device_lost(vha, sess, 1, 1);
+ 
+ 	sess->deleted = QLA_SESS_DELETION_IN_PROGRESS;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  
  	INIT_WORK(&sess->free_work, qlt_free_session_done);
  	schedule_work(&sess->free_work);
  }
  EXPORT_SYMBOL(qlt_unreg_sess);
  
++<<<<<<< HEAD
 +/* ha->hardware_lock supposed to be held on entry */
 +static int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt_sess *sess = NULL;
 +	uint32_t unpacked_lun, lun = 0;
++=======
+ static int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess = NULL;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	uint16_t loop_id;
  	int res = 0;
  	struct imm_ntfy_from_isp *n = (struct imm_ntfy_from_isp *)iocb;
@@@ -390,36 -653,15 +642,43 @@@
  
  	loop_id = le16_to_cpu(n->u.isp24.nport_handle);
  	if (loop_id == 0xFFFF) {
 +#if 0 /* FIXME: Re-enable Global event handling.. */
  		/* Global event */
++<<<<<<< HEAD
 +		atomic_inc(&ha->tgt.qla_tgt->tgt_global_resets_count);
 +		qlt_clear_tgt_db(ha->tgt.qla_tgt, 1);
 +		if (!list_empty(&ha->tgt.qla_tgt->sess_list)) {
 +			sess = list_entry(ha->tgt.qla_tgt->sess_list.next,
 +			    typeof(*sess), sess_list_entry);
 +			switch (mcmd) {
 +			case QLA_TGT_NEXUS_LOSS_SESS:
 +				mcmd = QLA_TGT_NEXUS_LOSS;
 +				break;
 +			case QLA_TGT_ABORT_ALL_SESS:
 +				mcmd = QLA_TGT_ABORT_ALL;
 +				break;
 +			case QLA_TGT_NEXUS_LOSS:
 +			case QLA_TGT_ABORT_ALL:
 +				break;
 +			default:
 +				ql_dbg(ql_dbg_tgt, vha, 0xe046,
 +				    "qla_target(%d): Not allowed "
 +				    "command %x in %s", vha->vp_idx,
 +				    mcmd, __func__);
 +				sess = NULL;
 +				break;
 +			}
 +		} else
 +			sess = NULL;
 +#endif
++=======
+ 		atomic_inc(&vha->vha_tgt.qla_tgt->tgt_global_resets_count);
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		qlt_clear_tgt_db(vha->vha_tgt.qla_tgt);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	} else {
 -		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  		sess = ha->tgt.tgt_ops->find_sess_by_loop_id(vha, loop_id);
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  	}
  
  	ql_dbg(ql_dbg_tgt, vha, 0xe000,
@@@ -434,15 -676,11 +693,20 @@@
  	    "loop_id %d)\n", vha->host_no, sess, sess->port_name,
  	    mcmd, loop_id);
  
 -	return qlt_issue_task_mgmt(sess, 0, mcmd, iocb, QLA24XX_MGMT_SEND_NACK);
 +	lun = a->u.isp24.fcp_cmnd.lun;
 +	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
 +
 +	return qlt_issue_task_mgmt(sess, unpacked_lun, mcmd,
 +	    iocb, QLA24XX_MGMT_SEND_NACK);
  }
  
++<<<<<<< HEAD
 +/* ha->hardware_lock supposed to be held on entry */
 +static void qlt_schedule_sess_for_deletion(struct qla_tgt_sess *sess,
++=======
+ /* ha->tgt.sess_lock supposed to be held on entry */
+ static void qlt_schedule_sess_for_deletion(struct fc_port *sess,
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	bool immediate)
  {
  	struct qla_tgt *tgt = sess->tgt;
@@@ -462,25 -709,30 +726,28 @@@
  	sess->expires = jiffies + dev_loss_tmo * HZ;
  
  	ql_dbg(ql_dbg_tgt, sess->vha, 0xe048,
 -	    "qla_target(%d): session for port %8phC (loop ID %d s_id %02x:%02x:%02x)"
 -	    " scheduled for deletion in %u secs (expires: %lu) immed: %d, logout: %d, gen: %#x\n",
 -	    sess->vha->vp_idx, sess->port_name, sess->loop_id,
 -	    sess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,
 -	    dev_loss_tmo, sess->expires, immediate, sess->logout_on_delete,
 -	    sess->generation);
 +	    "qla_target(%d): session for port %8phC (loop ID %d) scheduled for "
 +	    "deletion in %u secs (expires: %lu) immed: %d\n",
 +	    sess->vha->vp_idx, sess->port_name, sess->loop_id, dev_loss_tmo,
 +	    sess->expires, immediate);
  
  	if (immediate)
 -		mod_delayed_work(system_wq, &tgt->sess_del_work, 0);
 +		schedule_delayed_work(&tgt->sess_del_work, 0);
  	else
  		schedule_delayed_work(&tgt->sess_del_work,
 -		    sess->expires - jiffies);
 +		    jiffies - sess->expires);
  }
  
 -/* ha->tgt.sess_lock supposed to be held on entry */
 -static void qlt_clear_tgt_db(struct qla_tgt *tgt)
 +/* ha->hardware_lock supposed to be held on entry */
 +static void qlt_clear_tgt_db(struct qla_tgt *tgt, bool local_only)
  {
- 	struct qla_tgt_sess *sess;
+ 	struct fc_port *sess;
+ 	scsi_qla_host_t *vha = tgt->vha;
  
- 	list_for_each_entry(sess, &tgt->sess_list, sess_list_entry)
- 		qlt_schedule_sess_for_deletion(sess, true);
+ 	list_for_each_entry(sess, &vha->vp_fcports, list) {
+ 		if (sess->se_sess)
+ 			qlt_schedule_sess_for_deletion(sess, true);
+ 	}
  
  	/* At this point tgt could be already dead */
  }
@@@ -534,108 -786,12 +801,113 @@@ out_free_id_list
  	return res;
  }
  
++<<<<<<< HEAD
 +static bool qlt_check_fcport_exist(struct scsi_qla_host *vha,
 +	struct qla_tgt_sess *sess)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_port_24xx_data *pmap24;
 +	bool res, found = false;
 +	int rc, i;
 +	uint16_t loop_id = 0xFFFF; /* to eliminate compiler's warning */
 +	uint16_t entries;
 +	void *pmap;
 +	int pmap_len;
 +	fc_port_t *fcport;
 +	int global_resets;
 +	unsigned long flags;
 +
 +retry:
 +	global_resets = atomic_read(&ha->tgt.qla_tgt->tgt_global_resets_count);
 +
 +	rc = qla2x00_get_node_name_list(vha, &pmap, &pmap_len);
 +	if (rc != QLA_SUCCESS) {
 +		res = false;
 +		goto out;
 +	}
 +
 +	pmap24 = pmap;
 +	entries = pmap_len/sizeof(*pmap24);
 +
 +	for (i = 0; i < entries; ++i) {
 +		if (!memcmp(sess->port_name, pmap24[i].port_name, WWN_SIZE)) {
 +			loop_id = le16_to_cpu(pmap24[i].loop_id);
 +			found = true;
 +			break;
 +		}
 +	}
 +
 +	kfree(pmap);
 +
 +	if (!found) {
 +		res = false;
 +		goto out;
 +	}
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf046,
 +	    "qlt_check_fcport_exist(): loop_id %d", loop_id);
 +
 +	fcport = kzalloc(sizeof(*fcport), GFP_KERNEL);
 +	if (fcport == NULL) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf047,
 +		    "qla_target(%d): Allocation of tmp FC port failed",
 +		    vha->vp_idx);
 +		res = false;
 +		goto out;
 +	}
 +
 +	fcport->loop_id = loop_id;
 +
 +	rc = qla2x00_get_port_database(vha, fcport, 0);
 +	if (rc != QLA_SUCCESS) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf048,
 +		    "qla_target(%d): Failed to retrieve fcport "
 +		    "information -- get_port_database() returned %x "
 +		    "(loop_id=0x%04x)", vha->vp_idx, rc, loop_id);
 +		res = false;
 +		goto out_free_fcport;
 +	}
 +
 +	if (global_resets !=
 +	    atomic_read(&ha->tgt.qla_tgt->tgt_global_resets_count)) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf002,
 +		    "qla_target(%d): global reset during session discovery"
 +		    " (counter was %d, new %d), retrying",
 +		    vha->vp_idx, global_resets,
 +		    atomic_read(&ha->tgt.qla_tgt->tgt_global_resets_count));
 +		goto retry;
 +	}
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf003,
 +	    "Updating sess %p s_id %x:%x:%x, loop_id %d) to d_id %x:%x:%x, "
 +	    "loop_id %d", sess, sess->s_id.b.domain, sess->s_id.b.al_pa,
 +	    sess->s_id.b.area, sess->loop_id, fcport->d_id.b.domain,
 +	    fcport->d_id.b.al_pa, fcport->d_id.b.area, fcport->loop_id);
 +
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	ha->tgt.tgt_ops->update_sess(sess, fcport->d_id, fcport->loop_id,
 +				(fcport->flags & FCF_CONF_COMP_SUPPORTED));
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	res = true;
 +
 +out_free_fcport:
 +	kfree(fcport);
 +
 +out:
 +	return res;
 +}
 +
 +/* ha->hardware_lock supposed to be held on entry */
 +static void qlt_undelete_sess(struct qla_tgt_sess *sess)
++=======
+ /* ha->tgt.sess_lock supposed to be held on entry */
+ static void qlt_undelete_sess(struct fc_port *sess)
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  {
 -	BUG_ON(sess->deleted != QLA_SESS_DELETION_PENDING);
 +	BUG_ON(!sess->deleted);
  
 -	list_del_init(&sess->del_list_entry);
 +	list_del(&sess->del_list_entry);
  	sess->deleted = 0;
  }
  
@@@ -645,54 -801,28 +917,63 @@@ static void qlt_del_sess_work_fn(struc
  	    sess_del_work);
  	struct scsi_qla_host *vha = tgt->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess;
 +	unsigned long flags;
++=======
+ 	struct fc_port *sess;
+ 	unsigned long flags, elapsed;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
  	while (!list_empty(&tgt->del_sess_list)) {
  		sess = list_entry(tgt->del_sess_list.next, typeof(*sess),
  		    del_list_entry);
 -		elapsed = jiffies;
 -		if (time_after_eq(elapsed, sess->expires)) {
 -			/* No turning back */
 -			list_del_init(&sess->del_list_entry);
 -			sess->deleted = QLA_SESS_DELETION_IN_PROGRESS;
 -
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,
 -			    "Timeout: sess %p about to be deleted\n",
 -			    sess);
 -			if (sess->se_sess)
 +		if (time_after_eq(jiffies, sess->expires)) {
 +			bool cancel;
 +
 +			qlt_undelete_sess(sess);
 +
 +			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +			cancel = qlt_check_fcport_exist(vha, sess);
 +
 +			if (cancel) {
 +				if (sess->deleted) {
 +					/*
 +					 * sess was again deleted while we were
 +					 * discovering it
 +					 */
 +					spin_lock_irqsave(&ha->hardware_lock,
 +					    flags);
 +					continue;
 +				}
 +
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf049,
 +				    "qla_target(%d): cancel deletion of "
 +				    "session for port %02x:%02x:%02x:%02x:%02x:"
 +				    "%02x:%02x:%02x (loop ID %d), because "
 +				    " it isn't deleted by firmware",
 +				    vha->vp_idx, sess->port_name[0],
 +				    sess->port_name[1], sess->port_name[2],
 +				    sess->port_name[3], sess->port_name[4],
 +				    sess->port_name[5], sess->port_name[6],
 +				    sess->port_name[7], sess->loop_id);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,
 +				    "Timeout: sess %p about to be deleted\n",
 +				    sess);
  				ha->tgt.tgt_ops->shutdown_sess(sess);
++<<<<<<< HEAD
 +				ha->tgt.tgt_ops->put_sess(sess);
 +			}
 +
 +			spin_lock_irqsave(&ha->hardware_lock, flags);
++=======
+ 			ha->tgt.tgt_ops->put_sess(sess);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  		} else {
  			schedule_delayed_work(&tgt->sess_del_work,
 -			    sess->expires - elapsed);
 +			    jiffies - sess->expires);
  			break;
  		}
  	}
@@@ -709,14 -839,12 +990,19 @@@ static struct fc_port *qlt_create_sess
  	bool local)
  {
  	struct qla_hw_data *ha = vha->hw;
- 	struct qla_tgt_sess *sess;
+ 	struct fc_port *sess;
  	unsigned long flags;
 +	unsigned char be_sid[3];
  
  	/* Check to avoid double sessions */
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	list_for_each_entry(sess, &ha->tgt.qla_tgt->sess_list,
 +				sess_list_entry) {
++=======
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	list_for_each_entry(sess, &vha->vp_fcports, list) {
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  		if (!memcmp(sess->port_name, fcport->port_name, WWN_SIZE)) {
  			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf005,
  			    "Double sess %p found (s_id %x:%x:%x, "
@@@ -760,11 -906,34 +1046,32 @@@
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf006,
  	    "Adding sess %p to tgt %p via ->check_initiator_node_acl()\n",
++<<<<<<< HEAD
 +	    sess, ha->tgt.qla_tgt);
++=======
+ 	    sess, vha->vha_tgt.qla_tgt);
+ 
+ 	sess->conf_compl_supported = (fcport->flags & FCF_CONF_COMP_SUPPORTED);
+ 	BUILD_BUG_ON(sizeof(sess->port_name) != sizeof(fcport->port_name));
+ 	memcpy(sess->port_name, fcport->port_name, sizeof(sess->port_name));
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	list_add_tail(&sess->list, &vha->vp_fcports);
+ 	vha->vha_tgt.qla_tgt->sess_count++;
+ 	qlt_do_generation_tick(vha, &sess->generation);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04b,
+ 	    "qla_target(%d): %ssession for wwn %8phC (loop_id %d, "
+ 	    "s_id %x:%x:%x, confirmed completion %ssupported) added\n",
+ 	    vha->vp_idx, local ?  "local " : "", fcport->port_name,
+ 	    fcport->loop_id, sess->d_id.b.domain, sess->d_id.b.area,
+ 	    sess->d_id.b.al_pa, sess->conf_compl_supported ?  "" : "not ");
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  
 +	be_sid[0] = sess->s_id.b.domain;
 +	be_sid[1] = sess->s_id.b.area;
 +	be_sid[2] = sess->s_id.b.al_pa;
  	/*
  	 * Determine if this fc_port->port_name is allowed to access
  	 * target mode using explict NodeACLs+MappedLUNs, or using
@@@ -772,117 -941,53 +1079,152 @@@
  	 * is created.
  	 */
  	if (ha->tgt.tgt_ops->check_initiator_node_acl(vha,
 -	    &fcport->port_name[0], sess) < 0) {
 +	    &fcport->port_name[0], sess, &be_sid[0], fcport->loop_id) < 0) {
 +		kfree(sess);
  		return NULL;
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		/*
+ 		 * Take an extra reference to ->sess_kref here to handle fc_port
+ 		 * access across ->tgt.sess_lock reaquire.
+ 		 */
+ 		kref_get(&sess->sess_kref);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	}
 +	/*
 +	 * Take an extra reference to ->sess_kref here to handle qla_tgt_sess
 +	 * access across ->hardware_lock reaquire.
 +	 */
 +	kref_get(&sess->se_sess->sess_kref);
 +
 +	sess->conf_compl_supported = (fcport->flags & FCF_CONF_COMP_SUPPORTED);
 +	BUILD_BUG_ON(sizeof(sess->port_name) != sizeof(fcport->port_name));
 +	memcpy(sess->port_name, fcport->port_name, sizeof(sess->port_name));
 +
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	list_add_tail(&sess->sess_list_entry, &ha->tgt.qla_tgt->sess_list);
 +	ha->tgt.qla_tgt->sess_count++;
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04b,
 +	    "qla_target(%d): %ssession for wwn %8phC (loop_id %d, "
 +	    "s_id %x:%x:%x, confirmed completion %ssupported) added\n",
 +	    vha->vp_idx, local ?  "local " : "", fcport->port_name,
 +	    fcport->loop_id, sess->s_id.b.domain, sess->s_id.b.area,
 +	    sess->s_id.b.al_pa, sess->conf_compl_supported ?  "" : "not ");
  
  	return sess;
  }
  
  /*
++<<<<<<< HEAD
 + * Called from drivers/scsi/qla2xxx/qla_init.c:qla2x00_reg_remote_port()
 + */
 +void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_sess *sess;
 +	unsigned long flags;
 +
 +	if (!vha->hw->tgt.tgt_ops)
 +		return;
 +
 +	if (!tgt || (fcport->port_type != FCT_INITIATOR))
 +		return;
 +
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	if (tgt->tgt_stop) {
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +		return;
 +	}
 +	sess = qlt_find_sess_by_port_name(tgt, fcport->port_name);
 +	if (!sess) {
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +		mutex_lock(&ha->tgt.tgt_mutex);
 +		sess = qlt_create_sess(vha, fcport, false);
 +		mutex_unlock(&ha->tgt.tgt_mutex);
 +
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
 +	} else {
 +		kref_get(&sess->se_sess->sess_kref);
 +
 +		if (sess->deleted) {
 +			qlt_undelete_sess(sess);
 +
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04c,
 +			    "qla_target(%u): %ssession for port %8phC "
 +			    "(loop ID %d) reappeared\n", vha->vp_idx,
 +			    sess->local ? "local " : "", sess->port_name,
 +			    sess->loop_id);
 +
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf007,
 +			    "Reappeared sess %p\n", sess);
 +		}
 +		ha->tgt.tgt_ops->update_sess(sess, fcport->d_id, fcport->loop_id,
 +					(fcport->flags & FCF_CONF_COMP_SUPPORTED));
 +	}
 +
 +	if (sess && sess->local) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04d,
 +		    "qla_target(%u): local session for "
 +		    "port %8phC (loop ID %d) became global\n", vha->vp_idx,
 +		    fcport->port_name, sess->loop_id);
 +		sess->local = 0;
 +	}
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	ha->tgt.tgt_ops->put_sess(sess);
 +}
 +
 +void qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_sess *sess;
++=======
+  * max_gen - specifies maximum session generation
+  * at which this deletion requestion is still valid
+  */
+ void
+ qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport, int max_gen)
+ {
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct fc_port *sess = fcport;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	unsigned long flags;
  
  	if (!vha->hw->tgt.tgt_ops)
  		return;
  
 -	if (!tgt)
 +	if (!tgt || (fcport->port_type != FCT_INITIATOR))
  		return;
  
 -	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
  	if (tgt->tgt_stop) {
 -		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  		return;
  	}
++<<<<<<< HEAD
 +	sess = qlt_find_sess_by_port_name(tgt, fcport->port_name);
 +	if (!sess) {
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
++=======
+ 	if (!sess->se_sess) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (max_gen - sess->generation < 0) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf092,
+ 		    "Ignoring stale deletion request for se_sess %p / sess %p"
+ 		    " for port %8phC, req_gen %d, sess_gen %d\n",
+ 		    sess->se_sess, sess, sess->port_name, max_gen,
+ 		    sess->generation);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  		return;
  	}
  
@@@ -1238,9 -1359,73 +1578,9 @@@ static void qlt_24xx_retry_term_exchang
  	    FCP_TMF_CMPL, true);
  }
  
 -static int abort_cmd_for_tag(struct scsi_qla_host *vha, uint32_t tag)
 -{
 -	struct qla_tgt_sess_op *op;
 -	struct qla_tgt_cmd *cmd;
 -
 -	spin_lock(&vha->cmd_list_lock);
 -
 -	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
 -		if (tag == op->atio.u.isp24.exchange_addr) {
 -			op->aborted = true;
 -			spin_unlock(&vha->cmd_list_lock);
 -			return 1;
 -		}
 -	}
 -
 -	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
 -		if (tag == cmd->atio.u.isp24.exchange_addr) {
 -			cmd->aborted = 1;
 -			spin_unlock(&vha->cmd_list_lock);
 -			return 1;
 -		}
 -	}
 -
 -	spin_unlock(&vha->cmd_list_lock);
 -	return 0;
 -}
 -
 -/* drop cmds for the given lun
 - * XXX only looks for cmds on the port through which lun reset was recieved
 - * XXX does not go through the list of other port (which may have cmds
 - *     for the same lun)
 - */
 -static void abort_cmds_for_lun(struct scsi_qla_host *vha,
 -				uint32_t lun, uint8_t *s_id)
 -{
 -	struct qla_tgt_sess_op *op;
 -	struct qla_tgt_cmd *cmd;
 -	uint32_t key;
 -
 -	key = sid_to_key(s_id);
 -	spin_lock(&vha->cmd_list_lock);
 -	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
 -		uint32_t op_key;
 -		uint32_t op_lun;
 -
 -		op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
 -		op_lun = scsilun_to_int(
 -			(struct scsi_lun *)&op->atio.u.isp24.fcp_cmnd.lun);
 -		if (op_key == key && op_lun == lun)
 -			op->aborted = true;
 -	}
 -	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
 -		uint32_t cmd_key;
 -		uint32_t cmd_lun;
 -
 -		cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
 -		cmd_lun = scsilun_to_int(
 -			(struct scsi_lun *)&cmd->atio.u.isp24.fcp_cmnd.lun);
 -		if (cmd_key == key && cmd_lun == lun)
 -			cmd->aborted = 1;
 -	}
 -	spin_unlock(&vha->cmd_list_lock);
 -}
 -
  /* ha->hardware_lock supposed to be held on entry */
  static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,
- 	struct abts_recv_from_24xx *abts, struct qla_tgt_sess *sess)
+ 	struct abts_recv_from_24xx *abts, struct fc_port *sess)
  {
  	struct qla_hw_data *ha = vha->hw;
  	struct se_session *se_sess = sess->se_sess;
@@@ -1260,10 -1446,21 +1601,10 @@@
  			break;
  		}
  	}
- 	spin_unlock(&se_sess->sess_cmd_lock);
+ 	spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
  
 -	/* cmd not in LIO lists, look in qla list */
 -	if (!found_lun) {
 -		if (abort_cmd_for_tag(vha, abts->exchange_addr_to_abort)) {
 -			/* send TASK_ABORT response immediately */
 -			qlt_24xx_send_abts_resp(vha, abts, FCP_TMF_CMPL, false);
 -			return 0;
 -		} else {
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf081,
 -			    "unable to find cmd in driver or LIO for tag 0x%x\n",
 -			    abts->exchange_addr_to_abort);
 -			return -ENOENT;
 -		}
 -	}
 +	if (!found_lun)
 +		return -ENOENT;
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00f,
  	    "qla_target(%d): task abort (tag=%d)\n",
@@@ -2292,99 -3015,122 +2633,117 @@@ done
  	return;
  }
  
 -static void qlt_init_term_exchange(struct scsi_qla_host *vha)
 -{
 -	struct list_head free_list;
 -	struct qla_tgt_cmd *cmd, *tcmd;
 -
 -	vha->hw->tgt.leak_exchg_thresh_hold =
 -	    (vha->hw->cur_fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;
 -
 -	cmd = tcmd = NULL;
 -	if (!list_empty(&vha->hw->tgt.q_full_list)) {
 -		INIT_LIST_HEAD(&free_list);
 -		list_splice_init(&vha->hw->tgt.q_full_list, &free_list);
 -
 -		list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
 -			list_del(&cmd->cmd_list);
 -			/* This cmd was never sent to TCM.  There is no need
 -			 * to schedule free or call free_cmd
 -			 */
 -			qlt_free_cmd(cmd);
 -			vha->hw->tgt.num_qfull_cmds_alloc--;
 -		}
 -	}
 -	vha->hw->tgt.num_qfull_cmds_dropped = 0;
 -}
 -
 -static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)
 -{
 -	uint32_t total_leaked;
 -
 -	total_leaked = vha->hw->tgt.num_qfull_cmds_dropped;
 -
 -	if (vha->hw->tgt.leak_exchg_thresh_hold &&
 -	    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {
 -
 -		ql_dbg(ql_dbg_tgt, vha, 0xe079,
 -		    "Chip reset due to exchange starvation: %d/%d.\n",
 -		    total_leaked, vha->hw->cur_fw_xcb_count);
 -
 -		if (IS_P3P_TYPE(vha->hw))
 -			set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
 -		else
 -			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
 -		qla2xxx_wake_dpc(vha);
 -	}
 -
 -}
 -
 -int qlt_abort_cmd(struct qla_tgt_cmd *cmd)
 -{
 -	struct qla_tgt *tgt = cmd->tgt;
 -	struct scsi_qla_host *vha = tgt->vha;
 -	struct se_cmd *se_cmd = &cmd->se_cmd;
 -	unsigned long flags;
 -
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
 -	    "qla_target(%d): terminating exchange for aborted cmd=%p "
 -	    "(se_cmd=%p, tag=%llu)", vha->vp_idx, cmd, &cmd->se_cmd,
 -	    se_cmd->tag);
 -
 -	spin_lock_irqsave(&cmd->cmd_lock, flags);
 -	if (cmd->aborted) {
 -		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
 -		/*
 -		 * It's normal to see 2 calls in this path:
 -		 *  1) XFER Rdy completion + CMD_T_ABORT
 -		 *  2) TCM TMR - drain_state_list
 -		 */
 -	        ql_dbg(ql_dbg_tgt_mgt, vha, 0xffff,
 -			"multiple abort. %p transport_state %x, t_state %x,"
 -			" se_cmd_flags %x \n", cmd, cmd->se_cmd.transport_state,
 -			cmd->se_cmd.t_state,cmd->se_cmd.se_cmd_flags);
 -		return EIO;
 -	}
 -	cmd->aborted = 1;
 -	cmd->trc_flags |= TRC_ABORT;
 -	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
 -
 -	qlt_send_term_exchange(vha, cmd, &cmd->atio, 0, 1);
 -	return 0;
 -}
 -EXPORT_SYMBOL(qlt_abort_cmd);
 -
  void qlt_free_cmd(struct qla_tgt_cmd *cmd)
  {
++<<<<<<< HEAD
++=======
+ 	struct fc_port *sess = cmd->sess;
+ 
+ 	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,
+ 	    "%s: se_cmd[%p] ox_id %04x\n",
+ 	    __func__, &cmd->se_cmd,
+ 	    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 
+ 	BUG_ON(cmd->cmd_in_wq);
+ 
+ 	if (cmd->sg_mapped)
+ 		qlt_unmap_sg(cmd->vha, cmd);
+ 
+ 	if (!cmd->q_full)
+ 		qlt_decr_num_pend_cmds(cmd->vha);
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	BUG_ON(cmd->sg_mapped);
 -	cmd->jiffies_at_free = get_jiffies_64();
 +
  	if (unlikely(cmd->free_sg))
  		kfree(cmd->sg);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
 +}
 +EXPORT_SYMBOL(qlt_free_cmd);
  
 -	if (!sess || !sess->se_sess) {
 -		WARN_ON(1);
 -		return;
 +/* ha->hardware_lock supposed to be held on entry */
 +static int qlt_prepare_srr_ctio(struct scsi_qla_host *vha,
 +	struct qla_tgt_cmd *cmd, void *ctio)
 +{
 +	struct qla_tgt_srr_ctio *sc;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_srr_imm *imm;
 +
 +	tgt->ctio_srr_id++;
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf019,
 +	    "qla_target(%d): CTIO with SRR status received\n", vha->vp_idx);
 +
 +	if (!ctio) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf055,
 +		    "qla_target(%d): SRR CTIO, but ctio is NULL\n",
 +		    vha->vp_idx);
 +		return -EINVAL;
  	}
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 +
 +	sc = kzalloc(sizeof(*sc), GFP_ATOMIC);
 +	if (sc != NULL) {
 +		sc->cmd = cmd;
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		sc->srr_id = tgt->ctio_srr_id;
 +		list_add_tail(&sc->srr_list_entry,
 +		    &tgt->srr_ctio_list);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01a,
 +		    "CTIO SRR %p added (id %d)\n", sc, sc->srr_id);
 +		if (tgt->imm_srr_id == tgt->ctio_srr_id) {
 +			int found = 0;
 +			list_for_each_entry(imm, &tgt->srr_imm_list,
 +			    srr_list_entry) {
 +				if (imm->srr_id == sc->srr_id) {
 +					found = 1;
 +					break;
 +				}
 +			}
 +			if (found) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01b,
 +				    "Scheduling srr work\n");
 +				schedule_work(&tgt->srr_work);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf056,
 +				    "qla_target(%d): imm_srr_id "
 +				    "== ctio_srr_id (%d), but there is no "
 +				    "corresponding SRR IMM, deleting CTIO "
 +				    "SRR %p\n", vha->vp_idx,
 +				    tgt->ctio_srr_id, sc);
 +				list_del(&sc->srr_list_entry);
 +				spin_unlock(&tgt->srr_lock);
 +
 +				kfree(sc);
 +				return -EINVAL;
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
 +	} else {
 +		struct qla_tgt_srr_imm *ti;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf057,
 +		    "qla_target(%d): Unable to allocate SRR CTIO entry\n",
 +		    vha->vp_idx);
 +		spin_lock(&tgt->srr_lock);
 +		list_for_each_entry_safe(imm, ti, &tgt->srr_imm_list,
 +		    srr_list_entry) {
 +			if (imm->srr_id == tgt->ctio_srr_id) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01c,
 +				    "IMM SRR %p deleted (id %d)\n",
 +				    imm, imm->srr_id);
 +				list_del(&imm->srr_list_entry);
 +				qlt_reject_free_srr_imm(vha, imm, 1);
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
 +
 +		return -ENOMEM;
 +	}
 +
 +	return 0;
  }
 -EXPORT_SYMBOL(qlt_free_cmd);
  
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
@@@ -2622,13 -3470,12 +2981,18 @@@ static struct fc_port *qlt_make_local_s
  /*
   * Process context for I/O path into tcm_qla2xxx code
   */
 -static void __qlt_do_work(struct qla_tgt_cmd *cmd)
 +static void qlt_do_work(struct work_struct *work)
  {
 +	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
  	scsi_qla_host_t *vha = cmd->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_sess *sess = NULL;
++=======
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct fc_port *sess = cmd->sess;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	struct atio_from_isp *atio = &cmd->atio;
  	unsigned char *cdb;
  	unsigned long flags;
@@@ -2706,7 -3524,9 +3070,13 @@@
  	/*
  	 * Drop extra session reference from qla_tgt_handle_cmd_for_atio*(
  	 */
++<<<<<<< HEAD
++	ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	return;
  
  out_term:
@@@ -2715,12 -3535,134 +3085,136 @@@
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
 -	cmd->trc_flags |= TRC_DO_WORK_ERR;
  	spin_lock_irqsave(&ha->hardware_lock, flags);
 -	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1, 0);
 -
 -	qlt_decr_num_pend_cmds(vha);
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 +	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ static void qlt_do_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&cmd->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	__qlt_do_work(cmd);
+ }
+ 
+ static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
+ 				       struct fc_port *sess,
+ 				       struct atio_from_isp *atio)
+ {
+ 	struct se_session *se_sess = sess->se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return NULL;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 	cmd->state = QLA_TGT_STATE_NEW;
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	qlt_incr_num_pend_cmds(vha);
+ 	cmd->vha = vha;
+ 	cmd->se_cmd.map_tag = tag;
+ 	cmd->sess = sess;
+ 	cmd->loop_id = sess->loop_id;
+ 	cmd->conf_compl_supported = sess->conf_compl_supported;
+ 
+ 	cmd->trc_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
+ 
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 
+ 	return cmd;
+ }
+ 
+ static void qlt_send_busy(struct scsi_qla_host *, struct atio_from_isp *,
+ 			  uint16_t);
+ 
+ static void qlt_create_sess_from_atio(struct work_struct *work)
+ {
+ 	struct qla_tgt_sess_op *op = container_of(work,
+ 					struct qla_tgt_sess_op, work);
+ 	scsi_qla_host_t *vha = op->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&op->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	if (op->aborted) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+ 		    "sess_op with tag %u is aborted\n",
+ 		    op->atio.u.isp24.exchange_addr);
+ 		goto out_term;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+ 	    "qla_target(%d): Unable to find wwn login"
+ 	    " (s_id %x:%x:%x), trying to create it manually\n",
+ 	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
+ 
+ 	if (op->atio.u.raw.entry_count > 1) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+ 		    "Dropping multy entry atio %p\n", &op->atio);
+ 		goto out_term;
+ 	}
+ 
+ 	sess = qlt_make_local_sess(vha, s_id);
+ 	/* sess has an extra creation ref. */
+ 
+ 	if (!sess)
+ 		goto out_term;
+ 	/*
+ 	 * Now obtain a pre-allocated session tag using the original op->atio
+ 	 * packet header, and dispatch into __qlt_do_work() using the existing
+ 	 * process context.
+ 	 */
+ 	cmd = qlt_get_tag(vha, sess, &op->atio);
+ 	if (!cmd) {
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
+ 		qlt_send_busy(vha, &op->atio, SAM_STAT_BUSY);
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 		kfree(op);
+ 		return;
+ 	}
+ 	/*
+ 	 * __qlt_do_work() will call qlt_put_sess() to release
+ 	 * the extra reference taken above by qlt_make_local_sess()
+ 	 */
+ 	__qlt_do_work(cmd);
+ 	kfree(op);
+ 	return;
+ 
+ out_term:
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	qlt_send_term_exchange(vha, NULL, &op->atio, 1, 0);
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 	kfree(op);
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -2728,19 -3670,57 +3222,31 @@@ static int qlt_handle_cmd_for_atio(stru
  	struct atio_from_isp *atio)
  {
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
++=======
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct fc_port *sess;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
  
  	if (unlikely(tgt->tgt_stop)) {
 -		ql_dbg(ql_dbg_io, vha, 0x3061,
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf021,
  		    "New command while device %p is shutting down\n", tgt);
  		return -EFAULT;
  	}
  
 -	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);
 -	if (unlikely(!sess)) {
 -		struct qla_tgt_sess_op *op = kzalloc(sizeof(struct qla_tgt_sess_op),
 -						     GFP_ATOMIC);
 -		if (!op)
 -			return -ENOMEM;
 -
 -		memcpy(&op->atio, atio, sizeof(*atio));
 -		op->vha = vha;
 -
 -		spin_lock(&vha->cmd_list_lock);
 -		list_add_tail(&op->cmd_list, &vha->qla_sess_op_cmd_list);
 -		spin_unlock(&vha->cmd_list_lock);
 -
 -		INIT_WORK(&op->work, qlt_create_sess_from_atio);
 -		queue_work(qla_tgt_wq, &op->work);
 -		return 0;
 -	}
 -
 -	/* Another WWN used to have our s_id. Our PLOGI scheduled its
 -	 * session deletion, but it's still in sess_del_work wq */
 -	if (sess->deleted == QLA_SESS_DELETION_IN_PROGRESS) {
 -		ql_dbg(ql_dbg_io, vha, 0x3061,
 -		    "New command while old session %p is being deleted\n",
 -		    sess);
 -		return -EFAULT;
 -	}
 -
 -	/*
 -	 * Do kref_get() before returning + dropping qla_hw_data->hardware_lock.
 -	 */
 -	kref_get(&sess->sess_kref);
 -
 -	cmd = qlt_get_tag(vha, sess, atio);
 +	cmd = kmem_cache_zalloc(qla_tgt_cmd_cachep, GFP_ATOMIC);
  	if (!cmd) {
 -		ql_dbg(ql_dbg_io, vha, 0x3062,
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05e,
  		    "qla_target(%d): Allocation of cmd failed\n", vha->vp_idx);
++<<<<<<< HEAD
++=======
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  		return -ENOMEM;
  	}
  
@@@ -2870,11 -3801,12 +3376,11 @@@ static int qlt_handle_task_mgmt(struct 
  	struct atio_from_isp *a = (struct atio_from_isp *)iocb;
  	struct qla_hw_data *ha = vha->hw;
  	struct qla_tgt *tgt;
- 	struct qla_tgt_sess *sess;
+ 	struct fc_port *sess;
  	uint32_t lun, unpacked_lun;
  	int fn;
 -	unsigned long flags;
  
 -	tgt = vha->vha_tgt.qla_tgt;
 +	tgt = ha->tgt.qla_tgt;
  
  	lun = a->u.isp24.fcp_cmnd.lun;
  	fn = a->u.isp24.fcp_cmnd.task_mgmt_flags;
@@@ -2938,8 -3878,9 +3444,8 @@@ static int qlt_abort_task(struct scsi_q
  	struct imm_ntfy_from_isp *iocb)
  {
  	struct qla_hw_data *ha = vha->hw;
- 	struct qla_tgt_sess *sess;
+ 	struct fc_port *sess;
  	int loop_id;
 -	unsigned long flags;
  
  	loop_id = GET_TARGET_ID(ha, (struct atio_from_isp *)iocb);
  
@@@ -2955,14 -3899,152 +3461,158 @@@
  	return __qlt_abort_task(vha, iocb, sess);
  }
  
++<<<<<<< HEAD
++=======
+ void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
+ {
+ 	if (fcport->tgt_session) {
+ 		if (rc != MBS_COMMAND_COMPLETE) {
+ 			ql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,
+ 				"%s: se_sess %p / sess %p from"
+ 				" port %8phC loop_id %#04x s_id %02x:%02x:%02x"
+ 				" LOGO failed: %#x\n",
+ 				__func__,
+ 				fcport->se_sess,
+ 				fcport->tgt_session,
+ 				fcport->port_name, fcport->loop_id,
+ 				fcport->d_id.b.domain, fcport->d_id.b.area,
+ 				fcport->d_id.b.al_pa, rc);
+ 		}
+ 
+ 		fcport->logout_completed = 1;
+ 	}
+ }
+ 
+ /*
+ * ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)
+ *
+ * Schedules sessions with matching port_id/loop_id but different wwn for
+ * deletion. Returns existing session with matching wwn if present.
+ * Null otherwise.
+ */
+ static struct fc_port *
+ qlt_find_sess_invalidate_other(struct qla_tgt *tgt, uint64_t wwn,
+     port_id_t port_id, uint16_t loop_id, struct fc_port **conflict_sess)
+ {
+ 	struct fc_port *sess = NULL, *other_sess;
+ 	uint64_t other_wwn;
+ 	scsi_qla_host_t *vha = tgt->vha;
+ 
+ 	*conflict_sess = NULL;
+ 
+ 	list_for_each_entry(other_sess, &vha->vp_fcports, list) {
+ 
+ 		other_wwn = wwn_to_u64(other_sess->port_name);
+ 
+ 		if (wwn == other_wwn) {
+ 			WARN_ON(sess);
+ 			sess = other_sess;
+ 			continue;
+ 		}
+ 
+ 		/* find other sess with nport_id collision */
+ 		if (port_id.b24 == other_sess->d_id.b24) {
+ 			if (loop_id != other_sess->loop_id) {
+ 				ql_dbg(ql_dbg_tgt_tmr, tgt->vha, 0x1000c,
+ 				    "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 				    other_sess, other_sess->loop_id, other_wwn);
+ 
+ 				/*
+ 				 * logout_on_delete is set by default, but another
+ 				 * session that has the same s_id/loop_id combo
+ 				 * might have cleared it when requested this session
+ 				 * deletion, so don't touch it
+ 				 */
+ 				qlt_schedule_sess_for_deletion(other_sess, true);
+ 			} else {
+ 				/*
+ 				 * Another wwn used to have our s_id/loop_id
+ 				 * kill the session, but don't free the loop_id
+ 				 */
+ 				other_sess->keep_nport_handle = 1;
+ 				*conflict_sess = other_sess;
+ 				qlt_schedule_sess_for_deletion(other_sess,
+ 				    true);
+ 			}
+ 			continue;
+ 		}
+ 
+ 		/* find other sess with nport handle collision */
+ 		if (loop_id == other_sess->loop_id) {
+ 			ql_dbg(ql_dbg_tgt_tmr, tgt->vha, 0x1000d,
+ 			       "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 			       other_sess, other_sess->loop_id, other_wwn);
+ 
+ 			/* Same loop_id but different s_id
+ 			 * Ok to kill and logout */
+ 			qlt_schedule_sess_for_deletion(other_sess, true);
+ 		}
+ 	}
+ 
+ 	return sess;
+ }
+ 
+ /* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */
+ static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 	uint32_t key;
+ 	int count = 0;
+ 
+ 	key = (((u32)s_id->b.domain << 16) |
+ 	       ((u32)s_id->b.area   <<  8) |
+ 	       ((u32)s_id->b.al_pa));
+ 
+ 	spin_lock(&vha->cmd_list_lock);
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		if (op_key == key) {
+ 			op->aborted = true;
+ 			count++;
+ 		}
+ 	}
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		uint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
+ 		if (cmd_key == key) {
+ 			cmd->aborted = 1;
+ 			count++;
+ 		}
+ 	}
+ 	spin_unlock(&vha->cmd_list_lock);
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
  static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
  	struct imm_ntfy_from_isp *iocb)
  {
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
 +	int res = 0;
++=======
+ 	struct fc_port *sess = NULL, *conflict_sess = NULL;
+ 	uint64_t wwn;
+ 	port_id_t port_id;
+ 	uint16_t loop_id;
+ 	uint16_t wd3_lo;
+ 	int res = 0;
+ 	struct qlt_plogi_ack_t *pla;
+ 	unsigned long flags;
+ 
+ 	wwn = wwn_to_u64(iocb->u.isp24.port_name);
+ 
+ 	port_id.b.domain = iocb->u.isp24.port_id[2];
+ 	port_id.b.area   = iocb->u.isp24.port_id[1];
+ 	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
+ 	port_id.b.rsvd_1 = 0;
+ 
+ 	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
  	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
@@@ -3592,13 -4347,16 +4242,18 @@@ static void qlt_send_busy(struct scsi_q
  	struct ctio7_to_24xx *ctio24;
  	struct qla_hw_data *ha = vha->hw;
  	request_t *pkt;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess = NULL;
++=======
+ 	struct fc_port *sess = NULL;
+ 	unsigned long flags;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    atio->u.isp24.fcp_hdr.s_id);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  	if (!sess) {
 -		qlt_send_term_exchange(vha, NULL, atio, 1, 0);
 -		return 0;
 +		qlt_send_term_exchange(vha, NULL, atio, 1);
 +		return;
  	}
  	/* Sending marker isn't necessary, since we called from ISR */
  
@@@ -3635,6 -4394,189 +4290,192 @@@
  	/* Memory Barrier */
  	wmb();
  	qla2x00_start_iocbs(vha, vha->req);
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ /*
+  * This routine is used to allocate a command for either a QFull condition
+  * (ie reply SAM_STAT_BUSY) or to terminate an exchange that did not go
+  * out previously.
+  */
+ static void
+ qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull)
+ {
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct se_session *se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	if (unlikely(tgt->tgt_stop)) {
+ 		ql_dbg(ql_dbg_io, vha, 0x300a,
+ 			"New command while device %p is shutting down\n", tgt);
+ 		return;
+ 	}
+ 
+ 	if ((vha->hw->tgt.num_qfull_cmds_alloc + 1) > MAX_QFULL_CMDS_ALLOC) {
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0x3068,
+ 			"qla_target(%d): %s: QFull CMD dropped[%d]\n",
+ 			vha->vp_idx, __func__,
+ 			vha->hw->tgt.num_qfull_cmds_dropped);
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	sess = ha->tgt.tgt_ops->find_sess_by_s_id
+ 		(vha, atio->u.isp24.fcp_hdr.s_id);
+ 	if (!sess)
+ 		return;
+ 
+ 	se_sess = sess->se_sess;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	if (!cmd) {
+ 		ql_dbg(ql_dbg_io, vha, 0x3009,
+ 			"qla_target(%d): %s: Allocation of cmd failed\n",
+ 			vha->vp_idx, __func__);
+ 
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 
+ 	qlt_incr_num_pend_cmds(vha);
+ 	INIT_LIST_HEAD(&cmd->cmd_list);
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	cmd->vha = vha;
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 	cmd->q_full = 1;
+ 
+ 	if (qfull) {
+ 		cmd->q_full = 1;
+ 		/* NOTE: borrowing the state field to carry the status */
+ 		cmd->state = status;
+ 	} else
+ 		cmd->term_exchg = 1;
+ 
+ 	list_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);
+ 
+ 	vha->hw->tgt.num_qfull_cmds_alloc++;
+ 	if (vha->hw->tgt.num_qfull_cmds_alloc >
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc)
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc =
+ 			vha->hw->tgt.num_qfull_cmds_alloc;
+ }
+ 
+ int
+ qlt_free_qfull_cmds(struct scsi_qla_host *vha)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 	struct list_head free_list;
+ 	int rc = 0;
+ 
+ 	if (list_empty(&ha->tgt.q_full_list))
+ 		return 0;
+ 
+ 	INIT_LIST_HEAD(&free_list);
+ 
+ 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
+ 
+ 	if (list_empty(&ha->tgt.q_full_list)) {
+ 		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &ha->tgt.q_full_list, cmd_list) {
+ 		if (cmd->q_full)
+ 			/* cmd->state is a borrowed field to hold status */
+ 			rc = __qlt_send_busy(vha, &cmd->atio, cmd->state);
+ 		else if (cmd->term_exchg)
+ 			rc = __qlt_send_term_exchange(vha, NULL, &cmd->atio);
+ 
+ 		if (rc == -ENOMEM)
+ 			break;
+ 
+ 		if (cmd->q_full)
+ 			ql_dbg(ql_dbg_io, vha, 0x3006,
+ 			    "%s: busy sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else if (cmd->term_exchg)
+ 			ql_dbg(ql_dbg_io, vha, 0x3007,
+ 			    "%s: Term exchg sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else
+ 			ql_dbg(ql_dbg_io, vha, 0x3008,
+ 			    "%s: Unexpected cmd in QFull list %p\n", __func__,
+ 			    cmd);
+ 
+ 		list_del(&cmd->cmd_list);
+ 		list_add_tail(&cmd->cmd_list, &free_list);
+ 
+ 		/* piggy back on hardware_lock for protection */
+ 		vha->hw->tgt.num_qfull_cmds_alloc--;
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ 
+ 	cmd = NULL;
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 		list_del(&cmd->cmd_list);
+ 		/* This cmd was never sent to TCM.  There is no need
+ 		 * to schedule free or call free_cmd
+ 		 */
+ 		qlt_free_cmd(cmd);
+ 	}
+ 	return rc;
+ }
+ 
+ static void
+ qlt_send_busy(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status)
+ {
+ 	int rc = 0;
+ 
+ 	rc = __qlt_send_busy(vha, atio, status);
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, atio, status, 1);
+ }
+ 
+ static int
+ qlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t status;
+ 
+ 	if (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))
+ 		return 0;
+ 
+ 	status = temp_sam_status;
+ 	qlt_send_busy(vha, atio, status);
+ 	return 1;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -4075,11 -5004,10 +4916,15 @@@ static fc_port_t *qlt_get_port_database
  }
  
  /* Must be called under tgt_mutex */
- static struct qla_tgt_sess *qlt_make_local_sess(struct scsi_qla_host *vha,
+ static struct fc_port *qlt_make_local_sess(struct scsi_qla_host *vha,
  	uint8_t *s_id)
  {
++<<<<<<< HEAD
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt_sess *sess = NULL;
++=======
+ 	struct fc_port *sess = NULL;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	fc_port_t *fcport = NULL;
  	int rc, global_resets;
  	uint16_t loop_id = 0;
@@@ -4123,7 -5067,8 +4968,12 @@@ retry
  
  	sess = qlt_create_sess(vha, fcport, true);
  
++<<<<<<< HEAD
 +	kfree(fcport);
++=======
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	return sess;
  }
  
@@@ -4132,8 -5077,8 +4982,13 @@@ static void qlt_abort_work(struct qla_t
  {
  	struct scsi_qla_host *vha = tgt->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess = NULL;
 +	unsigned long flags;
++=======
+ 	struct fc_port *sess = NULL;
+ 	unsigned long flags = 0, flags2 = 0;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	uint32_t be_s_id;
  	uint8_t s_id[3];
  	int rc;
@@@ -4171,15 -5121,20 +5026,27 @@@
  	if (rc != 0)
  		goto out_term;
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +
 +	ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 	if (sess)
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	return;
  
 -out_term2:
 -	spin_lock_irqsave(&ha->hardware_lock, flags);
 -
  out_term:
  	qlt_24xx_send_abts_resp(vha, &prm->abts, FCP_TMF_REJECTED, false);
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  static void qlt_tmr_work(struct qla_tgt *tgt,
@@@ -4226,16 -5184,16 +5093,27 @@@
  	rc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
  	if (rc != 0)
  		goto out_term;
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
  	ha->tgt.tgt_ops->put_sess(sess);
++<<<<<<< HEAD
 +	return;
 +
 +out_term:
 +	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 	return;
+ 
+ out_term:
+ 	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1, 0);
+ 	if (sess)
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  static void qlt_sess_work_fn(struct work_struct *work)
@@@ -5063,8 -6120,18 +5940,21 @@@ int __init qlt_init(void
  	if (!qla_tgt_mgmt_cmd_cachep) {
  		ql_log(ql_log_fatal, NULL, 0xe06d,
  		    "kmem_cache_create for qla_tgt_mgmt_cmd_cachep failed\n");
++<<<<<<< HEAD
++=======
+ 		return -ENOMEM;
+ 	}
+ 
+ 	qla_tgt_plogi_cachep = kmem_cache_create("qla_tgt_plogi_cachep",
+ 	    sizeof(struct qlt_plogi_ack_t), __alignof__(struct qlt_plogi_ack_t),
+ 	    0, NULL);
+ 
+ 	if (!qla_tgt_plogi_cachep) {
+ 		ql_log(ql_log_fatal, NULL, 0xe06d,
+ 		    "kmem_cache_create for qla_tgt_plogi_cachep failed\n");
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  		ret = -ENOMEM;
 -		goto out_mgmt_cmd_cachep;
 +		goto out;
  	}
  
  	qla_tgt_mgmt_cmd_mempool = mempool_create(25, mempool_alloc_slab,
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,9c35ba15c687..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -118,67 -118,6 +118,70 @@@
  			 ? le16_to_cpu((iocb)->u.isp2x.target.extended)	\
  			 : (uint16_t)(iocb)->u.isp2x.target.id.standard)
  
++<<<<<<< HEAD
 +#ifndef IMMED_NOTIFY_TYPE
 +#define IMMED_NOTIFY_TYPE 0x0D		/* Immediate notify entry. */
 +/*
 + * ISP queue -	immediate notify entry structure definition.
 + *		This is sent by the ISP to the Target driver.
 + *		This IOCB would have report of events sent by the
 + *		initiator, that needs to be handled by the target
 + *		driver immediately.
 + */
 +struct imm_ntfy_from_isp {
 +	uint8_t	 entry_type;		    /* Entry type. */
 +	uint8_t	 entry_count;		    /* Entry count. */
 +	uint8_t	 sys_define;		    /* System defined. */
 +	uint8_t	 entry_status;		    /* Entry Status. */
 +	union {
 +		struct {
 +			uint32_t sys_define_2; /* System defined. */
 +			target_id_t target;
 +			uint16_t lun;
 +			uint8_t  target_id;
 +			uint8_t  reserved_1;
 +			uint16_t status_modifier;
 +			uint16_t status;
 +			uint16_t task_flags;
 +			uint16_t seq_id;
 +			uint16_t srr_rx_id;
 +			uint32_t srr_rel_offs;
 +			uint16_t srr_ui;
 +#define SRR_IU_DATA_IN	0x1
 +#define SRR_IU_DATA_OUT	0x5
 +#define SRR_IU_STATUS	0x7
 +			uint16_t srr_ox_id;
 +			uint8_t reserved_2[28];
 +		} isp2x;
 +		struct {
 +			uint32_t reserved;
 +			uint16_t nport_handle;
 +			uint16_t reserved_2;
 +			uint16_t flags;
 +#define NOTIFY24XX_FLAGS_GLOBAL_TPRLO   BIT_1
 +#define NOTIFY24XX_FLAGS_PUREX_IOCB     BIT_0
 +			uint16_t srr_rx_id;
 +			uint16_t status;
 +			uint8_t  status_subcode;
 +			uint8_t  fw_handle;
 +			uint32_t exchange_address;
 +			uint32_t srr_rel_offs;
 +			uint16_t srr_ui;
 +			uint16_t srr_ox_id;
 +			uint8_t  reserved_4[19];
 +			uint8_t  vp_index;
 +			uint32_t reserved_5;
 +			uint8_t  port_id[3];
 +			uint8_t  reserved_6;
 +		} isp24;
 +	} u;
 +	uint16_t reserved_7;
 +	uint16_t ox_id;
 +} __packed;
 +#endif
 +
++=======
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  #ifndef NOTIFY_ACK_TYPE
  #define NOTIFY_ACK_TYPE 0x0E	  /* Notify acknowledge entry. */
  /*
@@@ -645,18 -670,18 +648,30 @@@ struct qla_tgt_func_tmpl 
  			uint32_t);
  	void (*free_cmd)(struct qla_tgt_cmd *);
  	void (*free_mcmd)(struct qla_tgt_mgmt_cmd *);
- 	void (*free_session)(struct qla_tgt_sess *);
+ 	void (*free_session)(struct fc_port *);
  
  	int (*check_initiator_node_acl)(struct scsi_qla_host *, unsigned char *,
++<<<<<<< HEAD
 +					void *, uint8_t *, uint16_t);
 +	void (*update_sess)(struct qla_tgt_sess *, port_id_t, uint16_t, bool);
 +	struct qla_tgt_sess *(*find_sess_by_loop_id)(struct scsi_qla_host *,
++=======
+ 					struct fc_port *);
+ 	void (*update_sess)(struct fc_port *, port_id_t, uint16_t, bool);
+ 	struct fc_port *(*find_sess_by_loop_id)(struct scsi_qla_host *,
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  						const uint16_t);
- 	struct qla_tgt_sess *(*find_sess_by_s_id)(struct scsi_qla_host *,
+ 	struct fc_port *(*find_sess_by_s_id)(struct scsi_qla_host *,
  						const uint8_t *);
++<<<<<<< HEAD
 +	void (*clear_nacl_from_fcport_map)(struct qla_tgt_sess *);
 +	void (*put_sess)(struct qla_tgt_sess *);
 +	void (*shutdown_sess)(struct qla_tgt_sess *);
++=======
+ 	void (*clear_nacl_from_fcport_map)(struct fc_port *);
+ 	void (*put_sess)(struct fc_port *);
+ 	void (*shutdown_sess)(struct fc_port *);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  };
  
  int qla2x00_wait_for_hba_online(struct scsi_qla_host *);
@@@ -805,33 -814,49 +817,78 @@@ struct qla_tgt 
  	struct list_head tgt_list_entry;
  };
  
++<<<<<<< HEAD
 +/*
 + * Equivilant to IT Nexus (Initiator-Target)
 + */
 +struct qla_tgt_sess {
 +	uint16_t loop_id;
 +	port_id_t s_id;
 +
 +	unsigned int conf_compl_supported:1;
 +	unsigned int deleted:1;
 +	unsigned int local:1;
 +
 +	struct se_session *se_sess;
 +	struct scsi_qla_host *vha;
 +	struct qla_tgt *tgt;
 +
 +	struct list_head sess_list_entry;
 +	unsigned long expires;
 +	struct list_head del_list_entry;
 +
 +	uint8_t port_name[WWN_SIZE];
 +	struct work_struct free_work;
 +};
 +
 +struct qla_tgt_cmd {
 +	struct qla_tgt_sess *sess;
++=======
+ struct qla_tgt_sess_op {
+ 	struct scsi_qla_host *vha;
+ 	uint32_t chip_reset;
+ 	struct atio_from_isp atio;
+ 	struct work_struct work;
+ 	struct list_head cmd_list;
+ 	bool aborted;
+ };
+ 
+ enum qla_sess_deletion {
+ 	QLA_SESS_DELETION_NONE		= 0,
+ 	QLA_SESS_DELETION_PENDING	= 1, /* hopefully we can get rid of
+ 					      * this one */
+ 	QLA_SESS_DELETION_IN_PROGRESS	= 2,
+ };
+ 
+ enum trace_flags {
+ 	TRC_NEW_CMD = BIT_0,
+ 	TRC_DO_WORK = BIT_1,
+ 	TRC_DO_WORK_ERR = BIT_2,
+ 	TRC_XFR_RDY = BIT_3,
+ 	TRC_XMIT_DATA = BIT_4,
+ 	TRC_XMIT_STATUS = BIT_5,
+ 	TRC_SRR_RSP =  BIT_6,
+ 	TRC_SRR_XRDY = BIT_7,
+ 	TRC_SRR_TERM = BIT_8,
+ 	TRC_SRR_CTIO = BIT_9,
+ 	TRC_FLUSH = BIT_10,
+ 	TRC_CTIO_ERR = BIT_11,
+ 	TRC_CTIO_DONE = BIT_12,
+ 	TRC_CTIO_ABORTED =  BIT_13,
+ 	TRC_CTIO_STRANGE= BIT_14,
+ 	TRC_CMD_DONE = BIT_15,
+ 	TRC_CMD_CHK_STOP = BIT_16,
+ 	TRC_CMD_FREE = BIT_17,
+ 	TRC_DATA_IN = BIT_18,
+ 	TRC_ABORT = BIT_19,
+ };
+ 
+ struct qla_tgt_cmd {
+ 	struct se_cmd se_cmd;
+ 	struct fc_port *sess;
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	int state;
 +	struct se_cmd se_cmd;
  	struct work_struct free_work;
  	struct work_struct work;
  	/* Sense buffer that will be mapped into outgoing status */
@@@ -875,9 -918,9 +932,9 @@@ struct qla_tgt_sess_work_param 
  };
  
  struct qla_tgt_mgmt_cmd {
 -	uint16_t tmr_func;
 +	uint8_t tmr_func;
  	uint8_t fc_tm_rsp;
- 	struct qla_tgt_sess *sess;
+ 	struct fc_port *sess;
  	struct se_cmd se_cmd;
  	struct work_struct free_work;
  	unsigned int flags;
@@@ -932,14 -968,12 +989,18 @@@ void qlt_disable_vha(struct scsi_qla_ho
   */
  extern int qlt_add_target(struct qla_hw_data *, struct scsi_qla_host *);
  extern int qlt_remove_target(struct qla_hw_data *, struct scsi_qla_host *);
 -extern int qlt_lport_register(void *, u64, u64, u64,
 -			int (*callback)(struct scsi_qla_host *, void *, u64, u64));
 +extern int qlt_lport_register(struct qla_tgt_func_tmpl *, u64,
 +			int (*callback)(struct scsi_qla_host *), void *);
  extern void qlt_lport_deregister(struct scsi_qla_host *);
++<<<<<<< HEAD
 +extern void qlt_unreg_sess(struct qla_tgt_sess *);
++=======
+ extern void qlt_unreg_sess(struct fc_port *);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  extern void qlt_fc_port_added(struct scsi_qla_host *, fc_port_t *);
 -extern void qlt_fc_port_deleted(struct scsi_qla_host *, fc_port_t *, int);
 +extern void qlt_fc_port_deleted(struct scsi_qla_host *, fc_port_t *);
 +extern void qlt_set_mode(struct scsi_qla_host *ha);
 +extern void qlt_clear_mode(struct scsi_qla_host *ha);
  extern int __init qlt_init(void);
  extern void qlt_exit(void);
  extern void qlt_update_vp_map(struct scsi_qla_host *, int);
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 45ec37d3095c,e37d7ee95473..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -443,20 -339,21 +443,38 @@@ static void tcm_qla2xxx_release_cmd(str
  	qlt_free_cmd(cmd);
  }
  
++<<<<<<< HEAD
 +static int tcm_qla2xxx_shutdown_session(struct se_session *se_sess)
 +{
 +	struct qla_tgt_sess *sess = se_sess->fabric_sess_ptr;
 +	struct scsi_qla_host *vha;
 +	unsigned long flags;
 +
 +	BUG_ON(!sess);
 +	vha = sess->vha;
 +
 +	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
 +	target_sess_cmd_list_set_waiting(se_sess);
 +	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
 +
 +	return 1;
++=======
+ static void tcm_qla2xxx_release_session(struct kref *kref)
+ {
+ 	struct fc_port  *sess = container_of(kref,
+ 	    struct fc_port, sess_kref);
+ 
+ 	qlt_unreg_sess(sess);
+ }
+ 
+ static void tcm_qla2xxx_put_sess(struct fc_port *sess)
+ {
+ 	if (!sess)
+ 		return;
+ 
+ 	assert_spin_locked(&sess->vha->hw->tgt.sess_lock);
+ 	kref_put(&sess->sess_kref, tcm_qla2xxx_release_session);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  static void tcm_qla2xxx_close_session(struct se_session *se_sess)
@@@ -468,9 -365,10 +486,16 @@@
  	BUG_ON(!sess);
  	vha = sess->vha;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
 +	qlt_unreg_sess(sess);
 +	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
++=======
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	target_sess_cmd_list_set_waiting(se_sess);
+ 	tcm_qla2xxx_put_sess(sess);
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  }
  
  static u32 tcm_qla2xxx_sess_get_index(struct se_session *se_sess)
@@@ -574,15 -458,22 +599,23 @@@ static int tcm_qla2xxx_handle_cmd(scsi_
  {
  	struct se_cmd *se_cmd = &cmd->se_cmd;
  	struct se_session *se_sess;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess;
++=======
+ 	struct fc_port *sess;
+ #ifdef CONFIG_TCM_QLA2XXX_DEBUG
+ 	struct se_portal_group *se_tpg;
+ 	struct tcm_qla2xxx_tpg *tpg;
+ #endif
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  	int flags = TARGET_SCF_ACK_KREF;
  
  	if (bidi)
  		flags |= TARGET_SCF_BIDI_OP;
  
 -	if (se_cmd->cpuid != WORK_CPU_UNBOUND)
 -		flags |= TARGET_SCF_USE_CPUID;
 -
  	sess = cmd->sess;
  	if (!sess) {
- 		pr_err("Unable to locate struct qla_tgt_sess from qla_tgt_cmd\n");
+ 		pr_err("Unable to locate struct fc_port from qla_tgt_cmd\n");
  		return -EINVAL;
  	}
  
@@@ -636,13 -580,49 +669,13 @@@ static void tcm_qla2xxx_handle_data(str
   * Called from qla_target.c:qlt_issue_task_mgmt()
   */
  static int tcm_qla2xxx_handle_tmr(struct qla_tgt_mgmt_cmd *mcmd, uint32_t lun,
 -	uint16_t tmr_func, uint32_t tag)
 +	uint8_t tmr_func, uint32_t tag)
  {
- 	struct qla_tgt_sess *sess = mcmd->sess;
+ 	struct fc_port *sess = mcmd->sess;
  	struct se_cmd *se_cmd = &mcmd->se_cmd;
 -	int transl_tmr_func = 0;
 -
 -	switch (tmr_func) {
 -	case QLA_TGT_ABTS:
 -		pr_debug("%ld: ABTS received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_ABORT_TASK;
 -		break;
 -	case QLA_TGT_2G_ABORT_TASK:
 -		pr_debug("%ld: 2G Abort Task received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_ABORT_TASK;
 -		break;
 -	case QLA_TGT_CLEAR_ACA:
 -		pr_debug("%ld: CLEAR_ACA received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_CLEAR_ACA;
 -		break;
 -	case QLA_TGT_TARGET_RESET:
 -		pr_debug("%ld: TARGET_RESET received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_TARGET_WARM_RESET;
 -		break;
 -	case QLA_TGT_LUN_RESET:
 -		pr_debug("%ld: LUN_RESET received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_LUN_RESET;
 -		break;
 -	case QLA_TGT_CLEAR_TS:
 -		pr_debug("%ld: CLEAR_TS received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_CLEAR_TASK_SET;
 -		break;
 -	case QLA_TGT_ABORT_TS:
 -		pr_debug("%ld: ABORT_TS received\n", sess->vha->host_no);
 -		transl_tmr_func = TMR_ABORT_TASK_SET;
 -		break;
 -	default:
 -		pr_debug("%ld: Unknown task mgmt fn 0x%x\n",
 -		    sess->vha->host_no, tmr_func);
 -		return -ENOSYS;
 -	}
  
  	return target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,
 -	    transl_tmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);
 +			tmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);
  }
  
  static int tcm_qla2xxx_queue_data_in(struct se_cmd *se_cmd)
@@@ -735,11 -763,11 +768,11 @@@ static int tcm_qla2xxx_queue_tm_rsp(str
  }
  
  static void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *,
- 			struct tcm_qla2xxx_nacl *, struct qla_tgt_sess *);
+ 			struct tcm_qla2xxx_nacl *, struct fc_port *);
  /*
 - * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 + * Expected to be called with struct qla_hw_data->hardware_lock held
   */
- static void tcm_qla2xxx_clear_nacl_from_fcport_map(struct qla_tgt_sess *sess)
+ static void tcm_qla2xxx_clear_nacl_from_fcport_map(struct fc_port *sess)
  {
  	struct se_node_acl *se_nacl = sess->se_sess->se_node_acl;
  	struct se_portal_group *se_tpg = se_nacl->se_tpg;
@@@ -769,68 -806,22 +802,72 @@@
  	tcm_qla2xxx_clear_sess_lookup(lport, nacl, sess);
  }
  
++<<<<<<< HEAD
 +static void tcm_qla2xxx_release_session(struct kref *kref)
++=======
+ static void tcm_qla2xxx_shutdown_sess(struct fc_port *sess)
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  {
 -	assert_spin_locked(&sess->vha->hw->tgt.sess_lock);
 -	target_sess_cmd_list_set_waiting(sess->se_sess);
 +	struct se_session *se_sess = container_of(kref,
 +			struct se_session, sess_kref);
 +
 +	qlt_unreg_sess(se_sess->fabric_sess_ptr);
  }
  
 -static int tcm_qla2xxx_init_nodeacl(struct se_node_acl *se_nacl,
 -		const char *name)
 +static void tcm_qla2xxx_put_session(struct se_session *se_sess)
 +{
 +	struct qla_tgt_sess *sess = se_sess->fabric_sess_ptr;
 +	struct qla_hw_data *ha = sess->vha->hw;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	kref_put(&se_sess->sess_kref, tcm_qla2xxx_release_session);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +}
 +
 +static void tcm_qla2xxx_put_sess(struct qla_tgt_sess *sess)
 +{
 +	tcm_qla2xxx_put_session(sess->se_sess);
 +}
 +
 +static void tcm_qla2xxx_shutdown_sess(struct qla_tgt_sess *sess)
 +{
 +	tcm_qla2xxx_shutdown_session(sess->se_sess);
 +}
 +
 +static struct se_node_acl *tcm_qla2xxx_make_nodeacl(
 +	struct se_portal_group *se_tpg,
 +	struct config_group *group,
 +	const char *name)
  {
 -	struct tcm_qla2xxx_nacl *nacl =
 -		container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);
 +	struct se_node_acl *se_nacl, *se_nacl_new;
 +	struct tcm_qla2xxx_nacl *nacl;
  	u64 wwnn;
 +	u32 qla2xxx_nexus_depth;
  
  	if (tcm_qla2xxx_parse_wwn(name, &wwnn, 1) < 0)
 -		return -EINVAL;
 +		return ERR_PTR(-EINVAL);
  
 +	se_nacl_new = tcm_qla2xxx_alloc_fabric_acl(se_tpg);
 +	if (!se_nacl_new)
 +		return ERR_PTR(-ENOMEM);
 +/* #warning FIXME: Hardcoded qla2xxx_nexus depth in tcm_qla2xxx_make_nodeacl */
 +	qla2xxx_nexus_depth = 1;
 +
 +	/*
 +	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
 +	 * when converting a NodeACL from demo mode -> explict
 +	 */
 +	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,
 +				name, qla2xxx_nexus_depth);
 +	if (IS_ERR(se_nacl)) {
 +		tcm_qla2xxx_release_fabric_acl(se_tpg, se_nacl_new);
 +		return se_nacl;
 +	}
 +	/*
 +	 * Locate our struct tcm_qla2xxx_nacl and set the FC Nport WWPN
 +	 */
 +	nacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);
  	nacl->nport_wwnn = wwnn;
  	tcm_qla2xxx_format_wwn(&nacl->nport_name[0], TCM_QLA2XXX_NAMELEN, wwnn);
  
@@@ -1116,9 -1189,9 +1153,9 @@@ static struct se_portal_group *tcm_qla2
  }
  
  /*
 - * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 + * Expected to be called with struct qla_hw_data->hardware_lock held
   */
- static struct qla_tgt_sess *tcm_qla2xxx_find_sess_by_s_id(
+ static struct fc_port *tcm_qla2xxx_find_sess_by_s_id(
  	scsi_qla_host_t *vha,
  	const uint8_t *s_id)
  {
@@@ -1226,9 -1294,9 +1263,9 @@@ static void tcm_qla2xxx_set_sess_by_s_i
  }
  
  /*
 - * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 + * Expected to be called with struct qla_hw_data->hardware_lock held
   */
- static struct qla_tgt_sess *tcm_qla2xxx_find_sess_by_loop_id(
+ static struct fc_port *tcm_qla2xxx_find_sess_by_loop_id(
  	scsi_qla_host_t *vha,
  	const uint16_t loop_id)
  {
@@@ -1330,10 -1397,10 +1367,10 @@@ static void tcm_qla2xxx_set_sess_by_loo
  }
  
  /*
 - * Should always be called with qla_hw_data->tgt.sess_lock held.
 + * Should always be called with qla_hw_data->hardware_lock held.
   */
  static void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *lport,
- 		struct tcm_qla2xxx_nacl *nacl, struct qla_tgt_sess *sess)
+ 		struct tcm_qla2xxx_nacl *nacl, struct fc_port *sess)
  {
  	struct se_session *se_sess = sess->se_sess;
  	unsigned char be_sid[3];
@@@ -1380,6 -1444,39 +1417,42 @@@ static void tcm_qla2xxx_free_session(st
  	transport_deregister_session(sess->se_sess);
  }
  
++<<<<<<< HEAD
++=======
+ static int tcm_qla2xxx_session_cb(struct se_portal_group *se_tpg,
+ 				  struct se_session *se_sess, void *p)
+ {
+ 	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
+ 				struct tcm_qla2xxx_tpg, se_tpg);
+ 	struct tcm_qla2xxx_lport *lport = tpg->lport;
+ 	struct qla_hw_data *ha = lport->qla_vha->hw;
+ 	struct se_node_acl *se_nacl = se_sess->se_node_acl;
+ 	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
+ 				struct tcm_qla2xxx_nacl, se_node_acl);
+ 	struct fc_port *qlat_sess = p;
+ 	uint16_t loop_id = qlat_sess->loop_id;
+ 	unsigned long flags;
+ 	unsigned char be_sid[3];
+ 
+ 	be_sid[0] = qlat_sess->d_id.b.domain;
+ 	be_sid[1] = qlat_sess->d_id.b.area;
+ 	be_sid[2] = qlat_sess->d_id.b.al_pa;
+ 
+ 	/*
+ 	 * And now setup se_nacl and session pointers into HW lport internal
+ 	 * mappings for fabric S_ID and LOOP_ID.
+ 	 */
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	tcm_qla2xxx_set_sess_by_s_id(lport, se_nacl, nacl,
+ 				     se_sess, qlat_sess, be_sid);
+ 	tcm_qla2xxx_set_sess_by_loop_id(lport, se_nacl, nacl,
+ 					se_sess, qlat_sess, loop_id);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  /*
   * Called via qlt_create_sess():ha->qla2x_tmpl->check_initiator_node_acl()
   * to locate struct se_node_acl
@@@ -1387,9 -1484,7 +1460,13 @@@
  static int tcm_qla2xxx_check_initiator_node_acl(
  	scsi_qla_host_t *vha,
  	unsigned char *fc_wwpn,
++<<<<<<< HEAD
 +	void *qla_tgt_sess,
 +	uint8_t *s_id,
 +	uint16_t loop_id)
++=======
+ 	struct fc_port *qlat_sess)
++>>>>>>> 5d964837c6a7 (qla2xxx: Track I-T nexus as single fc_port struct)
  {
  	struct qla_hw_data *ha = vha->hw;
  	struct tcm_qla2xxx_lport *lport;
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812..9d6c86afe04b 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -1955,6 +1955,84 @@ struct mbx_entry {
 	uint8_t port_name[WWN_SIZE];
 };
 
+#ifndef IMMED_NOTIFY_TYPE
+#define IMMED_NOTIFY_TYPE 0x0D		/* Immediate notify entry. */
+/*
+ * ISP queue -	immediate notify entry structure definition.
+ *		This is sent by the ISP to the Target driver.
+ *		This IOCB would have report of events sent by the
+ *		initiator, that needs to be handled by the target
+ *		driver immediately.
+ */
+struct imm_ntfy_from_isp {
+	uint8_t	 entry_type;		    /* Entry type. */
+	uint8_t	 entry_count;		    /* Entry count. */
+	uint8_t	 sys_define;		    /* System defined. */
+	uint8_t	 entry_status;		    /* Entry Status. */
+	union {
+		struct {
+			uint32_t sys_define_2; /* System defined. */
+			target_id_t target;
+			uint16_t lun;
+			uint8_t  target_id;
+			uint8_t  reserved_1;
+			uint16_t status_modifier;
+			uint16_t status;
+			uint16_t task_flags;
+			uint16_t seq_id;
+			uint16_t srr_rx_id;
+			uint32_t srr_rel_offs;
+			uint16_t srr_ui;
+#define SRR_IU_DATA_IN	0x1
+#define SRR_IU_DATA_OUT	0x5
+#define SRR_IU_STATUS	0x7
+			uint16_t srr_ox_id;
+			uint8_t reserved_2[28];
+		} isp2x;
+		struct {
+			uint32_t reserved;
+			uint16_t nport_handle;
+			uint16_t reserved_2;
+			uint16_t flags;
+#define NOTIFY24XX_FLAGS_GLOBAL_TPRLO   BIT_1
+#define NOTIFY24XX_FLAGS_PUREX_IOCB     BIT_0
+			uint16_t srr_rx_id;
+			uint16_t status;
+			uint8_t  status_subcode;
+			uint8_t  fw_handle;
+			uint32_t exchange_address;
+			uint32_t srr_rel_offs;
+			uint16_t srr_ui;
+			uint16_t srr_ox_id;
+			union {
+				struct {
+					uint8_t node_name[8];
+				} plogi; /* PLOGI/ADISC/PDISC */
+				struct {
+					/* PRLI word 3 bit 0-15 */
+					uint16_t wd3_lo;
+					uint8_t resv0[6];
+				} prli;
+				struct {
+					uint8_t port_id[3];
+					uint8_t resv1;
+					uint16_t nport_handle;
+					uint16_t resv2;
+				} req_els;
+			} u;
+			uint8_t port_name[8];
+			uint8_t resv3[3];
+			uint8_t  vp_index;
+			uint32_t reserved_5;
+			uint8_t  port_id[3];
+			uint8_t  reserved_6;
+		} isp24;
+	} u;
+	uint16_t reserved_7;
+	uint16_t ox_id;
+} __packed;
+#endif
+
 /*
  * ISP request and response queue entry sizes
  */
@@ -2005,7 +2083,7 @@ typedef struct {
 /*
  * Fibre channel port type.
  */
- typedef enum {
+typedef enum {
 	FCT_UNKNOWN,
 	FCT_RSCN,
 	FCT_SWITCH,
@@ -2014,6 +2092,19 @@ typedef struct {
 	FCT_TARGET
 } fc_port_type_t;
 
+enum qlt_plogi_link_t {
+	QLT_PLOGI_LINK_SAME_WWN,
+	QLT_PLOGI_LINK_CONFLICT,
+	QLT_PLOGI_LINK_MAX
+};
+
+struct qlt_plogi_ack_t {
+	struct list_head	list;
+	struct imm_ntfy_from_isp iocb;
+	port_id_t	id;
+	int		ref_count;
+};
+
 /*
  * Fibre channel port structure.
  */
@@ -2027,6 +2118,25 @@ typedef struct fc_port {
 	uint16_t loop_id;
 	uint16_t old_loop_id;
 
+	unsigned int conf_compl_supported:1;
+	unsigned int deleted:2;
+	unsigned int local:1;
+	unsigned int logout_on_delete:1;
+	unsigned int keep_nport_handle:1;
+	unsigned int send_els_logo:1;
+
+	unsigned char logout_completed;
+	int generation;
+
+	struct se_session *se_sess;
+	struct kref sess_kref;
+	struct qla_tgt *tgt;
+	unsigned long expires;
+	struct list_head del_list_entry;
+	struct work_struct free_work;
+
+	struct qlt_plogi_ack_t *plogi_link[QLT_PLOGI_LINK_MAX];
+
 	uint16_t tgt_id;
 	uint16_t old_tgt_id;
 
* Unmerged path drivers/scsi/qla2xxx/qla_dfs.c
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.h b/drivers/scsi/qla2xxx/tcm_qla2xxx.h
index fe758517da6d..f6b3b7415531 100644
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.h
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.h
@@ -13,8 +13,8 @@ struct tcm_qla2xxx_nacl {
 	u64 nport_wwnn;
 	/* ASCII formatted WWPN for FC Initiator Nport */
 	char nport_name[TCM_QLA2XXX_NAMELEN];
-	/* Pointer to qla_tgt_sess */
-	struct qla_tgt_sess *qla_tgt_sess;
+	/* Pointer to fc_port */
+	struct fc_port *fc_port;
 	/* Pointer to TCM FC nexus */
 	struct se_session *nport_nexus;
 	/* Returned by tcm_qla2xxx_make_nodeacl() */
