ovl: cleanup bad and stale index entries on mount

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 415543d5c64fe490b4b6a7e21c3ea2f1310c442f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/415543d5.failed

Bad index entries are entries whose name does not match the
origin file handle stored in trusted.overlay.origin xattr.
Bad index entries could be a result of a system power off in
the middle of copy up.

Stale index entries are entries whose origin file handle is
stale. Stale index entries could be a result of copying layers
or removing lower entries while the overlay is not mounted.
The case of copying layers should be detected earlier by the
verification of upper root dir origin and index dir origin.

Both bad and stale index entries are detected and removed
on mount.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 415543d5c64fe490b4b6a7e21c3ea2f1310c442f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/dir.c
index 709c8eb662f9,a072c27e03bc..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -15,9 -15,16 +15,18 @@@
  #include <linux/posix_acl.h>
  #include <linux/posix_acl_xattr.h>
  #include <linux/atomic.h>
 -#include <linux/ratelimit.h>
  #include "overlayfs.h"
  
++<<<<<<< HEAD
 +void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)
++=======
+ static unsigned short ovl_redirect_max = 256;
+ module_param_named(redirect_max, ovl_redirect_max, ushort, 0644);
+ MODULE_PARM_DESC(ovl_redirect_max,
+ 		 "Maximum length of absolute redirect xattr value");
+ 
+ int ovl_cleanup(struct inode *wdir, struct dentry *wdentry)
++>>>>>>> 415543d5c64f (ovl: cleanup bad and stale index entries on mount)
  {
  	int err;
  
@@@ -32,9 -39,11 +41,11 @@@
  		pr_err("overlayfs: cleanup of '%pd2' failed (%i)\n",
  		       wdentry, err);
  	}
+ 
+ 	return err;
  }
  
 -struct dentry *ovl_lookup_temp(struct dentry *workdir)
 +struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)
  {
  	struct dentry *temp;
  	char name[20];
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,f3e49cf34517..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -198,51 +151,68 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 -struct inode *ovl_inode_upper(struct inode *inode);
 -struct inode *ovl_inode_lower(struct inode *inode);
 -struct inode *ovl_inode_real(struct inode *inode);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+ 		    struct dentry *lowerdentry);
+ void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+ 		       const char *name, const void *value, size_t size,
+ 		       int xerr);
+ int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_set_flag(unsigned long flag, struct inode *inode);
+ bool ovl_test_flag(unsigned long flag, struct inode *inode);
+ bool ovl_inuse_trylock(struct dentry *dentry);
+ void ovl_inuse_unlock(struct dentry *dentry);
+ 
+ static inline bool ovl_is_impuredir(struct dentry *dentry)
+ {
+ 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+ }
+ 
+ 
+ /* namei.c */
+ int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
+ 		      struct dentry *origin, bool is_upper, bool set);
+ int ovl_verify_index(struct dentry *index, struct path *lowerstack,
+ 		     unsigned int numlower);
+ int ovl_get_index_name(struct dentry *origin, struct qstr *name);
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> 415543d5c64f (ovl: cleanup bad and stale index entries on mount)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
@@@ -208,12 -283,17 +251,12 @@@ static inline void ovl_copyattr(struct 
  }
  
  /* dir.c */
 -extern const struct inode_operations ovl_dir_inode_operations;
 -struct dentry *ovl_lookup_temp(struct dentry *workdir);
 -struct cattr {
 -	dev_t rdev;
 -	umode_t mode;
 -	const char *link;
 -};
 +extern const struct inode_operations_wrapper ovl_dir_inode_operations;
 +struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);
  int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 -		    struct cattr *attr,
 +		    struct kstat *stat, const char *link,
  		    struct dentry *hardlink, bool debug);
- void ovl_cleanup(struct inode *dir, struct dentry *dentry);
+ int ovl_cleanup(struct inode *dir, struct dentry *dentry);
  
  /* copy_up.c */
  int ovl_copy_up(struct dentry *dentry);
diff --cc fs/overlayfs/super.c
index aaf06952d88f,791581c370f5..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -1434,11 -1044,51 +1434,54 @@@ static int ovl_fill_super(struct super_
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
  	if (!ufs->upper_mnt)
  		sb->s_flags |= MS_RDONLY;
++<<<<<<< HEAD
++=======
+ 	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
+ 		ufs->same_sb = NULL;
+ 
+ 	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
+ 		/* Verify lower root is upper root origin */
+ 		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
+ 					stack[0].dentry, false, true);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to verify upper root origin\n");
+ 			goto out_put_lower_mnt;
+ 		}
+ 
+ 		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
+ 						   OVL_INDEXDIR_NAME, true);
+ 		err = PTR_ERR(ufs->indexdir);
+ 		if (IS_ERR(ufs->indexdir))
+ 			goto out_put_lower_mnt;
+ 
+ 		if (ufs->indexdir) {
+ 			/* Verify upper root is index dir origin */
+ 			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
+ 						upperpath.dentry, true, true);
+ 			if (err)
+ 				pr_err("overlayfs: failed to verify index dir origin\n");
+ 
+ 			/* Cleanup bad/stale index entries */
+ 			if (!err)
+ 				err = ovl_indexdir_cleanup(ufs->indexdir,
+ 							   ufs->upper_mnt,
+ 							   stack, numlower);
+ 		}
+ 		if (err || !ufs->indexdir)
+ 			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 		if (err)
+ 			goto out_put_indexdir;
+ 	}
+ 
+ 	/* Show index=off/on in /proc/mounts for any of the reasons above */
+ 	if (!ufs->indexdir)
+ 		ufs->config.index = false;
++>>>>>>> 415543d5c64f (ovl: cleanup bad and stale index entries on mount)
  
  	if (remote)
 -		sb->s_d_op = &ovl_reval_dentry_operations;
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
  	else
 -		sb->s_d_op = &ovl_dentry_operations;
 +		sb->s_d_op = &ovl_dentry_operations.ops;
  
  	ufs->creator_cred = cred = prepare_creds();
  	if (!cred)
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
diff --git a/fs/overlayfs/readdir.c b/fs/overlayfs/readdir.c
index 2010cf9bd904..4af6ba684073 100644
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@ -678,3 +678,53 @@ void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 		ovl_cleanup(dir, dentry);
 	}
 }
+
+int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
+			 struct path *lowerstack, unsigned int numlower)
+{
+	int err;
+	struct inode *dir = dentry->d_inode;
+	struct path path = { .mnt = mnt, .dentry = dentry };
+	LIST_HEAD(list);
+	struct ovl_cache_entry *p;
+	struct ovl_readdir_data rdd = {
+		.ctx.actor = ovl_fill_merge,
+		.dentry = NULL,
+		.list = &list,
+		.root = RB_ROOT,
+		.is_lowest = false,
+	};
+
+	err = ovl_dir_read(&path, &rdd);
+	if (err)
+		goto out;
+
+	inode_lock_nested(dir, I_MUTEX_PARENT);
+	list_for_each_entry(p, &list, l_node) {
+		struct dentry *index;
+
+		if (p->name[0] == '.') {
+			if (p->len == 1)
+				continue;
+			if (p->len == 2 && p->name[1] == '.')
+				continue;
+		}
+		index = lookup_one_len(p->name, dentry, p->len);
+		if (IS_ERR(index)) {
+			err = PTR_ERR(index);
+			break;
+		}
+		if (ovl_verify_index(index, lowerstack, numlower)) {
+			err = ovl_cleanup(dir, index);
+			if (err)
+				break;
+		}
+		dput(index);
+	}
+	inode_unlock(dir);
+out:
+	ovl_cache_free(&list);
+	if (err)
+		pr_err("overlayfs: failed index dir cleanup (%i)\n", err);
+	return err;
+}
* Unmerged path fs/overlayfs/super.c
