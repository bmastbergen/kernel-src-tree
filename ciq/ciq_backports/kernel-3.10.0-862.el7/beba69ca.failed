nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit beba69ca755542c2581bbb64b2fa79b11047ed8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/beba69ca.failed

struct nfp_net represents a vNIC, we will be moving away from the
requirement for every vNIC to have a netdev associated with it.
Remove "netdev" from some function names and prefer passing
struct nfp_net pointer as argument instead of struct net_device *.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit beba69ca755542c2581bbb64b2fa79b11047ed8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,b427c95c5acd..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2702,12 -3143,33 +2701,12 @@@ struct nfp_net *nfp_net_alloc(struct pc
  }
  
  /**
-  * nfp_net_netdev_free() - Undo what @nfp_net_netdev_alloc() did
+  * nfp_net_free() - Undo what @nfp_net_alloc() did
   * @nn:      NFP Net device to reconfigure
   */
- void nfp_net_netdev_free(struct nfp_net *nn)
+ void nfp_net_free(struct nfp_net *nn)
  {
 -	free_netdev(nn->dp.netdev);
 -}
 -
 -/**
 - * nfp_net_rss_key_sz() - Get current size of the RSS key
 - * @nn:		NFP Net device instance
 - *
 - * Return: size of the RSS key for currently selected hash function.
 - */
 -unsigned int nfp_net_rss_key_sz(struct nfp_net *nn)
 -{
 -	switch (nn->rss_hfunc) {
 -	case ETH_RSS_HASH_TOP:
 -		return NFP_NET_CFG_RSS_KEY_SZ;
 -	case ETH_RSS_HASH_XOR:
 -		return 0;
 -	case ETH_RSS_HASH_CRC32:
 -		return 4;
 -	}
 -
 -	nn_warn(nn, "Unknown hash function: %u\n", nn->rss_hfunc);
 -	return 0;
 +	free_netdev(nn->netdev);
  }
  
  /**
@@@ -2745,11 -3225,13 +2744,11 @@@ static void nfp_net_irqmod_init(struct 
   *
   * Return: 0 on success or negative errno on error.
   */
- int nfp_net_netdev_init(struct net_device *netdev)
+ int nfp_net_init(struct nfp_net *nn)
  {
- 	struct nfp_net *nn = netdev_priv(netdev);
+ 	struct net_device *netdev = nn->dp.netdev;
  	int err;
  
 -	nn->dp.rx_dma_dir = DMA_FROM_DEVICE;
 -
  	/* Get some of the read-only fields from the BAR */
  	nn->cap = nn_readl(nn, NFP_NET_CFG_CAP);
  	nn->max_mtu = nn_readl(nn, NFP_NET_CFG_MAX_MTU);
@@@ -2860,10 -3372,15 +2859,19 @@@
  }
  
  /**
-  * nfp_net_netdev_clean() - Undo what nfp_net_netdev_init() did.
-  * @netdev:      netdev structure
+  * nfp_net_clean() - Undo what nfp_net_init() did.
+  * @nn:		NFP Net device structure
   */
- void nfp_net_netdev_clean(struct net_device *netdev)
+ void nfp_net_clean(struct nfp_net *nn)
  {
++<<<<<<< HEAD
 +	unregister_netdev(netdev);
++=======
+ 	unregister_netdev(nn->dp.netdev);
+ 
+ 	if (nn->dp.xdp_prog)
+ 		bpf_prog_put(nn->dp.xdp_prog);
+ 	if (nn->dp.bpf_offload_xdp)
+ 		nfp_net_xdp_offload(nn, NULL);
++>>>>>>> beba69ca7555 (nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs)
  }
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,55d916cb04fe..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -275,8 -275,9 +275,8 @@@ static void nfp_net_pf_free_netdevs(str
  	while (!list_empty(&pf->ports)) {
  		nn = list_first_entry(&pf->ports, struct nfp_net, port_list);
  		list_del(&nn->port_list);
 -		pf->num_netdevs--;
  
- 		nfp_net_netdev_free(nn);
+ 		nfp_net_free(nn);
  	}
  }
  
@@@ -323,7 -326,7 +323,11 @@@ nfp_net_pf_init_port_netdev(struct nfp_
  	 */
  	nn->me_freq_mhz = 1200;
  
++<<<<<<< HEAD
 +	err = nfp_net_netdev_init(nn->netdev);
++=======
+ 	err = nfp_net_init(nn);
++>>>>>>> beba69ca7555 (nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs)
  	if (err)
  		return err;
  
@@@ -437,7 -451,7 +441,11 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  err_prev_deinit:
  	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
  		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
++<<<<<<< HEAD
 +		nfp_net_netdev_clean(nn->netdev);
++=======
+ 		nfp_net_clean(nn);
++>>>>>>> beba69ca7555 (nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs)
  	}
  	nfp_net_irqs_disable(pf->pdev);
  err_vec_free:
@@@ -652,7 -693,7 +660,11 @@@ void nfp_net_pci_remove(struct nfp_pf *
  	list_for_each_entry(nn, &pf->ports, port_list) {
  		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
  
++<<<<<<< HEAD
 +		nfp_net_netdev_clean(nn->netdev);
++=======
+ 		nfp_net_clean(nn);
++>>>>>>> beba69ca7555 (nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs)
  	}
  
  	nfp_net_pf_free_netdevs(pf);
diff --cc drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
index bd3cf87f2365,856a76bdfc24..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
@@@ -281,7 -283,7 +281,11 @@@ static int nfp_netvf_pci_probe(struct p
  	 */
  	nn->me_freq_mhz = 1200;
  
++<<<<<<< HEAD
 +	err = nfp_net_netdev_init(nn->netdev);
++=======
+ 	err = nfp_net_init(nn);
++>>>>>>> beba69ca7555 (nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs)
  	if (err)
  		goto err_irqs_disable;
  
@@@ -326,7 -328,7 +330,11 @@@ static void nfp_netvf_pci_remove(struc
  	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
  	nfp_net_debugfs_dir_clean(&vf->ddir);
  
++<<<<<<< HEAD
 +	nfp_net_netdev_clean(nn->netdev);
++=======
+ 	nfp_net_clean(nn);
++>>>>>>> beba69ca7555 (nfp: make nfp_net alloc/init/cleanup/free not depend on netdevs)
  
  	nfp_net_irqs_disable(pdev);
  
@@@ -336,9 -338,9 +344,9 @@@
  	} else {
  		iounmap(vf->q_bar);
  	}
 -	iounmap(nn->dp.ctrl_bar);
 +	iounmap(nn->ctrl_bar);
  
- 	nfp_net_netdev_free(nn);
+ 	nfp_net_free(nn);
  
  	pci_release_regions(pdev);
  	pci_disable_device(pdev);
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net.h b/drivers/net/ethernet/netronome/nfp/nfp_net.h
index 600c79f39fe0..142a8d8d9840 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@ -738,11 +738,13 @@ void nfp_net_get_fw_version(struct nfp_net_fw_version *fw_ver,
 			    void __iomem *ctrl_bar);
 
 struct nfp_net *
-nfp_net_netdev_alloc(struct pci_dev *pdev,
-		     unsigned int max_tx_rings, unsigned int max_rx_rings);
-void nfp_net_netdev_free(struct nfp_net *nn);
-int nfp_net_netdev_init(struct net_device *netdev);
-void nfp_net_netdev_clean(struct net_device *netdev);
+nfp_net_alloc(struct pci_dev *pdev,
+	      unsigned int max_tx_rings, unsigned int max_rx_rings);
+void nfp_net_free(struct nfp_net *nn);
+
+int nfp_net_init(struct nfp_net *nn);
+void nfp_net_clean(struct nfp_net *nn);
+
 void nfp_net_set_ethtool_ops(struct net_device *netdev);
 void nfp_net_info(struct nfp_net *nn);
 int nfp_net_reconfig(struct nfp_net *nn, u32 update);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
