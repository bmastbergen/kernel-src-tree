nfp: handle page allocation failures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 5f0ca2fb71e28df146f590eebfe32b41171b737f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5f0ca2fb.failed

page_address() does not handle NULL argument gracefully,
make sure we NULL-check the page pointer before passing it
to page_address().

Fixes: ecd63a0217d5 ("nfp: add XDP support in the driver")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f0ca2fb71e28df146f590eebfe32b41171b737f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 4daa95c7c08c,e118b5f23996..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1071,16 -1176,20 +1071,27 @@@ nfp_net_calc_fl_bufsz(struct nfp_net *n
   *
   * Return: allocated page frag or NULL on failure.
   */
 -static void *nfp_net_rx_alloc_one(struct nfp_net_dp *dp, dma_addr_t *dma_addr)
 +static void *
 +nfp_net_rx_alloc_one(struct nfp_net_rx_ring *rx_ring, dma_addr_t *dma_addr,
 +		     unsigned int fl_bufsz)
  {
 +	struct nfp_net *nn = rx_ring->r_vec->nfp_net;
  	void *frag;
  
++<<<<<<< HEAD
 +	frag = netdev_alloc_frag(fl_bufsz);
++=======
+ 	if (!dp->xdp_prog) {
+ 		frag = netdev_alloc_frag(dp->fl_bufsz);
+ 	} else {
+ 		struct page *page;
+ 
+ 		page = alloc_page(GFP_KERNEL | __GFP_COLD);
+ 		frag = page ? page_address(page) : NULL;
+ 	}
++>>>>>>> 5f0ca2fb71e2 (nfp: handle page allocation failures)
  	if (!frag) {
 -		nn_dp_warn(dp, "Failed to alloc receive page frag\n");
 +		nn_warn_ratelimit(nn, "Failed to alloc receive page frag\n");
  		return NULL;
  	}
  
@@@ -1098,9 -1207,16 +1109,20 @@@ static void *nfp_net_napi_alloc_one(str
  {
  	void *frag;
  
++<<<<<<< HEAD
 +	frag = napi_alloc_frag(nn->fl_bufsz);
++=======
+ 	if (!dp->xdp_prog) {
+ 		frag = napi_alloc_frag(dp->fl_bufsz);
+ 	} else {
+ 		struct page *page;
+ 
+ 		page = alloc_page(GFP_ATOMIC | __GFP_COLD);
+ 		frag = page ? page_address(page) : NULL;
+ 	}
++>>>>>>> 5f0ca2fb71e2 (nfp: handle page allocation failures)
  	if (!frag) {
 -		nn_dp_warn(dp, "Failed to alloc receive page frag\n");
 +		nn_warn_ratelimit(nn, "Failed to alloc receive page frag\n");
  		return NULL;
  	}
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
