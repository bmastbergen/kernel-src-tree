drm/i915: Replace tmds_clock_speed and link_rate with just ls_clock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit c98ec5ba6cbbaaa98cb4c00888aecf58f7d470c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c98ec5ba.failed

There's no need to distinguish between the DP link rate and HDMI TMDS
clock for the purposes of the LPE audio. Both are actually the same
thing more or less, which is the link symbol clock. So let's just
call the thing ls_clock and simplify the code.

	Cc: Takashi Iwai <tiwai@suse.de>
	Cc: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20170427160231.13337-6-ville.syrjala@linux.intel.com
	Reviewed-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit c98ec5ba6cbbaaa98cb4c00888aecf58f7d470c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.h
#	drivers/gpu/drm/i915/intel_audio.c
#	drivers/gpu/drm/i915/intel_lpe_audio.c
#	include/drm/intel_lpe_audio.h
#	sound/x86/intel_hdmi_audio.c
diff --cc drivers/gpu/drm/i915/i915_drv.h
index c383dcb3961f,38b6bf9f4dc2..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -3388,9 -3716,17 +3388,20 @@@ extern int i915_restore_state(struct dr
  void i915_setup_sysfs(struct drm_i915_private *dev_priv);
  void i915_teardown_sysfs(struct drm_i915_private *dev_priv);
  
++<<<<<<< HEAD
++=======
+ /* intel_lpe_audio.c */
+ int  intel_lpe_audio_init(struct drm_i915_private *dev_priv);
+ void intel_lpe_audio_teardown(struct drm_i915_private *dev_priv);
+ void intel_lpe_audio_irq_handler(struct drm_i915_private *dev_priv);
+ void intel_lpe_audio_notify(struct drm_i915_private *dev_priv,
+ 			    void *eld, int port, int pipe, int ls_clock,
+ 			    bool dp_output);
+ 
++>>>>>>> c98ec5ba6cbb (drm/i915: Replace tmds_clock_speed and link_rate with just ls_clock)
  /* intel_i2c.c */
 -extern int intel_setup_gmbus(struct drm_i915_private *dev_priv);
 -extern void intel_teardown_gmbus(struct drm_i915_private *dev_priv);
 +extern int intel_setup_gmbus(struct drm_device *dev);
 +extern void intel_teardown_gmbus(struct drm_device *dev);
  extern bool intel_gmbus_is_valid_pin(struct drm_i915_private *dev_priv,
  				     unsigned int pin);
  
diff --cc drivers/gpu/drm/i915/intel_audio.c
index 49f10538d4aa,79eeef25321f..000000000000
--- a/drivers/gpu/drm/i915/intel_audio.c
+++ b/drivers/gpu/drm/i915/intel_audio.c
@@@ -623,13 -624,17 +623,21 @@@ void intel_audio_codec_enable(struct in
  	dev_priv->av_enc_map[pipe] = intel_encoder;
  	mutex_unlock(&dev_priv->av_mutex);
  
 -	if (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify) {
 -		/* audio drivers expect pipe = -1 to indicate Non-MST cases */
 -		if (intel_encoder->type != INTEL_OUTPUT_DP_MST)
 -			pipe = -1;
 +	/* audio drivers expect pipe = -1 to indicate Non-MST cases */
 +	if (intel_encoder->type != INTEL_OUTPUT_DP_MST)
 +		pipe = -1;
 +
 +	if (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify)
  		acomp->audio_ops->pin_eld_notify(acomp->audio_ops->audio_ptr,
  						 (int) port, (int) pipe);
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	intel_lpe_audio_notify(dev_priv, connector->eld, port, pipe,
+ 			       crtc_state->port_clock,
+ 			       intel_encoder->type == INTEL_OUTPUT_DP);
++>>>>>>> c98ec5ba6cbb (drm/i915: Replace tmds_clock_speed and link_rate with just ls_clock)
  }
  
  /**
@@@ -656,13 -661,15 +664,19 @@@ void intel_audio_codec_disable(struct i
  	dev_priv->av_enc_map[pipe] = NULL;
  	mutex_unlock(&dev_priv->av_mutex);
  
 -	if (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify) {
 -		/* audio drivers expect pipe = -1 to indicate Non-MST cases */
 -		if (intel_encoder->type != INTEL_OUTPUT_DP_MST)
 -			pipe = -1;
 +	/* audio drivers expect pipe = -1 to indicate Non-MST cases */
 +	if (intel_encoder->type != INTEL_OUTPUT_DP_MST)
 +		pipe = -1;
 +
 +	if (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify)
  		acomp->audio_ops->pin_eld_notify(acomp->audio_ops->audio_ptr,
  						 (int) port, (int) pipe);
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	intel_lpe_audio_notify(dev_priv, NULL, port, pipe, 0, false);
++>>>>>>> c98ec5ba6cbb (drm/i915: Replace tmds_clock_speed and link_rate with just ls_clock)
  }
  
  /**
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,4eaf5de54f61..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -1573,61 -1515,263 +1573,235 @@@ static struct snd_kcontrol_new had_cont
  };
  
  /*
++<<<<<<< HEAD
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
++=======
+  * audio interrupt handler
+  */
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad *ctx = dev_id;
+ 	u32 audio_stat;
+ 
+ 	/* use raw register access to ack IRQs even while disconnected */
+ 	audio_stat = had_read_register_raw(ctx, AUD_HDMI_STATUS);
+ 
+ 	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 		had_write_register_raw(ctx, AUD_HDMI_STATUS,
+ 				       HDMI_AUDIO_UNDERRUN);
+ 		had_process_buffer_underrun(ctx);
+ 	}
+ 
+ 	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 		had_write_register_raw(ctx, AUD_HDMI_STATUS,
+ 				       HDMI_AUDIO_BUFFER_DONE);
+ 		had_process_buffer_done(ctx);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ /*
+  * monitor plug/unplug notification from i915; just kick off the work
+  */
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
+ 
+ 	schedule_work(&ctx->hdmi_audio_wq);
+ }
+ 
+ /* the work to handle monitor hot plug/unplug */
+ static void had_audio_wq(struct work_struct *work)
+ {
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 
+ 	pm_runtime_get_sync(ctx->dev);
+ 	mutex_lock(&ctx->mutex);
+ 	if (!pdata->hdmi_connected) {
+ 		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 		memset(ctx->eld, 0, sizeof(ctx->eld)); /* clear the old ELD */
+ 		had_process_hot_unplug(ctx);
+ 	} else {
+ 		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
+ 
+ 		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, eld->port_id,	pdata->ls_clock);
+ 
+ 		switch (eld->pipe_id) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(ctx->dev, "Invalid pipe %d\n",
+ 				eld->pipe_id);
+ 			break;
+ 		}
+ 
+ 		memcpy(ctx->eld, eld->eld_data, sizeof(ctx->eld));
+ 
+ 		ctx->dp_output = pdata->dp_output;
+ 		if (ctx->dp_output) {
+ 			ctx->tmds_clock_speed = 0;
+ 			ctx->link_rate = pdata->ls_clock;
+ 		} else {
+ 			ctx->tmds_clock_speed = pdata->ls_clock;
+ 			ctx->link_rate = 0;
+ 		}
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		/* Process mode change if stream is active */
+ 		had_process_mode_change(ctx);
+ 	}
+ 	mutex_unlock(&ctx->mutex);
+ 	pm_runtime_mark_last_busy(ctx->dev);
+ 	pm_runtime_put_autosuspend(ctx->dev);
+ }
+ 
+ /*
+  * Jack interface
+  */
+ static int had_create_jack(struct snd_intelhad *ctx)
+ {
+ 	int err;
+ 
+ 	err = snd_jack_new(ctx->card, "HDMI/DP", SND_JACK_AVOUT, &ctx->jack,
+ 			   true, false);
+ 	if (err < 0)
+ 		return err;
+ 	ctx->jack->private_data = ctx;
+ 	return 0;
+ }
+ 
+ /*
+  * PM callbacks
+  */
+ 
+ static int hdmi_lpe_audio_runtime_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 	struct snd_pcm_substream *substream;
+ 
+ 	substream = had_substream_get(ctx);
+ 	if (substream) {
+ 		snd_pcm_suspend(substream);
+ 		had_substream_put(ctx);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused hdmi_lpe_audio_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = hdmi_lpe_audio_runtime_suspend(dev);
+ 	if (!err)
+ 		snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D3hot);
+ 	return err;
+ }
+ 
+ static int hdmi_lpe_audio_runtime_resume(struct device *dev)
+ {
+ 	pm_runtime_mark_last_busy(dev);
+ 	return 0;
+ }
+ 
+ static int __maybe_unused hdmi_lpe_audio_resume(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 
+ 	hdmi_lpe_audio_runtime_resume(dev);
+ 	snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D0);
+ 	return 0;
+ }
+ 
+ /* release resources */
+ static void hdmi_lpe_audio_free(struct snd_card *card)
+ {
+ 	struct snd_intelhad *ctx = card->private_data;
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 
+ 	spin_lock_irq(&pdata->lpe_audio_slock);
+ 	pdata->notify_audio_lpe = NULL;
+ 	spin_unlock_irq(&pdata->lpe_audio_slock);
+ 
+ 	cancel_work_sync(&ctx->hdmi_audio_wq);
+ 
+ 	if (ctx->mmio_start)
+ 		iounmap(ctx->mmio_start);
+ 	if (ctx->irq >= 0)
+ 		free_irq(ctx->irq, ctx);
+ }
+ 
+ /*
+  * hdmi_lpe_audio_probe - start bridge with i915
++>>>>>>> c98ec5ba6cbb (drm/i915: Replace tmds_clock_speed and link_rate with just ls_clock)
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
 + *
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
 -	struct snd_card *card;
 -	struct snd_intelhad *ctx;
 +	int retval;
  	struct snd_pcm *pcm;
 -	struct intel_hdmi_lpe_audio_pdata *pdata;
 -	int irq;
 -	struct resource *res_mmio;
 -	int i, ret;
 -
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	pr_debug("Enter %s\n", __func__);
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	/* create a card instance with ALSA framework */
 -	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
 -			   THIS_MODULE, sizeof(*ctx), &card);
 -	if (ret)
 -		return ret;
 -
 -	ctx = card->private_data;
 -	spin_lock_init(&ctx->had_spinlock);
 -	mutex_init(&ctx->mutex);
 -	ctx->connected = false;
 -	ctx->dev = &pdev->dev;
 -	ctx->card = card;
 -	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 -	strcpy(card->driver, INTEL_HAD);
 -	strcpy(card->shortname, "Intel HDMI/DP LPE Audio");
 -	strcpy(card->longname, "Intel HDMI/DP LPE Audio");
 -
 -	ctx->irq = -1;
 -	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
 -	INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
 -
 -	card->private_free = hdmi_lpe_audio_free;
 -
 -	/* assume pipe A as default */
 -	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -
 -	platform_set_drvdata(pdev, ctx);
 -
 -	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
 -		__func__, (unsigned int)res_mmio->start,
 -		(unsigned int)res_mmio->end);
 -
 -	ctx->mmio_start = ioremap_nocache(res_mmio->start,
 -					  (size_t)(resource_size(res_mmio)));
 -	if (!ctx->mmio_start) {
 -		dev_err(&pdev->dev, "Could not get ioremap\n");
 -		ret = -EACCES;
 -		goto err;
 -	}
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
  
 -	/* setup interrupt handler */
 -	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
 -			  pdev->name, ctx);
 -	if (ret < 0) {
 -		dev_err(&pdev->dev, "request_irq failed\n");
 -		goto err;
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 -	ctx->irq = irq;
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
  
 -	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 -			  MAX_CAP_STREAMS, &pcm);
 -	if (ret)
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
 +
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
* Unmerged path drivers/gpu/drm/i915/intel_lpe_audio.c
* Unmerged path include/drm/intel_lpe_audio.h
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_audio.c
* Unmerged path drivers/gpu/drm/i915/intel_lpe_audio.c
* Unmerged path include/drm/intel_lpe_audio.h
* Unmerged path sound/x86/intel_hdmi_audio.c
