x86/mm/pkeys: Add PTE bits for storing protection key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mm/pkeys: Add PTE bits for storing protection key (Rui Wang) [1272615]
Rebuild_FUZZ: 96.08%
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit 5c1d90f51027e197e1299ab1235a2fed78910905
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5c1d90f5.failed

Previous documentation has referred to these 4 bits as "ignored".
That means that software could have made use of them.  But, as
far as I know, the kernel never used them.

They are still ignored when protection keys is not enabled, so
they could theoretically still get used for software purposes.

We also implement "empty" versions so that code that references
to them can be optimized away by the compiler when the config
option is not enabled.

	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave@sr71.net>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/20160212210205.81E33ED6@viggo.jf.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 5c1d90f51027e197e1299ab1235a2fed78910905)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/pgtable_types.h
diff --cc arch/x86/include/asm/pgtable_types.h
index b8078b5f1b11,cae10ba3c975..000000000000
--- a/arch/x86/include/asm/pgtable_types.h
+++ b/arch/x86/include/asm/pgtable_types.h
@@@ -16,16 -16,22 +16,31 @@@
  #define _PAGE_BIT_PSE		7	/* 4 MB (or 2MB) page */
  #define _PAGE_BIT_PAT		7	/* on 4KB pages */
  #define _PAGE_BIT_GLOBAL	8	/* Global TLB entry PPro+ */
 -#define _PAGE_BIT_SOFTW1	9	/* available for programmer */
 -#define _PAGE_BIT_SOFTW2	10	/* " */
 -#define _PAGE_BIT_SOFTW3	11	/* " */
 +#define _PAGE_BIT_UNUSED1	9	/* available for programmer */
 +#define _PAGE_BIT_IOMAP		10	/* flag used to indicate IO mapping */
 +#define _PAGE_BIT_HIDDEN	11	/* hidden by kmemcheck */
  #define _PAGE_BIT_PAT_LARGE	12	/* On 2MB or 1GB pages */
++<<<<<<< HEAD
 +#define _PAGE_BIT_SPECIAL	_PAGE_BIT_UNUSED1
 +#define _PAGE_BIT_CPA_TEST	_PAGE_BIT_UNUSED1
 +#define _PAGE_BIT_SPLITTING	_PAGE_BIT_UNUSED1 /* only valid on a PSE pmd */
 +#define _PAGE_BIT_SOFTW4	58	/* available for programmer */
 +#define _PAGE_BIT_DEVMAP		_PAGE_BIT_SOFTW4
 +#define _PAGE_BIT_NX		63	/* No execute: only valid after cpuid check */
++=======
+ #define _PAGE_BIT_SOFTW4	58	/* available for programmer */
+ #define _PAGE_BIT_PKEY_BIT0	59	/* Protection Keys, bit 1/4 */
+ #define _PAGE_BIT_PKEY_BIT1	60	/* Protection Keys, bit 2/4 */
+ #define _PAGE_BIT_PKEY_BIT2	61	/* Protection Keys, bit 3/4 */
+ #define _PAGE_BIT_PKEY_BIT3	62	/* Protection Keys, bit 4/4 */
+ #define _PAGE_BIT_NX		63	/* No execute: only valid after cpuid check */
+ 
+ #define _PAGE_BIT_SPECIAL	_PAGE_BIT_SOFTW1
+ #define _PAGE_BIT_CPA_TEST	_PAGE_BIT_SOFTW1
+ #define _PAGE_BIT_HIDDEN	_PAGE_BIT_SOFTW3 /* hidden by kmemcheck */
+ #define _PAGE_BIT_SOFT_DIRTY	_PAGE_BIT_SOFTW3 /* software dirty tracking */
+ #define _PAGE_BIT_DEVMAP	_PAGE_BIT_SOFTW4
++>>>>>>> 5c1d90f51027 (x86/mm/pkeys: Add PTE bits for storing protection key)
  
  /* If _PAGE_BIT_PRESENT is clear, we use these: */
  /* - if the user mapped it with PROT_NONE; pte_present gives true */
@@@ -53,20 -52,19 +68,34 @@@
  #define _PAGE_PAT_LARGE (_AT(pteval_t, 1) << _PAGE_BIT_PAT_LARGE)
  #define _PAGE_SPECIAL	(_AT(pteval_t, 1) << _PAGE_BIT_SPECIAL)
  #define _PAGE_CPA_TEST	(_AT(pteval_t, 1) << _PAGE_BIT_CPA_TEST)
++<<<<<<< HEAD
 +#define _PAGE_SPLITTING	(_AT(pteval_t, 1) << _PAGE_BIT_SPLITTING)
++=======
+ #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
+ #define _PAGE_PKEY_BIT0	(_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT0)
+ #define _PAGE_PKEY_BIT1	(_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT1)
+ #define _PAGE_PKEY_BIT2	(_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT2)
+ #define _PAGE_PKEY_BIT3	(_AT(pteval_t, 1) << _PAGE_BIT_PKEY_BIT3)
+ #else
+ #define _PAGE_PKEY_BIT0	(_AT(pteval_t, 0))
+ #define _PAGE_PKEY_BIT1	(_AT(pteval_t, 0))
+ #define _PAGE_PKEY_BIT2	(_AT(pteval_t, 0))
+ #define _PAGE_PKEY_BIT3	(_AT(pteval_t, 0))
+ #endif
++>>>>>>> 5c1d90f51027 (x86/mm/pkeys: Add PTE bits for storing protection key)
  #define __HAVE_ARCH_PTE_SPECIAL
  
 +#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
 +#define _PAGE_KNL_ERRATUM_MASK (_PAGE_DIRTY | _PAGE_ACCESSED)
 +#else
 +/*
 + * With 32-bit PTEs, _PAGE_DIRTY is used to denote a nonlinear
 + * PTE.  We must not clear the bit.  We do not allow 32-bit
 + * kernels to run on KNL
 + */
 +#define _PAGE_KNL_ERRATUM_MASK 0
 +#endif
 +
  #ifdef CONFIG_KMEMCHECK
  #define _PAGE_HIDDEN	(_AT(pteval_t, 1) << _PAGE_BIT_HIDDEN)
  #else
* Unmerged path arch/x86/include/asm/pgtable_types.h
