ext4: preserve i_mode if __ext4_set_acl() fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ernesto A. Fernández <ernesto.mnd.fernandez@gmail.com>
commit 397e434176bb62bc6068d2210af1d876c6212a7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/397e4341.failed

When changing a file's acl mask, __ext4_set_acl() will first set the group
bits of i_mode to the value of the mask, and only then set the actual
extended attribute representing the new acl.

If the second part fails (due to lack of space, for example) and the file
had no acl attribute to begin with, the system will from now on assume
that the mask permission bits are actual group permission bits, potentially
granting access to the wrong users.

Prevent this by only changing the inode mode after the acl has been set.

	Signed-off-by: Ernesto A. Fernández <ernesto.mnd.fernandez@gmail.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 397e434176bb62bc6068d2210af1d876c6212a7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/acl.c
diff --cc fs/ext4/acl.c
index c844f1bfb451,2985cd0a640d..000000000000
--- a/fs/ext4/acl.c
+++ b/fs/ext4/acl.c
@@@ -203,19 -189,17 +203,25 @@@ ext4_set_acl(handle_t *handle, struct i
  	void *value = NULL;
  	size_t size = 0;
  	int error;
+ 	int update_mode = 0;
+ 	umode_t mode = inode->i_mode;
  
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
 +
  	switch (type) {
  	case ACL_TYPE_ACCESS:
  		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
  		if (acl) {
- 			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ 			error = posix_acl_update_mode(inode, &mode, &acl);
  			if (error)
  				return error;
++<<<<<<< HEAD
 +			inode->i_ctime = ext4_current_time(inode);
 +			ext4_mark_inode_dirty(handle, inode);
++=======
+ 			update_mode = 1;
++>>>>>>> 397e434176bb (ext4: preserve i_mode if __ext4_set_acl() fails)
  		}
  		break;
  
@@@ -235,11 -219,17 +241,17 @@@
  	}
  
  	error = ext4_xattr_set_handle(handle, inode, name_index, "",
 -				      value, size, xattr_flags);
 +				      value, size, 0);
  
  	kfree(value);
- 	if (!error)
+ 	if (!error) {
  		set_cached_acl(inode, type, acl);
+ 		if (update_mode) {
+ 			inode->i_mode = mode;
+ 			inode->i_ctime = current_time(inode);
+ 			ext4_mark_inode_dirty(handle, inode);
+ 		}
+ 	}
  
  	return error;
  }
* Unmerged path fs/ext4/acl.c
