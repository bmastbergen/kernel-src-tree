xfs: track log done items directly in the deferred pending work item

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit ea78d80866ce375defb2fdd1c8a3aafec95e0f85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ea78d808.failed

Christoph reports slab corruption when a deferred refcount update
aborts during _defer_finish().  The cause of this was broken log item
state tracking in xfs_defer_pending -- upon an abort,
_defer_trans_abort() will call abort_intent on all intent items,
including the ones that have already had a done item attached.

This is incorrect because each intent item has 2 refcount: the first
is released when the intent item is committed to the log; and the
second is released when the _done_ item is committed to the log, or
by the intent creator if there is no done item.  In other words, once
we log the done item, responsibility for releasing the intent item's
second refcount is transferred to the done item and /must not/ be
performed by anything else.

The dfp_committed flag should have been tracking whether or not we had
a done item so that _defer_trans_abort could decide if it needs to
abort the intent item, but due to a thinko this was not the case.  Rip
it out and track the done item directly so that we do the right thing
w.r.t. intent item freeing.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reported-by: Christoph Hellwig <hch@infradead.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit ea78d80866ce375defb2fdd1c8a3aafec95e0f85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_defer.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/libxfs/xfs_defer.c
index 2809db75e0d3,c221d0ecd52e..000000000000
--- a/fs/xfs/libxfs/xfs_defer.c
+++ b/fs/xfs/libxfs/xfs_defer.c
@@@ -191,7 -193,8 +191,12 @@@ xfs_defer_trans_abort
  
  	/* Abort intent items. */
  	list_for_each_entry(dfp, &dop->dop_pending, dfp_list) {
++<<<<<<< HEAD
 +		if (dfp->dfp_committed)
++=======
+ 		trace_xfs_defer_pending_abort(tp->t_mountp, dfp);
+ 		if (!dfp->dfp_done)
++>>>>>>> ea78d80866ce (xfs: track log done items directly in the deferred pending work item)
  			dfp->dfp_type->abort_intent(dfp->dfp_intent);
  	}
  
@@@ -301,17 -308,11 +305,25 @@@ xfs_defer_finish
  		if (error)
  			goto out;
  
++<<<<<<< HEAD
 +		/* Mark all pending intents as committed. */
 +		list_for_each_entry_reverse(dfp, &dop->dop_pending, dfp_list) {
 +			if (dfp->dfp_committed)
 +				break;
 +			dfp->dfp_committed = true;
 +		}
 +
 +		/* Log an intent-done item for the first pending item. */
 +		dfp = list_first_entry(&dop->dop_pending,
 +				struct xfs_defer_pending, dfp_list);
 +		done_item = dfp->dfp_type->create_done(*tp, dfp->dfp_intent,
++=======
+ 		/* Log an intent-done item for the first pending item. */
+ 		dfp = list_first_entry(&dop->dop_pending,
+ 				struct xfs_defer_pending, dfp_list);
+ 		trace_xfs_defer_pending_finish((*tp)->t_mountp, dfp);
+ 		dfp->dfp_done = dfp->dfp_type->create_done(*tp, dfp->dfp_intent,
++>>>>>>> ea78d80866ce (xfs: track log done items directly in the deferred pending work item)
  				dfp->dfp_count);
  		cleanup_fn = dfp->dfp_type->finish_cleanup;
  
diff --cc fs/xfs/xfs_trace.h
index e83c100d88de,d303a665dba9..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -2210,6 -2185,379 +2210,382 @@@ DEFINE_DISCARD_EVENT(xfs_discard_toosma
  DEFINE_DISCARD_EVENT(xfs_discard_exclude);
  DEFINE_DISCARD_EVENT(xfs_discard_busy);
  
++<<<<<<< HEAD
++=======
+ /* btree cursor events */
+ DECLARE_EVENT_CLASS(xfs_btree_cur_class,
+ 	TP_PROTO(struct xfs_btree_cur *cur, int level, struct xfs_buf *bp),
+ 	TP_ARGS(cur, level, bp),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_btnum_t, btnum)
+ 		__field(int, level)
+ 		__field(int, nlevels)
+ 		__field(int, ptr)
+ 		__field(xfs_daddr_t, daddr)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = cur->bc_mp->m_super->s_dev;
+ 		__entry->btnum = cur->bc_btnum;
+ 		__entry->level = level;
+ 		__entry->nlevels = cur->bc_nlevels;
+ 		__entry->ptr = cur->bc_ptrs[level];
+ 		__entry->daddr = bp ? bp->b_bn : -1;
+ 	),
+ 	TP_printk("dev %d:%d btnum %d level %d/%d ptr %d daddr 0x%llx",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->btnum,
+ 		  __entry->level,
+ 		  __entry->nlevels,
+ 		  __entry->ptr,
+ 		  (unsigned long long)__entry->daddr)
+ )
+ 
+ #define DEFINE_BTREE_CUR_EVENT(name) \
+ DEFINE_EVENT(xfs_btree_cur_class, name, \
+ 	TP_PROTO(struct xfs_btree_cur *cur, int level, struct xfs_buf *bp), \
+ 	TP_ARGS(cur, level, bp))
+ DEFINE_BTREE_CUR_EVENT(xfs_btree_updkeys);
+ DEFINE_BTREE_CUR_EVENT(xfs_btree_overlapped_query_range);
+ 
+ /* deferred ops */
+ struct xfs_defer_pending;
+ struct xfs_defer_intake;
+ struct xfs_defer_ops;
+ 
+ DECLARE_EVENT_CLASS(xfs_defer_class,
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_defer_ops *dop),
+ 	TP_ARGS(mp, dop),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(void *, dop)
+ 		__field(bool, committed)
+ 		__field(bool, low)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp ? mp->m_super->s_dev : 0;
+ 		__entry->dop = dop;
+ 		__entry->committed = dop->dop_committed;
+ 		__entry->low = dop->dop_low;
+ 	),
+ 	TP_printk("dev %d:%d ops %p committed %d low %d\n",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->dop,
+ 		  __entry->committed,
+ 		  __entry->low)
+ )
+ #define DEFINE_DEFER_EVENT(name) \
+ DEFINE_EVENT(xfs_defer_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_defer_ops *dop), \
+ 	TP_ARGS(mp, dop))
+ 
+ DECLARE_EVENT_CLASS(xfs_defer_error_class,
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_defer_ops *dop, int error),
+ 	TP_ARGS(mp, dop, error),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(void *, dop)
+ 		__field(bool, committed)
+ 		__field(bool, low)
+ 		__field(int, error)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp ? mp->m_super->s_dev : 0;
+ 		__entry->dop = dop;
+ 		__entry->committed = dop->dop_committed;
+ 		__entry->low = dop->dop_low;
+ 		__entry->error = error;
+ 	),
+ 	TP_printk("dev %d:%d ops %p committed %d low %d err %d\n",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->dop,
+ 		  __entry->committed,
+ 		  __entry->low,
+ 		  __entry->error)
+ )
+ #define DEFINE_DEFER_ERROR_EVENT(name) \
+ DEFINE_EVENT(xfs_defer_error_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_defer_ops *dop, int error), \
+ 	TP_ARGS(mp, dop, error))
+ 
+ DECLARE_EVENT_CLASS(xfs_defer_pending_class,
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_defer_pending *dfp),
+ 	TP_ARGS(mp, dfp),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(int, type)
+ 		__field(void *, intent)
+ 		__field(bool, committed)
+ 		__field(int, nr)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp ? mp->m_super->s_dev : 0;
+ 		__entry->type = dfp->dfp_type->type;
+ 		__entry->intent = dfp->dfp_intent;
+ 		__entry->committed = dfp->dfp_done != NULL;
+ 		__entry->nr = dfp->dfp_count;
+ 	),
+ 	TP_printk("dev %d:%d optype %d intent %p committed %d nr %d\n",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->type,
+ 		  __entry->intent,
+ 		  __entry->committed,
+ 		  __entry->nr)
+ )
+ #define DEFINE_DEFER_PENDING_EVENT(name) \
+ DEFINE_EVENT(xfs_defer_pending_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_defer_pending *dfp), \
+ 	TP_ARGS(mp, dfp))
+ 
+ DECLARE_EVENT_CLASS(xfs_phys_extent_deferred_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 int type, xfs_agblock_t agbno, xfs_extlen_t len),
+ 	TP_ARGS(mp, agno, type, agbno, len),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(int, type)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_extlen_t, len)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->type = type;
+ 		__entry->agbno = agbno;
+ 		__entry->len = len;
+ 	),
+ 	TP_printk("dev %d:%d op %d agno %u agbno %u len %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->type,
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->len)
+ );
+ #define DEFINE_PHYS_EXTENT_DEFERRED_EVENT(name) \
+ DEFINE_EVENT(xfs_phys_extent_deferred_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 int type, \
+ 		 xfs_agblock_t bno, \
+ 		 xfs_extlen_t len), \
+ 	TP_ARGS(mp, agno, type, bno, len))
+ 
+ DECLARE_EVENT_CLASS(xfs_map_extent_deferred_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 int op,
+ 		 xfs_agblock_t agbno,
+ 		 xfs_ino_t ino,
+ 		 int whichfork,
+ 		 xfs_fileoff_t offset,
+ 		 xfs_filblks_t len,
+ 		 xfs_exntst_t state),
+ 	TP_ARGS(mp, agno, op, agbno, ino, whichfork, offset, len, state),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_ino_t, ino)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(int, whichfork)
+ 		__field(xfs_fileoff_t, l_loff)
+ 		__field(xfs_filblks_t, l_len)
+ 		__field(xfs_exntst_t, l_state)
+ 		__field(int, op)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->ino = ino;
+ 		__entry->agbno = agbno;
+ 		__entry->whichfork = whichfork;
+ 		__entry->l_loff = offset;
+ 		__entry->l_len = len;
+ 		__entry->l_state = state;
+ 		__entry->op = op;
+ 	),
+ 	TP_printk("dev %d:%d op %d agno %u agbno %u owner %lld %s offset %llu len %llu state %d",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->op,
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->ino,
+ 		  __entry->whichfork == XFS_ATTR_FORK ? "attr" : "data",
+ 		  __entry->l_loff,
+ 		  __entry->l_len,
+ 		  __entry->l_state)
+ );
+ #define DEFINE_MAP_EXTENT_DEFERRED_EVENT(name) \
+ DEFINE_EVENT(xfs_map_extent_deferred_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 int op, \
+ 		 xfs_agblock_t agbno, \
+ 		 xfs_ino_t ino, \
+ 		 int whichfork, \
+ 		 xfs_fileoff_t offset, \
+ 		 xfs_filblks_t len, \
+ 		 xfs_exntst_t state), \
+ 	TP_ARGS(mp, agno, op, agbno, ino, whichfork, offset, len, state))
+ 
+ DEFINE_DEFER_EVENT(xfs_defer_init);
+ DEFINE_DEFER_EVENT(xfs_defer_cancel);
+ DEFINE_DEFER_EVENT(xfs_defer_trans_roll);
+ DEFINE_DEFER_EVENT(xfs_defer_trans_abort);
+ DEFINE_DEFER_EVENT(xfs_defer_finish);
+ DEFINE_DEFER_EVENT(xfs_defer_finish_done);
+ 
+ DEFINE_DEFER_ERROR_EVENT(xfs_defer_trans_roll_error);
+ DEFINE_DEFER_ERROR_EVENT(xfs_defer_finish_error);
+ DEFINE_DEFER_ERROR_EVENT(xfs_defer_op_finish_error);
+ 
+ DEFINE_DEFER_PENDING_EVENT(xfs_defer_intake_work);
+ DEFINE_DEFER_PENDING_EVENT(xfs_defer_intake_cancel);
+ DEFINE_DEFER_PENDING_EVENT(xfs_defer_pending_commit);
+ DEFINE_DEFER_PENDING_EVENT(xfs_defer_pending_cancel);
+ DEFINE_DEFER_PENDING_EVENT(xfs_defer_pending_finish);
+ DEFINE_DEFER_PENDING_EVENT(xfs_defer_pending_abort);
+ 
+ #define DEFINE_BMAP_FREE_DEFERRED_EVENT DEFINE_PHYS_EXTENT_DEFERRED_EVENT
+ DEFINE_BMAP_FREE_DEFERRED_EVENT(xfs_bmap_free_defer);
+ DEFINE_BMAP_FREE_DEFERRED_EVENT(xfs_bmap_free_deferred);
+ 
+ /* rmap tracepoints */
+ DECLARE_EVENT_CLASS(xfs_rmap_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 xfs_agblock_t agbno, xfs_extlen_t len, bool unwritten,
+ 		 struct xfs_owner_info *oinfo),
+ 	TP_ARGS(mp, agno, agbno, len, unwritten, oinfo),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_extlen_t, len)
+ 		__field(uint64_t, owner)
+ 		__field(uint64_t, offset)
+ 		__field(unsigned long, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agbno = agbno;
+ 		__entry->len = len;
+ 		__entry->owner = oinfo->oi_owner;
+ 		__entry->offset = oinfo->oi_offset;
+ 		__entry->flags = oinfo->oi_flags;
+ 		if (unwritten)
+ 			__entry->flags |= XFS_RMAP_UNWRITTEN;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u owner %lld offset %llu flags 0x%lx",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->len,
+ 		  __entry->owner,
+ 		  __entry->offset,
+ 		  __entry->flags)
+ );
+ #define DEFINE_RMAP_EVENT(name) \
+ DEFINE_EVENT(xfs_rmap_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 xfs_agblock_t agbno, xfs_extlen_t len, bool unwritten, \
+ 		 struct xfs_owner_info *oinfo), \
+ 	TP_ARGS(mp, agno, agbno, len, unwritten, oinfo))
+ 
+ /* simple AG-based error/%ip tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_ag_error_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, int error,
+ 		 unsigned long caller_ip),
+ 	TP_ARGS(mp, agno, error, caller_ip),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(int, error)
+ 		__field(unsigned long, caller_ip)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->error = error;
+ 		__entry->caller_ip = caller_ip;
+ 	),
+ 	TP_printk("dev %d:%d agno %u error %d caller %ps",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->error,
+ 		  (char *)__entry->caller_ip)
+ );
+ 
+ #define DEFINE_AG_ERROR_EVENT(name) \
+ DEFINE_EVENT(xfs_ag_error_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, int error, \
+ 		 unsigned long caller_ip), \
+ 	TP_ARGS(mp, agno, error, caller_ip))
+ 
+ DEFINE_RMAP_EVENT(xfs_rmap_unmap);
+ DEFINE_RMAP_EVENT(xfs_rmap_unmap_done);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_unmap_error);
+ DEFINE_RMAP_EVENT(xfs_rmap_map);
+ DEFINE_RMAP_EVENT(xfs_rmap_map_done);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_map_error);
+ DEFINE_RMAP_EVENT(xfs_rmap_convert);
+ DEFINE_RMAP_EVENT(xfs_rmap_convert_done);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_convert_error);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_convert_state);
+ 
+ DECLARE_EVENT_CLASS(xfs_rmapbt_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 xfs_agblock_t agbno, xfs_extlen_t len,
+ 		 uint64_t owner, uint64_t offset, unsigned int flags),
+ 	TP_ARGS(mp, agno, agbno, len, owner, offset, flags),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_extlen_t, len)
+ 		__field(uint64_t, owner)
+ 		__field(uint64_t, offset)
+ 		__field(unsigned int, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agbno = agbno;
+ 		__entry->len = len;
+ 		__entry->owner = owner;
+ 		__entry->offset = offset;
+ 		__entry->flags = flags;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u owner %lld offset %llu flags 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->len,
+ 		  __entry->owner,
+ 		  __entry->offset,
+ 		  __entry->flags)
+ );
+ #define DEFINE_RMAPBT_EVENT(name) \
+ DEFINE_EVENT(xfs_rmapbt_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 xfs_agblock_t agbno, xfs_extlen_t len, \
+ 		 uint64_t owner, uint64_t offset, unsigned int flags), \
+ 	TP_ARGS(mp, agno, agbno, len, owner, offset, flags))
+ 
+ #define DEFINE_RMAP_DEFERRED_EVENT DEFINE_MAP_EXTENT_DEFERRED_EVENT
+ DEFINE_RMAP_DEFERRED_EVENT(xfs_rmap_defer);
+ DEFINE_RMAP_DEFERRED_EVENT(xfs_rmap_deferred);
+ 
+ DEFINE_BUSY_EVENT(xfs_rmapbt_alloc_block);
+ DEFINE_BUSY_EVENT(xfs_rmapbt_free_block);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_update);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_insert);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_delete);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_insert_error);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_delete_error);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_update_error);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_lookup_le_range_result);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_find_right_neighbor_result);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_find_left_neighbor_result);
+ 
++>>>>>>> ea78d80866ce (xfs: track log done items directly in the deferred pending work item)
  #endif /* _TRACE_XFS_H */
  
  #undef TRACE_INCLUDE_PATH
* Unmerged path fs/xfs/libxfs/xfs_defer.c
diff --git a/fs/xfs/libxfs/xfs_defer.h b/fs/xfs/libxfs/xfs_defer.h
index 8d2508640121..692fc3cca645 100644
--- a/fs/xfs/libxfs/xfs_defer.h
+++ b/fs/xfs/libxfs/xfs_defer.h
@@ -30,8 +30,8 @@ struct xfs_defer_op_type;
 struct xfs_defer_pending {
 	const struct xfs_defer_op_type	*dfp_type;	/* function pointers */
 	struct list_head		dfp_list;	/* pending items */
-	bool				dfp_committed;	/* committed trans? */
 	void				*dfp_intent;	/* log intent item */
+	void				*dfp_done;	/* log done item */
 	struct list_head		dfp_work;	/* work items */
 	unsigned int			dfp_count;	/* # extent items */
 };
* Unmerged path fs/xfs/xfs_trace.h
