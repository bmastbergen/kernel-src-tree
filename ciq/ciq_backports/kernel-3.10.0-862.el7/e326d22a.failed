scsi: qla2xxx: Enable Target Multi Queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Enable Target Multi Queue (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 91.89%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit e326d22af9653dd8eff05d71f0d1bad9174578a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e326d22a.failed

Enable Multi Queue for Target mode. At Initiator LUN scan time, each LUN
is assign to a QPair. Each QPair is affinitize to certain CPU. When new
cmd arrives from the wire, the lunid is used to search for qpair. The
qpair's affinitized cpuid will be used to queue up the work element.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit e326d22af9653dd8eff05d71f0d1bad9174578a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_inline.h
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,005ca2de3795..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2894,6 -3245,14 +2894,17 @@@ struct req_que 
  struct qla_qpair {
  	spinlock_t qp_lock;
  	atomic_t ref_count;
++<<<<<<< HEAD
++=======
+ 	uint32_t lun_cnt;
+ 	/*
+ 	 * For qpair 0, qp_lock_ptr will point at hardware_lock due to
+ 	 * legacy code. For other Qpair(s), it will point at qp_lock.
+ 	 */
+ 	spinlock_t *qp_lock_ptr;
+ 	struct scsi_qla_host *vha;
+ 
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  	/* distill these fields down to 'online=0/1'
  	 * ha->flags.eeh_busy
  	 * ha->flags.pci_channel_io_perm_failure
@@@ -2919,13 -3275,8 +2930,18 @@@
  	struct qla_hw_data *hw;
  	struct work_struct q_work;
  	struct list_head qp_list_elem; /* vha->qp_list */
++<<<<<<< HEAD
 +};
 +
 +struct qla_percpu_qp_hint {
 +	int change_in_progress;
 +	struct qla_qpair *qp;
 +	int redirect_to_cpuid;
 +	struct qla_qpair *alternate_qp;
++=======
+ 	struct list_head hints_list;
+ 	uint16_t cpuid;
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  };
  
  /* Place holder for FW buffer parameters */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,4366b12b0e6d..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -6708,6 -7666,9 +6709,12 @@@ struct qla_qpair *qla2xxx_create_qpair(
  
  		qpair->req = ha->req_q_map[req_id];
  		qpair->rsp->req = qpair->req;
++<<<<<<< HEAD
++=======
+ 		qpair->rsp->qpair = qpair;
+ 		/* init qpair to this cpu. Will adjust at run time. */
+ 		qla_cpu_update(qpair, smp_processor_id());
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  
  		if (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {
  			if (ha->fw_attributes & BIT_4)
diff --cc drivers/scsi/qla2xxx/qla_inline.h
index 0ac13772fc47,bd8cb796f64e..000000000000
--- a/drivers/scsi/qla2xxx/qla_inline.h
+++ b/drivers/scsi/qla2xxx/qla_inline.h
@@@ -308,3 -308,47 +308,50 @@@ qla2x00_set_retry_delay_timestamp(fc_po
  		fcport->retry_delay_timestamp = jiffies +
  		    (retry_delay * HZ / 10);
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline bool
+ qla_is_exch_offld_enabled(struct scsi_qla_host *vha)
+ {
+ 	if (qla_ini_mode_enabled(vha) &&
+ 	    (ql2xiniexchg > FW_DEF_EXCHANGES_CNT))
+ 		return true;
+ 	else if (qla_tgt_mode_enabled(vha) &&
+ 	    (ql2xexchoffld > FW_DEF_EXCHANGES_CNT))
+ 		return true;
+ 	else if (qla_dual_mode_enabled(vha) &&
+ 	    ((ql2xiniexchg + ql2xexchoffld) > FW_DEF_EXCHANGES_CNT))
+ 		return true;
+ 	else
+ 		return false;
+ }
+ 
+ static inline void
+ qla_cpu_update(struct qla_qpair *qpair, uint16_t cpuid)
+ {
+ 	qpair->cpuid = cpuid;
+ 
+ 	if (!list_empty(&qpair->hints_list)) {
+ 		struct qla_qpair_hint *h;
+ 
+ 		list_for_each_entry(h, &qpair->hints_list, hint_elem)
+ 			h->cpuid = qpair->cpuid;
+ 	}
+ }
+ 
+ static inline struct qla_qpair_hint *
+ qla_qpair_to_hint(struct qla_tgt *tgt, struct qla_qpair *qpair)
+ {
+ 	struct qla_qpair_hint *h;
+ 	u16 i;
+ 
+ 	for (i = 0; i < tgt->ha->max_qpairs + 1; i++) {
+ 		h = &tgt->qphints[i];
+ 		if (h->qpair == qpair)
+ 			return h;
+ 	}
+ 
+ 	return NULL;
+ }
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index d71223f09c1c,9eb946cc8297..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -9,6 -9,8 +9,11 @@@
  
  #include <linux/delay.h>
  #include <linux/slab.h>
++<<<<<<< HEAD
++=======
+ #include <linux/cpu.h>
+ #include <linux/t10-pi.h>
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  #include <scsi/scsi_tcq.h>
  #include <scsi/scsi_bsg_fc.h>
  #include <scsi/scsi_eh.h>
@@@ -2558,16 -2759,11 +2563,21 @@@ void qla24xx_process_response_queue(str
  	struct sts_entry_24xx *pkt;
  	struct qla_hw_data *ha = vha->hw;
  
 -	if (!ha->flags.fw_started)
 +	if (!vha->flags.online)
  		return;
  
++<<<<<<< HEAD
 +	if (rsp->msix && rsp->msix->cpuid != smp_processor_id()) {
 +		/* if kernel does not notify qla of IRQ's CPU change,
 +		 * then set it here.
 +		 */
 +		rsp->msix->cpuid = smp_processor_id();
 +		ha->tgt.rspq_vector_cpuid = rsp->msix->cpuid;
 +	}
++=======
+ 	if (rsp->qpair->cpuid != smp_processor_id())
+ 		qla_cpu_update(rsp->qpair, smp_processor_id());
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  
  	while (rsp->ring_ptr->signature != RESPONSE_PROCESSED) {
  		pkt = (struct sts_entry_24xx *)rsp->ring_ptr;
@@@ -3079,7 -3283,7 +3089,11 @@@ qla24xx_enable_msix(struct qla_hw_data 
  		qentry->handle = rsp;
  		rsp->msix = qentry;
  		scnprintf(qentry->name, sizeof(qentry->name),
++<<<<<<< HEAD
 +			msix_entries[i].name);
++=======
+ 		    "qla2xxx%lu_%s", vha->host_no, msix_entries[i].name);
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  		if (IS_P3P_TYPE(ha))
  			ret = request_irq(qentry->vector,
  				qla82xx_msix_entries[i].handler,
@@@ -3103,24 -3307,13 +3117,29 @@@
  		rsp->msix = qentry;
  		qentry->handle = rsp;
  		scnprintf(qentry->name, sizeof(qentry->name),
++<<<<<<< HEAD
 +			msix_entries[QLA_ATIO_VECTOR].name);
++=======
+ 		    "qla2xxx%lu_%s", vha->host_no,
+ 		    msix_entries[QLA_ATIO_VECTOR].name);
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  		qentry->in_use = 1;
  		ret = request_irq(qentry->vector,
  			msix_entries[QLA_ATIO_VECTOR].handler,
- 			0, msix_entries[QLA_ATIO_VECTOR].name, rsp);
+ 			0, qentry->name, rsp);
  		qentry->have_irq = 1;
 +
 +		/* Register for CPU affinity notification. */
 +		irq_set_affinity_notifier(qentry->vector, &qentry->irq_notify);
 +
 +		/* Schedule work (ie. trigger a notification) to read cpu
 +		 * mask for this specific irq.
 +		 * kref_get is required because
 +		* irq_affinity_notify() will do
 +		* kref_put().
 +		*/
 +		kref_get(&qentry->irq_notify.kref);
 +		schedule_work(&qentry->irq_notify.work);
  	}
  
  msix_register_fail:
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 4e0d0a2f9461,3963602aef35..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -347,22 -371,31 +347,42 @@@ static int qla2x00_alloc_queues(struct 
  		goto fail_rsp_map;
  	}
  
+ 	ha->base_qpair = kzalloc(sizeof(struct qla_qpair), GFP_KERNEL);
+ 	if (ha->base_qpair == NULL) {
+ 		ql_log(ql_log_warn, vha, 0x00e0,
+ 		    "Failed to allocate base queue pair memory.\n");
+ 		goto fail_base_qpair;
+ 	}
+ 
+ 	rsp->qpair = ha->base_qpair;
+ 	rsp->req = req;
+ 	ha->base_qpair->req = req;
+ 	ha->base_qpair->rsp = rsp;
+ 	ha->base_qpair->vha = vha;
+ 	ha->base_qpair->qp_lock_ptr = &ha->hardware_lock;
+ 	ha->base_qpair->msix = &ha->msix_entries[QLA_MSIX_RSP_Q];
+ 	INIT_LIST_HEAD(&ha->base_qpair->hints_list);
+ 	qla_cpu_update(rsp->qpair, smp_processor_id());
+ 
  	if (ql2xmqsupport && ha->max_qpairs) {
 -		ha->queue_pair_map = kcalloc(ha->max_qpairs, sizeof(struct qla_qpair *),
 -			GFP_KERNEL);
 +		ha->queue_pair_map = kcalloc(ha->max_qpairs,
 +			sizeof(struct qla_qpair *), GFP_KERNEL);
  		if (!ha->queue_pair_map) {
  			ql_log(ql_log_fatal, vha, 0x0180,
  			    "Unable to allocate memory for queue pair ptrs.\n");
  			goto fail_qpair_map;
  		}
++<<<<<<< HEAD
 +		ha->base_qpair = kzalloc(sizeof(struct qla_qpair), GFP_KERNEL);
 +		if (ha->base_qpair == NULL) {
 +			ql_log(ql_log_warn, vha, 0x0182,
 +			    "Failed to allocate base queue pair memory.\n");
 +			goto fail_base_qpair;
 +		}
 +		ha->base_qpair->req = req;
 +		ha->base_qpair->rsp = rsp;
++=======
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  	}
  
  	/*
@@@ -3066,19 -3127,29 +3086,42 @@@ qla2x00_probe_one(struct pci_dev *pdev
  	    host->can_queue, base_vha->req,
  	    base_vha->mgmt_svr_loop_id, host->sg_tablesize);
  
++<<<<<<< HEAD
 +	if (ha->mqenable && qla_ini_mode_enabled(base_vha)) {
 +		base_vha->qps_hint = alloc_percpu(struct qla_percpu_qp_hint);
 +		ha->wq = alloc_workqueue("qla2xxx_wq", WQ_MEM_RECLAIM, 1);
 +		/* Create start of day qpairs for Block MQ */
 +		if (shost_use_blk_mq(host)) {
 +			cpumask_clear(&cpu_mask);
 +			for (cpu_id = 0; cpu_id < ha->max_qpairs; cpu_id++) {
 +				cpumask_set_cpu(cpu_id, &cpu_mask);
 +				qla2xxx_create_qpair(base_vha, &cpu_mask, 5, 0);
 +				cpumask_clear_cpu(cpu_id, &cpu_mask);
 +			}
++=======
+ 	if (ha->mqenable) {
+ 		bool mq = false;
+ 		bool startit = false;
+ 		ha->wq = alloc_workqueue("qla2xxx_wq", WQ_MEM_RECLAIM, 1);
+ 
+ 		if (QLA_TGT_MODE_ENABLED()) {
+ 			mq = true;
+ 			startit = false;
+ 		}
+ 
+ 		if ((ql2x_ini_mode == QLA2XXX_INI_MODE_ENABLED) &&
+ 		    shost_use_blk_mq(host)) {
+ 			mq = true;
+ 			startit = true;
+ 		}
+ 
+ 		if (mq) {
+ 			/* Create start of day qpairs for Block MQ */
+ 			for (i = 0; i < ha->max_qpairs; i++)
+ 				qla2xxx_create_qpair(base_vha, 5, 0, startit);
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  		}
  	}
 -
  	if (ha->flags.running_gold_fw)
  		goto skip_dpc;
  
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7a27b61e2d53,92e41055e6f8..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1004,14 -1514,40 +1004,44 @@@ EXPORT_SYMBOL(qlt_stop_phase2)
  /* Called from qlt_remove_target() -> qla2x00_remove_one() */
  static void qlt_release(struct qla_tgt *tgt)
  {
++<<<<<<< HEAD
 +	struct qla_hw_data *ha = tgt->ha;
++=======
+ 	scsi_qla_host_t *vha = tgt->vha;
+ 	void *node;
+ 	u64 key = 0;
+ 	u16 i;
+ 	struct qla_qpair_hint *h;
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  
 -	if ((vha->vha_tgt.qla_tgt != NULL) && !tgt->tgt_stop &&
 -	    !tgt->tgt_stopped)
 -		qlt_stop_phase1(tgt);
 -
 -	if ((vha->vha_tgt.qla_tgt != NULL) && !tgt->tgt_stopped)
 +	if ((ha->tgt.qla_tgt != NULL) && !tgt->tgt_stopped)
  		qlt_stop_phase2(tgt);
  
++<<<<<<< HEAD
 +	ha->tgt.qla_tgt = NULL;
++=======
+ 	for (i = 0; i < vha->hw->max_qpairs + 1; i++) {
+ 		unsigned long flags;
+ 
+ 		h = &tgt->qphints[i];
+ 		if (h->qpair) {
+ 			spin_lock_irqsave(h->qpair->qp_lock_ptr, flags);
+ 			list_del(&h->hint_elem);
+ 			spin_unlock_irqrestore(h->qpair->qp_lock_ptr, flags);
+ 			h->qpair = NULL;
+ 		}
+ 	}
+ 	kfree(tgt->qphints);
+ 
+ 	btree_for_each_safe64(&tgt->lun_qpair_map, key, node)
+ 		btree_remove64(&tgt->lun_qpair_map, key);
+ 
+ 	btree_destroy64(&tgt->lun_qpair_map);
+ 
+ 	vha->vha_tgt.qla_tgt = NULL;
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00d,
 +	ql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf00d,
  	    "Release of tgt %p finished\n", tgt);
  
  	kfree(tgt);
@@@ -1594,10 -2377,11 +1624,14 @@@ static int qlt_24xx_build_ctio_pkt(stru
  		 */
  		return -EAGAIN;
  	} else
++<<<<<<< HEAD
 +		ha->tgt.cmds[h-1] = prm->cmd;
++=======
+ 		qpair->req->outstanding_cmds[h] = (srb_t *)prm->cmd;
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  
 -	pkt->handle = MAKE_HANDLE(qpair->req->id, h);
 -	pkt->handle |= CTIO_COMPLETION_HANDLE_MARK;
 -	pkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);
 +	pkt->handle = h | CTIO_COMPLETION_HANDLE_MARK;
 +	pkt->nport_handle = prm->cmd->loop_id;
  	pkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
  	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
  	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
@@@ -2638,45 -3985,18 +2672,49 @@@ static void qlt_do_work(struct work_str
  	if (tgt->tgt_stop)
  		goto out_term;
  
 -	if (cmd->aborted) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf082,
 -		    "cmd with tag %u is aborted\n",
 -		    cmd->atio.u.isp24.exchange_addr);
 -		goto out_term;
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
 +	    atio->u.isp24.fcp_hdr.s_id);
 +	/* Do kref_get() before dropping qla_hw_data->hardware_lock. */
 +	if (sess)
 +		kref_get(&sess->se_sess->sess_kref);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	if (unlikely(!sess)) {
 +		uint8_t *s_id =	atio->u.isp24.fcp_hdr.s_id;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
 +			"qla_target(%d): Unable to find wwn login"
 +			" (s_id %x:%x:%x), trying to create it manually\n",
 +			vha->vp_idx, s_id[0], s_id[1], s_id[2]);
 +
 +		if (atio->u.raw.entry_count > 1) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
 +				"Dropping multy entry cmd %p\n", cmd);
 +			goto out_term;
 +		}
 +
 +		mutex_lock(&ha->tgt.tgt_mutex);
 +		sess = qlt_make_local_sess(vha, s_id);
 +		/* sess has an extra creation ref. */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
 +
 +		if (!sess)
 +			goto out_term;
  	}
  
 -	spin_lock_init(&cmd->cmd_lock);
 +	cmd->sess = sess;
 +	cmd->loop_id = sess->loop_id;
 +	cmd->conf_compl_supported = sess->conf_compl_supported;
 +
  	cdb = &atio->u.isp24.fcp_cmnd.cdb[0];
++<<<<<<< HEAD
 +	cmd->tag = atio->u.isp24.exchange_addr;
 +	cmd->unpacked_lun = scsilun_to_int(
 +	    (struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);
++=======
+ 	cmd->se_cmd.tag = atio->u.isp24.exchange_addr;
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  
  	if (atio->u.isp24.fcp_cmnd.rddata &&
  	    atio->u.isp24.fcp_cmnd.wrdata) {
@@@ -2715,12 -4033,215 +2753,208 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
++=======
+ 	cmd->trc_flags |= TRC_DO_WORK_ERR;
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 	qlt_send_term_exchange(qpair, NULL, &cmd->atio, 1, 0);
+ 
+ 	qlt_decr_num_pend_cmds(vha);
+ 	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ static void qlt_do_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&cmd->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	__qlt_do_work(cmd);
+ }
+ 
+ static void qlt_assign_qpair(struct scsi_qla_host *vha,
+ 	struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_qpair *qpair, *qp;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_qpair_hint *h;
+ 
+ 	if (vha->flags.qpairs_available) {
+ 		h = btree_lookup64(&tgt->lun_qpair_map, cmd->unpacked_lun);
+ 		if (unlikely(!h)) {
+ 			/* spread lun to qpair ratio evently */
+ 			int lcnt = 0, rc;
+ 			struct scsi_qla_host *base_vha =
+ 				pci_get_drvdata(vha->hw->pdev);
+ 
+ 			qpair = vha->hw->base_qpair;
+ 			if (qpair->lun_cnt == 0) {
+ 				qpair->lun_cnt++;
+ 				h = qla_qpair_to_hint(tgt, qpair);
+ 				BUG_ON(!h);
+ 				rc = btree_insert64(&tgt->lun_qpair_map,
+ 					cmd->unpacked_lun, h, GFP_ATOMIC);
+ 				if (rc) {
+ 					qpair->lun_cnt--;
+ 					ql_log(ql_log_info, vha, 0xd037,
+ 					    "Unable to insert lun %llx into lun_qpair_map\n",
+ 					    cmd->unpacked_lun);
+ 				}
+ 				goto out;
+ 			} else {
+ 				lcnt = qpair->lun_cnt;
+ 			}
+ 
+ 			h = NULL;
+ 			list_for_each_entry(qp, &base_vha->qp_list,
+ 			    qp_list_elem) {
+ 				if (qp->lun_cnt == 0) {
+ 					qp->lun_cnt++;
+ 					h = qla_qpair_to_hint(tgt, qp);
+ 					BUG_ON(!h);
+ 					rc = btree_insert64(&tgt->lun_qpair_map,
+ 					    cmd->unpacked_lun, h, GFP_ATOMIC);
+ 					if (rc) {
+ 						qp->lun_cnt--;
+ 						ql_log(ql_log_info, vha, 0xd038,
+ 							"Unable to insert lun %llx into lun_qpair_map\n",
+ 							cmd->unpacked_lun);
+ 					}
+ 					qpair = qp;
+ 					goto out;
+ 				} else {
+ 					if (qp->lun_cnt < lcnt) {
+ 						lcnt = qp->lun_cnt;
+ 						qpair = qp;
+ 						continue;
+ 					}
+ 				}
+ 			}
+ 			BUG_ON(!qpair);
+ 			qpair->lun_cnt++;
+ 			h = qla_qpair_to_hint(tgt, qpair);
+ 			BUG_ON(!h);
+ 			rc = btree_insert64(&tgt->lun_qpair_map,
+ 				cmd->unpacked_lun, h, GFP_ATOMIC);
+ 			if (rc) {
+ 				qpair->lun_cnt--;
+ 				ql_log(ql_log_info, vha, 0xd039,
+ 				   "Unable to insert lun %llx into lun_qpair_map\n",
+ 				   cmd->unpacked_lun);
+ 			}
+ 		}
+ 	} else {
+ 		h = &tgt->qphints[0];
+ 	}
+ out:
+ 	cmd->qpair = h->qpair;
+ 	cmd->se_cmd.cpuid = h->cpuid;
+ }
+ 
+ static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
+ 				       struct fc_port *sess,
+ 				       struct atio_from_isp *atio)
+ {
+ 	struct se_session *se_sess = sess->se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return NULL;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 	cmd->cmd_type = TYPE_TGT_CMD;
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 	cmd->state = QLA_TGT_STATE_NEW;
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	qlt_incr_num_pend_cmds(vha);
+ 	cmd->vha = vha;
+ 	cmd->se_cmd.map_tag = tag;
+ 	cmd->sess = sess;
+ 	cmd->loop_id = sess->loop_id;
+ 	cmd->conf_compl_supported = sess->conf_compl_supported;
+ 
+ 	cmd->trc_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
+ 
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 	cmd->unpacked_lun = scsilun_to_int(
+ 	    (struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);
+ 	qlt_assign_qpair(vha, cmd);
+ 
+ 	return cmd;
+ }
+ 
+ static void qlt_create_sess_from_atio(struct work_struct *work)
+ {
+ 	struct qla_tgt_sess_op *op = container_of(work,
+ 					struct qla_tgt_sess_op, work);
+ 	scsi_qla_host_t *vha = op->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&op->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	if (op->aborted) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+ 		    "sess_op with tag %u is aborted\n",
+ 		    op->atio.u.isp24.exchange_addr);
+ 		goto out_term;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+ 	    "qla_target(%d): Unable to find wwn login"
+ 	    " (s_id %x:%x:%x), trying to create it manually\n",
+ 	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
+ 
+ 	if (op->atio.u.raw.entry_count > 1) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+ 		    "Dropping multy entry atio %p\n", &op->atio);
+ 		goto out_term;
+ 	}
+ 
+ 	sess = qlt_make_local_sess(vha, s_id);
+ 	/* sess has an extra creation ref. */
+ 
+ 	if (!sess)
+ 		goto out_term;
+ 	/*
+ 	 * Now obtain a pre-allocated session tag using the original op->atio
+ 	 * packet header, and dispatch into __qlt_do_work() using the existing
+ 	 * process context.
+ 	 */
+ 	cmd = qlt_get_tag(vha, sess, &op->atio);
+ 	if (!cmd) {
+ 		struct qla_qpair *qpair = ha->base_qpair;
+ 
+ 		spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 		qlt_send_busy(qpair, &op->atio, SAM_STAT_BUSY);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  		ha->tgt.tgt_ops->put_sess(sess);
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -		kfree(op);
 -		return;
 -	}
 -
 -	/*
 -	 * __qlt_do_work() will call qlt_put_sess() to release
 -	 * the extra reference taken above by qlt_make_local_sess()
 -	 */
 -	__qlt_do_work(cmd);
 -	kfree(op);
 -	return;
 -out_term:
 -	qlt_send_term_exchange(vha->hw->base_qpair, NULL, &op->atio, 0, 0);
 -	kfree(op);
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -2744,17 -4306,31 +2978,33 @@@ static int qlt_handle_cmd_for_atio(stru
  		return -ENOMEM;
  	}
  
 -	cmd->cmd_in_wq = 1;
 -	cmd->trc_flags |= TRC_NEW_CMD;
 +	INIT_LIST_HEAD(&cmd->cmd_list);
  
 -	spin_lock_irqsave(&vha->cmd_list_lock, flags);
 -	list_add_tail(&cmd->cmd_list, &vha->qla_cmd_list);
 -	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
 +	memcpy(&cmd->atio, atio, sizeof(*atio));
 +	cmd->state = QLA_TGT_STATE_NEW;
 +	cmd->tgt = ha->tgt.qla_tgt;
 +	cmd->vha = vha;
  
  	INIT_WORK(&cmd->work, qlt_do_work);
++<<<<<<< HEAD
 +	queue_work(qla_tgt_wq, &cmd->work);
++=======
+ 	if (vha->flags.qpairs_available) {
+ 		queue_work_on(cmd->se_cmd.cpuid, qla_tgt_wq, &cmd->work);
+ 	} else if (ha->msix_count) {
+ 		if (cmd->atio.u.isp24.fcp_cmnd.rddata)
+ 			queue_work_on(smp_processor_id(), qla_tgt_wq,
+ 			    &cmd->work);
+ 		else
+ 			queue_work_on(cmd->se_cmd.cpuid, qla_tgt_wq,
+ 			    &cmd->work);
+ 	} else {
+ 		queue_work(qla_tgt_wq, &cmd->work);
+ 	}
+ 
++>>>>>>> e326d22af965 (scsi: qla2xxx: Enable Target Multi Queue)
  	return 0;
 +
  }
  
  /* ha->hardware_lock supposed to be held on entry */
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_inline.h
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0..81c6967c8d10 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -749,10 +749,18 @@ struct qla_port_24xx_data {
 	uint16_t reserved;
 };
 
+struct qla_qpair_hint {
+	struct list_head hint_elem;
+	struct qla_qpair *qpair;
+	u16 cpuid;
+	uint8_t cmd_cnt;
+};
+
 struct qla_tgt {
 	struct scsi_qla_host *vha;
 	struct qla_hw_data *ha;
-
+	struct btree_head64 lun_qpair_map;
+	struct qla_qpair_hint *qphints;
 	/*
 	 * To sync between IRQ handlers and qlt_target_release(). Needed,
 	 * because req_pkt() can drop/reaquire HW lock inside. Protected by
