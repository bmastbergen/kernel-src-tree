bnxt_en: Add ethtool mac loopback self test.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add ethtool mac loopback self test (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.85%
commit-author Michael Chan <michael.chan@broadcom.com>
commit f7dc1ea6c4c1f31371b7098d6fae0d49dc6cdff1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f7dc1ea6.failed

The mac loopback self test operates in polling mode.  To support that,
we need to add functions to open and close the NIC half way.  The half
open mode allows the rings to operate without IRQ and NAPI.  We
use the XDP transmit function to send the loopback packet.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f7dc1ea6c4c1f31371b7098d6fae0d49dc6cdff1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 235aedf756e1,ecb441724b10..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@@ -2181,6 -2178,276 +2182,279 @@@ static int bnxt_set_phys_id(struct net_
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_hwrm_mac_loopback(struct bnxt *bp, bool enable)
+ {
+ 	struct hwrm_port_mac_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_PORT_MAC_CFG, -1, -1);
+ 
+ 	req.enables = cpu_to_le32(PORT_MAC_CFG_REQ_ENABLES_LPBK);
+ 	if (enable)
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_LOCAL;
+ 	else
+ 		req.lpbk = PORT_MAC_CFG_REQ_LPBK_NONE;
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_rx_loopback(struct bnxt *bp, struct bnxt_napi *bnapi,
+ 			    u32 raw_cons, int pkt_size)
+ {
+ 	struct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;
+ 	struct bnxt_rx_ring_info *rxr = bnapi->rx_ring;
+ 	struct bnxt_sw_rx_bd *rx_buf;
+ 	struct rx_cmp *rxcmp;
+ 	u16 cp_cons, cons;
+ 	u8 *data;
+ 	u32 len;
+ 	int i;
+ 
+ 	cp_cons = RING_CMP(raw_cons);
+ 	rxcmp = (struct rx_cmp *)
+ 		&cpr->cp_desc_ring[CP_RING(cp_cons)][CP_IDX(cp_cons)];
+ 	cons = rxcmp->rx_cmp_opaque;
+ 	rx_buf = &rxr->rx_buf_ring[cons];
+ 	data = rx_buf->data_ptr;
+ 	len = le32_to_cpu(rxcmp->rx_cmp_len_flags_type) >> RX_CMP_LEN_SHIFT;
+ 	if (len != pkt_size)
+ 		return -EIO;
+ 	i = ETH_ALEN;
+ 	if (!ether_addr_equal(data + i, bnapi->bp->dev->dev_addr))
+ 		return -EIO;
+ 	i += ETH_ALEN;
+ 	for (  ; i < pkt_size; i++) {
+ 		if (data[i] != (u8)(i & 0xff))
+ 			return -EIO;
+ 	}
+ 	return 0;
+ }
+ 
+ static int bnxt_poll_loopback(struct bnxt *bp, int pkt_size)
+ {
+ 	struct bnxt_napi *bnapi = bp->bnapi[0];
+ 	struct bnxt_cp_ring_info *cpr;
+ 	struct tx_cmp *txcmp;
+ 	int rc = -EIO;
+ 	u32 raw_cons;
+ 	u32 cons;
+ 	int i;
+ 
+ 	cpr = &bnapi->cp_ring;
+ 	raw_cons = cpr->cp_raw_cons;
+ 	for (i = 0; i < 200; i++) {
+ 		cons = RING_CMP(raw_cons);
+ 		txcmp = &cpr->cp_desc_ring[CP_RING(cons)][CP_IDX(cons)];
+ 
+ 		if (!TX_CMP_VALID(txcmp, raw_cons)) {
+ 			udelay(5);
+ 			continue;
+ 		}
+ 
+ 		/* The valid test of the entry must be done first before
+ 		 * reading any further.
+ 		 */
+ 		dma_rmb();
+ 		if (TX_CMP_TYPE(txcmp) == CMP_TYPE_RX_L2_CMP) {
+ 			rc = bnxt_rx_loopback(bp, bnapi, raw_cons, pkt_size);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			raw_cons = NEXT_RAW_CMP(raw_cons);
+ 			break;
+ 		}
+ 		raw_cons = NEXT_RAW_CMP(raw_cons);
+ 	}
+ 	cpr->cp_raw_cons = raw_cons;
+ 	return rc;
+ }
+ 
+ static int bnxt_run_loopback(struct bnxt *bp)
+ {
+ 	struct bnxt_tx_ring_info *txr = &bp->tx_ring[0];
+ 	int pkt_size, i = 0;
+ 	struct sk_buff *skb;
+ 	dma_addr_t map;
+ 	u8 *data;
+ 	int rc;
+ 
+ 	pkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_copy_thresh);
+ 	skb = netdev_alloc_skb(bp->dev, pkt_size);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 	data = skb_put(skb, pkt_size);
+ 	eth_broadcast_addr(data);
+ 	i += ETH_ALEN;
+ 	ether_addr_copy(&data[i], bp->dev->dev_addr);
+ 	i += ETH_ALEN;
+ 	for ( ; i < pkt_size; i++)
+ 		data[i] = (u8)(i & 0xff);
+ 
+ 	map = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,
+ 			     PCI_DMA_TODEVICE);
+ 	if (dma_mapping_error(&bp->pdev->dev, map)) {
+ 		dev_kfree_skb(skb);
+ 		return -EIO;
+ 	}
+ 	bnxt_xmit_xdp(bp, txr, map, pkt_size, 0);
+ 
+ 	/* Sync BD data before updating doorbell */
+ 	wmb();
+ 
+ 	writel(DB_KEY_TX | txr->tx_prod, txr->tx_doorbell);
+ 	writel(DB_KEY_TX | txr->tx_prod, txr->tx_doorbell);
+ 	rc = bnxt_poll_loopback(bp, pkt_size);
+ 
+ 	dma_unmap_single(&bp->pdev->dev, map, pkt_size, PCI_DMA_TODEVICE);
+ 	dev_kfree_skb(skb);
+ 	return rc;
+ }
+ 
+ static int bnxt_run_fw_tests(struct bnxt *bp, u8 test_mask, u8 *test_results)
+ {
+ 	struct hwrm_selftest_exec_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_exec_input req = {0};
+ 	int rc;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_EXEC, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	resp->test_success = 0;
+ 	req.flags = test_mask;
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), bp->test_info->timeout);
+ 	*test_results = resp->test_success;
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ 	return rc;
+ }
+ 
+ #define BNXT_DRV_TESTS			1
+ #define BNXT_MACLPBK_TEST_IDX		(bp->num_tests - BNXT_DRV_TESTS)
+ 
+ static void bnxt_self_test(struct net_device *dev, struct ethtool_test *etest,
+ 			   u64 *buf)
+ {
+ 	struct bnxt *bp = netdev_priv(dev);
+ 	bool offline = false;
+ 	u8 test_results = 0;
+ 	u8 test_mask = 0;
+ 	int rc, i;
+ 
+ 	if (!bp->num_tests || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 	memset(buf, 0, sizeof(u64) * bp->num_tests);
+ 	if (!netif_running(dev)) {
+ 		etest->flags |= ETH_TEST_FL_FAILED;
+ 		return;
+ 	}
+ 
+ 	if (etest->flags & ETH_TEST_FL_OFFLINE) {
+ 		if (bp->pf.active_vfs) {
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			netdev_warn(dev, "Offline tests cannot be run with active VFs\n");
+ 			return;
+ 		}
+ 		offline = true;
+ 	}
+ 
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if (!(bp->test_info->offline_mask & bit_val))
+ 			test_mask |= bit_val;
+ 		else if (offline)
+ 			test_mask |= bit_val;
+ 	}
+ 	if (!offline) {
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 	} else {
+ 		rc = bnxt_close_nic(bp, false, false);
+ 		if (rc)
+ 			return;
+ 		bnxt_run_fw_tests(bp, test_mask, &test_results);
+ 
+ 		buf[BNXT_MACLPBK_TEST_IDX] = 1;
+ 		bnxt_hwrm_mac_loopback(bp, true);
+ 		msleep(250);
+ 		rc = bnxt_half_open_nic(bp);
+ 		if (rc) {
+ 			bnxt_hwrm_mac_loopback(bp, false);
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 			return;
+ 		}
+ 		if (bnxt_run_loopback(bp))
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		else
+ 			buf[BNXT_MACLPBK_TEST_IDX] = 0;
+ 
+ 		bnxt_half_close_nic(bp);
+ 		bnxt_hwrm_mac_loopback(bp, false);
+ 		bnxt_open_nic(bp, false, true);
+ 	}
+ 	for (i = 0; i < bp->num_tests - BNXT_DRV_TESTS; i++) {
+ 		u8 bit_val = 1 << i;
+ 
+ 		if ((test_mask & bit_val) && !(test_results & bit_val)) {
+ 			buf[i] = 1;
+ 			etest->flags |= ETH_TEST_FL_FAILED;
+ 		}
+ 	}
+ }
+ 
+ void bnxt_ethtool_init(struct bnxt *bp)
+ {
+ 	struct hwrm_selftest_qlist_output *resp = bp->hwrm_cmd_resp_addr;
+ 	struct hwrm_selftest_qlist_input req = {0};
+ 	struct bnxt_test_info *test_info;
+ 	int i, rc;
+ 
+ 	if (bp->hwrm_spec_code < 0x10704 || !BNXT_SINGLE_PF(bp))
+ 		return;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_SELFTEST_QLIST, -1, -1);
+ 	mutex_lock(&bp->hwrm_cmd_lock);
+ 	rc = _hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		goto ethtool_init_exit;
+ 
+ 	test_info = kzalloc(sizeof(*bp->test_info), GFP_KERNEL);
+ 	if (!test_info)
+ 		goto ethtool_init_exit;
+ 
+ 	bp->test_info = test_info;
+ 	bp->num_tests = resp->num_tests + BNXT_DRV_TESTS;
+ 	if (bp->num_tests > BNXT_MAX_TEST)
+ 		bp->num_tests = BNXT_MAX_TEST;
+ 
+ 	test_info->offline_mask = resp->offline_tests;
+ 	test_info->timeout = le16_to_cpu(resp->test_timeout);
+ 	if (!test_info->timeout)
+ 		test_info->timeout = HWRM_CMD_TIMEOUT;
+ 	for (i = 0; i < bp->num_tests; i++) {
+ 		char *str = test_info->string[i];
+ 		char *fw_str = resp->test0_name + i * 32;
+ 
+ 		if (i == BNXT_MACLPBK_TEST_IDX) {
+ 			strcpy(str, "Mac loopback test (offline)");
+ 		} else {
+ 			strlcpy(str, fw_str, ETH_GSTRING_LEN);
+ 			strncat(str, " test", ETH_GSTRING_LEN - strlen(str));
+ 			if (test_info->offline_mask & (1 << i))
+ 				strncat(str, " (offline)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 			else
+ 				strncat(str, " (online)",
+ 					ETH_GSTRING_LEN - strlen(str));
+ 		}
+ 	}
+ 
+ ethtool_init_exit:
+ 	mutex_unlock(&bp->hwrm_cmd_lock);
+ }
+ 
+ void bnxt_ethtool_free(struct bnxt *bp)
+ {
+ 	kfree(bp->test_info);
+ 	bp->test_info = NULL;
+ }
+ 
++>>>>>>> f7dc1ea6c4c1 (bnxt_en: Add ethtool mac loopback self test.)
  const struct ethtool_ops bnxt_ethtool_ops = {
  	.get_link_ksettings	= bnxt_get_link_ksettings,
  	.set_link_ksettings	= bnxt_set_link_ksettings,
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.h
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 5289d9d23b48..0421ee3a360d 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -5988,6 +5988,43 @@ int bnxt_open_nic(struct bnxt *bp, bool irq_re_init, bool link_re_init)
 	return rc;
 }
 
+/* rtnl_lock held, open the NIC half way by allocating all resources, but
+ * NAPI, IRQ, and TX are not enabled.  This is mainly used for offline
+ * self tests.
+ */
+int bnxt_half_open_nic(struct bnxt *bp)
+{
+	int rc = 0;
+
+	rc = bnxt_alloc_mem(bp, false);
+	if (rc) {
+		netdev_err(bp->dev, "bnxt_alloc_mem err: %x\n", rc);
+		goto half_open_err;
+	}
+	rc = bnxt_init_nic(bp, false);
+	if (rc) {
+		netdev_err(bp->dev, "bnxt_init_nic err: %x\n", rc);
+		goto half_open_err;
+	}
+	return 0;
+
+half_open_err:
+	bnxt_free_skbs(bp);
+	bnxt_free_mem(bp, false);
+	dev_close(bp->dev);
+	return rc;
+}
+
+/* rtnl_lock held, this call can only be made after a previous successful
+ * call to bnxt_half_open_nic().
+ */
+void bnxt_half_close_nic(struct bnxt *bp)
+{
+	bnxt_hwrm_resource_free(bp, false, false);
+	bnxt_free_skbs(bp);
+	bnxt_free_mem(bp, false);
+}
+
 static int bnxt_open(struct net_device *dev)
 {
 	struct bnxt *bp = netdev_priv(dev);
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.h b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 1ff86ce1c504..9732fb7544d1 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -1208,6 +1208,8 @@ int bnxt_hwrm_alloc_wol_fltr(struct bnxt *bp);
 int bnxt_hwrm_free_wol_fltr(struct bnxt *bp);
 int bnxt_hwrm_fw_set_time(struct bnxt *);
 int bnxt_open_nic(struct bnxt *, bool, bool);
+int bnxt_half_open_nic(struct bnxt *bp);
+void bnxt_half_close_nic(struct bnxt *bp);
 int bnxt_close_nic(struct bnxt *, bool, bool);
 int bnxt_setup_mq_tc(struct net_device *dev, u8 tc);
 int bnxt_get_max_rings(struct bnxt *, int *, int *, bool);
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.h
