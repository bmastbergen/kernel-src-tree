selinux: Add a cache for quicker retreival of PKey SIDs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Daniel Jurgens <danielj@mellanox.com>
commit 409dcf31538ae6ae96b3a0a1d3211e668bfefe8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/409dcf31.failed

It is likely that the SID for the same PKey will be requested many
times. To reduce the time to modify QPs and process MADs use a cache to
store PKey SIDs.

This code is heavily based on the "netif" and "netport" concept
originally developed by James Morris <jmorris@redhat.com> and Paul Moore
<paul@paul-moore.com> (see security/selinux/netif.c and
security/selinux/netport.c for more information)

	Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
	Acked-by: Doug Ledford <dledford@redhat.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 409dcf31538ae6ae96b3a0a1d3211e668bfefe8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
#	security/selinux/include/objsec.h
diff --cc security/selinux/hooks.c
index 7c150cbbfbc6,158f6a005246..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -159,6 -173,16 +160,19 @@@ static int selinux_netcache_avc_callbac
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_lsm_notifier_avc_callback(u32 event)
+ {
+ 	if (event == AVC_CALLBACK_RESET) {
+ 		sel_ib_pkey_flush();
+ 		call_lsm_notifier(LSM_POLICY_CHANGE, NULL);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 409dcf31538a (selinux: Add a cache for quicker retreival of PKey SIDs)
  /*
   * initialise the security for the init task
   */
@@@ -5961,200 -6148,277 +5975,206 @@@ static int selinux_key_getsecurity(stru
  	*_buffer = context;
  	return rc;
  }
 -#endif
  
 -#ifdef CONFIG_SECURITY_INFINIBAND
 -static int selinux_ib_pkey_access(void *ib_sec, u64 subnet_prefix, u16 pkey_val)
 -{
 -	struct common_audit_data ad;
 -	int err;
 -	u32 sid = 0;
 -	struct ib_security_struct *sec = ib_sec;
 -	struct lsm_ibpkey_audit ibpkey;
 +#endif
  
 +static struct security_operations selinux_ops = {
 +	.name =				"selinux",
 +
++<<<<<<< HEAD
 +	.ptrace_access_check =		selinux_ptrace_access_check,
 +	.ptrace_traceme =		selinux_ptrace_traceme,
 +	.capget =			selinux_capget,
 +	.capset =			selinux_capset,
 +	.capable =			selinux_capable,
 +	.quotactl =			selinux_quotactl,
 +	.quota_on =			selinux_quota_on,
 +	.syslog =			selinux_syslog,
 +	.vm_enough_memory =		selinux_vm_enough_memory,
++=======
+ 	err = sel_ib_pkey_sid(subnet_prefix, pkey_val, &sid);
+ 	if (err)
+ 		return err;
++>>>>>>> 409dcf31538a (selinux: Add a cache for quicker retreival of PKey SIDs)
 +
 +	.netlink_send =			selinux_netlink_send,
 +
 +	.bprm_set_creds =		selinux_bprm_set_creds,
 +	.bprm_committing_creds =	selinux_bprm_committing_creds,
 +	.bprm_committed_creds =		selinux_bprm_committed_creds,
 +	.bprm_secureexec =		selinux_bprm_secureexec,
 +
 +	.sb_alloc_security =		selinux_sb_alloc_security,
 +	.sb_free_security =		selinux_sb_free_security,
 +	.sb_copy_data =			selinux_sb_copy_data,
 +	.sb_remount =			selinux_sb_remount,
 +	.sb_kern_mount =		selinux_sb_kern_mount,
 +	.sb_show_options =		selinux_sb_show_options,
 +	.sb_statfs =			selinux_sb_statfs,
 +	.sb_mount =			selinux_mount,
 +	.sb_umount =			selinux_umount,
 +	.sb_set_mnt_opts =		selinux_set_mnt_opts,
 +	.sb_clone_mnt_opts =		selinux_sb_clone_mnt_opts,
 +	.sb_parse_opts_str = 		selinux_parse_opts_str,
 +
 +	.dentry_init_security =		selinux_dentry_init_security,
 +	.dentry_create_files_as =	selinux_dentry_create_files_as,
 +
 +	.inode_alloc_security =		selinux_inode_alloc_security,
 +	.inode_free_security =		selinux_inode_free_security,
 +	.inode_init_security =		selinux_inode_init_security,
 +	.inode_create =			selinux_inode_create,
 +	.inode_link =			selinux_inode_link,
 +	.inode_unlink =			selinux_inode_unlink,
 +	.inode_symlink =		selinux_inode_symlink,
 +	.inode_mkdir =			selinux_inode_mkdir,
 +	.inode_rmdir =			selinux_inode_rmdir,
 +	.inode_mknod =			selinux_inode_mknod,
 +	.inode_rename =			selinux_inode_rename,
 +	.inode_readlink =		selinux_inode_readlink,
 +	.inode_follow_link =		selinux_inode_follow_link,
 +	.inode_permission =		selinux_inode_permission,
 +	.inode_setattr =		selinux_inode_setattr,
 +	.inode_getattr =		selinux_inode_getattr,
 +	.inode_setxattr =		selinux_inode_setxattr,
 +	.inode_post_setxattr =		selinux_inode_post_setxattr,
 +	.inode_getxattr =		selinux_inode_getxattr,
 +	.inode_listxattr =		selinux_inode_listxattr,
 +	.inode_removexattr =		selinux_inode_removexattr,
 +	.inode_getsecurity =		selinux_inode_getsecurity,
 +	.inode_setsecurity =		selinux_inode_setsecurity,
 +	.inode_listsecurity =		selinux_inode_listsecurity,
 +	.inode_getsecid =		selinux_inode_getsecid,
 +	.inode_copy_up =		selinux_inode_copy_up,
 +	.inode_copy_up_xattr =		selinux_inode_copy_up_xattr,
 +
 +	.file_permission =		selinux_file_permission,
 +	.file_alloc_security =		selinux_file_alloc_security,
 +	.file_free_security =		selinux_file_free_security,
 +	.file_ioctl =			selinux_file_ioctl,
 +	.mmap_file =			selinux_mmap_file,
 +	.mmap_addr =			selinux_mmap_addr,
 +	.file_mprotect =		selinux_file_mprotect,
 +	.file_lock =			selinux_file_lock,
 +	.file_fcntl =			selinux_file_fcntl,
 +	.file_set_fowner =		selinux_file_set_fowner,
 +	.file_send_sigiotask =		selinux_file_send_sigiotask,
 +	.file_receive =			selinux_file_receive,
 +
 +	.file_open =			selinux_file_open,
 +
 +	.task_create =			selinux_task_create,
 +	.cred_alloc_blank =		selinux_cred_alloc_blank,
 +	.cred_free =			selinux_cred_free,
 +	.cred_prepare =			selinux_cred_prepare,
 +	.cred_transfer =		selinux_cred_transfer,
 +	.kernel_act_as =		selinux_kernel_act_as,
 +	.kernel_create_files_as =	selinux_kernel_create_files_as,
 +	.kernel_module_request =	selinux_kernel_module_request,
 +	.task_setpgid =			selinux_task_setpgid,
 +	.task_getpgid =			selinux_task_getpgid,
 +	.task_getsid =			selinux_task_getsid,
 +	.task_getsecid =		selinux_task_getsecid,
 +	.task_setnice =			selinux_task_setnice,
 +	.task_setioprio =		selinux_task_setioprio,
 +	.task_getioprio =		selinux_task_getioprio,
 +	.task_setrlimit =		selinux_task_setrlimit,
 +	.task_setscheduler =		selinux_task_setscheduler,
 +	.task_getscheduler =		selinux_task_getscheduler,
 +	.task_movememory =		selinux_task_movememory,
 +	.task_kill =			selinux_task_kill,
 +	.task_wait =			selinux_task_wait,
 +	.task_to_inode =		selinux_task_to_inode,
 +
 +	.ipc_permission =		selinux_ipc_permission,
 +	.ipc_getsecid =			selinux_ipc_getsecid,
 +
 +	.msg_msg_alloc_security =	selinux_msg_msg_alloc_security,
 +	.msg_msg_free_security =	selinux_msg_msg_free_security,
 +
 +	.msg_queue_alloc_security =	selinux_msg_queue_alloc_security,
 +	.msg_queue_free_security =	selinux_msg_queue_free_security,
 +	.msg_queue_associate =		selinux_msg_queue_associate,
 +	.msg_queue_msgctl =		selinux_msg_queue_msgctl,
 +	.msg_queue_msgsnd =		selinux_msg_queue_msgsnd,
 +	.msg_queue_msgrcv =		selinux_msg_queue_msgrcv,
 +
 +	.shm_alloc_security =		selinux_shm_alloc_security,
 +	.shm_free_security =		selinux_shm_free_security,
 +	.shm_associate =		selinux_shm_associate,
 +	.shm_shmctl =			selinux_shm_shmctl,
 +	.shm_shmat =			selinux_shm_shmat,
 +
 +	.sem_alloc_security =		selinux_sem_alloc_security,
 +	.sem_free_security =		selinux_sem_free_security,
 +	.sem_associate =		selinux_sem_associate,
 +	.sem_semctl =			selinux_sem_semctl,
 +	.sem_semop =			selinux_sem_semop,
 +
 +	.d_instantiate =		selinux_d_instantiate,
 +
 +	.getprocattr =			selinux_getprocattr,
 +	.setprocattr =			selinux_setprocattr,
 +
 +	.ismaclabel =			selinux_ismaclabel,
 +	.secid_to_secctx =		selinux_secid_to_secctx,
 +	.secctx_to_secid =		selinux_secctx_to_secid,
 +	.release_secctx =		selinux_release_secctx,
 +	.inode_invalidate_secctx =	selinux_inode_invalidate_secctx,
 +	.inode_notifysecctx =		selinux_inode_notifysecctx,
 +	.inode_setsecctx =		selinux_inode_setsecctx,
 +	.inode_getsecctx =		selinux_inode_getsecctx,
 +
 +	.unix_stream_connect =		selinux_socket_unix_stream_connect,
 +	.unix_may_send =		selinux_socket_unix_may_send,
 +
 +	.socket_create =		selinux_socket_create,
 +	.socket_post_create =		selinux_socket_post_create,
 +	.socket_bind =			selinux_socket_bind,
 +	.socket_connect =		selinux_socket_connect,
 +	.socket_listen =		selinux_socket_listen,
 +	.socket_accept =		selinux_socket_accept,
 +	.socket_sendmsg =		selinux_socket_sendmsg,
 +	.socket_recvmsg =		selinux_socket_recvmsg,
 +	.socket_getsockname =		selinux_socket_getsockname,
 +	.socket_getpeername =		selinux_socket_getpeername,
 +	.socket_getsockopt =		selinux_socket_getsockopt,
 +	.socket_setsockopt =		selinux_socket_setsockopt,
 +	.socket_shutdown =		selinux_socket_shutdown,
 +	.socket_sock_rcv_skb =		selinux_socket_sock_rcv_skb,
 +	.socket_getpeersec_stream =	selinux_socket_getpeersec_stream,
 +	.socket_getpeersec_dgram =	selinux_socket_getpeersec_dgram,
 +	.sk_alloc_security =		selinux_sk_alloc_security,
 +	.sk_free_security =		selinux_sk_free_security,
 +	.sk_clone_security =		selinux_sk_clone_security,
 +	.sk_getsecid =			selinux_sk_getsecid,
 +	.sock_graft =			selinux_sock_graft,
 +	.inet_conn_request =		selinux_inet_conn_request,
 +	.inet_csk_clone =		selinux_inet_csk_clone,
 +	.inet_conn_established =	selinux_inet_conn_established,
 +	.secmark_relabel_packet =	selinux_secmark_relabel_packet,
 +	.secmark_refcount_inc =		selinux_secmark_refcount_inc,
 +	.secmark_refcount_dec =		selinux_secmark_refcount_dec,
 +	.req_classify_flow =		selinux_req_classify_flow,
 +	.tun_dev_alloc_security =	selinux_tun_dev_alloc_security,
 +	.tun_dev_free_security =	selinux_tun_dev_free_security,
 +	.tun_dev_create =		selinux_tun_dev_create,
 +	.tun_dev_attach_queue =		selinux_tun_dev_attach_queue,
 +	.tun_dev_attach =		selinux_tun_dev_attach,
 +	.tun_dev_open =			selinux_tun_dev_open,
 +	.skb_owned_by =			selinux_skb_owned_by,
  
 -	ad.type = LSM_AUDIT_DATA_IBPKEY;
 -	ibpkey.subnet_prefix = subnet_prefix;
 -	ibpkey.pkey = pkey_val;
 -	ad.u.ibpkey = &ibpkey;
 -	return avc_has_perm(sec->sid, sid,
 -			    SECCLASS_INFINIBAND_PKEY,
 -			    INFINIBAND_PKEY__ACCESS, &ad);
 -}
 -
 -static int selinux_ib_endport_manage_subnet(void *ib_sec, const char *dev_name,
 -					    u8 port_num)
 -{
 -	struct common_audit_data ad;
 -	int err;
 -	u32 sid = 0;
 -	struct ib_security_struct *sec = ib_sec;
 -	struct lsm_ibendport_audit ibendport;
 -
 -	err = security_ib_endport_sid(dev_name, port_num, &sid);
 -
 -	if (err)
 -		return err;
 -
 -	ad.type = LSM_AUDIT_DATA_IBENDPORT;
 -	strncpy(ibendport.dev_name, dev_name, sizeof(ibendport.dev_name));
 -	ibendport.port = port_num;
 -	ad.u.ibendport = &ibendport;
 -	return avc_has_perm(sec->sid, sid,
 -			    SECCLASS_INFINIBAND_ENDPORT,
 -			    INFINIBAND_ENDPORT__MANAGE_SUBNET, &ad);
 -}
 -
 -static int selinux_ib_alloc_security(void **ib_sec)
 -{
 -	struct ib_security_struct *sec;
 -
 -	sec = kzalloc(sizeof(*sec), GFP_KERNEL);
 -	if (!sec)
 -		return -ENOMEM;
 -	sec->sid = current_sid();
 -
 -	*ib_sec = sec;
 -	return 0;
 -}
 -
 -static void selinux_ib_free_security(void *ib_sec)
 -{
 -	kfree(ib_sec);
 -}
 -#endif
 -
 -static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
 -	LSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),
 -	LSM_HOOK_INIT(binder_transaction, selinux_binder_transaction),
 -	LSM_HOOK_INIT(binder_transfer_binder, selinux_binder_transfer_binder),
 -	LSM_HOOK_INIT(binder_transfer_file, selinux_binder_transfer_file),
 -
 -	LSM_HOOK_INIT(ptrace_access_check, selinux_ptrace_access_check),
 -	LSM_HOOK_INIT(ptrace_traceme, selinux_ptrace_traceme),
 -	LSM_HOOK_INIT(capget, selinux_capget),
 -	LSM_HOOK_INIT(capset, selinux_capset),
 -	LSM_HOOK_INIT(capable, selinux_capable),
 -	LSM_HOOK_INIT(quotactl, selinux_quotactl),
 -	LSM_HOOK_INIT(quota_on, selinux_quota_on),
 -	LSM_HOOK_INIT(syslog, selinux_syslog),
 -	LSM_HOOK_INIT(vm_enough_memory, selinux_vm_enough_memory),
 -
 -	LSM_HOOK_INIT(netlink_send, selinux_netlink_send),
 -
 -	LSM_HOOK_INIT(bprm_set_creds, selinux_bprm_set_creds),
 -	LSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),
 -	LSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),
 -	LSM_HOOK_INIT(bprm_secureexec, selinux_bprm_secureexec),
 -
 -	LSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),
 -	LSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),
 -	LSM_HOOK_INIT(sb_copy_data, selinux_sb_copy_data),
 -	LSM_HOOK_INIT(sb_remount, selinux_sb_remount),
 -	LSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),
 -	LSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),
 -	LSM_HOOK_INIT(sb_statfs, selinux_sb_statfs),
 -	LSM_HOOK_INIT(sb_mount, selinux_mount),
 -	LSM_HOOK_INIT(sb_umount, selinux_umount),
 -	LSM_HOOK_INIT(sb_set_mnt_opts, selinux_set_mnt_opts),
 -	LSM_HOOK_INIT(sb_clone_mnt_opts, selinux_sb_clone_mnt_opts),
 -	LSM_HOOK_INIT(sb_parse_opts_str, selinux_parse_opts_str),
 -
 -	LSM_HOOK_INIT(dentry_init_security, selinux_dentry_init_security),
 -	LSM_HOOK_INIT(dentry_create_files_as, selinux_dentry_create_files_as),
 -
 -	LSM_HOOK_INIT(inode_alloc_security, selinux_inode_alloc_security),
 -	LSM_HOOK_INIT(inode_free_security, selinux_inode_free_security),
 -	LSM_HOOK_INIT(inode_init_security, selinux_inode_init_security),
 -	LSM_HOOK_INIT(inode_create, selinux_inode_create),
 -	LSM_HOOK_INIT(inode_link, selinux_inode_link),
 -	LSM_HOOK_INIT(inode_unlink, selinux_inode_unlink),
 -	LSM_HOOK_INIT(inode_symlink, selinux_inode_symlink),
 -	LSM_HOOK_INIT(inode_mkdir, selinux_inode_mkdir),
 -	LSM_HOOK_INIT(inode_rmdir, selinux_inode_rmdir),
 -	LSM_HOOK_INIT(inode_mknod, selinux_inode_mknod),
 -	LSM_HOOK_INIT(inode_rename, selinux_inode_rename),
 -	LSM_HOOK_INIT(inode_readlink, selinux_inode_readlink),
 -	LSM_HOOK_INIT(inode_follow_link, selinux_inode_follow_link),
 -	LSM_HOOK_INIT(inode_permission, selinux_inode_permission),
 -	LSM_HOOK_INIT(inode_setattr, selinux_inode_setattr),
 -	LSM_HOOK_INIT(inode_getattr, selinux_inode_getattr),
 -	LSM_HOOK_INIT(inode_setxattr, selinux_inode_setxattr),
 -	LSM_HOOK_INIT(inode_post_setxattr, selinux_inode_post_setxattr),
 -	LSM_HOOK_INIT(inode_getxattr, selinux_inode_getxattr),
 -	LSM_HOOK_INIT(inode_listxattr, selinux_inode_listxattr),
 -	LSM_HOOK_INIT(inode_removexattr, selinux_inode_removexattr),
 -	LSM_HOOK_INIT(inode_getsecurity, selinux_inode_getsecurity),
 -	LSM_HOOK_INIT(inode_setsecurity, selinux_inode_setsecurity),
 -	LSM_HOOK_INIT(inode_listsecurity, selinux_inode_listsecurity),
 -	LSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),
 -	LSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),
 -	LSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),
 -
 -	LSM_HOOK_INIT(file_permission, selinux_file_permission),
 -	LSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),
 -	LSM_HOOK_INIT(file_free_security, selinux_file_free_security),
 -	LSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),
 -	LSM_HOOK_INIT(mmap_file, selinux_mmap_file),
 -	LSM_HOOK_INIT(mmap_addr, selinux_mmap_addr),
 -	LSM_HOOK_INIT(file_mprotect, selinux_file_mprotect),
 -	LSM_HOOK_INIT(file_lock, selinux_file_lock),
 -	LSM_HOOK_INIT(file_fcntl, selinux_file_fcntl),
 -	LSM_HOOK_INIT(file_set_fowner, selinux_file_set_fowner),
 -	LSM_HOOK_INIT(file_send_sigiotask, selinux_file_send_sigiotask),
 -	LSM_HOOK_INIT(file_receive, selinux_file_receive),
 -
 -	LSM_HOOK_INIT(file_open, selinux_file_open),
 -
 -	LSM_HOOK_INIT(task_alloc, selinux_task_alloc),
 -	LSM_HOOK_INIT(cred_alloc_blank, selinux_cred_alloc_blank),
 -	LSM_HOOK_INIT(cred_free, selinux_cred_free),
 -	LSM_HOOK_INIT(cred_prepare, selinux_cred_prepare),
 -	LSM_HOOK_INIT(cred_transfer, selinux_cred_transfer),
 -	LSM_HOOK_INIT(kernel_act_as, selinux_kernel_act_as),
 -	LSM_HOOK_INIT(kernel_create_files_as, selinux_kernel_create_files_as),
 -	LSM_HOOK_INIT(kernel_module_request, selinux_kernel_module_request),
 -	LSM_HOOK_INIT(kernel_read_file, selinux_kernel_read_file),
 -	LSM_HOOK_INIT(task_setpgid, selinux_task_setpgid),
 -	LSM_HOOK_INIT(task_getpgid, selinux_task_getpgid),
 -	LSM_HOOK_INIT(task_getsid, selinux_task_getsid),
 -	LSM_HOOK_INIT(task_getsecid, selinux_task_getsecid),
 -	LSM_HOOK_INIT(task_setnice, selinux_task_setnice),
 -	LSM_HOOK_INIT(task_setioprio, selinux_task_setioprio),
 -	LSM_HOOK_INIT(task_getioprio, selinux_task_getioprio),
 -	LSM_HOOK_INIT(task_prlimit, selinux_task_prlimit),
 -	LSM_HOOK_INIT(task_setrlimit, selinux_task_setrlimit),
 -	LSM_HOOK_INIT(task_setscheduler, selinux_task_setscheduler),
 -	LSM_HOOK_INIT(task_getscheduler, selinux_task_getscheduler),
 -	LSM_HOOK_INIT(task_movememory, selinux_task_movememory),
 -	LSM_HOOK_INIT(task_kill, selinux_task_kill),
 -	LSM_HOOK_INIT(task_to_inode, selinux_task_to_inode),
 -
 -	LSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),
 -	LSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),
 -
 -	LSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),
 -	LSM_HOOK_INIT(msg_msg_free_security, selinux_msg_msg_free_security),
 -
 -	LSM_HOOK_INIT(msg_queue_alloc_security,
 -			selinux_msg_queue_alloc_security),
 -	LSM_HOOK_INIT(msg_queue_free_security, selinux_msg_queue_free_security),
 -	LSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),
 -	LSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),
 -	LSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),
 -	LSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),
 -
 -	LSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),
 -	LSM_HOOK_INIT(shm_free_security, selinux_shm_free_security),
 -	LSM_HOOK_INIT(shm_associate, selinux_shm_associate),
 -	LSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),
 -	LSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),
 -
 -	LSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),
 -	LSM_HOOK_INIT(sem_free_security, selinux_sem_free_security),
 -	LSM_HOOK_INIT(sem_associate, selinux_sem_associate),
 -	LSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),
 -	LSM_HOOK_INIT(sem_semop, selinux_sem_semop),
 -
 -	LSM_HOOK_INIT(d_instantiate, selinux_d_instantiate),
 -
 -	LSM_HOOK_INIT(getprocattr, selinux_getprocattr),
 -	LSM_HOOK_INIT(setprocattr, selinux_setprocattr),
 -
 -	LSM_HOOK_INIT(ismaclabel, selinux_ismaclabel),
 -	LSM_HOOK_INIT(secid_to_secctx, selinux_secid_to_secctx),
 -	LSM_HOOK_INIT(secctx_to_secid, selinux_secctx_to_secid),
 -	LSM_HOOK_INIT(release_secctx, selinux_release_secctx),
 -	LSM_HOOK_INIT(inode_invalidate_secctx, selinux_inode_invalidate_secctx),
 -	LSM_HOOK_INIT(inode_notifysecctx, selinux_inode_notifysecctx),
 -	LSM_HOOK_INIT(inode_setsecctx, selinux_inode_setsecctx),
 -	LSM_HOOK_INIT(inode_getsecctx, selinux_inode_getsecctx),
 -
 -	LSM_HOOK_INIT(unix_stream_connect, selinux_socket_unix_stream_connect),
 -	LSM_HOOK_INIT(unix_may_send, selinux_socket_unix_may_send),
 -
 -	LSM_HOOK_INIT(socket_create, selinux_socket_create),
 -	LSM_HOOK_INIT(socket_post_create, selinux_socket_post_create),
 -	LSM_HOOK_INIT(socket_bind, selinux_socket_bind),
 -	LSM_HOOK_INIT(socket_connect, selinux_socket_connect),
 -	LSM_HOOK_INIT(socket_listen, selinux_socket_listen),
 -	LSM_HOOK_INIT(socket_accept, selinux_socket_accept),
 -	LSM_HOOK_INIT(socket_sendmsg, selinux_socket_sendmsg),
 -	LSM_HOOK_INIT(socket_recvmsg, selinux_socket_recvmsg),
 -	LSM_HOOK_INIT(socket_getsockname, selinux_socket_getsockname),
 -	LSM_HOOK_INIT(socket_getpeername, selinux_socket_getpeername),
 -	LSM_HOOK_INIT(socket_getsockopt, selinux_socket_getsockopt),
 -	LSM_HOOK_INIT(socket_setsockopt, selinux_socket_setsockopt),
 -	LSM_HOOK_INIT(socket_shutdown, selinux_socket_shutdown),
 -	LSM_HOOK_INIT(socket_sock_rcv_skb, selinux_socket_sock_rcv_skb),
 -	LSM_HOOK_INIT(socket_getpeersec_stream,
 -			selinux_socket_getpeersec_stream),
 -	LSM_HOOK_INIT(socket_getpeersec_dgram, selinux_socket_getpeersec_dgram),
 -	LSM_HOOK_INIT(sk_alloc_security, selinux_sk_alloc_security),
 -	LSM_HOOK_INIT(sk_free_security, selinux_sk_free_security),
 -	LSM_HOOK_INIT(sk_clone_security, selinux_sk_clone_security),
 -	LSM_HOOK_INIT(sk_getsecid, selinux_sk_getsecid),
 -	LSM_HOOK_INIT(sock_graft, selinux_sock_graft),
 -	LSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),
 -	LSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),
 -	LSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),
 -	LSM_HOOK_INIT(secmark_relabel_packet, selinux_secmark_relabel_packet),
 -	LSM_HOOK_INIT(secmark_refcount_inc, selinux_secmark_refcount_inc),
 -	LSM_HOOK_INIT(secmark_refcount_dec, selinux_secmark_refcount_dec),
 -	LSM_HOOK_INIT(req_classify_flow, selinux_req_classify_flow),
 -	LSM_HOOK_INIT(tun_dev_alloc_security, selinux_tun_dev_alloc_security),
 -	LSM_HOOK_INIT(tun_dev_free_security, selinux_tun_dev_free_security),
 -	LSM_HOOK_INIT(tun_dev_create, selinux_tun_dev_create),
 -	LSM_HOOK_INIT(tun_dev_attach_queue, selinux_tun_dev_attach_queue),
 -	LSM_HOOK_INIT(tun_dev_attach, selinux_tun_dev_attach),
 -	LSM_HOOK_INIT(tun_dev_open, selinux_tun_dev_open),
 -#ifdef CONFIG_SECURITY_INFINIBAND
 -	LSM_HOOK_INIT(ib_pkey_access, selinux_ib_pkey_access),
 -	LSM_HOOK_INIT(ib_endport_manage_subnet,
 -		      selinux_ib_endport_manage_subnet),
 -	LSM_HOOK_INIT(ib_alloc_security, selinux_ib_alloc_security),
 -	LSM_HOOK_INIT(ib_free_security, selinux_ib_free_security),
 -#endif
  #ifdef CONFIG_SECURITY_NETWORK_XFRM
 -	LSM_HOOK_INIT(xfrm_policy_alloc_security, selinux_xfrm_policy_alloc),
 -	LSM_HOOK_INIT(xfrm_policy_clone_security, selinux_xfrm_policy_clone),
 -	LSM_HOOK_INIT(xfrm_policy_free_security, selinux_xfrm_policy_free),
 -	LSM_HOOK_INIT(xfrm_policy_delete_security, selinux_xfrm_policy_delete),
 -	LSM_HOOK_INIT(xfrm_state_alloc, selinux_xfrm_state_alloc),
 -	LSM_HOOK_INIT(xfrm_state_alloc_acquire,
 -			selinux_xfrm_state_alloc_acquire),
 -	LSM_HOOK_INIT(xfrm_state_free_security, selinux_xfrm_state_free),
 -	LSM_HOOK_INIT(xfrm_state_delete_security, selinux_xfrm_state_delete),
 -	LSM_HOOK_INIT(xfrm_policy_lookup, selinux_xfrm_policy_lookup),
 -	LSM_HOOK_INIT(xfrm_state_pol_flow_match,
 -			selinux_xfrm_state_pol_flow_match),
 -	LSM_HOOK_INIT(xfrm_decode_session, selinux_xfrm_decode_session),
 +	.xfrm_policy_alloc_security =	selinux_xfrm_policy_alloc,
 +	.xfrm_policy_clone_security =	selinux_xfrm_policy_clone,
 +	.xfrm_policy_free_security =	selinux_xfrm_policy_free,
 +	.xfrm_policy_delete_security =	selinux_xfrm_policy_delete,
 +	.xfrm_state_alloc_security =	selinux_xfrm_state_alloc,
 +	.xfrm_state_free_security =	selinux_xfrm_state_free,
 +	.xfrm_state_delete_security =	selinux_xfrm_state_delete,
 +	.xfrm_policy_lookup =		selinux_xfrm_policy_lookup,
 +	.xfrm_state_pol_flow_match =	selinux_xfrm_state_pol_flow_match,
 +	.xfrm_decode_session =		selinux_xfrm_decode_session,
  #endif
  
  #ifdef CONFIG_KEYS
diff --cc security/selinux/include/objsec.h
index 446c3d13c83f,6ebc61e370ff..000000000000
--- a/security/selinux/include/objsec.h
+++ b/security/selinux/include/objsec.h
@@@ -129,6 -140,16 +129,19 @@@ struct key_security_struct 
  	u32 sid;	/* SID of key */
  };
  
++<<<<<<< HEAD
++=======
+ struct ib_security_struct {
+ 	u32 sid;        /* SID of the queue pair or MAD agent */
+ };
+ 
+ struct pkey_security_struct {
+ 	u64	subnet_prefix; /* Port subnet prefix */
+ 	u16	pkey;	/* PKey number */
+ 	u32	sid;	/* SID of pkey */
+ };
+ 
++>>>>>>> 409dcf31538a (selinux: Add a cache for quicker retreival of PKey SIDs)
  extern unsigned int selinux_checkreqprot;
  
  #endif /* _SELINUX_OBJSEC_H_ */
diff --git a/security/selinux/Makefile b/security/selinux/Makefile
index ad5cd76ec231..4d1017a87f3a 100644
--- a/security/selinux/Makefile
+++ b/security/selinux/Makefile
@@ -5,7 +5,7 @@
 obj-$(CONFIG_SECURITY_SELINUX) := selinux.o
 
 selinux-y := avc.o hooks.o selinuxfs.o netlink.o nlmsgtab.o netif.o \
-	     netnode.o netport.o exports.o \
+	     netnode.o netport.o ibpkey.o exports.o \
 	     ss/ebitmap.o ss/hashtab.o ss/symtab.o ss/sidtab.o ss/avtab.o \
 	     ss/policydb.o ss/services.o ss/conditional.o ss/mls.o ss/status.o
 
* Unmerged path security/selinux/hooks.c
diff --git a/security/selinux/ibpkey.c b/security/selinux/ibpkey.c
new file mode 100644
index 000000000000..e3614ee5f1c0
--- /dev/null
+++ b/security/selinux/ibpkey.c
@@ -0,0 +1,245 @@
+/*
+ * Pkey table
+ *
+ * SELinux must keep a mapping of Infinband PKEYs to labels/SIDs.  This
+ * mapping is maintained as part of the normal policy but a fast cache is
+ * needed to reduce the lookup overhead.
+ *
+ * This code is heavily based on the "netif" and "netport" concept originally
+ * developed by
+ * James Morris <jmorris@redhat.com> and
+ * Paul Moore <paul@paul-moore.com>
+ *   (see security/selinux/netif.c and security/selinux/netport.c for more
+ *   information)
+ *
+ */
+
+/*
+ * (c) Mellanox Technologies, 2016
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/rcupdate.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+
+#include "ibpkey.h"
+#include "objsec.h"
+
+#define SEL_PKEY_HASH_SIZE       256
+#define SEL_PKEY_HASH_BKT_LIMIT   16
+
+struct sel_ib_pkey_bkt {
+	int size;
+	struct list_head list;
+};
+
+struct sel_ib_pkey {
+	struct pkey_security_struct psec;
+	struct list_head list;
+	struct rcu_head rcu;
+};
+
+static LIST_HEAD(sel_ib_pkey_list);
+static DEFINE_SPINLOCK(sel_ib_pkey_lock);
+static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];
+
+/**
+ * sel_ib_pkey_hashfn - Hashing function for the pkey table
+ * @pkey: pkey number
+ *
+ * Description:
+ * This is the hashing function for the pkey table, it returns the bucket
+ * number for the given pkey.
+ *
+ */
+static unsigned int sel_ib_pkey_hashfn(u16 pkey)
+{
+	return (pkey & (SEL_PKEY_HASH_SIZE - 1));
+}
+
+/**
+ * sel_ib_pkey_find - Search for a pkey record
+ * @subnet_prefix: subnet_prefix
+ * @pkey_num: pkey_num
+ *
+ * Description:
+ * Search the pkey table and return the matching record.  If an entry
+ * can not be found in the table return NULL.
+ *
+ */
+static struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)
+{
+	unsigned int idx;
+	struct sel_ib_pkey *pkey;
+
+	idx = sel_ib_pkey_hashfn(pkey_num);
+	list_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {
+		if (pkey->psec.pkey == pkey_num &&
+		    pkey->psec.subnet_prefix == subnet_prefix)
+			return pkey;
+	}
+
+	return NULL;
+}
+
+/**
+ * sel_ib_pkey_insert - Insert a new pkey into the table
+ * @pkey: the new pkey record
+ *
+ * Description:
+ * Add a new pkey record to the hash table.
+ *
+ */
+static void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)
+{
+	unsigned int idx;
+
+	/* we need to impose a limit on the growth of the hash table so check
+	 * this bucket to make sure it is within the specified bounds
+	 */
+	idx = sel_ib_pkey_hashfn(pkey->psec.pkey);
+	list_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);
+	if (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {
+		struct sel_ib_pkey *tail;
+
+		tail = list_entry(
+			rcu_dereference_protected(
+				sel_ib_pkey_hash[idx].list.prev,
+				lockdep_is_held(&sel_ib_pkey_lock)),
+			struct sel_ib_pkey, list);
+		list_del_rcu(&tail->list);
+		kfree_rcu(tail, rcu);
+	} else {
+		sel_ib_pkey_hash[idx].size++;
+	}
+}
+
+/**
+ * sel_ib_pkey_sid_slow - Lookup the SID of a pkey using the policy
+ * @subnet_prefix: subnet prefix
+ * @pkey_num: pkey number
+ * @sid: pkey SID
+ *
+ * Description:
+ * This function determines the SID of a pkey by querying the security
+ * policy.  The result is added to the pkey table to speedup future
+ * queries.  Returns zero on success, negative values on failure.
+ *
+ */
+static int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)
+{
+	int ret;
+	struct sel_ib_pkey *pkey;
+	struct sel_ib_pkey *new = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sel_ib_pkey_lock, flags);
+	pkey = sel_ib_pkey_find(subnet_prefix, pkey_num);
+	if (pkey) {
+		*sid = pkey->psec.sid;
+		spin_unlock_irqrestore(&sel_ib_pkey_lock, flags);
+		return 0;
+	}
+
+	ret = security_ib_pkey_sid(subnet_prefix, pkey_num, sid);
+	if (ret)
+		goto out;
+
+	/* If this memory allocation fails still return 0. The SID
+	 * is valid, it just won't be added to the cache.
+	 */
+	new = kzalloc(sizeof(*new), GFP_ATOMIC);
+	if (!new)
+		goto out;
+
+	new->psec.subnet_prefix = subnet_prefix;
+	new->psec.pkey = pkey_num;
+	new->psec.sid = *sid;
+	sel_ib_pkey_insert(new);
+
+out:
+	spin_unlock_irqrestore(&sel_ib_pkey_lock, flags);
+	return ret;
+}
+
+/**
+ * sel_ib_pkey_sid - Lookup the SID of a PKEY
+ * @subnet_prefix: subnet_prefix
+ * @pkey_num: pkey number
+ * @sid: pkey SID
+ *
+ * Description:
+ * This function determines the SID of a PKEY using the fastest method
+ * possible.  First the pkey table is queried, but if an entry can't be found
+ * then the policy is queried and the result is added to the table to speedup
+ * future queries.  Returns zero on success, negative values on failure.
+ *
+ */
+int sel_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *sid)
+{
+	struct sel_ib_pkey *pkey;
+
+	rcu_read_lock();
+	pkey = sel_ib_pkey_find(subnet_prefix, pkey_num);
+	if (pkey) {
+		*sid = pkey->psec.sid;
+		rcu_read_unlock();
+		return 0;
+	}
+	rcu_read_unlock();
+
+	return sel_ib_pkey_sid_slow(subnet_prefix, pkey_num, sid);
+}
+
+/**
+ * sel_ib_pkey_flush - Flush the entire pkey table
+ *
+ * Description:
+ * Remove all entries from the pkey table
+ *
+ */
+void sel_ib_pkey_flush(void)
+{
+	unsigned int idx;
+	struct sel_ib_pkey *pkey, *pkey_tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sel_ib_pkey_lock, flags);
+	for (idx = 0; idx < SEL_PKEY_HASH_SIZE; idx++) {
+		list_for_each_entry_safe(pkey, pkey_tmp,
+					 &sel_ib_pkey_hash[idx].list, list) {
+			list_del_rcu(&pkey->list);
+			kfree_rcu(pkey, rcu);
+		}
+		sel_ib_pkey_hash[idx].size = 0;
+	}
+	spin_unlock_irqrestore(&sel_ib_pkey_lock, flags);
+}
+
+static __init int sel_ib_pkey_init(void)
+{
+	int iter;
+
+	if (!selinux_enabled)
+		return 0;
+
+	for (iter = 0; iter < SEL_PKEY_HASH_SIZE; iter++) {
+		INIT_LIST_HEAD(&sel_ib_pkey_hash[iter].list);
+		sel_ib_pkey_hash[iter].size = 0;
+	}
+
+	return 0;
+}
+
+subsys_initcall(sel_ib_pkey_init);
diff --git a/security/selinux/include/ibpkey.h b/security/selinux/include/ibpkey.h
new file mode 100644
index 000000000000..b17a19e348e6
--- /dev/null
+++ b/security/selinux/include/ibpkey.h
@@ -0,0 +1,31 @@
+/*
+ * pkey table
+ *
+ * SELinux must keep a mapping of pkeys to labels/SIDs.  This
+ * mapping is maintained as part of the normal policy but a fast cache is
+ * needed to reduce the lookup overhead.
+ *
+ */
+
+/*
+ * (c) Mellanox Technologies, 2016
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _SELINUX_IB_PKEY_H
+#define _SELINUX_IB_PKEY_H
+
+void sel_ib_pkey_flush(void);
+
+int sel_ib_pkey_sid(u64 subnet_prefix, u16 pkey, u32 *sid);
+
+#endif
* Unmerged path security/selinux/include/objsec.h
