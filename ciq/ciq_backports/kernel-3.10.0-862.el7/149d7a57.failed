nfp: xdp: report if program is offloaded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 149d7a572ae124385973bf1c8e4d80b3f07d8bd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/149d7a57.failed

Make use of just added XDP_ATTACHED_HW.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 149d7a572ae124385973bf1c8e4d80b3f07d8bd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,2134493ec8a8..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2600,8 -3274,104 +2600,109 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
++<<<<<<< HEAD
 +static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
++=======
+ static int
+ nfp_net_xdp_setup_drv(struct nfp_net *nn, struct bpf_prog *prog,
+ 		      struct netlink_ext_ack *extack)
+ {
+ 	struct nfp_net_dp *dp;
+ 
+ 	if (!prog == !nn->dp.xdp_prog) {
+ 		WRITE_ONCE(nn->dp.xdp_prog, prog);
+ 		return 0;
+ 	}
+ 
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	dp->xdp_prog = prog;
+ 	dp->num_tx_rings += prog ? nn->dp.num_rx_rings : -nn->dp.num_rx_rings;
+ 	dp->rx_dma_dir = prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;
+ 	dp->rx_dma_off = prog ? XDP_PACKET_HEADROOM - nn->dp.rx_offset : 0;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	return nfp_net_ring_reconfig(nn, dp, extack);
+ }
+ 
+ static int
+ nfp_net_xdp_setup(struct nfp_net *nn, struct bpf_prog *prog, u32 flags,
+ 		  struct netlink_ext_ack *extack)
+ {
+ 	struct bpf_prog *drv_prog, *offload_prog;
+ 	int err;
+ 
+ 	if (nn->xdp_prog && (flags ^ nn->xdp_flags) & XDP_FLAGS_MODES)
+ 		return -EBUSY;
+ 
+ 	/* Load both when no flags set to allow easy activation of driver path
+ 	 * when program is replaced by one which can't be offloaded.
+ 	 */
+ 	drv_prog     = flags & XDP_FLAGS_HW_MODE  ? NULL : prog;
+ 	offload_prog = flags & XDP_FLAGS_DRV_MODE ? NULL : prog;
+ 
+ 	err = nfp_net_xdp_setup_drv(nn, drv_prog, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_app_xdp_offload(nn->app, nn, offload_prog);
+ 	if (err && flags & XDP_FLAGS_HW_MODE)
+ 		return err;
+ 
+ 	if (nn->xdp_prog)
+ 		bpf_prog_put(nn->xdp_prog);
+ 	nn->xdp_prog = prog;
+ 	nn->xdp_flags = flags;
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 	case XDP_SETUP_PROG_HW:
+ 		return nfp_net_xdp_setup(nn, xdp->prog, xdp->flags,
+ 					 xdp->extack);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->xdp_prog;
+ 		if (nn->dp.bpf_offload_xdp)
+ 			xdp->prog_attached = XDP_ATTACHED_HW;
+ 		xdp->prog_id = nn->xdp_prog ? nn->xdp_prog->aux->id : 0;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int nfp_net_set_mac_address(struct net_device *netdev, void *addr)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	struct sockaddr *saddr = addr;
+ 	int err;
+ 
+ 	err = eth_prepare_mac_addr_change(netdev, addr);
+ 	if (err)
+ 		return err;
+ 
+ 	nfp_net_write_mac_addr(nn, saddr->sa_data);
+ 
+ 	err = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_MACADDR);
+ 	if (err)
+ 		return err;
+ 
+ 	eth_commit_mac_addr_change(netdev, addr);
+ 
+ 	return 0;
+ }
+ 
+ const struct net_device_ops nfp_net_netdev_ops = {
++>>>>>>> 149d7a572ae1 (nfp: xdp: report if program is offloaded)
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
