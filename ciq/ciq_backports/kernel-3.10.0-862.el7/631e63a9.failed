vmbus: change to per channel tasklet

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 631e63a9f346cb657761ae22138f294718696501
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/631e63a9.failed

Make the event handling tasklet per channel rather than per-cpu.
This allows for better fairness when getting lots of data on the same
cpu.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 631e63a9f346cb657761ae22138f294718696501)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
#	drivers/hv/connection.c
#	drivers/hv/hv.c
#	drivers/hv/hyperv_vmbus.h
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/channel_mgmt.c
index 8a209b718a7d,2f6270d76b79..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -355,19 -384,15 +359,30 @@@ static void vmbus_release_relid(u32 rel
  
  void hv_event_tasklet_disable(struct vmbus_channel *channel)
  {
++<<<<<<< HEAD
 +	struct tasklet_struct *tasklet;
 +	tasklet = hv_context.event_dpc[channel->target_cpu];
 +	tasklet_disable(tasklet);
++=======
+ 	tasklet_disable(&channel->callback_event);
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
  }
  
  void hv_event_tasklet_enable(struct vmbus_channel *channel)
  {
++<<<<<<< HEAD
 +	struct tasklet_struct *tasklet;
 +	tasklet = hv_context.event_dpc[channel->target_cpu];
 +	tasklet_enable(tasklet);
 +
 +	/* In case there is any pending event */
 +	tasklet_schedule(tasklet);
++=======
+ 	tasklet_enable(&channel->callback_event);
+ 
+ 	/* In case there is any pending event */
+ 	tasklet_schedule(&channel->callback_event);
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
  }
  
  void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid)
diff --cc drivers/hv/connection.c
index 9b72ebcd37bc,27e72dc07e12..000000000000
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@@ -265,29 -260,6 +265,32 @@@ void vmbus_disconnect(void
  }
  
  /*
++<<<<<<< HEAD
 + * Map the given relid to the corresponding channel based on the
 + * per-cpu list of channels that have been affinitized to this CPU.
 + * This will be used in the channel callback path as we can do this
 + * mapping in a lock-free fashion.
 + */
 +static struct vmbus_channel *pcpu_relid2channel(u32 relid)
 +{
 +	struct vmbus_channel *channel;
 +	struct vmbus_channel *found_channel  = NULL;
 +	int cpu = smp_processor_id();
 +	struct list_head *pcpu_head = &hv_context.percpu_list[cpu];
 +
 +	list_for_each_entry(channel, pcpu_head, percpu_list) {
 +		if (channel->offermsg.child_relid == relid) {
 +			found_channel = channel;
 +			break;
 +		}
 +	}
 +
 +	return found_channel;
 +}
 +
 +/*
++=======
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
   * relid2channel - Get the channel object given its
   * child relative id (ie channel id)
   */
@@@ -378,62 -340,6 +371,65 @@@ void vmbus_on_event(unsigned long data
  }
  
  /*
++<<<<<<< HEAD
 + * vmbus_on_event - Handler for events
 + */
 +void vmbus_on_event(unsigned long data)
 +{
 +	u32 dword;
 +	u32 maxdword;
 +	int bit;
 +	u32 relid;
 +	u32 *recv_int_page = NULL;
 +	void *page_addr;
 +	int cpu = smp_processor_id();
 +	union hv_synic_event_flags *event;
 +
 +	if (vmbus_proto_version < VERSION_WIN8) {
 +		maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
 +		recv_int_page = vmbus_connection.recv_int_page;
 +	} else {
 +		/*
 +		 * When the host is win8 and beyond, the event page
 +		 * can be directly checked to get the id of the channel
 +		 * that has the interrupt pending.
 +		 */
 +		maxdword = HV_EVENT_FLAGS_DWORD_COUNT;
 +		page_addr = hv_context.synic_event_page[cpu];
 +		event = (union hv_synic_event_flags *)page_addr +
 +						 VMBUS_MESSAGE_SINT;
 +		recv_int_page = event->flags32;
 +	}
 +
 +
 +
 +	/* Check events */
 +	if (!recv_int_page)
 +		return;
 +	for (dword = 0; dword < maxdword; dword++) {
 +		if (!recv_int_page[dword])
 +			continue;
 +		for (bit = 0; bit < 32; bit++) {
 +			if (sync_test_and_clear_bit(bit,
 +				(unsigned long *)&recv_int_page[dword])) {
 +				relid = (dword << 5) + bit;
 +
 +				if (relid == 0)
 +					/*
 +					 * Special case - vmbus
 +					 * channel protocol msg
 +					 */
 +					continue;
 +
 +				process_chn_event(relid);
 +			}
 +		}
 +	}
 +}
 +
 +/*
++=======
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
   * vmbus_post_msg - Send a msg on the vmbus's message connection
   */
  int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
diff --cc drivers/hv/hv.c
index f6a591c69dfd,665a64f1611e..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -336,22 -152,16 +336,28 @@@ int hv_synic_alloc(void
  	}
  
  	for_each_present_cpu(cpu) {
 -		struct hv_per_cpu_context *hv_cpu
 -			= per_cpu_ptr(hv_context.cpu_context, cpu);
 +		hv_context.event_dpc[cpu] = kmalloc(size, GFP_ATOMIC);
 +		if (hv_context.event_dpc[cpu] == NULL) {
 +			pr_err("Unable to allocate event dpc\n");
 +			goto err;
 +		}
 +		tasklet_init(hv_context.event_dpc[cpu], vmbus_on_event, cpu);
  
++<<<<<<< HEAD
 +		hv_context.msg_dpc[cpu] = kmalloc(size, GFP_ATOMIC);
 +		if (hv_context.msg_dpc[cpu] == NULL) {
 +			pr_err("Unable to allocate event dpc\n");
 +			goto err;
 +		}
 +		tasklet_init(hv_context.msg_dpc[cpu], vmbus_on_msg_dpc, cpu);
++=======
+ 		memset(hv_cpu, 0, sizeof(*hv_cpu));
+ 		tasklet_init(&hv_cpu->msg_dpc,
+ 			     vmbus_on_msg_dpc, (unsigned long) hv_cpu);
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
  
 -		hv_cpu->clk_evt = kzalloc(sizeof(struct clock_event_device),
 -					  GFP_KERNEL);
 -		if (hv_cpu->clk_evt == NULL) {
 +		hv_context.clk_evt[cpu] = kzalloc(ced_size, GFP_ATOMIC);
 +		if (hv_context.clk_evt[cpu] == NULL) {
  			pr_err("Unable to allocate clock event device\n");
  			goto err;
  		}
diff --cc drivers/hv/hyperv_vmbus.h
index c92ad5535c23,558a798c407c..000000000000
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@@ -322,55 -190,32 +322,64 @@@ enum 
  	VMBUS_MESSAGE_SINT		= 2,
  };
  
 -/*
 - * Per cpu state for channel handling
 - */
 -struct hv_per_cpu_context {
 -	void *synic_message_page;
 -	void *synic_event_page;
 -	/*
 -	 * buffer to post messages to the host.
 -	 */
 -	void *post_msg_page;
 +/* #defines */
  
++<<<<<<< HEAD
 +#define HV_PRESENT_BIT			0x80000000
++=======
+ 	/*
+ 	 * Starting with win8, we can take channel interrupts on any CPU;
+ 	 * we will manage the tasklet that handles events messages on a per CPU
+ 	 * basis.
+ 	 */
+ 	struct tasklet_struct msg_dpc;
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
  
 -	/*
 -	 * To optimize the mapping of relid to channel, maintain
 -	 * per-cpu list of the channels based on their CPU affinity.
 -	 */
 -	struct list_head chan_list;
 -	struct clock_event_device *clk_evt;
 +
 +#define HV_CPU_POWER_MANAGEMENT		(1 << 0)
 +#define HV_RECOMMENDATIONS_MAX		4
 +
 +#define HV_X64_MAX			5
 +#define HV_CAPS_MAX			8
 +
 +
 +#define HV_HYPERCALL_PARAM_ALIGN	sizeof(u64)
 +
 +
 +/* Service definitions */
 +
 +#define HV_SERVICE_PARENT_PORT				(0)
 +#define HV_SERVICE_PARENT_CONNECTION			(0)
 +
 +#define HV_SERVICE_CONNECT_RESPONSE_SUCCESS		(0)
 +#define HV_SERVICE_CONNECT_RESPONSE_INVALID_PARAMETER	(1)
 +#define HV_SERVICE_CONNECT_RESPONSE_UNKNOWN_SERVICE	(2)
 +#define HV_SERVICE_CONNECT_RESPONSE_CONNECTION_REJECTED	(3)
 +
 +#define HV_SERVICE_CONNECT_REQUEST_MESSAGE_ID		(1)
 +#define HV_SERVICE_CONNECT_RESPONSE_MESSAGE_ID		(2)
 +#define HV_SERVICE_DISCONNECT_REQUEST_MESSAGE_ID	(3)
 +#define HV_SERVICE_DISCONNECT_RESPONSE_MESSAGE_ID	(4)
 +#define HV_SERVICE_MAX_MESSAGE_ID				(4)
 +
 +#define HV_SERVICE_PROTOCOL_VERSION (0x0010)
 +#define HV_CONNECT_PAYLOAD_BYTE_COUNT 64
 +
 +/* #define VMBUS_REVISION_NUMBER	6 */
 +
 +/* Our local vmbus's port and connection id. Anything >0 is fine */
 +/* #define VMBUS_PORT_ID		11 */
 +
 +/* 628180B8-308D-4c5e-B7DB-1BEB62E62EF4 */
 +static const uuid_le VMBUS_SERVICE_ID = {
 +	.b = {
 +		0xb8, 0x80, 0x81, 0x62, 0x8d, 0x30, 0x5e, 0x4c,
 +		0xb7, 0xdb, 0x1b, 0xeb, 0x62, 0xe6, 0x2e, 0xf4
 +	},
  };
  
 +
 +
  struct hv_context {
  	/* We only support running on top of Hyper-V
  	* So at this point this really can only contain the Hyper-V ID
diff --cc drivers/hv/vmbus_drv.c
index 4aa498db4703,eaf1a10b0245..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -915,10 -885,61 +915,60 @@@ msg_handled
  	vmbus_signal_eom(msg, message_type);
  }
  
+ 
+ /*
+  * Schedule all channels with events pending
+  */
+ static void vmbus_chan_sched(struct hv_per_cpu_context *hv_cpu)
+ {
+ 	unsigned long *recv_int_page;
+ 	u32 maxbits, relid;
+ 
+ 	if (vmbus_proto_version < VERSION_WIN8) {
+ 		maxbits = MAX_NUM_CHANNELS_SUPPORTED;
+ 		recv_int_page = vmbus_connection.recv_int_page;
+ 	} else {
+ 		/*
+ 		 * When the host is win8 and beyond, the event page
+ 		 * can be directly checked to get the id of the channel
+ 		 * that has the interrupt pending.
+ 		 */
+ 		void *page_addr = hv_cpu->synic_event_page;
+ 		union hv_synic_event_flags *event
+ 			= (union hv_synic_event_flags *)page_addr +
+ 						 VMBUS_MESSAGE_SINT;
+ 
+ 		maxbits = HV_EVENT_FLAGS_COUNT;
+ 		recv_int_page = event->flags;
+ 	}
+ 
+ 	if (unlikely(!recv_int_page))
+ 		return;
+ 
+ 	for_each_set_bit(relid, recv_int_page, maxbits) {
+ 		struct vmbus_channel *channel;
+ 
+ 		if (!sync_test_and_clear_bit(relid, recv_int_page))
+ 			continue;
+ 
+ 		/* Special case - vmbus channel protocol msg */
+ 		if (relid == 0)
+ 			continue;
+ 
+ 		/* Find channel based on relid */
+ 		list_for_each_entry(channel, &hv_cpu->chan_list, percpu_list) {
+ 			if (channel->offermsg.child_relid == relid) {
+ 				tasklet_schedule(&channel->callback_event);
+ 				break;
+ 			}
+ 		}
+ 	}
+ }
+ 
  static void vmbus_isr(void)
  {
 -	struct hv_per_cpu_context *hv_cpu
 -		= this_cpu_ptr(hv_context.cpu_context);
 -	void *page_addr = hv_cpu->synic_event_page;
 +	int cpu = smp_processor_id();
 +	void *page_addr;
  	struct hv_message *msg;
  	union hv_synic_event_flags *event;
  	bool handled = false;
@@@ -954,10 -972,9 +1004,14 @@@
  	}
  
  	if (handled)
++<<<<<<< HEAD
 +		tasklet_schedule(hv_context.event_dpc[cpu]);
 +
++=======
+ 		vmbus_chan_sched(hv_cpu);
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
  
 -	page_addr = hv_cpu->synic_message_page;
 +	page_addr = hv_context.synic_message_page[cpu];
  	msg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;
  
  	/* Check if there are actual msgs to be processed */
@@@ -1629,14 -1585,8 +1683,19 @@@ static void __exit vmbus_exit(void
  						 &hyperv_panic_block);
  	}
  	bus_unregister(&hv_bus);
++<<<<<<< HEAD
 +	hv_cleanup(false);
 +	cpu_notifier_register_begin();
 +	__unregister_hotcpu_notifier(&hv_cpuhp_notifier);
 +	for_each_online_cpu(cpu) {
 +		tasklet_kill(hv_context.event_dpc[cpu]);
 +		smp_call_function_single(cpu, hv_synic_cleanup_oncpu, NULL, 1);
 +	}
 +	cpu_notifier_register_done();
++=======
+ 
+ 	cpuhp_remove_state(hyperv_cpuhp_online);
++>>>>>>> 631e63a9f346 (vmbus: change to per channel tasklet)
  	hv_synic_free();
  	acpi_bus_unregister_driver(&vmbus_acpi_driver);
  }
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index 2dc1bb035e9c..c0c033a7b9e4 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -516,7 +516,7 @@ static int vmbus_close_internal(struct vmbus_channel *channel)
 	int ret;
 
 	/*
-	 * process_chn_event(), running in the tasklet, can race
+	 * vmbus_on_event(), running in the tasklet, can race
 	 * with vmbus_close_internal() in the case of SMP guest, e.g., when
 	 * the former is accessing channel->inbound.ring_buffer, the latter
 	 * could be freeing the ring_buffer pages.
* Unmerged path drivers/hv/channel_mgmt.c
* Unmerged path drivers/hv/connection.c
* Unmerged path drivers/hv/hv.c
* Unmerged path drivers/hv/hyperv_vmbus.h
* Unmerged path drivers/hv/vmbus_drv.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2d127a5ad611..8524af5a18e6 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -35,7 +35,7 @@
 #include <linux/completion.h>
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
-
+#include <linux/interrupt.h>
 
 #define MAX_PAGE_BUFFER_COUNT				32
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
@@ -747,6 +747,7 @@ struct vmbus_channel {
 	struct vmbus_close_msg close_msg;
 
 	/* Channel callback's invoked in softirq context */
+	struct tasklet_struct callback_event;
 	void (*onchannel_callback)(void *context);
 	void *channel_callback_context;
 
