nfp: calculate total port lanes for split

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit f0b81195381f0fd9ec84009a0e5a4bb12ccc9637
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f0b81195.failed

For port splitting we will need to know the total number of lanes
in a port.  Calculate that based on eth_table information.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f0b81195381f0fd9ec84009a0e5a4bb12ccc9637)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
index f94361014b87,b0f8785c064f..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
@@@ -129,14 -167,61 +129,64 @@@ nfp_eth_port_translate(const struct eth
  	dst->tx_enabled = FIELD_GET(NSP_ETH_STATE_TX_ENABLED, state);
  	dst->rx_enabled = FIELD_GET(NSP_ETH_STATE_RX_ENABLED, state);
  
 -	rate = nfp_eth_rate2speed(FIELD_GET(NSP_ETH_STATE_RATE, state));
 +	rate = nfp_eth_rate(FIELD_GET(NSP_ETH_STATE_RATE, state));
  	dst->speed = dst->lanes * rate;
  
 -	dst->interface = FIELD_GET(NSP_ETH_STATE_INTERFACE, state);
 -	dst->media = FIELD_GET(NSP_ETH_STATE_MEDIA, state);
 -
  	nfp_eth_copy_mac_reverse(dst->mac_addr, src->mac_addr);
  
++<<<<<<< HEAD
 +	snprintf(dst->label, sizeof(dst->label) - 1, "%llu.%llu",
 +		 FIELD_GET(NSP_ETH_PORT_PHYLABEL, port),
 +		 FIELD_GET(NSP_ETH_PORT_LABEL, port));
++=======
+ 	dst->label_port = FIELD_GET(NSP_ETH_PORT_PHYLABEL, port);
+ 	dst->label_subport = FIELD_GET(NSP_ETH_PORT_LABEL, port);
+ 
+ 	if (nfp_nsp_get_abi_ver_minor(nsp) < 17)
+ 		return;
+ 
+ 	dst->override_changed = FIELD_GET(NSP_ETH_STATE_OVRD_CHNG, state);
+ 	dst->aneg = FIELD_GET(NSP_ETH_STATE_ANEG, state);
+ }
+ 
+ static void
+ nfp_eth_calc_port_geometry(struct nfp_cpp *cpp, struct nfp_eth_table *table)
+ {
+ 	unsigned int i, j;
+ 
+ 	for (i = 0; i < table->count; i++)
+ 		for (j = 0; j < table->count; j++) {
+ 			if (table->ports[i].label_port !=
+ 			    table->ports[j].label_port)
+ 				continue;
+ 			table->ports[i].port_lanes += table->ports[j].lanes;
+ 
+ 			if (i == j)
+ 				continue;
+ 			if (table->ports[i].label_subport ==
+ 			    table->ports[j].label_subport)
+ 				nfp_warn(cpp,
+ 					 "Port %d subport %d is a duplicate\n",
+ 					 table->ports[i].label_port,
+ 					 table->ports[i].label_subport);
+ 
+ 			table->ports[i].is_split = true;
+ 		}
+ }
+ 
+ static void
+ nfp_eth_calc_port_type(struct nfp_cpp *cpp, struct nfp_eth_table_port *entry)
+ {
+ 	if (entry->interface == NFP_INTERFACE_NONE) {
+ 		entry->port_type = PORT_NONE;
+ 		return;
+ 	}
+ 
+ 	if (entry->media == NFP_MEDIA_FIBRE)
+ 		entry->port_type = PORT_FIBRE;
+ 	else
+ 		entry->port_type = PORT_DA;
++>>>>>>> f0b81195381f (nfp: calculate total port lanes for split)
  }
  
  /**
@@@ -202,9 -287,13 +252,16 @@@ __nfp_eth_read_ports(struct nfp_cpp *cp
  	table->count = cnt;
  	for (i = 0, j = 0; i < NSP_ETH_MAX_COUNT; i++)
  		if (entries[i].port & NSP_ETH_PORT_LANES_MASK)
 -			nfp_eth_port_translate(nsp, &entries[i], i,
 +			nfp_eth_port_translate(&entries[i], i,
  					       &table->ports[j++]);
  
++<<<<<<< HEAD
++=======
+ 	nfp_eth_calc_port_geometry(cpp, table);
+ 	for (i = 0; i < table->count; i++)
+ 		nfp_eth_calc_port_type(cpp, &table->ports[i]);
+ 
++>>>>>>> f0b81195381f (nfp: calculate total port lanes for split)
  	kfree(entries);
  
  	return table;
diff --cc drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
index 40eb6f95d0ce,84a1d20adae1..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
@@@ -53,6 -93,11 +53,14 @@@
   * @enabled:	is enabled?
   * @tx_enabled:	is TX enabled?
   * @rx_enabled:	is RX enabled?
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+  * @override_changed: is media reconfig pending?
+  *
+  * @port_type:	one of %PORT_* defines for ethtool
+  * @port_lanes:	total number of lanes on the port (sum of lanes of all subports)
+  * @is_split:	is interface part of a split port
++>>>>>>> f0b81195381f (nfp: calculate total port lanes for split):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
   */
  struct nfp_eth_table {
  	unsigned int count;
@@@ -70,6 -122,15 +78,18 @@@
  		bool enabled;
  		bool tx_enabled;
  		bool rx_enabled;
++<<<<<<< HEAD:drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
++=======
+ 
+ 		bool override_changed;
+ 
+ 		/* Computed fields */
+ 		u8 port_type;
+ 
+ 		unsigned int port_lanes;
+ 
+ 		bool is_split;
++>>>>>>> f0b81195381f (nfp: calculate total port lanes for split):drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
  	} ports[0];
  };
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_eth.h
