x86/intel_rdt/cqm: Add mkdir support for RDT monitoring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt/cqm: Add mkdir support for RDT monitoring (Jiri Olsa) [1457533]
Rebuild_FUZZ: 96.23%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit c7d9aac6131148abe29ed1dc6bd73ad1213d1f56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c7d9aac6.failed

Resource control groups can be created using mkdir in resctrl
fs(rdtgroup). In order to extend the resctrl interface to support
monitoring the control groups, extend the current mkdir to support
resource monitoring also.

This allows the rdtgroup created under the root directory to be able to
both control and monitor resources (ctrl_mon group). The ctrl_mon groups
are associated with one CLOSID like the legacy rdtgroups and one
RMID(Resource monitoring ID) as well. Hardware uses RMID to track the
resource usage. Once either of the CLOSID or RMID are exhausted, the
mkdir fails with -ENOSPC. If there are RMIDs in limbo list but not free
an -EBUSY is returned. User can also monitor a subset of the ctrl_mon
rdtgroup's tasks/cpus using the monitor groups. The monitor groups are
created using mkdir under the "mon_groups" directory in every ctrl_mon
group.

[Merged Tony's code: Removed a lot of common mkdir code, a fix to handling
of the list of the child rdtgroups and some cleanups in list
traversal. Also the changes to have similar alloc and free for CLOS/RMID
and return -EBUSY when RMIDs are in limbo and not free]

	Signed-off-by: Tony Luck <tony.luck@intel.com>
	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: fenghua.yu@intel.com
	Cc: peterz@infradead.org
	Cc: eranian@google.com
	Cc: vikas.shivappa@intel.com
	Cc: ak@linux.intel.com
	Cc: davidcc@google.com
	Cc: reinette.chatre@intel.com
Link: http://lkml.kernel.org/r/1501017287-28083-14-git-send-email-vikas.shivappa@linux.intel.com

(cherry picked from commit c7d9aac6131148abe29ed1dc6bd73ad1213d1f56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1c3603d97e9d,bee9f885dd20..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -932,23 -1115,18 +965,30 @@@ static struct file_system_type rdt_fs_t
  	.kill_sb = rdt_kill_sb,
  };
  
++<<<<<<< HEAD
 +static int rdtgroup_mkdir(struct kernfs_node *parent_kn, const char *name,
 +			  umode_t mode)
++=======
+ static int mkdir_rdt_prepare(struct kernfs_node *parent_kn,
+ 			     struct kernfs_node *prgrp_kn,
+ 			     const char *name, umode_t mode,
+ 			     enum rdt_group_type rtype, struct rdtgroup **r)
++>>>>>>> c7d9aac61311 (x86/intel_rdt/cqm: Add mkdir support for RDT monitoring)
  {
 -	struct rdtgroup *prdtgrp, *rdtgrp;
 +	struct rdtgroup *parent, *rdtgrp;
  	struct kernfs_node *kn;
 -	uint files = 0;
 -	int ret;
 +	int ret, closid;
  
 -	prdtgrp = rdtgroup_kn_lock_live(prgrp_kn);
 -	if (!prdtgrp) {
 +	/* Only allow mkdir in the root directory */
 +	if (parent_kn != rdtgroup_default.kn)
 +		return -EPERM;
 +
 +	/* Do not accept '\n' to avoid unparsable situation. */
 +	if (strchr(name, '\n'))
 +		return -EINVAL;
 +
 +	parent = rdtgroup_kn_lock_live(parent_kn);
 +	if (!parent) {
  		ret = -ENODEV;
  		goto out_unlock;
  	}
@@@ -962,16 -1135,18 +1002,23 @@@
  	rdtgrp = kzalloc(sizeof(*rdtgrp), GFP_KERNEL);
  	if (!rdtgrp) {
  		ret = -ENOSPC;
 -		goto out_unlock;
 +		goto out_closid_free;
  	}
++<<<<<<< HEAD
 +	rdtgrp->closid = closid;
 +	list_add(&rdtgrp->rdtgroup_list, &rdt_all_groups);
++=======
+ 	*r = rdtgrp;
+ 	rdtgrp->mon.parent = prdtgrp;
+ 	rdtgrp->type = rtype;
+ 	INIT_LIST_HEAD(&rdtgrp->mon.crdtgrp_list);
++>>>>>>> c7d9aac61311 (x86/intel_rdt/cqm: Add mkdir support for RDT monitoring)
  
  	/* kernfs creates the directory for rdtgrp */
 -	kn = kernfs_create_dir(parent_kn, name, mode, rdtgrp);
 +	kn = kernfs_create_dir(parent->kn, name, mode, rdtgrp);
  	if (IS_ERR(kn)) {
  		ret = PTR_ERR(kn);
 -		goto out_free_rgrp;
 +		goto out_cancel_ref;
  	}
  	rdtgrp->kn = kn;
  
@@@ -987,15 -1162,24 +1034,27 @@@
  	if (ret)
  		goto out_destroy;
  
++<<<<<<< HEAD
 +	ret = rdtgroup_add_files(kn, rdtgroup_base_files,
 +				 ARRAY_SIZE(rdtgroup_base_files));
++=======
+ 	files = RFTYPE_BASE | RFTYPE_CTRL;
+ 	files = RFTYPE_BASE | BIT(RF_CTRLSHIFT + rtype);
+ 	ret = rdtgroup_add_files(kn, files);
++>>>>>>> c7d9aac61311 (x86/intel_rdt/cqm: Add mkdir support for RDT monitoring)
  	if (ret)
  		goto out_destroy;
  
+ 	if (rdt_mon_capable) {
+ 		ret = alloc_rmid();
+ 		if (ret < 0)
+ 			goto out_destroy;
+ 		rdtgrp->mon.rmid = ret;
+ 	}
  	kernfs_activate(kn);
  
 -	/*
 -	 * The caller unlocks the prgrp_kn upon success.
 -	 */
 -	return 0;
 +	ret = 0;
 +	goto out_unlock;
  
  out_destroy:
  	kernfs_remove(rdtgrp->kn);
@@@ -1009,6 -1190,134 +1068,137 @@@ out_unlock
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void mkdir_rdt_prepare_clean(struct rdtgroup *rgrp)
+ {
+ 	kernfs_remove(rgrp->kn);
+ 	free_rmid(rgrp->mon.rmid);
+ 	kfree(rgrp);
+ }
+ 
+ /*
+  * Create a monitor group under "mon_groups" directory of a control
+  * and monitor group(ctrl_mon). This is a resource group
+  * to monitor a subset of tasks and cpus in its parent ctrl_mon group.
+  */
+ static int rdtgroup_mkdir_mon(struct kernfs_node *parent_kn,
+ 			      struct kernfs_node *prgrp_kn,
+ 			      const char *name,
+ 			      umode_t mode)
+ {
+ 	struct rdtgroup *rdtgrp, *prgrp;
+ 	int ret;
+ 
+ 	ret = mkdir_rdt_prepare(parent_kn, prgrp_kn, name, mode, RDTMON_GROUP,
+ 				&rdtgrp);
+ 	if (ret)
+ 		return ret;
+ 
+ 	prgrp = rdtgrp->mon.parent;
+ 	rdtgrp->closid = prgrp->closid;
+ 
+ 	/*
+ 	 * Add the rdtgrp to the list of rdtgrps the parent
+ 	 * ctrl_mon group has to track.
+ 	 */
+ 	list_add_tail(&rdtgrp->mon.crdtgrp_list, &prgrp->mon.crdtgrp_list);
+ 
+ 	rdtgroup_kn_unlock(prgrp_kn);
+ 	return ret;
+ }
+ 
+ /*
+  * These are rdtgroups created under the root directory. Can be used
+  * to allocate and monitor resources.
+  */
+ static int rdtgroup_mkdir_ctrl_mon(struct kernfs_node *parent_kn,
+ 				   struct kernfs_node *prgrp_kn,
+ 				   const char *name, umode_t mode)
+ {
+ 	struct rdtgroup *rdtgrp;
+ 	struct kernfs_node *kn;
+ 	u32 closid;
+ 	int ret;
+ 
+ 	ret = mkdir_rdt_prepare(parent_kn, prgrp_kn, name, mode, RDTCTRL_GROUP,
+ 				&rdtgrp);
+ 	if (ret)
+ 		return ret;
+ 
+ 	kn = rdtgrp->kn;
+ 	ret = closid_alloc();
+ 	if (ret < 0)
+ 		goto out_common_fail;
+ 	closid = ret;
+ 
+ 	rdtgrp->closid = closid;
+ 	list_add(&rdtgrp->rdtgroup_list, &rdt_all_groups);
+ 
+ 	if (rdt_mon_capable) {
+ 		/*
+ 		 * Create an empty mon_groups directory to hold the subset
+ 		 * of tasks and cpus to monitor.
+ 		 */
+ 		ret = mongroup_create_dir(kn, NULL, "mon_groups", NULL);
+ 		if (ret)
+ 			goto out_id_free;
+ 	}
+ 
+ 	goto out_unlock;
+ 
+ out_id_free:
+ 	closid_free(closid);
+ 	list_del(&rdtgrp->rdtgroup_list);
+ out_common_fail:
+ 	mkdir_rdt_prepare_clean(rdtgrp);
+ out_unlock:
+ 	rdtgroup_kn_unlock(prgrp_kn);
+ 	return ret;
+ }
+ 
+ /*
+  * We allow creating mon groups only with in a directory called "mon_groups"
+  * which is present in every ctrl_mon group. Check if this is a valid
+  * "mon_groups" directory.
+  *
+  * 1. The directory should be named "mon_groups".
+  * 2. The mon group itself should "not" be named "mon_groups".
+  *   This makes sure "mon_groups" directory always has a ctrl_mon group
+  *   as parent.
+  */
+ static bool is_mon_groups(struct kernfs_node *kn, const char *name)
+ {
+ 	return (!strcmp(kn->name, "mon_groups") &&
+ 		strcmp(name, "mon_groups"));
+ }
+ 
+ static int rdtgroup_mkdir(struct kernfs_node *parent_kn, const char *name,
+ 			  umode_t mode)
+ {
+ 	/* Do not accept '\n' to avoid unparsable situation. */
+ 	if (strchr(name, '\n'))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * If the parent directory is the root directory and RDT
+ 	 * allocation is supported, add a control and monitoring
+ 	 * subdirectory
+ 	 */
+ 	if (rdt_alloc_capable && parent_kn == rdtgroup_default.kn)
+ 		return rdtgroup_mkdir_ctrl_mon(parent_kn, parent_kn, name, mode);
+ 
+ 	/*
+ 	 * If RDT monitoring is supported and the parent directory is a valid
+ 	 * "mon_groups" directory, add a monitoring subdirectory.
+ 	 */
+ 	if (rdt_mon_capable && is_mon_groups(parent_kn, name))
+ 		return rdtgroup_mkdir_mon(parent_kn, parent_kn->parent, name, mode);
+ 
+ 	return -EPERM;
+ }
+ 
++>>>>>>> c7d9aac61311 (x86/intel_rdt/cqm: Add mkdir support for RDT monitoring)
  static int rdtgroup_rmdir(struct kernfs_node *kn)
  {
  	int ret, cpu, closid = rdtgroup_default.closid;
@@@ -1084,10 -1393,13 +1274,14 @@@ static int __init rdtgroup_setup_root(v
  	mutex_lock(&rdtgroup_mutex);
  
  	rdtgroup_default.closid = 0;
+ 	rdtgroup_default.mon.rmid = 0;
+ 	rdtgroup_default.type = RDTCTRL_GROUP;
+ 	INIT_LIST_HEAD(&rdtgroup_default.mon.crdtgrp_list);
+ 
  	list_add(&rdtgroup_default.rdtgroup_list, &rdt_all_groups);
  
 -	ret = rdtgroup_add_files(rdt_root->kn, RF_CTRL_BASE);
 +	ret = rdtgroup_add_files(rdt_root->kn, rdtgroup_base_files,
 +				 ARRAY_SIZE(rdtgroup_base_files));
  	if (ret) {
  		kernfs_destroy_root(rdt_root);
  		goto out;
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
