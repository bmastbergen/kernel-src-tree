geneve: Merge ipv4 and ipv6 geneve_build_skb()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author pravin shelar <pshelar@ovn.org>
commit c3ef5aa5e5f853168fe9728f390bfa2141eef4ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c3ef5aa5.failed

There are minimal difference in building Geneve header
between ipv4 and ipv6 geneve tunnels. Following patch
refactors code to unify it.

	Signed-off-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c3ef5aa5e5f853168fe9728f390bfa2141eef4ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index c4c93ccffa85,95dd19a3cafe..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -656,55 -641,23 +655,69 @@@ static void geneve_build_header(struct 
  	geneveh->proto_type = htons(ETH_P_TEB);
  	geneveh->rsvd2 = 0;
  
- 	memcpy(geneveh->options, options, options_len);
+ 	ip_tunnel_info_opts_get(geneveh->options, info);
  }
  
++<<<<<<< HEAD
 +static int geneve_build_skb(struct rtable *rt, struct sk_buff *skb,
 +			    __be16 tun_flags, u8 vni[3], u8 opt_len, u8 *opt,
 +			    u32 flags, bool xnet)
 +{
++=======
+ static int geneve_build_skb(struct dst_entry *dst, struct sk_buff *skb,
+ 			    const struct ip_tunnel_info *info,
+ 			    bool xnet, int ip_hdr_len)
+ {
+ 	bool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);
++>>>>>>> c3ef5aa5e5f8 (geneve: Merge ipv4 and ipv6 geneve_build_skb())
  	struct genevehdr *gnvh;
  	int min_headroom;
  	int err;
 +	bool udp_sum = !(flags & GENEVE_F_UDP_ZERO_CSUM_TX);
  
+ 	skb_reset_mac_header(skb);
  	skb_scrub_packet(skb, xnet);
  
++<<<<<<< HEAD
 +	min_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len
 +			+ GENEVE_BASE_HLEN + opt_len + sizeof(struct iphdr);
 +	err = skb_cow_head(skb, min_headroom);
 +	if (unlikely(err))
 +		goto free_rt;
 +
 +	err = udp_tunnel_handle_offloads(skb, udp_sum);
 +	if (err)
 +		goto free_rt;
 +
 +	gnvh = (struct genevehdr *)__skb_push(skb, sizeof(*gnvh) + opt_len);
 +	geneve_build_header(gnvh, tun_flags, vni, opt_len, opt);
 +
 +	skb_set_inner_protocol(skb, htons(ETH_P_TEB));
 +	return 0;
 +
 +free_rt:
 +	ip_rt_put(rt);
 +	return err;
 +}
 +
 +#if IS_ENABLED(CONFIG_IPV6)
 +static int geneve6_build_skb(struct dst_entry *dst, struct sk_buff *skb,
 +			     __be16 tun_flags, u8 vni[3], u8 opt_len, u8 *opt,
 +			     u32 flags, bool xnet)
 +{
 +	struct genevehdr *gnvh;
 +	int min_headroom;
 +	int err;
 +	bool udp_sum = !(flags & GENEVE_F_UDP_ZERO_CSUM6_TX);
 +
 +	skb_scrub_packet(skb, xnet);
 +
 +	min_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len
 +			+ GENEVE_BASE_HLEN + opt_len + sizeof(struct ipv6hdr);
++=======
+ 	min_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len +
+ 		       GENEVE_BASE_HLEN + info->options_len + ip_hdr_len;
++>>>>>>> c3ef5aa5e5f8 (geneve: Merge ipv4 and ipv6 geneve_build_skb())
  	err = skb_cow_head(skb, min_headroom);
  	if (unlikely(err))
  		goto free_dst;
@@@ -739,26 -691,20 +751,30 @@@ static struct rtable *geneve_get_v4_rt(
  	memset(fl4, 0, sizeof(*fl4));
  	fl4->flowi4_mark = skb->mark;
  	fl4->flowi4_proto = IPPROTO_UDP;
 -	fl4->daddr = info->key.u.ipv4.dst;
 -	fl4->saddr = info->key.u.ipv4.src;
  
 -	tos = info->key.tos;
 -	if ((tos == 1) && !geneve->collect_md) {
 -		tos = ip_tunnel_get_dsfield(ip_hdr(skb), skb);
 -		use_cache = false;
 +	if (info) {
 +		fl4->daddr = info->key.u.ipv4.dst;
 +		fl4->saddr = info->key.u.ipv4.src;
 +		fl4->flowi4_tos = RT_TOS(info->key.tos);
 +		dst_cache = &info->dst_cache;
 +	} else {
 +		tos = geneve->tos;
 +		if (tos == 1) {
 +			const struct iphdr *iip = ip_hdr(skb);
 +
 +			tos = ip_tunnel_get_dsfield(iip, skb);
 +			use_cache = false;
 +		}
 +
 +		fl4->flowi4_tos = RT_TOS(tos);
 +		fl4->daddr = geneve->remote.sin.sin_addr.s_addr;
 +		dst_cache = &geneve->dst_cache;
  	}
 -	fl4->flowi4_tos = RT_TOS(tos);
  
++<<<<<<< HEAD
++=======
+ 	dst_cache = (struct dst_cache *)&info->dst_cache;
++>>>>>>> c3ef5aa5e5f8 (geneve: Merge ipv4 and ipv6 geneve_build_skb())
  	if (use_cache) {
  		rt = dst_cache_get_ip4(dst_cache, &fl4->saddr);
  		if (rt)
@@@ -796,28 -741,21 +812,34 @@@ static struct dst_entry *geneve_get_v6_
  	memset(fl6, 0, sizeof(*fl6));
  	fl6->flowi6_mark = skb->mark;
  	fl6->flowi6_proto = IPPROTO_UDP;
 -	fl6->daddr = info->key.u.ipv6.dst;
 -	fl6->saddr = info->key.u.ipv6.src;
 -	prio = info->key.tos;
 -	if ((prio == 1) && !geneve->collect_md) {
 -		prio = ip_tunnel_get_dsfield(ip_hdr(skb), skb);
 -		use_cache = false;
 +
 +	if (info) {
 +		fl6->daddr = info->key.u.ipv6.dst;
 +		fl6->saddr = info->key.u.ipv6.src;
 +		fl6->flowlabel = ip6_make_flowinfo(RT_TOS(info->key.tos),
 +						   info->key.label);
 +		dst_cache = &info->dst_cache;
 +	} else {
 +		prio = geneve->tos;
 +		if (prio == 1) {
 +			const struct iphdr *iip = ip_hdr(skb);
 +
 +			prio = ip_tunnel_get_dsfield(iip, skb);
 +			use_cache = false;
 +		}
 +
 +		fl6->flowlabel = ip6_make_flowinfo(RT_TOS(prio),
 +						   geneve->label);
 +		fl6->daddr = geneve->remote.sin6.sin6_addr;
 +		dst_cache = &geneve->dst_cache;
  	}
  
++<<<<<<< HEAD
++=======
+ 	fl6->flowlabel = ip6_make_flowinfo(RT_TOS(prio),
+ 					   info->key.label);
+ 	dst_cache = (struct dst_cache *)&info->dst_cache;
++>>>>>>> c3ef5aa5e5f8 (geneve: Merge ipv4 and ipv6 geneve_build_skb())
  	if (use_cache) {
  		dst = dst_cache_get_ip6(dst_cache, &fl6->saddr);
  		if (dst)
@@@ -840,36 -777,100 +862,121 @@@
  }
  #endif
  
++<<<<<<< HEAD
 +/* Convert 64 bit tunnel ID to 24 bit VNI. */
 +static void tunnel_id_to_vni(__be64 tun_id, __u8 *vni)
++=======
+ static int geneve_xmit_skb(struct sk_buff *skb, struct net_device *dev,
+ 			   struct geneve_dev *geneve,
+ 			   const struct ip_tunnel_info *info)
++>>>>>>> c3ef5aa5e5f8 (geneve: Merge ipv4 and ipv6 geneve_build_skb())
  {
 -	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
 -	struct geneve_sock *gs4 = rcu_dereference(geneve->sock4);
 -	const struct ip_tunnel_key *key = &info->key;
 -	struct rtable *rt;
 +#ifdef __BIG_ENDIAN
 +	vni[0] = (__force __u8)(tun_id >> 16);
 +	vni[1] = (__force __u8)(tun_id >> 8);
 +	vni[2] = (__force __u8)tun_id;
 +#else
 +	vni[0] = (__force __u8)((__force u64)tun_id >> 40);
 +	vni[1] = (__force __u8)((__force u64)tun_id >> 48);
 +	vni[2] = (__force __u8)((__force u64)tun_id >> 56);
 +#endif
 +}
 +
 +static netdev_tx_t geneve_xmit_skb(struct sk_buff *skb, struct net_device *dev,
 +				   struct ip_tunnel_info *info)
 +{
 +	struct geneve_dev *geneve = netdev_priv(dev);
 +	struct geneve_sock *gs4 = geneve->sock4;
 +	struct rtable *rt = NULL;
  	int err = -EINVAL;
  	struct flowi4 fl4;
  	__u8 tos, ttl;
  	__be16 sport;
  	__be16 df;
++<<<<<<< HEAD
 +	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
 +	u32 flags = geneve->flags;
++=======
+ 
+ 	if (!gs4)
+ 		return err;
+ 
+ 	rt = geneve_get_v4_rt(skb, dev, &fl4, info);
+ 	if (IS_ERR(rt))
+ 		return PTR_ERR(rt);
+ 
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	if (geneve->collect_md) {
+ 		tos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
+ 		ttl = key->ttl;
+ 	} else {
+ 		tos = ip_tunnel_ecn_encap(fl4.flowi4_tos, ip_hdr(skb), skb);
+ 		ttl = key->ttl ? : ip4_dst_hoplimit(&rt->dst);
+ 	}
+ 	df = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
+ 
+ 	err = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr));
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	udp_tunnel_xmit_skb(rt, gs4->sock->sk, skb, fl4.saddr, fl4.daddr,
+ 			    tos, ttl, df, sport, geneve->info.key.tp_dst,
+ 			    !net_eq(geneve->net, dev_net(geneve->dev)),
+ 			    !(info->key.tun_flags & TUNNEL_CSUM));
+ 	return 0;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int geneve6_xmit_skb(struct sk_buff *skb, struct net_device *dev,
+ 			    struct geneve_dev *geneve,
+ 			    const struct ip_tunnel_info *info)
+ {
+ 	bool xnet = !net_eq(geneve->net, dev_net(geneve->dev));
+ 	struct geneve_sock *gs6 = rcu_dereference(geneve->sock6);
+ 	const struct ip_tunnel_key *key = &info->key;
+ 	struct dst_entry *dst = NULL;
+ 	int err = -EINVAL;
+ 	struct flowi6 fl6;
+ 	__u8 prio, ttl;
+ 	__be16 sport;
+ 
+ 	if (!gs6)
+ 		return err;
+ 
+ 	dst = geneve_get_v6_dst(skb, dev, &fl6, info);
+ 	if (IS_ERR(dst))
+ 		return PTR_ERR(dst);
+ 
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	if (geneve->collect_md) {
+ 		prio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
+ 		ttl = key->ttl;
+ 	} else {
+ 		prio = ip_tunnel_ecn_encap(ip6_tclass(fl6.flowlabel),
+ 					   ip_hdr(skb), skb);
+ 		ttl = key->ttl ? : ip6_dst_hoplimit(dst);
+ 	}
+ 	err = geneve_build_skb(dst, skb, info, xnet, sizeof(struct iphdr));
+ 	if (unlikely(err))
+ 		return err;
+ 
+ 	udp_tunnel6_xmit_skb(dst, gs6->sock->sk, skb, dev,
+ 			     &fl6.saddr, &fl6.daddr, prio, ttl,
+ 			     info->key.label, sport, geneve->info.key.tp_dst,
+ 			     !(info->key.tun_flags & TUNNEL_CSUM));
+ 	return 0;
+ }
+ #endif
+ 
+ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct geneve_dev *geneve = netdev_priv(dev);
+ 	struct ip_tunnel_info *info = NULL;
+ 	int err;
++>>>>>>> c3ef5aa5e5f8 (geneve: Merge ipv4 and ipv6 geneve_build_skb())
  
  	if (geneve->collect_md) {
 -		info = skb_tunnel_info(skb);
  		if (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {
 -			err = -EINVAL;
  			netdev_dbg(dev, "no tunnel metadata\n");
  			goto tx_error;
  		}
* Unmerged path drivers/net/geneve.c
