s390/crypto: Renaming PPNO to PRNO.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] crypto: Renaming PPNO to PRNO (Hendrik Brueckner) [1375266]
Rebuild_FUZZ: 90.62%
commit-author Harald Freudenberger <freude@linux.vnet.ibm.com>
commit 985a9d20daa67e1983910fcf6e4f348ce8eed086
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/985a9d20.failed

The PPNO (Perform Pseudorandom Number Operation) instruction
has been renamed to PRNO (Perform Random Number Operation).
To avoid confusion and conflicts with future extensions with
this instruction (like e.g. provide a true random number
generator) this patch renames all occurences in cpacf.h and
adjusts the only exploiter code which is the prng device
driver and one line in the s390 kvm feature check.

	Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 985a9d20daa67e1983910fcf6e4f348ce8eed086)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/crypto/prng.c
#	arch/s390/include/asm/cpacf.h
#	arch/s390/kvm/kvm-s390.c
diff --cc arch/s390/crypto/prng.c
index 9d5192c94963,3e47c4a0f18b..000000000000
--- a/arch/s390/crypto/prng.c
+++ b/arch/s390/crypto/prng.c
@@@ -303,22 -305,14 +303,27 @@@ static int __init prng_sha512_selftest(
  		0x21, 0xe4, 0xb0, 0x86, 0x44, 0xf6, 0x72, 0x7c,
  		0x36, 0x8c, 0x5a, 0x9f, 0x7a, 0x4b, 0x3e, 0xe2 };
  
 +	int ret = 0;
  	u8 buf[sizeof(random)];
- 	struct ppno_ws_s ws;
+ 	struct prno_ws_s ws;
  
  	memset(&ws, 0, sizeof(ws));
  
  	/* initial seed */
++<<<<<<< HEAD
 +	ret = crypt_s390_ppno(PPNO_SHA512_DRNG_SEED,
 +			      &ws, NULL, 0,
 +			      seed, sizeof(seed));
 +	if (ret < 0) {
 +		pr_err("The prng self test seed operation for the "
 +		       "SHA-512 mode failed with rc=%d\n", ret);
 +		prng_errorflag = PRNG_SELFTEST_FAILED;
 +		return -EIO;
 +	}
++=======
+ 	cpacf_prno(CPACF_PRNO_SHA512_DRNG_SEED,
+ 		   &ws, NULL, 0, seed, sizeof(seed));
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  
  	/* check working states V and C */
  	if (memcmp(ws.V, V0, sizeof(V0)) != 0
@@@ -330,24 -324,10 +335,31 @@@
  	}
  
  	/* generate random bytes */
++<<<<<<< HEAD
 +	ret = crypt_s390_ppno(PPNO_SHA512_DRNG_GEN,
 +			      &ws, buf, sizeof(buf),
 +			      NULL, 0);
 +	if (ret < 0) {
 +		pr_err("The prng self test generate operation for "
 +		       "the SHA-512 mode failed with rc=%d\n", ret);
 +		prng_errorflag = PRNG_SELFTEST_FAILED;
 +		return -EIO;
 +	}
 +	ret = crypt_s390_ppno(PPNO_SHA512_DRNG_GEN,
 +			      &ws, buf, sizeof(buf),
 +			      NULL, 0);
 +	if (ret < 0) {
 +		pr_err("The prng self test generate operation for "
 +		       "the SHA-512 mode failed with rc=%d\n", ret);
 +		prng_errorflag = PRNG_SELFTEST_FAILED;
 +		return -EIO;
 +	}
++=======
+ 	cpacf_prno(CPACF_PRNO_SHA512_DRNG_GEN,
+ 		   &ws, buf, sizeof(buf), NULL, 0);
+ 	cpacf_prno(CPACF_PRNO_SHA512_DRNG_GEN,
+ 		   &ws, buf, sizeof(buf), NULL, 0);
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  
  	/* check against expected data */
  	if (memcmp(buf, random, sizeof(random)) != 0) {
@@@ -387,37 -367,24 +399,49 @@@ static int __init prng_sha512_instantia
  	if (ret)
  		goto outfree;
  
 -	/* generate initial seed bytestring, with 256 + 128 bits entropy */
 -	ret = generate_entropy(seed, 64 + 32);
 -	if (ret != 64 + 32)
 +	/* generate initial seed bytestring, first 48 bytes of entropy */
 +	ret = generate_entropy(seed, 48);
 +	if (ret != 48)
  		goto outfree;
  	/* followed by 16 bytes of unique nonce */
 -	get_tod_clock_ext(seed + 64 + 32);
 -
 +	get_tod_clock_ext(seed + 48);
 +
++<<<<<<< HEAD
 +	/* initial seed of the ppno drng */
 +	ret = crypt_s390_ppno(PPNO_SHA512_DRNG_SEED,
 +			      &prng_data->ppnows, NULL, 0,
 +			      seed, sizeof(seed));
 +	if (ret < 0) {
 +		prng_errorflag = PRNG_SEED_FAILED;
 +		ret = -EIO;
 +		goto outfree;
 +	}
++=======
+ 	/* initial seed of the prno drng */
+ 	cpacf_prno(CPACF_PRNO_SHA512_DRNG_SEED,
+ 		   &prng_data->prnows, NULL, 0, seed, sizeof(seed));
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  
  	/* if fips mode is enabled, generate a first block of random
  	   bytes for the FIPS 140-2 Conditional Self Test */
  	if (fips_enabled) {
  		prng_data->prev = prng_data->buf + prng_chunk_size;
++<<<<<<< HEAD
 +		ret = crypt_s390_ppno(PPNO_SHA512_DRNG_GEN,
 +				      &prng_data->ppnows,
 +				      prng_data->prev,
 +				      prng_chunk_size,
 +				      NULL, 0);
 +		if (ret < 0 || ret != prng_chunk_size) {
 +			prng_errorflag = PRNG_GEN_FAILED;
 +			ret = -EIO;
 +			goto outfree;
 +		}
++=======
+ 		cpacf_prno(CPACF_PRNO_SHA512_DRNG_GEN,
+ 			   &prng_data->prnows,
+ 			   prng_data->prev, prng_chunk_size, NULL, 0);
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  	}
  
  	return 0;
@@@ -445,14 -412,9 +469,20 @@@ static int prng_sha512_reseed(void
  	if (ret != sizeof(seed))
  		return ret;
  
++<<<<<<< HEAD
 +	/* do a reseed of the ppno drng with this bytestring */
 +	ret = crypt_s390_ppno(PPNO_SHA512_DRNG_SEED,
 +			      &prng_data->ppnows, NULL, 0,
 +			      seed, sizeof(seed));
 +	if (ret) {
 +		prng_errorflag = PRNG_RESEED_FAILED;
 +		return -EIO;
 +	}
++=======
+ 	/* do a reseed of the prno drng with this bytestring */
+ 	cpacf_prno(CPACF_PRNO_SHA512_DRNG_SEED,
+ 		   &prng_data->prnows, NULL, 0, seed, sizeof(seed));
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  
  	return 0;
  }
@@@ -469,14 -431,9 +499,20 @@@ static int prng_sha512_generate(u8 *buf
  			return ret;
  	}
  
++<<<<<<< HEAD
 +	/* PPNO generate */
 +	ret = crypt_s390_ppno(PPNO_SHA512_DRNG_GEN,
 +			      &prng_data->ppnows, buf, nbytes,
 +			      NULL, 0);
 +	if (ret < 0 || ret != nbytes) {
 +		prng_errorflag = PRNG_GEN_FAILED;
 +		return -EIO;
 +	}
++=======
+ 	/* PRNO generate */
+ 	cpacf_prno(CPACF_PRNO_SHA512_DRNG_GEN,
+ 		   &prng_data->prnows, buf, nbytes, NULL, 0);
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  
  	/* FIPS 140-2 Conditional Self Test */
  	if (fips_enabled) {
@@@ -817,9 -774,8 +853,14 @@@ static int __init prng_init(void
  
  	/* choose prng mode */
  	if (prng_mode != PRNG_MODE_TDES) {
++<<<<<<< HEAD
 +		/* check for MSA5 support for PPNO operations */
 +		if (!crypt_s390_func_available(PPNO_SHA512_DRNG_GEN,
 +					       CRYPT_S390_MSA5)) {
++=======
+ 		/* check for MSA5 support for PRNO operations */
+ 		if (!cpacf_query_func(CPACF_PRNO, CPACF_PRNO_SHA512_DRNG_GEN)) {
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  			if (prng_mode == PRNG_MODE_SHA512) {
  				pr_err("The prng module cannot "
  				       "start in SHA-512 mode\n");
diff --cc arch/s390/kvm/kvm-s390.c
index 9b2d6973d202,d5c5c911821a..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -118,11 -206,118 +118,118 @@@ int kvm_arch_hardware_setup(void
  
  void kvm_arch_hardware_unsetup(void)
  {
 -	gmap_unregister_pte_notifier(&gmap_notifier);
 -	gmap_unregister_pte_notifier(&vsie_gmap_notifier);
 -	atomic_notifier_chain_unregister(&s390_epoch_delta_notifier,
 -					 &kvm_clock_notifier);
 +	gmap_unregister_ipte_notifier(&gmap_notifier);
  }
  
 -static void allow_cpu_feat(unsigned long nr)
 +void kvm_arch_check_processor_compat(void *rtn)
  {
++<<<<<<< HEAD
++=======
+ 	set_bit_inv(nr, kvm_s390_available_cpu_feat);
+ }
+ 
+ static inline int plo_test_bit(unsigned char nr)
+ {
+ 	register unsigned long r0 asm("0") = (unsigned long) nr | 0x100;
+ 	int cc;
+ 
+ 	asm volatile(
+ 		/* Parameter registers are ignored for "test bit" */
+ 		"	plo	0,0,0,0(0)\n"
+ 		"	ipm	%0\n"
+ 		"	srl	%0,28\n"
+ 		: "=d" (cc)
+ 		: "d" (r0)
+ 		: "cc");
+ 	return cc == 0;
+ }
+ 
+ static void kvm_s390_cpu_feat_init(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < 256; ++i) {
+ 		if (plo_test_bit(i))
+ 			kvm_s390_available_subfunc.plo[i >> 3] |= 0x80 >> (i & 7);
+ 	}
+ 
+ 	if (test_facility(28)) /* TOD-clock steering */
+ 		ptff(kvm_s390_available_subfunc.ptff,
+ 		     sizeof(kvm_s390_available_subfunc.ptff),
+ 		     PTFF_QAF);
+ 
+ 	if (test_facility(17)) { /* MSA */
+ 		__cpacf_query(CPACF_KMAC, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.kmac);
+ 		__cpacf_query(CPACF_KMC, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.kmc);
+ 		__cpacf_query(CPACF_KM, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.km);
+ 		__cpacf_query(CPACF_KIMD, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.kimd);
+ 		__cpacf_query(CPACF_KLMD, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.klmd);
+ 	}
+ 	if (test_facility(76)) /* MSA3 */
+ 		__cpacf_query(CPACF_PCKMO, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.pckmo);
+ 	if (test_facility(77)) { /* MSA4 */
+ 		__cpacf_query(CPACF_KMCTR, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.kmctr);
+ 		__cpacf_query(CPACF_KMF, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.kmf);
+ 		__cpacf_query(CPACF_KMO, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.kmo);
+ 		__cpacf_query(CPACF_PCC, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.pcc);
+ 	}
+ 	if (test_facility(57)) /* MSA5 */
+ 		__cpacf_query(CPACF_PRNO, (cpacf_mask_t *)
+ 			      kvm_s390_available_subfunc.ppno);
+ 
+ 	if (MACHINE_HAS_ESOP)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_ESOP);
+ 	/*
+ 	 * We need SIE support, ESOP (PROT_READ protection for gmap_shadow),
+ 	 * 64bit SCAO (SCA passthrough) and IDTE (for gmap_shadow unshadowing).
+ 	 */
+ 	if (!sclp.has_sief2 || !MACHINE_HAS_ESOP || !sclp.has_64bscao ||
+ 	    !test_facility(3) || !nested)
+ 		return;
+ 	allow_cpu_feat(KVM_S390_VM_CPU_FEAT_SIEF2);
+ 	if (sclp.has_64bscao)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_64BSCAO);
+ 	if (sclp.has_siif)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_SIIF);
+ 	if (sclp.has_gpere)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_GPERE);
+ 	if (sclp.has_gsls)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_GSLS);
+ 	if (sclp.has_ib)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_IB);
+ 	if (sclp.has_cei)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_CEI);
+ 	if (sclp.has_ibs)
+ 		allow_cpu_feat(KVM_S390_VM_CPU_FEAT_IBS);
+ 	/*
+ 	 * KVM_S390_VM_CPU_FEAT_SKEY: Wrong shadow of PTE.I bits will make
+ 	 * all skey handling functions read/set the skey from the PGSTE
+ 	 * instead of the real storage key.
+ 	 *
+ 	 * KVM_S390_VM_CPU_FEAT_CMMA: Wrong shadow of PTE.I bits will make
+ 	 * pages being detected as preserved although they are resident.
+ 	 *
+ 	 * KVM_S390_VM_CPU_FEAT_PFMFI: Wrong shadow of PTE.I bits will
+ 	 * have the same effect as for KVM_S390_VM_CPU_FEAT_SKEY.
+ 	 *
+ 	 * For KVM_S390_VM_CPU_FEAT_SKEY, KVM_S390_VM_CPU_FEAT_CMMA and
+ 	 * KVM_S390_VM_CPU_FEAT_PFMFI, all PTE.I and PGSTE bits have to be
+ 	 * correctly shadowed. We can do that for the PGSTE but not for PTE.I.
+ 	 *
+ 	 * KVM_S390_VM_CPU_FEAT_SIGPIF: Wrong SCB addresses in the SCA. We
+ 	 * cannot easily shadow the SCA because of the ipte lock.
+ 	 */
++>>>>>>> 985a9d20daa6 (s390/crypto: Renaming PPNO to PRNO.)
  }
  
  int kvm_arch_init(void *opaque)
* Unmerged path arch/s390/include/asm/cpacf.h
* Unmerged path arch/s390/crypto/prng.c
* Unmerged path arch/s390/include/asm/cpacf.h
* Unmerged path arch/s390/kvm/kvm-s390.c
