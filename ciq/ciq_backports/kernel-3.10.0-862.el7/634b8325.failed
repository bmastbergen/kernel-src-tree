nvme: fix nvme reset command timeout handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fix nvme reset command timeout handling (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 92.86%
commit-author Keith Busch <keith.busch@intel.com>
commit 634b8325905031eeafa61951623681ebc1329385
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/634b8325.failed

We need to return an error if a timeout occurs on any NVMe command during
initialization. Without this, the nvme reset work will be stuck. A timeout
will have a negative error code, meaning we need to stop initializing
the controller. All postitive returns mean the controller is still usable.

bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=196325

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Cc: Martin Peres <martin.peres@intel.com>
[jth consolidated cleanup path ]
	Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 634b8325905031eeafa61951623681ebc1329385)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 70f7805d0625,6212cf4e9829..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1161,9 -1503,232 +1161,236 @@@ static void nvme_set_queue_limits(struc
  	}
  	if (ctrl->quirks & NVME_QUIRK_STRIPE_SIZE)
  		blk_queue_chunk_sectors(q, ctrl->max_hw_sectors);
 -	blk_queue_virt_boundary(q, ctrl->page_size - 1);
  	if (ctrl->vwc & NVME_CTRL_VWC_PRESENT)
++<<<<<<< HEAD
 +		blk_queue_flush(q, REQ_FLUSH | REQ_FUA);
 +	blk_queue_virt_boundary(q, ctrl->page_size - 1);
++=======
+ 		vwc = true;
+ 	blk_queue_write_cache(q, vwc, vwc);
+ }
+ 
+ static int nvme_configure_apst(struct nvme_ctrl *ctrl)
+ {
+ 	/*
+ 	 * APST (Autonomous Power State Transition) lets us program a
+ 	 * table of power state transitions that the controller will
+ 	 * perform automatically.  We configure it with a simple
+ 	 * heuristic: we are willing to spend at most 2% of the time
+ 	 * transitioning between power states.  Therefore, when running
+ 	 * in any given state, we will enter the next lower-power
+ 	 * non-operational state after waiting 50 * (enlat + exlat)
+ 	 * microseconds, as long as that state's exit latency is under
+ 	 * the requested maximum latency.
+ 	 *
+ 	 * We will not autonomously enter any non-operational state for
+ 	 * which the total latency exceeds ps_max_latency_us.  Users
+ 	 * can set ps_max_latency_us to zero to turn off APST.
+ 	 */
+ 
+ 	unsigned apste;
+ 	struct nvme_feat_auto_pst *table;
+ 	u64 max_lat_us = 0;
+ 	int max_ps = -1;
+ 	int ret;
+ 
+ 	/*
+ 	 * If APST isn't supported or if we haven't been initialized yet,
+ 	 * then don't do anything.
+ 	 */
+ 	if (!ctrl->apsta)
+ 		return 0;
+ 
+ 	if (ctrl->npss > 31) {
+ 		dev_warn(ctrl->device, "NPSS is invalid; not using APST\n");
+ 		return 0;
+ 	}
+ 
+ 	table = kzalloc(sizeof(*table), GFP_KERNEL);
+ 	if (!table)
+ 		return 0;
+ 
+ 	if (!ctrl->apst_enabled || ctrl->ps_max_latency_us == 0) {
+ 		/* Turn off APST. */
+ 		apste = 0;
+ 		dev_dbg(ctrl->device, "APST disabled\n");
+ 	} else {
+ 		__le64 target = cpu_to_le64(0);
+ 		int state;
+ 
+ 		/*
+ 		 * Walk through all states from lowest- to highest-power.
+ 		 * According to the spec, lower-numbered states use more
+ 		 * power.  NPSS, despite the name, is the index of the
+ 		 * lowest-power state, not the number of states.
+ 		 */
+ 		for (state = (int)ctrl->npss; state >= 0; state--) {
+ 			u64 total_latency_us, exit_latency_us, transition_ms;
+ 
+ 			if (target)
+ 				table->entries[state] = target;
+ 
+ 			/*
+ 			 * Don't allow transitions to the deepest state
+ 			 * if it's quirked off.
+ 			 */
+ 			if (state == ctrl->npss &&
+ 			    (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS))
+ 				continue;
+ 
+ 			/*
+ 			 * Is this state a useful non-operational state for
+ 			 * higher-power states to autonomously transition to?
+ 			 */
+ 			if (!(ctrl->psd[state].flags &
+ 			      NVME_PS_FLAGS_NON_OP_STATE))
+ 				continue;
+ 
+ 			exit_latency_us =
+ 				(u64)le32_to_cpu(ctrl->psd[state].exit_lat);
+ 			if (exit_latency_us > ctrl->ps_max_latency_us)
+ 				continue;
+ 
+ 			total_latency_us =
+ 				exit_latency_us +
+ 				le32_to_cpu(ctrl->psd[state].entry_lat);
+ 
+ 			/*
+ 			 * This state is good.  Use it as the APST idle
+ 			 * target for higher power states.
+ 			 */
+ 			transition_ms = total_latency_us + 19;
+ 			do_div(transition_ms, 20);
+ 			if (transition_ms > (1 << 24) - 1)
+ 				transition_ms = (1 << 24) - 1;
+ 
+ 			target = cpu_to_le64((state << 3) |
+ 					     (transition_ms << 8));
+ 
+ 			if (max_ps == -1)
+ 				max_ps = state;
+ 
+ 			if (total_latency_us > max_lat_us)
+ 				max_lat_us = total_latency_us;
+ 		}
+ 
+ 		apste = 1;
+ 
+ 		if (max_ps == -1) {
+ 			dev_dbg(ctrl->device, "APST enabled but no non-operational states are available\n");
+ 		} else {
+ 			dev_dbg(ctrl->device, "APST enabled: max PS = %d, max round-trip latency = %lluus, table = %*phN\n",
+ 				max_ps, max_lat_us, (int)sizeof(*table), table);
+ 		}
+ 	}
+ 
+ 	ret = nvme_set_features(ctrl, NVME_FEAT_AUTO_PST, apste,
+ 				table, sizeof(*table), NULL);
+ 	if (ret)
+ 		dev_err(ctrl->device, "failed to set APST feature (%d)\n", ret);
+ 
+ 	kfree(table);
+ 	return ret;
+ }
+ 
+ static void nvme_set_latency_tolerance(struct device *dev, s32 val)
+ {
+ 	struct nvme_ctrl *ctrl = dev_get_drvdata(dev);
+ 	u64 latency;
+ 
+ 	switch (val) {
+ 	case PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT:
+ 	case PM_QOS_LATENCY_ANY:
+ 		latency = U64_MAX;
+ 		break;
+ 
+ 	default:
+ 		latency = val;
+ 	}
+ 
+ 	if (ctrl->ps_max_latency_us != latency) {
+ 		ctrl->ps_max_latency_us = latency;
+ 		nvme_configure_apst(ctrl);
+ 	}
+ }
+ 
+ struct nvme_core_quirk_entry {
+ 	/*
+ 	 * NVMe model and firmware strings are padded with spaces.  For
+ 	 * simplicity, strings in the quirk table are padded with NULLs
+ 	 * instead.
+ 	 */
+ 	u16 vid;
+ 	const char *mn;
+ 	const char *fr;
+ 	unsigned long quirks;
+ };
+ 
+ static const struct nvme_core_quirk_entry core_quirks[] = {
+ 	{
+ 		/*
+ 		 * This Toshiba device seems to die using any APST states.  See:
+ 		 * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1678184/comments/11
+ 		 */
+ 		.vid = 0x1179,
+ 		.mn = "THNSF5256GPUK TOSHIBA",
+ 		.quirks = NVME_QUIRK_NO_APST,
+ 	}
+ };
+ 
+ /* match is null-terminated but idstr is space-padded. */
+ static bool string_matches(const char *idstr, const char *match, size_t len)
+ {
+ 	size_t matchlen;
+ 
+ 	if (!match)
+ 		return true;
+ 
+ 	matchlen = strlen(match);
+ 	WARN_ON_ONCE(matchlen > len);
+ 
+ 	if (memcmp(idstr, match, matchlen))
+ 		return false;
+ 
+ 	for (; matchlen < len; matchlen++)
+ 		if (idstr[matchlen] != ' ')
+ 			return false;
+ 
+ 	return true;
+ }
+ 
+ static bool quirk_matches(const struct nvme_id_ctrl *id,
+ 			  const struct nvme_core_quirk_entry *q)
+ {
+ 	return q->vid == le16_to_cpu(id->vid) &&
+ 		string_matches(id->mn, q->mn, sizeof(id->mn)) &&
+ 		string_matches(id->fr, q->fr, sizeof(id->fr));
+ }
+ 
+ static void nvme_init_subnqn(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)
+ {
+ 	size_t nqnlen;
+ 	int off;
+ 
+ 	nqnlen = strnlen(id->subnqn, NVMF_NQN_SIZE);
+ 	if (nqnlen > 0 && nqnlen < NVMF_NQN_SIZE) {
+ 		strcpy(ctrl->subnqn, id->subnqn);
+ 		return;
+ 	}
+ 
+ 	if (ctrl->vs >= NVME_VS(1, 2, 1))
+ 		dev_warn(ctrl->device, "missing or invalid SUBNQN field.\n");
+ 
+ 	/* Generate a "fake" NQN per Figure 254 in NVMe 1.3 + ECN 001 */
+ 	off = snprintf(ctrl->subnqn, NVMF_NQN_SIZE,
+ 			"nqn.2014.08.org.nvmexpress:%4x%4x",
+ 			le16_to_cpu(id->vid), le16_to_cpu(id->ssvid));
+ 	memcpy(ctrl->subnqn + off, id->sn, sizeof(id->sn));
+ 	off += sizeof(id->sn);
+ 	memcpy(ctrl->subnqn + off, id->mn, sizeof(id->mn));
+ 	off += sizeof(id->mn);
+ 	memset(ctrl->subnqn + off, 0, sizeof(ctrl->subnqn) - off);
++>>>>>>> 634b83259050 (nvme: fix nvme reset command timeout handling)
  }
  
  /*
@@@ -1229,19 -1836,44 +1456,45 @@@ int nvme_init_identify(struct nvme_ctr
  		 * In fabrics we need to verify the cntlid matches the
  		 * admin connect
  		 */
- 		if (ctrl->cntlid != le16_to_cpu(id->cntlid))
+ 		if (ctrl->cntlid != le16_to_cpu(id->cntlid)) {
  			ret = -EINVAL;
+ 			goto out_free;
+ 		}
  
  		if (!ctrl->opts->discovery_nqn && !ctrl->kas) {
 -			dev_err(ctrl->device,
 +			dev_err(ctrl->dev,
  				"keep-alive support is mandatory for fabrics\n");
  			ret = -EINVAL;
+ 			goto out_free;
  		}
  	} else {
  		ctrl->cntlid = le16_to_cpu(id->cntlid);
  	}
  
  	kfree(id);
++<<<<<<< HEAD
++=======
+ 
+ 	if (ctrl->apst_enabled && !prev_apst_enabled)
+ 		dev_pm_qos_expose_latency_tolerance(ctrl->device);
+ 	else if (!ctrl->apst_enabled && prev_apst_enabled)
+ 		dev_pm_qos_hide_latency_tolerance(ctrl->device);
+ 
+ 	ret = nvme_configure_apst(ctrl);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = nvme_configure_directives(ctrl);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ctrl->identified = true;
+ 
+ 	return 0;
+ 
+ out_free:
+ 	kfree(id);
++>>>>>>> 634b83259050 (nvme: fix nvme reset command timeout handling)
  	return ret;
  }
  EXPORT_SYMBOL_GPL(nvme_init_identify);
* Unmerged path drivers/nvme/host/core.c
