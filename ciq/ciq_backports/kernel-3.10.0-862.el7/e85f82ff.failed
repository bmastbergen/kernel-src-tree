ovl: copy-up: don't unlock between lookup and link

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit e85f82ff9b8ef503923a3be8ca6b5fd1908a7f3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e85f82ff.failed

Nothing prevents mischief on upper layer while we are busy copying up the
data.

Move the lookup right before the looked up dentry is actually used.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Fixes: 01ad3eb8a073 ("ovl: concurrent copy up of regular files")
	Cc: <stable@vger.kernel.org> # v4.11
(cherry picked from commit e85f82ff9b8ef503923a3be8ca6b5fd1908a7f3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,ded8bfeb193e..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -276,21 -323,16 +276,27 @@@ static int ovl_copy_up_locked(struct de
  	int err;
  	const struct cred *old_creds = NULL;
  	struct cred *new_creds = NULL;
 -	struct cattr cattr = {
 -		/* Can't properly set mode on creation because of the umask */
 -		.mode = stat->mode & S_IFMT,
 -		.rdev = stat->rdev,
 -		.link = link
 -	};
  
 +	newdentry = ovl_lookup_temp(workdir, dentry);
 +	err = PTR_ERR(newdentry);
 +	if (IS_ERR(newdentry))
 +		goto out;
 +
++<<<<<<< HEAD
 +	upper = lookup_one_len(dentry->d_name.name, upperdir,
 +			       dentry->d_name.len);
 +	err = PTR_ERR(upper);
 +	if (IS_ERR(upper))
 +		goto out1;
 +
 +	err = security_inode_copy_up(dentry, &new_creds);
 +	if (err < 0)
 +		goto out2;
++=======
+ 	err = security_inode_copy_up(dentry, &new_creds);
+ 	if (err < 0)
+ 		goto out;
++>>>>>>> e85f82ff9b8e (ovl: copy-up: don't unlock between lookup and link)
  
  	if (new_creds)
  		old_creds = override_creds(new_creds);
@@@ -334,25 -397,36 +340,57 @@@
  	if (err)
  		goto out_cleanup;
  
++<<<<<<< HEAD
++=======
+ 	upper = lookup_one_len(dentry->d_name.name, upperdir,
+ 			       dentry->d_name.len);
+ 	if (IS_ERR(upper)) {
+ 		err = PTR_ERR(upper);
+ 		upper = NULL;
+ 		goto out_cleanup;
+ 	}
+ 
+ 	if (tmpfile)
+ 		err = ovl_do_link(temp, udir, upper, true);
+ 	else
+ 		err = ovl_do_rename(wdir, temp, udir, upper, 0);
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	newdentry = dget(tmpfile ? upper : temp);
++>>>>>>> e85f82ff9b8e (ovl: copy-up: don't unlock between lookup and link)
  	ovl_dentry_update(dentry, newdentry);
  	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
  
++<<<<<<< HEAD
 +	/*
 +	 * Non-directores become opaque when copied up.
 +	 */
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
 +	dput(upper);
 +out1:
 +	dput(newdentry);
++=======
+ 	/* Restore timestamps on parent (best effort) */
+ 	ovl_set_timestamps(upperdir, pstat);
++>>>>>>> e85f82ff9b8e (ovl: copy-up: don't unlock between lookup and link)
  out:
+ 	dput(temp);
+ 	dput(upper);
  	return err;
  
  out_cleanup:
++<<<<<<< HEAD
 +	ovl_cleanup(wdir, newdentry);
 +	goto out2;
++=======
+ 	if (!tmpfile)
+ 		ovl_cleanup(wdir, temp);
+ 	goto out;
++>>>>>>> e85f82ff9b8e (ovl: copy-up: don't unlock between lookup and link)
  }
  
  /*
* Unmerged path fs/overlayfs/copy_up.c
