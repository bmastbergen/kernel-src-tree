Drivers: hv: vmbus: Consolidate all Hyper-V specific clocksource code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] hv: vmbus: Consolidate all Hyper-V specific clocksource code (Vitaly Kuznetsov) [1410023]
Rebuild_FUZZ: 93.02%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 63ed4e0c67df332681ebfef6eca6852da28d6300
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/63ed4e0c.failed

As part of the effort to separate out architecture specific code,
consolidate all Hyper-V specific clocksource code to an architecture
specific code.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 63ed4e0c67df332681ebfef6eca6852da28d6300)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mshyperv.c
#	drivers/hv/hv.c
diff --cc arch/x86/kernel/cpu/mshyperv.c
index 13eadd65c578,d3705a44971c..000000000000
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@@ -133,33 -133,30 +133,36 @@@ static uint32_t  __init ms_hyperv_platf
  	return 0;
  }
  
 -static unsigned char hv_get_nmi_reason(void)
++<<<<<<< HEAD
 +static cycle_t read_hv_clock(struct clocksource *arg)
  {
 -	return 0;
 +	cycle_t current_tick;
 +	/*
 +	 * Read the partition counter to get the current tick count. This count
 +	 * is set to 0 when the partition is created and is incremented in
 +	 * 100 nanosecond units.
 +	 */
 +	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 +	return current_tick;
  }
  
 -#ifdef CONFIG_X86_LOCAL_APIC
 -/*
 - * Prior to WS2016 Debug-VM sends NMIs to all CPUs which makes
 - * it dificult to process CHANNELMSG_UNLOAD in case of crash. Handle
 - * unknown NMI on the first CPU which gets it.
 - */
 -static int hv_nmi_unknown(unsigned int val, struct pt_regs *regs)
 -{
 -	static atomic_t nmi_cpu = ATOMIC_INIT(-1);
 -
 -	if (!unknown_nmi_panic)
 -		return NMI_DONE;
 +static struct clocksource hyperv_cs_msr = {
 +	.name		= "hyperv_clocksource",
 +	.rating		= 400, /* use this when running on Hyperv*/
 +	.read		= read_hv_clock,
 +	.mask		= CLOCKSOURCE_MASK(64),
 +	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 +};
  
 -	if (atomic_cmpxchg(&nmi_cpu, -1, raw_smp_processor_id()) != -1)
 -		return NMI_HANDLED;
 +struct clocksource *hyperv_cs;
 +EXPORT_SYMBOL_GPL(hyperv_cs);
  
 -	return NMI_DONE;
++=======
++>>>>>>> 63ed4e0c67df (Drivers: hv: vmbus: Consolidate all Hyper-V specific clocksource code)
 +static unsigned char hv_get_nmi_reason(void)
 +{
 +	return 0;
  }
 -#endif
  
  static void __init ms_hyperv_init_platform(void)
  {
@@@ -183,16 -180,14 +186,19 @@@
  		rdmsrl(HV_X64_MSR_APIC_FREQUENCY, hv_lapic_frequency);
  		hv_lapic_frequency = div_u64(hv_lapic_frequency, HZ);
  		lapic_timer_frequency = hv_lapic_frequency;
 -		pr_info("HyperV: LAPIC Timer Frequency: %#x\n",
 -			lapic_timer_frequency);
 +		printk(KERN_INFO "HyperV: LAPIC Timer Frequency: %#x\n",
 +				lapic_timer_frequency);
  	}
 -
 -	register_nmi_handler(NMI_UNKNOWN, hv_nmi_unknown, NMI_FLAG_FIRST,
 -			     "hv_nmi_unknown");
  #endif
  
++<<<<<<< HEAD
 +	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE) {
 +		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
 +		hyperv_cs = &hyperv_cs_msr;
 +	}
 +
++=======
++>>>>>>> 63ed4e0c67df (Drivers: hv: vmbus: Consolidate all Hyper-V specific clocksource code)
  #ifdef CONFIG_X86_IO_APIC
  	no_timer_check = 1;
  #endif
diff --cc drivers/hv/hv.c
index f6a591c69dfd,1a33b59776d3..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -87,58 -87,6 +87,61 @@@ static int query_hypervisor_info(void
  	return max_leaf;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +static cycle_t read_hv_clock_tsc(struct clocksource *arg)
 +{
 +	cycle_t current_tick;
 +	struct ms_hyperv_tsc_page *tsc_pg = hv_context.tsc_page;
 +
 +	if (tsc_pg->tsc_sequence != 0) {
 +		/*
 +		 * Use the tsc page to compute the value.
 +		 */
 +
 +		while (1) {
 +			cycle_t tmp;
 +			u32 sequence = tsc_pg->tsc_sequence;
 +			u64 cur_tsc;
 +			u64 scale = tsc_pg->tsc_scale;
 +			s64 offset = tsc_pg->tsc_offset;
 +
 +			cur_tsc = rdtsc();
 +			/* current_tick = ((cur_tsc *scale) >> 64) + offset */
 +			asm("mulq %3"
 +				: "=d" (current_tick), "=a" (tmp)
 +				: "a" (cur_tsc), "r" (scale));
 +
 +			current_tick += offset;
 +			if (tsc_pg->tsc_sequence == sequence)
 +				return current_tick;
 +
 +			if (tsc_pg->tsc_sequence != 0)
 +				continue;
 +			/*
 +			 * Fallback using MSR method.
 +			 */
 +			break;
 +		}
 +	}
 +	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 +	return current_tick;
 +}
 +
 +static struct clocksource hyperv_cs_tsc = {
 +		.name           = "hyperv_clocksource_tsc_page",
 +		.rating         = 425,
 +		.read           = read_hv_clock_tsc,
 +		.mask           = CLOCKSOURCE_MASK(64),
 +		.flags          = CLOCK_SOURCE_IS_CONTINUOUS,
 +};
 +
 +static struct clocksource *hyperv_cs_old;
 +#endif
 +
 +
++=======
++>>>>>>> 63ed4e0c67df (Drivers: hv: vmbus: Consolidate all Hyper-V specific clocksource code)
  /*
   * hv_init - Main initialization routine.
   *
@@@ -173,31 -121,7 +176,31 @@@ int hv_init(void
  	if (!hypercall_msr.enable)
  		return -ENOTSUPP;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
 +		union hv_x64_msr_hypercall_contents tsc_msr;
 +		void *va_tsc;
 +
 +		va_tsc = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
 +		if (!va_tsc)
 +			goto cleanup;
 +		hv_context.tsc_page = va_tsc;
 +
 +		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 +
 +		tsc_msr.enable = 1;
 +		tsc_msr.guest_physical_address = vmalloc_to_pfn(va_tsc);
 +
 +		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 +		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
 +		hyperv_cs_old = hyperv_cs;
 +		hyperv_cs = &hyperv_cs_tsc;
 +	}
 +#endif
++=======
++>>>>>>> 63ed4e0c67df (Drivers: hv: vmbus: Consolidate all Hyper-V specific clocksource code)
  	return 0;
- 
- cleanup:
- 	return -ENOTSUPP;
  }
  
  /*
@@@ -208,30 -132,6 +211,33 @@@
  void hv_cleanup(bool crash)
  {
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +	union hv_x64_msr_hypercall_contents hypercall_msr;
 +	/*
 +	 * Cleanup the TSC page based CS.
 +	 */
 +	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
 +		/*
 +		 * Crash can happen in an interrupt context and unregistering
 +		 * a clocksource is impossible and redundant in this case.
 +		 */
 +		if (!oops_in_progress) {
 +			hyperv_cs = hyperv_cs_old;
 +			clocksource_change_rating(&hyperv_cs_tsc, 10);
 +			clocksource_unregister(&hyperv_cs_tsc);
 +		}
 +
 +		hypercall_msr.as_uint64 = 0;
 +		wrmsrl(HV_X64_MSR_REFERENCE_TSC, hypercall_msr.as_uint64);
 +		if (!crash) {
 +			vfree(hv_context.tsc_page);
 +			hv_context.tsc_page = NULL;
 +		}
 +	}
 +#endif
++=======
++>>>>>>> 63ed4e0c67df (Drivers: hv: vmbus: Consolidate all Hyper-V specific clocksource code)
  }
  
  /*
diff --git a/arch/x86/hyperv/hv_init.c b/arch/x86/hyperv/hv_init.c
index b5c8e04deacb..860233af4568 100644
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@ -24,6 +24,79 @@
 #include <linux/version.h>
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
+#include <linux/clockchips.h>
+
+
+#ifdef CONFIG_X86_64
+
+static struct ms_hyperv_tsc_page *tsc_pg;
+
+static u64 read_hv_clock_tsc(struct clocksource *arg)
+{
+	u64 current_tick;
+
+	if (tsc_pg->tsc_sequence != 0) {
+		/*
+		 * Use the tsc page to compute the value.
+		 */
+
+		while (1) {
+			u64 tmp;
+			u32 sequence = tsc_pg->tsc_sequence;
+			u64 cur_tsc;
+			u64 scale = tsc_pg->tsc_scale;
+			s64 offset = tsc_pg->tsc_offset;
+
+			rdtscll(cur_tsc);
+			/* current_tick = ((cur_tsc *scale) >> 64) + offset */
+			asm("mulq %3"
+				: "=d" (current_tick), "=a" (tmp)
+				: "a" (cur_tsc), "r" (scale));
+
+			current_tick += offset;
+			if (tsc_pg->tsc_sequence == sequence)
+				return current_tick;
+
+			if (tsc_pg->tsc_sequence != 0)
+				continue;
+			/*
+			 * Fallback using MSR method.
+			 */
+			break;
+		}
+	}
+	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+	return current_tick;
+}
+
+static struct clocksource hyperv_cs_tsc = {
+		.name		= "hyperv_clocksource_tsc_page",
+		.rating		= 400,
+		.read		= read_hv_clock_tsc,
+		.mask		= CLOCKSOURCE_MASK(64),
+		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+#endif
+
+static u64 read_hv_clock_msr(struct clocksource *arg)
+{
+	u64 current_tick;
+	/*
+	 * Read the partition counter to get the current tick count. This count
+	 * is set to 0 when the partition is created and is incremented in
+	 * 100 nanosecond units.
+	 */
+	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+	return current_tick;
+}
+
+static struct clocksource hyperv_cs_msr = {
+	.name		= "hyperv_clocksource_msr",
+	.rating		= 400,
+	.read		= read_hv_clock_msr,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
 
 static void *hypercall_pg;
 /*
@@ -31,6 +104,7 @@ static void *hypercall_pg;
  * hypervisor has been detected.
  *
  * 1. Setup the hypercall page.
+ * 2. Register Hyper-V specific clocksource.
  */
 void hyperv_init(void)
 {
@@ -58,6 +132,37 @@ void hyperv_init(void)
 	hypercall_msr.enable = 1;
 	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);
 	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
+
+	/*
+	 * Register Hyper-V specific clocksource.
+	 */
+#ifdef CONFIG_X86_64
+	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
+		union hv_x64_msr_hypercall_contents tsc_msr;
+
+		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
+		if (!tsc_pg) {
+			clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
+			return;
+		}
+
+		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+
+		tsc_msr.enable = 1;
+		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
+
+		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+		return;
+	}
+#endif
+	/*
+	 * For 32 bit guests just use the MSR based mechanism for reading
+	 * the partition counter.
+	 */
+
+	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
+		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
 }
 
 /*
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 766df316b67a..7c510a750f17 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -27,6 +27,18 @@ union hv_x64_msr_hypercall_contents {
 	};
 };
 
+/*
+ * TSC page layout.
+ */
+
+struct ms_hyperv_tsc_page {
+	volatile u32 tsc_sequence;
+	u32 reserved1;
+	volatile u64 tsc_scale;
+	volatile s64 tsc_offset;
+	u64 reserved2[509];
+};
+
 /*
  * The guest OS needs to register the guest ID with the hypervisor.
  * The guest ID is a 64 bit entity and the structure of this ID is
* Unmerged path arch/x86/kernel/cpu/mshyperv.c
* Unmerged path drivers/hv/hv.c
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 058c591c09f6..7bc3f8a39a88 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -508,14 +508,6 @@ struct hv_context {
 
 extern struct hv_context hv_context;
 
-struct ms_hyperv_tsc_page {
-	volatile u32 tsc_sequence;
-	u32 reserved1;
-	volatile u64 tsc_scale;
-	volatile s64 tsc_offset;
-	u64 reserved2[509];
-};
-
 struct hv_ring_buffer_debug_info {
 	u32 current_interrupt_mask;
 	u32 current_read_index;
