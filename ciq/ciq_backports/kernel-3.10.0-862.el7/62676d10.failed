qxl: alloc & use shadow for dumb buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Gerd Hoffmann <kraxel@redhat.com>
commit 62676d10b483a2ff6e8b08c5e7c7d63a831343f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/62676d10.failed

This patch changes the way the primary surface is used for dumb
framebuffers.  Instead of configuring the bo itself as primary surface
a shadow bo is created and used instead.  Framebuffers can share the
shadow bo in case they have the same format and resolution.

On atomic plane updates we don't have to update the primary surface in
case we pageflip from one framebuffer to another framebuffer which
shares the same shadow.  This in turn avoids the flicker caused by the
primary-destroy + primary-create cycle, which is very annonying when
running wayland on qxl.

The qxl driver never actually writes to the shadow bo.  It sends qxl
blit commands which update it though, and the spice server might
actually execute them (and thereby write to the shadow) in case the
local rendering is kicked for some reason.  This happens for example in
case qemu is asked to write out a dump of the guest display (screendump
monitor command).

	Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
	Reviewed-by: Dave Airlie <airlied@redhat.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20171019062150.28090-3-kraxel@redhat.com
(cherry picked from commit 62676d10b483a2ff6e8b08c5e7c7d63a831343f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/qxl/qxl_display.c
diff --cc drivers/gpu/drm/qxl/qxl_display.c
index 4b5eab8a47b3,4756b3c9bf2c..000000000000
--- a/drivers/gpu/drm/qxl/qxl_display.c
+++ b/drivers/gpu/drm/qxl/qxl_display.c
@@@ -809,14 -467,384 +811,388 @@@ static void qxl_crtc_disable(struct drm
  }
  
  static const struct drm_crtc_helper_funcs qxl_crtc_helper_funcs = {
 +	.dpms = qxl_crtc_dpms,
 +	.disable = qxl_crtc_disable,
  	.mode_fixup = qxl_crtc_mode_fixup,
 -	.mode_set_nofb = qxl_mode_set_nofb,
 -	.atomic_flush = qxl_crtc_atomic_flush,
 -	.atomic_enable = qxl_crtc_atomic_enable,
 -	.atomic_disable = qxl_crtc_atomic_disable,
 +	.mode_set = qxl_crtc_mode_set,
 +	.prepare = qxl_crtc_prepare,
 +	.commit = qxl_crtc_commit,
  };
  
++<<<<<<< HEAD
++=======
+ static int qxl_primary_atomic_check(struct drm_plane *plane,
+ 				    struct drm_plane_state *state)
+ {
+ 	struct qxl_device *qdev = plane->dev->dev_private;
+ 	struct qxl_framebuffer *qfb;
+ 	struct qxl_bo *bo;
+ 
+ 	if (!state->crtc || !state->fb)
+ 		return 0;
+ 
+ 	qfb = to_qxl_framebuffer(state->fb);
+ 	bo = gem_to_qxl_bo(qfb->obj);
+ 
+ 	if (bo->surf.stride * bo->surf.height > qdev->vram_size) {
+ 		DRM_ERROR("Mode doesn't fit in vram size (vgamem)");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void qxl_primary_atomic_update(struct drm_plane *plane,
+ 				      struct drm_plane_state *old_state)
+ {
+ 	struct qxl_device *qdev = plane->dev->dev_private;
+ 	struct qxl_framebuffer *qfb =
+ 		to_qxl_framebuffer(plane->state->fb);
+ 	struct qxl_framebuffer *qfb_old;
+ 	struct qxl_bo *bo = gem_to_qxl_bo(qfb->obj);
+ 	struct qxl_bo *bo_old;
+ 	struct drm_clip_rect norect = {
+ 	    .x1 = 0,
+ 	    .y1 = 0,
+ 	    .x2 = qfb->base.width,
+ 	    .y2 = qfb->base.height
+ 	};
+ 	bool same_shadow = false;
+ 
+ 	if (old_state->fb) {
+ 		qfb_old = to_qxl_framebuffer(old_state->fb);
+ 		bo_old = gem_to_qxl_bo(qfb_old->obj);
+ 	} else {
+ 		bo_old = NULL;
+ 	}
+ 
+ 	if (bo == bo_old)
+ 		return;
+ 
+ 	if (bo_old && bo_old->shadow && bo->shadow &&
+ 	    bo_old->shadow == bo->shadow) {
+ 		same_shadow = true;
+ 	}
+ 
+ 	if (bo_old && bo_old->is_primary) {
+ 		if (!same_shadow)
+ 			qxl_io_destroy_primary(qdev);
+ 		bo_old->is_primary = false;
+ 	}
+ 
+ 	if (!bo->is_primary) {
+ 		if (!same_shadow)
+ 			qxl_io_create_primary(qdev, 0, bo);
+ 		bo->is_primary = true;
+ 	}
+ 
+ 	qxl_draw_dirty_fb(qdev, qfb, bo, 0, 0, &norect, 1, 1);
+ }
+ 
+ static void qxl_primary_atomic_disable(struct drm_plane *plane,
+ 				       struct drm_plane_state *old_state)
+ {
+ 	struct qxl_device *qdev = plane->dev->dev_private;
+ 
+ 	if (old_state->fb) {
+ 		struct qxl_framebuffer *qfb =
+ 			to_qxl_framebuffer(old_state->fb);
+ 		struct qxl_bo *bo = gem_to_qxl_bo(qfb->obj);
+ 
+ 		if (bo->is_primary) {
+ 			qxl_io_destroy_primary(qdev);
+ 			bo->is_primary = false;
+ 		}
+ 	}
+ }
+ 
+ static int qxl_plane_atomic_check(struct drm_plane *plane,
+ 				  struct drm_plane_state *state)
+ {
+ 	return 0;
+ }
+ 
+ static void qxl_cursor_atomic_update(struct drm_plane *plane,
+ 				     struct drm_plane_state *old_state)
+ {
+ 	struct drm_device *dev = plane->dev;
+ 	struct qxl_device *qdev = dev->dev_private;
+ 	struct drm_framebuffer *fb = plane->state->fb;
+ 	struct qxl_release *release;
+ 	struct qxl_cursor_cmd *cmd;
+ 	struct qxl_cursor *cursor;
+ 	struct drm_gem_object *obj;
+ 	struct qxl_bo *cursor_bo, *user_bo = NULL;
+ 	int ret;
+ 	void *user_ptr;
+ 	int size = 64*64*4;
+ 
+ 	ret = qxl_alloc_release_reserved(qdev, sizeof(*cmd),
+ 					 QXL_RELEASE_CURSOR_CMD,
+ 					 &release, NULL);
+ 	if (ret)
+ 		return;
+ 
+ 	if (fb != old_state->fb) {
+ 		obj = to_qxl_framebuffer(fb)->obj;
+ 		user_bo = gem_to_qxl_bo(obj);
+ 
+ 		/* pinning is done in the prepare/cleanup framevbuffer */
+ 		ret = qxl_bo_kmap(user_bo, &user_ptr);
+ 		if (ret)
+ 			goto out_free_release;
+ 
+ 		ret = qxl_alloc_bo_reserved(qdev, release,
+ 					    sizeof(struct qxl_cursor) + size,
+ 					    &cursor_bo);
+ 		if (ret)
+ 			goto out_kunmap;
+ 
+ 		ret = qxl_release_reserve_list(release, true);
+ 		if (ret)
+ 			goto out_free_bo;
+ 
+ 		ret = qxl_bo_kmap(cursor_bo, (void **)&cursor);
+ 		if (ret)
+ 			goto out_backoff;
+ 
+ 		cursor->header.unique = 0;
+ 		cursor->header.type = SPICE_CURSOR_TYPE_ALPHA;
+ 		cursor->header.width = 64;
+ 		cursor->header.height = 64;
+ 		cursor->header.hot_spot_x = fb->hot_x;
+ 		cursor->header.hot_spot_y = fb->hot_y;
+ 		cursor->data_size = size;
+ 		cursor->chunk.next_chunk = 0;
+ 		cursor->chunk.prev_chunk = 0;
+ 		cursor->chunk.data_size = size;
+ 		memcpy(cursor->chunk.data, user_ptr, size);
+ 		qxl_bo_kunmap(cursor_bo);
+ 		qxl_bo_kunmap(user_bo);
+ 
+ 		cmd = (struct qxl_cursor_cmd *) qxl_release_map(qdev, release);
+ 		cmd->u.set.visible = 1;
+ 		cmd->u.set.shape = qxl_bo_physical_address(qdev,
+ 							   cursor_bo, 0);
+ 		cmd->type = QXL_CURSOR_SET;
+ 	} else {
+ 
+ 		ret = qxl_release_reserve_list(release, true);
+ 		if (ret)
+ 			goto out_free_release;
+ 
+ 		cmd = (struct qxl_cursor_cmd *) qxl_release_map(qdev, release);
+ 		cmd->type = QXL_CURSOR_MOVE;
+ 	}
+ 
+ 	cmd->u.position.x = plane->state->crtc_x + fb->hot_x;
+ 	cmd->u.position.y = plane->state->crtc_y + fb->hot_y;
+ 
+ 	qxl_release_unmap(qdev, release, &cmd->release_info);
+ 	qxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);
+ 	qxl_release_fence_buffer_objects(release);
+ 
+ 	return;
+ 
+ out_backoff:
+ 	qxl_release_backoff_reserve_list(release);
+ out_free_bo:
+ 	qxl_bo_unref(&cursor_bo);
+ out_kunmap:
+ 	qxl_bo_kunmap(user_bo);
+ out_free_release:
+ 	qxl_release_free(qdev, release);
+ 	return;
+ 
+ }
+ 
+ static void qxl_cursor_atomic_disable(struct drm_plane *plane,
+ 				      struct drm_plane_state *old_state)
+ {
+ 	struct qxl_device *qdev = plane->dev->dev_private;
+ 	struct qxl_release *release;
+ 	struct qxl_cursor_cmd *cmd;
+ 	int ret;
+ 
+ 	ret = qxl_alloc_release_reserved(qdev, sizeof(*cmd),
+ 					 QXL_RELEASE_CURSOR_CMD,
+ 					 &release, NULL);
+ 	if (ret)
+ 		return;
+ 
+ 	ret = qxl_release_reserve_list(release, true);
+ 	if (ret) {
+ 		qxl_release_free(qdev, release);
+ 		return;
+ 	}
+ 
+ 	cmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);
+ 	cmd->type = QXL_CURSOR_HIDE;
+ 	qxl_release_unmap(qdev, release, &cmd->release_info);
+ 
+ 	qxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);
+ 	qxl_release_fence_buffer_objects(release);
+ }
+ 
+ static int qxl_plane_prepare_fb(struct drm_plane *plane,
+ 				struct drm_plane_state *new_state)
+ {
+ 	struct qxl_device *qdev = plane->dev->dev_private;
+ 	struct drm_gem_object *obj;
+ 	struct qxl_bo *user_bo, *old_bo = NULL;
+ 	int ret;
+ 
+ 	if (!new_state->fb)
+ 		return 0;
+ 
+ 	obj = to_qxl_framebuffer(new_state->fb)->obj;
+ 	user_bo = gem_to_qxl_bo(obj);
+ 
+ 	if (plane->type == DRM_PLANE_TYPE_PRIMARY &&
+ 	    user_bo->is_dumb && !user_bo->shadow) {
+ 		if (plane->state->fb) {
+ 			obj = to_qxl_framebuffer(plane->state->fb)->obj;
+ 			old_bo = gem_to_qxl_bo(obj);
+ 		}
+ 		if (old_bo && old_bo->shadow &&
+ 		    user_bo->gem_base.size == old_bo->gem_base.size &&
+ 		    plane->state->crtc     == new_state->crtc &&
+ 		    plane->state->crtc_w   == new_state->crtc_w &&
+ 		    plane->state->crtc_h   == new_state->crtc_h &&
+ 		    plane->state->src_x    == new_state->src_x &&
+ 		    plane->state->src_y    == new_state->src_y &&
+ 		    plane->state->src_w    == new_state->src_w &&
+ 		    plane->state->src_h    == new_state->src_h &&
+ 		    plane->state->rotation == new_state->rotation &&
+ 		    plane->state->zpos     == new_state->zpos) {
+ 			drm_gem_object_get(&old_bo->shadow->gem_base);
+ 			user_bo->shadow = old_bo->shadow;
+ 		} else {
+ 			qxl_bo_create(qdev, user_bo->gem_base.size,
+ 				      true, true, QXL_GEM_DOMAIN_VRAM, NULL,
+ 				      &user_bo->shadow);
+ 		}
+ 	}
+ 
+ 	ret = qxl_bo_pin(user_bo, QXL_GEM_DOMAIN_CPU, NULL);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ 
+ static void qxl_plane_cleanup_fb(struct drm_plane *plane,
+ 				 struct drm_plane_state *old_state)
+ {
+ 	struct drm_gem_object *obj;
+ 	struct qxl_bo *user_bo;
+ 
+ 	if (!old_state->fb) {
+ 		/*
+ 		 * we never executed prepare_fb, so there's nothing to
+ 		 * unpin.
+ 		 */
+ 		return;
+ 	}
+ 
+ 	obj = to_qxl_framebuffer(old_state->fb)->obj;
+ 	user_bo = gem_to_qxl_bo(obj);
+ 	qxl_bo_unpin(user_bo);
+ 
+ 	if (user_bo->shadow && !user_bo->is_primary) {
+ 		drm_gem_object_put_unlocked(&user_bo->shadow->gem_base);
+ 		user_bo->shadow = NULL;
+ 	}
+ }
+ 
+ static const uint32_t qxl_cursor_plane_formats[] = {
+ 	DRM_FORMAT_ARGB8888,
+ };
+ 
+ static const struct drm_plane_helper_funcs qxl_cursor_helper_funcs = {
+ 	.atomic_check = qxl_plane_atomic_check,
+ 	.atomic_update = qxl_cursor_atomic_update,
+ 	.atomic_disable = qxl_cursor_atomic_disable,
+ 	.prepare_fb = qxl_plane_prepare_fb,
+ 	.cleanup_fb = qxl_plane_cleanup_fb,
+ };
+ 
+ static const struct drm_plane_funcs qxl_cursor_plane_funcs = {
+ 	.update_plane	= drm_atomic_helper_update_plane,
+ 	.disable_plane	= drm_atomic_helper_disable_plane,
+ 	.destroy	= drm_primary_helper_destroy,
+ 	.reset		= drm_atomic_helper_plane_reset,
+ 	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+ 	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+ };
+ 
+ static const uint32_t qxl_primary_plane_formats[] = {
+ 	DRM_FORMAT_XRGB8888,
+ 	DRM_FORMAT_ARGB8888,
+ };
+ 
+ static const struct drm_plane_helper_funcs primary_helper_funcs = {
+ 	.atomic_check = qxl_primary_atomic_check,
+ 	.atomic_update = qxl_primary_atomic_update,
+ 	.atomic_disable = qxl_primary_atomic_disable,
+ 	.prepare_fb = qxl_plane_prepare_fb,
+ 	.cleanup_fb = qxl_plane_cleanup_fb,
+ };
+ 
+ static const struct drm_plane_funcs qxl_primary_plane_funcs = {
+ 	.update_plane	= drm_atomic_helper_update_plane,
+ 	.disable_plane	= drm_atomic_helper_disable_plane,
+ 	.destroy	= drm_primary_helper_destroy,
+ 	.reset		= drm_atomic_helper_plane_reset,
+ 	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+ 	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+ };
+ 
+ static struct drm_plane *qxl_create_plane(struct qxl_device *qdev,
+ 					  unsigned int possible_crtcs,
+ 					  enum drm_plane_type type)
+ {
+ 	const struct drm_plane_helper_funcs *helper_funcs = NULL;
+ 	struct drm_plane *plane;
+ 	const struct drm_plane_funcs *funcs;
+ 	const uint32_t *formats;
+ 	int num_formats;
+ 	int err;
+ 
+ 	if (type == DRM_PLANE_TYPE_PRIMARY) {
+ 		funcs = &qxl_primary_plane_funcs;
+ 		formats = qxl_primary_plane_formats;
+ 		num_formats = ARRAY_SIZE(qxl_primary_plane_formats);
+ 		helper_funcs = &primary_helper_funcs;
+ 	} else if (type == DRM_PLANE_TYPE_CURSOR) {
+ 		funcs = &qxl_cursor_plane_funcs;
+ 		formats = qxl_cursor_plane_formats;
+ 		helper_funcs = &qxl_cursor_helper_funcs;
+ 		num_formats = ARRAY_SIZE(qxl_cursor_plane_formats);
+ 	} else {
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	plane = kzalloc(sizeof(*plane), GFP_KERNEL);
+ 	if (!plane)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	err = drm_universal_plane_init(&qdev->ddev, plane, possible_crtcs,
+ 				       funcs, formats, num_formats,
+ 				       NULL, type, NULL);
+ 	if (err)
+ 		goto free_plane;
+ 
+ 	drm_plane_helper_add(plane, helper_funcs);
+ 
+ 	return plane;
+ 
+ free_plane:
+ 	kfree(plane);
+ 	return ERR_PTR(-EINVAL);
+ }
+ 
++>>>>>>> 62676d10b483 (qxl: alloc & use shadow for dumb buffers)
  static int qdev_crtc_init(struct drm_device *dev, int crtc_id)
  {
  	struct qxl_crtc *qxl_crtc;
diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c
index 8ec53d5abd62..c0fb52c6d4ca 100644
--- a/drivers/gpu/drm/qxl/qxl_cmd.c
+++ b/drivers/gpu/drm/qxl/qxl_cmd.c
@@ -387,7 +387,11 @@ void qxl_io_create_primary(struct qxl_device *qdev,
 	create->width = bo->surf.width;
 	create->height = bo->surf.height;
 	create->stride = bo->surf.stride;
-	create->mem = qxl_bo_physical_address(qdev, bo, offset);
+	if (bo->shadow) {
+		create->mem = qxl_bo_physical_address(qdev, bo->shadow, offset);
+	} else {
+		create->mem = qxl_bo_physical_address(qdev, bo, offset);
+	}
 
 	DRM_DEBUG_DRIVER("mem = %llx, from %p\n", create->mem, bo->kptr);
 
* Unmerged path drivers/gpu/drm/qxl/qxl_display.c
diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 5f8d1b2ecd43..daf95f58e8b3 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -89,6 +89,8 @@ struct qxl_bo {
 	/* Constant after initialization */
 	struct drm_gem_object		gem_base;
 	bool is_primary; /* is this now a primary surface */
+	bool is_dumb;
+	struct qxl_bo *shadow;
 	bool hw_surf_alloc;
 	struct qxl_surface surf;
 	uint32_t surface_id;
diff --git a/drivers/gpu/drm/qxl/qxl_dumb.c b/drivers/gpu/drm/qxl/qxl_dumb.c
index 5e65d5d2d937..11085ab01374 100644
--- a/drivers/gpu/drm/qxl/qxl_dumb.c
+++ b/drivers/gpu/drm/qxl/qxl_dumb.c
@@ -63,6 +63,7 @@ int qxl_mode_dumb_create(struct drm_file *file_priv,
 					      &handle);
 	if (r)
 		return r;
+	qobj->is_dumb = true;
 	args->pitch = pitch;
 	args->handle = handle;
 	return 0;
