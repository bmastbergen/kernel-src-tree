scsi: qla2xxx: Allow MBC_GET_PORT_DATABASE to query and save the port states

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Allow MBC_GET_PORT_DATABASE to query and save the port states (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 95.89%
commit-author Duane Grigsby <duane.grigsby@cavium.com>
commit c0c462c8a061658ce5ae53c423b2a14bb280c2ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c0c462c8.failed

The MBC_GET_PORT_DATABASE command normally checks the port state
information. This patch allows it to save that info in the fcport
structure and ignore the check if the query flag is set.

[mkp: typo]

	Signed-off-by: Duane Grigsby <duane.grigsby@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c0c462c8a061658ce5ae53c423b2a14bb280c2ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,f712c0cd46d6..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2027,6 -2294,40 +2027,43 @@@ typedef struct fc_port 
  	uint16_t loop_id;
  	uint16_t old_loop_id;
  
++<<<<<<< HEAD
++=======
+ 	unsigned int conf_compl_supported:1;
+ 	unsigned int deleted:2;
+ 	unsigned int local:1;
+ 	unsigned int logout_on_delete:1;
+ 	unsigned int logo_ack_needed:1;
+ 	unsigned int keep_nport_handle:1;
+ 	unsigned int send_els_logo:1;
+ 	unsigned int login_pause:1;
+ 	unsigned int login_succ:1;
+ 	unsigned int query:1;
+ 
+ 	struct work_struct nvme_del_work;
+ 	struct completion nvme_del_done;
+ 	uint32_t nvme_prli_service_param;
+ #define NVME_PRLI_SP_CONF       BIT_7
+ #define NVME_PRLI_SP_INITIATOR  BIT_5
+ #define NVME_PRLI_SP_TARGET     BIT_4
+ #define NVME_PRLI_SP_DISCOVERY  BIT_3
+ 	uint8_t nvme_flag;
+ #define NVME_FLAG_REGISTERED 4
+ 
+ 	struct fc_port *conflict;
+ 	unsigned char logout_completed;
+ 	int generation;
+ 
+ 	struct se_session *se_sess;
+ 	struct kref sess_kref;
+ 	struct qla_tgt *tgt;
+ 	unsigned long expires;
+ 	struct list_head del_list_entry;
+ 	struct work_struct free_work;
+ 
+ 	struct qlt_plogi_ack_t *plogi_link[QLT_PLOGI_LINK_MAX];
+ 
++>>>>>>> c0c462c8a061 (scsi: qla2xxx: Allow MBC_GET_PORT_DATABASE to query and save the port states)
  	uint16_t tgt_id;
  	uint16_t old_tgt_id;
  
@@@ -2053,9 -2355,38 +2090,26 @@@
  
  	uint16_t port_id;
  
 -	struct nvme_fc_remote_port *nvme_remote_port;
 -
  	unsigned long retry_delay_timestamp;
++<<<<<<< HEAD
++=======
+ 	struct qla_tgt_sess *tgt_session;
+ 	struct ct_sns_desc ct_desc;
+ 	enum discovery_state disc_state;
+ 	enum login_state fw_login_state;
+ 	unsigned long plogi_nack_done_deadline;
+ 
+ 	u32 login_gen, last_login_gen;
+ 	u32 rscn_gen, last_rscn_gen;
+ 	u32 chip_reset;
+ 	struct list_head gnl_entry;
+ 	struct work_struct del_work;
+ 	u8 iocb[IOCB_SIZE];
+ 	u8 current_login_state;
+ 	u8 last_login_state;
++>>>>>>> c0c462c8a061 (scsi: qla2xxx: Allow MBC_GET_PORT_DATABASE to query and save the port states)
  } fc_port_t;
  
 -#define QLA_FCPORT_SCAN		1
 -#define QLA_FCPORT_FOUND	2
 -
 -struct event_arg {
 -	enum fcport_mgt_event	event;
 -	fc_port_t		*fcport;
 -	srb_t			*sp;
 -	port_id_t		id;
 -	u16			data[2], rc;
 -	u8			port_name[WWN_SIZE];
 -	u32			iop[2];
 -};
 -
  #include "qla_mr.h"
  
  /*
@@@ -3614,6 -4115,9 +3668,12 @@@ typedef struct scsi_qla_host 
  #define FX00_CRITEMP_RECOVERY	25
  #define FX00_HOST_INFO_RESEND	26
  #define QPAIR_ONLINE_CHECK_NEEDED	27
++<<<<<<< HEAD
++=======
+ #define SET_ZIO_THRESHOLD_NEEDED	28
+ #define DETECT_SFP_CHANGE	29
+ #define N2N_LOGIN_NEEDED	30
++>>>>>>> c0c462c8a061 (scsi: qla2xxx: Allow MBC_GET_PORT_DATABASE to query and save the port states)
  
  	unsigned long	pci_flags;
  #define PFLG_DISCONNECTED	0	/* PCI device removed */
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 11982e7bd50f..467ebefd6dc9 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -1568,17 +1568,32 @@ qla2x00_get_port_database(scsi_qla_host_t *vha, fc_port_t *fcport, uint8_t opt)
 
 	if (IS_FWI2_CAPABLE(ha)) {
 		uint64_t zero = 0;
+		u8 current_login_state, last_login_state;
+
 		pd24 = (struct port_database_24xx *) pd;
 
 		/* Check for logged in state. */
-		if (pd24->current_login_state != PDS_PRLI_COMPLETE &&
-		    pd24->last_login_state != PDS_PRLI_COMPLETE) {
-			ql_dbg(ql_dbg_mbx, vha, 0x1051,
-			    "Unable to verify login-state (%x/%x) for "
-			    "loop_id %x.\n", pd24->current_login_state,
-			    pd24->last_login_state, fcport->loop_id);
+		if (fcport->fc4f_nvme) {
+			current_login_state = pd24->current_login_state >> 4;
+			last_login_state = pd24->last_login_state >> 4;
+		} else {
+			current_login_state = pd24->current_login_state & 0xf;
+			last_login_state = pd24->last_login_state & 0xf;
+		}
+		fcport->current_login_state = pd24->current_login_state;
+		fcport->last_login_state = pd24->last_login_state;
+
+		/* Check for logged in state. */
+		if (current_login_state != PDS_PRLI_COMPLETE &&
+		    last_login_state != PDS_PRLI_COMPLETE) {
+			ql_dbg(ql_dbg_mbx, vha, 0x119a,
+			    "Unable to verify login-state (%x/%x) for loop_id %x.\n",
+			    current_login_state, last_login_state,
+			    fcport->loop_id);
 			rval = QLA_FUNCTION_FAILED;
-			goto gpd_error_out;
+
+			if (!fcport->query)
+				goto gpd_error_out;
 		}
 
 		if (fcport->loop_id == FC_NO_LOOP_ID ||
