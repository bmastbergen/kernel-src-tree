mm: workingset: fix crash in shadow node shrinker caused by replace_page_cache_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] workingset: fix crash in shadow node shrinker caused by replace_page_cache_page() (Waiman Long) [1441710]
Rebuild_FUZZ: 97.59%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 22f2ac51b6d643666f4db093f13144f773ff3f3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/22f2ac51.failed

Antonio reports the following crash when using fuse under memory pressure:

  kernel BUG at /build/linux-a2WvEb/linux-4.4.0/mm/workingset.c:346!
  invalid opcode: 0000 [#1] SMP
  Modules linked in: all of them
  CPU: 2 PID: 63 Comm: kswapd0 Not tainted 4.4.0-36-generic #55-Ubuntu
  Hardware name: System manufacturer System Product Name/P8H67-M PRO, BIOS 3904 04/27/2013
  task: ffff88040cae6040 ti: ffff880407488000 task.ti: ffff880407488000
  RIP: shadow_lru_isolate+0x181/0x190
  Call Trace:
    __list_lru_walk_one.isra.3+0x8f/0x130
    list_lru_walk_one+0x23/0x30
    scan_shadow_nodes+0x34/0x50
    shrink_slab.part.40+0x1ed/0x3d0
    shrink_zone+0x2ca/0x2e0
    kswapd+0x51e/0x990
    kthread+0xd8/0xf0
    ret_from_fork+0x3f/0x70

which corresponds to the following sanity check in the shadow node
tracking:

  BUG_ON(node->count & RADIX_TREE_COUNT_MASK);

The workingset code tracks radix tree nodes that exclusively contain
shadow entries of evicted pages in them, and this (somewhat obscure)
line checks whether there are real pages left that would interfere with
reclaim of the radix tree node under memory pressure.

While discussing ways how fuse might sneak pages into the radix tree
past the workingset code, Miklos pointed to replace_page_cache_page(),
and indeed there is a problem there: it properly accounts for the old
page being removed - __delete_from_page_cache() does that - but then
does a raw raw radix_tree_insert(), not accounting for the replacement
page.  Eventually the page count bits in node->count underflow while
leaving the node incorrectly linked to the shadow node LRU.

To address this, make sure replace_page_cache_page() uses the tracked
page insertion code, page_cache_tree_insert().  This fixes the page
accounting and makes sure page-containing nodes are properly unlinked
from the shadow node LRU again.

Also, make the sanity checks a bit less obscure by using the helpers for
checking the number of pages and shadows in a radix tree node.

Fixes: 449dd6984d0e ("mm: keep page cache radix tree nodes in check")
Link: http://lkml.kernel.org/r/20160919155822.29498-1-hannes@cmpxchg.org
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Reported-by: Antonio SJ Musumeci <trapexit@spawn.link>
	Debugged-by: Miklos Szeredi <miklos@szeredi.hu>
	Cc: <stable@vger.kernel.org>	[3.15+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 22f2ac51b6d643666f4db093f13144f773ff3f3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/filemap.c
#	mm/workingset.c
diff --cc mm/filemap.c
index 08b95d6a5228,2d0986a64f1f..000000000000
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@@ -524,17 -615,21 +580,17 @@@ int replace_page_cache_page(struct pag
  		new->mapping = mapping;
  		new->index = offset;
  
 -		spin_lock_irqsave(&mapping->tree_lock, flags);
 +		spin_lock_irq(&mapping->tree_lock);
  		__delete_from_page_cache(old, NULL);
- 		error = radix_tree_insert(&mapping->page_tree, offset, new);
+ 		error = page_cache_tree_insert(mapping, new, NULL);
  		BUG_ON(error);
  		mapping->nrpages++;
 -
 -		/*
 -		 * hugetlb pages do not participate in page cache accounting.
 -		 */
 -		if (!PageHuge(new))
 -			__inc_node_page_state(new, NR_FILE_PAGES);
 +		__inc_zone_page_state(new, NR_FILE_PAGES);
  		if (PageSwapBacked(new))
 -			__inc_node_page_state(new, NR_SHMEM);
 -		spin_unlock_irqrestore(&mapping->tree_lock, flags);
 -		mem_cgroup_migrate(old, new);
 +			__inc_zone_page_state(new, NR_SHMEM);
 +		spin_unlock_irq(&mapping->tree_lock);
 +		/* mem_cgroup codes must not be called under tree_lock */
 +		mem_cgroup_replace_page_cache(old, new);
  		radix_tree_preload_end();
  		if (freepage)
  			freepage(old);
@@@ -545,61 -640,6 +601,64 @@@
  }
  EXPORT_SYMBOL_GPL(replace_page_cache_page);
  
++<<<<<<< HEAD
 +static int page_cache_tree_insert(struct address_space *mapping,
 +				  struct page *page, void **shadowp)
 +{
 +	struct radix_tree_node *node;
 +	void **slot;
 +	int error;
 +
 +	error = __radix_tree_create(&mapping->page_tree, page->index,
 +				    &node, &slot);
 +	if (error)
 +		return error;
 +	if (*slot) {
 +		void *p;
 +
 +		p = radix_tree_deref_slot_protected(slot, &mapping->tree_lock);
 +		if (!radix_tree_exceptional_entry(p))
 +			return -EEXIST;
 +
 +		mapping->nrexceptional--;
 +		if (!dax_mapping(mapping)) {
 +			if (shadowp)
 +				*shadowp = p;
 +			if (node)
 +				workingset_node_shadows_dec(node);
 +		} else {
 +			/* DAX can replace empty locked entry with a hole */
 +			WARN_ON_ONCE(p !=
 +				(void *)(RADIX_TREE_EXCEPTIONAL_ENTRY |
 +					 RADIX_DAX_ENTRY_LOCK));
 +			/* DAX accounts exceptional entries as normal pages */
 +			if (node)
 +				workingset_node_pages_dec(node);
 +			/* Wakeup waiters for exceptional entry lock */
 +			dax_wake_mapping_entry_waiter(mapping, page->index, p,
 +						      true);
 +		}
 +	}
 +	radix_tree_replace_slot(slot, page);
 +	mapping->nrpages++;
 +	if (node) {
 +		workingset_node_pages_inc(node);
 +		/*
 +		 * Don't track node that contains actual pages.
 +		 *
 +		 * Avoid acquiring the list_lru lock if already
 +		 * untracked.  The list_empty() test is safe as
 +		 * node->private_list is protected by
 +		 * mapping->tree_lock.
 +		 */
 +		if (!list_empty(&node->private_list))
 +			workingset_forget_node(node);
 +	}
 +	return 0;
 +}
 +
++=======
++>>>>>>> 22f2ac51b6d6 (mm: workingset: fix crash in shadow node shrinker caused by replace_page_cache_page())
  static int __add_to_page_cache_locked(struct page *page,
  				      struct address_space *mapping,
  				      pgoff_t offset, gfp_t gfp_mask,
diff --cc mm/workingset.c
index 69a3283c2741,617475f529f4..000000000000
--- a/mm/workingset.c
+++ b/mm/workingset.c
@@@ -366,8 -430,8 +364,13 @@@ static void shadow_lru_isolate(struct l
  			mapping->nrexceptional--;
  		}
  	}
++<<<<<<< HEAD
 +	BUG_ON(node->count);
 +	inc_zone_state(page_zone(virt_to_page(node)), WORKINGSET_NODERECLAIM);
++=======
+ 	BUG_ON(workingset_node_shadows(node));
+ 	inc_node_state(page_pgdat(virt_to_page(node)), WORKINGSET_NODERECLAIM);
++>>>>>>> 22f2ac51b6d6 (mm: workingset: fix crash in shadow node shrinker caused by replace_page_cache_page())
  	if (!__radix_tree_delete_node(&mapping->page_tree, node))
  		BUG();
  
diff --git a/include/linux/swap.h b/include/linux/swap.h
index 61d41d507b58..dc191ae07a69 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -258,6 +258,7 @@ static inline void workingset_node_pages_inc(struct radix_tree_node *node)
 
 static inline void workingset_node_pages_dec(struct radix_tree_node *node)
 {
+	VM_BUG_ON(!workingset_node_pages(node));
 	node->count--;
 }
 
@@ -273,6 +274,7 @@ static inline void workingset_node_shadows_inc(struct radix_tree_node *node)
 
 static inline void workingset_node_shadows_dec(struct radix_tree_node *node)
 {
+	VM_BUG_ON(!workingset_node_shadows(node));
 	node->count -= 1U << RADIX_TREE_COUNT_SHIFT;
 }
 
* Unmerged path mm/filemap.c
* Unmerged path mm/workingset.c
