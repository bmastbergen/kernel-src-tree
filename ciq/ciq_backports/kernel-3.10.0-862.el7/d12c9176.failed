bridge: resolve a false alarm of lockdep

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit d12c917691b45d9dffcfe7c2362d25caa40905fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d12c9176.failed

Andrei reported a false alarm of lockdep at net/bridge/br_fdb.c:109,
this is because in Andrei's case, a spin_bug() was already triggered
before this, therefore the debug_locks is turned off, lockdep_is_held()
is no longer accurate after that. We should use lockdep_assert_held_once()
instead of lockdep_is_held() to respect debug_locks.

Fixes: 410b3d48f5111 ("bridge: fdb: add proper lock checks in searching functions")
	Reported-by: Andrei Vagin <avagin@gmail.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d12c917691b45d9dffcfe7c2362d25caa40905fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_fdb.c
diff --cc net/bridge/br_fdb.c
index fd15fe70631e,6e08b7199dd7..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -86,6 -83,47 +86,50 @@@ static void fdb_rcu_free(struct rcu_hea
  	kmem_cache_free(br_fdb_cache, ent);
  }
  
++<<<<<<< HEAD
++=======
+ static struct net_bridge_fdb_entry *fdb_find_rcu(struct hlist_head *head,
+ 						 const unsigned char *addr,
+ 						 __u16 vid)
+ {
+ 	struct net_bridge_fdb_entry *f;
+ 
+ 	WARN_ON_ONCE(!rcu_read_lock_held());
+ 
+ 	hlist_for_each_entry_rcu(f, head, hlist)
+ 		if (ether_addr_equal(f->addr.addr, addr) && f->vlan_id == vid)
+ 			break;
+ 
+ 	return f;
+ }
+ 
+ /* requires bridge hash_lock */
+ static struct net_bridge_fdb_entry *br_fdb_find(struct net_bridge *br,
+ 						const unsigned char *addr,
+ 						__u16 vid)
+ {
+ 	struct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];
+ 	struct net_bridge_fdb_entry *fdb;
+ 
+ 	lockdep_assert_held_once(&br->hash_lock);
+ 
+ 	rcu_read_lock();
+ 	fdb = fdb_find_rcu(head, addr, vid);
+ 	rcu_read_unlock();
+ 
+ 	return fdb;
+ }
+ 
+ struct net_bridge_fdb_entry *br_fdb_find_rcu(struct net_bridge *br,
+ 					     const unsigned char *addr,
+ 					     __u16 vid)
+ {
+ 	struct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];
+ 
+ 	return fdb_find_rcu(head, addr, vid);
+ }
+ 
++>>>>>>> d12c917691b4 (bridge: resolve a false alarm of lockdep)
  /* When a static FDB entry is added, the mac address from the entry is
   * added to the bridge private HW address list and all required ports
   * are then updated with the new information.
* Unmerged path net/bridge/br_fdb.c
