x86, drm, fbdev: Do not specify encrypted memory for video mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] drm, fbdev: Do not specify encrypted memory for video mappings (Suravee Suthikulpanit) [1361287]
Rebuild_FUZZ: 96.12%
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 95cf9264d5f36c291c1c50c00349f83348e6f9c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/95cf9264.failed

Since video memory needs to be accessed decrypted, be sure that the
memory encryption mask is not set for the video ranges.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Larry Woodman <lwoodman@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Toshimitsu Kani <toshi.kani@hpe.com>
	Cc: kasan-dev@googlegroups.com
	Cc: kvm@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-efi@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/a19436f30424402e01f63a09b32ab103272acced.1500319216.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 95cf9264d5f36c291c1c50c00349f83348e6f9c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/pageattr.c
#	drivers/gpu/drm/ttm/ttm_bo_vm.c
diff --cc arch/x86/mm/pageattr.c
index 3fe832369c84,dfb7d657cf43..000000000000
--- a/arch/x86/mm/pageattr.c
+++ b/arch/x86/mm/pageattr.c
@@@ -1645,6 -1775,70 +1645,73 @@@ int set_memory_4k(unsigned long addr, i
  					__pgprot(0), 1, 0, NULL);
  }
  
++<<<<<<< HEAD
++=======
+ static int __set_memory_enc_dec(unsigned long addr, int numpages, bool enc)
+ {
+ 	struct cpa_data cpa;
+ 	unsigned long start;
+ 	int ret;
+ 
+ 	/* Nothing to do if the SME is not active */
+ 	if (!sme_active())
+ 		return 0;
+ 
+ 	/* Should not be working on unaligned addresses */
+ 	if (WARN_ONCE(addr & ~PAGE_MASK, "misaligned address: %#lx\n", addr))
+ 		addr &= PAGE_MASK;
+ 
+ 	start = addr;
+ 
+ 	memset(&cpa, 0, sizeof(cpa));
+ 	cpa.vaddr = &addr;
+ 	cpa.numpages = numpages;
+ 	cpa.mask_set = enc ? __pgprot(_PAGE_ENC) : __pgprot(0);
+ 	cpa.mask_clr = enc ? __pgprot(0) : __pgprot(_PAGE_ENC);
+ 	cpa.pgd = init_mm.pgd;
+ 
+ 	/* Must avoid aliasing mappings in the highmem code */
+ 	kmap_flush_unused();
+ 	vm_unmap_aliases();
+ 
+ 	/*
+ 	 * Before changing the encryption attribute, we need to flush caches.
+ 	 */
+ 	if (static_cpu_has(X86_FEATURE_CLFLUSH))
+ 		cpa_flush_range(start, numpages, 1);
+ 	else
+ 		cpa_flush_all(1);
+ 
+ 	ret = __change_page_attr_set_clr(&cpa, 1);
+ 
+ 	/*
+ 	 * After changing the encryption attribute, we need to flush TLBs
+ 	 * again in case any speculative TLB caching occurred (but no need
+ 	 * to flush caches again).  We could just use cpa_flush_all(), but
+ 	 * in case TLB flushing gets optimized in the cpa_flush_range()
+ 	 * path use the same logic as above.
+ 	 */
+ 	if (static_cpu_has(X86_FEATURE_CLFLUSH))
+ 		cpa_flush_range(start, numpages, 0);
+ 	else
+ 		cpa_flush_all(0);
+ 
+ 	return ret;
+ }
+ 
+ int set_memory_encrypted(unsigned long addr, int numpages)
+ {
+ 	return __set_memory_enc_dec(addr, numpages, true);
+ }
+ EXPORT_SYMBOL_GPL(set_memory_encrypted);
+ 
+ int set_memory_decrypted(unsigned long addr, int numpages)
+ {
+ 	return __set_memory_enc_dec(addr, numpages, false);
+ }
+ EXPORT_SYMBOL_GPL(set_memory_decrypted);
+ 
++>>>>>>> 95cf9264d5f3 (x86, drm, fbdev: Do not specify encrypted memory for video mappings)
  int set_pages_uc(struct page *page, int numpages)
  {
  	unsigned long addr = (unsigned long)page_address(page);
diff --cc drivers/gpu/drm/ttm/ttm_bo_vm.c
index 4748aedc933a,84fb009d4eb0..000000000000
--- a/drivers/gpu/drm/ttm/ttm_bo_vm.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_vm.c
@@@ -218,9 -231,11 +219,17 @@@ static int ttm_bo_vm_fault(struct vm_ar
  	 * first page.
  	 */
  	for (i = 0; i < TTM_BO_VM_NUM_PREFAULT; ++i) {
++<<<<<<< HEAD
 +		if (bo->mem.bus.is_iomem)
 +			pfn = ((bo->mem.bus.base + bo->mem.bus.offset) >> PAGE_SHIFT) + page_offset;
 +		else {
++=======
+ 		if (bo->mem.bus.is_iomem) {
+ 			/* Iomem should not be marked encrypted */
+ 			cvma.vm_page_prot = pgprot_decrypted(cvma.vm_page_prot);
+ 			pfn = bdev->driver->io_mem_pfn(bo, page_offset);
+ 		} else {
++>>>>>>> 95cf9264d5f3 (x86, drm, fbdev: Do not specify encrypted memory for video mappings)
  			page = ttm->pages[page_offset];
  			if (unlikely(!page && i == 0)) {
  				retval = VM_FAULT_OOM;
diff --git a/arch/x86/include/asm/vga.h b/arch/x86/include/asm/vga.h
index 44282fbf7bf9..ab4847e99bce 100644
--- a/arch/x86/include/asm/vga.h
+++ b/arch/x86/include/asm/vga.h
@@ -7,12 +7,24 @@
 #ifndef _ASM_X86_VGA_H
 #define _ASM_X86_VGA_H
 
+#include <asm/set_memory.h>
+
 /*
  *	On the PC, we can just recalculate addresses and then
  *	access the videoram directly without any black magic.
+ *	To support memory encryption however, we need to access
+ *	the videoram as decrypted memory.
  */
 
-#define VGA_MAP_MEM(x, s) (unsigned long)phys_to_virt(x)
+#define VGA_MAP_MEM(x, s)					\
+({								\
+	unsigned long start = (unsigned long)phys_to_virt(x);	\
+								\
+	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT))			\
+		set_memory_decrypted(start, (s) >> PAGE_SHIFT);	\
+								\
+	start;							\
+})
 
 #define vga_readb(x) (*(x))
 #define vga_writeb(x, y) (*(y) = (x))
* Unmerged path arch/x86/mm/pageattr.c
diff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c
index 465bacd0a630..f9b3be0cf0bc 100644
--- a/drivers/gpu/drm/drm_gem.c
+++ b/drivers/gpu/drm/drm_gem.c
@@ -36,6 +36,7 @@
 #include <linux/pagemap.h>
 #include <linux/shmem_fs.h>
 #include <linux/dma-buf.h>
+#include <linux/mem_encrypt.h>
 #include <drm/drmP.h>
 #include <drm/drm_vma_manager.h>
 #include <drm/drm_gem.h>
@@ -928,6 +929,7 @@ int drm_gem_mmap_obj(struct drm_gem_object *obj, unsigned long obj_size,
 	vma->vm_ops = dev->driver->gem_vm_ops;
 	vma->vm_private_data = obj;
 	vma->vm_page_prot = pgprot_writecombine(vm_get_page_prot(vma->vm_flags));
+	vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);
 
 	/* Take a ref for this mapping of the object, so that the fault
 	 * handler can dereference the mmap offset's pointer to the object.
diff --git a/drivers/gpu/drm/drm_vm.c b/drivers/gpu/drm/drm_vm.c
index caa4e4ca616d..b643a26599d7 100644
--- a/drivers/gpu/drm/drm_vm.c
+++ b/drivers/gpu/drm/drm_vm.c
@@ -40,6 +40,7 @@
 #include <linux/efi.h>
 #include <linux/slab.h>
 #endif
+#include <linux/mem_encrypt.h>
 #include <asm/pgtable.h>
 #include "drm_internal.h"
 #include "drm_legacy.h"
@@ -58,6 +59,9 @@ static pgprot_t drm_io_prot(struct drm_local_map *map,
 {
 	pgprot_t tmp = vm_get_page_prot(vma->vm_flags);
 
+	/* We don't want graphics memory to be mapped encrypted */
+	tmp = pgprot_decrypted(tmp);
+
 #if defined(__i386__) || defined(__x86_64__) || defined(__powerpc__)
 	if (map->type == _DRM_REGISTERS && !(map->flags & _DRM_WRITE_COMBINING))
 		tmp = pgprot_noncached(tmp);
* Unmerged path drivers/gpu/drm/ttm/ttm_bo_vm.c
diff --git a/drivers/gpu/drm/udl/udl_fb.c b/drivers/gpu/drm/udl/udl_fb.c
index 4f299de66c87..6b4e770b1e19 100644
--- a/drivers/gpu/drm/udl/udl_fb.c
+++ b/drivers/gpu/drm/udl/udl_fb.c
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/fb.h>
 #include <linux/dma-buf.h>
+#include <linux/mem_encrypt.h>
 
 #include <drm/drmP.h>
 #include <drm/drm_crtc.h>
@@ -169,6 +170,9 @@ static int udl_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
 	pr_notice("mmap() framebuffer addr:%lu size:%lu\n",
 		  pos, size);
 
+	/* We don't want the framebuffer to be mapped encrypted */
+	vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);
+
 	while (size > 0) {
 		page = vmalloc_to_pfn((void *)pos);
 		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index ea8257aab07c..aa912766e434 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -32,6 +32,7 @@
 #include <linux/device.h>
 #include <linux/efi.h>
 #include <linux/fb.h>
+#include <linux/mem_encrypt.h>
 
 #include <asm/fb.h>
 
@@ -1393,6 +1394,12 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)
 	mutex_lock(&info->mm_lock);
 	if (fb->fb_mmap) {
 		int res;
+
+		/*
+		 * The framebuffer needs to be accessed decrypted, be sure
+		 * SME protection is removed ahead of the call
+		 */
+		vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);
 		res = fb->fb_mmap(info, vma);
 		mutex_unlock(&info->mm_lock);
 		return res;
@@ -1418,6 +1425,11 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)
 	mutex_unlock(&info->mm_lock);
 
 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	/*
+	 * The framebuffer needs to be accessed decrypted, be sure
+	 * SME protection is removed
+	 */
+	vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);
 	fb_pgprotect(file, vma, start);
 
 	return vm_iomap_memory(vma, start, len);
