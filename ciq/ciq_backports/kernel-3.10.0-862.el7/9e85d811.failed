radix-tree: make radix_tree_descend() more useful

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 9e85d811196583126785a0405d0c879ae7a9eb2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9e85d811.failed

Now that the shift amount is stored in the node, radix_tree_descend()
can calculate offset itself from index, which removes several lines of
code from each of the tree walkers.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Neil Brown <neilb@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9e85d811196583126785a0405d0c879ae7a9eb2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index 31edcb4c659f,8b7d8459bb9d..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -535,20 -536,20 +536,26 @@@ int __radix_tree_create(struct radix_tr
  			break;
  
  		/* Go a level down */
++<<<<<<< HEAD
 +		height--;
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		node = indirect_to_ptr(slot);
 +		slot = node->slots[offset];
++=======
+ 		node = entry_to_node(child);
+ 		offset = radix_tree_descend(node, &child, index);
+ 		slot = &node->slots[offset];
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  	}
  
 -#ifdef CONFIG_RADIX_TREE_MULTIORDER
  	/* Insert pointers to the canonical entry */
  	if (order > shift) {
 -		unsigned i, n = 1 << (order - shift);
 +		int i, n = 1 << (order - shift);
  		offset = offset & ~(n - 1);
 -		slot = &node->slots[offset];
 -		child = node_to_entry(slot);
 +		slot = ptr_to_indirect(&node->slots[offset]);
  		for (i = 0; i < n; i++) {
 -			if (slot[i])
 +			if (node->slots[offset + i])
  				return -EEXIST;
  		}
  
@@@ -637,10 -639,8 +643,15 @@@ void *__radix_tree_lookup(struct radix_
  
  		if (node == RADIX_TREE_RETRY)
  			goto restart;
++<<<<<<< HEAD
 +		parent = indirect_to_ptr(node);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		offset = radix_tree_descend(parent, &node, offset);
++=======
+ 		parent = entry_to_node(node);
+ 		offset = radix_tree_descend(parent, &node, index);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  		slot = parent->slots + offset;
  	}
  
@@@ -710,19 -710,15 +721,23 @@@ void *radix_tree_tag_set(struct radix_t
  {
  	struct radix_tree_node *node, *parent;
  	unsigned long maxindex;
- 	unsigned int shift;
  
- 	shift = radix_tree_load_root(root, &node, &maxindex);
+ 	radix_tree_load_root(root, &node, &maxindex);
  	BUG_ON(index > maxindex);
  
 -	while (radix_tree_is_internal_node(node)) {
 +	while (radix_tree_is_indirect_ptr(node)) {
  		unsigned offset;
  
++<<<<<<< HEAD
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +
 +		parent = indirect_to_ptr(node);
 +		offset = radix_tree_descend(parent, &node, offset);
++=======
+ 		parent = entry_to_node(node);
+ 		offset = radix_tree_descend(parent, &node, index);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  		BUG_ON(!node);
  
  		if (!tag_get(parent, tag, offset))
@@@ -785,12 -780,9 +799,18 @@@ void *radix_tree_tag_clear(struct radix
  
  	parent = NULL;
  
++<<<<<<< HEAD
 +	while (radix_tree_is_indirect_ptr(node)) {
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +
 +		parent = indirect_to_ptr(node);
 +		offset = radix_tree_descend(parent, &node, offset);
++=======
+ 	while (radix_tree_is_internal_node(node)) {
+ 		parent = entry_to_node(node);
+ 		offset = radix_tree_descend(parent, &node, index);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  	}
  
  	if (node)
@@@ -831,14 -822,11 +850,22 @@@ int radix_tree_tag_get(struct radix_tre
  	if (node == NULL)
  		return 0;
  
++<<<<<<< HEAD
 +	while (radix_tree_is_indirect_ptr(node)) {
 +		int offset;
 +
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +
 +		parent = indirect_to_ptr(node);
 +		offset = radix_tree_descend(parent, &node, offset);
++=======
+ 	while (radix_tree_is_internal_node(node)) {
+ 		unsigned offset;
+ 
+ 		parent = entry_to_node(node);
+ 		offset = radix_tree_descend(parent, &node, index);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  
  		if (!node)
  			return 0;
@@@ -863,9 -859,9 +890,15 @@@ EXPORT_SYMBOL(radix_tree_tag_get)
  void **radix_tree_next_chunk(struct radix_tree_root *root,
  			     struct radix_tree_iter *iter, unsigned flags)
  {
++<<<<<<< HEAD
 +	unsigned shift, tag = flags & RADIX_TREE_ITER_TAG_MASK;
 +	struct radix_tree_node *rnode, *node;
 +	unsigned long index, offset, height;
++=======
+ 	unsigned tag = flags & RADIX_TREE_ITER_TAG_MASK;
+ 	struct radix_tree_node *node, *child;
+ 	unsigned long index, offset, maxindex;
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  
  	if ((flags & RADIX_TREE_ITER_TAGGED) && !root_tag_get(root, tag))
  		return NULL;
@@@ -883,33 -879,28 +916,50 @@@
  	if (!index && iter->index)
  		return NULL;
  
++<<<<<<< HEAD
 +	rnode = rcu_dereference_raw(root->rnode);
 +	if (radix_tree_is_indirect_ptr(rnode)) {
 +		rnode = indirect_to_ptr(rnode);
 +	} else if (rnode && !index) {
++=======
+  restart:
+ 	radix_tree_load_root(root, &child, &maxindex);
+ 	if (index > maxindex)
+ 		return NULL;
+ 	if (!child)
+ 		return NULL;
+ 
+ 	if (!radix_tree_is_internal_node(child)) {
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  		/* Single-slot tree */
 -		iter->index = index;
 -		iter->next_index = maxindex + 1;
 +		iter->index = 0;
 +		iter->next_index = 1;
  		iter->tags = 1;
 -		__set_iter_shift(iter, 0);
  		return (void **)&root->rnode;
 -	}
 +	} else
 +		return NULL;
  
++<<<<<<< HEAD
 +restart:
 +	height = rnode->path & RADIX_TREE_HEIGHT_MASK;
 +	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
 +	offset = index >> shift;
++=======
+ 	do {
+ 		node = entry_to_node(child);
+ 		offset = radix_tree_descend(node, &child, index);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
 +
 +	/* Index outside of the tree */
 +	if (offset >= RADIX_TREE_MAP_SIZE)
 +		return NULL;
  
 +	node = rnode;
 +	while (1) {
 +		struct radix_tree_node *slot;
  		if ((flags & RADIX_TREE_ITER_TAGGED) ?
 -				!tag_get(node, tag, offset) : !child) {
 +				!test_bit(offset, node->tags[tag]) :
 +				!node->slots[offset]) {
  			/* Hole detected */
  			if (flags & RADIX_TREE_ITER_CONTIG)
  				return NULL;
@@@ -921,35 -912,30 +971,46 @@@
  						offset + 1);
  			else
  				while (++offset	< RADIX_TREE_MAP_SIZE) {
 -					void *slot = node->slots[offset];
 -					if (is_sibling_entry(node, slot))
 -						continue;
 -					if (slot)
 +					if (node->slots[offset])
  						break;
  				}
++<<<<<<< HEAD
 +			index &= ~((RADIX_TREE_MAP_SIZE << shift) - 1);
 +			index += offset << shift;
++=======
+ 			index &= ~node_maxindex(node);
+ 			index += offset << node->shift;
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  			/* Overflow after ~0UL */
  			if (!index)
  				return NULL;
  			if (offset == RADIX_TREE_MAP_SIZE)
  				goto restart;
 -			child = rcu_dereference_raw(node->slots[offset]);
  		}
  
 -		if ((child == NULL) || (child == RADIX_TREE_RETRY))
 +		/* This is leaf-node */
 +		if (!shift)
 +			break;
 +
 +		slot = rcu_dereference_raw(node->slots[offset]);
 +		if (slot == NULL)
  			goto restart;
 -	} while (radix_tree_is_internal_node(child));
 +		if (!radix_tree_is_indirect_ptr(slot))
 +			break;
 +		node = indirect_to_ptr(slot);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +	}
  
  	/* Update the iterator state */
++<<<<<<< HEAD
 +	iter->index = index;
 +	iter->next_index = (index | RADIX_TREE_MAP_MASK) + 1;
++=======
+ 	iter->index = (index &~ node_maxindex(node)) | (offset << node->shift);
+ 	iter->next_index = (index | node_maxindex(node)) + 1;
+ 	__set_iter_shift(iter, node->shift);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  
  	/* Construct iter->tags bit-mask from node->tags[tag] array */
  	if (flags & RADIX_TREE_ITER_TAGGED) {
@@@ -1005,14 -991,13 +1066,24 @@@ unsigned long radix_tree_range_tag_if_t
  		unsigned long nr_to_tag,
  		unsigned int iftag, unsigned int settag)
  {
++<<<<<<< HEAD
 +	unsigned int height = root->height;
 +	struct radix_tree_node *node = NULL;
 +	struct radix_tree_node *slot;
 +	unsigned int shift;
 +	unsigned long tagged = 0;
 +	unsigned long index = *first_indexp;
 +
 +	last_index = min(last_index, radix_tree_maxindex(height));
++=======
+ 	struct radix_tree_node *parent, *node, *child;
+ 	unsigned long maxindex;
+ 	unsigned long tagged = 0;
+ 	unsigned long index = *first_indexp;
+ 
+ 	radix_tree_load_root(root, &child, &maxindex);
+ 	last_index = min(last_index, maxindex);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  	if (index > last_index)
  		return 0;
  	if (!nr_to_tag)
@@@ -1027,74 -1012,56 +1098,105 @@@
  		return 1;
  	}
  
++<<<<<<< HEAD
 +	shift = (height - 1) * RADIX_TREE_MAP_SHIFT;
 +	slot = indirect_to_ptr(root->rnode);
 +
 +	for (;;) {
 +		unsigned long upindex;
 +		int offset;
 +
 +		offset = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		if (!slot->slots[offset])
++=======
+ 	node = entry_to_node(child);
+ 
+ 	for (;;) {
+ 		unsigned offset = radix_tree_descend(node, &child, index);
+ 		if (!child)
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  			goto next;
 -		if (!tag_get(node, iftag, offset))
 +		if (!tag_get(slot, iftag, offset))
  			goto next;
++<<<<<<< HEAD
 +		if (shift) {
 +			node = slot;
 +			slot = slot->slots[offset];
 +			if (radix_tree_is_indirect_ptr(slot)) {
 +				slot = indirect_to_ptr(slot);
 +				shift -= RADIX_TREE_MAP_SHIFT;
 +				continue;
 +			} else {
 +				slot = node;
 +				node = node->parent;
 +			}
++=======
+ 		/* Sibling slots never have tags set on them */
+ 		if (radix_tree_is_internal_node(child)) {
+ 			node = entry_to_node(child);
+ 			continue;
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  		}
  
  		/* tag the leaf */
 -		tagged++;
 -		tag_set(node, settag, offset);
 +		tagged += 1 << shift;
 +		tag_set(slot, settag, offset);
  
  		/* walk back up the path tagging interior nodes */
 -		parent = node;
 -		for (;;) {
 -			offset = parent->offset;
 -			parent = parent->parent;
 -			if (!parent)
 -				break;
 +		upindex = index;
 +		while (node) {
 +			upindex >>= RADIX_TREE_MAP_SHIFT;
 +			offset = upindex & RADIX_TREE_MAP_MASK;
 +
  			/* stop if we find a node with the tag already set */
 -			if (tag_get(parent, settag, offset))
 +			if (tag_get(node, settag, offset))
  				break;
 -			tag_set(parent, settag, offset);
 +			tag_set(node, settag, offset);
 +			node = node->parent;
  		}
++<<<<<<< HEAD
 +
 +		/*
 +		 * Small optimization: now clear that node pointer.
 +		 * Since all of this slot's ancestors now have the tag set
 +		 * from setting it above, we have no further need to walk
 +		 * back up the tree setting tags, until we update slot to
 +		 * point to another radix_tree_node.
 +		 */
 +		node = NULL;
 +
 +next:
 +		/* Go to next item at level determined by 'shift' */
 +		index = ((index >> shift) + 1) << shift;
 +		/* Overflow can happen when last_index is ~0UL... */
 +		if (index > last_index || !index)
 +			break;
 +		if (tagged >= nr_to_tag)
 +			break;
 +		while (((index >> shift) & RADIX_TREE_MAP_MASK) == 0) {
++=======
+  next:
+ 		/* Go to next entry in node */
+ 		index = ((index >> node->shift) + 1) << node->shift;
+ 		/* Overflow can happen when last_index is ~0UL... */
+ 		if (index > last_index || !index)
+ 			break;
+ 		offset = (index >> node->shift) & RADIX_TREE_MAP_MASK;
+ 		while (offset == 0) {
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  			/*
  			 * We've fully scanned this node. Go up. Because
  			 * last_index is guaranteed to be in the tree, what
  			 * we do below cannot wander astray.
  			 */
++<<<<<<< HEAD
 +			slot = slot->parent;
 +			shift += RADIX_TREE_MAP_SHIFT;
++=======
+ 			node = node->parent;
+ 			offset = (index >> node->shift) & RADIX_TREE_MAP_MASK;
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  		}
 -		if (is_sibling_entry(node, node->slots[offset]))
 -			goto next;
 -		if (tagged >= nr_to_tag)
 -			break;
  	}
  	/*
  	 * We need not to tag the root tag if there is no tag which is set with
@@@ -1279,54 -1252,39 +1381,72 @@@ EXPORT_SYMBOL(radix_tree_gang_lookup_ta
   * This linear search is at present only useful to shmem_unuse_inode().
   */
  static unsigned long __locate(struct radix_tree_node *slot, void *item,
 -			      unsigned long index, struct locate_info *info)
 +			      unsigned long index, unsigned long *found_index)
  {
++<<<<<<< HEAD
 +	unsigned int shift, height;
 +	unsigned long i;
 +
 +	height = slot->path & RADIX_TREE_HEIGHT_MASK;
 +	shift = (height-1) * RADIX_TREE_MAP_SHIFT;
 +
 +	for ( ; height > 1; height--) {
 +		i = (index >> shift) & RADIX_TREE_MAP_MASK;
 +		for (;;) {
 +			if (slot->slots[i] != NULL)
 +				break;
 +			index &= ~((1UL << shift) - 1);
 +			index += 1UL << shift;
 +			if (index == 0)
 +				goto out;	/* 32-bit wraparound */
 +			i++;
 +			if (i == RADIX_TREE_MAP_SIZE)
++=======
+ 	unsigned long i;
+ 
+ 	do {
+ 		unsigned int shift = slot->shift;
+ 
+ 		for (i = (index >> shift) & RADIX_TREE_MAP_MASK;
+ 		     i < RADIX_TREE_MAP_SIZE;
+ 		     i++, index += (1UL << shift)) {
+ 			struct radix_tree_node *node =
+ 					rcu_dereference_raw(slot->slots[i]);
+ 			if (node == RADIX_TREE_RETRY)
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  				goto out;
 -			if (!radix_tree_is_internal_node(node)) {
 -				if (node == item) {
 -					info->found_index = index;
 -					info->stop = true;
 -					goto out;
 -				}
 -				continue;
 -			}
 -			node = entry_to_node(node);
 -			if (is_sibling_entry(slot, node))
 -				continue;
 -			slot = node;
 -			break;
  		}
++<<<<<<< HEAD
++=======
+ 	} while (i < RADIX_TREE_MAP_SIZE);
++>>>>>>> 9e85d8111965 (radix-tree: make radix_tree_descend() more useful)
  
 +		slot = rcu_dereference_raw(slot->slots[i]);
 +		if (slot == NULL)
 +			goto out;
 +		if (!radix_tree_is_indirect_ptr(slot)) {
 +			if (slot == item) {
 +				*found_index = index + i;
 +				index = 0;
 +			} else {
 +				index += shift;
 +			}
 +			goto out;
 +		}
 +		slot = indirect_to_ptr(slot);
 +		shift -= RADIX_TREE_MAP_SHIFT;
 +	}
 +
 +	/* Bottom level: check items */
 +	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
 +		if (slot->slots[i] == item) {
 +			*found_index = index + i;
 +			index = 0;
 +			goto out;
 +		}
 +	}
 +	index += RADIX_TREE_MAP_SIZE;
  out:
 -	if ((index == 0) && (i == RADIX_TREE_MAP_SIZE))
 -		info->stop = true;
  	return index;
  }
  
* Unmerged path lib/radix-tree.c
