vmbus: expose hv_begin/end_read

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 6e47dd3e2938f41d75045bbcb64aa9df3a463b2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6e47dd3e.failed

In order to implement NAPI in netvsc, the driver needs access to
control host interrupt mask.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6e47dd3e2938f41d75045bbcb64aa9df3a463b2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
diff --cc drivers/hv/ring_buffer.c
index f549e81b014a,75c9eefd55b5..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -32,26 -32,6 +32,29 @@@
  
  #include "hyperv_vmbus.h"
  
++<<<<<<< HEAD
 +void hv_begin_read(struct hv_ring_buffer_info *rbi)
 +{
 +	rbi->ring_buffer->interrupt_mask = 1;
 +	mb();
 +}
 +
 +u32 hv_end_read(struct hv_ring_buffer_info *rbi)
 +{
 +
 +	rbi->ring_buffer->interrupt_mask = 0;
 +	mb();
 +
 +	/*
 +	 * Now check to see if the ring buffer is still empty.
 +	 * If it is not, we raced and we need to process new
 +	 * incoming messages.
 +	 */
 +	return hv_get_bytes_to_read(rbi);
 +}
 +
++=======
++>>>>>>> 6e47dd3e2938 (vmbus: expose hv_begin/end_read)
  /*
   * When we write to the ring buffer, check if the host needs to
   * be signaled. Here is the details of this protocol:
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index c92ad5535c23..eb9014ca6ed5 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -491,10 +491,6 @@ int hv_ringbuffer_read(struct vmbus_channel *channel,
 void hv_ringbuffer_get_debuginfo(struct hv_ring_buffer_info *ring_info,
 			    struct hv_ring_buffer_debug_info *debug_info);
 
-void hv_begin_read(struct hv_ring_buffer_info *rbi);
-
-u32 hv_end_read(struct hv_ring_buffer_info *rbi);
-
 /*
  * Maximum channels is determined by the size of the interrupt page
  * which is PAGE_SIZE. 1/2 of PAGE_SIZE is for send endpoint interrupt
* Unmerged path drivers/hv/ring_buffer.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2d127a5ad611..306381e41775 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1553,6 +1553,36 @@ init_cached_read_index(struct vmbus_channel *channel)
 	rbi->cached_read_index = rbi->ring_buffer->read_index;
 }
 
+/*
+ * Mask off host interrupt callback notifications
+ */
+static inline void hv_begin_read(struct hv_ring_buffer_info *rbi)
+{
+	rbi->ring_buffer->interrupt_mask = 1;
+
+	/* make sure mask update is not reordered */
+	virt_mb();
+}
+
+/*
+ * Re-enable host callback and return number of outstanding bytes
+ */
+static inline u32 hv_end_read(struct hv_ring_buffer_info *rbi)
+{
+
+	rbi->ring_buffer->interrupt_mask = 0;
+
+	/* make sure mask update is not reordered */
+	virt_mb();
+
+	/*
+	 * Now check to see if the ring buffer is still empty.
+	 * If it is not, we raced and we need to process new
+	 * incoming messages.
+	 */
+	return hv_get_bytes_to_read(rbi);
+}
+
 /*
  * An API to support in-place processing of incoming VMBUS packets.
  */
