sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 7c6e2d362c19f01e6d6c8be59d83a89722032884
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7c6e2d36.failed

A directory sysfs_dirent points to the associated kobj.  A regular or
bin file points to the associated [bin_]attribute.  This patch
replaces sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with void *
->priv.

This is to prepare for kernfs interface so that sysfs can specify the
private data in the same way for directories and files.  This lower
debuggability but not by much - the whole thing was overlaid in a
union anyway.  If debuggability becomes an issue, we can later add
->priv accessors which explicitly check for the sysfs_dirent type and
performs casting.

This patch doesn't introduce any behavior difference.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7c6e2d362c19f01e6d6c8be59d83a89722032884)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
#	fs/sysfs/inode.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/file.c
index d8887c896abc,9b58d874c825..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -41,52 -44,91 +41,91 @@@ struct sysfs_open_dirent 
  	atomic_t		refcnt;
  	atomic_t		event;
  	wait_queue_head_t	poll;
 -	struct list_head	files; /* goes through sysfs_open_file.list */
 +	struct list_head	buffers; /* goes through sysfs_buffer.list */
  };
  
 -struct sysfs_open_file {
 -	struct sysfs_dirent	*sd;
 -	struct file		*file;
 +struct sysfs_buffer {
 +	size_t			count;
 +	loff_t			pos;
 +	char			* page;
 +	const struct sysfs_ops	* ops;
  	struct mutex		mutex;
 +	int			needs_read_fill;
  	int			event;
  	struct list_head	list;
 -
 -	bool			mmapped;
 -	const struct vm_operations_struct *vm_ops;
  };
  
 -static bool sysfs_is_bin(struct sysfs_dirent *sd)
 -{
 -	return sysfs_type(sd) == SYSFS_KOBJ_BIN_ATTR;
 -}
 -
 -static struct sysfs_open_file *sysfs_of(struct file *file)
 -{
 -	return ((struct seq_file *)file->private_data)->private;
 -}
 -
 -/*
 - * Determine ktype->sysfs_ops for the given sysfs_dirent.  This function
 - * must be called while holding an active reference.
 +/**
 + *	fill_read_buffer - allocate and fill buffer from object.
 + *	@dentry:	dentry pointer.
 + *	@buffer:	data buffer for file.
 + *
 + *	Allocate @buffer->page, if it hasn't been already, then call the
 + *	kobject's show() method to fill the buffer with this attribute's
 + *	data.
 + *	This is called only once, on the file's first read unless an error
 + *	is returned.
   */
 -static const struct sysfs_ops *sysfs_file_ops(struct sysfs_dirent *sd)
 +static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)
  {
++<<<<<<< HEAD
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
 +	int ret = 0;
++=======
+ 	struct kobject *kobj = sd->s_parent->priv;
+ 
+ 	if (!sysfs_ignore_lockdep(sd))
+ 		lockdep_assert_held(sd);
+ 	return kobj->ktype ? kobj->ktype->sysfs_ops : NULL;
+ }
+ 
+ /*
+  * Reads on sysfs are handled through seq_file, which takes care of hairy
+  * details like buffering and seeking.  The following function pipes
+  * sysfs_ops->show() result through seq_file.
+  */
+ static int sysfs_seq_show(struct seq_file *sf, void *v)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 	const struct sysfs_ops *ops;
+ 	char *buf;
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  	ssize_t count;
  
 -	/* acquire buffer and ensure that it's >= PAGE_SIZE */
 -	count = seq_get_buf(sf, &buf);
 -	if (count < PAGE_SIZE) {
 -		seq_commit(sf, -1);
 -		return 0;
 -	}
 +	if (!buffer->page)
 +		buffer->page = (char *) get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
 +		return -ENOMEM;
  
 -	/*
 -	 * Need @of->sd for attr and ops, its parent for kobj.  @of->mutex
 -	 * nests outside active ref and is just to ensure that the ops
 -	 * aren't called concurrently for the same open file.
 -	 */
 -	mutex_lock(&of->mutex);
 -	if (!sysfs_get_active(of->sd)) {
 -		mutex_unlock(&of->mutex);
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
 -	}
  
 -	of->event = atomic_read(&of->sd->s_attr.open->event);
 +	buffer->event = atomic_read(&attr_sd->s_attr.open->event);
 +	count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
  
++<<<<<<< HEAD
 +	sysfs_put_active(attr_sd);
++=======
+ 	/*
+ 	 * Lookup @ops and invoke show().  Control may reach here via seq
+ 	 * file lseek even if @ops->show() isn't implemented.
+ 	 */
+ 	ops = sysfs_file_ops(of->sd);
+ 	if (ops->show)
+ 		count = ops->show(kobj, of->sd->priv, buf);
+ 	else
+ 		count = 0;
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (count < 0)
+ 		return count;
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  
  	/*
  	 * The code works fine with PAGE_SIZE return but it's likely to
@@@ -98,146 -140,380 +137,419 @@@
  		/* Try to struggle along */
  		count = PAGE_SIZE - 1;
  	}
++<<<<<<< HEAD
 +	if (count >= 0) {
 +		buffer->needs_read_fill = 0;
 +		buffer->count = count;
 +	} else {
 +		ret = count;
++=======
+ 	seq_commit(sf, count);
+ 	return 0;
+ }
+ 
+ /*
+  * Read method for bin files.  As reading a bin file can have side-effects,
+  * the exact offset and bytes specified in read(2) call should be passed to
+  * the read callback making it difficult to use seq_file.  Implement
+  * simplistic custom buffering for bin files.
+  */
+ static ssize_t sysfs_bin_read(struct file *file, char __user *userbuf,
+ 			      size_t bytes, loff_t *off)
+ {
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	struct bin_attribute *battr = of->sd->priv;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 	loff_t size = file_inode(file)->i_size;
+ 	int count = min_t(size_t, bytes, PAGE_SIZE);
+ 	loff_t offs = *off;
+ 	char *buf;
+ 
+ 	if (!bytes)
+ 		return 0;
+ 
+ 	if (size) {
+ 		if (offs > size)
+ 			return 0;
+ 		if (offs + count > size)
+ 			count = size - offs;
+ 	}
+ 
+ 	buf = kmalloc(count, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	/* need of->sd for battr, its parent for kobj */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		count = -ENODEV;
+ 		mutex_unlock(&of->mutex);
+ 		goto out_free;
+ 	}
+ 
+ 	if (battr->read)
+ 		count = battr->read(file, kobj, battr, buf, offs, count);
+ 	else
+ 		count = -EIO;
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (count < 0)
+ 		goto out_free;
+ 
+ 	if (copy_to_user(userbuf, buf, count)) {
+ 		count = -EFAULT;
+ 		goto out_free;
+ 	}
+ 
+ 	pr_debug("offs = %lld, *off = %lld, count = %d\n", offs, *off, count);
+ 
+ 	*off = offs + count;
+ 
+  out_free:
+ 	kfree(buf);
+ 	return count;
+ }
+ 
+ /**
+  * flush_write_buffer - push buffer to kobject
+  * @of: open file
+  * @buf: data buffer for file
+  * @off: file offset to write to
+  * @count: number of bytes
+  *
+  * Get the correct pointers for the kobject and the attribute we're dealing
+  * with, then call the store() method for it with @buf.
+  */
+ static int flush_write_buffer(struct sysfs_open_file *of, char *buf, loff_t off,
+ 			      size_t count)
+ {
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 	int rc = 0;
+ 
+ 	/*
+ 	 * Need @of->sd for attr and ops, its parent for kobj.  @of->mutex
+ 	 * nests outside active ref and is just to ensure that the ops
+ 	 * aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		mutex_unlock(&of->mutex);
+ 		return -ENODEV;
+ 	}
+ 
+ 	if (sysfs_is_bin(of->sd)) {
+ 		struct bin_attribute *battr = of->sd->priv;
+ 
+ 		rc = -EIO;
+ 		if (battr->write)
+ 			rc = battr->write(of->file, kobj, battr, buf, off,
+ 					  count);
+ 	} else {
+ 		const struct sysfs_ops *ops = sysfs_file_ops(of->sd);
+ 
+ 		rc = ops->store(kobj, of->sd->priv, buf, count);
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  	}
 -
 -	sysfs_put_active(of->sd);
 -	mutex_unlock(&of->mutex);
 -
 -	return rc;
 +	return ret;
  }
  
  /**
 - * sysfs_write_file - write an attribute
 - * @file: file pointer
 - * @user_buf: data to write
 - * @count: number of bytes
 - * @ppos: starting offset
 + *	sysfs_read_file - read an attribute.
 + *	@file:	file pointer.
 + *	@buf:	buffer to fill.
 + *	@count:	number of bytes to read.
 + *	@ppos:	starting offset in file.
   *
 - * Copy data in from userland and pass it to the matching
 - * sysfs_ops->store() by invoking flush_write_buffer().
 + *	Userspace wants to read an attribute file. The attribute descriptor
 + *	is in the file's ->d_fsdata. The target object is in the directory's
 + *	->d_fsdata.
   *
 - * There is no easy way for us to know if userspace is only doing a partial
 - * write, so we don't support them. We expect the entire buffer to come on
 - * the first write.  Hint: if you're writing a value, first read the file,
 - * modify only the the value you're changing, then write entire buffer
 - * back.
 + *	We call fill_read_buffer() to allocate and fill the buffer from the
 + *	object's show() method exactly once (if the read is happening from
 + *	the beginning of the file). That should fill the entire buffer with
 + *	all the data the object has to offer for that attribute.
 + *	We then call flush_read_buffer() to copy the buffer to userspace
 + *	in the increments specified.
   */
 -static ssize_t sysfs_write_file(struct file *file, const char __user *user_buf,
 -				size_t count, loff_t *ppos)
 -{
 -	struct sysfs_open_file *of = sysfs_of(file);
 -	ssize_t len = min_t(size_t, count, PAGE_SIZE);
 -	loff_t size = file_inode(file)->i_size;
 -	char *buf;
  
 -	if (sysfs_is_bin(of->sd) && size) {
 -		if (size <= *ppos)
 -			return 0;
 -		len = min_t(ssize_t, len, size - *ppos);
 +static ssize_t
 +sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 +{
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t retval = 0;
 +
 +	mutex_lock(&buffer->mutex);
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
 +		if (retval)
 +			goto out;
  	}
 +	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
 +		 __func__, count, *ppos, buffer->page);
 +	retval = simple_read_from_buffer(buf, count, ppos, buffer->page,
 +					 buffer->count);
 +out:
 +	mutex_unlock(&buffer->mutex);
 +	return retval;
 +}
  
 -	if (!len)
 -		return 0;
 +/**
 + *	fill_write_buffer - copy buffer from userspace.
 + *	@buffer:	data buffer for file.
 + *	@buf:		data from user.
 + *	@count:		number of bytes in @userbuf.
 + *
 + *	Allocate @buffer->page if it hasn't been already, then
 + *	copy the user-supplied buffer into it.
 + */
 +static int fill_write_buffer(struct sysfs_buffer * buffer,
 +			     const char __user * buf, size_t count)
 +{
 +	int error;
  
 -	buf = kmalloc(len + 1, GFP_KERNEL);
 -	if (!buf)
 +	if (!buffer->page)
 +		buffer->page = (char *)get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
  		return -ENOMEM;
  
 -	if (copy_from_user(buf, user_buf, len)) {
 -		len = -EFAULT;
 -		goto out_free;
 -	}
 -	buf[len] = '\0';	/* guarantee string termination */
 -
 -	len = flush_write_buffer(of, buf, *ppos, len);
 -	if (len > 0)
 -		*ppos += len;
 -out_free:
 -	kfree(buf);
 -	return len;
 +	if (count >= PAGE_SIZE)
 +		count = PAGE_SIZE - 1;
 +	error = copy_from_user(buffer->page,buf,count);
 +	buffer->needs_read_fill = 1;
 +	/* if buf is assumed to contain a string, terminate it by \0,
 +	   so e.g. sscanf() can scan the string easily */
 +	buffer->page[count] = 0;
 +	return error ? -EFAULT : count;
  }
  
 -static void sysfs_bin_vma_open(struct vm_area_struct *vma)
 +
 +/**
 + *	flush_write_buffer - push buffer to kobject.
 + *	@dentry:	dentry to the attribute
 + *	@buffer:	data buffer for file.
 + *	@count:		number of bytes
 + *
 + *	Get the correct pointers for the kobject and the attribute we're
 + *	dealing with, then call the store() method for the attribute,
 + *	passing the buffer that we acquired in fill_write_buffer().
 + */
 +static int
 +flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)
  {
++<<<<<<< HEAD
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
++=======
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 
+ 	if (!of->vm_ops)
+ 		return;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return;
+ 
+ 	if (of->vm_ops->open)
+ 		of->vm_ops->open(vma);
+ 
+ 	sysfs_put_active(of->sd);
+ }
+ 
+ static int sysfs_bin_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	ret = VM_FAULT_SIGBUS;
+ 	if (of->vm_ops->fault)
+ 		ret = of->vm_ops->fault(vma, vmf);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ static int sysfs_bin_page_mkwrite(struct vm_area_struct *vma,
+ 				  struct vm_fault *vmf)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	ret = 0;
+ 	if (of->vm_ops->page_mkwrite)
+ 		ret = of->vm_ops->page_mkwrite(vma, vmf);
+ 	else
+ 		file_update_time(file);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ static int sysfs_bin_access(struct vm_area_struct *vma, unsigned long addr,
+ 			    void *buf, int len, int write)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return -EINVAL;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return -EINVAL;
+ 
+ 	ret = -EINVAL;
+ 	if (of->vm_ops->access)
+ 		ret = of->vm_ops->access(vma, addr, buf, len, write);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_NUMA
+ static int sysfs_bin_set_policy(struct vm_area_struct *vma,
+ 				struct mempolicy *new)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return 0;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return -EINVAL;
+ 
+ 	ret = 0;
+ 	if (of->vm_ops->set_policy)
+ 		ret = of->vm_ops->set_policy(vma, new);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ static struct mempolicy *sysfs_bin_get_policy(struct vm_area_struct *vma,
+ 					      unsigned long addr)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	struct mempolicy *pol;
+ 
+ 	if (!of->vm_ops)
+ 		return vma->vm_policy;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return vma->vm_policy;
+ 
+ 	pol = vma->vm_policy;
+ 	if (of->vm_ops->get_policy)
+ 		pol = of->vm_ops->get_policy(vma, addr);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return pol;
+ }
+ 
+ static int sysfs_bin_migrate(struct vm_area_struct *vma, const nodemask_t *from,
+ 			     const nodemask_t *to, unsigned long flags)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return 0;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return 0;
+ 
+ 	ret = 0;
+ 	if (of->vm_ops->migrate)
+ 		ret = of->vm_ops->migrate(vma, from, to, flags);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ #endif
+ 
+ static const struct vm_operations_struct sysfs_bin_vm_ops = {
+ 	.open		= sysfs_bin_vma_open,
+ 	.fault		= sysfs_bin_fault,
+ 	.page_mkwrite	= sysfs_bin_page_mkwrite,
+ 	.access		= sysfs_bin_access,
+ #ifdef CONFIG_NUMA
+ 	.set_policy	= sysfs_bin_set_policy,
+ 	.get_policy	= sysfs_bin_get_policy,
+ 	.migrate	= sysfs_bin_migrate,
+ #endif
+ };
+ 
+ static int sysfs_bin_mmap(struct file *file, struct vm_area_struct *vma)
+ {
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	struct bin_attribute *battr = of->sd->priv;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  	int rc;
  
 -	mutex_lock(&of->mutex);
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
 +		return -ENODEV;
  
 -	/* need of->sd for battr, its parent for kobj */
 -	rc = -ENODEV;
 -	if (!sysfs_get_active(of->sd))
 -		goto out_unlock;
 +	rc = ops->store(kobj, attr_sd->s_attr.attr, buffer->page, count);
  
 -	if (!battr->mmap)
 -		goto out_put;
 +	sysfs_put_active(attr_sd);
  
 -	rc = battr->mmap(file, kobj, battr, vma);
 -	if (rc)
 -		goto out_put;
 +	return rc;
 +}
  
 -	/*
 -	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()
 -	 * to satisfy versions of X which crash if the mmap fails: that
 -	 * substitutes a new vm_file, and we don't then want bin_vm_ops.
 -	 */
 -	if (vma->vm_file != file)
 -		goto out_put;
  
 -	rc = -EINVAL;
 -	if (of->mmapped && of->vm_ops != vma->vm_ops)
 -		goto out_put;
 +/**
 + *	sysfs_write_file - write an attribute.
 + *	@file:	file pointer
 + *	@buf:	data to write
 + *	@count:	number of bytes
 + *	@ppos:	starting offset
 + *
 + *	Similar to sysfs_read_file(), though working in the opposite direction.
 + *	We allocate and fill the data from the user in fill_write_buffer(),
 + *	then push it to the kobject in flush_write_buffer().
 + *	There is no easy way for us to know if userspace is only doing a partial
 + *	write, so we don't support them. We expect the entire buffer to come
 + *	on the first write.
 + *	Hint: if you're writing a value, first read the file, modify only the
 + *	the value you're changing, then write entire buffer back.
 + */
  
 -	/*
 -	 * It is not possible to successfully wrap close.
 -	 * So error if someone is trying to use close.
 -	 */
 -	rc = -EINVAL;
 -	if (vma->vm_ops && vma->vm_ops->close)
 -		goto out_put;
 -
 -	rc = 0;
 -	of->mmapped = 1;
 -	of->vm_ops = vma->vm_ops;
 -	vma->vm_ops = &sysfs_bin_vm_ops;
 -out_put:
 -	sysfs_put_active(of->sd);
 -out_unlock:
 -	mutex_unlock(&of->mutex);
 +static ssize_t
 +sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 +{
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t len;
  
 -	return rc;
 +	mutex_lock(&buffer->mutex);
 +	len = fill_write_buffer(buffer, buf, count);
 +	if (len > 0)
 +		len = flush_write_buffer(file->f_path.dentry, buffer, len);
 +	if (len > 0)
 +		*ppos += len;
 +	mutex_unlock(&buffer->mutex);
 +	return len;
  }
  
  /**
@@@ -330,60 -607,90 +642,87 @@@ static void sysfs_put_open_dirent(struc
  static int sysfs_open_file(struct inode *inode, struct file *file)
  {
  	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
++<<<<<<< HEAD
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	struct sysfs_buffer *buffer;
 +	const struct sysfs_ops *ops;
++=======
+ 	struct kobject *kobj = attr_sd->s_parent->priv;
+ 	struct sysfs_open_file *of;
+ 	bool has_read, has_write, has_mmap;
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  	int error = -EACCES;
  
  	/* need attr_sd for attr and ops, its parent for kobj */
  	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	/* every kobject with an attribute needs a ktype assigned */
 +	if (kobj->ktype && kobj->ktype->sysfs_ops)
 +		ops = kobj->ktype->sysfs_ops;
 +	else {
 +		WARN(1, KERN_ERR
 +		     "missing sysfs attribute operations for kobject: %s\n",
 +		     kobject_name(kobj));
 +		goto err_out;
++=======
+ 	if (sysfs_is_bin(attr_sd)) {
+ 		struct bin_attribute *battr = attr_sd->priv;
+ 
+ 		has_read = battr->read || battr->mmap;
+ 		has_write = battr->write || battr->mmap;
+ 		has_mmap = battr->mmap;
+ 	} else {
+ 		const struct sysfs_ops *ops = sysfs_file_ops(attr_sd);
+ 
+ 		/* every kobject with an attribute needs a ktype assigned */
+ 		if (WARN(!ops, KERN_ERR
+ 			 "missing sysfs attribute operations for kobject: %s\n",
+ 			 kobject_name(kobj)))
+ 			goto err_out;
+ 
+ 		has_read = ops->show;
+ 		has_write = ops->store;
+ 		has_mmap = false;
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  	}
  
 -	/* check perms and supported operations */
 -	if ((file->f_mode & FMODE_WRITE) &&
 -	    (!(inode->i_mode & S_IWUGO) || !has_write))
 -		goto err_out;
 -
 -	if ((file->f_mode & FMODE_READ) &&
 -	    (!(inode->i_mode & S_IRUGO) || !has_read))
 -		goto err_out;
 -
 -	/* allocate a sysfs_open_file for the file */
 -	error = -ENOMEM;
 -	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
 -	if (!of)
 -		goto err_out;
 -
 -	/*
 -	 * The following is done to give a different lockdep key to
 -	 * @of->mutex for files which implement mmap.  This is a rather
 -	 * crude way to avoid false positive lockdep warning around
 -	 * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and
 -	 * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under
 -	 * which mm->mmap_sem nests, while holding @of->mutex.  As each
 -	 * open file has a separate mutex, it's okay as long as those don't
 -	 * happen on the same file.  At this point, we can't easily give
 -	 * each file a separate locking class.  Let's differentiate on
 -	 * whether the file has mmap or not for now.
 +	/* File needs write support.
 +	 * The inode's perms must say it's ok,
 +	 * and we must have a store method.
  	 */
 -	if (has_mmap)
 -		mutex_init(&of->mutex);
 -	else
 -		mutex_init(&of->mutex);
 +	if (file->f_mode & FMODE_WRITE) {
 +		if (!(inode->i_mode & S_IWUGO) || !ops->store)
 +			goto err_out;
 +	}
  
 -	of->sd = attr_sd;
 -	of->file = file;
 +	/* File needs read support.
 +	 * The inode's perms must say it's ok, and we there
 +	 * must be a show method for it.
 +	 */
 +	if (file->f_mode & FMODE_READ) {
 +		if (!(inode->i_mode & S_IRUGO) || !ops->show)
 +			goto err_out;
 +	}
  
 -	/*
 -	 * Always instantiate seq_file even if read access doesn't use
 -	 * seq_file or is not requested.  This unifies private data access
 -	 * and readable regular files are the vast majority anyway.
 +	/* No error? Great, allocate a buffer for the file, and store it
 +	 * it in file->private_data for easy access.
  	 */
 -	if (sysfs_is_bin(attr_sd))
 -		error = single_open(file, NULL, of);
 -	else
 -		error = single_open(file, sysfs_seq_show, of);
 -	if (error)
 -		goto err_free;
 +	error = -ENOMEM;
 +	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
 +	if (!buffer)
 +		goto err_out;
  
 -	/* seq_file clears PWRITE unconditionally, restore it if WRITE */
 -	if (file->f_mode & FMODE_WRITE)
 -		file->f_mode |= FMODE_PWRITE;
 +	mutex_init(&buffer->mutex);
 +	buffer->needs_read_fill = 1;
 +	buffer->ops = ops;
 +	file->private_data = buffer;
  
  	/* make sure we have open dirent struct */
 -	error = sysfs_get_open_dirent(attr_sd, of);
 +	error = sysfs_get_open_dirent(attr_sd, buffer);
  	if (error)
 -		goto err_close;
 +		goto err_free;
  
  	/* open succeeded, put active references */
  	sysfs_put_active(attr_sd);
@@@ -549,11 -848,11 +888,11 @@@ int sysfs_add_file_mode(struct sysfs_di
  		return -ENOMEM;
  
  	sd->s_ns = ns;
- 	sd->s_attr.attr = (void *)attr;
+ 	sd->priv = (void *)attr;
  	sysfs_dirent_init_lockdep(sd);
  
 -	sysfs_addrm_start(&acxt);
 -	rc = sysfs_add_one(&acxt, sd, dir_sd);
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	rc = sysfs_add_one(&acxt, sd);
  	sysfs_addrm_finish(&acxt);
  
  	if (rc)
diff --cc fs/sysfs/inode.c
index 15a606d56f5d,81cc8585b32c..000000000000
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@@ -256,9 -275,9 +256,13 @@@ static void sysfs_init_inode(struct sys
  		inode->i_fop = &sysfs_file_operations;
  		break;
  	case SYSFS_KOBJ_BIN_ATTR:
++<<<<<<< HEAD
 +		bin_attr = sd->s_bin_attr.bin_attr;
++=======
+ 		bin_attr = sd->priv;
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  		inode->i_size = bin_attr->size;
 -		inode->i_fop = &sysfs_bin_operations;
 +		inode->i_fop = &bin_fops;
  		break;
  	case SYSFS_KOBJ_LINK:
  		inode->i_op = &sysfs_symlink_inode_operations;
diff --cc fs/sysfs/sysfs.h
index e18c3f38727c,a6f3fa3f02fe..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -29,7 -27,6 +27,10 @@@ struct sysfs_elem_symlink 
  };
  
  struct sysfs_elem_attr {
++<<<<<<< HEAD
 +	struct attribute	*attr;
++=======
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  	struct sysfs_open_dirent *open;
  };
  
@@@ -74,9 -66,10 +75,11 @@@ struct sysfs_dirent 
  		struct sysfs_elem_dir		s_dir;
  		struct sysfs_elem_symlink	s_symlink;
  		struct sysfs_elem_attr		s_attr;
 +		struct sysfs_elem_bin_attr	s_bin_attr;
  	};
  
+ 	void			*priv;
+ 
  	unsigned short		s_flags;
  	umode_t			s_mode;
  	unsigned int		s_ino;
@@@ -105,27 -95,37 +108,41 @@@ static inline unsigned int sysfs_type(s
  	return sd->s_flags & SYSFS_TYPE_MASK;
  }
  
 -#ifdef CONFIG_DEBUG_LOCK_ALLOC
 +/*
 + * Return any namespace tags on this dirent.
 + * enum kobj_ns_type is defined in linux/kobject.h
 + */
 +static inline enum kobj_ns_type sysfs_ns_type(struct sysfs_dirent *sd)
 +{
 +	return (sd->s_flags & SYSFS_NS_TYPE_MASK) >> SYSFS_NS_TYPE_SHIFT;
 +}
  
 +#ifdef CONFIG_DEBUG_LOCK_ALLOC
  #define sysfs_dirent_init_lockdep(sd)				\
  do {								\
- 	struct attribute *attr = sd->s_attr.attr;		\
+ 	struct attribute *attr = sd->priv;			\
  	struct lock_class_key *key = attr->key;			\
  	if (!key)						\
  		key = &attr->skey;				\
  								\
  	lockdep_init_map(&sd->dep_map, "s_active", key, 0);	\
  } while (0)
++<<<<<<< HEAD
++=======
+ 
+ /* Test for attributes that want to ignore lockdep for read-locking */
+ static inline bool sysfs_ignore_lockdep(struct sysfs_dirent *sd)
+ {
+ 	struct attribute *attr = sd->priv;
+ 	int type = sysfs_type(sd);
+ 
+ 	return (type == SYSFS_KOBJ_ATTR || type == SYSFS_KOBJ_BIN_ATTR) &&
+ 		attr->ignore_lockdep;
+ }
+ 
++>>>>>>> 7c6e2d362c19 (sysfs, kernfs: replace sysfs_dirent->s_dir.kobj and ->s_attr.[bin_]attr with ->priv)
  #else
 -
  #define sysfs_dirent_init_lockdep(sd) do {} while (0)
 -
 -static inline bool sysfs_ignore_lockdep(struct sysfs_dirent *sd)
 -{
 -	return true;
 -}
 -
  #endif
  
  /*
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index fd502d3fc9fc..c8060fd63b08 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -679,7 +679,7 @@ static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
 
 	sd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);
 	sd->s_ns = ns;
-	sd->s_dir.kobj = kobj;
+	sd->priv = kobj;
 
 	/* link in */
 	sysfs_addrm_start(&acxt, parent_sd);
* Unmerged path fs/sysfs/file.c
* Unmerged path fs/sysfs/inode.c
diff --git a/fs/sysfs/symlink.c b/fs/sysfs/symlink.c
index 9fab2e7f7357..05c64129d9da 100644
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@ -212,7 +212,7 @@ int sysfs_rename_link(struct kobject *kobj, struct kobject *targ,
 	result = -EINVAL;
 	if (sysfs_type(sd) != SYSFS_KOBJ_LINK)
 		goto out;
-	if (sd->s_symlink.target_sd->s_dir.kobj != targ)
+	if (sd->s_symlink.target_sd->priv != targ)
 		goto out;
 
 	if (sysfs_ns_type(parent_sd))
* Unmerged path fs/sysfs/sysfs.h
