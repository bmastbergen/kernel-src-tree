ovl: defer upper dir lock to tempfile link

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 15932c415b3ed20bd1c1e05d071b4ad498656280
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/15932c41.failed

On copy up of regular file using an O_TMPFILE, lock upper dir only
before linking the tempfile in place.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 15932c415b3ed20bd1c1e05d071b4ad498656280)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,28711af7f9db..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -264,15 -233,127 +264,134 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper)
+ {
+ 	struct ovl_fh *fh;
+ 	int fh_type, fh_len, dwords;
+ 	void *buf;
+ 	int buflen = MAX_HANDLE_SZ;
+ 	uuid_t *uuid = &lower->d_sb->s_uuid;
+ 
+ 	buf = kmalloc(buflen, GFP_TEMPORARY);
+ 	if (!buf)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	/*
+ 	 * We encode a non-connectable file handle for non-dir, because we
+ 	 * only need to find the lower inode number and we don't want to pay
+ 	 * the price or reconnecting the dentry.
+ 	 */
+ 	dwords = buflen >> 2;
+ 	fh_type = exportfs_encode_fh(lower, buf, &dwords, 0);
+ 	buflen = (dwords << 2);
+ 
+ 	fh = ERR_PTR(-EIO);
+ 	if (WARN_ON(fh_type < 0) ||
+ 	    WARN_ON(buflen > MAX_HANDLE_SZ) ||
+ 	    WARN_ON(fh_type == FILEID_INVALID))
+ 		goto out;
+ 
+ 	BUILD_BUG_ON(MAX_HANDLE_SZ + offsetof(struct ovl_fh, fid) > 255);
+ 	fh_len = offsetof(struct ovl_fh, fid) + buflen;
+ 	fh = kmalloc(fh_len, GFP_KERNEL);
+ 	if (!fh) {
+ 		fh = ERR_PTR(-ENOMEM);
+ 		goto out;
+ 	}
+ 
+ 	fh->version = OVL_FH_VERSION;
+ 	fh->magic = OVL_FH_MAGIC;
+ 	fh->type = fh_type;
+ 	fh->flags = OVL_FH_FLAG_CPU_ENDIAN;
+ 	/*
+ 	 * When we will want to decode an overlay dentry from this handle
+ 	 * and all layers are on the same fs, if we get a disconncted real
+ 	 * dentry when we decode fid, the only way to tell if we should assign
+ 	 * it to upperdentry or to lowerstack is by checking this flag.
+ 	 */
+ 	if (is_upper)
+ 		fh->flags |= OVL_FH_FLAG_PATH_UPPER;
+ 	fh->len = fh_len;
+ 	fh->uuid = *uuid;
+ 	memcpy(fh->fid, buf, buflen);
+ 
+ out:
+ 	kfree(buf);
+ 	return fh;
+ }
+ 
+ static int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+ 			  struct dentry *upper)
+ {
+ 	const struct ovl_fh *fh = NULL;
+ 	int err;
+ 
+ 	/*
+ 	 * When lower layer doesn't support export operations store a 'null' fh,
+ 	 * so we can use the overlay.origin xattr to distignuish between a copy
+ 	 * up and a pure upper inode.
+ 	 */
+ 	if (ovl_can_decode_fh(lower->d_sb)) {
+ 		fh = ovl_encode_fh(lower, false);
+ 		if (IS_ERR(fh))
+ 			return PTR_ERR(fh);
+ 	}
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_ORIGIN, fh,
+ 				 fh ? fh->len : 0, 0);
+ 	kfree(fh);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_install_temp(struct dentry *workdir, struct dentry *upperdir,
+ 			    struct dentry *dentry,
+ 			    struct dentry *temp, struct kstat *pstat,
+ 			    bool tmpfile, struct dentry **newdentry)
+ {
+ 	int err;
+ 	struct dentry *upper;
+ 	struct inode *udir = d_inode(upperdir);
+ 
+ 	upper = lookup_one_len(dentry->d_name.name, upperdir,
+ 			       dentry->d_name.len);
+ 	if (IS_ERR(upper))
+ 		return PTR_ERR(upper);
+ 
+ 	if (tmpfile)
+ 		err = ovl_do_link(temp, udir, upper, true);
+ 	else
+ 		err = ovl_do_rename(d_inode(workdir), temp, udir, upper, 0);
+ 
+ 	/* Restore timestamps on parent (best effort) */
+ 	if (!err) {
+ 		ovl_set_timestamps(upperdir, pstat);
+ 		*newdentry = dget(tmpfile ? upper : temp);
+ 	}
+ 	dput(upper);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 15932c415b3e (ovl: defer upper dir lock to tempfile link)
  static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
  			      struct dentry *dentry, struct path *lowerpath,
 -			      struct kstat *stat, const char *link,
 -			      struct kstat *pstat, bool tmpfile)
 +			      struct kstat *stat, const char *link)
  {
  	struct inode *wdir = workdir->d_inode;
  	struct inode *udir = upperdir->d_inode;
  	struct dentry *newdentry = NULL;
++<<<<<<< HEAD
 +	struct dentry *upper = NULL;
 +	umode_t mode = stat->mode;
++=======
+ 	struct dentry *temp = NULL;
++>>>>>>> 15932c415b3e (ovl: defer upper dir lock to tempfile link)
  	int err;
  	const struct cred *old_creds = NULL;
  	struct cred *new_creds = NULL;
@@@ -313,7 -397,7 +432,11 @@@
  
  		ovl_path_upper(dentry, &upperpath);
  		BUG_ON(upperpath.dentry != NULL);
++<<<<<<< HEAD
 +		upperpath.dentry = newdentry;
++=======
+ 		upperpath.dentry = temp;
++>>>>>>> 15932c415b3e (ovl: defer upper dir lock to tempfile link)
  
  		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
  		if (err)
@@@ -330,24 -414,34 +453,48 @@@
  	if (err)
  		goto out_cleanup;
  
 +	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
 +	if (err)
 +		goto out_cleanup;
 +
 +	ovl_dentry_update(dentry, newdentry);
 +	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
 +
  	/*
 -	 * Store identifier of lower inode in upper inode xattr to
 -	 * allow lookup of the copy up origin inode.
 -	 *
 -	 * Don't set origin when we are breaking the association with a lower
 -	 * hard link.
 +	 * Non-directores become opaque when copied up.
  	 */
++<<<<<<< HEAD
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
 +	dput(upper);
 +out1:
 +	dput(newdentry);
 +out:
++=======
+ 	if (S_ISDIR(stat->mode) || stat->nlink == 1) {
+ 		err = ovl_set_origin(dentry, lowerpath->dentry, temp);
+ 		if (err)
+ 			goto out_cleanup;
+ 	}
+ 
+ 	if (tmpfile) {
+ 		inode_lock_nested(udir, I_MUTEX_PARENT);
+ 		err = ovl_install_temp(workdir, upperdir, dentry, temp, pstat,
+ 				       tmpfile, &newdentry);
+ 		inode_unlock(udir);
+ 	} else {
+ 		err = ovl_install_temp(workdir, upperdir, dentry, temp, pstat,
+ 				       tmpfile, &newdentry);
+ 	}
+ 	if (err)
+ 		goto out_cleanup;
+ 
+ 	ovl_inode_update(d_inode(dentry), newdentry);
+ out:
+ 	dput(temp);
++>>>>>>> 15932c415b3e (ovl: defer upper dir lock to tempfile link)
  	return err;
  
  out_cleanup:
@@@ -399,6 -496,23 +546,26 @@@ static int ovl_copy_up_one(struct dentr
  			return PTR_ERR(link);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Should we copyup with O_TMPFILE or with workdir? */
+ 	if (S_ISREG(stat->mode) && ofs->tmpfile) {
+ 		err = ovl_copy_up_start(dentry);
+ 		/* err < 0: interrupted, err > 0: raced with another copy-up */
+ 		if (unlikely(err)) {
+ 			pr_debug("ovl_copy_up_start(%pd2) = %i\n", dentry, err);
+ 			if (err > 0)
+ 				err = 0;
+ 			goto out_done;
+ 		}
+ 
+ 		err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
+ 					 stat, link, &pstat, true);
+ 		ovl_copy_up_end(dentry);
+ 		goto out_done;
+ 	}
+ 
++>>>>>>> 15932c415b3e (ovl: defer upper dir lock to tempfile link)
  	err = -EIO;
  	if (lock_rename(workdir, upperdir) != NULL) {
  		pr_err("overlayfs: failed to lock workdir+upperdir\n");
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/util.c
