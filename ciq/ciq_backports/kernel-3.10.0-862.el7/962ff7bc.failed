mei: replace callback structures used as list head by list_head

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 962ff7bcec243dc5ff6dd3cbad6ed585e3177556
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/962ff7bc.failed

mei_dev structure used struct mei_cl_cb type variables as for holding
callbacks list heads.  Replace them by the actual struct list_head
as there is no other info that is handled. This slims down
the mei_dev structure and mostly streamline the code.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 962ff7bcec243dc5ff6dd3cbad6ed585e3177556)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/amthif.c
#	drivers/misc/mei/client.c
#	drivers/misc/mei/client.h
#	drivers/misc/mei/hw-me.c
#	drivers/misc/mei/interrupt.c
diff --cc drivers/misc/mei/amthif.c
index 2655770e72a1,366ef1fe9b90..000000000000
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@@ -355,9 -352,9 +354,14 @@@ int mei_amthif_release(struct mei_devic
  		dev->iamthif_canceled = true;
  	}
  
++<<<<<<< HEAD
 +	mei_clear_list(file, &dev->amthif_cmd_list.list);
++=======
+ 	/* Don't clean ctrl_rd_list here, the reads has to be completed */
+ 	mei_clear_list(file, &dev->amthif_cmd_list);
++>>>>>>> 962ff7bcec24 (mei: replace callback structures used as list head by list_head)
  	mei_clear_list(file, &cl->rd_completed);
 +	mei_clear_list(file, &dev->ctrl_rd_list.list);
  
  	return 0;
  }
diff --cc drivers/misc/mei/client.c
index beb942e6c248,838a4a349f9e..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -401,12 -401,12 +401,16 @@@ static void __mei_io_list_flush(struct 
  /**
   * mei_io_list_flush - removes list entry belonging to cl.
   *
-  * @list:  An instance of our list structure
+  * @head: An instance of our list structure
   * @cl: host client
   */
++<<<<<<< HEAD
 +void mei_io_list_flush(struct mei_cl_cb *list, struct mei_cl *cl)
++=======
+ static inline void mei_io_list_flush(struct list_head *head, struct mei_cl *cl)
++>>>>>>> 962ff7bcec24 (mei: replace callback structures used as list head by list_head)
  {
- 	__mei_io_list_flush(list, cl, false);
+ 	__mei_io_list_flush(head, cl, false);
  }
  
  /**
@@@ -1587,9 -1605,14 +1591,17 @@@ int mei_cl_irq_write(struct mei_cl *cl
  	}
  
  	if (mei_hdr.msg_complete)
- 		list_move_tail(&cb->list, &dev->write_waiting_list.list);
+ 		list_move_tail(&cb->list, &dev->write_waiting_list);
  
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err:
+ 	cl->status = rets;
+ 	list_move_tail(&cb->list, cmpl_list);
+ 	return rets;
++>>>>>>> 962ff7bcec24 (mei: replace callback structures used as list head by list_head)
  }
  
  /**
diff --cc drivers/misc/mei/client.h
index f2545af9be7b,f48cfa026268..000000000000
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@@ -84,17 -84,6 +84,20 @@@ static inline u8 mei_me_cl_ver(const st
   */
  void mei_io_cb_free(struct mei_cl_cb *priv_cb);
  
++<<<<<<< HEAD
 +/**
 + * mei_io_list_init - Sets up a queue list.
 + *
 + * @list: An instance cl callback structure
 + */
 +static inline void mei_io_list_init(struct mei_cl_cb *list)
 +{
 +	INIT_LIST_HEAD(&list->list);
 +}
 +void mei_io_list_flush(struct mei_cl_cb *list, struct mei_cl *cl);
 +
++=======
++>>>>>>> 962ff7bcec24 (mei: replace callback structures used as list head by list_head)
  /*
   * MEI Host Client Functions
   */
@@@ -209,9 -198,8 +212,9 @@@ static inline u8 mei_cl_host_addr(cons
  }
  
  int mei_cl_disconnect(struct mei_cl *cl);
 +void mei_cl_set_disconnected(struct mei_cl *cl);
  int mei_cl_irq_disconnect(struct mei_cl *cl, struct mei_cl_cb *cb,
- 			  struct mei_cl_cb *cmpl_list);
+ 			  struct list_head *cmpl_list);
  int mei_cl_connect(struct mei_cl *cl, struct mei_me_client *me_cl,
  		   const struct file *file);
  int mei_cl_irq_connect(struct mei_cl *cl, struct mei_cl_cb *cb,
diff --cc drivers/misc/mei/hw-me.c
index c78756141ffa,06a579952e3f..000000000000
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@@ -1152,14 -1189,19 +1152,22 @@@ irqreturn_t mei_me_irq_quick_handler(in
  irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
  {
  	struct mei_device *dev = (struct mei_device *) dev_id;
- 	struct mei_cl_cb complete_list;
+ 	struct list_head cmpl_list;
  	s32 slots;
 -	u32 hcsr;
  	int rets = 0;
  
  	dev_dbg(dev->dev, "function called after ISR to handle the interrupt processing.\n");
  	/* initialize our complete list */
  	mutex_lock(&dev->device_lock);
++<<<<<<< HEAD
 +	mei_io_list_init(&complete_list);
++=======
+ 
+ 	hcsr = mei_hcsr_read(dev);
+ 	me_intr_clear(dev, hcsr);
+ 
+ 	INIT_LIST_HEAD(&cmpl_list);
++>>>>>>> 962ff7bcec24 (mei: replace callback structures used as list head by list_head)
  
  	/* check if ME wants a reset */
  	if (!mei_hw_is_ready(dev) && dev->dev_state != MEI_DEV_RESETTING) {
diff --cc drivers/misc/mei/interrupt.c
index b4e3ec92784a,406e9e2b2fff..000000000000
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@@ -158,6 -153,8 +158,11 @@@ int mei_cl_irq_read_msg(struct mei_cl *
  	return 0;
  
  discard:
++<<<<<<< HEAD
++=======
+ 	if (cb)
+ 		list_move_tail(&cb->list, cmpl_list);
++>>>>>>> 962ff7bcec24 (mei: replace callback structures used as list head by list_head)
  	mei_irq_discard_msg(dev, mei_hdr);
  	return 0;
  }
* Unmerged path drivers/misc/mei/amthif.c
* Unmerged path drivers/misc/mei/client.c
* Unmerged path drivers/misc/mei/client.h
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index 7d133e19e0d7..fe6595fe94f1 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -814,7 +814,7 @@ static void mei_hbm_cl_res(struct mei_device *dev,
 	struct mei_cl_cb *cb, *next;
 
 	cl = NULL;
-	list_for_each_entry_safe(cb, next, &dev->ctrl_rd_list.list, list) {
+	list_for_each_entry_safe(cb, next, &dev->ctrl_rd_list, list) {
 
 		cl = cb->cl;
 
* Unmerged path drivers/misc/mei/hw-me.c
diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c
index 60415a2bfcbd..061e4b00f60d 100644
--- a/drivers/misc/mei/hw-txe.c
+++ b/drivers/misc/mei/hw-txe.c
@@ -1044,7 +1044,7 @@ irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)
 {
 	struct mei_device *dev = (struct mei_device *) dev_id;
 	struct mei_txe_hw *hw = to_txe_hw(dev);
-	struct mei_cl_cb complete_list;
+	struct list_head cmpl_list;
 	s32 slots;
 	int rets = 0;
 
@@ -1056,7 +1056,7 @@ irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)
 
 	/* initialize our complete list */
 	mutex_lock(&dev->device_lock);
-	mei_io_list_init(&complete_list);
+	INIT_LIST_HEAD(&cmpl_list);
 
 	if (pci_dev_msi_enabled(to_pci_dev(dev->dev)))
 		mei_txe_check_and_ack_intrs(dev, true);
@@ -1113,7 +1113,7 @@ irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)
 	slots = mei_count_full_read_slots(dev);
 	if (test_and_clear_bit(TXE_INTR_OUT_DB_BIT, &hw->intr_cause)) {
 		/* Read from TXE */
-		rets = mei_irq_read_handler(dev, &complete_list, &slots);
+		rets = mei_irq_read_handler(dev, &cmpl_list, &slots);
 		if (rets && dev->dev_state != MEI_DEV_RESETTING) {
 			dev_err(dev->dev,
 				"mei_irq_read_handler ret = %d.\n", rets);
@@ -1131,14 +1131,14 @@ irqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)
 	if (hw->aliveness && dev->hbuf_is_ready) {
 		/* get the real register value */
 		dev->hbuf_is_ready = mei_hbuf_is_ready(dev);
-		rets = mei_irq_write_handler(dev, &complete_list);
+		rets = mei_irq_write_handler(dev, &cmpl_list);
 		if (rets && rets != -EMSGSIZE)
 			dev_err(dev->dev, "mei_irq_write_handler ret = %d.\n",
 				rets);
 		dev->hbuf_is_ready = mei_hbuf_is_ready(dev);
 	}
 
-	mei_irq_compl_handler(dev, &complete_list);
+	mei_irq_compl_handler(dev, &cmpl_list);
 
 end:
 	dev_dbg(dev->dev, "interrupt thread end ret = %d\n", rets);
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index a9a5b4e2105e..b6369322de7a 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -339,16 +339,16 @@ EXPORT_SYMBOL_GPL(mei_stop);
 bool mei_write_is_idle(struct mei_device *dev)
 {
 	bool idle = (dev->dev_state == MEI_DEV_ENABLED &&
-		list_empty(&dev->ctrl_wr_list.list) &&
-		list_empty(&dev->write_list.list)   &&
-		list_empty(&dev->write_waiting_list.list));
+		list_empty(&dev->ctrl_wr_list) &&
+		list_empty(&dev->write_list)   &&
+		list_empty(&dev->write_waiting_list));
 
 	dev_dbg(dev->dev, "write pg: is idle[%d] state=%s ctrl=%01d write=%01d wwait=%01d\n",
 		idle,
 		mei_dev_state_str(dev->dev_state),
-		list_empty(&dev->ctrl_wr_list.list),
-		list_empty(&dev->write_list.list),
-		list_empty(&dev->write_waiting_list.list));
+		list_empty(&dev->ctrl_wr_list),
+		list_empty(&dev->write_list),
+		list_empty(&dev->write_waiting_list));
 
 	return idle;
 }
@@ -378,17 +378,17 @@ void mei_device_init(struct mei_device *dev,
 	dev->dev_state = MEI_DEV_INITIALIZING;
 	dev->reset_count = 0;
 
-	mei_io_list_init(&dev->write_list);
-	mei_io_list_init(&dev->write_waiting_list);
-	mei_io_list_init(&dev->ctrl_wr_list);
-	mei_io_list_init(&dev->ctrl_rd_list);
+	INIT_LIST_HEAD(&dev->write_list);
+	INIT_LIST_HEAD(&dev->write_waiting_list);
+	INIT_LIST_HEAD(&dev->ctrl_wr_list);
+	INIT_LIST_HEAD(&dev->ctrl_rd_list);
 
 	INIT_DELAYED_WORK(&dev->timer_work, mei_timer);
 	INIT_WORK(&dev->reset_work, mei_reset_work);
 	INIT_WORK(&dev->bus_rescan_work, mei_cl_bus_rescan_work);
 
 	INIT_LIST_HEAD(&dev->iamthif_cl.link);
-	mei_io_list_init(&dev->amthif_cmd_list);
+	INIT_LIST_HEAD(&dev->amthif_cmd_list);
 
 	bitmap_zero(dev->host_clients_map, MEI_CLIENTS_MAX);
 	dev->open_handle_count = 0;
* Unmerged path drivers/misc/mei/interrupt.c
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 6fb341d0b992..7e90fbf8ac93 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -432,10 +432,10 @@ struct mei_device {
 	struct cdev cdev;
 	int minor;
 
-	struct mei_cl_cb write_list;
-	struct mei_cl_cb write_waiting_list;
-	struct mei_cl_cb ctrl_wr_list;
-	struct mei_cl_cb ctrl_rd_list;
+	struct list_head write_list;
+	struct list_head write_waiting_list;
+	struct list_head ctrl_wr_list;
+	struct list_head ctrl_rd_list;
 
 	struct list_head file_list;
 	long open_handle_count;
@@ -492,7 +492,7 @@ struct mei_device {
 	bool override_fixed_address;
 
 	/* amthif list for cmd waiting */
-	struct mei_cl_cb amthif_cmd_list;
+	struct list_head amthif_cmd_list;
 	struct mei_cl iamthif_cl;
 	long iamthif_open_count;
 	u32 iamthif_stall_timer;
@@ -564,10 +564,10 @@ void mei_cancel_work(struct mei_device *dev);
 void mei_timer(struct work_struct *work);
 void mei_schedule_stall_timer(struct mei_device *dev);
 int mei_irq_read_handler(struct mei_device *dev,
-		struct mei_cl_cb *cmpl_list, s32 *slots);
+			 struct list_head *cmpl_list, s32 *slots);
 
-int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list);
-void mei_irq_compl_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list);
+int mei_irq_write_handler(struct mei_device *dev, struct list_head *cmpl_list);
+void mei_irq_compl_handler(struct mei_device *dev, struct list_head *cmpl_list);
 
 /*
  * AMTHIF - AMT Host Interface Functions
@@ -583,12 +583,12 @@ int mei_amthif_release(struct mei_device *dev, struct file *file);
 int mei_amthif_write(struct mei_cl *cl, struct mei_cl_cb *cb);
 int mei_amthif_run_next_cmd(struct mei_device *dev);
 int mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
-			struct mei_cl_cb *cmpl_list);
+			 struct list_head *cmpl_list);
 
 void mei_amthif_complete(struct mei_cl *cl, struct mei_cl_cb *cb);
 int mei_amthif_irq_read_msg(struct mei_cl *cl,
 			    struct mei_msg_hdr *mei_hdr,
-			    struct mei_cl_cb *complete_list);
+			    struct list_head *cmpl_list);
 int mei_amthif_irq_read(struct mei_device *dev, s32 *slots);
 
 /*
