mqprio: Change handling of hw u8 to allow for multiple hardware offload modes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 2026fecf516bc04df20cb50874957cd8c364fb4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2026fecf.failed

This patch is meant to allow for support of multiple hardware offload type
for a single device. There is currently no bounds checking for the hw
member of the mqprio_qopt structure.  This results in us being able to pass
values from 1 to 255 with all being treated the same.  On retreiving the
value it is returned as 1 for anything 1 or greater being set.

With this change we are currently adding limited bounds checking by
defining an enum and using those values to limit the reported hardware
offloads.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2026fecf516bc04df20cb50874957cd8c364fb4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_mqprio.c
diff --cc net/sched/sch_mqprio.c
index 748ea1bbc507,5f55bf149d9f..000000000000
--- a/net/sched/sch_mqprio.c
+++ b/net/sched/sch_mqprio.c
@@@ -39,13 -39,8 +39,18 @@@ static void mqprio_destroy(struct Qdis
  		kfree(priv->qdiscs);
  	}
  
++<<<<<<< HEAD
 +	if (priv->hw_owned && (dev->netdev_ops->ndo_setup_tc ||
 +			       dev->netdev_ops->ndo_setup_tc_rh72))
 +		if (dev->netdev_ops->ndo_setup_tc) {
 +			dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
 +		} else {
 +			dev->netdev_ops->ndo_setup_tc_rh72(dev, 0);
 +		}
++=======
+ 	if (priv->hw_offload && dev->netdev_ops->ndo_setup_tc)
+ 		dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
++>>>>>>> 2026fecf516b (mqprio: Change handling of hw u8 to allow for multiple hardware offload modes)
  	else
  		netdev_set_num_tc(dev, 0);
  }
@@@ -64,16 -59,20 +69,27 @@@ static int mqprio_parse_opt(struct net_
  			return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	/* net_device does not support requested operation */
 +	if (qopt->hw && !dev->netdev_ops->ndo_setup_tc &&
 +	    !dev->netdev_ops->ndo_setup_tc_rh72)
 +		return -EINVAL;
- 
- 	/* if hw owned qcount and qoffset are taken from LLD so
- 	 * no reason to verify them here
++=======
+ 	/* Limit qopt->hw to maximum supported offload value.  Drivers have
+ 	 * the option of overriding this later if they don't support the a
+ 	 * given offload type.
+ 	 */
+ 	if (qopt->hw > TC_MQPRIO_HW_OFFLOAD_MAX)
+ 		qopt->hw = TC_MQPRIO_HW_OFFLOAD_MAX;
++>>>>>>> 2026fecf516b (mqprio: Change handling of hw u8 to allow for multiple hardware offload modes)
+ 
+ 	/* If hardware offload is requested we will leave it to the device
+ 	 * to either populate the queue counts itself or to validate the
+ 	 * provided queue counts.  If ndo_setup_tc is not present then
+ 	 * hardware doesn't support offload and we should return an error.
  	 */
  	if (qopt->hw)
- 		return 0;
+ 		return dev->netdev_ops->ndo_setup_tc ? 0 : -EINVAL;
  
  	for (i = 0; i < qopt->num_tc; i++) {
  		unsigned int last = qopt->offset[i] + qopt->count[i];
@@@ -148,13 -147,11 +164,19 @@@ static int mqprio_init(struct Qdisc *sc
  		struct tc_to_netdev tc = {.type = TC_SETUP_MQPRIO,
  					  { .tc = qopt->num_tc }};
  
++<<<<<<< HEAD
 +		priv->hw_owned = 1;
 +		err = dev->netdev_ops->ndo_setup_tc ?
 +			dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0,
 +						      &tc) :
 +			dev->netdev_ops->ndo_setup_tc_rh72(dev, qopt->num_tc);
++=======
+ 		err = dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
++>>>>>>> 2026fecf516b (mqprio: Change handling of hw u8 to allow for multiple hardware offload modes)
  		if (err)
  			return err;
+ 
+ 		priv->hw_offload = qopt->hw;
  	} else {
  		netdev_set_num_tc(dev, qopt->num_tc);
  		for (i = 0; i < qopt->num_tc; i++)
diff --git a/include/uapi/linux/pkt_sched.h b/include/uapi/linux/pkt_sched.h
index ce07d863dd81..9ab9c6aaa21f 100644
--- a/include/uapi/linux/pkt_sched.h
+++ b/include/uapi/linux/pkt_sched.h
@@ -613,6 +613,14 @@ struct tc_drr_stats {
 #define TC_QOPT_BITMASK 15
 #define TC_QOPT_MAX_QUEUE 16
 
+enum {
+	TC_MQPRIO_HW_OFFLOAD_NONE,	/* no offload requested */
+	TC_MQPRIO_HW_OFFLOAD_TCS,	/* offload TCs, no queue counts */
+	__TC_MQPRIO_HW_OFFLOAD_MAX
+};
+
+#define TC_MQPRIO_HW_OFFLOAD_MAX (__TC_MQPRIO_HW_OFFLOAD_MAX - 1)
+
 struct tc_mqprio_qopt {
 	__u8	num_tc;
 	__u8	prio_tc_map[TC_QOPT_BITMASK + 1];
* Unmerged path net/sched/sch_mqprio.c
