nfs: fix a deadlock in nfs client initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Scott Mayhew <smayhew@redhat.com>
commit c156618e15101a9cc8c815108fec0300a0ec6637
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c156618e.failed

The following deadlock can occur between a process waiting for a client
to initialize in while walking the client list during nfsv4 server trunking
detection and another process waiting for the nfs_clid_init_mutex so it
can initialize that client:

Process 1                               Process 2
---------                               ---------
spin_lock(&nn->nfs_client_lock);
list_add_tail(&CLIENTA->cl_share_link,
        &nn->nfs_client_list);
spin_unlock(&nn->nfs_client_lock);
                                        spin_lock(&nn->nfs_client_lock);
                                        list_add_tail(&CLIENTB->cl_share_link,
                                                &nn->nfs_client_list);
                                        spin_unlock(&nn->nfs_client_lock);
                                        mutex_lock(&nfs_clid_init_mutex);
                                        nfs41_walk_client_list(clp, result, cred);
                                        nfs_wait_client_init_complete(CLIENTA);
(waiting for nfs_clid_init_mutex)

Make sure nfs_match_client() only evaluates clients that have completed
initialization in order to prevent that deadlock.

This patch also fixes v4.0 trunking behavior by not marking the client
NFS_CS_READY until the clientid has been confirmed.

	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit c156618e15101a9cc8c815108fec0300a0ec6637)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4client.c
diff --cc fs/nfs/nfs4client.c
index f08b7f95dabd,65a7e5da508c..000000000000
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@@ -416,9 -408,17 +413,16 @@@ struct nfs_client *nfs4_init_client(str
  	if (error < 0)
  		goto error;
  
- 	if (clp != old)
+ 	if (clp != old) {
  		clp->cl_preserve_clid = true;
+ 		/*
+ 		 * Mark the client as having failed initialization so other
+ 		 * processes walking the nfs_client_list in nfs_match_client()
+ 		 * won't try to use it.
+ 		 */
+ 		nfs_mark_client_ready(clp, -EPERM);
+ 	}
  	nfs_put_client(clp);
 -	clear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);
  	return old;
  
  error:
@@@ -500,34 -543,13 +504,44 @@@ int nfs40_walk_client_list(struct nfs_c
  	spin_lock(&nn->nfs_client_lock);
  	list_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {
  
++<<<<<<< HEAD
 +		if (pos->rpc_ops != new->rpc_ops)
 +			continue;
 +
 +		if (pos->cl_minorversion != new->cl_minorversion)
 +			continue;
 +
 +		/* If "pos" isn't marked ready, we can't trust the
 +		 * remaining fields in "pos" */
 +		if (pos->cl_cons_state > NFS_CS_READY) {
 +			atomic_inc(&pos->cl_count);
 +			spin_unlock(&nn->nfs_client_lock);
 +
 +			nfs_put_client(prev);
 +			prev = pos;
 +
 +			status = nfs_wait_client_init_complete(pos);
 +			if (status < 0)
 +				goto out;
 +			status = -NFS4ERR_STALE_CLIENTID;
 +			spin_lock(&nn->nfs_client_lock);
 +		}
 +		if (pos->cl_cons_state != NFS_CS_READY)
 +			continue;
 +
 +		if (pos->cl_clientid != new->cl_clientid)
 +			continue;
 +
 +		if (!nfs4_match_client_owner_id(pos, new))
++=======
+ 		if (pos == new)
+ 			goto found;
+ 
+ 		status = nfs4_match_client(pos, new, &prev, nn);
+ 		if (status < 0)
+ 			goto out_unlock;
+ 		if (status != 0)
++>>>>>>> c156618e1510 (nfs: fix a deadlock in nfs client initialization)
  			continue;
  		/*
  		 * We just sent a new SETCLIENTID, which should have
@@@ -544,7 -566,8 +558,12 @@@
  		 * way that a SETCLIENTID_CONFIRM to pos can succeed is
  		 * if new and pos point to the same server:
  		 */
++<<<<<<< HEAD
 +		atomic_inc(&pos->cl_count);
++=======
+ found:
+ 		refcount_inc(&pos->cl_count);
++>>>>>>> c156618e1510 (nfs: fix a deadlock in nfs client initialization)
  		spin_unlock(&nn->nfs_client_lock);
  
  		nfs_put_client(prev);
diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 9297f0681511..3fe57c4b9403 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -297,12 +297,23 @@ static struct nfs_client *nfs_match_client(const struct nfs_client_initdata *dat
 	const struct sockaddr *sap = data->addr;
 	struct nfs_net *nn = net_generic(data->net, nfs_net_id);
 
+again:
 	list_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {
 	        const struct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;
 		/* Don't match clients that failed to initialise properly */
 		if (clp->cl_cons_state < 0)
 			continue;
 
+		/* If a client is still initializing then we need to wait */
+		if (clp->cl_cons_state > NFS_CS_READY) {
+			refcount_inc(&clp->cl_count);
+			spin_unlock(&nn->nfs_client_lock);
+			nfs_wait_client_init_complete(clp);
+			nfs_put_client(clp);
+			spin_lock(&nn->nfs_client_lock);
+			goto again;
+		}
+
 		/* Different NFS versions cannot share the same nfs_client */
 		if (clp->rpc_ops != data->nfs_mod->rpc_ops)
 			continue;
* Unmerged path fs/nfs/nfs4client.c
