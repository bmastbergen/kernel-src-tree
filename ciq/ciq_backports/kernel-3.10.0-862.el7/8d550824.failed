drm/i915: Order two completing nop_submit_request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Chris Wilson <chris@chris-wilson.co.uk>
commit 8d550824c6f52506754f11cb6be51aa153cc580d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8d550824.failed

If two nop's (requests in-flight following a wedged device) complete at
the same time, the global_seqno value written to the HWSP is undefined
as the two threads are not serialized.

v2: Use irqsafe spinlock. We expect the callback may be called from
inside another irq spinlock, so we can't unconditionally restore irqs.

Fixes: ce1135c7de64 ("drm/i915: Complete requests in nop_submit_request")
	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20171006115617.18432-1-chris@chris-wilson.co.uk
(cherry picked from commit 8d550824c6f52506754f11cb6be51aa153cc580d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_gem.c
diff --cc drivers/gpu/drm/i915/i915_gem.c
index a2f7d83d21a7,50cc3c2cef06..000000000000
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@@ -2791,16 -2993,51 +2791,27 @@@ void i915_gem_reset(struct drm_i915_pri
  	}
  }
  
 -void i915_gem_reset_finish_engine(struct intel_engine_cs *engine)
 -{
 -	tasklet_enable(&engine->execlists.irq_tasklet);
 -	kthread_unpark(engine->breadcrumbs.signaler);
 -}
 -
 -void i915_gem_reset_finish(struct drm_i915_private *dev_priv)
 -{
 -	struct intel_engine_cs *engine;
 -	enum intel_engine_id id;
 -
 -	lockdep_assert_held(&dev_priv->drm.struct_mutex);
 -
 -	for_each_engine(engine, dev_priv, id) {
 -		engine->hangcheck.active_request = NULL;
 -		i915_gem_reset_finish_engine(engine);
 -	}
 -}
 -
  static void nop_submit_request(struct drm_i915_gem_request *request)
  {
++<<<<<<< HEAD
 +	i915_gem_request_submit(request);
++=======
+ 	unsigned long flags;
+ 
+ 	GEM_BUG_ON(!i915_terminally_wedged(&request->i915->gpu_error));
+ 	dma_fence_set_error(&request->fence, -EIO);
+ 
+ 	spin_lock_irqsave(&request->engine->timeline->lock, flags);
+ 	__i915_gem_request_submit(request);
++>>>>>>> 8d550824c6f5 (drm/i915: Order two completing nop_submit_request)
  	intel_engine_init_global_seqno(request->engine, request->global_seqno);
+ 	spin_unlock_irqrestore(&request->engine->timeline->lock, flags);
  }
  
 -static void engine_set_wedged(struct intel_engine_cs *engine)
 +static void i915_gem_cleanup_engine(struct intel_engine_cs *engine)
  {
 -	/* We need to be sure that no thread is running the old callback as
 -	 * we install the nop handler (otherwise we would submit a request
 -	 * to hardware that will never complete). In order to prevent this
 -	 * race, we wait until the machine is idle before making the swap
 -	 * (using stop_machine()).
 -	 */
  	engine->submit_request = nop_submit_request;
  
 -	/* Mark all executing requests as skipped */
 -	engine->cancel_requests(engine);
 -
  	/* Mark all pending requests as complete so that any concurrent
  	 * (lockless) lookup doesn't try and wait upon the request as we
  	 * reset it.
* Unmerged path drivers/gpu/drm/i915/i915_gem.c
