openvswitch: Fix for force/commit action failures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Greg Rose <gvrose8192@gmail.com>
commit 8b97ac5bda17cfaa257bcab6180af0f43a2e87e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8b97ac5b.failed

When there is an established connection in direction A->B, it is
possible to receive a packet on port B which then executes
ct(commit,force) without first performing ct() - ie, a lookup.
In this case, we would expect that this packet can delete the existing
entry so that we can commit a connection with direction B->A. However,
currently we only perform a check in skb_nfct_cached() for whether
OVS_CS_F_TRACKED is set and OVS_CS_F_INVALID is not set, ie that a
lookup previously occurred. In the above scenario, a lookup has not
occurred but we should still be able to statelessly look up the
existing entry and potentially delete the entry if it is in the
opposite direction.

This patch extends the check to also hint that if the action has the
force flag set, then we will lookup the existing entry so that the
force check at the end of skb_nfct_cached has the ability to delete
the connection.

Fixes: dd41d330b03 ("openvswitch: Add force commit.")
CC: Pravin Shelar <pshelar@nicira.com>
CC: dev@openvswitch.org
	Signed-off-by: Joe Stringer <joe@ovn.org>
	Signed-off-by: Greg Rose <gvrose8192@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8b97ac5bda17cfaa257bcab6180af0f43a2e87e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/conntrack.c
diff --cc net/openvswitch/conntrack.c
index 6843f95142f8,e3c4c6c3fef7..000000000000
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@@ -547,7 -629,35 +547,39 @@@ ovs_ct_find_existing(struct net *net, c
  	return ct;
  }
  
++<<<<<<< HEAD
 +/* Determine whether skb->nfct is equal to the result of conntrack lookup. */
++=======
+ static
+ struct nf_conn *ovs_ct_executed(struct net *net,
+ 				const struct sw_flow_key *key,
+ 				const struct ovs_conntrack_info *info,
+ 				struct sk_buff *skb,
+ 				bool *ct_executed)
+ {
+ 	struct nf_conn *ct = NULL;
+ 
+ 	/* If no ct, check if we have evidence that an existing conntrack entry
+ 	 * might be found for this skb.  This happens when we lose a skb->_nfct
+ 	 * due to an upcall, or if the direction is being forced.  If the
+ 	 * connection was not confirmed, it is not cached and needs to be run
+ 	 * through conntrack again.
+ 	 */
+ 	*ct_executed = (key->ct_state & OVS_CS_F_TRACKED) &&
+ 		       !(key->ct_state & OVS_CS_F_INVALID) &&
+ 		       (key->ct_zone == info->zone.id);
+ 
+ 	if (*ct_executed || (!key->ct_state && info->force)) {
+ 		ct = ovs_ct_find_existing(net, &info->zone, info->family, skb,
+ 					  !!(key->ct_state &
+ 					  OVS_CS_F_NAT_MASK));
+ 	}
+ 
+ 	return ct;
+ }
+ 
+ /* Determine whether skb->_nfct is equal to the result of conntrack lookup. */
++>>>>>>> 8b97ac5bda17 (openvswitch: Fix for force/commit action failures)
  static bool skb_nfct_cached(struct net *net,
  			    const struct sw_flow_key *key,
  			    const struct ovs_conntrack_info *info,
@@@ -555,19 -665,17 +587,29 @@@
  {
  	enum ip_conntrack_info ctinfo;
  	struct nf_conn *ct;
+ 	bool ct_executed = true;
  
  	ct = nf_ct_get(skb, &ctinfo);
++<<<<<<< HEAD
 +	/* If no ct, check if we have evidence that an existing conntrack entry
 +	 * might be found for this skb.  This happens when we lose a skb->nfct
 +	 * due to an upcall.  If the connection was not confirmed, it is not
 +	 * cached and needs to be run through conntrack again.
 +	 */
 +	if (!ct && key->ct.state & OVS_CS_F_TRACKED &&
 +	    !(key->ct.state & OVS_CS_F_INVALID) &&
 +	    key->ct.zone == info->zone.id)
 +		ct = ovs_ct_find_existing(net, &info->zone, info->family, skb);
++=======
++>>>>>>> 8b97ac5bda17 (openvswitch: Fix for force/commit action failures)
  	if (!ct)
+ 		ct = ovs_ct_executed(net, key, info, skb, &ct_executed);
+ 
+ 	if (ct)
+ 		nf_ct_get(skb, &ctinfo);
+ 	else
  		return false;
+ 
  	if (!net_eq(net, read_pnet(&ct->ct_net)))
  		return false;
  	if (!nf_ct_zone_equal_any(info->ct, nf_ct_zone(ct)))
@@@ -579,8 -687,20 +621,8 @@@
  		if (help && rcu_access_pointer(help->helper) != info->helper)
  			return false;
  	}
 -	/* Force conntrack entry direction to the current packet? */
 -	if (info->force && CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL) {
 -		/* Delete the conntrack entry if confirmed, else just release
 -		 * the reference.
 -		 */
 -		if (nf_ct_is_confirmed(ct))
 -			nf_ct_delete(ct, 0, 0);
 -
 -		nf_conntrack_put(&ct->ct_general);
 -		nf_ct_set(skb, NULL, 0);
 -		return false;
 -	}
  
- 	return true;
+ 	return ct_executed;
  }
  
  #ifdef CONFIG_NF_NAT_NEEDED
* Unmerged path net/openvswitch/conntrack.c
