Drivers: hv: vmbus: Get the current time from the current clocksource

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Get the current time from the current clocksource (Mohammed Gamal) [1467258]
Rebuild_FUZZ: 89.60%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit e546d778d6bb3e1a80697a6556d870c707e6df82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e546d778.failed

The current code uses the MSR based mechanism to get the current tick.
Use the current clock source as that might be more optimal.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit e546d778d6bb3e1a80697a6556d870c707e6df82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
#	drivers/hv/hv.c
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,18325dcdb7f1..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -70,6 -100,60 +70,63 @@@ static inline  __u64 generate_guest_id(
  	return guest_id;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* Free the message slot and signal end-of-message if required */
+ static inline void vmbus_signal_eom(struct hv_message *msg, u32 old_msg_type)
+ {
+ 	/*
+ 	 * On crash we're reading some other CPU's message page and we need
+ 	 * to be careful: this other CPU may already had cleared the header
+ 	 * and the host may already had delivered some other message there.
+ 	 * In case we blindly write msg->header.message_type we're going
+ 	 * to lose it. We can still lose a message of the same type but
+ 	 * we count on the fact that there can only be one
+ 	 * CHANNELMSG_UNLOAD_RESPONSE and we don't care about other messages
+ 	 * on crash.
+ 	 */
+ 	if (cmpxchg(&msg->header.message_type, old_msg_type,
+ 		    HVMSG_NONE) != old_msg_type)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure the write to MessageType (ie set to
+ 	 * HVMSG_NONE) happens before we read the
+ 	 * MessagePending and EOMing. Otherwise, the EOMing
+ 	 * will not deliver any more messages since there is
+ 	 * no empty slot
+ 	 */
+ 	mb();
+ 
+ 	if (msg->header.message_flags.msg_pending) {
+ 		/*
+ 		 * This will cause message queue rescan to
+ 		 * possibly deliver another msg from the
+ 		 * hypervisor
+ 		 */
+ 		wrmsrl(HV_X64_MSR_EOM, 0);
+ 	}
+ }
+ 
+ #define hv_init_timer(timer, tick) wrmsrl(timer, tick)
+ #define hv_init_timer_config(config, val) wrmsrl(config, val)
+ 
+ #define hv_get_simp(val) rdmsrl(HV_X64_MSR_SIMP, val)
+ #define hv_set_simp(val) wrmsrl(HV_X64_MSR_SIMP, val)
+ 
+ #define hv_get_siefp(val) rdmsrl(HV_X64_MSR_SIEFP, val)
+ #define hv_set_siefp(val) wrmsrl(HV_X64_MSR_SIEFP, val)
+ 
+ #define hv_get_synic_state(val) rdmsrl(HV_X64_MSR_SCONTROL, val)
+ #define hv_set_synic_state(val) wrmsrl(HV_X64_MSR_SCONTROL, val)
+ 
+ #define hv_get_vp_index(index) rdmsrl(HV_X64_MSR_VP_INDEX, index)
+ 
+ #define hv_get_synint_state(int_num, val) rdmsrl(int_num, val)
+ #define hv_set_synint_state(int_num, val) wrmsrl(int_num, val)
+ 
++>>>>>>> e546d778d6bb (Drivers: hv: vmbus: Get the current time from the current clocksource)
  void hyperv_callback_vector(void);
  #ifdef CONFIG_TRACING
  #define trace_hyperv_callback_vector hyperv_callback_vector
diff --cc drivers/hv/hv.c
index f6a591c69dfd,61fc8ce169a5..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -268,13 -92,13 +268,17 @@@ int hv_post_message(union hv_connection
  static int hv_ce_set_next_event(unsigned long delta,
  				struct clock_event_device *evt)
  {
 -	u64 current_tick;
 +	cycle_t current_tick;
  
 -	WARN_ON(!clockevent_state_oneshot(evt));
 +	WARN_ON(evt->mode != CLOCK_EVT_MODE_ONESHOT);
  
++<<<<<<< HEAD
 +	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
++=======
+ 	current_tick = hyperv_cs->read(NULL);
++>>>>>>> e546d778d6bb (Drivers: hv: vmbus: Get the current time from the current clocksource)
  	current_tick += delta;
 -	hv_init_timer(HV_X64_MSR_STIMER0_COUNT, current_tick);
 +	wrmsrl(HV_X64_MSR_STIMER0_COUNT, current_tick);
  	return 0;
  }
  
* Unmerged path arch/x86/include/asm/mshyperv.h
* Unmerged path drivers/hv/hv.c
