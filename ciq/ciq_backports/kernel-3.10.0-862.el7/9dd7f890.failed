openvswitch: Add original direction conntrack tuple to sw_flow_key.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] openvswitch: Add original direction conntrack tuple to sw_flow_key (Jiri Benc) [1497774]
Rebuild_FUZZ: 99.25%
commit-author Jarno Rajahalme <jarno@ovn.org>
commit 9dd7f8907c3705dc7a7a375d1c6e30b06e6daffc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9dd7f890.failed

Add the fields of the conntrack original direction 5-tuple to struct
sw_flow_key.  The new fields are initially marked as non-existent, and
are populated whenever a conntrack action is executed and either finds
or generates a conntrack entry.  This means that these fields exist
for all packets that were not rejected by conntrack as untrackable.

The original tuple fields in the sw_flow_key are filled from the
original direction tuple of the conntrack entry relating to the
current packet, or from the original direction tuple of the master
conntrack entry, if the current conntrack entry has a master.
Generally, expected connections of connections having an assigned
helper (e.g., FTP), have a master conntrack entry.

The main purpose of the new conntrack original tuple fields is to
allow matching on them for policy decision purposes, with the premise
that the admissibility of tracked connections reply packets (as well
as original direction packets), and both direction packets of any
related connections may be based on ACL rules applying to the master
connection's original direction 5-tuple.  This also makes it easier to
make policy decisions when the actual packet headers might have been
transformed by NAT, as the original direction 5-tuple represents the
packet headers before any such transformation.

When using the original direction 5-tuple the admissibility of return
and/or related packets need not be based on the mere existence of a
conntrack entry, allowing separation of admission policy from the
established conntrack state.  While existence of a conntrack entry is
required for admission of the return or related packets, policy
changes can render connections that were initially admitted to be
rejected or dropped afterwards.  If the admission of the return and
related packets was based on mere conntrack state (e.g., connection
being in an established state), a policy change that would make the
connection rejected or dropped would need to find and delete all
conntrack entries affected by such a change.  When using the original
direction 5-tuple matching the affected conntrack entries can be
allowed to time out instead, as the established state of the
connection would not need to be the basis for packet admission any
more.

It should be noted that the directionality of related connections may
be the same or different than that of the master connection, and
neither the original direction 5-tuple nor the conntrack state bits
carry this information.  If needed, the directionality of the master
connection can be stored in master's conntrack mark or labels, which
are automatically inherited by the expected related connections.

The fact that neither ARP nor ND packets are trackable by conntrack
allows mutual exclusion between ARP/ND and the new conntrack original
tuple fields.  Hence, the IP addresses are overlaid in union with ARP
and ND fields.  This allows the sw_flow_key to not grow much due to
this patch, but it also means that we must be careful to never use the
new key fields with ARP or ND packets.  ARP is easy to distinguish and
keep mutually exclusive based on the ethernet type, but ND being an
ICMPv6 protocol requires a bit more attention.

	Signed-off-by: Jarno Rajahalme <jarno@ovn.org>
	Acked-by: Joe Stringer <joe@ovn.org>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9dd7f8907c3705dc7a7a375d1c6e30b06e6daffc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/flow.c
#	net/openvswitch/flow_netlink.c
diff --cc net/openvswitch/flow.c
index f677cc12bd8c,9d4bb8eb63f2..000000000000
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@@ -722,6 -751,22 +722,11 @@@ int ovs_flow_key_update(struct sk_buff 
  int ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,
  			 struct sk_buff *skb, struct sw_flow_key *key)
  {
++<<<<<<< HEAD
++=======
+ 	int res, err;
+ 
++>>>>>>> 9dd7f8907c37 (openvswitch: Add original direction conntrack tuple to sw_flow_key.)
  	/* Extract metadata from packet. */
  	if (tun_info) {
  		key->tun_proto = ip_tunnel_info_af(tun_info);
@@@ -747,11 -792,17 +752,13 @@@
  	key->phy.priority = skb->priority;
  	key->phy.in_port = OVS_CB(skb)->input_vport->port_no;
  	key->phy.skb_mark = skb->mark;
- 	ovs_ct_fill_key(skb, key);
  	key->ovs_flow_hash = 0;
 -	res = key_extract_mac_proto(skb);
 -	if (res < 0)
 -		return res;
 -	key->mac_proto = res;
  	key->recirc_id = 0;
  
- 	return key_extract(skb, key);
+ 	err = key_extract(skb, key);
+ 	if (!err)
+ 		ovs_ct_fill_key(skb, key);   /* Must be after key_extract(). */
+ 	return err;
  }
  
  int ovs_flow_key_extract_userspace(struct net *net, const struct nlattr *attr,
@@@ -765,5 -822,31 +778,35 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	return key_extract(skb, key);
++=======
+ 	/* key_extract assumes that skb->protocol is set-up for
+ 	 * layer 3 packets which is the case for other callers,
+ 	 * in particular packets received from the network stack.
+ 	 * Here the correct value can be set from the metadata
+ 	 * extracted above.
+ 	 * For L2 packet key eth type would be zero. skb protocol
+ 	 * would be set to correct value later during key-extact.
+ 	 */
+ 
+ 	skb->protocol = key->eth.type;
+ 	err = key_extract(skb, key);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Check that we have conntrack original direction tuple metadata only
+ 	 * for packets for which it makes sense.  Otherwise the key may be
+ 	 * corrupted due to overlapping key fields.
+ 	 */
+ 	if (attrs & (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4) &&
+ 	    key->eth.type != htons(ETH_P_IP))
+ 		return -EINVAL;
+ 	if (attrs & (1 << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6) &&
+ 	    (key->eth.type != htons(ETH_P_IPV6) ||
+ 	     sw_flow_key_is_nd(key)))
+ 		return -EINVAL;
+ 
+ 	return 0;
++>>>>>>> 9dd7f8907c37 (openvswitch: Add original direction conntrack tuple to sw_flow_key.)
  }
diff --cc net/openvswitch/flow_netlink.c
index 559c659f3ff6,989f38f120bb..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -1059,6 -1098,49 +1075,52 @@@ static int metadata_from_nlattrs(struc
  				   sizeof(*cl), is_mask);
  		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);
  	}
++<<<<<<< HEAD
++=======
+ 	if (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4)) {
+ 		const struct ovs_key_ct_tuple_ipv4 *ct;
+ 
+ 		ct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ipv4.ct_orig.src, ct->ipv4_src, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ipv4.ct_orig.dst, ct->ipv4_dst, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_proto, ct->ipv4_proto, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4);
+ 	}
+ 	if (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6)) {
+ 		const struct ovs_key_ct_tuple_ipv6 *ct;
+ 
+ 		ct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6]);
+ 
+ 		SW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.src, &ct->ipv6_src,
+ 				   sizeof(match->key->ipv6.ct_orig.src),
+ 				   is_mask);
+ 		SW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.dst, &ct->ipv6_dst,
+ 				   sizeof(match->key->ipv6.ct_orig.dst),
+ 				   is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_proto, ct->ipv6_proto, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6);
+ 	}
+ 
+ 	/* For layer 3 packets the Ethernet type is provided
+ 	 * and treated as metadata but no MAC addresses are provided.
+ 	 */
+ 	if (!(*attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&
+ 	    (*attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)))
+ 		mac_proto = MAC_PROTO_NONE;
+ 
+ 	/* Always exact match mac_proto */
+ 	SW_FLOW_KEY_PUT(match, mac_proto, is_mask ? 0xff : mac_proto, is_mask);
+ 
+ 	if (mac_proto == MAC_PROTO_NONE)
+ 		return parse_eth_type_from_nlattrs(match, attrs, a, is_mask,
+ 						   log);
+ 
++>>>>>>> 9dd7f8907c37 (openvswitch: Add original direction conntrack tuple to sw_flow_key.)
  	return 0;
  }
  
@@@ -1553,45 -1629,47 +1616,45 @@@ static int __ovs_nla_put_key(const stru
  	if (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))
  		goto nla_put_failure;
  
- 	if (ovs_ct_put_key(output, skb))
+ 	if (ovs_ct_put_key(swkey, output, skb))
  		goto nla_put_failure;
  
 -	if (ovs_key_mac_proto(swkey) == MAC_PROTO_ETHERNET) {
 -		nla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));
 -		if (!nla)
 -			goto nla_put_failure;
 +	nla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));
 +	if (!nla)
 +		goto nla_put_failure;
  
 -		eth_key = nla_data(nla);
 -		ether_addr_copy(eth_key->eth_src, output->eth.src);
 -		ether_addr_copy(eth_key->eth_dst, output->eth.dst);
 +	eth_key = nla_data(nla);
 +	ether_addr_copy(eth_key->eth_src, output->eth.src);
 +	ether_addr_copy(eth_key->eth_dst, output->eth.dst);
 +
 +	if (swkey->eth.vlan.tci || eth_type_vlan(swkey->eth.type)) {
 +		if (ovs_nla_put_vlan(skb, &output->eth.vlan, is_mask))
 +			goto nla_put_failure;
 +		encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);
 +		if (!swkey->eth.vlan.tci)
 +			goto unencap;
  
 -		if (swkey->eth.vlan.tci || eth_type_vlan(swkey->eth.type)) {
 -			if (ovs_nla_put_vlan(skb, &output->eth.vlan, is_mask))
 +		if (swkey->eth.cvlan.tci || eth_type_vlan(swkey->eth.type)) {
 +			if (ovs_nla_put_vlan(skb, &output->eth.cvlan, is_mask))
  				goto nla_put_failure;
 -			encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);
 -			if (!swkey->eth.vlan.tci)
 +			in_encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);
 +			if (!swkey->eth.cvlan.tci)
  				goto unencap;
 -
 -			if (swkey->eth.cvlan.tci || eth_type_vlan(swkey->eth.type)) {
 -				if (ovs_nla_put_vlan(skb, &output->eth.cvlan, is_mask))
 -					goto nla_put_failure;
 -				in_encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);
 -				if (!swkey->eth.cvlan.tci)
 -					goto unencap;
 -			}
  		}
 +	}
  
 -		if (swkey->eth.type == htons(ETH_P_802_2)) {
 -			/*
 -			* Ethertype 802.2 is represented in the netlink with omitted
 -			* OVS_KEY_ATTR_ETHERTYPE in the flow key attribute, and
 -			* 0xffff in the mask attribute.  Ethertype can also
 -			* be wildcarded.
 -			*/
 -			if (is_mask && output->eth.type)
 -				if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,
 -							output->eth.type))
 -					goto nla_put_failure;
 -			goto unencap;
 -		}
 +	if (swkey->eth.type == htons(ETH_P_802_2)) {
 +		/*
 +		 * Ethertype 802.2 is represented in the netlink with omitted
 +		 * OVS_KEY_ATTR_ETHERTYPE in the flow key attribute, and
 +		 * 0xffff in the mask attribute.  Ethertype can also
 +		 * be wildcarded.
 +		 */
 +		if (is_mask && output->eth.type)
 +			if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,
 +						output->eth.type))
 +				goto nla_put_failure;
 +		goto unencap;
  	}
  
  	if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))
diff --git a/include/uapi/linux/openvswitch.h b/include/uapi/linux/openvswitch.h
index f8b3d4891de2..8f7a8e046d97 100644
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (c) 2007-2013 Nicira, Inc.
+ * Copyright (c) 2007-2017 Nicira, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of version 2 of the GNU General Public
@@ -331,6 +331,8 @@ enum ovs_key_attr {
 	OVS_KEY_ATTR_CT_ZONE,	/* u16 connection tracking zone. */
 	OVS_KEY_ATTR_CT_MARK,	/* u32 connection tracking mark */
 	OVS_KEY_ATTR_CT_LABELS,	/* 16-octet connection tracking label */
+	OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4,   /* struct ovs_key_ct_tuple_ipv4 */
+	OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6,   /* struct ovs_key_ct_tuple_ipv6 */
 
 #ifdef __KERNEL__
 	OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ip_tunnel_info */
@@ -472,6 +474,22 @@ struct ovs_key_ct_labels {
 
 #define OVS_CS_F_NAT_MASK (OVS_CS_F_SRC_NAT | OVS_CS_F_DST_NAT)
 
+struct ovs_key_ct_tuple_ipv4 {
+	__be32 ipv4_src;
+	__be32 ipv4_dst;
+	__be16 src_port;
+	__be16 dst_port;
+	__u8   ipv4_proto;
+};
+
+struct ovs_key_ct_tuple_ipv6 {
+	__be32 ipv6_src[4];
+	__be32 ipv6_dst[4];
+	__be16 src_port;
+	__be16 dst_port;
+	__u8   ipv6_proto;
+};
+
 /**
  * enum ovs_flow_attr - attributes for %OVS_FLOW_* commands.
  * @OVS_FLOW_ATTR_KEY: Nested %OVS_KEY_ATTR_* attributes specifying the flow
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index 330400f32a72..3a0ac54b1658 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -1068,6 +1068,8 @@ static int execute_masked_set_action(struct sk_buff *skb,
 	case OVS_KEY_ATTR_CT_ZONE:
 	case OVS_KEY_ATTR_CT_MARK:
 	case OVS_KEY_ATTR_CT_LABELS:
+	case OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4:
+	case OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6:
 		err = -EINVAL;
 		break;
 	}
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index a817d2fd90cf..2f1ebf63ac00 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -147,6 +147,20 @@ static void ovs_ct_get_labels(const struct nf_conn *ct,
 		memset(labels, 0, OVS_CT_LABELS_LEN);
 }
 
+static void __ovs_ct_update_key_orig_tp(struct sw_flow_key *key,
+					const struct nf_conntrack_tuple *orig,
+					u8 icmp_proto)
+{
+	key->ct.orig_proto = orig->dst.protonum;
+	if (orig->dst.protonum == icmp_proto) {
+		key->ct.orig_tp.src = htons(orig->dst.u.icmp.type);
+		key->ct.orig_tp.dst = htons(orig->dst.u.icmp.code);
+	} else {
+		key->ct.orig_tp.src = orig->src.u.all;
+		key->ct.orig_tp.dst = orig->dst.u.all;
+	}
+}
+
 static void __ovs_ct_update_key(struct sw_flow_key *key, u8 state,
 				const struct nf_conntrack_zone *zone,
 				const struct nf_conn *ct)
@@ -155,6 +169,35 @@ static void __ovs_ct_update_key(struct sw_flow_key *key, u8 state,
 	key->ct.zone = zone->id;
 	key->ct.mark = ovs_ct_get_mark(ct);
 	ovs_ct_get_labels(ct, &key->ct.labels);
+
+	if (ct) {
+		const struct nf_conntrack_tuple *orig;
+
+		/* Use the master if we have one. */
+		if (ct->master)
+			ct = ct->master;
+		orig = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
+
+		/* IP version must match with the master connection. */
+		if (key->eth.type == htons(ETH_P_IP) &&
+		    nf_ct_l3num(ct) == NFPROTO_IPV4) {
+			key->ipv4.ct_orig.src = orig->src.u3.ip;
+			key->ipv4.ct_orig.dst = orig->dst.u3.ip;
+			__ovs_ct_update_key_orig_tp(key, orig, IPPROTO_ICMP);
+			return;
+		} else if (key->eth.type == htons(ETH_P_IPV6) &&
+			   !sw_flow_key_is_nd(key) &&
+			   nf_ct_l3num(ct) == NFPROTO_IPV6) {
+			key->ipv6.ct_orig.src = orig->src.u3.in6;
+			key->ipv6.ct_orig.dst = orig->dst.u3.in6;
+			__ovs_ct_update_key_orig_tp(key, orig, NEXTHDR_ICMP);
+			return;
+		}
+	}
+	/* Clear 'ct.orig_proto' to mark the non-existence of conntrack
+	 * original direction key fields.
+	 */
+	key->ct.orig_proto = 0;
 }
 
 /* Update 'key' based on skb->nfct.  If 'post_ct' is true, then OVS has
@@ -208,24 +251,55 @@ void ovs_ct_fill_key(const struct sk_buff *skb, struct sw_flow_key *key)
 	ovs_ct_update_key(skb, NULL, key, false, false);
 }
 
-int ovs_ct_put_key(const struct sw_flow_key *key, struct sk_buff *skb)
+#define IN6_ADDR_INITIALIZER(ADDR) \
+	{ (ADDR).s6_addr32[0], (ADDR).s6_addr32[1], \
+	  (ADDR).s6_addr32[2], (ADDR).s6_addr32[3] }
+
+int ovs_ct_put_key(const struct sw_flow_key *swkey,
+		   const struct sw_flow_key *output, struct sk_buff *skb)
 {
-	if (nla_put_u32(skb, OVS_KEY_ATTR_CT_STATE, key->ct.state))
+	if (nla_put_u32(skb, OVS_KEY_ATTR_CT_STATE, output->ct.state))
 		return -EMSGSIZE;
 
 	if (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&
-	    nla_put_u16(skb, OVS_KEY_ATTR_CT_ZONE, key->ct.zone))
+	    nla_put_u16(skb, OVS_KEY_ATTR_CT_ZONE, output->ct.zone))
 		return -EMSGSIZE;
 
 	if (IS_ENABLED(CONFIG_NF_CONNTRACK_MARK) &&
-	    nla_put_u32(skb, OVS_KEY_ATTR_CT_MARK, key->ct.mark))
+	    nla_put_u32(skb, OVS_KEY_ATTR_CT_MARK, output->ct.mark))
 		return -EMSGSIZE;
 
 	if (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&
-	    nla_put(skb, OVS_KEY_ATTR_CT_LABELS, sizeof(key->ct.labels),
-		    &key->ct.labels))
+	    nla_put(skb, OVS_KEY_ATTR_CT_LABELS, sizeof(output->ct.labels),
+		    &output->ct.labels))
 		return -EMSGSIZE;
 
+	if (swkey->ct.orig_proto) {
+		if (swkey->eth.type == htons(ETH_P_IP)) {
+			struct ovs_key_ct_tuple_ipv4 orig = {
+				output->ipv4.ct_orig.src,
+				output->ipv4.ct_orig.dst,
+				output->ct.orig_tp.src,
+				output->ct.orig_tp.dst,
+				output->ct.orig_proto,
+			};
+			if (nla_put(skb, OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4,
+				    sizeof(orig), &orig))
+				return -EMSGSIZE;
+		} else if (swkey->eth.type == htons(ETH_P_IPV6)) {
+			struct ovs_key_ct_tuple_ipv6 orig = {
+				IN6_ADDR_INITIALIZER(output->ipv6.ct_orig.src),
+				IN6_ADDR_INITIALIZER(output->ipv6.ct_orig.dst),
+				output->ct.orig_tp.src,
+				output->ct.orig_tp.dst,
+				output->ct.orig_proto,
+			};
+			if (nla_put(skb, OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6,
+				    sizeof(orig), &orig))
+				return -EMSGSIZE;
+		}
+	}
+
 	return 0;
 }
 
diff --git a/net/openvswitch/conntrack.h b/net/openvswitch/conntrack.h
index 8f6230bd6183..9e92445dc092 100644
--- a/net/openvswitch/conntrack.h
+++ b/net/openvswitch/conntrack.h
@@ -32,7 +32,8 @@ int ovs_ct_execute(struct net *, struct sk_buff *, struct sw_flow_key *,
 		   const struct ovs_conntrack_info *);
 
 void ovs_ct_fill_key(const struct sk_buff *skb, struct sw_flow_key *key);
-int ovs_ct_put_key(const struct sw_flow_key *key, struct sk_buff *skb);
+int ovs_ct_put_key(const struct sw_flow_key *swkey,
+		   const struct sw_flow_key *output, struct sk_buff *skb);
 void ovs_ct_free_action(const struct nlattr *a);
 
 #define CT_SUPPORTED_MASK (OVS_CS_F_NEW | OVS_CS_F_ESTABLISHED | \
@@ -79,9 +80,14 @@ static inline void ovs_ct_fill_key(const struct sk_buff *skb,
 	key->ct.zone = 0;
 	key->ct.mark = 0;
 	memset(&key->ct.labels, 0, sizeof(key->ct.labels));
+	/* Clear 'ct.orig_proto' to mark the non-existence of original
+	 * direction key fields.
+	 */
+	key->ct.orig_proto = 0;
 }
 
-static inline int ovs_ct_put_key(const struct sw_flow_key *key,
+static inline int ovs_ct_put_key(const struct sw_flow_key *swkey,
+				 const struct sw_flow_key *output,
 				 struct sk_buff *skb)
 {
 	return 0;
* Unmerged path net/openvswitch/flow.c
diff --git a/net/openvswitch/flow.h b/net/openvswitch/flow.h
index e8d49bec2ea0..76199612ce4f 100644
--- a/net/openvswitch/flow.h
+++ b/net/openvswitch/flow.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007-2014 Nicira, Inc.
+ * Copyright (c) 2007-2017 Nicira, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of version 2 of the GNU General Public
@@ -100,10 +100,16 @@ struct sw_flow_key {
 				__be32 src;	/* IP source address. */
 				__be32 dst;	/* IP destination address. */
 			} addr;
-			struct {
-				u8 sha[ETH_ALEN];	/* ARP source hardware address. */
-				u8 tha[ETH_ALEN];	/* ARP target hardware address. */
-			} arp;
+			union {
+				struct {
+					__be32 src;
+					__be32 dst;
+				} ct_orig;	/* Conntrack original direction fields. */
+				struct {
+					u8 sha[ETH_ALEN];	/* ARP source hardware address. */
+					u8 tha[ETH_ALEN];	/* ARP target hardware address. */
+				} arp;
+			};
 		} ipv4;
 		struct {
 			struct {
@@ -111,23 +117,44 @@ struct sw_flow_key {
 				struct in6_addr dst;	/* IPv6 destination address. */
 			} addr;
 			__be32 label;			/* IPv6 flow label. */
-			struct {
-				struct in6_addr target;	/* ND target address. */
-				u8 sll[ETH_ALEN];	/* ND source link layer address. */
-				u8 tll[ETH_ALEN];	/* ND target link layer address. */
-			} nd;
+			union {
+				struct {
+					struct in6_addr src;
+					struct in6_addr dst;
+				} ct_orig;	/* Conntrack original direction fields. */
+				struct {
+					struct in6_addr target;	/* ND target address. */
+					u8 sll[ETH_ALEN];	/* ND source link layer address. */
+					u8 tll[ETH_ALEN];	/* ND target link layer address. */
+				} nd;
+			};
 		} ipv6;
 	};
 	struct {
 		/* Connection tracking fields. */
+		u8 state;
+		u8 orig_proto;		/* CT orig tuple IP protocol. */
 		u16 zone;
 		u32 mark;
-		u8 state;
+		struct {
+			__be16 src;	/* CT orig tuple tp src port. */
+			__be16 dst;	/* CT orig tuple tp dst port. */
+		} orig_tp;
+
 		struct ovs_key_ct_labels labels;
 	} ct;
 
 } __aligned(BITS_PER_LONG/8); /* Ensure that we can do comparisons as longs. */
 
+static inline bool sw_flow_key_is_nd(const struct sw_flow_key *key)
+{
+	return key->eth.type == htons(ETH_P_IPV6) &&
+		key->ip.proto == NEXTHDR_ICMP &&
+		key->tp.dst == 0 &&
+		(key->tp.src == htons(NDISC_NEIGHBOUR_SOLICITATION) ||
+		 key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT));
+}
+
 struct sw_flow_key_range {
 	unsigned short int start;
 	unsigned short int end;
* Unmerged path net/openvswitch/flow_netlink.c
diff --git a/net/openvswitch/flow_netlink.h b/net/openvswitch/flow_netlink.h
index 45f9769e5aac..929c665ac3aa 100644
--- a/net/openvswitch/flow_netlink.h
+++ b/net/openvswitch/flow_netlink.h
@@ -46,8 +46,11 @@ void ovs_match_init(struct sw_flow_match *match,
 
 int ovs_nla_put_key(const struct sw_flow_key *, const struct sw_flow_key *,
 		    int attr, bool is_mask, struct sk_buff *);
-int ovs_nla_get_flow_metadata(struct net *, const struct nlattr *,
-			      struct sw_flow_key *, bool log);
+int parse_flow_nlattrs(const struct nlattr *attr, const struct nlattr *a[],
+		       u64 *attrsp, bool log);
+int ovs_nla_get_flow_metadata(struct net *net,
+			      const struct nlattr *a[OVS_KEY_ATTR_MAX + 1],
+			      u64 attrs, struct sw_flow_key *key, bool log);
 
 int ovs_nla_put_identifier(const struct sw_flow *flow, struct sk_buff *skb);
 int ovs_nla_put_masked_key(const struct sw_flow *flow, struct sk_buff *skb);
