OF: make of_property_for_each_{u32|string}() use parameters if OF is not enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit 2adfffa223500b739b17dcf3d710cec344f7608f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2adfffa2.failed

I am getting a few
|warning: unused variable ‘p’ [-Wunused-variable]
|warning: unused variable ‘prop’ [-Wunused-variable]

in the case where CONFIG_OF is not defined and the parameters are only
used in the loop macro.

	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Grant Likely <grant.likely@linaro.org>
(cherry picked from commit 2adfffa223500b739b17dcf3d710cec344f7608f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/of.h
diff --cc include/linux/of.h
index 579834746e27,90a8811e9e48..000000000000
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@@ -571,162 -494,31 +560,170 @@@ static inline int of_machine_is_compati
  	return 0;
  }
  
+ static inline const __be32 *of_prop_next_u32(struct property *prop,
+ 		const __be32 *cur, u32 *pu)
+ {
+ 	return NULL;
+ }
+ 
+ static inline const char *of_prop_next_string(struct property *prop,
+ 		const char *cur)
+ {
+ 	return NULL;
+ }
+ 
  #define of_match_ptr(_ptr)	NULL
  #define of_match_node(_matches, _node)	NULL
- #define of_property_for_each_u32(np, propname, prop, p, u) \
- 	while (0)
- #define of_property_for_each_string(np, propname, prop, s) \
- 	while (0)
  #endif /* CONFIG_OF */
  
 -#ifndef of_node_to_nid
 -static inline int of_node_to_nid(struct device_node *np)
 +#if defined(CONFIG_OF) && defined(CONFIG_NUMA)
 +extern int of_node_to_nid(struct device_node *np);
 +#else
 +static inline int of_node_to_nid(struct device_node *device)
  {
 -	return numa_node_id();
 +	return NUMA_NO_NODE;
  }
 -
 -#define of_node_to_nid of_node_to_nid
  #endif
  
 +static inline struct device_node *of_find_matching_node(
 +	struct device_node *from,
 +	const struct of_device_id *matches)
 +{
 +	return of_find_matching_node_and_match(from, matches, NULL);
 +}
 +
 +/**
 + * of_property_read_string_array() - Read an array of strings from a multiple
 + * strings property.
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_strs:	output array of string pointers.
 + * @sz:		number of array elements to read.
 + *
 + * Search for a property in a device tree node and retrieve a list of
 + * terminated string values (pointer to data, not a copy) in that property.
 + *
 + * If @out_strs is NULL, the number of strings in the property is returned.
 + */
 +static inline int of_property_read_string_array(struct device_node *np,
 +						const char *propname, const char **out_strs,
 +						size_t sz)
 +{
 +	return of_property_read_string_helper(np, propname, out_strs, sz, 0);
 +}
 +
 +/**
 + * of_property_count_strings() - Find and return the number of strings from a
 + * multiple strings property.
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + *
 + * Search for a property in a device tree node and retrieve the number of null
 + * terminated string contain in it. Returns the number of strings on
 + * success, -EINVAL if the property does not exist, -ENODATA if property
 + * does not have a value, and -EILSEQ if the string is not null-terminated
 + * within the length of the property data.
 + */
 +static inline int of_property_count_strings(struct device_node *np,
 +					    const char *propname)
 +{
 +	return of_property_read_string_helper(np, propname, NULL, 0, 0);
 +}
 +
 +/**
 + * of_property_read_string_index() - Find and read a string from a multiple
 + * strings property.
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @index:	index of the string in the list of strings
 + * @out_string:	pointer to null terminated return string, modified only if
 + *		return value is 0.
 + *
 + * Search for a property in a device tree node and retrieve a null
 + * terminated string value (pointer to data, not a copy) in the list of strings
 + * contained in that property.
 + * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
 + * property does not have a value, and -EILSEQ if the string is not
 + * null-terminated within the length of the property data.
 + *
 + * The out_string pointer is modified only if a valid string can be decoded.
 + */
 +static inline int of_property_read_string_index(struct device_node *np,
 +						const char *propname,
 +						int index, const char **output)
 +{
 +	int rc = of_property_read_string_helper(np, propname, output, 1, index);
 +	return rc < 0 ? rc : 0;
 +}
 +
 +/**
 + * of_property_count_u8_elems - Count the number of u8 elements in a property
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + *
 + * Search for a property in a device node and count the number of u8 elements
 + * in it. Returns number of elements on sucess, -EINVAL if the property does
 + * not exist or its length does not match a multiple of u8 and -ENODATA if the
 + * property does not have a value.
 + */
 +static inline int of_property_count_u8_elems(const struct device_node *np,
 +				const char *propname)
 +{
 +	return of_property_count_elems_of_size(np, propname, sizeof(u8));
 +}
 +
 +/**
 + * of_property_count_u16_elems - Count the number of u16 elements in a property
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + *
 + * Search for a property in a device node and count the number of u16 elements
 + * in it. Returns number of elements on sucess, -EINVAL if the property does
 + * not exist or its length does not match a multiple of u16 and -ENODATA if the
 + * property does not have a value.
 + */
 +static inline int of_property_count_u16_elems(const struct device_node *np,
 +				const char *propname)
 +{
 +	return of_property_count_elems_of_size(np, propname, sizeof(u16));
 +}
 +
 +/**
 + * of_property_count_u32_elems - Count the number of u32 elements in a property
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + *
 + * Search for a property in a device node and count the number of u32 elements
 + * in it. Returns number of elements on sucess, -EINVAL if the property does
 + * not exist or its length does not match a multiple of u32 and -ENODATA if the
 + * property does not have a value.
 + */
 +static inline int of_property_count_u32_elems(const struct device_node *np,
 +				const char *propname)
 +{
 +	return of_property_count_elems_of_size(np, propname, sizeof(u32));
 +}
 +
 +/**
 + * of_property_count_u64_elems - Count the number of u64 elements in a property
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + *
 + * Search for a property in a device node and count the number of u64 elements
 + * in it. Returns number of elements on sucess, -EINVAL if the property does
 + * not exist or its length does not match a multiple of u64 and -ENODATA if the
 + * property does not have a value.
 + */
 +static inline int of_property_count_u64_elems(const struct device_node *np,
 +				const char *propname)
 +{
 +	return of_property_count_elems_of_size(np, propname, sizeof(u64));
 +}
 +
  /**
   * of_property_read_bool - Findfrom a property
   * @np:		device node from which the property value is to be read.
@@@ -764,54 -556,17 +761,68 @@@ static inline int of_property_read_u32(
  	return of_property_read_u32_array(np, propname, out_value, 1);
  }
  
++<<<<<<< HEAD
 +#define for_each_node_by_name(dn, name) \
 +	for (dn = of_find_node_by_name(NULL, name); dn; \
 +	     dn = of_find_node_by_name(dn, name))
 +#define for_each_node_by_type(dn, type) \
 +	for (dn = of_find_node_by_type(NULL, type); dn; \
 +	     dn = of_find_node_by_type(dn, type))
 +#define for_each_compatible_node(dn, type, compatible) \
 +	for (dn = of_find_compatible_node(NULL, type, compatible); dn; \
 +	     dn = of_find_compatible_node(dn, type, compatible))
 +#define for_each_matching_node(dn, matches) \
 +	for (dn = of_find_matching_node(NULL, matches); dn; \
 +	     dn = of_find_matching_node(dn, matches))
 +#define for_each_matching_node_and_match(dn, matches, match) \
 +	for (dn = of_find_matching_node_and_match(NULL, matches, match); \
 +	     dn; dn = of_find_matching_node_and_match(dn, matches, match))
 +
 +#define for_each_child_of_node(parent, child) \
 +	for (child = of_get_next_child(parent, NULL); child != NULL; \
 +	     child = of_get_next_child(parent, child))
 +#define for_each_available_child_of_node(parent, child) \
 +	for (child = of_get_next_available_child(parent, NULL); child != NULL; \
 +	     child = of_get_next_available_child(parent, child))
 +
 +#define for_each_node_with_property(dn, prop_name) \
 +	for (dn = of_find_node_with_property(NULL, prop_name); dn; \
 +	     dn = of_find_node_with_property(dn, prop_name))
 +
 +static inline int of_get_child_count(const struct device_node *np)
 +{
 +	struct device_node *child;
 +	int num = 0;
 +
 +	for_each_child_of_node(np, child)
 +		num++;
 +
 +	return num;
 +}
 +
 +static inline int of_get_available_child_count(const struct device_node *np)
 +{
 +	struct device_node *child;
 +	int num = 0;
 +
 +	for_each_available_child_of_node(np, child)
 +		num++;
 +
 +	return num;
 +}
++=======
+ #define of_property_for_each_u32(np, propname, prop, p, u)	\
+ 	for (prop = of_find_property(np, propname, NULL),	\
+ 		p = of_prop_next_u32(prop, NULL, &u);		\
+ 		p;						\
+ 		p = of_prop_next_u32(prop, p, &u))
+ 
+ #define of_property_for_each_string(np, propname, prop, s)	\
+ 	for (prop = of_find_property(np, propname, NULL),	\
+ 		s = of_prop_next_string(prop, NULL);		\
+ 		s;						\
+ 		s = of_prop_next_string(prop, s))
++>>>>>>> 2adfffa22350 (OF: make of_property_for_each_{u32|string}() use parameters if OF is not enabled)
  
  #if defined(CONFIG_PROC_FS) && defined(CONFIG_PROC_DEVICETREE)
  extern void proc_device_tree_add_node(struct device_node *, struct proc_dir_entry *);
* Unmerged path include/linux/of.h
