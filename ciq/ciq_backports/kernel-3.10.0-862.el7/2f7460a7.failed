drm/i915: Align vswing sequences with old ddi buffer registers.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [gpu] drm/i915: Align vswing sequences with old ddi buffer registers (Rob Clark) [1520639]
Rebuild_FUZZ: 99.20%
commit-author Rodrigo Vivi <rodrigo.vivi@intel.com>
commit 2f7460a75aa44a5cfbc9fcfa2a33b6929ecf2263
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2f7460a7.failed

Vswing sequences on BXT and CNL are equivalent
to the ddi buffer registers setting on other platforms.

For some reason it got aligned with skl_ddi_set_iboost what
is semantically incorrect. This forced us to keep skipping
ddi buffer translation tables on the platforms that has
the vswing sequences.

v2: Don't mess with DP signal levels on this patch.

	Cc: Vandana Kannan <vandana.kannan@intel.com>
	Cc: Imre Deak <imre.deak@intel.com>
	Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Cc: Ander Conselvan de Oliveira <conselvan2@gmail.com>
	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170829232230.23051-3-rodrigo.vivi@intel.com
(cherry picked from commit 2f7460a75aa44a5cfbc9fcfa2a33b6929ecf2263)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index d42007e133bd,eedd29487e0b..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -477,48 -684,29 +477,67 @@@ void intel_prepare_dp_ddi_buffers(struc
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	u32 iboost_bit = 0;
 -	int i, n_entries;
 +	int i, n_dp_entries, n_edp_entries, size;
  	enum port port = intel_ddi_get_encoder_port(encoder);
 +	const struct ddi_buf_trans *ddi_translations_fdi;
 +	const struct ddi_buf_trans *ddi_translations_dp;
 +	const struct ddi_buf_trans *ddi_translations_edp;
  	const struct ddi_buf_trans *ddi_translations;
  
++<<<<<<< HEAD
 +	if (IS_BROXTON(dev_priv))
 +		return;
 +
 +	if (IS_KABYLAKE(dev_priv)) {
 +		ddi_translations_fdi = NULL;
 +		ddi_translations_dp =
 +				kbl_get_buf_trans_dp(dev_priv, &n_dp_entries);
 +		ddi_translations_edp =
 +				skl_get_buf_trans_edp(dev_priv, &n_edp_entries);
 +	} else if (IS_SKYLAKE(dev_priv)) {
 +		ddi_translations_fdi = NULL;
 +		ddi_translations_dp =
 +				skl_get_buf_trans_dp(dev_priv, &n_dp_entries);
 +		ddi_translations_edp =
 +				skl_get_buf_trans_edp(dev_priv, &n_edp_entries);
 +	} else if (IS_BROADWELL(dev_priv)) {
 +		ddi_translations_fdi = bdw_ddi_translations_fdi;
 +		ddi_translations_dp = bdw_ddi_translations_dp;
 +		ddi_translations_edp = bdw_get_buf_trans_edp(dev_priv, &n_edp_entries);
 +		n_dp_entries = ARRAY_SIZE(bdw_ddi_translations_dp);
 +	} else if (IS_HASWELL(dev_priv)) {
 +		ddi_translations_fdi = hsw_ddi_translations_fdi;
 +		ddi_translations_dp = hsw_ddi_translations_dp;
 +		ddi_translations_edp = hsw_ddi_translations_dp;
 +		n_dp_entries = n_edp_entries = ARRAY_SIZE(hsw_ddi_translations_dp);
 +	} else {
 +		WARN(1, "ddi translation table missing\n");
 +		ddi_translations_edp = bdw_ddi_translations_dp;
 +		ddi_translations_fdi = bdw_ddi_translations_fdi;
 +		ddi_translations_dp = bdw_ddi_translations_dp;
 +		n_edp_entries = ARRAY_SIZE(bdw_ddi_translations_edp);
 +		n_dp_entries = ARRAY_SIZE(bdw_ddi_translations_dp);
++=======
+ 	switch (encoder->type) {
+ 	case INTEL_OUTPUT_EDP:
+ 		ddi_translations = intel_ddi_get_buf_trans_edp(dev_priv,
+ 							       &n_entries);
+ 		break;
+ 	case INTEL_OUTPUT_DP:
+ 		ddi_translations = intel_ddi_get_buf_trans_dp(dev_priv,
+ 							      &n_entries);
+ 		break;
+ 	case INTEL_OUTPUT_ANALOG:
+ 		ddi_translations = intel_ddi_get_buf_trans_fdi(dev_priv,
+ 							       &n_entries);
+ 		break;
+ 	default:
+ 		MISSING_CASE(encoder->type);
+ 		return;
++>>>>>>> 2f7460a75aa4 (drm/i915: Align vswing sequences with old ddi buffer registers.)
  	}
  
 -	if (IS_GEN9_BC(dev_priv)) {
 +	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
  		/* If we're boosting the current, set bit 31 of trans1 */
  		if (dev_priv->vbt.ddi_port_info[port].dp_boost_level)
  			iboost_bit = DDI_BUF_BALANCE_LEG_ENABLE;
@@@ -567,12 -738,9 +586,15 @@@ static void intel_prepare_hdmi_ddi_buff
  	enum port port = intel_ddi_get_encoder_port(encoder);
  	const struct ddi_buf_trans *ddi_translations_hdmi;
  
++<<<<<<< HEAD
 +	if (IS_BROXTON(dev_priv))
 +		return;
 +
++=======
++>>>>>>> 2f7460a75aa4 (drm/i915: Align vswing sequences with old ddi buffer registers.)
  	hdmi_level = intel_ddi_hdmi_level(dev_priv, port);
  
 -	if (IS_GEN9_BC(dev_priv)) {
 +	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {
  		ddi_translations_hdmi = skl_get_buf_trans_hdmi(dev_priv, &n_hdmi_entries);
  
  		/* If we're boosting the current, set bit 31 of trans1 */
@@@ -1695,7 -2145,12 +1717,16 @@@ static void intel_ddi_pre_enable_dp(str
  		intel_edp_panel_on(intel_dp);
  
  	intel_ddi_clk_select(encoder, pll);
++<<<<<<< HEAD
 +	intel_prepare_dp_ddi_buffers(encoder);
++=======
+ 
+ 	intel_display_power_get(dev_priv, dig_port->ddi_io_power_domain);
+ 
+ 	if (!IS_GEN9_LP(dev_priv) && !IS_CANNONLAKE(dev_priv))
+ 		intel_prepare_dp_ddi_buffers(encoder);
+ 
++>>>>>>> 2f7460a75aa4 (drm/i915: Align vswing sequences with old ddi buffer registers.)
  	intel_ddi_init_dp_buf_reg(encoder);
  	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
  	intel_dp_start_link_train(intel_dp);
@@@ -1716,32 -2172,38 +1747,48 @@@ static void intel_ddi_pre_enable_hdmi(s
  
  	intel_dp_dual_mode_set_tmds_output(intel_hdmi, true);
  	intel_ddi_clk_select(encoder, pll);
++<<<<<<< HEAD
 +	intel_prepare_hdmi_ddi_buffers(encoder);
 +	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
 +		skl_ddi_set_iboost(encoder, level);
 +	else if (IS_BROXTON(dev_priv))
 +		bxt_ddi_vswing_sequence(dev_priv, level, port,
 +					INTEL_OUTPUT_HDMI);
++=======
+ 
+ 	intel_display_power_get(dev_priv, dig_port->ddi_io_power_domain);
+ 
+ 	if (IS_CANNONLAKE(dev_priv))
+ 		cnl_ddi_vswing_sequence(encoder, level);
+ 	else if (IS_GEN9_LP(dev_priv))
+ 		bxt_ddi_vswing_sequence(dev_priv, level, port,
+ 					INTEL_OUTPUT_HDMI);
+ 	else
+ 		intel_prepare_hdmi_ddi_buffers(encoder);
+ 
+ 	if (IS_GEN9_BC(dev_priv))
+ 		skl_ddi_set_iboost(encoder, level);
++>>>>>>> 2f7460a75aa4 (drm/i915: Align vswing sequences with old ddi buffer registers.)
  
 -	intel_dig_port->set_infoframes(&encoder->base,
 -				       has_infoframe,
 -				       crtc_state, conn_state);
 +	intel_hdmi->set_infoframes(drm_encoder,
 +				   has_hdmi_sink,
 +				   adjusted_mode);
  }
  
 -static void intel_ddi_pre_enable(struct intel_encoder *encoder,
 -				 const struct intel_crtc_state *pipe_config,
 -				 const struct drm_connector_state *conn_state)
 +static void intel_ddi_pre_enable(struct intel_encoder *intel_encoder,
 +				 struct intel_crtc_state *pipe_config,
 +				 struct drm_connector_state *conn_state)
  {
 -	int type = encoder->type;
 +	struct drm_encoder *encoder = &intel_encoder->base;
 +	struct intel_crtc *crtc = to_intel_crtc(encoder->crtc);
 +	int type = intel_encoder->type;
  
  	if (type == INTEL_OUTPUT_DP || type == INTEL_OUTPUT_EDP) {
 -		intel_ddi_pre_enable_dp(encoder,
 -					pipe_config->port_clock,
 -					pipe_config->lane_count,
 -					pipe_config->shared_dpll,
 -					intel_crtc_has_type(pipe_config,
 +		intel_ddi_pre_enable_dp(intel_encoder,
 +					crtc->config->port_clock,
 +					crtc->config->lane_count,
 +					crtc->config->shared_dpll,
 +					intel_crtc_has_type(crtc->config,
  							    INTEL_OUTPUT_DP_MST));
  	}
  	if (type == INTEL_OUTPUT_HDMI) {
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
