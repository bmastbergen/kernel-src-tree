scsi_dh_alua: Use separate alua_port_group structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit 43394c67f8d6bb2f452ac25332ca0b271b344d81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/43394c67.failed

The port group needs to be a separate structure as several
LUNs might belong to the same group.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ewan Milne <emilne@redhat.com>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 43394c67f8d6bb2f452ac25332ca0b271b344d81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,e9fb76000750..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -64,18 -64,24 +64,32 @@@
  #define ALUA_OPTIMIZE_STPG		1
  #define ALUA_RTPG_EXT_HDR_UNSUPP	2
  
++<<<<<<< HEAD
 +struct alua_dh_data {
 +	struct scsi_dh_data	dh_data;
++=======
+ static LIST_HEAD(port_group_list);
+ static DEFINE_SPINLOCK(port_group_lock);
+ 
+ struct alua_port_group {
+ 	struct kref		kref;
+ 	struct list_head	node;
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  	int			group_id;
- 	int			rel_port;
  	int			tpgs;
  	int			state;
  	int			pref;
  	unsigned		flags; /* used for optimizing STPG */
 +	unsigned char		inq[ALUA_INQUIRY_SIZE];
 +	unsigned char		*buff;
 +	int			bufflen;
  	unsigned char		transition_tmo;
+ };
+ 
+ struct alua_dh_data {
+ 	struct alua_port_group	*pg;
+ 	int			group_id;
+ 	int			rel_port;
  	struct scsi_device	*sdev;
  	activate_complete	callback_fn;
  	void			*callback_data;
@@@ -86,24 -92,15 +100,36 @@@
  
  static char print_alua_state(int);
  
++<<<<<<< HEAD
 +static inline struct alua_dh_data *get_alua_data(struct scsi_device *sdev)
 +{
 +	return container_of(sdev->scsi_dh_data, struct alua_dh_data, dh_data);
 +}
 +
 +static int realloc_buffer(struct alua_dh_data *h, unsigned len)
 +{
 +	if (h->buff && h->buff != h->inq)
 +		kfree(h->buff);
 +
 +	h->buff = kmalloc(len, GFP_NOIO);
 +	if (!h->buff) {
 +		h->buff = h->inq;
 +		h->bufflen = ALUA_INQUIRY_SIZE;
 +		return 1;
 +	}
 +	h->bufflen = len;
 +	return 0;
++=======
+ static void release_port_group(struct kref *kref)
+ {
+ 	struct alua_port_group *pg;
+ 
+ 	pg = container_of(kref, struct alua_port_group, kref);
+ 	spin_lock(&port_group_lock);
+ 	list_del(&pg->node);
+ 	spin_unlock(&port_group_lock);
+ 	kfree(pg);
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  }
  
  /*
@@@ -336,23 -361,27 +390,27 @@@ static int alua_check_sense(struct scsi
   * Returns SCSI_DH_DEV_OFFLINED if the path is
   * found to be unusable.
   */
- static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h, int wait_for_transition)
+ static int alua_rtpg(struct scsi_device *sdev, struct alua_port_group *pg, int wait_for_transition)
  {
  	struct scsi_sense_hdr sense_hdr;
 -	int len, k, off, valid_states = 0, bufflen = ALUA_RTPG_SIZE;
 -	unsigned char *ucp, *buff;
 +	int len, k, off, valid_states = 0;
 +	unsigned char *ucp;
  	unsigned err, retval;
  	unsigned long expiry, interval = 0;
  	unsigned int tpg_desc_tbl_off;
  	unsigned char orig_transition_tmo;
  
- 	if (!h->transition_tmo)
+ 	if (!pg->transition_tmo)
  		expiry = round_jiffies_up(jiffies + ALUA_FAILOVER_TIMEOUT * HZ);
  	else
- 		expiry = round_jiffies_up(jiffies + h->transition_tmo * HZ);
+ 		expiry = round_jiffies_up(jiffies + pg->transition_tmo * HZ);
  
 -	buff = kzalloc(bufflen, GFP_KERNEL);
 -	if (!buff)
 -		return SCSI_DH_DEV_TEMP_BUSY;
 -
   retry:
++<<<<<<< HEAD
 +	retval = submit_rtpg(sdev, h->buff, h->bufflen, &sense_hdr, h->flags);
++=======
+ 	retval = submit_rtpg(sdev, buff, bufflen, &sense_hdr, pg->flags);
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  
  	if (retval) {
  		if (!scsi_sense_valid(&sense_hdr)) {
@@@ -412,20 -446,21 +470,31 @@@
  		goto retry;
  	}
  
++<<<<<<< HEAD
 +	orig_transition_tmo = h->transition_tmo;
 +	if ((h->buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && h->buff[5] != 0)
 +		h->transition_tmo = h->buff[5];
++=======
+ 	orig_transition_tmo = pg->transition_tmo;
+ 	if ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && buff[5] != 0)
+ 		pg->transition_tmo = buff[5];
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  	else
- 		h->transition_tmo = ALUA_FAILOVER_TIMEOUT;
+ 		pg->transition_tmo = ALUA_FAILOVER_TIMEOUT;
  
++<<<<<<< HEAD
 +	if (wait_for_transition && (orig_transition_tmo != h->transition_tmo)) {
++=======
+ 	if (wait_for_transition &&
+ 	    (orig_transition_tmo != pg->transition_tmo)) {
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  		sdev_printk(KERN_INFO, sdev,
  			    "%s: transition timeout set to %d seconds\n",
- 			    ALUA_DH_NAME, h->transition_tmo);
- 		expiry = jiffies + h->transition_tmo * HZ;
+ 			    ALUA_DH_NAME, pg->transition_tmo);
+ 		expiry = jiffies + pg->transition_tmo * HZ;
  	}
  
 -	if ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)
 +	if ((h->buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)
  		tpg_desc_tbl_off = 8;
  	else
  		tpg_desc_tbl_off = 4;
@@@ -578,7 -618,8 +651,12 @@@ out
   */
  static int alua_set_params(struct scsi_device *sdev, const char *params)
  {
++<<<<<<< HEAD
 +	struct alua_dh_data *h = get_alua_data(sdev);
++=======
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 	struct alua_port_group *pg = NULL;
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  	unsigned int optimize = 0, argc;
  	const char *p = params;
  	int result = SCSI_DH_OK;
@@@ -616,19 -661,26 +698,26 @@@ MODULE_PARM_DESC(optimize_stpg, "Allow 
  static int alua_activate(struct scsi_device *sdev,
  			activate_complete fn, void *data)
  {
 -	struct alua_dh_data *h = sdev->handler_data;
 +	struct alua_dh_data *h = get_alua_data(sdev);
  	int err = SCSI_DH_OK;
  
- 	err = alua_rtpg(sdev, h, 1);
- 	if (err != SCSI_DH_OK)
+ 	if (!h->pg)
  		goto out;
  
+ 	kref_get(&h->pg->kref);
+ 
  	if (optimize_stpg)
- 		h->flags |= ALUA_OPTIMIZE_STPG;
+ 		h->pg->flags |= ALUA_OPTIMIZE_STPG;
  
- 	err = alua_stpg(sdev, h);
+ 	err = alua_rtpg(sdev, h->pg, 1);
+ 	if (err != SCSI_DH_OK) {
+ 		kref_put(&h->pg->kref, release_port_group);
+ 		goto out;
+ 	}
+ 	err = alua_stpg(sdev, h->pg);
  	if (err == SCSI_DH_RETRY)
- 		err = alua_rtpg(sdev, h, 1);
+ 		err = alua_rtpg(sdev, h->pg, 1);
+ 	kref_put(&h->pg->kref, release_port_group);
  out:
  	if (fn)
  		fn(data, err);
@@@ -643,14 -695,20 +732,24 @@@
   */
  static int alua_prep_fn(struct scsi_device *sdev, struct request *req)
  {
++<<<<<<< HEAD
 +	struct alua_dh_data *h = get_alua_data(sdev);
++=======
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 	int state;
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  	int ret = BLKPREP_OK;
  
- 	if (h->state == TPGS_STATE_TRANSITIONING)
+ 	if (!h->pg)
+ 		return ret;
+ 	kref_get(&h->pg->kref);
+ 	state = h->pg->state;
+ 	kref_put(&h->pg->kref, release_port_group);
+ 	if (state == TPGS_STATE_TRANSITIONING)
  		ret = BLKPREP_DEFER;
- 	else if (h->state != TPGS_STATE_OPTIMIZED &&
- 		 h->state != TPGS_STATE_NONOPTIMIZED &&
- 		 h->state != TPGS_STATE_LBA_DEPENDENT) {
+ 	else if (state != TPGS_STATE_OPTIMIZED &&
+ 		 state != TPGS_STATE_NONOPTIMIZED &&
+ 		 state != TPGS_STATE_LBA_DEPENDENT) {
  		ret = BLKPREP_KILL;
  		req->cmd_flags |= REQ_QUIET;
  	}
@@@ -658,13 -716,50 +757,54 @@@
  
  }
  
 -/*
 - * alua_bus_attach - Attach device handler
 - * @sdev: device to be attached to
 - */
 -static int alua_bus_attach(struct scsi_device *sdev)
 +static bool alua_match(struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	return (scsi_device_tpgs(sdev) != 0);
 +}
 +
 +static int alua_bus_attach(struct scsi_device *sdev);
 +static void alua_bus_detach(struct scsi_device *sdev);
++=======
+ 	struct alua_dh_data *h;
+ 	int err, ret = -EINVAL;
+ 
+ 	h = kzalloc(sizeof(*h) , GFP_KERNEL);
+ 	if (!h)
+ 		return -ENOMEM;
+ 	h->pg = NULL;
+ 	h->rel_port = -1;
+ 	h->sdev = sdev;
+ 
+ 	err = alua_initialize(sdev, h);
+ 	if (err == SCSI_DH_NOMEM)
+ 		ret = -ENOMEM;
+ 	if (err != SCSI_DH_OK && err != SCSI_DH_DEV_OFFLINED)
+ 		goto failed;
+ 
+ 	sdev->handler_data = h;
+ 	return 0;
+ failed:
+ 	kfree(h);
+ 	return ret;
+ }
+ 
+ /*
+  * alua_bus_detach - Detach device handler
+  * @sdev: device to be detached from
+  */
+ static void alua_bus_detach(struct scsi_device *sdev)
+ {
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 
+ 	if (h->pg) {
+ 		kref_put(&h->pg->kref, release_port_group);
+ 		h->pg = NULL;
+ 	}
+ 	sdev->handler_data = NULL;
+ 	kfree(h);
+ }
++>>>>>>> 43394c67f8d6 (scsi_dh_alua: Use separate alua_port_group structure)
  
  static struct scsi_device_handler alua_dh = {
  	.name = ALUA_DH_NAME,
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
diff --git a/include/scsi/scsi_dh.h b/include/scsi/scsi_dh.h
index 620c723ee8ed..b15fd28a04c9 100644
--- a/include/scsi/scsi_dh.h
+++ b/include/scsi/scsi_dh.h
@@ -52,6 +52,7 @@ enum {
 	SCSI_DH_TIMED_OUT,
 	SCSI_DH_RES_TEMP_UNAVAIL,
 	SCSI_DH_DEV_OFFLINED,
+	SCSI_DH_NOMEM,
 	SCSI_DH_NOSYS,
 	SCSI_DH_DRIVER_MAX,
 };
