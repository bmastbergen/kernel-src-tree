acpi, nfit: add support for the _LSI, _LSR, and _LSW label methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 4b27db7e26cdb9deb4a211e963e2993fde0110cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4b27db7e.failed

ACPI 6.2 adds support for named methods to access the label storage area
of an NVDIMM. We prefer these new methods if available and otherwise
fallback to the NVDIMM_FAMILY_INTEL _DSMs. The kernel ioctls,
ND_IOCTL_{GET,SET}_CONFIG_{SIZE,DATA}, remain generic and the driver
translates the 'package' payloads into the NVDIMM_FAMILY_INTEL 'buffer'
format to maintain compatibility with existing userspace and keep the
output buffer parsing code in the driver common.

The output payloads are mostly compatible save for the 'label area
locked' status that moves from the 'config_size' (_LSI) command to the
'config_read' (_LSR) command status.

	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 4b27db7e26cdb9deb4a211e963e2993fde0110cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index 95a335d63b99,ebe0857ac346..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -295,7 -456,21 +457,25 @@@ int acpi_nfit_ctl(struct nvdimm_bus_des
  			in_buf.buffer.pointer,
  			min_t(u32, 256, in_buf.buffer.length), true);
  
++<<<<<<< HEAD
 +	out_obj = acpi_evaluate_dsm(handle, uuid, 1, func, &in_obj);
++=======
+ 	/* call the BIOS, prefer the named methods over _DSM if available */
+ 	if (cmd == ND_CMD_GET_CONFIG_SIZE && nfit_mem->has_lsi)
+ 		out_obj = acpi_label_info(handle);
+ 	else if (cmd == ND_CMD_GET_CONFIG_DATA && nfit_mem->has_lsr) {
+ 		struct nd_cmd_get_config_data_hdr *p = buf;
+ 
+ 		out_obj = acpi_label_read(handle, p->in_offset, p->in_length);
+ 	} else if (cmd == ND_CMD_SET_CONFIG_DATA && nfit_mem->has_lsw) {
+ 		struct nd_cmd_set_config_hdr *p = buf;
+ 
+ 		out_obj = acpi_label_write(handle, p->in_offset, p->in_length,
+ 				p->in_buf);
+ 	} else
+ 		out_obj = acpi_evaluate_dsm(handle, guid, 1, func, &in_obj);
+ 
++>>>>>>> 4b27db7e26cd (acpi, nfit: add support for the _LSI, _LSR, and _LSW label methods)
  	if (!out_obj) {
  		dev_dbg(dev, "%s:%s _DSM failed cmd: %s\n", __func__, dimm_name,
  				cmd_name);
@@@ -1432,8 -1607,9 +1612,9 @@@ static int acpi_nfit_add_dimm(struct ac
  {
  	struct acpi_device *adev, *adev_dimm;
  	struct device *dev = acpi_desc->dev;
+ 	union acpi_object *obj;
  	unsigned long dsm_mask;
 -	const guid_t *guid;
 +	const u8 *uuid;
  	int i;
  	int family = -1;
  
@@@ -1492,11 -1668,32 +1673,32 @@@
  		return 0;
  	}
  
 -	guid = to_nfit_uuid(nfit_mem->family);
 +	uuid = to_nfit_uuid(nfit_mem->family);
  	for_each_set_bit(i, &dsm_mask, BITS_PER_LONG)
 -		if (acpi_check_dsm(adev_dimm->handle, guid, 1, 1ULL << i))
 +		if (acpi_check_dsm(adev_dimm->handle, uuid, 1, 1ULL << i))
  			set_bit(i, &nfit_mem->dsm_mask);
  
+ 	obj = acpi_label_info(adev_dimm->handle);
+ 	if (obj) {
+ 		ACPI_FREE(obj);
+ 		nfit_mem->has_lsi = 1;
+ 		dev_dbg(dev, "%s: has _LSI\n", dev_name(&adev_dimm->dev));
+ 	}
+ 
+ 	obj = acpi_label_read(adev_dimm->handle, 0, 0);
+ 	if (obj) {
+ 		ACPI_FREE(obj);
+ 		nfit_mem->has_lsr = 1;
+ 		dev_dbg(dev, "%s: has _LSR\n", dev_name(&adev_dimm->dev));
+ 	}
+ 
+ 	obj = acpi_label_write(adev_dimm->handle, 0, 0, NULL);
+ 	if (obj) {
+ 		ACPI_FREE(obj);
+ 		nfit_mem->has_lsw = 1;
+ 		dev_dbg(dev, "%s: has _LSW\n", dev_name(&adev_dimm->dev));
+ 	}
+ 
  	return 0;
  }
  
* Unmerged path drivers/acpi/nfit/core.c
diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index f03ccb697469..99dc6fa80764 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -141,6 +141,9 @@ struct nfit_mem {
 	struct resource *flush_wpq;
 	unsigned long dsm_mask;
 	int family;
+	u32 has_lsi:1;
+	u32 has_lsr:1;
+	u32 has_lsw:1;
 };
 
 struct acpi_nfit_desc {
diff --git a/drivers/nvdimm/dimm.c b/drivers/nvdimm/dimm.c
index e0f0e3ce1a32..862bcbd96366 100644
--- a/drivers/nvdimm/dimm.c
+++ b/drivers/nvdimm/dimm.c
@@ -55,6 +55,8 @@ static int nvdimm_probe(struct device *dev)
 		goto err;
 
 	rc = nvdimm_init_config_data(ndd);
+	if (rc == -EACCES)
+		nvdimm_set_locked(dev);
 	if (rc)
 		goto err;
 
