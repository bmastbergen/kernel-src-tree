nvme: add duplicate_connect option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] add duplicate_connect option (Ewan Milne) [1508065]
Rebuild_FUZZ: 90.32%
commit-author James Smart <jsmart2021@gmail.com>
commit 3b3387620780fc9699021c85bdce5cb45a763d41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3b338762.failed

Add the "duplicate_connect" boolean option (presence means true).
Default is false.

When false, the transport should validate whether a new controller request
is targeted for the same host transport addressing and target transport
addressing as an existing controller. If so, the new controller request
should be rejected.

When true, the callee is explicitly requesting a duplicate controller
connection to be made and the new request should be attempted.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 3b3387620780fc9699021c85bdce5cb45a763d41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fabrics.c
#	drivers/nvme/host/fabrics.h
diff --cc drivers/nvme/host/fabrics.c
index ce43cf05bc46,4a83137b0268..000000000000
--- a/drivers/nvme/host/fabrics.c
+++ b/drivers/nvme/host/fabrics.c
@@@ -559,6 -547,8 +559,11 @@@ static const match_table_t opt_tokens 
  	{ NVMF_OPT_KATO,		"keep_alive_tmo=%d"	},
  	{ NVMF_OPT_HOSTNQN,		"hostnqn=%s"		},
  	{ NVMF_OPT_HOST_TRADDR,		"host_traddr=%s"	},
++<<<<<<< HEAD
++=======
+ 	{ NVMF_OPT_HOST_ID,		"hostid=%s"		},
+ 	{ NVMF_OPT_DUP_CONNECT,		"duplicate_connect"	},
++>>>>>>> 3b3387620780 (nvme: add duplicate_connect option)
  	{ NVMF_OPT_ERR,			NULL			}
  };
  
@@@ -575,6 -566,8 +580,11 @@@ static int nvmf_parse_options(struct nv
  	opts->queue_size = NVMF_DEF_QUEUE_SIZE;
  	opts->nr_io_queues = num_online_cpus();
  	opts->reconnect_delay = NVMF_DEF_RECONNECT_DELAY;
++<<<<<<< HEAD
++=======
+ 	opts->kato = NVME_DEFAULT_KATO;
+ 	opts->duplicate_connect = false;
++>>>>>>> 3b3387620780 (nvme: add duplicate_connect option)
  
  	options = o = kstrdup(buf, GFP_KERNEL);
  	if (!options)
@@@ -736,6 -732,21 +746,24 @@@
  			}
  			opts->host_traddr = p;
  			break;
++<<<<<<< HEAD
++=======
+ 		case NVMF_OPT_HOST_ID:
+ 			p = match_strdup(args);
+ 			if (!p) {
+ 				ret = -ENOMEM;
+ 				goto out;
+ 			}
+ 			if (uuid_parse(p, &hostid)) {
+ 				pr_err("Invalid hostid %s\n", p);
+ 				ret = -EINVAL;
+ 				goto out;
+ 			}
+ 			break;
+ 		case NVMF_OPT_DUP_CONNECT:
+ 			opts->duplicate_connect = true;
+ 			break;
++>>>>>>> 3b3387620780 (nvme: add duplicate_connect option)
  		default:
  			pr_warn("unknown parameter or missing value '%s' in ctrl creation request\n",
  				p);
@@@ -816,7 -827,8 +844,12 @@@ EXPORT_SYMBOL_GPL(nvmf_free_options)
  
  #define NVMF_REQUIRED_OPTS	(NVMF_OPT_TRANSPORT | NVMF_OPT_NQN)
  #define NVMF_ALLOWED_OPTS	(NVMF_OPT_QUEUE_SIZE | NVMF_OPT_NR_IO_QUEUES | \
++<<<<<<< HEAD
 +				 NVMF_OPT_KATO | NVMF_OPT_HOSTNQN)
++=======
+ 				 NVMF_OPT_KATO | NVMF_OPT_HOSTNQN | \
+ 				 NVMF_OPT_HOST_ID | NVMF_OPT_DUP_CONNECT)
++>>>>>>> 3b3387620780 (nvme: add duplicate_connect option)
  
  static struct nvme_ctrl *
  nvmf_create_ctrl(struct device *dev, const char *buf, size_t count)
diff --cc drivers/nvme/host/fabrics.h
index f5a9c1fb186f,a7590cc59ba2..000000000000
--- a/drivers/nvme/host/fabrics.h
+++ b/drivers/nvme/host/fabrics.h
@@@ -56,6 -56,8 +56,11 @@@ enum 
  	NVMF_OPT_RECONNECT_DELAY = 1 << 9,
  	NVMF_OPT_HOST_TRADDR	= 1 << 10,
  	NVMF_OPT_CTRL_LOSS_TMO	= 1 << 11,
++<<<<<<< HEAD
++=======
+ 	NVMF_OPT_HOST_ID	= 1 << 12,
+ 	NVMF_OPT_DUP_CONNECT	= 1 << 13,
++>>>>>>> 3b3387620780 (nvme: add duplicate_connect option)
  };
  
  /**
@@@ -96,9 -97,9 +101,10 @@@ struct nvmf_ctrl_options 
  	unsigned int		nr_io_queues;
  	unsigned int		reconnect_delay;
  	bool			discovery_nqn;
+ 	bool			duplicate_connect;
  	unsigned int		kato;
  	struct nvmf_host	*host;
 +	int			nr_reconnects;
  	int			max_reconnects;
  };
  
* Unmerged path drivers/nvme/host/fabrics.c
* Unmerged path drivers/nvme/host/fabrics.h
