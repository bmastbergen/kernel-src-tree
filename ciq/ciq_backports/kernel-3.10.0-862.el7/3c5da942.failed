qed: Share additional information with qedf

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 3c5da94278026a4583320f97f6547573fb3a93aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3c5da942.failed

Share several new tidbits with qedf:
 - wwpn & wwnn
 - Absolute pf-id [this one is actually meant for qedi as well]
 - Number of available CQs

While we're at it, now that qedf will be aware of the available CQs
we can add some validation on the inputs it provides.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3c5da94278026a4583320f97f6547573fb3a93aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
#	include/linux/qed/qed_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index 2707a33de744,2d88d4883483..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -1558,84 -2050,160 +1558,105 @@@ static void qed_hw_set_feat(struct qed_
  		 * the status blocks equally between L2 / RoCE but with
  		 * consideration as to how many l2 queues / cnqs we have.
  		 */
 +		num_features++;
 +
  		feat_num[QED_RDMA_CNQ] =
 -			min_t(u32, sb_cnt.cnt / 2,
 +			min_t(u32, RESC_NUM(p_hwfn, QED_SB) / num_features,
  			      RESC_NUM(p_hwfn, QED_RDMA_CNQ_RAM));
 -
 -		non_l2_sbs = feat_num[QED_RDMA_CNQ];
  	}
  
 -	if (p_hwfn->hw_info.personality == QED_PCI_ETH_ROCE ||
 -	    p_hwfn->hw_info.personality == QED_PCI_ETH) {
 -		/* Start by allocating VF queues, then PF's */
 -		feat_num[QED_VF_L2_QUE] = min_t(u32,
 -						RESC_NUM(p_hwfn, QED_L2_QUEUE),
 -						sb_cnt.iov_cnt);
 -		feat_num[QED_PF_L2_QUE] = min_t(u32,
 -						sb_cnt.cnt - non_l2_sbs,
 -						RESC_NUM(p_hwfn,
 -							 QED_L2_QUEUE) -
 -						FEAT_NUM(p_hwfn,
 -							 QED_VF_L2_QUE));
 -	}
 +	feat_num[QED_PF_L2_QUE] = min_t(u32, RESC_NUM(p_hwfn, QED_SB) /
 +						num_features,
 +					RESC_NUM(p_hwfn, QED_L2_QUEUE));
  
 +	memset(&sb_cnt_info, 0, sizeof(sb_cnt_info));
 +	qed_int_get_num_sbs(p_hwfn, &sb_cnt_info);
 +	feat_num[QED_VF_L2_QUE] =
 +	    min_t(u32,
 +		  RESC_NUM(p_hwfn, QED_L2_QUEUE) -
 +		  FEAT_NUM(p_hwfn, QED_PF_L2_QUE), sb_cnt_info.sb_iov_cnt);
 +
++<<<<<<< HEAD
 +	DP_VERBOSE(p_hwfn,
 +		   NETIF_MSG_PROBE,
 +		   "#PF_L2_QUEUES=%d VF_L2_QUEUES=%d #ROCE_CNQ=%d #SBS=%d num_features=%d\n",
 +		   (int)FEAT_NUM(p_hwfn, QED_PF_L2_QUE),
 +		   (int)FEAT_NUM(p_hwfn, QED_VF_L2_QUE),
 +		   (int)FEAT_NUM(p_hwfn, QED_RDMA_CNQ),
 +		   RESC_NUM(p_hwfn, QED_SB), num_features);
++=======
+ 	if (p_hwfn->hw_info.personality == QED_PCI_FCOE)
+ 		feat_num[QED_FCOE_CQ] =  min_t(u32, sb_cnt.cnt,
+ 					       RESC_NUM(p_hwfn,
+ 							QED_CMDQS_CQS));
+ 
+ 	if (p_hwfn->hw_info.personality == QED_PCI_ISCSI)
+ 		feat_num[QED_ISCSI_CQ] = min_t(u32, sb_cnt.cnt,
+ 					       RESC_NUM(p_hwfn,
+ 							QED_CMDQS_CQS));
+ 	DP_VERBOSE(p_hwfn,
+ 		   NETIF_MSG_PROBE,
+ 		   "#PF_L2_QUEUES=%d VF_L2_QUEUES=%d #ROCE_CNQ=%d FCOE_CQ=%d ISCSI_CQ=%d #SBS=%d\n",
+ 		   (int)FEAT_NUM(p_hwfn, QED_PF_L2_QUE),
+ 		   (int)FEAT_NUM(p_hwfn, QED_VF_L2_QUE),
+ 		   (int)FEAT_NUM(p_hwfn, QED_RDMA_CNQ),
+ 		   (int)FEAT_NUM(p_hwfn, QED_FCOE_CQ),
+ 		   (int)FEAT_NUM(p_hwfn, QED_ISCSI_CQ),
+ 		   (int)sb_cnt.cnt);
++>>>>>>> 3c5da9427802 (qed: Share additional information with qedf)
  }
  
 -const char *qed_hw_get_resc_name(enum qed_resources res_id)
 +static enum resource_id_enum qed_hw_get_mfw_res_id(enum qed_resources res_id)
  {
 +	enum resource_id_enum mfw_res_id = RESOURCE_NUM_INVALID;
 +
  	switch (res_id) {
 +	case QED_SB:
 +		mfw_res_id = RESOURCE_NUM_SB_E;
 +		break;
  	case QED_L2_QUEUE:
 -		return "L2_QUEUE";
 +		mfw_res_id = RESOURCE_NUM_L2_QUEUE_E;
 +		break;
  	case QED_VPORT:
 -		return "VPORT";
 +		mfw_res_id = RESOURCE_NUM_VPORT_E;
 +		break;
  	case QED_RSS_ENG:
 -		return "RSS_ENG";
 +		mfw_res_id = RESOURCE_NUM_RSS_ENGINES_E;
 +		break;
  	case QED_PQ:
 -		return "PQ";
 +		mfw_res_id = RESOURCE_NUM_PQ_E;
 +		break;
  	case QED_RL:
 -		return "RL";
 +		mfw_res_id = RESOURCE_NUM_RL_E;
 +		break;
  	case QED_MAC:
 -		return "MAC";
  	case QED_VLAN:
 -		return "VLAN";
 -	case QED_RDMA_CNQ_RAM:
 -		return "RDMA_CNQ_RAM";
 +		/* Each VFC resource can accommodate both a MAC and a VLAN */
 +		mfw_res_id = RESOURCE_VFC_FILTER_E;
 +		break;
  	case QED_ILT:
 -		return "ILT";
 +		mfw_res_id = RESOURCE_ILT_E;
 +		break;
  	case QED_LL2_QUEUE:
 -		return "LL2_QUEUE";
 +		mfw_res_id = RESOURCE_LL2_QUEUE_E;
 +		break;
 +	case QED_RDMA_CNQ_RAM:
  	case QED_CMDQS_CQS:
 -		return "CMDQS_CQS";
 +		/* CNQ/CMDQS are the same resource */
 +		mfw_res_id = RESOURCE_CQS_E;
 +		break;
  	case QED_RDMA_STATS_QUEUE:
 -		return "RDMA_STATS_QUEUE";
 -	case QED_BDQ:
 -		return "BDQ";
 -	case QED_SB:
 -		return "SB";
 +		mfw_res_id = RESOURCE_RDMA_STATS_QUEUE_E;
 +		break;
  	default:
 -		return "UNKNOWN_RESOURCE";
 -	}
 -}
 -
 -static int
 -__qed_hw_set_soft_resc_size(struct qed_hwfn *p_hwfn,
 -			    struct qed_ptt *p_ptt,
 -			    enum qed_resources res_id,
 -			    u32 resc_max_val, u32 *p_mcp_resp)
 -{
 -	int rc;
 -
 -	rc = qed_mcp_set_resc_max_val(p_hwfn, p_ptt, res_id,
 -				      resc_max_val, p_mcp_resp);
 -	if (rc) {
 -		DP_NOTICE(p_hwfn,
 -			  "MFW response failure for a max value setting of resource %d [%s]\n",
 -			  res_id, qed_hw_get_resc_name(res_id));
 -		return rc;
 -	}
 -
 -	if (*p_mcp_resp != FW_MSG_CODE_RESOURCE_ALLOC_OK)
 -		DP_INFO(p_hwfn,
 -			"Failed to set the max value of resource %d [%s]. mcp_resp = 0x%08x.\n",
 -			res_id, qed_hw_get_resc_name(res_id), *p_mcp_resp);
 -
 -	return 0;
 -}
 -
 -static int
 -qed_hw_set_soft_resc_size(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
 -{
 -	bool b_ah = QED_IS_AH(p_hwfn->cdev);
 -	u32 resc_max_val, mcp_resp;
 -	u8 res_id;
 -	int rc;
 -
 -	for (res_id = 0; res_id < QED_MAX_RESC; res_id++) {
 -		switch (res_id) {
 -		case QED_LL2_QUEUE:
 -			resc_max_val = MAX_NUM_LL2_RX_QUEUES;
 -			break;
 -		case QED_RDMA_CNQ_RAM:
 -			/* No need for a case for QED_CMDQS_CQS since
 -			 * CNQ/CMDQS are the same resource.
 -			 */
 -			resc_max_val = NUM_OF_CMDQS_CQS;
 -			break;
 -		case QED_RDMA_STATS_QUEUE:
 -			resc_max_val = b_ah ? RDMA_NUM_STATISTIC_COUNTERS_K2
 -			    : RDMA_NUM_STATISTIC_COUNTERS_BB;
 -			break;
 -		case QED_BDQ:
 -			resc_max_val = BDQ_NUM_RESOURCES;
 -			break;
 -		default:
 -			continue;
 -		}
 -
 -		rc = __qed_hw_set_soft_resc_size(p_hwfn, p_ptt, res_id,
 -						 resc_max_val, &mcp_resp);
 -		if (rc)
 -			return rc;
 -
 -		/* There's no point to continue to the next resource if the
 -		 * command is not supported by the MFW.
 -		 * We do continue if the command is supported but the resource
 -		 * is unknown to the MFW. Such a resource will be later
 -		 * configured with the default allocation values.
 -		 */
 -		if (mcp_resp == FW_MSG_CODE_UNSUPPORTED)
 -			return -EINVAL;
 +		break;
  	}
  
 -	return 0;
 +	return mfw_res_id;
  }
  
 -static
 -int qed_hw_get_dflt_resc(struct qed_hwfn *p_hwfn,
 -			 enum qed_resources res_id,
 -			 u32 *p_resc_num, u32 *p_resc_start)
 +static u32 qed_hw_get_dflt_resc_num(struct qed_hwfn *p_hwfn,
 +				    enum qed_resources res_id)
  {
  	u8 num_funcs = p_hwfn->num_funcs_on_engine;
  	bool b_ah = QED_IS_AH(p_hwfn->cdev);
diff --cc include/linux/qed/qed_if.h
index 8e0065c52857,e29c6f74a4d4..000000000000
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@@ -331,7 -345,23 +331,17 @@@ struct qed_dev_info 
  
  	bool wol_support;
  
 -	/* MBI version */
 -	u32 mbi_version;
 -#define QED_MBI_VERSION_0_MASK		0x000000FF
 -#define QED_MBI_VERSION_0_OFFSET	0
 -#define QED_MBI_VERSION_1_MASK		0x0000FF00
 -#define QED_MBI_VERSION_1_OFFSET	8
 -#define QED_MBI_VERSION_2_MASK		0x00FF0000
 -#define QED_MBI_VERSION_2_OFFSET	16
 -
  	enum qed_dev_type dev_type;
++<<<<<<< HEAD
++=======
+ 
+ 	/* Output parameters for qede */
+ 	bool		vxlan_enable;
+ 	bool		gre_enable;
+ 	bool		geneve_enable;
+ 
+ 	u8		abs_pf_id;
++>>>>>>> 3c5da9427802 (qed: Share additional information with qedf)
  };
  
  enum qed_sb_type {
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_fcoe.c b/drivers/net/ethernet/qlogic/qed/qed_fcoe.c
index cbc81412174f..47e393a8bd81 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_fcoe.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_fcoe.c
@@ -142,6 +142,15 @@ qed_sp_fcoe_func_start(struct qed_hwfn *p_hwfn,
 	p_data = &p_ramrod->init_ramrod_data;
 	fcoe_pf_params = &p_hwfn->pf_params.fcoe_pf_params;
 
+	/* Sanity */
+	if (fcoe_pf_params->num_cqs > p_hwfn->hw_info.feat_num[QED_FCOE_CQ]) {
+		DP_ERR(p_hwfn,
+		       "Cannot satisfy CQ amount. CQs requested %d, CQs available %d. Aborting function start\n",
+		       fcoe_pf_params->num_cqs,
+		       p_hwfn->hw_info.feat_num[QED_FCOE_CQ]);
+		return -EINVAL;
+	}
+
 	p_data->mtu = cpu_to_le16(fcoe_pf_params->mtu);
 	tmp = cpu_to_le16(fcoe_pf_params->sq_num_pbl_pages);
 	p_data->sq_num_pages_in_pbl = tmp;
@@ -722,6 +731,11 @@ static int qed_fill_fcoe_dev_info(struct qed_dev *cdev,
 	info->secondary_bdq_rq_addr =
 	    qed_fcoe_get_secondary_bdq_prod(hwfn, BDQ_ID_RQ);
 
+	info->wwpn = hwfn->mcp_info->func_info.wwn_port;
+	info->wwnn = hwfn->mcp_info->func_info.wwn_node;
+
+	info->num_cqs = FEAT_NUM(hwfn, QED_FCOE_CQ);
+
 	return rc;
 }
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index b513e0230d27..1003d1b4a5c3 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -252,6 +252,8 @@ int qed_fill_dev_info(struct qed_dev *cdev,
 		if (QED_LEADING_HWFN(cdev)->hw_info.b_wol_support ==
 		    QED_WOL_SUPPORT_PME)
 			dev_info->wol_support = true;
+
+		dev_info->abs_pf_id = QED_LEADING_HWFN(cdev)->abs_pf_id;
 	} else {
 		qed_vf_get_fw_version(&cdev->hwfns[0], &dev_info->fw_major,
 				      &dev_info->fw_minor, &dev_info->fw_rev,
diff --git a/include/linux/qed/qed_fcoe_if.h b/include/linux/qed/qed_fcoe_if.h
index bd6bcb809415..1e015c50e6b8 100644
--- a/include/linux/qed/qed_fcoe_if.h
+++ b/include/linux/qed/qed_fcoe_if.h
@@ -24,6 +24,11 @@ struct qed_dev_fcoe_info {
 
 	void __iomem *primary_dbq_rq_addr;
 	void __iomem *secondary_bdq_rq_addr;
+
+	u64 wwpn;
+	u64 wwnn;
+
+	u8 num_cqs;
 };
 
 struct qed_fcoe_params_offload {
* Unmerged path include/linux/qed/qed_if.h
