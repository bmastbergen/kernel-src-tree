x86/hyperv: Implement hv_get_tsc_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit bd2a9adaadb8defcaf6c284bca7ff41634105f51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bd2a9ada.failed

To use Hyper-V TSC page clocksource from vDSO we need to make tsc_pg
available. Implement hv_get_tsc_page() and add CONFIG_HYPERV_TSCPAGE to
make #ifdef-s simple.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Dexuan Cui <decui@microsoft.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: devel@linuxdriverproject.org
	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
	Cc: virtualization@lists.linux-foundation.org
Link: http://lkml.kernel.org/r/20170303132142.25595-2-vkuznets@redhat.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit bd2a9adaadb8defcaf6c284bca7ff41634105f51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,bb1ea58ecd7a..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -24,8 -24,89 +24,89 @@@
  #include <linux/version.h>
  #include <linux/vmalloc.h>
  #include <linux/mm.h>
++<<<<<<< HEAD
++=======
+ #include <linux/clockchips.h>
+ 
+ 
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ 
+ static struct ms_hyperv_tsc_page *tsc_pg;
+ 
+ struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
+ {
+ 	return tsc_pg;
+ }
+ 
+ static u64 read_hv_clock_tsc(struct clocksource *arg)
+ {
+ 	u64 current_tick;
+ 
+ 	if (tsc_pg->tsc_sequence != 0) {
+ 		/*
+ 		 * Use the tsc page to compute the value.
+ 		 */
+ 
+ 		while (1) {
+ 			u64 tmp;
+ 			u32 sequence = tsc_pg->tsc_sequence;
+ 			u64 cur_tsc;
+ 			u64 scale = tsc_pg->tsc_scale;
+ 			s64 offset = tsc_pg->tsc_offset;
+ 
+ 			rdtscll(cur_tsc);
+ 			/* current_tick = ((cur_tsc *scale) >> 64) + offset */
+ 			asm("mulq %3"
+ 				: "=d" (current_tick), "=a" (tmp)
+ 				: "a" (cur_tsc), "r" (scale));
+ 
+ 			current_tick += offset;
+ 			if (tsc_pg->tsc_sequence == sequence)
+ 				return current_tick;
+ 
+ 			if (tsc_pg->tsc_sequence != 0)
+ 				continue;
+ 			/*
+ 			 * Fallback using MSR method.
+ 			 */
+ 			break;
+ 		}
+ 	}
+ 	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+ 	return current_tick;
+ }
+ 
+ static struct clocksource hyperv_cs_tsc = {
+ 		.name		= "hyperv_clocksource_tsc_page",
+ 		.rating		= 400,
+ 		.read		= read_hv_clock_tsc,
+ 		.mask		= CLOCKSOURCE_MASK(64),
+ 		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+ };
+ #endif
+ 
+ static u64 read_hv_clock_msr(struct clocksource *arg)
+ {
+ 	u64 current_tick;
+ 	/*
+ 	 * Read the partition counter to get the current tick count. This count
+ 	 * is set to 0 when the partition is created and is incremented in
+ 	 * 100 nanosecond units.
+ 	 */
+ 	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+ 	return current_tick;
+ }
+ 
+ static struct clocksource hyperv_cs_msr = {
+ 	.name		= "hyperv_clocksource_msr",
+ 	.rating		= 400,
+ 	.read		= read_hv_clock_msr,
+ 	.mask		= CLOCKSOURCE_MASK(64),
+ 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+ };
++>>>>>>> bd2a9adaadb8 (x86/hyperv: Implement hv_get_tsc_page())
  
  static void *hypercall_pg;
 -struct clocksource *hyperv_cs;
 -EXPORT_SYMBOL_GPL(hyperv_cs);
 -
  /*
   * This function is to be invoked early in the boot sequence after the
   * hypervisor has been detected.
@@@ -58,8 -140,61 +139,44 @@@ void hyperv_init(void
  	hypercall_msr.enable = 1;
  	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);
  	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Register Hyper-V specific clocksource.
+ 	 */
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ 	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
+ 		union hv_x64_msr_hypercall_contents tsc_msr;
+ 
+ 		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
+ 		if (!tsc_pg)
+ 			goto register_msr_cs;
+ 
+ 		hyperv_cs = &hyperv_cs_tsc;
+ 
+ 		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 
+ 		tsc_msr.enable = 1;
+ 		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
+ 
+ 		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+ 		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+ 		return;
+ 	}
+ register_msr_cs:
+ #endif
+ 	/*
+ 	 * For 32 bit guests just use the MSR based mechanism for reading
+ 	 * the partition counter.
+ 	 */
+ 
+ 	hyperv_cs = &hyperv_cs_msr;
+ 	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
+ 		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
++>>>>>>> bd2a9adaadb8 (x86/hyperv: Implement hv_get_tsc_page())
  }
  
 -/*
 - * This routine is called before kexec/kdump, it does the required cleanup.
 - */
 -void hyperv_cleanup(void)
 -{
 -	union hv_x64_msr_hypercall_contents hypercall_msr;
 -
 -	/* Reset our OS id */
 -	wrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);
 -
 -	/* Reset the hypercall page */
 -	hypercall_msr.as_uint64 = 0;
 -	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 -
 -	/* Reset the TSC page */
 -	hypercall_msr.as_uint64 = 0;
 -	wrmsrl(HV_X64_MSR_REFERENCE_TSC, hypercall_msr.as_uint64);
 -}
 -EXPORT_SYMBOL_GPL(hyperv_cleanup);
 -
  /*
   * hv_do_hypercall- Invoke the specified hypercall
   */
* Unmerged path arch/x86/hyperv/hv_init.c
diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index 766df316b67a..30b9a1f2ef8c 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -86,4 +86,12 @@ void hv_remove_crash_handler(void);
 #if IS_ENABLED(CONFIG_HYPERV)
 void hyperv_init(void);
 #endif
+#ifdef CONFIG_HYPERV_TSCPAGE
+struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
+#else
+static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
+{
+	return NULL;
+}
+#endif
 #endif
diff --git a/drivers/hv/Kconfig b/drivers/hv/Kconfig
index 0403b51d20ba..c29cd5387a35 100644
--- a/drivers/hv/Kconfig
+++ b/drivers/hv/Kconfig
@@ -7,6 +7,9 @@ config HYPERV
 	  Select this option to run Linux as a Hyper-V client operating
 	  system.
 
+config HYPERV_TSCPAGE
+       def_bool HYPERV && X86_64
+
 config HYPERV_UTILS
 	tristate "Microsoft Hyper-V Utilities driver"
 	depends on HYPERV && CONNECTOR && NLS
