x86/mm/pkeys: Dump pkey from VMA in /proc/pid/smaps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit c1192f8428414679c8126180e690f8daa1d4d98a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c1192f84.failed

The protection key can now be just as important as read/write
permissions on a VMA.  We need some debug mechanism to help
figure out if it is in play.  smaps seems like a logical
place to expose it.

arch/x86/kernel/setup.c is a bit of a weirdo place to put
this code, but it already had seq_file.h and there was not
a much better existing place to put it.

We also use no #ifdef.  If protection keys is .config'd out we
will effectively get the same function as if we used the weak
generic function.

	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave@sr71.net>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Jerome Marchand <jmarchan@redhat.com>
	Cc: Jiri Kosina <jkosina@suse.cz>
	Cc: Joerg Roedel <jroedel@suse.de>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Laurent Dufour <ldufour@linux.vnet.ibm.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Mark Salter <msalter@redhat.com>
	Cc: Mark Williamson <mwilliamson@undo-software.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: linux-kernel@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/20160212210227.4F8EB3F8@viggo.jf.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c1192f8428414679c8126180e690f8daa1d4d98a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/setup.c
#	fs/proc/task_mmu.c
diff --cc arch/x86/kernel/setup.c
index dcb7e8a78aab,7260f992cd11..000000000000
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@@ -113,7 -112,7 +113,11 @@@
  #include <asm/alternative.h>
  #include <asm/prom.h>
  #include <asm/microcode.h>
++<<<<<<< HEAD
 +#include <asm/kaslr.h>
++=======
+ #include <asm/mmu_context.h>
++>>>>>>> c1192f842841 (x86/mm/pkeys: Dump pkey from VMA in /proc/pid/smaps)
  
  /*
   * max_low_pfn_mapped: highest direct mapped pfn under 4GB
diff --cc fs/proc/task_mmu.c
index a48a2953412f,9df431642042..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -628,6 -682,39 +637,42 @@@ static void show_smap_vma_flags(struct 
  	seq_putc(m, '\n');
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_HUGETLB_PAGE
+ static int smaps_hugetlb_range(pte_t *pte, unsigned long hmask,
+ 				 unsigned long addr, unsigned long end,
+ 				 struct mm_walk *walk)
+ {
+ 	struct mem_size_stats *mss = walk->private;
+ 	struct vm_area_struct *vma = walk->vma;
+ 	struct page *page = NULL;
+ 
+ 	if (pte_present(*pte)) {
+ 		page = vm_normal_page(vma, addr, *pte);
+ 	} else if (is_swap_pte(*pte)) {
+ 		swp_entry_t swpent = pte_to_swp_entry(*pte);
+ 
+ 		if (is_migration_entry(swpent))
+ 			page = migration_entry_to_page(swpent);
+ 	}
+ 	if (page) {
+ 		int mapcount = page_mapcount(page);
+ 
+ 		if (mapcount >= 2)
+ 			mss->shared_hugetlb += huge_page_size(hstate_vma(vma));
+ 		else
+ 			mss->private_hugetlb += huge_page_size(hstate_vma(vma));
+ 	}
+ 	return 0;
+ }
+ #endif /* HUGETLB_PAGE */
+ 
+ void __weak arch_show_smap(struct seq_file *m, struct vm_area_struct *vma)
+ {
+ }
+ 
++>>>>>>> c1192f842841 (x86/mm/pkeys: Dump pkey from VMA in /proc/pid/smaps)
  static int show_smap(struct seq_file *m, void *v, int is_pid)
  {
  	struct vm_area_struct *vma = v;
@@@ -702,10 -796,7 +747,14 @@@
  		   (vma->vm_flags & VM_LOCKED) ?
  			(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);
  
++<<<<<<< HEAD
 +	if (vma->vm_flags & VM_NONLINEAR)
 +		seq_printf(m, "Nonlinear:      %8lu kB\n",
 +				mss.nonlinear >> 10);
 +
++=======
+ 	arch_show_smap(m, vma);
++>>>>>>> c1192f842841 (x86/mm/pkeys: Dump pkey from VMA in /proc/pid/smaps)
  	show_smap_vma_flags(m, vma);
  	m_cache_vma(m, vma);
  	return 0;
* Unmerged path arch/x86/kernel/setup.c
* Unmerged path fs/proc/task_mmu.c
