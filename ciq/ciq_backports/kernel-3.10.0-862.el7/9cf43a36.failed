scsi: cxlflash: Support LUN provisioning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Support LUN provisioning (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 91.89%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 9cf43a360450ddd758b0021d1b55f1cc5643b9ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9cf43a36.failed

Adopt the SISLite AFU LUN provisioning capability to allow future CXL
Flash adapters the ability to better manage storage. Update the SISLite
header with the changes necessary to support LUN provision operations
and create a host ioctl interface for user LUN management software. Also
update the cxlflash documentation to describe this new host ioctl.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9cf43a360450ddd758b0021d1b55f1cc5643b9ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/powerpc/cxlflash.txt
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
#	drivers/scsi/cxlflash/sislite.h
#	include/uapi/scsi/cxlflash_ioctl.h
diff --cc Documentation/powerpc/cxlflash.txt
index 6d9a2ed32cad,2d6297b4ad80..000000000000
--- a/Documentation/powerpc/cxlflash.txt
+++ b/Documentation/powerpc/cxlflash.txt
@@@ -350,3 -367,49 +350,52 @@@ DK_CXLFLASH_MANAGE_LU
      exclusive user space access (superpipe). In case a LUN is visible
      across multiple ports and adapters, this ioctl is used to uniquely
      identify each LUN by its World Wide Node Name (WWNN).
++<<<<<<< HEAD
++=======
+ 
+ 
+ CXL Flash Driver Host IOCTLs
+ ============================
+ 
+     Each host adapter instance that is supported by the cxlflash driver
+     has a special character device associated with it to enable a set of
+     host management function. These character devices are hosted in a
+     class dedicated for cxlflash and can be accessed via /dev/cxlflash/*.
+ 
+     Applications can be written to perform various functions using the
+     host ioctl APIs below.
+ 
+     The structure definitions for these IOCTLs are available in:
+     uapi/scsi/cxlflash_ioctl.h
+ 
+ HT_CXLFLASH_LUN_PROVISION
+ -------------------------
+     This ioctl is used to create and delete persistent LUNs on cxlflash
+     devices that lack an external LUN management interface. It is only
+     valid when used with AFUs that support the LUN provision capability.
+ 
+     When sufficient space is available, LUNs can be created by specifying
+     the target port to host the LUN and a desired size in 4K blocks. Upon
+     success, the LUN ID and WWID of the created LUN will be returned and
+     the SCSI bus can be scanned to detect the change in LUN topology. Note
+     that partial allocations are not supported. Should a creation fail due
+     to a space issue, the target port can be queried for its current LUN
+     geometry.
+ 
+     To remove a LUN, the device must first be disassociated from the Linux
+     SCSI subsystem. The LUN deletion can then be initiated by specifying a
+     target port and LUN ID. Upon success, the LUN geometry associated with
+     the port will be updated to reflect new number of provisioned LUNs and
+     available capacity.
+ 
+     To query the LUN geometry of a port, the target port is specified and
+     upon success, the following information is presented:
+ 
+         - Maximum number of provisioned LUNs allowed for the port
+         - Current number of provisioned LUNs for the port
+         - Maximum total capacity of provisioned LUNs for the port (4K blocks)
+         - Current total capacity of provisioned LUNs for the port (4K blocks)
+ 
+     With this information, the number of available LUNs and capacity can be
+     can be calculated.
++>>>>>>> 9cf43a360450 (scsi: cxlflash: Support LUN provisioning)
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,58107246c32f..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -179,10 -234,49 +179,47 @@@ struct afu 
  	char version[16];
  	u64 interface_version;
  
 -	u32 irqpoll_weight;
  	struct cxlflash_cfg *parent; /* Pointer back to parent cxlflash_cfg */
 +
  };
  
++<<<<<<< HEAD
++=======
+ static inline struct hwq *get_hwq(struct afu *afu, u32 index)
+ {
+ 	WARN_ON(index >= CXLFLASH_MAX_HWQS);
+ 
+ 	return &afu->hwqs[index];
+ }
+ 
+ static inline bool afu_is_irqpoll_enabled(struct afu *afu)
+ {
+ 	return !!afu->irqpoll_weight;
+ }
+ 
+ static inline bool afu_has_cap(struct afu *afu, u64 cap)
+ {
+ 	u64 afu_cap = afu->interface_version >> SISL_INTVER_CAP_SHIFT;
+ 
+ 	return afu_cap & cap;
+ }
+ 
+ static inline bool afu_is_lun_provision(struct afu *afu)
+ {
+ 	return afu_has_cap(afu, SISL_INTVER_CAP_LUN_PROVISION);
+ }
+ 
+ static inline bool afu_is_sq_cmd_mode(struct afu *afu)
+ {
+ 	return afu_has_cap(afu, SISL_INTVER_CAP_SQ_CMD_MODE);
+ }
+ 
+ static inline bool afu_is_ioarrin_cmd_mode(struct afu *afu)
+ {
+ 	return afu_has_cap(afu, SISL_INTVER_CAP_IOARRIN_CMD_MODE);
+ }
+ 
++>>>>>>> 9cf43a360450 (scsi: cxlflash: Support LUN provisioning)
  static inline u64 lun_to_lunid(u64 lun)
  {
  	__be64 lun_id;
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,1279293ff3b3..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -2382,6 -3197,301 +2382,304 @@@ static void cxlflash_worker_thread(stru
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * cxlflash_chr_open() - character device open handler
+  * @inode:	Device inode associated with this character device.
+  * @file:	File pointer for this device.
+  *
+  * Only users with admin privileges are allowed to open the character device.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int cxlflash_chr_open(struct inode *inode, struct file *file)
+ {
+ 	struct cxlflash_cfg *cfg;
+ 
+ 	if (!capable(CAP_SYS_ADMIN))
+ 		return -EACCES;
+ 
+ 	cfg = container_of(inode->i_cdev, struct cxlflash_cfg, cdev);
+ 	file->private_data = cfg;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * decode_hioctl() - translates encoded host ioctl to easily identifiable string
+  * @cmd:        The host ioctl command to decode.
+  *
+  * Return: A string identifying the decoded host ioctl.
+  */
+ static char *decode_hioctl(int cmd)
+ {
+ 	switch (cmd) {
+ 	case HT_CXLFLASH_LUN_PROVISION:
+ 		return __stringify_1(HT_CXLFLASH_LUN_PROVISION);
+ 	}
+ 
+ 	return "UNKNOWN";
+ }
+ 
+ /**
+  * cxlflash_lun_provision() - host LUN provisioning handler
+  * @cfg:	Internal structure associated with the host.
+  * @arg:	Kernel copy of userspace ioctl data structure.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int cxlflash_lun_provision(struct cxlflash_cfg *cfg,
+ 				  struct ht_cxlflash_lun_provision *lunprov)
+ {
+ 	struct afu *afu = cfg->afu;
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct sisl_ioarcb rcb;
+ 	struct sisl_ioasa asa;
+ 	__be64 __iomem *fc_port_regs;
+ 	u16 port = lunprov->port;
+ 	u16 scmd = lunprov->hdr.subcmd;
+ 	u16 type;
+ 	u64 reg;
+ 	u64 size;
+ 	u64 lun_id;
+ 	int rc = 0;
+ 
+ 	if (!afu_is_lun_provision(afu)) {
+ 		rc = -ENOTSUPP;
+ 		goto out;
+ 	}
+ 
+ 	if (port >= cfg->num_fc_ports) {
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	switch (scmd) {
+ 	case HT_CXLFLASH_LUN_PROVISION_SUBCMD_CREATE_LUN:
+ 		type = SISL_AFU_LUN_PROVISION_CREATE;
+ 		size = lunprov->size;
+ 		lun_id = 0;
+ 		break;
+ 	case HT_CXLFLASH_LUN_PROVISION_SUBCMD_DELETE_LUN:
+ 		type = SISL_AFU_LUN_PROVISION_DELETE;
+ 		size = 0;
+ 		lun_id = lunprov->lun_id;
+ 		break;
+ 	case HT_CXLFLASH_LUN_PROVISION_SUBCMD_QUERY_PORT:
+ 		fc_port_regs = get_fc_port_regs(cfg, port);
+ 
+ 		reg = readq_be(&fc_port_regs[FC_MAX_NUM_LUNS / 8]);
+ 		lunprov->max_num_luns = reg;
+ 		reg = readq_be(&fc_port_regs[FC_CUR_NUM_LUNS / 8]);
+ 		lunprov->cur_num_luns = reg;
+ 		reg = readq_be(&fc_port_regs[FC_MAX_CAP_PORT / 8]);
+ 		lunprov->max_cap_port = reg;
+ 		reg = readq_be(&fc_port_regs[FC_CUR_CAP_PORT / 8]);
+ 		lunprov->cur_cap_port = reg;
+ 
+ 		goto out;
+ 	default:
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	memset(&rcb, 0, sizeof(rcb));
+ 	memset(&asa, 0, sizeof(asa));
+ 	rcb.req_flags = SISL_REQ_FLAGS_AFU_CMD;
+ 	rcb.lun_id = lun_id;
+ 	rcb.msi = SISL_MSI_RRQ_UPDATED;
+ 	rcb.timeout = MC_LUN_PROV_TIMEOUT;
+ 	rcb.ioasa = &asa;
+ 
+ 	rcb.cdb[0] = SISL_AFU_CMD_LUN_PROVISION;
+ 	rcb.cdb[1] = type;
+ 	rcb.cdb[2] = port;
+ 	put_unaligned_be64(size, &rcb.cdb[8]);
+ 
+ 	rc = send_afu_cmd(afu, &rcb);
+ 	if (rc) {
+ 		dev_err(dev, "%s: send_afu_cmd failed rc=%d asc=%08x afux=%x\n",
+ 			__func__, rc, asa.ioasc, asa.afu_extra);
+ 		goto out;
+ 	}
+ 
+ 	if (scmd == HT_CXLFLASH_LUN_PROVISION_SUBCMD_CREATE_LUN) {
+ 		lunprov->lun_id = (u64)asa.lunid_hi << 32 | asa.lunid_lo;
+ 		memcpy(lunprov->wwid, asa.wwid, sizeof(lunprov->wwid));
+ 	}
+ out:
+ 	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
+ 	return rc;
+ }
+ 
+ /**
+  * cxlflash_chr_ioctl() - character device IOCTL handler
+  * @file:	File pointer for this device.
+  * @cmd:	IOCTL command.
+  * @arg:	Userspace ioctl data structure.
+  *
+  * A read/write semaphore is used to implement a 'drain' of currently
+  * running ioctls. The read semaphore is taken at the beginning of each
+  * ioctl thread and released upon concluding execution. Additionally the
+  * semaphore should be released and then reacquired in any ioctl execution
+  * path which will wait for an event to occur that is outside the scope of
+  * the ioctl (i.e. an adapter reset). To drain the ioctls currently running,
+  * a thread simply needs to acquire the write semaphore.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static long cxlflash_chr_ioctl(struct file *file, unsigned int cmd,
+ 			       unsigned long arg)
+ {
+ 	typedef int (*hioctl) (struct cxlflash_cfg *, void *);
+ 
+ 	struct cxlflash_cfg *cfg = file->private_data;
+ 	struct device *dev = &cfg->dev->dev;
+ 	char buf[sizeof(union cxlflash_ht_ioctls)];
+ 	void __user *uarg = (void __user *)arg;
+ 	struct ht_cxlflash_hdr *hdr;
+ 	size_t size = 0;
+ 	bool known_ioctl = false;
+ 	int idx = 0;
+ 	int rc = 0;
+ 	hioctl do_ioctl = NULL;
+ 
+ 	static const struct {
+ 		size_t size;
+ 		hioctl ioctl;
+ 	} ioctl_tbl[] = {	/* NOTE: order matters here */
+ 	{ sizeof(struct ht_cxlflash_lun_provision),
+ 		(hioctl)cxlflash_lun_provision },
+ 	};
+ 
+ 	/* Hold read semaphore so we can drain if needed */
+ 	down_read(&cfg->ioctl_rwsem);
+ 
+ 	dev_dbg(dev, "%s: cmd=%u idx=%d tbl_size=%lu\n",
+ 		__func__, cmd, idx, sizeof(ioctl_tbl));
+ 
+ 	switch (cmd) {
+ 	case HT_CXLFLASH_LUN_PROVISION:
+ 		known_ioctl = true;
+ 		idx = _IOC_NR(HT_CXLFLASH_LUN_PROVISION) - _IOC_NR(cmd);
+ 		size = ioctl_tbl[idx].size;
+ 		do_ioctl = ioctl_tbl[idx].ioctl;
+ 
+ 		if (likely(do_ioctl))
+ 			break;
+ 
+ 		/* fall through */
+ 	default:
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (unlikely(copy_from_user(&buf, uarg, size))) {
+ 		dev_err(dev, "%s: copy_from_user() fail "
+ 			"size=%lu cmd=%d (%s) uarg=%p\n",
+ 			__func__, size, cmd, decode_hioctl(cmd), uarg);
+ 		rc = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	hdr = (struct ht_cxlflash_hdr *)&buf;
+ 	if (hdr->version != HT_CXLFLASH_VERSION_0) {
+ 		dev_dbg(dev, "%s: Version %u not supported for %s\n",
+ 			__func__, hdr->version, decode_hioctl(cmd));
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (hdr->rsvd[0] || hdr->rsvd[1] || hdr->return_flags) {
+ 		dev_dbg(dev, "%s: Reserved/rflags populated\n", __func__);
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	rc = do_ioctl(cfg, (void *)&buf);
+ 	if (likely(!rc))
+ 		if (unlikely(copy_to_user(uarg, &buf, size))) {
+ 			dev_err(dev, "%s: copy_to_user() fail "
+ 				"size=%lu cmd=%d (%s) uarg=%p\n",
+ 				__func__, size, cmd, decode_hioctl(cmd), uarg);
+ 			rc = -EFAULT;
+ 		}
+ 
+ 	/* fall through to exit */
+ 
+ out:
+ 	up_read(&cfg->ioctl_rwsem);
+ 	if (unlikely(rc && known_ioctl))
+ 		dev_err(dev, "%s: ioctl %s (%08X) returned rc=%d\n",
+ 			__func__, decode_hioctl(cmd), cmd, rc);
+ 	else
+ 		dev_dbg(dev, "%s: ioctl %s (%08X) returned rc=%d\n",
+ 			__func__, decode_hioctl(cmd), cmd, rc);
+ 	return rc;
+ }
+ 
+ /*
+  * Character device file operations
+  */
+ static const struct file_operations cxlflash_chr_fops = {
+ 	.owner          = THIS_MODULE,
+ 	.open           = cxlflash_chr_open,
+ 	.unlocked_ioctl	= cxlflash_chr_ioctl,
+ 	.compat_ioctl	= cxlflash_chr_ioctl,
+ };
+ 
+ /**
+  * init_chrdev() - initialize the character device for the host
+  * @cfg:	Internal structure associated with the host.
+  *
+  * Return: 0 on success, -errno on failure
+  */
+ static int init_chrdev(struct cxlflash_cfg *cfg)
+ {
+ 	struct device *dev = &cfg->dev->dev;
+ 	struct device *char_dev;
+ 	dev_t devno;
+ 	int minor;
+ 	int rc = 0;
+ 
+ 	minor = cxlflash_get_minor();
+ 	if (unlikely(minor < 0)) {
+ 		dev_err(dev, "%s: Exhausted allowed adapters\n", __func__);
+ 		rc = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	devno = MKDEV(cxlflash_major, minor);
+ 	cdev_init(&cfg->cdev, &cxlflash_chr_fops);
+ 
+ 	rc = cdev_add(&cfg->cdev, devno, 1);
+ 	if (rc) {
+ 		dev_err(dev, "%s: cdev_add failed rc=%d\n", __func__, rc);
+ 		goto err1;
+ 	}
+ 
+ 	char_dev = device_create(cxlflash_class, NULL, devno,
+ 				 NULL, "cxlflash%d", minor);
+ 	if (IS_ERR(char_dev)) {
+ 		rc = PTR_ERR(char_dev);
+ 		dev_err(dev, "%s: device_create failed rc=%d\n",
+ 			__func__, rc);
+ 		goto err2;
+ 	}
+ 
+ 	cfg->chardev = char_dev;
+ out:
+ 	dev_dbg(dev, "%s: returning rc=%d\n", __func__, rc);
+ 	return rc;
+ err2:
+ 	cdev_del(&cfg->cdev);
+ err1:
+ 	cxlflash_put_minor(minor);
+ 	goto out;
+ }
+ 
+ /**
++>>>>>>> 9cf43a360450 (scsi: cxlflash: Support LUN provisioning)
   * cxlflash_probe() - PCI entry point to add host
   * @pdev:	PCI device associated with the host.
   * @dev_id:	PCI device id associated with device.
diff --cc drivers/scsi/cxlflash/sislite.h
index 347fc1671975,c216feeb8906..000000000000
mode 100755,100644..100755
--- a/drivers/scsi/cxlflash/sislite.h
+++ b/drivers/scsi/cxlflash/sislite.h
@@@ -72,7 -72,16 +72,20 @@@ struct sisl_ioarcb 
  	u16 timeout;		/* in units specified by req_flags */
  	u32 rsvd1;
  	u8 cdb[16];		/* must be in big endian */
++<<<<<<< HEAD
 +	struct scsi_cmnd *scp;
++=======
+ #define SISL_AFU_CMD_SYNC		0xC0	/* AFU sync command */
+ #define SISL_AFU_CMD_LUN_PROVISION	0xD0	/* AFU LUN provision command */
+ 
+ #define SISL_AFU_LUN_PROVISION_CREATE	0x00	/* LUN provision create type */
+ #define SISL_AFU_LUN_PROVISION_DELETE	0x01	/* LUN provision delete type */
+ 
+ 	union {
+ 		u64 reserved;			/* Reserved for IOARRIN mode */
+ 		struct sisl_ioasa *ioasa;	/* IOASA EA for SQ Mode */
+ 	};
++>>>>>>> 9cf43a360450 (scsi: cxlflash: Support LUN provisioning)
  } __packed;
  
  struct sisl_rc {
@@@ -348,11 -402,30 +374,24 @@@ struct sisl_global_regs 
  	__be64 rsvd[0xf8];
  	__le64 afu_version;
  	__be64 interface_version;
++<<<<<<< HEAD
++=======
+ #define SISL_INTVER_CAP_SHIFT			16
+ #define SISL_INTVER_MAJ_SHIFT			8
+ #define SISL_INTVER_CAP_MASK			0xFFFFFFFF00000000ULL
+ #define SISL_INTVER_MAJ_MASK			0x00000000FFFF0000ULL
+ #define SISL_INTVER_MIN_MASK			0x000000000000FFFFULL
+ #define SISL_INTVER_CAP_IOARRIN_CMD_MODE	0x800000000000ULL
+ #define SISL_INTVER_CAP_SQ_CMD_MODE		0x400000000000ULL
+ #define SISL_INTVER_CAP_RESERVED_CMD_MODE_A	0x200000000000ULL
+ #define SISL_INTVER_CAP_RESERVED_CMD_MODE_B	0x100000000000ULL
+ #define SISL_INTVER_CAP_LUN_PROVISION		0x080000000000ULL
++>>>>>>> 9cf43a360450 (scsi: cxlflash: Support LUN provisioning)
  };
  
 -#define CXLFLASH_NUM_FC_PORTS_PER_BANK	2	/* fixed # of ports per bank */
 -#define CXLFLASH_MAX_FC_BANKS		2	/* max # of banks supported */
 -#define CXLFLASH_MAX_FC_PORTS	(CXLFLASH_NUM_FC_PORTS_PER_BANK *	\
 -				 CXLFLASH_MAX_FC_BANKS)
 -#define CXLFLASH_MAX_CONTEXT	512	/* number of contexts per AFU */
 -#define CXLFLASH_NUM_VLUNS	512	/* number of vluns per AFU/port */
 -#define CXLFLASH_NUM_REGS	512	/* number of registers per port */
 -
 -struct fc_port_bank {
 -	__be64 fc_port_regs[CXLFLASH_NUM_FC_PORTS_PER_BANK][CXLFLASH_NUM_REGS];
 -	__be64 fc_port_luns[CXLFLASH_NUM_FC_PORTS_PER_BANK][CXLFLASH_NUM_VLUNS];
 -};
 +#define CXLFLASH_NUM_FC_PORTS   2
 +#define CXLFLASH_MAX_CONTEXT  512	/* how many contexts per afu */
 +#define CXLFLASH_NUM_VLUNS    512
  
  struct sisl_global_map {
  	union {
diff --cc include/uapi/scsi/cxlflash_ioctl.h
index 6bf1f8a022b1,ad79c34f4d11..000000000000
--- a/include/uapi/scsi/cxlflash_ioctl.h
+++ b/include/uapi/scsi/cxlflash_ioctl.h
@@@ -190,4 -195,50 +190,53 @@@ union cxlflash_ioctls 
  #define DK_CXLFLASH_VLUN_RESIZE		CXL_IOWR(0x88, dk_cxlflash_resize)
  #define DK_CXLFLASH_VLUN_CLONE		CXL_IOWR(0x89, dk_cxlflash_clone)
  
++<<<<<<< HEAD
++=======
+ /*
+  * Structure and flag definitions CXL Flash host ioctls
+  */
+ 
+ #define HT_CXLFLASH_VERSION_0  0
+ 
+ struct ht_cxlflash_hdr {
+ 	__u16 version;		/* Version data */
+ 	__u16 subcmd;		/* Sub-command */
+ 	__u16 rsvd[2];		/* Reserved for future use */
+ 	__u64 flags;		/* Input flags */
+ 	__u64 return_flags;	/* Returned flags */
+ };
+ 
+ #define HT_CXLFLASH_LUN_PROVISION_SUBCMD_CREATE_LUN	0x0001
+ #define HT_CXLFLASH_LUN_PROVISION_SUBCMD_DELETE_LUN	0x0002
+ #define HT_CXLFLASH_LUN_PROVISION_SUBCMD_QUERY_PORT	0x0003
+ #define HT_CXLFLASH_LUN_PROVISION_WWID_LEN		16
+ 
+ struct ht_cxlflash_lun_provision {
+ 	struct ht_cxlflash_hdr hdr; /* Common fields */
+ 	__u16 port;		    /* Target port for provision request */
+ 	__u16 reserved16[3];	    /* Reserved for future use */
+ 	__u64 size;		    /* Size of LUN (4K blocks) */
+ 	__u64 lun_id;		    /* SCSI LUN ID */
+ 	__u8 wwid[HT_CXLFLASH_LUN_PROVISION_WWID_LEN]; /* Page83 WWID, NAA-6 */
+ 	__u64 max_num_luns;	    /* Maximum number of LUNs provisioned */
+ 	__u64 cur_num_luns;	    /* Current number of LUNs provisioned */
+ 	__u64 max_cap_port;	    /* Total capacity for port (4K blocks) */
+ 	__u64 cur_cap_port;	    /* Current capacity for port (4K blocks) */
+ 	__u64 reserved[8];	    /* Reserved for future use */
+ };
+ 
+ union cxlflash_ht_ioctls {
+ 	struct ht_cxlflash_lun_provision lun_provision;
+ };
+ 
+ #define MAX_HT_CXLFLASH_IOCTL_SZ	(sizeof(union cxlflash_ht_ioctls))
+ 
+ /*
+  * CXL Flash host ioctls start at the top of the reserved CXL_MAGIC
+  * region (0xBF) and grow downwards.
+  */
+ #define HT_CXLFLASH_LUN_PROVISION CXL_IOWR(0xBF, ht_cxlflash_lun_provision)
+ 
+ 
++>>>>>>> 9cf43a360450 (scsi: cxlflash: Support LUN provisioning)
  #endif /* ifndef _CXLFLASH_IOCTL_H */
* Unmerged path Documentation/powerpc/cxlflash.txt
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
diff --git a/drivers/scsi/cxlflash/main.h b/drivers/scsi/cxlflash/main.h
index 055ea95141f2..fa3e691c68a5 100644
--- a/drivers/scsi/cxlflash/main.h
+++ b/drivers/scsi/cxlflash/main.h
@@ -42,6 +42,10 @@
 /* FC defines */
 #define FC_MTIP_CMDCONFIG 0x010
 #define FC_MTIP_STATUS 0x018
+#define FC_MAX_NUM_LUNS 0x080 /* Max LUNs host can provision for port */
+#define FC_CUR_NUM_LUNS 0x088 /* Cur number LUNs provisioned for port */
+#define FC_MAX_CAP_PORT 0x090 /* Max capacity all LUNs for port (4K blocks) */
+#define FC_CUR_CAP_PORT 0x098 /* Cur capacity all LUNs for port (4K blocks) */
 
 #define FC_PNAME 0x300
 #define FC_CONFIG 0x320
@@ -64,6 +68,7 @@
 
 /* AFU command timeout values */
 #define MC_AFU_SYNC_TIMEOUT	5	/* 5 secs */
+#define MC_LUN_PROV_TIMEOUT	5	/* 5 secs */
 
 /* AFU command room retry limit */
 #define MC_ROOM_RETRY_CNT	10
* Unmerged path drivers/scsi/cxlflash/sislite.h
* Unmerged path include/uapi/scsi/cxlflash_ioctl.h
