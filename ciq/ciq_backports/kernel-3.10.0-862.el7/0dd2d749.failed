x86/intel_rdt: Show bitmask of shareable resource with other executing units

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt: Show bitmask of shareable resource with other executing units (Jiri Olsa) [1457533]
Rebuild_FUZZ: 97.30%
commit-author Fenghua Yu <fenghua.yu@intel.com>
commit 0dd2d7494cd818d06a2ae1cd840cd62124a2d25e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0dd2d749.failed

CPUID.(EAX=0x10, ECX=res#):EBX[31:0] reports a bit mask for a resource.
Each set bit within the length of the CBM indicates the corresponding
unit of the resource allocation may be used by other entities in the
platform (e.g. an integrated graphics engine or hardware units outside
the processor core and have direct access to the resource). Each
cleared bit within the length of the CBM indicates the corresponding
allocation unit can be configured to implement a priority-based
allocation scheme without interference with other hardware agents in
the system. Bits outside the length of the CBM are reserved.

More details on the bit mask are described in x86 Software Developer's
Manual.

The bitmask is shown in "info" directory for each resource. It's
up to user to decide how to use the bitmask within a CBM in a partition
to share or isolate a resource with other executing units.

	Suggested-by: Reinette Chatre <reinette.chatre@intel.com>
	Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
	Signed-off-by: Tony Luck <tony.luck@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: peterz@infradead.org
	Cc: eranian@google.com
	Cc: ak@linux.intel.com
	Cc: davidcc@google.com
	Cc: vikas.shivappa@linux.intel.com
Link: http://lkml.kernel.org/r/20170725223904.12996-1-tony.luck@intel.com

(cherry picked from commit 0dd2d7494cd818d06a2ae1cd840cd62124a2d25e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt.c
#	arch/x86/kernel/cpu/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index ad087dd4421e,da4f3898d517..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -124,11 -191,12 +124,20 @@@ static inline bool cache_alloc_hsw_prob
  			return false;
  
  		r->num_closid = 4;
++<<<<<<< HEAD
 +		r->cbm_len = 20;
 +		r->max_cbm = max_cbm;
 +		r->min_cbm_bits = 2;
 +		r->capable = true;
 +		r->enabled = true;
++=======
+ 		r->default_ctrl = max_cbm;
+ 		r->cache.cbm_len = 20;
+ 		r->cache.shareable_bits = 0xc0000;
+ 		r->cache.min_cbm_bits = 2;
+ 		r->alloc_capable = true;
+ 		r->alloc_enabled = true;
++>>>>>>> 0dd2d7494cd8 (x86/intel_rdt: Show bitmask of shareable resource with other executing units)
  
  		return true;
  	}
@@@ -144,11 -259,12 +153,20 @@@ static void rdt_get_config(int idx, str
  
  	cpuid_count(0x00000010, idx, &eax.full, &ebx, &ecx, &edx.full);
  	r->num_closid = edx.split.cos_max + 1;
++<<<<<<< HEAD
 +	r->cbm_len = eax.split.cbm_len + 1;
 +	r->max_cbm = BIT_MASK(eax.split.cbm_len + 1) - 1;
 +	r->data_width = (r->cbm_len + 3) / 4;
 +	r->capable = true;
 +	r->enabled = true;
++=======
+ 	r->cache.cbm_len = eax.split.cbm_len + 1;
+ 	r->default_ctrl = BIT_MASK(eax.split.cbm_len + 1) - 1;
+ 	r->cache.shareable_bits = ebx & r->default_ctrl;
+ 	r->data_width = (r->cache.cbm_len + 3) / 4;
+ 	r->alloc_capable = true;
+ 	r->alloc_enabled = true;
++>>>>>>> 0dd2d7494cd8 (x86/intel_rdt: Show bitmask of shareable resource with other executing units)
  }
  
  static void rdt_get_cdp_l3_config(int type)
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1c3603d97e9d,2621ae3f07fc..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -475,8 -569,193 +475,198 @@@ static int rdtgroup_tasks_show(struct k
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* Files in each rdtgroup */
 +static struct rftype rdtgroup_base_files[] = {
++=======
+ static int rdt_num_closids_show(struct kernfs_open_file *of,
+ 				struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%d\n", r->num_closid);
+ 	return 0;
+ }
+ 
+ static int rdt_default_ctrl_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%x\n", r->default_ctrl);
+ 	return 0;
+ }
+ 
+ static int rdt_min_cbm_bits_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->cache.min_cbm_bits);
+ 	return 0;
+ }
+ 
+ static int rdt_shareable_bits_show(struct kernfs_open_file *of,
+ 				   struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%x\n", r->cache.shareable_bits);
+ 	return 0;
+ }
+ 
+ static int rdt_min_bw_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.min_bw);
+ 	return 0;
+ }
+ 
+ static int rdt_num_rmids_show(struct kernfs_open_file *of,
+ 			      struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%d\n", r->num_rmid);
+ 
+ 	return 0;
+ }
+ 
+ static int rdt_mon_features_show(struct kernfs_open_file *of,
+ 				 struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	struct mon_evt *mevt;
+ 
+ 	list_for_each_entry(mevt, &r->evt_list, list)
+ 		seq_printf(seq, "%s\n", mevt->name);
+ 
+ 	return 0;
+ }
+ 
+ static int rdt_bw_gran_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.bw_gran);
+ 	return 0;
+ }
+ 
+ static int rdt_delay_linear_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.delay_linear);
+ 	return 0;
+ }
+ 
+ static int max_threshold_occ_show(struct kernfs_open_file *of,
+ 				  struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", intel_cqm_threshold * r->mon_scale);
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t max_threshold_occ_write(struct kernfs_open_file *of,
+ 				       char *buf, size_t nbytes, loff_t off)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 	unsigned int bytes;
+ 	int ret;
+ 
+ 	ret = kstrtouint(buf, 0, &bytes);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (bytes > (boot_cpu_data.x86_cache_size * 1024))
+ 		return -EINVAL;
+ 
+ 	intel_cqm_threshold = bytes / r->mon_scale;
+ 
+ 	return ret ?: nbytes;
+ }
+ 
+ /* rdtgroup information files for one cache resource. */
+ static struct rftype res_common_files[] = {
+ 	{
+ 		.name		= "num_closids",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_num_closids_show,
+ 		.fflags		= RF_CTRL_INFO,
+ 	},
+ 	{
+ 		.name		= "mon_features",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_mon_features_show,
+ 		.fflags		= RF_MON_INFO,
+ 	},
+ 	{
+ 		.name		= "num_rmids",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_num_rmids_show,
+ 		.fflags		= RF_MON_INFO,
+ 	},
+ 	{
+ 		.name		= "cbm_mask",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_default_ctrl_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_CACHE,
+ 	},
+ 	{
+ 		.name		= "min_cbm_bits",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_min_cbm_bits_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_CACHE,
+ 	},
+ 	{
+ 		.name		= "shareable_bits",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_shareable_bits_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_CACHE,
+ 	},
+ 	{
+ 		.name		= "min_bandwidth",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_min_bw_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_MB,
+ 	},
+ 	{
+ 		.name		= "bandwidth_gran",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_bw_gran_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_MB,
+ 	},
+ 	{
+ 		.name		= "delay_linear",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_delay_linear_show,
+ 		.fflags		= RF_CTRL_INFO | RFTYPE_RES_MB,
+ 	},
+ 	{
+ 		.name		= "max_threshold_occupancy",
+ 		.mode		= 0644,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.write		= max_threshold_occ_write,
+ 		.seq_show	= max_threshold_occ_show,
+ 		.fflags		= RF_MON_INFO | RFTYPE_RES_CACHE,
+ 	},
++>>>>>>> 0dd2d7494cd8 (x86/intel_rdt: Show bitmask of shareable resource with other executing units)
  	{
  		.name		= "cpus",
  		.mode		= 0644,
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
diff --git a/Documentation/x86/intel_rdt_ui.txt b/Documentation/x86/intel_rdt_ui.txt
index 76f21e2ac176..4d8848e4e224 100644
--- a/Documentation/x86/intel_rdt_ui.txt
+++ b/Documentation/x86/intel_rdt_ui.txt
@@ -48,6 +48,13 @@ related to allocation:
 "min_cbm_bits": 	The minimum number of consecutive bits which
 			must be set when writing a mask.
 
+"shareable_bits":	Bitmask of shareable resource with other executing
+			entities (e.g. I/O). User can use this when
+			setting up exclusive cache partitions. Note that
+			some platforms support devices that have their
+			own settings for cache use which can over-ride
+			these bits.
+
 Memory bandwitdh(MB) subdirectory contains the following files
 with respect to allocation:
 
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
* Unmerged path arch/x86/kernel/cpu/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
