nfp: allow non-equal distribution of IRQs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 2c7e41c0b2f103056f93dd5922c03d6e2021c76d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2c7e41c0.failed

Thus far the code assumed all vNICs will request similar number of IRQs.
This will be no longer true with control vNICs (where 1 IRQ will suffice).

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2c7e41c0b2f103056f93dd5922c03d6e2021c76d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,362dca38223b..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -391,31 -398,30 +391,36 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  
  	/* Get MSI-X vectors */
  	wanted_irqs = 0;
 -	list_for_each_entry(nn, &pf->vnics, vnic_list)
 -		wanted_irqs += NFP_NET_NON_Q_VECTORS + nn->dp.num_r_vecs;
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		wanted_irqs += NFP_NET_NON_Q_VECTORS + nn->num_r_vecs;
  	pf->irq_entries = kcalloc(wanted_irqs, sizeof(*pf->irq_entries),
  				  GFP_KERNEL);
 -	if (!pf->irq_entries)
 -		return -ENOMEM;
 +	if (!pf->irq_entries) {
 +		err = -ENOMEM;
 +		goto err_nn_free;
 +	}
  
  	num_irqs = nfp_net_irqs_alloc(pf->pdev, pf->irq_entries,
 -				      NFP_NET_MIN_VNIC_IRQS * pf->num_vnics,
 +				      NFP_NET_MIN_PORT_IRQS * pf->num_ports,
  				      wanted_irqs);
  	if (!num_irqs) {
 -		nfp_warn(pf->cpp, "Unable to allocate MSI-X vectors\n");
 -		kfree(pf->irq_entries);
 -		return -ENOMEM;
 +		nn_warn(nn, "Unable to allocate MSI-X Vectors. Exiting\n");
 +		err = -ENOMEM;
 +		goto err_vec_free;
  	}
  
 -	/* Distribute IRQs to vNICs */
 +	/* Distribute IRQs to ports */
  	irqs_left = num_irqs;
 -	vnics_left = pf->num_vnics;
 -	list_for_each_entry(nn, &pf->vnics, vnic_list) {
 +	ports_left = pf->num_ports;
 +	list_for_each_entry(nn, &pf->ports, port_list) {
  		unsigned int n;
  
++<<<<<<< HEAD
 +		n = DIV_ROUND_UP(irqs_left, ports_left);
++=======
+ 		n = min(NFP_NET_NON_Q_VECTORS + nn->dp.num_r_vecs,
+ 			DIV_ROUND_UP(irqs_left, vnics_left));
++>>>>>>> 2c7e41c0b2f1 (nfp: allow non-equal distribution of IRQs)
  		nfp_net_irqs_assign(nn, &pf->irq_entries[num_irqs - irqs_left],
  				    n);
  		irqs_left -= n;
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
