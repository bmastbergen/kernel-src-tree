blk-merge: return the merged request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jens Axboe <axboe@fb.com>
commit b973cb7e89fe3dcc2bc72c5b3aa7a3bfd9d0e6d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b973cb7e.failed

When we attempt to merge request-to-request, we return a 0/1 if we
ended up merging or not. Change that to return the pointer to the
request that we freed. We will use this to move the freeing of
that request out of the merge logic, so that callers can drop
locks before freeing the request.

There should be no functional changes in this patch.

	Signed-off-by: Jens Axboe <axboe@fb.com>
	Reviewed-by: Omar Sandoval <osandov@fb.com>
(cherry picked from commit b973cb7e89fe3dcc2bc72c5b3aa7a3bfd9d0e6d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-merge.c
diff --cc block/blk-merge.c
index 0e8b7f203168,3826fc32b72c..000000000000
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@@ -434,16 -659,17 +434,22 @@@ static void blk_account_io_merge(struc
  }
  
  /*
-  * Has to be called with the request spinlock acquired
+  * For non-mq, this has to be called with the request spinlock acquired.
+  * For mq with scheduling, the appropriate queue wide lock should be held.
   */
- static int attempt_merge(struct request_queue *q, struct request *req,
- 			  struct request *next)
+ static struct request *attempt_merge(struct request_queue *q,
+ 				     struct request *req, struct request *next)
  {
  	if (!rq_mergeable(req) || !rq_mergeable(next))
- 		return 0;
+ 		return NULL;
  
++<<<<<<< HEAD
 +	if (!blk_check_merge_flags(req->cmd_flags, next->cmd_flags))
 +		return 0;
++=======
+ 	if (req_op(req) != req_op(next))
+ 		return NULL;
++>>>>>>> b973cb7e89fe (blk-merge: return the merged request)
  
  	/*
  	 * not contiguous
@@@ -454,11 -680,11 +460,11 @@@
  	if (rq_data_dir(req) != rq_data_dir(next)
  	    || req->rq_disk != next->rq_disk
  	    || req_no_special_merge(next))
- 		return 0;
+ 		return NULL;
  
 -	if (req_op(req) == REQ_OP_WRITE_SAME &&
 +	if (req->cmd_flags & REQ_WRITE_SAME &&
  	    !blk_write_same_mergeable(req->bio, next->bio))
- 		return 0;
+ 		return NULL;
  
  	/*
  	 * If we are allowed to merge, then append bio list
@@@ -536,7 -762,13 +542,17 @@@ struct request *attempt_front_merge(str
  int blk_attempt_req_merge(struct request_queue *q, struct request *rq,
  			  struct request *next)
  {
++<<<<<<< HEAD
 +	return attempt_merge(q, rq, next);
++=======
+ 	struct elevator_queue *e = q->elevator;
+ 
+ 	if (!e->uses_mq && e->type->ops.sq.elevator_allow_rq_merge_fn)
+ 		if (!e->type->ops.sq.elevator_allow_rq_merge_fn(q, rq, next))
+ 			return 0;
+ 
+ 	return attempt_merge(q, rq, next) != NULL;
++>>>>>>> b973cb7e89fe (blk-merge: return the merged request)
  }
  
  bool blk_rq_merge_ok(struct request *rq, struct bio *bio)
* Unmerged path block/blk-merge.c
diff --git a/block/blk.h b/block/blk.h
index 4d1760d40372..7cf4031f6eab 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -211,8 +211,8 @@ int ll_back_merge_fn(struct request_queue *q, struct request *req,
 		     struct bio *bio);
 int ll_front_merge_fn(struct request_queue *q, struct request *req, 
 		      struct bio *bio);
-int attempt_back_merge(struct request_queue *q, struct request *rq);
-int attempt_front_merge(struct request_queue *q, struct request *rq);
+struct request *attempt_back_merge(struct request_queue *q, struct request *rq);
+struct request *attempt_front_merge(struct request_queue *q, struct request *rq);
 int blk_attempt_req_merge(struct request_queue *q, struct request *rq,
 				struct request *next);
 void blk_recalc_rq_segments(struct request *rq);
