ALSA: x86: Don't check connection in lowlevel accessors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 83af57dd515cf06883f6e954dd0efa9b15b514a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/83af57dd.failed

The lowlevel register read/write don't have to be careful about the
connection state.  It should be checked in the caller side instead.
By dropping the check, we can simplify the code, and readability.

This patch also refacors the functions slightly: namely,
- drop the useless always-zero return values
- fold the inline functions to the main accessor functions themselves
- move the DP audio hack for AUD_CONFIG to the caller side
- simplify snd_intelhad_eanble_audio() and drop the unused
  had_read_modify()

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 83af57dd515cf06883f6e954dd0efa9b15b514a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,db437efbb87d..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -154,81 -157,52 +154,99 @@@ static const struct snd_pcm_hardware sn
  	.fifo_size = HAD_FIFO_SIZE,
  };
  
 -/* Get the active PCM substream;
 - * Call had_substream_put() for unreferecing.
 - * Don't call this inside had_spinlock, as it takes by itself
 - */
 -static struct snd_pcm_substream *
 -had_substream_get(struct snd_intelhad *intelhaddata)
 +/* Register access functions */
++<<<<<<< HEAD
 +
 +int had_get_hwstate(struct snd_intelhad *intelhaddata)
  {
 -	struct snd_pcm_substream *substream;
 -	unsigned long flags;
 +	/* Check for device presence -SW state */
 +	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 +		pr_debug("%s:Device not connected:%d\n", __func__,
 +				intelhaddata->drv_status);
 +		return -ENODEV;
 +	}
  
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
 -	substream = intelhaddata->stream_info.substream;
 -	if (substream)
 -		intelhaddata->stream_info.substream_refcount++;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
 -	return substream;
 +	return 0;
  }
  
 -/* Unref the active PCM substream;
 - * Don't call this inside had_spinlock, as it takes by itself
 - */
 -static void had_substream_put(struct snd_intelhad *intelhaddata)
 +int had_get_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list query, void *caps)
  {
 -	unsigned long flags;
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_get_caps(query, caps);
  
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
 -	intelhaddata->stream_info.substream_refcount--;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
 +	return retval;
  }
  
 -/* Register access functions */
 +int had_set_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list set_element, void *caps)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_set_caps(set_element, caps);
 +
 +	return retval;
 +}
 +
 +int had_read_register(struct snd_intelhad *intelhaddata, u32 offset, u32 *data)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_read(offset, data);
 +
 +	return retval;
 +}
 +
 +int had_write_register(struct snd_intelhad *intelhaddata, u32 offset, u32 data)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_write(offset, data);
 +
 +	return retval;
 +}
 +
 +int had_read_modify(struct snd_intelhad *intelhaddata, u32 offset,
 +		    u32 data, u32 mask)
 +{
 +	int retval;
 +
 +	retval = had_get_hwstate(intelhaddata);
 +	if (!retval)
 +		retval = mid_hdmi_audio_rmw(offset, data, mask);
 +
 +	return retval;
 +}
 +/**
 + * function to read-modify
 + * AUD_CONFIG register on VLV2.The had_read_modify() function should not
 + * directly be used on VLV2 for updating AUD_CONFIG register.
++=======
+ static void had_read_register(struct snd_intelhad *ctx, u32 reg, u32 *val)
+ {
+ 	*val = ioread32(ctx->mmio_start + ctx->had_config_offset + reg);
+ }
+ 
+ static void had_write_register(struct snd_intelhad *ctx, u32 reg, u32 val)
+ {
+ 	iowrite32(val, ctx->mmio_start + ctx->had_config_offset + reg);
+ }
+ 
+ /*
+  * enable / disable audio configuration
+  *
+  * The normal read/modify should not directly be used on VLV2 for
+  * updating AUD_CONFIG register.
++>>>>>>> 83af57dd515c (ALSA: x86: Don't check connection in lowlevel accessors)
   * This is because:
   * Bit6 of AUD_CONFIG register is writeonly due to a silicon bug on VLV2
   * HDMI IP. As a result a read-modify of AUD_CONFIG regiter will always
@@@ -238,40 -212,44 +256,72 @@@
   * causes the "channels" field to be updated as 0xy binary resulting in
   * bad audio. The fix is to always write the AUD_CONFIG[6:4] with
   * appropriate value when doing read-modify of AUD_CONFIG register.
 + *
 + * @substream: the current substream or NULL if no active substream
 + * @data : data to be written
 + * @mask : mask
 + *
   */
 -static void snd_intelhad_enable_audio(struct snd_pcm_substream *substream,
 -				      struct snd_intelhad *intelhaddata,
 -				      bool enable)
 +static int had_read_modify_aud_config_v2(struct snd_pcm_substream *substream,
 +					u32 data, u32 mask)
  {
++<<<<<<< HEAD
 +	struct snd_intelhad *intelhaddata = snd_pcm_substream_chip(substream);
 +	union aud_cfg cfg_val = {.cfg_regval = 0};
 +	u8 channels;
++=======
+ 	union aud_cfg cfg_val = {.regval = 0};
+ 	u8 channels;
+ 	u32 mask, val;
++>>>>>>> 83af57dd515c (ALSA: x86: Don't check connection in lowlevel accessors)
  
  	/*
  	 * If substream is NULL, there is no active stream.
  	 * In this case just set channels to 2
  	 */
++<<<<<<< HEAD
 +	if (substream)
 +		channels = substream->runtime->channels;
 +	else
 +		channels = 2;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
 +
 +	data = data | cfg_val.cfg_regval;
 +	mask = mask | AUD_CONFIG_CH_MASK_V2;
 +
 +	pr_debug("%s : data = %x, mask =%x\n", __func__, data, mask);
 +
 +	return had_read_modify(intelhaddata, AUD_CONFIG, data, mask);
++=======
+ 	channels = substream ? substream->runtime->channels : 2;
+ 	dev_dbg(intelhaddata->dev, "enable %d, ch=%d\n", enable, channels);
+ 
+ 	cfg_val.regx.num_ch = channels - 2;
+ 	if (enable)
+ 		cfg_val.regx.aud_en = 1;
+ 	mask = AUD_CONFIG_CH_MASK | 1;
+ 
+ 	had_read_register(intelhaddata, AUD_CONFIG, &val);
+ 	val &= ~mask;
+ 	val |= cfg_val.regval;
+ 	had_write_register(intelhaddata, AUD_CONFIG, val);
++>>>>>>> 83af57dd515c (ALSA: x86: Don't check connection in lowlevel accessors)
  }
  
 -/* enable / disable the audio interface */
 -static void snd_intelhad_enable_audio_int(struct snd_intelhad *ctx, bool enable)
 +void snd_intelhad_enable_audio(struct snd_pcm_substream *substream, u8 enable)
  {
++<<<<<<< HEAD
 +	had_read_modify_aud_config_v2(substream, enable, BIT(0));
++=======
+ 	u32 status_reg;
+ 
+ 	if (enable) {
+ 		had_read_register(ctx, AUD_HDMI_STATUS, &status_reg);
+ 		status_reg |= HDMI_AUDIO_BUFFER_DONE | HDMI_AUDIO_UNDERRUN;
+ 		had_write_register(ctx, AUD_HDMI_STATUS, status_reg);
+ 		had_read_register(ctx, AUD_HDMI_STATUS, &status_reg);
+ 	}
++>>>>>>> 83af57dd515c (ALSA: x86: Don't check connection in lowlevel accessors)
  }
  
  static void snd_intelhad_reset_audio(struct snd_intelhad *intelhaddata,
@@@ -364,20 -340,27 +414,32 @@@ static int snd_intelhad_audio_ctrl(stru
  
  	had_prog_status_reg(substream, intelhaddata);
  
 -	buf_cfg.regx.audio_fifo_watermark = FIFO_THRESHOLD;
 -	buf_cfg.regx.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 -	buf_cfg.regx.aud_delay = 0;
 -	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.regval);
 +	buf_cfg.buf_cfg_regx_v2.audio_fifo_watermark = FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.aud_delay = 0;
 +	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.buf_cfgval);
  
  	channels = substream->runtime->channels;
 -	cfg_val.regx.num_ch = channels - 2;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
  	if (channels <= 2)
 -		cfg_val.regx.layout = LAYOUT0;
 +		cfg_val.cfg_regx_v2.layout = LAYOUT0;
  	else
 -		cfg_val.regx.layout = LAYOUT1;
 +		cfg_val.cfg_regx_v2.layout = LAYOUT1;
  
++<<<<<<< HEAD
 +	cfg_val.cfg_regx_v2.val_bit = 1;
 +	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.cfg_regval);
++=======
+ 	cfg_val.regx.val_bit = 1;
+ 
+ 	/* fix up the DP bits */
+ 	if (intelhaddata->dp_output) {
+ 		cfg_val.regx.dp_modei = 1;
+ 		cfg_val.regx.set = 1;
+ 	}
+ 
+ 	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.regval);
++>>>>>>> 83af57dd515c (ALSA: x86: Don't check connection in lowlevel accessors)
  	return 0;
  }
  
@@@ -1576,61 -1635,227 +1638,200 @@@ static struct snd_kcontrol_new had_cont
  };
  
  /*
++<<<<<<< HEAD
 + * hdmi_audio_probe - to create sound card instance for HDMI audio playabck
++=======
+  * audio interrupt handler
+  */
+ static irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)
+ {
+ 	struct snd_intelhad *ctx = dev_id;
+ 	u32 audio_stat, audio_reg;
+ 
+ 	audio_reg = AUD_HDMI_STATUS;
+ 	had_read_register(ctx, audio_reg, &audio_stat);
+ 
+ 	if (audio_stat & HDMI_AUDIO_UNDERRUN) {
+ 		had_write_register(ctx, audio_reg, HDMI_AUDIO_UNDERRUN);
+ 		had_process_buffer_underrun(ctx);
+ 	}
+ 
+ 	if (audio_stat & HDMI_AUDIO_BUFFER_DONE) {
+ 		had_write_register(ctx, audio_reg, HDMI_AUDIO_BUFFER_DONE);
+ 		had_process_buffer_done(ctx);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ /*
+  * monitor plug/unplug notification from i915; just kick off the work
+  */
+ static void notify_audio_lpe(struct platform_device *pdev)
+ {
+ 	struct snd_intelhad *ctx = platform_get_drvdata(pdev);
+ 
+ 	schedule_work(&ctx->hdmi_audio_wq);
+ }
+ 
+ /* the work to handle monitor hot plug/unplug */
+ static void had_audio_wq(struct work_struct *work)
+ {
+ 	struct snd_intelhad *ctx =
+ 		container_of(work, struct snd_intelhad, hdmi_audio_wq);
+ 	struct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;
+ 
+ 	pm_runtime_get_sync(ctx->dev);
+ 	mutex_lock(&ctx->mutex);
+ 	if (!pdata->hdmi_connected) {
+ 		dev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG\n",
+ 			__func__);
+ 		memset(ctx->eld, 0, sizeof(ctx->eld)); /* clear the old ELD */
+ 		had_process_hot_unplug(ctx);
+ 	} else {
+ 		struct intel_hdmi_lpe_audio_eld *eld = &pdata->eld;
+ 
+ 		dev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",
+ 			__func__, eld->port_id,	pdata->tmds_clock_speed);
+ 
+ 		switch (eld->pipe_id) {
+ 		case 0:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
+ 			break;
+ 		case 1:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_B;
+ 			break;
+ 		case 2:
+ 			ctx->had_config_offset = AUDIO_HDMI_CONFIG_C;
+ 			break;
+ 		default:
+ 			dev_dbg(ctx->dev, "Invalid pipe %d\n",
+ 				eld->pipe_id);
+ 			break;
+ 		}
+ 
+ 		memcpy(ctx->eld, eld->eld_data, sizeof(ctx->eld));
+ 
+ 		ctx->dp_output = pdata->dp_output;
+ 		ctx->tmds_clock_speed = pdata->tmds_clock_speed;
+ 		ctx->link_rate = pdata->link_rate;
+ 
+ 		had_process_hot_plug(ctx);
+ 
+ 		/* Process mode change if stream is active */
+ 		hdmi_audio_mode_change(ctx);
+ 	}
+ 	mutex_unlock(&ctx->mutex);
+ 	pm_runtime_put(ctx->dev);
+ }
+ 
+ /*
+  * PM callbacks
+  */
+ 
+ static int hdmi_lpe_audio_runtime_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 	struct snd_pcm_substream *substream;
+ 
+ 	substream = had_substream_get(ctx);
+ 	if (substream) {
+ 		snd_pcm_suspend(substream);
+ 		had_substream_put(ctx);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int hdmi_lpe_audio_suspend(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	err = hdmi_lpe_audio_runtime_suspend(dev);
+ 	if (!err)
+ 		snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D3hot);
+ 	return err;
+ }
+ 
+ static int hdmi_lpe_audio_resume(struct device *dev)
+ {
+ 	struct snd_intelhad *ctx = dev_get_drvdata(dev);
+ 
+ 	snd_power_change_state(ctx->card, SNDRV_CTL_POWER_D0);
+ 	return 0;
+ }
+ 
+ /* release resources */
+ static void hdmi_lpe_audio_free(struct snd_card *card)
+ {
+ 	struct snd_intelhad *ctx = card->private_data;
+ 
+ 	cancel_work_sync(&ctx->hdmi_audio_wq);
+ 
+ 	if (ctx->mmio_start)
+ 		iounmap(ctx->mmio_start);
+ 	if (ctx->irq >= 0)
+ 		free_irq(ctx->irq, ctx);
+ }
+ 
+ /*
+  * hdmi_lpe_audio_probe - start bridge with i915
++>>>>>>> 83af57dd515c (ALSA: x86: Don't check connection in lowlevel accessors)
   *
 - * This function is called when the i915 driver creates the
 - * hdmi-lpe-audio platform device.
 + * @devptr: platform device
 + * @had_ret: pointer to store the created snd_intelhad object
 + *
 + * This function is called when the platform device is probed. This function
 + * creates and registers the sound card with ALSA
   */
 -static int hdmi_lpe_audio_probe(struct platform_device *pdev)
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret)
  {
 -	struct snd_card *card;
 -	struct snd_intelhad *ctx;
 +	int retval;
  	struct snd_pcm *pcm;
 -	struct intel_hdmi_lpe_audio_pdata *pdata;
 -	int irq;
 -	struct resource *res_mmio;
 -	int i, ret;
 -
 -	pdata = pdev->dev.platform_data;
 -	if (!pdata) {
 -		dev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);
 -		return -EINVAL;
 -	}
 +	struct snd_card *card;
 +	struct snd_intelhad *intelhaddata;
 +	struct had_pvt_data *had_stream;
  
 -	/* get resources */
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "Could not get irq resource\n");
 -		return -ENODEV;
 -	}
 +	pr_debug("Enter %s\n", __func__);
  
 -	res_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res_mmio) {
 -		dev_err(&pdev->dev, "Could not get IO_MEM resources\n");
 -		return -ENXIO;
 -	}
 +	pr_debug("hdmi_audio_probe dma_mask: %p\n", devptr->dev.dma_mask);
  
 -	/* create a card instance with ALSA framework */
 -	ret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,
 -			   THIS_MODULE, sizeof(*ctx), &card);
 -	if (ret)
 -		return ret;
 -
 -	ctx = card->private_data;
 -	spin_lock_init(&ctx->had_spinlock);
 -	mutex_init(&ctx->mutex);
 -	ctx->connected = false;
 -	ctx->dev = &pdev->dev;
 -	ctx->card = card;
 -	ctx->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 -	strcpy(card->driver, INTEL_HAD);
 -	strcpy(card->shortname, INTEL_HAD);
 -
 -	ctx->irq = -1;
 -	ctx->tmds_clock_speed = DIS_SAMPLE_RATE_148_5;
 -	INIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);
 -
 -	card->private_free = hdmi_lpe_audio_free;
 -
 -	/* assume pipe A as default */
 -	ctx->had_config_offset = AUDIO_HDMI_CONFIG_A;
 -
 -	platform_set_drvdata(pdev, ctx);
 -
 -	dev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",
 -		__func__, (unsigned int)res_mmio->start,
 -		(unsigned int)res_mmio->end);
 -
 -	ctx->mmio_start = ioremap_nocache(res_mmio->start,
 -					  (size_t)(resource_size(res_mmio)));
 -	if (!ctx->mmio_start) {
 -		dev_err(&pdev->dev, "Could not get ioremap\n");
 -		ret = -EACCES;
 -		goto err;
 -	}
 +	/* allocate memory for saving internal context and working */
 +	intelhaddata = kzalloc(sizeof(*intelhaddata), GFP_KERNEL);
 +	if (!intelhaddata)
 +		return -ENOMEM;
  
 -	/* setup interrupt handler */
 -	ret = request_irq(irq, display_pipe_interrupt_handler, 0,
 -			  pdev->name, ctx);
 -	if (ret < 0) {
 -		dev_err(&pdev->dev, "request_irq failed\n");
 -		goto err;
 +	had_stream = kzalloc(sizeof(*had_stream), GFP_KERNEL);
 +	if (!had_stream) {
 +		retval = -ENOMEM;
 +		goto free_haddata;
  	}
  
 -	ctx->irq = irq;
 +	spin_lock_init(&intelhaddata->had_spinlock);
 +	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 +	pr_debug("%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 +			__func__, __LINE__);
  
 -	ret = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 -			  MAX_CAP_STREAMS, &pcm);
 -	if (ret)
 +	/* create a card instance with ALSA framework */
 +	retval = snd_card_new(&devptr->dev, hdmi_card_index, hdmi_card_id,
 +				THIS_MODULE, 0, &card);
 +
 +	if (retval)
 +		goto free_hadstream;
 +	intelhaddata->card = card;
 +	intelhaddata->card_id = hdmi_card_id;
 +	intelhaddata->card_index = card->number;
 +	intelhaddata->private_data = had_stream;
 +	intelhaddata->flag_underrun = 0;
 +	intelhaddata->aes_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
 +	strncpy(card->driver, INTEL_HAD, strlen(INTEL_HAD));
 +	strncpy(card->shortname, INTEL_HAD, strlen(INTEL_HAD));
 +
 +	retval = snd_pcm_new(card, INTEL_HAD, PCM_INDEX, MAX_PB_STREAMS,
 +						MAX_CAP_STREAMS, &pcm);
 +	if (retval)
  		goto err;
  
  	/* setup private data which can be retrieved when required */
* Unmerged path sound/x86/intel_hdmi_audio.c
