nfp: add helper for cleaning up vNICs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 71f8a116b5c4b4957c56a2f1a5bd2a7e19d6d400
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/71f8a116.failed

We will soon have to invoke more clean up for vNICs.
Move the cleanup callbacks into a helper.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 71f8a116b5c4b4957c56a2f1a5bd2a7e19d6d400)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index acc8cfe284f3,b0a6ec4fe097..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -373,13 -418,19 +373,19 @@@ err_free_prev
  	return err;
  }
  
+ static void nfp_net_pf_clean_vnic(struct nfp_pf *pf, struct nfp_net *nn)
+ {
+ 	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
+ 	nfp_net_clean(nn);
+ }
+ 
  static int
 -nfp_net_pf_spawn_vnics(struct nfp_pf *pf,
 -		       void __iomem *ctrl_bar, void __iomem *tx_bar,
 -		       void __iomem *rx_bar, int stride,
 -		       struct nfp_net_fw_version *fw_ver)
 +nfp_net_pf_spawn_netdevs(struct nfp_pf *pf,
 +			 void __iomem *ctrl_bar, void __iomem *tx_bar,
 +			 void __iomem *rx_bar, int stride,
 +			 struct nfp_net_fw_version *fw_ver)
  {
 -	unsigned int id, wanted_irqs, num_irqs, vnics_left, irqs_left;
 +	unsigned int id, wanted_irqs, num_irqs, ports_left, irqs_left;
  	struct nfp_net *nn;
  	int err;
  
@@@ -435,10 -486,8 +441,15 @@@
  	return 0;
  
  err_prev_deinit:
++<<<<<<< HEAD
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
 +	}
++=======
+ 	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
+ 		nfp_net_pf_clean_vnic(pf, nn);
++>>>>>>> 71f8a116b5c4 (nfp: add helper for cleaning up vNICs)
  	nfp_net_irqs_disable(pf->pdev);
  err_vec_free:
  	kfree(pf->irq_entries);
@@@ -463,63 -552,82 +474,68 @@@ static void nfp_net_refresh_netdevs(str
  {
  	struct nfp_pf *pf = container_of(work, struct nfp_pf,
  					 port_refresh_work);
 -	struct nfp_eth_table *eth_table;
  	struct nfp_net *nn, *next;
 -	struct nfp_port *port;
  
 -	mutex_lock(&pf->lock);
 +	mutex_lock(&pf->port_lock);
  
  	/* Check for nfp_net_pci_remove() racing against us */
 -	if (list_empty(&pf->vnics))
 -		goto out;
 -
 -	/* Update state of all ports */
 -	rtnl_lock();
 -	list_for_each_entry(port, &pf->ports, port_list)
 -		clear_bit(NFP_PORT_CHANGED, &port->flags);
 -
 -	eth_table = nfp_eth_read_ports(pf->cpp);
 -	if (!eth_table) {
 -		list_for_each_entry(port, &pf->ports, port_list)
 -			if (__nfp_port_get_eth_port(port))
 -				set_bit(NFP_PORT_CHANGED, &port->flags);
 -		rtnl_unlock();
 -		nfp_err(pf->cpp, "Error refreshing port config!\n");
 +	if (list_empty(&pf->ports))
  		goto out;
 -	}
  
 -	list_for_each_entry(port, &pf->ports, port_list)
 -		if (__nfp_port_get_eth_port(port))
 -			nfp_net_eth_port_update(pf->cpp, port, eth_table);
 -	rtnl_unlock();
 +	list_for_each_entry_safe(nn, next, &pf->ports, port_list) {
 +		if (!nn->eth_port) {
 +			nfp_warn(pf->cpp, "Warning: port not present after reconfig\n");
 +			continue;
 +		}
 +		if (!nn->eth_port->override_changed)
 +			continue;
  
 -	kfree(eth_table);
++<<<<<<< HEAD
 +		nn_warn(nn, "Port config changed, unregistering. Reboot required before port will be operational again.\n");
  
 -	/* Shoot off the ports which became invalid */
 -	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {
 -		if (!nn->port || nn->port->type != NFP_PORT_INVALID)
 -			continue;
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->dp.netdev);
  
 +		list_del(&nn->port_list);
 +		pf->num_netdevs--;
 +		nfp_net_netdev_free(nn);
++=======
+ 		nfp_net_pf_clean_vnic(pf, nn);
+ 		nfp_net_pf_free_vnic(pf, nn);
++>>>>>>> 71f8a116b5c4 (nfp: add helper for cleaning up vNICs)
  	}
  
 -	if (list_empty(&pf->vnics))
 +	if (list_empty(&pf->ports))
  		nfp_net_pci_remove_finish(pf);
  out:
 -	mutex_unlock(&pf->lock);
 +	mutex_unlock(&pf->port_lock);
  }
  
 -void nfp_net_refresh_port_table(struct nfp_port *port)
 +void nfp_net_refresh_port_config(struct nfp_net *nn)
  {
 -	struct nfp_pf *pf = port->app->pf;
 +	struct nfp_pf *pf = pci_get_drvdata(nn->pdev);
 +	struct nfp_eth_table *old_table;
  
 -	set_bit(NFP_PORT_CHANGED, &port->flags);
 -
 -	schedule_work(&pf->port_refresh_work);
 -}
 +	ASSERT_RTNL();
  
 -int nfp_net_refresh_eth_port(struct nfp_port *port)
 -{
 -	struct nfp_cpp *cpp = port->app->cpp;
 -	struct nfp_eth_table *eth_table;
 -	int ret;
 +	old_table = pf->eth_tbl;
  
 -	clear_bit(NFP_PORT_CHANGED, &port->flags);
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nfp_net_link_changed_read_clear(nn);
  
 -	eth_table = nfp_eth_read_ports(cpp);
 -	if (!eth_table) {
 -		set_bit(NFP_PORT_CHANGED, &port->flags);
 -		nfp_err(cpp, "Error refreshing port state table!\n");
 -		return -EIO;
 +	pf->eth_tbl = nfp_eth_read_ports(pf->cpp);
 +	if (!pf->eth_tbl) {
 +		pf->eth_tbl = old_table;
 +		nfp_err(pf->cpp, "Error refreshing port config!\n");
 +		return;
  	}
  
 -	ret = nfp_net_eth_port_update(cpp, port, eth_table);
 +	list_for_each_entry(nn, &pf->ports, port_list)
 +		nn->eth_port = nfp_net_find_port(pf, nn->eth_port->eth_index);
  
 -	kfree(eth_table);
 +	kfree(old_table);
  
 -	return ret;
 +	schedule_work(&pf->port_refresh_work);
  }
  
  /*
@@@ -645,17 -758,14 +661,22 @@@ void nfp_net_pci_remove(struct nfp_pf *
  {
  	struct nfp_net *nn;
  
 -	mutex_lock(&pf->lock);
 -	if (list_empty(&pf->vnics))
 +	mutex_lock(&pf->port_lock);
 +	if (list_empty(&pf->ports))
  		goto out;
  
++<<<<<<< HEAD
 +	list_for_each_entry(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +
 +		nfp_net_netdev_clean(nn->netdev);
 +	}
++=======
+ 	list_for_each_entry(nn, &pf->vnics, vnic_list)
+ 		nfp_net_pf_clean_vnic(pf, nn);
++>>>>>>> 71f8a116b5c4 (nfp: add helper for cleaning up vNICs)
  
 -	nfp_net_pf_free_vnics(pf);
 +	nfp_net_pf_free_netdevs(pf);
  
  	nfp_net_pci_remove_finish(pf);
  out:
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
