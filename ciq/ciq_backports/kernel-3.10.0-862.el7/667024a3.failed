qla2xxx: Remove verbose messages in target mode.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Remove verbose messages in target mode (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 98.95%
commit-author Arun Easi <arun.easi@qlogic.com>
commit 667024a36549186ce334c1027e434b45cf2c943d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/667024a3.failed

Turning logging bits for target mode ON dumps quite a lot verbose
messages, remove those and change some of the IO path logging to
use IO bits.

	Signed-off-by: Arun Easi <arun.easi@qlogic.com>
	Signed-off-by: Saurav Kashyap <saurav.kashyap@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 667024a36549186ce334c1027e434b45cf2c943d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 5f7b0de5e170,1503cf4120cf..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1453,16 -1360,43 +1453,14 @@@ static int qlt_pci_map_calc_cnt(struct 
  
  	prm->cmd->sg_mapped = 1;
  
 -	if (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL) {
 -		/*
 -		 * If greater than four sg entries then we need to allocate
 -		 * the continuation entries
 -		 */
 -		if (prm->seg_cnt > prm->tgt->datasegs_per_cmd)
 -			prm->req_cnt += DIV_ROUND_UP(prm->seg_cnt -
 -			prm->tgt->datasegs_per_cmd,
 -			prm->tgt->datasegs_per_cont);
 -	} else {
 -		/* DIF */
 -		if ((cmd->se_cmd.prot_op == TARGET_PROT_DIN_INSERT) ||
 -		    (cmd->se_cmd.prot_op == TARGET_PROT_DOUT_STRIP)) {
 -			prm->seg_cnt = DIV_ROUND_UP(cmd->bufflen, cmd->blk_sz);
 -			prm->tot_dsds = prm->seg_cnt;
 -		} else
 -			prm->tot_dsds = prm->seg_cnt;
 -
 -		if (cmd->prot_sg_cnt) {
 -			prm->prot_sg      = cmd->prot_sg;
 -			prm->prot_seg_cnt = pci_map_sg(prm->tgt->ha->pdev,
 -				cmd->prot_sg, cmd->prot_sg_cnt,
 -				cmd->dma_data_direction);
 -			if (unlikely(prm->prot_seg_cnt == 0))
 -				goto out_err;
 -
 -			if ((cmd->se_cmd.prot_op == TARGET_PROT_DIN_INSERT) ||
 -			    (cmd->se_cmd.prot_op == TARGET_PROT_DOUT_STRIP)) {
 -				/* Dif Bundling not support here */
 -				prm->prot_seg_cnt = DIV_ROUND_UP(cmd->bufflen,
 -								cmd->blk_sz);
 -				prm->tot_dsds += prm->prot_seg_cnt;
 -			} else
 -				prm->tot_dsds += prm->prot_seg_cnt;
 -		}
 -	}
 +	/*
 +	 * If greater than four sg entries then we need to allocate
 +	 * the continuation entries
 +	 */
 +	if (prm->seg_cnt > prm->tgt->datasegs_per_cmd)
 +		prm->req_cnt += DIV_ROUND_UP(prm->seg_cnt -
 +		    prm->tgt->datasegs_per_cmd, prm->tgt->datasegs_per_cont);
  
- 	ql_dbg(ql_dbg_tgt, prm->cmd->vha, 0xe009, "seg_cnt=%d, req_cnt=%d\n",
- 	    prm->seg_cnt, prm->req_cnt);
  	return 0;
  
  out_err:
@@@ -1595,13 -1536,10 +1589,16 @@@ static int qlt_24xx_build_ctio_pkt(stru
  	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
  	pkt->exchange_addr = atio->u.isp24.exchange_addr;
  	pkt->u.status0.flags |= (atio->u.isp24.attr << 9);
 -	temp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
 -	pkt->u.status0.ox_id = cpu_to_le16(temp);
 +	pkt->u.status0.ox_id = swab16(atio->u.isp24.fcp_hdr.ox_id);
  	pkt->u.status0.relative_offset = cpu_to_le32(prm->cmd->offset);
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, vha, 0xe00c,
 +	    "qla_target(%d): handle(cmd) -> %08x, timeout %d, ox_id %#x\n",
 +	    vha->vp_idx, pkt->handle, QLA_TGT_TIMEOUT,
 +	    le16_to_cpu(pkt->u.status0.ox_id));
++=======
++>>>>>>> 667024a36549 (qla2xxx: Remove verbose messages in target mode.)
  	return 0;
  }
  
@@@ -1766,9 -1682,6 +1741,12 @@@ static int qlt_pre_xmit_response(struc
  		return QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED;
  	}
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, vha, 0xe011, "qla_target(%d): tag=%u\n",
 +	    vha->vp_idx, cmd->tag);
 +
++=======
++>>>>>>> 667024a36549 (qla2xxx: Remove verbose messages in target mode.)
  	prm->cmd = cmd;
  	prm->tgt = tgt;
  	prm->rq_result = scsi_status;
@@@ -2081,13 -2312,20 +2050,14 @@@ int qlt_xmit_response(struct qla_tgt_cm
  			struct ctio7_to_24xx *ctio =
  				(struct ctio7_to_24xx *)qlt_get_req_pkt(vha);
  
- 			ql_dbg(ql_dbg_tgt, vha, 0xe019,
- 			    "Building additional status packet\n");
+ 			ql_dbg(ql_dbg_io, vha, 0x305e,
+ 			    "Building additional status packet 0x%p.\n",
+ 			    ctio);
  
 -			/*
 -			 * T10Dif: ctio_crc2_to_fw overlay ontop of
 -			 * ctio7_to_24xx
 -			 */
  			memcpy(ctio, pkt, sizeof(*ctio));
 -			/* reset back to CTIO7 */
  			ctio->entry_count = 1;
 -			ctio->entry_type = CTIO_TYPE7;
  			ctio->dseg_count = 0;
 -			ctio->u.status1.flags &= ~__constant_cpu_to_le16(
 +			ctio->u.status1.flags &= ~cpu_to_le16(
  			    CTIO7_FLAGS_DATA_IN);
  
  			/* Real finish is ctio_m1's finish */
@@@ -2142,9 -2381,6 +2108,12 @@@ int qlt_rdy_to_xfer(struct qla_tgt_cmd 
  	if (qlt_issue_marker(vha, 0) != QLA_SUCCESS)
  		return -EIO;
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, vha, 0xe01b, "CTIO_start: vha(%d)",
 +	    (int)vha->vp_idx);
 +
++=======
++>>>>>>> 667024a36549 (qla2xxx: Remove verbose messages in target mode.)
  	/* Calculate number of entries and segments required */
  	if (qlt_pci_map_calc_cnt(&prm) != 0)
  		return -EAGAIN;
@@@ -2541,13 -2956,18 +2504,13 @@@ static void qlt_do_ctio_completion(stru
  				return;
  		}
  	}
 -skip_term:
  
  	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
- 		ql_dbg(ql_dbg_tgt, vha, 0xe01f, "Command %p finished\n", cmd);
+ 		;
  	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
 -		int rx_status = 0;
 -
  		cmd->state = QLA_TGT_STATE_DATA_IN;
  
 -		if (unlikely(status != CTIO_SUCCESS))
 -			rx_status = -EIO;
 -		else
 +		if (status == CTIO_SUCCESS)
  			cmd->write_data_transferred = 1;
  
  		ha->tgt.tgt_ops->handle_data(cmd);
@@@ -2680,12 -3064,8 +2643,17 @@@ static void qlt_do_work(struct work_str
  	    &atio->u.isp24.fcp_cmnd.add_cdb[
  	    atio->u.isp24.fcp_cmnd.add_cdb_len]));
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, vha, 0xe022,
 +	    "qla_target: START qla command: %p lun: 0x%04x (tag %d)\n",
 +	    cmd, cmd->unpacked_lun, cmd->tag);
 +
 +	ret = vha->hw->tgt.tgt_ops->handle_cmd(vha, cmd, cdb, data_length,
 +	    fcp_task_attr, data_dir, bidi);
++=======
+ 	ret = ha->tgt.tgt_ops->handle_cmd(vha, cmd, cdb, data_length,
+ 				          fcp_task_attr, data_dir, bidi);
++>>>>>>> 667024a36549 (qla2xxx: Remove verbose messages in target mode.)
  	if (ret != 0)
  		goto out_term;
  	/*
@@@ -2722,10 -3200,29 +2690,10 @@@ static int qlt_handle_cmd_for_atio(stru
  		return -EFAULT;
  	}
  
 -	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);
 -	if (unlikely(!sess)) {
 -		struct qla_tgt_sess_op *op = kzalloc(sizeof(struct qla_tgt_sess_op),
 -						     GFP_ATOMIC);
 -		if (!op)
 -			return -ENOMEM;
 -
 -		memcpy(&op->atio, atio, sizeof(*atio));
 -		op->vha = vha;
 -		INIT_WORK(&op->work, qlt_create_sess_from_atio);
 -		queue_work(qla_tgt_wq, &op->work);
 -		return 0;
 -	}
 -	/*
 -	 * Do kref_get() before returning + dropping qla_hw_data->hardware_lock.
 -	 */
 -	kref_get(&sess->se_sess->sess_kref);
 -
 -	cmd = qlt_get_tag(vha, sess, atio);
 +	cmd = kmem_cache_zalloc(qla_tgt_cmd_cachep, GFP_ATOMIC);
  	if (!cmd) {
- 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05e,
+ 		ql_dbg(ql_dbg_io, vha, 0x3062,
  		    "qla_target(%d): Allocation of cmd failed\n", vha->vp_idx);
 -		ha->tgt.tgt_ops->put_sess(sess);
  		return -ENOMEM;
  	}
  
@@@ -3652,23 -4131,9 +3616,26 @@@ static void qlt_24xx_atio_pkt(struct sc
  
  	switch (atio->u.raw.entry_type) {
  	case ATIO_TYPE7:
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe02d,
 +		    "ATIO_TYPE7 instance %d, lun %Lx, read/write %d/%d, "
 +		    "add_cdb_len %d, data_length %04x, s_id %x:%x:%x\n",
 +		    vha->vp_idx, atio->u.isp24.fcp_cmnd.lun,
 +		    atio->u.isp24.fcp_cmnd.rddata,
 +		    atio->u.isp24.fcp_cmnd.wrdata,
 +		    atio->u.isp24.fcp_cmnd.add_cdb_len,
 +		    be32_to_cpu(get_unaligned((uint32_t *)
 +			&atio->u.isp24.fcp_cmnd.add_cdb[
 +			atio->u.isp24.fcp_cmnd.add_cdb_len])),
 +		    atio->u.isp24.fcp_hdr.s_id[0],
 +		    atio->u.isp24.fcp_hdr.s_id[1],
 +		    atio->u.isp24.fcp_hdr.s_id[2]);
 +
++=======
++>>>>>>> 667024a36549 (qla2xxx: Remove verbose messages in target mode.)
  		if (unlikely(atio->u.isp24.exchange_addr ==
  		    ATIO_EXCHANGE_ADDRESS_UNKNOWN)) {
- 			ql_dbg(ql_dbg_tgt, vha, 0xe058,
+ 			ql_dbg(ql_dbg_io, vha, 0x3065,
  			    "qla_target(%d): ATIO_TYPE7 "
  			    "received with UNKNOWN exchange address, "
  			    "sending QUEUE_FULL\n", vha->vp_idx);
@@@ -3758,8 -4218,7 +3720,11 @@@ static void qlt_response_pkt(struct scs
  	case CTIO_TYPE7:
  	{
  		struct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe030, "CTIO_TYPE7: instance %d\n",
 +		    vha->vp_idx);
++=======
++>>>>>>> 667024a36549 (qla2xxx: Remove verbose messages in target mode.)
  		qlt_do_ctio_completion(vha, entry->handle,
  		    le16_to_cpu(entry->status)|(pkt->entry_status << 16),
  		    entry);
@@@ -3770,17 -4229,8 +3735,8 @@@
  	{
  		struct atio_from_isp *atio = (struct atio_from_isp *)pkt;
  		int rc;
- 		ql_dbg(ql_dbg_tgt, vha, 0xe031,
- 		    "ACCEPT_TGT_IO instance %d status %04x "
- 		    "lun %04x read/write %d data_length %04x "
- 		    "target_id %02x rx_id %04x\n ", vha->vp_idx,
- 		    le16_to_cpu(atio->u.isp2x.status),
- 		    le16_to_cpu(atio->u.isp2x.lun),
- 		    atio->u.isp2x.execution_codes,
- 		    le32_to_cpu(atio->u.isp2x.data_length), GET_TARGET_ID(ha,
- 		    atio), atio->u.isp2x.rx_id);
  		if (atio->u.isp2x.status !=
 -		    __constant_cpu_to_le16(ATIO_CDB_VALID)) {
 +		    cpu_to_le16(ATIO_CDB_VALID)) {
  			ql_dbg(ql_dbg_tgt, vha, 0xe05e,
  			    "qla_target(%d): ATIO with error "
  			    "status %x received\n", vha->vp_idx,
@@@ -3936,14 -4378,9 +3884,9 @@@ void qlt_async_event(uint16_t code, str
  	uint16_t *mailbox)
  {
  	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
  	int login_code;
  
- 	ql_dbg(ql_dbg_tgt, vha, 0xe039,
- 	    "scsi(%ld): ha state %d init_done %d oper_mode %d topo %d\n",
- 	    vha->host_no, atomic_read(&vha->loop_state), vha->flags.init_done,
- 	    ha->operating_mode, ha->current_topology);
- 
  	if (!ha->tgt.tgt_ops)
  		return;
  
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
