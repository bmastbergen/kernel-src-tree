net: sched: use tcf_exts_has_actions in tcf_exts_exec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: use tcf_exts_has_actions in tcf_exts_exec (Ivan Vecera) [1445420]
Rebuild_FUZZ: 95.05%
commit-author Jiri Pirko <jiri@mellanox.com>
commit af69afc551eb9f9b1f2cc3295e2dfcdaa1dc948d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/af69afc5.failed

Use the tcf_exts_has_actions helper instead or directly testing
exts->nr_actions in tcf_exts_exec.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit af69afc551eb9f9b1f2cc3295e2dfcdaa1dc948d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
diff --cc include/net/pkt_cls.h
index ddbf01b80b4c,322a2823cc6a..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -108,47 -143,92 +108,80 @@@ tcf_exts_is_available(struct tcf_exts *
  	return tcf_exts_is_predicative(exts);
  }
  
 -static inline void tcf_exts_to_list(const struct tcf_exts *exts,
 -				    struct list_head *actions)
 -{
 -#ifdef CONFIG_NET_CLS_ACT
 -	int i;
 -
 -	for (i = 0; i < exts->nr_actions; i++) {
 -		struct tc_action *a = exts->actions[i];
 -
 -		list_add_tail(&a->list, actions);
 -	}
 -#endif
 -}
 -
 -static inline void
 -tcf_exts_stats_update(const struct tcf_exts *exts,
 -		      u64 bytes, u64 packets, u64 lastuse)
 -{
 -#ifdef CONFIG_NET_CLS_ACT
 -	int i;
 -
 -	preempt_disable();
 -
 -	for (i = 0; i < exts->nr_actions; i++) {
 -		struct tc_action *a = exts->actions[i];
 -
 -		tcf_action_stats_update(a, bytes, packets, lastuse);
 -	}
 -
 -	preempt_enable();
 -#endif
 -}
 -
  /**
 - * tcf_exts_has_actions - check if at least one action is present
++<<<<<<< HEAD
 + * tcf_exts_exec - execute tc filter extensions
 + * @skb: socket buffer
   * @exts: tc filter extensions handle
 + * @res: desired result
   *
 - * Returns true if at least one action is present.
 + * Executes all configured extensions. Returns 0 on a normal execution,
 + * a negative number if the filter must be considered unmatched or
 + * a positive action code (TC_ACT_*) which must be returned to the
 + * underlying layer.
   */
 -static inline bool tcf_exts_has_actions(struct tcf_exts *exts)
 +static inline int
 +tcf_exts_exec(struct sk_buff *skb, struct tcf_exts *exts,
 +	       struct tcf_result *res)
  {
  #ifdef CONFIG_NET_CLS_ACT
 -	return exts->nr_actions;
 -#else
 -	return false;
 +	if (!list_empty(&exts->actions))
 +		return tcf_action_exec(skb, &exts->actions, res);
  #endif
 +	return 0;
  }
  
 -/**
 - * tcf_exts_has_one_action - check if exactly one action is present
++=======
++ * tcf_exts_has_actions - check if at least one action is present
+  * @exts: tc filter extensions handle
+  *
 - * Returns true if exactly one action is present.
++ * Returns true if at least one action is present.
+  */
 -static inline bool tcf_exts_has_one_action(struct tcf_exts *exts)
++static inline bool tcf_exts_has_actions(struct tcf_exts *exts)
+ {
++>>>>>>> af69afc551eb (net: sched: use tcf_exts_has_actions in tcf_exts_exec)
  #ifdef CONFIG_NET_CLS_ACT
 -	return exts->nr_actions == 1;
 -#else
 -	return false;
 -#endif
 -}
 +
 +#define tc_no_actions(_exts) \
 +	(list_empty(&(_exts)->actions))
 +
 +#define tc_for_each_action(_a, _exts) \
 +	list_for_each_entry(_a, &(_exts)->actions, list)
 +
 +#define tc_single_action(_exts) \
 +	(list_is_singular(&(_exts)->actions))
 +
 +#else /* CONFIG_NET_CLS_ACT */
 +
 +#define tc_no_actions(_exts) true
 +#define tc_for_each_action(_a, _exts) while ((void)(_a), 0)
 +#define tc_single_action(_exts) false
 +
 +#endif /* CONFIG_NET_CLS_ACT */
  
+ /**
+  * tcf_exts_exec - execute tc filter extensions
+  * @skb: socket buffer
+  * @exts: tc filter extensions handle
+  * @res: desired result
+  *
+  * Executes all configured extensions. Returns 0 on a normal execution,
+  * a negative number if the filter must be considered unmatched or
+  * a positive action code (TC_ACT_*) which must be returned to the
+  * underlying layer.
+  */
+ static inline int
+ tcf_exts_exec(struct sk_buff *skb, struct tcf_exts *exts,
+ 	      struct tcf_result *res)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	if (tcf_exts_has_actions(exts))
+ 		return tcf_action_exec(skb, exts->actions, exts->nr_actions,
+ 				       res);
+ #endif
+ 	return 0;
+ }
+ 
  int tcf_exts_validate(struct net *net, struct tcf_proto *tp,
  		      struct nlattr **tb, struct nlattr *rate_tlv,
  		      struct tcf_exts *exts, bool ovr);
* Unmerged path include/net/pkt_cls.h
