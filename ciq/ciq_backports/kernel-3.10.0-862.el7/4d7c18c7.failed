GFS2: Set gl_object in inode lookup only after block type check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 4d7c18c7df89ef549f2de79b0faf873b49dea57a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4d7c18c7.failed

Before this patch, the inode glock's gl_object was set after a
reference was acquired, but before the block type was verified.
In cases where the block was unlinked, then freed and reused on
another node, a residule delete callback (delete_work) would try
to look up the inode, eventually failing the block check, but
only after it overwrites gl_object with a pointer to the wrong
inode. This patch moves the assignment of gl_object after the
block check so it won't be improperly overwritten.

Likewise, at the end of the function, gfs2_inode_lookup was
clearing gl_object after it unlocked the glock, which meant
another process might free the glock in the meantime. This
patch guards against that case.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 4d7c18c7df89ef549f2de79b0faf873b49dea57a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
diff --cc fs/gfs2/inode.c
index 82106f9575e9,fd6e1da3c5ab..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -144,7 -144,7 +144,11 @@@ struct inode *gfs2_inode_lookup(struct 
  		error = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);
  		if (unlikely(error))
  			goto fail;
++<<<<<<< HEAD
 +		ip->i_gl->gl_object = ip;
++=======
+ 		flush_delayed_work(&ip->i_gl->gl_work);
++>>>>>>> 4d7c18c7df89 (GFS2: Set gl_object in inode lookup only after block type check)
  
  		error = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);
  		if (unlikely(error))
@@@ -207,9 -206,9 +212,13 @@@ fail_refresh
  fail_put:
  	if (io_gl)
  		gfs2_glock_put(io_gl);
+ 	glock_clear_object(ip->i_gl, ip);
  	if (gfs2_holder_initialized(&i_gh))
  		gfs2_glock_dq_uninit(&i_gh);
++<<<<<<< HEAD
 +	ip->i_gl->gl_object = NULL;
++=======
++>>>>>>> 4d7c18c7df89 (GFS2: Set gl_object in inode lookup only after block type check)
  fail:
  	iget_failed(inode);
  	return ERR_PTR(error);
* Unmerged path fs/gfs2/inode.c
