tcp: avoid fragmenting peculiar skbs in SACK

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yuchung Cheng <ycheng@google.com>
commit b451e5d24ba6687c6f0e7319c727a709a1846c06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b451e5d2.failed

This patch fixes a bug in splitting an SKB during SACK
processing. Specifically if an skb contains multiple
packets and is only partially sacked in the higher sequences,
tcp_match_sack_to_skb() splits the skb and marks the second fragment
as SACKed.

The current code further attempts rounding up the first fragment
to MSS boundaries. But it misses a boundary condition when the
rounded-up fragment size (pkt_len) is exactly skb size.  Spliting
such an skb is pointless and causses a kernel warning and aborts
the SACK processing. This patch universally checks such over-split
before calling tcp_fragment to prevent these unnecessary warnings.

Fixes: adb92db857ee ("tcp: Make SACK code to split only at mss boundaries")
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Soheil Hassas Yeganeh <soheil@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b451e5d24ba6687c6f0e7319c727a709a1846c06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index b92dcfa17a8f,06e2dbc2b4a2..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -1193,14 -1179,15 +1193,19 @@@ static int tcp_match_skb_to_sack(struc
  		 */
  		if (pkt_len > mss) {
  			unsigned int new_len = (pkt_len / mss) * mss;
- 			if (!in_sack && new_len < pkt_len) {
+ 			if (!in_sack && new_len < pkt_len)
  				new_len += mss;
- 				if (new_len >= skb->len)
- 					return 0;
- 			}
  			pkt_len = new_len;
  		}
++<<<<<<< HEAD
 +		err = tcp_fragment(sk, skb, pkt_len, mss);
++=======
+ 
+ 		if (pkt_len >= skb->len && !in_sack)
+ 			return 0;
+ 
+ 		err = tcp_fragment(sk, skb, pkt_len, mss, GFP_ATOMIC);
++>>>>>>> b451e5d24ba6 (tcp: avoid fragmenting peculiar skbs in SACK)
  		if (err < 0)
  			return err;
  	}
* Unmerged path net/ipv4/tcp_input.c
