net: centralize net_device min/max MTU checking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] centralize net_device min/max MTU checking (Ivan Vecera) [1480542]
Rebuild_FUZZ: 94.38%
commit-author Jarod Wilson <jarod@redhat.com>
commit 61e84623ace35ce48975e8f90bbbac7557c43d61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/61e84623.failed

While looking into an MTU issue with sfc, I started noticing that almost
every NIC driver with an ndo_change_mtu function implemented almost
exactly the same range checks, and in many cases, that was the only
practical thing their ndo_change_mtu function was doing. Quite a few
drivers have either 68, 64, 60 or 46 as their minimum MTU value checked,
and then various sizes from 1500 to 65535 for their maximum MTU value. We
can remove a whole lot of redundant code here if we simple store min_mtu
and max_mtu in net_device, and check against those in net/core/dev.c's
dev_set_mtu().

In theory, there should be zero functional change with this patch, it just
puts the infrastructure in place. Subsequent patches will attempt to start
using said infrastructure, with theoretically zero change in
functionality.

CC: netdev@vger.kernel.org
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 61e84623ace35ce48975e8f90bbbac7557c43d61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index ac042b4e583c,fbdf923af4d3..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1523,11 -1427,210 +1523,218 @@@ enum netdev_priv_flags 
  #define IFF_RXFH_CONFIGURED		IFF_RXFH_CONFIGURED
  #define IFF_MACSEC			IFF_MACSEC
  
++<<<<<<< HEAD
 +/*
 + *	The DEVICE structure.
 + *	Actually, this whole structure is a big mistake.  It mixes I/O
 + *	data with strictly "high-level" data, and it has to know about
 + *	almost every data structure used in the INET module.
++=======
+ /**
+  *	struct net_device - The DEVICE structure.
+  *		Actually, this whole structure is a big mistake.  It mixes I/O
+  *		data with strictly "high-level" data, and it has to know about
+  *		almost every data structure used in the INET module.
+  *
+  *	@name:	This is the first field of the "visible" part of this structure
+  *		(i.e. as seen by users in the "Space.c" file).  It is the name
+  *	 	of the interface.
+  *
+  *	@name_hlist: 	Device name hash chain, please keep it close to name[]
+  *	@ifalias:	SNMP alias
+  *	@mem_end:	Shared memory end
+  *	@mem_start:	Shared memory start
+  *	@base_addr:	Device I/O address
+  *	@irq:		Device IRQ number
+  *
+  *	@carrier_changes:	Stats to monitor carrier on<->off transitions
+  *
+  *	@state:		Generic network queuing layer state, see netdev_state_t
+  *	@dev_list:	The global list of network devices
+  *	@napi_list:	List entry used for polling NAPI devices
+  *	@unreg_list:	List entry  when we are unregistering the
+  *			device; see the function unregister_netdev
+  *	@close_list:	List entry used when we are closing the device
+  *	@ptype_all:     Device-specific packet handlers for all protocols
+  *	@ptype_specific: Device-specific, protocol-specific packet handlers
+  *
+  *	@adj_list:	Directly linked devices, like slaves for bonding
+  *	@all_adj_list:	All linked devices, *including* neighbours
+  *	@features:	Currently active device features
+  *	@hw_features:	User-changeable features
+  *
+  *	@wanted_features:	User-requested features
+  *	@vlan_features:		Mask of features inheritable by VLAN devices
+  *
+  *	@hw_enc_features:	Mask of features inherited by encapsulating devices
+  *				This field indicates what encapsulation
+  *				offloads the hardware is capable of doing,
+  *				and drivers will need to set them appropriately.
+  *
+  *	@mpls_features:	Mask of features inheritable by MPLS
+  *
+  *	@ifindex:	interface index
+  *	@group:		The group the device belongs to
+  *
+  *	@stats:		Statistics struct, which was left as a legacy, use
+  *			rtnl_link_stats64 instead
+  *
+  *	@rx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@tx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@rx_nohandler:	nohandler dropped packets by core network on
+  *			inactive devices, do not use this in drivers
+  *
+  *	@wireless_handlers:	List of functions to handle Wireless Extensions,
+  *				instead of ioctl,
+  *				see <net/iw_handler.h> for details.
+  *	@wireless_data:	Instance data managed by the core of wireless extensions
+  *
+  *	@netdev_ops:	Includes several pointers to callbacks,
+  *			if one wants to override the ndo_*() functions
+  *	@ethtool_ops:	Management operations
+  *	@ndisc_ops:	Includes callbacks for different IPv6 neighbour
+  *			discovery handling. Necessary for e.g. 6LoWPAN.
+  *	@header_ops:	Includes callbacks for creating,parsing,caching,etc
+  *			of Layer 2 headers.
+  *
+  *	@flags:		Interface flags (a la BSD)
+  *	@priv_flags:	Like 'flags' but invisible to userspace,
+  *			see if.h for the definitions
+  *	@gflags:	Global flags ( kept as legacy )
+  *	@padded:	How much padding added by alloc_netdev()
+  *	@operstate:	RFC2863 operstate
+  *	@link_mode:	Mapping policy to operstate
+  *	@if_port:	Selectable AUI, TP, ...
+  *	@dma:		DMA channel
+  *	@mtu:		Interface MTU value
+  *	@min_mtu:	Interface Minimum MTU value
+  *	@max_mtu:	Interface Maximum MTU value
+  *	@type:		Interface hardware type
+  *	@hard_header_len: Maximum hardware header length.
+  *
+  *	@needed_headroom: Extra headroom the hardware may need, but not in all
+  *			  cases can this be guaranteed
+  *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
+  *			  cases can this be guaranteed. Some cases also use
+  *			  LL_MAX_HEADER instead to allocate the skb
+  *
+  *	interface address info:
+  *
+  * 	@perm_addr:		Permanent hw address
+  * 	@addr_assign_type:	Hw address assignment type
+  * 	@addr_len:		Hardware address length
+  *	@neigh_priv_len:	Used in neigh_alloc()
+  * 	@dev_id:		Used to differentiate devices that share
+  * 				the same link layer address
+  * 	@dev_port:		Used to differentiate devices that share
+  * 				the same function
+  *	@addr_list_lock:	XXX: need comments on this one
+  *	@uc_promisc:		Counter that indicates promiscuous mode
+  *				has been enabled due to the need to listen to
+  *				additional unicast addresses in a device that
+  *				does not implement ndo_set_rx_mode()
+  *	@uc:			unicast mac addresses
+  *	@mc:			multicast mac addresses
+  *	@dev_addrs:		list of device hw addresses
+  *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
+  *	@promiscuity:		Number of times the NIC is told to work in
+  *				promiscuous mode; if it becomes 0 the NIC will
+  *				exit promiscuous mode
+  *	@allmulti:		Counter, enables or disables allmulticast mode
+  *
+  *	@vlan_info:	VLAN info
+  *	@dsa_ptr:	dsa specific data
+  *	@tipc_ptr:	TIPC specific data
+  *	@atalk_ptr:	AppleTalk link
+  *	@ip_ptr:	IPv4 specific data
+  *	@dn_ptr:	DECnet specific data
+  *	@ip6_ptr:	IPv6 specific data
+  *	@ax25_ptr:	AX.25 specific data
+  *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
+  *
+  *	@last_rx:	Time of last Rx
+  *	@dev_addr:	Hw address (before bcast,
+  *			because most packets are unicast)
+  *
+  *	@_rx:			Array of RX queues
+  *	@num_rx_queues:		Number of RX queues
+  *				allocated at register_netdev() time
+  *	@real_num_rx_queues: 	Number of RX queues currently active in device
+  *
+  *	@rx_handler:		handler for received packets
+  *	@rx_handler_data: 	XXX: need comments on this one
+  *	@ingress_queue:		XXX: need comments on this one
+  *	@broadcast:		hw bcast address
+  *
+  *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
+  *			indexed by RX queue number. Assigned by driver.
+  *			This must only be set if the ndo_rx_flow_steer
+  *			operation is defined
+  *	@index_hlist:		Device index hash chain
+  *
+  *	@_tx:			Array of TX queues
+  *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
+  *	@real_num_tx_queues: 	Number of TX queues currently active in device
+  *	@qdisc:			Root qdisc from userspace point of view
+  *	@tx_queue_len:		Max frames per queue allowed
+  *	@tx_global_lock: 	XXX: need comments on this one
+  *
+  *	@xps_maps:	XXX: need comments on this one
+  *
+  *	@watchdog_timeo:	Represents the timeout that is used by
+  *				the watchdog (see dev_watchdog())
+  *	@watchdog_timer:	List of timers
+  *
+  *	@pcpu_refcnt:		Number of references to this device
+  *	@todo_list:		Delayed register/unregister
+  *	@link_watch_list:	XXX: need comments on this one
+  *
+  *	@reg_state:		Register/unregister state machine
+  *	@dismantle:		Device is going to be freed
+  *	@rtnl_link_state:	This enum represents the phases of creating
+  *				a new link
+  *
+  *	@destructor:		Called from unregister,
+  *				can be used to call free_netdev
+  *	@npinfo:		XXX: need comments on this one
+  * 	@nd_net:		Network namespace this network device is inside
+  *
+  * 	@ml_priv:	Mid-layer private
+  * 	@lstats:	Loopback statistics
+  * 	@tstats:	Tunnel statistics
+  * 	@dstats:	Dummy statistics
+  * 	@vstats:	Virtual ethernet statistics
+  *
+  *	@garp_port:	GARP
+  *	@mrp_port:	MRP
+  *
+  *	@dev:		Class/net/name entry
+  *	@sysfs_groups:	Space for optional device, statistics and wireless
+  *			sysfs groups
+  *
+  *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
+  *	@rtnl_link_ops:	Rtnl_link_ops
+  *
+  *	@gso_max_size:	Maximum size of generic segmentation offload
+  *	@gso_max_segs:	Maximum number of segments that can be passed to the
+  *			NIC for GSO
+  *
+  *	@dcbnl_ops:	Data Center Bridging netlink ops
+  *	@num_tc:	Number of traffic classes in the net device
+  *	@tc_to_txq:	XXX: need comments on this one
+  *	@prio_tc_map	XXX: need comments on this one
+  *
+  *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
+  *
+  *	@priomap:	XXX: need comments on this one
+  *	@phydev:	Physical device may attach itself
+  *			for hardware timestamping
+  *
+  *	@qdisc_tx_busylock: lockdep class annotating Qdisc->busylock spinlock
+  *	@qdisc_running_key: lockdep class annotating Qdisc->running seqcount
++>>>>>>> 61e84623ace3 (net: centralize net_device min/max MTU checking)
   *
   *	@proto_down:	protocol port state information can be sent to the
   *			switch driver and used to set the phys state of the
@@@ -1571,69 -1666,73 +1778,77 @@@ struct net_device 
  	struct list_head	dev_list;
  	struct list_head	napi_list;
  	struct list_head	unreg_list;
 -	struct list_head	close_list;
 -	struct list_head	ptype_all;
 -	struct list_head	ptype_specific;
 -
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} adj_list;
 +	struct list_head	upper_dev_list; /* List of upper devices */
  
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} all_adj_list;
  
 +	/* currently active device features */
  	netdev_features_t	features;
 +	/* user-changeable features */
  	netdev_features_t	hw_features;
 +	/* user-requested features */
  	netdev_features_t	wanted_features;
 +	/* mask of features inheritable by VLAN devices */
  	netdev_features_t	vlan_features;
 +	/* mask of features inherited by encapsulating devices
 +	 * This field indicates what encapsulation offloads
 +	 * the hardware is capable of doing, and drivers will
 +	 * need to set them appropriately.
 +	 */
  	netdev_features_t	hw_enc_features;
 +	/* mask of fetures inheritable by MPLS */
  	netdev_features_t	mpls_features;
 -	netdev_features_t	gso_partial_features;
  
 +	/* Interface index. Unique device identifier	*/
  	int			ifindex;
 -	int			group;
 +	int			iflink;
  
  	struct net_device_stats	stats;
 -
 -	atomic_long_t		rx_dropped;
 -	atomic_long_t		tx_dropped;
 -	atomic_long_t		rx_nohandler;
 +	atomic_long_t		rx_dropped; /* dropped packets by core network
 +					     * Do not use this in drivers.
 +					     */
  
  #ifdef CONFIG_WIRELESS_EXT
 -	const struct iw_handler_def *wireless_handlers;
 -	struct iw_public_data	*wireless_data;
 +	/* List of functions to handle Wireless Extensions (instead of ioctl).
 +	 * See <net/iw_handler.h> for details. Jean II */
 +	const struct iw_handler_def *	wireless_handlers;
 +	/* Instance data managed by the core of Wireless Extensions. */
 +	struct iw_public_data *	wireless_data;
  #endif
 +	/* Management operations */
  	const struct net_device_ops *netdev_ops;
  	const struct ethtool_ops *ethtool_ops;
 -#ifdef CONFIG_NET_SWITCHDEV
 -	const struct switchdev_ops *switchdev_ops;
 -#endif
 -#ifdef CONFIG_NET_L3_MASTER_DEV
 -	const struct l3mdev_ops	*l3mdev_ops;
 -#endif
 -#if IS_ENABLED(CONFIG_IPV6)
 -	const struct ndisc_ops *ndisc_ops;
 -#endif
  
 +	/* Hardware header description */
  	const struct header_ops *header_ops;
  
 -	unsigned int		flags;
 -	unsigned int		priv_flags;
 -
 +	unsigned int		flags;	/* interface flags (a la BSD)	*/
 +	unsigned int		priv_flags; /* Like 'flags' but invisible to userspace.
 +					     * See if.h for definitions. */
  	unsigned short		gflags;
 -	unsigned short		padded;
 +	unsigned short		padded;	/* How much padding added by alloc_netdev() */
  
 -	unsigned char		operstate;
 -	unsigned char		link_mode;
 +	unsigned char		operstate; /* RFC2863 operstate */
 +	unsigned char		link_mode; /* mapping policy to operstate */
  
 -	unsigned char		if_port;
 -	unsigned char		dma;
 +	unsigned char		if_port;	/* Selectable AUI, TP,..*/
 +	unsigned char		dma;		/* DMA channel		*/
  
++<<<<<<< HEAD
 +	unsigned int		mtu;	/* interface MTU value		*/
 +	unsigned short		type;	/* interface hardware type	*/
 +	unsigned short		hard_header_len;	/* hardware hdr length	*/
++=======
+ 	unsigned int		mtu;
+ 	unsigned int		min_mtu;
+ 	unsigned int		max_mtu;
+ 	unsigned short		type;
+ 	unsigned short		hard_header_len;
++>>>>>>> 61e84623ace3 (net: centralize net_device min/max MTU checking)
  
 +	/* extra head- and tailroom the hardware may need, but not in all cases
 +	 * can this be guaranteed, especially tailroom. Some cases also use
 +	 * LL_MAX_HEADER instead to allocate the skb.
 +	 */
  	unsigned short		needed_headroom;
  	unsigned short		needed_tailroom;
  
* Unmerged path include/linux/netdevice.h
diff --git a/net/core/dev.c b/net/core/dev.c
index 54ad82302512..a42c5a27264f 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -6573,9 +6573,18 @@ int dev_set_mtu(struct net_device *dev, int new_mtu)
 	if (new_mtu == dev->mtu)
 		return 0;
 
-	/*	MTU must be positive.	 */
-	if (new_mtu < 0)
+	/* MTU must be positive, and in range */
+	if (new_mtu < 0 || new_mtu < dev->min_mtu) {
+		net_err_ratelimited("%s: Invalid MTU %d requested, hw min %d\n",
+				    dev->name, new_mtu, dev->min_mtu);
 		return -EINVAL;
+	}
+
+	if (dev->max_mtu > 0 && new_mtu > dev->max_mtu) {
+		net_err_ratelimited("%s: Invalid MTU %d requested, hw max %d\n",
+				    dev->name, new_mtu, dev->min_mtu);
+		return -EINVAL;
+	}
 
 	if (!netif_device_present(dev))
 		return -ENODEV;
