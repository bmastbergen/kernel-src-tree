s390/ptrace: guarded storage regset for the current task

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit f5bbd7219891364a6ba1231cb751905045fd4466
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f5bbd721.failed

The regset functions for guarded storage are supposed to work on
the current task as well. For task == current add the required
load and store instructions for the guarded storage control block.

	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit f5bbd7219891364a6ba1231cb751905045fd4466)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/ptrace.c
diff --cc arch/s390/kernel/ptrace.c
index 490e6f6a7017,252ed61a128b..000000000000
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@@ -1201,6 -1149,85 +1201,88 @@@ static int s390_system_call_set(struct 
  				  data, 0, sizeof(unsigned int));
  }
  
++<<<<<<< HEAD
++=======
+ static int s390_gs_cb_get(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  void *kbuf, void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data)
+ 		return -ENODATA;
+ 	if (target == current)
+ 		save_gs_cb(data);
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+ 				   data, 0, sizeof(struct gs_cb));
+ }
+ 
+ static int s390_gs_cb_set(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  const void *kbuf, const void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_cb;
+ 	int rc;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data) {
+ 		data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 		if (!data)
+ 			return -ENOMEM;
+ 		data->gsd = 25;
+ 		target->thread.gs_cb = data;
+ 		if (target == current)
+ 			__ctl_set_bit(2, 4);
+ 	} else if (target == current) {
+ 		save_gs_cb(data);
+ 	}
+ 	rc = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				data, 0, sizeof(struct gs_cb));
+ 	if (target == current)
+ 		restore_gs_cb(data);
+ 	return rc;
+ }
+ 
+ static int s390_gs_bc_get(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  void *kbuf, void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_bc_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data)
+ 		return -ENODATA;
+ 	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+ 				   data, 0, sizeof(struct gs_cb));
+ }
+ 
+ static int s390_gs_bc_set(struct task_struct *target,
+ 			  const struct user_regset *regset,
+ 			  unsigned int pos, unsigned int count,
+ 			  const void *kbuf, const void __user *ubuf)
+ {
+ 	struct gs_cb *data = target->thread.gs_bc_cb;
+ 
+ 	if (!MACHINE_HAS_GS)
+ 		return -ENODEV;
+ 	if (!data) {
+ 		data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 		if (!data)
+ 			return -ENOMEM;
+ 		target->thread.gs_bc_cb = data;
+ 	}
+ 	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				  data, 0, sizeof(struct gs_cb));
+ }
+ 
++>>>>>>> f5bbd7219891 (s390/ptrace: guarded storage regset for the current task)
  static const struct user_regset s390_regsets[] = {
  	{
  		.core_note_type = NT_PRSTATUS,
* Unmerged path arch/s390/kernel/ptrace.c
