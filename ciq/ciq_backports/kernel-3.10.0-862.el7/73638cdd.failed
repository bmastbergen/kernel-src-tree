Drivers: hv: vmbus: Move the check for hypercall page setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Move the check for hypercall page setup (Vitaly Kuznetsov) [1410023]
Rebuild_FUZZ: 87.62%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 73638cddaad861a5ebb2b119d8b318d4bded8f8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/73638cdd.failed

As part of the effort to separate out architecture specific code, move the
check for detecting if the hypercall page is setup.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 73638cddaad861a5ebb2b119d8b318d4bded8f8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
#	arch/x86/include/asm/mshyperv.h
#	drivers/hv/hv.c
diff --cc arch/x86/hyperv/hv_init.c
index b5c8e04deacb,d289bc29d282..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -104,3 -209,44 +104,47 @@@ u64 hv_do_hypercall(u64 control, void *
  #endif /* !x86_64 */
  }
  EXPORT_SYMBOL_GPL(hv_do_hypercall);
++<<<<<<< HEAD
++=======
+ 
+ void hyperv_report_panic(struct pt_regs *regs)
+ {
+ 	static bool panic_reported;
+ 
+ 	/*
+ 	 * We prefer to report panic on 'die' chain as we have proper
+ 	 * registers to report, but if we miss it (e.g. on BUG()) we need
+ 	 * to report it on 'panic'.
+ 	 */
+ 	if (panic_reported)
+ 		return;
+ 	panic_reported = true;
+ 
+ 	wrmsrl(HV_X64_MSR_CRASH_P0, regs->ip);
+ 	wrmsrl(HV_X64_MSR_CRASH_P1, regs->ax);
+ 	wrmsrl(HV_X64_MSR_CRASH_P2, regs->bx);
+ 	wrmsrl(HV_X64_MSR_CRASH_P3, regs->cx);
+ 	wrmsrl(HV_X64_MSR_CRASH_P4, regs->dx);
+ 
+ 	/*
+ 	 * Let Hyper-V know there is crash data available
+ 	 */
+ 	wrmsrl(HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_CRASH_NOTIFY);
+ }
+ EXPORT_SYMBOL_GPL(hyperv_report_panic);
+ 
+ bool hv_is_hypercall_page_setup(void)
+ {
+ 	union hv_x64_msr_hypercall_contents hypercall_msr;
+ 
+ 	/* Check if the hypercall page is setup */
+ 	hypercall_msr.as_uint64 = 0;
+ 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
+ 
+ 	if (!hypercall_msr.enable)
+ 		return false;
+ 
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(hv_is_hypercall_page_setup);
++>>>>>>> 73638cddaad8 (Drivers: hv: vmbus: Move the check for hypercall page setup)
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,c843ef64defe..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -85,5 -114,7 +85,10 @@@ void hv_remove_crash_handler(void)
  
  #if IS_ENABLED(CONFIG_HYPERV)
  void hyperv_init(void);
++<<<<<<< HEAD
++=======
+ void hyperv_report_panic(struct pt_regs *regs);
+ bool hv_is_hypercall_page_setup(void);
++>>>>>>> 73638cddaad8 (Drivers: hv: vmbus: Move the check for hypercall page setup)
  #endif
  #endif
diff --cc drivers/hv/hv.c
index f6a591c69dfd,d28a8731baa0..000000000000
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@@ -146,8 -49,6 +146,11 @@@ static struct clocksource *hyperv_cs_ol
   */
  int hv_init(void)
  {
++<<<<<<< HEAD
 +	int max_leaf;
 +	union hv_x64_msr_hypercall_contents hypercall_msr;
++=======
++>>>>>>> 73638cddaad8 (Drivers: hv: vmbus: Move the check for hypercall page setup)
  
  	memset(hv_context.synic_event_page, 0, sizeof(void *) * NR_CPUS);
  	memset(hv_context.synic_message_page, 0,
@@@ -163,41 -64,10 +166,45 @@@
  	memset(hv_context.clk_evt, 0,
  	       sizeof(void *) * NR_CPUS);
  
++<<<<<<< HEAD
 +	max_leaf = query_hypervisor_info();
 +
 +
 +	/* See if the hypercall page is already set */
 +	hypercall_msr.as_uint64 = 0;
 +	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 +
 +	if (!hypercall_msr.enable)
++=======
+ 	if (!hv_is_hypercall_page_setup())
++>>>>>>> 73638cddaad8 (Drivers: hv: vmbus: Move the check for hypercall page setup)
  		return -ENOTSUPP;
  
 +#ifdef CONFIG_X86_64
 +	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
 +		union hv_x64_msr_hypercall_contents tsc_msr;
 +		void *va_tsc;
 +
 +		va_tsc = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
 +		if (!va_tsc)
 +			goto cleanup;
 +		hv_context.tsc_page = va_tsc;
 +
 +		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 +
 +		tsc_msr.enable = 1;
 +		tsc_msr.guest_physical_address = vmalloc_to_pfn(va_tsc);
 +
 +		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 +		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
 +		hyperv_cs_old = hyperv_cs;
 +		hyperv_cs = &hyperv_cs_tsc;
 +	}
 +#endif
  	return 0;
 +
 +cleanup:
 +	return -ENOTSUPP;
  }
  
  /*
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/include/asm/mshyperv.h
* Unmerged path drivers/hv/hv.c
