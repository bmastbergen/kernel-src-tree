Drivers: hv: vmbus: Define an APIs to manage interrupt state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Define an APIs to manage interrupt state (Mohammed Gamal) [1467258]
Rebuild_FUZZ: 87.85%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 37e11d5c7052a5ca55ef807731c75218ea341b4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/37e11d5c.failed

As part of cleaning up architecture specific code, define APIs
to manage interrupt state.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 37e11d5c7052a5ca55ef807731c75218ea341b4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,42505d1158d6..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -70,6 -99,61 +70,64 @@@ static inline  __u64 generate_guest_id(
  	return guest_id;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* Free the message slot and signal end-of-message if required */
+ static inline void vmbus_signal_eom(struct hv_message *msg, u32 old_msg_type)
+ {
+ 	/*
+ 	 * On crash we're reading some other CPU's message page and we need
+ 	 * to be careful: this other CPU may already had cleared the header
+ 	 * and the host may already had delivered some other message there.
+ 	 * In case we blindly write msg->header.message_type we're going
+ 	 * to lose it. We can still lose a message of the same type but
+ 	 * we count on the fact that there can only be one
+ 	 * CHANNELMSG_UNLOAD_RESPONSE and we don't care about other messages
+ 	 * on crash.
+ 	 */
+ 	if (cmpxchg(&msg->header.message_type, old_msg_type,
+ 		    HVMSG_NONE) != old_msg_type)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure the write to MessageType (ie set to
+ 	 * HVMSG_NONE) happens before we read the
+ 	 * MessagePending and EOMing. Otherwise, the EOMing
+ 	 * will not deliver any more messages since there is
+ 	 * no empty slot
+ 	 */
+ 	mb();
+ 
+ 	if (msg->header.message_flags.msg_pending) {
+ 		/*
+ 		 * This will cause message queue rescan to
+ 		 * possibly deliver another msg from the
+ 		 * hypervisor
+ 		 */
+ 		wrmsrl(HV_X64_MSR_EOM, 0);
+ 	}
+ }
+ 
+ #define hv_get_current_tick(tick) rdmsrl(HV_X64_MSR_TIME_REF_COUNT, tick)
+ #define hv_init_timer(timer, tick) wrmsrl(timer, tick)
+ #define hv_init_timer_config(config, val) wrmsrl(config, val)
+ 
+ #define hv_get_simp(val) rdmsrl(HV_X64_MSR_SIMP, val)
+ #define hv_set_simp(val) wrmsrl(HV_X64_MSR_SIMP, val)
+ 
+ #define hv_get_siefp(val) rdmsrl(HV_X64_MSR_SIEFP, val)
+ #define hv_set_siefp(val) wrmsrl(HV_X64_MSR_SIEFP, val)
+ 
+ #define hv_get_synic_state(val) rdmsrl(HV_X64_MSR_SCONTROL, val)
+ #define hv_set_synic_state(val) wrmsrl(HV_X64_MSR_SCONTROL, val)
+ 
+ #define hv_get_vp_index(index) rdmsrl(HV_X64_MSR_VP_INDEX, index)
+ 
+ #define hv_get_synint_state(int_num, val) rdmsrl(int_num, val)
+ #define hv_set_synint_state(int_num, val) wrmsrl(int_num, val)
+ 
++>>>>>>> 37e11d5c7052 (Drivers: hv: vmbus: Define an APIs to manage interrupt state)
  void hyperv_callback_vector(void);
  #ifdef CONFIG_TRACING
  #define trace_hyperv_callback_vector hyperv_callback_vector
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index f6a591c69dfd..b2d4e7815ec4 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -457,14 +457,16 @@ int hv_synic_init(unsigned int cpu)
 	wrmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);
 
 	/* Setup the shared SINT. */
-	rdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
+	hv_get_synint_state(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT,
+			    shared_sint.as_uint64);
 
 	shared_sint.as_uint64 = 0;
 	shared_sint.vector = HYPERVISOR_CALLBACK_VECTOR;
 	shared_sint.masked = false;
 	shared_sint.auto_eoi = true;
 
-	wrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
+	hv_set_synint_state(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT,
+			    shared_sint.as_uint64);
 
 	/* Enable the global synic bit */
 	rdmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);
@@ -565,13 +567,15 @@ int hv_synic_cleanup(unsigned int cpu)
 		hv_ce_setmode(CLOCK_EVT_MODE_SHUTDOWN,
 			      hv_context.clk_evt[cpu]);
 
-	rdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
+	hv_get_synint_state(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT,
+			    shared_sint.as_uint64);
 
 	shared_sint.masked = 1;
 
 	/* Need to correctly cleanup in the case of SMP!!! */
 	/* Disable the interrupt */
-	wrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
+	hv_set_synint_state(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT,
+			    shared_sint.as_uint64);
 
 	rdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);
 	simp.simp_enabled = 0;
