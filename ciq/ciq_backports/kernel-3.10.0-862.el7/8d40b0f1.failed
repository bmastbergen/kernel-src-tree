NFS filelayout:call GETDEVICEINFO after pnfs_layout_process completes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] nfs/filelayout: call GETDEVICEINFO after pnfs_layout_process completes (Steve Dickson) [1463784]
Rebuild_FUZZ: 97.84%
commit-author Andy Adamson <andros@netapp.com>
commit 8d40b0f14846f7d45c7c72d343fe62cb866dda34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8d40b0f1.failed

Fix a filelayout GETDEVICEINFO call hang triggered from the LAYOUTGET
pnfs_layout_process where the GETDEVICEINFO call is waiting for a
session slot, and the LAYOUGET call is waiting for pnfs_layout_process
to complete before freeing the slot GETDEVICEINFO is waiting for..

This occurs in testing against the pynfs pNFS server where the
the on-wire reply highest_slotid and slot id are zero, and the
target high slot id is 8 (negotiated in CREATE_SESSION).

The internal fore channel slot table max_slotid, the maximum allowed
table slotid value, has been reduced via nfs41_set_max_slotid_locked
 from 8 to 1.  Thus there is one slot (slotid 0) available for use but
it has not been freed by LAYOUTGET  proir to the GETDEVICEINFO request.

In order to ensure that layoutrecall callbacks are processed in the
correct order, nfs4_proc_layoutget processing needs to be finished
e.g. pnfs_layout_process) before giving up the slot that identifies
the layoutget (see referring_call_exists).

Move the filelayout_check_layout nfs4_find_get_device call outside of
the pnfs_layout_process call tree.

	Signed-off-by: Andy Adamson <andros@netapp.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 8d40b0f14846f7d45c7c72d343fe62cb866dda34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/filelayout/filelayout.c
diff --cc fs/nfs/filelayout/filelayout.c
index b859b153da3d,367f8eb19bfa..000000000000
--- a/fs/nfs/filelayout/filelayout.c
+++ b/fs/nfs/filelayout/filelayout.c
@@@ -532,49 -560,17 +532,25 @@@ filelayout_write_pagelist(struct nfs_pg
  	return PNFS_ATTEMPTED;
  }
  
- /*
-  * filelayout_check_layout()
-  *
-  * Make sure layout segment parameters are sane WRT the device.
-  * At this point no generic layer initialization of the lseg has occurred,
-  * and nothing has been added to the layout_hdr cache.
-  *
-  */
  static int
++<<<<<<< HEAD
 +filelayout_check_layout(struct pnfs_layout_hdr *lo,
 +			struct nfs4_filelayout_segment *fl,
 +			struct nfs4_layoutget_res *lgr,
 +			struct nfs4_deviceid *id,
 +			gfp_t gfp_flags)
++=======
+ filelayout_check_deviceid(struct pnfs_layout_hdr *lo,
+ 			  struct nfs4_filelayout_segment *fl,
+ 			  gfp_t gfp_flags)
++>>>>>>> 8d40b0f14846 (NFS filelayout:call GETDEVICEINFO after pnfs_layout_process completes)
  {
  	struct nfs4_deviceid_node *d;
  	struct nfs4_file_layout_dsaddr *dsaddr;
  	int status = -EINVAL;
  
- 	dprintk("--> %s\n", __func__);
- 
- 	/* FIXME: remove this check when layout segment support is added */
- 	if (lgr->range.offset != 0 ||
- 	    lgr->range.length != NFS4_MAX_UINT64) {
- 		dprintk("%s Only whole file layouts supported. Use MDS i/o\n",
- 			__func__);
- 		goto out;
- 	}
- 
- 	if (fl->pattern_offset > lgr->range.offset) {
- 		dprintk("%s pattern_offset %lld too large\n",
- 				__func__, fl->pattern_offset);
- 		goto out;
- 	}
- 
- 	if (!fl->stripe_unit) {
- 		dprintk("%s Invalid stripe unit (%u)\n",
- 			__func__, fl->stripe_unit);
- 		goto out;
- 	}
- 
  	/* find and reference the deviceid */
 -	d = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), &fl->deviceid,
 +	d = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), id,
  			lo->plh_lc_cred, gfp_flags);
  	if (d == NULL)
  		goto out;
* Unmerged path fs/nfs/filelayout/filelayout.c
