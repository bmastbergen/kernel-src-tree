scsi: lpfc: fix "integer constant too large" error on 32bit archs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: fix "integer constant too large" error on 32bit archs (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 95.16%
commit-author Maurizio Lombardi <mlombard@redhat.com>
commit 286871a6667c3d4d27a4cf1ee519e629527dfc9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/286871a6.failed

cc1: warnings being treated as errors
drivers/scsi/lpfc/lpfc_init.c: In function 'lpfc_get_wwpn':
drivers/scsi/lpfc/lpfc_init.c:3253: error: integer constant is too large for 'long' type

	Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 286871a6667c3d4d27a4cf1ee519e629527dfc9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index 2b10a2fda177,7e7ae786121b..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -34,6 -36,8 +34,11 @@@
  #include <linux/firmware.h>
  #include <linux/miscdevice.h>
  #include <linux/percpu.h>
++<<<<<<< HEAD
++=======
+ #include <linux/msi.h>
+ #include <linux/bitops.h>
++>>>>>>> 286871a6667c (scsi: lpfc: fix "integer constant too large" error on 32bit archs)
  
  #include <scsi/scsi.h>
  #include <scsi/scsi_device.h>
@@@ -3393,11 -3729,108 +3398,9 @@@ lpfc_get_wwpn(struct lpfc_hba *phba
  	if (phba->sli_rev == LPFC_SLI_REV4)
  		return be64_to_cpu(wwn);
  	else
- 		return (((wwn & 0xffffffff00000000) >> 32) |
- 			((wwn & 0x00000000ffffffff) << 32));
- 
+ 		return rol64(wwn, 32);
  }
  
 -/**
 - * lpfc_sli4_nvme_sgl_update - update xri-sgl sizing and mapping
 - * @phba: pointer to lpfc hba data structure.
 - *
 - * This routine first calculates the sizes of the current els and allocated
 - * scsi sgl lists, and then goes through all sgls to updates the physical
 - * XRIs assigned due to port function reset. During port initialization, the
 - * current els and allocated scsi sgl lists are 0s.
 - *
 - * Return codes
 - *   0 - successful (for now, it always returns 0)
 - **/
 -int
 -lpfc_sli4_nvme_sgl_update(struct lpfc_hba *phba)
 -{
 -	struct lpfc_nvme_buf *lpfc_ncmd = NULL, *lpfc_ncmd_next = NULL;
 -	uint16_t i, lxri, els_xri_cnt;
 -	uint16_t nvme_xri_cnt, nvme_xri_max;
 -	LIST_HEAD(nvme_sgl_list);
 -	int rc;
 -
 -	phba->total_nvme_bufs = 0;
 -
 -	if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))
 -		return 0;
 -	/*
 -	 * update on pci function's allocated nvme xri-sgl list
 -	 */
 -
 -	/* maximum number of xris available for nvme buffers */
 -	els_xri_cnt = lpfc_sli4_get_els_iocb_cnt(phba);
 -	nvme_xri_max = phba->sli4_hba.max_cfg_param.max_xri - els_xri_cnt;
 -	phba->sli4_hba.nvme_xri_max = nvme_xri_max;
 -	phba->sli4_hba.nvme_xri_max -= phba->sli4_hba.scsi_xri_max;
 -
 -	lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
 -			"6074 Current allocated NVME xri-sgl count:%d, "
 -			"maximum  NVME xri count:%d\n",
 -			phba->sli4_hba.nvme_xri_cnt,
 -			phba->sli4_hba.nvme_xri_max);
 -
 -	spin_lock_irq(&phba->nvme_buf_list_get_lock);
 -	spin_lock(&phba->nvme_buf_list_put_lock);
 -	list_splice_init(&phba->lpfc_nvme_buf_list_get, &nvme_sgl_list);
 -	list_splice(&phba->lpfc_nvme_buf_list_put, &nvme_sgl_list);
 -	spin_unlock(&phba->nvme_buf_list_put_lock);
 -	spin_unlock_irq(&phba->nvme_buf_list_get_lock);
 -
 -	if (phba->sli4_hba.nvme_xri_cnt > phba->sli4_hba.nvme_xri_max) {
 -		/* max nvme xri shrunk below the allocated nvme buffers */
 -		spin_lock_irq(&phba->nvme_buf_list_get_lock);
 -		nvme_xri_cnt = phba->sli4_hba.nvme_xri_cnt -
 -					phba->sli4_hba.nvme_xri_max;
 -		spin_unlock_irq(&phba->nvme_buf_list_get_lock);
 -		/* release the extra allocated nvme buffers */
 -		for (i = 0; i < nvme_xri_cnt; i++) {
 -			list_remove_head(&nvme_sgl_list, lpfc_ncmd,
 -					 struct lpfc_nvme_buf, list);
 -			if (lpfc_ncmd) {
 -				dma_pool_free(phba->lpfc_sg_dma_buf_pool,
 -					      lpfc_ncmd->data,
 -					      lpfc_ncmd->dma_handle);
 -				kfree(lpfc_ncmd);
 -			}
 -		}
 -		spin_lock_irq(&phba->nvme_buf_list_get_lock);
 -		phba->sli4_hba.nvme_xri_cnt -= nvme_xri_cnt;
 -		spin_unlock_irq(&phba->nvme_buf_list_get_lock);
 -	}
 -
 -	/* update xris associated to remaining allocated nvme buffers */
 -	lpfc_ncmd = NULL;
 -	lpfc_ncmd_next = NULL;
 -	list_for_each_entry_safe(lpfc_ncmd, lpfc_ncmd_next,
 -				 &nvme_sgl_list, list) {
 -		lxri = lpfc_sli4_next_xritag(phba);
 -		if (lxri == NO_XRI) {
 -			lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
 -					"6075 Failed to allocate xri for "
 -					"nvme buffer\n");
 -			rc = -ENOMEM;
 -			goto out_free_mem;
 -		}
 -		lpfc_ncmd->cur_iocbq.sli4_lxritag = lxri;
 -		lpfc_ncmd->cur_iocbq.sli4_xritag = phba->sli4_hba.xri_ids[lxri];
 -	}
 -	spin_lock_irq(&phba->nvme_buf_list_get_lock);
 -	spin_lock(&phba->nvme_buf_list_put_lock);
 -	list_splice_init(&nvme_sgl_list, &phba->lpfc_nvme_buf_list_get);
 -	INIT_LIST_HEAD(&phba->lpfc_nvme_buf_list_put);
 -	spin_unlock(&phba->nvme_buf_list_put_lock);
 -	spin_unlock_irq(&phba->nvme_buf_list_get_lock);
 -	return 0;
 -
 -out_free_mem:
 -	lpfc_nvme_free(phba);
 -	return rc;
 -}
 -
  /**
   * lpfc_create_port - Create an FC port
   * @phba: pointer to lpfc hba data structure.
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
