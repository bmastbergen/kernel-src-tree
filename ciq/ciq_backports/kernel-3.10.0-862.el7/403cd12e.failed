IB/umem: Add contiguous ODP support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Artemy Kovalyov <artemyko@mellanox.com>
commit 403cd12e2cf759ead5cbdcb62bf9872b9618d400
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/403cd12e.failed

Currenlty ODP supports only regular MMU pages.
Add ODP support for regions consisting of physically contiguous chunks
of arbitrary order (huge pages for instance) to improve performance.

	Signed-off-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 403cd12e2cf759ead5cbdcb62bf9872b9618d400)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/umem_odp.c
diff --cc drivers/infiniband/core/umem_odp.c
index ea5520c53058,73053c8a9e3b..000000000000
--- a/drivers/infiniband/core/umem_odp.c
+++ b/drivers/infiniband/core/umem_odp.c
@@@ -593,9 -595,10 +593,16 @@@ int ib_umem_odp_map_dma_pages(struct ib
  	struct task_struct *owning_process  = NULL;
  	struct mm_struct   *owning_mm       = NULL;
  	struct page       **local_page_list = NULL;
++<<<<<<< HEAD
 +	u64 off;
 +	int j, k, ret = 0, start_idx, npages = 0;
 +	u64 base_virt_addr;
++=======
+ 	u64 page_mask, off;
+ 	int j, k, ret = 0, start_idx, npages = 0, page_shift;
+ 	unsigned int flags = 0;
+ 	phys_addr_t p = 0;
++>>>>>>> 403cd12e2cf7 (IB/umem: Add contiguous ODP support)
  
  	if (access_mask == 0)
  		return -EINVAL;
@@@ -625,7 -629,10 +633,14 @@@
  		goto out_put_task;
  	}
  
++<<<<<<< HEAD
 +	start_idx = (user_virt - ib_umem_start(umem)) >> PAGE_SHIFT;
++=======
+ 	if (access_mask & ODP_WRITE_ALLOWED_BIT)
+ 		flags |= FOLL_WRITE;
+ 
+ 	start_idx = (user_virt - ib_umem_start(umem)) >> page_shift;
++>>>>>>> 403cd12e2cf7 (IB/umem: Add contiguous ODP support)
  	k = start_idx;
  
  	while (bcnt > 0) {
@@@ -702,8 -719,8 +728,13 @@@ void ib_umem_odp_unmap_dma_pages(struc
  	 * invalidations, so we must make sure we free each page only
  	 * once. */
  	mutex_lock(&umem->odp_data->umem_mutex);
++<<<<<<< HEAD
 +	for (addr = virt; addr < bound; addr += (u64)umem->page_size) {
 +		idx = (addr - ib_umem_start(umem)) / PAGE_SIZE;
++=======
+ 	for (addr = virt; addr < bound; addr += BIT(umem->page_shift)) {
+ 		idx = (addr - ib_umem_start(umem)) >> umem->page_shift;
++>>>>>>> 403cd12e2cf7 (IB/umem: Add contiguous ODP support)
  		if (umem->odp_data->page_list[idx]) {
  			struct page *page = umem->odp_data->page_list[idx];
  			dma_addr_t dma = umem->odp_data->dma_list[idx];
* Unmerged path drivers/infiniband/core/umem_odp.c
diff --git a/include/rdma/ib_umem.h b/include/rdma/ib_umem.h
index ff94050b1aa3..c81fe45a4486 100644
--- a/include/rdma/ib_umem.h
+++ b/include/rdma/ib_umem.h
@@ -72,12 +72,12 @@ static inline unsigned long ib_umem_start(struct ib_umem *umem)
 /* Returns the address of the page after the last one of an ODP umem. */
 static inline unsigned long ib_umem_end(struct ib_umem *umem)
 {
-	return PAGE_ALIGN(umem->address + umem->length);
+	return ALIGN(umem->address + umem->length, BIT(umem->page_shift));
 }
 
 static inline size_t ib_umem_num_pages(struct ib_umem *umem)
 {
-	return (ib_umem_end(umem) - ib_umem_start(umem)) >> PAGE_SHIFT;
+	return (ib_umem_end(umem) - ib_umem_start(umem)) >> umem->page_shift;
 }
 
 #ifdef CONFIG_INFINIBAND_USER_MEM
