cpufreq: intel_pstate: Replace timers with utilization update callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Replace timers with utilization update callbacks (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 93.23%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit a4675fbc4a7abe072ac6ba38c252f22a91ebcd94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a4675fbc.failed

Instead of using a per-CPU deferrable timer for utilization sampling
and P-states adjustments, register a utilization update callback that
will be invoked from the scheduler on utilization changes.

The sampling rate is still the same as what was used for the deferrable
timers, so the functional impact of this patch should not be significant.

Based on an earlier patch from Srinivas Pandruvada.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
(cherry picked from commit a4675fbc4a7abe072ac6ba38c252f22a91ebcd94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 95f94a8e7300,f4d85c2ae7b1..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1089,32 -1072,20 +1065,30 @@@ static int intel_pstate_init_cpu(unsign
  	cpu->cpu = cpunum;
  
  	if (hwp_active) {
++<<<<<<< HEAD
 +		const struct x86_cpu_id *id;
 +
 +		id = x86_match_cpu(intel_pstate_cpu_ee_disable_ids);
 +		if (id)
 +			intel_pstate_disable_ee(cpunum);
 +
 +		intel_pstate_hwp_enable(cpu);
++=======
+ 		intel_pstate_hwp_enable(cpu);
+ 		pid_params.sample_rate_ms = 50;
+ 		pid_params.sample_rate_ns = 50 * NSEC_PER_MSEC;
++>>>>>>> a4675fbc4a7a (cpufreq: intel_pstate: Replace timers with utilization update callbacks)
  	}
  
  	intel_pstate_get_cpu_pstates(cpu);
  
- 	init_timer_deferrable(&cpu->timer);
- 	cpu->timer.data = (unsigned long)cpu;
- 	cpu->timer.expires = jiffies + HZ/100;
- 
- 	if (!hwp_active)
- 		cpu->timer.function = intel_pstate_timer_func;
- 	else
- 		cpu->timer.function = intel_hwp_timer_func;
- 
  	intel_pstate_busy_pid_reset(cpu);
- 	intel_pstate_sample(cpu);
+ 	intel_pstate_sample(cpu, 0);
  
- 	add_timer_on(&cpu->timer, cpunum);
+ 	cpu->update_util.func = intel_pstate_update_util;
+ 	cpufreq_set_update_util_data(cpunum, &cpu->update_util);
  
 -	pr_debug("intel_pstate: controlling: cpu %d\n", cpunum);
 +	pr_debug("Intel pstate controlling: cpu %d\n", cpunum);
  
  	return 0;
  }
@@@ -1197,9 -1165,11 +1171,11 @@@ static void intel_pstate_stop_cpu(struc
  	int cpu_num = policy->cpu;
  	struct cpudata *cpu = all_cpu_data[cpu_num];
  
 -	pr_debug("intel_pstate: CPU %d exiting\n", cpu_num);
 +	pr_info("intel_pstate CPU %d exiting\n", cpu_num);
  
- 	del_timer_sync(&all_cpu_data[cpu_num]->timer);
+ 	cpufreq_set_update_util_data(cpu_num, NULL);
+ 	synchronize_rcu();
+ 
  	if (hwp_active)
  		return;
  
* Unmerged path drivers/cpufreq/intel_pstate.c
