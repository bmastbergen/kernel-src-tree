openvswitch: add ct_clear action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Garver <e@erig.me>
commit b8226962b1c49c784aeddb9d2fafbf53dfdc2190
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b8226962.failed

This adds a ct_clear action for clearing conntrack state. ct_clear is
currently implemented in OVS userspace, but is not backed by an action
in the kernel datapath. This is useful for flows that may modify a
packet tuple after a ct lookup has already occurred.

	Signed-off-by: Eric Garver <e@erig.me>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b8226962b1c49c784aeddb9d2fafbf53dfdc2190)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/openvswitch.h
#	net/openvswitch/actions.c
#	net/openvswitch/flow_netlink.c
diff --cc include/uapi/linux/openvswitch.h
index bb0d515b7654,0cd6f8833147..000000000000
--- a/include/uapi/linux/openvswitch.h
+++ b/include/uapi/linux/openvswitch.h
@@@ -730,6 -803,11 +730,14 @@@ enum ovs_nat_attr 
   * is no MPLS label stack, as determined by ethertype, no action is taken.
   * @OVS_ACTION_ATTR_CT: Track the connection. Populate the conntrack-related
   * entries in the flow key.
++<<<<<<< HEAD
++=======
+  * @OVS_ACTION_ATTR_PUSH_ETH: Push a new outermost Ethernet header onto the
+  * packet.
+  * @OVS_ACTION_ATTR_POP_ETH: Pop the outermost Ethernet header off the
+  * packet.
+  * @OVS_ACTION_ATTR_CT_CLEAR: Clear conntrack state from the packet.
++>>>>>>> b8226962b1c4 (openvswitch: add ct_clear action)
   *
   * Only a single header can be set with a single %OVS_ACTION_ATTR_SET.  Not all
   * fields within a header are modifiable, e.g. the IPv4 protocol and fragment
@@@ -756,6 -834,10 +764,13 @@@ enum ovs_action_attr 
  				       * The data must be zero for the unmasked
  				       * bits. */
  	OVS_ACTION_ATTR_CT,           /* Nested OVS_CT_ATTR_* . */
++<<<<<<< HEAD
++=======
+ 	OVS_ACTION_ATTR_TRUNC,        /* u32 struct ovs_action_trunc. */
+ 	OVS_ACTION_ATTR_PUSH_ETH,     /* struct ovs_action_push_eth. */
+ 	OVS_ACTION_ATTR_POP_ETH,      /* No argument. */
+ 	OVS_ACTION_ATTR_CT_CLEAR,     /* No argument. */
++>>>>>>> b8226962b1c4 (openvswitch: add ct_clear action)
  
  	__OVS_ACTION_ATTR_MAX,	      /* Nothing past this will be accepted
  				       * from userspace. */
diff --cc net/openvswitch/actions.c
index 4d44615c6c14,a551232daf61..000000000000
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@@ -1145,6 -1202,18 +1145,21 @@@ static int do_execute_actions(struct da
  			if (err)
  				return err == -EINPROGRESS ? 0 : err;
  			break;
++<<<<<<< HEAD
++=======
+ 
+ 		case OVS_ACTION_ATTR_CT_CLEAR:
+ 			err = ovs_ct_clear(skb, key);
+ 			break;
+ 
+ 		case OVS_ACTION_ATTR_PUSH_ETH:
+ 			err = push_eth(skb, key, nla_data(a));
+ 			break;
+ 
+ 		case OVS_ACTION_ATTR_POP_ETH:
+ 			err = pop_eth(skb, key);
+ 			break;
++>>>>>>> b8226962b1c4 (openvswitch: add ct_clear action)
  		}
  
  		if (unlikely(err)) {
diff --cc net/openvswitch/flow_netlink.c
index fc328d040852,dc0d79092e74..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -59,6 -60,40 +59,43 @@@ struct ovs_len_tbl 
  #define OVS_ATTR_NESTED -1
  #define OVS_ATTR_VARIABLE -2
  
++<<<<<<< HEAD
++=======
+ static bool actions_may_change_flow(const struct nlattr *actions)
+ {
+ 	struct nlattr *nla;
+ 	int rem;
+ 
+ 	nla_for_each_nested(nla, actions, rem) {
+ 		u16 action = nla_type(nla);
+ 
+ 		switch (action) {
+ 		case OVS_ACTION_ATTR_OUTPUT:
+ 		case OVS_ACTION_ATTR_RECIRC:
+ 		case OVS_ACTION_ATTR_TRUNC:
+ 		case OVS_ACTION_ATTR_USERSPACE:
+ 			break;
+ 
+ 		case OVS_ACTION_ATTR_CT:
+ 		case OVS_ACTION_ATTR_CT_CLEAR:
+ 		case OVS_ACTION_ATTR_HASH:
+ 		case OVS_ACTION_ATTR_POP_ETH:
+ 		case OVS_ACTION_ATTR_POP_MPLS:
+ 		case OVS_ACTION_ATTR_POP_VLAN:
+ 		case OVS_ACTION_ATTR_PUSH_ETH:
+ 		case OVS_ACTION_ATTR_PUSH_MPLS:
+ 		case OVS_ACTION_ATTR_PUSH_VLAN:
+ 		case OVS_ACTION_ATTR_SAMPLE:
+ 		case OVS_ACTION_ATTR_SET:
+ 		case OVS_ACTION_ATTR_SET_MASKED:
+ 		default:
+ 			return true;
+ 		}
+ 	}
+ 	return false;
+ }
+ 
++>>>>>>> b8226962b1c4 (openvswitch: add ct_clear action)
  static void update_range(struct sw_flow_match *match,
  			 size_t offset, size_t size, bool is_mask)
  {
@@@ -2345,6 -2529,10 +2382,13 @@@ static int __ovs_nla_copy_actions(struc
  			[OVS_ACTION_ATTR_SAMPLE] = (u32)-1,
  			[OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash),
  			[OVS_ACTION_ATTR_CT] = (u32)-1,
++<<<<<<< HEAD
++=======
+ 			[OVS_ACTION_ATTR_CT_CLEAR] = 0,
+ 			[OVS_ACTION_ATTR_TRUNC] = sizeof(struct ovs_action_trunc),
+ 			[OVS_ACTION_ATTR_PUSH_ETH] = sizeof(struct ovs_action_push_eth),
+ 			[OVS_ACTION_ATTR_POP_ETH] = 0,
++>>>>>>> b8226962b1c4 (openvswitch: add ct_clear action)
  		};
  		const struct ovs_action_push_vlan *vlan;
  		int type = nla_type(a);
@@@ -2465,6 -2671,25 +2509,28 @@@
  			skip_copy = true;
  			break;
  
++<<<<<<< HEAD
++=======
+ 		case OVS_ACTION_ATTR_CT_CLEAR:
+ 			break;
+ 
+ 		case OVS_ACTION_ATTR_PUSH_ETH:
+ 			/* Disallow pushing an Ethernet header if one
+ 			 * is already present */
+ 			if (mac_proto != MAC_PROTO_NONE)
+ 				return -EINVAL;
+ 			mac_proto = MAC_PROTO_NONE;
+ 			break;
+ 
+ 		case OVS_ACTION_ATTR_POP_ETH:
+ 			if (mac_proto != MAC_PROTO_ETHERNET)
+ 				return -EINVAL;
+ 			if (vlan_tci & htons(VLAN_TAG_PRESENT))
+ 				return -EINVAL;
+ 			mac_proto = MAC_PROTO_ETHERNET;
+ 			break;
+ 
++>>>>>>> b8226962b1c4 (openvswitch: add ct_clear action)
  		default:
  			OVS_NLERR(log, "Unknown Action type %d", type);
  			return -EINVAL;
* Unmerged path include/uapi/linux/openvswitch.h
* Unmerged path net/openvswitch/actions.c
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index 0eec48a6f4bc..28072b007aef 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -916,6 +916,17 @@ err:
 	return err;
 }
 
+int ovs_ct_clear(struct sk_buff *skb, struct sw_flow_key *key)
+{
+	if (skb_nfct(skb)) {
+		nf_conntrack_put(skb_nfct(skb));
+		nf_ct_set(skb, NULL, IP_CT_UNTRACKED);
+		ovs_ct_fill_key(skb, key);
+	}
+
+	return 0;
+}
+
 static int ovs_ct_add_helper(struct ovs_conntrack_info *info, const char *name,
 			     const struct sw_flow_key *key, bool log)
 {
diff --git a/net/openvswitch/conntrack.h b/net/openvswitch/conntrack.h
index 8f6230bd6183..da7ebbc80766 100644
--- a/net/openvswitch/conntrack.h
+++ b/net/openvswitch/conntrack.h
@@ -30,6 +30,7 @@ int ovs_ct_action_to_attr(const struct ovs_conntrack_info *, struct sk_buff *);
 
 int ovs_ct_execute(struct net *, struct sk_buff *, struct sw_flow_key *,
 		   const struct ovs_conntrack_info *);
+int ovs_ct_clear(struct sk_buff *skb, struct sw_flow_key *key);
 
 void ovs_ct_fill_key(const struct sk_buff *skb, struct sw_flow_key *key);
 int ovs_ct_put_key(const struct sw_flow_key *key, struct sk_buff *skb);
@@ -72,6 +73,12 @@ static inline int ovs_ct_execute(struct net *net, struct sk_buff *skb,
 	return -ENOTSUPP;
 }
 
+static inline int ovs_ct_clear(struct sk_buff *skb,
+			       struct sw_flow_key *key)
+{
+	return -ENOTSUPP;
+}
+
 static inline void ovs_ct_fill_key(const struct sk_buff *skb,
 				   struct sw_flow_key *key)
 {
* Unmerged path net/openvswitch/flow_netlink.c
