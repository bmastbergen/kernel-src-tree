ibmvnic: Clean up tx pools when closing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit b41b83e9a784576b2bcc33bce447f7ce78fb265d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b41b83e9.failed

When closing the ibmvnic driver, most notably during the reset
path, the tx pools need to be cleaned to ensure there are no
hanging skbs that need to be free'ed.

The need for this was found during debugging a loss of network
traffic after handling a driver reset. The underlying cause was
some skbs in the tx pool that were never free'ed. As a
result the upper network layers never tried a re-send since it
believed the driver still had the skb.

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b41b83e9a784576b2bcc33bce447f7ce78fb265d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 8b65bfc1f714,2297cf2390e1..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -529,14 -760,44 +529,53 @@@ static void disable_sub_crqs(struct ibm
  	}
  }
  
++<<<<<<< HEAD
 +static int ibmvnic_close(struct net_device *netdev)
++=======
+ static void clean_tx_pools(struct ibmvnic_adapter *adapter)
+ {
+ 	struct ibmvnic_tx_pool *tx_pool;
+ 	u64 tx_entries;
+ 	int tx_scrqs;
+ 	int i, j;
+ 
+ 	if (!adapter->tx_pool)
+ 		return;
+ 
+ 	tx_scrqs = be32_to_cpu(adapter->login_rsp_buf->num_txsubm_subcrqs);
+ 	tx_entries = adapter->req_tx_entries_per_subcrq;
+ 
+ 	/* Free any remaining skbs in the tx buffer pools */
+ 	for (i = 0; i < tx_scrqs; i++) {
+ 		tx_pool = &adapter->tx_pool[i];
+ 		if (!tx_pool)
+ 			continue;
+ 
+ 		for (j = 0; j < tx_entries; j++) {
+ 			if (tx_pool->tx_buff[j].skb) {
+ 				dev_kfree_skb_any(tx_pool->tx_buff[j].skb);
+ 				tx_pool->tx_buff[j].skb = NULL;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static int __ibmvnic_close(struct net_device *netdev)
++>>>>>>> b41b83e9a784 (ibmvnic: Clean up tx pools when closing)
  {
  	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
 -	int rc = 0;
 +	struct device *dev = &adapter->vdev->dev;
 +	union ibmvnic_crq crq;
  	int i;
  
++<<<<<<< HEAD
 +	adapter->closing = true;
++=======
+ 	adapter->state = VNIC_CLOSING;
+ 	netif_tx_stop_all_queues(netdev);
+ 
+ 	clean_tx_pools(adapter);
++>>>>>>> b41b83e9a784 (ibmvnic: Clean up tx pools when closing)
  	disable_sub_crqs(adapter);
  
  	if (adapter->napi) {
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
