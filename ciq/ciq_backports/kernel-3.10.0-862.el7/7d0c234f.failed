Do not return number of bytes written for ioctl CIFS_IOC_COPYCHUNK_FILE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] cifs: do not return number of bytes written for ioctl CIFS_IOC_COPYCHUNK_FILE (Sachin Prabhu) [1416385]
Rebuild_FUZZ: 95.95%
commit-author Sachin Prabhu <sprabhu@redhat.com>
commit 7d0c234fd2e1c9ca3fa032696c0c58b1b74a9e0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7d0c234f.failed

commit 620d8745b35d ("Introduce cifs_copy_file_range()") changes the
behaviour of the cifs ioctl call CIFS_IOC_COPYCHUNK_FILE. In case of
successful writes, it now returns the number of bytes written. This
return value is treated as an error by the xfstest cifs/001. Depending
on the errno set at that time, this may or may not result in the test
failing.

The patch fixes this by setting the return value to 0 in case of
successful writes.

Fixes: commit 620d8745b35d ("Introduce cifs_copy_file_range()")
	Reported-by: Eryu Guan <eguan@redhat.com>
	Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
	Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 7d0c234fd2e1c9ca3fa032696c0c58b1b74a9e0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/ioctl.c
diff --cc fs/cifs/ioctl.c
index 22af9a25cf09,7f4bba574930..000000000000
--- a/fs/cifs/ioctl.c
+++ b/fs/cifs/ioctl.c
@@@ -101,41 -72,10 +101,48 @@@ static long cifs_ioctl_clone(unsigned i
  	if (S_ISDIR(src_inode->i_mode))
  		goto out_fput;
  
++<<<<<<< HEAD
 +	/*
 +	 * Note: cifs case is easier than btrfs since server responsible for
 +	 * checks for proper open modes and file type and if it wants
 +	 * server could even support copy of range where source = target
 +	 */
 +	lock_two_nondirectories(target_inode, src_inode);
 +
 +	/* determine range to clone */
 +	rc = -EINVAL;
 +	if (off + len > src_inode->i_size || off + len < off)
 +		goto out_unlock;
 +	if (len == 0)
 +		len = src_inode->i_size - off;
 +
 +	cifs_dbg(FYI, "about to flush pages\n");
 +	/* should we flush first and last page first */
 +	truncate_inode_pages_range(&target_inode->i_data, destoff,
 +				   PAGE_CACHE_ALIGN(destoff + len)-1);
 +
 +	if (dup_extents && target_tcon->ses->server->ops->duplicate_extents)
 +		rc = target_tcon->ses->server->ops->duplicate_extents(xid,
 +			smb_file_src, smb_file_target, off, len, destoff);
 +	else if (!dup_extents && target_tcon->ses->server->ops->clone_range)
 +		rc = target_tcon->ses->server->ops->clone_range(xid,
 +			smb_file_src, smb_file_target, off, len, destoff);
 +	else
 +		rc = -EOPNOTSUPP;
 +
 +	/* force revalidate of size and timestamps of target file now
 +	   that target is updated on the server */
 +	CIFS_I(target_inode)->time = 0;
 +out_unlock:
 +	/* although unlocking in the reverse order from locking is not
 +	   strictly necessary here it is a little cleaner to be consistent */
 +	unlock_two_nondirectories(src_inode, target_inode);
++=======
+ 	rc = cifs_file_copychunk_range(xid, src_file.file, 0, dst_file, 0,
+ 					src_inode->i_size, 0);
+ 	if (rc > 0)
+ 		rc = 0;
++>>>>>>> 7d0c234fd2e1 (Do not return number of bytes written for ioctl CIFS_IOC_COPYCHUNK_FILE)
  out_fput:
  	fdput(src_file);
  out_drop_write:
* Unmerged path fs/cifs/ioctl.c
