intel_pstate: Do not set utilization update hook too early

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit bb6ab52f2befe1fb29ac198f27d8a6aadf510f81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bb6ab52f.failed

The utilization update hook in the intel_pstate driver is set too
early, as it only should be set after the policy has been fully
initialized by the core.  That may cause intel_pstate_update_util()
to use incorrect data and put the CPUs into incorrect P-states as
a result.

To prevent that from happening, make intel_pstate_set_policy() set
the utilization update hook instead of intel_pstate_init_cpu() so
intel_pstate_update_util() only runs when all things have been
initialized as appropriate.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit bb6ab52f2befe1fb29ac198f27d8a6aadf510f81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 5e3c944b968b,81057e48c4de..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1099,21 -1099,12 +1099,25 @@@ static int intel_pstate_init_cpu(unsign
  
  	intel_pstate_get_cpu_pstates(cpu);
  
 +	init_timer_deferrable(&cpu->timer);
 +	cpu->timer.data = (unsigned long)cpu;
 +	cpu->timer.expires = jiffies + HZ/100;
 +
 +	if (!hwp_active)
 +		cpu->timer.function = intel_pstate_timer_func;
 +	else
 +		cpu->timer.function = intel_hwp_timer_func;
 +
  	intel_pstate_busy_pid_reset(cpu);
 -	intel_pstate_sample(cpu, 0);
 +	intel_pstate_sample(cpu);
  
++<<<<<<< HEAD
 +	add_timer_on(&cpu->timer, cpunum);
++=======
+ 	cpu->update_util.func = intel_pstate_update_util;
++>>>>>>> bb6ab52f2bef (intel_pstate: Do not set utilization update hook too early)
  
 -	pr_debug("intel_pstate: controlling: cpu %d\n", cpunum);
 +	pr_debug("Intel pstate controlling: cpu %d\n", cpunum);
  
  	return 0;
  }
@@@ -1127,16 -1118,26 +1131,31 @@@ static unsigned int intel_pstate_get(un
  	if (!cpu)
  		return 0;
  	sample = &cpu->sample;
 -	return get_avg_frequency(cpu);
 +	return sample->freq;
  }
  
+ static void intel_pstate_set_update_util_hook(unsigned int cpu)
+ {
+ 	cpufreq_set_update_util_data(cpu, &all_cpu_data[cpu]->update_util);
+ }
+ 
+ static void intel_pstate_clear_update_util_hook(unsigned int cpu)
+ {
+ 	cpufreq_set_update_util_data(cpu, NULL);
+ 	synchronize_sched();
+ }
+ 
  static int intel_pstate_set_policy(struct cpufreq_policy *policy)
  {
  	if (!policy->cpuinfo.max_freq)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	pr_debug("set_policy cpuinfo.max %u policy->max %u\n",
 +		 policy->cpuinfo.max_freq, policy->max);
++=======
+ 	intel_pstate_clear_update_util_hook(policy->cpu);
++>>>>>>> bb6ab52f2bef (intel_pstate: Do not set utilization update hook too early)
  
  	if (policy->policy == CPUFREQ_POLICY_PERFORMANCE &&
  	    policy->max >= policy->cpuinfo.max_freq) {
@@@ -1172,8 -1172,10 +1189,11 @@@
  				  int_tofp(100));
  	limits->max_perf = div_fp(int_tofp(limits->max_perf_pct),
  				  int_tofp(100));
 +	limits->max_perf = round_up(limits->max_perf, FRAC_BITS);
  
+  out:
+ 	intel_pstate_set_update_util_hook(policy->cpu);
+ 
  	if (hwp_active)
  		intel_pstate_hwp_set(policy->cpus);
  
@@@ -1196,9 -1198,10 +1216,15 @@@ static void intel_pstate_stop_cpu(struc
  	int cpu_num = policy->cpu;
  	struct cpudata *cpu = all_cpu_data[cpu_num];
  
++<<<<<<< HEAD
 +	pr_info("intel_pstate CPU %d exiting\n", cpu_num);
++=======
+ 	pr_debug("intel_pstate: CPU %d exiting\n", cpu_num);
+ 
+ 	intel_pstate_clear_update_util_hook(cpu_num);
++>>>>>>> bb6ab52f2bef (intel_pstate: Do not set utilization update hook too early)
  
 +	del_timer_sync(&all_cpu_data[cpu_num]->timer);
  	if (hwp_active)
  		return;
  
@@@ -1463,7 -1467,7 +1489,11 @@@ out
  	get_online_cpus();
  	for_each_online_cpu(cpu) {
  		if (all_cpu_data[cpu]) {
++<<<<<<< HEAD
 +			del_timer_sync(&all_cpu_data[cpu]->timer);
++=======
+ 			intel_pstate_clear_update_util_hook(cpu);
++>>>>>>> bb6ab52f2bef (intel_pstate: Do not set utilization update hook too early)
  			kfree(all_cpu_data[cpu]);
  		}
  	}
* Unmerged path drivers/cpufreq/intel_pstate.c
