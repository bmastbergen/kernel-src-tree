pinctrl: intel: Add support for multiple GPIO chips sharing the interrupt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [pinctrl] intel: Add support for multiple GPIO chips sharing the interrupt (David Arcari) [1467490]
Rebuild_FUZZ: 93.43%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 193b40c8258f781d8dc395909b2971472aad6796
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/193b40c8.failed

On Intel Broxton the GPIO hardware consists of several chips that all share
the parent interrupt. It is not possible to handle this by setting chained
handler for each chip (as they will overwrite each other).

To overcome this we need to request the interrupt using devm_request_irq()
and pass IRQF_SHARED with the flags.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 193b40c8258f781d8dc395909b2971472aad6796)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-intel.c
diff --cc drivers/pinctrl/intel/pinctrl-intel.c
index a06b5e3ac823,19b73de2f238..000000000000
--- a/drivers/pinctrl/intel/pinctrl-intel.c
+++ b/drivers/pinctrl/intel/pinctrl-intel.c
@@@ -832,24 -835,28 +835,32 @@@ static irqreturn_t intel_gpio_community
  			irq = irq_find_mapping(gc->irqdomain,
  					       community->pin_base + padno);
  			generic_handle_irq(irq);
+ 
+ 			ret |= IRQ_HANDLED;
  		}
  	}
+ 
+ 	return ret;
  }
  
++<<<<<<< HEAD
 +static void intel_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
++=======
+ static irqreturn_t intel_gpio_irq(int irq, void *data)
++>>>>>>> 193b40c8258f (pinctrl: intel: Add support for multiple GPIO chips sharing the interrupt)
  {
- 	struct gpio_chip *gc = irq_desc_get_handler_data(desc);
- 	struct intel_pinctrl *pctrl = gpiochip_to_pinctrl(gc);
- 	struct irq_chip *chip = irq_desc_get_chip(desc);
+ 	const struct intel_community *community;
+ 	struct intel_pinctrl *pctrl = data;
+ 	irqreturn_t ret = IRQ_NONE;
  	int i;
  
- 	chained_irq_enter(chip, desc);
- 
  	/* Need to check all communities for pending interrupts */
- 	for (i = 0; i < pctrl->ncommunities; i++)
- 		intel_gpio_community_irq_handler(gc, &pctrl->communities[i]);
+ 	for (i = 0; i < pctrl->ncommunities; i++) {
+ 		community = &pctrl->communities[i];
+ 		ret |= intel_gpio_community_irq_handler(pctrl, community);
+ 	}
  
- 	chained_irq_exit(chip, desc);
+ 	return ret;
  }
  
  static struct irq_chip intel_gpio_irqchip = {
* Unmerged path drivers/pinctrl/intel/pinctrl-intel.c
