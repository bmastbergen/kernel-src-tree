GFS2: Clear gl_object when deleting an inode in gfs2_delete_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 240c6235dfe4fe46f2fd0f2b3c15b3a22100a75e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/240c6235.failed

This patch adds some calls to clear gl_object in function
gfs2_delete_inode. Since we are deleting the inode, and the glock
typically outlives the inode in core, we must clear gl_object
so subsequent use of the glock (e.g. for a new inode in its place)
will not have the old pointer sitting there. In error cases we
need to tidy up after ourselves. In non-error cases, we need to
clear gl_object before we set the block free in the bitmap so
residules aren't left for potential inode creators.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 240c6235dfe4fe46f2fd0f2b3c15b3a22100a75e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/super.c
diff --cc fs/gfs2/super.c
index e88f9229419d,87271a859a8d..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1492,9 -1541,15 +1492,10 @@@ static void gfs2_evict_inode(struct ino
  	/* Must not read inode block until block type has been verified */
  	error = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, &gh);
  	if (unlikely(error)) {
+ 		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
  		ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 -		gfs2_glock_dq_uninit(&ip->i_iopen_gh);
 +		gfs2_glock_dq_wait(&ip->i_iopen_gh);
 +		gfs2_holder_uninit(&ip->i_iopen_gh);
  		goto out;
  	}
  
@@@ -1569,13 -1629,17 +1575,21 @@@ out_unlock
  		gfs2_rs_deltree(&ip->i_res);
  
  	if (gfs2_holder_initialized(&ip->i_iopen_gh)) {
+ 		glock_clear_object(ip->i_iopen_gh.gh_gl, ip);
  		if (test_bit(HIF_HOLDER, &ip->i_iopen_gh.gh_iflags)) {
  			ip->i_iopen_gh.gh_flags |= GL_NOCACHE;
 -			gfs2_glock_dq(&ip->i_iopen_gh);
 +			gfs2_glock_dq_wait(&ip->i_iopen_gh);
  		}
  		gfs2_holder_uninit(&ip->i_iopen_gh);
  	}
++<<<<<<< HEAD
 +	gfs2_glock_dq_uninit(&gh);
++=======
+ 	if (gfs2_holder_initialized(&gh)) {
+ 		glock_clear_object(ip->i_gl, ip);
+ 		gfs2_glock_dq_uninit(&gh);
+ 	}
++>>>>>>> 240c6235dfe4 (GFS2: Clear gl_object when deleting an inode in gfs2_delete_inode)
  	if (error && error != GLR_TRYFAILED && error != -EROFS)
  		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
  out:
* Unmerged path fs/gfs2/super.c
