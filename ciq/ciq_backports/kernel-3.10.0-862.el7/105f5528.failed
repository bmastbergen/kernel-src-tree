ipv6: check raw payload size correctly in ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jamie Bainbridge <jbainbri@redhat.com>
commit 105f5528b9bbaa08b526d3405a5bcd2ff0c953c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/105f5528.failed

In situations where an skb is paged, the transport header pointer and
tail pointer can be the same because the skb contents are in frags.

This results in ioctl(SIOCINQ/FIONREAD) incorrectly returning a
length of 0 when the length to receive is actually greater than zero.

skb->len is already correctly set in ip6_input_finish() with
pskb_pull(), so use skb->len as it always returns the correct result
for both linear and paged data.

	Signed-off-by: Jamie Bainbridge <jbainbri@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 105f5528b9bbaa08b526d3405a5bcd2ff0c953c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/raw.c
diff --cc net/ipv6/raw.c
index c5057d832708,0da6a12b5472..000000000000
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@@ -1139,9 -1177,8 +1139,14 @@@ static int rawv6_ioctl(struct sock *sk
  
  		spin_lock_bh(&sk->sk_receive_queue.lock);
  		skb = skb_peek(&sk->sk_receive_queue);
++<<<<<<< HEAD
 +		if (skb != NULL)
 +			amount = skb_tail_pointer(skb) -
 +				skb_transport_header(skb);
++=======
+ 		if (skb)
+ 			amount = skb->len;
++>>>>>>> 105f5528b9bb (ipv6: check raw payload size correctly in ioctl)
  		spin_unlock_bh(&sk->sk_receive_queue.lock);
  		return put_user(amount, (int __user *)arg);
  	}
* Unmerged path net/ipv6/raw.c
