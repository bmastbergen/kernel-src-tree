mm: workingset: turn shadow node shrinker bugs into warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] workingset: turn shadow node shrinker bugs into warnings (Waiman Long) [1441710]
Rebuild_FUZZ: 96.55%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit b936887e8739d3fa83f87d899f68d136735d9816
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b936887e.failed

When the shadow page shrinker tries to reclaim a radix tree node but
finds it in an unexpected state - it should contain no pages, and
non-zero shadow entries - there is no need to kill the executing task or
even the entire system.  Warn about the invalid state, then leave that
tree node be.  Simply don't put it back on the shadow LRU for future
reclaim and move on.

Link: http://lkml.kernel.org/r/20161117191138.22769-4-hannes@cmpxchg.org
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Matthew Wilcox <mawilcox@linuxonhyperv.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b936887e8739d3fa83f87d899f68d136735d9816)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/workingset.c
diff --cc mm/workingset.c
index 69a3283c2741,98f830897b1b..000000000000
--- a/mm/workingset.c
+++ b/mm/workingset.c
@@@ -352,26 -418,29 +352,48 @@@ static void shadow_lru_isolate(struct l
  	 * no pages, so we expect to be able to remove them all and
  	 * delete and free the empty node afterwards.
  	 */
++<<<<<<< HEAD
 +
 +	BUG_ON(!node->count);
 +	BUG_ON(node->count & RADIX_TREE_COUNT_MASK);
 +
++=======
+ 	if (WARN_ON_ONCE(!workingset_node_shadows(node)))
+ 		goto out_invalid;
+ 	if (WARN_ON_ONCE(workingset_node_pages(node)))
+ 		goto out_invalid;
++>>>>>>> b936887e8739 (mm: workingset: turn shadow node shrinker bugs into warnings)
  	for (i = 0; i < RADIX_TREE_MAP_SIZE; i++) {
  		if (node->slots[i]) {
- 			BUG_ON(!radix_tree_exceptional_entry(node->slots[i]));
+ 			if (WARN_ON_ONCE(!radix_tree_exceptional_entry(node->slots[i])))
+ 				goto out_invalid;
+ 			if (WARN_ON_ONCE(!mapping->nrexceptional))
+ 				goto out_invalid;
  			node->slots[i] = NULL;
++<<<<<<< HEAD
 +			BUG_ON(node->count < (1U << RADIX_TREE_COUNT_SHIFT));
 +			node->count -= 1U << RADIX_TREE_COUNT_SHIFT;
 +			BUG_ON(!mapping->nrexceptional);
 +			mapping->nrexceptional--;
 +		}
 +	}
 +	BUG_ON(node->count);
 +	inc_zone_state(page_zone(virt_to_page(node)), WORKINGSET_NODERECLAIM);
 +	if (!__radix_tree_delete_node(&mapping->page_tree, node))
 +		BUG();
++=======
+ 			workingset_node_shadows_dec(node);
+ 			mapping->nrexceptional--;
+ 		}
+ 	}
+ 	if (WARN_ON_ONCE(workingset_node_shadows(node)))
+ 		goto out_invalid;
+ 	inc_node_state(page_pgdat(virt_to_page(node)), WORKINGSET_NODERECLAIM);
+ 	__radix_tree_delete_node(&mapping->page_tree, node);
++>>>>>>> b936887e8739 (mm: workingset: turn shadow node shrinker bugs into warnings)
  
+ out_invalid:
  	spin_unlock(&mapping->tree_lock);
 -	ret = LRU_REMOVED_RETRY;
  out:
  	local_irq_enable();
  	cond_resched();
* Unmerged path mm/workingset.c
