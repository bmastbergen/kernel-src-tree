qla2xxx: Simplify usage of SRB structure in driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit 25ff6af10562cfe30dd29452a8fc04ec022d4f18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/25ff6af1.failed

This patch simplifies SRB structure usage in driver.

- Simplify sp->done() and sp->free() interfaces.
- Remove sp->fcport->vha to use vha pointer from sp.
- Use sp->vha context in qla2x00_rel_sp().

	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 25ff6af10562cfe30dd29452a8fc04ec022d4f18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_bsg.c
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_gs.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_inline.h
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mr.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_bsg.c
index f25c5e89826a,975e7a117532..000000000000
--- a/drivers/scsi/qla2xxx/qla_bsg.c
+++ b/drivers/scsi/qla2xxx/qla_bsg.c
@@@ -12,24 -12,26 +12,42 @@@
  
  /* BSG support for ELS/CT pass through */
  void
- qla2x00_bsg_job_done(void *data, void *ptr, int res)
+ qla2x00_bsg_job_done(void *ptr, int res)
  {
++<<<<<<< HEAD
 +	srb_t *sp = (srb_t *)ptr;
 +	struct scsi_qla_host *vha = (scsi_qla_host_t *)data;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
 +
 +	bsg_job->reply->result = res;
 +	bsg_job->job_done(bsg_job);
 +	sp->free(vha, sp);
++=======
+ 	srb_t *sp = ptr;
+ 	struct bsg_job *bsg_job = sp->u.bsg_job;
+ 	struct fc_bsg_reply *bsg_reply = bsg_job->reply;
+ 
+ 	bsg_reply->result = res;
+ 	bsg_job_done(bsg_job, bsg_reply->result,
+ 		       bsg_reply->reply_payload_rcv_len);
+ 	sp->free(sp);
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  }
  
  void
- qla2x00_bsg_sp_free(void *data, void *ptr)
+ qla2x00_bsg_sp_free(void *ptr)
  {
++<<<<<<< HEAD
 +	srb_t *sp = (srb_t *)ptr;
 +	struct scsi_qla_host *vha = sp->fcport->vha;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
 +	struct qla_hw_data *ha = vha->hw;
++=======
+ 	srb_t *sp = ptr;
+ 	struct qla_hw_data *ha = sp->vha->hw;
+ 	struct bsg_job *bsg_job = sp->u.bsg_job;
+ 	struct fc_bsg_request *bsg_request = bsg_job->request;
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  	struct qla_mt_iocb_rqst_fx00 *piocb_rqst;
  
  	if (sp->type == SRB_FXIOCB_BCMD) {
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,ac37e91aee20..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -387,19 -433,22 +387,23 @@@ struct srb_iocb 
  typedef struct srb {
  	atomic_t ref_count;
  	struct fc_port *fcport;
++<<<<<<< HEAD
++=======
+ 	struct scsi_qla_host *vha;
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  	uint32_t handle;
  	uint16_t flags;
  	uint16_t type;
  	char *name;
  	int iocbs;
  	struct qla_qpair *qpair;
 -	u32 gen1;	/* scratch */
 -	u32 gen2;	/* scratch */
  	union {
  		struct srb_iocb iocb_cmd;
 -		struct bsg_job *bsg_job;
 +		struct fc_bsg_job *bsg_job;
  		struct srb_cmd scmd;
  	} u;
- 	void (*done)(void *, void *, int);
- 	void (*free)(void *, void *);
+ 	void (*done)(void *, int);
+ 	void (*free)(void *);
  } srb_t;
  
  #define GET_CMD_SP(sp) (sp->u.scmd.cmd)
@@@ -2919,15 -3224,9 +2923,16 @@@ struct qla_qpair 
  	struct qla_hw_data *hw;
  	struct work_struct q_work;
  	struct list_head qp_list_elem; /* vha->qp_list */
+ 	struct scsi_qla_host *vha;
  };
  
 +struct qla_percpu_qp_hint {
 +	int change_in_progress;
 +	struct qla_qpair *qp;
 +	int redirect_to_cpuid;
 +	struct qla_qpair *alternate_qp;
 +};
 +
  /* Place holder for FW buffer parameters */
  struct qlfc_fw {
  	void *fw_buf;
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,b3d6441d1d90..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -167,9 -186,13 +167,19 @@@ extern int qla2x00_post_uevent_work(str
  
  extern int qla2x00_post_uevent_work(struct scsi_qla_host *, u32);
  extern void qla2x00_disable_board_on_pci_error(struct work_struct *);
++<<<<<<< HEAD
 +extern void qla2x00_sp_compl(void *, void *, int);
 +extern void qla2xxx_qpair_sp_free_dma(void *, void *);
 +extern void qla2xxx_qpair_sp_compl(void *, void *, int);
++=======
+ extern void qla2x00_sp_compl(void *, int);
+ extern void qla2xxx_qpair_sp_free_dma(void *);
+ extern void qla2xxx_qpair_sp_compl(void *, int);
+ extern int qla24xx_post_upd_fcport_work(struct scsi_qla_host *, fc_port_t *);
+ void qla2x00_handle_login_done_event(struct scsi_qla_host *, fc_port_t *,
+ 	uint16_t *);
+ int qla24xx_post_gnl_work(struct scsi_qla_host *, fc_port_t *);
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  
  /*
   * Global Functions in qla_mid.c source file.
diff --cc drivers/scsi/qla2xxx/qla_gs.c
index 54827d74afb8,6d500fd06768..000000000000
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@@ -2692,3 -2741,538 +2692,541 @@@ qla2x00_gff_id(scsi_qla_host_t *vha, sw
  			break;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /* GID_PN completion processing. */
+ void qla24xx_handle_gidpn_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"%s %8phC login state %d \n",
+ 		__func__, fcport->port_name, fcport->fw_login_state);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* PLOGI/PRLI/LOGO came in while cmd was out.*/
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	if (!ea->rc) {
+ 		if (ea->sp->gen1 == fcport->rscn_gen) {
+ 			fcport->scan_state = QLA_FCPORT_FOUND;
+ 			fcport->flags |= FCF_FABRIC_DEVICE;
+ 
+ 			if (fcport->d_id.b24 == ea->id.b24) {
+ 				/* cable plugged into the same place */
+ 				switch (vha->host->active_mode) {
+ 				case MODE_TARGET:
+ 					/* NOOP. let the other guy login to us.*/
+ 					break;
+ 				case MODE_INITIATOR:
+ 				case MODE_DUAL:
+ 				default:
+ 					if (atomic_read(&fcport->state) ==
+ 					    FCS_ONLINE)
+ 						break;
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post gnl\n",
+ 					    __func__, __LINE__, fcport->port_name);
+ 					qla24xx_post_gnl_work(vha, fcport);
+ 					break;
+ 				}
+ 			} else { /* fcport->d_id.b24 != ea->id.b24 */
+ 				fcport->d_id.b24 = ea->id.b24;
+ 				if (fcport->deleted == QLA_SESS_DELETED) {
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__, fcport->port_name);
+ 					qlt_schedule_sess_for_deletion_lock(fcport);
+ 				}
+ 			}
+ 		} else { /* ea->sp->gen1 != fcport->rscn_gen */
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gidpn\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			/* rscn came in while cmd was out */
+ 			qla24xx_post_gidpn_work(vha, fcport);
+ 		}
+ 	} else { /* ea->rc */
+ 		/* cable pulled */
+ 		if (ea->sp->gen1 == fcport->rscn_gen) {
+ 			if (ea->sp->gen2 == fcport->login_gen) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %d %8phC post del sess\n", __func__,
+ 				    __LINE__, fcport->port_name);
+ 				qlt_schedule_sess_for_deletion_lock(fcport);
+ 			} else {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %d %8phC login\n", __func__, __LINE__,
+ 				    fcport->port_name);
+ 				qla24xx_fcport_handle_login(vha, fcport);
+ 			}
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gidpn\n", __func__, __LINE__,
+ 			    fcport->port_name);
+ 			qla24xx_post_gidpn_work(vha, fcport);
+ 		}
+ 	}
+ } /* gidpn_event */
+ 
+ static void qla2x00_async_gidpn_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u8 *id = fcport->ct_desc.ct_sns->p.rsp.rsp.gid_pn.port_id;
+ 	struct event_arg ea;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.fcport = fcport;
+ 	ea.id.b.domain = id[0];
+ 	ea.id.b.area = id[1];
+ 	ea.id.b.al_pa = id[2];
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GIDPN_DONE;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC ID %3phC \n",
+ 	    sp->name, res, fcport->port_name, id);
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gidpn(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GID_PN;
+ 	fcport->scan_state = QLA_FCPORT_SCAN;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gidpn";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(fcport->ct_desc.ct_sns, GID_PN_CMD,
+ 		GID_PN_RSP_SIZE);
+ 
+ 	/* GIDPN req */
+ 	memcpy(ct_req->req.gid_pn.port_name, fcport->port_name,
+ 		WWN_SIZE);
+ 
+ 	/* req & rsp use the same buffer */
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GID_PN_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GID_PN_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gidpn_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x206f,
+ 		"Async-%s - %8phC hdl=%x loopid=%x portid %02x%02x%02x.\n",
+ 		sp->name, fcport->port_name,
+ 		sp->handle, fcport->loop_id, fcport->d_id.b.domain,
+ 		fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gidpn_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 	int ls;
+ 
+ 	ls = atomic_read(&vha->loop_state);
+ 	if (((ls != LOOP_READY) && (ls != LOOP_UP)) ||
+ 		test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GIDPN);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_post_gpsc_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPSC);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static void qla24xx_async_gpsc_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct ct_sns_rsp       *ct_rsp;
+ 	struct event_arg ea;
+ 
+ 	ct_rsp = &fcport->ct_desc.ct_sns->p.rsp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC \n",
+ 	    sp->name, res, fcport->port_name);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res == (DID_ERROR << 16)) {
+ 		/* entry status error */
+ 		goto done;
+ 	} else if (res) {
+ 		if ((ct_rsp->header.reason_code ==
+ 			 CT_REASON_INVALID_COMMAND_CODE) ||
+ 			(ct_rsp->header.reason_code ==
+ 			 CT_REASON_COMMAND_UNSUPPORTED)) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x205a,
+ 				"GPSC command unsupported, disabling "
+ 				"query.\n");
+ 			ha->flags.gpsc_supported = 0;
+ 			res = QLA_SUCCESS;
+ 		}
+ 	} else {
+ 		switch (be16_to_cpu(ct_rsp->rsp.gpsc.speed)) {
+ 		case BIT_15:
+ 			fcport->fp_speed = PORT_SPEED_1GB;
+ 			break;
+ 		case BIT_14:
+ 			fcport->fp_speed = PORT_SPEED_2GB;
+ 			break;
+ 		case BIT_13:
+ 			fcport->fp_speed = PORT_SPEED_4GB;
+ 			break;
+ 		case BIT_12:
+ 			fcport->fp_speed = PORT_SPEED_10GB;
+ 			break;
+ 		case BIT_11:
+ 			fcport->fp_speed = PORT_SPEED_8GB;
+ 			break;
+ 		case BIT_10:
+ 			fcport->fp_speed = PORT_SPEED_16GB;
+ 			break;
+ 		case BIT_8:
+ 			fcport->fp_speed = PORT_SPEED_32GB;
+ 			break;
+ 		}
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s OUT WWPN %8phC speeds=%04x speed=%04x.\n",
+ 			sp->name,
+ 			fcport->fabric_port_name,
+ 			be16_to_cpu(ct_rsp->rsp.gpsc.speeds),
+ 			be16_to_cpu(ct_rsp->rsp.gpsc.speed));
+ 	}
+ done:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPSC_DONE;
+ 	ea.rc = res;
+ 	ea.fcport = fcport;
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gpsc(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gpsc";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla24xx_prep_ct_fm_req(fcport->ct_desc.ct_sns, GPSC_CMD,
+ 		GPSC_RSP_SIZE);
+ 
+ 	/* GPSC req */
+ 	memcpy(ct_req->req.gpsc.port_name, fcport->port_name,
+ 		WWN_SIZE);
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GPSC_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GPSC_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = vha->mgmt_svr_loop_id;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla24xx_async_gpsc_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hdl=%x loopid=%x portid=%02x%02x%02x.\n",
+ 		sp->name, fcport->port_name, sp->handle,
+ 		fcport->loop_id, fcport->d_id.b.domain,
+ 		fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gpnid_work(struct scsi_qla_host *vha, port_id_t *id)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPNID);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.gpnid.id = *id;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ void qla24xx_async_gpnid_done(scsi_qla_host_t *vha, srb_t *sp)
+ {
+ 	if (sp->u.iocb_cmd.u.ctarg.req) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.req,
+ 			sp->u.iocb_cmd.u.ctarg.req_dma);
+ 		sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 	}
+ 	if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.rsp,
+ 			sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 		sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 	}
+ 
+ 	sp->free(sp);
+ }
+ 
+ void qla24xx_handle_gpnid_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport = qla2x00_find_fcport_by_wwpn(vha, ea->port_name, 1);
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	if (fcport) {
+ 		/* cable moved. just plugged in */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post del sess\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		fcport->rscn_gen++;
+ 		fcport->d_id = ea->id;
+ 		fcport->scan_state = QLA_FCPORT_FOUND;
+ 		fcport->flags |= FCF_FABRIC_DEVICE;
+ 
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 	} else {
+ 		/* create new fcport */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post new sess\n",
+ 			   __func__, __LINE__, ea->port_name);
+ 
+ 		qla24xx_post_newsess_work(vha, &ea->id, ea->port_name, NULL);
+ 	}
+ }
+ 
+ static void qla2x00_async_gpnid_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct ct_sns_req *ct_req =
+ 	    (struct ct_sns_req *)sp->u.iocb_cmd.u.ctarg.req;
+ 	struct ct_sns_rsp *ct_rsp =
+ 	    (struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp;
+ 	struct event_arg ea;
+ 	struct qla_work_evt *e;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async done-%s res %x ID %3phC. %8phC\n",
+ 		sp->name, res, ct_req->req.port_id.port_id,
+ 		ct_rsp->rsp.gpn_id.port_name);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	memcpy(ea.port_name, ct_rsp->rsp.gpn_id.port_name, WWN_SIZE);
+ 	ea.sp = sp;
+ 	ea.id.b.domain = ct_req->req.port_id.port_id[0];
+ 	ea.id.b.area = ct_req->req.port_id.port_id[1];
+ 	ea.id.b.al_pa = ct_req->req.port_id.port_id[2];
+ 	ea.rc = res;
+ 	ea.event = FCME_GPNID_DONE;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPNID_DONE);
+ 	if (!e) {
+ 		/* please ignore kernel warning. otherwise, we have mem leak. */
+ 		if (sp->u.iocb_cmd.u.ctarg.req) {
+ 			dma_free_coherent(&vha->hw->pdev->dev,
+ 				sizeof(struct ct_sns_pkt),
+ 				sp->u.iocb_cmd.u.ctarg.req,
+ 				sp->u.iocb_cmd.u.ctarg.req_dma);
+ 			sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 		}
+ 		if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 			dma_free_coherent(&vha->hw->pdev->dev,
+ 				sizeof(struct ct_sns_pkt),
+ 				sp->u.iocb_cmd.u.ctarg.rsp,
+ 				sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 			sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 		}
+ 
+ 		sp->free(sp);
+ 		return;
+ 	}
+ 
+ 	e->u.iosb.sp = sp;
+ 	qla2x00_post_work(vha, e);
+ }
+ 
+ /* Get WWPN with Nport ID. */
+ int qla24xx_async_gpnid(scsi_qla_host_t *vha, port_id_t *id)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 	struct ct_sns_pkt *ct_sns;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	sp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gpnid";
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,
+ 		sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,
+ 		GFP_KERNEL);
+ 	if (!sp->u.iocb_cmd.u.ctarg.req) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate ct_sns request.\n");
+ 		goto done_free_sp;
+ 	}
+ 
+ 	sp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,
+ 		sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.rsp_dma,
+ 		GFP_KERNEL);
+ 	if (!sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate ct_sns request.\n");
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;
+ 	memset(ct_sns, 0, sizeof(*ct_sns));
+ 
+ 	ct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(ct_sns, GPN_ID_CMD, GPN_ID_RSP_SIZE);
+ 
+ 	/* GPN_ID req */
+ 	ct_req->req.port_id.port_id[0] = id->b.domain;
+ 	ct_req->req.port_id.port_id[1] = id->b.area;
+ 	ct_req->req.port_id.port_id[2] = id->b.al_pa;
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GPN_ID_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GPN_ID_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gpnid_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s hdl=%x ID %3phC.\n", sp->name,
+ 		sp->handle, ct_req->req.port_id.port_id);
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (sp->u.iocb_cmd.u.ctarg.req) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.req,
+ 			sp->u.iocb_cmd.u.ctarg.req_dma);
+ 		sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 	}
+ 	if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.rsp,
+ 			sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 		sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 	}
+ 
+ 	sp->free(sp);
+ done:
+ 	return rval;
+ }
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,f65431480833..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -47,8 -47,7 +47,12 @@@ qla2x00_sp_timeout(unsigned long __data
  {
  	srb_t *sp = (srb_t *)__data;
  	struct srb_iocb *iocb;
++<<<<<<< HEAD
 +	fc_port_t *fcport = sp->fcport;
 +	struct qla_hw_data *ha = fcport->vha->hw;
++=======
+ 	scsi_qla_host_t *vha = sp->vha;
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  	struct req_que *req;
  	unsigned long flags;
  
@@@ -57,8 -56,8 +61,13 @@@
  	req->outstanding_cmds[sp->handle] = NULL;
  	iocb = &sp->u.iocb_cmd;
  	iocb->timeout(sp);
++<<<<<<< HEAD
 +	sp->free(fcport->vha, sp);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++=======
+ 	sp->free(sp);
+ 	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  }
  
  void
@@@ -94,41 -92,72 +102,85 @@@ qla2x00_get_async_timeout(struct scsi_q
  	return tmo;
  }
  
 -void
 +static void
  qla2x00_async_iocb_timeout(void *data)
  {
- 	srb_t *sp = (srb_t *)data;
+ 	srb_t *sp = data;
  	fc_port_t *fcport = sp->fcport;
 -	struct srb_iocb *lio = &sp->u.iocb_cmd;
 -	struct event_arg ea;
  
  	ql_dbg(ql_dbg_disc, fcport->vha, 0x2071,
 -	    "Async-%s timeout - hdl=%x portid=%06x %8phC.\n",
 -	    sp->name, sp->handle, fcport->d_id.b24, fcport->port_name);
 +	    "Async-%s timeout - hdl=%x portid=%02x%02x%02x.\n",
 +	    sp->name, sp->handle, fcport->d_id.b.domain, fcport->d_id.b.area,
 +	    fcport->d_id.b.al_pa);
  
  	fcport->flags &= ~FCF_ASYNC_SENT;
 -
 -	switch (sp->type) {
 -	case SRB_LOGIN_CMD:
 +	if (sp->type == SRB_LOGIN_CMD) {
 +		struct srb_iocb *lio = &sp->u.iocb_cmd;
 +		qla2x00_post_async_logout_work(fcport->vha, fcport, NULL);
  		/* Retry as needed. */
  		lio->u.logio.data[0] = MBS_COMMAND_ERROR;
  		lio->u.logio.data[1] = lio->u.logio.flags & SRB_LOGIN_RETRIED ?
  			QLA_LOGIO_LOGIN_RETRIED : 0;
++<<<<<<< HEAD
 +		qla2x00_post_async_login_done_work(fcport->vha, fcport,
 +			lio->u.logio.data);
++=======
+ 		memset(&ea, 0, sizeof(ea));
+ 		ea.event = FCME_PLOGI_DONE;
+ 		ea.fcport = sp->fcport;
+ 		ea.data[0] = lio->u.logio.data[0];
+ 		ea.data[1] = lio->u.logio.data[1];
+ 		ea.sp = sp;
+ 		qla24xx_handle_plogi_done_event(fcport->vha, &ea);
+ 		break;
+ 	case SRB_LOGOUT_CMD:
+ 		qlt_logo_completion_handler(fcport, QLA_FUNCTION_TIMEOUT);
+ 		break;
+ 	case SRB_CT_PTHRU_CMD:
+ 	case SRB_MB_IOCB:
+ 	case SRB_NACK_PLOGI:
+ 	case SRB_NACK_PRLI:
+ 	case SRB_NACK_LOGO:
+ 		sp->done(sp, QLA_FUNCTION_TIMEOUT);
+ 		break;
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  	}
  }
  
  static void
- qla2x00_async_login_sp_done(void *data, void *ptr, int res)
+ qla2x00_async_login_sp_done(void *ptr, int res)
  {
- 	srb_t *sp = (srb_t *)ptr;
+ 	srb_t *sp = ptr;
+ 	struct scsi_qla_host *vha = sp->vha;
  	struct srb_iocb *lio = &sp->u.iocb_cmd;
++<<<<<<< HEAD
 +	struct scsi_qla_host *vha = (scsi_qla_host_t *)data;
 +
 +	if (!test_bit(UNLOADING, &vha->dpc_flags))
 +		qla2x00_post_async_login_done_work(sp->fcport->vha, sp->fcport,
 +		    lio->u.logio.data);
 +	sp->free(sp->fcport->vha, sp);
++=======
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC res %d \n", __func__, sp->fcport->port_name, res);
+ 
+ 	sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 	if (!test_bit(UNLOADING, &vha->dpc_flags)) {
+ 		memset(&ea, 0, sizeof(ea));
+ 		ea.event = FCME_PLOGI_DONE;
+ 		ea.fcport = sp->fcport;
+ 		ea.data[0] = lio->u.logio.data[0];
+ 		ea.data[1] = lio->u.logio.data[1];
+ 		ea.iop[0] = lio->u.logio.iop[0];
+ 		ea.iop[1] = lio->u.logio.iop[1];
+ 		ea.sp = sp;
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	sp->free(sp);
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  }
  
  int
@@@ -170,22 -209,23 +222,27 @@@ qla2x00_async_login(struct scsi_qla_hos
  	return rval;
  
  done_free_sp:
- 	sp->free(fcport->vha, sp);
+ 	sp->free(sp);
  done:
 -	fcport->flags &= ~FCF_ASYNC_SENT;
  	return rval;
  }
  
  static void
- qla2x00_async_logout_sp_done(void *data, void *ptr, int res)
+ qla2x00_async_logout_sp_done(void *ptr, int res)
  {
- 	srb_t *sp = (srb_t *)ptr;
+ 	srb_t *sp = ptr;
  	struct srb_iocb *lio = &sp->u.iocb_cmd;
- 	struct scsi_qla_host *vha = (scsi_qla_host_t *)data;
  
++<<<<<<< HEAD
 +	if (!test_bit(UNLOADING, &vha->dpc_flags))
 +		qla2x00_post_async_logout_done_work(sp->fcport->vha, sp->fcport,
++=======
+ 	sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 	if (!test_bit(UNLOADING, &sp->vha->dpc_flags))
+ 		qla2x00_post_async_logout_done_work(sp->vha, sp->fcport,
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  		    lio->u.logio.data);
- 	sp->free(sp->fcport->vha, sp);
+ 	sp->free(sp);
  }
  
  int
@@@ -218,8 -260,9 +275,8 @@@ qla2x00_async_logout(struct scsi_qla_ho
  	return rval;
  
  done_free_sp:
- 	sp->free(fcport->vha, sp);
+ 	sp->free(sp);
  done:
 -	fcport->flags &= ~FCF_ASYNC_SENT;
  	return rval;
  }
  
@@@ -269,11 -313,854 +326,856 @@@ qla2x00_async_adisc(struct scsi_qla_hos
  	return rval;
  
  done_free_sp:
- 	sp->free(fcport->vha, sp);
+ 	sp->free(sp);
  done:
 -	fcport->flags &= ~FCF_ASYNC_SENT;
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *conflict_fcport;
+ 	struct get_name_list_extended *e;
+ 	u16 i, n, found = 0, loop_id;
+ 	port_id_t id;
+ 	u64 wwn;
+ 	u8 opt = 0;
+ 
+ 	fcport = ea->fcport;
+ 
+ 	if (ea->rc) { /* rval */
+ 		if (fcport->login_retry == 0) {
+ 			fcport->login_retry = vha->hw->login_retry_count;
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				"GNL failed Port login retry %8phN, retry cnt=%d.\n",
+ 				fcport->port_name, fcport->login_retry);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC rscn gen changed rscn %d|%d \n",
+ 		    __func__, fcport->port_name,
+ 		    fcport->last_rscn_gen, fcport->rscn_gen);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	} else if (fcport->last_login_gen != fcport->login_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s %8phC login gen changed login %d|%d \n",
+ 			__func__, fcport->port_name,
+ 			fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	n = ea->data[0] / sizeof(struct get_name_list_extended);
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %d %8phC n %d %02x%02x%02x lid %d \n",
+ 	    __func__, __LINE__, fcport->port_name, n,
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa, fcport->loop_id);
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		if (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))
+ 			continue;
+ 
+ 		found = 1;
+ 		id.b.domain = e->port_id[2];
+ 		id.b.area = e->port_id[1];
+ 		id.b.al_pa = e->port_id[0];
+ 		id.b.rsvd_1 = 0;
+ 
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		loop_id = (loop_id & 0x7fff);
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s found %8phC CLS [%d|%d] ID[%02x%02x%02x|%02x%02x%02x] lid[%d|%d]\n",
+ 			   __func__, fcport->port_name,
+ 			e->current_login_state, fcport->fw_login_state,
+ 			id.b.domain, id.b.area, id.b.al_pa,
+ 			fcport->d_id.b.domain, fcport->d_id.b.area,
+ 			fcport->d_id.b.al_pa, loop_id, fcport->loop_id);
+ 
+ 		if ((id.b24 != fcport->d_id.b24) ||
+ 		    ((fcport->loop_id != FC_NO_LOOP_ID) &&
+ 			(fcport->loop_id != loop_id))) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post del sess\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qlt_schedule_sess_for_deletion(fcport, 1);
+ 			return;
+ 		}
+ 
+ 		fcport->loop_id = loop_id;
+ 
+ 		wwn = wwn_to_u64(fcport->port_name);
+ 		qlt_find_sess_invalidate_other(vha, wwn,
+ 			id, loop_id, &conflict_fcport);
+ 
+ 		if (conflict_fcport) {
+ 			/*
+ 			 * Another share fcport share the same loop_id &
+ 			 * nport id. Conflict fcport needs to finish
+ 			 * cleanup before this fcport can proceed to login.
+ 			 */
+ 			conflict_fcport->conflict = fcport;
+ 			fcport->login_pause = 1;
+ 		}
+ 
+ 		switch (e->current_login_state) {
+ 		case DSC_LS_PRLI_COMP:
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			opt = PDO_FORCE_ADISC;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 			break;
+ 
+ 		case DSC_LS_PORT_UNAVAIL:
+ 		default:
+ 			if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 				qla2x00_find_new_loop_id(vha, fcport);
+ 				fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 			}
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		/* fw has no record of this port */
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			qla2x00_find_new_loop_id(vha, fcport);
+ 			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		} else {
+ 			for (i = 0; i < n; i++) {
+ 				e = &vha->gnl.l[i];
+ 				id.b.domain = e->port_id[0];
+ 				id.b.area = e->port_id[1];
+ 				id.b.al_pa = e->port_id[2];
+ 				id.b.rsvd_1 = 0;
+ 				loop_id = le16_to_cpu(e->nport_handle);
+ 
+ 				if (fcport->d_id.b24 == id.b24) {
+ 					conflict_fcport =
+ 					    qla2x00_find_fcport_by_wwpn(vha,
+ 						e->port_name, 0);
+ 
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__,
+ 					    conflict_fcport->port_name);
+ 					qlt_schedule_sess_for_deletion
+ 						(conflict_fcport, 1);
+ 				}
+ 
+ 				if (fcport->loop_id == loop_id) {
+ 					/* FW already picked this loop id for another fcport */
+ 					qla2x00_find_new_loop_id(vha, fcport);
+ 				}
+ 			}
+ 		}
+ 		qla24xx_fcport_handle_login(vha, fcport);
+ 	}
+ } /* gnl_event */
+ 
+ static void
+ qla24xx_async_gnl_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	unsigned long flags;
+ 	struct fc_port *fcport = NULL, *tf;
+ 	u16 i, n = 0, loop_id;
+ 	struct event_arg ea;
+ 	struct get_name_list_extended *e;
+ 	u64 wwn;
+ 	struct list_head h;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],
+ 	    sp->u.iocb_cmd.u.mbx.in_mb[2]);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GNL_DONE;
+ 
+ 	if (sp->u.iocb_cmd.u.mbx.in_mb[1] >=
+ 	    sizeof(struct get_name_list_extended)) {
+ 		n = sp->u.iocb_cmd.u.mbx.in_mb[1] /
+ 		    sizeof(struct get_name_list_extended);
+ 		ea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1]; /* amnt xfered */
+ 	}
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		/* mask out reserve bit */
+ 		loop_id = (loop_id & 0x7fff);
+ 		set_bit(loop_id, vha->hw->loop_id_map);
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		ql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,
+ 		    "%s %8phC %02x:%02x:%02x state %d/%d lid %x \n",
+ 		    __func__, (void *)&wwn, e->port_id[2], e->port_id[1],
+ 		    e->port_id[0], e->current_login_state, e->last_login_state,
+ 		    (loop_id & 0x7fff));
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	vha->gnl.sent = 0;
+ 
+ 	INIT_LIST_HEAD(&h);
+ 	fcport = tf = NULL;
+ 	if (!list_empty(&vha->gnl.fcports))
+ 		list_splice_init(&vha->gnl.fcports, &h);
+ 
+ 	list_for_each_entry_safe(fcport, tf, &h, gnl_entry) {
+ 		list_del_init(&fcport->gnl_entry);
+ 		fcport->flags &= ~FCF_ASYNC_SENT;
+ 		ea.fcport = fcport;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	unsigned long flags;
+ 	u16 *mb;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-gnlist WWPN %8phC \n", fcport->port_name);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GNL;
+ 	fcport->last_rscn_gen = fcport->rscn_gen;
+ 	fcport->last_login_gen = fcport->login_gen;
+ 
+ 	list_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);
+ 	if (vha->gnl.sent) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		rval = QLA_SUCCESS;
+ 		goto done;
+ 	}
+ 	vha->gnl.sent = 1;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gnlist";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_PORT_NODE_NAME_LIST;
+ 	mb[1] = BIT_2 | BIT_3;
+ 	mb[2] = MSW(vha->gnl.ldma);
+ 	mb[3] = LSW(vha->gnl.ldma);
+ 	mb[6] = MSW(MSD(vha->gnl.ldma));
+ 	mb[7] = LSW(MSD(vha->gnl.ldma));
+ 	mb[8] = vha->gnl.size;
+ 	mb[9] = vha->vp_idx;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 
+ 	sp->done = qla24xx_async_gnl_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s - OUT WWPN %8phC hndl %x\n",
+ 		sp->name, fcport->port_name, sp->handle);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GNL);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla24xx_async_gpdb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint64_t zero = 0;
+ 	struct port_database_24xx *pd;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;
+ 	int rval = QLA_SUCCESS;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, fcport->port_name, mb[1], mb[2]);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res) {
+ 		rval = res;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
+ 
+ 	/* Check for logged in state. */
+ 	if (pd->current_login_state != PDS_PRLI_COMPLETE &&
+ 	    pd->last_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0xffff,
+ 		    "Unable to verify login-state (%x/%x) for "
+ 		    "loop_id %x.\n", pd->current_login_state,
+ 		    pd->last_login_state, fcport->loop_id);
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	if (fcport->loop_id == FC_NO_LOOP_ID ||
+ 	    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&
+ 		memcmp(fcport->port_name, pd->port_name, 8))) {
+ 		/* We lost the device mid way. */
+ 		rval = QLA_NOT_LOGGED_IN;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	/* Names are little-endian. */
+ 	memcpy(fcport->node_name, pd->node_name, WWN_SIZE);
+ 
+ 	/* Get port_id of device. */
+ 	fcport->d_id.b.domain = pd->port_id[0];
+ 	fcport->d_id.b.area = pd->port_id[1];
+ 	fcport->d_id.b.al_pa = pd->port_id[2];
+ 	fcport->d_id.b.rsvd_1 = 0;
+ 
+ 	/* If not target must be initiator or unknown type. */
+ 	if ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 		fcport->port_type = FCT_INITIATOR;
+ 	else
+ 		fcport->port_type = FCT_TARGET;
+ 
+ 	/* Passback COS information. */
+ 	fcport->supported_classes = (pd->flags & PDF_CLASS_2) ?
+ 		FC_COS_CLASS2 : FC_COS_CLASS3;
+ 
+ 	if (pd->prli_svc_param_word_3[0] & BIT_7) {
+ 		fcport->flags |= FCF_CONF_COMP_SUPPORTED;
+ 		fcport->conf_compl_supported = 1;
+ 	}
+ 
+ gpd_error_out:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPDB_DONE;
+ 	ea.rc = rval;
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	dma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,
+ 		sp->u.iocb_cmd.u.mbx.in_dma);
+ 
+ 	sp->free(sp);
+ }
+ 
+ static int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+     u8 opt)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPDB);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	e->u.fcport.opt = opt;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	u16 *mb;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GPDB;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gpdb";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_GET_PORT_DATABASE;
+ 	mb[1] = fcport->loop_id;
+ 	mb[2] = MSW(pd_dma);
+ 	mb[3] = LSW(pd_dma);
+ 	mb[6] = MSW(MSD(pd_dma));
+ 	mb[7] = LSW(MSD(pd_dma));
+ 	mb[9] = vha->vp_idx;
+ 	mb[10] = opt;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 	mbx->u.mbx.in = (void *)pd;
+ 	mbx->u.mbx.in_dma = pd_dma;
+ 
+ 	sp->done = qla24xx_async_gpdb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hndl %x opt %x\n",
+ 		sp->name, fcport->port_name, sp->handle, opt);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ 
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	qla24xx_post_gpdb_work(vha, fcport, opt);
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	int rval = ea->rc;
+ 	fc_port_t *fcport = ea->fcport;
+ 	unsigned long flags;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
+ 	    fcport->disc_state, fcport->fw_login_state, rval);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 		return;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	ea->fcport->login_gen++;
+ 	ea->fcport->deleted = 0;
+ 	ea->fcport->logout_on_delete = 1;
+ 
+ 	if (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {
+ 		vha->fcport_count++;
+ 		ea->fcport->login_succ = 1;
+ 
+ 		if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 		    !vha->hw->flags.gpsc_supported) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_upd_fcport_work(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gpsc fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_gpsc_work(vha, fcport);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ } /* gpdb event */
+ 
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	if (fcport->login_retry == 0)
+ 		return 0;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND)
+ 		return 0;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
+ 	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
+ 	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
+ 	    fcport->loop_id);
+ 
+ 	fcport->login_retry--;
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PLOGI_COMP) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return 0;
+ 
+ 	/* for pure Target Mode. Login will not be initiated */
+ 	if (vha->host->active_mode == MODE_TARGET)
+ 		return 0;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return 0;
+ 	}
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gnl\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_async_gnl(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 		break;
+ 
+ 	case DSC_GNL:
+ 		if (fcport->login_pause) {
+ 			fcport->last_rscn_gen = fcport->rscn_gen;
+ 			fcport->last_login_gen = fcport->login_gen;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
+ 		}
+ 
+ 		if (fcport->flags & FCF_FCP2_DEVICE) {
+ 			u8 opt = PDO_FORCE_ADISC;
+ 
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 			fcport->disc_state = DSC_GPDB;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 
+ 		break;
+ 
+ 	case DSC_LOGIN_FAILED:
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gidpn \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		break;
+ 
+ 	case DSC_LOGIN_COMPLETE:
+ 		/* recheck login state */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gpdb_work(vha, fcport, PDO_FORCE_ADISC);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_rscn_event(fc_port_t *fcport, struct event_arg *ea)
+ {
+ 	fcport->rscn_gen++;
+ 
+ 	ql_dbg(ql_dbg_disc, fcport->vha, 0xffff,
+ 		"%s %8phC DS %d LS %d\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state);
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT)
+ 		return;
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 	case DSC_LOGIN_COMPLETE:
+ 		qla24xx_post_gidpn_work(fcport->vha, fcport);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,
+ 	u8 *port_name, void *pla)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.new_sess.id = *id;
+ 	e->u.new_sess.pla = pla;
+ 	memcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ int qla24xx_handle_delete_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	switch (vha->host->active_mode) {
+ 	case MODE_INITIATOR:
+ 	case MODE_DUAL:
+ 		if (fcport->scan_state == QLA_FCPORT_FOUND)
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 		break;
+ 
+ 	case MODE_TARGET:
+ 	default:
+ 		/* no-op */
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_relogin_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state, fcport->login_pause,
+ 		fcport->deleted, fcport->conflict,
+ 		fcport->last_rscn_gen, fcport->rscn_gen,
+ 		fcport->last_login_gen, fcport->login_gen,
+ 		fcport->flags);
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PLOGI_COMP) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		fcport->login_retry++;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_async_gidpn(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	qla24xx_fcport_handle_login(vha, fcport);
+ }
+ 
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *f, *tf;
+ 	uint32_t id = 0, mask, rid;
+ 	int rc;
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 
+ 		qla24xx_handle_relogin_event(vha, ea);
+ 		break;
+ 	case FCME_RSCN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 		switch (ea->id.b.rsvd_1) {
+ 		case RSCN_PORT_ADDR:
+ 			fcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);
+ 			if (!fcport) {
+ 				/* cable moved */
+ 				rc = qla24xx_post_gpnid_work(vha, &ea->id);
+ 				if (rc) {
+ 					ql_log(ql_log_warn, vha, 0xffff,
+ 						"RSCN GPNID work failed %02x%02x%02x\n",
+ 						ea->id.b.domain, ea->id.b.area,
+ 						ea->id.b.al_pa);
+ 				}
+ 			} else {
+ 				ea->fcport = fcport;
+ 				qla24xx_handle_rscn_event(fcport, ea);
+ 			}
+ 			break;
+ 		case RSCN_AREA_ADDR:
+ 		case RSCN_DOM_ADDR:
+ 			if (ea->id.b.rsvd_1 == RSCN_AREA_ADDR) {
+ 				mask = 0xffff00;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Area 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			} else {
+ 				mask = 0xff0000;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Domain 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			}
+ 
+ 			rid = ea->id.b24 & mask;
+ 			list_for_each_entry_safe(f, tf, &vha->vp_fcports,
+ 			    list) {
+ 				id = f->d_id.b24 & mask;
+ 				if (rid == id) {
+ 					ea->fcport = f;
+ 					qla24xx_handle_rscn_event(f, ea);
+ 				}
+ 			}
+ 			break;
+ 		case RSCN_FAB_ADDR:
+ 		default:
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 				"RSCN: Fabric was affected. Addr format %d\n",
+ 				ea->id.b.rsvd_1);
+ 			qla2x00_mark_all_devices_lost(vha, 1);
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 		}
+ 		break;
+ 	case FCME_GIDPN_DONE:
+ 		qla24xx_handle_gidpn_event(vha, ea);
+ 		break;
+ 	case FCME_GNL_DONE:
+ 		qla24xx_handle_gnl_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPSC_DONE:
+ 		qla24xx_post_upd_fcport_work(vha, ea->fcport);
+ 		break;
+ 	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
+ 		qla24xx_handle_plogi_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPDB_DONE:
+ 		qla24xx_handle_gpdb_event(vha, ea);
+ 		break;
+ 	case FCME_GPNID_DONE:
+ 		qla24xx_handle_gpnid_event(vha, ea);
+ 		break;
+ 	case FCME_DELETE_DONE:
+ 		qla24xx_handle_delete_done_event(vha, ea);
+ 		break;
+ 	default:
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
diff --cc drivers/scsi/qla2xxx/qla_inline.h
index 0ac13772fc47,66df6cec59da..000000000000
--- a/drivers/scsi/qla2xxx/qla_inline.h
+++ b/drivers/scsi/qla2xxx/qla_inline.h
@@@ -276,9 -286,10 +276,13 @@@ qla2x00_init_timer(srb_t *sp, unsigned 
  	sp->u.iocb_cmd.timer.function = qla2x00_sp_timeout;
  	add_timer(&sp->u.iocb_cmd.timer);
  	sp->free = qla2x00_sp_free;
++<<<<<<< HEAD
 +	if ((IS_QLAFX00(sp->fcport->vha->hw)) &&
 +	    (sp->type == SRB_FXIOCB_DCMD))
++=======
+ 	if (IS_QLAFX00(sp->vha->hw) && (sp->type == SRB_FXIOCB_DCMD))
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  		init_completion(&sp->u.iocb_cmd.u.fxiocb.fxiocb_comp);
 -	if (sp->type == SRB_ELS_DCMD)
 -		init_completion(&sp->u.iocb_cmd.u.els_logo.comp);
  }
  
  static inline int
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 2aea13d9d71e,535079280288..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -1067,10 -1102,25 +1067,29 @@@ qla24xx_walk_and_build_prot_sglist(stru
  	int	i;
  	struct scsi_cmnd *cmd;
  	uint32_t *cur_dsd = dsd;
 -	uint16_t used_dsds = tot_dsds;
 -	struct scsi_qla_host *vha;
 +	uint16_t	used_dsds = tot_dsds;
  
++<<<<<<< HEAD
 +	cmd = GET_CMD_SP(sp);
 +	scsi_for_each_prot_sg(cmd, sg, tot_dsds, i) {
++=======
+ 	if (sp) {
+ 		cmd = GET_CMD_SP(sp);
+ 		sgl = scsi_prot_sglist(cmd);
+ 		vha = sp->vha;
+ 	} else if (tc) {
+ 		vha = tc->vha;
+ 		sgl = tc->prot_sg;
+ 	} else {
+ 		BUG();
+ 		return 1;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe021,
+ 		"%s: enter\n", __func__);
+ 
+ 	for_each_sg(sgl, sg, tot_dsds, i) {
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  		dma_addr_t	sle_dma;
  
  		/* Allocate additional continuation packets? */
@@@ -1377,9 -1415,8 +1396,9 @@@ qla24xx_start_scsi(srb_t *sp
  	struct req_que *req = NULL;
  	struct rsp_que *rsp = NULL;
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
- 	struct scsi_qla_host *vha = sp->fcport->vha;
+ 	struct scsi_qla_host *vha = sp->vha;
  	struct qla_hw_data *ha = vha->hw;
 +	char		tag[2];
  
  	/* Setup device pointers. */
  	req = vha->req;
@@@ -2301,9 -2338,192 +2320,194 @@@ qla24xx_tm_iocb(srb_t *sp, struct tsk_m
  }
  
  static void
++<<<<<<< HEAD
++=======
+ qla2x00_els_dcmd_sp_free(void *data)
+ {
+ 	srb_t *sp = data;
+ 	struct srb_iocb *elsio = &sp->u.iocb_cmd;
+ 
+ 	kfree(sp->fcport);
+ 
+ 	if (elsio->u.els_logo.els_logo_pyld)
+ 		dma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,
+ 		    elsio->u.els_logo.els_logo_pyld,
+ 		    elsio->u.els_logo.els_logo_pyld_dma);
+ 
+ 	del_timer(&elsio->timer);
+ 	qla2x00_rel_sp(sp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd_iocb_timeout(void *data)
+ {
+ 	srb_t *sp = data;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	unsigned long flags = 0;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3069,
+ 	    "%s Timeout, hdl=%x, portid=%02x%02x%02x\n",
+ 	    sp->name, sp->handle, fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa);
+ 
+ 	/* Abort the exchange */
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	if (ha->isp_ops->abort_command(sp)) {
+ 		ql_dbg(ql_dbg_io, vha, 0x3070,
+ 		    "mbx abort_command failed.\n");
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0x3071,
+ 		    "mbx abort_command success.\n");
+ 	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	complete(&lio->u.els_logo.comp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd_sp_done(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3072,
+ 	    "%s hdl=%x, portid=%02x%02x%02x done\n",
+ 	    sp->name, sp->handle, fcport->d_id.b.domain,
+ 	    fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 
+ 	complete(&lio->u.els_logo.comp);
+ }
+ 
+ int
+ qla24xx_els_dcmd_iocb(scsi_qla_host_t *vha, int els_opcode,
+     port_id_t remote_did)
+ {
+ 	srb_t *sp;
+ 	fc_port_t *fcport = NULL;
+ 	struct srb_iocb *elsio = NULL;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct els_logo_payload logo_pyld;
+ 	int rval = QLA_SUCCESS;
+ 
+ 	fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);
+ 	if (!fcport) {
+ 	       ql_log(ql_log_info, vha, 0x70e5, "fcport allocation failed\n");
+ 	       return -ENOMEM;
+ 	}
+ 
+ 	/* Alloc SRB structure */
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		kfree(fcport);
+ 		ql_log(ql_log_info, vha, 0x70e6,
+ 		 "SRB allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	elsio = &sp->u.iocb_cmd;
+ 	fcport->loop_id = 0xFFFF;
+ 	fcport->d_id.b.domain = remote_did.b.domain;
+ 	fcport->d_id.b.area = remote_did.b.area;
+ 	fcport->d_id.b.al_pa = remote_did.b.al_pa;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3073, "portid=%02x%02x%02x done\n",
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 
+ 	sp->type = SRB_ELS_DCMD;
+ 	sp->name = "ELS_DCMD";
+ 	sp->fcport = fcport;
+ 	qla2x00_init_timer(sp, ELS_DCMD_TIMEOUT);
+ 	elsio->timeout = qla2x00_els_dcmd_iocb_timeout;
+ 	sp->done = qla2x00_els_dcmd_sp_done;
+ 	sp->free = qla2x00_els_dcmd_sp_free;
+ 
+ 	elsio->u.els_logo.els_logo_pyld = dma_alloc_coherent(&ha->pdev->dev,
+ 			    DMA_POOL_SIZE, &elsio->u.els_logo.els_logo_pyld_dma,
+ 			    GFP_KERNEL);
+ 
+ 	if (!elsio->u.els_logo.els_logo_pyld) {
+ 		sp->free(sp);
+ 		return QLA_FUNCTION_FAILED;
+ 	}
+ 
+ 	memset(&logo_pyld, 0, sizeof(struct els_logo_payload));
+ 
+ 	elsio->u.els_logo.els_cmd = els_opcode;
+ 	logo_pyld.opcode = els_opcode;
+ 	logo_pyld.s_id[0] = vha->d_id.b.al_pa;
+ 	logo_pyld.s_id[1] = vha->d_id.b.area;
+ 	logo_pyld.s_id[2] = vha->d_id.b.domain;
+ 	host_to_fcp_swap(logo_pyld.s_id, sizeof(uint32_t));
+ 	memcpy(&logo_pyld.wwpn, vha->port_name, WWN_SIZE);
+ 
+ 	memcpy(elsio->u.els_logo.els_logo_pyld, &logo_pyld,
+ 	    sizeof(struct els_logo_payload));
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		sp->free(sp);
+ 		return QLA_FUNCTION_FAILED;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3074,
+ 	    "%s LOGO sent, hdl=%x, loopid=%x, portid=%02x%02x%02x.\n",
+ 	    sp->name, sp->handle, fcport->loop_id, fcport->d_id.b.domain,
+ 	    fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 
+ 	wait_for_completion(&elsio->u.els_logo.comp);
+ 
+ 	sp->free(sp);
+ 	return rval;
+ }
+ 
+ static void
+ qla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
+ {
+ 	scsi_qla_host_t *vha = sp->vha;
+ 	struct srb_iocb *elsio = &sp->u.iocb_cmd;
+ 
+ 	els_iocb->entry_type = ELS_IOCB_TYPE;
+ 	els_iocb->entry_count = 1;
+ 	els_iocb->sys_define = 0;
+ 	els_iocb->entry_status = 0;
+ 	els_iocb->handle = sp->handle;
+ 	els_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
+ 	els_iocb->tx_dsd_count = 1;
+ 	els_iocb->vp_index = vha->vp_idx;
+ 	els_iocb->sof_type = EST_SOFI3;
+ 	els_iocb->rx_dsd_count = 0;
+ 	els_iocb->opcode = elsio->u.els_logo.els_cmd;
+ 
+ 	els_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;
+ 	els_iocb->port_id[1] = sp->fcport->d_id.b.area;
+ 	els_iocb->port_id[2] = sp->fcport->d_id.b.domain;
+ 	els_iocb->control_flags = 0;
+ 
+ 	els_iocb->tx_byte_count = sizeof(struct els_logo_payload);
+ 	els_iocb->tx_address[0] =
+ 	    cpu_to_le32(LSD(elsio->u.els_logo.els_logo_pyld_dma));
+ 	els_iocb->tx_address[1] =
+ 	    cpu_to_le32(MSD(elsio->u.els_logo.els_logo_pyld_dma));
+ 	els_iocb->tx_len = cpu_to_le32(sizeof(struct els_logo_payload));
+ 
+ 	els_iocb->rx_byte_count = 0;
+ 	els_iocb->rx_address[0] = 0;
+ 	els_iocb->rx_address[1] = 0;
+ 	els_iocb->rx_len = 0;
+ 
+ 	sp->vha->qla_stats.control_requests++;
+ }
+ 
+ static void
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  qla24xx_els_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
  {
 -	struct bsg_job *bsg_job = sp->u.bsg_job;
 -	struct fc_bsg_request *bsg_request = bsg_job->request;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
  
          els_iocb->entry_type = ELS_IOCB_TYPE;
          els_iocb->entry_count = 1;
@@@ -2354,9 -2574,9 +2558,9 @@@ qla2x00_ct_iocb(srb_t *sp, ms_iocb_entr
  	struct scatterlist *sg;
  	int index;
  	uint16_t tot_dsds;
- 	scsi_qla_host_t *vha = sp->fcport->vha;
+ 	scsi_qla_host_t *vha = sp->vha;
  	struct qla_hw_data *ha = vha->hw;
 -	struct bsg_job *bsg_job = sp->u.bsg_job;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
  	int loop_iterartion = 0;
  	int entry_count = 1;
  
@@@ -2431,9 -2651,9 +2635,9 @@@ qla24xx_ct_iocb(srb_t *sp, struct ct_en
  	struct scatterlist *sg;
  	int index;
  	uint16_t tot_dsds;
-         scsi_qla_host_t *vha = sp->fcport->vha;
+ 	scsi_qla_host_t *vha = sp->vha;
  	struct qla_hw_data *ha = vha->hw;
 -	struct bsg_job *bsg_job = sp->u.bsg_job;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
  	int loop_iterartion = 0;
  	int entry_count = 1;
  
@@@ -2892,7 -3130,8 +3096,12 @@@ in
  qla2x00_start_sp(srb_t *sp)
  {
  	int rval;
++<<<<<<< HEAD
 +	struct qla_hw_data *ha = sp->fcport->vha->hw;
++=======
+ 	scsi_qla_host_t *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  	void *pkt;
  	unsigned long flags;
  
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 5ffd1682f367,914cc5a66b34..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -1354,6 -1377,49 +1354,52 @@@ logio_done
  }
  
  static void
++<<<<<<< HEAD
++=======
+ qla24xx_mbx_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,
+     struct mbx_24xx_entry *pkt)
+ {
+ 	const char func[] = "MBX-IOCB2";
+ 	srb_t *sp;
+ 	struct srb_iocb *si;
+ 	u16 sz, i;
+ 	int res;
+ 
+ 	sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
+ 	if (!sp)
+ 		return;
+ 
+ 	si = &sp->u.iocb_cmd;
+ 	sz = min(ARRAY_SIZE(pkt->mb), ARRAY_SIZE(sp->u.iocb_cmd.u.mbx.in_mb));
+ 
+ 	for (i = 0; i < sz; i++)
+ 		si->u.mbx.in_mb[i] = le16_to_cpu(pkt->mb[i]);
+ 
+ 	res = (si->u.mbx.in_mb[0] & MBS_MASK);
+ 
+ 	sp->done(sp, res);
+ }
+ 
+ static void
+ qla24xxx_nack_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,
+     struct nack_to_isp *pkt)
+ {
+ 	const char func[] = "nack";
+ 	srb_t *sp;
+ 	int res = 0;
+ 
+ 	sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
+ 	if (!sp)
+ 		return;
+ 
+ 	if (pkt->u.isp2x.status != cpu_to_le16(NOTIFY_ACK_SUCCESS))
+ 		res = QLA_FUNCTION_FAILED;
+ 
+ 	sp->done(sp, res);
+ }
+ 
+ static void
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  qla2x00_ct_entry(scsi_qla_host_t *vha, struct req_que *req,
      sts_entry_t *pkt, int iocb_type)
  {
@@@ -1368,46 -1435,60 +1414,46 @@@
  	if (!sp)
  		return;
  
 -	switch (sp->type) {
 -	case SRB_CT_CMD:
 -	    bsg_job = sp->u.bsg_job;
 -	    bsg_reply = bsg_job->reply;
 -
 -	    type = "ct pass-through";
 -
 -	    comp_status = le16_to_cpu(pkt->comp_status);
 -
 -	    /*
 -	     * return FC_CTELS_STATUS_OK and leave the decoding of the ELS/CT
 -	     * fc payload  to the caller
 -	     */
 -	    bsg_reply->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;
 -	    bsg_job->reply_len = sizeof(struct fc_bsg_reply);
 -
 -	    if (comp_status != CS_COMPLETE) {
 -		    if (comp_status == CS_DATA_UNDERRUN) {
 -			    res = DID_OK << 16;
 -			    bsg_reply->reply_payload_rcv_len =
 -				le16_to_cpu(((sts_entry_t *)pkt)->rsp_info_len);
 -
 -			    ql_log(ql_log_warn, vha, 0x5048,
 -				"CT pass-through-%s error comp_status=0x%x total_byte=0x%x.\n",
 -				type, comp_status,
 -				bsg_reply->reply_payload_rcv_len);
 -		    } else {
 -			    ql_log(ql_log_warn, vha, 0x5049,
 -				"CT pass-through-%s error comp_status=0x%x.\n",
 -				type, comp_status);
 -			    res = DID_ERROR << 16;
 -			    bsg_reply->reply_payload_rcv_len = 0;
 -		    }
 -		    ql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5035,
 -			(uint8_t *)pkt, sizeof(*pkt));
 -	    } else {
 -		    res = DID_OK << 16;
 -		    bsg_reply->reply_payload_rcv_len =
 -			bsg_job->reply_payload.payload_len;
 -		    bsg_job->reply_len = 0;
 -	    }
 -	    break;
 -	case SRB_CT_PTHRU_CMD:
 -	    /*
 -	     * borrowing sts_entry_24xx.comp_status.
 -	     * same location as ct_entry_24xx.comp_status
 -	     */
 -	     res = qla2x00_chk_ms_status(vha, (ms_iocb_entry_t *)pkt,
 -		 (struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp,
 -		 sp->name);
 -	     break;
 +	bsg_job = sp->u.bsg_job;
 +
 +	type = "ct pass-through";
 +
 +	comp_status = le16_to_cpu(pkt->comp_status);
 +
 +	/* return FC_CTELS_STATUS_OK and leave the decoding of the ELS/CT
 +	 * fc payload  to the caller
 +	 */
 +	bsg_job->reply->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;
 +	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
 +
 +	if (comp_status != CS_COMPLETE) {
 +		if (comp_status == CS_DATA_UNDERRUN) {
 +			res = DID_OK << 16;
 +			bsg_job->reply->reply_payload_rcv_len =
 +			    le16_to_cpu(((sts_entry_t *)pkt)->rsp_info_len);
 +
 +			ql_log(ql_log_warn, vha, 0x5048,
 +			    "CT pass-through-%s error "
 +			    "comp_status-status=0x%x total_byte = 0x%x.\n",
 +			    type, comp_status,
 +			    bsg_job->reply->reply_payload_rcv_len);
 +		} else {
 +			ql_log(ql_log_warn, vha, 0x5049,
 +			    "CT pass-through-%s error "
 +			    "comp_status-status=0x%x.\n", type, comp_status);
 +			res = DID_ERROR << 16;
 +			bsg_job->reply->reply_payload_rcv_len = 0;
 +		}
 +		ql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5035,
 +		    (uint8_t *)pkt, sizeof(*pkt));
 +	} else {
 +		res = DID_OK << 16;
 +		bsg_job->reply->reply_payload_rcv_len =
 +		    bsg_job->reply_payload.payload_len;
 +		bsg_job->reply_len = 0;
  	}
  
- 	sp->done(vha, sp, res);
+ 	sp->done(sp, res);
  }
  
  static void
@@@ -1437,6 -1520,21 +1483,24 @@@ qla24xx_els_ct_entry(scsi_qla_host_t *v
  	case SRB_CT_CMD:
  		type = "ct pass-through";
  		break;
++<<<<<<< HEAD
++=======
+ 	case SRB_ELS_DCMD:
+ 		type = "Driver ELS logo";
+ 		ql_dbg(ql_dbg_user, vha, 0x5047,
+ 		    "Completing %s: (%p) type=%d.\n", type, sp, sp->type);
+ 		sp->done(sp, 0);
+ 		return;
+ 	case SRB_CT_PTHRU_CMD:
+ 		/* borrowing sts_entry_24xx.comp_status.
+ 		   same location as ct_entry_24xx.comp_status
+ 		 */
+ 		res = qla2x00_chk_ms_status(vha, (ms_iocb_entry_t *)pkt,
+ 			(struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp,
+ 			sp->name);
+ 		sp->done(sp, res);
+ 		return;
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  	default:
  		ql_dbg(ql_dbg_user, vha, 0x503e,
  		    "Unrecognized SRB: (%p) type=%d.\n", sp, sp->type);
@@@ -1750,8 -1866,8 +1814,13 @@@ qla2x00_handle_sense(srb_t *sp, uint8_
  
  	if (sense_len) {
  		ql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x301c,
++<<<<<<< HEAD
 +		    "Check condition Sense data, nexus%ld:%d:%d cmd=%p.\n",
 +		    sp->fcport->vha->host_no, cp->device->id, cp->device->lun,
++=======
+ 		    "Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\n",
+ 		    sp->vha->host_no, cp->device->id, cp->device->lun,
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  		    cp);
  		ql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302b,
  		    cp->sense_buffer, sense_len);
@@@ -2485,9 -2614,13 +2554,9 @@@ qla2x00_error_entry(scsi_qla_host_t *vh
  	if (pkt->entry_status & RF_BUSY)
  		res = DID_BUS_BUSY << 16;
  
 -	if (pkt->entry_type == NOTIFY_ACK_TYPE &&
 -	    pkt->handle == QLA_TGT_SKIP_HANDLE)
 -		return;
 -
  	sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
  	if (sp) {
- 		sp->done(vha, sp, res);
+ 		sp->done(sp, res);
  		return;
  	}
  fatal:
diff --cc drivers/scsi/qla2xxx/qla_mr.c
index 4b49db25c794,945b6320e7d7..000000000000
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@@ -2161,8 -2161,8 +2161,13 @@@ qlafx00_handle_sense(srb_t *sp, uint8_
  
  	if (sense_len) {
  		ql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3039,
++<<<<<<< HEAD
 +		    "Check condition Sense data, nexus%ld:%d:%d cmd=%p.\n",
 +		    sp->fcport->vha->host_no, cp->device->id, cp->device->lun,
++=======
+ 		    "Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\n",
+ 		    sp->vha->host_no, cp->device->id, cp->device->lun,
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  		    cp);
  		ql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x3049,
  		    cp->sense_buffer, sense_len);
@@@ -2259,11 -2260,11 +2264,11 @@@ qlafx00_ioctl_iosb_entry(scsi_qla_host_
  		    sp->fcport->vha, 0x5074,
  		    (uint8_t *)fw_sts_ptr, sizeof(struct qla_mt_iocb_rsp_fx00));
  
 -		res = bsg_reply->result = DID_OK << 16;
 -		bsg_reply->reply_payload_rcv_len =
 +		res = bsg_job->reply->result = DID_OK << 16;
 +		bsg_job->reply->reply_payload_rcv_len =
  		    bsg_job->reply_payload.payload_len;
  	}
- 	sp->done(vha, sp, res);
+ 	sp->done(sp, res);
  }
  
  /**
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,45f5077684f0..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -333,9 -517,403 +333,406 @@@ void qlt_response_pkt_all_vps(struct sc
  
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * All qlt_plogi_ack_t operations are protected by hardware_lock
+  */
+ static int qla24xx_post_nack_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+ 	struct imm_ntfy_from_isp *ntfy, int type)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NACK);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.nack.fcport = fcport;
+ 	e->u.nack.type = type;
+ 	memcpy(e->u.nack.iocb, ntfy, sizeof(struct imm_ntfy_from_isp));
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla2x00_async_nack_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = (struct srb *)s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	unsigned long flags;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async done-%s res %x %8phC  type %d\n",
+ 		sp->name, res, sp->fcport->port_name, sp->type);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 	sp->fcport->chip_reset = vha->hw->chip_reset;
+ 
+ 	switch (sp->type) {
+ 	case SRB_NACK_PLOGI:
+ 		sp->fcport->login_gen++;
+ 		sp->fcport->fw_login_state = DSC_LS_PLOGI_COMP;
+ 		sp->fcport->logout_on_delete = 1;
+ 		break;
+ 
+ 	case SRB_NACK_PRLI:
+ 		sp->fcport->fw_login_state = DSC_LS_PRLI_COMP;
+ 		sp->fcport->deleted = 0;
+ 
+ 		if (!sp->fcport->login_succ &&
+ 		    !IS_SW_RESV_ADDR(sp->fcport->d_id)) {
+ 			sp->fcport->login_succ = 1;
+ 
+ 			vha->fcport_count++;
+ 
+ 			if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 			    !vha->hw->flags.gpsc_supported) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					"%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 					__func__, __LINE__,
+ 					sp->fcport->port_name,
+ 					vha->fcport_count);
+ 
+ 				qla24xx_post_upd_fcport_work(vha, sp->fcport);
+ 			} else {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					"%s %d %8phC post gpsc fcp_cnt %d\n",
+ 					__func__, __LINE__,
+ 					sp->fcport->port_name,
+ 					vha->fcport_count);
+ 
+ 				qla24xx_post_gpsc_work(vha, sp->fcport);
+ 			}
+ 		}
+ 		break;
+ 
+ 	case SRB_NACK_LOGO:
+ 		sp->fcport->login_gen++;
+ 		sp->fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		qlt_logo_completion_handler(sp->fcport, MBS_COMMAND_COMPLETE);
+ 		break;
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_notify_ack(scsi_qla_host_t *vha, fc_port_t *fcport,
+ 	struct imm_ntfy_from_isp *ntfy, int type)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	srb_t *sp;
+ 	char *c = NULL;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	switch (type) {
+ 	case SRB_NACK_PLOGI:
+ 		fcport->fw_login_state = DSC_LS_PLOGI_PEND;
+ 		c = "PLOGI";
+ 		break;
+ 	case SRB_NACK_PRLI:
+ 		fcport->fw_login_state = DSC_LS_PRLI_PEND;
+ 		c = "PRLI";
+ 		break;
+ 	case SRB_NACK_LOGO:
+ 		fcport->fw_login_state = DSC_LS_LOGO_PEND;
+ 		c = "LOGO";
+ 		break;
+ 	}
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = type;
+ 	sp->name = "nack";
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	sp->u.iocb_cmd.u.nack.ntfy = ntfy;
+ 
+ 	sp->done = qla2x00_async_nack_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hndl %x %s\n",
+ 		sp->name, fcport->port_name, sp->handle, c);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ void qla24xx_do_nack_work(struct scsi_qla_host *vha, struct qla_work_evt *e)
+ {
+ 	fc_port_t *t;
+ 	unsigned long flags;
+ 
+ 	switch (e->u.nack.type) {
+ 	case SRB_NACK_PRLI:
+ 		mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 		t = qlt_create_sess(vha, e->u.nack.fcport, 0);
+ 		mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 		if (t) {
+ 			ql_log(ql_log_info, vha, 0xffff,
+ 			    "%s create sess success %p", __func__, t);
+ 			spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 			/* create sess has an extra kref */
+ 			vha->hw->tgt.tgt_ops->put_sess(e->u.nack.fcport);
+ 			spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		}
+ 		break;
+ 	}
+ 	qla24xx_async_notify_ack(vha, e->u.nack.fcport,
+ 	    (struct imm_ntfy_from_isp*)e->u.nack.iocb, e->u.nack.type);
+ }
+ 
+ void qla24xx_delete_sess_fn(struct work_struct *work)
+ {
+ 	fc_port_t *fcport = container_of(work, struct fc_port, del_work);
+ 	struct qla_hw_data *ha = fcport->vha->hw;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 
+ 	if (fcport->se_sess) {
+ 		ha->tgt.tgt_ops->shutdown_sess(fcport);
+ 		ha->tgt.tgt_ops->put_sess(fcport);
+ 	} else {
+ 		qlt_unreg_sess(fcport);
+ 	}
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ /*
+  * Called from qla2x00_reg_remote_port()
+  */
+ void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct fc_port *sess = fcport;
+ 	unsigned long flags;
+ 
+ 	if (!vha->hw->tgt.tgt_ops)
+ 		return;
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	if (tgt->tgt_stop) {
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (!sess->se_sess) {
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 		mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 		sess = qlt_create_sess(vha, fcport, false);
+ 		mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	} else {
+ 		if (fcport->fw_login_state == DSC_LS_PRLI_COMP) {
+ 			spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 			return;
+ 		}
+ 
+ 		if (!kref_get_unless_zero(&sess->sess_kref)) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s: kref_get fail sess %8phC \n",
+ 			    __func__, sess->port_name);
+ 			spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 			return;
+ 		}
+ 
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04c,
+ 		    "qla_target(%u): %ssession for port %8phC "
+ 		    "(loop ID %d) reappeared\n", vha->vp_idx,
+ 		    sess->local ? "local " : "", sess->port_name, sess->loop_id);
+ 
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf007,
+ 		    "Reappeared sess %p\n", sess);
+ 
+ 		ha->tgt.tgt_ops->update_sess(sess, fcport->d_id,
+ 		    fcport->loop_id,
+ 		    (fcport->flags & FCF_CONF_COMP_SUPPORTED));
+ 	}
+ 
+ 	if (sess && sess->local) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04d,
+ 		    "qla_target(%u): local session for "
+ 		    "port %8phC (loop ID %d) became global\n", vha->vp_idx,
+ 		    fcport->port_name, sess->loop_id);
+ 		sess->local = 0;
+ 	}
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ /*
+  * This is a zero-base ref-counting solution, since hardware_lock
+  * guarantees that ref_count is not modified concurrently.
+  * Upon successful return content of iocb is undefined
+  */
+ static struct qlt_plogi_ack_t *
+ qlt_plogi_ack_find_add(struct scsi_qla_host *vha, port_id_t *id,
+ 		       struct imm_ntfy_from_isp *iocb)
+ {
+ 	struct qlt_plogi_ack_t *pla;
+ 
+ 	list_for_each_entry(pla, &vha->plogi_ack_list, list) {
+ 		if (pla->id.b24 == id->b24) {
+ 			qlt_send_term_imm_notif(vha, &pla->iocb, 1);
+ 			memcpy(&pla->iocb, iocb, sizeof(pla->iocb));
+ 			return pla;
+ 		}
+ 	}
+ 
+ 	pla = kmem_cache_zalloc(qla_tgt_plogi_cachep, GFP_ATOMIC);
+ 	if (!pla) {
+ 		ql_dbg(ql_dbg_async, vha, 0x5088,
+ 		       "qla_target(%d): Allocation of plogi_ack failed\n",
+ 		       vha->vp_idx);
+ 		return NULL;
+ 	}
+ 
+ 	memcpy(&pla->iocb, iocb, sizeof(pla->iocb));
+ 	pla->id = *id;
+ 	list_add_tail(&pla->list, &vha->plogi_ack_list);
+ 
+ 	return pla;
+ }
+ 
+ void qlt_plogi_ack_unref(struct scsi_qla_host *vha,
+     struct qlt_plogi_ack_t *pla)
+ {
+ 	struct imm_ntfy_from_isp *iocb = &pla->iocb;
+ 	port_id_t port_id;
+ 	uint16_t loop_id;
+ 	fc_port_t *fcport = pla->fcport;
+ 
+ 	BUG_ON(!pla->ref_count);
+ 	pla->ref_count--;
+ 
+ 	if (pla->ref_count)
+ 		return;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x5089,
+ 	    "Sending PLOGI ACK to wwn %8phC s_id %02x:%02x:%02x loop_id %#04x"
+ 	    " exch %#x ox_id %#x\n", iocb->u.isp24.port_name,
+ 	    iocb->u.isp24.port_id[2], iocb->u.isp24.port_id[1],
+ 	    iocb->u.isp24.port_id[0],
+ 	    le16_to_cpu(iocb->u.isp24.nport_handle),
+ 	    iocb->u.isp24.exchange_address, iocb->ox_id);
+ 
+ 	port_id.b.domain = iocb->u.isp24.port_id[2];
+ 	port_id.b.area   = iocb->u.isp24.port_id[1];
+ 	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
+ 	port_id.b.rsvd_1 = 0;
+ 
+ 	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
+ 
+ 	fcport->loop_id = loop_id;
+ 	fcport->d_id = port_id;
+ 	qla24xx_post_nack_work(vha, fcport, iocb, SRB_NACK_PLOGI);
+ 
+ 	list_for_each_entry(fcport, &vha->vp_fcports, list) {
+ 		if (fcport->plogi_link[QLT_PLOGI_LINK_SAME_WWN] == pla)
+ 			fcport->plogi_link[QLT_PLOGI_LINK_SAME_WWN] = NULL;
+ 		if (fcport->plogi_link[QLT_PLOGI_LINK_CONFLICT] == pla)
+ 			fcport->plogi_link[QLT_PLOGI_LINK_CONFLICT] = NULL;
+ 	}
+ 
+ 	list_del(&pla->list);
+ 	kmem_cache_free(qla_tgt_plogi_cachep, pla);
+ }
+ 
+ void
+ qlt_plogi_ack_link(struct scsi_qla_host *vha, struct qlt_plogi_ack_t *pla,
+     struct fc_port *sess, enum qlt_plogi_link_t link)
+ {
+ 	struct imm_ntfy_from_isp *iocb = &pla->iocb;
+ 	/* Inc ref_count first because link might already be pointing at pla */
+ 	pla->ref_count++;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf097,
+ 		"Linking sess %p [%d] wwn %8phC with PLOGI ACK to wwn %8phC"
+ 		" s_id %02x:%02x:%02x, ref=%d pla %p link %d\n",
+ 		sess, link, sess->port_name,
+ 		iocb->u.isp24.port_name, iocb->u.isp24.port_id[2],
+ 		iocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],
+ 		pla->ref_count, pla, link);
+ 
+ 	if (sess->plogi_link[link])
+ 		qlt_plogi_ack_unref(vha, sess->plogi_link[link]);
+ 
+ 	if (link == QLT_PLOGI_LINK_SAME_WWN)
+ 		pla->fcport = sess;
+ 
+ 	sess->plogi_link[link] = pla;
+ }
+ 
+ typedef struct {
+ 	/* These fields must be initialized by the caller */
+ 	port_id_t id;
+ 	/*
+ 	 * number of cmds dropped while we were waiting for
+ 	 * initiator to ack LOGO initialize to 1 if LOGO is
+ 	 * triggered by a command, otherwise, to 0
+ 	 */
+ 	int cmd_count;
+ 
+ 	/* These fields are used by callee */
+ 	struct list_head list;
+ } qlt_port_logo_t;
+ 
+ static void
+ qlt_send_first_logo(struct scsi_qla_host *vha, qlt_port_logo_t *logo)
+ {
+ 	qlt_port_logo_t *tmp;
+ 	int res;
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	list_for_each_entry(tmp, &vha->logo_list, list) {
+ 		if (tmp->id.b24 == logo->id.b24) {
+ 			tmp->cmd_count += logo->cmd_count;
+ 			mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 			return;
+ 		}
+ 	}
+ 
+ 	list_add_tail(&logo->list, &vha->logo_list);
+ 
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	res = qla24xx_els_dcmd_iocb(vha, ELS_DCMD_LOGO, logo->id);
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 	list_del(&logo->list);
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf098,
+ 	    "Finished LOGO to %02x:%02x:%02x, dropped %d cmds, res = %#x\n",
+ 	    logo->id.b.domain, logo->id.b.area, logo->id.b.al_pa,
+ 	    logo->cmd_count, res);
+ }
+ 
++>>>>>>> 25ff6af10562 (qla2xxx: Simplify usage of SRB structure in driver)
  static void qlt_free_session_done(struct work_struct *work)
  {
 -	struct fc_port *sess = container_of(work, struct fc_port,
 +	struct qla_tgt_sess *sess = container_of(work, struct qla_tgt_sess,
  	    free_work);
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
* Unmerged path drivers/scsi/qla2xxx/qla_bsg.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_gs.c
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_inline.h
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mr.c
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index ae651df67490..4aefd6bc1641 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -586,11 +586,11 @@ qla24xx_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)
 }
 
 void
-qla2x00_sp_free_dma(void *vha, void *ptr)
+qla2x00_sp_free_dma(void *ptr)
 {
-	srb_t *sp = (srb_t *)ptr;
+	srb_t *sp = ptr;
+	struct qla_hw_data *ha = sp->vha->hw;
 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
-	struct qla_hw_data *ha = sp->fcport->vha->hw;
 	void *ctx = GET_CMD_CTX_SP(sp);
 
 	if (sp->flags & SRB_DMA_VALID) {
@@ -629,20 +629,19 @@ qla2x00_sp_free_dma(void *vha, void *ptr)
 	}
 
 	CMD_SP(cmd) = NULL;
-	qla2x00_rel_sp(sp->fcport->vha, sp);
+	qla2x00_rel_sp(sp);
 }
 
 void
-qla2x00_sp_compl(void *data, void *ptr, int res)
+qla2x00_sp_compl(void *ptr, int res)
 {
-	struct qla_hw_data *ha = (struct qla_hw_data *)data;
-	srb_t *sp = (srb_t *)ptr;
+	srb_t *sp = ptr;
 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 
 	cmd->result = res;
 
 	if (atomic_read(&sp->ref_count) == 0) {
-		ql_dbg(ql_dbg_io, sp->fcport->vha, 0x3015,
+		ql_dbg(ql_dbg_io, sp->vha, 0x3015,
 		    "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
 		    sp, GET_CMD_SP(sp));
 		if (ql2xextended_error_logging & ql_dbg_io)
@@ -652,12 +651,12 @@ qla2x00_sp_compl(void *data, void *ptr, int res)
 	if (!atomic_dec_and_test(&sp->ref_count))
 		return;
 
-	qla2x00_sp_free_dma(ha, sp);
+	qla2x00_sp_free_dma(sp);
 	cmd->scsi_done(cmd);
 }
 
 void
-qla2xxx_qpair_sp_free_dma(void *vha, void *ptr)
+qla2xxx_qpair_sp_free_dma(void *ptr)
 {
 	srb_t *sp = (srb_t *)ptr;
 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
@@ -703,9 +702,9 @@ qla2xxx_qpair_sp_free_dma(void *vha, void *ptr)
 }
 
 void
-qla2xxx_qpair_sp_compl(void *data, void *ptr, int res)
+qla2xxx_qpair_sp_compl(void *ptr, int res)
 {
-	srb_t *sp = (srb_t *)ptr;
+	srb_t *sp = ptr;
 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 
 	cmd->result = res;
@@ -721,7 +720,7 @@ qla2xxx_qpair_sp_compl(void *data, void *ptr, int res)
 	if (!atomic_dec_and_test(&sp->ref_count))
 		return;
 
-	qla2xxx_qpair_sp_free_dma(sp->fcport->vha, sp);
+	qla2xxx_qpair_sp_free_dma(sp);
 	cmd->scsi_done(cmd);
 }
 
@@ -842,7 +841,7 @@ qla2xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)
 	return 0;
 
 qc24_host_busy_free_sp:
-	qla2x00_sp_free_dma(ha, sp);
+	qla2x00_sp_free_dma(sp);
 
 qc24_host_busy:
 	return SCSI_MLQUEUE_HOST_BUSY;
@@ -931,7 +930,7 @@ qla2xxx_mqueuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd,
 	return 0;
 
 qc24_host_busy_free_sp:
-	qla2xxx_qpair_sp_free_dma(vha, sp);
+	qla2xxx_qpair_sp_free_dma(sp);
 
 qc24_host_busy:
 	return SCSI_MLQUEUE_HOST_BUSY;
@@ -1187,7 +1186,7 @@ qla2xxx_eh_abort(struct scsi_cmnd *cmd)
 	}
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
-	sp->done(vha, sp, 0);
+	sp->done(sp, 0);
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	/* Did the command return during mailbox execution? */
@@ -1232,7 +1231,7 @@ qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *vha, unsigned int t,
 			continue;
 		if (sp->type != SRB_SCSI_CMD)
 			continue;
-		if (vha->vp_idx != sp->fcport->vha->vp_idx)
+		if (vha->vp_idx != sp->vha->vp_idx)
 			continue;
 		match = 0;
 		cmd = GET_CMD_SP(sp);
@@ -1613,7 +1612,7 @@ qla2x00_abort_all_cmds(scsi_qla_host_t *vha, int res)
 						atomic_dec(&sp->ref_count);
 				}
 				req->outstanding_cmds[cnt] = NULL;
-				sp->done(vha, sp, res);
+				sp->done(sp, res);
 			}
 		}
 	}
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
