net/mlx5: Add hash table for flow groups in flow table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add hash table for flow groups in flow table (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.15%
commit-author Matan Barak <matanb@mellanox.com>
commit 693c6883bbc4f7649750eb9ce49d0b799d073186
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/693c6883.failed

When adding a flow table entry (fte) to a flow table (ft), we first
need to find its flow group (fg). Currently, this is done by
traversing a linear list of all flow groups in the flow table.
Furthermore, since multiple flow groups which correspond to the same
fte mask may exist in the same ft, we can't just stop at the first
match. Converting the linear list to rhltable in order to speed things
up.

The last four patches increases the steering rules update rate by a
factor of more than 7 (for insertion of 50K steering rules).

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 693c6883bbc4f7649750eb9ce49d0b799d073186)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index bdd564dcef53,9704c2eb82a1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -149,6 -150,23 +149,26 @@@ enum fs_i_mutex_lock_class 
  	FS_MUTEX_CHILD
  };
  
++<<<<<<< HEAD
++=======
+ static const struct rhashtable_params rhash_fte = {
+ 	.key_len = FIELD_SIZEOF(struct fs_fte, val),
+ 	.key_offset = offsetof(struct fs_fte, val),
+ 	.head_offset = offsetof(struct fs_fte, hash),
+ 	.automatic_shrinking = true,
+ 	.min_size = 1,
+ };
+ 
+ static const struct rhashtable_params rhash_fg = {
+ 	.key_len = FIELD_SIZEOF(struct mlx5_flow_group, mask),
+ 	.key_offset = offsetof(struct mlx5_flow_group, mask),
+ 	.head_offset = offsetof(struct mlx5_flow_group, hash),
+ 	.automatic_shrinking = true,
+ 	.min_size = 1,
+ 
+ };
+ 
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  static void del_rule(struct fs_node *node);
  static void del_flow_table(struct fs_node *node);
  static void del_flow_group(struct fs_node *node);
@@@ -297,28 -313,36 +317,38 @@@ static bool compare_match_value(struct 
  			return false;
  	}
  
 -	if (!(match_criteria_enable &
 -	      1 << MLX5_CREATE_FLOW_GROUP_IN_MATCH_CRITERIA_ENABLE_INNER_HEADERS)) {
 -		char *fg_type_mask = MLX5_ADDR_OF(fte_match_param,
 -						  match_criteria, inner_headers);
 +	if (mask->match_criteria_enable &
 +	    1 << MLX5_CREATE_FLOW_GROUP_IN_MATCH_CRITERIA_ENABLE_INNER_HEADERS) {
 +		void *fte_match1 = MLX5_ADDR_OF(fte_match_param,
 +						fte_param1, inner_headers);
 +		void *fte_match2 = MLX5_ADDR_OF(fte_match_param,
 +						fte_param2, inner_headers);
 +		void *fte_mask = MLX5_ADDR_OF(fte_match_param,
 +					  mask->match_criteria, inner_headers);
  
 -		if (fg_type_mask[0] ||
 -		    memcmp(fg_type_mask, fg_type_mask + 1,
 -			   MLX5_ST_SZ_BYTES(fte_match_set_lyr_2_4) - 1))
 +		if (!masked_memcmp(fte_mask, fte_match1, fte_match2,
 +				   MLX5_ST_SZ_BYTES(fte_match_set_lyr_2_4)))
  			return false;
  	}
 -
 -	return check_last_reserved(match_criteria);
 +	return true;
  }
  
- static bool compare_match_criteria(u8 match_criteria_enable1,
- 				   u8 match_criteria_enable2,
- 				   void *mask1, void *mask2)
+ static bool check_valid_spec(const struct mlx5_flow_spec *spec)
  {
- 	return match_criteria_enable1 == match_criteria_enable2 &&
- 		!memcmp(mask1, mask2, MLX5_ST_SZ_BYTES(fte_match_param));
+ 	int i;
+ 
+ 	if (!check_valid_mask(spec->match_criteria_enable, spec->match_criteria)) {
+ 		pr_warn("mlx5_core: Match criteria given mismatches match_criteria_enable\n");
+ 		return false;
+ 	}
+ 
+ 	for (i = 0; i < MLX5_ST_SZ_DW_MATCH_PARAM; i++)
+ 		if (spec->match_value[i] & ~spec->match_criteria[i]) {
+ 			pr_warn("mlx5_core: match_value differs from match_criteria\n");
+ 			return false;
+ 		}
+ 
+ 	return check_last_reserved(spec->match_value);
  }
  
  static struct mlx5_flow_root_namespace *find_root(struct fs_node *node)
@@@ -359,6 -383,8 +389,11 @@@ static void del_flow_table(struct fs_no
  	err = mlx5_cmd_destroy_flow_table(dev, ft);
  	if (err)
  		mlx5_core_warn(dev, "flow steering can't destroy ft\n");
++<<<<<<< HEAD
++=======
+ 	ida_destroy(&ft->fte_allocator);
+ 	rhltable_destroy(&ft->fgs_hash);
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  	fs_get_obj(prio, ft->node.parent);
  	prio->num_ft--;
  }
@@@ -455,6 -483,11 +491,14 @@@ static void del_flow_group(struct fs_no
  	if (ft->autogroup.active)
  		ft->autogroup.num_groups--;
  
++<<<<<<< HEAD
++=======
+ 	rhashtable_destroy(&fg->ftes_hash);
+ 	err = rhltable_remove(&ft->fgs_hash,
+ 			      &fg->hash,
+ 			      rhash_fg);
+ 	WARN_ON(err);
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  	if (mlx5_cmd_destroy_flow_group(dev, ft, fg->id))
  		mlx5_core_warn(dev, "flow steering can't destroy fg %d of ft %d\n",
  			       fg->id, ft->id);
@@@ -927,11 -974,13 +978,21 @@@ static struct mlx5_flow_group *create_f
  	if (IS_ERR(fg))
  		return fg;
  
++<<<<<<< HEAD
 +	err = mlx5_cmd_create_flow_group(dev, ft, fg_in, &fg->id);
 +	if (err) {
 +		kfree(fg);
 +		return ERR_PTR(err);
 +	}
++=======
+ 	err = rhltable_insert(&ft->fgs_hash, &fg->hash, rhash_fg);
+ 	if (err)
+ 		goto err_free_fg;
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
+ 
+ 	err = mlx5_cmd_create_flow_group(dev, ft, fg_in, &fg->id);
+ 	if (err)
+ 		goto err_remove_fg;
  
  	if (ft->autogroup.active)
  		ft->autogroup.num_groups++;
@@@ -942,6 -991,16 +1003,19 @@@
  	list_add(&fg->node.list, prev_fg);
  
  	return fg;
++<<<<<<< HEAD
++=======
+ 
+ err_remove_fg:
+ 	WARN_ON(rhltable_remove(&ft->fgs_hash,
+ 				&fg->hash,
+ 				rhash_fg));
+ err_free_fg:
+ 	rhashtable_destroy(&fg->ftes_hash);
+ 	kfree(fg);
+ 
+ 	return ERR_PTR(err);
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  }
  
  struct mlx5_flow_group *mlx5_create_flow_group(struct mlx5_flow_table *ft,
@@@ -1237,62 -1336,48 +1312,76 @@@ static struct mlx5_flow_handle *add_rul
  {
  	struct mlx5_flow_handle *handle;
  	struct mlx5_flow_table *ft;
++<<<<<<< HEAD
 +	struct list_head *prev;
 +	struct fs_fte *fte;
 +	int i;
 +
 +	nested_lock_ref_node(&fg->node, FS_MUTEX_PARENT);
 +	fs_for_each_fte(fte, fg) {
++=======
+ 	int i;
+ 
+ 	if (fte) {
+ 		int old_action;
+ 		int ret;
+ 
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  		nested_lock_ref_node(&fte->node, FS_MUTEX_CHILD);
 -		ret = check_conflicting_ftes(fte, flow_act);
 -		if (ret) {
 -			handle = ERR_PTR(ret);
 -			goto unlock_fte;
 -		}
 +		if (compare_match_value(&fg->mask, match_value, &fte->val) &&
 +		    (flow_act->action & fte->action)) {
 +			int old_action = fte->action;
 +
 +			if (fte->flow_tag != flow_act->flow_tag) {
 +				mlx5_core_warn(get_dev(&fte->node),
 +					       "FTE flow tag %u already exists with different flow tag %u\n",
 +					       fte->flow_tag,
 +					       flow_act->flow_tag);
 +				handle = ERR_PTR(-EEXIST);
 +				goto unlock_fte;
 +			}
  
 -		old_action = fte->action;
 -		fte->action |= flow_act->action;
 -		handle = add_rule_fte(fte, fg, dest, dest_num,
 -				      old_action != flow_act->action);
 -		if (IS_ERR(handle)) {
 -			fte->action = old_action;
 -			goto unlock_fte;
 -		} else {
 -			goto add_rules;
 +			fte->action |= flow_act->action;
 +			handle = add_rule_fte(fte, fg, dest, dest_num,
 +					      old_action != flow_act->action);
 +			if (IS_ERR(handle)) {
 +				fte->action = old_action;
 +				goto unlock_fte;
 +			} else {
 +				goto add_rules;
 +			}
  		}
- 		unlock_ref_node(&fte->node);
  	}
  	fs_get_obj(ft, fg->node.parent);
 +	if (fg->num_ftes >= fg->max_ftes) {
 +		handle = ERR_PTR(-ENOSPC);
 +		goto unlock_fg;
 +	}
  
++<<<<<<< HEAD
 +	fte = create_fte(fg, match_value, flow_act, &prev);
 +	if (IS_ERR(fte)) {
 +		handle = (void *)fte;
 +		goto unlock_fg;
 +	}
++=======
+ 	fte = create_fte(fg, match_value, flow_act);
+ 	if (IS_ERR(fte))
+ 		return (void *)fte;
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  	tree_init_node(&fte->node, 0, del_fte);
  	nested_lock_ref_node(&fte->node, FS_MUTEX_CHILD);
  	handle = add_rule_fte(fte, fg, dest, dest_num, false);
  	if (IS_ERR(handle)) {
  		unlock_ref_node(&fte->node);
 -		destroy_fte(fte, fg);
  		kfree(fte);
- 		goto unlock_fg;
+ 		return handle;
  	}
  
 +	fg->num_ftes++;
 +
  	tree_add_node(&fte->node, &fg->node);
 -	/* fte list isn't sorted */
 -	list_add_tail(&fte->node.list, &fg->node.children);
 +	list_add(&fte->node.list, prev);
  add_rules:
  	for (i = 0; i < handle->num_rules; i++) {
  		if (atomic_read(&handle->rule[i]->node.refcount) == 1)
@@@ -1361,6 -1534,9 +1538,12 @@@ _mlx5_add_flow_rules(struct mlx5_flow_t
  	struct mlx5_flow_handle *rule;
  	int i;
  
++<<<<<<< HEAD
++=======
+ 	if (!check_valid_spec(spec))
+ 		return ERR_PTR(-EINVAL);
+ 
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  	for (i = 0; i < dest_num; i++) {
  		if (!dest_is_valid(&dest[i], flow_act->action, ft))
  			return ERR_PTR(-EINVAL);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index 9ce3f6c35408,5509a752f98e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@@ -118,7 -119,8 +118,12 @@@ struct mlx5_flow_table 
  	/* FWD rules that point on this flow table */
  	struct list_head		fwd_rules;
  	u32				flags;
++<<<<<<< HEAD
 +	u32				underlay_qpn;
++=======
+ 	struct ida			fte_allocator;
+ 	struct rhltable			fgs_hash;
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  };
  
  struct mlx5_fc_cache {
@@@ -184,8 -199,9 +189,13 @@@ struct mlx5_flow_group 
  	struct mlx5_flow_group_mask	mask;
  	u32				start_index;
  	u32				max_ftes;
 +	u32				num_ftes;
  	u32				id;
++<<<<<<< HEAD
++=======
+ 	struct rhashtable		ftes_hash;
+ 	struct rhlist_head		hash;
++>>>>>>> 693c6883bbc4 (net/mlx5: Add hash table for flow groups in flow table)
  };
  
  struct mlx5_flow_root_namespace {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
