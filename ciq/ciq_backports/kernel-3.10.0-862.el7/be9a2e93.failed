ALSA: x86: Stop the stream when buffer is processed after disconnection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit be9a2e933e301bec856d526516801e14247519c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/be9a2e93.failed

This shouldn't happen, but just to be sure...

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit be9a2e933e301bec856d526516801e14247519c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,8d67031e8429..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -914,41 -809,241 +914,207 @@@ static int snd_intelhad_prog_n(u32 aud_
  	return 0;
  }
  
 -/*
 - * PCM ring buffer handling
 - *
 - * The hardware provides a ring buffer with the fixed 4 buffer descriptors
 - * (BDs).  The driver maps these 4 BDs onto the PCM ring buffer.  The mapping
 - * moves at each period elapsed.  The below illustrates how it works:
 - *
 - * At time=0
 - *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *  BD  | 0 | 1 | 2 | 3 |
 - *
 - * At time=1 (period elapsed)
 - *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *  BD      | 1 | 2 | 3 | 0 |
 - *
 - * At time=2 (second period elapsed)
 - *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *  BD          | 2 | 3 | 0 | 1 |
 - *
 - * The bd_head field points to the index of the BD to be read.  It's also the
 - * position to be filled at next.  The pcm_head and the pcm_filled fields
 - * point to the indices of the current position and of the next position to
 - * be filled, respectively.  For PCM buffer there are both _head and _filled
 - * because they may be difference when nperiods > 4.  For example, in the
 - * example above at t=1, bd_head=1 and pcm_head=1 while pcm_filled=5:
 - *
 - * pcm_head (=1) --v               v-- pcm_filled (=5)
 - *       PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *       BD      | 1 | 2 | 3 | 0 |
 - *  bd_head (=1) --^               ^-- next to fill (= bd_head)
 - *
 - * For nperiods < 4, the remaining BDs out of 4 are marked as invalid, so that
 - * the hardware skips those BDs in the loop.
 - *
 - * An exceptional setup is the case with nperiods=1.  Since we have to update
 - * BDs after finishing one BD processing, we'd need at least two BDs, where
 - * both BDs point to the same content, the same address, the same size of the
 - * whole PCM buffer.
 - */
 -
 -#define AUD_BUF_ADDR(x)		(AUD_BUF_A_ADDR + (x) * HAD_REG_WIDTH)
 -#define AUD_BUF_LEN(x)		(AUD_BUF_A_LENGTH + (x) * HAD_REG_WIDTH)
 -
 -/* Set up a buffer descriptor at the "filled" position */
 -static void had_prog_bd(struct snd_pcm_substream *substream,
 -			struct snd_intelhad *intelhaddata)
 +void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata)
  {
++<<<<<<< HEAD
 +	u32 hdmi_status, i = 0;
++=======
+ 	int idx = intelhaddata->bd_head;
+ 	int ofs = intelhaddata->pcmbuf_filled * intelhaddata->period_bytes;
+ 	u32 addr = substream->runtime->dma_addr + ofs;
+ 
+ 	addr |= AUD_BUF_VALID;
+ 	if (!substream->runtime->no_period_wakeup)
+ 		addr |= AUD_BUF_INTR_EN;
+ 	had_write_register(intelhaddata, AUD_BUF_ADDR(idx), addr);
+ 	had_write_register(intelhaddata, AUD_BUF_LEN(idx),
+ 			   intelhaddata->period_bytes);
+ 
+ 	/* advance the indices to the next */
+ 	intelhaddata->bd_head++;
+ 	intelhaddata->bd_head %= intelhaddata->num_bds;
+ 	intelhaddata->pcmbuf_filled++;
+ 	intelhaddata->pcmbuf_filled %= substream->runtime->periods;
+ }
+ 
+ /* invalidate a buffer descriptor with the given index */
+ static void had_invalidate_bd(struct snd_intelhad *intelhaddata,
+ 			      int idx)
+ {
+ 	had_write_register(intelhaddata, AUD_BUF_ADDR(idx), 0);
+ 	had_write_register(intelhaddata, AUD_BUF_LEN(idx), 0);
+ }
+ 
+ /* Initial programming of ring buffer */
+ static void had_init_ringbuf(struct snd_pcm_substream *substream,
+ 			     struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_runtime *runtime = substream->runtime;
+ 	int i, num_periods;
+ 
+ 	num_periods = runtime->periods;
+ 	intelhaddata->num_bds = min(num_periods, HAD_NUM_OF_RING_BUFS);
+ 	/* set the minimum 2 BDs for num_periods=1 */
+ 	intelhaddata->num_bds = max(intelhaddata->num_bds, 2U);
+ 	intelhaddata->period_bytes =
+ 		frames_to_bytes(runtime, runtime->period_size);
+ 	WARN_ON(intelhaddata->period_bytes & 0x3f);
+ 
+ 	intelhaddata->bd_head = 0;
+ 	intelhaddata->pcmbuf_head = 0;
+ 	intelhaddata->pcmbuf_filled = 0;
+ 
+ 	for (i = 0; i < HAD_NUM_OF_RING_BUFS; i++) {
+ 		if (i < intelhaddata->num_bds)
+ 			had_prog_bd(substream, intelhaddata);
+ 		else /* invalidate the rest */
+ 			had_invalidate_bd(intelhaddata, i);
+ 	}
+ 
+ 	intelhaddata->bd_head = 0; /* reset at head again before starting */
+ }
+ 
+ /* process a bd, advance to the next */
+ static void had_advance_ringbuf(struct snd_pcm_substream *substream,
+ 				struct snd_intelhad *intelhaddata)
+ {
+ 	int num_periods = substream->runtime->periods;
+ 
+ 	/* reprogram the next buffer */
+ 	had_prog_bd(substream, intelhaddata);
+ 
+ 	/* proceed to next */
+ 	intelhaddata->pcmbuf_head++;
+ 	intelhaddata->pcmbuf_head %= num_periods;
+ }
+ 
+ /* process the current BD(s);
+  * returns the current PCM buffer byte position, or -EPIPE for underrun.
+  */
+ static int had_process_ringbuf(struct snd_pcm_substream *substream,
+ 			       struct snd_intelhad *intelhaddata)
+ {
+ 	int len, processed;
+ 	unsigned long flags;
+ 
+ 	processed = 0;
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	for (;;) {
+ 		/* get the remaining bytes on the buffer */
+ 		had_read_register(intelhaddata,
+ 				  AUD_BUF_LEN(intelhaddata->bd_head),
+ 				  &len);
+ 		if (len < 0 || len > intelhaddata->period_bytes) {
+ 			dev_dbg(intelhaddata->dev, "Invalid buf length %d\n",
+ 				len);
+ 			len = -EPIPE;
+ 			goto out;
+ 		}
+ 
+ 		if (len > 0) /* OK, this is the current buffer */
+ 			break;
+ 
+ 		/* len=0 => already empty, check the next buffer */
+ 		if (++processed >= intelhaddata->num_bds) {
+ 			len = -EPIPE; /* all empty? - report underrun */
+ 			goto out;
+ 		}
+ 		had_advance_ringbuf(substream, intelhaddata);
+ 	}
+ 
+ 	len = intelhaddata->period_bytes - len;
+ 	len += intelhaddata->period_bytes * intelhaddata->pcmbuf_head;
+  out:
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 	return len;
+ }
+ 
+ /* called from irq handler */
+ static void had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 	if (!substream)
+ 		return; /* no stream? - bail out */
+ 
+ 	if (!intelhaddata->connected) {
+ 		snd_pcm_stop_xrun(substream);
+ 		goto out; /* disconnected? - bail out */
+ 	}
+ 
+ 	/* process or stop the stream */
+ 	if (had_process_ringbuf(substream, intelhaddata) < 0)
+ 		snd_pcm_stop_xrun(substream);
+ 	else
+ 		snd_pcm_period_elapsed(substream);
+ 
+  out:
+ 	had_substream_put(intelhaddata);
+ }
+ 
+ /*
+  * The interrupt status 'sticky' bits might not be cleared by
+  * setting '1' to that bit once...
+  */
+ static void wait_clear_underrun_bit(struct snd_intelhad *intelhaddata)
+ {
+ 	int i;
+ 	u32 val;
+ 
+ 	for (i = 0; i < 100; i++) {
+ 		/* clear bit30, 31 AUD_HDMI_STATUS */
+ 		had_read_register(intelhaddata, AUD_HDMI_STATUS, &val);
+ 		if (!(val & AUD_HDMI_STATUS_MASK_UNDERRUN))
+ 			return;
+ 		udelay(100);
+ 		cond_resched();
+ 		had_write_register(intelhaddata, AUD_HDMI_STATUS, val);
+ 	}
+ 	dev_err(intelhaddata->dev, "Unable to clear UNDERRUN bits\n");
+ }
+ 
+ /* Perform some reset procedure but only when need_reset is set;
+  * this is called from prepare or hw_free callbacks once after trigger STOP
+  * or underrun has been processed in order to settle down the h/w state.
+  */
+ static void had_do_reset(struct snd_intelhad *intelhaddata)
+ {
+ 	if (!intelhaddata->need_reset || !intelhaddata->connected)
+ 		return;
++>>>>>>> be9a2e933e30 (ALSA: x86: Stop the stream when buffer is processed after disconnection)
  
 +	/* Handle Underrun interrupt within Audio Unit */
 +	had_write_register(intelhaddata, AUD_CONFIG, 0);
  	/* Reset buffer pointers */
 -	had_reset_audio(intelhaddata);
 -	wait_clear_underrun_bit(intelhaddata);
 -	intelhaddata->need_reset = false;
 -}
 -
 -/* called from irq handler */
 -static void had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
 -{
 -	struct snd_pcm_substream *substream;
 -
 -	/* Report UNDERRUN error to above layers */
 -	substream = had_substream_get(intelhaddata);
 -	if (substream) {
 -		snd_pcm_stop_xrun(substream);
 -		had_substream_put(intelhaddata);
 -	}
 -	intelhaddata->need_reset = true;
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, 1);
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, 0);
 +	/**
 +	 * The interrupt status 'sticky' bits might not be cleared by
 +	 * setting '1' to that bit once...
 +	 */
 +	do { /* clear bit30, 31 AUD_HDMI_STATUS */
 +		had_read_register(intelhaddata, AUD_HDMI_STATUS_v2,
 +				  &hdmi_status);
 +		pr_debug("HDMI status =0x%x\n", hdmi_status);
 +		if (hdmi_status & AUD_CONFIG_MASK_UNDERRUN) {
 +			i++;
 +			had_write_register(intelhaddata,
 +					   AUD_HDMI_STATUS_v2, hdmi_status);
 +		} else
 +			break;
 +	} while (i < MAX_CNT);
 +	if (i >= MAX_CNT)
 +		pr_err("Unable to clear UNDERRUN bits\n");
  }
  
 -/*
 - * ALSA PCM open callback
 +/**
 + * snd_intelhad_open - stream initializations are done here
 + * @substream:substream for which the stream function is called
 + *
 + * This function is called whenever a PCM stream is opened
   */
 -static int had_pcm_open(struct snd_pcm_substream *substream)
 +static int snd_intelhad_open(struct snd_pcm_substream *substream)
  {
  	struct snd_intelhad *intelhaddata;
  	struct snd_pcm_runtime *runtime;
* Unmerged path sound/x86/intel_hdmi_audio.c
