scsi: qla2xxx: Cleanup FC-NVMe code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Cleanup FC-NVMe code (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 90.62%
commit-author himanshu.madhani@cavium.com <himanshu.madhani@cavium.com>
commit 6fcd98fd2c731f87ab5ccd604d61d0ef20a8c5b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6fcd98fd.failed

This patch does not change any functionality.

Following cleanups have been done as requested by reviewer

- Changed waitQ --> waitq
- Collapsed multiple debug statements into single
- Remove extra parentheses in if-else as per operator precedence
- Remove unnecessary casting

	Cc: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6fcd98fd2c731f87ab5ccd604d61d0ef20a8c5b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_nvme.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,1635e98867aa..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -382,11 -447,32 +382,15 @@@ struct srb_iocb 
  #define SRB_FXIOCB_DCMD	10
  #define SRB_FXIOCB_BCMD	11
  #define SRB_ABT_CMD	12
 -#define SRB_ELS_DCMD	13
 -#define SRB_MB_IOCB	14
 -#define SRB_CT_PTHRU_CMD 15
 -#define SRB_NACK_PLOGI	16
 -#define SRB_NACK_PRLI	17
 -#define SRB_NACK_LOGO	18
 -#define SRB_NVME_CMD	19
 -#define SRB_NVME_LS	20
 -#define SRB_PRLI_CMD	21
 -
 -enum {
 -	TYPE_SRB,
 -	TYPE_TGT_CMD,
 -};
 +
  
  typedef struct srb {
 -	/*
 -	 * Do not move cmd_type field, it needs to
 -	 * line up with qla_tgt_cmd->cmd_type
 -	 */
 -	uint8_t cmd_type;
 -	uint8_t pad[3];
  	atomic_t ref_count;
++<<<<<<< HEAD
++=======
+ 	wait_queue_head_t nvme_ls_waitq;
++>>>>>>> 6fcd98fd2c73 (scsi: qla2xxx: Cleanup FC-NVMe code)
  	struct fc_port *fcport;
 -	struct scsi_qla_host *vha;
  	uint32_t handle;
  	uint16_t flags;
  	uint16_t type;
@@@ -2027,6 -2290,40 +2031,43 @@@ typedef struct fc_port 
  	uint16_t loop_id;
  	uint16_t old_loop_id;
  
++<<<<<<< HEAD
++=======
+ 	unsigned int conf_compl_supported:1;
+ 	unsigned int deleted:2;
+ 	unsigned int local:1;
+ 	unsigned int logout_on_delete:1;
+ 	unsigned int logo_ack_needed:1;
+ 	unsigned int keep_nport_handle:1;
+ 	unsigned int send_els_logo:1;
+ 	unsigned int login_pause:1;
+ 	unsigned int login_succ:1;
+ 
+ 	struct work_struct nvme_del_work;
+ 	atomic_t nvme_ref_count;
+ 	wait_queue_head_t nvme_waitq;
+ 	uint32_t nvme_prli_service_param;
+ #define NVME_PRLI_SP_CONF       BIT_7
+ #define NVME_PRLI_SP_INITIATOR  BIT_5
+ #define NVME_PRLI_SP_TARGET     BIT_4
+ #define NVME_PRLI_SP_DISCOVERY  BIT_3
+ 	uint8_t nvme_flag;
+ #define NVME_FLAG_REGISTERED 4
+ 
+ 	struct fc_port *conflict;
+ 	unsigned char logout_completed;
+ 	int generation;
+ 
+ 	struct se_session *se_sess;
+ 	struct kref sess_kref;
+ 	struct qla_tgt *tgt;
+ 	unsigned long expires;
+ 	struct list_head del_list_entry;
+ 	struct work_struct free_work;
+ 
+ 	struct qlt_plogi_ack_t *plogi_link[QLT_PLOGI_LINK_MAX];
+ 
++>>>>>>> 6fcd98fd2c73 (scsi: qla2xxx: Cleanup FC-NVMe code)
  	uint16_t tgt_id;
  	uint16_t old_tgt_id;
  
@@@ -3654,6 -4128,13 +3695,16 @@@ typedef struct scsi_qla_host 
  	uint8_t		port_name[WWN_SIZE];
  	uint8_t		fabric_node_name[WWN_SIZE];
  
++<<<<<<< HEAD
++=======
+ 	struct		nvme_fc_local_port *nvme_local_port;
+ 	atomic_t	nvme_ref_count;
+ 	wait_queue_head_t nvme_waitq;
+ 	struct list_head nvme_rport_list;
+ 	atomic_t 	nvme_active_aen_cnt;
+ 	uint16_t	nvme_last_rptd_aen;
+ 
++>>>>>>> 6fcd98fd2c73 (scsi: qla2xxx: Cleanup FC-NVMe code)
  	uint16_t	fcoe_vlan_id;
  	uint16_t	fcoe_fcf_idx;
  	uint8_t		fcoe_vn_port_mac[6];
diff --cc drivers/scsi/qla2xxx/qla_os.c
index c724f888aca6,635ce75c630b..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -584,7 -664,83 +584,87 @@@ qla24xx_fw_version_str(struct scsi_qla_
  }
  
  void
++<<<<<<< HEAD
 +qla2x00_sp_free_dma(void *vha, void *ptr)
++=======
+ qla2x00_sp_free_dma(void *ptr)
+ {
+ 	srb_t *sp = ptr;
+ 	struct qla_hw_data *ha = sp->vha->hw;
+ 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
+ 	void *ctx = GET_CMD_CTX_SP(sp);
+ 
+ 	if (sp->flags & SRB_DMA_VALID) {
+ 		scsi_dma_unmap(cmd);
+ 		sp->flags &= ~SRB_DMA_VALID;
+ 	}
+ 
+ 	if (sp->flags & SRB_CRC_PROT_DMA_VALID) {
+ 		dma_unmap_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),
+ 		    scsi_prot_sg_count(cmd), cmd->sc_data_direction);
+ 		sp->flags &= ~SRB_CRC_PROT_DMA_VALID;
+ 	}
+ 
+ 	if (!ctx)
+ 		goto end;
+ 
+ 	if (sp->flags & SRB_CRC_CTX_DSD_VALID) {
+ 		/* List assured to be having elements */
+ 		qla2x00_clean_dsd_pool(ha, ctx);
+ 		sp->flags &= ~SRB_CRC_CTX_DSD_VALID;
+ 	}
+ 
+ 	if (sp->flags & SRB_CRC_CTX_DMA_VALID) {
+ 		struct crc_context *ctx0 = ctx;
+ 
+ 		dma_pool_free(ha->dl_dma_pool, ctx0, ctx0->crc_ctx_dma);
+ 		sp->flags &= ~SRB_CRC_CTX_DMA_VALID;
+ 	}
+ 
+ 	if (sp->flags & SRB_FCP_CMND_DMA_VALID) {
+ 		struct ct6_dsd *ctx1 = ctx;
+ 
+ 		dma_pool_free(ha->fcp_cmnd_dma_pool, ctx1->fcp_cmnd,
+ 		    ctx1->fcp_cmnd_dma);
+ 		list_splice(&ctx1->dsd_list, &ha->gbl_dsd_list);
+ 		ha->gbl_dsd_inuse -= ctx1->dsd_use_cnt;
+ 		ha->gbl_dsd_avail += ctx1->dsd_use_cnt;
+ 		mempool_free(ctx1, ha->ctx_mempool);
+ 	}
+ 
+ end:
+ 	if (sp->type != SRB_NVME_CMD && sp->type != SRB_NVME_LS) {
+ 		CMD_SP(cmd) = NULL;
+ 		qla2x00_rel_sp(sp);
+ 	}
+ }
+ 
+ void
+ qla2x00_sp_compl(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
+ 
+ 	cmd->result = res;
+ 
+ 	if (atomic_read(&sp->ref_count) == 0) {
+ 		ql_dbg(ql_dbg_io, sp->vha, 0x3015,
+ 		    "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
+ 		    sp, GET_CMD_SP(sp));
+ 		if (ql2xextended_error_logging & ql_dbg_io)
+ 			WARN_ON(atomic_read(&sp->ref_count) == 0);
+ 		return;
+ 	}
+ 	if (!atomic_dec_and_test(&sp->ref_count))
+ 		return;
+ 
+ 	qla2x00_sp_free_dma(sp);
+ 	cmd->scsi_done(cmd);
+ }
+ 
+ void
+ qla2xxx_qpair_sp_free_dma(void *ptr)
++>>>>>>> 6fcd98fd2c73 (scsi: qla2xxx: Cleanup FC-NVMe code)
  {
  	srb_t *sp = (srb_t *)ptr;
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
@@@ -1590,27 -1713,65 +1670,88 @@@ qla2x00_abort_all_cmds(scsi_qla_host_t 
  		for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {
  			sp = req->outstanding_cmds[cnt];
  			if (sp) {
++<<<<<<< HEAD
 +				/* Don't abort commands in adapter during EEH
 +				 * recovery as it's not accessible/responding.
 +				 */
 +				if (GET_CMD_SP(sp) && !ha->flags.eeh_busy &&
 +				    (sp->type == SRB_SCSI_CMD)) {
 +					/* Get a reference to the sp and drop the lock.
 +					 * The reference ensures this sp->done() call
 +					 * - and not the call in qla2xxx_eh_abort() -
 +					 * ends the SCSI command (with result 'res').
 +					 */
 +					sp_get(sp);
 +					spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +					status = qla2xxx_eh_abort(GET_CMD_SP(sp));
 +					spin_lock_irqsave(&ha->hardware_lock, flags);
 +					/* Get rid of extra reference if immediate exit
 +					 * from ql2xxx_eh_abort */
 +					if (status == FAILED && (qla2x00_isp_reg_stat(ha)))
 +						atomic_dec(&sp->ref_count);
++=======
+ 				req->outstanding_cmds[cnt] = NULL;
+ 				if (sp->cmd_type == TYPE_SRB) {
+ 					if (sp->type == SRB_NVME_CMD ||
+ 					    sp->type == SRB_NVME_LS) {
+ 						sp_get(sp);
+ 						spin_unlock_irqrestore(
+ 						    &ha->hardware_lock, flags);
+ 						qla_nvme_abort(ha, sp);
+ 						spin_lock_irqsave(
+ 						    &ha->hardware_lock, flags);
+ 					} else if (GET_CMD_SP(sp) &&
+ 					    !ha->flags.eeh_busy &&
+ 					    (sp->type == SRB_SCSI_CMD)) {
+ 						/*
+ 						 * Don't abort commands in
+ 						 * adapter during EEH
+ 						 * recovery as it's not
+ 						 * accessible/responding.
+ 						 *
+ 						 * Get a reference to the sp
+ 						 * and drop the lock. The
+ 						 * reference ensures this
+ 						 * sp->done() call and not the
+ 						 * call in qla2xxx_eh_abort()
+ 						 * ends the SCSI command (with
+ 						 * result 'res').
+ 						 */
+ 						sp_get(sp);
+ 						spin_unlock_irqrestore(
+ 						    &ha->hardware_lock, flags);
+ 						status = qla2xxx_eh_abort(
+ 						    GET_CMD_SP(sp));
+ 						spin_lock_irqsave(
+ 						    &ha->hardware_lock, flags);
+ 						/*
+ 						 * Get rid of extra reference
+ 						 * if immediate exit from
+ 						 * ql2xxx_eh_abort
+ 						 */
+ 						if (status == FAILED &&
+ 						    (qla2x00_isp_reg_stat(ha)))
+ 							atomic_dec(
+ 							    &sp->ref_count);
+ 					}
+ 					sp->done(sp, res);
+ 				} else {
+ 					if (!vha->hw->tgt.tgt_ops || !tgt ||
+ 					    qla_ini_mode_enabled(vha)) {
+ 						if (!trace)
+ 							ql_dbg(ql_dbg_tgt_mgt,
+ 							    vha, 0xf003,
+ 							    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
+ 							    vha->dpc_flags);
+ 						continue;
+ 					}
+ 					cmd = (struct qla_tgt_cmd *)sp;
+ 					qlt_abort_cmd_on_host_reset(cmd->vha,
+ 					    cmd);
++>>>>>>> 6fcd98fd2c73 (scsi: qla2xxx: Cleanup FC-NVMe code)
  				}
 +				req->outstanding_cmds[cnt] = NULL;
 +				sp->done(vha, sp, res);
  			}
  		}
  	}
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
