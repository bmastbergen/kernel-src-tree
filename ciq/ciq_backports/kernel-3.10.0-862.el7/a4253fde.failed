scsi_dh_alua: simplify alua_initialize()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit a4253fde53fda56c2116a1cf8df9c93ef272eab4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a4253fde.failed

Rework alua_check_vpd() to use scsi_vpd_get_tpg()
and move the port group selection into the function, too.
With that we can simplify alua_initialize() to just
call alua_check_tpgs() and alua_check_vpd();

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a4253fde53fda56c2116a1cf8df9c93ef272eab4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,a6fe3ae50c25..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -84,26 -92,18 +84,27 @@@ struct alua_dh_data 
  #define ALUA_POLICY_SWITCH_CURRENT	0
  #define ALUA_POLICY_SWITCH_ALL		1
  
+ static int alua_rtpg(struct scsi_device *, struct alua_port_group *, int);
  static char print_alua_state(int);
  
 -static void release_port_group(struct kref *kref)
 +static inline struct alua_dh_data *get_alua_data(struct scsi_device *sdev)
  {
 -	struct alua_port_group *pg;
 +	return container_of(sdev->scsi_dh_data, struct alua_dh_data, dh_data);
 +}
  
 -	pg = container_of(kref, struct alua_port_group, kref);
 -	spin_lock(&port_group_lock);
 -	list_del(&pg->node);
 -	spin_unlock(&port_group_lock);
 -	kfree(pg);
 +static int realloc_buffer(struct alua_dh_data *h, unsigned len)
 +{
 +	if (h->buff && h->buff != h->inq)
 +		kfree(h->buff);
 +
 +	h->buff = kmalloc(len, GFP_NOIO);
 +	if (!h->buff) {
 +		h->buff = h->inq;
 +		h->bufflen = ALUA_INQUIRY_SIZE;
 +		return 1;
 +	}
 +	h->bufflen = len;
 +	return 0;
  }
  
  /*
@@@ -240,14 -312,21 +242,30 @@@ static int alua_check_vpd(struct scsi_d
  			    ALUA_DH_NAME);
  		return SCSI_DH_DEV_UNSUPP;
  	}
++<<<<<<< HEAD
 +	h->state = TPGS_STATE_OPTIMIZED;
 +	h->group_id = group_id;
 +
 +	sdev_printk(KERN_INFO, sdev,
 +		    "%s: port group %02x rel port %02x\n",
 +		    ALUA_DH_NAME, h->group_id, h->rel_port);
++=======
  
- 	return 0;
+ 	h->pg = alua_alloc_pg(sdev, group_id, tpgs);
+ 	if (IS_ERR(h->pg)) {
+ 		if (PTR_ERR(h->pg) == -ENOMEM)
+ 			return SCSI_DH_NOMEM;
+ 		return SCSI_DH_DEV_UNSUPP;
+ 	}
+ 	h->rel_port = rel_port;
+ 
+ 	sdev_printk(KERN_INFO, sdev,
+ 		    "%s: device %s port group %x rel port %x\n",
+ 		    ALUA_DH_NAME, h->pg->device_id_str,
+ 		    h->group_id, h->rel_port);
++>>>>>>> a4253fde53fd (scsi_dh_alua: simplify alua_initialize())
+ 
+ 	return alua_rtpg(sdev, h->pg, 0);
  }
  
  static char print_alua_state(int state)
@@@ -550,21 -640,12 +568,28 @@@ static unsigned alua_stpg(struct scsi_d
   */
  static int alua_initialize(struct scsi_device *sdev, struct alua_dh_data *h)
  {
 -	int err = SCSI_DH_DEV_UNSUPP, tpgs;
 +	int err = SCSI_DH_DEV_UNSUPP;
 +
++<<<<<<< HEAD
 +	h->tpgs = alua_check_tpgs(sdev);
 +	if (h->tpgs == TPGS_MODE_NONE)
 +		goto out;
 +
 +	err = alua_check_vpd(sdev, h);
 +	if (err != SCSI_DH_OK)
 +		goto out;
 +
 +	err = alua_rtpg(sdev, h, 0);
 +	if (err != SCSI_DH_OK)
 +		goto out;
  
 +out:
++=======
+ 	tpgs = alua_check_tpgs(sdev);
+ 	if (tpgs != TPGS_MODE_NONE)
+ 		err = alua_check_vpd(sdev, h, tpgs);
+ 
++>>>>>>> a4253fde53fd (scsi_dh_alua: simplify alua_initialize())
  	return err;
  }
  /*
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
