sysfs: @name comes before @ns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit cfec0bc835c84d3d3723d4955587f05a94879b26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cfec0bc8.failed

Some internal sysfs functions which take explicit namespace argument
are weird in that they place the optional @ns in front of @name which
is contrary to the established convention.  This is confusing and
error-prone especially as @ns and @name may be interchanged without
causing compilation warning.

Swap the positions of @name and @ns in the following internal
functions.

 sysfs_find_dirent()
 sysfs_rename()
 sysfs_hash_and_remove()
 sysfs_name_hash()
 sysfs_name_compare()
 create_dir()

This patch doesn't introduce any functional changes.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Kay Sievers <kay@vrfy.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit cfec0bc835c84d3d3723d4955587f05a94879b26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/file.c
#	fs/sysfs/inode.c
#	fs/sysfs/symlink.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/dir.c
index fd502d3fc9fc,d23e66dfba74..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -437,14 -451,7 +437,18 @@@ int __sysfs_add_one(struct sysfs_addrm_
  	struct sysfs_inode_attrs *ps_iattr;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!!sysfs_ns_type(acxt->parent_sd) != !!sd->s_ns) {
 +		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 +			sysfs_ns_type(acxt->parent_sd)? "required": "invalid",
 +			acxt->parent_sd->s_name, sd->s_name);
 +		return -EINVAL;
 +	}
 +
 +	sd->s_hash = sysfs_name_hash(sd->s_ns, sd->s_name);
++=======
+ 	sd->s_hash = sysfs_name_hash(sd->s_name, sd->s_ns);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  	sd->s_parent = sysfs_get(acxt->parent_sd);
  
  	ret = sysfs_link_sibling(sd);
@@@ -610,14 -613,7 +615,18 @@@ struct sysfs_dirent *sysfs_find_dirent(
  	struct rb_node *node = parent_sd->s_dir.children.rb_node;
  	unsigned int hash;
  
++<<<<<<< HEAD
 +	if (!!sysfs_ns_type(parent_sd) != !!ns) {
 +		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 +			sysfs_ns_type(parent_sd)? "required": "invalid",
 +			parent_sd->s_name, name);
 +		return NULL;
 +	}
 +
 +	hash = sysfs_name_hash(ns, name);
++=======
+ 	hash = sysfs_name_hash(name, ns);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  	while (node) {
  		struct sysfs_dirent *sd;
  		int result;
@@@ -661,13 -658,13 +670,18 @@@ struct sysfs_dirent *sysfs_get_dirent(s
  
  	return sd;
  }
 -EXPORT_SYMBOL_GPL(sysfs_get_dirent_ns);
 +EXPORT_SYMBOL_GPL(sysfs_get_dirent);
  
  static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
++<<<<<<< HEAD
 +	enum kobj_ns_type type, const void *ns, const char *name,
 +	struct sysfs_dirent **p_sd)
++=======
+ 		      const char *name, const void *ns,
+ 		      struct sysfs_dirent **p_sd)
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  {
 -	umode_t mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
 +	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
  	int rc;
@@@ -697,33 -693,7 +711,37 @@@
  int sysfs_create_subdir(struct kobject *kobj, const char *name,
  			struct sysfs_dirent **p_sd)
  {
++<<<<<<< HEAD
 +	return create_dir(kobj, kobj->sd,
 +			  KOBJ_NS_TYPE_NONE, NULL, name, p_sd);
++=======
+ 	return create_dir(kobj, kobj->sd, name, NULL, p_sd);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
 +}
 +
 +/**
 + *	sysfs_read_ns_type: return associated ns_type
 + *	@kobj: the kobject being queried
 + *
 + *	Each kobject can be tagged with exactly one namespace type
 + *	(i.e. network or user).  Return the ns_type associated with
 + *	this object if any
 + */
 +static enum kobj_ns_type sysfs_read_ns_type(struct kobject *kobj)
 +{
 +	const struct kobj_ns_type_operations *ops;
 +	enum kobj_ns_type type;
 +
 +	ops = kobj_child_ns_ops(kobj);
 +	if (!ops)
 +		return KOBJ_NS_TYPE_NONE;
 +
 +	type = ops->type;
 +	BUG_ON(type <= KOBJ_NS_TYPE_NONE);
 +	BUG_ON(type >= KOBJ_NS_TYPES);
 +	BUG_ON(!kobj_ns_type_registered(type));
 +
 +	return type;
  }
  
  /**
@@@ -747,11 -716,7 +765,15 @@@ int sysfs_create_dir(struct kobject * k
  	if (!parent_sd)
  		return -ENOENT;
  
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		ns = kobj->ktype->namespace(kobj);
 +	type = sysfs_read_ns_type(kobj);
 +
 +	error = create_dir(kobj, parent_sd, type, ns, kobject_name(kobj), &sd);
++=======
+ 	error = create_dir(kobj, parent_sd, kobject_name(kobj), ns, &sd);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  	if (!error)
  		kobj->sd = sd;
  	return error;
@@@ -770,10 -734,10 +792,10 @@@ static struct dentry * sysfs_lookup(str
  
  	mutex_lock(&sysfs_mutex);
  
 -	if (parent_sd->s_flags & SYSFS_FLAG_HAS_NS)
 -		ns = sysfs_info(dir->i_sb)->ns;
 +	type = sysfs_ns_type(parent_sd);
 +	ns = sysfs_info(dir->i_sb)->ns[type];
  
- 	sd = sysfs_find_dirent(parent_sd, ns, dentry->d_name.name);
+ 	sd = sysfs_find_dirent(parent_sd, dentry->d_name.name, ns);
  
  	/* no such entry */
  	if (!sd) {
@@@ -904,18 -869,16 +925,18 @@@ int sysfs_rename(struct sysfs_dirent *s
  	return error;
  }
  
 -int sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,
 -			const void *new_ns)
 +int sysfs_rename_dir(struct kobject *kobj, const char *new_name)
  {
  	struct sysfs_dirent *parent_sd = kobj->sd->s_parent;
 +	const void *new_ns = NULL;
 +
 +	if (sysfs_ns_type(parent_sd))
 +		new_ns = kobj->ktype->namespace(kobj);
  
- 	return sysfs_rename(kobj->sd, parent_sd, new_ns, new_name);
+ 	return sysfs_rename(kobj->sd, parent_sd, new_name, new_ns);
  }
  
 -int sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,
 -		      const void *new_ns)
 +int sysfs_move_dir(struct kobject *kobj, struct kobject *new_parent_kobj)
  {
  	struct sysfs_dirent *sd = kobj->sd;
  	struct sysfs_dirent *new_parent_sd;
diff --cc fs/sysfs/file.c
index 3de7949b1b72,4697019fafa3..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -641,7 -594,7 +641,11 @@@ int sysfs_chmod_file(struct kobject *ko
  	mutex_lock(&sysfs_mutex);
  
  	rc = -ENOENT;
++<<<<<<< HEAD
 +	sd = sysfs_find_dirent(kobj->sd, ns, attr->name);
++=======
+ 	sd = sysfs_find_dirent(kobj->sd, attr->name, NULL);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  	if (!sd)
  		goto out;
  
@@@ -656,24 -609,23 +660,28 @@@
  EXPORT_SYMBOL_GPL(sysfs_chmod_file);
  
  /**
 - * sysfs_remove_file_ns - remove an object attribute with a custom ns tag
 - * @kobj: object we're acting for
 - * @attr: attribute descriptor
 - * @ns: namespace tag of the file to remove
 + *	sysfs_remove_file - remove an object attribute.
 + *	@kobj:	object we're acting for.
 + *	@attr:	attribute descriptor.
   *
 - * Hash the attribute name and namespace tag and kill the victim.
 + *	Hash the attribute name and kill the victim.
   */
 -void sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,
 -			  const void *ns)
 +void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr)
  {
 -	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const void *ns;
 +
++<<<<<<< HEAD
 +	if (sysfs_attr_ns(kobj, attr, &ns))
 +		return;
  
 +	sysfs_hash_and_remove(kobj->sd, ns, attr->name);
++=======
+ 	sysfs_hash_and_remove(dir_sd, attr->name, ns);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  }
 -EXPORT_SYMBOL_GPL(sysfs_remove_file_ns);
 +EXPORT_SYMBOL_GPL(sysfs_remove_file);
  
 -void sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)
 +void sysfs_remove_files(struct kobject * kobj, const struct attribute **ptr)
  {
  	int i;
  	for (i = 0; ptr[i]; i++)
diff --cc fs/sysfs/inode.c
index 15a606d56f5d,07193d720d92..000000000000
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@@ -312,7 -314,8 +312,12 @@@ void sysfs_evict_inode(struct inode *in
  	sysfs_put(sd);
  }
  
++<<<<<<< HEAD
 +int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const void *ns, const char *name)
++=======
+ int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const char *name,
+ 			  const void *ns)
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  {
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
diff --cc fs/sysfs/symlink.c
index 9fab2e7f7357,88c8bc5e8911..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -156,10 -141,10 +156,10 @@@ void sysfs_delete_link(struct kobject *
  {
  	const void *ns = NULL;
  	spin_lock(&sysfs_assoc_lock);
 -	if (targ->sd)
 +	if (targ->sd && sysfs_ns_type(kobj->sd))
  		ns = targ->sd->s_ns;
  	spin_unlock(&sysfs_assoc_lock);
- 	sysfs_hash_and_remove(kobj->sd, ns, name);
+ 	sysfs_hash_and_remove(kobj->sd, name, ns);
  }
  
  /**
@@@ -215,10 -201,7 +215,14 @@@ int sysfs_rename_link(struct kobject *k
  	if (sd->s_symlink.target_sd->s_dir.kobj != targ)
  		goto out;
  
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		new_ns = targ->ktype->namespace(targ);
 +
 +	result = sysfs_rename(sd, parent_sd, new_ns, new);
++=======
+ 	result = sysfs_rename(sd, parent_sd, new, new_ns);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  
  out:
  	sysfs_put(sd);
diff --cc fs/sysfs/sysfs.h
index b6deca3e301d,ee44fde199d0..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -173,11 -162,8 +173,16 @@@ void sysfs_remove_one(struct sysfs_addr
  void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
  
  struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
++<<<<<<< HEAD
 +				       const void *ns,
 +				       const unsigned char *name);
 +struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
 +				      const void *ns,
 +				      const unsigned char *name);
++=======
+ 				       const unsigned char *name,
+ 				       const void *ns);
++>>>>>>> cfec0bc835c8 (sysfs: @name comes before @ns)
  struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
  
  void release_sysfs_dirent(struct sysfs_dirent *sd);
diff --git a/fs/sysfs/bin.c b/fs/sysfs/bin.c
index dd56734deb79..81e260095c86 100644
--- a/fs/sysfs/bin.c
+++ b/fs/sysfs/bin.c
@@ -497,6 +497,6 @@ EXPORT_SYMBOL_GPL(sysfs_create_bin_file);
 void sysfs_remove_bin_file(struct kobject *kobj,
 			   const struct bin_attribute *attr)
 {
-	sysfs_hash_and_remove(kobj->sd, NULL, attr->attr.name);
+	sysfs_hash_and_remove(kobj->sd, attr->attr.name, NULL);
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_bin_file);
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/file.c
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 1a6e16c0db91..f74dcb45b478 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -26,7 +26,7 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 
 	if (grp->attrs)
 		for (attr = grp->attrs; *attr; attr++)
-			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+			sysfs_hash_and_remove(dir_sd, (*attr)->name, NULL);
 	if (grp->bin_attrs)
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
 			sysfs_remove_bin_file(kobj, *bin_attr);
@@ -49,8 +49,8 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 * re-adding (if required) the file.
 			 */
 			if (update)
-				sysfs_hash_and_remove(dir_sd, NULL,
-						      (*attr)->name);
+				sysfs_hash_and_remove(dir_sd, (*attr)->name,
+						      NULL);
 			if (grp->is_visible) {
 				mode = grp->is_visible(kobj, *attr, i);
 				if (!mode)
@@ -269,7 +269,7 @@ int sysfs_merge_group(struct kobject *kobj,
 		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
 	if (error) {
 		while (--i >= 0)
-			sysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);
+			sysfs_hash_and_remove(dir_sd, (*--attr)->name, NULL);
 	}
 	sysfs_put(dir_sd);
 
@@ -291,7 +291,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
-			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+			sysfs_hash_and_remove(dir_sd, (*attr)->name, NULL);
 		sysfs_put(dir_sd);
 	}
 }
@@ -334,7 +334,7 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 
 	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
 	if (dir_sd) {
-		sysfs_hash_and_remove(dir_sd, NULL, link_name);
+		sysfs_hash_and_remove(dir_sd, link_name, NULL);
 		sysfs_put(dir_sd);
 	}
 }
* Unmerged path fs/sysfs/inode.c
* Unmerged path fs/sysfs/symlink.c
* Unmerged path fs/sysfs/sysfs.h
