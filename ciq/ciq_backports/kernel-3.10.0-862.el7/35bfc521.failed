md: allow metadata update while suspending.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [md] allow metadata update while suspending (Nigel Croxon) [1506338]
Rebuild_FUZZ: 93.83%
commit-author NeilBrown <neilb@suse.com>
commit 35bfc52187f6df8779d0f1cebdb52b7f797baf4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/35bfc521.failed

There are various deadlocks that can occur
when a thread holds reconfig_mutex and calls
->quiesce(mddev, 1).
As some write request block waiting for
metadata to be updated (e.g. to record device
failure), and as the md thread updates the metadata
while the reconfig mutex is held, holding the mutex
can stop write requests completing, and this prevents
->quiesce(mddev, 1) from completing.

->quiesce() is now usually called from mddev_suspend(),
and it is always called with reconfig_mutex held.  So
at this time it is safe for the thread to update metadata
without explicitly taking the lock.

So add 2 new flags, one which says the unlocked updates is
allowed, and one which ways it is happening.  Then allow it
while the quiesce completes, and then wait for it to finish.

Reported-and-tested-by: Xiao Ni <xni@redhat.com>
	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 35bfc52187f6df8779d0f1cebdb52b7f797baf4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.h
diff --cc drivers/md/md.h
index 0d13bf88f41f,03fc641e5da1..000000000000
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@@ -220,6 -221,30 +220,33 @@@ extern int rdev_clear_badblocks(struct 
  				int is_new);
  struct md_cluster_info;
  
++<<<<<<< HEAD
++=======
+ /* change UNSUPPORTED_MDDEV_FLAGS for each array type if new flag is added */
+ enum mddev_flags {
+ 	MD_ARRAY_FIRST_USE,	/* First use of array, needs initialization */
+ 	MD_CLOSING,		/* If set, we are closing the array, do not open
+ 				 * it then */
+ 	MD_JOURNAL_CLEAN,	/* A raid with journal is already clean */
+ 	MD_HAS_JOURNAL,		/* The raid array has journal feature set */
+ 	MD_CLUSTER_RESYNC_LOCKED, /* cluster raid only, which means node
+ 				   * already took resync lock, need to
+ 				   * release the lock */
+ 	MD_FAILFAST_SUPPORTED,	/* Using MD_FAILFAST on metadata writes is
+ 				 * supported as calls to md_error() will
+ 				 * never cause the array to become failed.
+ 				 */
+ 	MD_HAS_PPL,		/* The raid array has PPL feature set */
+ 	MD_HAS_MULTIPLE_PPLS,	/* The raid array has multiple PPLs feature set */
+ 	MD_ALLOW_SB_UPDATE,	/* md_check_recovery is allowed to update
+ 				 * the metadata without taking reconfig_mutex.
+ 				 */
+ 	MD_UPDATING_SB,		/* md_check_recovery is updating the metadata
+ 				 * without explicitly holding reconfig_mutex.
+ 				 */
+ };
+ 
++>>>>>>> 35bfc52187f6 (md: allow metadata update while suspending.)
  enum mddev_sb_flags {
  	MD_SB_CHANGE_DEVS,		/* Some device status has changed */
  	MD_SB_CHANGE_CLEAN,	/* transition to or from 'clean' */
diff --git a/drivers/md/md.c b/drivers/md/md.c
index 4c75b0e4a2a4..adcab43ee6b4 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -315,8 +315,12 @@ void mddev_suspend(struct mddev *mddev)
 		return;
 	synchronize_rcu();
 	wake_up(&mddev->sb_wait);
+	set_bit(MD_ALLOW_SB_UPDATE, &mddev->flags);
+	smp_mb__after_atomic();
 	wait_event(mddev->sb_wait, atomic_read(&mddev->active_io) == 0);
 	mddev->pers->quiesce(mddev, 1);
+	clear_bit_unlock(MD_ALLOW_SB_UPDATE, &mddev->flags);
+	wait_event(mddev->sb_wait, !test_bit(MD_UPDATING_SB, &mddev->flags));
 
 	del_timer_sync(&mddev->safemode_timer);
 }
@@ -8443,6 +8447,16 @@ void md_check_recovery(struct mddev *mddev)
 	unlock:
 		wake_up(&mddev->sb_wait);
 		mddev_unlock(mddev);
+	} else if (test_bit(MD_ALLOW_SB_UPDATE, &mddev->flags) && mddev->sb_flags) {
+		/* Write superblock - thread that called mddev_suspend()
+		 * holds reconfig_mutex for us.
+		 */
+		set_bit(MD_UPDATING_SB, &mddev->flags);
+		smp_mb__after_atomic();
+		if (test_bit(MD_ALLOW_SB_UPDATE, &mddev->flags))
+			md_update_sb(mddev, 0);
+		clear_bit_unlock(MD_UPDATING_SB, &mddev->flags);
+		wake_up(&mddev->sb_wait);
 	}
 }
 EXPORT_SYMBOL(md_check_recovery);
* Unmerged path drivers/md/md.h
