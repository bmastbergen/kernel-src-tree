perf callchain: Move callchain specific routines from util.[ch]

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 56e2e05644a9494e8ba3165182dcdf43d40cc6a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/56e2e056.failed

Where they belong, no point in leaving those in the generic "util"
files.

Link: http://lkml.kernel.org/n/tip-ljx3iiip1hlfa7a7apjem7ph@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 56e2e05644a9494e8ba3165182dcdf43d40cc6a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/util.c
#	tools/perf/util/util.h
diff --cc tools/perf/util/util.c
index dc59646111f8,131d21a659fb..000000000000
--- a/tools/perf/util/util.c
+++ b/tools/perf/util/util.c
@@@ -16,26 -17,8 +16,28 @@@
  #include <linux/log2.h>
  #include <linux/time64.h>
  #include <unistd.h>
- #include "callchain.h"
  #include "strlist.h"
  
++<<<<<<< HEAD
 +#include "sane_ctype.h"
 +
 +#define CALLCHAIN_PARAM_DEFAULT			\
 +	.mode		= CHAIN_GRAPH_ABS,	\
 +	.min_percent	= 0.5,			\
 +	.order		= ORDER_CALLEE,		\
 +	.key		= CCKEY_FUNCTION,	\
 +	.value		= CCVAL_PERCENT,	\
 +
 +struct callchain_param callchain_param = {
 +	CALLCHAIN_PARAM_DEFAULT
 +};
 +
 +struct callchain_param callchain_param_default = {
 +	CALLCHAIN_PARAM_DEFAULT
 +};
 +
++=======
++>>>>>>> 56e2e05644a9 (perf callchain: Move callchain specific routines from util.[ch])
  /*
   * XXX We need to find a better place for these things...
   */
diff --cc tools/perf/util/util.h
index e0eb4eee09b0,fcad17ce5c19..000000000000
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@@ -17,31 -17,14 +17,33 @@@
  #include <stdlib.h>
  #include <stdarg.h>
  #include <string.h>
++<<<<<<< HEAD
 +#include <term.h>
 +#include <errno.h>
 +#include <limits.h>
++=======
++>>>>>>> 56e2e05644a9 (perf callchain: Move callchain specific routines from util.[ch])
  #include <sys/param.h>
  #include <sys/types.h>
 +#include <dirent.h>
 +#include <sys/time.h>
 +#include <time.h>
 +#include <signal.h>
 +#include <fnmatch.h>
  #include <assert.h>
 +#include <regex.h>
 +#include <utime.h>
  #include <sys/wait.h>
  #include <poll.h>
  #include <sys/socket.h>
  #include <sys/ioctl.h>
- #include <linux/kernel.h>
  #include <linux/types.h>
 +#include <sys/ttydefaults.h>
 +#include <api/fs/tracing_path.h>
 +#include <termios.h>
 +#include <linux/bitops.h>
 +#include <termios.h>
 +#include "strlist.h"
  
  extern char buildid_dir[];
  
@@@ -152,61 -97,18 +154,76 @@@ void mem_bswap_32(void *src, int byte_s
  
  bool find_process(const char *name);
  
++<<<<<<< HEAD
 +#ifdef HAVE_ZLIB_SUPPORT
 +int gzip_decompress_to_file(const char *input, int output_fd);
++=======
+ int fetch_kernel_version(unsigned int *puint,
+ 			 char *str, size_t str_sz);
+ #define KVER_VERSION(x)		(((x) >> 16) & 0xff)
+ #define KVER_PATCHLEVEL(x)	(((x) >> 8) & 0xff)
+ #define KVER_SUBLEVEL(x)	((x) & 0xff)
+ #define KVER_FMT	"%d.%d.%d"
+ #define KVER_PARAM(x)	KVER_VERSION(x), KVER_PATCHLEVEL(x), KVER_SUBLEVEL(x)
+ 
+ const char *perf_tip(const char *dirpath);
+ 
+ #ifndef HAVE_SCHED_GETCPU_SUPPORT
+ int sched_getcpu(void);
++>>>>>>> 56e2e05644a9 (perf callchain: Move callchain specific routines from util.[ch])
 +#endif
 +
 +#ifdef HAVE_LZMA_SUPPORT
 +int lzma_decompress_to_file(const char *input, int output_fd);
  #endif
  
 +char *asprintf_expr_inout_ints(const char *var, bool in, size_t nints, int *ints);
 +
 +static inline char *asprintf_expr_in_ints(const char *var, size_t nints, int *ints)
 +{
 +	return asprintf_expr_inout_ints(var, true, nints, ints);
 +}
 +
 +static inline char *asprintf_expr_not_in_ints(const char *var, size_t nints, int *ints)
 +{
 +	return asprintf_expr_inout_ints(var, false, nints, ints);
 +}
 +
 +int get_stack_size(const char *str, unsigned long *_size);
 +
 +const char *perf_tip(const char *dirpath);
 +bool is_regular_file(const char *file);
 +int fetch_current_timestamp(char *buf, size_t sz);
 +
 +enum binary_printer_ops {
 +	BINARY_PRINT_DATA_BEGIN,
 +	BINARY_PRINT_LINE_BEGIN,
 +	BINARY_PRINT_ADDR,
 +	BINARY_PRINT_NUM_DATA,
 +	BINARY_PRINT_NUM_PAD,
 +	BINARY_PRINT_SEP,
 +	BINARY_PRINT_CHAR_DATA,
 +	BINARY_PRINT_CHAR_PAD,
 +	BINARY_PRINT_LINE_END,
 +	BINARY_PRINT_DATA_END,
 +};
 +
 +typedef void (*print_binary_t)(enum binary_printer_ops,
 +			       unsigned int val,
 +			       void *extra);
 +
 +void print_binary(unsigned char *data, size_t len,
 +		  size_t bytes_per_line, print_binary_t printer,
 +		  void *extra);
 +
 +#if !defined(__GLIBC__) && !defined(__ANDROID__)
 +extern int sched_getcpu(void);
 +#endif
 +
 +int is_printable_array(char *p, unsigned int len);
 +
 +int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);
 +
 +int unit_number__scnprintf(char *buf, size_t size, u64 n);
 +
  #endif /* GIT_COMPAT_UTIL_H */
diff --git a/tools/perf/util/callchain.c b/tools/perf/util/callchain.c
index 2e5eff5abef0..62383f135272 100644
--- a/tools/perf/util/callchain.c
+++ b/tools/perf/util/callchain.c
@@ -23,6 +23,21 @@
 #include "machine.h"
 #include "callchain.h"
 
+#define CALLCHAIN_PARAM_DEFAULT			\
+	.mode		= CHAIN_GRAPH_ABS,	\
+	.min_percent	= 0.5,			\
+	.order		= ORDER_CALLEE,		\
+	.key		= CCKEY_FUNCTION,	\
+	.value		= CCVAL_PERCENT,	\
+
+struct callchain_param callchain_param = {
+	CALLCHAIN_PARAM_DEFAULT
+};
+
+struct callchain_param callchain_param_default = {
+	CALLCHAIN_PARAM_DEFAULT
+};
+
 __thread struct callchain_cursor callchain_cursor;
 
 int parse_callchain_record_opt(const char *arg, struct callchain_param *param)
@@ -112,6 +127,32 @@ static int parse_callchain_value(const char *value)
 	return -1;
 }
 
+static int get_stack_size(const char *str, unsigned long *_size)
+{
+	char *endptr;
+	unsigned long size;
+	unsigned long max_size = round_down(USHRT_MAX, sizeof(u64));
+
+	size = strtoul(str, &endptr, 0);
+
+	do {
+		if (*endptr)
+			break;
+
+		size = round_up(size, sizeof(u64));
+		if (!size || size > max_size)
+			break;
+
+		*_size = size;
+		return 0;
+
+	} while (0);
+
+	pr_err("callchain: Incorrect stack dump size (max %ld): %s\n",
+	       max_size, str);
+	return -1;
+}
+
 static int
 __parse_callchain_report_opt(const char *arg, bool allow_record_opt)
 {
@@ -195,6 +236,68 @@ int parse_callchain_top_opt(const char *arg)
 	return __parse_callchain_report_opt(arg, true);
 }
 
+int parse_callchain_record(const char *arg, struct callchain_param *param)
+{
+	char *tok, *name, *saveptr = NULL;
+	char *buf;
+	int ret = -1;
+
+	/* We need buffer that we know we can write to. */
+	buf = malloc(strlen(arg) + 1);
+	if (!buf)
+		return -ENOMEM;
+
+	strcpy(buf, arg);
+
+	tok = strtok_r((char *)buf, ",", &saveptr);
+	name = tok ? : (char *)buf;
+
+	do {
+		/* Framepointer style */
+		if (!strncmp(name, "fp", sizeof("fp"))) {
+			if (!strtok_r(NULL, ",", &saveptr)) {
+				param->record_mode = CALLCHAIN_FP;
+				ret = 0;
+			} else
+				pr_err("callchain: No more arguments "
+				       "needed for --call-graph fp\n");
+			break;
+
+		/* Dwarf style */
+		} else if (!strncmp(name, "dwarf", sizeof("dwarf"))) {
+			const unsigned long default_stack_dump_size = 8192;
+
+			ret = 0;
+			param->record_mode = CALLCHAIN_DWARF;
+			param->dump_size = default_stack_dump_size;
+
+			tok = strtok_r(NULL, ",", &saveptr);
+			if (tok) {
+				unsigned long size = 0;
+
+				ret = get_stack_size(tok, &size);
+				param->dump_size = size;
+			}
+		} else if (!strncmp(name, "lbr", sizeof("lbr"))) {
+			if (!strtok_r(NULL, ",", &saveptr)) {
+				param->record_mode = CALLCHAIN_LBR;
+				ret = 0;
+			} else
+				pr_err("callchain: No more arguments "
+					"needed for --call-graph lbr\n");
+			break;
+		} else {
+			pr_err("callchain: Unknown --call-graph option "
+			       "value: %s\n", arg);
+			break;
+		}
+
+	} while (0);
+
+	free(buf);
+	return ret;
+}
+
 int perf_callchain_config(const char *var, const char *value)
 {
 	char *endptr;
diff --git a/tools/perf/util/python.c b/tools/perf/util/python.c
index a5fbc012e3df..eb0f310d8db0 100644
--- a/tools/perf/util/python.c
+++ b/tools/perf/util/python.c
@@ -4,11 +4,24 @@
 #include <poll.h>
 #include <linux/err.h>
 #include "evlist.h"
+#include "callchain.h"
 #include "evsel.h"
 #include "event.h"
 #include "cpumap.h"
 #include "thread_map.h"
 
+/*
+ * Provide these two so that we don't have to link against callchain.c and
+ * start dragging hist.c, etc.
+ */
+struct callchain_param callchain_param;
+
+int parse_callchain_record(const char *arg __maybe_unused,
+			   struct callchain_param *param __maybe_unused)
+{
+	return 0;
+}
+
 /*
  * Support debug printing even though util/debug.c is not linked.  That means
  * implementing 'verbose' and 'eprintf'.
* Unmerged path tools/perf/util/util.c
* Unmerged path tools/perf/util/util.h
