KVM: nVMX: fix EPT permissions as reported in exit qualification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 0780516a18f87e881e42ed815f189279b0a1743c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0780516a.failed

This fixes the new ept_access_test_read_only and ept_access_test_read_write
testcases from vmx.flat.

The problem is that gpte_access moves bits around to switch from EPT
bit order (XWR) to ACC_*_MASK bit order (RWX).  This results in an
incorrect exit qualification.  To fix this, make pt_access and
pte_access operate on raw PTE values (only with NX flipped to mean
"can execute") and call gpte_access at the end of the walk.  This
lets us use pte_access to compute the exit qualification with XWR
bit order.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Reviewed-by: Xiao Guangrong <xiaoguangrong@tencent.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 0780516a18f87e881e42ed815f189279b0a1743c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/paging_tmpl.h
diff --cc arch/x86/kvm/paging_tmpl.h
index 330d9e960636,b0454c7e4cff..000000000000
--- a/arch/x86/kvm/paging_tmpl.h
+++ b/arch/x86/kvm/paging_tmpl.h
@@@ -293,7 -283,9 +293,13 @@@ static int FNAME(walk_addr_generic)(str
  	pt_element_t pte;
  	pt_element_t __user *uninitialized_var(ptep_user);
  	gfn_t table_gfn;
++<<<<<<< HEAD
 +	unsigned index, pt_access, pte_access, accessed_dirty, pte_pkey;
++=======
+ 	u64 pt_access, pte_access;
+ 	unsigned index, accessed_dirty, pte_pkey;
+ 	unsigned nested_access;
++>>>>>>> 0780516a18f8 (KVM: nVMX: fix EPT permissions as reported in exit qualification)
  	gpa_t pte_gpa;
  	bool have_ad;
  	int offset;
@@@ -322,8 -316,14 +330,19 @@@ retry_walk
  	walker->max_level = walker->level;
  	ASSERT(!(is_long_mode(vcpu) && !is_pae(vcpu)));
  
++<<<<<<< HEAD
 +	accessed_dirty = have_ad ? PT_GUEST_ACCESSED_MASK : 0;
 +	pt_access = pte_access = ACC_ALL;
++=======
+ 	/*
+ 	 * FIXME: on Intel processors, loads of the PDPTE registers for PAE paging
+ 	 * by the MOV to CR instruction are treated as reads and do not cause the
+ 	 * processor to set the dirty flag in any EPT paging-structure entry.
+ 	 */
+ 	nested_access = (have_ad ? PFERR_WRITE_MASK : 0) | PFERR_USER_MASK;
+ 
+ 	pte_access = ~0;
++>>>>>>> 0780516a18f8 (KVM: nVMX: fix EPT permissions as reported in exit qualification)
  	++walker->level;
  
  	do {
* Unmerged path arch/x86/kvm/paging_tmpl.h
