nfp: add support for offload of XDP programs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 6d6770755f053e0ab2f7c3ffcfeaaf8dbbe89092
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6d677075.failed

Most infrastructure can be reused, provide separate handling
of context offsets and exit codes.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6d6770755f053e0ab2f7c3ffcfeaaf8dbbe89092)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_bpf.h
#	drivers/net/ethernet/netronome/nfp/nfp_bpf_jit.c
#	drivers/net/ethernet/netronome/nfp/nfp_bpf_verifier.c
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_offload.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 1826ee93d1da,2115f446031e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -421,8 -431,11 +421,13 @@@ static inline bool nfp_net_fw_ver_eq(st
   * struct nfp_net - NFP network device structure
   * @pdev:               Backpointer to PCI device
   * @netdev:             Backpointer to net_device structure
 - * @nfp_fallback:       Is the driver used in fallback mode?
   * @is_vf:              Is the driver attached to a VF?
   * @fw_loaded:          Is the firmware loaded?
++<<<<<<< HEAD
++=======
+  * @bpf_offload_skip_sw:  Offloaded BPF program will not be rerun by cls_bpf
+  * @bpf_offload_xdp:	Offloaded BPF program is XDP
++>>>>>>> 6d6770755f05 (nfp: add support for offload of XDP programs)
   * @ctrl:               Local copy of the control register/word.
   * @fl_bufsz:           Currently configured size of the freelist buffers
   * @rx_offset:		Offset in the RX buffers where packet data starts
@@@ -477,8 -499,11 +482,13 @@@ struct nfp_net 
  	struct pci_dev *pdev;
  	struct net_device *netdev;
  
 -	unsigned nfp_fallback:1;
  	unsigned is_vf:1;
  	unsigned fw_loaded:1;
++<<<<<<< HEAD
++=======
+ 	unsigned bpf_offload_skip_sw:1;
+ 	unsigned bpf_offload_xdp:1;
++>>>>>>> 6d6770755f05 (nfp: add support for offload of XDP programs)
  
  	u32 ctrl;
  	u32 fl_bufsz;
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index de17d3265a77,99edb9fd84bf..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1420,7 -1600,33 +1420,37 @@@ static int nfp_net_rx(struct nfp_net_rx
  		r_vec->rx_bytes += pkt_len;
  		u64_stats_update_end(&r_vec->rx_sync);
  
++<<<<<<< HEAD
 +		skb = build_skb(rxbuf->frag, nn->fl_bufsz);
++=======
+ 		if (xdp_prog && !(rxd->rxd.flags & PCIE_DESC_RX_BPF &&
+ 				  nn->bpf_offload_xdp)) {
+ 			int act;
+ 
+ 			dma_sync_single_for_cpu(&nn->pdev->dev,
+ 						rxbuf->dma_addr + pkt_off,
+ 						pkt_len, DMA_FROM_DEVICE);
+ 			act = nfp_net_run_xdp(xdp_prog, rxbuf->frag + data_off,
+ 					      pkt_len);
+ 			switch (act) {
+ 			case XDP_PASS:
+ 				break;
+ 			case XDP_TX:
+ 				nfp_net_tx_xdp_buf(nn, rx_ring, tx_ring, rxbuf,
+ 						   pkt_off, pkt_len);
+ 				continue;
+ 			default:
+ 				bpf_warn_invalid_xdp_action(act);
+ 			case XDP_ABORTED:
+ 			case XDP_DROP:
+ 				nfp_net_rx_give_one(rx_ring, rxbuf->frag,
+ 						    rxbuf->dma_addr);
+ 				continue;
+ 			}
+ 		}
+ 
+ 		skb = build_skb(rxbuf->frag, true_bufsz);
++>>>>>>> 6d6770755f05 (nfp: add support for offload of XDP programs)
  		if (unlikely(!skb)) {
  			nfp_net_rx_drop(r_vec, rx_ring, rxbuf, NULL);
  			continue;
@@@ -2398,6 -2675,35 +2428,38 @@@ static struct rtnl_link_stats64 *nfp_ne
  	return stats;
  }
  
++<<<<<<< HEAD
++=======
+ static bool nfp_net_ebpf_capable(struct nfp_net *nn)
+ {
+ 	if (nn->cap & NFP_NET_CFG_CTRL_BPF &&
+ 	    nn_readb(nn, NFP_NET_CFG_BPF_ABI) == NFP_NET_BPF_ABI)
+ 		return true;
+ 	return false;
+ }
+ 
+ static int
+ nfp_net_setup_tc(struct net_device *netdev, u32 handle, __be16 proto,
+ 		 struct tc_to_netdev *tc)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	if (TC_H_MAJ(handle) != TC_H_MAJ(TC_H_INGRESS))
+ 		return -ENOTSUPP;
+ 	if (proto != htons(ETH_P_ALL))
+ 		return -ENOTSUPP;
+ 
+ 	if (tc->type == TC_SETUP_CLSBPF && nfp_net_ebpf_capable(nn)) {
+ 		if (!nn->bpf_offload_xdp)
+ 			return nfp_net_bpf_offload(nn, tc->cls_bpf);
+ 		else
+ 			return -EBUSY;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 6d6770755f05 (nfp: add support for offload of XDP programs)
  static int nfp_net_set_features(struct net_device *netdev,
  				netdev_features_t features)
  {
@@@ -2596,8 -2907,88 +2658,92 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static int nfp_net_xdp_offload(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct tc_cls_bpf_offload cmd = {
+ 		.prog = prog,
+ 	};
+ 	int ret;
+ 
+ 	if (!nfp_net_ebpf_capable(nn))
+ 		return -EINVAL;
+ 
+ 	if (nn->ctrl & NFP_NET_CFG_CTRL_BPF) {
+ 		if (!nn->bpf_offload_xdp)
+ 			return prog ? -EBUSY : 0;
+ 		cmd.command = prog ? TC_CLSBPF_REPLACE : TC_CLSBPF_DESTROY;
+ 	} else {
+ 		if (!prog)
+ 			return 0;
+ 		cmd.command = TC_CLSBPF_ADD;
+ 	}
+ 
+ 	ret = nfp_net_bpf_offload(nn, &cmd);
+ 	/* Stop offload if replace not possible */
+ 	if (ret && cmd.command == TC_CLSBPF_REPLACE)
+ 		nfp_net_xdp_offload(nn, NULL);
+ 	nn->bpf_offload_xdp = prog && !ret;
+ 	return ret;
+ }
+ 
+ static int nfp_net_xdp_setup(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct nfp_net_ring_set rx = {
+ 		.n_rings = nn->num_rx_rings,
+ 		.mtu = nn->netdev->mtu,
+ 		.dcnt = nn->rxd_cnt,
+ 	};
+ 	struct nfp_net_ring_set tx = {
+ 		.n_rings = nn->num_tx_rings,
+ 		.dcnt = nn->txd_cnt,
+ 	};
+ 	int err;
+ 
+ 	if (!prog && !nn->xdp_prog)
+ 		return 0;
+ 	if (prog && nn->xdp_prog) {
+ 		prog = xchg(&nn->xdp_prog, prog);
+ 		bpf_prog_put(prog);
+ 		nfp_net_xdp_offload(nn, nn->xdp_prog);
+ 		return 0;
+ 	}
+ 
+ 	tx.n_rings += prog ? nn->num_rx_rings : -nn->num_rx_rings;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	err = nfp_net_ring_reconfig(nn, &prog, &rx, &tx);
+ 	if (err)
+ 		return err;
+ 
+ 	/* @prog got swapped and is now the old one */
+ 	if (prog)
+ 		bpf_prog_put(prog);
+ 
+ 	nfp_net_xdp_offload(nn, nn->xdp_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 		return nfp_net_xdp_setup(nn, xdp->prog);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->xdp_prog;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
++>>>>>>> 6d6770755f05 (nfp: add support for offload of XDP programs)
  static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
@@@ -2860,5 -3265,11 +3006,15 @@@ int nfp_net_netdev_init(struct net_devi
   */
  void nfp_net_netdev_clean(struct net_device *netdev)
  {
++<<<<<<< HEAD
 +	unregister_netdev(netdev);
++=======
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	if (nn->xdp_prog)
+ 		bpf_prog_put(nn->xdp_prog);
+ 	if (nn->bpf_offload_xdp)
+ 		nfp_net_xdp_offload(nn, NULL);
+ 	unregister_netdev(nn->netdev);
++>>>>>>> 6d6770755f05 (nfp: add support for offload of XDP programs)
  }
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_bpf.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_bpf_jit.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_bpf_verifier.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_offload.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_bpf.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_bpf_jit.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_bpf_verifier.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_offload.c
