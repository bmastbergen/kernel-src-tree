nvmet: Fixed avoided printing nvmet: twice in error logs.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fixed avoided printing nvmet: twice in error logs (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 92.45%
commit-author Parav Pandit <parav@mellanox.com>
commit 4151dd9a58c6b2758514fc88a1a3b02f9ab8b076
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4151dd9a.failed

This patch avoids printing "nvmet:" twice in error logs as its already
coming through pr_fmt macro.

	Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 4151dd9a58c6b2758514fc88a1a3b02f9ab8b076)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/discovery.c
diff --cc drivers/nvme/target/discovery.c
index 12f39eea569f,745f26f35244..000000000000
--- a/drivers/nvme/target/discovery.c
+++ b/drivers/nvme/target/discovery.c
@@@ -192,8 -192,8 +192,13 @@@ int nvmet_parse_discovery_cmd(struct nv
  				nvmet_execute_identify_disc_ctrl;
  			return 0;
  		default:
++<<<<<<< HEAD
 +			pr_err("nvmet: unsupported identify cns %d\n",
 +				le32_to_cpu(cmd->identify.cns));
++=======
+ 			pr_err("unsupported identify cns %d\n",
+ 			       cmd->identify.cns);
++>>>>>>> 4151dd9a58c6 (nvmet: Fixed avoided printing nvmet: twice in error logs.)
  			return NVME_SC_INVALID_OPCODE | NVME_SC_DNR;
  		}
  	default:
diff --git a/drivers/nvme/target/admin-cmd.c b/drivers/nvme/target/admin-cmd.c
index 0950c2264854..d1834b8b1b2b 100644
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@ -484,13 +484,13 @@ int nvmet_parse_admin_cmd(struct nvmet_req *req)
 	req->ns = NULL;
 
 	if (unlikely(!(req->sq->ctrl->cc & NVME_CC_ENABLE))) {
-		pr_err("nvmet: got admin cmd %d while CC.EN == 0\n",
-				cmd->common.opcode);
+		pr_err("got admin cmd %d while CC.EN == 0\n",
+		       cmd->common.opcode);
 		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 	}
 	if (unlikely(!(req->sq->ctrl->csts & NVME_CSTS_RDY))) {
-		pr_err("nvmet: got admin cmd %d while CSTS.RDY == 0\n",
-				cmd->common.opcode);
+		pr_err("got admin cmd %d while CSTS.RDY == 0\n",
+		       cmd->common.opcode);
 		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 	}
 
@@ -542,6 +542,6 @@ int nvmet_parse_admin_cmd(struct nvmet_req *req)
 		return 0;
 	}
 
-	pr_err("nvmet: unhandled cmd %d\n", cmd->common.opcode);
+	pr_err("unhandled cmd %d\n", cmd->common.opcode);
 	return NVME_SC_INVALID_OPCODE | NVME_SC_DNR;
 }
diff --git a/drivers/nvme/target/core.c b/drivers/nvme/target/core.c
index b29e7483affb..b5103a6161b1 100644
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@ -271,8 +271,8 @@ int nvmet_ns_enable(struct nvmet_ns *ns)
 	ns->bdev = blkdev_get_by_path(ns->device_path, FMODE_READ | FMODE_WRITE,
 			NULL);
 	if (IS_ERR(ns->bdev)) {
-		pr_err("nvmet: failed to open block device %s: (%ld)\n",
-			ns->device_path, PTR_ERR(ns->bdev));
+		pr_err("failed to open block device %s: (%ld)\n",
+		       ns->device_path, PTR_ERR(ns->bdev));
 		ret = PTR_ERR(ns->bdev);
 		ns->bdev = NULL;
 		goto out_unlock;
* Unmerged path drivers/nvme/target/discovery.c
diff --git a/drivers/nvme/target/io-cmd.c b/drivers/nvme/target/io-cmd.c
index 625d63c62bf4..82d98924ca3b 100644
--- a/drivers/nvme/target/io-cmd.c
+++ b/drivers/nvme/target/io-cmd.c
@@ -179,15 +179,15 @@ int nvmet_parse_io_cmd(struct nvmet_req *req)
 	struct nvme_command *cmd = req->cmd;
 
 	if (unlikely(!(req->sq->ctrl->cc & NVME_CC_ENABLE))) {
-		pr_err("nvmet: got io cmd %d while CC.EN == 0\n",
-				cmd->common.opcode);
+		pr_err("got io cmd %d while CC.EN == 0\n",
+		       cmd->common.opcode);
 		req->ns = NULL;
 		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 	}
 
 	if (unlikely(!(req->sq->ctrl->csts & NVME_CSTS_RDY))) {
-		pr_err("nvmet: got io cmd %d while CSTS.RDY == 0\n",
-				cmd->common.opcode);
+		pr_err("got io cmd %d while CSTS.RDY == 0\n",
+		       cmd->common.opcode);
 		req->ns = NULL;
 		return NVME_SC_CMD_SEQ_ERROR | NVME_SC_DNR;
 	}
@@ -212,7 +212,7 @@ int nvmet_parse_io_cmd(struct nvmet_req *req)
 			sizeof(struct nvme_dsm_range);
 		return 0;
 	default:
-		pr_err("nvmet: unhandled cmd %d\n", cmd->common.opcode);
+		pr_err("unhandled cmd %d\n", cmd->common.opcode);
 		return NVME_SC_INVALID_OPCODE | NVME_SC_DNR;
 	}
 }
