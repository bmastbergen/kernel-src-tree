nfp: use dp to carry xdp_prog at reconfig time

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 9dc6b116e21b9ff258334c09d78ce26caa5ade45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9dc6b116.failed

Use xdp_prog member of data path struct to carry the xdp_prog to
alloc/free free functions.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9dc6b116e21b9ff258334c09d78ce26caa5ade45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 1826ee93d1da,19dacc3f1269..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -755,9 -811,11 +755,14 @@@ void nfp_net_irqs_disable(struct pci_de
  void
  nfp_net_irqs_assign(struct nfp_net *nn, struct msix_entry *irq_entries,
  		    unsigned int n);
 -
 -struct nfp_net_dp *nfp_net_clone_dp(struct nfp_net *nn);
  int
++<<<<<<< HEAD
 +nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_ring_set *rx,
 +		      struct nfp_net_ring_set *tx);
++=======
+ nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_dp *new,
+ 		      struct nfp_net_ring_set *rx, struct nfp_net_ring_set *tx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  
  #ifdef CONFIG_NFP_DEBUG
  void nfp_net_debugfs_create(void);
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index e0a7eb1db7a9,6ab824a48d1d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1048,33 -1116,47 +1048,57 @@@ nfp_net_calc_fl_bufsz(struct nfp_net *n
  	return fl_bufsz;
  }
  
 -static void
 -nfp_net_free_frag(void *frag, bool xdp)
 -{
 -	if (!xdp)
 -		skb_free_frag(frag);
 -	else
 -		__free_page(virt_to_page(frag));
 -}
 -
  /**
   * nfp_net_rx_alloc_one() - Allocate and map page frag for RX
 - * @dp:		NFP Net data path struct
   * @rx_ring:	RX ring structure of the skb
   * @dma_addr:	Pointer to storage for DMA address (output param)
++<<<<<<< HEAD
 + * @fl_bufsz:	size of freelist buffers
++=======
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
   *
   * This function will allcate a new page frag, map it for DMA.
   *
   * Return: allocated page frag or NULL on failure.
   */
  static void *
++<<<<<<< HEAD
 +nfp_net_rx_alloc_one(struct nfp_net_rx_ring *rx_ring, dma_addr_t *dma_addr,
 +		     unsigned int fl_bufsz)
++=======
+ nfp_net_rx_alloc_one(struct nfp_net_dp *dp, struct nfp_net_rx_ring *rx_ring,
+ 		     dma_addr_t *dma_addr)
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  {
 -	int direction;
 +	struct nfp_net *nn = rx_ring->r_vec->nfp_net;
  	void *frag;
  
++<<<<<<< HEAD
 +	frag = netdev_alloc_frag(fl_bufsz);
++=======
+ 	if (!dp->xdp_prog)
+ 		frag = netdev_alloc_frag(dp->fl_bufsz);
+ 	else
+ 		frag = page_address(alloc_page(GFP_KERNEL | __GFP_COLD));
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  	if (!frag) {
 -		nn_dp_warn(dp, "Failed to alloc receive page frag\n");
 +		nn_warn_ratelimit(nn, "Failed to alloc receive page frag\n");
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	*dma_addr = nfp_net_dma_map_rx(nn, frag, fl_bufsz, DMA_FROM_DEVICE);
 +	if (dma_mapping_error(&nn->pdev->dev, *dma_addr)) {
 +		skb_free_frag(frag);
 +		nn_warn_ratelimit(nn, "Failed to map DMA RX buffer\n");
++=======
+ 	direction = dp->xdp_prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;
+ 
+ 	*dma_addr = nfp_net_dma_map_rx(dp, frag, direction);
+ 	if (dma_mapping_error(dp->dev, *dma_addr)) {
+ 		nfp_net_free_frag(frag, dp->xdp_prog);
+ 		nn_dp_warn(dp, "Failed to map DMA RX buffer\n");
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  		return NULL;
  	}
  
@@@ -1170,8 -1257,10 +1194,15 @@@ static void nfp_net_rx_ring_reset(struc
   * to restore required ring geometry.
   */
  static void
++<<<<<<< HEAD
 +nfp_net_rx_ring_bufs_free(struct nfp_net *nn, struct nfp_net_rx_ring *rx_ring)
 +{
++=======
+ nfp_net_rx_ring_bufs_free(struct nfp_net_dp *dp,
+ 			  struct nfp_net_rx_ring *rx_ring)
+ {
+ 	int direction = dp->xdp_prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  	unsigned int i;
  
  	for (i = 0; i < rx_ring->cnt - 1; i++) {
@@@ -1182,9 -1271,9 +1213,15 @@@
  		if (!rx_ring->rxbufs[i].frag)
  			continue;
  
++<<<<<<< HEAD
 +		nfp_net_dma_unmap_rx(nn, rx_ring->rxbufs[i].dma_addr,
 +				     rx_ring->bufsz, DMA_FROM_DEVICE);
 +		skb_free_frag(rx_ring->rxbufs[i].frag);
++=======
+ 		nfp_net_dma_unmap_rx(dp, rx_ring->rxbufs[i].dma_addr,
+ 				     direction);
+ 		nfp_net_free_frag(rx_ring->rxbufs[i].frag, dp->xdp_prog);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  		rx_ring->rxbufs[i].dma_addr = 0;
  		rx_ring->rxbufs[i].frag = NULL;
  	}
@@@ -1196,7 -1285,8 +1233,12 @@@
   * @rx_ring:	RX ring to remove buffers from
   */
  static int
++<<<<<<< HEAD
 +nfp_net_rx_ring_bufs_alloc(struct nfp_net *nn, struct nfp_net_rx_ring *rx_ring)
++=======
+ nfp_net_rx_ring_bufs_alloc(struct nfp_net_dp *dp,
+ 			   struct nfp_net_rx_ring *rx_ring)
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  {
  	struct nfp_net_rx_buf *rxbufs;
  	unsigned int i;
@@@ -1205,10 -1295,9 +1247,16 @@@
  
  	for (i = 0; i < rx_ring->cnt - 1; i++) {
  		rxbufs[i].frag =
++<<<<<<< HEAD
 +			nfp_net_rx_alloc_one(rx_ring, &rxbufs[i].dma_addr,
 +					     rx_ring->bufsz);
 +		if (!rxbufs[i].frag) {
 +			nfp_net_rx_ring_bufs_free(nn, rx_ring);
++=======
+ 			nfp_net_rx_alloc_one(dp, rx_ring, &rxbufs[i].dma_addr);
+ 		if (!rxbufs[i].frag) {
+ 			nfp_net_rx_ring_bufs_free(dp, rx_ring);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  			return -ENOMEM;
  		}
  	}
@@@ -1668,9 -1890,9 +1716,14 @@@ err_alloc
  }
  
  static struct nfp_net_rx_ring *
++<<<<<<< HEAD
 +nfp_net_rx_ring_set_prepare(struct nfp_net *nn, struct nfp_net_ring_set *s)
++=======
+ nfp_net_rx_ring_set_prepare(struct nfp_net *nn, struct nfp_net_dp *dp,
+ 			    struct nfp_net_ring_set *s)
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  {
 +	unsigned int fl_bufsz =	nfp_net_calc_fl_bufsz(nn, s->mtu);
  	struct nfp_net_rx_ring *rings;
  	unsigned int r;
  
@@@ -1681,10 -1903,10 +1734,14 @@@
  	for (r = 0; r < s->n_rings; r++) {
  		nfp_net_rx_ring_init(&rings[r], &nn->r_vecs[r], r);
  
 -		if (nfp_net_rx_ring_alloc(dp, &rings[r], s->dcnt))
 +		if (nfp_net_rx_ring_alloc(&rings[r], fl_bufsz, s->dcnt))
  			goto err_free_prev;
  
++<<<<<<< HEAD
 +		if (nfp_net_rx_ring_bufs_alloc(nn, &rings[r]))
++=======
+ 		if (nfp_net_rx_ring_bufs_alloc(dp, &rings[r]))
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  			goto err_free_ring;
  	}
  
@@@ -1692,7 -1914,7 +1749,11 @@@
  
  err_free_prev:
  	while (r--) {
++<<<<<<< HEAD
 +		nfp_net_rx_ring_bufs_free(nn, &rings[r]);
++=======
+ 		nfp_net_rx_ring_bufs_free(dp, &rings[r]);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  err_free_ring:
  		nfp_net_rx_ring_free(&rings[r]);
  	}
@@@ -1718,13 -1944,13 +1779,21 @@@ nfp_net_rx_ring_set_swap(struct nfp_ne
  }
  
  static void
++<<<<<<< HEAD
 +nfp_net_rx_ring_set_free(struct nfp_net *nn, struct nfp_net_ring_set *s)
++=======
+ nfp_net_rx_ring_set_free(struct nfp_net_dp *dp, struct nfp_net_ring_set *s)
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  {
  	struct nfp_net_rx_ring *rings = s->rings;
  	unsigned int r;
  
  	for (r = 0; r < s->n_rings; r++) {
++<<<<<<< HEAD
 +		nfp_net_rx_ring_bufs_free(nn, &rings[r]);
++=======
+ 		nfp_net_rx_ring_bufs_free(dp, &rings[r]);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  		nfp_net_rx_ring_free(&rings[r]);
  	}
  
@@@ -2057,8 -2286,8 +2126,13 @@@ static int nfp_net_netdev_open(struct n
  			goto err_cleanup_vec_p;
  	}
  
++<<<<<<< HEAD
 +	nn->rx_rings = nfp_net_rx_ring_set_prepare(nn, &rx);
 +	if (!nn->rx_rings) {
++=======
+ 	nn->dp.rx_rings = nfp_net_rx_ring_set_prepare(nn, &nn->dp, &rx);
+ 	if (!nn->dp.rx_rings) {
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  		err = -ENOMEM;
  		goto err_cleanup_vec;
  	}
@@@ -2102,11 -2331,11 +2176,15 @@@
  	return 0;
  
  err_free_rings:
 -	nfp_net_tx_ring_set_free(&tx);
 +	nfp_net_tx_ring_set_free(nn, &tx);
  err_free_rx_rings:
++<<<<<<< HEAD
 +	nfp_net_rx_ring_set_free(nn, &rx);
++=======
+ 	nfp_net_rx_ring_set_free(&nn->dp, &rx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  err_cleanup_vec:
 -	r = nn->dp.num_r_vecs;
 +	r = nn->num_r_vecs;
  err_cleanup_vec_p:
  	while (r--)
  		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
@@@ -2144,17 -2373,17 +2222,23 @@@ static void nfp_net_close_free_all(stru
  {
  	unsigned int r;
  
++<<<<<<< HEAD
 +	for (r = 0; r < nn->num_rx_rings; r++) {
 +		nfp_net_rx_ring_bufs_free(nn, &nn->rx_rings[r]);
 +		nfp_net_rx_ring_free(&nn->rx_rings[r]);
++=======
+ 	for (r = 0; r < nn->dp.num_rx_rings; r++) {
+ 		nfp_net_rx_ring_bufs_free(&nn->dp, &nn->dp.rx_rings[r]);
+ 		nfp_net_rx_ring_free(&nn->dp.rx_rings[r]);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  	}
 -	for (r = 0; r < nn->dp.num_tx_rings; r++)
 -		nfp_net_tx_ring_free(&nn->dp.tx_rings[r]);
 -	for (r = 0; r < nn->dp.num_r_vecs; r++)
 +	for (r = 0; r < nn->num_tx_rings; r++)
 +		nfp_net_tx_ring_free(&nn->tx_rings[r]);
 +	for (r = 0; r < nn->num_r_vecs; r++)
  		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
  
 -	kfree(nn->dp.rx_rings);
 -	kfree(nn->dp.tx_rings);
 +	kfree(nn->rx_rings);
 +	kfree(nn->tx_rings);
  
  	nfp_net_aux_irq_free(nn, NFP_NET_CFG_LSC, NFP_NET_IRQ_LSC_IDX);
  	nfp_net_aux_irq_free(nn, NFP_NET_CFG_EXN, NFP_NET_IRQ_EXN_IDX);
@@@ -2224,7 -2463,7 +2308,11 @@@ static void nfp_net_rss_init_itbl(struc
  }
  
  static int
++<<<<<<< HEAD
 +nfp_net_ring_swap_enable(struct nfp_net *nn, unsigned int *num_vecs,
++=======
+ nfp_net_ring_swap_enable(struct nfp_net *nn, struct nfp_net_dp *dp,
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  			 struct nfp_net_ring_set *rx,
  			 struct nfp_net_ring_set *tx)
  {
@@@ -2236,16 -2475,17 +2324,22 @@@
  	if (tx)
  		nfp_net_tx_ring_set_swap(nn, tx);
  
++<<<<<<< HEAD
 +	swap(*num_vecs, nn->num_r_vecs);
++=======
+ 	swap(dp->num_r_vecs, nn->dp.num_r_vecs);
+ 	swap(dp->num_stack_tx_rings, nn->dp.num_stack_tx_rings);
+ 	dp->xdp_prog = xchg(&nn->dp.xdp_prog, dp->xdp_prog);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  
  	for (r = 0; r <	nn->max_r_vecs; r++)
 -		nfp_net_vector_assign_rings(&nn->dp, &nn->r_vecs[r], r);
 +		nfp_net_vector_assign_rings(nn, &nn->r_vecs[r], r);
  
 -	if (!netif_is_rxfh_configured(nn->dp.netdev))
 +	if (!netif_is_rxfh_configured(nn->netdev))
  		nfp_net_rss_init_itbl(nn);
  
 -	err = netif_set_real_num_rx_queues(nn->dp.netdev, nn->dp.num_rx_rings);
 +	err = netif_set_real_num_rx_queues(nn->netdev,
 +					   nn->num_rx_rings);
  	if (err)
  		return err;
  
@@@ -2259,37 -2499,85 +2353,114 @@@
  	return __nfp_net_set_config_and_enable(nn);
  }
  
++<<<<<<< HEAD
 +static void
 +nfp_net_ring_reconfig_down(struct nfp_net *nn,
++=======
+ struct nfp_net_dp *nfp_net_clone_dp(struct nfp_net *nn)
+ {
+ 	struct nfp_net_dp *new;
+ 
+ 	new = kmalloc(sizeof(*new), GFP_KERNEL);
+ 	if (!new)
+ 		return NULL;
+ 
+ 	*new = nn->dp;
+ 
+ 	/* Clear things which need to be recomputed */
+ 	new->fl_bufsz = 0;
+ 	new->tx_rings = NULL;
+ 	new->rx_rings = NULL;
+ 	new->num_r_vecs = 0;
+ 	new->num_stack_tx_rings = 0;
+ 
+ 	return new;
+ }
+ 
+ static int
+ nfp_net_check_config(struct nfp_net *nn, struct nfp_net_dp *dp,
+ 		     struct nfp_net_ring_set *rx, struct nfp_net_ring_set *tx)
+ {
+ 	/* XDP-enabled tests */
+ 	if (!dp->xdp_prog)
+ 		return 0;
+ 	if (dp->fl_bufsz > PAGE_SIZE) {
+ 		nn_warn(nn, "MTU too large w/ XDP enabled\n");
+ 		return -EINVAL;
+ 	}
+ 	if (tx && tx->n_rings > nn->max_tx_rings) {
+ 		nn_warn(nn, "Insufficient number of TX rings w/ XDP enabled\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ nfp_net_ring_reconfig_down(struct nfp_net *nn, struct nfp_net_dp *dp,
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  			   struct nfp_net_ring_set *rx,
 -			   struct nfp_net_ring_set *tx)
 -{
 -	nfp_net_dp_swap(nn, dp);
 -
 +			   struct nfp_net_ring_set *tx,
 +			   unsigned int num_vecs)
 +{
 +	nn->netdev->mtu = rx ? rx->mtu : nn->netdev->mtu;
 +	nn->fl_bufsz = nfp_net_calc_fl_bufsz(nn, nn->netdev->mtu);
 +	nn->rxd_cnt = rx ? rx->dcnt : nn->rxd_cnt;
 +	nn->txd_cnt = tx ? tx->dcnt : nn->txd_cnt;
 +	nn->num_rx_rings = rx ? rx->n_rings : nn->num_rx_rings;
 +	nn->num_tx_rings = tx ? tx->n_rings : nn->num_tx_rings;
 +	nn->num_r_vecs = num_vecs;
 +
++<<<<<<< HEAD
 +	if (!netif_is_rxfh_configured(nn->netdev))
++=======
+ 	nn->dp.rxd_cnt = rx ? rx->dcnt : nn->dp.rxd_cnt;
+ 	nn->dp.txd_cnt = tx ? tx->dcnt : nn->dp.txd_cnt;
+ 	nn->dp.num_rx_rings = rx ? rx->n_rings : nn->dp.num_rx_rings;
+ 	nn->dp.num_tx_rings = tx ? tx->n_rings : nn->dp.num_tx_rings;
+ 
+ 	if (!netif_is_rxfh_configured(nn->dp.netdev))
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  		nfp_net_rss_init_itbl(nn);
  }
  
  int
++<<<<<<< HEAD
 +nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_ring_set *rx,
 +		      struct nfp_net_ring_set *tx)
++=======
+ nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_dp *dp,
+ 		      struct nfp_net_ring_set *rx, struct nfp_net_ring_set *tx)
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  {
 -	int r, err;
 +	unsigned int num_vecs, r;
 +	int err;
  
 -	dp->fl_bufsz = nfp_net_calc_fl_bufsz(dp);
 +	num_vecs = max(rx ? rx->n_rings : nn->num_rx_rings,
 +		       tx ? tx->n_rings : nn->num_tx_rings);
  
++<<<<<<< HEAD
 +	if (!netif_running(nn->netdev)) {
 +		nfp_net_ring_reconfig_down(nn, rx, tx, num_vecs);
 +		return 0;
++=======
+ 	dp->num_stack_tx_rings = tx ? tx->n_rings : dp->num_tx_rings;
+ 	if (dp->xdp_prog)
+ 		dp->num_stack_tx_rings -= rx ? rx->n_rings : dp->num_rx_rings;
+ 
+ 	dp->num_r_vecs = max(rx ? rx->n_rings : dp->num_rx_rings,
+ 			     dp->num_stack_tx_rings);
+ 
+ 	err = nfp_net_check_config(nn, dp, rx, tx);
+ 	if (err)
+ 		goto exit_free_dp;
+ 
+ 	if (!netif_running(dp->netdev)) {
+ 		nfp_net_ring_reconfig_down(nn, dp, rx, tx);
+ 
+ 		err = 0;
+ 		goto exit_free_dp;
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  	}
  
  	/* Prepare new rings */
@@@ -2301,7 -2589,7 +2472,11 @@@
  		}
  	}
  	if (rx) {
++<<<<<<< HEAD
 +		if (!nfp_net_rx_ring_set_prepare(nn, rx)) {
++=======
+ 		if (!nfp_net_rx_ring_set_prepare(nn, dp, rx)) {
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  			err = -ENOMEM;
  			goto err_cleanup_vecs;
  		}
@@@ -2317,14 -2605,14 +2492,22 @@@
  	nfp_net_close_stack(nn);
  	nfp_net_clear_config_and_disable(nn);
  
++<<<<<<< HEAD
 +	err = nfp_net_ring_swap_enable(nn, &num_vecs, rx, tx);
++=======
+ 	err = nfp_net_ring_swap_enable(nn, dp, rx, tx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  	if (err) {
  		int err2;
  
  		nfp_net_clear_config_and_disable(nn);
  
  		/* Try with old configuration and old rings */
++<<<<<<< HEAD
 +		err2 = nfp_net_ring_swap_enable(nn, &num_vecs, rx, tx);
++=======
+ 		err2 = nfp_net_ring_swap_enable(nn, dp, rx, tx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  		if (err2)
  			nn_err(nn, "Can't restore ring config - FW communication failed (%d,%d)\n",
  			       err, err2);
@@@ -2333,20 -2621,23 +2516,28 @@@
  		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
  
  	if (rx)
++<<<<<<< HEAD
 +		nfp_net_rx_ring_set_free(nn, rx);
++=======
+ 		nfp_net_rx_ring_set_free(dp, rx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  	if (tx)
 -		nfp_net_tx_ring_set_free(tx);
 +		nfp_net_tx_ring_set_free(nn, tx);
  
  	nfp_net_open_stack(nn);
 -exit_free_dp:
 -	kfree(dp);
  
  	return err;
  
  err_free_rx:
  	if (rx)
++<<<<<<< HEAD
 +		nfp_net_rx_ring_set_free(nn, rx);
++=======
+ 		nfp_net_rx_ring_set_free(dp, rx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  err_cleanup_vecs:
 -	for (r = dp->num_r_vecs - 1; r >= nn->dp.num_r_vecs; r--)
 +	for (r = num_vecs - 1; r >= nn->num_r_vecs; r--)
  		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
 -	kfree(dp);
  	return err;
  }
  
@@@ -2354,16 -2645,22 +2545,26 @@@ static int nfp_net_change_mtu(struct ne
  {
  	struct nfp_net *nn = netdev_priv(netdev);
  	struct nfp_net_ring_set rx = {
 -		.n_rings = nn->dp.num_rx_rings,
 -		.dcnt = nn->dp.rxd_cnt,
 +		.n_rings = nn->num_rx_rings,
 +		.mtu = new_mtu,
 +		.dcnt = nn->rxd_cnt,
  	};
 -	struct nfp_net_dp *dp;
  
++<<<<<<< HEAD
 +	return nfp_net_ring_reconfig(nn, &rx, NULL);
++=======
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	dp->mtu = new_mtu;
+ 
+ 	return nfp_net_ring_reconfig(nn, dp, &rx, NULL);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  }
  
 -static void nfp_net_stat64(struct net_device *netdev,
 -			   struct rtnl_link_stats64 *stats)
 +static struct rtnl_link_stats64 *nfp_net_stat64(struct net_device *netdev,
 +						struct rtnl_link_stats64 *stats)
  {
  	struct nfp_net *nn = netdev_priv(netdev);
  	int r;
@@@ -2595,8 -2944,97 +2796,101 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static int nfp_net_xdp_offload(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct tc_cls_bpf_offload cmd = {
+ 		.prog = prog,
+ 	};
+ 	int ret;
+ 
+ 	if (!nfp_net_ebpf_capable(nn))
+ 		return -EINVAL;
+ 
+ 	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF) {
+ 		if (!nn->dp.bpf_offload_xdp)
+ 			return prog ? -EBUSY : 0;
+ 		cmd.command = prog ? TC_CLSBPF_REPLACE : TC_CLSBPF_DESTROY;
+ 	} else {
+ 		if (!prog)
+ 			return 0;
+ 		cmd.command = TC_CLSBPF_ADD;
+ 	}
+ 
+ 	ret = nfp_net_bpf_offload(nn, &cmd);
+ 	/* Stop offload if replace not possible */
+ 	if (ret && cmd.command == TC_CLSBPF_REPLACE)
+ 		nfp_net_xdp_offload(nn, NULL);
+ 	nn->dp.bpf_offload_xdp = prog && !ret;
+ 	return ret;
+ }
+ 
+ static int nfp_net_xdp_setup(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct bpf_prog *old_prog = nn->dp.xdp_prog;
+ 	struct nfp_net_ring_set rx = {
+ 		.n_rings = nn->dp.num_rx_rings,
+ 		.dcnt = nn->dp.rxd_cnt,
+ 	};
+ 	struct nfp_net_ring_set tx = {
+ 		.n_rings = nn->dp.num_tx_rings,
+ 		.dcnt = nn->dp.txd_cnt,
+ 	};
+ 	struct nfp_net_dp *dp;
+ 	int err;
+ 
+ 	if (prog && prog->xdp_adjust_head) {
+ 		nn_err(nn, "Does not support bpf_xdp_adjust_head()\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 	if (!prog && !nn->dp.xdp_prog)
+ 		return 0;
+ 	if (prog && nn->dp.xdp_prog) {
+ 		prog = xchg(&nn->dp.xdp_prog, prog);
+ 		bpf_prog_put(prog);
+ 		nfp_net_xdp_offload(nn, nn->dp.xdp_prog);
+ 		return 0;
+ 	}
+ 
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	dp->xdp_prog = prog;
+ 	tx.n_rings += prog ? nn->dp.num_rx_rings : -nn->dp.num_rx_rings;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	err = nfp_net_ring_reconfig(nn, dp, &rx, &tx);
+ 	if (err)
+ 		return err;
+ 
+ 	if (old_prog)
+ 		bpf_prog_put(old_prog);
+ 
+ 	nfp_net_xdp_offload(nn, nn->dp.xdp_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 		return nfp_net_xdp_setup(nn, xdp->prog);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->dp.xdp_prog;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index dfbf6b94ff5b,63c1d9ab2335..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@@ -180,16 -192,21 +180,24 @@@ static int nfp_net_set_ring_size(struc
  		.dcnt = rxd_cnt,
  	};
  	struct nfp_net_ring_set tx = {
 -		.n_rings = nn->dp.num_tx_rings,
 +		.n_rings = nn->num_tx_rings,
  		.dcnt = txd_cnt,
  	};
 -	struct nfp_net_dp *dp;
  
 -	if (nn->dp.rxd_cnt != rxd_cnt)
 +	if (nn->rxd_cnt != rxd_cnt)
  		reconfig_rx = &rx;
 -	if (nn->dp.txd_cnt != txd_cnt)
 +	if (nn->txd_cnt != txd_cnt)
  		reconfig_tx = &tx;
  
++<<<<<<< HEAD
 +	return nfp_net_ring_reconfig(nn, reconfig_rx, reconfig_tx);
++=======
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	return nfp_net_ring_reconfig(nn, dp, reconfig_rx, reconfig_tx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  }
  
  static int nfp_net_set_ringparam(struct net_device *netdev,
@@@ -743,15 -772,25 +751,27 @@@ static int nfp_net_set_num_rings(struc
  	};
  	struct nfp_net_ring_set tx = {
  		.n_rings = total_tx,
 -		.dcnt = nn->dp.txd_cnt,
 +		.dcnt = nn->txd_cnt,
  	};
 -	struct nfp_net_dp *dp;
  
 -	if (nn->dp.num_rx_rings != total_rx)
 +	if (nn->num_rx_rings != total_rx)
  		reconfig_rx = &rx;
 -	if (nn->dp.num_stack_tx_rings != total_tx ||
 -	    (nn->dp.xdp_prog && reconfig_rx))
 +	if (nn->num_tx_rings != total_tx)
  		reconfig_tx = &tx;
  
++<<<<<<< HEAD
 +	return nfp_net_ring_reconfig(nn, reconfig_rx, reconfig_tx);
++=======
+ 	/* nfp_net_check_config() will catch tx.n_rings > nn->max_tx_rings */
+ 	if (nn->dp.xdp_prog)
+ 		tx.n_rings += total_rx;
+ 
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	return nfp_net_ring_reconfig(nn, dp, reconfig_rx, reconfig_tx);
++>>>>>>> 9dc6b116e21b (nfp: use dp to carry xdp_prog at reconfig time)
  }
  
  static int nfp_net_set_channels(struct net_device *netdev,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
