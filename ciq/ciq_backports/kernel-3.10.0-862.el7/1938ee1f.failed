net: Remove deprecated tunnel specific UDP offload functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] vxlan/geneve: Remove deprecated tunnel specific UDP offload functions (Jiri Benc) [1467280]
Rebuild_FUZZ: 91.47%
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 1938ee1fd3de74d761a60806b048df652666afec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1938ee1f.failed

Now that we have all the drivers using udp_tunnel_get_rx_ports,
ndo_add_udp_enc_rx_port, and ndo_del_udp_enc_rx_port we can drop the
function calls that were specific to VXLAN and GENEVE.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1938ee1fd3de74d761a60806b048df652666afec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/ipv4/udp_tunnel.c
diff --cc include/linux/netdevice.h
index f2e995a93118,e84d9d23c2d5..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1150,38 -1026,40 +1150,47 @@@ struct net_device_ops_extended 
   *	not implement this, it is assumed that the hw is not able to have
   *	multiple net devices on single physical port.
   *
++<<<<<<< HEAD
 + * void (*ndo_add_vxlan_port)(struct  net_device *dev,
 + *			      sa_family_t sa_family, __be16 port);
 + *	Called by vxlan to notiy a driver about the UDP port and socket
 + *	address family that vxlan is listnening to. It is called only when
 + *	a new port starts listening. The operation is protected by the
 + *	vxlan_net->sock_lock.
 + *
 + * void (*ndo_add_geneve_port)(struct net_device *dev,
 + *			      sa_family_t sa_family, __be16 port);
 + *	Called by geneve to notify a driver about the UDP port and socket
 + *	address family that geneve is listnening to. It is called only when
 + *	a new port starts listening. The operation is protected by the
 + *	geneve_net->sock_lock.
 + *
 + * void (*ndo_del_geneve_port)(struct net_device *dev,
 + *			      sa_family_t sa_family, __be16 port);
 + *	Called by geneve to notify the driver about a UDP port and socket
 + *	address family that geneve is not listening to anymore. The operation
 + *	is protected by the geneve_net->sock_lock.
 + *
 + * void (*ndo_del_vxlan_port)(struct  net_device *dev,
 + *			      sa_family_t sa_family, __be16 port);
 + *	Called by vxlan to notify the driver about a UDP port and socket
 + *	address family that vxlan is not listening to anymore. The operation
 + *	is protected by the vxlan_net->sock_lock.
 + *
 + * int (*ndo_get_iflink)(const struct net_device *dev);
 + *	Called to get the iflink value of this device.
++=======
+  * void (*ndo_udp_tunnel_add)(struct net_device *dev,
+  *			      struct udp_tunnel_info *ti);
+  *	Called by UDP tunnel to notify a driver about the UDP port and socket
+  *	address family that a UDP tunnel is listnening to. It is called only
+  *	when a new port starts listening. The operation is protected by the
+  *	RTNL.
++>>>>>>> 1938ee1fd3de (net: Remove deprecated tunnel specific UDP offload functions)
   *
 - * void (*ndo_udp_tunnel_del)(struct net_device *dev,
 - *			      struct udp_tunnel_info *ti);
 - *	Called by UDP tunnel to notify the driver about a UDP port and socket
 - *	address family that the UDP tunnel is not listening to anymore. The
 - *	operation is protected by the RTNL.
 - *
 - * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
 - *				 struct net_device *dev)
 - *	Called by upper layer devices to accelerate switching or other
 - *	station functionality into hardware. 'pdev is the lowerdev
 - *	to use for the offload and 'dev' is the net device that will
 - *	back the offload. Returns a pointer to the private structure
 - *	the upper layer will maintain.
 - * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
 - *	Called by upper layer device to delete the station created
 - *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
 - *	the station and priv is the structure returned by the add
 - *	operation.
 - * netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *skb,
 - *				      struct net_device *dev,
 - *				      void *priv);
 - *	Callback to use for xmit over the accelerated station. This
 - *	is used in place of ndo_start_xmit on accelerated net
 - *	devices.
 - * netdev_features_t (*ndo_features_check)(struct sk_buff *skb,
 - *					   struct net_device *dev
 - *					   netdev_features_t features);
 + * netdev_features_t (*ndo_features_check) (struct sk_buff *skb,
 + *					    struct net_device *dev
 + *					    netdev_features_t features);
   *	Called by core transmit path to determine if device is capable of
   *	performing offload operations on a given packet. This is to give
   *	the device an opportunity to implement any restrictions that cannot
@@@ -1350,77 -1244,33 +1359,90 @@@ struct net_device_ops 
  						      bool new_carrier);
  	int			(*ndo_get_phys_port_id)(struct net_device *dev,
  							struct netdev_phys_item_id *ppid);
++<<<<<<< HEAD
 +	void			(*ndo_add_vxlan_port)(struct  net_device *dev,
 +						      sa_family_t sa_family,
 +						      __be16 port);
 +	void			(*ndo_del_vxlan_port)(struct  net_device *dev,
 +						      sa_family_t sa_family,
 +						      __be16 port);
++=======
+ 	int			(*ndo_get_phys_port_name)(struct net_device *dev,
+ 							  char *name, size_t len);
+ 	void			(*ndo_udp_tunnel_add)(struct net_device *dev,
+ 						      struct udp_tunnel_info *ti);
+ 	void			(*ndo_udp_tunnel_del)(struct net_device *dev,
+ 						      struct udp_tunnel_info *ti);
+ 	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
+ 							struct net_device *dev);
+ 	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
+ 							void *priv);
++>>>>>>> 1938ee1fd3de (net: Remove deprecated tunnel specific UDP offload functions)
 +
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
  
 -	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
 -							struct net_device *dev,
 -							void *priv);
 -	int			(*ndo_get_lock_subclass)(struct net_device *dev);
 -	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
 -						      int queue_index,
 -						      u32 maxrate);
 -	int			(*ndo_get_iflink)(const struct net_device *dev);
 -	int			(*ndo_change_proto_down)(struct net_device *dev,
 -							 bool proto_down);
 -	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
 -						       struct sk_buff *skb);
 -	void			(*ndo_set_rx_headroom)(struct net_device *dev,
 -						       int needed_headroom);
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc)(struct net_device *dev,
 +						u32 handle,
 +						__be16 protocol,
 +						struct tc_to_netdev *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
diff --cc net/ipv4/udp_tunnel.c
index 6e94af27d34c,58bd39fb14b4..000000000000
--- a/net/ipv4/udp_tunnel.c
+++ b/net/ipv4/udp_tunnel.c
@@@ -78,36 -76,6 +78,39 @@@ void setup_udp_tunnel_sock(struct net *
  }
  EXPORT_SYMBOL_GPL(setup_udp_tunnel_sock);
  
++<<<<<<< HEAD
 +static void __udp_tunnel_push_rx_port(struct net_device *dev,
 +				      struct udp_tunnel_info *ti)
 +{
 +	if (get_ndo_ext(dev->netdev_ops, ndo_udp_tunnel_add)) {
 +		get_ndo_ext(dev->netdev_ops, ndo_udp_tunnel_add)(dev, ti);
 +		return;
 +	}
 +
 +	switch (ti->type) {
 +	case UDP_TUNNEL_TYPE_VXLAN:
 +		if (!dev->netdev_ops->ndo_add_vxlan_port)
 +			break;
 +
 +		dev->netdev_ops->ndo_add_vxlan_port(dev,
 +						    ti->sa_family,
 +						    ti->port);
 +		break;
 +	case UDP_TUNNEL_TYPE_GENEVE:
 +		if (!dev->netdev_ops->ndo_add_geneve_port)
 +			break;
 +
 +		dev->netdev_ops->ndo_add_geneve_port(dev,
 +						     ti->sa_family,
 +						     ti->port);
 +		break;
 +	default:
 +		break;
 +	}
 +}
 +
++=======
++>>>>>>> 1938ee1fd3de (net: Remove deprecated tunnel specific UDP offload functions)
  void udp_tunnel_push_rx_port(struct net_device *dev, struct socket *sock,
  			     unsigned short type)
  {
@@@ -141,36 -115,6 +150,39 @@@ void udp_tunnel_notify_add_rx_port(stru
  }
  EXPORT_SYMBOL_GPL(udp_tunnel_notify_add_rx_port);
  
++<<<<<<< HEAD
 +static void __udp_tunnel_pull_rx_port(struct net_device *dev,
 +				      struct udp_tunnel_info *ti)
 +{
 +	if (get_ndo_ext(dev->netdev_ops, ndo_udp_tunnel_del)) {
 +		get_ndo_ext(dev->netdev_ops, ndo_udp_tunnel_del)(dev, ti);
 +		return;
 +	}
 +
 +	switch (ti->type) {
 +	case UDP_TUNNEL_TYPE_VXLAN:
 +		if (!dev->netdev_ops->ndo_del_vxlan_port)
 +			break;
 +
 +		dev->netdev_ops->ndo_del_vxlan_port(dev,
 +						    ti->sa_family,
 +						    ti->port);
 +		break;
 +	case UDP_TUNNEL_TYPE_GENEVE:
 +		if (!dev->netdev_ops->ndo_del_geneve_port)
 +			break;
 +
 +		dev->netdev_ops->ndo_del_geneve_port(dev,
 +						     ti->sa_family,
 +						     ti->port);
 +		break;
 +	default:
 +		break;
 +	}
 +}
 +
++=======
++>>>>>>> 1938ee1fd3de (net: Remove deprecated tunnel specific UDP offload functions)
  /* Notify netdevs that UDP port is no more listening */
  void udp_tunnel_notify_del_rx_port(struct socket *sock, unsigned short type)
  {
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/geneve.h b/include/net/geneve.h
index 0b39d84bf1c2..6a28ecd1e41b 100644
--- a/include/net/geneve.h
+++ b/include/net/geneve.h
@@ -59,11 +59,6 @@ struct genevehdr {
 	struct geneve_opt options[];
 };
 
-static inline void geneve_get_rx_port(struct net_device *netdev)
-{
-	udp_tunnel_get_rx_info(netdev);
-}
-
 #ifdef CONFIG_INET
 struct net_device *geneve_dev_create_fb(struct net *net, const char *name,
 					u16 dst_port);
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 4ba23515efc8..59b198a48114 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -379,11 +379,6 @@ static inline __be32 vxlan_compute_rco(unsigned int start, unsigned int offset)
 	return vni_field;
 }
 
-static inline void vxlan_get_rx_port(struct net_device *netdev)
-{
-	udp_tunnel_get_rx_info(netdev);
-}
-
 static inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)
 {
 	return vs->sock->sk->sk_family;
* Unmerged path net/ipv4/udp_tunnel.c
