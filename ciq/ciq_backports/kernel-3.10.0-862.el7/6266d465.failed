ovl: don't fail copy-up if upper doesn't support xattr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 6266d465bde044a105f6c2d4e244680f951a2d70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6266d465.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 6266d465bde044a105f6c2d4e244680f951a2d70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,f92ab35d43a6..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -264,9 -233,87 +264,89 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct ovl_fh *ovl_encode_fh(struct dentry *lower, uuid_be *uuid)
+ {
+ 	struct ovl_fh *fh;
+ 	int fh_type, fh_len, dwords;
+ 	void *buf;
+ 	int buflen = MAX_HANDLE_SZ;
+ 
+ 	buf = kmalloc(buflen, GFP_TEMPORARY);
+ 	if (!buf)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	/*
+ 	 * We encode a non-connectable file handle for non-dir, because we
+ 	 * only need to find the lower inode number and we don't want to pay
+ 	 * the price or reconnecting the dentry.
+ 	 */
+ 	dwords = buflen >> 2;
+ 	fh_type = exportfs_encode_fh(lower, buf, &dwords, 0);
+ 	buflen = (dwords << 2);
+ 
+ 	fh = ERR_PTR(-EIO);
+ 	if (WARN_ON(fh_type < 0) ||
+ 	    WARN_ON(buflen > MAX_HANDLE_SZ) ||
+ 	    WARN_ON(fh_type == FILEID_INVALID))
+ 		goto out;
+ 
+ 	BUILD_BUG_ON(MAX_HANDLE_SZ + offsetof(struct ovl_fh, fid) > 255);
+ 	fh_len = offsetof(struct ovl_fh, fid) + buflen;
+ 	fh = kmalloc(fh_len, GFP_KERNEL);
+ 	if (!fh) {
+ 		fh = ERR_PTR(-ENOMEM);
+ 		goto out;
+ 	}
+ 
+ 	fh->version = OVL_FH_VERSION;
+ 	fh->magic = OVL_FH_MAGIC;
+ 	fh->type = fh_type;
+ 	fh->flags = OVL_FH_FLAG_CPU_ENDIAN;
+ 	fh->len = fh_len;
+ 	fh->uuid = *uuid;
+ 	memcpy(fh->fid, buf, buflen);
+ 
+ out:
+ 	kfree(buf);
+ 	return fh;
+ }
+ 
+ static int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+ 			  struct dentry *upper)
+ {
+ 	struct super_block *sb = lower->d_sb;
+ 	uuid_be *uuid = (uuid_be *) &sb->s_uuid;
+ 	const struct ovl_fh *fh = NULL;
+ 	int err;
+ 
+ 	/*
+ 	 * When lower layer doesn't support export operations store a 'null' fh,
+ 	 * so we can use the overlay.origin xattr to distignuish between a copy
+ 	 * up and a pure upper inode.
+ 	 */
+ 	if (sb->s_export_op && sb->s_export_op->fh_to_dentry &&
+ 	    uuid_be_cmp(*uuid, NULL_UUID_BE)) {
+ 		fh = ovl_encode_fh(lower, uuid);
+ 		if (IS_ERR(fh))
+ 			return PTR_ERR(fh);
+ 	}
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_ORIGIN, fh,
+ 				 fh ? fh->len : 0, 0);
+ 	kfree(fh);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 6266d465bde0 (ovl: don't fail copy-up if upper doesn't support xattr)
  static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
  			      struct dentry *dentry, struct path *lowerpath,
 -			      struct kstat *stat, const char *link,
 -			      struct kstat *pstat, bool tmpfile)
 +			      struct kstat *stat, const char *link)
  {
  	struct inode *wdir = workdir->d_inode;
  	struct inode *udir = upperdir->d_inode;
* Unmerged path fs/overlayfs/copy_up.c
