alarmtimer: Prevent overflow of relative timers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit f4781e76f90df7aec400635d73ea4c35ee1d4765
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f4781e76.failed

Andrey reported a alartimer related RCU stall while fuzzing the kernel with
syzkaller.

The reason for this is an overflow in ktime_add() which brings the
resulting time into negative space and causes immediate expiry of the
timer. The following rearm with a small interval does not bring the timer
back into positive space due to the same issue.

This results in a permanent firing alarmtimer which hogs the CPU.

Use ktime_add_safe() instead which detects the overflow and clamps the
result to KTIME_SEC_MAX.

	Reported-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Kostya Serebryany <kcc@google.com>
	Cc: syzkaller <syzkaller@googlegroups.com>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: stable@vger.kernel.org
Link: http://lkml.kernel.org/r/20170530211655.802921648@linutronix.de

(cherry picked from commit f4781e76f90df7aec400635d73ea4c35ee1d4765)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/alarmtimer.c
diff --cc kernel/time/alarmtimer.c
index f174e8e15c4b,2b2e032b4eb4..000000000000
--- a/kernel/time/alarmtimer.c
+++ b/kernel/time/alarmtimer.c
@@@ -319,7 -373,37 +319,38 @@@ void alarm_start(struct alarm *alarm, k
  	alarmtimer_enqueue(base, alarm);
  	hrtimer_start(&alarm->timer, alarm->node.expires, HRTIMER_MODE_ABS);
  	spin_unlock_irqrestore(&base->lock, flags);
 -
 -	trace_alarmtimer_start(alarm, base->gettime());
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(alarm_start);
+ 
+ /**
+  * alarm_start_relative - Sets a relative alarm to fire
+  * @alarm: ptr to alarm to set
+  * @start: time relative to now to run the alarm
+  */
+ void alarm_start_relative(struct alarm *alarm, ktime_t start)
+ {
+ 	struct alarm_base *base = &alarm_bases[alarm->type];
+ 
+ 	start = ktime_add_safe(start, base->gettime());
+ 	alarm_start(alarm, start);
+ }
+ EXPORT_SYMBOL_GPL(alarm_start_relative);
+ 
+ void alarm_restart(struct alarm *alarm)
+ {
+ 	struct alarm_base *base = &alarm_bases[alarm->type];
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&base->lock, flags);
+ 	hrtimer_set_expires(&alarm->timer, alarm->node.expires);
+ 	hrtimer_restart(&alarm->timer);
+ 	alarmtimer_enqueue(base, alarm);
+ 	spin_unlock_irqrestore(&base->lock, flags);
+ }
+ EXPORT_SYMBOL_GPL(alarm_restart);
++>>>>>>> f4781e76f90d (alarmtimer: Prevent overflow of relative timers)
  
  /**
   * alarm_try_to_cancel - Tries to cancel an alarm timer
@@@ -387,11 -475,18 +418,11 @@@ u64 alarm_forward(struct alarm *alarm, 
  		overrun++;
  	}
  
- 	alarm->node.expires = ktime_add(alarm->node.expires, interval);
+ 	alarm->node.expires = ktime_add_safe(alarm->node.expires, interval);
  	return overrun;
  }
 -EXPORT_SYMBOL_GPL(alarm_forward);
  
 -u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)
 -{
 -	struct alarm_base *base = &alarm_bases[alarm->type];
  
 -	return alarm_forward(alarm, base->gettime(), interval);
 -}
 -EXPORT_SYMBOL_GPL(alarm_forward_now);
  
  
  /**
* Unmerged path kernel/time/alarmtimer.c
