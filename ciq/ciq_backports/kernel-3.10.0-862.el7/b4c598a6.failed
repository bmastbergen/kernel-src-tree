RDMA/netlink: Implement nldev device dumpit calback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Leon Romanovsky <leonro@mellanox.com>
commit b4c598a67ea19c5784e542c03dd912a0ce36109a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b4c598a6.failed

This patch adds the ability to return all available devices
together with their properties.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
(cherry picked from commit b4c598a67ea19c5784e542c03dd912a0ce36109a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/ref.h
diff --cc net/tipc/ref.h
index 5bc8e7ab84de,4b8b0f5d5344..000000000000
--- a/net/tipc/ref.h
+++ b/net/tipc/ref.h
@@@ -34,16 -30,78 +34,89 @@@
   * POSSIBILITY OF SUCH DAMAGE.
   */
  
++<<<<<<< HEAD:net/tipc/ref.h
 +#ifndef _TIPC_REF_H
 +#define _TIPC_REF_H
++=======
+ #include <net/netlink.h>
+ #include <rdma/rdma_netlink.h>
++>>>>>>> b4c598a67ea1 (RDMA/netlink: Implement nldev device dumpit calback):drivers/infiniband/core/nldev.c
  
 -#include "core_priv.h"
 +int tipc_ref_table_init(u32 requested_size, u32 start);
 +void tipc_ref_table_stop(void);
  
++<<<<<<< HEAD:net/tipc/ref.h
 +u32 tipc_ref_acquire(void *object, spinlock_t **lock);
 +void tipc_ref_discard(u32 ref);
++=======
+ static const struct nla_policy nldev_policy[RDMA_NLDEV_ATTR_MAX] = {
+ 	[RDMA_NLDEV_ATTR_DEV_INDEX]     = { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_DEV_NAME]	= { .type = NLA_NUL_STRING,
+ 					    .len = IB_DEVICE_NAME_MAX - 1},
+ 	[RDMA_NLDEV_ATTR_PORT_INDEX]	= { .type = NLA_U32 },
+ };
+ 
+ static int fill_dev_info(struct sk_buff *msg, struct ib_device *device)
+ {
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_DEV_INDEX, device->index))
+ 		return -EMSGSIZE;
+ 	if (nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_NAME, device->name))
+ 		return -EMSGSIZE;
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, rdma_end_port(device)))
+ 		return -EMSGSIZE;
+ 	return 0;
+ }
+ 
+ static int _nldev_get_dumpit(struct ib_device *device,
+ 			     struct sk_buff *skb,
+ 			     struct netlink_callback *cb,
+ 			     unsigned int idx)
+ {
+ 	int start = cb->args[0];
+ 	struct nlmsghdr *nlh;
+ 
+ 	if (idx < start)
+ 		return 0;
+ 
+ 	nlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,
+ 			RDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_GET),
+ 			0, NLM_F_MULTI);
+ 
+ 	if (fill_dev_info(skb, device)) {
+ 		nlmsg_cancel(skb, nlh);
+ 		goto out;
+ 	}
+ 
+ 	nlmsg_end(skb, nlh);
+ 
+ 	idx++;
+ 
+ out:	cb->args[0] = idx;
+ 	return skb->len;
+ }
+ 
+ static int nldev_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)
+ {
+ 	/*
+ 	 * There is no need to take lock, because
+ 	 * we are relying on ib_core's lists_rwsem
+ 	 */
+ 	return ib_enum_all_devs(_nldev_get_dumpit, skb, cb);
+ }
+ 
+ static const struct rdma_nl_cbs nldev_cb_table[] = {
+ 	[RDMA_NLDEV_CMD_GET] = {
+ 		.dump = nldev_get_dumpit,
+ 	},
+ };
+ 
+ void __init nldev_init(void)
+ {
+ 	rdma_nl_register(RDMA_NL_NLDEV, nldev_cb_table);
+ }
++>>>>>>> b4c598a67ea1 (RDMA/netlink: Implement nldev device dumpit calback):drivers/infiniband/core/nldev.c
  
 -void __exit nldev_exit(void)
 -{
 -	rdma_nl_unregister(RDMA_NL_NLDEV);
 -}
 +void *tipc_ref_lock(u32 ref);
 +void *tipc_ref_deref(u32 ref);
 +
 +#endif
* Unmerged path net/tipc/ref.h
