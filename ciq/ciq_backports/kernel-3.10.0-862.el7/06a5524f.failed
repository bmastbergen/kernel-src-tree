KVM: nVMX: Fix posted intr delivery when vcpu is in guest mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Wincy Van <fanwenyi0529@gmail.com>
commit 06a5524f091b6b41b0007810c74cc9315923a145
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/06a5524f.failed

The PI vector for L0 and L1 must be different. If dest vcpu0
is in guest mode while vcpu1 is delivering a non-nested PI to
vcpu0, there wont't be any vmexit so that the non-nested interrupt
will be delayed.

	Signed-off-by: Wincy Van <fanwenyi0529@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 06a5524f091b6b41b0007810c74cc9315923a145)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 28219b8ca80d,497cf64794fd..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -4618,26 -5055,12 +4620,31 @@@ static void vmx_deliver_posted_interrup
  	if (pi_test_and_set_pir(vector, &vmx->pi_desc))
  		return;
  
 -	/* If a previous notification has sent the IPI, nothing to do.  */
 -	if (pi_test_and_set_on(&vmx->pi_desc))
 +	r = pi_test_and_set_on(&vmx->pi_desc);
 +	kvm_make_request(KVM_REQ_EVENT, vcpu);
 +	if (r || !kvm_vcpu_trigger_posted_interrupt(vcpu))
 +		kvm_vcpu_kick(vcpu);
 +}
 +
 +static void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 +{
 +	struct vcpu_vmx *vmx = to_vmx(vcpu);
 +
 +	if (!pi_test_on(&vmx->pi_desc))
  		return;
  
++<<<<<<< HEAD
 +	pi_clear_on(&vmx->pi_desc);
 +	/*
 +	 * IOMMU can write to PIR.ON, so the barrier matters even on UP.
 +	 * But on x86 this is just a compiler barrier anyway.
 +	 */
 +	smp_mb__after_atomic();
 +	kvm_apic_update_irr(vcpu, vmx->pi_desc.pir);
++=======
+ 	if (!kvm_vcpu_trigger_posted_interrupt(vcpu, false))
+ 		kvm_vcpu_kick(vcpu);
++>>>>>>> 06a5524f091b (KVM: nVMX: Fix posted intr delivery when vcpu is in guest mode)
  }
  
  /*
@@@ -9606,23 -10055,23 +9613,24 @@@ static int prepare_vmcs02(struct kvm_vc
  	vmcs_write64(VMCS_LINK_POINTER, -1ull);
  
  	exec_control = vmcs12->pin_based_vm_exec_control;
 -
 -	/* Preemption timer setting is only taken from vmcs01.  */
 -	exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
  	exec_control |= vmcs_config.pin_based_exec_ctrl;
 -	if (vmx->hv_deadline_tsc == -1)
 -		exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
 +	exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
  
 -	/* Posted interrupts setting is only taken from vmcs12.  */
  	if (nested_cpu_has_posted_intr(vmcs12)) {
- 		/*
- 		 * Note that we use L0's vector here and in
- 		 * vmx_deliver_nested_posted_interrupt.
- 		 */
  		vmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;
  		vmx->nested.pi_pending = false;
++<<<<<<< HEAD
 +		vmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);
 +		vmcs_write64(POSTED_INTR_DESC_ADDR,
 +			page_to_phys(vmx->nested.pi_desc_page) +
 +			(unsigned long)(vmcs12->posted_intr_desc_addr &
 +			(PAGE_SIZE - 1)));
 +	} else
++=======
+ 		vmcs_write16(POSTED_INTR_NV, POSTED_INTR_NESTED_VECTOR);
+ 	} else {
++>>>>>>> 06a5524f091b (KVM: nVMX: Fix posted intr delivery when vcpu is in guest mode)
  		exec_control &= ~PIN_BASED_POSTED_INTR;
 -	}
  
  	vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);
  
* Unmerged path arch/x86/kvm/vmx.c
