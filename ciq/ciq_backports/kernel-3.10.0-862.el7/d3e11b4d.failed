x86/intel_rdt: Move CBM specific data into a struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt: Move CBM specific data into a struct (Jiri Olsa) [1379551]
Rebuild_FUZZ: 95.92%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit d3e11b4d6ffd363747ac6e6b5522baa9ca5a20c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d3e11b4d.failed

Memory bandwidth allocation requires different information than cache
allocation.

To avoid a lump of data in struct rdt_resource, move all cache related
information into a seperate structure and add that to struct rdt_resource.

Sanitize the data types while at it.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: vikas.shivappa@intel.com
(cherry picked from commit d3e11b4d6ffd363747ac6e6b5522baa9ca5a20c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt.c
diff --cc arch/x86/include/asm/intel_rdt.h
index 06f50d0ed14f,ae61b0fd55bc..000000000000
--- a/arch/x86/include/asm/intel_rdt.h
+++ b/arch/x86/include/asm/intel_rdt.h
@@@ -73,37 -73,46 +73,69 @@@ struct rftype 
  			 char *buf, size_t nbytes, loff_t off);
  };
  
+ /**
+  * struct rdt_cache - Cache allocation related data
+  * @cbm_len:		Length of the cache bit mask
+  * @min_cbm_bits:	Minimum number of consecutive bits to be set
+  * @cbm_idx_mult:	Multiplier of CBM index
+  * @cbm_idx_offset:	Offset of CBM index. CBM index is computed by:
+  *			closid * cbm_idx_multi + cbm_idx_offset
+  *			in a cache bit mask
+  */
+ struct rdt_cache {
+ 	unsigned int	cbm_len;
+ 	unsigned int	min_cbm_bits;
+ 	unsigned int	cbm_idx_mult;
+ 	unsigned int	cbm_idx_offset;
+ };
+ 
  /**
   * struct rdt_resource - attributes of an RDT resource
++<<<<<<< HEAD
 + * @enabled:			Is this feature enabled on this machine
 + * @capable:			Is this feature available on this machine
 + * @name:			Name to use in "schemata" file
 + * @num_closid:			Number of CLOSIDs available
 + * @max_cbm:			Largest Cache Bit Mask allowed
 + * @data_width:			Character width of data when displaying
 + * @min_cbm_bits:		Minimum number of consecutive bits to be set
 + *				in a cache bit mask
 + * @domains:			All domains for this resource
 + * @msr_base:			Base MSR address for CBMs
 + * @cache_level:		Which cache level defines scope of this domain
 + * @cbm_idx_multi:		Multiplier of CBM index
 + * @cbm_idx_offset:		Offset of CBM index. CBM index is computed by:
 + *				closid * cbm_idx_multi + cbm_idx_offset
++=======
+  * @enabled:		Is this feature enabled on this machine
+  * @capable:		Is this feature available on this machine
+  * @name:		Name to use in "schemata" file
+  * @num_closid:		Number of CLOSIDs available
+  * @cache_level:	Which cache level defines scope of this resource
+  * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
+  * @msr_base:		Base MSR address for CBMs
+  * @data_width:		Character width of data when displaying
+  * @domains:		All domains for this resource
+  * @cache:		Cache allocation related data
++>>>>>>> d3e11b4d6ffd (x86/intel_rdt: Move CBM specific data into a struct)
   */
  struct rdt_resource {
  	bool			enabled;
  	bool			capable;
  	char			*name;
  	int			num_closid;
++<<<<<<< HEAD
 +	int			cbm_len;
 +	int			min_cbm_bits;
 +	u32			max_cbm;
++=======
+ 	int			cache_level;
+ 	u32			default_ctrl;
+ 	unsigned int		msr_base;
++>>>>>>> d3e11b4d6ffd (x86/intel_rdt: Move CBM specific data into a struct)
  	int			data_width;
  	struct list_head	domains;
- 	int			msr_base;
- 	int			cache_level;
- 	int			cbm_idx_multi;
- 	int			cbm_idx_offset;
+ 	struct rdt_cache	cache;
  };
  
  /**
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index ad087dd4421e,8d7e050567c2..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -124,9 -132,9 +132,15 @@@ static inline bool cache_alloc_hsw_prob
  			return false;
  
  		r->num_closid = 4;
++<<<<<<< HEAD
 +		r->cbm_len = 20;
 +		r->max_cbm = max_cbm;
 +		r->min_cbm_bits = 2;
++=======
+ 		r->default_ctrl = max_cbm;
+ 		r->cache.cbm_len = 20;
+ 		r->cache.min_cbm_bits = 2;
++>>>>>>> d3e11b4d6ffd (x86/intel_rdt: Move CBM specific data into a struct)
  		r->capable = true;
  		r->enabled = true;
  
@@@ -144,9 -152,9 +158,15 @@@ static void rdt_get_config(int idx, str
  
  	cpuid_count(0x00000010, idx, &eax.full, &ebx, &ecx, &edx.full);
  	r->num_closid = edx.split.cos_max + 1;
++<<<<<<< HEAD
 +	r->cbm_len = eax.split.cbm_len + 1;
 +	r->max_cbm = BIT_MASK(eax.split.cbm_len + 1) - 1;
 +	r->data_width = (r->cbm_len + 3) / 4;
++=======
+ 	r->cache.cbm_len = eax.split.cbm_len + 1;
+ 	r->default_ctrl = BIT_MASK(eax.split.cbm_len + 1) - 1;
+ 	r->data_width = (r->cache.cbm_len + 3) / 4;
++>>>>>>> d3e11b4d6ffd (x86/intel_rdt: Move CBM specific data into a struct)
  	r->capable = true;
  	r->enabled = true;
  }
@@@ -157,9 -165,9 +177,15 @@@ static void rdt_get_cdp_l3_config(int t
  	struct rdt_resource *r = &rdt_resources_all[type];
  
  	r->num_closid = r_l3->num_closid / 2;
++<<<<<<< HEAD
 +	r->cbm_len = r_l3->cbm_len;
 +	r->max_cbm = r_l3->max_cbm;
 +	r->data_width = (r->cbm_len + 3) / 4;
++=======
+ 	r->cache.cbm_len = r_l3->cache.cbm_len;
+ 	r->default_ctrl = r_l3->default_ctrl;
+ 	r->data_width = (r->cache.cbm_len + 3) / 4;
++>>>>>>> d3e11b4d6ffd (x86/intel_rdt: Move CBM specific data into a struct)
  	r->capable = true;
  	/*
  	 * By default, CDP is disabled. CDP can be enabled by mount parameter
@@@ -241,9 -208,9 +267,9 @@@ void rdt_cbm_update(void *arg
  
  found:
  	for (i = m->low; i < m->high; i++) {
- 		int idx = cbm_idx(r, i);
+ 		unsigned int idx = cbm_idx(r, i);
  
 -		wrmsrl(r->msr_base + idx, d->ctrl_val[i]);
 +		wrmsrl(r->msr_base + idx, d->cbm[i]);
  	}
  }
  
@@@ -323,11 -290,10 +349,11 @@@ static void domain_add_cpu(int cpu, str
  	}
  
  	for (i = 0; i < r->num_closid; i++) {
- 		int idx = cbm_idx(r, i);
+ 		unsigned int idx = cbm_idx(r, i);
  
 -		d->ctrl_val[i] = r->default_ctrl;
 -		wrmsrl(r->msr_base + idx, d->ctrl_val[i]);
 +		d->cbm[i] = r->max_cbm;
 +		if (notifier)
 +			wrmsrl(r->msr_base + idx, d->cbm[i]);
  	}
  
  	cpumask_set_cpu(cpu, &d->cpu_mask);
* Unmerged path arch/x86/include/asm/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
diff --git a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 13bdbbd81667..6cedcdc81dfc 100644
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@ -533,7 +533,7 @@ static int rdt_min_cbm_bits_show(struct kernfs_open_file *of,
 {
 	struct rdt_resource *r = of->kn->parent->priv;
 
-	seq_printf(seq, "%d\n", r->min_cbm_bits);
+	seq_printf(seq, "%u\n", r->cache.min_cbm_bits);
 
 	return 0;
 }
diff --git a/arch/x86/kernel/cpu/intel_rdt_schemata.c b/arch/x86/kernel/cpu/intel_rdt_schemata.c
index 8594db455aa1..91dc3d9a00e2 100644
--- a/arch/x86/kernel/cpu/intel_rdt_schemata.c
+++ b/arch/x86/kernel/cpu/intel_rdt_schemata.c
@@ -37,17 +37,18 @@
 static bool cbm_validate(unsigned long var, struct rdt_resource *r)
 {
 	unsigned long first_bit, zero_bit;
+	unsigned int cbm_len = r->cache.cbm_len;
 
 	if (var == 0 || var > r->max_cbm)
 		return false;
 
-	first_bit = find_first_bit(&var, r->cbm_len);
-	zero_bit = find_next_zero_bit(&var, r->cbm_len, first_bit);
+	first_bit = find_first_bit(&var, cbm_len);
+	zero_bit = find_next_zero_bit(&var, cbm_len, first_bit);
 
-	if (find_next_bit(&var, r->cbm_len, zero_bit) < r->cbm_len)
+	if (find_next_bit(&var, cbm_len, zero_bit) < cbm_len)
 		return false;
 
-	if ((zero_bit - first_bit) < r->min_cbm_bits)
+	if ((zero_bit - first_bit) < r->cache.min_cbm_bits)
 		return false;
 	return true;
 }
