scsi: qla2xxx: don't include <generated/utsrelease.h>

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: don't include <generated/utsrelease.h> (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 94.00%
commit-author Johannes Berg <johannes.berg@intel.com>
commit 49541a04b12ff0f4086c41d71ee5d3000d64a387
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/49541a04.failed

There's no need to use the static UTS_RELEASE string, since
utsname()->release contains the same.

This avoids rebuilding this file for every change of the release string.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 49541a04b12ff0f4086c41d71ee5d3000d64a387)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,00ae1f4090e2..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -28,8 -25,8 +28,7 @@@
  
  #include <linux/module.h>
  #include <linux/moduleparam.h>
- #include <generated/utsrelease.h>
  #include <linux/utsname.h>
 -#include <linux/vmalloc.h>
  #include <linux/init.h>
  #include <linux/list.h>
  #include <linux/slab.h>
@@@ -1715,20 -1878,19 +1714,20 @@@ static void tcm_qla2xxx_npiv_drop_lport
  }
  
  
 -static ssize_t tcm_qla2xxx_wwn_version_show(struct config_item *item,
 -		char *page)
 +static ssize_t tcm_qla2xxx_wwn_show_attr_version(
 +	struct target_fabric_configfs *tf,
 +	char *page)
  {
  	return sprintf(page,
- 	    "TCM QLOGIC QLA2XXX NPIV capable fabric module %s on %s/%s on "
- 	    UTS_RELEASE"\n", QLA2XXX_VERSION, utsname()->sysname,
- 	    utsname()->machine);
+ 	    "TCM QLOGIC QLA2XXX NPIV capable fabric module %s on %s/%s on %s\n",
+ 	    QLA2XXX_VERSION, utsname()->sysname,
+ 	    utsname()->machine, utsname()->release);
  }
  
 -CONFIGFS_ATTR_RO(tcm_qla2xxx_wwn_, version);
 +TF_WWN_ATTR_RO(tcm_qla2xxx, version);
  
  static struct configfs_attribute *tcm_qla2xxx_wwn_attrs[] = {
 -	&tcm_qla2xxx_wwn_attr_version,
 +	&tcm_qla2xxx_wwn_version.attr,
  	NULL,
  };
  
@@@ -1831,89 -1986,19 +1830,98 @@@ static struct target_core_fabric_ops tc
  
  static int tcm_qla2xxx_register_configfs(void)
  {
 +	struct target_fabric_configfs *fabric, *npiv_fabric;
  	int ret;
  
++<<<<<<< HEAD
 +	pr_debug("TCM QLOGIC QLA2XXX fabric module %s on %s/%s on "
 +	    UTS_RELEASE"\n", QLA2XXX_VERSION, utsname()->sysname,
 +	    utsname()->machine);
 +	/*
 +	 * Register the top level struct config_item_type with TCM core
 +	 */
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "qla2xxx");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() failed\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup fabric->tf_ops from our local tcm_qla2xxx_ops
 +	 */
 +	fabric->tf_ops = tcm_qla2xxx_ops;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = tcm_qla2xxx_wwn_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = tcm_qla2xxx_tpg_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs =
 +						tcm_qla2xxx_tpg_attrib_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 +	/*
 +	 * Register the fabric for use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() failed for TCM_QLA2XXX\n");
++=======
+ 	pr_debug("TCM QLOGIC QLA2XXX fabric module %s on %s/%s on %s\n",
+ 	    QLA2XXX_VERSION, utsname()->sysname,
+ 	    utsname()->machine, utsname()->release);
+ 
+ 	ret = target_register_template(&tcm_qla2xxx_ops);
+ 	if (ret)
++>>>>>>> 49541a04b12f (scsi: qla2xxx: don't include <generated/utsrelease.h>)
  		return ret;
 +	}
 +	/*
 +	 * Setup our local pointer to *fabric
 +	 */
 +	tcm_qla2xxx_fabric_configfs = fabric;
 +	pr_debug("TCM_QLA2XXX[0] - Set fabric -> tcm_qla2xxx_fabric_configfs\n");
  
 -	ret = target_register_template(&tcm_qla2xxx_npiv_ops);
 -	if (ret)
 +	/*
 +	 * Register the top level struct config_item_type for NPIV with TCM core
 +	 */
 +	npiv_fabric = target_fabric_configfs_init(THIS_MODULE, "qla2xxx_npiv");
 +	if (IS_ERR(npiv_fabric)) {
 +		pr_err("target_fabric_configfs_init() failed\n");
 +		ret = PTR_ERR(npiv_fabric);
  		goto out_fabric;
 +	}
 +	/*
 +	 * Setup fabric->tf_ops from our local tcm_qla2xxx_npiv_ops
 +	 */
 +	npiv_fabric->tf_ops = tcm_qla2xxx_npiv_ops;
 +	/*
 +	 * Setup default attribute lists for various npiv_fabric->tf_cit_tmpl
 +	 */
 +	TF_CIT_TMPL(npiv_fabric)->tfc_wwn_cit.ct_attrs = tcm_qla2xxx_wwn_attrs;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_nacl_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(npiv_fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 +	/*
 +	 * Register the npiv_fabric for use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(npiv_fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() failed for TCM_QLA2XXX\n");
 +		goto out_fabric;
 +	}
 +	/*
 +	 * Setup our local pointer to *npiv_fabric
 +	 */
 +	tcm_qla2xxx_npiv_fabric_configfs = npiv_fabric;
 +	pr_debug("TCM_QLA2XXX[0] - Set fabric -> tcm_qla2xxx_npiv_fabric_configfs\n");
  
  	tcm_qla2xxx_free_wq = alloc_workqueue("tcm_qla2xxx_free",
  						WQ_MEM_RECLAIM, 0);
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
