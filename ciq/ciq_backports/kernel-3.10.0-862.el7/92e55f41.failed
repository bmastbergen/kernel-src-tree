tcp: don't annotate mark on control socket from tcp_v6_send_response()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Pablo Neira <pablo@netfilter.org>
commit 92e55f412cffd016cc245a74278cb4d7b89bb3bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/92e55f41.failed

Unlike ipv4, this control socket is shared by all cpus so we cannot use
it as scratchpad area to annotate the mark that we pass to ip6_xmit().

Add a new parameter to ip6_xmit() to indicate the mark. The SCTP socket
family caches the flowi6 structure in the sctp_transport structure, so
we cannot use to carry the mark unless we later on reset it back, which
I discarded since it looks ugly to me.

Fixes: bf99b4ded5f8 ("tcp: fix mark propagation with fwmark_reflect enabled")
	Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92e55f412cffd016cc245a74278cb4d7b89bb3bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ipv6.h
#	net/dccp/ipv6.c
#	net/ipv6/ip6_output.c
#	net/ipv6/tcp_ipv6.c
diff --cc include/net/ipv6.h
index cc38d71d43a3,7afe991e900e..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -763,8 -870,8 +763,13 @@@ int ip6_rcv_finish(struct sock *sk, str
  /*
   *	upper-layer output functions
   */
++<<<<<<< HEAD
 +int ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 +	     struct ipv6_txoptions *opt, int tclass);
++=======
+ int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
+ 	     __u32 mark, struct ipv6_txoptions *opt, int tclass);
++>>>>>>> 92e55f412cff (tcp: don't annotate mark on control socket from tcp_v6_send_response())
  
  int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);
  
diff --cc net/dccp/ipv6.c
index c29aaaa58615,c4e879c02186..000000000000
--- a/net/dccp/ipv6.c
+++ b/net/dccp/ipv6.c
@@@ -260,8 -224,10 +260,15 @@@ static int dccp_v6_send_response(struc
  							 &ireq->ir_v6_rmt_addr);
  		fl6.daddr = ireq->ir_v6_rmt_addr;
  		rcu_read_lock();
++<<<<<<< HEAD
 +		err = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
 +			       np->tclass);
++=======
+ 		opt = ireq->ipv6_opt;
+ 		if (!opt)
+ 			opt = rcu_dereference(np->opt);
+ 		err = ip6_xmit(sk, skb, &fl6, sk->sk_mark, opt, np->tclass);
++>>>>>>> 92e55f412cff (tcp: don't annotate mark on control socket from tcp_v6_send_response())
  		rcu_read_unlock();
  		err = net_xmit_eval(err);
  	}
@@@ -314,9 -281,9 +321,15 @@@ static void dccp_v6_ctl_send_reset(stru
  	dst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);
  	if (!IS_ERR(dst)) {
  		skb_dst_set(skb, dst);
++<<<<<<< HEAD
 +		ip6_xmit(ctl_sk, skb, &fl6, NULL, 0);
 +		DCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);
 +		DCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);
++=======
+ 		ip6_xmit(ctl_sk, skb, &fl6, 0, NULL, 0);
+ 		DCCP_INC_STATS(DCCP_MIB_OUTSEGS);
+ 		DCCP_INC_STATS(DCCP_MIB_OUTRSTS);
++>>>>>>> 92e55f412cff (tcp: don't annotate mark on control socket from tcp_v6_send_response())
  		return;
  	}
  
diff --cc net/ipv6/ip6_output.c
index b1ac560a24f7,2c0df09e9036..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -151,14 -166,16 +151,19 @@@ int ip6_output(struct sock *sk, struct 
  }
  
  /*
 - * xmit an sk_buff (used by TCP, SCTP and DCCP)
 - * Note : socket lock is not held for SYNACK packets, but might be modified
 - * by calls to skb_set_owner_w() and ipv6_local_error(),
 - * which are using proper atomic operations or spinlocks.
 + *	xmit an sk_buff (used by TCP, SCTP and DCCP)
   */
++<<<<<<< HEAD
 +
 +int ip6_xmit(struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 +	     struct ipv6_txoptions *opt, int tclass)
++=======
+ int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
+ 	     __u32 mark, struct ipv6_txoptions *opt, int tclass)
++>>>>>>> 92e55f412cff (tcp: don't annotate mark on control socket from tcp_v6_send_response())
  {
  	struct net *net = sock_net(sk);
 -	const struct ipv6_pinfo *np = inet6_sk(sk);
 +	struct ipv6_pinfo *np = inet6_sk(sk);
  	struct in6_addr *first_hop = &fl6->daddr;
  	struct dst_entry *dst = skb_dst(skb);
  	struct ipv6hdr *hdr;
@@@ -216,8 -238,9 +221,8 @@@
  	hdr->saddr = fl6->saddr;
  	hdr->daddr = *first_hop;
  
 -	skb->protocol = htons(ETH_P_IPV6);
  	skb->priority = sk->sk_priority;
- 	skb->mark = sk->sk_mark;
+ 	skb->mark = mark;
  
  	mtu = dst_mtu(dst);
  	if ((skb->len <= mtu) || skb->ignore_df || skb_is_gso(skb)) {
diff --cc net/ipv6/tcp_ipv6.c
index e43484357cd2,cb8929681dc7..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -498,10 -462,14 +498,17 @@@ static int tcp_v6_send_synack(struct so
  				    &ireq->ir_v6_rmt_addr);
  
  		fl6->daddr = ireq->ir_v6_rmt_addr;
 -		if (np->repflow && ireq->pktopts)
 -			fl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));
 -
 +		skb_set_queue_mapping(skb, queue_mapping);
  		rcu_read_lock();
++<<<<<<< HEAD
 +		err = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),
 +			       np->tclass);
++=======
+ 		opt = ireq->ipv6_opt;
+ 		if (!opt)
+ 			opt = rcu_dereference(np->opt);
+ 		err = ip6_xmit(sk, skb, fl6, sk->sk_mark, opt, np->tclass);
++>>>>>>> 92e55f412cff (tcp: don't annotate mark on control socket from tcp_v6_send_response())
  		rcu_read_unlock();
  		err = net_xmit_eval(err);
  	}
@@@ -875,11 -840,10 +882,16 @@@ static void tcp_v6_send_response(struc
  	dst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);
  	if (!IS_ERR(dst)) {
  		skb_dst_set(buff, dst);
++<<<<<<< HEAD
 +		ctl_sk->sk_mark = fl6.flowi6_mark;
 +		ip6_xmit(ctl_sk, buff, &fl6, NULL, tclass);
 +		TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
++=======
+ 		ip6_xmit(ctl_sk, buff, &fl6, fl6.flowi6_mark, NULL, tclass);
+ 		TCP_INC_STATS(net, TCP_MIB_OUTSEGS);
++>>>>>>> 92e55f412cff (tcp: don't annotate mark on control socket from tcp_v6_send_response())
  		if (rst)
 -			TCP_INC_STATS(net, TCP_MIB_OUTRSTS);
 +			TCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);
  		return;
  	}
  
* Unmerged path include/net/ipv6.h
* Unmerged path net/dccp/ipv6.c
diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c
index ef7a87510b54..1bbd44b1533a 100644
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -242,7 +242,7 @@ int inet6_csk_xmit(struct sk_buff *skb, struct flowi *fl_unused)
 	/* Restore final destination back after routing done */
 	fl6.daddr = sk->sk_v6_daddr;
 
-	res = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
+	res = ip6_xmit(sk, skb, &fl6, sk->sk_mark, rcu_dereference(np->opt),
 		       np->tclass);
 	rcu_read_unlock();
 	return res;
* Unmerged path net/ipv6/ip6_output.c
* Unmerged path net/ipv6/tcp_ipv6.c
diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index 04d14042ba6c..d3411eb0822e 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -229,7 +229,8 @@ static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
 
 	rcu_read_lock();
-	res = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt), np->tclass);
+	res = ip6_xmit(sk, skb, fl6, sk->sk_mark, rcu_dereference(np->opt),
+		       np->tclass);
 	rcu_read_unlock();
 	return res;
 }
