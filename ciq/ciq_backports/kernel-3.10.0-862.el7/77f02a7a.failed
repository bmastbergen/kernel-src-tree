nvme: factor request completion code into a common helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] factor request completion code into a common helper (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 94.44%
commit-author Christoph Hellwig <hch@lst.de>
commit 77f02a7acd7654cd5944f2120831d1eace94b343
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/77f02a7a.failed

This avoids duplicating the logic four times, and it also allows to keep
some helpers static in core.c or just opencode them.

Note that this loses printing the aborted status on completions in the
PCI driver as that uses a data structure not available any more.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 77f02a7acd7654cd5944f2120831d1eace94b343)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/fc.c
#	drivers/nvme/host/pci.c
#	drivers/nvme/host/rdma.c
#	drivers/nvme/target/loop.c
diff --cc drivers/nvme/host/core.c
index bd223cb63595,3c908e1bc903..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -194,18 -234,6 +223,21 @@@ fail
  	return NULL;
  }
  
++<<<<<<< HEAD
 +void nvme_requeue_req(struct request *req)
 +{
 +	unsigned long flags;
 +
 +	blk_mq_requeue_request(req, false);
 +	spin_lock_irqsave(req->q->queue_lock, flags);
 +	if (!blk_queue_stopped(req->q))
 +		blk_mq_kick_requeue_list(req->q);
 +	spin_unlock_irqrestore(req->q->queue_lock, flags);
 +}
 +EXPORT_SYMBOL_GPL(nvme_requeue_req);
 +
++=======
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  struct request *nvme_alloc_request(struct request_queue *q,
  		struct nvme_command *cmd, unsigned int flags, int qid)
  {
diff --cc drivers/nvme/host/fc.c
index c60930e00631,fc42172c796a..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1893,24 -1930,8 +1893,27 @@@ nvme_fc_complete_rq(struct request *rq
  	state = atomic_xchg(&op->state, FCPOP_STATE_IDLE);
  
  	nvme_cleanup_cmd(rq);
- 
  	nvme_fc_unmap_data(ctrl, rq, op);
++<<<<<<< HEAD
 +
 +	if (unlikely(rq->errors)) {
 +		if (nvme_req_needs_retry(rq, rq->errors)) {
 +			rq->retries++;
 +			nvme_requeue_req(rq);
 +			goto put_ctrl;
 +		}
 +
 +		if (rq->cmd_type == REQ_TYPE_DRV_PRIV)
 +			error = rq->errors;
 +		else
 +			error = nvme_error_status(rq->errors);
 +	}
 +
 +	blk_mq_end_request(rq, error);
 +put_ctrl:
++=======
+ 	nvme_complete_rq(rq);
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  	nvme_fc_ctrl_put(ctrl);
  
  }
diff --cc drivers/nvme/host/pci.c
index 20d5219150f0,9e686a67d93b..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -555,34 -626,14 +555,37 @@@ out
  	return ret;
  }
  
- static void nvme_complete_rq(struct request *req)
+ static void nvme_pci_complete_rq(struct request *req)
  {
  	struct nvme_iod *iod = blk_mq_rq_to_pdu(req);
- 	struct nvme_dev *dev = iod->nvmeq->dev;
- 	int error = 0;
  
++<<<<<<< HEAD
 +	nvme_unmap_data(dev, req);
 +
 +	if (unlikely(req->errors)) {
 +		if (nvme_req_needs_retry(req, req->errors)) {
 +			req->retries++;
 +			nvme_requeue_req(req);
 +			return;
 +		}
 +
 +		if (req->cmd_type == REQ_TYPE_DRV_PRIV)
 +			error = req->errors;
 +		else
 +			error = nvme_error_status(req->errors);
 +	}
 +
 +	if (unlikely(iod->aborted)) {
 +		dev_warn(dev->ctrl.device,
 +			"completing aborted command with status: %04x\n",
 +			req->errors);
 +	}
 +
 +	blk_mq_end_request(req, error);
++=======
+ 	nvme_unmap_data(iod->nvmeq->dev, req);
+ 	nvme_complete_rq(req);
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  }
  
  /* We read the CQE phase first to check if the rest of the entry is valid */
@@@ -1034,21 -1107,18 +1037,29 @@@ static int nvme_create_queue(struct nvm
  	return result;
  }
  
 -static const struct blk_mq_ops nvme_mq_admin_ops = {
 +
 +static struct blk_mq_ops nvme_mq_admin_ops = {
  	.queue_rq	= nvme_queue_rq,
++<<<<<<< HEAD
 +	.complete	= nvme_complete_rq,
 +	.map_queue	= blk_mq_map_queue,
++=======
+ 	.complete	= nvme_pci_complete_rq,
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  	.init_hctx	= nvme_admin_init_hctx,
  	.exit_hctx      = nvme_admin_exit_hctx,
  	.init_request	= nvme_admin_init_request,
  	.timeout	= nvme_timeout,
  };
  
 -static const struct blk_mq_ops nvme_mq_ops = {
 +static struct blk_mq_ops nvme_mq_ops = {
  	.queue_rq	= nvme_queue_rq,
++<<<<<<< HEAD
 +	.complete	= nvme_complete_rq,
 +	.map_queue	= blk_mq_map_queue,
++=======
+ 	.complete	= nvme_pci_complete_rq,
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  	.init_hctx	= nvme_init_hctx,
  	.init_request	= nvme_init_request,
  	.map_queues	= nvme_pci_map_queues,
diff --cc drivers/nvme/host/rdma.c
index d26486b975ca,4aae363943e3..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -1501,31 -1496,36 +1501,34 @@@ err
  static void nvme_rdma_complete_rq(struct request *rq)
  {
  	struct nvme_rdma_request *req = blk_mq_rq_to_pdu(rq);
- 	struct nvme_rdma_queue *queue = req->queue;
- 	int error = 0;
  
++<<<<<<< HEAD
 +	nvme_rdma_unmap_data(queue, rq);
 +
 +	if (unlikely(rq->errors)) {
 +		if (nvme_req_needs_retry(rq, rq->errors)) {
 +			rq->retries++;
 +			nvme_requeue_req(rq);
 +			return;
 +		}
 +
 +		if (rq->cmd_type == REQ_TYPE_DRV_PRIV)
 +			error = rq->errors;
 +		else
 +			error = nvme_error_status(rq->errors);
 +	}
 +
 +	blk_mq_end_request(rq, error);
++=======
+ 	nvme_rdma_unmap_data(req->queue, rq);
+ 	nvme_complete_rq(rq);
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  }
  
 -static const struct blk_mq_ops nvme_rdma_mq_ops = {
 +static struct blk_mq_ops nvme_rdma_mq_ops = {
  	.queue_rq	= nvme_rdma_queue_rq,
  	.complete	= nvme_rdma_complete_rq,
 +	.map_queue	= blk_mq_map_queue,
  	.init_request	= nvme_rdma_init_request,
  	.exit_request	= nvme_rdma_exit_request,
  	.reinit_request	= nvme_rdma_reinit_request,
diff --cc drivers/nvme/target/loop.c
index afa73c669791,33b431e4eec3..000000000000
--- a/drivers/nvme/target/loop.c
+++ b/drivers/nvme/target/loop.c
@@@ -95,22 -94,7 +95,25 @@@ static void nvme_loop_complete_rq(struc
  
  	nvme_cleanup_cmd(req);
  	sg_free_table_chained(&iod->sg_table, true);
++<<<<<<< HEAD
 +
 +	if (unlikely(req->errors)) {
 +		if (nvme_req_needs_retry(req, req->errors)) {
 +			req->retries++;
 +			nvme_requeue_req(req);
 +			return;
 +		}
 +
 +		if (req->cmd_type == REQ_TYPE_DRV_PRIV)
 +			error = req->errors;
 +		else
 +			error = nvme_error_status(req->errors);
 +	}
 +
 +	blk_mq_end_request(req, error);
++=======
+ 	nvme_complete_rq(req);
++>>>>>>> 77f02a7acd76 (nvme: factor request completion code into a common helper)
  }
  
  static struct blk_mq_tags *nvme_loop_tagset(struct nvme_loop_queue *queue)
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/fc.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index edb3488b21b7..c07c401675a9 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -245,13 +245,7 @@ static inline int nvme_error_status(u16 status)
 	}
 }
 
-static inline bool nvme_req_needs_retry(struct request *req, u16 status)
-{
-	return !(status & NVME_SC_DNR || blk_noretry_request(req)) &&
-		(jiffies - req->start_time) < req->timeout &&
-		req->retries < nvme_max_retries;
-}
-
+void nvme_complete_rq(struct request *req);
 void nvme_cancel_request(struct request *req, void *data, bool reserved);
 bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
 		enum nvme_ctrl_state new_state);
@@ -283,7 +277,6 @@ void nvme_start_freeze(struct nvme_ctrl *ctrl);
 #define NVME_QID_ANY -1
 struct request *nvme_alloc_request(struct request_queue *q,
 		struct nvme_command *cmd, unsigned int flags, int qid);
-void nvme_requeue_req(struct request *req);
 int nvme_setup_cmd(struct nvme_ns *ns, struct request *req,
 		struct nvme_command *cmd);
 int nvme_submit_sync_cmd(struct request_queue *q, struct nvme_command *cmd,
* Unmerged path drivers/nvme/host/pci.c
* Unmerged path drivers/nvme/host/rdma.c
* Unmerged path drivers/nvme/target/loop.c
