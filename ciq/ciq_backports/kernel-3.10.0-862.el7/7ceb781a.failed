nfp: Initialize RX and TX ring 64-bit stats seqcounts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Fainelli <f.fainelli@gmail.com>
commit 7ceb781a1aa0356086e2bdc76bcd953fcb7ac377
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7ceb781a.failed

On 32-bit hosts and with CONFIG_DEBUG_LOCK_ALLOC we should be seeing a
lockdep splat indicating this seqcount is not correctly initialized, fix
that.

Fixes: 4c3523623dc0 ("net: add driver for Netronome NFP4000/NFP6000 NIC VFs")
	Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7ceb781a1aa0356086e2bdc76bcd953fcb7ac377)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,4631ca8b8eb2..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -466,6 -512,8 +466,11 @@@ nfp_net_tx_ring_init(struct nfp_net_tx_
  
  	tx_ring->idx = idx;
  	tx_ring->r_vec = r_vec;
++<<<<<<< HEAD
++=======
+ 	tx_ring->is_xdp = is_xdp;
+ 	u64_stats_init(&tx_ring->r_vec->tx_sync);
++>>>>>>> 7ceb781a1aa0 (nfp: Initialize RX and TX ring 64-bit stats seqcounts)
  
  	tx_ring->qcidx = tx_ring->idx * nn->stride_tx;
  	tx_ring->qcp_q = nn->tx_bar + NFP_QCP_QUEUE_OFF(tx_ring->qcidx);
@@@ -485,40 -533,10 +490,41 @@@ nfp_net_rx_ring_init(struct nfp_net_rx_
  
  	rx_ring->idx = idx;
  	rx_ring->r_vec = r_vec;
+ 	u64_stats_init(&rx_ring->r_vec->rx_sync);
  
  	rx_ring->fl_qcidx = rx_ring->idx * nn->stride_rx;
 +	rx_ring->rx_qcidx = rx_ring->fl_qcidx + (nn->stride_rx - 1);
 +
  	rx_ring->qcp_fl = nn->rx_bar + NFP_QCP_QUEUE_OFF(rx_ring->fl_qcidx);
 +	rx_ring->qcp_rx = nn->rx_bar + NFP_QCP_QUEUE_OFF(rx_ring->rx_qcidx);
 +}
 +
 +/**
 + * nfp_net_vecs_init() - Assign IRQs and setup rvecs.
 + * @netdev:   netdev structure
 + */
 +static void nfp_net_vecs_init(struct net_device *netdev)
 +{
 +	struct nfp_net *nn = netdev_priv(netdev);
 +	struct nfp_net_r_vector *r_vec;
 +	int r;
 +
 +	nn->lsc_handler = nfp_net_irq_lsc;
 +	nn->exn_handler = nfp_net_irq_exn;
 +
 +	for (r = 0; r < nn->max_r_vecs; r++) {
 +		struct msix_entry *entry;
 +
 +		entry = &nn->irq_entries[NFP_NET_NON_Q_VECTORS + r];
 +
 +		r_vec = &nn->r_vecs[r];
 +		r_vec->nfp_net = nn;
 +		r_vec->handler = nfp_net_irq_rxtx;
 +		r_vec->irq_entry = entry->entry;
 +		r_vec->irq_vector = entry->vector;
 +
 +		cpumask_set_cpu(r, &r_vec->affinity_mask);
 +	}
  }
  
  /**
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
