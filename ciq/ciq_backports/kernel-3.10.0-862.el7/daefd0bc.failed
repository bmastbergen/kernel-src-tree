perf stat: Add support to measure SMI cost

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kan Liang <Kan.liang@intel.com>
commit daefd0bc0bd28cea2e6b2f3e1a9da005cd4f58fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/daefd0bc.failed

Implementing a new --smi-cost mode in perf stat to measure SMI cost.

During the measurement, the /sys/device/cpu/freeze_on_smi will be set.

The measurement can be done with one counter (unhalted core cycles), and
two free running MSR counters (IA32_APERF and SMI_COUNT).

In practice, the percentages of SMI core cycles should be more useful
than absolute value. So the output will be the percentage of SMI core
cycles and SMI#. metric_only will be set by default.

SMI cycles% = (aperf - unhalted core cycles) / aperf

Here is an example output.

 Performance counter stats for 'sudo echo ':

SMI cycles%          SMI#
    0.1%              1

       0.010858678 seconds time elapsed

Users who wants to get the actual value can apply additional
--no-metric-only.

	Signed-off-by: Kan Liang <Kan.liang@intel.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Robert Elliott <elliott@hpe.com>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1495825538-5230-3-git-send-email-kan.liang@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit daefd0bc0bd28cea2e6b2f3e1a9da005cd4f58fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-stat.txt
#	tools/perf/util/stat-shadow.c
diff --cc tools/perf/Documentation/perf-stat.txt
index 978548138624,698076313606..000000000000
--- a/tools/perf/Documentation/perf-stat.txt
+++ b/tools/perf/Documentation/perf-stat.txt
@@@ -236,6 -236,23 +236,26 @@@ To interpret the results it is usually 
  CPUs the workload runs on. If needed the CPUs can be forced using
  taskset.
  
++<<<<<<< HEAD
++=======
+ --no-merge::
+ Do not merge results from same PMUs.
+ 
+ --smi-cost::
+ Measure SMI cost if msr/aperf/ and msr/smi/ events are supported.
+ 
+ During the measurement, the /sys/device/cpu/freeze_on_smi will be set to
+ freeze core counters on SMI.
+ The aperf counter will not be effected by the setting.
+ The cost of SMI can be measured by (aperf - unhalted core cycles).
+ 
+ In practice, the percentages of SMI cycles is very useful for performance
+ oriented analysis. --metric_only will be applied by default.
+ The output is SMI cycles%, equals to (aperf - unhalted core cycles) / aperf
+ 
+ Users who wants to get the actual value can apply --no-metric-only.
+ 
++>>>>>>> daefd0bc0bd2 (perf stat: Add support to measure SMI cost)
  EXAMPLES
  --------
  
diff --cc tools/perf/util/stat-shadow.c
index 8a2bbd2a4d82,719d6cb86952..000000000000
--- a/tools/perf/util/stat-shadow.c
+++ b/tools/perf/util/stat-shadow.c
@@@ -41,6 -44,9 +41,12 @@@ static struct stats runtime_topdown_slo
  static struct stats runtime_topdown_slots_retired[NUM_CTX][MAX_NR_CPUS];
  static struct stats runtime_topdown_fetch_bubbles[NUM_CTX][MAX_NR_CPUS];
  static struct stats runtime_topdown_recovery_bubbles[NUM_CTX][MAX_NR_CPUS];
++<<<<<<< HEAD
++=======
+ static struct stats runtime_smi_num_stats[NUM_CTX][MAX_NR_CPUS];
+ static struct stats runtime_aperf_stats[NUM_CTX][MAX_NR_CPUS];
+ static struct rblist runtime_saved_values;
++>>>>>>> daefd0bc0bd2 (perf stat: Add support to measure SMI cost)
  static bool have_frontend_stalled;
  
  struct stats walltime_nsecs_stats;
@@@ -92,6 -159,17 +98,20 @@@ void perf_stat__reset_shadow_stats(void
  	memset(runtime_topdown_slots_issued, 0, sizeof(runtime_topdown_slots_issued));
  	memset(runtime_topdown_fetch_bubbles, 0, sizeof(runtime_topdown_fetch_bubbles));
  	memset(runtime_topdown_recovery_bubbles, 0, sizeof(runtime_topdown_recovery_bubbles));
++<<<<<<< HEAD
++=======
+ 	memset(runtime_smi_num_stats, 0, sizeof(runtime_smi_num_stats));
+ 	memset(runtime_aperf_stats, 0, sizeof(runtime_aperf_stats));
+ 
+ 	next = rb_first(&runtime_saved_values.entries);
+ 	while (next) {
+ 		pos = next;
+ 		next = rb_next(pos);
+ 		memset(&container_of(pos, struct saved_value, rb_node)->stats,
+ 		       0,
+ 		       sizeof(struct stats));
+ 	}
++>>>>>>> daefd0bc0bd2 (perf stat: Add support to measure SMI cost)
  }
  
  /*
@@@ -143,6 -221,16 +163,19 @@@ void perf_stat__update_shadow_stats(str
  		update_stats(&runtime_dtlb_cache_stats[ctx][cpu], count[0]);
  	else if (perf_evsel__match(counter, HW_CACHE, HW_CACHE_ITLB))
  		update_stats(&runtime_itlb_cache_stats[ctx][cpu], count[0]);
++<<<<<<< HEAD
++=======
+ 	else if (perf_stat_evsel__is(counter, SMI_NUM))
+ 		update_stats(&runtime_smi_num_stats[ctx][cpu], count[0]);
+ 	else if (perf_stat_evsel__is(counter, APERF))
+ 		update_stats(&runtime_aperf_stats[ctx][cpu], count[0]);
+ 
+ 	if (counter->collect_stat) {
+ 		struct saved_value *v = saved_value_lookup(counter, cpu, ctx,
+ 							   true);
+ 		update_stats(&v->stats, count[0]);
+ 	}
++>>>>>>> daefd0bc0bd2 (perf stat: Add support to measure SMI cost)
  }
  
  /* used for get_ratio_color() */
* Unmerged path tools/perf/Documentation/perf-stat.txt
diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c
index ee5dd60db819..3d20a9b4bee3 100644
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@ -78,6 +78,7 @@
 #define DEFAULT_SEPARATOR	" "
 #define CNTR_NOT_SUPPORTED	"<not supported>"
 #define CNTR_NOT_COUNTED	"<not counted>"
+#define FREEZE_ON_SMI_PATH	"devices/cpu/freeze_on_smi"
 
 static void print_counters(struct timespec *ts, int argc, const char **argv);
 
@@ -114,6 +115,14 @@ static const char * topdown_attrs[] = {
 	NULL,
 };
 
+static const char *smi_cost_attrs = {
+	"{"
+	"msr/aperf/,"
+	"msr/smi/,"
+	"cycles"
+	"}"
+};
+
 static struct perf_evlist	*evsel_list;
 
 static struct target target = {
@@ -129,6 +138,8 @@ static bool			null_run			=  false;
 static int			detailed_run			=  0;
 static bool			transaction_run;
 static bool			topdown_run			= false;
+static bool			smi_cost			= false;
+static bool			smi_reset			= false;
 static bool			big_num				=  true;
 static int			big_num_opt			=  -1;
 static const char		*csv_sep			= NULL;
@@ -1742,6 +1753,8 @@ static const struct option stat_options[] = {
 			"Only print computed metrics. No raw values", enable_metric_only),
 	OPT_BOOLEAN(0, "topdown", &topdown_run,
 			"measure topdown level 1 statistics"),
+	OPT_BOOLEAN(0, "smi-cost", &smi_cost,
+			"measure SMI cost"),
 	OPT_END()
 };
 
@@ -2120,6 +2133,39 @@ static int add_default_attributes(void)
 		return 0;
 	}
 
+	if (smi_cost) {
+		int smi;
+
+		if (sysfs__read_int(FREEZE_ON_SMI_PATH, &smi) < 0) {
+			fprintf(stderr, "freeze_on_smi is not supported.\n");
+			return -1;
+		}
+
+		if (!smi) {
+			if (sysfs__write_int(FREEZE_ON_SMI_PATH, 1) < 0) {
+				fprintf(stderr, "Failed to set freeze_on_smi.\n");
+				return -1;
+			}
+			smi_reset = true;
+		}
+
+		if (pmu_have_event("msr", "aperf") &&
+		    pmu_have_event("msr", "smi")) {
+			if (!force_metric_only)
+				metric_only = true;
+			err = parse_events(evsel_list, smi_cost_attrs, NULL);
+		} else {
+			fprintf(stderr, "To measure SMI cost, it needs "
+				"msr/aperf/, msr/smi/ and cpu/cycles/ support\n");
+			return -1;
+		}
+		if (err) {
+			fprintf(stderr, "Cannot set up SMI cost events\n");
+			return -1;
+		}
+		return 0;
+	}
+
 	if (topdown_run) {
 		char *str = NULL;
 		bool warn = false;
@@ -2701,6 +2747,9 @@ int cmd_stat(int argc, const char **argv)
 	perf_stat__exit_aggr_mode();
 	perf_evlist__free_stats(evsel_list);
 out:
+	if (smi_cost && smi_reset)
+		sysfs__write_int(FREEZE_ON_SMI_PATH, 0);
+
 	perf_evlist__delete(evsel_list);
 	return status;
 }
* Unmerged path tools/perf/util/stat-shadow.c
diff --git a/tools/perf/util/stat.c b/tools/perf/util/stat.c
index 39345c2ddfc2..238f7c78e2b7 100644
--- a/tools/perf/util/stat.c
+++ b/tools/perf/util/stat.c
@@ -84,6 +84,8 @@ static const char *id_str[PERF_STAT_EVSEL_ID__MAX] = {
 	ID(TOPDOWN_SLOTS_RETIRED, topdown-slots-retired),
 	ID(TOPDOWN_FETCH_BUBBLES, topdown-fetch-bubbles),
 	ID(TOPDOWN_RECOVERY_BUBBLES, topdown-recovery-bubbles),
+	ID(SMI_NUM, msr/smi/),
+	ID(APERF, msr/aperf/),
 };
 #undef ID
 
diff --git a/tools/perf/util/stat.h b/tools/perf/util/stat.h
index c29bb94c48a4..c3be07da1e59 100644
--- a/tools/perf/util/stat.h
+++ b/tools/perf/util/stat.h
@@ -22,6 +22,8 @@ enum perf_stat_evsel_id {
 	PERF_STAT_EVSEL_ID__TOPDOWN_SLOTS_RETIRED,
 	PERF_STAT_EVSEL_ID__TOPDOWN_FETCH_BUBBLES,
 	PERF_STAT_EVSEL_ID__TOPDOWN_RECOVERY_BUBBLES,
+	PERF_STAT_EVSEL_ID__SMI_NUM,
+	PERF_STAT_EVSEL_ID__APERF,
 	PERF_STAT_EVSEL_ID__MAX,
 };
 
