gpio/pinctrl: sunxi: stop poking around in private vars

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 6cee3821e4e4bd6e6cdf0870b6c72d455460bd39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6cee3821.failed

This kind of hacks disturbs the refactoring of the gpiolib.

The descriptor table belongs to the gpiolib, if we want to know
something about something in it, use or define the proper accessor
functions. Let's add this gpiochip_lins_is_irq() to do what the
sunxi driver is trying at so we can privatize the descriptors
properly.

	Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
	Cc: Chen-Yu Tsai <wens@csie.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 6cee3821e4e4bd6e6cdf0870b6c72d455460bd39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/sunxi/pinctrl-sunxi.c
#	include/linux/gpio/driver.h
diff --cc include/linux/gpio/driver.h
index e61dc96b3e98,41c6144c473b..000000000000
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@@ -145,62 -206,39 +145,68 @@@ extern struct gpio_chip *gpiochip_find(
  			      int (*match)(struct gpio_chip *chip, void *data));
  
  /* lock/unlock as IRQ */
++<<<<<<< HEAD
 +int gpiod_lock_as_irq(struct gpio_desc *desc);
 +void gpiod_unlock_as_irq(struct gpio_desc *desc);
++=======
+ int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
+ void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
+ bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
++>>>>>>> 6cee3821e4e4 (gpio/pinctrl: sunxi: stop poking around in private vars)
  
 -/* get driver data */
 -static inline void *gpiochip_get_data(struct gpio_chip *chip)
 -{
 -	return chip->data;
 -}
 -
 -struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 +enum gpio_lookup_flags {
 +	GPIO_ACTIVE_HIGH = (0 << 0),
 +	GPIO_ACTIVE_LOW = (1 << 0),
 +	GPIO_OPEN_DRAIN = (1 << 1),
 +	GPIO_OPEN_SOURCE = (1 << 2),
 +};
  
 -struct bgpio_pdata {
 -	const char *label;
 -	int base;
 -	int ngpio;
 +/**
 + * struct gpiod_lookup - lookup table
 + * @chip_label: name of the chip the GPIO belongs to
 + * @chip_hwnum: hardware number (i.e. relative to the chip) of the GPIO
 + * @con_id: name of the GPIO from the device's point of view
 + * @idx: index of the GPIO in case several GPIOs share the same name
 + * @flags: mask of GPIO_* values
 + *
 + * gpiod_lookup is a lookup table for associating GPIOs to specific devices and
 + * functions using platform data.
 + */
 +struct gpiod_lookup {
 +	const char *chip_label;
 +	u16 chip_hwnum;
 +	const char *con_id;
 +	unsigned int idx;
 +	enum gpio_lookup_flags flags;
  };
  
 -#if IS_ENABLED(CONFIG_GPIO_GENERIC)
 +struct gpiod_lookup_table {
 +	struct list_head list;
 +	const char *dev_id;
 +	struct gpiod_lookup table[];
 +};
  
 -int bgpio_init(struct gpio_chip *gc, struct device *dev,
 -	       unsigned long sz, void __iomem *dat, void __iomem *set,
 -	       void __iomem *clr, void __iomem *dirout, void __iomem *dirin,
 -	       unsigned long flags);
 +/*
 + * Simple definition of a single GPIO under a con_id
 + */
 +#define GPIO_LOOKUP(_chip_label, _chip_hwnum, _con_id, _flags) \
 +	GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _con_id, 0, _flags)
  
 -#define BGPIOF_BIG_ENDIAN		BIT(0)
 -#define BGPIOF_UNREADABLE_REG_SET	BIT(1) /* reg_set is unreadable */
 -#define BGPIOF_UNREADABLE_REG_DIR	BIT(2) /* reg_dir is unreadable */
 -#define BGPIOF_BIG_ENDIAN_BYTE_ORDER	BIT(3)
 -#define BGPIOF_READ_OUTPUT_REG_SET	BIT(4) /* reg_set stores output value */
 -#define BGPIOF_NO_OUTPUT		BIT(5) /* only input */
 +/*
 + * Use this macro if you need to have several GPIOs under the same con_id.
 + * Each GPIO needs to use a different index and can be accessed using
 + * gpiod_get_index()
 + */
 +#define GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _con_id, _idx, _flags)  \
 +{                                                                         \
 +	.chip_label = _chip_label,                                        \
 +	.chip_hwnum = _chip_hwnum,                                        \
 +	.con_id = _con_id,                                                \
 +	.idx = _idx,                                                      \
 +	.flags = _flags,                                                  \
 +}
  
 -#endif
 +void gpiod_add_lookup_table(struct gpiod_lookup_table *table);
  
  #ifdef CONFIG_GPIOLIB_IRQCHIP
  
* Unmerged path drivers/pinctrl/sunxi/pinctrl-sunxi.c
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 927a1d077837..8f7d76ba2a43 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -2556,6 +2556,15 @@ void gpio_unlock_as_irq(struct gpio_chip *chip, unsigned int offset)
 }
 EXPORT_SYMBOL_GPL(gpio_unlock_as_irq);
 
+bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset)
+{
+	if (offset >= chip->ngpio)
+		return false;
+
+	return test_bit(FLAG_USED_AS_IRQ, &chip->gpiodev->descs[offset].flags);
+}
+EXPORT_SYMBOL_GPL(gpiochip_line_is_irq);
+
 /**
  * gpiod_get_raw_value_cansleep() - return a gpio's raw value
  * @desc: gpio whose value will be returned
* Unmerged path drivers/pinctrl/sunxi/pinctrl-sunxi.c
* Unmerged path include/linux/gpio/driver.h
