i40e: restore promiscuous after reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alan Brady <alan.brady@intel.com>
commit bd5608b3223bc711a5b365f80d4e67866ac7cc44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bd5608b3.failed

After a reset we rebuild the VSIs which is going to clobber any
promiscuous settings we had before reset.  This makes it so that we
restore the promiscuous settings we had before reset.

	Signed-off-by: Alan Brady <alan.brady@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit bd5608b3223bc711a5b365f80d4e67866ac7cc44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index faab10490986,775d5a125887..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -2357,71 -2532,18 +2424,86 @@@ int i40e_sync_vsi_filters(struct i40e_v
  		bool cur_promisc;
  
  		cur_promisc = (!!(vsi->current_netdev_flags & IFF_PROMISC) ||
++<<<<<<< HEAD
 +			       test_bit(__I40E_FILTER_OVERFLOW_PROMISC,
 +					&vsi->state));
 +		if ((vsi->type == I40E_VSI_MAIN) &&
 +		    (pf->lan_veb != I40E_NO_VEB) &&
 +		    !(pf->flags & I40E_FLAG_MFP_ENABLED)) {
 +			/* set defport ON for Main VSI instead of true promisc
 +			 * this way we will get all unicast/multicast and VLAN
 +			 * promisc behavior but will not get VF or VMDq traffic
 +			 * replicated on the Main VSI.
 +			 */
 +			if (pf->cur_promisc != cur_promisc) {
 +				pf->cur_promisc = cur_promisc;
 +				if (cur_promisc)
 +					aq_ret =
 +					      i40e_aq_set_default_vsi(hw,
 +								      vsi->seid,
 +								      NULL);
 +				else
 +					aq_ret =
 +					    i40e_aq_clear_default_vsi(hw,
 +								      vsi->seid,
 +								      NULL);
 +				if (aq_ret) {
 +					retval = i40e_aq_rc_to_posix(aq_ret,
 +							hw->aq.asq_last_status);
 +					dev_info(&pf->pdev->dev,
 +						 "Set default VSI failed on %s, err %s, aq_err %s\n",
 +						 vsi_name,
 +						 i40e_stat_str(hw, aq_ret),
 +						 i40e_aq_str(hw,
 +						     hw->aq.asq_last_status));
 +				}
 +			}
 +		} else {
 +			aq_ret = i40e_aq_set_vsi_unicast_promiscuous(
 +							  hw,
 +							  vsi->seid,
 +							  cur_promisc, NULL,
 +							  true);
 +			if (aq_ret) {
 +				retval =
 +				i40e_aq_rc_to_posix(aq_ret,
 +						    hw->aq.asq_last_status);
 +				dev_info(&pf->pdev->dev,
 +					 "set unicast promisc failed on %s, err %s, aq_err %s\n",
 +					 vsi_name,
 +					 i40e_stat_str(hw, aq_ret),
 +					 i40e_aq_str(hw,
 +						     hw->aq.asq_last_status));
 +			}
 +			aq_ret = i40e_aq_set_vsi_multicast_promiscuous(
 +							  hw,
 +							  vsi->seid,
 +							  cur_promisc, NULL);
 +			if (aq_ret) {
 +				retval =
 +				i40e_aq_rc_to_posix(aq_ret,
 +						    hw->aq.asq_last_status);
 +				dev_info(&pf->pdev->dev,
 +					 "set multicast promisc failed on %s, err %s, aq_err %s\n",
 +					 vsi_name,
 +					 i40e_stat_str(hw, aq_ret),
 +					 i40e_aq_str(hw,
 +						     hw->aq.asq_last_status));
 +			}
++=======
+ 			       test_bit(__I40E_VSI_OVERFLOW_PROMISC,
+ 					vsi->state));
+ 		aq_ret = i40e_set_promiscuous(pf, cur_promisc);
+ 		if (aq_ret) {
+ 			retval = i40e_aq_rc_to_posix(aq_ret,
+ 						     hw->aq.asq_last_status);
+ 			dev_info(&pf->pdev->dev,
+ 				 "Setting promiscuous %s failed on %s, err %s aq_err %s\n",
+ 				 cur_promisc ? "on" : "off",
+ 				 vsi_name,
+ 				 i40e_stat_str(hw, aq_ret),
+ 				 i40e_aq_str(hw, hw->aq.asq_last_status));
++>>>>>>> bd5608b3223b (i40e: restore promiscuous after reset)
  		}
  	}
  out:
@@@ -7265,10 -9419,20 +7347,27 @@@ static void i40e_reset_and_rebuild(stru
  	/* restart the VSIs that were rebuilt and running before the reset */
  	i40e_pf_unquiesce_all_vsi(pf);
  
++<<<<<<< HEAD
 +	if (pf->num_alloc_vfs) {
 +		for (v = 0; v < pf->num_alloc_vfs; v++)
 +			i40e_reset_vf(&pf->vf[v], true);
 +	}
++=======
+ 	/* Release the RTNL lock before we start resetting VFs */
+ 	if (!lock_acquired)
+ 		rtnl_unlock();
+ 
+ 	/* Restore promiscuous settings */
+ 	ret = i40e_set_promiscuous(pf, pf->cur_promisc);
+ 	if (ret)
+ 		dev_warn(&pf->pdev->dev,
+ 			 "Failed to restore promiscuous setting: %s, err %s aq_err %s\n",
+ 			 pf->cur_promisc ? "on" : "off",
+ 			 i40e_stat_str(&pf->hw, ret),
+ 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
+ 
+ 	i40e_reset_all_vfs(pf, true);
++>>>>>>> bd5608b3223b (i40e: restore promiscuous after reset)
  
  	/* tell the firmware that we're starting */
  	i40e_send_version(pf);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
