net/sched: act_mirred: Implement ingress actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: act_mirred: Implement ingress actions (Ivan Vecera) [1445420]
Rebuild_FUZZ: 95.65%
commit-author Shmulik Ladkani <shmulik.ladkani@gmail.com>
commit 53592b3640019f2834701093e38272fdfd367ad8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/53592b36.failed

Up until now, 'action mirred' supported only egress actions (either
TCA_EGRESS_REDIR or TCA_EGRESS_MIRROR).

This patch implements the corresponding ingress actions
TCA_INGRESS_REDIR and TCA_INGRESS_MIRROR.

This allows attaching filters whose target is to hand matching skbs into
the rx processing of a specified device.

	Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: Eric Dumazet <eric.dumazet@gmail.com>
	Cc: Cong Wang <xiyou.wangcong@gmail.com>
	Tested-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 53592b3640019f2834701093e38272fdfd367ad8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_mirred.c
diff --cc net/sched/act_mirred.c
index 80554d23769d,2d93be6717e5..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -72,8 -111,17 +91,10 @@@ static int tcf_mirred_init(struct net *
  	switch (parm->eaction) {
  	case TCA_EGRESS_MIRROR:
  	case TCA_EGRESS_REDIR:
+ 	case TCA_INGRESS_REDIR:
+ 	case TCA_INGRESS_MIRROR:
  		break;
  	default:
 -		if (exists)
 -			tcf_hash_release(*a, bind);
  		return -EINVAL;
  	}
  	if (parm->ifindex) {
@@@ -140,10 -176,13 +161,17 @@@
  static int tcf_mirred(struct sk_buff *skb, const struct tc_action *a,
  		      struct tcf_result *res)
  {
++<<<<<<< HEAD
 +	struct tcf_mirred *m = a->priv;
++=======
+ 	struct tcf_mirred *m = to_mirred(a);
+ 	bool m_mac_header_xmit;
++>>>>>>> 53592b364001 (net/sched: act_mirred: Implement ingress actions)
  	struct net_device *dev;
  	struct sk_buff *skb2;
- 	int retval, err;
+ 	int retval, err = 0;
+ 	int m_eaction;
+ 	int mac_len;
  	u32 at;
  
  	tcf_lastuse_update(&m->tcf_tm);
@@@ -168,9 -209,19 +198,24 @@@
  	if (!skb2)
  		goto out;
  
++<<<<<<< HEAD
 +	if (!(at & AT_EGRESS)) {
 +		if (m->tcfm_ok_push)
++=======
+ 	/* If action's target direction differs than filter's direction,
+ 	 * and devices expect a mac header on xmit, then mac push/pull is
+ 	 * needed.
+ 	 */
+ 	if (at != tcf_mirred_act_direction(m_eaction) && m_mac_header_xmit) {
+ 		if (at & AT_EGRESS) {
+ 			/* caught at egress, act ingress: pull mac */
+ 			mac_len = skb_network_header(skb) - skb_mac_header(skb);
+ 			skb_pull_rcsum(skb2, mac_len);
+ 		} else {
+ 			/* caught at ingress, act egress: push mac */
++>>>>>>> 53592b364001 (net/sched: act_mirred: Implement ingress actions)
  			skb_push_rcsum(skb2, skb->mac_len);
+ 		}
  	}
  
  	/* mirror is always swallowed */
* Unmerged path net/sched/act_mirred.c
