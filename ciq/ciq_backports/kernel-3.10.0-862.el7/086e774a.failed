pipe: cap initial pipe capacity according to pipe-max-size limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael Kerrisk (man-pages) <mtk.manpages@gmail.com>
commit 086e774a57fba4695f14383c0818994c0b31da7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/086e774a.failed

This is a patch that provides behavior that is more consistent, and
probably less surprising to users. I consider the change optional, and
welcome opinions about whether it should be applied.

By default, pipes are created with a capacity of 64 kiB.  However,
/proc/sys/fs/pipe-max-size may be set smaller than this value.  In this
scenario, an unprivileged user could thus create a pipe whose initial
capacity exceeds the limit. Therefore, it seems logical to cap the
initial pipe capacity according to the value of pipe-max-size.

The test program shown earlier in this patch series can be used to
demonstrate the effect of the change brought about with this patch:

    # cat /proc/sys/fs/pipe-max-size
    1048576
    # sudo -u mtk ./test_F_SETPIPE_SZ 1
    Initial pipe capacity: 65536
    # echo 10000 > /proc/sys/fs/pipe-max-size
    # cat /proc/sys/fs/pipe-max-size
    16384
    # sudo -u mtk ./test_F_SETPIPE_SZ 1
    Initial pipe capacity: 16384
    # ./test_F_SETPIPE_SZ 1
    Initial pipe capacity: 65536

The last two executions of 'test_F_SETPIPE_SZ' show that pipe-max-size
caps the initial allocation for a new pipe for unprivileged users, but
not for privileged users.

Link: http://lkml.kernel.org/r/31dc7064-2a17-9c5b-1df1-4e3012ee992c@gmail.com
	Signed-off-by: Michael Kerrisk <mtk.manpages@gmail.com>
	Reviewed-by: Vegard Nossum <vegard.nossum@oracle.com>
	Cc: Willy Tarreau <w@1wt.eu>
	Cc: <socketpair@gmail.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Jens Axboe <axboe@fb.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 086e774a57fba4695f14383c0818994c0b31da7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/pipe.c
diff --cc fs/pipe.c
index 771f837999b4,8e0d9f26dfad..000000000000
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@@ -823,31 -620,44 +823,38 @@@ static bool too_many_pipe_buffers_hard(
  struct pipe_inode_info *alloc_pipe_info(void)
  {
  	struct pipe_inode_info *pipe;
 -	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
 -	struct user_struct *user = get_current_user();
 -	unsigned long user_bufs;
  
 -	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
 -	if (pipe == NULL)
 -		goto out_free_uid;
 +	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
 +	if (pipe) {
 +		unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
 +		struct user_struct *user = get_current_user();
  
++<<<<<<< HEAD
 +		if (!too_many_pipe_buffers_hard(user)) {
 +			if (too_many_pipe_buffers_soft(user))
 +				pipe_bufs = 1;
 +			pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);
 +		}
++=======
+ 	if (pipe_bufs * PAGE_SIZE > pipe_max_size && !capable(CAP_SYS_RESOURCE))
+ 		pipe_bufs = pipe_max_size >> PAGE_SHIFT;
+ 
+ 	user_bufs = account_pipe_buffers(user, 0, pipe_bufs);
 -
 -	if (too_many_pipe_buffers_soft(user_bufs)) {
 -		user_bufs = account_pipe_buffers(user, pipe_bufs, 1);
 -		pipe_bufs = 1;
 -	}
 -
 -	if (too_many_pipe_buffers_hard(user_bufs))
 -		goto out_revert_acct;
 -
 -	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
 -			     GFP_KERNEL_ACCOUNT);
 -
 -	if (pipe->bufs) {
 -		init_waitqueue_head(&pipe->wait);
 -		pipe->r_counter = pipe->w_counter = 1;
 -		pipe->buffers = pipe_bufs;
 -		pipe->user = user;
 -		mutex_init(&pipe->mutex);
 -		return pipe;
++>>>>>>> 086e774a57fb (pipe: cap initial pipe capacity according to pipe-max-size limit)
 +
 +		if (pipe->bufs) {
 +			init_waitqueue_head(&pipe->wait);
 +			pipe->r_counter = pipe->w_counter = 1;
 +			pipe->buffers = pipe_bufs;
 +			pipe->user = user;
 +			account_pipe_buffers(user, 0, pipe_bufs);
 +			mutex_init(&pipe->mutex);
 +			return pipe;
 +		}
 +		free_uid(user);
 +		kfree(pipe);
  	}
  
 -out_revert_acct:
 -	(void) account_pipe_buffers(user, pipe_bufs, 0);
 -	kfree(pipe);
 -out_free_uid:
 -	free_uid(user);
  	return NULL;
  }
  
* Unmerged path fs/pipe.c
