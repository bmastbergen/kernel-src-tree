qed: LL2 code relocations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 58de289807f02122ef7eca96e50365d2c1440902
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/58de2898.failed

Instead of having the OOO logic packetd, divide it with rest of code
according to establish/release flows.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 58de289807f02122ef7eca96e50365d2c1440902)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_ll2.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_ll2.c
index b1ff824f44b2,f3aad61e6394..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_ll2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_ll2.c
@@@ -895,85 -896,6 +895,88 @@@ static int qed_ll2_lb_txq_completion(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +qed_ll2_acquire_connection_ooo(struct qed_hwfn *p_hwfn,
 +			       struct qed_ll2_info *p_ll2_info,
 +			       u16 rx_num_ooo_buffers, u16 mtu)
 +{
 +	struct qed_ooo_buffer *p_buf = NULL;
 +	void *p_virt;
 +	u16 buf_idx;
 +	int rc = 0;
 +
 +	if (p_ll2_info->conn.conn_type != QED_LL2_TYPE_ISCSI_OOO)
 +		return rc;
 +
 +	if (!rx_num_ooo_buffers)
 +		return -EINVAL;
 +
 +	for (buf_idx = 0; buf_idx < rx_num_ooo_buffers; buf_idx++) {
 +		p_buf = kzalloc(sizeof(*p_buf), GFP_KERNEL);
 +		if (!p_buf) {
 +			rc = -ENOMEM;
 +			goto out;
 +		}
 +
 +		p_buf->rx_buffer_size = mtu + 26 + ETH_CACHE_LINE_SIZE;
 +		p_buf->rx_buffer_size = (p_buf->rx_buffer_size +
 +					 ETH_CACHE_LINE_SIZE - 1) &
 +					~(ETH_CACHE_LINE_SIZE - 1);
 +		p_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,
 +					    p_buf->rx_buffer_size,
 +					    &p_buf->rx_buffer_phys_addr,
 +					    GFP_KERNEL);
 +		if (!p_virt) {
 +			kfree(p_buf);
 +			rc = -ENOMEM;
 +			goto out;
 +		}
 +
 +		p_buf->rx_buffer_virt_addr = p_virt;
 +		qed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info, p_buf);
 +	}
 +
 +	DP_VERBOSE(p_hwfn, QED_MSG_LL2,
 +		   "Allocated [%04x] LL2 OOO buffers [each of size 0x%08x]\n",
 +		   rx_num_ooo_buffers, p_buf->rx_buffer_size);
 +
 +out:
 +	return rc;
 +}
 +
 +static void
 +qed_ll2_establish_connection_ooo(struct qed_hwfn *p_hwfn,
 +				 struct qed_ll2_info *p_ll2_conn)
 +{
 +	if (p_ll2_conn->conn.conn_type != QED_LL2_TYPE_ISCSI_OOO)
 +		return;
 +
 +	qed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);
 +	qed_ooo_submit_rx_buffers(p_hwfn, p_ll2_conn);
 +}
 +
 +static void qed_ll2_release_connection_ooo(struct qed_hwfn *p_hwfn,
 +					   struct qed_ll2_info *p_ll2_conn)
 +{
 +	struct qed_ooo_buffer *p_buffer;
 +
 +	if (p_ll2_conn->conn.conn_type != QED_LL2_TYPE_ISCSI_OOO)
 +		return;
 +
 +	qed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);
 +	while ((p_buffer = qed_ooo_get_free_buffer(p_hwfn,
 +						   p_hwfn->p_ooo_info))) {
 +		dma_free_coherent(&p_hwfn->cdev->pdev->dev,
 +				  p_buffer->rx_buffer_size,
 +				  p_buffer->rx_buffer_virt_addr,
 +				  p_buffer->rx_buffer_phys_addr);
 +		kfree(p_buffer);
 +	}
 +}
 +
++=======
++>>>>>>> 58de289807f0 (qed: LL2 code relocations)
  static void qed_ll2_stop_ooo(struct qed_dev *cdev)
  {
  	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ll2.c
