ext4: return to starting transaction in ext4_dax_huge_fault()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit fb26a1cbed8c90025572d48bc9eabe59f7571e88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fb26a1cb.failed

DAX will return to locking exceptional entry before mapping blocks for a
page fault to fix possible races with concurrent writes.  To avoid lock
inversion between exceptional entry lock and transaction start, start
the transaction already in ext4_dax_huge_fault().

Fixes: 9f141d6ef6258a3a37a045842d9ba7e68f368956
Link: http://lkml.kernel.org/r/20170510085419.27601-4-jack@suse.cz
	Signed-off-by: Jan Kara <jack@suse.cz>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fb26a1cbed8c90025572d48bc9eabe59f7571e88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/file.c
diff --cc fs/ext4/file.c
index b51446198588,831fd6beebf0..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -206,31 -258,31 +206,55 @@@ static int ext4_dax_fault(struct vm_are
  {
  	int result;
  	handle_t *handle = NULL;
++<<<<<<< HEAD
 +	struct inode *inode = file_inode(vma->vm_file);
++=======
+ 	struct inode *inode = file_inode(vmf->vma->vm_file);
++>>>>>>> fb26a1cbed8c (ext4: return to starting transaction in ext4_dax_huge_fault())
  	struct super_block *sb = inode->i_sb;
  	bool write = vmf->flags & FAULT_FLAG_WRITE;
  
  	if (write) {
  		sb_start_pagefault(sb);
++<<<<<<< HEAD
 +		file_update_time(vma->vm_file);
 +		down_read(&EXT4_I(inode)->i_mmap_sem);
 +		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
 +						EXT4_DATA_TRANS_BLOCKS(sb));
 +	} else
 +		down_read(&EXT4_I(inode)->i_mmap_sem);
 +
 +	if (IS_ERR(handle))
 +		result = VM_FAULT_SIGBUS;
 +	else
 +		result = dax_fault(vma, vmf, ext4_dax_get_block);
 +
++=======
+ 		file_update_time(vmf->vma->vm_file);
+ 		down_read(&EXT4_I(inode)->i_mmap_sem);
+ 		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
+ 					       EXT4_DATA_TRANS_BLOCKS(sb));
+ 	} else {
+ 		down_read(&EXT4_I(inode)->i_mmap_sem);
+ 	}
+ 	if (!IS_ERR(handle))
+ 		result = dax_iomap_fault(vmf, pe_size, &ext4_iomap_ops);
+ 	else
+ 		result = VM_FAULT_SIGBUS;
++>>>>>>> fb26a1cbed8c (ext4: return to starting transaction in ext4_dax_huge_fault())
  	if (write) {
  		if (!IS_ERR(handle))
  			ext4_journal_stop(handle);
  		up_read(&EXT4_I(inode)->i_mmap_sem);
  		sb_end_pagefault(sb);
++<<<<<<< HEAD
 +	} else
 +		up_read(&EXT4_I(inode)->i_mmap_sem);
++=======
+ 	} else {
+ 		up_read(&EXT4_I(inode)->i_mmap_sem);
+ 	}
++>>>>>>> fb26a1cbed8c (ext4: return to starting transaction in ext4_dax_huge_fault())
  
  	return result;
  }
* Unmerged path fs/ext4/file.c
