qed: Add support for vf coalesce configuration.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] qed: Add support for vf coalesce configuration (Don Dutile) [1499364 1462433]
Rebuild_FUZZ: 98.92%
commit-author Rahul Verma <Rahul.Verma@cavium.com>
commit 477f2d1460a636abd08f03eafabe0c51366fa5de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/477f2d14.failed

This patch add the ethtool support to set RX/Tx coalesce
value to the VF associated Rx/Tx queues.

	Signed-off-by: Rahul Verma <Rahul.Verma@cavium.com>
	Signed-off-by: Yuval Mintz <yuval.mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 477f2d1460a636abd08f03eafabe0c51366fa5de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
#	drivers/net/ethernet/qlogic/qed/qed_dev_api.h
#	drivers/net/ethernet/qlogic/qed/qed_main.c
#	drivers/net/ethernet/qlogic/qed/qed_sriov.c
#	drivers/net/ethernet/qlogic/qed/qed_vf.h
#	drivers/net/ethernet/qlogic/qede/qede_ethtool.c
#	include/linux/qed/qed_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index f3b36ab0477e,58a689fb04db..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -3511,8 -3702,43 +3511,48 @@@ static int qed_set_coalesce(struct qed_
  	return 0;
  }
  
++<<<<<<< HEAD
 +int qed_set_rxq_coalesce(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,
 +			 u16 coalesce, u8 qid, u16 sb_id)
++=======
+ int qed_set_queue_coalesce(u16 rx_coal, u16 tx_coal, void *p_handle)
+ {
+ 	struct qed_queue_cid *p_cid = p_handle;
+ 	struct qed_hwfn *p_hwfn;
+ 	struct qed_ptt *p_ptt;
+ 	int rc = 0;
+ 
+ 	p_hwfn = p_cid->p_owner;
+ 
+ 	if (IS_VF(p_hwfn->cdev))
+ 		return qed_vf_pf_set_coalesce(p_hwfn, rx_coal, tx_coal, p_cid);
+ 
+ 	p_ptt = qed_ptt_acquire(p_hwfn);
+ 	if (!p_ptt)
+ 		return -EAGAIN;
+ 
+ 	if (rx_coal) {
+ 		rc = qed_set_rxq_coalesce(p_hwfn, p_ptt, rx_coal, p_cid);
+ 		if (rc)
+ 			goto out;
+ 		p_hwfn->cdev->rx_coalesce_usecs = rx_coal;
+ 	}
+ 
+ 	if (tx_coal) {
+ 		rc = qed_set_txq_coalesce(p_hwfn, p_ptt, tx_coal, p_cid);
+ 		if (rc)
+ 			goto out;
+ 		p_hwfn->cdev->tx_coalesce_usecs = tx_coal;
+ 	}
+ out:
+ 	qed_ptt_release(p_hwfn, p_ptt);
+ 	return rc;
+ }
+ 
+ int qed_set_rxq_coalesce(struct qed_hwfn *p_hwfn,
+ 			 struct qed_ptt *p_ptt,
+ 			 u16 coalesce, struct qed_queue_cid *p_cid)
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  {
  	struct ustorm_eth_queue_zone eth_qzone;
  	u8 timeset, timer_res;
@@@ -3533,11 -3758,8 +3572,16 @@@
  	}
  	timeset = (u8)(coalesce >> timer_res);
  
++<<<<<<< HEAD
 +	rc = qed_fw_l2_queue(p_hwfn, (u16)qid, &fw_qid);
 +	if (rc)
 +		return rc;
 +
 +	rc = qed_int_set_timer_res(p_hwfn, p_ptt, timer_res, sb_id, false);
++=======
+ 	rc = qed_int_set_timer_res(p_hwfn, p_ptt, timer_res,
+ 				   p_cid->sb_igu_id, false);
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  	if (rc)
  		goto out;
  
@@@ -3553,8 -3775,9 +3597,14 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
 +int qed_set_txq_coalesce(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,
 +			 u16 coalesce, u8 qid, u16 sb_id)
++=======
+ int qed_set_txq_coalesce(struct qed_hwfn *p_hwfn,
+ 			 struct qed_ptt *p_ptt,
+ 			 u16 coalesce, struct qed_queue_cid *p_cid)
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  {
  	struct xstorm_eth_queue_zone eth_qzone;
  	u8 timeset, timer_res;
@@@ -3575,11 -3797,8 +3624,16 @@@
  	}
  	timeset = (u8)(coalesce >> timer_res);
  
++<<<<<<< HEAD
 +	rc = qed_fw_l2_queue(p_hwfn, (u16)qid, &fw_qid);
 +	if (rc)
 +		return rc;
 +
 +	rc = qed_int_set_timer_res(p_hwfn, p_ptt, timer_res, sb_id, true);
++=======
+ 	rc = qed_int_set_timer_res(p_hwfn, p_ptt, timer_res,
+ 				   p_cid->sb_igu_id, true);
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  	if (rc)
  		goto out;
  
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev_api.h
index b4aee25d860f,e6b3c83c5db8..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev_api.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev_api.h
@@@ -416,36 -443,23 +416,52 @@@ int qed_final_cleanup(struct qed_hwfn *
  		      struct qed_ptt *p_ptt, u16 id, bool is_vf);
  
  /**
++<<<<<<< HEAD
 + * @brief qed_set_rxq_coalesce - Configure coalesce parameters for an Rx queue
 + * The fact that we can configure coalescing to up to 511, but on varying
 + * accuracy [the bigger the value the less accurate] up to a mistake of 3usec
 + * for the highest values.
 + *
 + * @param p_hwfn
 + * @param p_ptt
 + * @param coalesce - Coalesce value in micro seconds.
 + * @param qid - Queue index.
 + * @param qid - SB Id
 + *
 + * @return int
 + */
 +int qed_set_rxq_coalesce(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,
 +			 u16 coalesce, u8 qid, u16 sb_id);
 +
 +/**
 + * @brief qed_set_txq_coalesce - Configure coalesce parameters for a Tx queue
 + * While the API allows setting coalescing per-qid, all tx queues sharing a
 + * SB should be in same range [i.e., either 0-0x7f, 0x80-0xff or 0x100-0x1ff]
++=======
+  * @brief qed_set_queue_coalesce - Configure coalesce parameters for Rx or
+  * Tx queue. We can configure coalescing to up to 511, but on
+  * varying accuracy [the bigger the value the less accurate] up to a mistake
+  * of 3usec for the highest values.
+  * While the API allows setting coalescing per-qid, all queues sharing a SB
+  * should be in same range [i.e., either 0-0x7f, 0x80-0xff or 0x100-0x1ff]
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
   * otherwise configuration would break.
   *
-  * @param p_hwfn
-  * @param p_ptt
-  * @param coalesce - Coalesce value in micro seconds.
-  * @param qid - Queue index.
-  * @param qid - SB Id
+  * @param rx_coal - Rx Coalesce value in micro seconds.
+  * @param tx_coal - TX Coalesce value in micro seconds.
+  * @param p_handle
   *
   * @return int
++<<<<<<< HEAD
 + */
 +int qed_set_txq_coalesce(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,
 +			 u16 coalesce, u8 qid, u16 sb_id);
++=======
+  **/
+ int
+ qed_set_queue_coalesce(u16 rx_coal, u16 tx_coal, void *p_handle);
+ 
+ 
+ const char *qed_hw_get_resc_name(enum qed_resources res_id);
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  #endif
diff --cc drivers/net/ethernet/qlogic/qed/qed_main.c
index 545e79f7504c,448810a235b8..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@@ -1456,29 -1575,9 +1456,13 @@@ static void qed_get_coalesce(struct qed
  }
  
  static int qed_set_coalesce(struct qed_dev *cdev, u16 rx_coal, u16 tx_coal,
++<<<<<<< HEAD
 +			    u8 qid, u16 sb_id)
++=======
+ 			    void *handle)
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  {
- 	struct qed_hwfn *hwfn;
- 	struct qed_ptt *ptt;
- 	int hwfn_index;
- 	int status = 0;
- 
- 	hwfn_index = qid % cdev->num_hwfns;
- 	hwfn = &cdev->hwfns[hwfn_index];
- 	ptt = qed_ptt_acquire(hwfn);
- 	if (!ptt)
- 		return -EAGAIN;
- 
- 	status = qed_set_rxq_coalesce(hwfn, ptt, rx_coal,
- 				      qid / cdev->num_hwfns, sb_id);
- 	if (status)
- 		goto out;
- 	status = qed_set_txq_coalesce(hwfn, ptt, tx_coal,
- 				      qid / cdev->num_hwfns, sb_id);
- out:
- 	qed_ptt_release(hwfn, ptt);
- 
- 	return status;
+ 		return qed_set_queue_coalesce(rx_coal, tx_coal, handle);
  }
  
  static int qed_set_led(struct qed_dev *cdev, enum qed_led_mode mode)
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c231e788de76,5feef783623b..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@@ -3263,6 -3802,12 +3343,15 @@@ static void qed_iov_process_mbx_req(str
  		case CHANNEL_TLV_RELEASE:
  			qed_iov_vf_mbx_release(p_hwfn, p_ptt, p_vf);
  			break;
++<<<<<<< HEAD
++=======
+ 		case CHANNEL_TLV_UPDATE_TUNN_PARAM:
+ 			qed_iov_vf_mbx_update_tunn_param(p_hwfn, p_ptt, p_vf);
+ 			break;
+ 		case CHANNEL_TLV_COALESCE_UPDATE:
+ 			qed_iov_vf_pf_set_coalesce(p_hwfn, p_ptt, p_vf);
+ 			break;
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  		}
  	} else if (qed_iov_tlv_supported(mbx->first_tlv.tl.type)) {
  		DP_VERBOSE(p_hwfn, QED_MSG_IOV,
diff --cc drivers/net/ethernet/qlogic/qed/qed_vf.h
index 4b1e7ae5c823,2d9fdd62f56d..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_vf.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_vf.h
@@@ -444,6 -515,8 +451,11 @@@ union vfpf_tlvs 
  	struct vfpf_vport_start_tlv start_vport;
  	struct vfpf_vport_update_tlv vport_update;
  	struct vfpf_ucast_filter_tlv ucast_filter;
++<<<<<<< HEAD
++=======
+ 	struct vfpf_update_tunn_param_tlv tunn_param_update;
+ 	struct vfpf_update_coalesce update_coalesce;
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  	struct channel_list_end_tlv list_end;
  	struct tlv_buffer_size tlv_buf_size;
  };
@@@ -555,6 -631,9 +567,12 @@@ enum 
  	CHANNEL_TLV_VPORT_UPDATE_RSS,
  	CHANNEL_TLV_VPORT_UPDATE_ACCEPT_ANY_VLAN,
  	CHANNEL_TLV_VPORT_UPDATE_SGE_TPA,
++<<<<<<< HEAD
++=======
+ 	CHANNEL_TLV_UPDATE_TUNN_PARAM,
+ 	CHANNEL_TLV_COALESCE_UPDATE,
+ 	CHANNEL_TLV_QID,
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  	CHANNEL_TLV_MAX,
  
  	/* Required for iterating over vport-update tlvs.
@@@ -585,8 -670,35 +603,22 @@@ struct qed_vf_iov 
  	 * this has to be propagated as it affects the fastpath.
  	 */
  	bool b_pre_fp_hsi;
 -
 -	/* Current day VFs are passing the SBs physical address on vport
 -	 * start, and as they lack an IGU mapping they need to store the
 -	 * addresses of previously registered SBs.
 -	 * Even if we were to change configuration flow, due to backward
 -	 * compatibility [with older PFs] we'd still need to store these.
 -	 */
 -	struct qed_sb_info *sbs_info[PFVF_MAX_SBS_PER_VF];
 -
 -	/* Determines whether VF utilizes doorbells via limited register
 -	 * bar or via the doorbell bar.
 -	 */
 -	bool b_doorbell_bar;
  };
  
+ /**
+  * @brief VF - Set Rx/Tx coalesce per VF's relative queue.
+  *             Coalesce value '0' will omit the configuration.
+  *
+  * @param p_hwfn
+  * @param rx_coal - coalesce value in micro second for rx queue
+  * @param tx_coal - coalesce value in micro second for tx queue
+  * @param p_cid   - queue cid
+  *
+  **/
+ int qed_vf_pf_set_coalesce(struct qed_hwfn *p_hwfn,
+ 			   u16 rx_coal,
+ 			   u16 tx_coal, struct qed_queue_cid *p_cid);
+ 
  #ifdef CONFIG_QED_SRIOV
  /**
   * @brief Read the VF bulletin and act on it if needed
diff --cc drivers/net/ethernet/qlogic/qede/qede_ethtool.c
index 64750d8870db,76e0b132e8cc..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
@@@ -703,9 -718,9 +703,13 @@@ static int qede_set_coalesce(struct net
  			     struct ethtool_coalesce *coal)
  {
  	struct qede_dev *edev = netdev_priv(dev);
+ 	struct qede_fastpath *fp;
  	int i, rc = 0;
  	u16 rxc, txc;
++<<<<<<< HEAD
 +	u8 sb_id;
++=======
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  
  	if (!netif_running(dev)) {
  		DP_INFO(edev, "Interface is down\n");
@@@ -725,12 -739,28 +728,37 @@@
  	rxc = (u16)coal->rx_coalesce_usecs;
  	txc = (u16)coal->tx_coalesce_usecs;
  	for_each_queue(i) {
++<<<<<<< HEAD
 +		sb_id = edev->fp_array[i].sb_info->igu_sb_id;
 +		rc = edev->ops->common->set_coalesce(edev->cdev, rxc, txc,
 +						     (u8)i, sb_id);
 +		if (rc) {
 +			DP_INFO(edev, "Set coalesce error, rc = %d\n", rc);
 +			return rc;
++=======
+ 		fp = &edev->fp_array[i];
+ 
+ 		if (edev->fp_array[i].type & QEDE_FASTPATH_RX) {
+ 			rc = edev->ops->common->set_coalesce(edev->cdev,
+ 							     rxc, 0,
+ 							     fp->rxq->handle);
+ 			if (rc) {
+ 				DP_INFO(edev,
+ 					"Set RX coalesce error, rc = %d\n", rc);
+ 				return rc;
+ 			}
+ 		}
+ 
+ 		if (edev->fp_array[i].type & QEDE_FASTPATH_TX) {
+ 			rc = edev->ops->common->set_coalesce(edev->cdev,
+ 							     0, txc,
+ 							     fp->txq->handle);
+ 			if (rc) {
+ 				DP_INFO(edev,
+ 					"Set TX coalesce error, rc = %d\n", rc);
+ 				return rc;
+ 			}
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  		}
  	}
  
diff --cc include/linux/qed/qed_if.h
index cbe538f3b78a,4d59ca16134c..000000000000
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@@ -637,8 -694,8 +637,13 @@@ struct qed_common_ops 
   *
   * @return 0 on success, error otherwise.
   */
++<<<<<<< HEAD
 +	int (*set_coalesce)(struct qed_dev *cdev, u16 rx_coal, u16 tx_coal,
 +			    u8 qid, u16 sb_id);
++=======
+ 	int (*set_coalesce)(struct qed_dev *cdev,
+ 			    u16 rx_coal, u16 tx_coal, void *handle);
++>>>>>>> 477f2d1460a6 (qed: Add support for vf coalesce configuration.)
  
  /**
   * @brief set_led - Configure LED mode
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev_api.h
diff --git a/drivers/net/ethernet/qlogic/qed/qed_l2.h b/drivers/net/ethernet/qlogic/qed/qed_l2.h
index 93cb932ef663..6893f1d34edf 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.h
@@ -344,4 +344,11 @@ qed_eth_txq_start_ramrod(struct qed_hwfn *p_hwfn,
 
 u8 qed_mcast_bin_from_mac(u8 *mac);
 
+int qed_set_rxq_coalesce(struct qed_hwfn *p_hwfn,
+			 struct qed_ptt *p_ptt,
+			 u16 coalesce, struct qed_queue_cid *p_cid);
+
+int qed_set_txq_coalesce(struct qed_hwfn *p_hwfn,
+			 struct qed_ptt *p_ptt,
+			 u16 coalesce, struct qed_queue_cid *p_cid);
 #endif /* _QED_L2_H */
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_main.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_vf.c b/drivers/net/ethernet/qlogic/qed/qed_vf.c
index f2954eb03b41..e5f739f24f68 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_vf.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_vf.c
@@ -1079,6 +1079,50 @@ exit:
 	return rc;
 }
 
+int
+qed_vf_pf_set_coalesce(struct qed_hwfn *p_hwfn,
+		       u16 rx_coal, u16 tx_coal, struct qed_queue_cid *p_cid)
+{
+	struct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;
+	struct vfpf_update_coalesce *req;
+	struct pfvf_def_resp_tlv *resp;
+	int rc;
+
+	/* clear mailbox and prep header tlv */
+	req = qed_vf_pf_prep(p_hwfn, CHANNEL_TLV_COALESCE_UPDATE, sizeof(*req));
+
+	req->rx_coal = rx_coal;
+	req->tx_coal = tx_coal;
+	req->qid = p_cid->rel.queue_id;
+
+	DP_VERBOSE(p_hwfn,
+		   QED_MSG_IOV,
+		   "Setting coalesce rx_coal = %d, tx_coal = %d at queue = %d\n",
+		   rx_coal, tx_coal, req->qid);
+
+	/* add list termination tlv */
+	qed_add_tlv(p_hwfn, &p_iov->offset, CHANNEL_TLV_LIST_END,
+		    sizeof(struct channel_list_end_tlv));
+
+	resp = &p_iov->pf2vf_reply->default_resp;
+	rc = qed_send_msg2pf(p_hwfn, &resp->hdr.status, sizeof(*resp));
+	if (rc)
+		goto exit;
+
+	if (resp->hdr.status != PFVF_STATUS_SUCCESS)
+		goto exit;
+
+	if (rx_coal)
+		p_hwfn->cdev->rx_coalesce_usecs = rx_coal;
+
+	if (tx_coal)
+		p_hwfn->cdev->tx_coalesce_usecs = tx_coal;
+
+exit:
+	qed_vf_pf_req_end(p_hwfn, rc);
+	return rc;
+}
+
 u16 qed_vf_get_igu_sb_id(struct qed_hwfn *p_hwfn, u16 sb_id)
 {
 	struct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_vf.h
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_ethtool.c
* Unmerged path include/linux/qed/qed_if.h
