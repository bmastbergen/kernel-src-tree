net: add rbnode to struct sk_buff

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] add rbnode to struct sk_buff (Ivan Vecera) [1445420]
Rebuild_FUZZ: 91.80%
commit-author Eric Dumazet <edumazet@google.com>
commit 56b174256b6936ec4c1ed8f3407109ac6929d3ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/56b17425.failed

Yaogong replaces TCP out of order receive queue by an RB tree.

As netem already does a private skb->{next/prev/tstamp} union
with a 'struct rb_node', lets do this in a cleaner way.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Yaogong Wang <wygivan@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 56b174256b6936ec4c1ed8f3407109ac6929d3ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 28aefdf34562,5ad9675b6fe1..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -20,7 -20,7 +20,11 @@@
  #include <linux/time.h>
  #include <linux/bug.h>
  #include <linux/cache.h>
++<<<<<<< HEAD
 +#include <linux/socket.h>
++=======
+ #include <linux/rbtree.h>
++>>>>>>> 56b174256b69 (net: add rbnode to struct sk_buff)
  
  #include <linux/atomic.h>
  #include <asm/types.h>
@@@ -663,17 -506,19 +668,33 @@@ static inline u32 skb_mstamp_us_delta(c
   */
  
  struct sk_buff {
++<<<<<<< HEAD
 +	/* These two members must be first. */
 +	struct sk_buff		*next;
 +	struct sk_buff		*prev;
 +#ifdef __GENKSYMS__
 +	ktime_t		tstamp;
 +#else
 +	union {
 +		ktime_t		tstamp;
 +		struct skb_mstamp skb_mstamp;
 +	};
 +#endif
++=======
+ 	union {
+ 		struct {
+ 			/* These two members must be first. */
+ 			struct sk_buff		*next;
+ 			struct sk_buff		*prev;
+ 
+ 			union {
+ 				ktime_t		tstamp;
+ 				struct skb_mstamp skb_mstamp;
+ 			};
+ 		};
+ 		struct rb_node	rbnode; /* used in netem & tcp stack */
+ 	};
++>>>>>>> 56b174256b69 (net: add rbnode to struct sk_buff)
  	struct sock		*sk;
  	struct net_device	*dev;
  
* Unmerged path include/linux/skbuff.h
diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c
index 0f67384afb4d..a287a927aed7 100644
--- a/net/sched/sch_netem.c
+++ b/net/sched/sch_netem.c
@@ -139,33 +139,20 @@ struct netem_sched_data {
 
 /* Time stamp put into socket buffer control block
  * Only valid when skbs are in our internal t(ime)fifo queue.
+ *
+ * As skb->rbnode uses same storage than skb->next, skb->prev and skb->tstamp,
+ * and skb->next & skb->prev are scratch space for a qdisc,
+ * we save skb->tstamp value in skb->cb[] before destroying it.
  */
 struct netem_skb_cb {
 	psched_time_t	time_to_send;
 	ktime_t		tstamp_save;
 };
 
-/* Because space in skb->cb[] is tight, netem overloads skb->next/prev/tstamp
- * to hold a rb_node structure.
- *
- * If struct sk_buff layout is changed, the following checks will complain.
- */
-static struct rb_node *netem_rb_node(struct sk_buff *skb)
-{
-	BUILD_BUG_ON(offsetof(struct sk_buff, next) != 0);
-	BUILD_BUG_ON(offsetof(struct sk_buff, prev) !=
-		     offsetof(struct sk_buff, next) + sizeof(skb->next));
-	BUILD_BUG_ON(offsetof(struct sk_buff, tstamp) !=
-		     offsetof(struct sk_buff, prev) + sizeof(skb->prev));
-	BUILD_BUG_ON(sizeof(struct rb_node) > sizeof(skb->next) +
-					      sizeof(skb->prev) +
-					      sizeof(skb->tstamp));
-	return (struct rb_node *)&skb->next;
-}
 
 static struct sk_buff *netem_rb_to_skb(struct rb_node *rb)
 {
-	return (struct sk_buff *)rb;
+	return container_of(rb, struct sk_buff, rbnode);
 }
 
 static inline struct netem_skb_cb *netem_skb_cb(struct sk_buff *skb)
@@ -403,8 +390,8 @@ static void tfifo_enqueue(struct sk_buff *nskb, struct Qdisc *sch)
 		else
 			p = &parent->rb_left;
 	}
-	rb_link_node(netem_rb_node(nskb), parent, p);
-	rb_insert_color(netem_rb_node(nskb), &q->t_root);
+	rb_link_node(&nskb->rbnode, parent, p);
+	rb_insert_color(&nskb->rbnode, &q->t_root);
 	sch->q.qlen++;
 }
 
