KVM: nVMX: fix nested EPT detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ladi Prosek <lprosek@redhat.com>
commit 7ad658b693536741c37b16aeb07840a2ce75f5b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7ad658b6.failed

The nested_ept_enabled flag introduced in commit 7ca29de2136 was not
computed correctly. We are interested only in L1's EPT state, not the
the combined L0+L1 value.

In particular, if L0 uses EPT but L1 does not, nested_ept_enabled must
be false to make sure that PDPSTRs are loaded based on CR3 as usual,
because the special case described in 26.3.2.4 Loading Page-Directory-
Pointer-Table Entries does not apply.

Fixes: 7ca29de21362 ("KVM: nVMX: fix CR3 load if L2 uses PAE paging and EPT")
	Cc: qemu-stable@nongnu.org
	Reported-by: Wanpeng Li <wanpeng.li@hotmail.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Ladi Prosek <lprosek@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7ad658b693536741c37b16aeb07840a2ce75f5b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 52aa73b72bd4,2ee00dbbbd51..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9698,7 -10138,14 +9697,18 @@@ static int prepare_vmcs02(struct kvm_vc
  				vmcs12->guest_intr_status);
  		}
  
++<<<<<<< HEAD
 +		nested_ept_enabled = (exec_control & SECONDARY_EXEC_ENABLE_EPT) != 0;
++=======
+ 		/*
+ 		 * Write an illegal value to APIC_ACCESS_ADDR. Later,
+ 		 * nested_get_vmcs12_pages will either fix it up or
+ 		 * remove the VM execution control.
+ 		 */
+ 		if (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)
+ 			vmcs_write64(APIC_ACCESS_ADDR, -1ull);
+ 
++>>>>>>> 7ad658b69353 (KVM: nVMX: fix nested EPT detection)
  		vmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);
  	}
  
@@@ -9857,8 -10289,18 +9867,8 @@@
  	vmx_set_cr4(vcpu, vmcs12->guest_cr4);
  	vmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));
  
 -	if (from_vmentry &&
 -	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER))
 -		vcpu->arch.efer = vmcs12->guest_ia32_efer;
 -	else if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)
 -		vcpu->arch.efer |= (EFER_LMA | EFER_LME);
 -	else
 -		vcpu->arch.efer &= ~(EFER_LMA | EFER_LME);
 -	/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */
 -	vmx_set_efer(vcpu, vcpu->arch.efer);
 -
  	/* Shadow page tables on either EPT or shadow page tables. */
- 	if (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_ept_enabled,
+ 	if (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),
  				entry_failure_code))
  		return 1;
  
* Unmerged path arch/x86/kvm/vmx.c
