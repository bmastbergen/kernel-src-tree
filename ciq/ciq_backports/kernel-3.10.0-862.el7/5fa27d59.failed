nfp: resync repr state when port table sync

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dirk van der Merwe <dirk.vandermerwe@netronome.com>
commit 5fa27d59af2a36c32156e56b6370387f60b67052
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5fa27d59.failed

If the NSP port table has been refreshed, resync the representor state
with the new port information. At the moment, this only entails looking
for invalid ports and killing off representors associated with them.

The repr instance becomes NULL which is safe since the app accessor
function for reprs returns NULL when it cannot access a repr.

	Signed-off-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5fa27d59af2a36c32156e56b6370387f60b67052)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_repr.h
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,c505014121c4..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -449,17 -572,96 +449,101 @@@ err_nn_free
  
  static void nfp_net_pci_remove_finish(struct nfp_pf *pf)
  {
 -	nfp_net_pf_app_stop(pf);
 -	/* stop app first, to avoid double free of ctrl vNIC's ddir */
  	nfp_net_debugfs_dir_clean(&pf->ddir);
  
 -	nfp_net_pf_free_irqs(pf);
 -	nfp_net_pf_app_clean(pf);
 -	nfp_net_pci_unmap_mem(pf);
 +	nfp_net_irqs_disable(pf->pdev);
 +	kfree(pf->irq_entries);
 +
 +	nfp_cpp_area_release_free(pf->rx_area);
 +	nfp_cpp_area_release_free(pf->tx_area);
 +	nfp_cpp_area_release_free(pf->ctrl_area);
  }
  
++<<<<<<< HEAD
 +static void nfp_net_refresh_netdevs(struct work_struct *work)
++=======
+ static int
+ nfp_net_eth_port_update(struct nfp_cpp *cpp, struct nfp_port *port,
+ 			struct nfp_eth_table *eth_table)
+ {
+ 	struct nfp_eth_table_port *eth_port;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	eth_port = nfp_net_find_port(eth_table, port->eth_id);
+ 	if (!eth_port) {
+ 		set_bit(NFP_PORT_CHANGED, &port->flags);
+ 		nfp_warn(cpp, "Warning: port #%d not present after reconfig\n",
+ 			 port->eth_id);
+ 		return -EIO;
+ 	}
+ 	if (eth_port->override_changed) {
+ 		nfp_warn(cpp, "Port #%d config changed, unregistering. Driver reload required before port will be operational again.\n", port->eth_id);
+ 		port->type = NFP_PORT_INVALID;
+ 	}
+ 
+ 	memcpy(port->eth_port, eth_port, sizeof(*eth_port));
+ 
+ 	return 0;
+ }
+ 
+ int nfp_net_refresh_port_table_sync(struct nfp_pf *pf)
+ {
+ 	struct nfp_eth_table *eth_table;
+ 	struct nfp_net *nn, *next;
+ 	struct nfp_port *port;
+ 	int err;
+ 
+ 	lockdep_assert_held(&pf->lock);
+ 
+ 	/* Check for nfp_net_pci_remove() racing against us */
+ 	if (list_empty(&pf->vnics))
+ 		return 0;
+ 
+ 	/* Update state of all ports */
+ 	rtnl_lock();
+ 	list_for_each_entry(port, &pf->ports, port_list)
+ 		clear_bit(NFP_PORT_CHANGED, &port->flags);
+ 
+ 	eth_table = nfp_eth_read_ports(pf->cpp);
+ 	if (!eth_table) {
+ 		list_for_each_entry(port, &pf->ports, port_list)
+ 			if (__nfp_port_get_eth_port(port))
+ 				set_bit(NFP_PORT_CHANGED, &port->flags);
+ 		rtnl_unlock();
+ 		nfp_err(pf->cpp, "Error refreshing port config!\n");
+ 		return -EIO;
+ 	}
+ 
+ 	list_for_each_entry(port, &pf->ports, port_list)
+ 		if (__nfp_port_get_eth_port(port))
+ 			nfp_net_eth_port_update(pf->cpp, port, eth_table);
+ 	rtnl_unlock();
+ 
+ 	kfree(eth_table);
+ 
+ 	/* Resync repr state. This may cause reprs to be removed. */
+ 	err = nfp_reprs_resync_phys_ports(pf->app);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Shoot off the ports which became invalid */
+ 	list_for_each_entry_safe(nn, next, &pf->vnics, vnic_list) {
+ 		if (!nn->port || nn->port->type != NFP_PORT_INVALID)
+ 			continue;
+ 
+ 		nfp_net_pf_clean_vnic(pf, nn);
+ 		nfp_net_pf_free_vnic(pf, nn);
+ 	}
+ 
+ 	if (list_empty(&pf->vnics))
+ 		nfp_net_pci_remove_finish(pf);
+ 
+ 	return 0;
+ }
+ 
+ static void nfp_net_refresh_vnics(struct work_struct *work)
++>>>>>>> 5fa27d59af2a (nfp: resync repr state when port table sync)
  {
  	struct nfp_pf *pf = container_of(work, struct nfp_pf,
  					 port_refresh_work);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_repr.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_repr.h
