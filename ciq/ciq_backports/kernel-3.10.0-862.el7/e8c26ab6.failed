mm/swap: skip readahead for unreferenced swap slots

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] swap: skip readahead for unreferenced swap slots (Jerome Marchand) [1400689]
Rebuild_FUZZ: 96.97%
commit-author Tim Chen <tim.c.chen@linux.intel.com>
commit e8c26ab60598558ec3a626e7925b06e7417d7710
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e8c26ab6.failed

We can avoid needlessly allocating page for swap slots that are not used
by anyone.  No pages have to be read in for these slots.

Link: http://lkml.kernel.org/r/0784b3f20b9bd3aa5552219624cb78dc4ae710c9.1484082593.git.tim.c.chen@linux.intel.com
	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
	Cc: Aaron Lu <aaron.lu@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Hillf Danton <hillf.zj@alibaba-inc.com>
	Cc: Huang Ying <ying.huang@intel.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Jonathan Corbet <corbet@lwn.net> escreveu:
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e8c26ab60598558ec3a626e7925b06e7417d7710)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/swap.h
#	mm/swapfile.c
diff --cc include/linux/swap.h
index 61d41d507b58,3116382067cd..000000000000
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@@ -430,20 -398,14 +430,25 @@@ extern unsigned int count_swap_pages(in
  extern sector_t map_swap_page(struct page *, struct block_device **);
  extern sector_t swapdev_block(int, pgoff_t);
  extern int page_swapcount(struct page *);
++<<<<<<< HEAD
++=======
+ extern int __swp_swapcount(swp_entry_t entry);
+ extern int swp_swapcount(swp_entry_t entry);
++>>>>>>> e8c26ab60598 (mm/swap: skip readahead for unreferenced swap slots)
  extern struct swap_info_struct *page_swap_info(struct page *);
 -extern bool reuse_swap_page(struct page *, int *);
 +extern int reuse_swap_page(struct page *);
  extern int try_to_free_swap(struct page *);
  struct backing_dev_info;
 -extern int init_swap_address_space(unsigned int type, unsigned long nr_pages);
 -extern void exit_swap_address_space(unsigned int type);
 +
 +#ifdef CONFIG_MEMCG
 +extern void
 +mem_cgroup_uncharge_swapcache(struct page *page, swp_entry_t ent, bool swapout);
 +#else
 +static inline void
 +mem_cgroup_uncharge_swapcache(struct page *page, swp_entry_t ent, bool swapout)
 +{
 +}
 +#endif
  
  #else /* CONFIG_SWAP */
  
@@@ -530,7 -493,18 +535,22 @@@ static inline int page_swapcount(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +#define reuse_swap_page(page)	(page_mapcount(page) == 1)
++=======
+ static inline int __swp_swapcount(swp_entry_t entry)
+ {
+ 	return 0;
+ }
+ 
+ static inline int swp_swapcount(swp_entry_t entry)
+ {
+ 	return 0;
+ }
+ 
+ #define reuse_swap_page(page, total_mapcount) \
+ 	(page_trans_huge_mapcount(page, total_mapcount) == 1)
++>>>>>>> e8c26ab60598 (mm/swap: skip readahead for unreferenced swap slots)
  
  static inline int try_to_free_swap(struct page *page)
  {
diff --cc mm/swapfile.c
index 44c2eac6b890,7e888de35c41..000000000000
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@@ -521,7 -798,7 +521,11 @@@ swp_entry_t get_swap_page_of_type(int t
  	return (swp_entry_t) {0};
  }
  
++<<<<<<< HEAD
 +static struct swap_info_struct *swap_info_get(swp_entry_t entry)
++=======
+ static struct swap_info_struct *__swap_info_get(swp_entry_t entry)
++>>>>>>> e8c26ab60598 (mm/swap: skip readahead for unreferenced swap slots)
  {
  	struct swap_info_struct *p;
  	unsigned long offset, type;
@@@ -537,29 -814,53 +541,65 @@@
  	offset = swp_offset(entry);
  	if (offset >= p->max)
  		goto bad_offset;
++<<<<<<< HEAD
 +	if (!p->swap_map[offset])
 +		goto bad_free;
 +	spin_lock(&p->lock);
  	return p;
  
 +bad_free:
 +	printk(KERN_ERR "swap_free: %s%08lx\n", Unused_offset, entry.val);
 +	goto out;
++=======
++	return p;
++
++>>>>>>> e8c26ab60598 (mm/swap: skip readahead for unreferenced swap slots)
  bad_offset:
 -	pr_err("swap_info_get: %s%08lx\n", Bad_offset, entry.val);
 +	printk(KERN_ERR "swap_free: %s%08lx\n", Bad_offset, entry.val);
  	goto out;
  bad_device:
 -	pr_err("swap_info_get: %s%08lx\n", Unused_file, entry.val);
 +	printk(KERN_ERR "swap_free: %s%08lx\n", Unused_file, entry.val);
  	goto out;
  bad_nofile:
 -	pr_err("swap_info_get: %s%08lx\n", Bad_file, entry.val);
 +	printk(KERN_ERR "swap_free: %s%08lx\n", Bad_file, entry.val);
  out:
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static struct swap_info_struct *_swap_info_get(swp_entry_t entry)
+ {
+ 	struct swap_info_struct *p;
+ 
+ 	p = __swap_info_get(entry);
+ 	if (!p)
+ 		goto out;
+ 	if (!p->swap_map[swp_offset(entry)])
+ 		goto bad_free;
+ 	return p;
+ 
+ bad_free:
+ 	pr_err("swap_info_get: %s%08lx\n", Unused_offset, entry.val);
+ 	goto out;
+ out:
+ 	return NULL;
+ }
+ 
+ static struct swap_info_struct *swap_info_get(swp_entry_t entry)
+ {
+ 	struct swap_info_struct *p;
+ 
+ 	p = _swap_info_get(entry);
+ 	if (p)
+ 		spin_lock(&p->lock);
+ 	return p;
+ }
+ 
++>>>>>>> e8c26ab60598 (mm/swap: skip readahead for unreferenced swap slots)
  static unsigned char swap_entry_free(struct swap_info_struct *p,
 -				     swp_entry_t entry, unsigned char usage,
 -				     bool swap_info_locked)
 +				     swp_entry_t entry, unsigned char usage)
  {
 -	struct swap_cluster_info *ci;
  	unsigned long offset = swp_offset(entry);
  	unsigned char count;
  	unsigned char has_cache;
@@@ -676,6 -1000,74 +716,77 @@@ int page_swapcount(struct page *page
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * How many references to @entry are currently swapped out?
+  * This does not give an exact answer when swap count is continued,
+  * but does include the high COUNT_CONTINUED flag to allow for that.
+  */
+ int __swp_swapcount(swp_entry_t entry)
+ {
+ 	int count = 0;
+ 	pgoff_t offset;
+ 	struct swap_info_struct *si;
+ 	struct swap_cluster_info *ci;
+ 
+ 	si = __swap_info_get(entry);
+ 	if (si) {
+ 		offset = swp_offset(entry);
+ 		ci = lock_cluster_or_swap_info(si, offset);
+ 		count = swap_count(si->swap_map[offset]);
+ 		unlock_cluster_or_swap_info(si, ci);
+ 	}
+ 	return count;
+ }
+ 
+ /*
+  * How many references to @entry are currently swapped out?
+  * This considers COUNT_CONTINUED so it returns exact answer.
+  */
+ int swp_swapcount(swp_entry_t entry)
+ {
+ 	int count, tmp_count, n;
+ 	struct swap_info_struct *p;
+ 	struct swap_cluster_info *ci;
+ 	struct page *page;
+ 	pgoff_t offset;
+ 	unsigned char *map;
+ 
+ 	p = _swap_info_get(entry);
+ 	if (!p)
+ 		return 0;
+ 
+ 	offset = swp_offset(entry);
+ 
+ 	ci = lock_cluster_or_swap_info(p, offset);
+ 
+ 	count = swap_count(p->swap_map[offset]);
+ 	if (!(count & COUNT_CONTINUED))
+ 		goto out;
+ 
+ 	count &= ~COUNT_CONTINUED;
+ 	n = SWAP_MAP_MAX + 1;
+ 
+ 	page = vmalloc_to_page(p->swap_map + offset);
+ 	offset &= ~PAGE_MASK;
+ 	VM_BUG_ON(page_private(page) != SWP_CONTINUED);
+ 
+ 	do {
+ 		page = list_next_entry(page, lru);
+ 		map = kmap_atomic(page);
+ 		tmp_count = map[offset];
+ 		kunmap_atomic(map);
+ 
+ 		count += (tmp_count & ~COUNT_CONTINUED) * n;
+ 		n *= (SWAP_CONT_MAX + 1);
+ 	} while (tmp_count & COUNT_CONTINUED);
+ out:
+ 	unlock_cluster_or_swap_info(p, ci);
+ 	return count;
+ }
+ 
+ /*
++>>>>>>> e8c26ab60598 (mm/swap: skip readahead for unreferenced swap slots)
   * We can write to an anon page without COW if there are no other references
   * to it.  And as a side-effect, free up its swap: because the old content
   * on disk will never be read, and seeking back there to write new content
* Unmerged path include/linux/swap.h
diff --git a/mm/swap_state.c b/mm/swap_state.c
index 8ead62769c81..384fb1b879dc 100644
--- a/mm/swap_state.c
+++ b/mm/swap_state.c
@@ -329,6 +329,10 @@ struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 		if (found_page)
 			break;
 
+		/* Just skip read ahead for unused swap slot */
+		if (!__swp_swapcount(entry))
+			return NULL;
+
 		/*
 		 * Get a new page to read into from swap.
 		 */
* Unmerged path mm/swapfile.c
