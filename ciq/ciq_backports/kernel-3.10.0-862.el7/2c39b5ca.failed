qla2xxx: Remove SRR code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Himanshu Madhani <himanshu.madhani@cavium.com>
commit 2c39b5ca2a8cb99fc463fd622e8ea3b9fbb980a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2c39b5ca.failed

During initial implementation, tape support was included but not
enabled by default on target. So far, we don't see any target
customer requesting this support. Since this code is not being
used actively, we want to remove it and we will add back if there
are any request in future for SRR support.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Giridhar Malavali <giridhar.malavali@cavium.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 2c39b5ca2a8cb99fc463fd622e8ea3b9fbb980a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7d14b62f83a6,119a445a82f6..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -98,9 -105,19 +98,25 @@@ static void qlt_response_pkt(struct scs
  static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,
  	int fn, void *iocb, int flags);
  static void qlt_send_term_exchange(struct scsi_qla_host *ha, struct qla_tgt_cmd
++<<<<<<< HEAD
 +	*cmd, struct atio_from_isp *atio, int ha_locked);
 +static void qlt_reject_free_srr_imm(struct scsi_qla_host *ha,
 +	struct qla_tgt_srr_imm *imm, int ha_lock);
++=======
+ 	*cmd, struct atio_from_isp *atio, int ha_locked, int ul_abort);
+ static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha,
+ 	struct qla_tgt_cmd *cmd);
+ static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull);
+ static void qlt_disable_vha(struct scsi_qla_host *vha);
+ static void qlt_clear_tgt_db(struct qla_tgt *tgt);
+ static void qlt_send_notify_ack(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *ntfy,
+ 	uint32_t add_flags, uint16_t resp_code, int resp_code_valid,
+ 	uint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);
+ static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *imm, int ha_locked);
++>>>>>>> 2c39b5ca2a8c (qla2xxx: Remove SRR code)
  /*
   * Global Variables
   */
@@@ -1857,95 -2181,6 +1873,98 @@@ static inline int qlt_need_explicit_con
  		    cmd->conf_compl_supported;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_QLA_TGT_DEBUG_SRR
 +/*
 + *  Original taken from the XFS code
 + */
 +static unsigned long qlt_srr_random(void)
 +{
 +	static int Inited;
 +	static unsigned long RandomValue;
 +	static DEFINE_SPINLOCK(lock);
 +	/* cycles pseudo-randomly through all values between 1 and 2^31 - 2 */
 +	register long rv;
 +	register long lo;
 +	register long hi;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&lock, flags);
 +	if (!Inited) {
 +		RandomValue = jiffies;
 +		Inited = 1;
 +	}
 +	rv = RandomValue;
 +	hi = rv / 127773;
 +	lo = rv % 127773;
 +	rv = 16807 * lo - 2836 * hi;
 +	if (rv <= 0)
 +		rv += 2147483647;
 +	RandomValue = rv;
 +	spin_unlock_irqrestore(&lock, flags);
 +	return rv;
 +}
 +
 +static void qlt_check_srr_debug(struct qla_tgt_cmd *cmd, int *xmit_type)
 +{
 +#if 0 /* This is not a real status packets lost, so it won't lead to SRR */
 +	if ((*xmit_type & QLA_TGT_XMIT_STATUS) && (qlt_srr_random() % 200)
 +	    == 50) {
 +		*xmit_type &= ~QLA_TGT_XMIT_STATUS;
 +		ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf015,
 +		    "Dropping cmd %p (tag %d) status", cmd, cmd->tag);
 +	}
 +#endif
 +	/*
 +	 * It's currently not possible to simulate SRRs for FCP_WRITE without
 +	 * a physical link layer failure, so don't even try here..
 +	 */
 +	if (cmd->dma_data_direction != DMA_FROM_DEVICE)
 +		return;
 +
 +	if (qlt_has_data(cmd) && (cmd->sg_cnt > 1) &&
 +	    ((qlt_srr_random() % 100) == 20)) {
 +		int i, leave = 0;
 +		unsigned int tot_len = 0;
 +
 +		while (leave == 0)
 +			leave = qlt_srr_random() % cmd->sg_cnt;
 +
 +		for (i = 0; i < leave; i++)
 +			tot_len += cmd->sg[i].length;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf016,
 +		    "Cutting cmd %p (tag %d) buffer"
 +		    " tail to len %d, sg_cnt %d (cmd->bufflen %d,"
 +		    " cmd->sg_cnt %d)", cmd, cmd->tag, tot_len, leave,
 +		    cmd->bufflen, cmd->sg_cnt);
 +
 +		cmd->bufflen = tot_len;
 +		cmd->sg_cnt = leave;
 +	}
 +
 +	if (qlt_has_data(cmd) && ((qlt_srr_random() % 100) == 70)) {
 +		unsigned int offset = qlt_srr_random() % cmd->bufflen;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf017,
 +		    "Cutting cmd %p (tag %d) buffer head "
 +		    "to offset %d (cmd->bufflen %d)", cmd, cmd->tag, offset,
 +		    cmd->bufflen);
 +		if (offset == 0)
 +			*xmit_type &= ~QLA_TGT_XMIT_DATA;
 +		else if (qlt_set_data_offset(cmd, offset)) {
 +			ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf018,
 +			    "qlt_set_data_offset() failed (tag %d)", cmd->tag);
 +		}
 +	}
 +}
 +#else
 +static inline void qlt_check_srr_debug(struct qla_tgt_cmd *cmd, int *xmit_type)
 +{}
 +#endif
 +
++=======
++>>>>>>> 2c39b5ca2a8c (qla2xxx: Remove SRR code)
  static void qlt_24xx_init_ctio_to_isp(struct ctio7_to_24xx *ctio,
  	struct qla_tgt_prm *prm)
  {
@@@ -2027,13 -2581,26 +2046,12 @@@ int qlt_xmit_response(struct qla_tgt_cm
  	unsigned long flags = 0;
  	int res;
  
 -	spin_lock_irqsave(&ha->hardware_lock, flags);
 -	if (cmd->sess && cmd->sess->deleted == QLA_SESS_DELETION_IN_PROGRESS) {
 -		cmd->state = QLA_TGT_STATE_PROCESSED;
 -		if (cmd->sess->logout_completed)
 -			/* no need to terminate. FW already freed exchange. */
 -			qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
 -		else
 -			qlt_send_term_exchange(vha, cmd, &cmd->atio, 1, 0);
 -		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -		return 0;
 -	}
 -	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -
  	memset(&prm, 0, sizeof(prm));
- 	qlt_check_srr_debug(cmd, &xmit_type);
  
  	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe018,
 -	    "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d se_cmd[%p]\n",
 -	    (xmit_type & QLA_TGT_XMIT_STATUS) ?
 -	    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction,
 -	    &cmd->se_cmd);
 +	    "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, "
 +	    "cmd->dma_data_direction=%d\n", (xmit_type & QLA_TGT_XMIT_STATUS) ?
 +	    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction);
  
  	res = qlt_pre_xmit_response(cmd, &prm, xmit_type, scsi_status,
  	    &full_req_cnt);
@@@ -2292,100 -3127,123 +2310,103 @@@ done
  	return;
  }
  
 -static void qlt_init_term_exchange(struct scsi_qla_host *vha)
 +void qlt_free_cmd(struct qla_tgt_cmd *cmd)
  {
 -	struct list_head free_list;
 -	struct qla_tgt_cmd *cmd, *tcmd;
 -
 -	vha->hw->tgt.leak_exchg_thresh_hold =
 -	    (vha->hw->cur_fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;
 -
 -	cmd = tcmd = NULL;
 -	if (!list_empty(&vha->hw->tgt.q_full_list)) {
 -		INIT_LIST_HEAD(&free_list);
 -		list_splice_init(&vha->hw->tgt.q_full_list, &free_list);
 +	BUG_ON(cmd->sg_mapped);
  
 -		list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
 -			list_del(&cmd->cmd_list);
 -			/* This cmd was never sent to TCM.  There is no need
 -			 * to schedule free or call free_cmd
 -			 */
 -			qlt_free_cmd(cmd);
 -			vha->hw->tgt.num_qfull_cmds_alloc--;
 -		}
 -	}
 -	vha->hw->tgt.num_qfull_cmds_dropped = 0;
 +	if (unlikely(cmd->free_sg))
 +		kfree(cmd->sg);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  }
 +EXPORT_SYMBOL(qlt_free_cmd);
  
 -static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)
++<<<<<<< HEAD
 +/* ha->hardware_lock supposed to be held on entry */
 +static int qlt_prepare_srr_ctio(struct scsi_qla_host *vha,
 +	struct qla_tgt_cmd *cmd, void *ctio)
  {
 -	uint32_t total_leaked;
 -
 -	total_leaked = vha->hw->tgt.num_qfull_cmds_dropped;
 +	struct qla_tgt_srr_ctio *sc;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_srr_imm *imm;
  
 -	if (vha->hw->tgt.leak_exchg_thresh_hold &&
 -	    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {
 +	tgt->ctio_srr_id++;
  
 -		ql_dbg(ql_dbg_tgt, vha, 0xe079,
 -		    "Chip reset due to exchange starvation: %d/%d.\n",
 -		    total_leaked, vha->hw->cur_fw_xcb_count);
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf019,
 +	    "qla_target(%d): CTIO with SRR status received\n", vha->vp_idx);
  
 -		if (IS_P3P_TYPE(vha->hw))
 -			set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
 -		else
 -			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
 -		qla2xxx_wake_dpc(vha);
 +	if (!ctio) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf055,
 +		    "qla_target(%d): SRR CTIO, but ctio is NULL\n",
 +		    vha->vp_idx);
 +		return -EINVAL;
  	}
  
 -}
 -
 -int qlt_abort_cmd(struct qla_tgt_cmd *cmd)
 -{
 -	struct qla_tgt *tgt = cmd->tgt;
 -	struct scsi_qla_host *vha = tgt->vha;
 -	struct se_cmd *se_cmd = &cmd->se_cmd;
 -	unsigned long flags;
 +	sc = kzalloc(sizeof(*sc), GFP_ATOMIC);
 +	if (sc != NULL) {
 +		sc->cmd = cmd;
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		sc->srr_id = tgt->ctio_srr_id;
 +		list_add_tail(&sc->srr_list_entry,
 +		    &tgt->srr_ctio_list);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01a,
 +		    "CTIO SRR %p added (id %d)\n", sc, sc->srr_id);
 +		if (tgt->imm_srr_id == tgt->ctio_srr_id) {
 +			int found = 0;
 +			list_for_each_entry(imm, &tgt->srr_imm_list,
 +			    srr_list_entry) {
 +				if (imm->srr_id == sc->srr_id) {
 +					found = 1;
 +					break;
 +				}
 +			}
 +			if (found) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01b,
 +				    "Scheduling srr work\n");
 +				schedule_work(&tgt->srr_work);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf056,
 +				    "qla_target(%d): imm_srr_id "
 +				    "== ctio_srr_id (%d), but there is no "
 +				    "corresponding SRR IMM, deleting CTIO "
 +				    "SRR %p\n", vha->vp_idx,
 +				    tgt->ctio_srr_id, sc);
 +				list_del(&sc->srr_list_entry);
 +				spin_unlock(&tgt->srr_lock);
 +
 +				kfree(sc);
 +				return -EINVAL;
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
 +	} else {
 +		struct qla_tgt_srr_imm *ti;
  
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
 -	    "qla_target(%d): terminating exchange for aborted cmd=%p "
 -	    "(se_cmd=%p, tag=%llu)", vha->vp_idx, cmd, &cmd->se_cmd,
 -	    se_cmd->tag);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf057,
 +		    "qla_target(%d): Unable to allocate SRR CTIO entry\n",
 +		    vha->vp_idx);
 +		spin_lock(&tgt->srr_lock);
 +		list_for_each_entry_safe(imm, ti, &tgt->srr_imm_list,
 +		    srr_list_entry) {
 +			if (imm->srr_id == tgt->ctio_srr_id) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01c,
 +				    "IMM SRR %p deleted (id %d)\n",
 +				    imm, imm->srr_id);
 +				list_del(&imm->srr_list_entry);
 +				qlt_reject_free_srr_imm(vha, imm, 1);
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
  
 -	spin_lock_irqsave(&cmd->cmd_lock, flags);
 -	if (cmd->aborted) {
 -		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
 -		/*
 -		 * It's normal to see 2 calls in this path:
 -		 *  1) XFER Rdy completion + CMD_T_ABORT
 -		 *  2) TCM TMR - drain_state_list
 -		 */
 -	        ql_dbg(ql_dbg_tgt_mgt, vha, 0xffff,
 -			"multiple abort. %p transport_state %x, t_state %x,"
 -			" se_cmd_flags %x \n", cmd, cmd->se_cmd.transport_state,
 -			cmd->se_cmd.t_state,cmd->se_cmd.se_cmd_flags);
 -		return EIO;
 +		return -ENOMEM;
  	}
 -	cmd->aborted = 1;
 -	cmd->trc_flags |= TRC_ABORT;
 -	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
  
 -	qlt_send_term_exchange(vha, cmd, &cmd->atio, 0, 1);
  	return 0;
  }
 -EXPORT_SYMBOL(qlt_abort_cmd);
 -
 -void qlt_free_cmd(struct qla_tgt_cmd *cmd)
 -{
 -	struct qla_tgt_sess *sess = cmd->sess;
 -
 -	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,
 -	    "%s: se_cmd[%p] ox_id %04x\n",
 -	    __func__, &cmd->se_cmd,
 -	    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
 -
 -	BUG_ON(cmd->cmd_in_wq);
 -
 -	if (cmd->sg_mapped)
 -		qlt_unmap_sg(cmd->vha, cmd);
 -
 -	if (!cmd->q_full)
 -		qlt_decr_num_pend_cmds(cmd->vha);
 -
 -	BUG_ON(cmd->sg_mapped);
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	if (unlikely(cmd->free_sg))
 -		kfree(cmd->sg);
 -
 -	if (!sess || !sess->se_sess) {
 -		WARN_ON(1);
 -		return;
 -	}
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 -}
 -EXPORT_SYMBOL(qlt_free_cmd);
  
++=======
++>>>>>>> 2c39b5ca2a8c (qla2xxx: Remove SRR code)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -2518,27 -3440,61 +2539,62 @@@ static void qlt_do_ctio_completion(stru
  
  		case CTIO_PORT_LOGGED_OUT:
  		case CTIO_PORT_UNAVAILABLE:
 -		{
 -			int logged_out =
 -				(status & 0xFFFF) == CTIO_PORT_LOGGED_OUT;
 -
  			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf059,
 -			    "qla_target(%d): CTIO with %s status %x "
 +			    "qla_target(%d): CTIO with PORT LOGGED "
 +			    "OUT (29) or PORT UNAVAILABLE (28) status %x "
  			    "received (state %x, se_cmd %p)\n", vha->vp_idx,
 -			    logged_out ? "PORT LOGGED OUT" : "PORT UNAVAILABLE",
  			    status, cmd->state, se_cmd);
 -
 -			if (logged_out && cmd->sess) {
 -				/*
 -				 * Session is already logged out, but we need
 -				 * to notify initiator, who's not aware of this
 -				 */
 -				cmd->sess->logout_on_delete = 0;
 -				cmd->sess->send_els_logo = 1;
 -				qlt_schedule_sess_for_deletion(cmd->sess, true);
 -			}
  			break;
++<<<<<<< HEAD
 +
 +		case CTIO_SRR_RECEIVED:
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05a,
 +			    "qla_target(%d): CTIO with SRR_RECEIVED"
 +			    " status %x received (state %x, se_cmd %p)\n",
 +			    vha->vp_idx, status, cmd->state, se_cmd);
 +			if (qlt_prepare_srr_ctio(vha, cmd, ctio) != 0)
 +				break;
 +			else
 +				return;
 +
++=======
+ 		}
+ 		case CTIO_DIF_ERROR: {
+ 			struct ctio_crc_from_fw *crc =
+ 				(struct ctio_crc_from_fw *)ctio;
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf073,
+ 			    "qla_target(%d): CTIO with DIF_ERROR status %x received (state %x, se_cmd %p) actual_dif[0x%llx] expect_dif[0x%llx]\n",
+ 			    vha->vp_idx, status, cmd->state, se_cmd,
+ 			    *((u64 *)&crc->actual_dif[0]),
+ 			    *((u64 *)&crc->expected_dif[0]));
+ 
+ 			if (qlt_handle_dif_error(vha, cmd, ctio)) {
+ 				if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
+ 					/* scsi Write/xfer rdy complete */
+ 					goto skip_term;
+ 				} else {
+ 					/* scsi read/xmit respond complete
+ 					 * call handle dif to send scsi status
+ 					 * rather than terminate exchange.
+ 					 */
+ 					cmd->state = QLA_TGT_STATE_PROCESSED;
+ 					ha->tgt.tgt_ops->handle_dif_err(cmd);
+ 					return;
+ 				}
+ 			} else {
+ 				/* Need to generate a SCSI good completion.
+ 				 * because FW did not send scsi status.
+ 				 */
+ 				status = 0;
+ 				goto skip_term;
+ 			}
+ 			break;
+ 		}
++>>>>>>> 2c39b5ca2a8c (qla2xxx: Remove SRR code)
  		default:
  			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05b,
 -			    "qla_target(%d): CTIO with error status 0x%x received (state %x, se_cmd %p\n",
 +			    "qla_target(%d): CTIO with error status "
 +			    "0x%x received (state %x, se_cmd %p\n",
  			    vha->vp_idx, status, cmd->state, se_cmd);
  			break;
  		}
@@@ -2955,495 -4008,311 +3011,498 @@@ static int qlt_abort_task(struct scsi_q
  	return __qlt_abort_task(vha, iocb, sess);
  }
  
 -void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
 +/*
 + * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
 + */
 +static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 +	struct imm_ntfy_from_isp *iocb)
  {
 -	if (fcport->tgt_session) {
 -		if (rc != MBS_COMMAND_COMPLETE) {
 -			ql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,
 -				"%s: se_sess %p / sess %p from"
 -				" port %8phC loop_id %#04x s_id %02x:%02x:%02x"
 -				" LOGO failed: %#x\n",
 -				__func__,
 -				fcport->tgt_session->se_sess,
 -				fcport->tgt_session,
 -				fcport->port_name, fcport->loop_id,
 -				fcport->d_id.b.domain, fcport->d_id.b.area,
 -				fcport->d_id.b.al_pa, rc);
 +	struct qla_hw_data *ha = vha->hw;
 +	int res = 0;
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
 +	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
 +	    vha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);
 +
 +	switch (iocb->u.isp24.status_subcode) {
 +	case ELS_PLOGI:
 +	case ELS_FLOGI:
 +	case ELS_PRLI:
 +	case ELS_LOGO:
 +	case ELS_PRLO:
 +		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 +		break;
 +	case ELS_PDISC:
 +	case ELS_ADISC:
 +	{
 +		struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +		if (tgt->link_reinit_iocb_pending) {
 +			qlt_send_notify_ack(vha, &tgt->link_reinit_iocb,
 +			    0, 0, 0, 0, 0, 0);
 +			tgt->link_reinit_iocb_pending = 0;
  		}
 +		res = 1; /* send notify ack */
 +		break;
 +	}
  
 -		fcport->tgt_session->logout_completed = 1;
 +	default:
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,
 +		    "qla_target(%d): Unsupported ELS command %x "
 +		    "received\n", vha->vp_idx, iocb->u.isp24.status_subcode);
 +		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 +		break;
  	}
 +
 +	return res;
  }
  
 -/*
 -* ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)
 -*
 -* Schedules sessions with matching port_id/loop_id but different wwn for
 -* deletion. Returns existing session with matching wwn if present.
 -* Null otherwise.
 -*/
 -static struct qla_tgt_sess *
 -qlt_find_sess_invalidate_other(struct qla_tgt *tgt, uint64_t wwn,
 -    port_id_t port_id, uint16_t loop_id, struct qla_tgt_sess **conflict_sess)
++<<<<<<< HEAD
 +static int qlt_set_data_offset(struct qla_tgt_cmd *cmd, uint32_t offset)
  {
 -	struct qla_tgt_sess *sess = NULL, *other_sess;
 -	uint64_t other_wwn;
 +#if 1
 +	/*
 +	 * FIXME: Reject non zero SRR relative offset until we can test
 +	 * this code properly.
 +	 */
 +	pr_debug("Rejecting non zero SRR rel_offs: %u\n", offset);
 +	return -1;
 +#else
 +	struct scatterlist *sg, *sgp, *sg_srr, *sg_srr_start = NULL;
 +	size_t first_offset = 0, rem_offset = offset, tmp = 0;
 +	int i, sg_srr_cnt, bufflen = 0;
 +
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe023,
 +	    "Entering qla_tgt_set_data_offset: cmd: %p, cmd->sg: %p, "
 +	    "cmd->sg_cnt: %u, direction: %d\n",
 +	    cmd, cmd->sg, cmd->sg_cnt, cmd->dma_data_direction);
 +
 +	if (!cmd->sg || !cmd->sg_cnt) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe055,
 +		    "Missing cmd->sg or zero cmd->sg_cnt in"
 +		    " qla_tgt_set_data_offset\n");
 +		return -EINVAL;
 +	}
 +	/*
 +	 * Walk the current cmd->sg list until we locate the new sg_srr_start
 +	 */
 +	for_each_sg(cmd->sg, sg, cmd->sg_cnt, i) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe024,
 +		    "sg[%d]: %p page: %p, length: %d, offset: %d\n",
 +		    i, sg, sg_page(sg), sg->length, sg->offset);
 +
 +		if ((sg->length + tmp) > offset) {
 +			first_offset = rem_offset;
 +			sg_srr_start = sg;
 +			ql_dbg(ql_dbg_tgt, cmd->vha, 0xe025,
 +			    "Found matching sg[%d], using %p as sg_srr_start, "
 +			    "and using first_offset: %zu\n", i, sg,
 +			    first_offset);
 +			break;
 +		}
 +		tmp += sg->length;
 +		rem_offset -= sg->length;
 +	}
  
 -	*conflict_sess = NULL;
 +	if (!sg_srr_start) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe056,
 +		    "Unable to locate sg_srr_start for offset: %u\n", offset);
 +		return -EINVAL;
 +	}
 +	sg_srr_cnt = (cmd->sg_cnt - i);
  
 -	list_for_each_entry(other_sess, &tgt->sess_list, sess_list_entry) {
 +	sg_srr = kzalloc(sizeof(struct scatterlist) * sg_srr_cnt, GFP_KERNEL);
 +	if (!sg_srr) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe057,
 +		    "Unable to allocate sgp\n");
 +		return -ENOMEM;
 +	}
 +	sg_init_table(sg_srr, sg_srr_cnt);
 +	sgp = &sg_srr[0];
 +	/*
 +	 * Walk the remaining list for sg_srr_start, mapping to the newly
 +	 * allocated sg_srr taking first_offset into account.
 +	 */
 +	for_each_sg(sg_srr_start, sg, sg_srr_cnt, i) {
 +		if (first_offset) {
 +			sg_set_page(sgp, sg_page(sg),
 +			    (sg->length - first_offset), first_offset);
 +			first_offset = 0;
 +		} else {
 +			sg_set_page(sgp, sg_page(sg), sg->length, 0);
 +		}
 +		bufflen += sgp->length;
  
 -		other_wwn = wwn_to_u64(other_sess->port_name);
 +		sgp = sg_next(sgp);
 +		if (!sgp)
 +			break;
 +	}
  
 -		if (wwn == other_wwn) {
 -			WARN_ON(sess);
 -			sess = other_sess;
 -			continue;
 -		}
 +	cmd->sg = sg_srr;
 +	cmd->sg_cnt = sg_srr_cnt;
 +	cmd->bufflen = bufflen;
 +	cmd->offset += offset;
 +	cmd->free_sg = 1;
  
 -		/* find other sess with nport_id collision */
 -		if (port_id.b24 == other_sess->s_id.b24) {
 -			if (loop_id != other_sess->loop_id) {
 -				ql_dbg(ql_dbg_tgt_tmr, tgt->vha, 0x1000c,
 -				    "Invalidating sess %p loop_id %d wwn %llx.\n",
 -				    other_sess, other_sess->loop_id, other_wwn);
 -
 -				/*
 -				 * logout_on_delete is set by default, but another
 -				 * session that has the same s_id/loop_id combo
 -				 * might have cleared it when requested this session
 -				 * deletion, so don't touch it
 -				 */
 -				qlt_schedule_sess_for_deletion(other_sess, true);
 -			} else {
 -				/*
 -				 * Another wwn used to have our s_id/loop_id
 -				 * kill the session, but don't free the loop_id
 -				 */
 -				other_sess->keep_nport_handle = 1;
 -				*conflict_sess = other_sess;
 -				qlt_schedule_sess_for_deletion(other_sess,
 -				    true);
 -			}
 -			continue;
 -		}
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe026, "New cmd->sg: %p\n", cmd->sg);
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe027, "New cmd->sg_cnt: %u\n",
 +	    cmd->sg_cnt);
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe028, "New cmd->bufflen: %u\n",
 +	    cmd->bufflen);
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe029, "New cmd->offset: %u\n",
 +	    cmd->offset);
  
 -		/* find other sess with nport handle collision */
 -		if (loop_id == other_sess->loop_id) {
 -			ql_dbg(ql_dbg_tgt_tmr, tgt->vha, 0x1000d,
 -			       "Invalidating sess %p loop_id %d wwn %llx.\n",
 -			       other_sess, other_sess->loop_id, other_wwn);
 +	if (cmd->sg_cnt < 0)
 +		BUG();
  
 -			/* Same loop_id but different s_id
 -			 * Ok to kill and logout */
 -			qlt_schedule_sess_for_deletion(other_sess, true);
 -		}
 -	}
 +	if (cmd->bufflen < 0)
 +		BUG();
  
 -	return sess;
 +	return 0;
 +#endif
  }
  
 -/* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */
 -static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)
 +static inline int qlt_srr_adjust_data(struct qla_tgt_cmd *cmd,
 +	uint32_t srr_rel_offs, int *xmit_type)
  {
 -	struct qla_tgt_sess_op *op;
 -	struct qla_tgt_cmd *cmd;
 -	uint32_t key;
 -	int count = 0;
 -
 -	key = (((u32)s_id->b.domain << 16) |
 -	       ((u32)s_id->b.area   <<  8) |
 -	       ((u32)s_id->b.al_pa));
 -
 -	spin_lock(&vha->cmd_list_lock);
 -	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
 -		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
 -		if (op_key == key) {
 -			op->aborted = true;
 -			count++;
 -		}
 -	}
 -	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
 -		uint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
 -		if (cmd_key == key) {
 -			cmd->aborted = 1;
 -			count++;
 -		}
 -	}
 -	spin_unlock(&vha->cmd_list_lock);
 +	int res = 0, rel_offs;
 +
 +	rel_offs = srr_rel_offs - cmd->offset;
 +	ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf027, "srr_rel_offs=%d, rel_offs=%d",
 +	    srr_rel_offs, rel_offs);
 +
 +	*xmit_type = QLA_TGT_XMIT_ALL;
 +
 +	if (rel_offs < 0) {
 +		ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf062,
 +		    "qla_target(%d): SRR rel_offs (%d) < 0",
 +		    cmd->vha->vp_idx, rel_offs);
 +		res = -1;
 +	} else if (rel_offs == cmd->bufflen)
 +		*xmit_type = QLA_TGT_XMIT_STATUS;
 +	else if (rel_offs > 0)
 +		res = qlt_set_data_offset(cmd, rel_offs);
  
 -	return count;
 +	return res;
  }
  
 -/*
 - * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
 - */
 -static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *iocb)
 +/* No locks, thread context */
 +static void qlt_handle_srr(struct scsi_qla_host *vha,
 +	struct qla_tgt_srr_ctio *sctio, struct qla_tgt_srr_imm *imm)
  {
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 +	struct imm_ntfy_from_isp *ntfy =
 +	    (struct imm_ntfy_from_isp *)&imm->imm_ntfy;
  	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt_sess *sess = NULL, *conflict_sess = NULL;
 -	uint64_t wwn;
 -	port_id_t port_id;
 -	uint16_t loop_id;
 -	uint16_t wd3_lo;
 -	int res = 0;
 -	qlt_plogi_ack_t *pla;
 +	struct qla_tgt_cmd *cmd = sctio->cmd;
 +	struct se_cmd *se_cmd = &cmd->se_cmd;
  	unsigned long flags;
 +	int xmit_type = 0, resp = 0;
 +	uint32_t offset;
 +	uint16_t srr_ui;
  
 -	wwn = wwn_to_u64(iocb->u.isp24.port_name);
 +	offset = le32_to_cpu(ntfy->u.isp24.srr_rel_offs);
 +	srr_ui = ntfy->u.isp24.srr_ui;
  
 -	port_id.b.domain = iocb->u.isp24.port_id[2];
 -	port_id.b.area   = iocb->u.isp24.port_id[1];
 -	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
 -	port_id.b.rsvd_1 = 0;
 -
 -	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
 -
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
 -	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
 -	    vha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);
 -
 -	/* res = 1 means ack at the end of thread
 -	 * res = 0 means ack async/later.
 -	 */
 -	switch (iocb->u.isp24.status_subcode) {
 -	case ELS_PLOGI:
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf028, "SRR cmd %p, srr_ui %x\n",
 +	    cmd, srr_ui);
  
 -		/* Mark all stale commands in qla_tgt_wq for deletion */
 -		abort_cmds_for_s_id(vha, &port_id);
 +	switch (srr_ui) {
 +	case SRR_IU_STATUS:
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
 +		qlt_send_notify_ack(vha, ntfy,
 +		    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +		xmit_type = QLA_TGT_XMIT_STATUS;
 +		resp = 1;
 +		break;
 +	case SRR_IU_DATA_IN:
 +		if (!cmd->sg || !cmd->sg_cnt) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf063,
 +			    "Unable to process SRR_IU_DATA_IN due to"
 +			    " missing cmd->sg, state: %d\n", cmd->state);
 +			dump_stack();
 +			goto out_reject;
 +		}
 +		if (se_cmd->scsi_status != 0) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe02a,
 +			    "Rejecting SRR_IU_DATA_IN with non GOOD "
 +			    "scsi_status\n");
 +			goto out_reject;
 +		}
 +		cmd->bufflen = se_cmd->data_length;
  
 -		if (wwn) {
 -			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 -			sess = qlt_find_sess_invalidate_other(tgt, wwn,
 -			    port_id, loop_id, &conflict_sess);
 -			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 +		if (qlt_has_data(cmd)) {
 +			if (qlt_srr_adjust_data(cmd, offset, &xmit_type) != 0)
 +				goto out_reject;
 +			spin_lock_irqsave(&ha->hardware_lock, flags);
 +			qlt_send_notify_ack(vha, ntfy,
 +			    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
 +			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +			resp = 1;
 +		} else {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf064,
 +			    "qla_target(%d): SRR for in data for cmd "
 +			    "without them (tag %d, SCSI status %d), "
 +			    "reject", vha->vp_idx, cmd->tag,
 +			    cmd->se_cmd.scsi_status);
 +			goto out_reject;
 +		}
 +		break;
 +	case SRR_IU_DATA_OUT:
 +		if (!cmd->sg || !cmd->sg_cnt) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf065,
 +			    "Unable to process SRR_IU_DATA_OUT due to"
 +			    " missing cmd->sg\n");
 +			dump_stack();
 +			goto out_reject;
  		}
 +		if (se_cmd->scsi_status != 0) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe02b,
 +			    "Rejecting SRR_IU_DATA_OUT"
 +			    " with non GOOD scsi_status\n");
 +			goto out_reject;
 +		}
 +		cmd->bufflen = se_cmd->data_length;
  
 -		if (IS_SW_RESV_ADDR(port_id) || (!sess && !conflict_sess)) {
 -			res = 1;
 -			break;
 +		if (qlt_has_data(cmd)) {
 +			if (qlt_srr_adjust_data(cmd, offset, &xmit_type) != 0)
 +				goto out_reject;
 +			spin_lock_irqsave(&ha->hardware_lock, flags);
 +			qlt_send_notify_ack(vha, ntfy,
 +			    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
 +			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +			if (xmit_type & QLA_TGT_XMIT_DATA)
 +				qlt_rdy_to_xfer(cmd);
 +		} else {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf066,
 +			    "qla_target(%d): SRR for out data for cmd "
 +			    "without them (tag %d, SCSI status %d), "
 +			    "reject", vha->vp_idx, cmd->tag,
 +			    cmd->se_cmd.scsi_status);
 +			goto out_reject;
  		}
 +		break;
 +	default:
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf067,
 +		    "qla_target(%d): Unknown srr_ui value %x",
 +		    vha->vp_idx, srr_ui);
 +		goto out_reject;
 +	}
  
 -		pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
 -		if (!pla) {
 -			qlt_send_term_imm_notif(vha, iocb, 1);
 +	/* Transmit response in case of status and data-in cases */
 +	if (resp)
 +		qlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);
  
 -			res = 0;
 -			break;
 -		}
 +	return;
  
 -		res = 0;
 +out_reject:
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	qlt_send_notify_ack(vha, ntfy, 0, 0, 0,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT,
 +	    NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);
 +	if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
 +		cmd->state = QLA_TGT_STATE_DATA_IN;
 +		dump_stack();
 +	} else
 +		qlt_send_term_exchange(vha, cmd, &cmd->atio, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +}
  
 -		if (conflict_sess)
 -			qlt_plogi_ack_link(vha, pla, conflict_sess,
 -			    QLT_PLOGI_LINK_CONFLICT);
 +static void qlt_reject_free_srr_imm(struct scsi_qla_host *vha,
 +	struct qla_tgt_srr_imm *imm, int ha_locked)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	unsigned long flags = 0;
  
 -		if (!sess)
 -			break;
 +#ifndef __CHECKER__
 +	if (!ha_locked)
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
 +#endif
  
 -		qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
 -		 /*
 -		  * Under normal circumstances we want to release nport handle
 -		  * during LOGO process to avoid nport handle leaks inside FW.
 -		  * The exception is when LOGO is done while another PLOGI with
 -		  * the same nport handle is waiting as might be the case here.
 -		  * Note: there is always a possibily of a race where session
 -		  * deletion has already started for other reasons (e.g. ACL
 -		  * removal) and now PLOGI arrives:
 -		  * 1. if PLOGI arrived in FW after nport handle has been freed,
 -		  *    FW must have assigned this PLOGI a new/same handle and we
 -		  *    can proceed ACK'ing it as usual when session deletion
 -		  *    completes.
 -		  * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
 -		  *    bit reached it, the handle has now been released. We'll
 -		  *    get an error when we ACK this PLOGI. Nothing will be sent
 -		  *    back to initiator. Initiator should eventually retry
 -		  *    PLOGI and situation will correct itself.
 -		  */
 -		sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
 -					   (sess->s_id.b24 == port_id.b24));
 -		qlt_schedule_sess_for_deletion(sess, true);
 -		break;
 +	qlt_send_notify_ack(vha, (void *)&imm->imm_ntfy, 0, 0, 0,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT,
 +	    NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);
  
 -	case ELS_PRLI:
 -		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
 +#ifndef __CHECKER__
 +	if (!ha_locked)
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +#endif
  
 -		if (wwn) {
 -			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 -			sess = qlt_find_sess_invalidate_other(tgt, wwn, port_id,
 -			    loop_id, &conflict_sess);
 -			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 -		}
 +	kfree(imm);
 +}
  
 -		if (conflict_sess) {
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09b,
 -			    "PRLI with conflicting sess %p port %8phC\n",
 -			    conflict_sess, conflict_sess->port_name);
 -			qlt_send_term_imm_notif(vha, iocb, 1);
 -			res = 0;
 -			break;
 -		}
 +static void qlt_handle_srr_work(struct work_struct *work)
 +{
 +	struct qla_tgt *tgt = container_of(work, struct qla_tgt, srr_work);
 +	struct scsi_qla_host *vha = tgt->vha;
 +	struct qla_tgt_srr_ctio *sctio;
 +	unsigned long flags;
  
 -		if (sess != NULL) {
 -			if (sess->deleted) {
 -				/*
 -				 * Impatient initiator sent PRLI before last
 -				 * PLOGI could finish. Will force him to re-try,
 -				 * while last one finishes.
 -				 */
 -				ql_log(ql_log_warn, sess->vha, 0xf095,
 -				    "sess %p PRLI received, before plogi ack.\n",
 -				    sess);
 -				qlt_send_term_imm_notif(vha, iocb, 1);
 -				res = 0;
 -				break;
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf029, "Entering SRR work (tgt %p)\n",
 +	    tgt);
 +
 +restart:
 +	spin_lock_irqsave(&tgt->srr_lock, flags);
 +	list_for_each_entry(sctio, &tgt->srr_ctio_list, srr_list_entry) {
 +		struct qla_tgt_srr_imm *imm, *i, *ti;
 +		struct qla_tgt_cmd *cmd;
 +		struct se_cmd *se_cmd;
 +
 +		imm = NULL;
 +		list_for_each_entry_safe(i, ti, &tgt->srr_imm_list,
 +						srr_list_entry) {
 +			if (i->srr_id == sctio->srr_id) {
 +				list_del(&i->srr_list_entry);
 +				if (imm) {
 +					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf068,
 +					  "qla_target(%d): There must be "
 +					  "only one IMM SRR per CTIO SRR "
 +					  "(IMM SRR %p, id %d, CTIO %p\n",
 +					  vha->vp_idx, i, i->srr_id, sctio);
 +					qlt_reject_free_srr_imm(tgt->vha, i, 0);
 +				} else
 +					imm = i;
  			}
 +		}
  
 -			/*
 -			 * This shouldn't happen under normal circumstances,
 -			 * since we have deleted the old session during PLOGI
 -			 */
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,
 -			    "PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\n",
 -			    sess->loop_id, sess, iocb->u.isp24.nport_handle);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02a,
 +		    "IMM SRR %p, CTIO SRR %p (id %d)\n", imm, sctio,
 +		    sctio->srr_id);
  
 -			sess->local = 0;
 -			sess->loop_id = loop_id;
 -			sess->s_id = port_id;
 +		if (imm == NULL) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02b,
 +			    "Not found matching IMM for SRR CTIO (id %d)\n",
 +			    sctio->srr_id);
 +			continue;
 +		} else
 +			list_del(&sctio->srr_list_entry);
  
 -			if (wd3_lo & BIT_7)
 -				sess->conf_compl_supported = 1;
 +		spin_unlock_irqrestore(&tgt->srr_lock, flags);
  
 +		cmd = sctio->cmd;
 +		/*
 +		 * Reset qla_tgt_cmd SRR values and SGL pointer+count to follow
 +		 * tcm_qla2xxx_write_pending() and tcm_qla2xxx_queue_data_in()
 +		 * logic..
 +		 */
 +		cmd->offset = 0;
 +		if (cmd->free_sg) {
 +			kfree(cmd->sg);
 +			cmd->sg = NULL;
 +			cmd->free_sg = 0;
  		}
 -		res = 1; /* send notify ack */
 +		se_cmd = &cmd->se_cmd;
  
 -		/* Make session global (not used in fabric mode) */
 -		if (ha->current_topology != ISP_CFG_F) {
 -			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
 -			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
 -			qla2xxx_wake_dpc(vha);
 -		} else {
 -			/* todo: else - create sess here. */
 -			res = 1; /* send notify ack */
 -		}
 +		cmd->sg_cnt = se_cmd->t_data_nents;
 +		cmd->sg = se_cmd->t_data_sg;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02c,
 +		    "SRR cmd %p (se_cmd %p, tag %d, op %x), "
 +		    "sg_cnt=%d, offset=%d", cmd, &cmd->se_cmd, cmd->tag,
 +		    se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
 +		    cmd->sg_cnt, cmd->offset);
 +
 +		qlt_handle_srr(vha, sctio, imm);
  
 -		break;
 +		kfree(imm);
 +		kfree(sctio);
 +		goto restart;
 +	}
 +	spin_unlock_irqrestore(&tgt->srr_lock, flags);
 +}
  
 -	case ELS_LOGO:
 -	case ELS_PRLO:
 -		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 -		break;
 -	case ELS_PDISC:
 -	case ELS_ADISC:
 -	{
 -		struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 -		if (tgt->link_reinit_iocb_pending) {
 -			qlt_send_notify_ack(vha, &tgt->link_reinit_iocb,
 -			    0, 0, 0, 0, 0, 0);
 -			tgt->link_reinit_iocb_pending = 0;
 +/* ha->hardware_lock supposed to be held on entry */
 +static void qlt_prepare_srr_imm(struct scsi_qla_host *vha,
 +	struct imm_ntfy_from_isp *iocb)
 +{
 +	struct qla_tgt_srr_imm *imm;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_srr_ctio *sctio;
 +
 +	tgt->imm_srr_id++;
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02d, "qla_target(%d): SRR received\n",
 +	    vha->vp_idx);
 +
 +	imm = kzalloc(sizeof(*imm), GFP_ATOMIC);
 +	if (imm != NULL) {
 +		memcpy(&imm->imm_ntfy, iocb, sizeof(imm->imm_ntfy));
 +
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		imm->srr_id = tgt->imm_srr_id;
 +		list_add_tail(&imm->srr_list_entry,
 +		    &tgt->srr_imm_list);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02e,
 +		    "IMM NTFY SRR %p added (id %d, ui %x)\n",
 +		    imm, imm->srr_id, iocb->u.isp24.srr_ui);
 +		if (tgt->imm_srr_id == tgt->ctio_srr_id) {
 +			int found = 0;
 +			list_for_each_entry(sctio, &tgt->srr_ctio_list,
 +			    srr_list_entry) {
 +				if (sctio->srr_id == imm->srr_id) {
 +					found = 1;
 +					break;
 +				}
 +			}
 +			if (found) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02f, "%s",
 +				    "Scheduling srr work\n");
 +				schedule_work(&tgt->srr_work);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf030,
 +				    "qla_target(%d): imm_srr_id "
 +				    "== ctio_srr_id (%d), but there is no "
 +				    "corresponding SRR CTIO, deleting IMM "
 +				    "SRR %p\n", vha->vp_idx, tgt->ctio_srr_id,
 +				    imm);
 +				list_del(&imm->srr_list_entry);
 +
 +				kfree(imm);
 +
 +				spin_unlock(&tgt->srr_lock);
 +				goto out_reject;
 +			}
  		}
 -		res = 1; /* send notify ack */
 -		break;
 +		spin_unlock(&tgt->srr_lock);
 +	} else {
 +		struct qla_tgt_srr_ctio *ts;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf069,
 +		    "qla_target(%d): Unable to allocate SRR IMM "
 +		    "entry, SRR request will be rejected\n", vha->vp_idx);
 +
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		list_for_each_entry_safe(sctio, ts, &tgt->srr_ctio_list,
 +		    srr_list_entry) {
 +			if (sctio->srr_id == tgt->imm_srr_id) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf031,
 +				    "CTIO SRR %p deleted (id %d)\n",
 +				    sctio, sctio->srr_id);
 +				list_del(&sctio->srr_list_entry);
 +				qlt_send_term_exchange(vha, sctio->cmd,
 +				    &sctio->cmd->atio, 1);
 +				kfree(sctio);
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
 +		goto out_reject;
  	}
  
 -	case ELS_FLOGI:	/* should never happen */
 -	default:
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,
 -		    "qla_target(%d): Unsupported ELS command %x "
 -		    "received\n", vha->vp_idx, iocb->u.isp24.status_subcode);
 -		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 -		break;
 -	}
 +	return;
  
 -	return res;
 +out_reject:
 +	qlt_send_notify_ack(vha, iocb, 0, 0, 0,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT,
 +	    NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);
  }
  
++=======
++>>>>>>> 2c39b5ca2a8c (qla2xxx: Remove SRR code)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -4318,13 -5384,9 +4371,9 @@@ int qlt_add_target(struct qla_hw_data *
  	spin_lock_init(&tgt->sess_work_lock);
  	INIT_WORK(&tgt->sess_work, qlt_sess_work_fn);
  	INIT_LIST_HEAD(&tgt->sess_works_list);
- 	spin_lock_init(&tgt->srr_lock);
- 	INIT_LIST_HEAD(&tgt->srr_ctio_list);
- 	INIT_LIST_HEAD(&tgt->srr_imm_list);
- 	INIT_WORK(&tgt->srr_work, qlt_handle_srr_work);
  	atomic_set(&tgt->tgt_global_resets_count, 0);
  
 -	base_vha->vha_tgt.qla_tgt = tgt;
 +	ha->tgt.qla_tgt = tgt;
  
  	ql_dbg(ql_dbg_tgt, base_vha, 0xe067,
  		"qla_target(%d): using 64 Bit PCI addressing",
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,f72bd0755a59..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -902,19 -1072,15 +893,25 @@@ struct qla_tgt_prm 
  	int sense_buffer_len;
  	int residual;
  	int add_status_pkt;
 -	/* dif */
 -	struct scatterlist *prot_sg;
 -	uint16_t prot_seg_cnt;
 -	uint16_t tot_dsds;
  };
  
++<<<<<<< HEAD
 +struct qla_tgt_srr_imm {
 +	struct list_head srr_list_entry;
 +	int srr_id;
 +	struct imm_ntfy_from_isp imm_ntfy;
 +};
 +
 +struct qla_tgt_srr_ctio {
 +	struct list_head srr_list_entry;
 +	int srr_id;
 +	struct qla_tgt_cmd *cmd;
 +};
++=======
+ /* Check for Switch reserved address */
+ #define IS_SW_RESV_ADDR(_s_id) \
+ 	((_s_id.b.domain == 0xff) && (_s_id.b.area == 0xfc))
++>>>>>>> 2c39b5ca2a8c (qla2xxx: Remove SRR code)
  
  #define QLA_TGT_XMIT_DATA		1
  #define QLA_TGT_XMIT_STATUS		2
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
