udp: fix potential infinite loop in SO_REUSEPORT logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Dumazet <edumazet@google.com>
commit ed0dfffd7dcd3f517b1507929642c2aed4ef00fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ed0dfffd.failed

Using a combination of connected and un-connected sockets, Dmitry
was able to trigger soft lockups with his fuzzer.

The problem is that sockets in the SO_REUSEPORT array might have
different scores.

Right after sk2=socket(), setsockopt(sk2,...,SO_REUSEPORT, on) and
bind(sk2, ...), but _before_ the connect(sk2) is done, sk2 is added into
the soreuseport array, with a score which is smaller than the score of
first socket sk1 found in hash table (I am speaking of the regular UDP
hash table), if sk1 had the connect() done, giving a +8 to its score.

hash bucket [X] -> sk1 -> sk2 -> NULL

sk1 score = 14  (because it did a connect())
sk2 score = 6

SO_REUSEPORT fast selection is an optimization. If it turns out the
score of the selected socket does not match score of first socket, just
fallback to old SO_REUSEPORT logic instead of trying to be too smart.

Normal SO_REUSEPORT users do not mix different kind of sockets, as this
mechanism is used for load balance traffic.

Fixes: e32ea7e74727 ("soreuseport: fast reuseport UDP socket selection")
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Craig Gallek <kraigatgoog@gmail.com>
	Acked-by: Craig Gallek <kraig@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed0dfffd7dcd3f517b1507929642c2aed4ef00fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index 65a7d1f16a3d,be0b21852b13..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -459,6 -515,17 +460,20 @@@ begin
  			if (reuseport) {
  				hash = udp_ehashfn(net, daddr, hnum,
  						   saddr, sport);
++<<<<<<< HEAD
++=======
+ 				if (select_ok) {
+ 					struct sock *sk2;
+ 
+ 					sk2 = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 					if (sk2) {
+ 						result = sk2;
+ 						select_ok = false;
+ 						goto found;
+ 					}
+ 				}
++>>>>>>> ed0dfffd7dcd (udp: fix potential infinite loop in SO_REUSEPORT logic)
  				matches = 1;
  			}
  		} else if (score == badness && reuseport) {
@@@ -540,6 -609,17 +556,20 @@@ begin
  			if (reuseport) {
  				hash = udp_ehashfn(net, daddr, hnum,
  						   saddr, sport);
++<<<<<<< HEAD
++=======
+ 				if (select_ok) {
+ 					struct sock *sk2;
+ 
+ 					sk2 = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 					if (sk2) {
+ 						result = sk2;
+ 						select_ok = false;
+ 						goto found;
+ 					}
+ 				}
++>>>>>>> ed0dfffd7dcd (udp: fix potential infinite loop in SO_REUSEPORT logic)
  				matches = 1;
  			}
  		} else if (score == badness && reuseport) {
diff --cc net/ipv6/udp.c
index f5a8a12b48a5,22e28a44e3c8..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -252,9 -273,19 +253,23 @@@ begin
  			if (reuseport) {
  				hash = udp6_ehashfn(net, daddr, hnum,
  						    saddr, sport);
++<<<<<<< HEAD
++=======
+ 				if (select_ok) {
+ 					struct sock *sk2;
+ 
+ 					sk2 = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 					if (sk2) {
+ 						result = sk2;
+ 						select_ok = false;
+ 						goto found;
+ 					}
+ 				}
++>>>>>>> ed0dfffd7dcd (udp: fix potential infinite loop in SO_REUSEPORT logic)
  				matches = 1;
 -			}
 +			} else if (score == SCORE2_MAX)
 +				goto exact_match;
  		} else if (score == badness && reuseport) {
  			matches++;
  			if (reciprocal_scale(hash, matches) == 0)
@@@ -333,6 -366,17 +349,20 @@@ begin
  			if (reuseport) {
  				hash = udp6_ehashfn(net, daddr, hnum,
  						    saddr, sport);
++<<<<<<< HEAD
++=======
+ 				if (select_ok) {
+ 					struct sock *sk2;
+ 
+ 					sk2 = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 					if (sk2) {
+ 						result = sk2;
+ 						select_ok = false;
+ 						goto found;
+ 					}
+ 				}
++>>>>>>> ed0dfffd7dcd (udp: fix potential infinite loop in SO_REUSEPORT logic)
  				matches = 1;
  			}
  		} else if (score == badness && reuseport) {
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
