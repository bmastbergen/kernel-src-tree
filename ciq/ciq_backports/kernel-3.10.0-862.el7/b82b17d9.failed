net: ixgbe: add support for tc_u32 offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] ixgbe: add support for tc_u32 offload (Ken Cox) [1452423]
Rebuild_FUZZ: 93.67%
commit-author John Fastabend <john.fastabend@gmail.com>
commit b82b17d929a692df1122fedc0ff4ddcef9cb6ad4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b82b17d9.failed

This adds initial support for offloading the u32 tc classifier. This
initial implementation only implements a few base matches and actions
to illustrate the use of the infrastructure patches.

However it is an interesting subset because it handles the u32 next
hdr logic to correctly map tcp packets from ip headers using the ihl
and protocol fields. After this is accepted we can extend the match
and action fields easily by updating the model header file.

Also only the drop action is supported initially.

Here is a short test script,

 #tc qdisc add dev eth4 ingress
 #tc filter add dev eth4 parent ffff: protocol ip \
	u32 ht 800: order 1 \
	match ip dst 15.0.0.1/32 match ip src 15.0.0.2/32 action drop

<-- hardware has dst/src ip match rule installed -->

 #tc filter del dev eth4 parent ffff: prio 49152
 #tc filter add dev eth4 parent ffff: protocol ip prio 99 \
	handle 1: u32 divisor 1
 #tc filter add dev eth4 protocol ip parent ffff: prio 99 \
	u32 ht 800: order 1 link 1: \
	offset at 0 mask 0f00 shift 6 plus 0 eat match ip protocol 6 ff
 #tc filter add dev eth4 parent ffff: protocol ip \
	u32 ht 1: order 3 match tcp src 23 ffff action drop

<-- hardware has tcp src port rule installed -->

 #tc qdisc del dev eth4 parent ffff:

<-- hardware cleaned up -->

	Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b82b17d929a692df1122fedc0ff4ddcef9cb6ad4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 0afaf44ddea2,abdfaead1ba1..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -50,9 -50,19 +50,11 @@@
  #include <linux/if_bridge.h>
  #include <linux/prefetch.h>
  #include <scsi/fc/fc_fcoe.h>
 +#include <net/udp_tunnel.h>
  #include <net/vxlan.h>
+ #include <net/pkt_cls.h>
+ #include <net/tc_act/tc_gact.h>
  
 -#ifdef CONFIG_OF
 -#include <linux/of_net.h>
 -#endif
 -
 -#ifdef CONFIG_SPARC
 -#include <asm/idprom.h>
 -#include <asm/prom.h>
 -#endif
 -
  #include "ixgbe.h"
  #include "ixgbe_common.h"
  #include "ixgbe_dcb_82599.h"
@@@ -8326,11 -8206,192 +8332,200 @@@ int ixgbe_setup_tc(struct net_device *d
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int __ixgbe_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
 +			    struct tc_to_netdev *tc)
 +{
 +	/* Only support egress tc setup for now */
 +	if (tc->type != TC_SETUP_MQPRIO)
++=======
+ static int ixgbe_delete_clsu32(struct ixgbe_adapter *adapter,
+ 			       struct tc_cls_u32_offload *cls)
+ {
+ 	int err;
+ 
+ 	spin_lock(&adapter->fdir_perfect_lock);
+ 	err = ixgbe_update_ethtool_fdir_entry(adapter, NULL, cls->knode.handle);
+ 	spin_unlock(&adapter->fdir_perfect_lock);
+ 	return err;
+ }
+ 
+ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
+ 				  __be16 protocol,
+ 				  struct tc_cls_u32_offload *cls)
+ {
+ 	u32 loc = cls->knode.handle & 0xfffff;
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	struct ixgbe_mat_field *field_ptr;
+ 	struct ixgbe_fdir_filter *input;
+ 	union ixgbe_atr_input mask;
+ #ifdef CONFIG_NET_CLS_ACT
+ 	const struct tc_action *a;
+ #endif
+ 	int i, err = 0;
+ 	u8 queue;
+ 	u32 handle;
+ 
+ 	memset(&mask, 0, sizeof(union ixgbe_atr_input));
+ 	handle = cls->knode.handle;
+ 
+ 	/* At the moment cls_u32 jumps to transport layer and skips past
+ 	 * L2 headers. The canonical method to match L2 frames is to use
+ 	 * negative values. However this is error prone at best but really
+ 	 * just broken because there is no way to "know" what sort of hdr
+ 	 * is in front of the transport layer. Fix cls_u32 to support L2
+ 	 * headers when needed.
+ 	 */
+ 	if (protocol != htons(ETH_P_IP))
+ 		return -EINVAL;
+ 
+ 	if (cls->knode.link_handle ||
+ 	    cls->knode.link_handle >= IXGBE_MAX_LINK_HANDLE) {
+ 		struct ixgbe_nexthdr *nexthdr = ixgbe_ipv4_jumps;
+ 		u32 uhtid = TC_U32_USERHTID(cls->knode.link_handle);
+ 
+ 		for (i = 0; nexthdr[i].jump; i++) {
+ 			if (nexthdr->o != cls->knode.sel->offoff ||
+ 			    nexthdr->s != cls->knode.sel->offshift ||
+ 			    nexthdr->m != cls->knode.sel->offmask ||
+ 			    /* do not support multiple key jumps its just mad */
+ 			    cls->knode.sel->nkeys > 1)
+ 				return -EINVAL;
+ 
+ 			if (nexthdr->off != cls->knode.sel->keys[0].off ||
+ 			    nexthdr->val != cls->knode.sel->keys[0].val ||
+ 			    nexthdr->mask != cls->knode.sel->keys[0].mask)
+ 				return -EINVAL;
+ 
+ 			if (uhtid >= IXGBE_MAX_LINK_HANDLE)
+ 				return -EINVAL;
+ 
+ 			adapter->jump_tables[uhtid] = nexthdr->jump;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	if (loc >= ((1024 << adapter->fdir_pballoc) - 2)) {
+ 		e_err(drv, "Location out of range\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* cls u32 is a graph starting at root node 0x800. The driver tracks
+ 	 * links and also the fields used to advance the parser across each
+ 	 * link (e.g. nexthdr/eat parameters from 'tc'). This way we can map
+ 	 * the u32 graph onto the hardware parse graph denoted in ixgbe_model.h
+ 	 * To add support for new nodes update ixgbe_model.h parse structures
+ 	 * this function _should_ be generic try not to hardcode values here.
+ 	 */
+ 	if (TC_U32_USERHTID(handle) == 0x800) {
+ 		field_ptr = adapter->jump_tables[0];
+ 	} else {
+ 		if (TC_U32_USERHTID(handle) >= ARRAY_SIZE(adapter->jump_tables))
+ 			return -EINVAL;
+ 
+ 		field_ptr = adapter->jump_tables[TC_U32_USERHTID(handle)];
+ 	}
+ 
+ 	if (!field_ptr)
+ 		return -EINVAL;
+ 
+ 	input = kzalloc(sizeof(*input), GFP_KERNEL);
+ 	if (!input)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < cls->knode.sel->nkeys; i++) {
+ 		int off = cls->knode.sel->keys[i].off;
+ 		__be32 val = cls->knode.sel->keys[i].val;
+ 		__be32 m = cls->knode.sel->keys[i].mask;
+ 		bool found_entry = false;
+ 		int j;
+ 
+ 		for (j = 0; field_ptr[j].val; j++) {
+ 			if (field_ptr[j].off == off &&
+ 			    field_ptr[j].mask == m) {
+ 				field_ptr[j].val(input, &mask, val, m);
+ 				input->filter.formatted.flow_type |=
+ 					field_ptr[j].type;
+ 				found_entry = true;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (!found_entry)
+ 			goto err_out;
+ 	}
+ 
+ 	mask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |
+ 				   IXGBE_ATR_L4TYPE_MASK;
+ 
+ 	if (input->filter.formatted.flow_type == IXGBE_ATR_FLOW_TYPE_IPV4)
+ 		mask.formatted.flow_type &= IXGBE_ATR_L4TYPE_IPV6_MASK;
+ 
+ #ifdef CONFIG_NET_CLS_ACT
+ 	if (list_empty(&cls->knode.exts->actions))
+ 		goto err_out;
+ 
+ 	list_for_each_entry(a, &cls->knode.exts->actions, list) {
+ 		if (!is_tcf_gact_shot(a))
+ 			goto err_out;
+ 	}
+ #endif
+ 
+ 	input->action = IXGBE_FDIR_DROP_QUEUE;
+ 	queue = IXGBE_FDIR_DROP_QUEUE;
+ 	input->sw_idx = loc;
+ 
+ 	spin_lock(&adapter->fdir_perfect_lock);
+ 
+ 	if (hlist_empty(&adapter->fdir_filter_list)) {
+ 		memcpy(&adapter->fdir_mask, &mask, sizeof(mask));
+ 		err = ixgbe_fdir_set_input_mask_82599(hw, &mask);
+ 		if (err)
+ 			goto err_out_w_lock;
+ 	} else if (memcmp(&adapter->fdir_mask, &mask, sizeof(mask))) {
+ 		err = -EINVAL;
+ 		goto err_out_w_lock;
+ 	}
+ 
+ 	ixgbe_atr_compute_perfect_hash_82599(&input->filter, &mask);
+ 	err = ixgbe_fdir_write_perfect_filter_82599(hw, &input->filter,
+ 						    input->sw_idx, queue);
+ 	if (!err)
+ 		ixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);
+ 	spin_unlock(&adapter->fdir_perfect_lock);
+ 
+ 	return err;
+ err_out_w_lock:
+ 	spin_unlock(&adapter->fdir_perfect_lock);
+ err_out:
+ 	kfree(input);
+ 	return -EINVAL;
+ }
+ 
+ int __ixgbe_setup_tc(struct net_device *dev, u32 handle, __be16 proto,
+ 		     struct tc_to_netdev *tc)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 
+ 	if (TC_H_MAJ(handle) == TC_H_MAJ(TC_H_INGRESS) &&
+ 	    tc->type == TC_SETUP_CLSU32) {
+ 		if (!(dev->features & NETIF_F_HW_TC))
+ 			return -EINVAL;
+ 
+ 		switch (tc->cls_u32->command) {
+ 		case TC_CLSU32_NEW_KNODE:
+ 		case TC_CLSU32_REPLACE_KNODE:
+ 			return ixgbe_configure_clsu32(adapter,
+ 						      proto, tc->cls_u32);
+ 		case TC_CLSU32_DELETE_KNODE:
+ 			return ixgbe_delete_clsu32(adapter, tc->cls_u32);
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	if (handle != TC_H_ROOT || tc->type != TC_SETUP_MQPRIO)
++>>>>>>> b82b17d929a6 (net: ixgbe: add support for tc_u32 offload)
  		return -EINVAL;
  
  	return ixgbe_setup_tc(dev, tc->tc);
@@@ -8418,25 -8477,23 +8611,18 @@@ static int ixgbe_set_features(struct ne
  		adapter->flags &= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
  
  		/* We cannot enable ATR if SR-IOV is enabled */
- 		if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)
- 			break;
- 
- 		/* We cannot enable ATR if we have 2 or more traffic classes */
- 		if (netdev_get_num_tc(netdev) > 1)
- 			break;
- 
- 		/* We cannot enable ATR if RSS is disabled */
- 		if (adapter->ring_feature[RING_F_RSS].limit <= 1)
- 			break;
- 
- 		/* A sample rate of 0 indicates ATR disabled */
- 		if (!adapter->atr_sample_rate)
- 			break;
- 
- 		adapter->flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
- 		break;
+ 		if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED ||
+ 		    /* We cannot enable ATR if we have 2 or more tcs */
+ 		    (netdev_get_num_tc(netdev) > 1) ||
+ 		    /* We cannot enable ATR if RSS is disabled */
+ 		    (adapter->ring_feature[RING_F_RSS].limit <= 1) ||
+ 		    /* A sample rate of 0 indicates ATR disabled */
+ 		    (!adapter->atr_sample_rate))
+ 			; /* do nothing not supported */
+ 		else /* otherwise supported and set the flag */
+ 			adapter->flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
  	}
  
 -	if (features & NETIF_F_HW_VLAN_CTAG_RX)
 -		ixgbe_vlan_strip_enable(adapter);
 -	else
 -		ixgbe_vlan_strip_disable(adapter);
 -
  	if (changed & NETIF_F_RXALL)
  		need_reset = true;
  
@@@ -8855,12 -8842,10 +9041,10 @@@ static const struct net_device_ops ixgb
  	.ndo_set_vf_rate	= ixgbe_ndo_set_vf_bw,
  	.ndo_set_vf_spoofchk	= ixgbe_ndo_set_vf_spoofchk,
  	.ndo_set_vf_rss_query_en = ixgbe_ndo_set_vf_rss_query_en,
 -	.ndo_set_vf_trust	= ixgbe_ndo_set_vf_trust,
 +	.extended.ndo_set_vf_trust	= ixgbe_ndo_set_vf_trust,
  	.ndo_get_vf_config	= ixgbe_ndo_get_vf_config,
  	.ndo_get_stats64	= ixgbe_get_stats64,
- #ifdef CONFIG_IXGBE_DCB
  	.ndo_setup_tc		= __ixgbe_setup_tc,
- #endif
  #ifdef CONFIG_NET_POLL_CONTROLLER
  	.ndo_poll_controller	= ixgbe_netpoll,
  #endif
@@@ -9198,45 -9201,38 +9382,55 @@@ skip_sriov
  			   NETIF_F_TSO |
  			   NETIF_F_TSO6 |
  			   NETIF_F_RXHASH |
 -			   NETIF_F_RXCSUM;
 +			   NETIF_F_RXCSUM |
 +			   NETIF_F_HW_CSUM;
  
 -	netdev->hw_features = netdev->features | NETIF_F_HW_L2FW_DOFFLOAD;
 +#define IXGBE_GSO_PARTIAL_FEATURES (NETIF_F_GSO_GRE | \
 +				    NETIF_F_GSO_GRE_CSUM | \
 +				    NETIF_F_GSO_IPIP | \
 +				    NETIF_F_GSO_SIT | \
 +				    NETIF_F_GSO_UDP_TUNNEL | \
 +				    NETIF_F_GSO_UDP_TUNNEL_CSUM)
  
 -	switch (adapter->hw.mac.type) {
 -	case ixgbe_mac_82599EB:
 -	case ixgbe_mac_X540:
 -	case ixgbe_mac_X550:
 -	case ixgbe_mac_X550EM_x:
 +	netdev->gso_partial_features = IXGBE_GSO_PARTIAL_FEATURES;
 +	netdev->features |= NETIF_F_GSO_PARTIAL |
 +			    IXGBE_GSO_PARTIAL_FEATURES;
 +
 +	if (hw->mac.type >= ixgbe_mac_82599EB)
  		netdev->features |= NETIF_F_SCTP_CRC;
++<<<<<<< HEAD
++=======
+ 		netdev->hw_features |= NETIF_F_SCTP_CRC |
+ 				       NETIF_F_NTUPLE |
+ 				       NETIF_F_HW_TC;
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> b82b17d929a6 (net: ixgbe: add support for tc_u32 offload)
 +
 +	/* copy netdev features into list of user selectable features */
 +	netdev->hw_features |= netdev->features |
 +			       NETIF_F_HW_VLAN_CTAG_FILTER |
 +			       NETIF_F_HW_VLAN_CTAG_RX |
 +			       NETIF_F_HW_VLAN_CTAG_TX |
 +			       NETIF_F_RXALL |
 +			       NETIF_F_HW_L2FW_DOFFLOAD;
  
 -	netdev->hw_features |= NETIF_F_RXALL;
 -	netdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 +	if (hw->mac.type >= ixgbe_mac_82599EB)
 +		netdev->hw_features |= NETIF_F_NTUPLE;
 +
 +	if (pci_using_dac)
 +		netdev->features |= NETIF_F_HIGHDMA;
  
 -	netdev->vlan_features |= NETIF_F_TSO;
 -	netdev->vlan_features |= NETIF_F_TSO6;
 -	netdev->vlan_features |= NETIF_F_IP_CSUM;
 -	netdev->vlan_features |= NETIF_F_IPV6_CSUM;
 -	netdev->vlan_features |= NETIF_F_SG;
 +	netdev->vlan_features |= netdev->features | NETIF_F_TSO_MANGLEID;
 +	netdev->hw_enc_features |= netdev->vlan_features;
 +	netdev->mpls_features |= NETIF_F_HW_CSUM;
  
 -	netdev->hw_enc_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 +	/* set this bit last since it cannot be part of vlan_features */
 +	netdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER |
 +			    NETIF_F_HW_VLAN_CTAG_RX |
 +			    NETIF_F_HW_VLAN_CTAG_TX;
  
  	netdev->priv_flags |= IFF_UNICAST_FLT;
  	netdev->priv_flags |= IFF_SUPP_NOFCS;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
index f0fd27d2f566..89bce6eba593 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@ -828,6 +828,9 @@ struct ixgbe_adapter {
 	u8 default_up;
 	unsigned long fwd_bitmask; /* Bitmask indicating in use pools */
 
+#define IXGBE_MAX_LINK_HANDLE 10
+	struct ixgbe_mat_field *jump_tables[IXGBE_MAX_LINK_HANDLE];
+
 /* maximum number of RETA entries among all devices supported by ixgbe
  * driver: currently it's x550 device in non-SRIOV mode
  */
@@ -965,6 +968,9 @@ s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
 					  u16 soft_id);
 void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
 					  union ixgbe_atr_input *mask);
+int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
+				    struct ixgbe_fdir_filter *input,
+				    u16 sw_idx);
 void ixgbe_set_rx_mode(struct net_device *netdev);
 #ifdef CONFIG_IXGBE_DCB
 void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter);
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index 72e704cb0047..a49237f61275 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -2553,9 +2553,9 @@ static int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
 	return ret;
 }
 
-static int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
-					   struct ixgbe_fdir_filter *input,
-					   u16 sw_idx)
+int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
+				    struct ixgbe_fdir_filter *input,
+				    u16 sw_idx)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct hlist_node *node2;
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
