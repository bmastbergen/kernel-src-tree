net: sched: remove redundant helpers tcf_exts_is_predicative and tcf_exts_is_available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: remove redundant helpers tcf_exts_is_predicative and tcf_exts_is_available (Ivan Vecera) [1445420]
Rebuild_FUZZ: 97.01%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 6fc6d06e5371507e68c6904a3423622b0e465b64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6fc6d06e.failed

These two helpers are doing the same as tcf_exts_has_actions, so remove
them and use tcf_exts_has_actions instead.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6fc6d06e5371507e68c6904a3423622b0e465b64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
diff --cc include/net/pkt_cls.h
index ddbf01b80b4c,817badf733b5..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -76,36 -110,70 +76,99 @@@ static inline void tcf_exts_init(struc
  #endif
  	exts->action = action;
  	exts->police = police;
 -	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * tcf_exts_is_predicative - check if a predicative extension is present
 + * @exts: tc filter extensions handle
 + *
 + * Returns 1 if a predicative extension is present, i.e. an extension which
 + * might cause further actions and thus overrule the regular tcf_result.
 + */
 +static inline int
 +tcf_exts_is_predicative(struct tcf_exts *exts)
 +{
 +#ifdef CONFIG_NET_CLS_ACT
 +	return !list_empty(&exts->actions);
 +#else
 +	return 0;
++=======
+ static inline void tcf_exts_to_list(const struct tcf_exts *exts,
+ 				    struct list_head *actions)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	int i;
+ 
+ 	for (i = 0; i < exts->nr_actions; i++) {
+ 		struct tc_action *a = exts->actions[i];
+ 
+ 		list_add_tail(&a->list, actions);
+ 	}
+ #endif
+ }
+ 
+ static inline void
+ tcf_exts_stats_update(const struct tcf_exts *exts,
+ 		      u64 bytes, u64 packets, u64 lastuse)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	int i;
+ 
+ 	preempt_disable();
+ 
+ 	for (i = 0; i < exts->nr_actions; i++) {
+ 		struct tc_action *a = exts->actions[i];
+ 
+ 		tcf_action_stats_update(a, bytes, packets, lastuse);
+ 	}
+ 
+ 	preempt_enable();
++>>>>>>> 6fc6d06e5371 (net: sched: remove redundant helpers tcf_exts_is_predicative and tcf_exts_is_available)
  #endif
  }
  
  /**
++<<<<<<< HEAD
 + * tcf_exts_is_available - check if at least one extension is present
 + * @exts: tc filter extensions handle
 + *
 + * Returns 1 if at least one extension is present.
 + */
 +static inline int
 +tcf_exts_is_available(struct tcf_exts *exts)
 +{
 +	/* All non-predicative extensions must be added here. */
 +	return tcf_exts_is_predicative(exts);
++=======
+  * tcf_exts_has_actions - check if at least one action is present
+  * @exts: tc filter extensions handle
+  *
+  * Returns true if at least one action is present.
+  */
+ static inline bool tcf_exts_has_actions(struct tcf_exts *exts)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	return exts->nr_actions;
+ #else
+ 	return false;
+ #endif
+ }
+ 
+ /**
+  * tcf_exts_has_one_action - check if exactly one action is present
+  * @exts: tc filter extensions handle
+  *
+  * Returns true if exactly one action is present.
+  */
+ static inline bool tcf_exts_has_one_action(struct tcf_exts *exts)
+ {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	return exts->nr_actions == 1;
+ #else
+ 	return false;
+ #endif
++>>>>>>> 6fc6d06e5371 (net: sched: remove redundant helpers tcf_exts_is_predicative and tcf_exts_is_available)
  }
  
  /**
* Unmerged path include/net/pkt_cls.h
diff --git a/net/sched/cls_fw.c b/net/sched/cls_fw.c
index 54ee2a3086fa..9ab9434f1f18 100644
--- a/net/sched/cls_fw.c
+++ b/net/sched/cls_fw.c
@@ -372,7 +372,7 @@ static int fw_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,
 
 	t->tcm_handle = f->id;
 
-	if (!f->res.classid && !tcf_exts_is_available(&f->exts))
+	if (!f->res.classid && !tcf_exts_has_actions(&f->exts))
 		return skb->len;
 
 	nest = nla_nest_start(skb, TCA_OPTIONS);
diff --git a/net/sched/cls_route.c b/net/sched/cls_route.c
index ddc332f8bc11..71f3f12e1fd2 100644
--- a/net/sched/cls_route.c
+++ b/net/sched/cls_route.c
@@ -113,7 +113,7 @@ static inline int route4_hash_wild(void)
 #define ROUTE4_APPLY_RESULT()					\
 {								\
 	*res = f->res;						\
-	if (tcf_exts_is_available(&f->exts)) {			\
+	if (tcf_exts_has_actions(&f->exts)) {			\
 		int r = tcf_exts_exec(skb, &f->exts, res);	\
 		if (r < 0) {					\
 			dont_cache = 1;				\
diff --git a/net/sched/cls_tcindex.c b/net/sched/cls_tcindex.c
index 5f0af005d12e..fc0cb7c9c7d7 100644
--- a/net/sched/cls_tcindex.c
+++ b/net/sched/cls_tcindex.c
@@ -52,7 +52,7 @@ struct tcindex_data {
 
 static inline int tcindex_filter_is_set(struct tcindex_filter_result *r)
 {
-	return tcf_exts_is_predicative(&r->exts) || r->res.classid;
+	return tcf_exts_has_actions(&r->exts) || r->res.classid;
 }
 
 static struct tcindex_filter_result *tcindex_lookup(struct tcindex_data *p,
