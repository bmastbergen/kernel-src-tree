netvsc: cleanup datapath switch

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 9a0c48df0d77602da3958a4c8fc2abb9521b0ade
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9a0c48df.failed

Use one routine for datapath up/down. Don't need to reopen
the rndis layer.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9a0c48df0d77602da3958a4c8fc2abb9521b0ade)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 5103dca8a92e,b54b5b99cd79..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -1389,61 -1847,26 +1389,72 @@@ static int netvsc_register_vf(struct ne
  	return NOTIFY_OK;
  }
  
- static int netvsc_vf_up(struct net_device *vf_netdev)
+ /* VF up/down change detected, schedule to change data path */
+ static int netvsc_vf_changed(struct net_device *vf_netdev)
  {
 -	struct net_device_context *net_device_ctx;
 -	struct netvsc_device *netvsc_dev;
  	struct net_device *ndev;
++<<<<<<< HEAD
 +	struct netvsc_device *netvsc_dev;
 +	struct net_device_context *net_device_ctx;
++=======
+ 	bool vf_is_up = netif_running(vf_netdev);
++>>>>>>> 9a0c48df0d77 (netvsc: cleanup datapath switch)
  
  	ndev = get_netvsc_byref(vf_netdev);
  	if (!ndev)
  		return NOTIFY_DONE;
  
  	net_device_ctx = netdev_priv(ndev);
 -	netvsc_dev = rtnl_dereference(net_device_ctx->nvdev);
 -	if (!netvsc_dev)
 +	netvsc_dev = net_device_ctx->nvdev;
 +
++<<<<<<< HEAD
 +	netdev_info(ndev, "VF up: %s\n", vf_netdev->name);
 +
 +	/*
 +	 * Open the device before switching data path.
 +	 */
 +	rndis_filter_open(netvsc_dev);
 +
 +	/*
 +	 * notify the host to switch the data path.
 +	 */
 +	netvsc_switch_datapath(ndev, true);
 +	netdev_info(ndev, "Data path switched to VF: %s\n", vf_netdev->name);
 +
 +	netif_carrier_off(ndev);
 +
 +	/* Now notify peers through VF device. */
 +	call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, vf_netdev);
 +
 +	return NOTIFY_OK;
 +}
 +
 +static int netvsc_vf_down(struct net_device *vf_netdev)
 +{
 +	struct net_device *ndev;
 +	struct netvsc_device *netvsc_dev;
 +	struct net_device_context *net_device_ctx;
 +
 +	ndev = get_netvsc_byref(vf_netdev);
 +	if (!ndev)
  		return NOTIFY_DONE;
  
 +	net_device_ctx = netdev_priv(ndev);
 +	netvsc_dev = net_device_ctx->nvdev;
 +
 +	netdev_info(ndev, "VF down: %s\n", vf_netdev->name);
 +	netvsc_switch_datapath(ndev, false);
 +	netdev_info(ndev, "Data path switched from VF: %s\n", vf_netdev->name);
 +	rndis_filter_close(netvsc_dev);
 +	netif_carrier_on(ndev);
 +
 +	/* Now notify peers through netvsc device. */
 +	call_netdevice_notifiers(NETDEV_NOTIFY_PEERS, ndev);
++=======
+ 	netvsc_switch_datapath(ndev, vf_is_up);
+ 	netdev_info(ndev, "Data path switched %s VF: %s\n",
+ 		    vf_is_up ? "to" : "from", vf_netdev->name);
++>>>>>>> 9a0c48df0d77 (netvsc: cleanup datapath switch)
  
  	return NOTIFY_OK;
  }
* Unmerged path drivers/net/hyperv/netvsc_drv.c
