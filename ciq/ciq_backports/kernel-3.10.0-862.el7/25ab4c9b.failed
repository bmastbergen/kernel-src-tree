fs/namespace.c: path_is_under can be boolean

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] namespace.c: path_is_under can be boolean ("Eric W. Biederman") [1487751]
Rebuild_FUZZ: 96.47%
commit-author Yaowei Bai <baiyaowei@cmss.chinamobile.com>
commit 25ab4c9b1ccb64b1433cecd3f19f28fe300c1576
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/25ab4c9b.failed

This patch makes path_is_under return bool to improve
readability due to this particular function only using either
one or zero as its return value.

No functional change.

	Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 25ab4c9b1ccb64b1433cecd3f19f28fe300c1576)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
diff --cc include/linux/fs.h
index 24213ce025a6,aab8094656e4..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2798,8 -2533,9 +2798,14 @@@ extern struct file * open_exec(const ch
   
  /* fs/dcache.c -- generic fs support functions */
  extern int is_subdir(struct dentry *, struct dentry *);
++<<<<<<< HEAD
 +extern int path_is_under(struct path *, struct path *);
 +extern ino_t find_inode_number(struct dentry *, struct qstr *);
++=======
+ extern bool path_is_under(struct path *, struct path *);
+ 
+ extern char *file_path(struct file *, char *, int);
++>>>>>>> 25ab4c9b1ccb (fs/namespace.c: path_is_under can be boolean)
  
  #include <linux/err.h>
  
diff --git a/fs/namespace.c b/fs/namespace.c
index 84149742b9d6..8f1a0939d127 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -3021,9 +3021,9 @@ bool is_path_reachable(struct mount *mnt, struct dentry *dentry,
 	return &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);
 }
 
-int path_is_under(struct path *path1, struct path *path2)
+bool path_is_under(struct path *path1, struct path *path2)
 {
-	int res;
+	bool res;
 	read_seqlock_excl(&mount_lock);
 	res = is_path_reachable(real_mount(path1->mnt), path1->dentry, path2);
 	read_sequnlock_excl(&mount_lock);
* Unmerged path include/linux/fs.h
