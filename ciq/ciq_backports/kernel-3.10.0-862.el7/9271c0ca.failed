drm/edid: Don't send non-zero YQ in AVI infoframe for HDMI 1.x sinks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 9271c0ca573e02a360b636ecd8cb408852f4e9f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9271c0ca.failed

Apparently some sinks look at the YQ bits even when receiving RGB,
and they get somehow confused when they see a non-zero YQ value.
So we can't just blindly follow CEA-861-F and set YQ to match the
RGB range.

Unfortunately there is no good way to tell whether the sink
designer claims to have read CEA-861-F. The CEA extension block
revision number has generally been stuck at 3 since forever,
and even a very recently manufactured sink might be based on
an old design so the manufacturing date doesn't seem like
something we can use. In lieu of better information let's
follow CEA-861-F only for HDMI 2.0 sinks, since HDMI 2.0 is
based on CEA-861-F. For HDMI 1.x sinks we'll always set YQ=0.

The alternative would of course be to always set YQ=0. And if
we ever encounter a HDMI 2.0+ sink with this bug that's what
we'll probably have to do.

	Cc: stable@vger.kernel.org
	Cc: Jani Nikula <jani.nikula@intel.com>
	Cc: Eric Anholt <eric@anholt.net>
	Cc: Neil Kownacki <njkkow@gmail.com>
	Reported-by: Neil Kownacki <njkkow@gmail.com>
	Tested-by: Neil Kownacki <njkkow@gmail.com>
Fixes: fcc8a22cc905 ("drm/edid: Set YQ bits in the AVI infoframe according to CEA-861-F")
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=101639
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20171108152504.12596-1-ville.syrjala@linux.intel.com
	Acked-by: Eric Anholt <eric@anholt.net>
(cherry picked from commit 9271c0ca573e02a360b636ecd8cb408852f4e9f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_edid.c
#	drivers/gpu/drm/i915/intel_hdmi.c
#	drivers/gpu/drm/vc4/vc4_hdmi.c
#	include/drm/drm_edid.h
diff --cc drivers/gpu/drm/drm_edid.c
index 7cce86933000,fc7946eb6665..000000000000
--- a/drivers/gpu/drm/drm_edid.c
+++ b/drivers/gpu/drm/drm_edid.c
@@@ -4275,6 -4797,60 +4275,63 @@@ drm_hdmi_avi_infoframe_from_display_mod
  }
  EXPORT_SYMBOL(drm_hdmi_avi_infoframe_from_display_mode);
  
++<<<<<<< HEAD
++=======
+ /**
+  * drm_hdmi_avi_infoframe_quant_range() - fill the HDMI AVI infoframe
+  *                                        quantization range information
+  * @frame: HDMI AVI infoframe
+  * @mode: DRM display mode
+  * @rgb_quant_range: RGB quantization range (Q)
+  * @rgb_quant_range_selectable: Sink support selectable RGB quantization range (QS)
+  */
+ void
+ drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
+ 				   const struct drm_display_mode *mode,
+ 				   enum hdmi_quantization_range rgb_quant_range,
+ 				   bool rgb_quant_range_selectable,
+ 				   bool is_hdmi2_sink)
+ {
+ 	/*
+ 	 * CEA-861:
+ 	 * "A Source shall not send a non-zero Q value that does not correspond
+ 	 *  to the default RGB Quantization Range for the transmitted Picture
+ 	 *  unless the Sink indicates support for the Q bit in a Video
+ 	 *  Capabilities Data Block."
+ 	 *
+ 	 * HDMI 2.0 recommends sending non-zero Q when it does match the
+ 	 * default RGB quantization range for the mode, even when QS=0.
+ 	 */
+ 	if (rgb_quant_range_selectable ||
+ 	    rgb_quant_range == drm_default_rgb_quant_range(mode))
+ 		frame->quantization_range = rgb_quant_range;
+ 	else
+ 		frame->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+ 
+ 	/*
+ 	 * CEA-861-F:
+ 	 * "When transmitting any RGB colorimetry, the Source should set the
+ 	 *  YQ-field to match the RGB Quantization Range being transmitted
+ 	 *  (e.g., when Limited Range RGB, set YQ=0 or when Full Range RGB,
+ 	 *  set YQ=1) and the Sink shall ignore the YQ-field."
+ 	 *
+ 	 * Unfortunate certain sinks (eg. VIZ Model 67/E261VA) get confused
+ 	 * by non-zero YQ when receiving RGB. There doesn't seem to be any
+ 	 * good way to tell which version of CEA-861 the sink supports, so
+ 	 * we limit non-zero YQ to HDMI 2.0 sinks only as HDMI 2.0 is based
+ 	 * on on CEA-861-F.
+ 	 */
+ 	if (!is_hdmi2_sink ||
+ 	    rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)
+ 		frame->ycc_quantization_range =
+ 			HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+ 	else
+ 		frame->ycc_quantization_range =
+ 			HDMI_YCC_QUANTIZATION_RANGE_FULL;
+ }
+ EXPORT_SYMBOL(drm_hdmi_avi_infoframe_quant_range);
+ 
++>>>>>>> 9271c0ca573e (drm/edid: Don't send non-zero YQ in AVI infoframe for HDMI 1.x sinks)
  static enum hdmi_3d_structure
  s3d_structure_from_display_mode(const struct drm_display_mode *mode)
  {
diff --cc drivers/gpu/drm/i915/intel_hdmi.c
index fe8f8a4c384e,3fed1d3ecded..000000000000
--- a/drivers/gpu/drm/i915/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/intel_hdmi.c
@@@ -461,19 -472,24 +461,31 @@@ static void intel_hdmi_set_avi_infofram
  		return;
  	}
  
 -	if (crtc_state->ycbcr420)
 -		frame.avi.colorspace = HDMI_COLORSPACE_YUV420;
 -	else
 -		frame.avi.colorspace = HDMI_COLORSPACE_RGB;
 +	if (intel_hdmi->rgb_quant_range_selectable) {
 +		if (intel_crtc->config->limited_color_range)
 +			frame.avi.quantization_range =
 +				HDMI_QUANTIZATION_RANGE_LIMITED;
 +		else
 +			frame.avi.quantization_range =
 +				HDMI_QUANTIZATION_RANGE_FULL;
 +	}
  
++<<<<<<< HEAD
 +	intel_write_infoframe(encoder, &frame);
++=======
+ 	drm_hdmi_avi_infoframe_quant_range(&frame.avi, adjusted_mode,
+ 					   crtc_state->limited_color_range ?
+ 					   HDMI_QUANTIZATION_RANGE_LIMITED :
+ 					   HDMI_QUANTIZATION_RANGE_FULL,
+ 					   intel_hdmi->rgb_quant_range_selectable,
+ 					   is_hdmi2_sink);
+ 
+ 	/* TODO: handle pixel repetition for YCBCR420 outputs */
+ 	intel_write_infoframe(encoder, crtc_state, &frame);
++>>>>>>> 9271c0ca573e (drm/edid: Don't send non-zero YQ in AVI infoframe for HDMI 1.x sinks)
  }
  
 -static void intel_hdmi_set_spd_infoframe(struct drm_encoder *encoder,
 -					 const struct intel_crtc_state *crtc_state)
 +static void intel_hdmi_set_spd_infoframe(struct drm_encoder *encoder)
  {
  	union hdmi_infoframe frame;
  	int ret;
diff --cc include/drm/drm_edid.h
index 38eabf65f19d,a992434ded99..000000000000
--- a/include/drm/drm_edid.h
+++ b/include/drm/drm_edid.h
@@@ -346,6 -356,12 +346,15 @@@ drm_hdmi_avi_infoframe_from_display_mod
  int
  drm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,
  					    const struct drm_display_mode *mode);
++<<<<<<< HEAD
++=======
+ void
+ drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
+ 				   const struct drm_display_mode *mode,
+ 				   enum hdmi_quantization_range rgb_quant_range,
+ 				   bool rgb_quant_range_selectable,
+ 				   bool is_hdmi2_sink);
++>>>>>>> 9271c0ca573e (drm/edid: Don't send non-zero YQ in AVI infoframe for HDMI 1.x sinks)
  
  /**
   * drm_eld_mnl - Get ELD monitor name length in bytes.
* Unmerged path drivers/gpu/drm/vc4/vc4_hdmi.c
* Unmerged path drivers/gpu/drm/drm_edid.c
* Unmerged path drivers/gpu/drm/i915/intel_hdmi.c
* Unmerged path drivers/gpu/drm/vc4/vc4_hdmi.c
* Unmerged path include/drm/drm_edid.h
