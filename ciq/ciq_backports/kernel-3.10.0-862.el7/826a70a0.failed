SCSI: don't get target/host busy_count in scsi_mq_get_budget()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ming Lei <ming.lei@redhat.com>
commit 826a70a08b1210bbfdbda812ab43eb986e25b5c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/826a70a0.failed

It is very expensive to atomic_inc/atomic_dec the host wide counter of
host->busy_count, and it should have been avoided via blk-mq's mechanism
of getting driver tag, which uses the more efficient way of sbitmap queue.

Also we don't check atomic_read(&sdev->device_busy) in scsi_mq_get_budget()
and don't run queue if the counter becomes zero, so IO hang may be caused
if all requests are completed just before the current SCSI device
is added to shost->starved_list.

Fixes: 0df21c86bdbf(scsi: implement .get_budget and .put_budget for blk-mq)
	Reported-by: Bart Van Assche <bart.vanassche@wdc.com>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 826a70a08b1210bbfdbda812ab43eb986e25b5c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index 540886abddcc,22a7e4c47207..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -1800,74 -1943,99 +1800,150 @@@ static int scsi_mq_prep_fn(struct reque
  static void scsi_mq_done(struct scsi_cmnd *cmd)
  {
  	trace_scsi_dispatch_cmd_done(cmd);
 -	blk_mq_complete_request(cmd->request);
 +	blk_mq_complete_request(cmd->request, cmd->request->errors);
  }
  
 -static void scsi_mq_put_budget(struct blk_mq_hw_ctx *hctx)
 +static int scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 +			 const struct blk_mq_queue_data *bd)
  {
 -	struct request_queue *q = hctx->queue;
 +	struct request *req = bd->rq;
 +	struct request_queue *q = req->q;
  	struct scsi_device *sdev = q->queuedata;
++<<<<<<< HEAD
 +	struct Scsi_Host *shost = sdev->host;
 +	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
 +	int ret;
 +	int reason;
 +
 +	ret = prep_to_mq(scsi_prep_state_check(sdev, req));
 +	if (ret)
 +		goto out;
++=======
+ 
+ 	atomic_dec(&sdev->device_busy);
+ 	put_device(&sdev->sdev_gendev);
+ }
+ 
+ static blk_status_t scsi_mq_get_budget(struct blk_mq_hw_ctx *hctx)
+ {
+ 	struct request_queue *q = hctx->queue;
+ 	struct scsi_device *sdev = q->queuedata;
+ 	blk_status_t ret;
+ 
+ 	ret = prep_to_mq(scsi_prep_state_check(sdev, NULL));
+ 	if (ret == BLK_STS_RESOURCE || ret != BLK_STS_OK)
+ 		return ret;
++>>>>>>> 826a70a08b12 (SCSI: don't get target/host busy_count in scsi_mq_get_budget())
  
 +	ret = BLK_MQ_RQ_QUEUE_BUSY;
  	if (!get_device(&sdev->sdev_gendev))
  		goto out;
 +
  	if (!scsi_dev_queue_ready(q, sdev))
  		goto out_put_device;
- 	if (!scsi_target_queue_ready(shost, sdev))
- 		goto out_dec_device_busy;
- 	if (!scsi_host_queue_ready(q, shost, sdev))
- 		goto out_dec_target_busy;
  
 -	return BLK_STS_OK;
  
++<<<<<<< HEAD
 +	if (!(req->cmd_flags & REQ_DONTPREP)) {
 +		ret = prep_to_mq(scsi_mq_prep_fn(req));
 +		if (ret)
 +			goto out_dec_host_busy;
 +		req->cmd_flags |= REQ_DONTPREP;
 +	} else {
 +		blk_mq_start_request(req);
 +	}
 +
 +	if (blk_queue_tagged(q))
 +		req->cmd_flags |= REQ_QUEUED;
 +	else
 +		req->cmd_flags &= ~REQ_QUEUED;
 +
 +	scsi_init_cmd_errh(cmd);
 +	cmd->scsi_done = scsi_mq_done;
 +
 +	reason = scsi_dispatch_cmd(cmd);
 +	if (reason) {
 +		scsi_set_blocked(cmd, reason);
 +		ret = BLK_MQ_RQ_QUEUE_BUSY;
 +		goto out_dec_host_busy;
 +	}
 +
 +	return BLK_MQ_RQ_QUEUE_OK;
 +
 +out_dec_host_busy:
 +	atomic_dec(&shost->host_busy);
 +out_dec_target_busy:
 +	if (scsi_target(sdev)->can_queue > 0)
 +		atomic_dec(&scsi_target(sdev)->target_busy);
 +out_dec_device_busy:
 +	atomic_dec(&sdev->device_busy);
 +out_put_device:
 +	put_device(&sdev->sdev_gendev);
 +out:
++=======
+ out_put_device:
+ 	put_device(&sdev->sdev_gendev);
+ out:
+ 	return BLK_STS_RESOURCE;
+ }
+ 
+ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
+ 			 const struct blk_mq_queue_data *bd)
+ {
+ 	struct request *req = bd->rq;
+ 	struct request_queue *q = req->q;
+ 	struct scsi_device *sdev = q->queuedata;
+ 	struct Scsi_Host *shost = sdev->host;
+ 	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
+ 	blk_status_t ret;
+ 	int reason;
+ 
+ 	ret = prep_to_mq(scsi_prep_state_check(sdev, req));
+ 	if (ret != BLK_STS_OK)
+ 		goto out_put_budget;
+ 
+ 	ret = BLK_STS_RESOURCE;
+ 	if (!scsi_target_queue_ready(shost, sdev))
+ 		goto out_put_budget;
+ 	if (!scsi_host_queue_ready(q, shost, sdev))
+ 		goto out_dec_target_busy;
+ 
+ 	if (!(req->rq_flags & RQF_DONTPREP)) {
+ 		ret = prep_to_mq(scsi_mq_prep_fn(req));
+ 		if (ret != BLK_STS_OK)
+ 			goto out_dec_host_busy;
+ 		req->rq_flags |= RQF_DONTPREP;
+ 	} else {
+ 		blk_mq_start_request(req);
+ 	}
+ 
+ 	if (sdev->simple_tags)
+ 		cmd->flags |= SCMD_TAGGED;
+ 	else
+ 		cmd->flags &= ~SCMD_TAGGED;
+ 
+ 	scsi_init_cmd_errh(cmd);
+ 	cmd->scsi_done = scsi_mq_done;
+ 
+ 	reason = scsi_dispatch_cmd(cmd);
+ 	if (reason) {
+ 		scsi_set_blocked(cmd, reason);
+ 		ret = BLK_STS_RESOURCE;
+ 		goto out_dec_host_busy;
+ 	}
+ 
+ 	return BLK_STS_OK;
+ 
+ out_dec_host_busy:
+        atomic_dec(&shost->host_busy);
+ out_dec_target_busy:
+ 	if (scsi_target(sdev)->can_queue > 0)
+ 		atomic_dec(&scsi_target(sdev)->target_busy);
+ out_put_budget:
+ 	scsi_mq_put_budget(hctx);
++>>>>>>> 826a70a08b12 (SCSI: don't get target/host busy_count in scsi_mq_get_budget())
  	switch (ret) {
 -	case BLK_STS_OK:
 -		break;
 -	case BLK_STS_RESOURCE:
 +	case BLK_MQ_RQ_QUEUE_BUSY:
  		if (atomic_read(&sdev->device_busy) == 0 &&
  		    !scsi_device_blocked(sdev))
  			blk_mq_delay_run_hw_queue(hctx, SCSI_QUEUE_DELAY);
* Unmerged path drivers/scsi/scsi_lib.c
