net/mlx5e: More generic netdev management API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: More generic netdev management API (Don Dutile) [1385325 1499362]
Rebuild_FUZZ: 95.35%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 2c3b5beec46ab0d77c94828eb15170b333ae769a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2c3b5bee.failed

In preparation for mlx5e RDMA net_device support, here we generalize
mlx5e_attach/detach in a way that those functions will be agnostic
to link type.  For that we move ethernet specific NIC net device logic out
of those functions into {nic,rep}_{enable/disable} mlx5e NIC and
representor profiles callbacks.

Also some of the logic was moved only to NIC profile since it is not right
to have this logic for representor net device (e.g. set port MTU).

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2c3b5beec46ab0d77c94828eb15170b333ae769a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,cdc34ba354c8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3707,13 -4281,12 +3769,16 @@@ err_cleanup_nic
  	return NULL;
  }
  
- int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev)
+ int mlx5e_attach_netdev(struct mlx5e_priv *priv)
  {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
  	const struct mlx5e_profile *profile;
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv;
++=======
++>>>>>>> 2c3b5beec46a (net/mlx5e: More generic netdev management API)
  	int err;
  
- 	priv = netdev_priv(netdev);
  	profile = priv->profile;
  	clear_bit(MLX5E_STATE_DESTROYING, &priv->state);
  
@@@ -3733,10 -4306,6 +3798,13 @@@
  
  	mlx5e_create_q_counter(priv);
  
++<<<<<<< HEAD
 +	mlx5e_init_l2_addr(priv);
 +
 +	mlx5e_set_dev_port_mtu(netdev);
 +
++=======
++>>>>>>> 2c3b5beec46a (net/mlx5e: More generic netdev management API)
  	if (profile->enable)
  		profile->enable(priv);
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 16c2c2d53ebb..9be22c020225 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -903,12 +903,6 @@ void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
 int mlx5e_close(struct net_device *netdev);
 int mlx5e_open(struct net_device *netdev);
 void mlx5e_update_stats_work(struct work_struct *work);
-struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
-				       const struct mlx5e_profile *profile,
-				       void *ppriv);
-void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv);
-int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
-void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout);
 void mlx5e_add_vxlan_port(struct net_device *netdev,
 			  struct udp_tunnel_info *ti);
@@ -921,4 +915,13 @@ bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv);
+
+/* mlx5e generic netdev management API */
+struct net_device*
+mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
+		    void *ppriv);
+int mlx5e_attach_netdev(struct mlx5e_priv *priv);
+void mlx5e_detach_netdev(struct mlx5e_priv *priv);
+void mlx5e_destroy_netdev(struct mlx5e_priv *priv);
+
 #endif /* __MLX5_EN_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d..7abad7a5e381 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -475,6 +475,8 @@ static int mlx5e_init_rep_rx(struct mlx5e_priv *priv)
 	int err;
 	int i;
 
+	mlx5e_init_l2_addr(priv);
+
 	err = mlx5e_create_direct_rqts(priv);
 	if (err) {
 		mlx5_core_warn(mdev, "create direct rqts failed, %d\n", err);
@@ -568,7 +570,7 @@ int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
 
 	rep->netdev = netdev;
 
-	err = mlx5e_attach_netdev(esw->dev, netdev);
+	err = mlx5e_attach_netdev(netdev_priv(netdev));
 	if (err) {
 		pr_warn("Failed to attach representor netdev for vport %d\n",
 			rep->vport);
@@ -585,10 +587,10 @@ int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
 	return 0;
 
 err_detach_netdev:
-	mlx5e_detach_netdev(esw->dev, netdev);
+	mlx5e_detach_netdev(netdev_priv(netdev));
 
 err_destroy_netdev:
-	mlx5e_destroy_netdev(esw->dev, netdev_priv(netdev));
+	mlx5e_destroy_netdev(netdev_priv(netdev));
 
 	return err;
 
@@ -600,6 +602,6 @@ void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
 	struct net_device *netdev = rep->netdev;
 
 	unregister_netdev(netdev);
-	mlx5e_detach_netdev(esw->dev, netdev);
-	mlx5e_destroy_netdev(esw->dev, netdev_priv(netdev));
+	mlx5e_detach_netdev(netdev_priv(netdev));
+	mlx5e_destroy_netdev(netdev_priv(netdev));
 }
