scsi: qla2xxx: Preparation for Target MQ.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Preparation for Target MQ (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 90.67%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 82de802ad46e23820f7fcaddc45adde181d95562
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/82de802a.failed

In Current code, Req Q 0, RespQ 0 & hardware_lock are the main resources
for sending and process completion of Target IO. These resources are now
referenced behind a new qpair/"struct qla_qpair base_qpair".  Main path
IO handle will access those resources via the qpair pointer in
preparation for Target MQ.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 82de802ad46e23820f7fcaddc45adde181d95562)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index 23b15e5afee2,f0f16d313faf..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -2061,7 -2096,7 +2061,11 @@@ qla24xx_vport_create(struct fc_vport *f
  	}
  
  	if (qos) {
++<<<<<<< HEAD
 +		qpair = qla2xxx_create_qpair(vha, 0, qos, vha->vp_idx);
++=======
+ 		qpair = qla2xxx_create_qpair(vha, qos, vha->vp_idx, true);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		if (!qpair)
  			ql_log(ql_log_warn, vha, 0x7084,
  			    "Can't create qpair for VP[%d]\n",
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,64109134e276..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2919,13 -3275,7 +2928,17 @@@ struct qla_qpair 
  	struct qla_hw_data *hw;
  	struct work_struct q_work;
  	struct list_head qp_list_elem; /* vha->qp_list */
++<<<<<<< HEAD
 +};
 +
 +struct qla_percpu_qp_hint {
 +	int change_in_progress;
 +	struct qla_qpair *qp;
 +	int redirect_to_cpuid;
 +	struct qla_qpair *alternate_qp;
++=======
+ 	uint16_t cpuid;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  };
  
  /* Place holder for FW buffer parameters */
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,f5493eda0110..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -71,7 -73,11 +71,15 @@@ extern void qla2x00_async_logout_done(s
      uint16_t *);
  extern void qla2x00_async_adisc_done(struct scsi_qla_host *, fc_port_t *,
      uint16_t *);
++<<<<<<< HEAD
 +extern void *qla2x00_alloc_iocbs(struct scsi_qla_host *, srb_t *);
++=======
+ struct qla_work_evt *qla2x00_alloc_work(struct scsi_qla_host *,
+     enum qla_work_type);
+ extern int qla24xx_async_gnl(struct scsi_qla_host *, fc_port_t *);
+ int qla2x00_post_work(struct scsi_qla_host *vha, struct qla_work_evt *e);
+ extern void *qla2x00_alloc_iocbs_ready(struct qla_qpair *, srb_t *);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  extern int qla24xx_update_fcport_fcp_prio(scsi_qla_host_t *, fc_port_t *);
  
  extern fc_port_t *
@@@ -89,8 -95,15 +97,12 @@@ qla2x00_alloc_outstanding_cmds(struct q
  extern int qla2x00_init_rings(scsi_qla_host_t *);
  extern uint8_t qla27xx_find_valid_image(struct scsi_qla_host *);
  extern struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *,
++<<<<<<< HEAD
 +	cpumask_var_t, int, int);
++=======
+ 	int, int, bool);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  extern int qla2xxx_delete_qpair(struct scsi_qla_host *, struct qla_qpair *);
 -void qla2x00_fcport_event_handler(scsi_qla_host_t *, struct event_arg *);
 -int qla24xx_async_gpdb(struct scsi_qla_host *, fc_port_t *, u8);
 -int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
 -	struct imm_ntfy_from_isp *, int);
 -int qla24xx_post_newsess_work(struct scsi_qla_host *, port_id_t *, u8 *,
 -    void *);
 -int qla24xx_fcport_handle_login(struct scsi_qla_host *, fc_port_t *);
  
  /*
   * Global Data in qla_os.c source file.
@@@ -230,9 -254,15 +242,10 @@@ extern int qla2x00_start_bidir(srb_t *
  extern int qla2xxx_dif_start_scsi_mq(srb_t *);
  extern unsigned long qla2x00_get_async_timeout(struct scsi_qla_host *);
  
- extern void *qla2x00_alloc_iocbs(scsi_qla_host_t *, srb_t *);
+ extern void *qla2x00_alloc_iocbs(struct scsi_qla_host *, srb_t *);
+ extern void *__qla2x00_alloc_iocbs(struct qla_qpair *, srb_t *);
  extern int qla2x00_issue_marker(scsi_qla_host_t *, int);
 -extern int qla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *, srb_t *,
 -	uint32_t *, uint16_t, struct qla_tc_param *);
 -extern int qla24xx_walk_and_build_sglist(struct qla_hw_data *, srb_t *,
 -	uint32_t *, uint16_t, struct qla_tc_param *);
 -extern int qla24xx_walk_and_build_prot_sglist(struct qla_hw_data *, srb_t *,
 -	uint32_t *, uint16_t, struct qla_tc_param *);
 +
  extern int qla24xx_get_one_block_sg(uint32_t, struct qla2_sgx *, uint32_t *);
  extern int qla24xx_configure_prot_mode(srb_t *, uint16_t *);
  extern int qla24xx_build_scsi_crc_2_iocbs(srb_t *,
@@@ -781,5 -834,27 +794,30 @@@ extern irqreturn_t qla8044_intr_handler
  extern void qla82xx_mbx_completion(scsi_qla_host_t *, uint16_t);
  extern int qla8044_abort_isp(scsi_qla_host_t *);
  extern int qla8044_check_fw_alive(struct scsi_qla_host *);
++<<<<<<< HEAD
++=======
+ extern int qla_get_exlogin_status(scsi_qla_host_t *, uint16_t *,
+ 	uint16_t *);
+ extern int qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr);
+ extern int qla_get_exchoffld_status(scsi_qla_host_t *, uint16_t *, uint16_t *);
+ extern int qla_set_exchoffld_mem_cfg(scsi_qla_host_t *);
+ extern void qlt_handle_abts_recv(struct scsi_qla_host *, struct rsp_que *,
+ 	response_t *);
+ 
+ int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
+ 	struct imm_ntfy_from_isp *, int);
+ void qla24xx_do_nack_work(struct scsi_qla_host *, struct qla_work_evt *);
+ void qlt_plogi_ack_link(struct scsi_qla_host *, struct qlt_plogi_ack_t *,
+ 	struct fc_port *, enum qlt_plogi_link_t);
+ void qlt_plogi_ack_unref(struct scsi_qla_host *, struct qlt_plogi_ack_t *);
+ extern void qlt_schedule_sess_for_deletion(struct fc_port *, bool);
+ extern void qlt_schedule_sess_for_deletion_lock(struct fc_port *);
+ extern struct fc_port *qlt_find_sess_invalidate_other(scsi_qla_host_t *,
+ 	uint64_t wwn, port_id_t port_id, uint16_t loop_id, struct fc_port **);
+ void qla24xx_delete_sess_fn(struct work_struct *);
+ void qlt_unknown_atio_work_fn(struct work_struct *);
+ void qlt_update_host_map(struct scsi_qla_host *, port_id_t);
+ void qlt_remove_target_resources(struct qla_hw_data *);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,878b552be263..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -6610,21 -7578,8 +6610,26 @@@ qla24xx_update_all_fcp_prio(scsi_qla_ho
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int
 +qla2xxx_set_affinity_hint(struct qla_qpair *qpair, cpumask_var_t cpu_mask)
 +{
 +	int ret;
 +
 +	if (!qpair || !qpair->msix)
 +		return -EINVAL;
 +
 +	ret = irq_set_affinity_hint(qpair->msix->vector, cpu_mask);
 +
 +	return ret;
 +}
 +
 +struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *vha,
 +	cpumask_var_t cpu_mask, int qos, int vp_idx)
++=======
+ struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *vha, int qos,
+ 	int vp_idx, bool startqp)
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  {
  	int rsp_id = 0;
  	int  req_id = 0;
@@@ -6652,6 -7605,9 +6657,12 @@@
  		memset(qpair, 0, sizeof(struct qla_qpair));
  
  		qpair->hw = vha->hw;
++<<<<<<< HEAD
++=======
+ 		qpair->vha = vha;
+ 		qpair->qp_lock_ptr = &qpair->qp_lock;
+ 		spin_lock_init(&qpair->qp_lock);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  		/* Assign available que pair id */
  		mutex_lock(&ha->mq_lock);
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 2aea13d9d71e,6c710313adce..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2084,11 -2107,15 +2084,18 @@@ queuing_error
  }
  
  /* Generic Control-SRB manipulation functions. */
++<<<<<<< HEAD
++=======
+ 
+ /* hardware_lock assumed to be held. */
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  void *
- qla2x00_alloc_iocbs(scsi_qla_host_t *vha, srb_t *sp)
+ __qla2x00_alloc_iocbs(struct qla_qpair *qpair, srb_t *sp)
  {
+ 	scsi_qla_host_t *vha = qpair->vha;
  	struct qla_hw_data *ha = vha->hw;
- 	struct req_que *req = ha->req_q_map[0];
+ 	struct req_que *req = qpair->req;
  	device_reg_t *reg = ISP_QUE_REG(ha, req->id);
  	uint32_t index, handle;
  	request_t *pkt;
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index d71223f09c1c,1535a29a9d9f..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -2612,12 -2804,27 +2613,36 @@@ void qla24xx_process_response_queue(str
  			qla24xx_els_ct_entry(vha, rsp->req, pkt, ELS_IOCB_TYPE);
  			break;
  		case ABTS_RECV_24XX:
++<<<<<<< HEAD
 +			/* ensure that the ATIO queue is empty */
 +			qlt_24xx_process_atio_queue(vha);
 +		case ABTS_RESP_24XX:
 +		case CTIO_TYPE7:
 +		case NOTIFY_ACK_TYPE:
 +			qlt_response_pkt_all_vps(vha, (response_t *)pkt);
++=======
+ 			if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+ 				/* ensure that the ATIO queue is empty */
+ 				qlt_handle_abts_recv(vha, rsp,
+ 				    (response_t *)pkt);
+ 				break;
+ 			} else {
+ 				/* drop through */
+ 				qlt_24xx_process_atio_queue(vha, 1);
+ 			}
+ 		case ABTS_RESP_24XX:
+ 		case CTIO_TYPE7:
+ 		case CTIO_CRC2:
+ 			qlt_response_pkt_all_vps(vha, rsp, (response_t *)pkt);
+ 			break;
+ 		case NOTIFY_ACK_TYPE:
+ 			if (pkt->handle == QLA_TGT_SKIP_HANDLE)
+ 				qlt_response_pkt_all_vps(vha, rsp,
+ 				    (response_t *)pkt);
+ 			else
+ 				qla24xxx_nack_iocb_entry(vha, rsp->req,
+ 					(struct nack_to_isp *)pkt);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  			break;
  		case MARKER_TYPE:
  			/* Do nothing in this case, this check is to prevent it
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 4e0d0a2f9461,82bbb6432f77..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -427,8 -459,20 +435,17 @@@ static void qla2x00_free_queues(struct 
  	int cnt;
  	unsigned long flags;
  
+ 	if (ha->queue_pair_map) {
+ 		kfree(ha->queue_pair_map);
+ 		ha->queue_pair_map = NULL;
+ 	}
+ 	if (ha->base_qpair) {
+ 		kfree(ha->base_qpair);
+ 		ha->base_qpair = NULL;
+ 	}
+ 
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	for (cnt = 0; cnt < ha->max_req_queues; cnt++) {
 -		if (!test_bit(cnt, ha->req_qid_map))
 -			continue;
 -
  		req = ha->req_q_map[cnt];
  		clear_bit(cnt, ha->req_qid_map);
  		ha->req_q_map[cnt] = NULL;
@@@ -3071,14 -3129,11 +3088,19 @@@ qla2x00_probe_one(struct pci_dev *pdev
  		ha->wq = alloc_workqueue("qla2xxx_wq", WQ_MEM_RECLAIM, 1);
  		/* Create start of day qpairs for Block MQ */
  		if (shost_use_blk_mq(host)) {
++<<<<<<< HEAD
 +			cpumask_clear(&cpu_mask);
 +			for (cpu_id = 0; cpu_id < ha->max_qpairs; cpu_id++) {
 +				cpumask_set_cpu(cpu_id, &cpu_mask);
 +				qla2xxx_create_qpair(base_vha, &cpu_mask, 5, 0);
 +				cpumask_clear_cpu(cpu_id, &cpu_mask);
 +			}
++=======
+ 			for (i = 0; i < ha->max_qpairs; i++)
+ 				qla2xxx_create_qpair(base_vha, 5,  0, true);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		}
  	}
 -
  	if (ha->flags.running_gold_fw)
  		goto skip_dpc;
  
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7a27b61e2d53,22f9bb59a98d..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -93,14 -109,31 +93,42 @@@ enum fcp_resp_rsp_codes 
   */
  /* Predefs for callbacks handed to qla2xxx LLD */
  static void qlt_24xx_atio_pkt(struct scsi_qla_host *ha,
++<<<<<<< HEAD
 +	struct atio_from_isp *pkt);
 +static void qlt_response_pkt(struct scsi_qla_host *ha, response_t *pkt);
 +static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,
 +	int fn, void *iocb, int flags);
 +static void qlt_send_term_exchange(struct scsi_qla_host *ha, struct qla_tgt_cmd
 +	*cmd, struct atio_from_isp *atio, int ha_locked);
 +static void qlt_reject_free_srr_imm(struct scsi_qla_host *ha,
 +	struct qla_tgt_srr_imm *imm, int ha_lock);
++=======
+ 	struct atio_from_isp *pkt, uint8_t);
+ static void qlt_response_pkt(struct scsi_qla_host *ha, struct rsp_que *rsp,
+ 	response_t *pkt);
+ static int qlt_issue_task_mgmt(struct fc_port *sess, u64 lun,
+ 	int fn, void *iocb, int flags);
+ static void qlt_send_term_exchange(struct qla_qpair *, struct qla_tgt_cmd
+ 	*cmd, struct atio_from_isp *atio, int ha_locked, int ul_abort);
+ static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull);
+ static void qlt_disable_vha(struct scsi_qla_host *vha);
+ static void qlt_clear_tgt_db(struct qla_tgt *tgt);
+ static void qlt_send_notify_ack(struct qla_qpair *qpair,
+ 	struct imm_ntfy_from_isp *ntfy,
+ 	uint32_t add_flags, uint16_t resp_code, int resp_code_valid,
+ 	uint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);
+ static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *imm, int ha_locked);
+ static struct fc_port *qlt_create_sess(struct scsi_qla_host *vha,
+ 	fc_port_t *fcport, bool local);
+ void qlt_unreg_sess(struct fc_port *sess);
+ static void qlt_24xx_handle_abts(struct scsi_qla_host *,
+ 	struct abts_recv_from_24xx *);
+ static void qlt_send_busy(struct qla_qpair *, struct atio_from_isp *,
+     uint16_t);
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  /*
   * Global Variables
   */
@@@ -179,9 -223,129 +207,133 @@@ struct scsi_qla_host *qlt_find_host_by_
  	return NULL;
  }
  
 -static inline void qlt_incr_num_pend_cmds(struct scsi_qla_host *vha)
 +void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
 +	struct atio_from_isp *atio)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 
+ 	vha->hw->tgt.num_pend_cmds++;
+ 	if (vha->hw->tgt.num_pend_cmds > vha->qla_stats.stat_max_pend_cmds)
+ 		vha->qla_stats.stat_max_pend_cmds =
+ 			vha->hw->tgt.num_pend_cmds;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ static inline void qlt_decr_num_pend_cmds(struct scsi_qla_host *vha)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 	vha->hw->tgt.num_pend_cmds--;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ 
+ 
+ static void qlt_queue_unknown_atio(scsi_qla_host_t *vha,
+ 	struct atio_from_isp *atio, uint8_t ha_locked)
+ {
+ 	struct qla_tgt_sess_op *u;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	unsigned long flags;
+ 
+ 	if (tgt->tgt_stop) {
+ 		ql_dbg(ql_dbg_async, vha, 0x502c,
+ 		    "qla_target(%d): dropping unknown ATIO_TYPE7, because tgt is being stopped",
+ 		    vha->vp_idx);
+ 		goto out_term;
+ 	}
+ 
+ 	u = kzalloc(sizeof(*u), GFP_ATOMIC);
+ 	if (u == NULL)
+ 		goto out_term;
+ 
+ 	u->vha = vha;
+ 	memcpy(&u->atio, atio, sizeof(*atio));
+ 	INIT_LIST_HEAD(&u->cmd_list);
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_add_tail(&u->cmd_list, &vha->unknown_atio_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	schedule_delayed_work(&vha->unknown_atio_work, 1);
+ 
+ out:
+ 	return;
+ 
+ out_term:
+ 	qlt_send_term_exchange(vha->hw->base_qpair, NULL, atio, ha_locked, 0);
+ 	goto out;
+ }
+ 
+ static void qlt_try_to_dequeue_unknown_atios(struct scsi_qla_host *vha,
+ 	uint8_t ha_locked)
+ {
+ 	struct qla_tgt_sess_op *u, *t;
+ 	scsi_qla_host_t *host;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	unsigned long flags;
+ 	uint8_t queued = 0;
+ 
+ 	list_for_each_entry_safe(u, t, &vha->unknown_atio_list, cmd_list) {
+ 		if (u->aborted) {
+ 			ql_dbg(ql_dbg_async, vha, 0x502e,
+ 			    "Freeing unknown %s %p, because of Abort\n",
+ 			    "ATIO_TYPE7", u);
+ 			qlt_send_term_exchange(vha->hw->base_qpair, NULL,
+ 			    &u->atio, ha_locked, 0);
+ 			goto abort;
+ 		}
+ 
+ 		host = qlt_find_host_by_d_id(vha, u->atio.u.isp24.fcp_hdr.d_id);
+ 		if (host != NULL) {
+ 			ql_dbg(ql_dbg_async, vha, 0x502f,
+ 			    "Requeuing unknown ATIO_TYPE7 %p\n", u);
+ 			qlt_24xx_atio_pkt(host, &u->atio, ha_locked);
+ 		} else if (tgt->tgt_stop) {
+ 			ql_dbg(ql_dbg_async, vha, 0x503a,
+ 			    "Freeing unknown %s %p, because tgt is being stopped\n",
+ 			    "ATIO_TYPE7", u);
+ 			qlt_send_term_exchange(vha->hw->base_qpair, NULL,
+ 			    &u->atio, ha_locked, 0);
+ 		} else {
+ 			ql_dbg(ql_dbg_async, vha, 0x503d,
+ 			    "Reschedule u %p, vha %p, host %p\n", u, vha, host);
+ 			if (!queued) {
+ 				queued = 1;
+ 				schedule_delayed_work(&vha->unknown_atio_work,
+ 				    1);
+ 			}
+ 			continue;
+ 		}
+ 
+ abort:
+ 		spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 		list_del(&u->cmd_list);
+ 		spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 		kfree(u);
+ 	}
+ }
+ 
+ void qlt_unknown_atio_work_fn(struct work_struct *work)
+ {
+ 	struct scsi_qla_host *vha = container_of(to_delayed_work(work),
+ 	    struct scsi_qla_host, unknown_atio_work);
+ 
+ 	qlt_try_to_dequeue_unknown_atios(vha, 0);
+ }
+ 
+ static bool qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint8_t ha_locked)
+ {
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe072,
+ 		"%s: qla_target(%d): type %x ox_id %04x\n",
+ 		__func__, vha->vp_idx, atio->u.raw.entry_type,
+ 		be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	switch (atio->u.raw.entry_type) {
  	case ATIO_TYPE7:
  	{
@@@ -230,12 -432,17 +384,13 @@@
  		break;
  	}
  
 -	return false;
 +	return;
  }
  
- void qlt_response_pkt_all_vps(struct scsi_qla_host *vha, response_t *pkt)
+ void qlt_response_pkt_all_vps(struct scsi_qla_host *vha,
+ 	struct rsp_que *rsp, response_t *pkt)
  {
  	switch (pkt->entry_type) {
 -	case CTIO_CRC2:
 -		ql_dbg(ql_dbg_tgt, vha, 0xe073,
 -			"qla_target(%d):%s: CRC2 Response pkt\n",
 -			vha->vp_idx, __func__);
  	case CTIO_TYPE7:
  	{
  		struct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;
@@@ -1061,13 -1576,12 +1217,9 @@@ static void qlt_send_notify_ack(struct 
  	request_t *pkt;
  	struct nack_to_isp *nack;
  
 -	if (!ha->flags.fw_started)
 -		return;
 -
  	ql_dbg(ql_dbg_tgt, vha, 0xe004, "Sending NOTIFY_ACK (ha=%p)\n", ha);
  
- 	/* Send marker if required */
- 	if (qlt_issue_marker(vha, 1) != QLA_SUCCESS)
- 		return;
- 
- 	pkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);
+ 	pkt = (request_t *)__qla2x00_alloc_iocbs(qpair, NULL);
  	if (!pkt) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe049,
  		    "qla_target(%d): %s failed: unable to allocate "
@@@ -1126,11 -1642,8 +1279,16 @@@ static void qlt_24xx_send_abts_resp(str
  	    "Sending task mgmt ABTS response (ha=%p, atio=%p, status=%x\n",
  	    ha, abts, status);
  
++<<<<<<< HEAD
 +	/* Send marker if required */
 +	if (qlt_issue_marker(vha, 1) != QLA_SUCCESS)
 +		return;
 +
 +	resp = (struct abts_resp_to_24xx *)qla2x00_alloc_iocbs(vha, NULL);
++=======
+ 	resp = (struct abts_resp_to_24xx *)qla2x00_alloc_iocbs_ready(qpair,
+ 	    NULL);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	if (!resp) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe04a,
  		    "qla_target(%d): %s failed: unable to allocate "
@@@ -1199,11 -1712,9 +1357,13 @@@ static void qlt_24xx_retry_term_exchang
  
  	ql_dbg(ql_dbg_tgt, vha, 0xe007,
  	    "Sending retry TERM EXCH CTIO7 (ha=%p)\n", vha->hw);
- 	/* Send marker if required */
- 	if (qlt_issue_marker(vha, 1) != QLA_SUCCESS)
- 		return;
  
++<<<<<<< HEAD
 +	ctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs(vha, NULL);
++=======
+ 	ctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs_ready(
+ 	    vha->hw->base_qpair, NULL);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	if (ctio == NULL) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe04b,
  		    "qla_target(%d): %s failed: unable to allocate "
@@@ -1260,10 -1855,22 +1421,27 @@@ static int __qlt_24xx_handle_abts(struc
  			break;
  		}
  	}
 -	spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
 +	spin_unlock(&se_sess->sess_cmd_lock);
  
++<<<<<<< HEAD
 +	if (!found_lun)
 +		return -ENOENT;
++=======
+ 	/* cmd not in LIO lists, look in qla list */
+ 	if (!found_lun) {
+ 		if (abort_cmd_for_tag(vha, abts->exchange_addr_to_abort)) {
+ 			/* send TASK_ABORT response immediately */
+ 			qlt_24xx_send_abts_resp(ha->base_qpair, abts,
+ 			    FCP_TMF_CMPL, false);
+ 			return 0;
+ 		} else {
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf081,
+ 			    "unable to find cmd in driver or LIO for tag 0x%x\n",
+ 			    abts->exchange_addr_to_abort);
+ 			return -ENOENT;
+ 		}
+ 	}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00f,
  	    "qla_target(%d): task abort (tag=%d)\n",
@@@ -1281,8 -1888,11 +1459,13 @@@
  	mcmd->sess = sess;
  	memcpy(&mcmd->orig_iocb.abts, abts, sizeof(mcmd->orig_iocb.abts));
  	mcmd->reset_count = vha->hw->chip_reset;
++<<<<<<< HEAD
++=======
+ 	mcmd->tmr_func = QLA_TGT_ABTS;
+ 	mcmd->qpair = ha->base_qpair;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
 -	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, cmd->unpacked_lun, mcmd->tmr_func,
 +	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, TMR_ABORT_TASK,
  	    abts->exchange_addr_to_abort);
  	if (rc != 0) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf052,
@@@ -1338,14 -1952,25 +1523,25 @@@ static void qlt_24xx_handle_abts(struc
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf012,
  		    "qla_target(%d): task abort for non-existant session\n",
  		    vha->vp_idx);
 -		rc = qlt_sched_sess_work(vha->vha_tgt.qla_tgt,
 +		rc = qlt_sched_sess_work(ha->tgt.qla_tgt,
  		    QLA_TGT_SESS_WORK_ABORT, abts, sizeof(*abts));
 -
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -
  		if (rc != 0) {
- 			qlt_24xx_send_abts_resp(vha, abts, FCP_TMF_REJECTED,
- 			    false);
+ 			qlt_24xx_send_abts_resp(ha->base_qpair, abts,
+ 			    FCP_TMF_REJECTED, false);
  		}
  		return;
  	}
++<<<<<<< HEAD
++=======
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 
+ 	if (sess->deleted) {
+ 		qlt_24xx_send_abts_resp(ha->base_qpair, abts, FCP_TMF_REJECTED,
+ 		    false);
+ 		return;
+ 	}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	rc = __qlt_24xx_handle_abts(vha, abts, sess);
  	if (rc != 0) {
@@@ -1360,11 -1986,13 +1557,12 @@@
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
- static void qlt_24xx_send_task_mgmt_ctio(struct scsi_qla_host *ha,
+ static void qlt_24xx_send_task_mgmt_ctio(struct qla_qpair *qpair,
  	struct qla_tgt_mgmt_cmd *mcmd, uint32_t resp_code)
  {
+ 	struct scsi_qla_host *ha = qpair->vha;
  	struct atio_from_isp *atio = &mcmd->orig_iocb.atio;
  	struct ctio7_to_24xx *ctio;
 -	uint16_t temp;
  
  	ql_dbg(ql_dbg_tgt, ha, 0xe008,
  	    "Sending task mgmt CTIO7 (ha=%p, atio=%p, resp_code=%x\n",
@@@ -1422,16 -2115,44 +1618,52 @@@ void qlt_xmit_tm_rsp(struct qla_tgt_mgm
  	    "TM response mcmd (%p) status %#x state %#x",
  	    mcmd, mcmd->fc_tm_rsp, mcmd->flags);
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	if (mcmd->flags == QLA24XX_MGMT_SEND_NACK)
 +		qlt_send_notify_ack(vha, &mcmd->orig_iocb.imm_ntfy,
 +		    0, 0, 0, 0, 0, 0);
 +	else {
++=======
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 
+ 	if (!vha->flags.online || mcmd->reset_count != ha->chip_reset) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		ql_dbg(ql_dbg_async, vha, 0xe100,
+ 			"RESET-TMR online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			mcmd->reset_count, ha->chip_reset);
+ 		ha->tgt.tgt_ops->free_mcmd(mcmd);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 		return;
+ 	}
+ 
+ 	if (mcmd->flags == QLA24XX_MGMT_SEND_NACK) {
+ 		if (mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode ==
+ 		    ELS_LOGO ||
+ 		    mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode ==
+ 		    ELS_PRLO ||
+ 		    mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode ==
+ 		    ELS_TPRLO) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x2106,
+ 			    "TM response logo %phC status %#x state %#x",
+ 			    mcmd->sess->port_name, mcmd->fc_tm_rsp,
+ 			    mcmd->flags);
+ 			qlt_schedule_sess_for_deletion_lock(mcmd->sess);
+ 		} else {
+ 			qlt_send_notify_ack(vha->hw->base_qpair,
+ 			    &mcmd->orig_iocb.imm_ntfy, 0, 0, 0, 0, 0, 0);
+ 		}
+ 	} else {
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		if (mcmd->orig_iocb.atio.u.raw.entry_type == ABTS_RECV_24XX)
- 			qlt_24xx_send_abts_resp(vha, &mcmd->orig_iocb.abts,
+ 			qlt_24xx_send_abts_resp(qpair, &mcmd->orig_iocb.abts,
  			    mcmd->fc_tm_rsp, false);
  		else
- 			qlt_24xx_send_task_mgmt_ctio(vha, mcmd,
+ 			qlt_24xx_send_task_mgmt_ctio(qpair, mcmd,
  			    mcmd->fc_tm_rsp);
  	}
  	/*
@@@ -1486,39 -2233,44 +1718,53 @@@ static inline void qlt_unmap_sg(struct 
  {
  	struct qla_hw_data *ha = vha->hw;
  
 -	if (!cmd->sg_mapped)
 -		return;
 -
 +	BUG_ON(!cmd->sg_mapped);
  	pci_unmap_sg(ha->pdev, cmd->sg, cmd->sg_cnt, cmd->dma_data_direction);
  	cmd->sg_mapped = 0;
 -
 -	if (cmd->prot_sg_cnt)
 -		pci_unmap_sg(ha->pdev, cmd->prot_sg, cmd->prot_sg_cnt,
 -			cmd->dma_data_direction);
 -
 -	if (!cmd->ctx)
 -		return;
 -
 -	if (cmd->ctx_dsd_alloced)
 -		qla2x00_clean_dsd_pool(ha, cmd->ctx);
 -
 -	dma_pool_free(ha->dl_dma_pool, cmd->ctx, cmd->ctx->crc_ctx_dma);
  }
  
- static int qlt_check_reserve_free_req(struct scsi_qla_host *vha,
+ static int qlt_check_reserve_free_req(struct qla_qpair *qpair,
  	uint32_t req_cnt)
  {
  	uint32_t cnt;
+ 	struct req_que *req = qpair->req;
  
- 	if (vha->req->cnt < (req_cnt + 2)) {
- 		cnt = (uint16_t)RD_REG_DWORD(vha->req->req_q_out);
+ 	if (req->cnt < (req_cnt + 2)) {
+ 		cnt = (uint16_t)RD_REG_DWORD(req->req_q_out);
  
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe00a,
 +		    "Request ring circled: cnt=%d, vha->->ring_index=%d, "
 +		    "vha->req->cnt=%d, req_cnt=%d\n", cnt,
 +		    vha->req->ring_index, vha->req->cnt, req_cnt);
 +		if  (vha->req->ring_index < cnt)
 +			vha->req->cnt = cnt - vha->req->ring_index;
 +		else
 +			vha->req->cnt = vha->req->length -
 +			    (vha->req->ring_index - cnt);
 +	}
 +
 +	if (unlikely(vha->req->cnt < (req_cnt + 2))) {
 +		ql_dbg(ql_dbg_tgt, vha, 0xe00b,
 +		    "qla_target(%d): There is no room in the "
 +		    "request ring: vha->req->ring_index=%d, vha->req->cnt=%d, "
 +		    "req_cnt=%d\n", vha->vp_idx, vha->req->ring_index,
 +		    vha->req->cnt, req_cnt);
 +		return -EAGAIN;
 +	}
 +	vha->req->cnt -= req_cnt;
++=======
+ 		if  (req->ring_index < cnt)
+ 			req->cnt = cnt - req->ring_index;
+ 		else
+ 			req->cnt = req->length - (req->ring_index - cnt);
+ 
+ 		if (unlikely(req->cnt < (req_cnt + 2)))
+ 			return -EAGAIN;
+ 	}
+ 
+ 	req->cnt -= req_cnt;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	return 0;
  }
@@@ -1540,30 -2292,38 +1786,38 @@@ static inline void *qlt_get_req_pkt(str
  }
  
  /* ha->hardware_lock supposed to be held on entry */
- static inline uint32_t qlt_make_handle(struct scsi_qla_host *vha)
+ static inline uint32_t qlt_make_handle(struct qla_qpair *qpair)
  {
++<<<<<<< HEAD
 +	struct qla_hw_data *ha = vha->hw;
 +	uint32_t h;
++=======
+ 	struct scsi_qla_host *vha = qpair->vha;
+ 	uint32_t h;
+ 	int index;
 -	uint8_t found = 0;
 -	struct req_que *req = qpair->req;
 -
 -	h = req->current_outstanding_cmd;
 -
 -	for (index = 1; index < req->num_outstanding_cmds; index++) {
 -		h++;
 -		if (h == req->num_outstanding_cmds)
 -			h = 1;
 -
 -		if (h == QLA_TGT_SKIP_HANDLE)
 -			continue;
 -
 -		if (!req->outstanding_cmds[h]) {
 -			found = 1;
++	uint8_t found = 0;
++	struct req_que *req = qpair->req;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
 +
 +	h = ha->tgt.current_handle;
 +	/* always increment cmd handle */
 +	do {
 +		++h;
 +		if (h > DEFAULT_OUTSTANDING_COMMANDS)
 +			h = 1; /* 0 is QLA_TGT_NULL_HANDLE */
 +		if (h == ha->tgt.current_handle) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe04e,
 +			    "qla_target(%d): Ran out of "
 +			    "empty cmd slots in ha %p\n", vha->vp_idx, ha);
 +			h = QLA_TGT_NULL_HANDLE;
  			break;
  		}
 -	}
 +	} while ((h == QLA_TGT_NULL_HANDLE) ||
 +	    (h == QLA_TGT_SKIP_HANDLE) ||
 +	    (ha->tgt.cmds[h-1] != NULL));
  
 -	if (found) {
 -		req->current_outstanding_cmd = h;
 -	} else {
 -		ql_dbg(ql_dbg_io, vha, 0x305b,
 -			"qla_target(%d): Ran out of empty cmd slots\n",
 -			vha->vp_idx);
 -		h = QLA_TGT_NULL_HANDLE;
 -	}
 +	if (h != QLA_TGT_NULL_HANDLE)
 +		ha->tgt.current_handle = h;
  
  	return h;
  }
@@@ -1574,10 -2334,11 +1828,15 @@@ static int qlt_24xx_build_ctio_pkt(stru
  {
  	uint32_t h;
  	struct ctio7_to_24xx *pkt;
 +	struct qla_hw_data *ha = vha->hw;
  	struct atio_from_isp *atio = &prm->cmd->atio;
++<<<<<<< HEAD
++=======
+ 	uint16_t temp;
+ 	struct scsi_qla_host *vha = prm->cmd->vha;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
- 	pkt = (struct ctio7_to_24xx *)vha->req->ring_ptr;
+ 	pkt = (struct ctio7_to_24xx *)qpair->req->ring_ptr;
  	prm->pkt = pkt;
  	memset(pkt, 0, sizeof(*pkt));
  
@@@ -1593,11 -2354,13 +1852,12 @@@
  		 * the session and, so, the command.
  		 */
  		return -EAGAIN;
 -	} else {
 -		vha->req->outstanding_cmds[h] = (srb_t *)prm->cmd;
 -	}
 +	} else
 +		ha->tgt.cmds[h-1] = prm->cmd;
  
- 	pkt->handle = h | CTIO_COMPLETION_HANDLE_MARK;
- 	pkt->nport_handle = prm->cmd->loop_id;
+ 	pkt->handle = MAKE_HANDLE(qpair->req->id, h);
+ 	pkt->handle |= CTIO_COMPLETION_HANDLE_MARK;
+ 	pkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);
  	pkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
  	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
  	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
@@@ -1788,15 -2555,6 +2049,18 @@@ static int qlt_pre_xmit_response(struc
  	prm->req_cnt = 1;
  	prm->add_status_pkt = 0;
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, vha, 0xe012, "rq_result=%x, xmit_type=%x\n",
 +	    prm->rq_result, xmit_type);
 +
 +	/* Send marker if required */
 +	if (qlt_issue_marker(vha, 0) != QLA_SUCCESS)
 +		return -EFAULT;
 +
 +	ql_dbg(ql_dbg_tgt, vha, 0xe013, "CTIO start: vha(%d)\n", vha->vp_idx);
 +
++=======
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	if ((xmit_type & QLA_TGT_XMIT_DATA) && qlt_has_data(cmd)) {
  		if  (qlt_pci_map_calc_cnt(prm) != 0)
  			return -EAGAIN;
@@@ -2011,6 -2666,350 +2275,353 @@@ skip_explict_conf
  	/* Sense with len > 24, is it possible ??? */
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ qlt_hba_err_chk_enabled(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 		if (ql2xenablehba_err_chk >= 1)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DOUT_PASS:
+ 	case TARGET_PROT_DIN_PASS:
+ 		if (ql2xenablehba_err_chk >= 2)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		return 1;
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static inline int
+ qla_tgt_ref_mask_check(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 	    return 1;
+ 	default:
+ 	    return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * qla_tgt_set_dif_tags - Extract Ref and App tags from SCSI command
+  */
+ static void
+ qla_tgt_set_dif_tags(struct qla_tgt_cmd *cmd, struct crc_context *ctx,
+     uint16_t *pfw_prot_opts)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	uint32_t lba = 0xffffffff & se_cmd->t_task_lba;
+ 	scsi_qla_host_t *vha = cmd->tgt->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t t32 = 0;
+ 
+ 	/*
+ 	 * wait till Mode Sense/Select cmd, modepage Ah, subpage 2
+ 	 * have been immplemented by TCM, before AppTag is avail.
+ 	 * Look for modesense_handlers[]
+ 	 */
+ 	ctx->app_tag = 0;
+ 	ctx->app_tag_mask[0] = 0x0;
+ 	ctx->app_tag_mask[1] = 0x0;
+ 
+ 	if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	t32 = ha->tgt.tgt_ops->get_dif_tags(cmd, pfw_prot_opts);
+ 
+ 	switch (se_cmd->prot_type) {
+ 	case TARGET_DIF_TYPE0_PROT:
+ 		/*
+ 		 * No check for ql2xenablehba_err_chk, as it
+ 		 * would be an I/O error if hba tag generation
+ 		 * is not done.
+ 		 */
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 	case TARGET_DIF_TYPE1_PROT:
+ 	    /*
+ 	     * For TYPE 1 protection: 16 bit GUARD tag, 32 bit
+ 	     * REF tag, and 16 bit app tag.
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE2_PROT:
+ 	    /*
+ 	     * For TYPE 2 protection: 16 bit GUARD + 32 bit REF
+ 	     * tag has to match LBA in CDB + N
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE3_PROT:
+ 	    /* For TYPE 3 protection: 16 bit GUARD only */
+ 	    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 	    ctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =
+ 		ctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;
+ 	    break;
+ 	}
+ }
+ 
+ static inline int
+ qlt_build_ctio_crc2_pkt(struct qla_qpair *qpair, struct qla_tgt_prm *prm)
+ {
+ 	uint32_t		*cur_dsd;
+ 	uint32_t		transfer_length = 0;
+ 	uint32_t		data_bytes;
+ 	uint32_t		dif_bytes;
+ 	uint8_t			bundling = 1;
+ 	uint8_t			*clr_ptr;
+ 	struct crc_context	*crc_ctx_pkt = NULL;
+ 	struct qla_hw_data	*ha;
+ 	struct ctio_crc2_to_fw	*pkt;
+ 	dma_addr_t		crc_ctx_dma;
+ 	uint16_t		fw_prot_opts = 0;
+ 	struct qla_tgt_cmd	*cmd = prm->cmd;
+ 	struct se_cmd		*se_cmd = &cmd->se_cmd;
+ 	uint32_t h;
+ 	struct atio_from_isp *atio = &prm->cmd->atio;
+ 	struct qla_tc_param	tc;
+ 	uint16_t t16;
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 
+ 	ha = vha->hw;
+ 
+ 	pkt = (struct ctio_crc2_to_fw *)qpair->req->ring_ptr;
+ 	prm->pkt = pkt;
+ 	memset(pkt, 0, sizeof(*pkt));
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe071,
+ 		"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",
+ 		vha->vp_idx, __func__, se_cmd, se_cmd->prot_op,
+ 		prm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);
+ 
+ 	if ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||
+ 	    (se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))
+ 		bundling = 0;
+ 
+ 	/* Compute dif len and adjust data len to incude protection */
+ 	data_bytes = cmd->bufflen;
+ 	dif_bytes  = (data_bytes / cmd->blk_sz) * 8;
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		transfer_length = data_bytes;
+ 		if (cmd->prot_sg_cnt)
+ 			data_bytes += dif_bytes;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		transfer_length = data_bytes + dif_bytes;
+ 		break;
+ 	default:
+ 		BUG();
+ 		break;
+ 	}
+ 
+ 	if (!qlt_hba_err_chk_enabled(se_cmd))
+ 		fw_prot_opts |= 0x10; /* Disable Guard tag checking */
+ 	/* HBA error checking enabled */
+ 	else if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			fw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			fw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 		fw_prot_opts |= PO_MODE_DIF_INSERT;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		fw_prot_opts |= PO_MODE_DIF_REMOVE;
+ 		break;
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		/* FUTURE: does tcm require T10CRC<->IPCKSUM conversion? */
+ 		break;
+ 	default:/* Normal Request */
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		break;
+ 	}
+ 
+ 	/* ---- PKT ---- */
+ 	/* Update entry type to indicate Command Type CRC_2 IOCB */
+ 	pkt->entry_type  = CTIO_CRC2;
+ 	pkt->entry_count = 1;
+ 	pkt->vp_index = vha->vp_idx;
+ 
+ 	h = qlt_make_handle(qpair);
+ 	if (unlikely(h == QLA_TGT_NULL_HANDLE)) {
+ 		/*
+ 		 * CTIO type 7 from the firmware doesn't provide a way to
+ 		 * know the initiator's LOOP ID, hence we can't find
+ 		 * the session and, so, the command.
+ 		 */
+ 		return -EAGAIN;
+ 	} else
+ 		qpair->req->outstanding_cmds[h] = (srb_t *)prm->cmd;
+ 
+ 	pkt->handle  = MAKE_HANDLE(qpair->req->id, h);
+ 	pkt->handle |= CTIO_COMPLETION_HANDLE_MARK;
+ 	pkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);
+ 	pkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
+ 	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
+ 	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
+ 	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
+ 	pkt->exchange_addr   = atio->u.isp24.exchange_addr;
+ 
+ 	/* silence compile warning */
+ 	t16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	pkt->ox_id  = cpu_to_le16(t16);
+ 
+ 	t16 = (atio->u.isp24.attr << 9);
+ 	pkt->flags |= cpu_to_le16(t16);
+ 	pkt->relative_offset = cpu_to_le32(prm->cmd->offset);
+ 
+ 	/* Set transfer direction */
+ 	if (cmd->dma_data_direction == DMA_TO_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_IN);
+ 	else if (cmd->dma_data_direction == DMA_FROM_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_OUT);
+ 
+ 	pkt->dseg_count = prm->tot_dsds;
+ 	/* Fibre channel byte count */
+ 	pkt->transfer_length = cpu_to_le32(transfer_length);
+ 
+ 	/* ----- CRC context -------- */
+ 
+ 	/* Allocate CRC context from global pool */
+ 	crc_ctx_pkt = cmd->ctx =
+ 	    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);
+ 
+ 	if (!crc_ctx_pkt)
+ 		goto crc_queuing_error;
+ 
+ 	/* Zero out CTX area. */
+ 	clr_ptr = (uint8_t *)crc_ctx_pkt;
+ 	memset(clr_ptr, 0, sizeof(*crc_ctx_pkt));
+ 
+ 	crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
+ 	INIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);
+ 
+ 	/* Set handle */
+ 	crc_ctx_pkt->handle = pkt->handle;
+ 
+ 	qla_tgt_set_dif_tags(cmd, crc_ctx_pkt, &fw_prot_opts);
+ 
+ 	pkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));
+ 	pkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));
+ 	pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+ 
+ 	if (!bundling) {
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;
+ 	} else {
+ 		/*
+ 		 * Configure Bundling if we need to fetch interlaving
+ 		 * protection PCI accesses
+ 		 */
+ 		fw_prot_opts |= PO_ENABLE_DIF_BUNDLING;
+ 		crc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);
+ 		crc_ctx_pkt->u.bundling.dseg_count =
+ 			cpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;
+ 	}
+ 
+ 	/* Finish the common fields of CRC pkt */
+ 	crc_ctx_pkt->blk_size   = cpu_to_le16(cmd->blk_sz);
+ 	crc_ctx_pkt->prot_opts  = cpu_to_le16(fw_prot_opts);
+ 	crc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);
+ 	crc_ctx_pkt->guard_seed = cpu_to_le16(0);
+ 
+ 	memset((uint8_t *)&tc, 0 , sizeof(tc));
+ 	tc.vha = vha;
+ 	tc.blk_sz = cmd->blk_sz;
+ 	tc.bufflen = cmd->bufflen;
+ 	tc.sg = cmd->sg;
+ 	tc.prot_sg = cmd->prot_sg;
+ 	tc.ctx = crc_ctx_pkt;
+ 	tc.ctx_dsd_alloced = &cmd->ctx_dsd_alloced;
+ 
+ 	/* Walks data segments */
+ 	pkt->flags |= cpu_to_le16(CTIO7_FLAGS_DSD_PTR);
+ 
+ 	if (!bundling && prm->prot_seg_cnt) {
+ 		if (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,
+ 			prm->tot_dsds, &tc))
+ 			goto crc_queuing_error;
+ 	} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,
+ 		(prm->tot_dsds - prm->prot_seg_cnt), &tc))
+ 		goto crc_queuing_error;
+ 
+ 	if (bundling && prm->prot_seg_cnt) {
+ 		/* Walks dif segments */
+ 		pkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;
+ 
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;
+ 		if (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,
+ 			prm->prot_seg_cnt, &tc))
+ 			goto crc_queuing_error;
+ 	}
+ 	return QLA_SUCCESS;
+ 
+ crc_queuing_error:
+ 	/* Cleanup will be performed by the caller */
+ 	qpair->req->outstanding_cmds[h] = NULL;
+ 
+ 	return QLA_FUNCTION_FAILED;
+ }
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  /*
   * Callback to setup response of xmit_type of QLA_TGT_XMIT_DATA and *
@@@ -2027,13 -3027,23 +2639,33 @@@ int qlt_xmit_response(struct qla_tgt_cm
  	unsigned long flags = 0;
  	int res;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd->sess && cmd->sess->deleted) {
+ 		cmd->state = QLA_TGT_STATE_PROCESSED;
+ 		if (cmd->sess->logout_completed)
+ 			/* no need to terminate. FW already freed exchange. */
+ 			qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		else
+ 			qlt_send_term_exchange(qpair, cmd, &cmd->atio, 0, 0);
+ 		return 0;
+ 	}
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	memset(&prm, 0, sizeof(prm));
 +	qlt_check_srr_debug(cmd, &xmit_type);
  
  	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe018,
++<<<<<<< HEAD
 +	    "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, "
 +	    "cmd->dma_data_direction=%d\n", (xmit_type & QLA_TGT_XMIT_STATUS) ?
 +	    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction);
++=======
+ 	    "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d se_cmd[%p] qp %d\n",
+ 	    (xmit_type & QLA_TGT_XMIT_STATUS) ?
+ 	    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction,
+ 	    &cmd->se_cmd, qpair->id);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	res = qlt_pre_xmit_response(cmd, &prm, xmit_type, scsi_status,
  	    &full_req_cnt);
@@@ -2044,17 -3051,41 +2676,49 @@@
  		return res;
  	}
  
- 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 
++<<<<<<< HEAD
++=======
+ 	if (xmit_type == QLA_TGT_XMIT_STATUS)
+ 		vha->tgt_counters.core_qla_snd_status++;
+ 	else
+ 		vha->tgt_counters.core_qla_que_buf++;
  
+ 	if (!ha->flags.fw_started || cmd->reset_count != ha->chip_reset) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_PROCESSED;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg(ql_dbg_async, vha, 0xe101,
+ 			"RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, ha->chip_reset);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 		return 0;
+ 	}
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	/* Does F/W have an IOCBs for this request */
- 	res = qlt_check_reserve_free_req(vha, full_req_cnt);
+ 	res = qlt_check_reserve_free_req(qpair, full_req_cnt);
  	if (unlikely(res))
  		goto out_unmap_unlock;
  
++<<<<<<< HEAD
 +	res = qlt_24xx_build_ctio_pkt(&prm, vha);
 +	if (unlikely(res != 0))
++=======
+ 	if (cmd->se_cmd.prot_op && (xmit_type & QLA_TGT_XMIT_DATA))
+ 		res = qlt_build_ctio_crc2_pkt(qpair, &prm);
+ 	else
+ 		res = qlt_24xx_build_ctio_pkt(qpair, &prm);
+ 	if (unlikely(res != 0)) {
+ 		qpair->req->cnt += full_req_cnt;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		goto out_unmap_unlock;
 -	}
 +
  
  	pkt = (struct ctio7_to_24xx *)prm.pkt;
  
@@@ -2088,13 -3120,21 +2752,20 @@@
  			 * req_pkt().
  			 */
  			struct ctio7_to_24xx *ctio =
- 				(struct ctio7_to_24xx *)qlt_get_req_pkt(vha);
+ 				(struct ctio7_to_24xx *)qlt_get_req_pkt(
+ 				    qpair->req);
  
++<<<<<<< HEAD
 +			ql_dbg(ql_dbg_tgt, vha, 0xe019,
 +			    "Building additional status packet\n");
++=======
+ 			ql_dbg(ql_dbg_tgt, vha, 0x305e,
+ 			    "Building additional status packet 0x%p.\n",
+ 			    ctio);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
 -			/*
 -			 * T10Dif: ctio_crc2_to_fw overlay ontop of
 -			 * ctio7_to_24xx
 -			 */
  			memcpy(ctio, pkt, sizeof(*ctio));
 -			/* reset back to CTIO7 */
  			ctio->entry_count = 1;
 -			ctio->entry_type = CTIO_TYPE7;
  			ctio->dseg_count = 0;
  			ctio->u.status1.flags &= ~cpu_to_le16(
  			    CTIO7_FLAGS_DATA_IN);
@@@ -2125,9 -3167,8 +2796,14 @@@
  	return 0;
  
  out_unmap_unlock:
++<<<<<<< HEAD
 +	if (cmd->sg_mapped)
 +		qlt_unmap_sg(vha, cmd);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++=======
+ 	qlt_unmap_sg(vha, cmd);
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	return res;
  }
@@@ -2149,27 -3191,40 +2826,59 @@@ int qlt_rdy_to_xfer(struct qla_tgt_cmd 
  	prm.sg = NULL;
  	prm.req_cnt = 1;
  
++<<<<<<< HEAD
 +	/* Send marker if required */
 +	if (qlt_issue_marker(vha, 0) != QLA_SUCCESS)
 +		return -EIO;
 +
 +	ql_dbg(ql_dbg_tgt, vha, 0xe01b, "CTIO_start: vha(%d)",
 +	    (int)vha->vp_idx);
 +
++=======
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	/* Calculate number of entries and segments required */
  	if (qlt_pci_map_calc_cnt(&prm) != 0)
  		return -EAGAIN;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +
++=======
+ 	if (!ha->flags.fw_started || (cmd->reset_count != ha->chip_reset) ||
+ 	    (cmd->sess && cmd->sess->deleted)) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_NEED_DATA;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg(ql_dbg_async, vha, 0xe102,
+ 			"RESET-XFR online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, ha->chip_reset);
+ 		return 0;
+ 	}
+ 
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	/* Does F/W have an IOCBs for this request */
- 	res = qlt_check_reserve_free_req(vha, prm.req_cnt);
+ 	res = qlt_check_reserve_free_req(qpair, prm.req_cnt);
  	if (res != 0)
  		goto out_unlock_free_unmap;
++<<<<<<< HEAD
 +
 +	res = qlt_24xx_build_ctio_pkt(&prm, vha);
 +	if (unlikely(res != 0))
++=======
+ 	if (cmd->se_cmd.prot_op)
+ 		res = qlt_build_ctio_crc2_pkt(qpair, &prm);
+ 	else
+ 		res = qlt_24xx_build_ctio_pkt(qpair, &prm);
+ 
+ 	if (unlikely(res != 0)) {
+ 		qpair->req->cnt += prm.req_cnt;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		goto out_unlock_free_unmap;
 -	}
 -
  	pkt = (struct ctio7_to_24xx *)prm.pkt;
  	pkt->u.status0.flags |= cpu_to_le16(CTIO7_FLAGS_DATA_OUT |
  	    CTIO7_FLAGS_STATUS_MODE_0);
@@@ -2185,18 -3243,203 +2894,112 @@@
  	return res;
  
  out_unlock_free_unmap:
++<<<<<<< HEAD
 +	if (cmd->sg_mapped)
 +		qlt_unmap_sg(vha, cmd);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
++=======
+ 	qlt_unmap_sg(vha, cmd);
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	return res;
  }
  EXPORT_SYMBOL(qlt_rdy_to_xfer);
  
  
 -/*
 - * it is assumed either hardware_lock or qpair lock is held.
 - */
 -static void
 -qlt_handle_dif_error(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd,
 -	struct ctio_crc_from_fw *sts)
 -{
 -	uint8_t		*ap = &sts->actual_dif[0];
 -	uint8_t		*ep = &sts->expected_dif[0];
 -	uint64_t	lba = cmd->se_cmd.t_task_lba;
 -	uint8_t scsi_status, sense_key, asc, ascq;
 -	unsigned long flags;
 -
 -	cmd->trc_flags |= TRC_DIF_ERR;
 -
 -	cmd->a_guard   = be16_to_cpu(*(uint16_t *)(ap + 0));
 -	cmd->a_app_tag = be16_to_cpu(*(uint16_t *)(ap + 2));
 -	cmd->a_ref_tag = be32_to_cpu(*(uint32_t *)(ap + 4));
 -
 -	cmd->e_guard   = be16_to_cpu(*(uint16_t *)(ep + 0));
 -	cmd->e_app_tag = be16_to_cpu(*(uint16_t *)(ep + 2));
 -	cmd->e_ref_tag = be32_to_cpu(*(uint32_t *)(ep + 4));
 -
 -	ql_dbg(ql_dbg_tgt_dif, vha, 0xf075,
 -	    "%s: aborted %d state %d\n", __func__, cmd->aborted, cmd->state);
 -
 -	scsi_status = sense_key = asc = ascq = 0;
 -
 -	/* check appl tag */
 -	if (cmd->e_app_tag != cmd->a_app_tag) {
 -		ql_dbg(ql_dbg_tgt_dif, vha, 0xe00d,
 -		    "App Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] Ref[%x|%x], App[%x|%x], Guard [%x|%x] cmd=%p ox_id[%04x]",
 -		    cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
 -		    cmd->a_ref_tag, cmd->e_ref_tag, cmd->a_app_tag,
 -		    cmd->e_app_tag, cmd->a_guard, cmd->e_guard, cmd,
 -		    cmd->atio.u.isp24.fcp_hdr.ox_id);
 -
 -		cmd->dif_err_code = DIF_ERR_APP;
 -		scsi_status = SAM_STAT_CHECK_CONDITION;
 -		sense_key = ABORTED_COMMAND;
 -		asc = 0x10;
 -		ascq = 0x2;
 -	}
 -
 -	/* check ref tag */
 -	if (cmd->e_ref_tag != cmd->a_ref_tag) {
 -		ql_dbg(ql_dbg_tgt_dif, vha, 0xe00e,
 -		    "Ref Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] Ref[%x|%x], App[%x|%x], Guard[%x|%x] cmd=%p ox_id[%04x] ",
 -		    cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
 -		    cmd->a_ref_tag, cmd->e_ref_tag, cmd->a_app_tag,
 -		    cmd->e_app_tag, cmd->a_guard, cmd->e_guard, cmd,
 -		    cmd->atio.u.isp24.fcp_hdr.ox_id);
 -
 -		cmd->dif_err_code = DIF_ERR_REF;
 -		scsi_status = SAM_STAT_CHECK_CONDITION;
 -		sense_key = ABORTED_COMMAND;
 -		asc = 0x10;
 -		ascq = 0x3;
 -		goto out;
 -	}
 -
 -	/* check guard */
 -	if (cmd->e_guard != cmd->a_guard) {
 -		ql_dbg(ql_dbg_tgt_dif, vha, 0xe012,
 -		    "Guard ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] Ref[%x|%x], App[%x|%x], Guard [%x|%x] cmd=%p ox_id[%04x]",
 -		    cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
 -		    cmd->a_ref_tag, cmd->e_ref_tag, cmd->a_app_tag,
 -		    cmd->e_app_tag, cmd->a_guard, cmd->e_guard, cmd,
 -		    cmd->atio.u.isp24.fcp_hdr.ox_id);
 -
 -		cmd->dif_err_code = DIF_ERR_GRD;
 -		scsi_status = SAM_STAT_CHECK_CONDITION;
 -		sense_key = ABORTED_COMMAND;
 -		asc = 0x10;
 -		ascq = 0x1;
 -	}
 -out:
 -	switch (cmd->state) {
 -	case QLA_TGT_STATE_NEED_DATA:
 -		/* handle_data will load DIF error code  */
 -		cmd->state = QLA_TGT_STATE_DATA_IN;
 -		vha->hw->tgt.tgt_ops->handle_data(cmd);
 -		break;
 -	default:
 -		spin_lock_irqsave(&cmd->cmd_lock, flags);
 -		if (cmd->aborted) {
 -			spin_unlock_irqrestore(&cmd->cmd_lock, flags);
 -			vha->hw->tgt.tgt_ops->free_cmd(cmd);
 -			break;
 -		}
 -		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
 -
 -		qlt_send_resp_ctio(vha, cmd, scsi_status, sense_key, asc, ascq);
 -		/* assume scsi status gets out on the wire.
 -		 * Will not wait for completion.
 -		 */
 -		vha->hw->tgt.tgt_ops->free_cmd(cmd);
 -		break;
 -	}
 -}
 -
  /* If hardware_lock held on entry, might drop it, then reaquire */
  /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
++<<<<<<< HEAD
 +static int __qlt_send_term_exchange(struct scsi_qla_host *vha,
++=======
+ static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *ntfy)
+ {
+ 	struct nack_to_isp *nack;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	request_t *pkt;
+ 	int ret = 0;
+ 
+ 	ql_dbg(ql_dbg_tgt_tmr, vha, 0xe01c,
+ 	    "Sending TERM ELS CTIO (ha=%p)\n", ha);
+ 
+ 	pkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);
+ 	if (pkt == NULL) {
+ 		ql_dbg(ql_dbg_tgt, vha, 0xe080,
+ 		    "qla_target(%d): %s failed: unable to allocate "
+ 		    "request packet\n", vha->vp_idx, __func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pkt->entry_type = NOTIFY_ACK_TYPE;
+ 	pkt->entry_count = 1;
+ 	pkt->handle = QLA_TGT_SKIP_HANDLE;
+ 
+ 	nack = (struct nack_to_isp *)pkt;
+ 	nack->ox_id = ntfy->ox_id;
+ 
+ 	nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
+ 	if (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {
+ 		nack->u.isp24.flags = ntfy->u.isp24.flags &
+ 			__constant_cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);
+ 	}
+ 
+ 	/* terminate */
+ 	nack->u.isp24.flags |=
+ 		__constant_cpu_to_le16(NOTIFY_ACK_FLAGS_TERMINATE);
+ 
+ 	nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
+ 	nack->u.isp24.status = ntfy->u.isp24.status;
+ 	nack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;
+ 	nack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;
+ 	nack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;
+ 	nack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;
+ 	nack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;
+ 	nack->u.isp24.vp_index = ntfy->u.isp24.vp_index;
+ 
+ 	qla2x00_start_iocbs(vha, vha->req);
+ 	return ret;
+ }
+ 
+ static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *imm, int ha_locked)
+ {
+ 	unsigned long flags = 0;
+ 	int rc;
+ 
+ 	if (ha_locked) {
+ 		rc = __qlt_send_term_imm_notif(vha, imm);
+ 
+ #if 0	/* Todo  */
+ 		if (rc == -ENOMEM)
+ 			qlt_alloc_qfull_cmd(vha, imm, 0, 0);
+ #else
+ 		if (rc) {
+ 		}
+ #endif
+ 		goto done;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
+ 	rc = __qlt_send_term_imm_notif(vha, imm);
+ 
+ #if 0	/* Todo */
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, imm, 0, 0);
+ #endif
+ 
+ done:
+ 	if (!ha_locked)
+ 		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ }
+ 
+ /*
+  * If hardware_lock held on entry, might drop it, then reaquire
+  * This function sends the appropriate CTIO to ISP 2xxx or 24xx
+  */
+ static int __qlt_send_term_exchange(struct qla_qpair *qpair,
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	struct qla_tgt_cmd *cmd,
  	struct atio_from_isp *atio)
  {
@@@ -2204,10 -3448,11 +3008,14 @@@
  	struct qla_hw_data *ha = vha->hw;
  	request_t *pkt;
  	int ret = 0;
 -	uint16_t temp;
  
 -	ql_dbg(ql_dbg_tgt, vha, 0xe009, "Sending TERM EXCH CTIO (ha=%p)\n", ha);
 +	ql_dbg(ql_dbg_tgt, vha, 0xe01c, "Sending TERM EXCH CTIO (ha=%p)\n", ha);
  
++<<<<<<< HEAD
 +	pkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);
++=======
+ 	pkt = (request_t *)qla2x00_alloc_iocbs_ready(qpair, NULL);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	if (pkt == NULL) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe050,
  		    "qla_target(%d): %s failed: unable to allocate "
@@@ -2255,136 -3502,156 +3063,253 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void qlt_send_term_exchange(struct scsi_qla_host *vha,
 +	struct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked)
 +{
 +	unsigned long flags;
++=======
+ static void qlt_send_term_exchange(struct qla_qpair *qpair,
+ 	struct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked,
+ 	int ul_abort)
+ {
+ 	struct scsi_qla_host *vha;
+ 	unsigned long flags = 0;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	int rc;
  
- 	if (qlt_issue_marker(vha, ha_locked) < 0)
- 		return;
+ 	/* why use different vha? NPIV */
+ 	if (cmd)
+ 		vha = cmd->vha;
+ 	else
+ 		vha = qpair->vha;
  
  	if (ha_locked) {
++<<<<<<< HEAD
 +		rc = __qlt_send_term_exchange(vha, cmd, atio);
 +		goto done;
 +	}
 +	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
 +	rc = __qlt_send_term_exchange(vha, cmd, atio);
 +	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
++=======
+ 		rc = __qlt_send_term_exchange(qpair, cmd, atio);
+ 		if (rc == -ENOMEM)
+ 			qlt_alloc_qfull_cmd(vha, atio, 0, 0);
+ 		goto done;
+ 	}
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 	rc = __qlt_send_term_exchange(qpair, cmd, atio);
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, atio, 0, 0);
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  done:
 -	if (cmd && !ul_abort && !cmd->aborted) {
 -		if (cmd->sg_mapped)
 -			qlt_unmap_sg(vha, cmd);
 +	/*
 +	 * Terminate exchange will tell fw to release any active CTIO
 +	 * that's in FW posession and cleanup the exchange.
 +	 *
 +	 * "cmd->state == QLA_TGT_STATE_ABORTED" means CTIO is still
 +	 * down at FW.  Free the cmd later when CTIO comes back later
 +	 * w/aborted(0x2) status.
 +	 *
 +	 * "cmd->state != QLA_TGT_STATE_ABORTED" means CTIO is already
 +	 * back w/some err.  Free the cmd now.
 +	 */
 +	if ((rc == 1) && (cmd->state != QLA_TGT_STATE_ABORTED)) {
 +		if (!ha_locked && !in_interrupt())
 +			msleep(250); /* just in case */
 +
  		vha->hw->tgt.tgt_ops->free_cmd(cmd);
  	}
++<<<<<<< HEAD
 +	return;
 +}
 +
++=======
+ 
+ 	if (!ha_locked)
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 	return;
+ }
+ 
+ static void qlt_init_term_exchange(struct scsi_qla_host *vha)
+ {
+ 	struct list_head free_list;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 
+ 	vha->hw->tgt.leak_exchg_thresh_hold =
+ 	    (vha->hw->cur_fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;
+ 
+ 	cmd = tcmd = NULL;
+ 	if (!list_empty(&vha->hw->tgt.q_full_list)) {
+ 		INIT_LIST_HEAD(&free_list);
+ 		list_splice_init(&vha->hw->tgt.q_full_list, &free_list);
+ 
+ 		list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 			list_del(&cmd->cmd_list);
+ 			/* This cmd was never sent to TCM.  There is no need
+ 			 * to schedule free or call free_cmd
+ 			 */
+ 			qlt_free_cmd(cmd);
+ 			vha->hw->tgt.num_qfull_cmds_alloc--;
+ 		}
+ 	}
+ 	vha->hw->tgt.num_qfull_cmds_dropped = 0;
+ }
+ 
+ static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)
+ {
+ 	uint32_t total_leaked;
+ 
+ 	total_leaked = vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 	if (vha->hw->tgt.leak_exchg_thresh_hold &&
+ 	    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {
+ 
+ 		ql_dbg(ql_dbg_tgt, vha, 0xe079,
+ 		    "Chip reset due to exchange starvation: %d/%d.\n",
+ 		    total_leaked, vha->hw->cur_fw_xcb_count);
+ 
+ 		if (IS_P3P_TYPE(vha->hw))
+ 			set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
+ 		else
+ 			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		qla2xxx_wake_dpc(vha);
+ 	}
+ 
+ }
+ 
+ int qlt_abort_cmd(struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_tgt *tgt = cmd->tgt;
+ 	struct scsi_qla_host *vha = tgt->vha;
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	unsigned long flags;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
+ 	    "qla_target(%d): terminating exchange for aborted cmd=%p "
+ 	    "(se_cmd=%p, tag=%llu)", vha->vp_idx, cmd, &cmd->se_cmd,
+ 	    se_cmd->tag);
+ 
+ 	spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 	if (cmd->aborted) {
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 		/*
+ 		 * It's normal to see 2 calls in this path:
+ 		 *  1) XFER Rdy completion + CMD_T_ABORT
+ 		 *  2) TCM TMR - drain_state_list
+ 		 */
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf016,
+ 		    "multiple abort. %p transport_state %x, t_state %x, "
+ 		    "se_cmd_flags %x\n", cmd, cmd->se_cmd.transport_state,
+ 		    cmd->se_cmd.t_state, cmd->se_cmd.se_cmd_flags);
+ 		return EIO;
+ 	}
+ 	cmd->aborted = 1;
+ 	cmd->trc_flags |= TRC_ABORT;
+ 	spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 	qlt_send_term_exchange(cmd->qpair, cmd, &cmd->atio, 0, 1);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(qlt_abort_cmd);
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  void qlt_free_cmd(struct qla_tgt_cmd *cmd)
  {
 -	struct fc_port *sess = cmd->sess;
 +	BUG_ON(cmd->sg_mapped);
  
 -	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,
 -	    "%s: se_cmd[%p] ox_id %04x\n",
 -	    __func__, &cmd->se_cmd,
 -	    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
 +	if (unlikely(cmd->free_sg))
 +		kfree(cmd->sg);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
 +}
 +EXPORT_SYMBOL(qlt_free_cmd);
  
 -	BUG_ON(cmd->cmd_in_wq);
 +/* ha->hardware_lock supposed to be held on entry */
 +static int qlt_prepare_srr_ctio(struct scsi_qla_host *vha,
 +	struct qla_tgt_cmd *cmd, void *ctio)
 +{
 +	struct qla_tgt_srr_ctio *sc;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_srr_imm *imm;
  
 -	if (cmd->sg_mapped)
 -		qlt_unmap_sg(cmd->vha, cmd);
 +	tgt->ctio_srr_id++;
  
 -	if (!cmd->q_full)
 -		qlt_decr_num_pend_cmds(cmd->vha);
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf019,
 +	    "qla_target(%d): CTIO with SRR status received\n", vha->vp_idx);
  
 -	BUG_ON(cmd->sg_mapped);
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	if (unlikely(cmd->free_sg))
 -		kfree(cmd->sg);
 +	if (!ctio) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf055,
 +		    "qla_target(%d): SRR CTIO, but ctio is NULL\n",
 +		    vha->vp_idx);
 +		return -EINVAL;
 +	}
  
 -	if (!sess || !sess->se_sess) {
 -		WARN_ON(1);
 -		return;
 +	sc = kzalloc(sizeof(*sc), GFP_ATOMIC);
 +	if (sc != NULL) {
 +		sc->cmd = cmd;
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		sc->srr_id = tgt->ctio_srr_id;
 +		list_add_tail(&sc->srr_list_entry,
 +		    &tgt->srr_ctio_list);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01a,
 +		    "CTIO SRR %p added (id %d)\n", sc, sc->srr_id);
 +		if (tgt->imm_srr_id == tgt->ctio_srr_id) {
 +			int found = 0;
 +			list_for_each_entry(imm, &tgt->srr_imm_list,
 +			    srr_list_entry) {
 +				if (imm->srr_id == sc->srr_id) {
 +					found = 1;
 +					break;
 +				}
 +			}
 +			if (found) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01b,
 +				    "Scheduling srr work\n");
 +				schedule_work(&tgt->srr_work);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf056,
 +				    "qla_target(%d): imm_srr_id "
 +				    "== ctio_srr_id (%d), but there is no "
 +				    "corresponding SRR IMM, deleting CTIO "
 +				    "SRR %p\n", vha->vp_idx,
 +				    tgt->ctio_srr_id, sc);
 +				list_del(&sc->srr_list_entry);
 +				spin_unlock(&tgt->srr_lock);
 +
 +				kfree(sc);
 +				return -EINVAL;
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
 +	} else {
 +		struct qla_tgt_srr_imm *ti;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf057,
 +		    "qla_target(%d): Unable to allocate SRR CTIO entry\n",
 +		    vha->vp_idx);
 +		spin_lock(&tgt->srr_lock);
 +		list_for_each_entry_safe(imm, ti, &tgt->srr_imm_list,
 +		    srr_list_entry) {
 +			if (imm->srr_id == tgt->ctio_srr_id) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf01c,
 +				    "IMM SRR %p deleted (id %d)\n",
 +				    imm, imm->srr_id);
 +				list_del(&imm->srr_list_entry);
 +				qlt_reject_free_srr_imm(vha, imm, 1);
 +			}
 +		}
 +		spin_unlock(&tgt->srr_lock);
 +
 +		return -ENOMEM;
  	}
 -	cmd->jiffies_at_free = get_jiffies_64();
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 +
 +	return 0;
  }
 -EXPORT_SYMBOL(qlt_free_cmd);
  
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
@@@ -2393,7 -3660,18 +3318,8 @@@ static int qlt_term_ctio_exchange(struc
  	struct qla_tgt_cmd *cmd, uint32_t status)
  {
  	int term = 0;
+ 	struct scsi_qla_host *vha = qpair->vha;
  
 -	if (cmd->se_cmd.prot_op)
 -		ql_dbg(ql_dbg_tgt_dif, vha, 0xe013,
 -		    "Term DIF cmd: lba[0x%llx|%lld] len[0x%x] "
 -		    "se_cmd=%p tag[%x] op %#x/%s",
 -		     cmd->lba, cmd->lba,
 -		     cmd->num_blks, &cmd->se_cmd,
 -		     cmd->atio.u.isp24.exchange_addr,
 -		     cmd->se_cmd.prot_op,
 -		     prot_op_str(cmd->se_cmd.prot_op));
 -
  	if (ctio != NULL) {
  		struct ctio7_from_24xx *c = (struct ctio7_from_24xx *)ctio;
  		term = !(c->flags &
@@@ -2402,7 -3680,7 +3328,11 @@@
  		term = 1;
  
  	if (term)
++<<<<<<< HEAD
 +		qlt_send_term_exchange(vha, cmd, &cmd->atio, 1);
++=======
+ 		qlt_term_ctio_exchange(qpair, ctio, cmd, status);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	return term;
  }
@@@ -2424,35 -3688,45 +3354,72 @@@ static inline struct qla_tgt_cmd *qlt_g
  
  /* ha->hardware_lock supposed to be held on entry */
  static struct qla_tgt_cmd *qlt_ctio_to_cmd(struct scsi_qla_host *vha,
- 	uint32_t handle, void *ctio)
+ 	struct rsp_que *rsp, uint32_t handle, void *ctio)
  {
  	struct qla_tgt_cmd *cmd = NULL;
++<<<<<<< HEAD
 +
 +	/* Clear out internal marks */
 +	handle &= ~(CTIO_COMPLETION_HANDLE_MARK |
 +	    CTIO_INTERMEDIATE_HANDLE_MARK);
 +
 +	if (handle != QLA_TGT_NULL_HANDLE) {
 +		if (unlikely(handle == QLA_TGT_SKIP_HANDLE)) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe01d, "%s",
 +			    "SKIP_HANDLE CTIO\n");
 +			return NULL;
 +		}
 +		/* handle-1 is actually used */
 +		if (unlikely(handle > DEFAULT_OUTSTANDING_COMMANDS)) {
++=======
+ 	struct req_que *req;
+ 	int qid = GET_QID(handle);
+ 	uint32_t h = handle & ~QLA_TGT_HANDLE_MASK;
+ 
+ 	if (unlikely(h == QLA_TGT_SKIP_HANDLE))
+ 		return NULL;
+ 
+ 	if (qid == rsp->req->id) {
+ 		req = rsp->req;
+ 	} else if (vha->hw->req_q_map[qid]) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0x1000a,
+ 		    "qla_target(%d): CTIO completion with different QID %d handle %x\n",
+ 		    vha->vp_idx, rsp->id, handle);
+ 		req = vha->hw->req_q_map[qid];
+ 	} else {
+ 		return NULL;
+ 	}
+ 
+ 	h &= QLA_CMD_HANDLE_MASK;
+ 
+ 	if (h != QLA_TGT_NULL_HANDLE) {
+ 		if (unlikely(h > req->num_outstanding_cmds)) {
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  			ql_dbg(ql_dbg_tgt, vha, 0xe052,
  			    "qla_target(%d): Wrong handle %x received\n",
  			    vha->vp_idx, handle);
  			return NULL;
  		}
++<<<<<<< HEAD
 +		cmd = qlt_get_cmd(vha, handle);
 +		if (unlikely(cmd == NULL)) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe053,
 +			    "qla_target(%d): Suspicious: unable to "
 +			    "find the command with handle %x\n", vha->vp_idx,
 +			    handle);
 +			return NULL;
 +		}
++=======
+ 
+ 		cmd = (struct qla_tgt_cmd *)req->outstanding_cmds[h];
+ 		if (unlikely(cmd == NULL)) {
+ 			ql_dbg(ql_dbg_async, vha, 0xe053,
+ 			    "qla_target(%d): Suspicious: unable to find the command with handle %x req->id %d rsp->id %d\n",
+ 				vha->vp_idx, handle, req->id, rsp->id);
+ 			return NULL;
+ 		}
+ 		req->outstanding_cmds[h] = NULL;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	} else if (ctio != NULL) {
  		/* We can't get loop ID from CTIO7 */
  		ql_dbg(ql_dbg_tgt, vha, 0xe054,
@@@ -2464,6 -3738,39 +3431,42 @@@
  	return cmd;
  }
  
++<<<<<<< HEAD
++=======
+ /* hardware_lock should be held by caller. */
+ void
+ qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (cmd->sg_mapped)
+ 		qlt_unmap_sg(vha, cmd);
+ 
+ 	/* TODO: fix debug message type and ids. */
+ 	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
+ 		ql_dbg(ql_dbg_io, vha, 0xff00,
+ 		    "HOST-ABORT: state=PROCESSED.\n");
+ 	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
+ 		cmd->write_data_transferred = 0;
+ 		cmd->state = QLA_TGT_STATE_DATA_IN;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0xff01,
+ 		    "HOST-ABORT: state=DATA_IN.\n");
+ 
+ 		ha->tgt.tgt_ops->handle_data(cmd);
+ 		return;
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0xff03,
+ 		    "HOST-ABORT: state=BAD(%d).\n",
+ 		    cmd->state);
+ 		dump_stack();
+ 	}
+ 
+ 	cmd->trc_flags |= TRC_FLUSH;
+ 	ha->tgt.tgt_ops->free_cmd(cmd);
+ }
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -2472,13 -3779,9 +3475,14 @@@ static void qlt_do_ctio_completion(stru
  {
  	struct qla_hw_data *ha = vha->hw;
  	struct se_cmd *se_cmd;
 +	struct target_core_fabric_ops *tfo;
  	struct qla_tgt_cmd *cmd;
+ 	struct qla_qpair *qpair = rsp->qpair;
  
 +	ql_dbg(ql_dbg_tgt, vha, 0xe01e,
 +	    "qla_target(%d): handle(ctio %p status %#x) <- %08x\n",
 +	    vha->vp_idx, ctio, status, handle);
 +
  	if (handle & CTIO_INTERMEDIATE_HANDLE_MARK) {
  		/* That could happen only in case of an error/reset/abort */
  		if (status != CTIO_SUCCESS) {
@@@ -2551,8 -3874,9 +3555,14 @@@
  		 * level.
  		 */
  		if ((cmd->state != QLA_TGT_STATE_NEED_DATA) &&
++<<<<<<< HEAD
 +			(cmd->state != QLA_TGT_STATE_ABORTED)) {
 +			if (qlt_term_ctio_exchange(vha, ctio, cmd, status))
++=======
+ 		    (!cmd->aborted)) {
+ 			cmd->trc_flags |= TRC_CTIO_ERR;
+ 			if (qlt_term_ctio_exchange(qpair, ctio, cmd, status))
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  				return;
  		}
  	}
@@@ -2634,7 -3959,10 +3644,8 @@@ static void qlt_do_work(struct work_str
  	unsigned long flags;
  	uint32_t data_length;
  	int ret, fcp_task_attr, data_dir, bidi = 0;
+ 	struct qla_qpair *qpair = cmd->qpair;
  
 -	cmd->cmd_in_wq = 0;
 -	cmd->trc_flags |= TRC_DO_WORK;
  	if (tgt->tgt_stop)
  		goto out_term;
  
@@@ -2715,25 -4014,189 +3726,157 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
++=======
+ 	cmd->trc_flags |= TRC_DO_WORK_ERR;
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 	qlt_send_term_exchange(qpair, NULL, &cmd->atio, 1, 0);
+ 
+ 	qlt_decr_num_pend_cmds(vha);
+ 	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ static void qlt_do_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&cmd->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	__qlt_do_work(cmd);
+ }
+ 
+ static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
+ 				       struct fc_port *sess,
+ 				       struct atio_from_isp *atio)
+ {
+ 	struct se_session *se_sess = sess->se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return NULL;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 	cmd->cmd_type = TYPE_TGT_CMD;
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 	cmd->state = QLA_TGT_STATE_NEW;
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	qlt_incr_num_pend_cmds(vha);
+ 	cmd->vha = vha;
+ 	cmd->se_cmd.map_tag = tag;
+ 	cmd->sess = sess;
+ 	cmd->loop_id = sess->loop_id;
+ 	cmd->conf_compl_supported = sess->conf_compl_supported;
+ 
+ 	cmd->trc_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
+ 
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 	cmd->qpair = vha->hw->base_qpair;
+ 	cmd->se_cmd.cpuid = cmd->qpair->cpuid;
+ 
+ 	return cmd;
+ }
+ 
+ static void qlt_create_sess_from_atio(struct work_struct *work)
+ {
+ 	struct qla_tgt_sess_op *op = container_of(work,
+ 					struct qla_tgt_sess_op, work);
+ 	scsi_qla_host_t *vha = op->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&op->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	if (op->aborted) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+ 		    "sess_op with tag %u is aborted\n",
+ 		    op->atio.u.isp24.exchange_addr);
+ 		goto out_term;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+ 	    "qla_target(%d): Unable to find wwn login"
+ 	    " (s_id %x:%x:%x), trying to create it manually\n",
+ 	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
+ 
+ 	if (op->atio.u.raw.entry_count > 1) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+ 		    "Dropping multy entry atio %p\n", &op->atio);
+ 		goto out_term;
+ 	}
+ 
+ 	sess = qlt_make_local_sess(vha, s_id);
+ 	/* sess has an extra creation ref. */
+ 
+ 	if (!sess)
+ 		goto out_term;
+ 	/*
+ 	 * Now obtain a pre-allocated session tag using the original op->atio
+ 	 * packet header, and dispatch into __qlt_do_work() using the existing
+ 	 * process context.
+ 	 */
+ 	cmd = qlt_get_tag(vha, sess, &op->atio);
+ 	if (!cmd) {
+ 		struct qla_qpair *qpair = ha->base_qpair;
+ 
+ 		spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 		qlt_send_busy(qpair, &op->atio, SAM_STAT_BUSY);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		ha->tgt.tgt_ops->put_sess(sess);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 		kfree(op);
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * __qlt_do_work() will call qlt_put_sess() to release
+ 	 * the extra reference taken above by qlt_make_local_sess()
+ 	 */
+ 	__qlt_do_work(cmd);
+ 	kfree(op);
+ 	return;
+ out_term:
+ 	qlt_send_term_exchange(vha->hw->base_qpair, NULL, &op->atio, 0, 0);
+ 	kfree(op);
 -}
 -
 -/* ha->hardware_lock supposed to be held on entry */
 -static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,
 -	struct atio_from_isp *atio)
 -{
 -	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 -	struct fc_port *sess;
 -	struct qla_tgt_cmd *cmd;
 -	unsigned long flags;
 -
 -	if (unlikely(tgt->tgt_stop)) {
 -		ql_dbg(ql_dbg_io, vha, 0x3061,
 -		    "New command while device %p is shutting down\n", tgt);
 -		return -EFAULT;
 -	}
 -
 -	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);
 -	if (unlikely(!sess)) {
 -		struct qla_tgt_sess_op *op = kzalloc(sizeof(struct qla_tgt_sess_op),
 -						     GFP_ATOMIC);
 -		if (!op)
 -			return -ENOMEM;
 -
 -		memcpy(&op->atio, atio, sizeof(*atio));
 -		op->vha = vha;
 -
 -		spin_lock_irqsave(&vha->cmd_list_lock, flags);
 -		list_add_tail(&op->cmd_list, &vha->qla_sess_op_cmd_list);
 -		spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
 -
 -		INIT_WORK(&op->work, qlt_create_sess_from_atio);
 -		queue_work(qla_tgt_wq, &op->work);
 -		return 0;
 -	}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
 +}
  
 -	/* Another WWN used to have our s_id. Our PLOGI scheduled its
 -	 * session deletion, but it's still in sess_del_work wq */
 -	if (sess->deleted) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf002,
 -		    "New command while old session %p is being deleted\n",
 -		    sess);
 -		return -EFAULT;
 -	}
 +/* ha->hardware_lock supposed to be held on entry */
 +static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,
 +	struct atio_from_isp *atio)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_cmd *cmd;
  
 -	/*
 -	 * Do kref_get() before returning + dropping qla_hw_data->hardware_lock.
 -	 */
 -	if (!kref_get_unless_zero(&sess->sess_kref)) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,
 -		    "%s: kref_get fail, %8phC oxid %x \n",
 -		    __func__, sess->port_name,
 -		     be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));
 +	if (unlikely(tgt->tgt_stop)) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf021,
 +		    "New command while device %p is shutting down\n", tgt);
  		return -EFAULT;
  	}
  
@@@ -2744,17 -4207,29 +3887,36 @@@
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&cmd->cmd_list);
++=======
+ 	cmd->cmd_in_wq = 1;
+ 	cmd->trc_flags |= TRC_NEW_CMD;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
 -	spin_lock_irqsave(&vha->cmd_list_lock, flags);
 -	list_add_tail(&cmd->cmd_list, &vha->qla_cmd_list);
 -	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
 +	memcpy(&cmd->atio, atio, sizeof(*atio));
 +	cmd->state = QLA_TGT_STATE_NEW;
 +	cmd->tgt = ha->tgt.qla_tgt;
 +	cmd->vha = vha;
  
  	INIT_WORK(&cmd->work, qlt_do_work);
++<<<<<<< HEAD
 +	queue_work(qla_tgt_wq, &cmd->work);
 +	return 0;
++=======
+ 	if (ha->msix_count) {
+ 		if (cmd->atio.u.isp24.fcp_cmnd.rddata)
+ 			queue_work_on(smp_processor_id(), qla_tgt_wq,
+ 			    &cmd->work);
+ 		else
+ 			queue_work_on(cmd->se_cmd.cpuid, qla_tgt_wq,
+ 			    &cmd->work);
+ 	} else {
+ 		queue_work(qla_tgt_wq, &cmd->work);
+ 	}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
+ 	return 0;
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -2784,75 -4259,16 +3946,80 @@@ static int qlt_issue_task_mgmt(struct q
  	}
  	mcmd->tmr_func = fn;
  	mcmd->flags = flags;
++<<<<<<< HEAD
++=======
+ 	mcmd->reset_count = vha->hw->chip_reset;
+ 	mcmd->qpair = ha->base_qpair;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	switch (fn) {
 +	case QLA_TGT_CLEAR_ACA:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10000,
 +		    "qla_target(%d): CLEAR_ACA received\n", sess->vha->vp_idx);
 +		tmr_func = TMR_CLEAR_ACA;
 +		break;
 +
 +	case QLA_TGT_TARGET_RESET:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10001,
 +		    "qla_target(%d): TARGET_RESET received\n",
 +		    sess->vha->vp_idx);
 +		tmr_func = TMR_TARGET_WARM_RESET;
 +		break;
 +
  	case QLA_TGT_LUN_RESET:
 -	    abort_cmds_for_lun(vha, lun, a->u.isp24.fcp_hdr.s_id);
 -	    break;
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10002,
 +		    "qla_target(%d): LUN_RESET received\n", sess->vha->vp_idx);
 +		tmr_func = TMR_LUN_RESET;
 +		break;
 +
 +	case QLA_TGT_CLEAR_TS:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10003,
 +		    "qla_target(%d): CLEAR_TS received\n", sess->vha->vp_idx);
 +		tmr_func = TMR_CLEAR_TASK_SET;
 +		break;
 +
 +	case QLA_TGT_ABORT_TS:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10004,
 +		    "qla_target(%d): ABORT_TS received\n", sess->vha->vp_idx);
 +		tmr_func = TMR_ABORT_TASK_SET;
 +		break;
 +#if 0
 +	case QLA_TGT_ABORT_ALL:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10005,
 +		    "qla_target(%d): Doing ABORT_ALL_TASKS\n",
 +		    sess->vha->vp_idx);
 +		tmr_func = 0;
 +		break;
 +
 +	case QLA_TGT_ABORT_ALL_SESS:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10006,
 +		    "qla_target(%d): Doing ABORT_ALL_TASKS_SESS\n",
 +		    sess->vha->vp_idx);
 +		tmr_func = 0;
 +		break;
 +
 +	case QLA_TGT_NEXUS_LOSS_SESS:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10007,
 +		    "qla_target(%d): Doing NEXUS_LOSS_SESS\n",
 +		    sess->vha->vp_idx);
 +		tmr_func = 0;
 +		break;
 +
 +	case QLA_TGT_NEXUS_LOSS:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10008,
 +		    "qla_target(%d): Doing NEXUS_LOSS\n", sess->vha->vp_idx);
 +		tmr_func = 0;
 +		break;
 +#endif
 +	default:
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000a,
 +		    "qla_target(%d): Unknown task mgmt fn 0x%x\n",
 +		    sess->vha->vp_idx, fn);
 +		mempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);
 +		return -ENOSYS;
  	}
  
 -	res = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, mcmd->tmr_func, 0);
 +	res = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, tmr_func, 0);
  	if (res != 0) {
  		ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000b,
  		    "qla_target(%d): tgt.tgt_ops->handle_tmr() failed: %d\n",
@@@ -2916,11 -4340,13 +4083,16 @@@ static int __qlt_abort_task(struct scsi
  	memcpy(&mcmd->orig_iocb.imm_ntfy, iocb,
  	    sizeof(mcmd->orig_iocb.imm_ntfy));
  
 -	unpacked_lun =
 -	    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);
 +	lun = a->u.isp24.fcp_cmnd.lun;
 +	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
  	mcmd->reset_count = vha->hw->chip_reset;
++<<<<<<< HEAD
++=======
+ 	mcmd->tmr_func = QLA_TGT_2G_ABORT_TASK;
+ 	mcmd->qpair = ha->base_qpair;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
 -	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, unpacked_lun, mcmd->tmr_func,
 +	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, unpacked_lun, TMR_ABORT_TASK,
  	    le16_to_cpu(iocb->u.isp2x.seq_id));
  	if (rc != 0) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf060,
@@@ -2955,493 -4385,420 +4127,493 @@@ static int qlt_abort_task(struct scsi_q
  	return __qlt_abort_task(vha, iocb, sess);
  }
  
 -void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
 -{
 -	if (rc != MBS_COMMAND_COMPLETE) {
 -		ql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,
 -			"%s: se_sess %p / sess %p from"
 -			" port %8phC loop_id %#04x s_id %02x:%02x:%02x"
 -			" LOGO failed: %#x\n",
 -			__func__,
 -			fcport->se_sess,
 -			fcport,
 -			fcport->port_name, fcport->loop_id,
 -			fcport->d_id.b.domain, fcport->d_id.b.area,
 -			fcport->d_id.b.al_pa, rc);
 -	}
 -
 -	fcport->logout_completed = 1;
 -}
 -
  /*
 -* ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)
 -*
 -* Schedules sessions with matching port_id/loop_id but different wwn for
 -* deletion. Returns existing session with matching wwn if present.
 -* Null otherwise.
 -*/
 -struct fc_port *
 -qlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,
 -    port_id_t port_id, uint16_t loop_id, struct fc_port **conflict_sess)
 + * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
 + */
 +static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 +	struct imm_ntfy_from_isp *iocb)
  {
 -	struct fc_port *sess = NULL, *other_sess;
 -	uint64_t other_wwn;
 -
 -	*conflict_sess = NULL;
 -
 -	list_for_each_entry(other_sess, &vha->vp_fcports, list) {
 -
 -		other_wwn = wwn_to_u64(other_sess->port_name);
 +	struct qla_hw_data *ha = vha->hw;
 +	int res = 0;
  
 -		if (wwn == other_wwn) {
 -			WARN_ON(sess);
 -			sess = other_sess;
 -			continue;
 -		}
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
 +	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
 +	    vha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);
  
 -		/* find other sess with nport_id collision */
 -		if (port_id.b24 == other_sess->d_id.b24) {
 -			if (loop_id != other_sess->loop_id) {
 -				ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000c,
 -				    "Invalidating sess %p loop_id %d wwn %llx.\n",
 -				    other_sess, other_sess->loop_id, other_wwn);
 -
 -				/*
 -				 * logout_on_delete is set by default, but another
 -				 * session that has the same s_id/loop_id combo
 -				 * might have cleared it when requested this session
 -				 * deletion, so don't touch it
 -				 */
 -				qlt_schedule_sess_for_deletion(other_sess, true);
 -			} else {
 -				/*
 -				 * Another wwn used to have our s_id/loop_id
 -				 * kill the session, but don't free the loop_id
 -				 */
 -				ql_dbg(ql_dbg_tgt_tmr, vha, 0xf01b,
 -				    "Invalidating sess %p loop_id %d wwn %llx.\n",
 -				    other_sess, other_sess->loop_id, other_wwn);
 -
 -
 -				other_sess->keep_nport_handle = 1;
 -				*conflict_sess = other_sess;
 -				qlt_schedule_sess_for_deletion(other_sess,
 -				    true);
 -			}
 -			continue;
 +	switch (iocb->u.isp24.status_subcode) {
 +	case ELS_PLOGI:
 +	case ELS_FLOGI:
 +	case ELS_PRLI:
 +	case ELS_LOGO:
 +	case ELS_PRLO:
 +		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 +		break;
 +	case ELS_PDISC:
 +	case ELS_ADISC:
 +	{
 +		struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +		if (tgt->link_reinit_iocb_pending) {
- 			qlt_send_notify_ack(vha, &tgt->link_reinit_iocb,
- 			    0, 0, 0, 0, 0, 0);
++			qlt_send_notify_ack(ha->base_qpair,
++			    &tgt->link_reinit_iocb, 0, 0, 0, 0, 0, 0);
 +			tgt->link_reinit_iocb_pending = 0;
  		}
 +		res = 1; /* send notify ack */
 +		break;
 +	}
  
 -		/* find other sess with nport handle collision */
 -		if ((loop_id == other_sess->loop_id) &&
 -			(loop_id != FC_NO_LOOP_ID)) {
 -			ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000d,
 -			       "Invalidating sess %p loop_id %d wwn %llx.\n",
 -			       other_sess, other_sess->loop_id, other_wwn);
 -
 -			/* Same loop_id but different s_id
 -			 * Ok to kill and logout */
 -			qlt_schedule_sess_for_deletion(other_sess, true);
 -		}
 +	default:
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,
 +		    "qla_target(%d): Unsupported ELS command %x "
 +		    "received\n", vha->vp_idx, iocb->u.isp24.status_subcode);
 +		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 +		break;
  	}
  
 -	return sess;
 +	return res;
  }
  
 -/* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */
 -static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)
 +static int qlt_set_data_offset(struct qla_tgt_cmd *cmd, uint32_t offset)
  {
 -	struct qla_tgt_sess_op *op;
 -	struct qla_tgt_cmd *cmd;
 -	uint32_t key;
 -	int count = 0;
 -	unsigned long flags;
 -
 -	key = (((u32)s_id->b.domain << 16) |
 -	       ((u32)s_id->b.area   <<  8) |
 -	       ((u32)s_id->b.al_pa));
 -
 -	spin_lock_irqsave(&vha->cmd_list_lock, flags);
 -	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
 -		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
 -
 -		if (op_key == key) {
 -			op->aborted = true;
 -			count++;
 +#if 1
 +	/*
 +	 * FIXME: Reject non zero SRR relative offset until we can test
 +	 * this code properly.
 +	 */
 +	pr_debug("Rejecting non zero SRR rel_offs: %u\n", offset);
 +	return -1;
 +#else
 +	struct scatterlist *sg, *sgp, *sg_srr, *sg_srr_start = NULL;
 +	size_t first_offset = 0, rem_offset = offset, tmp = 0;
 +	int i, sg_srr_cnt, bufflen = 0;
 +
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe023,
 +	    "Entering qla_tgt_set_data_offset: cmd: %p, cmd->sg: %p, "
 +	    "cmd->sg_cnt: %u, direction: %d\n",
 +	    cmd, cmd->sg, cmd->sg_cnt, cmd->dma_data_direction);
 +
 +	if (!cmd->sg || !cmd->sg_cnt) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe055,
 +		    "Missing cmd->sg or zero cmd->sg_cnt in"
 +		    " qla_tgt_set_data_offset\n");
 +		return -EINVAL;
 +	}
 +	/*
 +	 * Walk the current cmd->sg list until we locate the new sg_srr_start
 +	 */
 +	for_each_sg(cmd->sg, sg, cmd->sg_cnt, i) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe024,
 +		    "sg[%d]: %p page: %p, length: %d, offset: %d\n",
 +		    i, sg, sg_page(sg), sg->length, sg->offset);
 +
 +		if ((sg->length + tmp) > offset) {
 +			first_offset = rem_offset;
 +			sg_srr_start = sg;
 +			ql_dbg(ql_dbg_tgt, cmd->vha, 0xe025,
 +			    "Found matching sg[%d], using %p as sg_srr_start, "
 +			    "and using first_offset: %zu\n", i, sg,
 +			    first_offset);
 +			break;
  		}
 +		tmp += sg->length;
 +		rem_offset -= sg->length;
  	}
  
 -	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
 -		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
 -		if (op_key == key) {
 -			op->aborted = true;
 -			count++;
 -		}
 +	if (!sg_srr_start) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe056,
 +		    "Unable to locate sg_srr_start for offset: %u\n", offset);
 +		return -EINVAL;
  	}
 +	sg_srr_cnt = (cmd->sg_cnt - i);
  
 -	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
 -		uint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
 -		if (cmd_key == key) {
 -			cmd->aborted = 1;
 -			count++;
 +	sg_srr = kzalloc(sizeof(struct scatterlist) * sg_srr_cnt, GFP_KERNEL);
 +	if (!sg_srr) {
 +		ql_dbg(ql_dbg_tgt, cmd->vha, 0xe057,
 +		    "Unable to allocate sgp\n");
 +		return -ENOMEM;
 +	}
 +	sg_init_table(sg_srr, sg_srr_cnt);
 +	sgp = &sg_srr[0];
 +	/*
 +	 * Walk the remaining list for sg_srr_start, mapping to the newly
 +	 * allocated sg_srr taking first_offset into account.
 +	 */
 +	for_each_sg(sg_srr_start, sg, sg_srr_cnt, i) {
 +		if (first_offset) {
 +			sg_set_page(sgp, sg_page(sg),
 +			    (sg->length - first_offset), first_offset);
 +			first_offset = 0;
 +		} else {
 +			sg_set_page(sgp, sg_page(sg), sg->length, 0);
  		}
 +		bufflen += sgp->length;
 +
 +		sgp = sg_next(sgp);
 +		if (!sgp)
 +			break;
  	}
 -	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
  
 -	return count;
 +	cmd->sg = sg_srr;
 +	cmd->sg_cnt = sg_srr_cnt;
 +	cmd->bufflen = bufflen;
 +	cmd->offset += offset;
 +	cmd->free_sg = 1;
 +
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe026, "New cmd->sg: %p\n", cmd->sg);
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe027, "New cmd->sg_cnt: %u\n",
 +	    cmd->sg_cnt);
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe028, "New cmd->bufflen: %u\n",
 +	    cmd->bufflen);
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe029, "New cmd->offset: %u\n",
 +	    cmd->offset);
 +
 +	if (cmd->sg_cnt < 0)
 +		BUG();
 +
 +	if (cmd->bufflen < 0)
 +		BUG();
 +
 +	return 0;
 +#endif
  }
  
 -/*
 - * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
 - */
 -static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *iocb)
 +static inline int qlt_srr_adjust_data(struct qla_tgt_cmd *cmd,
 +	uint32_t srr_rel_offs, int *xmit_type)
  {
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 -	struct qla_hw_data *ha = vha->hw;
 -	struct fc_port *sess = NULL, *conflict_sess = NULL;
 -	uint64_t wwn;
 -	port_id_t port_id;
 -	uint16_t loop_id;
 -	uint16_t wd3_lo;
 -	int res = 0;
 -	struct qlt_plogi_ack_t *pla;
 -	unsigned long flags;
 +	int res = 0, rel_offs;
  
 -	wwn = wwn_to_u64(iocb->u.isp24.port_name);
 +	rel_offs = srr_rel_offs - cmd->offset;
 +	ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf027, "srr_rel_offs=%d, rel_offs=%d",
 +	    srr_rel_offs, rel_offs);
  
 -	port_id.b.domain = iocb->u.isp24.port_id[2];
 -	port_id.b.area   = iocb->u.isp24.port_id[1];
 -	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
 -	port_id.b.rsvd_1 = 0;
 +	*xmit_type = QLA_TGT_XMIT_ALL;
  
 -	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
 +	if (rel_offs < 0) {
 +		ql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf062,
 +		    "qla_target(%d): SRR rel_offs (%d) < 0",
 +		    cmd->vha->vp_idx, rel_offs);
 +		res = -1;
 +	} else if (rel_offs == cmd->bufflen)
 +		*xmit_type = QLA_TGT_XMIT_STATUS;
 +	else if (rel_offs > 0)
 +		res = qlt_set_data_offset(cmd, rel_offs);
  
 -	ql_dbg(ql_dbg_disc, vha, 0xf026,
 -	    "qla_target(%d): Port ID: %02x:%02x:%02x ELS opcode: 0x%02x lid %d %8phC\n",
 -	    vha->vp_idx, iocb->u.isp24.port_id[2],
 -		iocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],
 -		   iocb->u.isp24.status_subcode, loop_id,
 -		iocb->u.isp24.port_name);
 +	return res;
 +}
  
 -	/* res = 1 means ack at the end of thread
 -	 * res = 0 means ack async/later.
 -	 */
 -	switch (iocb->u.isp24.status_subcode) {
 -	case ELS_PLOGI:
 +/* No locks, thread context */
 +static void qlt_handle_srr(struct scsi_qla_host *vha,
 +	struct qla_tgt_srr_ctio *sctio, struct qla_tgt_srr_imm *imm)
 +{
 +	struct imm_ntfy_from_isp *ntfy =
 +	    (struct imm_ntfy_from_isp *)&imm->imm_ntfy;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt_cmd *cmd = sctio->cmd;
 +	struct se_cmd *se_cmd = &cmd->se_cmd;
 +	unsigned long flags;
 +	int xmit_type = 0, resp = 0;
 +	uint32_t offset;
 +	uint16_t srr_ui;
  
 -		/* Mark all stale commands in qla_tgt_wq for deletion */
 -		abort_cmds_for_s_id(vha, &port_id);
 +	offset = le32_to_cpu(ntfy->u.isp24.srr_rel_offs);
 +	srr_ui = ntfy->u.isp24.srr_ui;
  
 -		if (wwn) {
 -			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 -			sess = qlt_find_sess_invalidate_other(vha, wwn,
 -				port_id, loop_id, &conflict_sess);
 -			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 -		}
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf028, "SRR cmd %p, srr_ui %x\n",
 +	    cmd, srr_ui);
  
 -		if (IS_SW_RESV_ADDR(port_id)) {
 -			res = 1;
 -			break;
 +	switch (srr_ui) {
 +	case SRR_IU_STATUS:
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
 +		qlt_send_notify_ack(vha, ntfy,
 +		    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +		xmit_type = QLA_TGT_XMIT_STATUS;
 +		resp = 1;
 +		break;
 +	case SRR_IU_DATA_IN:
 +		if (!cmd->sg || !cmd->sg_cnt) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf063,
 +			    "Unable to process SRR_IU_DATA_IN due to"
 +			    " missing cmd->sg, state: %d\n", cmd->state);
 +			dump_stack();
 +			goto out_reject;
  		}
 -
 -		pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
 -		if (!pla) {
 -			qlt_send_term_imm_notif(vha, iocb, 1);
 -			break;
 +		if (se_cmd->scsi_status != 0) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe02a,
 +			    "Rejecting SRR_IU_DATA_IN with non GOOD "
 +			    "scsi_status\n");
 +			goto out_reject;
  		}
 +		cmd->bufflen = se_cmd->data_length;
  
 -		res = 0;
 -
 -		if (conflict_sess) {
 -			conflict_sess->login_gen++;
 -			qlt_plogi_ack_link(vha, pla, conflict_sess,
 -				QLT_PLOGI_LINK_CONFLICT);
 +		if (qlt_has_data(cmd)) {
 +			if (qlt_srr_adjust_data(cmd, offset, &xmit_type) != 0)
 +				goto out_reject;
 +			spin_lock_irqsave(&ha->hardware_lock, flags);
 +			qlt_send_notify_ack(vha, ntfy,
 +			    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
 +			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +			resp = 1;
 +		} else {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf064,
 +			    "qla_target(%d): SRR for in data for cmd "
 +			    "without them (tag %d, SCSI status %d), "
 +			    "reject", vha->vp_idx, cmd->tag,
 +			    cmd->se_cmd.scsi_status);
 +			goto out_reject;
  		}
 +		break;
 +	case SRR_IU_DATA_OUT:
 +		if (!cmd->sg || !cmd->sg_cnt) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf065,
 +			    "Unable to process SRR_IU_DATA_OUT due to"
 +			    " missing cmd->sg\n");
 +			dump_stack();
 +			goto out_reject;
 +		}
 +		if (se_cmd->scsi_status != 0) {
 +			ql_dbg(ql_dbg_tgt, vha, 0xe02b,
 +			    "Rejecting SRR_IU_DATA_OUT"
 +			    " with non GOOD scsi_status\n");
 +			goto out_reject;
 +		}
 +		cmd->bufflen = se_cmd->data_length;
  
 -		if (!sess) {
 -			pla->ref_count++;
 -			qla24xx_post_newsess_work(vha, &port_id,
 -				iocb->u.isp24.port_name, pla);
 -			res = 0;
 -			break;
 +		if (qlt_has_data(cmd)) {
 +			if (qlt_srr_adjust_data(cmd, offset, &xmit_type) != 0)
 +				goto out_reject;
 +			spin_lock_irqsave(&ha->hardware_lock, flags);
 +			qlt_send_notify_ack(vha, ntfy,
 +			    0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);
 +			spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +			if (xmit_type & QLA_TGT_XMIT_DATA)
 +				qlt_rdy_to_xfer(cmd);
 +		} else {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf066,
 +			    "qla_target(%d): SRR for out data for cmd "
 +			    "without them (tag %d, SCSI status %d), "
 +			    "reject", vha->vp_idx, cmd->tag,
 +			    cmd->se_cmd.scsi_status);
 +			goto out_reject;
  		}
 +		break;
 +	default:
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf067,
 +		    "qla_target(%d): Unknown srr_ui value %x",
 +		    vha->vp_idx, srr_ui);
 +		goto out_reject;
 +	}
  
 -		qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
 -		sess->fw_login_state = DSC_LS_PLOGI_PEND;
 -		sess->d_id = port_id;
 -		sess->login_gen++;
 +	/* Transmit response in case of status and data-in cases */
 +	if (resp)
 +		qlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);
  
 -		switch (sess->disc_state) {
 -		case DSC_DELETED:
 -			qlt_plogi_ack_unref(vha, pla);
 -			break;
 +	return;
  
 -		default:
 -			/*
 -			 * Under normal circumstances we want to release nport handle
 -			 * during LOGO process to avoid nport handle leaks inside FW.
 -			 * The exception is when LOGO is done while another PLOGI with
 -			 * the same nport handle is waiting as might be the case here.
 -			 * Note: there is always a possibily of a race where session
 -			 * deletion has already started for other reasons (e.g. ACL
 -			 * removal) and now PLOGI arrives:
 -			 * 1. if PLOGI arrived in FW after nport handle has been freed,
 -			 *    FW must have assigned this PLOGI a new/same handle and we
 -			 *    can proceed ACK'ing it as usual when session deletion
 -			 *    completes.
 -			 * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
 -			 *    bit reached it, the handle has now been released. We'll
 -			 *    get an error when we ACK this PLOGI. Nothing will be sent
 -			 *    back to initiator. Initiator should eventually retry
 -			 *    PLOGI and situation will correct itself.
 -			 */
 -			sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
 -			   (sess->d_id.b24 == port_id.b24));
 +out_reject:
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	qlt_send_notify_ack(vha, ntfy, 0, 0, 0,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT,
 +	    NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);
 +	if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
 +		cmd->state = QLA_TGT_STATE_DATA_IN;
 +		dump_stack();
 +	} else
 +		qlt_send_term_exchange(vha, cmd, &cmd->atio, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +}
  
 -			ql_dbg(ql_dbg_disc, vha, 0x20f9,
 -			    "%s %d %8phC post del sess\n",
 -			    __func__, __LINE__, sess->port_name);
 +static void qlt_reject_free_srr_imm(struct scsi_qla_host *vha,
 +	struct qla_tgt_srr_imm *imm, int ha_locked)
 +{
 +	struct qla_hw_data *ha = vha->hw;
 +	unsigned long flags = 0;
  
 +#ifndef __CHECKER__
 +	if (!ha_locked)
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
 +#endif
  
 -			qlt_schedule_sess_for_deletion_lock(sess);
 -			break;
 -		}
 +	qlt_send_notify_ack(vha, (void *)&imm->imm_ntfy, 0, 0, 0,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT,
 +	    NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);
  
 -		break;
 +#ifndef __CHECKER__
 +	if (!ha_locked)
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +#endif
  
 -	case ELS_PRLI:
 -		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
 +	kfree(imm);
 +}
  
 -		if (wwn) {
 -			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 -			sess = qlt_find_sess_invalidate_other(vha, wwn, port_id,
 -				loop_id, &conflict_sess);
 -			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 -		}
 +static void qlt_handle_srr_work(struct work_struct *work)
 +{
 +	struct qla_tgt *tgt = container_of(work, struct qla_tgt, srr_work);
 +	struct scsi_qla_host *vha = tgt->vha;
 +	struct qla_tgt_srr_ctio *sctio;
 +	unsigned long flags;
  
 -		if (conflict_sess) {
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09b,
 -			    "PRLI with conflicting sess %p port %8phC\n",
 -			    conflict_sess, conflict_sess->port_name);
 -			qlt_send_term_imm_notif(vha, iocb, 1);
 -			res = 0;
 -			break;
 -		}
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf029, "Entering SRR work (tgt %p)\n",
 +	    tgt);
  
 -		if (sess != NULL) {
 -			if (sess->fw_login_state != DSC_LS_PLOGI_PEND &&
 -			    sess->fw_login_state != DSC_LS_PLOGI_COMP) {
 -				/*
 -				 * Impatient initiator sent PRLI before last
 -				 * PLOGI could finish. Will force him to re-try,
 -				 * while last one finishes.
 -				 */
 -				ql_log(ql_log_warn, sess->vha, 0xf095,
 -				    "sess %p PRLI received, before plogi ack.\n",
 -				    sess);
 -				qlt_send_term_imm_notif(vha, iocb, 1);
 -				res = 0;
 -				break;
 +restart:
 +	spin_lock_irqsave(&tgt->srr_lock, flags);
 +	list_for_each_entry(sctio, &tgt->srr_ctio_list, srr_list_entry) {
 +		struct qla_tgt_srr_imm *imm, *i, *ti;
 +		struct qla_tgt_cmd *cmd;
 +		struct se_cmd *se_cmd;
 +
 +		imm = NULL;
 +		list_for_each_entry_safe(i, ti, &tgt->srr_imm_list,
 +						srr_list_entry) {
 +			if (i->srr_id == sctio->srr_id) {
 +				list_del(&i->srr_list_entry);
 +				if (imm) {
 +					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf068,
 +					  "qla_target(%d): There must be "
 +					  "only one IMM SRR per CTIO SRR "
 +					  "(IMM SRR %p, id %d, CTIO %p\n",
 +					  vha->vp_idx, i, i->srr_id, sctio);
 +					qlt_reject_free_srr_imm(tgt->vha, i, 0);
 +				} else
 +					imm = i;
  			}
 +		}
  
 -			/*
 -			 * This shouldn't happen under normal circumstances,
 -			 * since we have deleted the old session during PLOGI
 -			 */
 -			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,
 -			    "PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\n",
 -			    sess->loop_id, sess, iocb->u.isp24.nport_handle);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02a,
 +		    "IMM SRR %p, CTIO SRR %p (id %d)\n", imm, sctio,
 +		    sctio->srr_id);
  
 -			sess->local = 0;
 -			sess->loop_id = loop_id;
 -			sess->d_id = port_id;
 -			sess->fw_login_state = DSC_LS_PRLI_PEND;
 +		if (imm == NULL) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02b,
 +			    "Not found matching IMM for SRR CTIO (id %d)\n",
 +			    sctio->srr_id);
 +			continue;
 +		} else
 +			list_del(&sctio->srr_list_entry);
  
 -			if (wd3_lo & BIT_7)
 -				sess->conf_compl_supported = 1;
 +		spin_unlock_irqrestore(&tgt->srr_lock, flags);
  
 -			if ((wd3_lo & BIT_4) == 0)
 -				sess->port_type = FCT_INITIATOR;
 -			else
 -				sess->port_type = FCT_TARGET;
 +		cmd = sctio->cmd;
 +		/*
 +		 * Reset qla_tgt_cmd SRR values and SGL pointer+count to follow
 +		 * tcm_qla2xxx_write_pending() and tcm_qla2xxx_queue_data_in()
 +		 * logic..
 +		 */
 +		cmd->offset = 0;
 +		if (cmd->free_sg) {
 +			kfree(cmd->sg);
 +			cmd->sg = NULL;
 +			cmd->free_sg = 0;
  		}
 -		res = 1; /* send notify ack */
 +		se_cmd = &cmd->se_cmd;
  
 -		/* Make session global (not used in fabric mode) */
 -		if (ha->current_topology != ISP_CFG_F) {
 -			if (sess) {
 -				ql_dbg(ql_dbg_disc, vha, 0x20fa,
 -				    "%s %d %8phC post nack\n",
 -				    __func__, __LINE__, sess->port_name);
 -				qla24xx_post_nack_work(vha, sess, iocb,
 -					SRB_NACK_PRLI);
 -				res = 0;
 -			} else {
 -				set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
 -				set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
 -				qla2xxx_wake_dpc(vha);
 -			}
 -		} else {
 -			if (sess) {
 -				ql_dbg(ql_dbg_disc, vha, 0x20fb,
 -				    "%s %d %8phC post nack\n",
 -				    __func__, __LINE__, sess->port_name);
 -				qla24xx_post_nack_work(vha, sess, iocb,
 -					SRB_NACK_PRLI);
 -				res = 0;
 -			}
 -		}
 -		break;
 +		cmd->sg_cnt = se_cmd->t_data_nents;
 +		cmd->sg = se_cmd->t_data_sg;
  
 -	case ELS_TPRLO:
 -		if (le16_to_cpu(iocb->u.isp24.flags) &
 -			NOTIFY24XX_FLAGS_GLOBAL_TPRLO) {
 -			loop_id = 0xFFFF;
 -			qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS);
 -			res = 1;
 -			break;
 -		}
 -		/* drop through */
 -	case ELS_LOGO:
 -	case ELS_PRLO:
 -		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 -		sess = qla2x00_find_fcport_by_loopid(vha, loop_id);
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02c,
 +		    "SRR cmd %p (se_cmd %p, tag %d, op %x), "
 +		    "sg_cnt=%d, offset=%d", cmd, &cmd->se_cmd, cmd->tag,
 +		    se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
 +		    cmd->sg_cnt, cmd->offset);
  
 -		if (sess) {
 -			sess->login_gen++;
 -			sess->fw_login_state = DSC_LS_LOGO_PEND;
 -			sess->logo_ack_needed = 1;
 -			memcpy(sess->iocb, iocb, IOCB_SIZE);
 -		}
 +		qlt_handle_srr(vha, sctio, imm);
  
 -		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 +		kfree(imm);
 +		kfree(sctio);
 +		goto restart;
 +	}
 +	spin_unlock_irqrestore(&tgt->srr_lock, flags);
 +}
  
 -		ql_dbg(ql_dbg_disc, vha, 0x20fc,
 -		    "%s: logo %llx res %d sess %p ",
 -		    __func__, wwn, res, sess);
 -		if (res == 0) {
 -			/*
 -			 * cmd went upper layer, look for qlt_xmit_tm_rsp()
 -			 * for LOGO_ACK & sess delete
 -			 */
 -			BUG_ON(!sess);
 -			res = 0;
 -		} else {
 -			/* cmd did not go to upper layer. */
 -			if (sess) {
 -				qlt_schedule_sess_for_deletion_lock(sess);
 -				res = 0;
 +/* ha->hardware_lock supposed to be held on entry */
 +static void qlt_prepare_srr_imm(struct scsi_qla_host *vha,
 +	struct imm_ntfy_from_isp *iocb)
 +{
 +	struct qla_tgt_srr_imm *imm;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
 +	struct qla_tgt_srr_ctio *sctio;
 +
 +	tgt->imm_srr_id++;
 +
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02d, "qla_target(%d): SRR received\n",
 +	    vha->vp_idx);
 +
 +	imm = kzalloc(sizeof(*imm), GFP_ATOMIC);
 +	if (imm != NULL) {
 +		memcpy(&imm->imm_ntfy, iocb, sizeof(imm->imm_ntfy));
 +
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		imm->srr_id = tgt->imm_srr_id;
 +		list_add_tail(&imm->srr_list_entry,
 +		    &tgt->srr_imm_list);
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02e,
 +		    "IMM NTFY SRR %p added (id %d, ui %x)\n",
 +		    imm, imm->srr_id, iocb->u.isp24.srr_ui);
 +		if (tgt->imm_srr_id == tgt->ctio_srr_id) {
 +			int found = 0;
 +			list_for_each_entry(sctio, &tgt->srr_ctio_list,
 +			    srr_list_entry) {
 +				if (sctio->srr_id == imm->srr_id) {
 +					found = 1;
 +					break;
 +				}
 +			}
 +			if (found) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf02f, "%s",
 +				    "Scheduling srr work\n");
 +				schedule_work(&tgt->srr_work);
 +			} else {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf030,
 +				    "qla_target(%d): imm_srr_id "
 +				    "== ctio_srr_id (%d), but there is no "
 +				    "corresponding SRR CTIO, deleting IMM "
 +				    "SRR %p\n", vha->vp_idx, tgt->ctio_srr_id,
 +				    imm);
 +				list_del(&imm->srr_list_entry);
 +
 +				kfree(imm);
 +
 +				spin_unlock(&tgt->srr_lock);
 +				goto out_reject;
  			}
 -			/* else logo will be ack */
  		}
 -		break;
 -	case ELS_PDISC:
 -	case ELS_ADISC:
 -	{
 -		struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 -		if (tgt->link_reinit_iocb_pending) {
 -			qlt_send_notify_ack(ha->base_qpair,
 -			    &tgt->link_reinit_iocb, 0, 0, 0, 0, 0, 0);
 -			tgt->link_reinit_iocb_pending = 0;
 -		}
 -
 -		sess = qla2x00_find_fcport_by_wwpn(vha,
 -		    iocb->u.isp24.port_name, 1);
 -		if (sess) {
 -			ql_dbg(ql_dbg_disc, vha, 0x20fd,
 -				"sess %p lid %d|%d DS %d LS %d\n",
 -				sess, sess->loop_id, loop_id,
 -				sess->disc_state, sess->fw_login_state);
 +		spin_unlock(&tgt->srr_lock);
 +	} else {
 +		struct qla_tgt_srr_ctio *ts;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf069,
 +		    "qla_target(%d): Unable to allocate SRR IMM "
 +		    "entry, SRR request will be rejected\n", vha->vp_idx);
 +
 +		/* IRQ is already OFF */
 +		spin_lock(&tgt->srr_lock);
 +		list_for_each_entry_safe(sctio, ts, &tgt->srr_ctio_list,
 +		    srr_list_entry) {
 +			if (sctio->srr_id == tgt->imm_srr_id) {
 +				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf031,
 +				    "CTIO SRR %p deleted (id %d)\n",
 +				    sctio, sctio->srr_id);
 +				list_del(&sctio->srr_list_entry);
 +				qlt_send_term_exchange(vha, sctio->cmd,
 +				    &sctio->cmd->atio, 1);
 +				kfree(sctio);
 +			}
  		}
 -
 -		res = 1; /* send notify ack */
 -		break;
 +		spin_unlock(&tgt->srr_lock);
 +		goto out_reject;
  	}
  
 -	case ELS_FLOGI:	/* should never happen */
 -	default:
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,
 -		    "qla_target(%d): Unsupported ELS command %x "
 -		    "received\n", vha->vp_idx, iocb->u.isp24.status_subcode);
 -		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 -		break;
 -	}
 +	return;
  
 -	return res;
 +out_reject:
 +	qlt_send_notify_ack(vha, iocb, 0, 0, 0,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT,
 +	    NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,
 +	    NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);
  }
  
  /*
@@@ -3586,30 -4938,36 +4759,40 @@@ static void qlt_handle_imm_notify(struc
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   * This function sends busy to ISP 2xxx or 24xx.
   */
++<<<<<<< HEAD
 +static void qlt_send_busy(struct scsi_qla_host *vha,
++=======
+ static int __qlt_send_busy(struct qla_qpair *qpair,
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	struct atio_from_isp *atio, uint16_t status)
  {
+ 	struct scsi_qla_host *vha = qpair->vha;
  	struct ctio7_to_24xx *ctio24;
  	struct qla_hw_data *ha = vha->hw;
  	request_t *pkt;
 -	struct fc_port *sess = NULL;
 -	unsigned long flags;
 -	u16 temp;
 +	struct qla_tgt_sess *sess = NULL;
  
 -	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    atio->u.isp24.fcp_hdr.s_id);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
  	if (!sess) {
++<<<<<<< HEAD
 +		qlt_send_term_exchange(vha, NULL, atio, 1);
 +		return;
++=======
+ 		qlt_send_term_exchange(qpair, NULL, atio, 1, 0);
+ 		return 0;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	}
  	/* Sending marker isn't necessary, since we called from ISR */
  
- 	pkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);
+ 	pkt = (request_t *)__qla2x00_alloc_iocbs(qpair, NULL);
  	if (!pkt) {
 -		ql_dbg(ql_dbg_io, vha, 0x3063,
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf06e,
  		    "qla_target(%d): %s failed: unable to allocate "
  		    "request packet", vha->vp_idx, __func__);
 -		return -ENOMEM;
 +		return;
  	}
  
 -	vha->tgt_counters.num_q_full_sent++;
  	pkt->entry_count = 1;
  	pkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;
  
@@@ -3634,7 -4992,213 +4817,217 @@@
  	ctio24->u.status1.scsi_status = cpu_to_le16(status);
  	/* Memory Barrier */
  	wmb();
++<<<<<<< HEAD
 +	qla2x00_start_iocbs(vha, vha->req);
++=======
+ 	qla2x00_start_iocbs(vha, qpair->req);
+ 	return 0;
+ }
+ 
+ /*
+  * This routine is used to allocate a command for either a QFull condition
+  * (ie reply SAM_STAT_BUSY) or to terminate an exchange that did not go
+  * out previously.
+  */
+ static void
+ qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint16_t status, int qfull)
+ {
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct se_session *se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 	unsigned long flags;
+ 
+ 	if (unlikely(tgt->tgt_stop)) {
+ 		ql_dbg(ql_dbg_io, vha, 0x300a,
+ 			"New command while device %p is shutting down\n", tgt);
+ 		return;
+ 	}
+ 
+ 	if ((vha->hw->tgt.num_qfull_cmds_alloc + 1) > MAX_QFULL_CMDS_ALLOC) {
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0x3068,
+ 			"qla_target(%d): %s: QFull CMD dropped[%d]\n",
+ 			vha->vp_idx, __func__,
+ 			vha->hw->tgt.num_qfull_cmds_dropped);
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	sess = ha->tgt.tgt_ops->find_sess_by_s_id
+ 		(vha, atio->u.isp24.fcp_hdr.s_id);
+ 	if (!sess)
+ 		return;
+ 
+ 	se_sess = sess->se_sess;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	if (!cmd) {
+ 		ql_dbg(ql_dbg_io, vha, 0x3009,
+ 			"qla_target(%d): %s: Allocation of cmd failed\n",
+ 			vha->vp_idx, __func__);
+ 
+ 		vha->hw->tgt.num_qfull_cmds_dropped++;
+ 		if (vha->hw->tgt.num_qfull_cmds_dropped >
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped)
+ 			vha->qla_stats.stat_max_qfull_cmds_dropped =
+ 				vha->hw->tgt.num_qfull_cmds_dropped;
+ 
+ 		qlt_chk_exch_leak_thresh_hold(vha);
+ 		return;
+ 	}
+ 
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 
+ 	qlt_incr_num_pend_cmds(vha);
+ 	INIT_LIST_HEAD(&cmd->cmd_list);
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	cmd->vha = vha;
+ 	cmd->reset_count = vha->hw->chip_reset;
+ 	cmd->q_full = 1;
+ 	cmd->qpair = ha->base_qpair;
+ 
+ 	if (qfull) {
+ 		cmd->q_full = 1;
+ 		/* NOTE: borrowing the state field to carry the status */
+ 		cmd->state = status;
+ 	} else
+ 		cmd->term_exchg = 1;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 	list_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);
+ 
+ 	vha->hw->tgt.num_qfull_cmds_alloc++;
+ 	if (vha->hw->tgt.num_qfull_cmds_alloc >
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc)
+ 		vha->qla_stats.stat_max_qfull_cmds_alloc =
+ 			vha->hw->tgt.num_qfull_cmds_alloc;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ 
+ int
+ qlt_free_qfull_cmds(struct qla_qpair *qpair)
+ {
+ 	struct scsi_qla_host *vha = qpair->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct qla_tgt_cmd *cmd, *tcmd;
+ 	struct list_head free_list, q_full_list;
+ 	int rc = 0;
+ 
+ 	if (list_empty(&ha->tgt.q_full_list))
+ 		return 0;
+ 
+ 	INIT_LIST_HEAD(&free_list);
+ 	INIT_LIST_HEAD(&q_full_list);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 	if (list_empty(&ha->tgt.q_full_list)) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ 		return 0;
+ 	}
+ 
+ 	list_splice_init(&vha->hw->tgt.q_full_list, &q_full_list);
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ 
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 	list_for_each_entry_safe(cmd, tcmd, &q_full_list, cmd_list) {
+ 		if (cmd->q_full)
+ 			/* cmd->state is a borrowed field to hold status */
+ 			rc = __qlt_send_busy(qpair, &cmd->atio, cmd->state);
+ 		else if (cmd->term_exchg)
+ 			rc = __qlt_send_term_exchange(qpair, NULL, &cmd->atio);
+ 
+ 		if (rc == -ENOMEM)
+ 			break;
+ 
+ 		if (cmd->q_full)
+ 			ql_dbg(ql_dbg_io, vha, 0x3006,
+ 			    "%s: busy sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else if (cmd->term_exchg)
+ 			ql_dbg(ql_dbg_io, vha, 0x3007,
+ 			    "%s: Term exchg sent for ox_id[%04x]\n", __func__,
+ 			    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 		else
+ 			ql_dbg(ql_dbg_io, vha, 0x3008,
+ 			    "%s: Unexpected cmd in QFull list %p\n", __func__,
+ 			    cmd);
+ 
+ 		list_del(&cmd->cmd_list);
+ 		list_add_tail(&cmd->cmd_list, &free_list);
+ 
+ 		/* piggy back on hardware_lock for protection */
+ 		vha->hw->tgt.num_qfull_cmds_alloc--;
+ 	}
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 	cmd = NULL;
+ 
+ 	list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
+ 		list_del(&cmd->cmd_list);
+ 		/* This cmd was never sent to TCM.  There is no need
+ 		 * to schedule free or call free_cmd
+ 		 */
+ 		qlt_free_cmd(cmd);
+ 	}
+ 
+ 	if (!list_empty(&q_full_list)) {
+ 		spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 		list_splice(&q_full_list, &vha->hw->tgt.q_full_list);
+ 		spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ static void
+ qlt_send_busy(struct qla_qpair *qpair, struct atio_from_isp *atio,
+     uint16_t status)
+ {
+ 	int rc = 0;
+ 	struct scsi_qla_host *vha = qpair->vha;
+ 
+ 	rc = __qlt_send_busy(qpair, atio, status);
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, atio, status, 1);
+ }
+ 
+ static int
+ qlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha, struct qla_qpair *qpair,
+ 	struct atio_from_isp *atio, uint8_t ha_locked)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t status;
+ 	unsigned long flags;
+ 
+ 	if (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))
+ 		return 0;
+ 
+ 	if (!ha_locked)
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	status = temp_sam_status;
+ 	qlt_send_busy(qpair, atio, status);
+ 	if (!ha_locked)
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	return 1;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -3684,20 -5231,43 +5077,57 @@@ static void qlt_24xx_atio_pkt(struct sc
  			    "qla_target(%d): ATIO_TYPE7 "
  			    "received with UNKNOWN exchange address, "
  			    "sending QUEUE_FULL\n", vha->vp_idx);
++<<<<<<< HEAD
 +			qlt_send_busy(vha, atio, SAM_STAT_TASK_SET_FULL);
 +			break;
 +		}
 +		if (likely(atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0))
++=======
+ 			if (!ha_locked)
+ 				spin_lock_irqsave(&ha->hardware_lock, flags);
+ 			qlt_send_busy(ha->base_qpair, atio,
+ 			    SAM_STAT_TASK_SET_FULL);
+ 			if (!ha_locked)
+ 				spin_unlock_irqrestore(&ha->hardware_lock,
+ 				    flags);
+ 			break;
+ 		}
+ 
+ 		if (likely(atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0)) {
+ 			rc = qlt_chk_qfull_thresh_hold(vha, ha->base_qpair,
+ 			    atio, ha_locked);
+ 			if (rc != 0) {
+ 				tgt->atio_irq_cmd_count--;
+ 				return;
+ 			}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  			rc = qlt_handle_cmd_for_atio(vha, atio);
 -		} else {
 +		else
  			rc = qlt_handle_task_mgmt(vha, atio);
 -		}
  		if (unlikely(rc != 0)) {
  			if (rc == -ESRCH) {
++<<<<<<< HEAD
++=======
+ 				if (!ha_locked)
+ 					spin_lock_irqsave(&ha->hardware_lock,
+ 					    flags);
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  #if 1 /* With TERM EXCHANGE some FC cards refuse to boot */
- 				qlt_send_busy(vha, atio, SAM_STAT_BUSY);
+ 				qlt_send_busy(ha->base_qpair, atio,
+ 				    SAM_STAT_BUSY);
  #else
++<<<<<<< HEAD
 +				qlt_send_term_exchange(vha, NULL, atio, 1);
 +#endif
++=======
+ 				qlt_send_term_exchange(ha->base_qpair, NULL,
+ 				    atio, 1, 0);
+ #endif
+ 				if (!ha_locked)
+ 					spin_unlock_irqrestore(
+ 					    &ha->hardware_lock, flags);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  			} else {
  				if (tgt->tgt_stop) {
  					ql_dbg(ql_dbg_tgt, vha, 0xe059,
@@@ -3709,7 -5279,14 +5139,18 @@@
  					    "qla_target(%d): Unable to send "
  					    "command to target, sending BUSY "
  					    "status.\n", vha->vp_idx);
++<<<<<<< HEAD
 +					qlt_send_busy(vha, atio, SAM_STAT_BUSY);
++=======
+ 					if (!ha_locked)
+ 						spin_lock_irqsave(
+ 						    &ha->hardware_lock, flags);
+ 					qlt_send_busy(ha->base_qpair,
+ 					    atio, SAM_STAT_BUSY);
+ 					if (!ha_locked)
+ 						spin_unlock_irqrestore(
+ 						    &ha->hardware_lock, flags);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  				}
  			}
  		}
@@@ -3742,10 -5324,11 +5183,11 @@@
  
  /* ha->hardware_lock supposed to be held on entry */
  /* called via callback from qla2xxx */
- static void qlt_response_pkt(struct scsi_qla_host *vha, response_t *pkt)
+ static void qlt_response_pkt(struct scsi_qla_host *vha,
+ 	struct rsp_que *rsp, response_t *pkt)
  {
  	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
  
  	if (unlikely(tgt == NULL)) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe05d,
@@@ -3770,9 -5346,8 +5212,13 @@@
  	case CTIO_TYPE7:
  	{
  		struct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe030, "CTIO_TYPE7: instance %d\n",
 +		    vha->vp_idx);
 +		qlt_do_ctio_completion(vha, entry->handle,
++=======
+ 		qlt_do_ctio_completion(vha, rsp, entry->handle,
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		    le16_to_cpu(entry->status)|(pkt->entry_status << 16),
  		    entry);
  		break;
@@@ -3799,18 -5365,18 +5245,29 @@@
  			    le16_to_cpu(atio->u.isp2x.status));
  			break;
  		}
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe032,
 +		    "FCP CDB: 0x%02x, sizeof(cdb): %lu",
 +		    atio->u.isp2x.cdb[0], (unsigned long
 +		    int)sizeof(atio->u.isp2x.cdb));
++=======
+ 
+ 		rc = qlt_chk_qfull_thresh_hold(vha, rsp->qpair, atio, 1);
+ 		if (rc != 0)
+ 			return;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  		rc = qlt_handle_cmd_for_atio(vha, atio);
  		if (unlikely(rc != 0)) {
  			if (rc == -ESRCH) {
  #if 1 /* With TERM EXCHANGE some FC cards refuse to boot */
- 				qlt_send_busy(vha, atio, 0);
+ 				qlt_send_busy(rsp->qpair, atio, 0);
  #else
++<<<<<<< HEAD
 +				qlt_send_term_exchange(vha, NULL, atio, 1);
++=======
+ 				qlt_send_term_exchange(rsp->qpair, NULL, atio, 1, 0);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  #endif
  			} else {
  				if (tgt->tgt_stop) {
@@@ -3818,8 -5384,8 +5275,13 @@@
  					    "qla_target: Unable to send "
  					    "command to target, sending TERM "
  					    "EXCHANGE for rsp\n");
++<<<<<<< HEAD
 +					qlt_send_term_exchange(vha, NULL,
 +					    atio, 1);
++=======
+ 					qlt_send_term_exchange(rsp->qpair, NULL,
+ 					    atio, 1, 0);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  				} else {
  					ql_dbg(ql_dbg_tgt, vha, 0xe060,
  					    "qla_target(%d): Unable to send "
@@@ -3835,9 -5401,7 +5297,13 @@@
  	case CONTINUE_TGT_IO_TYPE:
  	{
  		struct ctio_to_2xxx *entry = (struct ctio_to_2xxx *)pkt;
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe033,
 +		    "CONTINUE_TGT_IO: instance %d\n", vha->vp_idx);
 +		qlt_do_ctio_completion(vha, entry->handle,
++=======
+ 		qlt_do_ctio_completion(vha, rsp, entry->handle,
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		    le16_to_cpu(entry->status)|(pkt->entry_status << 16),
  		    entry);
  		break;
@@@ -3846,9 -5410,7 +5312,13 @@@
  	case CTIO_A64_TYPE:
  	{
  		struct ctio_to_2xxx *entry = (struct ctio_to_2xxx *)pkt;
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe034, "CTIO_A64: instance %d\n",
 +		    vha->vp_idx);
 +		qlt_do_ctio_completion(vha, entry->handle,
++=======
+ 		qlt_do_ctio_completion(vha, rsp, entry->handle,
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  		    le16_to_cpu(entry->status)|(pkt->entry_status << 16),
  		    entry);
  		break;
@@@ -4144,36 -5790,47 +5615,42 @@@ static void qlt_abort_work(struct qla_t
  	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
  	    (unsigned char *)&be_s_id);
  	if (!sess) {
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
 +		mutex_lock(&ha->tgt.tgt_mutex);
  		sess = qlt_make_local_sess(vha, s_id);
  		/* sess has got an extra creation ref */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
  
 -		spin_lock_irqsave(&ha->tgt.sess_lock, flags2);
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
  		if (!sess)
 -			goto out_term2;
 +			goto out_term;
  	} else {
 -		if (sess->deleted) {
 -			sess = NULL;
 -			goto out_term2;
 -		}
 -
 -		if (!kref_get_unless_zero(&sess->sess_kref)) {
 -			ql_dbg(ql_dbg_tgt_tmr, vha, 0xf01c,
 -			    "%s: kref_get fail %8phC \n",
 -			     __func__, sess->port_name);
 -			sess = NULL;
 -			goto out_term2;
 -		}
 +		kref_get(&sess->se_sess->sess_kref);
  	}
  
 -	rc = __qlt_24xx_handle_abts(vha, &prm->abts, sess);
 -	ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
 +	if (tgt->tgt_stop)
 +		goto out_term;
  
 +	rc = __qlt_24xx_handle_abts(vha, &prm->abts, sess);
  	if (rc != 0)
  		goto out_term;
 -	return;
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
 -out_term2:
 -	if (sess)
 -		ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);
 +	ha->tgt.tgt_ops->put_sess(sess);
 +	return;
  
  out_term:
++<<<<<<< HEAD
 +	qlt_24xx_send_abts_resp(vha, &prm->abts, FCP_TMF_REJECTED, false);
++=======
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	qlt_24xx_send_abts_resp(ha->base_qpair, &prm->abts,
+ 	    FCP_TMF_REJECTED, false);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
 +		ha->tgt.tgt_ops->put_sess(sess);
  }
  
  static void qlt_tmr_work(struct qla_tgt *tgt,
@@@ -4213,23 -5879,24 +5690,29 @@@
  	}
  
  	iocb = a;
 +	lun = a->u.isp24.fcp_cmnd.lun;
  	fn = a->u.isp24.fcp_cmnd.task_mgmt_flags;
 -	unpacked_lun =
 -	    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);
 +	unpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);
  
  	rc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
 -	ha->tgt.tgt_ops->put_sess(sess);
 -	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -
  	if (rc != 0)
  		goto out_term;
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	ha->tgt.tgt_ops->put_sess(sess);
  	return;
  
 -out_term2:
 +out_term:
 +	qlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  	if (sess)
  		ha->tgt.tgt_ops->put_sess(sess);
++<<<<<<< HEAD
++=======
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ out_term:
+ 	qlt_send_term_exchange(ha->base_qpair, NULL, &prm->tm_iocb2, 1, 0);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  }
  
  static void qlt_sess_work_fn(struct work_struct *work)
@@@ -4522,8 -6196,9 +6005,12 @@@ voi
  qlt_enable_vha(struct scsi_qla_host *vha)
  {
  	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
  	unsigned long flags;
++<<<<<<< HEAD
++=======
+ 	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  	if (!tgt) {
  		ql_dbg(ql_dbg_tgt, vha, 0xe069,
@@@ -4538,9 -6213,14 +6025,20 @@@
  	qlt_set_mode(vha);
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
++<<<<<<< HEAD
 +	set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
 +	qla2xxx_wake_dpc(vha);
 +	qla2x00_wait_for_hba_online(vha);
++=======
+ 	if (vha->vp_idx) {
+ 		qla24xx_disable_vp(vha);
+ 		qla24xx_enable_vp(vha);
+ 	} else {
+ 		set_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags);
+ 		qla2xxx_wake_dpc(base_vha);
+ 		qla2x00_wait_for_hba_online(base_vha);
+ 	}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  }
  EXPORT_SYMBOL(qlt_enable_vha);
  
@@@ -4658,7 -6337,25 +6156,29 @@@ qlt_24xx_process_atio_queue(struct scsi
  		pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
  		cnt = pkt->u.raw.entry_count;
  
++<<<<<<< HEAD
 +		qlt_24xx_atio_pkt_all_vps(vha, (struct atio_from_isp *)pkt);
++=======
+ 		if (unlikely(fcpcmd_is_corrupted(ha->tgt.atio_ring_ptr))) {
+ 			/*
+ 			 * This packet is corrupted. The header + payload
+ 			 * can not be trusted. There is no point in passing
+ 			 * it further up.
+ 			 */
+ 			ql_log(ql_log_warn, vha, 0xd03c,
+ 			    "corrupted fcp frame SID[%3phN] OXID[%04x] EXCG[%x] %64phN\n",
+ 			    pkt->u.isp24.fcp_hdr.s_id,
+ 			    be16_to_cpu(pkt->u.isp24.fcp_hdr.ox_id),
+ 			    le32_to_cpu(pkt->u.isp24.exchange_addr), pkt);
+ 
+ 			adjust_corrupted_atio(pkt);
+ 			qlt_send_term_exchange(ha->base_qpair, NULL, pkt,
+ 			    ha_locked, 0);
+ 		} else {
+ 			qlt_24xx_atio_pkt_all_vps(vha,
+ 			    (struct atio_from_isp *)pkt, ha_locked);
+ 		}
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  		for (i = 0; i < cnt; i++) {
  			ha->tgt.atio_ring_index++;
@@@ -4947,14 -6676,61 +6467,46 @@@ qla83xx_msix_atio_q(int irq, void *dev_
  	ha = rsp->hw;
  	vha = pci_get_drvdata(ha->pdev);
  
 -	spin_lock_irqsave(&ha->tgt.atio_lock, flags);
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
++<<<<<<< HEAD
  
 -	qlt_24xx_process_atio_queue(vha, 0);
 +	qlt_24xx_process_atio_queue(vha);
 +	qla24xx_process_response_queue(vha, rsp);
  
 -	spin_unlock_irqrestore(&ha->tgt.atio_lock, flags);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
  
  	return IRQ_HANDLED;
 -}
 -
 -static void
 -qlt_handle_abts_recv_work(struct work_struct *work)
 -{
 -	struct qla_tgt_sess_op *op = container_of(work,
 -		struct qla_tgt_sess_op, work);
 -	scsi_qla_host_t *vha = op->vha;
 -	struct qla_hw_data *ha = vha->hw;
 -	unsigned long flags;
 -
 -	if (qla2x00_reset_active(vha) || (op->chip_reset != ha->chip_reset))
 -		return;
 -
 -	spin_lock_irqsave(&ha->tgt.atio_lock, flags);
 -	qlt_24xx_process_atio_queue(vha, 0);
 -	spin_unlock_irqrestore(&ha->tgt.atio_lock, flags);
 -
 -	spin_lock_irqsave(&ha->hardware_lock, flags);
++=======
+ 	qlt_response_pkt_all_vps(vha, op->rsp, (response_t *)&op->atio);
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	kfree(op);
+ }
+ 
+ void
+ qlt_handle_abts_recv(struct scsi_qla_host *vha, struct rsp_que *rsp,
+     response_t *pkt)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 
+ 	op = kzalloc(sizeof(*op), GFP_ATOMIC);
+ 
+ 	if (!op) {
+ 		/* do not reach for ATIO queue here.  This is best effort err
+ 		 * recovery at this point.
+ 		 */
+ 		qlt_response_pkt_all_vps(vha, rsp, pkt);
+ 		return;
+ 	}
+ 
+ 	memcpy(&op->atio, pkt, sizeof(*pkt));
+ 	op->vha = vha;
+ 	op->chip_reset = vha->hw->chip_reset;
+ 	op->rsp = rsp;
+ 	INIT_WORK(&op->work, qlt_handle_abts_recv_work);
+ 	queue_work(qla_tgt_wq, &op->work);
+ 	return;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  }
  
  int
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,9519eeca1997..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -68,6 -70,16 +68,19 @@@
  
  /* Used to mark CTIO as intermediate */
  #define CTIO_INTERMEDIATE_HANDLE_MARK	BIT_30
++<<<<<<< HEAD
++=======
+ #define QLA_TGT_NULL_HANDLE	0
+ 
+ #define QLA_TGT_HANDLE_MASK  0xF0000000
+ #define QLA_QPID_HANDLE_MASK 0x00FF0000 /* qpair id mask */
+ #define QLA_CMD_HANDLE_MASK  0x0000FFFF
+ #define QLA_TGT_SKIP_HANDLE	(0xFFFFFFFF & ~QLA_TGT_HANDLE_MASK)
+ 
+ #define QLA_QPID_HANDLE_SHIFT 16
+ #define GET_QID(_h) ((_h & QLA_QPID_HANDLE_MASK) >> QLA_QPID_HANDLE_SHIFT)
+ 
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  #ifndef OF_SS_MODE_0
  /*
@@@ -805,34 -830,50 +818,57 @@@ struct qla_tgt 
  	struct list_head tgt_list_entry;
  };
  
++<<<<<<< HEAD
 +/*
 + * Equivilant to IT Nexus (Initiator-Target)
 + */
 +struct qla_tgt_sess {
 +	uint16_t loop_id;
 +	port_id_t s_id;
++=======
+ struct qla_tgt_sess_op {
+ 	struct scsi_qla_host *vha;
+ 	uint32_t chip_reset;
+ 	struct atio_from_isp atio;
+ 	struct work_struct work;
+ 	struct list_head cmd_list;
+ 	bool aborted;
+ 	struct rsp_que *rsp;
+ };
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
 -enum trace_flags {
 -	TRC_NEW_CMD = BIT_0,
 -	TRC_DO_WORK = BIT_1,
 -	TRC_DO_WORK_ERR = BIT_2,
 -	TRC_XFR_RDY = BIT_3,
 -	TRC_XMIT_DATA = BIT_4,
 -	TRC_XMIT_STATUS = BIT_5,
 -	TRC_SRR_RSP =  BIT_6,
 -	TRC_SRR_XRDY = BIT_7,
 -	TRC_SRR_TERM = BIT_8,
 -	TRC_SRR_CTIO = BIT_9,
 -	TRC_FLUSH = BIT_10,
 -	TRC_CTIO_ERR = BIT_11,
 -	TRC_CTIO_DONE = BIT_12,
 -	TRC_CTIO_ABORTED =  BIT_13,
 -	TRC_CTIO_STRANGE= BIT_14,
 -	TRC_CMD_DONE = BIT_15,
 -	TRC_CMD_CHK_STOP = BIT_16,
 -	TRC_CMD_FREE = BIT_17,
 -	TRC_DATA_IN = BIT_18,
 -	TRC_ABORT = BIT_19,
 -	TRC_DIF_ERR = BIT_20,
 +	unsigned int conf_compl_supported:1;
 +	unsigned int deleted:1;
 +	unsigned int local:1;
 +
 +	struct se_session *se_sess;
 +	struct scsi_qla_host *vha;
 +	struct qla_tgt *tgt;
 +
 +	struct list_head sess_list_entry;
 +	unsigned long expires;
 +	struct list_head del_list_entry;
 +
 +	uint8_t port_name[WWN_SIZE];
 +	struct work_struct free_work;
  };
  
  struct qla_tgt_cmd {
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess;
++=======
+ 	/*
+ 	 * Do not move cmd_type field. it needs to line up with srb->cmd_type
+ 	 */
+ 	uint8_t cmd_type;
+ 	uint8_t pad[7];
+ 	struct se_cmd se_cmd;
+ 	struct fc_port *sess;
+ 	struct qla_qpair *qpair;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	int state;
 +	struct se_cmd se_cmd;
 +	struct work_struct free_work;
  	struct work_struct work;
  	/* Sense buffer that will be mapped into outgoing status */
  	unsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];
@@@ -875,9 -947,10 +911,14 @@@ struct qla_tgt_sess_work_param 
  };
  
  struct qla_tgt_mgmt_cmd {
 -	uint16_t tmr_func;
 +	uint8_t tmr_func;
  	uint8_t fc_tm_rsp;
++<<<<<<< HEAD
 +	struct qla_tgt_sess *sess;
++=======
+ 	struct fc_port *sess;
+ 	struct qla_qpair *qpair;
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  	struct se_cmd se_cmd;
  	struct work_struct free_work;
  	unsigned int flags;
@@@ -972,11 -1052,11 +1013,16 @@@ static inline void qla_reverse_ini_mode
  /*
   * Exported symbols from qla_target.c LLD logic used by qla2xxx code..
   */
++<<<<<<< HEAD
 +extern void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *,
 +	struct atio_from_isp *);
 +extern void qlt_response_pkt_all_vps(struct scsi_qla_host *, response_t *);
++=======
+ extern void qlt_response_pkt_all_vps(struct scsi_qla_host *, struct rsp_que *,
+ 	response_t *);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  extern int qlt_rdy_to_xfer(struct qla_tgt_cmd *);
  extern int qlt_xmit_response(struct qla_tgt_cmd *, int, uint8_t);
 -extern int qlt_abort_cmd(struct qla_tgt_cmd *);
  extern void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *);
  extern void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *);
  extern void qlt_free_cmd(struct qla_tgt_cmd *cmd);
@@@ -1006,5 -1086,13 +1052,16 @@@ extern void qlt_stop_phase1(struct qla_
  extern void qlt_stop_phase2(struct qla_tgt *);
  extern irqreturn_t qla83xx_msix_atio_q(int, void *);
  extern void qlt_83xx_iospace_config(struct qla_hw_data *);
++<<<<<<< HEAD
++=======
+ extern int qlt_free_qfull_cmds(struct qla_qpair *);
+ extern void qlt_logo_completion_handler(fc_port_t *, int);
+ extern void qlt_do_generation_tick(struct scsi_qla_host *, int *);
+ 
+ void qlt_send_resp_ctio(scsi_qla_host_t *, struct qla_tgt_cmd *, uint8_t,
+     uint8_t, uint8_t, uint8_t);
+ extern void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *,
+     struct qla_tgt_cmd *);
++>>>>>>> 82de802ad46e (scsi: qla2xxx: Preparation for Target MQ.)
  
  #endif /* __QLA_TARGET_H */
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index e8fb4d809d33..b984a3e7ecb2 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -639,7 +639,7 @@ qla25xx_delete_queues(struct scsi_qla_host *vha)
 
 int
 qla25xx_create_req_que(struct qla_hw_data *ha, uint16_t options,
-	uint8_t vp_idx, uint16_t rid, int rsp_que, uint8_t qos)
+    uint8_t vp_idx, uint16_t rid, int rsp_que, uint8_t qos, bool startqp)
 {
 	int ret = 0;
 	struct req_que *req = NULL;
@@ -730,14 +730,16 @@ qla25xx_create_req_que(struct qla_hw_data *ha, uint16_t options,
 	    req->ring_ptr, req->ring_index, req->cnt,
 	    req->id, req->max_q_depth);
 
-	ret = qla25xx_init_req_que(base_vha, req);
-	if (ret != QLA_SUCCESS) {
-		ql_log(ql_log_fatal, base_vha, 0x00df,
-		    "%s failed.\n", __func__);
-		mutex_lock(&ha->mq_lock);
-		clear_bit(que_id, ha->req_qid_map);
-		mutex_unlock(&ha->mq_lock);
-		goto que_failed;
+	if (startqp) {
+		ret = qla25xx_init_req_que(base_vha, req);
+		if (ret != QLA_SUCCESS) {
+			ql_log(ql_log_fatal, base_vha, 0x00df,
+			    "%s failed.\n", __func__);
+			mutex_lock(&ha->mq_lock);
+			clear_bit(que_id, ha->req_qid_map);
+			mutex_unlock(&ha->mq_lock);
+			goto que_failed;
+		}
 	}
 
 	return req->id;
@@ -764,7 +766,7 @@ static void qla_do_work(struct work_struct *work)
 /* create response queue */
 int
 qla25xx_create_rsp_que(struct qla_hw_data *ha, uint16_t options,
-	uint8_t vp_idx, uint16_t rid, struct qla_qpair *qpair)
+    uint8_t vp_idx, uint16_t rid, struct qla_qpair *qpair, bool startqp)
 {
 	int ret = 0;
 	struct rsp_que *rsp = NULL;
@@ -842,14 +844,16 @@ qla25xx_create_rsp_que(struct qla_hw_data *ha, uint16_t options,
 	if (ret)
 		goto que_failed;
 
-	ret = qla25xx_init_rsp_que(base_vha, rsp);
-	if (ret != QLA_SUCCESS) {
-		ql_log(ql_log_fatal, base_vha, 0x00e7,
-		    "%s failed.\n", __func__);
-		mutex_lock(&ha->mq_lock);
-		clear_bit(que_id, ha->rsp_qid_map);
-		mutex_unlock(&ha->mq_lock);
-		goto que_failed;
+	if (startqp) {
+		ret = qla25xx_init_rsp_que(base_vha, rsp);
+		if (ret != QLA_SUCCESS) {
+			ql_log(ql_log_fatal, base_vha, 0x00e7,
+			    "%s failed.\n", __func__);
+			mutex_lock(&ha->mq_lock);
+			clear_bit(que_id, ha->rsp_qid_map);
+			mutex_unlock(&ha->mq_lock);
+			goto que_failed;
+		}
 	}
 	rsp->req = NULL;
 
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
