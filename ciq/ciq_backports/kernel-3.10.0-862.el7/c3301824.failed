bpf: nfp: Report bpf_prog ID during XDP_QUERY_PROG

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit c330182479fa73227c44404d104577580d441458
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c3301824.failed

Add support to nfp to report bpf_prog ID during XDP_QUERY_PROG.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Cc: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Alexei Starovoitov <ast@fb.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c330182479fa73227c44404d104577580d441458)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,378512dec80d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2600,8 -3209,82 +2600,87 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
++<<<<<<< HEAD
 +static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
++=======
+ static int nfp_net_xdp_setup(struct nfp_net *nn, struct netdev_xdp *xdp)
+ {
+ 	struct bpf_prog *old_prog = nn->dp.xdp_prog;
+ 	struct bpf_prog *prog = xdp->prog;
+ 	struct nfp_net_dp *dp;
+ 	int err;
+ 
+ 	if (!prog && !nn->dp.xdp_prog)
+ 		return 0;
+ 	if (prog && nn->dp.xdp_prog) {
+ 		prog = xchg(&nn->dp.xdp_prog, prog);
+ 		bpf_prog_put(prog);
+ 		nfp_app_xdp_offload(nn->app, nn, nn->dp.xdp_prog);
+ 		return 0;
+ 	}
+ 
+ 	dp = nfp_net_clone_dp(nn);
+ 	if (!dp)
+ 		return -ENOMEM;
+ 
+ 	dp->xdp_prog = prog;
+ 	dp->num_tx_rings += prog ? nn->dp.num_rx_rings : -nn->dp.num_rx_rings;
+ 	dp->rx_dma_dir = prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE;
+ 	dp->rx_dma_off = prog ? XDP_PACKET_HEADROOM - nn->dp.rx_offset : 0;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	err = nfp_net_ring_reconfig(nn, dp, xdp->extack);
+ 	if (err)
+ 		return err;
+ 
+ 	if (old_prog)
+ 		bpf_prog_put(old_prog);
+ 
+ 	nfp_app_xdp_offload(nn->app, nn, nn->dp.xdp_prog);
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 		return nfp_net_xdp_setup(nn, xdp);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->dp.xdp_prog;
+ 		xdp->prog_id = nn->dp.xdp_prog ? nn->dp.xdp_prog->aux->id : 0;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static int nfp_net_set_mac_address(struct net_device *netdev, void *addr)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	struct sockaddr *saddr = addr;
+ 	int err;
+ 
+ 	err = eth_prepare_mac_addr_change(netdev, addr);
+ 	if (err)
+ 		return err;
+ 
+ 	nfp_net_write_mac_addr(nn, saddr->sa_data);
+ 
+ 	err = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_MACADDR);
+ 	if (err)
+ 		return err;
+ 
+ 	eth_commit_mac_addr_change(netdev, addr);
+ 
+ 	return 0;
+ }
+ 
+ const struct net_device_ops nfp_net_netdev_ops = {
++>>>>>>> c330182479fa (bpf: nfp: Report bpf_prog ID during XDP_QUERY_PROG)
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
