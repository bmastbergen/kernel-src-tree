fsnotify: Make fsnotify_mark_connector hold inode reference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit e911d8af87dba7642138f4320ca3db80629989f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e911d8af.failed

Currently inode reference is held by fsnotify marks. Change the rules so
that inode reference is held by fsnotify_mark_connector structure
whenever the list is non-empty. This simplifies the code and is more
logical.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit e911d8af87dba7642138f4320ca3db80629989f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/inode_mark.c
#	fs/notify/mark.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,c3873b6920e7..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -43,9 -43,10 +43,14 @@@ void fsnotify_recalc_inode_mask(struct 
  	__fsnotify_update_child_dentry_flags(inode);
  }
  
- void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
+ struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
  {
++<<<<<<< HEAD
 +	struct inode *inode = mark->inode;
++=======
+ 	struct inode *inode = mark->connector->inode;
+ 	bool empty;
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
  
  	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
  	assert_spin_locked(&mark->lock);
@@@ -53,15 -54,18 +58,22 @@@
  	spin_lock(&inode->i_lock);
  
  	hlist_del_init_rcu(&mark->obj_list);
++<<<<<<< HEAD
 +	mark->inode = NULL;
++=======
+ 	empty = hlist_empty(&mark->connector->list);
+ 	mark->connector = NULL;
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
  
  	/*
  	 * this mark is now off the inode->i_fsnotify_marks list and we
  	 * hold the inode->i_lock, so this is the perfect time to update the
  	 * inode->i_fsnotify_mask
  	 */
 -	inode->i_fsnotify_mask = fsnotify_recalc_mask(inode->i_fsnotify_marks);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
  	spin_unlock(&inode->i_lock);
+ 
+ 	return empty ? inode : NULL;
  }
  
  /*
@@@ -89,31 -93,6 +101,34 @@@ struct fsnotify_mark *fsnotify_find_ino
  }
  
  /*
++<<<<<<< HEAD
 + * If we are setting a mark mask on an inode mark we should pin the inode
 + * in memory.
 + */
 +void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,
 +					 __u32 mask)
 +{
 +	struct inode *inode;
 +
 +	assert_spin_locked(&mark->lock);
 +
 +	if (mask &&
 +	    mark->inode &&
 +	    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {
 +		mark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;
 +		inode = igrab(mark->inode);
 +		/*
 +		 * we shouldn't be able to get here if the inode wasn't
 +		 * already safely held in memory.  But bug in case it
 +		 * ever is wrong.
 +		 */
 +		BUG_ON(!inode);
 +	}
 +}
 +
 +/*
++=======
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
   * Attach an initialized mark to a given inode.
   * These marks may be used for the fsnotify backend to determine which
   * event types should be delivered to which group and for which inodes.  These
diff --cc fs/notify/mark.c
index 44836e539169,8a15c64fbe80..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -137,10 -142,9 +137,16 @@@ void fsnotify_detach_mark(struct fsnoti
  
  	mark->flags &= ~FSNOTIFY_MARK_FLAG_ATTACHED;
  
++<<<<<<< HEAD
 +	if (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {
 +		inode = mark->inode;
 +		fsnotify_destroy_inode_mark(mark);
 +	} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)
++=======
+ 	if (mark->connector->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		inode = fsnotify_destroy_inode_mark(mark);
+ 	else if (mark->connector->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT)
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
  		fsnotify_destroy_vfsmount_mark(mark);
  	else
  		BUG();
@@@ -256,9 -273,6 +262,12 @@@ void fsnotify_set_mark_mask_locked(stru
  	assert_spin_locked(&mark->lock);
  
  	mark->mask = mask;
++<<<<<<< HEAD
 +
 +	if (mark->flags & FSNOTIFY_MARK_FLAG_INODE)
 +		fsnotify_set_inode_mark_mask_locked(mark, mask);
++=======
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
  }
  
  void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)
@@@ -304,17 -318,62 +313,25 @@@ int fsnotify_compare_groups(struct fsno
  	return -1;
  }
  
 -static int fsnotify_attach_connector_to_object(
 -					struct fsnotify_mark_connector **connp,
 -					struct inode *inode,
 -					struct vfsmount *mnt)
 -{
 -	struct fsnotify_mark_connector *conn;
 -
 -	conn = kmem_cache_alloc(fsnotify_mark_connector_cachep, GFP_ATOMIC);
 -	if (!conn)
 -		return -ENOMEM;
 -	INIT_HLIST_HEAD(&conn->list);
 -	if (inode) {
 -		conn->flags = FSNOTIFY_OBJ_TYPE_INODE;
 -		conn->inode = inode;
 -	} else {
 -		conn->flags = FSNOTIFY_OBJ_TYPE_VFSMOUNT;
 -		conn->mnt = mnt;
 -	}
 -	/*
 -	 * Make sure 'conn' initialization is visible. Matches
 -	 * lockless_dereference() in fsnotify().
 -	 */
 -	smp_wmb();
 -	*connp = conn;
 -
 -	return 0;
 -}
 -
 -/*
 - * Add mark into proper place in given list of marks. These marks may be used
 - * for the fsnotify backend to determine which event types should be delivered
 - * to which group and for which inodes. These marks are ordered according to
 - * priority, highest number first, and then by the group's location in memory.
 - */
 -int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
 -			   struct fsnotify_mark *mark, struct inode *inode,
 -			   struct vfsmount *mnt, int allow_dups)
 +/* Add mark into proper place in given list of marks */
 +int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,
 +			   int allow_dups)
  {
  	struct fsnotify_mark *lmark, *last = NULL;
 -	struct fsnotify_mark_connector *conn;
  	int cmp;
 -	int err;
 -
 -	if (!*connp) {
 -		err = fsnotify_attach_connector_to_object(connp, inode, mnt);
 -		if (err)
 -			return err;
 -	}
 -	conn = *connp;
  
  	/* is mark the first mark? */
++<<<<<<< HEAD
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&mark->obj_list, head);
 +		return 0;
++=======
+ 	if (hlist_empty(&conn->list)) {
+ 		hlist_add_head_rcu(&mark->obj_list, &conn->list);
+ 		if (inode)
+ 			__iget(inode);
+ 		goto added;
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
  	}
  
  	/* should mark be in the middle of the current list? */
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,96333fb09309..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -195,6 -195,23 +195,26 @@@ struct fsnotify_group 
  #define FSNOTIFY_EVENT_INODE	2
  
  /*
++<<<<<<< HEAD
++=======
+  * Inode / vfsmount point to this structure which tracks all marks attached to
+  * the inode / vfsmount. The reference to inode / vfsmount is held by this
+  * structure whenever the list is non-empty. The structure is freed only when
+  * inode / vfsmount gets freed.
+  */
+ struct fsnotify_mark_connector {
+ #define FSNOTIFY_OBJ_TYPE_INODE		0x01
+ #define FSNOTIFY_OBJ_TYPE_VFSMOUNT	0x02
+ 	unsigned int flags;	/* Type of object [lock] */
+ 	union {	/* Object pointer [lock] */
+ 		struct inode *inode;
+ 		struct vfsmount *mnt;
+ 	};
+ 	struct hlist_head list;
+ };
+ 
+ /*
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
   * A mark is simply an object attached to an in core inode which allows an
   * fsnotify listener to indicate they are either no longer interested in events
   * of a type matching mask or only interested in those events.
@@@ -225,18 -242,13 +245,24 @@@ struct fsnotify_mark 
  	spinlock_t lock;
  	/* List of marks for inode / vfsmount [obj_lock] */
  	struct hlist_node obj_list;
 -	/* Head of list of marks for an object [mark->lock, group->mark_mutex] */
 -	struct fsnotify_mark_connector *connector;
 +	union {	/* Object pointer [mark->lock, group->mark_mutex] */
 +		struct inode *inode;	/* inode this mark is associated with */
 +		struct vfsmount *mnt;	/* vfsmount this mark is associated with */
 +	};
  	/* Events types to ignore [mark->lock, group->mark_mutex] */
  	__u32 ignored_mask;
++<<<<<<< HEAD
 +#define FSNOTIFY_MARK_FLAG_INODE		0x01
 +#define FSNOTIFY_MARK_FLAG_VFSMOUNT		0x02
 +#define FSNOTIFY_MARK_FLAG_OBJECT_PINNED	0x04
 +#define FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY	0x08
 +#define FSNOTIFY_MARK_FLAG_ALIVE		0x10
 +#define FSNOTIFY_MARK_FLAG_ATTACHED		0x20
++=======
+ #define FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY	0x01
+ #define FSNOTIFY_MARK_FLAG_ALIVE		0x02
+ #define FSNOTIFY_MARK_FLAG_ATTACHED		0x04
++>>>>>>> e911d8af87db (fsnotify: Make fsnotify_mark_connector hold inode reference)
  	unsigned int flags;		/* flags [mark->lock] */
  	void (*free_mark)(struct fsnotify_mark *mark); /* called on final put+free */
  };
diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 0a3bc2cf192c..4ec74d0fb029 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -21,8 +21,6 @@ extern u32 fsnotify_recalc_mask(struct hlist_head *head);
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
-extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
-						__u32 mask);
 /* Add mark to a proper place in mark list */
 extern int fsnotify_add_mark_list(struct hlist_head *head,
 				  struct fsnotify_mark *mark,
@@ -39,7 +37,7 @@ extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 /* vfsmount specific destruction of a mark */
 extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */
-extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
+extern struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* Find mark belonging to given group in the list of marks */
 extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 						struct fsnotify_group *group);
* Unmerged path fs/notify/inode_mark.c
* Unmerged path fs/notify/mark.c
* Unmerged path include/linux/fsnotify_backend.h
