gfs2: Clean up {lookup,fillup}_metapath

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] gfs2: Clean up (lookup,fillup)_metapath (Andreas Grunbacher) [1542594]
Rebuild_FUZZ: 94.87%
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit e8b43fe0c1e035a135be7ca3791d465fcb1b501e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e8b43fe0.failed

Split out the entire lookup loop from lookup_metapath and
fillup_metapath.  Make both functions return the actual height in
mp->mp_aheight, and return 0 on success.  Handle lookup errors properly
in trunc_dealloc.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit e8b43fe0c1e035a135be7ca3791d465fcb1b501e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
diff --cc fs/gfs2/bmap.c
index 15571283d4f0,1110aa9f6f31..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -296,6 -305,24 +296,27 @@@ static void gfs2_metapath_ra(struct gfs
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int __fillup_metapath(struct gfs2_inode *ip, struct metapath *mp,
+ 			     unsigned int x, unsigned int h)
+ {
+ 	for (; x < h; x++) {
+ 		__be64 *ptr = metapointer(x, mp);
+ 		u64 dblock = be64_to_cpu(*ptr);
+ 		int ret;
+ 
+ 		if (!dblock)
+ 			break;
+ 		ret = gfs2_meta_indirect_buffer(ip, x + 1, dblock, &mp->mp_bh[x + 1]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	mp->mp_aheight = x + 1;
+ 	return 0;
+ }
+ 
++>>>>>>> e8b43fe0c1e0 (gfs2: Clean up {lookup,fillup}_metapath)
  /**
   * lookup_metapath - Walk the metadata tree to a specific point
   * @ip: The inode
@@@ -315,29 -342,34 +336,60 @@@
  
  static int lookup_metapath(struct gfs2_inode *ip, struct metapath *mp)
  {
++<<<<<<< HEAD
 +	unsigned int end_of_metadata = ip->i_height - 1;
 +	unsigned int x;
 +	__be64 *ptr;
 +	u64 dblock;
 +	int ret;
 +
 +	for (x = 0; x < end_of_metadata; x++) {
 +		ptr = metapointer(x, mp);
 +		dblock = be64_to_cpu(*ptr);
 +		if (!dblock)
 +			return x + 1;
 +
 +		ret = gfs2_meta_indirect_buffer(ip, x+1, dblock, &mp->mp_bh[x+1]);
 +		if (ret)
 +			goto out;
 +	}
 +
 +	ret = ip->i_height;
 +out:
 +	mp->mp_aheight = ret;
 +	return ret;
 +}
 +
++=======
+ 	return __fillup_metapath(ip, mp, 0, ip->i_height - 1);
+ }
+ 
+ /**
+  * fillup_metapath - fill up buffers for the metadata path to a specific height
+  * @ip: The inode
+  * @mp: The metapath
+  * @h: The height to which it should be mapped
+  *
+  * Similar to lookup_metapath, but does lookups for a range of heights
+  *
+  * Returns: error
+  */
+ 
+ static int fillup_metapath(struct gfs2_inode *ip, struct metapath *mp, int h)
+ {
+ 	unsigned int x = 0;
+ 
+ 	if (h) {
+ 		/* find the first buffer we need to look up. */
+ 		for (x = h - 1; x > 0; x--) {
+ 			if (mp->mp_bh[x])
+ 				break;
+ 		}
+ 	}
+ 	return __fillup_metapath(ip, mp, x, h);
+ }
+ 
++>>>>>>> e8b43fe0c1e0 (gfs2: Clean up {lookup,fillup}_metapath)
  static inline void release_metapath(struct metapath *mp)
  {
  	int i;
@@@ -591,6 -632,190 +643,193 @@@ static int gfs2_bmap_alloc(struct inod
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * hole_size - figure out the size of a hole
+  * @inode: The inode
+  * @lblock: The logical starting block number
+  * @mp: The metapath
+  *
+  * Returns: The hole size in bytes
+  *
+  */
+ static u64 hole_size(struct inode *inode, sector_t lblock, struct metapath *mp)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	struct metapath mp_eof;
+ 	u64 factor = 1;
+ 	int hgt;
+ 	u64 holesz = 0;
+ 	const __be64 *first, *end, *ptr;
+ 	const struct buffer_head *bh;
+ 	u64 lblock_stop = (i_size_read(inode) - 1) >> inode->i_blkbits;
+ 	int zeroptrs;
+ 	bool done = false;
+ 
+ 	/* Get another metapath, to the very last byte */
+ 	find_metapath(sdp, lblock_stop, &mp_eof, ip->i_height);
+ 	for (hgt = ip->i_height - 1; hgt >= 0 && !done; hgt--) {
+ 		bh = mp->mp_bh[hgt];
+ 		if (bh) {
+ 			zeroptrs = 0;
+ 			first = metapointer(hgt, mp);
+ 			end = (const __be64 *)(bh->b_data + bh->b_size);
+ 
+ 			for (ptr = first; ptr < end; ptr++) {
+ 				if (*ptr) {
+ 					done = true;
+ 					break;
+ 				} else {
+ 					zeroptrs++;
+ 				}
+ 			}
+ 		} else {
+ 			zeroptrs = sdp->sd_inptrs;
+ 		}
+ 		if (factor * zeroptrs >= lblock_stop - lblock + 1) {
+ 			holesz = lblock_stop - lblock + 1;
+ 			break;
+ 		}
+ 		holesz += factor * zeroptrs;
+ 
+ 		factor *= sdp->sd_inptrs;
+ 		if (hgt && (mp->mp_list[hgt - 1] < mp_eof.mp_list[hgt - 1]))
+ 			(mp->mp_list[hgt - 1])++;
+ 	}
+ 	return holesz << inode->i_blkbits;
+ }
+ 
+ static void gfs2_stuffed_iomap(struct inode *inode, struct iomap *iomap)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 
+ 	iomap->addr = (ip->i_no_addr << inode->i_blkbits) +
+ 		      sizeof(struct gfs2_dinode);
+ 	iomap->offset = 0;
+ 	iomap->length = i_size_read(inode);
+ 	iomap->type = IOMAP_MAPPED;
+ 	iomap->flags = IOMAP_F_DATA_INLINE;
+ }
+ 
+ /**
+  * gfs2_iomap_begin - Map blocks from an inode to disk blocks
+  * @inode: The inode
+  * @pos: Starting position in bytes
+  * @length: Length to map, in bytes
+  * @flags: iomap flags
+  * @iomap: The iomap structure
+  *
+  * Returns: errno
+  */
+ int gfs2_iomap_begin(struct inode *inode, loff_t pos, loff_t length,
+ 		     unsigned flags, struct iomap *iomap)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	struct metapath mp = { .mp_aheight = 1, };
+ 	unsigned int factor = sdp->sd_sb.sb_bsize;
+ 	const u64 *arr = sdp->sd_heightsize;
+ 	__be64 *ptr;
+ 	sector_t lblock;
+ 	sector_t lend;
+ 	int ret;
+ 	int eob;
+ 	unsigned int len;
+ 	struct buffer_head *bh;
+ 	u8 height;
+ 
+ 	trace_gfs2_iomap_start(ip, pos, length, flags);
+ 	if (!length) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if ((flags & IOMAP_REPORT) && gfs2_is_stuffed(ip)) {
+ 		gfs2_stuffed_iomap(inode, iomap);
+ 		if (pos >= iomap->length)
+ 			return -ENOENT;
+ 		ret = 0;
+ 		goto out;
+ 	}
+ 
+ 	lblock = pos >> inode->i_blkbits;
+ 	lend = (pos + length + sdp->sd_sb.sb_bsize - 1) >> inode->i_blkbits;
+ 
+ 	iomap->offset = lblock << inode->i_blkbits;
+ 	iomap->addr = IOMAP_NULL_ADDR;
+ 	iomap->type = IOMAP_HOLE;
+ 	iomap->length = (u64)(lend - lblock) << inode->i_blkbits;
+ 	iomap->flags = IOMAP_F_MERGED;
+ 	bmap_lock(ip, 0);
+ 
+ 	/*
+ 	 * Directory data blocks have a struct gfs2_meta_header header, so the
+ 	 * remaining size is smaller than the filesystem block size.  Logical
+ 	 * block numbers for directories are in units of this remaining size!
+ 	 */
+ 	if (gfs2_is_dir(ip)) {
+ 		factor = sdp->sd_jbsize;
+ 		arr = sdp->sd_jheightsize;
+ 	}
+ 
+ 	ret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);
+ 	if (ret)
+ 		goto out_release;
+ 
+ 	height = ip->i_height;
+ 	while ((lblock + 1) * factor > arr[height])
+ 		height++;
+ 	find_metapath(sdp, lblock, &mp, height);
+ 	if (height > ip->i_height || gfs2_is_stuffed(ip))
+ 		goto do_alloc;
+ 
+ 	ret = lookup_metapath(ip, &mp);
+ 	if (ret)
+ 		goto out_release;
+ 
+ 	if (mp.mp_aheight != ip->i_height)
+ 		goto do_alloc;
+ 
+ 	ptr = metapointer(ip->i_height - 1, &mp);
+ 	if (*ptr == 0)
+ 		goto do_alloc;
+ 
+ 	iomap->type = IOMAP_MAPPED;
+ 	iomap->addr = be64_to_cpu(*ptr) << inode->i_blkbits;
+ 
+ 	bh = mp.mp_bh[ip->i_height - 1];
+ 	len = gfs2_extent_length(bh->b_data, bh->b_size, ptr, lend - lblock, &eob);
+ 	if (eob)
+ 		iomap->flags |= IOMAP_F_BOUNDARY;
+ 	iomap->length = (u64)len << inode->i_blkbits;
+ 
+ 	ret = 0;
+ 
+ out_release:
+ 	release_metapath(&mp);
+ 	bmap_unlock(ip, 0);
+ out:
+ 	trace_gfs2_iomap_end(ip, iomap, ret);
+ 	return ret;
+ 
+ do_alloc:
+ 	if (!(flags & IOMAP_WRITE)) {
+ 		if (pos >= i_size_read(inode)) {
+ 			ret = -ENOENT;
+ 			goto out_release;
+ 		}
+ 		ret = 0;
+ 		iomap->length = hole_size(inode, lblock, &mp);
+ 		goto out_release;
+ 	}
+ 
+ 	ret = gfs2_iomap_alloc(inode, iomap, flags, &mp);
+ 	goto out_release;
+ }
+ 
+ /**
++>>>>>>> e8b43fe0c1e0 (gfs2: Clean up {lookup,fillup}_metapath)
   * gfs2_block_map - Map a block from an inode to a disk block
   * @inode: The inode
   * @lblock: The logical block number
@@@ -1108,53 -1057,428 +1347,176 @@@ static int trunc_start(struct inode *in
  	else
  		truncate_pagecache(inode, newsize);
  
 -out:
 -	brelse(dibh);
 -	if (current->journal_info)
 -		gfs2_trans_end(sdp);
 -	return error;
 -}
 -
 -/**
 - * sweep_bh_for_rgrps - find an rgrp in a meta buffer and free blocks therein
 - * @ip: inode
 - * @rg_gh: holder of resource group glock
 - * @mp: current metapath fully populated with buffers
 - * @btotal: place to keep count of total blocks freed
 - * @hgt: height we're processing
 - * @first: true if this is the first call to this function for this height
 - *
 - * We sweep a metadata buffer (provided by the metapath) for blocks we need to
 - * free, and free them all. However, we do it one rgrp at a time. If this
 - * block has references to multiple rgrps, we break it into individual
 - * transactions. This allows other processes to use the rgrps while we're
 - * focused on a single one, for better concurrency / performance.
 - * At every transaction boundary, we rewrite the inode into the journal.
 - * That way the bitmaps are kept consistent with the inode and we can recover
 - * if we're interrupted by power-outages.
 - *
 - * Returns: 0, or return code if an error occurred.
 - *          *btotal has the total number of blocks freed
 - */
 -static int sweep_bh_for_rgrps(struct gfs2_inode *ip, struct gfs2_holder *rd_gh,
 -			      const struct metapath *mp, u32 *btotal, int hgt,
 -			      bool preserve1)
 -{
 -	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 -	struct gfs2_rgrpd *rgd;
 -	struct gfs2_trans *tr;
 -	struct buffer_head *bh = mp->mp_bh[hgt];
 -	__be64 *top, *bottom, *p;
 -	int blks_outside_rgrp;
 -	u64 bn, bstart, isize_blks;
 -	s64 blen; /* needs to be s64 or gfs2_add_inode_blocks breaks */
 -	int meta = ((hgt != ip->i_height - 1) ? 1 : 0);
 -	int ret = 0;
 -	bool buf_in_tr = false; /* buffer was added to transaction */
 -
 -	if (gfs2_metatype_check(sdp, bh,
 -				(hgt ? GFS2_METATYPE_IN : GFS2_METATYPE_DI)))
 -		return -EIO;
 -
 -more_rgrps:
 -	blks_outside_rgrp = 0;
 -	bstart = 0;
 -	blen = 0;
 -	top = metapointer(hgt, mp); /* first ptr from metapath */
 -	/* If we're keeping some data at the truncation point, we've got to
 -	   preserve the metadata tree by adding 1 to the starting metapath. */
 -	if (preserve1)
 -		top++;
 -
 -	bottom = (__be64 *)(bh->b_data + bh->b_size);
 -
 -	for (p = top; p < bottom; p++) {
 -		if (!*p)
 -			continue;
 -		bn = be64_to_cpu(*p);
 -		if (gfs2_holder_initialized(rd_gh)) {
 -			rgd = gfs2_glock2rgrp(rd_gh->gh_gl);
 -			gfs2_assert_withdraw(sdp,
 -				     gfs2_glock_is_locked_by_me(rd_gh->gh_gl));
 -		} else {
 -			rgd = gfs2_blk2rgrpd(sdp, bn, true);
 -			ret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE,
 -						 0, rd_gh);
 -			if (ret)
 -				goto out;
 -
 -			/* Must be done with the rgrp glock held: */
 -			if (gfs2_rs_active(&ip->i_res) &&
 -			    rgd == ip->i_res.rs_rbm.rgd)
 -				gfs2_rs_deltree(&ip->i_res);
 -		}
 -
 -		if (!rgrp_contains_block(rgd, bn)) {
 -			blks_outside_rgrp++;
 -			continue;
 -		}
 -
 -		/* The size of our transactions will be unknown until we
 -		   actually process all the metadata blocks that relate to
 -		   the rgrp. So we estimate. We know it can't be more than
 -		   the dinode's i_blocks and we don't want to exceed the
 -		   journal flush threshold, sd_log_thresh2. */
 -		if (current->journal_info == NULL) {
 -			unsigned int jblocks_rqsted, revokes;
 -
 -			jblocks_rqsted = rgd->rd_length + RES_DINODE +
 -				RES_INDIRECT;
 -			isize_blks = gfs2_get_inode_blocks(&ip->i_inode);
 -			if (isize_blks > atomic_read(&sdp->sd_log_thresh2))
 -				jblocks_rqsted +=
 -					atomic_read(&sdp->sd_log_thresh2);
 -			else
 -				jblocks_rqsted += isize_blks;
 -			revokes = jblocks_rqsted;
 -			if (meta)
 -				revokes += hptrs(sdp, hgt);
 -			else if (ip->i_depth)
 -				revokes += sdp->sd_inptrs;
 -			ret = gfs2_trans_begin(sdp, jblocks_rqsted, revokes);
 -			if (ret)
 -				goto out_unlock;
 -			down_write(&ip->i_rw_mutex);
 -		}
 -		/* check if we will exceed the transaction blocks requested */
 -		tr = current->journal_info;
 -		if (tr->tr_num_buf_new + RES_STATFS +
 -		    RES_QUOTA >= atomic_read(&sdp->sd_log_thresh2)) {
 -			/* We set blks_outside_rgrp to ensure the loop will
 -			   be repeated for the same rgrp, but with a new
 -			   transaction. */
 -			blks_outside_rgrp++;
 -			/* This next part is tricky. If the buffer was added
 -			   to the transaction, we've already set some block
 -			   pointers to 0, so we better follow through and free
 -			   them, or we will introduce corruption (so break).
 -			   This may be impossible, or at least rare, but I
 -			   decided to cover the case regardless.
 -
 -			   If the buffer was not added to the transaction
 -			   (this call), doing so would exceed our transaction
 -			   size, so we need to end the transaction and start a
 -			   new one (so goto). */
 -
 -			if (buf_in_tr)
 -				break;
 -			goto out_unlock;
 -		}
 -
 -		gfs2_trans_add_meta(ip->i_gl, bh);
 -		buf_in_tr = true;
 -		*p = 0;
 -		if (bstart + blen == bn) {
 -			blen++;
 -			continue;
 -		}
 -		if (bstart) {
 -			__gfs2_free_blocks(ip, bstart, (u32)blen, meta);
 -			(*btotal) += blen;
 -			gfs2_add_inode_blocks(&ip->i_inode, -blen);
 -		}
 -		bstart = bn;
 -		blen = 1;
 -	}
 -	if (bstart) {
 -		__gfs2_free_blocks(ip, bstart, (u32)blen, meta);
 -		(*btotal) += blen;
 -		gfs2_add_inode_blocks(&ip->i_inode, -blen);
 -	}
 -out_unlock:
 -	if (!ret && blks_outside_rgrp) { /* If buffer still has non-zero blocks
 -					    outside the rgrp we just processed,
 -					    do it all over again. */
 -		if (current->journal_info) {
 -			struct buffer_head *dibh = mp->mp_bh[0];
 -
 -			/* Every transaction boundary, we rewrite the dinode
 -			   to keep its di_blocks current in case of failure. */
 -			ip->i_inode.i_mtime = ip->i_inode.i_ctime =
 -				current_time(&ip->i_inode);
 -			gfs2_trans_add_meta(ip->i_gl, dibh);
 -			gfs2_dinode_out(ip, dibh->b_data);
 -			up_write(&ip->i_rw_mutex);
 -			gfs2_trans_end(sdp);
 -		}
 -		gfs2_glock_dq_uninit(rd_gh);
 -		cond_resched();
 -		goto more_rgrps;
 -	}
 -out:
 -	return ret;
 -}
 -
 -/**
 - * find_nonnull_ptr - find a non-null pointer given a metapath and height
 - * assumes the metapath is valid (with buffers) out to height h
 - * @mp: starting metapath
 - * @h: desired height to search
 - *
 - * Returns: true if a non-null pointer was found in the metapath buffer
 - *          false if all remaining pointers are NULL in the buffer
 - */
 -static bool find_nonnull_ptr(struct gfs2_sbd *sdp, struct metapath *mp,
 -			     unsigned int h)
 -{
 -	__be64 *ptr;
 -	unsigned int ptrs = hptrs(sdp, h) - 1;
 -
 -	while (true) {
 -		ptr = metapointer(h, mp);
 -		if (*ptr) { /* if we have a non-null pointer */
 -			/* Now zero the metapath after the current height. */
 -			h++;
 -			if (h < GFS2_MAX_META_HEIGHT)
 -				memset(&mp->mp_list[h], 0,
 -				       (GFS2_MAX_META_HEIGHT - h) *
 -				       sizeof(mp->mp_list[0]));
 -			return true;
 -		}
 -
 -		if (mp->mp_list[h] < ptrs)
 -			mp->mp_list[h]++;
 -		else
 -			return false; /* no more pointers in this buffer */
 +	if (error) {
 +		brelse(dibh);
 +		return error;
  	}
 -}
  
 -enum dealloc_states {
 -	DEALLOC_MP_FULL = 0,    /* Strip a metapath with all buffers read in */
 -	DEALLOC_MP_LOWER = 1,   /* lower the metapath strip height */
 -	DEALLOC_FILL_MP = 2,  /* Fill in the metapath to the given height. */
 -	DEALLOC_DONE = 3,       /* process complete */
 -};
 -
 -static bool mp_eq_to_hgt(struct metapath *mp, __u16 *nbof, unsigned int h)
 -{
 -	if (memcmp(mp->mp_list, nbof, h * sizeof(mp->mp_list[0])))
 -		return false;
 -	return true;
 +out_brelse:
 +	brelse(dibh);
 +out:
 +	gfs2_trans_end(sdp);
 +	return error;
  }
  
 -/**
 - * trunc_dealloc - truncate a file down to a desired size
 - * @ip: inode to truncate
 - * @newsize: The desired size of the file
 - *
 - * This function truncates a file to newsize. It works from the
 - * bottom up, and from the right to the left. In other words, it strips off
 - * the highest layer (data) before stripping any of the metadata. Doing it
 - * this way is best in case the operation is interrupted by power failure, etc.
 - * The dinode is rewritten in every transaction to guarantee integrity.
 - */
 -static int trunc_dealloc(struct gfs2_inode *ip, u64 newsize)
 +static int trunc_dealloc(struct gfs2_inode *ip, u64 size)
  {
  	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 -	struct metapath mp;
 -	struct buffer_head *dibh, *bh;
 -	struct gfs2_holder rd_gh;
 +	unsigned int height = ip->i_height;
  	u64 lblock;
 -	__u16 nbof[GFS2_MAX_META_HEIGHT]; /* new beginning of truncation */
 -	unsigned int strip_h = ip->i_height - 1;
 -	u32 btotal = 0;
 -	int ret, state;
 -	int mp_h; /* metapath buffers are read in to this height */
 -	sector_t last_ra = 0;
 -	u64 prev_bnr = 0;
 -	bool preserve1; /* need to preserve the first meta pointer? */
 -
 -	if (!newsize)
 +	struct metapath mp;
 +	int error;
 +
 +	if (!size)
  		lblock = 0;
  	else
 -		lblock = (newsize - 1) >> sdp->sd_sb.sb_bsize_shift;
 +		lblock = (size - 1) >> sdp->sd_sb.sb_bsize_shift;
  
 -	memset(&mp, 0, sizeof(mp));
  	find_metapath(sdp, lblock, &mp, ip->i_height);
 +	error = gfs2_rindex_update(sdp);
 +	if (error)
 +		return error;
  
 -	memcpy(&nbof, &mp.mp_list, sizeof(nbof));
 +	error = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);
 +	if (error)
 +		return error;
  
 -	ret = gfs2_meta_inode_buffer(ip, &dibh);
 -	if (ret)
 -		return ret;
 +	while (height--) {
 +		struct strip_mine sm;
 +		sm.sm_first = !!size;
 +		sm.sm_height = height;
  
++<<<<<<< HEAD
 +		error = recursive_scan(ip, NULL, &mp, 0, 0, 1, &sm);
 +		if (error)
 +			break;
++=======
+ 	mp.mp_bh[0] = dibh;
+ 	ret = lookup_metapath(ip, &mp);
+ 	if (ret)
+ 		goto out_metapath;
+ 	if (mp.mp_aheight == ip->i_height)
+ 		state = DEALLOC_MP_FULL; /* We have a complete metapath */
+ 	else
+ 		state = DEALLOC_FILL_MP; /* deal with partial metapath */
+ 
+ 	ret = gfs2_rindex_update(sdp);
+ 	if (ret)
+ 		goto out_metapath;
+ 
+ 	ret = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);
+ 	if (ret)
+ 		goto out_metapath;
+ 	gfs2_holder_mark_uninitialized(&rd_gh);
+ 
+ 	mp_h = strip_h;
+ 
+ 	while (state != DEALLOC_DONE) {
+ 		switch (state) {
+ 		/* Truncate a full metapath at the given strip height.
+ 		 * Note that strip_h == mp_h in order to be in this state. */
+ 		case DEALLOC_MP_FULL:
+ 			if (mp_h > 0) { /* issue read-ahead on metadata */
+ 				__be64 *top;
+ 
+ 				bh = mp.mp_bh[mp_h - 1];
+ 				if (bh->b_blocknr != last_ra) {
+ 					last_ra = bh->b_blocknr;
+ 					top = metaptr1(mp_h - 1, &mp);
+ 					gfs2_metapath_ra(ip->i_gl, bh, top);
+ 				}
+ 			}
+ 			/* If we're truncating to a non-zero size and the mp is
+ 			   at the beginning of file for the strip height, we
+ 			   need to preserve the first metadata pointer. */
+ 			preserve1 = (newsize && mp_eq_to_hgt(&mp, nbof, mp_h));
+ 			bh = mp.mp_bh[mp_h];
+ 			gfs2_assert_withdraw(sdp, bh);
+ 			if (gfs2_assert_withdraw(sdp,
+ 						 prev_bnr != bh->b_blocknr)) {
+ 				printk(KERN_EMERG "GFS2: fsid=%s:inode %llu, "
+ 				       "block:%llu, i_h:%u, s_h:%u, mp_h:%u\n",
+ 				       sdp->sd_fsname,
+ 				       (unsigned long long)ip->i_no_addr,
+ 				       prev_bnr, ip->i_height, strip_h, mp_h);
+ 			}
+ 			prev_bnr = bh->b_blocknr;
+ 			ret = sweep_bh_for_rgrps(ip, &rd_gh, &mp, &btotal,
+ 						 mp_h, preserve1);
+ 			/* If we hit an error or just swept dinode buffer,
+ 			   just exit. */
+ 			if (ret || !mp_h) {
+ 				state = DEALLOC_DONE;
+ 				break;
+ 			}
+ 			state = DEALLOC_MP_LOWER;
+ 			break;
+ 
+ 		/* lower the metapath strip height */
+ 		case DEALLOC_MP_LOWER:
+ 			/* We're done with the current buffer, so release it,
+ 			   unless it's the dinode buffer. Then back up to the
+ 			   previous pointer. */
+ 			if (mp_h) {
+ 				brelse(mp.mp_bh[mp_h]);
+ 				mp.mp_bh[mp_h] = NULL;
+ 			}
+ 			/* If we can't get any lower in height, we've stripped
+ 			   off all we can. Next step is to back up and start
+ 			   stripping the previous level of metadata. */
+ 			if (mp_h == 0) {
+ 				strip_h--;
+ 				memcpy(&mp.mp_list, &nbof, sizeof(nbof));
+ 				mp_h = strip_h;
+ 				state = DEALLOC_FILL_MP;
+ 				break;
+ 			}
+ 			mp.mp_list[mp_h] = 0;
+ 			mp_h--; /* search one metadata height down */
+ 			if (mp.mp_list[mp_h] >= hptrs(sdp, mp_h) - 1)
+ 				break; /* loop around in the same state */
+ 			mp.mp_list[mp_h]++;
+ 			/* Here we've found a part of the metapath that is not
+ 			 * allocated. We need to search at that height for the
+ 			 * next non-null pointer. */
+ 			if (find_nonnull_ptr(sdp, &mp, mp_h)) {
+ 				state = DEALLOC_FILL_MP;
+ 				mp_h++;
+ 			}
+ 			/* No more non-null pointers at this height. Back up
+ 			   to the previous height and try again. */
+ 			break; /* loop around in the same state */
+ 
+ 		/* Fill the metapath with buffers to the given height. */
+ 		case DEALLOC_FILL_MP:
+ 			/* Fill the buffers out to the current height. */
+ 			ret = fillup_metapath(ip, &mp, mp_h);
+ 			if (ret)
+ 				goto out;
+ 
+ 			/* If buffers found for the entire strip height */
+ 			if (mp.mp_aheight - 1 == strip_h) {
+ 				state = DEALLOC_MP_FULL;
+ 				break;
+ 			}
+ 			if (mp.mp_aheight < ip->i_height) /* We have a partial height */
+ 				mp_h = mp.mp_aheight - 1;
+ 
+ 			/* If we find a non-null block pointer, crawl a bit
+ 			   higher up in the metapath and try again, otherwise
+ 			   we need to look lower for a new starting point. */
+ 			if (find_nonnull_ptr(sdp, &mp, mp_h))
+ 				mp_h++;
+ 			else
+ 				state = DEALLOC_MP_LOWER;
+ 			break;
+ 		}
++>>>>>>> e8b43fe0c1e0 (gfs2: Clean up {lookup,fillup}_metapath)
  	}
  
 -	if (btotal) {
 -		if (current->journal_info == NULL) {
 -			ret = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS +
 -					       RES_QUOTA, 0);
 -			if (ret)
 -				goto out;
 -			down_write(&ip->i_rw_mutex);
 -		}
 -		gfs2_statfs_change(sdp, 0, +btotal, 0);
 -		gfs2_quota_change(ip, -(s64)btotal, ip->i_inode.i_uid,
 -				  ip->i_inode.i_gid);
 -		ip->i_inode.i_mtime = ip->i_inode.i_ctime = current_time(&ip->i_inode);
 -		gfs2_trans_add_meta(ip->i_gl, dibh);
 -		gfs2_dinode_out(ip, dibh->b_data);
 -		up_write(&ip->i_rw_mutex);
 -		gfs2_trans_end(sdp);
 -	}
 -
 -out:
 -	if (gfs2_holder_initialized(&rd_gh))
 -		gfs2_glock_dq_uninit(&rd_gh);
 -	if (current->journal_info) {
 -		up_write(&ip->i_rw_mutex);
 -		gfs2_trans_end(sdp);
 -		cond_resched();
 -	}
  	gfs2_quota_unhold(ip);
 -out_metapath:
 -	release_metapath(&mp);
 -	return ret;
 +
 +	return error;
  }
  
  static int trunc_end(struct gfs2_inode *ip)
* Unmerged path fs/gfs2/bmap.c
