x86: irq: Define a global vector for nested posted interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] irq: Define a global vector for nested posted interrupts (Paolo Bonzini) [1469685]
Rebuild_FUZZ: 95.73%
commit-author Wincy Van <fanwenyi0529@gmail.com>
commit 210f84b0ca7743f3b2a9acfae81df668dbbb6a12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/210f84b0.failed

We are using the same vector for nested/non-nested posted
interrupts delivery, this may cause interrupts latency in
L1 since we can't kick the L2 vcpu out of vmx-nonroot mode.

This patch introduces a new vector which is only for nested
posted interrupts to solve the problems above.

	Signed-off-by: Wincy Van <fanwenyi0529@gmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 210f84b0ca7743f3b2a9acfae81df668dbbb6a12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64.S
#	arch/x86/include/asm/hardirq.h
#	arch/x86/include/asm/hw_irq.h
#	arch/x86/include/asm/irq_vectors.h
diff --cc arch/x86/include/asm/hardirq.h
index f7f46cf61b6a,ad1ed531febc..000000000000
--- a/arch/x86/include/asm/hardirq.h
+++ b/arch/x86/include/asm/hardirq.h
@@@ -14,6 -14,8 +14,11 @@@ typedef struct 
  #endif
  #ifdef CONFIG_HAVE_KVM
  	unsigned int kvm_posted_intr_ipis;
++<<<<<<< HEAD
++=======
+ 	unsigned int kvm_posted_intr_wakeup_ipis;
+ 	unsigned int kvm_posted_intr_nested_ipis;
++>>>>>>> 210f84b0ca77 (x86: irq: Define a global vector for nested posted interrupts)
  #endif
  	unsigned int x86_platform_ipis;	/* arch dependent */
  	unsigned int apic_perf_irqs;
diff --cc arch/x86/include/asm/hw_irq.h
index 4ee1660f9acf,d6dbafbd4207..000000000000
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@@ -26,58 -26,25 +26,68 @@@
  #include <asm/sections.h>
  
  /* Interrupt handlers registered during init_IRQ */
++<<<<<<< HEAD
 +extern void apic_timer_interrupt(void);
 +extern void x86_platform_ipi(void);
 +extern void kvm_posted_intr_ipi(void);
 +extern void kvm_posted_intr_wakeup_ipi(void);
 +extern void error_interrupt(void);
 +extern void irq_work_interrupt(void);
++=======
+ extern asmlinkage void apic_timer_interrupt(void);
+ extern asmlinkage void x86_platform_ipi(void);
+ extern asmlinkage void kvm_posted_intr_ipi(void);
+ extern asmlinkage void kvm_posted_intr_wakeup_ipi(void);
+ extern asmlinkage void kvm_posted_intr_nested_ipi(void);
+ extern asmlinkage void error_interrupt(void);
+ extern asmlinkage void irq_work_interrupt(void);
 -
 -extern asmlinkage void spurious_interrupt(void);
 -extern asmlinkage void thermal_interrupt(void);
 -extern asmlinkage void reschedule_interrupt(void);
 -
 -extern asmlinkage void irq_move_cleanup_interrupt(void);
 -extern asmlinkage void reboot_interrupt(void);
 -extern asmlinkage void threshold_interrupt(void);
 -extern asmlinkage void deferred_error_interrupt(void);
 -
 -extern asmlinkage void call_function_interrupt(void);
 -extern asmlinkage void call_function_single_interrupt(void);
++>>>>>>> 210f84b0ca77 (x86: irq: Define a global vector for nested posted interrupts)
 +
 +extern void spurious_interrupt(void);
 +extern void thermal_interrupt(void);
 +extern void reschedule_interrupt(void);
 +
 +extern void invalidate_interrupt(void);
 +extern void invalidate_interrupt0(void);
 +extern void invalidate_interrupt1(void);
 +extern void invalidate_interrupt2(void);
 +extern void invalidate_interrupt3(void);
 +extern void invalidate_interrupt4(void);
 +extern void invalidate_interrupt5(void);
 +extern void invalidate_interrupt6(void);
 +extern void invalidate_interrupt7(void);
 +extern void invalidate_interrupt8(void);
 +extern void invalidate_interrupt9(void);
 +extern void invalidate_interrupt10(void);
 +extern void invalidate_interrupt11(void);
 +extern void invalidate_interrupt12(void);
 +extern void invalidate_interrupt13(void);
 +extern void invalidate_interrupt14(void);
 +extern void invalidate_interrupt15(void);
 +extern void invalidate_interrupt16(void);
 +extern void invalidate_interrupt17(void);
 +extern void invalidate_interrupt18(void);
 +extern void invalidate_interrupt19(void);
 +extern void invalidate_interrupt20(void);
 +extern void invalidate_interrupt21(void);
 +extern void invalidate_interrupt22(void);
 +extern void invalidate_interrupt23(void);
 +extern void invalidate_interrupt24(void);
 +extern void invalidate_interrupt25(void);
 +extern void invalidate_interrupt26(void);
 +extern void invalidate_interrupt27(void);
 +extern void invalidate_interrupt28(void);
 +extern void invalidate_interrupt29(void);
 +extern void invalidate_interrupt30(void);
 +extern void invalidate_interrupt31(void);
 +
 +extern void irq_move_cleanup_interrupt(void);
 +extern void reboot_interrupt(void);
 +extern void threshold_interrupt(void);
 +extern void deferred_error_interrupt(void);
 +
 +extern void call_function_interrupt(void);
 +extern void call_function_single_interrupt(void);
  
  #ifdef CONFIG_TRACING
  /* Interrupt handlers registered during init_IRQ */
@@@ -96,84 -63,107 +106,85 @@@ extern void trace_call_function_single_
  #define trace_reboot_interrupt  reboot_interrupt
  #define trace_kvm_posted_intr_ipi kvm_posted_intr_ipi
  #define trace_kvm_posted_intr_wakeup_ipi kvm_posted_intr_wakeup_ipi
+ #define trace_kvm_posted_intr_nested_ipi kvm_posted_intr_nested_ipi
  #endif /* CONFIG_TRACING */
  
 -#ifdef	CONFIG_X86_LOCAL_APIC
 -struct irq_data;
 -struct pci_dev;
 -struct msi_desc;
 -
 -enum irq_alloc_type {
 -	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
 -	X86_IRQ_ALLOC_TYPE_HPET,
 -	X86_IRQ_ALLOC_TYPE_MSI,
 -	X86_IRQ_ALLOC_TYPE_MSIX,
 -	X86_IRQ_ALLOC_TYPE_DMAR,
 -	X86_IRQ_ALLOC_TYPE_UV,
 +/* IOAPIC */
 +#define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1<<(x)) & io_apic_irqs))
 +extern unsigned long io_apic_irqs;
 +
 +extern void init_VISWS_APIC_irqs(void);
 +extern void setup_IO_APIC(void);
 +extern void disable_IO_APIC(void);
 +
 +struct io_apic_irq_attr {
 +	int ioapic;
 +	int ioapic_pin;
 +	int trigger;
 +	int polarity;
  };
  
 -struct irq_alloc_info {
 -	enum irq_alloc_type	type;
 -	u32			flags;
 -	const struct cpumask	*mask;	/* CPU mask for vector allocation */
 -	union {
 -		int		unused;
 -#ifdef	CONFIG_HPET_TIMER
 -		struct {
 -			int		hpet_id;
 -			int		hpet_index;
 -			void		*hpet_data;
 -		};
 -#endif
 -#ifdef	CONFIG_PCI_MSI
 -		struct {
 -			struct pci_dev	*msi_dev;
 -			irq_hw_number_t	msi_hwirq;
 -		};
 -#endif
 -#ifdef	CONFIG_X86_IO_APIC
 -		struct {
 -			int		ioapic_id;
 -			int		ioapic_pin;
 -			int		ioapic_node;
 -			u32		ioapic_trigger : 1;
 -			u32		ioapic_polarity : 1;
 -			u32		ioapic_valid : 1;
 -			struct IO_APIC_route_entry *ioapic_entry;
 -		};
 -#endif
 -#ifdef	CONFIG_DMAR_TABLE
 -		struct {
 -			int		dmar_id;
 -			void		*dmar_data;
 -		};
 -#endif
 -#ifdef	CONFIG_HT_IRQ
 -		struct {
 -			int		ht_pos;
 -			int		ht_idx;
 -			struct pci_dev	*ht_dev;
 -			void		*ht_update;
 -		};
 -#endif
 -#ifdef	CONFIG_X86_UV
 -		struct {
 -			int		uv_limit;
 -			int		uv_blade;
 -			unsigned long	uv_offset;
 -			char		*uv_name;
 -		};
 -#endif
 -#if IS_ENABLED(CONFIG_VMD)
 -		struct {
 -			struct msi_desc *desc;
 -		};
 -#endif
 -	};
 +static inline void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr,
 +					int ioapic, int ioapic_pin,
 +					int trigger, int polarity)
 +{
 +	irq_attr->ioapic	= ioapic;
 +	irq_attr->ioapic_pin	= ioapic_pin;
 +	irq_attr->trigger	= trigger;
 +	irq_attr->polarity	= polarity;
 +}
 +
 +enum irq_mode {
 +       IRQ_REMAPPING,
 +       IRQ_POSTING,
 +};
 +
 +/* Intel specific interrupt remapping information */
 +struct irq_2_iommu {
 +	struct intel_iommu *iommu;
 +	u64 irte_entry[2];
 +	u16 irte_index;
 +	u16 sub_handle;
 +	u8  irte_mask;
 +	enum irq_mode mode;
 +};
 +
 +/* AMD specific interrupt remapping information */
 +struct irq_2_irte {
 +	u16 devid; /* Device ID for IRTE table */
 +	u16 index; /* Index into IRTE table*/
  };
  
 +/*
 + * This is performance-critical, we want to do it O(1)
 + *
 + * Most irqs are mapped 1:1 with pins.
 + */
  struct irq_cfg {
 -	unsigned int		dest_apicid;
 +	struct irq_pin_list	*irq_2_pin;
 +	cpumask_var_t		domain;
 +	cpumask_var_t		old_domain;
  	u8			vector;
 -	u8			old_vector;
 +	u8			move_in_progress : 1;
 +#ifdef CONFIG_IRQ_REMAP
 +	u8			remapped : 1;
 +	union {
 +		struct irq_2_iommu irq_2_iommu;
 +		struct irq_2_irte  irq_2_irte;
 +	};
 +#endif
  };
  
 -extern struct irq_cfg *irq_cfg(unsigned int irq);
 -extern struct irq_cfg *irqd_cfg(struct irq_data *irq_data);
 -extern void lock_vector_lock(void);
 -extern void unlock_vector_lock(void);
 -extern void setup_vector_irq(int cpu);
 -#ifdef CONFIG_SMP
 +extern int assign_irq_vector(int, struct irq_cfg *, const struct cpumask *);
  extern void send_cleanup_vector(struct irq_cfg *);
 -extern void irq_complete_move(struct irq_cfg *cfg);
 -#else
 -static inline void send_cleanup_vector(struct irq_cfg *c) { }
 -static inline void irq_complete_move(struct irq_cfg *c) { }
 -#endif
  
 -extern void apic_ack_edge(struct irq_data *data);
 -#else	/*  CONFIG_X86_LOCAL_APIC */
 -static inline void lock_vector_lock(void) {}
 -static inline void unlock_vector_lock(void) {}
 -#endif	/* CONFIG_X86_LOCAL_APIC */
 +struct irq_data;
 +int __ioapic_set_affinity(struct irq_data *, const struct cpumask *,
 +			  unsigned int *dest_id);
 +extern int IO_APIC_get_PCI_irq_vector(int bus, int devfn, int pin, struct io_apic_irq_attr *irq_attr);
 +extern void setup_ioapic_dest(void);
 +
 +extern void enable_IO_APIC(void);
  
  /* Statistics */
  extern atomic_t irq_err_count;
diff --cc arch/x86/include/asm/irq_vectors.h
index a01f8f4818f5,aaf8d28b5d00..000000000000
--- a/arch/x86/include/asm/irq_vectors.h
+++ b/arch/x86/include/asm/irq_vectors.h
@@@ -117,6 -98,7 +117,10 @@@
  #ifdef CONFIG_HAVE_KVM
  #define POSTED_INTR_VECTOR		0xf2
  #define POSTED_INTR_WAKEUP_VECTOR	0xf1
++<<<<<<< HEAD
++=======
+ #define POSTED_INTR_NESTED_VECTOR	0xf0
++>>>>>>> 210f84b0ca77 (x86: irq: Define a global vector for nested posted interrupts)
  #endif
  
  /*
* Unmerged path arch/x86/entry/entry_64.S
* Unmerged path arch/x86/entry/entry_64.S
diff --git a/arch/x86/include/asm/entry_arch.h b/arch/x86/include/asm/entry_arch.h
index df002992d8fd..07b06955a05d 100644
--- a/arch/x86/include/asm/entry_arch.h
+++ b/arch/x86/include/asm/entry_arch.h
@@ -25,6 +25,8 @@ BUILD_INTERRUPT3(kvm_posted_intr_ipi, POSTED_INTR_VECTOR,
 		 smp_kvm_posted_intr_ipi)
 BUILD_INTERRUPT3(kvm_posted_intr_wakeup_ipi, POSTED_INTR_WAKEUP_VECTOR,
 		 smp_kvm_posted_intr_wakeup_ipi)
+BUILD_INTERRUPT3(kvm_posted_intr_nested_ipi, POSTED_INTR_NESTED_VECTOR,
+		 smp_kvm_posted_intr_nested_ipi)
 #endif
 
 /*
* Unmerged path arch/x86/include/asm/hardirq.h
* Unmerged path arch/x86/include/asm/hw_irq.h
* Unmerged path arch/x86/include/asm/irq_vectors.h
diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 46228b348455..fa0139caf4a8 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -150,6 +150,12 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 		seq_printf(p, "%10u ", irq_stats(j)->kvm_posted_intr_ipis);
 	seq_puts(p, "  Posted-interrupt notification event\n");
 
+	seq_printf(p, "%*s: ", prec, "NPI");
+	for_each_online_cpu(j)
+		seq_printf(p, "%10u ",
+			   irq_stats(j)->kvm_posted_intr_nested_ipis);
+	seq_puts(p, "  Nested posted-interrupt event\n");
+
 	seq_printf(p, "%*s: ", prec, "PIW");
 	for_each_online_cpu(j)
 		seq_printf(p, "%10u ",
@@ -302,6 +308,19 @@ __visible void smp_kvm_posted_intr_wakeup_ipi(struct pt_regs *regs)
 	exiting_irq();
 	set_irq_regs(old_regs);
 }
+
+/*
+ * Handler for POSTED_INTERRUPT_NESTED_VECTOR.
+ */
+__visible void smp_kvm_posted_intr_nested_ipi(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	entering_ack_irq();
+	inc_irq_stat(kvm_posted_intr_nested_ipis);
+	exiting_irq();
+	set_irq_regs(old_regs);
+}
 #endif
 
 void smp_trace_x86_platform_ipi(struct pt_regs *regs)
diff --git a/arch/x86/kernel/irqinit.c b/arch/x86/kernel/irqinit.c
index 12ff965e393b..534d66f3cbab 100644
--- a/arch/x86/kernel/irqinit.c
+++ b/arch/x86/kernel/irqinit.c
@@ -175,6 +175,8 @@ static void __init apic_intr_init(void)
 	alloc_intr_gate(POSTED_INTR_VECTOR, kvm_posted_intr_ipi);
 	/* IPI for KVM to deliver interrupt to wake up tasks */
 	alloc_intr_gate(POSTED_INTR_WAKEUP_VECTOR, kvm_posted_intr_wakeup_ipi);
+	/* IPI for KVM to deliver nested posted interrupt */
+	alloc_intr_gate(POSTED_INTR_NESTED_VECTOR, kvm_posted_intr_nested_ipi);
 #endif
 
 	/* IPI vectors for APIC spurious and error interrupts */
