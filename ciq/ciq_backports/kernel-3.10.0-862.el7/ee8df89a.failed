cpufreq: intel_pstate: Drop driver_registered variable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Drop driver_registered variable (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 90.91%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ee8df89a68f27a7484f1fc71d3d69149dd4dd267
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ee8df89a.failed

The driver_registered variable in intel_pstate is used for checking
whether or not the driver has been registered, but intel_pstate_driver
can be used for that too (with the rule that the driver is not
registered as long as it is NULL).

That is a bit more straightforward and the code may be simplified
a bit this way, so modify the driver accordingly.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ee8df89a68f27a7484f1fc71d3d69149dd4dd267)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index b6f8db18a31a,73ccddf94cf4..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -262,9 -335,21 +262,15 @@@ struct cpu_defaults 
  static inline int32_t get_target_pstate_use_performance(struct cpudata *cpu);
  static inline int32_t get_target_pstate_use_cpu_load(struct cpudata *cpu);
  
 +static struct pstate_adjust_policy pid_params __read_mostly;
  static struct pstate_funcs pstate_funcs __read_mostly;
 -static struct pstate_adjust_policy pid_params __read_mostly = {
 -	.sample_rate_ms = 10,
 -	.sample_rate_ns = 10 * NSEC_PER_MSEC,
 -	.deadband = 0,
 -	.setpoint = 97,
 -	.p_gain_pct = 20,
 -	.d_gain_pct = 0,
 -	.i_gain_pct = 0,
 -};
 -
  static int hwp_active __read_mostly;
++<<<<<<< HEAD
++=======
+ static bool per_cpu_limits __read_mostly;
+ 
+ static struct cpufreq_driver *intel_pstate_driver __read_mostly;
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  
  #ifdef CONFIG_ACPI
  static bool acpi_ppc;
@@@ -646,6 -1033,13 +652,16 @@@ static ssize_t show_turbo_pct(struct ko
  	int total, no_turbo, turbo_pct;
  	uint32_t turbo_fp;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!intel_pstate_driver) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  	cpu = all_cpu_data[0];
  
  	total = cpu->pstate.turbo_pstate - cpu->pstate.min_pstate + 1;
@@@ -661,8 -1058,18 +677,18 @@@ static ssize_t show_num_pstates(struct 
  	struct cpudata *cpu;
  	int total;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!intel_pstate_driver) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  	cpu = all_cpu_data[0];
  	total = cpu->pstate.turbo_pstate - cpu->pstate.min_pstate + 1;
 -
 -	mutex_unlock(&intel_pstate_driver_lock);
 -
  	return sprintf(buf, "%u\n", total);
  }
  
@@@ -671,11 -1078,20 +697,21 @@@ static ssize_t show_no_turbo(struct kob
  {
  	ssize_t ret;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!intel_pstate_driver) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  	update_turbo_state();
 -	if (global.turbo_disabled)
 -		ret = sprintf(buf, "%u\n", global.turbo_disabled);
 +	if (limits->turbo_disabled)
 +		ret = sprintf(buf, "%u\n", limits->turbo_disabled);
  	else
 -		ret = sprintf(buf, "%u\n", global.no_turbo);
 -
 -	mutex_unlock(&intel_pstate_driver_lock);
 +		ret = sprintf(buf, "%u\n", limits->no_turbo);
  
  	return ret;
  }
@@@ -690,9 -1106,20 +726,21 @@@ static ssize_t store_no_turbo(struct ko
  	if (ret != 1)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!intel_pstate_driver) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  	update_turbo_state();
 -	if (global.turbo_disabled) {
 +	if (limits->turbo_disabled) {
  		pr_warn("Turbo disabled by BIOS or unavailable on processor\n");
 -		mutex_unlock(&intel_pstate_limits_lock);
 -		mutex_unlock(&intel_pstate_driver_lock);
  		return -EPERM;
  	}
  
@@@ -714,18 -1153,23 +762,37 @@@ static ssize_t store_max_perf_pct(struc
  	if (ret != 1)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	limits->max_sysfs_pct = clamp_t(int, input, 0 , 100);
 +	limits->max_perf_pct = min(limits->max_policy_pct,
 +				   limits->max_sysfs_pct);
 +	limits->max_perf_pct = max(limits->min_policy_pct,
 +				   limits->max_perf_pct);
 +	limits->max_perf_pct = max(limits->min_perf_pct,
 +				   limits->max_perf_pct);
 +	limits->max_perf = div_fp(int_tofp(limits->max_perf_pct),
 +				  int_tofp(100));
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!intel_pstate_driver) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
+ 	global.max_perf_pct = clamp_t(int, input, global.min_perf_pct, 100);
+ 
+ 	mutex_unlock(&intel_pstate_limits_lock);
+ 
+ 	intel_pstate_update_policies();
+ 
+ 	mutex_unlock(&intel_pstate_driver_lock);
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  
 +	if (hwp_active)
 +		intel_pstate_hwp_set_online_cpus();
  	return count;
  }
  
@@@ -739,18 -1183,24 +806,38 @@@ static ssize_t store_min_perf_pct(struc
  	if (ret != 1)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	limits->min_sysfs_pct = clamp_t(int, input, 0 , 100);
 +	limits->min_perf_pct = max(limits->min_policy_pct,
 +				   limits->min_sysfs_pct);
 +	limits->min_perf_pct = min(limits->max_policy_pct,
 +				   limits->min_perf_pct);
 +	limits->min_perf_pct = min(limits->max_perf_pct,
 +				   limits->min_perf_pct);
 +	limits->min_perf = div_fp(int_tofp(limits->min_perf_pct),
 +				  int_tofp(100));
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 
+ 	if (!intel_pstate_driver) {
+ 		mutex_unlock(&intel_pstate_driver_lock);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	mutex_lock(&intel_pstate_limits_lock);
+ 
+ 	global.min_perf_pct = clamp_t(int, input,
+ 				      min_perf_pct_min(), global.max_perf_pct);
+ 
+ 	mutex_unlock(&intel_pstate_limits_lock);
+ 
+ 	intel_pstate_update_policies();
+ 
+ 	mutex_unlock(&intel_pstate_driver_lock);
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  
 +	if (hwp_active)
 +		intel_pstate_hwp_set_online_cpus();
  	return count;
  }
  
@@@ -1569,6 -2164,201 +1656,204 @@@ static struct cpufreq_driver intel_psta
  	.name		= "intel_pstate",
  };
  
++<<<<<<< HEAD
++=======
+ static int intel_cpufreq_verify_policy(struct cpufreq_policy *policy)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 
+ 	update_turbo_state();
+ 	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+ 				     intel_pstate_get_max_freq(cpu));
+ 
+ 	intel_pstate_adjust_policy_max(policy, cpu);
+ 
+ 	intel_pstate_update_perf_limits(policy, cpu);
+ 
+ 	return 0;
+ }
+ 
+ static int intel_cpufreq_target(struct cpufreq_policy *policy,
+ 				unsigned int target_freq,
+ 				unsigned int relation)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 	struct cpufreq_freqs freqs;
+ 	int target_pstate;
+ 
+ 	update_turbo_state();
+ 
+ 	freqs.old = policy->cur;
+ 	freqs.new = target_freq;
+ 
+ 	cpufreq_freq_transition_begin(policy, &freqs);
+ 	switch (relation) {
+ 	case CPUFREQ_RELATION_L:
+ 		target_pstate = DIV_ROUND_UP(freqs.new, cpu->pstate.scaling);
+ 		break;
+ 	case CPUFREQ_RELATION_H:
+ 		target_pstate = freqs.new / cpu->pstate.scaling;
+ 		break;
+ 	default:
+ 		target_pstate = DIV_ROUND_CLOSEST(freqs.new, cpu->pstate.scaling);
+ 		break;
+ 	}
+ 	target_pstate = intel_pstate_prepare_request(cpu, target_pstate);
+ 	if (target_pstate != cpu->pstate.current_pstate) {
+ 		cpu->pstate.current_pstate = target_pstate;
+ 		wrmsrl_on_cpu(policy->cpu, MSR_IA32_PERF_CTL,
+ 			      pstate_funcs.get_val(cpu, target_pstate));
+ 	}
+ 	freqs.new = target_pstate * cpu->pstate.scaling;
+ 	cpufreq_freq_transition_end(policy, &freqs, false);
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int intel_cpufreq_fast_switch(struct cpufreq_policy *policy,
+ 					      unsigned int target_freq)
+ {
+ 	struct cpudata *cpu = all_cpu_data[policy->cpu];
+ 	int target_pstate;
+ 
+ 	update_turbo_state();
+ 
+ 	target_pstate = DIV_ROUND_UP(target_freq, cpu->pstate.scaling);
+ 	target_pstate = intel_pstate_prepare_request(cpu, target_pstate);
+ 	intel_pstate_update_pstate(cpu, target_pstate);
+ 	return target_pstate * cpu->pstate.scaling;
+ }
+ 
+ static int intel_cpufreq_cpu_init(struct cpufreq_policy *policy)
+ {
+ 	int ret = __intel_pstate_cpu_init(policy);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	policy->cpuinfo.transition_latency = INTEL_CPUFREQ_TRANSITION_LATENCY;
+ 	/* This reflects the intel_pstate_get_cpu_pstates() setting. */
+ 	policy->cur = policy->cpuinfo.min_freq;
+ 
+ 	return 0;
+ }
+ 
+ static struct cpufreq_driver intel_cpufreq = {
+ 	.flags		= CPUFREQ_CONST_LOOPS,
+ 	.verify		= intel_cpufreq_verify_policy,
+ 	.target		= intel_cpufreq_target,
+ 	.fast_switch	= intel_cpufreq_fast_switch,
+ 	.init		= intel_cpufreq_cpu_init,
+ 	.exit		= intel_pstate_cpu_exit,
+ 	.stop_cpu	= intel_cpufreq_stop_cpu,
+ 	.name		= "intel_cpufreq",
+ };
+ 
+ static struct cpufreq_driver *default_driver = &intel_pstate;
+ 
+ static void intel_pstate_driver_cleanup(void)
+ {
+ 	unsigned int cpu;
+ 
+ 	get_online_cpus();
+ 	for_each_online_cpu(cpu) {
+ 		if (all_cpu_data[cpu]) {
+ 			if (intel_pstate_driver == &intel_pstate)
+ 				intel_pstate_clear_update_util_hook(cpu);
+ 
+ 			kfree(all_cpu_data[cpu]);
+ 			all_cpu_data[cpu] = NULL;
+ 		}
+ 	}
+ 	put_online_cpus();
+ 	intel_pstate_driver = NULL;
+ }
+ 
+ static int intel_pstate_register_driver(struct cpufreq_driver *driver)
+ {
+ 	int ret;
+ 
+ 	memset(&global, 0, sizeof(global));
+ 	global.max_perf_pct = 100;
+ 
+ 	intel_pstate_driver = driver;
+ 	ret = cpufreq_register_driver(intel_pstate_driver);
+ 	if (ret) {
+ 		intel_pstate_driver_cleanup();
+ 		return ret;
+ 	}
+ 
+ 	global.min_perf_pct = min_perf_pct_min();
+ 
+ 	if (intel_pstate_driver == &intel_pstate && !hwp_active &&
+ 	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
+ 		intel_pstate_debug_expose_params();
+ 
+ 	return 0;
+ }
+ 
+ static int intel_pstate_unregister_driver(void)
+ {
+ 	if (hwp_active)
+ 		return -EBUSY;
+ 
+ 	if (intel_pstate_driver == &intel_pstate && !hwp_active &&
+ 	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
+ 		intel_pstate_debug_hide_params();
+ 
+ 	cpufreq_unregister_driver(intel_pstate_driver);
+ 	intel_pstate_driver_cleanup();
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t intel_pstate_show_status(char *buf)
+ {
+ 	if (!intel_pstate_driver)
+ 		return sprintf(buf, "off\n");
+ 
+ 	return sprintf(buf, "%s\n", intel_pstate_driver == &intel_pstate ?
+ 					"active" : "passive");
+ }
+ 
+ static int intel_pstate_update_status(const char *buf, size_t size)
+ {
+ 	int ret;
+ 
+ 	if (size == 3 && !strncmp(buf, "off", size))
+ 		return intel_pstate_driver ?
+ 			intel_pstate_unregister_driver() : -EINVAL;
+ 
+ 	if (size == 6 && !strncmp(buf, "active", size)) {
+ 		if (intel_pstate_driver) {
+ 			if (intel_pstate_driver == &intel_pstate)
+ 				return 0;
+ 
+ 			ret = intel_pstate_unregister_driver();
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		return intel_pstate_register_driver(&intel_pstate);
+ 	}
+ 
+ 	if (size == 7 && !strncmp(buf, "passive", size)) {
+ 		if (intel_pstate_driver) {
+ 			if (intel_pstate_driver != &intel_pstate)
+ 				return 0;
+ 
+ 			ret = intel_pstate_unregister_driver();
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		return intel_pstate_register_driver(&intel_cpufreq);
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  static int no_load __initdata;
  static int no_hwp __initdata;
  static int hwp_only __initdata;
@@@ -1780,37 -2588,20 +2065,46 @@@ hwp_cpu_matched
  	if (!all_cpu_data)
  		return -ENOMEM;
  
 +	if (!hwp_active && hwp_only)
 +		goto out;
 +
  	intel_pstate_request_control_from_smm();
  
 +	rc = cpufreq_register_driver(&intel_pstate_driver);
 +	if (rc)
 +		goto out;
 +
 +	if (intel_pstate_driver == &intel_pstate && !hwp_active &&
 +	    pstate_funcs.get_target_pstate != get_target_pstate_use_cpu_load)
 +		intel_pstate_debug_expose_params();
 +
  	intel_pstate_sysfs_expose_params();
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&intel_pstate_driver_lock);
+ 	rc = intel_pstate_register_driver(default_driver);
+ 	mutex_unlock(&intel_pstate_driver_lock);
+ 	if (rc)
+ 		return rc;
+ 
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  	if (hwp_active)
 -		pr_info("HWP enabled\n");
 +		pr_info("intel_pstate: HWP enabled\n");
  
 -	return 0;
 +	return rc;
 +out:
 +	get_online_cpus();
 +	for_each_online_cpu(cpu) {
 +		if (all_cpu_data[cpu]) {
 +			del_timer_sync(&all_cpu_data[cpu]->timer);
 +			kfree(all_cpu_data[cpu]);
 +		}
 +	}
 +
 +	put_online_cpus();
 +	vfree(all_cpu_data);
 +	return -ENODEV;
  }
  device_initcall(intel_pstate_init);
  
@@@ -1819,10 -2610,15 +2113,18 @@@ static int __init intel_pstate_setup(ch
  	if (!str)
  		return -EINVAL;
  
 -	if (!strcmp(str, "disable")) {
 +	if (!strcmp(str, "disable"))
  		no_load = 1;
++<<<<<<< HEAD
++=======
+ 	} else if (!strcmp(str, "passive")) {
+ 		pr_info("Passive mode enabled\n");
+ 		default_driver = &intel_cpufreq;
+ 		no_hwp = 1;
+ 	}
++>>>>>>> ee8df89a68f2 (cpufreq: intel_pstate: Drop driver_registered variable)
  	if (!strcmp(str, "no_hwp")) {
 -		pr_info("HWP disabled\n");
 +		pr_info("intel_pstate: HWP disabled\n");
  		no_hwp = 1;
  	}
  	if (!strcmp(str, "force"))
* Unmerged path drivers/cpufreq/intel_pstate.c
