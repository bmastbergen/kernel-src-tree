x86/dumpstack: Fix interrupt and exception stack boundary checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 5a3cf86978a1ac433407704ec280919751aa2699
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5a3cf869.failed

On x86_64, the double fault exception stack is located immediately after
the interrupt stack in memory.  This causes confusion in the unwinder
when it tries to unwind through an empty interrupt stack, where the
stack pointer points to the address bordering the two stacks.  The
unwinder incorrectly thinks it's running on the double fault stack.

Fix this kind of stack border confusion by never considering the
beginning address of an exception or interrupt stack to be part of the
stack.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Jiri Slaby <jslaby@suse.cz>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: live-patching@vger.kernel.org
Fixes: 5fe599e02e41 ("x86/dumpstack: Add support for unwinding empty IRQ stacks")
Link: http://lkml.kernel.org/r/bcc142160a5104de5c354c21c394c93a0173943f.1499786555.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 5a3cf86978a1ac433407704ec280919751aa2699)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/dumpstack_32.c
#	arch/x86/kernel/dumpstack_64.c
diff --cc arch/x86/kernel/dumpstack_32.c
index c90b53d2857e,4f0481474903..000000000000
--- a/arch/x86/kernel/dumpstack_32.c
+++ b/arch/x86/kernel/dumpstack_32.c
@@@ -16,77 -17,110 +16,164 @@@
  
  #include <asm/stacktrace.h>
  
 -const char *stack_type_name(enum stack_type type)
 +
 +void dump_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data)
  {
 -	if (type == STACK_TYPE_IRQ)
 -		return "IRQ";
 +	int graph = 0;
  
 -	if (type == STACK_TYPE_SOFTIRQ)
 -		return "SOFTIRQ";
 +	if (!task)
 +		task = current;
  
 -	return NULL;
 -}
 +	if (!stack) {
 +		unsigned long dummy;
  
++<<<<<<< HEAD
 +		stack = &dummy;
 +		if (task && task != current)
 +			stack = (unsigned long *)task->thread.sp;
++=======
+ static bool in_hardirq_stack(unsigned long *stack, struct stack_info *info)
+ {
+ 	unsigned long *begin = (unsigned long *)this_cpu_read(hardirq_stack);
+ 	unsigned long *end   = begin + (THREAD_SIZE / sizeof(long));
+ 
+ 	/*
+ 	 * This is a software stack, so 'end' can be a valid stack pointer.
+ 	 * It just means the stack is empty.
+ 	 */
+ 	if (stack <= begin || stack > end)
+ 		return false;
+ 
+ 	info->type	= STACK_TYPE_IRQ;
+ 	info->begin	= begin;
+ 	info->end	= end;
+ 
+ 	/*
+ 	 * See irq_32.c -- the next stack pointer is stored at the beginning of
+ 	 * the stack.
+ 	 */
+ 	info->next_sp	= (unsigned long *)*begin;
+ 
+ 	return true;
+ }
+ 
+ static bool in_softirq_stack(unsigned long *stack, struct stack_info *info)
+ {
+ 	unsigned long *begin = (unsigned long *)this_cpu_read(softirq_stack);
+ 	unsigned long *end   = begin + (THREAD_SIZE / sizeof(long));
+ 
+ 	/*
+ 	 * This is a software stack, so 'end' can be a valid stack pointer.
+ 	 * It just means the stack is empty.
+ 	 */
+ 	if (stack <= begin || stack > end)
+ 		return false;
+ 
+ 	info->type	= STACK_TYPE_SOFTIRQ;
+ 	info->begin	= begin;
+ 	info->end	= end;
+ 
+ 	/*
+ 	 * The next stack pointer is stored at the beginning of the stack.
+ 	 * See irq_32.c.
+ 	 */
+ 	info->next_sp	= (unsigned long *)*begin;
+ 
+ 	return true;
+ }
+ 
+ int get_stack_info(unsigned long *stack, struct task_struct *task,
+ 		   struct stack_info *info, unsigned long *visit_mask)
+ {
+ 	if (!stack)
+ 		goto unknown;
+ 
+ 	task = task ? : current;
+ 
+ 	if (in_task_stack(stack, task, info))
+ 		goto recursion_check;
+ 
+ 	if (task != current)
+ 		goto unknown;
+ 
+ 	if (in_hardirq_stack(stack, info))
+ 		goto recursion_check;
+ 
+ 	if (in_softirq_stack(stack, info))
+ 		goto recursion_check;
+ 
+ 	goto unknown;
+ 
+ recursion_check:
+ 	/*
+ 	 * Make sure we don't iterate through any given stack more than once.
+ 	 * If it comes up a second time then there's something wrong going on:
+ 	 * just break out and report an unknown stack type.
+ 	 */
+ 	if (visit_mask) {
+ 		if (*visit_mask & (1UL << info->type)) {
+ 			printk_deferred_once(KERN_WARNING "WARNING: stack recursion on stack type %d\n", info->type);
+ 			goto unknown;
+ 		}
+ 		*visit_mask |= 1UL << info->type;
++>>>>>>> 5a3cf86978a1 (x86/dumpstack: Fix interrupt and exception stack boundary checks)
 +	}
 +
 +	if (!bp)
 +		bp = stack_frame(task, regs);
 +
 +	for (;;) {
 +		struct thread_info *context;
 +
 +		context = (struct thread_info *)
 +			((unsigned long)stack & (~(THREAD_SIZE - 1)));
 +		bp = ops->walk_stack(context, stack, bp, ops, data, NULL, &graph);
 +
 +		stack = (unsigned long *)context->previous_esp;
 +		if (!stack)
 +			break;
 +		if (ops->stack(data, "IRQ") < 0)
 +			break;
 +		touch_nmi_watchdog();
  	}
 +}
 +EXPORT_SYMBOL(dump_trace);
 +
 +void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl)
 +{
 +	unsigned long *stack;
 +	int i;
  
 -	return 0;
 +	if (sp == NULL) {
 +		if (regs)
 +			sp = (unsigned long *)regs->sp;
 +		else if (task)
 +			sp = (unsigned long *)task->thread.sp;
 +		else
 +			sp = (unsigned long *)&sp;
 +	}
  
 -unknown:
 -	info->type = STACK_TYPE_UNKNOWN;
 -	return -EINVAL;
 +	stack = sp;
 +	for (i = 0; i < kstack_depth_to_print; i++) {
 +		if (kstack_end(stack))
 +			break;
 +		if ((i % STACKSLOTS_PER_LINE) == 0) {
 +			if (i != 0)
 +				pr_cont("\n");
 +			printk("%s %08lx", log_lvl, *stack++);
 +		} else
 +			pr_cont(" %08lx", *stack++);
 +		touch_nmi_watchdog();
 +	}
 +	pr_cont("\n");
 +	show_trace_log_lvl(task, regs, sp, bp, log_lvl);
  }
  
 +
  void show_regs(struct pt_regs *regs)
  {
  	int i;
diff --cc arch/x86/kernel/dumpstack_64.c
index 101e30243d5b,225af4184f06..000000000000
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@@ -96,204 -42,99 +96,214 @@@ static unsigned long *in_exception_stac
  	return NULL;
  }
  
 -static bool in_exception_stack(unsigned long *stack, struct stack_info *info)
 +static inline int
 +in_irq_stack(unsigned long *stack, unsigned long *irq_stack,
 +	     unsigned long *irq_stack_end)
  {
 -	unsigned long *begin, *end;
 -	struct pt_regs *regs;
 -	unsigned k;
 +	return (stack >= irq_stack && stack < irq_stack_end);
 +}
  
 -	BUILD_BUG_ON(N_EXCEPTION_STACKS != 4);
 +enum stack_type {
 +	STACK_IS_UNKNOWN,
 +	STACK_IS_NORMAL,
 +	STACK_IS_EXCEPTION,
 +	STACK_IS_IRQ,
 +};
  
 -	for (k = 0; k < N_EXCEPTION_STACKS; k++) {
 -		end   = (unsigned long *)raw_cpu_ptr(&orig_ist)->ist[k];
 -		begin = end - (exception_stack_sizes[k] / sizeof(long));
 -		regs  = (struct pt_regs *)end - 1;
 +static enum stack_type
 +analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
 +	      unsigned long **stack_end, unsigned long *irq_stack,
 +	      unsigned *used, char **id)
 +{
 +	unsigned long addr;
  
++<<<<<<< HEAD
 +	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
 +	if ((unsigned long)task_stack_page(task) == addr)
 +		return STACK_IS_NORMAL;
++=======
+ 		if (stack <= begin || stack >= end)
+ 			continue;
++>>>>>>> 5a3cf86978a1 (x86/dumpstack: Fix interrupt and exception stack boundary checks)
  
 -		info->type	= STACK_TYPE_EXCEPTION + k;
 -		info->begin	= begin;
 -		info->end	= end;
 -		info->next_sp	= (unsigned long *)regs->sp;
 +	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
 +					used, id);
 +	if (*stack_end)
 +		return STACK_IS_EXCEPTION;
  
 -		return true;
 -	}
 +	if (!irq_stack)
 +		return STACK_IS_NORMAL;
 +
 +	*stack_end = irq_stack;
 +	irq_stack -= (IRQ_STACK_SIZE / sizeof(long));
 +
 +	if (in_irq_stack(stack, irq_stack, *stack_end))
 +		return STACK_IS_IRQ;
  
 -	return false;
 +	return STACK_IS_UNKNOWN;
  }
  
 -static bool in_irq_stack(unsigned long *stack, struct stack_info *info)
 +/*
 + * x86-64 can have up to three kernel stacks:
 + * process stack
 + * interrupt stack
 + * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
 + */
 +
 +void dump_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data)
  {
 -	unsigned long *end   = (unsigned long *)this_cpu_read(irq_stack_ptr);
 -	unsigned long *begin = end - (IRQ_STACK_SIZE / sizeof(long));
 +	const unsigned cpu = get_cpu();
 +	struct thread_info *tinfo;
 +	unsigned long *irq_stack = (unsigned long *)per_cpu(irq_stack_ptr, cpu);
 +	unsigned long dummy;
 +	unsigned used = 0;
 +	int graph = 0;
 +	int done = 0;
 +
 +	if (!task)
 +		task = current;
 +
 +	if (!stack) {
 +		if (regs)
 +			stack = (unsigned long *)regs->sp;
 +		else if (task != current)
 +			stack = (unsigned long *)task->thread.sp;
 +		else
 +			stack = &dummy;
 +	}
  
 +	if (!bp)
 +		bp = stack_frame(task, regs);
  	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 +	 * Print function call entries in all stacks, starting at the
 +	 * current stack address. If the stacks consist of nested
 +	 * exceptions
  	 */
++<<<<<<< HEAD
 +	tinfo = task_thread_info(task);
 +	while (!done) {
 +		unsigned long *stack_end;
 +		enum stack_type stype;
 +		char *id;
++=======
+ 	if (stack <= begin || stack > end)
+ 		return false;
++>>>>>>> 5a3cf86978a1 (x86/dumpstack: Fix interrupt and exception stack boundary checks)
  
 -	info->type	= STACK_TYPE_IRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 +		stype = analyze_stack(cpu, task, stack, &stack_end,
 +				      irq_stack, &used, &id);
  
 -	/*
 -	 * The next stack pointer is the first thing pushed by the entry code
 -	 * after switching to the irq stack.
 -	 */
 -	info->next_sp = (unsigned long *)*(end - 1);
 +		/* Default finish unless specified to continue */
 +		done = 1;
  
 -	return true;
 -}
 +		switch (stype) {
  
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask)
 -{
 -	if (!stack)
 -		goto unknown;
 +		/* Break out early if we are on the thread stack */
 +		case STACK_IS_NORMAL:
 +			break;
  
 -	task = task ? : current;
 +		case STACK_IS_EXCEPTION:
  
 -	if (in_task_stack(stack, task, info))
 -		goto recursion_check;
 +			if (ops->stack(data, id) < 0)
 +				break;
  
 -	if (task != current)
 -		goto unknown;
 +			bp = ops->walk_stack(tinfo, stack, bp, ops,
 +					     data, stack_end, &graph);
 +			ops->stack(data, "EOE");
 +			/*
 +			 * We link to the next stack via the
 +			 * second-to-last pointer (index -2 to end) in the
 +			 * exception stack:
 +			 */
 +			stack = (unsigned long *) stack_end[-2];
 +			done = 0;
 +			break;
 +
 +		case STACK_IS_IRQ:
 +
 +			if (ops->stack(data, "IRQ") < 0)
 +				break;
 +			bp = ops->walk_stack(tinfo, stack, bp,
 +				     ops, data, stack_end, &graph);
 +			/*
 +			 * We link to the next stack (which would be
 +			 * the process stack normally) the last
 +			 * pointer (index -1 to end) in the IRQ stack:
 +			 */
 +			stack = (unsigned long *) (stack_end[-1]);
 +			irq_stack = NULL;
 +			ops->stack(data, "EOI");
 +			done = 0;
 +			break;
 +
 +		case STACK_IS_UNKNOWN:
 +			ops->stack(data, "UNK");
 +			break;
 +		}
 +	}
  
 -	if (in_exception_stack(stack, info))
 -		goto recursion_check;
 +	/*
 +	 * This handles the process stack:
 +	 */
 +	bp = ops->walk_stack(tinfo, stack, bp, ops, data, NULL, &graph);
 +	put_cpu();
 +}
 +EXPORT_SYMBOL(dump_trace);
  
 -	if (in_irq_stack(stack, info))
 -		goto recursion_check;
 +void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl)
 +{
 +	unsigned long *irq_stack_end;
 +	unsigned long *irq_stack;
 +	unsigned long *stack;
 +	int cpu;
 +	int i;
 +
 +	preempt_disable();
 +	cpu = smp_processor_id();
  
 -	goto unknown;
 +	irq_stack_end = (unsigned long *)(per_cpu(irq_stack_ptr, cpu));
 +	irq_stack     = irq_stack_end - (IRQ_STACK_SIZE / sizeof(long));
  
 -recursion_check:
  	/*
 -	 * Make sure we don't iterate through any given stack more than once.
 -	 * If it comes up a second time then there's something wrong going on:
 -	 * just break out and report an unknown stack type.
 +	 * Debugging aid: "show_stack(NULL, NULL);" prints the
 +	 * back trace for this cpu:
  	 */
 -	if (visit_mask) {
 -		if (*visit_mask & (1UL << info->type)) {
 -			printk_deferred_once(KERN_WARNING "WARNING: stack recursion on stack type %d\n", info->type);
 -			goto unknown;
 -		}
 -		*visit_mask |= 1UL << info->type;
 +	if (sp == NULL) {
 +		if (regs)
 +			sp = (unsigned long *)regs->sp;
 +		else if (task)
 +			sp = (unsigned long *)task->thread.sp;
 +		else
 +			sp = (unsigned long *)&sp;
  	}
  
 -	return 0;
 +	stack = sp;
 +	for (i = 0; i < kstack_depth_to_print; i++) {
 +		if (stack >= irq_stack && stack <= irq_stack_end) {
 +			if (stack == irq_stack_end) {
 +				stack = (unsigned long *) (irq_stack_end[-1]);
 +				pr_cont(" <EOI> ");
 +			}
 +		} else {
 +		if (((long) stack & (THREAD_SIZE-1)) == 0)
 +			break;
 +		}
 +		if ((i % STACKSLOTS_PER_LINE) == 0) {
 +			if (i != 0)
 +				pr_cont("\n");
 +			printk("%s %016lx", log_lvl, *stack++);
 +		} else
 +			pr_cont(" %016lx", *stack++);
 +		touch_nmi_watchdog();
 +	}
 +	preempt_enable();
  
 -unknown:
 -	info->type = STACK_TYPE_UNKNOWN;
 -	return -EINVAL;
 +	pr_cont("\n");
 +	show_trace_log_lvl(task, regs, sp, bp, log_lvl);
  }
  
  void show_regs(struct pt_regs *regs)
* Unmerged path arch/x86/kernel/dumpstack_32.c
* Unmerged path arch/x86/kernel/dumpstack_64.c
