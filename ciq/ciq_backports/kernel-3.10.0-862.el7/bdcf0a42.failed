kernel: make groups_sort calling a responsibility group_info allocators

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [kernel] make groups_sort calling a responsibility group_info allocators (Thiago Becker) [1516978]
Rebuild_FUZZ: 94.03%
commit-author Thiago Rafael Becker <thiago.becker@gmail.com>
commit bdcf0a423ea1c40bbb40e7ee483b50fc8aa3d758
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bdcf0a42.failed

In testing, we found that nfsd threads may call set_groups in parallel
for the same entry cached in auth.unix.gid, racing in the call of
groups_sort, corrupting the groups for that entry and leading to
permission denials for the client.

This patch:
 - Make groups_sort globally visible.
 - Move the call to groups_sort to the modifiers of group_info
 - Remove the call to groups_sort from set_groups

Link: http://lkml.kernel.org/r/20171211151420.18655-1-thiago.becker@gmail.com
	Signed-off-by: Thiago Rafael Becker <thiago.becker@gmail.com>
	Reviewed-by: Matthew Wilcox <mawilcox@microsoft.com>
	Reviewed-by: NeilBrown <neilb@suse.com>
	Acked-by: "J. Bruce Fields" <bfields@fieldses.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bdcf0a423ea1c40bbb40e7ee483b50fc8aa3d758)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/auth.c
#	include/linux/cred.h
#	kernel/groups.c
diff --cc fs/nfsd/auth.c
index 6d5187b528aa,f650e475d8f0..000000000000
--- a/fs/nfsd/auth.c
+++ b/fs/nfsd/auth.c
@@@ -56,10 -56,13 +56,17 @@@ int nfsd_setuser(struct svc_rqst *rqstp
  			goto oom;
  
  		for (i = 0; i < rqgi->ngroups; i++) {
 -			if (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))
 -				gi->gid[i] = exp->ex_anon_gid;
 +			if (gid_eq(GLOBAL_ROOT_GID, GROUP_AT(rqgi, i)))
 +				GROUP_AT(gi, i) = exp->ex_anon_gid;
  			else
++<<<<<<< HEAD
 +				GROUP_AT(gi, i) = GROUP_AT(rqgi, i);
++=======
+ 				gi->gid[i] = rqgi->gid[i];
+ 
+ 			/* Each thread allocates its own gi, no race */
+ 			groups_sort(gi);
++>>>>>>> bdcf0a423ea1 (kernel: make groups_sort calling a responsibility group_info allocators)
  		}
  	} else {
  		gi = get_group_info(rqgi);
diff --cc include/linux/cred.h
index 2ec6f7b4826a,631286535d0f..000000000000
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@@ -77,6 -65,25 +77,28 @@@ extern bool may_setgroups(void)
  
  extern int in_group_p(kgid_t);
  extern int in_egroup_p(kgid_t);
++<<<<<<< HEAD
++=======
+ #else
+ static inline void groups_free(struct group_info *group_info)
+ {
+ }
+ 
+ static inline int in_group_p(kgid_t grp)
+ {
+         return 1;
+ }
+ static inline int in_egroup_p(kgid_t grp)
+ {
+         return 1;
+ }
+ #endif
+ extern int set_current_groups(struct group_info *);
+ extern void set_groups(struct cred *, struct group_info *);
+ extern int groups_search(const struct group_info *, kgid_t);
+ extern bool may_setgroups(void);
+ extern void groups_sort(struct group_info *);
++>>>>>>> bdcf0a423ea1 (kernel: make groups_sort calling a responsibility group_info allocators)
  
  /*
   * The security context of a task
diff --cc kernel/groups.c
index 67b4ba30475f,daae2f2dc6d4..000000000000
--- a/kernel/groups.c
+++ b/kernel/groups.c
@@@ -103,34 -78,20 +103,47 @@@ static int groups_from_user(struct grou
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* a simple Shell sort */
 +static void groups_sort(struct group_info *group_info)
++=======
+ static int gid_cmp(const void *_a, const void *_b)
+ {
+ 	kgid_t a = *(kgid_t *)_a;
+ 	kgid_t b = *(kgid_t *)_b;
+ 
+ 	return gid_gt(a, b) - gid_lt(a, b);
+ }
+ 
+ void groups_sort(struct group_info *group_info)
++>>>>>>> bdcf0a423ea1 (kernel: make groups_sort calling a responsibility group_info allocators)
  {
 -	sort(group_info->gid, group_info->ngroups, sizeof(*group_info->gid),
 -	     gid_cmp, NULL);
 +	int base, max, stride;
 +	int gidsetsize = group_info->ngroups;
 +
 +	for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)
 +		; /* nothing */
 +	stride /= 3;
 +
 +	while (stride) {
 +		max = gidsetsize - stride;
 +		for (base = 0; base < max; base++) {
 +			int left = base;
 +			int right = left + stride;
 +			kgid_t tmp = GROUP_AT(group_info, right);
 +
 +			while (left >= 0 && gid_gt(GROUP_AT(group_info, left), tmp)) {
 +				GROUP_AT(group_info, right) =
 +				    GROUP_AT(group_info, left);
 +				right = left;
 +				left -= stride;
 +			}
 +			GROUP_AT(group_info, right) = tmp;
 +		}
 +		stride /= 3;
 +	}
  }
+ EXPORT_SYMBOL(groups_sort);
  
  /* a simple bsearch */
  int groups_search(const struct group_info *group_info, kgid_t grp)
@@@ -158,17 -119,12 +171,16 @@@
   * set_groups - Change a group subscription in a set of credentials
   * @new: The newly prepared set of credentials to alter
   * @group_info: The group list to install
 + *
 + * Validate a group subscription and, if valid, insert it into a set
 + * of credentials.
   */
 -void set_groups(struct cred *new, struct group_info *group_info)
 +int set_groups(struct cred *new, struct group_info *group_info)
  {
  	put_group_info(new->group_info);
- 	groups_sort(group_info);
  	get_group_info(group_info);
  	new->group_info = group_info;
 +	return 0;
  }
  
  EXPORT_SYMBOL(set_groups);
diff --git a/arch/s390/kernel/compat_linux.c b/arch/s390/kernel/compat_linux.c
index fe61f56b846b..c754bff51f5b 100644
--- a/arch/s390/kernel/compat_linux.c
+++ b/arch/s390/kernel/compat_linux.c
@@ -258,6 +258,7 @@ asmlinkage long sys32_setgroups16(int gidsetsize, u16 __user *grouplist)
 		return retval;
 	}
 
+	groups_sort(group_info);
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
* Unmerged path fs/nfsd/auth.c
* Unmerged path include/linux/cred.h
* Unmerged path kernel/groups.c
diff --git a/kernel/uid16.c b/kernel/uid16.c
index d58cc4d8f0d1..651aaa5221ec 100644
--- a/kernel/uid16.c
+++ b/kernel/uid16.c
@@ -190,6 +190,7 @@ SYSCALL_DEFINE2(setgroups16, int, gidsetsize, old_gid_t __user *, grouplist)
 		return retval;
 	}
 
+	groups_sort(group_info);
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c
index eeeba5adee6d..1486eaa356b0 100644
--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c
+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c
@@ -231,6 +231,7 @@ static int gssx_dec_linux_creds(struct xdr_stream *xdr,
 			goto out_free_groups;
 		GROUP_AT(creds->cr_group_info, i) = kgid;
 	}
+	groups_sort(creds->cr_group_info);
 
 	return 0;
 out_free_groups:
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index 44979faf03cd..32364c67f382 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -479,6 +479,7 @@ static int rsc_parse(struct cache_detail *cd,
 				goto out;
 			GROUP_AT(rsci.cred.cr_group_info, i) = kgid;
 		}
+		groups_sort(rsci.cred.cr_group_info);
 
 		/* mech name */
 		len = qword_get(&mesg, buf, mlen);
diff --git a/net/sunrpc/svcauth_unix.c b/net/sunrpc/svcauth_unix.c
index dfacdc95b3f5..eff65fc257cb 100644
--- a/net/sunrpc/svcauth_unix.c
+++ b/net/sunrpc/svcauth_unix.c
@@ -520,6 +520,7 @@ static int unix_gid_parse(struct cache_detail *cd,
 		GROUP_AT(ug.gi, i) = kgid;
 	}
 
+	groups_sort(ug.gi);
 	ugp = unix_gid_lookup(cd, uid);
 	if (ugp) {
 		struct cache_head *ch;
@@ -819,6 +820,7 @@ svcauth_unix_accept(struct svc_rqst *rqstp, __be32 *authp)
 		kgid_t kgid = make_kgid(&init_user_ns, svc_getnl(argv));
 		GROUP_AT(cred->cr_group_info, i) = kgid;
 	}
+	groups_sort(cred->cr_group_info);
 	if (svc_getu32(argv) != htonl(RPC_AUTH_NULL) || svc_getu32(argv) != 0) {
 		*authp = rpc_autherr_badverf;
 		return SVC_DENIED;
