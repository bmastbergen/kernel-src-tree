iw_cxgb4: remove BUG_ON() usage.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [infiniband] iw_cxgb4: remove BUG_ON() usage (Arjun Vynipadath) [1526289]
Rebuild_FUZZ: 98.41%
commit-author Steve Wise <swise@opengridcomputing.com>
commit ba97b749979ef0ebb821e58ee8b16a84412922f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ba97b749.failed

iw_cxgb4 has many BUG_ON()s that were left over from various enhancemnets
made over the years.  Almost all of them should just be removed.  Some,
however indicate a ULP usage error and can be handled w/o bringing down
the system.

If the condition cannot happen with correctly implemented cxgb4 sw/fw,
then remove the BUG_ON.

If the condition indicates a misbehaving ULP (like CQ overflows), add
proper recovery logic.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit ba97b749979ef0ebb821e58ee8b16a84412922f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
#	drivers/infiniband/hw/cxgb4/cq.c
#	drivers/infiniband/hw/cxgb4/provider.c
#	drivers/infiniband/hw/cxgb4/qp.c
#	drivers/infiniband/hw/cxgb4/t4.h
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 9b70d4724eb7,21db3b48a617..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -912,10 -909,9 +912,8 @@@ static int send_mpa_req(struct c4iw_ep 
  	struct mpa_message *mpa;
  	struct mpa_v2_conn_params mpa_v2_params;
  
 -	pr_debug("ep %p tid %u pd_len %d\n",
 -		 ep, ep->hwtid, ep->plen);
 +	PDBG("%s ep %p tid %u pd_len %d\n", __func__, ep, ep->hwtid, ep->plen);
  
- 	BUG_ON(skb_cloned(skb));
- 
  	mpalen = sizeof(*mpa) + ep->plen;
  	if (mpa_rev_to_use == 2)
  		mpalen += sizeof(struct mpa_v2_conn_params);
@@@ -2355,8 -2350,7 +2350,12 @@@ static int accept_cr(struct c4iw_ep *ep
  	int win;
  	enum chip_type adapter_type = ep->com.dev->rdev.lldi.adapter_type;
  
++<<<<<<< HEAD
 +	PDBG("%s ep %p tid %u\n", __func__, ep, ep->hwtid);
 +	BUG_ON(skb_cloned(skb));
++=======
+ 	pr_debug("ep %p tid %u\n", ep, ep->hwtid);
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  
  	skb_get(skb);
  	rpl = cplhdr(skb);
@@@ -2439,8 -2433,7 +2438,12 @@@
  
  static void reject_cr(struct c4iw_dev *dev, u32 hwtid, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	PDBG("%s c4iw_dev %p tid %u\n", __func__, dev, hwtid);
 +	BUG_ON(skb_cloned(skb));
++=======
+ 	pr_debug("c4iw_dev %p tid %u\n", dev, hwtid);
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  	skb_trim(skb, sizeof(struct cpl_tid_release));
  	release_tid(&dev->rdev, hwtid, skb);
  	return;
@@@ -2923,11 -2911,10 +2926,10 @@@ static int terminate(struct c4iw_dev *d
  	struct c4iw_qp_attributes attrs;
  
  	ep = get_ep_from_tid(dev, tid);
- 	BUG_ON(!ep);
  
  	if (ep && ep->com.qp) {
 -		pr_warn("TERM received tid %u qpid %u\n",
 -			tid, ep->com.qp->wq.sq.qid);
 +		printk(KERN_WARNING MOD "TERM received tid %u qpid %u\n", tid,
 +		       ep->com.qp->wq.sq.qid);
  		attrs.next_state = C4IW_QP_STATE_TERMINATE;
  		c4iw_modify_qp(ep->com.qp->rhp, ep->com.qp,
  			       C4IW_QP_ATTR_NEXT_STATE, &attrs, 1);
@@@ -3572,11 -3567,11 +3577,11 @@@ int c4iw_ep_disconnect(struct c4iw_ep *
  	case MORIBUND:
  	case ABORTING:
  	case DEAD:
 -		pr_info("%s ignoring disconnect ep %p state %u\n",
 -			__func__, ep, ep->com.state);
 +		PDBG("%s ignoring disconnect ep %p state %u\n",
 +		     __func__, ep, ep->com.state);
  		break;
  	default:
- 		BUG();
+ 		WARN_ONCE(1, "Bad endpoint state %u\n", ep->com.state);
  		break;
  	}
  
@@@ -3676,9 -3671,8 +3681,8 @@@ static void passive_ofld_conn_reply(str
  	int ret;
  
  	rpl_skb = (struct sk_buff *)(unsigned long)req->cookie;
- 	BUG_ON(!rpl_skb);
  	if (req->retval) {
 -		pr_err("%s passive open failure %d\n", __func__, req->retval);
 +		PDBG("%s passive open failure %d\n", __func__, req->retval);
  		mutex_lock(&dev->rdev.stats.lock);
  		dev->rdev.stats.pas_ofld_conn_fails++;
  		mutex_unlock(&dev->rdev.stats.lock);
diff --cc drivers/infiniband/hw/cxgb4/cq.c
index eb5e910786df,ea55e95cd2c5..000000000000
--- a/drivers/infiniband/hw/cxgb4/cq.c
+++ b/drivers/infiniband/hw/cxgb4/cq.c
@@@ -198,9 -188,8 +198,14 @@@ int c4iw_flush_rq(struct t4_wq *wq, str
  	int flushed = 0;
  	int in_use = wq->rq.in_use - count;
  
++<<<<<<< HEAD
 +	BUG_ON(in_use < 0);
 +	PDBG("%s wq %p cq %p rq.in_use %u skip count %u\n", __func__,
 +	     wq, cq, wq->rq.in_use, count);
++=======
+ 	pr_debug("wq %p cq %p rq.in_use %u skip count %u\n",
+ 		 wq, cq, wq->rq.in_use, count);
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  	while (in_use--) {
  		insert_recv_cqe(wq, cq);
  		flushed++;
@@@ -638,18 -619,16 +636,16 @@@ proc_cqe
  			wq->sq.in_use -= wq->sq.size + idx - wq->sq.cidx;
  		else
  			wq->sq.in_use -= idx - wq->sq.cidx;
- 		BUG_ON(wq->sq.in_use <= 0 && wq->sq.in_use >= wq->sq.size);
  
  		wq->sq.cidx = (uint16_t)idx;
 -		pr_debug("completing sq idx %u\n", wq->sq.cidx);
 +		PDBG("%s completing sq idx %u\n", __func__, wq->sq.cidx);
  		*cookie = wq->sq.sw_sq[wq->sq.cidx].wr_id;
  		if (c4iw_wr_log)
  			c4iw_log_wr_stats(wq, hw_cqe);
  		t4_sq_consume(wq);
  	} else {
 -		pr_debug("completing rq idx %u\n", wq->rq.cidx);
 +		PDBG("%s completing rq idx %u\n", __func__, wq->rq.cidx);
  		*cookie = wq->rq.sw_rq[wq->rq.cidx].wr_id;
- 		BUG_ON(t4_rq_empty(wq));
  		if (c4iw_wr_log)
  			c4iw_log_wr_stats(wq, hw_cqe);
  		t4_rq_consume(wq);
diff --cc drivers/infiniband/hw/cxgb4/provider.c
index 26ed2e0446bd,30206a57dbe7..000000000000
--- a/drivers/infiniband/hw/cxgb4/provider.c
+++ b/drivers/infiniband/hw/cxgb4/provider.c
@@@ -310,10 -308,11 +310,16 @@@ static int c4iw_query_gid(struct ib_dev
  {
  	struct c4iw_dev *dev;
  
++<<<<<<< HEAD
 +	PDBG("%s ibdev %p, port %d, index %d, gid %p\n",
 +	       __func__, ibdev, port, index, gid);
++=======
+ 	pr_debug("ibdev %p, port %d, index %d, gid %p\n",
+ 		 ibdev, port, index, gid);
+ 	if (!port)
+ 		return -EINVAL;
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  	dev = to_c4iw_dev(ibdev);
- 	BUG_ON(port == 0);
  	memset(&(gid->raw[0]), 0, sizeof(gid->raw));
  	memcpy(&(gid->raw[0]), dev->rdev.lldi.ports[port-1]->dev_addr, 6);
  	return 0;
@@@ -538,8 -536,7 +544,12 @@@ int c4iw_register_device(struct c4iw_de
  	int ret;
  	int i;
  
++<<<<<<< HEAD
 +	PDBG("%s c4iw_dev %p\n", __func__, dev);
 +	BUG_ON(!dev->rdev.lldi.ports[0]);
++=======
+ 	pr_debug("c4iw_dev %p\n", dev);
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  	strlcpy(dev->ibdev.name, "cxgb4_%d", IB_DEVICE_NAME_MAX);
  	memset(&dev->ibdev.node_guid, 0, sizeof(dev->ibdev.node_guid));
  	memcpy(&dev->ibdev.node_guid, dev->rdev.lldi.ports[0]->dev_addr, 6);
diff --cc drivers/infiniband/hw/cxgb4/qp.c
index 4f7928418476,1374b41201a9..000000000000
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@@ -1581,7 -1567,6 +1580,10 @@@ int c4iw_modify_qp(struct c4iw_dev *rhp
  	case C4IW_QP_STATE_RTS:
  		switch (attrs->next_state) {
  		case C4IW_QP_STATE_CLOSING:
++<<<<<<< HEAD
 +			BUG_ON(atomic_read(&qhp->ep->com.kref.refcount) < 2);
++=======
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  			t4_set_wq_in_error(&qhp->wq);
  			set_state(qhp, C4IW_QP_STATE_CLOSING);
  			ep = qhp->ep;
diff --cc drivers/infiniband/hw/cxgb4/t4.h
index 640d22148a3e,e9ea94268d51..000000000000
--- a/drivers/infiniband/hw/cxgb4/t4.h
+++ b/drivers/infiniband/hw/cxgb4/t4.h
@@@ -601,9 -596,11 +600,10 @@@ static inline void t4_swcq_produce(stru
  {
  	cq->sw_in_use++;
  	if (cq->sw_in_use == cq->size) {
 -		pr_warn("%s cxgb4 sw cq overflow cqid %u\n",
 -			__func__, cq->cqid);
 +		PDBG("%s cxgb4 sw cq overflow cqid %u\n", __func__, cq->cqid);
  		cq->error = 1;
- 		BUG_ON(1);
+ 		cq->sw_in_use--;
+ 		return;
  	}
  	if (++cq->sw_pidx == cq->size)
  		cq->sw_pidx = 0;
@@@ -656,8 -652,7 +655,12 @@@ static inline int t4_next_hw_cqe(struc
  	if (cq->queue[prev_cidx].bits_type_ts != cq->bits_type_ts) {
  		ret = -EOVERFLOW;
  		cq->error = 1;
++<<<<<<< HEAD
 +		printk(KERN_ERR MOD "cq overflow cqid %u\n", cq->cqid);
 +		BUG_ON(1);
++=======
+ 		pr_err("cq overflow cqid %u\n", cq->cqid);
++>>>>>>> ba97b749979e (iw_cxgb4: remove BUG_ON() usage.)
  	} else if (t4_valid_cqe(cq, &cq->queue[cq->cidx])) {
  
  		/* Ensure CQE is flushed to memory */
@@@ -672,9 -667,9 +675,8 @@@
  static inline struct t4_cqe *t4_next_sw_cqe(struct t4_cq *cq)
  {
  	if (cq->sw_in_use == cq->size) {
 -		pr_warn("%s cxgb4 sw cq overflow cqid %u\n",
 -			__func__, cq->cqid);
 +		PDBG("%s cxgb4 sw cq overflow cqid %u\n", __func__, cq->cqid);
  		cq->error = 1;
- 		BUG_ON(1);
  		return NULL;
  	}
  	if (cq->sw_in_use)
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
* Unmerged path drivers/infiniband/hw/cxgb4/cq.c
diff --git a/drivers/infiniband/hw/cxgb4/id_table.c b/drivers/infiniband/hw/cxgb4/id_table.c
index 0161ae6ad629..5c2cfdea06ad 100644
--- a/drivers/infiniband/hw/cxgb4/id_table.c
+++ b/drivers/infiniband/hw/cxgb4/id_table.c
@@ -73,7 +73,6 @@ void c4iw_id_free(struct c4iw_id_table *alloc, u32 obj)
 	unsigned long flags;
 
 	obj -= alloc->start;
-	BUG_ON((int)obj < 0);
 
 	spin_lock_irqsave(&alloc->lock, flags);
 	clear_bit(obj, alloc->table);
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 9da4fb4991be..d7ac9179d7db 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -311,7 +311,6 @@ static inline int _insert_handle(struct c4iw_dev *rhp, struct idr *idr,
 		idr_preload_end();
 	}
 
-	BUG_ON(ret == -ENOSPC);
 	return ret < 0 ? ret : 0;
 }
 
* Unmerged path drivers/infiniband/hw/cxgb4/provider.c
* Unmerged path drivers/infiniband/hw/cxgb4/qp.c
* Unmerged path drivers/infiniband/hw/cxgb4/t4.h
