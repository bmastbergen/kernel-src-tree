target: Fix missing complete during ABORT_TASK + CMD_T_FABRIC_STOP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Fix missing complete during ABORT_TASK + CMD_T_FABRIC_STOP (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 93.55%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 5e2c956b8aa24d4f33ff7afef92d409eed164746
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5e2c956b.failed

During transport_generic_free_cmd() with a concurrent TMR
ABORT_TASK and shutdown CMD_T_FABRIC_STOP bit set, the
caller will be blocked on se_cmd->cmd_wait_stop completion
until the final kref_put() -> target_release_cmd_kref()
has been invoked to call complete().

However, when ABORT_TASK is completed with FUNCTION_COMPLETE
in core_tmr_abort_task(), the aborted se_cmd will have already
been removed from se_sess->sess_cmd_list via list_del_init().

This results in target_release_cmd_kref() hitting the
legacy list_empty() == true check, invoking ->release_cmd()
but skipping complete() to wakeup se_cmd->cmd_wait_stop
blocked earlier in transport_generic_free_cmd() code.

To address this bug, it's safe to go ahead and drop the
original list_empty() check so that fabric_stop invokes
the complete() as expected, since list_del_init() can
safely be used on a empty list.

	Cc: Mike Christie <mchristi@redhat.com>
	Cc: Quinn Tran <quinn.tran@qlogic.com>
	Cc: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: stable@vger.kernel.org # 3.14+
	Tested-by: Nicholas Bellinger <nab@linux-iscsi.org>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 5e2c956b8aa24d4f33ff7afef92d409eed164746)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_transport.c
diff --cc drivers/target/target_core_transport.c
index 68bc47c2e404,ae97e81141ed..000000000000
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@@ -2546,14 -2553,19 +2546,27 @@@ static void target_release_cmd_kref(str
  {
  	struct se_cmd *se_cmd = container_of(kref, struct se_cmd, cmd_kref);
  	struct se_session *se_sess = se_cmd->se_sess;
 -	unsigned long flags;
 -	bool fabric_stop;
  
++<<<<<<< HEAD
 +	if (list_empty(&se_cmd->se_cmd_list)) {
 +		spin_unlock(&se_sess->sess_cmd_lock);
 +		se_cmd->se_tfo->release_cmd(se_cmd);
 +		return;
 +	}
 +	if (se_sess->sess_tearing_down && se_cmd->cmd_wait_set) {
 +		spin_unlock(&se_sess->sess_cmd_lock);
++=======
+ 	spin_lock_irqsave(&se_sess->sess_cmd_lock, flags);
+ 
+ 	spin_lock(&se_cmd->t_state_lock);
+ 	fabric_stop = (se_cmd->transport_state & CMD_T_FABRIC_STOP);
+ 	spin_unlock(&se_cmd->t_state_lock);
+ 
+ 	if (se_cmd->cmd_wait_set || fabric_stop) {
+ 		list_del_init(&se_cmd->se_cmd_list);
+ 		spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
+ 		target_free_cmd_mem(se_cmd);
++>>>>>>> 5e2c956b8aa2 (target: Fix missing complete during ABORT_TASK + CMD_T_FABRIC_STOP)
  		complete(&se_cmd->cmd_wait_comp);
  		return;
  	}
* Unmerged path drivers/target/target_core_transport.c
