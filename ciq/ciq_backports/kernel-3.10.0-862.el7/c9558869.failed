scsi: qla2xxx: Add ATIO-Q processing for INTx mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add ATIO-Q processing for INTx mode (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 93.62%
commit-author Himanshu Madhani <himanshu.madhani@cavium.com>
commit c955886962a280eb90b6bde87448ee99c467c0b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c9558869.failed

	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c955886962a280eb90b6bde87448ee99c467c0b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_isr.c
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 3d56972c1852,ab97fb06c239..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -2781,13 -3129,23 +2781,22 @@@ qla24xx_intr_handler(int irq, void *dev
  		case INTR_RSP_QUE_UPDATE_83XX:
  			qla24xx_process_response_queue(vha, rsp);
  			break;
++<<<<<<< HEAD
 +		case INTR_ATIO_QUE_UPDATE:
 +			qlt_24xx_process_atio_queue(vha);
++=======
+ 		case INTR_ATIO_QUE_UPDATE_27XX:
+ 		case INTR_ATIO_QUE_UPDATE:{
+ 			unsigned long flags2;
+ 			spin_lock_irqsave(&ha->tgt.atio_lock, flags2);
+ 			qlt_24xx_process_atio_queue(vha, 1);
+ 			spin_unlock_irqrestore(&ha->tgt.atio_lock, flags2);
++>>>>>>> c955886962a2 (scsi: qla2xxx: Add ATIO-Q processing for INTx mode)
  			break;
 -		}
 -		case INTR_ATIO_RSP_QUE_UPDATE: {
 -			unsigned long flags2;
 -			spin_lock_irqsave(&ha->tgt.atio_lock, flags2);
 -			qlt_24xx_process_atio_queue(vha, 1);
 -			spin_unlock_irqrestore(&ha->tgt.atio_lock, flags2);
 -
 +		case INTR_ATIO_RSP_QUE_UPDATE:
 +			qlt_24xx_process_atio_queue(vha);
  			qla24xx_process_response_queue(vha, rsp);
  			break;
 -		}
  		default:
  			ql_dbg(ql_dbg_async, vha, 0x504f,
  			    "Unrecognized interrupt type (%d).\n", stat * 0xff);
@@@ -2911,13 -3260,23 +2920,22 @@@ qla24xx_msix_default(int irq, void *dev
  		case INTR_RSP_QUE_UPDATE_83XX:
  			qla24xx_process_response_queue(vha, rsp);
  			break;
++<<<<<<< HEAD
 +		case INTR_ATIO_QUE_UPDATE:
 +			qlt_24xx_process_atio_queue(vha);
++=======
+ 		case INTR_ATIO_QUE_UPDATE_27XX:
+ 		case INTR_ATIO_QUE_UPDATE:{
+ 			unsigned long flags2;
+ 			spin_lock_irqsave(&ha->tgt.atio_lock, flags2);
+ 			qlt_24xx_process_atio_queue(vha, 1);
+ 			spin_unlock_irqrestore(&ha->tgt.atio_lock, flags2);
++>>>>>>> c955886962a2 (scsi: qla2xxx: Add ATIO-Q processing for INTx mode)
  			break;
 -		}
 -		case INTR_ATIO_RSP_QUE_UPDATE: {
 -			unsigned long flags2;
 -			spin_lock_irqsave(&ha->tgt.atio_lock, flags2);
 -			qlt_24xx_process_atio_queue(vha, 1);
 -			spin_unlock_irqrestore(&ha->tgt.atio_lock, flags2);
 -
 +		case INTR_ATIO_RSP_QUE_UPDATE:
 +			qlt_24xx_process_atio_queue(vha);
  			qla24xx_process_response_queue(vha, rsp);
  			break;
 -		}
  		default:
  			ql_dbg(ql_dbg_async, vha, 0x5051,
  			    "Unrecognized interrupt type (%d).\n", stat & 0xff);
@@@ -3005,25 -3341,29 +3023,32 @@@ qla24xx_disable_msix(struct qla_hw_dat
  static int
  qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)
  {
 +#define MIN_MSIX_COUNT	2
  	int i, ret;
 +	struct msix_entry *entries;
  	struct qla_msix_entry *qentry;
  	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
 -	int min_vecs = QLA_BASE_VECTORS;
 -	struct irq_affinity desc = {
 -		.pre_vectors = QLA_BASE_VECTORS,
 -	};
  
++<<<<<<< HEAD
 +	entries = kzalloc(sizeof(struct msix_entry) * ha->msix_count,
 +			GFP_KERNEL);
 +	if (!entries) {
 +		ql_log(ql_log_warn, vha, 0x00bc,
 +		    "Failed to allocate memory for msix_entry.\n");
 +		return -ENOMEM;
++=======
+ 	if (QLA_TGT_MODE_ENABLED() && (ql2xenablemsix != 0) &&
+ 	    IS_ATIO_MSIX_CAPABLE(ha)) {
+ 		desc.pre_vectors++;
+ 		min_vecs++;
++>>>>>>> c955886962a2 (scsi: qla2xxx: Add ATIO-Q processing for INTx mode)
  	}
  
 -	if (USER_CTRL_IRQ(ha)) {
 -		/* user wants to control IRQ setting for target mode */
 -		ret = pci_alloc_irq_vectors(ha->pdev, min_vecs,
 -		    ha->msix_count, PCI_IRQ_MSIX);
 -	} else
 -		ret = pci_alloc_irq_vectors_affinity(ha->pdev, min_vecs,
 -		    ha->msix_count, PCI_IRQ_MSIX | PCI_IRQ_AFFINITY,
 -		    &desc);
 +	for (i = 0; i < ha->msix_count; i++)
 +		entries[i].entry = i;
  
 +	ret = pci_enable_msix_range(ha->pdev,
 +				    entries, MIN_MSIX_COUNT, ha->msix_count);
  	if (ret < 0) {
  		ql_log(ql_log_fatal, vha, 0x00c7,
  		    "MSI-X: Failed to enable support, "
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812..16f9e1e4751c 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -832,6 +832,7 @@ struct mbx_cmd_32 {
 #define INTR_RSP_QUE_UPDATE_83XX	0x14
 #define INTR_ATIO_QUE_UPDATE		0x1C
 #define INTR_ATIO_RSP_QUE_UPDATE	0x1D
+#define INTR_ATIO_QUE_UPDATE_27XX	0x1E
 
 /* ISP mailbox loopback echo diagnostic error code */
 #define MBS_LB_RESET	0x17
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 4244f37d5d93..a6f998a7fb87 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -4683,6 +4683,7 @@ void
 qlt_24xx_config_rings(struct scsi_qla_host *vha)
 {
 	struct qla_hw_data *ha = vha->hw;
+	struct init_cb_24xx *icb;
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
 
@@ -4690,14 +4691,19 @@ qlt_24xx_config_rings(struct scsi_qla_host *vha)
 	WRT_REG_DWORD(ISP_ATIO_Q_OUT(vha), 0);
 	RD_REG_DWORD(ISP_ATIO_Q_OUT(vha));
 
-	if (IS_ATIO_MSIX_CAPABLE(ha)) {
+	icb = (struct init_cb_24xx *)ha->init_cb;
+
+	if ((ql2xenablemsix != 0) && IS_ATIO_MSIX_CAPABLE(ha)) {
 		struct qla_msix_entry *msix = &ha->msix_entries[2];
-		struct init_cb_24xx *icb = (struct init_cb_24xx *)ha->init_cb;
 
 		icb->msix_atio = cpu_to_le16(msix->entry);
 		ql_dbg(ql_dbg_init, vha, 0xf072,
 		    "Registering ICB vector 0x%x for atio que.\n",
 		    msix->entry);
+	} else if (ql2xenablemsix == 0) {
+		icb->firmware_options_2 |= cpu_to_le32(BIT_26);
+		ql_dbg(ql_dbg_init, vha, 0xf07f,
+		    "Registering INTx vector for ATIO.\n");
 	}
 }
 
@@ -4922,7 +4928,7 @@ qlt_probe_one_stage1(struct scsi_qla_host *base_vha, struct qla_hw_data *ha)
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
 
-	if  (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+	if  ((ql2xenablemsix == 0) || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
 		ISP_ATIO_Q_IN(base_vha) = &ha->mqiobase->isp25mq.atio_q_in;
 		ISP_ATIO_Q_OUT(base_vha) = &ha->mqiobase->isp25mq.atio_q_out;
 	} else {
