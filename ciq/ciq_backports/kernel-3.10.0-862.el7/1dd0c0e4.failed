scsi: cxlflash: Introduce hardware queue steering

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Introduce hardware queue steering (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 93.48%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 1dd0c0e4fd02dc5e5bfaf89bd4656aabe4ae3cb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1dd0c0e4.failed

As an enhancement to distribute requests to multiple hardware queues, add the
infrastructure to hash a SCSI command into a particular hardware queue.
Support the following scenarios when deriving which queue to use: single
queue, tagging when SCSI-MQ enabled, and simple hash via CPU ID when SCSI-MQ
is disabled. Rather than altering the existing send API, the derived hardware
queue is stored in the AFU command where it can be used for sending a command
to the chosen hardware queue.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1dd0c0e4fd02dc5e5bfaf89bd4656aabe4ae3cb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,256af819377d..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -132,11 -149,11 +139,16 @@@ struct cxlflash_cfg 
  struct afu_cmd {
  	struct sisl_ioarcb rcb;	/* IOARCB (cache line aligned) */
  	struct sisl_ioasa sa;	/* IOASA must follow IOARCB */
 -	struct afu *parent;
 -	struct scsi_cmnd *scp;
 +	spinlock_t slock;
  	struct completion cevent;
++<<<<<<< HEAD
 +	struct afu *parent;
 +	int slot;
 +	atomic_t free;
++=======
+ 	struct list_head queue;
+ 	u32 hwq_index;
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  
  	u8 cmd_tmf:1;
  
@@@ -170,11 -202,29 +182,19 @@@ struct afu 
  	u64 *hrrq_end;
  	u64 *hrrq_curr;
  	bool toggle;
 -
  	s64 room;
  	spinlock_t rrin_slock; /* Lock to rrin queuing and cmd_room updates */
 -
 -	struct irq_poll irqpoll;
 -} __aligned(cache_line_size());
 -
 -struct afu {
 -	struct hwq hwqs[CXLFLASH_MAX_HWQS];
 -	int (*send_cmd)(struct afu *, struct afu_cmd *);
 -	void (*context_reset)(struct afu_cmd *);
 -
 -	/* AFU HW */
 -	struct cxlflash_afu_map __iomem *afu_map;	/* entire MMIO map */
 -
 -	atomic_t cmds_active;	/* Number of currently active AFU commands */
  	u64 hb;
 +	u32 cmd_couts;		/* Number of command checkouts */
  	u32 internal_lun;	/* User-desired LUN mode for this AFU */
++<<<<<<< HEAD
++=======
+ 
+ 	u32 num_hwqs;		/* Number of hardware queues */
+ 	u32 desired_hwqs;	/* Desired h/w queues, effective on AFU reset */
+ 	enum cxlflash_hwq_mode hwq_mode; /* Steering mode for h/w queues */
+ 	u32 hwq_rr_count;	/* Count to distribute traffic for roundrobin */
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  
  	char version[16];
  	u64 interface_version;
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,a7d57c343492..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -345,16 -340,60 +345,53 @@@ static void wait_resp(struct afu *afu, 
  	ulong timeout = msecs_to_jiffies(cmd->rcb.timeout * 2 * 1000);
  
  	timeout = wait_for_completion_timeout(&cmd->cevent, timeout);
 -	if (!timeout) {
 -		afu->context_reset(cmd);
 -		rc = -1;
 -	}
 -
 -	if (unlikely(cmd->sa.ioasc != 0)) {
 -		dev_err(dev, "%s: cmd %02x failed, ioasc=%08x\n",
 -			__func__, cmd->rcb.cdb[0], cmd->sa.ioasc);
 -		rc = -1;
 -	}
 +	if (!timeout)
 +		context_reset(cmd);
  
 -	return rc;
 +	if (unlikely(cmd->sa.ioasc != 0))
 +		pr_err("%s: CMD 0x%X failed, IOASC: flags 0x%X, afu_rc 0x%X, "
 +		       "scsi_rc 0x%X, fc_rc 0x%X\n", __func__, cmd->rcb.cdb[0],
 +		       cmd->sa.rc.flags, cmd->sa.rc.afu_rc, cmd->sa.rc.scsi_rc,
 +		       cmd->sa.rc.fc_rc);
  }
  
+ /**
+  * cmd_to_target_hwq() - selects a target hardware queue for a SCSI command
+  * @host:	SCSI host associated with device.
+  * @scp:	SCSI command to send.
+  * @afu:	SCSI command to send.
+  *
+  * Hashes a command based upon the hardware queue mode.
+  *
+  * Return: Trusted index of target hardware queue
+  */
+ static u32 cmd_to_target_hwq(struct Scsi_Host *host, struct scsi_cmnd *scp,
+ 			     struct afu *afu)
+ {
+ 	u32 tag;
+ 	u32 hwq = 0;
+ 
+ 	if (afu->num_hwqs == 1)
+ 		return 0;
+ 
+ 	switch (afu->hwq_mode) {
+ 	case HWQ_MODE_RR:
+ 		hwq = afu->hwq_rr_count++ % afu->num_hwqs;
+ 		break;
+ 	case HWQ_MODE_TAG:
+ 		tag = blk_mq_unique_tag(scp->request);
+ 		hwq = blk_mq_unique_tag_to_hwq(tag);
+ 		break;
+ 	case HWQ_MODE_CPU:
+ 		hwq = smp_processor_id() % afu->num_hwqs;
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 	}
+ 
+ 	return hwq;
+ }
+ 
  /**
   * send_tmf() - sends a Task Management Function (TMF)
   * @afu:	AFU to checkout from.
@@@ -366,13 -405,12 +403,22 @@@
   */
  static int send_tmf(struct afu *afu, struct scsi_cmnd *scp, u64 tmfcmd)
  {
++<<<<<<< HEAD
 +	struct afu_cmd *cmd;
 +
 +	u32 port_sel = scp->device->channel + 1;
 +	short lflag = 0;
 +	struct Scsi_Host *host = scp->device->host;
 +	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)host->hostdata;
 +	struct device *dev = &cfg->dev->dev;
++=======
+ 	struct Scsi_Host *host = scp->device->host;
+ 	struct cxlflash_cfg *cfg = shost_priv(host);
+ 	struct afu_cmd *cmd = sc_to_afucz(scp);
+ 	struct device *dev = &cfg->dev->dev;
+ 	int hwq_index = cmd_to_target_hwq(host, scp, afu);
+ 	struct hwq *hwq = get_hwq(afu, hwq_index);
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  	ulong lock_flags;
  	int rc = 0;
  	ulong to;
@@@ -391,28 -422,24 +437,39 @@@
  						  !cfg->tmf_active,
  						  cfg->tmf_slock);
  	cfg->tmf_active = true;
 +	cmd->cmd_tmf = true;
  	spin_unlock_irqrestore(&cfg->tmf_slock, lock_flags);
  
++<<<<<<< HEAD
 +	cmd->rcb.ctx_id = afu->ctx_hndl;
 +	cmd->rcb.port_sel = port_sel;
++=======
+ 	cmd->scp = scp;
+ 	cmd->parent = afu;
+ 	cmd->cmd_tmf = true;
+ 	cmd->hwq_index = hwq_index;
+ 
+ 	cmd->rcb.ctx_id = hwq->ctx_hndl;
+ 	cmd->rcb.msi = SISL_MSI_RRQ_UPDATED;
+ 	cmd->rcb.port_sel = CHAN2PORTMASK(scp->device->channel);
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  	cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);
 +
 +	lflag = SISL_REQ_FLAGS_TMF_CMD;
 +
  	cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
 -			      SISL_REQ_FLAGS_SUP_UNDERRUN |
 -			      SISL_REQ_FLAGS_TMF_CMD);
 +			      SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
 +
 +	/* Stash the scp in the reserved field, for reuse during interrupt */
 +	cmd->rcb.scp = scp;
 +
 +	/* Copy the CDB from the cmd passed in */
  	memcpy(cmd->rcb.cdb, &tmfcmd, sizeof(tmfcmd));
  
 -	rc = afu->send_cmd(afu, cmd);
 +	/* Send the command */
 +	rc = send_cmd(afu, cmd);
  	if (unlikely(rc)) {
 +		cmd_checkin(cmd);
  		spin_lock_irqsave(&cfg->tmf_slock, lock_flags);
  		cfg->tmf_active = false;
  		spin_unlock_irqrestore(&cfg->tmf_slock, lock_flags);
@@@ -455,19 -482,19 +512,27 @@@ static const char *cxlflash_driver_info
   */
  static int cxlflash_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scp)
  {
 -	struct cxlflash_cfg *cfg = shost_priv(host);
 +	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)host->hostdata;
  	struct afu *afu = cfg->afu;
  	struct device *dev = &cfg->dev->dev;
++<<<<<<< HEAD
 +	struct afu_cmd *cmd;
 +	u32 port_sel = scp->device->channel + 1;
 +	int nseg, i, ncount;
 +	struct scatterlist *sg;
++=======
+ 	struct afu_cmd *cmd = sc_to_afucz(scp);
+ 	struct scatterlist *sg = scsi_sglist(scp);
+ 	int hwq_index = cmd_to_target_hwq(host, scp, afu);
+ 	struct hwq *hwq = get_hwq(afu, hwq_index);
+ 	u16 req_flags = SISL_REQ_FLAGS_SUP_UNDERRUN;
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  	ulong lock_flags;
 +	short lflag = 0;
  	int rc = 0;
  
 -	dev_dbg_ratelimited(dev, "%s: (scp=%p) %d/%d/%d/%llu "
 -			    "cdb=(%08x-%08x-%08x-%08x)\n",
 +	dev_dbg_ratelimited(dev, "%s: (scp=%p) %d/%d/%d/%d "
 +			    "cdb=(%08X-%08X-%08X-%08X)\n",
  			    __func__, scp, host->host_no, scp->device->channel,
  			    scp->device->id, scp->device->lun,
  			    get_unaligned_be32(&((u32 *)scp->cmnd)[0]),
@@@ -502,15 -531,18 +567,25 @@@
  		break;
  	}
  
 -	if (likely(sg)) {
 -		cmd->rcb.data_len = sg->length;
 -		cmd->rcb.data_ea = (uintptr_t)sg_virt(sg);
 +	cmd = cmd_checkout(afu);
 +	if (unlikely(!cmd)) {
 +		dev_err(dev, "%s: could not get a free command\n", __func__);
 +		rc = SCSI_MLQUEUE_HOST_BUSY;
 +		goto out;
  	}
  
++<<<<<<< HEAD
 +	cmd->rcb.ctx_id = afu->ctx_hndl;
 +	cmd->rcb.port_sel = port_sel;
++=======
+ 	cmd->scp = scp;
+ 	cmd->parent = afu;
+ 	cmd->hwq_index = hwq_index;
+ 
+ 	cmd->rcb.ctx_id = hwq->ctx_hndl;
+ 	cmd->rcb.msi = SISL_MSI_RRQ_UPDATED;
+ 	cmd->rcb.port_sel = CHAN2PORTMASK(scp->device->channel);
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  	cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);
  
  	if (scp->sc_data_direction == DMA_TO_DEVICE)
@@@ -2230,13 -2493,275 +2305,81 @@@ static ssize_t port1_lun_table_show(str
  				    struct device_attribute *attr,
  				    char *buf)
  {
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -
 -	return cxlflash_show_port_lun_table(1, cfg, buf);
 -}
 -
 -/**
 - * port2_lun_table_show() - presents the current LUN table of port 2
 - * @dev:	Generic device associated with the host owning the port.
 - * @attr:	Device attribute representing the port.
 - * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t port2_lun_table_show(struct device *dev,
 -				    struct device_attribute *attr,
 -				    char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -
 -	return cxlflash_show_port_lun_table(2, cfg, buf);
 -}
 -
 -/**
 - * port3_lun_table_show() - presents the current LUN table of port 3
 - * @dev:	Generic device associated with the host owning the port.
 - * @attr:	Device attribute representing the port.
 - * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t port3_lun_table_show(struct device *dev,
 -				    struct device_attribute *attr,
 -				    char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -
 -	return cxlflash_show_port_lun_table(3, cfg, buf);
 -}
 -
 -/**
 - * irqpoll_weight_show() - presents the current IRQ poll weight for the host
 - * @dev:	Generic device associated with the host.
 - * @attr:	Device attribute representing the IRQ poll weight.
 - * @buf:	Buffer of length PAGE_SIZE to report back the current IRQ poll
 - *		weight in ASCII.
 - *
 - * An IRQ poll weight of 0 indicates polling is disabled.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t irqpoll_weight_show(struct device *dev,
 -				   struct device_attribute *attr, char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -	struct afu *afu = cfg->afu;
 -
 -	return scnprintf(buf, PAGE_SIZE, "%u\n", afu->irqpoll_weight);
 -}
 -
 -/**
 - * irqpoll_weight_store() - sets the current IRQ poll weight for the host
 - * @dev:	Generic device associated with the host.
 - * @attr:	Device attribute representing the IRQ poll weight.
 - * @buf:	Buffer of length PAGE_SIZE containing the desired IRQ poll
 - *		weight in ASCII.
 - * @count:	Length of data resizing in @buf.
 - *
 - * An IRQ poll weight of 0 indicates polling is disabled.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t irqpoll_weight_store(struct device *dev,
 -				    struct device_attribute *attr,
 -				    const char *buf, size_t count)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -	struct device *cfgdev = &cfg->dev->dev;
 -	struct afu *afu = cfg->afu;
 -	struct hwq *hwq;
 -	u32 weight;
 -	int rc, i;
 -
 -	rc = kstrtouint(buf, 10, &weight);
 -	if (rc)
 -		return -EINVAL;
 -
 -	if (weight > 256) {
 -		dev_info(cfgdev,
 -			 "Invalid IRQ poll weight. It must be 256 or less.\n");
 -		return -EINVAL;
 -	}
 -
 -	if (weight == afu->irqpoll_weight) {
 -		dev_info(cfgdev,
 -			 "Current IRQ poll weight has the same weight.\n");
 -		return -EINVAL;
 -	}
 -
 -	if (afu_is_irqpoll_enabled(afu)) {
 -		for (i = 0; i < afu->num_hwqs; i++) {
 -			hwq = get_hwq(afu, i);
 -
 -			irq_poll_disable(&hwq->irqpoll);
 -		}
 -	}
 -
 -	afu->irqpoll_weight = weight;
 -
 -	if (weight > 0) {
 -		for (i = 0; i < afu->num_hwqs; i++) {
 -			hwq = get_hwq(afu, i);
 -
 -			irq_poll_init(&hwq->irqpoll, weight, cxlflash_irqpoll);
 -		}
 -	}
 -
 -	return count;
 -}
 -
 -/**
 - * num_hwqs_show() - presents the number of hardware queues for the host
 - * @dev:	Generic device associated with the host.
 - * @attr:	Device attribute representing the number of hardware queues.
 - * @buf:	Buffer of length PAGE_SIZE to report back the number of hardware
 - *		queues in ASCII.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t num_hwqs_show(struct device *dev,
 -			     struct device_attribute *attr, char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -	struct afu *afu = cfg->afu;
 -
 -	return scnprintf(buf, PAGE_SIZE, "%u\n", afu->num_hwqs);
 -}
 -
 -/**
 - * num_hwqs_store() - sets the number of hardware queues for the host
 - * @dev:	Generic device associated with the host.
 - * @attr:	Device attribute representing the number of hardware queues.
 - * @buf:	Buffer of length PAGE_SIZE containing the number of hardware
 - *		queues in ASCII.
 - * @count:	Length of data resizing in @buf.
 - *
 - * n > 0: num_hwqs = n
 - * n = 0: num_hwqs = num_online_cpus()
 - * n < 0: num_online_cpus() / abs(n)
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t num_hwqs_store(struct device *dev,
 -			      struct device_attribute *attr,
 -			      const char *buf, size_t count)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 +	struct Scsi_Host *shost = class_to_shost(dev);
 +	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)shost->hostdata;
  	struct afu *afu = cfg->afu;
 -	int rc;
 -	int nhwqs, num_hwqs;
  
 -	rc = kstrtoint(buf, 10, &nhwqs);
 -	if (rc)
 -		return -EINVAL;
 -
 -	if (nhwqs >= 1)
 -		num_hwqs = nhwqs;
 -	else if (nhwqs == 0)
 -		num_hwqs = num_online_cpus();
 -	else
 -		num_hwqs = num_online_cpus() / abs(nhwqs);
 -
 -	afu->desired_hwqs = min(num_hwqs, CXLFLASH_MAX_HWQS);
 -	WARN_ON_ONCE(afu->desired_hwqs == 0);
 -
 -retry:
 -	switch (cfg->state) {
 -	case STATE_NORMAL:
 -		cfg->state = STATE_RESET;
 -		drain_ioctls(cfg);
 -		cxlflash_mark_contexts_error(cfg);
 -		rc = afu_reset(cfg);
 -		if (rc)
 -			cfg->state = STATE_FAILTERM;
 -		else
 -			cfg->state = STATE_NORMAL;
 -		wake_up_all(&cfg->reset_waitq);
 -		break;
 -	case STATE_RESET:
 -		wait_event(cfg->reset_waitq, cfg->state != STATE_RESET);
 -		if (cfg->state == STATE_NORMAL)
 -			goto retry;
 -	default:
 -		/* Ideally should not happen */
 -		dev_err(dev, "%s: Device is not ready, state=%d\n",
 -			__func__, cfg->state);
 -		break;
 -	}
 -
 -	return count;
 +	return cxlflash_show_port_lun_table(1, afu, buf);
  }
  
+ static const char *hwq_mode_name[MAX_HWQ_MODE] = { "rr", "tag", "cpu" };
+ 
+ /**
+  * hwq_mode_show() - presents the HWQ steering mode for the host
+  * @dev:	Generic device associated with the host.
+  * @attr:	Device attribute representing the HWQ steering mode.
+  * @buf:	Buffer of length PAGE_SIZE to report back the HWQ steering mode
+  *		as a character string.
+  *
+  * Return: The size of the ASCII string returned in @buf.
+  */
+ static ssize_t hwq_mode_show(struct device *dev,
+ 			     struct device_attribute *attr, char *buf)
+ {
+ 	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
+ 	struct afu *afu = cfg->afu;
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", hwq_mode_name[afu->hwq_mode]);
+ }
+ 
+ /**
+  * hwq_mode_store() - sets the HWQ steering mode for the host
+  * @dev:	Generic device associated with the host.
+  * @attr:	Device attribute representing the HWQ steering mode.
+  * @buf:	Buffer of length PAGE_SIZE containing the HWQ steering mode
+  *		as a character string.
+  * @count:	Length of data resizing in @buf.
+  *
+  * rr = Round-Robin
+  * tag = Block MQ Tagging
+  * cpu = CPU Affinity
+  *
+  * Return: The size of the ASCII string returned in @buf.
+  */
+ static ssize_t hwq_mode_store(struct device *dev,
+ 			      struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+ 	struct Scsi_Host *shost = class_to_shost(dev);
+ 	struct cxlflash_cfg *cfg = shost_priv(shost);
+ 	struct device *cfgdev = &cfg->dev->dev;
+ 	struct afu *afu = cfg->afu;
+ 	int i;
+ 	u32 mode = MAX_HWQ_MODE;
+ 
+ 	for (i = 0; i < MAX_HWQ_MODE; i++) {
+ 		if (!strncmp(hwq_mode_name[i], buf, strlen(hwq_mode_name[i]))) {
+ 			mode = i;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (mode >= MAX_HWQ_MODE) {
+ 		dev_info(cfgdev, "Invalid HWQ steering mode.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((mode == HWQ_MODE_TAG) && !shost_use_blk_mq(shost)) {
+ 		dev_info(cfgdev, "SCSI-MQ is not enabled, use a different "
+ 			 "HWQ steering mode.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	afu->hwq_mode = mode;
+ 
+ 	return count;
+ }
+ 
  /**
   * mode_show() - presents the current mode of the device
   * @dev:	Generic device associated with the device.
@@@ -2263,6 -2790,11 +2406,14 @@@ static DEVICE_ATTR_RW(lun_mode)
  static DEVICE_ATTR_RO(ioctl_version);
  static DEVICE_ATTR_RO(port0_lun_table);
  static DEVICE_ATTR_RO(port1_lun_table);
++<<<<<<< HEAD
++=======
+ static DEVICE_ATTR_RO(port2_lun_table);
+ static DEVICE_ATTR_RO(port3_lun_table);
+ static DEVICE_ATTR_RW(irqpoll_weight);
+ static DEVICE_ATTR_RW(num_hwqs);
+ static DEVICE_ATTR_RW(hwq_mode);
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  
  static struct device_attribute *cxlflash_host_attrs[] = {
  	&dev_attr_port0,
@@@ -2271,6 -2805,11 +2422,14 @@@
  	&dev_attr_ioctl_version,
  	&dev_attr_port0_lun_table,
  	&dev_attr_port1_lun_table,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_port2_lun_table,
+ 	&dev_attr_port3_lun_table,
+ 	&dev_attr_irqpoll_weight,
+ 	&dev_attr_num_hwqs,
+ 	&dev_attr_hwq_mode,
++>>>>>>> 1dd0c0e4fd02 (scsi: cxlflash: Introduce hardware queue steering)
  	NULL
  };
  
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
