libceph: use alloc_pg_mapping() in __decode_pg_upmap_items()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit f5cc6898650210a90669437d2d9a3fd564ff7d88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f5cc6898.failed

... otherwise we die in insert_pg_mapping(), which wants pg->node to be
empty, i.e. initialized with RB_CLEAR_NODE.

Fixes: 6f428df47dae ("libceph: pg_upmap[_items] infrastructure")
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit f5cc6898650210a90669437d2d9a3fd564ff7d88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osdmap.c
diff --cc net/ceph/osdmap.c
index c0502f182074,64ae9f89773a..000000000000
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@@ -1350,6 -1366,75 +1350,78 @@@ e_inval
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static struct ceph_pg_mapping *__decode_pg_upmap(void **p, void *end,
+ 						 bool __unused)
+ {
+ 	return __decode_pg_temp(p, end, false);
+ }
+ 
+ static int decode_pg_upmap(void **p, void *end, struct ceph_osdmap *map)
+ {
+ 	return decode_pg_mapping(p, end, &map->pg_upmap, __decode_pg_upmap,
+ 				 false);
+ }
+ 
+ static int decode_new_pg_upmap(void **p, void *end, struct ceph_osdmap *map)
+ {
+ 	return decode_pg_mapping(p, end, &map->pg_upmap, __decode_pg_upmap,
+ 				 true);
+ }
+ 
+ static int decode_old_pg_upmap(void **p, void *end, struct ceph_osdmap *map)
+ {
+ 	return decode_pg_mapping(p, end, &map->pg_upmap, NULL, true);
+ }
+ 
+ static struct ceph_pg_mapping *__decode_pg_upmap_items(void **p, void *end,
+ 						       bool __unused)
+ {
+ 	struct ceph_pg_mapping *pg;
+ 	u32 len, i;
+ 
+ 	ceph_decode_32_safe(p, end, len, e_inval);
+ 	if (len > (SIZE_MAX - sizeof(*pg)) / (2 * sizeof(u32)))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	ceph_decode_need(p, end, 2 * len * sizeof(u32), e_inval);
+ 	pg = alloc_pg_mapping(2 * len * sizeof(u32));
+ 	if (!pg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pg->pg_upmap_items.len = len;
+ 	for (i = 0; i < len; i++) {
+ 		pg->pg_upmap_items.from_to[i][0] = ceph_decode_32(p);
+ 		pg->pg_upmap_items.from_to[i][1] = ceph_decode_32(p);
+ 	}
+ 
+ 	return pg;
+ 
+ e_inval:
+ 	return ERR_PTR(-EINVAL);
+ }
+ 
+ static int decode_pg_upmap_items(void **p, void *end, struct ceph_osdmap *map)
+ {
+ 	return decode_pg_mapping(p, end, &map->pg_upmap_items,
+ 				 __decode_pg_upmap_items, false);
+ }
+ 
+ static int decode_new_pg_upmap_items(void **p, void *end,
+ 				     struct ceph_osdmap *map)
+ {
+ 	return decode_pg_mapping(p, end, &map->pg_upmap_items,
+ 				 __decode_pg_upmap_items, true);
+ }
+ 
+ static int decode_old_pg_upmap_items(void **p, void *end,
+ 				     struct ceph_osdmap *map)
+ {
+ 	return decode_pg_mapping(p, end, &map->pg_upmap_items, NULL, true);
+ }
+ 
++>>>>>>> f5cc68986502 (libceph: use alloc_pg_mapping() in __decode_pg_upmap_items())
  /*
   * decode a full map.
   */
* Unmerged path net/ceph/osdmap.c
