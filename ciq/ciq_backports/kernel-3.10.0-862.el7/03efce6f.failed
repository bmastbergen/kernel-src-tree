nVMX: Advertise PML to L1 hypervisor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bandan Das <bsd@redhat.com>
commit 03efce6f935f89f90a98997ceea514aeff47b6dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/03efce6f.failed

Advertise the PML bit in vmcs12 but don't try to enable
it in hardware when running L2 since L0 is emulating it. Also,
preserve L0's settings for PML since it may still
want to log writes.

	Signed-off-by: Bandan Das <bsd@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 03efce6f935f89f90a98997ceea514aeff47b6dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 8426c9cb3bfe,c6f4ad44aa95..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2656,6 -2766,11 +2656,14 @@@ static void nested_vmx_setup_ctls_msrs(
  		vmx->nested.nested_vmx_ept_caps |= VMX_EPT_EXTENT_GLOBAL_BIT |
  			VMX_EPT_EXTENT_CONTEXT_BIT | VMX_EPT_2MB_PAGE_BIT |
  			VMX_EPT_1GB_PAGE_BIT;
++<<<<<<< HEAD
++=======
+ 		if (enable_ept_ad_bits) {
+ 			vmx->nested.nested_vmx_secondary_ctls_high |=
+ 				SECONDARY_EXEC_ENABLE_PML;
+ 		       vmx->nested.nested_vmx_ept_caps |= VMX_EPT_AD_BIT;
+ 		}
++>>>>>>> 03efce6f935f (nVMX: Advertise PML to L1 hypervisor)
  	} else
  		vmx->nested.nested_vmx_ept_caps = 0;
  
@@@ -7926,8 -8121,18 +7934,8 @@@ static bool nested_vmx_exit_handled(str
  		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);
  	case EXIT_REASON_XSETBV:
  		return true;
 -	case EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:
 -		/*
 -		 * This should never happen, since it is not possible to
 -		 * set XSS to a non-zero value---neither in L1 nor in L2.
 -		 * If if it were, XSS would have to be checked against
 -		 * the XSS exit bitmap in vmcs12.
 -		 */
 -		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);
 -	case EXIT_REASON_PREEMPTION_TIMER:
 -		return false;
  	case EXIT_REASON_PML_FULL:
- 		/* We don't expose PML support to L1. */
+ 		/* We emulate PML support to L1. */
  		return false;
  	default:
  		return true;
@@@ -9610,11 -9924,10 +9618,15 @@@ static int nested_vmx_load_cr3(struct k
   * is assigned to entry_failure_code on failure.
   */
  static int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
 -			  bool from_vmentry, u32 *entry_failure_code)
 +			  unsigned long *entry_failure_code)
  {
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
++<<<<<<< HEAD
 +	u32 exec_control;
 +	bool nested_ept_enabled = false;
++=======
+ 	u32 exec_control, vmcs12_exec_ctrl;
++>>>>>>> 03efce6f935f (nVMX: Advertise PML to L1 hypervisor)
  
  	vmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);
  	vmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);
@@@ -9737,29 -10058,12 +9749,32 @@@
  				  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
  				  SECONDARY_EXEC_APIC_REGISTER_VIRT);
  		if (nested_cpu_has(vmcs12,
- 				CPU_BASED_ACTIVATE_SECONDARY_CONTROLS))
- 			exec_control |= vmcs12->secondary_vm_exec_control;
+ 				   CPU_BASED_ACTIVATE_SECONDARY_CONTROLS)) {
+ 			vmcs12_exec_ctrl = vmcs12->secondary_vm_exec_control &
+ 				~SECONDARY_EXEC_ENABLE_PML;
+ 			exec_control |= vmcs12_exec_ctrl;
+ 		}
  
 +		if (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {
 +			/*
 +			 * If translation failed, no matter: This feature asks
 +			 * to exit when accessing the given address, and if it
 +			 * can never be accessed, this feature won't do
 +			 * anything anyway.
 +			 */
 +			if (!vmx->nested.apic_access_page)
 +				exec_control &=
 +				  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 +			else
 +				vmcs_write64(APIC_ACCESS_ADDR,
 +				  page_to_phys(vmx->nested.apic_access_page));
 +		} else if (!(nested_cpu_has_virt_x2apic_mode(vmcs12)) &&
 +			    cpu_need_virtualize_apic_accesses(&vmx->vcpu)) {
 +			exec_control |=
 +				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 +			kvm_vcpu_reload_apic_access_page(vcpu);
 +		}
 +
  		if (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {
  			vmcs_write64(EOI_EXIT_BITMAP0,
  				vmcs12->eoi_exit_bitmap0);
* Unmerged path arch/x86/kvm/vmx.c
