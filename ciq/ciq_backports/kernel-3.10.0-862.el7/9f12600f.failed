dcache: add missing lockdep annotation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 9f12600fe425bc28f0ccba034a77783c09c15af4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9f12600f.failed

lock_parent() very much on purpose does nested locking of dentries, and
is careful to maintain the right order (lock parent first).  But because
it didn't annotate the nested locking order, lockdep thought it might be
a deadlock on d_lock, and complained.

Add the proper annotation for the inner locking of the child dentry to
make lockdep happy.

Introduced by commit 046b961b45f9 ("shrink_dentry_list(): take parent's
->d_lock earlier").

Reported-and-tested-by: Josh Boyer <jwboyer@fedoraproject.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9f12600fe425bc28f0ccba034a77783c09c15af4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index e518a196fb4f,be2bea834bf4..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -482,10 -460,103 +482,104 @@@ relock
  	if ((dentry->d_flags & DCACHE_OP_PRUNE) && !d_unhashed(dentry))
  		dentry->d_op->d_prune(dentry);
  
 -	if (dentry->d_flags & DCACHE_LRU_LIST) {
 -		if (!(dentry->d_flags & DCACHE_SHRINK_LIST))
 -			d_lru_del(dentry);
 -	}
 +	dentry_lru_del(dentry);
  	/* if it was on the hash then remove it */
  	__d_drop(dentry);
++<<<<<<< HEAD
 +	return d_kill(dentry, parent);
++=======
+ 	list_del(&dentry->d_u.d_child);
+ 	/*
+ 	 * Inform d_walk() that we are no longer attached to the
+ 	 * dentry tree
+ 	 */
+ 	dentry->d_flags |= DCACHE_DENTRY_KILLED;
+ 	if (parent)
+ 		spin_unlock(&parent->d_lock);
+ 	dentry_iput(dentry);
+ 	/*
+ 	 * dentry_iput drops the locks, at which point nobody (except
+ 	 * transient RCU lookups) can reach this dentry.
+ 	 */
+ 	BUG_ON((int)dentry->d_lockref.count > 0);
+ 	this_cpu_dec(nr_dentry);
+ 	if (dentry->d_op && dentry->d_op->d_release)
+ 		dentry->d_op->d_release(dentry);
+ 
+ 	spin_lock(&dentry->d_lock);
+ 	if (dentry->d_flags & DCACHE_SHRINK_LIST) {
+ 		dentry->d_flags |= DCACHE_MAY_FREE;
+ 		can_free = false;
+ 	}
+ 	spin_unlock(&dentry->d_lock);
+ 	if (likely(can_free))
+ 		dentry_free(dentry);
+ }
+ 
+ /*
+  * Finish off a dentry we've decided to kill.
+  * dentry->d_lock must be held, returns with it unlocked.
+  * If ref is non-zero, then decrement the refcount too.
+  * Returns dentry requiring refcount drop, or NULL if we're done.
+  */
+ static struct dentry *dentry_kill(struct dentry *dentry)
+ 	__releases(dentry->d_lock)
+ {
+ 	struct inode *inode = dentry->d_inode;
+ 	struct dentry *parent = NULL;
+ 
+ 	if (inode && unlikely(!spin_trylock(&inode->i_lock)))
+ 		goto failed;
+ 
+ 	if (!IS_ROOT(dentry)) {
+ 		parent = dentry->d_parent;
+ 		if (unlikely(!spin_trylock(&parent->d_lock))) {
+ 			if (inode)
+ 				spin_unlock(&inode->i_lock);
+ 			goto failed;
+ 		}
+ 	}
+ 
+ 	__dentry_kill(dentry);
+ 	return parent;
+ 
+ failed:
+ 	spin_unlock(&dentry->d_lock);
+ 	cpu_relax();
+ 	return dentry; /* try again with same dentry */
+ }
+ 
+ static inline struct dentry *lock_parent(struct dentry *dentry)
+ {
+ 	struct dentry *parent = dentry->d_parent;
+ 	if (IS_ROOT(dentry))
+ 		return NULL;
+ 	if (likely(spin_trylock(&parent->d_lock)))
+ 		return parent;
+ 	spin_unlock(&dentry->d_lock);
+ 	rcu_read_lock();
+ again:
+ 	parent = ACCESS_ONCE(dentry->d_parent);
+ 	spin_lock(&parent->d_lock);
+ 	/*
+ 	 * We can't blindly lock dentry until we are sure
+ 	 * that we won't violate the locking order.
+ 	 * Any changes of dentry->d_parent must have
+ 	 * been done with parent->d_lock held, so
+ 	 * spin_lock() above is enough of a barrier
+ 	 * for checking if it's still our child.
+ 	 */
+ 	if (unlikely(parent != dentry->d_parent)) {
+ 		spin_unlock(&parent->d_lock);
+ 		goto again;
+ 	}
+ 	rcu_read_unlock();
+ 	if (parent != dentry)
+ 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
+ 	else
+ 		parent = NULL;
+ 	return parent;
++>>>>>>> 9f12600fe425 (dcache: add missing lockdep annotation)
  }
  
  /* 
* Unmerged path fs/dcache.c
