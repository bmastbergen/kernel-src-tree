IB/hfi1: Add support to send 16B bypass packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit 30e07416cf48801f127019c1dfece8039f1da8e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/30e07416.failed

We introduce struct hfi1_opa_header as a union
of ib (9B) and 16B headers.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 30e07416cf48801f127019c1dfece8039f1da8e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/rc.c
#	drivers/infiniband/hw/hfi1/ruc.c
#	drivers/infiniband/hw/hfi1/uc.c
#	drivers/infiniband/hw/hfi1/ud.c
#	drivers/infiniband/hw/hfi1/verbs.h
diff --cc drivers/infiniband/hw/hfi1/rc.c
index be9bcccf13a9,e3dbf6d45afe..000000000000
--- a/drivers/infiniband/hw/hfi1/rc.c
+++ b/drivers/infiniband/hw/hfi1/rc.c
@@@ -273,9 -273,9 +273,15 @@@ int hfi1_make_rc_req(struct rvt_qp *qp
  	if (IS_ERR(ps->s_txreq))
  		goto bail_no_tx;
  
++<<<<<<< HEAD
 +	ohdr = &ps->s_txreq->phdr.hdr.u.oth;
 +	if (qp->remote_ah_attr.ah_flags & IB_AH_GRH)
 +		ohdr = &ps->s_txreq->phdr.hdr.u.l.oth;
++=======
+ 	ohdr = &ps->s_txreq->phdr.hdr.ibh.u.oth;
+ 	if (rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)
+ 		ohdr = &ps->s_txreq->phdr.hdr.ibh.u.l.oth;
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  
  	/* Sending responses has higher priority over sending requests. */
  	if ((qp->s_flags & RVT_S_RESP_PENDING) &&
@@@ -741,15 -742,19 +748,26 @@@ void hfi1_send_rc_ack(struct hfi1_ctxtd
  		goto queue_ack;
  
  	/* Construct the header */
+ 	opah.hdr_type = 0;
+ 	hdr = &opah.ibh;
+ 
  	/* header size in 32-bit words LRH+BTH+AETH = (8+12+4)/4 */
  	hwords = 6;
++<<<<<<< HEAD
 +	if (unlikely(qp->remote_ah_attr.ah_flags & IB_AH_GRH)) {
 +		hwords += hfi1_make_grh(ibp, &hdr.u.l.grh,
 +				       &qp->remote_ah_attr.grh, hwords, 0);
 +		ohdr = &hdr.u.l.oth;
++=======
+ 	if (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)) {
+ 		hwords += hfi1_make_grh(ibp, &hdr->u.l.grh,
+ 					rdma_ah_read_grh(&qp->remote_ah_attr),
+ 					hwords, 0);
+ 		ohdr = &hdr->u.l.oth;
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  		lrh0 = HFI1_LRH_GRH;
  	} else {
- 		ohdr = &hdr.u.oth;
+ 		ohdr = &hdr->u.oth;
  		lrh0 = HFI1_LRH_BTH;
  	}
  	/* read pkey_index w/o lock (its atomic) */
@@@ -762,14 -767,16 +780,25 @@@
  					     IB_AETH_CREDIT_SHIFT));
  	else
  		ohdr->u.aeth = rvt_compute_aeth(qp);
 -	sc5 = ibp->sl_to_sc[rdma_ah_get_sl(&qp->remote_ah_attr)];
 +	sc5 = ibp->sl_to_sc[qp->remote_ah_attr.sl];
  	/* set PBC_DC_INFO bit (aka SC[4]) in pbc_flags */
++<<<<<<< HEAD
 +	pbc_flags |= ((!!(sc5 & 0x10)) << PBC_DC_INFO_SHIFT);
 +	lrh0 |= (sc5 & 0xf) << 12 | (qp->remote_ah_attr.sl & 0xf) << 4;
 +	hdr.lrh[0] = cpu_to_be16(lrh0);
 +	hdr.lrh[1] = cpu_to_be16(qp->remote_ah_attr.dlid);
 +	hdr.lrh[2] = cpu_to_be16(hwords + SIZE_OF_CRC);
 +	hdr.lrh[3] = cpu_to_be16(ppd->lid | qp->remote_ah_attr.src_path_bits);
++=======
+ 	pbc_flags |= (ib_is_sc5(sc5) << PBC_DC_INFO_SHIFT);
+ 	lrh0 |= (sc5 & 0xf) << 12 | (rdma_ah_get_sl(&qp->remote_ah_attr)
+ 				     & 0xf) << 4;
+ 	hdr->lrh[0] = cpu_to_be16(lrh0);
+ 	hdr->lrh[1] = cpu_to_be16(rdma_ah_get_dlid(&qp->remote_ah_attr));
+ 	hdr->lrh[2] = cpu_to_be16(hwords + SIZE_OF_CRC);
+ 	hdr->lrh[3] = cpu_to_be16(ppd->lid |
+ 				  rdma_ah_get_path_bits(&qp->remote_ah_attr));
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  	ohdr->bth[0] = cpu_to_be32(bth0);
  	ohdr->bth[1] = cpu_to_be32(qp->remote_qpn);
  	ohdr->bth[1] |= cpu_to_be32((!!is_fecn) << IB_BECN_SHIFT);
diff --cc drivers/infiniband/hw/hfi1/ruc.c
index 675f4ef89dc3,e30c64fcce67..000000000000
--- a/drivers/infiniband/hw/hfi1/ruc.c
+++ b/drivers/infiniband/hw/hfi1/ruc.c
@@@ -733,11 -741,12 +734,20 @@@ void hfi1_make_ruc_header(struct rvt_q
  	extra_bytes = -ps->s_txreq->s_cur_size & 3;
  	nwords = (ps->s_txreq->s_cur_size + extra_bytes) >> 2;
  	lrh0 = HFI1_LRH_BTH;
++<<<<<<< HEAD
 +	if (unlikely(qp->remote_ah_attr.ah_flags & IB_AH_GRH)) {
 +		qp->s_hdrwords += hfi1_make_grh(ibp,
 +						&ps->s_txreq->phdr.hdr.u.l.grh,
 +						&qp->remote_ah_attr.grh,
 +						qp->s_hdrwords, nwords);
++=======
+ 	if (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)) {
+ 		qp->s_hdrwords +=
+ 			hfi1_make_grh(ibp,
+ 				      &ps->s_txreq->phdr.hdr.ibh.u.l.grh,
+ 				      &qp->remote_ah_attr.grh,
+ 				      qp->s_hdrwords, nwords);
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  		lrh0 = HFI1_LRH_GRH;
  		middle = 0;
  	}
@@@ -764,12 -774,14 +774,23 @@@
  		build_ahg(qp, bth2);
  	else
  		qp->s_flags &= ~RVT_S_AHG_VALID;
++<<<<<<< HEAD
 +	ps->s_txreq->phdr.hdr.lrh[0] = cpu_to_be16(lrh0);
 +	ps->s_txreq->phdr.hdr.lrh[1] = cpu_to_be16(qp->remote_ah_attr.dlid);
 +	ps->s_txreq->phdr.hdr.lrh[2] =
 +		cpu_to_be16(qp->s_hdrwords + nwords + SIZE_OF_CRC);
 +	ps->s_txreq->phdr.hdr.lrh[3] = cpu_to_be16(ppd_from_ibp(ibp)->lid |
 +				       qp->remote_ah_attr.src_path_bits);
++=======
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[0] = cpu_to_be16(lrh0);
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[1] =
+ 		cpu_to_be16(rdma_ah_get_dlid(&qp->remote_ah_attr));
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[2] =
+ 		cpu_to_be16(qp->s_hdrwords + nwords + SIZE_OF_CRC);
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[3] =
+ 		cpu_to_be16(ppd_from_ibp(ibp)->lid |
+ 		rdma_ah_get_path_bits(&qp->remote_ah_attr));
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  	bth0 |= hfi1_get_pkey(ibp, qp->s_pkey_index);
  	bth0 |= extra_bytes << 20;
  	ohdr->bth[0] = cpu_to_be32(bth0);
diff --cc drivers/infiniband/hw/hfi1/uc.c
index f0bdb100e005,e0bb766ae36c..000000000000
--- a/drivers/infiniband/hw/hfi1/uc.c
+++ b/drivers/infiniband/hw/hfi1/uc.c
@@@ -93,9 -93,9 +93,15 @@@ int hfi1_make_uc_req(struct rvt_qp *qp
  		goto done_free_tx;
  	}
  
++<<<<<<< HEAD
 +	ohdr = &ps->s_txreq->phdr.hdr.u.oth;
 +	if (qp->remote_ah_attr.ah_flags & IB_AH_GRH)
 +		ohdr = &ps->s_txreq->phdr.hdr.u.l.oth;
++=======
+ 	ohdr = &ps->s_txreq->phdr.hdr.ibh.u.oth;
+ 	if (rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)
+ 		ohdr = &ps->s_txreq->phdr.hdr.ibh.u.l.oth;
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  
  	/* Get the next send request. */
  	wqe = rvt_get_swqe_ptr(qp, qp->s_cur);
diff --cc drivers/infiniband/hw/hfi1/ud.c
index 45bc3f04793e,2af993cbe5af..000000000000
--- a/drivers/infiniband/hw/hfi1/ud.c
+++ b/drivers/infiniband/hw/hfi1/ud.c
@@@ -364,14 -355,15 +364,22 @@@ int hfi1_make_ud_req(struct rvt_qp *qp
  	qp->s_sge.num_sge = wqe->wr.num_sge;
  	qp->s_sge.total_len = wqe->length;
  
 -	if (rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) {
 +	if (ah_attr->ah_flags & IB_AH_GRH) {
  		/* Header size in 32-bit words. */
++<<<<<<< HEAD
 +		qp->s_hdrwords += hfi1_make_grh(ibp,
 +						&ps->s_txreq->phdr.hdr.u.l.grh,
 +						&ah_attr->grh,
 +						qp->s_hdrwords, nwords);
++=======
+ 		qp->s_hdrwords +=
+ 			hfi1_make_grh(ibp,
+ 				      &ps->s_txreq->phdr.hdr.ibh.u.l.grh,
+ 				      rdma_ah_read_grh(ah_attr),
+ 				      qp->s_hdrwords, nwords);
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  		lrh0 = HFI1_LRH_GRH;
- 		ohdr = &ps->s_txreq->phdr.hdr.u.l.oth;
+ 		ohdr = &ps->s_txreq->phdr.hdr.ibh.u.l.oth;
  		/*
  		 * Don't worry about sending to locally attached multicast
  		 * QPs.  It is unspecified by the spec. what happens.
@@@ -401,19 -393,21 +409,35 @@@
  	ps->s_txreq->sde = priv->s_sde;
  	priv->s_sendcontext = qp_to_send_context(qp, priv->s_sc);
  	ps->s_txreq->psc = priv->s_sendcontext;
++<<<<<<< HEAD
 +	ps->s_txreq->phdr.hdr.lrh[0] = cpu_to_be16(lrh0);
 +	ps->s_txreq->phdr.hdr.lrh[1] = cpu_to_be16(ah_attr->dlid);
 +	ps->s_txreq->phdr.hdr.lrh[2] =
 +		cpu_to_be16(qp->s_hdrwords + nwords + SIZE_OF_CRC);
 +	if (ah_attr->dlid == be16_to_cpu(IB_LID_PERMISSIVE)) {
 +		ps->s_txreq->phdr.hdr.lrh[3] = IB_LID_PERMISSIVE;
 +	} else {
 +		lid = ppd->lid;
 +		if (lid) {
 +			lid |= ah_attr->src_path_bits & ((1 << ppd->lmc) - 1);
 +			ps->s_txreq->phdr.hdr.lrh[3] = cpu_to_be16(lid);
++=======
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[0] = cpu_to_be16(lrh0);
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[1] =
+ 		cpu_to_be16(rdma_ah_get_dlid(ah_attr));
+ 	ps->s_txreq->phdr.hdr.ibh.lrh[2] =
+ 		cpu_to_be16(qp->s_hdrwords + nwords + SIZE_OF_CRC);
+ 	if (rdma_ah_get_dlid(ah_attr) == be16_to_cpu(IB_LID_PERMISSIVE)) {
+ 		ps->s_txreq->phdr.hdr.ibh.lrh[3] = IB_LID_PERMISSIVE;
+ 	} else {
+ 		lid = ppd->lid;
+ 		if (lid) {
+ 			lid |= rdma_ah_get_path_bits(ah_attr) &
+ 				((1 << ppd->lmc) - 1);
+ 			ps->s_txreq->phdr.hdr.ibh.lrh[3] = cpu_to_be16(lid);
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  		} else {
- 			ps->s_txreq->phdr.hdr.lrh[3] = IB_LID_PERMISSIVE;
+ 			ps->s_txreq->phdr.hdr.ibh.lrh[3] = IB_LID_PERMISSIVE;
  		}
  	}
  	if (wqe->wr.send_flags & IB_SEND_SOLICITED)
diff --cc drivers/infiniband/hw/hfi1/verbs.h
index 76081f770f70,20224100cbc5..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.h
+++ b/drivers/infiniband/hw/hfi1/verbs.h
@@@ -104,6 -104,25 +104,28 @@@ enum 
  	HFI1_HAS_GRH = (1 << 0),
  };
  
++<<<<<<< HEAD
++=======
+ struct hfi1_16b_header {
+ 	u32 lrh[4];
+ 	union {
+ 		struct {
+ 			struct ib_grh grh;
+ 			struct ib_other_headers oth;
+ 		} l;
+ 		struct ib_other_headers oth;
+ 	} u;
+ } __packed;
+ 
+ struct hfi1_opa_header {
+ 	union {
+ 		struct ib_header ibh; /* 9B header */
+ 		struct hfi1_16b_header opah; /* 16B header */
+ 	};
+ 	u8 hdr_type; /* 9B or 16B */
+ } __packed;
+ 
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  struct hfi1_ahg_info {
  	u32 ahgdesc[2];
  	u16 tx_flags;
@@@ -336,21 -355,10 +358,25 @@@ int hfi1_check_send_wqe(struct rvt_qp *
  extern const u32 rc_only_opcode;
  extern const u32 uc_only_opcode;
  
++<<<<<<< HEAD
 +static inline u8 get_opcode(struct ib_header *h)
 +{
 +	u16 lnh = be16_to_cpu(h->lrh[0]) & 3;
 +
 +	if (lnh == IB_LNH_IBA_LOCAL)
 +		return be32_to_cpu(h->u.oth.bth[0]) >> 24;
 +	else
 +		return be32_to_cpu(h->u.l.oth.bth[0]) >> 24;
 +}
 +
 +int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct ib_header *hdr,
 +		       int has_grh, struct rvt_qp *qp, u32 bth0);
++=======
+ int hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct hfi1_packet *packet);
++>>>>>>> 30e07416cf48 (IB/hfi1: Add support to send 16B bypass packets)
  
  u32 hfi1_make_grh(struct hfi1_ibport *ibp, struct ib_grh *hdr,
 -		  const struct ib_global_route *grh, u32 hwords, u32 nwords);
 +		  struct ib_global_route *grh, u32 hwords, u32 nwords);
  
  void hfi1_make_ruc_header(struct rvt_qp *qp, struct ib_other_headers *ohdr,
  			  u32 bth0, u32 bth2, int middle,
* Unmerged path drivers/infiniband/hw/hfi1/rc.c
* Unmerged path drivers/infiniband/hw/hfi1/ruc.c
diff --git a/drivers/infiniband/hw/hfi1/trace_ibhdrs.h b/drivers/infiniband/hw/hfi1/trace_ibhdrs.h
index 0f2d2da057ec..73240255ffc5 100644
--- a/drivers/infiniband/hw/hfi1/trace_ibhdrs.h
+++ b/drivers/infiniband/hw/hfi1/trace_ibhdrs.h
@@ -213,9 +213,9 @@ DEFINE_EVENT(hfi1_input_ibhdr_template, input_ibhdr,
 
 DECLARE_EVENT_CLASS(hfi1_output_ibhdr_template,
 		    TP_PROTO(struct hfi1_devdata *dd,
-			     struct ib_header *hdr,
+			     struct hfi1_opa_header *opah,
 			     bool sc5),
-		    TP_ARGS(dd, hdr, sc5),
+		    TP_ARGS(dd, opah, sc5),
 		    TP_STRUCT__entry(
 			DD_DEV_ENTRY(dd)
 			__field(u8, lnh)
@@ -238,10 +238,11 @@ DECLARE_EVENT_CLASS(hfi1_output_ibhdr_template,
 			__field(u32, psn)
 			/* extended headers */
 			__dynamic_array(u8, ehdrs,
-					hfi1_trace_ib_hdr_len(hdr))
+					hfi1_trace_ib_hdr_len(&opah->ibh))
 			),
 		    TP_fast_assign(
 			struct ib_other_headers *ohdr;
+			struct ib_header *hdr = &opah->ibh;
 
 			DD_DEV_ASSIGN(dd);
 
@@ -294,18 +295,18 @@ DECLARE_EVENT_CLASS(hfi1_output_ibhdr_template,
 
 DEFINE_EVENT(hfi1_output_ibhdr_template, pio_output_ibhdr,
 	     TP_PROTO(struct hfi1_devdata *dd,
-		      struct ib_header *hdr, bool sc5),
-	     TP_ARGS(dd, hdr, sc5));
+		      struct hfi1_opa_header *opah, bool sc5),
+	     TP_ARGS(dd, opah, sc5));
 
 DEFINE_EVENT(hfi1_output_ibhdr_template, ack_output_ibhdr,
 	     TP_PROTO(struct hfi1_devdata *dd,
-		      struct ib_header *hdr, bool sc5),
-	     TP_ARGS(dd, hdr, sc5));
+		      struct hfi1_opa_header *opah, bool sc5),
+	     TP_ARGS(dd, opah, sc5));
 
 DEFINE_EVENT(hfi1_output_ibhdr_template, sdma_output_ibhdr,
 	     TP_PROTO(struct hfi1_devdata *dd,
-		      struct ib_header *hdr, bool sc5),
-	     TP_ARGS(dd, hdr, sc5));
+		      struct hfi1_opa_header *opah, bool sc5),
+	     TP_ARGS(dd, opah, sc5));
 
 
 #endif /* __HFI1_TRACE_IBHDRS_H */
* Unmerged path drivers/infiniband/hw/hfi1/uc.c
* Unmerged path drivers/infiniband/hw/hfi1/ud.c
diff --git a/drivers/infiniband/hw/hfi1/verbs.c b/drivers/infiniband/hw/hfi1/verbs.c
index 06ac08cf82a6..8da893bc9223 100644
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@ -505,6 +505,24 @@ again:
 	}
 }
 
+static u8 get_opcode(struct hfi1_opa_header *hdr)
+{
+	struct ib_other_headers *ohdr;
+
+	if (hdr->hdr_type) {
+		if (hfi1_16B_get_l4(&hdr->opah) == OPA_16B_L4_IB_LOCAL)
+			ohdr = &hdr->opah.u.oth;
+		else
+			ohdr = &hdr->opah.u.l.oth;
+	} else {
+		if (ib_get_lnh(&hdr->ibh) == HFI1_LRH_BTH)
+			ohdr = &hdr->ibh.u.oth;
+		else
+			ohdr = &hdr->ibh.u.l.oth;
+	}
+	return ib_bth_get_opcode(ohdr);
+}
+
 /*
  * Make sure the QP is ready and able to accept the given opcode.
  */
@@ -695,7 +713,7 @@ static void verbs_sdma_complete(
 	if (tx->wqe) {
 		hfi1_send_complete(qp, tx->wqe, IB_WC_SUCCESS);
 	} else if (qp->ibqp.qp_type == IB_QPT_RC) {
-		struct ib_header *hdr;
+		struct hfi1_opa_header *hdr;
 
 		hdr = &tx->phdr.hdr;
 		hfi1_rc_send_complete(qp, hdr);
@@ -1182,7 +1200,7 @@ static inline send_routine get_send_routine(struct rvt_qp *qp,
 {
 	struct hfi1_devdata *dd = dd_from_ibdev(qp->ibqp.device);
 	struct hfi1_qp_priv *priv = qp->priv;
-	struct ib_header *h = &tx->phdr.hdr;
+	struct hfi1_opa_header *h = &tx->phdr.hdr;
 
 	if (unlikely(!(dd->flags & HFI1_HAS_SEND_DMA)))
 		return dd->process_pio_send;
@@ -1228,7 +1246,7 @@ int hfi1_verbs_send(struct rvt_qp *qp, struct hfi1_pkt_state *ps)
 	int ret;
 	u8 lnh;
 
-	hdr = &ps->s_txreq->phdr.hdr;
+	hdr = &ps->s_txreq->phdr.hdr.ibh;
 	/* locate the pkey within the headers */
 	lnh = ib_get_lnh(hdr);
 	if (lnh == HFI1_LRH_GRH)
* Unmerged path drivers/infiniband/hw/hfi1/verbs.h
