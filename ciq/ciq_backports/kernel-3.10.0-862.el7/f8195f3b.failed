IB/hfi1: Eliminate allocation while atomic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit f8195f3b14a046ae33d9c369ffb59b4192f29e08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f8195f3b.failed

The PIO trailing buffer was being dynamically allocated
but the kcalloc return value was not being checked. Further,
the GFP_KERNEL was being used even though the send engine
might be called with interrupts disabled.

Since the maximum size of the trailing buffer is only 12
bytes (CRC = 4, LT = 1, Pad = 0 to 7 bytes) just statically
allocate the buffer, remove the alloc entirely and share it
with the SDMA engine by making it global.

	Reported-by: Leon Romanovsky <leon@kernel.org>
Fixes: 566d53a82644 ("IB/hfi1: Enhance PIO/SDMA send for 16B")
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Reviewed-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit f8195f3b14a046ae33d9c369ffb59b4192f29e08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/common.h
#	drivers/infiniband/hw/hfi1/verbs.c
diff --cc drivers/infiniband/hw/hfi1/common.h
index 995d62c7f9a7,7108d4d92259..000000000000
--- a/drivers/infiniband/hw/hfi1/common.h
+++ b/drivers/infiniband/hw/hfi1/common.h
@@@ -325,7 -325,10 +325,12 @@@ struct diag_pkt 
  #define HFI1_LRH_BTH 0x0002      /* 1. word of IB LRH - next header: BTH */
  
  /* misc. */
 -#define SC15_PACKET 0xF
  #define SIZE_OF_CRC 1
++<<<<<<< HEAD
++=======
+ #define SIZE_OF_LT 1
+ #define MAX_16B_PADDING 12 /* CRC = 4, LT = 1, Pad = 0 to 7 bytes */
++>>>>>>> f8195f3b14a0 (IB/hfi1: Eliminate allocation while atomic)
  
  #define LIM_MGMT_P_KEY       0x7FFF
  #define FULL_MGMT_P_KEY      0xFFFF
diff --cc drivers/infiniband/hw/hfi1/verbs.c
index 5f39e874b55f,726c064b22d8..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@@ -798,7 -815,20 +801,12 @@@ static int build_verbs_tx_desc
  	int ret = 0;
  	struct hfi1_sdma_header *phdr = &tx->phdr;
  	u16 hdrbytes = tx->hdr_dwords << 2;
++<<<<<<< HEAD
++=======
+ 	u32 *hdr;
+ 	u8 extra_bytes = 0;
++>>>>>>> f8195f3b14a0 (IB/hfi1: Eliminate allocation while atomic)
  
 -	if (tx->phdr.hdr.hdr_type) {
 -		/*
 -		 * hdrbytes accounts for PBC. Need to subtract 8 bytes
 -		 * before calculating padding.
 -		 */
 -		extra_bytes = hfi1_get_16b_padding(hdrbytes - 8, length) +
 -			      (SIZE_OF_CRC << 2) + SIZE_OF_LT;
 -		hdr = (u32 *)&phdr->hdr.opah;
 -	} else {
 -		hdr = (u32 *)&phdr->hdr.ibh;
 -	}
  	if (!ahg_info->ahgcount) {
  		ret = sdma_txinit_ahg(
  			&tx->txreq,
@@@ -833,8 -864,17 +841,20 @@@
  			goto bail_txadd;
  	}
  	/* add the ulp payload - if any. tx->ss can be NULL for acks */
 -	if (tx->ss) {
 +	if (tx->ss)
  		ret = build_verbs_ulp_payload(sde, length, tx);
++<<<<<<< HEAD
++=======
+ 		if (ret)
+ 			goto bail_txadd;
+ 	}
+ 
+ 	/* add icrc, lt byte, and padding to flit */
+ 	if (extra_bytes)
+ 		ret = sdma_txadd_kvaddr(sde->dd, &tx->txreq,
+ 					(void *)trail_buf, extra_bytes);
+ 
++>>>>>>> f8195f3b14a0 (IB/hfi1: Eliminate allocation while atomic)
  bail_txadd:
  	return ret;
  }
@@@ -1052,8 -1129,12 +1072,16 @@@ int hfi1_verbs_send_pio(struct rvt_qp *
  				seg_pio_copy_mid(pbuf, addr, slen);
  				len -= slen;
  			}
 +			seg_pio_copy_end(pbuf);
  		}
++<<<<<<< HEAD
++=======
+ 		/* add icrc, lt byte, and padding to flit */
+ 		if (extra_bytes)
+ 			seg_pio_copy_mid(pbuf, trail_buf, extra_bytes);
+ 
+ 		seg_pio_copy_end(pbuf);
++>>>>>>> f8195f3b14a0 (IB/hfi1: Eliminate allocation while atomic)
  	}
  
  	trace_pio_output_ibhdr(dd_from_ibdev(qp->ibqp.device),
* Unmerged path drivers/infiniband/hw/hfi1/common.h
* Unmerged path drivers/infiniband/hw/hfi1/verbs.c
