i40e: Fix memory leak related filter programming status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 2b9478ffc550f17c6cd8c69057234e91150f5972
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2b9478ff.failed

It looks like we weren't correctly placing the pages from buffers that had
been used to return a filter programming status back on the ring. As a
result they were being overwritten and tracking of the pages was lost.

This change works to correct that by incorporating part of
i40e_put_rx_buffer into the programming status handler code. As a result we
should now be correctly placing the pages for those buffers on the
re-allocation list instead of letting them stay in place.

Fixes: 0e626ff7ccbf ("i40e: Fix support for flow director programming status")
	Reported-by: Anders K. Pedersen <akp@cohaesio.com>
	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Anders K Pedersen <akp@cohaesio.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 2b9478ffc550f17c6cd8c69057234e91150f5972)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 6e79fcc2d6ed,2756131495f0..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -1033,8 -1034,52 +1033,54 @@@ static bool i40e_set_new_dynamic_itr(st
  		rc->itr = new_itr;
  		return true;
  	}
 -	return false;
 -}
  
++<<<<<<< HEAD
 +	return false;
++=======
+ /**
+  * i40e_reuse_rx_page - page flip buffer and store it back on the ring
+  * @rx_ring: rx descriptor ring to store buffers on
+  * @old_buff: donor buffer to have page reused
+  *
+  * Synchronizes page for reuse by the adapter
+  **/
+ static void i40e_reuse_rx_page(struct i40e_ring *rx_ring,
+ 			       struct i40e_rx_buffer *old_buff)
+ {
+ 	struct i40e_rx_buffer *new_buff;
+ 	u16 nta = rx_ring->next_to_alloc;
+ 
+ 	new_buff = &rx_ring->rx_bi[nta];
+ 
+ 	/* update, and store next to alloc */
+ 	nta++;
+ 	rx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;
+ 
+ 	/* transfer page from old buffer to new buffer */
+ 	new_buff->dma		= old_buff->dma;
+ 	new_buff->page		= old_buff->page;
+ 	new_buff->page_offset	= old_buff->page_offset;
+ 	new_buff->pagecnt_bias	= old_buff->pagecnt_bias;
+ }
+ 
+ /**
+  * i40e_rx_is_programming_status - check for programming status descriptor
+  * @qw: qword representing status_error_len in CPU ordering
+  *
+  * The value of in the descriptor length field indicate if this
+  * is a programming status descriptor for flow director or FCoE
+  * by the value of I40E_RX_PROG_STATUS_DESC_LENGTH, otherwise
+  * it is a packet descriptor.
+  **/
+ static inline bool i40e_rx_is_programming_status(u64 qw)
+ {
+ 	/* The Rx filter programming status and SPH bit occupy the same
+ 	 * spot in the descriptor. Since we don't support packet split we
+ 	 * can just reuse the bit as an indication that this is a
+ 	 * programming status descriptor.
+ 	 */
+ 	return qw & I40E_RXD_QW1_LENGTH_SPH_MASK;
++>>>>>>> 2b9478ffc550 (i40e: Fix memory leak related filter programming status)
  }
  
  /**
@@@ -1048,12 -1094,27 +1094,33 @@@
   *
   **/
  static void i40e_clean_programming_status(struct i40e_ring *rx_ring,
 -					  union i40e_rx_desc *rx_desc,
 -					  u64 qw)
 +					  union i40e_rx_desc *rx_desc)
  {
++<<<<<<< HEAD
 +	u64 qw;
 +	u8 id;
 +
 +	qw = le64_to_cpu(rx_desc->wb.qword1.status_error_len);
++=======
+ 	struct i40e_rx_buffer *rx_buffer;
+ 	u32 ntc = rx_ring->next_to_clean;
+ 	u8 id;
+ 
+ 	/* fetch, update, and store next to clean */
+ 	rx_buffer = &rx_ring->rx_bi[ntc++];
+ 	ntc = (ntc < rx_ring->count) ? ntc : 0;
+ 	rx_ring->next_to_clean = ntc;
+ 
+ 	prefetch(I40E_RX_DESC(rx_ring, ntc));
+ 
+ 	/* place unused page back on the ring */
+ 	i40e_reuse_rx_page(rx_ring, rx_buffer);
+ 	rx_ring->rx_stats.page_reuse_count++;
+ 
+ 	/* clear contents of buffer_info */
+ 	rx_buffer->page = NULL;
+ 
++>>>>>>> 2b9478ffc550 (i40e: Fix memory leak related filter programming status)
  	id = (qw & I40E_RX_PROG_STATUS_DESC_QW1_PROGID_MASK) >>
  		  I40E_RX_PROG_STATUS_DESC_QW1_PROGID_SHIFT;
  
@@@ -1563,29 -1674,6 +1630,32 @@@ static bool i40e_cleanup_headers(struc
  }
  
  /**
++<<<<<<< HEAD
 + * i40e_reuse_rx_page - page flip buffer and store it back on the ring
 + * @rx_ring: rx descriptor ring to store buffers on
 + * @old_buff: donor buffer to have page reused
 + *
 + * Synchronizes page for reuse by the adapter
 + **/
 +static void i40e_reuse_rx_page(struct i40e_ring *rx_ring,
 +			       struct i40e_rx_buffer *old_buff)
 +{
 +	struct i40e_rx_buffer *new_buff;
 +	u16 nta = rx_ring->next_to_alloc;
 +
 +	new_buff = &rx_ring->rx_bi[nta];
 +
 +	/* update, and store next to alloc */
 +	nta++;
 +	rx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;
 +
 +	/* transfer page from old buffer to new buffer */
 +	*new_buff = *old_buff;
 +}
 +
 +/**
++=======
++>>>>>>> 2b9478ffc550 (i40e: Fix memory leak related filter programming status)
   * i40e_page_is_reusable - check if any reuse is possible
   * @page: page struct to check
   *
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
