net/mlx5: Fix health work queue spin lock to IRQ safe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Fix health work queue spin lock to IRQ safe (Kamal Heib) [1456694]
Rebuild_FUZZ: 96.08%
commit-author Moshe Shemesh <moshe@mellanox.com>
commit 6377ed0bbae6fa28853e1679d068a9106c8a8908
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6377ed0b.failed

spin_lock/unlock of health->wq_lock should be IRQ safe.
It was changed to spin_lock_irqsave since adding commit 0179720d6be2
("net/mlx5: Introduce trigger_health_work function") which uses
spin_lock from asynchronous event (IRQ) context.
Thus, all spin_lock/unlock of health->wq_lock should have been moved
to IRQ safe mode.
However, one occurrence on new code using this lock missed that
change, resulting in possible deadlock:
  kernel: Possible unsafe locking scenario:
  kernel:       CPU0
  kernel:       ----
  kernel:  lock(&(&health->wq_lock)->rlock);
  kernel:  <Interrupt>
  kernel:    lock(&(&health->wq_lock)->rlock);
  kernel: #012 *** DEADLOCK ***

Fixes: 2a0165a034ac ("net/mlx5: Cancel delayed recovery work when unloading the driver")
	Signed-off-by: Moshe Shemesh <moshe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6377ed0bbae6fa28853e1679d068a9106c8a8908)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index c6679b21884e,db86e1506c8b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -350,6 -353,17 +350,20 @@@ void mlx5_drain_health_wq(struct mlx5_c
  	cancel_work_sync(&health->work);
  }
  
++<<<<<<< HEAD
++=======
+ void mlx5_drain_health_recovery(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_core_health *health = &dev->priv.health;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&health->wq_lock, flags);
+ 	set_bit(MLX5_DROP_NEW_RECOVERY_WORK, &health->flags);
+ 	spin_unlock_irqrestore(&health->wq_lock, flags);
+ 	cancel_delayed_work_sync(&dev->priv.health.recover_work);
+ }
+ 
++>>>>>>> 6377ed0bbae6 (net/mlx5: Fix health work queue spin lock to IRQ safe)
  void mlx5_health_cleanup(struct mlx5_core_dev *dev)
  {
  	struct mlx5_core_health *health = &dev->priv.health;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
