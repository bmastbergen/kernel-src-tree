scsi: qla2xxx: Ability to process multiple SGEs in Command SGL for CT passthrough commands.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Ability to process multiple SGEs in Command SGL for CT passthrough commands (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 96.00%
commit-author Giridhar Malavali <giridhar.malavali@cavium.com>
commit ce0779c7d72c42b5a625850086b60ec3ddbad17e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ce0779c7.failed

	Signed-off-by: Giridhar Malavali <giridhar.malavali@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ce0779c7d72c42b5a625850086b60ec3ddbad17e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_iocb.c
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index ff2ecaf39d3d,2f94159186d7..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2435,12 -2682,12 +2435,20 @@@ qla24xx_ct_iocb(srb_t *sp, struct ct_en
  	uint32_t        *cur_dsd;
  	struct scatterlist *sg;
  	int index;
++<<<<<<< HEAD
 +	uint16_t tot_dsds;
 +        scsi_qla_host_t *vha = sp->fcport->vha;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
 +	int loop_iterartion = 0;
++=======
+ 	uint16_t cmd_dsds, rsp_dsds;
+ 	scsi_qla_host_t *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct bsg_job *bsg_job = sp->u.bsg_job;
++>>>>>>> ce0779c7d72c (scsi: qla2xxx: Ability to process multiple SGEs in Command SGL for CT passthrough commands.)
  	int entry_count = 1;
+ 	cont_a64_entry_t *cont_pkt = NULL;
  
  	ct_iocb->entry_type = CT_IOCB_TYPE;
          ct_iocb->entry_status = 0;
@@@ -2448,33 -2695,49 +2456,49 @@@
          ct_iocb->handle = sp->handle;
  
  	ct_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);
 -	ct_iocb->vp_index = sp->vha->vp_idx;
 +	ct_iocb->vp_index = sp->fcport->vha->vp_idx;
  	ct_iocb->comp_status = cpu_to_le16(0);
  
- 	ct_iocb->cmd_dsd_count =
- 		cpu_to_le16(bsg_job->request_payload.sg_cnt);
+ 	cmd_dsds = bsg_job->request_payload.sg_cnt;
+ 	rsp_dsds = bsg_job->reply_payload.sg_cnt;
+ 
+ 	ct_iocb->cmd_dsd_count = cpu_to_le16(cmd_dsds);
          ct_iocb->timeout = 0;
-         ct_iocb->rsp_dsd_count =
- 		cpu_to_le16(bsg_job->reply_payload.sg_cnt);
-         ct_iocb->rsp_byte_count =
-             cpu_to_le32(bsg_job->reply_payload.payload_len);
+ 	ct_iocb->rsp_dsd_count = cpu_to_le16(rsp_dsds);
          ct_iocb->cmd_byte_count =
              cpu_to_le32(bsg_job->request_payload.payload_len);
-         ct_iocb->dseg_0_address[0] = cpu_to_le32(LSD(sg_dma_address
-             (bsg_job->request_payload.sg_list)));
-         ct_iocb->dseg_0_address[1] = cpu_to_le32(MSD(sg_dma_address
-            (bsg_job->request_payload.sg_list)));
-         ct_iocb->dseg_0_len = cpu_to_le32(sg_dma_len
-             (bsg_job->request_payload.sg_list));
  
- 	avail_dsds = 1;
- 	cur_dsd = (uint32_t *)ct_iocb->dseg_1_address;
+ 	avail_dsds = 2;
+ 	cur_dsd = (uint32_t *)ct_iocb->dseg_0_address;
  	index = 0;
- 	tot_dsds = bsg_job->reply_payload.sg_cnt;
  
- 	for_each_sg(bsg_job->reply_payload.sg_list, sg, tot_dsds, index) {
+ 	for_each_sg(bsg_job->request_payload.sg_list, sg, cmd_dsds, index) {
+ 		dma_addr_t       sle_dma;
+ 
+ 		/* Allocate additional continuation packets? */
+ 		if (avail_dsds == 0) {
+ 			/*
+ 			 * Five DSDs are available in the Cont.
+ 			 * Type 1 IOCB.
+ 			 */
+ 			cont_pkt = qla2x00_prep_cont_type1_iocb(
+ 			    vha, ha->req_q_map[0]);
+ 			cur_dsd = (uint32_t *) cont_pkt->dseg_0_address;
+ 			avail_dsds = 5;
+ 			entry_count++;
+ 		}
+ 
+ 		sle_dma = sg_dma_address(sg);
+ 		*cur_dsd++   = cpu_to_le32(LSD(sle_dma));
+ 		*cur_dsd++   = cpu_to_le32(MSD(sle_dma));
+ 		*cur_dsd++   = cpu_to_le32(sg_dma_len(sg));
+ 		avail_dsds--;
+ 	}
+ 
+ 	index = 0;
+ 
+ 	for_each_sg(bsg_job->reply_payload.sg_list, sg, rsp_dsds, index) {
  		dma_addr_t       sle_dma;
- 		cont_a64_entry_t *cont_pkt;
  
  		/* Allocate additional continuation packets? */
  		if (avail_dsds == 0) {
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
