i40e: avoid permanent lock of *_PTP_TX_IN_PROGRESS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 69077577af5054da8c8adfb6c1ebb565c2f1f158
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/69077577.failed

The i40e driver uses a bit lock to indicate when a Tx timestamp is in
progress to avoid attempting to timestamp multiple packets at once. This
is required because hardware only has registers to handle one request at
a time.

There is a corner case where we failed to cleanup the bit lock after
a failed transmit. This can potentially result in a state bit being
locked forever.

Add some cleanup code to i40e_xmit_frame_ring to check and make sure we
cleanup incase of these failures. We also modify i40e_tx_map to return
an error code indication DMA failure.

	Reported-by: Reported-by: David Mirabito <davidm@metamako.com>
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 69077577af5054da8c8adfb6c1ebb565c2f1f158)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 4656a603459e,19984be0f70c..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2819,16 -2932,12 +2819,24 @@@ bool __i40e_chk_linearize(struct sk_buf
   * @hdr_len:  size of the packet header
   * @td_cmd:   the command field in the descriptor
   * @td_offset: offset for checksum or crc
+  *
+  * Returns 0 on success, -1 on failure to DMA
   **/
++<<<<<<< HEAD
 +#ifdef I40E_FCOE
 +inline void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
 +			struct i40e_tx_buffer *first, u32 tx_flags,
 +			const u8 hdr_len, u32 td_cmd, u32 td_offset)
 +#else
 +static inline void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
 +			       struct i40e_tx_buffer *first, u32 tx_flags,
 +			       const u8 hdr_len, u32 td_cmd, u32 td_offset)
 +#endif
++=======
+ static inline int i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
+ 			      struct i40e_tx_buffer *first, u32 tx_flags,
+ 			      const u8 hdr_len, u32 td_cmd, u32 td_offset)
++>>>>>>> 69077577af50 (i40e: avoid permanent lock of *_PTP_TX_IN_PROGRESS)
  {
  	unsigned int data_len = skb->data_len;
  	unsigned int size = skb_headlen(skb);
@@@ -3107,8 -3221,18 +3118,17 @@@ static netdev_tx_t i40e_xmit_frame_ring
  	return NETDEV_TX_OK;
  
  out_drop:
 -	i40e_trace(xmit_frame_ring_drop, first->skb, tx_ring);
  	dev_kfree_skb_any(first->skb);
  	first->skb = NULL;
+ cleanup_tx_tstamp:
+ 	if (unlikely(tx_flags & I40E_TX_FLAGS_TSYN)) {
+ 		struct i40e_pf *pf = i40e_netdev_to_pf(tx_ring->netdev);
+ 
+ 		dev_kfree_skb_any(pf->ptp_tx_skb);
+ 		pf->ptp_tx_skb = NULL;
+ 		clear_bit_unlock(__I40E_PTP_TX_IN_PROGRESS, pf->state);
+ 	}
+ 
  	return NETDEV_TX_OK;
  }
  
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
