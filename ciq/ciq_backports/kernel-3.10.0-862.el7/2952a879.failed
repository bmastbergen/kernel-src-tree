nvme-fc: stop queues on error detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: stop queues on error detection (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 93.15%
commit-author James Smart <jsmart2021@gmail.com>
commit 2952a879bacbfae8b03fd886754e64fe14b8041e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2952a879.failed

Per the recommendation by Sagi on:
http://lists.infradead.org/pipermail/linux-nvme/2017-April/009261.html

Rather than waiting for reset work thread to stop queues and abort the ios,
immediately stop the queues on error detection. Reset thread will restop
the queues (as it's called on other paths), but it does not appear to have
a side effect.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 2952a879bacbfae8b03fd886754e64fe14b8041e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index a2d701be7e74,dca7165fabcf..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1604,27 -1745,33 +1604,39 @@@ nvme_fc_free_nvme_ctrl(struct nvme_ctr
  	nvme_fc_ctrl_put(ctrl);
  }
  
 -static void
 -nvme_fc_error_recovery(struct nvme_fc_ctrl *ctrl, char *errmsg)
 +
++<<<<<<< HEAD
 +static int
 +__nvme_fc_abort_op(struct nvme_fc_ctrl *ctrl, struct nvme_fc_fcp_op *op)
  {
 -	dev_warn(ctrl->ctrl.device,
 -		"NVME-FC{%d}: transport association error detected: %s\n",
 -		ctrl->cnum, errmsg);
 -	dev_info(ctrl->ctrl.device,
 -		"NVME-FC{%d}: resetting controller\n", ctrl->cnum);
 +	int state;
  
 +	state = atomic_xchg(&op->state, FCPOP_STATE_ABORTED);
 +	if (state != FCPOP_STATE_ACTIVE) {
 +		atomic_set(&op->state, state);
 +		return -ECANCELED; /* fail */
++=======
+ 	/* stop the queues on error, cleanup is in reset thread */
+ 	if (ctrl->queue_count > 1)
+ 		nvme_stop_queues(&ctrl->ctrl);
+ 
+ 	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_RECONNECTING)) {
+ 		dev_err(ctrl->ctrl.device,
+ 			"NVME-FC{%d}: error_recovery: Couldn't change state "
+ 			"to RECONNECTING\n", ctrl->cnum);
+ 		return;
++>>>>>>> 2952a879bacb (nvme-fc: stop queues on error detection)
  	}
  
 -	if (!queue_work(nvme_fc_wq, &ctrl->reset_work))
 -		dev_err(ctrl->ctrl.device,
 -			"NVME-FC{%d}: error_recovery: Failed to schedule "
 -			"reset work\n", ctrl->cnum);
 +	ctrl->lport->ops->fcp_abort(&ctrl->lport->localport,
 +					&ctrl->rport->remoteport,
 +					op->queue->lldd_handle,
 +					&op->fcp_req);
 +
 +	return 0;
  }
  
 -static enum blk_eh_timer_return
 +enum blk_eh_timer_return
  nvme_fc_timeout(struct request *rq, bool reserved)
  {
  	struct nvme_fc_fcp_op *op = blk_mq_rq_to_pdu(rq);
* Unmerged path drivers/nvme/host/fc.c
