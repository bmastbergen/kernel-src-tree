dax: support for transparent PUD pages for device DAX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [dax] Support for transparent PUD pages for device DAX (Larry Woodman) [1457572 1457561]
Rebuild_FUZZ: 95.05%
commit-author Dave Jiang <dave.jiang@intel.com>
commit 9557feee39b75ceb502b4777e08706df1ddf10ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9557feee.failed

Add transparent huge PUD pages support for device DAX by adding a
pud_fault handler.

Link: http://lkml.kernel.org/r/148545060002.17912.6765687780007547551.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Cc: Matthew Wilcox <mawilcox@microsoft.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Jan Kara <jack@suse.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Nilesh Choudhury <nilesh.choudhury@oracle.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9557feee39b75ceb502b4777e08706df1ddf10ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/dax.c
diff --cc drivers/dax/dax.c
index 85c0bc93f989,b90bb301bda0..000000000000
--- a/drivers/dax/dax.c
+++ b/drivers/dax/dax.c
@@@ -533,23 -489,80 +533,88 @@@ static int __dax_dev_pmd_fault(struct d
  
  	pfn = phys_to_pfn_t(phys, dax_region->pfn_flags);
  
 -	return vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd, pfn,
 -			vmf->flags & FAULT_FLAG_WRITE);
 +	return vmf_insert_pfn_pmd(vma, addr, pmd, pfn,
 +			flags & FAULT_FLAG_WRITE);
  }
  
++<<<<<<< HEAD
 +static int dax_dev_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
 +		pmd_t *pmd, unsigned int flags)
++=======
+ #ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+ static int __dax_dev_pud_fault(struct dax_dev *dax_dev, struct vm_fault *vmf)
+ {
+ 	unsigned long pud_addr = vmf->address & PUD_MASK;
+ 	struct device *dev = &dax_dev->dev;
+ 	struct dax_region *dax_region;
+ 	phys_addr_t phys;
+ 	pgoff_t pgoff;
+ 	pfn_t pfn;
+ 
+ 	if (check_vma(dax_dev, vmf->vma, __func__))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	dax_region = dax_dev->region;
+ 	if (dax_region->align > PUD_SIZE) {
+ 		dev_dbg(dev, "%s: alignment > fault size\n", __func__);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	/* dax pud mappings require pfn_t_devmap() */
+ 	if ((dax_region->pfn_flags & (PFN_DEV|PFN_MAP)) != (PFN_DEV|PFN_MAP)) {
+ 		dev_dbg(dev, "%s: alignment > fault size\n", __func__);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	pgoff = linear_page_index(vmf->vma, pud_addr);
+ 	phys = pgoff_to_phys(dax_dev, pgoff, PUD_SIZE);
+ 	if (phys == -1) {
+ 		dev_dbg(dev, "%s: phys_to_pgoff(%#lx) failed\n", __func__,
+ 				pgoff);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	pfn = phys_to_pfn_t(phys, dax_region->pfn_flags);
+ 
+ 	return vmf_insert_pfn_pud(vmf->vma, vmf->address, vmf->pud, pfn,
+ 			vmf->flags & FAULT_FLAG_WRITE);
+ }
+ #else
+ static int __dax_dev_pud_fault(struct dax_dev *dax_dev, struct vm_fault *vmf)
+ {
+ 	return VM_FAULT_FALLBACK;
+ }
+ #endif /* !CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
+ 
+ static int dax_dev_fault(struct vm_fault *vmf)
++>>>>>>> 9557feee39b7 (dax: support for transparent PUD pages for device DAX)
  {
  	int rc;
 -	struct file *filp = vmf->vma->vm_file;
 +	struct file *filp = vma->vm_file;
  	struct dax_dev *dax_dev = filp->private_data;
  
  	dev_dbg(&dax_dev->dev, "%s: %s: %s (%#lx - %#lx)\n", __func__,
 -			current->comm, (vmf->flags & FAULT_FLAG_WRITE)
 -			? "write" : "read",
 -			vmf->vma->vm_start, vmf->vma->vm_end);
 +			current->comm, (flags & FAULT_FLAG_WRITE)
 +			? "write" : "read", vma->vm_start, vma->vm_end);
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	rc = __dax_dev_pmd_fault(dax_dev, vma, addr, pmd, flags);
++=======
+ 	switch (vmf->flags & FAULT_FLAG_SIZE_MASK) {
+ 	case FAULT_FLAG_SIZE_PTE:
+ 		rc = __dax_dev_pte_fault(dax_dev, vmf);
+ 		break;
+ 	case FAULT_FLAG_SIZE_PMD:
+ 		rc = __dax_dev_pmd_fault(dax_dev, vmf);
+ 		break;
+ 	case FAULT_FLAG_SIZE_PUD:
+ 		rc = __dax_dev_pud_fault(dax_dev, vmf);
+ 		break;
+ 	default:
+ 		return VM_FAULT_FALLBACK;
+ 	}
++>>>>>>> 9557feee39b7 (dax: support for transparent PUD pages for device DAX)
  	rcu_read_unlock();
  
  	return rc;
* Unmerged path drivers/dax/dax.c
