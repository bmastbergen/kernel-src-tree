sysctl: allow for strict write position handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kees Cook <keescook@chromium.org>
commit f4aacea2f5d1a5f7e3154e967d70cf3f711bcd61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f4aacea2.failed

When writing to a sysctl string, each write, regardless of VFS position,
begins writing the string from the start.  This means the contents of
the last write to the sysctl controls the string contents instead of the
first:

  open("/proc/sys/kernel/modprobe", O_WRONLY)   = 1
  write(1, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"..., 4096) = 4096
  write(1, "/bin/true", 9)                = 9
  close(1)                                = 0

  $ cat /proc/sys/kernel/modprobe
  /bin/true

Expected behaviour would be to have the sysctl be "AAAA..." capped at
maxlen (in this case KMOD_PATH_LEN: 256), instead of truncating to the
contents of the second write.  Similarly, multiple short writes would
not append to the sysctl.

The old behavior is unlike regular POSIX files enough that doing audits
of software that interact with sysctls can end up in unexpected or
dangerous situations.  For example, "as long as the input starts with a
trusted path" turns out to be an insufficient filter, as what must also
happen is for the input to be entirely contained in a single write
syscall -- not a common consideration, especially for high level tools.

This provides kernel.sysctl_writes_strict as a way to make this behavior
act in a less surprising manner for strings, and disallows non-zero file
position when writing numeric sysctls (similar to what is already done
when reading from non-zero file positions).  For now, the default (0) is
to warn about non-zero file position use, but retain the legacy
behavior.  Setting this to -1 disables the warning, and setting this to
1 enables the file position respecting behavior.

[akpm@linux-foundation.org: fix build]
[akpm@linux-foundation.org: move misplaced hunk, per Randy]
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f4aacea2f5d1a5f7e3154e967d70cf3f711bcd61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/sysctl/kernel.txt
diff --cc Documentation/sysctl/kernel.txt
index 50713c8133e8,708bb7f1b7e0..000000000000
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@@ -80,11 -75,9 +80,12 @@@ show up in /proc/sys/kernel
  - shmall
  - shmmax                      [ sysv ipc ]
  - shmmni
 +- softlockup_all_cpu_backtrace
 +- softlockup_thresh
 +- soft_watchdog
  - stop-a                      [ SPARC only ]
  - sysrq                       ==> Documentation/sysrq.txt
+ - sysctl_writes_strict
  - tainted
  - threads-max
  - unknown_nmi_panic
@@@ -835,44 -763,23 +836,64 @@@ without users and with a dead originati
  
  ==============================================================
  
++<<<<<<< HEAD
 +softlockup_thresh:
 +
 +This value can be used to lower the softlockup tolerance threshold.  The
 +default threshold is 60 seconds.  If a cpu is locked up for 60 seconds,
 +the kernel complains.  Valid values are 1-60 seconds.  Setting this
 +tunable to zero will disable the softlockup detection altogether.
 +
 +==============================================================
 +
 +softlockup_all_cpu_backtrace:
 +
 +This value controls the soft lockup detector thread's behavior
 +when a soft lockup condition is detected as to whether or not
 +to gather further debug information. If enabled, each cpu will
 +be issued an NMI and instructed to capture stack trace.
 +
 +This feature is only applicable for architectures which support
 +NMI.
 +
 +0: do nothing. This is the default behavior.
 +
 +1: on detection capture more debug information.
 +
 +==============================================================
 +
 +soft_watchdog
 +
 +This parameter can be used to control the soft lockup detector.
 +
 +   0 - disable the soft lockup detector
 +   1 - enable the soft lockup detector
 +
 +The soft lockup detector monitors CPUs for threads that are hogging the CPUs
 +without rescheduling voluntarily, and thus prevent the 'watchdog/N' threads
 +from running. The mechanism depends on the CPUs ability to respond to timer
 +interrupts which are needed for the 'watchdog/N' threads to be woken up by
 +the watchdog timer function, otherwise the NMI watchdog - if enabled - can
 +detect a hard lockup condition.
++=======
+ sysctl_writes_strict:
+ 
+ Control how file position affects the behavior of updating sysctl values
+ via the /proc/sys interface:
+ 
+   -1 - Legacy per-write sysctl value handling, with no printk warnings.
+        Each write syscall must fully contain the sysctl value to be
+        written, and multiple writes on the same sysctl file descriptor
+        will rewrite the sysctl value, regardless of file position.
+    0 - (default) Same behavior as above, but warn about processes that
+        perform writes to a sysctl file descriptor when the file position
+        is not 0.
+    1 - Respect file position when writing sysctl strings. Multiple writes
+        will append to the sysctl value buffer. Anything past the max length
+        of the sysctl value buffer will be ignored. Writes to numeric sysctl
+        entries must always be at file position 0 and the value must be
+        fully contained in the buffer sent in the write syscall.
++>>>>>>> f4aacea2f5d1 (sysctl: allow for strict write position handling)
  
  ==============================================================
  
* Unmerged path Documentation/sysctl/kernel.txt
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 7842d59f10b8..03d348daa26f 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -172,6 +172,13 @@ extern int no_unaligned_warning;
 #endif
 
 #ifdef CONFIG_PROC_SYSCTL
+
+#define SYSCTL_WRITES_LEGACY	-1
+#define SYSCTL_WRITES_WARN	 0
+#define SYSCTL_WRITES_STRICT	 1
+
+static int sysctl_writes_strict = SYSCTL_WRITES_WARN;
+
 static int proc_do_cad_pid(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
 static int proc_taint(struct ctl_table *table, int write,
@@ -513,6 +520,15 @@ static struct ctl_table kern_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_taint,
 	},
+	{
+		.procname	= "sysctl_writes_strict",
+		.data		= &sysctl_writes_strict,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &neg_one,
+		.extra2		= &one,
+	},
 #endif
 #ifdef CONFIG_LATENCYTOP
 	{
@@ -1840,8 +1856,20 @@ static int _proc_do_string(char *data, int maxlen, int write,
 	}
 
 	if (write) {
-		/* Start writing from beginning of buffer. */
-		len = 0;
+		if (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {
+			/* Only continue writes not past the end of buffer. */
+			len = strlen(data);
+			if (len > maxlen - 1)
+				len = maxlen - 1;
+
+			if (*ppos > len)
+				return 0;
+			len = *ppos;
+		} else {
+			/* Start writing from beginning of buffer. */
+			len = 0;
+		}
+
 		*ppos += *lenp;
 		p = buffer;
 		while ((p - buffer) < *lenp && len < maxlen - 1) {
@@ -1881,6 +1909,14 @@ static int _proc_do_string(char *data, int maxlen, int write,
 	return 0;
 }
 
+static void warn_sysctl_write(struct ctl_table *table)
+{
+	pr_warn_once("%s wrote to %s when file position was not 0!\n"
+		"This will not be supported in the future. To silence this\n"
+		"warning, set kernel.sysctl_writes_strict = -1\n",
+		current->comm, table->procname);
+}
+
 /**
  * proc_dostring - read a string sysctl
  * @table: the sysctl table
@@ -1901,6 +1937,9 @@ static int _proc_do_string(char *data, int maxlen, int write,
 int proc_dostring(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
+	if (write && *ppos && sysctl_writes_strict == SYSCTL_WRITES_WARN)
+		warn_sysctl_write(table);
+
 	return _proc_do_string((char *)(table->data), table->maxlen, write,
 			       (char __user *)buffer, lenp, ppos);
 }
@@ -2084,6 +2123,18 @@ static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
 		conv = do_proc_dointvec_conv;
 
 	if (write) {
+		if (*ppos) {
+			switch (sysctl_writes_strict) {
+			case SYSCTL_WRITES_STRICT:
+				goto out;
+			case SYSCTL_WRITES_WARN:
+				warn_sysctl_write(table);
+				break;
+			default:
+				break;
+			}
+		}
+
 		if (left > PAGE_SIZE - 1)
 			left = PAGE_SIZE - 1;
 		page = __get_free_page(GFP_TEMPORARY);
@@ -2141,6 +2192,7 @@ free:
 			return err ? : -EINVAL;
 	}
 	*lenp -= left;
+out:
 	*ppos += *lenp;
 	return err;
 }
@@ -2333,6 +2385,18 @@ static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table, int
 	left = *lenp;
 
 	if (write) {
+		if (*ppos) {
+			switch (sysctl_writes_strict) {
+			case SYSCTL_WRITES_STRICT:
+				goto out;
+			case SYSCTL_WRITES_WARN:
+				warn_sysctl_write(table);
+				break;
+			default:
+				break;
+			}
+		}
+
 		if (left > PAGE_SIZE - 1)
 			left = PAGE_SIZE - 1;
 		page = __get_free_page(GFP_TEMPORARY);
@@ -2385,6 +2449,7 @@ free:
 			return err ? : -EINVAL;
 	}
 	*lenp -= left;
+out:
 	*ppos += *lenp;
 	return err;
 }
