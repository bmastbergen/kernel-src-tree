x86/dumpstack: Remove dump_trace() and related callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] dumpstack: Remove dump_trace() and related callbacks (Josh Poimboeuf) [1430637]
Rebuild_FUZZ: 96.30%
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit c8fe4609827aedc9c4b45de80e7cdc8ccfa8541b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c8fe4609.failed

All previous users of dump_trace() have been converted to use the new
unwind interfaces, so we can remove it and the related
print_context_stack() and print_context_stack_bp() callback functions.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Byungchul Park <byungchul.park@lge.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Nilay Vaish <nilayvaish@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/5b97da3572b40b5a4d8e185cf2429308d0987a13.1474045023.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit c8fe4609827aedc9c4b45de80e7cdc8ccfa8541b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/stacktrace.h
#	arch/x86/kernel/dumpstack.c
#	arch/x86/kernel/dumpstack_32.c
#	arch/x86/kernel/dumpstack_64.c
diff --cc arch/x86/include/asm/stacktrace.h
index 7c247e7404be,37f2e0b377ad..000000000000
--- a/arch/x86/include/asm/stacktrace.h
+++ b/arch/x86/include/asm/stacktrace.h
@@@ -8,51 -8,47 +8,54 @@@
  
  #include <linux/uaccess.h>
  #include <linux/ptrace.h>
 -#include <asm/switch_to.h>
 -
 -enum stack_type {
 -	STACK_TYPE_UNKNOWN,
 -	STACK_TYPE_TASK,
 -	STACK_TYPE_IRQ,
 -	STACK_TYPE_SOFTIRQ,
 -	STACK_TYPE_EXCEPTION,
 -	STACK_TYPE_EXCEPTION_LAST = STACK_TYPE_EXCEPTION + N_EXCEPTION_STACKS-1,
 -};
 -
 -struct stack_info {
 -	enum stack_type type;
 -	unsigned long *begin, *end, *next_sp;
 -};
 -
 -bool in_task_stack(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info);
 -
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask);
  
 -void stack_type_str(enum stack_type type, const char **begin,
 -		    const char **end);
 +extern int kstack_depth_to_print;
  
 -static inline bool on_stack(struct stack_info *info, void *addr, size_t len)
 -{
 -	void *begin = info->begin;
 -	void *end   = info->end;
++<<<<<<< HEAD
 +struct thread_info;
 +struct stacktrace_ops;
 +
 +typedef unsigned long (*walk_stack_t)(struct thread_info *tinfo,
 +				      unsigned long *stack,
 +				      unsigned long bp,
 +				      const struct stacktrace_ops *ops,
 +				      void *data,
 +				      unsigned long *end,
 +				      int *graph);
 +
 +extern unsigned long
 +print_context_stack(struct thread_info *tinfo,
 +		    unsigned long *stack, unsigned long bp,
 +		    const struct stacktrace_ops *ops, void *data,
 +		    unsigned long *end, int *graph);
 +
 +extern unsigned long
 +print_context_stack_bp(struct thread_info *tinfo,
 +		       unsigned long *stack, unsigned long bp,
 +		       const struct stacktrace_ops *ops, void *data,
 +		       unsigned long *end, int *graph);
 +
 +/* Generic stack tracer with callbacks */
 +
 +struct stacktrace_ops {
 +	int (*address)(void *data, unsigned long address, int reliable);
 +	/* On negative return stop dumping */
 +	int (*stack)(void *data, char *name);
 +	walk_stack_t	walk_stack;
 +};
  
 -	return (info->type != STACK_TYPE_UNKNOWN &&
 -		addr >= begin && addr < end &&
 -		addr + len > begin && addr + len <= end);
 -}
 -
 -extern int kstack_depth_to_print;
 +void dump_trace(struct task_struct *tsk, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data);
  
++=======
++>>>>>>> c8fe4609827a (x86/dumpstack: Remove dump_trace() and related callbacks)
  #ifdef CONFIG_X86_32
  #define STACKSLOTS_PER_LINE 8
 +#define get_bp(bp) asm("movl %%ebp, %0" : "=r" (bp) :)
  #else
  #define STACKSLOTS_PER_LINE 4
 +#define get_bp(bp) asm("movq %%rbp, %0" : "=r" (bp) :)
  #endif
  
  #ifdef CONFIG_FRAME_POINTER
diff --cc arch/x86/kernel/dumpstack.c
index 08594671b59f,999de3b3f7f4..000000000000
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@@ -39,147 -56,101 +39,152 @@@ void printk_address(unsigned long addre
  	pr_cont(" [<%p>] %pS\n", (void *)address, (void *)address);
  }
  
 -void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 -			unsigned long *stack, char *log_lvl)
++<<<<<<< HEAD
 +#ifdef CONFIG_FUNCTION_GRAPH_TRACER
 +static void
 +print_ftrace_graph_addr(unsigned long addr, void *data,
 +			const struct stacktrace_ops *ops,
 +			struct thread_info *tinfo, int *graph)
  {
 -	struct unwind_state state;
 -	struct stack_info stack_info = {0};
 -	unsigned long visit_mask = 0;
 -	int graph_idx = 0;
 +	struct task_struct *task;
 +	unsigned long ret_addr;
 +	int index;
  
 -	printk("%sCall Trace:\n", log_lvl);
 +	if (addr != (unsigned long)return_to_handler)
 +		return;
  
 -	unwind_start(&state, task, regs, stack);
 +	task = tinfo->task;
 +	index = task->curr_ret_stack;
  
 -	/*
 -	 * Iterate through the stacks, starting with the current stack pointer.
 -	 * Each stack has a pointer to the next one.
 -	 *
 -	 * x86-64 can have several stacks:
 -	 * - task stack
 -	 * - interrupt stack
 -	 * - HW exception stacks (double fault, nmi, debug, mce)
 -	 *
 -	 * x86-32 can have up to three stacks:
 -	 * - task stack
 -	 * - softirq stack
 -	 * - hardirq stack
 -	 */
 -	for (; stack; stack = stack_info.next_sp) {
 -		const char *str_begin, *str_end;
 +	if (!task->ret_stack || index < *graph)
 +		return;
  
 -		/*
 -		 * If we overflowed the task stack into a guard page, jump back
 -		 * to the bottom of the usable stack.
 -		 */
 -		if (task_stack_page(task) - (void *)stack < PAGE_SIZE)
 -			stack = task_stack_page(task);
 +	index -= *graph;
 +	ret_addr = task->ret_stack[index].ret;
  
 -		if (get_stack_info(stack, task, &stack_info, &visit_mask))
 -			break;
 +	ops->address(data, ret_addr, 1);
  
 -		stack_type_str(stack_info.type, &str_begin, &str_end);
 -		if (str_begin)
 -			printk("%s <%s> ", log_lvl, str_begin);
 -
 -		/*
 -		 * Scan the stack, printing any text addresses we find.  At the
 -		 * same time, follow proper stack frames with the unwinder.
 -		 *
 -		 * Addresses found during the scan which are not reported by
 -		 * the unwinder are considered to be additional clues which are
 -		 * sometimes useful for debugging and are prefixed with '?'.
 -		 * This also serves as a failsafe option in case the unwinder
 -		 * goes off in the weeds.
 -		 */
 -		for (; stack < stack_info.end; stack++) {
 -			unsigned long real_addr;
 -			int reliable = 0;
 -			unsigned long addr = *stack;
 -			unsigned long *ret_addr_p =
 -				unwind_get_return_address_ptr(&state);
 -
 -			if (!__kernel_text_address(addr))
 -				continue;
 -
 -			if (stack == ret_addr_p)
 -				reliable = 1;
 -
 -			/*
 -			 * When function graph tracing is enabled for a
 -			 * function, its return address on the stack is
 -			 * replaced with the address of an ftrace handler
 -			 * (return_to_handler).  In that case, before printing
 -			 * the "real" address, we want to print the handler
 -			 * address as an "unreliable" hint that function graph
 -			 * tracing was involved.
 -			 */
 -			real_addr = ftrace_graph_ret_addr(task, &graph_idx,
 -							  addr, stack);
 -			if (real_addr != addr)
 -				printk_stack_address(addr, 0, log_lvl);
 -			printk_stack_address(real_addr, reliable, log_lvl);
 -
 -			if (!reliable)
 -				continue;
 -
 -			/*
 -			 * Get the next frame from the unwinder.  No need to
 -			 * check for an error: if anything goes wrong, the rest
 -			 * of the addresses will just be printed as unreliable.
 -			 */
 -			unwind_next_frame(&state);
 +	(*graph)++;
 +}
 +#else
 +static inline void
 +print_ftrace_graph_addr(unsigned long addr, void *data,
 +			const struct stacktrace_ops *ops,
 +			struct thread_info *tinfo, int *graph)
 +{ }
 +#endif
 +
 +/*
 + * x86-64 can have up to three kernel stacks:
 + * process stack
 + * interrupt stack
 + * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
 + */
 +
 +static inline int valid_stack_ptr(struct thread_info *tinfo,
 +			void *p, unsigned int size, void *end)
 +{
 +	void *t = tinfo;
 +	if (end) {
 +		if (p < end && p >= (end-THREAD_SIZE))
 +			return 1;
 +		else
 +			return 0;
 +	}
 +	return p > t && p < t + THREAD_SIZE - size;
 +}
 +
 +unsigned long
 +print_context_stack(struct thread_info *tinfo,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data,
 +		unsigned long *end, int *graph)
 +{
 +	struct stack_frame *frame = (struct stack_frame *)bp;
 +
 +	while (valid_stack_ptr(tinfo, stack, sizeof(*stack), end)) {
 +		unsigned long addr;
 +
 +		addr = *stack;
 +		if (__kernel_text_address(addr)) {
 +			if ((unsigned long) stack == bp + sizeof(long)) {
 +				ops->address(data, addr, 1);
 +				frame = frame->next_frame;
 +				bp = (unsigned long) frame;
 +			} else {
 +				ops->address(data, addr, 0);
 +			}
 +			print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
  		}
 +		stack++;
 +	}
 +	return bp;
 +}
 +EXPORT_SYMBOL_GPL(print_context_stack);
 +
 +unsigned long
 +print_context_stack_bp(struct thread_info *tinfo,
 +		       unsigned long *stack, unsigned long bp,
 +		       const struct stacktrace_ops *ops, void *data,
 +		       unsigned long *end, int *graph)
 +{
 +	struct stack_frame *frame = (struct stack_frame *)bp;
 +	unsigned long *ret_addr = &frame->return_address;
 +
 +	while (valid_stack_ptr(tinfo, ret_addr, sizeof(*ret_addr), end)) {
 +		unsigned long addr = *ret_addr;
 +
 +		if (!__kernel_text_address(addr))
 +			break;
  
 -		if (str_end)
 -			printk("%s <%s> ", log_lvl, str_end);
 +		if (ops->address(data, addr, 1))
 +			break;
 +		frame = frame->next_frame;
 +		ret_addr = &frame->return_address;
 +		print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
  	}
 +
 +	return (unsigned long)frame;
 +}
 +EXPORT_SYMBOL_GPL(print_context_stack_bp);
 +
 +static int print_trace_stack(void *data, char *name)
++=======
++void show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
++			unsigned long *stack, char *log_lvl)
++>>>>>>> c8fe4609827a (x86/dumpstack: Remove dump_trace() and related callbacks)
 +{
 +	printk("%s <%s> ", (char *)data, name);
 +	return 0;
 +}
 +
 +/*
 + * Print one address/symbol entries per line.
 + */
 +static int print_trace_address(void *data, unsigned long addr, int reliable)
 +{
 +	printk_stack_address(addr, reliable, data);
 +	return 0;
 +}
 +
 +static const struct stacktrace_ops print_trace_ops = {
 +	.stack			= print_trace_stack,
 +	.address		= print_trace_address,
 +	.walk_stack		= print_context_stack,
 +};
 +
 +void
 +show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp, char *log_lvl)
 +{
 +	printk("%sCall Trace:\n", log_lvl);
 +	dump_trace(task, regs, stack, bp, &print_trace_ops, log_lvl);
 +}
 +
 +void show_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp)
 +{
 +	show_trace_log_lvl(task, regs, stack, bp, "");
  }
  
  void show_stack(struct task_struct *task, unsigned long *sp)
diff --cc arch/x86/kernel/dumpstack_32.c
index c90b53d2857e,06eb322b5f9f..000000000000
--- a/arch/x86/kernel/dumpstack_32.c
+++ b/arch/x86/kernel/dumpstack_32.c
@@@ -16,47 -16,113 +16,52 @@@
  
  #include <asm/stacktrace.h>
  
 -void stack_type_str(enum stack_type type, const char **begin, const char **end)
 -{
 -	switch (type) {
 -	case STACK_TYPE_IRQ:
 -	case STACK_TYPE_SOFTIRQ:
 -		*begin = "IRQ";
 -		*end   = "EOI";
 -		break;
 -	default:
 -		*begin = NULL;
 -		*end   = NULL;
 -	}
 -}
 -
 -static bool in_hardirq_stack(unsigned long *stack, struct stack_info *info)
 -{
 -	unsigned long *begin = (unsigned long *)this_cpu_read(hardirq_stack);
 -	unsigned long *end   = begin + (THREAD_SIZE / sizeof(long));
 -
 -	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 -	 */
 -	if (stack < begin || stack > end)
 -		return false;
 -
 -	info->type	= STACK_TYPE_IRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 -
 -	/*
 -	 * See irq_32.c -- the next stack pointer is stored at the beginning of
 -	 * the stack.
 -	 */
 -	info->next_sp	= (unsigned long *)*begin;
 -
 -	return true;
 -}
 -
 -static bool in_softirq_stack(unsigned long *stack, struct stack_info *info)
 -{
 -	unsigned long *begin = (unsigned long *)this_cpu_read(softirq_stack);
 -	unsigned long *end   = begin + (THREAD_SIZE / sizeof(long));
 -
 -	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 -	 */
 -	if (stack < begin || stack > end)
 -		return false;
 -
 -	info->type	= STACK_TYPE_SOFTIRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 -
 -	/*
 -	 * The next stack pointer is stored at the beginning of the stack.
 -	 * See irq_32.c.
 -	 */
 -	info->next_sp	= (unsigned long *)*begin;
  
 -	return true;
 -}
 -
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask)
++<<<<<<< HEAD
 +void dump_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data)
  {
 -	if (!stack)
 -		goto unknown;
 +	int graph = 0;
  
 -	task = task ? : current;
 +	if (!task)
 +		task = current;
  
 -	if (in_task_stack(stack, task, info))
 -		goto recursion_check;
 +	if (!stack) {
 +		unsigned long dummy;
  
 -	if (task != current)
 -		goto unknown;
 +		stack = &dummy;
 +		if (task && task != current)
 +			stack = (unsigned long *)task->thread.sp;
 +	}
  
 -	if (in_hardirq_stack(stack, info))
 -		goto recursion_check;
 +	if (!bp)
 +		bp = stack_frame(task, regs);
  
 -	if (in_softirq_stack(stack, info))
 -		goto recursion_check;
 +	for (;;) {
 +		struct thread_info *context;
  
 -	goto unknown;
 +		context = (struct thread_info *)
 +			((unsigned long)stack & (~(THREAD_SIZE - 1)));
 +		bp = ops->walk_stack(context, stack, bp, ops, data, NULL, &graph);
  
 -recursion_check:
 -	/*
 -	 * Make sure we don't iterate through any given stack more than once.
 -	 * If it comes up a second time then there's something wrong going on:
 -	 * just break out and report an unknown stack type.
 -	 */
 -	if (visit_mask) {
 -		if (*visit_mask & (1UL << info->type))
 -			goto unknown;
 -		*visit_mask |= 1UL << info->type;
 +		stack = (unsigned long *)context->previous_esp;
 +		if (!stack)
 +			break;
 +		if (ops->stack(data, "IRQ") < 0)
 +			break;
 +		touch_nmi_watchdog();
  	}
 -
 -	return 0;
 -
 -unknown:
 -	info->type = STACK_TYPE_UNKNOWN;
 -	return -EINVAL;
  }
 +EXPORT_SYMBOL(dump_trace);
  
 +void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl)
++=======
+ void show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
+ 			unsigned long *sp, char *log_lvl)
++>>>>>>> c8fe4609827a (x86/dumpstack: Remove dump_trace() and related callbacks)
  {
  	unsigned long *stack;
  	int i;
diff --cc arch/x86/kernel/dumpstack_64.c
index 101e30243d5b,36cf1a498227..000000000000
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@@ -16,235 -16,132 +16,240 @@@
  
  #include <asm/stacktrace.h>
  
 -static char *exception_stack_names[N_EXCEPTION_STACKS] = {
 -		[ DOUBLEFAULT_STACK-1	]	= "#DF",
 -		[ NMI_STACK-1		]	= "NMI",
 -		[ DEBUG_STACK-1		]	= "#DB",
 -		[ MCE_STACK-1		]	= "#MC",
 -};
  
 -static unsigned long exception_stack_sizes[N_EXCEPTION_STACKS] = {
 -	[0 ... N_EXCEPTION_STACKS - 1]		= EXCEPTION_STKSZ,
 -	[DEBUG_STACK - 1]			= DEBUG_STKSZ
 +#define N_EXCEPTION_STACKS_END \
 +		(N_EXCEPTION_STACKS + DEBUG_STKSZ/EXCEPTION_STKSZ - 2)
 +
 +static char x86_stack_ids[][8] = {
 +		[ DEBUG_STACK-1			]	= "#DB",
 +		[ NMI_STACK-1			]	= "NMI",
 +		[ DOUBLEFAULT_STACK-1		]	= "#DF",
 +		[ MCE_STACK-1			]	= "#MC",
 +#if DEBUG_STKSZ > EXCEPTION_STKSZ
 +		[ N_EXCEPTION_STACKS ...
 +		  N_EXCEPTION_STACKS_END	]	= "#DB[?]"
 +#endif
  };
  
 -void stack_type_str(enum stack_type type, const char **begin, const char **end)
 +static unsigned long *in_exception_stack(unsigned cpu, unsigned long stack,
 +					 unsigned *usedp, char **idp)
  {
 -	BUILD_BUG_ON(N_EXCEPTION_STACKS != 4);
 -
 -	switch (type) {
 -	case STACK_TYPE_IRQ:
 -		*begin = "IRQ";
 -		*end   = "EOI";
 -		break;
 -	case STACK_TYPE_EXCEPTION ... STACK_TYPE_EXCEPTION_LAST:
 -		*begin = exception_stack_names[type - STACK_TYPE_EXCEPTION];
 -		*end   = "EOE";
 -		break;
 -	default:
 -		*begin = NULL;
 -		*end   = NULL;
 +	unsigned k;
 +
 +	/*
 +	 * Iterate over all exception stacks, and figure out whether
 +	 * 'stack' is in one of them:
 +	 */
 +	for (k = 0; k < N_EXCEPTION_STACKS; k++) {
 +		unsigned long end = per_cpu(orig_ist, cpu).ist[k];
 +		/*
 +		 * Is 'stack' above this exception frame's end?
 +		 * If yes then skip to the next frame.
 +		 */
 +		if (stack >= end)
 +			continue;
 +		/*
 +		 * Is 'stack' above this exception frame's start address?
 +		 * If yes then we found the right frame.
 +		 */
 +		if (stack >= end - EXCEPTION_STKSZ) {
 +			/*
 +			 * Make sure we only iterate through an exception
 +			 * stack once. If it comes up for the second time
 +			 * then there's something wrong going on - just
 +			 * break out and return NULL:
 +			 */
 +			if (*usedp & (1U << k))
 +				break;
 +			*usedp |= 1U << k;
 +			*idp = x86_stack_ids[k];
 +			return (unsigned long *)end;
 +		}
 +		/*
 +		 * If this is a debug stack, and if it has a larger size than
 +		 * the usual exception stacks, then 'stack' might still
 +		 * be within the lower portion of the debug stack:
 +		 */
 +#if DEBUG_STKSZ > EXCEPTION_STKSZ
 +		if (k == DEBUG_STACK - 1 && stack >= end - DEBUG_STKSZ) {
 +			unsigned j = N_EXCEPTION_STACKS - 1;
 +
 +			/*
 +			 * Black magic. A large debug stack is composed of
 +			 * multiple exception stack entries, which we
 +			 * iterate through now. Dont look:
 +			 */
 +			do {
 +				++j;
 +				end -= EXCEPTION_STKSZ;
 +				x86_stack_ids[j][4] = '1' +
 +						(j - N_EXCEPTION_STACKS);
 +			} while (stack < end - EXCEPTION_STKSZ);
 +			if (*usedp & (1U << j))
 +				break;
 +			*usedp |= 1U << j;
 +			*idp = x86_stack_ids[j];
 +			return (unsigned long *)end;
 +		}
 +#endif
  	}
 +	return NULL;
  }
  
 -static bool in_exception_stack(unsigned long *stack, struct stack_info *info)
 +static inline int
 +in_irq_stack(unsigned long *stack, unsigned long *irq_stack,
 +	     unsigned long *irq_stack_end)
  {
 -	unsigned long *begin, *end;
 -	struct pt_regs *regs;
 -	unsigned k;
 +	return (stack >= irq_stack && stack < irq_stack_end);
 +}
  
 -	BUILD_BUG_ON(N_EXCEPTION_STACKS != 4);
 +enum stack_type {
 +	STACK_IS_UNKNOWN,
 +	STACK_IS_NORMAL,
 +	STACK_IS_EXCEPTION,
 +	STACK_IS_IRQ,
 +};
  
 -	for (k = 0; k < N_EXCEPTION_STACKS; k++) {
 -		end   = (unsigned long *)raw_cpu_ptr(&orig_ist)->ist[k];
 -		begin = end - (exception_stack_sizes[k] / sizeof(long));
 -		regs  = (struct pt_regs *)end - 1;
 +static enum stack_type
 +analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
 +	      unsigned long **stack_end, unsigned long *irq_stack,
 +	      unsigned *used, char **id)
 +{
 +	unsigned long addr;
  
 -		if (stack < begin || stack >= end)
 -			continue;
 +	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
 +	if ((unsigned long)task_stack_page(task) == addr)
 +		return STACK_IS_NORMAL;
  
 -		info->type	= STACK_TYPE_EXCEPTION + k;
 -		info->begin	= begin;
 -		info->end	= end;
 -		info->next_sp	= (unsigned long *)regs->sp;
 +	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
 +					used, id);
 +	if (*stack_end)
 +		return STACK_IS_EXCEPTION;
  
 -		return true;
 -	}
 +	if (!irq_stack)
 +		return STACK_IS_NORMAL;
  
 -	return false;
 +	*stack_end = irq_stack;
 +	irq_stack -= (IRQ_STACK_SIZE / sizeof(long));
 +
 +	if (in_irq_stack(stack, irq_stack, *stack_end))
 +		return STACK_IS_IRQ;
 +
 +	return STACK_IS_UNKNOWN;
  }
  
 -static bool in_irq_stack(unsigned long *stack, struct stack_info *info)
++<<<<<<< HEAD
 +/*
 + * x86-64 can have up to three kernel stacks:
 + * process stack
 + * interrupt stack
 + * severe exception (double fault, nmi, stack fault, debug, mce) hardware stack
 + */
 +
 +void dump_trace(struct task_struct *task, struct pt_regs *regs,
 +		unsigned long *stack, unsigned long bp,
 +		const struct stacktrace_ops *ops, void *data)
  {
 -	unsigned long *end   = (unsigned long *)this_cpu_read(irq_stack_ptr);
 -	unsigned long *begin = end - (IRQ_STACK_SIZE / sizeof(long));
 +	const unsigned cpu = get_cpu();
 +	struct thread_info *tinfo;
 +	unsigned long *irq_stack = (unsigned long *)per_cpu(irq_stack_ptr, cpu);
 +	unsigned long dummy;
 +	unsigned used = 0;
 +	int graph = 0;
 +	int done = 0;
 +
 +	if (!task)
 +		task = current;
 +
 +	if (!stack) {
 +		if (regs)
 +			stack = (unsigned long *)regs->sp;
 +		else if (task != current)
 +			stack = (unsigned long *)task->thread.sp;
 +		else
 +			stack = &dummy;
 +	}
  
 +	if (!bp)
 +		bp = stack_frame(task, regs);
  	/*
 -	 * This is a software stack, so 'end' can be a valid stack pointer.
 -	 * It just means the stack is empty.
 +	 * Print function call entries in all stacks, starting at the
 +	 * current stack address. If the stacks consist of nested
 +	 * exceptions
  	 */
 -	if (stack < begin || stack > end)
 -		return false;
 +	tinfo = task_thread_info(task);
 +	while (!done) {
 +		unsigned long *stack_end;
 +		enum stack_type stype;
 +		char *id;
  
 -	info->type	= STACK_TYPE_IRQ;
 -	info->begin	= begin;
 -	info->end	= end;
 +		stype = analyze_stack(cpu, task, stack, &stack_end,
 +				      irq_stack, &used, &id);
  
 -	/*
 -	 * The next stack pointer is the first thing pushed by the entry code
 -	 * after switching to the irq stack.
 -	 */
 -	info->next_sp = (unsigned long *)*(end - 1);
 +		/* Default finish unless specified to continue */
 +		done = 1;
  
 -	return true;
 -}
 +		switch (stype) {
  
 -int get_stack_info(unsigned long *stack, struct task_struct *task,
 -		   struct stack_info *info, unsigned long *visit_mask)
 -{
 -	if (!stack)
 -		goto unknown;
 +		/* Break out early if we are on the thread stack */
 +		case STACK_IS_NORMAL:
 +			break;
  
 -	task = task ? : current;
 +		case STACK_IS_EXCEPTION:
  
 -	if (in_task_stack(stack, task, info))
 -		goto recursion_check;
 +			if (ops->stack(data, id) < 0)
 +				break;
  
 -	if (task != current)
 -		goto unknown;
 +			bp = ops->walk_stack(tinfo, stack, bp, ops,
 +					     data, stack_end, &graph);
 +			ops->stack(data, "EOE");
 +			/*
 +			 * We link to the next stack via the
 +			 * second-to-last pointer (index -2 to end) in the
 +			 * exception stack:
 +			 */
 +			stack = (unsigned long *) stack_end[-2];
 +			done = 0;
 +			break;
  
 -	if (in_exception_stack(stack, info))
 -		goto recursion_check;
 +		case STACK_IS_IRQ:
  
 -	if (in_irq_stack(stack, info))
 -		goto recursion_check;
 +			if (ops->stack(data, "IRQ") < 0)
 +				break;
 +			bp = ops->walk_stack(tinfo, stack, bp,
 +				     ops, data, stack_end, &graph);
 +			/*
 +			 * We link to the next stack (which would be
 +			 * the process stack normally) the last
 +			 * pointer (index -1 to end) in the IRQ stack:
 +			 */
 +			stack = (unsigned long *) (stack_end[-1]);
 +			irq_stack = NULL;
 +			ops->stack(data, "EOI");
 +			done = 0;
 +			break;
  
 -	goto unknown;
 +		case STACK_IS_UNKNOWN:
 +			ops->stack(data, "UNK");
 +			break;
 +		}
 +	}
  
 -recursion_check:
  	/*
 -	 * Make sure we don't iterate through any given stack more than once.
 -	 * If it comes up a second time then there's something wrong going on:
 -	 * just break out and report an unknown stack type.
 +	 * This handles the process stack:
  	 */
 -	if (visit_mask) {
 -		if (*visit_mask & (1UL << info->type))
 -			goto unknown;
 -		*visit_mask |= 1UL << info->type;
 -	}
 -
 -	return 0;
 -
 -unknown:
 -	info->type = STACK_TYPE_UNKNOWN;
 -	return -EINVAL;
 +	bp = ops->walk_stack(tinfo, stack, bp, ops, data, NULL, &graph);
 +	put_cpu();
  }
 +EXPORT_SYMBOL(dump_trace);
  
 +void
 +show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
 +		   unsigned long *sp, unsigned long bp, char *log_lvl)
++=======
+ void show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
+ 			unsigned long *sp, char *log_lvl)
++>>>>>>> c8fe4609827a (x86/dumpstack: Remove dump_trace() and related callbacks)
  {
  	unsigned long *irq_stack_end;
  	unsigned long *irq_stack;
* Unmerged path arch/x86/include/asm/stacktrace.h
* Unmerged path arch/x86/kernel/dumpstack.c
* Unmerged path arch/x86/kernel/dumpstack_32.c
* Unmerged path arch/x86/kernel/dumpstack_64.c
