block: factor out req_set_nomerge

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [block] factor out req_set_nomerge (Ming Lei) [1458104]
Rebuild_FUZZ: 88.14%
commit-author Ritesh Harjani <riteshh@codeaurora.org>
commit e0c723000966ae285295caaa8cda914dfa177fa4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e0c72300.failed

Factor out common code for setting REQ_NOMERGE flag which is being used
out at certain places and make it a helper instead, req_set_nomerge().

	Signed-off-by: Ritesh Harjani <riteshh@codeaurora.org>

Get rid of the inline.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit e0c723000966ae285295caaa8cda914dfa177fa4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-merge.c
diff --cc block/blk-merge.c
index 0e8b7f203168,1002afdfee99..000000000000
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@@ -228,42 -501,12 +228,51 @@@ int blk_rq_map_sg(struct request_queue 
  }
  EXPORT_SYMBOL(blk_rq_map_sg);
  
++<<<<<<< HEAD
 +/**
 + * blk_bio_map_sg - map a bio to a scatterlist
 + * @q: request_queue in question
 + * @bio: bio being mapped
 + * @sglist: scatterlist being mapped
 + *
 + * Note:
 + *    Caller must make sure sg can hold bio->bi_phys_segments entries
 + *
 + * Will return the number of sg entries setup
 + */
 +int blk_bio_map_sg(struct request_queue *q, struct bio *bio,
 +		   struct scatterlist *sglist)
 +{
 +	struct bio_vec *bvec, *bvprv;
 +	struct scatterlist *sg;
 +	int nsegs, cluster;
 +	unsigned long i;
 +
 +	nsegs = 0;
 +	cluster = blk_queue_cluster(q);
 +
 +	bvprv = NULL;
 +	sg = NULL;
 +	bio_for_each_segment(bvec, bio, i) {
 +		__blk_segment_map_sg(q, bvec, sglist, &bvprv, &sg,
 +				     &nsegs, &cluster);
 +	} /* segments in bio */
 +
 +	if (sg)
 +		sg_mark_end(sg);
 +
 +	BUG_ON(bio->bi_phys_segments && nsegs > bio->bi_phys_segments);
 +	return nsegs;
 +}
 +EXPORT_SYMBOL(blk_bio_map_sg);
++=======
+ static void req_set_nomerge(struct request_queue *q, struct request *req)
+ {
+ 	req->cmd_flags |= REQ_NOMERGE;
+ 	if (req == q->last_merge)
+ 		q->last_merge = NULL;
+ }
++>>>>>>> e0c723000966 (block: factor out req_set_nomerge)
  
  static inline int ll_new_hw_segment(struct request_queue *q,
  				    struct request *req,
@@@ -296,11 -537,12 +303,16 @@@ int ll_back_merge_fn(struct request_que
  {
  	if (req_gap_back_merge(req, bio))
  		return 0;
 -	if (blk_integrity_rq(req) &&
 -	    integrity_req_gap_back_merge(req, bio))
 -		return 0;
  	if (blk_rq_sectors(req) + bio_sectors(bio) >
++<<<<<<< HEAD
 +	    blk_rq_get_max_sectors(req)) {
 +		req->cmd_flags |= REQ_NOMERGE;
 +		if (req == q->last_merge)
 +			q->last_merge = NULL;
++=======
+ 	    blk_rq_get_max_sectors(req, blk_rq_pos(req))) {
+ 		req_set_nomerge(q, req);
++>>>>>>> e0c723000966 (block: factor out req_set_nomerge)
  		return 0;
  	}
  	if (!bio_flagged(req->biotail, BIO_SEG_VALID))
@@@ -314,13 -556,15 +326,18 @@@
  int ll_front_merge_fn(struct request_queue *q, struct request *req,
  		      struct bio *bio)
  {
 -
  	if (req_gap_front_merge(req, bio))
  		return 0;
 -	if (blk_integrity_rq(req) &&
 -	    integrity_req_gap_front_merge(req, bio))
 -		return 0;
  	if (blk_rq_sectors(req) + bio_sectors(bio) >
++<<<<<<< HEAD
 +	    blk_rq_get_max_sectors(req)) {
 +		req->cmd_flags |= REQ_NOMERGE;
 +		if (req == q->last_merge)
 +			q->last_merge = NULL;
++=======
+ 	    blk_rq_get_max_sectors(req, bio->bi_iter.bi_sector)) {
+ 		req_set_nomerge(q, req);
++>>>>>>> e0c723000966 (block: factor out req_set_nomerge)
  		return 0;
  	}
  	if (!bio_flagged(bio, BIO_SEG_VALID))
* Unmerged path block/blk-merge.c
