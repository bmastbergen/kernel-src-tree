cpuset: introduce effective_{cpumask|nodemask}_cpuset()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Li Zefan <lizefan@huawei.com>
commit 070b57fcacc9dfc23a180290079078373fb697e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/070b57fc.failed

effective_cpumask_cpuset() returns an ancestor cpuset which has
non-empty cpumask.

If a cpuset is empty and the tasks in it need to update their
cpus_allowed, they take on the ancestor cpuset's cpumask.

This currently won't change any behavior, but it will later allow us
to keep tasks in empty cpusets.

	Signed-off-by: Li Zefan <lizefan@huawei.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 070b57fcacc9dfc23a180290079078373fb697e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cpuset.c
diff --cc kernel/cpuset.c
index 07bb1f0b440a,82ac1f862cbc..000000000000
--- a/kernel/cpuset.c
+++ b/kernel/cpuset.c
@@@ -938,9 -968,8 +981,14 @@@ static void cpuset_migrate_mm(struct mm
  
  	do_migrate_pages(mm, from, to, MPOL_MF_MOVE_ALL);
  
++<<<<<<< HEAD
 +	rcu_read_lock();
 +	guarantee_online_mems(task_cs(tsk),&tsk->mems_allowed);
 +	rcu_read_unlock();
++=======
+ 	mems_cs = effective_nodemask_cpuset(task_cs(tsk));
+ 	guarantee_online_mems(mems_cs, &tsk->mems_allowed);
++>>>>>>> 070b57fcacc9 (cpuset: introduce effective_{cpumask|nodemask}_cpuset())
  }
  
  /*
* Unmerged path kernel/cpuset.c
