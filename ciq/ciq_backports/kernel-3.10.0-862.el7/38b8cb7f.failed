mm: pass vm_fault structure into do_page_mkwrite()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] pass vm_fault structure into do_page_mkwrite() (Larry Woodman) [1457569 1383493 1457572]
Rebuild_FUZZ: 95.83%
commit-author Jan Kara <jack@suse.cz>
commit 38b8cb7fbb892503fe9fcf748ebbed8c9fde7bf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/38b8cb7f.failed

We will need more information in the ->page_mkwrite() helper for DAX to
be able to fully finish faults there.  Pass vm_fault structure to
do_page_mkwrite() and use it there so that information propagates
properly from upper layers.

Link: http://lkml.kernel.org/r/1479460644-25076-13-git-send-email-jack@suse.cz
	Signed-off-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 38b8cb7fbb892503fe9fcf748ebbed8c9fde7bf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
diff --cc mm/memory.c
index 2fc5b28b6782,e8a527885e8b..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -2048,19 -2034,17 +2048,25 @@@ static inline void cow_user_page(struc
   *
   * We do this without the lock held, so that it can sleep if it needs to.
   */
- static int do_page_mkwrite(struct vm_area_struct *vma, struct page *page,
- 	       unsigned long address)
+ static int do_page_mkwrite(struct vm_fault *vmf)
  {
- 	struct vm_fault vmf;
  	int ret;
+ 	struct page *page = vmf->page;
+ 	unsigned int old_flags = vmf->flags;
  
++<<<<<<< HEAD
 +	vmf.virtual_address = (void __user *)(address & PAGE_MASK);
 +	vmf.pgoff = page->index;
 +	vmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;
 +	vmf.page = page;
 +	vmf.cow_page = NULL;
++=======
+ 	vmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;
++>>>>>>> 38b8cb7fbb89 (mm: pass vm_fault structure into do_page_mkwrite())
  
- 	ret = vma->vm_ops->page_mkwrite(vma, &vmf);
+ 	ret = vmf->vma->vm_ops->page_mkwrite(vmf->vma, vmf);
+ 	/* Restore original flags so that caller is not surprised */
+ 	vmf->flags = old_flags;
  	if (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))
  		return ret;
  	if (unlikely(!(ret & VM_FAULT_LOCKED))) {
@@@ -2326,11 -2319,12 +2332,17 @@@ static int wp_page_shared(struct mm_str
  	if (vma->vm_ops && vma->vm_ops->page_mkwrite) {
  		int tmp;
  
++<<<<<<< HEAD
 +		pte_unmap_unlock(page_table, ptl);
 +		tmp = do_page_mkwrite(vma, old_page, address);
++=======
+ 		pte_unmap_unlock(vmf->pte, vmf->ptl);
+ 		vmf->page = old_page;
+ 		tmp = do_page_mkwrite(vmf);
++>>>>>>> 38b8cb7fbb89 (mm: pass vm_fault structure into do_page_mkwrite())
  		if (unlikely(!tmp || (tmp &
  				      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {
 -			put_page(old_page);
 +			page_cache_release(old_page);
  			return tmp;
  		}
  		/*
@@@ -2987,11 -3321,11 +2999,16 @@@ static int do_shared_fault(struct mm_st
  	 * about to become writable
  	 */
  	if (vma->vm_ops->page_mkwrite) {
++<<<<<<< HEAD
 +		unlock_page(fault_page);
 +		tmp = do_page_mkwrite(vma, fault_page, address);
++=======
+ 		unlock_page(vmf->page);
+ 		tmp = do_page_mkwrite(vmf);
++>>>>>>> 38b8cb7fbb89 (mm: pass vm_fault structure into do_page_mkwrite())
  		if (unlikely(!tmp ||
  				(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {
 -			put_page(vmf->page);
 +			page_cache_release(fault_page);
  			return tmp;
  		}
  	}
* Unmerged path mm/memory.c
