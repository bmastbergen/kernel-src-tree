cpufreq: intel_pstate: Drop pointless initialization of PID parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Drop pointless initialization of PID parameters (Prarit Bhargava) [1465349]
Rebuild_FUZZ: 93.13%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 6404367862bb25730e373cb9d443757b76f6abcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/64043678.failed

The P-state selection algorithm used by intel_pstate for Atom
processors is not based on the PID controller and the initialization
of PID parametrs for those processors is pointless and confusing, so
drop it.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6404367862bb25730e373cb9d443757b76f6abcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 9b85edc571c0,efce4e7eeeca..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1049,15 -1539,7 +1049,19 @@@ static struct cpu_defaults core_params 
  	},
  };
  
++<<<<<<< HEAD
 +static struct cpu_defaults atom_params = {
 +	.pid_policy = {
 +		.sample_rate_ms = 10,
 +		.deadband = 0,
 +		.setpoint = 60,
 +		.p_gain_pct = 14,
 +		.d_gain_pct = 0,
 +		.i_gain_pct = 4,
 +	},
++=======
+ static const struct cpu_defaults silvermont_params = {
++>>>>>>> 6404367862bb (cpufreq: intel_pstate: Drop pointless initialization of PID parameters)
  	.funcs = {
  		.get_max = atom_get_max_pstate,
  		.get_max_physical = atom_get_max_pstate,
@@@ -1070,7 -1552,20 +1074,24 @@@
  	},
  };
  
++<<<<<<< HEAD
 +static struct cpu_defaults knl_params = {
++=======
+ static const struct cpu_defaults airmont_params = {
+ 	.funcs = {
+ 		.get_max = atom_get_max_pstate,
+ 		.get_max_physical = atom_get_max_pstate,
+ 		.get_min = atom_get_min_pstate,
+ 		.get_turbo = atom_get_turbo_pstate,
+ 		.get_val = atom_get_val,
+ 		.get_scaling = airmont_get_scaling,
+ 		.get_vid = atom_get_vid,
+ 		.get_target_pstate = get_target_pstate_use_cpu_load,
+ 	},
+ };
+ 
+ static const struct cpu_defaults knl_params = {
++>>>>>>> 6404367862bb (cpufreq: intel_pstate: Drop pointless initialization of PID parameters)
  	.pid_policy = {
  		.sample_rate_ms = 10,
  		.deadband = 0,
@@@ -1090,6 -1585,18 +1111,21 @@@
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static const struct cpu_defaults bxt_params = {
+ 	.funcs = {
+ 		.get_max = core_get_max_pstate,
+ 		.get_max_physical = core_get_max_pstate_physical,
+ 		.get_min = core_get_min_pstate,
+ 		.get_turbo = core_get_turbo_pstate,
+ 		.get_scaling = core_get_scaling,
+ 		.get_val = core_get_val,
+ 		.get_target_pstate = get_target_pstate_use_cpu_load,
+ 	},
+ };
+ 
++>>>>>>> 6404367862bb (cpufreq: intel_pstate: Drop pointless initialization of PID parameters)
  static void intel_pstate_get_min_max(struct cpudata *cpu, int *min, int *max)
  {
  	int max_perf = cpu->pstate.turbo_pstate;
@@@ -1753,21 -2595,29 +1789,43 @@@ static int __init intel_pstate_init(voi
  	if (no_load)
  		return -ENODEV;
  
 -	if (x86_match_cpu(hwp_support_ids)) {
 +	if (x86_match_cpu(hwp_support_ids) && !no_hwp) {
  		copy_cpu_funcs(&core_params.funcs);
++<<<<<<< HEAD
 +		hwp_active++;
 +		goto hwp_cpu_matched;
++=======
+ 		if (no_hwp) {
+ 			pstate_funcs.get_target_pstate = get_target_pstate_use_cpu_load;
+ 		} else {
+ 			hwp_active++;
+ 			intel_pstate.attr = hwp_cpufreq_attrs;
+ 			goto hwp_cpu_matched;
+ 		}
+ 	} else {
+ 		const struct x86_cpu_id *id;
+ 		struct cpu_defaults *cpu_def;
+ 
+ 		id = x86_match_cpu(intel_pstate_cpu_ids);
+ 		if (!id)
+ 			return -ENODEV;
+ 
+ 		cpu_def = (struct cpu_defaults *)id->driver_data;
+ 		copy_cpu_funcs(&cpu_def->funcs);
+ 		if (pstate_funcs.get_target_pstate == get_target_pstate_use_performance)
+ 			copy_pid_params(&cpu_def->pid_policy);
++>>>>>>> 6404367862bb (cpufreq: intel_pstate: Drop pointless initialization of PID parameters)
  	}
  
 +	id = x86_match_cpu(intel_pstate_cpu_ids);
 +	if (!id)
 +		return -ENODEV;
 +
 +	cpu_info = (struct cpu_defaults *)id->driver_data;
 +
 +	copy_pid_params(&cpu_info->pid_policy);
 +	copy_cpu_funcs(&cpu_info->funcs);
 +
  	if (intel_pstate_msrs_not_valid())
  		return -ENODEV;
  
* Unmerged path drivers/cpufreq/intel_pstate.c
