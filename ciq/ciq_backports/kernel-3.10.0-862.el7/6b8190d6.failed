nvme: implement NS Optimal IO Boundary from 1.3 Spec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] implement NS Optimal IO Boundary from 1.3 Spec (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 93.88%
commit-author Scott Bauer <scott.bauer@intel.com>
commit 6b8190d61a622e095f04451437953acd2d74b371
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6b8190d6.failed

The NVMe 1.3 spec introduces Namespace Optimal IO Boundaries (NOIOB),
which standardizes the stripe mechanism we currently have quirks for.
This patch implements the necessary logic to handle this new feature.

	Signed-off-by: Scott Bauer <scott.bauer@intel.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 6b8190d61a622e095f04451437953acd2d74b371)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index f3660f9b6cc7,0ddd6b9af7fc..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -905,20 -1144,18 +911,27 @@@ static int nvme_revalidate_disk(struct 
  	if (ns->lba_shift == 0)
  		ns->lba_shift = 9;
  	bs = 1 << ns->lba_shift;
+ 	ns->noiob = le16_to_cpu(id->noiob);
  
  	blk_mq_freeze_queue(disk->queue);
 +	if (blk_get_integrity(disk) && (ns->ms != old_ms ||
 +				bs != queue_logical_block_size(disk->queue) ||
 +				(ns->ms && ns->ext)))
 +		blk_integrity_unregister(disk);
  
 -	if (ns->ctrl->ops->flags & NVME_F_METADATA_SUPPORTED)
 -		nvme_prep_integrity(disk, id, bs);
 +	ns->pi_type = ns->ms == 8 ? id->dps & NVME_NS_DPS_PI_MASK : 0;
  	blk_queue_logical_block_size(ns->queue, bs);
++<<<<<<< HEAD
 +
 +	if (ns->ms && !blk_get_integrity(disk) && (disk->flags & GENHD_FL_UP) &&
 +								!ns->ext)
++=======
+ 	if (ns->noiob)
+ 		nvme_set_chunk_size(ns);
+ 	if (ns->ms && !blk_get_integrity(disk) && !ns->ext)
++>>>>>>> 6b8190d61a62 (nvme: implement NS Optimal IO Boundary from 1.3 Spec)
  		nvme_init_integrity(ns);
 +
  	if (ns->ms && !(ns->ms == 8 && ns->pi_type) && !blk_get_integrity(disk))
  		set_capacity(disk, 0);
  	else
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index a338bbe34fd8..59c1e3ea533a 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -172,6 +172,7 @@ struct nvme_ns {
 	bool ext;
 	u8 pi_type;
 	unsigned long flags;
+	u16 noiob;
 
 #define NVME_NS_REMOVING 0
 #define NVME_NS_DEAD     1
diff --git a/include/linux/nvme.h b/include/linux/nvme.h
index 3a254de86f14..bed778087efb 100644
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@ -278,7 +278,7 @@ struct nvme_id_ns {
 	__le16			nabsn;
 	__le16			nabo;
 	__le16			nabspf;
-	__u16			rsvd46;
+	__le16			noiob;
 	__u8			nvmcap[16];
 	__u8			rsvd64[40];
 	__u8			nguid[16];
