udp: no longer use SLAB_DESTROY_BY_RCU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Dumazet <edumazet@google.com>
commit ca065d0cf80fa547724440a8bf37f1e674d917c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ca065d0c.failed

Tom Herbert would like not touching UDP socket refcnt for encapsulated
traffic. For this to happen, we need to use normal RCU rules, with a grace
period before freeing a socket. UDP sockets are not short lived in the
high usage case, so the added cost of call_rcu() should not be a concern.

This actually removes a lot of complexity in UDP stack.

Multicast receives no longer need to hold a bucket spinlock.

Note that ip early demux still needs to take a reference on the socket.

Same remark for functions used by xt_socket and xt_PROXY netfilter modules,
but this might be changed later.

Performance for a single UDP socket receiving flood traffic from
many RX queues/cpus.

Simple udp_rx using simple recvfrom() loop :
438 kpps instead of 374 kpps : 17 % increase of the peak rate.

v2: Addressed Willem de Bruijn feedback in multicast handling
 - keep early demux break in __udp4_lib_demux_lookup()

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Tom Herbert <tom@herbertland.com>
	Cc: Willem de Bruijn <willemb@google.com>
	Tested-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ca065d0cf80fa547724440a8bf37f1e674d917c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index c6e2b198be79,355bdb221057..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -171,10 -172,10 +170,9 @@@ static int udp_lib_lport_inuse2(struct 
  				struct udp_hslot *hslot2,
  				struct sock *sk,
  				int (*saddr_comp)(const struct sock *sk1,
 -						  const struct sock *sk2,
 -						  bool match_wildcard))
 +						  const struct sock *sk2))
  {
  	struct sock *sk2;
- 	struct hlist_nulls_node *node;
  	kuid_t uid = sock_i_uid(sk);
  	int res = 0;
  
@@@ -197,6 -199,34 +195,37 @@@
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ static int udp_reuseport_add_sock(struct sock *sk, struct udp_hslot *hslot,
+ 				  int (*saddr_same)(const struct sock *sk1,
+ 						    const struct sock *sk2,
+ 						    bool match_wildcard))
+ {
+ 	struct net *net = sock_net(sk);
+ 	kuid_t uid = sock_i_uid(sk);
+ 	struct sock *sk2;
+ 
+ 	sk_for_each(sk2, &hslot->head) {
+ 		if (net_eq(sock_net(sk2), net) &&
+ 		    sk2 != sk &&
+ 		    sk2->sk_family == sk->sk_family &&
+ 		    ipv6_only_sock(sk2) == ipv6_only_sock(sk) &&
+ 		    (udp_sk(sk2)->udp_port_hash == udp_sk(sk)->udp_port_hash) &&
+ 		    (sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
+ 		    sk2->sk_reuseport && uid_eq(uid, sock_i_uid(sk2)) &&
+ 		    (*saddr_same)(sk, sk2, false)) {
+ 			return reuseport_add_sock(sk, sk2);
+ 		}
+ 	}
+ 
+ 	/* Initial allocation may have already happened via setsockopt */
+ 	if (!rcu_access_pointer(sk->sk_reuseport_cb))
+ 		return reuseport_alloc(sk);
+ 	return 0;
+ }
+ 
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  /**
   *  udp_lib_get_port  -  UDP/-Lite port lookup for IPv4 and IPv6
   *
@@@ -291,19 -322,22 +320,36 @@@ found
  	udp_sk(sk)->udp_port_hash = snum;
  	udp_sk(sk)->udp_portaddr_hash ^= snum;
  	if (sk_unhashed(sk)) {
++<<<<<<< HEAD
 +		sk_nulls_add_node_rcu(sk, &hslot->head);
++=======
+ 		if (sk->sk_reuseport &&
+ 		    udp_reuseport_add_sock(sk, hslot, saddr_comp)) {
+ 			inet_sk(sk)->inet_num = 0;
+ 			udp_sk(sk)->udp_port_hash = 0;
+ 			udp_sk(sk)->udp_portaddr_hash ^= snum;
+ 			goto fail_unlock;
+ 		}
+ 
+ 		sk_add_node_rcu(sk, &hslot->head);
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  		hslot->count++;
  		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
  
  		hslot2 = udp_hashslot2(udptable, udp_sk(sk)->udp_portaddr_hash);
  		spin_lock(&hslot2->lock);
++<<<<<<< HEAD
 +		if (IS_ENABLED(CONFIG_IPV6) && sk->sk_reuseport &&
 +			sk->sk_family == AF_INET6)
 +			hlist_nulls_add_tail_rcu(&udp_sk(sk)->udp_portaddr_node,
 +						 &hslot2->head);
 +		else
 +			hlist_nulls_add_head_rcu(&udp_sk(sk)->udp_portaddr_node,
 +						 &hslot2->head);
++=======
+ 		hlist_add_head_rcu(&udp_sk(sk)->udp_portaddr_node,
+ 					 &hslot2->head);
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  		hslot2->count++;
  		spin_unlock(&hslot2->lock);
  	}
@@@ -444,10 -491,10 +491,9 @@@ static unsigned int udp_ehashfn(struct 
  static struct sock *udp4_lib_lookup2(struct net *net,
  		__be32 saddr, __be16 sport,
  		__be32 daddr, unsigned int hnum, int dif,
 -		struct udp_hslot *hslot2, unsigned int slot2,
 -		struct sk_buff *skb)
 +		struct udp_hslot *hslot2, unsigned int slot2)
  {
  	struct sock *sk, *result;
- 	struct hlist_nulls_node *node;
  	int score, badness, matches = 0, reuseport = 0;
  	u32 hash = 0;
  
@@@ -464,8 -508,14 +507,17 @@@
  			if (reuseport) {
  				hash = udp_ehashfn(net, daddr, hnum,
  						   saddr, sport);
++<<<<<<< HEAD
++=======
+ 				result = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 				if (result)
+ 					return result;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  				matches = 1;
  			}
+ 			badness = score;
+ 			result = sk;
  		} else if (score == badness && reuseport) {
  			matches++;
  			if (reciprocal_scale(hash, matches) == 0)
@@@ -473,22 -523,6 +525,25 @@@
  			hash = next_pseudo_random32(hash);
  		}
  	}
++<<<<<<< HEAD
 +	/*
 +	 * if the nulls value we got at the end of this lookup is
 +	 * not the expected one, we must restart lookup.
 +	 * We probably met an item that was moved to another chain.
 +	 */
 +	if (get_nulls_value(node) != slot2)
 +		goto begin;
 +	if (result) {
 +		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 +			result = NULL;
 +		else if (unlikely(compute_score2(result, net, saddr, sport,
 +				  daddr, hnum, dif) < badness)) {
 +			sock_put(result);
 +			goto begin;
 +		}
 +	}
++=======
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  	return result;
  }
  
@@@ -497,10 -531,9 +552,9 @@@
   */
  struct sock *__udp4_lib_lookup(struct net *net, __be32 saddr,
  		__be16 sport, __be32 daddr, __be16 dport,
 -		int dif, struct udp_table *udptable, struct sk_buff *skb)
 +		int dif, struct udp_table *udptable)
  {
  	struct sock *sk, *result;
- 	struct hlist_nulls_node *node;
  	unsigned short hnum = ntohs(dport);
  	unsigned int hash2, slot2, slot = udp_hashfn(net, hnum, udptable->mask);
  	struct udp_hslot *hslot2, *hslot = &udptable->hash[slot];
@@@ -527,9 -559,8 +580,8 @@@
  
  			result = udp4_lib_lookup2(net, saddr, sport,
  						  htonl(INADDR_ANY), hnum, dif,
 -						  hslot2, slot2, skb);
 +						  hslot2, slot2);
  		}
- 		rcu_read_unlock();
  		return result;
  	}
  begin:
@@@ -545,8 -574,14 +595,17 @@@
  			if (reuseport) {
  				hash = udp_ehashfn(net, daddr, hnum,
  						   saddr, sport);
++<<<<<<< HEAD
++=======
+ 				result = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 				if (result)
+ 					return result;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  				matches = 1;
  			}
+ 			result = sk;
+ 			badness = score;
  		} else if (score == badness && reuseport) {
  			matches++;
  			if (reciprocal_scale(hash, matches) == 0)
@@@ -554,24 -589,6 +613,27 @@@
  			hash = next_pseudo_random32(hash);
  		}
  	}
++<<<<<<< HEAD
 +	/*
 +	 * if the nulls value we got at the end of this lookup is
 +	 * not the expected one, we must restart lookup.
 +	 * We probably met an item that was moved to another chain.
 +	 */
 +	if (get_nulls_value(node) != slot)
 +		goto begin;
 +
 +	if (result) {
 +		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 +			result = NULL;
 +		else if (unlikely(compute_score(result, net, saddr, hnum, sport,
 +				  daddr, dport, dif) < badness)) {
 +			sock_put(result);
 +			goto begin;
 +		}
 +	}
 +	rcu_read_unlock();
++=======
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  	return result;
  }
  EXPORT_SYMBOL_GPL(__udp4_lib_lookup);
@@@ -582,24 -599,29 +644,43 @@@ static inline struct sock *__udp4_lib_l
  {
  	const struct iphdr *iph = ip_hdr(skb);
  
 -	return __udp4_lib_lookup(dev_net(skb_dst(skb)->dev), iph->saddr, sport,
 +	return __udp4_lib_lookup(dev_net(skb->dev), iph->saddr, sport,
  				 iph->daddr, dport, inet_iif(skb),
 -				 udptable, skb);
 +				 udptable);
  }
  
++<<<<<<< HEAD
 +struct sock *udp4_lib_lookup_skb(struct sk_buff *skb,
 +				 __be16 sport, __be16 dport)
 +{
 +	return __udp4_lib_lookup_skb(skb, sport, dport, &udp_table);
 +}
 +EXPORT_SYMBOL_GPL(udp4_lib_lookup_skb);
 +
 +struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
 +			     __be32 daddr, __be16 dport, int dif)
 +{
 +	return __udp4_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);
++=======
+ /* Must be called under rcu_read_lock().
+  * Does increment socket refcount.
+  */
+ #if IS_ENABLED(CONFIG_NETFILTER_XT_MATCH_SOCKET) || \
+     IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TPROXY)
+ struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
+ 			     __be32 daddr, __be16 dport, int dif)
+ {
+ 	struct sock *sk;
+ 
+ 	sk = __udp4_lib_lookup(net, saddr, sport, daddr, dport,
+ 			       dif, &udp_table, NULL);
+ 	if (sk && !atomic_inc_not_zero(&sk->sk_refcnt))
+ 		sk = NULL;
+ 	return sk;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  }
  EXPORT_SYMBOL_GPL(udp4_lib_lookup);
+ #endif
  
  static inline bool __udp_is_mcast_sock(struct net *net, struct sock *sk,
  				       __be16 loc_port, __be32 loc_addr,
@@@ -1499,7 -1424,9 +1580,13 @@@ void udp_lib_unhash(struct sock *sk
  		hslot2 = udp_hashslot2(udptable, udp_sk(sk)->udp_portaddr_hash);
  
  		spin_lock_bh(&hslot->lock);
++<<<<<<< HEAD
 +		if (sk_nulls_del_node_init_rcu(sk)) {
++=======
+ 		if (rcu_access_pointer(sk->sk_reuseport_cb))
+ 			reuseport_detach_sock(sk);
+ 		if (sk_del_node_init_rcu(sk)) {
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  			hslot->count--;
  			inet_sk(sk)->inet_num = 0;
  			sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
@@@ -1531,17 -1460,21 +1618,32 @@@ void udp_lib_rehash(struct sock *sk, u1
  					     udp_sk(sk)->udp_port_hash);
  			/* we must lock primary chain too */
  			spin_lock_bh(&hslot->lock);
 -			if (rcu_access_pointer(sk->sk_reuseport_cb))
 -				reuseport_detach_sock(sk);
  
++<<<<<<< HEAD
 +			spin_lock(&hslot2->lock);
 +			hlist_nulls_del_init_rcu(&udp_sk(sk)->udp_portaddr_node);
 +			hslot2->count--;
 +			spin_unlock(&hslot2->lock);
 +
 +			spin_lock(&nhslot2->lock);
 +			hlist_nulls_add_head_rcu(&udp_sk(sk)->udp_portaddr_node,
 +						 &nhslot2->head);
 +			nhslot2->count++;
 +			spin_unlock(&nhslot2->lock);
++=======
+ 			if (hslot2 != nhslot2) {
+ 				spin_lock(&hslot2->lock);
+ 				hlist_del_init_rcu(&udp_sk(sk)->udp_portaddr_node);
+ 				hslot2->count--;
+ 				spin_unlock(&hslot2->lock);
+ 
+ 				spin_lock(&nhslot2->lock);
+ 				hlist_add_head_rcu(&udp_sk(sk)->udp_portaddr_node,
+ 							 &nhslot2->head);
+ 				nhslot2->count++;
+ 				spin_unlock(&nhslot2->lock);
+ 			}
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  
  			spin_unlock_bh(&hslot->lock);
  		}
@@@ -1699,36 -1649,6 +1801,39 @@@ drop
  	return -1;
  }
  
++<<<<<<< HEAD
 +
 +static void flush_stack(struct sock **stack, unsigned int count,
 +			struct sk_buff *skb, unsigned int final)
 +{
 +	unsigned int i;
 +	struct sk_buff *skb1 = NULL;
 +	struct sock *sk;
 +
 +	for (i = 0; i < count; i++) {
 +		sk = stack[i];
 +		if (likely(skb1 == NULL))
 +			skb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);
 +
 +		if (!skb1) {
 +			atomic_inc(&sk->sk_drops);
 +			UDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,
 +					 IS_UDPLITE(sk));
 +			UDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS,
 +					 IS_UDPLITE(sk));
 +		}
 +
 +		if (skb1 && udp_queue_rcv_skb(sk, skb1) <= 0)
 +			skb1 = NULL;
 +
 +		sock_put(sk);
 +	}
 +	if (unlikely(skb1))
 +		kfree_skb(skb1);
 +}
 +
++=======
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  /* For TCP sockets, sk_rx_dst is protected by socket lock
   * For UDP, we use xchg() to guard against concurrent changes.
   */
@@@ -1749,15 -1669,17 +1854,19 @@@ static void udp_sk_rx_dst_set(struct so
  static int __udp4_lib_mcast_deliver(struct net *net, struct sk_buff *skb,
  				    struct udphdr  *uh,
  				    __be32 saddr, __be32 daddr,
 -				    struct udp_table *udptable,
 -				    int proto)
 +				    struct udp_table *udptable)
  {
- 	struct sock *sk, *stack[256 / sizeof(struct sock *)];
- 	struct hlist_nulls_node *node;
+ 	struct sock *sk, *first = NULL;
  	unsigned short hnum = ntohs(uh->dest);
  	struct udp_hslot *hslot = udp_hashslot(udptable, net, hnum);
- 	int dif = skb->dev->ifindex;
- 	unsigned int count = 0, offset = offsetof(typeof(*sk), sk_nulls_node);
  	unsigned int hash2 = 0, hash2_any = 0, use_hash2 = (hslot->count > 10);
++<<<<<<< HEAD
++=======
+ 	unsigned int offset = offsetof(typeof(*sk), sk_node);
+ 	int dif = skb->dev->ifindex;
+ 	struct hlist_node *node;
+ 	struct sk_buff *nskb;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  
  	if (use_hash2) {
  		hash2_any = udp4_portaddr_hash(net, htonl(INADDR_ANY), hnum) &
@@@ -1768,22 -1690,28 +1877,45 @@@ start_lookup
  		offset = offsetof(typeof(*sk), __sk_common.skc_portaddr_node);
  	}
  
++<<<<<<< HEAD
 +	spin_lock(&hslot->lock);
 +	sk_nulls_for_each_entry_offset(sk, node, &hslot->head, offset) {
 +		if (__udp_is_mcast_sock(net, sk,
 +					uh->dest, daddr,
 +					uh->source, saddr,
 +					dif, hnum)) {
 +			if (unlikely(count == ARRAY_SIZE(stack))) {
 +				flush_stack(stack, count, skb, ~0);
 +				count = 0;
 +			}
 +			stack[count++] = sk;
 +			sock_hold(sk);
 +		}
 +	}
++=======
+ 	sk_for_each_entry_offset_rcu(sk, node, &hslot->head, offset) {
+ 		if (!__udp_is_mcast_sock(net, sk, uh->dest, daddr,
+ 					 uh->source, saddr, dif, hnum))
+ 			continue;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
+ 
+ 		if (!first) {
+ 			first = sk;
+ 			continue;
+ 		}
+ 		nskb = skb_clone(skb, GFP_ATOMIC);
  
- 	spin_unlock(&hslot->lock);
+ 		if (unlikely(!nskb)) {
+ 			atomic_inc(&sk->sk_drops);
+ 			UDP_INC_STATS_BH(net, UDP_MIB_RCVBUFERRORS,
+ 					 IS_UDPLITE(sk));
+ 			UDP_INC_STATS_BH(net, UDP_MIB_INERRORS,
+ 					 IS_UDPLITE(sk));
+ 			continue;
+ 		}
+ 		if (udp_queue_rcv_skb(sk, nskb) > 0)
+ 			consume_skb(nskb);
+ 	}
  
  	/* Also lookup *:port if we are using hash2 and haven't done so yet. */
  	if (use_hash2 && hash2 != hash2_any) {
@@@ -1791,13 -1719,13 +1923,16 @@@
  		goto start_lookup;
  	}
  
- 	/*
- 	 * do the slow work with no lock held
- 	 */
- 	if (count) {
- 		flush_stack(stack, count, skb, count - 1);
+ 	if (first) {
+ 		if (udp_queue_rcv_skb(first, skb) > 0)
+ 			consume_skb(skb);
  	} else {
  		kfree_skb(skb);
++<<<<<<< HEAD
++=======
+ 		UDP_INC_STATS_BH(net, UDP_MIB_IGNOREDMULTI,
+ 				 proto == IPPROTO_UDPLITE);
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  	}
  	return 0;
  }
@@@ -2016,15 -1916,14 +2123,14 @@@ static struct sock *__udp4_lib_demux_lo
  	unsigned int hash2 = udp4_portaddr_hash(net, loc_addr, hnum);
  	unsigned int slot2 = hash2 & udp_table.mask;
  	struct udp_hslot *hslot2 = &udp_table.hash2[slot2];
 -	INET_ADDR_COOKIE(acookie, rmt_addr, loc_addr);
 +	INET_ADDR_COOKIE(acookie, rmt_addr, loc_addr)
  	const __portpair ports = INET_COMBINED_PORTS(rmt_port, hnum);
+ 	struct sock *sk;
  
- 	rcu_read_lock();
- 	result = NULL;
- 	udp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {
- 		if (INET_MATCH(sk, net, acookie,
- 			       rmt_addr, loc_addr, ports, dif))
- 			result = sk;
+ 	udp_portaddr_for_each_entry_rcu(sk, &hslot2->head) {
+ 		if (INET_MATCH(sk, net, acookie, rmt_addr,
+ 			       loc_addr, ports, dif))
+ 			return sk;
  		/* Only check first socket in chain */
  		break;
  	}
diff --cc net/ipv6/udp.c
index f5a8a12b48a5,78a7dfd12707..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -232,10 -209,10 +232,9 @@@ static inline int compute_score2(struc
  static struct sock *udp6_lib_lookup2(struct net *net,
  		const struct in6_addr *saddr, __be16 sport,
  		const struct in6_addr *daddr, unsigned int hnum, int dif,
 -		struct udp_hslot *hslot2, unsigned int slot2,
 -		struct sk_buff *skb)
 +		struct udp_hslot *hslot2, unsigned int slot2)
  {
  	struct sock *sk, *result;
- 	struct hlist_nulls_node *node;
  	int score, badness, matches = 0, reuseport = 0;
  	u32 hash = 0;
  
@@@ -252,9 -226,15 +248,21 @@@
  			if (reuseport) {
  				hash = udp6_ehashfn(net, daddr, hnum,
  						    saddr, sport);
++<<<<<<< HEAD
 +				matches = 1;
 +			} else if (score == SCORE2_MAX)
 +				goto exact_match;
++=======
+ 
+ 				result = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 				if (result)
+ 					return result;
+ 				matches = 1;
+ 			}
+ 			result = sk;
+ 			badness = score;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  		} else if (score == badness && reuseport) {
  			matches++;
  			if (reciprocal_scale(hash, matches) == 0)
@@@ -262,24 -242,6 +270,27 @@@
  			hash = next_pseudo_random32(hash);
  		}
  	}
++<<<<<<< HEAD
 +	/*
 +	 * if the nulls value we got at the end of this lookup is
 +	 * not the expected one, we must restart lookup.
 +	 * We probably met an item that was moved to another chain.
 +	 */
 +	if (get_nulls_value(node) != slot2)
 +		goto begin;
 +
 +	if (result) {
 +exact_match:
 +		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 +			result = NULL;
 +		else if (unlikely(compute_score2(result, net, saddr, sport,
 +				  daddr, hnum, dif) < badness)) {
 +			sock_put(result);
 +			goto begin;
 +		}
 +	}
++=======
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  	return result;
  }
  
@@@ -286,10 -249,10 +298,9 @@@
  struct sock *__udp6_lib_lookup(struct net *net,
  				      const struct in6_addr *saddr, __be16 sport,
  				      const struct in6_addr *daddr, __be16 dport,
 -				      int dif, struct udp_table *udptable,
 -				      struct sk_buff *skb)
 +				      int dif, struct udp_table *udptable)
  {
  	struct sock *sk, *result;
- 	struct hlist_nulls_node *node;
  	unsigned short hnum = ntohs(dport);
  	unsigned int hash2, slot2, slot = udp_hashfn(net, hnum, udptable->mask);
  	struct udp_hslot *hslot2, *hslot = &udptable->hash[slot];
@@@ -316,9 -278,8 +326,8 @@@
  
  			result = udp6_lib_lookup2(net, saddr, sport,
  						  &in6addr_any, hnum, dif,
 -						  hslot2, slot2, skb);
 +						  hslot2, slot2);
  		}
- 		rcu_read_unlock();
  		return result;
  	}
  begin:
@@@ -333,8 -292,14 +340,17 @@@
  			if (reuseport) {
  				hash = udp6_ehashfn(net, daddr, hnum,
  						    saddr, sport);
++<<<<<<< HEAD
++=======
+ 				result = reuseport_select_sock(sk, hash, skb,
+ 							sizeof(struct udphdr));
+ 				if (result)
+ 					return result;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  				matches = 1;
  			}
+ 			result = sk;
+ 			badness = score;
  		} else if (score == badness && reuseport) {
  			matches++;
  			if (reciprocal_scale(hash, matches) == 0)
@@@ -342,24 -307,6 +358,27 @@@
  			hash = next_pseudo_random32(hash);
  		}
  	}
++<<<<<<< HEAD
 +	/*
 +	 * if the nulls value we got at the end of this lookup is
 +	 * not the expected one, we must restart lookup.
 +	 * We probably met an item that was moved to another chain.
 +	 */
 +	if (get_nulls_value(node) != slot)
 +		goto begin;
 +
 +	if (result) {
 +		if (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))
 +			result = NULL;
 +		else if (unlikely(compute_score(result, net, hnum, saddr, sport,
 +					daddr, dport, dif) < badness)) {
 +			sock_put(result);
 +			goto begin;
 +		}
 +	}
 +	rcu_read_unlock();
++=======
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  	return result;
  }
  EXPORT_SYMBOL_GPL(__udp6_lib_lookup);
@@@ -374,37 -321,36 +393,56 @@@ static struct sock *__udp6_lib_lookup_s
  	sk = skb_steal_sock(skb);
  	if (unlikely(sk))
  		return sk;
 -	return __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,
 +	return __udp6_lib_lookup(dev_net(skb->dev), &iph->saddr, sport,
 +				 &iph->daddr, dport, inet6_iif(skb),
 +				 udptable);
 +}
 +
++<<<<<<< HEAD
 +struct sock *udp6_lib_lookup_skb(struct sk_buff *skb,
 +				 __be16 sport, __be16 dport)
 +{
 +	const struct ipv6hdr *iph = ipv6_hdr(skb);
 +
 +	return __udp6_lib_lookup(dev_net(skb->dev), &iph->saddr, sport,
  				 &iph->daddr, dport, inet6_iif(skb),
 -				 udptable, skb);
 +				 &udp_table);
  }
 +EXPORT_SYMBOL_GPL(udp6_lib_lookup_skb);
  
 +struct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
 +			     const struct in6_addr *daddr, __be16 dport, int dif)
 +{
 +	return __udp6_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);
++=======
+ /* Must be called under rcu_read_lock().
+  * Does increment socket refcount.
+  */
+ #if IS_ENABLED(CONFIG_NETFILTER_XT_MATCH_SOCKET) || \
+     IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TPROXY)
+ struct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,
+ 			     const struct in6_addr *daddr, __be16 dport, int dif)
+ {
+ 	struct sock *sk;
+ 
+ 	sk =  __udp6_lib_lookup(net, saddr, sport, daddr, dport,
+ 				dif, &udp_table, NULL);
+ 	if (sk && !atomic_inc_not_zero(&sk->sk_refcnt))
+ 		sk = NULL;
+ 	return sk;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  }
  EXPORT_SYMBOL_GPL(udp6_lib_lookup);
+ #endif
  
 +
  /*
 - *	This should be easy, if there is something there we
 - *	return it, otherwise we block.
 + * 	This should be easy, if there is something there we
 + * 	return it, otherwise we block.
   */
  
 -int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 +int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 +		  struct msghdr *msg, size_t len,
  		  int noblock, int flags, int *addr_len)
  {
  	struct ipv6_pinfo *np = inet6_sk(sk);
@@@ -741,33 -703,6 +779,36 @@@ static bool __udp_v6_is_mcast_sock(stru
  	return true;
  }
  
++<<<<<<< HEAD
 +static void flush_stack(struct sock **stack, unsigned int count,
 +			struct sk_buff *skb, unsigned int final)
 +{
 +	struct sk_buff *skb1 = NULL;
 +	struct sock *sk;
 +	unsigned int i;
 +
 +	for (i = 0; i < count; i++) {
 +		sk = stack[i];
 +		if (likely(skb1 == NULL))
 +			skb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);
 +		if (!skb1) {
 +			atomic_inc(&sk->sk_drops);
 +			UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,
 +					  IS_UDPLITE(sk));
 +			UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS,
 +					  IS_UDPLITE(sk));
 +		}
 +
 +		if (skb1 && udpv6_queue_rcv_skb(sk, skb1) <= 0)
 +			skb1 = NULL;
 +		sock_put(sk);
 +	}
 +	if (unlikely(skb1))
 +		kfree_skb(skb1);
 +}
 +
++=======
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  static void udp6_csum_zero_error(struct sk_buff *skb)
  {
  	/* RFC 2460 section 8.1 says that we SHOULD log
@@@ -784,16 -719,17 +825,20 @@@
   */
  static int __udp6_lib_mcast_deliver(struct net *net, struct sk_buff *skb,
  		const struct in6_addr *saddr, const struct in6_addr *daddr,
 -		struct udp_table *udptable, int proto)
 +		struct udp_table *udptable)
  {
- 	struct sock *sk, *stack[256 / sizeof(struct sock *)];
+ 	struct sock *sk, *first = NULL;
  	const struct udphdr *uh = udp_hdr(skb);
- 	struct hlist_nulls_node *node;
  	unsigned short hnum = ntohs(uh->dest);
  	struct udp_hslot *hslot = udp_hashslot(udptable, net, hnum);
- 	int dif = inet6_iif(skb);
- 	unsigned int count = 0, offset = offsetof(typeof(*sk), sk_nulls_node);
+ 	unsigned int offset = offsetof(typeof(*sk), sk_node);
  	unsigned int hash2 = 0, hash2_any = 0, use_hash2 = (hslot->count > 10);
++<<<<<<< HEAD
++=======
+ 	int dif = inet6_iif(skb);
+ 	struct hlist_node *node;
+ 	struct sk_buff *nskb;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  
  	if (use_hash2) {
  		hash2_any = udp6_portaddr_hash(net, &in6addr_any, hnum) &
@@@ -804,26 -740,32 +849,51 @@@ start_lookup
  		offset = offsetof(typeof(*sk), __sk_common.skc_portaddr_node);
  	}
  
++<<<<<<< HEAD
 +	spin_lock(&hslot->lock);
 +	sk_nulls_for_each_entry_offset(sk, node, &hslot->head, offset) {
 +		if (__udp_v6_is_mcast_sock(net, sk,
 +					   uh->dest, daddr,
 +					   uh->source, saddr,
 +					   dif, hnum) &&
 +		    /* If zero checksum and no_check is not on for
 +		     * the socket then skip it.
 +		     */
 +		    (uh->check || udp_sk(sk)->no_check6_rx)) {
 +			if (unlikely(count == ARRAY_SIZE(stack))) {
 +				flush_stack(stack, count, skb, ~0);
 +				count = 0;
 +			}
 +			stack[count++] = sk;
 +			sock_hold(sk);
++=======
+ 	sk_for_each_entry_offset_rcu(sk, node, &hslot->head, offset) {
+ 		if (!__udp_v6_is_mcast_sock(net, sk, uh->dest, daddr,
+ 					    uh->source, saddr, dif, hnum))
+ 			continue;
+ 		/* If zero checksum and no_check is not on for
+ 		 * the socket then skip it.
+ 		 */
+ 		if (!uh->check && !udp_sk(sk)->no_check6_rx)
+ 			continue;
+ 		if (!first) {
+ 			first = sk;
+ 			continue;
+ 		}
+ 		nskb = skb_clone(skb, GFP_ATOMIC);
+ 		if (unlikely(!nskb)) {
+ 			atomic_inc(&sk->sk_drops);
+ 			UDP6_INC_STATS_BH(net, UDP_MIB_RCVBUFERRORS,
+ 					  IS_UDPLITE(sk));
+ 			UDP6_INC_STATS_BH(net, UDP_MIB_INERRORS,
+ 					  IS_UDPLITE(sk));
+ 			continue;
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  		}
- 	}
  
- 	spin_unlock(&hslot->lock);
+ 		if (udpv6_queue_rcv_skb(sk, nskb) > 0)
+ 			consume_skb(nskb);
+ 	}
  
  	/* Also lookup *:port if we are using hash2 and haven't done so yet. */
  	if (use_hash2 && hash2 != hash2_any) {
@@@ -831,10 -773,13 +901,16 @@@
  		goto start_lookup;
  	}
  
- 	if (count) {
- 		flush_stack(stack, count, skb, count - 1);
+ 	if (first) {
+ 		if (udpv6_queue_rcv_skb(first, skb) > 0)
+ 			consume_skb(skb);
  	} else {
  		kfree_skb(skb);
++<<<<<<< HEAD
++=======
+ 		UDP6_INC_STATS_BH(net, UDP_MIB_IGNOREDMULTI,
+ 				  proto == IPPROTO_UDPLITE);
++>>>>>>> ca065d0cf80f (udp: no longer use SLAB_DESTROY_BY_RCU)
  	}
  	return 0;
  }
@@@ -909,13 -853,10 +984,12 @@@ int __udp6_lib_rcv(struct sk_buff *skb
  						 ip6_compute_pseudo);
  
  		ret = udpv6_queue_rcv_skb(sk, skb);
- 		sock_put(sk);
  
 -		/* a return value > 0 means to resubmit the input */
 +		/* a return value > 0 means to resubmit the input, but
 +		 * it wants the return to be -protocol, or 0
 +		 */
  		if (ret > 0)
 -			return ret;
 +			return -ret;
  
  		return 0;
  	}
diff --git a/include/linux/udp.h b/include/linux/udp.h
index 33da22a7fe02..3b44c8aa0d07 100644
--- a/include/linux/udp.h
+++ b/include/linux/udp.h
@@ -106,11 +106,11 @@ static inline bool udp_get_no_check6_rx(struct sock *sk)
 	return udp_sk(sk)->no_check6_rx;
 }
 
-#define udp_portaddr_for_each_entry(__sk, node, list) \
-	hlist_nulls_for_each_entry(__sk, node, list, __sk_common.skc_portaddr_node)
+#define udp_portaddr_for_each_entry(__sk, list) \
+	hlist_for_each_entry(__sk, list, __sk_common.skc_portaddr_node)
 
-#define udp_portaddr_for_each_entry_rcu(__sk, node, list) \
-	hlist_nulls_for_each_entry_rcu(__sk, node, list, __sk_common.skc_portaddr_node)
+#define udp_portaddr_for_each_entry_rcu(__sk, list) \
+	hlist_for_each_entry_rcu(__sk, list, __sk_common.skc_portaddr_node)
 
 #define IS_UDPLITE(__sk) (udp_sk(__sk)->pcflag)
 
diff --git a/include/net/sock.h b/include/net/sock.h
index f6191ea845e2..38495a20c8ec 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -193,7 +193,7 @@ struct sock_common {
 	int			skc_bound_dev_if;
 	union {
 		struct hlist_node	skc_bind_node;
-		struct hlist_nulls_node skc_portaddr_node;
+		struct hlist_node	skc_portaddr_node;
 	};
 	struct proto		*skc_prot;
 	possible_net_t		skc_net;
@@ -689,18 +689,18 @@ static inline void sk_add_bind_node(struct sock *sk,
 	hlist_for_each_entry(__sk, list, sk_bind_node)
 
 /**
- * sk_nulls_for_each_entry_offset - iterate over a list at a given struct offset
+ * sk_for_each_entry_offset_rcu - iterate over a list at a given struct offset
  * @tpos:	the type * to use as a loop cursor.
  * @pos:	the &struct hlist_node to use as a loop cursor.
  * @head:	the head for your list.
  * @offset:	offset of hlist_node within the struct.
  *
  */
-#define sk_nulls_for_each_entry_offset(tpos, pos, head, offset)		       \
-	for (pos = (head)->first;					       \
-	     (!is_a_nulls(pos)) &&					       \
+#define sk_for_each_entry_offset_rcu(tpos, pos, head, offset)		       \
+	for (pos = rcu_dereference((head)->first);			       \
+	     pos != NULL &&						       \
 		({ tpos = (typeof(*tpos) *)((void *)pos - offset); 1;});       \
-	     pos = pos->next)
+	     pos = rcu_dereference(pos->next))
 
 static inline struct user_namespace *sk_user_ns(struct sock *sk)
 {
diff --git a/include/net/udp.h b/include/net/udp.h
index 886fb5efc132..b23f169bc0ec 100644
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@ -59,7 +59,7 @@ struct udp_skb_cb {
  *	@lock:	spinlock protecting changes to head/count
  */
 struct udp_hslot {
-	struct hlist_nulls_head	head;
+	struct hlist_head	head;
 	int			count;
 	spinlock_t		lock;
 } __attribute__((aligned(2 * sizeof(long))));
* Unmerged path net/ipv4/udp.c
diff --git a/net/ipv4/udp_diag.c b/net/ipv4/udp_diag.c
index 47ac0ba8eb6c..c07c49454e4e 100644
--- a/net/ipv4/udp_diag.c
+++ b/net/ipv4/udp_diag.c
@@ -36,10 +36,11 @@ static int udp_dump_one(struct udp_table *tbl, struct sk_buff *in_skb,
 			const struct inet_diag_req_v2 *req)
 {
 	int err = -EINVAL;
-	struct sock *sk;
+	struct sock *sk = NULL;
 	struct sk_buff *rep;
 	struct net *net = sock_net(in_skb->sk);
 
+	rcu_read_lock();
 	if (req->sdiag_family == AF_INET)
 		sk = __udp4_lib_lookup(net,
 				req->id.idiag_src[0], req->id.idiag_sport,
@@ -54,9 +55,9 @@ static int udp_dump_one(struct udp_table *tbl, struct sk_buff *in_skb,
 				req->id.idiag_dport,
 				req->id.idiag_if, tbl);
 #endif
-	else
-		goto out_nosk;
-
+	if (sk && !atomic_inc_not_zero(&sk->sk_refcnt))
+		sk = NULL;
+	rcu_read_unlock();
 	err = -ENOENT;
 	if (sk == NULL)
 		goto out_nosk;
@@ -96,24 +97,23 @@ static void udp_dump(struct udp_table *table, struct sk_buff *skb,
 		     struct netlink_callback *cb,
 		     const struct inet_diag_req_v2 *r, struct nlattr *bc)
 {
-	int num, s_num, slot, s_slot;
 	struct net *net = sock_net(skb->sk);
+	int num, s_num, slot, s_slot;
 
 	s_slot = cb->args[0];
 	num = s_num = cb->args[1];
 
 	for (slot = s_slot; slot <= table->mask; s_num = 0, slot++) {
-		struct sock *sk;
-		struct hlist_nulls_node *node;
 		struct udp_hslot *hslot = &table->hash[slot];
+		struct sock *sk;
 
 		num = 0;
 
-		if (hlist_nulls_empty(&hslot->head))
+		if (hlist_empty(&hslot->head))
 			continue;
 
 		spin_lock_bh(&hslot->lock);
-		sk_nulls_for_each(sk, node, &hslot->head) {
+		sk_for_each(sk, &hslot->head) {
 			struct inet_sock *inet = inet_sk(sk);
 
 			if (!net_eq(sock_net(sk), net))
* Unmerged path net/ipv6/udp.c
