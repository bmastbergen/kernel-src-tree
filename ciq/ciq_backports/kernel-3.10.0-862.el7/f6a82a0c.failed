ALSA: x86: Drop superfluous PCM private_free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit f6a82a0c01e51dd494b6eb68861473368355e58b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f6a82a0c.failed

snd_pcm_lib_preallocate_free_for_all() doesn't have to be called from
each driver as it's called in the PCM core.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit f6a82a0c01e51dd494b6eb68861473368355e58b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index f2f54691cb43,28eb980d2d2e..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -1461,56 -1430,368 +1461,59 @@@ out
  	return retval;
  }
  
 -/*
 - * hdmi_lpe_audio_suspend - power management suspend function
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
 +	.open =		snd_intelhad_open,
 +	.close =	snd_intelhad_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_intelhad_hw_params,
 +	.hw_free =	snd_intelhad_hw_free,
 +	.prepare =	snd_intelhad_pcm_prepare,
 +	.trigger =	snd_intelhad_pcm_trigger,
 +	.pointer =	snd_intelhad_pcm_pointer,
 +	.mmap =	snd_intelhad_pcm_mmap,
 +};
 +
++<<<<<<< HEAD
 +/**
 + * snd_intelhad_create - to crete alsa card instance
   *
 - * @pdev: platform device
 + * @intelhaddata: pointer to internal context
 + * @card: pointer to card
   *
 - * This function is called by client driver to suspend the
 - * hdmi audio.
 + * This function is called when the hdmi cable is plugged in
   */
 -static int hdmi_lpe_audio_suspend(struct platform_device *pdev,
 -				  pm_message_t state)
 +static int snd_intelhad_create(
 +		struct snd_intelhad *intelhaddata,
 +		struct snd_card *card)
  {
 -	struct had_stream_data *had_stream;
 -	unsigned long flag_irqs;
 -	struct snd_pcm_substream *substream;
 -	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
 -
 -	had_stream = &intelhaddata->stream_data;
 -	substream = intelhaddata->stream_info.had_substream;
 -
 -	if (!pm_runtime_status_suspended(intelhaddata->dev)) {
 -		dev_err(intelhaddata->dev, "audio stream is active\n");
 -		return -EAGAIN;
 -	}
 -
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		dev_dbg(intelhaddata->dev, "had not connected\n");
 -		return 0;
 -	}
 +	int retval;
 +	static struct snd_device_ops ops = {
 +	};
  
 -	if (intelhaddata->drv_status == HAD_DRV_SUSPENDED) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		dev_dbg(intelhaddata->dev, "had already suspended\n");
 -		return 0;
 -	}
 +	pr_debug("snd_intelhad_create called\n");
  
 -	intelhaddata->drv_status = HAD_DRV_SUSPENDED;
 -	dev_dbg(intelhaddata->dev,
 -		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_SUSPENDED\n",
 -			__func__, __LINE__);
 +	if (!intelhaddata)
 +		return -EINVAL;
  
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -	snd_intelhad_enable_audio_int(intelhaddata, false);
 -	return 0;
 +	/* ALSA api to register the device */
 +	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelhaddata, &ops);
 +	return retval;
  }
 -
 -/*
 - * hdmi_lpe_audio_resume - power management resume function
 - *
 - *@pdev: platform device
 +/**
 + * snd_intelhad_pcm_free - to free the memory allocated
   *
 - * This function is called by client driver to resume the
 - * hdmi audio.
 + * @pcm: pointer to pcm instance
 + * This function is called when the device is removed
   */
 -static int hdmi_lpe_audio_resume(struct platform_device *pdev)
 -{
 -	struct snd_intelhad *intelhaddata = platform_get_drvdata(pdev);
 -	unsigned long flag_irqs;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		dev_dbg(intelhaddata->dev, "had not connected\n");
 -		return 0;
 -	}
 -
 -	if (intelhaddata->drv_status != HAD_DRV_SUSPENDED) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		dev_err(intelhaddata->dev, "had is not in suspended state\n");
 -		return 0;
 -	}
 -
 -	if (had_get_hwstate(intelhaddata)) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		dev_err(intelhaddata->dev,
 -			"Failed to resume. Device not accessible\n");
 -		return -ENODEV;
 -	}
 -
 -	intelhaddata->drv_status = HAD_DRV_CONNECTED;
 -	dev_dbg(intelhaddata->dev,
 -		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 -			__func__, __LINE__);
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -	snd_intelhad_enable_audio_int(intelhaddata, true);
 -	return 0;
 -}
 -
 -static inline int had_chk_intrmiss(struct snd_intelhad *intelhaddata,
 -		enum intel_had_aud_buf_type buf_id)
 +static void snd_intelhad_pcm_free(struct snd_pcm *pcm)
  {
 -	int i, intr_count = 0;
 -	enum intel_had_aud_buf_type buff_done;
 -	u32 buf_size, buf_addr;
 -	struct had_stream_data *had_stream;
 -	unsigned long flag_irqs;
 -
 -	had_stream = &intelhaddata->stream_data;
 -
 -	buff_done = buf_id;
 -
 -	intr_count = snd_intelhad_read_len(intelhaddata);
 -	if (intr_count > 1) {
 -		/* In case of active playback */
 -		dev_err(intelhaddata->dev,
 -			"Driver detected %d missed buffer done interrupt(s)\n",
 -			(intr_count - 1));
 -		if (intr_count > 3)
 -			return intr_count;
 -
 -		buf_id += (intr_count - 1);
 -		/* Reprogram registers*/
 -		for (i = buff_done; i < buf_id; i++) {
 -			int j = i % 4;
 -
 -			buf_size = intelhaddata->buf_info[j].buf_size;
 -			buf_addr = intelhaddata->buf_info[j].buf_addr;
 -			had_write_register(intelhaddata,
 -					   AUD_BUF_A_LENGTH +
 -					   (j * HAD_REG_WIDTH), buf_size);
 -			had_write_register(intelhaddata,
 -					   AUD_BUF_A_ADDR+(j * HAD_REG_WIDTH),
 -					   (buf_addr | BIT(0) | BIT(1)));
 -		}
 -		buf_id = buf_id % 4;
 -		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -		intelhaddata->buff_done = buf_id;
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -	}
 -
 -	return intr_count;
 +	pr_debug("Freeing PCM preallocated pages\n");
 +	snd_pcm_lib_preallocate_free_for_all(pcm);
  }
  
 -static int had_process_buffer_done(struct snd_intelhad *intelhaddata)
 -{
 -	u32 len = 1;
 -	enum intel_had_aud_buf_type buf_id;
 -	enum intel_had_aud_buf_type buff_done;
 -	struct pcm_stream_info *stream;
 -	u32 buf_size;
 -	struct had_stream_data *had_stream;
 -	int intr_count;
 -	enum had_status_stream		stream_type;
 -	unsigned long flag_irqs;
 -
 -	had_stream = &intelhaddata->stream_data;
 -	stream = &intelhaddata->stream_info;
 -	intr_count = 1;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		dev_dbg(intelhaddata->dev,
 -			"%s:Device already disconnected\n", __func__);
 -		return 0;
 -	}
 -	buf_id = intelhaddata->curr_buf;
 -	intelhaddata->buff_done = buf_id;
 -	buff_done = intelhaddata->buff_done;
 -	buf_size = intelhaddata->buf_info[buf_id].buf_size;
 -	stream_type = had_stream->stream_type;
 -
 -	/* Every debug statement has an implication
 -	 * of ~5msec. Thus, avoid having >3 debug statements
 -	 * for each buffer_done handling.
 -	 */
 -
 -	/* Check for any intr_miss in case of active playback */
 -	if (had_stream->stream_type == HAD_RUNNING_STREAM) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		intr_count = had_chk_intrmiss(intelhaddata, buf_id);
 -		if (!intr_count || (intr_count > 3)) {
 -			dev_err(intelhaddata->dev,
 -				"HAD SW state in non-recoverable mode\n");
 -			return 0;
 -		}
 -		buf_id += (intr_count - 1);
 -		buf_id = buf_id % 4;
 -		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	}
 -
 -	intelhaddata->buf_info[buf_id].is_valid = true;
 -	if (intelhaddata->valid_buf_cnt-1 == buf_id) {
 -		if (had_stream->stream_type >= HAD_RUNNING_STREAM)
 -			intelhaddata->curr_buf = HAD_BUF_TYPE_A;
 -	} else
 -		intelhaddata->curr_buf = buf_id + 1;
 -
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -
 -	if (had_get_hwstate(intelhaddata)) {
 -		dev_dbg(intelhaddata->dev, "HDMI cable plugged-out\n");
 -		return 0;
 -	}
 -
 -	/*Reprogram the registers with addr and length*/
 -	had_write_register(intelhaddata,
 -			   AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
 -			   buf_size);
 -	had_write_register(intelhaddata,
 -			   AUD_BUF_A_ADDR + (buf_id * HAD_REG_WIDTH),
 -			   intelhaddata->buf_info[buf_id].buf_addr |
 -			   BIT(0) | BIT(1));
 -
 -	had_read_register(intelhaddata,
 -			  AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH),
 -			  &len);
 -	dev_dbg(intelhaddata->dev, "%s:Enabled buf[%d]\n", __func__, buf_id);
 -
 -	/* In case of actual data,
 -	 * report buffer_done to above ALSA layer
 -	 */
 -	buf_size = intelhaddata->buf_info[buf_id].buf_size;
 -	if (stream_type >= HAD_RUNNING_STREAM) {
 -		intelhaddata->stream_info.buffer_rendered +=
 -			(intr_count * buf_size);
 -		had_period_elapsed(stream->had_substream);
 -	}
 -
 -	return 0;
 -}
 -
 -static int had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
 -{
 -	enum intel_had_aud_buf_type buf_id;
 -	struct pcm_stream_info *stream;
 -	struct had_stream_data *had_stream;
 -	enum had_status_stream stream_type;
 -	unsigned long flag_irqs;
 -	int drv_status;
 -
 -	had_stream = &intelhaddata->stream_data;
 -	stream = &intelhaddata->stream_info;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	buf_id = intelhaddata->curr_buf;
 -	stream_type = had_stream->stream_type;
 -	intelhaddata->buff_done = buf_id;
 -	drv_status = intelhaddata->drv_status;
 -	if (stream_type == HAD_RUNNING_STREAM)
 -		intelhaddata->curr_buf = HAD_BUF_TYPE_A;
 -
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -
 -	dev_dbg(intelhaddata->dev, "Enter:%s buf_id=%d, stream_type=%d\n",
 -			__func__, buf_id, stream_type);
 -
 -	snd_intelhad_handle_underrun(intelhaddata);
 -
 -	if (drv_status == HAD_DRV_DISCONNECTED) {
 -		dev_dbg(intelhaddata->dev,
 -			"%s:Device already disconnected\n", __func__);
 -		return 0;
 -	}
 -
 -	if (stream_type == HAD_RUNNING_STREAM) {
 -		/* Report UNDERRUN error to above layers */
 -		intelhaddata->flag_underrun = true;
 -		had_period_elapsed(stream->had_substream);
 -	}
 -
 -	return 0;
 -}
 -
 -static int had_process_hot_plug(struct snd_intelhad *intelhaddata)
 -{
 -	enum intel_had_aud_buf_type buf_id;
 -	struct snd_pcm_substream *substream;
 -	struct had_stream_data *had_stream;
 -	unsigned long flag_irqs;
 -
 -	substream = intelhaddata->stream_info.had_substream;
 -	had_stream = &intelhaddata->stream_data;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	if (intelhaddata->drv_status == HAD_DRV_CONNECTED) {
 -		dev_dbg(intelhaddata->dev, "Device already connected\n");
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		return 0;
 -	}
 -	buf_id = intelhaddata->curr_buf;
 -	intelhaddata->buff_done = buf_id;
 -	intelhaddata->drv_status = HAD_DRV_CONNECTED;
 -	dev_dbg(intelhaddata->dev,
 -		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
 -			__func__, __LINE__);
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -
 -	dev_dbg(intelhaddata->dev, "Processing HOT_PLUG, buf_id = %d\n",
 -		buf_id);
 -
 -	/* Safety check */
 -	if (substream) {
 -		dev_dbg(intelhaddata->dev,
 -			"Force to stop the active stream by disconnection\n");
 -		/* Set runtime->state to hw_params done */
 -		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
 -	}
 -
 -	had_build_channel_allocation_map(intelhaddata);
 -
 -	return 0;
 -}
 -
 -static int had_process_hot_unplug(struct snd_intelhad *intelhaddata)
 -{
 -	enum intel_had_aud_buf_type buf_id;
 -	struct had_stream_data *had_stream;
 -	unsigned long flag_irqs;
 -
 -	had_stream = &intelhaddata->stream_data;
 -	buf_id = intelhaddata->curr_buf;
 -
 -	spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -
 -	if (intelhaddata->drv_status == HAD_DRV_DISCONNECTED) {
 -		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		return 0;
 -
 -	} else {
 -		/* Disable Audio */
 -		snd_intelhad_enable_audio_int(intelhaddata, false);
 -		snd_intelhad_enable_audio(intelhaddata, false);
 -	}
 -
 -	intelhaddata->drv_status = HAD_DRV_DISCONNECTED;
 -	dev_dbg(intelhaddata->dev,
 -		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
 -			__func__, __LINE__);
 -
 -	/* Report to above ALSA layer */
 -	if (intelhaddata->stream_info.had_substream != NULL) {
 -		spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -		snd_pcm_stop(intelhaddata->stream_info.had_substream,
 -				SNDRV_PCM_STATE_SETUP);
 -		spin_lock_irqsave(&intelhaddata->had_spinlock, flag_irqs);
 -	}
 -
 -	had_stream->stream_type = HAD_INIT;
 -	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flag_irqs);
 -	kfree(intelhaddata->chmap->chmap);
 -	intelhaddata->chmap->chmap = NULL;
 -
 -	return 0;
 -}
 -
 -/* PCM operations structure and the calls back for the same */
 -static struct snd_pcm_ops snd_intelhad_playback_ops = {
 -	.open =		snd_intelhad_open,
 -	.close =	snd_intelhad_close,
 -	.ioctl =	snd_pcm_lib_ioctl,
 -	.hw_params =	snd_intelhad_hw_params,
 -	.hw_free =	snd_intelhad_hw_free,
 -	.prepare =	snd_intelhad_pcm_prepare,
 -	.trigger =	snd_intelhad_pcm_trigger,
 -	.pointer =	snd_intelhad_pcm_pointer,
 -	.mmap =	snd_intelhad_pcm_mmap,
 -};
 -
++=======
++>>>>>>> f6a82a0c01e5 (ALSA: x86: Drop superfluous PCM private_free)
  static int had_iec958_info(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_info *uinfo)
  {
@@@ -1634,11 -2051,10 +1637,15 @@@ int hdmi_audio_probe(struct platform_de
  		goto err;
  
  	/* setup private data which can be retrieved when required */
++<<<<<<< HEAD
 +	pcm->private_data = intelhaddata;
 +	pcm->private_free = snd_intelhad_pcm_free;
++=======
+ 	pcm->private_data = ctx;
++>>>>>>> f6a82a0c01e5 (ALSA: x86: Drop superfluous PCM private_free)
  	pcm->info_flags = 0;
  	strncpy(pcm->name, card->shortname, strlen(card->shortname));
 -	/* setup the ops for playabck */
 +	/* setup the ops for palyabck */
  	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
  			    &snd_intelhad_playback_ops);
  	/* allocate dma pages for ALSA stream operations
* Unmerged path sound/x86/intel_hdmi_audio.c
