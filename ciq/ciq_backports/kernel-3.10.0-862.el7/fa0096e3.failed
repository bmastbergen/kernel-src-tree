ovl: do not cleanup unsupported index entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit fa0096e3bad69ed6f34843fd7ae1c45ca987012a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fa0096e3.failed

With index=on, ovl_indexdir_cleanup() tries to cleanup invalid index
entries (e.g. bad index name). This behavior could result in cleaning of
entries created by newer kernels and is therefore undesirable.
Instead, abort mount if such entries are encountered. We still cleanup
'stale' entries and 'orphan' entries, both those cases can be a result
of offline changes to lower and upper dirs.

When encoutering an index entry of type directory or whiteout, kernel
was supposed to fallback to read-only mount, but the fill_super()
operation returns EROFS in this case instead of returning success with
read-only mount flag, so mount fails when encoutering directory or
whiteout index entries. Bless this behavior by returning -EINVAL on
directory and whiteout index entries as we do for all unsupported index
entries.

Fixes: 61b674710cd9 ("ovl: do not cleanup directory and whiteout index..")
	Cc: <stable@vger.kernel.org> # v4.13
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
(cherry picked from commit fa0096e3bad69ed6f34843fd7ae1c45ca987012a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/namei.c
#	fs/overlayfs/readdir.c
diff --cc fs/overlayfs/readdir.c
index 2010cf9bd904,698b74dd750e..000000000000
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@@ -678,3 -983,58 +678,61 @@@ void ovl_workdir_cleanup(struct inode *
  		ovl_cleanup(dir, dentry);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
+ 			 struct path *lowerstack, unsigned int numlower)
+ {
+ 	int err;
+ 	struct dentry *index = NULL;
+ 	struct inode *dir = dentry->d_inode;
+ 	struct path path = { .mnt = mnt, .dentry = dentry };
+ 	LIST_HEAD(list);
+ 	struct rb_root root = RB_ROOT;
+ 	struct ovl_cache_entry *p;
+ 	struct ovl_readdir_data rdd = {
+ 		.ctx.actor = ovl_fill_merge,
+ 		.dentry = NULL,
+ 		.list = &list,
+ 		.root = &root,
+ 		.is_lowest = false,
+ 	};
+ 
+ 	err = ovl_dir_read(&path, &rdd);
+ 	if (err)
+ 		goto out;
+ 
+ 	inode_lock_nested(dir, I_MUTEX_PARENT);
+ 	list_for_each_entry(p, &list, l_node) {
+ 		if (p->name[0] == '.') {
+ 			if (p->len == 1)
+ 				continue;
+ 			if (p->len == 2 && p->name[1] == '.')
+ 				continue;
+ 		}
+ 		index = lookup_one_len(p->name, dentry, p->len);
+ 		if (IS_ERR(index)) {
+ 			err = PTR_ERR(index);
+ 			index = NULL;
+ 			break;
+ 		}
+ 		err = ovl_verify_index(index, lowerstack, numlower);
+ 		/* Cleanup stale and orphan index entries */
+ 		if (err && (err == -ESTALE || err == -ENOENT))
+ 			err = ovl_cleanup(dir, index);
+ 		if (err)
+ 			break;
+ 
+ 		dput(index);
+ 		index = NULL;
+ 	}
+ 	dput(index);
+ 	inode_unlock(dir);
+ out:
+ 	ovl_cache_free(&list);
+ 	if (err)
+ 		pr_err("overlayfs: failed index dir cleanup (%i)\n", err);
+ 	return err;
+ }
++>>>>>>> fa0096e3bad6 (ovl: do not cleanup unsupported index entries)
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/readdir.c
