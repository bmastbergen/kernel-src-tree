openvswitch: Fix ovs_flow_key_update()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yi-Hung Wei <yihung.wei@gmail.com>
commit 6f56f6186c18e3fd54122b73da68e870687b8c59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6f56f618.failed

ovs_flow_key_update() is called when the flow key is invalid, and it is
used to update and revalidate the flow key. Commit 329f45bc4f19
("openvswitch: add mac_proto field to the flow key") introduces mac_proto
field to flow key and use it to determine whether the flow key is valid.
However, the commit does not update the code path in ovs_flow_key_update()
to revalidate the flow key which may cause BUG_ON() on execute_recirc().
This patch addresses the aforementioned issue.

Fixes: 329f45bc4f19 ("openvswitch: add mac_proto field to the flow key")
	Signed-off-by: Yi-Hung Wei <yihung.wei@gmail.com>
	Acked-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6f56f6186c18e3fd54122b73da68e870687b8c59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/flow.c
diff --cc net/openvswitch/flow.c
index f677cc12bd8c,3f76cb765e5b..000000000000
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@@ -503,28 -525,35 +503,36 @@@ static int key_extract(struct sk_buff *
  
  	skb_reset_mac_header(skb);
  
++<<<<<<< HEAD
 +	/* Link layer.  We are guaranteed to have at least the 14 byte Ethernet
 +	 * header in the linear data area.
 +	 */
 +	eth = eth_hdr(skb);
 +	ether_addr_copy(key->eth.src, eth->h_source);
 +	ether_addr_copy(key->eth.dst, eth->h_dest);
++=======
+ 	/* Link layer. */
+ 	clear_vlan(key);
+ 	if (ovs_key_mac_proto(key) == MAC_PROTO_NONE) {
+ 		if (unlikely(eth_type_vlan(skb->protocol)))
+ 			return -EINVAL;
++>>>>>>> 6f56f6186c18 (openvswitch: Fix ovs_flow_key_update())
  
 -		skb_reset_network_header(skb);
 -	} else {
 -		eth = eth_hdr(skb);
 -		ether_addr_copy(key->eth.src, eth->h_source);
 -		ether_addr_copy(key->eth.dst, eth->h_dest);
 -
 -		__skb_pull(skb, 2 * ETH_ALEN);
 -		/* We are going to push all headers that we pull, so no need to
 -		* update skb->csum here.
 -		*/
 +	__skb_pull(skb, 2 * ETH_ALEN);
 +	/* We are going to push all headers that we pull, so no need to
 +	 * update skb->csum here.
 +	 */
  
 -		if (unlikely(parse_vlan(skb, key)))
 -			return -ENOMEM;
 +	if (unlikely(parse_vlan(skb, key)))
 +		return -ENOMEM;
  
 -		skb->protocol = parse_ethertype(skb);
 -		if (unlikely(skb->protocol == htons(0)))
 -			return -ENOMEM;
 +	key->eth.type = parse_ethertype(skb);
 +	if (unlikely(key->eth.type == htons(0)))
 +		return -ENOMEM;
  
 -		skb_reset_network_header(skb);
 -		__skb_push(skb, skb->data - skb_mac_header(skb));
 -	}
 +	skb_reset_network_header(skb);
  	skb_reset_mac_len(skb);
 -	key->eth.type = skb->protocol;
 +	__skb_push(skb, skb->data - skb_mac_header(skb));
  
  	/* Network layer. */
  	if (key->eth.type == htons(ETH_P_IP)) {
@@@ -716,9 -745,29 +724,15 @@@
  
  int ovs_flow_key_update(struct sk_buff *skb, struct sw_flow_key *key)
  {
- 	return key_extract(skb, key);
+ 	int res;
+ 
+ 	res = key_extract(skb, key);
+ 	if (!res)
+ 		key->mac_proto &= ~SW_FLOW_KEY_INVALID;
+ 
+ 	return res;
  }
  
 -static int key_extract_mac_proto(struct sk_buff *skb)
 -{
 -	switch (skb->dev->type) {
 -	case ARPHRD_ETHER:
 -		return MAC_PROTO_ETHERNET;
 -	case ARPHRD_NONE:
 -		if (skb->protocol == htons(ETH_P_TEB))
 -			return MAC_PROTO_ETHERNET;
 -		return MAC_PROTO_NONE;
 -	}
 -	WARN_ON_ONCE(1);
 -	return -EINVAL;
 -}
 -
  int ovs_flow_key_extract(const struct ip_tunnel_info *tun_info,
  			 struct sk_buff *skb, struct sw_flow_key *key)
  {
* Unmerged path net/openvswitch/flow.c
