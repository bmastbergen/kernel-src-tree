ceph: make fault/page_mkwrite return VM_FAULT_OOM for -ENOMEM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 6ce026e411c4f36c9e51189d28a5dd9d08095b9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6ce026e4.failed

	Signed-off-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 6ce026e411c4f36c9e51189d28a5dd9d08095b9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index 49a4dc035844,d128bb65746d..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -1307,19 -1348,14 +1307,28 @@@ static int ceph_filemap_fault(struct vm
  		want = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;
  	else
  		want = CEPH_CAP_FILE_CACHE;
++<<<<<<< HEAD
 +	while (1) {
 +		got = 0;
 +		ret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,
 +				    -1, &got, &pinned_page);
 +		if (ret == 0)
 +			break;
 +		if (ret != -ERESTARTSYS) {
 +			WARN_ON(1);
 +			return VM_FAULT_SIGBUS;
 +		}
 +	}
++=======
+ 
+ 	got = 0;
+ 	ret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want, -1, &got, &pinned_page);
+ 	if (ret < 0)
+ 		goto out_restore;
+ 
++>>>>>>> 6ce026e411c4 (ceph: make fault/page_mkwrite return VM_FAULT_OOM for -ENOMEM)
  	dout("filemap_fault %p %llu~%zd got cap refs on %s\n",
 -	     inode, off, (size_t)PAGE_SIZE, ceph_cap_string(got));
 +	     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));
  
  	if ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||
  	    ci->i_inline_version == CEPH_INLINE_NONE)
@@@ -1354,21 -1390,29 +1363,38 @@@
  					 CEPH_STAT_CAP_INLINE_DATA, true);
  		if (ret1 < 0 || off >= i_size_read(inode)) {
  			unlock_page(page);
++<<<<<<< HEAD
 +			page_cache_release(page);
 +			ret = VM_FAULT_SIGBUS;
 +			goto out;
++=======
+ 			put_page(page);
+ 			if (ret1 < 0)
+ 				ret = ret1;
+ 			else
+ 				ret = VM_FAULT_SIGBUS;
+ 			goto out_inline;
++>>>>>>> 6ce026e411c4 (ceph: make fault/page_mkwrite return VM_FAULT_OOM for -ENOMEM)
  		}
 -		if (ret1 < PAGE_SIZE)
 -			zero_user_segment(page, ret1, PAGE_SIZE);
 +		if (ret1 < PAGE_CACHE_SIZE)
 +			zero_user_segment(page, ret1, PAGE_CACHE_SIZE);
  		else
  			flush_dcache_page(page);
  		SetPageUptodate(page);
  		vmf->page = page;
  		ret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;
 -out_inline:
 -		dout("filemap_fault %p %llu~%zd read inline data ret %d\n",
 -		     inode, off, (size_t)PAGE_SIZE, ret);
  	}
++<<<<<<< HEAD
 +out:
 +	dout("filemap_fault %p %llu~%zd read inline data ret %d\n",
 +	     inode, off, (size_t)PAGE_CACHE_SIZE, ret);
++=======
+ out_restore:
+ 	ceph_restore_sigs(&oldset);
+ 	if (ret < 0)
+ 		ret = (ret == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;
+ 
++>>>>>>> 6ce026e411c4 (ceph: make fault/page_mkwrite return VM_FAULT_OOM for -ENOMEM)
  	return ret;
  }
  
@@@ -1389,8 -1433,11 +1415,8 @@@ static int ceph_page_mkwrite(struct vm_
  
  	prealloc_cf = ceph_alloc_cap_flush();
  	if (!prealloc_cf)
- 		return VM_FAULT_SIGBUS;
+ 		return VM_FAULT_OOM;
  
 -	ceph_block_sigs(&oldset);
 -
  	if (ci->i_inline_version != CEPH_INLINE_NONE) {
  		struct page *locked_page = NULL;
  		if (off == 0) {
@@@ -1400,16 -1447,14 +1426,14 @@@
  		ret = ceph_uninline_data(vma->vm_file, locked_page);
  		if (locked_page)
  			unlock_page(locked_page);
- 		if (ret < 0) {
- 			ret = VM_FAULT_SIGBUS;
+ 		if (ret < 0)
  			goto out_free;
- 		}
  	}
  
 -	if (off + PAGE_SIZE <= size)
 -		len = PAGE_SIZE;
 +	if (off + PAGE_CACHE_SIZE <= size)
 +		len = PAGE_CACHE_SIZE;
  	else
 -		len = size & ~PAGE_MASK;
 +		len = size & ~PAGE_CACHE_MASK;
  
  	dout("page_mkwrite %p %llx.%llx %llu~%zd getting caps i_size %llu\n",
  	     inode, ceph_vinop(inode), off, len, size);
@@@ -1417,18 -1462,13 +1441,28 @@@
  		want = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;
  	else
  		want = CEPH_CAP_FILE_BUFFER;
++<<<<<<< HEAD
 +	while (1) {
 +		got = 0;
 +		ret = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, off + len,
 +				    &got, NULL);
 +		if (ret == 0)
 +			break;
 +		if (ret != -ERESTARTSYS) {
 +			WARN_ON(1);
 +			ret = VM_FAULT_SIGBUS;
 +			goto out_free;
 +		}
 +	}
++=======
+ 
+ 	got = 0;
+ 	ret = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, off + len,
+ 			    &got, NULL);
+ 	if (ret < 0)
+ 		goto out_free;
+ 
++>>>>>>> 6ce026e411c4 (ceph: make fault/page_mkwrite return VM_FAULT_OOM for -ENOMEM)
  	dout("page_mkwrite %p %llu~%zd got cap refs on %s\n",
  	     inode, off, len, ceph_cap_string(got));
  
@@@ -1472,8 -1506,10 +1500,9 @@@ out
  	     inode, off, len, ceph_cap_string(got), ret);
  	ceph_put_cap_refs(ci, got);
  out_free:
 -	ceph_restore_sigs(&oldset);
  	ceph_free_cap_flush(prealloc_cf);
- 
+ 	if (ret < 0)
+ 		ret = (ret == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;
  	return ret;
  }
  
* Unmerged path fs/ceph/addr.c
