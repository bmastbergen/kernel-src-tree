x86/fpu: Parse clearcpuid= as early XSAVE argument

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] fpu: Parse clearcpuid= as early XSAVE argument (Scott Wood) [1457543]
Rebuild_FUZZ: 95.83%
commit-author Andi Kleen <ak@linux.intel.com>
commit 0c2a3913d6f50503f7c59d83a6219e39508cc898
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0c2a3913.failed

With a followon patch we want to make clearcpuid affect the XSAVE
configuration. But xsave is currently initialized before arguments
are parsed. Move the clearcpuid= parsing into the special
early xsave argument parsing code.

Since clearcpuid= contains a = we need to keep the old __setup
around as a dummy, otherwise it would end up as a environment
variable in init's environment.

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20171013215645.23166-4-andi@firstfloor.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0c2a3913d6f50503f7c59d83a6219e39508cc898)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
#	arch/x86/kernel/fpu/init.c
diff --cc arch/x86/kernel/cpu/common.c
index 3eec1147ce1e,03bb004bb15e..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -1179,53 -1286,39 +1179,61 @@@ void print_cpu_info(struct cpuinfo_x86 
  	}
  
  	if (vendor && !strstr(c->x86_model_id, vendor))
 -		pr_cont("%s ", vendor);
 +		printk(KERN_CONT "%s ", vendor);
  
  	if (c->x86_model_id[0])
 -		pr_cont("%s", c->x86_model_id);
 +		printk(KERN_CONT "%s", c->x86_model_id);
  	else
 -		pr_cont("%d86", c->x86);
 +		printk(KERN_CONT "%d86", c->x86);
  
 -	pr_cont(" (family: 0x%x, model: 0x%x", c->x86, c->x86_model);
 +	printk(KERN_CONT " (fam: %02x, model: %02x", c->x86, c->x86_model);
  
  	if (c->x86_mask || c->cpuid_level >= 0)
 -		pr_cont(", stepping: 0x%x)\n", c->x86_mask);
 +		printk(KERN_CONT ", stepping: %02x)\n", c->x86_mask);
  	else
 -		pr_cont(")\n");
 +		printk(KERN_CONT ")\n");
 +
 +	print_cpu_msr(c);
 +}
 +
 +void print_cpu_msr(struct cpuinfo_x86 *c)
 +{
 +	if (c->cpu_index < show_msr)
 +		__print_cpu_msr();
  }
  
- static __init int setup_disablecpuid(char *arg)
+ /*
+  * clearcpuid= was already parsed in fpu__init_parse_early_param.
+  * But we need to keep a dummy __setup around otherwise it would
+  * show up as an environment variable for init.
+  */
+ static __init int setup_clearcpuid(char *arg)
  {
++<<<<<<< HEAD
 +	int bit;
 +
 +	if (get_option(&arg, &bit) && bit < NCAPINTS*32)
 +		setup_clear_cpu_cap(bit);
 +	else
 +		return 0;
 +
++=======
++>>>>>>> 0c2a3913d6f5 (x86/fpu: Parse clearcpuid= as early XSAVE argument)
  	return 1;
  }
- __setup("clearcpuid=", setup_disablecpuid);
+ __setup("clearcpuid=", setup_clearcpuid);
  
  #ifdef CONFIG_X86_64
 +struct desc_ptr idt_descr = { NR_VECTORS * 16 - 1, (unsigned long) idt_table };
 +struct desc_ptr debug_idt_descr = { NR_VECTORS * 16 - 1,
 +				    (unsigned long) debug_idt_table };
 +
  DEFINE_PER_CPU_FIRST(union irq_stack_union,
 -		     irq_stack_union) __aligned(PAGE_SIZE) __visible;
 +		     irq_stack_union) __aligned(PAGE_SIZE);
  
  /*
 - * The following percpu variables are hot.  Align current_task to
 - * cacheline size such that they fall in the same cacheline.
 + * The following four percpu variables are hot.  Align current_task to
 + * cacheline size such that all four fall in the same cacheline.
   */
  DEFINE_PER_CPU(struct task_struct *, current_task) ____cacheline_aligned =
  	&init_task;
* Unmerged path arch/x86/kernel/fpu/init.c
* Unmerged path arch/x86/kernel/cpu/common.c
* Unmerged path arch/x86/kernel/fpu/init.c
