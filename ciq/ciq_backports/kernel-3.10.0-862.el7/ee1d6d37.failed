ovl: mark upper dir with type origin entries "impure"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit ee1d6d37b6b884383b501089be93ce94f2153028
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ee1d6d37.failed

When moving a merge dir or non-dir with copy up origin into a non-merge
upper dir (a.k.a pure upper dir), we are marking the target parent dir
"impure". ovl_iterate() iterates pure upper dirs directly, because there is
no need to filter out whiteouts and merge dir content with lower dir. But
for the case of an "impure" upper dir, ovl_iterate() will not be able to
iterate the real upper dir directly, because it will need to lookup the
origin inode and use it to fill d_ino.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit ee1d6d37b6b884383b501089be93ce94f2153028)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/dir.c
index 09ee239b1762,f2a118ba00e4..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -121,40 -127,44 +121,56 @@@ int ovl_create_real(struct inode *dir, 
  	return err;
  }
  
 -static int ovl_set_opaque_xerr(struct dentry *dentry, struct dentry *upper,
 -			       int xerr)
 +static int ovl_set_opaque(struct dentry *upperdentry)
 +{
 +	return ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, "y", 1, 0);
 +}
 +
 +static int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,
 +			 struct kstat *stat)
  {
  	int err;
 +	enum ovl_path_type type;
 +	struct path realpath;
 +	const struct cred *old_cred;
  
 -	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_OPAQUE, "y", 1, xerr);
 -	if (!err)
 -		ovl_dentry_set_opaque(dentry);
 +	type = ovl_path_real(dentry, &realpath);
 +	old_cred = ovl_override_creds(dentry->d_sb);
 +	err = vfs_getattr(&realpath, stat);
 +	revert_creds(old_cred);
 +	if (err)
 +		return err;
  
 -	return err;
 -}
 +	stat->dev = dentry->d_sb->s_dev;
 +	stat->ino = dentry->d_inode->i_ino;
  
 -static int ovl_set_opaque(struct dentry *dentry, struct dentry *upperdentry)
 -{
  	/*
 -	 * Fail with -EIO when trying to create opaque dir and upper doesn't
 -	 * support xattrs. ovl_rename() calls ovl_set_opaque_xerr(-EXDEV) to
 -	 * return a specific error for noxattr case.
 +	 * It's probably not worth it to count subdirs to get the
 +	 * correct link count.  nlink=1 seems to pacify 'find' and
 +	 * other utilities.
  	 */
 -	return ovl_set_opaque_xerr(dentry, upperdentry, -EIO);
 +	if (OVL_TYPE_MERGE(type))
 +		stat->nlink = 1;
 +
 +	return 0;
  }
  
+ static int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry)
+ {
+ 	int err;
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 * Upper inodes won't have origin nor redirect xattr anyway.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upperdentry, OVL_XATTR_IMPURE,
+ 				 "y", 1, 0);
+ 	if (!err)
+ 		ovl_dentry_set_impure(dentry);
+ 
+ 	return err;
+ }
+ 
  /* Common operations required to be done after creation of file on upper */
  static void ovl_instantiate(struct dentry *dentry, struct inode *inode,
  			    struct dentry *newdentry, bool hardlink)
@@@ -174,9 -184,18 +190,22 @@@
  		d_drop(dentry);
  }
  
++<<<<<<< HEAD
++=======
+ static bool ovl_type_merge(struct dentry *dentry)
+ {
+ 	return OVL_TYPE_MERGE(ovl_path_type(dentry));
+ }
+ 
+ static bool ovl_type_origin(struct dentry *dentry)
+ {
+ 	return OVL_TYPE_ORIGIN(ovl_path_type(dentry));
+ }
+ 
++>>>>>>> ee1d6d37b6b8 (ovl: mark upper dir with type origin entries "impure")
  static int ovl_create_upper(struct dentry *dentry, struct inode *inode,
 -			    struct cattr *attr, struct dentry *hardlink)
 +			    struct kstat *stat, const char *link,
 +			    struct dentry *hardlink)
  {
  	struct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);
  	struct inode *udir = upperdir->d_inode;
@@@ -912,9 -973,32 +941,33 @@@ static int ovl_rename(struct inode *old
  	old_upperdir = ovl_dentry_upper(old->d_parent);
  	new_upperdir = ovl_dentry_upper(new->d_parent);
  
+ 	if (!samedir) {
+ 		/*
+ 		 * When moving a merge dir or non-dir with copy up origin into
+ 		 * a non-merge upper dir (a.k.a pure upper dir), we are making
+ 		 * the target parent dir "impure". ovl_iterate() iterates pure
+ 		 * upper dirs directly, because there is no need to filter out
+ 		 * whiteouts and merge dir content with lower dir. But for the
+ 		 * case of an "impure" upper dir, ovl_iterate() cannot iterate
+ 		 * the real directory directly, because it looks for the inode
+ 		 * numbers to fill d_ino in the entries origin inode.
+ 		 */
+ 		if (ovl_type_origin(old) && !ovl_type_merge(new->d_parent)) {
+ 			err = ovl_set_impure(new->d_parent, new_upperdir);
+ 			if (err)
+ 				goto out_revert_creds;
+ 		}
+ 		if (!overwrite && ovl_type_origin(new) &&
+ 		    !ovl_type_merge(old->d_parent)) {
+ 			err = ovl_set_impure(old->d_parent, old_upperdir);
+ 			if (err)
+ 				goto out_revert_creds;
+ 		}
+ 	}
+ 
  	trap = lock_rename(new_upperdir, old_upperdir);
  
 +
  	olddentry = lookup_one_len(old->d_name.name, old_upperdir,
  				   old->d_name.len);
  	err = PTR_ERR(olddentry);
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,a9fb958fd5d4..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -24,6 -22,43 +24,46 @@@ enum ovl_path_type 
  
  #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
  #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
++<<<<<<< HEAD
++=======
+ #define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
+ #define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
+ #define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
+ 
+ /*
+  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
+  * where:
+  * origin.fh	- exported file handle of the lower file
+  * origin.uuid	- uuid of the lower filesystem
+  */
+ #define OVL_FH_VERSION	0
+ #define OVL_FH_MAGIC	0xfb
+ 
+ /* CPU byte order required for fid decoding:  */
+ #define OVL_FH_FLAG_BIG_ENDIAN	(1 << 0)
+ #define OVL_FH_FLAG_ANY_ENDIAN	(1 << 1)
+ 
+ #define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
+ 
+ #if defined(__LITTLE_ENDIAN)
+ #define OVL_FH_FLAG_CPU_ENDIAN 0
+ #elif defined(__BIG_ENDIAN)
+ #define OVL_FH_FLAG_CPU_ENDIAN OVL_FH_FLAG_BIG_ENDIAN
+ #else
+ #error Endianness not defined
+ #endif
+ 
+ /* On-disk and in-memeory format for redirect by file handle */
+ struct ovl_fh {
+ 	u8 version;	/* 0 */
+ 	u8 magic;	/* 0xfb */
+ 	u8 len;		/* size of this header + size of fid */
+ 	u8 flags;	/* OVL_FH_FLAG_* */
+ 	u8 type;	/* fid_type of fid */
+ 	uuid_be uuid;	/* uuid of filesystem */
+ 	u8 fid[0];	/* file identifier */
+ } __packed;
++>>>>>>> ee1d6d37b6b8 (ovl: mark upper dir with type origin entries "impure")
  
  #define OVL_ISUPPER_MASK 1UL
  
@@@ -151,27 -201,31 +191,51 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_impure(struct dentry *dentry);
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ void ovl_dentry_set_impure(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_inode_init(struct inode *inode, struct inode *realinode,
+ 		    bool is_upper);
+ void ovl_inode_update(struct inode *inode, struct inode *upperinode);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ 
+ /* namei.c */
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> ee1d6d37b6b8 (ovl: mark upper dir with type origin entries "impure")
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/util.c
