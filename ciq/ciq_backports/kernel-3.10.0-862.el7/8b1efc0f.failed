net: remove MTU limits on a few ether_setup callers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] remove MTU limits on a few ether_setup callers (Ivan Vecera) [1527175]
Rebuild_FUZZ: 94.85%
commit-author Jarod Wilson <jarod@redhat.com>
commit 8b1efc0f83f1f75b8f85c70d2211007de8fd7633
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8b1efc0f.failed

These few drivers call ether_setup(), but have no ndo_change_mtu, and thus
were overlooked for changes to MTU range checking behavior. They
previously had no range checks, so for feature-parity, set their min_mtu
to 0 and max_mtu to ETH_MAX_MTU (65535), instead of the 68 and 1500
inherited from the ether_setup() changes. Fine-tuning can come after we get
back to full feature-parity here.

CC: netdev@vger.kernel.org
	Reported-by: Asbjoern Sloth Toennesen <asbjorn@asbjorn.st>
CC: Asbjoern Sloth Toennesen <asbjorn@asbjorn.st>
CC: R Parameswaran <parameswaran.r7@gmail.com>
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8b1efc0f83f1f75b8f85c70d2211007de8fd7633)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/dsa/slave.c
diff --cc net/dsa/slave.c
index f3efc3546e20,d0c7bce88743..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -322,38 -1232,30 +322,45 @@@ dsa_slave_create(struct dsa_switch *ds
  	struct dsa_slave_priv *p;
  	int ret;
  
 -	master = ds->dst->master_netdev;
 -	if (ds->master_netdev)
 -		master = ds->master_netdev;
 -
 -	slave_dev = alloc_netdev(sizeof(struct dsa_slave_priv), name,
 -				 NET_NAME_UNKNOWN, ether_setup);
 +	slave_dev = alloc_netdev(sizeof(struct dsa_slave_priv),
 +				 name, ether_setup);
  	if (slave_dev == NULL)
 -		return -ENOMEM;
 +		return slave_dev;
  
  	slave_dev->features = master->vlan_features;
 -	slave_dev->ethtool_ops = &dsa_slave_ethtool_ops;
 -	eth_hw_addr_inherit(slave_dev, master);
 -	slave_dev->priv_flags |= IFF_NO_QUEUE;
 +	SET_ETHTOOL_OPS(slave_dev, &dsa_slave_ethtool_ops);
 +	memcpy(slave_dev->dev_addr, master->dev_addr, ETH_ALEN);
 +	slave_dev->tx_queue_len = 0;
  	slave_dev->netdev_ops = &dsa_slave_netdev_ops;
++<<<<<<< HEAD
++=======
+ 	slave_dev->switchdev_ops = &dsa_slave_switchdev_ops;
+ 	slave_dev->min_mtu = 0;
+ 	slave_dev->max_mtu = ETH_MAX_MTU;
+ 	SET_NETDEV_DEVTYPE(slave_dev, &dsa_type);
++>>>>>>> 8b1efc0f83f1 (net: remove MTU limits on a few ether_setup callers)
  
 -	netdev_for_each_tx_queue(slave_dev, dsa_slave_set_lockdep_class_one,
 -				 NULL);
 +	switch (ds->dst->tag_protocol) {
 +#ifdef CONFIG_NET_DSA_TAG_DSA
 +	case htons(ETH_P_DSA):
 +		ds->dst->ops = &dsa_netdev_ops;
 +		break;
 +#endif
 +#ifdef CONFIG_NET_DSA_TAG_EDSA
 +	case htons(ETH_P_EDSA):
 +		ds->dst->ops = &edsa_netdev_ops;
 +		break;
 +#endif
 +#ifdef CONFIG_NET_DSA_TAG_TRAILER
 +	case htons(ETH_P_TRAILER):
 +		ds->dst->ops = &trailer_netdev_ops;
 +		break;
 +#endif
 +	default:
 +		BUG();
 +	}
  
  	SET_NETDEV_DEV(slave_dev, parent);
 -	slave_dev->dev.of_node = ds->ports[port].dn;
  	slave_dev->vlan_features = master->vlan_features;
  
  	p = netdev_priv(slave_dev);
diff --git a/net/atm/br2684.c b/net/atm/br2684.c
index 403e71fa88fe..c94f2d5714b9 100644
--- a/net/atm/br2684.c
+++ b/net/atm/br2684.c
@@ -651,7 +651,9 @@ static void br2684_setup_routed(struct net_device *netdev)
 	netdev->hard_header_len = sizeof(llc_oui_ipv4); /* worst case */
 	netdev->netdev_ops = &br2684_netdev_ops_routed;
 	netdev->addr_len = 0;
-	netdev->mtu = 1500;
+	netdev->mtu = ETH_DATA_LEN;
+	netdev->min_mtu = 0;
+	netdev->max_mtu = ETH_MAX_MTU;
 	netdev->type = ARPHRD_PPP;
 	netdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
 	netdev->tx_queue_len = 100;
diff --git a/net/bluetooth/bnep/netdev.c b/net/bluetooth/bnep/netdev.c
index f4fcb4a9d5c1..80789e44ed63 100644
--- a/net/bluetooth/bnep/netdev.c
+++ b/net/bluetooth/bnep/netdev.c
@@ -222,6 +222,8 @@ void bnep_net_setup(struct net_device *dev)
 	dev->addr_len = ETH_ALEN;
 
 	ether_setup(dev);
+	dev->min_mtu = 0;
+	dev->max_mtu = ETH_MAX_MTU;
 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev->netdev_ops = &bnep_netdev_ops;
 
* Unmerged path net/dsa/slave.c
diff --git a/net/irda/irlan/irlan_eth.c b/net/irda/irlan/irlan_eth.c
index ae3ab09130ed..f0267a9feb69 100644
--- a/net/irda/irlan/irlan_eth.c
+++ b/net/irda/irlan/irlan_eth.c
@@ -67,7 +67,8 @@ static void irlan_eth_setup(struct net_device *dev)
 
 	dev->netdev_ops		= &irlan_eth_netdev_ops;
 	dev->destructor		= free_netdev;
-
+	dev->min_mtu		= 0;
+	dev->max_mtu		= ETH_MAX_MTU;
 
 	/*
 	 * Lets do all queueing in IrTTP instead of this device driver.
diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c
index 0ce7a542fcfb..be1d57a832f7 100644
--- a/net/l2tp/l2tp_eth.c
+++ b/net/l2tp/l2tp_eth.c
@@ -251,6 +251,8 @@ static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p
 		session->mtu = dev->mtu - session->hdr_len;
 	dev->mtu = session->mtu;
 	dev->needed_headroom += session->hdr_len;
+	dev->min_mtu = 0;
+	dev->max_mtu = ETH_MAX_MTU;
 
 	priv = netdev_priv(dev);
 	priv->dev = dev;
