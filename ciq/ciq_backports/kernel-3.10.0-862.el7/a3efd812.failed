netfilter: conntrack: move generation seqcnt out of netns_ct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Westphal <fw@strlen.de>
commit a3efd81205b128a802025abb689925177a4607ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a3efd812.failed

We only allow rehash in init namespace, so we only use
init_ns.generation.  And even if we would allow it, it makes no sense
as the conntrack locks are global; any ongoing rehash prevents insert/
delete.

So make this private to nf_conntrack_core instead.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a3efd81205b128a802025abb689925177a4607ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 5140736f7cea,a53c009fe510..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -72,6 -68,21 +72,24 @@@ EXPORT_SYMBOL_GPL(nf_conntrack_locks)
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(nf_conntrack_expect_lock);
  EXPORT_SYMBOL_GPL(nf_conntrack_expect_lock);
  
++<<<<<<< HEAD
++=======
+ static __read_mostly spinlock_t nf_conntrack_locks_all_lock;
+ static __read_mostly seqcount_t nf_conntrack_generation;
+ static __read_mostly bool nf_conntrack_locks_all;
+ 
+ void nf_conntrack_lock(spinlock_t *lock) __acquires(lock)
+ {
+ 	spin_lock(lock);
+ 	while (unlikely(nf_conntrack_locks_all)) {
+ 		spin_unlock(lock);
+ 		spin_unlock_wait(&nf_conntrack_locks_all_lock);
+ 		spin_lock(lock);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(nf_conntrack_lock);
+ 
++>>>>>>> a3efd81205b1 (netfilter: conntrack: move generation seqcnt out of netns_ct)
  static void nf_conntrack_double_unlock(unsigned int h1, unsigned int h2)
  {
  	h1 %= CONNTRACK_LOCKS;
@@@ -792,8 -776,8 +810,13 @@@ restart
  	hash = hash_bucket(_hash, net);
  	for (; i < net->ct.htable_size; i++) {
  		lockp = &nf_conntrack_locks[hash % CONNTRACK_LOCKS];
++<<<<<<< HEAD
 +		spin_lock(lockp);
 +		if (read_seqcount_retry(&net->ct.generation, sequence)) {
++=======
+ 		nf_conntrack_lock(lockp);
+ 		if (read_seqcount_retry(&nf_conntrack_generation, sequence)) {
++>>>>>>> a3efd81205b1 (netfilter: conntrack: move generation seqcnt out of netns_ct)
  			spin_unlock(lockp);
  			goto restart;
  		}
diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
index 43f98506baab..532355c7d117 100644
--- a/include/net/netns/conntrack.h
+++ b/include/net/netns/conntrack.h
@@ -126,7 +126,6 @@ struct netns_ct {
 	int			sysctl_checksum;
 
 	unsigned int		htable_size;
-	seqcount_t		generation;
 	struct kmem_cache	*nf_conntrack_cachep;
 	struct hlist_nulls_head	*hash;
 	struct hlist_head	*expect_hash;
* Unmerged path net/netfilter/nf_conntrack_core.c
