scsi: qla2xxx: Add ability to autodetect SFP type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add ability to autodetect SFP type (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 93.48%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit e4e3a2ce9556cc4da40dadaf94c0d3395b6e91d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e4e3a2ce.failed

SFP can come in 2 formats: short range/SR and long range/LR.  For LR,
user the can increase the number of Buffer to Buffer credits between end
points via Cavium's command line tool.  By default, FW uses a lower BB
Credit value optimized for SR.  This patch will read the SFP for each
link up event and during chip reset sequence. If the SFP type and
setting are mismatch, then the chip is reset 1 time to use the
appropriate setting.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit e4e3a2ce9556cc4da40dadaf94c0d3395b6e91d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,609687d04e3c..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3014,14 -3453,27 +3014,31 @@@ struct qla_hw_data 
  		uint32_t	isp82xx_no_md_cap:1;
  		uint32_t	host_shutting_down:1;
  		uint32_t	idc_compl_status:1;
 +
  		uint32_t        mr_reset_hdlr_active:1;
  		uint32_t        mr_intr_valid:1;
 -
 -		uint32_t        dport_enabled:1;
 +		uint32_t	dport_enabled:1;
  		uint32_t	fawwpn_enabled:1;
++<<<<<<< HEAD
 +		/* 35 bits */
++=======
+ 		uint32_t	exlogins_enabled:1;
+ 		uint32_t	exchoffld_enabled:1;
+ 
+ 		uint32_t	lip_ae:1;
+ 		uint32_t	n2n_ae:1;
+ 		uint32_t	fw_started:1;
+ 		uint32_t	fw_init_done:1;
+ 
+ 		uint32_t	detected_lr_sfp:1;
+ 		uint32_t	using_lr_setting:1;
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  	} flags;
  
+ 	u8 long_range_distance;	/* 32G & above */
+ #define LR_DISTANCE_5K  1
+ #define LR_DISTANCE_10K 0
+ 
  	/* This spinlock is used to protect "io transactions", you must
  	* acquire it before doing any IO to the card, eg with RD_REG*() and
  	* WRT_REG*() for the duration of your entire commandtransaction.
@@@ -3614,6 -4101,8 +3631,11 @@@ typedef struct scsi_qla_host 
  #define FX00_CRITEMP_RECOVERY	25
  #define FX00_HOST_INFO_RESEND	26
  #define QPAIR_ONLINE_CHECK_NEEDED	27
++<<<<<<< HEAD
++=======
+ #define SET_ZIO_THRESHOLD_NEEDED	28
+ #define DETECT_SFP_CHANGE	29
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  
  	unsigned long	pci_flags;
  #define PFLG_DISCONNECTED	0	/* PCI device removed */
@@@ -3834,6 -4386,92 +3856,95 @@@ enum nexus_wait_type 
  	WAIT_LUN,
  };
  
++<<<<<<< HEAD
++=======
+ /* Refer to SNIA SFF 8247 */
+ struct sff_8247_a0 {
+ 	u8 txid;	/* transceiver id */
+ 	u8 ext_txid;
+ 	u8 connector;
+ 	/* compliance code */
+ 	u8 eth_infi_cc3;	/* ethernet, inifiband */
+ 	u8 sonet_cc4[2];
+ 	u8 eth_cc6;
+ 	/* link length */
+ #define FC_LL_VL BIT_7	/* very long */
+ #define FC_LL_S  BIT_6	/* Short */
+ #define FC_LL_I  BIT_5	/* Intermidiate*/
+ #define FC_LL_L  BIT_4	/* Long */
+ #define FC_LL_M  BIT_3	/* Medium */
+ #define FC_LL_SA BIT_2	/* ShortWave laser */
+ #define FC_LL_LC BIT_1	/* LongWave laser */
+ #define FC_LL_EL BIT_0	/* Electrical inter enclosure */
+ 	u8 fc_ll_cc7;
+ 	/* FC technology */
+ #define FC_TEC_EL BIT_7	/* Electrical inter enclosure */
+ #define FC_TEC_SN BIT_6	/* short wave w/o OFC */
+ #define FC_TEC_SL BIT_5	/* short wave with OFC */
+ #define FC_TEC_LL BIT_4	/* Longwave Laser */
+ #define FC_TEC_ACT BIT_3	/* Active cable */
+ #define FC_TEC_PAS BIT_2	/* Passive cable */
+ 	u8 fc_tec_cc8;
+ 	/* Transmission Media */
+ #define FC_MED_TW BIT_7	/* Twin Ax */
+ #define FC_MED_TP BIT_6	/* Twited Pair */
+ #define FC_MED_MI BIT_5	/* Min Coax */
+ #define FC_MED_TV BIT_4	/* Video Coax */
+ #define FC_MED_M6 BIT_3	/* Multimode, 62.5um */
+ #define FC_MED_M5 BIT_2	/* Multimode, 50um */
+ #define FC_MED_SM BIT_0	/* Single Mode */
+ 	u8 fc_med_cc9;
+ 	/* speed FC_SP_12: 12*100M = 1200 MB/s */
+ #define FC_SP_12 BIT_7
+ #define FC_SP_8  BIT_6
+ #define FC_SP_16 BIT_5
+ #define FC_SP_4  BIT_4
+ #define FC_SP_32 BIT_3
+ #define FC_SP_2  BIT_2
+ #define FC_SP_1  BIT_0
+ 	u8 fc_sp_cc10;
+ 	u8 encode;
+ 	u8 bitrate;
+ 	u8 rate_id;
+ 	u8 length_km;		/* offset 14/eh */
+ 	u8 length_100m;
+ 	u8 length_50um_10m;
+ 	u8 length_62um_10m;
+ 	u8 length_om4_10m;
+ 	u8 length_om3_10m;
+ #define SFF_VEN_NAME_LEN 16
+ 	u8 vendor_name[SFF_VEN_NAME_LEN];	/* offset 20/14h */
+ 	u8 tx_compat;
+ 	u8 vendor_oui[3];
+ #define SFF_PART_NAME_LEN 16
+ 	u8 vendor_pn[SFF_PART_NAME_LEN];	/* part number */
+ 	u8 vendor_rev[4];
+ 	u8 wavelength[2];
+ 	u8 resv;
+ 	u8 cc_base;
+ 	u8 options[2];	/* offset 64 */
+ 	u8 br_max;
+ 	u8 br_min;
+ 	u8 vendor_sn[16];
+ 	u8 date_code[8];
+ 	u8 diag;
+ 	u8 enh_options;
+ 	u8 sff_revision;
+ 	u8 cc_ext;
+ 	u8 vendor_specific[32];
+ 	u8 resv2[128];
+ };
+ 
+ #define AUTO_DETECT_SFP_SUPPORT(_vha)\
+ 	(ql2xautodetectsfp && !_vha->vp_idx &&		\
+ 	(IS_QLA25XX(_vha->hw) || IS_QLA81XX(_vha->hw) ||\
+ 	IS_QLA83XX(_vha->hw) || IS_QLA27XX(_vha->hw)))
+ 
+ #define USER_CTRL_IRQ(_ha) (ql2xuctrlirq && QLA_TGT_MODE_ENABLED() && \
+ 	(IS_QLA27XX(_ha) || IS_QLA83XX(_ha)))
+ 
+ #include "qla_target.h"
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  #include "qla_gbl.h"
  #include "qla_dbg.h"
  #include "qla_inline.h"
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,3aada5dd597f..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -89,8 -95,17 +89,20 @@@ qla2x00_alloc_outstanding_cmds(struct q
  extern int qla2x00_init_rings(scsi_qla_host_t *);
  extern uint8_t qla27xx_find_valid_image(struct scsi_qla_host *);
  extern struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *,
 -	int, int, bool);
 +	cpumask_var_t, int, int);
  extern int qla2xxx_delete_qpair(struct scsi_qla_host *, struct qla_qpair *);
++<<<<<<< HEAD
++=======
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *, struct event_arg *);
+ int qla24xx_async_gpdb(struct scsi_qla_host *, fc_port_t *, u8);
+ int qla24xx_async_prli(struct scsi_qla_host *, fc_port_t *);
+ int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
+ 	struct imm_ntfy_from_isp *, int);
+ int qla24xx_post_newsess_work(struct scsi_qla_host *, port_id_t *, u8 *,
+     void *);
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *, fc_port_t *);
+ int qla24xx_detect_sfp(scsi_qla_host_t *vha);
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  
  /*
   * Global Data in qla_os.c source file.
@@@ -118,10 -133,17 +130,17 @@@ extern int ql2xenabledif
  extern int ql2xenablehba_err_chk;
  extern int ql2xtargetreset;
  extern int ql2xdontresethba;
 -extern uint64_t ql2xmaxlun;
 +extern unsigned int ql2xmaxlun;
  extern int ql2xmdcapmask;
  extern int ql2xmdenable;
 -extern int ql2xexlogins;
 -extern int ql2xexchoffld;
 -extern int ql2xiniexchg;
  extern int ql2xfwholdabts;
++<<<<<<< HEAD
++=======
+ extern int ql2xmvasynctoatio;
+ extern int ql2xuctrlirq;
+ extern int ql2xnvmeenable;
+ extern int ql2xautodetectsfp;
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  
  extern int qla2x00_loop_reset(scsi_qla_host_t *);
  extern void qla2x00_abort_all_cmds(scsi_qla_host_t *, int);
@@@ -736,10 -798,11 +755,11 @@@ extern char *qdev_state(uint32_t)
  extern void qla82xx_clear_pending_mbx(scsi_qla_host_t *);
  extern int qla82xx_read_temperature(scsi_qla_host_t *);
  extern int qla8044_read_temperature(scsi_qla_host_t *);
+ extern int qla2x00_read_sfp_dev(struct scsi_qla_host *, char *, int);
  
  /* BSG related functions */
 -extern int qla24xx_bsg_request(struct bsg_job *);
 -extern int qla24xx_bsg_timeout(struct bsg_job *);
 +extern int qla24xx_bsg_request(struct fc_bsg_job *);
 +extern int qla24xx_bsg_timeout(struct fc_bsg_job *);
  extern int qla84xx_reset_chip(scsi_qla_host_t *, uint16_t);
  extern int qla2x00_issue_iocb_timeout(scsi_qla_host_t *, void *,
  	dma_addr_t, size_t, uint32_t);
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 998b579c233c,b380a7c97d5b..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1844,6 -3014,22 +1985,19 @@@ qla2x00_setup_chip(scsi_qla_host_t *vha
  			rval = qla2x00_execute_fw(vha, srisc_address);
  			/* Retrieve firmware information. */
  			if (rval == QLA_SUCCESS) {
++<<<<<<< HEAD
++=======
+ 				qla24xx_detect_sfp(vha);
+ 
+ 				rval = qla2x00_set_exlogins_buffer(vha);
+ 				if (rval != QLA_SUCCESS)
+ 					goto failed;
+ 
+ 				rval = qla2x00_set_exchoffld_buffer(vha);
+ 				if (rval != QLA_SUCCESS)
+ 					goto failed;
+ 
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  enable_82xx_npiv:
  				fw_major_version = ha->fw_major_version;
  				if (IS_P3P_TYPE(ha))
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index a8c3dc9d6e90,52cb9882bf31..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -575,13 -599,39 +576,47 @@@ qla2x00_execute_fw(scsi_qla_host_t *vha
  		mcp->mb[1] = MSW(risc_addr);
  		mcp->mb[2] = LSW(risc_addr);
  		mcp->mb[3] = 0;
+ 		mcp->mb[4] = 0;
  		if (IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) ||
  		    IS_QLA27XX(ha)) {
++<<<<<<< HEAD
 +			struct nvram_81xx *nv = ha->nvram;
 +			mcp->mb[4] = (nv->enhanced_features &
 +			    EXTENDED_BB_CREDITS);
 +		} else
 +			mcp->mb[4] = 0;
++=======
+ 			if (ql2xautodetectsfp) {
+ 				if (ha->flags.detected_lr_sfp) {
+ 					mcp->mb[4] |= EXTENDED_BB_CREDITS;
+ 					if (IS_QLA27XX(ha))
+ 						mcp->mb[4] |=
+ 					(u16)ha->long_range_distance << 12;
+ 					ha->flags.using_lr_setting = 1;
+ 				}
+ 			} else {
+ 				struct nvram_81xx *nv = ha->nvram;
+ 
+ 				if (nv->enhanced_features &
+ 				    EXTENDED_BB_CREDITS) {
+ 					mcp->mb[4] |= EXTENDED_BB_CREDITS;
+ 					ha->flags.using_lr_setting = 1;
+ 				}
+ 			}
+ 		} else {
+ 			ha->flags.using_lr_setting = 0;
+ 		}
+ 
+ 		if (ql2xnvmeenable && IS_QLA27XX(ha))
+ 			mcp->mb[4] |= NVME_ENABLE_FLAG;
+ 
+ 		if (ha->flags.exlogins_enabled)
+ 			mcp->mb[4] |= ENABLE_EXTENDED_LOGIN;
+ 
+ 		if (ha->flags.exchoffld_enabled)
+ 			mcp->mb[4] |= ENABLE_EXCHANGE_OFFLD;
+ 
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  		mcp->out_mb |= MBX_4|MBX_3|MBX_2|MBX_1;
  		mcp->in_mb |= MBX_1;
  	} else {
@@@ -5656,3 -5866,343 +5695,346 @@@ qla26xx_dport_diagnostics(scsi_qla_host
  
  	return rval;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void qla2x00_async_mb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 
+ 	sp->u.iocb_cmd.u.mbx.rc = res;
+ 
+ 	complete(&sp->u.iocb_cmd.u.mbx.comp);
+ 	/* don't free sp here. Let the caller do the free */
+ }
+ 
+ /*
+  * This mailbox uses the iocb interface to send MB command.
+  * This allows non-critial (non chip setup) command to go
+  * out in parrallel.
+  */
+ int qla24xx_send_mb_cmd(struct scsi_qla_host *vha, mbx_cmd_t *mcp)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	srb_t *sp;
+ 	struct srb_iocb *c;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	sp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = mb_to_str(mcp->mb[0]);
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	memcpy(sp->u.iocb_cmd.u.mbx.out_mb, mcp->mb, SIZEOF_IOCB_MB_REG);
+ 
+ 	c = &sp->u.iocb_cmd;
+ 	c->timeout = qla2x00_async_iocb_timeout;
+ 	init_completion(&c->u.mbx.comp);
+ 
+ 	sp->done = qla2x00_async_mb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1018,
+ 		    "%s: %s Failed submission. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x113f, "MB:%s hndl %x submitted\n",
+ 	    sp->name, sp->handle);
+ 
+ 	wait_for_completion(&c->u.mbx.comp);
+ 	memcpy(mcp->mb, sp->u.iocb_cmd.u.mbx.in_mb, SIZEOF_IOCB_MB_REG);
+ 
+ 	rval = c->u.mbx.rc;
+ 	switch (rval) {
+ 	case QLA_FUNCTION_TIMEOUT:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1140, "%s: %s Timeout. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		break;
+ 	case  QLA_SUCCESS:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119d, "%s: %s done.\n",
+ 		    __func__, sp->name);
+ 		sp->free(sp);
+ 		break;
+ 	default:
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119e, "%s: %s Failed. %x.\n",
+ 		    __func__, sp->name, rval);
+ 		sp->free(sp);
+ 		break;
+ 	}
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	return rval;
+ }
+ 
+ /*
+  * qla24xx_gpdb_wait
+  * NOTE: Do not call this routine from DPC thread
+  */
+ int qla24xx_gpdb_wait(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	mbx_cmd_t mc;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd  == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xd047,
+ 		    "Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	memset(&mc, 0, sizeof(mc));
+ 	mc.mb[0] = MBC_GET_PORT_DATABASE;
+ 	mc.mb[1] = cpu_to_le16(fcport->loop_id);
+ 	mc.mb[2] = MSW(pd_dma);
+ 	mc.mb[3] = LSW(pd_dma);
+ 	mc.mb[6] = MSW(MSD(pd_dma));
+ 	mc.mb[7] = LSW(MSD(pd_dma));
+ 	mc.mb[9] = cpu_to_le16(vha->vp_idx);
+ 	mc.mb[10] = cpu_to_le16((uint16_t)opt);
+ 
+ 	rval = qla24xx_send_mb_cmd(vha, &mc);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x1193,
+ 		    "%s: %8phC fail\n", __func__, fcport->port_name);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	rval = __qla24xx_parse_gpdb(vha, fcport, pd);
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1197, "%s: %8phC done\n",
+ 	    __func__, fcport->port_name);
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ done:
+ 	return rval;
+ }
+ 
+ int __qla24xx_parse_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport,
+     struct port_database_24xx *pd)
+ {
+ 	int rval = QLA_SUCCESS;
+ 	uint64_t zero = 0;
+ 	u8 current_login_state, last_login_state;
+ 
+ 	if (fcport->fc4f_nvme) {
+ 		current_login_state = pd->current_login_state >> 4;
+ 		last_login_state = pd->last_login_state >> 4;
+ 	} else {
+ 		current_login_state = pd->current_login_state & 0xf;
+ 		last_login_state = pd->last_login_state & 0xf;
+ 	}
+ 
+ 	/* Check for logged in state. */
+ 	if (current_login_state != PDS_PRLI_COMPLETE &&
+ 	    last_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119a,
+ 		    "Unable to verify login-state (%x/%x) for loop_id %x.\n",
+ 		    current_login_state, last_login_state, fcport->loop_id);
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	if (fcport->loop_id == FC_NO_LOOP_ID ||
+ 	    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&
+ 	     memcmp(fcport->port_name, pd->port_name, 8))) {
+ 		/* We lost the device mid way. */
+ 		rval = QLA_NOT_LOGGED_IN;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	/* Names are little-endian. */
+ 	memcpy(fcport->node_name, pd->node_name, WWN_SIZE);
+ 	memcpy(fcport->port_name, pd->port_name, WWN_SIZE);
+ 
+ 	/* Get port_id of device. */
+ 	fcport->d_id.b.domain = pd->port_id[0];
+ 	fcport->d_id.b.area = pd->port_id[1];
+ 	fcport->d_id.b.al_pa = pd->port_id[2];
+ 	fcport->d_id.b.rsvd_1 = 0;
+ 
+ 	if (fcport->fc4f_nvme) {
+ 		fcport->nvme_prli_service_param =
+ 		    pd->prli_nvme_svc_param_word_3;
+ 		fcport->port_type = FCT_NVME;
+ 	} else {
+ 		/* If not target must be initiator or unknown type. */
+ 		if ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 			fcport->port_type = FCT_INITIATOR;
+ 		else
+ 			fcport->port_type = FCT_TARGET;
+ 	}
+ 	/* Passback COS information. */
+ 	fcport->supported_classes = (pd->flags & PDF_CLASS_2) ?
+ 		FC_COS_CLASS2 : FC_COS_CLASS3;
+ 
+ 	if (pd->prli_svc_param_word_3[0] & BIT_7) {
+ 		fcport->flags |= FCF_CONF_COMP_SUPPORTED;
+ 		fcport->conf_compl_supported = 1;
+ 	}
+ 
+ gpd_error_out:
+ 	return rval;
+ }
+ 
+ /*
+  * qla24xx_gidlist__wait
+  * NOTE: don't call this routine from DPC thread.
+  */
+ int qla24xx_gidlist_wait(struct scsi_qla_host *vha,
+ 	void *id_list, dma_addr_t id_list_dma, uint16_t *entries)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	mbx_cmd_t mc;
+ 
+ 	if (!vha->hw->flags.fw_started)
+ 		goto done;
+ 
+ 	memset(&mc, 0, sizeof(mc));
+ 	mc.mb[0] = MBC_GET_ID_LIST;
+ 	mc.mb[2] = MSW(id_list_dma);
+ 	mc.mb[3] = LSW(id_list_dma);
+ 	mc.mb[6] = MSW(MSD(id_list_dma));
+ 	mc.mb[7] = LSW(MSD(id_list_dma));
+ 	mc.mb[8] = 0;
+ 	mc.mb[9] = cpu_to_le16(vha->vp_idx);
+ 
+ 	rval = qla24xx_send_mb_cmd(vha, &mc);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119b,
+ 		    "%s:  fail\n", __func__);
+ 	} else {
+ 		*entries = mc.mb[1];
+ 		ql_dbg(ql_dbg_mbx, vha, 0x119c,
+ 		    "%s:  done\n", __func__);
+ 	}
+ done:
+ 	return rval;
+ }
+ 
+ int qla27xx_set_zio_threshold(scsi_qla_host_t *vha, uint16_t value)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1200,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0 , sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_SET_ZIO_THRESHOLD;
+ 	mcp->mb[1] = cpu_to_le16(1);
+ 	mcp->mb[2] = cpu_to_le16(value);
+ 	mcp->out_mb = MBX_2 | MBX_1 | MBX_0;
+ 	mcp->in_mb = MBX_2 | MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1201, "%s %x\n",
+ 	    (rval != QLA_SUCCESS) ? "Failed"  : "Done", rval);
+ 
+ 	return rval;
+ }
+ 
+ int qla27xx_get_zio_threshold(scsi_qla_host_t *vha, uint16_t *value)
+ {
+ 	int rval;
+ 	mbx_cmd_t	mc;
+ 	mbx_cmd_t	*mcp = &mc;
+ 
+ 	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1203,
+ 	    "Entered %s\n", __func__);
+ 
+ 	memset(mcp->mb, 0, sizeof(mcp->mb));
+ 	mcp->mb[0] = MBC_GET_SET_ZIO_THRESHOLD;
+ 	mcp->mb[1] = cpu_to_le16(0);
+ 	mcp->out_mb = MBX_1 | MBX_0;
+ 	mcp->in_mb = MBX_2 | MBX_0;
+ 	mcp->tov = MBX_TOV_SECONDS;
+ 	mcp->flags = 0;
+ 
+ 	rval = qla2x00_mailbox_command(vha, mcp);
+ 	if (rval == QLA_SUCCESS)
+ 		*value = mc.mb[2];
+ 
+ 	ql_dbg(ql_dbg_mbx, vha, 0x1205, "%s %x\n",
+ 	    (rval != QLA_SUCCESS) ? "Failed" : "Done", rval);
+ 
+ 	return rval;
+ }
+ 
+ int
+ qla2x00_read_sfp_dev(struct scsi_qla_host *vha, char *buf, int count)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t iter, addr, offset;
+ 	dma_addr_t phys_addr;
+ 	int rval, c;
+ 	u8 *sfp_data;
+ 
+ 	memset(ha->sfp_data, 0, SFP_DEV_SIZE);
+ 	addr = 0xa0;
+ 	phys_addr = ha->sfp_data_dma;
+ 	sfp_data = ha->sfp_data;
+ 	offset = c = 0;
+ 
+ 	for (iter = 0; iter < SFP_DEV_SIZE / SFP_BLOCK_SIZE; iter++) {
+ 		if (iter == 4) {
+ 			/* Skip to next device address. */
+ 			addr = 0xa2;
+ 			offset = 0;
+ 		}
+ 
+ 		rval = qla2x00_read_sfp(vha, phys_addr, sfp_data,
+ 		    addr, offset, SFP_BLOCK_SIZE, BIT_1);
+ 		if (rval != QLA_SUCCESS) {
+ 			ql_log(ql_log_warn, vha, 0x706d,
+ 			    "Unable to read SFP data (%x/%x/%x).\n", rval,
+ 			    addr, offset);
+ 
+ 			return rval;
+ 		}
+ 
+ 		if (buf && (c < count)) {
+ 			u16 sz;
+ 
+ 			if ((count - c) >= SFP_BLOCK_SIZE)
+ 				sz = SFP_BLOCK_SIZE;
+ 			else
+ 				sz = count - c;
+ 
+ 			memcpy(buf, sfp_data, sz);
+ 			buf += SFP_BLOCK_SIZE;
+ 			c += sz;
+ 		}
+ 		phys_addr += SFP_BLOCK_SIZE;
+ 		sfp_data  += SFP_BLOCK_SIZE;
+ 		offset += SFP_BLOCK_SIZE;
+ 	}
+ 
+ 	return rval;
+ }
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 4e0d0a2f9461,b6b070db5891..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -224,6 -255,19 +224,22 @@@ MODULE_PARM_DESC(ql2xfwholdabts
  		"0 (Default) Do not set fw option. "
  		"1 - Set fw option to hold ABTS.");
  
++<<<<<<< HEAD
++=======
+ int ql2xmvasynctoatio = 1;
+ module_param(ql2xmvasynctoatio, int, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(ql2xmvasynctoatio,
+ 		"Move PUREX, ABTS RX and RIDA IOCBs to ATIOQ"
+ 		"0 (Default). Do not move IOCBs"
+ 		"1 - Move IOCBs.");
+ 
+ int ql2xautodetectsfp = 1;
+ module_param(ql2xautodetectsfp, int, 0444);
+ MODULE_PARM_DESC(ql2xautodetectsfp,
+ 		 "Detect SFP range and set appropriate distance.\n"
+ 		 "1 (Default): Enable\n");
+ 
++>>>>>>> e4e3a2ce9556 (scsi: qla2xxx: Add ability to autodetect SFP type)
  /*
   * SCSI host template entry points
   */
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index 23b15e5afee2..680e4e54f40b 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -565,47 +565,17 @@ qla2x00_sysfs_read_sfp(struct file *filp, struct kobject *kobj,
 {
 	struct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,
 	    struct device, kobj)));
-	struct qla_hw_data *ha = vha->hw;
-	uint16_t iter, addr, offset;
 	int rval;
 
-	if (!capable(CAP_SYS_ADMIN) || off != 0 || count != SFP_DEV_SIZE * 2)
+	if (!capable(CAP_SYS_ADMIN) || off != 0 || count < SFP_DEV_SIZE)
 		return 0;
 
-	if (ha->sfp_data)
-		goto do_read;
-
-	ha->sfp_data = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,
-	    &ha->sfp_data_dma);
-	if (!ha->sfp_data) {
-		ql_log(ql_log_warn, vha, 0x706c,
-		    "Unable to allocate memory for SFP read-data.\n");
+	if (qla2x00_reset_active(vha))
 		return 0;
-	}
-
-do_read:
-	memset(ha->sfp_data, 0, SFP_BLOCK_SIZE);
-	addr = 0xa0;
-	for (iter = 0, offset = 0; iter < (SFP_DEV_SIZE * 2) / SFP_BLOCK_SIZE;
-	    iter++, offset += SFP_BLOCK_SIZE) {
-		if (iter == 4) {
-			/* Skip to next device address. */
-			addr = 0xa2;
-			offset = 0;
-		}
-
-		rval = qla2x00_read_sfp(vha, ha->sfp_data_dma, ha->sfp_data,
-		    addr, offset, SFP_BLOCK_SIZE, BIT_1);
-		if (rval != QLA_SUCCESS) {
-			ql_log(ql_log_warn, vha, 0x706d,
-			    "Unable to read SFP data (%x/%x/%x).\n", rval,
-			    addr, offset);
 
-			return -EIO;
-		}
-		memcpy(buf, ha->sfp_data, SFP_BLOCK_SIZE);
-		buf += SFP_BLOCK_SIZE;
-	}
+	rval = qla2x00_read_sfp_dev(vha, buf, count);
+	if (rval)
+		return -EIO;
 
 	return count;
 }
@@ -615,7 +585,7 @@ static struct bin_attribute sysfs_sfp_attr = {
 		.name = "sfp",
 		.mode = S_IRUSR | S_IWUSR,
 	},
-	.size = SFP_DEV_SIZE * 2,
+	.size = SFP_DEV_SIZE,
 	.read = qla2x00_sysfs_read_sfp,
 };
 
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index 99f5a88cc283..56f434f44719 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -761,6 +761,11 @@ skip_rio:
 
 		vha->flags.management_server_logged_in = 0;
 		qla2x00_post_aen_work(vha, FCH_EVT_LINKUP, ha->link_data_rate);
+
+		if (AUTO_DETECT_SFP_SUPPORT(vha)) {
+			set_bit(DETECT_SFP_CHANGE, &vha->dpc_flags);
+			qla2xxx_wake_dpc(vha);
+		}
 		break;
 
 	case MBA_LOOP_DOWN:		/* Loop Down Event */
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
