IB/hfi1: Only set fd pointer when base context is completely initialized

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit e87473bc1b6c2cb08f1b760cfc8cd012822241a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e87473bc.failed

The allocate_ctxt() function adds the context to the fd data structure.
Since the context is not completely initialized, this can cause confusion
as to whether the context is valid or not.

Move the fd reference from allocate_ctxt() to setup_base_ctxt().
Update the necessary functions to be aware of this move.

	Reviewed-by: Sebastian Sanchez <sebastian.sanchez@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit e87473bc1b6c2cb08f1b760cfc8cd012822241a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/file_ops.c
#	drivers/infiniband/hw/hfi1/user_exp_rcv.c
#	drivers/infiniband/hw/hfi1/user_exp_rcv.h
#	drivers/infiniband/hw/hfi1/user_sdma.h
diff --cc drivers/infiniband/hw/hfi1/file_ops.c
index 8df16f5d7e38,a0c13fa5babb..000000000000
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@@ -70,31 -71,41 +70,63 @@@
  /*
   * File operation functions
   */
 -static int hfi1_file_open(struct inode *inode, struct file *fp);
 -static int hfi1_file_close(struct inode *inode, struct file *fp);
 -static ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from);
 -static unsigned int hfi1_poll(struct file *fp, struct poll_table_struct *pt);
 -static int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma);
 -
 +static int hfi1_file_open(struct inode *, struct file *);
 +static int hfi1_file_close(struct inode *, struct file *);
 +static ssize_t hfi1_aio_write(struct kiocb *, const struct iovec *,
 +			      unsigned long, loff_t);
 +static unsigned int hfi1_poll(struct file *, struct poll_table_struct *);
 +static int hfi1_file_mmap(struct file *, struct vm_area_struct *);
 +
++<<<<<<< HEAD
 +static u64 kvirt_to_phys(void *);
 +static int assign_ctxt(struct file *, struct hfi1_user_info *);
 +static int init_subctxts(struct hfi1_ctxtdata *, const struct hfi1_user_info *);
 +static int user_init(struct file *);
 +static int get_ctxt_info(struct file *, void __user *, __u32);
 +static int get_base_info(struct file *, void __user *, __u32);
 +static int setup_ctxt(struct file *);
 +static int setup_subctxt(struct hfi1_ctxtdata *);
 +static int get_user_context(struct file *, struct hfi1_user_info *, int);
 +static int find_shared_ctxt(struct file *, const struct hfi1_user_info *);
 +static int allocate_ctxt(struct file *, struct hfi1_devdata *,
 +			 struct hfi1_user_info *);
 +static unsigned int poll_urgent(struct file *, struct poll_table_struct *);
 +static unsigned int poll_next(struct file *, struct poll_table_struct *);
 +static int user_event_ack(struct hfi1_ctxtdata *, int, unsigned long);
 +static int set_ctxt_pkey(struct hfi1_ctxtdata *, unsigned, u16);
 +static int manage_rcvq(struct hfi1_ctxtdata *, unsigned, int);
 +static int vma_fault(struct vm_area_struct *, struct vm_fault *);
++=======
+ static u64 kvirt_to_phys(void *addr);
+ static int assign_ctxt(struct hfi1_filedata *fd, struct hfi1_user_info *uinfo);
+ static int init_subctxts(struct hfi1_ctxtdata *uctxt,
+ 			 const struct hfi1_user_info *uinfo);
+ static int init_user_ctxt(struct hfi1_filedata *fd,
+ 			  struct hfi1_ctxtdata *uctxt);
+ static void user_init(struct hfi1_ctxtdata *uctxt);
+ static int get_ctxt_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int get_base_info(struct hfi1_filedata *fd, void __user *ubase,
+ 			 __u32 len);
+ static int setup_base_ctxt(struct hfi1_filedata *fd,
+ 			   struct hfi1_ctxtdata *uctxt);
+ static int setup_subctxt(struct hfi1_ctxtdata *uctxt);
+ 
+ static int find_sub_ctxt(struct hfi1_filedata *fd,
+ 			 const struct hfi1_user_info *uinfo);
+ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
+ 			 struct hfi1_user_info *uinfo,
+ 			 struct hfi1_ctxtdata **cd);
+ static void deallocate_ctxt(struct hfi1_ctxtdata *uctxt);
+ static unsigned int poll_urgent(struct file *fp, struct poll_table_struct *pt);
+ static unsigned int poll_next(struct file *fp, struct poll_table_struct *pt);
+ static int user_event_ack(struct hfi1_ctxtdata *uctxt, u16 subctxt,
+ 			  unsigned long events);
+ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, u16 subctxt, u16 pkey);
+ static int manage_rcvq(struct hfi1_ctxtdata *uctxt, u16 subctxt,
+ 		       int start_stop);
+ static int vma_fault(struct vm_fault *vmf);
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,
  			    unsigned long arg);
  
@@@ -842,16 -844,15 +874,17 @@@ static u64 kvirt_to_phys(void *addr
  	return paddr;
  }
  
 -static int assign_ctxt(struct hfi1_filedata *fd, struct hfi1_user_info *uinfo)
 +static int assign_ctxt(struct file *fp, struct hfi1_user_info *uinfo)
  {
 -	int ret;
 +	int i_minor, ret = 0;
  	unsigned int swmajor, swminor;
+ 	struct hfi1_ctxtdata *uctxt = NULL;
  
  	swmajor = uinfo->userversion >> 16;
 -	if (swmajor != HFI1_USER_SWMAJOR)
 -		return -ENODEV;
 +	if (swmajor != HFI1_USER_SWMAJOR) {
 +		ret = -ENODEV;
 +		goto done;
 +	}
  
  	swminor = uinfo->userversion & 0xffff;
  
@@@ -870,99 -870,120 +903,156 @@@
  	}
  
  	/*
 -	 * Allocate a base context if context sharing is not required or we
 -	 * couldn't find a sub context.
 +	 * We execute the following block if we couldn't find a
 +	 * shared context or if context sharing is not required.
  	 */
++<<<<<<< HEAD
 +	if (!ret) {
 +		i_minor = iminor(file_inode(fp)) - HFI1_USER_MINOR_BASE;
 +		ret = get_user_context(fp, uinfo, i_minor);
 +	}
 +done_unlock:
 +	mutex_unlock(&hfi1_mutex);
 +done:
++=======
+ 	if (!ret)
+ 		ret = allocate_ctxt(fd, fd->dd, uinfo, &uctxt);
+ 
+ 	mutex_unlock(&hfi1_mutex);
+ 
+ 	/* Depending on the context type, do the appropriate init */
+ 	if (ret > 0) {
+ 		/*
+ 		 * sub-context info can only be set up after the base
+ 		 * context has been completed.
+ 		 */
+ 		ret = wait_event_interruptible(fd->uctxt->wait, !test_bit(
+ 					       HFI1_CTXT_BASE_UNINIT,
+ 					       &fd->uctxt->event_flags));
+ 		if (test_bit(HFI1_CTXT_BASE_FAILED, &fd->uctxt->event_flags))
+ 			ret = -ENOMEM;
+ 
+ 		/* The only thing a sub context needs is the user_xxx stuff */
+ 		if (!ret)
+ 			ret = init_user_ctxt(fd, fd->uctxt);
+ 
+ 		if (ret)
+ 			clear_bit(fd->subctxt, fd->uctxt->in_use_ctxts);
+ 
+ 	} else if (!ret) {
+ 		ret = setup_base_ctxt(fd, uctxt);
+ 		if (uctxt->subctxt_cnt) {
+ 			/* If there is an error, set the failed bit. */
+ 			if (ret)
+ 				set_bit(HFI1_CTXT_BASE_FAILED,
+ 					&uctxt->event_flags);
+ 			/*
+ 			 * Base context is done, notify anybody using a
+ 			 * sub-context that is waiting for this completion
+ 			 */
+ 			clear_bit(HFI1_CTXT_BASE_UNINIT, &uctxt->event_flags);
+ 			wake_up(&uctxt->wait);
+ 		}
+ 		if (ret)
+ 			deallocate_ctxt(uctxt);
+ 	}
+ 
+ 	/* If an error occurred, clear the reference */
+ 	if (ret && fd->uctxt) {
+ 		hfi1_rcd_put(fd->uctxt);
+ 		fd->uctxt = NULL;
+ 	}
+ 
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  	return ret;
  }
  
 -/*
 - * The hfi1_mutex must be held when this function is called.  It is
 - * necessary to ensure serialized access to the bitmask in_use_ctxts.
 - */
 -static int find_sub_ctxt(struct hfi1_filedata *fd,
 -			 const struct hfi1_user_info *uinfo)
 +static int get_user_context(struct file *fp, struct hfi1_user_info *uinfo,
 +			    int devno)
  {
 -	u16 i;
 -	struct hfi1_devdata *dd = fd->dd;
 -	u16 subctxt;
 -
 -	for (i = dd->first_dyn_alloc_ctxt; i < dd->num_rcv_contexts; i++) {
 -		struct hfi1_ctxtdata *uctxt = dd->rcd[i];
 +	struct hfi1_devdata *dd = NULL;
 +	int devmax, npresent, nup;
  
 -		/* Skip ctxts which are not yet open */
 -		if (!uctxt ||
 -		    bitmap_empty(uctxt->in_use_ctxts,
 -				 HFI1_MAX_SHARED_CTXTS))
 -			continue;
 +	devmax = hfi1_count_units(&npresent, &nup);
 +	if (!npresent)
 +		return -ENXIO;
  
 -		/* Skip dynamically allocted kernel contexts */
 -		if (uctxt->sc && (uctxt->sc->type == SC_KERNEL))
 -			continue;
 +	if (!nup)
 +		return -ENETDOWN;
  
 -		/* Skip ctxt if it doesn't match the requested one */
 -		if (memcmp(uctxt->uuid, uinfo->uuid,
 -			   sizeof(uctxt->uuid)) ||
 -		    uctxt->jkey != generate_jkey(current_uid()) ||
 -		    uctxt->subctxt_id != uinfo->subctxt_id ||
 -		    uctxt->subctxt_cnt != uinfo->subctxt_cnt)
 -			continue;
 +	dd = hfi1_lookup(devno);
 +	if (!dd)
 +		return -ENODEV;
 +	else if (!dd->freectxts)
 +		return -EBUSY;
  
 -		/* Verify the sharing process matches the master */
 -		if (uctxt->userversion != uinfo->userversion)
 -			return -EINVAL;
 +	return allocate_ctxt(fp, dd, uinfo);
 +}
  
 -		/* Find an unused context */
 -		subctxt = find_first_zero_bit(uctxt->in_use_ctxts,
 -					      HFI1_MAX_SHARED_CTXTS);
 -		if (subctxt >= uctxt->subctxt_cnt)
 -			return -EBUSY;
++<<<<<<< HEAD
 +static int find_shared_ctxt(struct file *fp,
 +			    const struct hfi1_user_info *uinfo)
 +{
 +	int devmax, ndev, i;
 +	int ret = 0;
 +	struct hfi1_filedata *fd = fp->private_data;
  
 -		fd->uctxt = uctxt;
 -		fd->subctxt = subctxt;
 +	devmax = hfi1_count_units(NULL, NULL);
  
 -		hfi1_rcd_get(uctxt);
 -		__set_bit(fd->subctxt, uctxt->in_use_ctxts);
 +	for (ndev = 0; ndev < devmax; ndev++) {
 +		struct hfi1_devdata *dd = hfi1_lookup(ndev);
  
 -		return 1;
 +		if (!(dd && (dd->flags & HFI1_PRESENT) && dd->kregbase))
 +			continue;
 +		for (i = dd->first_dyn_alloc_ctxt;
 +		     i < dd->num_rcv_contexts; i++) {
 +			struct hfi1_ctxtdata *uctxt = dd->rcd[i];
 +
 +			/* Skip ctxts which are not yet open */
 +			if (!uctxt || !uctxt->cnt)
 +				continue;
 +
 +			/* Skip dynamically allocted kernel contexts */
 +			if (uctxt->sc && (uctxt->sc->type == SC_KERNEL))
 +				continue;
 +
 +			/* Skip ctxt if it doesn't match the requested one */
 +			if (memcmp(uctxt->uuid, uinfo->uuid,
 +				   sizeof(uctxt->uuid)) ||
 +			    uctxt->jkey != generate_jkey(current_uid()) ||
 +			    uctxt->subctxt_id != uinfo->subctxt_id ||
 +			    uctxt->subctxt_cnt != uinfo->subctxt_cnt)
 +				continue;
 +
 +			/* Verify the sharing process matches the master */
 +			if (uctxt->userversion != uinfo->userversion ||
 +			    uctxt->cnt >= uctxt->subctxt_cnt) {
 +				ret = -EINVAL;
 +				goto done;
 +			}
 +			fd->uctxt = uctxt;
 +			fd->subctxt  = uctxt->cnt++;
 +			uctxt->active_slaves |= 1 << fd->subctxt;
 +			ret = 1;
 +			goto done;
 +		}
  	}
  
 -	return 0;
 +done:
 +	return ret;
  }
  
 +static int allocate_ctxt(struct file *fp, struct hfi1_devdata *dd,
 +			 struct hfi1_user_info *uinfo)
++=======
+ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
+ 			 struct hfi1_user_info *uinfo,
+ 			 struct hfi1_ctxtdata **cd)
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  {
 +	struct hfi1_filedata *fd = fp->private_data;
  	struct hfi1_ctxtdata *uctxt;
 -	u16 ctxt;
 +	unsigned ctxt;
  	int ret, numa;
  
  	if (dd->flags & HFI1_FROZEN) {
@@@ -1048,13 -1075,15 +1138,18 @@@
  	 */
  	if (dd->freectxts-- == dd->num_user_contexts)
  		aspm_disable_all(dd);
- 	fd->uctxt = uctxt;
  
++<<<<<<< HEAD
++=======
+ 	*cd = uctxt;
+ 
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  	return 0;
  
  ctxdata_free:
+ 	*cd = NULL;
  	dd->rcd[ctxt] = NULL;
 -	hfi1_rcd_put(uctxt);
 +	hfi1_free_ctxtdata(dd, uctxt);
  	return ret;
  }
  
@@@ -1217,61 -1246,64 +1312,111 @@@ static int get_ctxt_info(struct file *f
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int setup_ctxt(struct file *fp)
 +{
 +	struct hfi1_filedata *fd = fp->private_data;
 +	struct hfi1_ctxtdata *uctxt = fd->uctxt;
++=======
+ static int init_user_ctxt(struct hfi1_filedata *fd,
+ 			  struct hfi1_ctxtdata *uctxt)
+ {
+ 	int ret;
+ 
+ 	ret = hfi1_user_sdma_alloc_queues(uctxt, fd);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = hfi1_user_exp_rcv_init(fd, uctxt);
+ 	if (ret)
+ 		hfi1_user_sdma_free_queues(fd, uctxt);
+ 
+ 	return ret;
+ }
+ 
+ static int setup_base_ctxt(struct hfi1_filedata *fd,
+ 			   struct hfi1_ctxtdata *uctxt)
+ {
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  	struct hfi1_devdata *dd = uctxt->dd;
  	int ret = 0;
  
 -	hfi1_init_ctxt(uctxt->sc);
 +	/*
 +	 * Context should be set up only once, including allocation and
 +	 * programming of eager buffers. This is done if context sharing
 +	 * is not requested or by the master process.
 +	 */
 +	if (!uctxt->subctxt_cnt || !fd->subctxt) {
 +		ret = hfi1_init_ctxt(uctxt->sc);
 +		if (ret)
 +			goto done;
 +
 +		/* Now allocate the RcvHdr queue and eager buffers. */
 +		ret = hfi1_create_rcvhdrq(dd, uctxt);
 +		if (ret)
 +			goto done;
 +		ret = hfi1_setup_eagerbufs(uctxt);
 +		if (ret)
 +			goto done;
 +		if (uctxt->subctxt_cnt && !fd->subctxt) {
 +			ret = setup_subctxt(uctxt);
 +			if (ret)
 +				goto done;
 +		}
 +	} else {
 +		ret = wait_event_interruptible(uctxt->wait, !test_bit(
 +					       HFI1_CTXT_MASTER_UNINIT,
 +					       &uctxt->event_flags));
 +		if (ret)
 +			goto done;
 +	}
  
 -	/* Now allocate the RcvHdr queue and eager buffers. */
 -	ret = hfi1_create_rcvhdrq(dd, uctxt);
 +	ret = hfi1_user_sdma_alloc_queues(uctxt, fp);
  	if (ret)
 -		return ret;
 -
 -	ret = hfi1_setup_eagerbufs(uctxt);
 +		goto done;
 +	/*
 +	 * Expected receive has to be setup for all processes (including
 +	 * shared contexts). However, it has to be done after the master
 +	 * context has been fully configured as it depends on the
 +	 * eager/expected split of the RcvArray entries.
 +	 * Setting it up here ensures that the subcontexts will be waiting
 +	 * (due to the above wait_event_interruptible() until the master
 +	 * is setup.
 +	 */
 +	ret = hfi1_user_exp_rcv_init(fp);
  	if (ret)
 -		goto setup_failed;
 +		goto done;
  
++<<<<<<< HEAD
 +	set_bit(HFI1_CTXT_SETUP_DONE, &uctxt->event_flags);
 +done:
++=======
+ 	/* If sub-contexts are enabled, do the appropriate setup */
+ 	if (uctxt->subctxt_cnt)
+ 		ret = setup_subctxt(uctxt);
+ 	if (ret)
+ 		goto setup_failed;
+ 
+ 	ret = hfi1_alloc_ctxt_rcv_groups(uctxt);
+ 	if (ret)
+ 		goto setup_failed;
+ 
+ 	ret = init_user_ctxt(fd, uctxt);
+ 	if (ret)
+ 		goto setup_failed;
+ 
+ 	user_init(uctxt);
+ 
+ 	/* Now that the context is set up, the fd can get a reference. */
+ 	fd->uctxt = uctxt;
+ 	hfi1_rcd_get(uctxt);
+ 
+ 	return 0;
+ 
+ setup_failed:
+ 	/* Call _free_ctxtdata, not _rcd_put().  We still need the context. */
+ 	hfi1_free_ctxtdata(dd, uctxt);
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  	return ret;
  }
  
diff --cc drivers/infiniband/hw/hfi1/user_exp_rcv.c
index c7f13df471c4,d9036ba3f4eb..000000000000
--- a/drivers/infiniband/hw/hfi1/user_exp_rcv.c
+++ b/drivers/infiniband/hw/hfi1/user_exp_rcv.c
@@@ -154,13 -104,11 +154,19 @@@ static inline void tid_group_move(struc
   * receive caching. This needs to be done after the context has
   * been configured with the eager/expected RcvEntry counts.
   */
++<<<<<<< HEAD
 +int hfi1_user_exp_rcv_init(struct file *fp)
 +{
 +	struct hfi1_filedata *fd = fp->private_data;
 +	struct hfi1_ctxtdata *uctxt = fd->uctxt;
++=======
+ int hfi1_user_exp_rcv_init(struct hfi1_filedata *fd,
+ 			   struct hfi1_ctxtdata *uctxt)
+ {
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  	struct hfi1_devdata *dd = uctxt->dd;
 -	int ret = 0;
 +	unsigned tidbase;
 +	int i, ret = 0;
  
  	spin_lock_init(&fd->tid_lock);
  	spin_lock_init(&fd->invalid_lock);
diff --cc drivers/infiniband/hw/hfi1/user_exp_rcv.h
index d1d7d3d3bd44,6cbaa4cf4970..000000000000
--- a/drivers/infiniband/hw/hfi1/user_exp_rcv.h
+++ b/drivers/infiniband/hw/hfi1/user_exp_rcv.h
@@@ -49,32 -49,16 +49,44 @@@
  
  #include "hfi.h"
  
 -#include "exp_rcv.h"
 +#define EXP_TID_TIDLEN_MASK   0x7FFULL
 +#define EXP_TID_TIDLEN_SHIFT  0
 +#define EXP_TID_TIDCTRL_MASK  0x3ULL
 +#define EXP_TID_TIDCTRL_SHIFT 20
 +#define EXP_TID_TIDIDX_MASK   0x3FFULL
 +#define EXP_TID_TIDIDX_SHIFT  22
 +#define EXP_TID_GET(tid, field)	\
 +	(((tid) >> EXP_TID_TID##field##_SHIFT) & EXP_TID_TID##field##_MASK)
  
++<<<<<<< HEAD
 +#define EXP_TID_SET(field, value)			\
 +	(((value) & EXP_TID_TID##field##_MASK) <<	\
 +	 EXP_TID_TID##field##_SHIFT)
 +#define EXP_TID_CLEAR(tid, field) ({					\
 +		(tid) &= ~(EXP_TID_TID##field##_MASK <<			\
 +			   EXP_TID_TID##field##_SHIFT);			\
 +		})
 +#define EXP_TID_RESET(tid, field, value) do {				\
 +		EXP_TID_CLEAR(tid, field);				\
 +		(tid) |= EXP_TID_SET(field, (value));			\
 +	} while (0)
 +
 +void hfi1_user_exp_rcv_grp_free(struct hfi1_ctxtdata *uctxt);
 +int hfi1_user_exp_rcv_init(struct file *);
 +int hfi1_user_exp_rcv_free(struct hfi1_filedata *);
 +int hfi1_user_exp_rcv_setup(struct file *, struct hfi1_tid_info *);
 +int hfi1_user_exp_rcv_clear(struct file *, struct hfi1_tid_info *);
 +int hfi1_user_exp_rcv_invalid(struct file *, struct hfi1_tid_info *);
++=======
+ int hfi1_user_exp_rcv_init(struct hfi1_filedata *fd,
+ 			   struct hfi1_ctxtdata *uctxt);
+ void hfi1_user_exp_rcv_free(struct hfi1_filedata *fd);
+ int hfi1_user_exp_rcv_setup(struct hfi1_filedata *fd,
+ 			    struct hfi1_tid_info *tinfo);
+ int hfi1_user_exp_rcv_clear(struct hfi1_filedata *fd,
+ 			    struct hfi1_tid_info *tinfo);
+ int hfi1_user_exp_rcv_invalid(struct hfi1_filedata *fd,
+ 			      struct hfi1_tid_info *tinfo);
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
  
  #endif /* _HFI1_USER_EXP_RCV_H */
diff --cc drivers/infiniband/hw/hfi1/user_sdma.h
index 39001714f551,84c199d3e003..000000000000
--- a/drivers/infiniband/hw/hfi1/user_sdma.h
+++ b/drivers/infiniband/hw/hfi1/user_sdma.h
@@@ -78,7 -79,12 +78,19 @@@ struct hfi1_user_sdma_comp_q 
  	struct hfi1_sdma_comp_entry *comps;
  };
  
++<<<<<<< HEAD
 +int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *, struct file *);
 +int hfi1_user_sdma_free_queues(struct hfi1_filedata *);
 +int hfi1_user_sdma_process_request(struct file *, struct iovec *, unsigned long,
 +				   unsigned long *);
++=======
+ int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt,
+ 				struct hfi1_filedata *fd);
+ int hfi1_user_sdma_free_queues(struct hfi1_filedata *fd,
+ 			       struct hfi1_ctxtdata *uctxt);
+ int hfi1_user_sdma_process_request(struct hfi1_filedata *fd,
+ 				   struct iovec *iovec, unsigned long dim,
+ 				   unsigned long *count);
+ 
+ #endif /* _HFI1_USER_SDMA_H */
++>>>>>>> e87473bc1b6c (IB/hfi1: Only set fd pointer when base context is completely initialized)
* Unmerged path drivers/infiniband/hw/hfi1/file_ops.c
* Unmerged path drivers/infiniband/hw/hfi1/user_exp_rcv.c
* Unmerged path drivers/infiniband/hw/hfi1/user_exp_rcv.h
diff --git a/drivers/infiniband/hw/hfi1/user_sdma.c b/drivers/infiniband/hw/hfi1/user_sdma.c
index 44eb867b91f4..0e6dd897b438 100644
--- a/drivers/infiniband/hw/hfi1/user_sdma.c
+++ b/drivers/infiniband/hw/hfi1/user_sdma.c
@@ -480,9 +480,9 @@ done:
 	return ret;
 }
 
-int hfi1_user_sdma_free_queues(struct hfi1_filedata *fd)
+int hfi1_user_sdma_free_queues(struct hfi1_filedata *fd,
+			       struct hfi1_ctxtdata *uctxt)
 {
-	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 	struct hfi1_user_sdma_pkt_q *pq;
 	unsigned long flags;
 
* Unmerged path drivers/infiniband/hw/hfi1/user_sdma.h
