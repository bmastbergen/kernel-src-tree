RDMA/netlink: Add netlink device definitions to UAPI

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Leon Romanovsky <leonro@mellanox.com>
commit 1a6e7c31d71db34d1b9bc3acc87eaea6c2ecc997
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1a6e7c31.failed

Introduce new defines to rdma_netlink.h, so the RDMA configuration tool
will be able to communicate with RDMA subsystem by using the shared defines.

The addition of new client (NLDEV) revealed the fact that we exposed by
mistake the RDMA_NL_I40IW define which is not backed by any RDMA netlink
by now and it won't be exposed in the future too. So this patch reuses
the value and deletes the old defines.

The NLDEV operates with objects. The struct ib_device has two straightforward
objects: device itself and ports of that device.

This brings us to propose the following commands to work on those objects:
 * RDMA_NLDEV_CMD_{GET,SET,NEW,DEL} - works on ib_device itself
 * RDMA_NLDEV_CMD_PORT_{GET,SET,NEW,DEL} - works on ports of specific ib_device

Those commands receive/return the device index (RDMA_NLDEV_ATTR_DEV_INDEX)
and port index (RDMA_NLDEV_ATTR_PORT_INDEX). For device object accesses,
the RDMA_NLDEV_ATTR_PORT_INDEX will return the maximum number of ports
for specific ib_device and for port access the actual port index.

The port index starts from 1 to follow RDMA/core internal semantics and
the sysfs exposed knobs.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
(cherry picked from commit 1a6e7c31d71db34d1b9bc3acc87eaea6c2ecc997)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/netlink.c
diff --cc drivers/infiniband/core/netlink.c
index 680dd421639c,27352a352770..000000000000
--- a/drivers/infiniband/core/netlink.c
+++ b/drivers/infiniband/core/netlink.c
@@@ -40,76 -40,92 +40,102 @@@
  #include <rdma/rdma_netlink.h>
  #include "core_priv.h"
  
 -#include "core_priv.h"
 -
 -static DEFINE_MUTEX(rdma_nl_mutex);
 +struct ibnl_client {
 +	struct list_head		list;
 +	int				index;
 +	int				nops;
 +	const struct ibnl_client_cbs   *cb_table;
 +};
 +
 +static DEFINE_MUTEX(ibnl_mutex);
  static struct sock *nls;
 -static struct {
 -	const struct rdma_nl_cbs   *cb_table;
 -} rdma_nl_types[RDMA_NL_NUM_CLIENTS];
 +static LIST_HEAD(client_list);
  
 -int rdma_nl_chk_listeners(unsigned int group)
 +int ibnl_chk_listeners(unsigned int group)
  {
++<<<<<<< HEAD
 +	if (netlink_has_listeners(nls, group) == 0)
 +		return -1;
 +	return 0;
++=======
+ 	return (netlink_has_listeners(nls, group)) ? 0 : -1;
+ }
+ EXPORT_SYMBOL(rdma_nl_chk_listeners);
+ 
+ static bool is_nl_msg_valid(unsigned int type, unsigned int op)
+ {
+ 	static const unsigned int max_num_ops[RDMA_NL_NUM_CLIENTS - 1] = {
+ 				  RDMA_NL_RDMA_CM_NUM_OPS,
+ 				  RDMA_NL_IWPM_NUM_OPS,
+ 				  0,
+ 				  RDMA_NL_LS_NUM_OPS,
+ 				  RDMA_NLDEV_NUM_OPS };
+ 
+ 	/*
+ 	 * This BUILD_BUG_ON is intended to catch addition of new
+ 	 * RDMA netlink protocol without updating the array above.
+ 	 */
+ 	BUILD_BUG_ON(RDMA_NL_NUM_CLIENTS != 6);
+ 
+ 	if (type > RDMA_NL_NUM_CLIENTS - 1)
+ 		return false;
+ 
+ 	return (op < max_num_ops[type - 1]) ? true : false;
++>>>>>>> 1a6e7c31d71d (RDMA/netlink: Add netlink device definitions to UAPI)
  }
  
 -static bool is_nl_valid(unsigned int type, unsigned int op)
 +int ibnl_add_client(int index, int nops,
 +		    const struct ibnl_client_cbs cb_table[])
  {
 -	const struct rdma_nl_cbs *cb_table;
 +	struct ibnl_client *cur;
 +	struct ibnl_client *nl_client;
  
 -	if (!is_nl_msg_valid(type, op))
 -		return false;
 +	nl_client = kmalloc(sizeof *nl_client, GFP_KERNEL);
 +	if (!nl_client)
 +		return -ENOMEM;
  
 -	cb_table = rdma_nl_types[type].cb_table;
 -	if (!cb_table || (!cb_table[op].dump && !cb_table[op].doit))
 -		return false;
 -	return true;
 -}
 +	nl_client->index	= index;
 +	nl_client->nops		= nops;
 +	nl_client->cb_table	= cb_table;
  
 -void rdma_nl_register(unsigned int index,
 -		      const struct rdma_nl_cbs cb_table[])
 -{
 -	mutex_lock(&rdma_nl_mutex);
 -	if (!is_nl_msg_valid(index, 0)) {
 -		/*
 -		 * All clients are not interesting in success/failure of
 -		 * this call. They want to see the print to error log and
 -		 * continue their initialization. Print warning for them,
 -		 * because it is programmer's error to be here.
 -		 */
 -		mutex_unlock(&rdma_nl_mutex);
 -		WARN(true,
 -		     "The not-valid %u index was supplied to RDMA netlink\n",
 -		     index);
 -		return;
 -	}
 +	mutex_lock(&ibnl_mutex);
  
 -	if (rdma_nl_types[index].cb_table) {
 -		mutex_unlock(&rdma_nl_mutex);
 -		WARN(true,
 -		     "The %u index is already registered in RDMA netlink\n",
 -		     index);
 -		return;
 +	list_for_each_entry(cur, &client_list, list) {
 +		if (cur->index == index) {
 +			pr_warn("Client for %d already exists\n", index);
 +			mutex_unlock(&ibnl_mutex);
 +			kfree(nl_client);
 +			return -EINVAL;
 +		}
  	}
  
 -	rdma_nl_types[index].cb_table = cb_table;
 -	mutex_unlock(&rdma_nl_mutex);
 +	list_add_tail(&nl_client->list, &client_list);
 +
 +	mutex_unlock(&ibnl_mutex);
 +
 +	return 0;
  }
 -EXPORT_SYMBOL(rdma_nl_register);
 +EXPORT_SYMBOL(ibnl_add_client);
  
 -void rdma_nl_unregister(unsigned int index)
 +int ibnl_remove_client(int index)
  {
 -	mutex_lock(&rdma_nl_mutex);
 -	rdma_nl_types[index].cb_table = NULL;
 -	mutex_unlock(&rdma_nl_mutex);
 +	struct ibnl_client *cur, *next;
 +
 +	mutex_lock(&ibnl_mutex);
 +	list_for_each_entry_safe(cur, next, &client_list, list) {
 +		if (cur->index == index) {
 +			list_del(&(cur->list));
 +			mutex_unlock(&ibnl_mutex);
 +			kfree(cur);
 +			return 0;
 +		}
 +	}
 +	pr_warn("Can't remove callback for client idx %d. Not found\n", index);
 +	mutex_unlock(&ibnl_mutex);
 +
 +	return -EINVAL;
  }
 -EXPORT_SYMBOL(rdma_nl_unregister);
 +EXPORT_SYMBOL(ibnl_remove_client);
  
  void *ibnl_put_msg(struct sk_buff *skb, struct nlmsghdr **nlh, int seq,
  		   int len, int client, int op, int flags)
* Unmerged path drivers/infiniband/core/netlink.c
diff --git a/include/uapi/rdma/rdma_netlink.h b/include/uapi/rdma/rdma_netlink.h
index 02fe8390c18f..a44229fa5eca 100644
--- a/include/uapi/rdma/rdma_netlink.h
+++ b/include/uapi/rdma/rdma_netlink.h
@@ -8,7 +8,7 @@ enum {
 	RDMA_NL_IWCM,
 	RDMA_NL_RSVD,
 	RDMA_NL_LS,	/* RDMA Local Services */
-	RDMA_NL_I40IW,
+	RDMA_NL_NLDEV,	/* RDMA device interface */
 	RDMA_NL_NUM_CLIENTS
 };
 
@@ -222,4 +222,41 @@ struct rdma_nla_ls_gid {
 	__u8		gid[16];
 };
 
+enum rdma_nldev_command {
+	RDMA_NLDEV_CMD_UNSPEC,
+
+	RDMA_NLDEV_CMD_GET, /* can dump */
+	RDMA_NLDEV_CMD_SET,
+	RDMA_NLDEV_CMD_NEW,
+	RDMA_NLDEV_CMD_DEL,
+
+	RDMA_NLDEV_CMD_PORT_GET, /* can dump */
+	RDMA_NLDEV_CMD_PORT_SET,
+	RDMA_NLDEV_CMD_PORT_NEW,
+	RDMA_NLDEV_CMD_PORT_DEL,
+
+	RDMA_NLDEV_NUM_OPS
+};
+
+enum rdma_nldev_attr {
+	/* don't change the order or add anything between, this is ABI! */
+	RDMA_NLDEV_ATTR_UNSPEC,
+
+	/* Identifier for ib_device */
+	RDMA_NLDEV_ATTR_DEV_INDEX,		/* u32 */
+
+	RDMA_NLDEV_ATTR_DEV_NAME,		/* string */
+	/*
+	 * Device index together with port index are identifiers
+	 * for port/link properties.
+	 *
+	 * For RDMA_NLDEV_CMD_GET commamnd, port index will return number
+	 * of available ports in ib_device, while for port specific operations,
+	 * it will be real port index as it appears in sysfs. Port index follows
+	 * sysfs notation and starts from 1 for the first port.
+	 */
+	RDMA_NLDEV_ATTR_PORT_INDEX,		/* u32 */
+
+	RDMA_NLDEV_ATTR_MAX
+};
 #endif /* _UAPI_RDMA_NETLINK_H */
