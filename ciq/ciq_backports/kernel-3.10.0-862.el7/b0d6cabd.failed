qla2xxx: Enable Extended Logins support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit b0d6cabd355ae9c13c53680cfe8b5ae58a84d2c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b0d6cabd.failed

This patch enables Extended Logins support in Qlogic ISP.
To enable extended login with Qlogic ISP24XX/25XX/26XX,
set module parameter ql2xexlogins to any non-zero number.
This will alow ISP firmware to store port database structure
information of remote login sessions to host memory provided
by driver. ISP firmware supports upto 16k total logins.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Giridhar Malavali <giridhar.malavali@qlogic.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit b0d6cabd355ae9c13c53680cfe8b5ae58a84d2c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.c
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index 866e7a991a8e,576664072a59..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -11,14 -11,12 +11,23 @@@
   * ----------------------------------------------------------------------
   * |             Level            |   Last Value Used  |     Holes	|
   * ----------------------------------------------------------------------
++<<<<<<< HEAD
 + * | Module Init and Probe        |       0x0193       | 0x0146         |
 + * | Mailbox commands             |       0x1199       | 0x111a-0x111b  |
 + * |                              |                    | 0x1155-0x1158  |
 + * |                              |                    | 0x1018-0x1019  |
 + * |                              |                    | 0x1115-0x1116  |
 + * |                              |                    | 0x10ca,0x1193  |
 + * | Device Discovery             |       0x2095       | 0x2016         |
 + * |                              |                    | 0x2020-0x2022, |
++=======
+  * | Module Init and Probe        |       0x017f       | 0x0146         |
+  * |                              |                    | 0x015b-0x0160	|
+  * |                              |                    | 0x016e-0x0170  |
+  * | Mailbox commands             |       0x1192       | 0x1018-0x1019	|
+  * |                              |                    | 0x111a-0x111b  |
+  * | Device Discovery             |       0x2016       | 0x2020-0x2022, |
++>>>>>>> b0d6cabd355a (qla2xxx: Enable Extended Logins support)
   * |                              |                    | 0x2011-0x2012, |
   * |                              |                    | 0x2099-0x20a4  |
   * | Queue Command and IO tracing |       0x3075       | 0x300b         |
@@@ -61,18 -59,17 +70,25 @@@
   * |                              |                    | 0xb13a,0xb142  |
   * |                              |                    | 0xb13c-0xb140  |
   * |                              |                    | 0xb149		|
++<<<<<<< HEAD
 + * | MultiQ                       |       0xc010       |		|
 + * | Misc                         |       0xd300       | 0xd016-0xd017	|
 + * |                              |                    | 0xd021,0xd024	|
 + * |                              |                    | 0xd025,0xd029	|
 + * |                              |                    | 0xd02a,0xd02e	|
++=======
+  * | MultiQ                       |       0xc00c       |		|
+  * | Misc                         |       0xd300       | 0xd012-0xd014	|
+  * |                              |                    | 0xd016-0xd017	|
+  * |                              |                    | 0xd02e		|
++>>>>>>> b0d6cabd355a (qla2xxx: Enable Extended Logins support)
   * |                              |                    | 0xd031-0xd0ff	|
   * |                              |                    | 0xd101-0xd1fe	|
 - * |                              |                    | 0xd214-0xd2fe	|
 - * | Target Mode		  |	  0xe080       |		|
 - * | Target Mode Management	  |	  0xf096       | 0xf002		|
 + * |                              |                    | 0xd213-0xd2fe	|
 + * | Target Mode		  |	  0xe070       | 0xe021		|
 + * | Target Mode Management	  |	  0xf072       | 0xf002-0xf003	|
   * |                              |                    | 0xf046-0xf049  |
 - * | Target Mode Task Management  |	  0x1000d      |		|
 + * | Target Mode Task Management  |	  0x1000b      |		|
   * ----------------------------------------------------------------------
   */
  
diff --cc drivers/scsi/qla2xxx/qla_def.h
index e18cc36570ad,8f465b7965fc..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3013,12 -2963,12 +3014,16 @@@ struct qla_hw_data 
  		uint32_t	isp82xx_no_md_cap:1;
  		uint32_t	host_shutting_down:1;
  		uint32_t	idc_compl_status:1;
- 
  		uint32_t        mr_reset_hdlr_active:1;
  		uint32_t        mr_intr_valid:1;
++<<<<<<< HEAD
 +		uint32_t	dport_enabled:1;
++=======
+ 
++>>>>>>> b0d6cabd355a (qla2xxx: Enable Extended Logins support)
  		uint32_t	fawwpn_enabled:1;
- 		/* 35 bits */
+ 		uint32_t	exlogins_enabled:1;
+ 		/* 34 bits */
  	} flags;
  
  	/* This spinlock is used to protect "io transactions", you must
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,d396c490e204..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -118,10 -114,10 +118,14 @@@ extern int ql2xenabledif
  extern int ql2xenablehba_err_chk;
  extern int ql2xtargetreset;
  extern int ql2xdontresethba;
 -extern uint64_t ql2xmaxlun;
 +extern unsigned int ql2xmaxlun;
  extern int ql2xmdcapmask;
  extern int ql2xmdenable;
++<<<<<<< HEAD
 +extern int ql2xfwholdabts;
++=======
+ extern int ql2xexlogins;
++>>>>>>> b0d6cabd355a (qla2xxx: Enable Extended Logins support)
  
  extern int qla2x00_loop_reset(scsi_qla_host_t *);
  extern void qla2x00_abort_all_cmds(scsi_qla_host_t *, int);
@@@ -782,4 -768,9 +788,12 @@@ extern void qla82xx_mbx_completion(scsi
  extern int qla8044_abort_isp(scsi_qla_host_t *);
  extern int qla8044_check_fw_alive(struct scsi_qla_host *);
  
++<<<<<<< HEAD
++=======
+ extern void qlt_host_reset_handler(struct qla_hw_data *ha);
+ extern int qla_get_exlogin_status(scsi_qla_host_t *, uint16_t *,
+ 	uint16_t *);
+ extern int qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr);
+ 
++>>>>>>> b0d6cabd355a (qla2xxx: Enable Extended Logins support)
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_os.c
index ae651df67490,3c4af7e10550..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -217,12 -221,11 +217,20 @@@ MODULE_PARM_DESC(ql2xmdenable
  		"0 - MiniDump disabled. "
  		"1 (Default) - MiniDump enabled.");
  
++<<<<<<< HEAD
 +int ql2xfwholdabts = 0;
 +module_param(ql2xfwholdabts, int, S_IRUGO);
 +MODULE_PARM_DESC(ql2xfwholdabts,
 +		"Allow FW to hold status IOCB until ABTS rsp received. "
 +		"0 (Default) Do not set fw option. "
 +		"1 - Set fw option to hold ABTS.");
++=======
+ int ql2xexlogins = 0;
+ module_param(ql2xexlogins, uint, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(ql2xexlogins,
+ 		 "Number of extended Logins. "
+ 		 "0 (Default)- Disabled.");
++>>>>>>> b0d6cabd355a (qla2xxx: Enable Extended Logins support)
  
  /*
   * SCSI host template entry points
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5..ec1e857bc017 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -1841,9 +1841,16 @@ qla2x00_setup_chip(scsi_qla_host_t *vha)
 			ql_dbg(ql_dbg_init, vha, 0x00ca,
 			    "Starting firmware.\n");
 
+			if (ql2xexlogins)
+				ha->flags.exlogins_enabled = 1;
+
 			rval = qla2x00_execute_fw(vha, srisc_address);
 			/* Retrieve firmware information. */
 			if (rval == QLA_SUCCESS) {
+				rval = qla2x00_set_exlogins_buffer(vha);
+				if (rval != QLA_SUCCESS)
+					goto failed;
+
 enable_82xx_npiv:
 				fw_major_version = ha->fw_major_version;
 				if (IS_P3P_TYPE(ha))
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index b8143a854ee5..a583922b7106 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -527,6 +527,10 @@ qla2x00_execute_fw(scsi_qla_host_t *vha, uint32_t risc_addr)
 			    EXTENDED_BB_CREDITS);
 		} else
 			mcp->mb[4] = 0;
+
+		if (ha->flags.exlogins_enabled)
+			mcp->mb[4] |= ENABLE_EXTENDED_LOGIN;
+
 		mcp->out_mb |= MBX_4|MBX_3|MBX_2|MBX_1;
 		mcp->in_mb |= MBX_1;
 	} else {
@@ -558,6 +562,117 @@ qla2x00_execute_fw(scsi_qla_host_t *vha, uint32_t risc_addr)
 	return rval;
 }
 
+/*
+ * qla_get_exlogin_status
+ *	Get extended login status
+ *	uses the memory offload control/status Mailbox
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fwopt:		firmware options
+ *
+ * Returns:
+ *	qla2x00 local function status
+ *
+ * Context:
+ *	Kernel context.
+ */
+#define	FETCH_XLOGINS_STAT	0x8
+int
+qla_get_exlogin_status(scsi_qla_host_t *vha, uint16_t *buf_sz,
+	uint16_t *ex_logins_cnt)
+{
+	int rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118f,
+	    "Entered %s\n", __func__);
+
+	memset(mcp->mb, 0 , sizeof(mcp->mb));
+	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+	mcp->mb[1] = FETCH_XLOGINS_STAT;
+	mcp->out_mb = MBX_1|MBX_0;
+	mcp->in_mb = MBX_10|MBX_4|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+
+	rval = qla2x00_mailbox_command(vha, mcp);
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0x1115, "Failed=%x.\n", rval);
+	} else {
+		*buf_sz = mcp->mb[4];
+		*ex_logins_cnt = mcp->mb[10];
+
+		ql_log(ql_log_info, vha, 0x1190,
+		    "buffer size 0x%x, exchange login count=%d\n",
+		    mcp->mb[4], mcp->mb[10]);
+
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1116,
+		    "Done %s.\n", __func__);
+	}
+
+	return rval;
+}
+
+/*
+ * qla_set_exlogin_mem_cfg
+ *	set extended login memory configuration
+ *	Mbx needs to be issues before init_cb is set
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	buffer:		buffer pointer
+ *	phys_addr:	physical address of buffer
+ *	size:		size of buffer
+ *	TARGET_QUEUE_LOCK must be released
+ *	ADAPTER_STATE_LOCK must be release
+ *
+ * Returns:
+ *	qla2x00 local funxtion status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+#define CONFIG_XLOGINS_MEM	0x3
+int
+qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+	struct qla_hw_data *ha = vha->hw;
+	int configured_count;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111a,
+	    "Entered %s.\n", __func__);
+
+	memset(mcp->mb, 0 , sizeof(mcp->mb));
+	mcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;
+	mcp->mb[1] = CONFIG_XLOGINS_MEM;
+	mcp->mb[2] = MSW(phys_addr);
+	mcp->mb[3] = LSW(phys_addr);
+	mcp->mb[6] = MSW(MSD(phys_addr));
+	mcp->mb[7] = LSW(MSD(phys_addr));
+	mcp->mb[8] = MSW(ha->exlogin_size);
+	mcp->mb[9] = LSW(ha->exlogin_size);
+	mcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_11|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		ql_dbg(ql_dbg_mbx, vha, 0x111b, "Failed=%x.\n", rval);
+	} else {
+		configured_count = mcp->mb[11];
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118c,
+		    "Done %s.\n", __func__);
+	}
+
+	return rval;
+}
+
 /*
  * qla2x00_get_fw_version
  *	Get firmware version.
@@ -633,6 +748,10 @@ qla2x00_get_fw_version(scsi_qla_host_t *vha)
 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x112f,
 		    "%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\n",
 		    __func__, mcp->mb[17], mcp->mb[16]);
+		if (ha->fw_attributes_h & 0x4)
+			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118d,
+			    "%s: Firmware supports Extended Login 0x%x\n",
+			    __func__, ha->fw_attributes_h);
 	}
 
 	if (IS_QLA27XX(ha)) {
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
