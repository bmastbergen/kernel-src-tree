PCI: hotplug: Use list_for_each_entry() to simplify code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [pci] hotplug: Use list_for_each_entry() to simplify code (Myron Stowe) [1462837]
Rebuild_FUZZ: 95.33%
commit-author Geliang Tang <geliangtang@163.com>
commit 2ac83cccabbc8d264c20ce11931d60e0e6ea3f53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2ac83ccc.failed

Use list_for_each_entry() instead of list_for_each() to simplify the code.

	Signed-off-by: Geliang Tang <geliangtang@163.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 2ac83cccabbc8d264c20ce11931d60e0e6ea3f53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/ibmphp_ebda.c
#	drivers/pci/hotplug/ibmphp_hpc.c
#	drivers/pci/hotplug/ibmphp_res.c
diff --cc drivers/pci/hotplug/ibmphp_ebda.c
index bb72b0ae9c6a,664b5d1efb8f..000000000000
--- a/drivers/pci/hotplug/ibmphp_ebda.c
+++ b/drivers/pci/hotplug/ibmphp_ebda.c
@@@ -1115,46 -1115,40 +1115,57 @@@ int ibmphp_get_bus_index(u8 num
  	return -ENODEV;
  }
  
 -void ibmphp_free_bus_info_queue (void)
 +void ibmphp_free_bus_info_queue(void)
  {
- 	struct bus_info *bus_info;
- 	struct list_head *list;
- 	struct list_head *next;
+ 	struct bus_info *bus_info, *next;
  
++<<<<<<< HEAD
 +	list_for_each_safe(list, next, &bus_info_head) {
 +		bus_info = list_entry(list, struct bus_info, bus_info_list);
 +		kfree(bus_info);
++=======
+ 	list_for_each_entry_safe(bus_info, next, &bus_info_head,
+ 				 bus_info_list) {
+ 		kfree (bus_info);
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  	}
  }
  
 -void ibmphp_free_ebda_hpc_queue (void)
 +void ibmphp_free_ebda_hpc_queue(void)
  {
- 	struct controller *controller = NULL;
- 	struct list_head *list;
- 	struct list_head *next;
+ 	struct controller *controller = NULL, *next;
  	int pci_flag = 0;
  
++<<<<<<< HEAD
 +	list_for_each_safe(list, next, &ebda_hpc_head) {
 +		controller = list_entry(list, struct controller, ebda_hpc_list);
++=======
+ 	list_for_each_entry_safe(controller, next, &ebda_hpc_head,
+ 				 ebda_hpc_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		if (controller->ctlr_type == 0)
 -			release_region (controller->u.isa_ctlr.io_start, (controller->u.isa_ctlr.io_end - controller->u.isa_ctlr.io_start + 1));
 +			release_region(controller->u.isa_ctlr.io_start, (controller->u.isa_ctlr.io_end - controller->u.isa_ctlr.io_start + 1));
  		else if ((controller->ctlr_type == 1) && (!pci_flag)) {
  			++pci_flag;
 -			pci_unregister_driver (&ibmphp_driver);
 +			pci_unregister_driver(&ibmphp_driver);
  		}
 -		free_ebda_hpc (controller);
 +		free_ebda_hpc(controller);
  	}
  }
  
 -void ibmphp_free_ebda_pci_rsrc_queue (void)
 +void ibmphp_free_ebda_pci_rsrc_queue(void)
  {
- 	struct ebda_pci_rsrc *resource;
- 	struct list_head *list;
- 	struct list_head *next;
+ 	struct ebda_pci_rsrc *resource, *next;
  
++<<<<<<< HEAD
 +	list_for_each_safe(list, next, &ibmphp_ebda_pci_rsrc_head) {
 +		resource = list_entry(list, struct ebda_pci_rsrc, ebda_pci_rsrc_list);
 +		kfree(resource);
++=======
+ 	list_for_each_entry_safe(resource, next, &ibmphp_ebda_pci_rsrc_head,
+ 				 ebda_pci_rsrc_list) {
+ 		kfree (resource);
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		resource = NULL;
  	}
  }
diff --cc drivers/pci/hotplug/ibmphp_hpc.c
index 035425adb24e,e2608585abd3..000000000000
--- a/drivers/pci/hotplug/ibmphp_hpc.c
+++ b/drivers/pci/hotplug/ibmphp_hpc.c
@@@ -628,14 -627,14 +627,19 @@@ int ibmphp_hpc_readslot(struct slot *ps
  
  			// Not used
  		case READ_ALLSLOT:
++<<<<<<< HEAD
 +			list_for_each(pslotlist, &ibmphp_slot_head) {
 +				pslot = list_entry(pslotlist, struct slot, ibm_slot_list);
++=======
+ 			list_for_each_entry(pslot, &ibmphp_slot_head,
+ 					    ibm_slot_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  				index = pslot->ctlr_index;
 -				rc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr,
 +				rc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT, ctlr_ptr,
  								wpg_bbar, &status);
  				if (!rc) {
 -					pslot->status = ctrl_read (ctlr_ptr, wpg_bbar, index);
 -					rc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT,
 +					pslot->status = ctrl_read(ctlr_ptr, wpg_bbar, index);
 +					rc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT,
  									ctlr_ptr, wpg_bbar, &status);
  					if (!rc)
  						pslot->ext_status =
@@@ -838,14 -836,14 +841,21 @@@ static int poll_hpc(void *data
  		case POLL_LATCH_REGISTER:
  			oldlatchlow = curlatchlow;
  			ctrl_count = 0x00;
++<<<<<<< HEAD
 +			list_for_each(pslotlist, &ibmphp_slot_head) {
 +				if (ctrl_count >= ibmphp_get_total_controllers())
 +					break;
 +				pslot = list_entry(pslotlist, struct slot, ibm_slot_list);
++=======
+ 			list_for_each_entry(pslot, &ibmphp_slot_head,
+ 					    ibm_slot_list) {
+ 				if (ctrl_count >= ibmphp_get_total_controllers())
+ 					break;
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  				if (pslot->ctrl->ctlr_relative_id == ctrl_count) {
  					ctrl_count++;
 -					if (READ_SLOT_LATCH (pslot->ctrl)) {
 -						rc = ibmphp_hpc_readslot (pslot,
 +					if (READ_SLOT_LATCH(pslot->ctrl)) {
 +						rc = ibmphp_hpc_readslot(pslot,
  									  READ_SLOTLATCHLOWREG,
  									  &curlatchlow);
  						if (oldlatchlow != curlatchlow)
@@@ -859,25 -857,25 +869,37 @@@
  			poll_state = POLL_SLEEP;
  			break;
  		case POLL_SLOTS:
++<<<<<<< HEAD
 +			list_for_each(pslotlist, &ibmphp_slot_head) {
 +				pslot = list_entry(pslotlist, struct slot, ibm_slot_list);
++=======
+ 			list_for_each_entry(pslot, &ibmphp_slot_head,
+ 					    ibm_slot_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  				// make a copy of the old status
 -				memcpy ((void *) &myslot, (void *) pslot,
 -					sizeof (struct slot));
 -				rc = ibmphp_hpc_readslot (pslot, READ_ALLSTAT, NULL);
 +				memcpy((void *) &myslot, (void *) pslot,
 +					sizeof(struct slot));
 +				rc = ibmphp_hpc_readslot(pslot, READ_ALLSTAT, NULL);
  				if ((myslot.status != pslot->status)
  				    || (myslot.ext_status != pslot->ext_status))
 -					process_changeinstatus (pslot, &myslot);
 +					process_changeinstatus(pslot, &myslot);
  			}
  			ctrl_count = 0x00;
++<<<<<<< HEAD
 +			list_for_each(pslotlist, &ibmphp_slot_head) {
 +				if (ctrl_count >= ibmphp_get_total_controllers())
 +					break;
 +				pslot = list_entry(pslotlist, struct slot, ibm_slot_list);
++=======
+ 			list_for_each_entry(pslot, &ibmphp_slot_head,
+ 					    ibm_slot_list) {
+ 				if (ctrl_count >= ibmphp_get_total_controllers())
+ 					break;
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  				if (pslot->ctrl->ctlr_relative_id == ctrl_count) {
  					ctrl_count++;
 -					if (READ_SLOT_LATCH (pslot->ctrl))
 -						rc = ibmphp_hpc_readslot (pslot,
 +					if (READ_SLOT_LATCH(pslot->ctrl))
 +						rc = ibmphp_hpc_readslot(pslot,
  									  READ_SLOTLATCHLOWREG,
  									  &curlatchlow);
  				}
diff --cc drivers/pci/hotplug/ibmphp_res.c
index 56fd48fe1c31,b5f2851e8cbe..000000000000
--- a/drivers/pci/hotplug/ibmphp_res.c
+++ b/drivers/pci/hotplug/ibmphp_res.c
@@@ -208,13 -207,12 +207,17 @@@ int __init ibmphp_rsrc_init(void
  	struct resource_node *new_mem = NULL;
  	struct resource_node *new_pfmem = NULL;
  	int rc;
- 	struct list_head *tmp_ebda;
  
++<<<<<<< HEAD
 +	list_for_each(tmp_ebda, &ibmphp_ebda_pci_rsrc_head) {
 +		curr = list_entry(tmp_ebda, struct ebda_pci_rsrc, ebda_pci_rsrc_list);
++=======
+ 	list_for_each_entry(curr, &ibmphp_ebda_pci_rsrc_head,
+ 			    ebda_pci_rsrc_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		if (!(curr->rsrc_type & PCIDEVMASK)) {
  			/* EBDA still lists non PCI devices, so ignore... */
 -			debug ("this is not a PCI DEVICE in rsrc_init, please take care\n");
 +			debug("this is not a PCI DEVICE in rsrc_init, please take care\n");
  			// continue;
  		}
  
@@@ -369,10 -367,9 +372,14 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	list_for_each(tmp, &gbuses) {
 +		bus_cur = list_entry(tmp, struct bus_node, bus_list);
++=======
+ 	list_for_each_entry(bus_cur, &gbuses, bus_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		/* This is to get info about PPB resources, since EBDA doesn't put this info into the primary bus info */
 -		rc = update_bridge_ranges (&bus_cur);
 +		rc = update_bridge_ranges(&bus_cur);
  		if (rc)
  			return rc;
  	}
@@@ -1569,9 -1566,9 +1576,9 @@@ int ibmphp_find_resource(struct bus_nod
   * Parameters: none
   * Returns: none
   ***********************************************************************/
 -void ibmphp_free_resources (void)
 +void ibmphp_free_resources(void)
  {
- 	struct bus_node *bus_cur = NULL;
+ 	struct bus_node *bus_cur = NULL, *next;
  	struct bus_node *bus_tmp;
  	struct range_node *range_cur;
  	struct range_node *range_tmp;
@@@ -1580,10 -1577,7 +1587,12 @@@
  	int i = 0;
  	flags = 1;
  
++<<<<<<< HEAD
 +	list_for_each_safe(tmp, next, &gbuses) {
 +		bus_cur = list_entry(tmp, struct bus_node, bus_list);
++=======
+ 	list_for_each_entry_safe(bus_cur, next, &gbuses, bus_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		if (bus_cur->noIORanges) {
  			range_cur = bus_cur->rangeIO;
  			for (i = 0; i < bus_cur->noIORanges; i++) {
@@@ -1691,10 -1685,8 +1700,13 @@@ static int __init once_over(void
  	struct resource_node *pfmem_prev;
  	struct resource_node *mem;
  	struct bus_node *bus_cur;
- 	struct list_head *tmp;
  
++<<<<<<< HEAD
 +	list_for_each(tmp, &gbuses) {
 +		bus_cur = list_entry(tmp, struct bus_node, bus_list);
++=======
+ 	list_for_each_entry(bus_cur, &gbuses, bus_list) {
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		if ((!bus_cur->rangePFMem) && (bus_cur->firstPFMem)) {
  			for (pfmem_cur = bus_cur->firstPFMem, pfmem_prev = NULL; pfmem_cur; pfmem_prev = pfmem_cur, pfmem_cur = pfmem_cur->next) {
  				pfmem_cur->fromMem = 1;
@@@ -1759,22 -1751,18 +1771,26 @@@ int ibmphp_add_pfmem_from_mem(struct re
   * Parameters: bus_number
   * Returns: Bus pointer or NULL
   */
 -struct bus_node *ibmphp_find_res_bus (u8 bus_number)
 +struct bus_node *ibmphp_find_res_bus(u8 bus_number)
  {
 -	return find_bus_wprev (bus_number, NULL, 0);
 +	return find_bus_wprev(bus_number, NULL, 0);
  }
  
 -static struct bus_node *find_bus_wprev (u8 bus_number, struct bus_node **prev, u8 flag)
 +static struct bus_node *find_bus_wprev(u8 bus_number, struct bus_node **prev, u8 flag)
  {
  	struct bus_node *bus_cur;
- 	struct list_head *tmp;
- 	struct list_head *tmp_prev;
  
++<<<<<<< HEAD
 +	list_for_each(tmp, &gbuses) {
 +		tmp_prev = tmp->prev;
 +		bus_cur = list_entry(tmp, struct bus_node, bus_list);
 +		if (flag)
 +			*prev = list_entry(tmp_prev, struct bus_node, bus_list);
++=======
+ 	list_for_each_entry(bus_cur, &gbuses, bus_list) {
+ 		if (flag)
+ 			*prev = list_prev_entry(bus_cur, bus_list);
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		if (bus_cur->busno == bus_number)
  			return bus_cur;
  	}
@@@ -1788,22 -1776,20 +1804,30 @@@ void ibmphp_print_test(void
  	struct bus_node *bus_cur = NULL;
  	struct range_node *range;
  	struct resource_node *res;
- 	struct list_head *tmp;
  
 -	debug_pci ("*****************START**********************\n");
 +	debug_pci("*****************START**********************\n");
  
  	if ((!list_empty(&gbuses)) && flags) {
 -		err ("The GBUSES is not NULL?!?!?!?!?\n");
 +		err("The GBUSES is not NULL?!?!?!?!?\n");
  		return;
  	}
  
++<<<<<<< HEAD
 +	list_for_each(tmp, &gbuses) {
 +		bus_cur = list_entry(tmp, struct bus_node, bus_list);
 +		debug_pci("This is bus # %d.  There are\n", bus_cur->busno);
 +		debug_pci("IORanges = %d\t", bus_cur->noIORanges);
 +		debug_pci("MemRanges = %d\t", bus_cur->noMemRanges);
 +		debug_pci("PFMemRanges = %d\n", bus_cur->noPFMemRanges);
 +		debug_pci("The IO Ranges are as follows:\n");
++=======
+ 	list_for_each_entry(bus_cur, &gbuses, bus_list) {
+ 		debug_pci ("This is bus # %d.  There are\n", bus_cur->busno);
+ 		debug_pci ("IORanges = %d\t", bus_cur->noIORanges);
+ 		debug_pci ("MemRanges = %d\t", bus_cur->noMemRanges);
+ 		debug_pci ("PFMemRanges = %d\n", bus_cur->noPFMemRanges);
+ 		debug_pci ("The IO Ranges are as follows:\n");
++>>>>>>> 2ac83cccabbc (PCI: hotplug: Use list_for_each_entry() to simplify code)
  		if (bus_cur->rangeIO) {
  			range = bus_cur->rangeIO;
  			for (i = 0; i < bus_cur->noIORanges; i++) {
diff --git a/drivers/pci/hotplug/ibmphp_core.c b/drivers/pci/hotplug/ibmphp_core.c
index 3f04cc1d31e3..9b9b33977f08 100644
--- a/drivers/pci/hotplug/ibmphp_core.c
+++ b/drivers/pci/hotplug/ibmphp_core.c
@@ -115,11 +115,9 @@ static inline int slot_update(struct slot **sl)
 static int __init get_max_slots(void)
 {
 	struct slot *slot_cur;
-	struct list_head *tmp;
 	u8 slot_count = 0;
 
-	list_for_each(tmp, &ibmphp_slot_head) {
-		slot_cur = list_entry(tmp, struct slot, ibm_slot_list);
+	list_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {
 		/* sometimes the hot-pluggable slots start with 4 (not always from 1) */
 		slot_count = max(slot_count, slot_cur->number);
 	}
@@ -503,13 +501,10 @@ static int get_bus_name(struct hotplug_slot *hotplug_slot, char *value)
 static int __init init_ops(void)
 {
 	struct slot *slot_cur;
-	struct list_head *tmp;
 	int retval;
 	int rc;
 
-	list_for_each(tmp, &ibmphp_slot_head) {
-		slot_cur = list_entry(tmp, struct slot, ibm_slot_list);
-
+	list_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {
 		if (!slot_cur)
 			return -ENODEV;
 
@@ -671,9 +666,7 @@ static struct pci_func *ibm_slot_find(u8 busno, u8 device, u8 function)
 {
 	struct pci_func *func_cur;
 	struct slot *slot_cur;
-	struct list_head *tmp;
-	list_for_each(tmp, &ibmphp_slot_head) {
-		slot_cur = list_entry(tmp, struct slot, ibm_slot_list);
+	list_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {
 		if (slot_cur->func) {
 			func_cur = slot_cur->func;
 			while (func_cur) {
@@ -695,14 +688,12 @@ static struct pci_func *ibm_slot_find(u8 busno, u8 device, u8 function)
  *************************************************************/
 static void free_slots(void)
 {
-	struct slot *slot_cur;
-	struct list_head *tmp;
-	struct list_head *next;
+	struct slot *slot_cur, *next;
 
 	debug("%s -- enter\n", __func__);
 
-	list_for_each_safe(tmp, next, &ibmphp_slot_head) {
-		slot_cur = list_entry(tmp, struct slot, ibm_slot_list);
+	list_for_each_entry_safe(slot_cur, next, &ibmphp_slot_head,
+				 ibm_slot_list) {
 		pci_hp_deregister(slot_cur->hotplug_slot);
 	}
 	debug("%s -- exit\n", __func__);
* Unmerged path drivers/pci/hotplug/ibmphp_ebda.c
* Unmerged path drivers/pci/hotplug/ibmphp_hpc.c
* Unmerged path drivers/pci/hotplug/ibmphp_res.c
diff --git a/drivers/pci/hotplug/pci_hotplug_core.c b/drivers/pci/hotplug/pci_hotplug_core.c
index d379d49f733d..9acd1997c6fe 100644
--- a/drivers/pci/hotplug/pci_hotplug_core.c
+++ b/drivers/pci/hotplug/pci_hotplug_core.c
@@ -396,10 +396,8 @@ static void fs_remove_slot(struct pci_slot *pci_slot)
 static struct hotplug_slot *get_slot_from_name(const char *name)
 {
 	struct hotplug_slot *slot;
-	struct list_head *tmp;
 
-	list_for_each(tmp, &pci_hotplug_slot_list) {
-		slot = list_entry(tmp, struct hotplug_slot, slot_list);
+	list_for_each_entry(slot, &pci_hotplug_slot_list, slot_list) {
 		if (strcmp(hotplug_slot_name(slot), name) == 0)
 			return slot;
 	}
diff --git a/drivers/pci/hotplug/pcihp_skeleton.c b/drivers/pci/hotplug/pcihp_skeleton.c
index cade1411e23c..172ed89200cd 100644
--- a/drivers/pci/hotplug/pcihp_skeleton.c
+++ b/drivers/pci/hotplug/pcihp_skeleton.c
@@ -321,17 +321,14 @@ error:
 
 static void __exit cleanup_slots(void)
 {
-	struct list_head *tmp;
-	struct list_head *next;
-	struct slot *slot;
+	struct slot *slot, *next;
 
 	/*
 	 * Unregister all of our slots with the pci_hotplug subsystem.
 	 * Memory will be freed in release_slot() callback after slot's
 	 * lifespan is finished.
 	 */
-	list_for_each_safe(tmp, next, &slot_list) {
-		slot = list_entry(tmp, struct slot, slot_list);
+	list_for_each_entry_safe(slot, next, &slot_list, slot_list) {
 		list_del(&slot->slot_list);
 		pci_hp_deregister(slot->hotplug_slot);
 	}
diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c
index e12bafdc42e0..b46b57d870fc 100644
--- a/drivers/pci/hotplug/rpadlpar_core.c
+++ b/drivers/pci/hotplug/rpadlpar_core.c
@@ -114,11 +114,10 @@ static struct device_node *find_dlpar_node(char *drc_name, int *node_type)
  */
 static struct slot *find_php_slot(struct device_node *dn)
 {
-	struct list_head *tmp, *n;
-	struct slot *slot;
+	struct slot *slot, *next;
 
-	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
-		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+	list_for_each_entry_safe(slot, next, &rpaphp_slot_head,
+				 rpaphp_slot_list) {
 		if (slot->dn == dn)
 			return slot;
 	}
diff --git a/drivers/pci/hotplug/rpaphp_core.c b/drivers/pci/hotplug/rpaphp_core.c
index 58448e664637..bc4a9f115f21 100644
--- a/drivers/pci/hotplug/rpaphp_core.c
+++ b/drivers/pci/hotplug/rpaphp_core.c
@@ -356,8 +356,7 @@ EXPORT_SYMBOL_GPL(rpaphp_add_slot);
 
 static void __exit cleanup_slots(void)
 {
-	struct list_head *tmp, *n;
-	struct slot *slot;
+	struct slot *slot, *next;
 
 	/*
 	 * Unregister all of our slots with the pci_hotplug subsystem,
@@ -365,8 +364,8 @@ static void __exit cleanup_slots(void)
 	 * memory will be freed in release_slot callback.
 	 */
 
-	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
-		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+	list_for_each_entry_safe(slot, next, &rpaphp_slot_head,
+				 rpaphp_slot_list) {
 		list_del(&slot->rpaphp_slot_list);
 		pci_hp_deregister(slot->hotplug_slot);
 	}
diff --git a/drivers/pci/hotplug/s390_pci_hpc.c b/drivers/pci/hotplug/s390_pci_hpc.c
index f73fec9ba805..1c0343bae304 100644
--- a/drivers/pci/hotplug/s390_pci_hpc.c
+++ b/drivers/pci/hotplug/s390_pci_hpc.c
@@ -205,11 +205,10 @@ error:
 
 void zpci_exit_slot(struct zpci_dev *zdev)
 {
-	struct list_head *tmp, *n;
-	struct slot *slot;
+	struct slot *slot, *next;
 
-	list_for_each_safe(tmp, n, &s390_hotplug_slot_list) {
-		slot = list_entry(tmp, struct slot, slot_list);
+	list_for_each_entry_safe(slot, next, &s390_hotplug_slot_list,
+				 slot_list) {
 		if (slot->zdev != zdev)
 			continue;
 		list_del(&slot->slot_list);
diff --git a/drivers/pci/hotplug/shpchp_core.c b/drivers/pci/hotplug/shpchp_core.c
index c3fbf3ed351e..3454dc7385f1 100644
--- a/drivers/pci/hotplug/shpchp_core.c
+++ b/drivers/pci/hotplug/shpchp_core.c
@@ -178,12 +178,9 @@ error:
 
 void cleanup_slots(struct controller *ctrl)
 {
-	struct list_head *tmp;
-	struct list_head *next;
-	struct slot *slot;
+	struct slot *slot, *next;
 
-	list_for_each_safe(tmp, next, &ctrl->slot_list) {
-		slot = list_entry(tmp, struct slot, slot_list);
+	list_for_each_entry_safe(slot, next, &ctrl->slot_list, slot_list) {
 		list_del(&slot->slot_list);
 		cancel_delayed_work(&slot->work);
 		destroy_workqueue(slot->wq);
