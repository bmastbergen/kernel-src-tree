macsec: double accounting of dropped rx/tx packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Girish Moodalbail <girish.moodalbail@oracle.com>
commit 863483c970e968efd6a119a2118f57977d04cefe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/863483c9.failed

The macsec implementation shouldn't account for rx/tx packets that are
dropped in the netdev framework. The netdev framework itself accounts
for such packets by atomically updating struct net_device`rx_dropped and
struct net_device`tx_dropped fields. Later on when the stats for macsec
link is retrieved, the packets dropped in netdev framework will be
included in dev_get_stats() after calling macsec.c`macsec_get_stats64()

	Signed-off-by: Girish Moodalbail <girish.moodalbail@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 863483c970e968efd6a119a2118f57977d04cefe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macsec.c
diff --cc drivers/net/macsec.c
index ef3e576d89a1,91642fd87cd1..000000000000
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@@ -910,11 -902,8 +908,13 @@@ static void macsec_decrypt_done(struct 
  	macsec_reset_skb(skb, macsec->secy.netdev);
  
  	len = skb->len;
++<<<<<<< HEAD
 +	ret = netif_rx(skb);
 +	if (ret == NET_RX_SUCCESS)
++=======
+ 	if (gro_cells_receive(&macsec->gro_cells, skb) == NET_RX_SUCCESS)
++>>>>>>> 863483c970e9 (macsec: double accounting of dropped rx/tx packets)
  		count_rx(dev, len);
- 	else
- 		macsec->secy.netdev->stats.rx_dropped++;
  
  	rcu_read_unlock_bh();
  
* Unmerged path drivers/net/macsec.c
