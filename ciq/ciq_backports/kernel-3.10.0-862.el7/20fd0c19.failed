net/mlx5e: RX handlers per netdev profile

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: RX handlers per netdev profile (Don Dutile) [1385325 1499362]
Rebuild_FUZZ: 94.87%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 20fd0c193ff6384717a6d500aa0e737a81c6a1fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/20fd0c19.failed

In order to have different RX handler per profile, fix and refactor the
current code to take the rx handler directly from the netdevice profile
rather than computing it on runtime as it was done with the switchdev
mode representor rx handler.

This will also remove the current wrong assumption in mlx5e_alloc_rq
code that mlx5e_priv->ppriv is of the type vport_rep.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 20fd0c193ff6384717a6d500aa0e737a81c6a1fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index f6e3d4bf0928,0881325fba04..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -717,9 -766,28 +717,32 @@@ struct mlx5e_priv 
  	void                      *ppriv;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_profile {
+ 	void	(*init)(struct mlx5_core_dev *mdev,
+ 			struct net_device *netdev,
+ 			const struct mlx5e_profile *profile, void *ppriv);
+ 	void	(*cleanup)(struct mlx5e_priv *priv);
+ 	int	(*init_rx)(struct mlx5e_priv *priv);
+ 	void	(*cleanup_rx)(struct mlx5e_priv *priv);
+ 	int	(*init_tx)(struct mlx5e_priv *priv);
+ 	void	(*cleanup_tx)(struct mlx5e_priv *priv);
+ 	void	(*enable)(struct mlx5e_priv *priv);
+ 	void	(*disable)(struct mlx5e_priv *priv);
+ 	void	(*update_stats)(struct mlx5e_priv *priv);
+ 	int	(*max_nch)(struct mlx5_core_dev *mdev);
+ 	struct {
+ 		mlx5e_fp_handle_rx_cqe handle_rx_cqe;
+ 		mlx5e_fp_handle_rx_cqe handle_rx_cqe_mpwqe;
+ 	} rx_handlers;
+ 	int	max_tc;
+ };
+ 
++>>>>>>> 20fd0c193ff6 (net/mlx5e: RX handlers per netdev profile)
  void mlx5e_build_ptys2ethtool_map(void);
  
 +void mlx5e_send_nop(struct mlx5e_sq *sq, bool notify_hw);
  u16 mlx5e_select_queue(struct net_device *dev, struct sk_buff *skb,
  		       void *accel_priv, select_queue_fallback_t fallback);
  netdev_tx_t mlx5e_xmit(struct sk_buff *skb, struct net_device *dev);
@@@ -929,5 -1036,16 +952,20 @@@ int mlx5e_get_offload_stats(int attr_id
  bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
  
  bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
++<<<<<<< HEAD
 +bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv);
++=======
+ 
+ /* mlx5e generic netdev management API */
+ struct net_device*
+ mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
+ 		    void *ppriv);
+ int mlx5e_attach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_detach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_destroy_netdev(struct mlx5e_priv *priv);
+ void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
+ 			    struct mlx5e_params *params,
+ 			    u16 max_channels);
+ 
++>>>>>>> 20fd0c193ff6 (net/mlx5e: RX handlers per netdev profile)
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,6a164aff404c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -557,27 -560,44 +557,41 @@@ static int mlx5e_create_rq(struct mlx5e
  
  	wq_sz = mlx5_wq_ll_get_size(&rq->wq);
  
 -	rq->wq_type = params->rq_wq_type;
 +	rq->wq_type = priv->params.rq_wq_type;
  	rq->pdev    = c->pdev;
  	rq->netdev  = c->netdev;
 -	rq->tstamp  = c->tstamp;
 +	rq->tstamp  = &priv->tstamp;
  	rq->channel = c;
  	rq->ix      = c->ix;
 -	rq->mdev    = mdev;
 -
 -	rq->xdp_prog = params->xdp_prog ? bpf_prog_inc(params->xdp_prog) : NULL;
 -	if (IS_ERR(rq->xdp_prog)) {
 -		err = PTR_ERR(rq->xdp_prog);
 -		rq->xdp_prog = NULL;
 -		goto err_rq_wq_destroy;
 -	}
 -
 -	if (rq->xdp_prog) {
 -		rq->buff.map_dir = DMA_BIDIRECTIONAL;
 -		rq->rx_headroom = XDP_PACKET_HEADROOM;
 -	} else {
 -		rq->buff.map_dir = DMA_FROM_DEVICE;
 -		rq->rx_headroom = MLX5_RX_HEADROOM;
 -	}
 +	rq->priv    = c->priv;
  
 -	switch (rq->wq_type) {
 +	switch (priv->params.rq_wq_type) {
  	case MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:
++<<<<<<< HEAD
 +		if (mlx5e_is_vf_vport_rep(priv)) {
 +			err = -EINVAL;
 +			goto err_rq_wq_destroy;
 +		}
++=======
++>>>>>>> 20fd0c193ff6 (net/mlx5e: RX handlers per netdev profile)
  
- 		rq->handle_rx_cqe = mlx5e_handle_rx_cqe_mpwrq;
  		rq->alloc_wqe = mlx5e_alloc_rx_mpwqe;
  		rq->dealloc_wqe = mlx5e_dealloc_rx_mpwqe;
  
++<<<<<<< HEAD
 +		rq->mpwqe_stride_sz = BIT(priv->params.mpwqe_log_stride_sz);
 +		rq->mpwqe_num_strides = BIT(priv->params.mpwqe_log_num_strides);
++=======
+ 		rq->handle_rx_cqe = c->priv->profile->rx_handlers.handle_rx_cqe_mpwqe;
+ 		if (!rq->handle_rx_cqe) {
+ 			err = -EINVAL;
+ 			netdev_err(c->netdev, "RX handler of MPWQE RQ is not set, err %d\n", err);
+ 			goto err_rq_wq_destroy;
+ 		}
+ 
+ 		rq->mpwqe_stride_sz = BIT(params->mpwqe_log_stride_sz);
+ 		rq->mpwqe_num_strides = BIT(params->mpwqe_log_num_strides);
++>>>>>>> 20fd0c193ff6 (net/mlx5e: RX handlers per netdev profile)
  
  		rq->buff.wqe_sz = rq->mpwqe_stride_sz * rq->mpwqe_num_strides;
  		byte_count = rq->buff.wqe_sz;
@@@ -598,18 -618,20 +612,35 @@@
  			err = -ENOMEM;
  			goto err_rq_wq_destroy;
  		}
++<<<<<<< HEAD
 +
 +		if (mlx5e_is_vf_vport_rep(priv))
 +			rq->handle_rx_cqe = mlx5e_handle_rx_cqe_rep;
 +		else
 +			rq->handle_rx_cqe = mlx5e_handle_rx_cqe;
 +
 +		rq->alloc_wqe = mlx5e_alloc_rx_wqe;
 +		rq->dealloc_wqe = mlx5e_dealloc_rx_wqe;
 +
 +		rq->buff.wqe_sz = (priv->params.lro_en) ?
 +				priv->params.lro_wqe_sz :
 +				MLX5E_SW2HW_MTU(priv->netdev->mtu);
++=======
+ 		rq->alloc_wqe = mlx5e_alloc_rx_wqe;
+ 		rq->dealloc_wqe = mlx5e_dealloc_rx_wqe;
+ 
+ 		rq->handle_rx_cqe = c->priv->profile->rx_handlers.handle_rx_cqe;
+ 		if (!rq->handle_rx_cqe) {
+ 			kfree(rq->dma_info);
+ 			err = -EINVAL;
+ 			netdev_err(c->netdev, "RX handler of RQ is not set, err %d\n", err);
+ 			goto err_rq_wq_destroy;
+ 		}
+ 
+ 		rq->buff.wqe_sz = params->lro_en  ?
+ 				params->lro_wqe_sz :
+ 				MLX5E_SW2HW_MTU(c->netdev->mtu);
++>>>>>>> 20fd0c193ff6 (net/mlx5e: RX handlers per netdev profile)
  		byte_count = rq->buff.wqe_sz;
  
  		/* calc the required page order */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d..a0498071e052 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -323,7 +323,7 @@ bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv)
 	return false;
 }
 
-bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv)
+static bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv)
 {
 	struct mlx5_eswitch_rep *rep = (struct mlx5_eswitch_rep *)priv->ppriv;
 
@@ -550,6 +550,8 @@ static struct mlx5e_profile mlx5e_rep_profile = {
 	.cleanup_tx		= mlx5e_cleanup_nic_tx,
 	.update_stats           = mlx5e_rep_update_stats,
 	.max_nch		= mlx5e_get_rep_max_num_channels,
+	.rx_handlers.handle_rx_cqe       = mlx5e_handle_rx_cqe_rep,
+	.rx_handlers.handle_rx_cqe_mpwqe = NULL /* Not supported */,
 	.max_tc			= 1,
 };
 
