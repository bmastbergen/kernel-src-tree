mm/debug_pagealloc: ask users for default setting of debug_pagealloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] debug_pagealloc: ask users for default setting of debug_pagealloc (Waiman Long) [1481847]
Rebuild_FUZZ: 97.74%
commit-author Christian Borntraeger <borntraeger@de.ibm.com>
commit ea6eabb05b26bd3d6f60b29b77a03bc61479fc0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ea6eabb0.failed

Since commit 031bc5743f158 ("mm/debug-pagealloc: make debug-pagealloc
boottime configurable") CONFIG_DEBUG_PAGEALLOC is by default not adding
any page debugging.

This resulted in several unnoticed bugs, e.g.

    https://lkml.kernel.org/g/<569F5E29.3090107@de.ibm.com>
or
    https://lkml.kernel.org/g/<56A20F30.4050705@de.ibm.com>

as this behaviour change was not even documented in Kconfig.

Let's provide a new Kconfig symbol that allows to change the default
back to enabled, e.g.  for debug kernels.  This also makes the change
obvious to kernel packagers.

Let's also change the Kconfig description for CONFIG_DEBUG_PAGEALLOC, to
indicate that there are two stages of overhead.

	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ea6eabb05b26bd3d6f60b29b77a03bc61479fc0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/Kconfig.debug
#	mm/page_alloc.c
diff --cc mm/Kconfig.debug
index 4b2443254de2,a0c136af9c91..000000000000
--- a/mm/Kconfig.debug
+++ b/mm/Kconfig.debug
@@@ -3,12 -12,12 +3,12 @@@ config DEBUG_PAGEALLO
  	depends on DEBUG_KERNEL
  	depends on !HIBERNATION || ARCH_SUPPORTS_DEBUG_PAGEALLOC && !PPC && !SPARC
  	depends on !KMEMCHECK
 -	select PAGE_EXTENSION
  	select PAGE_POISONING if !ARCH_SUPPORTS_DEBUG_PAGEALLOC
 +	select PAGE_GUARD if ARCH_SUPPORTS_DEBUG_PAGEALLOC
  	---help---
  	  Unmap pages from the kernel linear mapping after free_pages().
- 	  This results in a large slowdown, but helps to find certain types
- 	  of memory corruption.
+ 	  Depending on runtime enablement, this results in a small or large
+ 	  slowdown, but helps to find certain types of memory corruption.
  
  	  For architectures which don't enable ARCH_SUPPORTS_DEBUG_PAGEALLOC,
  	  fill the pages with poison patterns after free_pages() and verify
@@@ -17,8 -26,19 +17,24 @@@
  	  that would result in incorrect warnings of memory corruption after
  	  a resume because free pages are not saved to the suspend image.
  
++<<<<<<< HEAD
 +config WANT_PAGE_DEBUG_FLAGS
 +	bool
++=======
+ 	  By default this option will have a small overhead, e.g. by not
+ 	  allowing the kernel mapping to be backed by large pages on some
+ 	  architectures. Even bigger overhead comes when the debugging is
+ 	  enabled by DEBUG_PAGEALLOC_ENABLE_DEFAULT or the debug_pagealloc
+ 	  command line parameter.
+ 
+ config DEBUG_PAGEALLOC_ENABLE_DEFAULT
+ 	bool "Enable debug page memory allocations by default?"
+ 	default n
+ 	depends on DEBUG_PAGEALLOC
+ 	---help---
+ 	  Enable debug page memory allocations by default? This value
+ 	  can be overridden by debug_pagealloc=off|on.
++>>>>>>> ea6eabb05b26 (mm/debug_pagealloc: ask users for default setting of debug_pagealloc)
  
  config PAGE_POISONING
  	bool
diff --cc mm/page_alloc.c
index 1ea5aceae15f,36a0a792f4f8..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -528,6 -478,46 +528,49 @@@ static inline void prep_zero_page(struc
  
  #ifdef CONFIG_DEBUG_PAGEALLOC
  unsigned int _debug_guardpage_minorder;
++<<<<<<< HEAD
++=======
+ bool _debug_pagealloc_enabled __read_mostly
+ 			= IS_ENABLED(CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT);
+ bool _debug_guardpage_enabled __read_mostly;
+ 
+ static int __init early_debug_pagealloc(char *buf)
+ {
+ 	if (!buf)
+ 		return -EINVAL;
+ 
+ 	if (strcmp(buf, "on") == 0)
+ 		_debug_pagealloc_enabled = true;
+ 
+ 	if (strcmp(buf, "off") == 0)
+ 		_debug_pagealloc_enabled = false;
+ 
+ 	return 0;
+ }
+ early_param("debug_pagealloc", early_debug_pagealloc);
+ 
+ static bool need_debug_guardpage(void)
+ {
+ 	/* If we don't use debug_pagealloc, we don't need guard page */
+ 	if (!debug_pagealloc_enabled())
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static void init_debug_guardpage(void)
+ {
+ 	if (!debug_pagealloc_enabled())
+ 		return;
+ 
+ 	_debug_guardpage_enabled = true;
+ }
+ 
+ struct page_ext_operations debug_guardpage_ops = {
+ 	.need = need_debug_guardpage,
+ 	.init = init_debug_guardpage,
+ };
++>>>>>>> ea6eabb05b26 (mm/debug_pagealloc: ask users for default setting of debug_pagealloc)
  
  static int __init debug_guardpage_minorder_setup(char *buf)
  {
* Unmerged path mm/Kconfig.debug
* Unmerged path mm/page_alloc.c
