mlx5e_rep: push cls_flower setup_tc processing into a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit 8c818c27f37f4d847769a38b9d20c1b5ae21075d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8c818c27.failed

Let mlx5e_rep_setup_tc (former mlx5e_rep_ndo_setup_tc) be a splitter for
specific setup_tc types and push out cls_flower specific code into
a separate function.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8c818c27f37f4d847769a38b9d20c1b5ae21075d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d,e6cc642f6d8c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -281,32 -651,47 +281,60 @@@ static int mlx5e_rep_get_phys_port_name
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_rep_ndo_setup_tc(struct net_device *dev, u32 handle,
 +				  __be16 proto, struct tc_to_netdev *tc)
++=======
+ static int mlx5e_rep_setup_tc_cls_flower(struct net_device *dev,
+ 					 u32 handle, u32 chain_index,
+ 					 __be16 proto,
+ 					 struct tc_to_netdev *tc)
++>>>>>>> 8c818c27f37f (mlx5e_rep: push cls_flower setup_tc processing into a separate function)
  {
+ 	struct tc_cls_flower_offload *cls_flower = tc->cls_flower;
  	struct mlx5e_priv *priv = netdev_priv(dev);
  
- 	if (TC_H_MAJ(handle) != TC_H_MAJ(TC_H_INGRESS))
+ 	if (TC_H_MAJ(handle) != TC_H_MAJ(TC_H_INGRESS) ||
+ 	    chain_index)
  		return -EOPNOTSUPP;
  
- 	if (type == TC_SETUP_CLSFLOWER && tc->cls_flower->egress_dev) {
+ 	if (cls_flower->egress_dev) {
  		struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
- 		struct net_device *uplink_dev = mlx5_eswitch_get_uplink_netdev(esw);
  
++<<<<<<< HEAD
 +		return uplink_dev->netdev_ops->ndo_setup_tc(uplink_dev, handle,
 +							    proto, tc);
 +	}
 +
 +	switch (tc->type) {
++=======
+ 		dev = mlx5_eswitch_get_uplink_netdev(esw);
+ 		return dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_CLSFLOWER,
+ 						     handle, chain_index,
+ 						     proto, tc);
+ 	}
+ 
+ 	switch (cls_flower->command) {
+ 	case TC_CLSFLOWER_REPLACE:
+ 		return mlx5e_configure_flower(priv, proto, cls_flower);
+ 	case TC_CLSFLOWER_DESTROY:
+ 		return mlx5e_delete_flower(priv, cls_flower);
+ 	case TC_CLSFLOWER_STATS:
+ 		return mlx5e_stats_flower(priv, cls_flower);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int mlx5e_rep_setup_tc(struct net_device *dev, enum tc_setup_type type,
+ 			      u32 handle, u32 chain_index, __be16 proto,
+ 			      struct tc_to_netdev *tc)
+ {
+ 	switch (type) {
++>>>>>>> 8c818c27f37f (mlx5e_rep: push cls_flower setup_tc processing into a separate function)
  	case TC_SETUP_CLSFLOWER:
- 		switch (tc->cls_flower->command) {
- 		case TC_CLSFLOWER_REPLACE:
- 			return mlx5e_configure_flower(priv, proto, tc->cls_flower);
- 		case TC_CLSFLOWER_DESTROY:
- 			return mlx5e_delete_flower(priv, tc->cls_flower);
- 		case TC_CLSFLOWER_STATS:
- 			return mlx5e_stats_flower(priv, tc->cls_flower);
- 		}
+ 		return mlx5e_rep_setup_tc_cls_flower(dev, handle, chain_index,
+ 						     proto, tc);
  	default:
  		return -EOPNOTSUPP;
  	}
@@@ -392,21 -782,16 +420,26 @@@ static const struct net_device_ops mlx5
  	.ndo_open                = mlx5e_rep_open,
  	.ndo_stop                = mlx5e_rep_close,
  	.ndo_start_xmit          = mlx5e_xmit,
++<<<<<<< HEAD
 +	.extended.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 +	.ndo_setup_tc            = mlx5e_rep_ndo_setup_tc,
++=======
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
++>>>>>>> 8c818c27f37f (mlx5e_rep: push cls_flower setup_tc processing into a separate function)
  	.ndo_get_stats64         = mlx5e_rep_get_stats,
 -	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 -	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 +	.extended.ndo_udp_tunnel_add      = mlx5e_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del      = mlx5e_del_vxlan_port,
 +	.extended.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 +	.extended.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
  };
  
 -static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
 -				   struct mlx5e_params *params)
 +static void mlx5e_build_rep_netdev_priv(struct mlx5_core_dev *mdev,
 +					struct net_device *netdev,
 +					const struct mlx5e_profile *profile,
 +					void *ppriv)
  {
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
  	u8 cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
  					 MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
  					 MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
