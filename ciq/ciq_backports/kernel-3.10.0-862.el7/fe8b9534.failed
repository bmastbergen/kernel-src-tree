scsi_dh_alua: do not fail for unknown VPD identification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit fe8b9534a0a0356f8a76467e2c561194bdb53c84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fe8b9534.failed

Not every device will return a useable VPD identification, but still
might support ALUA. Rather than disable ALUA support we should be
allowing the device identification to be empty and attach individual
ALUA device handler to each devices.

[mkp: Fixed typo reported by Bart]

	Reported-by: Paul Mackerras <paulus@ozlabs.org>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Tested-by: Paul Mackerras <paulus@ozlabs.org>
	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit fe8b9534a0a0356f8a76467e2c561194bdb53c84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 2f054f24112a,b2244eb90776..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -165,6 -190,87 +165,90 @@@ static int submit_stpg(struct scsi_devi
  				      ALUA_FAILOVER_RETRIES, NULL, req_flags);
  }
  
++<<<<<<< HEAD
++=======
+ static struct alua_port_group *alua_find_get_pg(char *id_str, size_t id_size,
+ 						int group_id)
+ {
+ 	struct alua_port_group *pg;
+ 
+ 	if (!id_str || !id_size || !strlen(id_str))
+ 		return NULL;
+ 
+ 	list_for_each_entry(pg, &port_group_list, node) {
+ 		if (pg->group_id != group_id)
+ 			continue;
+ 		if (!pg->device_id_len || pg->device_id_len != id_size)
+ 			continue;
+ 		if (strncmp(pg->device_id_str, id_str, id_size))
+ 			continue;
+ 		if (!kref_get_unless_zero(&pg->kref))
+ 			continue;
+ 		return pg;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * alua_alloc_pg - Allocate a new port_group structure
+  * @sdev: scsi device
+  * @h: alua device_handler data
+  * @group_id: port group id
+  *
+  * Allocate a new port_group structure for a given
+  * device.
+  */
+ static struct alua_port_group *alua_alloc_pg(struct scsi_device *sdev,
+ 					     int group_id, int tpgs)
+ {
+ 	struct alua_port_group *pg, *tmp_pg;
+ 
+ 	pg = kzalloc(sizeof(struct alua_port_group), GFP_KERNEL);
+ 	if (!pg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pg->device_id_len = scsi_vpd_lun_id(sdev, pg->device_id_str,
+ 					    sizeof(pg->device_id_str));
+ 	if (pg->device_id_len <= 0) {
+ 		/*
+ 		 * TPGS supported but no device identification found.
+ 		 * Generate private device identification.
+ 		 */
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: No device descriptors found\n",
+ 			    ALUA_DH_NAME);
+ 		pg->device_id_str[0] = '\0';
+ 		pg->device_id_len = 0;
+ 	}
+ 	pg->group_id = group_id;
+ 	pg->tpgs = tpgs;
+ 	pg->state = SCSI_ACCESS_STATE_OPTIMAL;
+ 	if (optimize_stpg)
+ 		pg->flags |= ALUA_OPTIMIZE_STPG;
+ 	kref_init(&pg->kref);
+ 	INIT_DELAYED_WORK(&pg->rtpg_work, alua_rtpg_work);
+ 	INIT_LIST_HEAD(&pg->rtpg_list);
+ 	INIT_LIST_HEAD(&pg->node);
+ 	INIT_LIST_HEAD(&pg->dh_list);
+ 	spin_lock_init(&pg->lock);
+ 
+ 	spin_lock(&port_group_lock);
+ 	tmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,
+ 				  group_id);
+ 	if (tmp_pg) {
+ 		spin_unlock(&port_group_lock);
+ 		kfree(pg);
+ 		return tmp_pg;
+ 	}
+ 
+ 	list_add(&pg->node, &port_group_list);
+ 	spin_unlock(&port_group_lock);
+ 
+ 	return pg;
+ }
+ 
++>>>>>>> fe8b9534a0a0 (scsi_dh_alua: do not fail for unknown VPD identification)
  /*
   * alua_check_tpgs - Evaluate TPGS setting
   * @sdev: device to be checked
@@@ -240,32 -350,69 +324,50 @@@ static int alua_check_vpd(struct scsi_d
  			    ALUA_DH_NAME);
  		return SCSI_DH_DEV_UNSUPP;
  	}
 +	h->state = TPGS_STATE_OPTIMIZED;
 +	h->group_id = group_id;
  
++<<<<<<< HEAD
 +	sdev_printk(KERN_INFO, sdev,
 +		    "%s: port group %02x rel port %02x\n",
 +		    ALUA_DH_NAME, h->group_id, h->rel_port);
++=======
+ 	pg = alua_alloc_pg(sdev, group_id, tpgs);
+ 	if (IS_ERR(pg)) {
+ 		if (PTR_ERR(pg) == -ENOMEM)
+ 			return SCSI_DH_NOMEM;
+ 		return SCSI_DH_DEV_UNSUPP;
+ 	}
+ 	if (pg->device_id_len)
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: device %s port group %x rel port %x\n",
+ 			    ALUA_DH_NAME, pg->device_id_str,
+ 			    group_id, rel_port);
+ 	else
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: port group %x rel port %x\n",
+ 			    ALUA_DH_NAME, group_id, rel_port);
++>>>>>>> fe8b9534a0a0 (scsi_dh_alua: do not fail for unknown VPD identification)
  
 -	/* Check for existing port group references */
 -	spin_lock(&h->pg_lock);
 -	old_pg = h->pg;
 -	if (old_pg != pg) {
 -		/* port group has changed. Update to new port group */
 -		if (h->pg) {
 -			spin_lock_irqsave(&old_pg->lock, flags);
 -			list_del_rcu(&h->node);
 -			spin_unlock_irqrestore(&old_pg->lock, flags);
 -		}
 -		rcu_assign_pointer(h->pg, pg);
 -		pg_updated = true;
 -	}
 -
 -	spin_lock_irqsave(&pg->lock, flags);
 -	if (sdev->synchronous_alua)
 -		pg->flags |= ALUA_SYNC_STPG;
 -	if (pg_updated)
 -		list_add_rcu(&h->node, &pg->dh_list);
 -	spin_unlock_irqrestore(&pg->lock, flags);
 -
 -	alua_rtpg_queue(h->pg, sdev, NULL, true);
 -	spin_unlock(&h->pg_lock);
 -
 -	if (old_pg)
 -		kref_put(&old_pg->kref, release_port_group);
 -
 -	return SCSI_DH_OK;
 +	return 0;
  }
  
 -static char print_alua_state(unsigned char state)
 +static char print_alua_state(int state)
  {
  	switch (state) {
 -	case SCSI_ACCESS_STATE_OPTIMAL:
 +	case TPGS_STATE_OPTIMIZED:
  		return 'A';
 -	case SCSI_ACCESS_STATE_ACTIVE:
 +	case TPGS_STATE_NONOPTIMIZED:
  		return 'N';
 -	case SCSI_ACCESS_STATE_STANDBY:
 +	case TPGS_STATE_STANDBY:
  		return 'S';
 -	case SCSI_ACCESS_STATE_UNAVAILABLE:
 +	case TPGS_STATE_UNAVAILABLE:
  		return 'U';
 -	case SCSI_ACCESS_STATE_LBA:
 +	case TPGS_STATE_LBA_DEPENDENT:
  		return 'L';
 -	case SCSI_ACCESS_STATE_OFFLINE:
 +	case TPGS_STATE_OFFLINE:
  		return 'O';
 -	case SCSI_ACCESS_STATE_TRANSITIONING:
 +	case TPGS_STATE_TRANSITIONING:
  		return 'T';
  	default:
  		return 'X';
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
