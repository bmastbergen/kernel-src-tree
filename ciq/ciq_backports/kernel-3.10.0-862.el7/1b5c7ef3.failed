drm/nouveau/disp/gf119: add missing drive vfunc ptr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Rob Clark <robdclark@gmail.com>
commit 1b5c7ef3d0d0610bda9b63263f7c5b7178d11015
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1b5c7ef3.failed

Fixes broken dp on GF119:

  Call Trace:
   ? nvkm_dp_train_drive+0x183/0x2c0 [nouveau]
   nvkm_dp_acquire+0x4f3/0xcd0 [nouveau]
   nv50_disp_super_2_2+0x5d/0x470 [nouveau]
   ? nvkm_devinit_pll_set+0xf/0x20 [nouveau]
   gf119_disp_super+0x19c/0x2f0 [nouveau]
   process_one_work+0x193/0x3c0
   worker_thread+0x35/0x3b0
   kthread+0x125/0x140
   ? process_one_work+0x3c0/0x3c0
   ? kthread_park+0x60/0x60
   ret_from_fork+0x25/0x30
  Code:  Bad RIP value.
  RIP:           (null) RSP: ffffb1e243e4bc38
  CR2: 0000000000000000

Fixes: af85389c614a drm/nouveau/disp: shuffle functions around
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=103421
	Signed-off-by: Rob Clark <robdclark@gmail.com>
	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 1b5c7ef3d0d0610bda9b63263f7c5b7178d11015)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
index 6ffdaa65aa77,700fc754f28a..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
@@@ -66,61 -116,74 +66,87 @@@ gf119_sor_dp_lnk_ctl(struct nvkm_output
  	return 0;
  }
  
 -void
 -gf119_sor_clock(struct nvkm_ior *sor)
 +int
 +gf119_sor_dp_drv_ctl(struct nvkm_output_dp *outp,
 +		     int ln, int vs, int pe, int pc)
  {
 -	struct nvkm_device *device = sor->disp->engine.subdev.device;
 -	const int  div = sor->asy.link == 3;
 -	const u32 soff = nv50_ior_base(sor);
 -	if (sor->asy.proto == TMDS) {
 -		/* NFI why, but this sets DP_LINK_BW_2_7 when using TMDS. */
 -		nvkm_mask(device, 0x612300 + soff, 0x007c0000, 0x0a << 18);
 -	}
 -	nvkm_mask(device, 0x612300 + soff, 0x00000707, (div << 8) | div);
 +	struct nvkm_device *device = outp->base.disp->engine.subdev.device;
 +	struct nvkm_bios *bios = device->bios;
 +	const u32 shift = g94_sor_dp_lane_map(device, ln);
 +	const u32 loff = gf119_sor_loff(outp);
 +	u32 addr, data[4];
 +	u8  ver, hdr, cnt, len;
 +	struct nvbios_dpout info;
 +	struct nvbios_dpcfg ocfg;
 +
 +	addr = nvbios_dpout_match(bios, outp->base.info.hasht,
 +					outp->base.info.hashm,
 +				  &ver, &hdr, &cnt, &len, &info);
 +	if (!addr)
 +		return -ENODEV;
 +
 +	addr = nvbios_dpcfg_match(bios, addr, pc, vs, pe,
 +				  &ver, &hdr, &cnt, &len, &ocfg);
 +	if (!addr)
 +		return -EINVAL;
 +
 +	data[0] = nvkm_rd32(device, 0x61c118 + loff) & ~(0x000000ff << shift);
 +	data[1] = nvkm_rd32(device, 0x61c120 + loff) & ~(0x000000ff << shift);
 +	data[2] = nvkm_rd32(device, 0x61c130 + loff);
 +	if ((data[2] & 0x0000ff00) < (ocfg.tx_pu << 8) || ln == 0)
 +		data[2] = (data[2] & ~0x0000ff00) | (ocfg.tx_pu << 8);
 +	nvkm_wr32(device, 0x61c118 + loff, data[0] | (ocfg.dc << shift));
 +	nvkm_wr32(device, 0x61c120 + loff, data[1] | (ocfg.pe << shift));
 +	nvkm_wr32(device, 0x61c130 + loff, data[2]);
 +	data[3] = nvkm_rd32(device, 0x61c13c + loff) & ~(0x000000ff << shift);
 +	nvkm_wr32(device, 0x61c13c + loff, data[3] | (ocfg.pc << shift));
 +	return 0;
  }
  
++<<<<<<< HEAD
  void
 -gf119_sor_state(struct nvkm_ior *sor, struct nvkm_ior_state *state)
 +gf119_sor_dp_vcpi(struct nvkm_output_dp *outp, int head, u8 slot,
 +		  u8 slot_nr, u16 pbn, u16 aligned)
  {
 -	struct nvkm_device *device = sor->disp->engine.subdev.device;
 -	const u32 coff = (state == &sor->asy) * 0x20000 + sor->id * 0x20;
 -	u32 ctrl = nvkm_rd32(device, 0x640200 + coff);
 -
 -	state->proto_evo = (ctrl & 0x00000f00) >> 8;
 -	switch (state->proto_evo) {
 -	case 0: state->proto = LVDS; state->link = 1; break;
 -	case 1: state->proto = TMDS; state->link = 1; break;
 -	case 2: state->proto = TMDS; state->link = 2; break;
 -	case 5: state->proto = TMDS; state->link = 3; break;
 -	case 8: state->proto =   DP; state->link = 1; break;
 -	case 9: state->proto =   DP; state->link = 2; break;
 -	default:
 -		state->proto = UNKNOWN;
 -		break;
 -	}
 -
 -	state->head = ctrl & 0x0000000f;
 -}
 +	struct nvkm_device *device = outp->base.disp->engine.subdev.device;
 +	const u32 hoff = head * 0x800;
  
 -int
 -gf119_sor_new_(const struct nvkm_ior_func *func, struct nvkm_disp *disp, int id)
 -{
 -	struct nvkm_device *device = disp->engine.subdev.device;
 -	if (!(nvkm_rd32(device, 0x612004) & (0x00000100 << id)))
 -		return 0;
 -	return nvkm_ior_new_(func, disp, SOR, id);
 +	nvkm_mask(device, 0x616588 + hoff, 0x00003f3f, (slot_nr << 8) | slot);
 +	nvkm_mask(device, 0x61658c + hoff, 0xffffffff, (aligned << 16) | pbn);
  }
  
 +static const struct nvkm_output_dp_func
 +gf119_sor_dp_func = {
 +	.pattern = gf119_sor_dp_pattern,
 +	.lnk_pwr = g94_sor_dp_lnk_pwr,
 +	.lnk_ctl = gf119_sor_dp_lnk_ctl,
 +	.drv_ctl = gf119_sor_dp_drv_ctl,
 +	.vcpi = gf119_sor_dp_vcpi,
++=======
+ static const struct nvkm_ior_func
+ gf119_sor = {
+ 	.state = gf119_sor_state,
+ 	.power = nv50_sor_power,
+ 	.clock = gf119_sor_clock,
+ 	.hdmi = {
+ 		.ctrl = gf119_hdmi_ctrl,
+ 	},
+ 	.dp = {
+ 		.lanes = { 2, 1, 0, 3 },
+ 		.links = gf119_sor_dp_links,
+ 		.power = g94_sor_dp_power,
+ 		.pattern = gf119_sor_dp_pattern,
+ 		.drive = gf119_sor_dp_drive,
+ 		.vcpi = gf119_sor_dp_vcpi,
+ 		.audio = gf119_sor_dp_audio,
+ 		.audio_sym = gf119_sor_dp_audio_sym,
+ 		.watermark = gf119_sor_dp_watermark,
+ 	},
+ 	.hda = {
+ 		.hpd = gf119_hda_hpd,
+ 		.eld = gf119_hda_eld,
+ 	},
++>>>>>>> 1b5c7ef3d0d0 (drm/nouveau/disp/gf119: add missing drive vfunc ptr)
  };
  
  int
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
