dma-mapping: consolidate dma_{alloc,free}_noncoherent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [kernel] dma-mapping: consolidate dma_{alloc, free}_noncoherent (Don Dutile) [1494648]
Rebuild_FUZZ: 99.07%
commit-author Christoph Hellwig <hch@lst.de>
commit 1e8937526e2309d48fccd81bb30a590ac21a5516
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1e893752.failed

Most architectures do not support non-coherent allocations and either
define dma_{alloc,free}_noncoherent to their coherent versions or stub
them out.

Openrisc uses dma_{alloc,free}_attrs to implement them, and only Mips
implements them directly.

This patch moves the Openrisc version to common code, and handles the
DMA_ATTR_NON_CONSISTENT case in the mips dma_map_ops instance.

Note that actual non-coherent allocations require a dma_cache_sync
implementation, so if non-coherent allocations didn't work on
an architecture before this patch they still won't work after it.

[jcmvbkbc@gmail.com: fix xtensa]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Russell King <linux@arm.linux.org.uk>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Chris Metcalf <cmetcalf@ezchip.com>
	Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1e8937526e2309d48fccd81bb30a590ac21a5516)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/dma-mapping.h
#	arch/h8300/include/asm/dma-mapping.h
#	arch/ia64/include/asm/dma-mapping.h
#	arch/microblaze/include/asm/dma-mapping.h
#	arch/mips/include/asm/dma-mapping.h
#	arch/openrisc/include/asm/dma-mapping.h
#	arch/sparc/include/asm/dma-mapping.h
#	arch/tile/include/asm/dma-mapping.h
#	arch/unicore32/include/asm/dma-mapping.h
#	arch/xtensa/include/asm/dma-mapping.h
#	include/asm-generic/dma-mapping-common.h
diff --cc arch/arm64/include/asm/dma-mapping.h
index 994776894198,178e60b80922..000000000000
--- a/arch/arm64/include/asm/dma-mapping.h
+++ b/arch/arm64/include/asm/dma-mapping.h
@@@ -81,45 -118,5 +81,48 @@@ static inline void dma_mark_clean(void 
  {
  }
  
++<<<<<<< HEAD
 +static inline void *dma_alloc_coherent(struct device *dev, size_t size,
 +				       dma_addr_t *dma_handle, gfp_t flags)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	void *vaddr;
 +
 +	if (dma_alloc_from_coherent(dev, size, dma_handle, &vaddr))
 +		return vaddr;
 +
 +	vaddr = ops->alloc(dev, size, dma_handle, flags, NULL);
 +	debug_dma_alloc_coherent(dev, size, *dma_handle, vaddr);
 +	return vaddr;
 +}
 +
 +static inline void dma_free_coherent(struct device *dev, size_t size,
 +				     void *vaddr, dma_addr_t dev_addr)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +
 +	if (dma_release_from_coherent(dev, get_order(size), vaddr))
 +		return;
 +
 +	debug_dma_free_coherent(dev, size, vaddr, dev_addr);
 +	ops->free(dev, size, vaddr, dev_addr, NULL);
 +}
 +
 +/*
 + * There is no dma_cache_sync() implementation, so just return NULL here.
 + */
 +static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
 +					  dma_addr_t *handle, gfp_t flags)
 +{
 +	return NULL;
 +}
 +
 +static inline void dma_free_noncoherent(struct device *dev, size_t size,
 +					void *cpu_addr, dma_addr_t handle)
 +{
 +}
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  #endif	/* __KERNEL__ */
  #endif	/* __ASM_DMA_MAPPING_H */
diff --cc arch/ia64/include/asm/dma-mapping.h
index cf3ab7e784b5,a925ff03c964..000000000000
--- a/arch/ia64/include/asm/dma-mapping.h
+++ b/arch/ia64/include/asm/dma-mapping.h
@@@ -23,34 -23,6 +23,37 @@@ extern void machvec_dma_sync_single(str
  extern void machvec_dma_sync_sg(struct device *, struct scatterlist *, int,
  				enum dma_data_direction);
  
++<<<<<<< HEAD
 +#define dma_alloc_coherent(d,s,h,f)	dma_alloc_attrs(d,s,h,f,NULL)
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *daddr, gfp_t gfp,
 +				    struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = platform_dma_get_ops(dev);
 +	void *caddr;
 +
 +	caddr = ops->alloc(dev, size, daddr, gfp, attrs);
 +	debug_dma_alloc_coherent(dev, size, *daddr, caddr);
 +	return caddr;
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *caddr, dma_addr_t daddr,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = platform_dma_get_ops(dev);
 +	debug_dma_free_coherent(dev, size, caddr, daddr);
 +	ops->free(dev, size, caddr, daddr, attrs);
 +}
 +
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  #define get_dma_ops(dev) platform_dma_get_ops(dev)
  
  #include <asm-generic/dma-mapping-common.h>
diff --cc arch/microblaze/include/asm/dma-mapping.h
index 46460f1c49c4,bc81625d486f..000000000000
--- a/arch/microblaze/include/asm/dma-mapping.h
+++ b/arch/microblaze/include/asm/dma-mapping.h
@@@ -122,39 -98,6 +122,42 @@@ static inline int dma_mapping_error(str
  	return (dma_addr == DMA_ERROR_CODE);
  }
  
++<<<<<<< HEAD
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 +
 +#define dma_alloc_coherent(d, s, h, f) dma_alloc_attrs(d, s, h, f, NULL)
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t flag,
 +				    struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	void *memory;
 +
 +	BUG_ON(!ops);
 +
 +	memory = ops->alloc(dev, size, dma_handle, flag, attrs);
 +
 +	debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
 +	return memory;
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d, s, c, h, NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *cpu_addr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +
 +	BUG_ON(!ops);
 +	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
 +	ops->free(dev, size, cpu_addr, dma_handle, attrs);
 +}
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
  		enum dma_data_direction direction)
  {
diff --cc arch/mips/include/asm/dma-mapping.h
index 84238c574d5e,709b2ba79cc3..000000000000
--- a/arch/mips/include/asm/dma-mapping.h
+++ b/arch/mips/include/asm/dma-mapping.h
@@@ -60,40 -64,4 +60,43 @@@ dma_set_mask(struct device *dev, u64 ma
  extern void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
  	       enum dma_data_direction direction);
  
++<<<<<<< HEAD
 +#define dma_alloc_coherent(d,s,h,f)	dma_alloc_attrs(d,s,h,f,NULL)
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t gfp,
 +				    struct dma_attrs *attrs)
 +{
 +	void *ret;
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +
 +	ret = ops->alloc(dev, size, dma_handle, gfp, attrs);
 +
 +	debug_dma_alloc_coherent(dev, size, *dma_handle, ret);
 +
 +	return ret;
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *vaddr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +
 +	ops->free(dev, size, vaddr, dma_handle, attrs);
 +
 +	debug_dma_free_coherent(dev, size, vaddr, dma_handle);
 +}
 +
 +
 +void *dma_alloc_noncoherent(struct device *dev, size_t size,
 +			   dma_addr_t *dma_handle, gfp_t flag);
 +
 +void dma_free_noncoherent(struct device *dev, size_t size,
 +			 void *vaddr, dma_addr_t dma_handle);
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  #endif /* _ASM_DMA_MAPPING_H */
diff --cc arch/openrisc/include/asm/dma-mapping.h
index fab8628e1b6e,57722528ea4d..000000000000
--- a/arch/openrisc/include/asm/dma-mapping.h
+++ b/arch/openrisc/include/asm/dma-mapping.h
@@@ -38,55 -37,6 +38,58 @@@ static inline struct dma_map_ops *get_d
  
  #include <asm-generic/dma-mapping-common.h>
  
++<<<<<<< HEAD
 +#define dma_alloc_coherent(d,s,h,f) dma_alloc_attrs(d,s,h,f,NULL) 
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t gfp,
 +				    struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	void *memory;
 +
 +	memory = ops->alloc(dev, size, dma_handle, gfp, attrs);
 +
 +	debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
 +
 +	return memory;
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *cpu_addr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +
 +	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
 +
 +	ops->free(dev, size, cpu_addr, dma_handle, attrs);
 +}
 +
 +static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
 +					  dma_addr_t *dma_handle, gfp_t gfp)
 +{
 +	struct dma_attrs attrs;
 +
 +	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
 +
 +	return dma_alloc_attrs(dev, size, dma_handle, gfp, &attrs);
 +}
 +
 +static inline void dma_free_noncoherent(struct device *dev, size_t size,
 +					 void *cpu_addr, dma_addr_t dma_handle)
 +{
 +	struct dma_attrs attrs;
 +
 +	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
 +
 +	dma_free_attrs(dev, size, cpu_addr, dma_handle, &attrs);
 +}
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  static inline int dma_supported(struct device *dev, u64 dma_mask)
  {
  	/* Support 32 bit DMA mask exclusively */
diff --cc arch/sparc/include/asm/dma-mapping.h
index 05fe53f5346e,2564edcb9728..000000000000
--- a/arch/sparc/include/asm/dma-mapping.h
+++ b/arch/sparc/include/asm/dma-mapping.h
@@@ -7,10 -7,15 +7,20 @@@
  
  #define DMA_ERROR_CODE	(~(dma_addr_t)0x0)
  
 -int dma_supported(struct device *dev, u64 mask);
 +extern int dma_supported(struct device *dev, u64 mask);
  
++<<<<<<< HEAD
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
++=======
+ static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+ 				  enum dma_data_direction dir)
+ {
+ 	/* Since dma_{alloc,free}_noncoherent() allocated coherent memory, this
+ 	 * routine can be a nop.
+ 	 */
+ }
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  
  extern struct dma_map_ops *dma_ops;
  extern struct dma_map_ops *leon_dma_ops;
diff --cc arch/tile/include/asm/dma-mapping.h
index f2ff191376b4,e982dfa5d2f4..000000000000
--- a/arch/tile/include/asm/dma-mapping.h
+++ b/arch/tile/include/asm/dma-mapping.h
@@@ -103,36 -116,6 +103,39 @@@ dma_set_mask(struct device *dev, u64 ma
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t flag,
 +				    struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *dma_ops = get_dma_ops(dev);
 +	void *cpu_addr;
 +
 +	cpu_addr = dma_ops->alloc(dev, size, dma_handle, flag, attrs);
 +
 +	debug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr);
 +
 +	return cpu_addr;
 +}
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *cpu_addr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *dma_ops = get_dma_ops(dev);
 +
 +	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
 +
 +	dma_ops->free(dev, size, cpu_addr, dma_handle, attrs);
 +}
 +
 +#define dma_alloc_coherent(d, s, h, f) dma_alloc_attrs(d, s, h, f, NULL)
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_attrs(d, s, h, f, NULL)
 +#define dma_free_coherent(d, s, v, h) dma_free_attrs(d, s, v, h, NULL)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_attrs(d, s, v, h, NULL)
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  /*
   * dma_alloc_noncoherent() is #defined to return coherent memory,
   * so there's no need to do any flushing here.
diff --cc arch/unicore32/include/asm/dma-mapping.h
index 366460a81796,636e942940a0..000000000000
--- a/arch/unicore32/include/asm/dma-mapping.h
+++ b/arch/unicore32/include/asm/dma-mapping.h
@@@ -82,31 -80,6 +82,34 @@@ static inline int dma_set_mask(struct d
  	return 0;
  }
  
++<<<<<<< HEAD
 +#define dma_alloc_coherent(d,s,h,f)	dma_alloc_attrs(d,s,h,f,NULL)
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t flag,
 +				    struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *dma_ops = get_dma_ops(dev);
 +
 +	return dma_ops->alloc(dev, size, dma_handle, flag, attrs);
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *cpu_addr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *dma_ops = get_dma_ops(dev);
 +
 +	dma_ops->free(dev, size, cpu_addr, dma_handle, attrs);
 +}
 +
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 +
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  static inline void dma_cache_sync(struct device *dev, void *vaddr,
  		size_t size, enum dma_data_direction direction)
  {
diff --cc arch/xtensa/include/asm/dma-mapping.h
index 172a02a6ad14,0a19581375da..000000000000
--- a/arch/xtensa/include/asm/dma-mapping.h
+++ b/arch/xtensa/include/asm/dma-mapping.h
@@@ -18,132 -20,25 +18,135 @@@
  
  #define DMA_ERROR_CODE		(~(dma_addr_t)0x0)
  
 -extern struct dma_map_ops xtensa_dma_map_ops;
 +/*
 + * DMA-consistent mapping functions.
 + */
 +
 +extern void *consistent_alloc(int, size_t, dma_addr_t, unsigned long);
 +extern void consistent_free(void*, size_t, dma_addr_t);
 +extern void consistent_sync(void*, size_t, int);
 +
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 +
 +void *dma_alloc_coherent(struct device *dev, size_t size,
 +			   dma_addr_t *dma_handle, gfp_t flag);
  
 -static inline struct dma_map_ops *get_dma_ops(struct device *dev)
 +void dma_free_coherent(struct device *dev, size_t size,
 +			 void *vaddr, dma_addr_t dma_handle);
 +
 +static inline dma_addr_t
 +dma_map_single(struct device *dev, void *ptr, size_t size,
 +	       enum dma_data_direction direction)
  {
 -	if (dev && dev->archdata.dma_ops)
 -		return dev->archdata.dma_ops;
 -	else
 -		return &xtensa_dma_map_ops;
 +	BUG_ON(direction == DMA_NONE);
 +	consistent_sync(ptr, size, direction);
 +	return virt_to_phys(ptr);
  }
  
 -#include <asm-generic/dma-mapping-common.h>
 +static inline void
 +dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
 +		 enum dma_data_direction direction)
 +{
 +	BUG_ON(direction == DMA_NONE);
 +}
  
++<<<<<<< HEAD
  static inline int
 -dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
 +	   enum dma_data_direction direction)
  {
 -	struct dma_map_ops *ops = get_dma_ops(dev);
 +	int i;
 +
 +	BUG_ON(direction == DMA_NONE);
 +
 +	for (i = 0; i < nents; i++, sg++ ) {
 +		BUG_ON(!sg_page(sg));
 +
 +		sg->dma_address = sg_phys(sg);
 +		consistent_sync(sg_virt(sg), sg->length, direction);
 +	}
  
 -	debug_dma_mapping_error(dev, dma_addr);
 -	return ops->mapping_error(dev, dma_addr);
 +	return nents;
 +}
 +
 +static inline dma_addr_t
 +dma_map_page(struct device *dev, struct page *page, unsigned long offset,
 +	     size_t size, enum dma_data_direction direction)
 +{
 +	BUG_ON(direction == DMA_NONE);
 +	return (dma_addr_t)(page_to_pfn(page)) * PAGE_SIZE + offset;
 +}
 +
 +static inline void
 +dma_unmap_page(struct device *dev, dma_addr_t dma_address, size_t size,
 +	       enum dma_data_direction direction)
 +{
 +	BUG_ON(direction == DMA_NONE);
 +}
 +
 +
 +static inline void
 +dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nhwentries,
 +	     enum dma_data_direction direction)
 +{
 +	BUG_ON(direction == DMA_NONE);
 +}
 +
 +static inline void
 +dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle, size_t size,
 +		enum dma_data_direction direction)
 +{
 +	consistent_sync((void *)bus_to_virt(dma_handle), size, direction);
 +}
 +
 +static inline void
 +dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,
 +		           size_t size, enum dma_data_direction direction)
 +{
 +	consistent_sync((void *)bus_to_virt(dma_handle), size, direction);
 +}
 +
 +static inline void
 +dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t dma_handle,
 +		      unsigned long offset, size_t size,
 +		      enum dma_data_direction direction)
 +{
 +
 +	consistent_sync((void *)bus_to_virt(dma_handle)+offset,size,direction);
 +}
 +
 +static inline void
 +dma_sync_single_range_for_device(struct device *dev, dma_addr_t dma_handle,
 +		      unsigned long offset, size_t size,
 +		      enum dma_data_direction direction)
 +{
 +
 +	consistent_sync((void *)bus_to_virt(dma_handle)+offset,size,direction);
 +}
 +static inline void
 +dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nelems,
 +		 enum dma_data_direction dir)
 +{
 +	int i;
 +	for (i = 0; i < nelems; i++, sg++)
 +		consistent_sync(sg_virt(sg), sg->length, dir);
 +}
 +
 +static inline void
 +dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nelems,
 +		 enum dma_data_direction dir)
 +{
 +	int i;
 +	for (i = 0; i < nelems; i++, sg++)
 +		consistent_sync(sg_virt(sg), sg->length, dir);
 +}
++=======
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
 +static inline int
 +dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +{
 +	return 0;
  }
  
  static inline int
diff --cc include/asm-generic/dma-mapping-common.h
index de8bf89940f8,ec321dd98f93..000000000000
--- a/include/asm-generic/dma-mapping-common.h
+++ b/include/asm-generic/dma-mapping-common.h
@@@ -231,4 -238,79 +231,82 @@@ dma_get_sgtable_attrs(struct device *de
  
  #define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, NULL)
  
++<<<<<<< HEAD
++=======
+ #ifndef arch_dma_alloc_attrs
+ #define arch_dma_alloc_attrs(dev, flag)	(true)
+ #endif
+ 
+ static inline void *dma_alloc_attrs(struct device *dev, size_t size,
+ 				       dma_addr_t *dma_handle, gfp_t flag,
+ 				       struct dma_attrs *attrs)
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 	void *cpu_addr;
+ 
+ 	BUG_ON(!ops);
+ 
+ 	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
+ 		return cpu_addr;
+ 
+ 	if (!arch_dma_alloc_attrs(&dev, &flag))
+ 		return NULL;
+ 	if (!ops->alloc)
+ 		return NULL;
+ 
+ 	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
+ 	debug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr);
+ 	return cpu_addr;
+ }
+ 
+ static inline void dma_free_attrs(struct device *dev, size_t size,
+ 				     void *cpu_addr, dma_addr_t dma_handle,
+ 				     struct dma_attrs *attrs)
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!ops);
+ 	WARN_ON(irqs_disabled());
+ 
+ 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
+ 		return;
+ 
+ 	if (!ops->free)
+ 		return;
+ 
+ 	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
+ 	ops->free(dev, size, cpu_addr, dma_handle, attrs);
+ }
+ 
+ static inline void *dma_alloc_coherent(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, gfp_t flag)
+ {
+ 	return dma_alloc_attrs(dev, size, dma_handle, flag, NULL);
+ }
+ 
+ static inline void dma_free_coherent(struct device *dev, size_t size,
+ 		void *cpu_addr, dma_addr_t dma_handle)
+ {
+ 	return dma_free_attrs(dev, size, cpu_addr, dma_handle, NULL);
+ }
+ 
+ static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, gfp_t gfp)
+ {
+ 	DEFINE_DMA_ATTRS(attrs);
+ 
+ 	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+ 	return dma_alloc_attrs(dev, size, dma_handle, gfp, &attrs);
+ }
+ 
+ static inline void dma_free_noncoherent(struct device *dev, size_t size,
+ 		void *cpu_addr, dma_addr_t dma_handle)
+ {
+ 	DEFINE_DMA_ATTRS(attrs);
+ 
+ 	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+ 	dma_free_attrs(dev, size, cpu_addr, dma_handle, &attrs);
+ }
+ 
++>>>>>>> 1e8937526e23 (dma-mapping: consolidate dma_{alloc,free}_noncoherent)
  #endif
* Unmerged path arch/h8300/include/asm/dma-mapping.h
diff --git a/arch/alpha/include/asm/dma-mapping.h b/arch/alpha/include/asm/dma-mapping.h
index dfa32f061320..71ec85d54a67 100644
--- a/arch/alpha/include/asm/dma-mapping.h
+++ b/arch/alpha/include/asm/dma-mapping.h
@@ -45,9 +45,6 @@ static inline int dma_set_mask(struct device *dev, u64 mask)
 	return get_dma_ops(dev)->set_dma_mask(dev, mask);
 }
 
-#define dma_alloc_noncoherent(d, s, h, f)	dma_alloc_coherent(d, s, h, f)
-#define dma_free_noncoherent(d, s, v, h)	dma_free_coherent(d, s, v, h)
-
 #define dma_cache_sync(dev, va, size, dir)		  ((void)0)
 
 #endif	/* _ALPHA_DMA_MAPPING_H */
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index 5b579b951503..30cdab9d4d0e 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -28,6 +28,12 @@ static inline void set_dma_ops(struct device *dev, struct dma_map_ops *ops)
 	dev->archdata.dma_ops = ops;
 }
 
+/*
+ * Note that while the generic code provides dummy dma_{alloc,free}_noncoherent
+ * implementations, we don't provide a dma_cache_sync function so drivers using
+ * this API are highlighted with build warnings.
+ */
+
 #include <asm-generic/dma-mapping-common.h>
 
 static inline int dma_set_mask(struct device *dev, u64 mask)
@@ -95,21 +101,6 @@ static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 	return dma_addr == DMA_ERROR_CODE;
 }
 
-/*
- * Dummy noncoherent implementation.  We don't provide a dma_cache_sync
- * function so drivers using this API are highlighted with build warnings.
- */
-static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
-		dma_addr_t *handle, gfp_t gfp)
-{
-	return NULL;
-}
-
-static inline void dma_free_noncoherent(struct device *dev, size_t size,
-		void *cpu_addr, dma_addr_t handle)
-{
-}
-
 extern int dma_supported(struct device *dev, u64 mask);
 
 extern int arm_dma_set_mask(struct device *dev, u64 dma_mask);
* Unmerged path arch/arm64/include/asm/dma-mapping.h
* Unmerged path arch/h8300/include/asm/dma-mapping.h
diff --git a/arch/hexagon/include/asm/dma-mapping.h b/arch/hexagon/include/asm/dma-mapping.h
index 85e9935660cb..0a91f63a58fc 100644
--- a/arch/hexagon/include/asm/dma-mapping.h
+++ b/arch/hexagon/include/asm/dma-mapping.h
@@ -35,9 +35,6 @@ extern int bad_dma_address;
 
 extern struct dma_map_ops *dma_ops;
 
-#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
-#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
-
 static inline struct dma_map_ops *get_dma_ops(struct device *dev)
 {
 	if (unlikely(dev == NULL))
* Unmerged path arch/ia64/include/asm/dma-mapping.h
* Unmerged path arch/microblaze/include/asm/dma-mapping.h
* Unmerged path arch/mips/include/asm/dma-mapping.h
diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c
index caf92ecb37d6..11c25179a59f 100644
--- a/arch/mips/mm/dma-default.c
+++ b/arch/mips/mm/dma-default.c
@@ -99,7 +99,7 @@ static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
 	return gfp | dma_flag;
 }
 
-void *dma_alloc_noncoherent(struct device *dev, size_t size,
+static void *mips_dma_alloc_noncoherent(struct device *dev, size_t size,
 	dma_addr_t * dma_handle, gfp_t gfp)
 {
 	void *ret;
@@ -115,7 +115,6 @@ void *dma_alloc_noncoherent(struct device *dev, size_t size,
 
 	return ret;
 }
-EXPORT_SYMBOL(dma_alloc_noncoherent);
 
 static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
 	dma_addr_t * dma_handle, gfp_t gfp, struct dma_attrs *attrs)
@@ -125,6 +124,13 @@ static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
 	if (dma_alloc_from_coherent(dev, size, dma_handle, &ret))
 		return ret;
 
+	/*
+	 * XXX: seems like the coherent and non-coherent implementations could
+	 * be consolidated.
+	 */
+	if (dma_get_attr(DMA_ATTR_NON_CONSISTENT, attrs))
+		return mips_dma_alloc_noncoherent(dev, size, dma_handle, gfp);
+
 	gfp = massage_gfp_flags(dev, gfp);
 
 	ret = (void *) __get_free_pages(gfp, get_order(size));
@@ -144,13 +150,12 @@ static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
 }
 
 
-void dma_free_noncoherent(struct device *dev, size_t size, void *vaddr,
-	dma_addr_t dma_handle)
+static void mips_dma_free_noncoherent(struct device *dev, size_t size,
+		void *vaddr, dma_addr_t dma_handle)
 {
 	plat_unmap_dma_mem(dev, dma_handle, size, DMA_BIDIRECTIONAL);
 	free_pages((unsigned long) vaddr, get_order(size));
 }
-EXPORT_SYMBOL(dma_free_noncoherent);
 
 static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
 	dma_addr_t dma_handle, struct dma_attrs *attrs)
@@ -161,6 +166,11 @@ static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
 	if (dma_release_from_coherent(dev, order, vaddr))
 		return;
 
+	if (dma_get_attr(DMA_ATTR_NON_CONSISTENT, attrs)) {
+		mips_dma_free_noncoherent(dev, size, vaddr, dma_handle);
+		return;
+	}
+
 	plat_unmap_dma_mem(dev, dma_handle, size, DMA_BIDIRECTIONAL);
 
 	if (!plat_device_is_coherent(dev) && !hw_coherentio)
* Unmerged path arch/openrisc/include/asm/dma-mapping.h
diff --git a/arch/powerpc/include/asm/dma-mapping.h b/arch/powerpc/include/asm/dma-mapping.h
index c6f39b7c9f40..5ee3e09612a3 100644
--- a/arch/powerpc/include/asm/dma-mapping.h
+++ b/arch/powerpc/include/asm/dma-mapping.h
@@ -210,9 +210,6 @@ static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
 	return daddr - get_dma_offset(dev);
 }
 
-#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
-#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
-
 #define ARCH_HAS_DMA_MMAP_COHERENT
 
 static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
diff --git a/arch/s390/include/asm/dma-mapping.h b/arch/s390/include/asm/dma-mapping.h
index 3f2d5669375a..152011bee402 100644
--- a/arch/s390/include/asm/dma-mapping.h
+++ b/arch/s390/include/asm/dma-mapping.h
@@ -27,9 +27,6 @@ static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
 {
 }
 
-#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
-#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
-
 #include <asm-generic/dma-mapping-common.h>
 
 static inline int dma_supported(struct device *dev, u64 mask)
diff --git a/arch/sh/include/asm/dma-mapping.h b/arch/sh/include/asm/dma-mapping.h
index b437f2c780b8..2efb55e652e4 100644
--- a/arch/sh/include/asm/dma-mapping.h
+++ b/arch/sh/include/asm/dma-mapping.h
@@ -39,9 +39,6 @@ static inline int dma_set_mask(struct device *dev, u64 mask)
 void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
 		    enum dma_data_direction dir);
 
-#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
-#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
-
 static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 {
 	struct dma_map_ops *ops = get_dma_ops(dev);
* Unmerged path arch/sparc/include/asm/dma-mapping.h
* Unmerged path arch/tile/include/asm/dma-mapping.h
* Unmerged path arch/unicore32/include/asm/dma-mapping.h
diff --git a/arch/x86/include/asm/dma-mapping.h b/arch/x86/include/asm/dma-mapping.h
index 1f5b7287d1ad..e3d622803c6d 100644
--- a/arch/x86/include/asm/dma-mapping.h
+++ b/arch/x86/include/asm/dma-mapping.h
@@ -54,9 +54,6 @@ static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 	return (dma_addr == DMA_ERROR_CODE);
 }
 
-#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
-#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
-
 extern int dma_supported(struct device *hwdev, u64 mask);
 extern int dma_set_mask(struct device *dev, u64 mask);
 
* Unmerged path arch/xtensa/include/asm/dma-mapping.h
* Unmerged path include/asm-generic/dma-mapping-common.h
