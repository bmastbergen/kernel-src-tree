macsec: Fix header length if SCI is added if explicitly disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tobias Brunner <tobias@strongswan.org>
commit e0f841f5cbf2a195c63f3441f3d8ef1cd2bdeeed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e0f841f5.failed

Even if sending SCIs is explicitly disabled, the code that creates the
Security Tag might still decide to add it (e.g. if multiple RX SCs are
defined on the MACsec interface).
But because the header length so far only depended on the configuration
option the SCI overwrote the original frame's contents (EtherType and
e.g. the beginning of the IP header) and if encrypted did not visibly
end up in the packet, while the SC flag in the TCI field of the Security
Tag was still set, resulting in invalid MACsec frames.

Fixes: c09440f7dcb3 ("macsec: introduce IEEE 802.1AE driver")
	Signed-off-by: Tobias Brunner <tobias@strongswan.org>
	Acked-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e0f841f5cbf2a195c63f3441f3d8ef1cd2bdeeed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macsec.c
diff --cc drivers/net/macsec.c
index 06e10f832c4e,d2e61e002926..000000000000
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@@ -736,28 -732,17 +746,35 @@@ static struct sk_buff *macsec_encrypt(s
  
  	macsec_fill_iv(iv, secy->sci, pn);
  
 -	sg_init_table(sg, MAX_SKB_FRAGS + 1);
 -	skb_to_sgvec(skb, sg, 0, skb->len);
 -
  	if (tx_sc->encrypt) {
++<<<<<<< HEAD
 +		int assoc_len = macsec_hdr_len(tx_sc->send_sci);
 +		int data_len = skb->len - secy->icv_len - assoc_len;
 +
 +		sg_init_table(sg_ad, ret);
 +		skb_to_sgvec(skb, sg_ad, 0, assoc_len);
 +		sg_init_table(sg, ret);
 +		skb_to_sgvec(skb, sg, assoc_len, data_len + secy->icv_len);
 +
 +		aead_request_set_crypt(req, sg, sg, data_len, iv);
 +		aead_request_set_assoc(req, sg_ad, assoc_len);
++=======
+ 		int len = skb->len - macsec_hdr_len(sci_present) -
+ 			  secy->icv_len;
+ 		aead_request_set_crypt(req, sg, sg, len, iv);
+ 		aead_request_set_ad(req, macsec_hdr_len(sci_present));
++>>>>>>> e0f841f5cbf2 (macsec: Fix header length if SCI is added if explicitly disabled)
  	} else {
 +		int assoc_len = skb->len - secy->icv_len;
 +		int data_len = secy->icv_len;
 +
 +		sg_init_table(sg_ad, ret);
 +		skb_to_sgvec(skb, sg_ad, 0, assoc_len);
 +		sg_init_table(sg, ret);
 +		skb_to_sgvec(skb, sg, assoc_len, data_len);
 +
  		aead_request_set_crypt(req, sg, sg, 0, iv);
 -		aead_request_set_ad(req, skb->len - secy->icv_len);
 +		aead_request_set_assoc(req, sg_ad, assoc_len);
  	}
  
  	macsec_skb_cb(skb)->req = req;
* Unmerged path drivers/net/macsec.c
