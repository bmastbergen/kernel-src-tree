vxlan: get rid of redundant vxlan_dev.flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthias Schiffer <mschiffer@universe-factory.net>
commit dc5321d79697db1b610c25fa4fad1aec7533ea3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dc5321d7.failed

There is no good reason to keep the flags twice in vxlan_dev and
vxlan_config.

	Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dc5321d79697db1b610c25fa4fad1aec7533ea3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 740e6d79f5f2,b4fce3b29647..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -304,6 -305,10 +304,13 @@@ static int vxlan_fdb_info(struct sk_buf
  	if (rdst->remote_vni != vxlan->default_dst.remote_vni &&
  	    nla_put_u32(skb, NDA_VNI, be32_to_cpu(rdst->remote_vni)))
  		goto nla_put_failure;
++<<<<<<< HEAD
++=======
+ 	if ((vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) && fdb->vni &&
+ 	    nla_put_u32(skb, NDA_SRC_VNI,
+ 			be32_to_cpu(fdb->vni)))
+ 		goto nla_put_failure;
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  	if (rdst->remote_ifindex &&
  	    nla_put_u32(skb, NDA_IFINDEX, rdst->remote_ifindex))
  		goto nla_put_failure;
@@@ -402,11 -407,22 +409,18 @@@ static u32 eth_hash(const unsigned cha
  	return hash_64(value, FDB_HASH_BITS);
  }
  
 -static u32 eth_vni_hash(const unsigned char *addr, __be32 vni)
 -{
 -	/* use 1 byte of OUI and 3 bytes of NIC */
 -	u32 key = get_unaligned((u32 *)(addr + 2));
 -
 -	return jhash_2words(key, vni, vxlan_salt) & (FDB_HASH_SIZE - 1);
 -}
 -
  /* Hash chain to use given mac address */
  static inline struct hlist_head *vxlan_fdb_head(struct vxlan_dev *vxlan,
 -						const u8 *mac, __be32 vni)
 +						const u8 *mac)
  {
++<<<<<<< HEAD
 +	return &vxlan->fdb_head[eth_hash(mac)];
++=======
+ 	if (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA)
+ 		return &vxlan->fdb_head[eth_vni_hash(mac, vni)];
+ 	else
+ 		return &vxlan->fdb_head[eth_hash(mac)];
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  }
  
  /* Look up Ethernet address in forwarding table */
@@@ -417,8 -433,14 +431,19 @@@ static struct vxlan_fdb *__vxlan_find_m
  	struct vxlan_fdb *f;
  
  	hlist_for_each_entry_rcu(f, head, hlist) {
++<<<<<<< HEAD
 +		if (ether_addr_equal(mac, f->eth_addr))
 +			return f;
++=======
+ 		if (ether_addr_equal(mac, f->eth_addr)) {
+ 			if (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) {
+ 				if (vni == f->vni)
+ 					return f;
+ 			} else {
+ 				return f;
+ 			}
+ 		}
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  	}
  
  	return NULL;
@@@ -1228,8 -1284,8 +1253,13 @@@ static bool vxlan_set_mac(struct vxlan_
  #endif
  	}
  
++<<<<<<< HEAD
 +	if ((vxlan->flags & VXLAN_F_LEARN) &&
 +	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source))
++=======
+ 	if ((vxlan->cfg.flags & VXLAN_F_LEARN) &&
+ 	    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source, vni))
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  		return false;
  
  	return true;
@@@ -1882,8 -1993,8 +1912,13 @@@ static void vxlan_encap_bypass(struct s
  #endif
  	}
  
++<<<<<<< HEAD
 +	if (dst_vxlan->flags & VXLAN_F_LEARN)
 +		vxlan_snoop(skb->dev, &loopback, eth_hdr(skb)->h_source);
++=======
+ 	if (dst_vxlan->cfg.flags & VXLAN_F_LEARN)
+ 		vxlan_snoop(skb->dev, &loopback, eth_hdr(skb)->h_source, vni);
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  
  	u64_stats_update_begin(&tx_stats->syncp);
  	tx_stats->tx_packets++;
@@@ -1900,8 -2011,43 +1935,45 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int encap_bypass_if_local(struct sk_buff *skb, struct net_device *dev,
+ 				 struct vxlan_dev *vxlan, union vxlan_addr *daddr,
+ 				 __be16 dst_port, __be32 vni, struct dst_entry *dst,
+ 				 u32 rt_flags)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	/* IPv6 rt-flags are checked against RTF_LOCAL, but the value of
+ 	 * RTF_LOCAL is equal to RTCF_LOCAL. So to keep code simple
+ 	 * we can use RTCF_LOCAL which works for ipv4 and ipv6 route entry.
+ 	 */
+ 	BUILD_BUG_ON(RTCF_LOCAL != RTF_LOCAL);
+ #endif
+ 	/* Bypass encapsulation if the destination is local */
+ 	if (rt_flags & RTCF_LOCAL &&
+ 	    !(rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
+ 		struct vxlan_dev *dst_vxlan;
+ 
+ 		dst_release(dst);
+ 		dst_vxlan = vxlan_find_vni(vxlan->net, vni,
+ 					   daddr->sa.sa_family, dst_port,
+ 					   vxlan->cfg.flags);
+ 		if (!dst_vxlan) {
+ 			dev->stats.tx_errors++;
+ 			kfree_skb(skb);
+ 
+ 			return -ENOENT;
+ 		}
+ 		vxlan_encap_bypass(skb, vxlan, dst_vxlan, vni);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
 -			   __be32 default_vni, struct vxlan_rdst *rdst,
 -			   bool did_rsc)
 +			   struct vxlan_rdst *rdst, bool did_rsc)
  {
  	struct dst_cache *dst_cache;
  	struct ip_tunnel_info *info;
@@@ -1915,11 -2058,11 +1987,11 @@@
  	struct vxlan_metadata _md;
  	struct vxlan_metadata *md = &_md;
  	__be16 src_port = 0, dst_port;
 -	struct dst_entry *ndst = NULL;
  	__be32 vni, label;
 +	__be16 df = 0;
  	__u8 tos, ttl;
  	int err;
- 	u32 flags = vxlan->flags;
+ 	u32 flags = vxlan->cfg.flags;
  	bool udp_sum = false;
  	bool xnet = !net_eq(vxlan->net, dev_net(vxlan->dev));
  
@@@ -2142,38 -2244,40 +2214,52 @@@ static netdev_tx_t vxlan_xmit(struct sk
  
  	skb_reset_mac_header(skb);
  
++<<<<<<< HEAD
 +	if (vxlan->flags & VXLAN_F_COLLECT_METADATA) {
 +		if (info && info->mode & IP_TUNNEL_INFO_TX)
 +			vxlan_xmit_one(skb, dev, NULL, false);
 +		else
 +			kfree_skb(skb);
 +		return NETDEV_TX_OK;
++=======
+ 	if (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) {
+ 		if (info && info->mode & IP_TUNNEL_INFO_BRIDGE &&
+ 		    info->mode & IP_TUNNEL_INFO_TX) {
+ 			vni = tunnel_id_to_key32(info->key.tun_id);
+ 		} else {
+ 			if (info && info->mode & IP_TUNNEL_INFO_TX)
+ 				vxlan_xmit_one(skb, dev, vni, NULL, false);
+ 			else
+ 				kfree_skb(skb);
+ 			return NETDEV_TX_OK;
+ 		}
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  	}
  
- 	if (vxlan->flags & VXLAN_F_PROXY) {
+ 	if (vxlan->cfg.flags & VXLAN_F_PROXY) {
  		eth = eth_hdr(skb);
  		if (ntohs(eth->h_proto) == ETH_P_ARP)
 -			return arp_reduce(dev, skb, vni);
 +			return arp_reduce(dev, skb);
  #if IS_ENABLED(CONFIG_IPV6)
 -		else if (ntohs(eth->h_proto) == ETH_P_IPV6) {
 -			struct ipv6hdr *hdr, _hdr;
 -			if ((hdr = skb_header_pointer(skb,
 -						      skb_network_offset(skb),
 -						      sizeof(_hdr), &_hdr)) &&
 -			    hdr->nexthdr == IPPROTO_ICMPV6)
 -				return neigh_reduce(dev, skb, vni);
 +		else if (ntohs(eth->h_proto) == ETH_P_IPV6 &&
 +			 pskb_may_pull(skb, sizeof(struct ipv6hdr)
 +				       + sizeof(struct nd_msg)) &&
 +			 ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {
 +				struct nd_msg *msg;
 +
 +				msg = (struct nd_msg *)skb_transport_header(skb);
 +				if (msg->icmph.icmp6_code == 0 &&
 +				    msg->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)
 +					return neigh_reduce(dev, skb);
  		}
  #endif
  	}
  
  	eth = eth_hdr(skb);
 -	f = vxlan_find_mac(vxlan, eth->h_dest, vni);
 +	f = vxlan_find_mac(vxlan, eth->h_dest);
  	did_rsc = false;
  
- 	if (f && (f->flags & NTF_ROUTER) && (vxlan->flags & VXLAN_F_RSC) &&
+ 	if (f && (f->flags & NTF_ROUTER) && (vxlan->cfg.flags & VXLAN_F_RSC) &&
  	    (ntohs(eth->h_proto) == ETH_P_IP ||
  	     ntohs(eth->h_proto) == ETH_P_IPV6)) {
  		did_rsc = route_shortcircuit(dev, skb);
@@@ -2182,9 -2286,9 +2268,9 @@@
  	}
  
  	if (f == NULL) {
 -		f = vxlan_find_mac(vxlan, all_zeros_mac, vni);
 +		f = vxlan_find_mac(vxlan, all_zeros_mac);
  		if (f == NULL) {
- 			if ((vxlan->flags & VXLAN_F_L2MISS) &&
+ 			if ((vxlan->cfg.flags & VXLAN_F_L2MISS) &&
  			    !is_multicast_ether_addr(eth->h_dest))
  				vxlan_fdb_miss(vxlan, eth->h_dest);
  
@@@ -2804,16 -2893,92 +2890,64 @@@ static int vxlan_dev_configure(struct n
  		 */
  		if ((conf->flags & ~VXLAN_F_ALLOWED_GPE) ||
  		    !(conf->flags & VXLAN_F_COLLECT_METADATA)) {
 +			pr_info("unsupported combination of extensions\n");
  			return -EINVAL;
  		}
 -	}
 -
 -	if (!conf->remote_ip.sa.sa_family)
 -		conf->remote_ip.sa.sa_family = AF_INET;
 -
 -	if (conf->remote_ip.sa.sa_family == AF_INET6 ||
 -	    conf->saddr.sa.sa_family == AF_INET6) {
 -		if (!IS_ENABLED(CONFIG_IPV6))
 -			return -EPFNOSUPPORT;
 -		use_ipv6 = true;
 -		conf->flags |= VXLAN_F_IPV6;
 -	}
 -
 -	if (conf->label && !use_ipv6)
 -		return -EINVAL;
 -
 -	if (conf->remote_ifindex) {
 -		struct net_device *lowerdev;
 -
 -		lowerdev = __dev_get_by_index(src_net, conf->remote_ifindex);
 -		if (!lowerdev)
 -			return -ENODEV;
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -		if (use_ipv6) {
 -			struct inet6_dev *idev = __in6_dev_get(lowerdev);
 -			if (idev && idev->cnf.disable_ipv6)
 -				return -EPERM;
 -		}
 -#endif
  
 -		*lower = lowerdev;
 +		vxlan_raw_setup(dev);
  	} else {
 -		if (vxlan_addr_multicast(&conf->remote_ip))
 -			return -EINVAL;
 -
 -		*lower = NULL;
 +		vxlan_ether_setup(dev);
  	}
  
++<<<<<<< HEAD
 +	vxlan->net = src_net;
++=======
+ 	if (!conf->dst_port) {
+ 		if (conf->flags & VXLAN_F_GPE)
+ 			conf->dst_port = htons(4790); /* IANA VXLAN-GPE port */
+ 		else
+ 			conf->dst_port = htons(vxlan_port);
+ 	}
+ 
+ 	if (!conf->age_interval)
+ 		conf->age_interval = FDB_AGE_DEFAULT;
+ 
+ 	list_for_each_entry(tmp, &vn->vxlan_list, next) {
+ 		if (tmp == old)
+ 			continue;
+ 
+ 		if (tmp->cfg.vni == conf->vni &&
+ 		    (tmp->default_dst.remote_ip.sa.sa_family == AF_INET6 ||
+ 		     tmp->cfg.saddr.sa.sa_family == AF_INET6) == use_ipv6 &&
+ 		    tmp->cfg.dst_port == conf->dst_port &&
+ 		    (tmp->cfg.flags & VXLAN_F_RCV_FLAGS) ==
+ 		    (conf->flags & VXLAN_F_RCV_FLAGS))
+ 			return -EEXIST;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vxlan_config_apply(struct net_device *dev,
+ 			       struct vxlan_config *conf,
+ 			       struct net_device *lowerdev, bool changelink)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct vxlan_rdst *dst = &vxlan->default_dst;
+ 	unsigned short needed_headroom = ETH_HLEN;
+ 	bool use_ipv6 = !!(conf->flags & VXLAN_F_IPV6);
+ 	int max_mtu = ETH_MAX_MTU;
+ 
+ 	if (!changelink) {
+ 		if (conf->flags & VXLAN_F_GPE)
+ 			vxlan_raw_setup(dev);
+ 		else
+ 			vxlan_ether_setup(dev);
+ 
+ 		if (conf->mtu)
+ 			dev->mtu = conf->mtu;
+ 	}
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  
  	dst->remote_vni = conf->vni;
  
@@@ -2882,28 -3006,35 +3016,32 @@@
  	dev->needed_headroom = needed_headroom;
  
  	memcpy(&vxlan->cfg, conf, sizeof(*conf));
++<<<<<<< HEAD
 +	if (!vxlan->cfg.dst_port) {
 +		if (conf->flags & VXLAN_F_GPE)
 +			vxlan->cfg.dst_port = htons(4790); /* IANA VXLAN-GPE port */
 +		else
 +			vxlan->cfg.dst_port = default_port;
 +	}
 +	vxlan->flags |= conf->flags;
++=======
+ }
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  
 -static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,
 -			       struct vxlan_config *conf,
 -			       bool changelink)
 -{
 -	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	struct net_device *lowerdev;
 -	int ret;
 -
 -	ret = vxlan_config_validate(src_net, conf, &lowerdev, vxlan);
 -	if (ret)
 -		return ret;
 -
 -	vxlan_config_apply(dev, conf, lowerdev, changelink);
 -
 -	return 0;
 -}
 -
 -static int __vxlan_dev_create(struct net *net, struct net_device *dev,
 -			      struct vxlan_config *conf)
 -{
 -	struct vxlan_net *vn = net_generic(net, vxlan_net_id);
 -	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	int err;
 +	if (!vxlan->cfg.age_interval)
 +		vxlan->cfg.age_interval = FDB_AGE_DEFAULT;
  
 -	err = vxlan_dev_configure(net, dev, conf, false);
 -	if (err)
 -		return err;
 +	list_for_each_entry(tmp, &vn->vxlan_list, next) {
 +		if (tmp->cfg.vni == conf->vni &&
 +		    (tmp->default_dst.remote_ip.sa.sa_family == AF_INET6 ||
 +		     tmp->cfg.saddr.sa.sa_family == AF_INET6) == use_ipv6 &&
 +		    tmp->cfg.dst_port == vxlan->cfg.dst_port &&
 +		    (tmp->flags & VXLAN_F_RCV_FLAGS) ==
 +		    (vxlan->flags & VXLAN_F_RCV_FLAGS)) {
 +			pr_info("duplicate VNI %u\n", be32_to_cpu(conf->vni));
 +			return -EEXIST;
 +		}
 +	}
  
  	dev->ethtool_ops = &vxlan_ethtool_ops;
  
@@@ -2928,6 -3060,196 +3066,199 @@@
  	}
  
  	list_add(&vxlan->next, &vn->vxlan_list);
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int vxlan_nl2conf(struct nlattr *tb[], struct nlattr *data[],
+ 			 struct net_device *dev, struct vxlan_config *conf,
+ 			 bool changelink)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 
+ 	memset(conf, 0, sizeof(*conf));
+ 
+ 	/* if changelink operation, start with old existing cfg */
+ 	if (changelink)
+ 		memcpy(conf, &vxlan->cfg, sizeof(*conf));
+ 
+ 	if (data[IFLA_VXLAN_ID]) {
+ 		__be32 vni = cpu_to_be32(nla_get_u32(data[IFLA_VXLAN_ID]));
+ 
+ 		if (changelink && (vni != conf->vni))
+ 			return -EOPNOTSUPP;
+ 		conf->vni = cpu_to_be32(nla_get_u32(data[IFLA_VXLAN_ID]));
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_GROUP]) {
+ 		conf->remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);
+ 	} else if (data[IFLA_VXLAN_GROUP6]) {
+ 		if (!IS_ENABLED(CONFIG_IPV6))
+ 			return -EPFNOSUPPORT;
+ 
+ 		conf->remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);
+ 		conf->remote_ip.sa.sa_family = AF_INET6;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LOCAL]) {
+ 		conf->saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);
+ 		conf->saddr.sa.sa_family = AF_INET;
+ 	} else if (data[IFLA_VXLAN_LOCAL6]) {
+ 		if (!IS_ENABLED(CONFIG_IPV6))
+ 			return -EPFNOSUPPORT;
+ 
+ 		/* TODO: respect scope id */
+ 		conf->saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);
+ 		conf->saddr.sa.sa_family = AF_INET6;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LINK])
+ 		conf->remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]);
+ 
+ 	if (data[IFLA_VXLAN_TOS])
+ 		conf->tos  = nla_get_u8(data[IFLA_VXLAN_TOS]);
+ 
+ 	if (data[IFLA_VXLAN_TTL])
+ 		conf->ttl = nla_get_u8(data[IFLA_VXLAN_TTL]);
+ 
+ 	if (data[IFLA_VXLAN_LABEL])
+ 		conf->label = nla_get_be32(data[IFLA_VXLAN_LABEL]) &
+ 			     IPV6_FLOWLABEL_MASK;
+ 
+ 	if (data[IFLA_VXLAN_LEARNING]) {
+ 		if (nla_get_u8(data[IFLA_VXLAN_LEARNING]))
+ 			conf->flags |= VXLAN_F_LEARN;
+ 		else
+ 			conf->flags &= ~VXLAN_F_LEARN;
+ 	} else if (!changelink) {
+ 		/* default to learn on a new device */
+ 		conf->flags |= VXLAN_F_LEARN;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_AGEING]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->age_interval = nla_get_u32(data[IFLA_VXLAN_AGEING]);
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_PROXY]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_PROXY]))
+ 			conf->flags |= VXLAN_F_PROXY;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_RSC]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_RSC]))
+ 			conf->flags |= VXLAN_F_RSC;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_L2MISS]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_L2MISS]))
+ 			conf->flags |= VXLAN_F_L2MISS;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_L3MISS]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_L3MISS]))
+ 			conf->flags |= VXLAN_F_L3MISS;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_LIMIT]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->addrmax = nla_get_u32(data[IFLA_VXLAN_LIMIT]);
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_COLLECT_METADATA]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_COLLECT_METADATA]))
+ 			conf->flags |= VXLAN_F_COLLECT_METADATA;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_PORT_RANGE]) {
+ 		if (!changelink) {
+ 			const struct ifla_vxlan_port_range *p
+ 				= nla_data(data[IFLA_VXLAN_PORT_RANGE]);
+ 			conf->port_min = ntohs(p->low);
+ 			conf->port_max = ntohs(p->high);
+ 		} else {
+ 			return -EOPNOTSUPP;
+ 		}
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_PORT]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->dst_port = nla_get_be16(data[IFLA_VXLAN_PORT]);
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_UDP_CSUM]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (!nla_get_u8(data[IFLA_VXLAN_UDP_CSUM]))
+ 			conf->flags |= VXLAN_F_UDP_ZERO_CSUM_TX;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX]))
+ 			conf->flags |= VXLAN_F_UDP_ZERO_CSUM6_TX;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]))
+ 			conf->flags |= VXLAN_F_UDP_ZERO_CSUM6_RX;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_TX]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_REMCSUM_TX]))
+ 			conf->flags |= VXLAN_F_REMCSUM_TX;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_RX]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		if (nla_get_u8(data[IFLA_VXLAN_REMCSUM_RX]))
+ 			conf->flags |= VXLAN_F_REMCSUM_RX;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_GBP]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->flags |= VXLAN_F_GBP;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_GPE]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->flags |= VXLAN_F_GPE;
+ 	}
+ 
+ 	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->flags |= VXLAN_F_REMCSUM_NOPARTIAL;
+ 	}
+ 
+ 	if (tb[IFLA_MTU]) {
+ 		if (changelink)
+ 			return -EOPNOTSUPP;
+ 		conf->mtu = nla_get_u32(tb[IFLA_MTU]);
+ 	}
++>>>>>>> dc5321d79697 (vxlan: get rid of redundant vxlan_dev.flags)
  
  	return 0;
  }
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index f29e314da893..676668e0e1a4 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -240,7 +240,6 @@ struct vxlan_dev {
 	struct net_device *dev;
 	struct net	  *net;		/* netns for packet i/o */
 	struct vxlan_rdst default_dst;	/* default destination */
-	u32		  flags;	/* VXLAN_F_* in vxlan.h */
 
 	struct timer_list age_timer;
 	spinlock_t	  hash_lock;
diff --git a/net/openvswitch/vport-vxlan.c b/net/openvswitch/vport-vxlan.c
index e12b5b7a0b06..9757521d92c5 100644
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@ -40,14 +40,14 @@ static int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)
 	if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))
 		return -EMSGSIZE;
 
-	if (vxlan->flags & VXLAN_F_GBP) {
+	if (vxlan->cfg.flags & VXLAN_F_GBP) {
 		struct nlattr *exts;
 
 		exts = nla_nest_start(skb, OVS_TUNNEL_ATTR_EXTENSION);
 		if (!exts)
 			return -EMSGSIZE;
 
-		if (vxlan->flags & VXLAN_F_GBP &&
+		if (vxlan->cfg.flags & VXLAN_F_GBP &&
 		    nla_put_flag(skb, OVS_VXLAN_EXT_GBP))
 			return -EMSGSIZE;
 
