bnxt_en: Centralize logic to reserve rings.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Centralize logic to reserve rings (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.82%
commit-author Michael Chan <michael.chan@broadcom.com>
commit d1e7925e6d80ce5f9ef6deb8f3cec7526f5c443c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d1e7925e.failed

Currently, bnxt_setup_tc() and bnxt_set_channels() have similar and
duplicated code to check and reserve rx and tx rings.  Add a new
function bnxt_reserve_rings() to centralize the logic.  This will
make it easier to add XDP_TX support which requires allocating a
new set of TX rings.

Also, the tx ring checking logic in bnxt_setup_msix() can be removed.
The rings have been reserved before hand.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d1e7925e6d80ce5f9ef6deb8f3cec7526f5c443c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 4ce80edb8f5b,1b051f930598..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -6526,29 -6572,35 +6519,61 @@@ static void bnxt_sp_task(struct work_st
  	clear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);
  }
  
++<<<<<<< HEAD
 +static void bnxt_unmap_bars(struct bnxt *bp, struct pci_dev *pdev)
 +{
 +	if (bp->bar2) {
 +		pci_iounmap(pdev, bp->bar2);
 +		bp->bar2 = NULL;
 +	}
 +
 +	if (bp->bar1) {
 +		pci_iounmap(pdev, bp->bar1);
 +		bp->bar1 = NULL;
 +	}
 +
 +	if (bp->bar0) {
 +		pci_iounmap(pdev, bp->bar0);
 +		bp->bar0 = NULL;
 +	}
 +}
 +
 +static void bnxt_cleanup_pci(struct bnxt *bp)
 +{
 +	bnxt_unmap_bars(bp, bp->pdev);
 +	pci_release_regions(bp->pdev);
 +	pci_disable_device(bp->pdev);
++=======
+ /* Under rtnl_lock */
+ int bnxt_reserve_rings(struct bnxt *bp, int tx, int rx, int tcs)
+ {
+ 	int max_rx, max_tx, tx_sets = 1;
+ 	int tx_rings_needed;
+ 	bool sh = true;
+ 	int rc;
+ 
+ 	if (!(bp->flags & BNXT_FLAG_SHARED_RINGS))
+ 		sh = false;
+ 
+ 	if (tcs)
+ 		tx_sets = tcs;
+ 
+ 	rc = bnxt_get_max_rings(bp, &max_rx, &max_tx, sh);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (max_rx < rx)
+ 		return -ENOMEM;
+ 
+ 	tx_rings_needed = tx * tx_sets;
+ 	if (max_tx < tx_rings_needed)
+ 		return -ENOMEM;
+ 
+ 	if (bnxt_hwrm_reserve_tx_rings(bp, &tx_rings_needed) ||
+ 	    tx_rings_needed < (tx * tx_sets))
+ 		return -ENOMEM;
+ 	return 0;
++>>>>>>> d1e7925e6d80 (bnxt_en: Centralize logic to reserve rings.)
  }
  
  static int bnxt_init_board(struct pci_dev *pdev, struct net_device *dev)
@@@ -6701,9 -6765,10 +6726,10 @@@ int bnxt_setup_mq_tc(struct net_device 
  {
  	struct bnxt *bp = netdev_priv(dev);
  	bool sh = false;
+ 	int rc;
  
  	if (tc > bp->max_tc) {
 -		netdev_err(dev, "too many traffic classes requested: %d Max supported is %d\n",
 +		netdev_err(dev, "Too many traffic classes requested: %d. Max supported is %d.\n",
  			   tc, bp->max_tc);
  		return -EINVAL;
  	}
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.h b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
index d068cfc3f874..da24eb5222a6 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -1187,7 +1187,6 @@ int bnxt_hwrm_func_rgtr_async_events(struct bnxt *bp, unsigned long *bmap,
 				     int bmap_size);
 int bnxt_hwrm_vnic_cfg(struct bnxt *bp, u16 vnic_id);
 int __bnxt_hwrm_get_tx_rings(struct bnxt *bp, u16 fid, int *tx_rings);
-int bnxt_hwrm_reserve_tx_rings(struct bnxt *bp, int *tx_rings);
 int bnxt_hwrm_set_coal(struct bnxt *);
 unsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp);
 void bnxt_set_max_func_stat_ctxs(struct bnxt *bp, unsigned int max);
@@ -1201,6 +1200,7 @@ int bnxt_hwrm_set_link_setting(struct bnxt *, bool, bool);
 int bnxt_hwrm_fw_set_time(struct bnxt *);
 int bnxt_open_nic(struct bnxt *, bool, bool);
 int bnxt_close_nic(struct bnxt *, bool, bool);
+int bnxt_reserve_rings(struct bnxt *bp, int tx, int rx, int tcs);
 int bnxt_setup_mq_tc(struct net_device *dev, u8 tc);
 int bnxt_get_max_rings(struct bnxt *, int *, int *, bool);
 void bnxt_restore_pf_fw_resources(struct bnxt *bp);
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 2f132686f064..468e13cfd3bc 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -387,10 +387,9 @@ static int bnxt_set_channels(struct net_device *dev,
 			     struct ethtool_channels *channel)
 {
 	struct bnxt *bp = netdev_priv(dev);
-	int max_rx_rings, max_tx_rings, tcs;
-	int req_tx_rings, rsv_tx_rings;
-	u32 rc = 0;
+	int req_tx_rings, req_rx_rings, tcs;
 	bool sh = false;
+	int rc = 0;
 
 	if (channel->other_count)
 		return -EINVAL;
@@ -410,32 +409,14 @@ static int bnxt_set_channels(struct net_device *dev,
 	if (channel->combined_count)
 		sh = true;
 
-	bnxt_get_max_rings(bp, &max_rx_rings, &max_tx_rings, sh);
-
 	tcs = netdev_get_num_tc(dev);
-	if (tcs > 1)
-		max_tx_rings /= tcs;
-
-	if (sh &&
-	    channel->combined_count > max_t(int, max_rx_rings, max_tx_rings))
-		return -ENOMEM;
-
-	if (!sh && (channel->rx_count > max_rx_rings ||
-		    channel->tx_count > max_tx_rings))
-		return -ENOMEM;
 
 	req_tx_rings = sh ? channel->combined_count : channel->tx_count;
-	req_tx_rings = min_t(int, req_tx_rings, max_tx_rings);
-	if (tcs > 1)
-		req_tx_rings *= tcs;
-
-	rsv_tx_rings = req_tx_rings;
-	if (bnxt_hwrm_reserve_tx_rings(bp, &rsv_tx_rings))
-		return -ENOMEM;
-
-	if (rsv_tx_rings < req_tx_rings) {
-		netdev_warn(dev, "Unable to allocate the requested tx rings\n");
-		return -ENOMEM;
+	req_rx_rings = sh ? channel->combined_count : channel->rx_count;
+	rc = bnxt_reserve_rings(bp, req_tx_rings, req_rx_rings, tcs);
+	if (rc) {
+		netdev_warn(dev, "Unable to allocate the requested rings\n");
+		return rc;
 	}
 
 	if (netif_running(dev)) {
@@ -454,10 +435,8 @@ static int bnxt_set_channels(struct net_device *dev,
 
 	if (sh) {
 		bp->flags |= BNXT_FLAG_SHARED_RINGS;
-		bp->rx_nr_rings = min_t(int, channel->combined_count,
-					max_rx_rings);
-		bp->tx_nr_rings_per_tc = min_t(int, channel->combined_count,
-					       max_tx_rings);
+		bp->rx_nr_rings = channel->combined_count;
+		bp->tx_nr_rings_per_tc = channel->combined_count;
 	} else {
 		bp->flags &= ~BNXT_FLAG_SHARED_RINGS;
 		bp->rx_nr_rings = channel->rx_count;
