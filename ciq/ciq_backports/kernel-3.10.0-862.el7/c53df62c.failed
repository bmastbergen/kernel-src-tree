IB/hfi1: Check return values from PCI config API calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bartlomiej Dudek <bartlomiej.dudek@intel.com>
commit c53df62c7a9a82c7375308af270f90a08e94f6b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c53df62c.failed

Ensure that return values from kernel PCI config access
API calls in HFI driver are checked and react properly if
they are not expected (i.e. not successful).

	Reviewed-by: Jakub Byczkowski <jakub.byczkowski@intel.com>
	Signed-off-by: Bartlomiej Dudek <bartlomiej.dudek@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit c53df62c7a9a82c7375308af270f90a08e94f6b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/hfi.h
#	drivers/infiniband/hw/hfi1/pcie.c
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index 9e4a63b05006,62f843d7b099..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -1830,14 -1848,13 +1830,20 @@@ void hfi1_verbs_unregister_sysfs(struc
  /* Hook for sysfs read of QSFP */
  int qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len);
  
 -int hfi1_pcie_init(struct pci_dev *pdev, const struct pci_device_id *ent);
 -void hfi1_pcie_cleanup(struct pci_dev *pdev);
 -int hfi1_pcie_ddinit(struct hfi1_devdata *dd, struct pci_dev *pdev);
 +int hfi1_pcie_init(struct pci_dev *, const struct pci_device_id *);
 +void hfi1_pcie_cleanup(struct pci_dev *);
 +int hfi1_pcie_ddinit(struct hfi1_devdata *, struct pci_dev *);
  void hfi1_pcie_ddcleanup(struct hfi1_devdata *);
++<<<<<<< HEAD
 +int pcie_speeds(struct hfi1_devdata *);
 +void request_msix(struct hfi1_devdata *, u32 *, struct hfi1_msix_entry *);
 +void hfi1_enable_intx(struct pci_dev *);
 +void restore_pci_variables(struct hfi1_devdata *dd);
++=======
+ int pcie_speeds(struct hfi1_devdata *dd);
+ int request_msix(struct hfi1_devdata *dd, u32 msireq);
+ int restore_pci_variables(struct hfi1_devdata *dd);
++>>>>>>> c53df62c7a9a (IB/hfi1: Check return values from PCI config API calls)
  int do_pcie_gen3_transition(struct hfi1_devdata *dd);
  int parse_platform_config(struct hfi1_devdata *dd);
  int get_platform_config_field(struct hfi1_devdata *dd,
diff --cc drivers/infiniband/hw/hfi1/pcie.c
index 6a9f6f9819e1,903ea45bf650..000000000000
--- a/drivers/infiniband/hw/hfi1/pcie.c
+++ b/drivers/infiniband/hw/hfi1/pcie.c
@@@ -364,33 -370,34 +414,46 @@@ int pcie_speeds(struct hfi1_devdata *dd
  }
  
  /*
 - * Returns:
 - *	- actual number of interrupts allocated or
 + * Returns in *nent:
 + *	- actual number of interrupts allocated
   *	- 0 if fell back to INTx.
 - *      - error
   */
 -int request_msix(struct hfi1_devdata *dd, u32 msireq)
 +void request_msix(struct hfi1_devdata *dd, u32 *nent,
 +		  struct hfi1_msix_entry *entry)
  {
++<<<<<<< HEAD
 +	int pos;
++=======
+ 	int nvec, ret;
++>>>>>>> c53df62c7a9a (IB/hfi1: Check return values from PCI config API calls)
  
 -	nvec = pci_alloc_irq_vectors(dd->pcidev, 1, msireq,
 -				     PCI_IRQ_MSIX | PCI_IRQ_LEGACY);
 -	if (nvec < 0) {
 -		dd_dev_err(dd, "pci_alloc_irq_vectors() failed: %d\n", nvec);
 -		return nvec;
 +	pos = dd->pcidev->msix_cap;
 +	if (*nent && pos) {
 +		msix_setup(dd, pos, nent, entry);
 +		/* did it, either MSI-X or INTx */
 +	} else {
 +		*nent = 0;
 +		hfi1_enable_intx(dd->pcidev);
  	}
  
++<<<<<<< HEAD
 +	tune_pcie_caps(dd);
 +}
++=======
+ 	ret = tune_pcie_caps(dd);
+ 	if (ret) {
+ 		dd_dev_err(dd, "tune_pcie_caps() failed: %d\n", ret);
+ 		pci_free_irq_vectors(dd->pcidev);
+ 		return ret;
+ 	}
++>>>>>>> c53df62c7a9a (IB/hfi1: Check return values from PCI config API calls)
  
 -	/* check for legacy IRQ */
 -	if (nvec == 1 && !dd->pcidev->msix_enabled)
 -		return 0;
 -
 -	return nvec;
 +void hfi1_enable_intx(struct pci_dev *pdev)
 +{
 +	/* first, turn on INTx */
 +	pci_intx(pdev, 1);
 +	/* then turn off MSI-X */
 +	pci_disable_msix(pdev);
  }
  
  /* restore command and BARs after a reset has wiped them out */
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index f57caa8b4d09..cd7169364814 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -13821,9 +13821,10 @@ static void init_sc2vl_tables(struct hfi1_devdata *dd)
  * a reset following the (possible) FLR in this routine.
  *
  */
-static void init_chip(struct hfi1_devdata *dd)
+static int init_chip(struct hfi1_devdata *dd)
 {
 	int i;
+	int ret = 0;
 
 	/*
 	 * Put the HFI CSRs in a known state.
@@ -13871,12 +13872,22 @@ static void init_chip(struct hfi1_devdata *dd)
 		pcie_flr(dd->pcidev);
 
 		/* restore command and BARs */
-		restore_pci_variables(dd);
+		ret = restore_pci_variables(dd);
+		if (ret) {
+			dd_dev_err(dd, "%s: Could not restore PCI variables\n",
+				   __func__);
+			return ret;
+		}
 
 		if (is_ax(dd)) {
 			dd_dev_info(dd, "Resetting CSRs with FLR\n");
 			pcie_flr(dd->pcidev);
-			restore_pci_variables(dd);
+			ret = restore_pci_variables(dd);
+			if (ret) {
+				dd_dev_err(dd, "%s: Could not restore PCI variables\n",
+					   __func__);
+				return ret;
+			}
 		}
 	} else {
 		dd_dev_info(dd, "Resetting CSRs with writes\n");
@@ -13904,6 +13915,7 @@ static void init_chip(struct hfi1_devdata *dd)
 	write_csr(dd, ASIC_QSFP1_OUT, 0x1f);
 	write_csr(dd, ASIC_QSFP2_OUT, 0x1f);
 	init_chip_resources(dd);
+	return ret;
 }
 
 static void init_early_variables(struct hfi1_devdata *dd)
@@ -14889,7 +14901,9 @@ struct hfi1_devdata *hfi1_init_dd(struct pci_dev *pdev,
 		goto bail_cleanup;
 
 	/* obtain chip sizes, reset chip CSRs */
-	init_chip(dd);
+	ret = init_chip(dd);
+	if (ret)
+		goto bail_cleanup;
 
 	/* read in the PCIe link speed information */
 	ret = pcie_speeds(dd);
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
* Unmerged path drivers/infiniband/hw/hfi1/pcie.c
