tcm_loop: Send I_T_NEXUS_LOSS_OCCURRED UA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit e986a35aba67558381d5cec59a14c4d0b20f0d47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e986a35a.failed

If the virtual SAS link is set to 'offline' we should be
queueing an I_T_NEXUS_LOSS_OCCURRED UA.

	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit e986a35aba67558381d5cec59a14c4d0b20f0d47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/target/target_core_fabric.h
diff --cc include/target/target_core_fabric.h
index c9a57a197803,69355feabd1d..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -147,7 -151,8 +147,12 @@@ void	core_tmr_release_req(struct se_tmr
  int	transport_generic_handle_tmr(struct se_cmd *);
  void	transport_generic_request_failure(struct se_cmd *, sense_reason_t);
  void	__target_execute_cmd(struct se_cmd *);
++<<<<<<< HEAD
 +int	transport_lookup_tmr_lun(struct se_cmd *, u32);
++=======
+ int	transport_lookup_tmr_lun(struct se_cmd *, u64);
+ void	core_allocate_nexus_loss_ua(struct se_node_acl *acl);
++>>>>>>> e986a35aba67 (tcm_loop: Send I_T_NEXUS_LOSS_OCCURRED UA)
  
  struct se_node_acl *core_tpg_get_initiator_node_acl(struct se_portal_group *tpg,
  		unsigned char *);
diff --git a/drivers/target/loopback/tcm_loop.c b/drivers/target/loopback/tcm_loop.c
index 9f83e2336f48..a991c21cc2a6 100644
--- a/drivers/target/loopback/tcm_loop.c
+++ b/drivers/target/loopback/tcm_loop.c
@@ -1217,6 +1217,11 @@ static ssize_t tcm_loop_tpg_store_transport_status(
 	}
 	if (!strncmp(page, "offline", 7)) {
 		tl_tpg->tl_transport_status = TCM_TRANSPORT_OFFLINE;
+		if (tl_tpg->tl_nexus) {
+			struct se_session *tl_sess = tl_tpg->tl_nexus->se_sess;
+
+			core_allocate_nexus_loss_ua(tl_sess->se_node_acl);
+		}
 		return count;
 	}
 	return -EINVAL;
diff --git a/drivers/target/target_core_tpg.c b/drivers/target/target_core_tpg.c
index 0696de9553d3..c245cfc98eae 100644
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@ -41,6 +41,7 @@
 
 #include "target_core_internal.h"
 #include "target_core_pr.h"
+#include "target_core_ua.h"
 
 extern struct se_device *g_lun0_dev;
 
@@ -119,6 +120,22 @@ struct se_node_acl *core_tpg_get_initiator_node_acl(
 }
 EXPORT_SYMBOL(core_tpg_get_initiator_node_acl);
 
+void core_allocate_nexus_loss_ua(
+	struct se_node_acl *nacl)
+{
+	struct se_dev_entry *deve;
+
+	if (!nacl)
+		return;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link)
+		core_scsi3_ua_allocate(deve, 0x29,
+			ASCQ_29H_NEXUS_LOSS_OCCURRED);
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(core_allocate_nexus_loss_ua);
+
 /*	core_tpg_add_node_to_devs():
  *
  *
* Unmerged path include/target/target_core_fabric.h
