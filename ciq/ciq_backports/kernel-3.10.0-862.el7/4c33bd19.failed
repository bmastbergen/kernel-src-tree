IB/SA: Add support to query OPA path records

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
commit 4c33bd1926ccbfad362d22208c23cc045c5c82af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4c33bd19.failed

When the bit 26 of capmask2 field in OPA classport info
query is set, SA will query for OPA path records instead
of querying for IB path records. Note that OPA
path records can only be queried by kernel ULPs.
Userspace clients continue to query IB path records.

	Reviewed-by: Don Hiatt <don.hiatt@intel.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Dasaratharaman Chandramouli <dasaratharaman.chandramouli@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 4c33bd1926ccbfad362d22208c23cc045c5c82af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cma.c
#	drivers/infiniband/core/sa_query.c
#	drivers/infiniband/ulp/ipoib/ipoib_main.c
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/core/cma.c
index 2584e562abad,91b7a2fe5a55..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -2333,6 -2335,11 +2333,14 @@@ static int cma_query_ib_route(struct rd
  	struct sockaddr_ib *sib;
  
  	memset(&path_rec, 0, sizeof path_rec);
++<<<<<<< HEAD
++=======
+ 
+ 	if (rdma_cap_opa_ah(id_priv->id.device, id_priv->id.port_num))
+ 		path_rec.rec_type = SA_PATH_REC_TYPE_OPA;
+ 	else
+ 		path_rec.rec_type = SA_PATH_REC_TYPE_IB;
++>>>>>>> 4c33bd1926cc (IB/SA: Add support to query OPA path records)
  	rdma_addr_get_sgid(dev_addr, &path_rec.sgid);
  	rdma_addr_get_dgid(dev_addr, &path_rec.dgid);
  	path_rec.pkey = cpu_to_be16(ib_addr_get_pkey(dev_addr));
diff --cc drivers/infiniband/core/sa_query.c
index 17b24d8a34e1,e335b09c022e..000000000000
--- a/drivers/infiniband/core/sa_query.c
+++ b/drivers/infiniband/core/sa_query.c
@@@ -111,9 -129,10 +111,10 @@@ struct ib_sa_service_query 
  };
  
  struct ib_sa_path_query {
 -	void (*callback)(int, struct sa_path_rec *, void *);
 +	void (*callback)(int, struct ib_sa_path_rec *, void *);
  	void *context;
  	struct ib_sa_query sa_query;
+ 	struct sa_path_rec *conv_pr;
  };
  
  struct ib_sa_guidinfo_query {
@@@ -1215,15 -1520,33 +1404,43 @@@ static void ib_sa_path_rec_callback(str
  		container_of(sa_query, struct ib_sa_path_query, sa_query);
  
  	if (mad) {
 -		struct sa_path_rec rec;
 +		struct ib_sa_path_rec rec;
  
++<<<<<<< HEAD
 +		ib_unpack(path_rec_table, ARRAY_SIZE(path_rec_table),
 +			  mad->data, &rec);
 +		rec.net = NULL;
 +		rec.ifindex = 0;
 +		rec.gid_type = IB_GID_TYPE_IB;
 +		eth_zero_addr(rec.dmac);
 +		query->callback(status, &rec, query->context);
++=======
+ 		if (sa_query->flags & IB_SA_QUERY_OPA) {
+ 			ib_unpack(opa_path_rec_table,
+ 				  ARRAY_SIZE(opa_path_rec_table),
+ 				  mad->data, &rec);
+ 			rec.rec_type = SA_PATH_REC_TYPE_OPA;
+ 			query->callback(status, &rec, query->context);
+ 		} else {
+ 			ib_unpack(path_rec_table,
+ 				  ARRAY_SIZE(path_rec_table),
+ 				  mad->data, &rec);
+ 			rec.rec_type = SA_PATH_REC_TYPE_IB;
+ 			sa_path_set_ndev(&rec, NULL);
+ 			sa_path_set_ifindex(&rec, 0);
+ 			sa_path_set_dmac_zero(&rec);
+ 
+ 			if (query->conv_pr) {
+ 				struct sa_path_rec opa;
+ 
+ 				memset(&opa, 0, sizeof(struct sa_path_rec));
+ 				sa_convert_path_ib_to_opa(&opa, &rec);
+ 				query->callback(status, &opa, query->context);
+ 			} else {
+ 				query->callback(status, &rec, query->context);
+ 			}
+ 		}
++>>>>>>> 4c33bd1926cc (IB/SA: Add support to query OPA path records)
  	} else
  		query->callback(status, NULL, query->context);
  }
@@@ -1279,6 -1607,10 +1501,13 @@@ int ib_sa_path_rec_get(struct ib_sa_cli
  	if (!sa_dev)
  		return -ENODEV;
  
++<<<<<<< HEAD
++=======
+ 	if ((rec->rec_type != SA_PATH_REC_TYPE_IB) &&
+ 	    (rec->rec_type != SA_PATH_REC_TYPE_OPA))
+ 		return -EINVAL;
+ 
++>>>>>>> 4c33bd1926cc (IB/SA: Add support to query OPA path records)
  	port  = &sa_dev->port[port_num - sa_dev->start_port];
  	agent = port->agent;
  
diff --cc drivers/infiniband/ulp/ipoib/ipoib_main.c
index 91ce500f1b9b,2869d1adb1de..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@@ -901,6 -832,10 +901,13 @@@ static struct ipoib_path *path_rec_crea
  
  	INIT_LIST_HEAD(&path->neigh_list);
  
++<<<<<<< HEAD
++=======
+ 	if (rdma_cap_opa_ah(priv->ca, priv->port))
+ 		path->pathrec.rec_type = SA_PATH_REC_TYPE_OPA;
+ 	else
+ 		path->pathrec.rec_type = SA_PATH_REC_TYPE_IB;
++>>>>>>> 4c33bd1926cc (IB/SA: Add support to query OPA path records)
  	memcpy(path->pathrec.dgid.raw, gid, sizeof (union ib_gid));
  	path->pathrec.sgid	    = priv->local_gid;
  	path->pathrec.pkey	    = cpu_to_be16(priv->pkey);
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index a2ef4228ad02,def723a5df29..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -311,6 -312,11 +311,14 @@@ static int srp_new_cm_id(struct srp_rdm
  	if (ch->cm_id)
  		ib_destroy_cm_id(ch->cm_id);
  	ch->cm_id = new_cm_id;
++<<<<<<< HEAD
++=======
+ 	if (rdma_cap_opa_ah(target->srp_host->srp_dev->dev,
+ 			    target->srp_host->port))
+ 		ch->path.rec_type = SA_PATH_REC_TYPE_OPA;
+ 	else
+ 		ch->path.rec_type = SA_PATH_REC_TYPE_IB;
++>>>>>>> 4c33bd1926cc (IB/SA: Add support to query OPA path records)
  	ch->path.sgid = target->sgid;
  	ch->path.dgid = target->orig_dgid;
  	ch->path.pkey = target->pkey;
* Unmerged path drivers/infiniband/core/cma.c
* Unmerged path drivers/infiniband/core/sa_query.c
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_main.c
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
diff --git a/include/rdma/ib_mad.h b/include/rdma/ib_mad.h
index 3d5f5d6031ec..d67b11b72029 100644
--- a/include/rdma/ib_mad.h
+++ b/include/rdma/ib_mad.h
@@ -262,6 +262,8 @@ struct ib_class_port_info {
 	__be32			trap_qkey;
 };
 
+#define OPA_CLASS_PORT_INFO_PR_SUPPORT BIT(26)
+
 struct opa_class_port_info {
 	u8 base_version;
 	u8 class_version;
@@ -340,6 +342,17 @@ static inline void ib_set_cpi_capmask2(struct ib_class_port_info *cpi,
 			    IB_CLASS_PORT_INFO_RESP_TIME_FIELD_SIZE);
 }
 
+/**
+ * opa_get_cpi_capmask2 - Returns the capmask2 value from
+ * cap_mask2_resp_time in ib_class_port_info.
+ * @cpi: A struct opa_class_port_info mad.
+ */
+static inline u32 opa_get_cpi_capmask2(struct opa_class_port_info *cpi)
+{
+	return (be32_to_cpu(cpi->cap_mask2_resp_time) >>
+		IB_CLASS_PORT_INFO_RESP_TIME_FIELD_SIZE);
+}
+
 struct ib_mad_notice_attr {
 	u8 generic_type;
 	u8 prod_type_msb;
