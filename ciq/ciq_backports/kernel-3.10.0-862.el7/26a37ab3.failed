x86/mce: Fix copy/paste error in exception table entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mce: Fix copy/paste error in exception table entries (Jeff Moyer) [1437205]
Rebuild_FUZZ: 96.30%
commit-author Tony Luck <tony.luck@intel.com>
commit 26a37ab319a26d330bab298770d692bb9c852aff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/26a37ab3.failed

Back in commit:

  92b0729c34cab ("x86/mm, x86/mce: Add memcpy_mcsafe()")

... I made a copy/paste error setting up the exception table entries
and ended up with two for label .L_cache_w3 and none for .L_cache_w2.

This means that if we take a machine check on:

  .L_cache_w2: movq 2*8(%rsi), %r10

then we don't have an exception table entry for this instruction
and we can't recover.

Fix: s/3/2/

	Signed-off-by: Tony Luck <tony.luck@intel.com>
	Cc: <stable@vger.kernel.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: 92b0729c34cab ("x86/mm, x86/mce: Add memcpy_mcsafe()")
Link: http://lkml.kernel.org/r/1490046030-25862-1-git-send-email-tony.luck@intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 26a37ab319a26d330bab298770d692bb9c852aff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/lib/memcpy_64.S
diff --cc arch/x86/lib/memcpy_64.S
index 56313a326188,9a53a06e5a3e..000000000000
--- a/arch/x86/lib/memcpy_64.S
+++ b/arch/x86/lib/memcpy_64.S
@@@ -180,27 -180,122 +180,43 @@@ ENTRY(memcpy
  
  .Lend:
  	retq
 -ENDPROC(memcpy_orig)
 -
 -#ifndef CONFIG_UML
 -/*
 - * memcpy_mcsafe_unrolled - memory copy with machine check exception handling
 - * Note that we only catch machine checks when reading the source addresses.
 - * Writes to target are posted and don't generate machine checks.
 - */
 -ENTRY(memcpy_mcsafe_unrolled)
 -	cmpl $8, %edx
 -	/* Less than 8 bytes? Go to byte copy loop */
 -	jb .L_no_whole_words
 -
 -	/* Check for bad alignment of source */
 -	testl $7, %esi
 -	/* Already aligned */
 -	jz .L_8byte_aligned
 -
 -	/* Copy one byte at a time until source is 8-byte aligned */
 -	movl %esi, %ecx
 -	andl $7, %ecx
 -	subl $8, %ecx
 -	negl %ecx
 -	subl %ecx, %edx
 -.L_copy_leading_bytes:
 -	movb (%rsi), %al
 -	movb %al, (%rdi)
 -	incq %rsi
 -	incq %rdi
 -	decl %ecx
 -	jnz .L_copy_leading_bytes
 -
 -.L_8byte_aligned:
 -	/* Figure out how many whole cache lines (64-bytes) to copy */
 -	movl %edx, %ecx
 -	andl $63, %edx
 -	shrl $6, %ecx
 -	jz .L_no_whole_cache_lines
 -
 -	/* Loop copying whole cache lines */
 -.L_cache_w0: movq (%rsi), %r8
 -.L_cache_w1: movq 1*8(%rsi), %r9
 -.L_cache_w2: movq 2*8(%rsi), %r10
 -.L_cache_w3: movq 3*8(%rsi), %r11
 -	movq %r8, (%rdi)
 -	movq %r9, 1*8(%rdi)
 -	movq %r10, 2*8(%rdi)
 -	movq %r11, 3*8(%rdi)
 -.L_cache_w4: movq 4*8(%rsi), %r8
 -.L_cache_w5: movq 5*8(%rsi), %r9
 -.L_cache_w6: movq 6*8(%rsi), %r10
 -.L_cache_w7: movq 7*8(%rsi), %r11
 -	movq %r8, 4*8(%rdi)
 -	movq %r9, 5*8(%rdi)
 -	movq %r10, 6*8(%rdi)
 -	movq %r11, 7*8(%rdi)
 -	leaq 64(%rsi), %rsi
 -	leaq 64(%rdi), %rdi
 -	decl %ecx
 -	jnz .L_cache_w0
 -
 -	/* Are there any trailing 8-byte words? */
 -.L_no_whole_cache_lines:
 -	movl %edx, %ecx
 -	andl $7, %edx
 -	shrl $3, %ecx
 -	jz .L_no_whole_words
 -
 -	/* Copy trailing words */
 -.L_copy_trailing_words:
 -	movq (%rsi), %r8
 -	mov %r8, (%rdi)
 -	leaq 8(%rsi), %rsi
 -	leaq 8(%rdi), %rdi
 -	decl %ecx
 -	jnz .L_copy_trailing_words
 -
 -	/* Any trailing bytes? */
 -.L_no_whole_words:
 -	andl %edx, %edx
 -	jz .L_done_memcpy_trap
 -
 -	/* Copy trailing bytes */
 -	movl %edx, %ecx
 -.L_copy_trailing_bytes:
 -	movb (%rsi), %al
 -	movb %al, (%rdi)
 -	incq %rsi
 -	incq %rdi
 -	decl %ecx
 -	jnz .L_copy_trailing_bytes
 -
 -	/* Copy successful. Return zero */
 -.L_done_memcpy_trap:
 -	xorq %rax, %rax
 -	ret
 -ENDPROC(memcpy_mcsafe_unrolled)
 -EXPORT_SYMBOL_GPL(memcpy_mcsafe_unrolled)
 -
 -	.section .fixup, "ax"
 -	/* Return -EFAULT for any failure */
 -.L_memcpy_mcsafe_fail:
 -	mov	$-EFAULT, %rax
 -	ret
 +	CFI_ENDPROC
 +ENDPROC(memcpy)
 +ENDPROC(__memcpy)
  
 +	/*
 +	 * Some CPUs are adding enhanced REP MOVSB/STOSB feature
 +	 * If the feature is supported, memcpy_c_e() is the first choice.
 +	 * If enhanced rep movsb copy is not available, use fast string copy
 +	 * memcpy_c() when possible. This is faster and code is simpler than
 +	 * original memcpy().
 +	 * Otherwise, original memcpy() is used.
 +	 * In .altinstructions section, ERMS feature is placed after REG_GOOD
 +         * feature to implement the right patch order.
 +	 *
 +	 * Replace only beginning, memcpy is used to apply alternatives,
 +	 * so it is silly to overwrite itself with nops - reboot is the
 +	 * only outcome...
 +	 */
 +	.section .altinstructions, "a"
 +	altinstruction_entry memcpy,.Lmemcpy_c,X86_FEATURE_REP_GOOD,\
 +			     .Lmemcpy_e-.Lmemcpy_c,.Lmemcpy_e-.Lmemcpy_c
 +	altinstruction_entry memcpy,.Lmemcpy_c_e,X86_FEATURE_ERMS, \
 +			     .Lmemcpy_e_e-.Lmemcpy_c_e,.Lmemcpy_e_e-.Lmemcpy_c_e
  	.previous
++<<<<<<< HEAD
++=======
+ 
+ 	_ASM_EXTABLE_FAULT(.L_copy_leading_bytes, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w0, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w1, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w2, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w3, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w4, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w5, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w6, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_cache_w7, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_copy_trailing_words, .L_memcpy_mcsafe_fail)
+ 	_ASM_EXTABLE_FAULT(.L_copy_trailing_bytes, .L_memcpy_mcsafe_fail)
+ #endif
++>>>>>>> 26a37ab319a2 (x86/mce: Fix copy/paste error in exception table entries)
* Unmerged path arch/x86/lib/memcpy_64.S
