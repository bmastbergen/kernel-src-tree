powercap/rapl: add package reference per domain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [powercap] rapl: add package reference per domain (Xiaolong Wang) [1369918]
Rebuild_FUZZ: 89.41%
commit-author Jacob Pan <jacob.jun.pan@linux.intel.com>
commit 309557f558a6f276e364b08d916c0f644b5bd2e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/309557f5.failed

This patch adds to each rapl domain a reference of the package
it belongs to. At runtime, we can then avoid searching the package
data for each access. It simplifies the domain level operations
which depend on package level information.

	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 309557f558a6f276e364b08d916c0f644b5bd2e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/powercap/intel_rapl.c
diff --cc drivers/powercap/intel_rapl.c
index 518b7c58fd31,3413692c4dde..000000000000
--- a/drivers/powercap/intel_rapl.c
+++ b/drivers/powercap/intel_rapl.c
@@@ -806,30 -823,31 +792,48 @@@ static int rapl_write_data_raw(struct r
  			enum rapl_primitives prim,
  			unsigned long long value)
  {
 +	u64 msr_val;
 +	u32 msr;
  	struct rapl_primitive_info *rp = &rpi[prim];
  	int cpu;
 -	u64 bits;
 -	struct msrl_action ma;
 -	int ret;
  
- 	cpu = find_active_cpu_on_package(rd->package_id);
+ 	cpu = find_active_cpu_on_package(rd->rp->id);
  	if (cpu < 0)
  		return cpu;
 +	msr = rd->msrs[rp->id];
 +	if (rdmsrl_safe_on_cpu(cpu, msr, &msr_val)) {
 +		dev_dbg(&rd->power_zone.dev,
 +			"failed to read msr 0x%x on cpu %d\n", msr, cpu);
 +		return -EIO;
 +	}
 +	value = rapl_unit_xlate(rd, rd->package_id, rp->unit, value, 1);
 +	msr_val &= ~rp->mask;
 +	msr_val |= value << rp->shift;
 +	if (wrmsrl_safe_on_cpu(cpu, msr, msr_val)) {
 +		dev_dbg(&rd->power_zone.dev,
 +			"failed to write msr 0x%x on cpu %d\n", msr, cpu);
 +		return -EIO;
 +	}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	bits = rapl_unit_xlate(rd, rp->unit, value, 1);
+ 	bits |= bits << rp->shift;
+ 	memset(&ma, 0, sizeof(ma));
+ 
+ 	ma.msr_no = rd->msrs[rp->id];
+ 	ma.clear_mask = rp->mask;
+ 	ma.set_mask = bits;
+ 
+ 	ret = smp_call_function_single(cpu, msrl_update_func, &ma, 1);
+ 	if (ret)
+ 		WARN_ON_ONCE(ret);
+ 	else
+ 		ret = ma.err;
+ 
+ 	return ret;
++>>>>>>> 309557f558a6 (powercap/rapl: add package reference per domain)
  }
  
  /*
@@@ -905,42 -938,41 +909,32 @@@ static int rapl_check_unit_atom(struct 
   * to do by adding an atomic notifier.
   */
  
- static void package_power_limit_irq_save(int package_id)
+ static void package_power_limit_irq_save(struct rapl_package *rp)
  {
 +	u32 l, h = 0;
  	int cpu;
- 	struct rapl_package *rp;
- 
- 	rp = find_package_by_id(package_id);
- 	if (!rp)
- 		return;
  
  	if (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))
  		return;
  
- 	cpu = find_active_cpu_on_package(package_id);
+ 	cpu = find_active_cpu_on_package(rp->id);
  	if (cpu < 0)
  		return;
 -	if (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))
 -		return;
 -
 -	smp_call_function_single(cpu, power_limit_irq_save_cpu, rp, 1);
 -}
 -
 -static void power_limit_irq_restore_cpu(void *info)
 -{
 -	u32 l, h = 0;
 -	struct rapl_package *rp = (struct rapl_package *)info;
 -
 -	rdmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);
 -
 -	if (rp->power_limit_irq & PACKAGE_THERM_INT_PLN_ENABLE)
 -		l |= PACKAGE_THERM_INT_PLN_ENABLE;
 -	else
 -		l &= ~PACKAGE_THERM_INT_PLN_ENABLE;
 -
 -	wrmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);
 +	/* save the state of PLN irq mask bit before disabling it */
 +	rdmsr_safe_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);
 +	if (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED)) {
 +		rp->power_limit_irq = l & PACKAGE_THERM_INT_PLN_ENABLE;
 +		rp->power_limit_irq |= PACKAGE_PLN_INT_SAVED;
 +	}
 +	l &= ~PACKAGE_THERM_INT_PLN_ENABLE;
 +	wrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);
  }
  
  /* restore per package power limit interrupt enable state */
- static void package_power_limit_irq_restore(int package_id)
+ static void package_power_limit_irq_restore(struct rapl_package *rp)
  {
 +	u32 l, h;
  	int cpu;
- 	struct rapl_package *rp;
- 
- 	rp = find_package_by_id(package_id);
- 	if (!rp)
- 		return;
  
  	if (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))
  		return;
* Unmerged path drivers/powercap/intel_rapl.c
