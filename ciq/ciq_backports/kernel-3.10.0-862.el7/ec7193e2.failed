qla2xxx: Fix delayed response to command for loop mode/direct connect.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix delayed response to command for loop mode/direct connect (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 99.28%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit ec7193e26055112bc824929fd943035f9a30b06f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec7193e2.failed

Current driver wait for FW to be in the ready state before
processing in-coming commands. For Arbitrated Loop or
Point-to- Point (not switch), FW Ready state can take a while.
FW will transition to ready state after all Nports have been
logged in. In the mean time, certain initiators have completed
the login and starts IO. Driver needs to start processing all
queues if FW is already started.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit ec7193e26055112bc824929fd943035f9a30b06f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,ae119018dfaa..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2969,9 -3299,33 +2969,23 @@@ struct qlt_hw_data 
  	uint8_t saved_add_firmware_options[2];
  
  	uint8_t tgt_node_name[WWN_SIZE];
 -
 -	struct dentry *dfs_tgt_sess;
 -	struct dentry *dfs_tgt_port_database;
 -
 -	struct list_head q_full_list;
 -	uint32_t num_pend_cmds;
 -	uint32_t num_qfull_cmds_alloc;
 -	uint32_t num_qfull_cmds_dropped;
 -	spinlock_t q_full_lock;
 -	uint32_t leak_exchg_thresh_hold;
 -	spinlock_t sess_lock;
  	int rspq_vector_cpuid;
 -	spinlock_t atio_lock ____cacheline_aligned;
 -	struct btree_head32 host_map;
  };
  
++<<<<<<< HEAD
++=======
+ #define MAX_QFULL_CMDS_ALLOC	8192
+ #define Q_FULL_THRESH_HOLD_PERCENT 90
+ #define Q_FULL_THRESH_HOLD(ha) \
+ 	((ha->cur_fw_xcb_count/100) * Q_FULL_THRESH_HOLD_PERCENT)
+ 
+ #define LEAK_EXCHG_THRESH_HOLD_PERCENT 75	/* 75 percent */
+ 
+ #define QLA_EARLY_LINKUP(_ha) \
+ 	((_ha->flags.n2n_ae || _ha->flags.lip_ae) && \
+ 	 _ha->flags.fw_started && !_ha->flags.fw_init_done)
+ 
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  /*
   * Qlogic host adapter specific data structure.
  */
@@@ -3014,12 -3368,18 +3028,22 @@@ struct qla_hw_data 
  		uint32_t	isp82xx_no_md_cap:1;
  		uint32_t	host_shutting_down:1;
  		uint32_t	idc_compl_status:1;
 +
  		uint32_t        mr_reset_hdlr_active:1;
  		uint32_t        mr_intr_valid:1;
 -
 -		uint32_t        dport_enabled:1;
 +		uint32_t	dport_enabled:1;
  		uint32_t	fawwpn_enabled:1;
++<<<<<<< HEAD
 +		/* 35 bits */
++=======
+ 		uint32_t	exlogins_enabled:1;
+ 		uint32_t	exchoffld_enabled:1;
+ 
+ 		uint32_t	lip_ae:1;
+ 		uint32_t	n2n_ae:1;
+ 		uint32_t	fw_started:1;
+ 		uint32_t	fw_init_done:1;
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  	} flags;
  
  	/* This spinlock is used to protect "io transactions", you must
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,f9d2fe7b1ade..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -3093,6 -4001,28 +3094,31 @@@ qla2x00_configure_loop(scsi_qla_host_t 
  			atomic_set(&vha->loop_state, LOOP_READY);
  			ql_dbg(ql_dbg_disc, vha, 0x2069,
  			    "LOOP READY.\n");
++<<<<<<< HEAD
++=======
+ 			ha->flags.fw_init_done = 1;
+ 
+ 			/*
+ 			 * Process any ATIO queue entries that came in
+ 			 * while we weren't online.
+ 			 */
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				if (IS_QLA27XX(ha) || IS_QLA83XX(ha)) {
+ 					spin_lock_irqsave(&ha->tgt.atio_lock,
+ 					    flags);
+ 					qlt_24xx_process_atio_queue(vha, 0);
+ 					spin_unlock_irqrestore(
+ 					    &ha->tgt.atio_lock, flags);
+ 				} else {
+ 					spin_lock_irqsave(&ha->hardware_lock,
+ 					    flags);
+ 					qlt_24xx_process_atio_queue(vha, 1);
+ 					spin_unlock_irqrestore(
+ 					    &ha->hardware_lock, flags);
+ 				}
+ 			}
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  		}
  	}
  
@@@ -4602,6 -5493,13 +4628,16 @@@ qla2x00_abort_isp_cleanup(scsi_qla_host
  	if (!(IS_P3P_TYPE(ha)))
  		ha->isp_ops->reset_chip(vha);
  
++<<<<<<< HEAD
++=======
+ 	ha->flags.n2n_ae = 0;
+ 	ha->flags.lip_ae = 0;
+ 	ha->current_topology = 0;
+ 	ha->flags.fw_started = 0;
+ 	ha->flags.fw_init_done = 0;
+ 	ha->chip_reset++;
+ 
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  	atomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);
  	if (atomic_read(&vha->loop_state) != LOOP_DOWN) {
  		atomic_set(&vha->loop_state, LOOP_DOWN);
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 21eee93873e8,a113ab3592a7..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -3480,21 -3631,30 +3480,35 @@@ qla24xx_report_id_acquisition(scsi_qla_
  	if (rptid_entry->entry_status != 0)
  		return;
  
 -	id.b.domain = rptid_entry->port_id[2];
 -	id.b.area   = rptid_entry->port_id[1];
 -	id.b.al_pa  = rptid_entry->port_id[0];
 -	id.b.rsvd_1 = 0;
 -
  	if (rptid_entry->format == 0) {
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b7,
 +		    "Format 0 : Number of VPs setup %d, number of "
 +		    "VPs acquired %d.\n",
 +		    MSB(le16_to_cpu(rptid_entry->vp_count)),
 +		    LSB(le16_to_cpu(rptid_entry->vp_count)));
 +		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b8,
++=======
+ 		/* loop */
+ 		ql_dbg(ql_dbg_async, vha, 0x10b7,
+ 		    "Format 0 : Number of VPs setup %d, number of "
+ 		    "VPs acquired %d.\n", rptid_entry->vp_setup,
+ 		    rptid_entry->vp_acquired);
+ 		ql_dbg(ql_dbg_async, vha, 0x10b8,
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  		    "Primary port id %02x%02x%02x.\n",
  		    rptid_entry->port_id[2], rptid_entry->port_id[1],
  		    rptid_entry->port_id[0]);
 -
 -		qlt_update_host_map(vha, id);
 -
  	} else if (rptid_entry->format == 1) {
++<<<<<<< HEAD
 +		vp_idx = LSB(stat);
 +		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b9,
++=======
+ 		/* fabric */
+ 		ql_dbg(ql_dbg_async, vha, 0x10b9,
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  		    "Format 1: VP[%d] enabled - status %d - with "
 -		    "port id %02x%02x%02x.\n", rptid_entry->vp_idx,
 -			rptid_entry->vp_status,
 +		    "port id %02x%02x%02x.\n", vp_idx, MSB(stat),
  		    rptid_entry->port_id[2], rptid_entry->port_id[1],
  		    rptid_entry->port_id[0]);
  
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,0e03ca2ab3e5..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -333,9 -541,405 +333,408 @@@ void qlt_response_pkt_all_vps(struct sc
  
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * All qlt_plogi_ack_t operations are protected by hardware_lock
+  */
+ static int qla24xx_post_nack_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+ 	struct imm_ntfy_from_isp *ntfy, int type)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NACK);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.nack.fcport = fcport;
+ 	e->u.nack.type = type;
+ 	memcpy(e->u.nack.iocb, ntfy, sizeof(struct imm_ntfy_from_isp));
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla2x00_async_nack_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = (struct srb *)s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	unsigned long flags;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async done-%s res %x %8phC  type %d\n",
+ 		sp->name, res, sp->fcport->port_name, sp->type);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 	sp->fcport->chip_reset = vha->hw->chip_reset;
+ 
+ 	switch (sp->type) {
+ 	case SRB_NACK_PLOGI:
+ 		sp->fcport->login_gen++;
+ 		sp->fcport->fw_login_state = DSC_LS_PLOGI_COMP;
+ 		sp->fcport->logout_on_delete = 1;
+ 		sp->fcport->plogi_nack_done_deadline = jiffies + HZ;
+ 		break;
+ 
+ 	case SRB_NACK_PRLI:
+ 		sp->fcport->fw_login_state = DSC_LS_PRLI_COMP;
+ 		sp->fcport->deleted = 0;
+ 
+ 		if (!sp->fcport->login_succ &&
+ 		    !IS_SW_RESV_ADDR(sp->fcport->d_id)) {
+ 			sp->fcport->login_succ = 1;
+ 
+ 			vha->fcport_count++;
+ 
+ 			if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 			    !vha->hw->flags.gpsc_supported) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					"%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 					__func__, __LINE__,
+ 					sp->fcport->port_name,
+ 					vha->fcport_count);
+ 
+ 				qla24xx_post_upd_fcport_work(vha, sp->fcport);
+ 			} else {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					"%s %d %8phC post gpsc fcp_cnt %d\n",
+ 					__func__, __LINE__,
+ 					sp->fcport->port_name,
+ 					vha->fcport_count);
+ 
+ 				qla24xx_post_gpsc_work(vha, sp->fcport);
+ 			}
+ 		}
+ 		break;
+ 
+ 	case SRB_NACK_LOGO:
+ 		sp->fcport->login_gen++;
+ 		sp->fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		qlt_logo_completion_handler(sp->fcport, MBS_COMMAND_COMPLETE);
+ 		break;
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_notify_ack(scsi_qla_host_t *vha, fc_port_t *fcport,
+ 	struct imm_ntfy_from_isp *ntfy, int type)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	srb_t *sp;
+ 	char *c = NULL;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	switch (type) {
+ 	case SRB_NACK_PLOGI:
+ 		fcport->fw_login_state = DSC_LS_PLOGI_PEND;
+ 		c = "PLOGI";
+ 		break;
+ 	case SRB_NACK_PRLI:
+ 		fcport->fw_login_state = DSC_LS_PRLI_PEND;
+ 		fcport->deleted = 0;
+ 		c = "PRLI";
+ 		break;
+ 	case SRB_NACK_LOGO:
+ 		fcport->fw_login_state = DSC_LS_LOGO_PEND;
+ 		c = "LOGO";
+ 		break;
+ 	}
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = type;
+ 	sp->name = "nack";
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	sp->u.iocb_cmd.u.nack.ntfy = ntfy;
+ 
+ 	sp->done = qla2x00_async_nack_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hndl %x %s\n",
+ 		sp->name, fcport->port_name, sp->handle, c);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ void qla24xx_do_nack_work(struct scsi_qla_host *vha, struct qla_work_evt *e)
+ {
+ 	fc_port_t *t;
+ 	unsigned long flags;
+ 
+ 	switch (e->u.nack.type) {
+ 	case SRB_NACK_PRLI:
+ 		mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 		t = qlt_create_sess(vha, e->u.nack.fcport, 0);
+ 		mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 		if (t) {
+ 			ql_log(ql_log_info, vha, 0xffff,
+ 			    "%s create sess success %p", __func__, t);
+ 			spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 			/* create sess has an extra kref */
+ 			vha->hw->tgt.tgt_ops->put_sess(e->u.nack.fcport);
+ 			spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		}
+ 		break;
+ 	}
+ 	qla24xx_async_notify_ack(vha, e->u.nack.fcport,
+ 	    (struct imm_ntfy_from_isp*)e->u.nack.iocb, e->u.nack.type);
+ }
+ 
+ void qla24xx_delete_sess_fn(struct work_struct *work)
+ {
+ 	fc_port_t *fcport = container_of(work, struct fc_port, del_work);
+ 	struct qla_hw_data *ha = fcport->vha->hw;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 
+ 	if (fcport->se_sess) {
+ 		ha->tgt.tgt_ops->shutdown_sess(fcport);
+ 		ha->tgt.tgt_ops->put_sess(fcport);
+ 	} else {
+ 		qlt_unreg_sess(fcport);
+ 	}
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ /*
+  * Called from qla2x00_reg_remote_port()
+  */
+ void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct fc_port *sess = fcport;
+ 	unsigned long flags;
+ 
+ 	if (!vha->hw->tgt.tgt_ops)
+ 		return;
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	if (tgt->tgt_stop) {
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (!sess->se_sess) {
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 		mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 		sess = qlt_create_sess(vha, fcport, false);
+ 		mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	} else {
+ 		if (fcport->fw_login_state == DSC_LS_PRLI_COMP) {
+ 			spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 			return;
+ 		}
+ 
+ 		if (!kref_get_unless_zero(&sess->sess_kref)) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s: kref_get fail sess %8phC \n",
+ 			    __func__, sess->port_name);
+ 			spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 			return;
+ 		}
+ 
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04c,
+ 		    "qla_target(%u): %ssession for port %8phC "
+ 		    "(loop ID %d) reappeared\n", vha->vp_idx,
+ 		    sess->local ? "local " : "", sess->port_name, sess->loop_id);
+ 
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf007,
+ 		    "Reappeared sess %p\n", sess);
+ 
+ 		ha->tgt.tgt_ops->update_sess(sess, fcport->d_id,
+ 		    fcport->loop_id,
+ 		    (fcport->flags & FCF_CONF_COMP_SUPPORTED));
+ 	}
+ 
+ 	if (sess && sess->local) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04d,
+ 		    "qla_target(%u): local session for "
+ 		    "port %8phC (loop ID %d) became global\n", vha->vp_idx,
+ 		    fcport->port_name, sess->loop_id);
+ 		sess->local = 0;
+ 	}
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ /*
+  * This is a zero-base ref-counting solution, since hardware_lock
+  * guarantees that ref_count is not modified concurrently.
+  * Upon successful return content of iocb is undefined
+  */
+ static struct qlt_plogi_ack_t *
+ qlt_plogi_ack_find_add(struct scsi_qla_host *vha, port_id_t *id,
+ 		       struct imm_ntfy_from_isp *iocb)
+ {
+ 	struct qlt_plogi_ack_t *pla;
+ 
+ 	list_for_each_entry(pla, &vha->plogi_ack_list, list) {
+ 		if (pla->id.b24 == id->b24) {
+ 			qlt_send_term_imm_notif(vha, &pla->iocb, 1);
+ 			memcpy(&pla->iocb, iocb, sizeof(pla->iocb));
+ 			return pla;
+ 		}
+ 	}
+ 
+ 	pla = kmem_cache_zalloc(qla_tgt_plogi_cachep, GFP_ATOMIC);
+ 	if (!pla) {
+ 		ql_dbg(ql_dbg_async, vha, 0x5088,
+ 		       "qla_target(%d): Allocation of plogi_ack failed\n",
+ 		       vha->vp_idx);
+ 		return NULL;
+ 	}
+ 
+ 	memcpy(&pla->iocb, iocb, sizeof(pla->iocb));
+ 	pla->id = *id;
+ 	list_add_tail(&pla->list, &vha->plogi_ack_list);
+ 
+ 	return pla;
+ }
+ 
+ void qlt_plogi_ack_unref(struct scsi_qla_host *vha,
+     struct qlt_plogi_ack_t *pla)
+ {
+ 	struct imm_ntfy_from_isp *iocb = &pla->iocb;
+ 	port_id_t port_id;
+ 	uint16_t loop_id;
+ 	fc_port_t *fcport = pla->fcport;
+ 
+ 	BUG_ON(!pla->ref_count);
+ 	pla->ref_count--;
+ 
+ 	if (pla->ref_count)
+ 		return;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x5089,
+ 	    "Sending PLOGI ACK to wwn %8phC s_id %02x:%02x:%02x loop_id %#04x"
+ 	    " exch %#x ox_id %#x\n", iocb->u.isp24.port_name,
+ 	    iocb->u.isp24.port_id[2], iocb->u.isp24.port_id[1],
+ 	    iocb->u.isp24.port_id[0],
+ 	    le16_to_cpu(iocb->u.isp24.nport_handle),
+ 	    iocb->u.isp24.exchange_address, iocb->ox_id);
+ 
+ 	port_id.b.domain = iocb->u.isp24.port_id[2];
+ 	port_id.b.area   = iocb->u.isp24.port_id[1];
+ 	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
+ 	port_id.b.rsvd_1 = 0;
+ 
+ 	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
+ 
+ 	fcport->loop_id = loop_id;
+ 	fcport->d_id = port_id;
+ 	qla24xx_post_nack_work(vha, fcport, iocb, SRB_NACK_PLOGI);
+ 
+ 	list_for_each_entry(fcport, &vha->vp_fcports, list) {
+ 		if (fcport->plogi_link[QLT_PLOGI_LINK_SAME_WWN] == pla)
+ 			fcport->plogi_link[QLT_PLOGI_LINK_SAME_WWN] = NULL;
+ 		if (fcport->plogi_link[QLT_PLOGI_LINK_CONFLICT] == pla)
+ 			fcport->plogi_link[QLT_PLOGI_LINK_CONFLICT] = NULL;
+ 	}
+ 
+ 	list_del(&pla->list);
+ 	kmem_cache_free(qla_tgt_plogi_cachep, pla);
+ }
+ 
+ void
+ qlt_plogi_ack_link(struct scsi_qla_host *vha, struct qlt_plogi_ack_t *pla,
+     struct fc_port *sess, enum qlt_plogi_link_t link)
+ {
+ 	struct imm_ntfy_from_isp *iocb = &pla->iocb;
+ 	/* Inc ref_count first because link might already be pointing at pla */
+ 	pla->ref_count++;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf097,
+ 		"Linking sess %p [%d] wwn %8phC with PLOGI ACK to wwn %8phC"
+ 		" s_id %02x:%02x:%02x, ref=%d pla %p link %d\n",
+ 		sess, link, sess->port_name,
+ 		iocb->u.isp24.port_name, iocb->u.isp24.port_id[2],
+ 		iocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],
+ 		pla->ref_count, pla, link);
+ 
+ 	if (sess->plogi_link[link])
+ 		qlt_plogi_ack_unref(vha, sess->plogi_link[link]);
+ 
+ 	if (link == QLT_PLOGI_LINK_SAME_WWN)
+ 		pla->fcport = sess;
+ 
+ 	sess->plogi_link[link] = pla;
+ }
+ 
+ typedef struct {
+ 	/* These fields must be initialized by the caller */
+ 	port_id_t id;
+ 	/*
+ 	 * number of cmds dropped while we were waiting for
+ 	 * initiator to ack LOGO initialize to 1 if LOGO is
+ 	 * triggered by a command, otherwise, to 0
+ 	 */
+ 	int cmd_count;
+ 
+ 	/* These fields are used by callee */
+ 	struct list_head list;
+ } qlt_port_logo_t;
+ 
+ static void
+ qlt_send_first_logo(struct scsi_qla_host *vha, qlt_port_logo_t *logo)
+ {
+ 	qlt_port_logo_t *tmp;
+ 	int res;
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	list_for_each_entry(tmp, &vha->logo_list, list) {
+ 		if (tmp->id.b24 == logo->id.b24) {
+ 			tmp->cmd_count += logo->cmd_count;
+ 			mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 			return;
+ 		}
+ 	}
+ 
+ 	list_add_tail(&logo->list, &vha->logo_list);
+ 
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	res = qla24xx_els_dcmd_iocb(vha, ELS_DCMD_LOGO, logo->id);
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 	list_del(&logo->list);
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf098,
+ 	    "Finished LOGO to %02x:%02x:%02x, dropped %d cmds, res = %#x\n",
+ 	    logo->id.b.domain, logo->id.b.area, logo->id.b.al_pa,
+ 	    logo->cmd_count, res);
+ }
+ 
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  static void qlt_free_session_done(struct work_struct *work)
  {
 -	struct fc_port *sess = container_of(work, struct fc_port,
 +	struct qla_tgt_sess *sess = container_of(work, struct qla_tgt_sess,
  	    free_work);
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
@@@ -2046,6 -3052,26 +2448,29 @@@ int qlt_xmit_response(struct qla_tgt_cm
  
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  
++<<<<<<< HEAD
++=======
+ 	if (xmit_type == QLA_TGT_XMIT_STATUS)
+ 		vha->tgt_counters.core_qla_snd_status++;
+ 	else
+ 		vha->tgt_counters.core_qla_que_buf++;
+ 
+ 	if (!ha->flags.fw_started || cmd->reset_count != ha->chip_reset) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_PROCESSED;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg(ql_dbg_async, vha, 0xe101,
+ 			"RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, ha->chip_reset);
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 		return 0;
+ 	}
+ 
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  	/* Does F/W have an IOCBs for this request */
  	res = qlt_check_reserve_free_req(vha, full_req_cnt);
  	if (unlikely(res))
@@@ -2162,6 -3198,22 +2587,25 @@@ int qlt_rdy_to_xfer(struct qla_tgt_cmd 
  
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  
++<<<<<<< HEAD
++=======
+ 	if (!ha->flags.fw_started || (cmd->reset_count != ha->chip_reset) ||
+ 	    (cmd->sess && cmd->sess->deleted)) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_NEED_DATA;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg(ql_dbg_async, vha, 0xe102,
+ 			"RESET-XFR online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, ha->chip_reset);
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 		return 0;
+ 	}
+ 
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  	/* Does F/W have an IOCBs for this request */
  	res = qlt_check_reserve_free_req(vha, prm.req_cnt);
  	if (res != 0)
@@@ -2194,6 -3254,201 +2638,204 @@@ out_unlock_free_unmap
  EXPORT_SYMBOL(qlt_rdy_to_xfer);
  
  
++<<<<<<< HEAD
++=======
+ /*
+  * it is assumed either hardware_lock or qpair lock is held.
+  */
+ static void
+ qlt_handle_dif_error(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd,
+ 	struct ctio_crc_from_fw *sts)
+ {
+ 	uint8_t		*ap = &sts->actual_dif[0];
+ 	uint8_t		*ep = &sts->expected_dif[0];
+ 	uint64_t	lba = cmd->se_cmd.t_task_lba;
+ 	uint8_t scsi_status, sense_key, asc, ascq;
+ 	unsigned long flags;
+ 
+ 	cmd->trc_flags |= TRC_DIF_ERR;
+ 
+ 	cmd->a_guard   = be16_to_cpu(*(uint16_t *)(ap + 0));
+ 	cmd->a_app_tag = be16_to_cpu(*(uint16_t *)(ap + 2));
+ 	cmd->a_ref_tag = be32_to_cpu(*(uint32_t *)(ap + 4));
+ 
+ 	cmd->e_guard   = be16_to_cpu(*(uint16_t *)(ep + 0));
+ 	cmd->e_app_tag = be16_to_cpu(*(uint16_t *)(ep + 2));
+ 	cmd->e_ref_tag = be32_to_cpu(*(uint32_t *)(ep + 4));
+ 
+ 	ql_dbg(ql_dbg_tgt_dif, vha, 0xf075,
+ 	    "%s: aborted %d state %d\n", __func__, cmd->aborted, cmd->state);
+ 
+ 	scsi_status = sense_key = asc = ascq = 0;
+ 
+ 	/* check appl tag */
+ 	if (cmd->e_app_tag != cmd->a_app_tag) {
+ 		ql_dbg(ql_dbg_tgt_dif, vha, 0xffff,
+ 			"App Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] "
+ 			"Ref[%x|%x], App[%x|%x], "
+ 			"Guard [%x|%x] cmd=%p ox_id[%04x]",
+ 			cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
+ 			cmd->a_ref_tag, cmd->e_ref_tag,
+ 			cmd->a_app_tag, cmd->e_app_tag,
+ 			cmd->a_guard, cmd->e_guard,
+ 			cmd, cmd->atio.u.isp24.fcp_hdr.ox_id);
+ 
+ 		cmd->dif_err_code = DIF_ERR_APP;
+ 		scsi_status = SAM_STAT_CHECK_CONDITION;
+ 		sense_key = ABORTED_COMMAND;
+ 		asc = 0x10;
+ 		ascq = 0x2;
+ 	}
+ 
+ 	/* check ref tag */
+ 	if (cmd->e_ref_tag != cmd->a_ref_tag) {
+ 		ql_dbg(ql_dbg_tgt_dif, vha, 0xffff,
+ 			"Ref Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] "
+ 			"Ref[%x|%x], App[%x|%x], "
+ 			"Guard[%x|%x] cmd=%p ox_id[%04x] ",
+ 			cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
+ 			cmd->a_ref_tag, cmd->e_ref_tag,
+ 			cmd->a_app_tag, cmd->e_app_tag,
+ 			cmd->a_guard, cmd->e_guard,
+ 			cmd, cmd->atio.u.isp24.fcp_hdr.ox_id);
+ 
+ 		cmd->dif_err_code = DIF_ERR_REF;
+ 		scsi_status = SAM_STAT_CHECK_CONDITION;
+ 		sense_key = ABORTED_COMMAND;
+ 		asc = 0x10;
+ 		ascq = 0x3;
+ 		goto out;
+ 	}
+ 
+ 	/* check guard */
+ 	if (cmd->e_guard != cmd->a_guard) {
+ 		ql_dbg(ql_dbg_tgt_dif, vha, 0xffff,
+ 			"Guard ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] "
+ 			"Ref[%x|%x], App[%x|%x], "
+ 			"Guard [%x|%x] cmd=%p ox_id[%04x]",
+ 			cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
+ 			cmd->a_ref_tag, cmd->e_ref_tag,
+ 			cmd->a_app_tag, cmd->e_app_tag,
+ 			cmd->a_guard, cmd->e_guard,
+ 			cmd, cmd->atio.u.isp24.fcp_hdr.ox_id);
+ 		cmd->dif_err_code = DIF_ERR_GRD;
+ 		scsi_status = SAM_STAT_CHECK_CONDITION;
+ 		sense_key = ABORTED_COMMAND;
+ 		asc = 0x10;
+ 		ascq = 0x1;
+ 	}
+ out:
+ 	switch (cmd->state) {
+ 	case QLA_TGT_STATE_NEED_DATA:
+ 		/* handle_data will load DIF error code  */
+ 		cmd->state = QLA_TGT_STATE_DATA_IN;
+ 		vha->hw->tgt.tgt_ops->handle_data(cmd);
+ 		break;
+ 	default:
+ 		spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 		if (cmd->aborted) {
+ 			spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 			vha->hw->tgt.tgt_ops->free_cmd(cmd);
+ 			break;
+ 		}
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 		qlt_send_resp_ctio(vha, cmd, scsi_status, sense_key, asc, ascq);
+ 		/* assume scsi status gets out on the wire.
+ 		 * Will not wait for completion.
+ 		 */
+ 		vha->hw->tgt.tgt_ops->free_cmd(cmd);
+ 		break;
+ 	}
+ }
+ 
+ /* If hardware_lock held on entry, might drop it, then reaquire */
+ /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
+ static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *ntfy)
+ {
+ 	struct nack_to_isp *nack;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	request_t *pkt;
+ 	int ret = 0;
+ 
+ 	ql_dbg(ql_dbg_tgt_tmr, vha, 0xe01c,
+ 	    "Sending TERM ELS CTIO (ha=%p)\n", ha);
+ 
+ 	pkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);
+ 	if (pkt == NULL) {
+ 		ql_dbg(ql_dbg_tgt, vha, 0xe080,
+ 		    "qla_target(%d): %s failed: unable to allocate "
+ 		    "request packet\n", vha->vp_idx, __func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pkt->entry_type = NOTIFY_ACK_TYPE;
+ 	pkt->entry_count = 1;
+ 	pkt->handle = QLA_TGT_SKIP_HANDLE;
+ 
+ 	nack = (struct nack_to_isp *)pkt;
+ 	nack->ox_id = ntfy->ox_id;
+ 
+ 	nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
+ 	if (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {
+ 		nack->u.isp24.flags = ntfy->u.isp24.flags &
+ 			__constant_cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);
+ 	}
+ 
+ 	/* terminate */
+ 	nack->u.isp24.flags |=
+ 		__constant_cpu_to_le16(NOTIFY_ACK_FLAGS_TERMINATE);
+ 
+ 	nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
+ 	nack->u.isp24.status = ntfy->u.isp24.status;
+ 	nack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;
+ 	nack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;
+ 	nack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;
+ 	nack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;
+ 	nack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;
+ 	nack->u.isp24.vp_index = ntfy->u.isp24.vp_index;
+ 
+ 	qla2x00_start_iocbs(vha, vha->req);
+ 	return ret;
+ }
+ 
+ static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *imm, int ha_locked)
+ {
+ 	unsigned long flags = 0;
+ 	int rc;
+ 
+ 	if (qlt_issue_marker(vha, ha_locked) < 0)
+ 		return;
+ 
+ 	if (ha_locked) {
+ 		rc = __qlt_send_term_imm_notif(vha, imm);
+ 
+ #if 0	/* Todo  */
+ 		if (rc == -ENOMEM)
+ 			qlt_alloc_qfull_cmd(vha, imm, 0, 0);
+ #else
+ 		if (rc) {
+ 		}
+ #endif
+ 		goto done;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
+ 	rc = __qlt_send_term_imm_notif(vha, imm);
+ 
+ #if 0	/* Todo */
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, imm, 0, 0);
+ #endif
+ 
+ done:
+ 	if (!ha_locked)
+ 		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ }
+ 
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  /* If hardware_lock held on entry, might drop it, then reaquire */
  /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
  static int __qlt_send_term_exchange(struct scsi_qla_host *vha,
@@@ -2955,26 -4428,385 +3597,121 @@@ static int qlt_abort_task(struct scsi_q
  	return __qlt_abort_task(vha, iocb, sess);
  }
  
 -void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
 -{
 -	if (rc != MBS_COMMAND_COMPLETE) {
 -		ql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,
 -			"%s: se_sess %p / sess %p from"
 -			" port %8phC loop_id %#04x s_id %02x:%02x:%02x"
 -			" LOGO failed: %#x\n",
 -			__func__,
 -			fcport->se_sess,
 -			fcport,
 -			fcport->port_name, fcport->loop_id,
 -			fcport->d_id.b.domain, fcport->d_id.b.area,
 -			fcport->d_id.b.al_pa, rc);
 -	}
 -
 -	fcport->logout_completed = 1;
 -}
 -
  /*
 -* ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)
 -*
 -* Schedules sessions with matching port_id/loop_id but different wwn for
 -* deletion. Returns existing session with matching wwn if present.
 -* Null otherwise.
 -*/
 -struct fc_port *
 -qlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,
 -    port_id_t port_id, uint16_t loop_id, struct fc_port **conflict_sess)
 + * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
 + */
 +static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 +	struct imm_ntfy_from_isp *iocb)
  {
 -	struct fc_port *sess = NULL, *other_sess;
 -	uint64_t other_wwn;
 -
 -	*conflict_sess = NULL;
 +	struct qla_hw_data *ha = vha->hw;
 +	int res = 0;
  
 -	list_for_each_entry(other_sess, &vha->vp_fcports, list) {
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
 +	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
 +	    vha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);
  
 -		other_wwn = wwn_to_u64(other_sess->port_name);
 -
 -		if (wwn == other_wwn) {
 -			WARN_ON(sess);
 -			sess = other_sess;
 -			continue;
 -		}
 -
 -		/* find other sess with nport_id collision */
 -		if (port_id.b24 == other_sess->d_id.b24) {
 -			if (loop_id != other_sess->loop_id) {
 -				ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000c,
 -				    "Invalidating sess %p loop_id %d wwn %llx.\n",
 -				    other_sess, other_sess->loop_id, other_wwn);
 -
 -				/*
 -				 * logout_on_delete is set by default, but another
 -				 * session that has the same s_id/loop_id combo
 -				 * might have cleared it when requested this session
 -				 * deletion, so don't touch it
 -				 */
 -				qlt_schedule_sess_for_deletion(other_sess, true);
 -			} else {
 -				/*
 -				 * Another wwn used to have our s_id/loop_id
 -				 * kill the session, but don't free the loop_id
 -				 */
 -				ql_dbg(ql_dbg_tgt_tmr, vha, 0xffff,
 -				    "Invalidating sess %p loop_id %d wwn %llx.\n",
 -				    other_sess, other_sess->loop_id, other_wwn);
 -
 -
 -				other_sess->keep_nport_handle = 1;
 -				*conflict_sess = other_sess;
 -				qlt_schedule_sess_for_deletion(other_sess,
 -				    true);
 -			}
 -			continue;
 -		}
 -
 -		/* find other sess with nport handle collision */
 -		if ((loop_id == other_sess->loop_id) &&
 -			(loop_id != FC_NO_LOOP_ID)) {
 -			ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000d,
 -			       "Invalidating sess %p loop_id %d wwn %llx.\n",
 -			       other_sess, other_sess->loop_id, other_wwn);
 -
 -			/* Same loop_id but different s_id
 -			 * Ok to kill and logout */
 -			qlt_schedule_sess_for_deletion(other_sess, true);
 -		}
 -	}
 -
 -	return sess;
 -}
 -
 -/* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */
 -static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)
 -{
 -	struct qla_tgt_sess_op *op;
 -	struct qla_tgt_cmd *cmd;
 -	uint32_t key;
 -	int count = 0;
 -
 -	key = (((u32)s_id->b.domain << 16) |
 -	       ((u32)s_id->b.area   <<  8) |
 -	       ((u32)s_id->b.al_pa));
 -
 -	spin_lock(&vha->cmd_list_lock);
 -	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
 -		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
 -
 -		if (op_key == key) {
 -			op->aborted = true;
 -			count++;
 -		}
 -	}
 -
 -	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
 -		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
 -		if (op_key == key) {
 -			op->aborted = true;
 -			count++;
 -		}
 -	}
 -
 -	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
 -		uint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
 -		if (cmd_key == key) {
 -			cmd->aborted = 1;
 -			count++;
 -		}
 -	}
 -	spin_unlock(&vha->cmd_list_lock);
 -
 -	return count;
 -}
 -
 -/*
 - * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
 - */
 -static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 -	struct imm_ntfy_from_isp *iocb)
 -{
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 -	struct qla_hw_data *ha = vha->hw;
 -	struct fc_port *sess = NULL, *conflict_sess = NULL;
 -	uint64_t wwn;
 -	port_id_t port_id;
 -	uint16_t loop_id;
 -	uint16_t wd3_lo;
 -	int res = 0;
 -	struct qlt_plogi_ack_t *pla;
 -	unsigned long flags;
 -
 -	wwn = wwn_to_u64(iocb->u.isp24.port_name);
 -
 -	port_id.b.domain = iocb->u.isp24.port_id[2];
 -	port_id.b.area   = iocb->u.isp24.port_id[1];
 -	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
 -	port_id.b.rsvd_1 = 0;
 -
 -	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
 -
 -	ql_dbg(ql_dbg_disc, vha, 0xf026,
 -	    "qla_target(%d): Port ID: %02x:%02x:%02x ELS opcode: 0x%02x lid %d %8phC\n",
 -	    vha->vp_idx, iocb->u.isp24.port_id[2],
 -		iocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],
 -		   iocb->u.isp24.status_subcode, loop_id,
 -		iocb->u.isp24.port_name);
 -
 -	/* res = 1 means ack at the end of thread
 -	 * res = 0 means ack async/later.
 -	 */
 -	switch (iocb->u.isp24.status_subcode) {
 -	case ELS_PLOGI:
 -
 -		/* Mark all stale commands in qla_tgt_wq for deletion */
 -		abort_cmds_for_s_id(vha, &port_id);
 -
 -		if (wwn) {
 -			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 -			sess = qlt_find_sess_invalidate_other(vha, wwn,
 -				port_id, loop_id, &conflict_sess);
 -			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 -		}
 -
 -		if (IS_SW_RESV_ADDR(port_id)) {
 -			res = 1;
 -			break;
 -		}
 -
 -		pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
 -		if (!pla) {
 -			qlt_send_term_imm_notif(vha, iocb, 1);
 -			break;
 -		}
 -
 -		res = 0;
 -
 -		if (conflict_sess) {
 -			conflict_sess->login_gen++;
 -			qlt_plogi_ack_link(vha, pla, conflict_sess,
 -				QLT_PLOGI_LINK_CONFLICT);
 -		}
 -
 -		if (!sess) {
 -			pla->ref_count++;
 -			qla24xx_post_newsess_work(vha, &port_id,
 -				iocb->u.isp24.port_name, pla);
 -			res = 0;
 -			break;
 -		}
 -
 -		qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
 -		sess->fw_login_state = DSC_LS_PLOGI_PEND;
 -		sess->d_id = port_id;
 -		sess->login_gen++;
 -
 -		switch (sess->disc_state) {
 -		case DSC_DELETED:
 -			qlt_plogi_ack_unref(vha, pla);
 -			break;
 -
 -		default:
 -			/*
 -			 * Under normal circumstances we want to release nport handle
 -			 * during LOGO process to avoid nport handle leaks inside FW.
 -			 * The exception is when LOGO is done while another PLOGI with
 -			 * the same nport handle is waiting as might be the case here.
 -			 * Note: there is always a possibily of a race where session
 -			 * deletion has already started for other reasons (e.g. ACL
 -			 * removal) and now PLOGI arrives:
 -			 * 1. if PLOGI arrived in FW after nport handle has been freed,
 -			 *    FW must have assigned this PLOGI a new/same handle and we
 -			 *    can proceed ACK'ing it as usual when session deletion
 -			 *    completes.
 -			 * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
 -			 *    bit reached it, the handle has now been released. We'll
 -			 *    get an error when we ACK this PLOGI. Nothing will be sent
 -			 *    back to initiator. Initiator should eventually retry
 -			 *    PLOGI and situation will correct itself.
 -			 */
 -			sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
 -			   (sess->d_id.b24 == port_id.b24));
 -
 -			ql_dbg(ql_dbg_disc, vha, 0xffff,
 -				   "%s %d %8phC post del sess\n",
 -				   __func__, __LINE__, sess->port_name);
 -
 -
 -			qlt_schedule_sess_for_deletion_lock(sess);
 -			break;
 -		}
 -
 -		break;
 -
 -	case ELS_PRLI:
 -		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
 +	switch (iocb->u.isp24.status_subcode) {
 +	case ELS_PLOGI:
 +	case ELS_FLOGI:
 +	case ELS_PRLI:
++<<<<<<< HEAD
++=======
++		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
+ 
+ 		if (wwn) {
+ 			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
+ 			sess = qlt_find_sess_invalidate_other(vha, wwn, port_id,
+ 				loop_id, &conflict_sess);
+ 			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
+ 		}
+ 
+ 		if (conflict_sess) {
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09b,
+ 			    "PRLI with conflicting sess %p port %8phC\n",
+ 			    conflict_sess, conflict_sess->port_name);
+ 			qlt_send_term_imm_notif(vha, iocb, 1);
+ 			res = 0;
+ 			break;
+ 		}
+ 
+ 		if (sess != NULL) {
+ 			if (sess->fw_login_state != DSC_LS_PLOGI_PEND &&
+ 			    sess->fw_login_state != DSC_LS_PLOGI_COMP) {
+ 				/*
+ 				 * Impatient initiator sent PRLI before last
+ 				 * PLOGI could finish. Will force him to re-try,
+ 				 * while last one finishes.
+ 				 */
+ 				ql_log(ql_log_warn, sess->vha, 0xf095,
+ 				    "sess %p PRLI received, before plogi ack.\n",
+ 				    sess);
+ 				qlt_send_term_imm_notif(vha, iocb, 1);
+ 				res = 0;
+ 				break;
+ 			}
+ 
+ 			/*
+ 			 * This shouldn't happen under normal circumstances,
+ 			 * since we have deleted the old session during PLOGI
+ 			 */
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,
+ 			    "PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\n",
+ 			    sess->loop_id, sess, iocb->u.isp24.nport_handle);
+ 
+ 			sess->local = 0;
+ 			sess->loop_id = loop_id;
+ 			sess->d_id = port_id;
+ 			sess->fw_login_state = DSC_LS_PRLI_PEND;
+ 
+ 			if (wd3_lo & BIT_7)
+ 				sess->conf_compl_supported = 1;
+ 
+ 			if ((wd3_lo & BIT_4) == 0)
+ 				sess->port_type = FCT_INITIATOR;
+ 			else
+ 				sess->port_type = FCT_TARGET;
+ 		}
+ 		res = 1; /* send notify ack */
+ 
+ 		/* Make session global (not used in fabric mode) */
+ 		if (ha->current_topology != ISP_CFG_F) {
+ 			if (sess) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %d %8phC post nack\n",
+ 				    __func__, __LINE__, sess->port_name);
+ 				qla24xx_post_nack_work(vha, sess, iocb,
+ 					SRB_NACK_PRLI);
+ 				res = 0;
+ 			} else {
+ 				set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 				set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 				qla2xxx_wake_dpc(vha);
+ 			}
+ 		} else {
+ 			if (sess) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %d %8phC post nack\n",
+ 				    __func__, __LINE__, sess->port_name);
+ 				qla24xx_post_nack_work(vha, sess, iocb,
+ 					SRB_NACK_PRLI);
+ 				res = 0;
+ 			}
+ 		}
+ 		break;
+ 
+ 	case ELS_TPRLO:
+ 		if (le16_to_cpu(iocb->u.isp24.flags) &
+ 			NOTIFY24XX_FLAGS_GLOBAL_TPRLO) {
+ 			loop_id = 0xFFFF;
+ 			qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS);
+ 			res = 1;
+ 			break;
+ 		}
+ 		/* drop through */
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  	case ELS_LOGO:
  	case ELS_PRLO:
 -		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
 -		sess = qla2x00_find_fcport_by_loopid(vha, loop_id);
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -
 -		if (sess) {
 -			sess->login_gen++;
 -			sess->fw_login_state = DSC_LS_LOGO_PEND;
 -			sess->logo_ack_needed = 1;
 -			memcpy(sess->iocb, iocb, IOCB_SIZE);
 -		}
 -
  		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
 -
 -		ql_dbg(ql_dbg_disc, vha, 0xffff,
 -		    "%s: logo %llx res %d sess %p ",
 -		    __func__, wwn, res, sess);
 -		if (res == 0) {
 -			/*
 -			 * cmd went upper layer, look for qlt_xmit_tm_rsp()
 -			 * for LOGO_ACK & sess delete
 -			 */
 -			BUG_ON(!sess);
 -			res = 0;
 -		} else {
 -			/* cmd did not go to upper layer. */
 -			if (sess) {
 -				qlt_schedule_sess_for_deletion_lock(sess);
 -				res = 0;
 -			}
 -			/* else logo will be ack */
 -		}
  		break;
  	case ELS_PDISC:
  	case ELS_ADISC:
@@@ -3640,14 -5226,15 +4377,18 @@@ static void qlt_send_busy(struct scsi_q
  /* ha->hardware_lock supposed to be held on entry */
  /* called via callback from qla2xxx */
  static void qlt_24xx_atio_pkt(struct scsi_qla_host *vha,
 -	struct atio_from_isp *atio, uint8_t ha_locked)
 +	struct atio_from_isp *atio)
  {
  	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
  	int rc;
 -	unsigned long flags;
  
  	if (unlikely(tgt == NULL)) {
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf039,
++=======
+ 		ql_dbg(ql_dbg_tgt, vha, 0x3064,
++>>>>>>> ec7193e26055 (qla2xxx: Fix delayed response to command for loop mode/direct connect.)
  		    "ATIO pkt, but no tgt (ha %p)", ha);
  		return;
  	}
@@@ -4657,10 -6371,11 +5398,10 @@@ qlt_24xx_process_atio_queue(struct scsi
  	struct atio_from_isp *pkt;
  	int cnt, i;
  
- 	if (!vha->flags.online)
+ 	if (!ha->flags.fw_started)
  		return;
  
 -	while ((ha->tgt.atio_ring_ptr->signature != ATIO_PROCESSED) ||
 -	    fcpcmd_is_corrupted(ha->tgt.atio_ring_ptr)) {
 +	while (ha->tgt.atio_ring_ptr->signature != ATIO_PROCESSED) {
  		pkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;
  		cnt = pkt->u.raw.entry_count;
  
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index 5ffd1682f367..51f5d9f67040 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -675,6 +675,8 @@ skip_rio:
 		    "mbx7=%xh.\n", mb[1], mb[2], mb[3], mbx);
 
 		ha->isp_ops->fw_dump(vha, 1);
+		ha->flags.fw_init_done = 0;
+		ha->flags.fw_started = 0;
 
 		if (IS_FWI2_CAPABLE(ha)) {
 			if (mb[1] == 0 && mb[2] == 0) {
@@ -728,6 +730,9 @@ skip_rio:
 		break;
 
 	case MBA_LIP_OCCURRED:		/* Loop Initialization Procedure */
+		ha->flags.lip_ae = 1;
+		ha->flags.n2n_ae = 0;
+
 		ql_dbg(ql_dbg_async, vha, 0x5009,
 		    "LIP occurred (%x).\n", mb[1]);
 
@@ -764,6 +769,10 @@ skip_rio:
 		break;
 
 	case MBA_LOOP_DOWN:		/* Loop Down Event */
+		ha->flags.n2n_ae = 0;
+		ha->flags.lip_ae = 0;
+		ha->current_topology = 0;
+
 		mbx = (IS_QLA81XX(ha) || IS_QLA8031(ha))
 			? RD_REG_WORD(&reg24->mailbox4) : 0;
 		mbx = (IS_P3P_TYPE(ha)) ? RD_REG_WORD(&reg82->mailbox_out[4])
@@ -833,6 +842,9 @@ skip_rio:
 
 	/* case MBA_DCBX_COMPLETE: */
 	case MBA_POINT_TO_POINT:	/* Point-to-Point */
+		ha->flags.lip_ae = 0;
+		ha->flags.n2n_ae = 1;
+
 		if (IS_QLA2100(ha))
 			break;
 
@@ -2558,7 +2570,7 @@ void qla24xx_process_response_queue(struct scsi_qla_host *vha,
 	struct sts_entry_24xx *pkt;
 	struct qla_hw_data *ha = vha->hw;
 
-	if (!vha->flags.online)
+	if (!ha->flags.fw_started)
 		return;
 
 	if (rsp->msix && rsp->msix->cpuid != smp_processor_id()) {
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 1232bc4f04b9..18c5d27d0360 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -2588,6 +2588,20 @@ qla2xxx_scan_finished(struct Scsi_Host *shost, unsigned long time)
 	return atomic_read(&vha->loop_state) == LOOP_READY;
 }
 
+static void qla2x00_iocb_work_fn(struct work_struct *work)
+{
+	struct scsi_qla_host *vha = container_of(work,
+		struct scsi_qla_host, iocb_work);
+	int cnt = 0;
+
+	while (!list_empty(&vha->work_list)) {
+		qla2x00_do_work(vha);
+		cnt++;
+		if (cnt > 10)
+			break;
+	}
+}
+
 /*
  * PCI driver interface
  */
@@ -3107,6 +3121,7 @@ qla2x00_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	 */
 	qla2xxx_wake_dpc(base_vha);
 
+	INIT_WORK(&base_vha->iocb_work, qla2x00_iocb_work_fn);
 	INIT_WORK(&ha->board_disable, qla2x00_disable_board_on_pci_error);
 
 	if (IS_QLA8031(ha) || IS_MCTP_CAPABLE(ha)) {
@@ -4177,7 +4192,11 @@ qla2x00_post_work(struct scsi_qla_host *vha, struct qla_work_evt *e)
 	spin_lock_irqsave(&vha->work_lock, flags);
 	list_add_tail(&e->list, &vha->work_list);
 	spin_unlock_irqrestore(&vha->work_lock, flags);
-	qla2xxx_wake_dpc(vha);
+
+	if (QLA_EARLY_LINKUP(vha->hw))
+		schedule_work(&vha->iocb_work);
+	else
+		qla2xxx_wake_dpc(vha);
 
 	return QLA_SUCCESS;
 }
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
