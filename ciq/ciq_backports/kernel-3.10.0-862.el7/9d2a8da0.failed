radix-tree: replace preallocated node array with linked list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit 9d2a8da006fcbf2dea663c095f0a0088dfbbec15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9d2a8da0.failed

Currently we use per-cpu array to hold pointers to preallocated nodes.
Let's replace it with linked list.  On x86_64 it saves 256 bytes in
per-cpu ELF section which may translate into freeing up 2MB of memory for
NR_CPUS==8192.

[akpm@linux-foundation.org: fix comment, coding style]
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9d2a8da006fcbf2dea663c095f0a0088dfbbec15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index 1461d8f31808,f9ebe1c82060..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -194,12 -196,18 +195,13 @@@ radix_tree_node_alloc(struct radix_tree
  		 * succeed in getting a node here (and never reach
  		 * kmem_cache_alloc)
  		 */
 -		rtp = this_cpu_ptr(&radix_tree_preloads);
 +		rtp = &__get_cpu_var(radix_tree_preloads);
  		if (rtp->nr) {
- 			ret = rtp->nodes[rtp->nr - 1];
- 			rtp->nodes[rtp->nr - 1] = NULL;
+ 			ret = rtp->nodes;
+ 			rtp->nodes = ret->private_data;
+ 			ret->private_data = NULL;
  			rtp->nr--;
  		}
 -		/*
 -		 * Update the allocation stack trace as this is more useful
 -		 * for debugging.
 -		 */
 -		kmemleak_update_trace(ret);
  	}
  	if (ret == NULL)
  		ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);
@@@ -250,18 -258,21 +252,33 @@@ static int __radix_tree_preload(gfp_t g
  	int ret = -ENOMEM;
  
  	preempt_disable();
++<<<<<<< HEAD
 +	rtp = &__get_cpu_var(radix_tree_preloads);
 +	while (rtp->nr < ARRAY_SIZE(rtp->nodes)) {
++=======
+ 	rtp = this_cpu_ptr(&radix_tree_preloads);
+ 	while (rtp->nr < RADIX_TREE_PRELOAD_SIZE) {
++>>>>>>> 9d2a8da006fc (radix-tree: replace preallocated node array with linked list)
  		preempt_enable();
  		node = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);
  		if (node == NULL)
  			goto out;
  		preempt_disable();
++<<<<<<< HEAD
 +		rtp = &__get_cpu_var(radix_tree_preloads);
 +		if (rtp->nr < ARRAY_SIZE(rtp->nodes))
 +			rtp->nodes[rtp->nr++] = node;
 +		else
++=======
+ 		rtp = this_cpu_ptr(&radix_tree_preloads);
+ 		if (rtp->nr < RADIX_TREE_PRELOAD_SIZE) {
+ 			node->private_data = rtp->nodes;
+ 			rtp->nodes = node;
+ 			rtp->nr++;
+ 		} else {
++>>>>>>> 9d2a8da006fc (radix-tree: replace preallocated node array with linked list)
  			kmem_cache_free(radix_tree_node_cachep, node);
+ 		}
  	}
  	ret = 0;
  out:
* Unmerged path lib/radix-tree.c
