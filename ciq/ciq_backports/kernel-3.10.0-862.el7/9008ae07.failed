net/mlx5e: Minimize mlx5e_{open/close}_locked

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Minimize mlx5e_{open/close}_locked (Don Dutile) [1456659 1499362]
Rebuild_FUZZ: 95.35%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 9008ae074885ddaa2470f4c106245ddea4ae2a67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9008ae07.failed

mlx5e_redirect_rqts_to_{channels,drop} and mlx5e_{add,del}_sqs_fwd_rules
and Set real num tx/rx queues belong to
mlx5e_{activate,deactivate}_priv_channels, for that we move those functions
and minimize mlx5e_open/close flows.

This will be needed in downstream patches to replace old channels with new
ones without the need to call mlx5e_close/open.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
(cherry picked from commit 9008ae074885ddaa2470f4c106245ddea4ae2a67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index fc92406a15c4,a94f84ec2c1a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2195,6 -2477,62 +2195,65 @@@ static void mlx5e_netdev_set_tcs(struc
  		netdev_set_tc_queue(netdev, tc, nch, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_build_channels_tx_maps(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_channel *c;
+ 	struct mlx5e_txqsq *sq;
+ 	int i, tc;
+ 
+ 	for (i = 0; i < priv->channels.num; i++)
+ 		for (tc = 0; tc < priv->profile->max_tc; tc++)
+ 			priv->channel_tc2txq[i][tc] = i + tc * priv->channels.num;
+ 
+ 	for (i = 0; i < priv->channels.num; i++) {
+ 		c = priv->channels.c[i];
+ 		for (tc = 0; tc < c->num_tc; tc++) {
+ 			sq = &c->sq[tc];
+ 			priv->txq2sq[sq->txq_ix] = sq;
+ 		}
+ 	}
+ }
+ 
+ static void mlx5e_activate_priv_channels(struct mlx5e_priv *priv)
+ {
+ 	int num_txqs = priv->channels.num * priv->channels.params.num_tc;
+ 	struct net_device *netdev = priv->netdev;
+ 
+ 	mlx5e_netdev_set_tcs(netdev);
+ 	if (netdev->real_num_tx_queues != num_txqs)
+ 		netif_set_real_num_tx_queues(netdev, num_txqs);
+ 	if (netdev->real_num_rx_queues != priv->channels.num)
+ 		netif_set_real_num_rx_queues(netdev, priv->channels.num);
+ 
+ 	mlx5e_build_channels_tx_maps(priv);
+ 	mlx5e_activate_channels(&priv->channels);
+ 	netif_tx_start_all_queues(priv->netdev);
+ 
+ 	if (MLX5_CAP_GEN(priv->mdev, vport_group_manager))
+ 		mlx5e_add_sqs_fwd_rules(priv);
+ 
+ 	mlx5e_wait_channels_min_rx_wqes(&priv->channels);
+ 	mlx5e_redirect_rqts_to_channels(priv, &priv->channels);
+ }
+ 
+ static void mlx5e_deactivate_priv_channels(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_redirect_rqts_to_drop(priv);
+ 
+ 	if (MLX5_CAP_GEN(priv->mdev, vport_group_manager))
+ 		mlx5e_remove_sqs_fwd_rules(priv);
+ 
+ 	/* FIXME: This is a W/A only for tx timeout watch dog false alarm when
+ 	 * polling for inactive tx queues.
+ 	 */
+ 	netif_tx_stop_all_queues(priv->netdev);
+ 	netif_tx_disable(priv->netdev);
+ 	mlx5e_deactivate_channels(&priv->channels);
+ }
+ 
++>>>>>>> 9008ae074885 (net/mlx5e: Minimize mlx5e_{open/close}_locked)
  int mlx5e_open_locked(struct net_device *netdev)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
@@@ -2204,42 -2540,20 +2261,50 @@@
  
  	set_bit(MLX5E_STATE_OPENED, &priv->state);
  
++<<<<<<< HEAD
 +	mlx5e_netdev_set_tcs(netdev);
 +
 +	num_txqs = priv->params.num_channels * priv->params.num_tc;
 +	netif_set_real_num_tx_queues(netdev, num_txqs);
 +	netif_set_real_num_rx_queues(netdev, priv->params.num_channels);
 +
 +	err = mlx5e_open_channels(priv);
 +	if (err) {
 +		netdev_err(netdev, "%s: mlx5e_open_channels failed, %d\n",
 +			   __func__, err);
++=======
+ 	err = mlx5e_open_channels(priv, &priv->channels);
+ 	if (err)
++>>>>>>> 9008ae074885 (net/mlx5e: Minimize mlx5e_{open/close}_locked)
  		goto err_clear_state_opened_flag;
 +	}
  
++<<<<<<< HEAD
 +	err = mlx5e_refresh_tirs_self_loopback(priv->mdev, false);
 +	if (err) {
 +		netdev_err(netdev, "%s: mlx5e_refresh_tirs_self_loopback_enable failed, %d\n",
 +			   __func__, err);
 +		goto err_close_channels;
 +	}
 +
 +	mlx5e_redirect_rqts(priv);
++=======
+ 	mlx5e_refresh_tirs(priv, false);
+ 	mlx5e_activate_priv_channels(priv);
++>>>>>>> 9008ae074885 (net/mlx5e: Minimize mlx5e_{open/close}_locked)
  	mlx5e_update_carrier(priv);
  	mlx5e_timestamp_init(priv);
  
  	if (priv->profile->update_stats)
  		queue_delayed_work(priv->wq, &priv->update_stats_work, 0);
  
- 	if (MLX5_CAP_GEN(mdev, vport_group_manager)) {
- 		err = mlx5e_add_sqs_fwd_rules(priv);
- 		if (err)
- 			goto err_close_channels;
- 	}
  	return 0;
  
++<<<<<<< HEAD
 +err_close_channels:
 +	mlx5e_close_channels(priv);
++=======
++>>>>>>> 9008ae074885 (net/mlx5e: Minimize mlx5e_{open/close}_locked)
  err_clear_state_opened_flag:
  	clear_bit(MLX5E_STATE_OPENED, &priv->state);
  	return err;
@@@ -2270,13 -2583,10 +2334,15 @@@ int mlx5e_close_locked(struct net_devic
  
  	clear_bit(MLX5E_STATE_OPENED, &priv->state);
  
- 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
- 		mlx5e_remove_sqs_fwd_rules(priv);
- 
  	mlx5e_timestamp_cleanup(priv);
  	netif_carrier_off(priv->netdev);
++<<<<<<< HEAD
 +	mlx5e_redirect_rqts(priv);
 +	mlx5e_close_channels(priv);
++=======
+ 	mlx5e_deactivate_priv_channels(priv);
+ 	mlx5e_close_channels(&priv->channels);
++>>>>>>> 9008ae074885 (net/mlx5e: Minimize mlx5e_{open/close}_locked)
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d..5a4516f3ef4b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -187,12 +187,13 @@ int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv)
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 	struct mlx5_eswitch_rep *rep = priv->ppriv;
 	struct mlx5e_channel *c;
-	int n, tc, err, num_sqs = 0;
+	int n, tc, num_sqs = 0;
+	int err = -ENOMEM;
 	u16 *sqs;
 
 	sqs = kcalloc(priv->params.num_channels * priv->params.num_tc, sizeof(u16), GFP_KERNEL);
 	if (!sqs)
-		return -ENOMEM;
+		goto out;
 
 	for (n = 0; n < priv->params.num_channels; n++) {
 		c = priv->channel[n];
@@ -201,8 +202,11 @@ int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv)
 	}
 
 	err = mlx5_eswitch_sqs2vport_start(esw, rep, sqs, num_sqs);
-
 	kfree(sqs);
+
+out:
+	if (err)
+		netdev_warn(priv->netdev, "Failed to add SQs FWD rules %d\n", err);
 	return err;
 }
 
