xfs: rename flist/free_list to dfops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 2c3234d1ef53030ff6a79d55ba1fb291098467c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2c3234d1.failed

Mechanical change of flist/free_list to dfops, since they're now
deferred ops, not just a freeing list.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 2c3234d1ef53030ff6a79d55ba1fb291098467c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
#	fs/xfs/libxfs/xfs_attr_remote.c
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap.h
#	fs/xfs/libxfs/xfs_btree.h
#	fs/xfs/libxfs/xfs_da_btree.h
#	fs/xfs/libxfs/xfs_dir2.c
#	fs/xfs/libxfs/xfs_dir2.h
#	fs/xfs/libxfs/xfs_ialloc.c
#	fs/xfs/libxfs/xfs_ialloc.h
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_dquot.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_iomap.c
#	fs/xfs/xfs_rtalloc.c
#	fs/xfs/xfs_symlink.c
diff --cc fs/xfs/libxfs/xfs_attr.c
index e5d479c6c346,af1ecb19121e..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -201,7 -204,7 +201,11 @@@ xfs_attr_set
  {
  	struct xfs_mount	*mp = dp->i_mount;
  	struct xfs_da_args	args;
++<<<<<<< HEAD
 +	struct xfs_bmap_free	flist;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	struct xfs_trans_res	tres;
  	xfs_fsblock_t		firstblock;
  	int			rsvd = (flags & ATTR_ROOT) != 0;
@@@ -314,13 -317,13 +318,23 @@@
  		 * It won't fit in the shortform, transform to a leaf block.
  		 * GROT: another possible req'mt for a double-split btree op.
  		 */
++<<<<<<< HEAD
 +		xfs_bmap_init(args.flist, args.firstblock);
 +		error = xfs_attr_shortform_to_leaf(&args);
 +		if (!error)
 +			error = xfs_bmap_finish(&args.trans, args.flist, dp);
 +		if (error) {
 +			args.trans = NULL;
 +			xfs_bmap_cancel(&flist);
++=======
+ 		xfs_defer_init(args.dfops, args.firstblock);
+ 		error = xfs_attr_shortform_to_leaf(&args);
+ 		if (!error)
+ 			error = xfs_defer_finish(&args.trans, args.dfops, dp);
+ 		if (error) {
+ 			args.trans = NULL;
+ 			xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			goto out;
  		}
  
@@@ -380,7 -383,7 +394,11 @@@ xfs_attr_remove
  {
  	struct xfs_mount	*mp = dp->i_mount;
  	struct xfs_da_args	args;
++<<<<<<< HEAD
 +	struct xfs_bmap_free	flist;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		firstblock;
  	int			error;
  
@@@ -579,13 -585,13 +597,23 @@@ xfs_attr_leaf_addname(xfs_da_args_t *ar
  		 * Commit that transaction so that the node_addname() call
  		 * can manage its own transactions.
  		 */
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
 +		error = xfs_attr3_leaf_to_node(args);
 +		if (!error)
 +			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_bmap_cancel(args->flist);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
+ 		error = xfs_attr3_leaf_to_node(args);
+ 		if (!error)
+ 			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+ 		if (error) {
+ 			args->trans = NULL;
+ 			xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			return error;
  		}
  
@@@ -669,15 -675,15 +697,27 @@@
  		 * If the result is small enough, shrink it all into the inode.
  		 */
  		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
++<<<<<<< HEAD
 +			xfs_bmap_init(args->flist, args->firstblock);
 +			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 +			/* bp is gone due to xfs_da_shrink_inode */
 +			if (!error)
 +				error = xfs_bmap_finish(&args->trans,
 +							args->flist, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_bmap_cancel(args->flist);
++=======
+ 			xfs_defer_init(args->dfops, args->firstblock);
+ 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
+ 			/* bp is gone due to xfs_da_shrink_inode */
+ 			if (!error)
+ 				error = xfs_defer_finish(&args->trans,
+ 							args->dfops, dp);
+ 			if (error) {
+ 				args->trans = NULL;
+ 				xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  				return error;
  			}
  		}
@@@ -732,14 -738,14 +772,25 @@@ xfs_attr_leaf_removename(xfs_da_args_t 
  	 * If the result is small enough, shrink it all into the inode.
  	 */
  	if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
 +		error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 +		/* bp is gone due to xfs_da_shrink_inode */
 +		if (!error)
 +			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_bmap_cancel(args->flist);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
+ 		error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
+ 		/* bp is gone due to xfs_da_shrink_inode */
+ 		if (!error)
+ 			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+ 		if (error) {
+ 			args->trans = NULL;
+ 			xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			return error;
  		}
  	}
@@@ -858,14 -864,14 +909,25 @@@ restart
  			 */
  			xfs_da_state_free(state);
  			state = NULL;
++<<<<<<< HEAD
 +			xfs_bmap_init(args->flist, args->firstblock);
 +			error = xfs_attr3_leaf_to_node(args);
 +			if (!error)
 +				error = xfs_bmap_finish(&args->trans,
 +							args->flist, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_bmap_cancel(args->flist);
++=======
+ 			xfs_defer_init(args->dfops, args->firstblock);
+ 			error = xfs_attr3_leaf_to_node(args);
+ 			if (!error)
+ 				error = xfs_defer_finish(&args->trans,
+ 							args->dfops, dp);
+ 			if (error) {
+ 				args->trans = NULL;
+ 				xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  				goto out;
  			}
  
@@@ -886,13 -892,13 +948,23 @@@
  		 * in the index/blkno/rmtblkno/rmtblkcnt fields and
  		 * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.
  		 */
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
 +		error = xfs_da3_split(state);
 +		if (!error)
 +			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_bmap_cancel(args->flist);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
+ 		error = xfs_da3_split(state);
+ 		if (!error)
+ 			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+ 		if (error) {
+ 			args->trans = NULL;
+ 			xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			goto out;
  		}
  	} else {
@@@ -985,14 -991,14 +1057,25 @@@
  		 * Check to see if the tree needs to be collapsed.
  		 */
  		if (retval && (state->path.active > 1)) {
++<<<<<<< HEAD
 +			xfs_bmap_init(args->flist, args->firstblock);
 +			error = xfs_da3_join(state);
 +			if (!error)
 +				error = xfs_bmap_finish(&args->trans,
 +							args->flist, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_bmap_cancel(args->flist);
++=======
+ 			xfs_defer_init(args->dfops, args->firstblock);
+ 			error = xfs_da3_join(state);
+ 			if (!error)
+ 				error = xfs_defer_finish(&args->trans,
+ 							args->dfops, dp);
+ 			if (error) {
+ 				args->trans = NULL;
+ 				xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  				goto out;
  			}
  		}
@@@ -1108,13 -1114,13 +1191,23 @@@ xfs_attr_node_removename(xfs_da_args_t 
  	 * Check to see if the tree needs to be collapsed.
  	 */
  	if (retval && (state->path.active > 1)) {
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
 +		error = xfs_da3_join(state);
 +		if (!error)
 +			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_bmap_cancel(args->flist);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
+ 		error = xfs_da3_join(state);
+ 		if (!error)
+ 			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+ 		if (error) {
+ 			args->trans = NULL;
+ 			xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			goto out;
  		}
  		/*
@@@ -1141,15 -1147,15 +1234,27 @@@
  			goto out;
  
  		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
++<<<<<<< HEAD
 +			xfs_bmap_init(args->flist, args->firstblock);
 +			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 +			/* bp is gone due to xfs_da_shrink_inode */
 +			if (!error)
 +				error = xfs_bmap_finish(&args->trans,
 +							args->flist, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_bmap_cancel(args->flist);
++=======
+ 			xfs_defer_init(args->dfops, args->firstblock);
+ 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
+ 			/* bp is gone due to xfs_da_shrink_inode */
+ 			if (!error)
+ 				error = xfs_defer_finish(&args->trans,
+ 							args->dfops, dp);
+ 			if (error) {
+ 				args->trans = NULL;
+ 				xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  				goto out;
  			}
  		} else
diff --cc fs/xfs/libxfs/xfs_attr_remote.c
index 93a9ce1da359,d52f525f5b2d..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@@ -461,16 -461,16 +461,27 @@@ xfs_attr_rmtval_set
  		 * extent and then crash then the block may not contain the
  		 * correct metadata after log recovery occurs.
  		 */
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		nmap = 1;
  		error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,
  				  blkcnt, XFS_BMAPI_ATTRFORK, args->firstblock,
- 				  args->total, &map, &nmap, args->flist);
+ 				  args->total, &map, &nmap, args->dfops);
  		if (!error)
++<<<<<<< HEAD
 +			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_bmap_cancel(args->flist);
++=======
+ 			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+ 		if (error) {
+ 			args->trans = NULL;
+ 			xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			return error;
  		}
  
@@@ -504,7 -504,7 +515,11 @@@
  
  		ASSERT(blkcnt > 0);
  
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		nmap = 1;
  		error = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,
  				       blkcnt, &map, &nmap,
@@@ -604,16 -604,16 +619,28 @@@ xfs_attr_rmtval_remove
  	blkcnt = args->rmtblkcnt;
  	done = 0;
  	while (!done) {
++<<<<<<< HEAD
 +		xfs_bmap_init(args->flist, args->firstblock);
++=======
+ 		xfs_defer_init(args->dfops, args->firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		error = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,
  				    XFS_BMAPI_ATTRFORK, 1, args->firstblock,
- 				    args->flist, &done);
+ 				    args->dfops, &done);
  		if (!error)
++<<<<<<< HEAD
 +			error = xfs_bmap_finish(&args->trans, args->flist,
 +						args->dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_bmap_cancel(args->flist);
++=======
+ 			error = xfs_defer_finish(&args->trans, args->dfops,
+ 						args->dp);
+ 		if (error) {
+ 			args->trans = NULL;
+ 			xfs_defer_cancel(args->dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			return error;
  		}
  
diff --cc fs/xfs/libxfs/xfs_bmap.c
index e335b368ac04,540a6b7928af..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -572,7 -572,7 +572,11 @@@ xfs_bmap_validate_ret
  void
  xfs_bmap_add_free(
  	struct xfs_mount	*mp,		/* mount point structure */
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*flist,		/* list of extents */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* list of extents */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		bno,		/* fs block number of extent */
  	xfs_filblks_t		len)		/* length of extent */
  {
@@@ -594,9 -594,9 +598,15 @@@
  #endif
  	ASSERT(xfs_bmap_free_item_zone != NULL);
  	new = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);
++<<<<<<< HEAD
 +	new->xbfi_startblock = bno;
 +	new->xbfi_blockcount = (xfs_extlen_t)len;
 +	xfs_defer_add(flist, XFS_DEFER_OPS_TYPE_FREE, &new->xbfi_list);
++=======
+ 	new->xefi_startblock = bno;
+ 	new->xefi_blockcount = (xfs_extlen_t)len;
+ 	xfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_FREE, &new->xefi_list);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  }
  
  /*
@@@ -672,7 -672,7 +682,11 @@@ xfs_bmap_extents_to_btree
  	xfs_trans_t		*tp,		/* transaction pointer */
  	xfs_inode_t		*ip,		/* incore inode pointer */
  	xfs_fsblock_t		*firstblock,	/* first-block-allocated */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,		/* blocks freed in xaction */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* blocks freed in xaction */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_btree_cur_t		**curp,		/* cursor returned to caller */
  	int			wasdel,		/* converting a delayed alloc */
  	int			*logflagsp,	/* inode logging flags */
@@@ -940,7 -940,7 +954,11 @@@ xfs_bmap_add_attrfork_btree
  	xfs_trans_t		*tp,		/* transaction pointer */
  	xfs_inode_t		*ip,		/* incore inode pointer */
  	xfs_fsblock_t		*firstblock,	/* first block allocated */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,		/* blocks to free at commit */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* blocks to free at commit */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int			*flags)		/* inode logging flags */
  {
  	xfs_btree_cur_t		*cur;		/* btree cursor */
@@@ -983,7 -983,7 +1001,11 @@@ xfs_bmap_add_attrfork_extents
  	xfs_trans_t		*tp,		/* transaction pointer */
  	xfs_inode_t		*ip,		/* incore inode pointer */
  	xfs_fsblock_t		*firstblock,	/* first block allocated */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,		/* blocks to free at commit */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* blocks to free at commit */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int			*flags)		/* inode logging flags */
  {
  	xfs_btree_cur_t		*cur;		/* bmap btree cursor */
@@@ -1018,7 -1018,7 +1040,11 @@@ xfs_bmap_add_attrfork_local
  	xfs_trans_t		*tp,		/* transaction pointer */
  	xfs_inode_t		*ip,		/* incore inode pointer */
  	xfs_fsblock_t		*firstblock,	/* first block allocated */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,		/* blocks to free at commit */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* blocks to free at commit */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int			*flags)		/* inode logging flags */
  {
  	xfs_da_args_t		dargs;		/* args for dir/attr code */
@@@ -1059,7 -1059,7 +1085,11 @@@ xfs_bmap_add_attrfork
  	int			rsvd)		/* xact may use reserved blks */
  {
  	xfs_fsblock_t		firstblock;	/* 1st block/ag allocated */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		flist;		/* freed extent records */
++=======
+ 	struct xfs_defer_ops	dfops;		/* freed extent records */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_mount_t		*mp;		/* mount structure */
  	xfs_trans_t		*tp;		/* transaction pointer */
  	int			blks;		/* space reservation */
@@@ -1125,10 -1125,10 +1155,14 @@@
  	ip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);
  	ip->i_afp->if_flags = XFS_IFEXTENTS;
  	logflags = 0;
++<<<<<<< HEAD
 +	xfs_bmap_init(&flist, &firstblock);
++=======
+ 	xfs_defer_init(&dfops, &firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	switch (ip->i_d.di_format) {
  	case XFS_DINODE_FMT_LOCAL:
- 		error = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &flist,
+ 		error = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &dfops,
  			&logflags);
  		break;
  	case XFS_DINODE_FMT_EXTENTS:
@@@ -1165,7 -1165,7 +1199,11 @@@
  			xfs_log_sb(tp);
  	}
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &flist, NULL);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto bmap_cancel;
  	error = xfs_trans_commit(tp);
@@@ -1173,7 -1173,7 +1211,11 @@@
  	return error;
  
  bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&flist);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  trans_cancel:
  	xfs_trans_cancel(tp);
  	xfs_iunlock(ip, XFS_ILOCK_EXCL);
@@@ -2214,7 -2214,7 +2256,11 @@@ xfs_bmap_add_extent_unwritten_real
  	xfs_btree_cur_t		**curp,	/* if *curp is null, not a btree */
  	xfs_bmbt_irec_t		*new,	/* new data to add to file extents */
  	xfs_fsblock_t		*first,	/* pointer to firstblock variable */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,	/* list of extents to be freed */
++=======
+ 	struct xfs_defer_ops	*dfops,	/* list of extents to be freed */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int			*logflagsp) /* inode logging flags */
  {
  	xfs_btree_cur_t		*cur;	/* btree cursor */
@@@ -4448,7 -4447,7 +4494,11 @@@ xfs_bmapi_write
  	xfs_extlen_t		total,		/* total blocks needed */
  	struct xfs_bmbt_irec	*mval,		/* output: map values */
  	int			*nmap,		/* i/o: mval size/count */
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*flist)		/* i/o: list extents to free */
++=======
+ 	struct xfs_defer_ops	*dfops)		/* i/o: list extents to free */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  {
  	struct xfs_mount	*mp = ip->i_mount;
  	struct xfs_ifork	*ifp;
@@@ -4760,7 -4735,7 +4810,11 @@@ xfs_bmap_del_extent
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
  	xfs_extnum_t		*idx,	/* extent number to update/delete */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,	/* list of extents to be freed */
++=======
+ 	struct xfs_defer_ops	*dfops,	/* list of extents to be freed */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_btree_cur_t		*cur,	/* if null, not a btree */
  	xfs_bmbt_irec_t		*del,	/* data to remove from extents */
  	int			*logflagsp, /* inode logging flags */
@@@ -5089,7 -5064,7 +5143,11 @@@ xfs_bunmapi
  	xfs_extnum_t		nexts,		/* number of extents max */
  	xfs_fsblock_t		*firstblock,	/* first allocated block
  						   controls a.g. for allocs */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,		/* i/o: list extents to free */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* i/o: list extents to free */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int			*done)		/* set if not done yet */
  {
  	xfs_btree_cur_t		*cur;		/* bmap btree cursor */
@@@ -5659,12 -5675,13 +5717,17 @@@ in
  xfs_bmap_shift_extents(
  	struct xfs_trans	*tp,
  	struct xfs_inode	*ip,
 -	xfs_fileoff_t		*next_fsb,
 +	xfs_fileoff_t		start_fsb,
  	xfs_fileoff_t		offset_shift_fsb,
  	int			*done,
 -	xfs_fileoff_t		stop_fsb,
 +	xfs_fileoff_t		*next_fsb,
  	xfs_fsblock_t		*firstblock,
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*flist,
++=======
+ 	struct xfs_defer_ops	*dfops,
+ 	enum shift_direction	direction,
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int			num_exts)
  {
  	struct xfs_btree_cur		*cur = NULL;
@@@ -5761,3 -5821,185 +5824,188 @@@ del_cursor
  
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Splits an extent into two extents at split_fsb block such that it is
+  * the first block of the current_ext. @current_ext is a target extent
+  * to be split. @split_fsb is a block where the extents is split.
+  * If split_fsb lies in a hole or the first block of extents, just return 0.
+  */
+ STATIC int
+ xfs_bmap_split_extent_at(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		split_fsb,
+ 	xfs_fsblock_t		*firstfsb,
+ 	struct xfs_defer_ops	*dfops)
+ {
+ 	int				whichfork = XFS_DATA_FORK;
+ 	struct xfs_btree_cur		*cur = NULL;
+ 	struct xfs_bmbt_rec_host	*gotp;
+ 	struct xfs_bmbt_irec		got;
+ 	struct xfs_bmbt_irec		new; /* split extent */
+ 	struct xfs_mount		*mp = ip->i_mount;
+ 	struct xfs_ifork		*ifp;
+ 	xfs_fsblock_t			gotblkcnt; /* new block count for got */
+ 	xfs_extnum_t			current_ext;
+ 	int				error = 0;
+ 	int				logflags = 0;
+ 	int				i = 0;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT("xfs_bmap_split_extent_at",
+ 				 XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		/* Read in all the extents */
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * gotp can be null in 2 cases: 1) if there are no extents
+ 	 * or 2) split_fsb lies in a hole beyond which there are
+ 	 * no extents. Either way, we are done.
+ 	 */
+ 	gotp = xfs_iext_bno_to_ext(ifp, split_fsb, &current_ext);
+ 	if (!gotp)
+ 		return 0;
+ 
+ 	xfs_bmbt_get_all(gotp, &got);
+ 
+ 	/*
+ 	 * Check split_fsb lies in a hole or the start boundary offset
+ 	 * of the extent.
+ 	 */
+ 	if (got.br_startoff >= split_fsb)
+ 		return 0;
+ 
+ 	gotblkcnt = split_fsb - got.br_startoff;
+ 	new.br_startoff = split_fsb;
+ 	new.br_startblock = got.br_startblock + gotblkcnt;
+ 	new.br_blockcount = got.br_blockcount - gotblkcnt;
+ 	new.br_state = got.br_state;
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstfsb;
+ 		cur->bc_private.b.dfops = dfops;
+ 		cur->bc_private.b.flags = 0;
+ 		error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 				got.br_startblock,
+ 				got.br_blockcount,
+ 				&i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	xfs_bmbt_set_blockcount(gotp, gotblkcnt);
+ 	got.br_blockcount = gotblkcnt;
+ 
+ 	logflags = XFS_ILOG_CORE;
+ 	if (cur) {
+ 		error = xfs_bmbt_update(cur, got.br_startoff,
+ 				got.br_startblock,
+ 				got.br_blockcount,
+ 				got.br_state);
+ 		if (error)
+ 			goto del_cursor;
+ 	} else
+ 		logflags |= XFS_ILOG_DEXT;
+ 
+ 	/* Add new extent */
+ 	current_ext++;
+ 	xfs_iext_insert(ip, current_ext, 1, &new, 0);
+ 	XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			   XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
+ 
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, new.br_startoff,
+ 				new.br_startblock, new.br_blockcount,
+ 				&i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 0, del_cursor);
+ 		cur->bc_rec.b.br_state = new.br_state;
+ 
+ 		error = xfs_btree_insert(cur, &i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	/*
+ 	 * Convert to a btree if necessary.
+ 	 */
+ 	if (xfs_bmap_needs_btree(ip, whichfork)) {
+ 		int tmp_logflags; /* partial log flag return val */
+ 
+ 		ASSERT(cur == NULL);
+ 		error = xfs_bmap_extents_to_btree(tp, ip, firstfsb, dfops,
+ 				&cur, 0, &tmp_logflags, whichfork);
+ 		logflags |= tmp_logflags;
+ 	}
+ 
+ del_cursor:
+ 	if (cur) {
+ 		cur->bc_private.b.allocated = 0;
+ 		xfs_btree_del_cursor(cur,
+ 				error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 	}
+ 
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 	return error;
+ }
+ 
+ int
+ xfs_bmap_split_extent(
+ 	struct xfs_inode        *ip,
+ 	xfs_fileoff_t           split_fsb)
+ {
+ 	struct xfs_mount        *mp = ip->i_mount;
+ 	struct xfs_trans        *tp;
+ 	struct xfs_defer_ops    dfops;
+ 	xfs_fsblock_t           firstfsb;
+ 	int                     error;
+ 
+ 	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write,
+ 			XFS_DIOSTRAT_SPACE_RES(mp, 0), 0, 0, &tp);
+ 	if (error)
+ 		return error;
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	xfs_defer_init(&dfops, &firstfsb);
+ 
+ 	error = xfs_bmap_split_extent_at(tp, ip, split_fsb,
+ 			&firstfsb, &dfops);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
+ 	if (error)
+ 		goto out;
+ 
+ 	return xfs_trans_commit(tp);
+ 
+ out:
+ 	xfs_defer_cancel(&dfops);
+ 	xfs_trans_cancel(tp);
+ 	return error;
+ }
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
diff --cc fs/xfs/libxfs/xfs_bmap.h
index 2c95d141b01f,dc01bb85a6e8..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@@ -32,7 -32,7 +32,11 @@@ extern kmem_zone_t	*xfs_bmap_free_item_
   */
  struct xfs_bmalloca {
  	xfs_fsblock_t		*firstblock; /* i/o first block allocated */
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*flist;	/* bmap freelist */
++=======
+ 	struct xfs_defer_ops	*dfops;	/* bmap freelist */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	struct xfs_trans	*tp;	/* transaction pointer */
  	struct xfs_inode	*ip;	/* incore inode pointer */
  	struct xfs_bmbt_irec	prev;	/* extent before the new one */
@@@ -159,7 -164,7 +163,11 @@@ void	xfs_bmap_trace_exlist(struct xfs_i
  
  int	xfs_bmap_add_attrfork(struct xfs_inode *ip, int size, int rsvd);
  void	xfs_bmap_local_to_extents_empty(struct xfs_inode *ip, int whichfork);
++<<<<<<< HEAD
 +void	xfs_bmap_add_free(struct xfs_mount *mp, struct xfs_bmap_free *flist,
++=======
+ void	xfs_bmap_add_free(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			  xfs_fsblock_t bno, xfs_filblks_t len);
  void	xfs_bmap_compute_maxlevels(struct xfs_mount *mp, int whichfork);
  int	xfs_bmap_first_unused(struct xfs_trans *tp, struct xfs_inode *ip,
@@@ -181,17 -186,19 +189,33 @@@ int	xfs_bmapi_write(struct xfs_trans *t
  		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
  		xfs_fsblock_t *firstblock, xfs_extlen_t total,
  		struct xfs_bmbt_irec *mval, int *nmap,
++<<<<<<< HEAD
 +		struct xfs_bmap_free *flist);
 +int	xfs_bunmapi(struct xfs_trans *tp, struct xfs_inode *ip,
 +		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
 +		xfs_extnum_t nexts, xfs_fsblock_t *firstblock,
 +		struct xfs_bmap_free *flist, int *done);
++=======
+ 		struct xfs_defer_ops *dfops);
+ int	xfs_bunmapi(struct xfs_trans *tp, struct xfs_inode *ip,
+ 		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
+ 		xfs_extnum_t nexts, xfs_fsblock_t *firstblock,
+ 		struct xfs_defer_ops *dfops, int *done);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  int	xfs_check_nostate_extents(struct xfs_ifork *ifp, xfs_extnum_t idx,
  		xfs_extnum_t num);
  uint	xfs_default_attroffset(struct xfs_inode *ip);
  int	xfs_bmap_shift_extents(struct xfs_trans *tp, struct xfs_inode *ip,
++<<<<<<< HEAD
 +		xfs_fileoff_t start_fsb, xfs_fileoff_t offset_shift_fsb,
 +		int *done, xfs_fileoff_t *next_fsb, xfs_fsblock_t *firstblock,
 +		struct xfs_bmap_free *flist, int num_exts);
++=======
+ 		xfs_fileoff_t *next_fsb, xfs_fileoff_t offset_shift_fsb,
+ 		int *done, xfs_fileoff_t stop_fsb, xfs_fsblock_t *firstblock,
+ 		struct xfs_defer_ops *dfops, enum shift_direction direction,
+ 		int num_exts);
+ int	xfs_bmap_split_extent(struct xfs_inode *ip, xfs_fileoff_t split_offset);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  #endif	/* __XFS_BMAP_H__ */
diff --cc fs/xfs/libxfs/xfs_btree.h
index ec95b3a36250,154eefdcb730..000000000000
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@@ -229,11 -255,12 +229,19 @@@ typedef struct xfs_btree_cu
  	union {
  		struct {			/* needed for BNO, CNT, INO */
  			struct xfs_buf	*agbp;	/* agf/agi buffer pointer */
++<<<<<<< HEAD
++=======
+ 			struct xfs_defer_ops *dfops;	/* deferred updates */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			xfs_agnumber_t	agno;	/* ag number */
  		} a;
  		struct {			/* needed for BMAP */
  			struct xfs_inode *ip;	/* pointer to our inode */
++<<<<<<< HEAD
 +			struct xfs_bmap_free *flist;	/* list to free after */
++=======
+ 			struct xfs_defer_ops *dfops;	/* deferred updates */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			xfs_fsblock_t	firstblock;	/* 1st blk allocated */
  			int		allocated;	/* count of alloced */
  			short		forksize;	/* fork's inode space */
diff --cc fs/xfs/libxfs/xfs_da_btree.h
index 6e153e399a77,98c75cbe6ac2..000000000000
--- a/fs/xfs/libxfs/xfs_da_btree.h
+++ b/fs/xfs/libxfs/xfs_da_btree.h
@@@ -70,7 -70,7 +70,11 @@@ typedef struct xfs_da_args 
  	xfs_ino_t	inumber;	/* input/output inode number */
  	struct xfs_inode *dp;		/* directory inode to manipulate */
  	xfs_fsblock_t	*firstblock;	/* ptr to firstblock for bmap calls */
++<<<<<<< HEAD
 +	struct xfs_bmap_free *flist;	/* ptr to freelist for bmap_finish */
++=======
+ 	struct xfs_defer_ops *dfops;	/* ptr to freelist for bmap_finish */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	struct xfs_trans *trans;	/* current trans (changes over time) */
  	xfs_extlen_t	total;		/* total blocks needed, for 1st bmap */
  	int		whichfork;	/* data or attribute fork */
diff --cc fs/xfs/libxfs/xfs_dir2.c
index c9ec962a7902,20a96dd5af7e..000000000000
--- a/fs/xfs/libxfs/xfs_dir2.c
+++ b/fs/xfs/libxfs/xfs_dir2.c
@@@ -268,7 -260,7 +268,11 @@@ xfs_dir_createname
  	struct xfs_name		*name,
  	xfs_ino_t		inum,		/* new entry inode number */
  	xfs_fsblock_t		*first,		/* bmap's firstblock */
++<<<<<<< HEAD
 +	xfs_bmap_free_t		*flist,		/* bmap's freeblock list */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* bmap's freeblock list */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_extlen_t		total)		/* bmap's total block count */
  {
  	struct xfs_da_args	*args;
@@@ -445,7 -437,7 +449,11 @@@ xfs_dir_removename
  	struct xfs_name	*name,
  	xfs_ino_t	ino,
  	xfs_fsblock_t	*first,		/* bmap's firstblock */
++<<<<<<< HEAD
 +	xfs_bmap_free_t	*flist,		/* bmap's freeblock list */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* bmap's freeblock list */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_extlen_t	total)		/* bmap's total block count */
  {
  	struct xfs_da_args *args;
@@@ -507,7 -499,7 +515,11 @@@ xfs_dir_replace
  	struct xfs_name	*name,		/* name of entry to replace */
  	xfs_ino_t	inum,		/* new inode number */
  	xfs_fsblock_t	*first,		/* bmap's firstblock */
++<<<<<<< HEAD
 +	xfs_bmap_free_t	*flist,		/* bmap's freeblock list */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* bmap's freeblock list */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_extlen_t	total)		/* bmap's total block count */
  {
  	struct xfs_da_args *args;
diff --cc fs/xfs/libxfs/xfs_dir2.h
index df34134b1ca0,becc926c3e3d..000000000000
--- a/fs/xfs/libxfs/xfs_dir2.h
+++ b/fs/xfs/libxfs/xfs_dir2.h
@@@ -128,18 -129,18 +128,30 @@@ extern int xfs_dir_init(struct xfs_tran
  extern int xfs_dir_createname(struct xfs_trans *tp, struct xfs_inode *dp,
  				struct xfs_name *name, xfs_ino_t inum,
  				xfs_fsblock_t *first,
++<<<<<<< HEAD
 +				struct xfs_bmap_free *flist, xfs_extlen_t tot);
++=======
+ 				struct xfs_defer_ops *dfops, xfs_extlen_t tot);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  extern int xfs_dir_lookup(struct xfs_trans *tp, struct xfs_inode *dp,
  				struct xfs_name *name, xfs_ino_t *inum,
  				struct xfs_name *ci_name);
  extern int xfs_dir_removename(struct xfs_trans *tp, struct xfs_inode *dp,
  				struct xfs_name *name, xfs_ino_t ino,
  				xfs_fsblock_t *first,
++<<<<<<< HEAD
 +				struct xfs_bmap_free *flist, xfs_extlen_t tot);
 +extern int xfs_dir_replace(struct xfs_trans *tp, struct xfs_inode *dp,
 +				struct xfs_name *name, xfs_ino_t inum,
 +				xfs_fsblock_t *first,
 +				struct xfs_bmap_free *flist, xfs_extlen_t tot);
++=======
+ 				struct xfs_defer_ops *dfops, xfs_extlen_t tot);
+ extern int xfs_dir_replace(struct xfs_trans *tp, struct xfs_inode *dp,
+ 				struct xfs_name *name, xfs_ino_t inum,
+ 				xfs_fsblock_t *first,
+ 				struct xfs_defer_ops *dfops, xfs_extlen_t tot);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  extern int xfs_dir_canenter(struct xfs_trans *tp, struct xfs_inode *dp,
  				struct xfs_name *name);
  
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 231671e8371a,f0e1f713b0be..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -1817,7 -1818,7 +1817,11 @@@ xfs_difree_inode_chunk
  	struct xfs_mount		*mp,
  	xfs_agnumber_t			agno,
  	struct xfs_inobt_rec_incore	*rec,
++<<<<<<< HEAD
 +	struct xfs_bmap_free		*flist)
++=======
+ 	struct xfs_defer_ops		*dfops)
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  {
  	xfs_agblock_t	sagbno = XFS_AGINO_TO_AGBNO(mp, rec->ir_startino);
  	int		startidx, endidx;
@@@ -1889,7 -1890,7 +1893,11 @@@ xfs_difree_inobt
  	struct xfs_trans		*tp,
  	struct xfs_buf			*agbp,
  	xfs_agino_t			agino,
++<<<<<<< HEAD
 +	struct xfs_bmap_free		*flist,
++=======
+ 	struct xfs_defer_ops		*dfops,
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	struct xfs_icluster		*xic,
  	struct xfs_inobt_rec_incore	*orec)
  {
@@@ -2121,7 -2122,7 +2129,11 @@@ in
  xfs_difree(
  	struct xfs_trans	*tp,		/* transaction pointer */
  	xfs_ino_t		inode,		/* inode to be freed */
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*flist,		/* extents to free */
++=======
+ 	struct xfs_defer_ops	*dfops,		/* extents to free */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	struct xfs_icluster	*xic)	/* cluster info if deleted */
  {
  	/* REFERENCED */
diff --cc fs/xfs/libxfs/xfs_ialloc.h
index 6e450df2979b,0bb89669fc07..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.h
+++ b/fs/xfs/libxfs/xfs_ialloc.h
@@@ -95,7 -95,7 +95,11 @@@ int					/* error *
  xfs_difree(
  	struct xfs_trans *tp,		/* transaction pointer */
  	xfs_ino_t	inode,		/* inode to be freed */
++<<<<<<< HEAD
 +	struct xfs_bmap_free *flist,	/* extents to free */
++=======
+ 	struct xfs_defer_ops *dfops,	/* extents to free */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	struct xfs_icluster *ifree);	/* cluster info if deleted */
  
  /*
diff --cc fs/xfs/xfs_bmap_util.c
index e68409b0c53f,3bbe46bdbc6e..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -685,7 -685,7 +685,11 @@@ xfs_bmap_punch_delalloc_range
  		xfs_bmbt_irec_t	imap;
  		int		nimaps = 1;
  		xfs_fsblock_t	firstblock;
++<<<<<<< HEAD
 +		xfs_bmap_free_t flist;
++=======
+ 		struct xfs_defer_ops dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  		/*
  		 * Map the range first and check that it is a delalloc extent
@@@ -721,9 -721,9 +725,13 @@@
  		 * allocated or freed for a delalloc extent and hence we need
  		 * don't cancel or finish them after the xfs_bunmapi() call.
  		 */
++<<<<<<< HEAD
 +		xfs_bmap_init(&flist, &firstblock);
++=======
+ 		xfs_defer_init(&dfops, &firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		error = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,
- 					&flist, &done);
+ 					&dfops, &done);
  		if (error)
  			break;
  
@@@ -876,7 -884,7 +884,11 @@@ xfs_alloc_file_space
  	int			rt;
  	xfs_trans_t		*tp;
  	xfs_bmbt_irec_t		imaps[1], *imapp;
++<<<<<<< HEAD
 +	xfs_bmap_free_t		free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	uint			qblocks, resblks, resrtextents;
  	int			error;
  
@@@ -967,17 -975,17 +979,25 @@@
  
  		xfs_trans_ijoin(tp, ip, 0);
  
++<<<<<<< HEAD
 +		xfs_bmap_init(&free_list, &firstfsb);
++=======
+ 		xfs_defer_init(&dfops, &firstfsb);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		error = xfs_bmapi_write(tp, ip, startoffset_fsb,
  					allocatesize_fsb, alloc_type, &firstfsb,
- 					resblks, imapp, &nimaps, &free_list);
+ 					resblks, imapp, &nimaps, &dfops);
  		if (error)
  			goto error0;
  
  		/*
  		 * Complete the transaction
  		 */
++<<<<<<< HEAD
 +		error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 		error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		if (error)
  			goto error0;
  
@@@ -1000,7 -1008,7 +1020,11 @@@
  	return error;
  
  error0:	/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);
  
  error1:	/* Just cancel transaction */
@@@ -1009,99 -1017,120 +1033,206 @@@
  	return error;
  }
  
 -static int
 -xfs_unmap_extent(
 -	struct xfs_inode	*ip,
 -	xfs_fileoff_t		startoffset_fsb,
 -	xfs_filblks_t		len_fsb,
 -	int			*done)
 +/*
 + * Zero file bytes between startoff and endoff inclusive.
 + * The iolock is held exclusive and no blocks are buffered.
 + *
 + * This function is used by xfs_free_file_space() to zero
 + * partial blocks when the range to free is not block aligned.
 + * When unreserving space with boundaries that are not block
 + * aligned we round up the start and round down the end
 + * boundaries and then use this function to zero the parts of
 + * the blocks that got dropped during the rounding.
 + */
 +STATIC int
 +xfs_zero_remaining_bytes(
 +	xfs_inode_t		*ip,
 +	xfs_off_t		startoff,
 +	xfs_off_t		endoff)
  {
++<<<<<<< HEAD
 +	xfs_bmbt_irec_t		imap;
 +	xfs_fileoff_t		offset_fsb;
 +	xfs_off_t		lastoffset;
 +	xfs_off_t		offset;
 +	xfs_buf_t		*bp;
 +	xfs_mount_t		*mp = ip->i_mount;
 +	int			nimap;
 +	int			error = 0;
++=======
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	struct xfs_defer_ops	dfops;
+ 	xfs_fsblock_t		firstfsb;
+ 	uint			resblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);
+ 	int			error;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
 -	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0, 0, &tp);
 -	if (error) {
 -		ASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));
 -		return error;
 +	/*
 +	 * Avoid doing I/O beyond eof - it's not necessary
 +	 * since nothing can read beyond eof.  The space will
 +	 * be zeroed when the file is extended anyway.
 +	 */
 +	if (startoff >= XFS_ISIZE(ip))
 +		return 0;
 +
 +	if (endoff > XFS_ISIZE(ip))
 +		endoff = XFS_ISIZE(ip);
 +
 +	for (offset = startoff; offset <= endoff; offset = lastoffset + 1) {
 +		uint lock_mode;
 +
 +		offset_fsb = XFS_B_TO_FSBT(mp, offset);
 +		nimap = 1;
 +
 +		lock_mode = xfs_ilock_data_map_shared(ip);
 +		error = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);
 +		xfs_iunlock(ip, lock_mode);
 +
 +		if (error || nimap < 1)
 +			break;
 +		ASSERT(imap.br_blockcount >= 1);
 +		ASSERT(imap.br_startoff == offset_fsb);
 +		ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
 +
 +		if (imap.br_startblock == HOLESTARTBLOCK ||
 +		    imap.br_state == XFS_EXT_UNWRITTEN) {
 +			/* skip the entire extent */
 +			lastoffset = XFS_FSB_TO_B(mp, imap.br_startoff +
 +						      imap.br_blockcount) - 1;
 +			continue;
 +		}
 +
 +		lastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;
 +		if (lastoffset > endoff)
 +			lastoffset = endoff;
 +
 +		/* DAX can just zero the backing device directly */
 +		if (IS_DAX(VFS_I(ip))) {
 +			error = dax_zero_page_range(VFS_I(ip), offset,
 +						    lastoffset - offset + 1,
 +						    xfs_get_blocks_direct);
 +			if (error)
 +				return error;
 +			continue;
 +		}
 +
 +		error = xfs_buf_read_uncached(XFS_IS_REALTIME_INODE(ip) ?
 +				mp->m_rtdev_targp : mp->m_ddev_targp,
 +				xfs_fsb_to_db(ip, imap.br_startblock),
 +				BTOBB(mp->m_sb.sb_blocksize),
 +				0, &bp, NULL);
 +		if (error)
 +			return error;
 +
 +		memset(bp->b_addr +
 +				(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),
 +		       0, lastoffset - offset + 1);
 +
 +		error = xfs_bwrite(bp);
 +		xfs_buf_relse(bp);
 +		if (error)
 +			return error;
  	}
++<<<<<<< HEAD
 +	return error;
++=======
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	error = xfs_trans_reserve_quota(tp, mp, ip->i_udquot, ip->i_gdquot,
+ 			ip->i_pdquot, resblks, 0, XFS_QMOPT_RES_REGBLKS);
+ 	if (error)
+ 		goto out_trans_cancel;
+ 
+ 	xfs_trans_ijoin(tp, ip, 0);
+ 
+ 	xfs_defer_init(&dfops, &firstfsb);
+ 	error = xfs_bunmapi(tp, ip, startoffset_fsb, len_fsb, 0, 2, &firstfsb,
+ 			&dfops, done);
+ 	if (error)
+ 		goto out_bmap_cancel;
+ 
+ 	error = xfs_defer_finish(&tp, &dfops, ip);
+ 	if (error)
+ 		goto out_bmap_cancel;
+ 
+ 	error = xfs_trans_commit(tp);
+ out_unlock:
+ 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
+ 	return error;
+ 
+ out_bmap_cancel:
+ 	xfs_defer_cancel(&dfops);
+ out_trans_cancel:
+ 	xfs_trans_cancel(tp);
+ 	goto out_unlock;
+ }
+ 
+ static int
+ xfs_adjust_extent_unmap_boundaries(
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		*startoffset_fsb,
+ 	xfs_fileoff_t		*endoffset_fsb)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_bmbt_irec	imap;
+ 	int			nimap, error;
+ 	xfs_extlen_t		mod = 0;
+ 
+ 	nimap = 1;
+ 	error = xfs_bmapi_read(ip, *startoffset_fsb, 1, &imap, &nimap, 0);
+ 	if (error)
+ 		return error;
+ 
+ 	if (nimap && imap.br_startblock != HOLESTARTBLOCK) {
+ 		xfs_daddr_t	block;
+ 
+ 		ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
+ 		block = imap.br_startblock;
+ 		mod = do_div(block, mp->m_sb.sb_rextsize);
+ 		if (mod)
+ 			*startoffset_fsb += mp->m_sb.sb_rextsize - mod;
+ 	}
+ 
+ 	nimap = 1;
+ 	error = xfs_bmapi_read(ip, *endoffset_fsb - 1, 1, &imap, &nimap, 0);
+ 	if (error)
+ 		return error;
+ 
+ 	if (nimap && imap.br_startblock != HOLESTARTBLOCK) {
+ 		ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
+ 		mod++;
+ 		if (mod && mod != mp->m_sb.sb_rextsize)
+ 			*endoffset_fsb -= mod;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ xfs_flush_unmap_range(
+ 	struct xfs_inode	*ip,
+ 	xfs_off_t		offset,
+ 	xfs_off_t		len)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct inode		*inode = VFS_I(ip);
+ 	xfs_off_t		rounding, start, end;
+ 	int			error;
+ 
+ 	/* wait for the completion of any pending DIOs */
+ 	inode_dio_wait(inode);
+ 
+ 	rounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_SIZE);
+ 	start = round_down(offset, rounding);
+ 	end = round_up(offset + len, rounding) - 1;
+ 
+ 	error = filemap_write_and_wait_range(inode->i_mapping, start, end);
+ 	if (error)
+ 		return error;
+ 	truncate_pagecache_range(inode, start, end);
+ 	return 0;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  }
  
  int
@@@ -1328,9 -1250,9 +1459,13 @@@ xfs_collapse_file_space
  	struct xfs_mount	*mp = ip->i_mount;
  	struct xfs_trans	*tp;
  	int			error;
++<<<<<<< HEAD
 +	struct xfs_bmap_free	free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		first_block;
 -	xfs_fileoff_t		stop_fsb;
 +	xfs_fileoff_t		start_fsb;
  	xfs_fileoff_t		next_fsb;
  	xfs_fileoff_t		shift_fsb;
  
@@@ -1391,22 -1326,21 +1526,36 @@@
  		if (error)
  			goto out_trans_cancel;
  
 -		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 +		xfs_trans_ijoin(tp, ip, 0);
  
++<<<<<<< HEAD
 +		xfs_bmap_init(&free_list, &first_block);
++=======
+ 		xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  		/*
  		 * We are using the write transaction in which max 2 bmbt
  		 * updates are allowed
  		 */
++<<<<<<< HEAD
 +		start_fsb = next_fsb;
 +		error = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,
 +				&done, &next_fsb, &first_block, &free_list,
 +				XFS_BMAP_MAX_SHIFT_EXTENTS);
 +		if (error)
 +			goto out_bmap_cancel;
 +
 +		error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 		error = xfs_bmap_shift_extents(tp, ip, &next_fsb, shift_fsb,
+ 				&done, stop_fsb, &first_block, &dfops,
+ 				direction, XFS_BMAP_MAX_SHIFT_EXTENTS);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 
+ 		error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		if (error)
  			goto out_bmap_cancel;
  
@@@ -1417,10 -1350,9 +1566,14 @@@
  	return error;
  
  out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  out_trans_cancel:
  	xfs_trans_cancel(tp);
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	return error;
  }
  
diff --cc fs/xfs/xfs_dquot.c
index 51b0377c9efb,7a30b8f11db7..000000000000
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@@ -308,7 -308,7 +308,11 @@@ xfs_qm_dqalloc
  	xfs_buf_t	**O_bpp)
  {
  	xfs_fsblock_t	firstblock;
++<<<<<<< HEAD
 +	xfs_bmap_free_t flist;
++=======
+ 	struct xfs_defer_ops dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_bmbt_irec_t map;
  	int		nmaps, error;
  	xfs_buf_t	*bp;
@@@ -321,7 -321,7 +325,11 @@@
  	/*
  	 * Initialize the bmap freelist prior to calling bmapi code.
  	 */
++<<<<<<< HEAD
 +	xfs_bmap_init(&flist, &firstblock);
++=======
+ 	xfs_defer_init(&dfops, &firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_ilock(quotip, XFS_ILOCK_EXCL);
  	/*
  	 * Return if this type of quotas is turned off while we didn't
@@@ -383,7 -383,7 +391,11 @@@
  
  	xfs_trans_bhold(tp, bp);
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(tpp, &flist, NULL);
++=======
+ 	error = xfs_defer_finish(tpp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto error1;
  
@@@ -399,7 -399,7 +411,11 @@@
  	return 0;
  
  error1:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&flist);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  error0:
  	xfs_iunlock(quotip, XFS_ILOCK_EXCL);
  
diff --cc fs/xfs/xfs_inode.c
index b349df258043,e08eaea6327b..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -1131,7 -1123,7 +1131,11 @@@ xfs_create
  	struct xfs_inode	*ip = NULL;
  	struct xfs_trans	*tp = NULL;
  	int			error;
++<<<<<<< HEAD
 +	xfs_bmap_free_t		free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		first_block;
  	bool                    unlock_dp_on_error = false;
  	prid_t			prid;
@@@ -1192,7 -1183,7 +1196,11 @@@
  		      XFS_IOLOCK_PARENT | XFS_ILOCK_PARENT);
  	unlock_dp_on_error = true;
  
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  	/*
  	 * Reserve disk quota and the inode.
@@@ -1263,7 -1254,7 +1271,11 @@@
  	 */
  	xfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto out_bmap_cancel;
  
@@@ -1279,7 -1270,7 +1291,11 @@@
  	return 0;
  
   out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
   out_trans_cancel:
  	xfs_trans_cancel(tp);
   out_release_inode:
@@@ -1411,7 -1402,7 +1427,11 @@@ xfs_link
  	xfs_mount_t		*mp = tdp->i_mount;
  	xfs_trans_t		*tp;
  	int			error;
++<<<<<<< HEAD
 +	xfs_bmap_free_t         free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t           first_block;
  	int			resblks;
  
@@@ -1462,7 -1453,7 +1482,11 @@@
  			goto error_return;
  	}
  
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  	/*
  	 * Handle initial link state of O_TMPFILE inode
@@@ -1492,9 -1483,9 +1516,15 @@@
  	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
  		xfs_trans_set_sync(tp);
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, NULL);
 +	if (error) {
 +		xfs_bmap_cancel(&free_list);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
+ 	if (error) {
+ 		xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		goto error_return;
  	}
  
@@@ -1536,7 -1527,7 +1566,11 @@@ xfs_itruncate_extents
  {
  	struct xfs_mount	*mp = ip->i_mount;
  	struct xfs_trans	*tp = *tpp;
++<<<<<<< HEAD
 +	xfs_bmap_free_t		free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		first_block;
  	xfs_fileoff_t		first_unmap_block;
  	xfs_fileoff_t		last_block;
@@@ -1572,7 -1563,7 +1606,11 @@@
  	ASSERT(first_unmap_block < last_block);
  	unmap_len = last_block - first_unmap_block + 1;
  	while (!done) {
++<<<<<<< HEAD
 +		xfs_bmap_init(&free_list, &first_block);
++=======
+ 		xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		error = xfs_bunmapi(tp, ip,
  				    first_unmap_block, unmap_len,
  				    xfs_bmapi_aflag(whichfork),
@@@ -1586,7 -1577,7 +1624,11 @@@
  		 * Duplicate the transaction that has the permanent
  		 * reservation and commit the old transaction.
  		 */
++<<<<<<< HEAD
 +		error = xfs_bmap_finish(&tp, &free_list, ip);
++=======
+ 		error = xfs_defer_finish(&tp, &dfops, ip);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		if (error)
  			goto out_bmap_cancel;
  
@@@ -1612,7 -1603,7 +1654,11 @@@ out_bmap_cancel
  	 * the transaction can be properly aborted.  We just need to make sure
  	 * we're not holding any resources that we were not when we came in.
  	 */
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	goto out;
  }
  
@@@ -1755,7 -1744,7 +1801,11 @@@ STATIC in
  xfs_inactive_ifree(
  	struct xfs_inode *ip)
  {
++<<<<<<< HEAD
 +	xfs_bmap_free_t		free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		first_block;
  	struct xfs_mount	*mp = ip->i_mount;
  	struct xfs_trans	*tp;
@@@ -1792,8 -1781,8 +1842,13 @@@
  	xfs_ilock(ip, XFS_ILOCK_EXCL);
  	xfs_trans_ijoin(tp, ip, 0);
  
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
 +	error = xfs_ifree(tp, ip, &free_list);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
+ 	error = xfs_ifree(tp, ip, &dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error) {
  		/*
  		 * If we fail to free the inode, shut down.  The cancel
@@@ -1819,11 -1808,11 +1874,19 @@@
  	 * Just ignore errors at this point.  There is nothing we can do except
  	 * to try to keep going. Make sure it's not a silent error.
  	 */
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error) {
 -		xfs_notice(mp, "%s: xfs_defer_finish returned error %d",
 +		xfs_notice(mp, "%s: xfs_bmap_finish returned error %d",
  			__func__, error);
++<<<<<<< HEAD
 +		xfs_bmap_cancel(&free_list);
++=======
+ 		xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	}
  	error = xfs_trans_commit(tp);
  	if (error)
@@@ -2383,7 -2368,7 +2446,11 @@@ in
  xfs_ifree(
  	xfs_trans_t	*tp,
  	xfs_inode_t	*ip,
++<<<<<<< HEAD
 +	xfs_bmap_free_t	*flist)
++=======
+ 	struct xfs_defer_ops	*dfops)
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  {
  	int			error;
  	struct xfs_icluster	xic = { 0 };
@@@ -2505,7 -2490,7 +2572,11 @@@ xfs_remove
  	xfs_trans_t             *tp = NULL;
  	int			is_dir = S_ISDIR(VFS_I(ip)->i_mode);
  	int                     error = 0;
++<<<<<<< HEAD
 +	xfs_bmap_free_t         free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t           first_block;
  	uint			resblks;
  
@@@ -2587,9 -2572,9 +2658,13 @@@
  	if (error)
  		goto out_trans_cancel;
  
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	error = xfs_dir_removename(tp, dp, name, ip->i_ino,
- 					&first_block, &free_list, resblks);
+ 					&first_block, &dfops, resblks);
  	if (error) {
  		ASSERT(error != -ENOENT);
  		goto out_bmap_cancel;
@@@ -2603,7 -2588,7 +2678,11 @@@
  	if (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
  		xfs_trans_set_sync(tp);
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto out_bmap_cancel;
  
@@@ -2617,7 -2602,7 +2696,11 @@@
  	return 0;
  
   out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
   out_trans_cancel:
  	xfs_trans_cancel(tp);
   std_return:
@@@ -2678,7 -2663,7 +2761,11 @@@ xfs_sort_for_rename
  static int
  xfs_finish_rename(
  	struct xfs_trans	*tp,
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*free_list)
++=======
+ 	struct xfs_defer_ops	*dfops)
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  {
  	int			error;
  
@@@ -2689,9 -2674,9 +2776,15 @@@
  	if (tp->t_mountp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))
  		xfs_trans_set_sync(tp);
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, free_list, NULL);
 +	if (error) {
 +		xfs_bmap_cancel(free_list);
++=======
+ 	error = xfs_defer_finish(&tp, dfops, NULL);
+ 	if (error) {
+ 		xfs_defer_cancel(dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		xfs_trans_cancel(tp);
  		return error;
  	}
@@@ -2713,7 -2698,7 +2806,11 @@@ xfs_cross_rename
  	struct xfs_inode	*dp2,
  	struct xfs_name		*name2,
  	struct xfs_inode	*ip2,
++<<<<<<< HEAD
 +	struct xfs_bmap_free	*free_list,
++=======
+ 	struct xfs_defer_ops	*dfops,
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		*first_block,
  	int			spaceres)
  {
@@@ -2813,10 -2798,10 +2910,14 @@@
  	}
  	xfs_trans_ichgtime(tp, dp1, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);
  	xfs_trans_log_inode(tp, dp1, XFS_ILOG_CORE);
- 	return xfs_finish_rename(tp, free_list);
+ 	return xfs_finish_rename(tp, dfops);
  
  out_trans_abort:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(free_list);
++=======
+ 	xfs_defer_cancel(dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_trans_cancel(tp);
  	return error;
  }
@@@ -2871,7 -2856,7 +2972,11 @@@ xfs_rename
  {
  	struct xfs_mount	*mp = src_dp->i_mount;
  	struct xfs_trans	*tp;
++<<<<<<< HEAD
 +	struct xfs_bmap_free	free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		first_block;
  	struct xfs_inode	*wip = NULL;		/* whiteout inode */
  	struct xfs_inode	*inodes[__XFS_SORT_INODES];
@@@ -2960,7 -2945,7 +3065,11 @@@
  		goto out_trans_cancel;
  	}
  
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  	/* RENAME_EXCHANGE is unique from here on. */
  	if (flags & RENAME_EXCHANGE)
@@@ -3146,7 -3131,7 +3255,11 @@@
  	return error;
  
  out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  out_trans_cancel:
  	xfs_trans_cancel(tp);
  out_release_wip:
diff --cc fs/xfs/xfs_iomap.c
index 39ce9cf9a329,2114d53df433..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -129,7 -129,7 +129,11 @@@ xfs_iomap_write_direct
  	int		quota_flag;
  	int		rt;
  	xfs_trans_t	*tp;
++<<<<<<< HEAD
 +	xfs_bmap_free_t free_list;
++=======
+ 	struct xfs_defer_ops dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	uint		qblocks, resblks, resrtextents;
  	int		error;
  	int		lockmode;
@@@ -232,7 -232,7 +236,11 @@@
  	 * From this point onwards we overwrite the imap pointer that the
  	 * caller gave to us.
  	 */
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &firstfsb);
++=======
+ 	xfs_defer_init(&dfops, &firstfsb);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	nimaps = 1;
  	error = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,
  				bmapi_flags, &firstfsb, resblks, imap,
@@@ -243,7 -243,7 +251,11 @@@
  	/*
  	 * Complete the transaction
  	 */
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto out_bmap_cancel;
  
@@@ -267,7 -267,7 +279,11 @@@ out_unlock
  	return error;
  
  out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);
  out_trans_cancel:
  	xfs_trans_cancel(tp);
@@@ -686,7 -686,7 +702,11 @@@ xfs_iomap_write_allocate
  	xfs_fileoff_t	offset_fsb, last_block;
  	xfs_fileoff_t	end_fsb, map_start_fsb;
  	xfs_fsblock_t	first_block;
++<<<<<<< HEAD
 +	xfs_bmap_free_t	free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_filblks_t	count_fsb;
  	xfs_trans_t	*tp;
  	int		nimaps;
@@@ -728,7 -728,7 +748,11 @@@
  			xfs_ilock(ip, XFS_ILOCK_EXCL);
  			xfs_trans_ijoin(tp, ip, 0);
  
++<<<<<<< HEAD
 +			xfs_bmap_init(&free_list, &first_block);
++=======
+ 			xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  			/*
  			 * it is possible that the extents have changed since
@@@ -788,7 -788,7 +812,11 @@@
  			if (error)
  				goto trans_cancel;
  
++<<<<<<< HEAD
 +			error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 			error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  			if (error)
  				goto trans_cancel;
  
@@@ -822,7 -822,7 +850,11 @@@
  	}
  
  trans_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_trans_cancel(tp);
  error0:
  	xfs_iunlock(ip, XFS_ILOCK_EXCL);
@@@ -843,7 -843,7 +875,11 @@@ xfs_iomap_write_unwritten
  	int		nimaps;
  	xfs_trans_t	*tp;
  	xfs_bmbt_irec_t imap;
++<<<<<<< HEAD
 +	xfs_bmap_free_t free_list;
++=======
+ 	struct xfs_defer_ops dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsize_t	i_size;
  	uint		resblks;
  	int		error;
@@@ -887,7 -887,7 +923,11 @@@
  		/*
  		 * Modify the unwritten extent state of the buffer.
  		 */
++<<<<<<< HEAD
 +		xfs_bmap_init(&free_list, &firstfsb);
++=======
+ 		xfs_defer_init(&dfops, &firstfsb);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		nimaps = 1;
  		error = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,
  					XFS_BMAPI_CONVERT, &firstfsb, resblks,
@@@ -910,7 -910,7 +950,11 @@@
  			xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
  		}
  
++<<<<<<< HEAD
 +		error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 		error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		if (error)
  			goto error_on_bmapi_transaction;
  
@@@ -937,7 -937,7 +981,11 @@@
  	return 0;
  
  error_on_bmapi_transaction:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_trans_cancel(tp);
  	xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	return error;
diff --cc fs/xfs/xfs_rtalloc.c
index 627f7e69ae59,802bcc326d9f..000000000000
--- a/fs/xfs/xfs_rtalloc.c
+++ b/fs/xfs/xfs_rtalloc.c
@@@ -770,7 -770,7 +770,11 @@@ xfs_growfs_rt_alloc
  	xfs_daddr_t		d;		/* disk block address */
  	int			error;		/* error return value */
  	xfs_fsblock_t		firstblock;/* first block allocated in xaction */
++<<<<<<< HEAD
 +	struct xfs_bmap_free	flist;		/* list of freed blocks */
++=======
+ 	struct xfs_defer_ops	dfops;		/* list of freed blocks */
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		fsbno;		/* filesystem block for bno */
  	struct xfs_bmbt_irec	map;		/* block map output */
  	int			nmap;		/* number of block maps */
@@@ -795,7 -795,7 +799,11 @@@
  		xfs_ilock(ip, XFS_ILOCK_EXCL);
  		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
  
++<<<<<<< HEAD
 +		xfs_bmap_init(&flist, &firstblock);
++=======
+ 		xfs_defer_init(&dfops, &firstblock);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		/*
  		 * Allocate blocks to the bitmap file.
  		 */
@@@ -810,7 -810,7 +818,11 @@@
  		/*
  		 * Free any blocks freed up in the transaction, then commit.
  		 */
++<<<<<<< HEAD
 +		error = xfs_bmap_finish(&tp, &flist, NULL);
++=======
+ 		error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  		if (error)
  			goto out_bmap_cancel;
  		error = xfs_trans_commit(tp);
@@@ -863,7 -863,7 +875,11 @@@
  	return 0;
  
  out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&flist);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  out_trans_cancel:
  	xfs_trans_cancel(tp);
  	return error;
diff --cc fs/xfs/xfs_symlink.c
index 1697cc045cce,58142aeeeea6..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -176,7 -173,7 +176,11 @@@ xfs_symlink
  	struct xfs_inode	*ip = NULL;
  	int			error = 0;
  	int			pathlen;
++<<<<<<< HEAD
 +	struct xfs_bmap_free	free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	xfs_fsblock_t		first_block;
  	bool                    unlock_dp_on_error = false;
  	xfs_fileoff_t		first_fsb;
@@@ -273,7 -270,7 +277,11 @@@
  	 * Initialize the bmap freelist prior to calling either
  	 * bmapi or the directory create code.
  	 */
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  
  	/*
  	 * Allocate an inode for the symlink.
@@@ -380,7 -377,7 +388,11 @@@
  		xfs_trans_set_sync(tp);
  	}
  
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, NULL);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, NULL);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto out_bmap_cancel;
  
@@@ -396,7 -393,7 +408,11 @@@
  	return 0;
  
  out_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  out_trans_cancel:
  	xfs_trans_cancel(tp);
  out_release_inode:
@@@ -430,7 -427,7 +446,11 @@@ xfs_inactive_symlink_rmt
  	int		done;
  	int		error;
  	xfs_fsblock_t	first_block;
++<<<<<<< HEAD
 +	xfs_bmap_free_t	free_list;
++=======
+ 	struct xfs_defer_ops	dfops;
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	int		i;
  	xfs_mount_t	*mp;
  	xfs_bmbt_irec_t	mval[XFS_SYMLINK_MAPS];
@@@ -469,7 -466,7 +489,11 @@@
  	 * Find the block(s) so we can inval and unmap them.
  	 */
  	done = 0;
++<<<<<<< HEAD
 +	xfs_bmap_init(&free_list, &first_block);
++=======
+ 	xfs_defer_init(&dfops, &first_block);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	nmaps = ARRAY_SIZE(mval);
  	error = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),
  				mval, &nmaps, 0);
@@@ -499,7 -496,7 +523,11 @@@
  	/*
  	 * Commit the first transaction.  This logs the EFI and the inode.
  	 */
++<<<<<<< HEAD
 +	error = xfs_bmap_finish(&tp, &free_list, ip);
++=======
+ 	error = xfs_defer_finish(&tp, &dfops, ip);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  	if (error)
  		goto error_bmap_cancel;
  	/*
@@@ -529,7 -526,7 +557,11 @@@
  	return 0;
  
  error_bmap_cancel:
++<<<<<<< HEAD
 +	xfs_bmap_cancel(&free_list);
++=======
+ 	xfs_defer_cancel(&dfops);
++>>>>>>> 2c3234d1ef53 (xfs: rename flist/free_list to dfops)
  error_trans_cancel:
  	xfs_trans_cancel(tp);
  error_unlock:
* Unmerged path fs/xfs/libxfs/xfs_attr.c
diff --git a/fs/xfs/libxfs/xfs_attr_leaf.c b/fs/xfs/libxfs/xfs_attr_leaf.c
index f18270ae791a..2852521fc8ec 100644
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@ -798,7 +798,7 @@ xfs_attr_shortform_to_leaf(xfs_da_args_t *args)
 	nargs.dp = dp;
 	nargs.geo = args->geo;
 	nargs.firstblock = args->firstblock;
-	nargs.flist = args->flist;
+	nargs.dfops = args->dfops;
 	nargs.total = args->total;
 	nargs.whichfork = XFS_ATTR_FORK;
 	nargs.trans = args->trans;
@@ -928,7 +928,7 @@ xfs_attr3_leaf_to_shortform(
 	nargs.geo = args->geo;
 	nargs.dp = dp;
 	nargs.firstblock = args->firstblock;
-	nargs.flist = args->flist;
+	nargs.dfops = args->dfops;
 	nargs.total = args->total;
 	nargs.whichfork = XFS_ATTR_FORK;
 	nargs.trans = args->trans;
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.h
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index f499fdf0e7f8..fad1ff3fa8a2 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -407,11 +407,11 @@ xfs_bmbt_dup_cursor(
 			cur->bc_private.b.ip, cur->bc_private.b.whichfork);
 
 	/*
-	 * Copy the firstblock, flist, and flags values,
+	 * Copy the firstblock, dfops, and flags values,
 	 * since init cursor doesn't get them.
 	 */
 	new->bc_private.b.firstblock = cur->bc_private.b.firstblock;
-	new->bc_private.b.flist = cur->bc_private.b.flist;
+	new->bc_private.b.dfops = cur->bc_private.b.dfops;
 	new->bc_private.b.flags = cur->bc_private.b.flags;
 
 	return new;
@@ -424,7 +424,7 @@ xfs_bmbt_update_cursor(
 {
 	ASSERT((dst->bc_private.b.firstblock != NULLFSBLOCK) ||
 	       (dst->bc_private.b.ip->i_d.di_flags & XFS_DIFLAG_REALTIME));
-	ASSERT(dst->bc_private.b.flist == src->bc_private.b.flist);
+	ASSERT(dst->bc_private.b.dfops == src->bc_private.b.dfops);
 
 	dst->bc_private.b.allocated += src->bc_private.b.allocated;
 	dst->bc_private.b.firstblock = src->bc_private.b.firstblock;
@@ -463,7 +463,7 @@ xfs_bmbt_alloc_block(
 		 * block allocation here and corrupt the filesystem.
 		 */
 		args.minleft = args.tp->t_blk_res;
-	} else if (cur->bc_private.b.flist->dop_low) {
+	} else if (cur->bc_private.b.dfops->dop_low) {
 		args.type = XFS_ALLOCTYPE_START_BNO;
 	} else {
 		args.type = XFS_ALLOCTYPE_NEAR_BNO;
@@ -491,7 +491,7 @@ xfs_bmbt_alloc_block(
 		error = xfs_alloc_vextent(&args);
 		if (error)
 			goto error0;
-		cur->bc_private.b.flist->dop_low = true;
+		cur->bc_private.b.dfops->dop_low = true;
 	}
 	if (args.fsbno == NULLFSBLOCK) {
 		XFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);
@@ -527,7 +527,7 @@ xfs_bmbt_free_block(
 	struct xfs_trans	*tp = cur->bc_tp;
 	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));
 
-	xfs_bmap_add_free(mp, cur->bc_private.b.flist, fsbno, 1);
+	xfs_bmap_add_free(mp, cur->bc_private.b.dfops, fsbno, 1);
 	ip->i_d.di_nblocks--;
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
@@ -793,7 +793,7 @@ xfs_bmbt_init_cursor(
 	cur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);
 	cur->bc_private.b.ip = ip;
 	cur->bc_private.b.firstblock = NULLFSBLOCK;
-	cur->bc_private.b.flist = NULL;
+	cur->bc_private.b.dfops = NULL;
 	cur->bc_private.b.allocated = 0;
 	cur->bc_private.b.flags = 0;
 	cur->bc_private.b.whichfork = whichfork;
* Unmerged path fs/xfs/libxfs/xfs_btree.h
diff --git a/fs/xfs/libxfs/xfs_da_btree.c b/fs/xfs/libxfs/xfs_da_btree.c
index 0f1f165f4048..f2dc1a950c85 100644
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@ -2029,7 +2029,7 @@ xfs_da_grow_inode_int(
 	error = xfs_bmapi_write(tp, dp, *bno, count,
 			xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,
 			args->firstblock, args->total, &map, &nmap,
-			args->flist);
+			args->dfops);
 	if (error)
 		return error;
 
@@ -2052,7 +2052,7 @@ xfs_da_grow_inode_int(
 			error = xfs_bmapi_write(tp, dp, b, c,
 					xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,
 					args->firstblock, args->total,
-					&mapp[mapi], &nmap, args->flist);
+					&mapp[mapi], &nmap, args->dfops);
 			if (error)
 				goto out_free_map;
 			if (nmap < 1)
@@ -2362,7 +2362,7 @@ xfs_da_shrink_inode(
 		 */
 		error = xfs_bunmapi(tp, dp, dead_blkno, count,
 				    xfs_bmapi_aflag(w), 0, args->firstblock,
-				    args->flist, &done);
+				    args->dfops, &done);
 		if (error == -ENOSPC) {
 			if (w != XFS_DATA_FORK)
 				break;
* Unmerged path fs/xfs/libxfs/xfs_da_btree.h
* Unmerged path fs/xfs/libxfs/xfs_dir2.c
* Unmerged path fs/xfs/libxfs/xfs_dir2.h
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
* Unmerged path fs/xfs/libxfs/xfs_ialloc.h
* Unmerged path fs/xfs/xfs_bmap_util.c
* Unmerged path fs/xfs/xfs_dquot.c
diff --git a/fs/xfs/xfs_filestream.c b/fs/xfs/xfs_filestream.c
index 832f513ee33b..4bbe58fc7118 100644
--- a/fs/xfs/xfs_filestream.c
+++ b/fs/xfs/xfs_filestream.c
@@ -386,7 +386,7 @@ xfs_filestream_new_ag(
 	}
 
 	flags = (ap->userdata ? XFS_PICK_USERDATA : 0) |
-	        (ap->flist->dop_low ? XFS_PICK_LOWSPACE : 0);
+	        (ap->dfops->dop_low ? XFS_PICK_LOWSPACE : 0);
 
 	err = xfs_filestream_pick_ag(pip, startag, agp, flags, minlen);
 
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_iomap.c
* Unmerged path fs/xfs/xfs_rtalloc.c
* Unmerged path fs/xfs/xfs_symlink.c
