qla2xxx: Improve RSCN handling in driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 41dc529a4602ac737020f423f84686a81de38e6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/41dc529a.failed

Current code blindly does State Change Registration when
the link is up. Move SCR behind fabric scan, so that arbitrated
loop scan would not get erroneous error message.

Some of the other improvements are as follows

- Add session deletion for TPRLO and send acknowledgment for TPRLO.
- Enable FW option to move ABTS, RIDA & PUREX from RSPQ to ATIOQ.
- Save NPort ID early in link init.
- Move ABTS & RIDA to ATIOQ helps in keeping command ordering and
  link up sequence ordering.
- Save Nport ID and update VP map so that SCSI CMD/ATIO won't be dropped.
- fcport alloc does the initializes memory to zero. Remove memset to
  zero since It might corrupt link list.
- Turn off Registration for State Change MB in loop mode.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 41dc529a4602ac737020f423f84686a81de38e6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_gs.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,3881790e80da..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2014,6 -2165,74 +2014,77 @@@ typedef struct 
  	FCT_TARGET
  } fc_port_type_t;
  
++<<<<<<< HEAD
++=======
+ enum qla_sess_deletion {
+ 	QLA_SESS_DELETION_NONE		= 0,
+ 	QLA_SESS_DELETION_IN_PROGRESS,
+ 	QLA_SESS_DELETED,
+ };
+ 
+ enum qlt_plogi_link_t {
+ 	QLT_PLOGI_LINK_SAME_WWN,
+ 	QLT_PLOGI_LINK_CONFLICT,
+ 	QLT_PLOGI_LINK_MAX
+ };
+ 
+ struct qlt_plogi_ack_t {
+ 	struct list_head	list;
+ 	struct imm_ntfy_from_isp iocb;
+ 	port_id_t	id;
+ 	int		ref_count;
+ 	void		*fcport;
+ };
+ 
+ struct ct_sns_desc {
+ 	struct ct_sns_pkt	*ct_sns;
+ 	dma_addr_t		ct_sns_dma;
+ };
+ 
+ enum discovery_state {
+ 	DSC_DELETED,
+ 	DSC_GID_PN,
+ 	DSC_GNL,
+ 	DSC_LOGIN_PEND,
+ 	DSC_LOGIN_FAILED,
+ 	DSC_GPDB,
+ 	DSC_GPSC,
+ 	DSC_UPD_FCPORT,
+ 	DSC_LOGIN_COMPLETE,
+ 	DSC_DELETE_PEND,
+ };
+ 
+ enum login_state {	/* FW control Target side */
+ 	DSC_LS_LLIOCB_SENT = 2,
+ 	DSC_LS_PLOGI_PEND,
+ 	DSC_LS_PLOGI_COMP,
+ 	DSC_LS_PRLI_PEND,
+ 	DSC_LS_PRLI_COMP,
+ 	DSC_LS_PORT_UNAVAIL,
+ 	DSC_LS_PRLO_PEND = 9,
+ 	DSC_LS_LOGO_PEND,
+ };
+ 
+ enum fcport_mgt_event {
+ 	FCME_RELOGIN = 1,
+ 	FCME_RSCN,
+ 	FCME_GIDPN_DONE,
+ 	FCME_PLOGI_DONE,	/* Initiator side sent LLIOCB */
+ 	FCME_GNL_DONE,
+ 	FCME_GPSC_DONE,
+ 	FCME_GPDB_DONE,
+ 	FCME_GPNID_DONE,
+ 	FCME_DELETE_DONE,
+ };
+ 
+ enum rscn_addr_format {
+ 	RSCN_PORT_ADDR,
+ 	RSCN_AREA_ADDR,
+ 	RSCN_DOM_ADDR,
+ 	RSCN_FAB_ADDR,
+ };
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  /*
   * Fibre channel port structure.
   */
@@@ -3658,6 -4014,22 +3729,25 @@@ typedef struct scsi_qla_host 
  	uint16_t	fcoe_fcf_idx;
  	uint8_t		fcoe_vn_port_mac[6];
  
++<<<<<<< HEAD
++=======
+ 	/* list of commands waiting on workqueue */
+ 	struct list_head	qla_cmd_list;
+ 	struct list_head	qla_sess_op_cmd_list;
+ 	struct list_head	unknown_atio_list;
+ 	spinlock_t		cmd_list_lock;
+ 	struct delayed_work	unknown_atio_work;
+ 
+ 	/* Counter to detect races between ELS and RSCN events */
+ 	atomic_t		generation_tick;
+ 	/* Time when global fcport update has been scheduled */
+ 	int			total_fcport_update_gen;
+ 	/* List of pending LOGOs, protected by tgt_mutex */
+ 	struct list_head	logo_list;
+ 	/* List of pending PLOGI acks, protected by hw lock */
+ 	struct list_head	plogi_ack_list;
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  	struct list_head	qp_list;
  
  	uint32_t	vp_abort_cnt;
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,e0914575aab3..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -118,10 -132,13 +118,11 @@@ extern int ql2xenabledif
  extern int ql2xenablehba_err_chk;
  extern int ql2xtargetreset;
  extern int ql2xdontresethba;
 -extern uint64_t ql2xmaxlun;
 +extern unsigned int ql2xmaxlun;
  extern int ql2xmdcapmask;
  extern int ql2xmdenable;
 -extern int ql2xexlogins;
 -extern int ql2xexchoffld;
  extern int ql2xfwholdabts;
+ extern int ql2xmvasynctoatio;
  
  extern int qla2x00_loop_reset(scsi_qla_host_t *);
  extern void qla2x00_abort_all_cmds(scsi_qla_host_t *, int);
@@@ -782,4 -826,25 +783,28 @@@ extern void qla82xx_mbx_completion(scsi
  extern int qla8044_abort_isp(scsi_qla_host_t *);
  extern int qla8044_check_fw_alive(struct scsi_qla_host *);
  
++<<<<<<< HEAD
++=======
+ extern void qlt_host_reset_handler(struct qla_hw_data *ha);
+ extern int qla_get_exlogin_status(scsi_qla_host_t *, uint16_t *,
+ 	uint16_t *);
+ extern int qla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr);
+ extern int qla_get_exchoffld_status(scsi_qla_host_t *, uint16_t *, uint16_t *);
+ extern int qla_set_exchoffld_mem_cfg(scsi_qla_host_t *, dma_addr_t);
+ extern void qlt_handle_abts_recv(struct scsi_qla_host *, response_t *);
+ 
+ int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
+ 	struct imm_ntfy_from_isp *, int);
+ void qla24xx_do_nack_work(struct scsi_qla_host *, struct qla_work_evt *);
+ void qlt_plogi_ack_link(struct scsi_qla_host *, struct qlt_plogi_ack_t *,
+ 	struct fc_port *, enum qlt_plogi_link_t);
+ void qlt_plogi_ack_unref(struct scsi_qla_host *, struct qlt_plogi_ack_t *);
+ extern void qlt_schedule_sess_for_deletion(struct fc_port *, bool);
+ extern void qlt_schedule_sess_for_deletion_lock(struct fc_port *);
+ extern struct fc_port *qlt_find_sess_invalidate_other(scsi_qla_host_t *,
+ 	uint64_t wwn, port_id_t port_id, uint16_t loop_id, struct fc_port **);
+ void qla24xx_delete_sess_fn(struct work_struct *);
+ void qlt_unknown_atio_work_fn(struct work_struct *);
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_gs.c
index 54827d74afb8,d1074fb0fff8..000000000000
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@@ -2692,3 -2741,538 +2692,541 @@@ qla2x00_gff_id(scsi_qla_host_t *vha, sw
  			break;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /* GID_PN completion processing. */
+ void qla24xx_handle_gidpn_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"%s %8phC login state %d \n",
+ 		__func__, fcport->port_name, fcport->fw_login_state);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* PLOGI/PRLI/LOGO came in while cmd was out.*/
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	if (!ea->rc) {
+ 		if (ea->sp->gen1 == fcport->rscn_gen) {
+ 			fcport->scan_state = QLA_FCPORT_FOUND;
+ 			fcport->flags |= FCF_FABRIC_DEVICE;
+ 
+ 			if (fcport->d_id.b24 == ea->id.b24) {
+ 				/* cable plugged into the same place */
+ 				switch (vha->host->active_mode) {
+ 				case MODE_TARGET:
+ 					/* NOOP. let the other guy login to us.*/
+ 					break;
+ 				case MODE_INITIATOR:
+ 				case MODE_DUAL:
+ 				default:
+ 					if (atomic_read(&fcport->state) ==
+ 					    FCS_ONLINE)
+ 						break;
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post gnl\n",
+ 					    __func__, __LINE__, fcport->port_name);
+ 					qla24xx_post_gnl_work(vha, fcport);
+ 					break;
+ 				}
+ 			} else { /* fcport->d_id.b24 != ea->id.b24 */
+ 				fcport->d_id.b24 = ea->id.b24;
+ 				if (fcport->deleted == QLA_SESS_DELETED) {
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__, fcport->port_name);
+ 					qlt_schedule_sess_for_deletion_lock(fcport);
+ 				}
+ 			}
+ 		} else { /* ea->sp->gen1 != fcport->rscn_gen */
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gidpn\n",
+ 			    __func__, __LINE__, fcport->port_name);
+ 			/* rscn came in while cmd was out */
+ 			qla24xx_post_gidpn_work(vha, fcport);
+ 		}
+ 	} else { /* ea->rc */
+ 		/* cable pulled */
+ 		if (ea->sp->gen1 == fcport->rscn_gen) {
+ 			if (ea->sp->gen2 == fcport->login_gen) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %d %8phC post del sess\n", __func__,
+ 				    __LINE__, fcport->port_name);
+ 				qlt_schedule_sess_for_deletion_lock(fcport);
+ 			} else {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %d %8phC login\n", __func__, __LINE__,
+ 				    fcport->port_name);
+ 				qla24xx_fcport_handle_login(vha, fcport);
+ 			}
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gidpn\n", __func__, __LINE__,
+ 			    fcport->port_name);
+ 			qla24xx_post_gidpn_work(vha, fcport);
+ 		}
+ 	}
+ } /* gidpn_event */
+ 
+ static void qla2x00_async_gidpn_sp_done(void *v, void *s, int res)
+ {
+ 	struct scsi_qla_host *vha = (struct scsi_qla_host *)v;
+ 	struct srb *sp = (struct srb *)s;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u8 *id = fcport->ct_desc.ct_sns->p.rsp.rsp.gid_pn.port_id;
+ 	struct event_arg ea;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.fcport = fcport;
+ 	ea.id.b.domain = id[0];
+ 	ea.id.b.area = id[1];
+ 	ea.id.b.al_pa = id[2];
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GIDPN_DONE;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC ID %3phC \n",
+ 	    sp->name, res, fcport->port_name, id);
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	sp->free(vha, sp);
+ }
+ 
+ int qla24xx_async_gidpn(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GID_PN;
+ 	fcport->scan_state = QLA_FCPORT_SCAN;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gidpn";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(fcport->ct_desc.ct_sns, GID_PN_CMD,
+ 		GID_PN_RSP_SIZE);
+ 
+ 	/* GIDPN req */
+ 	memcpy(ct_req->req.gid_pn.port_name, fcport->port_name,
+ 		WWN_SIZE);
+ 
+ 	/* req & rsp use the same buffer */
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GID_PN_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GID_PN_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gidpn_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x206f,
+ 		"Async-%s - %8phC hdl=%x loopid=%x portid %02x%02x%02x.\n",
+ 		sp->name, fcport->port_name,
+ 		sp->handle, fcport->loop_id, fcport->d_id.b.domain,
+ 		fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(vha, sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gidpn_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 	int ls;
+ 
+ 	ls = atomic_read(&vha->loop_state);
+ 	if (((ls != LOOP_READY) && (ls != LOOP_UP)) ||
+ 		test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GIDPN);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_post_gpsc_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPSC);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static void qla24xx_async_gpsc_sp_done(void *v, void *s, int res)
+ {
+ 	struct scsi_qla_host *vha = (struct scsi_qla_host *)v;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct srb *sp = (struct srb *)s;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct ct_sns_rsp       *ct_rsp;
+ 	struct event_arg ea;
+ 
+ 	ct_rsp = &fcport->ct_desc.ct_sns->p.rsp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC \n",
+ 	    sp->name, res, fcport->port_name);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res == (DID_ERROR << 16)) {
+ 		/* entry status error */
+ 		goto done;
+ 	} else if (res) {
+ 		if ((ct_rsp->header.reason_code ==
+ 			 CT_REASON_INVALID_COMMAND_CODE) ||
+ 			(ct_rsp->header.reason_code ==
+ 			 CT_REASON_COMMAND_UNSUPPORTED)) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x205a,
+ 				"GPSC command unsupported, disabling "
+ 				"query.\n");
+ 			ha->flags.gpsc_supported = 0;
+ 			res = QLA_SUCCESS;
+ 		}
+ 	} else {
+ 		switch (be16_to_cpu(ct_rsp->rsp.gpsc.speed)) {
+ 		case BIT_15:
+ 			fcport->fp_speed = PORT_SPEED_1GB;
+ 			break;
+ 		case BIT_14:
+ 			fcport->fp_speed = PORT_SPEED_2GB;
+ 			break;
+ 		case BIT_13:
+ 			fcport->fp_speed = PORT_SPEED_4GB;
+ 			break;
+ 		case BIT_12:
+ 			fcport->fp_speed = PORT_SPEED_10GB;
+ 			break;
+ 		case BIT_11:
+ 			fcport->fp_speed = PORT_SPEED_8GB;
+ 			break;
+ 		case BIT_10:
+ 			fcport->fp_speed = PORT_SPEED_16GB;
+ 			break;
+ 		case BIT_8:
+ 			fcport->fp_speed = PORT_SPEED_32GB;
+ 			break;
+ 		}
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s OUT WWPN %8phC speeds=%04x speed=%04x.\n",
+ 			sp->name,
+ 			fcport->fabric_port_name,
+ 			be16_to_cpu(ct_rsp->rsp.gpsc.speeds),
+ 			be16_to_cpu(ct_rsp->rsp.gpsc.speed));
+ 	}
+ done:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPSC_DONE;
+ 	ea.rc = res;
+ 	ea.fcport = fcport;
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	sp->free(vha, sp);
+ }
+ 
+ int qla24xx_async_gpsc(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gpsc";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla24xx_prep_ct_fm_req(fcport->ct_desc.ct_sns, GPSC_CMD,
+ 		GPSC_RSP_SIZE);
+ 
+ 	/* GPSC req */
+ 	memcpy(ct_req->req.gpsc.port_name, fcport->port_name,
+ 		WWN_SIZE);
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GPSC_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GPSC_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = vha->mgmt_svr_loop_id;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla24xx_async_gpsc_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hdl=%x loopid=%x portid=%02x%02x%02x.\n",
+ 		sp->name, fcport->port_name, sp->handle,
+ 		fcport->loop_id, fcport->d_id.b.domain,
+ 		fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(vha, sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gpnid_work(struct scsi_qla_host *vha, port_id_t *id)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPNID);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.gpnid.id = *id;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ void qla24xx_async_gpnid_done(scsi_qla_host_t *vha, srb_t *sp)
+ {
+ 	if (sp->u.iocb_cmd.u.ctarg.req) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.req,
+ 			sp->u.iocb_cmd.u.ctarg.req_dma);
+ 		sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 	}
+ 	if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.rsp,
+ 			sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 		sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 	}
+ 
+ 	sp->free(vha, sp);
+ }
+ 
+ void qla24xx_handle_gpnid_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport = qla2x00_find_fcport_by_wwpn(vha, ea->port_name, 1);
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	if (fcport) {
+ 		/* cable moved. just plugged in */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post del sess\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		fcport->rscn_gen++;
+ 		fcport->d_id = ea->id;
+ 		fcport->scan_state = QLA_FCPORT_FOUND;
+ 		fcport->flags |= FCF_FABRIC_DEVICE;
+ 
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 	} else {
+ 		/* create new fcport */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post new sess\n",
+ 			   __func__, __LINE__, ea->port_name);
+ 
+ 		qla24xx_post_newsess_work(vha, &ea->id, ea->port_name, NULL);
+ 	}
+ }
+ 
+ static void qla2x00_async_gpnid_sp_done(void *v, void *s, int res)
+ {
+ 	struct scsi_qla_host *vha = (struct scsi_qla_host *)v;
+ 	struct srb *sp = (struct srb *)s;
+ 	struct ct_sns_req *ct_req =
+ 	    (struct ct_sns_req *)sp->u.iocb_cmd.u.ctarg.req;
+ 	struct ct_sns_rsp *ct_rsp =
+ 	    (struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp;
+ 	struct event_arg ea;
+ 	struct qla_work_evt *e;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async done-%s res %x ID %3phC. %8phC\n",
+ 		sp->name, res, ct_req->req.port_id.port_id,
+ 		ct_rsp->rsp.gpn_id.port_name);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	memcpy(ea.port_name, ct_rsp->rsp.gpn_id.port_name, WWN_SIZE);
+ 	ea.sp = sp;
+ 	ea.id.b.domain = ct_req->req.port_id.port_id[0];
+ 	ea.id.b.area = ct_req->req.port_id.port_id[1];
+ 	ea.id.b.al_pa = ct_req->req.port_id.port_id[2];
+ 	ea.rc = res;
+ 	ea.event = FCME_GPNID_DONE;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPNID_DONE);
+ 	if (!e) {
+ 		/* please ignore kernel warning. otherwise, we have mem leak. */
+ 		if (sp->u.iocb_cmd.u.ctarg.req) {
+ 			dma_free_coherent(&vha->hw->pdev->dev,
+ 				sizeof(struct ct_sns_pkt),
+ 				sp->u.iocb_cmd.u.ctarg.req,
+ 				sp->u.iocb_cmd.u.ctarg.req_dma);
+ 			sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 		}
+ 		if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 			dma_free_coherent(&vha->hw->pdev->dev,
+ 				sizeof(struct ct_sns_pkt),
+ 				sp->u.iocb_cmd.u.ctarg.rsp,
+ 				sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 			sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 		}
+ 
+ 		sp->free(vha, sp);
+ 		return;
+ 	}
+ 
+ 	e->u.iosb.sp = sp;
+ 	qla2x00_post_work(vha, e);
+ }
+ 
+ /* Get WWPN with Nport ID. */
+ int qla24xx_async_gpnid(scsi_qla_host_t *vha, port_id_t *id)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 	struct ct_sns_pkt *ct_sns;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	sp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gpnid";
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,
+ 		sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,
+ 		GFP_KERNEL);
+ 	if (!sp->u.iocb_cmd.u.ctarg.req) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate ct_sns request.\n");
+ 		goto done_free_sp;
+ 	}
+ 
+ 	sp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,
+ 		sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.rsp_dma,
+ 		GFP_KERNEL);
+ 	if (!sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate ct_sns request.\n");
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;
+ 	memset(ct_sns, 0, sizeof(*ct_sns));
+ 
+ 	ct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(ct_sns, GPN_ID_CMD, GPN_ID_RSP_SIZE);
+ 
+ 	/* GPN_ID req */
+ 	ct_req->req.port_id.port_id[0] = id->b.domain;
+ 	ct_req->req.port_id.port_id[1] = id->b.area;
+ 	ct_req->req.port_id.port_id[2] = id->b.al_pa;
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GPN_ID_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GPN_ID_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gpnid_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s hdl=%x ID %3phC.\n", sp->name,
+ 		sp->handle, ct_req->req.port_id.port_id);
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (sp->u.iocb_cmd.u.ctarg.req) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.req,
+ 			sp->u.iocb_cmd.u.ctarg.req_dma);
+ 		sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 	}
+ 	if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 			sizeof(struct ct_sns_pkt),
+ 			sp->u.iocb_cmd.u.ctarg.rsp,
+ 			sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 		sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 	}
+ 
+ 	sp->free(vha, sp);
+ done:
+ 	return rval;
+ }
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,68430934fa8d..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -274,6 -322,849 +274,851 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *conflict_fcport;
+ 	struct get_name_list_extended *e;
+ 	u16 i, n, found = 0, loop_id;
+ 	port_id_t id;
+ 	u64 wwn;
+ 	u8 opt = 0;
+ 
+ 	fcport = ea->fcport;
+ 
+ 	if (ea->rc) { /* rval */
+ 		if (fcport->login_retry == 0) {
+ 			fcport->login_retry = vha->hw->login_retry_count;
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				"GNL failed Port login retry %8phN, retry cnt=%d.\n",
+ 				fcport->port_name, fcport->login_retry);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC rscn gen changed rscn %d|%d \n",
+ 		    __func__, fcport->port_name,
+ 		    fcport->last_rscn_gen, fcport->rscn_gen);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	} else if (fcport->last_login_gen != fcport->login_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s %8phC login gen changed login %d|%d \n",
+ 			__func__, fcport->port_name,
+ 			fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	n = ea->data[0] / sizeof(struct get_name_list_extended);
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %d %8phC n %d %02x%02x%02x lid %d \n",
+ 	    __func__, __LINE__, fcport->port_name, n,
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa, fcport->loop_id);
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		if (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))
+ 			continue;
+ 
+ 		found = 1;
+ 		id.b.domain = e->port_id[2];
+ 		id.b.area = e->port_id[1];
+ 		id.b.al_pa = e->port_id[0];
+ 		id.b.rsvd_1 = 0;
+ 
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		loop_id = (loop_id & 0x7fff);
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s found %8phC CLS [%d|%d] ID[%02x%02x%02x|%02x%02x%02x] lid[%d|%d]\n",
+ 			   __func__, fcport->port_name,
+ 			e->current_login_state, fcport->fw_login_state,
+ 			id.b.domain, id.b.area, id.b.al_pa,
+ 			fcport->d_id.b.domain, fcport->d_id.b.area,
+ 			fcport->d_id.b.al_pa, loop_id, fcport->loop_id);
+ 
+ 		if ((id.b24 != fcport->d_id.b24) ||
+ 		    ((fcport->loop_id != FC_NO_LOOP_ID) &&
+ 			(fcport->loop_id != loop_id))) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post del sess\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qlt_schedule_sess_for_deletion(fcport, 1);
+ 			return;
+ 		}
+ 
+ 		fcport->loop_id = loop_id;
+ 
+ 		wwn = wwn_to_u64(fcport->port_name);
+ 		qlt_find_sess_invalidate_other(vha, wwn,
+ 			id, loop_id, &conflict_fcport);
+ 
+ 		if (conflict_fcport) {
+ 			/*
+ 			 * Another share fcport share the same loop_id &
+ 			 * nport id. Conflict fcport needs to finish
+ 			 * cleanup before this fcport can proceed to login.
+ 			 */
+ 			conflict_fcport->conflict = fcport;
+ 			fcport->login_pause = 1;
+ 		}
+ 
+ 		switch (e->current_login_state) {
+ 		case DSC_LS_PRLI_COMP:
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			opt = PDO_FORCE_ADISC;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 			break;
+ 
+ 		case DSC_LS_PORT_UNAVAIL:
+ 		default:
+ 			if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 				qla2x00_find_new_loop_id(vha, fcport);
+ 				fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 			}
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		/* fw has no record of this port */
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			qla2x00_find_new_loop_id(vha, fcport);
+ 			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		} else {
+ 			for (i = 0; i < n; i++) {
+ 				e = &vha->gnl.l[i];
+ 				id.b.domain = e->port_id[0];
+ 				id.b.area = e->port_id[1];
+ 				id.b.al_pa = e->port_id[2];
+ 				id.b.rsvd_1 = 0;
+ 				loop_id = le16_to_cpu(e->nport_handle);
+ 
+ 				if (fcport->d_id.b24 == id.b24) {
+ 					conflict_fcport =
+ 					    qla2x00_find_fcport_by_wwpn(vha,
+ 						e->port_name, 0);
+ 
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__,
+ 					    conflict_fcport->port_name);
+ 					qlt_schedule_sess_for_deletion
+ 						(conflict_fcport, 1);
+ 				}
+ 
+ 				if (fcport->loop_id == loop_id) {
+ 					/* FW already picked this loop id for another fcport */
+ 					qla2x00_find_new_loop_id(vha, fcport);
+ 				}
+ 			}
+ 		}
+ 		qla24xx_fcport_handle_login(vha, fcport);
+ 	}
+ } /* gnl_event */
+ 
+ static void
+ qla24xx_async_gnl_sp_done(void *v, void *s, int res)
+ {
+ 	struct scsi_qla_host *vha = (struct scsi_qla_host *)v;
+ 	struct srb *sp = (struct srb *)s;
+ 	unsigned long flags;
+ 	struct fc_port *fcport = NULL, *tf;
+ 	u16 i, n = 0, loop_id;
+ 	struct event_arg ea;
+ 	struct get_name_list_extended *e;
+ 	u64 wwn;
+ 	struct list_head h;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],
+ 	    sp->u.iocb_cmd.u.mbx.in_mb[2]);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GNL_DONE;
+ 
+ 	if (sp->u.iocb_cmd.u.mbx.in_mb[1] >=
+ 	    sizeof(struct get_name_list_extended)) {
+ 		n = sp->u.iocb_cmd.u.mbx.in_mb[1] /
+ 		    sizeof(struct get_name_list_extended);
+ 		ea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1]; /* amnt xfered */
+ 	}
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		/* mask out reserve bit */
+ 		loop_id = (loop_id & 0x7fff);
+ 		set_bit(loop_id, vha->hw->loop_id_map);
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		ql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,
+ 		    "%s %8phC %02x:%02x:%02x state %d/%d lid %x \n",
+ 		    __func__, (void *)&wwn, e->port_id[2], e->port_id[1],
+ 		    e->port_id[0], e->current_login_state, e->last_login_state,
+ 		    (loop_id & 0x7fff));
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	vha->gnl.sent = 0;
+ 
+ 	INIT_LIST_HEAD(&h);
+ 	fcport = tf = NULL;
+ 	if (!list_empty(&vha->gnl.fcports))
+ 		list_splice_init(&vha->gnl.fcports, &h);
+ 
+ 	list_for_each_entry_safe(fcport, tf, &h, gnl_entry) {
+ 		list_del_init(&fcport->gnl_entry);
+ 		fcport->flags &= ~FCF_ASYNC_SENT;
+ 		ea.fcport = fcport;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(vha, sp);
+ }
+ 
+ int qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	unsigned long flags;
+ 	u16 *mb;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-gnlist WWPN %8phC \n", fcport->port_name);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GNL;
+ 	fcport->last_rscn_gen = fcport->rscn_gen;
+ 	fcport->last_login_gen = fcport->login_gen;
+ 
+ 	list_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);
+ 	if (vha->gnl.sent) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		rval = QLA_SUCCESS;
+ 		goto done;
+ 	}
+ 	vha->gnl.sent = 1;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gnlist";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_PORT_NODE_NAME_LIST;
+ 	mb[1] = BIT_2 | BIT_3;
+ 	mb[2] = MSW(vha->gnl.ldma);
+ 	mb[3] = LSW(vha->gnl.ldma);
+ 	mb[6] = MSW(MSD(vha->gnl.ldma));
+ 	mb[7] = LSW(MSD(vha->gnl.ldma));
+ 	mb[8] = vha->gnl.size;
+ 	mb[9] = vha->vp_idx;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 
+ 	sp->done = qla24xx_async_gnl_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s - OUT WWPN %8phC hndl %x\n",
+ 		sp->name, fcport->port_name, sp->handle);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(fcport->vha, sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GNL);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla24xx_async_gpdb_sp_done(void *v, void *s, int res)
+ {
+ 	struct scsi_qla_host *vha = (struct scsi_qla_host *)v;
+ 	struct srb *sp = (struct srb *)s;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint64_t zero = 0;
+ 	struct port_database_24xx *pd;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;
+ 	int rval = QLA_SUCCESS;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, fcport->port_name, mb[1], mb[2]);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res) {
+ 		rval = res;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
+ 
+ 	/* Check for logged in state. */
+ 	if (pd->current_login_state != PDS_PRLI_COMPLETE &&
+ 	    pd->last_login_state != PDS_PRLI_COMPLETE) {
+ 		ql_dbg(ql_dbg_mbx, vha, 0xffff,
+ 		    "Unable to verify login-state (%x/%x) for "
+ 		    "loop_id %x.\n", pd->current_login_state,
+ 		    pd->last_login_state, fcport->loop_id);
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	if (fcport->loop_id == FC_NO_LOOP_ID ||
+ 	    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&
+ 		memcmp(fcport->port_name, pd->port_name, 8))) {
+ 		/* We lost the device mid way. */
+ 		rval = QLA_NOT_LOGGED_IN;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	/* Names are little-endian. */
+ 	memcpy(fcport->node_name, pd->node_name, WWN_SIZE);
+ 
+ 	/* Get port_id of device. */
+ 	fcport->d_id.b.domain = pd->port_id[0];
+ 	fcport->d_id.b.area = pd->port_id[1];
+ 	fcport->d_id.b.al_pa = pd->port_id[2];
+ 	fcport->d_id.b.rsvd_1 = 0;
+ 
+ 	/* If not target must be initiator or unknown type. */
+ 	if ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 		fcport->port_type = FCT_INITIATOR;
+ 	else
+ 		fcport->port_type = FCT_TARGET;
+ 
+ 	/* Passback COS information. */
+ 	fcport->supported_classes = (pd->flags & PDF_CLASS_2) ?
+ 		FC_COS_CLASS2 : FC_COS_CLASS3;
+ 
+ 	if (pd->prli_svc_param_word_3[0] & BIT_7) {
+ 		fcport->flags |= FCF_CONF_COMP_SUPPORTED;
+ 		fcport->conf_compl_supported = 1;
+ 	}
+ 
+ gpd_error_out:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPDB_DONE;
+ 	ea.rc = rval;
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	dma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,
+ 		sp->u.iocb_cmd.u.mbx.in_dma);
+ 
+ 	sp->free(vha, sp);
+ }
+ 
+ static int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+     u8 opt)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPDB);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	e->u.fcport.opt = opt;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	u16 *mb;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GPDB;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gpdb";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_GET_PORT_DATABASE;
+ 	mb[1] = fcport->loop_id;
+ 	mb[2] = MSW(pd_dma);
+ 	mb[3] = LSW(pd_dma);
+ 	mb[6] = MSW(MSD(pd_dma));
+ 	mb[7] = LSW(MSD(pd_dma));
+ 	mb[9] = vha->vp_idx;
+ 	mb[10] = opt;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 	mbx->u.mbx.in = (void *)pd;
+ 	mbx->u.mbx.in_dma = pd_dma;
+ 
+ 	sp->done = qla24xx_async_gpdb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hndl %x opt %x\n",
+ 		sp->name, fcport->port_name, sp->handle, opt);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ 
+ 	sp->free(vha, sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	qla24xx_post_gpdb_work(vha, fcport, opt);
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	int rval = ea->rc;
+ 	fc_port_t *fcport = ea->fcport;
+ 	unsigned long flags;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
+ 	    fcport->disc_state, fcport->fw_login_state, rval);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 		return;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	ea->fcport->login_gen++;
+ 	ea->fcport->deleted = 0;
+ 	ea->fcport->logout_on_delete = 1;
+ 
+ 	if (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {
+ 		vha->fcport_count++;
+ 		ea->fcport->login_succ = 1;
+ 
+ 		if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 		    !vha->hw->flags.gpsc_supported) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_upd_fcport_work(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gpsc fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_gpsc_work(vha, fcport);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ } /* gpdb event */
+ 
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	if (fcport->login_retry == 0)
+ 		return 0;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND)
+ 		return 0;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
+ 	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
+ 	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
+ 	    fcport->loop_id);
+ 
+ 	fcport->login_retry--;
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PLOGI_COMP) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return 0;
+ 
+ 	/* for pure Target Mode. Login will not be initiated */
+ 	if (vha->host->active_mode == MODE_TARGET)
+ 		return 0;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return 0;
+ 	}
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gnl\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_async_gnl(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 		break;
+ 
+ 	case DSC_GNL:
+ 		if (fcport->login_pause) {
+ 			fcport->last_rscn_gen = fcport->rscn_gen;
+ 			fcport->last_login_gen = fcport->login_gen;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
+ 		}
+ 
+ 		if (fcport->flags & FCF_FCP2_DEVICE) {
+ 			u8 opt = PDO_FORCE_ADISC;
+ 
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 			fcport->disc_state = DSC_GPDB;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 
+ 		break;
+ 
+ 	case DSC_LOGIN_FAILED:
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gidpn \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		break;
+ 
+ 	case DSC_LOGIN_COMPLETE:
+ 		/* recheck login state */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gpdb_work(vha, fcport, PDO_FORCE_ADISC);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_rscn_event(fc_port_t *fcport, struct event_arg *ea)
+ {
+ 	fcport->rscn_gen++;
+ 
+ 	ql_dbg(ql_dbg_disc, fcport->vha, 0xffff,
+ 		"%s %8phC DS %d LS %d\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state);
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT)
+ 		return;
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 	case DSC_LOGIN_COMPLETE:
+ 		qla24xx_post_gidpn_work(fcport->vha, fcport);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,
+ 	u8 *port_name, void *pla)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.new_sess.id = *id;
+ 	e->u.new_sess.pla = pla;
+ 	memcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ int qla24xx_handle_delete_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	switch (vha->host->active_mode) {
+ 	case MODE_INITIATOR:
+ 	case MODE_DUAL:
+ 		if (fcport->scan_state == QLA_FCPORT_FOUND)
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 		break;
+ 
+ 	case MODE_TARGET:
+ 	default:
+ 		/* no-op */
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_relogin_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state, fcport->login_pause,
+ 		fcport->deleted, fcport->conflict,
+ 		fcport->last_rscn_gen, fcport->rscn_gen,
+ 		fcport->last_login_gen, fcport->login_gen,
+ 		fcport->flags);
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PLOGI_COMP) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		fcport->login_retry++;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_async_gidpn(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	qla24xx_fcport_handle_login(vha, fcport);
+ }
+ 
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *f, *tf;
+ 	uint32_t id = 0, mask, rid;
+ 	int rc;
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 
+ 		qla24xx_handle_relogin_event(vha, ea);
+ 		break;
+ 	case FCME_RSCN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 		switch (ea->id.b.rsvd_1) {
+ 		case RSCN_PORT_ADDR:
+ 			fcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);
+ 			if (!fcport) {
+ 				/* cable moved */
+ 				rc = qla24xx_post_gpnid_work(vha, &ea->id);
+ 				if (rc) {
+ 					ql_log(ql_log_warn, vha, 0xffff,
+ 						"RSCN GPNID work failed %02x%02x%02x\n",
+ 						ea->id.b.domain, ea->id.b.area,
+ 						ea->id.b.al_pa);
+ 				}
+ 			} else {
+ 				ea->fcport = fcport;
+ 				qla24xx_handle_rscn_event(fcport, ea);
+ 			}
+ 			break;
+ 		case RSCN_AREA_ADDR:
+ 		case RSCN_DOM_ADDR:
+ 			if (ea->id.b.rsvd_1 == RSCN_AREA_ADDR) {
+ 				mask = 0xffff00;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Area 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			} else {
+ 				mask = 0xff0000;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Domain 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			}
+ 
+ 			rid = ea->id.b24 & mask;
+ 			list_for_each_entry_safe(f, tf, &vha->vp_fcports,
+ 			    list) {
+ 				id = f->d_id.b24 & mask;
+ 				if (rid == id) {
+ 					ea->fcport = f;
+ 					qla24xx_handle_rscn_event(f, ea);
+ 				}
+ 			}
+ 			break;
+ 		case RSCN_FAB_ADDR:
+ 		default:
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 				"RSCN: Fabric was affected. Addr format %d\n",
+ 				ea->id.b.rsvd_1);
+ 			qla2x00_mark_all_devices_lost(vha, 1);
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 		}
+ 		break;
+ 	case FCME_GIDPN_DONE:
+ 		qla24xx_handle_gidpn_event(vha, ea);
+ 		break;
+ 	case FCME_GNL_DONE:
+ 		qla24xx_handle_gnl_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPSC_DONE:
+ 		qla24xx_post_upd_fcport_work(vha, ea->fcport);
+ 		break;
+ 	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
+ 		qla24xx_handle_plogi_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPDB_DONE:
+ 		qla24xx_handle_gpdb_event(vha, ea);
+ 		break;
+ 	case FCME_GPNID_DONE:
+ 		qla24xx_handle_gpnid_event(vha, ea);
+ 		break;
+ 	case FCME_DELETE_DONE:
+ 		qla24xx_handle_delete_done_event(vha, ea);
+ 		break;
+ 	default:
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
@@@ -3427,7 -4443,19 +4309,17 @@@ qla2x00_configure_fabric(scsi_qla_host_
  	}
  	vha->device_flags |= SWITCH_FOUND;
  
+ 
+ 	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {
+ 		rval = qla2x00_send_change_request(vha, 0x3, 0);
+ 		if (rval != QLA_SUCCESS)
+ 			ql_log(ql_log_warn, vha, 0x121,
+ 				"Failed to enable receiving of RSCN requests: 0x%x.\n",
+ 				rval);
+ 	}
+ 
+ 
  	do {
 -		qla2x00_mgmt_svr_login(vha);
 -
  		/* FDMI support. */
  		if (ql2xfdmienable &&
  		    test_and_clear_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags))
@@@ -6416,21 -7339,26 +7313,39 @@@ qla81xx_update_fw_options(scsi_qla_host
  			__func__, ha->fw_options[2]);
  	}
  
++<<<<<<< HEAD
 +	/* Set Retry FLOGI in case of P2P connection */
 +	if (ha->operating_mode == P2P) {
 +		ha->fw_options[2] |= BIT_3;
 +		ql_dbg(ql_dbg_disc, vha, 0x2103,
 +		    "(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\n",
 +			__func__, ha->fw_options[2]);
 +	}
 +
 +	if (!ql2xetsenable)
 +		goto out;
++=======
+ 	/* Move PUREX, ABTS RX & RIDA to ATIOQ */
+ 	if (ql2xmvasynctoatio) {
+ 		if (qla_tgt_mode_enabled(vha) ||
+ 		    qla_dual_mode_enabled(vha))
+ 			ha->fw_options[2] |= BIT_11;
+ 		else
+ 			ha->fw_options[2] &= ~BIT_11;
+ 	}
+ 
+ 	if (ql2xetsenable) {
+ 		/* Enable ETS Burst. */
+ 		memset(ha->fw_options, 0, sizeof(ha->fw_options));
+ 		ha->fw_options[2] |= BIT_9;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_init, vha, 0xffff,
+ 		"%s, add FW options 1-3 = 0x%04x 0x%04x 0x%04x mode %x\n",
+ 		__func__, ha->fw_options[1], ha->fw_options[2],
+ 		ha->fw_options[3], vha->host->active_mode);
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  
- 	/* Enable ETS Burst. */
- 	memset(ha->fw_options, 0, sizeof(ha->fw_options));
- 	ha->fw_options[2] |= BIT_9;
- out:
  	qla2x00_set_fw_options(vha, ha->fw_options);
  }
  
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 5ffd1682f367,d9577db7ddbb..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -988,9 -1025,6 +988,12 @@@ global_port_update
  
  		qla2x00_mark_all_devices_lost(vha, 1);
  
++<<<<<<< HEAD
 +		if (vha->vp_idx == 0 && !qla_ini_mode_enabled(vha))
 +			set_bit(SCR_PENDING, &vha->dpc_flags);
 +
++=======
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  		set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
  		set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
  		set_bit(VP_CONFIG_OK, &vha->vp_flags);
@@@ -1027,31 -1061,19 +1030,41 @@@
  		if (qla2x00_is_a_vp_did(vha, rscn_entry))
  			break;
  
 +		/*
 +		 * Search for the rport related to this RSCN entry and mark it
 +		 * as lost.
 +		 */
 +		list_for_each_entry(fcport, &vha->vp_fcports, list) {
 +			if (atomic_read(&fcport->state) != FCS_ONLINE)
 +				continue;
 +			if (fcport->d_id.b24 == rscn_entry) {
 +				/*
 +				 * Logout needs to be deferred here to prevent
 +				 * locking issues
 +				 */
 +				qla2x00_mark_device_lost(vha, fcport, 0, 1);
 +				break;
 +			}
 +		}
 +
  		atomic_set(&vha->loop_down_timer, 0);
  		vha->flags.management_server_logged_in = 0;
 -		{
 -			struct event_arg ea;
  
++<<<<<<< HEAD
 +		set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
 +		set_bit(RSCN_UPDATE, &vha->dpc_flags);
 +		qla2x00_post_aen_work(vha, FCH_EVT_RSCN, rscn_entry);
++=======
+ 			memset(&ea, 0, sizeof(ea));
+ 			ea.event = FCME_RSCN;
+ 			ea.id.b24 = rscn_entry;
+ 			ea.id.b.rsvd_1 = rscn_entry >> 24;
+ 			qla2x00_fcport_event_handler(vha, &ea);
+ 			qla2x00_post_aen_work(vha, FCH_EVT_RSCN, rscn_entry);
+ 		}
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  		break;
 +
  	/* case MBA_RIO_RESPONSE: */
  	case MBA_ZIO_RESPONSE:
  		ql_dbg(ql_dbg_async, vha, 0x5015,
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,1cd3734292f9..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -179,9 -203,134 +179,138 @@@ struct scsi_qla_host *qlt_find_host_by_
  	return NULL;
  }
  
 -static inline void qlt_incr_num_pend_cmds(struct scsi_qla_host *vha)
 +void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
 +	struct atio_from_isp *atio)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 
+ 	vha->hw->tgt.num_pend_cmds++;
+ 	if (vha->hw->tgt.num_pend_cmds > vha->qla_stats.stat_max_pend_cmds)
+ 		vha->qla_stats.stat_max_pend_cmds =
+ 			vha->hw->tgt.num_pend_cmds;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ static inline void qlt_decr_num_pend_cmds(struct scsi_qla_host *vha)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);
+ 	vha->hw->tgt.num_pend_cmds--;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);
+ }
+ 
+ 
+ static void qlt_queue_unknown_atio(scsi_qla_host_t *vha,
+ 	struct atio_from_isp *atio,	uint8_t ha_locked)
+ {
+ 	struct qla_tgt_sess_op *u;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	unsigned long flags;
+ 
+ 	if (tgt->tgt_stop) {
+ 		ql_dbg(ql_dbg_async, vha, 0xffff,
+ 			   "qla_target(%d): dropping unknown ATIO_TYPE7, "
+ 			   "because tgt is being stopped", vha->vp_idx);
+ 		goto out_term;
+ 	}
+ 
+ 	u = kzalloc(sizeof(*u), GFP_ATOMIC);
+ 	if (u == NULL) {
+ 		ql_dbg(ql_dbg_async, vha, 0xffff,
+ 		    "Alloc of struct unknown_atio (size %zd) failed", sizeof(*u));
+ 		/* It should be harmless and on the next retry should work well */
+ 		goto out_term;
+ 	}
+ 
+ 	u->vha = vha;
+ 	memcpy(&u->atio, atio, sizeof(*atio));
+ 	INIT_LIST_HEAD(&u->cmd_list);
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_add_tail(&u->cmd_list, &vha->unknown_atio_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	schedule_delayed_work(&vha->unknown_atio_work, 1);
+ 
+ out:
+ 	return;
+ 
+ out_term:
+ 	qlt_send_term_exchange(vha, NULL, atio, ha_locked, 0);
+ 	goto out;
+ }
+ 
+ static void qlt_try_to_dequeue_unknown_atios(struct scsi_qla_host *vha,
+ 	uint8_t ha_locked)
+ {
+ 	struct qla_tgt_sess_op *u, *t;
+ 	scsi_qla_host_t *host;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	unsigned long flags;
+ 	uint8_t queued = 0;
+ 
+ 	list_for_each_entry_safe(u, t, &vha->unknown_atio_list, cmd_list) {
+ 		if (u->aborted) {
+ 			ql_dbg(ql_dbg_async, vha, 0xffff,
+ 			    "Freeing unknown %s %p, because of Abort",
+ 			    "ATIO_TYPE7", u);
+ 			qlt_send_term_exchange(vha, NULL, &u->atio,
+ 			    ha_locked, 0);
+ 			goto abort;
+ 		}
+ 
+ 		host = qlt_find_host_by_d_id(vha, u->atio.u.isp24.fcp_hdr.d_id);
+ 		if (host != NULL) {
+ 			ql_dbg(ql_dbg_async, vha, 0xffff,
+ 				"Requeuing unknown ATIO_TYPE7 %p", u);
+ 			qlt_24xx_atio_pkt(host, &u->atio, ha_locked);
+ 		} else if (tgt->tgt_stop) {
+ 			ql_dbg(ql_dbg_async, vha, 0xffff,
+ 				"Freeing unknown %s %p, because tgt is being stopped",
+ 				"ATIO_TYPE7", u);
+ 			qlt_send_term_exchange(vha, NULL, &u->atio,
+ 			    ha_locked, 0);
+ 		} else {
+ 			ql_dbg(ql_dbg_async, vha, 0xffff,
+ 				"u %p, vha %p, host %p, sched again..", u,
+ 				vha, host);
+ 			if (!queued) {
+ 				queued = 1;
+ 				schedule_delayed_work(&vha->unknown_atio_work,
+ 				    1);
+ 			}
+ 			continue;
+ 		}
+ 
+ abort:
+ 		spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 		list_del(&u->cmd_list);
+ 		spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 		kfree(u);
+ 	}
+ }
+ 
+ void qlt_unknown_atio_work_fn(struct work_struct *work)
+ {
+ 	struct scsi_qla_host *vha = container_of(to_delayed_work(work),
+ 	    struct scsi_qla_host, unknown_atio_work);
+ 
+ 	qlt_try_to_dequeue_unknown_atios(vha, 0);
+ }
+ 
+ static bool qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,
+ 	struct atio_from_isp *atio, uint8_t ha_locked)
+ {
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe072,
+ 		"%s: qla_target(%d): type %x ox_id %04x\n",
+ 		__func__, vha->vp_idx, atio->u.raw.entry_type,
+ 		be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  	switch (atio->u.raw.entry_type) {
  	case ATIO_TYPE7:
  	{
@@@ -194,9 -343,15 +323,19 @@@
  			    atio->u.isp24.fcp_hdr.d_id[0],
  			    atio->u.isp24.fcp_hdr.d_id[1],
  			    atio->u.isp24.fcp_hdr.d_id[2]);
+ 
+ 
+ 			qlt_queue_unknown_atio(vha, atio, ha_locked);
  			break;
  		}
++<<<<<<< HEAD
 +		qlt_24xx_atio_pkt(host, atio);
++=======
+ 		if (unlikely(!list_empty(&vha->unknown_atio_list)))
+ 			qlt_try_to_dequeue_unknown_atios(vha, ha_locked);
+ 
+ 		qlt_24xx_atio_pkt(host, atio, ha_locked);
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  		break;
  	}
  
@@@ -340,29 -918,157 +504,172 @@@ static void qlt_free_session_done(struc
  	struct qla_tgt *tgt = sess->tgt;
  	struct scsi_qla_host *vha = sess->vha;
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 	unsigned long flags;
+ 	bool logout_started = false;
+ 	struct event_arg ea;
+ 	scsi_qla_host_t *base_vha;
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,
+ 		"%s: se_sess %p / sess %p from port %8phC loop_id %#04x"
+ 		" s_id %02x:%02x:%02x logout %d keep %d els_logo %d\n",
+ 		__func__, sess->se_sess, sess, sess->port_name, sess->loop_id,
+ 		sess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,
+ 		sess->logout_on_delete, sess->keep_nport_handle,
+ 		sess->send_els_logo);
+ 
+ 
+ 	if (!IS_SW_RESV_ADDR(sess->d_id)) {
+ 		if (sess->send_els_logo) {
+ 			qlt_port_logo_t logo;
+ 
+ 			logo.id = sess->d_id;
+ 			logo.cmd_count = 0;
+ 			qlt_send_first_logo(vha, &logo);
+ 		}
+ 
+ 		if (sess->logout_on_delete) {
+ 			int rc;
+ 
+ 			rc = qla2x00_post_async_logout_work(vha, sess, NULL);
+ 			if (rc != QLA_SUCCESS)
+ 				ql_log(ql_log_warn, vha, 0xf085,
+ 				    "Schedule logo failed sess %p rc %d\n",
+ 				    sess, rc);
+ 			else
+ 				logout_started = true;
+ 		}
+ 	}
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  
 +	BUG_ON(!tgt);
  	/*
  	 * Release the target session for FC Nexus from fabric module code.
  	 */
  	if (sess->se_sess != NULL)
  		ha->tgt.tgt_ops->free_session(sess);
  
++<<<<<<< HEAD
++=======
+ 	if (logout_started) {
+ 		bool traced = false;
+ 
+ 		while (!ACCESS_ONCE(sess->logout_completed)) {
+ 			if (!traced) {
+ 				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf086,
+ 					"%s: waiting for sess %p logout\n",
+ 					__func__, sess);
+ 				traced = true;
+ 			}
+ 			msleep(100);
+ 		}
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xf087,
+ 		    "%s: sess %p logout completed\n",__func__, sess);
+ 	}
+ 
+ 	if (sess->logo_ack_needed) {
+ 		sess->logo_ack_needed = 0;
+ 		qla24xx_async_notify_ack(vha, sess,
+ 			(struct imm_ntfy_from_isp *)sess->iocb, SRB_NACK_LOGO);
+ 	}
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	if (sess->se_sess) {
+ 		sess->se_sess = NULL;
+ 		if (tgt && !IS_SW_RESV_ADDR(sess->d_id))
+ 			tgt->sess_count--;
+ 	}
+ 
+ 	sess->disc_state = DSC_DELETED;
+ 	sess->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 	sess->deleted = QLA_SESS_DELETED;
+ 	sess->login_retry = vha->hw->login_retry_count;
+ 
+ 	if (sess->login_succ && !IS_SW_RESV_ADDR(sess->d_id)) {
+ 		vha->fcport_count--;
+ 		sess->login_succ = 0;
+ 	}
+ 
+ 	if (sess->chip_reset != sess->vha->hw->chip_reset)
+ 		qla2x00_clear_loop_id(sess);
+ 
+ 	if (sess->conflict) {
+ 		sess->conflict->login_pause = 0;
+ 		sess->conflict = NULL;
+ 		if (!test_bit(UNLOADING, &vha->dpc_flags))
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 	}
+ 
+ 	{
+ 		struct qlt_plogi_ack_t *own =
+ 		    sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN];
+ 		struct qlt_plogi_ack_t *con =
+ 		    sess->plogi_link[QLT_PLOGI_LINK_CONFLICT];
+ 		struct imm_ntfy_from_isp *iocb;
+ 
+ 		if (con) {
+ 			iocb = &con->iocb;
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf099,
+ 				 "se_sess %p / sess %p port %8phC is gone,"
+ 				 " %s (ref=%d), releasing PLOGI for %8phC (ref=%d)\n",
+ 				 sess->se_sess, sess, sess->port_name,
+ 				 own ? "releasing own PLOGI" : "no own PLOGI pending",
+ 				 own ? own->ref_count : -1,
+ 				 iocb->u.isp24.port_name, con->ref_count);
+ 			qlt_plogi_ack_unref(vha, con);
+ 			sess->plogi_link[QLT_PLOGI_LINK_CONFLICT] = NULL;
+ 		} else {
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09a,
+ 			    "se_sess %p / sess %p port %8phC is gone, %s (ref=%d)\n",
+ 			    sess->se_sess, sess, sess->port_name,
+ 			    own ? "releasing own PLOGI" :
+ 			    "no own PLOGI pending",
+ 			    own ? own->ref_count : -1);
+ 		}
+ 
+ 		if (own) {
+ 			sess->fw_login_state = DSC_LS_PLOGI_PEND;
+ 			qlt_plogi_ack_unref(vha, own);
+ 			sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN] = NULL;
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf001,
 -	    "Unregistration of sess %p %8phC finished fcp_cnt %d\n",
 -		sess, sess->port_name, vha->fcport_count);
 +	    "Unregistration of sess %p finished\n", sess);
  
 -	if (tgt && (tgt->sess_count == 0))
 +	kfree(sess);
 +	/*
 +	 * We need to protect against race, when tgt is freed before or
 +	 * inside wake_up()
 +	 */
 +	tgt->sess_count--;
 +	if (tgt->sess_count == 0)
  		wake_up_all(&tgt->waitQ);
++<<<<<<< HEAD
++=======
+ 
+ 	if (vha->fcport_count == 0)
+ 		wake_up_all(&vha->fcport_waitQ);
+ 
+ 	base_vha = pci_get_drvdata(ha->pdev);
+ 	if (test_bit(PFLG_DRIVER_REMOVING, &base_vha->pci_flags))
+ 		return;
+ 
+ 	if (!tgt || !tgt->tgt_stop) {
+ 		memset(&ea, 0, sizeof(ea));
+ 		ea.event = FCME_DELETE_DONE;
+ 		ea.fcport = sess;
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  }
  
 -/* ha->tgt.sess_lock supposed to be held on entry */
 -void qlt_unreg_sess(struct fc_port *sess)
 +/* ha->hardware_lock supposed to be held on entry */
 +void qlt_unreg_sess(struct qla_tgt_sess *sess)
  {
  	struct scsi_qla_host *vha = sess->vha;
  
@@@ -1238,9 -1729,93 +1545,96 @@@ static void qlt_24xx_retry_term_exchang
  	    FCP_TMF_CMPL, true);
  }
  
++<<<<<<< HEAD
++=======
+ static int abort_cmd_for_tag(struct scsi_qla_host *vha, uint32_t tag)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 
+ 	spin_lock(&vha->cmd_list_lock);
+ 
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		if (tag == op->atio.u.isp24.exchange_addr) {
+ 			op->aborted = true;
+ 			spin_unlock(&vha->cmd_list_lock);
+ 			return 1;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
+ 		if (tag == op->atio.u.isp24.exchange_addr) {
+ 			op->aborted = true;
+ 			spin_unlock(&vha->cmd_list_lock);
+ 			return 1;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		if (tag == cmd->atio.u.isp24.exchange_addr) {
+ 			cmd->aborted = 1;
+ 			spin_unlock(&vha->cmd_list_lock);
+ 			return 1;
+ 		}
+ 	}
+ 
+ 	spin_unlock(&vha->cmd_list_lock);
+ 	return 0;
+ }
+ 
+ /* drop cmds for the given lun
+  * XXX only looks for cmds on the port through which lun reset was recieved
+  * XXX does not go through the list of other port (which may have cmds
+  *     for the same lun)
+  */
+ static void abort_cmds_for_lun(struct scsi_qla_host *vha,
+ 				uint32_t lun, uint8_t *s_id)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 	uint32_t key;
+ 
+ 	key = sid_to_key(s_id);
+ 	spin_lock(&vha->cmd_list_lock);
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		uint32_t op_key;
+ 		uint32_t op_lun;
+ 
+ 		op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		op_lun = scsilun_to_int(
+ 			(struct scsi_lun *)&op->atio.u.isp24.fcp_cmnd.lun);
+ 		if (op_key == key && op_lun == lun)
+ 			op->aborted = true;
+ 	}
+ 
+ 	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
+ 		uint32_t op_key;
+ 		u64 op_lun;
+ 
+ 		op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		op_lun = scsilun_to_int(
+ 			(struct scsi_lun *)&op->atio.u.isp24.fcp_cmnd.lun);
+ 		if (op_key == key && op_lun == lun)
+ 			op->aborted = true;
+ 	}
+ 
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		uint32_t cmd_key;
+ 		uint32_t cmd_lun;
+ 
+ 		cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
+ 		cmd_lun = scsilun_to_int(
+ 			(struct scsi_lun *)&cmd->atio.u.isp24.fcp_cmnd.lun);
+ 		if (cmd_key == key && cmd_lun == lun)
+ 			cmd->aborted = 1;
+ 	}
+ 	spin_unlock(&vha->cmd_list_lock);
+ }
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  /* ha->hardware_lock supposed to be held on entry */
  static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,
 -	struct abts_recv_from_24xx *abts, struct fc_port *sess)
 +	struct abts_recv_from_24xx *abts, struct qla_tgt_sess *sess)
  {
  	struct qla_hw_data *ha = vha->hw;
  	struct se_session *se_sess = sess->se_sess;
@@@ -1423,10 -2025,38 +1817,45 @@@ void qlt_xmit_tm_rsp(struct qla_tgt_mgm
  	    mcmd, mcmd->fc_tm_rsp, mcmd->flags);
  
  	spin_lock_irqsave(&ha->hardware_lock, flags);
++<<<<<<< HEAD
 +	if (mcmd->flags == QLA24XX_MGMT_SEND_NACK)
 +		qlt_send_notify_ack(vha, &mcmd->orig_iocb.imm_ntfy,
 +		    0, 0, 0, 0, 0, 0);
 +	else {
++=======
+ 
+ 	if (!vha->flags.online || mcmd->reset_count != ha->chip_reset) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		ql_dbg(ql_dbg_async, vha, 0xe100,
+ 			"RESET-TMR online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			mcmd->reset_count, ha->chip_reset);
+ 		ha->tgt.tgt_ops->free_mcmd(mcmd);
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (mcmd->flags == QLA24XX_MGMT_SEND_NACK) {
+ 		if (mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode ==
+ 		    ELS_LOGO ||
+ 		    mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode ==
+ 		    ELS_PRLO ||
+ 		    mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode ==
+ 		    ELS_TPRLO) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "TM response logo %phC status %#x state %#x",
+ 			    mcmd->sess->port_name, mcmd->fc_tm_rsp,
+ 			    mcmd->flags);
+ 			qlt_schedule_sess_for_deletion_lock(mcmd->sess);
+ 		} else {
+ 			qlt_send_notify_ack(vha, &mcmd->orig_iocb.imm_ntfy,
+ 				0, 0, 0, 0, 0, 0);
+ 		}
+ 	} else {
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  		if (mcmd->orig_iocb.atio.u.raw.entry_type == ABTS_RECV_24XX)
  			qlt_24xx_send_abts_resp(vha, &mcmd->orig_iocb.abts,
  			    mcmd->fc_tm_rsp, false);
@@@ -2955,26 -4311,377 +3384,283 @@@ static int qlt_abort_task(struct scsi_q
  	return __qlt_abort_task(vha, iocb, sess);
  }
  
++<<<<<<< HEAD
++=======
+ void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
+ {
+ 	if (rc != MBS_COMMAND_COMPLETE) {
+ 		ql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,
+ 			"%s: se_sess %p / sess %p from"
+ 			" port %8phC loop_id %#04x s_id %02x:%02x:%02x"
+ 			" LOGO failed: %#x\n",
+ 			__func__,
+ 			fcport->se_sess,
+ 			fcport,
+ 			fcport->port_name, fcport->loop_id,
+ 			fcport->d_id.b.domain, fcport->d_id.b.area,
+ 			fcport->d_id.b.al_pa, rc);
+ 	}
+ 
+ 	fcport->logout_completed = 1;
+ }
+ 
+ /*
+ * ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)
+ *
+ * Schedules sessions with matching port_id/loop_id but different wwn for
+ * deletion. Returns existing session with matching wwn if present.
+ * Null otherwise.
+ */
+ struct fc_port *
+ qlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,
+     port_id_t port_id, uint16_t loop_id, struct fc_port **conflict_sess)
+ {
+ 	struct fc_port *sess = NULL, *other_sess;
+ 	uint64_t other_wwn;
+ 
+ 	*conflict_sess = NULL;
+ 
+ 	list_for_each_entry(other_sess, &vha->vp_fcports, list) {
+ 
+ 		other_wwn = wwn_to_u64(other_sess->port_name);
+ 
+ 		if (wwn == other_wwn) {
+ 			WARN_ON(sess);
+ 			sess = other_sess;
+ 			continue;
+ 		}
+ 
+ 		/* find other sess with nport_id collision */
+ 		if (port_id.b24 == other_sess->d_id.b24) {
+ 			if (loop_id != other_sess->loop_id) {
+ 				ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000c,
+ 				    "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 				    other_sess, other_sess->loop_id, other_wwn);
+ 
+ 				/*
+ 				 * logout_on_delete is set by default, but another
+ 				 * session that has the same s_id/loop_id combo
+ 				 * might have cleared it when requested this session
+ 				 * deletion, so don't touch it
+ 				 */
+ 				qlt_schedule_sess_for_deletion(other_sess, true);
+ 			} else {
+ 				/*
+ 				 * Another wwn used to have our s_id/loop_id
+ 				 * kill the session, but don't free the loop_id
+ 				 */
+ 				ql_dbg(ql_dbg_tgt_tmr, vha, 0xffff,
+ 				    "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 				    other_sess, other_sess->loop_id, other_wwn);
+ 
+ 
+ 				other_sess->keep_nport_handle = 1;
+ 				*conflict_sess = other_sess;
+ 				qlt_schedule_sess_for_deletion(other_sess,
+ 				    true);
+ 			}
+ 			continue;
+ 		}
+ 
+ 		/* find other sess with nport handle collision */
+ 		if ((loop_id == other_sess->loop_id) &&
+ 			(loop_id != FC_NO_LOOP_ID)) {
+ 			ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000d,
+ 			       "Invalidating sess %p loop_id %d wwn %llx.\n",
+ 			       other_sess, other_sess->loop_id, other_wwn);
+ 
+ 			/* Same loop_id but different s_id
+ 			 * Ok to kill and logout */
+ 			qlt_schedule_sess_for_deletion(other_sess, true);
+ 		}
+ 	}
+ 
+ 	return sess;
+ }
+ 
+ /* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */
+ static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)
+ {
+ 	struct qla_tgt_sess_op *op;
+ 	struct qla_tgt_cmd *cmd;
+ 	uint32_t key;
+ 	int count = 0;
+ 
+ 	key = (((u32)s_id->b.domain << 16) |
+ 	       ((u32)s_id->b.area   <<  8) |
+ 	       ((u32)s_id->b.al_pa));
+ 
+ 	spin_lock(&vha->cmd_list_lock);
+ 	list_for_each_entry(op, &vha->qla_sess_op_cmd_list, cmd_list) {
+ 		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 
+ 		if (op_key == key) {
+ 			op->aborted = true;
+ 			count++;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {
+ 		uint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);
+ 		if (op_key == key) {
+ 			op->aborted = true;
+ 			count++;
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {
+ 		uint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);
+ 		if (cmd_key == key) {
+ 			cmd->aborted = 1;
+ 			count++;
+ 		}
+ 	}
+ 	spin_unlock(&vha->cmd_list_lock);
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
  static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
  	struct imm_ntfy_from_isp *iocb)
  {
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
  	struct qla_hw_data *ha = vha->hw;
 -	struct fc_port *sess = NULL, *conflict_sess = NULL;
 -	uint64_t wwn;
 -	port_id_t port_id;
 -	uint16_t loop_id;
 -	uint16_t wd3_lo;
  	int res = 0;
 -	struct qlt_plogi_ack_t *pla;
 -	unsigned long flags;
 -
 -	wwn = wwn_to_u64(iocb->u.isp24.port_name);
 -
 -	port_id.b.domain = iocb->u.isp24.port_id[2];
 -	port_id.b.area   = iocb->u.isp24.port_id[1];
 -	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
 -	port_id.b.rsvd_1 = 0;
 -
 -	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
  
 -	ql_dbg(ql_dbg_disc, vha, 0xf026,
 -	    "qla_target(%d): Port ID: %02x:%02x:%02x ELS opcode: 0x%02x lid %d %8phC\n",
 -	    vha->vp_idx, iocb->u.isp24.port_id[2],
 -		iocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],
 -		   iocb->u.isp24.status_subcode, loop_id,
 -		iocb->u.isp24.port_name);
 +	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
 +	    "qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",
 +	    vha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);
  
 -	/* res = 1 means ack at the end of thread
 -	 * res = 0 means ack async/later.
 -	 */
  	switch (iocb->u.isp24.status_subcode) {
  	case ELS_PLOGI:
 -
 -		/* Mark all stale commands in qla_tgt_wq for deletion */
 -		abort_cmds_for_s_id(vha, &port_id);
 -
 -		if (wwn) {
 -			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 -			sess = qlt_find_sess_invalidate_other(vha, wwn,
 -				port_id, loop_id, &conflict_sess);
 -			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 -		}
 -
 -		if (IS_SW_RESV_ADDR(port_id)) {
 -			res = 1;
 -			break;
 -		}
 -
 -		pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
 -		if (!pla) {
 -			qlt_send_term_imm_notif(vha, iocb, 1);
 -			break;
 -		}
 -
 -		res = 0;
 -
 -		if (conflict_sess) {
 -			conflict_sess->login_gen++;
 -			qlt_plogi_ack_link(vha, pla, conflict_sess,
 -				QLT_PLOGI_LINK_CONFLICT);
 -		}
 -
 -		if (!sess) {
 -			pla->ref_count++;
 -			qla24xx_post_newsess_work(vha, &port_id,
 -				iocb->u.isp24.port_name, pla);
 -			res = 0;
 -			break;
 -		}
 -
 -		qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
 -		sess->fw_login_state = DSC_LS_PLOGI_PEND;
 -		sess->d_id = port_id;
 -		sess->login_gen++;
 -
 -		switch (sess->disc_state) {
 -		case DSC_DELETED:
 -			qlt_plogi_ack_unref(vha, pla);
 -			break;
 -
 -		default:
 -			/*
 -			 * Under normal circumstances we want to release nport handle
 -			 * during LOGO process to avoid nport handle leaks inside FW.
 -			 * The exception is when LOGO is done while another PLOGI with
 -			 * the same nport handle is waiting as might be the case here.
 -			 * Note: there is always a possibily of a race where session
 -			 * deletion has already started for other reasons (e.g. ACL
 -			 * removal) and now PLOGI arrives:
 -			 * 1. if PLOGI arrived in FW after nport handle has been freed,
 -			 *    FW must have assigned this PLOGI a new/same handle and we
 -			 *    can proceed ACK'ing it as usual when session deletion
 -			 *    completes.
 -			 * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
 -			 *    bit reached it, the handle has now been released. We'll
 -			 *    get an error when we ACK this PLOGI. Nothing will be sent
 -			 *    back to initiator. Initiator should eventually retry
 -			 *    PLOGI and situation will correct itself.
 -			 */
 -			sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
 -			   (sess->d_id.b24 == port_id.b24));
 -
 -			ql_dbg(ql_dbg_disc, vha, 0xffff,
 -				   "%s %d %8phC post del sess\n",
 -				   __func__, __LINE__, sess->port_name);
 -
 -
 -			qlt_schedule_sess_for_deletion_lock(sess);
 -			break;
 -		}
 -
 -		break;
 -
 +	case ELS_FLOGI:
  	case ELS_PRLI:
++<<<<<<< HEAD
 +	case ELS_LOGO:
 +	case ELS_PRLO:
 +		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
++=======
+ 		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
+ 
+ 		if (wwn) {
+ 			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
+ 			sess = qlt_find_sess_invalidate_other(vha, wwn, port_id,
+ 				loop_id, &conflict_sess);
+ 			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
+ 		}
+ 
+ 		if (conflict_sess) {
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf09b,
+ 			    "PRLI with conflicting sess %p port %8phC\n",
+ 			    conflict_sess, conflict_sess->port_name);
+ 			qlt_send_term_imm_notif(vha, iocb, 1);
+ 			res = 0;
+ 			break;
+ 		}
+ 
+ 		if (sess != NULL) {
+ 			if (sess->fw_login_state == DSC_LS_PLOGI_PEND) {
+ 				/*
+ 				 * Impatient initiator sent PRLI before last
+ 				 * PLOGI could finish. Will force him to re-try,
+ 				 * while last one finishes.
+ 				 */
+ 				ql_log(ql_log_warn, sess->vha, 0xf095,
+ 				    "sess %p PRLI received, before plogi ack.\n",
+ 				    sess);
+ 				qlt_send_term_imm_notif(vha, iocb, 1);
+ 				res = 0;
+ 				break;
+ 			}
+ 
+ 			/*
+ 			 * This shouldn't happen under normal circumstances,
+ 			 * since we have deleted the old session during PLOGI
+ 			 */
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,
+ 			    "PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\n",
+ 			    sess->loop_id, sess, iocb->u.isp24.nport_handle);
+ 
+ 			sess->local = 0;
+ 			sess->loop_id = loop_id;
+ 			sess->d_id = port_id;
+ 			sess->fw_login_state = DSC_LS_PRLI_PEND;
+ 
+ 			if (wd3_lo & BIT_7)
+ 				sess->conf_compl_supported = 1;
+ 
+ 			if ((wd3_lo & BIT_4) == 0)
+ 				sess->port_type = FCT_INITIATOR;
+ 			else
+ 				sess->port_type = FCT_TARGET;
+ 		}
+ 		res = 1; /* send notify ack */
+ 
+ 		/* Make session global (not used in fabric mode) */
+ 		if (ha->current_topology != ISP_CFG_F) {
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 			qla2xxx_wake_dpc(vha);
+ 		} else {
+ 			if (sess) {
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					   "%s %d %8phC post nack\n",
+ 					   __func__, __LINE__, sess->port_name);
+ 
+ 				qla24xx_post_nack_work(vha, sess, iocb,
+ 					SRB_NACK_PRLI);
+ 				res = 0;
+ 			}
+ 		}
+ 		break;
+ 
+ 
+ 	case ELS_TPRLO:
+ 		if (le16_to_cpu(iocb->u.isp24.flags) &
+ 			NOTIFY24XX_FLAGS_GLOBAL_TPRLO) {
+ 			loop_id = 0xFFFF;
+ 			qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS);
+ 			res = 1;
+ 			break;
+ 		}
+ 		/* drop through */
+ 	case ELS_LOGO:
+ 	case ELS_PRLO:
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		sess = qla2x00_find_fcport_by_loopid(vha, loop_id);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 
+ 		if (sess) {
+ 			sess->login_gen++;
+ 			sess->fw_login_state = DSC_LS_LOGO_PEND;
+ 			sess->logo_ack_needed = 1;
+ 			memcpy(sess->iocb, iocb, IOCB_SIZE);
+ 		}
+ 
+ 		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s: logo %llx res %d sess %p ",
+ 		    __func__, wwn, res, sess);
+ 		if (res == 0) {
+ 			/*
+ 			 * cmd went upper layer, look for qlt_xmit_tm_rsp()
+ 			 * for LOGO_ACK & sess delete
+ 			 */
+ 			BUG_ON(!sess);
+ 			res = 0;
+ 		} else {
+ 			/* cmd did not go to upper layer. */
+ 			if (sess) {
+ 				qlt_schedule_sess_for_deletion_lock(sess);
+ 				res = 0;
+ 			}
+ 			/* else logo will be ack */
+ 		}
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  		break;
  	case ELS_PDISC:
  	case ELS_ADISC:
@@@ -4936,8 -6592,13 +5622,18 @@@ qlt_probe_one_stage1(struct scsi_qla_ho
  		ISP_ATIO_Q_OUT(base_vha) = &ha->iobase->isp24.atio_q_out;
  	}
  
++<<<<<<< HEAD
 +	mutex_init(&ha->tgt.tgt_mutex);
 +	mutex_init(&ha->tgt.tgt_host_action_mutex);
++=======
+ 	mutex_init(&base_vha->vha_tgt.tgt_mutex);
+ 	mutex_init(&base_vha->vha_tgt.tgt_host_action_mutex);
+ 
+ 	INIT_LIST_HEAD(&base_vha->unknown_atio_list);
+ 	INIT_DELAYED_WORK(&base_vha->unknown_atio_work,
+ 	    qlt_unknown_atio_work_fn);
+ 
++>>>>>>> 41dc529a4602 (qla2xxx: Improve RSCN handling in driver)
  	qlt_clear_mode(base_vha);
  }
  
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 8a2368b32dec..dcc7475513fd 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -1270,27 +1270,76 @@ struct vp_config_entry_24xx {
 };
 
 #define VP_RPT_ID_IOCB_TYPE	0x32	/* Report ID Acquisition entry. */
+enum VP_STATUS {
+	VP_STAT_COMPL,
+	VP_STAT_FAIL,
+	VP_STAT_ID_CHG,
+	VP_STAT_SNS_TO,				/* timeout */
+	VP_STAT_SNS_RJT,
+	VP_STAT_SCR_TO,				/* timeout */
+	VP_STAT_SCR_RJT,
+};
+
+enum VP_FLAGS {
+	VP_FLAGS_CON_FLOOP = 1,
+	VP_FLAGS_CON_P2P = 2,
+	VP_FLAGS_CON_FABRIC = 3,
+	VP_FLAGS_NAME_VALID = BIT_5,
+};
+
 struct vp_rpt_id_entry_24xx {
 	uint8_t entry_type;		/* Entry type. */
 	uint8_t entry_count;		/* Entry count. */
 	uint8_t sys_define;		/* System defined. */
 	uint8_t entry_status;		/* Entry Status. */
-
-	uint32_t handle;		/* System handle. */
-
-	uint16_t vp_count;		/* Format 0 -- | VP setup | VP acq |. */
-					/* Format 1 -- | VP count |. */
-	uint16_t vp_idx;		/* Format 0 -- Reserved. */
-					/* Format 1 -- VP status and index. */
+	uint32_t resv1;
+	uint8_t vp_acquired;
+	uint8_t vp_setup;
+	uint8_t vp_idx;		/* Format 0=reserved */
+	uint8_t vp_status;	/* Format 0=reserved */
 
 	uint8_t port_id[3];
 	uint8_t format;
-
-	uint8_t vp_idx_map[16];
-
-	uint8_t reserved_4[24];
-	uint16_t bbcr;
-	uint8_t reserved_5[6];
+	union {
+		struct {
+			/* format 0 loop */
+			uint8_t vp_idx_map[16];
+			uint8_t reserved_4[32];
+		} f0;
+		struct {
+			/* format 1 fabric */
+			uint8_t vpstat1_subcode; /* vp_status=1 subcode */
+			uint8_t flags;
+			uint16_t fip_flags;
+			uint8_t rsv2[12];
+
+			uint8_t ls_rjt_vendor;
+			uint8_t ls_rjt_explanation;
+			uint8_t ls_rjt_reason;
+			uint8_t rsv3[5];
+
+			uint8_t port_name[8];
+			uint8_t node_name[8];
+			uint16_t bbcr;
+			uint8_t reserved_5[6];
+		} f1;
+		struct { /* format 2: N2N direct connect */
+		    uint8_t vpstat1_subcode;
+		    uint8_t flags;
+		    uint16_t rsv6;
+		    uint8_t rsv2[12];
+
+		    uint8_t ls_rjt_vendor;
+		    uint8_t ls_rjt_explanation;
+		    uint8_t ls_rjt_reason;
+		    uint8_t rsv3[5];
+
+		    uint8_t port_name[8];
+		    uint8_t node_name[8];
+		    uint32_t remote_nport_id;
+		    uint32_t reserved_5;
+		} f2;
+	} u;
 };
 
 #define VF_EVFP_IOCB_TYPE       0x26    /* Exchange Virtual Fabric Parameters entry. */
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_gs.c
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index b8143a854ee5..f2c874a3e251 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -3415,10 +3415,8 @@ void
 qla24xx_report_id_acquisition(scsi_qla_host_t *vha,
 	struct vp_rpt_id_entry_24xx *rptid_entry)
 {
-	uint8_t vp_idx;
-	uint16_t stat = le16_to_cpu(rptid_entry->vp_idx);
 	struct qla_hw_data *ha = vha->hw;
-	scsi_qla_host_t *vp;
+	scsi_qla_host_t *vp = NULL;
 	unsigned long   flags;
 	int found;
 
@@ -3429,80 +3427,124 @@ qla24xx_report_id_acquisition(scsi_qla_host_t *vha,
 		return;
 
 	if (rptid_entry->format == 0) {
+		/* loop */
 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b7,
 		    "Format 0 : Number of VPs setup %d, number of "
-		    "VPs acquired %d.\n",
-		    MSB(le16_to_cpu(rptid_entry->vp_count)),
-		    LSB(le16_to_cpu(rptid_entry->vp_count)));
+		    "VPs acquired %d.\n", rptid_entry->vp_setup,
+		    rptid_entry->vp_acquired);
 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b8,
 		    "Primary port id %02x%02x%02x.\n",
 		    rptid_entry->port_id[2], rptid_entry->port_id[1],
 		    rptid_entry->port_id[0]);
+
+		vha->d_id.b.domain = rptid_entry->port_id[2];
+		vha->d_id.b.area = rptid_entry->port_id[1];
+		vha->d_id.b.al_pa = rptid_entry->port_id[0];
+
+		spin_lock_irqsave(&ha->vport_slock, flags);
+		qlt_update_vp_map(vha, SET_AL_PA);
+		spin_unlock_irqrestore(&ha->vport_slock, flags);
+
 	} else if (rptid_entry->format == 1) {
-		vp_idx = LSB(stat);
+		/* fabric */
 		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b9,
 		    "Format 1: VP[%d] enabled - status %d - with "
-		    "port id %02x%02x%02x.\n", vp_idx, MSB(stat),
+		    "port id %02x%02x%02x.\n", rptid_entry->vp_idx,
+			rptid_entry->vp_status,
 		    rptid_entry->port_id[2], rptid_entry->port_id[1],
 		    rptid_entry->port_id[0]);
 
 		/* buffer to buffer credit flag */
-		vha->flags.bbcr_enable = (rptid_entry->bbcr & 0xf) != 0;
-
-		/* FA-WWN is only for physical port */
-		if (!vp_idx) {
-			void *wwpn = ha->init_cb->port_name;
+		vha->flags.bbcr_enable = (rptid_entry->u.f1.bbcr & 0xf) != 0;
+
+		if (rptid_entry->vp_idx == 0) {
+			if (rptid_entry->vp_status == VP_STAT_COMPL) {
+				/* FA-WWN is only for physical port */
+				if (qla_ini_mode_enabled(vha) &&
+				    ha->flags.fawwpn_enabled &&
+				    (rptid_entry->u.f1.flags &
+				     VP_FLAGS_NAME_VALID)) {
+					memcpy(vha->port_name,
+					    rptid_entry->u.f1.port_name,
+					    WWN_SIZE);
+				}
 
-			if (!MSB(stat)) {
-				if (rptid_entry->vp_idx_map[1] & BIT_6)
-					wwpn = rptid_entry->reserved_4 + 8;
+				vha->d_id.b.domain = rptid_entry->port_id[2];
+				vha->d_id.b.area = rptid_entry->port_id[1];
+				vha->d_id.b.al_pa = rptid_entry->port_id[0];
+				spin_lock_irqsave(&ha->vport_slock, flags);
+				qlt_update_vp_map(vha, SET_AL_PA);
+				spin_unlock_irqrestore(&ha->vport_slock, flags);
 			}
-			memcpy(vha->port_name, wwpn, WWN_SIZE);
+
 			fc_host_port_name(vha->host) =
 			    wwn_to_u64(vha->port_name);
-			ql_dbg(ql_dbg_mbx, vha, 0x1018,
-			    "FA-WWN portname %016llx (%x)\n",
-			    fc_host_port_name(vha->host), MSB(stat));
-		}
-
-		vp = vha;
-		if (vp_idx == 0)
-			goto reg_needed;
 
-		if (MSB(stat) != 0 && MSB(stat) != 2) {
-			ql_dbg(ql_dbg_mbx, vha, 0x10ba,
-			    "Could not acquire ID for VP[%d].\n", vp_idx);
-			return;
-		}
+			if (qla_ini_mode_enabled(vha))
+				ql_dbg(ql_dbg_mbx, vha, 0x1018,
+				    "FA-WWN portname %016llx (%x)\n",
+				    fc_host_port_name(vha->host),
+				    rptid_entry->vp_status);
 
-		found = 0;
-		spin_lock_irqsave(&ha->vport_slock, flags);
-		list_for_each_entry(vp, &ha->vp_list, list) {
-			if (vp_idx == vp->vp_idx) {
-				found = 1;
-				break;
+			set_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);
+			set_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);
+		} else {
+			if (rptid_entry->vp_status != VP_STAT_COMPL &&
+				rptid_entry->vp_status != VP_STAT_ID_CHG) {
+				ql_dbg(ql_dbg_mbx, vha, 0x10ba,
+				    "Could not acquire ID for VP[%d].\n",
+				    rptid_entry->vp_idx);
+				return;
 			}
-		}
-		spin_unlock_irqrestore(&ha->vport_slock, flags);
 
-		if (!found)
-			return;
+			found = 0;
+			spin_lock_irqsave(&ha->vport_slock, flags);
+			list_for_each_entry(vp, &ha->vp_list, list) {
+				if (rptid_entry->vp_idx == vp->vp_idx) {
+					found = 1;
+					break;
+				}
+			}
+			spin_unlock_irqrestore(&ha->vport_slock, flags);
 
-		vp->d_id.b.domain = rptid_entry->port_id[2];
-		vp->d_id.b.area =  rptid_entry->port_id[1];
-		vp->d_id.b.al_pa = rptid_entry->port_id[0];
+			if (!found)
+				return;
 
-		/*
-		 * Cannot configure here as we are still sitting on the
-		 * response queue. Handle it in dpc context.
-		 */
-		set_bit(VP_IDX_ACQUIRED, &vp->vp_flags);
+			vp->d_id.b.domain = rptid_entry->port_id[2];
+			vp->d_id.b.area =  rptid_entry->port_id[1];
+			vp->d_id.b.al_pa = rptid_entry->port_id[0];
+			spin_lock_irqsave(&ha->vport_slock, flags);
+			qlt_update_vp_map(vp, SET_AL_PA);
+			spin_unlock_irqrestore(&ha->vport_slock, flags);
 
-reg_needed:
-		set_bit(REGISTER_FC4_NEEDED, &vp->dpc_flags);
-		set_bit(REGISTER_FDMI_NEEDED, &vp->dpc_flags);
+			/*
+			 * Cannot configure here as we are still sitting on the
+			 * response queue. Handle it in dpc context.
+			 */
+			set_bit(VP_IDX_ACQUIRED, &vp->vp_flags);
+			set_bit(REGISTER_FC4_NEEDED, &vp->dpc_flags);
+			set_bit(REGISTER_FDMI_NEEDED, &vp->dpc_flags);
+		}
 		set_bit(VP_DPC_NEEDED, &vha->dpc_flags);
 		qla2xxx_wake_dpc(vha);
+	} else if (rptid_entry->format == 2) {
+		ql_dbg(ql_dbg_async, vha, 0xffff,
+		    "RIDA: format 2/N2N Primary port id %02x%02x%02x.\n",
+		    rptid_entry->port_id[2], rptid_entry->port_id[1],
+		    rptid_entry->port_id[0]);
+
+		ql_dbg(ql_dbg_async, vha, 0xffff,
+		    "N2N: Remote WWPN %8phC.\n",
+		    rptid_entry->u.f2.port_name);
+
+		/* N2N.  direct connect */
+		vha->d_id.b.domain = rptid_entry->port_id[2];
+		vha->d_id.b.area = rptid_entry->port_id[1];
+		vha->d_id.b.al_pa = rptid_entry->port_id[0];
+
+		spin_lock_irqsave(&ha->vport_slock, flags);
+		qlt_update_vp_map(vha, SET_AL_PA);
+		spin_unlock_irqrestore(&ha->vport_slock, flags);
 	}
 }
 
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index ae651df67490..e07bb71e82f2 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -224,6 +224,13 @@ MODULE_PARM_DESC(ql2xfwholdabts,
 		"0 (Default) Do not set fw option. "
 		"1 - Set fw option to hold ABTS.");
 
+int ql2xmvasynctoatio = 1;
+module_param(ql2xmvasynctoatio, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(ql2xmvasynctoatio,
+		"Move PUREX, ABTS RX and RIDA IOCBs to ATIOQ"
+		"0 (Default). Do not move IOCBs"
+		"1 - Move IOCBs.");
+
 /*
  * SCSI host template entry points
  */
@@ -4112,10 +4119,10 @@ struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht,
 	struct scsi_qla_host *vha = NULL;
 
 	host = scsi_host_alloc(sht, sizeof(scsi_qla_host_t));
-	if (host == NULL) {
+	if (!host) {
 		ql_log_pci(ql_log_fatal, ha->pdev, 0x0107,
 		    "Failed to allocate host from the scsi layer, aborting.\n");
-		goto fail;
+		return NULL;
 	}
 
 	/* Clear our data area */
@@ -4130,10 +4137,22 @@ struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht,
 	INIT_LIST_HEAD(&vha->work_list);
 	INIT_LIST_HEAD(&vha->list);
 	INIT_LIST_HEAD(&vha->qp_list);
+	INIT_LIST_HEAD(&vha->gnl.fcports);
 
 	spin_lock_init(&vha->work_lock);
 	init_waitqueue_head(&vha->vref_waitq);
 
+	vha->gnl.size =
+	    sizeof(struct get_name_list_extended[ha->max_loop_id+1]);
+	vha->gnl.l = dma_alloc_coherent(&ha->pdev->dev,
+	    vha->gnl.size, &vha->gnl.ldma, GFP_KERNEL);
+	if (!vha->gnl.l) {
+		ql_log(ql_log_fatal, vha, 0xffff,
+		    "Alloc failed for name list.\n");
+		scsi_remove_host(vha->host);
+		return NULL;
+	}
+
 	sprintf(vha->host_str, "%s_%ld", QLA2XXX_DRIVER_NAME, vha->host_no);
 	ql_dbg(ql_dbg_init, vha, 0x0041,
 	    "Allocated the host=%p hw=%p vha=%p dev_name=%s",
@@ -4141,9 +4160,6 @@ struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht,
 	    dev_name(&(ha->pdev->dev)));
 
 	return vha;
-
-fail:
-	return vha;
 }
 
 static struct qla_work_evt *
@@ -5324,16 +5340,6 @@ qla2x00_do_dpc(void *data)
 			qla2x00_update_fcports(base_vha);
 		}
 
-		if (test_bit(SCR_PENDING, &base_vha->dpc_flags)) {
-			int ret;
-			ret = qla2x00_send_change_request(base_vha, 0x3, 0);
-			if (ret != QLA_SUCCESS)
-				ql_log(ql_log_warn, base_vha, 0x121,
-				    "Failed to enable receiving of RSCN "
-				    "requests: 0x%x.\n", ret);
-			clear_bit(SCR_PENDING, &base_vha->dpc_flags);
-		}
-
 		if (IS_QLAFX00(ha))
 			goto loop_resync_check;
 
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
