efi: Use early_mem*() instead of early_io*()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Daniel Kiper <daniel.kiper@oracle.com>
commit abc93f8eb6e46a480485f19256bdbda36ec78a84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/abc93f8e.failed

Use early_mem*() instead of early_io*() because all mapped EFI regions
are memory (usually RAM but they could also be ROM, EPROM, EEPROM, flash,
etc.) not I/O regions. Additionally, I/O family calls do not work correctly
under Xen in our case. early_ioremap() skips the PFN to MFN conversion
when building the PTE. Using it for memory will attempt to map the wrong
machine frame. However, all artificial EFI structures created under Xen
live in dom0 memory and should be mapped/unmapped using early_mem*() family
calls which map domain memory.

	Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
	Cc: Leif Lindholm <leif.lindholm@linaro.org>
	Cc: Mark Salter <msalter@redhat.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit abc93f8eb6e46a480485f19256bdbda36ec78a84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
diff --cc drivers/firmware/efi/efi.c
index 298ffe5c759a,023937a63a48..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -377,6 -314,86 +377,13 @@@ int __init efi_config_init(efi_config_t
  		tablep += sz;
  	}
  	pr_cont("\n");
++<<<<<<< HEAD
 +	early_iounmap(config_tables, efi.systab->nr_tables * sz);
++=======
+ 	early_memunmap(config_tables, efi.systab->nr_tables * sz);
+ 
+ 	set_bit(EFI_CONFIG_TABLES, &efi.flags);
+ 
++>>>>>>> abc93f8eb6e4 (efi: Use early_mem*() instead of early_io*())
  	return 0;
  }
 -
 -#ifdef CONFIG_EFI_PARAMS_FROM_FDT
 -
 -#define UEFI_PARAM(name, prop, field)			   \
 -	{						   \
 -		{ name },				   \
 -		{ prop },				   \
 -		offsetof(struct efi_fdt_params, field),    \
 -		FIELD_SIZEOF(struct efi_fdt_params, field) \
 -	}
 -
 -static __initdata struct {
 -	const char name[32];
 -	const char propname[32];
 -	int offset;
 -	int size;
 -} dt_params[] = {
 -	UEFI_PARAM("System Table", "linux,uefi-system-table", system_table),
 -	UEFI_PARAM("MemMap Address", "linux,uefi-mmap-start", mmap),
 -	UEFI_PARAM("MemMap Size", "linux,uefi-mmap-size", mmap_size),
 -	UEFI_PARAM("MemMap Desc. Size", "linux,uefi-mmap-desc-size", desc_size),
 -	UEFI_PARAM("MemMap Desc. Version", "linux,uefi-mmap-desc-ver", desc_ver)
 -};
 -
 -struct param_info {
 -	int verbose;
 -	void *params;
 -};
 -
 -static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
 -				       int depth, void *data)
 -{
 -	struct param_info *info = data;
 -	void *prop, *dest;
 -	unsigned long len;
 -	u64 val;
 -	int i;
 -
 -	if (depth != 1 ||
 -	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 -		return 0;
 -
 -	pr_info("Getting parameters from FDT:\n");
 -
 -	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
 -		prop = of_get_flat_dt_prop(node, dt_params[i].propname, &len);
 -		if (!prop) {
 -			pr_err("Can't find %s in device tree!\n",
 -			       dt_params[i].name);
 -			return 0;
 -		}
 -		dest = info->params + dt_params[i].offset;
 -
 -		val = of_read_number(prop, len / sizeof(u32));
 -
 -		if (dt_params[i].size == sizeof(u32))
 -			*(u32 *)dest = val;
 -		else
 -			*(u64 *)dest = val;
 -
 -		if (info->verbose)
 -			pr_info("  %s: 0x%0*llx\n", dt_params[i].name,
 -				dt_params[i].size * 2, val);
 -	}
 -	return 1;
 -}
 -
 -int __init efi_get_fdt_params(struct efi_fdt_params *params, int verbose)
 -{
 -	struct param_info info;
 -
 -	info.verbose = verbose;
 -	info.params = params;
 -
 -	return of_scan_flat_dt(fdt_find_uefi_params, &info);
 -}
 -#endif /* CONFIG_EFI_PARAMS_FROM_FDT */
diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 4075c6f4984c..9fb605049938 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -462,7 +462,7 @@ void __init efi_unmap_memmap(void)
 {
 	clear_bit(EFI_MEMMAP, &x86_efi_facility);
 	if (memmap.map) {
-		early_iounmap(memmap.map, memmap.nr_map * memmap.desc_size);
+		early_memunmap(memmap.map, memmap.nr_map * memmap.desc_size);
 		memmap.map = NULL;
 	}
 }
@@ -502,12 +502,12 @@ static int __init efi_systab_init(void *phys)
 			if (!data)
 				return -ENOMEM;
 		}
-		systab64 = early_ioremap((unsigned long)phys,
+		systab64 = early_memremap((unsigned long)phys,
 					 sizeof(*systab64));
 		if (systab64 == NULL) {
 			pr_err("Couldn't map the system table!\n");
 			if (data)
-				early_iounmap(data, sizeof(*data));
+				early_memunmap(data, sizeof(*data));
 			return -ENOMEM;
 		}
 
@@ -539,9 +539,9 @@ static int __init efi_systab_init(void *phys)
 					   systab64->tables;
 		tmp |= data ? data->tables : systab64->tables;
 
-		early_iounmap(systab64, sizeof(*systab64));
+		early_memunmap(systab64, sizeof(*systab64));
 		if (data)
-			early_iounmap(data, sizeof(*data));
+			early_memunmap(data, sizeof(*data));
 #ifdef CONFIG_X86_32
 		if (tmp >> 32) {
 			pr_err("EFI data located above 4GB, disabling EFI.\n");
@@ -551,7 +551,7 @@ static int __init efi_systab_init(void *phys)
 	} else {
 		efi_system_table_32_t *systab32;
 
-		systab32 = early_ioremap((unsigned long)phys,
+		systab32 = early_memremap((unsigned long)phys,
 					 sizeof(*systab32));
 		if (systab32 == NULL) {
 			pr_err("Couldn't map the system table!\n");
@@ -572,7 +572,7 @@ static int __init efi_systab_init(void *phys)
 		efi_systab.nr_tables = systab32->nr_tables;
 		efi_systab.tables = systab32->tables;
 
-		early_iounmap(systab32, sizeof(*systab32));
+		early_memunmap(systab32, sizeof(*systab32));
 	}
 
 	efi.systab = &efi_systab;
@@ -596,7 +596,7 @@ static int __init efi_runtime_init32(void)
 {
 	efi_runtime_services_32_t *runtime;
 
-	runtime = early_ioremap((unsigned long)efi.systab->runtime,
+	runtime = early_memremap((unsigned long)efi.systab->runtime,
 			sizeof(efi_runtime_services_32_t));
 	if (!runtime) {
 		pr_err("Could not map the runtime service table!\n");
@@ -611,7 +611,7 @@ static int __init efi_runtime_init32(void)
 	efi_phys.set_virtual_address_map =
 			(efi_set_virtual_address_map_t *)
 			(unsigned long)runtime->set_virtual_address_map;
-	early_iounmap(runtime, sizeof(efi_runtime_services_32_t));
+	early_memunmap(runtime, sizeof(efi_runtime_services_32_t));
 
 	return 0;
 }
@@ -620,7 +620,7 @@ static int __init efi_runtime_init64(void)
 {
 	efi_runtime_services_64_t *runtime;
 
-	runtime = early_ioremap((unsigned long)efi.systab->runtime,
+	runtime = early_memremap((unsigned long)efi.systab->runtime,
 			sizeof(efi_runtime_services_64_t));
 	if (!runtime) {
 		pr_err("Could not map the runtime service table!\n");
@@ -635,7 +635,7 @@ static int __init efi_runtime_init64(void)
 	efi_phys.set_virtual_address_map =
 			(efi_set_virtual_address_map_t *)
 			(unsigned long)runtime->set_virtual_address_map;
-	early_iounmap(runtime, sizeof(efi_runtime_services_64_t));
+	early_memunmap(runtime, sizeof(efi_runtime_services_64_t));
 
 	return 0;
 }
@@ -664,7 +664,7 @@ static int __init efi_runtime_init(void)
 static int __init efi_memmap_init(void)
 {
 	/* Map the EFI memory map */
-	memmap.map = early_ioremap((unsigned long)memmap.phys_map,
+	memmap.map = early_memremap((unsigned long)memmap.phys_map,
 				   memmap.nr_map * memmap.desc_size);
 	if (memmap.map == NULL) {
 		pr_err("Could not map the memory map!\n");
@@ -766,14 +766,14 @@ void __init efi_init(void)
 	/*
 	 * Show what we know for posterity
 	 */
-	c16 = tmp = early_ioremap(efi.systab->fw_vendor, 2);
+	c16 = tmp = early_memremap(efi.systab->fw_vendor, 2);
 	if (c16) {
 		for (i = 0; i < sizeof(vendor) - 1 && *c16; ++i)
 			vendor[i] = *c16++;
 		vendor[i] = '\0';
 	} else
 		pr_err("Could not map the firmware vendor!\n");
-	early_iounmap(tmp, 2);
+	early_memunmap(tmp, 2);
 
 	pr_info("EFI v%u.%.02u by %s\n",
 		efi.systab->hdr.revision >> 16,
* Unmerged path drivers/firmware/efi/efi.c
