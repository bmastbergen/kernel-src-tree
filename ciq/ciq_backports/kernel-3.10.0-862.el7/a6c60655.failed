ovl: redirect on rename-dir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit a6c6065511411c57167a6cdae0c33263fb662b51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a6c60655.failed

Current code returns EXDEV when a directory would need to be copied up to
move.  We could copy up the directory tree in this case, but there's
another, simpler solution: point to old lower directory from moved upper
directory.

This is achieved with a "trusted.overlay.redirect" xattr storing the path
relative to the root of the overlay.  After such attribute has been set,
the directory can be moved without further actions required.

This is a backward incompatible feature, old kernels won't be able to
correctly mount an overlay containing redirected directories.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit a6c6065511411c57167a6cdae0c33263fb662b51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/overlayfs.txt
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/dir.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/util.c
diff --cc Documentation/filesystems/overlayfs.txt
index bcbf9710e4af,fb6f3070c6fe..000000000000
--- a/Documentation/filesystems/overlayfs.txt
+++ b/Documentation/filesystems/overlayfs.txt
@@@ -192,6 -206,9 +209,12 @@@ If a file with multiple hard links is c
  "break" the link.  Changes will not be propagated to other names
  referring to the same inode.
  
++<<<<<<< HEAD
++=======
+ Unless "redirect_dir" feature is enabled, rename(2) on a lower or merged
+ directory will fail with EXDEV.
+ 
++>>>>>>> a6c606551141 (ovl: redirect on rename-dir)
  Changes to underlying filesystems
  ---------------------------------
  
diff --cc fs/overlayfs/copy_up.c
index d5488899e537,e191c631b17f..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -377,9 -338,9 +371,13 @@@ int ovl_copy_up_one(struct dentry *pare
  	int err;
  	struct kstat pstat;
  	struct path parentpath;
 -	struct dentry *lowerdentry = lowerpath->dentry;
  	struct dentry *upperdir;
++<<<<<<< HEAD
 +	struct dentry *upperdentry;
 +	char *link = NULL;
++=======
+ 	const char *link = NULL;
++>>>>>>> a6c606551141 (ovl: redirect on rename-dir)
  
  	if (WARN_ON(!workdir))
  		return -EROFS;
diff --cc fs/overlayfs/dir.c
index c82fdefe6d3b,c1de84c1c5ec..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -810,6 -751,111 +811,114 @@@ static int ovl_rmdir(struct inode *dir
  	return ovl_do_remove(dentry, true);
  }
  
++<<<<<<< HEAD
++=======
+ static bool ovl_type_merge_or_lower(struct dentry *dentry)
+ {
+ 	enum ovl_path_type type = ovl_path_type(dentry);
+ 
+ 	return OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type);
+ }
+ 
+ static bool ovl_can_move(struct dentry *dentry)
+ {
+ 	return ovl_redirect_dir(dentry->d_sb) ||
+ 		!d_is_dir(dentry) || !ovl_type_merge_or_lower(dentry);
+ }
+ 
+ #define OVL_REDIRECT_MAX 256
+ 
+ static char *ovl_get_redirect(struct dentry *dentry, bool samedir)
+ {
+ 	char *buf, *ret;
+ 	struct dentry *d, *tmp;
+ 	int buflen = OVL_REDIRECT_MAX + 1;
+ 
+ 	if (samedir) {
+ 		ret = kstrndup(dentry->d_name.name, dentry->d_name.len,
+ 			       GFP_KERNEL);
+ 		goto out;
+ 	}
+ 
+ 	buf = ret = kmalloc(buflen, GFP_TEMPORARY);
+ 	if (!buf)
+ 		goto out;
+ 
+ 	buflen--;
+ 	buf[buflen] = '\0';
+ 	for (d = dget(dentry); !IS_ROOT(d);) {
+ 		const char *name;
+ 		int thislen;
+ 
+ 		spin_lock(&d->d_lock);
+ 		name = ovl_dentry_get_redirect(d);
+ 		if (name) {
+ 			thislen = strlen(name);
+ 		} else {
+ 			name = d->d_name.name;
+ 			thislen = d->d_name.len;
+ 		}
+ 
+ 		/* If path is too long, fall back to userspace move */
+ 		if (thislen + (name[0] != '/') > buflen) {
+ 			ret = ERR_PTR(-EXDEV);
+ 			spin_unlock(&d->d_lock);
+ 			goto out_put;
+ 		}
+ 
+ 		buflen -= thislen;
+ 		memcpy(&buf[buflen], name, thislen);
+ 		tmp = dget_dlock(d->d_parent);
+ 		spin_unlock(&d->d_lock);
+ 
+ 		dput(d);
+ 		d = tmp;
+ 
+ 		/* Absolute redirect: finished */
+ 		if (buf[buflen] == '/')
+ 			break;
+ 		buflen--;
+ 		buf[buflen] = '/';
+ 	}
+ 	ret = kstrdup(&buf[buflen], GFP_KERNEL);
+ out_put:
+ 	dput(d);
+ 	kfree(buf);
+ out:
+ 	return ret ? ret : ERR_PTR(-ENOMEM);
+ }
+ 
+ static int ovl_set_redirect(struct dentry *dentry, bool samedir)
+ {
+ 	int err;
+ 	const char *redirect = ovl_dentry_get_redirect(dentry);
+ 
+ 	if (redirect && (samedir || redirect[0] == '/'))
+ 		return 0;
+ 
+ 	redirect = ovl_get_redirect(dentry, samedir);
+ 	if (IS_ERR(redirect))
+ 		return PTR_ERR(redirect);
+ 
+ 	err = ovl_do_setxattr(ovl_dentry_upper(dentry), OVL_XATTR_REDIRECT,
+ 			      redirect, strlen(redirect), 0);
+ 	if (!err) {
+ 		spin_lock(&dentry->d_lock);
+ 		ovl_dentry_set_redirect(dentry, redirect);
+ 		spin_unlock(&dentry->d_lock);
+ 	} else {
+ 		kfree(redirect);
+ 		if (err == -EOPNOTSUPP)
+ 			ovl_clear_redirect_dir(dentry->d_sb);
+ 		else
+ 			pr_warn_ratelimited("overlay: failed to set redirect (%i)\n", err);
+ 		/* Fall back to userspace copy-up */
+ 		err = -EXDEV;
+ 	}
+ 	return err;
+ }
+ 
++>>>>>>> a6c606551141 (ovl: redirect on rename-dir)
  static int ovl_rename(struct inode *olddir, struct dentry *old,
  		      struct inode *newdir, struct dentry *new,
  		      unsigned int flags)
@@@ -826,8 -870,9 +935,14 @@@
  	bool new_opaque;
  	bool cleanup_whiteout = false;
  	bool overwrite = !(flags & RENAME_EXCHANGE);
++<<<<<<< HEAD
 +	bool is_dir = S_ISDIR(old->d_inode->i_mode);
 +	bool new_is_dir = false;
++=======
+ 	bool is_dir = d_is_dir(old);
+ 	bool new_is_dir = d_is_dir(new);
+ 	bool samedir = olddir == newdir;
++>>>>>>> a6c606551141 (ovl: redirect on rename-dir)
  	struct dentry *opaquedir = NULL;
  	const struct cred *old_cred = NULL;
  
@@@ -837,32 -882,13 +952,38 @@@
  
  	flags &= ~RENAME_NOREPLACE;
  
 +	err = ovl_check_sticky(old);
 +	if (err)
 +		goto out;
 +
  	/* Don't copy up directory trees */
 +	old_type = ovl_path_type(old);
  	err = -EXDEV;
++<<<<<<< HEAD
 +	if (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)
++=======
+ 	if (!ovl_can_move(old))
+ 		goto out;
+ 	if (!overwrite && !ovl_can_move(new))
++>>>>>>> a6c606551141 (ovl: redirect on rename-dir)
  		goto out;
  
 +	if (new->d_inode) {
 +		err = ovl_check_sticky(new);
 +		if (err)
 +			goto out;
 +
 +		if (S_ISDIR(new->d_inode->i_mode))
 +			new_is_dir = true;
 +
 +		new_type = ovl_path_type(new);
 +		err = -EXDEV;
 +		if (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)
 +			goto out;
 +	} else {
 +		new_type = __OVL_PATH_UPPER;
 +	}
 +
  	err = ovl_want_write(old);
  	if (err)
  		goto out;
diff --cc fs/overlayfs/overlayfs.h
index 6d920ffce215,bdda37fa3f67..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -152,28 +151,40 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
 +bool ovl_lower_positive(struct dentry *dentry);
  bool ovl_dentry_is_whiteout(struct dentry *dentry);
  void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
++<<<<<<< HEAD
++=======
+ bool ovl_redirect_dir(struct super_block *sb);
+ void ovl_clear_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_inode_init(struct inode *inode, struct inode *realinode,
+ 		    bool is_upper);
+ void ovl_inode_update(struct inode *inode, struct inode *upperinode);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
++>>>>>>> a6c606551141 (ovl: redirect on rename-dir)
  bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
  struct file *ovl_path_open(struct path *path, int flags);
  
 -/* namei.c */
 -int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
 -bool ovl_lower_positive(struct dentry *dentry);
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/util.c
* Unmerged path Documentation/filesystems/overlayfs.txt
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/ovl_entry.h
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 32484e92dfd8..40a62efd7837 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -759,6 +759,8 @@ enum {
 	OPT_UPPERDIR,
 	OPT_WORKDIR,
 	OPT_DEFAULT_PERMISSIONS,
+	OPT_REDIRECT_DIR_ON,
+	OPT_REDIRECT_DIR_OFF,
 	OPT_ERR,
 };
 
@@ -767,6 +769,8 @@ static const match_table_t ovl_tokens = {
 	{OPT_UPPERDIR,			"upperdir=%s"},
 	{OPT_WORKDIR,			"workdir=%s"},
 	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
+	{OPT_REDIRECT_DIR_ON,		"redirect_dir=on"},
+	{OPT_REDIRECT_DIR_OFF,		"redirect_dir=off"},
 	{OPT_ERR,			NULL}
 };
 
@@ -831,6 +835,14 @@ static int ovl_parse_opt(char *opt, struct ovl_config *config)
 			config->default_permissions = true;
 			break;
 
+		case OPT_REDIRECT_DIR_ON:
+			config->redirect_dir = true;
+			break;
+
+		case OPT_REDIRECT_DIR_OFF:
+			config->redirect_dir = false;
+			break;
+
 		default:
 			pr_err("overlayfs: unrecognized mount option \"%s\" or missing value\n", p);
 			return -EINVAL;
* Unmerged path fs/overlayfs/util.c
