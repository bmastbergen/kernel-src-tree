gfs2: Fixes to "Implement iomap for block_map"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 49edd5bf429c405b3a7f75503845d9f66a47dd4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/49edd5bf.failed

It turns out that commit 3974320ca6 "Implement iomap for block_map"
introduced a few bugs that trigger occasional failures with xfstest
generic/476:

In gfs2_iomap_begin, we jump to do_alloc when we determine that we are
beyond the end of the allocated metadata (height > ip->i_height).
There, we can end up calling hole_size with a metapath that doesn't
match the current metadata tree, which doesn't make sense.  After
untangling the code at do_alloc, fix this by checking if the block we
are looking for is within the range of allocated metadata.

In addition, add a BUG() in case gfs2_iomap_begin is accidentally called
for reading stuffed files: this is handled separately.  Make sure we
don't truncate iomap->length for reads beyond the end of the file; in
that case, the entire range counts as a hole.

Finally, revert to taking a bitmap write lock when doing allocations.
It's unclear why that change didn't lead to any failures during testing.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 49edd5bf429c405b3a7f75503845d9f66a47dd4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
diff --cc fs/gfs2/bmap.c
index 15571283d4f0,86d6a4435c87..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -591,6 -628,193 +591,196 @@@ static int gfs2_bmap_alloc(struct inod
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * hole_size - figure out the size of a hole
+  * @inode: The inode
+  * @lblock: The logical starting block number
+  * @mp: The metapath
+  *
+  * Returns: The hole size in bytes
+  *
+  */
+ static u64 hole_size(struct inode *inode, sector_t lblock, struct metapath *mp)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	struct metapath mp_eof;
+ 	u64 factor = 1;
+ 	int hgt;
+ 	u64 holesz = 0;
+ 	const __be64 *first, *end, *ptr;
+ 	const struct buffer_head *bh;
+ 	u64 lblock_stop = (i_size_read(inode) - 1) >> inode->i_blkbits;
+ 	int zeroptrs;
+ 	bool done = false;
+ 
+ 	/* Get another metapath, to the very last byte */
+ 	find_metapath(sdp, lblock_stop, &mp_eof, ip->i_height);
+ 	for (hgt = ip->i_height - 1; hgt >= 0 && !done; hgt--) {
+ 		bh = mp->mp_bh[hgt];
+ 		if (bh) {
+ 			zeroptrs = 0;
+ 			first = metapointer(hgt, mp);
+ 			end = (const __be64 *)(bh->b_data + bh->b_size);
+ 
+ 			for (ptr = first; ptr < end; ptr++) {
+ 				if (*ptr) {
+ 					done = true;
+ 					break;
+ 				} else {
+ 					zeroptrs++;
+ 				}
+ 			}
+ 		} else {
+ 			zeroptrs = sdp->sd_inptrs;
+ 		}
+ 		if (factor * zeroptrs >= lblock_stop - lblock + 1) {
+ 			holesz = lblock_stop - lblock + 1;
+ 			break;
+ 		}
+ 		holesz += factor * zeroptrs;
+ 
+ 		factor *= sdp->sd_inptrs;
+ 		if (hgt && (mp->mp_list[hgt - 1] < mp_eof.mp_list[hgt - 1]))
+ 			(mp->mp_list[hgt - 1])++;
+ 	}
+ 	return holesz << inode->i_blkbits;
+ }
+ 
+ static void gfs2_stuffed_iomap(struct inode *inode, struct iomap *iomap)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 
+ 	iomap->addr = (ip->i_no_addr << inode->i_blkbits) +
+ 		      sizeof(struct gfs2_dinode);
+ 	iomap->offset = 0;
+ 	iomap->length = i_size_read(inode);
+ 	iomap->type = IOMAP_MAPPED;
+ 	iomap->flags = IOMAP_F_DATA_INLINE;
+ }
+ 
+ /**
+  * gfs2_iomap_begin - Map blocks from an inode to disk blocks
+  * @inode: The inode
+  * @pos: Starting position in bytes
+  * @length: Length to map, in bytes
+  * @flags: iomap flags
+  * @iomap: The iomap structure
+  *
+  * Returns: errno
+  */
+ int gfs2_iomap_begin(struct inode *inode, loff_t pos, loff_t length,
+ 		     unsigned flags, struct iomap *iomap)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	struct metapath mp = { .mp_aheight = 1, };
+ 	unsigned int factor = sdp->sd_sb.sb_bsize;
+ 	const u64 *arr = sdp->sd_heightsize;
+ 	__be64 *ptr;
+ 	sector_t lblock;
+ 	sector_t lend;
+ 	int ret = 0;
+ 	int eob;
+ 	unsigned int len;
+ 	struct buffer_head *bh;
+ 	u8 height;
+ 
+ 	trace_gfs2_iomap_start(ip, pos, length, flags);
+ 	if (!length) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (gfs2_is_stuffed(ip)) {
+ 		if (flags & IOMAP_REPORT) {
+ 			gfs2_stuffed_iomap(inode, iomap);
+ 			if (pos >= iomap->length)
+ 				ret = -ENOENT;
+ 			goto out;
+ 		}
+ 		BUG_ON(!(flags & IOMAP_WRITE));
+ 	}
+ 
+ 	lblock = pos >> inode->i_blkbits;
+ 	lend = (pos + length + sdp->sd_sb.sb_bsize - 1) >> inode->i_blkbits;
+ 
+ 	iomap->offset = lblock << inode->i_blkbits;
+ 	iomap->addr = IOMAP_NULL_ADDR;
+ 	iomap->type = IOMAP_HOLE;
+ 	iomap->length = (u64)(lend - lblock) << inode->i_blkbits;
+ 	iomap->flags = IOMAP_F_MERGED;
+ 	bmap_lock(ip, flags & IOMAP_WRITE);
+ 
+ 	/*
+ 	 * Directory data blocks have a struct gfs2_meta_header header, so the
+ 	 * remaining size is smaller than the filesystem block size.  Logical
+ 	 * block numbers for directories are in units of this remaining size!
+ 	 */
+ 	if (gfs2_is_dir(ip)) {
+ 		factor = sdp->sd_jbsize;
+ 		arr = sdp->sd_jheightsize;
+ 	}
+ 
+ 	ret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);
+ 	if (ret)
+ 		goto out_release;
+ 
+ 	height = ip->i_height;
+ 	while ((lblock + 1) * factor > arr[height])
+ 		height++;
+ 	find_metapath(sdp, lblock, &mp, height);
+ 	if (height > ip->i_height || gfs2_is_stuffed(ip))
+ 		goto do_alloc;
+ 
+ 	ret = lookup_metapath(ip, &mp);
+ 	if (ret)
+ 		goto out_release;
+ 
+ 	if (mp.mp_aheight != ip->i_height)
+ 		goto do_alloc;
+ 
+ 	ptr = metapointer(ip->i_height - 1, &mp);
+ 	if (*ptr == 0)
+ 		goto do_alloc;
+ 
+ 	iomap->type = IOMAP_MAPPED;
+ 	iomap->addr = be64_to_cpu(*ptr) << inode->i_blkbits;
+ 
+ 	bh = mp.mp_bh[ip->i_height - 1];
+ 	len = gfs2_extent_length(bh->b_data, bh->b_size, ptr, lend - lblock, &eob);
+ 	if (eob)
+ 		iomap->flags |= IOMAP_F_BOUNDARY;
+ 	iomap->length = (u64)len << inode->i_blkbits;
+ 
+ out_release:
+ 	release_metapath(&mp);
+ 	bmap_unlock(ip, flags & IOMAP_WRITE);
+ out:
+ 	trace_gfs2_iomap_end(ip, iomap, ret);
+ 	return ret;
+ 
+ do_alloc:
+ 	if (flags & IOMAP_WRITE) {
+ 		ret = gfs2_iomap_alloc(inode, iomap, flags, &mp);
+ 	} else if (flags & IOMAP_REPORT) {
+ 		loff_t size = i_size_read(inode);
+ 		if (pos >= size)
+ 			ret = -ENOENT;
+ 		else if (height <= ip->i_height)
+ 			iomap->length = hole_size(inode, lblock, &mp);
+ 		else
+ 			iomap->length = size - pos;
+ 	} else {
+ 		if (height <= ip->i_height)
+ 			iomap->length = hole_size(inode, lblock, &mp);
+ 	}
+ 	goto out_release;
+ }
+ 
+ /**
++>>>>>>> 49edd5bf429c (gfs2: Fixes to "Implement iomap for block_map")
   * gfs2_block_map - Map a block from an inode to a disk block
   * @inode: The inode
   * @lblock: The logical block number
* Unmerged path fs/gfs2/bmap.c
