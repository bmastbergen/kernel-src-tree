qed: Acquire/release ptt_ptp lock when enabling/disabling PTP.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] qed: Acquire/release ptt_ptp lock when enabling/disabling PTP (Don Dutile) [1462433 1499362]
Rebuild_FUZZ: 99.19%
commit-author sudarsana.kalluru@cavium.com <sudarsana.kalluru@cavium.com>
commit d179bd1699fccd9d5b9bc38470bab7343a441ea0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d179bd16.failed

Move the code for acquiring/releasing ptt_ptp lock to ptp specific
implementations i.e., ptp_enable()/disable() respectively.

	Signed-off-by: Sudarsana Reddy Kalluru <Sudarsana.Kalluru@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d179bd1699fccd9d5b9bc38470bab7343a441ea0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed.h
#	drivers/net/ethernet/qlogic/qed/qed_main.c
#	drivers/net/ethernet/qlogic/qed/qed_ptp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed.h
index d52c188a91a3,c07191cb7631..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@@ -501,6 -535,8 +506,11 @@@ struct qed_hwfn 
  	u8 dcbx_no_edpm;
  	u8 db_bar_no_edpm;
  
++<<<<<<< HEAD
++=======
+ 	struct qed_ptt *p_arfs_ptt;
+ 
++>>>>>>> d179bd1699fc (qed: Acquire/release ptt_ptp lock when enabling/disabling PTP.)
  	struct qed_simd_fp_handler	simd_proto_handler[64];
  
  #ifdef CONFIG_QED_SRIOV
diff --cc drivers/net/ethernet/qlogic/qed/qed_main.c
index 1702ce0e037b,8a5a0649fc4a..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@@ -922,6 -943,19 +922,22 @@@ static int qed_slowpath_start(struct qe
  				  QED_FW_FILE_NAME);
  			goto err;
  		}
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_RFS_ACCEL
+ 		if (cdev->num_hwfns == 1) {
+ 			p_ptt = qed_ptt_acquire(QED_LEADING_HWFN(cdev));
+ 			if (p_ptt) {
+ 				QED_LEADING_HWFN(cdev)->p_arfs_ptt = p_ptt;
+ 			} else {
+ 				DP_NOTICE(cdev,
+ 					  "Failed to acquire PTT for aRFS\n");
+ 				goto err;
+ 			}
+ 		}
+ #endif
++>>>>>>> d179bd1699fc (qed: Acquire/release ptt_ptp lock when enabling/disabling PTP.)
  	}
  
  	cdev->rx_coalesce_usecs = QED_DEFAULT_RX_USECS;
@@@ -1014,6 -1063,13 +1030,16 @@@ err
  	if (IS_PF(cdev))
  		release_firmware(cdev->firmware);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_RFS_ACCEL
+ 	if (IS_PF(cdev) && (cdev->num_hwfns == 1) &&
+ 	    QED_LEADING_HWFN(cdev)->p_arfs_ptt)
+ 		qed_ptt_release(QED_LEADING_HWFN(cdev),
+ 				QED_LEADING_HWFN(cdev)->p_arfs_ptt);
+ #endif
+ 
++>>>>>>> d179bd1699fc (qed: Acquire/release ptt_ptp lock when enabling/disabling PTP.)
  	qed_iov_wq_stop(cdev, false);
  
  	return rc;
@@@ -1027,6 -1083,11 +1053,14 @@@ static int qed_slowpath_stop(struct qed
  	qed_ll2_dealloc_if(cdev);
  
  	if (IS_PF(cdev)) {
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_RFS_ACCEL
+ 		if (cdev->num_hwfns == 1)
+ 			qed_ptt_release(QED_LEADING_HWFN(cdev),
+ 					QED_LEADING_HWFN(cdev)->p_arfs_ptt);
+ #endif
++>>>>>>> d179bd1699fc (qed: Acquire/release ptt_ptp lock when enabling/disabling PTP.)
  		qed_free_stream_mem(cdev);
  		if (IS_QED_ETH_IF(cdev))
  			qed_sriov_disable(cdev, true);
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ptp.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_main.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ptp.c
