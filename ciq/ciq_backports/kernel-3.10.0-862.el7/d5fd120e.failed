i2c: Only include slave support if selected

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [i2c] Only include slave support if selected (Gopal Tiwari) [1456705]
Rebuild_FUZZ: 93.83%
commit-author Jean Delvare <jdelvare@suse.de>
commit d5fd120e7860c2b3d4c936a2ebadb6b244bec4c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d5fd120e.failed

Make the slave support depend on CONFIG_I2C_SLAVE. Otherwise it gets
included unconditionally, even when it is not needed.

I2C bus drivers which implement slave support must select
I2C_SLAVE.

	Signed-off-by: Jean Delvare <jdelvare@suse.de>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit d5fd120e7860c2b3d4c936a2ebadb6b244bec4c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/Kconfig
#	drivers/i2c/i2c-core.c
#	include/linux/i2c.h
diff --cc drivers/i2c/busses/Kconfig
index beeaadfb989f,ab838d9e28b6..000000000000
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@@ -774,7 -880,8 +774,12 @@@ config I2C_XL
  
  config I2C_RCAR
  	tristate "Renesas R-Car I2C Controller"
++<<<<<<< HEAD
 +	depends on ARCH_SHMOBILE && I2C
++=======
+ 	depends on ARCH_SHMOBILE || COMPILE_TEST
+ 	select I2C_SLAVE
++>>>>>>> d5fd120e7860 (i2c: Only include slave support if selected)
  	help
  	  If you say yes to this option, support will be included for the
  	  R-Car I2C controller.
diff --cc drivers/i2c/i2c-core.c
index 6cd788a2e027,e9eae57a2b50..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -2620,6 -2972,56 +2620,59 @@@ s32 i2c_smbus_xfer(struct i2c_adapter *
  }
  EXPORT_SYMBOL(i2c_smbus_xfer);
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_I2C_SLAVE)
+ int i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb)
+ {
+ 	int ret;
+ 
+ 	if (!client || !slave_cb)
+ 		return -EINVAL;
+ 
+ 	if (!(client->flags & I2C_CLIENT_TEN)) {
+ 		/* Enforce stricter address checking */
+ 		ret = i2c_check_addr_validity(client->addr);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (!client->adapter->algo->reg_slave)
+ 		return -EOPNOTSUPP;
+ 
+ 	client->slave_cb = slave_cb;
+ 
+ 	i2c_lock_adapter(client->adapter);
+ 	ret = client->adapter->algo->reg_slave(client);
+ 	i2c_unlock_adapter(client->adapter);
+ 
+ 	if (ret)
+ 		client->slave_cb = NULL;
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(i2c_slave_register);
+ 
+ int i2c_slave_unregister(struct i2c_client *client)
+ {
+ 	int ret;
+ 
+ 	if (!client->adapter->algo->unreg_slave)
+ 		return -EOPNOTSUPP;
+ 
+ 	i2c_lock_adapter(client->adapter);
+ 	ret = client->adapter->algo->unreg_slave(client);
+ 	i2c_unlock_adapter(client->adapter);
+ 
+ 	if (ret == 0)
+ 		client->slave_cb = NULL;
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(i2c_slave_unregister);
+ #endif
+ 
++>>>>>>> d5fd120e7860 (i2c: Only include slave support if selected)
  MODULE_AUTHOR("Simon G. Vogl <simon@tk.uni-linz.ac.at>");
  MODULE_DESCRIPTION("I2C-Bus main module");
  MODULE_LICENSE("GPL");
diff --cc include/linux/i2c.h
index 021a03407cda,7c7695940ddd..000000000000
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@@ -224,6 -228,9 +224,12 @@@ struct i2c_client 
  	struct device dev;		/* the device structure		*/
  	int irq;			/* irq issued by device		*/
  	struct list_head detected;
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_I2C_SLAVE)
+ 	i2c_slave_cb_t slave_cb;	/* callback for slave mode	*/
+ #endif
++>>>>>>> d5fd120e7860 (i2c: Only include slave support if selected)
  };
  #define to_i2c_client(d) container_of(d, struct i2c_client, dev)
  
@@@ -246,6 -253,27 +252,30 @@@ static inline void i2c_set_clientdata(s
  	dev_set_drvdata(&dev->dev, data);
  }
  
++<<<<<<< HEAD
++=======
+ /* I2C slave support */
+ 
+ #if IS_ENABLED(CONFIG_I2C_SLAVE)
+ enum i2c_slave_event {
+ 	I2C_SLAVE_REQ_READ_START,
+ 	I2C_SLAVE_REQ_READ_END,
+ 	I2C_SLAVE_REQ_WRITE_START,
+ 	I2C_SLAVE_REQ_WRITE_END,
+ 	I2C_SLAVE_STOP,
+ };
+ 
+ extern int i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb);
+ extern int i2c_slave_unregister(struct i2c_client *client);
+ 
+ static inline int i2c_slave_event(struct i2c_client *client,
+ 				  enum i2c_slave_event event, u8 *val)
+ {
+ 	return client->slave_cb(client, event, val);
+ }
+ #endif
+ 
++>>>>>>> d5fd120e7860 (i2c: Only include slave support if selected)
  /**
   * struct i2c_board_info - template for device creation
   * @type: chip type, to initialize i2c_client.name
@@@ -363,6 -407,11 +393,14 @@@ struct i2c_algorithm 
  
  	/* To determine what the adapter supports */
  	u32 (*functionality) (struct i2c_adapter *);
++<<<<<<< HEAD
++=======
+ 
+ #if IS_ENABLED(CONFIG_I2C_SLAVE)
+ 	int (*reg_slave)(struct i2c_client *client);
+ 	int (*unreg_slave)(struct i2c_client *client);
+ #endif
++>>>>>>> d5fd120e7860 (i2c: Only include slave support if selected)
  };
  
  /**
* Unmerged path drivers/i2c/busses/Kconfig
* Unmerged path drivers/i2c/i2c-core.c
* Unmerged path include/linux/i2c.h
