net/mlx5e: Use modify header ID cache for offloaded TC E-Switch flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Use modify header ID cache for offloaded TC E-Switch flows (Kamal Heib) [1456687 1456694]
Rebuild_FUZZ: 97.01%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 1a9527bb17427a330ef9bd1a65e2c15760095b5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1a9527bb.failed

Use the modify header ID cache for the header re-write part of offloading
TC eswitch flows.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 1a9527bb17427a330ef9bd1a65e2c15760095b5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 971ee0c61b0b,4625a0e226da..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -316,6 -343,15 +316,18 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  		goto err_add_vlan;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {
+ 		err = mlx5e_attach_mod_hdr(priv, flow, parse_attr);
+ 		kfree(parse_attr->mod_hdr_actions);
+ 		if (err) {
+ 			rule = ERR_PTR(err);
+ 			goto err_mod_hdr;
+ 		}
+ 	}
+ 
++>>>>>>> 1a9527bb1742 (net/mlx5e: Use modify header ID cache for offloaded TC E-Switch flows)
  	rule = mlx5_eswitch_add_offloaded_rule(esw, &parse_attr->spec, attr);
  	if (IS_ERR(rule))
  		goto err_add_rule;
@@@ -323,6 -359,9 +335,12 @@@
  	return rule;
  
  err_add_rule:
++<<<<<<< HEAD
++=======
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
+ 		mlx5e_detach_mod_hdr(priv, flow);
+ err_mod_hdr:
++>>>>>>> 1a9527bb1742 (net/mlx5e: Use modify header ID cache for offloaded TC E-Switch flows)
  	mlx5_eswitch_del_vlan_action(esw, attr);
  err_add_vlan:
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
@@@ -335,14 -373,127 +353,127 @@@ static void mlx5e_tc_del_fdb_flow(struc
  				  struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  
 -	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
 -		flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
 -		mlx5_eswitch_del_offloaded_rule(esw, flow->rule, attr);
 -	}
 +	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED)
 +		mlx5_eswitch_del_offloaded_rule(esw, flow->rule, flow->esw_attr);
  
 -	mlx5_eswitch_del_vlan_action(esw, attr);
 +	mlx5_eswitch_del_vlan_action(esw, flow->esw_attr);
  
 -	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP) {
 +	if (flow->esw_attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
  		mlx5e_detach_encap(priv, flow);
++<<<<<<< HEAD
++=======
+ 		kvfree(attr->parse_attr);
+ 	}
+ 
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
+ 		mlx5e_detach_mod_hdr(priv, flow);
+ }
+ 
+ void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
+ 			      struct mlx5e_encap_entry *e)
+ {
+ 	struct mlx5e_tc_flow *flow;
+ 	int err;
+ 
+ 	err = mlx5_encap_alloc(priv->mdev, e->tunnel_type,
+ 			       e->encap_size, e->encap_header,
+ 			       &e->encap_id);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "Failed to offload cached encapsulation header, %d\n",
+ 			       err);
+ 		return;
+ 	}
+ 	e->flags |= MLX5_ENCAP_ENTRY_VALID;
+ 	mlx5e_rep_queue_neigh_stats_work(priv);
+ 
+ 	list_for_each_entry(flow, &e->flows, encap) {
+ 		flow->esw_attr->encap_id = e->encap_id;
+ 		flow->rule = mlx5e_tc_add_fdb_flow(priv,
+ 						   flow->esw_attr->parse_attr,
+ 						   flow);
+ 		if (IS_ERR(flow->rule)) {
+ 			err = PTR_ERR(flow->rule);
+ 			mlx5_core_warn(priv->mdev, "Failed to update cached encapsulation flow, %d\n",
+ 				       err);
+ 			continue;
+ 		}
+ 		flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
+ 	}
+ }
+ 
+ void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
+ 			      struct mlx5e_encap_entry *e)
+ {
+ 	struct mlx5e_tc_flow *flow;
+ 	struct mlx5_fc *counter;
+ 
+ 	list_for_each_entry(flow, &e->flows, encap) {
+ 		if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 			flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
+ 			counter = mlx5_flow_rule_counter(flow->rule);
+ 			mlx5_del_flow_rules(flow->rule);
+ 			mlx5_fc_destroy(priv->mdev, counter);
+ 		}
+ 	}
+ 
+ 	if (e->flags & MLX5_ENCAP_ENTRY_VALID) {
+ 		e->flags &= ~MLX5_ENCAP_ENTRY_VALID;
+ 		mlx5_encap_dealloc(priv->mdev, e->encap_id);
+ 	}
+ }
+ 
+ void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe)
+ {
+ 	struct mlx5e_neigh *m_neigh = &nhe->m_neigh;
+ 	u64 bytes, packets, lastuse = 0;
+ 	struct mlx5e_tc_flow *flow;
+ 	struct mlx5e_encap_entry *e;
+ 	struct mlx5_fc *counter;
+ 	struct neigh_table *tbl;
+ 	bool neigh_used = false;
+ 	struct neighbour *n;
+ 
+ 	if (m_neigh->family == AF_INET)
+ 		tbl = &arp_tbl;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (m_neigh->family == AF_INET6)
+ 		tbl = ipv6_stub->nd_tbl;
+ #endif
+ 	else
+ 		return;
+ 
+ 	list_for_each_entry(e, &nhe->encap_list, encap_list) {
+ 		if (!(e->flags & MLX5_ENCAP_ENTRY_VALID))
+ 			continue;
+ 		list_for_each_entry(flow, &e->flows, encap) {
+ 			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
+ 				counter = mlx5_flow_rule_counter(flow->rule);
+ 				mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
+ 				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
+ 					neigh_used = true;
+ 					break;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	if (neigh_used) {
+ 		nhe->reported_lastuse = jiffies;
+ 
+ 		/* find the relevant neigh according to the cached device and
+ 		 * dst ip pair
+ 		 */
+ 		n = neigh_lookup(tbl, &m_neigh->dst_ip, m_neigh->dev);
+ 		if (!n) {
+ 			WARN(1, "The neighbour already freed\n");
+ 			return;
+ 		}
+ 
+ 		neigh_event_send(n, NULL);
+ 		neigh_release(n);
+ 	}
++>>>>>>> 1a9527bb1742 (net/mlx5e: Use modify header ID cache for offloaded TC E-Switch flows)
  }
  
  static void mlx5e_detach_encap(struct mlx5e_priv *priv,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
