locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit cff2fce58b2b0f59089e7edcdc38803d65057b9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cff2fce5.failed

File-private locks have been re-christened as "open file description"
locks.  Finish the symbol name cleanup in the internal implementation.

	Signed-off-by: Jeff Layton <jlayton@redhat.com>
(cherry picked from commit cff2fce58b2b0f59089e7edcdc38803d65057b9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
#	include/linux/fs.h
diff --cc fs/locks.c
index 20dcff562a1d,e663aeac579e..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -137,12 -134,8 +137,17 @@@
  
  #define IS_POSIX(fl)	(fl->fl_flags & FL_POSIX)
  #define IS_FLOCK(fl)	(fl->fl_flags & FL_FLOCK)
++<<<<<<< HEAD
 +#define IS_LEASE(fl)	(fl->fl_flags & (FL_LEASE|FL_DELEG|FL_LAYOUT))
 +
 +static inline bool is_remote_lock(struct file *filp)
 +{
 +	return likely(!(filp->f_path.dentry->d_sb->s_flags & MS_NOREMOTELOCK));
 +}
++=======
+ #define IS_LEASE(fl)	(fl->fl_flags & (FL_LEASE|FL_DELEG))
+ #define IS_OFDLCK(fl)	(fl->fl_flags & FL_OFDLCK)
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  
  static bool lease_breaking(struct file_lock *fl)
  {
@@@ -2009,6 -1941,16 +2014,19 @@@ int fcntl_getlk(struct file *filp, unsi
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK;
+ 		file_lock.fl_flags |= FL_OFDLCK;
+ 		file_lock.fl_owner = (fl_owner_t)filp;
+ 	}
+ 
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2130,10 -2070,34 +2148,38 @@@ again
  	error = flock_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW) {
++=======
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_OFDLCK flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW:
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2179,6 -2143,16 +2225,19 @@@ int fcntl_getlk64(struct file *filp, un
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK64;
+ 		file_lock.fl_flags |= FL_OFDLCK;
+ 		file_lock.fl_owner = (fl_owner_t)filp;
+ 	}
+ 
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2232,10 -2205,34 +2291,38 @@@ again
  	error = flock64_to_posix_lock(filp, file_lock, &flock);
  	if (error)
  		goto out;
++<<<<<<< HEAD
 +	if (cmd == F_SETLKW64) {
++=======
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_OFDLCK flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK64;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock.l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW64;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = (fl_owner_t)filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW64:
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2413,8 -2410,14 +2500,19 @@@ static void lock_get_status(struct seq_
  
  	seq_printf(f, "%lld:%s ", id, pfx);
  	if (IS_POSIX(fl)) {
++<<<<<<< HEAD
 +		seq_printf(f, "%6s %s ",
 +			     (fl->fl_flags & FL_ACCESS) ? "ACCESS" : "POSIX ",
++=======
+ 		if (fl->fl_flags & FL_ACCESS)
+ 			seq_printf(f, "ACCESS");
+ 		else if (IS_OFDLCK(fl))
+ 			seq_printf(f, "OFDLCK");
+ 		else
+ 			seq_printf(f, "POSIX ");
+ 
+ 		seq_printf(f, " %s ",
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  			     (inode == NULL) ? "*NOINODE*" :
  			     mandatory_lock(inode) ? "MANDATORY" : "ADVISORY ");
  	} else if (IS_FLOCK(fl)) {
diff --cc include/linux/fs.h
index 4086333a0708,878031227c57..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -993,10 -815,7 +993,14 @@@ static inline int file_check_writeable(
  #define FL_SLEEP	128	/* A blocking lock */
  #define FL_DOWNGRADE_PENDING	256 /* Lease is being downgraded */
  #define FL_UNLOCK_PENDING	512 /* Lease is being broken */
++<<<<<<< HEAD
 +#define FL_LAYOUT	2048	/* outstanding pNFS layout */
 +#define FL_LM_OPS_EXTEND	65536 /* safe to use lock_manager_operations_extend */
 +
 +#define FL_CLOSE_POSIX (FL_POSIX | FL_CLOSE)
++=======
+ #define FL_OFDLCK	1024	/* lock is "owned" by struct file */
++>>>>>>> cff2fce58b2b (locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead)
  
  /*
   * Special return value from posix_lock_file() and vfs_lock_file() for
* Unmerged path fs/locks.c
* Unmerged path include/linux/fs.h
