scsi: lpfc: Add Buffer to Buffer credit recovery support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Add Buffer to Buffer credit recovery support (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 94.34%
commit-author James Smart <jsmart2021@gmail.com>
commit 44fd7fe3dd2ce9dba873a0522e1eeab9ab5d5651
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/44fd7fe3.failed

Add Buffer to buffer credit recovery support to the driver.  This is a
negotiated feature with the peer that allows for both sides to detect
dropped RRDY's and FC Frames and recover credit.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 44fd7fe3dd2ce9dba873a0522e1eeab9ab5d5651)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc.h
#	drivers/scsi/lpfc/lpfc_attr.c
#	drivers/scsi/lpfc/lpfc_els.c
#	drivers/scsi/lpfc/lpfc_sli4.h
diff --cc drivers/scsi/lpfc/lpfc.h
index 61c6751c0584,8eb3f96fe068..000000000000
--- a/drivers/scsi/lpfc/lpfc.h
+++ b/drivers/scsi/lpfc/lpfc.h
@@@ -703,7 -751,12 +702,12 @@@ struct lpfc_hba 
  	uint8_t  wwpn[8];
  	uint32_t RandomData[7];
  	uint8_t  fcp_embed_io;
 -	uint8_t  nvme_support;	/* Firmware supports NVME */
 -	uint8_t  nvmet_support;	/* driver supports NVMET */
 -#define LPFC_NVMET_MAX_PORTS	32
  	uint8_t  mds_diags_support;
++<<<<<<< HEAD
++=======
+ 	uint32_t initial_imax;
+ 	uint8_t  bbcredit_support;
++>>>>>>> 44fd7fe3dd2c (scsi: lpfc: Add Buffer to Buffer credit recovery support)
  
  	/* HBA Config Parameters */
  	uint32_t cfg_ack0;
@@@ -772,6 -835,14 +776,17 @@@
  #define LPFC_FDMI_SUPPORT	1	/* FDMI supported? */
  	uint32_t cfg_enable_SmartSAN;
  	uint32_t cfg_enable_mds_diags;
++<<<<<<< HEAD
++=======
+ 	uint32_t cfg_enable_fc4_type;
+ 	uint32_t cfg_enable_bbcr;	/*Enable BB Credit Recovery*/
+ 	uint32_t cfg_xri_split;
+ #define LPFC_ENABLE_FCP  1
+ #define LPFC_ENABLE_NVME 2
+ #define LPFC_ENABLE_BOTH 3
+ 	uint32_t io_channel_irqs;	/* number of irqs for io channels */
+ 	struct nvmet_fc_target_port *targetport;
++>>>>>>> 44fd7fe3dd2c (scsi: lpfc: Add Buffer to Buffer credit recovery support)
  	lpfc_vpd_t vpd;		/* vital product data */
  
  	struct pci_dev *pcidev;
diff --cc drivers/scsi/lpfc/lpfc_attr.c
index e030a290e43b,0806323829e6..000000000000
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@@ -4700,7 -5141,16 +4730,15 @@@ LPFC_ATTR_R(sg_seg_cnt, LPFC_DEFAULT_SG
   */
  LPFC_ATTR_R(enable_mds_diags, 0, 0, 1, "Enable MDS Diagnostics");
  
+ /*
+  * lpfc_enable_bbcr: Enable BB Credit Recovery
+  *       0  = BB Credit Recovery disabled
+  *       1  = BB Credit Recovery enabled (default)
+  * Value range is [0,1]. Default value is 1.
+  */
+ LPFC_BBCR_ATTR_RW(enable_bbcr, 1, 0, 1, "Enable BBC Recovery");
+ 
  struct device_attribute *lpfc_hba_attrs[] = {
 -	&dev_attr_nvme_info,
  	&dev_attr_bg_info,
  	&dev_attr_bg_guard_err,
  	&dev_attr_bg_apptag_err,
@@@ -5795,6 -6258,49 +5834,52 @@@ lpfc_get_cfgparam(struct lpfc_hba *phba
  		phba->cfg_poll = 0;
  	else
  		phba->cfg_poll = lpfc_poll;
++<<<<<<< HEAD
++=======
+ 	lpfc_suppress_rsp_init(phba, lpfc_suppress_rsp);
+ 
+ 	lpfc_enable_fc4_type_init(phba, lpfc_enable_fc4_type);
+ 	lpfc_nvmet_mrq_init(phba, lpfc_nvmet_mrq);
+ 
+ 	/* Initialize first burst. Target vs Initiator are different. */
+ 	lpfc_nvme_enable_fb_init(phba, lpfc_nvme_enable_fb);
+ 	lpfc_nvmet_fb_size_init(phba, lpfc_nvmet_fb_size);
+ 	lpfc_fcp_io_channel_init(phba, lpfc_fcp_io_channel);
+ 	lpfc_nvme_io_channel_init(phba, lpfc_nvme_io_channel);
+ 	lpfc_enable_bbcr_init(phba, lpfc_enable_bbcr);
+ 
+ 	if (phba->sli_rev != LPFC_SLI_REV4) {
+ 		/* NVME only supported on SLI4 */
+ 		phba->nvmet_support = 0;
+ 		phba->cfg_enable_fc4_type = LPFC_ENABLE_FCP;
+ 		phba->cfg_enable_bbcr = 0;
+ 	} else {
+ 		/* We MUST have FCP support */
+ 		if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))
+ 			phba->cfg_enable_fc4_type |= LPFC_ENABLE_FCP;
+ 	}
+ 
+ 	if (phba->cfg_auto_imax && !phba->cfg_fcp_imax)
+ 		phba->cfg_auto_imax = 0;
+ 	phba->initial_imax = phba->cfg_fcp_imax;
+ 
+ 	/* A value of 0 means use the number of CPUs found in the system */
+ 	if (phba->cfg_fcp_io_channel == 0)
+ 		phba->cfg_fcp_io_channel = phba->sli4_hba.num_present_cpu;
+ 	if (phba->cfg_nvme_io_channel == 0)
+ 		phba->cfg_nvme_io_channel = phba->sli4_hba.num_present_cpu;
+ 
+ 	if (phba->cfg_enable_fc4_type == LPFC_ENABLE_NVME)
+ 		phba->cfg_fcp_io_channel = 0;
+ 
+ 	if (phba->cfg_enable_fc4_type == LPFC_ENABLE_FCP)
+ 		phba->cfg_nvme_io_channel = 0;
+ 
+ 	if (phba->cfg_fcp_io_channel > phba->cfg_nvme_io_channel)
+ 		phba->io_channel_irqs = phba->cfg_fcp_io_channel;
+ 	else
+ 		phba->io_channel_irqs = phba->cfg_nvme_io_channel;
++>>>>>>> 44fd7fe3dd2c (scsi: lpfc: Add Buffer to Buffer credit recovery support)
  
  	phba->cfg_soft_wwnn = 0L;
  	phba->cfg_soft_wwpn = 0L;
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 896be78956d8,468a66371de9..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -2022,7 -2032,8 +2022,12 @@@ lpfc_issue_els_plogi(struct lpfc_vport 
  		sp->cmn.fcphHigh = FC_PH3;
  
  	sp->cmn.valid_vendor_ver_level = 0;
++<<<<<<< HEAD
 +	memset(sp->vendorVersion, 0, sizeof(sp->vendorVersion));
++=======
+ 	memset(sp->un.vendorVersion, 0, sizeof(sp->un.vendorVersion));
+ 	sp->cmn.bbRcvSizeMsb &= 0xF;
++>>>>>>> 44fd7fe3dd2c (scsi: lpfc: Add Buffer to Buffer credit recovery support)
  
  	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,
  		"Issue PLOGI:     did:x%x",
@@@ -4037,7 -4210,19 +4052,23 @@@ lpfc_els_rsp_acc(struct lpfc_vport *vpo
  			       sizeof(struct serv_parm));
  
  			sp->cmn.valid_vendor_ver_level = 0;
++<<<<<<< HEAD
 +			memset(sp->vendorVersion, 0, sizeof(sp->vendorVersion));
++=======
+ 			memset(sp->un.vendorVersion, 0,
+ 			       sizeof(sp->un.vendorVersion));
+ 			sp->cmn.bbRcvSizeMsb &= 0xF;
+ 
+ 			/* If our firmware supports this feature, convey that
+ 			 * info to the target using the vendor specific field.
+ 			 */
+ 			if (phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) {
+ 				sp->cmn.valid_vendor_ver_level = 1;
+ 				sp->un.vv.vid = cpu_to_be32(LPFC_VV_EMLX_ID);
+ 				sp->un.vv.flags =
+ 					cpu_to_be32(LPFC_VV_SUPPRESS_RSP);
+ 			}
++>>>>>>> 44fd7fe3dd2c (scsi: lpfc: Add Buffer to Buffer credit recovery support)
  		}
  
  		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,
diff --cc drivers/scsi/lpfc/lpfc_sli4.h
index 10078254ebc7,60200385fe00..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli4.h
+++ b/drivers/scsi/lpfc/lpfc_sli4.h
@@@ -379,12 -408,32 +379,26 @@@ struct lpfc_max_cfg_param 
  
  struct lpfc_hba;
  /* SLI4 HBA multi-fcp queue handler struct */
 -#define LPFC_SLI4_HANDLER_NAME_SZ	16
 -struct lpfc_hba_eq_hdl {
 +struct lpfc_fcp_eq_hdl {
  	uint32_t idx;
 -	char handler_name[LPFC_SLI4_HANDLER_NAME_SZ];
  	struct lpfc_hba *phba;
 -	atomic_t hba_eq_in_use;
 -	struct cpumask *cpumask;
 -	/* CPU affinitsed to or 0xffffffff if multiple */
 -	uint32_t cpu;
 -#define LPFC_MULTI_CPU_AFFINITY 0xffffffff
 +	atomic_t fcp_eq_in_use;
  };
  
+ /*BB Credit recovery value*/
+ struct lpfc_bbscn_params {
+ 	uint32_t word0;
+ #define lpfc_bbscn_min_SHIFT		0
+ #define lpfc_bbscn_min_MASK		0x0000000F
+ #define lpfc_bbscn_min_WORD		word0
+ #define lpfc_bbscn_max_SHIFT		4
+ #define lpfc_bbscn_max_MASK		0x0000000F
+ #define lpfc_bbscn_max_WORD		word0
+ #define lpfc_bbscn_def_SHIFT		8
+ #define lpfc_bbscn_def_MASK		0x0000000F
+ #define lpfc_bbscn_def_WORD		word0
+ };
+ 
  /* Port Capabilities for SLI4 Parameters */
  struct lpfc_pc_sli4_params {
  	uint32_t supported;
@@@ -515,15 -565,21 +529,20 @@@ struct lpfc_sli4_hba 
  	uint32_t ue_to_rp;
  	struct lpfc_register sli_intf;
  	struct lpfc_pc_sli4_params pc_sli4_params;
++<<<<<<< HEAD
 +	struct msix_entry *msix_entries;
 +	uint8_t handler_name[LPFC_SLI4_HANDLER_CNT][LPFC_SLI4_HANDLER_NAME_SZ];
 +	struct lpfc_fcp_eq_hdl *fcp_eq_hdl; /* FCP per-WQ handle */
++=======
+ 	struct lpfc_bbscn_params bbscn_params;
+ 	struct lpfc_hba_eq_hdl *hba_eq_hdl; /* HBA per-WQ handle */
++>>>>>>> 44fd7fe3dd2c (scsi: lpfc: Add Buffer to Buffer credit recovery support)
  
  	/* Pointers to the constructed SLI4 queues */
 -	struct lpfc_queue **hba_eq;  /* Event queues for HBA */
 -	struct lpfc_queue **fcp_cq;  /* Fast-path FCP compl queue */
 -	struct lpfc_queue **nvme_cq; /* Fast-path NVME compl queue */
 -	struct lpfc_queue **nvmet_cqset; /* Fast-path NVMET CQ Set queues */
 -	struct lpfc_queue **nvmet_mrq_hdr; /* Fast-path NVMET hdr MRQs */
 -	struct lpfc_queue **nvmet_mrq_data; /* Fast-path NVMET data MRQs */
 -	struct lpfc_queue **fcp_wq;  /* Fast-path FCP work queue */
 -	struct lpfc_queue **nvme_wq; /* Fast-path NVME work queue */
 +	struct lpfc_queue **hba_eq;/* Event queues for HBA */
 +	struct lpfc_queue **fcp_cq;/* Fast-path FCP compl queue */
 +	struct lpfc_queue **fcp_wq;/* Fast-path FCP work queue */
  	uint16_t *fcp_cq_map;
 -	uint16_t *nvme_cq_map;
 -	struct list_head lpfc_wq_list;
  
  	struct lpfc_queue *mbx_cq; /* Slow-path mailbox complete queue */
  	struct lpfc_queue *els_cq; /* Slow-path ELS response complete queue */
* Unmerged path drivers/scsi/lpfc/lpfc.h
* Unmerged path drivers/scsi/lpfc/lpfc_attr.c
diff --git a/drivers/scsi/lpfc/lpfc_attr.h b/drivers/scsi/lpfc/lpfc_attr.h
index 44e26b021dbf..356213a8d00b 100644
--- a/drivers/scsi/lpfc/lpfc_attr.h
+++ b/drivers/scsi/lpfc/lpfc_attr.h
@@ -44,6 +44,16 @@ lpfc_param_store(name)\
 static DEVICE_ATTR(lpfc_##name, S_IRUGO | S_IWUSR,\
 		   lpfc_##name##_show, lpfc_##name##_store)
 
+#define LPFC_BBCR_ATTR_RW(name, defval, minval, maxval, desc) \
+static uint lpfc_##name = defval;\
+module_param(lpfc_##name, uint, 0444);\
+MODULE_PARM_DESC(lpfc_##name, desc);\
+lpfc_param_show(name)\
+lpfc_param_init(name, defval, minval, maxval)\
+lpfc_param_store(name)\
+static DEVICE_ATTR(lpfc_##name, 0444 | 0644,\
+		   lpfc_##name##_show, lpfc_##name##_store)
+
 #define LPFC_ATTR_HEX_R(name, defval, minval, maxval, desc) \
 static uint lpfc_##name = defval;\
 module_param(lpfc_##name, uint, S_IRUGO);\
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c
index 79d58e5464d6..c0760f359eea 100644
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -1085,6 +1085,7 @@ void
 lpfc_mbx_cmpl_local_config_link(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)
 {
 	struct lpfc_vport *vport = pmb->vport;
+	uint8_t bbscn = 0;
 
 	if (pmb->u.mb.mbxStatus)
 		goto out;
@@ -1111,10 +1112,17 @@ lpfc_mbx_cmpl_local_config_link(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)
 	/* Start discovery by sending a FLOGI. port_state is identically
 	 * LPFC_FLOGI while waiting for FLOGI cmpl
 	 */
-	if (vport->port_state != LPFC_FLOGI)
+	if (vport->port_state != LPFC_FLOGI) {
+		if (phba->bbcredit_support && phba->cfg_enable_bbcr) {
+			bbscn = bf_get(lpfc_bbscn_def,
+				       &phba->sli4_hba.bbscn_params);
+			vport->fc_sparam.cmn.bbRcvSizeMsb &= 0xf;
+			vport->fc_sparam.cmn.bbRcvSizeMsb |= (bbscn << 4);
+		}
 		lpfc_initial_flogi(vport);
-	else if (vport->fc_flag & FC_PT2PT)
+	} else if (vport->fc_flag & FC_PT2PT) {
 		lpfc_disc_start(vport);
+	}
 	return;
 
 out:
diff --git a/drivers/scsi/lpfc/lpfc_hw.h b/drivers/scsi/lpfc/lpfc_hw.h
index cadc7918ae04..c4a31cf1be06 100644
--- a/drivers/scsi/lpfc/lpfc_hw.h
+++ b/drivers/scsi/lpfc/lpfc_hw.h
@@ -2257,15 +2257,27 @@ typedef struct {
 	uint32_t rttov;
 	uint32_t altov;
 	uint32_t crtov;
-	uint32_t citov;
+
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t rsvd4:19;
+	uint32_t cscn:1;
+	uint32_t bbscn:4;
+	uint32_t rsvd3:8;
+#else	/*  __LITTLE_ENDIAN_BITFIELD */
+	uint32_t rsvd3:8;
+	uint32_t bbscn:4;
+	uint32_t cscn:1;
+	uint32_t rsvd4:19;
+#endif
+
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t rrq_enable:1;
 	uint32_t rrq_immed:1;
-	uint32_t rsvd4:29;
+	uint32_t rsvd5:29;
 	uint32_t ack0_enable:1;
 #else	/*  __LITTLE_ENDIAN_BITFIELD */
 	uint32_t ack0_enable:1;
-	uint32_t rsvd4:29;
+	uint32_t rsvd5:29;
 	uint32_t rrq_immed:1;
 	uint32_t rrq_enable:1;
 #endif
diff --git a/drivers/scsi/lpfc/lpfc_hw4.h b/drivers/scsi/lpfc/lpfc_hw4.h
index 3567b6a0d2ee..04c88a5a05c4 100644
--- a/drivers/scsi/lpfc/lpfc_hw4.h
+++ b/drivers/scsi/lpfc/lpfc_hw4.h
@@ -2021,9 +2021,15 @@ struct lpfc_mbx_reg_vfi {
 	uint32_t e_d_tov;
 	uint32_t r_a_tov;
 	uint32_t word10;
-#define lpfc_reg_vfi_nport_id_SHIFT		0
-#define lpfc_reg_vfi_nport_id_MASK		0x00FFFFFF
-#define lpfc_reg_vfi_nport_id_WORD		word10
+#define lpfc_reg_vfi_nport_id_SHIFT	0
+#define lpfc_reg_vfi_nport_id_MASK	0x00FFFFFF
+#define lpfc_reg_vfi_nport_id_WORD	word10
+#define lpfc_reg_vfi_bbcr_SHIFT		27
+#define lpfc_reg_vfi_bbcr_MASK		0x00000001
+#define lpfc_reg_vfi_bbcr_WORD		word10
+#define lpfc_reg_vfi_bbscn_SHIFT	28
+#define lpfc_reg_vfi_bbscn_MASK		0x0000000F
+#define lpfc_reg_vfi_bbscn_WORD		word10
 };
 
 struct lpfc_mbx_init_vpi {
@@ -2296,7 +2302,16 @@ struct lpfc_mbx_read_config {
 #define lpfc_mbx_rd_conf_link_speed_MASK	0x0000FFFF
 #define lpfc_mbx_rd_conf_link_speed_WORD	word6
 	uint32_t rsvd_7;
-	uint32_t rsvd_8;
+	uint32_t word8;
+#define lpfc_mbx_rd_conf_bbscn_min_SHIFT	0
+#define lpfc_mbx_rd_conf_bbscn_min_MASK		0x0000000F
+#define lpfc_mbx_rd_conf_bbscn_min_WORD		word8
+#define lpfc_mbx_rd_conf_bbscn_max_SHIFT	4
+#define lpfc_mbx_rd_conf_bbscn_max_MASK		0x0000000F
+#define lpfc_mbx_rd_conf_bbscn_max_WORD		word8
+#define lpfc_mbx_rd_conf_bbscn_def_SHIFT	8
+#define lpfc_mbx_rd_conf_bbscn_def_MASK		0x0000000F
+#define lpfc_mbx_rd_conf_bbscn_def_WORD		word8
 	uint32_t word9;
 #define lpfc_mbx_rd_conf_lmt_SHIFT		0
 #define lpfc_mbx_rd_conf_lmt_MASK		0x0000FFFF
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index 2b10a2fda177..c94ad8399415 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -7081,6 +7081,11 @@ lpfc_sli4_read_config(struct lpfc_hba *phba)
 			lpfc_printf_log(phba, KERN_WARNING, LOG_SLI,
 					"3082 Mailbox (x%x) returned ldv:x0\n",
 					bf_get(lpfc_mqe_command, &pmb->u.mqe));
+		if (bf_get(lpfc_mbx_rd_conf_bbscn_def, rd_config)) {
+			phba->bbcredit_support = 1;
+			phba->sli4_hba.bbscn_params.word0 = rd_config->word8;
+		}
+
 		phba->sli4_hba.extents_in_use =
 			bf_get(lpfc_mbx_rd_conf_extnts_inuse, rd_config);
 		phba->sli4_hba.max_cfg_param.max_xri =
diff --git a/drivers/scsi/lpfc/lpfc_mbox.c b/drivers/scsi/lpfc/lpfc_mbox.c
index f0fb18d00e9f..d4f98859fd21 100644
--- a/drivers/scsi/lpfc/lpfc_mbox.c
+++ b/drivers/scsi/lpfc/lpfc_mbox.c
@@ -374,7 +374,12 @@ lpfc_config_link(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)
 	mb->un.varCfgLnk.rttov = phba->fc_rttov;
 	mb->un.varCfgLnk.altov = phba->fc_altov;
 	mb->un.varCfgLnk.crtov = phba->fc_crtov;
-	mb->un.varCfgLnk.citov = phba->fc_citov;
+	mb->un.varCfgLnk.cscn = 0;
+	if (phba->bbcredit_support && phba->cfg_enable_bbcr) {
+		mb->un.varCfgLnk.cscn = 1;
+		mb->un.varCfgLnk.bbscn = bf_get(lpfc_bbscn_def,
+						 &phba->sli4_hba.bbscn_params);
+	}
 
 	if (phba->cfg_ack0 && (phba->sli_rev < LPFC_SLI_REV4))
 		mb->un.varCfgLnk.ack0_enable = 1;
@@ -2131,6 +2136,7 @@ lpfc_reg_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport, dma_addr_t phys)
 {
 	struct lpfc_mbx_reg_vfi *reg_vfi;
 	struct lpfc_hba *phba = vport->phba;
+	uint8_t bbscn_fabric = 0, bbscn_max = 0, bbscn_def = 0;
 
 	memset(mbox, 0, sizeof(*mbox));
 	reg_vfi = &mbox->u.mqe.un.reg_vfi;
@@ -2160,16 +2166,39 @@ lpfc_reg_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport, dma_addr_t phys)
 		bf_set(lpfc_reg_vfi_vp, reg_vfi, 0);
 		bf_set(lpfc_reg_vfi_upd, reg_vfi, 1);
 	}
+
+	bf_set(lpfc_reg_vfi_bbcr, reg_vfi, 0);
+	bf_set(lpfc_reg_vfi_bbscn, reg_vfi, 0);
+	bbscn_fabric = (phba->fc_fabparam.cmn.bbRcvSizeMsb >> 4) & 0xF;
+
+	if (phba->bbcredit_support && phba->cfg_enable_bbcr  &&
+	    bbscn_fabric != 0) {
+		bbscn_max = bf_get(lpfc_bbscn_max,
+				   &phba->sli4_hba.bbscn_params);
+		if (bbscn_fabric <= bbscn_max) {
+			bbscn_def = bf_get(lpfc_bbscn_def,
+					   &phba->sli4_hba.bbscn_params);
+
+			if (bbscn_fabric > bbscn_def)
+				bf_set(lpfc_reg_vfi_bbscn, reg_vfi,
+				       bbscn_fabric);
+			else
+				bf_set(lpfc_reg_vfi_bbscn, reg_vfi, bbscn_def);
+
+			bf_set(lpfc_reg_vfi_bbcr, reg_vfi, 1);
+		}
+	}
 	lpfc_printf_vlog(vport, KERN_INFO, LOG_MBOX,
 			"3134 Register VFI, mydid:x%x, fcfi:%d, "
 			" vfi:%d, vpi:%d, fc_pname:%x%x fc_flag:x%x"
-			" port_state:x%x topology chg:%d\n",
+			" port_state:x%x topology chg:%d bbscn_fabric :%d\n",
 			vport->fc_myDID,
 			phba->fcf.fcfi,
 			phba->sli4_hba.vfi_ids[vport->vfi],
 			phba->vpi_ids[vport->vpi],
 			reg_vfi->wwn[0], reg_vfi->wwn[1], vport->fc_flag,
-			vport->port_state, phba->fc_topology_changed);
+			vport->port_state, phba->fc_topology_changed,
+			bbscn_fabric);
 }
 
 /**
* Unmerged path drivers/scsi/lpfc/lpfc_sli4.h
