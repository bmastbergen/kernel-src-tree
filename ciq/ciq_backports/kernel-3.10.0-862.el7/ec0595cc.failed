net_sched: get rid of struct tcf_common

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit ec0595cc4495be579309b4bfd5e997af0f2ae6f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec0595cc.failed

After the previous patch, struct tc_action should be enough
to represent the generic tc action, tcf_common is not necessary
any more. This patch gets rid of it to make tc action code
more readable.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec0595cc4495be579309b4bfd5e997af0f2ae6f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	include/net/tc_act/tc_bpf.h
#	include/net/tc_act/tc_connmark.h
#	include/net/tc_act/tc_ife.h
#	include/net/tc_act/tc_skbedit.h
#	net/sched/act_api.c
#	net/sched/act_police.c
diff --cc include/net/act_api.h
index 7eba1aba336b,41e6a24a44b9..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -7,43 -7,54 +7,94 @@@
  
  #include <net/sch_generic.h>
  #include <net/pkt_sched.h>
++<<<<<<< HEAD
 +
 +struct tcf_common {
 +	struct hlist_node		tcfc_head;
 +	u32				tcfc_index;
 +	int				tcfc_refcnt;
 +	int				tcfc_bindcnt;
 +	u32				tcfc_capab;
 +	int				tcfc_action;
 +	struct tcf_t			tcfc_tm;
 +	struct gnet_stats_basic_packed	tcfc_bstats;
 +	struct gnet_stats_queue		tcfc_qstats;
 +	struct gnet_stats_rate_est64	tcfc_rate_est;
 +	spinlock_t			tcfc_lock;
 +	struct rcu_head			tcfc_rcu;
++=======
+ #include <net/net_namespace.h>
+ #include <net/netns/generic.h>
+ 
+ 
+ struct tcf_hashinfo {
+ 	struct hlist_head	*htab;
+ 	unsigned int		hmask;
+ 	spinlock_t		lock;
+ 	u32			index;
+ };
+ 
+ struct tc_action_ops;
+ 
+ struct tc_action {
+ 	const struct tc_action_ops	*ops;
+ 	__u32				type; /* for backward compat(TCA_OLD_COMPAT) */
+ 	__u32				order;
+ 	struct list_head		list;
+ 	struct tcf_hashinfo		*hinfo;
+ 
+ 	struct hlist_node		tcfa_head;
+ 	u32				tcfa_index;
+ 	int				tcfa_refcnt;
+ 	int				tcfa_bindcnt;
+ 	u32				tcfa_capab;
+ 	int				tcfa_action;
+ 	struct tcf_t			tcfa_tm;
+ 	struct gnet_stats_basic_packed	tcfa_bstats;
+ 	struct gnet_stats_queue		tcfa_qstats;
+ 	struct gnet_stats_rate_est64	tcfa_rate_est;
+ 	spinlock_t			tcfa_lock;
+ 	struct rcu_head			tcfa_rcu;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
  	struct gnet_stats_queue __percpu *cpu_qstats;
 +	struct tc_cookie	*act_cookie;
  };
++<<<<<<< HEAD
 +#define tcf_head	common.tcfc_head
 +#define tcf_index	common.tcfc_index
 +#define tcf_refcnt	common.tcfc_refcnt
 +#define tcf_bindcnt	common.tcfc_bindcnt
 +#define tcf_capab	common.tcfc_capab
 +#define tcf_action	common.tcfc_action
 +#define tcf_tm		common.tcfc_tm
 +#define tcf_bstats	common.tcfc_bstats
 +#define tcf_qstats	common.tcfc_qstats
 +#define tcf_rate_est	common.tcfc_rate_est
 +#define tcf_lock	common.tcfc_lock
 +#define tcf_rcu		common.tcfc_rcu
++=======
+ #define tcf_act		common.tcfa_act
+ #define tcf_head	common.tcfa_head
+ #define tcf_index	common.tcfa_index
+ #define tcf_refcnt	common.tcfa_refcnt
+ #define tcf_bindcnt	common.tcfa_bindcnt
+ #define tcf_capab	common.tcfa_capab
+ #define tcf_action	common.tcfa_action
+ #define tcf_tm		common.tcfa_tm
+ #define tcf_bstats	common.tcfa_bstats
+ #define tcf_qstats	common.tcfa_qstats
+ #define tcf_rate_est	common.tcfa_rate_est
+ #define tcf_lock	common.tcfa_lock
+ #define tcf_rcu		common.tcfa_rcu
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
 +
 +struct tcf_hashinfo {
 +	struct hlist_head	*htab;
 +	unsigned int		hmask;
 +	spinlock_t		lock;
 +	u32			index;
 +};
  
  static inline unsigned int tcf_hash(u32 index, unsigned int hmask)
  {
diff --cc include/net/tc_act/tc_skbedit.h
index b496d5ad7d42,5767e9dbcf92..000000000000
--- a/include/net/tc_act/tc_skbedit.h
+++ b/include/net/tc_act/tc_skbedit.h
@@@ -23,15 -23,14 +23,24 @@@
  #include <linux/tc_act/tc_skbedit.h>
  
  struct tcf_skbedit {
++<<<<<<< HEAD
 +	struct tcf_common	common;
 +	u32			flags;
 +	u32     		priority;
 +	u32     		mark;
 +	u16			queue_mapping;
 +	/* XXX: 16-bit pad here? */
++=======
+ 	struct tc_action	common;
+ 	u32		flags;
+ 	u32		priority;
+ 	u32		mark;
+ 	u16		queue_mapping;
+ 	u16		ptype;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  };
 -#define to_skbedit(a) ((struct tcf_skbedit *)a)
 +#define to_skbedit(a) \
 +	container_of(a->priv, struct tcf_skbedit, common)
  
  /* Return true iff action is mark */
  static inline bool is_tcf_skbedit_mark(const struct tc_action *a)
diff --cc net/sched/act_api.c
index ea1d31e140f8,e4a5f2607ffa..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -43,39 -36,36 +43,56 @@@ static void free_tcf(struct rcu_head *h
  	kfree(p);
  }
  
++<<<<<<< HEAD
 +static void tcf_hash_destroy(struct tc_action *a)
 +{
 +	struct tcf_common *p = a->priv;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +
++=======
+ static void tcf_hash_destroy(struct tcf_hashinfo *hinfo, struct tc_action *p)
+ {
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	spin_lock_bh(&hinfo->lock);
- 	hlist_del(&p->tcfc_head);
+ 	hlist_del(&p->tcfa_head);
  	spin_unlock_bh(&hinfo->lock);
- 	gen_kill_estimator(&p->tcfc_bstats,
- 			   &p->tcfc_rate_est);
+ 	gen_kill_estimator(&p->tcfa_bstats,
+ 			   &p->tcfa_rate_est);
  	/*
- 	 * gen_estimator est_timer() might access p->tcfc_lock
+ 	 * gen_estimator est_timer() might access p->tcfa_lock
  	 * or bstats, wait a RCU grace period before freeing p
  	 */
- 	call_rcu(&p->tcfc_rcu, free_tcf);
+ 	call_rcu(&p->tcfa_rcu, free_tcf);
  }
  
- int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)
+ int __tcf_hash_release(struct tc_action *p, bool bind, bool strict)
  {
++<<<<<<< HEAD
 +	struct tcf_common *p = a->priv;
++=======
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	int ret = 0;
  
  	if (p) {
  		if (bind)
- 			p->tcfc_bindcnt--;
- 		else if (strict && p->tcfc_bindcnt > 0)
+ 			p->tcfa_bindcnt--;
+ 		else if (strict && p->tcfa_bindcnt > 0)
  			return -EPERM;
  
++<<<<<<< HEAD
 +		p->tcfc_refcnt--;
 +		if (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {
 +			if (a->ops->cleanup)
 +				a->ops->cleanup(a, bind);
 +			tcf_hash_destroy(a);
++=======
+ 		p->tcfa_refcnt--;
+ 		if (p->tcfa_bindcnt <= 0 && p->tcfa_refcnt <= 0) {
+ 			if (p->ops->cleanup)
+ 				p->ops->cleanup(p, bind);
+ 			list_del(&p->list);
+ 			tcf_hash_destroy(p->hinfo, p);
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  			ret = ACT_P_DELETED;
  		}
  	}
@@@ -98,19 -85,20 +115,29 @@@ static int tcf_dump_walker(struct sk_bu
  	s_i = cb->args[0];
  
  	for (i = 0; i < (hinfo->hmask + 1); i++) {
++<<<<<<< HEAD
++=======
+ 		struct hlist_head *head;
+ 		struct tc_action *p;
+ 
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
  
- 		hlist_for_each_entry_rcu(p, head, tcfc_head) {
+ 		hlist_for_each_entry_rcu(p, head, tcfa_head) {
  			index++;
  			if (index < s_i)
  				continue;
 +			a->priv = p;
 +			a->order = n_i;
  
 -			nest = nla_nest_start(skb, n_i);
 +			nest = nla_nest_start(skb, a->order);
  			if (nest == NULL)
  				goto nla_put_failure;
++<<<<<<< HEAD
 +			err = tcf_action_dump_1(skb, a, 0, 0);
++=======
+ 			err = tcf_action_dump_1(skb, p, 0, 0);
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  			if (err < 0) {
  				index--;
  				nlmsg_trim(skb, nest);
@@@ -143,18 -128,21 +170,30 @@@ static int tcf_del_walker(struct sk_buf
  	int i = 0, n_i = 0;
  	int ret = -EINVAL;
  
 -	nest = nla_nest_start(skb, 0);
 +	nest = nla_nest_start(skb, a->order);
  	if (nest == NULL)
  		goto nla_put_failure;
 -	if (nla_put_string(skb, TCA_KIND, ops->kind))
 +	if (nla_put_string(skb, TCA_KIND, a->ops->kind))
  		goto nla_put_failure;
  	for (i = 0; i < (hinfo->hmask + 1); i++) {
++<<<<<<< HEAD
 +		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
 +		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
 +			a->priv = p;
 +			ret = __tcf_hash_release(a, false, true);
 +			if (ret == ACT_P_DELETED) {
 +				module_put(a->ops->owner);
++=======
+ 		struct hlist_head *head;
+ 		struct hlist_node *n;
+ 		struct tc_action *p;
+ 
+ 		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
+ 		hlist_for_each_entry_safe(p, n, head, tcfa_head) {
+ 			ret = __tcf_hash_release(p, false, true);
+ 			if (ret == ACT_P_DELETED) {
+ 				module_put(p->ops->owner);
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  				n_i++;
  			} else if (ret < 0)
  				goto nla_put_failure;
@@@ -182,10 -173,11 +221,10 @@@ static int tcf_generic_walker(struct sk
  		return -EINVAL;
  	}
  }
 -EXPORT_SYMBOL(tcf_generic_walker);
  
- static struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo)
+ static struct tc_action *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo)
  {
- 	struct tcf_common *p = NULL;
+ 	struct tc_action *p = NULL;
  	struct hlist_head *head;
  
  	spin_lock_bh(&hinfo->lock);
@@@ -212,49 -205,51 +251,77 @@@ u32 tcf_hash_new_index(struct tcf_hashi
  }
  EXPORT_SYMBOL(tcf_hash_new_index);
  
 -int tcf_hash_search(struct tc_action_net *tn, struct tc_action **a, u32 index)
 +int tcf_hash_search(struct tc_action *a, u32 index)
  {
++<<<<<<< HEAD
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = tcf_hash_lookup(index, hinfo);
 +
 +	if (p) {
 +		a->priv = p;
++=======
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
+ 	struct tc_action *p = tcf_hash_lookup(index, hinfo);
+ 
+ 	if (p) {
+ 		*a = p;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  		return 1;
  	}
  	return 0;
  }
  EXPORT_SYMBOL(tcf_hash_search);
  
 -bool tcf_hash_check(struct tc_action_net *tn, u32 index, struct tc_action **a,
 -		    int bind)
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind)
  {
++<<<<<<< HEAD
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = NULL;
 +	if (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {
 +		if (bind)
 +			p->tcfc_bindcnt++;
 +		p->tcfc_refcnt++;
 +		a->priv = p;
 +		return 1;
++=======
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
+ 	struct tc_action *p = NULL;
+ 
+ 	if (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {
+ 		if (bind)
+ 			p->tcfa_bindcnt++;
+ 		p->tcfa_refcnt++;
+ 		*a = p;
+ 		return true;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	}
 -	return false;
 +	return 0;
  }
  EXPORT_SYMBOL(tcf_hash_check);
  
  void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est)
  {
++<<<<<<< HEAD
 +	struct tcf_common *pc = a->priv;
++=======
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	if (est)
- 		gen_kill_estimator(&pc->tcfc_bstats,
- 				   &pc->tcfc_rate_est);
- 	call_rcu(&pc->tcfc_rcu, free_tcf);
+ 		gen_kill_estimator(&a->tcfa_bstats,
+ 				   &a->tcfa_rate_est);
+ 	call_rcu(&a->tcfa_rcu, free_tcf);
  }
  EXPORT_SYMBOL(tcf_hash_cleanup);
  
 -int tcf_hash_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
 -		    struct tc_action **a, const struct tc_action_ops *ops,
 -		    int bind, bool cpustats)
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats)
  {
++<<<<<<< HEAD
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = kzalloc(size, GFP_KERNEL);
++=======
+ 	struct tc_action *p = kzalloc(ops->size, GFP_KERNEL);
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	int err = -ENOMEM;
  
  	if (unlikely(!p))
@@@ -277,35 -272,37 +344,56 @@@ err2
  			goto err1;
  		}
  	}
++<<<<<<< HEAD
 +	spin_lock_init(&p->tcfc_lock);
 +	INIT_HLIST_NODE(&p->tcfc_head);
 +	p->tcfc_index = index ? index : tcf_hash_new_index(hinfo);
 +	p->tcfc_tm.install = jiffies;
 +	p->tcfc_tm.lastuse = jiffies;
 +	p->tcfc_tm.firstuse = 0;
++=======
+ 	spin_lock_init(&p->tcfa_lock);
+ 	INIT_HLIST_NODE(&p->tcfa_head);
+ 	p->tcfa_index = index ? index : tcf_hash_new_index(tn);
+ 	p->tcfa_tm.install = jiffies;
+ 	p->tcfa_tm.lastuse = jiffies;
+ 	p->tcfa_tm.firstuse = 0;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	if (est) {
- 		err = gen_new_estimator(&p->tcfc_bstats, p->cpu_bstats,
- 					&p->tcfc_rate_est,
- 					&p->tcfc_lock, NULL, est);
+ 		err = gen_new_estimator(&p->tcfa_bstats, p->cpu_bstats,
+ 					&p->tcfa_rate_est,
+ 					&p->tcfa_lock, NULL, est);
  		if (err) {
  			free_percpu(p->cpu_qstats);
  			goto err2;
  		}
  	}
  
++<<<<<<< HEAD
 +	a->priv = (void *) p;
++=======
+ 	p->hinfo = hinfo;
+ 	p->ops = ops;
+ 	INIT_LIST_HEAD(&p->list);
+ 	*a = p;
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  	return 0;
  }
  EXPORT_SYMBOL(tcf_hash_create);
  
 -void tcf_hash_insert(struct tc_action_net *tn, struct tc_action *a)
 +void tcf_hash_insert(struct tc_action *a)
  {
++<<<<<<< HEAD
 +	struct tcf_common *p = a->priv;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
++=======
+ 	struct tcf_hashinfo *hinfo = tn->hinfo;
+ 	unsigned int h = tcf_hash(a->tcfa_index, hinfo->hmask);
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  
  	spin_lock_bh(&hinfo->lock);
- 	hlist_add_head(&p->tcfc_head, &hinfo->htab[h]);
+ 	hlist_add_head(&a->tcfa_head, &hinfo->htab[h]);
  	spin_unlock_bh(&hinfo->lock);
  }
  EXPORT_SYMBOL(tcf_hash_insert);
@@@ -319,14 -313,13 +407,18 @@@ static void tcf_hashinfo_destroy(const 
  	int i;
  
  	for (i = 0; i < hinfo->hmask + 1; i++) {
- 		struct tcf_common *p;
+ 		struct tc_action *p;
  		struct hlist_node *n;
  
- 		hlist_for_each_entry_safe(p, n, &hinfo->htab[i], tcfc_head) {
+ 		hlist_for_each_entry_safe(p, n, &hinfo->htab[i], tcfa_head) {
  			int ret;
  
++<<<<<<< HEAD
 +			a.priv = p;
 +			ret = __tcf_hash_release(&a, false, true);
++=======
+ 			ret = __tcf_hash_release(p, false, true);
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  			if (ret == ACT_P_DELETED)
  				module_put(ops->owner);
  			else if (ret < 0)
@@@ -704,7 -626,6 +796,10 @@@ int tcf_action_copy_stats(struct sk_buf
  {
  	int err = 0;
  	struct gnet_dump d;
++<<<<<<< HEAD
 +	struct tcf_common *p = a->priv;
++=======
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  
  	if (p == NULL)
  		goto errout;
diff --cc net/sched/act_police.c
index 8a7c279e7b2c,b3c7e975fc9e..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -69,9 -72,12 +69,15 @@@ static int tcf_act_police_walker(struc
  	s_i = cb->args[0];
  
  	for (i = 0; i < (POL_TAB_MASK + 1); i++) {
++<<<<<<< HEAD
++=======
+ 		struct hlist_head *head;
+ 		struct tc_action *p;
+ 
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  		head = &hinfo->htab[tcf_hash(i, POL_TAB_MASK)];
  
- 		hlist_for_each_entry_rcu(p, head, tcfc_head) {
+ 		hlist_for_each_entry_rcu(p, head, tcfa_head) {
  			index++;
  			if (index < s_i)
  				continue;
@@@ -81,9 -85,9 +87,15 @@@
  			if (nest == NULL)
  				goto nla_put_failure;
  			if (type == RTM_DELACTION)
++<<<<<<< HEAD
 +				err = tcf_action_dump_1(skb, a, 0, 1);
 +			else
 +				err = tcf_action_dump_1(skb, a, 0, 0);
++=======
+ 				err = tcf_action_dump_1(skb, p, 0, 1);
+ 			else
+ 				err = tcf_action_dump_1(skb, p, 0, 0);
++>>>>>>> ec0595cc4495 (net_sched: get rid of struct tcf_common)
  			if (err < 0) {
  				index--;
  				nla_nest_cancel(skb, nest);
* Unmerged path include/net/tc_act/tc_bpf.h
* Unmerged path include/net/tc_act/tc_connmark.h
* Unmerged path include/net/tc_act/tc_ife.h
* Unmerged path include/net/act_api.h
* Unmerged path include/net/tc_act/tc_bpf.h
* Unmerged path include/net/tc_act/tc_connmark.h
diff --git a/include/net/tc_act/tc_csum.h b/include/net/tc_act/tc_csum.h
index fa8f5fac65e9..50b9137e98bb 100644
--- a/include/net/tc_act/tc_csum.h
+++ b/include/net/tc_act/tc_csum.h
@@ -5,7 +5,7 @@
 #include <net/act_api.h>
 
 struct tcf_csum {
-	struct tcf_common common;
+	struct tc_action common;
 
 	u32 update_flags;
 };
diff --git a/include/net/tc_act/tc_defact.h b/include/net/tc_act/tc_defact.h
index ab9b5d6be67b..51a19633a44f 100644
--- a/include/net/tc_act/tc_defact.h
+++ b/include/net/tc_act/tc_defact.h
@@ -4,7 +4,7 @@
 #include <net/act_api.h>
 
 struct tcf_defact {
-	struct tcf_common	common;
+	struct tc_action	common;
 	u32		tcfd_datalen;
 	void		*tcfd_defdata;
 };
diff --git a/include/net/tc_act/tc_gact.h b/include/net/tc_act/tc_gact.h
index 93c520b83d10..414d00c8ce69 100644
--- a/include/net/tc_act/tc_gact.h
+++ b/include/net/tc_act/tc_gact.h
@@ -5,7 +5,7 @@
 #include <linux/tc_act/tc_gact.h>
 
 struct tcf_gact {
-	struct tcf_common	common;
+	struct tc_action	common;
 #ifdef CONFIG_GACT_PROB
 	u16			tcfg_ptype;
 	u16			tcfg_pval;
* Unmerged path include/net/tc_act/tc_ife.h
diff --git a/include/net/tc_act/tc_ipt.h b/include/net/tc_act/tc_ipt.h
index c0f4193f432c..8b5974614d8d 100644
--- a/include/net/tc_act/tc_ipt.h
+++ b/include/net/tc_act/tc_ipt.h
@@ -6,7 +6,7 @@
 struct xt_entry_target;
 
 struct tcf_ipt {
-	struct tcf_common	common;
+	struct tc_action	common;
 	u32			tcfi_hook;
 	char			*tcfi_tname;
 	struct xt_entry_target	*tcfi_t;
diff --git a/include/net/tc_act/tc_mirred.h b/include/net/tc_act/tc_mirred.h
index 9ea601b2d0be..dbe3abe2a4c3 100644
--- a/include/net/tc_act/tc_mirred.h
+++ b/include/net/tc_act/tc_mirred.h
@@ -5,7 +5,7 @@
 #include <linux/tc_act/tc_mirred.h>
 
 struct tcf_mirred {
-	struct tcf_common	common;
+	struct tc_action	common;
 	int			tcfm_eaction;
 	int			tcfm_ifindex;
 	int			tcfm_ok_push;
diff --git a/include/net/tc_act/tc_nat.h b/include/net/tc_act/tc_nat.h
index 63d8e9ca9d99..eb0cc8ddd02b 100644
--- a/include/net/tc_act/tc_nat.h
+++ b/include/net/tc_act/tc_nat.h
@@ -5,7 +5,7 @@
 #include <net/act_api.h>
 
 struct tcf_nat {
-	struct tcf_common common;
+	struct tc_action common;
 
 	__be32 old_addr;
 	__be32 new_addr;
diff --git a/include/net/tc_act/tc_pedit.h b/include/net/tc_act/tc_pedit.h
index 5b80998879c7..5bdee6c3938f 100644
--- a/include/net/tc_act/tc_pedit.h
+++ b/include/net/tc_act/tc_pedit.h
@@ -4,7 +4,7 @@
 #include <net/act_api.h>
 
 struct tcf_pedit {
-	struct tcf_common	common;
+	struct tc_action	common;
 	unsigned char		tcfp_nkeys;
 	unsigned char		tcfp_flags;
 	struct tc_pedit_key	*tcfp_keys;
* Unmerged path include/net/tc_act/tc_skbedit.h
diff --git a/include/net/tc_act/tc_vlan.h b/include/net/tc_act/tc_vlan.h
index daed22bd4926..7ccb02f84a63 100644
--- a/include/net/tc_act/tc_vlan.h
+++ b/include/net/tc_act/tc_vlan.h
@@ -17,7 +17,7 @@
 #define VLAN_F_PUSH		0x2
 
 struct tcf_vlan {
-	struct tcf_common	common;
+	struct tc_action	common;
 	int			tcfv_action;
 	u16			tcfv_push_vid;
 	__be16			tcfv_push_proto;
* Unmerged path net/sched/act_api.c
* Unmerged path net/sched/act_police.c
