x86/intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation (Jiri Olsa) [1379551]
Rebuild_FUZZ: 97.26%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit db69ef65636e6da135680d75d8646bd7e76136bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/db69ef65.failed

The files in the info directory for MBA are as follows:

 num_closids
 	The maximum number of CLOSids available for MBA

 min_bandwidth
 	The minimum memory bandwidth percentage value

 bandwidth_gran
 	The granularity of the bandwidth control in percent for the
	particular CPU SKU. Intermediate values entered are rounded off
	to the previous control step available. Available bandwidth
	control steps are minimum_bandwidth + N * bandwidth_gran.

 delay_linear
 	When set, the OS writes a linear percentage based value to the
	control MSRs ranging from minimum_bandwidth to 100 percent.

	This value is informational and has no influence on the values
	written to the schemata files. The values written to the
	schemata are always bandwidth percentage that is requested.

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: vikas.shivappa@intel.com
Link: http://lkml.kernel.org/r/1491611637-20417-7-git-send-email-vikas.shivappa@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit db69ef65636e6da135680d75d8646bd7e76136bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt.c
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/include/asm/intel_rdt.h
index 06f50d0ed14f,167fe10f00b9..000000000000
--- a/arch/x86/include/asm/intel_rdt.h
+++ b/arch/x86/include/asm/intel_rdt.h
@@@ -136,6 -104,78 +136,81 @@@ struct msr_param 
  	int			high;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct rdt_cache - Cache allocation related data
+  * @cbm_len:		Length of the cache bit mask
+  * @min_cbm_bits:	Minimum number of consecutive bits to be set
+  * @cbm_idx_mult:	Multiplier of CBM index
+  * @cbm_idx_offset:	Offset of CBM index. CBM index is computed by:
+  *			closid * cbm_idx_multi + cbm_idx_offset
+  *			in a cache bit mask
+  */
+ struct rdt_cache {
+ 	unsigned int	cbm_len;
+ 	unsigned int	min_cbm_bits;
+ 	unsigned int	cbm_idx_mult;
+ 	unsigned int	cbm_idx_offset;
+ };
+ 
+ /**
+  * struct rdt_membw - Memory bandwidth allocation related data
+  * @max_delay:		Max throttle delay. Delay is the hardware
+  *			representation for memory bandwidth.
+  * @min_bw:		Minimum memory bandwidth percentage user can request
+  * @bw_gran:		Granularity at which the memory bandwidth is allocated
+  * @delay_linear:	True if memory B/W delay is in linear scale
+  * @mb_map:		Mapping of memory B/W percentage to memory B/W delay
+  */
+ struct rdt_membw {
+ 	u32		max_delay;
+ 	u32		min_bw;
+ 	u32		bw_gran;
+ 	u32		delay_linear;
+ 	u32		*mb_map;
+ };
+ 
+ /**
+  * struct rdt_resource - attributes of an RDT resource
+  * @enabled:		Is this feature enabled on this machine
+  * @capable:		Is this feature available on this machine
+  * @name:		Name to use in "schemata" file
+  * @num_closid:		Number of CLOSIDs available
+  * @cache_level:	Which cache level defines scope of this resource
+  * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
+  * @msr_base:		Base MSR address for CBMs
+  * @msr_update:		Function pointer to update QOS MSRs
+  * @data_width:		Character width of data when displaying
+  * @domains:		All domains for this resource
+  * @cache:		Cache allocation related data
+  * @info_files:		resctrl info files for the resource
+  * @nr_info_files:	Number of info files
+  */
+ struct rdt_resource {
+ 	bool			enabled;
+ 	bool			capable;
+ 	char			*name;
+ 	int			num_closid;
+ 	int			cache_level;
+ 	u32			default_ctrl;
+ 	unsigned int		msr_base;
+ 	void (*msr_update)	(struct rdt_domain *d, struct msr_param *m,
+ 				 struct rdt_resource *r);
+ 	int			data_width;
+ 	struct list_head	domains;
+ 	union {
+ 		struct rdt_cache	cache;
+ 		struct rdt_membw	membw;
+ 	};
+ 	struct rftype		*info_files;
+ 	int			nr_info_files;
+ };
+ 
+ void rdt_get_cache_infofile(struct rdt_resource *r);
+ void rdt_get_mba_infofile(struct rdt_resource *r);
+ 
++>>>>>>> db69ef65636e (x86/intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation)
  extern struct mutex rdtgroup_mutex;
  
  extern struct rdt_resource rdt_resources_all[];
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index ad087dd4421e,438efefd6862..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -136,10 -163,58 +136,62 @@@ static inline bool cache_alloc_hsw_prob
  	return false;
  }
  
++<<<<<<< HEAD
 +static void rdt_get_config(int idx, struct rdt_resource *r)
++=======
+ /*
+  * rdt_get_mb_table() - get a mapping of bandwidth(b/w) percentage values
+  * exposed to user interface and the h/w understandable delay values.
+  *
+  * The non-linear delay values have the granularity of power of two
+  * and also the h/w does not guarantee a curve for configured delay
+  * values vs. actual b/w enforced.
+  * Hence we need a mapping that is pre calibrated so the user can
+  * express the memory b/w as a percentage value.
+  */
+ static inline bool rdt_get_mb_table(struct rdt_resource *r)
+ {
+ 	/*
+ 	 * There are no Intel SKUs as of now to support non-linear delay.
+ 	 */
+ 	pr_info("MBA b/w map not implemented for cpu:%d, model:%d",
+ 		boot_cpu_data.x86, boot_cpu_data.x86_model);
+ 
+ 	return false;
+ }
+ 
+ static bool rdt_get_mem_config(struct rdt_resource *r)
+ {
+ 	union cpuid_0x10_3_eax eax;
+ 	union cpuid_0x10_x_edx edx;
+ 	u32 ebx, ecx;
+ 
+ 	cpuid_count(0x00000010, 3, &eax.full, &ebx, &ecx, &edx.full);
+ 	r->num_closid = edx.split.cos_max + 1;
+ 	r->membw.max_delay = eax.split.max_delay + 1;
+ 	r->default_ctrl = MAX_MBA_BW;
+ 	if (ecx & MBA_IS_LINEAR) {
+ 		r->membw.delay_linear = true;
+ 		r->membw.min_bw = MAX_MBA_BW - r->membw.max_delay;
+ 		r->membw.bw_gran = MAX_MBA_BW - r->membw.max_delay;
+ 	} else {
+ 		if (!rdt_get_mb_table(r))
+ 			return false;
+ 	}
+ 	r->data_width = 3;
+ 	rdt_get_mba_infofile(r);
+ 
+ 	r->capable = true;
+ 	r->enabled = true;
+ 
+ 	return true;
+ }
+ 
+ static void rdt_get_cache_config(int idx, struct rdt_resource *r)
++>>>>>>> db69ef65636e (x86/intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation)
  {
  	union cpuid_0x10_1_eax eax;
 -	union cpuid_0x10_x_edx edx;
 +	union cpuid_0x10_1_edx edx;
  	u32 ebx, ecx;
  
  	cpuid_count(0x00000010, idx, &eax.full, &ebx, &ecx, &edx.full);
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 13bdbbd81667,f5af0cc7eb0d..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -523,8 -523,7 +522,12 @@@ static int rdt_cbm_mask_show(struct ker
  {
  	struct rdt_resource *r = of->kn->parent->priv;
  
++<<<<<<< HEAD
 +	seq_printf(seq, "%x\n", r->max_cbm);
 +
++=======
+ 	seq_printf(seq, "%x\n", r->default_ctrl);
++>>>>>>> db69ef65636e (x86/intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation)
  	return 0;
  }
  
@@@ -533,8 -532,34 +536,38 @@@ static int rdt_min_cbm_bits_show(struc
  {
  	struct rdt_resource *r = of->kn->parent->priv;
  
++<<<<<<< HEAD
 +	seq_printf(seq, "%d\n", r->min_cbm_bits);
++=======
+ 	seq_printf(seq, "%u\n", r->cache.min_cbm_bits);
+ 	return 0;
+ }
++>>>>>>> db69ef65636e (x86/intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation)
+ 
+ static int rdt_min_bw_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.min_bw);
+ 	return 0;
+ }
+ 
+ static int rdt_bw_gran_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
+ 
+ 	seq_printf(seq, "%u\n", r->membw.bw_gran);
+ 	return 0;
+ }
+ 
+ static int rdt_delay_linear_show(struct kernfs_open_file *of,
+ 			     struct seq_file *seq, void *v)
+ {
+ 	struct rdt_resource *r = of->kn->parent->priv;
  
+ 	seq_printf(seq, "%u\n", r->membw.delay_linear);
  	return 0;
  }
  
@@@ -560,6 -585,46 +593,49 @@@ static struct rftype res_info_files[] 
  	},
  };
  
++<<<<<<< HEAD
++=======
+ /* rdtgroup information files for memory bandwidth. */
+ static struct rftype res_mba_info_files[] = {
+ 	{
+ 		.name		= "num_closids",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_num_closids_show,
+ 	},
+ 	{
+ 		.name		= "min_bandwidth",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_min_bw_show,
+ 	},
+ 	{
+ 		.name		= "bandwidth_gran",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_bw_gran_show,
+ 	},
+ 	{
+ 		.name		= "delay_linear",
+ 		.mode		= 0444,
+ 		.kf_ops		= &rdtgroup_kf_single_ops,
+ 		.seq_show	= rdt_delay_linear_show,
+ 	},
+ };
+ 
+ void rdt_get_mba_infofile(struct rdt_resource *r)
+ {
+ 	r->info_files = res_mba_info_files;
+ 	r->nr_info_files = ARRAY_SIZE(res_mba_info_files);
+ }
+ 
+ void rdt_get_cache_infofile(struct rdt_resource *r)
+ {
+ 	r->info_files = res_cache_info_files;
+ 	r->nr_info_files = ARRAY_SIZE(res_cache_info_files);
+ }
+ 
++>>>>>>> db69ef65636e (x86/intel_rdt/mba: Add info directory files for Memory Bandwidth Allocation)
  static int rdtgroup_create_info_dir(struct kernfs_node *parent_kn)
  {
  	struct kernfs_node *kn_subdir;
* Unmerged path arch/x86/include/asm/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
