IB/hfi1: Use context pointer rather than context index

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 17573972f44d6293ed4fe561816b701241cb0847
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/17573972.failed

The hfi1_<set|clear>_ctxt_<j|p>key functions take a context index and
look up the context based on that index.

Since the context index is being retrieved from the context, this
doesn't seem optimal.

Pass the context pointer for use, rather than the context index.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 17573972f44d6293ed4fe561816b701241cb0847)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.c
#	drivers/infiniband/hw/hfi1/chip.h
diff --cc drivers/infiniband/hw/hfi1/chip.c
index f57caa8b4d09,2f747023444b..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@@ -14460,18 -14542,16 +14460,20 @@@ static void init_txe(struct hfi1_devdat
  		write_csr(dd, SEND_CM_TIMER_CTRL, HFI1_CREDIT_RETURN_RATE);
  }
  
++<<<<<<< HEAD
 +int hfi1_set_ctxt_jkey(struct hfi1_devdata *dd, unsigned ctxt, u16 jkey)
++=======
+ int hfi1_set_ctxt_jkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd,
+ 		       u16 jkey)
++>>>>>>> 17573972f44d (IB/hfi1: Use context pointer rather than context index)
  {
- 	struct hfi1_ctxtdata *rcd = dd->rcd[ctxt];
- 	unsigned sctxt;
- 	int ret = 0;
+ 	u8 hw_ctxt;
  	u64 reg;
  
- 	if (!rcd || !rcd->sc) {
- 		ret = -EINVAL;
- 		goto done;
- 	}
- 	sctxt = rcd->sc->hw_context;
+ 	if (!rcd || !rcd->sc)
+ 		return -EINVAL;
+ 
+ 	hw_ctxt = rcd->sc->hw_context;
  	reg = SEND_CTXT_CHECK_JOB_KEY_MASK_SMASK | /* mask is always 1's */
  		((jkey & SEND_CTXT_CHECK_JOB_KEY_VALUE_MASK) <<
  		 SEND_CTXT_CHECK_JOB_KEY_VALUE_SHIFT);
@@@ -14492,67 -14572,56 +14494,64 @@@
  	reg = RCV_KEY_CTRL_JOB_KEY_ENABLE_SMASK |
  		((jkey & RCV_KEY_CTRL_JOB_KEY_VALUE_MASK) <<
  		 RCV_KEY_CTRL_JOB_KEY_VALUE_SHIFT);
- 	write_kctxt_csr(dd, ctxt, RCV_KEY_CTRL, reg);
- done:
- 	return ret;
+ 	write_kctxt_csr(dd, rcd->ctxt, RCV_KEY_CTRL, reg);
+ 
+ 	return 0;
  }
  
++<<<<<<< HEAD
 +int hfi1_clear_ctxt_jkey(struct hfi1_devdata *dd, unsigned ctxt)
++=======
+ int hfi1_clear_ctxt_jkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd)
++>>>>>>> 17573972f44d (IB/hfi1: Use context pointer rather than context index)
  {
- 	struct hfi1_ctxtdata *rcd = dd->rcd[ctxt];
- 	unsigned sctxt;
- 	int ret = 0;
+ 	u8 hw_ctxt;
  	u64 reg;
  
- 	if (!rcd || !rcd->sc) {
- 		ret = -EINVAL;
- 		goto done;
- 	}
- 	sctxt = rcd->sc->hw_context;
- 	write_kctxt_csr(dd, sctxt, SEND_CTXT_CHECK_JOB_KEY, 0);
+ 	if (!rcd || !rcd->sc)
+ 		return -EINVAL;
+ 
+ 	hw_ctxt = rcd->sc->hw_context;
+ 	write_kctxt_csr(dd, hw_ctxt, SEND_CTXT_CHECK_JOB_KEY, 0);
  	/*
  	 * Disable send-side J_KEY integrity check, unless this is A0 h/w.
  	 * This check would not have been enabled for A0 h/w, see
  	 * set_ctxt_jkey().
  	 */
  	if (!is_ax(dd)) {
- 		reg = read_kctxt_csr(dd, sctxt, SEND_CTXT_CHECK_ENABLE);
+ 		reg = read_kctxt_csr(dd, hw_ctxt, SEND_CTXT_CHECK_ENABLE);
  		reg &= ~SEND_CTXT_CHECK_ENABLE_CHECK_JOB_KEY_SMASK;
- 		write_kctxt_csr(dd, sctxt, SEND_CTXT_CHECK_ENABLE, reg);
+ 		write_kctxt_csr(dd, hw_ctxt, SEND_CTXT_CHECK_ENABLE, reg);
  	}
  	/* Turn off the J_KEY on the receive side */
- 	write_kctxt_csr(dd, ctxt, RCV_KEY_CTRL, 0);
- done:
- 	return ret;
+ 	write_kctxt_csr(dd, rcd->ctxt, RCV_KEY_CTRL, 0);
+ 
+ 	return 0;
  }
  
++<<<<<<< HEAD
 +int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, unsigned ctxt, u16 pkey)
++=======
+ int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd,
+ 		       u16 pkey)
++>>>>>>> 17573972f44d (IB/hfi1: Use context pointer rather than context index)
  {
- 	struct hfi1_ctxtdata *rcd;
- 	unsigned sctxt;
- 	int ret = 0;
+ 	u8 hw_ctxt;
  	u64 reg;
  
- 	if (ctxt < dd->num_rcv_contexts) {
- 		rcd = dd->rcd[ctxt];
- 	} else {
- 		ret = -EINVAL;
- 		goto done;
- 	}
- 	if (!rcd || !rcd->sc) {
- 		ret = -EINVAL;
- 		goto done;
- 	}
- 	sctxt = rcd->sc->hw_context;
+ 	if (!rcd || !rcd->sc)
+ 		return -EINVAL;
+ 
+ 	hw_ctxt = rcd->sc->hw_context;
  	reg = ((u64)pkey & SEND_CTXT_CHECK_PARTITION_KEY_VALUE_MASK) <<
  		SEND_CTXT_CHECK_PARTITION_KEY_VALUE_SHIFT;
- 	write_kctxt_csr(dd, sctxt, SEND_CTXT_CHECK_PARTITION_KEY, reg);
- 	reg = read_kctxt_csr(dd, sctxt, SEND_CTXT_CHECK_ENABLE);
+ 	write_kctxt_csr(dd, hw_ctxt, SEND_CTXT_CHECK_PARTITION_KEY, reg);
+ 	reg = read_kctxt_csr(dd, hw_ctxt, SEND_CTXT_CHECK_ENABLE);
  	reg |= SEND_CTXT_CHECK_ENABLE_CHECK_PARTITION_KEY_SMASK;
  	reg &= ~SEND_CTXT_CHECK_ENABLE_DISALLOW_KDETH_PACKETS_SMASK;
- 	write_kctxt_csr(dd, sctxt, SEND_CTXT_CHECK_ENABLE, reg);
- done:
- 	return ret;
+ 	write_kctxt_csr(dd, hw_ctxt, SEND_CTXT_CHECK_ENABLE, reg);
+ 
+ 	return 0;
  }
  
  int hfi1_clear_ctxt_pkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt)
diff --cc drivers/infiniband/hw/hfi1/chip.h
index 8a7b218d745f,995105214953..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@@ -1351,15 -1352,16 +1351,23 @@@ int hfi1_init_ctxt(struct send_context 
  void hfi1_put_tid(struct hfi1_devdata *dd, u32 index,
  		  u32 type, unsigned long pa, u16 order);
  void hfi1_quiet_serdes(struct hfi1_pportdata *ppd);
 -void hfi1_rcvctrl(struct hfi1_devdata *dd, unsigned int op, u16 ctxt);
 +void hfi1_rcvctrl(struct hfi1_devdata *dd, unsigned int op, int ctxt);
  u32 hfi1_read_cntrs(struct hfi1_devdata *dd, char **namep, u64 **cntrp);
  u32 hfi1_read_portcntrs(struct hfi1_pportdata *ppd, char **namep, u64 **cntrp);
 +u8 hfi1_ibphys_portstate(struct hfi1_pportdata *ppd);
  int hfi1_get_ib_cfg(struct hfi1_pportdata *ppd, int which);
  int hfi1_set_ib_cfg(struct hfi1_pportdata *ppd, int which, u32 val);
++<<<<<<< HEAD
 +int hfi1_set_ctxt_jkey(struct hfi1_devdata *dd, unsigned ctxt, u16 jkey);
 +int hfi1_clear_ctxt_jkey(struct hfi1_devdata *dd, unsigned ctxt);
 +int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, unsigned ctxt, u16 pkey);
++=======
+ int hfi1_set_ctxt_jkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *rcd,
+ 		       u16 jkey);
+ int hfi1_clear_ctxt_jkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt);
+ int hfi1_set_ctxt_pkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt,
+ 		       u16 pkey);
++>>>>>>> 17573972f44d (IB/hfi1: Use context pointer rather than context index)
  int hfi1_clear_ctxt_pkey(struct hfi1_devdata *dd, struct hfi1_ctxtdata *ctxt);
  void hfi1_read_link_quality(struct hfi1_devdata *dd, u8 *link_quality);
  void hfi1_init_vnic_rsm(struct hfi1_devdata *dd);
* Unmerged path drivers/infiniband/hw/hfi1/chip.c
* Unmerged path drivers/infiniband/hw/hfi1/chip.h
diff --git a/drivers/infiniband/hw/hfi1/file_ops.c b/drivers/infiniband/hw/hfi1/file_ops.c
index 32dd4a920494..196a413947a2 100644
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@ -787,7 +787,7 @@ static int hfi1_file_close(struct inode *inode, struct file *fp)
 		     HFI1_RCVCTRL_NO_RHQ_DROP_DIS |
 		     HFI1_RCVCTRL_NO_EGR_DROP_DIS, uctxt->ctxt);
 	/* Clear the context's J_KEY */
-	hfi1_clear_ctxt_jkey(dd, uctxt->ctxt);
+	hfi1_clear_ctxt_jkey(dd, uctxt);
 	/*
 	 * Reset context integrity checks to default.
 	 * (writes to CSRs probably belong in chip.c)
@@ -1137,7 +1137,7 @@ static int user_init(struct file *fp)
 		clear_rcvhdrtail(uctxt);
 
 	/* Setup J_KEY before enabling the context */
-	hfi1_set_ctxt_jkey(uctxt->dd, uctxt->ctxt, uctxt->jkey);
+	hfi1_set_ctxt_jkey(uctxt->dd, uctxt, uctxt->jkey);
 
 	rcvctrl_ops = HFI1_RCVCTRL_CTXT_ENB;
 	if (HFI1_CAP_UGET_MASK(uctxt->flags, HDRSUPP))
@@ -1522,7 +1522,7 @@ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned subctxt,
 		}
 
 	if (intable)
-		ret = hfi1_set_ctxt_pkey(dd, uctxt->ctxt, pkey);
+		ret = hfi1_set_ctxt_pkey(dd, uctxt, pkey);
 done:
 	return ret;
 }
