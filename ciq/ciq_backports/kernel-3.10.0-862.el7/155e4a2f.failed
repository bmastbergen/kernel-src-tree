Drivers: hv: vmbus: Define APIs to manipulate the message page

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Define APIs to manipulate the message page (Mohammed Gamal) [1467258]
Rebuild_FUZZ: 88.29%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 155e4a2f28a59e5344dfa7c5d003161fe59a5bf2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/155e4a2f.failed

As part of cleaning up architecture specific code, define APIs
to manipulate the message page.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 155e4a2f28a59e5344dfa7c5d003161fe59a5bf2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,1e75141bc123..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -70,6 -99,50 +70,53 @@@ static inline  __u64 generate_guest_id(
  	return guest_id;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* Free the message slot and signal end-of-message if required */
+ static inline void vmbus_signal_eom(struct hv_message *msg, u32 old_msg_type)
+ {
+ 	/*
+ 	 * On crash we're reading some other CPU's message page and we need
+ 	 * to be careful: this other CPU may already had cleared the header
+ 	 * and the host may already had delivered some other message there.
+ 	 * In case we blindly write msg->header.message_type we're going
+ 	 * to lose it. We can still lose a message of the same type but
+ 	 * we count on the fact that there can only be one
+ 	 * CHANNELMSG_UNLOAD_RESPONSE and we don't care about other messages
+ 	 * on crash.
+ 	 */
+ 	if (cmpxchg(&msg->header.message_type, old_msg_type,
+ 		    HVMSG_NONE) != old_msg_type)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure the write to MessageType (ie set to
+ 	 * HVMSG_NONE) happens before we read the
+ 	 * MessagePending and EOMing. Otherwise, the EOMing
+ 	 * will not deliver any more messages since there is
+ 	 * no empty slot
+ 	 */
+ 	mb();
+ 
+ 	if (msg->header.message_flags.msg_pending) {
+ 		/*
+ 		 * This will cause message queue rescan to
+ 		 * possibly deliver another msg from the
+ 		 * hypervisor
+ 		 */
+ 		wrmsrl(HV_X64_MSR_EOM, 0);
+ 	}
+ }
+ 
+ #define hv_get_current_tick(tick) rdmsrl(HV_X64_MSR_TIME_REF_COUNT, tick)
+ #define hv_init_timer(timer, tick) wrmsrl(timer, tick)
+ #define hv_init_timer_config(config, val) wrmsrl(config, val)
+ 
+ #define hv_get_simp(val) rdmsrl(HV_X64_MSR_SIMP, val)
+ #define hv_set_simp(val) wrmsrl(HV_X64_MSR_SIMP, val)
+ 
++>>>>>>> 155e4a2f28a5 (Drivers: hv: vmbus: Define APIs to manipulate the message page)
  void hyperv_callback_vector(void);
  #ifdef CONFIG_TRACING
  #define trace_hyperv_callback_vector hyperv_callback_vector
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index f6a591c69dfd..63be56be43d8 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -441,12 +441,12 @@ int hv_synic_init(unsigned int cpu)
 	rdmsrl(HV_X64_MSR_SVERSION, version);
 
 	/* Setup the Synic's message page */
-	rdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);
+	hv_get_simp(simp.as_uint64);
 	simp.simp_enabled = 1;
 	simp.base_simp_gpa = virt_to_phys(hv_context.synic_message_page[cpu])
 		>> PAGE_SHIFT;
 
-	wrmsrl(HV_X64_MSR_SIMP, simp.as_uint64);
+	hv_set_simp(simp.as_uint64);
 
 	/* Setup the Synic's event page */
 	rdmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);
@@ -573,11 +573,11 @@ int hv_synic_cleanup(unsigned int cpu)
 	/* Disable the interrupt */
 	wrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
 
-	rdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);
+	hv_get_simp(simp.as_uint64);
 	simp.simp_enabled = 0;
 	simp.base_simp_gpa = 0;
 
-	wrmsrl(HV_X64_MSR_SIMP, simp.as_uint64);
+	hv_set_simp(simp.as_uint64);
 
 	rdmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);
 	siefp.siefp_enabled = 0;
