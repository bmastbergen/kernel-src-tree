hv_netvsc: Exclude non-TCP port numbers from vRSS hashing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit f72860afa2e32cdc674cbdd7f354f8fb62e908a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f72860af.failed

Azure hosts are not supporting non-TCP port numbers in vRSS hashing for
now. For example, UDP packet loss rate will be high if port numbers are
also included in vRSS hash.

So, we created this patch to use only IP numbers for hashing in non-TCP
traffic.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f72860afa2e32cdc674cbdd7f354f8fb62e908a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 1f2fdf8f9b74,51fa90365348..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -202,6 -191,54 +202,57 @@@ static void *init_ppi_data(struct rndis
  	return ppi;
  }
  
++<<<<<<< HEAD
++=======
+ /* Azure hosts don't support non-TCP port numbers in hashing yet. We compute
+  * hash for non-TCP traffic with only IP numbers.
+  */
+ static inline u32 netvsc_get_hash(struct sk_buff *skb, struct sock *sk)
+ {
+ 	struct flow_keys flow;
+ 	u32 hash;
+ 	static u32 hashrnd __read_mostly;
+ 
+ 	net_get_random_once(&hashrnd, sizeof(hashrnd));
+ 
+ 	if (!skb_flow_dissect_flow_keys(skb, &flow, 0))
+ 		return 0;
+ 
+ 	if (flow.basic.ip_proto == IPPROTO_TCP) {
+ 		return skb_get_hash(skb);
+ 	} else {
+ 		if (flow.basic.n_proto == htons(ETH_P_IP))
+ 			hash = jhash2((u32 *)&flow.addrs.v4addrs, 2, hashrnd);
+ 		else if (flow.basic.n_proto == htons(ETH_P_IPV6))
+ 			hash = jhash2((u32 *)&flow.addrs.v6addrs, 8, hashrnd);
+ 		else
+ 			hash = 0;
+ 
+ 		skb_set_hash(skb, hash, PKT_HASH_TYPE_L3);
+ 	}
+ 
+ 	return hash;
+ }
+ 
+ static inline int netvsc_get_tx_queue(struct net_device *ndev,
+ 				      struct sk_buff *skb, int old_idx)
+ {
+ 	const struct net_device_context *ndc = netdev_priv(ndev);
+ 	struct sock *sk = skb->sk;
+ 	int q_idx;
+ 
+ 	q_idx = ndc->tx_send_table[netvsc_get_hash(skb, sk) &
+ 				   (VRSS_SEND_TAB_SIZE - 1)];
+ 
+ 	/* If queue index changed record the new value */
+ 	if (q_idx != old_idx &&
+ 	    sk && sk_fullsock(sk) && rcu_access_pointer(sk->sk_dst_cache))
+ 		sk_tx_queue_set(sk, q_idx);
+ 
+ 	return q_idx;
+ }
+ 
++>>>>>>> f72860afa2e3 (hv_netvsc: Exclude non-TCP port numbers from vRSS hashing)
  /*
   * Select queue for transmit.
   *
* Unmerged path drivers/net/hyperv/netvsc_drv.c
