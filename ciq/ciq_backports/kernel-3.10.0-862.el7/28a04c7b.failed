mlxsw: spectrum_router: Move VRF refcounting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 28a04c7b7bbecaab642fcb6a2d7354eb70ea7fbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/28a04c7b.failed

When creating a new RIF, bumping RIF count of the containing VR is the
last thing to be done. Symmetrically, when destroying a RIF, RIF count
is first dropped and only then the rest of the cleanup proceeds.

That's a problem for loopback RIFs. Those hold two VR references: one
for overlay and one for underlay. mlxsw_sp_rif_destroy() releases the
overlay one, and the deconfigure() callback the underlay one. But if
both overlay and underlay are the same, and if there are no other
artifacts holding the VR alive, this put actually destroys the VR. Later
on, when mlxsw_sp_rif_destroy() calls mlxsw_sp_vr_put() for the same VR,
the VR will already have been released and the kernel crashes with NULL
pointer dereference.

The underlying problem is that the RIF under destruction ends up
referencing the overlay VR much longer than it claims: all the way until
the call to mlxsw_sp_vr_put(). So line up the reference counting
properly to reflect this. Make corresponding changes in
mlxsw_sp_rif_create() as well for symmetry.

Fixes: 6ddb7426a7d4 ("mlxsw: spectrum_router: Introduce loopback RIFs")
	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28a04c7b7bbecaab642fcb6a2d7354eb70ea7fbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 1b11e7dc65c3,3917b4dd4202..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -2976,138 -5050,481 +2976,176 @@@ mlxsw_sp_rif_alloc(u16 rif, u16 vr_id, 
  }
  
  static struct mlxsw_sp_rif *
 -mlxsw_sp_rif_create(struct mlxsw_sp *mlxsw_sp,
 -		    const struct mlxsw_sp_rif_params *params)
 -{
 -	u32 tb_id = l3mdev_fib_table(params->dev);
 -	const struct mlxsw_sp_rif_ops *ops;
 -	struct mlxsw_sp_fid *fid = NULL;
 -	enum mlxsw_sp_rif_type type;
 -	struct mlxsw_sp_rif *rif;
 +mlxsw_sp_vport_rif_sp_create(struct mlxsw_sp_port *mlxsw_sp_vport,
 +			     struct net_device *l3_dev)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
  	struct mlxsw_sp_vr *vr;
 -	u16 rif_index;
 +	struct mlxsw_sp_fid *f;
 +	struct mlxsw_sp_rif *r;
 +	u16 fid, rif;
  	int err;
  
 -	type = mlxsw_sp_dev_rif_type(mlxsw_sp, params->dev);
 -	ops = mlxsw_sp->router->rif_ops_arr[type];
 +	rif = mlxsw_sp_avail_rif_get(mlxsw_sp);
 +	if (rif == MLXSW_SP_INVALID_RIF)
 +		return ERR_PTR(-ERANGE);
  
 -	vr = mlxsw_sp_vr_get(mlxsw_sp, tb_id ? : RT_TABLE_MAIN);
 +	vr = mlxsw_sp_vr_get(mlxsw_sp, RT_TABLE_MAIN);
  	if (IS_ERR(vr))
  		return ERR_CAST(vr);
+ 	vr->rif_count++;
  
 -	err = mlxsw_sp_rif_index_alloc(mlxsw_sp, &rif_index);
 +	err = mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif,
 +				       true);
 +	if (err)
 +		goto err_vport_rif_sp_op;
 +
 +	fid = mlxsw_sp_rif_sp_to_fid(rif);
 +	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, true);
  	if (err)
 -		goto err_rif_index_alloc;
 +		goto err_rif_fdb_op;
 +
 +	f = mlxsw_sp_rfid_alloc(fid, l3_dev);
 +	if (!f) {
 +		err = -ENOMEM;
 +		goto err_rfid_alloc;
 +	}
  
 -	rif = mlxsw_sp_rif_alloc(ops->rif_size, rif_index, vr->id, params->dev);
 -	if (!rif) {
 +	r = mlxsw_sp_rif_alloc(rif, vr->id, l3_dev, f);
 +	if (!r) {
  		err = -ENOMEM;
  		goto err_rif_alloc;
  	}
 -	rif->mlxsw_sp = mlxsw_sp;
 -	rif->ops = ops;
  
++<<<<<<< HEAD
 +	f->r = r;
 +	mlxsw_sp->rifs[rif] = r;
 +	vr->rif_count++;
++=======
+ 	if (ops->fid_get) {
+ 		fid = ops->fid_get(rif);
+ 		if (IS_ERR(fid)) {
+ 			err = PTR_ERR(fid);
+ 			goto err_fid_get;
+ 		}
+ 		rif->fid = fid;
+ 	}
+ 
+ 	if (ops->setup)
+ 		ops->setup(rif, params);
+ 
+ 	err = ops->configure(rif);
+ 	if (err)
+ 		goto err_configure;
+ 
+ 	mlxsw_sp_rif_counters_alloc(rif);
+ 	mlxsw_sp->router->rifs[rif_index] = rif;
++>>>>>>> 28a04c7b7bbe (mlxsw: spectrum_router: Move VRF refcounting)
  
 -	return rif;
 +	return r;
  
 -err_configure:
 -	if (fid)
 -		mlxsw_sp_fid_put(fid);
 -err_fid_get:
 -	kfree(rif);
  err_rif_alloc:
++<<<<<<< HEAD
 +	kfree(f);
 +err_rfid_alloc:
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
 +err_rif_fdb_op:
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
 +err_vport_rif_sp_op:
++=======
+ err_rif_index_alloc:
+ 	vr->rif_count--;
++>>>>>>> 28a04c7b7bbe (mlxsw: spectrum_router: Move VRF refcounting)
  	mlxsw_sp_vr_put(vr);
  	return ERR_PTR(err);
  }
  
 -void mlxsw_sp_rif_destroy(struct mlxsw_sp_rif *rif)
 -{
 -	const struct mlxsw_sp_rif_ops *ops = rif->ops;
 -	struct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;
 -	struct mlxsw_sp_fid *fid = rif->fid;
 -	struct mlxsw_sp_vr *vr;
 -
 -	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, rif);
 -	vr = &mlxsw_sp->router->vrs[rif->vr_id];
 -
 -	mlxsw_sp->router->rifs[rif->rif_index] = NULL;
 -	mlxsw_sp_rif_counters_free(rif);
 -	ops->deconfigure(rif);
 -	if (fid)
 -		/* Loopback RIFs are not associated with a FID. */
 -		mlxsw_sp_fid_put(fid);
 -	kfree(rif);
 -	vr->rif_count--;
 -	mlxsw_sp_vr_put(vr);
 -}
 -
 -static void
 -mlxsw_sp_rif_subport_params_init(struct mlxsw_sp_rif_params *params,
 -				 struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)
 -{
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -
 -	params->vid = mlxsw_sp_port_vlan->vid;
 -	params->lag = mlxsw_sp_port->lagged;
 -	if (params->lag)
 -		params->lag_id = mlxsw_sp_port->lag_id;
 -	else
 -		params->system_port = mlxsw_sp_port->local_port;
 -}
 -
 -static int
 -mlxsw_sp_port_vlan_router_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,
 -			       struct net_device *l3_dev)
 -{
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 -	u16 vid = mlxsw_sp_port_vlan->vid;
 -	struct mlxsw_sp_rif *rif;
 -	struct mlxsw_sp_fid *fid;
 -	int err;
 -
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (!rif) {
 -		struct mlxsw_sp_rif_params params = {
 -			.dev = l3_dev,
 -		};
 -
 -		mlxsw_sp_rif_subport_params_init(&params, mlxsw_sp_port_vlan);
 -		rif = mlxsw_sp_rif_create(mlxsw_sp, &params);
 -		if (IS_ERR(rif))
 -			return PTR_ERR(rif);
 -	}
 -
 -	/* FID was already created, just take a reference */
 -	fid = rif->ops->fid_get(rif);
 -	err = mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port, vid);
 -	if (err)
 -		goto err_fid_port_vid_map;
 -
 -	err = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);
 -	if (err)
 -		goto err_port_vid_learning_set;
 -
 -	err = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,
 -					BR_STATE_FORWARDING);
 -	if (err)
 -		goto err_port_vid_stp_set;
 -
 -	mlxsw_sp_port_vlan->fid = fid;
 -
 -	return 0;
 -
 -err_port_vid_stp_set:
 -	mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);
 -err_port_vid_learning_set:
 -	mlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);
 -err_fid_port_vid_map:
 -	mlxsw_sp_fid_put(fid);
 -	return err;
 -}
 -
 -void
 -mlxsw_sp_port_vlan_router_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)
 -{
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;
 -	u16 vid = mlxsw_sp_port_vlan->vid;
 -
 -	if (WARN_ON(mlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_RFID))
 -		return;
 -
 -	mlxsw_sp_port_vlan->fid = NULL;
 -	mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_BLOCKING);
 -	mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);
 -	mlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);
 -	/* If router port holds the last reference on the rFID, then the
 -	 * associated Sub-port RIF will be destroyed.
 -	 */
 -	mlxsw_sp_fid_put(fid);
 -}
 -
 -static int mlxsw_sp_inetaddr_port_vlan_event(struct net_device *l3_dev,
 -					     struct net_device *port_dev,
 -					     unsigned long event, u16 vid)
 -{
 -	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(port_dev);
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 -
 -	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);
 -	if (WARN_ON(!mlxsw_sp_port_vlan))
 -		return -EINVAL;
 -
 -	switch (event) {
 -	case NETDEV_UP:
 -		return mlxsw_sp_port_vlan_router_join(mlxsw_sp_port_vlan,
 -						      l3_dev);
 -	case NETDEV_DOWN:
 -		mlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);
 -		break;
 -	}
 -
 -	return 0;
 -}
 -
 -static int mlxsw_sp_inetaddr_port_event(struct net_device *port_dev,
 -					unsigned long event)
 -{
 -	if (netif_is_bridge_port(port_dev) ||
 -	    netif_is_lag_port(port_dev) ||
 -	    netif_is_ovs_port(port_dev))
 -		return 0;
 -
 -	return mlxsw_sp_inetaddr_port_vlan_event(port_dev, port_dev, event, 1);
 -}
 -
 -static int __mlxsw_sp_inetaddr_lag_event(struct net_device *l3_dev,
 -					 struct net_device *lag_dev,
 -					 unsigned long event, u16 vid)
 -{
 -	struct net_device *port_dev;
 -	struct list_head *iter;
 -	int err;
 -
 -	netdev_for_each_lower_dev(lag_dev, port_dev, iter) {
 -		if (mlxsw_sp_port_dev_check(port_dev)) {
 -			err = mlxsw_sp_inetaddr_port_vlan_event(l3_dev,
 -								port_dev,
 -								event, vid);
 -			if (err)
 -				return err;
 -		}
 -	}
 -
 -	return 0;
 -}
 -
 -static int mlxsw_sp_inetaddr_lag_event(struct net_device *lag_dev,
 -				       unsigned long event)
 -{
 -	if (netif_is_bridge_port(lag_dev))
 -		return 0;
 -
 -	return __mlxsw_sp_inetaddr_lag_event(lag_dev, lag_dev, event, 1);
 -}
 -
 -static int mlxsw_sp_inetaddr_bridge_event(struct net_device *l3_dev,
 -					  unsigned long event)
 -{
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
 -	struct mlxsw_sp_rif_params params = {
 -		.dev = l3_dev,
 -	};
 -	struct mlxsw_sp_rif *rif;
 -
 -	switch (event) {
 -	case NETDEV_UP:
 -		rif = mlxsw_sp_rif_create(mlxsw_sp, &params);
 -		if (IS_ERR(rif))
 -			return PTR_ERR(rif);
 -		break;
 -	case NETDEV_DOWN:
 -		rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -		mlxsw_sp_rif_destroy(rif);
 -		break;
 -	}
 -
 -	return 0;
 -}
 -
 -static int mlxsw_sp_inetaddr_vlan_event(struct net_device *vlan_dev,
 -					unsigned long event)
 -{
 -	struct net_device *real_dev = vlan_dev_real_dev(vlan_dev);
 -	u16 vid = vlan_dev_vlan_id(vlan_dev);
 -
 -	if (netif_is_bridge_port(vlan_dev))
 -		return 0;
 -
 -	if (mlxsw_sp_port_dev_check(real_dev))
 -		return mlxsw_sp_inetaddr_port_vlan_event(vlan_dev, real_dev,
 -							 event, vid);
 -	else if (netif_is_lag_master(real_dev))
 -		return __mlxsw_sp_inetaddr_lag_event(vlan_dev, real_dev, event,
 -						     vid);
 -	else if (netif_is_bridge_master(real_dev) && br_vlan_enabled(real_dev))
 -		return mlxsw_sp_inetaddr_bridge_event(vlan_dev, event);
 -
 -	return 0;
 -}
 -
 -static int __mlxsw_sp_inetaddr_event(struct net_device *dev,
 -				     unsigned long event)
 -{
 -	if (mlxsw_sp_port_dev_check(dev))
 -		return mlxsw_sp_inetaddr_port_event(dev, event);
 -	else if (netif_is_lag_master(dev))
 -		return mlxsw_sp_inetaddr_lag_event(dev, event);
 -	else if (netif_is_bridge_master(dev))
 -		return mlxsw_sp_inetaddr_bridge_event(dev, event);
 -	else if (is_vlan_dev(dev))
 -		return mlxsw_sp_inetaddr_vlan_event(dev, event);
 -	else
 -		return 0;
 -}
 -
 -int mlxsw_sp_inetaddr_event(struct notifier_block *unused,
 -			    unsigned long event, void *ptr)
 -{
 -	struct in_ifaddr *ifa = (struct in_ifaddr *) ptr;
 -	struct net_device *dev = ifa->ifa_dev->dev;
 -	struct mlxsw_sp *mlxsw_sp;
 -	struct mlxsw_sp_rif *rif;
 -	int err = 0;
 -
 -	mlxsw_sp = mlxsw_sp_lower_get(dev);
 -	if (!mlxsw_sp)
 -		goto out;
 -
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);
 -	if (!mlxsw_sp_rif_should_config(rif, dev, event))
 -		goto out;
 -
 -	err = __mlxsw_sp_inetaddr_event(dev, event);
 -out:
 -	return notifier_from_errno(err);
 -}
 -
 -struct mlxsw_sp_inet6addr_event_work {
 -	struct work_struct work;
 -	struct net_device *dev;
 -	unsigned long event;
 -};
 -
 -static void mlxsw_sp_inet6addr_event_work(struct work_struct *work)
 -{
 -	struct mlxsw_sp_inet6addr_event_work *inet6addr_work =
 -		container_of(work, struct mlxsw_sp_inet6addr_event_work, work);
 -	struct net_device *dev = inet6addr_work->dev;
 -	unsigned long event = inet6addr_work->event;
 -	struct mlxsw_sp *mlxsw_sp;
 -	struct mlxsw_sp_rif *rif;
 -
 -	rtnl_lock();
 -	mlxsw_sp = mlxsw_sp_lower_get(dev);
 -	if (!mlxsw_sp)
 -		goto out;
 -
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);
 -	if (!mlxsw_sp_rif_should_config(rif, dev, event))
 -		goto out;
 -
 -	__mlxsw_sp_inetaddr_event(dev, event);
 -out:
 -	rtnl_unlock();
 -	dev_put(dev);
 -	kfree(inet6addr_work);
 -}
 -
 -/* Called with rcu_read_lock() */
 -int mlxsw_sp_inet6addr_event(struct notifier_block *unused,
 -			     unsigned long event, void *ptr)
 -{
 -	struct inet6_ifaddr *if6 = (struct inet6_ifaddr *) ptr;
 -	struct mlxsw_sp_inet6addr_event_work *inet6addr_work;
 -	struct net_device *dev = if6->idev->dev;
 -
 -	if (!mlxsw_sp_port_dev_lower_find_rcu(dev))
 -		return NOTIFY_DONE;
 -
 -	inet6addr_work = kzalloc(sizeof(*inet6addr_work), GFP_ATOMIC);
 -	if (!inet6addr_work)
 -		return NOTIFY_BAD;
 -
 -	INIT_WORK(&inet6addr_work->work, mlxsw_sp_inet6addr_event_work);
 -	inet6addr_work->dev = dev;
 -	inet6addr_work->event = event;
 -	dev_hold(dev);
 -	mlxsw_core_schedule_work(&inet6addr_work->work);
 -
 -	return NOTIFY_DONE;
 -}
 -
 -static int mlxsw_sp_rif_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,
 -			     const char *mac, int mtu)
 -{
 -	char ritr_pl[MLXSW_REG_RITR_LEN];
 -	int err;
 -
 -	mlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);
 -	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
 -	if (err)
 -		return err;
 -
 -	mlxsw_reg_ritr_mtu_set(ritr_pl, mtu);
 -	mlxsw_reg_ritr_if_mac_memcpy_to(ritr_pl, mac);
 -	mlxsw_reg_ritr_op_set(ritr_pl, MLXSW_REG_RITR_RIF_CREATE);
 -	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
 -}
 -
 -int mlxsw_sp_netdevice_router_port_event(struct net_device *dev)
 +static void mlxsw_sp_vport_rif_sp_destroy(struct mlxsw_sp_port *mlxsw_sp_vport,
 +					  struct mlxsw_sp_rif *r)
  {
 -	struct mlxsw_sp *mlxsw_sp;
 -	struct mlxsw_sp_rif *rif;
 -	u16 fid_index;
 -	int err;
 -
 -	mlxsw_sp = mlxsw_sp_lower_get(dev);
 -	if (!mlxsw_sp)
 -		return 0;
 -
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);
 -	if (!rif)
 -		return 0;
 -	fid_index = mlxsw_sp_fid_index(rif->fid);
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_vr *vr = &mlxsw_sp->router.vrs[r->vr_id];
 +	struct net_device *l3_dev = r->dev;
 +	struct mlxsw_sp_fid *f = r->f;
 +	u16 fid = f->fid;
 +	u16 rif = r->rif;
  
 -	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, rif->addr, fid_index, false);
 -	if (err)
 -		return err;
 +	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, r);
  
 -	err = mlxsw_sp_rif_edit(mlxsw_sp, rif->rif_index, dev->dev_addr,
 -				dev->mtu);
 -	if (err)
 -		goto err_rif_edit;
++<<<<<<< HEAD
 +	vr->rif_count--;
 +	mlxsw_sp->rifs[rif] = NULL;
 +	f->r = NULL;
  
 -	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, dev->dev_addr, fid_index, true);
 -	if (err)
 -		goto err_rif_fdb_op;
 +	kfree(r);
  
 -	ether_addr_copy(rif->addr, dev->dev_addr);
 -	rif->mtu = dev->mtu;
 +	kfree(f);
  
 -	netdev_dbg(dev, "Updated RIF=%d\n", rif->rif_index);
 +	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
  
 -	return 0;
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
  
 -err_rif_fdb_op:
 -	mlxsw_sp_rif_edit(mlxsw_sp, rif->rif_index, rif->addr, rif->mtu);
 -err_rif_edit:
 -	mlxsw_sp_rif_fdb_op(mlxsw_sp, rif->addr, fid_index, true);
 -	return err;
++=======
++	mlxsw_sp->router->rifs[rif->rif_index] = NULL;
++	mlxsw_sp_rif_counters_free(rif);
++	ops->deconfigure(rif);
++	if (fid)
++		/* Loopback RIFs are not associated with a FID. */
++		mlxsw_sp_fid_put(fid);
++	kfree(rif);
++	vr->rif_count--;
++>>>>>>> 28a04c7b7bbe (mlxsw: spectrum_router: Move VRF refcounting)
 +	mlxsw_sp_vr_put(vr);
  }
  
 -static int mlxsw_sp_port_vrf_join(struct mlxsw_sp *mlxsw_sp,
 -				  struct net_device *l3_dev)
 +static int mlxsw_sp_vport_rif_sp_join(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				      struct net_device *l3_dev)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_rif *r;
  
 -	/* If netdev is already associated with a RIF, then we need to
 -	 * destroy it and create a new one with the new virtual router ID.
 -	 */
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (rif)
 -		__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +	r = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 +	if (!r) {
 +		r = mlxsw_sp_vport_rif_sp_create(mlxsw_sp_vport, l3_dev);
 +		if (IS_ERR(r))
 +			return PTR_ERR(r);
 +	}
 +
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, r->f);
 +	r->f->ref_count++;
 +
 +	netdev_dbg(mlxsw_sp_vport->dev, "Joined FID=%d\n", r->f->fid);
  
 -	return __mlxsw_sp_inetaddr_event(l3_dev, NETDEV_UP);
 +	return 0;
  }
  
 -static void mlxsw_sp_port_vrf_leave(struct mlxsw_sp *mlxsw_sp,
 -				    struct net_device *l3_dev)
 +static void mlxsw_sp_vport_rif_sp_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_rif *rif;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
  
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 -	if (!rif)
 -		return;
 -	__mlxsw_sp_inetaddr_event(l3_dev, NETDEV_DOWN);
 +	netdev_dbg(mlxsw_sp_vport->dev, "Left FID=%d\n", f->fid);
 +
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, NULL);
 +	if (--f->ref_count == 0)
 +		mlxsw_sp_vport_rif_sp_destroy(mlxsw_sp_vport, f->r);
  }
  
 -int mlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,
 -				 struct netdev_notifier_changeupper_info *info)
 +static int mlxsw_sp_inetaddr_vport_event(struct net_device *l3_dev,
 +					 struct net_device *port_dev,
 +					 unsigned long event, u16 vid)
  {
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);
 -	int err = 0;
 +	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(port_dev);
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
  
 -	if (!mlxsw_sp)
 -		return 0;
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, vid);
 +	if (WARN_ON(!mlxsw_sp_vport))
 +		return -EINVAL;
  
  	switch (event) {
 -	case NETDEV_PRECHANGEUPPER:
 -		return 0;
 -	case NETDEV_CHANGEUPPER:
 -		if (info->linking)
 -			err = mlxsw_sp_port_vrf_join(mlxsw_sp, l3_dev);
 -		else
 -			mlxsw_sp_port_vrf_leave(mlxsw_sp, l3_dev);
 +	case NETDEV_UP:
 +		return mlxsw_sp_vport_rif_sp_join(mlxsw_sp_vport, l3_dev);
 +	case NETDEV_DOWN:
 +		mlxsw_sp_vport_rif_sp_leave(mlxsw_sp_vport);
  		break;
  	}
  
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
