qla2xxx: Add Dual mode support in the driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@cavium.com>
commit ead038556f646788e22ad7f0398556d10981ca5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ead03855.failed

Add switch to allow both Initiator Mode & Target
mode to operate at the same time.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit ead038556f646788e22ad7f0398556d10981ca5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,4c0a2d8aa964..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -701,7 -1568,7 +701,11 @@@ qla2x00_initialize_adapter(scsi_qla_hos
  		}
  	}
  
++<<<<<<< HEAD
 +	if (qla_ini_mode_enabled(vha))
++=======
+ 	if (qla_ini_mode_enabled(vha) || qla_dual_mode_enabled(vha))
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  		rval = qla2x00_init_rings(vha);
  
  	ha->flags.chip_reset_done = 1;
@@@ -3093,6 -3988,27 +3097,30 @@@ qla2x00_configure_loop(scsi_qla_host_t 
  			atomic_set(&vha->loop_state, LOOP_READY);
  			ql_dbg(ql_dbg_disc, vha, 0x2069,
  			    "LOOP READY.\n");
++<<<<<<< HEAD
++=======
+ 
+ 			/*
+ 			 * Process any ATIO queue entries that came in
+ 			 * while we weren't online.
+ 			 */
+ 			if (qla_tgt_mode_enabled(vha) ||
+ 			    qla_dual_mode_enabled(vha)) {
+ 				if (IS_QLA27XX(ha) || IS_QLA83XX(ha)) {
+ 					spin_lock_irqsave(&ha->tgt.atio_lock,
+ 					    flags);
+ 					qlt_24xx_process_atio_queue(vha, 0);
+ 					spin_unlock_irqrestore(
+ 					    &ha->tgt.atio_lock, flags);
+ 				} else {
+ 					spin_lock_irqsave(&ha->hardware_lock,
+ 					    flags);
+ 					qlt_24xx_process_atio_queue(vha, 1);
+ 					spin_unlock_irqrestore(
+ 					    &ha->hardware_lock, flags);
+ 				}
+ 			}
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  		}
  	}
  
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,c8f312f8e0ff..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -50,10 -55,21 +50,19 @@@ MODULE_PARM_DESC(qlini_mode
  	"disabled on enabling target mode and then on disabling target mode "
  	"enabled back; "
  	"\"disabled\" - initiator mode will never be enabled; "
+ 	"\"dual\" - Initiator Modes will be enabled. Target Mode can be activated "
+ 	"when ready "
  	"\"enabled\" (default) - initiator mode will always stay enabled.");
  
+ static int ql_dm_tgt_ex_pct = 50;
+ module_param(ql_dm_tgt_ex_pct, int, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(ql_dm_tgt_ex_pct,
+ 	"For Dual Mode (qlini_mode=dual), this parameter determines "
+ 	"the percentage of exchanges/cmds FW will allocate resources "
+ 	"for Target mode.");
+ 
  int ql2x_ini_mode = QLA2XXX_INI_MODE_EXCLUSIVE;
  
 -static int temp_sam_status = SAM_STAT_BUSY;
 -
  /*
   * From scsi/fc/fc_fcp.h
   */
@@@ -4509,7 -5892,8 +4549,12 @@@ void qlt_clear_mode(struct scsi_qla_hos
  		vha->host->active_mode = MODE_INITIATOR;
  		break;
  	case QLA2XXX_INI_MODE_ENABLED:
++<<<<<<< HEAD
 +		vha->host->active_mode &= ~MODE_TARGET;
++=======
+ 	case QLA2XXX_INI_MODE_DUAL:
+ 		vha->host->active_mode = MODE_INITIATOR;
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  		break;
  	default:
  		break;
@@@ -4587,11 -5988,10 +4632,18 @@@ qlt_disable_vha(struct scsi_qla_host *v
  void
  qlt_vport_create(struct scsi_qla_host *vha, struct qla_hw_data *ha)
  {
++<<<<<<< HEAD
 +	if (!qla_tgt_mode_enabled(vha))
 +		return;
 +
 +	mutex_init(&ha->tgt.tgt_mutex);
 +	mutex_init(&ha->tgt.tgt_host_action_mutex);
++=======
+ 	vha->vha_tgt.qla_tgt = NULL;
+ 
+ 	mutex_init(&vha->vha_tgt.tgt_mutex);
+ 	mutex_init(&vha->vha_tgt.tgt_host_action_mutex);
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  
  	qlt_clear_mode(vha);
  
@@@ -4611,13 -6013,11 +4663,18 @@@ qlt_rff_id(struct scsi_qla_host *vha, s
  	 * FC-4 Feature bit 0 indicates target functionality to the name server.
  	 */
  	if (qla_tgt_mode_enabled(vha)) {
 -		ct_req->req.rff_id.fc4_feature = BIT_0;
 +		if (qla_ini_mode_enabled(vha))
 +			ct_req->req.rff_id.fc4_feature = BIT_0 | BIT_1;
 +		else
 +			ct_req->req.rff_id.fc4_feature = BIT_0;
  	} else if (qla_ini_mode_enabled(vha)) {
  		ct_req->req.rff_id.fc4_feature = BIT_1;
++<<<<<<< HEAD
 +	}
++=======
+ 	} else if (qla_dual_mode_enabled(vha))
+ 		ct_req->req.rff_id.fc4_feature = BIT_0 | BIT_1;
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  }
  
  /*
@@@ -4915,10 -6392,12 +5009,17 @@@ voi
  qlt_modify_vp_config(struct scsi_qla_host *vha,
  	struct vp_config_entry_24xx *vpmod)
  {
- 	if (qla_tgt_mode_enabled(vha))
+ 	/* enable target mode.  Bit5 = 1 => disable */
+ 	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha))
  		vpmod->options_idx1 &= ~BIT_5;
++<<<<<<< HEAD
 +	/* Disable ini mode, if requested */
 +	if (!qla_ini_mode_enabled(vha))
++=======
+ 
+ 	/* Disable ini mode, if requested.  bit4 = 1 => disable */
+ 	if (qla_tgt_mode_enabled(vha))
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  		vpmod->options_idx1 &= ~BIT_4;
  }
  
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 45ec37d3095c,8b878a2d7304..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -1653,6 -1731,53 +1653,56 @@@ static void tcm_qla2xxx_drop_lport(stru
  	kfree(lport);
  }
  
++<<<<<<< HEAD
++=======
+ static int tcm_qla2xxx_lport_register_npiv_cb(struct scsi_qla_host *base_vha,
+ 					      void *target_lport_ptr,
+ 					      u64 npiv_wwpn, u64 npiv_wwnn)
+ {
+ 	struct fc_vport *vport;
+ 	struct Scsi_Host *sh = base_vha->host;
+ 	struct scsi_qla_host *npiv_vha;
+ 	struct tcm_qla2xxx_lport *lport =
+ 			(struct tcm_qla2xxx_lport *)target_lport_ptr;
+ 	struct tcm_qla2xxx_lport *base_lport =
+ 			(struct tcm_qla2xxx_lport *)base_vha->vha_tgt.target_lport_ptr;
+ 	struct fc_vport_identifiers vport_id;
+ 
+ 	if (qla_ini_mode_enabled(base_vha)) {
+ 		pr_err("qla2xxx base_vha not enabled for target mode\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	if (!base_lport || !base_lport->tpg_1 ||
+ 	    !atomic_read(&base_lport->tpg_1->lport_tpg_enabled)) {
+ 		pr_err("qla2xxx base_lport or tpg_1 not available\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	memset(&vport_id, 0, sizeof(vport_id));
+ 	vport_id.port_name = npiv_wwpn;
+ 	vport_id.node_name = npiv_wwnn;
+ 	vport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;
+ 	vport_id.vport_type = FC_PORTTYPE_NPIV;
+ 	vport_id.disable = false;
+ 
+ 	vport = fc_vport_create(sh, 0, &vport_id);
+ 	if (!vport) {
+ 		pr_err("fc_vport_create failed for qla2xxx_npiv\n");
+ 		return -ENODEV;
+ 	}
+ 	/*
+ 	 * Setup local pointer to NPIV vhba + target_lport_ptr
+ 	 */
+ 	npiv_vha = (struct scsi_qla_host *)vport->dd_data;
+ 	npiv_vha->vha_tgt.target_lport_ptr = target_lport_ptr;
+ 	lport->qla_vha = npiv_vha;
+ 	scsi_host_get(npiv_vha->host);
+ 	return 0;
+ }
+ 
+ 
++>>>>>>> ead038556f64 (qla2xxx: Add Dual mode support in the driver)
  static struct se_wwn *tcm_qla2xxx_npiv_make_lport(
  	struct target_fabric_configfs *tf,
  	struct config_group *group,
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812..d48982b8973e 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -3076,6 +3076,7 @@ struct qla_hw_data {
 #define FLOGI_SP_SUPPORT        BIT_13
 
 	uint8_t		port_no;		/* Physical port of adapter */
+	uint8_t		exch_starvation;
 
 	/* Timeout timers. */
 	uint8_t 	loop_down_abort_time;    /* port down timer */
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index 5ffd1682f367..0a39c96c74bc 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -988,7 +988,8 @@ global_port_update:
 
 		qla2x00_mark_all_devices_lost(vha, 1);
 
-		if (vha->vp_idx == 0 && !qla_ini_mode_enabled(vha))
+		if (vha->vp_idx == 0 &&
+		    (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)))
 			set_bit(SCR_PENDING, &vha->dpc_flags);
 
 		set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
@@ -1538,6 +1539,7 @@ qla24xx_logio_entry(scsi_qla_host_t *vha, struct req_que *req,
 		    fcport->d_id.b.area, fcport->d_id.b.al_pa,
 		    le32_to_cpu(logio->io_parameter[0]));
 
+		vha->hw->exch_starvation = 0;
 		data[0] = MBS_COMMAND_COMPLETE;
 		if (sp->type != SRB_LOGIN_CMD)
 			goto logio_done;
@@ -1571,6 +1573,21 @@ qla24xx_logio_entry(scsi_qla_host_t *vha, struct req_que *req,
 	case LSC_SCODE_NPORT_USED:
 		data[0] = MBS_LOOP_ID_USED;
 		break;
+	case LSC_SCODE_NOXCB:
+		vha->hw->exch_starvation++;
+		if (vha->hw->exch_starvation > 5) {
+			ql_log(ql_log_warn, vha, 0xffff,
+			    "Exchange starvation. Resetting RISC\n");
+
+			vha->hw->exch_starvation = 0;
+
+			if (IS_P3P_TYPE(vha->hw))
+				set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
+			else
+				set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+			qla2xxx_wake_dpc(vha);
+		}
+		/* drop through */
 	default:
 		data[0] = MBS_COMMAND_ERROR;
 		break;
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0..3a62813b26d4 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -45,10 +45,12 @@
 #define QLA2XXX_INI_MODE_STR_EXCLUSIVE	"exclusive"
 #define QLA2XXX_INI_MODE_STR_DISABLED	"disabled"
 #define QLA2XXX_INI_MODE_STR_ENABLED	"enabled"
+#define QLA2XXX_INI_MODE_STR_DUAL		"dual"
 
 #define QLA2XXX_INI_MODE_EXCLUSIVE	0
 #define QLA2XXX_INI_MODE_DISABLED	1
 #define QLA2XXX_INI_MODE_ENABLED	2
+#define QLA2XXX_INI_MODE_DUAL	3
 
 #define QLA2XXX_COMMAND_COUNT_INIT	250
 #define QLA2XXX_IMMED_NOTIFY_COUNT_INIT 250
@@ -949,6 +951,7 @@ extern void qlt_update_vp_map(struct scsi_qla_host *, int);
  * is not set. Right now, ha value is ignored.
  */
 #define QLA_TGT_MODE_ENABLED() (ql2x_ini_mode != QLA2XXX_INI_MODE_ENABLED)
+
 extern int ql2x_ini_mode;
 
 static inline bool qla_tgt_mode_enabled(struct scsi_qla_host *ha)
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
