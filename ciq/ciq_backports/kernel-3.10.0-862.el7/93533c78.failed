xfs: new inode extent list lookup helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 93533c7855c3c78c8a900cac65c8d669bb14935d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/93533c78.failed

xfs_iext_lookup_extent looks up a single extent at the passed in offset,
and returns the extent covering the area, or the one behind it in case
of a hole, as well as the index of the returned extent in arguments,
as well as a simple bool as return value that is set to false if no
extent could be found because the offset is behind EOF.  It is a simpler
replacement for xfs_bmap_search_extent that leaves looking up the rarely
needed previous extent to the caller and has a nicer calling convention.

xfs_iext_get_extent is a helper for iterating over the extent list,
it takes an extent index as input, and returns the extent at that index
in it's expanded form in an argument if it exists.  The actual return
value is a bool whether the index is valid or not.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 93533c7855c3c78c8a900cac65c8d669bb14935d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_fork.c
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index d6a184f18f85,222e103356c6..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -1938,3 -1986,66 +1938,69 @@@ xfs_iext_irec_update_extoffs
  		ifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Initialize an inode's copy-on-write fork.
+  */
+ void
+ xfs_ifork_init_cow(
+ 	struct xfs_inode	*ip)
+ {
+ 	if (ip->i_cowfp)
+ 		return;
+ 
+ 	ip->i_cowfp = kmem_zone_zalloc(xfs_ifork_zone,
+ 				       KM_SLEEP | KM_NOFS);
+ 	ip->i_cowfp->if_flags = XFS_IFEXTENTS;
+ 	ip->i_cformat = XFS_DINODE_FMT_EXTENTS;
+ 	ip->i_cnextents = 0;
+ }
+ 
+ /*
+  * Lookup the extent covering bno.
+  *
+  * If there is an extent covering bno return the extent index, and store the
+  * expanded extent structure in *gotp, and the extent index in *idx.
+  * If there is no extent covering bno, but there is an extent after it (e.g.
+  * it lies in a hole) return that extent in *gotp and its index in *idx
+  * instead.
+  * If bno is beyond the last extent return false, and return the index after
+  * the last valid index in *idxp.
+  */
+ bool
+ xfs_iext_lookup_extent(
+ 	struct xfs_inode	*ip,
+ 	struct xfs_ifork	*ifp,
+ 	xfs_fileoff_t		bno,
+ 	xfs_extnum_t		*idxp,
+ 	struct xfs_bmbt_irec	*gotp)
+ {
+ 	struct xfs_bmbt_rec_host *ep;
+ 
+ 	XFS_STATS_INC(ip->i_mount, xs_look_exlist);
+ 
+ 	ep = xfs_iext_bno_to_ext(ifp, bno, idxp);
+ 	if (!ep)
+ 		return false;
+ 	xfs_bmbt_get_all(ep, gotp);
+ 	return true;
+ }
+ 
+ /*
+  * Return true if there is an extent at index idx, and return the expanded
+  * extent structure at idx in that case.  Else return false.
+  */
+ bool
+ xfs_iext_get_extent(
+ 	struct xfs_ifork	*ifp,
+ 	xfs_extnum_t		idx,
+ 	struct xfs_bmbt_irec	*gotp)
+ {
+ 	if (idx < 0 || idx >= xfs_iext_count(ifp))
+ 		return false;
+ 	xfs_bmbt_get_all(xfs_iext_get_ext(ifp, idx), gotp);
+ 	return true;
+ }
++>>>>>>> 93533c7855c3 (xfs: new inode extent list lookup helpers)
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
diff --git a/fs/xfs/libxfs/xfs_inode_fork.h b/fs/xfs/libxfs/xfs_inode_fork.h
index 8fa2a172410e..94dc3f5b6860 100644
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@ -167,6 +167,12 @@ void		xfs_iext_irec_compact_pages(struct xfs_ifork *);
 void		xfs_iext_irec_compact_full(struct xfs_ifork *);
 void		xfs_iext_irec_update_extoffs(struct xfs_ifork *, int, int);
 
+bool		xfs_iext_lookup_extent(struct xfs_inode *ip,
+			struct xfs_ifork *ifp, xfs_fileoff_t bno,
+			xfs_extnum_t *idxp, struct xfs_bmbt_irec *gotp);
+bool		xfs_iext_get_extent(struct xfs_ifork *ifp, xfs_extnum_t idx,
+			struct xfs_bmbt_irec *gotp);
+
 extern struct kmem_zone	*xfs_ifork_zone;
 
 #endif	/* __XFS_INODE_FORK_H__ */
