sysfs: add sysfs_open_file->sd and ->file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit bcafe4eea3e58a60e9c2c63781700a9ab1d70f93
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bcafe4ee.failed

sysfs will be converted to use seq_file for read path, which will make
it difficult to pass around multiple pointers directly.  This patch
adds sysfs_open_file->sd and ->file so that we can reach all the
necessary data structures from sysfs_open_file.

flush_write_buffer() is updated to drop @dentry which was used to
discover the sysfs_dirent as it's now available through
sysfs_open_file->sd.

This patch doesn't cause any behavior difference.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bcafe4eea3e58a60e9c2c63781700a9ab1d70f93)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
diff --cc fs/sysfs/file.c
index d8887c896abc,af6e9092a679..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -41,16 -41,15 +41,22 @@@ struct sysfs_open_dirent 
  	atomic_t		refcnt;
  	atomic_t		event;
  	wait_queue_head_t	poll;
 -	struct list_head	files; /* goes through sysfs_open_file.list */
 +	struct list_head	buffers; /* goes through sysfs_buffer.list */
  };
  
++<<<<<<< HEAD
 +struct sysfs_buffer {
++=======
+ struct sysfs_open_file {
+ 	struct sysfs_dirent	*sd;
+ 	struct file		*file;
++>>>>>>> bcafe4eea3e5 (sysfs: add sysfs_open_file->sd and ->file)
  	size_t			count;
 -	char			*page;
 +	loff_t			pos;
 +	char			* page;
 +	const struct sysfs_ops	* ops;
  	struct mutex		mutex;
 +	int			needs_read_fill;
  	int			event;
  	struct list_head	list;
  };
@@@ -176,32 -192,29 +182,48 @@@ static int fill_write_buffer(struct sys
  	return error ? -EFAULT : count;
  }
  
 +
  /**
   *	flush_write_buffer - push buffer to kobject.
++<<<<<<< HEAD
 + *	@dentry:	dentry to the attribute
 + *	@buffer:	data buffer for file.
++=======
+  *	@of:		open file
++>>>>>>> bcafe4eea3e5 (sysfs: add sysfs_open_file->sd and ->file)
   *	@count:		number of bytes
   *
   *	Get the correct pointers for the kobject and the attribute we're
   *	dealing with, then call the store() method for the attribute,
   *	passing the buffer that we acquired in fill_write_buffer().
   */
++<<<<<<< HEAD
 +static int
 +flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)
 +{
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
++=======
+ static int flush_write_buffer(struct sysfs_open_file *of, size_t count)
+ {
+ 	struct kobject *kobj = of->sd->s_parent->s_dir.kobj;
+ 	const struct sysfs_ops *ops;
++>>>>>>> bcafe4eea3e5 (sysfs: add sysfs_open_file->sd and ->file)
  	int rc;
  
- 	/* need attr_sd for attr and ops, its parent for kobj */
- 	if (!sysfs_get_active(attr_sd))
+ 	/* need @of->sd for attr and ops, its parent for kobj */
+ 	if (!sysfs_get_active(of->sd))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	rc = ops->store(kobj, attr_sd->s_attr.attr, buffer->page, count);
++=======
+ 	ops = sysfs_file_ops(of->sd);
+ 	rc = ops->store(kobj, of->sd->s_attr.attr, of->page, count);
++>>>>>>> bcafe4eea3e5 (sysfs: add sysfs_open_file->sd and ->file)
  
- 	sysfs_put_active(attr_sd);
+ 	sysfs_put_active(of->sd);
  
  	return rc;
  }
@@@ -223,20 -235,19 +245,24 @@@
   *	Hint: if you're writing a value, first read the file, modify only the
   *	the value you're changing, then write entire buffer back.
   */
 -static ssize_t sysfs_write_file(struct file *file, const char __user *buf,
 -				size_t count, loff_t *ppos)
 +
 +static ssize_t
 +sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
 -	struct sysfs_open_file *of = file->private_data;
 +	struct sysfs_buffer * buffer = file->private_data;
  	ssize_t len;
  
 -	mutex_lock(&of->mutex);
 -	len = fill_write_buffer(of, buf, count);
 +	mutex_lock(&buffer->mutex);
 +	len = fill_write_buffer(buffer, buf, count);
  	if (len > 0)
++<<<<<<< HEAD
 +		len = flush_write_buffer(file->f_path.dentry, buffer, len);
++=======
+ 		len = flush_write_buffer(of, len);
++>>>>>>> bcafe4eea3e5 (sysfs: add sysfs_open_file->sd and ->file)
  	if (len > 0)
  		*ppos += len;
 -	mutex_unlock(&of->mutex);
 +	mutex_unlock(&buffer->mutex);
  	return len;
  }
  
@@@ -367,21 -374,22 +393,28 @@@ static int sysfs_open_file(struct inod
  			goto err_out;
  	}
  
 -	/*
 -	 * No error? Great, allocate a sysfs_open_file for the file, and
 -	 * store it it in file->private_data for easy access.
 +	/* No error? Great, allocate a buffer for the file, and store it
 +	 * it in file->private_data for easy access.
  	 */
  	error = -ENOMEM;
 -	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
 -	if (!of)
 +	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
 +	if (!buffer)
  		goto err_out;
  
++<<<<<<< HEAD
 +	mutex_init(&buffer->mutex);
 +	buffer->needs_read_fill = 1;
 +	buffer->ops = ops;
 +	file->private_data = buffer;
++=======
+ 	mutex_init(&of->mutex);
+ 	of->sd = attr_sd;
+ 	of->file = file;
+ 	file->private_data = of;
++>>>>>>> bcafe4eea3e5 (sysfs: add sysfs_open_file->sd and ->file)
  
  	/* make sure we have open dirent struct */
 -	error = sysfs_get_open_dirent(attr_sd, of);
 +	error = sysfs_get_open_dirent(attr_sd, buffer);
  	if (error)
  		goto err_free;
  
* Unmerged path fs/sysfs/file.c
