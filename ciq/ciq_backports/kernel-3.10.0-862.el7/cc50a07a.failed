userns: Remove the now unnecessary FS_USERNS_DEV_MOUNT flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit cc50a07a247e17db76b1f0b0ca06652556e04fa3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/cc50a07a.failed

Now that SB_I_NODEV controls the nodev behavior devpts can just clear
this flag during mount.  Simplifying the code and making it easier
to audit how the code works.  While still preserving the invariant
that s_iflags is only modified during mount.

	Acked-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit cc50a07a247e17db76b1f0b0ca06652556e04fa3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/devpts/inode.c
#	fs/super.c
#	include/linux/fs.h
diff --cc fs/devpts/inode.c
index 5dd7a19aa582,d116453b0276..000000000000
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@@ -511,9 -481,7 +512,13 @@@ static struct file_system_type devpts_f
  	.name		= "devpts",
  	.mount		= devpts_mount,
  	.kill_sb	= devpts_kill_sb,
++<<<<<<< HEAD
 +#ifdef CONFIG_DEVPTS_MULTIPLE_INSTANCES
 +	.fs_flags	= FS_USERNS_MOUNT | FS_USERNS_DEV_MOUNT,
 +#endif
++=======
+ 	.fs_flags	= FS_USERNS_MOUNT,
++>>>>>>> cc50a07a247e (userns: Remove the now unnecessary FS_USERNS_DEV_MOUNT flag)
  };
  
  /*
diff --cc fs/super.c
index 8a24c3f5ff79,37813bf479cf..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -142,26 -191,34 +142,31 @@@ static struct super_block *alloc_super(
  	if (!s)
  		return NULL;
  
 -	INIT_LIST_HEAD(&s->s_mounts);
 -	s->s_user_ns = get_user_ns(user_ns);
 -
  	if (security_sb_alloc(s))
  		goto fail;
 -
  	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
 -		if (__percpu_init_rwsem(&s->s_writers.rw_sem[i],
 -					sb_writers_name[i],
 -					&type->s_writers_key[i]))
 +		if (percpu_counter_init(&s->s_writers.counter[i], 0,
 +					GFP_KERNEL) < 0)
  			goto fail;
 +		lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],
 +				 &type->s_writers_key[i], 0);
  	}
 +	init_waitqueue_head(&s->s_writers.wait);
  	init_waitqueue_head(&s->s_writers.wait_unfrozen);
 -	s->s_bdi = &noop_backing_dev_info;
  	s->s_flags = flags;
++<<<<<<< HEAD
 +	s->s_bdi = &default_backing_dev_info;
++=======
+ 	if (s->s_user_ns != &init_user_ns)
+ 		s->s_iflags |= SB_I_NODEV;
++>>>>>>> cc50a07a247e (userns: Remove the now unnecessary FS_USERNS_DEV_MOUNT flag)
  	INIT_HLIST_NODE(&s->s_instances);
  	INIT_HLIST_BL_HEAD(&s->s_anon);
 -	mutex_init(&s->s_sync_lock);
  	INIT_LIST_HEAD(&s->s_inodes);
 -	spin_lock_init(&s->s_inode_list_lock);
 -
 -	if (list_lru_init_memcg(&s->s_dentry_lru))
 -		goto fail;
 -	if (list_lru_init_memcg(&s->s_inode_lru))
 -		goto fail;
 -
 +	INIT_LIST_HEAD(&s->s_dentry_lru);
 +	INIT_LIST_HEAD(&s->s_inode_lru);
 +	spin_lock_init(&s->s_inode_lru_lock);
 +	INIT_LIST_HEAD(&s->s_mounts);
  	init_rwsem(&s->s_umount);
  	lockdep_set_class(&s->s_umount, &type->s_umount_key);
  	/*
diff --cc include/linux/fs.h
index 24213ce025a6,375e37f42cdf..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -2093,15 -2022,7 +2093,18 @@@ struct file_system_type 
  #define FS_BINARY_MOUNTDATA	2
  #define FS_HAS_SUBTYPE		4
  #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
++<<<<<<< HEAD
 +#define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
 +#define FS_HAS_RM_XQUOTA	256	/* KABI: fs has the rm_xquota quota op */
 +#define FS_HAS_INVALIDATE_RANGE	512	/* FS has new ->invalidatepage with length arg */
 +#define FS_HAS_DIO_IODONE2	1024	/* KABI: fs supports new iodone */
 +#define FS_HAS_NEXTDQBLK	2048	/* KABI: fs has the ->get_nextdqblk op */
 +#define FS_HAS_DOPS_WRAPPER	4096	/* kabi: fs is using dentry_operations_wrapper. sb->s_d_op points to
 +dentry_operations_wrapper */
++=======
++>>>>>>> cc50a07a247e (userns: Remove the now unnecessary FS_USERNS_DEV_MOUNT flag)
  #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 +#define FS_HAS_FO_EXTEND	65536 	/* fs is using the file_operations_extend struture */
  	struct dentry *(*mount) (struct file_system_type *, int,
  		       const char *, void *);
  	void (*kill_sb) (struct super_block *);
* Unmerged path fs/devpts/inode.c
* Unmerged path fs/super.c
* Unmerged path include/linux/fs.h
