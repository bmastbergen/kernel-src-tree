bnxt_en: Add a set of TX rings to support XDP.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add a set of TX rings to support XDP (Jonathan Toppins) [1459659]
Rebuild_FUZZ: 98.90%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 5f4492493e75dafc5cbb96eabe0f146c2ffb1e3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5f449249.failed

Add logic for an extra set of TX rings for XDP.  If enabled, this
set of TX rings equals the number of RX rings and shares the same
IRQ as the RX ring set.  A new field bp->tx_nr_rings_xdp is added
to keep track of these TX XDP rings.  Adjust all other relevant functions
to handle bp->tx_nr_rings_xdp.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f4492493e75dafc5cbb96eabe0f146c2ffb1e3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 10385773ecb6,412a8de8c2c8..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -6535,29 -6586,35 +6540,52 @@@ static void bnxt_sp_task(struct work_st
  	clear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);
  }
  
++<<<<<<< HEAD
 +static void bnxt_unmap_bars(struct bnxt *bp, struct pci_dev *pdev)
++=======
+ /* Under rtnl_lock */
+ int bnxt_reserve_rings(struct bnxt *bp, int tx, int rx, int tcs, int tx_xdp)
++>>>>>>> 5f4492493e75 (bnxt_en: Add a set of TX rings to support XDP.)
  {
 -	int max_rx, max_tx, tx_sets = 1;
 -	int tx_rings_needed;
 -	bool sh = true;
 -	int rc;
 +	if (bp->bar2) {
 +		pci_iounmap(pdev, bp->bar2);
 +		bp->bar2 = NULL;
 +	}
  
 -	if (!(bp->flags & BNXT_FLAG_SHARED_RINGS))
 -		sh = false;
 +	if (bp->bar1) {
 +		pci_iounmap(pdev, bp->bar1);
 +		bp->bar1 = NULL;
 +	}
  
 -	if (tcs)
 -		tx_sets = tcs;
 +	if (bp->bar0) {
 +		pci_iounmap(pdev, bp->bar0);
 +		bp->bar0 = NULL;
 +	}
 +}
  
++<<<<<<< HEAD
 +static void bnxt_cleanup_pci(struct bnxt *bp)
 +{
 +	bnxt_unmap_bars(bp, bp->pdev);
 +	pci_release_regions(bp->pdev);
 +	pci_disable_device(bp->pdev);
++=======
+ 	rc = bnxt_get_max_rings(bp, &max_rx, &max_tx, sh);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (max_rx < rx)
+ 		return -ENOMEM;
+ 
+ 	tx_rings_needed = tx * tx_sets + tx_xdp;
+ 	if (max_tx < tx_rings_needed)
+ 		return -ENOMEM;
+ 
+ 	if (bnxt_hwrm_reserve_tx_rings(bp, &tx_rings_needed) ||
+ 	    tx_rings_needed < (tx * tx_sets + tx_xdp))
+ 		return -ENOMEM;
+ 	return 0;
++>>>>>>> 5f4492493e75 (bnxt_en: Add a set of TX rings to support XDP.)
  }
  
  static int bnxt_init_board(struct pci_dev *pdev, struct net_device *dev)
@@@ -6723,19 -6793,10 +6751,26 @@@ int bnxt_setup_mq_tc(struct net_device 
  	if (bp->flags & BNXT_FLAG_SHARED_RINGS)
  		sh = true;
  
++<<<<<<< HEAD
 +	if (tc) {
 +		int max_rx_rings, max_tx_rings, req_tx_rings, rsv_tx_rings, rc;
 +
 +		req_tx_rings = bp->tx_nr_rings_per_tc * tc;
 +		rc = bnxt_get_max_rings(bp, &max_rx_rings, &max_tx_rings, sh);
 +		if (rc || req_tx_rings > max_tx_rings)
 +			return -ENOMEM;
 +
 +		rsv_tx_rings = req_tx_rings;
 +		if (bnxt_hwrm_reserve_tx_rings(bp, &rsv_tx_rings) ||
 +		    rsv_tx_rings < req_tx_rings)
 +			return -ENOMEM;
 +	}
++=======
+ 	rc = bnxt_reserve_rings(bp, bp->tx_nr_rings_per_tc, bp->rx_nr_rings,
+ 				tc, bp->tx_nr_rings_xdp);
+ 	if (rc)
+ 		return rc;
++>>>>>>> 5f4492493e75 (bnxt_en: Add a set of TX rings to support XDP.)
  
  	/* Needs to close the device and do hw resource re-allocations */
  	if (netif_running(bp->dev))
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 5e8dec350fca,4c3289a7fea8..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1203,6 -1204,7 +1204,10 @@@ int bnxt_hwrm_set_link_setting(struct b
  int bnxt_hwrm_fw_set_time(struct bnxt *);
  int bnxt_open_nic(struct bnxt *, bool, bool);
  int bnxt_close_nic(struct bnxt *, bool, bool);
++<<<<<<< HEAD
++=======
+ int bnxt_reserve_rings(struct bnxt *bp, int tx, int rx, int tcs, int tx_xdp);
++>>>>>>> 5f4492493e75 (bnxt_en: Add a set of TX rings to support XDP.)
  int bnxt_setup_mq_tc(struct net_device *dev, u8 tc);
  int bnxt_get_max_rings(struct bnxt *, int *, int *, bool);
  void bnxt_restore_pf_fw_resources(struct bnxt *bp);
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 2f132686f064,7aa248db10c6..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@@ -387,10 -387,10 +387,15 @@@ static int bnxt_set_channels(struct net
  			     struct ethtool_channels *channel)
  {
  	struct bnxt *bp = netdev_priv(dev);
 -	int req_tx_rings, req_rx_rings, tcs;
 +	int max_rx_rings, max_tx_rings, tcs;
 +	int req_tx_rings, rsv_tx_rings;
 +	u32 rc = 0;
  	bool sh = false;
++<<<<<<< HEAD
++=======
+ 	int tx_xdp = 0;
+ 	int rc = 0;
++>>>>>>> 5f4492493e75 (bnxt_en: Add a set of TX rings to support XDP.)
  
  	if (channel->other_count)
  		return -EINVAL;
@@@ -410,32 -410,21 +415,47 @@@
  	if (channel->combined_count)
  		sh = true;
  
 +	bnxt_get_max_rings(bp, &max_rx_rings, &max_tx_rings, sh);
 +
  	tcs = netdev_get_num_tc(dev);
 +	if (tcs > 1)
 +		max_tx_rings /= tcs;
 +
 +	if (sh &&
 +	    channel->combined_count > max_t(int, max_rx_rings, max_tx_rings))
 +		return -ENOMEM;
 +
 +	if (!sh && (channel->rx_count > max_rx_rings ||
 +		    channel->tx_count > max_tx_rings))
 +		return -ENOMEM;
  
  	req_tx_rings = sh ? channel->combined_count : channel->tx_count;
++<<<<<<< HEAD
 +	req_tx_rings = min_t(int, req_tx_rings, max_tx_rings);
 +	if (tcs > 1)
 +		req_tx_rings *= tcs;
 +
 +	rsv_tx_rings = req_tx_rings;
 +	if (bnxt_hwrm_reserve_tx_rings(bp, &rsv_tx_rings))
 +		return -ENOMEM;
 +
 +	if (rsv_tx_rings < req_tx_rings) {
 +		netdev_warn(dev, "Unable to allocate the requested tx rings\n");
 +		return -ENOMEM;
++=======
+ 	req_rx_rings = sh ? channel->combined_count : channel->rx_count;
+ 	if (bp->tx_nr_rings_xdp) {
+ 		if (!sh) {
+ 			netdev_err(dev, "Only combined mode supported when XDP is enabled.\n");
+ 			return -EINVAL;
+ 		}
+ 		tx_xdp = req_rx_rings;
+ 	}
+ 	rc = bnxt_reserve_rings(bp, req_tx_rings, req_rx_rings, tcs, tx_xdp);
+ 	if (rc) {
+ 		netdev_warn(dev, "Unable to allocate the requested rings\n");
+ 		return rc;
++>>>>>>> 5f4492493e75 (bnxt_en: Add a set of TX rings to support XDP.)
  	}
  
  	if (netif_running(dev)) {
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
