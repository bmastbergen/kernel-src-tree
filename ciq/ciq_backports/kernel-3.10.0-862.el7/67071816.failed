hyperv: fix warning about missing prototype

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 670718161852c6acdb8d6bca6a73510f7b9f4320
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/67071816.failed

Compiling with warnings enabled finds missing prototype for
hv_do_hypercall.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 670718161852c6acdb8d6bca6a73510f7b9f4320)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,ecaa3f3b1923..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -24,8 -24,84 +24,84 @@@
  #include <linux/version.h>
  #include <linux/vmalloc.h>
  #include <linux/mm.h>
++<<<<<<< HEAD
++=======
+ #include <linux/clockchips.h>
+ #include <linux/hyperv.h>
+ 
+ #ifdef CONFIG_X86_64
+ 
+ static struct ms_hyperv_tsc_page *tsc_pg;
+ 
+ static u64 read_hv_clock_tsc(struct clocksource *arg)
+ {
+ 	u64 current_tick;
+ 
+ 	if (tsc_pg->tsc_sequence != 0) {
+ 		/*
+ 		 * Use the tsc page to compute the value.
+ 		 */
+ 
+ 		while (1) {
+ 			u64 tmp;
+ 			u32 sequence = tsc_pg->tsc_sequence;
+ 			u64 cur_tsc;
+ 			u64 scale = tsc_pg->tsc_scale;
+ 			s64 offset = tsc_pg->tsc_offset;
+ 
+ 			rdtscll(cur_tsc);
+ 			/* current_tick = ((cur_tsc *scale) >> 64) + offset */
+ 			asm("mulq %3"
+ 				: "=d" (current_tick), "=a" (tmp)
+ 				: "a" (cur_tsc), "r" (scale));
+ 
+ 			current_tick += offset;
+ 			if (tsc_pg->tsc_sequence == sequence)
+ 				return current_tick;
+ 
+ 			if (tsc_pg->tsc_sequence != 0)
+ 				continue;
+ 			/*
+ 			 * Fallback using MSR method.
+ 			 */
+ 			break;
+ 		}
+ 	}
+ 	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+ 	return current_tick;
+ }
+ 
+ static struct clocksource hyperv_cs_tsc = {
+ 		.name		= "hyperv_clocksource_tsc_page",
+ 		.rating		= 400,
+ 		.read		= read_hv_clock_tsc,
+ 		.mask		= CLOCKSOURCE_MASK(64),
+ 		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+ };
+ #endif
+ 
+ static u64 read_hv_clock_msr(struct clocksource *arg)
+ {
+ 	u64 current_tick;
+ 	/*
+ 	 * Read the partition counter to get the current tick count. This count
+ 	 * is set to 0 when the partition is created and is incremented in
+ 	 * 100 nanosecond units.
+ 	 */
+ 	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+ 	return current_tick;
+ }
+ 
+ static struct clocksource hyperv_cs_msr = {
+ 	.name		= "hyperv_clocksource_msr",
+ 	.rating		= 400,
+ 	.read		= read_hv_clock_msr,
+ 	.mask		= CLOCKSOURCE_MASK(64),
+ 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+ };
++>>>>>>> 670718161852 (hyperv: fix warning about missing prototype)
  
  static void *hypercall_pg;
 -struct clocksource *hyperv_cs;
 -EXPORT_SYMBOL_GPL(hyperv_cs);
 -
  /*
   * This function is to be invoked early in the boot sequence after the
   * hypervisor has been detected.
* Unmerged path arch/x86/hyperv/hv_init.c
