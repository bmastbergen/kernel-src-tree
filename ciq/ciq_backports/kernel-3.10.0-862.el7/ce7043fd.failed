target: remove ->fabric_cleanup_nodeacl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] remove ->fabric_cleanup_nodeacl (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 88.57%
commit-author Christoph Hellwig <hch@lst.de>
commit ce7043fd903eb9722a885b98b53fffe2cedfb047
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ce7043fd.failed

Instead we can clean up the list of default ACLs in core code.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit ce7043fd903eb9722a885b98b53fffe2cedfb047)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target_configfs.c
#	drivers/target/target_core_fabric_configfs.c
#	include/target/target_core_fabric.h
diff --cc drivers/target/iscsi/iscsi_target_configfs.c
index 7bdf7a03b311,3c05d1e97f8f..000000000000
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@@ -950,89 -766,19 +950,92 @@@ static struct configfs_attribute *lio_t
  	NULL,
  };
  
 -static int lio_target_init_nodeacl(struct se_node_acl *se_nacl,
 -		const char *name)
 +static struct se_node_acl *lio_tpg_alloc_fabric_acl(
 +	struct se_portal_group *se_tpg)
  {
 -	struct iscsi_node_acl *acl =
 -		container_of(se_nacl, struct iscsi_node_acl, se_node_acl);
 +	struct iscsi_node_acl *acl;
 +
 +	acl = kzalloc(sizeof(struct iscsi_node_acl), GFP_KERNEL);
 +	if (!acl) {
 +		pr_err("Unable to allocate memory for struct iscsi_node_acl\n");
 +		return NULL;
 +	}
 +
 +	return &acl->se_node_acl;
 +}
 +
++<<<<<<< HEAD
 +static struct se_node_acl *lio_target_make_nodeacl(
 +	struct se_portal_group *se_tpg,
 +	struct config_group *group,
 +	const char *name)
 +{
 +	struct config_group *stats_cg;
 +	struct iscsi_node_acl *acl;
 +	struct se_node_acl *se_nacl_new, *se_nacl;
 +	struct iscsi_portal_group *tpg = container_of(se_tpg,
 +			struct iscsi_portal_group, tpg_se_tpg);
 +	u32 cmdsn_depth;
  
 +	se_nacl_new = lio_tpg_alloc_fabric_acl(se_tpg);
 +	if (!se_nacl_new)
 +		return ERR_PTR(-ENOMEM);
 +
 +	cmdsn_depth = tpg->tpg_attrib.default_cmdsn_depth;
 +	/*
 +	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
 +	 * when converting a NdoeACL from demo mode -> explict
 +	 */
 +	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,
 +				name, cmdsn_depth);
 +	if (IS_ERR(se_nacl))
 +		return se_nacl;
 +
 +	acl = container_of(se_nacl, struct iscsi_node_acl, se_node_acl);
 +	stats_cg = &se_nacl->acl_fabric_stat_group;
 +
 +	stats_cg->default_groups = kmalloc(sizeof(struct config_group *) * 2,
 +				GFP_KERNEL);
 +	if (!stats_cg->default_groups) {
 +		pr_err("Unable to allocate memory for"
 +				" stats_cg->default_groups\n");
 +		core_tpg_del_initiator_node_acl(se_tpg, se_nacl, 1);
 +		kfree(acl);
 +		return ERR_PTR(-ENOMEM);
 +	}
 +
 +	stats_cg->default_groups[0] = &acl->node_stat_grps.iscsi_sess_stats_group;
 +	stats_cg->default_groups[1] = NULL;
  	config_group_init_type_name(&acl->node_stat_grps.iscsi_sess_stats_group,
  			"iscsi_sess_stats", &iscsi_stat_sess_cit);
 -	configfs_add_default_group(&acl->node_stat_grps.iscsi_sess_stats_group,
 -			&se_nacl->acl_fabric_stat_group);
 -	return 0;
 +
 +	return se_nacl;
  }
  
 +static void lio_target_drop_nodeacl(
 +	struct se_node_acl *se_nacl)
 +{
 +	struct se_portal_group *se_tpg = se_nacl->se_tpg;
 +	struct iscsi_node_acl *acl = container_of(se_nacl,
 +			struct iscsi_node_acl, se_node_acl);
 +	struct config_item *df_item;
 +	struct config_group *stats_cg;
 +	int i;
 +
 +	stats_cg = &acl->se_node_acl.acl_fabric_stat_group;
 +	for (i = 0; stats_cg->default_groups[i]; i++) {
 +		df_item = &stats_cg->default_groups[i]->cg_item;
 +		stats_cg->default_groups[i] = NULL;
 +		config_item_put(df_item);
 +	}
 +	kfree(stats_cg->default_groups);
 +
 +	core_tpg_del_initiator_node_acl(se_tpg, se_nacl, 1);
 +	kfree(acl);
 +}
 +
++=======
++>>>>>>> ce7043fd903e (target: remove ->fabric_cleanup_nodeacl)
  /* End items for lio_target_acl_cit */
  
  /* Start items for lio_target_tpg_attrib_cit */
@@@ -2067,115 -1620,53 +2070,155 @@@ static void lio_release_cmd(struct se_c
  	iscsit_release_cmd(cmd);
  }
  
++<<<<<<< HEAD
 +/* End functions for target_core_fabric_ops */
++=======
+ const struct target_core_fabric_ops iscsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "iscsi",
+ 	.node_acl_size			= sizeof(struct iscsi_node_acl),
+ 	.get_fabric_name		= iscsi_get_fabric_name,
+ 	.tpg_get_wwn			= lio_tpg_get_endpoint_wwn,
+ 	.tpg_get_tag			= lio_tpg_get_tag,
+ 	.tpg_get_default_depth		= lio_tpg_get_default_depth,
+ 	.tpg_check_demo_mode		= lio_tpg_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= lio_tpg_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 			lio_tpg_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 			lio_tpg_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= &lio_tpg_check_prot_fabric_only,
+ 	.tpg_get_inst_index		= lio_tpg_get_inst_index,
+ 	.check_stop_free		= lio_check_stop_free,
+ 	.release_cmd			= lio_release_cmd,
+ 	.shutdown_session		= lio_tpg_shutdown_session,
+ 	.close_session			= lio_tpg_close_session,
+ 	.sess_get_index			= lio_sess_get_index,
+ 	.sess_get_initiator_sid		= lio_sess_get_initiator_sid,
+ 	.write_pending			= lio_write_pending,
+ 	.write_pending_status		= lio_write_pending_status,
+ 	.set_default_node_attributes	= lio_set_default_node_attributes,
+ 	.get_cmd_state			= iscsi_get_cmd_state,
+ 	.queue_data_in			= lio_queue_data_in,
+ 	.queue_status			= lio_queue_status,
+ 	.queue_tm_rsp			= lio_queue_tm_rsp,
+ 	.aborted_task			= lio_aborted_task,
+ 	.fabric_make_wwn		= lio_target_call_coreaddtiqn,
+ 	.fabric_drop_wwn		= lio_target_call_coredeltiqn,
+ 	.fabric_make_tpg		= lio_target_tiqn_addtpg,
+ 	.fabric_drop_tpg		= lio_target_tiqn_deltpg,
+ 	.fabric_make_np			= lio_target_call_addnptotpg,
+ 	.fabric_drop_np			= lio_target_call_delnpfromtpg,
+ 	.fabric_init_nodeacl		= lio_target_init_nodeacl,
++>>>>>>> ce7043fd903e (target: remove ->fabric_cleanup_nodeacl)
  
 -	.tfc_discovery_attrs		= lio_target_discovery_auth_attrs,
 -	.tfc_wwn_attrs			= lio_target_wwn_attrs,
 -	.tfc_tpg_base_attrs		= lio_target_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= lio_target_tpg_attrib_attrs,
 -	.tfc_tpg_auth_attrs		= lio_target_tpg_auth_attrs,
 -	.tfc_tpg_param_attrs		= lio_target_tpg_param_attrs,
 -	.tfc_tpg_np_base_attrs		= lio_target_portal_attrs,
 -	.tfc_tpg_nacl_base_attrs	= lio_target_initiator_attrs,
 -	.tfc_tpg_nacl_attrib_attrs	= lio_target_nacl_attrib_attrs,
 -	.tfc_tpg_nacl_auth_attrs	= lio_target_nacl_auth_attrs,
 -	.tfc_tpg_nacl_param_attrs	= lio_target_nacl_param_attrs,
 -};
 +int iscsi_target_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	lio_target_fabric_configfs = NULL;
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "iscsi");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() for"
 +				" LIO-Target failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod..
 +	 */
 +	fabric->tf_ops.get_fabric_name = &iscsi_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &iscsi_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &lio_tpg_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &lio_tpg_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &lio_tpg_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &iscsi_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +				&iscsi_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +				&iscsi_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &lio_tpg_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +				&lio_tpg_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +				&lio_tpg_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +				&lio_tpg_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &lio_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl = &lio_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &lio_tpg_get_inst_index;
 +	fabric->tf_ops.check_stop_free = &lio_check_stop_free,
 +	fabric->tf_ops.release_cmd = &lio_release_cmd;
 +	fabric->tf_ops.shutdown_session = &lio_tpg_shutdown_session;
 +	fabric->tf_ops.close_session = &lio_tpg_close_session;
 +	fabric->tf_ops.sess_get_index = &lio_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = &lio_sess_get_initiator_sid;
 +	fabric->tf_ops.write_pending = &lio_write_pending;
 +	fabric->tf_ops.write_pending_status = &lio_write_pending_status;
 +	fabric->tf_ops.set_default_node_attributes =
 +				&lio_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &iscsi_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &iscsi_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &lio_queue_data_in;
 +	fabric->tf_ops.queue_status = &lio_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &lio_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &lio_aborted_task;
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &lio_target_call_coreaddtiqn;
 +	fabric->tf_ops.fabric_drop_wwn = &lio_target_call_coredeltiqn;
 +	fabric->tf_ops.fabric_make_tpg = &lio_target_tiqn_addtpg;
 +	fabric->tf_ops.fabric_drop_tpg = &lio_target_tiqn_deltpg;
 +	fabric->tf_ops.fabric_post_link	= NULL;
 +	fabric->tf_ops.fabric_pre_unlink = NULL;
 +	fabric->tf_ops.fabric_make_np = &lio_target_call_addnptotpg;
 +	fabric->tf_ops.fabric_drop_np = &lio_target_call_delnpfromtpg;
 +	fabric->tf_ops.fabric_make_nodeacl = &lio_target_make_nodeacl;
 +	fabric->tf_ops.fabric_drop_nodeacl = &lio_target_drop_nodeacl;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 * sturct config_item_type's
 +	 */
 +	fabric->tf_cit_tmpl.tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_auth_cit.ct_attrs = lio_target_tpg_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
 +
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" LIO-Target failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return ret;
 +	}
 +
 +	lio_target_fabric_configfs = fabric;
 +	pr_debug("LIO_TARGET[0] - Set fabric ->"
 +			" lio_target_fabric_configfs\n");
 +	return 0;
 +}
 +
 +
 +void iscsi_target_deregister_configfs(void)
 +{
 +	if (!lio_target_fabric_configfs)
 +		return;
 +	/*
 +	 * Shutdown discovery sessions and disable discovery TPG
 +	 */
 +	if (iscsit_global->discovery_tpg)
 +		iscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);
 +
 +	target_fabric_configfs_deregister(lio_target_fabric_configfs);
 +	lio_target_fabric_configfs = NULL;
 +	pr_debug("LIO_TARGET[0] - Cleared"
 +				" lio_target_fabric_configfs\n");
 +}
diff --cc drivers/target/target_core_fabric_configfs.c
index 0c3f90130b7d,096790ad6e50..000000000000
--- a/drivers/target/target_core_fabric_configfs.c
+++ b/drivers/target/target_core_fabric_configfs.c
@@@ -444,10 -338,9 +444,16 @@@ static void target_fabric_nacl_base_rel
  {
  	struct se_node_acl *se_nacl = container_of(to_config_group(item),
  			struct se_node_acl, acl_group);
++<<<<<<< HEAD
 +	struct se_portal_group *se_tpg = se_nacl->se_tpg;
 +	struct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;
 +
 +	tf->tf_ops.fabric_drop_nodeacl(se_nacl);
++=======
+ 
+ 	configfs_remove_default_groups(&se_nacl->acl_fabric_stat_group);
+ 	core_tpg_del_initiator_node_acl(se_nacl);
++>>>>>>> ce7043fd903e (target: remove ->fabric_cleanup_nodeacl)
  }
  
  static struct configfs_item_operations target_fabric_nacl_base_item_ops = {
diff --cc include/target/target_core_fabric.h
index 990942f22016,5a9dd1892b70..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -87,11 -86,33 +87,27 @@@ struct target_core_fabric_ops 
  	struct se_tpg_np *(*fabric_make_np)(struct se_portal_group *,
  				struct config_group *, const char *);
  	void (*fabric_drop_np)(struct se_tpg_np *);
++<<<<<<< HEAD
 +	struct se_node_acl *(*fabric_make_nodeacl)(struct se_portal_group *,
 +				struct config_group *, const char *);
 +	void (*fabric_drop_nodeacl)(struct se_node_acl *);
++=======
+ 	int (*fabric_init_nodeacl)(struct se_node_acl *, const char *);
+ 
+ 	struct configfs_attribute **tfc_discovery_attrs;
+ 	struct configfs_attribute **tfc_wwn_attrs;
+ 	struct configfs_attribute **tfc_tpg_base_attrs;
+ 	struct configfs_attribute **tfc_tpg_np_base_attrs;
+ 	struct configfs_attribute **tfc_tpg_attrib_attrs;
+ 	struct configfs_attribute **tfc_tpg_auth_attrs;
+ 	struct configfs_attribute **tfc_tpg_param_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_base_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_attrib_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_auth_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_param_attrs;
++>>>>>>> ce7043fd903e (target: remove ->fabric_cleanup_nodeacl)
  };
  
 -int target_register_template(const struct target_core_fabric_ops *fo);
 -void target_unregister_template(const struct target_core_fabric_ops *fo);
 -
 -int target_depend_item(struct config_item *item);
 -void target_undepend_item(struct config_item *item);
 -
 -struct se_session *target_alloc_session(struct se_portal_group *,
 -		unsigned int, unsigned int, enum target_prot_op prot_op,
 -		const char *, void *,
 -		int (*callback)(struct se_portal_group *,
 -				struct se_session *, void *));
 -
  struct se_session *transport_init_session(enum target_prot_op);
  int transport_alloc_session_tags(struct se_session *, unsigned int,
  		unsigned int);
* Unmerged path drivers/target/iscsi/iscsi_target_configfs.c
* Unmerged path drivers/target/target_core_fabric_configfs.c
* Unmerged path include/target/target_core_fabric.h
