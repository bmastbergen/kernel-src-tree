blk-cgroup: ensure that we clear the stop bit on quiesced queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jens Axboe <axboe@fb.com>
commit 4d199c6f1c847151ea393d5b9946a17cc57cdf6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4d199c6f.failed

If we call blk_mq_quiesce_queue() on a queue, we must remember to
pair that with something that clears the stopped by on the
queues later on.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 4d199c6f1c847151ea393d5b9946a17cc57cdf6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-cgroup.c
diff --cc block/blk-cgroup.c
index 61f595f4525f,efb97ec37eee..000000000000
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@@ -1023,12 -1262,16 +1023,23 @@@ int blkcg_activate_policy(struct reques
  
  	__set_bit(pol->plid, q->blkcg_pols);
  	ret = 0;
 -
 +out_unlock:
  	spin_unlock_irq(q->queue_lock);
++<<<<<<< HEAD
 +out_free:
 +	blk_queue_bypass_end(q);
 +	list_for_each_entry_safe(pd, n, &pds, alloc_node)
 +		kfree(pd);
++=======
+ out_bypass_end:
+ 	if (q->mq_ops) {
+ 		blk_mq_unfreeze_queue(q);
+ 		blk_mq_start_stopped_hw_queues(q, true);
+ 	} else
+ 		blk_queue_bypass_end(q);
+ 	if (pd_prealloc)
+ 		pol->pd_free_fn(pd_prealloc);
++>>>>>>> 4d199c6f1c84 (blk-cgroup: ensure that we clear the stop bit on quiesced queues)
  	return ret;
  }
  EXPORT_SYMBOL_GPL(blkcg_activate_policy);
@@@ -1074,7 -1317,12 +1085,16 @@@ void blkcg_deactivate_policy(struct req
  	}
  
  	spin_unlock_irq(q->queue_lock);
++<<<<<<< HEAD
 +	blk_queue_bypass_end(q);
++=======
+ 
+ 	if (q->mq_ops) {
+ 		blk_mq_unfreeze_queue(q);
+ 		blk_mq_start_stopped_hw_queues(q, true);
+ 	} else
+ 		blk_queue_bypass_end(q);
++>>>>>>> 4d199c6f1c84 (blk-cgroup: ensure that we clear the stop bit on quiesced queues)
  }
  EXPORT_SYMBOL_GPL(blkcg_deactivate_policy);
  
* Unmerged path block/blk-cgroup.c
