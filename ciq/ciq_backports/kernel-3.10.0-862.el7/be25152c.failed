qla2xxx: Improve T10-DIF/PI handling in driver.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Improve T10-DIF/PI handling in driver (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 98.92%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit be25152c0d9e236076323abbe9def9714234b761
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/be25152c.failed

Add routines to support T10 DIF tag.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Anil Gurumurthy <anil.gurumurthy@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit be25152c0d9e236076323abbe9def9714234b761)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.h
index ec0c6e8c1fbf,c6bffe929fe7..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.h
+++ b/drivers/scsi/qla2xxx/qla_dbg.h
@@@ -348,6 -348,8 +348,11 @@@ ql_log_pci(uint32_t, struct pci_dev *pd
  #define ql_dbg_tgt	0x00004000 /* Target mode */
  #define ql_dbg_tgt_mgt	0x00002000 /* Target mode management */
  #define ql_dbg_tgt_tmr	0x00001000 /* Target mode task management */
++<<<<<<< HEAD
++=======
+ #define ql_dbg_tgt_dif  0x00000800 /* Target mode dif */
+ 
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  extern int qla27xx_dump_mpi_ram(struct qla_hw_data *, uint32_t, uint32_t *,
  	uint32_t, void **);
  extern int qla24xx_dump_ram(struct qla_hw_data *, uint32_t, uint32_t *,
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index c4f068539cd6,ca6f122e5865..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -232,7 -255,12 +232,16 @@@ extern unsigned long qla2x00_get_async_
  
  extern void *qla2x00_alloc_iocbs(scsi_qla_host_t *, srb_t *);
  extern int qla2x00_issue_marker(scsi_qla_host_t *, int);
- 
++<<<<<<< HEAD
++
++=======
+ extern int qla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *, srb_t *,
+ 	uint32_t *, uint16_t, struct qla_tc_param *);
+ extern int qla24xx_walk_and_build_sglist(struct qla_hw_data *, srb_t *,
+ 	uint32_t *, uint16_t, struct qla_tc_param *);
+ extern int qla24xx_walk_and_build_prot_sglist(struct qla_hw_data *, srb_t *,
+ 	uint32_t *, uint16_t, struct qla_tc_param *);
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  extern int qla24xx_get_one_block_sg(uint32_t, struct qla2_sgx *, uint32_t *);
  extern int qla24xx_configure_prot_mode(srb_t *, uint16_t *);
  extern int qla24xx_build_scsi_crc_2_iocbs(srb_t *,
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 2aea13d9d71e,ea027f6a7fd4..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -888,9 -887,9 +888,13 @@@ qla24xx_get_one_block_sg(uint32_t blk_s
  	return 1;
  }
  
 -int
 +static int
  qla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *ha, srb_t *sp,
++<<<<<<< HEAD
 +	uint32_t *dsd, uint16_t tot_dsds)
++=======
+ 	uint32_t *dsd, uint16_t tot_dsds, struct qla_tc_param *tc)
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  {
  	void *next_dsd;
  	uint8_t avail_dsds = 0;
@@@ -899,8 -898,7 +903,12 @@@
  	struct scatterlist *sg_prot;
  	uint32_t *cur_dsd = dsd;
  	uint16_t	used_dsds = tot_dsds;
++<<<<<<< HEAD
 +
 +	uint32_t	prot_int;
++=======
+ 	uint32_t	prot_int; /* protection interval */
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  	uint32_t	partial;
  	struct qla2_sgx sgx;
  	dma_addr_t	sle_dma;
@@@ -947,10 -956,18 +955,24 @@@ alloc_and_fill
  				return 1;
  			}
  
++<<<<<<< HEAD
 +			list_add_tail(&dsd_ptr->list,
 +			    &((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
++=======
+ 			if (sp) {
+ 				list_add_tail(&dsd_ptr->list,
+ 				    &((struct crc_context *)
+ 					    sp->u.scmd.ctx)->dsd_list);
+ 
+ 				sp->flags |= SRB_CRC_CTX_DSD_VALID;
+ 			} else {
+ 				list_add_tail(&dsd_ptr->list,
+ 				    &(tc->ctx->dsd_list));
+ 				*tc->ctx_dsd_alloced = 1;
+ 			}
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  
 +			sp->flags |= SRB_CRC_CTX_DSD_VALID;
  
  			/* add new list to cmd iocb or last list */
  			*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));
@@@ -985,9 -1002,9 +1007,13 @@@
  	return 0;
  }
  
 -int
 +static int
  qla24xx_walk_and_build_sglist(struct qla_hw_data *ha, srb_t *sp, uint32_t *dsd,
++<<<<<<< HEAD
 +	uint16_t tot_dsds)
++=======
+ 	uint16_t tot_dsds, struct qla_tc_param *tc)
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  {
  	void *next_dsd;
  	uint8_t avail_dsds = 0;
@@@ -1028,10 -1056,17 +1054,19 @@@
  				return 1;
  			}
  
 -			if (sp) {
 -				list_add_tail(&dsd_ptr->list,
 -				    &((struct crc_context *)
 -					    sp->u.scmd.ctx)->dsd_list);
 +			list_add_tail(&dsd_ptr->list,
 +			    &((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
  
++<<<<<<< HEAD
 +			sp->flags |= SRB_CRC_CTX_DSD_VALID;
++=======
+ 				sp->flags |= SRB_CRC_CTX_DSD_VALID;
+ 			} else {
+ 				list_add_tail(&dsd_ptr->list,
+ 				    &(tc->ctx->dsd_list));
+ 				*tc->ctx_dsd_alloced = 1;
+ 			}
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  
  			/* add new list to cmd iocb or last list */
  			*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));
@@@ -1054,10 -1089,9 +1089,14 @@@
  	return 0;
  }
  
 -int
 +static int
  qla24xx_walk_and_build_prot_sglist(struct qla_hw_data *ha, srb_t *sp,
++<<<<<<< HEAD
 +							uint32_t *dsd,
 +	uint16_t tot_dsds)
++=======
+ 	uint32_t *dsd, uint16_t tot_dsds, struct qla_tc_param *tc)
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  {
  	void *next_dsd;
  	uint8_t avail_dsds = 0;
@@@ -1099,10 -1148,17 +1138,19 @@@
  				return 1;
  			}
  
 -			if (sp) {
 -				list_add_tail(&dsd_ptr->list,
 -				    &((struct crc_context *)
 -					    sp->u.scmd.ctx)->dsd_list);
 +			list_add_tail(&dsd_ptr->list,
 +			    &((struct crc_context *)sp->u.scmd.ctx)->dsd_list);
  
++<<<<<<< HEAD
 +			sp->flags |= SRB_CRC_CTX_DSD_VALID;
++=======
+ 				sp->flags |= SRB_CRC_CTX_DSD_VALID;
+ 			} else {
+ 				list_add_tail(&dsd_ptr->list,
+ 				    &(tc->ctx->dsd_list));
+ 				*tc->ctx_dsd_alloced = 1;
+ 			}
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  
  			/* add new list to cmd iocb or last list */
  			*cur_dsd++ = cpu_to_le32(LSD(dsd_ptr->dsd_list_dma));
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,532004981dbd..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -111,19 -143,28 +111,39 @@@ static struct workqueue_struct *qla_tgt
  static DEFINE_MUTEX(qla_tgt_mutex);
  static LIST_HEAD(qla_tgt_glist);
  
++<<<<<<< HEAD
 +/* ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list) */
 +static struct qla_tgt_sess *qlt_find_sess_by_port_name(
 +	struct qla_tgt *tgt,
 +	const uint8_t *port_name)
++=======
+ static const char *prot_op_str(u32 prot_op)
+ {
+ 	switch (prot_op) {
+ 	case TARGET_PROT_NORMAL:	return "NORMAL";
+ 	case TARGET_PROT_DIN_INSERT:	return "DIN_INSERT";
+ 	case TARGET_PROT_DOUT_INSERT:	return "DOUT_INSERT";
+ 	case TARGET_PROT_DIN_STRIP:	return "DIN_STRIP";
+ 	case TARGET_PROT_DOUT_STRIP:	return "DOUT_STRIP";
+ 	case TARGET_PROT_DIN_PASS:	return "DIN_PASS";
+ 	case TARGET_PROT_DOUT_PASS:	return "DOUT_PASS";
+ 	default:			return "UNKNOWN";
+ 	}
+ }
+ 
+ /* This API intentionally takes dest as a parameter, rather than returning
+  * int value to avoid caller forgetting to issue wmb() after the store */
+ void qlt_do_generation_tick(struct scsi_qla_host *vha, int *dest)
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  {
 -	scsi_qla_host_t *base_vha = pci_get_drvdata(vha->hw->pdev);
 -	*dest = atomic_inc_return(&base_vha->generation_tick);
 -	/* memory barrier */
 -	wmb();
 +	struct qla_tgt_sess *sess;
 +
 +	list_for_each_entry(sess, &tgt->sess_list, sess_list_entry) {
 +		if (!memcmp(sess->port_name, port_name, WWN_SIZE))
 +			return sess;
 +	}
 +
 +	return NULL;
  }
  
  /* Might release hw lock, then reaquire!! */
@@@ -2011,6 -2659,348 +2130,351 @@@ skip_explict_conf
  	/* Sense with len > 24, is it possible ??? */
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ qlt_hba_err_chk_enabled(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 		if (ql2xenablehba_err_chk >= 1)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DOUT_PASS:
+ 	case TARGET_PROT_DIN_PASS:
+ 		if (ql2xenablehba_err_chk >= 2)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		return 1;
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static inline int
+ qla_tgt_ref_mask_check(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 	    return 1;
+ 	default:
+ 	    return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * qla_tgt_set_dif_tags - Extract Ref and App tags from SCSI command
+  */
+ static void
+ qla_tgt_set_dif_tags(struct qla_tgt_cmd *cmd, struct crc_context *ctx,
+     uint16_t *pfw_prot_opts)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	uint32_t lba = 0xffffffff & se_cmd->t_task_lba;
+ 	scsi_qla_host_t *vha = cmd->tgt->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t t32 = 0;
+ 
+ 	/*
+ 	 * wait till Mode Sense/Select cmd, modepage Ah, subpage 2
+ 	 * have been immplemented by TCM, before AppTag is avail.
+ 	 * Look for modesense_handlers[]
+ 	 */
+ 	ctx->app_tag = 0;
+ 	ctx->app_tag_mask[0] = 0x0;
+ 	ctx->app_tag_mask[1] = 0x0;
+ 
+ 	if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	t32 = ha->tgt.tgt_ops->get_dif_tags(cmd, pfw_prot_opts);
+ 
+ 	switch (se_cmd->prot_type) {
+ 	case TARGET_DIF_TYPE0_PROT:
+ 		/*
+ 		 * No check for ql2xenablehba_err_chk, as it
+ 		 * would be an I/O error if hba tag generation
+ 		 * is not done.
+ 		 */
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 	case TARGET_DIF_TYPE1_PROT:
+ 	    /*
+ 	     * For TYPE 1 protection: 16 bit GUARD tag, 32 bit
+ 	     * REF tag, and 16 bit app tag.
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE2_PROT:
+ 	    /*
+ 	     * For TYPE 2 protection: 16 bit GUARD + 32 bit REF
+ 	     * tag has to match LBA in CDB + N
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE3_PROT:
+ 	    /* For TYPE 3 protection: 16 bit GUARD only */
+ 	    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 	    ctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =
+ 		ctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;
+ 	    break;
+ 	}
+ }
+ 
+ static inline int
+ qlt_build_ctio_crc2_pkt(struct qla_tgt_prm *prm, scsi_qla_host_t *vha)
+ {
+ 	uint32_t		*cur_dsd;
+ 	uint32_t		transfer_length = 0;
+ 	uint32_t		data_bytes;
+ 	uint32_t		dif_bytes;
+ 	uint8_t			bundling = 1;
+ 	uint8_t			*clr_ptr;
+ 	struct crc_context	*crc_ctx_pkt = NULL;
+ 	struct qla_hw_data	*ha;
+ 	struct ctio_crc2_to_fw	*pkt;
+ 	dma_addr_t		crc_ctx_dma;
+ 	uint16_t		fw_prot_opts = 0;
+ 	struct qla_tgt_cmd	*cmd = prm->cmd;
+ 	struct se_cmd		*se_cmd = &cmd->se_cmd;
+ 	uint32_t h;
+ 	struct atio_from_isp *atio = &prm->cmd->atio;
+ 	struct qla_tc_param	tc;
+ 	uint16_t t16;
+ 
+ 	ha = vha->hw;
+ 
+ 	pkt = (struct ctio_crc2_to_fw *)vha->req->ring_ptr;
+ 	prm->pkt = pkt;
+ 	memset(pkt, 0, sizeof(*pkt));
+ 
+ 	ql_dbg(ql_dbg_tgt, vha, 0xe071,
+ 		"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",
+ 		vha->vp_idx, __func__, se_cmd, se_cmd->prot_op,
+ 		prm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);
+ 
+ 	if ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||
+ 	    (se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))
+ 		bundling = 0;
+ 
+ 	/* Compute dif len and adjust data len to incude protection */
+ 	data_bytes = cmd->bufflen;
+ 	dif_bytes  = (data_bytes / cmd->blk_sz) * 8;
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		transfer_length = data_bytes;
+ 		if (cmd->prot_sg_cnt)
+ 			data_bytes += dif_bytes;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		transfer_length = data_bytes + dif_bytes;
+ 		break;
+ 	default:
+ 		BUG();
+ 		break;
+ 	}
+ 
+ 	if (!qlt_hba_err_chk_enabled(se_cmd))
+ 		fw_prot_opts |= 0x10; /* Disable Guard tag checking */
+ 	/* HBA error checking enabled */
+ 	else if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			fw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			fw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 		fw_prot_opts |= PO_MODE_DIF_INSERT;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		fw_prot_opts |= PO_MODE_DIF_REMOVE;
+ 		break;
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		/* FUTURE: does tcm require T10CRC<->IPCKSUM conversion? */
+ 		break;
+ 	default:/* Normal Request */
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		break;
+ 	}
+ 
+ 	/* ---- PKT ---- */
+ 	/* Update entry type to indicate Command Type CRC_2 IOCB */
+ 	pkt->entry_type  = CTIO_CRC2;
+ 	pkt->entry_count = 1;
+ 	pkt->vp_index = vha->vp_idx;
+ 
+ 	h = qlt_make_handle(vha);
+ 	if (unlikely(h == QLA_TGT_NULL_HANDLE)) {
+ 		/*
+ 		 * CTIO type 7 from the firmware doesn't provide a way to
+ 		 * know the initiator's LOOP ID, hence we can't find
+ 		 * the session and, so, the command.
+ 		 */
+ 		return -EAGAIN;
+ 	} else
+ 		ha->tgt.cmds[h-1] = prm->cmd;
+ 
+ 	pkt->handle  = h | CTIO_COMPLETION_HANDLE_MARK;
+ 	pkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);
+ 	pkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
+ 	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
+ 	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
+ 	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
+ 	pkt->exchange_addr   = atio->u.isp24.exchange_addr;
+ 
+ 	/* silence compile warning */
+ 	t16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	pkt->ox_id  = cpu_to_le16(t16);
+ 
+ 	t16 = (atio->u.isp24.attr << 9);
+ 	pkt->flags |= cpu_to_le16(t16);
+ 	pkt->relative_offset = cpu_to_le32(prm->cmd->offset);
+ 
+ 	/* Set transfer direction */
+ 	if (cmd->dma_data_direction == DMA_TO_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_IN);
+ 	else if (cmd->dma_data_direction == DMA_FROM_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_OUT);
+ 
+ 	pkt->dseg_count = prm->tot_dsds;
+ 	/* Fibre channel byte count */
+ 	pkt->transfer_length = cpu_to_le32(transfer_length);
+ 
+ 	/* ----- CRC context -------- */
+ 
+ 	/* Allocate CRC context from global pool */
+ 	crc_ctx_pkt = cmd->ctx =
+ 	    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);
+ 
+ 	if (!crc_ctx_pkt)
+ 		goto crc_queuing_error;
+ 
+ 	/* Zero out CTX area. */
+ 	clr_ptr = (uint8_t *)crc_ctx_pkt;
+ 	memset(clr_ptr, 0, sizeof(*crc_ctx_pkt));
+ 
+ 	crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
+ 	INIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);
+ 
+ 	/* Set handle */
+ 	crc_ctx_pkt->handle = pkt->handle;
+ 
+ 	qla_tgt_set_dif_tags(cmd, crc_ctx_pkt, &fw_prot_opts);
+ 
+ 	pkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));
+ 	pkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));
+ 	pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+ 
+ 	if (!bundling) {
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;
+ 	} else {
+ 		/*
+ 		 * Configure Bundling if we need to fetch interlaving
+ 		 * protection PCI accesses
+ 		 */
+ 		fw_prot_opts |= PO_ENABLE_DIF_BUNDLING;
+ 		crc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);
+ 		crc_ctx_pkt->u.bundling.dseg_count =
+ 			cpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;
+ 	}
+ 
+ 	/* Finish the common fields of CRC pkt */
+ 	crc_ctx_pkt->blk_size   = cpu_to_le16(cmd->blk_sz);
+ 	crc_ctx_pkt->prot_opts  = cpu_to_le16(fw_prot_opts);
+ 	crc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);
+ 	crc_ctx_pkt->guard_seed = cpu_to_le16(0);
+ 
+ 	memset((uint8_t *)&tc, 0 , sizeof(tc));
+ 	tc.vha = vha;
+ 	tc.blk_sz = cmd->blk_sz;
+ 	tc.bufflen = cmd->bufflen;
+ 	tc.sg = cmd->sg;
+ 	tc.prot_sg = cmd->prot_sg;
+ 	tc.ctx = crc_ctx_pkt;
+ 	tc.ctx_dsd_alloced = &cmd->ctx_dsd_alloced;
+ 
+ 	/* Walks data segments */
+ 	pkt->flags |= cpu_to_le16(CTIO7_FLAGS_DSD_PTR);
+ 
+ 	if (!bundling && prm->prot_seg_cnt) {
+ 		if (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,
+ 			prm->tot_dsds, &tc))
+ 			goto crc_queuing_error;
+ 	} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,
+ 		(prm->tot_dsds - prm->prot_seg_cnt), &tc))
+ 		goto crc_queuing_error;
+ 
+ 	if (bundling && prm->prot_seg_cnt) {
+ 		/* Walks dif segments */
+ 		pkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;
+ 
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;
+ 		if (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,
+ 			prm->prot_seg_cnt, &tc))
+ 			goto crc_queuing_error;
+ 	}
+ 	return QLA_SUCCESS;
+ 
+ crc_queuing_error:
+ 	/* Cleanup will be performed by the caller */
+ 	vha->hw->tgt.cmds[h - 1] = NULL;
+ 
+ 	return QLA_FUNCTION_FAILED;
+ }
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  
  /*
   * Callback to setup response of xmit_type of QLA_TGT_XMIT_DATA and *
@@@ -2194,6 -3248,201 +2658,204 @@@ out_unlock_free_unmap
  EXPORT_SYMBOL(qlt_rdy_to_xfer);
  
  
++<<<<<<< HEAD
++=======
+ /*
+  * it is assumed either hardware_lock or qpair lock is held.
+  */
+ static void
+ qlt_handle_dif_error(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd,
+ 	struct ctio_crc_from_fw *sts)
+ {
+ 	uint8_t		*ap = &sts->actual_dif[0];
+ 	uint8_t		*ep = &sts->expected_dif[0];
+ 	uint64_t	lba = cmd->se_cmd.t_task_lba;
+ 	uint8_t scsi_status, sense_key, asc, ascq;
+ 	unsigned long flags;
+ 
+ 	cmd->trc_flags |= TRC_DIF_ERR;
+ 
+ 	cmd->a_guard   = be16_to_cpu(*(uint16_t *)(ap + 0));
+ 	cmd->a_app_tag = be16_to_cpu(*(uint16_t *)(ap + 2));
+ 	cmd->a_ref_tag = be32_to_cpu(*(uint32_t *)(ap + 4));
+ 
+ 	cmd->e_guard   = be16_to_cpu(*(uint16_t *)(ep + 0));
+ 	cmd->e_app_tag = be16_to_cpu(*(uint16_t *)(ep + 2));
+ 	cmd->e_ref_tag = be32_to_cpu(*(uint32_t *)(ep + 4));
+ 
+ 	ql_dbg(ql_dbg_tgt_dif, vha, 0xf075,
+ 	    "%s: aborted %d state %d\n", __func__, cmd->aborted, cmd->state);
+ 
+ 	scsi_status = sense_key = asc = ascq = 0;
+ 
+ 	/* check appl tag */
+ 	if (cmd->e_app_tag != cmd->a_app_tag) {
+ 		ql_dbg(ql_dbg_tgt_dif, vha, 0xffff,
+ 			"App Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] "
+ 			"Ref[%x|%x], App[%x|%x], "
+ 			"Guard [%x|%x] cmd=%p ox_id[%04x]",
+ 			cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
+ 			cmd->a_ref_tag, cmd->e_ref_tag,
+ 			cmd->a_app_tag, cmd->e_app_tag,
+ 			cmd->a_guard, cmd->e_guard,
+ 			cmd, cmd->atio.u.isp24.fcp_hdr.ox_id);
+ 
+ 		cmd->dif_err_code = DIF_ERR_APP;
+ 		scsi_status = SAM_STAT_CHECK_CONDITION;
+ 		sense_key = ABORTED_COMMAND;
+ 		asc = 0x10;
+ 		ascq = 0x2;
+ 	}
+ 
+ 	/* check ref tag */
+ 	if (cmd->e_ref_tag != cmd->a_ref_tag) {
+ 		ql_dbg(ql_dbg_tgt_dif, vha, 0xffff,
+ 			"Ref Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] "
+ 			"Ref[%x|%x], App[%x|%x], "
+ 			"Guard[%x|%x] cmd=%p ox_id[%04x] ",
+ 			cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
+ 			cmd->a_ref_tag, cmd->e_ref_tag,
+ 			cmd->a_app_tag, cmd->e_app_tag,
+ 			cmd->a_guard, cmd->e_guard,
+ 			cmd, cmd->atio.u.isp24.fcp_hdr.ox_id);
+ 
+ 		cmd->dif_err_code = DIF_ERR_REF;
+ 		scsi_status = SAM_STAT_CHECK_CONDITION;
+ 		sense_key = ABORTED_COMMAND;
+ 		asc = 0x10;
+ 		ascq = 0x3;
+ 		goto out;
+ 	}
+ 
+ 	/* check guard */
+ 	if (cmd->e_guard != cmd->a_guard) {
+ 		ql_dbg(ql_dbg_tgt_dif, vha, 0xffff,
+ 			"Guard ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] "
+ 			"Ref[%x|%x], App[%x|%x], "
+ 			"Guard [%x|%x] cmd=%p ox_id[%04x]",
+ 			cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,
+ 			cmd->a_ref_tag, cmd->e_ref_tag,
+ 			cmd->a_app_tag, cmd->e_app_tag,
+ 			cmd->a_guard, cmd->e_guard,
+ 			cmd, cmd->atio.u.isp24.fcp_hdr.ox_id);
+ 		cmd->dif_err_code = DIF_ERR_GRD;
+ 		scsi_status = SAM_STAT_CHECK_CONDITION;
+ 		sense_key = ABORTED_COMMAND;
+ 		asc = 0x10;
+ 		ascq = 0x1;
+ 	}
+ out:
+ 	switch (cmd->state) {
+ 	case QLA_TGT_STATE_NEED_DATA:
+ 		/* handle_data will load DIF error code  */
+ 		cmd->state = QLA_TGT_STATE_DATA_IN;
+ 		vha->hw->tgt.tgt_ops->handle_data(cmd);
+ 		break;
+ 	default:
+ 		spin_lock_irqsave(&cmd->cmd_lock, flags);
+ 		if (cmd->aborted) {
+ 			spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 			vha->hw->tgt.tgt_ops->free_cmd(cmd);
+ 			break;
+ 		}
+ 		spin_unlock_irqrestore(&cmd->cmd_lock, flags);
+ 
+ 		qlt_send_resp_ctio(vha, cmd, scsi_status, sense_key, asc, ascq);
+ 		/* assume scsi status gets out on the wire.
+ 		 * Will not wait for completion.
+ 		 */
+ 		vha->hw->tgt.tgt_ops->free_cmd(cmd);
+ 		break;
+ 	}
+ }
+ 
+ /* If hardware_lock held on entry, might drop it, then reaquire */
+ /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
+ static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *ntfy)
+ {
+ 	struct nack_to_isp *nack;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	request_t *pkt;
+ 	int ret = 0;
+ 
+ 	ql_dbg(ql_dbg_tgt_tmr, vha, 0xe01c,
+ 	    "Sending TERM ELS CTIO (ha=%p)\n", ha);
+ 
+ 	pkt = (request_t *)qla2x00_alloc_iocbs_ready(vha, NULL);
+ 	if (pkt == NULL) {
+ 		ql_dbg(ql_dbg_tgt, vha, 0xe080,
+ 		    "qla_target(%d): %s failed: unable to allocate "
+ 		    "request packet\n", vha->vp_idx, __func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pkt->entry_type = NOTIFY_ACK_TYPE;
+ 	pkt->entry_count = 1;
+ 	pkt->handle = QLA_TGT_SKIP_HANDLE;
+ 
+ 	nack = (struct nack_to_isp *)pkt;
+ 	nack->ox_id = ntfy->ox_id;
+ 
+ 	nack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;
+ 	if (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {
+ 		nack->u.isp24.flags = ntfy->u.isp24.flags &
+ 			__constant_cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);
+ 	}
+ 
+ 	/* terminate */
+ 	nack->u.isp24.flags |=
+ 		__constant_cpu_to_le16(NOTIFY_ACK_FLAGS_TERMINATE);
+ 
+ 	nack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;
+ 	nack->u.isp24.status = ntfy->u.isp24.status;
+ 	nack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;
+ 	nack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;
+ 	nack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;
+ 	nack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;
+ 	nack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;
+ 	nack->u.isp24.vp_index = ntfy->u.isp24.vp_index;
+ 
+ 	qla2x00_start_iocbs(vha, vha->req);
+ 	return ret;
+ }
+ 
+ static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,
+ 	struct imm_ntfy_from_isp *imm, int ha_locked)
+ {
+ 	unsigned long flags = 0;
+ 	int rc;
+ 
+ 	if (qlt_issue_marker(vha, ha_locked) < 0)
+ 		return;
+ 
+ 	if (ha_locked) {
+ 		rc = __qlt_send_term_imm_notif(vha, imm);
+ 
+ #if 0	/* Todo  */
+ 		if (rc == -ENOMEM)
+ 			qlt_alloc_qfull_cmd(vha, imm, 0, 0);
+ #else
+ 		if (rc) {
+ 		}
+ #endif
+ 		goto done;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
+ 	rc = __qlt_send_term_imm_notif(vha, imm);
+ 
+ #if 0	/* Todo */
+ 	if (rc == -ENOMEM)
+ 		qlt_alloc_qfull_cmd(vha, imm, 0, 0);
+ #endif
+ 
+ done:
+ 	if (!ha_locked)
+ 		spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+ }
+ 
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  /* If hardware_lock held on entry, might drop it, then reaquire */
  /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
  static int __qlt_send_term_exchange(struct scsi_qla_host *vha,
@@@ -2518,27 -3860,48 +3190,45 @@@ static void qlt_do_ctio_completion(stru
  
  		case CTIO_PORT_LOGGED_OUT:
  		case CTIO_PORT_UNAVAILABLE:
 -		{
 -			int logged_out =
 -				(status & 0xFFFF) == CTIO_PORT_LOGGED_OUT;
 -
  			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf059,
 -			    "qla_target(%d): CTIO with %s status %x "
 +			    "qla_target(%d): CTIO with PORT LOGGED "
 +			    "OUT (29) or PORT UNAVAILABLE (28) status %x "
  			    "received (state %x, se_cmd %p)\n", vha->vp_idx,
 -			    logged_out ? "PORT LOGGED OUT" : "PORT UNAVAILABLE",
  			    status, cmd->state, se_cmd);
 -
 -			if (logged_out && cmd->sess) {
 -				/*
 -				 * Session is already logged out, but we need
 -				 * to notify initiator, who's not aware of this
 -				 */
 -				cmd->sess->logout_on_delete = 0;
 -				cmd->sess->send_els_logo = 1;
 -				ql_dbg(ql_dbg_disc, vha, 0xffff,
 -				    "%s %d %8phC post del sess\n",
 -				    __func__, __LINE__, cmd->sess->port_name);
 -
 -				qlt_schedule_sess_for_deletion_lock(cmd->sess);
 -			}
  			break;
++<<<<<<< HEAD
 +
 +		case CTIO_SRR_RECEIVED:
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05a,
 +			    "qla_target(%d): CTIO with SRR_RECEIVED"
 +			    " status %x received (state %x, se_cmd %p)\n",
 +			    vha->vp_idx, status, cmd->state, se_cmd);
 +			if (qlt_prepare_srr_ctio(vha, cmd, ctio) != 0)
 +				break;
 +			else
 +				return;
 +
++=======
+ 		}
+ 		case CTIO_DIF_ERROR: {
+ 			struct ctio_crc_from_fw *crc =
+ 				(struct ctio_crc_from_fw *)ctio;
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf073,
+ 			    "qla_target(%d): CTIO with DIF_ERROR status %x "
+ 			    "received (state %x, ulp_cmd %p) actual_dif[0x%llx] "
+ 			    "expect_dif[0x%llx]\n",
+ 			    vha->vp_idx, status, cmd->state, se_cmd,
+ 			    *((u64 *)&crc->actual_dif[0]),
+ 			    *((u64 *)&crc->expected_dif[0]));
+ 
+ 			qlt_handle_dif_error(vha, cmd, ctio);
+ 			return;
+ 		}
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  		default:
  			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf05b,
 -			    "qla_target(%d): CTIO with error status 0x%x received (state %x, se_cmd %p\n",
 +			    "qla_target(%d): CTIO with error status "
 +			    "0x%x received (state %x, se_cmd %p\n",
  			    vha->vp_idx, status, cmd->state, se_cmd);
  			break;
  		}
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,c35f889b94a6..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -415,6 -361,31 +415,34 @@@ struct atio_from_isp 
  	} u;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ static inline int fcpcmd_is_corrupted(struct atio *atio)
+ {
+ 	if (atio->entry_type == ATIO_TYPE7 &&
+ 	    (le16_to_cpu(atio->attr_n_length & FCP_CMD_LENGTH_MASK) <
+ 	    FCP_CMD_LENGTH_MIN))
+ 		return 1;
+ 	else
+ 		return 0;
+ }
+ 
+ /* adjust corrupted atio so we won't trip over the same entry again. */
+ static inline void adjust_corrupted_atio(struct atio_from_isp *atio)
+ {
+ 	atio->u.raw.attr_n_length = cpu_to_le16(FCP_CMD_LENGTH_MIN);
+ 	atio->u.isp24.fcp_cmnd.add_cdb_len = 0;
+ }
+ 
+ static inline int get_datalen_for_atio(struct atio_from_isp *atio)
+ {
+ 	int len = atio->u.isp24.fcp_cmnd.add_cdb_len;
+ 
+ 	return (be32_to_cpu(get_unaligned((uint32_t *)
+ 	    &atio->u.isp24.fcp_cmnd.add_cdb[len * 4])));
+ }
+ 
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  #define CTIO_TYPE7 0x12 /* Continue target I/O entry (for 24xx) */
  
  /*
@@@ -641,22 -675,24 +669,34 @@@ struct qla_tgt_func_tmpl 
  	int (*handle_cmd)(struct scsi_qla_host *, struct qla_tgt_cmd *,
  			unsigned char *, uint32_t, int, int, int);
  	void (*handle_data)(struct qla_tgt_cmd *);
++<<<<<<< HEAD
 +	int (*handle_tmr)(struct qla_tgt_mgmt_cmd *, uint32_t, uint8_t,
++=======
+ 	int (*handle_tmr)(struct qla_tgt_mgmt_cmd *, uint32_t, uint16_t,
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  			uint32_t);
  	void (*free_cmd)(struct qla_tgt_cmd *);
  	void (*free_mcmd)(struct qla_tgt_mgmt_cmd *);
 -	void (*free_session)(struct fc_port *);
 +	void (*free_session)(struct qla_tgt_sess *);
  
  	int (*check_initiator_node_acl)(struct scsi_qla_host *, unsigned char *,
 -					struct fc_port *);
 -	void (*update_sess)(struct fc_port *, port_id_t, uint16_t, bool);
 -	struct fc_port *(*find_sess_by_loop_id)(struct scsi_qla_host *,
 +					void *, uint8_t *, uint16_t);
 +	void (*update_sess)(struct qla_tgt_sess *, port_id_t, uint16_t, bool);
 +	struct qla_tgt_sess *(*find_sess_by_loop_id)(struct scsi_qla_host *,
  						const uint16_t);
 -	struct fc_port *(*find_sess_by_s_id)(struct scsi_qla_host *,
 +	struct qla_tgt_sess *(*find_sess_by_s_id)(struct scsi_qla_host *,
  						const uint8_t *);
++<<<<<<< HEAD
 +	void (*clear_nacl_from_fcport_map)(struct qla_tgt_sess *);
 +	void (*put_sess)(struct qla_tgt_sess *);
 +	void (*shutdown_sess)(struct qla_tgt_sess *);
++=======
+ 	void (*clear_nacl_from_fcport_map)(struct fc_port *);
+ 	void (*put_sess)(struct fc_port *);
+ 	void (*shutdown_sess)(struct fc_port *);
+ 	int (*get_dif_tags)(struct qla_tgt_cmd *cmd, uint16_t *pfw_prot_opts);
+ 	int (*chk_dif_tags)(uint32_t tag);
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  };
  
  int qla2x00_wait_for_hba_online(struct scsi_qla_host *);
@@@ -693,6 -729,8 +733,11 @@@
  #define QLA_TGT_ABORT_ALL               0xFFFE
  #define QLA_TGT_NEXUS_LOSS_SESS         0xFFFD
  #define QLA_TGT_NEXUS_LOSS              0xFFFC
++<<<<<<< HEAD
++=======
+ #define QLA_TGT_ABTS			0xFFFB
+ #define QLA_TGT_2G_ABORT_TASK		0xFFFA
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  
  /* Notify Acknowledge flags */
  #define NOTIFY_ACK_RES_COUNT        BIT_8
@@@ -805,27 -824,37 +850,52 @@@ struct qla_tgt 
  	struct list_head tgt_list_entry;
  };
  
 -struct qla_tgt_sess_op {
 +/*
 + * Equivilant to IT Nexus (Initiator-Target)
 + */
 +struct qla_tgt_sess {
 +	uint16_t loop_id;
 +	port_id_t s_id;
 +
++<<<<<<< HEAD
 +	unsigned int conf_compl_supported:1;
 +	unsigned int deleted:1;
 +	unsigned int local:1;
 +
 +	struct se_session *se_sess;
  	struct scsi_qla_host *vha;
 -	uint32_t chip_reset;
 -	struct atio_from_isp atio;
 -	struct work_struct work;
 -	struct list_head cmd_list;
 -	bool aborted;
 -};
 +	struct qla_tgt *tgt;
  
 +	struct list_head sess_list_entry;
 +	unsigned long expires;
 +	struct list_head del_list_entry;
 +
 +	uint8_t port_name[WWN_SIZE];
 +	struct work_struct free_work;
++=======
+ enum trace_flags {
+ 	TRC_NEW_CMD = BIT_0,
+ 	TRC_DO_WORK = BIT_1,
+ 	TRC_DO_WORK_ERR = BIT_2,
+ 	TRC_XFR_RDY = BIT_3,
+ 	TRC_XMIT_DATA = BIT_4,
+ 	TRC_XMIT_STATUS = BIT_5,
+ 	TRC_SRR_RSP =  BIT_6,
+ 	TRC_SRR_XRDY = BIT_7,
+ 	TRC_SRR_TERM = BIT_8,
+ 	TRC_SRR_CTIO = BIT_9,
+ 	TRC_FLUSH = BIT_10,
+ 	TRC_CTIO_ERR = BIT_11,
+ 	TRC_CTIO_DONE = BIT_12,
+ 	TRC_CTIO_ABORTED =  BIT_13,
+ 	TRC_CTIO_STRANGE= BIT_14,
+ 	TRC_CMD_DONE = BIT_15,
+ 	TRC_CMD_CHK_STOP = BIT_16,
+ 	TRC_CMD_FREE = BIT_17,
+ 	TRC_DATA_IN = BIT_18,
+ 	TRC_ABORT = BIT_19,
+ 	TRC_DIF_ERR = BIT_20,
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  };
  
  struct qla_tgt_cmd {
@@@ -841,8 -871,14 +911,18 @@@
  	unsigned int conf_compl_supported:1;
  	unsigned int sg_mapped:1;
  	unsigned int free_sg:1;
 +	unsigned int aborted:1; /* Needed in case of SRR */
  	unsigned int write_data_transferred:1;
++<<<<<<< HEAD
++=======
+ 	unsigned int q_full:1;
+ 	unsigned int term_exchg:1;
+ 	unsigned int cmd_sent_to_fw:1;
+ 	unsigned int cmd_in_wq:1;
+ 	unsigned int aborted:1;
+ 	unsigned int data_work:1;
+ 	unsigned int data_work_free:1;
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  
  	struct scatterlist *sg;	/* cmd data buffer SG vector */
  	int sg_cnt;		/* SG segments count */
@@@ -858,6 -894,30 +938,33 @@@
  	struct list_head cmd_list;
  
  	struct atio_from_isp atio;
++<<<<<<< HEAD
++=======
+ 
+ 	uint8_t ctx_dsd_alloced;
+ 
+ 	/* T10-DIF */
+ #define DIF_ERR_NONE 0
+ #define DIF_ERR_GRD 1
+ #define DIF_ERR_REF 2
+ #define DIF_ERR_APP 3
+ 	int8_t dif_err_code;
+ 	struct scatterlist *prot_sg;
+ 	uint32_t prot_sg_cnt;
+ 	uint32_t blk_sz, num_blks;
+ 	uint8_t scsi_status, sense_key, asc, ascq;
+ 
+ 	struct crc_context *ctx;
+ 	uint8_t		*cdb;
+ 	uint64_t	lba;
+ 	uint16_t	a_guard, e_guard, a_app_tag, e_app_tag;
+ 	uint32_t	a_ref_tag, e_ref_tag;
+ 
+ 	uint64_t jiffies_at_alloc;
+ 	uint64_t jiffies_at_free;
+ 
+ 	enum trace_flags trc_flags;
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  };
  
  struct qla_tgt_sess_work_param {
@@@ -1006,5 -1072,11 +1113,8 @@@ extern void qlt_stop_phase1(struct qla_
  extern void qlt_stop_phase2(struct qla_tgt *);
  extern irqreturn_t qla83xx_msix_atio_q(int, void *);
  extern void qlt_83xx_iospace_config(struct qla_hw_data *);
 -extern int qlt_free_qfull_cmds(struct scsi_qla_host *);
 -extern void qlt_logo_completion_handler(fc_port_t *, int);
 -extern void qlt_do_generation_tick(struct scsi_qla_host *, int *);
  
+ void qlt_send_resp_ctio(scsi_qla_host_t *, struct qla_tgt_cmd *, uint8_t,
+     uint8_t, uint8_t, uint8_t);
+ 
  #endif /* __QLA_TARGET_H */
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 45ec37d3095c,7443e4efa3ae..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -615,8 -531,31 +615,36 @@@ static void tcm_qla2xxx_handle_data_wor
  			return;
  		}
  
++<<<<<<< HEAD
 +		transport_generic_request_failure(&cmd->se_cmd,
 +						  TCM_CHECK_CONDITION_ABORT_CMD);
++=======
+ 		switch (cmd->dif_err_code) {
+ 		case DIF_ERR_GRD:
+ 			cmd->se_cmd.pi_err =
+ 			    TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;
+ 			break;
+ 		case DIF_ERR_REF:
+ 			cmd->se_cmd.pi_err =
+ 			    TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
+ 			break;
+ 		case DIF_ERR_APP:
+ 			cmd->se_cmd.pi_err =
+ 			    TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;
+ 			break;
+ 		case DIF_ERR_NONE:
+ 		default:
+ 			break;
+ 		}
+ 
+ 		if (cmd->se_cmd.pi_err)
+ 			transport_generic_request_failure(&cmd->se_cmd,
+ 				cmd->se_cmd.pi_err);
+ 		else
+ 			transport_generic_request_failure(&cmd->se_cmd,
+ 				TCM_CHECK_CONDITION_ABORT_CMD);
+ 
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  		return;
  	}
  
@@@ -628,8 -567,29 +656,31 @@@
   */
  static void tcm_qla2xxx_handle_data(struct qla_tgt_cmd *cmd)
  {
 -	cmd->trc_flags |= TRC_DATA_IN;
 -	cmd->cmd_in_wq = 1;
  	INIT_WORK(&cmd->work, tcm_qla2xxx_handle_data_work);
++<<<<<<< HEAD
 +	queue_work(tcm_qla2xxx_free_wq, &cmd->work);
++=======
+ 	queue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);
+ }
+ 
+ static int tcm_qla2xxx_chk_dif_tags(uint32_t tag)
+ {
+ 	return 0;
+ }
+ 
+ static int tcm_qla2xxx_dif_tags(struct qla_tgt_cmd *cmd,
+     uint16_t *pfw_prot_opts)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 
+ 	if (!(se_cmd->prot_checks & TARGET_DIF_CHECK_GUARD))
+ 		*pfw_prot_opts |= PO_DISABLE_GUARD_CHECK;
+ 
+ 	if (!(se_cmd->prot_checks & TARGET_DIF_CHECK_APPTAG))
+ 		*pfw_prot_opts |= PO_DIS_APP_TAG_VALD;
+ 
+ 	return 0;
++>>>>>>> be25152c0d9e (qla2xxx: Improve T10-DIF/PI handling in driver.)
  }
  
  /*
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.h
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812..1b986df01aa6 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -2820,6 +2820,16 @@ struct bidi_statistics {
 	unsigned long long transfer_bytes;
 };
 
+struct qla_tc_param {
+	struct scsi_qla_host *vha;
+	uint32_t blk_sz;
+	uint32_t bufflen;
+	struct scatterlist *sg;
+	struct scatterlist *prot_sg;
+	struct crc_context *ctx;
+	uint8_t *ctx_dsd_alloced;
+};
+
 /* Multi queue support */
 #define MBC_INITIALIZE_MULTIQ 0x1f
 #define QLA_QUE_PAGE 0X1000
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
