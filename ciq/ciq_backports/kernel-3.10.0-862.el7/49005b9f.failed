HID: wacom: Refactor button-to-key translation into function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hid] wacom: Refactor button-to-key translation into function (Aristeu Rozanski) [1475409 1462363]
Rebuild_FUZZ: 95.65%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 49005b9fd05249d537363ff86cb41f07f48c847a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/49005b9f.failed

This just centralizes the logic used in both wacom_setup_numbered_buttons
and wacom_report_numbered_buttons so that they don't drift out of sync.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 49005b9fd05249d537363ff86cb41f07f48c847a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index 5629cf3068d2,8071c18bf9c2..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -2774,25 -2786,119 +2786,37 @@@ static void wacom_setup_numbered_button
  {
  	int i;
  
- 	for (i = 0; i < button_count && i < 10; i++)
- 		__set_bit(BTN_0 + i, input_dev->keybit);
- 	for (i = 10; i < button_count && i < 16; i++)
- 		__set_bit(BTN_A + (i-10), input_dev->keybit);
- 	for (i = 16; i < button_count && i < 18; i++)
- 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ 	for (i = 0; i < button_count; i++) {
+ 		int key = wacom_numbered_button_to_key(i);
+ 
+ 		if (key)
+ 			__set_bit(key, input_dev->keybit);
+ 	}
  }
  
 -static void wacom_24hd_update_leds(struct wacom *wacom, int mask, int group)
 -{
 -	struct wacom_led *led;
 -	int i;
 -	bool updated = false;
 -
 -	/*
 -	 * 24HD has LED group 1 to the left and LED group 0 to the right.
 -	 * So group 0 matches the second half of the buttons and thus the mask
 -	 * needs to be shifted.
 -	 */
 -	if (group == 0)
 -		mask >>= 8;
 -
 -	for (i = 0; i < 3; i++) {
 -		led = wacom_led_find(wacom, group, i);
 -		if (!led) {
 -			hid_err(wacom->hdev, "can't find LED %d in group %d\n",
 -				i, group);
 -			continue;
 -		}
 -		if (!updated && mask & BIT(i)) {
 -			led->held = true;
 -			led_trigger_event(&led->trigger, LED_FULL);
 -		} else {
 -			led->held = false;
 -		}
 -	}
 -}
 -
 -static bool wacom_is_led_toggled(struct wacom *wacom, int button_count,
 -				 int mask, int group)
 -{
 -	int button_per_group;
 -
 -	/*
 -	 * 21UX2 has LED group 1 to the left and LED group 0
 -	 * to the right. We need to reverse the group to match this
 -	 * historical behavior.
 -	 */
 -	if (wacom->wacom_wac.features.type == WACOM_21UX2)
 -		group = 1 - group;
 -
 -	button_per_group = button_count/wacom->led.count;
 -
 -	return mask & (1 << (group * button_per_group));
 -}
 -
 -static void wacom_update_led(struct wacom *wacom, int button_count, int mask,
 -			     int group)
 -{
 -	struct wacom_led *led, *next_led;
 -	int cur;
 -	bool pressed;
 -
 -	if (wacom->wacom_wac.features.type == WACOM_24HD)
 -		return wacom_24hd_update_leds(wacom, mask, group);
 -
 -	pressed = wacom_is_led_toggled(wacom, button_count, mask, group);
 -	cur = wacom->led.groups[group].select;
 -
 -	led = wacom_led_find(wacom, group, cur);
 -	if (!led) {
 -		hid_err(wacom->hdev, "can't find current LED %d in group %d\n",
 -			cur, group);
 -		return;
 -	}
 -
 -	if (!pressed) {
 -		led->held = false;
 -		return;
 -	}
 -
 -	if (led->held && pressed)
 -		return;
 -
 -	next_led = wacom_led_next(wacom, led);
 -	if (!next_led) {
 -		hid_err(wacom->hdev, "can't find next LED in group %d\n",
 -			group);
 -		return;
 -	}
 -	if (next_led == led)
 -		return;
 -
 -	next_led->held = true;
 -	led_trigger_event(&next_led->trigger,
 -			  wacom_leds_brightness_get(next_led));
 -}
 -
  static void wacom_report_numbered_buttons(struct input_dev *input_dev,
  				int button_count, int mask)
  {
 -	struct wacom *wacom = input_get_drvdata(input_dev);
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < button_count && i < 10; i++)
 +		input_report_key(input_dev, BTN_0 + i, mask & (1 << i));
 +	for (i = 10; i < button_count && i < 16; i++)
 +		input_report_key(input_dev, BTN_A + (i-10), mask & (1 << i));
 +	for (i = 16; i < button_count && i < 18; i++)
 +		input_report_key(input_dev, BTN_BASE + (i-16), mask & (1 << i));
++=======
+ 	for (i = 0; i < wacom->led.count; i++)
+ 		wacom_update_led(wacom,  button_count, mask, i);
+ 
+ 	for (i = 0; i < button_count; i++) {
+ 		int key = wacom_numbered_button_to_key(i);
+ 
+ 		if (key)
+ 			input_report_key(input_dev, key, mask & (1 << i));
+ 	}
++>>>>>>> 49005b9fd052 (HID: wacom: Refactor button-to-key translation into function)
  }
  
  int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
* Unmerged path drivers/hid/wacom_wac.c
