qla2xxx: Add flags for tracing the target commands.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add flags for tracing the target commands (Himanshu Madhani) [1327621]
Rebuild_FUZZ: 99.01%
commit-author Saurav Kashyap <saurav.kashyap@qlogic.com>
commit e07f8f6547c246936b489772717b05695af53e35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e07f8f65.failed

	Signed-off-by: Saurav Kashyap <saurav.kashyap@qlogic.com>
	Signed-off-by: Giridhar Malavali <giridhar.malavali@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit e07f8f6547c246936b489772717b05695af53e35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 29185d5b36ff,f3287e1bc554..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -2278,13 -2734,78 +2279,39 @@@ done
  	return;
  }
  
 -static void qlt_init_term_exchange(struct scsi_qla_host *vha)
 -{
 -	struct list_head free_list;
 -	struct qla_tgt_cmd *cmd, *tcmd;
 -
 -	vha->hw->tgt.leak_exchg_thresh_hold =
 -	    (vha->hw->fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;
 -
 -	cmd = tcmd = NULL;
 -	if (!list_empty(&vha->hw->tgt.q_full_list)) {
 -		INIT_LIST_HEAD(&free_list);
 -		list_splice_init(&vha->hw->tgt.q_full_list, &free_list);
 -
 -		list_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {
 -			list_del(&cmd->cmd_list);
 -			/* This cmd was never sent to TCM.  There is no need
 -			 * to schedule free or call free_cmd
 -			 */
 -			qlt_free_cmd(cmd);
 -			vha->hw->tgt.num_qfull_cmds_alloc--;
 -		}
 -	}
 -	vha->hw->tgt.num_qfull_cmds_dropped = 0;
 -}
 -
 -static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)
 -{
 -	uint32_t total_leaked;
 -
 -	total_leaked = vha->hw->tgt.num_qfull_cmds_dropped;
 -
 -	if (vha->hw->tgt.leak_exchg_thresh_hold &&
 -	    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {
 -
 -		ql_dbg(ql_dbg_tgt, vha, 0xe079,
 -		    "Chip reset due to exchange starvation: %d/%d.\n",
 -		    total_leaked, vha->hw->fw_xcb_count);
 -
 -		if (IS_P3P_TYPE(vha->hw))
 -			set_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);
 -		else
 -			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
 -		qla2xxx_wake_dpc(vha);
 -	}
 -
 -}
 -
  void qlt_free_cmd(struct qla_tgt_cmd *cmd)
  {
++<<<<<<< HEAD
 +	BUG_ON(cmd->sg_mapped);
 +
 +	if (unlikely(cmd->free_sg))
 +		kfree(cmd->sg);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
++=======
+ 	struct qla_tgt_sess *sess = cmd->sess;
+ 
+ 	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,
+ 	    "%s: se_cmd[%p] ox_id %04x\n",
+ 	    __func__, &cmd->se_cmd,
+ 	    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));
+ 
+ 	BUG_ON(cmd->cmd_in_wq);
+ 
+ 	if (!cmd->q_full)
+ 		qlt_decr_num_pend_cmds(cmd->vha);
+ 
+ 	BUG_ON(cmd->sg_mapped);
+ 	cmd->jiffies_at_free = get_jiffies_64();
+ 	if (unlikely(cmd->free_sg))
+ 		kfree(cmd->sg);
+ 
+ 	if (!sess || !sess->se_sess) {
+ 		WARN_ON(1);
+ 		return;
+ 	}
+ 	cmd->jiffies_at_free = get_jiffies_64();
+ 	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
  }
  EXPORT_SYMBOL(qlt_free_cmd);
  
@@@ -2450,6 -2969,81 +2478,84 @@@ static struct qla_tgt_cmd *qlt_ctio_to_
  	return cmd;
  }
  
++<<<<<<< HEAD
++=======
+ /* hardware_lock should be held by caller. */
+ static void
+ qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t handle;
+ 
+ 	if (cmd->sg_mapped)
+ 		qlt_unmap_sg(vha, cmd);
+ 
+ 	handle = qlt_make_handle(vha);
+ 
+ 	/* TODO: fix debug message type and ids. */
+ 	if (cmd->state == QLA_TGT_STATE_PROCESSED) {
+ 		ql_dbg(ql_dbg_io, vha, 0xff00,
+ 		    "HOST-ABORT: handle=%d, state=PROCESSED.\n", handle);
+ 	} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {
+ 		cmd->write_data_transferred = 0;
+ 		cmd->state = QLA_TGT_STATE_DATA_IN;
+ 
+ 		ql_dbg(ql_dbg_io, vha, 0xff01,
+ 		    "HOST-ABORT: handle=%d, state=DATA_IN.\n", handle);
+ 
+ 		ha->tgt.tgt_ops->handle_data(cmd);
+ 		return;
+ 	} else if (cmd->state == QLA_TGT_STATE_ABORTED) {
+ 		ql_dbg(ql_dbg_io, vha, 0xff02,
+ 		    "HOST-ABORT: handle=%d, state=ABORTED.\n", handle);
+ 	} else {
+ 		ql_dbg(ql_dbg_io, vha, 0xff03,
+ 		    "HOST-ABORT: handle=%d, state=BAD(%d).\n", handle,
+ 		    cmd->state);
+ 		dump_stack();
+ 	}
+ 
+ 	cmd->cmd_flags |= BIT_12;
+ 	ha->tgt.tgt_ops->free_cmd(cmd);
+ }
+ 
+ void
+ qlt_host_reset_handler(struct qla_hw_data *ha)
+ {
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);
+ 	scsi_qla_host_t *vha = NULL;
+ 	struct qla_tgt *tgt = base_vha->vha_tgt.qla_tgt;
+ 	uint32_t i;
+ 
+ 	if (!base_vha->hw->tgt.tgt_ops)
+ 		return;
+ 
+ 	if (!tgt || qla_ini_mode_enabled(base_vha)) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf003,
+ 			"Target mode disabled\n");
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xff10,
+ 	    "HOST-ABORT-HNDLR: base_vha->dpc_flags=%lx.\n",
+ 	    base_vha->dpc_flags);
+ 
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	for (i = 1; i < DEFAULT_OUTSTANDING_COMMANDS + 1; i++) {
+ 		cmd = qlt_get_cmd(base_vha, i);
+ 		if (!cmd)
+ 			continue;
+ 		/* ha->tgt.cmds entry is cleared by qlt_get_cmd. */
+ 		vha = cmd->vha;
+ 		qlt_abort_cmd_on_host_reset(vha, cmd);
+ 	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ }
+ 
+ 
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -2537,7 -3158,8 +2643,12 @@@ static void qlt_do_ctio_completion(stru
  		 * level.
  		 */
  		if ((cmd->state != QLA_TGT_STATE_NEED_DATA) &&
++<<<<<<< HEAD
 +			(cmd->state != QLA_TGT_STATE_ABORTED)) {
++=======
+ 		    (cmd->state != QLA_TGT_STATE_ABORTED)) {
+ 			cmd->cmd_flags |= BIT_13;
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
  			if (qlt_term_ctio_exchange(vha, ctio, cmd, status))
  				return;
  		}
@@@ -2621,43 -3248,10 +2732,45 @@@ static void qlt_do_work(struct work_str
  	uint32_t data_length;
  	int ret, fcp_task_attr, data_dir, bidi = 0;
  
 -	cmd->cmd_in_wq = 0;
 -	cmd->cmd_flags |= BIT_1;
 -	if (tgt->tgt_stop)
 -		goto out_term;
++	cmd->cmd_in_wq = 0;
++	cmd->cmd_flags |= BIT_1;
 +	if (tgt->tgt_stop)
 +		goto out_term;
 +
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
 +	    atio->u.isp24.fcp_hdr.s_id);
 +	/* Do kref_get() before dropping qla_hw_data->hardware_lock. */
 +	if (sess)
 +		kref_get(&sess->se_sess->sess_kref);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +
 +	if (unlikely(!sess)) {
 +		uint8_t *s_id =	atio->u.isp24.fcp_hdr.s_id;
 +
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
 +			"qla_target(%d): Unable to find wwn login"
 +			" (s_id %x:%x:%x), trying to create it manually\n",
 +			vha->vp_idx, s_id[0], s_id[1], s_id[2]);
 +
 +		if (atio->u.raw.entry_count > 1) {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
 +				"Dropping multy entry cmd %p\n", cmd);
 +			goto out_term;
 +		}
 +
 +		mutex_lock(&ha->tgt.tgt_mutex);
 +		sess = qlt_make_local_sess(vha, s_id);
 +		/* sess has an extra creation ref. */
 +		mutex_unlock(&ha->tgt.tgt_mutex);
 +
 +		if (!sess)
 +			goto out_term;
 +	}
 +
 +	cmd->sess = sess;
 +	cmd->loop_id = sess->loop_id;
 +	cmd->conf_compl_supported = sess->conf_compl_supported;
  
  	cdb = &atio->u.isp24.fcp_cmnd.cdb[0];
  	cmd->tag = atio->u.isp24.exchange_addr;
@@@ -2701,12 -3293,111 +2814,13 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
+ 	cmd->cmd_flags |= BIT_2;
  	spin_lock_irqsave(&ha->hardware_lock, flags);
  	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 -
 -	qlt_decr_num_pend_cmds(vha);
 -	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
 -	ha->tgt.tgt_ops->put_sess(sess);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
  	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -}
 -
 -static void qlt_do_work(struct work_struct *work)
 -{
 -	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
 -
 -	__qlt_do_work(cmd);
 -}
 -
 -static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
 -				       struct qla_tgt_sess *sess,
 -				       struct atio_from_isp *atio)
 -{
 -	struct se_session *se_sess = sess->se_sess;
 -	struct qla_tgt_cmd *cmd;
 -	int tag;
 -
 -	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
 -	if (tag < 0)
 -		return NULL;
 -
 -	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
 -	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
 -
 -	memcpy(&cmd->atio, atio, sizeof(*atio));
 -	cmd->state = QLA_TGT_STATE_NEW;
 -	cmd->tgt = vha->vha_tgt.qla_tgt;
 -	qlt_incr_num_pend_cmds(vha);
 -	cmd->vha = vha;
 -	cmd->se_cmd.map_tag = tag;
 -	cmd->sess = sess;
 -	cmd->loop_id = sess->loop_id;
 -	cmd->conf_compl_supported = sess->conf_compl_supported;
 -
 -	return cmd;
 -}
 -
 -static void qlt_send_busy(struct scsi_qla_host *, struct atio_from_isp *,
 -			  uint16_t);
 -
 -static void qlt_create_sess_from_atio(struct work_struct *work)
 -{
 -	struct qla_tgt_sess_op *op = container_of(work,
 -					struct qla_tgt_sess_op, work);
 -	scsi_qla_host_t *vha = op->vha;
 -	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt_sess *sess;
 -	struct qla_tgt_cmd *cmd;
 -	unsigned long flags;
 -	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
 -
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
 -		"qla_target(%d): Unable to find wwn login"
 -		" (s_id %x:%x:%x), trying to create it manually\n",
 -		vha->vp_idx, s_id[0], s_id[1], s_id[2]);
 -
 -	if (op->atio.u.raw.entry_count > 1) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
 -		        "Dropping multy entry atio %p\n", &op->atio);
 -		goto out_term;
 -	}
 -
 -	mutex_lock(&vha->vha_tgt.tgt_mutex);
 -	sess = qlt_make_local_sess(vha, s_id);
 -	/* sess has an extra creation ref. */
 -	mutex_unlock(&vha->vha_tgt.tgt_mutex);
 -
 -	if (!sess)
 -		goto out_term;
 -	/*
 -	 * Now obtain a pre-allocated session tag using the original op->atio
 -	 * packet header, and dispatch into __qlt_do_work() using the existing
 -	 * process context.
 -	 */
 -	cmd = qlt_get_tag(vha, sess, &op->atio);
 -	if (!cmd) {
 -		spin_lock_irqsave(&ha->hardware_lock, flags);
 -		qlt_send_busy(vha, &op->atio, SAM_STAT_BUSY);
 +	if (sess)
  		ha->tgt.tgt_ops->put_sess(sess);
 -		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -		kfree(op);
 -		return;
 -	}
 -	/*
 -	 * __qlt_do_work() will call ha->tgt.tgt_ops->put_sess() to release
 -	 * the extra reference taken above by qlt_make_local_sess()
 -	 */
 -	__qlt_do_work(cmd);
 -	kfree(op);
 -	return;
 -
 -out_term:
 -	spin_lock_irqsave(&ha->hardware_lock, flags);
 -	qlt_send_term_exchange(vha, NULL, &op->atio, 1);
 -	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 -	kfree(op);
 -
  }
  
  /* ha->hardware_lock supposed to be held on entry */
@@@ -2730,13 -3440,14 +2844,22 @@@ static int qlt_handle_cmd_for_atio(stru
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&cmd->cmd_list);
 +
 +	memcpy(&cmd->atio, atio, sizeof(*atio));
 +	cmd->state = QLA_TGT_STATE_NEW;
 +	cmd->tgt = ha->tgt.qla_tgt;
 +	cmd->vha = vha;
++=======
+ 	cmd->cmd_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
  
+ 	cmd->reset_count = vha->hw->chip_reset;
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
+ 
+ 	cmd->cmd_in_wq = 1;
+ 	cmd->cmd_flags |= BIT_0;
  	INIT_WORK(&cmd->work, qlt_do_work);
  	queue_work(qla_tgt_wq, &cmd->work);
  	return 0;
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,8ff330f7d6f5..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -843,6 -914,11 +843,14 @@@ struct qla_tgt_cmd 
  	unsigned int free_sg:1;
  	unsigned int aborted:1; /* Needed in case of SRR */
  	unsigned int write_data_transferred:1;
++<<<<<<< HEAD
++=======
+ 	unsigned int ctx_dsd_alloced:1;
+ 	unsigned int q_full:1;
+ 	unsigned int term_exchg:1;
+ 	unsigned int cmd_sent_to_fw:1;
+ 	unsigned int cmd_in_wq:1;
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
  
  	struct scatterlist *sg;	/* cmd data buffer SG vector */
  	int sg_cnt;		/* SG segments count */
@@@ -858,6 -935,35 +866,38 @@@
  	struct list_head cmd_list;
  
  	struct atio_from_isp atio;
++<<<<<<< HEAD
++=======
+ 	/* t10dif */
+ 	struct scatterlist *prot_sg;
+ 	uint32_t prot_sg_cnt;
+ 	uint32_t blk_sz;
+ 	struct crc_context *ctx;
+ 
+ 	uint64_t jiffies_at_alloc;
+ 	uint64_t jiffies_at_free;
+ 	/* BIT_0 - Atio Arrival / schedule to work
+ 	 * BIT_1 - qlt_do_work
+ 	 * BIT_2 - qlt_do work failed
+ 	 * BIT_3 - xfer rdy/tcm_qla2xxx_write_pending
+ 	 * BIT_4 - read respond/tcm_qla2xx_queue_data_in
+ 	 * BIT_5 - status respond / tcm_qla2xx_queue_status
+ 	 * BIT_6 - tcm request to abort/Term exchange.
+ 	 *	pre_xmit_response->qlt_send_term_exchange
+ 	 * BIT_7 - SRR received (qlt_handle_srr->qlt_xmit_response)
+ 	 * BIT_8 - SRR received (qlt_handle_srr->qlt_rdy_to_xfer)
+ 	 * BIT_9 - SRR received (qla_handle_srr->qlt_send_term_exchange)
+ 	 * BIT_10 - Data in - hanlde_data->tcm_qla2xxx_handle_data
+ 	 * BIT_11 - Data actually going to TCM : tcm_qla2xx_handle_data_work
+ 	 * BIT_12 - good completion - qlt_ctio_do_completion -->free_cmd
+ 	 * BIT_13 - Bad completion -
+ 	 *	qlt_ctio_do_completion --> qlt_term_ctio_exchange
+ 	 * BIT_14 - Back end data received/sent.
+ 	 * BIT_15 - SRR prepare ctio
+ 	 * BIT_16 - complete free
+ 	 */
+ 	uint32_t cmd_flags;
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
  };
  
  struct qla_tgt_sess_work_param {
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index a8363189ea72,031b2961c6b7..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -422,7 -415,14 +428,18 @@@ static void tcm_qla2xxx_free_cmd(struc
   */
  static int tcm_qla2xxx_check_stop_free(struct se_cmd *se_cmd)
  {
++<<<<<<< HEAD
 +	return target_put_sess_cmd(se_cmd);
++=======
+ 	struct qla_tgt_cmd *cmd;
+ 
+ 	if ((se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) == 0) {
+ 		cmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);
+ 		cmd->cmd_flags |= BIT_14;
+ 	}
+ 
+ 	return target_put_sess_cmd(se_cmd->se_sess, se_cmd);
++>>>>>>> e07f8f6547c2 (qla2xxx: Add flags for tracing the target commands.)
  }
  
  /* tcm_qla2xxx_release_cmd - Callback from TCM Core to release underlying
@@@ -650,14 -659,21 +671,16 @@@ static int tcm_qla2xxx_queue_data_in(st
  	struct qla_tgt_cmd *cmd = container_of(se_cmd,
  				struct qla_tgt_cmd, se_cmd);
  
+ 	cmd->cmd_flags |= BIT_4;
  	cmd->bufflen = se_cmd->data_length;
 -	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
 +	cmd->dma_data_direction = tcm_qla2xxx_mapping_dir(se_cmd);
  	cmd->aborted = (se_cmd->transport_state & CMD_T_ABORTED);
  
  	cmd->sg_cnt = se_cmd->t_data_nents;
  	cmd->sg = se_cmd->t_data_sg;
  	cmd->offset = 0;
+ 	cmd->cmd_flags |= BIT_3;
  
 -	cmd->prot_sg_cnt = se_cmd->t_prot_nents;
 -	cmd->prot_sg = se_cmd->t_prot_sg;
 -	cmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;
 -	se_cmd->pi_err = 0;
 -
  	/*
  	 * Now queue completed DATA_IN the qla2xxx LLD and response ring
  	 */
@@@ -675,8 -691,13 +698,13 @@@ static int tcm_qla2xxx_queue_status(str
  	cmd->sg = NULL;
  	cmd->sg_cnt = 0;
  	cmd->offset = 0;
 -	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
 +	cmd->dma_data_direction = tcm_qla2xxx_mapping_dir(se_cmd);
  	cmd->aborted = (se_cmd->transport_state & CMD_T_ABORTED);
+ 	if (cmd->cmd_flags &  BIT_5) {
+ 		pr_crit("Bit_5 already set for cmd = %p.\n", cmd);
+ 		dump_stack();
+ 	}
+ 	cmd->cmd_flags |= BIT_5;
  
  	if (se_cmd->data_direction == DMA_FROM_DEVICE) {
  		/*
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
