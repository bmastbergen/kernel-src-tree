x86/intel_rdt: Separate the ctrl bits from rmdir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt: Separate the ctrl bits from rmdir (Jiri Olsa) [1457533]
Rebuild_FUZZ: 95.65%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit f9049547f7e72377049d717354b2f56f36a5854a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f9049547.failed

Re-factor the code to separate the ctrl group removal from the rmdir to
prepare to add RDT monitoring group removal.

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: peterz@infradead.org
	Cc: eranian@google.com
	Cc: vikas.shivappa@intel.com
	Cc: ak@linux.intel.com
	Cc: davidcc@google.com
	Cc: reinette.chatre@intel.com
Link: http://lkml.kernel.org/r/1501017287-28083-21-git-send-email-vikas.shivappa@linux.intel.com

(cherry picked from commit f9049547f7e72377049d717354b2f56f36a5854a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 1c3603d97e9d,3b62287a2f01..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -1009,20 -1524,51 +1009,55 @@@ out_unlock
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int rdtgroup_rmdir(struct kernfs_node *kn)
++=======
+ /*
+  * We allow creating mon groups only with in a directory called "mon_groups"
+  * which is present in every ctrl_mon group. Check if this is a valid
+  * "mon_groups" directory.
+  *
+  * 1. The directory should be named "mon_groups".
+  * 2. The mon group itself should "not" be named "mon_groups".
+  *   This makes sure "mon_groups" directory always has a ctrl_mon group
+  *   as parent.
+  */
+ static bool is_mon_groups(struct kernfs_node *kn, const char *name)
  {
- 	int ret, cpu, closid = rdtgroup_default.closid;
- 	struct rdtgroup *rdtgrp;
- 	cpumask_var_t tmpmask;
+ 	return (!strcmp(kn->name, "mon_groups") &&
+ 		strcmp(name, "mon_groups"));
+ }
  
- 	if (!zalloc_cpumask_var(&tmpmask, GFP_KERNEL))
- 		return -ENOMEM;
+ static int rdtgroup_mkdir(struct kernfs_node *parent_kn, const char *name,
+ 			  umode_t mode)
+ {
+ 	/* Do not accept '\n' to avoid unparsable situation. */
+ 	if (strchr(name, '\n'))
+ 		return -EINVAL;
  
- 	rdtgrp = rdtgroup_kn_lock_live(kn);
- 	if (!rdtgrp) {
- 		ret = -EPERM;
- 		goto out;
- 	}
+ 	/*
+ 	 * If the parent directory is the root directory and RDT
+ 	 * allocation is supported, add a control and monitoring
+ 	 * subdirectory
+ 	 */
+ 	if (rdt_alloc_capable && parent_kn == rdtgroup_default.kn)
+ 		return rdtgroup_mkdir_ctrl_mon(parent_kn, parent_kn, name, mode);
+ 
+ 	/*
+ 	 * If RDT monitoring is supported and the parent directory is a valid
+ 	 * "mon_groups" directory, add a monitoring subdirectory.
+ 	 */
+ 	if (rdt_mon_capable && is_mon_groups(parent_kn, name))
+ 		return rdtgroup_mkdir_mon(parent_kn, parent_kn->parent, name, mode);
+ 
+ 	return -EPERM;
+ }
+ 
+ static int rdtgroup_rmdir_ctrl(struct kernfs_node *kn, struct rdtgroup *rdtgrp,
+ 			       cpumask_var_t tmpmask)
++>>>>>>> f9049547f7e7 (x86/intel_rdt: Separate the ctrl bits from rmdir)
+ {
+ 	int cpu;
  
  	/* Give any tasks back to the default group */
  	rdt_move_group_tasks(rdtgrp, &rdtgroup_default, tmpmask);
@@@ -1033,7 -1579,7 +1068,11 @@@
  
  	/* Update per cpu closid of the moved CPUs first */
  	for_each_cpu(cpu, &rdtgrp->cpu_mask)
++<<<<<<< HEAD
 +		per_cpu(cpu_closid, cpu) = closid;
++=======
+ 		per_cpu(rdt_cpu_default.closid, cpu) = rdtgroup_default.closid;
++>>>>>>> f9049547f7e7 (x86/intel_rdt: Separate the ctrl bits from rmdir)
  	/*
  	 * Update the MSR on moved CPUs and CPUs which have moved
  	 * task running on them.
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
