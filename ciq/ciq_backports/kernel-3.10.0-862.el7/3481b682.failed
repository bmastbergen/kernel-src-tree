xfs: move (and rename) the deferred bmap-free tracepoints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 3481b68285238054be519ad0c8cad5cc2425e26c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3481b682.failed

Rename the deferred bmap-free to extent_free and make them only
trigger when we're really running deferred ops.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 3481b68285238054be519ad0c8cad5cc2425e26c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/xfs_trans_extfree.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 38fe0753ea05,776ae2f325d1..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -2702,6 -2819,11 +2702,14 @@@ xfs_free_extent
  
  	ASSERT(len != 0);
  
++<<<<<<< HEAD
++=======
+ 	if (XFS_TEST_ERROR(false, mp,
+ 			XFS_ERRTAG_FREE_EXTENT,
+ 			XFS_RANDOM_FREE_EXTENT))
+ 		return -EIO;
+ 
++>>>>>>> 3481b6828523 (xfs: move (and rename) the deferred bmap-free tracepoints)
  	error = xfs_free_extent_fix_freelist(tp, agno, &agbp);
  	if (error)
  		return error;
diff --cc fs/xfs/xfs_trans_extfree.c
index a9f34ee52ab4,459ddec137a4..000000000000
--- a/fs/xfs/xfs_trans_extfree.c
+++ b/fs/xfs/xfs_trans_extfree.c
@@@ -28,62 -29,8 +29,63 @@@
  #include "xfs_extfree_item.h"
  #include "xfs_alloc.h"
  #include "xfs_bmap.h"
+ #include "xfs_trace.h"
  
 +/*
 + * This routine is called to allocate an "extent free intention"
 + * log item that will hold nextents worth of extents.  The
 + * caller must use all nextents extents, because we are not
 + * flexible about this at all.
 + */
 +struct xfs_efi_log_item *
 +xfs_trans_get_efi(struct xfs_trans	*tp,
 +		  uint			nextents)
 +{
 +	struct xfs_efi_log_item		*efip;
 +
 +	ASSERT(tp != NULL);
 +	ASSERT(nextents > 0);
 +
 +	efip = xfs_efi_init(tp->t_mountp, nextents);
 +	ASSERT(efip != NULL);
 +
 +	/*
 +	 * Get a log_item_desc to point at the new item.
 +	 */
 +	xfs_trans_add_item(tp, &efip->efi_item);
 +	return efip;
 +}
 +
 +/*
 + * This routine is called to indicate that the described
 + * extent is to be logged as needing to be freed.  It should
 + * be called once for each extent to be freed.
 + */
 +void
 +xfs_trans_log_efi_extent(struct xfs_trans		*tp,
 +			 struct xfs_efi_log_item	*efip,
 +			 xfs_fsblock_t			start_block,
 +			 xfs_extlen_t			ext_len)
 +{
 +	uint						next_extent;
 +	struct xfs_extent				*extp;
 +
 +	tp->t_flags |= XFS_TRANS_DIRTY;
 +	efip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;
 +
 +	/*
 +	 * atomic_inc_return gives us the value after the increment;
 +	 * we want to use it as an array index so we need to subtract 1 from
 +	 * it.
 +	 */
 +	next_extent = atomic_inc_return(&efip->efi_next_extent) - 1;
 +	ASSERT(next_extent < efip->efi_format.efi_nextents);
 +	extp = &(efip->efi_format.efi_extents[next_extent]);
 +	extp->ext_start = start_block;
 +	extp->ext_len = ext_len;
 +}
 +
 +
  /*
   * This routine is called to allocate an "extent free done"
   * log item that will hold nextents worth of extents.  The
@@@ -120,13 -67,19 +122,22 @@@ xfs_trans_free_extent
  	struct xfs_trans	*tp,
  	struct xfs_efd_log_item	*efdp,
  	xfs_fsblock_t		start_block,
 -	xfs_extlen_t		ext_len,
 -	struct xfs_owner_info	*oinfo)
 +	xfs_extlen_t		ext_len)
  {
+ 	struct xfs_mount	*mp = tp->t_mountp;
  	uint			next_extent;
+ 	xfs_agnumber_t		agno = XFS_FSB_TO_AGNO(mp, start_block);
+ 	xfs_agblock_t		agbno = XFS_FSB_TO_AGBNO(mp, start_block);
  	struct xfs_extent	*extp;
  	int			error;
  
++<<<<<<< HEAD
 +	error = xfs_free_extent(tp, start_block, ext_len);
++=======
+ 	trace_xfs_bmap_free_deferred(tp->t_mountp, agno, 0, agbno, ext_len);
+ 
+ 	error = xfs_free_extent(tp, start_block, ext_len, oinfo);
++>>>>>>> 3481b6828523 (xfs: move (and rename) the deferred bmap-free tracepoints)
  
  	/*
  	 * Mark the transaction dirty, even on error. This ensures the
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/xfs_trans_extfree.c
