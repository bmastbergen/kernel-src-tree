KEYS: trusted: fix writing past end of buffer in trusted_read()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Biggers <ebiggers@google.com>
commit a3c812f7cfd80cf51e8f5b7034f7418f6beb56c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a3c812f7.failed

When calling keyctl_read() on a key of type "trusted", if the
user-supplied buffer was too small, the kernel ignored the buffer length
and just wrote past the end of the buffer, potentially corrupting
userspace memory.  Fix it by instead returning the size required, as per
the documentation for keyctl_read().

We also don't even fill the buffer at all in this case, as this is
slightly easier to implement than doing a short read, and either
behavior appears to be permitted.  It also makes it match the behavior
of the "encrypted" key type.

Fixes: d00a1c72f7f4 ("keys: add new trusted key-type")
	Reported-by: Ben Hutchings <ben@decadent.org.uk>
	Cc: <stable@vger.kernel.org> # v2.6.38+
	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Reviewed-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
	Reviewed-by: James Morris <james.l.morris@oracle.com>
	Signed-off-by: James Morris <james.l.morris@oracle.com>
(cherry picked from commit a3c812f7cfd80cf51e8f5b7034f7418f6beb56c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/trusted.c
diff --cc security/keys/trusted.c
index 85c9acff3892,98aa89ff7bfd..000000000000
--- a/security/keys/trusted.c
+++ b/security/keys/trusted.c
@@@ -1142,23 -1144,24 +1142,35 @@@ static long trusted_read(const struct k
  	char *bufp;
  	int i;
  
 -	p = dereference_key_locked(key);
 +	p = rcu_dereference_key(key);
  	if (!p)
  		return -EINVAL;
- 	if (!buffer || buflen <= 0)
- 		return 2 * p->blob_len;
- 	ascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);
- 	if (!ascii_buf)
- 		return -ENOMEM;
  
++<<<<<<< HEAD
 +	bufp = ascii_buf;
 +	for (i = 0; i < p->blob_len; i++)
 +		bufp = hex_byte_pack(bufp, p->blob[i]);
 +	if ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {
 +		kfree(ascii_buf);
 +		return -EFAULT;
 +	}
 +	kfree(ascii_buf);
++=======
+ 	if (buffer && buflen >= 2 * p->blob_len) {
+ 		ascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);
+ 		if (!ascii_buf)
+ 			return -ENOMEM;
+ 
+ 		bufp = ascii_buf;
+ 		for (i = 0; i < p->blob_len; i++)
+ 			bufp = hex_byte_pack(bufp, p->blob[i]);
+ 		if (copy_to_user(buffer, ascii_buf, 2 * p->blob_len) != 0) {
+ 			kzfree(ascii_buf);
+ 			return -EFAULT;
+ 		}
+ 		kzfree(ascii_buf);
+ 	}
++>>>>>>> a3c812f7cfd8 (KEYS: trusted: fix writing past end of buffer in trusted_read())
  	return 2 * p->blob_len;
  }
  
* Unmerged path security/keys/trusted.c
