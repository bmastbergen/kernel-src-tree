nvme: Display raw APST configuration via DYNAMIC_DEBUG

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] Display raw APST configuration via DYNAMIC_DEBUG (David Milburn) [1389600]
Rebuild_FUZZ: 94.12%
commit-author Andy Lutomirski <luto@kernel.org>
commit fb0dc3993b537e12ce63511d535ff86efff13c8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fb0dc399.failed

Debugging APST is currently a bit of a pain.  This gives optional
simple log messages that describe the APST state.

The easiest way to use this is probably with the nvme_core.dyndbg=+p
module parameter.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit fb0dc3993b537e12ce63511d535ff86efff13c8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index bd223cb63595,3c9547b94541..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1162,9 -1310,203 +1162,207 @@@ static void nvme_set_queue_limits(struc
  	}
  	if (ctrl->quirks & NVME_QUIRK_STRIPE_SIZE)
  		blk_queue_chunk_sectors(q, ctrl->max_hw_sectors);
 -	blk_queue_virt_boundary(q, ctrl->page_size - 1);
  	if (ctrl->vwc & NVME_CTRL_VWC_PRESENT)
++<<<<<<< HEAD
 +		blk_queue_flush(q, REQ_FLUSH | REQ_FUA);
 +	blk_queue_virt_boundary(q, ctrl->page_size - 1);
++=======
+ 		vwc = true;
+ 	blk_queue_write_cache(q, vwc, vwc);
+ }
+ 
+ static void nvme_configure_apst(struct nvme_ctrl *ctrl)
+ {
+ 	/*
+ 	 * APST (Autonomous Power State Transition) lets us program a
+ 	 * table of power state transitions that the controller will
+ 	 * perform automatically.  We configure it with a simple
+ 	 * heuristic: we are willing to spend at most 2% of the time
+ 	 * transitioning between power states.  Therefore, when running
+ 	 * in any given state, we will enter the next lower-power
+ 	 * non-operational state after waiting 50 * (enlat + exlat)
+ 	 * microseconds, as long as that state's total latency is under
+ 	 * the requested maximum latency.
+ 	 *
+ 	 * We will not autonomously enter any non-operational state for
+ 	 * which the total latency exceeds ps_max_latency_us.  Users
+ 	 * can set ps_max_latency_us to zero to turn off APST.
+ 	 */
+ 
+ 	unsigned apste;
+ 	struct nvme_feat_auto_pst *table;
+ 	u64 max_lat_us = 0;
+ 	int max_ps = -1;
+ 	int ret;
+ 
+ 	/*
+ 	 * If APST isn't supported or if we haven't been initialized yet,
+ 	 * then don't do anything.
+ 	 */
+ 	if (!ctrl->apsta)
+ 		return;
+ 
+ 	if (ctrl->npss > 31) {
+ 		dev_warn(ctrl->device, "NPSS is invalid; not using APST\n");
+ 		return;
+ 	}
+ 
+ 	table = kzalloc(sizeof(*table), GFP_KERNEL);
+ 	if (!table)
+ 		return;
+ 
+ 	if (ctrl->ps_max_latency_us == 0) {
+ 		/* Turn off APST. */
+ 		apste = 0;
+ 		dev_dbg(ctrl->device, "APST disabled\n");
+ 	} else {
+ 		__le64 target = cpu_to_le64(0);
+ 		int state;
+ 
+ 		/*
+ 		 * Walk through all states from lowest- to highest-power.
+ 		 * According to the spec, lower-numbered states use more
+ 		 * power.  NPSS, despite the name, is the index of the
+ 		 * lowest-power state, not the number of states.
+ 		 */
+ 		for (state = (int)ctrl->npss; state >= 0; state--) {
+ 			u64 total_latency_us, transition_ms;
+ 
+ 			if (target)
+ 				table->entries[state] = target;
+ 
+ 			/*
+ 			 * Don't allow transitions to the deepest state
+ 			 * if it's quirked off.
+ 			 */
+ 			if (state == ctrl->npss &&
+ 			    (ctrl->quirks & NVME_QUIRK_NO_DEEPEST_PS))
+ 				continue;
+ 
+ 			/*
+ 			 * Is this state a useful non-operational state for
+ 			 * higher-power states to autonomously transition to?
+ 			 */
+ 			if (!(ctrl->psd[state].flags &
+ 			      NVME_PS_FLAGS_NON_OP_STATE))
+ 				continue;
+ 
+ 			total_latency_us =
+ 				(u64)le32_to_cpu(ctrl->psd[state].entry_lat) +
+ 				+ le32_to_cpu(ctrl->psd[state].exit_lat);
+ 			if (total_latency_us > ctrl->ps_max_latency_us)
+ 				continue;
+ 
+ 			/*
+ 			 * This state is good.  Use it as the APST idle
+ 			 * target for higher power states.
+ 			 */
+ 			transition_ms = total_latency_us + 19;
+ 			do_div(transition_ms, 20);
+ 			if (transition_ms > (1 << 24) - 1)
+ 				transition_ms = (1 << 24) - 1;
+ 
+ 			target = cpu_to_le64((state << 3) |
+ 					     (transition_ms << 8));
+ 
+ 			if (max_ps == -1)
+ 				max_ps = state;
+ 
+ 			if (total_latency_us > max_lat_us)
+ 				max_lat_us = total_latency_us;
+ 		}
+ 
+ 		apste = 1;
+ 
+ 		if (max_ps == -1) {
+ 			dev_dbg(ctrl->device, "APST enabled but no non-operational states are available\n");
+ 		} else {
+ 			dev_dbg(ctrl->device, "APST enabled: max PS = %d, max round-trip latency = %lluus, table = %*phN\n",
+ 				max_ps, max_lat_us, (int)sizeof(*table), table);
+ 		}
+ 	}
+ 
+ 	ret = nvme_set_features(ctrl, NVME_FEAT_AUTO_PST, apste,
+ 				table, sizeof(*table), NULL);
+ 	if (ret)
+ 		dev_err(ctrl->device, "failed to set APST feature (%d)\n", ret);
+ 
+ 	kfree(table);
+ }
+ 
+ static void nvme_set_latency_tolerance(struct device *dev, s32 val)
+ {
+ 	struct nvme_ctrl *ctrl = dev_get_drvdata(dev);
+ 	u64 latency;
+ 
+ 	switch (val) {
+ 	case PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT:
+ 	case PM_QOS_LATENCY_ANY:
+ 		latency = U64_MAX;
+ 		break;
+ 
+ 	default:
+ 		latency = val;
+ 	}
+ 
+ 	if (ctrl->ps_max_latency_us != latency) {
+ 		ctrl->ps_max_latency_us = latency;
+ 		nvme_configure_apst(ctrl);
+ 	}
+ }
+ 
+ struct nvme_core_quirk_entry {
+ 	/*
+ 	 * NVMe model and firmware strings are padded with spaces.  For
+ 	 * simplicity, strings in the quirk table are padded with NULLs
+ 	 * instead.
+ 	 */
+ 	u16 vid;
+ 	const char *mn;
+ 	const char *fr;
+ 	unsigned long quirks;
+ };
+ 
+ static const struct nvme_core_quirk_entry core_quirks[] = {
+ 	{
+ 		/*
+ 		 * This Toshiba device seems to die using any APST states.  See:
+ 		 * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1678184/comments/11
+ 		 */
+ 		.vid = 0x1179,
+ 		.mn = "THNSF5256GPUK TOSHIBA",
+ 		.quirks = NVME_QUIRK_NO_APST,
+ 	}
+ };
+ 
+ /* match is null-terminated but idstr is space-padded. */
+ static bool string_matches(const char *idstr, const char *match, size_t len)
+ {
+ 	size_t matchlen;
+ 
+ 	if (!match)
+ 		return true;
+ 
+ 	matchlen = strlen(match);
+ 	WARN_ON_ONCE(matchlen > len);
+ 
+ 	if (memcmp(idstr, match, matchlen))
+ 		return false;
+ 
+ 	for (; matchlen < len; matchlen++)
+ 		if (idstr[matchlen] != ' ')
+ 			return false;
+ 
+ 	return true;
+ }
+ 
+ static bool quirk_matches(const struct nvme_id_ctrl *id,
+ 			  const struct nvme_core_quirk_entry *q)
+ {
+ 	return q->vid == le16_to_cpu(id->vid) &&
+ 		string_matches(id->mn, q->mn, sizeof(id->mn)) &&
+ 		string_matches(id->fr, q->fr, sizeof(id->fr));
++>>>>>>> fb0dc3993b53 (nvme: Display raw APST configuration via DYNAMIC_DEBUG)
  }
  
  /*
* Unmerged path drivers/nvme/host/core.c
