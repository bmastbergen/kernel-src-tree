ipv4: Fix memory leak in exception case for splitting tries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 3114cdfe66c156345b0ae34e2990472f277e0c1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3114cdfe.failed

Fix a small memory leak that can occur where we leak a fib_alias in the
event of us not being able to insert it into the local table.

Fixes: 0ddcf43d5d4a0 ("ipv4: FIB Local/MAIN table collapse")
	Reported-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3114cdfe66c156345b0ae34e2990472f277e0c1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 5512775a2305,026f309c51e9..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1716,6 -1646,187 +1716,190 @@@ found
  	return n;
  }
  
++<<<<<<< HEAD
++=======
+ static void fib_trie_free(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 
+ 	/* walk trie in reverse order and free everything */
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			n = pn;
+ 			pn = node_parent(pn);
+ 
+ 			/* drop emptied tnode */
+ 			put_child_root(pn, n->key, NULL);
+ 			node_free(n);
+ 
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			hlist_del_rcu(&fa->fa_list);
+ 			alias_free_mem_rcu(fa);
+ 		}
+ 
+ 		put_child_root(pn, n->key, NULL);
+ 		node_free(n);
+ 	}
+ 
+ #ifdef CONFIG_IP_FIB_TRIE_STATS
+ 	free_percpu(t->stats);
+ #endif
+ 	kfree(tb);
+ }
+ 
+ struct fib_table *fib_trie_unmerge(struct fib_table *oldtb)
+ {
+ 	struct trie *ot = (struct trie *)oldtb->tb_data;
+ 	struct key_vector *l, *tp = ot->kv;
+ 	struct fib_table *local_tb;
+ 	struct fib_alias *fa;
+ 	struct trie *lt;
+ 	t_key key = 0;
+ 
+ 	if (oldtb->tb_data == oldtb->__data)
+ 		return oldtb;
+ 
+ 	local_tb = fib_trie_table(RT_TABLE_LOCAL, NULL);
+ 	if (!local_tb)
+ 		return NULL;
+ 
+ 	lt = (struct trie *)local_tb->tb_data;
+ 
+ 	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
+ 		struct key_vector *local_l = NULL, *local_tp;
+ 
+ 		hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
+ 			struct fib_alias *new_fa;
+ 
+ 			if (local_tb->tb_id != fa->tb_id)
+ 				continue;
+ 
+ 			/* clone fa for new local table */
+ 			new_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);
+ 			if (!new_fa)
+ 				goto out;
+ 
+ 			memcpy(new_fa, fa, sizeof(*fa));
+ 
+ 			/* insert clone into table */
+ 			if (!local_l)
+ 				local_l = fib_find_node(lt, &local_tp, l->key);
+ 
+ 			if (fib_insert_alias(lt, local_tp, local_l, new_fa,
+ 					     NULL, l->key)) {
+ 				kmem_cache_free(fn_alias_kmem, new_fa);
+ 				goto out;
+ 			}
+ 		}
+ 
+ 		/* stop loop if key wrapped back to 0 */
+ 		key = l->key + 1;
+ 		if (key < l->key)
+ 			break;
+ 	}
+ 
+ 	return local_tb;
+ out:
+ 	fib_trie_free(local_tb);
+ 
+ 	return NULL;
+ }
+ 
+ /* Caller must hold RTNL */
+ void fib_table_flush_external(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 
+ 	/* walk trie in reverse order */
+ 	for (;;) {
+ 		unsigned char slen = 0;
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			/* cannot resize the trie vector */
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			/* resize completed node */
+ 			pn = resize(t, pn);
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			/* if alias was cloned to local then we just
+ 			 * need to remove the local copy from main
+ 			 */
+ 			if (tb->tb_id != fa->tb_id) {
+ 				hlist_del_rcu(&fa->fa_list);
+ 				alias_free_mem_rcu(fa);
+ 				continue;
+ 			}
+ 
+ 			/* record local slen */
+ 			slen = fa->fa_slen;
+ 		}
+ 
+ 		/* update leaf slen */
+ 		n->slen = slen;
+ 
+ 		if (hlist_empty(&n->leaf)) {
+ 			put_child_root(pn, n->key, NULL);
+ 			node_free(n);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 3114cdfe66c1 (ipv4: Fix memory leak in exception case for splitting tries)
  /* Caller must hold RTNL. */
  int fib_table_flush(struct net *net, struct fib_table *tb)
  {
* Unmerged path net/ipv4/fib_trie.c
