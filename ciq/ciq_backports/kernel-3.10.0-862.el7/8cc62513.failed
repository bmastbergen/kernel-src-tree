net: sched: cls_cgroup: no need to call tcf_exts_change for newly allocated struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: cls_cgroup: no need to call tcf_exts_change for newly allocated struct (Ivan Vecera) [1445420]
Rebuild_FUZZ: 96.86%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 8cc6251381183191f99ecd6d49931251ebbbe27d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8cc62513.failed

As the new struct just was allocated, so no need to use tcf_exts_change
to do atomic change, and we can just fill-up the unused exts struct
directly by tcf_exts_validate.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8cc6251381183191f99ecd6d49931251ebbbe27d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_cgroup.c
diff --cc net/sched/cls_cgroup.c
index 1e87931dbe99,df7a582775df..000000000000
--- a/net/sched/cls_cgroup.c
+++ b/net/sched/cls_cgroup.c
@@@ -188,8 -76,6 +188,11 @@@ static int cls_cgroup_change(struct ne
  	struct nlattr *tb[TCA_CGROUP_MAX + 1];
  	struct cls_cgroup_head *head = rtnl_dereference(tp->root);
  	struct cls_cgroup_head *new;
++<<<<<<< HEAD
 +	struct tcf_ematch_tree t;
 +	struct tcf_exts e;
++=======
++>>>>>>> 8cc625138118 (net: sched: cls_cgroup: no need to call tcf_exts_change for newly allocated struct)
  	int err;
  
  	if (!tca[TCA_OPTIONS])
@@@ -213,19 -101,13 +216,29 @@@
  	if (err < 0)
  		goto errout;
  
++<<<<<<< HEAD
 +	tcf_exts_init(&e, TCA_CGROUP_ACT, TCA_CGROUP_POLICE);
 +	err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &e, ovr);
 +	if (err < 0)
 +		goto errout;
 +
 +	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &t);
 +	if (err < 0) {
 +		tcf_exts_destroy(&e);
 +		goto errout;
 +	}
 +
 +	tcf_exts_change(tp, &new->exts, &e);
 +	tcf_em_tree_change(tp, &new->ematches, &t);
++=======
+ 	err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &new->exts, ovr);
+ 	if (err < 0)
+ 		goto errout;
+ 
+ 	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &new->ematches);
+ 	if (err < 0)
+ 		goto errout;
++>>>>>>> 8cc625138118 (net: sched: cls_cgroup: no need to call tcf_exts_change for newly allocated struct)
  
  	rcu_assign_pointer(tp->root, new);
  	if (head)
* Unmerged path net/sched/cls_cgroup.c
