x86/retpoline/hyperv: Convert assembler indirect jumps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] retpoline/hyperv: Convert assembler indirect jumps (Josh Poimboeuf) [1535644]
Rebuild_FUZZ: 96.15%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit e70e5892b28c18f517f29ab6e83bd57705104b31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e70e5892.failed

Convert all indirect jumps in hyperv inline asm code to use non-speculative
sequences when CONFIG_RETPOLINE is enabled.

	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Arjan van de Ven <arjan@linux.intel.com>
	Acked-by: Ingo Molnar <mingo@kernel.org>
	Cc: gnomes@lxorguk.ukuu.org.uk
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: thomas.lendacky@amd.com
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Jiri Kosina <jikos@kernel.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Kees Cook <keescook@google.com>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Greg Kroah-Hartman <gregkh@linux-foundation.org>
	Cc: Paul Turner <pjt@google.com>
Link: https://lkml.kernel.org/r/1515707194-20531-9-git-send-email-dwmw@amazon.co.uk

(cherry picked from commit e70e5892b28c18f517f29ab6e83bd57705104b31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index c86331fdc4b0,5119e4b555cc..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -3,8 -4,30 +3,9 @@@
  
  #include <linux/types.h>
  #include <linux/atomic.h>
 -#include <linux/nmi.h>
 -#include <asm/io.h>
  #include <asm/hyperv.h>
+ #include <asm/nospec-branch.h>
  
 -/*
 - * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
 - * is set by CPUID(HVCPUID_VERSION_FEATURES).
 - */
 -enum hv_cpuid_function {
 -	HVCPUID_VERSION_FEATURES		= 0x00000001,
 -	HVCPUID_VENDOR_MAXFUNCTION		= 0x40000000,
 -	HVCPUID_INTERFACE			= 0x40000001,
 -
 -	/*
 -	 * The remaining functions depend on the value of
 -	 * HVCPUID_INTERFACE
 -	 */
 -	HVCPUID_VERSION				= 0x40000002,
 -	HVCPUID_FEATURES			= 0x40000003,
 -	HVCPUID_ENLIGHTENMENT_INFO		= 0x40000004,
 -	HVCPUID_IMPLEMENTATION_LIMITS		= 0x40000005,
 -};
 -
  struct ms_hyperv_info {
  	u32 features;
  	u32 misc_features;
@@@ -83,6 -173,208 +84,146 @@@ void hv_setup_crash_handler(void (*hand
  void hv_remove_crash_handler(void);
  
  #if IS_ENABLED(CONFIG_HYPERV)
++<<<<<<< HEAD
++=======
+ extern struct clocksource *hyperv_cs;
+ extern void *hv_hypercall_pg;
+ 
+ static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
+ {
+ 	u64 input_address = input ? virt_to_phys(input) : 0;
+ 	u64 output_address = output ? virt_to_phys(output) : 0;
+ 	u64 hv_status;
+ 
+ #ifdef CONFIG_X86_64
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("mov %4, %%r8\n"
+ 			     CALL_NOSPEC
+ 			     : "=a" (hv_status), ASM_CALL_CONSTRAINT,
+ 			       "+c" (control), "+d" (input_address)
+ 			     :  "r" (output_address),
+ 				THUNK_TARGET(hv_hypercall_pg)
+ 			     : "cc", "memory", "r8", "r9", "r10", "r11");
+ #else
+ 	u32 input_address_hi = upper_32_bits(input_address);
+ 	u32 input_address_lo = lower_32_bits(input_address);
+ 	u32 output_address_hi = upper_32_bits(output_address);
+ 	u32 output_address_lo = lower_32_bits(output_address);
+ 
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__(CALL_NOSPEC
+ 			     : "=A" (hv_status),
+ 			       "+c" (input_address_lo), ASM_CALL_CONSTRAINT
+ 			     : "A" (control),
+ 			       "b" (input_address_hi),
+ 			       "D"(output_address_hi), "S"(output_address_lo),
+ 			       THUNK_TARGET(hv_hypercall_pg)
+ 			     : "cc", "memory");
+ #endif /* !x86_64 */
+ 	return hv_status;
+ }
+ 
+ #define HV_HYPERCALL_RESULT_MASK	GENMASK_ULL(15, 0)
+ #define HV_HYPERCALL_FAST_BIT		BIT(16)
+ #define HV_HYPERCALL_VARHEAD_OFFSET	17
+ #define HV_HYPERCALL_REP_COMP_OFFSET	32
+ #define HV_HYPERCALL_REP_COMP_MASK	GENMASK_ULL(43, 32)
+ #define HV_HYPERCALL_REP_START_OFFSET	48
+ #define HV_HYPERCALL_REP_START_MASK	GENMASK_ULL(59, 48)
+ 
+ /* Fast hypercall with 8 bytes of input and no output */
+ static inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)
+ {
+ 	u64 hv_status, control = (u64)code | HV_HYPERCALL_FAST_BIT;
+ 
+ #ifdef CONFIG_X86_64
+ 	{
+ 		__asm__ __volatile__(CALL_NOSPEC
+ 				     : "=a" (hv_status), ASM_CALL_CONSTRAINT,
+ 				       "+c" (control), "+d" (input1)
+ 				     : THUNK_TARGET(hv_hypercall_pg)
+ 				     : "cc", "r8", "r9", "r10", "r11");
+ 	}
+ #else
+ 	{
+ 		u32 input1_hi = upper_32_bits(input1);
+ 		u32 input1_lo = lower_32_bits(input1);
+ 
+ 		__asm__ __volatile__ (CALL_NOSPEC
+ 				      : "=A"(hv_status),
+ 					"+c"(input1_lo),
+ 					ASM_CALL_CONSTRAINT
+ 				      :	"A" (control),
+ 					"b" (input1_hi),
+ 					THUNK_TARGET(hv_hypercall_pg)
+ 				      : "cc", "edi", "esi");
+ 	}
+ #endif
+ 		return hv_status;
+ }
+ 
+ /*
+  * Rep hypercalls. Callers of this functions are supposed to ensure that
+  * rep_count and varhead_size comply with Hyper-V hypercall definition.
+  */
+ static inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,
+ 				      void *input, void *output)
+ {
+ 	u64 control = code;
+ 	u64 status;
+ 	u16 rep_comp;
+ 
+ 	control |= (u64)varhead_size << HV_HYPERCALL_VARHEAD_OFFSET;
+ 	control |= (u64)rep_count << HV_HYPERCALL_REP_COMP_OFFSET;
+ 
+ 	do {
+ 		status = hv_do_hypercall(control, input, output);
+ 		if ((status & HV_HYPERCALL_RESULT_MASK) != HV_STATUS_SUCCESS)
+ 			return status;
+ 
+ 		/* Bits 32-43 of status have 'Reps completed' data. */
+ 		rep_comp = (status & HV_HYPERCALL_REP_COMP_MASK) >>
+ 			HV_HYPERCALL_REP_COMP_OFFSET;
+ 
+ 		control &= ~HV_HYPERCALL_REP_START_MASK;
+ 		control |= (u64)rep_comp << HV_HYPERCALL_REP_START_OFFSET;
+ 
+ 		touch_nmi_watchdog();
+ 	} while (rep_comp < rep_count);
+ 
+ 	return status;
+ }
+ 
+ /*
+  * Hypervisor's notion of virtual processor ID is different from
+  * Linux' notion of CPU ID. This information can only be retrieved
+  * in the context of the calling CPU. Setup a map for easy access
+  * to this information.
+  */
+ extern u32 *hv_vp_index;
+ extern u32 hv_max_vp_index;
+ 
+ /**
+  * hv_cpu_number_to_vp_number() - Map CPU to VP.
+  * @cpu_number: CPU number in Linux terms
+  *
+  * This function returns the mapping between the Linux processor
+  * number and the hypervisor's virtual processor number, useful
+  * in making hypercalls and such that talk about specific
+  * processors.
+  *
+  * Return: Virtual processor number in Hyper-V terms
+  */
+ static inline int hv_cpu_number_to_vp_number(int cpu_number)
+ {
+ 	return hv_vp_index[cpu_number];
+ }
+ 
++>>>>>>> e70e5892b28c (x86/retpoline/hyperv: Convert assembler indirect jumps)
  void hyperv_init(void);
 -void hyperv_setup_mmu_ops(void);
 -void hyper_alloc_mmu(void);
 -void hyperv_report_panic(struct pt_regs *regs);
 -bool hv_is_hypercall_page_setup(void);
 -void hyperv_cleanup(void);
 -#else /* CONFIG_HYPERV */
 -static inline void hyperv_init(void) {}
 -static inline bool hv_is_hypercall_page_setup(void) { return false; }
 -static inline void hyperv_cleanup(void) {}
 -static inline void hyperv_setup_mmu_ops(void) {}
 -#endif /* CONFIG_HYPERV */
 -
 -#ifdef CONFIG_HYPERV_TSCPAGE
 -struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
 -static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
 -{
 -	u64 scale, offset, cur_tsc;
 -	u32 sequence;
 -
 -	/*
 -	 * The protocol for reading Hyper-V TSC page is specified in Hypervisor
 -	 * Top-Level Functional Specification ver. 3.0 and above. To get the
 -	 * reference time we must do the following:
 -	 * - READ ReferenceTscSequence
 -	 *   A special '0' value indicates the time source is unreliable and we
 -	 *   need to use something else. The currently published specification
 -	 *   versions (up to 4.0b) contain a mistake and wrongly claim '-1'
 -	 *   instead of '0' as the special value, see commit c35b82ef0294.
 -	 * - ReferenceTime =
 -	 *        ((RDTSC() * ReferenceTscScale) >> 64) + ReferenceTscOffset
 -	 * - READ ReferenceTscSequence again. In case its value has changed
 -	 *   since our first reading we need to discard ReferenceTime and repeat
 -	 *   the whole sequence as the hypervisor was updating the page in
 -	 *   between.
 -	 */
 -	do {
 -		sequence = READ_ONCE(tsc_pg->tsc_sequence);
 -		if (!sequence)
 -			return U64_MAX;
 -		/*
 -		 * Make sure we read sequence before we read other values from
 -		 * TSC page.
 -		 */
 -		smp_rmb();
 -
 -		scale = READ_ONCE(tsc_pg->tsc_scale);
 -		offset = READ_ONCE(tsc_pg->tsc_offset);
 -		cur_tsc = rdtsc_ordered();
 -
 -		/*
 -		 * Make sure we read sequence after we read all other values
 -		 * from TSC page.
 -		 */
 -		smp_rmb();
 -
 -	} while (READ_ONCE(tsc_pg->tsc_sequence) != sequence);
 -
 -	return mul_u64_u64_shr(cur_tsc, scale, 64) + offset;
 -}
 -
 -#else
 -static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
 -{
 -	return NULL;
 -}
  #endif
  #endif
* Unmerged path arch/x86/include/asm/mshyperv.h
