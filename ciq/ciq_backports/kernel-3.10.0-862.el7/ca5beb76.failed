dm mpath: micro-optimize the hot path relative to MPATHF_QUEUE_IF_NO_PATH

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit ca5beb76c32af33e5be4e01c85c8bd5a067c4543
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ca5beb76.failed

Instead of checking MPATHF_QUEUE_IF_NO_PATH,
MPATHF_SAVED_QUEUE_IF_NO_PATH and the no_flush flag to decide whether
or not to push back a request (or bio) if there are no paths available,
only clear MPATHF_QUEUE_IF_NO_PATH in queue_if_no_path() if no_flush has
not been set.  The result is that only a single bit has to be tested in
the hot path to decide whether or not a request must be pushed back and
also that m->lock does not have to be taken in the hot path.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit ca5beb76c32af33e5be4e01c85c8bd5a067c4543)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-mpath.c
diff --cc drivers/md/dm-mpath.c
index 745e8192f19b,5cb1beccd1e2..000000000000
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@@ -496,58 -442,19 +496,62 @@@ failed
  }
  
  /*
++<<<<<<< HEAD
 + * Check whether bios must be queued in the device-mapper core rather
 + * than here in the target.
 + *
 + * If m->queue_if_no_path and m->saved_queue_if_no_path hold the
 + * same value then we are not between multipath_presuspend()
 + * and multipath_resume() calls and we have no need to check
 + * for the DMF_NOFLUSH_SUSPENDING flag.
 + */
 +static bool __must_push_back(struct multipath *m)
 +{
 +	return ((test_bit(MPATHF_QUEUE_IF_NO_PATH, &m->flags) !=
 +		 test_bit(MPATHF_SAVED_QUEUE_IF_NO_PATH, &m->flags)) &&
 +		dm_noflush_suspending(m->ti));
 +}
 +
 +static bool must_push_back_rq(struct multipath *m)
 +{
 +	bool r;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&m->lock, flags);
 +	r = (test_bit(MPATHF_QUEUE_IF_NO_PATH, &m->flags) ||
 +	     __must_push_back(m));
 +	spin_unlock_irqrestore(&m->lock, flags);
 +
 +	return r;
 +}
 +
 +static bool must_push_back_bio(struct multipath *m)
 +{
 +	bool r;
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&m->lock, flags);
 +	r = __must_push_back(m);
 +	spin_unlock_irqrestore(&m->lock, flags);
 +
 +	return r;
 +}
 +
 +/*
 + * Map cloned requests
++=======
+  * Map cloned requests (request-based multipath)
++>>>>>>> ca5beb76c32a (dm mpath: micro-optimize the hot path relative to MPATHF_QUEUE_IF_NO_PATH)
   */
 -static int multipath_clone_and_map(struct dm_target *ti, struct request *rq,
 -				   union map_info *map_context,
 -				   struct request **__clone)
 +static int __multipath_map(struct dm_target *ti, struct request *clone,
 +			   union map_info *map_context,
 +			   struct request *rq, struct request **__clone)
  {
  	struct multipath *m = ti->private;
 -	size_t nr_bytes = blk_rq_bytes(rq);
 +	size_t nr_bytes = clone ? blk_rq_bytes(clone) : blk_rq_bytes(rq);
  	struct pgpath *pgpath;
  	struct block_device *bdev;
 -	struct dm_mpath_io *mpio = get_mpio(map_context);
 -	struct request_queue *q;
 -	struct request *clone;
 +	struct dm_mpath_io *mpio;
  
  	/* Do we need to select a new pgpath? */
  	pgpath = lockless_dereference(m->current_pgpath);
* Unmerged path drivers/md/dm-mpath.c
