target: refactor node ACL allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] refactor node ACL allocation (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 87.50%
commit-author Christoph Hellwig <hch@lst.de>
commit e413f4727037e826c55a639c713a221006b6d61d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e413f472.failed

Split out two common helpers to share code for allocating and initializing
node ACLs.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit e413f4727037e826c55a639c713a221006b6d61d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_tpg.c
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,0cd86ff9a792..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -371,15 -387,7 +390,19 @@@ struct se_node_acl *core_tpg_add_initia
  				" for %s\n", tpg->se_tpg_tfo->get_fabric_name(),
  				tpg->se_tpg_tfo->tpg_get_tag(tpg), initiatorname);
  			spin_unlock_irq(&tpg->acl_node_lock);
++<<<<<<< HEAD
 +			/*
 +			 * Release the locally allocated struct se_node_acl
 +			 * because * core_tpg_add_initiator_node_acl() returned
 +			 * a pointer to an existing demo mode node ACL.
 +			 */
 +			if (se_nacl)
 +				tpg->se_tpg_tfo->tpg_release_fabric_acl(tpg,
 +							se_nacl);
 +			goto done;
++=======
+ 			return acl;
++>>>>>>> e413f4727037 (target: refactor node ACL allocation)
  		}
  
  		pr_err("ACL entry for %s Initiator"
@@@ -391,66 -399,17 +414,54 @@@
  	}
  	spin_unlock_irq(&tpg->acl_node_lock);
  
++<<<<<<< HEAD
 +	if (!se_nacl) {
 +		pr_err("struct se_node_acl pointer is NULL\n");
 +		return ERR_PTR(-EINVAL);
 +	}
 +	/*
 +	 * For v4.x logic the se_node_acl_s is hanging off a fabric
 +	 * dependent structure allocated via
 +	 * struct target_core_fabric_ops->fabric_make_nodeacl()
 +	 */
 +	acl = se_nacl;
 +
 +	INIT_LIST_HEAD(&acl->acl_list);
 +	INIT_LIST_HEAD(&acl->acl_sess_list);
 +	kref_init(&acl->acl_kref);
 +	init_completion(&acl->acl_free_comp);
 +	spin_lock_init(&acl->device_list_lock);
 +	spin_lock_init(&acl->nacl_sess_lock);
 +	atomic_set(&acl->acl_pr_ref_count, 0);
 +	acl->queue_depth = queue_depth;
 +	snprintf(acl->initiatorname, TRANSPORT_IQN_LEN, "%s", initiatorname);
 +	acl->se_tpg = tpg;
 +	acl->acl_index = scsi_get_new_index(SCSI_AUTH_INTR_INDEX);
 +
 +	tpg->se_tpg_tfo->set_default_node_attributes(acl);
 +
 +	if (core_create_device_list_for_node(acl) < 0) {
 +		tpg->se_tpg_tfo->tpg_release_fabric_acl(tpg, acl);
++=======
+ 	acl = target_alloc_node_acl(tpg, initiatorname);
+ 	if (!acl)
++>>>>>>> e413f4727037 (target: refactor node ACL allocation)
  		return ERR_PTR(-ENOMEM);
- 	}
- 
- 	if (core_set_queue_depth_for_node(tpg, acl) < 0) {
- 		core_free_device_list_for_node(acl, tpg);
- 		tpg->se_tpg_tfo->tpg_release_fabric_acl(tpg, acl);
- 		return ERR_PTR(-EINVAL);
- 	}
- 
- 	spin_lock_irq(&tpg->acl_node_lock);
- 	list_add_tail(&acl->acl_list, &tpg->acl_node_list);
- 	tpg->num_node_acls++;
- 	spin_unlock_irq(&tpg->acl_node_lock);
- 
- done:
- 	pr_debug("%s_TPG[%hu] - Added ACL with TCQ Depth: %d for %s"
- 		" Initiator Node: %s\n", tpg->se_tpg_tfo->get_fabric_name(),
- 		tpg->se_tpg_tfo->tpg_get_tag(tpg), acl->queue_depth,
- 		tpg->se_tpg_tfo->get_fabric_name(), initiatorname);
  
+ 	target_add_node_acl(acl);
  	return acl;
  }
 +EXPORT_SYMBOL(core_tpg_add_initiator_node_acl);
  
 -void core_tpg_del_initiator_node_acl(struct se_node_acl *acl)
 +/*	core_tpg_del_initiator_node_acl():
 + *
 + *
 + */
 +int core_tpg_del_initiator_node_acl(
 +	struct se_portal_group *tpg,
 +	struct se_node_acl *acl,
 +	int force)
  {
 -	struct se_portal_group *tpg = acl->se_tpg;
  	LIST_HEAD(sess_list);
  	struct se_session *sess, *sess_tmp;
  	unsigned long flags;
* Unmerged path drivers/target/target_core_tpg.c
