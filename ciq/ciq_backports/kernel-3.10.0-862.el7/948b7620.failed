PCI/MSI: Return -ENOSPC if pci_enable_msi_range() can't get enough vectors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [pci] msi: Return -ENOSPC if pci_enable_msi_range() can't get enough vectors (Ming Lei) [1389540]
Rebuild_FUZZ: 97.22%
commit-author Dennis Chen <dennis.chen@arm.com>
commit 948b7620c15411444167a62cfc14cdd4b0e44682
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/948b7620.failed

If device doesn't support as many MSI vectors as the driver requested, we
previously returned -EINVAL from __pci_enable_msi_range() and
pci_enable_msi_range().  In other similar situations in both
__pci_enable_msi_range() and __pci_enable_msix_range(), we returned
-ENOSPC.

Return -ENOSPC from __pci_enable_msi_range() so we do it consistently.

[bhelgaas: changelog]
	Signed-off-by: Dennis Chen <dennis.chen@arm.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
CC: Tejun Heo <tj@kernel.org>
CC: Christoph Hellwig <hch@lst.de>
CC: Tom Long Nguyen <tom.l.nguyen@intel.com>
CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
CC: Marc Zyngier <marc.zyngier@arm.com>
CC: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
CC: Steve Capper <steve.capper@arm.com>
(cherry picked from commit 948b7620c15411444167a62cfc14cdd4b0e44682)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/msi.c
diff --cc drivers/pci/msi.c
index 0a99aff13490,93cc268c6ff1..000000000000
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@@ -1108,25 -1064,70 +1108,32 @@@ int pci_enable_msi_range(struct pci_de
  	nvec = pci_msi_vec_count(dev);
  	if (nvec < 0)
  		return nvec;
++<<<<<<< HEAD
 +	else if (nvec < minvec)
 +		return -EINVAL;
 +	else if (nvec > maxvec)
++=======
+ 	if (nvec < minvec)
+ 		return -ENOSPC;
+ 
+ 	if (nvec > maxvec)
++>>>>>>> 948b7620c154 (PCI/MSI: Return -ENOSPC if pci_enable_msi_range() can't get enough vectors)
  		nvec = maxvec;
  
 -	for (;;) {
 -		if (affd) {
 -			nvec = irq_calc_affinity_vectors(nvec, affd);
 -			if (nvec < minvec)
 -				return -ENOSPC;
 -		}
 -
 -		rc = msi_capability_init(dev, nvec, affd);
 -		if (rc == 0)
 -			return nvec;
 -
 -		if (rc < 0)
 +	do {
 +		rc = msi_capability_init(dev, nvec);
 +		if (rc < 0) {
  			return rc;
 -		if (rc < minvec)
 -			return -ENOSPC;
 -
 -		nvec = rc;
 -	}
 -}
 -
 -/* deprecated, don't use */
 -int pci_enable_msi(struct pci_dev *dev)
 -{
 -	int rc = __pci_enable_msi_range(dev, 1, 1, NULL);
 -	if (rc < 0)
 -		return rc;
 -	return 0;
 -}
 -EXPORT_SYMBOL(pci_enable_msi);
 -
 -static int __pci_enable_msix_range(struct pci_dev *dev,
 -				   struct msix_entry *entries, int minvec,
 -				   int maxvec, const struct irq_affinity *affd)
 -{
 -	int rc, nvec = maxvec;
 -
 -	if (maxvec < minvec)
 -		return -ERANGE;
 -
 -	for (;;) {
 -		if (affd) {
 -			nvec = irq_calc_affinity_vectors(nvec, affd);
 -			if (nvec < minvec)
 +		} else if (rc > 0) {
 +			if (rc < minvec)
  				return -ENOSPC;
 +			nvec = rc;
  		}
 +	} while (rc);
  
 -		rc = __pci_enable_msix(dev, entries, nvec, affd);
 -		if (rc == 0)
 -			return nvec;
 -
 -		if (rc < 0)
 -			return rc;
 -		if (rc < minvec)
 -			return -ENOSPC;
 -
 -		nvec = rc;
 -	}
 +	return nvec;
  }
 +EXPORT_SYMBOL(pci_enable_msi_range);
  
  /**
   * pci_enable_msix_range - configure device's MSI-X capability structure
* Unmerged path drivers/pci/msi.c
