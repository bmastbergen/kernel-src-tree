scsi: cxlflash: Add hardware queues attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] cxlflash: Add hardware queues attribute (Gustavo Duarte) [1456494]
Rebuild_FUZZ: 92.86%
commit-author Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
commit 3065267a80c88d775e8eb34196280e8eee33322f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3065267a.failed

As staging for supporting multiple hardware queues, add an attribute to show
and set the current number of hardware queues for the host. Support specifying
a hard limit or a CPU affinitized value. This will allow the number of
hardware queues to be tuned by a system administrator.

	Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
	Signed-off-by: Uma Krishnan <ukrishn@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3065267a80c88d775e8eb34196280e8eee33322f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxlflash/common.h
#	drivers/scsi/cxlflash/main.c
diff --cc drivers/scsi/cxlflash/common.h
index 811927d91c5c,8fd7a1fa235e..000000000000
--- a/drivers/scsi/cxlflash/common.h
+++ b/drivers/scsi/cxlflash/common.h
@@@ -53,6 -57,14 +53,17 @@@ extern const struct file_operations cxl
  /* RRQ for master issued cmds */
  #define NUM_RRQ_ENTRY                   CXLFLASH_MAX_CMDS
  
++<<<<<<< HEAD
++=======
+ /* SQ for master issued cmds */
+ #define NUM_SQ_ENTRY			CXLFLASH_MAX_CMDS
+ 
+ /* Hardware queue definitions */
+ #define CXLFLASH_DEF_HWQS		1
+ #define CXLFLASH_MAX_HWQS		8
+ #define PRIMARY_HWQ			0
+ 
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
  static inline void check_sizes(void)
  {
@@@ -170,19 -195,63 +181,69 @@@ struct afu 
  	u64 *hrrq_end;
  	u64 *hrrq_curr;
  	bool toggle;
 -
  	s64 room;
  	spinlock_t rrin_slock; /* Lock to rrin queuing and cmd_room updates */
++<<<<<<< HEAD
++=======
+ 
+ 	struct irq_poll irqpoll;
+ } __aligned(cache_line_size());
+ 
+ struct afu {
+ 	struct hwq hwqs[CXLFLASH_MAX_HWQS];
+ 	int (*send_cmd)(struct afu *, struct afu_cmd *);
+ 	void (*context_reset)(struct afu_cmd *);
+ 
+ 	/* AFU HW */
+ 	struct cxlflash_afu_map __iomem *afu_map;	/* entire MMIO map */
+ 
+ 	atomic_t cmds_active;	/* Number of currently active AFU commands */
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  	u64 hb;
 +	u32 cmd_couts;		/* Number of command checkouts */
  	u32 internal_lun;	/* User-desired LUN mode for this AFU */
+ 	u32 num_hwqs;		/* Number of hardware queues */
+ 	u32 desired_hwqs;	/* Desired h/w queues, effective on AFU reset */
  
  	char version[16];
  	u64 interface_version;
  
 -	u32 irqpoll_weight;
  	struct cxlflash_cfg *parent; /* Pointer back to parent cxlflash_cfg */
 +
  };
  
++<<<<<<< HEAD
++=======
+ static inline struct hwq *get_hwq(struct afu *afu, u32 index)
+ {
+ 	WARN_ON(index >= CXLFLASH_MAX_HWQS);
+ 
+ 	return &afu->hwqs[index];
+ }
+ 
+ static inline bool afu_is_irqpoll_enabled(struct afu *afu)
+ {
+ 	return !!afu->irqpoll_weight;
+ }
+ 
+ static inline bool afu_is_cmd_mode(struct afu *afu, u64 cmd_mode)
+ {
+ 	u64 afu_cap = afu->interface_version >> SISL_INTVER_CAP_SHIFT;
+ 
+ 	return afu_cap & cmd_mode;
+ }
+ 
+ static inline bool afu_is_sq_cmd_mode(struct afu *afu)
+ {
+ 	return afu_is_cmd_mode(afu, SISL_INTVER_CAP_SQ_CMD_MODE);
+ }
+ 
+ static inline bool afu_is_ioarrin_cmd_mode(struct afu *afu)
+ {
+ 	return afu_is_cmd_mode(afu, SISL_INTVER_CAP_IOARRIN_CMD_MODE);
+ }
+ 
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  static inline u64 lun_to_lunid(u64 lun)
  {
  	__be64 lun_id;
diff --cc drivers/scsi/cxlflash/main.c
index c68badcfa77f,113797aafd7e..000000000000
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@@ -606,11 -562,15 +606,23 @@@ static void stop_afu(struct cxlflash_cf
  	cancel_work_sync(&cfg->work_q);
  
  	if (likely(afu)) {
++<<<<<<< HEAD
 +		for (i = 0; i < CXLFLASH_NUM_CMDS; i++) {
 +			cmd = &afu->cmd[i];
 +			complete(&cmd->cevent);
 +			if (!atomic_read(&cmd->free))
 +				cmd_checkin(cmd);
++=======
+ 		while (atomic_read(&afu->cmds_active))
+ 			ssleep(1);
+ 
+ 		if (afu_is_irqpoll_enabled(afu)) {
+ 			for (i = 0; i < afu->num_hwqs; i++) {
+ 				hwq = get_hwq(afu, i);
+ 
+ 				irq_poll_disable(&hwq->irqpoll);
+ 			}
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  		}
  
  		if (likely(afu->afu_map)) {
@@@ -689,17 -672,20 +701,28 @@@ static void term_afu(struct cxlflash_cf
  	 * no interrupts can come in when the problem state
  	 * area is unmapped.
  	 *
 -	 * 1) Disable all AFU interrupts for each master
 +	 * 1) Disable all AFU interrupts
  	 * 2) Unmap the problem state area
 -	 * 3) Stop each master context
 +	 * 3) Stop the master context
  	 */
++<<<<<<< HEAD
 +	term_intr(cfg, UNMAP_THREE);
 +	if (cfg->afu)
 +		stop_afu(cfg);
 +
 +	term_mc(cfg);
++=======
+ 	for (k = cfg->afu->num_hwqs - 1; k >= 0; k--)
+ 		term_intr(cfg, UNMAP_THREE, k);
+ 
+ 	if (cfg->afu)
+ 		stop_afu(cfg);
+ 
+ 	for (k = cfg->afu->num_hwqs - 1; k >= 0; k--)
+ 		term_mc(cfg, k);
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
 -	dev_dbg(dev, "%s: returning\n", __func__);
 +	pr_debug("%s: returning\n", __func__);
  }
  
  /**
@@@ -836,13 -823,8 +859,14 @@@ static int alloc_mem(struct cxlflash_cf
  		goto out;
  	}
  	cfg->afu->parent = cfg;
+ 	cfg->afu->desired_hwqs = CXLFLASH_DEF_HWQS;
  	cfg->afu->afu_map = NULL;
 +
 +	for (i = 0; i < CXLFLASH_NUM_CMDS; i++) {
 +		atomic_set(&cfg->afu->cmd[i].free, 1);
 +		cfg->afu->cmd[i].slot = i;
 +	}
 +
  out:
  	return rc;
  }
@@@ -1173,8 -1117,12 +1197,17 @@@ static void afu_err_intr_init(struct af
  	/* IOARRIN yet), so there is nothing to clear. */
  
  	/* set LISN#, it is always sent to the context that wrote IOARRIN */
++<<<<<<< HEAD
 +	writeq_be(SISL_MSI_SYNC_ERROR, &afu->host_map->ctx_ctrl);
 +	writeq_be(SISL_ISTATUS_MASK, &afu->host_map->intr_mask);
++=======
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		hwq = get_hwq(afu, i);
+ 
+ 		writeq_be(SISL_MSI_SYNC_ERROR, &hwq->host_map->ctx_ctrl);
+ 		writeq_be(SISL_ISTATUS_MASK, &hwq->host_map->intr_mask);
+ 	}
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  }
  
  /**
@@@ -1463,19 -1551,16 +1496,25 @@@ static void init_pcr(struct cxlflash_cf
  		writeq_be(0, &ctrl_map->ctx_cap);
  	}
  
++<<<<<<< HEAD
 +	/* Copy frequently used fields into afu */
 +	afu->ctx_hndl = (u16) cxl_process_element(cfg->mcctx);
 +	afu->host_map = &afu->afu_map->hosts[afu->ctx_hndl].host;
 +	afu->ctrl_map = &afu->afu_map->ctrls[afu->ctx_hndl].ctrl;
++=======
+ 	/* Copy frequently used fields into hwq */
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		hwq = get_hwq(afu, i);
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
 -		hwq->ctx_hndl = (u16) cxl_process_element(hwq->ctx);
 -		hwq->host_map = &afu->afu_map->hosts[hwq->ctx_hndl].host;
 -		hwq->ctrl_map = &afu->afu_map->ctrls[hwq->ctx_hndl].ctrl;
 +	/* Program the Endian Control for the master context */
 +	writeq_be(SISL_ENDIAN_CTRL, &afu->host_map->endian_ctrl);
  
 -		/* Program the Endian Control for the master context */
 -		writeq_be(SISL_ENDIAN_CTRL, &hwq->host_map->endian_ctrl);
 +	/* Initialize cmd fields that never change */
 +	for (i = 0; i < CXLFLASH_NUM_CMDS; i++) {
 +		afu->cmd[i].rcb.ctx_id = afu->ctx_hndl;
 +		afu->cmd[i].rcb.msi = SISL_MSI_RRQ_UPDATED;
 +		afu->cmd[i].rcb.rrq = 0x0;
  	}
  }
  
@@@ -1498,11 -1586,19 +1537,18 @@@ static int init_global(struct cxlflash_
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	pr_debug("%s: wwpn0=0x%llX wwpn1=0x%llX\n", __func__, wwpn[0], wwpn[1]);
++=======
+ 	/* Set up RRQ and SQ in HWQ for master issued cmds */
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		hwq = get_hwq(afu, i);
+ 		hmap = hwq->host_map;
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
 -		writeq_be((u64) hwq->hrrq_start, &hmap->rrq_start);
 -		writeq_be((u64) hwq->hrrq_end, &hmap->rrq_end);
 -
 -		if (afu_is_sq_cmd_mode(afu)) {
 -			writeq_be((u64)hwq->hsq_start, &hmap->sq_start);
 -			writeq_be((u64)hwq->hsq_end, &hmap->sq_end);
 -		}
 -	}
 +	/* Set up RRQ in AFU for master issued cmds */
 +	writeq_be((u64) afu->hrrq_start, &afu->host_map->rrq_start);
 +	writeq_be((u64) afu->hrrq_end, &afu->host_map->rrq_end);
  
  	/* AFU configuration */
  	reg = readq_be(&afu->afu_map->global.regs.afu_config);
@@@ -1546,14 -1641,17 +1592,26 @@@
  	/* Set up master's own CTX_CAP to allow real mode, host translation */
  	/* tables, afu cmds and read/write GSCSI cmds. */
  	/* First, unlock ctx_cap write by reading mbox */
++<<<<<<< HEAD
 +	(void)readq_be(&afu->ctrl_map->mbox_r);	/* unlock ctx_cap */
 +	writeq_be((SISL_CTX_CAP_REAL_MODE | SISL_CTX_CAP_HOST_XLATE |
 +		   SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD |
 +		   SISL_CTX_CAP_AFU_CMD | SISL_CTX_CAP_GSCSI_CMD),
 +		  &afu->ctrl_map->ctx_cap);
++=======
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		hwq = get_hwq(afu, i);
+ 
+ 		(void)readq_be(&hwq->ctrl_map->mbox_r);	/* unlock ctx_cap */
+ 		writeq_be((SISL_CTX_CAP_REAL_MODE | SISL_CTX_CAP_HOST_XLATE |
+ 			SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD |
+ 			SISL_CTX_CAP_AFU_CMD | SISL_CTX_CAP_GSCSI_CMD),
+ 			&hwq->ctrl_map->ctx_cap);
+ 	}
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  	/* Initialize heartbeat */
  	afu->hb = readq_be(&afu->afu_map->global.regs.afu_hb);
 +
  out:
  	return rc;
  }
@@@ -1580,14 -1670,37 +1638,20 @@@ static int start_afu(struct cxlflash_cf
  
  	init_pcr(cfg);
  
++<<<<<<< HEAD
 +	/* After an AFU reset, RRQ entries are stale, clear them */
 +	memset(&afu->rrq_entry, 0, sizeof(afu->rrq_entry));
++=======
+ 	/* Initialize each HWQ */
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		hwq = get_hwq(afu, i);
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
 -		/* After an AFU reset, RRQ entries are stale, clear them */
 -		memset(&hwq->rrq_entry, 0, sizeof(hwq->rrq_entry));
 -
 -		/* Initialize RRQ pointers */
 -		hwq->hrrq_start = &hwq->rrq_entry[0];
 -		hwq->hrrq_end = &hwq->rrq_entry[NUM_RRQ_ENTRY - 1];
 -		hwq->hrrq_curr = hwq->hrrq_start;
 -		hwq->toggle = 1;
 -		spin_lock_init(&hwq->hrrq_slock);
 -
 -		/* Initialize SQ */
 -		if (afu_is_sq_cmd_mode(afu)) {
 -			memset(&hwq->sq, 0, sizeof(hwq->sq));
 -			hwq->hsq_start = &hwq->sq[0];
 -			hwq->hsq_end = &hwq->sq[NUM_SQ_ENTRY - 1];
 -			hwq->hsq_curr = hwq->hsq_start;
 -
 -			spin_lock_init(&hwq->hsq_slock);
 -			atomic_set(&hwq->hsq_credits, NUM_SQ_ENTRY - 1);
 -		}
 -
 -		/* Initialize IRQ poll */
 -		if (afu_is_irqpoll_enabled(afu))
 -			irq_poll_init(&hwq->irqpoll, afu->irqpoll_weight,
 -				      cxlflash_irqpoll);
 -
 -	}
 +	/* Initialize RRQ pointers */
 +	afu->hrrq_start = &afu->rrq_entry[0];
 +	afu->hrrq_end = &afu->rrq_entry[NUM_RRQ_ENTRY - 1];
 +	afu->hrrq_curr = afu->hrrq_start;
 +	afu->toggle = 1;
  
  	rc = init_global(cfg);
  
@@@ -1721,17 -1887,23 +1785,28 @@@ static int init_afu(struct cxlflash_cf
  
  	cxl_perst_reloads_same_image(cfg->cxl_afu, true);
  
++<<<<<<< HEAD
 +	rc = init_mc(cfg);
 +	if (rc) {
 +		dev_err(dev, "%s: call to init_mc failed, rc=%d!\n",
 +			__func__, rc);
 +		goto out;
++=======
+ 	afu->num_hwqs = afu->desired_hwqs;
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		rc = init_mc(cfg, i);
+ 		if (rc) {
+ 			dev_err(dev, "%s: init_mc failed rc=%d index=%d\n",
+ 				__func__, rc, i);
+ 			goto err1;
+ 		}
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  	}
  
 -	/* Map the entire MMIO space of the AFU using the first context */
 -	hwq = get_hwq(afu, PRIMARY_HWQ);
 -	afu->afu_map = cxl_psa_map(hwq->ctx);
 +	/* Map the entire MMIO space of the AFU */
 +	afu->afu_map = cxl_psa_map(cfg->mcctx);
  	if (!afu->afu_map) {
 -		dev_err(dev, "%s: cxl_psa_map failed\n", __func__);
 +		dev_err(dev, "%s: call to cxl_psa_map failed!\n", __func__);
  		rc = -ENOMEM;
  		goto err1;
  	}
@@@ -1760,8 -1941,12 +1835,17 @@@
  	}
  
  	afu_err_intr_init(cfg->afu);
++<<<<<<< HEAD
 +	spin_lock_init(&afu->rrin_slock);
 +	afu->room = readq_be(&afu->host_map->cmd_room);
++=======
+ 	for (i = 0; i < afu->num_hwqs; i++) {
+ 		hwq = get_hwq(afu, i);
+ 
+ 		spin_lock_init(&hwq->rrin_slock);
+ 		hwq->room = readq_be(&hwq->host_map->cmd_room);
+ 	}
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
  	/* Restore the LUN mappings */
  	cxlflash_restore_luntable(cfg);
@@@ -1770,8 -1955,10 +1854,15 @@@ out
  	return rc;
  
  err1:
++<<<<<<< HEAD
 +	term_intr(cfg, UNMAP_THREE);
 +	term_mc(cfg);
++=======
+ 	for (i = afu->num_hwqs - 1; i >= 0; i--) {
+ 		term_intr(cfg, UNMAP_THREE, i);
+ 		term_mc(cfg, i);
+ 	}
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  	goto out;
  }
  
@@@ -2230,11 -2453,205 +2321,157 @@@ static ssize_t port1_lun_table_show(str
  				    struct device_attribute *attr,
  				    char *buf)
  {
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -
 -	return cxlflash_show_port_lun_table(1, cfg, buf);
 -}
 -
 -/**
 - * port2_lun_table_show() - presents the current LUN table of port 2
 - * @dev:	Generic device associated with the host owning the port.
 - * @attr:	Device attribute representing the port.
 - * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t port2_lun_table_show(struct device *dev,
 -				    struct device_attribute *attr,
 -				    char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -
 -	return cxlflash_show_port_lun_table(2, cfg, buf);
 -}
 -
 -/**
 - * port3_lun_table_show() - presents the current LUN table of port 3
 - * @dev:	Generic device associated with the host owning the port.
 - * @attr:	Device attribute representing the port.
 - * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t port3_lun_table_show(struct device *dev,
 -				    struct device_attribute *attr,
 -				    char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 -
 -	return cxlflash_show_port_lun_table(3, cfg, buf);
 -}
 -
 -/**
 - * irqpoll_weight_show() - presents the current IRQ poll weight for the host
 - * @dev:	Generic device associated with the host.
 - * @attr:	Device attribute representing the IRQ poll weight.
 - * @buf:	Buffer of length PAGE_SIZE to report back the current IRQ poll
 - *		weight in ASCII.
 - *
 - * An IRQ poll weight of 0 indicates polling is disabled.
 - *
 - * Return: The size of the ASCII string returned in @buf.
 - */
 -static ssize_t irqpoll_weight_show(struct device *dev,
 -				   struct device_attribute *attr, char *buf)
 -{
 -	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
 +	struct Scsi_Host *shost = class_to_shost(dev);
 +	struct cxlflash_cfg *cfg = (struct cxlflash_cfg *)shost->hostdata;
  	struct afu *afu = cfg->afu;
  
++<<<<<<< HEAD
 +	return cxlflash_show_port_lun_table(1, afu, buf);
++=======
+ 	return scnprintf(buf, PAGE_SIZE, "%u\n", afu->irqpoll_weight);
+ }
+ 
+ /**
+  * irqpoll_weight_store() - sets the current IRQ poll weight for the host
+  * @dev:	Generic device associated with the host.
+  * @attr:	Device attribute representing the IRQ poll weight.
+  * @buf:	Buffer of length PAGE_SIZE containing the desired IRQ poll
+  *		weight in ASCII.
+  * @count:	Length of data resizing in @buf.
+  *
+  * An IRQ poll weight of 0 indicates polling is disabled.
+  *
+  * Return: The size of the ASCII string returned in @buf.
+  */
+ static ssize_t irqpoll_weight_store(struct device *dev,
+ 				    struct device_attribute *attr,
+ 				    const char *buf, size_t count)
+ {
+ 	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
+ 	struct device *cfgdev = &cfg->dev->dev;
+ 	struct afu *afu = cfg->afu;
+ 	struct hwq *hwq;
+ 	u32 weight;
+ 	int rc, i;
+ 
+ 	rc = kstrtouint(buf, 10, &weight);
+ 	if (rc)
+ 		return -EINVAL;
+ 
+ 	if (weight > 256) {
+ 		dev_info(cfgdev,
+ 			 "Invalid IRQ poll weight. It must be 256 or less.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (weight == afu->irqpoll_weight) {
+ 		dev_info(cfgdev,
+ 			 "Current IRQ poll weight has the same weight.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (afu_is_irqpoll_enabled(afu)) {
+ 		for (i = 0; i < afu->num_hwqs; i++) {
+ 			hwq = get_hwq(afu, i);
+ 
+ 			irq_poll_disable(&hwq->irqpoll);
+ 		}
+ 	}
+ 
+ 	afu->irqpoll_weight = weight;
+ 
+ 	if (weight > 0) {
+ 		for (i = 0; i < afu->num_hwqs; i++) {
+ 			hwq = get_hwq(afu, i);
+ 
+ 			irq_poll_init(&hwq->irqpoll, weight, cxlflash_irqpoll);
+ 		}
+ 	}
+ 
+ 	return count;
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
+ }
+ 
+ /**
+  * num_hwqs_show() - presents the number of hardware queues for the host
+  * @dev:	Generic device associated with the host.
+  * @attr:	Device attribute representing the number of hardware queues.
+  * @buf:	Buffer of length PAGE_SIZE to report back the number of hardware
+  *		queues in ASCII.
+  *
+  * Return: The size of the ASCII string returned in @buf.
+  */
+ static ssize_t num_hwqs_show(struct device *dev,
+ 			     struct device_attribute *attr, char *buf)
+ {
+ 	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
+ 	struct afu *afu = cfg->afu;
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%u\n", afu->num_hwqs);
+ }
+ 
+ /**
+  * num_hwqs_store() - sets the number of hardware queues for the host
+  * @dev:	Generic device associated with the host.
+  * @attr:	Device attribute representing the number of hardware queues.
+  * @buf:	Buffer of length PAGE_SIZE containing the number of hardware
+  *		queues in ASCII.
+  * @count:	Length of data resizing in @buf.
+  *
+  * n > 0: num_hwqs = n
+  * n = 0: num_hwqs = num_online_cpus()
+  * n < 0: num_online_cpus() / abs(n)
+  *
+  * Return: The size of the ASCII string returned in @buf.
+  */
+ static ssize_t num_hwqs_store(struct device *dev,
+ 			      struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+ 	struct cxlflash_cfg *cfg = shost_priv(class_to_shost(dev));
+ 	struct afu *afu = cfg->afu;
+ 	int rc;
+ 	int nhwqs, num_hwqs;
+ 
+ 	rc = kstrtoint(buf, 10, &nhwqs);
+ 	if (rc)
+ 		return -EINVAL;
+ 
+ 	if (nhwqs >= 1)
+ 		num_hwqs = nhwqs;
+ 	else if (nhwqs == 0)
+ 		num_hwqs = num_online_cpus();
+ 	else
+ 		num_hwqs = num_online_cpus() / abs(nhwqs);
+ 
+ 	afu->desired_hwqs = min(num_hwqs, CXLFLASH_MAX_HWQS);
+ 	WARN_ON_ONCE(afu->desired_hwqs == 0);
+ 
+ retry:
+ 	switch (cfg->state) {
+ 	case STATE_NORMAL:
+ 		cfg->state = STATE_RESET;
+ 		drain_ioctls(cfg);
+ 		cxlflash_mark_contexts_error(cfg);
+ 		rc = afu_reset(cfg);
+ 		if (rc)
+ 			cfg->state = STATE_FAILTERM;
+ 		else
+ 			cfg->state = STATE_NORMAL;
+ 		wake_up_all(&cfg->reset_waitq);
+ 		break;
+ 	case STATE_RESET:
+ 		wait_event(cfg->reset_waitq, cfg->state != STATE_RESET);
+ 		if (cfg->state == STATE_NORMAL)
+ 			goto retry;
+ 	default:
+ 		/* Ideally should not happen */
+ 		dev_err(dev, "%s: Device is not ready, state=%d\n",
+ 			__func__, cfg->state);
+ 		break;
+ 	}
+ 
+ 	return count;
  }
  
  /**
@@@ -2263,6 -2682,10 +2500,13 @@@ static DEVICE_ATTR_RW(lun_mode)
  static DEVICE_ATTR_RO(ioctl_version);
  static DEVICE_ATTR_RO(port0_lun_table);
  static DEVICE_ATTR_RO(port1_lun_table);
++<<<<<<< HEAD
++=======
+ static DEVICE_ATTR_RO(port2_lun_table);
+ static DEVICE_ATTR_RO(port3_lun_table);
+ static DEVICE_ATTR_RW(irqpoll_weight);
+ static DEVICE_ATTR_RW(num_hwqs);
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  
  static struct device_attribute *cxlflash_host_attrs[] = {
  	&dev_attr_port0,
@@@ -2271,6 -2696,10 +2515,13 @@@
  	&dev_attr_ioctl_version,
  	&dev_attr_port0_lun_table,
  	&dev_attr_port1_lun_table,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_port2_lun_table,
+ 	&dev_attr_port3_lun_table,
+ 	&dev_attr_irqpoll_weight,
+ 	&dev_attr_num_hwqs,
++>>>>>>> 3065267a80c8 (scsi: cxlflash: Add hardware queues attribute)
  	NULL
  };
  
* Unmerged path drivers/scsi/cxlflash/common.h
* Unmerged path drivers/scsi/cxlflash/main.c
