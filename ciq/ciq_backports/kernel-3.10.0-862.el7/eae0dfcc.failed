powerpc/fadump: avoid holes in boot memory area when fadump is registered

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [powerpc] fadump: avoid holes in boot memory area when fadump is registered (Pingfan Liu) [1438695]
Rebuild_FUZZ: 94.20%
commit-author Hari Bathini <hbathini@linux.vnet.ibm.com>
commit eae0dfcc44320c79a05637534d59af4643b2ee7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/eae0dfcc.failed

To register fadump, boot memory area - the size of low memory chunk that
is required for a kernel to boot successfully when booted with restricted
memory, is assumed to have no holes. But this memory area is currently
not protected from hot-remove operations. So, fadump could fail to
re-register after a memory hot-remove operation, if memory is removed
from boot memory area. To avoid this, ensure that memory from boot
memory area is not hot-removed when fadump is registered.

	Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
	Reviewed-by: Mahesh J Salgaonkar <mahesh@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit eae0dfcc44320c79a05637534d59af4643b2ee7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/fadump.c
diff --cc arch/powerpc/kernel/fadump.c
index f3425d4ba1e8,750bff3b4af3..000000000000
--- a/arch/powerpc/kernel/fadump.c
+++ b/arch/powerpc/kernel/fadump.c
@@@ -114,9 -113,16 +114,22 @@@ int __init early_init_dt_scan_fw_dump(u
  	return 1;
  }
  
++<<<<<<< HEAD
 +int is_fadump_enabled(void)
 +{
 +	return fw_dump.fadump_enabled;
++=======
+ /*
+  * If fadump is registered, check if the memory provided
+  * falls within boot memory area.
+  */
+ int is_fadump_boot_memory_area(u64 addr, ulong size)
+ {
+ 	if (!fw_dump.dump_registered)
+ 		return 0;
+ 
+ 	return (addr + size) > RMA_START && addr <= fw_dump.boot_memory_size;
++>>>>>>> eae0dfcc4432 (powerpc/fadump: avoid holes in boot memory area when fadump is registered)
  }
  
  int is_fadump_active(void)
diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 6521ae7099b8..4bd8d731c560 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -204,6 +204,7 @@ struct fad_crash_memory_ranges {
 	unsigned long long	size;
 };
 
+extern int is_fadump_boot_memory_area(u64 addr, ulong size);
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);
 extern int fadump_reserve_mem(void);
* Unmerged path arch/powerpc/kernel/fadump.c
diff --git a/arch/powerpc/platforms/pseries/hotplug-memory.c b/arch/powerpc/platforms/pseries/hotplug-memory.c
index 00d51919f554..9770fecbe4a2 100644
--- a/arch/powerpc/platforms/pseries/hotplug-memory.c
+++ b/arch/powerpc/platforms/pseries/hotplug-memory.c
@@ -22,6 +22,7 @@
 #include <asm/machdep.h>
 #include <asm/prom.h>
 #include <asm/sparsemem.h>
+#include <asm/fadump.h>
 #include "pseries.h"
 
 static bool rtas_hp_event;
@@ -406,6 +407,12 @@ static bool lmb_is_removable(struct of_drconf_cell *lmb)
 	scns_per_block = block_sz / MIN_MEMORY_BLOCK_SIZE;
 	phys_addr = lmb->base_addr;
 
+#ifdef CONFIG_FA_DUMP
+	/* Don't hot-remove memory that falls in fadump boot memory area */
+	if (is_fadump_boot_memory_area(phys_addr, block_sz))
+		return false;
+#endif
+
 	for (i = 0; i < scns_per_block; i++) {
 		pfn = PFN_DOWN(phys_addr);
 		if (!pfn_present(pfn))
