nfp: eliminate an if statement in calculation of completed frames

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 730b3ab54af4f816cdf541a23c879c9379a480db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/730b3ab5.failed

Given that our rings are always a power of 2, we can simplify the
calculation of number of completed TX descriptors by using masking
instead of if statement based on whether the index have wrapped
or not.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 730b3ab54af4f816cdf541a23c879c9379a480db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,da83e17b8b20..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -908,14 -940,10 +908,11 @@@ static void nfp_net_tx_complete(struct 
  	if (qcp_rd_p == tx_ring->qcp_rd_p)
  		return;
  
- 	if (qcp_rd_p > tx_ring->qcp_rd_p)
- 		todo = qcp_rd_p - tx_ring->qcp_rd_p;
- 	else
- 		todo = qcp_rd_p + tx_ring->cnt - tx_ring->qcp_rd_p;
+ 	todo = D_IDX(tx_ring, qcp_rd_p + tx_ring->cnt - tx_ring->qcp_rd_p);
  
  	while (todo--) {
 -		idx = D_IDX(tx_ring, tx_ring->rd_p++);
 +		idx = tx_ring->rd_p & (tx_ring->cnt - 1);
 +		tx_ring->rd_p++;
  
  		skb = tx_ring->txbufs[idx].skb;
  		if (!skb)
@@@ -971,9 -997,50 +968,53 @@@
  		  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);
  }
  
++<<<<<<< HEAD
++=======
+ static bool nfp_net_xdp_complete(struct nfp_net_tx_ring *tx_ring)
+ {
+ 	struct nfp_net_r_vector *r_vec = tx_ring->r_vec;
+ 	u32 done_pkts = 0, done_bytes = 0;
+ 	bool done_all;
+ 	int idx, todo;
+ 	u32 qcp_rd_p;
+ 
+ 	/* Work out how many descriptors have been transmitted */
+ 	qcp_rd_p = nfp_qcp_rd_ptr_read(tx_ring->qcp_q);
+ 
+ 	if (qcp_rd_p == tx_ring->qcp_rd_p)
+ 		return true;
+ 
+ 	todo = D_IDX(tx_ring, qcp_rd_p + tx_ring->cnt - tx_ring->qcp_rd_p);
+ 
+ 	done_all = todo <= NFP_NET_XDP_MAX_COMPLETE;
+ 	todo = min(todo, NFP_NET_XDP_MAX_COMPLETE);
+ 
+ 	tx_ring->qcp_rd_p = D_IDX(tx_ring, tx_ring->qcp_rd_p + todo);
+ 
+ 	done_pkts = todo;
+ 	while (todo--) {
+ 		idx = D_IDX(tx_ring, tx_ring->rd_p);
+ 		tx_ring->rd_p++;
+ 
+ 		done_bytes += tx_ring->txbufs[idx].real_len;
+ 	}
+ 
+ 	u64_stats_update_begin(&r_vec->tx_sync);
+ 	r_vec->tx_bytes += done_bytes;
+ 	r_vec->tx_pkts += done_pkts;
+ 	u64_stats_update_end(&r_vec->tx_sync);
+ 
+ 	WARN_ONCE(tx_ring->wr_p - tx_ring->rd_p > tx_ring->cnt,
+ 		  "XDP TX ring corruption rd_p=%u wr_p=%u cnt=%u\n",
+ 		  tx_ring->rd_p, tx_ring->wr_p, tx_ring->cnt);
+ 
+ 	return done_all;
+ }
+ 
++>>>>>>> 730b3ab54af4 (nfp: eliminate an if statement in calculation of completed frames)
  /**
   * nfp_net_tx_ring_reset() - Free any untransmitted buffers and reset pointers
 - * @dp:		NFP Net data path struct
 + * @nn:		NFP Net device
   * @tx_ring:	TX ring structure
   *
   * Assumes that the device is stopped
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
