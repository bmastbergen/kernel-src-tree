netfilter: ipset: move registration message to init from net_init

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ilia Mirkin <imirkin@alum.mit.edu>
commit 6843bc3c568128e8771ba35cfefe95b7ec1c93a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6843bc3c.failed

Commit 1785e8f473 ("netfiler: ipset: Add net namespace for ipset") moved
the initialization print into net_init, which can get called a lot due
to namespaces. Move it back into init, reduce to pr_info.

	Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 6843bc3c568128e8771ba35cfefe95b7ec1c93a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_core.c
diff --cc net/netfilter/ipset/ip_set_core.c
index 98b197a78f1a,636cb8df5354..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -1801,6 -1930,50 +1801,53 @@@ static struct nf_sockopt_ops so_set __r
  	.owner		= THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ static int __net_init
+ ip_set_net_init(struct net *net)
+ {
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 	struct ip_set **list;
+ 
+ 	inst->ip_set_max = max_sets ? max_sets : CONFIG_IP_SET_MAX;
+ 	if (inst->ip_set_max >= IPSET_INVALID_ID)
+ 		inst->ip_set_max = IPSET_INVALID_ID - 1;
+ 
+ 	list = kzalloc(sizeof(struct ip_set *) * inst->ip_set_max, GFP_KERNEL);
+ 	if (!list)
+ 		return -ENOMEM;
+ 	inst->is_deleted = 0;
+ 	rcu_assign_pointer(inst->ip_set_list, list);
+ 	return 0;
+ }
+ 
+ static void __net_exit
+ ip_set_net_exit(struct net *net)
+ {
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 
+ 	struct ip_set *set = NULL;
+ 	ip_set_id_t i;
+ 
+ 	inst->is_deleted = 1; /* flag for ip_set_nfnl_put */
+ 
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		set = ip_set(inst, i);
+ 		if (set != NULL)
+ 			ip_set_destroy_set(inst, i);
+ 	}
+ 	kfree(rcu_dereference_protected(inst->ip_set_list, 1));
+ }
+ 
+ static struct pernet_operations ip_set_net_ops = {
+ 	.init	= ip_set_net_init,
+ 	.exit   = ip_set_net_exit,
+ 	.id	= &ip_set_net_id,
+ 	.size	= sizeof(struct ip_set_net)
+ };
+ 
+ 
++>>>>>>> 6843bc3c5681 (netfilter: ipset: move registration message to init from net_init)
  static int __init
  ip_set_init(void)
  {
@@@ -1827,11 -1986,16 +1874,22 @@@
  	if (ret != 0) {
  		pr_err("SO_SET registry failed: %d\n", ret);
  		nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
 +		kfree(list);
  		return ret;
  	}
++<<<<<<< HEAD
 +
 +	pr_notice("ip_set: protocol %u\n", IPSET_PROTOCOL);
++=======
+ 	ret = register_pernet_subsys(&ip_set_net_ops);
+ 	if (ret) {
+ 		pr_err("ip_set: cannot register pernet_subsys.\n");
+ 		nf_unregister_sockopt(&so_set);
+ 		nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
+ 		return ret;
+ 	}
+ 	pr_info("ip_set: protocol %u\n", IPSET_PROTOCOL);
++>>>>>>> 6843bc3c5681 (netfilter: ipset: move registration message to init from net_init)
  	return 0;
  }
  
* Unmerged path net/netfilter/ipset/ip_set_core.c
