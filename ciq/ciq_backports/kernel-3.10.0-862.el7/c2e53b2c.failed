IB/mlx5: Add support for QP with a given source QPN

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yishai Hadas <yishaih@mellanox.com>
commit c2e53b2ce1ba351918ede492c0cb207f42e1228f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c2e53b2c.failed

Allow user space applications to accelerate send and receive
traffic which is typically handled by IPoIB ULP by creating
a UD QP with a given source QPN of the IPoIB UD QP.

UD QP with a given source QPN should basically be similar to
RAW QP from point of view of its created resources.

However,
- Its TIS should point to the source QPN.
- Modify can be done only on its state as the transport attributes
  are managed by its source QP.

This patch manages below:
- Creating/destroying/modifying UD QP with a given source QPN.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit c2e53b2ce1ba351918ede492c0cb207f42e1228f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 50a7f77d9dee,5c7ce9bd466e..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -1527,13 -1512,6 +1533,16 @@@ static int create_qp_common(struct mlx5
  	u32 *in;
  	int err;
  
++<<<<<<< HEAD
 +	base = init_attr->qp_type == IB_QPT_RAW_PACKET ?
 +	       &qp->raw_packet_qp.rq.base :
 +	       &qp->trans_qp.base;
 +
 +	if (init_attr->qp_type != IB_QPT_RAW_PACKET)
 +		mlx5_ib_odp_create_qp(qp);
 +
++=======
++>>>>>>> c2e53b2ce1ba (IB/mlx5: Add support for QP with a given source QPN)
  	mutex_init(&qp->mutex);
  	spin_lock_init(&qp->sq.lock);
  	spin_lock_init(&qp->rq.lock);
@@@ -1935,8 -1933,8 +1964,13 @@@ static void destroy_qp_common(struct ml
  	       &qp->trans_qp.base;
  
  	if (qp->state != IB_QPS_RESET) {
++<<<<<<< HEAD
 +		if (qp->ibqp.qp_type != IB_QPT_RAW_PACKET) {
 +			mlx5_ib_qp_disable_pagefaults(qp);
++=======
+ 		if (qp->ibqp.qp_type != IB_QPT_RAW_PACKET &&
+ 		    !(qp->flags & MLX5_IB_QP_UNDERLAY)) {
++>>>>>>> c2e53b2ce1ba (IB/mlx5: Add support for QP with a given source QPN)
  			err = mlx5_core_qp_modify(dev->mdev,
  						  MLX5_CMD_OP_2RST_QP, 0,
  						  NULL, &base->mqp);
@@@ -2826,9 -2828,14 +2862,14 @@@ static int __mlx5_ib_modify_qp(struct i
  	if (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {
  		u8 port_num = (attr_mask & IB_QP_PORT ? attr->port_num :
  			       qp->port) - 1;
+ 
+ 		/* Underlay port should be used - index 0 function per port */
+ 		if (qp->flags & MLX5_IB_QP_UNDERLAY)
+ 			port_num = 0;
+ 
  		mibport = &dev->port[port_num];
  		context->qp_counter_set_usr_page |=
 -			cpu_to_be32((u32)(mibport->cnts.set_id) << 24);
 +			cpu_to_be32((u32)(mibport->q_cnt_id) << 24);
  	}
  
  	if (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)
@@@ -4560,13 -4518,9 +4608,19 @@@ int mlx5_ib_query_qp(struct ib_qp *ibqp
  		return mlx5_ib_gsi_query_qp(ibqp, qp_attr, qp_attr_mask,
  					    qp_init_attr);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
 +	/*
 +	 * Wait for any outstanding page faults, in case the user frees memory
 +	 * based upon this query's result.
 +	 */
 +	flush_workqueue(mlx5_ib_page_fault_wq);
 +#endif
++=======
+ 	/* Not all of output fields are applicable, make sure to zero them */
+ 	memset(qp_init_attr, 0, sizeof(*qp_init_attr));
+ 	memset(qp_attr, 0, sizeof(*qp_attr));
++>>>>>>> c2e53b2ce1ba (IB/mlx5: Add support for QP with a given source QPN)
  
  	mutex_lock(&qp->mutex);
  
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index 83418c5208ab..23bb0f99ac66 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -397,6 +397,7 @@ struct mlx5_ib_qp {
 	struct list_head	cq_recv_list;
 	struct list_head	cq_send_list;
 	u32			rate_limit;
+	u32                     underlay_qpn;
 };
 
 struct mlx5_ib_cq_buf {
@@ -418,6 +419,7 @@ enum mlx5_ib_qp_flags {
 	MLX5_IB_QP_CAP_SCATTER_FCS		= 1 << 7,
 	MLX5_IB_QP_RSS				= 1 << 8,
 	MLX5_IB_QP_CVLAN_STRIPPING		= 1 << 9,
+	MLX5_IB_QP_UNDERLAY			= 1 << 10,
 };
 
 struct mlx5_umr_wr {
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
