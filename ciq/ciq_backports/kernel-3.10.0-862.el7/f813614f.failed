ibmvnic: Wait for device response when changing MAC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
commit f813614f531114db796ad66ced75c5dc8db7aa3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f813614f.failed

Wait for a response from the VNIC server before exiting after setting
the MAC address. The resolves an issue with bonding a VNIC client in
ALB or TLB modes. The bonding driver was changing the MAC address more
rapidly than the device could respond, causing the following errors.

"bond0: the hw address of slave eth2 is in use by the bond;
couldn't find a slave with a free hw address to give it
(this should not have happened)"

If the function waits until the change is finalized, these errors are
avoided.

	Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f813614f531114db796ad66ced75c5dc8db7aa3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 569bb2b68f4b,8c3058d5d191..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -974,39 -1529,270 +974,57 @@@ static void ibmvnic_set_multi(struct ne
  				crq.multicast_ctrl.flags = IBMVNIC_ENABLE_MC;
  				ether_addr_copy(&crq.multicast_ctrl.mac_addr[0],
  						ha->addr);
 -				ibmvnic_send_crq(adapter, &crq);
 -			}
 -		}
 -	}
 -}
 -
 -static int __ibmvnic_set_mac(struct net_device *netdev, struct sockaddr *p)
 -{
 -	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
 -	struct sockaddr *addr = p;
 -	union ibmvnic_crq crq;
 -
 -	if (!is_valid_ether_addr(addr->sa_data))
 -		return -EADDRNOTAVAIL;
 -
 -	memset(&crq, 0, sizeof(crq));
 -	crq.change_mac_addr.first = IBMVNIC_CRQ_CMD;
 -	crq.change_mac_addr.cmd = CHANGE_MAC_ADDR;
 -	ether_addr_copy(&crq.change_mac_addr.mac_addr[0], addr->sa_data);
 -
 -	init_completion(&adapter->fw_done);
 -	ibmvnic_send_crq(adapter, &crq);
 -	wait_for_completion(&adapter->fw_done);
 -	/* netdev->dev_addr is changed in handle_change_mac_rsp function */
 -	return adapter->fw_done_rc ? -EIO : 0;
 -}
 -
 -static int ibmvnic_set_mac(struct net_device *netdev, void *p)
 -{
 -	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
 -	struct sockaddr *addr = p;
 -	int rc;
 -
 -	if (adapter->state == VNIC_PROBED) {
 -		memcpy(&adapter->desired.mac, addr, sizeof(struct sockaddr));
 -		adapter->mac_change_pending = true;
 -		return 0;
 -	}
 -
 -	rc = __ibmvnic_set_mac(netdev, addr);
 -
 -	return rc;
 -}
 -
 -/**
 - * do_reset returns zero if we are able to keep processing reset events, or
 - * non-zero if we hit a fatal error and must halt.
 - */
 -static int do_reset(struct ibmvnic_adapter *adapter,
 -		    struct ibmvnic_rwi *rwi, u32 reset_state)
 -{
 -	u64 old_num_rx_queues, old_num_tx_queues;
 -	struct net_device *netdev = adapter->netdev;
 -	int i, rc;
 -
 -	netdev_dbg(adapter->netdev, "Re-setting driver (%d)\n",
 -		   rwi->reset_reason);
 -
 -	netif_carrier_off(netdev);
 -	adapter->reset_reason = rwi->reset_reason;
 -
 -	old_num_rx_queues = adapter->req_rx_queues;
 -	old_num_tx_queues = adapter->req_tx_queues;
 -
 -	if (rwi->reset_reason == VNIC_RESET_MOBILITY) {
 -		rc = ibmvnic_reenable_crq_queue(adapter);
 -		if (rc)
 -			return 0;
 -	}
 -
 -	rc = __ibmvnic_close(netdev);
 -	if (rc)
 -		return rc;
 -
 -	if (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM ||
 -	    adapter->wait_for_reset) {
 -		release_resources(adapter);
 -		release_sub_crqs(adapter);
 -		release_crq_queue(adapter);
 -	}
 -
 -	if (adapter->reset_reason != VNIC_RESET_NON_FATAL) {
 -		/* remove the closed state so when we call open it appears
 -		 * we are coming from the probed state.
 -		 */
 -		adapter->state = VNIC_PROBED;
 -
 -		rc = ibmvnic_init(adapter);
 -		if (rc)
 -			return IBMVNIC_INIT_FAILED;
 -
 -		/* If the adapter was in PROBE state prior to the reset,
 -		 * exit here.
 -		 */
 -		if (reset_state == VNIC_PROBED)
 -			return 0;
 -
 -		rc = ibmvnic_login(netdev);
 -		if (rc) {
 -			adapter->state = VNIC_PROBED;
 -			return 0;
 -		}
 -
 -		if (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM ||
 -		    adapter->wait_for_reset) {
 -			rc = init_resources(adapter);
 -			if (rc)
 -				return rc;
 -		} else if (adapter->req_rx_queues != old_num_rx_queues ||
 -			   adapter->req_tx_queues != old_num_tx_queues) {
 -			release_rx_pools(adapter);
 -			release_tx_pools(adapter);
 -			init_rx_pools(netdev);
 -			init_tx_pools(netdev);
 -		} else {
 -			rc = reset_tx_pools(adapter);
 -			if (rc)
 -				return rc;
 -
 -			rc = reset_rx_pools(adapter);
 -			if (rc)
 -				return rc;
 -
 -			if (reset_state == VNIC_CLOSED)
 -				return 0;
 +				ibmvnic_send_crq(adapter, &crq);
 +			}
  		}
  	}
 -
 -	rc = __ibmvnic_open(netdev);
 -	if (rc) {
 -		if (list_empty(&adapter->rwi_list))
 -			adapter->state = VNIC_CLOSED;
 -		else
 -			adapter->state = reset_state;
 -
 -		return 0;
 -	}
 -
 -	netif_carrier_on(netdev);
 -
 -	/* kick napi */
 -	for (i = 0; i < adapter->req_rx_queues; i++)
 -		napi_schedule(&adapter->napi[i]);
 -
 -	if (adapter->reset_reason != VNIC_RESET_FAILOVER)
 -		netdev_notify_peers(netdev);
 -
 -	return 0;
 -}
 -
 -static struct ibmvnic_rwi *get_next_rwi(struct ibmvnic_adapter *adapter)
 -{
 -	struct ibmvnic_rwi *rwi;
 -
 -	mutex_lock(&adapter->rwi_lock);
 -
 -	if (!list_empty(&adapter->rwi_list)) {
 -		rwi = list_first_entry(&adapter->rwi_list, struct ibmvnic_rwi,
 -				       list);
 -		list_del(&rwi->list);
 -	} else {
 -		rwi = NULL;
 -	}
 -
 -	mutex_unlock(&adapter->rwi_lock);
 -	return rwi;
 -}
 -
 -static void free_all_rwi(struct ibmvnic_adapter *adapter)
 -{
 -	struct ibmvnic_rwi *rwi;
 -
 -	rwi = get_next_rwi(adapter);
 -	while (rwi) {
 -		kfree(rwi);
 -		rwi = get_next_rwi(adapter);
 -	}
  }
  
 -static void __ibmvnic_reset(struct work_struct *work)
 +static int ibmvnic_set_mac(struct net_device *netdev, void *p)
  {
 -	struct ibmvnic_rwi *rwi;
 -	struct ibmvnic_adapter *adapter;
 -	struct net_device *netdev;
 -	u32 reset_state;
 -	int rc = 0;
 -
 -	adapter = container_of(work, struct ibmvnic_adapter, ibmvnic_reset);
 -	netdev = adapter->netdev;
 -
 -	mutex_lock(&adapter->reset_lock);
 -	adapter->resetting = true;
 -	reset_state = adapter->state;
 -
 -	rwi = get_next_rwi(adapter);
 -	while (rwi) {
 -		rc = do_reset(adapter, rwi, reset_state);
 -		kfree(rwi);
 -		if (rc && rc != IBMVNIC_INIT_FAILED)
 -			break;
 -
 -		rwi = get_next_rwi(adapter);
 -	}
 +	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
 +	struct sockaddr *addr = p;
 +	union ibmvnic_crq crq;
  
 -	if (adapter->wait_for_reset) {
 -		adapter->wait_for_reset = false;
 -		adapter->reset_done_rc = rc;
 -		complete(&adapter->reset_done);
 -	}
 +	if (!is_valid_ether_addr(addr->sa_data))
 +		return -EADDRNOTAVAIL;
  
 -	if (rc) {
 -		netdev_dbg(adapter->netdev, "Reset failed\n");
 -		free_all_rwi(adapter);
 -		mutex_unlock(&adapter->reset_lock);
 -		return;
 -	}
 +	memset(&crq, 0, sizeof(crq));
 +	crq.change_mac_addr.first = IBMVNIC_CRQ_CMD;
 +	crq.change_mac_addr.cmd = CHANGE_MAC_ADDR;
 +	ether_addr_copy(&crq.change_mac_addr.mac_addr[0], addr->sa_data);
+ 
 -	adapter->resetting = false;
 -	mutex_unlock(&adapter->reset_lock);
++	init_completion(&adapter->fw_done);
 +	ibmvnic_send_crq(adapter, &crq);
++	wait_for_completion(&adapter->fw_done);
 +	/* netdev->dev_addr is changed in handle_change_mac_rsp function */
- 	return 0;
++	return adapter->fw_done_rc ? -EIO : 0;
  }
  
 -static void ibmvnic_reset(struct ibmvnic_adapter *adapter,
 -			  enum ibmvnic_reset_reason reason)
 +static int ibmvnic_change_mtu(struct net_device *netdev, int new_mtu)
  {
 -	struct ibmvnic_rwi *rwi, *tmp;
 -	struct net_device *netdev = adapter->netdev;
 -	struct list_head *entry;
 -
 -	if (adapter->state == VNIC_REMOVING ||
 -	    adapter->state == VNIC_REMOVED) {
 -		netdev_dbg(netdev, "Adapter removing, skipping reset\n");
 -		return;
 -	}
 -
 -	if (adapter->state == VNIC_PROBING) {
 -		netdev_warn(netdev, "Adapter reset during probe\n");
 -		adapter->init_done_rc = EAGAIN;
 -		return;
 -	}
 +	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
++<<<<<<< HEAD
  
 -	mutex_lock(&adapter->rwi_lock);
 +	if (new_mtu > adapter->req_mtu || new_mtu < adapter->min_mtu)
 +		return -EINVAL;
  
 -	list_for_each(entry, &adapter->rwi_list) {
 -		tmp = list_entry(entry, struct ibmvnic_rwi, list);
 -		if (tmp->reset_reason == reason) {
 -			netdev_dbg(netdev, "Skipping matching reset\n");
 -			mutex_unlock(&adapter->rwi_lock);
 -			return;
 -		}
 -	}
 +	netdev->mtu = new_mtu;
 +	return 0;
++=======
++	struct sockaddr *addr = p;
++	int rc;
+ 
 -	rwi = kzalloc(sizeof(*rwi), GFP_KERNEL);
 -	if (!rwi) {
 -		mutex_unlock(&adapter->rwi_lock);
 -		ibmvnic_close(netdev);
 -		return;
++	if (adapter->state == VNIC_PROBED) {
++		memcpy(&adapter->desired.mac, addr, sizeof(struct sockaddr));
++		adapter->mac_change_pending = true;
++		return 0;
+ 	}
+ 
 -	rwi->reset_reason = reason;
 -	list_add_tail(&rwi->list, &adapter->rwi_list);
 -	mutex_unlock(&adapter->rwi_lock);
++	rc = __ibmvnic_set_mac(netdev, addr);
+ 
 -	netdev_dbg(adapter->netdev, "Scheduling reset (reason %d)\n", reason);
 -	schedule_work(&adapter->ibmvnic_reset);
++	return rc;
++>>>>>>> f813614f5311 (ibmvnic: Wait for device response when changing MAC)
  }
  
  static void ibmvnic_tx_timeout(struct net_device *dev)
@@@ -2536,40 -3517,64 +2554,40 @@@ static void handle_error_indication(uni
  		return;
  	}
  
 -	error_buff->len = detail_len;
 -	error_buff->error_id = err_crq->error_indication.error_id;
 -
 -	spin_lock_irqsave(&adapter->error_list_lock, flags);
 -	list_add_tail(&error_buff->list, &adapter->errors);
 -	spin_unlock_irqrestore(&adapter->error_list_lock, flags);
 -
 -	memset(&crq, 0, sizeof(crq));
 -	crq.request_error_info.first = IBMVNIC_CRQ_CMD;
 -	crq.request_error_info.cmd = REQUEST_ERROR_INFO;
 -	crq.request_error_info.ioba = cpu_to_be32(error_buff->dma);
 -	crq.request_error_info.len = cpu_to_be32(detail_len);
 -	crq.request_error_info.error_id = err_crq->error_indication.error_id;
 -
 -	rc = ibmvnic_send_crq(adapter, &crq);
 -	if (rc) {
 -		netdev_err(netdev, "failed to request error information\n");
 -		goto err_info_fail;
 -	}
 -
 -	if (!wait_for_completion_timeout(&adapter->init_done, timeout)) {
 -		netdev_err(netdev, "timeout waiting for error information\n");
 -		goto err_info_fail;
 +	inflight_cmd = kmalloc(sizeof(*inflight_cmd), GFP_ATOMIC);
 +	if (!inflight_cmd) {
 +		dma_unmap_single(dev, error_buff->dma, detail_len,
 +				 DMA_FROM_DEVICE);
 +		kfree(error_buff->buff);
 +		kfree(error_buff);
 +		return;
  	}
  
 -	return;
 +	error_buff->len = detail_len;
 +	error_buff->error_id = crq->error_indication.error_id;
  
 -err_info_fail:
  	spin_lock_irqsave(&adapter->error_list_lock, flags);
 -	list_del(&error_buff->list);
 +	list_add_tail(&error_buff->list, &adapter->errors);
  	spin_unlock_irqrestore(&adapter->error_list_lock, flags);
  
 -	kfree(error_buff->buff);
 -	kfree(error_buff);
 -}
 -
 -static void handle_error_indication(union ibmvnic_crq *crq,
 -				    struct ibmvnic_adapter *adapter)
 -{
 -	struct device *dev = &adapter->vdev->dev;
 +	memset(&new_crq, 0, sizeof(new_crq));
 +	new_crq.request_error_info.first = IBMVNIC_CRQ_CMD;
 +	new_crq.request_error_info.cmd = REQUEST_ERROR_INFO;
 +	new_crq.request_error_info.ioba = cpu_to_be32(error_buff->dma);
 +	new_crq.request_error_info.len = cpu_to_be32(detail_len);
 +	new_crq.request_error_info.error_id = crq->error_indication.error_id;
  
 -	dev_err(dev, "Firmware reports %serror id %x, cause %d\n",
 -		crq->error_indication.flags
 -			& IBMVNIC_FATAL_ERROR ? "FATAL " : "",
 -		be32_to_cpu(crq->error_indication.error_id),
 -		be16_to_cpu(crq->error_indication.error_cause));
 +	memcpy(&inflight_cmd->crq, &crq, sizeof(crq));
  
 -	if (be32_to_cpu(crq->error_indication.error_id))
 -		request_error_information(adapter, crq);
 +	spin_lock_irqsave(&adapter->inflight_lock, flags);
 +	list_add_tail(&inflight_cmd->list, &adapter->inflight);
 +	spin_unlock_irqrestore(&adapter->inflight_lock, flags);
  
 -	if (crq->error_indication.flags & IBMVNIC_FATAL_ERROR)
 -		ibmvnic_reset(adapter, VNIC_RESET_FATAL);
 -	else
 -		ibmvnic_reset(adapter, VNIC_RESET_NON_FATAL);
 +	ibmvnic_send_crq(adapter, &new_crq);
  }
  
- static void handle_change_mac_rsp(union ibmvnic_crq *crq,
- 				  struct ibmvnic_adapter *adapter)
+ static int handle_change_mac_rsp(union ibmvnic_crq *crq,
+ 				 struct ibmvnic_adapter *adapter)
  {
  	struct net_device *netdev = adapter->netdev;
  	struct device *dev = &adapter->vdev->dev;
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
