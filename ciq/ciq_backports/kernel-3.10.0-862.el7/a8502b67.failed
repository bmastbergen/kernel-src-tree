x86/pkeys: Make mprotect_key() mask off additional vm_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit a8502b67d739c1d7a4542c1da0a5d98a6a58c177
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a8502b67.failed

Today, mprotect() takes 4 bits of data: PROT_READ/WRITE/EXEC/NONE.
Three of those bits: READ/WRITE/EXEC get translated directly in to
vma->vm_flags by calc_vm_prot_bits().  If a bit is unset in
mprotect()'s 'prot' argument then it must be cleared in vma->vm_flags
during the mprotect() call.

We do this clearing today by first calculating the VMA flags we
want set, then clearing the ones we do not want to inherit from
the original VMA:

	vm_flags = calc_vm_prot_bits(prot, key);
	...
	newflags = vm_flags;
	newflags |= (vma->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));

However, we *also* want to mask off the original VMA's vm_flags in
which we store the protection key.

To do that, this patch adds a new macro:

	ARCH_VM_PKEY_FLAGS

which allows the architecture to specify additional bits that it would
like cleared.  We use that to ensure that the VM_PKEY_BIT* bits get
cleared.

	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Acked-by: Mel Gorman <mgorman@techsingularity.net>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-arch@vger.kernel.org
	Cc: Dave Hansen <dave@sr71.net>
	Cc: arnd@arndb.de
	Cc: linux-api@vger.kernel.org
	Cc: linux-mm@kvack.org
	Cc: luto@kernel.org
	Cc: akpm@linux-foundation.org
	Cc: torvalds@linux-foundation.org
Link: http://lkml.kernel.org/r/20160729163013.E48D6981@viggo.jf.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit a8502b67d739c1d7a4542c1da0a5d98a6a58c177)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/pkeys.h
#	include/linux/pkeys.h
#	mm/mprotect.c
diff --cc mm/mprotect.c
index 12cbcc768180,abd9c8257b2e..000000000000
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@@ -391,12 -417,27 +391,31 @@@ SYSCALL_DEFINE3(mprotect, unsigned long
  		prev = vma;
  
  	for (nstart = start ; ; ) {
+ 		unsigned long mask_off_old_flags;
  		unsigned long newflags;
 -		int new_vma_pkey;
  
  		/* Here we know that vma->vm_start <= nstart < vma->vm_end. */
  
++<<<<<<< HEAD
 +		newflags = vm_flags;
 +		newflags |= (vma->vm_flags & ~(VM_READ | VM_WRITE | VM_EXEC));
++=======
+ 		/* Does the application expect PROT_READ to imply PROT_EXEC */
+ 		if (rier && (vma->vm_flags & VM_MAYEXEC))
+ 			prot |= PROT_EXEC;
+ 
+ 		/*
+ 		 * Each mprotect() call explicitly passes r/w/x permissions.
+ 		 * If a permission is not passed to mprotect(), it must be
+ 		 * cleared from the VMA.
+ 		 */
+ 		mask_off_old_flags = VM_READ | VM_WRITE | VM_EXEC |
+ 					ARCH_VM_PKEY_FLAGS;
+ 
+ 		new_vma_pkey = arch_override_mprotect_pkey(vma, prot, pkey);
+ 		newflags = calc_vm_prot_bits(prot, new_vma_pkey);
+ 		newflags |= (vma->vm_flags & ~mask_off_old_flags);
++>>>>>>> a8502b67d739 (x86/pkeys: Make mprotect_key() mask off additional vm_flags)
  
  		/* newflags >> 4 shift VM_MAY% in place of VM_% */
  		if ((newflags & ~(newflags >> 4)) & (VM_READ | VM_WRITE | VM_EXEC)) {
* Unmerged path arch/x86/include/asm/pkeys.h
* Unmerged path include/linux/pkeys.h
* Unmerged path arch/x86/include/asm/pkeys.h
* Unmerged path include/linux/pkeys.h
* Unmerged path mm/mprotect.c
