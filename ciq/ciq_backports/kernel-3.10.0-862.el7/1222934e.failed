dmaengine: dw: check return code of dma_async_device_register()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: dmaengine: dw: check return code of dma_async_device_register() (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 95.45%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 1222934e54b63752b4b1ad305d6a7f632a3ae46d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1222934e.failed

dma_async_device_register() may return non-zero error code. In such case we
have to follow error path.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit 1222934e54b63752b4b1ad305d6a7f632a3ae46d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dw_dmac.c
diff --cc drivers/dma/dw_dmac.c
index 5d0ba000e772,a27ded53ab4f..000000000000
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@@ -1849,32 -1659,28 +1849,49 @@@ static int dw_probe(struct platform_dev
  
  	dma_writel(dw, CFG, DW_CFG_DMA_EN);
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	dev_info(&pdev->dev, "DesignWare DMA Controller, %d channels\n",
 +		 nr_channels);
 +
 +	dma_async_device_register(&dw->dma);
 +
 +	if (pdev->dev.of_node) {
 +		err = of_dma_controller_register(pdev->dev.of_node,
 +						 dw_dma_of_xlate, dw);
 +		if (err)
 +			dev_err(&pdev->dev,
 +				"could not register of_dma_controller\n");
 +	}
 +
 +	if (ACPI_HANDLE(&pdev->dev))
 +		dw_dma_acpi_controller_register(dw);
 +
 +	return 0;
++=======
+ 	err = dma_async_device_register(&dw->dma);
+ 	if (err)
+ 		goto err_dma_register;
+ 
+ 	dev_info(chip->dev, "DesignWare DMA Controller, %d channels\n",
+ 		 nr_channels);
+ 
+ 	return 0;
+ 
+ err_dma_register:
+ 	free_irq(chip->irq, dw);
+ err_pdata:
+ 	clk_disable_unprepare(dw->clk);
+ 	return err;
++>>>>>>> 1222934e54b6 (dmaengine: dw: check return code of dma_async_device_register()):drivers/dma/dw/core.c
  }
 -EXPORT_SYMBOL_GPL(dw_dma_probe);
  
 -int dw_dma_remove(struct dw_dma_chip *chip)
 +static int dw_remove(struct platform_device *pdev)
  {
 -	struct dw_dma		*dw = chip->dw;
 +	struct dw_dma		*dw = platform_get_drvdata(pdev);
  	struct dw_dma_chan	*dwc, *_dwc;
  
 +	if (pdev->dev.of_node)
 +		of_dma_controller_free(pdev->dev.of_node);
  	dw_dma_off(dw);
  	dma_async_device_unregister(&dw->dma);
  
* Unmerged path drivers/dma/dw_dmac.c
