platform/x86: intel-vbtn: Simplify autorelease logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [platform] x86: intel-vbtn: Simplify autorelease logic (Scott Wood) [1445052]
Rebuild_FUZZ: 90.53%
commit-author Darren Hart (VMware) <dvhart@infradead.org>
commit 1c3fdf125ef416227e43fdedf6b5097c41e8c467
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1c3fdf12.failed

The new notify_handler logic determining if autorelease should be used or
not is a bit awkward, and can result in more than one call to
sparse_keymap_report_event for the same event (scancode). The nesting
and long lines also made it difficult to read.

Simplify the logic by eliminating a level of nesting with a goto and
always calculate autorelease and val so we can make a single call to
sparse_keymap_report_event.

	Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
	Reviewed-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
	Tested-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
	Cc: AceLan Kao <acelan.kao@canonical.com>
(cherry picked from commit 1c3fdf125ef416227e43fdedf6b5097c41e8c467)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/intel-vbtn.c
diff --cc drivers/platform/x86/intel-vbtn.c
index 4650b64f8aaa,5fc4315f7382..000000000000
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@@ -78,10 -80,30 +78,37 @@@ static void notify_handler(acpi_handle 
  {
  	struct platform_device *device = context;
  	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
++<<<<<<< HEAD
 +
 +	if (!sparse_keymap_report_event(priv->input_dev, event, 1, true))
 +		dev_info(&device->dev, "unknown event index 0x%x\n",
 +			 event);
++=======
+ 	unsigned int val = !(event & 1); /* Even=press, Odd=release */
+ 	const struct key_entry *ke_rel;
+ 	bool autorelease;
+ 
+ 	if (priv->wakeup_mode) {
+ 		if (sparse_keymap_entry_from_scancode(priv->input_dev, event)) {
+ 			pm_wakeup_hard_event(&device->dev);
+ 			return;
+ 		}
+ 		goto out_unknown;
+ 	}
+ 
+ 	/*
+ 	 * Even press events are autorelease if there is no corresponding odd
+ 	 * release event, or if the odd event is KE_IGNORE.
+ 	 */
+ 	ke_rel = sparse_keymap_entry_from_scancode(priv->input_dev, event | 1);
+ 	autorelease = val && (!ke_rel || ke_rel->type == KE_IGNORE);
+ 
+ 	if (sparse_keymap_report_event(priv->input_dev, event, val, autorelease))
+ 		return;
+ 
+ out_unknown:
+ 	dev_dbg(&device->dev, "unknown event index 0x%x\n", event);
++>>>>>>> 1c3fdf125ef4 (platform/x86: intel-vbtn: Simplify autorelease logic)
  }
  
  static int intel_vbtn_probe(struct platform_device *device)
* Unmerged path drivers/platform/x86/intel-vbtn.c
