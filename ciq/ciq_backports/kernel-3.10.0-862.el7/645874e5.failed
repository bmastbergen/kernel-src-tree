qed: Add support for Energy efficient ethernet.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] qed: Add support for Energy efficient ethernet (Don Dutile) [1499364 1462433]
Rebuild_FUZZ: 98.92%
commit-author Sudarsana Reddy Kalluru <sudarsana.kalluru@cavium.com>
commit 645874e5807ae5ffa09fba2ccd23f01e4eb16d58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/645874e5.failed

The patch adds required driver support for reading/configuring the
Energy Efficient Ethernet (EEE) parameters.

	Signed-off-by: Sudarsana Reddy Kalluru <sudarsana.kalluru@cavium.com>
	Signed-off-by: Yuval Mintz <yuval.mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 645874e5807ae5ffa09fba2ccd23f01e4eb16d58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
#	drivers/net/ethernet/qlogic/qed/qed_mcp.h
#	include/linux/qed/qed_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index f3b36ab0477e,f545607100e4..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -1627,12 -1679,15 +1627,22 @@@ int qed_hw_init(struct qed_dev *cdev, s
  			return rc;
  		}
  
++<<<<<<< HEAD
++=======
+ 		load_code = load_req_params.load_code;
+ 		DP_VERBOSE(p_hwfn, QED_MSG_SP,
+ 			   "Load request was sent. Load code: 0x%x\n",
+ 			   load_code);
+ 
+ 		qed_mcp_set_capabilities(p_hwfn, p_hwfn->p_main_ptt);
+ 
++>>>>>>> 645874e5807a (qed: Add support for Energy efficient ethernet.)
  		qed_reset_mb_shadow(p_hwfn, p_hwfn->p_main_ptt);
  
 +		DP_VERBOSE(p_hwfn, QED_MSG_SP,
 +			   "Load request was sent. Resp:0x%x, Load code: 0x%x\n",
 +			   rc, load_code);
 +
  		p_hwfn->first_on_engine = (load_code ==
  					   FW_MSG_CODE_DRV_LOAD_ENGINE);
  
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 484d4f20feff,c1ecce6b9141..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -732,7 -1253,12 +757,10 @@@ static void qed_mcp_handle_link_change(
  
  	p_link->sfp_tx_fault = !!(status & LINK_STATUS_SFP_TX_FAULT);
  
+ 	if (p_hwfn->mcp_info->capabilities & FW_MB_PARAM_FEATURE_SUPPORT_EEE)
+ 		qed_mcp_read_eee_config(p_hwfn, p_ptt, p_link);
+ 
  	qed_link_update(p_hwfn);
 -out:
 -	spin_unlock_bh(&p_hwfn->mcp_info->link_lock);
  }
  
  int qed_mcp_set_link(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt, bool b_up)
@@@ -745,16 -1270,28 +773,38 @@@
  	u32 cmd;
  
  	/* Set the shmem configuration according to params */
 -	memset(&phy_cfg, 0, sizeof(phy_cfg));
 +	phy_cfg = &union_data.drv_phy_cfg;
 +	memset(phy_cfg, 0, sizeof(*phy_cfg));
  	cmd = b_up ? DRV_MSG_CODE_INIT_PHY : DRV_MSG_CODE_LINK_RESET;
  	if (!params->speed.autoneg)
++<<<<<<< HEAD
 +		phy_cfg->speed = params->speed.forced_speed;
 +	phy_cfg->pause |= (params->pause.autoneg) ? ETH_PAUSE_AUTONEG : 0;
 +	phy_cfg->pause |= (params->pause.forced_rx) ? ETH_PAUSE_RX : 0;
 +	phy_cfg->pause |= (params->pause.forced_tx) ? ETH_PAUSE_TX : 0;
 +	phy_cfg->adv_speed = params->speed.advertised_speeds;
 +	phy_cfg->loopback_mode = params->loopback_mode;
++=======
+ 		phy_cfg.speed = params->speed.forced_speed;
+ 	phy_cfg.pause |= (params->pause.autoneg) ? ETH_PAUSE_AUTONEG : 0;
+ 	phy_cfg.pause |= (params->pause.forced_rx) ? ETH_PAUSE_RX : 0;
+ 	phy_cfg.pause |= (params->pause.forced_tx) ? ETH_PAUSE_TX : 0;
+ 	phy_cfg.adv_speed = params->speed.advertised_speeds;
+ 	phy_cfg.loopback_mode = params->loopback_mode;
+ 	if (p_hwfn->mcp_info->capabilities & FW_MB_PARAM_FEATURE_SUPPORT_EEE) {
+ 		if (params->eee.enable)
+ 			phy_cfg.eee_cfg |= EEE_CFG_EEE_ENABLED;
+ 		if (params->eee.tx_lpi_enable)
+ 			phy_cfg.eee_cfg |= EEE_CFG_TX_LPI;
+ 		if (params->eee.adv_caps & QED_EEE_1G_ADV)
+ 			phy_cfg.eee_cfg |= EEE_CFG_ADV_SPEED_1G;
+ 		if (params->eee.adv_caps & QED_EEE_10G_ADV)
+ 			phy_cfg.eee_cfg |= EEE_CFG_ADV_SPEED_10G;
+ 		phy_cfg.eee_cfg |= (params->eee.tx_lpi_timer <<
+ 				    EEE_TX_TIMER_USEC_OFFSET) &
+ 				   EEE_TX_TIMER_USEC_MASK;
+ 	}
++>>>>>>> 645874e5807a (qed: Add support for Energy efficient ethernet.)
  
  	p_hwfn->b_drv_link_init = b_up;
  
@@@ -2009,3 -2833,58 +2059,61 @@@ qed_mcp_resc_unlock(struct qed_hwfn *p_
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ void qed_mcp_resc_lock_default_init(struct qed_resc_lock_params *p_lock,
+ 				    struct qed_resc_unlock_params *p_unlock,
+ 				    enum qed_resc_lock
+ 				    resource, bool b_is_permanent)
+ {
+ 	if (p_lock) {
+ 		memset(p_lock, 0, sizeof(*p_lock));
+ 
+ 		/* Permanent resources don't require aging, and there's no
+ 		 * point in trying to acquire them more than once since it's
+ 		 * unexpected another entity would release them.
+ 		 */
+ 		if (b_is_permanent) {
+ 			p_lock->timeout = QED_MCP_RESC_LOCK_TO_NONE;
+ 		} else {
+ 			p_lock->retry_num = QED_MCP_RESC_LOCK_RETRY_CNT_DFLT;
+ 			p_lock->retry_interval =
+ 			    QED_MCP_RESC_LOCK_RETRY_VAL_DFLT;
+ 			p_lock->sleep_b4_retry = true;
+ 		}
+ 
+ 		p_lock->resource = resource;
+ 	}
+ 
+ 	if (p_unlock) {
+ 		memset(p_unlock, 0, sizeof(*p_unlock));
+ 		p_unlock->resource = resource;
+ 	}
+ }
+ 
+ int qed_mcp_get_capabilities(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
+ {
+ 	u32 mcp_resp;
+ 	int rc;
+ 
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_GET_MFW_FEATURE_SUPPORT,
+ 			 0, &mcp_resp, &p_hwfn->mcp_info->capabilities);
+ 	if (!rc)
+ 		DP_VERBOSE(p_hwfn, (QED_MSG_SP | NETIF_MSG_PROBE),
+ 			   "MFW supported features: %08x\n",
+ 			   p_hwfn->mcp_info->capabilities);
+ 
+ 	return rc;
+ }
+ 
+ int qed_mcp_set_capabilities(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
+ {
+ 	u32 mcp_resp, mcp_param, features;
+ 
+ 	features = DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EEE;
+ 
+ 	return qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_FEATURE_SUPPORT,
+ 			   features, &mcp_resp, &mcp_param);
+ }
++>>>>>>> 645874e5807a (qed: Add support for Energy efficient ethernet.)
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.h
index 65cdfcf16057,c7ec2395d1ce..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@@ -512,7 -558,10 +525,14 @@@ struct qed_mcp_info 
  	u8					*mfw_mb_cur;
  	u8					*mfw_mb_shadow;
  	u16					mfw_mb_length;
++<<<<<<< HEAD
 +	u16					mcp_hist;
++=======
+ 	u32					mcp_hist;
+ 
+ 	/* Capabilties negotiated with the MFW */
+ 	u32					capabilities;
++>>>>>>> 645874e5807a (qed: Add support for Energy efficient ethernet.)
  };
  
  struct qed_mcp_mb_params {
@@@ -816,4 -929,32 +836,35 @@@ qed_mcp_resc_unlock(struct qed_hwfn *p_
  		    struct qed_ptt *p_ptt,
  		    struct qed_resc_unlock_params *p_params);
  
++<<<<<<< HEAD
++=======
+ /**
+  * @brief - default initialization for lock/unlock resource structs
+  *
+  * @param p_lock - lock params struct to be initialized; Can be NULL
+  * @param p_unlock - unlock params struct to be initialized; Can be NULL
+  * @param resource - the requested resource
+  * @paral b_is_permanent - disable retries & aging when set
+  */
+ void qed_mcp_resc_lock_default_init(struct qed_resc_lock_params *p_lock,
+ 				    struct qed_resc_unlock_params *p_unlock,
+ 				    enum qed_resc_lock
+ 				    resource, bool b_is_permanent);
+ /**
+  * @brief Learn of supported MFW features; To be done during early init
+  *
+  * @param p_hwfn
+  * @param p_ptt
+  */
+ int qed_mcp_get_capabilities(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);
+ 
+ /**
+  * @brief Inform MFW of set of features supported by driver. Should be done
+  * inside the content of the LOAD_REQ.
+  *
+  * @param p_hwfn
+  * @param p_ptt
+  */
+ int qed_mcp_set_capabilities(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);
++>>>>>>> 645874e5807a (qed: Add support for Energy efficient ethernet.)
  #endif
diff --cc include/linux/qed/qed_if.h
index cbe538f3b78a,9f3276271b02..000000000000
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@@ -156,6 -156,23 +156,26 @@@ struct qed_dcbx_get 
  	struct qed_dcbx_admin_params local;
  };
  
++<<<<<<< HEAD
++=======
+ enum qed_nvm_images {
+ 	QED_NVM_IMAGE_ISCSI_CFG,
+ 	QED_NVM_IMAGE_FCOE_CFG,
+ };
+ 
+ struct qed_link_eee_params {
+ 	u32 tx_lpi_timer;
+ #define QED_EEE_1G_ADV		BIT(0)
+ #define QED_EEE_10G_ADV		BIT(1)
+ 
+ 	/* Capabilities are represented using QED_EEE_*_ADV values */
+ 	u8 adv_caps;
+ 	u8 lp_adv_caps;
+ 	bool enable;
+ 	bool tx_lpi_enable;
+ };
+ 
++>>>>>>> 645874e5807a (qed: Add support for Energy efficient ethernet.)
  enum qed_led_mode {
  	QED_LED_MODE_OFF,
  	QED_LED_MODE_ON,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_hsi.h b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
index 60cc88a3ac01..a8bb5266c2b7 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_hsi.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
@@ -9411,6 +9411,17 @@ struct eth_phy_cfg {
 #define ETH_LOOPBACK_EXT		(3)
 #define ETH_LOOPBACK_MAC		(4)
 
+	u32 eee_cfg;
+#define EEE_CFG_EEE_ENABLED			BIT(0)
+#define EEE_CFG_TX_LPI				BIT(1)
+#define EEE_CFG_ADV_SPEED_1G			BIT(2)
+#define EEE_CFG_ADV_SPEED_10G			BIT(3)
+#define EEE_TX_TIMER_USEC_MASK			(0xfffffff0)
+#define EEE_TX_TIMER_USEC_OFFSET		4
+#define EEE_TX_TIMER_USEC_BALANCED_TIME		(0xa00)
+#define EEE_TX_TIMER_USEC_AGGRESSIVE_TIME	(0x100)
+#define EEE_TX_TIMER_USEC_LATENCY_TIME		(0x6000)
+
 	u32 feature_config_flags;
 #define ETH_EEE_MODE_ADV_LPI		(1 << 0)
 };
@@ -9828,6 +9839,25 @@ struct public_port {
 	u32 wol_pkt_len;
 	u32 wol_pkt_details;
 	struct dcb_dscp_map dcb_dscp_map;
+
+	u32 eee_status;
+#define EEE_ACTIVE_BIT			BIT(0)
+#define EEE_LD_ADV_STATUS_MASK		0x000000f0
+#define EEE_LD_ADV_STATUS_OFFSET	4
+#define EEE_1G_ADV			BIT(1)
+#define EEE_10G_ADV			BIT(2)
+#define EEE_LP_ADV_STATUS_MASK		0x00000f00
+#define EEE_LP_ADV_STATUS_OFFSET	8
+#define EEE_SUPPORTED_SPEED_MASK	0x0000f000
+#define EEE_SUPPORTED_SPEED_OFFSET	12
+#define EEE_1G_SUPPORTED		BIT(1)
+#define EEE_10G_SUPPORTED		BIT(2)
+
+	u32 eee_remote;
+#define EEE_REMOTE_TW_TX_MASK   0x0000ffff
+#define EEE_REMOTE_TW_TX_OFFSET 0
+#define EEE_REMOTE_TW_RX_MASK   0xffff0000
+#define EEE_REMOTE_TW_RX_OFFSET 16
 };
 
 struct public_func {
@@ -10110,6 +10140,9 @@ struct public_drv_mb {
 #define DRV_MSG_CODE_GET_PF_RDMA_PROTOCOL	0x002b0000
 #define DRV_MSG_CODE_OS_WOL			0x002e0000
 
+#define DRV_MSG_CODE_FEATURE_SUPPORT		0x00300000
+#define DRV_MSG_CODE_GET_MFW_FEATURE_SUPPORT	0x00310000
+
 #define DRV_MSG_SEQ_NUMBER_MASK			0x0000ffff
 
 	u32 drv_mb_param;
@@ -10193,6 +10226,10 @@ struct public_drv_mb {
 #define DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_SHIFT	8
 #define DRV_MB_PARAM_BIST_TEST_IMAGE_INDEX_MASK		0x0000FF00
 
+#define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_MASK		0x0000FFFF
+#define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_OFFSET	0
+#define DRV_MB_PARAM_FEATURE_SUPPORT_PORT_EEE		0x00000002
+
 	u32 fw_mb_header;
 #define FW_MSG_CODE_MASK			0xffff0000
 #define FW_MSG_CODE_UNSUPPORTED                 0x00000000
@@ -10228,6 +10265,9 @@ struct public_drv_mb {
 #define FW_MB_PARAM_GET_PF_RDMA_IWARP		0x2
 #define FW_MB_PARAM_GET_PF_RDMA_BOTH		0x3
 
+/* get MFW feature support response */
+#define FW_MB_PARAM_FEATURE_SUPPORT_EEE		0x00000002
+
 #define FW_MB_PARAM_LOAD_DONE_DID_EFUSE_ERROR	(1 << 0)
 
 	u32 drv_pulse_mb;
@@ -10423,7 +10463,16 @@ struct nvm_cfg1_port {
 #define NVM_CFG1_PORT_DRV_FLOW_CONTROL_TX			0x4
 	u32 phy_cfg;
 	u32 mgmt_traffic;
+
 	u32 ext_phy;
+	/* EEE power saving mode */
+#define NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_MASK		0x00FF0000
+#define NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_OFFSET		16
+#define NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_DISABLED		0x0
+#define NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_BALANCED		0x1
+#define NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_AGGRESSIVE		0x2
+#define NVM_CFG1_PORT_EEE_POWER_SAVING_MODE_LOW_LATENCY		0x3
+
 	u32 mba_cfg1;
 	u32 mba_cfg2;
 	u32 vf_cfg;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index 545e79f7504c..63058cab02db 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -1212,6 +1212,10 @@ static int qed_set_link(struct qed_dev *cdev, struct qed_link_params *params)
 		}
 	}
 
+	if (params->override_flags & QED_LINK_OVERRIDE_EEE_CONFIG)
+		memcpy(&link_params->eee, &params->eee,
+		       sizeof(link_params->eee));
+
 	rc = qed_mcp_set_link(hwfn, ptt, params->link_up);
 
 	qed_ptt_release(hwfn, ptt);
@@ -1398,6 +1402,21 @@ static void qed_fill_link(struct qed_hwfn *hwfn,
 	if (link.partner_adv_pause == QED_LINK_PARTNER_ASYMMETRIC_PAUSE ||
 	    link.partner_adv_pause == QED_LINK_PARTNER_BOTH_PAUSE)
 		if_link->lp_caps |= QED_LM_Asym_Pause_BIT;
+
+	if (link_caps.default_eee == QED_MCP_EEE_UNSUPPORTED) {
+		if_link->eee_supported = false;
+	} else {
+		if_link->eee_supported = true;
+		if_link->eee_active = link.eee_active;
+		if_link->sup_caps = link_caps.eee_speed_caps;
+		/* MFW clears adv_caps on eee disable; use configured value */
+		if_link->eee.adv_caps = link.eee_adv_caps ? link.eee_adv_caps :
+					params.eee.adv_caps;
+		if_link->eee.lp_adv_caps = link.eee_lp_adv_caps;
+		if_link->eee.enable = params.eee.enable;
+		if_link->eee.tx_lpi_enable = params.eee.tx_lpi_enable;
+		if_link->eee.tx_lpi_timer = params.eee.tx_lpi_timer;
+	}
 }
 
 static void qed_get_current_link(struct qed_dev *cdev,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.h
* Unmerged path include/linux/qed/qed_if.h
