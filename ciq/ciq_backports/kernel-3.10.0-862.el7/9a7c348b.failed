ftrace: Add return address pointer to ftrace_ret_stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 9a7c348ba6a46f6270d4fe49577649dad5664fe7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/9a7c348b.failed

Storing this value will help prevent unwinders from getting out of sync
with the function graph tracer ret_stack.  Now instead of needing a
stateful iterator, they can compare the return address pointer to find
the right ret_stack entry.

Note that an array of 50 ftrace_ret_stack structs is allocated for every
task.  So when an arch implements this, it will add either 200 or 400
bytes of memory usage per task (depending on whether it's a 32-bit or
64-bit platform).

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Acked-by: Steven Rostedt <rostedt@goodmis.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Byungchul Park <byungchul.park@lge.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Nilay Vaish <nilayvaish@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/a95cfcc39e8f26b89a430c56926af0bb217bc0a1.1471607358.git.jpoimboe@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9a7c348ba6a46f6270d4fe49577649dad5664fe7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/ftrace.c
#	arch/parisc/kernel/ftrace.c
#	arch/tile/kernel/ftrace.c
#	include/linux/ftrace.h
#	kernel/trace/trace_functions_graph.c
diff --cc arch/parisc/kernel/ftrace.c
index 5beb97bafbb1,5a5506a35395..000000000000
--- a/arch/parisc/kernel/ftrace.c
+++ b/arch/parisc/kernel/ftrace.c
@@@ -116,13 -39,33 +116,42 @@@ void prepare_ftrace_return(unsigned lon
  		return;
  
  	old = *parent;
 -
 +	*parent = (unsigned long)
 +		  dereference_function_descriptor(&return_to_handler);
 +
++<<<<<<< HEAD
 +	if (unlikely(!__kernel_text_address(old))) {
 +		ftrace_graph_stop();
 +		*parent = old;
 +		WARN_ON(1);
++=======
+ 	trace.func = self_addr;
+ 	trace.depth = current->curr_ret_stack + 1;
+ 
+ 	/* Only trace if the calling function expects to */
+ 	if (!ftrace_graph_entry(&trace))
+ 		return;
+ 
+         if (ftrace_push_return_trace(old, self_addr, &trace.depth,
+ 				     0, NULL) == -EBUSY)
+                 return;
+ 
+ 	/* activate parisc_return_to_handler() as return point */
+ 	*parent = (unsigned long) &parisc_return_to_handler;
+ }
+ #endif /* CONFIG_FUNCTION_GRAPH_TRACER */
+ 
+ void notrace __hot ftrace_function_trampoline(unsigned long parent,
+ 				unsigned long self_addr,
+ 				unsigned long org_sp_gr3)
+ {
+ 	extern ftrace_func_t ftrace_trace_function;  /* depends on CONFIG_DYNAMIC_FTRACE */
+ 	extern int ftrace_graph_entry_stub(struct ftrace_graph_ent *trace);
+ 
+ 	if (ftrace_trace_function != ftrace_stub) {
+ 		/* struct ftrace_ops *op, struct pt_regs *regs); */
+ 		ftrace_trace_function(parent, self_addr, NULL, NULL);
++>>>>>>> 9a7c348ba6a4 (ftrace: Add return address pointer to ftrace_ret_stack)
  		return;
  	}
  
diff --cc include/linux/ftrace.h
index 5e2f30c5d3de,483e02a50d37..000000000000
--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@@ -681,7 -795,12 +681,14 @@@ struct ftrace_ret_stack 
  	unsigned long func;
  	unsigned long long calltime;
  	unsigned long long subtime;
 -#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
  	unsigned long fp;
++<<<<<<< HEAD
++=======
+ #endif
+ #ifdef HAVE_FUNCTION_GRAPH_RET_ADDR_PTR
+ 	unsigned long *retp;
+ #endif
++>>>>>>> 9a7c348ba6a4 (ftrace: Add return address pointer to ftrace_ret_stack)
  };
  
  /*
diff --cc kernel/trace/trace_functions_graph.c
index 399f630766c9,f7212ec643e2..000000000000
--- a/kernel/trace/trace_functions_graph.c
+++ b/kernel/trace/trace_functions_graph.c
@@@ -152,8 -171,13 +152,16 @@@ ftrace_push_return_trace(unsigned long 
  	current->ret_stack[index].func = func;
  	current->ret_stack[index].calltime = calltime;
  	current->ret_stack[index].subtime = 0;
 -#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
  	current->ret_stack[index].fp = frame_pointer;
++<<<<<<< HEAD
 +	*depth = index;
++=======
+ #endif
+ #ifdef HAVE_FUNCTION_GRAPH_RET_ADDR_PTR
+ 	current->ret_stack[index].retp = retp;
+ #endif
+ 	*depth = current->curr_ret_stack;
++>>>>>>> 9a7c348ba6a4 (ftrace: Add return address pointer to ftrace_ret_stack)
  
  	return 0;
  }
* Unmerged path arch/arm64/kernel/ftrace.c
* Unmerged path arch/tile/kernel/ftrace.c
diff --git a/Documentation/trace/ftrace-design.txt b/Documentation/trace/ftrace-design.txt
index 6666f8b00b9b..de3d729ff6c0 100644
--- a/Documentation/trace/ftrace-design.txt
+++ b/Documentation/trace/ftrace-design.txt
@@ -203,6 +203,17 @@ along to ftrace_push_return_trace() instead of a stub value of 0.
 
 Similarly, when you call ftrace_return_to_handler(), pass it the frame pointer.
 
+HAVE_FUNCTION_GRAPH_RET_ADDR_PTR
+--------------------------------
+
+An arch may pass in a pointer to the return address on the stack.  This
+prevents potential stack unwinding issues where the unwinder gets out of
+sync with ret_stack and the wrong addresses are reported by
+ftrace_graph_ret_addr().
+
+Adding support for it is easy: just define the macro in asm/ftrace.h and
+pass the return address pointer as the 'retp' argument to
+ftrace_push_return_trace().
 
 HAVE_FTRACE_NMI_ENTER
 ---------------------
diff --git a/arch/arm/kernel/ftrace.c b/arch/arm/kernel/ftrace.c
index 34e56647dcee..7b1b223d4a04 100644
--- a/arch/arm/kernel/ftrace.c
+++ b/arch/arm/kernel/ftrace.c
@@ -189,7 +189,7 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr,
 	}
 
 	err = ftrace_push_return_trace(old, self_addr, &trace.depth,
-				       frame_pointer);
+				       frame_pointer, NULL);
 	if (err == -EBUSY) {
 		*parent = old;
 		return;
* Unmerged path arch/arm64/kernel/ftrace.c
diff --git a/arch/blackfin/kernel/ftrace.c b/arch/blackfin/kernel/ftrace.c
index 9277905b82cf..cdf95b8aa5a2 100644
--- a/arch/blackfin/kernel/ftrace.c
+++ b/arch/blackfin/kernel/ftrace.c
@@ -110,7 +110,7 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr,
 		return;
 
 	if (ftrace_push_return_trace(*parent, self_addr, &trace.depth,
-	                             frame_pointer) == -EBUSY)
+				     frame_pointer, NULL) == -EBUSY)
 		return;
 
 	trace.func = self_addr;
diff --git a/arch/microblaze/kernel/ftrace.c b/arch/microblaze/kernel/ftrace.c
index e8a5e9cf4ed1..6cd61100d07d 100644
--- a/arch/microblaze/kernel/ftrace.c
+++ b/arch/microblaze/kernel/ftrace.c
@@ -60,7 +60,7 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr)
 		return;
 	}
 
-	err = ftrace_push_return_trace(old, self_addr, &trace.depth, 0);
+	err = ftrace_push_return_trace(old, self_addr, &trace.depth, 0, NULL);
 	if (err == -EBUSY) {
 		*parent = old;
 		return;
diff --git a/arch/mips/kernel/ftrace.c b/arch/mips/kernel/ftrace.c
index dba90ec0dc38..9ca269158191 100644
--- a/arch/mips/kernel/ftrace.c
+++ b/arch/mips/kernel/ftrace.c
@@ -338,8 +338,8 @@ void prepare_ftrace_return(unsigned long *parent_ra_addr, unsigned long self_ra,
 	if (unlikely(faulted))
 		goto out;
 
-	if (ftrace_push_return_trace(old_parent_ra, self_ra, &trace.depth, fp)
-	    == -EBUSY) {
+	if (ftrace_push_return_trace(old_parent_ra, self_ra, &trace.depth, fp,
+				     NULL) == -EBUSY) {
 		*parent_ra_addr = old_parent_ra;
 		return;
 	}
* Unmerged path arch/parisc/kernel/ftrace.c
diff --git a/arch/powerpc/kernel/ftrace.c b/arch/powerpc/kernel/ftrace.c
index e958be11db11..a3cd361a5f1f 100644
--- a/arch/powerpc/kernel/ftrace.c
+++ b/arch/powerpc/kernel/ftrace.c
@@ -549,7 +549,8 @@ unsigned long prepare_ftrace_return(unsigned long parent, unsigned long ip)
 	if (!ftrace_graph_entry(&trace))
 		goto out;
 
-	if (ftrace_push_return_trace(parent, ip, &trace.depth, 0) == -EBUSY)
+	if (ftrace_push_return_trace(parent, ip, &trace.depth, 0,
+				     NULL) == -EBUSY)
 		goto out;
 
 	parent = return_hooker;
diff --git a/arch/s390/kernel/ftrace.c b/arch/s390/kernel/ftrace.c
index 9d3533e6a3fd..f0a1d63eb12f 100644
--- a/arch/s390/kernel/ftrace.c
+++ b/arch/s390/kernel/ftrace.c
@@ -158,7 +158,8 @@ unsigned long __kprobes prepare_ftrace_return(unsigned long parent,
 	/* Only trace if the calling function expects to. */
 	if (!ftrace_graph_entry(&trace))
 		goto out;
-	if (ftrace_push_return_trace(parent, ip, &trace.depth, 0) == -EBUSY)
+	if (ftrace_push_return_trace(parent, ip, &trace.depth, 0,
+				     NULL) == -EBUSY)
 		goto out;
 	parent = (unsigned long) return_to_handler;
 out:
diff --git a/arch/sh/kernel/ftrace.c b/arch/sh/kernel/ftrace.c
index 5b65422ab035..0fdd78c2e446 100644
--- a/arch/sh/kernel/ftrace.c
+++ b/arch/sh/kernel/ftrace.c
@@ -384,7 +384,7 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr)
 		return;
 	}
 
-	err = ftrace_push_return_trace(old, self_addr, &trace.depth, 0);
+	err = ftrace_push_return_trace(old, self_addr, &trace.depth, 0, NULL);
 	if (err == -EBUSY) {
 		__raw_writel(old, parent);
 		return;
diff --git a/arch/sparc/kernel/ftrace.c b/arch/sparc/kernel/ftrace.c
index 03ab022e51c5..2b73bfb8c3ff 100644
--- a/arch/sparc/kernel/ftrace.c
+++ b/arch/sparc/kernel/ftrace.c
@@ -135,7 +135,7 @@ unsigned long prepare_ftrace_return(unsigned long parent,
 		return parent + 8UL;
 
 	if (ftrace_push_return_trace(parent, self_addr, &trace.depth,
-				     frame_pointer) == -EBUSY)
+				     frame_pointer, NULL) == -EBUSY)
 		return parent + 8UL;
 
 	trace.func = self_addr;
* Unmerged path arch/tile/kernel/ftrace.c
diff --git a/arch/x86/kernel/ftrace.c b/arch/x86/kernel/ftrace.c
index c07a794c9672..f26324133752 100644
--- a/arch/x86/kernel/ftrace.c
+++ b/arch/x86/kernel/ftrace.c
@@ -792,7 +792,7 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr,
 	}
 
 	if (ftrace_push_return_trace(old, self_addr, &trace.depth,
-		    frame_pointer) == -EBUSY) {
+				     frame_pointer, NULL) == -EBUSY) {
 		*parent = old;
 		return;
 	}
* Unmerged path include/linux/ftrace.h
* Unmerged path kernel/trace/trace_functions_graph.c
