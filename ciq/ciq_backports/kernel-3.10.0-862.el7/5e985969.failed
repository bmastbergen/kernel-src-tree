KVM: PPC: Book3S HV: Outline of KVM-HV HPT resizing implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author David Gibson <david@gibson.dropbear.id.au>
commit 5e9859699aba74c0e297645e7d1734cd4b964de7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5e985969.failed

This adds a not yet working outline of the HPT resizing PAPR
extension.  Specifically it adds the necessary ioctl() functions,
their basic steps, the work function which will handle preparation for
the resize, and synchronization between these, the guest page fault
path and guest HPT update path.

The actual guts of the implementation isn't here yet, so for now the
calls will always fail.

	Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 5e9859699aba74c0e297645e7d1734cd4b964de7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_host.h
#	arch/powerpc/kvm/book3s_64_mmu_hv.c
diff --cc arch/powerpc/include/asm/kvm_host.h
index 328d42daf22c,7bba8f415627..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -235,6 -241,19 +235,22 @@@ struct kvm_arch_memory_slot 
  #endif /* CONFIG_KVM_BOOK3S_HV_POSSIBLE */
  };
  
++<<<<<<< HEAD
++=======
+ struct kvm_hpt_info {
+ 	/* Host virtual (linear mapping) address of guest HPT */
+ 	unsigned long virt;
+ 	/* Array of reverse mapping entries for each guest HPTE */
+ 	struct revmap_entry *rev;
+ 	/* Guest HPT size is 2**(order) bytes */
+ 	u32 order;
+ 	/* 1 if HPT allocated with CMA, 0 otherwise */
+ 	int cma;
+ };
+ 
+ struct kvm_resize_hpt;
+ 
++>>>>>>> 5e9859699aba (KVM: PPC: Book3S HV: Outline of KVM-HV HPT resizing implementation)
  struct kvm_arch {
  	unsigned int lpid;
  #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
@@@ -248,16 -268,17 +264,17 @@@
  	unsigned long lpcr;
  	unsigned long vrma_slb_v;
  	int hpte_setup_done;
 +	u32 hpt_order;
  	atomic_t vcpus_running;
  	u32 online_vcores;
 +	unsigned long hpt_npte;
 +	unsigned long hpt_mask;
  	atomic_t hpte_mod_interest;
  	cpumask_t need_tlb_flush;
 -	cpumask_t cpu_in_guest;
 -	u8 radix;
 -	pgd_t *pgtable;
 -	u64 process_table;
 +	int hpt_cma_alloc;
  	struct dentry *debugfs_dir;
  	struct dentry *htab_dentry;
+ 	struct kvm_resize_hpt *resize_hpt; /* protected by kvm->lock */
  #endif /* CONFIG_KVM_BOOK3S_HV_POSSIBLE */
  #ifdef CONFIG_KVM_BOOK3S_PR_POSSIBLE
  	struct mutex hpt_mutex;
diff --cc arch/powerpc/kvm/book3s_64_mmu_hv.c
index 283e37e10f56,323287fc0c01..000000000000
--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c
+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c
@@@ -38,46 -38,59 +38,73 @@@
  #include <asm/ppc-opcode.h>
  #include <asm/cputable.h>
  
 +#include "book3s_hv_cma.h"
  #include "trace_hv.h"
  
++<<<<<<< HEAD
 +/* Power architecture requires HPT is at least 256kB */
 +#define PPC_MIN_HPT_ORDER	18
++=======
+ //#define DEBUG_RESIZE_HPT	1
+ 
+ #ifdef DEBUG_RESIZE_HPT
+ #define resize_hpt_debug(resize, ...)				\
+ 	do {							\
+ 		printk(KERN_DEBUG "RESIZE HPT %p: ", resize);	\
+ 		printk(__VA_ARGS__);				\
+ 	} while (0)
+ #else
+ #define resize_hpt_debug(resize, ...)				\
+ 	do { } while (0)
+ #endif
++>>>>>>> 5e9859699aba (KVM: PPC: Book3S HV: Outline of KVM-HV HPT resizing implementation)
  
  static long kvmppc_virtmode_do_h_enter(struct kvm *kvm, unsigned long flags,
  				long pte_index, unsigned long pteh,
  				unsigned long ptel, unsigned long *pte_idx_ret);
+ 
+ struct kvm_resize_hpt {
+ 	/* These fields read-only after init */
+ 	struct kvm *kvm;
+ 	struct work_struct work;
+ 	u32 order;
+ 
+ 	/* These fields protected by kvm->lock */
+ 	int error;
+ 	bool prepare_done;
+ };
+ 
  static void kvmppc_rmap_reset(struct kvm *kvm);
  
 -int kvmppc_allocate_hpt(struct kvm_hpt_info *info, u32 order)
 +long kvmppc_alloc_hpt(struct kvm *kvm, u32 *htab_orderp)
  {
  	unsigned long hpt = 0;
 -	int cma = 0;
 -	struct page *page = NULL;
  	struct revmap_entry *rev;
 -	unsigned long npte;
 +	struct page *page = NULL;
 +	long order = KVM_DEFAULT_HPT_ORDER;
  
 -	if ((order < PPC_MIN_HPT_ORDER) || (order > PPC_MAX_HPT_ORDER))
 -		return -EINVAL;
 +	if (htab_orderp) {
 +		order = *htab_orderp;
 +		if (order < PPC_MIN_HPT_ORDER)
 +			order = PPC_MIN_HPT_ORDER;
 +	}
  
 -	page = kvm_alloc_hpt_cma(1ul << (order - PAGE_SHIFT));
 +	kvm->arch.hpt_cma_alloc = 0;
 +	VM_BUG_ON(order < KVM_CMA_CHUNK_ORDER);
 +	page = kvm_alloc_hpt(1 << (order - PAGE_SHIFT));
  	if (page) {
  		hpt = (unsigned long)pfn_to_kaddr(page_to_pfn(page));
 -		memset((void *)hpt, 0, (1ul << order));
 -		cma = 1;
 +		kvm->arch.hpt_cma_alloc = 1;
  	}
  
 -	if (!hpt)
 -		hpt = __get_free_pages(GFP_KERNEL|__GFP_ZERO|__GFP_REPEAT
 -				       |__GFP_NOWARN, order - PAGE_SHIFT);
 +	/* Lastly try successively smaller sizes from the page allocator */
 +	/* Only do this if userspace didn't specify a size via ioctl */
 +	while (!hpt && order > PPC_MIN_HPT_ORDER && !htab_orderp) {
 +		hpt = __get_free_pages(GFP_KERNEL|__GFP_ZERO|__GFP_REPEAT|
 +				       __GFP_NOWARN, order - PAGE_SHIFT);
 +		if (!hpt)
 +			--order;
 +	}
  
  	if (!hpt)
  		return -ENOMEM;
* Unmerged path arch/powerpc/include/asm/kvm_host.h
diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h
index 4fff076a809b..fb513b69a157 100644
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@ -215,6 +215,10 @@ extern void kvmppc_bookehv_exit(void);
 extern int kvmppc_prepare_to_enter(struct kvm_vcpu *vcpu);
 
 extern int kvm_vm_ioctl_get_htab_fd(struct kvm *kvm, struct kvm_get_htab_fd *);
+extern long kvm_vm_ioctl_resize_hpt_prepare(struct kvm *kvm,
+					    struct kvm_ppc_resize_hpt *rhpt);
+extern long kvm_vm_ioctl_resize_hpt_commit(struct kvm *kvm,
+					   struct kvm_ppc_resize_hpt *rhpt);
 
 int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu, struct kvm_interrupt *irq);
 
* Unmerged path arch/powerpc/kvm/book3s_64_mmu_hv.c
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index 92357b82799a..7eb6fefbab26 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -3227,6 +3227,9 @@ static int kvmppc_core_init_vm_hv(struct kvm *kvm)
 		lpcr |= LPCR_ONL;
 	kvm->arch.lpcr = lpcr;
 
+	/* Initialization for future HPT resizes */
+	kvm->arch.resize_hpt = NULL;
+
 	/*
 	 * Track that we now have a HV mode VM active. This blocks secondary
 	 * CPU threads from coming online.
@@ -3501,6 +3504,28 @@ static long kvm_arch_vm_ioctl_hv(struct file *filp,
 		break;
 	}
 
+	case KVM_PPC_RESIZE_HPT_PREPARE: {
+		struct kvm_ppc_resize_hpt rhpt;
+
+		r = -EFAULT;
+		if (copy_from_user(&rhpt, argp, sizeof(rhpt)))
+			break;
+
+		r = kvm_vm_ioctl_resize_hpt_prepare(kvm, &rhpt);
+		break;
+	}
+
+	case KVM_PPC_RESIZE_HPT_COMMIT: {
+		struct kvm_ppc_resize_hpt rhpt;
+
+		r = -EFAULT;
+		if (copy_from_user(&rhpt, argp, sizeof(rhpt)))
+			break;
+
+		r = kvm_vm_ioctl_resize_hpt_commit(kvm, &rhpt);
+		break;
+	}
+
 	default:
 		r = -ENOTTY;
 	}
