userfaultfd: non-cooperative: notify about unmap of destination during mremap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mike Rapoport <rppt@linux.vnet.ibm.com>
commit b22823719302e88d0e2a6bb06433bd97b175a8d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b2282371.failed

When mremap is called with MREMAP_FIXED it unmaps memory at the
destination address without notifying userfaultfd monitor.

If the destination were registered with userfaultfd, the monitor has no
way to distinguish between the old and new ranges and to properly relate
the page faults that would occur in the destination region.

Fixes: 897ab3e0c49e ("userfaultfd: non-cooperative: add event for memory unmaps")
Link: http://lkml.kernel.org/r/1500276876-3350-1-git-send-email-rppt@linux.vnet.ibm.com
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Acked-by: Pavel Emelyanov <xemul@virtuozzo.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b22823719302e88d0e2a6bb06433bd97b175a8d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mremap.c
diff --cc mm/mremap.c
index f8d5366beb3a,3f23715d3c69..000000000000
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@@ -427,16 -444,11 +428,16 @@@ static unsigned long mremap_to(unsigne
  	if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
  		goto out;
  
 -	/* Ensure the old/new locations do not overlap */
 -	if (addr + old_len > new_addr && new_addr + new_len > addr)
 +	/* Check if the location we're moving into overlaps the
 +	 * old location at all, and fail if it does.
 +	 */
 +	if ((new_addr <= addr) && (new_addr+new_len) > addr)
 +		goto out;
 +
 +	if ((addr <= new_addr) && (addr+old_len) > new_addr)
  		goto out;
  
- 	ret = do_munmap(mm, new_addr, new_len, NULL);
+ 	ret = do_munmap(mm, new_addr, new_len, uf_unmap_early);
  	if (ret)
  		goto out;
  
@@@ -504,15 -516,17 +505,16 @@@ SYSCALL_DEFINE5(mremap, unsigned long, 
  	unsigned long charged = 0;
  	bool locked = false;
  	struct vm_userfaultfd_ctx uf = NULL_VM_UFFD_CTX;
+ 	LIST_HEAD(uf_unmap_early);
  	LIST_HEAD(uf_unmap);
  
 -	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 -		return ret;
 +	down_write(&current->mm->mmap_sem);
  
 -	if (flags & MREMAP_FIXED && !(flags & MREMAP_MAYMOVE))
 -		return ret;
 +	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 +		goto out;
  
 -	if (offset_in_page(addr))
 -		return ret;
 +	if (addr & ~PAGE_MASK)
 +		goto out;
  
  	old_len = PAGE_ALIGN(old_len);
  	new_len = PAGE_ALIGN(new_len);
@@@ -523,12 -537,14 +525,17 @@@
  	 * a zero new-len is nonsensical.
  	 */
  	if (!new_len)
 -		return ret;
 -
 -	if (down_write_killable(&current->mm->mmap_sem))
 -		return -EINTR;
 +		goto out;
  
  	if (flags & MREMAP_FIXED) {
++<<<<<<< HEAD
 +		if (flags & MREMAP_MAYMOVE)
 +			ret = mremap_to(addr, old_len, new_addr, new_len,
 +					&locked, &uf, &uf_unmap);
++=======
+ 		ret = mremap_to(addr, old_len, new_addr, new_len,
+ 				&locked, &uf, &uf_unmap_early, &uf_unmap);
++>>>>>>> b22823719302 (userfaultfd: non-cooperative: notify about unmap of destination during mremap)
  		goto out;
  	}
  
* Unmerged path mm/mremap.c
