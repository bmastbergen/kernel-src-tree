radix-tree: free up the bottom bit of exceptional entries for reuse

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthew Wilcox <willy@linux.intel.com>
commit 3bcadd6fa6c4fd07ace3626357c824eb532488a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3bcadd6f.failed

We are guaranteed that pointers to radix_tree_nodes always have the
bottom two bits clear (because they come from a slab cache, and slab
caches have a minimum alignment of sizeof(void *)), so we can redefine
'radix_tree_is_internal_node' to only return true if the bottom two bits
have value '01'.  This frees up one quarter of the potential values for
use by the user.

Idea from Neil Brown.

	Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
	Suggested-by: Neil Brown <neilb@suse.de>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Kirill Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Jan Kara <jack@suse.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3bcadd6fa6c4fd07ace3626357c824eb532488a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/radix-tree.h
diff --cc include/linux/radix-tree.h
index 476b3e739080,cb4b7e8cee81..000000000000
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@@ -29,32 -29,37 +29,60 @@@
  #include <linux/rcupdate.h>
  
  /*
++<<<<<<< HEAD
 + * An indirect pointer (root->rnode pointing to a radix_tree_node, rather
 + * than a data item) is signalled by the low bit set in the root->rnode
 + * pointer.
 + *
 + * In this case root->height is > 0, but the indirect pointer tests are
 + * needed for RCU lookups (because root->height is unreliable). The only
 + * time callers need worry about this is when doing a lookup_slot under
 + * RCU.
 + *
 + * Indirect pointer in fact is also used to tag the last pointer of a node
 + * when it is shrunk, before we rcu free the node. See shrink code for
 + * details.
 + */
 +#define RADIX_TREE_INDIRECT_PTR		1
++=======
+  * The bottom two bits of the slot determine how the remaining bits in the
+  * slot are interpreted:
+  *
+  * 00 - data pointer
+  * 01 - internal entry
+  * 10 - exceptional entry
+  * 11 - locked exceptional entry
+  *
+  * The internal entry may be a pointer to the next level in the tree, a
+  * sibling entry, or an indicator that the entry in this slot has been moved
+  * to another location in the tree and the lookup should be restarted.  While
+  * NULL fits the 'data pointer' pattern, it means that there is no entry in
+  * the tree for this index (no matter what level of the tree it is found at).
+  * This means that you cannot store NULL in the tree as a value for the index.
+  */
+ #define RADIX_TREE_ENTRY_MASK		3UL
+ #define RADIX_TREE_INTERNAL_NODE	1UL
+ 
++>>>>>>> 3bcadd6fa6c4 (radix-tree: free up the bottom bit of exceptional entries for reuse)
  /*
-  * A common use of the radix tree is to store pointers to struct pages;
-  * but shmem/tmpfs needs also to store swap entries in the same tree:
-  * those are marked as exceptional entries to distinguish them.
+  * Most users of the radix tree store pointers but shmem/tmpfs stores swap
+  * entries in the same tree.  They are marked as exceptional entries to
+  * distinguish them from pointers to struct page.
   * EXCEPTIONAL_ENTRY tests the bit, EXCEPTIONAL_SHIFT shifts content past it.
   */
  #define RADIX_TREE_EXCEPTIONAL_ENTRY	2
  #define RADIX_TREE_EXCEPTIONAL_SHIFT	2
  
++<<<<<<< HEAD
 +static inline int radix_tree_is_indirect_ptr(void *ptr)
 +{
 +	return (int)((unsigned long)ptr & RADIX_TREE_INDIRECT_PTR);
++=======
+ static inline bool radix_tree_is_internal_node(void *ptr)
+ {
+ 	return ((unsigned long)ptr & RADIX_TREE_ENTRY_MASK) ==
+ 				RADIX_TREE_INTERNAL_NODE;
++>>>>>>> 3bcadd6fa6c4 (radix-tree: free up the bottom bit of exceptional entries for reuse)
  }
  
  /*** radix-tree API starts here ***/
@@@ -243,8 -245,7 +271,12 @@@ static inline int radix_tree_exceptiona
   */
  static inline int radix_tree_exception(void *arg)
  {
++<<<<<<< HEAD
 +	return unlikely((unsigned long)arg &
 +		(RADIX_TREE_INDIRECT_PTR | RADIX_TREE_EXCEPTIONAL_ENTRY));
++=======
+ 	return unlikely((unsigned long)arg & RADIX_TREE_ENTRY_MASK);
++>>>>>>> 3bcadd6fa6c4 (radix-tree: free up the bottom bit of exceptional entries for reuse)
  }
  
  /**
* Unmerged path include/linux/radix-tree.h
