udp: inuse checks can quit early for reuseport

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric Garver <e@erig.me>
commit df560056d960a3e164c179d89770d5a51b798537
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/df560056.failed

UDP lib inuse checks will walk the entire hash bucket to check if the
portaddr is in use. In the case of reuseport we can stop searching when
we find a matching reuseport.

On a 16-core VM a test program that spawns 16 threads that each bind to
1024 sockets (one per 10ms) takes 1m45s. With this change it takes 11s.

Also add a cond_resched() when the port is not specified.

	Signed-off-by: Eric Garver <e@erig.me>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df560056d960a3e164c179d89770d5a51b798537)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
diff --cc net/ipv4/udp.c
index c6e2b198be79,4318d72e0248..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -152,12 -153,18 +152,27 @@@ static int udp_lib_lport_inuse(struct n
  		    (!sk2->sk_reuse || !sk->sk_reuse) &&
  		    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if ||
  		     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
++<<<<<<< HEAD
 +		    (!sk2->sk_reuseport || !sk->sk_reuseport ||
 +		     !uid_eq(uid, sock_i_uid(sk2))) &&
 +		    saddr_comp(sk, sk2)) {
 +			if (!bitmap)
 +				return 1;
 +			__set_bit(udp_sk(sk2)->udp_port_hash >> log, bitmap);
++=======
+ 		    saddr_comp(sk, sk2, true)) {
+ 			if (sk2->sk_reuseport && sk->sk_reuseport &&
+ 			    !rcu_access_pointer(sk->sk_reuseport_cb) &&
+ 			    uid_eq(uid, sock_i_uid(sk2))) {
+ 				if (!bitmap)
+ 					return 0;
+ 			} else {
+ 				if (!bitmap)
+ 					return 1;
+ 				__set_bit(udp_sk(sk2)->udp_port_hash >> log,
+ 					  bitmap);
+ 			}
++>>>>>>> df560056d960 (udp: inuse checks can quit early for reuseport)
  		}
  	}
  	return 0;
@@@ -186,10 -193,14 +201,21 @@@ static int udp_lib_lport_inuse2(struct 
  		    (!sk2->sk_reuse || !sk->sk_reuse) &&
  		    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if ||
  		     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
++<<<<<<< HEAD
 +		    (!sk2->sk_reuseport || !sk->sk_reuseport ||
 +		     !uid_eq(uid, sock_i_uid(sk2))) &&
 +		    saddr_comp(sk, sk2)) {
 +			res = 1;
++=======
+ 		    saddr_comp(sk, sk2, true)) {
+ 			if (sk2->sk_reuseport && sk->sk_reuseport &&
+ 			    !rcu_access_pointer(sk->sk_reuseport_cb) &&
+ 			    uid_eq(uid, sock_i_uid(sk2))) {
+ 				res = 0;
+ 			} else {
+ 				res = 1;
+ 			}
++>>>>>>> df560056d960 (udp: inuse checks can quit early for reuseport)
  			break;
  		}
  	}
* Unmerged path net/ipv4/udp.c
