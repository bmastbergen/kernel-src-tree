intel_pstate: Avoid unnecessary synchronize_sched() during initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Chen Yu <yu.c.chen@intel.com>
commit 4578ee7e1defe534582fe3afdb747b86023207f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4578ee7e.failed

Currently, in intel_pstate_clear_update_util_hook(), after
clearing the utilization update hook, we leverage
synchronize_sched() to deal with synchronization, which
is a little bit time-costly because synchronize_sched()
has to wait for all the CPUs to go through a grace period.

Actually, the synchronize_sched() is not necessary if the utilization
update hook has not been set for the given CPU yet, so make the driver
check if that's the case and avoid the synchronize_sched() call then.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=116371
	Tested-by: Tian Ye <yex.tian@intel.com>
	Signed-off-by: Chen Yu <yu.c.chen@intel.com>
[ rjw : Rebase ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 4578ee7e1defe534582fe3afdb747b86023207f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 18143602d790,36953b5f18de..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -183,7 -187,8 +184,12 @@@ struct _pid 
  struct cpudata {
  	int cpu;
  
++<<<<<<< HEAD
 +	struct timer_list timer;
++=======
+ 	struct update_util_data update_util;
+ 	bool   update_util_set;
++>>>>>>> 4578ee7e1def (intel_pstate: Avoid unnecessary synchronize_sched() during initialization)
  
  	struct pstate_data pstate;
  	struct vid_data vid;
@@@ -1401,14 -1406,46 +1407,55 @@@ static int intel_pstate_init_cpu(unsign
  
  static unsigned int intel_pstate_get(unsigned int cpu_num)
  {
 -	struct cpudata *cpu = all_cpu_data[cpu_num];
 +	struct sample *sample;
 +	struct cpudata *cpu;
  
++<<<<<<< HEAD
 +	cpu = all_cpu_data[cpu_num];
 +	if (!cpu)
 +		return 0;
 +	sample = &cpu->sample;
 +	return sample->freq;
++=======
+ 	return cpu ? get_avg_frequency(cpu) : 0;
+ }
+ 
+ static void intel_pstate_set_update_util_hook(unsigned int cpu_num)
+ {
+ 	struct cpudata *cpu = all_cpu_data[cpu_num];
+ 
+ 	/* Prevent intel_pstate_update_util() from using stale data. */
+ 	cpu->sample.time = 0;
+ 	cpufreq_add_update_util_hook(cpu_num, &cpu->update_util,
+ 				     intel_pstate_update_util);
+ 	cpu->update_util_set = true;
+ }
+ 
+ static void intel_pstate_clear_update_util_hook(unsigned int cpu)
+ {
+ 	struct cpudata *cpu_data = all_cpu_data[cpu];
+ 
+ 	if (!cpu_data->update_util_set)
+ 		return;
+ 
+ 	cpufreq_remove_update_util_hook(cpu);
+ 	cpu_data->update_util_set = false;
+ 	synchronize_sched();
+ }
+ 
+ static void intel_pstate_set_performance_limits(struct perf_limits *limits)
+ {
+ 	limits->no_turbo = 0;
+ 	limits->turbo_disabled = 0;
+ 	limits->max_perf_pct = 100;
+ 	limits->max_perf = int_tofp(1);
+ 	limits->min_perf_pct = 100;
+ 	limits->min_perf = int_tofp(1);
+ 	limits->max_policy_pct = 100;
+ 	limits->max_sysfs_pct = 100;
+ 	limits->min_policy_pct = 0;
+ 	limits->min_sysfs_pct = 0;
++>>>>>>> 4578ee7e1def (intel_pstate: Avoid unnecessary synchronize_sched() during initialization)
  }
  
  static int intel_pstate_set_policy(struct cpufreq_policy *policy)
* Unmerged path drivers/cpufreq/intel_pstate.c
