kernfs: implement kernfs_root->supers list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tejun Heo <tj@kernel.org>
commit 7d568a8383bbb9c1f5167781075906acb2bb1550
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7d568a83.failed

Currently, there's no way to find out which super_blocks are
associated with a given kernfs_root.  Let's implement it - the planned
inotify extension to kernfs_notify() needs it.

Make kernfs_super_info point back to the super_block and chain it at
kernfs_root->supers.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7d568a8383bbb9c1f5167781075906acb2bb1550)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/mount.c
diff --cc fs/kernfs/mount.c
index 95dcd1d558bb,f25a7c0c3cdc..000000000000
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@@ -68,9 -68,10 +68,10 @@@ static int kernfs_fill_super(struct sup
  	struct inode *inode;
  	struct dentry *root;
  
+ 	info->sb = sb;
  	sb->s_blocksize = PAGE_CACHE_SIZE;
  	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 -	sb->s_magic = SYSFS_MAGIC;
 +	sb->s_magic = magic;
  	sb->s_op = &kernfs_sops;
  	sb->s_time_gran = 1;
  
@@@ -167,7 -167,9 +168,13 @@@ struct dentry *kernfs_mount_ns(struct f
  		*new_sb_created = !sb->s_root;
  
  	if (!sb->s_root) {
++<<<<<<< HEAD
 +		error = kernfs_fill_super(sb, magic);
++=======
+ 		struct kernfs_super_info *info = kernfs_info(sb);
+ 
+ 		error = kernfs_fill_super(sb);
++>>>>>>> 7d568a8383bb (kernfs: implement kernfs_root->supers list)
  		if (error) {
  			deactivate_locked_super(sb);
  			return ERR_PTR(error);
diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c
index c60dc474ff58..12ce9f9941d7 100644
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@ -702,6 +702,7 @@ struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
 		return ERR_PTR(-ENOMEM);
 
 	ida_init(&root->ino_ida);
+	INIT_LIST_HEAD(&root->supers);
 
 	kn = __kernfs_new_node(root, "", S_IFDIR | S_IRUGO | S_IXUGO,
 			       KERNFS_DIR);
diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 8be13b2a079b..dc84a3ef9ca2 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -49,6 +49,8 @@ static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
  * mount.c
  */
 struct kernfs_super_info {
+	struct super_block	*sb;
+
 	/*
 	 * The root associated with this super_block.  Each super_block is
 	 * identified by the root and ns it's associated with.
@@ -62,6 +64,9 @@ struct kernfs_super_info {
 	 * an array and compare kernfs_node tag against every entry.
 	 */
 	const void		*ns;
+
+	/* anchored at kernfs_root->supers, protected by kernfs_mutex */
+	struct list_head	node;
 };
 #define kernfs_info(SB) ((struct kernfs_super_info *)(SB->s_fs_info))
 
* Unmerged path fs/kernfs/mount.c
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 52bf5677db0b..17aa1cce6f8e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -161,6 +161,10 @@ struct kernfs_root {
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
 	struct kernfs_syscall_ops *syscall_ops;
+
+	/* list of kernfs_super_info of this root, protected by kernfs_mutex */
+	struct list_head	supers;
+
 	wait_queue_head_t	deactivate_waitq;
 };
 
