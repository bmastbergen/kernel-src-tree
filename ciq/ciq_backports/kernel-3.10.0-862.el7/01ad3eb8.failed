ovl: concurrent copy up of regular files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 01ad3eb8a07385bc8849f0ee7c800e7c8bd7287e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/01ad3eb8.failed

Now that copy up of regular file is done using O_TMPFILE,
we don't need to hold rename_lock throughout copy up.

Use the copy up waitqueue to synchronize concurrent copy up
of the same file. Different regular files can be copied up
concurrently.

The upper dir inode_lock is taken instead of rename_lock,
because it is needed for lookup and later for linking the
temp file, but it is released while copying up data.

	Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 01ad3eb8a07385bc8849f0ee7c800e7c8bd7287e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,48eb8812ac5b..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -313,9 -289,18 +313,18 @@@ static int ovl_copy_up_locked(struct de
  
  		ovl_path_upper(dentry, &upperpath);
  		BUG_ON(upperpath.dentry != NULL);
 -		upperpath.dentry = temp;
 +		upperpath.dentry = newdentry;
  
- 		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
+ 		if (tmpfile) {
+ 			inode_unlock(udir);
+ 			err = ovl_copy_up_data(lowerpath, &upperpath,
+ 					       stat->size);
+ 			inode_lock_nested(udir, I_MUTEX_PARENT);
+ 		} else {
+ 			err = ovl_copy_up_data(lowerpath, &upperpath,
+ 					       stat->size);
+ 		}
+ 
  		if (err)
  			goto out_cleanup;
  	}
@@@ -377,9 -358,10 +386,14 @@@ static int ovl_copy_up_one(struct dentr
  	int err;
  	struct kstat pstat;
  	struct path parentpath;
 -	struct dentry *lowerdentry = lowerpath->dentry;
  	struct dentry *upperdir;
++<<<<<<< HEAD
 +	struct dentry *upperdentry;
 +	char *link = NULL;
++=======
+ 	const char *link = NULL;
+ 	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
++>>>>>>> 01ad3eb8a073 (ovl: concurrent copy up of regular files)
  
  	if (WARN_ON(!workdir))
  		return -EROFS;
@@@ -412,16 -412,11 +445,24 @@@
  	}
  
  	err = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,
++<<<<<<< HEAD
 +				 stat, link);
 +	if (!err) {
 +		/* Restore timestamps on parent (best effort) */
 +		ovl_set_timestamps(upperdir, &pstat);
 +	}
 +out_unlock:
 +	unlock_rename(workdir, upperdir);
 +
 +	if (link)
 +		free_page((unsigned long) link);
++=======
+ 				 stat, link, &pstat, false);
+ out_unlock:
+ 	unlock_rename(workdir, upperdir);
+ out_done:
+ 	do_delayed_call(&done);
++>>>>>>> 01ad3eb8a073 (ovl: concurrent copy up of regular files)
  
  	return err;
  }
* Unmerged path fs/overlayfs/copy_up.c
