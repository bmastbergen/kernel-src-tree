ALSA: x86: Allow no-period-wakeup setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit e8de9859e4e834a74da824e13070aa992c32de10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e8de9859.failed

In the current implementation, the driver may update the BDs even at
PCM pointer callback.  This allows us to skip the period interrupt
effectively.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit e8de9859e4e834a74da824e13070aa992c32de10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 3dd33e089501,80b1ab9b1c57..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -127,10 -130,11 +127,11 @@@ static const struct channel_map_table m
  };
  
  /* hardware capability structure */
 -static const struct snd_pcm_hardware had_pcm_hardware = {
 +static const struct snd_pcm_hardware snd_intel_hadstream = {
  	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
  		SNDRV_PCM_INFO_MMAP |
- 		SNDRV_PCM_INFO_MMAP_VALID),
+ 		SNDRV_PCM_INFO_MMAP_VALID |
+ 		SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),
  	.formats = SNDRV_PCM_FMTBIT_S24,
  	.rates = SNDRV_PCM_RATE_32000 |
  		SNDRV_PCM_RATE_44100 |
@@@ -914,9 -790,209 +915,168 @@@ static int snd_intelhad_prog_n(u32 aud_
  	return 0;
  }
  
 -/*
 - * PCM ring buffer handling
 - *
 - * The hardware provides a ring buffer with the fixed 4 buffer descriptors
 - * (BDs).  The driver maps these 4 BDs onto the PCM ring buffer.  The mapping
 - * moves at each period elapsed.  The below illustrates how it works:
 - *
 - * At time=0
 - *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *  BD  | 0 | 1 | 2 | 3 |
 - *
 - * At time=1 (period elapsed)
 - *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *  BD      | 1 | 2 | 3 | 0 |
 - *
 - * At time=2 (second period elapsed)
 - *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *  BD          | 2 | 3 | 0 | 1 |
 - *
 - * The bd_head field points to the index of the BD to be read.  It's also the
 - * position to be filled at next.  The pcm_head and the pcm_filled fields
 - * point to the indices of the current position and of the next position to
 - * be filled, respectively.  For PCM buffer there are both _head and _filled
 - * because they may be difference when nperiods > 4.  For example, in the
 - * example above at t=1, bd_head=1 and pcm_head=1 while pcm_filled=5:
 - *
 - * pcm_head (=1) --v               v-- pcm_filled (=5)
 - *       PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
 - *       BD      | 1 | 2 | 3 | 0 |
 - *  bd_head (=1) --^               ^-- next to fill (= bd_head)
 - *
 - * For nperiods < 4, the remaining BDs out of 4 are marked as invalid, so that
 - * the hardware skips those BDs in the loop.
 - *
 - * An exceptional setup is the case with nperiods=1.  Since we have to update
 - * BDs after finishing one BD processing, we'd need at least two BDs, where
 - * both BDs point to the same content, the same address, the same size of the
 - * whole PCM buffer.
 - */
 -
 -#define AUD_BUF_ADDR(x)		(AUD_BUF_A_ADDR + (x) * HAD_REG_WIDTH)
 -#define AUD_BUF_LEN(x)		(AUD_BUF_A_LENGTH + (x) * HAD_REG_WIDTH)
 -
 -/* Set up a buffer descriptor at the "filled" position */
 -static void had_prog_bd(struct snd_pcm_substream *substream,
 -			struct snd_intelhad *intelhaddata)
 +void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata)
  {
++<<<<<<< HEAD
 +	u32 hdmi_status, i = 0;
++=======
+ 	int idx = intelhaddata->bd_head;
+ 	int ofs = intelhaddata->pcmbuf_filled * intelhaddata->period_bytes;
+ 	u32 addr = substream->runtime->dma_addr + ofs;
+ 
+ 	addr |= AUD_BUF_VALID;
+ 	if (!substream->runtime->no_period_wakeup)
+ 		addr |= AUD_BUF_INTR_EN;
+ 	had_write_register(intelhaddata, AUD_BUF_ADDR(idx), addr);
+ 	had_write_register(intelhaddata, AUD_BUF_LEN(idx),
+ 			   intelhaddata->period_bytes);
+ 
+ 	/* advance the indices to the next */
+ 	intelhaddata->bd_head++;
+ 	intelhaddata->bd_head %= intelhaddata->num_bds;
+ 	intelhaddata->pcmbuf_filled++;
+ 	intelhaddata->pcmbuf_filled %= substream->runtime->periods;
+ }
+ 
+ /* invalidate a buffer descriptor with the given index */
+ static void had_invalidate_bd(struct snd_intelhad *intelhaddata,
+ 			      int idx)
+ {
+ 	had_write_register(intelhaddata, AUD_BUF_ADDR(idx), 0);
+ 	had_write_register(intelhaddata, AUD_BUF_LEN(idx), 0);
+ }
+ 
+ /* Initial programming of ring buffer */
+ static void had_init_ringbuf(struct snd_pcm_substream *substream,
+ 			     struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_runtime *runtime = substream->runtime;
+ 	int i, num_periods;
+ 
+ 	num_periods = runtime->periods;
+ 	intelhaddata->num_bds = min(num_periods, HAD_NUM_OF_RING_BUFS);
+ 	/* set the minimum 2 BDs for num_periods=1 */
+ 	intelhaddata->num_bds = max(intelhaddata->num_bds, 2U);
+ 	intelhaddata->period_bytes =
+ 		frames_to_bytes(runtime, runtime->period_size);
+ 	WARN_ON(intelhaddata->period_bytes & 0x3f);
+ 
+ 	intelhaddata->bd_head = 0;
+ 	intelhaddata->pcmbuf_head = 0;
+ 	intelhaddata->pcmbuf_filled = 0;
+ 
+ 	for (i = 0; i < HAD_NUM_OF_RING_BUFS; i++) {
+ 		if (i < intelhaddata->num_bds)
+ 			had_prog_bd(substream, intelhaddata);
+ 		else /* invalidate the rest */
+ 			had_invalidate_bd(intelhaddata, i);
+ 	}
+ 
+ 	intelhaddata->bd_head = 0; /* reset at head again before starting */
+ }
+ 
+ /* process a bd, advance to the next */
+ static void had_advance_ringbuf(struct snd_pcm_substream *substream,
+ 				struct snd_intelhad *intelhaddata)
+ {
+ 	int num_periods = substream->runtime->periods;
+ 
+ 	/* reprogram the next buffer */
+ 	had_prog_bd(substream, intelhaddata);
+ 
+ 	/* proceed to next */
+ 	intelhaddata->pcmbuf_head++;
+ 	intelhaddata->pcmbuf_head %= num_periods;
+ }
+ 
+ /* process the current BD(s);
+  * returns the current PCM buffer byte position, or -EPIPE for underrun.
+  */
+ static int had_process_ringbuf(struct snd_pcm_substream *substream,
+ 			       struct snd_intelhad *intelhaddata)
+ {
+ 	int len, processed;
+ 	unsigned long flags;
+ 
+ 	processed = 0;
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	for (;;) {
+ 		/* get the remaining bytes on the buffer */
+ 		had_read_register(intelhaddata,
+ 				  AUD_BUF_LEN(intelhaddata->bd_head),
+ 				  &len);
+ 		if (len < 0 || len > intelhaddata->period_bytes) {
+ 			dev_dbg(intelhaddata->dev, "Invalid buf length %d\n",
+ 				len);
+ 			len = -EPIPE;
+ 			goto out;
+ 		}
+ 
+ 		if (len > 0) /* OK, this is the current buffer */
+ 			break;
+ 
+ 		/* len=0 => already empty, check the next buffer */
+ 		if (++processed >= intelhaddata->num_bds) {
+ 			len = -EPIPE; /* all empty? - report underrun */
+ 			goto out;
+ 		}
+ 		had_advance_ringbuf(substream, intelhaddata);
+ 	}
+ 
+ 	len = intelhaddata->period_bytes - len;
+ 	len += intelhaddata->period_bytes * intelhaddata->pcmbuf_head;
+  out:
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 	return len;
+ }
+ 
+ /* called from irq handler */
+ static void had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	if (!intelhaddata->connected)
+ 		return; /* disconnected? - bail out */
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 	if (!substream)
+ 		return; /* no stream? - bail out */
+ 
+ 	/* process or stop the stream */
+ 	if (had_process_ringbuf(substream, intelhaddata) < 0)
+ 		snd_pcm_stop_xrun(substream);
+ 	else
+ 		snd_pcm_period_elapsed(substream);
+ 
+ 	had_substream_put(intelhaddata);
+ }
+ 
+ #define MAX_CNT			0xFF
+ 
+ /*
+  * The interrupt status 'sticky' bits might not be cleared by
+  * setting '1' to that bit once...
+  */
+ static void wait_clear_underrun_bit(struct snd_intelhad *intelhaddata)
+ {
+ 	int i;
+ 	u32 val;
+ 
+ 	for (i = 0; i < MAX_CNT; i++) {
+ 		/* clear bit30, 31 AUD_HDMI_STATUS */
+ 		had_read_register(intelhaddata, AUD_HDMI_STATUS, &val);
+ 		if (!(val & AUD_HDMI_STATUS_MASK_UNDERRUN))
+ 			return;
+ 		had_write_register(intelhaddata, AUD_HDMI_STATUS, val);
+ 	}
+ 	dev_err(intelhaddata->dev, "Unable to clear UNDERRUN bits\n");
+ }
+ 
+ /* called from irq handler */
+ static void had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
++>>>>>>> e8de9859e4e8 (ALSA: x86: Allow no-period-wakeup setup)
  
  	/* Handle Underrun interrupt within Audio Unit */
  	had_write_register(intelhaddata, AUD_CONFIG, 0);
* Unmerged path sound/x86/intel_hdmi_audio.c
