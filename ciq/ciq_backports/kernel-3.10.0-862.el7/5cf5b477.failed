ovl: opaque cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 5cf5b477f0ca33f56a30c7ec00e61a6204da2efb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5cf5b477.failed

oe->opaque is set for

 a) whiteouts
 b) directories having the "trusted.overlay.opaque" xattr

Case b can be simplified, since setting the xattr always implies setting
oe->opaque.  Also once set, the opaque flag is never cleared.

Don't need to set opaque flag for non-directories.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 5cf5b477f0ca33f56a30c7ec00e61a6204da2efb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/dir.c
index c82fdefe6d3b,76e39aaaa038..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -954,18 -1002,22 +960,37 @@@ static int ovl_rename(struct inode *old
  	if (WARN_ON(olddentry->d_inode == newdentry->d_inode))
  		goto out_dput;
  
++<<<<<<< HEAD
 +	if (is_dir && !old_opaque && ovl_lower_positive(new)) {
 +		err = ovl_set_opaque(olddentry);
 +		if (err)
 +			goto out_dput;
 +		ovl_dentry_set_opaque(old, true);
 +	}
 +	if (!overwrite &&
 +	    new_is_dir && !new_opaque && ovl_lower_positive(old)) {
 +		err = ovl_set_opaque(newdentry);
 +		if (err)
 +			goto out_dput;
 +		ovl_dentry_set_opaque(new, true);
++=======
+ 	err = 0;
+ 	if (is_dir) {
+ 		if (ovl_type_merge_or_lower(old))
+ 			err = ovl_set_redirect(old, samedir);
+ 		else if (!old_opaque && ovl_lower_positive(new))
+ 			err = ovl_set_opaque(old, olddentry);
+ 		if (err)
+ 			goto out_dput;
+ 	}
+ 	if (!overwrite && new_is_dir) {
+ 		if (ovl_type_merge_or_lower(new))
+ 			err = ovl_set_redirect(new, samedir);
+ 		else if (!new_opaque && ovl_lower_positive(old))
+ 			err = ovl_set_opaque(new, newdentry);
+ 		if (err)
+ 			goto out_dput;
++>>>>>>> 5cf5b477f0ca (ovl: opaque cleanup)
  	}
  
  	err = ovl_do_rename(old_upperdir->d_inode, olddentry,
diff --cc fs/overlayfs/overlayfs.h
index 6d920ffce215,a83de5d5b8a0..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -152,28 +151,41 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
 +bool ovl_lower_positive(struct dentry *dentry);
  bool ovl_dentry_is_whiteout(struct dentry *dentry);
++<<<<<<< HEAD
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
++=======
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ void ovl_clear_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_inode_init(struct inode *inode, struct inode *realinode,
+ 		    bool is_upper);
+ void ovl_inode_update(struct inode *inode, struct inode *upperinode);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
++>>>>>>> 5cf5b477f0ca (ovl: opaque cleanup)
  bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
  struct file *ovl_path_open(struct path *path, int flags);
  
 -/* namei.c */
 -int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
 -bool ovl_lower_positive(struct dentry *dentry);
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
* Unmerged path fs/overlayfs/util.c
diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c
index d5488899e537..9da4d0238eda 100644
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@ -337,12 +337,6 @@ static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
 	ovl_dentry_update(dentry, newdentry);
 	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 	newdentry = NULL;
-
-	/*
-	 * Non-directores become opaque when copied up.
-	 */
-	if (!S_ISDIR(stat->mode))
-		ovl_dentry_set_opaque(dentry, true);
 out2:
 	dput(upper);
 out1:
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/util.c
