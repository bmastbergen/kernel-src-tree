ip6_tunnel: disable caching when the traffic class is inherited

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit b5c2d49544e5930c96e2632a7eece3f4325a1888
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b5c2d495.failed

If an ip6 tunnel is configured to inherit the traffic class from
the inner header, the dst_cache must be disabled or it will foul
the policy routing.

The issue is apprently there since at leat Linux-2.6.12-rc2.

	Reported-by: Liam McBirnie <liam.mcbirnie@boeing.com>
	Cc: Liam McBirnie <liam.mcbirnie@boeing.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b5c2d49544e5930c96e2632a7eece3f4325a1888)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index aa21696048ee,0a4759b89da2..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1020,9 -1032,19 +1020,16 @@@ int ip6_tnl_xmit(struct sk_buff *skb, s
  	struct dst_entry *dst = NULL, *ndst = NULL;
  	struct net_device *tdev;
  	int mtu;
++<<<<<<< HEAD
 +	unsigned int max_headroom = sizeof(struct ipv6hdr);
++=======
+ 	unsigned int psh_hlen = sizeof(struct ipv6hdr) + t->encap_hlen;
+ 	unsigned int max_headroom = psh_hlen;
+ 	bool use_cache = false;
+ 	u8 hop_limit;
++>>>>>>> b5c2d49544e5 (ip6_tunnel: disable caching when the traffic class is inherited)
  	int err = -1;
  
 -	if (t->parms.collect_md) {
 -		hop_limit = skb_tunnel_info(skb)->key.ttl;
 -		goto route_lookup;
 -	} else {
 -		hop_limit = t->parms.hop_limit;
 -	}
 -
  	/* NBMA tunnel */
  	if (ipv6_addr_any(&t->parms.raddr)) {
  		struct in6_addr *addr6;
@@@ -1119,12 -1155,15 +1134,22 @@@
  		skb = new_skb;
  	}
  
++<<<<<<< HEAD
 +	if (!fl6->flowi6_mark && ndst)
 +		dst_cache_set_ip6(&t->dst_cache, ndst, &fl6->saddr);
++=======
+ 	if (t->parms.collect_md) {
+ 		if (t->encap.type != TUNNEL_ENCAP_NONE)
+ 			goto tx_err_dst_release;
+ 	} else {
+ 		if (use_cache && ndst)
+ 			dst_cache_set_ip6(&t->dst_cache, ndst, &fl6->saddr);
+ 	}
++>>>>>>> b5c2d49544e5 (ip6_tunnel: disable caching when the traffic class is inherited)
  	skb_dst_set(skb, dst);
  
 +	skb->transport_header = skb->network_header;
 +
  	if (encap_limit >= 0) {
  		init_tel_txopt(&opt, encap_limit);
  		ipv6_push_nfrag_opts(skb, &opt.ops, &proto, NULL);
* Unmerged path net/ipv6/ip6_tunnel.c
