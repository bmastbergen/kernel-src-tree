mmc: sdhci-pci: Add support for Intel CNP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit bc55dcd822f98cd7c170d0aeac4ed4fb79c86bda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bc55dcd8.failed

Add PCI ids and enhanced strobe support for Intel CNP. This is combined
with GLK due to the pending CMDQ support which they both share.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit bc55dcd822f98cd7c170d0aeac4ed4fb79c86bda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-pci-core.c
diff --cc drivers/mmc/host/sdhci-pci-core.c
index 97cceea4baa8,8fa84a013be4..000000000000
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@@ -474,9 -568,111 +491,115 @@@ static const struct sdhci_ops sdhci_int
  	.reset			= sdhci_reset,
  	.set_uhs_signaling	= sdhci_set_uhs_signaling,
  	.hw_reset		= sdhci_pci_hw_reset,
 +	.select_drive_strength	= sdhci_pci_select_drive_strength,
  };
  
++<<<<<<< HEAD
++=======
+ static void byt_read_dsm(struct sdhci_pci_slot *slot)
+ {
+ 	struct intel_host *intel_host = sdhci_pci_priv(slot);
+ 	struct device *dev = &slot->chip->pdev->dev;
+ 	struct mmc_host *mmc = slot->host->mmc;
+ 
+ 	intel_dsm_init(intel_host, dev, mmc);
+ 	slot->chip->rpm_retune = intel_host->d3_retune;
+ }
+ 
+ static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)
+ {
+ 	byt_read_dsm(slot);
+ 	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
+ 				 MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
+ 				 MMC_CAP_CMD_DURING_TFR |
+ 				 MMC_CAP_WAIT_WHILE_BUSY;
+ 	slot->host->mmc->caps2 |= MMC_CAP2_HC_ERASE_SZ;
+ 	slot->hw_reset = sdhci_pci_int_hw_reset;
+ 	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BSW_EMMC)
+ 		slot->host->timeout_clk = 1000; /* 1000 kHz i.e. 1 MHz */
+ 	slot->host->mmc_host_ops.select_drive_strength =
+ 						intel_select_drive_strength;
+ 	return 0;
+ }
+ 
+ static int glk_emmc_probe_slot(struct sdhci_pci_slot *slot)
+ {
+ 	int ret = byt_emmc_probe_slot(slot);
+ 
+ 	if (slot->chip->pdev->device != PCI_DEVICE_ID_INTEL_GLK_EMMC) {
+ 		slot->host->mmc->caps2 |= MMC_CAP2_HS400_ES,
+ 		slot->host->mmc_host_ops.hs400_enhanced_strobe =
+ 						intel_hs400_enhanced_strobe;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_ACPI
+ static int ni_set_max_freq(struct sdhci_pci_slot *slot)
+ {
+ 	acpi_status status;
+ 	unsigned long long max_freq;
+ 
+ 	status = acpi_evaluate_integer(ACPI_HANDLE(&slot->chip->pdev->dev),
+ 				       "MXFQ", NULL, &max_freq);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&slot->chip->pdev->dev,
+ 			"MXFQ not found in acpi table\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	slot->host->mmc->f_max = max_freq * 1000000;
+ 
+ 	return 0;
+ }
+ #else
+ static inline int ni_set_max_freq(struct sdhci_pci_slot *slot)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ static int ni_byt_sdio_probe_slot(struct sdhci_pci_slot *slot)
+ {
+ 	int err;
+ 
+ 	byt_read_dsm(slot);
+ 
+ 	err = ni_set_max_freq(slot);
+ 	if (err)
+ 		return err;
+ 
+ 	slot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |
+ 				 MMC_CAP_WAIT_WHILE_BUSY;
+ 	return 0;
+ }
+ 
+ static int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)
+ {
+ 	byt_read_dsm(slot);
+ 	slot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |
+ 				 MMC_CAP_WAIT_WHILE_BUSY;
+ 	return 0;
+ }
+ 
+ static int byt_sd_probe_slot(struct sdhci_pci_slot *slot)
+ {
+ 	byt_read_dsm(slot);
+ 	slot->host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY |
+ 				 MMC_CAP_AGGRESSIVE_PM;
+ 	slot->cd_idx = 0;
+ 	slot->cd_override_level = true;
+ 	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BXT_SD ||
+ 	    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BXTM_SD ||
+ 	    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_APL_SD ||
+ 	    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_GLK_SD)
+ 		slot->host->mmc_host_ops.get_cd = bxt_get_cd;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> bc55dcd822f9 (mmc: sdhci-pci: Add support for Intel CNP)
  static const struct sdhci_pci_fixes sdhci_intel_byt_emmc = {
  	.allow_runtime_pm = true,
  	.probe_slot	= byt_emmc_probe_slot,
@@@ -485,8 -681,20 +608,19 @@@
  			  SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 |
  			  SDHCI_QUIRK2_STOP_WITH_TC,
  	.ops		= &sdhci_intel_byt_ops,
 -	.priv_size	= sizeof(struct intel_host),
  };
  
+ static const struct sdhci_pci_fixes sdhci_intel_glk_emmc = {
+ 	.allow_runtime_pm	= true,
+ 	.probe_slot		= glk_emmc_probe_slot,
+ 	.quirks			= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+ 	.quirks2		= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+ 				  SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 |
+ 				  SDHCI_QUIRK2_STOP_WITH_TC,
+ 	.ops			= &sdhci_intel_byt_ops,
+ 	.priv_size		= sizeof(struct intel_host),
+ };
+ 
  static const struct sdhci_pci_fixes sdhci_ni_byt_sdio = {
  	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
  	.quirks2	= SDHCI_QUIRK2_HOST_OFF_CARD_ON |
* Unmerged path drivers/mmc/host/sdhci-pci-core.c
diff --git a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
index 978100ee1577..f8d22ce1633e 100644
--- a/drivers/mmc/host/sdhci-pci.h
+++ b/drivers/mmc/host/sdhci-pci.h
@@ -37,6 +37,9 @@
 #define PCI_DEVICE_ID_INTEL_GLK_SD	0x31ca
 #define PCI_DEVICE_ID_INTEL_GLK_EMMC	0x31cc
 #define PCI_DEVICE_ID_INTEL_GLK_SDIO	0x31d0
+#define PCI_DEVICE_ID_INTEL_CNP_EMMC	0x9dc4
+#define PCI_DEVICE_ID_INTEL_CNP_SD	0x9df5
+#define PCI_DEVICE_ID_INTEL_CNPH_SD	0xa375
 
 #define PCI_DEVICE_ID_SYSKONNECT_8000	0x8000
 #define PCI_DEVICE_ID_VIA_95D0		0x95d0
