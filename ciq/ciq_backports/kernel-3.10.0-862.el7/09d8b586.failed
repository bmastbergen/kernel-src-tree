ovl: move __upperdentry to ovl_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 09d8b586731bf589655c2ac971532c14cf272b63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/09d8b586.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 09d8b586731bf589655c2ac971532c14cf272b63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/inode.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,87289b9a152c..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -334,20 -416,14 +334,25 @@@ static int ovl_copy_up_locked(struct de
  	if (err)
  		goto out_cleanup;
  
++<<<<<<< HEAD
 +	ovl_dentry_update(dentry, newdentry);
 +	ovl_inode_update(d_inode(dentry), d_inode(newdentry));
 +	newdentry = NULL;
++=======
+ 	newdentry = dget(tmpfile ? upper : temp);
+ 	ovl_inode_update(d_inode(dentry), newdentry);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  
 -	/* Restore timestamps on parent (best effort) */
 -	ovl_set_timestamps(upperdir, pstat);
 -out:
 -	dput(temp);
 +	/*
 +	 * Non-directores become opaque when copied up.
 +	 */
 +	if (!S_ISDIR(stat->mode))
 +		ovl_dentry_set_opaque(dentry, true);
 +out2:
  	dput(upper);
 +out1:
 +	dput(newdentry);
 +out:
  	return err;
  
  out_cleanup:
diff --cc fs/overlayfs/inode.c
index e60c6d748742,4654c03dd508..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -436,18 -463,35 +437,49 @@@ static int ovl_inode_set(struct inode *
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode)
 +
 +{
 +	struct inode *inode;
 +
 +	inode = iget5_locked(sb, (unsigned long) realinode,
 +			     ovl_inode_test, ovl_inode_set, realinode);
 +	if (inode && inode->i_state & I_NEW) {
 +		ovl_fill_inode(inode, realinode->i_mode);
 +		set_nlink(inode, realinode->i_nlink);
++=======
+ struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry)
+ {
+ 	struct dentry *lowerdentry = ovl_dentry_lower(dentry);
+ 	struct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;
+ 	struct inode *inode;
+ 
+ 	if (!realinode)
+ 		realinode = d_inode(lowerdentry);
+ 
+ 	if (upperdentry && !d_is_dir(upperdentry)) {
+ 		inode = iget5_locked(dentry->d_sb, (unsigned long) realinode,
+ 				     ovl_inode_test, ovl_inode_set, realinode);
+ 		if (!inode)
+ 			goto out;
+ 		if (!(inode->i_state & I_NEW)) {
+ 			dput(upperdentry);
+ 			goto out;
+ 		}
+ 
+ 		set_nlink(inode, realinode->i_nlink);
+ 	} else {
+ 		inode = new_inode(dentry->d_sb);
+ 		if (!inode)
+ 			goto out;
+ 	}
+ 	ovl_fill_inode(inode, realinode->i_mode, realinode->i_rdev);
+ 	ovl_inode_init(inode, upperdentry, lowerdentry);
+ 	if (inode->i_state & I_NEW)
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  		unlock_new_inode(inode);
 -out:
 +	}
 +
  	return inode;
  }
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,83607f883ace..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -151,27 -189,43 +151,66 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
++<<<<<<< HEAD
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
++=======
+ struct inode *ovl_inode_upper(struct inode *inode);
+ struct inode *ovl_inode_lower(struct inode *inode);
+ struct inode *ovl_inode_real(struct inode *inode);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_impure(struct dentry *dentry);
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+ 		    struct dentry *lowerdentry);
+ void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+ 		       const char *name, const void *value, size_t size,
+ 		       int xerr);
+ int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+ 
+ static inline bool ovl_is_impuredir(struct dentry *dentry)
+ {
+ 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+ }
+ 
+ 
+ /* namei.c */
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
@@@ -195,8 -251,8 +234,13 @@@ int ovl_open_maybe_copy_up(struct dentr
  int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
  bool ovl_is_private_xattr(const char *name);
  
++<<<<<<< HEAD
 +struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
 +struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
++=======
+ struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
+ struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  static inline void ovl_copyattr(struct inode *from, struct inode *to)
  {
  	to->i_uid = from->i_uid;
diff --cc fs/overlayfs/super.c
index aaf06952d88f,1b865716110a..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -295,7 -41,7 +295,11 @@@ static void ovl_dentry_release(struct d
  	if (oe) {
  		unsigned int i;
  
++<<<<<<< HEAD
 +		dput(oe->__upperdentry);
++=======
+ 		kfree(oe->redirect);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  		for (i = 0; i < oe->numlower; i++)
  			dput(oe->lowerstack[i].dentry);
  		kfree_rcu(oe, rcu);
@@@ -415,282 -157,39 +419,295 @@@ static const struct dentry_operations_w
  	.d_real = ovl_d_real,
  };
  
 -static const struct dentry_operations ovl_reval_dentry_operations = {
 -	.d_release = ovl_dentry_release,
 +static const struct dentry_operations_wrapper ovl_reval_dentry_operations = {
 +	.ops = {
 +		.d_release = ovl_dentry_release,
 +		.d_revalidate = ovl_dentry_revalidate,
 +		.d_weak_revalidate = ovl_dentry_weak_revalidate,
 +	},
 +	.size = sizeof(struct dentry_operations_wrapper),
  	.d_real = ovl_d_real,
 -	.d_revalidate = ovl_dentry_revalidate,
 -	.d_weak_revalidate = ovl_dentry_weak_revalidate,
  };
  
 -static struct kmem_cache *ovl_inode_cachep;
 -
 -static struct inode *ovl_alloc_inode(struct super_block *sb)
 +static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)
  {
 -	struct ovl_inode *oi = kmem_cache_alloc(ovl_inode_cachep, GFP_KERNEL);
 +	size_t size = offsetof(struct ovl_entry, lowerstack[numlower]);
 +	struct ovl_entry *oe = kzalloc(size, GFP_KERNEL);
  
++<<<<<<< HEAD
 +	if (oe)
 +		oe->numlower = numlower;
++=======
+ 	oi->__upperdentry = NULL;
+ 	oi->lower = NULL;
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
 +
 +	return oe;
 +}
 +
 +static bool ovl_dentry_remote(struct dentry *dentry)
 +{
 +	return dentry->d_flags &
 +		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE |
 +		 DCACHE_OP_REAL);
 +}
 +
 +static bool ovl_dentry_weird(struct dentry *dentry)
 +{
++<<<<<<< HEAD
 +	return dentry->d_flags & (DCACHE_NEED_AUTOMOUNT |
 +				  DCACHE_MANAGE_TRANSIT |
 +				  DCACHE_OP_HASH |
 +				  DCACHE_OP_COMPARE);
 +}
  
 -	return &oi->vfs_inode;
 +static inline struct dentry *ovl_lookup_real(struct dentry *dir,
 +					     const struct qstr *name)
 +{
 +	struct dentry *dentry;
 +
 +	dentry = lookup_one_len_unlocked(name->name, dir, name->len);
 +	if (IS_ERR(dentry)) {
 +		if (PTR_ERR(dentry) == -ENOENT)
 +			dentry = NULL;
 +	} else if (!dentry->d_inode) {
 +		dput(dentry);
 +		dentry = NULL;
 +	} else if (ovl_dentry_weird(dentry)) {
 +		dput(dentry);
 +		/* Don't support traversing automounts and other weirdness */
 +		dentry = ERR_PTR(-EREMOTE);
 +	}
 +	return dentry;
  }
  
 -static void ovl_i_callback(struct rcu_head *head)
 +/*
 + * Returns next layer in stack starting from top.
 + * Returns -1 if this is the last layer.
 + */
 +int ovl_path_next(int idx, struct dentry *dentry, struct path *path)
  {
 -	struct inode *inode = container_of(head, struct inode, i_rcu);
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +
 +	BUG_ON(idx < 0);
 +	if (idx == 0) {
 +		ovl_path_upper(dentry, path);
 +		if (path->dentry)
 +			return oe->numlower ? 1 : -1;
 +		idx++;
 +	}
 +	BUG_ON(idx > oe->numlower);
 +	*path = oe->lowerstack[idx - 1];
  
 -	kmem_cache_free(ovl_inode_cachep, OVL_I(inode));
 +	return (idx < oe->numlower) ? idx + 1 : -1;
  }
  
 -static void ovl_destroy_inode(struct inode *inode)
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags)
  {
 +	struct ovl_entry *oe;
 +	const struct cred *old_cred;
 +	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 +	struct path *stack = NULL;
 +	struct dentry *upperdir, *upperdentry = NULL;
 +	unsigned int ctr = 0;
 +	struct inode *inode = NULL;
 +	bool upperopaque = false;
 +	bool stop = false;
 +	bool isdir = false;
 +	struct dentry *this;
 +	unsigned int i;
 +	int err;
 +
 +	old_cred = ovl_override_creds(dentry->d_sb);
 +	upperdir = ovl_upperdentry_dereference(poe);
 +	if (upperdir) {
 +		this = ovl_lookup_real(upperdir, &dentry->d_name);
 +		err = PTR_ERR(this);
 +		if (IS_ERR(this))
 +			goto out;
 +
 +		if (this) {
 +			if (unlikely(ovl_dentry_remote(this))) {
 +				dput(this);
 +				err = -EREMOTE;
 +				goto out;
 +			}
 +			if (ovl_is_whiteout(this)) {
 +				dput(this);
 +				this = NULL;
 +				stop = upperopaque = true;
 +			} else if (!d_is_dir(this)) {
 +				stop = true;
 +			} else {
 +				isdir = true;
 +				if (poe->numlower && ovl_is_opaquedir(this))
 +					stop = upperopaque = true;
 +			}
 +		}
 +		upperdentry = this;
 +	}
 +
 +	if (!stop && poe->numlower) {
 +		err = -ENOMEM;
 +		stack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);
 +		if (!stack)
 +			goto out_put_upper;
 +	}
 +
 +	for (i = 0; !stop && i < poe->numlower; i++) {
 +		struct path lowerpath = poe->lowerstack[i];
 +
 +		this = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);
 +		err = PTR_ERR(this);
 +		if (IS_ERR(this)) {
 +			/*
 +			 * If it's positive, then treat ENAMETOOLONG as ENOENT.
 +			 */
 +			if (err == -ENAMETOOLONG && (upperdentry || ctr))
 +				continue;
 +			goto out_put;
 +		}
 +		if (!this)
 +			continue;
 +		if (ovl_is_whiteout(this)) {
 +			dput(this);
 +			break;
 +		}
 +		/*
 +		 * If this is a non-directory then stop here.
 +		 */
 +		if (!d_is_dir(this)) {
 +			if (isdir) {
 +				dput(this);
 +				break;
 +			}
 +			stop = true;
 +		} else {
 +			/*
 +			 * Only makes sense to check opaque dir if this is not
 +			 * the lowermost layer.
 +			 */
 +			if (i < poe->numlower - 1 && ovl_is_opaquedir(this))
 +				stop = true;
 +		}
 +
 +		stack[ctr].dentry = this;
 +		stack[ctr].mnt = lowerpath.mnt;
 +		ctr++;
 +	}
 +
 +	oe = ovl_alloc_entry(ctr);
 +	err = -ENOMEM;
 +	if (!oe)
 +		goto out_put;
 +
 +	if (upperdentry || ctr) {
 +		struct dentry *realdentry;
 +		struct inode *realinode;
 +
 +		realdentry = upperdentry ? upperdentry : stack[0].dentry;
 +		realinode = d_inode(realdentry);
 +
 +		err = -ENOMEM;
 +		if (upperdentry && !d_is_dir(upperdentry)) {
 +			inode = ovl_get_inode(dentry->d_sb, realinode);
 +		} else {
 +			inode = ovl_new_inode(dentry->d_sb, realinode->i_mode);
 +			if (inode)
 +				ovl_inode_init(inode, realinode, !!upperdentry);
 +		}
 +		if (!inode)
 +			goto out_free_oe;
 +		ovl_copyattr(realdentry->d_inode, inode);
 +	}
 +
 +	revert_creds(old_cred);
 +	oe->opaque = upperopaque;
 +	oe->__upperdentry = upperdentry;
 +	memcpy(oe->lowerstack, stack, sizeof(struct path) * ctr);
 +	kfree(stack);
 +	dentry->d_fsdata = oe;
 +	d_add(dentry, inode);
 +
 +	return NULL;
 +
 +out_free_oe:
 +	kfree(oe);
 +out_put:
 +	for (i = 0; i < ctr; i++)
 +		dput(stack[i].dentry);
 +	kfree(stack);
 +out_put_upper:
 +	dput(upperdentry);
 +out:
 +	revert_creds(old_cred);
 +	return ERR_PTR(err);
 +}
 +
 +bool ovl_lower_positive(struct dentry *dentry)
 +{
 +	struct ovl_entry *oe = dentry->d_fsdata;
 +	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
 +	const struct qstr *name = &dentry->d_name;
 +	unsigned int i;
 +	bool positive = false;
 +	bool done = false;
 +
 +	/*
 +	 * If dentry is negative, then lower is positive iff this is a
 +	 * whiteout.
 +	 */
 +	if (!dentry->d_inode)
 +		return oe->opaque;
 +
 +	/* Negative upper -> positive lower */
 +	if (!oe->__upperdentry)
 +		return true;
 +
 +	/* Positive upper -> have to look up lower to see whether it exists */
 +	for (i = 0; !done && !positive && i < poe->numlower; i++) {
 +		struct dentry *this;
 +		struct dentry *lowerdir = poe->lowerstack[i].dentry;
 +
 +		this = lookup_one_len_unlocked(name->name, lowerdir,
 +					       name->len);
 +		if (IS_ERR(this)) {
 +			switch (PTR_ERR(this)) {
 +			case -ENOENT:
 +			case -ENAMETOOLONG:
 +				break;
 +
 +			default:
 +				/*
 +				 * Assume something is there, we just couldn't
 +				 * access it.
 +				 */
 +				positive = true;
 +				break;
 +			}
 +		} else {
 +			if (this->d_inode) {
 +				positive = !ovl_is_whiteout(this);
 +				done = true;
 +			}
 +			dput(this);
 +		}
 +	}
 +
 +	return positive;
 +}
 +
 +struct file *ovl_path_open(struct path *path, int flags)
 +{
 +	return dentry_open(path, flags | O_NOATIME, current_cred());
++=======
+ 	struct ovl_inode *oi = OVL_I(inode);
+ 
+ 	dput(oi->__upperdentry);
+ 
+ 	call_rcu(&inode->i_rcu, ovl_i_callback);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  }
  
  static void ovl_put_super(struct super_block *sb)
@@@ -1119,12 -633,13 +1136,16 @@@ ovl_posix_acl_xattr_get(struct dentry *
  }
  
  static int __maybe_unused
 -ovl_posix_acl_xattr_set(const struct xattr_handler *handler,
 -			struct dentry *dentry, struct inode *inode,
 +ovl_posix_acl_xattr_set(struct dentry *dentry,
  			const char *name, const void *value,
 -			size_t size, int flags)
 +			size_t size, int flags, int handler_flags)
  {
  	struct dentry *workdir = ovl_workdir(dentry);
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
++=======
+ 	struct inode *realinode = ovl_inode_real(inode);
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  	struct posix_acl *acl = NULL;
  	int err;
  
@@@ -1162,10 -679,9 +1183,10 @@@
  			return err;
  	}
  
 -	err = ovl_xattr_set(dentry, handler->name, value, size, flags);
 +	err = ovl_xattr_set(dentry, handler_flags == ACL_TYPE_DEFAULT ? XATTR_NAME_POSIX_ACL_DEFAULT : XATTR_NAME_POSIX_ACL_ACCESS,
 +			     value, size, flags);
  	if (!err)
- 		ovl_copyattr(ovl_inode_real(inode, NULL), inode);
+ 		ovl_copyattr(ovl_inode_real(inode), inode);
  
  	return err;
  
@@@ -1468,7 -1002,9 +1489,13 @@@ static int ovl_fill_super(struct super_
  	path_put(&workpath);
  	kfree(lowertmp);
  
++<<<<<<< HEAD
 +	oe->__upperdentry = upperpath.dentry;
++=======
+ 	if (upperpath.dentry) {
+ 		oe->impure = ovl_is_impuredir(upperpath.dentry);
+ 	}
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  	for (i = 0; i < numlower; i++) {
  		oe->lowerstack[i].dentry = stack[i].dentry;
  		oe->lowerstack[i].mnt = ufs->lower_mnt[i];
@@@ -1477,9 -1013,8 +1504,14 @@@
  
  	root_dentry->d_fsdata = oe;
  
++<<<<<<< HEAD
 +	realinode = d_inode(ovl_dentry_real(root_dentry));
 +	ovl_inode_init(d_inode(root_dentry), realinode, !!upperpath.dentry);
 +	ovl_copyattr(realinode, d_inode(root_dentry));
++=======
+ 	ovl_inode_init(d_inode(root_dentry), upperpath.dentry,
+ 		       ovl_dentry_lower(root_dentry));
++>>>>>>> 09d8b586731b (ovl: move __upperdentry to ovl_inode)
  
  	sb->s_root = root_dentry;
  
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/util.c
* Unmerged path fs/overlayfs/copy_up.c
diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c
index 709c8eb662f9..c968e0e4b979 100644
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@ -160,12 +160,12 @@ static void ovl_instantiate(struct dentry *dentry, struct inode *inode,
 			    struct dentry *newdentry, bool hardlink)
 {
 	ovl_dentry_version_inc(dentry->d_parent);
-	ovl_dentry_update(dentry, newdentry);
 	if (!hardlink) {
-		ovl_inode_update(inode, d_inode(newdentry));
+		ovl_inode_update(inode, newdentry);
 		ovl_copyattr(newdentry->d_inode, inode);
 	} else {
-		WARN_ON(ovl_inode_real(inode, NULL) != d_inode(newdentry));
+		WARN_ON(ovl_inode_real(inode) != d_inode(newdentry));
+		dput(newdentry);
 		inc_nlink(inode);
 	}
 	d_instantiate(dentry, inode);
@@ -935,7 +935,7 @@ static int ovl_rename(struct inode *olddir, struct dentry *old,
 	new_opaque = ovl_dentry_is_opaque(new);
 
 	err = -ESTALE;
-	if (ovl_dentry_upper(new)) {
+	if (d_inode(new) && ovl_dentry_upper(new)) {
 		if (opaquedir) {
 			if (newdentry != opaquedir)
 				goto out_dput;
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
* Unmerged path fs/overlayfs/util.c
