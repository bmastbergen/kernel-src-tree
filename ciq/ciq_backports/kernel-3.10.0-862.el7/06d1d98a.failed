Drivers: hv: vmbus: Define APIs to manipulate the synthetic interrupt controller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hv] vmbus: Define APIs to manipulate the synthetic interrupt controller (Mohammed Gamal) [1467258]
Rebuild_FUZZ: 91.16%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 06d1d98a839f196e94cb726008fb2118e430f356
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/06d1d98a.failed

As part of cleaning up architecture specific code, define APIs
to manipulate the interrupt controller state.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 06d1d98a839f196e94cb726008fb2118e430f356)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,1ea19a57cf4c..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -70,6 -99,56 +70,59 @@@ static inline  __u64 generate_guest_id(
  	return guest_id;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* Free the message slot and signal end-of-message if required */
+ static inline void vmbus_signal_eom(struct hv_message *msg, u32 old_msg_type)
+ {
+ 	/*
+ 	 * On crash we're reading some other CPU's message page and we need
+ 	 * to be careful: this other CPU may already had cleared the header
+ 	 * and the host may already had delivered some other message there.
+ 	 * In case we blindly write msg->header.message_type we're going
+ 	 * to lose it. We can still lose a message of the same type but
+ 	 * we count on the fact that there can only be one
+ 	 * CHANNELMSG_UNLOAD_RESPONSE and we don't care about other messages
+ 	 * on crash.
+ 	 */
+ 	if (cmpxchg(&msg->header.message_type, old_msg_type,
+ 		    HVMSG_NONE) != old_msg_type)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure the write to MessageType (ie set to
+ 	 * HVMSG_NONE) happens before we read the
+ 	 * MessagePending and EOMing. Otherwise, the EOMing
+ 	 * will not deliver any more messages since there is
+ 	 * no empty slot
+ 	 */
+ 	mb();
+ 
+ 	if (msg->header.message_flags.msg_pending) {
+ 		/*
+ 		 * This will cause message queue rescan to
+ 		 * possibly deliver another msg from the
+ 		 * hypervisor
+ 		 */
+ 		wrmsrl(HV_X64_MSR_EOM, 0);
+ 	}
+ }
+ 
+ #define hv_get_current_tick(tick) rdmsrl(HV_X64_MSR_TIME_REF_COUNT, tick)
+ #define hv_init_timer(timer, tick) wrmsrl(timer, tick)
+ #define hv_init_timer_config(config, val) wrmsrl(config, val)
+ 
+ #define hv_get_simp(val) rdmsrl(HV_X64_MSR_SIMP, val)
+ #define hv_set_simp(val) wrmsrl(HV_X64_MSR_SIMP, val)
+ 
+ #define hv_get_siefp(val) rdmsrl(HV_X64_MSR_SIEFP, val)
+ #define hv_set_siefp(val) wrmsrl(HV_X64_MSR_SIEFP, val)
+ 
+ #define hv_get_synic_state(val) rdmsrl(HV_X64_MSR_SCONTROL, val)
+ #define hv_set_synic_state(val) wrmsrl(HV_X64_MSR_SCONTROL, val)
+ 
++>>>>>>> 06d1d98a839f (Drivers: hv: vmbus: Define APIs to manipulate the synthetic interrupt controller)
  void hyperv_callback_vector(void);
  #ifdef CONFIG_TRACING
  #define trace_hyperv_callback_vector hyperv_callback_vector
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index f6a591c69dfd..d0510ed83fb6 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -467,10 +467,10 @@ int hv_synic_init(unsigned int cpu)
 	wrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
 
 	/* Enable the global synic bit */
-	rdmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);
+	hv_get_synic_state(sctrl.as_uint64);
 	sctrl.enable = 1;
 
-	wrmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);
+	hv_set_synic_state(sctrl.as_uint64);
 
 	hv_context.synic_initialized = true;
 
@@ -586,9 +586,9 @@ int hv_synic_cleanup(unsigned int cpu)
 	wrmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);
 
 	/* Disable the global synic bit */
-	rdmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);
+	hv_get_synic_state(sctrl.as_uint64);
 	sctrl.enable = 0;
-	wrmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);
+	hv_set_synic_state(sctrl.as_uint64);
 
 	return 0;
 }
