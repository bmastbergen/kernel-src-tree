net: sched: remove check for number of actions in tcf_exts_exec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: remove check for number of actions in tcf_exts_exec (Ivan Vecera) [1445420]
Rebuild_FUZZ: 95.87%
commit-author Jiri Pirko <jiri@mellanox.com>
commit ec1a9cca0e13391167567964fd04e61a39d6a4ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec1a9cca.failed

Leave it to tcf_action_exec to return TC_ACT_OK in case there is no
action present.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec1a9cca0e13391167567964fd04e61a39d6a4ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	net/sched/act_api.c
diff --cc include/net/pkt_cls.h
index 09f92f9cf4d7,b8959c9a190d..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -121,11 -189,10 +121,15 @@@ tcf_exts_is_available(struct tcf_exts *
   */
  static inline int
  tcf_exts_exec(struct sk_buff *skb, struct tcf_exts *exts,
 -	      struct tcf_result *res)
 +	       struct tcf_result *res)
  {
  #ifdef CONFIG_NET_CLS_ACT
++<<<<<<< HEAD
 +	if (!list_empty(&exts->actions))
 +		return tcf_action_exec(skb, &exts->actions, res);
++=======
+ 	return tcf_action_exec(skb, exts->actions, exts->nr_actions, res);
++>>>>>>> ec1a9cca0e13 (net: sched: remove check for number of actions in tcf_exts_exec)
  #endif
  	return TC_ACT_OK;
  }
diff --cc net/sched/act_api.c
index f6d266c05d33,a2915d958279..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -436,18 -468,27 +436,25 @@@ static struct tc_action_ops *tc_lookup_
  	return res;
  }
  
 -/*TCA_ACT_MAX_PRIO is 32, there count upto 32 */
 -#define TCA_ACT_MAX_PRIO_MASK 0x1FF
 -int tcf_action_exec(struct sk_buff *skb, struct tc_action **actions,
 -		    int nr_actions, struct tcf_result *res)
 +int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
 +		    struct tcf_result *res)
  {
++<<<<<<< HEAD
 +	const struct tc_action *a;
 +	int ret = -1;
++=======
+ 	u32 jmp_prgcnt = 0;
+ 	u32 jmp_ttl = TCA_ACT_MAX_PRIO; /*matches actions per filter */
+ 	int i;
+ 	int ret = TC_ACT_OK;
++>>>>>>> ec1a9cca0e13 (net: sched: remove check for number of actions in tcf_exts_exec)
  
 -	if (skb_skip_tc_classify(skb))
 -		return TC_ACT_OK;
 -
 -restart_act_graph:
 -	for (i = 0; i < nr_actions; i++) {
 -		const struct tc_action *a = actions[i];
 -
 -		if (jmp_prgcnt > 0) {
 -			jmp_prgcnt -= 1;
 -			continue;
 -		}
 +	if (skb->tc_verd & TC_NCLS) {
 +		skb->tc_verd = CLR_TC_NCLS(skb->tc_verd);
 +		ret = TC_ACT_OK;
 +		goto exec_done;
 +	}
 +	list_for_each_entry(a, actions, list) {
  repeat:
  		ret = a->ops->act(skb, a, res);
  		if (ret == TC_ACT_REPEAT)
* Unmerged path include/net/pkt_cls.h
* Unmerged path net/sched/act_api.c
