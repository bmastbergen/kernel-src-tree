KVM: VMX: cache secondary exec controls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 80154d77c922d0f9bb1e4d115ff760c066c12d8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/80154d77.failed

Currently, secondary execution controls are divided in three groups:

- static, depending mostly on the module arguments or the processor
  (vmx_secondary_exec_control)

- static, depending on CPUID (vmx_cpuid_update)

- dynamic, depending on nested VMX or local APIC state

Because walking CPUID is expensive, prepare_vmcs02 is using only
the first group.  This however is unnecessarily complicated.  Just
cache the static secondary execution controls, and then prepare_vmcs02
does not need to compute them every time.  Computation of all static
secondary execution controls is now kept in a single function,
vmx_compute_secondary_exec_control.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 80154d77c922d0f9bb1e4d115ff760c066c12d8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 35bc7f099719,08381a5d8879..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2624,11 -2806,13 +2626,14 @@@ static void nested_vmx_setup_ctls_msrs(
  		CPU_BASED_USE_MSR_BITMAPS;
  
  	/* We support free control of CR3 access interception. */
 -	vmx->nested.nested_vmx_procbased_ctls_low &=
 +	vmx->nested.nested_vmx_true_procbased_ctls_low =
 +		vmx->nested.nested_vmx_procbased_ctls_low &
  		~(CPU_BASED_CR3_LOAD_EXITING | CPU_BASED_CR3_STORE_EXITING);
  
- 	/* secondary cpu-based controls */
+ 	/*
+ 	 * secondary cpu-based controls.  Do not include those that
+ 	 * depend on CPUID bits, they are added later by vmx_cpuid_update.
+ 	 */
  	rdmsr(MSR_IA32_VMX_PROCBASED_CTLS2,
  		vmx->nested.nested_vmx_secondary_ctls_low,
  		vmx->nested.nested_vmx_secondary_ctls_high);
@@@ -4839,9 -5384,12 +4881,17 @@@ static int vmx_vcpu_setup(struct vcpu_v
  
  	vmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));
  
++<<<<<<< HEAD
 +	if (cpu_has_secondary_exec_ctrls())
 +		vmcs_write32(SECONDARY_VM_EXEC_CONTROL,
 +				vmx_secondary_exec_control(vmx));
++=======
+ 	if (cpu_has_secondary_exec_ctrls()) {
+ 		vmx_compute_secondary_exec_control(vmx);
+ 		vmcs_write32(SECONDARY_VM_EXEC_CONTROL,
+ 			     vmx->secondary_exec_control);
+ 	}
++>>>>>>> 80154d77c922 (KVM: VMX: cache secondary exec controls)
  
  	if (kvm_vcpu_apicv_active(&vmx->vcpu)) {
  		vmcs_write64(EOI_EXIT_BITMAP0, 0);
@@@ -9045,49 -9622,56 +9095,56 @@@ static void vmcs_set_secondary_exec_con
  static void vmx_cpuid_update(struct kvm_vcpu *vcpu)
  {
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
- 	u32 secondary_exec_ctl = vmx_secondary_exec_control(vmx);
  
++<<<<<<< HEAD
 +	if (vmx_rdtscp_supported()) {
 +		bool rdtscp_enabled = guest_cpuid_has_rdtscp(vcpu);
 +		if (!rdtscp_enabled)
 +			secondary_exec_ctl &= ~SECONDARY_EXEC_RDTSCP;
 +
 +		if (nested) {
 +			if (rdtscp_enabled)
 +				vmx->nested.nested_vmx_secondary_ctls_high |=
 +					SECONDARY_EXEC_RDTSCP;
 +			else
 +				vmx->nested.nested_vmx_secondary_ctls_high &=
 +					~SECONDARY_EXEC_RDTSCP;
 +		}
 +	}
 +
 +	if (vmx_invpcid_supported()) {
 +		/* Exposing INVPCID only when PCID is exposed */
 +		struct kvm_cpuid_entry2 *best = kvm_find_cpuid_entry(vcpu, 0x7, 0);
 +		bool invpcid_enabled =
 +			best && best->ebx & bit(X86_FEATURE_INVPCID) &&
 +			guest_cpuid_has_pcid(vcpu);
 +
 +		if (!invpcid_enabled) {
 +			secondary_exec_ctl &= ~SECONDARY_EXEC_ENABLE_INVPCID;
 +			if (best)
 +				best->ebx &= ~bit(X86_FEATURE_INVPCID);
 +		}
 +
 +		if (nested) {
 +			if (invpcid_enabled)
 +				vmx->nested.nested_vmx_secondary_ctls_high |=
 +					SECONDARY_EXEC_ENABLE_INVPCID;
 +			else
 +				vmx->nested.nested_vmx_secondary_ctls_high &=
 +					~SECONDARY_EXEC_ENABLE_INVPCID;
 +		}
 +	}
 +
 +	if (cpu_has_secondary_exec_ctrls())
 +		vmcs_set_secondary_exec_control(secondary_exec_ctl);
 +
++=======
+ 	if (cpu_has_secondary_exec_ctrls()) {
+ 		vmx_compute_secondary_exec_control(vmx);
+ 		vmcs_set_secondary_exec_control(vmx->secondary_exec_control);
+ 	}
+ 
++>>>>>>> 80154d77c922 (KVM: VMX: cache secondary exec controls)
  	if (nested_vmx_allowed(vcpu))
  		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=
  			FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
* Unmerged path arch/x86/kvm/vmx.c
