HID: introduce hid_is_using_ll_driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [hid] introduce hid_is_using_ll_driver (Aristeu Rozanski) [1475409 1462363]
Rebuild_FUZZ: 92.75%
commit-author Jason Gerecke <killertofu@gmail.com>
commit fc2237a724a9e448599076d7d23497f51e2f7441
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fc2237a7.failed

Although HID itself is transport-agnostic, occasionally a driver may
want to interact with the low-level transport that a device is connected
through. To do this, we need to know what kind of bus is in use. The
first guess may be to look at the 'bus' field of the 'struct hid_device',
but this field may be emulated in some cases (e.g. uhid).

More ideally, we can check which ll_driver a device is using. This
function introduces a 'hid_is_using_ll_driver' function and makes the
'struct hid_ll_driver' of the four most common transports accessible
through hid.h.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
Acked-By: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit fc2237a724a9e448599076d7d23497f51e2f7441)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/uhid.c
diff --cc drivers/hid/uhid.c
index 5bfcdf88b929,6f819f144cb4..000000000000
--- a/drivers/hid/uhid.c
+++ b/drivers/hid/uhid.c
@@@ -250,30 -369,16 +250,35 @@@ static int uhid_hid_output_report(struc
  	return uhid_hid_output_raw(hid, buf, count, HID_OUTPUT_REPORT);
  }
  
++<<<<<<< HEAD
 +static int uhid_raw_request(struct hid_device *hid, unsigned char reportnum,
 +			    __u8 *buf, size_t len, unsigned char rtype,
 +			    int reqtype)
 +{
 +	switch (reqtype) {
 +	case HID_REQ_GET_REPORT:
 +		return uhid_hid_get_raw(hid, reportnum, buf, len, rtype);
 +	case HID_REQ_SET_REPORT:
 +		/* TODO: implement proper SET_REPORT functionality */
 +		return -ENOSYS;
 +	default:
 +		return -EIO;
 +	}
 +}
 +
 +static struct hid_ll_driver uhid_hid_driver = {
++=======
+ struct hid_ll_driver uhid_hid_driver = {
++>>>>>>> fc2237a724a9 (HID: introduce hid_is_using_ll_driver)
  	.start = uhid_hid_start,
  	.stop = uhid_hid_stop,
  	.open = uhid_hid_open,
  	.close = uhid_hid_close,
  	.parse = uhid_hid_parse,
 -	.raw_request = uhid_hid_raw_request,
  	.output_report = uhid_hid_output_report,
 +	.raw_request = uhid_raw_request,
  };
+ EXPORT_SYMBOL_GPL(uhid_hid_driver);
  
  #ifdef CONFIG_COMPAT
  
diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c
index 0136149c9ee8..449bd7b1178a 100644
--- a/drivers/hid/i2c-hid/i2c-hid.c
+++ b/drivers/hid/i2c-hid/i2c-hid.c
@@ -859,7 +859,7 @@ static int i2c_hid_power(struct hid_device *hid, int lvl)
 	return 0;
 }
 
-static struct hid_ll_driver i2c_hid_ll_driver = {
+struct hid_ll_driver i2c_hid_ll_driver = {
 	.parse = i2c_hid_parse,
 	.start = i2c_hid_start,
 	.stop = i2c_hid_stop,
@@ -869,6 +869,7 @@ static struct hid_ll_driver i2c_hid_ll_driver = {
 	.output_report = i2c_hid_output_report,
 	.raw_request = i2c_hid_raw_request,
 };
+EXPORT_SYMBOL_GPL(i2c_hid_ll_driver);
 
 static int i2c_hid_init_irq(struct i2c_client *client)
 {
* Unmerged path drivers/hid/uhid.c
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index f7165ac03d35..7359001471e9 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1256,7 +1256,7 @@ static int usbhid_idle(struct hid_device *hid, int report, int idle,
 	return hid_set_idle(dev, ifnum, report, idle);
 }
 
-static struct hid_ll_driver usb_hid_driver = {
+struct hid_ll_driver usb_hid_driver = {
 	.parse = usbhid_parse,
 	.start = usbhid_start,
 	.stop = usbhid_stop,
@@ -1269,6 +1269,7 @@ static struct hid_ll_driver usb_hid_driver = {
 	.output_report = usbhid_output_report,
 	.idle = usbhid_idle,
 };
+EXPORT_SYMBOL_GPL(usb_hid_driver);
 
 static int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 08d85c2ce6c5..b4e4922f3b41 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -733,6 +733,17 @@ struct hid_ll_driver {
 	int (*idle)(struct hid_device *hdev, int report, int idle, int reqtype);
 };
 
+extern struct hid_ll_driver i2c_hid_ll_driver;
+extern struct hid_ll_driver hidp_hid_driver;
+extern struct hid_ll_driver uhid_hid_driver;
+extern struct hid_ll_driver usb_hid_driver;
+
+static inline bool hid_is_using_ll_driver(struct hid_device *hdev,
+		struct hid_ll_driver *driver)
+{
+	return hdev->ll_driver == driver;
+}
+
 #define	PM_HINT_FULLON	1<<5
 #define PM_HINT_NORMAL	1<<1
 
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index 0bec4588c3c8..1c3615636bd0 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -733,7 +733,7 @@ static void hidp_stop(struct hid_device *hid)
 	hid->claimed = 0;
 }
 
-static struct hid_ll_driver hidp_hid_driver = {
+struct hid_ll_driver hidp_hid_driver = {
 	.parse = hidp_parse,
 	.start = hidp_start,
 	.stop = hidp_stop,
@@ -742,6 +742,7 @@ static struct hid_ll_driver hidp_hid_driver = {
 	.raw_request = hidp_raw_request,
 	.output_report = hidp_output_report,
 };
+EXPORT_SYMBOL_GPL(hidp_hid_driver);
 
 /* This function sets up the hid device. It does not add it
    to the HID system. That is done in hidp_add_connection(). */
