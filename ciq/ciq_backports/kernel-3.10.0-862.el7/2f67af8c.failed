qed: Pass src/dst sizes when interacting with MFW

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tomer Tayar <Tomer.Tayar@cavium.com>
commit 2f67af8c596e16760dc7e7d28ee0edd7ce59f2b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2f67af8c.failed

The driver interaction with management firmware involves a union
of all the data-members relating to the commands the driver prepares.

Current interface assumes the caller always passes such a union -
but thats cumbersome as well as risky [chancing a stack corruption
in case caller accidentally passes a smaller member instead of union].

Change implementation so that caller could pass a pointer to any
of the members instead of the union.

	Signed-off-by: Tomer Tayar <Tomer.Tayar@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2f67af8c596e16760dc7e7d28ee0edd7ce59f2b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 1cc3e9b6cf0b,8d181025e78c..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -285,67 -318,200 +285,169 @@@ int qed_mcp_reset(struct qed_hwfn *p_hw
  	return rc;
  }
  
 -/* Must be called while cmd_lock is acquired */
 -static bool qed_mcp_has_pending_cmd(struct qed_hwfn *p_hwfn)
 +static int qed_do_mcp_cmd(struct qed_hwfn *p_hwfn,
 +			  struct qed_ptt *p_ptt,
 +			  u32 cmd,
 +			  u32 param,
 +			  u32 *o_mcp_resp,
 +			  u32 *o_mcp_param)
  {
++<<<<<<< HEAD
 +	u8 delay = CHIP_MCP_RESP_ITER_US;
 +	u32 seq, cnt = 1, actual_mb_seq;
++=======
+ 	struct qed_mcp_cmd_elem *p_cmd_elem;
+ 
+ 	/* There is at most one pending command at a certain time, and if it
+ 	 * exists - it is placed at the HEAD of the list.
+ 	 */
+ 	if (!list_empty(&p_hwfn->mcp_info->cmd_list)) {
+ 		p_cmd_elem = list_first_entry(&p_hwfn->mcp_info->cmd_list,
+ 					      struct qed_mcp_cmd_elem, list);
+ 		return !p_cmd_elem->b_is_completed;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /* Must be called while cmd_lock is acquired */
+ static int
+ qed_mcp_update_pending_cmd(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
+ {
+ 	struct qed_mcp_mb_params *p_mb_params;
+ 	struct qed_mcp_cmd_elem *p_cmd_elem;
+ 	u32 mcp_resp;
+ 	u16 seq_num;
+ 
+ 	mcp_resp = DRV_MB_RD(p_hwfn, p_ptt, fw_mb_header);
+ 	seq_num = (u16)(mcp_resp & FW_MSG_SEQ_NUMBER_MASK);
+ 
+ 	/* Return if no new non-handled response has been received */
+ 	if (seq_num != p_hwfn->mcp_info->drv_mb_seq)
+ 		return -EAGAIN;
+ 
+ 	p_cmd_elem = qed_mcp_cmd_get_elem(p_hwfn, seq_num);
+ 	if (!p_cmd_elem) {
+ 		DP_ERR(p_hwfn,
+ 		       "Failed to find a pending mailbox cmd that expects sequence number %d\n",
+ 		       seq_num);
+ 		return -EINVAL;
+ 	}
+ 
+ 	p_mb_params = p_cmd_elem->p_mb_params;
+ 
+ 	/* Get the MFW response along with the sequence number */
+ 	p_mb_params->mcp_resp = mcp_resp;
+ 
+ 	/* Get the MFW param */
+ 	p_mb_params->mcp_param = DRV_MB_RD(p_hwfn, p_ptt, fw_mb_param);
+ 
+ 	/* Get the union data */
+ 	if (p_mb_params->p_data_dst != NULL && p_mb_params->data_dst_size) {
+ 		u32 union_data_addr = p_hwfn->mcp_info->drv_mb_addr +
+ 				      offsetof(struct public_drv_mb,
+ 					       union_data);
+ 		qed_memcpy_from(p_hwfn, p_ptt, p_mb_params->p_data_dst,
+ 				union_data_addr, p_mb_params->data_dst_size);
+ 	}
+ 
+ 	p_cmd_elem->b_is_completed = true;
+ 
+ 	return 0;
+ }
+ 
+ /* Must be called while cmd_lock is acquired */
+ static void __qed_mcp_cmd_and_union(struct qed_hwfn *p_hwfn,
+ 				    struct qed_ptt *p_ptt,
+ 				    struct qed_mcp_mb_params *p_mb_params,
+ 				    u16 seq_num)
+ {
+ 	union drv_union_data union_data;
+ 	u32 union_data_addr;
+ 
+ 	/* Set the union data */
+ 	union_data_addr = p_hwfn->mcp_info->drv_mb_addr +
+ 			  offsetof(struct public_drv_mb, union_data);
+ 	memset(&union_data, 0, sizeof(union_data));
+ 	if (p_mb_params->p_data_src != NULL && p_mb_params->data_src_size)
+ 		memcpy(&union_data, p_mb_params->p_data_src,
+ 		       p_mb_params->data_src_size);
+ 	qed_memcpy_to(p_hwfn, p_ptt, union_data_addr, &union_data,
+ 		      sizeof(union_data));
+ 
+ 	/* Set the drv param */
+ 	DRV_MB_WR(p_hwfn, p_ptt, drv_mb_param, p_mb_params->param);
+ 
+ 	/* Set the drv command along with the sequence number */
+ 	DRV_MB_WR(p_hwfn, p_ptt, drv_mb_header, (p_mb_params->cmd | seq_num));
+ 
+ 	DP_VERBOSE(p_hwfn, QED_MSG_SP,
+ 		   "MFW mailbox: command 0x%08x param 0x%08x\n",
+ 		   (p_mb_params->cmd | seq_num), p_mb_params->param);
+ }
+ 
+ static int
+ _qed_mcp_cmd_and_union(struct qed_hwfn *p_hwfn,
+ 		       struct qed_ptt *p_ptt,
+ 		       struct qed_mcp_mb_params *p_mb_params,
+ 		       u32 max_retries, u32 delay)
+ {
+ 	struct qed_mcp_cmd_elem *p_cmd_elem;
+ 	u32 cnt = 0;
+ 	u16 seq_num;
++>>>>>>> 2f67af8c596e (qed: Pass src/dst sizes when interacting with MFW)
  	int rc = 0;
  
 -	/* Wait until the mailbox is non-occupied */
 -	do {
 -		/* Exit the loop if there is no pending command, or if the
 -		 * pending command is completed during this iteration.
 -		 * The spinlock stays locked until the command is sent.
 -		 */
 -
 -		spin_lock_bh(&p_hwfn->mcp_info->cmd_lock);
 -
 -		if (!qed_mcp_has_pending_cmd(p_hwfn))
 -			break;
 -
 -		rc = qed_mcp_update_pending_cmd(p_hwfn, p_ptt);
 -		if (!rc)
 -			break;
 -		else if (rc != -EAGAIN)
 -			goto err;
 +	/* Get actual driver mailbox sequence */
 +	actual_mb_seq = DRV_MB_RD(p_hwfn, p_ptt, drv_mb_header) &
 +			DRV_MSG_SEQ_NUMBER_MASK;
  
 -		spin_unlock_bh(&p_hwfn->mcp_info->cmd_lock);
 -		udelay(delay);
 -	} while (++cnt < max_retries);
 -
 -	if (cnt >= max_retries) {
 -		DP_NOTICE(p_hwfn,
 -			  "The MFW mailbox is occupied by an uncompleted command. Failed to send command 0x%08x [param 0x%08x].\n",
 -			  p_mb_params->cmd, p_mb_params->param);
 -		return -EAGAIN;
 +	/* Use MCP history register to check if MCP reset occurred between
 +	 * init time and now.
 +	 */
 +	if (p_hwfn->mcp_info->mcp_hist !=
 +	    qed_rd(p_hwfn, p_ptt, MISCS_REG_GENERIC_POR_0)) {
 +		DP_VERBOSE(p_hwfn, QED_MSG_SP, "Rereading MCP offsets\n");
 +		qed_load_mcp_offsets(p_hwfn, p_ptt);
 +		qed_mcp_cmd_port_init(p_hwfn, p_ptt);
  	}
 +	seq = ++p_hwfn->mcp_info->drv_mb_seq;
  
 -	/* Send the mailbox command */
 -	qed_mcp_reread_offsets(p_hwfn, p_ptt);
 -	seq_num = ++p_hwfn->mcp_info->drv_mb_seq;
 -	p_cmd_elem = qed_mcp_cmd_add_elem(p_hwfn, p_mb_params, seq_num);
 -	if (!p_cmd_elem)
 -		goto err;
 +	/* Set drv param */
 +	DRV_MB_WR(p_hwfn, p_ptt, drv_mb_param, param);
  
 -	__qed_mcp_cmd_and_union(p_hwfn, p_ptt, p_mb_params, seq_num);
 -	spin_unlock_bh(&p_hwfn->mcp_info->cmd_lock);
 +	/* Set drv command along with the updated sequence */
 +	DRV_MB_WR(p_hwfn, p_ptt, drv_mb_header, (cmd | seq));
  
 -	/* Wait for the MFW response */
 -	do {
 -		/* Exit the loop if the command is already completed, or if the
 -		 * command is completed during this iteration.
 -		 * The spinlock stays locked until the list element is removed.
 -		 */
 +	DP_VERBOSE(p_hwfn, QED_MSG_SP,
 +		   "wrote command (%x) to MFW MB param 0x%08x\n",
 +		   (cmd | seq), param);
  
 +	do {
 +		/* Wait for MFW response */
  		udelay(delay);
 -		spin_lock_bh(&p_hwfn->mcp_info->cmd_lock);
 -
 -		if (p_cmd_elem->b_is_completed)
 -			break;
 -
 -		rc = qed_mcp_update_pending_cmd(p_hwfn, p_ptt);
 -		if (!rc)
 -			break;
 -		else if (rc != -EAGAIN)
 -			goto err;
 -
 -		spin_unlock_bh(&p_hwfn->mcp_info->cmd_lock);
 -	} while (++cnt < max_retries);
 +		*o_mcp_resp = DRV_MB_RD(p_hwfn, p_ptt, fw_mb_header);
  
 -	if (cnt >= max_retries) {
 -		DP_NOTICE(p_hwfn,
 -			  "The MFW failed to respond to command 0x%08x [param 0x%08x].\n",
 -			  p_mb_params->cmd, p_mb_params->param);
 -
 -		spin_lock_bh(&p_hwfn->mcp_info->cmd_lock);
 -		qed_mcp_cmd_del_elem(p_hwfn, p_cmd_elem);
 -		spin_unlock_bh(&p_hwfn->mcp_info->cmd_lock);
 +		/* Give the FW up to 5 second (500*10ms) */
 +	} while ((seq != (*o_mcp_resp & FW_MSG_SEQ_NUMBER_MASK)) &&
 +		 (cnt++ < QED_DRV_MB_MAX_RETRIES));
  
 -		return -EAGAIN;
 +	DP_VERBOSE(p_hwfn, QED_MSG_SP,
 +		   "[after %d ms] read (%x) seq is (%x) from FW MB\n",
 +		   cnt * delay, *o_mcp_resp, seq);
 +
 +	/* Is this a reply to our command? */
 +	if (seq == (*o_mcp_resp & FW_MSG_SEQ_NUMBER_MASK)) {
 +		*o_mcp_resp &= FW_MSG_CODE_MASK;
 +		/* Get the MCP param */
 +		*o_mcp_param = DRV_MB_RD(p_hwfn, p_ptt, fw_mb_param);
 +	} else {
 +		/* FW BUG! */
 +		DP_ERR(p_hwfn, "MFW failed to respond [cmd 0x%x param 0x%x]\n",
 +		       cmd, param);
 +		*o_mcp_resp = 0;
 +		rc = -EAGAIN;
  	}
 -
 -	qed_mcp_cmd_del_elem(p_hwfn, p_cmd_elem);
 -	spin_unlock_bh(&p_hwfn->mcp_info->cmd_lock);
 -
 -	DP_VERBOSE(p_hwfn,
 -		   QED_MSG_SP,
 -		   "MFW mailbox: response 0x%08x param 0x%08x [after %d.%03d ms]\n",
 -		   p_mb_params->mcp_resp,
 -		   p_mb_params->mcp_param,
 -		   (cnt * delay) / 1000, (cnt * delay) % 1000);
 -
 -	/* Clear the sequence number from the MFW response */
 -	p_mb_params->mcp_resp &= FW_MSG_CODE_MASK;
 -
 -	return 0;
 -
 -err:
 -	spin_unlock_bh(&p_hwfn->mcp_info->cmd_lock);
  	return rc;
  }
  
@@@ -353,9 -519,9 +455,15 @@@ static int qed_mcp_cmd_and_union(struc
  				 struct qed_ptt *p_ptt,
  				 struct qed_mcp_mb_params *p_mb_params)
  {
++<<<<<<< HEAD
 +	u32 union_data_addr;
 +
 +	int rc;
++=======
+ 	size_t union_data_size = sizeof(union drv_union_data);
+ 	u32 max_retries = QED_DRV_MB_MAX_RETRIES;
+ 	u32 delay = CHIP_MCP_RESP_ITER_US;
++>>>>>>> 2f67af8c596e (qed: Pass src/dst sizes when interacting with MFW)
  
  	/* MCP not initialized */
  	if (!qed_mcp_is_init(p_hwfn)) {
@@@ -363,33 -529,17 +471,47 @@@
  		return -EBUSY;
  	}
  
++<<<<<<< HEAD
 +	union_data_addr = p_hwfn->mcp_info->drv_mb_addr +
 +			  offsetof(struct public_drv_mb, union_data);
 +
 +	/* Ensure that only a single thread is accessing the mailbox at a
 +	 * certain time.
 +	 */
 +	rc = qed_mcp_mb_lock(p_hwfn, p_mb_params->cmd);
 +	if (rc)
 +		return rc;
 +
 +	if (p_mb_params->p_data_src != NULL)
 +		qed_memcpy_to(p_hwfn, p_ptt, union_data_addr,
 +			      p_mb_params->p_data_src,
 +			      sizeof(*p_mb_params->p_data_src));
 +
 +	rc = qed_do_mcp_cmd(p_hwfn, p_ptt, p_mb_params->cmd,
 +			    p_mb_params->param, &p_mb_params->mcp_resp,
 +			    &p_mb_params->mcp_param);
 +
 +	if (p_mb_params->p_data_dst != NULL)
 +		qed_memcpy_from(p_hwfn, p_ptt, p_mb_params->p_data_dst,
 +				union_data_addr,
 +				sizeof(*p_mb_params->p_data_dst));
 +
 +	qed_mcp_mb_unlock(p_hwfn, p_mb_params->cmd);
 +
 +	return rc;
++=======
+ 	if (p_mb_params->data_src_size > union_data_size ||
+ 	    p_mb_params->data_dst_size > union_data_size) {
+ 		DP_ERR(p_hwfn,
+ 		       "The provided size is larger than the union data size [src_size %u, dst_size %u, union_data_size %zu]\n",
+ 		       p_mb_params->data_src_size,
+ 		       p_mb_params->data_dst_size, union_data_size);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return _qed_mcp_cmd_and_union(p_hwfn, p_ptt, p_mb_params, max_retries,
+ 				      delay);
++>>>>>>> 2f67af8c596e (qed: Pass src/dst sizes when interacting with MFW)
  }
  
  int qed_mcp_cmd(struct qed_hwfn *p_hwfn,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.h b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
index f2623df65ec2..f6154f78133b 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@ -505,8 +505,10 @@ struct qed_mcp_info {
 struct qed_mcp_mb_params {
 	u32			cmd;
 	u32			param;
-	union drv_union_data	*p_data_src;
-	union drv_union_data	*p_data_dst;
+	void			*p_data_src;
+	u8			data_src_size;
+	void			*p_data_dst;
+	u8			data_dst_size;
 	u32			mcp_resp;
 	u32			mcp_param;
 };
