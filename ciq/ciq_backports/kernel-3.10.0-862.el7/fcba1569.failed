hv_netvsc: Clean up unused parameter from netvsc_get_hash()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit fcba1569a0c87cea40404af9a29b319f4e491839
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fcba1569.failed

The parameter "sk" is not in use.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fcba1569a0c87cea40404af9a29b319f4e491839)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index b16b610847ea,4677d214cc1f..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -201,6 -190,54 +201,57 @@@ static void *init_ppi_data(struct rndis
  	return ppi;
  }
  
++<<<<<<< HEAD
++=======
+ /* Azure hosts don't support non-TCP port numbers in hashing yet. We compute
+  * hash for non-TCP traffic with only IP numbers.
+  */
+ static inline u32 netvsc_get_hash(struct sk_buff *skb)
+ {
+ 	struct flow_keys flow;
+ 	u32 hash;
+ 	static u32 hashrnd __read_mostly;
+ 
+ 	net_get_random_once(&hashrnd, sizeof(hashrnd));
+ 
+ 	if (!skb_flow_dissect_flow_keys(skb, &flow, 0))
+ 		return 0;
+ 
+ 	if (flow.basic.ip_proto == IPPROTO_TCP) {
+ 		return skb_get_hash(skb);
+ 	} else {
+ 		if (flow.basic.n_proto == htons(ETH_P_IP))
+ 			hash = jhash2((u32 *)&flow.addrs.v4addrs, 2, hashrnd);
+ 		else if (flow.basic.n_proto == htons(ETH_P_IPV6))
+ 			hash = jhash2((u32 *)&flow.addrs.v6addrs, 8, hashrnd);
+ 		else
+ 			hash = 0;
+ 
+ 		skb_set_hash(skb, hash, PKT_HASH_TYPE_L3);
+ 	}
+ 
+ 	return hash;
+ }
+ 
+ static inline int netvsc_get_tx_queue(struct net_device *ndev,
+ 				      struct sk_buff *skb, int old_idx)
+ {
+ 	const struct net_device_context *ndc = netdev_priv(ndev);
+ 	struct sock *sk = skb->sk;
+ 	int q_idx;
+ 
+ 	q_idx = ndc->tx_send_table[netvsc_get_hash(skb) &
+ 				   (VRSS_SEND_TAB_SIZE - 1)];
+ 
+ 	/* If queue index changed record the new value */
+ 	if (q_idx != old_idx &&
+ 	    sk && sk_fullsock(sk) && rcu_access_pointer(sk->sk_dst_cache))
+ 		sk_tx_queue_set(sk, q_idx);
+ 
+ 	return q_idx;
+ }
+ 
++>>>>>>> fcba1569a0c8 (hv_netvsc: Clean up unused parameter from netvsc_get_hash())
  /*
   * Select queue for transmit.
   *
* Unmerged path drivers/net/hyperv/netvsc_drv.c
