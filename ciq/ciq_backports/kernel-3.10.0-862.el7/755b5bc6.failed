fsnotify: Remove indirection from mark list addition

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 755b5bc681eb46de7bfaec196f85e30efd95bd9f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/755b5bc6.failed

Adding notification mark to object list has been currently done through
fsnotify_add_{inode|vfsmount}_mark() helpers from
fsnotify_add_mark_locked() which call fsnotify_add_mark_list(). Remove
this unnecessary indirection to simplify the code.

Pushing all the locking to fsnotify_add_mark_list() also allows us to
allocate the connector structure with GFP_KERNEL mode.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 755b5bc681eb46de7bfaec196f85e30efd95bd9f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fsnotify.h
#	fs/notify/inode_mark.c
#	fs/notify/mark.c
#	fs/notify/vfsmount_mark.c
diff --cc fs/notify/fsnotify.h
index 0a3bc2cf192c,0354338aad78..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -21,21 -21,6 +21,24 @@@ extern u32 fsnotify_recalc_mask(struct 
  extern int fsnotify_compare_groups(struct fsnotify_group *a,
  				   struct fsnotify_group *b);
  
++<<<<<<< HEAD
 +extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 +						__u32 mask);
 +/* Add mark to a proper place in mark list */
 +extern int fsnotify_add_mark_list(struct hlist_head *head,
 +				  struct fsnotify_mark *mark,
 +				  int allow_dups);
 +/* add a mark to an inode */
 +extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 +				   struct fsnotify_group *group, struct inode *inode,
 +				   int allow_dups);
 +/* add a mark to a vfsmount */
 +extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 +				      struct fsnotify_group *group, struct vfsmount *mnt,
 +				      int allow_dups);
 +
++=======
++>>>>>>> 755b5bc681eb (fsnotify: Remove indirection from mark list addition)
  /* vfsmount specific destruction of a mark */
  extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
  /* inode specific destruction of a mark */
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,87bef7d802db..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -88,67 -92,14 +88,70 @@@ struct fsnotify_mark *fsnotify_find_ino
  	return mark;
  }
  
++<<<<<<< HEAD
 +/*
 + * If we are setting a mark mask on an inode mark we should pin the inode
 + * in memory.
 + */
 +void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,
 +					 __u32 mask)
 +{
 +	struct inode *inode;
 +
 +	assert_spin_locked(&mark->lock);
 +
 +	if (mask &&
 +	    mark->inode &&
 +	    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {
 +		mark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;
 +		inode = igrab(mark->inode);
 +		/*
 +		 * we shouldn't be able to get here if the inode wasn't
 +		 * already safely held in memory.  But bug in case it
 +		 * ever is wrong.
 +		 */
 +		BUG_ON(!inode);
 +	}
 +}
 +
 +/*
 + * Attach an initialized mark to a given inode.
 + * These marks may be used for the fsnotify backend to determine which
 + * event types should be delivered to which group and for which inodes.  These
 + * marks are ordered according to priority, highest number first, and then by
 + * the group's location in memory.
 + */
 +int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 +			    struct fsnotify_group *group, struct inode *inode,
 +			    int allow_dups)
 +{
 +	int ret;
 +
 +	mark->flags |= FSNOTIFY_MARK_FLAG_INODE;
 +
 +	BUG_ON(!mutex_is_locked(&group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&inode->i_lock);
 +	mark->inode = inode;
 +	ret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,
 +				     allow_dups);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 755b5bc681eb (fsnotify: Remove indirection from mark list addition)
  /**
   * fsnotify_unmount_inodes - an sb is unmounting.  handle any watched inodes.
 - * @sb: superblock being unmounted.
 + * @list: list of inodes being unmounted (sb->s_inodes)
   *
   * Called during unmount with no locks held, so needs to be safe against
 - * concurrent modifiers. We temporarily drop sb->s_inode_list_lock and CAN block.
 + * concurrent modifiers. We temporarily drop inode_sb_list_lock and CAN block.
   */
 -void fsnotify_unmount_inodes(struct super_block *sb)
 +void fsnotify_unmount_inodes(struct list_head *list)
  {
  	struct inode *inode, *iput_inode = NULL;
  
diff --cc fs/notify/mark.c
index 44836e539169,e8c2f829ce65..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -304,25 -318,93 +304,100 @@@ int fsnotify_compare_groups(struct fsno
  	return -1;
  }
  
++<<<<<<< HEAD
 +/* Add mark into proper place in given list of marks */
 +int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,
 +			   int allow_dups)
 +{
 +	struct fsnotify_mark *lmark, *last = NULL;
 +	int cmp;
++=======
+ static int fsnotify_attach_connector_to_object(
+ 					struct fsnotify_mark_connector **connp,
+ 					spinlock_t *lock,
+ 					struct inode *inode,
+ 					struct vfsmount *mnt)
+ {
+ 	struct fsnotify_mark_connector *conn;
+ 
+ 	conn = kmem_cache_alloc(fsnotify_mark_connector_cachep, GFP_KERNEL);
+ 	if (!conn)
+ 		return -ENOMEM;
+ 	INIT_HLIST_HEAD(&conn->list);
+ 	if (inode) {
+ 		conn->flags = FSNOTIFY_OBJ_TYPE_INODE;
+ 		conn->inode = inode;
+ 	} else {
+ 		conn->flags = FSNOTIFY_OBJ_TYPE_VFSMOUNT;
+ 		conn->mnt = mnt;
+ 	}
+ 	/*
+ 	 * Make sure 'conn' initialization is visible. Matches
+ 	 * lockless_dereference() in fsnotify().
+ 	 */
+ 	smp_wmb();
+ 	spin_lock(lock);
+ 	if (!*connp)
+ 		*connp = conn;
+ 	else
+ 		kmem_cache_free(fsnotify_mark_connector_cachep, conn);
+ 	spin_unlock(lock);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Add mark into proper place in given list of marks. These marks may be used
+  * for the fsnotify backend to determine which event types should be delivered
+  * to which group and for which inodes. These marks are ordered according to
+  * priority, highest number first, and then by the group's location in memory.
+  */
+ static int fsnotify_add_mark_list(struct fsnotify_mark *mark,
+ 				  struct inode *inode, struct vfsmount *mnt,
+ 				  int allow_dups)
+ {
+ 	struct fsnotify_mark *lmark, *last = NULL;
+ 	struct fsnotify_mark_connector *conn;
+ 	struct fsnotify_mark_connector **connp;
+ 	spinlock_t *lock;
+ 	int cmp;
+ 	int err = 0;
+ 
+ 	if (WARN_ON(!inode && !mnt))
+ 		return -EINVAL;
+ 	if (inode) {
+ 		connp = &inode->i_fsnotify_marks;
+ 		lock = &inode->i_lock;
+ 	} else {
+ 		connp = &real_mount(mnt)->mnt_fsnotify_marks;
+ 		lock = &mnt->mnt_root->d_lock;
+ 	}
+ 
+ 	if (!*connp) {
+ 		err = fsnotify_attach_connector_to_object(connp, lock,
+ 							  inode, mnt);
+ 		if (err)
+ 			return err;
+ 	}
+ 	spin_lock(&mark->lock);
+ 	spin_lock(lock);
+ 	conn = *connp;
++>>>>>>> 755b5bc681eb (fsnotify: Remove indirection from mark list addition)
  
  	/* is mark the first mark? */
 -	if (hlist_empty(&conn->list)) {
 -		hlist_add_head_rcu(&mark->obj_list, &conn->list);
 -		if (inode)
 -			__iget(inode);
 -		goto added;
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&mark->obj_list, head);
 +		return 0;
  	}
  
  	/* should mark be in the middle of the current list? */
 -	hlist_for_each_entry(lmark, &conn->list, obj_list) {
 +	hlist_for_each_entry(lmark, head, obj_list) {
  		last = lmark;
  
- 		if ((lmark->group == mark->group) && !allow_dups)
- 			return -EEXIST;
+ 		if ((lmark->group == mark->group) && !allow_dups) {
+ 			err = -EEXIST;
+ 			goto out_err;
+ 		}
  
  		cmp = fsnotify_compare_groups(lmark->group, mark->group);
  		if (cmp >= 0) {
@@@ -334,7 -416,12 +409,16 @@@
  	BUG_ON(last == NULL);
  	/* mark should be the last entry.  last is the current last entry */
  	hlist_add_behind_rcu(&mark->obj_list, &last->obj_list);
++<<<<<<< HEAD
 +	return 0;
++=======
+ added:
+ 	mark->connector = conn;
+ out_err:
+ 	spin_unlock(lock);
+ 	spin_unlock(&mark->lock);
+ 	return err;
++>>>>>>> 755b5bc681eb (fsnotify: Remove indirection from mark list addition)
  }
  
  /*
@@@ -366,25 -453,16 +450,34 @@@ int fsnotify_add_mark_locked(struct fsn
  	list_add(&mark->g_list, &group->marks_list);
  	atomic_inc(&group->num_marks);
  	fsnotify_get_mark(mark); /* for i_list and g_list */
++<<<<<<< HEAD
 +
 +	if (inode) {
 +		ret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);
 +		if (ret)
 +			goto err;
 +	} else if (mnt) {
 +		ret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);
 +		if (ret)
 +			goto err;
 +	} else {
 +		BUG();
 +	}
 +
 +	/* this will pin the object if appropriate */
 +	fsnotify_set_mark_mask_locked(mark, mark->mask);
++=======
++>>>>>>> 755b5bc681eb (fsnotify: Remove indirection from mark list addition)
  	spin_unlock(&mark->lock);
  
+ 	ret = fsnotify_add_mark_list(mark, inode, mnt, allow_dups);
+ 	if (ret)
+ 		goto err;
+ 
  	if (inode)
- 		__fsnotify_update_child_dentry_flags(inode);
+ 		fsnotify_recalc_inode_mask(inode);
+ 	else
+ 		fsnotify_recalc_vfsmount_mask(mnt);
  
  	return ret;
  err:
diff --cc fs/notify/vfsmount_mark.c
index a8fcab68faef,49ccbdb74f82..000000000000
--- a/fs/notify/vfsmount_mark.c
+++ b/fs/notify/vfsmount_mark.c
@@@ -80,29 -80,3 +80,32 @@@ struct fsnotify_mark *fsnotify_find_vfs
  
  	return mark;
  }
++<<<<<<< HEAD
 +
 +/*
 + * Attach an initialized mark to a given group and vfsmount.
 + * These marks may be used for the fsnotify backend to determine which
 + * event types should be delivered to which groups.
 + */
 +int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 +			       struct fsnotify_group *group, struct vfsmount *mnt,
 +			       int allow_dups)
 +{
 +	struct mount *m = real_mount(mnt);
 +	int ret;
 +
 +	mark->flags |= FSNOTIFY_MARK_FLAG_VFSMOUNT;
 +
 +	BUG_ON(!mutex_is_locked(&group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +	mark->mnt = mnt;
 +	ret = fsnotify_add_mark_list(&m->mnt_fsnotify_marks, mark, allow_dups);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
 +
 +	return ret;
 +}
++=======
++>>>>>>> 755b5bc681eb (fsnotify: Remove indirection from mark list addition)
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/inode_mark.c
* Unmerged path fs/notify/mark.c
* Unmerged path fs/notify/vfsmount_mark.c
