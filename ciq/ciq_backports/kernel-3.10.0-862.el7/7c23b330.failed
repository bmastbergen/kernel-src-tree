livepatch: add /proc/<pid>/patch_state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 7c23b330011690705613a66a8239d2ca64a41d4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7c23b330.failed

Expose the per-task patch state value so users can determine which tasks
are holding up completion of a patching operation.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Reviewed-by: Miroslav Benes <mbenes@suse.cz>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 7c23b330011690705613a66a8239d2ca64a41d4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/proc.txt
#	fs/proc/base.c
diff --cc Documentation/filesystems/proc.txt
index 9433709281cc,9036dbf16156..000000000000
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@@ -42,6 -42,9 +42,12 @@@ Table of Content
    3.6	/proc/<pid>/comm  & /proc/<pid>/task/<tid>/comm
    3.7   /proc/<pid>/task/<tid>/children - Information about task children
    3.8   /proc/<pid>/fdinfo/<fd> - Information about opened file
++<<<<<<< HEAD
++=======
+   3.9   /proc/<pid>/map_files - Information about memory mapped files
+   3.10  /proc/<pid>/timerslack_ns - Task timerslack value
+   3.11	/proc/<pid>/patch_state - Livepatch patch operation state
++>>>>>>> 7c23b3300116 (livepatch: add /proc/<pid>/patch_state)
  
    4	Configuring procfs
    4.1	Mount options
@@@ -1816,6 -1850,62 +1822,65 @@@ pair provide additional information par
  	with TIMER_ABSTIME option which will be shown in 'settime flags', but 'it_value'
  	still exhibits timer's remaining time.
  
++<<<<<<< HEAD
++=======
+ 3.9	/proc/<pid>/map_files - Information about memory mapped files
+ ---------------------------------------------------------------------
+ This directory contains symbolic links which represent memory mapped files
+ the process is maintaining.  Example output:
+ 
+      | lr-------- 1 root root 64 Jan 27 11:24 333c600000-333c620000 -> /usr/lib64/ld-2.18.so
+      | lr-------- 1 root root 64 Jan 27 11:24 333c81f000-333c820000 -> /usr/lib64/ld-2.18.so
+      | lr-------- 1 root root 64 Jan 27 11:24 333c820000-333c821000 -> /usr/lib64/ld-2.18.so
+      | ...
+      | lr-------- 1 root root 64 Jan 27 11:24 35d0421000-35d0422000 -> /usr/lib64/libselinux.so.1
+      | lr-------- 1 root root 64 Jan 27 11:24 400000-41a000 -> /usr/bin/ls
+ 
+ The name of a link represents the virtual memory bounds of a mapping, i.e.
+ vm_area_struct::vm_start-vm_area_struct::vm_end.
+ 
+ The main purpose of the map_files is to retrieve a set of memory mapped
+ files in a fast way instead of parsing /proc/<pid>/maps or
+ /proc/<pid>/smaps, both of which contain many more records.  At the same
+ time one can open(2) mappings from the listings of two processes and
+ comparing their inode numbers to figure out which anonymous memory areas
+ are actually shared.
+ 
+ 3.10	/proc/<pid>/timerslack_ns - Task timerslack value
+ ---------------------------------------------------------
+ This file provides the value of the task's timerslack value in nanoseconds.
+ This value specifies a amount of time that normal timers may be deferred
+ in order to coalesce timers and avoid unnecessary wakeups.
+ 
+ This allows a task's interactivity vs power consumption trade off to be
+ adjusted.
+ 
+ Writing 0 to the file will set the tasks timerslack to the default value.
+ 
+ Valid values are from 0 - ULLONG_MAX
+ 
+ An application setting the value must have PTRACE_MODE_ATTACH_FSCREDS level
+ permissions on the task specified to change its timerslack_ns value.
+ 
+ 3.11	/proc/<pid>/patch_state - Livepatch patch operation state
+ -----------------------------------------------------------------
+ When CONFIG_LIVEPATCH is enabled, this file displays the value of the
+ patch state for the task.
+ 
+ A value of '-1' indicates that no patch is in transition.
+ 
+ A value of '0' indicates that a patch is in transition and the task is
+ unpatched.  If the patch is being enabled, then the task hasn't been
+ patched yet.  If the patch is being disabled, then the task has already
+ been unpatched.
+ 
+ A value of '1' indicates that a patch is in transition and the task is
+ patched.  If the patch is being enabled, then the task has already been
+ patched.  If the patch is being disabled, then the task hasn't been
+ unpatched yet.
+ 
+ 
++>>>>>>> 7c23b3300116 (livepatch: add /proc/<pid>/patch_state)
  ------------------------------------------------------------------------------
  Configuring procfs
  ------------------------------------------------------------------------------
diff --cc fs/proc/base.c
index c36f34194d71,9e3ac5c11780..000000000000
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@@ -2948,16 -2938,19 +2957,23 @@@ static const struct pid_entry tgid_base
  	REG("projid_map", S_IRUGO|S_IWUSR, proc_projid_map_operations),
  	REG("setgroups",  S_IRUGO|S_IWUSR, proc_setgroups_operations),
  #endif
 -#if defined(CONFIG_CHECKPOINT_RESTORE) && defined(CONFIG_POSIX_TIMERS)
 +#ifdef CONFIG_CHECKPOINT_RESTORE
  	REG("timers",	  S_IRUGO, proc_timers_operations),
  #endif
++<<<<<<< HEAD
++=======
+ 	REG("timerslack_ns", S_IRUGO|S_IWUGO, proc_pid_set_timerslack_ns_operations),
+ #ifdef CONFIG_LIVEPATCH
+ 	ONE("patch_state",  S_IRUSR, proc_pid_patch_state),
+ #endif
++>>>>>>> 7c23b3300116 (livepatch: add /proc/<pid>/patch_state)
  };
  
 -static int proc_tgid_base_readdir(struct file *file, struct dir_context *ctx)
 +static int proc_tgid_base_readdir(struct file * filp,
 +			     void * dirent, filldir_t filldir)
  {
 -	return proc_pident_readdir(file, ctx,
 -				   tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));
 +	return proc_pident_readdir(filp,dirent,filldir,
 +				   tgid_base_stuff,ARRAY_SIZE(tgid_base_stuff));
  }
  
  static const struct file_operations proc_tgid_base_operations = {
@@@ -3299,13 -3327,15 +3315,16 @@@ static const struct pid_entry tid_base_
  	REG("projid_map", S_IRUGO|S_IWUSR, proc_projid_map_operations),
  	REG("setgroups",  S_IRUGO|S_IWUSR, proc_setgroups_operations),
  #endif
+ #ifdef CONFIG_LIVEPATCH
+ 	ONE("patch_state",  S_IRUSR, proc_pid_patch_state),
+ #endif
  };
  
 -static int proc_tid_base_readdir(struct file *file, struct dir_context *ctx)
 +static int proc_tid_base_readdir(struct file * filp,
 +			     void * dirent, filldir_t filldir)
  {
 -	return proc_pident_readdir(file, ctx,
 -				   tid_base_stuff, ARRAY_SIZE(tid_base_stuff));
 +	return proc_pident_readdir(filp,dirent,filldir,
 +				   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));
  }
  
  static struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)
* Unmerged path Documentation/filesystems/proc.txt
* Unmerged path fs/proc/base.c
