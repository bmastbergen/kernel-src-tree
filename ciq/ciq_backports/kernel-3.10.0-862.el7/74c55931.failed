KVM: VMX: Cache IA32_DEBUGCTL in memory

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Wanpeng Li <wanpeng.li@hotmail.com>
commit 74c55931c71352317ae0f5736ee9e4ca07ba4238
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/74c55931.failed

MSR_IA32_DEBUGCTLMSR is zeroed on VMEXIT, so it is saved/restored each
time during world switch.  This patch caches the host IA32_DEBUGCTL MSR
and saves/restores the host IA32_DEBUGCTL msr when guest/host switches
to avoid to save/restore each time during world switch.  This saves
about 100 clock cycles per vmexit.

	Suggested-by: Jim Mattson <jmattson@google.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Jim Mattson <jmattson@google.com>
	Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 74c55931c71352317ae0f5736ee9e4ca07ba4238)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index b8537eb9caaf,4e7da90b4426..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -609,8 -643,15 +609,15 @@@ struct vcpu_vmx 
  #define PML_ENTITY_NUM		512
  	struct page *pml_pg;
  
 -	/* apic deadline value in host tsc */
 -	u64 hv_deadline_tsc;
 -
  	u64 current_tsc_ratio;
  
++<<<<<<< HEAD
++=======
+ 	u32 host_pkru;
+ 
+ 	unsigned long host_debugctlmsr;
+ 
++>>>>>>> 74c55931c713 (KVM: VMX: Cache IA32_DEBUGCTL in memory)
  	/*
  	 * Only bits masked by msr_ia32_feature_control_valid_bits can be set in
  	 * msr_ia32_feature_control. FEATURE_CONTROL_LOCKED is always included
@@@ -2133,6 -2319,8 +2140,11 @@@ static void vmx_vcpu_load(struct kvm_vc
  		decache_tsc_multiplier(vmx);
  
  	vmx_vcpu_pi_load(vcpu, cpu);
++<<<<<<< HEAD
++=======
+ 	vmx->host_pkru = read_pkru();
+ 	vmx->host_debugctlmsr = get_debugctlmsr();
++>>>>>>> 74c55931c713 (KVM: VMX: Cache IA32_DEBUGCTL in memory)
  }
  
  static void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)
@@@ -8625,11 -9244,32 +8637,15 @@@ static void atomic_switch_perf_msrs(str
  static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
  {
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
++<<<<<<< HEAD
 +	unsigned long debugctlmsr, cr4;
++=======
+ 	unsigned long cr3, cr4;
++>>>>>>> 74c55931c713 (KVM: VMX: Cache IA32_DEBUGCTL in memory)
  
  	/* Record the guest's net vcpu time for enforced NMI injections. */
 -	if (unlikely(!enable_vnmi &&
 -		     vmx->loaded_vmcs->soft_vnmi_blocked))
 -		vmx->loaded_vmcs->entry_time = ktime_get();
 +	if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
 +		vmx->entry_time = ktime_get();
  
  	/* Don't enter VMX if guest state is invalid, let the exit handler
  	   start emulation until we arrive back to a valid state */
@@@ -8665,9 -9311,15 +8681,8 @@@
  	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)
  		vmx_set_interrupt_shadow(vcpu, 0);
  
 -	if (static_cpu_has(X86_FEATURE_PKU) &&
 -	    kvm_read_cr4_bits(vcpu, X86_CR4_PKE) &&
 -	    vcpu->arch.pkru != vmx->host_pkru)
 -		__write_pkru(vcpu->arch.pkru);
 -
  	atomic_switch_perf_msrs(vmx);
- 	debugctlmsr = get_debugctlmsr();
  
 -	vmx_arm_hv_timer(vcpu);
 -
  	vmx->__launched = vmx->loaded_vmcs->launched;
  	asm(
  		/* Store host registers */
* Unmerged path arch/x86/kvm/vmx.c
