iommu/vt-d: Fix overflow of iommu->domains array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] vt-d: Fix overflow of iommu->domains array (Jerry Snitselaar) [1499325]
Rebuild_FUZZ: 93.33%
commit-author Jan Niehusmann <jan@gondor.com>
commit 3bd4f9112f87a9c65fe6e817272806167f0bc9ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3bd4f911.failed

The valid range of 'did' in get_iommu_domain(*iommu, did)
is 0..cap_ndoms(iommu->cap), so don't exceed that
range in free_all_cpu_cached_iovas().

The user-visible impact of the out-of-bounds access is the machine
hanging on suspend-to-ram. It is, in fact, a kernel panic, but due
to already suspended devices, that's often not visible to the user.

Fixes: 22e2f9fa63b0 ("iommu/vt-d: Use per-cpu IOVA caching")
	Signed-off-by: Jan Niehusmann <jan@gondor.com>
Tested-By: Marius Vlad <marius.c.vlad@intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 3bd4f9112f87a9c65fe6e817272806167f0bc9ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 5612d2bd2e03,cfe410eedaf0..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -4432,15 -4595,47 +4432,34 @@@ static struct notifier_block intel_iomm
  	.priority = 0
  };
  
 -static void free_all_cpu_cached_iovas(unsigned int cpu)
 +static void intel_disable_iommus(void)
  {
 -	int i;
 +	struct intel_iommu *iommu = NULL;
 +	struct dmar_drhd_unit *drhd;
  
++<<<<<<< HEAD
 +	for_each_iommu(iommu, drhd)
 +		iommu_disable_translation(iommu);
++=======
+ 	for (i = 0; i < g_num_of_iommus; i++) {
+ 		struct intel_iommu *iommu = g_iommus[i];
+ 		struct dmar_domain *domain;
+ 		u16 did;
+ 
+ 		if (!iommu)
+ 			continue;
+ 
+ 		for (did = 0; did < cap_ndoms(iommu->cap); did++) {
+ 			domain = get_iommu_domain(iommu, did);
+ 
+ 			if (!domain)
+ 				continue;
+ 			free_cpu_cached_iovas(cpu, &domain->iovad);
+ 		}
+ 	}
++>>>>>>> 3bd4f9112f87 (iommu/vt-d: Fix overflow of iommu->domains array)
  }
  
 -static int intel_iommu_cpu_notifier(struct notifier_block *nfb,
 -				    unsigned long action, void *v)
 -{
 -	unsigned int cpu = (unsigned long)v;
 -
 -	switch (action) {
 -	case CPU_DEAD:
 -	case CPU_DEAD_FROZEN:
 -		free_all_cpu_cached_iovas(cpu);
 -		flush_unmaps_timeout(cpu);
 -		break;
 -	}
 -	return NOTIFY_OK;
 -}
 -
 -static struct notifier_block intel_iommu_cpu_nb = {
 -	.notifier_call = intel_iommu_cpu_notifier,
 -};
 -
  static ssize_t intel_iommu_show_version(struct device *dev,
  					struct device_attribute *attr,
  					char *buf)
* Unmerged path drivers/iommu/intel-iommu.c
