xfs: Honor FALLOC_FL_KEEP_SIZE when punching ends of files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Calvin Owens <calvinowens@fb.com>
commit 3dd09d5a8589c640abb49cfcf92b4ed669eafad1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3dd09d5a.failed

When punching past EOF on XFS, fallocate(mode=PUNCH_HOLE|KEEP_SIZE) will
round the file size up to the nearest multiple of PAGE_SIZE:

  calvinow@vm-disks/generic-xfs-1 ~$ dd if=/dev/urandom of=test bs=2048 count=1
  calvinow@vm-disks/generic-xfs-1 ~$ stat test
    Size: 2048            Blocks: 8          IO Block: 4096   regular file
  calvinow@vm-disks/generic-xfs-1 ~$ fallocate -n -l 2048 -o 2048 -p test
  calvinow@vm-disks/generic-xfs-1 ~$ stat test
    Size: 4096            Blocks: 8          IO Block: 4096   regular file

Commit 3c2bdc912a1cc050 ("xfs: kill xfs_zero_remaining_bytes") replaced
xfs_zero_remaining_bytes() with calls to iomap helpers. The new helpers
don't enforce that [pos,offset) lies strictly on [0,i_size) when being
called from xfs_free_file_space(), so by "leaking" these ranges into
xfs_zero_range() we get this buggy behavior.

Fix this by reintroducing the checks xfs_zero_remaining_bytes() did
against i_size at the bottom of xfs_free_file_space().

	Reported-by: Aaron Gao <gzh@fb.com>
Fixes: 3c2bdc912a1cc050 ("xfs: kill xfs_zero_remaining_bytes")
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Brian Foster <bfoster@redhat.com>
	Cc: <stable@vger.kernel.org> # 4.8+
	Signed-off-by: Calvin Owens <calvinowens@fb.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 3dd09d5a8589c640abb49cfcf92b4ed669eafad1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index e68409b0c53f,828532ce0adc..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1135,135 -1275,53 +1135,151 @@@ xfs_free_file_space
  	if (error)
  		return error;
  
 +	error = 0;
  	if (len <= 0)	/* if nothing being freed */
 -		return 0;
 -
 -	error = xfs_flush_unmap_range(ip, offset, len);
 -	if (error)
  		return error;
 -
 -	startoffset_fsb = XFS_B_TO_FSB(mp, offset);
 +	rt = XFS_IS_REALTIME_INODE(ip);
 +	startoffset_fsb	= XFS_B_TO_FSB(mp, offset);
  	endoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);
  
 +	/* wait for the completion of any pending DIOs */
 +	inode_dio_wait(VFS_I(ip));
 +
 +	rounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);
 +	ioffset = round_down(offset, rounding);
 +	iendoffset = round_up(offset + len, rounding) - 1;
 +	error = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,
 +					     iendoffset);
 +	if (error)
 +		goto out;
 +	truncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);
 +
  	/*
 -	 * Need to zero the stuff we're not freeing, on disk.  If it's a RT file
 -	 * and we can't use unwritten extents then we actually need to ensure
 -	 * to zero the whole extent, otherwise we just need to take of block
 -	 * boundaries, and xfs_bunmapi will handle the rest.
 +	 * Need to zero the stuff we're not freeing, on disk.
 +	 * If it's a realtime file & can't use unwritten extents then we
 +	 * actually need to zero the extent edges.  Otherwise xfs_bunmapi
 +	 * will take care of it for us.
  	 */
 -	if (XFS_IS_REALTIME_INODE(ip) &&
 -	    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {
 -		error = xfs_adjust_extent_unmap_boundaries(ip, &startoffset_fsb,
 -				&endoffset_fsb);
 +	if (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {
 +		nimap = 1;
 +		error = xfs_bmapi_read(ip, startoffset_fsb, 1,
 +					&imap, &nimap, 0);
  		if (error)
 -			return error;
 +			goto out;
 +		ASSERT(nimap == 0 || nimap == 1);
 +		if (nimap && imap.br_startblock != HOLESTARTBLOCK) {
 +			xfs_daddr_t	block;
 +
 +			ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
 +			block = imap.br_startblock;
 +			mod = do_div(block, mp->m_sb.sb_rextsize);
 +			if (mod)
 +				startoffset_fsb += mp->m_sb.sb_rextsize - mod;
 +		}
 +		nimap = 1;
 +		error = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,
 +					&imap, &nimap, 0);
 +		if (error)
 +			goto out;
 +		ASSERT(nimap == 0 || nimap == 1);
 +		if (nimap && imap.br_startblock != HOLESTARTBLOCK) {
 +			ASSERT(imap.br_startblock != DELAYSTARTBLOCK);
 +			mod++;
 +			if (mod && (mod != mp->m_sb.sb_rextsize))
 +				endoffset_fsb -= mod;
 +		}
 +	}
 +	if ((done = (endoffset_fsb <= startoffset_fsb)))
 +		/*
 +		 * One contiguous piece to clear
 +		 */
 +		error = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);
 +	else {
 +		/*
 +		 * Some full blocks, possibly two pieces to clear
 +		 */
 +		if (offset < XFS_FSB_TO_B(mp, startoffset_fsb))
 +			error = xfs_zero_remaining_bytes(ip, offset,
 +				XFS_FSB_TO_B(mp, startoffset_fsb) - 1);
 +		if (!error &&
 +		    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)
 +			error = xfs_zero_remaining_bytes(ip,
 +				XFS_FSB_TO_B(mp, endoffset_fsb),
 +				offset + len - 1);
  	}
  
 -	if (endoffset_fsb > startoffset_fsb) {
 -		while (!done) {
 -			error = xfs_unmap_extent(ip, startoffset_fsb,
 -					endoffset_fsb - startoffset_fsb, &done);
 -			if (error)
 -				return error;
 +	/*
++<<<<<<< HEAD
 +	 * free file space until done or until there is an error
 +	 */
 +	resblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);
 +	while (!error && !done) {
 +
 +		/*
 +		 * allocate and setup the transaction. Allow this
 +		 * transaction to dip into the reserve blocks to ensure
 +		 * the freeing of the space succeeds at ENOSPC.
 +		 */
 +		error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0, 0,
 +				&tp);
 +		if (error) {
 +			ASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));
 +			break;
  		}
 +		xfs_ilock(ip, XFS_ILOCK_EXCL);
 +		error = xfs_trans_reserve_quota(tp, mp,
 +				ip->i_udquot, ip->i_gdquot, ip->i_pdquot,
 +				resblks, 0, XFS_QMOPT_RES_REGBLKS);
 +		if (error)
 +			goto error1;
 +
 +		xfs_trans_ijoin(tp, ip, 0);
 +
 +		/*
 +		 * issue the bunmapi() call to free the blocks
 +		 */
 +		xfs_bmap_init(&free_list, &firstfsb);
 +		error = xfs_bunmapi(tp, ip, startoffset_fsb,
 +				  endoffset_fsb - startoffset_fsb,
 +				  0, 2, &firstfsb, &free_list, &done);
 +		if (error)
 +			goto error0;
 +
 +		/*
 +		 * complete the transaction
 +		 */
 +		error = xfs_bmap_finish(&tp, &free_list, NULL);
 +		if (error)
 +			goto error0;
 +
 +		error = xfs_trans_commit(tp);
 +		xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	}
  
 -	/*
 + out:
 +	return error;
 +
 + error0:
 +	xfs_bmap_cancel(&free_list);
 + error1:
 +	xfs_trans_cancel(tp);
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 +	goto out;
++=======
+ 	 * Now that we've unmap all full blocks we'll have to zero out any
+ 	 * partial block at the beginning and/or end.  xfs_zero_range is
+ 	 * smart enough to skip any holes, including those we just created,
+ 	 * but we must take care not to zero beyond EOF and enlarge i_size.
+ 	 */
+ 
+ 	if (offset >= XFS_ISIZE(ip))
+ 		return 0;
+ 
+ 	if (offset + len > XFS_ISIZE(ip))
+ 		len = XFS_ISIZE(ip) - offset;
+ 
+ 	return xfs_zero_range(ip, offset, len, NULL);
++>>>>>>> 3dd09d5a8589 (xfs: Honor FALLOC_FL_KEEP_SIZE when punching ends of files)
  }
  
  /*
* Unmerged path fs/xfs/xfs_bmap_util.c
