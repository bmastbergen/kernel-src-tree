scsi: implement .get_budget and .put_budget for blk-mq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ming Lei <ming.lei@redhat.com>
commit 0df21c86bdbfd17dec9ab898312af9bfb74d5d86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0df21c86.failed

We need to tell blk-mq to reserve resources before queuing one request,
so implement these two callbacks. Then blk-mq can avoid to dequeue
request too early, and IO merging can be improved a lot.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 0df21c86bdbfd17dec9ab898312af9bfb74d5d86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index 540886abddcc,6f10afaca25b..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -1800,28 -1943,35 +1800,52 @@@ static int scsi_mq_prep_fn(struct reque
  static void scsi_mq_done(struct scsi_cmnd *cmd)
  {
  	trace_scsi_dispatch_cmd_done(cmd);
 -	blk_mq_complete_request(cmd->request);
 +	blk_mq_complete_request(cmd->request, cmd->request->errors);
  }
  
++<<<<<<< HEAD
 +static int scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 +			 const struct blk_mq_queue_data *bd)
++=======
+ static void scsi_mq_put_budget(struct blk_mq_hw_ctx *hctx)
++>>>>>>> 0df21c86bdbf (scsi: implement .get_budget and .put_budget for blk-mq)
  {
- 	struct request *req = bd->rq;
- 	struct request_queue *q = req->q;
+ 	struct request_queue *q = hctx->queue;
+ 	struct scsi_device *sdev = q->queuedata;
+ 	struct Scsi_Host *shost = sdev->host;
+ 
+ 	atomic_dec(&shost->host_busy);
+ 	if (scsi_target(sdev)->can_queue > 0)
+ 		atomic_dec(&scsi_target(sdev)->target_busy);
+ 	atomic_dec(&sdev->device_busy);
+ 	put_device(&sdev->sdev_gendev);
+ }
+ 
+ static blk_status_t scsi_mq_get_budget(struct blk_mq_hw_ctx *hctx)
+ {
+ 	struct request_queue *q = hctx->queue;
  	struct scsi_device *sdev = q->queuedata;
  	struct Scsi_Host *shost = sdev->host;
++<<<<<<< HEAD
 +	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
 +	int ret;
 +	int reason;
 +
 +	ret = prep_to_mq(scsi_prep_state_check(sdev, req));
 +	if (ret)
 +		goto out;
 +
 +	ret = BLK_MQ_RQ_QUEUE_BUSY;
++=======
+ 	blk_status_t ret;
+ 
+ 	ret = prep_to_mq(scsi_prep_state_check(sdev, NULL));
+ 	if (ret == BLK_STS_RESOURCE || ret != BLK_STS_OK)
+ 		return ret;
+ 
++>>>>>>> 0df21c86bdbf (scsi: implement .get_budget and .put_budget for blk-mq)
  	if (!get_device(&sdev->sdev_gendev))
  		goto out;
- 
  	if (!scsi_dev_queue_ready(q, sdev))
  		goto out_put_device;
  	if (!scsi_target_queue_ready(shost, sdev))
@@@ -1829,12 -1979,39 +1853,48 @@@
  	if (!scsi_host_queue_ready(q, shost, sdev))
  		goto out_dec_target_busy;
  
++<<<<<<< HEAD
 +
 +	if (!(req->cmd_flags & REQ_DONTPREP)) {
 +		ret = prep_to_mq(scsi_mq_prep_fn(req));
 +		if (ret)
 +			goto out_dec_host_busy;
 +		req->cmd_flags |= REQ_DONTPREP;
++=======
+ 	return BLK_STS_OK;
+ 
+ out_dec_target_busy:
+ 	if (scsi_target(sdev)->can_queue > 0)
+ 		atomic_dec(&scsi_target(sdev)->target_busy);
+ out_dec_device_busy:
+ 	atomic_dec(&sdev->device_busy);
+ out_put_device:
+ 	put_device(&sdev->sdev_gendev);
+ out:
+ 	return BLK_STS_RESOURCE;
+ }
+ 
+ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
+ 			 const struct blk_mq_queue_data *bd)
+ {
+ 	struct request *req = bd->rq;
+ 	struct request_queue *q = req->q;
+ 	struct scsi_device *sdev = q->queuedata;
+ 	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
+ 	blk_status_t ret;
+ 	int reason;
+ 
+ 	ret = prep_to_mq(scsi_prep_state_check(sdev, req));
+ 	if (ret != BLK_STS_OK)
+ 		goto out_put_budget;
+ 
+ 	ret = BLK_STS_RESOURCE;
+ 	if (!(req->rq_flags & RQF_DONTPREP)) {
+ 		ret = prep_to_mq(scsi_mq_prep_fn(req));
+ 		if (ret != BLK_STS_OK)
+ 			goto out_put_budget;
+ 		req->rq_flags |= RQF_DONTPREP;
++>>>>>>> 0df21c86bdbf (scsi: implement .get_budget and .put_budget for blk-mq)
  	} else {
  		blk_mq_start_request(req);
  	}
@@@ -1850,24 -2027,18 +1910,21 @@@
  	reason = scsi_dispatch_cmd(cmd);
  	if (reason) {
  		scsi_set_blocked(cmd, reason);
++<<<<<<< HEAD
 +		ret = BLK_MQ_RQ_QUEUE_BUSY;
 +		goto out_dec_host_busy;
++=======
+ 		ret = BLK_STS_RESOURCE;
+ 		goto out_put_budget;
++>>>>>>> 0df21c86bdbf (scsi: implement .get_budget and .put_budget for blk-mq)
  	}
  
 -	return BLK_STS_OK;
 +	return BLK_MQ_RQ_QUEUE_OK;
  
- out_dec_host_busy:
- 	atomic_dec(&shost->host_busy);
- out_dec_target_busy:
- 	if (scsi_target(sdev)->can_queue > 0)
- 		atomic_dec(&scsi_target(sdev)->target_busy);
- out_dec_device_busy:
- 	atomic_dec(&sdev->device_busy);
- out_put_device:
- 	put_device(&sdev->sdev_gendev);
- out:
+ out_put_budget:
+ 	scsi_mq_put_budget(hctx);
  	switch (ret) {
 -	case BLK_STS_OK:
 -		break;
 -	case BLK_STS_RESOURCE:
 +	case BLK_MQ_RQ_QUEUE_BUSY:
  		if (atomic_read(&sdev->device_busy) == 0 &&
  		    !scsi_device_blocked(sdev))
  			blk_mq_delay_run_hw_queue(hctx, SCSI_QUEUE_DELAY);
@@@ -2003,13 -2237,19 +2060,19 @@@ struct request_queue *scsi_alloc_queue(
  	return q;
  }
  
++<<<<<<< HEAD
 +static struct blk_mq_ops scsi_mq_ops = {
 +	.map_queue	= blk_mq_map_queue,
++=======
+ static const struct blk_mq_ops scsi_mq_ops = {
+ 	.get_budget	= scsi_mq_get_budget,
+ 	.put_budget	= scsi_mq_put_budget,
++>>>>>>> 0df21c86bdbf (scsi: implement .get_budget and .put_budget for blk-mq)
  	.queue_rq	= scsi_queue_rq,
  	.complete	= scsi_softirq_done,
 -	.timeout	= scsi_timeout,
 -#ifdef CONFIG_BLK_DEBUG_FS
 -	.show_rq	= scsi_show_rq,
 -#endif
 -	.init_request	= scsi_mq_init_request,
 -	.exit_request	= scsi_mq_exit_request,
 -	.initialize_rq_fn = scsi_initialize_rq,
 -	.map_queues	= scsi_map_queues,
 +	.timeout        = scsi_timeout,
 +	.init_request	= scsi_init_request,
 +	.exit_request	= scsi_exit_request,
  };
  
  struct request_queue *scsi_mq_alloc_queue(struct scsi_device *sdev)
* Unmerged path drivers/scsi/scsi_lib.c
