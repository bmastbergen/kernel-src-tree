dma-mapping: consolidate dma_supported

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Christoph Hellwig <hch@lst.de>
commit ee196371d5cb1942ebdccc16bdce389812aa265e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ee196371.failed

Most architectures just call into ->dma_supported, but some also return 1
if the method is not present, or 0 if no dma ops are present (although
that should never happeb). Consolidate this more broad version into
common code.

Also fix h8300 which inorrectly always returned 0, which would have been
a problem if it's dma_set_mask implementation wasn't a similarly buggy
noop.

As a few architectures have much more elaborate implementations, we
still allow for arch overrides.

[jcmvbkbc@gmail.com: fix xtensa]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Russell King <linux@arm.linux.org.uk>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Chris Metcalf <cmetcalf@ezchip.com>
	Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ee196371d5cb1942ebdccc16bdce389812aa265e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/alpha/include/asm/dma-mapping.h
#	arch/arm/include/asm/dma-mapping.h
#	arch/arm64/include/asm/dma-mapping.h
#	arch/h8300/include/asm/dma-mapping.h
#	arch/ia64/include/asm/dma-mapping.h
#	arch/mips/include/asm/dma-mapping.h
#	arch/openrisc/include/asm/dma-mapping.h
#	arch/sparc/include/asm/dma-mapping.h
#	arch/tile/include/asm/dma-mapping.h
#	arch/unicore32/include/asm/dma-mapping.h
#	arch/x86/include/asm/dma-mapping.h
#	include/asm-generic/dma-mapping-common.h
diff --cc arch/alpha/include/asm/dma-mapping.h
index dfa32f061320,9d763e535c5a..000000000000
--- a/arch/alpha/include/asm/dma-mapping.h
+++ b/arch/alpha/include/asm/dma-mapping.h
@@@ -12,34 -12,6 +12,37 @@@ static inline struct dma_map_ops *get_d
  
  #include <asm-generic/dma-mapping-common.h>
  
++<<<<<<< HEAD
 +#define dma_alloc_coherent(d,s,h,f)	dma_alloc_attrs(d,s,h,f,NULL)
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t gfp,
 +				    struct dma_attrs *attrs)
 +{
 +	return get_dma_ops(dev)->alloc(dev, size, dma_handle, gfp, attrs);
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *vaddr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	get_dma_ops(dev)->free(dev, size, vaddr, dma_handle, attrs);
 +}
 +
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +{
 +	return get_dma_ops(dev)->mapping_error(dev, dma_addr);
 +}
 +
 +static inline int dma_supported(struct device *dev, u64 mask)
 +{
 +	return get_dma_ops(dev)->dma_supported(dev, mask);
 +}
 +
++=======
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  static inline int dma_set_mask(struct device *dev, u64 mask)
  {
  	return get_dma_ops(dev)->set_dma_mask(dev, mask);
diff --cc arch/arm/include/asm/dma-mapping.h
index 5b579b951503,2f9c731691c0..000000000000
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@@ -28,6 -38,14 +28,17 @@@ static inline void set_dma_ops(struct d
  	dev->archdata.dma_ops = ops;
  }
  
++<<<<<<< HEAD
++=======
+ #define HAVE_ARCH_DMA_SUPPORTED 1
+ extern int dma_supported(struct device *dev, u64 mask);
+ 
+ /*
+  * Note that while the generic code provides dummy dma_{alloc,free}_noncoherent
+  * implementations, we don't provide a dma_cache_sync function so drivers using
+  * this API are highlighted with build warnings.
+  */
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  #include <asm-generic/dma-mapping-common.h>
  
  static inline int dma_set_mask(struct device *dev, u64 mask)
@@@ -86,31 -121,58 +97,54 @@@ static inline dma_addr_t virt_to_dma(st
  }
  #endif
  
 -/* The ARM override for dma_max_pfn() */
 -static inline unsigned long dma_max_pfn(struct device *dev)
 -{
 -	return PHYS_PFN_OFFSET + dma_to_pfn(dev, *dev->dma_mask);
 -}
 -#define dma_max_pfn(dev) dma_max_pfn(dev)
 -
 -#define arch_setup_dma_ops arch_setup_dma_ops
 -extern void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 -			       struct iommu_ops *iommu, bool coherent);
 -
 -#define arch_teardown_dma_ops arch_teardown_dma_ops
 -extern void arch_teardown_dma_ops(struct device *dev);
 -
 -/* do not use this function in a driver */
 -static inline bool is_device_dma_coherent(struct device *dev)
 +/*
 + * DMA errors are defined by all-bits-set in the DMA address.
 + */
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
  {
 -	return dev->archdata.dma_coherent;
 +	debug_dma_mapping_error(dev, dma_addr);
 +	return dma_addr == DMA_ERROR_CODE;
  }
  
 -static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 +/*
 + * Dummy noncoherent implementation.  We don't provide a dma_cache_sync
 + * function so drivers using this API are highlighted with build warnings.
 + */
 +static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
 +		dma_addr_t *handle, gfp_t gfp)
  {
 -	unsigned int offset = paddr & ~PAGE_MASK;
 -	return pfn_to_dma(dev, __phys_to_pfn(paddr)) + offset;
 +	return NULL;
  }
  
 -static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dev_addr)
 +static inline void dma_free_noncoherent(struct device *dev, size_t size,
 +		void *cpu_addr, dma_addr_t handle)
  {
 -	unsigned int offset = dev_addr & ~PAGE_MASK;
 -	return __pfn_to_phys(dma_to_pfn(dev, dev_addr)) + offset;
  }
  
++<<<<<<< HEAD
 +extern int dma_supported(struct device *dev, u64 mask);
++=======
+ static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
+ {
+ 	u64 limit, mask;
+ 
+ 	if (!dev->dma_mask)
+ 		return 0;
+ 
+ 	mask = *dev->dma_mask;
+ 
+ 	limit = (mask + 1) & ~mask;
+ 	if (limit && size > limit)
+ 		return 0;
+ 
+ 	if ((addr | (addr + size - 1)) & ~mask)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ 
+ static inline void dma_mark_clean(void *addr, size_t size) { }
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  
  extern int arm_dma_set_mask(struct device *dev, u64 dma_mask);
  
diff --cc arch/arm64/include/asm/dma-mapping.h
index 994776894198,f519a58c55ae..000000000000
--- a/arch/arm64/include/asm/dma-mapping.h
+++ b/arch/arm64/include/asm/dma-mapping.h
@@@ -21,45 -21,69 +21,48 @@@
  #include <linux/types.h>
  #include <linux/vmalloc.h>
  
 -#include <xen/xen.h>
 -#include <asm/xen/hypervisor.h>
 +#include <asm-generic/dma-coherent.h>
 +
 +#define ARCH_HAS_DMA_GET_REQUIRED_MASK
  
 -#define DMA_ERROR_CODE	(~(dma_addr_t)0)
  extern struct dma_map_ops *dma_ops;
 -extern struct dma_map_ops dummy_dma_ops;
  
 -static inline struct dma_map_ops *__generic_dma_ops(struct device *dev)
 +static inline struct dma_map_ops *get_dma_ops(struct device *dev)
  {
 -	if (unlikely(!dev))
 +	if (unlikely(!dev) || !dev->archdata.dma_ops)
  		return dma_ops;
 -	else if (dev->archdata.dma_ops)
 +	else
  		return dev->archdata.dma_ops;
 -	else if (acpi_disabled)
 -		return dma_ops;
 -
 -	/*
 -	 * When ACPI is enabled, if arch_set_dma_ops is not called,
 -	 * we will disable device DMA capability by setting it
 -	 * to dummy_dma_ops.
 -	 */
 -	return &dummy_dma_ops;
  }
  
 -static inline struct dma_map_ops *get_dma_ops(struct device *dev)
 -{
 -	if (xen_initial_domain())
 -		return xen_dma_ops;
 -	else
 -		return __generic_dma_ops(dev);
 -}
 +#include <asm-generic/dma-mapping-common.h>
  
 -static inline void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 -				      struct iommu_ops *iommu, bool coherent)
 +static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
  {
 -	if (!acpi_disabled && !dev->archdata.dma_ops)
 -		dev->archdata.dma_ops = dma_ops;
 -
 -	dev->archdata.dma_coherent = coherent;
 +	return (dma_addr_t)paddr;
  }
 -#define arch_setup_dma_ops	arch_setup_dma_ops
  
 -/* do not use this function in a driver */
 -static inline bool is_device_dma_coherent(struct device *dev)
 +static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dev_addr)
  {
 -	if (!dev)
 -		return false;
 -	return dev->archdata.dma_coherent;
 +	return (phys_addr_t)dev_addr;
  }
  
 -#include <asm-generic/dma-mapping-common.h>
 -
 -static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
++<<<<<<< HEAD
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t dev_addr)
  {
 -	return (dma_addr_t)paddr;
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	debug_dma_mapping_error(dev, dev_addr);
 +	return ops->mapping_error(dev, dev_addr);
  }
  
 -static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t dev_addr)
 +static inline int dma_supported(struct device *dev, u64 mask)
  {
 -	return (phys_addr_t)dev_addr;
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	return ops->dma_supported(dev, mask);
  }
  
++=======
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  static inline int dma_set_mask(struct device *dev, u64 mask)
  {
  	if (!dev->dma_mask || !dma_supported(dev, mask))
diff --cc arch/ia64/include/asm/dma-mapping.h
index cf3ab7e784b5,7982caa7c5e7..000000000000
--- a/arch/ia64/include/asm/dma-mapping.h
+++ b/arch/ia64/include/asm/dma-mapping.h
@@@ -55,19 -27,6 +55,22 @@@ static inline void dma_free_attrs(struc
  
  #include <asm-generic/dma-mapping-common.h>
  
++<<<<<<< HEAD
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t daddr)
 +{
 +	struct dma_map_ops *ops = platform_dma_get_ops(dev);
 +	debug_dma_mapping_error(dev, daddr);
 +	return ops->mapping_error(dev, daddr);
 +}
 +
 +static inline int dma_supported(struct device *dev, u64 mask)
 +{
 +	struct dma_map_ops *ops = platform_dma_get_ops(dev);
 +	return ops->dma_supported(dev, mask);
 +}
 +
++=======
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  static inline int
  dma_set_mask (struct device *dev, u64 mask)
  {
diff --cc arch/mips/include/asm/dma-mapping.h
index 84238c574d5e,8bf8ec30a4b2..000000000000
--- a/arch/mips/include/asm/dma-mapping.h
+++ b/arch/mips/include/asm/dma-mapping.h
@@@ -32,13 -31,8 +32,18 @@@ static inline void dma_mark_clean(void 
  
  #include <asm-generic/dma-mapping-common.h>
  
++<<<<<<< HEAD
 +static inline int dma_supported(struct device *dev, u64 mask)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	return ops->dma_supported(dev, mask);
 +}
 +
 +static inline int dma_mapping_error(struct device *dev, u64 mask)
++=======
+ static inline int
+ dma_set_mask(struct device *dev, u64 mask)
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  {
  	struct dma_map_ops *ops = get_dma_ops(dev);
  
diff --cc arch/openrisc/include/asm/dma-mapping.h
index fab8628e1b6e,8fc08b883477..000000000000
--- a/arch/openrisc/include/asm/dma-mapping.h
+++ b/arch/openrisc/include/asm/dma-mapping.h
@@@ -36,67 -35,14 +36,75 @@@ static inline struct dma_map_ops *get_d
  	return &or1k_dma_map_ops;
  }
  
++<<<<<<< HEAD
 +#include <asm-generic/dma-mapping-common.h>
 +
 +#define dma_alloc_coherent(d,s,h,f) dma_alloc_attrs(d,s,h,f,NULL) 
 +
 +static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 +				    dma_addr_t *dma_handle, gfp_t gfp,
 +				    struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	void *memory;
 +
 +	memory = ops->alloc(dev, size, dma_handle, gfp, attrs);
 +
 +	debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
 +
 +	return memory;
 +}
 +
 +#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
 +
 +static inline void dma_free_attrs(struct device *dev, size_t size,
 +				  void *cpu_addr, dma_addr_t dma_handle,
 +				  struct dma_attrs *attrs)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +
 +	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
 +
 +	ops->free(dev, size, cpu_addr, dma_handle, attrs);
 +}
 +
 +static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
 +					  dma_addr_t *dma_handle, gfp_t gfp)
 +{
 +	struct dma_attrs attrs;
 +
 +	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
 +
 +	return dma_alloc_attrs(dev, size, dma_handle, gfp, &attrs);
 +}
 +
 +static inline void dma_free_noncoherent(struct device *dev, size_t size,
 +					 void *cpu_addr, dma_addr_t dma_handle)
 +{
 +	struct dma_attrs attrs;
 +
 +	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
 +
 +	dma_free_attrs(dev, size, cpu_addr, dma_handle, &attrs);
 +}
 +
++=======
+ #define HAVE_ARCH_DMA_SUPPORTED 1
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  static inline int dma_supported(struct device *dev, u64 dma_mask)
  {
  	/* Support 32 bit DMA mask exclusively */
  	return dma_mask == DMA_BIT_MASK(32);
  }
  
++<<<<<<< HEAD
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +{
 +	return 0;
 +}
++=======
+ #include <asm-generic/dma-mapping-common.h>
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  
  static inline int dma_set_mask(struct device *dev, u64 dma_mask)
  {
diff --cc arch/sparc/include/asm/dma-mapping.h
index 05fe53f5346e,184651bb0b46..000000000000
--- a/arch/sparc/include/asm/dma-mapping.h
+++ b/arch/sparc/include/asm/dma-mapping.h
@@@ -7,10 -7,16 +7,15 @@@
  
  #define DMA_ERROR_CODE	(~(dma_addr_t)0x0)
  
++<<<<<<< HEAD
 +extern int dma_supported(struct device *dev, u64 mask);
++=======
+ #define HAVE_ARCH_DMA_SUPPORTED 1
+ int dma_supported(struct device *dev, u64 mask);
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  
 -static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
 -				  enum dma_data_direction dir)
 -{
 -	/* Since dma_{alloc,free}_noncoherent() allocated coherent memory, this
 -	 * routine can be a nop.
 -	 */
 -}
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
  
  extern struct dma_map_ops *dma_ops;
  extern struct dma_map_ops *leon_dma_ops;
diff --cc arch/tile/include/asm/dma-mapping.h
index f2ff191376b4,559ed4a60077..000000000000
--- a/arch/tile/include/asm/dma-mapping.h
+++ b/arch/tile/include/asm/dma-mapping.h
@@@ -70,19 -75,6 +70,22 @@@ static inline bool dma_capable(struct d
  }
  
  static inline int
++<<<<<<< HEAD
 +dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +{
 +	debug_dma_mapping_error(dev, dma_addr);
 +	return get_dma_ops(dev)->mapping_error(dev, dma_addr);
 +}
 +
 +static inline int
 +dma_supported(struct device *dev, u64 mask)
 +{
 +	return get_dma_ops(dev)->dma_supported(dev, mask);
 +}
 +
 +static inline int
++=======
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  dma_set_mask(struct device *dev, u64 mask)
  {
  	struct dma_map_ops *dma_ops = get_dma_ops(dev);
diff --cc arch/unicore32/include/asm/dma-mapping.h
index 366460a81796,21231c14182c..000000000000
--- a/arch/unicore32/include/asm/dma-mapping.h
+++ b/arch/unicore32/include/asm/dma-mapping.h
@@@ -30,26 -28,6 +30,29 @@@ static inline struct dma_map_ops *get_d
  	return &swiotlb_dma_map_ops;
  }
  
++<<<<<<< HEAD
 +static inline int dma_supported(struct device *dev, u64 mask)
 +{
 +	struct dma_map_ops *dma_ops = get_dma_ops(dev);
 +
 +	if (unlikely(dma_ops == NULL))
 +		return 0;
 +
 +	return dma_ops->dma_supported(dev, mask);
 +}
 +
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +{
 +	struct dma_map_ops *dma_ops = get_dma_ops(dev);
 +
 +	if (dma_ops->mapping_error)
 +		return dma_ops->mapping_error(dev, dma_addr);
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  #include <asm-generic/dma-mapping-common.h>
  
  static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
diff --cc arch/x86/include/asm/dma-mapping.h
index 1f5b7287d1ad,b1fbf582048b..000000000000
--- a/arch/x86/include/asm/dma-mapping.h
+++ b/arch/x86/include/asm/dma-mapping.h
@@@ -41,23 -40,14 +41,34 @@@ static inline struct dma_map_ops *get_d
  #endif
  }
  
++<<<<<<< HEAD
 +#include <asm-generic/dma-mapping-common.h>
 +
 +/* Make sure we keep the same behaviour */
 +static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 +{
 +	struct dma_map_ops *ops = get_dma_ops(dev);
 +	debug_dma_mapping_error(dev, dma_addr);
 +	if (ops->mapping_error)
 +		return ops->mapping_error(dev, dma_addr);
 +
 +	return (dma_addr == DMA_ERROR_CODE);
 +}
 +
 +#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 +#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 +
 +extern int dma_supported(struct device *hwdev, u64 mask);
++=======
+ bool arch_dma_alloc_attrs(struct device **dev, gfp_t *gfp);
+ #define arch_dma_alloc_attrs arch_dma_alloc_attrs
+ 
+ #define HAVE_ARCH_DMA_SUPPORTED 1
+ extern int dma_supported(struct device *hwdev, u64 mask);
+ 
+ #include <asm-generic/dma-mapping-common.h>
+ 
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  extern int dma_set_mask(struct device *dev, u64 mask);
  
  extern void *dma_generic_alloc_coherent(struct device *dev, size_t size,
diff --cc include/asm-generic/dma-mapping-common.h
index de8bf89940f8,67fa6bcd644c..000000000000
--- a/include/asm-generic/dma-mapping-common.h
+++ b/include/asm-generic/dma-mapping-common.h
@@@ -231,4 -238,106 +231,109 @@@ dma_get_sgtable_attrs(struct device *de
  
  #define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, NULL)
  
++<<<<<<< HEAD
++=======
+ #ifndef arch_dma_alloc_attrs
+ #define arch_dma_alloc_attrs(dev, flag)	(true)
+ #endif
+ 
+ static inline void *dma_alloc_attrs(struct device *dev, size_t size,
+ 				       dma_addr_t *dma_handle, gfp_t flag,
+ 				       struct dma_attrs *attrs)
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 	void *cpu_addr;
+ 
+ 	BUG_ON(!ops);
+ 
+ 	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
+ 		return cpu_addr;
+ 
+ 	if (!arch_dma_alloc_attrs(&dev, &flag))
+ 		return NULL;
+ 	if (!ops->alloc)
+ 		return NULL;
+ 
+ 	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
+ 	debug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr);
+ 	return cpu_addr;
+ }
+ 
+ static inline void dma_free_attrs(struct device *dev, size_t size,
+ 				     void *cpu_addr, dma_addr_t dma_handle,
+ 				     struct dma_attrs *attrs)
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	BUG_ON(!ops);
+ 	WARN_ON(irqs_disabled());
+ 
+ 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
+ 		return;
+ 
+ 	if (!ops->free)
+ 		return;
+ 
+ 	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
+ 	ops->free(dev, size, cpu_addr, dma_handle, attrs);
+ }
+ 
+ static inline void *dma_alloc_coherent(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, gfp_t flag)
+ {
+ 	return dma_alloc_attrs(dev, size, dma_handle, flag, NULL);
+ }
+ 
+ static inline void dma_free_coherent(struct device *dev, size_t size,
+ 		void *cpu_addr, dma_addr_t dma_handle)
+ {
+ 	return dma_free_attrs(dev, size, cpu_addr, dma_handle, NULL);
+ }
+ 
+ static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
+ 		dma_addr_t *dma_handle, gfp_t gfp)
+ {
+ 	DEFINE_DMA_ATTRS(attrs);
+ 
+ 	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+ 	return dma_alloc_attrs(dev, size, dma_handle, gfp, &attrs);
+ }
+ 
+ static inline void dma_free_noncoherent(struct device *dev, size_t size,
+ 		void *cpu_addr, dma_addr_t dma_handle)
+ {
+ 	DEFINE_DMA_ATTRS(attrs);
+ 
+ 	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+ 	dma_free_attrs(dev, size, cpu_addr, dma_handle, &attrs);
+ }
+ 
+ static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+ {
+ 	debug_dma_mapping_error(dev, dma_addr);
+ 
+ 	if (get_dma_ops(dev)->mapping_error)
+ 		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
+ 
+ #ifdef DMA_ERROR_CODE
+ 	return dma_addr == DMA_ERROR_CODE;
+ #else
+ 	return 0;
+ #endif
+ }
+ 
+ #ifndef HAVE_ARCH_DMA_SUPPORTED
+ static inline int dma_supported(struct device *dev, u64 mask)
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	if (!ops)
+ 		return 0;
+ 	if (!ops->dma_supported)
+ 		return 1;
+ 	return ops->dma_supported(dev, mask);
+ }
+ #endif
+ 
++>>>>>>> ee196371d5cb (dma-mapping: consolidate dma_supported)
  #endif
* Unmerged path arch/h8300/include/asm/dma-mapping.h
* Unmerged path arch/alpha/include/asm/dma-mapping.h
* Unmerged path arch/arm/include/asm/dma-mapping.h
* Unmerged path arch/arm64/include/asm/dma-mapping.h
* Unmerged path arch/h8300/include/asm/dma-mapping.h
diff --git a/arch/hexagon/include/asm/dma-mapping.h b/arch/hexagon/include/asm/dma-mapping.h
index 85e9935660cb..0702a3684f53 100644
--- a/arch/hexagon/include/asm/dma-mapping.h
+++ b/arch/hexagon/include/asm/dma-mapping.h
@@ -46,6 +46,7 @@ static inline struct dma_map_ops *get_dma_ops(struct device *dev)
 	return dma_ops;
 }
 
+#define HAVE_ARCH_DMA_SUPPORTED 1
 extern int dma_supported(struct device *dev, u64 mask);
 extern int dma_set_mask(struct device *dev, u64 mask);
 extern int dma_is_consistent(struct device *dev, dma_addr_t dma_handle);
* Unmerged path arch/ia64/include/asm/dma-mapping.h
diff --git a/arch/microblaze/include/asm/dma-mapping.h b/arch/microblaze/include/asm/dma-mapping.h
index 46460f1c49c4..152db7f715b7 100644
--- a/arch/microblaze/include/asm/dma-mapping.h
+++ b/arch/microblaze/include/asm/dma-mapping.h
@@ -68,16 +68,7 @@ static inline void set_dma_ops(struct device *dev, struct dma_map_ops *ops)
 	dev->archdata.dma_ops = ops;
 }
 
-static inline int dma_supported(struct device *dev, u64 mask)
-{
-	struct dma_map_ops *ops = get_dma_ops(dev);
-
-	if (unlikely(!ops))
-		return 0;
-	if (!ops->dma_supported)
-		return 1;
-	return ops->dma_supported(dev, mask);
-}
+#include <asm-generic/dma-mapping-common.h>
 
 static inline int dma_set_mask(struct device *dev, u64 dma_mask)
 {
@@ -93,8 +84,6 @@ static inline int dma_set_mask(struct device *dev, u64 dma_mask)
 	return 0;
 }
 
-#include <asm-generic/dma-mapping-common.h>
-
 static inline void __dma_sync(unsigned long paddr,
 			      size_t size, enum dma_data_direction direction)
 {
* Unmerged path arch/mips/include/asm/dma-mapping.h
* Unmerged path arch/openrisc/include/asm/dma-mapping.h
diff --git a/arch/powerpc/include/asm/dma-mapping.h b/arch/powerpc/include/asm/dma-mapping.h
index c6f39b7c9f40..1282942b1792 100644
--- a/arch/powerpc/include/asm/dma-mapping.h
+++ b/arch/powerpc/include/asm/dma-mapping.h
@@ -122,17 +122,6 @@ static inline void set_dma_offset(struct device *dev, dma_addr_t off)
 
 #include <asm-generic/dma-mapping-common.h>
 
-static inline int dma_supported(struct device *dev, u64 mask)
-{
-	struct dma_map_ops *dma_ops = get_dma_ops(dev);
-
-	if (unlikely(dma_ops == NULL))
-		return 0;
-	if (dma_ops->dma_supported == NULL)
-		return 1;
-	return dma_ops->dma_supported(dev, mask);
-}
-
 extern int dma_set_mask(struct device *dev, u64 dma_mask);
 extern int __dma_set_mask(struct device *dev, u64 dma_mask);
 extern u64 __dma_get_required_mask(struct device *dev);
diff --git a/arch/s390/include/asm/dma-mapping.h b/arch/s390/include/asm/dma-mapping.h
index 3f2d5669375a..814e5ab6e083 100644
--- a/arch/s390/include/asm/dma-mapping.h
+++ b/arch/s390/include/asm/dma-mapping.h
@@ -32,15 +32,6 @@ static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
 
 #include <asm-generic/dma-mapping-common.h>
 
-static inline int dma_supported(struct device *dev, u64 mask)
-{
-	struct dma_map_ops *dma_ops = get_dma_ops(dev);
-
-	if (dma_ops->dma_supported == NULL)
-		return 1;
-	return dma_ops->dma_supported(dev, mask);
-}
-
 static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
 {
 	if (!dev->dma_mask)
diff --git a/arch/sh/include/asm/dma-mapping.h b/arch/sh/include/asm/dma-mapping.h
index b437f2c780b8..1cdc0b659745 100644
--- a/arch/sh/include/asm/dma-mapping.h
+++ b/arch/sh/include/asm/dma-mapping.h
@@ -12,16 +12,6 @@ static inline struct dma_map_ops *get_dma_ops(struct device *dev)
 #include <asm-generic/dma-coherent.h>
 #include <asm-generic/dma-mapping-common.h>
 
-static inline int dma_supported(struct device *dev, u64 mask)
-{
-	struct dma_map_ops *ops = get_dma_ops(dev);
-
-	if (ops->dma_supported)
-		return ops->dma_supported(dev, mask);
-
-	return 1;
-}
-
 static inline int dma_set_mask(struct device *dev, u64 mask)
 {
 	struct dma_map_ops *ops = get_dma_ops(dev);
* Unmerged path arch/sparc/include/asm/dma-mapping.h
* Unmerged path arch/tile/include/asm/dma-mapping.h
* Unmerged path arch/unicore32/include/asm/dma-mapping.h
* Unmerged path arch/x86/include/asm/dma-mapping.h
diff --git a/arch/xtensa/include/asm/dma-mapping.h b/arch/xtensa/include/asm/dma-mapping.h
index 172a02a6ad14..b5fe72c7b616 100644
--- a/arch/xtensa/include/asm/dma-mapping.h
+++ b/arch/xtensa/include/asm/dma-mapping.h
@@ -146,12 +146,6 @@ dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 	return 0;
 }
 
-static inline int
-dma_supported(struct device *dev, u64 mask)
-{
-	return 1;
-}
-
 static inline int
 dma_set_mask(struct device *dev, u64 mask)
 {
* Unmerged path include/asm-generic/dma-mapping-common.h
