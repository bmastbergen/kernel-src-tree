cifs: Use smb 2 - 3 and cifsacl mount options setacl function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Shirish Pargaonkar <shirishpargaonkar@gmail.com>
commit 366ed846df607a79b4d9b52b097c01f9d53b9d2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/366ed846.failed

Added set acl function. Very similar to set cifs acl function for smb1.

	Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
	Signed-off-by: Steve French <smfrench@gmail.com>
	Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
(cherry picked from commit 366ed846df607a79b4d9b52b097c01f9d53b9d2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/smb2ops.c
index f4acb0a6593b,ed98daa0891c..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -1181,6 -1288,165 +1181,168 @@@ smb2_query_symlink(const unsigned int x
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CIFS_ACL
+ static struct cifs_ntsd *
+ get_smb2_acl_by_fid(struct cifs_sb_info *cifs_sb,
+ 		const struct cifs_fid *cifsfid, u32 *pacllen)
+ {
+ 	struct cifs_ntsd *pntsd = NULL;
+ 	unsigned int xid;
+ 	int rc = -EOPNOTSUPP;
+ 	struct tcon_link *tlink = cifs_sb_tlink(cifs_sb);
+ 
+ 	if (IS_ERR(tlink))
+ 		return ERR_CAST(tlink);
+ 
+ 	xid = get_xid();
+ 	cifs_dbg(FYI, "trying to get acl\n");
+ 
+ 	rc = SMB2_query_acl(xid, tlink_tcon(tlink), cifsfid->persistent_fid,
+ 			    cifsfid->volatile_fid, (void **)&pntsd, pacllen);
+ 	free_xid(xid);
+ 
+ 	cifs_put_tlink(tlink);
+ 
+ 	cifs_dbg(FYI, "%s: rc = %d ACL len %d\n", __func__, rc, *pacllen);
+ 	if (rc)
+ 		return ERR_PTR(rc);
+ 	return pntsd;
+ 
+ }
+ 
+ static struct cifs_ntsd *
+ get_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,
+ 		const char *path, u32 *pacllen)
+ {
+ 	struct cifs_ntsd *pntsd = NULL;
+ 	u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
+ 	unsigned int xid;
+ 	int rc;
+ 	struct cifs_tcon *tcon;
+ 	struct tcon_link *tlink = cifs_sb_tlink(cifs_sb);
+ 	struct cifs_fid fid;
+ 	struct cifs_open_parms oparms;
+ 	__le16 *utf16_path;
+ 
+ 	cifs_dbg(FYI, "get smb3 acl for path %s\n", path);
+ 	if (IS_ERR(tlink))
+ 		return ERR_CAST(tlink);
+ 
+ 	tcon = tlink_tcon(tlink);
+ 	xid = get_xid();
+ 
+ 	if (backup_cred(cifs_sb))
+ 		oparms.create_options = CREATE_OPEN_BACKUP_INTENT;
+ 	else
+ 		oparms.create_options = 0;
+ 
+ 	utf16_path = cifs_convert_path_to_utf16(path, cifs_sb);
+ 	if (!utf16_path)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	oparms.tcon = tcon;
+ 	oparms.desired_access = READ_CONTROL;
+ 	oparms.disposition = FILE_OPEN;
+ 	oparms.fid = &fid;
+ 	oparms.reconnect = false;
+ 
+ 	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);
+ 	kfree(utf16_path);
+ 	if (!rc) {
+ 		rc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,
+ 			    fid.volatile_fid, (void **)&pntsd, pacllen);
+ 		SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+ 	}
+ 
+ 	cifs_put_tlink(tlink);
+ 	free_xid(xid);
+ 
+ 	cifs_dbg(FYI, "%s: rc = %d ACL len %d\n", __func__, rc, *pacllen);
+ 	if (rc)
+ 		return ERR_PTR(rc);
+ 	return pntsd;
+ }
+ 
+ #ifdef CONFIG_CIFS_ACL
+ static int
+ set_smb2_acl(struct cifs_ntsd *pnntsd, __u32 acllen,
+ 		struct inode *inode, const char *path, int aclflag)
+ {
+ 	u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
+ 	unsigned int xid;
+ 	int rc, access_flags = 0;
+ 	struct cifs_tcon *tcon;
+ 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
+ 	struct tcon_link *tlink = cifs_sb_tlink(cifs_sb);
+ 	struct cifs_fid fid;
+ 	struct cifs_open_parms oparms;
+ 	__le16 *utf16_path;
+ 
+ 	cifs_dbg(FYI, "set smb3 acl for path %s\n", path);
+ 	if (IS_ERR(tlink))
+ 		return PTR_ERR(tlink);
+ 
+ 	tcon = tlink_tcon(tlink);
+ 	xid = get_xid();
+ 
+ 	if (backup_cred(cifs_sb))
+ 		oparms.create_options = CREATE_OPEN_BACKUP_INTENT;
+ 	else
+ 		oparms.create_options = 0;
+ 
+ 	if (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)
+ 		access_flags = WRITE_OWNER;
+ 	else
+ 		access_flags = WRITE_DAC;
+ 
+ 	utf16_path = cifs_convert_path_to_utf16(path, cifs_sb);
+ 	if (!utf16_path)
+ 		return -ENOMEM;
+ 
+ 	oparms.tcon = tcon;
+ 	oparms.desired_access = access_flags;
+ 	oparms.disposition = FILE_OPEN;
+ 	oparms.path = path;
+ 	oparms.fid = &fid;
+ 	oparms.reconnect = false;
+ 
+ 	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);
+ 	kfree(utf16_path);
+ 	if (!rc) {
+ 		rc = SMB2_set_acl(xid, tlink_tcon(tlink), fid.persistent_fid,
+ 			    fid.volatile_fid, pnntsd, acllen, aclflag);
+ 		SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+ 	}
+ 
+ 	cifs_put_tlink(tlink);
+ 	free_xid(xid);
+ 	return rc;
+ }
+ #endif /* CIFS_ACL */
+ 
+ /* Retrieve an ACL from the server */
+ static struct cifs_ntsd *
+ get_smb2_acl(struct cifs_sb_info *cifs_sb,
+ 				      struct inode *inode, const char *path,
+ 				      u32 *pacllen)
+ {
+ 	struct cifs_ntsd *pntsd = NULL;
+ 	struct cifsFileInfo *open_file = NULL;
+ 
+ 	if (inode)
+ 		open_file = find_readable_file(CIFS_I(inode), true);
+ 	if (!open_file)
+ 		return get_smb2_acl_by_path(cifs_sb, path, pacllen);
+ 
+ 	pntsd = get_smb2_acl_by_fid(cifs_sb, &open_file->fid, pacllen);
+ 	cifsFileInfo_put(open_file);
+ 	return pntsd;
+ }
+ #endif
+ 
++>>>>>>> 366ed846df60 (cifs: Use smb 2 - 3 and cifsacl mount options setacl function)
  static long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,
  			    loff_t offset, loff_t len, bool keep_size)
  {
@@@ -1631,9 -2547,16 +1793,19 @@@ struct smb_version_operations smb20_ope
  	.set_oplock_level = smb2_set_oplock_level,
  	.create_lease_buf = smb2_create_lease_buf,
  	.parse_lease_buf = smb2_parse_lease_buf,
 -	.copychunk_range = smb2_copychunk_range,
 +	.clone_range = smb2_clone_range,
  	.wp_retry_size = smb2_wp_retry_size,
  	.dir_needs_close = smb2_dir_needs_close,
++<<<<<<< HEAD
++=======
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_ACL
+ 	.get_acl = get_smb2_acl,
+ 	.get_acl_by_fid = get_smb2_acl_by_fid,
+ 	.set_acl = set_smb2_acl,
+ #endif /* CIFS_ACL */
++>>>>>>> 366ed846df60 (cifs: Use smb 2 - 3 and cifsacl mount options setacl function)
  };
  
  struct smb_version_operations smb21_operations = {
@@@ -1715,6 -2639,13 +1887,16 @@@
  	.wp_retry_size = smb2_wp_retry_size,
  	.dir_needs_close = smb2_dir_needs_close,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_ACL
+ 	.get_acl = get_smb2_acl,
+ 	.get_acl_by_fid = get_smb2_acl_by_fid,
+ 	.set_acl = set_smb2_acl,
+ #endif /* CIFS_ACL */
++>>>>>>> 366ed846df60 (cifs: Use smb 2 - 3 and cifsacl mount options setacl function)
  };
  
  struct smb_version_operations smb30_operations = {
@@@ -1802,6 -2734,17 +1984,20 @@@
  	.dir_needs_close = smb2_dir_needs_close,
  	.fallocate = smb3_fallocate,
  	.enum_snapshots = smb3_enum_snapshots,
++<<<<<<< HEAD
++=======
+ 	.init_transform_rq = smb3_init_transform_rq,
+ 	.free_transform_rq = smb3_free_transform_rq,
+ 	.is_transform_hdr = smb3_is_transform_hdr,
+ 	.receive_transform = smb3_receive_transform,
+ 	.get_dfs_refer = smb2_get_dfs_refer,
+ 	.select_sectype = smb2_select_sectype,
+ #ifdef CONFIG_CIFS_ACL
+ 	.get_acl = get_smb2_acl,
+ 	.get_acl_by_fid = get_smb2_acl_by_fid,
+ 	.set_acl = set_smb2_acl,
+ #endif /* CIFS_ACL */
++>>>>>>> 366ed846df60 (cifs: Use smb 2 - 3 and cifsacl mount options setacl function)
  };
  
  #ifdef CONFIG_CIFS_SMB311
* Unmerged path fs/cifs/smb2ops.c
