ovl: treat special files like a regular fs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit ca4c8a3a800039c2681d609c5b7491c1bd17c0a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ca4c8a3a.failed

No sense in opening special files on the underlying layers, they work just
as well if opened on the overlay.

Side effect is that it's no longer possible to connect one side of a pipe
opened on overlayfs with the other side opened on the underlying layer.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit ca4c8a3a800039c2681d609c5b7491c1bd17c0a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index b5466ac817a0,a10e948d24fa..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -407,13 -338,18 +407,16 @@@ static void ovl_fill_inode(struct inod
  	inode->i_ino = get_next_ino();
  	inode->i_mode = mode;
  	inode->i_flags |= S_NOCMTIME;
 -#ifdef CONFIG_FS_POSIX_ACL
 -	inode->i_acl = inode->i_default_acl = ACL_DONT_CACHE;
 -#endif
  
- 	mode &= S_IFMT;
- 	switch (mode) {
+ 	switch (mode & S_IFMT) {
+ 	case S_IFREG:
+ 		inode->i_op = &ovl_file_inode_operations;
+ 		break;
+ 
  	case S_IFDIR:
 -		inode->i_op = &ovl_dir_inode_operations;
 +		inode->i_op = &ovl_dir_inode_operations.ops;
  		inode->i_fop = &ovl_dir_operations;
 +		inode->i_flags |= S_IOPS_WRAPPER;
  		break;
  
  	case S_IFLNK:
@@@ -421,16 -357,8 +424,21 @@@
  		break;
  
  	default:
++<<<<<<< HEAD
 +		WARN(1, "illegal file type: %i\n", mode);
 +		/* Fall through */
 +
 +	case S_IFREG:
 +	case S_IFSOCK:
 +	case S_IFBLK:
 +	case S_IFCHR:
 +	case S_IFIFO:
 +		inode->i_op = &ovl_file_inode_operations.ops;
 +		inode->i_flags |= S_IOPS_WRAPPER;
++=======
+ 		inode->i_op = &ovl_file_inode_operations;
+ 		init_special_inode(inode, mode, rdev);
++>>>>>>> ca4c8a3a8000 (ovl: treat special files like a regular fs)
  		break;
  	}
  }
diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c
index 44efbe35eb73..2a648e61bf73 100644
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@ -581,7 +581,7 @@ static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,
 		goto out;
 
 	err = -ENOMEM;
-	inode = ovl_new_inode(dentry->d_sb, mode);
+	inode = ovl_new_inode(dentry->d_sb, mode, rdev);
 	if (!inode)
 		goto out_drop_write;
 
* Unmerged path fs/overlayfs/inode.c
diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index ad2b64b7794f..3c5d387ba186 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -195,7 +195,7 @@ int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
-struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
+struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 9c63613b5388..8b043e8454ce 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -305,7 +305,7 @@ static struct dentry *ovl_d_real(struct dentry *dentry,
 {
 	struct dentry *real;
 
-	if (d_is_dir(dentry)) {
+	if (!d_is_reg(dentry)) {
 		if (!inode || inode == d_inode(dentry))
 			return dentry;
 		goto bug;
@@ -583,7 +583,8 @@ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 		if (upperdentry && !d_is_dir(upperdentry)) {
 			inode = ovl_get_inode(dentry->d_sb, realinode);
 		} else {
-			inode = ovl_new_inode(dentry->d_sb, realinode->i_mode);
+			inode = ovl_new_inode(dentry->d_sb, realinode->i_mode,
+					      realinode->i_rdev);
 			if (inode)
 				ovl_inode_init(inode, realinode, !!upperdentry);
 		}
@@ -1356,7 +1357,7 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_fs_info = ufs;
 	sb->s_flags |= MS_POSIXACL | MS_NOREMOTELOCK;
 
-	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR));
+	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, 0));
 	if (!root_dentry)
 		goto out_free_oe;
 
