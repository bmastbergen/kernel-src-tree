fs/mpage.c: fix mpage_writepage() for pages with buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] mpage.c: fix mpage_writepage() for pages with buffers (Eric Sandeen) [1476389]
Rebuild_FUZZ: 97.25%
commit-author Matthew Wilcox <willy@infradead.org>
commit f892760aa66a2d657deaf59538fb69433036767c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/f892760a.failed

When using FAT on a block device which supports rw_page, we can hit
BUG_ON(!PageLocked(page)) in try_to_free_buffers().  This is because we
call clean_buffers() after unlocking the page we've written.  Introduce
a new clean_page_buffers() which cleans all buffers associated with a
page and call it from within bdev_write_page().

[akpm@linux-foundation.org: s/PAGE_SIZE/~0U/ per Linus and Matthew]
Link: http://lkml.kernel.org/r/20171006211541.GA7409@bombadil.infradead.org
	Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
	Reported-by: Toshi Kani <toshi.kani@hpe.com>
	Reported-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
	Tested-by: Toshi Kani <toshi.kani@hpe.com>
	Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f892760aa66a2d657deaf59538fb69433036767c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/block_dev.c
diff --cc fs/block_dev.c
index ed7207dfa086,789f55e851ae..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -519,11 -715,13 +519,18 @@@ int bdev_write_page(struct block_devic
  		return result;
  
  	set_page_writeback(page);
++<<<<<<< HEAD
 +	result = ops->rw_page(bdev, sector + get_start_sect(bdev), page, rw);
 +	if (result)
++=======
+ 	result = ops->rw_page(bdev, sector + get_start_sect(bdev), page, true);
+ 	if (result) {
++>>>>>>> f892760aa66a (fs/mpage.c: fix mpage_writepage() for pages with buffers)
  		end_page_writeback(page);
- 	else
+ 	} else {
+ 		clean_page_buffers(page);
  		unlock_page(page);
+ 	}
  	blk_queue_exit(bdev->bd_queue);
  	return result;
  }
* Unmerged path fs/block_dev.c
diff --git a/fs/mpage.c b/fs/mpage.c
index 5f69658231ea..b987897d87ff 100644
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@ -459,6 +459,16 @@ static void clean_buffers(struct page *page, unsigned first_unmapped)
 		try_to_free_buffers(page);
 }
 
+/*
+ * For situations where we want to clean all buffers attached to a page.
+ * We don't need to calculate how many buffers are attached to the page,
+ * we just need to specify a number larger than the maximum number of buffers.
+ */
+void clean_page_buffers(struct page *page)
+{
+	clean_buffers(page, ~0U);
+}
+
 static int __mpage_writepage(struct page *page, struct writeback_control *wbc,
 		      void *data)
 {
@@ -596,10 +606,8 @@ alloc_new:
 	if (bio == NULL) {
 		if (first_unmapped == blocks_per_page) {
 			if (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),
-								page, wbc)) {
-				clean_buffers(page, first_unmapped);
+								page, wbc))
 				goto out;
-			}
 		}
 		bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),
 				bio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);
diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h
index ecf7642d376f..22502875b939 100644
--- a/include/linux/buffer_head.h
+++ b/include/linux/buffer_head.h
@@ -228,6 +228,7 @@ int generic_write_end(struct file *, struct address_space *,
 				loff_t, unsigned, unsigned,
 				struct page *, void *);
 void page_zero_new_buffers(struct page *page, unsigned from, unsigned to);
+void clean_page_buffers(struct page *page);
 int cont_write_begin(struct file *, struct address_space *, loff_t,
 			unsigned, unsigned, struct page **, void **,
 			get_block_t *, loff_t *);
