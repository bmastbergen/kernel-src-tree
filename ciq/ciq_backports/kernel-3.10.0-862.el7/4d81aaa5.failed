s390/pageattr: handle numpages parameter correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] pageattr: handle numpages parameter correctly (Hendrik Brueckner) [1489742]
Rebuild_FUZZ: 94.74%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 4d81aaa53c2dea220ddf88e19c33033d6cf4f8cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4d81aaa5.failed

Both set_memory_ro() and set_memory_rw() will modify the page
attributes of at least one page, even if the numpages parameter is
zero.

The author expected that calling these functions with numpages == zero
would never happen. However with the new 444d13ff10fb ("modules: add
ro_after_init support") feature this happens frequently.

Therefore do the right thing and make these two functions return
gracefully if nothing should be done.

Fixes crashes on module load like this one:

Unable to handle kernel pointer dereference in virtual kernel address space
Failing address: 000003ff80008000 TEID: 000003ff80008407
Fault in home space mode while using kernel ASCE.
AS:0000000000d18007 R3:00000001e6aa4007 S:00000001e6a10800 P:00000001e34ee21d
Oops: 0004 ilc:3 [#1] SMP
Modules linked in: x_tables
CPU: 10 PID: 1 Comm: systemd Not tainted 4.7.0-11895-g3fa9045 #4
Hardware name: IBM              2964 N96              703              (LPAR)
task: 00000001e9118000 task.stack: 00000001e9120000
Krnl PSW : 0704e00180000000 00000000005677f8 (rb_erase+0xf0/0x4d0)
           R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3
Krnl GPRS: 000003ff80008b20 000003ff80008b20 000003ff80008b70 0000000000b9d608
           000003ff80008b20 0000000000000000 00000001e9123e88 000003ff80008950
           00000001e485ab40 000003ff00000000 000003ff80008b00 00000001e4858480
           0000000100000000 000003ff80008b68 00000000001d5998 00000001e9123c28
Krnl Code: 00000000005677e8: ec1801c3007c        cgij    %r1,0,8,567b6e
           00000000005677ee: e32010100020        cg      %r2,16(%r1)
          #00000000005677f4: a78401c2            brc     8,567b78
          >00000000005677f8: e35010080024        stg     %r5,8(%r1)
           00000000005677fe: ec5801af007c        cgij    %r5,0,8,567b5c
           0000000000567804: e30050000024        stg     %r0,0(%r5)
           000000000056780a: ebacf0680004        lmg     %r10,%r12,104(%r15)
           0000000000567810: 07fe                bcr     15,%r14
Call Trace:
([<000003ff80008900>] __this_module+0x0/0xffffffffffffd700 [x_tables])
([<0000000000264fd4>] do_init_module+0x12c/0x220)
([<00000000001da14a>] load_module+0x24e2/0x2b10)
([<00000000001da976>] SyS_finit_module+0xbe/0xd8)
([<0000000000803b26>] system_call+0xd6/0x264)
Last Breaking-Event-Address:
 [<000000000056771a>] rb_erase+0x12/0x4d0
 Kernel panic - not syncing: Fatal exception: panic_on_oops

	Reported-by: Christian Borntraeger <borntraeger@de.ibm.com>
Reported-and-tested-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Fixes: e8a97e42dc98 ("s390/pageattr: allow kernel page table splitting")
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 4d81aaa53c2dea220ddf88e19c33033d6cf4f8cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/mm/pageattr.c
diff --cc arch/s390/mm/pageattr.c
index 954cfcf38d1b,af7cf28cf97e..000000000000
--- a/arch/s390/mm/pageattr.c
+++ b/arch/s390/mm/pageattr.c
@@@ -37,44 -39,236 +37,52 @@@ void __storage_key_init_range(unsigned 
  		start += PAGE_SIZE;
  	}
  }
 +#endif
  
 -#ifdef CONFIG_PROC_FS
 -atomic_long_t direct_pages_count[PG_DIRECT_MAP_MAX];
 -
 -void arch_report_meminfo(struct seq_file *m)
 -{
 -	seq_printf(m, "DirectMap4k:    %8lu kB\n",
 -		   atomic_long_read(&direct_pages_count[PG_DIRECT_MAP_4K]) << 2);
 -	seq_printf(m, "DirectMap1M:    %8lu kB\n",
 -		   atomic_long_read(&direct_pages_count[PG_DIRECT_MAP_1M]) << 10);
 -	seq_printf(m, "DirectMap2G:    %8lu kB\n",
 -		   atomic_long_read(&direct_pages_count[PG_DIRECT_MAP_2G]) << 21);
 -}
 -#endif /* CONFIG_PROC_FS */
 -
 -static void pgt_set(unsigned long *old, unsigned long new, unsigned long addr,
 -		    unsigned long dtt)
 -{
 -	unsigned long table, mask;
 -
 -	mask = 0;
 -	if (MACHINE_HAS_EDAT2) {
 -		switch (dtt) {
 -		case CRDTE_DTT_REGION3:
 -			mask = ~(PTRS_PER_PUD * sizeof(pud_t) - 1);
 -			break;
 -		case CRDTE_DTT_SEGMENT:
 -			mask = ~(PTRS_PER_PMD * sizeof(pmd_t) - 1);
 -			break;
 -		case CRDTE_DTT_PAGE:
 -			mask = ~(PTRS_PER_PTE * sizeof(pte_t) - 1);
 -			break;
 -		}
 -		table = (unsigned long)old & mask;
 -		crdte(*old, new, table, dtt, addr, S390_lowcore.kernel_asce);
 -	} else if (MACHINE_HAS_IDTE) {
 -		cspg(old, *old, new);
 -	} else {
 -		csp((unsigned int *)old + 1, *old, new);
 -	}
 -}
 -
 -struct cpa {
 -	unsigned int set_ro	: 1;
 -	unsigned int clear_ro	: 1;
 -};
 -
 -static int walk_pte_level(pmd_t *pmdp, unsigned long addr, unsigned long end,
 -			  struct cpa cpa)
 -{
 -	pte_t *ptep, new;
 -
 -	ptep = pte_offset(pmdp, addr);
 -	do {
 -		if (pte_none(*ptep))
 -			return -EINVAL;
 -		if (cpa.set_ro)
 -			new = pte_wrprotect(*ptep);
 -		else if (cpa.clear_ro)
 -			new = pte_mkwrite(pte_mkdirty(*ptep));
 -		pgt_set((unsigned long *)ptep, pte_val(new), addr, CRDTE_DTT_PAGE);
 -		ptep++;
 -		addr += PAGE_SIZE;
 -		cond_resched();
 -	} while (addr < end);
 -	return 0;
 -}
 -
 -static int split_pmd_page(pmd_t *pmdp, unsigned long addr)
 -{
 -	unsigned long pte_addr, prot;
 -	pte_t *pt_dir, *ptep;
 -	pmd_t new;
 -	int i, ro;
 -
 -	pt_dir = vmem_pte_alloc();
 -	if (!pt_dir)
 -		return -ENOMEM;
 -	pte_addr = pmd_pfn(*pmdp) << PAGE_SHIFT;
 -	ro = !!(pmd_val(*pmdp) & _SEGMENT_ENTRY_PROTECT);
 -	prot = pgprot_val(ro ? PAGE_KERNEL_RO : PAGE_KERNEL);
 -	ptep = pt_dir;
 -	for (i = 0; i < PTRS_PER_PTE; i++) {
 -		pte_val(*ptep) = pte_addr | prot;
 -		pte_addr += PAGE_SIZE;
 -		ptep++;
 -	}
 -	pmd_val(new) = __pa(pt_dir) | _SEGMENT_ENTRY;
 -	pgt_set((unsigned long *)pmdp, pmd_val(new), addr, CRDTE_DTT_SEGMENT);
 -	update_page_count(PG_DIRECT_MAP_4K, PTRS_PER_PTE);
 -	update_page_count(PG_DIRECT_MAP_1M, -1);
 -	return 0;
 -}
 -
 -static void modify_pmd_page(pmd_t *pmdp, unsigned long addr, struct cpa cpa)
 +static pte_t *walk_page_table(unsigned long addr)
  {
 -	pmd_t new;
 -
 -	if (cpa.set_ro)
 -		new = pmd_wrprotect(*pmdp);
 -	else if (cpa.clear_ro)
 -		new = pmd_mkwrite(pmd_mkdirty(*pmdp));
 -	pgt_set((unsigned long *)pmdp, pmd_val(new), addr, CRDTE_DTT_SEGMENT);
 -}
 -
 -static int walk_pmd_level(pud_t *pudp, unsigned long addr, unsigned long end,
 -			  struct cpa cpa)
 -{
 -	unsigned long next;
 -	pmd_t *pmdp;
 -	int rc = 0;
 -
 -	pmdp = pmd_offset(pudp, addr);
 -	do {
 -		if (pmd_none(*pmdp))
 -			return -EINVAL;
 -		next = pmd_addr_end(addr, end);
 -		if (pmd_large(*pmdp)) {
 -			if (addr & ~PMD_MASK || addr + PMD_SIZE > next) {
 -				rc = split_pmd_page(pmdp, addr);
 -				if (rc)
 -					return rc;
 -				continue;
 -			}
 -			modify_pmd_page(pmdp, addr, cpa);
 -		} else {
 -			rc = walk_pte_level(pmdp, addr, next, cpa);
 -			if (rc)
 -				return rc;
 -		}
 -		pmdp++;
 -		addr = next;
 -		cond_resched();
 -	} while (addr < end);
 -	return rc;
 -}
 -
 -static int split_pud_page(pud_t *pudp, unsigned long addr)
 -{
 -	unsigned long pmd_addr, prot;
 -	pmd_t *pm_dir, *pmdp;
 -	pud_t new;
 -	int i, ro;
 -
 -	pm_dir = vmem_pmd_alloc();
 -	if (!pm_dir)
 -		return -ENOMEM;
 -	pmd_addr = pud_pfn(*pudp) << PAGE_SHIFT;
 -	ro = !!(pud_val(*pudp) & _REGION_ENTRY_PROTECT);
 -	prot = pgprot_val(ro ? SEGMENT_KERNEL_RO : SEGMENT_KERNEL);
 -	pmdp = pm_dir;
 -	for (i = 0; i < PTRS_PER_PMD; i++) {
 -		pmd_val(*pmdp) = pmd_addr | prot;
 -		pmd_addr += PMD_SIZE;
 -		pmdp++;
 -	}
 -	pud_val(new) = __pa(pm_dir) | _REGION3_ENTRY;
 -	pgt_set((unsigned long *)pudp, pud_val(new), addr, CRDTE_DTT_REGION3);
 -	update_page_count(PG_DIRECT_MAP_1M, PTRS_PER_PMD);
 -	update_page_count(PG_DIRECT_MAP_2G, -1);
 -	return 0;
 -}
 -
 -static void modify_pud_page(pud_t *pudp, unsigned long addr, struct cpa cpa)
 -{
 -	pud_t new;
 -
 -	if (cpa.set_ro)
 -		new = pud_wrprotect(*pudp);
 -	else if (cpa.clear_ro)
 -		new = pud_mkwrite(pud_mkdirty(*pudp));
 -	pgt_set((unsigned long *)pudp, pud_val(new), addr, CRDTE_DTT_REGION3);
 -}
 -
 -static int walk_pud_level(pgd_t *pgd, unsigned long addr, unsigned long end,
 -			  struct cpa cpa)
 -{
 -	unsigned long next;
 -	pud_t *pudp;
 -	int rc = 0;
 -
 -	pudp = pud_offset(pgd, addr);
 -	do {
 -		if (pud_none(*pudp))
 -			return -EINVAL;
 -		next = pud_addr_end(addr, end);
 -		if (pud_large(*pudp)) {
 -			if (addr & ~PUD_MASK || addr + PUD_SIZE > next) {
 -				rc = split_pud_page(pudp, addr);
 -				if (rc)
 -					break;
 -				continue;
 -			}
 -			modify_pud_page(pudp, addr, cpa);
 -		} else {
 -			rc = walk_pmd_level(pudp, addr, next, cpa);
 -		}
 -		pudp++;
 -		addr = next;
 -		cond_resched();
 -	} while (addr < end && !rc);
 -	return rc;
 -}
 -
 -static DEFINE_MUTEX(cpa_mutex);
 -
 -static int change_page_attr(unsigned long addr, unsigned long end,
 -			    struct cpa cpa)
 -{
 -	unsigned long next;
 -	int rc = -EINVAL;
  	pgd_t *pgdp;
 +	pud_t *pudp;
 +	pmd_t *pmdp;
 +	pte_t *ptep;
  
++<<<<<<< HEAD
++=======
+ 	if (addr == end)
+ 		return 0;
+ 	if (end >= MODULES_END)
+ 		return -EINVAL;
+ 	mutex_lock(&cpa_mutex);
++>>>>>>> 4d81aaa53c2d (s390/pageattr: handle numpages parameter correctly)
  	pgdp = pgd_offset_k(addr);
 -	do {
 -		if (pgd_none(*pgdp))
 -			break;
 -		next = pgd_addr_end(addr, end);
 -		rc = walk_pud_level(pgdp, addr, next, cpa);
 -		if (rc)
 +	if (pgd_none(*pgdp))
 +		return NULL;
 +	pudp = pud_offset(pgdp, addr);
 +	if (pud_none(*pudp) || pud_large(*pudp))
 +		return NULL;
 +	pmdp = pmd_offset(pudp, addr);
 +	if (pmd_none(*pmdp) || pmd_large(*pmdp))
 +		return NULL;
 +	ptep = pte_offset_kernel(pmdp, addr);
 +	if (pte_none(*ptep))
 +		return NULL;
 +	return ptep;
 +}
 +
 +static void change_page_attr(unsigned long addr, int numpages,
 +			     pte_t (*set) (pte_t))
 +{
 +	pte_t *ptep;
 +	int i;
 +
 +	for (i = 0; i < numpages; i++) {
 +		ptep = walk_page_table(addr);
 +		if (WARN_ON_ONCE(!ptep))
  			break;
 -		cond_resched();
 -	} while (pgdp++, addr = next, addr < end && !rc);
 -	mutex_unlock(&cpa_mutex);
 -	return rc;
 +		*ptep = set(*ptep);
 +		addr += PAGE_SIZE;
 +	}
 +	__tlb_flush_kernel();
  }
  
  int set_memory_ro(unsigned long addr, int numpages)
* Unmerged path arch/s390/mm/pageattr.c
