nfp: reorder SR-IOV config and nfp_app SR-IOV callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit e3f28473b8ed348f7c052fa1bf79edfde5efba48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e3f28473.failed

We previously assumed that app callback can be guaranteed to be
executed before SR-IOV is actually enabled.  Given that we can't
guarantee that SR-IOV will be disabled during probe or that we
will be able to disable it on remove, we should reorder the callbacks.
We should also call the app's sriov_enable if SR-IOV was enabled
during probe.

Application FW must be able to disable VFs internally and not depend
on them being removed at PCIe level.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3f28473b8ed348f7c052fa1bf79edfde5efba48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_main.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_main.c
index 11612af996f5,a0f3df8572d6..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.c
@@@ -97,20 -101,38 +97,47 @@@ static int nfp_pcie_sriov_enable(struc
  	if (num_vfs > pf->limit_vfs) {
  		nfp_info(pf->cpp, "Firmware limits number of VFs to %u\n",
  			 pf->limit_vfs);
++<<<<<<< HEAD
 +		return -EINVAL;
++=======
+ 		err = -EINVAL;
+ 		goto err_unlock;
  	}
  
  	err = pci_enable_sriov(pdev, num_vfs);
  	if (err) {
+ 		dev_warn(&pdev->dev, "Failed to enable PCI SR-IOV: %d\n", err);
+ 		goto err_unlock;
++>>>>>>> e3f28473b8ed (nfp: reorder SR-IOV config and nfp_app SR-IOV callbacks)
+ 	}
+ 
+ 	err = nfp_app_sriov_enable(pf->app, num_vfs);
+ 	if (err) {
++<<<<<<< HEAD
 +		dev_warn(&pdev->dev, "Failed to enable PCI sriov: %d\n", err);
 +		return err;
++=======
+ 		dev_warn(&pdev->dev,
+ 			 "App specific PCI SR-IOV configuration failed: %d\n",
+ 			 err);
+ 		goto err_sriov_disable;
++>>>>>>> e3f28473b8ed (nfp: reorder SR-IOV config and nfp_app SR-IOV callbacks)
  	}
  
  	pf->num_vfs = num_vfs;
  
  	dev_dbg(&pdev->dev, "Created %d VFs.\n", pf->num_vfs);
  
 -	mutex_unlock(&pf->lock);
  	return num_vfs;
++<<<<<<< HEAD
++=======
+ 
+ err_sriov_disable:
+ 	pci_disable_sriov(pdev);
+ err_unlock:
+ 	mutex_unlock(&pf->lock);
+ 	return err;
++>>>>>>> e3f28473b8ed (nfp: reorder SR-IOV config and nfp_app SR-IOV callbacks)
  #endif
  	return 0;
  }
@@@ -404,12 -459,21 +436,21 @@@ err_pci_disable
  static void nfp_pci_remove(struct pci_dev *pdev)
  {
  	struct nfp_pf *pf = pci_get_drvdata(pdev);
 -	struct devlink *devlink;
  
 -	nfp_hwmon_unregister(pf);
 -
 -	devlink = priv_to_devlink(pf);
 +	nfp_net_pci_remove(pf);
  
+ 	nfp_net_pci_remove(pf);
+ 
  	nfp_pcie_sriov_disable(pdev);
  	pci_sriov_set_totalvfs(pf->pdev, 0);
  
++<<<<<<< HEAD
++=======
+ 	devlink_unregister(devlink);
+ 
+ 	kfree(pf->rtbl);
+ 	nfp_mip_close(pf->mip);
++>>>>>>> e3f28473b8ed (nfp: reorder SR-IOV config and nfp_app SR-IOV callbacks)
  	if (pf->fw_loaded)
  		nfp_fw_unload(pf);
  
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 092c7d18f2ec,4d22e1cc013e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@@ -435,15 -385,199 +435,180 @@@ nfp_net_pf_spawn_netdevs(struct nfp_pf 
  	return 0;
  
  err_prev_deinit:
 -	list_for_each_entry_continue_reverse(nn, &pf->vnics, vnic_list)
 -		if (nfp_net_is_data_vnic(nn))
 -			nfp_net_pf_clean_vnic(pf, nn);
 -	return err;
 -}
 -
 -static int
 -nfp_net_pf_app_init(struct nfp_pf *pf, u8 __iomem *qc_bar, unsigned int stride)
 -{
 -	u8 __iomem *ctrl_bar;
 -	int err;
 -
 -	pf->app = nfp_app_alloc(pf, nfp_net_pf_get_app_id(pf));
 -	if (IS_ERR(pf->app))
 -		return PTR_ERR(pf->app);
 -
 -	err = nfp_app_init(pf->app);
 -	if (err)
 -		goto err_free;
 -
 -	if (!nfp_app_needs_ctrl_vnic(pf->app))
 -		return 0;
 -
 -	ctrl_bar = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%u_net_ctrl_bar",
 -					NFP_PF_CSR_SLICE_SIZE,
 -					&pf->ctrl_vnic_bar);
 -	if (IS_ERR(ctrl_bar)) {
 -		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
 -		err = PTR_ERR(ctrl_bar);
 -		goto err_app_clean;
 +	list_for_each_entry_continue_reverse(nn, &pf->ports, port_list) {
 +		nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
 +		nfp_net_netdev_clean(nn->netdev);
  	}
++<<<<<<< HEAD
 +	nfp_net_irqs_disable(pf->pdev);
 +err_vec_free:
 +	kfree(pf->irq_entries);
 +err_nn_free:
 +	nfp_net_pf_free_netdevs(pf);
++=======
+ 
+ 	pf->ctrl_vnic =	nfp_net_pf_alloc_vnic(pf, false, ctrl_bar, qc_bar,
+ 					      stride, 0);
+ 	if (IS_ERR(pf->ctrl_vnic)) {
+ 		err = PTR_ERR(pf->ctrl_vnic);
+ 		goto err_unmap;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap:
+ 	nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ err_app_clean:
+ 	nfp_app_clean(pf->app);
+ err_free:
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_clean(struct nfp_pf *pf)
+ {
+ 	if (pf->ctrl_vnic) {
+ 		nfp_net_pf_free_vnic(pf, pf->ctrl_vnic);
+ 		nfp_cpp_area_release_free(pf->ctrl_vnic_bar);
+ 	}
+ 	nfp_app_clean(pf->app);
+ 	nfp_app_free(pf->app);
+ 	pf->app = NULL;
+ }
+ 
+ static int nfp_net_pf_app_start_ctrl(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	if (!pf->ctrl_vnic)
+ 		return 0;
+ 	err = nfp_net_pf_init_vnic(pf, pf->ctrl_vnic, 0);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_ctrl_open(pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_clean_ctrl;
+ 
+ 	return 0;
+ 
+ err_clean_ctrl:
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop_ctrl(struct nfp_pf *pf)
+ {
+ 	if (!pf->ctrl_vnic)
+ 		return;
+ 	nfp_ctrl_close(pf->ctrl_vnic);
+ 	nfp_net_pf_clean_vnic(pf, pf->ctrl_vnic);
+ }
+ 
+ static int nfp_net_pf_app_start(struct nfp_pf *pf)
+ {
+ 	int err;
+ 
+ 	err = nfp_net_pf_app_start_ctrl(pf);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_app_start(pf->app, pf->ctrl_vnic);
+ 	if (err)
+ 		goto err_ctrl_stop;
+ 
+ 	if (pf->num_vfs) {
+ 		err = nfp_app_sriov_enable(pf->app, pf->num_vfs);
+ 		if (err)
+ 			goto err_app_stop;
+ 	}
+ 
+ 	return 0;
+ 
+ err_app_stop:
+ 	nfp_app_stop(pf->app);
+ err_ctrl_stop:
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ 	return err;
+ }
+ 
+ static void nfp_net_pf_app_stop(struct nfp_pf *pf)
+ {
+ 	if (pf->num_vfs)
+ 		nfp_app_sriov_disable(pf->app);
+ 	nfp_app_stop(pf->app);
+ 	nfp_net_pf_app_stop_ctrl(pf);
+ }
+ 
+ static void nfp_net_pci_unmap_mem(struct nfp_pf *pf)
+ {
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ 	nfp_cpp_area_release_free(pf->qc_area);
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
+ }
+ 
+ static int nfp_net_pci_map_mem(struct nfp_pf *pf)
+ {
+ 	u8 __iomem *mem;
+ 	u32 min_size;
+ 	int err;
+ 
+ 	min_size = pf->max_data_vnics * NFP_PF_CSR_SLICE_SIZE;
+ 	mem = nfp_net_pf_map_rtsym(pf, "net.ctrl", "_pf%d_net_bar0",
+ 				   min_size, &pf->data_vnic_bar);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to find data vNIC memory symbol\n");
+ 		return PTR_ERR(mem);
+ 	}
+ 
+ 	min_size =  NFP_MAC_STATS_SIZE * (pf->eth_tbl->max_index + 1);
+ 	pf->mac_stats_mem = nfp_rtsym_map(pf->rtbl, "_mac_stats",
+ 					  "net.macstats", min_size,
+ 					  &pf->mac_stats_bar);
+ 	if (IS_ERR(pf->mac_stats_mem)) {
+ 		if (PTR_ERR(pf->mac_stats_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->mac_stats_mem);
+ 			goto err_unmap_ctrl;
+ 		}
+ 		pf->mac_stats_mem = NULL;
+ 	}
+ 
+ 	pf->vf_cfg_mem = nfp_net_pf_map_rtsym(pf, "net.vfcfg",
+ 					      "_pf%d_net_vf_bar",
+ 					      NFP_NET_CFG_BAR_SZ *
+ 					      pf->limit_vfs, &pf->vf_cfg_bar);
+ 	if (IS_ERR(pf->vf_cfg_mem)) {
+ 		if (PTR_ERR(pf->vf_cfg_mem) != -ENOENT) {
+ 			err = PTR_ERR(pf->vf_cfg_mem);
+ 			goto err_unmap_mac_stats;
+ 		}
+ 		pf->vf_cfg_mem = NULL;
+ 	}
+ 
+ 	mem = nfp_cpp_map_area(pf->cpp, "net.qc", 0, 0,
+ 			       NFP_PCIE_QUEUE(0), NFP_QCP_QUEUE_AREA_SZ,
+ 			       &pf->qc_area);
+ 	if (IS_ERR(mem)) {
+ 		nfp_err(pf->cpp, "Failed to map Queue Controller area.\n");
+ 		err = PTR_ERR(mem);
+ 		goto err_unmap_vf_cfg;
+ 	}
+ 
+ 	return 0;
+ 
+ err_unmap_vf_cfg:
+ 	if (pf->vf_cfg_bar)
+ 		nfp_cpp_area_release_free(pf->vf_cfg_bar);
+ err_unmap_mac_stats:
+ 	if (pf->mac_stats_bar)
+ 		nfp_cpp_area_release_free(pf->mac_stats_bar);
+ err_unmap_ctrl:
+ 	nfp_cpp_area_release_free(pf->data_vnic_bar);
++>>>>>>> e3f28473b8ed (nfp: reorder SR-IOV config and nfp_app SR-IOV callbacks)
  	return err;
  }
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_main.c
