ALSA: x86: Set CA bits for DisplayPort too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 36ed34662f1944ebf553b30fcba1abab1703d125
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/36ed3466.failed

This is a guess work.  Usually the DP audio info frame is just 8-bit
shifted from HDMI AI, so let's try to put CA in DIP frame 2 [24-31].

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 36ed34662f1944ebf553b30fcba1abab1703d125)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,24a18b88c927..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -608,32 -630,31 +609,41 @@@ static void snd_intelhad_prog_dip(struc
  
  	channels = substream->runtime->channels;
  
 -	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);
 +	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.ctrl_val);
  
+ 	ca = snd_intelhad_channel_allocation(intelhaddata, channels);
  	if (intelhaddata->dp_output) {
  		info_frame = DP_INFO_FRAME_WORD1;
++<<<<<<< HEAD
 +		frame2.fr2_val = 1;
 +	} else {
 +		info_frame = HDMI_INFO_FRAME_WORD1;
 +		frame2.fr2_regx.chnl_cnt = substream->runtime->channels - 1;
 +
 +		frame3.fr3_regx.chnl_alloc = snd_intelhad_channel_allocation(
 +			intelhaddata, channels);
++=======
+ 		frame2.regval = (substream->runtime->channels - 1) | (ca << 24);
+ 	} else {
+ 		info_frame = HDMI_INFO_FRAME_WORD1;
+ 		frame2.regx.chnl_cnt = substream->runtime->channels - 1;
+ 		frame3.regx.chnl_alloc = ca;
++>>>>>>> 36ed34662f19 (ALSA: x86: Set CA bits for DisplayPort too)
  
 -		/* Calculte the byte wide checksum for all valid DIP words */
 +		/*Calculte the byte wide checksum for all valid DIP words*/
  		for (i = 0; i < BYTES_PER_WORD; i++)
 -			checksum += (info_frame >> (i * 8)) & 0xff;
 +			checksum += (info_frame >> i*BITS_PER_BYTE) & MASK_BYTE0;
  		for (i = 0; i < BYTES_PER_WORD; i++)
 -			checksum += (frame2.regval >> (i * 8)) & 0xff;
 +			checksum += (frame2.fr2_val >> i*BITS_PER_BYTE) & MASK_BYTE0;
  		for (i = 0; i < BYTES_PER_WORD; i++)
 -			checksum += (frame3.regval >> (i * 8)) & 0xff;
 +			checksum += (frame3.fr3_val >> i*BITS_PER_BYTE) & MASK_BYTE0;
  
 -		frame2.regx.chksum = -(checksum);
 +		frame2.fr2_regx.chksum = -(checksum);
  	}
  
 -	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, info_frame);
 -	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame2.regval);
 -	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame3.regval);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, info_frame);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, frame2.fr2_val);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, frame3.fr3_val);
  
  	/* program remaining DIP words with zero */
  	for (i = 0; i < HAD_MAX_DIP_WORDS-VALID_DIP_WORDS; i++)
* Unmerged path sound/x86/intel_hdmi_audio.c
