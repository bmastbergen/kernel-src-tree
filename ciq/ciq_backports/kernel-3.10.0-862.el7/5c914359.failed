nfp: add missing fall through statements

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 5c9143598ea1a5f7a92761966f0c65a459eef7b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5c914359.failed

GCC 7 checks for fall through comments, add the two missing ones.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5c9143598ea1a5f7a92761966f0c65a459eef7b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 5094c56dbda7,2bcf3e8330ea..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1434,17 -1634,78 +1434,85 @@@ static int nfp_net_rx(struct nfp_net_rx
  		r_vec->rx_bytes += pkt_len;
  		u64_stats_update_end(&r_vec->rx_sync);
  
++<<<<<<< HEAD
 +		skb = build_skb(rxbuf->frag, nn->fl_bufsz);
++=======
+ 		if (unlikely(meta_len > NFP_NET_MAX_PREPEND ||
+ 			     (dp->rx_offset && meta_len > dp->rx_offset))) {
+ 			nn_dp_warn(dp, "oversized RX packet metadata %u\n",
+ 				   meta_len);
+ 			nfp_net_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);
+ 			continue;
+ 		}
+ 
+ 		nfp_net_dma_sync_cpu_rx(dp, rxbuf->dma_addr + meta_off,
+ 					data_len);
+ 
+ 		if (!dp->chained_metadata_format) {
+ 			nfp_net_set_hash_desc(dp->netdev, &meta,
+ 					      rxbuf->frag + meta_off, rxd);
+ 		} else if (meta_len) {
+ 			void *end;
+ 
+ 			end = nfp_net_parse_meta(dp->netdev, &meta,
+ 						 rxbuf->frag + meta_off,
+ 						 meta_len);
+ 			if (unlikely(end != rxbuf->frag + pkt_off)) {
+ 				nn_dp_warn(dp, "invalid RX packet metadata\n");
+ 				nfp_net_rx_drop(dp, r_vec, rx_ring, rxbuf,
+ 						NULL);
+ 				continue;
+ 			}
+ 		}
+ 
+ 		if (xdp_prog && !(rxd->rxd.flags & PCIE_DESC_RX_BPF &&
+ 				  dp->bpf_offload_xdp)) {
+ 			unsigned int dma_off;
+ 			void *hard_start;
+ 			int act;
+ 
+ 			hard_start = rxbuf->frag + NFP_NET_RX_BUF_HEADROOM;
+ 
+ 			act = nfp_net_run_xdp(xdp_prog, rxbuf->frag, hard_start,
+ 					      &pkt_off, &pkt_len);
+ 			switch (act) {
+ 			case XDP_PASS:
+ 				break;
+ 			case XDP_TX:
+ 				dma_off = pkt_off - NFP_NET_RX_BUF_HEADROOM;
+ 				if (unlikely(!nfp_net_tx_xdp_buf(dp, rx_ring,
+ 								 tx_ring, rxbuf,
+ 								 dma_off,
+ 								 pkt_len,
+ 								 &xdp_tx_cmpl)))
+ 					trace_xdp_exception(dp->netdev,
+ 							    xdp_prog, act);
+ 				continue;
+ 			default:
+ 				bpf_warn_invalid_xdp_action(act);
+ 				/* fall through */
+ 			case XDP_ABORTED:
+ 				trace_xdp_exception(dp->netdev, xdp_prog, act);
+ 				/* fall through */
+ 			case XDP_DROP:
+ 				nfp_net_rx_give_one(dp, rx_ring, rxbuf->frag,
+ 						    rxbuf->dma_addr);
+ 				continue;
+ 			}
+ 		}
+ 
+ 		skb = build_skb(rxbuf->frag, true_bufsz);
++>>>>>>> 5c9143598ea1 (nfp: add missing fall through statements)
  		if (unlikely(!skb)) {
 -			nfp_net_rx_drop(dp, r_vec, rx_ring, rxbuf, NULL);
 +			nfp_net_rx_drop(r_vec, rx_ring, rxbuf, NULL);
  			continue;
  		}
 -		new_frag = nfp_net_napi_alloc_one(dp, &new_dma_addr);
 +
 +		nfp_net_set_hash(nn->netdev, skb, rxd);
 +
 +		new_frag = nfp_net_napi_alloc_one(nn, &new_dma_addr);
  		if (unlikely(!new_frag)) {
 -			nfp_net_rx_drop(dp, r_vec, rx_ring, rxbuf, skb);
 +			nfp_net_rx_drop(r_vec, rx_ring, rxbuf, skb);
  			continue;
  		}
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
