x86/cpuid: Fix up "virtual" IBRS/IBPB/STIBP feature bits on Intel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] cpuid: Fix up "virtual" IBRS/IBPB/STIBP feature bits on Intel (Paolo Bonzini) [1537379]
Rebuild_FUZZ: 96.83%
commit-author David Woodhouse <dwmw@amazon.co.uk>
commit 7fcae1118f5fd44a862aa5c3525248e35ee67c3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7fcae111.failed

Despite the fact that all the other code there seems to be doing it, just
using set_cpu_cap() in early_intel_init() doesn't actually work.

For CPUs with PKU support, setup_pku() calls get_cpu_cap() after
c->c_init() has set those feature bits. That resets those bits back to what
was queried from the hardware.

Turning the bits off for bad microcode is easy to fix. That can just use
setup_clear_cpu_cap() to force them off for all CPUs.

I was less keen on forcing the feature bits *on* that way, just in case
of inconsistencies. I appreciate that the kernel is going to get this
utterly wrong if CPU features are not consistent, because it has already
applied alternatives by the time secondary CPUs are brought up.

But at least if setup_force_cpu_cap() isn't being used, we might have a
chance of *detecting* the lack of the corresponding bit and either
panicking or refusing to bring the offending CPU online.

So ensure that the appropriate feature bits are set within get_cpu_cap()
regardless of how many extra times it's called.

Fixes: 2961298e ("x86/cpufeatures: Clean up Spectre v2 related CPUID flags")
	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: karahmed@amazon.de
	Cc: peterz@infradead.org
	Cc: bp@alien8.de
Link: https://lkml.kernel.org/r/1517322623-15261-1-git-send-email-dwmw@amazon.co.uk

(cherry picked from commit 7fcae1118f5fd44a862aa5c3525248e35ee67c3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
#	arch/x86/kernel/cpu/intel.c
diff --cc arch/x86/kernel/cpu/common.c
index 3eec1147ce1e,dd09270bb74e..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -661,6 -740,36 +661,39 @@@ void cpu_detect(struct cpuinfo_x86 *c
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void apply_forced_caps(struct cpuinfo_x86 *c)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NCAPINTS + NBUGINTS; i++) {
+ 		c->x86_capability[i] &= ~cpu_caps_cleared[i];
+ 		c->x86_capability[i] |= cpu_caps_set[i];
+ 	}
+ }
+ 
+ static void init_speculation_control(struct cpuinfo_x86 *c)
+ {
+ 	/*
+ 	 * The Intel SPEC_CTRL CPUID bit implies IBRS and IBPB support,
+ 	 * and they also have a different bit for STIBP support. Also,
+ 	 * a hypervisor might have set the individual AMD bits even on
+ 	 * Intel CPUs, for finer-grained selection of what's available.
+ 	 *
+ 	 * We use the AMD bits in 0x8000_0008 EBX as the generic hardware
+ 	 * features, which are visible in /proc/cpuinfo and used by the
+ 	 * kernel. So set those accordingly from the Intel bits.
+ 	 */
+ 	if (cpu_has(c, X86_FEATURE_SPEC_CTRL)) {
+ 		set_cpu_cap(c, X86_FEATURE_IBRS);
+ 		set_cpu_cap(c, X86_FEATURE_IBPB);
+ 	}
+ 	if (cpu_has(c, X86_FEATURE_INTEL_STIBP))
+ 		set_cpu_cap(c, X86_FEATURE_STIBP);
+ }
+ 
++>>>>>>> 7fcae1118f5f (x86/cpuid: Fix up "virtual" IBRS/IBPB/STIBP feature bits on Intel)
  void get_cpu_cap(struct cpuinfo_x86 *c)
  {
  	u32 eax, ebx, ecx, edx;
@@@ -752,9 -861,17 +785,20 @@@
  #endif
  
  	if (c->extended_cpuid_level >= 0x8000000a)
 -		c->x86_capability[CPUID_8000_000A_EDX] = cpuid_edx(0x8000000a);
 +		c->x86_capability[15] = cpuid_edx(0x8000000a);
  
  	init_scattered_cpuid_features(c);
++<<<<<<< HEAD
++=======
+ 	init_speculation_control(c);
+ 
+ 	/*
+ 	 * Clear/Set all flags overridden by options, after probe.
+ 	 * This needs to happen each time we re-probe, which may happen
+ 	 * several times during CPU initialization.
+ 	 */
+ 	apply_forced_caps(c);
++>>>>>>> 7fcae1118f5f (x86/cpuid: Fix up "virtual" IBRS/IBPB/STIBP feature bits on Intel)
  }
  
  static void identify_cpu_without_cpuid(struct cpuinfo_x86 *c)
diff --cc arch/x86/kernel/cpu/intel.c
index 74476001995a,319bf989fad1..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -123,13 -172,20 +123,27 @@@ static void early_init_intel(struct cpu
  		(c->x86 == 0x6 && c->x86_model >= 0x0e))
  		set_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);
  
 -	if (c->x86 >= 6 && !cpu_has(c, X86_FEATURE_IA64))
 -		c->microcode = intel_get_microcode_revision();
 +	if (c->x86 >= 6 && !cpu_has(c, X86_FEATURE_IA64)) {
 +		unsigned lower_word;
  
++<<<<<<< HEAD
 +		wrmsr(MSR_IA32_UCODE_REV, 0, 0);
 +		/* Required by the SDM */
 +		sync_core();
 +		rdmsr(MSR_IA32_UCODE_REV, lower_word, c->microcode);
++=======
+ 	/* Now if any of them are set, check the blacklist and clear the lot */
+ 	if ((cpu_has(c, X86_FEATURE_SPEC_CTRL) ||
+ 	     cpu_has(c, X86_FEATURE_INTEL_STIBP) ||
+ 	     cpu_has(c, X86_FEATURE_IBRS) || cpu_has(c, X86_FEATURE_IBPB) ||
+ 	     cpu_has(c, X86_FEATURE_STIBP)) && bad_spectre_microcode(c)) {
+ 		pr_warn("Intel Spectre v2 broken microcode detected; disabling Speculation Control\n");
+ 		setup_clear_cpu_cap(X86_FEATURE_IBRS);
+ 		setup_clear_cpu_cap(X86_FEATURE_IBPB);
+ 		setup_clear_cpu_cap(X86_FEATURE_STIBP);
+ 		setup_clear_cpu_cap(X86_FEATURE_SPEC_CTRL);
+ 		setup_clear_cpu_cap(X86_FEATURE_INTEL_STIBP);
++>>>>>>> 7fcae1118f5f (x86/cpuid: Fix up "virtual" IBRS/IBPB/STIBP feature bits on Intel)
  	}
  
  	/*
* Unmerged path arch/x86/kernel/cpu/common.c
* Unmerged path arch/x86/kernel/cpu/intel.c
