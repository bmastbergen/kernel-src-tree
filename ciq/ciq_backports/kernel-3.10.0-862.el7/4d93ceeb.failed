mlxsw: spectrum_router: Extend the RIF struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 4d93ceebf09b0e85adc8048752eea39785b300bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4d93ceeb.failed

Currently, when a Subport RIF is configured, the LAG status and VLAN of
the underlying port are read from the port itself. This is problematic,
as we would like to have common code to configure all types of RIFs,
which aren't necessarily bound to a port.

Instead, embed the RIF in a struct specific to the Subport type, which
contains all the necessary information.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4d93ceebf09b0e85adc8048752eea39785b300bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index f8e7036e3f4a,28ba5d323a37..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -58,10 -89,172 +58,171 @@@ struct mlxsw_sp_rif 
  	struct mlxsw_sp_fid *f;
  	unsigned char addr[ETH_ALEN];
  	int mtu;
 -	u16 rif_index;
 +	u16 rif;
  	u16 vr_id;
 -	unsigned int counter_ingress;
 -	bool counter_ingress_valid;
 -	unsigned int counter_egress;
 -	bool counter_egress_valid;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_rif_subport {
+ 	struct mlxsw_sp_rif common;
+ 	union {
+ 		u16 system_port;
+ 		u16 lag_id;
+ 	};
+ 	u16 vid;
+ 	bool lag;
+ };
+ 
+ static unsigned int *
+ mlxsw_sp_rif_p_counter_get(struct mlxsw_sp_rif *rif,
+ 			   enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return &rif->counter_egress;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return &rif->counter_ingress;
+ 	}
+ 	return NULL;
+ }
+ 
+ static bool
+ mlxsw_sp_rif_counter_valid_get(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		return rif->counter_egress_valid;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		return rif->counter_ingress_valid;
+ 	}
+ 	return false;
+ }
+ 
+ static void
+ mlxsw_sp_rif_counter_valid_set(struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir,
+ 			       bool valid)
+ {
+ 	switch (dir) {
+ 	case MLXSW_SP_RIF_COUNTER_EGRESS:
+ 		rif->counter_egress_valid = valid;
+ 		break;
+ 	case MLXSW_SP_RIF_COUNTER_INGRESS:
+ 		rif->counter_ingress_valid = valid;
+ 		break;
+ 	}
+ }
+ 
+ static int mlxsw_sp_rif_counter_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,
+ 				     unsigned int counter_index, bool enable,
+ 				     enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	char ritr_pl[MLXSW_REG_RITR_LEN];
+ 	bool is_egress = false;
+ 	int err;
+ 
+ 	if (dir == MLXSW_SP_RIF_COUNTER_EGRESS)
+ 		is_egress = true;
+ 	mlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	mlxsw_reg_ritr_counter_pack(ritr_pl, counter_index, enable,
+ 				    is_egress);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_rif *rif,
+ 				   enum mlxsw_sp_rif_counter_dir dir, u64 *cnt)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 	unsigned int *p_counter_index;
+ 	bool valid;
+ 	int err;
+ 
+ 	valid = mlxsw_sp_rif_counter_valid_get(rif, dir);
+ 	if (!valid)
+ 		return -EINVAL;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, *p_counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_NOP);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ 	if (err)
+ 		return err;
+ 	*cnt = mlxsw_reg_ricnt_good_unicast_packets_get(ricnt_pl);
+ 	return 0;
+ }
+ 
+ static int mlxsw_sp_rif_counter_clear(struct mlxsw_sp *mlxsw_sp,
+ 				      unsigned int counter_index)
+ {
+ 	char ricnt_pl[MLXSW_REG_RICNT_LEN];
+ 
+ 	mlxsw_reg_ricnt_pack(ricnt_pl, counter_index,
+ 			     MLXSW_REG_RICNT_OPCODE_CLEAR);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);
+ }
+ 
+ int mlxsw_sp_rif_counter_alloc(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 	int err;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (!p_counter_index)
+ 		return -EINVAL;
+ 	err = mlxsw_sp_counter_alloc(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 				     p_counter_index);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlxsw_sp_rif_counter_clear(mlxsw_sp, *p_counter_index);
+ 	if (err)
+ 		goto err_counter_clear;
+ 
+ 	err = mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 					*p_counter_index, true, dir);
+ 	if (err)
+ 		goto err_counter_edit;
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, true);
+ 	return 0;
+ 
+ err_counter_edit:
+ err_counter_clear:
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_rif_counter_free(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_rif *rif,
+ 			       enum mlxsw_sp_rif_counter_dir dir)
+ {
+ 	unsigned int *p_counter_index;
+ 
+ 	if (!mlxsw_sp_rif_counter_valid_get(rif, dir))
+ 		return;
+ 
+ 	p_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);
+ 	if (WARN_ON(!p_counter_index))
+ 		return;
+ 	mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,
+ 				  *p_counter_index, false, dir);
+ 	mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,
+ 			      *p_counter_index);
+ 	mlxsw_sp_rif_counter_valid_set(rif, dir, false);
+ }
+ 
++>>>>>>> 4d93ceebf09b (mlxsw: spectrum_router: Extend the RIF struct)
  static struct mlxsw_sp_rif *
  mlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,
  			 const struct net_device *dev);
@@@ -2747,52 -2974,95 +2908,98 @@@ mlxsw_sp_rfid_alloc(u16 fid, struct net
  }
  
  static struct mlxsw_sp_rif *
++<<<<<<< HEAD
 +mlxsw_sp_rif_alloc(u16 rif, u16 vr_id, struct net_device *l3_dev,
 +		   struct mlxsw_sp_fid *f)
 +{
 +	struct mlxsw_sp_rif *r;
 +
 +	r = kzalloc(sizeof(*r), GFP_KERNEL);
 +	if (!r)
++=======
+ mlxsw_sp_rif_alloc(u16 rif_index, u16 vr_id, struct net_device *l3_dev,
+ 		   struct mlxsw_sp_fid *f, bool is_subport)
+ {
+ 	size_t size = is_subport ? sizeof(struct mlxsw_sp_rif_subport) :
+ 				   sizeof(struct mlxsw_sp_rif);
+ 	struct mlxsw_sp_rif *rif;
+ 
+ 	rif = kzalloc(size, GFP_KERNEL);
+ 	if (!rif)
++>>>>>>> 4d93ceebf09b (mlxsw: spectrum_router: Extend the RIF struct)
  		return NULL;
  
 -	INIT_LIST_HEAD(&rif->nexthop_list);
 -	INIT_LIST_HEAD(&rif->neigh_list);
 -	ether_addr_copy(rif->addr, l3_dev->dev_addr);
 -	rif->mtu = l3_dev->mtu;
 -	rif->vr_id = vr_id;
 -	rif->dev = l3_dev;
 -	rif->rif_index = rif_index;
 -	rif->f = f;
 -
 -	return rif;
 -}
 -
 -struct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,
 -					   u16 rif_index)
 -{
 -	return mlxsw_sp->router->rifs[rif_index];
 -}
 -
 -u16 mlxsw_sp_rif_index(const struct mlxsw_sp_rif *rif)
 -{
 -	return rif->rif_index;
 -}
 +	INIT_LIST_HEAD(&r->nexthop_list);
 +	INIT_LIST_HEAD(&r->neigh_list);
 +	ether_addr_copy(r->addr, l3_dev->dev_addr);
 +	r->mtu = l3_dev->mtu;
 +	r->vr_id = vr_id;
 +	r->dev = l3_dev;
 +	r->rif = rif;
 +	r->f = f;
  
 -int mlxsw_sp_rif_dev_ifindex(const struct mlxsw_sp_rif *rif)
 -{
 -	return rif->dev->ifindex;
 +	return r;
  }
  
  static struct mlxsw_sp_rif *
 -mlxsw_sp_port_vlan_rif_sp_create(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,
 -				 struct net_device *l3_dev)
 +mlxsw_sp_vport_rif_sp_create(struct mlxsw_sp_port *mlxsw_sp_vport,
 +			     struct net_device *l3_dev)
  {
++<<<<<<< HEAD
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
++=======
+ 	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
+ 	struct mlxsw_sp_rif_subport *rif_subport;
+ 	u32 tb_id = l3mdev_fib_table(l3_dev);
++>>>>>>> 4d93ceebf09b (mlxsw: spectrum_router: Extend the RIF struct)
  	struct mlxsw_sp_vr *vr;
  	struct mlxsw_sp_fid *f;
 -	struct mlxsw_sp_rif *rif;
 -	u16 fid, rif_index;
 +	struct mlxsw_sp_rif *r;
 +	u16 fid, rif;
  	int err;
  
 -	rif_index = mlxsw_sp_avail_rif_get(mlxsw_sp);
 -	if (rif_index == MLXSW_SP_INVALID_INDEX_RIF)
 +	rif = mlxsw_sp_avail_rif_get(mlxsw_sp);
 +	if (rif == MLXSW_SP_INVALID_RIF)
  		return ERR_PTR(-ERANGE);
  
 -	fid = mlxsw_sp_rif_sp_to_fid(rif_index);
 -	f = mlxsw_sp_rfid_alloc(fid, l3_dev);
 -	if (!f)
 -		return ERR_PTR(-ENOMEM);
 +	vr = mlxsw_sp_vr_get(mlxsw_sp, RT_TABLE_MAIN);
 +	if (IS_ERR(vr))
 +		return ERR_CAST(vr);
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif,
 +				       true);
++=======
+ 	vr = mlxsw_sp_vr_get(mlxsw_sp, tb_id ? : RT_TABLE_MAIN);
+ 	if (IS_ERR(vr)) {
+ 		err = PTR_ERR(vr);
+ 		goto err_vr_get;
+ 	}
+ 
+ 	rif = mlxsw_sp_rif_alloc(rif_index, vr->id, l3_dev, f, true);
+ 	if (!rif) {
+ 		err = -ENOMEM;
+ 		goto err_rif_alloc;
+ 	}
+ 
+ 	rif_subport = container_of(rif, struct mlxsw_sp_rif_subport, common);
+ 	rif_subport->vid = mlxsw_sp_port_vlan->vid;
+ 	if (mlxsw_sp_port->lagged) {
+ 		rif_subport->lag = true;
+ 		rif_subport->lag_id = mlxsw_sp_port->lag_id;
+ 	} else {
+ 		rif_subport->lag = false;
+ 		rif_subport->system_port = mlxsw_sp_port->local_port;
+ 	}
+ 
+ 	err = mlxsw_sp_port_vlan_rif_sp_op(mlxsw_sp_port_vlan, vr->id, l3_dev,
+ 					   rif_index, true);
++>>>>>>> 4d93ceebf09b (mlxsw: spectrum_router: Extend the RIF struct)
  	if (err)
 -		goto err_port_vlan_rif_sp_op;
 +		goto err_vport_rif_sp_op;
  
 +	fid = mlxsw_sp_rif_sp_to_fid(rif);
  	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, true);
  	if (err)
  		goto err_rif_fdb_op;
@@@ -3046,8 -3364,14 +3253,19 @@@ static int mlxsw_sp_rif_bridge_create(s
  	if (err)
  		goto err_port_flood_set;
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_rif_bridge_op(mlxsw_sp, vr->id, l3_dev, f->fid, rif,
 +				     true);
++=======
+ 	rif = mlxsw_sp_rif_alloc(rif_index, vr->id, l3_dev, f, false);
+ 	if (!rif) {
+ 		err = -ENOMEM;
+ 		goto err_rif_alloc;
+ 	}
+ 
+ 	err = mlxsw_sp_rif_bridge_op(mlxsw_sp, vr->id, l3_dev, f->fid,
+ 				     rif_index, true);
++>>>>>>> 4d93ceebf09b (mlxsw: spectrum_router: Extend the RIF struct)
  	if (err)
  		goto err_rif_bridge_op;
  
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
