x86/hyperv: Move TSC reading method to asm/mshyperv.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 0733379b512ce36ba0b10942f9597b74f579f063
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0733379b.failed

As a preparation to making Hyper-V TSC page suitable for vDSO move
the TSC page reading logic to asm/mshyperv.h. While on it, do the
following:

- Document the reading algorithm.
- Simplify the code a bit.
- Add explicit READ_ONCE() to not rely on 'volatile'.
- Add explicit barriers to prevent re-ordering (we need to read sequence
  strictly before and after)
- Use mul_u64_u64_shr() instead of assembly, gcc generates a single 'mul'
  instruction on x86_64 anyway.

[ tglx: Simplified the loop ]

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Dexuan Cui <decui@microsoft.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: devel@linuxdriverproject.org
	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
	Cc: virtualization@lists.linux-foundation.org
Link: http://lkml.kernel.org/r/20170303132142.25595-3-vkuznets@redhat.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 0733379b512ce36ba0b10942f9597b74f579f063)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,7f5152356a59..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -24,8 -24,61 +24,61 @@@
  #include <linux/version.h>
  #include <linux/vmalloc.h>
  #include <linux/mm.h>
++<<<<<<< HEAD
++=======
+ #include <linux/clockchips.h>
+ 
+ 
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ 
+ static struct ms_hyperv_tsc_page *tsc_pg;
+ 
+ struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
+ {
+ 	return tsc_pg;
+ }
+ 
+ static u64 read_hv_clock_tsc(struct clocksource *arg)
+ {
+ 	u64 current_tick = hv_read_tsc_page(tsc_pg);
+ 
+ 	if (current_tick == U64_MAX)
+ 		rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+ 
+ 	return current_tick;
+ }
+ 
+ static struct clocksource hyperv_cs_tsc = {
+ 		.name		= "hyperv_clocksource_tsc_page",
+ 		.rating		= 400,
+ 		.read		= read_hv_clock_tsc,
+ 		.mask		= CLOCKSOURCE_MASK(64),
+ 		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+ };
+ #endif
+ 
+ static u64 read_hv_clock_msr(struct clocksource *arg)
+ {
+ 	u64 current_tick;
+ 	/*
+ 	 * Read the partition counter to get the current tick count. This count
+ 	 * is set to 0 when the partition is created and is incremented in
+ 	 * 100 nanosecond units.
+ 	 */
+ 	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
+ 	return current_tick;
+ }
+ 
+ static struct clocksource hyperv_cs_msr = {
+ 	.name		= "hyperv_clocksource_msr",
+ 	.rating		= 400,
+ 	.read		= read_hv_clock_msr,
+ 	.mask		= CLOCKSOURCE_MASK(64),
+ 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+ };
++>>>>>>> 0733379b512c (x86/hyperv: Move TSC reading method to asm/mshyperv.h)
  
  static void *hypercall_pg;
 -struct clocksource *hyperv_cs;
 -EXPORT_SYMBOL_GPL(hyperv_cs);
 -
  /*
   * This function is to be invoked early in the boot sequence after the
   * hypervisor has been detected.
diff --cc arch/x86/include/asm/mshyperv.h
index 766df316b67a,fba100713924..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -84,6 -169,65 +84,66 @@@ void hv_setup_crash_handler(void (*hand
  void hv_remove_crash_handler(void);
  
  #if IS_ENABLED(CONFIG_HYPERV)
 -extern struct clocksource *hyperv_cs;
 -
  void hyperv_init(void);
++<<<<<<< HEAD
++=======
+ void hyperv_report_panic(struct pt_regs *regs);
+ bool hv_is_hypercall_page_setup(void);
+ void hyperv_cleanup(void);
+ #endif
+ #ifdef CONFIG_HYPERV_TSCPAGE
+ struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
+ static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
+ {
+ 	u64 scale, offset, cur_tsc;
+ 	u32 sequence;
+ 
+ 	/*
+ 	 * The protocol for reading Hyper-V TSC page is specified in Hypervisor
+ 	 * Top-Level Functional Specification ver. 3.0 and above. To get the
+ 	 * reference time we must do the following:
+ 	 * - READ ReferenceTscSequence
+ 	 *   A special '0' value indicates the time source is unreliable and we
+ 	 *   need to use something else. The currently published specification
+ 	 *   versions (up to 4.0b) contain a mistake and wrongly claim '-1'
+ 	 *   instead of '0' as the special value, see commit c35b82ef0294.
+ 	 * - ReferenceTime =
+ 	 *        ((RDTSC() * ReferenceTscScale) >> 64) + ReferenceTscOffset
+ 	 * - READ ReferenceTscSequence again. In case its value has changed
+ 	 *   since our first reading we need to discard ReferenceTime and repeat
+ 	 *   the whole sequence as the hypervisor was updating the page in
+ 	 *   between.
+ 	 */
+ 	do {
+ 		sequence = READ_ONCE(tsc_pg->tsc_sequence);
+ 		if (!sequence)
+ 			return U64_MAX;
+ 		/*
+ 		 * Make sure we read sequence before we read other values from
+ 		 * TSC page.
+ 		 */
+ 		smp_rmb();
+ 
+ 		scale = READ_ONCE(tsc_pg->tsc_scale);
+ 		offset = READ_ONCE(tsc_pg->tsc_offset);
+ 		cur_tsc = rdtsc_ordered();
+ 
+ 		/*
+ 		 * Make sure we read sequence after we read all other values
+ 		 * from TSC page.
+ 		 */
+ 		smp_rmb();
+ 
+ 	} while (READ_ONCE(tsc_pg->tsc_sequence) != sequence);
+ 
+ 	return mul_u64_u64_shr(cur_tsc, scale, 64) + offset;
+ }
+ 
+ #else
+ static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
+ {
+ 	return NULL;
+ }
++>>>>>>> 0733379b512c (x86/hyperv: Move TSC reading method to asm/mshyperv.h)
  #endif
  #endif
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/include/asm/mshyperv.h
