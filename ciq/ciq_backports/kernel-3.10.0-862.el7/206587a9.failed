X86/nVMX: Properly set spec_ctrl and pred_cmd before merging MSRs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] nvmx: Properly set spec_ctrl and pred_cmd before merging MSRs (Paolo Bonzini) [1537379]
Rebuild_FUZZ: 96.83%
commit-author KarimAllah Ahmed <karahmed@amazon.de>
commit 206587a9fb764d71f035dc7f6d3b6488f5d5b304
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/206587a9.failed

These two variables should check whether SPEC_CTRL and PRED_CMD are
supposed to be passed through to L2 guests or not. While
msr_write_intercepted_l01 would return 'true' if it is not passed through.

So just invert the result of msr_write_intercepted_l01 to implement the
correct semantics.

	Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Acked-by: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arjan van de Ven <arjan@linux.intel.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David Woodhouse <dwmw2@infradead.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: arjan.van.de.ven@intel.com
	Cc: dave.hansen@intel.com
	Cc: kvm@vger.kernel.org
	Cc: sironi@amazon.de
Fixes: 086e7d4118cc ("KVM: VMX: Allow direct access to MSR_IA32_SPEC_CTRL")
Link: http://lkml.kernel.org/r/1518305967-31356-5-git-send-email-dwmw@amazon.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 206587a9fb764d71f035dc7f6d3b6488f5d5b304)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 553a3a9096ee,599179bfb87f..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9336,14 -10205,29 +9336,33 @@@ static inline bool nested_vmx_merge_msr
  	int msr;
  	struct page *page;
  	unsigned long *msr_bitmap_l1;
++<<<<<<< HEAD
 +	unsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.msr_bitmap;
++=======
+ 	unsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.vmcs02.msr_bitmap;
+ 	/*
+ 	 * pred_cmd & spec_ctrl are trying to verify two things:
+ 	 *
+ 	 * 1. L0 gave a permission to L1 to actually passthrough the MSR. This
+ 	 *    ensures that we do not accidentally generate an L02 MSR bitmap
+ 	 *    from the L12 MSR bitmap that is too permissive.
+ 	 * 2. That L1 or L2s have actually used the MSR. This avoids
+ 	 *    unnecessarily merging of the bitmap if the MSR is unused. This
+ 	 *    works properly because we only update the L01 MSR bitmap lazily.
+ 	 *    So even if L0 should pass L1 these MSRs, the L01 bitmap is only
+ 	 *    updated to reflect this when L1 (or its L2s) actually write to
+ 	 *    the MSR.
+ 	 */
+ 	bool pred_cmd = !msr_write_intercepted_l01(vcpu, MSR_IA32_PRED_CMD);
+ 	bool spec_ctrl = !msr_write_intercepted_l01(vcpu, MSR_IA32_SPEC_CTRL);
++>>>>>>> 206587a9fb76 (X86/nVMX: Properly set spec_ctrl and pred_cmd before merging MSRs)
  
 -	if (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&
 -	    !pred_cmd && !spec_ctrl)
 +	/* This shortcut is ok because we support only x2APIC MSRs so far. */
 +	if (!nested_cpu_has_virt_x2apic_mode(vmcs12))
  		return false;
  
 -	page = kvm_vcpu_gpa_to_page(vcpu, vmcs12->msr_bitmap);
 -	if (is_error_page(page))
 +	page = nested_get_page(vcpu, vmcs12->msr_bitmap);
 +	if (!page)
  		return false;
  	msr_bitmap_l1 = (unsigned long *)kmap(page);
  
* Unmerged path arch/x86/kvm/vmx.c
