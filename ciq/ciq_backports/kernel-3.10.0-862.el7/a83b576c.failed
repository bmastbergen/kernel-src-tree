block: fix stacked driver stats init and free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [block] fix stacked driver stats init and free (Ming Lei) [1458104]
Rebuild_FUZZ: 91.57%
commit-author Jens Axboe <axboe@fb.com>
commit a83b576c9c25cf771fb0b15ec5eb2e7510ec2f5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a83b576c.failed

If a driver allocates a queue for stacked usage, then it does
not currently get stats allocated. This causes the later init
of, eg, writeback throttling to blow up. Move the init to the
queue allocation instead.

Additionally, allow a NULL callback unregistration. This avoids
having the caller check for that, fixing another oops on
removal of a block device that doesn't have poll stats allocated.

Fixes: 34dbad5d26e2 ("blk-stat: convert to callback-based statistics reporting")
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit a83b576c9c25cf771fb0b15ec5eb2e7510ec2f5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
#	block/blk-stat.c
diff --cc block/blk-core.c
index 844f81639307,ad388d5e309a..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -674,22 -712,25 +674,41 @@@ struct request_queue *blk_alloc_queue_n
  	if (q->id < 0)
  		goto fail_q;
  
++<<<<<<< HEAD
 +	q->backing_dev_info.ra_pages =
 +			(VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;
 +	q->backing_dev_info.state = 0;
 +	q->backing_dev_info.capabilities = BDI_CAP_MAP_COPY;
 +	q->backing_dev_info.name = "block";
++=======
+ 	q->bio_split = bioset_create(BIO_POOL_SIZE, 0);
+ 	if (!q->bio_split)
+ 		goto fail_id;
+ 
+ 	q->backing_dev_info = bdi_alloc_node(gfp_mask, node_id);
+ 	if (!q->backing_dev_info)
+ 		goto fail_split;
+ 
+ 	q->stats = blk_alloc_queue_stats();
+ 	if (!q->stats)
+ 		goto fail_stats;
+ 
+ 	q->backing_dev_info->ra_pages =
+ 			(VM_MAX_READAHEAD * 1024) / PAGE_SIZE;
+ 	q->backing_dev_info->capabilities = BDI_CAP_CGROUP_WRITEBACK;
+ 	q->backing_dev_info->name = "block";
++>>>>>>> a83b576c9c25 (block: fix stacked driver stats init and free)
  	q->node = node_id;
  
 -	setup_timer(&q->backing_dev_info->laptop_mode_wb_timer,
 +	/* Initialize auxillary shadow structure used to extend struct queue_limits */
 +	limits_aux = (struct queue_limits_aux *)&q[1];
 +	queue_limits_init_aux(q, limits_aux);
 +
 +	err = bdi_init(&q->backing_dev_info);
 +	if (err)
 +		goto fail_id;
 +
 +	setup_timer(&q->backing_dev_info.laptop_mode_wb_timer,
  		    laptop_mode_timer_fn, (unsigned long) q);
  	setup_timer(&q->timeout, blk_rq_timed_out_timer, (unsigned long) q);
  	INIT_LIST_HEAD(&q->queue_head);
@@@ -739,7 -780,11 +758,15 @@@
  fail_ref:
  	percpu_ref_exit(&q->q_usage_counter);
  fail_bdi:
++<<<<<<< HEAD
 +	bdi_destroy(&q->backing_dev_info);
++=======
+ 	blk_free_queue_stats(q->stats);
+ fail_stats:
+ 	bdi_put(q->backing_dev_info);
+ fail_split:
+ 	bioset_free(q->bio_split);
++>>>>>>> a83b576c9c25 (block: fix stacked driver stats init and free)
  fail_id:
  	ida_simple_remove(&blk_queue_ida, q->id);
  fail_q:
@@@ -804,30 -853,24 +831,34 @@@ blk_init_queue_node(request_fn_proc *rf
  }
  EXPORT_SYMBOL(blk_init_queue_node);
  
 -static blk_qc_t blk_queue_bio(struct request_queue *q, struct bio *bio);
 -
 -
 -int blk_init_allocated_queue(struct request_queue *q)
 +struct request_queue *
 +blk_init_allocated_queue(struct request_queue *q, request_fn_proc *rfn,
 +			 spinlock_t *lock)
  {
++<<<<<<< HEAD
 +	if (!q)
 +		return NULL;
 +
 +	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, 0);
++=======
+ 	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
++>>>>>>> a83b576c9c25 (block: fix stacked driver stats init and free)
  	if (!q->fq)
 -		return -ENOMEM;
 -
 -	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
 -		goto out_free_flush_queue;
 +		return NULL;
  
  	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
 -		goto out_exit_flush_rq;
 +		goto fail;
  
  	INIT_WORK(&q->timeout_work, blk_timeout_work);
 +	q->request_fn		= rfn;
 +	q->prep_rq_fn		= NULL;
 +	q->unprep_rq_fn		= NULL;
  	q->queue_flags		|= QUEUE_FLAG_DEFAULT;
  
 +	/* Override internal queue lock with supplied lock pointer */
 +	if (lock)
 +		q->queue_lock		= lock;
 +
  	/*
  	 * This also sets hw/phys segments, boundary and size
  	 */
* Unmerged path block/blk-stat.c
* Unmerged path block/blk-core.c
* Unmerged path block/blk-stat.c
