ALSA: x86: Reduce redundant register field names

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 7ceba75f21e4ecb520b110ffada72cc0c9f5c072
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7ceba75f.failed

Currently each register definition contains the own prefix in the
union struct itself; for example, union aud_ch_status_0 has
status_0_regx and status_0_regval fields.  These are simply
superfluous, since usually the type of the variable is seen in its
declaration or in its name.

In this patch, we cut off these prefixes.  Now all register
definitions have regx and regval fields consistently, instead.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 7ceba75f21e4ecb520b110ffada72cc0c9f5c072)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
#	sound/x86/intel_hdmi_lpe_audio.h
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,f825d514500e..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -238,40 -258,43 +238,55 @@@ int had_read_modify(struct snd_intelha
   * causes the "channels" field to be updated as 0xy binary resulting in
   * bad audio. The fix is to always write the AUD_CONFIG[6:4] with
   * appropriate value when doing read-modify of AUD_CONFIG register.
 + *
 + * @substream: the current substream or NULL if no active substream
 + * @data : data to be written
 + * @mask : mask
 + *
   */
 -static void snd_intelhad_enable_audio(struct snd_pcm_substream *substream,
 -				      struct snd_intelhad *intelhaddata,
 -				      bool enable)
 +static int had_read_modify_aud_config_v2(struct snd_pcm_substream *substream,
 +					u32 data, u32 mask)
  {
++<<<<<<< HEAD
 +	struct snd_intelhad *intelhaddata = snd_pcm_substream_chip(substream);
 +	union aud_cfg cfg_val = {.cfg_regval = 0};
 +	u8 channels;
++=======
+ 	union aud_cfg cfg_val = {.regval = 0};
+ 	u8 channels, data, mask;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  
  	/*
  	 * If substream is NULL, there is no active stream.
  	 * In this case just set channels to 2
  	 */
++<<<<<<< HEAD
 +	if (substream)
 +		channels = substream->runtime->channels;
 +	else
 +		channels = 2;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
 +
 +	data = data | cfg_val.cfg_regval;
 +	mask = mask | AUD_CONFIG_CH_MASK_V2;
++=======
+ 	channels = substream ? substream->runtime->channels : 2;
+ 	cfg_val.regx.num_ch = channels - 2;
+ 
+ 	data = cfg_val.regval;
+ 	if (enable)
+ 		data |= 1;
+ 	mask = AUD_CONFIG_CH_MASK | 1;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  
 -	dev_dbg(intelhaddata->dev, "%s : data = %x, mask =%x\n",
 -		__func__, data, mask);
 +	pr_debug("%s : data = %x, mask =%x\n", __func__, data, mask);
  
 -	had_read_modify(intelhaddata, AUD_CONFIG, data, mask);
 +	return had_read_modify(intelhaddata, AUD_CONFIG, data, mask);
  }
  
 -/* enable / disable the audio interface */
 -static void snd_intelhad_enable_audio_int(struct snd_intelhad *ctx, bool enable)
 +void snd_intelhad_enable_audio(struct snd_pcm_substream *substream, u8 enable)
  {
 -	u32 status_reg;
 -
 -	if (enable) {
 -		mid_hdmi_audio_read(ctx, AUD_HDMI_STATUS, &status_reg);
 -		status_reg |= HDMI_AUDIO_BUFFER_DONE | HDMI_AUDIO_UNDERRUN;
 -		mid_hdmi_audio_write(ctx, AUD_HDMI_STATUS, status_reg);
 -		mid_hdmi_audio_read(ctx, AUD_HDMI_STATUS, &status_reg);
 -	}
 +	had_read_modify_aud_config_v2(substream, enable, BIT(0));
  }
  
  static void snd_intelhad_reset_audio(struct snd_intelhad *intelhaddata,
@@@ -287,18 -310,16 +302,26 @@@
  static int had_prog_status_reg(struct snd_pcm_substream *substream,
  			struct snd_intelhad *intelhaddata)
  {
- 	union aud_cfg cfg_val = {.cfg_regval = 0};
- 	union aud_ch_status_0 ch_stat0 = {.status_0_regval = 0};
- 	union aud_ch_status_1 ch_stat1 = {.status_1_regval = 0};
+ 	union aud_cfg cfg_val = {.regval = 0};
+ 	union aud_ch_status_0 ch_stat0 = {.regval = 0};
+ 	union aud_ch_status_1 ch_stat1 = {.regval = 0};
  	int format;
  
++<<<<<<< HEAD
 +	pr_debug("Entry %s\n", __func__);
 +
 +	ch_stat0.status_0_regx.lpcm_id = (intelhaddata->aes_bits &
 +						IEC958_AES0_NONAUDIO)>>1;
 +	ch_stat0.status_0_regx.clk_acc = (intelhaddata->aes_bits &
 +						IEC958_AES3_CON_CLOCK)>>4;
 +	cfg_val.cfg_regx_v2.val_bit = ch_stat0.status_0_regx.lpcm_id;
++=======
+ 	ch_stat0.regx.lpcm_id = (intelhaddata->aes_bits &
+ 					  IEC958_AES0_NONAUDIO) >> 1;
+ 	ch_stat0.regx.clk_acc = (intelhaddata->aes_bits &
+ 					  IEC958_AES3_CON_CLOCK) >> 4;
+ 	cfg_val.regx.val_bit = ch_stat0.regx.lpcm_id;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  
  	switch (substream->runtime->rate) {
  	case AUD_SAMPLE_RATE_32:
@@@ -327,26 -348,26 +350,26 @@@
  	default:
  		/* control should never come here */
  		return -EINVAL;
 -	}
 +	break;
  
 +	}
  	had_write_register(intelhaddata,
- 			   AUD_CH_STATUS_0, ch_stat0.status_0_regval);
+ 			   AUD_CH_STATUS_0, ch_stat0.regval);
  
  	format = substream->runtime->format;
  
  	if (format == SNDRV_PCM_FORMAT_S16_LE) {
- 		ch_stat1.status_1_regx.max_wrd_len = MAX_SMPL_WIDTH_20;
- 		ch_stat1.status_1_regx.wrd_len = SMPL_WIDTH_16BITS;
+ 		ch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_20;
+ 		ch_stat1.regx.wrd_len = SMPL_WIDTH_16BITS;
  	} else if (format == SNDRV_PCM_FORMAT_S24_LE) {
- 		ch_stat1.status_1_regx.max_wrd_len = MAX_SMPL_WIDTH_24;
- 		ch_stat1.status_1_regx.wrd_len = SMPL_WIDTH_24BITS;
+ 		ch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_24;
+ 		ch_stat1.regx.wrd_len = SMPL_WIDTH_24BITS;
  	} else {
- 		ch_stat1.status_1_regx.max_wrd_len = 0;
- 		ch_stat1.status_1_regx.wrd_len = 0;
+ 		ch_stat1.regx.max_wrd_len = 0;
+ 		ch_stat1.regx.wrd_len = 0;
  	}
 -
  	had_write_register(intelhaddata,
- 			   AUD_CH_STATUS_1, ch_stat1.status_1_regval);
+ 			   AUD_CH_STATUS_1, ch_stat1.regval);
  	return 0;
  }
  
@@@ -364,20 -385,20 +387,37 @@@ static int snd_intelhad_audio_ctrl(stru
  
  	had_prog_status_reg(substream, intelhaddata);
  
++<<<<<<< HEAD
 +	buf_cfg.buf_cfg_regx_v2.audio_fifo_watermark = FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
 +	buf_cfg.buf_cfg_regx_v2.aud_delay = 0;
 +	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.buf_cfgval);
 +
 +	channels = substream->runtime->channels;
 +	cfg_val.cfg_regx_v2.num_ch = channels - 2;
 +	if (channels <= 2)
 +		cfg_val.cfg_regx_v2.layout = LAYOUT0;
 +	else
 +		cfg_val.cfg_regx_v2.layout = LAYOUT1;
 +
 +	cfg_val.cfg_regx_v2.val_bit = 1;
 +	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.cfg_regval);
++=======
+ 	buf_cfg.regx.audio_fifo_watermark = FIFO_THRESHOLD;
+ 	buf_cfg.regx.dma_fifo_watermark = DMA_FIFO_THRESHOLD;
+ 	buf_cfg.regx.aud_delay = 0;
+ 	had_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.regval);
+ 
+ 	channels = substream->runtime->channels;
+ 	cfg_val.regx.num_ch = channels - 2;
+ 	if (channels <= 2)
+ 		cfg_val.regx.layout = LAYOUT0;
+ 	else
+ 		cfg_val.regx.layout = LAYOUT1;
+ 
+ 	cfg_val.regx.val_bit = 1;
+ 	had_write_register(intelhaddata, AUD_CONFIG, cfg_val.regval);
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  	return 0;
  }
  
@@@ -612,44 -631,42 +652,50 @@@ static void snd_intelhad_prog_dip(struc
  
  	if (intelhaddata->dp_output) {
  		info_frame = DP_INFO_FRAME_WORD1;
- 		frame2.fr2_val = 1;
+ 		frame2.regval = 1;
  	} else {
  		info_frame = HDMI_INFO_FRAME_WORD1;
- 		frame2.fr2_regx.chnl_cnt = substream->runtime->channels - 1;
+ 		frame2.regx.chnl_cnt = substream->runtime->channels - 1;
  
- 		frame3.fr3_regx.chnl_alloc = snd_intelhad_channel_allocation(
+ 		frame3.regx.chnl_alloc = snd_intelhad_channel_allocation(
  			intelhaddata, channels);
  
 -		/* Calculte the byte wide checksum for all valid DIP words */
 +		/*Calculte the byte wide checksum for all valid DIP words*/
  		for (i = 0; i < BYTES_PER_WORD; i++)
- 			checksum += (info_frame >> i*BITS_PER_BYTE) & MASK_BYTE0;
+ 			checksum += (info_frame >> (i * 8)) & 0xff;
  		for (i = 0; i < BYTES_PER_WORD; i++)
- 			checksum += (frame2.fr2_val >> i*BITS_PER_BYTE) & MASK_BYTE0;
+ 			checksum += (frame2.regval >> (i * 8)) & 0xff;
  		for (i = 0; i < BYTES_PER_WORD; i++)
- 			checksum += (frame3.fr3_val >> i*BITS_PER_BYTE) & MASK_BYTE0;
+ 			checksum += (frame3.regval >> (i * 8)) & 0xff;
  
- 		frame2.fr2_regx.chksum = -(checksum);
+ 		frame2.regx.chksum = -(checksum);
  	}
  
++<<<<<<< HEAD
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, info_frame);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, frame2.fr2_val);
 +	had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, frame3.fr3_val);
++=======
+ 	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, info_frame);
+ 	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame2.regval);
+ 	had_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame3.regval);
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  
  	/* program remaining DIP words with zero */
  	for (i = 0; i < HAD_MAX_DIP_WORDS-VALID_DIP_WORDS; i++)
 -		had_write_register(intelhaddata, AUD_HDMIW_INFOFR, 0x0);
 +		had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, 0x0);
  
- 	ctrl_state.ctrl_regx.dip_freq = 1;
- 	ctrl_state.ctrl_regx.dip_en_sta = 1;
- 	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.ctrl_val);
+ 	ctrl_state.regx.dip_freq = 1;
+ 	ctrl_state.regx.dip_en_sta = 1;
+ 	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);
  }
  
 -/*
 - * snd_intelhad_prog_buffer - programs buffer address and length registers
 - * @substream: substream for which the prepare function is called
 - * @intelhaddata: substream private data
 +/**
 + * snd_intelhad_prog_buffer - programs buffer
 + * address and length registers
 + *
 + * @substream:substream for which the prepare function is called
 + * @intelhaddata:substream private data
   *
   * This function programs ring buffer address and length into registers.
   */
diff --cc sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57,0e8397970e4a..000000000000
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@@ -373,17 -216,11 +367,16 @@@ union aud_cfg 
  		u32 bogus_sample:1;
  		u32 dp_modei:1;
  		u32 rsvd:16;
++<<<<<<< HEAD
 +	} cfg_regx_v2;
 +	u32 cfg_regval;
++=======
+ 	} regx;
+ 	u32 regval;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  };
  
- /**
-  * union aud_ch_status_0 - Audio Channel Status 0 Attributes
-  *
-  * @status_0_regx:individual register bits
-  * @status_0_regval:full register value
-  *
-  */
+ /* Audio Channel Status 0 Attributes */
  union aud_ch_status_0 {
  	struct {
  		u32 ch_status:1;
@@@ -429,33 -254,21 +410,31 @@@ union aud_hdmi_cts 
  		u32 cts_val:24;
  		u32 en_cts_prog:1;
  		u32 rsvd:7;
++<<<<<<< HEAD
 +	} cts_regx_v2;
 +	u32 cts_regval;
++=======
+ 	} regx;
+ 	u32 regval;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  };
  
- /**
-  * union aud_hdmi_n_enable - N register
-  *
-  * @n_regx: individual register bits
-  * @n_regval: full register value
-  *
-  */
+ /* N register */
  union aud_hdmi_n_enable {
  	struct {
  		u32 n_val:24;
  		u32 en_n_prog:1;
  		u32 rsvd:7;
++<<<<<<< HEAD
 +	} n_regx_v2;
 +	u32 n_regval;
++=======
+ 	} regx;
+ 	u32 regval;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  };
  
- /**
-  * union aud_buf_config -  Audio Buffer configurations
-  *
-  * @buf_cfg_regx: individual register bits
-  * @buf_cfgval: full register value
-  *
-  */
+ /* Audio Buffer configurations */
  union aud_buf_config {
  	struct {
  		u32 audio_fifo_watermark:8;
@@@ -463,17 -276,11 +442,16 @@@
  		u32 rsvd0:5;
  		u32 aud_delay:8;
  		u32 rsvd1:8;
++<<<<<<< HEAD
 +	} buf_cfg_regx_v2;
 +	u32 buf_cfgval;
++=======
+ 	} regx;
+ 	u32 regval;
++>>>>>>> 7ceba75f21e4 (ALSA: x86: Reduce redundant register field names)
  };
  
- /**
-  * union aud_buf_ch_swap - Audio Sample Swapping offset
-  *
-  * @buf_ch_swap_regx: individual register bits
-  * @buf_ch_swap_val: full register value
-  *
-  */
+ /* Audio Sample Swapping offset */
  union aud_buf_ch_swap {
  	struct {
  		u32 first_0:3;
@@@ -596,16 -367,10 +538,16 @@@ union aud_info_frame3 
  		u32 lsv:4;
  		u32 dm_inh:1;
  		u32 rsvd1:16;
- 	} fr3_regx;
- 	u32 fr3_val;
+ 	} regx;
+ 	u32 regval;
  };
  
 +enum hdmi_connector_status {
 +	hdmi_connector_status_connected = 1,
 +	hdmi_connector_status_disconnected = 2,
 +	hdmi_connector_status_unknown = 3,
 +};
 +
  #define HDMI_AUDIO_UNDERRUN     (1UL<<31)
  #define HDMI_AUDIO_BUFFER_DONE  (1UL<<29)
  
* Unmerged path sound/x86/intel_hdmi_audio.c
diff --git a/sound/x86/intel_hdmi_audio.h b/sound/x86/intel_hdmi_audio.h
index 32a2fb766e47..5b8acfe17652 100644
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@ -66,7 +66,6 @@ struct platform_device;
 #define SMPL_WIDTH_16BITS	0x1
 #define SMPL_WIDTH_24BITS	0x5
 #define CHANNEL_ALLOCATION	0x1F
-#define MASK_BYTE0		0x000000FF
 #define VALID_DIP_WORDS		3
 #define LAYOUT0			0
 #define LAYOUT1			1
* Unmerged path sound/x86/intel_hdmi_lpe_audio.h
