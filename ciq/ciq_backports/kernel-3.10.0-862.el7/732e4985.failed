netvsc: fix race on sub channel creation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 732e49850c5e15231e11a0a464748bcbade5e3c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/732e4985.failed

The existing sub channel code did not wait for all the sub-channels
to completely initialize. This could lead to race causing crash
in napi_netif_del() from bad list. The existing code would send
an init message, then wait only for the initial response that
the init message was received. It thought it was waiting for
sub channels but really the init response did the wakeup.

The new code keeps track of the number of open channels and
waits until that many are open.

Other issues here were:
  * host might return less sub-channels than was requested.
  * the new init status is not valid until after init was completed.

Fixes: b3e6b82a0099 ("hv_netvsc: Wait for sub-channels to be processed during probe")
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 732e49850c5e15231e11a0a464748bcbade5e3c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,12cc64bfcff8..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -746,13 -762,11 +746,19 @@@ struct netvsc_device 
  
  	struct nvsp_message revoke_packet;
  
 +	struct vmbus_channel *chn_table[VRSS_CHANNEL_MAX];
 +	u32 send_table[VRSS_SEND_TAB_SIZE];
  	u32 max_chn;
  	u32 num_chn;
++<<<<<<< HEAD
 +	spinlock_t sc_lock; /* Protects num_sc_offered variable */
 +	u32 num_sc_offered;
 +	atomic_t queue_sends[VRSS_CHANNEL_MAX];
++=======
+ 
+ 	atomic_t open_chn;
+ 	wait_queue_head_t subchan_open;
++>>>>>>> 732e49850c5e (netvsc: fix race on sub channel creation)
  
  	struct rndis_device *extension;
  
diff --cc drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92,d6308ffda53e..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -925,18 -1035,21 +925,23 @@@ static void netvsc_sc_open(struct vmbus
  	 */
  	set_channel_read_mode(new_sc, HV_CALL_ISR);
  
 -	/* Set the channel before opening.*/
 -	nvchan->channel = new_sc;
 -	netif_napi_add(ndev, &nvchan->napi,
 -		       netvsc_poll, NAPI_POLL_WEIGHT);
 -
  	ret = vmbus_open(new_sc, nvscdev->ring_size * PAGE_SIZE,
  			 nvscdev->ring_size * PAGE_SIZE, NULL, 0,
 -			 netvsc_channel_cb, nvchan);
 -	if (ret == 0)
 -		napi_enable(&nvchan->napi);
 -	else
 -		netif_napi_del(&nvchan->napi);
 +			 netvsc_channel_cb, new_sc);
  
++<<<<<<< HEAD
 +	if (ret == 0)
 +		nvscdev->chn_table[chn_index] = new_sc;
 +
 +	spin_lock_irqsave(&nvscdev->sc_lock, flags);
 +	nvscdev->num_sc_offered--;
 +	spin_unlock_irqrestore(&nvscdev->sc_lock, flags);
 +	if (nvscdev->num_sc_offered == 0)
 +		complete(&nvscdev->channel_init_wait);
++=======
+ 	atomic_inc(&nvscdev->open_chn);
+ 	wake_up(&nvscdev->subchan_open);
++>>>>>>> 732e49850c5e (netvsc: fix race on sub channel creation)
  }
  
  int rndis_filter_device_add(struct hv_device *dev,
@@@ -979,8 -1090,6 +984,11 @@@
  	net_device->max_chn = 1;
  	net_device->num_chn = 1;
  
++<<<<<<< HEAD
 +	spin_lock_init(&net_device->sc_lock);
 +
++=======
++>>>>>>> 732e49850c5e (netvsc: fix race on sub channel creation)
  	net_device->extension = rndis_device;
  	rndis_device->ndev = net;
  
@@@ -1070,18 -1219,10 +1078,25 @@@
  		rndis_device->ind_table[i] = ethtool_rxfh_indir_default(i,
  							net_device->num_chn);
  
++<<<<<<< HEAD
 +	net_device->num_sc_offered = num_rss_qs;
 +
 +	if (net_device->num_chn == 1)
 +		goto out;
 +
 +	net_device->sub_cb_buf = vzalloc((net_device->num_chn - 1) *
 +					 NETVSC_PACKET_SIZE);
 +	if (!net_device->sub_cb_buf) {
 +		net_device->num_chn = 1;
 +		dev_info(&dev->device, "No memory for subchannels.\n");
 +		goto out;
 +	}
++=======
+ 	atomic_set(&net_device->open_chn, 1);
+ 	num_rss_qs = net_device->num_chn - 1;
+ 	if (num_rss_qs == 0)
+ 		return 0;
++>>>>>>> 732e49850c5e (netvsc: fix race on sub channel creation)
  
  	vmbus_set_sc_create_callback(dev->channel, netvsc_sc_open);
  
@@@ -1098,27 -1239,23 +1113,46 @@@
  			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
  	if (ret)
  		goto out;
 +	wait_for_completion(&net_device->channel_init_wait);
 +
++<<<<<<< HEAD
 +	if (init_packet->msg.v5_msg.subchn_comp.status !=
 +	    NVSP_STAT_SUCCESS) {
 +		ret = -ENODEV;
 +		goto out;
 +	}
 +	net_device->num_chn = 1 +
 +		init_packet->msg.v5_msg.subchn_comp.num_subchannels;
  
 +	ret = rndis_filter_set_rss_param(rndis_device, netvsc_hash_key,
 +					 net_device->num_chn);
 +
 +	/*
 +	 * Set the number of sub-channels to be received.
 +	 */
 +	spin_lock_irqsave(&net_device->sc_lock, flags);
 +	sc_delta = num_rss_qs - (net_device->num_chn - 1);
 +	net_device->num_sc_offered -= sc_delta;
 +	spin_unlock_irqrestore(&net_device->sc_lock, flags);
 +
++=======
+ 	wait_for_completion(&net_device->channel_init_wait);
+ 	if (init_packet->msg.v5_msg.subchn_comp.status != NVSP_STAT_SUCCESS) {
+ 		ret = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	net_device->num_chn = 1 +
+ 		init_packet->msg.v5_msg.subchn_comp.num_subchannels;
+ 
+ 	/* wait for all sub channels to open */
+ 	wait_event(net_device->subchan_open,
+ 		   atomic_read(&net_device->open_chn) == net_device->num_chn);
+ 
+ 	/* ignore failues from setting rss parameters, still have channels */
+ 	rndis_filter_set_rss_param(rndis_device, netvsc_hash_key,
+ 				   net_device->num_chn);
++>>>>>>> 732e49850c5e (netvsc: fix race on sub channel creation)
  out:
  	if (ret) {
  		net_device->max_chn = 1;
* Unmerged path drivers/net/hyperv/hyperv_net.h
diff --git a/drivers/net/hyperv/netvsc.c b/drivers/net/hyperv/netvsc.c
index 3170ba757106..a30ec69a4a80 100644
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@ -84,6 +84,7 @@ static struct netvsc_device *alloc_net_device(void)
 	net_device->max_pkt = RNDIS_MAX_PKT_DEFAULT;
 	net_device->pkt_align = RNDIS_PKT_ALIGN_DEFAULT;
 	init_completion(&net_device->channel_init_wait);
+	init_waitqueue_head(&net_device->subchan_open);
 
 	return net_device;
 }
* Unmerged path drivers/net/hyperv/rndis_filter.c
