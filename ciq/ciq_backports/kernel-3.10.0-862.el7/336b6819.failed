scsi: smartpqi: add pqi reset quiesce support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] smartpqi: add pqi reset quiesce support (Don Brace) [1457414]
Rebuild_FUZZ: 92.86%
commit-author Kevin Barnett <kevin.barnett@microseim.com>
commit 336b68193165b1215d21dd05619dc262340e404b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/336b6819.failed

	Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 336b68193165b1215d21dd05619dc262340e404b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi.h
#	drivers/scsi/smartpqi/smartpqi_sis.c
diff --cc drivers/scsi/smartpqi/smartpqi.h
index 591b0f1547e0,6dd04491423b..000000000000
--- a/drivers/scsi/smartpqi/smartpqi.h
+++ b/drivers/scsi/smartpqi/smartpqi.h
@@@ -629,6 -636,80 +629,83 @@@ struct pqi_encryption_info 
  	u32	encrypt_tweak_upper;
  };
  
++<<<<<<< HEAD
++=======
+ #pragma pack(1)
+ 
+ #define PQI_CONFIG_TABLE_SIGNATURE	"CFGTABLE"
+ #define PQI_CONFIG_TABLE_MAX_LENGTH	((u16)~0)
+ 
+ /* configuration table section IDs */
+ #define PQI_CONFIG_TABLE_SECTION_GENERAL_INFO		0
+ #define PQI_CONFIG_TABLE_SECTION_FIRMWARE_FEATURES	1
+ #define PQI_CONFIG_TABLE_SECTION_FIRMWARE_ERRATA	2
+ #define PQI_CONFIG_TABLE_SECTION_DEBUG			3
+ #define PQI_CONFIG_TABLE_SECTION_HEARTBEAT		4
+ 
+ struct pqi_config_table {
+ 	u8	signature[8];		/* "CFGTABLE" */
+ 	__le32	first_section_offset;	/* offset in bytes from the base */
+ 					/* address of this table to the */
+ 					/* first section */
+ };
+ 
+ struct pqi_config_table_section_header {
+ 	__le16	section_id;		/* as defined by the */
+ 					/* PQI_CONFIG_TABLE_SECTION_* */
+ 					/* manifest constants above */
+ 	__le16	next_section_offset;	/* offset in bytes from base */
+ 					/* address of the table of the */
+ 					/* next section or 0 if last entry */
+ };
+ 
+ struct pqi_config_table_general_info {
+ 	struct pqi_config_table_section_header header;
+ 	__le32	section_length;		/* size of this section in bytes */
+ 					/* including the section header */
+ 	__le32	max_outstanding_requests;	/* max. outstanding */
+ 						/* commands supported by */
+ 						/* the controller */
+ 	__le32	max_sg_size;		/* max. transfer size of a single */
+ 					/* command */
+ 	__le32	max_sg_per_request;	/* max. number of scatter-gather */
+ 					/* entries supported in a single */
+ 					/* command */
+ };
+ 
+ struct pqi_config_table_debug {
+ 	struct pqi_config_table_section_header header;
+ 	__le32	scratchpad;
+ };
+ 
+ struct pqi_config_table_heartbeat {
+ 	struct pqi_config_table_section_header header;
+ 	__le32	heartbeat_counter;
+ };
+ 
+ union pqi_reset_register {
+ 	struct {
+ 		u32	reset_type : 3;
+ 		u32	reserved : 2;
+ 		u32	reset_action : 3;
+ 		u32	hold_in_pd1 : 1;
+ 		u32	reserved2 : 23;
+ 	} bits;
+ 	u32	all_bits;
+ };
+ 
+ #define PQI_RESET_ACTION_RESET		0x1
+ 
+ #define PQI_RESET_TYPE_NO_RESET		0x0
+ #define PQI_RESET_TYPE_SOFT_RESET	0x1
+ #define PQI_RESET_TYPE_FIRM_RESET	0x2
+ #define PQI_RESET_TYPE_HARD_RESET	0x3
+ 
+ #define PQI_RESET_ACTION_COMPLETED	0x2
+ 
+ #define PQI_RESET_POLL_INTERVAL_MSECS	100
+ 
++>>>>>>> 336b68193165 (scsi: smartpqi: add pqi reset quiesce support)
  #define PQI_MAX_OUTSTANDING_REQUESTS		((u32)~0)
  #define PQI_MAX_OUTSTANDING_REQUESTS_KDUMP	32
  #define PQI_MAX_TRANSFER_SIZE			(1024U * 1024U)
@@@ -942,7 -1017,7 +1019,11 @@@ struct pqi_ctrl_info 
  	u8		inbound_spanning_supported : 1;
  	u8		outbound_spanning_supported : 1;
  	u8		pqi_mode_enabled : 1;
++<<<<<<< HEAD
 +	u8		heartbeat_timer_started : 1;
++=======
+ 	u8		pqi_reset_quiesce_supported : 1;
++>>>>>>> 336b68193165 (scsi: smartpqi: add pqi reset quiesce support)
  
  	struct list_head scsi_device_list;
  	spinlock_t	scsi_device_list_lock;
diff --cc drivers/scsi/smartpqi/smartpqi_sis.c
index 6ebeb141fe44,9abbaced4b33..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_sis.c
+++ b/drivers/scsi/smartpqi/smartpqi_sis.c
@@@ -33,8 -33,10 +33,9 @@@
  /* for submission of legacy SIS commands */
  #define SIS_REENABLE_SIS_MODE			0x1
  #define SIS_ENABLE_MSIX				0x40
 -#define SIS_ENABLE_INTX				0x80
  #define SIS_SOFT_RESET				0x100
  #define SIS_TRIGGER_SHUTDOWN			0x800000
+ #define SIS_PQI_RESET_QUIESCE			0x1000000
  #define SIS_CMD_READY				0x200
  #define SIS_CMD_COMPLETE			0x1000
  #define SIS_CLEAR_CTRL_TO_HOST_DOORBELL		0x1000
@@@ -318,6 -339,40 +323,43 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ #define SIS_DOORBELL_BIT_CLEAR_TIMEOUT_SECS	30
+ 
+ static int sis_wait_for_doorbell_bit_to_clear(
+ 	struct pqi_ctrl_info *ctrl_info, u32 bit)
+ {
+ 	int rc = 0;
+ 	u32 doorbell_register;
+ 	unsigned long timeout;
+ 
+ 	timeout = (SIS_DOORBELL_BIT_CLEAR_TIMEOUT_SECS * HZ) + jiffies;
+ 
+ 	while (1) {
+ 		doorbell_register =
+ 			readl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);
+ 		if ((doorbell_register & bit) == 0)
+ 			break;
+ 		if (readl(&ctrl_info->registers->sis_firmware_status) &
+ 			SIS_CTRL_KERNEL_PANIC) {
+ 			rc = -ENODEV;
+ 			break;
+ 		}
+ 		if (time_after(jiffies, timeout)) {
+ 			dev_err(&ctrl_info->pci_dev->dev,
+ 				"doorbell register bit 0x%x not cleared\n",
+ 				bit);
+ 			rc = -ETIMEDOUT;
+ 			break;
+ 		}
+ 		usleep_range(1000, 2000);
+ 	}
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 336b68193165 (scsi: smartpqi: add pqi reset quiesce support)
  /* Enable MSI-X interrupts on the controller. */
  
  void sis_enable_msix(struct pqi_ctrl_info *ctrl_info)
* Unmerged path drivers/scsi/smartpqi/smartpqi.h
diff --git a/drivers/scsi/smartpqi/smartpqi_init.c b/drivers/scsi/smartpqi/smartpqi_init.c
index 13a5a9aaadf9..d1d96508dd09 100644
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -5580,28 +5580,62 @@ static void pqi_unregister_scsi(struct pqi_ctrl_info *ctrl_info)
 	scsi_host_put(shost);
 }
 
-#define PQI_RESET_ACTION_RESET		0x1
+static int pqi_wait_for_pqi_reset_completion(struct pqi_ctrl_info *ctrl_info)
+{
+	int rc = 0;
+	struct pqi_device_registers __iomem *pqi_registers;
+	unsigned long timeout;
+	unsigned int timeout_msecs;
+	union pqi_reset_register reset_reg;
+
+	pqi_registers = ctrl_info->pqi_registers;
+	timeout_msecs = readw(&pqi_registers->max_reset_timeout) * 100;
+	timeout = msecs_to_jiffies(timeout_msecs) + jiffies;
+
+	while (1) {
+		msleep(PQI_RESET_POLL_INTERVAL_MSECS);
+		reset_reg.all_bits = readl(&pqi_registers->device_reset);
+		if (reset_reg.bits.reset_action == PQI_RESET_ACTION_COMPLETED)
+			break;
+		pqi_check_ctrl_health(ctrl_info);
+		if (pqi_ctrl_offline(ctrl_info)) {
+			rc = -ENXIO;
+			break;
+		}
+		if (time_after(jiffies, timeout)) {
+			rc = -ETIMEDOUT;
+			break;
+		}
+	}
 
-#define PQI_RESET_TYPE_NO_RESET		0x0
-#define PQI_RESET_TYPE_SOFT_RESET	0x1
-#define PQI_RESET_TYPE_FIRM_RESET	0x2
-#define PQI_RESET_TYPE_HARD_RESET	0x3
+	return rc;
+}
 
 static int pqi_reset(struct pqi_ctrl_info *ctrl_info)
 {
 	int rc;
-	u32 reset_params;
+	union pqi_reset_register reset_reg;
 
-	reset_params = (PQI_RESET_ACTION_RESET << 5) |
-		PQI_RESET_TYPE_HARD_RESET;
+	if (ctrl_info->pqi_reset_quiesce_supported) {
+		rc = sis_pqi_reset_quiesce(ctrl_info);
+		if (rc) {
+			dev_err(&ctrl_info->pci_dev->dev,
+				"PQI reset failed during quiesce with error %d\n",
+				rc);
+			return rc;
+		}
+	}
 
-	writel(reset_params,
-		&ctrl_info->pqi_registers->device_reset);
+	reset_reg.all_bits = 0;
+	reset_reg.bits.reset_type = PQI_RESET_TYPE_HARD_RESET;
+	reset_reg.bits.reset_action = PQI_RESET_ACTION_RESET;
 
-	rc = pqi_wait_for_pqi_mode_ready(ctrl_info);
+	writel(reset_reg.all_bits, &ctrl_info->pqi_registers->device_reset);
+
+	rc = pqi_wait_for_pqi_reset_completion(ctrl_info);
 	if (rc)
 		dev_err(&ctrl_info->pci_dev->dev,
-			"PQI reset failed\n");
+			"PQI reset failed with error %d\n", rc);
 
 	return rc;
 }
* Unmerged path drivers/scsi/smartpqi/smartpqi_sis.c
diff --git a/drivers/scsi/smartpqi/smartpqi_sis.h b/drivers/scsi/smartpqi/smartpqi_sis.h
index 157768d939a9..90fe58d994b5 100644
--- a/drivers/scsi/smartpqi/smartpqi_sis.h
+++ b/drivers/scsi/smartpqi/smartpqi_sis.h
@@ -29,6 +29,7 @@ void sis_enable_msix(struct pqi_ctrl_info *ctrl_info);
 void sis_disable_msix(struct pqi_ctrl_info *ctrl_info);
 void sis_soft_reset(struct pqi_ctrl_info *ctrl_info);
 void sis_shutdown_ctrl(struct pqi_ctrl_info *ctrl_info);
+int sis_pqi_reset_quiesce(struct pqi_ctrl_info *ctrl_info);
 int sis_reenable_sis_mode(struct pqi_ctrl_info *ctrl_info);
 void sis_write_driver_scratch(struct pqi_ctrl_info *ctrl_info, u32 value);
 u32 sis_read_driver_scratch(struct pqi_ctrl_info *ctrl_info);
