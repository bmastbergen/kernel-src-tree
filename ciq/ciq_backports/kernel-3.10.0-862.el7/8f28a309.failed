mlxsw: spectrum_router: Support IPv6 overlay encap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 8f28a3097645ae29a7c6835ed9323d6b6b8db169
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8f28a309.failed

Add the missing bits to recognize IPv6 next hops as IPIP ones to enable
offloading of IPv6 overlay encapsulation.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8f28a3097645ae29a7c6835ed9323d6b6b8db169)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 2055c8543e7b,05afd535805e..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -2600,35 -3626,730 +2600,466 @@@ err_fib4_entry_create
  static void mlxsw_sp_router_fib4_del(struct mlxsw_sp *mlxsw_sp,
  				     struct fib_entry_notifier_info *fen_info)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_fib4_entry *fib4_entry;
+ 	struct mlxsw_sp_fib_node *fib_node;
+ 
+ 	if (mlxsw_sp->router->aborted)
+ 		return;
+ 
+ 	fib4_entry = mlxsw_sp_fib4_entry_lookup(mlxsw_sp, fen_info);
+ 	if (WARN_ON(!fib4_entry))
+ 		return;
+ 	fib_node = fib4_entry->common.fib_node;
+ 
+ 	mlxsw_sp_fib4_node_entry_unlink(mlxsw_sp, fib4_entry);
+ 	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);
+ 	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
+ }
+ 
+ static bool mlxsw_sp_fib6_rt_should_ignore(const struct rt6_info *rt)
+ {
+ 	/* Packets with link-local destination IP arriving to the router
+ 	 * are trapped to the CPU, so no need to program specific routes
+ 	 * for them.
+ 	 */
+ 	if (ipv6_addr_type(&rt->rt6i_dst.addr) & IPV6_ADDR_LINKLOCAL)
+ 		return true;
+ 
+ 	/* Multicast routes aren't supported, so ignore them. Neighbour
+ 	 * Discovery packets are specifically trapped.
+ 	 */
+ 	if (ipv6_addr_type(&rt->rt6i_dst.addr) & IPV6_ADDR_MULTICAST)
+ 		return true;
+ 
+ 	/* Cloned routes are irrelevant in the forwarding path. */
+ 	if (rt->rt6i_flags & RTF_CACHE)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static struct mlxsw_sp_rt6 *mlxsw_sp_rt6_create(struct rt6_info *rt)
+ {
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 
+ 	mlxsw_sp_rt6 = kzalloc(sizeof(*mlxsw_sp_rt6), GFP_KERNEL);
+ 	if (!mlxsw_sp_rt6)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	/* In case of route replace, replaced route is deleted with
+ 	 * no notification. Take reference to prevent accessing freed
+ 	 * memory.
+ 	 */
+ 	mlxsw_sp_rt6->rt = rt;
+ 	rt6_hold(rt);
+ 
+ 	return mlxsw_sp_rt6;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static void mlxsw_sp_rt6_release(struct rt6_info *rt)
+ {
+ 	rt6_release(rt);
+ }
+ #else
+ static void mlxsw_sp_rt6_release(struct rt6_info *rt)
+ {
+ }
+ #endif
+ 
+ static void mlxsw_sp_rt6_destroy(struct mlxsw_sp_rt6 *mlxsw_sp_rt6)
+ {
+ 	mlxsw_sp_rt6_release(mlxsw_sp_rt6->rt);
+ 	kfree(mlxsw_sp_rt6);
+ }
+ 
+ static bool mlxsw_sp_fib6_rt_can_mp(const struct rt6_info *rt)
+ {
+ 	/* RTF_CACHE routes are ignored */
+ 	return (rt->rt6i_flags & (RTF_GATEWAY | RTF_ADDRCONF)) == RTF_GATEWAY;
+ }
+ 
+ static struct rt6_info *
+ mlxsw_sp_fib6_entry_rt(const struct mlxsw_sp_fib6_entry *fib6_entry)
+ {
+ 	return list_first_entry(&fib6_entry->rt6_list, struct mlxsw_sp_rt6,
+ 				list)->rt;
+ }
+ 
+ static struct mlxsw_sp_fib6_entry *
+ mlxsw_sp_fib6_node_mp_entry_find(const struct mlxsw_sp_fib_node *fib_node,
+ 				 const struct rt6_info *nrt, bool replace)
+ {
+ 	struct mlxsw_sp_fib6_entry *fib6_entry;
+ 
+ 	if (!mlxsw_sp_fib6_rt_can_mp(nrt) || replace)
+ 		return NULL;
+ 
+ 	list_for_each_entry(fib6_entry, &fib_node->entry_list, common.list) {
+ 		struct rt6_info *rt = mlxsw_sp_fib6_entry_rt(fib6_entry);
+ 
+ 		/* RT6_TABLE_LOCAL and RT6_TABLE_MAIN share the same
+ 		 * virtual router.
+ 		 */
+ 		if (rt->rt6i_table->tb6_id > nrt->rt6i_table->tb6_id)
+ 			continue;
+ 		if (rt->rt6i_table->tb6_id != nrt->rt6i_table->tb6_id)
+ 			break;
+ 		if (rt->rt6i_metric < nrt->rt6i_metric)
+ 			continue;
+ 		if (rt->rt6i_metric == nrt->rt6i_metric &&
+ 		    mlxsw_sp_fib6_rt_can_mp(rt))
+ 			return fib6_entry;
+ 		if (rt->rt6i_metric > nrt->rt6i_metric)
+ 			break;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static struct mlxsw_sp_rt6 *
+ mlxsw_sp_fib6_entry_rt_find(const struct mlxsw_sp_fib6_entry *fib6_entry,
+ 			    const struct rt6_info *rt)
+ {
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 
+ 	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {
+ 		if (mlxsw_sp_rt6->rt == rt)
+ 			return mlxsw_sp_rt6;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static bool mlxsw_sp_nexthop6_ipip_type(const struct mlxsw_sp *mlxsw_sp,
+ 					const struct rt6_info *rt,
+ 					enum mlxsw_sp_ipip_type *ret)
+ {
+ 	return rt->dst.dev &&
+ 	       mlxsw_sp_netdev_ipip_type(mlxsw_sp, rt->dst.dev, ret);
+ }
+ 
+ static int mlxsw_sp_nexthop6_type_init(struct mlxsw_sp *mlxsw_sp,
+ 				       struct mlxsw_sp_nexthop_group *nh_grp,
+ 				       struct mlxsw_sp_nexthop *nh,
+ 				       const struct rt6_info *rt)
+ {
+ 	struct mlxsw_sp_router *router = mlxsw_sp->router;
+ 	struct net_device *dev = rt->dst.dev;
+ 	enum mlxsw_sp_ipip_type ipipt;
+ 	struct mlxsw_sp_rif *rif;
+ 	int err;
+ 
+ 	if (mlxsw_sp_nexthop6_ipip_type(mlxsw_sp, rt, &ipipt) &&
+ 	    router->ipip_ops_arr[ipipt]->can_offload(mlxsw_sp, dev,
+ 						     MLXSW_SP_L3_PROTO_IPV6)) {
+ 		nh->type = MLXSW_SP_NEXTHOP_TYPE_IPIP;
+ 		return mlxsw_sp_nexthop_ipip_init(mlxsw_sp, ipipt, nh, dev);
+ 	}
+ 
+ 	nh->type = MLXSW_SP_NEXTHOP_TYPE_ETH;
+ 	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);
+ 	if (!rif)
+ 		return 0;
+ 	mlxsw_sp_nexthop_rif_init(nh, rif);
+ 
+ 	err = mlxsw_sp_nexthop_neigh_init(mlxsw_sp, nh);
+ 	if (err)
+ 		goto err_nexthop_neigh_init;
+ 
+ 	return 0;
+ 
+ err_nexthop_neigh_init:
+ 	mlxsw_sp_nexthop_rif_fini(nh);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_nexthop6_type_fini(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_nexthop *nh)
+ {
+ 	mlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);
+ }
+ 
+ static int mlxsw_sp_nexthop6_init(struct mlxsw_sp *mlxsw_sp,
+ 				  struct mlxsw_sp_nexthop_group *nh_grp,
+ 				  struct mlxsw_sp_nexthop *nh,
+ 				  const struct rt6_info *rt)
+ {
+ 	struct net_device *dev = rt->dst.dev;
+ 
+ 	nh->nh_grp = nh_grp;
+ 	memcpy(&nh->gw_addr, &rt->rt6i_gateway, sizeof(nh->gw_addr));
+ 
+ 	if (!dev)
+ 		return 0;
+ 	nh->ifindex = dev->ifindex;
+ 
+ 	return mlxsw_sp_nexthop6_type_init(mlxsw_sp, nh_grp, nh, rt);
+ }
+ 
+ static void mlxsw_sp_nexthop6_fini(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_nexthop *nh)
+ {
+ 	mlxsw_sp_nexthop6_type_fini(mlxsw_sp, nh);
+ }
+ 
+ static bool mlxsw_sp_rt6_is_gateway(const struct mlxsw_sp *mlxsw_sp,
+ 				    const struct rt6_info *rt)
+ {
+ 	return rt->rt6i_flags & RTF_GATEWAY ||
+ 	       mlxsw_sp_nexthop6_ipip_type(mlxsw_sp, rt, NULL);
+ }
+ 
+ static struct mlxsw_sp_nexthop_group *
+ mlxsw_sp_nexthop6_group_create(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_fib6_entry *fib6_entry)
+ {
+ 	struct mlxsw_sp_nexthop_group *nh_grp;
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 	struct mlxsw_sp_nexthop *nh;
+ 	size_t alloc_size;
+ 	int i = 0;
+ 	int err;
+ 
+ 	alloc_size = sizeof(*nh_grp) +
+ 		     fib6_entry->nrt6 * sizeof(struct mlxsw_sp_nexthop);
+ 	nh_grp = kzalloc(alloc_size, GFP_KERNEL);
+ 	if (!nh_grp)
+ 		return ERR_PTR(-ENOMEM);
+ 	INIT_LIST_HEAD(&nh_grp->fib_list);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	nh_grp->neigh_tbl = &nd_tbl;
+ #endif
+ 	mlxsw_sp_rt6 = list_first_entry(&fib6_entry->rt6_list,
+ 					struct mlxsw_sp_rt6, list);
+ 	nh_grp->gateway = mlxsw_sp_rt6_is_gateway(mlxsw_sp, mlxsw_sp_rt6->rt);
+ 	nh_grp->count = fib6_entry->nrt6;
+ 	for (i = 0; i < nh_grp->count; i++) {
+ 		struct rt6_info *rt = mlxsw_sp_rt6->rt;
+ 
+ 		nh = &nh_grp->nexthops[i];
+ 		err = mlxsw_sp_nexthop6_init(mlxsw_sp, nh_grp, nh, rt);
+ 		if (err)
+ 			goto err_nexthop6_init;
+ 		mlxsw_sp_rt6 = list_next_entry(mlxsw_sp_rt6, list);
+ 	}
+ 
+ 	err = mlxsw_sp_nexthop_group_insert(mlxsw_sp, nh_grp);
+ 	if (err)
+ 		goto err_nexthop_group_insert;
+ 
+ 	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);
+ 	return nh_grp;
+ 
+ err_nexthop_group_insert:
+ err_nexthop6_init:
+ 	for (i--; i >= 0; i--) {
+ 		nh = &nh_grp->nexthops[i];
+ 		mlxsw_sp_nexthop6_fini(mlxsw_sp, nh);
+ 	}
+ 	kfree(nh_grp);
+ 	return ERR_PTR(err);
+ }
+ 
+ static void
+ mlxsw_sp_nexthop6_group_destroy(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_nexthop_group *nh_grp)
+ {
+ 	struct mlxsw_sp_nexthop *nh;
+ 	int i = nh_grp->count;
+ 
+ 	mlxsw_sp_nexthop_group_remove(mlxsw_sp, nh_grp);
+ 	for (i--; i >= 0; i--) {
+ 		nh = &nh_grp->nexthops[i];
+ 		mlxsw_sp_nexthop6_fini(mlxsw_sp, nh);
+ 	}
+ 	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);
+ 	WARN_ON(nh_grp->adj_index_valid);
+ 	kfree(nh_grp);
+ }
+ 
+ static int mlxsw_sp_nexthop6_group_get(struct mlxsw_sp *mlxsw_sp,
+ 				       struct mlxsw_sp_fib6_entry *fib6_entry)
+ {
+ 	struct mlxsw_sp_nexthop_group *nh_grp;
+ 
+ 	nh_grp = mlxsw_sp_nexthop6_group_lookup(mlxsw_sp, fib6_entry);
+ 	if (!nh_grp) {
+ 		nh_grp = mlxsw_sp_nexthop6_group_create(mlxsw_sp, fib6_entry);
+ 		if (IS_ERR(nh_grp))
+ 			return PTR_ERR(nh_grp);
+ 	}
+ 
+ 	list_add_tail(&fib6_entry->common.nexthop_group_node,
+ 		      &nh_grp->fib_list);
+ 	fib6_entry->common.nh_group = nh_grp;
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_nexthop6_group_put(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_fib_entry *fib_entry)
+ {
+ 	struct mlxsw_sp_nexthop_group *nh_grp = fib_entry->nh_group;
+ 
+ 	list_del(&fib_entry->nexthop_group_node);
+ 	if (!list_empty(&nh_grp->fib_list))
+ 		return;
+ 	mlxsw_sp_nexthop6_group_destroy(mlxsw_sp, nh_grp);
+ }
+ 
+ static int
+ mlxsw_sp_nexthop6_group_update(struct mlxsw_sp *mlxsw_sp,
+ 			       struct mlxsw_sp_fib6_entry *fib6_entry)
+ {
+ 	struct mlxsw_sp_nexthop_group *old_nh_grp = fib6_entry->common.nh_group;
+ 	int err;
+ 
+ 	fib6_entry->common.nh_group = NULL;
+ 	list_del(&fib6_entry->common.nexthop_group_node);
+ 
+ 	err = mlxsw_sp_nexthop6_group_get(mlxsw_sp, fib6_entry);
+ 	if (err)
+ 		goto err_nexthop6_group_get;
+ 
+ 	/* In case this entry is offloaded, then the adjacency index
+ 	 * currently associated with it in the device's table is that
+ 	 * of the old group. Start using the new one instead.
+ 	 */
+ 	err = mlxsw_sp_fib_node_entry_add(mlxsw_sp, &fib6_entry->common);
+ 	if (err)
+ 		goto err_fib_node_entry_add;
+ 
+ 	if (list_empty(&old_nh_grp->fib_list))
+ 		mlxsw_sp_nexthop6_group_destroy(mlxsw_sp, old_nh_grp);
+ 
+ 	return 0;
+ 
+ err_fib_node_entry_add:
+ 	mlxsw_sp_nexthop6_group_put(mlxsw_sp, &fib6_entry->common);
+ err_nexthop6_group_get:
+ 	list_add_tail(&fib6_entry->common.nexthop_group_node,
+ 		      &old_nh_grp->fib_list);
+ 	fib6_entry->common.nh_group = old_nh_grp;
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_fib6_entry_nexthop_add(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_fib6_entry *fib6_entry,
+ 				struct rt6_info *rt)
+ {
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 	int err;
+ 
+ 	mlxsw_sp_rt6 = mlxsw_sp_rt6_create(rt);
+ 	if (IS_ERR(mlxsw_sp_rt6))
+ 		return PTR_ERR(mlxsw_sp_rt6);
+ 
+ 	list_add_tail(&mlxsw_sp_rt6->list, &fib6_entry->rt6_list);
+ 	fib6_entry->nrt6++;
+ 
+ 	err = mlxsw_sp_nexthop6_group_update(mlxsw_sp, fib6_entry);
+ 	if (err)
+ 		goto err_nexthop6_group_update;
+ 
+ 	return 0;
+ 
+ err_nexthop6_group_update:
+ 	fib6_entry->nrt6--;
+ 	list_del(&mlxsw_sp_rt6->list);
+ 	mlxsw_sp_rt6_destroy(mlxsw_sp_rt6);
+ 	return err;
+ }
+ 
+ static void
+ mlxsw_sp_fib6_entry_nexthop_del(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_fib6_entry *fib6_entry,
+ 				struct rt6_info *rt)
+ {
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 
+ 	mlxsw_sp_rt6 = mlxsw_sp_fib6_entry_rt_find(fib6_entry, rt);
+ 	if (WARN_ON(!mlxsw_sp_rt6))
+ 		return;
+ 
+ 	fib6_entry->nrt6--;
+ 	list_del(&mlxsw_sp_rt6->list);
+ 	mlxsw_sp_nexthop6_group_update(mlxsw_sp, fib6_entry);
+ 	mlxsw_sp_rt6_destroy(mlxsw_sp_rt6);
+ }
+ 
+ static void mlxsw_sp_fib6_entry_type_set(struct mlxsw_sp *mlxsw_sp,
+ 					 struct mlxsw_sp_fib_entry *fib_entry,
+ 					 const struct rt6_info *rt)
+ {
+ 	/* Packets hitting RTF_REJECT routes need to be discarded by the
+ 	 * stack. We can rely on their destination device not having a
+ 	 * RIF (it's the loopback device) and can thus use action type
+ 	 * local, which will cause them to be trapped with a lower
+ 	 * priority than packets that need to be locally received.
+ 	 */
+ 	if (rt->rt6i_flags & (RTF_LOCAL | RTF_ANYCAST))
+ 		fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;
+ 	else if (rt->rt6i_flags & RTF_REJECT)
+ 		fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_LOCAL;
+ 	else if (mlxsw_sp_rt6_is_gateway(mlxsw_sp, rt))
+ 		fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_REMOTE;
+ 	else
+ 		fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_LOCAL;
+ }
+ 
+ static void
+ mlxsw_sp_fib6_entry_rt_destroy_all(struct mlxsw_sp_fib6_entry *fib6_entry)
+ {
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6, *tmp;
+ 
+ 	list_for_each_entry_safe(mlxsw_sp_rt6, tmp, &fib6_entry->rt6_list,
+ 				 list) {
+ 		fib6_entry->nrt6--;
+ 		list_del(&mlxsw_sp_rt6->list);
+ 		mlxsw_sp_rt6_destroy(mlxsw_sp_rt6);
+ 	}
+ }
+ 
+ static struct mlxsw_sp_fib6_entry *
+ mlxsw_sp_fib6_entry_create(struct mlxsw_sp *mlxsw_sp,
+ 			   struct mlxsw_sp_fib_node *fib_node,
+ 			   struct rt6_info *rt)
+ {
+ 	struct mlxsw_sp_fib6_entry *fib6_entry;
++>>>>>>> 8f28a3097645 (mlxsw: spectrum_router: Support IPv6 overlay encap)
  	struct mlxsw_sp_fib_entry *fib_entry;
 -	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
 -	int err;
 +	struct mlxsw_sp_fib_node *fib_node;
  
 -	fib6_entry = kzalloc(sizeof(*fib6_entry), GFP_KERNEL);
 -	if (!fib6_entry)
 -		return ERR_PTR(-ENOMEM);
 -	fib_entry = &fib6_entry->common;
 +	if (mlxsw_sp->router.aborted)
 +		return;
  
 -	mlxsw_sp_rt6 = mlxsw_sp_rt6_create(rt);
 -	if (IS_ERR(mlxsw_sp_rt6)) {
 -		err = PTR_ERR(mlxsw_sp_rt6);
 -		goto err_rt6_create;
 -	}
 +	fib_entry = mlxsw_sp_fib4_entry_lookup(mlxsw_sp, fen_info);
 +	if (WARN_ON(!fib_entry))
 +		return;
 +	fib_node = fib_entry->fib_node;
  
 -	mlxsw_sp_fib6_entry_type_set(mlxsw_sp, fib_entry, mlxsw_sp_rt6->rt);
 +	mlxsw_sp_fib4_node_entry_unlink(mlxsw_sp, fib_entry);
 +	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib_entry);
 +	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 +}
  
 -	INIT_LIST_HEAD(&fib6_entry->rt6_list);
 -	list_add_tail(&mlxsw_sp_rt6->list, &fib6_entry->rt6_list);
 -	fib6_entry->nrt6 = 1;
 -	err = mlxsw_sp_nexthop6_group_get(mlxsw_sp, fib6_entry);
 +static int mlxsw_sp_router_set_abort_trap(struct mlxsw_sp *mlxsw_sp)
 +{
 +	char ralta_pl[MLXSW_REG_RALTA_LEN];
 +	char ralst_pl[MLXSW_REG_RALST_LEN];
 +	int i, err;
 +
 +	mlxsw_reg_ralta_pack(ralta_pl, true, MLXSW_REG_RALXX_PROTOCOL_IPV4,
 +			     MLXSW_SP_LPM_TREE_MIN);
 +	err = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralta), ralta_pl);
  	if (err)
 -		goto err_nexthop6_group_get;
 +		return err;
  
 -	fib_entry->fib_node = fib_node;
 -
 -	return fib6_entry;
 -
 -err_nexthop6_group_get:
 -	list_del(&mlxsw_sp_rt6->list);
 -	mlxsw_sp_rt6_destroy(mlxsw_sp_rt6);
 -err_rt6_create:
 -	kfree(fib6_entry);
 -	return ERR_PTR(err);
 -}
 -
 -static void mlxsw_sp_fib6_entry_destroy(struct mlxsw_sp *mlxsw_sp,
 -					struct mlxsw_sp_fib6_entry *fib6_entry)
 -{
 -	mlxsw_sp_nexthop6_group_put(mlxsw_sp, &fib6_entry->common);
 -	mlxsw_sp_fib6_entry_rt_destroy_all(fib6_entry);
 -	WARN_ON(fib6_entry->nrt6);
 -	kfree(fib6_entry);
 -}
 -
 -static struct mlxsw_sp_fib6_entry *
 -mlxsw_sp_fib6_node_entry_find(const struct mlxsw_sp_fib_node *fib_node,
 -			      const struct rt6_info *nrt, bool replace)
 -{
 -	struct mlxsw_sp_fib6_entry *fib6_entry, *fallback = NULL;
 -
 -	list_for_each_entry(fib6_entry, &fib_node->entry_list, common.list) {
 -		struct rt6_info *rt = mlxsw_sp_fib6_entry_rt(fib6_entry);
 -
 -		if (rt->rt6i_table->tb6_id > nrt->rt6i_table->tb6_id)
 -			continue;
 -		if (rt->rt6i_table->tb6_id != nrt->rt6i_table->tb6_id)
 -			break;
 -		if (replace && rt->rt6i_metric == nrt->rt6i_metric) {
 -			if (mlxsw_sp_fib6_rt_can_mp(rt) ==
 -			    mlxsw_sp_fib6_rt_can_mp(nrt))
 -				return fib6_entry;
 -			if (mlxsw_sp_fib6_rt_can_mp(nrt))
 -				fallback = fallback ?: fib6_entry;
 -		}
 -		if (rt->rt6i_metric > nrt->rt6i_metric)
 -			return fallback ?: fib6_entry;
 -	}
 -
 -	return fallback;
 -}
 -
 -static int
 -mlxsw_sp_fib6_node_list_insert(struct mlxsw_sp_fib6_entry *new6_entry,
 -			       bool replace)
 -{
 -	struct mlxsw_sp_fib_node *fib_node = new6_entry->common.fib_node;
 -	struct rt6_info *nrt = mlxsw_sp_fib6_entry_rt(new6_entry);
 -	struct mlxsw_sp_fib6_entry *fib6_entry;
 -
 -	fib6_entry = mlxsw_sp_fib6_node_entry_find(fib_node, nrt, replace);
 -
 -	if (replace && WARN_ON(!fib6_entry))
 -		return -EINVAL;
 -
 -	if (fib6_entry) {
 -		list_add_tail(&new6_entry->common.list,
 -			      &fib6_entry->common.list);
 -	} else {
 -		struct mlxsw_sp_fib6_entry *last;
 -
 -		list_for_each_entry(last, &fib_node->entry_list, common.list) {
 -			struct rt6_info *rt = mlxsw_sp_fib6_entry_rt(last);
 -
 -			if (nrt->rt6i_table->tb6_id > rt->rt6i_table->tb6_id)
 -				break;
 -			fib6_entry = last;
 -		}
 -
 -		if (fib6_entry)
 -			list_add(&new6_entry->common.list,
 -				 &fib6_entry->common.list);
 -		else
 -			list_add(&new6_entry->common.list,
 -				 &fib_node->entry_list);
 -	}
 -
 -	return 0;
 -}
 -
 -static void
 -mlxsw_sp_fib6_node_list_remove(struct mlxsw_sp_fib6_entry *fib6_entry)
 -{
 -	list_del(&fib6_entry->common.list);
 -}
 -
 -static int mlxsw_sp_fib6_node_entry_link(struct mlxsw_sp *mlxsw_sp,
 -					 struct mlxsw_sp_fib6_entry *fib6_entry,
 -					 bool replace)
 -{
 -	int err;
 -
 -	err = mlxsw_sp_fib6_node_list_insert(fib6_entry, replace);
 -	if (err)
 -		return err;
 -
 -	err = mlxsw_sp_fib_node_entry_add(mlxsw_sp, &fib6_entry->common);
 -	if (err)
 -		goto err_fib_node_entry_add;
 -
 -	return 0;
 -
 -err_fib_node_entry_add:
 -	mlxsw_sp_fib6_node_list_remove(fib6_entry);
 -	return err;
 -}
 -
 -static void
 -mlxsw_sp_fib6_node_entry_unlink(struct mlxsw_sp *mlxsw_sp,
 -				struct mlxsw_sp_fib6_entry *fib6_entry)
 -{
 -	mlxsw_sp_fib_node_entry_del(mlxsw_sp, &fib6_entry->common);
 -	mlxsw_sp_fib6_node_list_remove(fib6_entry);
 -}
 -
 -static struct mlxsw_sp_fib6_entry *
 -mlxsw_sp_fib6_entry_lookup(struct mlxsw_sp *mlxsw_sp,
 -			   const struct rt6_info *rt)
 -{
 -	struct mlxsw_sp_fib6_entry *fib6_entry;
 -	struct mlxsw_sp_fib_node *fib_node;
 -	struct mlxsw_sp_fib *fib;
 -	struct mlxsw_sp_vr *vr;
 -
 -	vr = mlxsw_sp_vr_find(mlxsw_sp, rt->rt6i_table->tb6_id);
 -	if (!vr)
 -		return NULL;
 -	fib = mlxsw_sp_vr_fib(vr, MLXSW_SP_L3_PROTO_IPV6);
 -
 -	fib_node = mlxsw_sp_fib_node_lookup(fib, &rt->rt6i_dst.addr,
 -					    sizeof(rt->rt6i_dst.addr),
 -					    rt->rt6i_dst.plen);
 -	if (!fib_node)
 -		return NULL;
 -
 -	list_for_each_entry(fib6_entry, &fib_node->entry_list, common.list) {
 -		struct rt6_info *iter_rt = mlxsw_sp_fib6_entry_rt(fib6_entry);
 -
 -		if (rt->rt6i_table->tb6_id == iter_rt->rt6i_table->tb6_id &&
 -		    rt->rt6i_metric == iter_rt->rt6i_metric &&
 -		    mlxsw_sp_fib6_entry_rt_find(fib6_entry, rt))
 -			return fib6_entry;
 -	}
 -
 -	return NULL;
 -}
 -
 -static void mlxsw_sp_fib6_entry_replace(struct mlxsw_sp *mlxsw_sp,
 -					struct mlxsw_sp_fib6_entry *fib6_entry,
 -					bool replace)
 -{
 -	struct mlxsw_sp_fib_node *fib_node = fib6_entry->common.fib_node;
 -	struct mlxsw_sp_fib6_entry *replaced;
 -
 -	if (!replace)
 -		return;
 -
 -	replaced = list_next_entry(fib6_entry, common.list);
 -
 -	mlxsw_sp_fib6_node_entry_unlink(mlxsw_sp, replaced);
 -	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, replaced);
 -	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 -}
 -
 -static int mlxsw_sp_router_fib6_add(struct mlxsw_sp *mlxsw_sp,
 -				    struct rt6_info *rt, bool replace)
 -{
 -	struct mlxsw_sp_fib6_entry *fib6_entry;
 -	struct mlxsw_sp_fib_node *fib_node;
 -	int err;
 -
 -	if (mlxsw_sp->router->aborted)
 -		return 0;
 -
 -	if (rt->rt6i_src.plen)
 -		return -EINVAL;
 -
 -	if (mlxsw_sp_fib6_rt_should_ignore(rt))
 -		return 0;
 -
 -	fib_node = mlxsw_sp_fib_node_get(mlxsw_sp, rt->rt6i_table->tb6_id,
 -					 &rt->rt6i_dst.addr,
 -					 sizeof(rt->rt6i_dst.addr),
 -					 rt->rt6i_dst.plen,
 -					 MLXSW_SP_L3_PROTO_IPV6);
 -	if (IS_ERR(fib_node))
 -		return PTR_ERR(fib_node);
 -
 -	/* Before creating a new entry, try to append route to an existing
 -	 * multipath entry.
 -	 */
 -	fib6_entry = mlxsw_sp_fib6_node_mp_entry_find(fib_node, rt, replace);
 -	if (fib6_entry) {
 -		err = mlxsw_sp_fib6_entry_nexthop_add(mlxsw_sp, fib6_entry, rt);
 -		if (err)
 -			goto err_fib6_entry_nexthop_add;
 -		return 0;
 -	}
 -
 -	fib6_entry = mlxsw_sp_fib6_entry_create(mlxsw_sp, fib_node, rt);
 -	if (IS_ERR(fib6_entry)) {
 -		err = PTR_ERR(fib6_entry);
 -		goto err_fib6_entry_create;
 -	}
 -
 -	err = mlxsw_sp_fib6_node_entry_link(mlxsw_sp, fib6_entry, replace);
 -	if (err)
 -		goto err_fib6_node_entry_link;
 -
 -	mlxsw_sp_fib6_entry_replace(mlxsw_sp, fib6_entry, replace);
 -
 -	return 0;
 -
 -err_fib6_node_entry_link:
 -	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
 -err_fib6_entry_create:
 -err_fib6_entry_nexthop_add:
 -	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 -	return err;
 -}
 -
 -static void mlxsw_sp_router_fib6_del(struct mlxsw_sp *mlxsw_sp,
 -				     struct rt6_info *rt)
 -{
 -	struct mlxsw_sp_fib6_entry *fib6_entry;
 -	struct mlxsw_sp_fib_node *fib_node;
 -
 -	if (mlxsw_sp->router->aborted)
 -		return;
 -
 -	if (mlxsw_sp_fib6_rt_should_ignore(rt))
 -		return;
 -
 -	fib6_entry = mlxsw_sp_fib6_entry_lookup(mlxsw_sp, rt);
 -	if (WARN_ON(!fib6_entry))
 -		return;
 -
 -	/* If route is part of a multipath entry, but not the last one
 -	 * removed, then only reduce its nexthop group.
 -	 */
 -	if (!list_is_singular(&fib6_entry->rt6_list)) {
 -		mlxsw_sp_fib6_entry_nexthop_del(mlxsw_sp, fib6_entry, rt);
 -		return;
 -	}
 -
 -	fib_node = fib6_entry->common.fib_node;
 -
 -	mlxsw_sp_fib6_node_entry_unlink(mlxsw_sp, fib6_entry);
 -	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
 -	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 -}
 -
 -static int __mlxsw_sp_router_set_abort_trap(struct mlxsw_sp *mlxsw_sp,
 -					    enum mlxsw_reg_ralxx_protocol proto,
 -					    u8 tree_id)
 -{
 -	char ralta_pl[MLXSW_REG_RALTA_LEN];
 -	char ralst_pl[MLXSW_REG_RALST_LEN];
 -	int i, err;
 -
 -	mlxsw_reg_ralta_pack(ralta_pl, true, proto, tree_id);
 -	err = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralta), ralta_pl);
 -	if (err)
 -		return err;
 -
 -	mlxsw_reg_ralst_pack(ralst_pl, 0xff, tree_id);
 +	mlxsw_reg_ralst_pack(ralst_pl, 0xff, MLXSW_SP_LPM_TREE_MIN);
  	err = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralst), ralst_pl);
  	if (err)
  		return err;
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
