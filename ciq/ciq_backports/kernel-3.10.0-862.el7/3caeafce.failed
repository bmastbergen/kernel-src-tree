perf units: Move parse_tag_value() to units.[ch]

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 3caeafce5392a8eba7b36d0d097d403cacc66e2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3caeafce.failed

Its basically to do units handling, so move to a more appropriately
named object.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-90ob9vfepui24l8l2makhd9u@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 3caeafce5392a8eba7b36d0d097d403cacc66e2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/units.c
#	tools/perf/util/units.h
#	tools/perf/util/util.c
#	tools/perf/util/util.h
diff --cc tools/perf/util/util.c
index dc59646111f8,28c9f335006c..000000000000
--- a/tools/perf/util/util.c
+++ b/tools/perf/util/util.c
@@@ -372,157 -334,6 +372,160 @@@ int hex2u64(const char *ptr, u64 *long_
  	return p - ptr;
  }
  
++<<<<<<< HEAD
 +/* Obtain a backtrace and print it to stdout. */
 +#ifdef HAVE_BACKTRACE_SUPPORT
 +void dump_stack(void)
 +{
 +	void *array[16];
 +	size_t size = backtrace(array, ARRAY_SIZE(array));
 +	char **strings = backtrace_symbols(array, size);
 +	size_t i;
 +
 +	printf("Obtained %zd stack frames.\n", size);
 +
 +	for (i = 0; i < size; i++)
 +		printf("%s\n", strings[i]);
 +
 +	free(strings);
 +}
 +#else
 +void dump_stack(void) {}
 +#endif
 +
 +void sighandler_dump_stack(int sig)
 +{
 +	psignal(sig, "perf");
 +	dump_stack();
 +	signal(sig, SIG_DFL);
 +	raise(sig);
 +}
 +
 +int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz)
 +{
 +	u64  sec = timestamp / NSEC_PER_SEC;
 +	u64 usec = (timestamp % NSEC_PER_SEC) / NSEC_PER_USEC;
 +
 +	return scnprintf(buf, sz, "%"PRIu64".%06"PRIu64, sec, usec);
 +}
 +
 +unsigned long parse_tag_value(const char *str, struct parse_tag *tags)
 +{
 +	struct parse_tag *i = tags;
 +
 +	while (i->tag) {
 +		char *s;
 +
 +		s = strchr(str, i->tag);
 +		if (s) {
 +			unsigned long int value;
 +			char *endptr;
 +
 +			value = strtoul(str, &endptr, 10);
 +			if (s != endptr)
 +				break;
 +
 +			if (value > ULONG_MAX / i->mult)
 +				break;
 +			value *= i->mult;
 +			return value;
 +		}
 +		i++;
 +	}
 +
 +	return (unsigned long) -1;
 +}
 +
 +int get_stack_size(const char *str, unsigned long *_size)
 +{
 +	char *endptr;
 +	unsigned long size;
 +	unsigned long max_size = round_down(USHRT_MAX, sizeof(u64));
 +
 +	size = strtoul(str, &endptr, 0);
 +
 +	do {
 +		if (*endptr)
 +			break;
 +
 +		size = round_up(size, sizeof(u64));
 +		if (!size || size > max_size)
 +			break;
 +
 +		*_size = size;
 +		return 0;
 +
 +	} while (0);
 +
 +	pr_err("callchain: Incorrect stack dump size (max %ld): %s\n",
 +	       max_size, str);
 +	return -1;
 +}
 +
 +int parse_callchain_record(const char *arg, struct callchain_param *param)
 +{
 +	char *tok, *name, *saveptr = NULL;
 +	char *buf;
 +	int ret = -1;
 +
 +	/* We need buffer that we know we can write to. */
 +	buf = malloc(strlen(arg) + 1);
 +	if (!buf)
 +		return -ENOMEM;
 +
 +	strcpy(buf, arg);
 +
 +	tok = strtok_r((char *)buf, ",", &saveptr);
 +	name = tok ? : (char *)buf;
 +
 +	do {
 +		/* Framepointer style */
 +		if (!strncmp(name, "fp", sizeof("fp"))) {
 +			if (!strtok_r(NULL, ",", &saveptr)) {
 +				param->record_mode = CALLCHAIN_FP;
 +				ret = 0;
 +			} else
 +				pr_err("callchain: No more arguments "
 +				       "needed for --call-graph fp\n");
 +			break;
 +
 +		/* Dwarf style */
 +		} else if (!strncmp(name, "dwarf", sizeof("dwarf"))) {
 +			const unsigned long default_stack_dump_size = 8192;
 +
 +			ret = 0;
 +			param->record_mode = CALLCHAIN_DWARF;
 +			param->dump_size = default_stack_dump_size;
 +
 +			tok = strtok_r(NULL, ",", &saveptr);
 +			if (tok) {
 +				unsigned long size = 0;
 +
 +				ret = get_stack_size(tok, &size);
 +				param->dump_size = size;
 +			}
 +		} else if (!strncmp(name, "lbr", sizeof("lbr"))) {
 +			if (!strtok_r(NULL, ",", &saveptr)) {
 +				param->record_mode = CALLCHAIN_LBR;
 +				ret = 0;
 +			} else
 +				pr_err("callchain: No more arguments "
 +					"needed for --call-graph lbr\n");
 +			break;
 +		} else {
 +			pr_err("callchain: Unknown --call-graph option "
 +			       "value: %s\n", arg);
 +			break;
 +		}
 +
 +	} while (0);
 +
 +	free(buf);
 +	return ret;
 +}
 +
++=======
++>>>>>>> 3caeafce5392 (perf units: Move parse_tag_value() to units.[ch])
  int perf_event_paranoid(void)
  {
  	int value;
diff --cc tools/perf/util/util.h
index ab75dd1dcd49,d620719775a8..000000000000
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@@ -105,105 -56,23 +105,108 @@@ void event_attr_init(struct perf_event_
  size_t hex_width(u64 v);
  int hex2u64(const char *ptr, u64 *val);
  
 +char *ltrim(char *s);
 +char *rtrim(char *s);
 +
 +static inline char *trim(char *s)
 +{
 +	return ltrim(rtrim(s));
 +}
 +
 +void dump_stack(void);
 +void sighandler_dump_stack(int sig);
 +
  extern unsigned int page_size;
  extern int cacheline_size;
 +extern unsigned int sysctl_perf_event_max_stack;
 +
++<<<<<<< HEAD
 +struct parse_tag {
 +	char tag;
 +	int mult;
 +};
  
 +unsigned long parse_tag_value(const char *str, struct parse_tag *tags);
 +
 +static inline int path__join(char *bf, size_t size,
 +			     const char *path1, const char *path2)
 +{
 +	return scnprintf(bf, size, "%s%s%s", path1, path1[0] ? "/" : "", path2);
 +}
 +
 +static inline int path__join3(char *bf, size_t size,
 +			      const char *path1, const char *path2,
 +			      const char *path3)
 +{
 +	return scnprintf(bf, size, "%s%s%s%s%s",
 +			 path1, path1[0] ? "/" : "",
 +			 path2, path2[0] ? "/" : "", path3);
 +}
 +
 +int perf_event_paranoid(void);
 +
 +void mem_bswap_64(void *src, int byte_size);
 +void mem_bswap_32(void *src, int byte_size);
 +
++=======
++>>>>>>> 3caeafce5392 (perf units: Move parse_tag_value() to units.[ch])
  bool find_process(const char *name);
  
 -int fetch_kernel_version(unsigned int *puint,
 -			 char *str, size_t str_sz);
 -#define KVER_VERSION(x)		(((x) >> 16) & 0xff)
 -#define KVER_PATCHLEVEL(x)	(((x) >> 8) & 0xff)
 -#define KVER_SUBLEVEL(x)	((x) & 0xff)
 -#define KVER_FMT	"%d.%d.%d"
 -#define KVER_PARAM(x)	KVER_VERSION(x), KVER_PATCHLEVEL(x), KVER_SUBLEVEL(x)
 +#ifdef HAVE_ZLIB_SUPPORT
 +int gzip_decompress_to_file(const char *input, int output_fd);
 +#endif
  
 -const char *perf_tip(const char *dirpath);
 +#ifdef HAVE_LZMA_SUPPORT
 +int lzma_decompress_to_file(const char *input, int output_fd);
 +#endif
 +
 +char *asprintf_expr_inout_ints(const char *var, bool in, size_t nints, int *ints);
 +
 +static inline char *asprintf_expr_in_ints(const char *var, size_t nints, int *ints)
 +{
 +	return asprintf_expr_inout_ints(var, true, nints, ints);
 +}
 +
 +static inline char *asprintf_expr_not_in_ints(const char *var, size_t nints, int *ints)
 +{
 +	return asprintf_expr_inout_ints(var, false, nints, ints);
 +}
 +
 +int get_stack_size(const char *str, unsigned long *_size);
  
 -#ifndef HAVE_SCHED_GETCPU_SUPPORT
 -int sched_getcpu(void);
 +const char *perf_tip(const char *dirpath);
 +bool is_regular_file(const char *file);
 +int fetch_current_timestamp(char *buf, size_t sz);
 +
 +enum binary_printer_ops {
 +	BINARY_PRINT_DATA_BEGIN,
 +	BINARY_PRINT_LINE_BEGIN,
 +	BINARY_PRINT_ADDR,
 +	BINARY_PRINT_NUM_DATA,
 +	BINARY_PRINT_NUM_PAD,
 +	BINARY_PRINT_SEP,
 +	BINARY_PRINT_CHAR_DATA,
 +	BINARY_PRINT_CHAR_PAD,
 +	BINARY_PRINT_LINE_END,
 +	BINARY_PRINT_DATA_END,
 +};
 +
 +typedef void (*print_binary_t)(enum binary_printer_ops,
 +			       unsigned int val,
 +			       void *extra);
 +
 +void print_binary(unsigned char *data, size_t len,
 +		  size_t bytes_per_line, print_binary_t printer,
 +		  void *extra);
 +
 +#if !defined(__GLIBC__) && !defined(__ANDROID__)
 +extern int sched_getcpu(void);
  #endif
  
 +int is_printable_array(char *p, unsigned int len);
 +
 +int timestamp__scnprintf_usec(u64 timestamp, char *buf, size_t sz);
 +
 +int unit_number__scnprintf(char *buf, size_t size, u64 n);
 +
  #endif /* GIT_COMPAT_UTIL_H */
* Unmerged path tools/perf/util/units.c
* Unmerged path tools/perf/util/units.h
* Unmerged path tools/perf/util/units.c
* Unmerged path tools/perf/util/units.h
* Unmerged path tools/perf/util/util.c
* Unmerged path tools/perf/util/util.h
