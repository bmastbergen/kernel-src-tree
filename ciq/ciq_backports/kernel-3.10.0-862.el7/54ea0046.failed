libceph, rbd, ceph: WRITE | ONDISK -> WRITE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 54ea0046b6fe36ec18e82d282a29a18da6cdea0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/54ea0046.failed

CEPH_OSD_FLAG_ONDISK is set in account_request().

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Reviewed-by: Sage Weil <sage@redhat.com>
(cherry picked from commit 54ea0046b6fe36ec18e82d282a29a18da6cdea0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index b73b90551b4e,695ef552aaf0..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -2003,35 -1979,9 +2003,41 @@@ static struct ceph_osd_request *rbd_osd
  
  	rbd_assert(num_ops == 1 || ((op_type == OBJ_OP_WRITE) && num_ops == 2));
  
++<<<<<<< HEAD
 +	/* Allocate and initialize the request, for the num_ops ops */
 +
 +	osdc = &rbd_dev->rbd_client->client->osdc;
 +	osd_req = ceph_osdc_alloc_request(osdc, snapc, num_ops, false,
 +					  GFP_NOIO);
 +	if (!osd_req)
 +		goto fail;
 +
 +	if (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD)
 +		osd_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
 +	else
 +		osd_req->r_flags = CEPH_OSD_FLAG_READ;
 +
 +	osd_req->r_callback = rbd_osd_req_callback;
 +	osd_req->r_priv = obj_request;
 +
 +	osd_req->r_base_oloc.pool = ceph_file_layout_pg_pool(rbd_dev->layout);
 +	if (ceph_oid_aprintf(&osd_req->r_base_oid, GFP_NOIO, "%s",
 +			     obj_request->object_name))
 +		goto fail;
 +
 +	if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
 +		goto fail;
 +
 +	return osd_req;
 +
 +fail:
 +	ceph_osdc_put_request(osd_req);
 +	return NULL;
++=======
+ 	return __rbd_osd_req_create(rbd_dev, snapc, num_ops,
+ 	    (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD) ?
+ 	    CEPH_OSD_FLAG_WRITE : CEPH_OSD_FLAG_READ, obj_request);
++>>>>>>> 54ea0046b6fe (libceph, rbd, ceph: WRITE | ONDISK -> WRITE)
  }
  
  /*
@@@ -2059,36 -2005,11 +2065,42 @@@ rbd_osd_req_create_copyup(struct rbd_ob
  	if (img_request_discard_test(img_request))
  		num_osd_ops = 2;
  
++<<<<<<< HEAD
 +	/* Allocate and initialize the request, for all the ops */
 +
 +	snapc = img_request->snapc;
 +	rbd_dev = img_request->rbd_dev;
 +	osdc = &rbd_dev->rbd_client->client->osdc;
 +	osd_req = ceph_osdc_alloc_request(osdc, snapc, num_osd_ops,
 +						false, GFP_NOIO);
 +	if (!osd_req)
 +		goto fail;
 +
 +	osd_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
 +	osd_req->r_callback = rbd_osd_req_callback;
 +	osd_req->r_priv = obj_request;
 +
 +	osd_req->r_base_oloc.pool = ceph_file_layout_pg_pool(rbd_dev->layout);
 +	if (ceph_oid_aprintf(&osd_req->r_base_oid, GFP_NOIO, "%s",
 +			     obj_request->object_name))
 +		goto fail;
 +
 +	if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
 +		goto fail;
 +
 +	return osd_req;
 +
 +fail:
 +	ceph_osdc_put_request(osd_req);
 +	return NULL;
++=======
+ 	return __rbd_osd_req_create(img_request->rbd_dev,
+ 				    img_request->snapc, num_osd_ops,
+ 				    CEPH_OSD_FLAG_WRITE, obj_request);
++>>>>>>> 54ea0046b6fe (libceph, rbd, ceph: WRITE | ONDISK -> WRITE)
  }
  
 +
  static void rbd_osd_req_destroy(struct ceph_osd_request *osd_req)
  {
  	ceph_osdc_put_request(osd_req);
* Unmerged path drivers/block/rbd.c
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index 88cb6aaae4e2..d07cdc81d1ac 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -953,8 +953,7 @@ new_request:
 					&ci->i_layout, vino,
 					offset, &len, 0, num_ops,
 					CEPH_OSD_OP_WRITE,
-					CEPH_OSD_FLAG_WRITE |
-					CEPH_OSD_FLAG_ONDISK,
+					CEPH_OSD_FLAG_WRITE,
 					snapc, truncate_seq,
 					truncate_size, false);
 		if (IS_ERR(req)) {
@@ -964,8 +963,7 @@ new_request:
 						min(num_ops,
 						    CEPH_OSD_SLAB_OPS),
 						CEPH_OSD_OP_WRITE,
-						CEPH_OSD_FLAG_WRITE |
-						CEPH_OSD_FLAG_ONDISK,
+						CEPH_OSD_FLAG_WRITE,
 						snapc, truncate_seq,
 						truncate_size, true);
 			BUG_ON(IS_ERR(req));
@@ -1601,8 +1599,7 @@ int ceph_uninline_data(struct file *filp, struct page *locked_page)
 
 	req = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,
 				    ceph_vino(inode), 0, &len, 0, 1,
-				    CEPH_OSD_OP_CREATE,
-				    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,
+				    CEPH_OSD_OP_CREATE, CEPH_OSD_FLAG_WRITE,
 				    NULL, 0, 0, false);
 	if (IS_ERR(req)) {
 		err = PTR_ERR(req);
@@ -1619,8 +1616,7 @@ int ceph_uninline_data(struct file *filp, struct page *locked_page)
 
 	req = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,
 				    ceph_vino(inode), 0, &len, 1, 3,
-				    CEPH_OSD_OP_WRITE,
-				    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,
+				    CEPH_OSD_OP_WRITE, CEPH_OSD_FLAG_WRITE,
 				    NULL, ci->i_truncate_seq,
 				    ci->i_truncate_size, false);
 	if (IS_ERR(req)) {
@@ -1767,7 +1763,7 @@ static int __ceph_pool_perm_get(struct ceph_inode_info *ci, u32 pool)
 		goto out_unlock;
 	}
 
-	wr_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
+	wr_req->r_flags = CEPH_OSD_FLAG_WRITE;
 	osd_req_op_init(wr_req, 0, CEPH_OSD_OP_CREATE, CEPH_OSD_OP_FLAG_EXCL);
 	ceph_oloc_copy(&wr_req->r_base_oloc, &rd_req->r_base_oloc);
 	ceph_oid_copy(&wr_req->r_base_oid, &rd_req->r_base_oid);
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index 7308253a72e7..408875b23be8 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -759,9 +759,7 @@ static void ceph_aio_retry_work(struct work_struct *work)
 		goto out;
 	}
 
-	req->r_flags =	CEPH_OSD_FLAG_ORDERSNAP |
-			CEPH_OSD_FLAG_ONDISK |
-			CEPH_OSD_FLAG_WRITE;
+	req->r_flags = CEPH_OSD_FLAG_ORDERSNAP | CEPH_OSD_FLAG_WRITE;
 	ceph_oloc_copy(&req->r_base_oloc, &orig_req->r_base_oloc);
 	ceph_oid_copy(&req->r_base_oid, &orig_req->r_base_oid);
 
@@ -833,9 +831,7 @@ ceph_direct_read_write(struct kiocb *iocb, struct iov_iter *iter,
 		if (ret < 0)
 			dout("invalidate_inode_pages2_range returned %d\n", ret);
 
-		flags = CEPH_OSD_FLAG_ORDERSNAP |
-			CEPH_OSD_FLAG_ONDISK |
-			CEPH_OSD_FLAG_WRITE;
+		flags = CEPH_OSD_FLAG_ORDERSNAP | CEPH_OSD_FLAG_WRITE;
 	} else {
 		flags = CEPH_OSD_FLAG_READ;
 	}
@@ -1035,9 +1031,7 @@ static ssize_t ceph_sync_write(struct kiocb *iocb, struct iov_iter *i,
 	if (ret < 0)
 		dout("invalidate_inode_pages2_range returned %d\n", ret);
 
-	flags = CEPH_OSD_FLAG_ORDERSNAP |
-		CEPH_OSD_FLAG_ONDISK |
-		CEPH_OSD_FLAG_WRITE;
+	flags = CEPH_OSD_FLAG_ORDERSNAP | CEPH_OSD_FLAG_WRITE;
 
 	while ((len = iov_iter_count(i)) > 0) {
 		size_t left;
@@ -1598,8 +1592,7 @@ static int ceph_zero_partial_object(struct inode *inode,
 					ceph_vino(inode),
 					offset, length,
 					0, 1, op,
-					CEPH_OSD_FLAG_WRITE |
-					CEPH_OSD_FLAG_ONDISK,
+					CEPH_OSD_FLAG_WRITE,
 					NULL, 0, 0, false);
 	if (IS_ERR(req)) {
 		ret = PTR_ERR(req);
diff --git a/net/ceph/cls_lock_client.c b/net/ceph/cls_lock_client.c
index f13a1ea87459..b9233b990399 100644
--- a/net/ceph/cls_lock_client.c
+++ b/net/ceph/cls_lock_client.c
@@ -69,8 +69,8 @@ int ceph_cls_lock(struct ceph_osd_client *osdc,
 	dout("%s lock_name %s type %d cookie %s tag %s desc %s flags 0x%x\n",
 	     __func__, lock_name, type, cookie, tag, desc, flags);
 	ret = ceph_osdc_call(osdc, oid, oloc, "lock", "lock",
-			     CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK,
-			     lock_op_page, lock_op_buf_size, NULL, NULL);
+			     CEPH_OSD_FLAG_WRITE, lock_op_page,
+			     lock_op_buf_size, NULL, NULL);
 
 	dout("%s: status %d\n", __func__, ret);
 	__free_page(lock_op_page);
@@ -117,8 +117,8 @@ int ceph_cls_unlock(struct ceph_osd_client *osdc,
 
 	dout("%s lock_name %s cookie %s\n", __func__, lock_name, cookie);
 	ret = ceph_osdc_call(osdc, oid, oloc, "lock", "unlock",
-			     CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK,
-			     unlock_op_page, unlock_op_buf_size, NULL, NULL);
+			     CEPH_OSD_FLAG_WRITE, unlock_op_page,
+			     unlock_op_buf_size, NULL, NULL);
 
 	dout("%s: status %d\n", __func__, ret);
 	__free_page(unlock_op_page);
@@ -170,8 +170,8 @@ int ceph_cls_break_lock(struct ceph_osd_client *osdc,
 	dout("%s lock_name %s cookie %s locker %s%llu\n", __func__, lock_name,
 	     cookie, ENTITY_NAME(*locker));
 	ret = ceph_osdc_call(osdc, oid, oloc, "lock", "break_lock",
-			     CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK,
-			     break_op_page, break_op_buf_size, NULL, NULL);
+			     CEPH_OSD_FLAG_WRITE, break_op_page,
+			     break_op_buf_size, NULL, NULL);
 
 	dout("%s: status %d\n", __func__, ret);
 	__free_page(break_op_page);
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 47e25213ce4c..2ed741950428 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -1690,7 +1690,7 @@ promote:
 
 static void account_request(struct ceph_osd_request *req)
 {
-	WARN_ON(req->r_flags & CEPH_OSD_FLAG_ACK);
+	WARN_ON(req->r_flags & (CEPH_OSD_FLAG_ACK | CEPH_OSD_FLAG_ONDISK));
 	WARN_ON(!(req->r_flags & (CEPH_OSD_FLAG_READ | CEPH_OSD_FLAG_WRITE)));
 
 	req->r_flags |= CEPH_OSD_FLAG_ONDISK;
@@ -3507,7 +3507,7 @@ ceph_osdc_watch(struct ceph_osd_client *osdc,
 
 	ceph_oid_copy(&lreq->t.base_oid, oid);
 	ceph_oloc_copy(&lreq->t.base_oloc, oloc);
-	lreq->t.flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
+	lreq->t.flags = CEPH_OSD_FLAG_WRITE;
 	lreq->mtime = CURRENT_TIME;
 
 	lreq->reg_req = alloc_linger_request(lreq);
@@ -3565,7 +3565,7 @@ int ceph_osdc_unwatch(struct ceph_osd_client *osdc,
 
 	ceph_oid_copy(&req->r_base_oid, &lreq->t.base_oid);
 	ceph_oloc_copy(&req->r_base_oloc, &lreq->t.base_oloc);
-	req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
+	req->r_flags = CEPH_OSD_FLAG_WRITE;
 	req->r_mtime = CURRENT_TIME;
 	osd_req_op_watch_init(req, 0, lreq->linger_id,
 			      CEPH_OSD_WATCH_OP_UNWATCH);
@@ -4131,8 +4131,7 @@ int ceph_osdc_writepages(struct ceph_osd_client *osdc, struct ceph_vino vino,
 	int page_align = off & ~PAGE_MASK;
 
 	req = ceph_osdc_new_request(osdc, layout, vino, off, &len, 0, 1,
-				    CEPH_OSD_OP_WRITE,
-				    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,
+				    CEPH_OSD_OP_WRITE, CEPH_OSD_FLAG_WRITE,
 				    snapc, truncate_seq, truncate_size,
 				    true);
 	if (IS_ERR(req))
