target/qla2xxx: Honor max_data_sg_nents I/O transfer limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 8f9b565482c537821588444e09ff732c7d65ed6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8f9b5654.failed

This patch adds an optional fabric driver provided SGL limit
that target-core will honor as it's own internal I/O maximum
transfer length limit, as exposed by EVPD=0xb0 block limits
parameters.

This is required for handling cases when host I/O transfer
length exceeds the requested EVPD block limits maximum
transfer length. The initial user of this logic is qla2xxx,
so that we can avoid having to reject I/Os from some legacy
FC hosts where EVPD=0xb0 parameters are not honored.

When se_cmd payload length exceeds the provided limit in
target_check_max_data_sg_nents() code, se_cmd->data_length +
se_cmd->prot_length are reset with se_cmd->residual_count
plus underflow bit for outgoing TFO response callbacks.
It also checks for existing CDB level underflow + overflow
and recalculates final residual_count as necessary.

Note this patch currently assumes 1:1 mapping of PAGE_SIZE
per struct scatterlist entry.

	Reported-by: Craig Watson <craig.watson@vanguard-rugged.com>
	Cc: Craig Watson <craig.watson@vanguard-rugged.com>
	Tested-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Cc: Roland Dreier <roland@purestorage.com>
	Cc: Arun Easi <arun.easi@qlogic.com>
	Cc: Giridhar Malavali <giridhar.malavali@qlogic.com>
	Cc: Andrew Vasquez <andrew.vasquez@qlogic.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Hannes Reinecke <hare@suse.de>
	Cc: Martin K. Petersen <martin.petersen@oracle.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 8f9b565482c537821588444e09ff732c7d65ed6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
#	include/target/target_core_fabric.h
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,edeb3aefa6fe..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -1732,15 -1804,18 +1732,27 @@@ static struct configfs_attribute *tcm_q
  	NULL,
  };
  
++<<<<<<< HEAD
 +static struct target_core_fabric_ops tcm_qla2xxx_ops = {
++=======
+ static const struct target_core_fabric_ops tcm_qla2xxx_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "qla2xxx",
+ 	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
+ 	/*
+ 	 * XXX: Limit assumes single page per scatter-gather-list entry.
+ 	 * Current maximum is ~4.9 MB per se_cmd->t_data_sg with PAGE_SIZE=4096
+ 	 */
+ 	.max_data_sg_nents		= 1200,
++>>>>>>> 8f9b565482c5 (target/qla2xxx: Honor max_data_sg_nents I/O transfer limit)
  	.get_fabric_name		= tcm_qla2xxx_get_fabric_name,
 +	.get_fabric_proto_ident		= tcm_qla2xxx_get_fabric_proto_ident,
  	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
  	.tpg_get_tag			= tcm_qla2xxx_get_tag,
 +	.tpg_get_default_depth		= tcm_qla2xxx_get_default_depth,
 +	.tpg_get_pr_transport_id	= tcm_qla2xxx_get_pr_transport_id,
 +	.tpg_get_pr_transport_id_len	= tcm_qla2xxx_get_pr_transport_id_len,
 +	.tpg_parse_pr_out_transport_id	= tcm_qla2xxx_parse_pr_out_transport_id,
  	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
  	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
  	.tpg_check_demo_mode_write_protect =
diff --cc include/target/target_core_fabric.h
index c9a57a197803,7fb2557a760e..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -2,9 -2,23 +2,28 @@@
  #define TARGET_CORE_FABRIC_H
  
  struct target_core_fabric_ops {
++<<<<<<< HEAD
 +	struct configfs_subsystem *tf_subsys;
++=======
+ 	struct module *module;
+ 	const char *name;
+ 	size_t node_acl_size;
+ 	/*
+ 	 * Limits number of scatterlist entries per SCF_SCSI_DATA_CDB payload.
+ 	 * Setting this value tells target-core to enforce this limit, and
+ 	 * report as INQUIRY EVPD=b0 MAXIMUM TRANSFER LENGTH.
+ 	 *
+ 	 * target-core will currently reset se_cmd->data_length to this
+ 	 * maximum size, and set UNDERFLOW residual count if length exceeds
+ 	 * this limit.
+ 	 *
+ 	 * XXX: Not all initiator hosts honor this block-limit EVPD
+ 	 * XXX: Currently assumes single PAGE_SIZE per scatterlist entry
+ 	 */
+ 	u32 max_data_sg_nents;
++>>>>>>> 8f9b565482c5 (target/qla2xxx: Honor max_data_sg_nents I/O transfer limit)
  	char *(*get_fabric_name)(void);
 +	u8 (*get_fabric_proto_ident)(struct se_portal_group *);
  	char *(*tpg_get_wwn)(struct se_portal_group *);
  	u16 (*tpg_get_tag)(struct se_portal_group *);
  	u32 (*tpg_get_default_depth)(struct se_portal_group *);
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
diff --git a/drivers/target/target_core_spc.c b/drivers/target/target_core_spc.c
index 819803d44776..9e74ed0b8be6 100644
--- a/drivers/target/target_core_spc.c
+++ b/drivers/target/target_core_spc.c
@@ -503,8 +503,8 @@ static sense_reason_t
 spc_emulate_evpd_b0(struct se_cmd *cmd, unsigned char *buf)
 {
 	struct se_device *dev = cmd->se_dev;
-	int have_tp = 0;
-	int opt, min;
+	u32 mtl = 0;
+	int have_tp = 0, opt, min;
 
 	/*
 	 * Following spc3r22 section 6.5.3 Block Limits VPD page, when
@@ -535,8 +535,15 @@ spc_emulate_evpd_b0(struct se_cmd *cmd, unsigned char *buf)
 
 	/*
 	 * Set MAXIMUM TRANSFER LENGTH
+	 *
+	 * XXX: Currently assumes single PAGE_SIZE per scatterlist for fabrics
+	 * enforcing maximum HW scatter-gather-list entry limit
 	 */
-	put_unaligned_be32(dev->dev_attrib.hw_max_sectors, &buf[8]);
+	if (cmd->se_tfo->max_data_sg_nents) {
+		mtl = (cmd->se_tfo->max_data_sg_nents * PAGE_SIZE) /
+		       dev->dev_attrib.block_size;
+	}
+	put_unaligned_be32(min_not_zero(mtl, dev->dev_attrib.hw_max_sectors), &buf[8]);
 
 	/*
 	 * Set OPTIMAL TRANSFER LENGTH
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 512f3715b6d1..d6e101619181 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -1116,6 +1116,55 @@ transport_set_vpd_ident(struct t10_vpd *vpd, unsigned char *page_83)
 }
 EXPORT_SYMBOL(transport_set_vpd_ident);
 
+static sense_reason_t
+target_check_max_data_sg_nents(struct se_cmd *cmd, struct se_device *dev,
+			       unsigned int size)
+{
+	u32 mtl;
+
+	if (!cmd->se_tfo->max_data_sg_nents)
+		return TCM_NO_SENSE;
+	/*
+	 * Check if fabric enforced maximum SGL entries per I/O descriptor
+	 * exceeds se_cmd->data_length.  If true, set SCF_UNDERFLOW_BIT +
+	 * residual_count and reduce original cmd->data_length to maximum
+	 * length based on single PAGE_SIZE entry scatter-lists.
+	 */
+	mtl = (cmd->se_tfo->max_data_sg_nents * PAGE_SIZE);
+	if (cmd->data_length > mtl) {
+		/*
+		 * If an existing CDB overflow is present, calculate new residual
+		 * based on CDB size minus fabric maximum transfer length.
+		 *
+		 * If an existing CDB underflow is present, calculate new residual
+		 * based on original cmd->data_length minus fabric maximum transfer
+		 * length.
+		 *
+		 * Otherwise, set the underflow residual based on cmd->data_length
+		 * minus fabric maximum transfer length.
+		 */
+		if (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {
+			cmd->residual_count = (size - mtl);
+		} else if (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {
+			u32 orig_dl = size + cmd->residual_count;
+			cmd->residual_count = (orig_dl - mtl);
+		} else {
+			cmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;
+			cmd->residual_count = (cmd->data_length - mtl);
+		}
+		cmd->data_length = mtl;
+		/*
+		 * Reset sbc_check_prot() calculated protection payload
+		 * length based upon the new smaller MTL.
+		 */
+		if (cmd->prot_length) {
+			u32 sectors = (mtl / dev->dev_attrib.block_size);
+			cmd->prot_length = dev->prot_length * sectors;
+		}
+	}
+	return TCM_NO_SENSE;
+}
+
 sense_reason_t
 target_cmd_size_check(struct se_cmd *cmd, unsigned int size)
 {
@@ -1161,7 +1210,7 @@ target_cmd_size_check(struct se_cmd *cmd, unsigned int size)
 		}
 	}
 
-	return 0;
+	return target_check_max_data_sg_nents(cmd, dev, size);
 
 }
 
* Unmerged path include/target/target_core_fabric.h
