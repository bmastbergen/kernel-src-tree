mnt: Account for MS_RDONLY in fs_fully_visible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 695e9df010e40f407f4830dc11d53dce957710ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/695e9df0.failed

In rare cases it is possible for s_flags & MS_RDONLY to be set but
MNT_READONLY to be clear.  This starting combination can cause
fs_fully_visible to fail to ensure that the new mount is readonly.
Therefore force MNT_LOCK_READONLY in the new mount if MS_RDONLY
is set on the source filesystem of the mount.

In general both MS_RDONLY and MNT_READONLY are set at the same for
mounts so I don't expect any programs to care.  Nor do I expect
MS_RDONLY to be set on proc or sysfs in the initial user namespace,
which further decreases the likelyhood of problems.

Which means this change should only affect system configurations by
paranoid sysadmins who should welcome the additional protection
as it keeps people from wriggling out of their policies.

	Cc: stable@vger.kernel.org
Fixes: 8c6cf9cc829f ("mnt: Modify fs_fully_visible to deal with locked ro nodev and atime")
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 695e9df010e40f407f4830dc11d53dce957710ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index edd7c5e218b1,783004af5707..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -3300,23 -3224,83 +3300,80 @@@ void update_mnt_policy(struct user_name
  
  	down_read(&namespace_sem);
  	list_for_each_entry(mnt, &ns->list, mnt_list) {
++<<<<<<< HEAD
 +		switch (mnt->mnt.mnt_sb->s_magic) {
 +		case SYSFS_MAGIC:
 +			userns->may_mount_sysfs = true;
 +			break;
 +		case PROC_SUPER_MAGIC:
 +			userns->may_mount_proc = true;
 +			break;
++=======
+ 		struct mount *child;
+ 		int mnt_flags;
+ 
+ 		if (mnt->mnt.mnt_sb->s_type != type)
+ 			continue;
+ 
+ 		/* This mount is not fully visible if it's root directory
+ 		 * is not the root directory of the filesystem.
+ 		 */
+ 		if (mnt->mnt.mnt_root != mnt->mnt.mnt_sb->s_root)
+ 			continue;
+ 
+ 		/* Read the mount flags and filter out flags that
+ 		 * may safely be ignored.
+ 		 */
+ 		mnt_flags = mnt->mnt.mnt_flags;
+ 		if (mnt->mnt.mnt_sb->s_iflags & SB_I_NOEXEC)
+ 			mnt_flags &= ~(MNT_LOCK_NOSUID | MNT_LOCK_NOEXEC);
+ 
+ 		/* Don't miss readonly hidden in the superblock flags */
+ 		if (mnt->mnt.mnt_sb->s_flags & MS_RDONLY)
+ 			mnt_flags |= MNT_LOCK_READONLY;
+ 
+ 		/* Verify the mount flags are equal to or more permissive
+ 		 * than the proposed new mount.
+ 		 */
+ 		if ((mnt_flags & MNT_LOCK_READONLY) &&
+ 		    !(new_flags & MNT_READONLY))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NODEV) &&
+ 		    !(new_flags & MNT_NODEV))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NOSUID) &&
+ 		    !(new_flags & MNT_NOSUID))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_NOEXEC) &&
+ 		    !(new_flags & MNT_NOEXEC))
+ 			continue;
+ 		if ((mnt_flags & MNT_LOCK_ATIME) &&
+ 		    ((mnt_flags & MNT_ATIME_MASK) != (new_flags & MNT_ATIME_MASK)))
+ 			continue;
+ 
+ 		/* This mount is not fully visible if there are any
+ 		 * locked child mounts that cover anything except for
+ 		 * empty directories.
+ 		 */
+ 		list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {
+ 			struct inode *inode = child->mnt_mountpoint->d_inode;
+ 			/* Only worry about locked mounts */
+ 			if (!(child->mnt.mnt_flags & MNT_LOCKED))
+ 				continue;
+ 			/* Is the directory permanetly empty? */
+ 			if (!is_empty_dir_inode(inode))
+ 				goto next;
++>>>>>>> 695e9df010e4 (mnt: Account for MS_RDONLY in fs_fully_visible)
  		}
 -		/* Preserve the locked attributes */
 -		*new_mnt_flags |= mnt_flags & (MNT_LOCK_READONLY | \
 -					       MNT_LOCK_NODEV    | \
 -					       MNT_LOCK_NOSUID   | \
 -					       MNT_LOCK_NOEXEC   | \
 -					       MNT_LOCK_ATIME);
 -		visible = true;
 -		goto found;
 -	next:	;
 -	}
 -found:
 +		if (userns->may_mount_sysfs && userns->may_mount_proc)
 +			break;
 +	}
  	up_read(&namespace_sem);
 -	return visible;
  }
  
 -static struct ns_common *mntns_get(struct task_struct *task)
 +static void *mntns_get(struct task_struct *task)
  {
 -	struct ns_common *ns = NULL;
 +	struct mnt_namespace *ns = NULL;
  	struct nsproxy *nsproxy;
  
  	task_lock(task);
* Unmerged path fs/namespace.c
