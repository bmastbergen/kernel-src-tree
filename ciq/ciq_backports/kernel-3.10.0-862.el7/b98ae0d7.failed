scsi: qla2xxx: Fix name server relogin

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix name server relogin (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 91.43%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit b98ae0d748dbc80016c5cc2e926f33648d83353d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b98ae0d7.failed

Name server login is normally handle by FW. In some rare case where one
of the switches is being updated, name server login could get
affected. Trigger relogin to name server when driver detects this
condition.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b98ae0d748dbc80016c5cc2e926f33648d83353d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5,4ea4aa5bddaa..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -274,6 -318,829 +274,831 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ static void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *conflict_fcport;
+ 	struct get_name_list_extended *e;
+ 	u16 i, n, found = 0, loop_id;
+ 	port_id_t id;
+ 	u64 wwn;
+ 	u8 opt = 0;
+ 
+ 	fcport = ea->fcport;
+ 
+ 	if (ea->rc) { /* rval */
+ 		if (fcport->login_retry == 0) {
+ 			fcport->login_retry = vha->hw->login_retry_count;
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				"GNL failed Port login retry %8phN, retry cnt=%d.\n",
+ 				fcport->port_name, fcport->login_retry);
+ 		}
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC rscn gen changed rscn %d|%d \n",
+ 		    __func__, fcport->port_name,
+ 		    fcport->last_rscn_gen, fcport->rscn_gen);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	} else if (fcport->last_login_gen != fcport->login_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s %8phC login gen changed login %d|%d \n",
+ 			__func__, fcport->port_name,
+ 			fcport->last_login_gen, fcport->login_gen);
+ 		return;
+ 	}
+ 
+ 	n = ea->data[0] / sizeof(struct get_name_list_extended);
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %d %8phC n %d %02x%02x%02x lid %d \n",
+ 	    __func__, __LINE__, fcport->port_name, n,
+ 	    fcport->d_id.b.domain, fcport->d_id.b.area,
+ 	    fcport->d_id.b.al_pa, fcport->loop_id);
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		if (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))
+ 			continue;
+ 
+ 		found = 1;
+ 		id.b.domain = e->port_id[2];
+ 		id.b.area = e->port_id[1];
+ 		id.b.al_pa = e->port_id[0];
+ 		id.b.rsvd_1 = 0;
+ 
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		loop_id = (loop_id & 0x7fff);
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			"%s found %8phC CLS [%d|%d] ID[%02x%02x%02x|%02x%02x%02x] lid[%d|%d]\n",
+ 			   __func__, fcport->port_name,
+ 			e->current_login_state, fcport->fw_login_state,
+ 			id.b.domain, id.b.area, id.b.al_pa,
+ 			fcport->d_id.b.domain, fcport->d_id.b.area,
+ 			fcport->d_id.b.al_pa, loop_id, fcport->loop_id);
+ 
+ 		if ((id.b24 != fcport->d_id.b24) ||
+ 		    ((fcport->loop_id != FC_NO_LOOP_ID) &&
+ 			(fcport->loop_id != loop_id))) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post del sess\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qlt_schedule_sess_for_deletion(fcport, 1);
+ 			return;
+ 		}
+ 
+ 		fcport->loop_id = loop_id;
+ 
+ 		wwn = wwn_to_u64(fcport->port_name);
+ 		qlt_find_sess_invalidate_other(vha, wwn,
+ 			id, loop_id, &conflict_fcport);
+ 
+ 		if (conflict_fcport) {
+ 			/*
+ 			 * Another share fcport share the same loop_id &
+ 			 * nport id. Conflict fcport needs to finish
+ 			 * cleanup before this fcport can proceed to login.
+ 			 */
+ 			conflict_fcport->conflict = fcport;
+ 			fcport->login_pause = 1;
+ 		}
+ 
+ 		switch (e->current_login_state) {
+ 		case DSC_LS_PRLI_COMP:
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			opt = PDO_FORCE_ADISC;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 			break;
+ 
+ 		case DSC_LS_PORT_UNAVAIL:
+ 		default:
+ 			if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 				qla2x00_find_new_loop_id(vha, fcport);
+ 				fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 			}
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!found) {
+ 		/* fw has no record of this port */
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			qla2x00_find_new_loop_id(vha, fcport);
+ 			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 		} else {
+ 			for (i = 0; i < n; i++) {
+ 				e = &vha->gnl.l[i];
+ 				id.b.domain = e->port_id[0];
+ 				id.b.area = e->port_id[1];
+ 				id.b.al_pa = e->port_id[2];
+ 				id.b.rsvd_1 = 0;
+ 				loop_id = le16_to_cpu(e->nport_handle);
+ 
+ 				if (fcport->d_id.b24 == id.b24) {
+ 					conflict_fcport =
+ 					    qla2x00_find_fcport_by_wwpn(vha,
+ 						e->port_name, 0);
+ 
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__,
+ 					    conflict_fcport->port_name);
+ 					qlt_schedule_sess_for_deletion
+ 						(conflict_fcport, 1);
+ 				}
+ 
+ 				if (fcport->loop_id == loop_id) {
+ 					/* FW already picked this loop id for another fcport */
+ 					qla2x00_find_new_loop_id(vha, fcport);
+ 				}
+ 			}
+ 		}
+ 		qla24xx_fcport_handle_login(vha, fcport);
+ 	}
+ } /* gnl_event */
+ 
+ static void
+ qla24xx_async_gnl_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	unsigned long flags;
+ 	struct fc_port *fcport = NULL, *tf;
+ 	u16 i, n = 0, loop_id;
+ 	struct event_arg ea;
+ 	struct get_name_list_extended *e;
+ 	u64 wwn;
+ 	struct list_head h;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],
+ 	    sp->u.iocb_cmd.u.mbx.in_mb[2]);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GNL_DONE;
+ 
+ 	if (sp->u.iocb_cmd.u.mbx.in_mb[1] >=
+ 	    sizeof(struct get_name_list_extended)) {
+ 		n = sp->u.iocb_cmd.u.mbx.in_mb[1] /
+ 		    sizeof(struct get_name_list_extended);
+ 		ea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1]; /* amnt xfered */
+ 	}
+ 
+ 	for (i = 0; i < n; i++) {
+ 		e = &vha->gnl.l[i];
+ 		loop_id = le16_to_cpu(e->nport_handle);
+ 		/* mask out reserve bit */
+ 		loop_id = (loop_id & 0x7fff);
+ 		set_bit(loop_id, vha->hw->loop_id_map);
+ 		wwn = wwn_to_u64(e->port_name);
+ 
+ 		ql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,
+ 		    "%s %8phC %02x:%02x:%02x state %d/%d lid %x \n",
+ 		    __func__, (void *)&wwn, e->port_id[2], e->port_id[1],
+ 		    e->port_id[0], e->current_login_state, e->last_login_state,
+ 		    (loop_id & 0x7fff));
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	vha->gnl.sent = 0;
+ 
+ 	INIT_LIST_HEAD(&h);
+ 	fcport = tf = NULL;
+ 	if (!list_empty(&vha->gnl.fcports))
+ 		list_splice_init(&vha->gnl.fcports, &h);
+ 
+ 	list_for_each_entry_safe(fcport, tf, &h, gnl_entry) {
+ 		list_del_init(&fcport->gnl_entry);
+ 		fcport->flags &= ~FCF_ASYNC_SENT;
+ 		ea.fcport = fcport;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	unsigned long flags;
+ 	u16 *mb;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-gnlist WWPN %8phC \n", fcport->port_name);
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GNL;
+ 	fcport->last_rscn_gen = fcport->rscn_gen;
+ 	fcport->last_login_gen = fcport->login_gen;
+ 
+ 	list_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);
+ 	if (vha->gnl.sent) {
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 		rval = QLA_SUCCESS;
+ 		goto done;
+ 	}
+ 	vha->gnl.sent = 1;
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gnlist";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_PORT_NODE_NAME_LIST;
+ 	mb[1] = BIT_2 | BIT_3;
+ 	mb[2] = MSW(vha->gnl.ldma);
+ 	mb[3] = LSW(vha->gnl.ldma);
+ 	mb[6] = MSW(MSD(vha->gnl.ldma));
+ 	mb[7] = LSW(MSD(vha->gnl.ldma));
+ 	mb[8] = vha->gnl.size;
+ 	mb[9] = vha->vp_idx;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 
+ 	sp->done = qla24xx_async_gnl_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s - OUT WWPN %8phC hndl %x\n",
+ 		sp->name, fcport->port_name, sp->handle);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GNL);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ void qla24xx_async_gpdb_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct port_database_24xx *pd;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;
+ 	int rval = QLA_SUCCESS;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \n",
+ 	    sp->name, res, fcport->port_name, mb[1], mb[2]);
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (res) {
+ 		rval = res;
+ 		goto gpd_error_out;
+ 	}
+ 
+ 	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
+ 
+ 	rval = __qla24xx_parse_gpdb(vha, fcport, pd);
+ 
+ gpd_error_out:
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.event = FCME_GPDB_DONE;
+ 	ea.rc = rval;
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	dma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,
+ 		sp->u.iocb_cmd.u.mbx.in_dma);
+ 
+ 	sp->free(sp);
+ }
+ 
+ static int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport,
+     u8 opt)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GPDB);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	e->u.fcport.opt = opt;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ int qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *mbx;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	u16 *mb;
+ 	dma_addr_t pd_dma;
+ 	struct port_database_24xx *pd;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GPDB;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);
+ 	if (pd == NULL) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 			"Failed to allocate port database structure.\n");
+ 		goto done_free_sp;
+ 	}
+ 	memset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));
+ 
+ 	sp->type = SRB_MB_IOCB;
+ 	sp->name = "gpdb";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	mb = sp->u.iocb_cmd.u.mbx.out_mb;
+ 	mb[0] = MBC_GET_PORT_DATABASE;
+ 	mb[1] = fcport->loop_id;
+ 	mb[2] = MSW(pd_dma);
+ 	mb[3] = LSW(pd_dma);
+ 	mb[6] = MSW(MSD(pd_dma));
+ 	mb[7] = LSW(MSD(pd_dma));
+ 	mb[9] = vha->vp_idx;
+ 	mb[10] = opt;
+ 
+ 	mbx = &sp->u.iocb_cmd;
+ 	mbx->timeout = qla2x00_async_iocb_timeout;
+ 	mbx->u.mbx.in = (void *)pd;
+ 	mbx->u.mbx.in_dma = pd_dma;
+ 
+ 	sp->done = qla24xx_async_gpdb_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"Async-%s %8phC hndl %x opt %x\n",
+ 		sp->name, fcport->port_name, sp->handle, opt);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (pd)
+ 		dma_pool_free(ha->s_dma_pool, pd, pd_dma);
+ 
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	qla24xx_post_gpdb_work(vha, fcport, opt);
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	int rval = ea->rc;
+ 	fc_port_t *fcport = ea->fcport;
+ 	unsigned long flags;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
+ 	    fcport->disc_state, fcport->fw_login_state, rval);
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 		return;
+ 	}
+ 
+ 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 	ea->fcport->login_gen++;
+ 	ea->fcport->deleted = 0;
+ 	ea->fcport->logout_on_delete = 1;
+ 
+ 	if (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {
+ 		vha->fcport_count++;
+ 		ea->fcport->login_succ = 1;
+ 
+ 		if (!IS_IIDMA_CAPABLE(vha->hw) ||
+ 		    !vha->hw->flags.gpsc_supported) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post upd_fcport fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_upd_fcport_work(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post gpsc fcp_cnt %d\n",
+ 			    __func__, __LINE__, fcport->port_name,
+ 			    vha->fcport_count);
+ 
+ 			qla24xx_post_gpsc_work(vha, fcport);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ } /* gpdb event */
+ 
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	if (fcport->login_retry == 0)
+ 		return 0;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND)
+ 		return 0;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
+ 	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
+ 	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
+ 	    fcport->loop_id);
+ 
+ 	fcport->login_retry--;
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return 0;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
+ 		if (time_before_eq(jiffies, fcport->plogi_nack_done_deadline))
+ 			return 0;
+ 	}
+ 
+ 	/* for pure Target Mode. Login will not be initiated */
+ 	if (vha->host->active_mode == MODE_TARGET)
+ 		return 0;
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return 0;
+ 	}
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gnl\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			qla24xx_async_gnl(vha, fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 		break;
+ 
+ 	case DSC_GNL:
+ 		if (fcport->login_pause) {
+ 			fcport->last_rscn_gen = fcport->rscn_gen;
+ 			fcport->last_login_gen = fcport->login_gen;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
+ 		}
+ 
+ 		if (fcport->flags & FCF_FCP2_DEVICE) {
+ 			u8 opt = PDO_FORCE_ADISC;
+ 
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb\n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 			fcport->disc_state = DSC_GPDB;
+ 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post login \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 			fcport->disc_state = DSC_LOGIN_PEND;
+ 			qla2x00_post_async_login_work(vha, fcport, NULL);
+ 		}
+ 
+ 		break;
+ 
+ 	case DSC_LOGIN_FAILED:
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gidpn \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		break;
+ 
+ 	case DSC_LOGIN_COMPLETE:
+ 		/* recheck login state */
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			   "%s %d %8phC post gpdb \n",
+ 			   __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_post_gpdb_work(vha, fcport, PDO_FORCE_ADISC);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_rscn_event(fc_port_t *fcport, struct event_arg *ea)
+ {
+ 	fcport->rscn_gen++;
+ 
+ 	ql_dbg(ql_dbg_disc, fcport->vha, 0xffff,
+ 		"%s %8phC DS %d LS %d\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state);
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT)
+ 		return;
+ 
+ 	switch (fcport->disc_state) {
+ 	case DSC_DELETED:
+ 	case DSC_LOGIN_COMPLETE:
+ 		qla24xx_post_gidpn_work(fcport->vha, fcport);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ int qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,
+ 	u8 *port_name, void *pla)
+ {
+ 	struct qla_work_evt *e;
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.new_sess.id = *id;
+ 	e->u.new_sess.pla = pla;
+ 	memcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static
+ int qla24xx_handle_delete_done_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	switch (vha->host->active_mode) {
+ 	case MODE_INITIATOR:
+ 	case MODE_DUAL:
+ 		if (fcport->scan_state == QLA_FCPORT_FOUND)
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 		break;
+ 
+ 	case MODE_TARGET:
+ 	default:
+ 		/* no-op */
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static
+ void qla24xx_handle_relogin_event(scsi_qla_host_t *vha,
+ 	struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		"%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\n",
+ 		__func__, fcport->port_name, fcport->disc_state,
+ 		fcport->fw_login_state, fcport->login_pause,
+ 		fcport->deleted, fcport->conflict,
+ 		fcport->last_rscn_gen, fcport->rscn_gen,
+ 		fcport->last_login_gen, fcport->login_gen,
+ 		fcport->flags);
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
+ 		return;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
+ 		if (time_before_eq(jiffies, fcport->plogi_nack_done_deadline))
+ 			return;
+ 	}
+ 
+ 	if (fcport->flags & FCF_ASYNC_SENT) {
+ 		fcport->login_retry++;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND) {
+ 		fcport->login_retry++;
+ 		return;
+ 	}
+ 
+ 	if (fcport->last_rscn_gen != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 
+ 		qla24xx_async_gidpn(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	qla24xx_fcport_handle_login(vha, fcport);
+ }
+ 
+ void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport, *f, *tf;
+ 	uint32_t id = 0, mask, rid;
+ 	int rc;
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 	case FCME_RSCN:
+ 	case FCME_GIDPN_DONE:
+ 	case FCME_GPSC_DONE:
+ 	case FCME_GPNID_DONE:
+ 		if (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags) ||
+ 		    test_bit(LOOP_RESYNC_ACTIVE, &vha->dpc_flags))
+ 			return;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	switch (ea->event) {
+ 	case FCME_RELOGIN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 
+ 		qla24xx_handle_relogin_event(vha, ea);
+ 		break;
+ 	case FCME_RSCN:
+ 		if (test_bit(UNLOADING, &vha->dpc_flags))
+ 			return;
+ 		switch (ea->id.b.rsvd_1) {
+ 		case RSCN_PORT_ADDR:
+ 			fcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);
+ 			if (!fcport) {
+ 				/* cable moved */
+ 				rc = qla24xx_post_gpnid_work(vha, &ea->id);
+ 				if (rc) {
+ 					ql_log(ql_log_warn, vha, 0xffff,
+ 						"RSCN GPNID work failed %02x%02x%02x\n",
+ 						ea->id.b.domain, ea->id.b.area,
+ 						ea->id.b.al_pa);
+ 				}
+ 			} else {
+ 				ea->fcport = fcport;
+ 				qla24xx_handle_rscn_event(fcport, ea);
+ 			}
+ 			break;
+ 		case RSCN_AREA_ADDR:
+ 		case RSCN_DOM_ADDR:
+ 			if (ea->id.b.rsvd_1 == RSCN_AREA_ADDR) {
+ 				mask = 0xffff00;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Area 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			} else {
+ 				mask = 0xff0000;
+ 				ql_log(ql_dbg_async, vha, 0xffff,
+ 					   "RSCN: Domain 0x%06x was affected\n",
+ 					   ea->id.b24);
+ 			}
+ 
+ 			rid = ea->id.b24 & mask;
+ 			list_for_each_entry_safe(f, tf, &vha->vp_fcports,
+ 			    list) {
+ 				id = f->d_id.b24 & mask;
+ 				if (rid == id) {
+ 					ea->fcport = f;
+ 					qla24xx_handle_rscn_event(f, ea);
+ 				}
+ 			}
+ 			break;
+ 		case RSCN_FAB_ADDR:
+ 		default:
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 				"RSCN: Fabric was affected. Addr format %d\n",
+ 				ea->id.b.rsvd_1);
+ 			qla2x00_mark_all_devices_lost(vha, 1);
+ 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+ 		}
+ 		break;
+ 	case FCME_GIDPN_DONE:
+ 		qla24xx_handle_gidpn_event(vha, ea);
+ 		break;
+ 	case FCME_GNL_DONE:
+ 		qla24xx_handle_gnl_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPSC_DONE:
+ 		qla24xx_post_upd_fcport_work(vha, ea->fcport);
+ 		break;
+ 	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
+ 		qla24xx_handle_plogi_done_event(vha, ea);
+ 		break;
+ 	case FCME_GPDB_DONE:
+ 		qla24xx_handle_gpdb_event(vha, ea);
+ 		break;
+ 	case FCME_GPNID_DONE:
+ 		qla24xx_handle_gpnid_event(vha, ea);
+ 		break;
+ 	case FCME_DELETE_DONE:
+ 		qla24xx_handle_delete_done_event(vha, ea);
+ 		break;
+ 	default:
+ 		BUG_ON(1);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> b98ae0d748db (scsi: qla2xxx: Fix name server relogin)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
@@@ -3629,13 -4561,20 +4465,26 @@@ qla2x00_find_all_fabric_devs(scsi_qla_h
  		memset(swl, 0, ha->max_fibre_devices * sizeof(sw_info_t));
  		if (qla2x00_gid_pt(vha, swl) != QLA_SUCCESS) {
  			swl = NULL;
+ 			if (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))
+ 				return rval;
  		} else if (qla2x00_gpn_id(vha, swl) != QLA_SUCCESS) {
  			swl = NULL;
+ 			if (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))
+ 				return rval;
  		} else if (qla2x00_gnn_id(vha, swl) != QLA_SUCCESS) {
  			swl = NULL;
++<<<<<<< HEAD
 +		} else if (ql2xiidmaenable &&
 +		    qla2x00_gfpn_id(vha, swl) == QLA_SUCCESS) {
 +			qla2x00_gpsc(vha, swl);
++=======
+ 			if (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))
+ 				return rval;
+ 		} else if (qla2x00_gfpn_id(vha, swl) != QLA_SUCCESS) {
+ 			swl = NULL;
+ 			if (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))
+ 				return rval;
++>>>>>>> b98ae0d748db (scsi: qla2xxx: Fix name server relogin)
  		}
  
  		/* If other queries succeeded probe for FC-4 type */
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812..687707dbd970 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -249,6 +249,8 @@
 #define NPH_F_PORT		0x7fe		/*  FFFFFE */
 #define NPH_IP_BROADCAST	0x7ff		/*  FFFFFF */
 
+#define NPH_SNS_LID(ha)	(IS_FWI2_CAPABLE(ha) ? NPH_SNS : SIMPLE_NAME_SERVER)
+
 #define MAX_CMDSZ	16		/* SCSI maximum CDB size. */
 #include "qla_fw.h"
 /*
diff --git a/drivers/scsi/qla2xxx/qla_gs.c b/drivers/scsi/qla2xxx/qla_gs.c
index 54827d74afb8..6dc0d2c7764f 100644
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@ -124,6 +124,7 @@ qla2x00_chk_ms_status(scsi_qla_host_t *vha, ms_iocb_entry_t *ms_pkt,
 	int rval;
 	uint16_t comp_status;
 	struct qla_hw_data *ha = vha->hw;
+	bool lid_is_sns = false;
 
 	rval = QLA_FUNCTION_FAILED;
 	if (ms_pkt->entry_status != 0) {
@@ -155,6 +156,25 @@ qla2x00_chk_ms_status(scsi_qla_host_t *vha, ms_iocb_entry_t *ms_pkt,
 			} else
 				rval = QLA_SUCCESS;
 			break;
+		case CS_PORT_LOGGED_OUT:
+			if (IS_FWI2_CAPABLE(ha)) {
+				if (le16_to_cpu(ms_pkt->loop_id.extended) ==
+				    NPH_SNS)
+					lid_is_sns = true;
+			} else {
+				if (le16_to_cpu(ms_pkt->loop_id.extended) ==
+				    SIMPLE_NAME_SERVER)
+					lid_is_sns = true;
+			}
+			if (lid_is_sns) {
+				ql_dbg(ql_dbg_async, vha, 0x502b,
+					"%s failed, Name server has logged out",
+					routine);
+				rval = QLA_NOT_LOGGED_IN;
+				set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+				set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+			}
+			break;
 		default:
 			ql_dbg(ql_dbg_disc, vha, 0x2033,
 			    "%s failed, completion status (%x) on port_id: "
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index d71223f09c1c..c2d968609b58 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -928,6 +928,23 @@ skip_rio:
 			if (mb[1] == 0xffff)
 				goto global_port_update;
 
+			if (mb[1] == NPH_SNS_LID(ha)) {
+				set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+				set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+				break;
+			}
+
+			/* use handle_cnt for loop id/nport handle */
+			if (IS_FWI2_CAPABLE(ha))
+				handle_cnt = NPH_SNS;
+			else
+				handle_cnt = SIMPLE_NAME_SERVER;
+			if (mb[1] == handle_cnt) {
+				set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+				set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
+				break;
+			}
+
 			/* Port logout */
 			fcport = qla2x00_find_fcport_by_loopid(vha, mb[1]);
 			if (!fcport)
