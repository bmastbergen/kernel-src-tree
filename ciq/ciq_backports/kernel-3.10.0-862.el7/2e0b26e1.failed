geneve: Optimize geneve device lookup.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] geneve: Optimize geneve device lookup (Jakub Sitnicki) [1467288]
Rebuild_FUZZ: 98.67%
commit-author pravin shelar <pshelar@ovn.org>
commit 2e0b26e1035253bda7587f705f346385352e942d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2e0b26e1.failed

Rather than comparing 64-bit tunnel-id, compare tunnel vni
which is 24-bit id. This also save conversion from vni
to tunnel id on each tunnel packet receive.

	Signed-off-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2e0b26e1035253bda7587f705f346385352e942d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index c4c93ccffa85,7b80e2879b70..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -117,6 -89,31 +117,34 @@@ static __be64 vni_to_tunnel_id(const __
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ /* Convert 64 bit tunnel ID to 24 bit VNI. */
+ static void tunnel_id_to_vni(__be64 tun_id, __u8 *vni)
+ {
+ #ifdef __BIG_ENDIAN
+ 	vni[0] = (__force __u8)(tun_id >> 16);
+ 	vni[1] = (__force __u8)(tun_id >> 8);
+ 	vni[2] = (__force __u8)tun_id;
+ #else
+ 	vni[0] = (__force __u8)((__force u64)tun_id >> 40);
+ 	vni[1] = (__force __u8)((__force u64)tun_id >> 48);
+ 	vni[2] = (__force __u8)((__force u64)tun_id >> 56);
+ #endif
+ }
+ 
+ static bool eq_tun_id_and_vni(u8 *tun_id, u8 *vni)
+ {
+ #ifdef __BIG_ENDIAN
+ 	return (vni[0] == tun_id[2]) &&
+ 	       (vni[1] == tun_id[1]) &&
+ 	       (vni[2] == tun_id[0]);
+ #else
+ 	return !memcmp(vni, &tun_id[5], 3);
+ #endif
+ }
+ 
++>>>>>>> 2e0b26e10352 (geneve: Optimize geneve device lookup.)
  static sa_family_t geneve_get_sk_family(struct geneve_sock *gs)
  {
  	return gs->sock->sk->sk_family;
@@@ -132,10 -129,10 +160,17 @@@ static struct geneve_dev *geneve_lookup
  	/* Find the device for this VNI */
  	hash = geneve_net_vni_hash(vni);
  	vni_list_head = &gs->vni_list[hash];
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(node, vni_list_head, hlist) {
 +		if (!memcmp(vni, node->geneve->vni, sizeof(node->geneve->vni)) &&
 +		    addr == node->geneve->remote.sin.sin_addr.s_addr)
 +			return node->geneve;
++=======
+ 	hlist_for_each_entry_rcu(geneve, vni_list_head, hlist) {
+ 		if (eq_tun_id_and_vni((u8 *)&geneve->info.key.tun_id, vni) &&
+ 		    addr == geneve->info.key.u.ipv4.dst)
+ 			return geneve;
++>>>>>>> 2e0b26e10352 (geneve: Optimize geneve device lookup.)
  	}
  	return NULL;
  }
@@@ -151,10 -148,10 +186,17 @@@ static struct geneve_dev *geneve6_looku
  	/* Find the device for this VNI */
  	hash = geneve_net_vni_hash(vni);
  	vni_list_head = &gs->vni_list[hash];
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(node, vni_list_head, hlist) {
 +		if (!memcmp(vni, node->geneve->vni, sizeof(node->geneve->vni)) &&
 +		    ipv6_addr_equal(&addr6, &node->geneve->remote.sin6.sin6_addr))
 +			return node->geneve;
++=======
+ 	hlist_for_each_entry_rcu(geneve, vni_list_head, hlist) {
+ 		if (eq_tun_id_and_vni((u8 *)&geneve->info.key.tun_id, vni) &&
+ 		    ipv6_addr_equal(&addr6, &geneve->info.key.u.ipv6.dst))
+ 			return geneve;
++>>>>>>> 2e0b26e10352 (geneve: Optimize geneve device lookup.)
  	}
  	return NULL;
  }
* Unmerged path drivers/net/geneve.c
