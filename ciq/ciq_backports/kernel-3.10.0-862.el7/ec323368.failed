sched: remove qdisc arg from __qdisc_dequeue_head

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Florian Westphal <fw@strlen.de>
commit ec323368793b8570c02e723127611a8d906a9b3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ec323368.failed

Moves qdisc stat accouting to qdisc_dequeue_head.

The only direct caller of the __qdisc_dequeue_head version open-codes
this now.

This allows us to later use __qdisc_dequeue_head as a replacement
of __skb_dequeue() (which operates on sk_buff_head list).

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec323368793b8570c02e723127611a8d906a9b3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sch_generic.h
diff --cc include/net/sch_generic.h
index e957def28d63,0741ed41575b..000000000000
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@@ -627,9 -633,13 +633,19 @@@ static inline struct sk_buff *qdisc_deq
  	return skb;
  }
  
++<<<<<<< HEAD
 +static inline struct sk_buff *qdisc_dequeue_head(struct Qdisc *sch)
 +{
 +	return __qdisc_dequeue_head(sch, &sch->q);
++=======
+ /* Instead of calling kfree_skb() while root qdisc lock is held,
+  * queue the skb for future freeing at end of __dev_xmit_skb()
+  */
+ static inline void __qdisc_drop(struct sk_buff *skb, struct sk_buff **to_free)
+ {
+ 	skb->next = *to_free;
+ 	*to_free = skb;
++>>>>>>> ec323368793b (sched: remove qdisc arg from __qdisc_dequeue_head)
  }
  
  static inline unsigned int __qdisc_queue_drop_head(struct Qdisc *sch,
* Unmerged path include/net/sch_generic.h
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 57cbfa322683..8de3b8f78cbd 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -494,7 +494,12 @@ static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
 
 	if (likely(band >= 0)) {
 		struct sk_buff_head *list = band2list(priv, band);
-		struct sk_buff *skb = __qdisc_dequeue_head(qdisc, list);
+		struct sk_buff *skb = __qdisc_dequeue_head(list);
+
+		if (likely(skb != NULL)) {
+			qdisc_qstats_backlog_dec(qdisc, skb);
+			qdisc_bstats_update(qdisc, skb);
+		}
 
 		qdisc->q.qlen--;
 		if (skb_queue_empty(list))
