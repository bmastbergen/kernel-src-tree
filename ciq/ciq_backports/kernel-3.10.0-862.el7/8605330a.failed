tcp: fix SCM_TIMESTAMPING_OPT_STATS for normal skbs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Soheil Hassas Yeganeh <soheil@google.com>
commit 8605330aac5a5785630aec8f64378a54891937cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8605330a.failed

__sock_recv_timestamp can be called for both normal skbs (for
receive timestamps) and for skbs on the error queue (for transmit
timestamps).

Commit 1c885808e456
(tcp: SOF_TIMESTAMPING_OPT_STATS option for SO_TIMESTAMPING)
assumes any skb passed to __sock_recv_timestamp are from
the error queue, containing OPT_STATS in the content of the skb.
This results in accessing invalid memory or generating junk
data.

To fix this, set skb->pkt_type to PACKET_OUTGOING for packets
on the error queue. This is safe because on the receive path
on local sockets skb->pkt_type is never set to PACKET_OUTGOING.
With that, copy OPT_STATS from a packet, only if its pkt_type
is PACKET_OUTGOING.

Fixes: 1c885808e456 ("tcp: SOF_TIMESTAMPING_OPT_STATS option for SO_TIMESTAMPING")
	Reported-by: JongHwan Kim <zzoru007@gmail.com>
	Signed-off-by: Soheil Hassas Yeganeh <soheil@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8605330aac5a5785630aec8f64378a54891937cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/socket.c
diff --cc net/socket.c
index 88dae07181b5,692d6989d2c2..000000000000
--- a/net/socket.c
+++ b/net/socket.c
@@@ -704,17 -697,19 +714,26 @@@ void __sock_recv_timestamp(struct msghd
  	if ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&
  	    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))
  		empty = 0;
 -	if (shhwtstamps &&
 -	    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&
 -	    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))
 -		empty = 0;
 -	if (!empty) {
 +	if (shhwtstamps) {
 +		if ((sk->sk_tsflags & SOF_TIMESTAMPING_SYS_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->syststamp, tss.ts + 1))
 +			empty = 0;
 +		if ((sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))
 +			empty = 0;
 +	}
 +	if (!empty)
  		put_cmsg(msg, SOL_SOCKET,
  			 SCM_TIMESTAMPING, sizeof(tss), &tss);
++<<<<<<< HEAD
++=======
+ 
+ 		if (skb_is_err_queue(skb) && skb->len &&
+ 		    (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))
+ 			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,
+ 				 skb->len, skb->data);
+ 	}
++>>>>>>> 8605330aac5a (tcp: fix SCM_TIMESTAMPING_OPT_STATS for normal skbs)
  }
  EXPORT_SYMBOL_GPL(__sock_recv_timestamp);
  
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 1810381d0deb..b95a6a78cf5c 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -3766,6 +3766,15 @@ static void sock_rmem_free(struct sk_buff *skb)
 	atomic_sub(skb->truesize, &sk->sk_rmem_alloc);
 }
 
+static void skb_set_err_queue(struct sk_buff *skb)
+{
+	/* pkt_type of skbs received on local sockets is never PACKET_OUTGOING.
+	 * So, it is safe to (mis)use it to mark skbs on the error queue.
+	 */
+	skb->pkt_type = PACKET_OUTGOING;
+	BUILD_BUG_ON(PACKET_OUTGOING == 0);
+}
+
 /*
  * Note: We dont mem charge error packets (no sk_forward_alloc changes)
  */
@@ -3781,6 +3790,7 @@ int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)
 	skb->sk = sk;
 	skb->destructor = sock_rmem_free;
 	atomic_add(skb->truesize, &sk->sk_rmem_alloc);
+	skb_set_err_queue(skb);
 
 	/* before exiting rcu section, make sure dst is refcounted */
 	skb_dst_force(skb);
* Unmerged path net/socket.c
