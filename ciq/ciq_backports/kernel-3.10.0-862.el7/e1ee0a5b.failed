ipv6: fib: Dump tables during registration to FIB chain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit e1ee0a5ba35d999caef94d659b4cb842e63aeb68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e1ee0a5b.failed

Dump all the FIB tables in each net namespace upon registration to the
FIB notification chain so that the callee will have a complete view of
the tables.

The integrity of the dump is ensured by a per-table sequence counter
that is incremented (under write lock) whenever a route is added or
deleted from the table.

All the sequence counters are read (under each table's read lock) and
summed, prior and after the dump. In case the counters differ, then the
dump is either restarted or the registration fails.

While it's possible for a table to be modified after its counter has
been read, this isn't really a problem. In case it happened before it
was read the second time, then the comparison at the end will fail. If
it happened afterwards, then we're guaranteed to be notified about the
change, as the notification block is registered prior to the second
read.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e1ee0a5ba35d999caef94d659b4cb842e63aeb68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
#	net/ipv6/fib6_notifier.c
#	net/ipv6/ip6_fib.c
diff --cc include/net/ip6_fib.h
index 2ee17a3a8c5d,0b3052157e6b..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -237,6 -234,9 +237,12 @@@ struct fib6_table 
  	rwlock_t		tb6_lock;
  	struct fib6_node	tb6_root;
  	struct inet_peer_base	tb6_peers;
++<<<<<<< HEAD
++=======
+ 	unsigned int		flags;
+ 	unsigned int		fib_seq;
+ #define RT6_TABLE_HAS_DFLT_ROUTER	BIT(0)
++>>>>>>> e1ee0a5ba35d (ipv6: fib: Dump tables during registration to FIB chain)
  };
  
  #define RT6_TABLE_UNSPEC	RT_TABLE_UNSPEC
@@@ -292,9 -298,20 +298,12 @@@ void fib6_gc_cleanup(void)
  
  int fib6_init(void);
  
 -int ipv6_route_open(struct inode *inode, struct file *file);
 -
 -int call_fib6_notifier(struct notifier_block *nb, struct net *net,
 -		       enum fib_event_type event_type,
 -		       struct fib_notifier_info *info);
 -int call_fib6_notifiers(struct net *net, enum fib_event_type event_type,
 -			struct fib_notifier_info *info);
 -
 -int __net_init fib6_notifier_init(struct net *net);
 -void __net_exit fib6_notifier_exit(struct net *net);
 +extern int			ipv6_route_open(struct inode *inode,
 +						struct file *file);
  
+ unsigned int fib6_tables_seq_read(struct net *net);
+ int fib6_tables_dump(struct net *net, struct notifier_block *nb);
+ 
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  int fib6_rules_init(void);
  void fib6_rules_cleanup(void);
diff --cc net/ipv6/ip6_fib.c
index 4461375cbfa9,719c10480c74..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -302,6 -303,109 +302,112 @@@ static void __net_init fib6_tables_init
  
  #endif
  
++<<<<<<< HEAD
++=======
+ unsigned int fib6_tables_seq_read(struct net *net)
+ {
+ 	unsigned int h, fib_seq = 0;
+ 
+ 	rcu_read_lock();
+ 	for (h = 0; h < FIB6_TABLE_HASHSZ; h++) {
+ 		struct hlist_head *head = &net->ipv6.fib_table_hash[h];
+ 		struct fib6_table *tb;
+ 
+ 		hlist_for_each_entry_rcu(tb, head, tb6_hlist) {
+ 			read_lock_bh(&tb->tb6_lock);
+ 			fib_seq += tb->fib_seq;
+ 			read_unlock_bh(&tb->tb6_lock);
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return fib_seq;
+ }
+ 
+ static int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,
+ 				    enum fib_event_type event_type,
+ 				    struct rt6_info *rt)
+ {
+ 	struct fib6_entry_notifier_info info = {
+ 		.rt = rt,
+ 	};
+ 
+ 	return call_fib6_notifier(nb, net, event_type, &info.info);
+ }
+ 
+ static int call_fib6_entry_notifiers(struct net *net,
+ 				     enum fib_event_type event_type,
+ 				     struct rt6_info *rt)
+ {
+ 	struct fib6_entry_notifier_info info = {
+ 		.rt = rt,
+ 	};
+ 
+ 	rt->rt6i_table->fib_seq++;
+ 	return call_fib6_notifiers(net, event_type, &info.info);
+ }
+ 
+ struct fib6_dump_arg {
+ 	struct net *net;
+ 	struct notifier_block *nb;
+ };
+ 
+ static void fib6_rt_dump(struct rt6_info *rt, struct fib6_dump_arg *arg)
+ {
+ 	if (rt == arg->net->ipv6.ip6_null_entry)
+ 		return;
+ 	call_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);
+ }
+ 
+ static int fib6_node_dump(struct fib6_walker *w)
+ {
+ 	struct rt6_info *rt;
+ 
+ 	for (rt = w->leaf; rt; rt = rt->dst.rt6_next)
+ 		fib6_rt_dump(rt, w->args);
+ 	w->leaf = NULL;
+ 	return 0;
+ }
+ 
+ static void fib6_table_dump(struct net *net, struct fib6_table *tb,
+ 			    struct fib6_walker *w)
+ {
+ 	w->root = &tb->tb6_root;
+ 	read_lock_bh(&tb->tb6_lock);
+ 	fib6_walk(net, w);
+ 	read_unlock_bh(&tb->tb6_lock);
+ }
+ 
+ /* Called with rcu_read_lock() */
+ int fib6_tables_dump(struct net *net, struct notifier_block *nb)
+ {
+ 	struct fib6_dump_arg arg;
+ 	struct fib6_walker *w;
+ 	unsigned int h;
+ 
+ 	w = kzalloc(sizeof(*w), GFP_ATOMIC);
+ 	if (!w)
+ 		return -ENOMEM;
+ 
+ 	w->func = fib6_node_dump;
+ 	arg.net = net;
+ 	arg.nb = nb;
+ 	w->args = &arg;
+ 
+ 	for (h = 0; h < FIB6_TABLE_HASHSZ; h++) {
+ 		struct hlist_head *head = &net->ipv6.fib_table_hash[h];
+ 		struct fib6_table *tb;
+ 
+ 		hlist_for_each_entry_rcu(tb, head, tb6_hlist)
+ 			fib6_table_dump(net, tb, w);
+ 	}
+ 
+ 	kfree(w);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> e1ee0a5ba35d (ipv6: fib: Dump tables during registration to FIB chain)
  static int fib6_dump_node(struct fib6_walker *w)
  {
  	int res;
* Unmerged path net/ipv6/fib6_notifier.c
* Unmerged path include/net/ip6_fib.h
* Unmerged path net/ipv6/fib6_notifier.c
* Unmerged path net/ipv6/ip6_fib.c
