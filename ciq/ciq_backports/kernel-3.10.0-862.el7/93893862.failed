path_init(): don't bother with checking MAY_EXEC for LOOKUP_ROOT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] path_init(): don't bother with checking MAY_EXEC for LOOKUP_ROOT ("Eric W. Biederman") [1487751]
Rebuild_FUZZ: 99.22%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 93893862fb7ba704ec5a6872a294c9cc2b0d4ca3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/93893862.failed

we'll hit that check in link_path_walk() anyway.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 93893862fb7ba704ec5a6872a294c9cc2b0d4ca3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index 999526d427c6,60c0a78ebca7..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -1845,37 -2116,45 +1845,49 @@@ static int link_path_walk(const char *n
  			return err;
  
  		if (err) {
 -			const char *s = get_link(nd);
 -
 -			if (IS_ERR(s))
 -				return PTR_ERR(s);
 -			err = 0;
 -			if (unlikely(!s)) {
 -				/* jumped */
 -				put_link(nd);
 -			} else {
 -				nd->stack[nd->depth - 1].name = name;
 -				name = s;
 -				continue;
 -			}
 +			err = nested_symlink(&next, nd);
 +			if (err)
 +				return err;
  		}
 -		if (unlikely(!d_can_lookup(nd->path.dentry))) {
 -			if (nd->flags & LOOKUP_RCU) {
 -				if (unlazy_walk(nd))
 -					return -ECHILD;
 -			}
 -			return -ENOTDIR;
 +		if (!d_can_lookup(nd->path.dentry)) {
 +			err = -ENOTDIR; 
 +			break;
  		}
  	}
 +	terminate_walk(nd);
 +	return err;
  }
  
 -static const char *path_init(struct nameidata *nd, unsigned flags)
 +static int path_init(int dfd, const char *name, unsigned int flags,
 +		     struct nameidata *nd, struct file **fp)
  {
++<<<<<<< HEAD
 +	int retval = 0;
++=======
+ 	const char *s = nd->name->name;
+ 
+ 	if (!*s)
+ 		flags &= ~LOOKUP_RCU;
++>>>>>>> 93893862fb7b (path_init(): don't bother with checking MAY_EXEC for LOOKUP_ROOT)
  
  	nd->last_type = LAST_ROOT; /* if there are only slashes... */
 -	nd->flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
 +	nd->flags = flags | LOOKUP_JUMPED;
  	nd->depth = 0;
  	if (flags & LOOKUP_ROOT) {
  		struct dentry *root = nd->root.dentry;
  		struct inode *inode = root->d_inode;
++<<<<<<< HEAD
 +		if (*name) {
 +			if (!d_can_lookup(root))
 +				return -ENOTDIR;
 +			retval = inode_permission(inode, MAY_EXEC);
 +			if (retval)
 +				return retval;
 +		}
++=======
+ 		if (*s && unlikely(!d_can_lookup(root)))
+ 			return ERR_PTR(-ENOTDIR);
++>>>>>>> 93893862fb7b (path_init(): don't bother with checking MAY_EXEC for LOOKUP_ROOT)
  		nd->path = nd->root;
  		nd->inode = inode;
  		if (flags & LOOKUP_RCU) {
* Unmerged path fs/namei.c
