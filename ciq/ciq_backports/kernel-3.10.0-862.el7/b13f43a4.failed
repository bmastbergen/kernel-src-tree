iwlwifi: mvm: fix packet injection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Emmanuel Grumbach <emmanuel.grumbach@intel.com>
commit b13f43a48571f0cd0fda271b5046b65f1f268db5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b13f43a4.failed

We need to have a station and a queue for the monitor
interface to be able to inject traffic. We used to have
this traffic routed to the auxiliary queue, but this queue
isn't scheduled for the station we had linked to the
monitor vif.

Allocate a new queue, link it to the monitor vif's station
and make that queue use the BE fifo.

This fixes https://bugzilla.kernel.org/show_bug.cgi?id=196715

	Cc: stable@vger.kernel.org
	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit b13f43a48571f0cd0fda271b5046b65f1f268db5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/api/txq.h
#	drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
#	drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
#	drivers/net/wireless/intel/iwlwifi/mvm/ops.c
#	drivers/net/wireless/intel/iwlwifi/mvm/sta.c
#	drivers/net/wireless/intel/iwlwifi/mvm/tx.c
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
index c5734e1a02d2,2f22e14e00fe..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
@@@ -879,8 -787,8 +879,13 @@@ static int iwl_mvm_mac_ctxt_cmd_listene
  					 u32 action)
  {
  	struct iwl_mac_ctx_cmd cmd = {};
++<<<<<<< HEAD
 +	u32 tfd_queue_msk = 0;
 +	int ret, i;
++=======
+ 	u32 tfd_queue_msk = BIT(mvm->snif_queue);
+ 	int ret;
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
  
  	WARN_ON(vif->type != NL80211_IFTYPE_MONITOR);
  
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
index 73a216524af2,6a9a25beab3f..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
@@@ -975,9 -971,10 +975,16 @@@ struct iwl_mvm 
  #endif
  
  	/* Tx queues */
++<<<<<<< HEAD
 +	u8 aux_queue;
 +	u8 first_agg_queue;
 +	u8 last_agg_queue;
++=======
+ 	u16 aux_queue;
+ 	u16 snif_queue;
+ 	u16 probe_queue;
+ 	u16 p2p_dev_queue;
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
  
  	/* Indicate if device power save is allowed */
  	u8 ps_disabled; /* u8 instead of bool to ease debugfs_create_* usage */
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/ops.c
index 4cd72d4cdc47,45470b6b351a..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c
@@@ -588,28 -621,18 +588,35 @@@ iwl_op_mode_mvm_start(struct iwl_trans 
  			goto out_free;
  	}
  
 -	mvm->fw_restart = iwlwifi_mod_params.fw_restart ? -1 : 0;
 +	mvm->restart_fw = iwlwifi_mod_params.restart_fw ? -1 : 0;
  
++<<<<<<< HEAD
 +	if (!iwl_mvm_is_dqa_supported(mvm)) {
 +		mvm->last_agg_queue = mvm->cfg->base_params->num_of_queues - 1;
++=======
+ 	mvm->aux_queue = IWL_MVM_DQA_AUX_QUEUE;
+ 	mvm->snif_queue = IWL_MVM_DQA_INJECT_MONITOR_QUEUE;
+ 	mvm->probe_queue = IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;
+ 	mvm->p2p_dev_queue = IWL_MVM_DQA_P2P_DEVICE_QUEUE;
 -
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
 +
 +		if (mvm->cfg->base_params->num_of_queues == 16) {
 +			mvm->aux_queue = 11;
 +			mvm->first_agg_queue = 12;
 +		} else {
 +			mvm->aux_queue = 15;
 +			mvm->first_agg_queue = 16;
 +		}
 +	} else {
 +		mvm->aux_queue = IWL_MVM_DQA_AUX_QUEUE;
 +		mvm->first_agg_queue = IWL_MVM_DQA_MIN_DATA_QUEUE;
 +		mvm->last_agg_queue = IWL_MVM_DQA_MAX_DATA_QUEUE;
 +	}
  	mvm->sf_state = SF_UNINIT;
 -	if (iwl_mvm_has_unified_ucode(mvm))
 -		iwl_fw_set_current_image(&mvm->fwrt, IWL_UCODE_REGULAR);
 +	if (iwl_mvm_has_new_tx_api(mvm))
 +		mvm->cur_ucode = IWL_UCODE_REGULAR;
  	else
 -		iwl_fw_set_current_image(&mvm->fwrt, IWL_UCODE_INIT);
 +		mvm->cur_ucode = IWL_UCODE_INIT;
  	mvm->drop_bcn_ap_mode = true;
  
  	mutex_init(&mvm->mutex);
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/sta.c
index 9d28db7f56aa,1add5615fc3a..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
@@@ -1657,89 -1706,71 +1657,142 @@@ static void iwl_mvm_dealloc_int_sta(str
  {
  	RCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta->sta_id], NULL);
  	memset(sta, 0, sizeof(struct iwl_mvm_int_sta));
 -	sta->sta_id = IWL_MVM_INVALID_STA;
 +	sta->sta_id = IWL_MVM_STATION_COUNT;
  }
  
 -static void iwl_mvm_enable_aux_snif_queue(struct iwl_mvm *mvm, u16 *queue,
 -					  u8 sta_id, u8 fifo)
 -{
 -	unsigned int wdg_timeout = iwlmvm_mod_params.tfd_q_hang_detect ?
 -					mvm->cfg->base_params->wd_timeout :
++<<<<<<< HEAD
 +static int iwl_mvm_add_int_sta_common(struct iwl_mvm *mvm,
 +				      struct iwl_mvm_int_sta *sta,
 +				      const u8 *addr,
 +				      u16 mac_id, u16 color)
 +{
 +	struct iwl_mvm_add_sta_cmd cmd;
 +	int ret;
 +	u32 status;
 +
 +	lockdep_assert_held(&mvm->mutex);
 +
 +	memset(&cmd, 0, sizeof(cmd));
 +	cmd.sta_id = sta->sta_id;
 +	cmd.mac_id_n_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mac_id,
 +							     color));
 +
 +	cmd.tfd_queue_msk = cpu_to_le32(sta->tfd_queue_msk);
 +	cmd.tid_disable_tx = cpu_to_le16(0xffff);
 +
 +	if (addr)
 +		memcpy(cmd.addr, addr, ETH_ALEN);
 +
 +	ret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,
 +					  iwl_mvm_add_sta_cmd_size(mvm),
 +					  &cmd, &status);
 +	if (ret)
 +		return ret;
 +
 +	switch (status & IWL_ADD_STA_STATUS_MASK) {
 +	case ADD_STA_SUCCESS:
 +		IWL_DEBUG_INFO(mvm, "Internal station added.\n");
 +		return 0;
 +	default:
 +		ret = -EIO;
 +		IWL_ERR(mvm, "Add internal station failed, status=0x%x\n",
 +			status);
 +		break;
 +	}
 +	return ret;
 +}
 +
 +int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)
++=======
++static void iwl_mvm_enable_aux_snif_queue(struct iwl_mvm *mvm, u16 *queue,
++					  u8 sta_id, u8 fifo)
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
 +{
 +	unsigned int wdg_timeout = iwlmvm_mod_params.tfd_q_hang_detect ?
 +					mvm->cfg->base_params->wd_timeout :
  					IWL_WATCHDOG_DISABLED;
 +	int ret;
 +
++<<<<<<< HEAD
 +	lockdep_assert_held(&mvm->mutex);
  
 +	/* Map Aux queue to fifo - needs to happen before adding Aux station */
 +	if (!iwl_mvm_is_dqa_supported(mvm))
 +		iwl_mvm_enable_ac_txq(mvm, mvm->aux_queue, mvm->aux_queue,
 +				      IWL_MVM_TX_FIFO_MCAST, 0, wdg_timeout);
 +
 +	/* Allocate aux station and assign to it the aux queue */
 +	ret = iwl_mvm_allocate_int_sta(mvm, &mvm->aux_sta, BIT(mvm->aux_queue),
 +				       NL80211_IFTYPE_UNSPECIFIED);
 +	if (ret)
 +		return ret;
 +
 +	if (iwl_mvm_is_dqa_supported(mvm)) {
++=======
+ 	if (iwl_mvm_has_new_tx_api(mvm)) {
+ 		int tvqm_queue =
+ 			iwl_mvm_tvqm_enable_txq(mvm, *queue, sta_id,
+ 						IWL_MAX_TID_COUNT,
+ 						wdg_timeout);
+ 		*queue = tvqm_queue;
+ 	} else {
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
  		struct iwl_trans_txq_scd_cfg cfg = {
- 			.fifo = IWL_MVM_TX_FIFO_MCAST,
- 			.sta_id = mvm->aux_sta.sta_id,
+ 			.fifo = fifo,
+ 			.sta_id = sta_id,
  			.tid = IWL_MAX_TID_COUNT,
  			.aggregate = false,
  			.frame_limit = IWL_FRAME_LIMIT,
  		};
  
- 		iwl_mvm_enable_txq(mvm, mvm->aux_queue, mvm->aux_queue, 0, &cfg,
- 				   wdg_timeout);
+ 		iwl_mvm_enable_txq(mvm, *queue, *queue, 0, &cfg, wdg_timeout);
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)
+ {
+ 	int ret;
+ 
+ 	lockdep_assert_held(&mvm->mutex);
+ 
+ 	/* Allocate aux station and assign to it the aux queue */
+ 	ret = iwl_mvm_allocate_int_sta(mvm, &mvm->aux_sta, BIT(mvm->aux_queue),
+ 				       NL80211_IFTYPE_UNSPECIFIED,
+ 				       IWL_STA_AUX_ACTIVITY);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Map Aux queue to fifo - needs to happen before adding Aux station */
+ 	if (!iwl_mvm_has_new_tx_api(mvm))
+ 		iwl_mvm_enable_aux_snif_queue(mvm, &mvm->aux_queue,
+ 					      mvm->aux_sta.sta_id,
+ 					      IWL_MVM_TX_FIFO_MCAST);
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
  
  	ret = iwl_mvm_add_int_sta_common(mvm, &mvm->aux_sta, NULL,
  					 MAC_INDEX_AUX, 0);
 -	if (ret) {
 +
 +	if (ret)
  		iwl_mvm_dealloc_int_sta(mvm, &mvm->aux_sta);
++<<<<<<< HEAD
 +	return ret;
++=======
+ 		return ret;
+ 	}
+ 
+ 	/*
+ 	 * For a000 firmware and on we cannot add queue to a station unknown
+ 	 * to firmware so enable queue here - after the station was added
+ 	 */
+ 	if (iwl_mvm_has_new_tx_api(mvm))
+ 		iwl_mvm_enable_aux_snif_queue(mvm, &mvm->aux_queue,
+ 					      mvm->aux_sta.sta_id,
+ 					      IWL_MVM_TX_FIFO_MCAST);
+ 
+ 	return 0;
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
  }
  
  int iwl_mvm_add_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/tx.c
index 1ba0a6f55503,333bcb75b8af..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
@@@ -593,17 -650,15 +593,23 @@@ int iwl_mvm_tx_skb_non_sta(struct iwl_m
  							   hdr->frame_control);
  			if (queue < 0)
  				return -1;
 +
  		} else if (info.control.vif->type == NL80211_IFTYPE_STATION &&
  			   is_multicast_ether_addr(hdr->addr1)) {
 -			u8 ap_sta_id = READ_ONCE(mvmvif->ap_sta_id);
 +			u8 ap_sta_id = ACCESS_ONCE(mvmvif->ap_sta_id);
  
 -			if (ap_sta_id != IWL_MVM_INVALID_STA)
 +			if (ap_sta_id != IWL_MVM_STATION_COUNT)
  				sta_id = ap_sta_id;
++<<<<<<< HEAD
 +		} else if (iwl_mvm_is_dqa_supported(mvm) &&
 +			   info.control.vif->type == NL80211_IFTYPE_STATION &&
 +			   queue != mvm->aux_queue) {
 +			queue = IWL_MVM_DQA_BSS_CLIENT_QUEUE;
++=======
+ 		} else if (info.control.vif->type == NL80211_IFTYPE_MONITOR) {
+ 			queue = mvm->snif_queue;
+ 			sta_id = mvm->snif_sta.sta_id;
++>>>>>>> b13f43a48571 (iwlwifi: mvm: fix packet injection)
  		}
  	}
  
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/txq.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/txq.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/ops.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/sta.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/tx.c
