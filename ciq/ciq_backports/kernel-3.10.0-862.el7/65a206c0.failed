net/sched: Change act_api and act_xxx modules to use IDR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: Change act_api and act_xxx modules to use IDR (Ivan Vecera) [1445420]
Rebuild_FUZZ: 96.30%
commit-author Chris Mi <chrism@mellanox.com>
commit 65a206c01e8e7ffe971477a36419422099216eff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/65a206c0.failed

Typically, each TC filter has its own action. All the actions of the
same type are saved in its hash table. But the hash buckets are too
small that it degrades to a list. And the performance is greatly
affected. For example, it takes about 0m11.914s to insert 64K rules.
If we convert the hash table to IDR, it only takes about 0m1.500s.
The improvement is huge.

But please note that the test result is based on previous patch that
cls_flower uses IDR.

	Signed-off-by: Chris Mi <chrism@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 65a206c01e8e7ffe971477a36419422099216eff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	net/sched/act_api.c
#	net/sched/act_bpf.c
#	net/sched/act_connmark.c
#	net/sched/act_csum.c
#	net/sched/act_gact.c
#	net/sched/act_ife.c
#	net/sched/act_ipt.c
#	net/sched/act_mirred.c
#	net/sched/act_nat.c
#	net/sched/act_pedit.c
#	net/sched/act_police.c
#	net/sched/act_simple.c
#	net/sched/act_skbedit.c
#	net/sched/act_skbmod.c
#	net/sched/act_tunnel_key.c
#	net/sched/act_vlan.c
diff --cc include/net/act_api.h
index 7eba1aba336b,8f3d5d8b5ae0..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -7,64 -7,50 +7,108 @@@
  
  #include <net/sch_generic.h>
  #include <net/pkt_sched.h>
 -#include <net/net_namespace.h>
 -#include <net/netns/generic.h>
  
++<<<<<<< HEAD
 +struct tcf_common {
 +	struct hlist_node		tcfc_head;
 +	u32				tcfc_index;
 +	int				tcfc_refcnt;
 +	int				tcfc_bindcnt;
 +	u32				tcfc_capab;
 +	int				tcfc_action;
 +	struct tcf_t			tcfc_tm;
 +	struct gnet_stats_basic_packed	tcfc_bstats;
 +	struct gnet_stats_queue		tcfc_qstats;
 +	struct gnet_stats_rate_est64	tcfc_rate_est;
 +	spinlock_t			tcfc_lock;
 +	struct rcu_head			tcfc_rcu;
 +	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
 +	struct gnet_stats_queue __percpu *cpu_qstats;
 +	struct tc_cookie	*act_cookie;
 +};
 +#define tcf_head	common.tcfc_head
 +#define tcf_index	common.tcfc_index
 +#define tcf_refcnt	common.tcfc_refcnt
 +#define tcf_bindcnt	common.tcfc_bindcnt
 +#define tcf_capab	common.tcfc_capab
 +#define tcf_action	common.tcfc_action
 +#define tcf_tm		common.tcfc_tm
 +#define tcf_bstats	common.tcfc_bstats
 +#define tcf_qstats	common.tcfc_qstats
 +#define tcf_rate_est	common.tcfc_rate_est
 +#define tcf_lock	common.tcfc_lock
 +#define tcf_rcu		common.tcfc_rcu
 +
 +struct tcf_hashinfo {
 +	struct hlist_head	*htab;
 +	unsigned int		hmask;
 +	spinlock_t		lock;
 +	u32			index;
 +};
 +
 +static inline unsigned int tcf_hash(u32 index, unsigned int hmask)
 +{
 +	return index & hmask;
 +}
 +
 +static inline int tcf_hashinfo_init(struct tcf_hashinfo *hf, unsigned int mask)
 +{
 +	int i;
 +
 +	spin_lock_init(&hf->lock);
 +	hf->index = 0;
 +	hf->hmask = mask;
 +	hf->htab = kzalloc((mask + 1) * sizeof(struct hlist_head),
 +			   GFP_KERNEL);
 +	if (!hf->htab)
 +		return -ENOMEM;
 +	for (i = 0; i < mask + 1; i++)
 +		INIT_HLIST_HEAD(&hf->htab[i]);
 +	return 0;
 +}
++=======
+ struct tcf_idrinfo {
+ 	spinlock_t	lock;
+ 	struct idr	action_idr;
+ };
+ 
+ struct tc_action_ops;
+ 
+ struct tc_action {
+ 	const struct tc_action_ops	*ops;
+ 	__u32				type; /* for backward compat(TCA_OLD_COMPAT) */
+ 	__u32				order;
+ 	struct list_head		list;
+ 	struct tcf_idrinfo		*idrinfo;
+ 
+ 	u32				tcfa_index;
+ 	int				tcfa_refcnt;
+ 	int				tcfa_bindcnt;
+ 	u32				tcfa_capab;
+ 	int				tcfa_action;
+ 	struct tcf_t			tcfa_tm;
+ 	struct gnet_stats_basic_packed	tcfa_bstats;
+ 	struct gnet_stats_queue		tcfa_qstats;
+ 	struct net_rate_estimator __rcu *tcfa_rate_est;
+ 	spinlock_t			tcfa_lock;
+ 	struct rcu_head			tcfa_rcu;
+ 	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
+ 	struct gnet_stats_queue __percpu *cpu_qstats;
+ 	struct tc_cookie	*act_cookie;
+ 	struct tcf_chain	*goto_chain;
+ };
+ #define tcf_index	common.tcfa_index
+ #define tcf_refcnt	common.tcfa_refcnt
+ #define tcf_bindcnt	common.tcfa_bindcnt
+ #define tcf_capab	common.tcfa_capab
+ #define tcf_action	common.tcfa_action
+ #define tcf_tm		common.tcfa_tm
+ #define tcf_bstats	common.tcfa_bstats
+ #define tcf_qstats	common.tcfa_qstats
+ #define tcf_rate_est	common.tcfa_rate_est
+ #define tcf_lock	common.tcfa_lock
+ #define tcf_rcu		common.tcfa_rcu
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  /* Update lastuse only if needed, to avoid dirtying a cache line.
   * We use a temp variable to avoid fetching jiffies twice.
@@@ -120,32 -99,66 +164,75 @@@ struct tc_action_ops 
  			   struct net_device **mirred_dev);
  };
  
++<<<<<<< HEAD
 +int tcf_hash_search(struct tc_action *a, u32 index);
 +u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats);
 +void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 +void tcf_hash_insert(struct tc_action *a);
++=======
+ struct tc_action_net {
+ 	struct tcf_idrinfo *idrinfo;
+ 	const struct tc_action_ops *ops;
+ };
+ 
+ static inline
+ int tc_action_net_init(struct tc_action_net *tn,
+ 		       const struct tc_action_ops *ops)
+ {
+ 	int err = 0;
  
- int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
+ 	tn->idrinfo = kmalloc(sizeof(*tn->idrinfo), GFP_KERNEL);
+ 	if (!tn->idrinfo)
+ 		return -ENOMEM;
+ 	tn->ops = ops;
+ 	spin_lock_init(&tn->idrinfo->lock);
+ 	idr_init(&tn->idrinfo->action_idr);
+ 	return err;
+ }
+ 
+ void tcf_idrinfo_destroy(const struct tc_action_ops *ops,
+ 			 struct tcf_idrinfo *idrinfo);
+ 
+ static inline void tc_action_net_exit(struct tc_action_net *tn)
+ {
+ 	tcf_idrinfo_destroy(tn->ops, tn->idrinfo);
+ 	kfree(tn->idrinfo);
+ }
  
- static inline int tcf_hash_release(struct tc_action *a, bool bind)
+ int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
+ 		       struct netlink_callback *cb, int type,
+ 		       const struct tc_action_ops *ops);
+ int tcf_idr_search(struct tc_action_net *tn, struct tc_action **a, u32 index);
+ bool tcf_idr_check(struct tc_action_net *tn, u32 index, struct tc_action **a,
+ 		    int bind);
+ int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		   struct tc_action **a, const struct tc_action_ops *ops,
+ 		   int bind, bool cpustats);
+ void tcf_idr_cleanup(struct tc_action *a, struct nlattr *est);
+ void tcf_idr_insert(struct tc_action_net *tn, struct tc_action *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
+ 
+ int __tcf_idr_release(struct tc_action *a, bool bind, bool strict);
+ 
+ static inline int tcf_idr_release(struct tc_action *a, bool bind)
  {
- 	return __tcf_hash_release(a, bind, false);
+ 	return __tcf_idr_release(a, bind, false);
  }
  
 -int tcf_register_action(struct tc_action_ops *a, struct pernet_operations *ops);
 -int tcf_unregister_action(struct tc_action_ops *a,
 -			  struct pernet_operations *ops);
 +int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
 +int tcf_unregister_action(struct tc_action_ops *a);
  int tcf_action_destroy(struct list_head *actions, int bind);
 -int tcf_action_exec(struct sk_buff *skb, struct tc_action **actions,
 -		    int nr_actions, struct tcf_result *res);
 -int tcf_action_init(struct net *net, struct tcf_proto *tp, struct nlattr *nla,
 -		    struct nlattr *est, char *name, int ovr, int bind,
 -		    struct list_head *actions);
 -struct tc_action *tcf_action_init_1(struct net *net, struct tcf_proto *tp,
 -				    struct nlattr *nla, struct nlattr *est,
 -				    char *name, int ovr, int bind);
 +int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
 +		    struct tcf_result *res);
 +int tcf_action_init(struct net *net, struct nlattr *nla,
 +				  struct nlattr *est, char *n, int ovr,
 +				  int bind, struct list_head *);
 +struct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,
 +				    struct nlattr *est, char *n, int ovr,
 +				    int bind);
  int tcf_action_dump(struct sk_buff *skb, struct list_head *, int, int);
  int tcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int, int);
  int tcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int, int);
diff --cc net/sched/act_api.c
index f6d266c05d33,0eb545bcb247..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -43,89 -70,91 +43,159 @@@ static void free_tcf(struct rcu_head *h
  	kfree(p);
  }
  
++<<<<<<< HEAD
 +static void tcf_hash_destroy(struct tc_action *a)
 +{
 +	struct tcf_common *p = a->priv;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +
 +	spin_lock_bh(&hinfo->lock);
 +	hlist_del(&p->tcfc_head);
 +	spin_unlock_bh(&hinfo->lock);
 +	gen_kill_estimator(&p->tcfc_bstats,
 +			   &p->tcfc_rate_est);
++=======
+ static void tcf_idr_remove(struct tcf_idrinfo *idrinfo, struct tc_action *p)
+ {
+ 	spin_lock_bh(&idrinfo->lock);
+ 	idr_remove_ext(&idrinfo->action_idr, p->tcfa_index);
+ 	spin_unlock_bh(&idrinfo->lock);
+ 	gen_kill_estimator(&p->tcfa_rate_est);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	/*
 -	 * gen_estimator est_timer() might access p->tcfa_lock
 +	 * gen_estimator est_timer() might access p->tcfc_lock
  	 * or bstats, wait a RCU grace period before freeing p
  	 */
 -	call_rcu(&p->tcfa_rcu, free_tcf);
 +	call_rcu(&p->tcfc_rcu, free_tcf);
  }
  
++<<<<<<< HEAD
 +int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)
++=======
+ int __tcf_idr_release(struct tc_action *p, bool bind, bool strict)
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  {
 +	struct tcf_common *p = a->priv;
  	int ret = 0;
  
  	if (p) {
  		if (bind)
 -			p->tcfa_bindcnt--;
 -		else if (strict && p->tcfa_bindcnt > 0)
 +			p->tcfc_bindcnt--;
 +		else if (strict && p->tcfc_bindcnt > 0)
  			return -EPERM;
  
++<<<<<<< HEAD
 +		p->tcfc_refcnt--;
 +		if (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {
 +			if (a->ops->cleanup)
 +				a->ops->cleanup(a, bind);
 +			tcf_hash_destroy(a);
++=======
+ 		p->tcfa_refcnt--;
+ 		if (p->tcfa_bindcnt <= 0 && p->tcfa_refcnt <= 0) {
+ 			if (p->ops->cleanup)
+ 				p->ops->cleanup(p, bind);
+ 			tcf_idr_remove(p->idrinfo, p);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			ret = ACT_P_DELETED;
  		}
  	}
  
  	return ret;
  }
- EXPORT_SYMBOL(__tcf_hash_release);
+ EXPORT_SYMBOL(__tcf_idr_release);
  
++<<<<<<< HEAD
 +static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			   struct tc_action *a)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct tcf_common *p;
 +	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
++=======
+ static int tcf_dump_walker(struct tcf_idrinfo *idrinfo, struct sk_buff *skb,
+ 			   struct netlink_callback *cb)
+ {
+ 	int err = 0, index = -1, s_i = 0, n_i = 0;
+ 	u32 act_flags = cb->args[2];
+ 	unsigned long jiffy_since = cb->args[3];
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	struct nlattr *nest;
+ 	struct idr *idr = &idrinfo->action_idr;
+ 	struct tc_action *p;
+ 	unsigned long id = 1;
  
- 	spin_lock_bh(&hinfo->lock);
+ 	spin_lock_bh(&idrinfo->lock);
  
  	s_i = cb->args[0];
  
++<<<<<<< HEAD
 +	for (i = 0; i < (hinfo->hmask + 1); i++) {
 +		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
 +
 +		hlist_for_each_entry_rcu(p, head, tcfc_head) {
 +			index++;
 +			if (index < s_i)
 +				continue;
 +			a->priv = p;
 +			a->order = n_i;
 +
 +			nest = nla_nest_start(skb, a->order);
 +			if (nest == NULL)
 +				goto nla_put_failure;
 +			err = tcf_action_dump_1(skb, a, 0, 0);
 +			if (err < 0) {
 +				index--;
 +				nlmsg_trim(skb, nest);
 +				goto done;
 +			}
 +			nla_nest_end(skb, nest);
 +			n_i++;
 +			if (n_i >= TCA_ACT_MAX_PRIO)
 +				goto done;
++=======
+ 	idr_for_each_entry_ext(idr, p, id) {
+ 		index++;
+ 		if (index < s_i)
+ 			continue;
+ 
+ 		if (jiffy_since &&
+ 		    time_after(jiffy_since,
+ 			       (unsigned long)p->tcfa_tm.lastuse))
+ 			continue;
+ 
+ 		nest = nla_nest_start(skb, n_i);
+ 		if (!nest)
+ 			goto nla_put_failure;
+ 		err = tcf_action_dump_1(skb, p, 0, 0);
+ 		if (err < 0) {
+ 			index--;
+ 			nlmsg_trim(skb, nest);
+ 			goto done;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		}
+ 		nla_nest_end(skb, nest);
+ 		n_i++;
+ 		if (!(act_flags & TCA_FLAG_LARGE_DUMP_ON) &&
+ 		    n_i >= TCA_ACT_MAX_PRIO)
+ 			goto done;
  	}
  done:
++<<<<<<< HEAD
 +	spin_unlock_bh(&hinfo->lock);
 +	if (n_i)
 +		cb->args[0] += n_i;
++=======
+ 	if (index >= 0)
+ 		cb->args[0] = index + 1;
+ 
+ 	spin_unlock_bh(&idrinfo->lock);
+ 	if (n_i) {
+ 		if (act_flags & TCA_FLAG_LARGE_DUMP_ON)
+ 			cb->args[1] = n_i;
+ 	}
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return n_i;
  
  nla_put_failure:
@@@ -133,31 -162,29 +203,50 @@@
  	goto done;
  }
  
++<<<<<<< HEAD
 +static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)
++=======
+ static int tcf_del_walker(struct tcf_idrinfo *idrinfo, struct sk_buff *skb,
+ 			  const struct tc_action_ops *ops)
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  {
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct hlist_head *head;
 +	struct hlist_node *n;
 +	struct tcf_common *p;
  	struct nlattr *nest;
- 	int i = 0, n_i = 0;
+ 	int n_i = 0;
  	int ret = -EINVAL;
+ 	struct idr *idr = &idrinfo->action_idr;
+ 	struct tc_action *p;
+ 	unsigned long id = 1;
  
 -	nest = nla_nest_start(skb, 0);
 +	nest = nla_nest_start(skb, a->order);
  	if (nest == NULL)
  		goto nla_put_failure;
 -	if (nla_put_string(skb, TCA_KIND, ops->kind))
 +	if (nla_put_string(skb, TCA_KIND, a->ops->kind))
  		goto nla_put_failure;
++<<<<<<< HEAD
 +	for (i = 0; i < (hinfo->hmask + 1); i++) {
 +		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
 +		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
 +			a->priv = p;
 +			ret = __tcf_hash_release(a, false, true);
 +			if (ret == ACT_P_DELETED) {
 +				module_put(a->ops->owner);
 +				n_i++;
 +			} else if (ret < 0)
 +				goto nla_put_failure;
++=======
+ 
+ 	idr_for_each_entry_ext(idr, p, id) {
+ 		ret = __tcf_idr_release(p, false, true);
+ 		if (ret == ACT_P_DELETED) {
+ 			module_put(p->ops->owner);
+ 			n_i++;
+ 		} else if (ret < 0) {
+ 			goto nla_put_failure;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		}
  	}
  	if (nla_put_u32(skb, TCA_FCNT, n_i))
@@@ -170,92 -197,81 +259,139 @@@ nla_put_failure
  	return ret;
  }
  
 -int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
 -		       struct netlink_callback *cb, int type,
 -		       const struct tc_action_ops *ops)
 +static int tcf_generic_walker(struct sk_buff *skb, struct netlink_callback *cb,
 +			      int type, struct tc_action *a)
  {
++<<<<<<< HEAD
 +	if (type == RTM_DELACTION) {
 +		return tcf_del_walker(skb, a);
 +	} else if (type == RTM_GETACTION) {
 +		return tcf_dump_walker(skb, cb, a);
++=======
+ 	struct tcf_idrinfo *idrinfo = tn->idrinfo;
+ 
+ 	if (type == RTM_DELACTION) {
+ 		return tcf_del_walker(idrinfo, skb, ops);
+ 	} else if (type == RTM_GETACTION) {
+ 		return tcf_dump_walker(idrinfo, skb, cb);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	} else {
  		WARN(1, "tcf_generic_walker: unknown action %d\n", type);
  		return -EINVAL;
  	}
  }
 -EXPORT_SYMBOL(tcf_generic_walker);
  
++<<<<<<< HEAD
 +static struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo)
 +{
 +	struct tcf_common *p = NULL;
 +	struct hlist_head *head;
 +
 +	spin_lock_bh(&hinfo->lock);
 +	head = &hinfo->htab[tcf_hash(index, hinfo->hmask)];
 +	hlist_for_each_entry_rcu(p, head, tcfc_head)
 +		if (p->tcfc_index == index)
 +			break;
 +	spin_unlock_bh(&hinfo->lock);
++=======
+ static struct tc_action *tcf_idr_lookup(u32 index, struct tcf_idrinfo *idrinfo)
+ {
+ 	struct tc_action *p = NULL;
+ 
+ 	spin_lock_bh(&idrinfo->lock);
+ 	p = idr_find_ext(&idrinfo->action_idr, index);
+ 	spin_unlock_bh(&idrinfo->lock);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  	return p;
  }
  
++<<<<<<< HEAD
 +u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo)
 +{
 +	u32 val = hinfo->index;
 +
 +	do {
 +		if (++val == 0)
 +			val = 1;
 +	} while (tcf_hash_lookup(val, hinfo));
 +
 +	hinfo->index = val;
 +	return val;
 +}
 +EXPORT_SYMBOL(tcf_hash_new_index);
 +
 +int tcf_hash_search(struct tc_action *a, u32 index)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = tcf_hash_lookup(index, hinfo);
++=======
+ int tcf_idr_search(struct tc_action_net *tn, struct tc_action **a, u32 index)
+ {
+ 	struct tcf_idrinfo *idrinfo = tn->idrinfo;
+ 	struct tc_action *p = tcf_idr_lookup(index, idrinfo);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  	if (p) {
 -		*a = p;
 +		a->priv = p;
  		return 1;
  	}
  	return 0;
  }
- EXPORT_SYMBOL(tcf_hash_search);
+ EXPORT_SYMBOL(tcf_idr_search);
  
++<<<<<<< HEAD
 +int tcf_hash_check(u32 index, struct tc_action *a, int bind)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = NULL;
 +	if (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {
++=======
+ bool tcf_idr_check(struct tc_action_net *tn, u32 index, struct tc_action **a,
+ 		   int bind)
+ {
+ 	struct tcf_idrinfo *idrinfo = tn->idrinfo;
+ 	struct tc_action *p = tcf_idr_lookup(index, idrinfo);
+ 
+ 	if (index && p) {
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (bind)
 -			p->tcfa_bindcnt++;
 -		p->tcfa_refcnt++;
 -		*a = p;
 -		return true;
 +			p->tcfc_bindcnt++;
 +		p->tcfc_refcnt++;
 +		a->priv = p;
 +		return 1;
  	}
 -	return false;
 +	return 0;
  }
- EXPORT_SYMBOL(tcf_hash_check);
+ EXPORT_SYMBOL(tcf_idr_check);
  
- void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est)
+ void tcf_idr_cleanup(struct tc_action *a, struct nlattr *est)
  {
 +	struct tcf_common *pc = a->priv;
  	if (est)
 -		gen_kill_estimator(&a->tcfa_rate_est);
 -	call_rcu(&a->tcfa_rcu, free_tcf);
 +		gen_kill_estimator(&pc->tcfc_bstats,
 +				   &pc->tcfc_rate_est);
 +	call_rcu(&pc->tcfc_rcu, free_tcf);
  }
- EXPORT_SYMBOL(tcf_hash_cleanup);
+ EXPORT_SYMBOL(tcf_idr_cleanup);
  
++<<<<<<< HEAD
 +int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
 +		    int size, int bind, bool cpustats)
 +{
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	struct tcf_common *p = kzalloc(size, GFP_KERNEL);
++=======
+ int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
+ 		   struct tc_action **a, const struct tc_action_ops *ops,
+ 		   int bind, bool cpustats)
+ {
+ 	struct tc_action *p = kzalloc(ops->size, GFP_KERNEL);
+ 	struct tcf_idrinfo *idrinfo = tn->idrinfo;
+ 	struct idr *idr = &idrinfo->action_idr;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	int err = -ENOMEM;
+ 	unsigned long idr_index;
  
  	if (unlikely(!p))
  		return -ENOMEM;
@@@ -277,64 -293,77 +413,130 @@@ err2
  			goto err1;
  		}
  	}
++<<<<<<< HEAD
 +	spin_lock_init(&p->tcfc_lock);
 +	INIT_HLIST_NODE(&p->tcfc_head);
 +	p->tcfc_index = index ? index : tcf_hash_new_index(hinfo);
 +	p->tcfc_tm.install = jiffies;
 +	p->tcfc_tm.lastuse = jiffies;
 +	p->tcfc_tm.firstuse = 0;
++=======
+ 	spin_lock_init(&p->tcfa_lock);
+ 	/* user doesn't specify an index */
+ 	if (!index) {
+ 		spin_lock_bh(&idrinfo->lock);
+ 		err = idr_alloc_ext(idr, NULL, &idr_index, 1, 0,
+ 				    GFP_KERNEL);
+ 		spin_unlock_bh(&idrinfo->lock);
+ 		if (err) {
+ err3:
+ 			free_percpu(p->cpu_qstats);
+ 			goto err2;
+ 		}
+ 		p->tcfa_index = idr_index;
+ 	} else {
+ 		spin_lock_bh(&idrinfo->lock);
+ 		err = idr_alloc_ext(idr, NULL, NULL, index, index + 1,
+ 				    GFP_KERNEL);
+ 		spin_unlock_bh(&idrinfo->lock);
+ 		if (err)
+ 			goto err3;
+ 		p->tcfa_index = index;
+ 	}
+ 
+ 	p->tcfa_tm.install = jiffies;
+ 	p->tcfa_tm.lastuse = jiffies;
+ 	p->tcfa_tm.firstuse = 0;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	if (est) {
 -		err = gen_new_estimator(&p->tcfa_bstats, p->cpu_bstats,
 -					&p->tcfa_rate_est,
 -					&p->tcfa_lock, NULL, est);
 +		err = gen_new_estimator(&p->tcfc_bstats, p->cpu_bstats,
 +					&p->tcfc_rate_est,
 +					&p->tcfc_lock, NULL, est);
  		if (err) {
- 			free_percpu(p->cpu_qstats);
- 			goto err2;
+ 			goto err3;
  		}
  	}
  
++<<<<<<< HEAD
 +	a->priv = (void *) p;
++=======
+ 	p->idrinfo = idrinfo;
+ 	p->ops = ops;
+ 	INIT_LIST_HEAD(&p->list);
+ 	*a = p;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return 0;
  }
- EXPORT_SYMBOL(tcf_hash_create);
+ EXPORT_SYMBOL(tcf_idr_create);
  
++<<<<<<< HEAD
 +void tcf_hash_insert(struct tc_action *a)
 +{
 +	struct tcf_common *p = a->priv;
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 +	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
 +
 +	spin_lock_bh(&hinfo->lock);
 +	hlist_add_head(&p->tcfc_head, &hinfo->htab[h]);
 +	spin_unlock_bh(&hinfo->lock);
++=======
+ void tcf_idr_insert(struct tc_action_net *tn, struct tc_action *a)
+ {
+ 	struct tcf_idrinfo *idrinfo = tn->idrinfo;
+ 
+ 	spin_lock_bh(&idrinfo->lock);
+ 	idr_replace_ext(&idrinfo->action_idr, a, a->tcfa_index);
+ 	spin_unlock_bh(&idrinfo->lock);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  }
- EXPORT_SYMBOL(tcf_hash_insert);
+ EXPORT_SYMBOL(tcf_idr_insert);
  
++<<<<<<< HEAD
 +static void tcf_hashinfo_destroy(const struct tc_action_ops *ops)
 +{
 +	struct tcf_hashinfo *hinfo = ops->hinfo;
 +	struct tc_action a = {
 +		.ops = ops,
 +	};
 +	int i;
 +
 +	for (i = 0; i < hinfo->hmask + 1; i++) {
 +		struct tcf_common *p;
 +		struct hlist_node *n;
 +
 +		hlist_for_each_entry_safe(p, n, &hinfo->htab[i], tcfc_head) {
 +			int ret;
 +
 +			a.priv = p;
 +			ret = __tcf_hash_release(&a, false, true);
 +			if (ret == ACT_P_DELETED)
 +				module_put(ops->owner);
 +			else if (ret < 0)
 +				return;
 +		}
++=======
+ void tcf_idrinfo_destroy(const struct tc_action_ops *ops,
+ 			 struct tcf_idrinfo *idrinfo)
+ {
+ 	struct idr *idr = &idrinfo->action_idr;
+ 	struct tc_action *p;
+ 	int ret;
+ 	unsigned long id = 1;
+ 
+ 	idr_for_each_entry_ext(idr, p, id) {
+ 		ret = __tcf_idr_release(p, false, true);
+ 		if (ret == ACT_P_DELETED)
+ 			module_put(ops->owner);
+ 		else if (ret < 0)
+ 			return;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	}
- 	kfree(hinfo->htab);
+ 	idr_destroy(&idrinfo->action_idr);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL(tcf_idrinfo_destroy);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  static LIST_HEAD(act_base);
  static DEFINE_RWLOCK(act_mod_lock);
diff --cc net/sched/act_csum.c
index 8090d0537677,1c40caadcff9..000000000000
--- a/net/sched/act_csum.c
+++ b/net/sched/act_csum.c
@@@ -62,16 -65,16 +60,26 @@@ static int tcf_csum_init(struct net *n
  		return -EINVAL;
  	parm = nla_data(tb[TCA_CSUM_PARMS]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*p),
 +				      bind, false);
++=======
+ 	if (!tcf_idr_check(tn, parm->index, a, bind)) {
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_csum_ops, bind, false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)/* dont override defaults */
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -83,7 -86,7 +91,11 @@@
  	spin_unlock_bh(&p->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  	return ret;
  }
@@@ -600,6 -594,22 +612,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_csum_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_csum_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_csum_ops = {
  	.kind		= "csum",
  	.type		= TCA_ACT_CSUM,
@@@ -607,6 -617,30 +638,33 @@@
  	.act		= tcf_csum,
  	.dump		= tcf_csum_dump,
  	.init		= tcf_csum_init,
++<<<<<<< HEAD
++=======
+ 	.walk		= tcf_csum_walker,
+ 	.lookup		= tcf_csum_search,
+ 	.size		= sizeof(struct tcf_csum),
+ };
+ 
+ static __net_init int csum_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_csum_ops);
+ }
+ 
+ static void __net_exit csum_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, csum_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations csum_net_ops = {
+ 	.init = csum_init_net,
+ 	.exit = csum_exit_net,
+ 	.id   = &csum_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_DESCRIPTION("Checksum updating actions");
diff --cc net/sched/act_gact.c
index 8f8ca0c64f9d,e29a48ef7fc3..000000000000
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@@ -23,7 -23,8 +23,12 @@@
  #include <linux/tc_act/tc_gact.h>
  #include <net/tc_act/tc_gact.h>
  
++<<<<<<< HEAD
 +#define GACT_TAB_MASK	15
++=======
+ static unsigned int gact_net_id;
+ static struct tc_action_ops act_gact_ops;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  #ifdef CONFIG_GACT_PROB
  static int gact_net_rand(struct tcf_gact *gact)
@@@ -88,16 -90,16 +93,26 @@@ static int tcf_gact_init(struct net *ne
  	}
  #endif
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*gact),
 +				      bind, true);
++=======
+ 	if (!tcf_idr_check(tn, parm->index, a, bind)) {
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_gact_ops, bind, true);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)/* dont override defaults */
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -118,7 -120,7 +133,11 @@@
  	}
  #endif
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  }
  
@@@ -197,6 -199,22 +216,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_gact_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_gact_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_gact_ops = {
  	.kind		=	"gact",
  	.type		=	TCA_ACT_GACT,
@@@ -205,6 -223,30 +243,33 @@@
  	.stats_update	=	tcf_gact_stats_update,
  	.dump		=	tcf_gact_dump,
  	.init		=	tcf_gact_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_gact_walker,
+ 	.lookup		=	tcf_gact_search,
+ 	.size		=	sizeof(struct tcf_gact),
+ };
+ 
+ static __net_init int gact_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_gact_ops);
+ }
+ 
+ static void __net_exit gact_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, gact_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations gact_net_ops = {
+ 	.init = gact_init_net,
+ 	.exit = gact_exit_net,
+ 	.id   = &gact_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002-4)");
diff --cc net/sched/act_ipt.c
index 014563af32c0,d9e399a7e3d5..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -28,10 -28,14 +28,21 @@@
  #include <linux/netfilter_ipv4/ip_tables.h>
  
  
++<<<<<<< HEAD
 +#define IPT_TAB_MASK     15
 +
 +static int ipt_init_target(struct xt_entry_target *t, char *table,
 +			   unsigned int hook)
++=======
+ static unsigned int ipt_net_id;
+ static struct tc_action_ops act_ipt_ops;
+ 
+ static unsigned int xt_net_id;
+ static struct tc_action_ops act_xt_ops;
+ 
+ static int ipt_init_target(struct net *net, struct xt_entry_target *t,
+ 			   char *table, unsigned int hook)
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  {
  	struct xt_tgchk_param par;
  	struct xt_target *target;
@@@ -115,15 -116,33 +126,42 @@@ static int tcf_ipt_init(struct net *net
  	if (tb[TCA_IPT_INDEX] != NULL)
  		index = nla_get_u32(tb[TCA_IPT_INDEX]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(index, a, bind) ) {
 +		ret = tcf_hash_create(index, est, a, sizeof(*ipt), bind, false);
++=======
+ 	exists = tcf_idr_check(tn, index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (tb[TCA_IPT_HOOK] == NULL || tb[TCA_IPT_TARG] == NULL) {
+ 		if (exists)
+ 			tcf_idr_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	td = (struct xt_entry_target *)nla_data(tb[TCA_IPT_TARG]);
+ 	if (nla_len(tb[TCA_IPT_TARG]) < td->u.target_size) {
+ 		if (exists)
+ 			tcf_idr_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!exists) {
+ 		ret = tcf_idr_create(tn, index, est, a, ops, bind,
+ 				     false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)/* dont override defaults */
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  		if (!ovr)
  			return -EEXIST;
@@@ -159,7 -178,7 +197,11 @@@
  	ipt->tcfi_hook  = hook;
  	spin_unlock_bh(&ipt->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  
  err3:
@@@ -168,7 -187,7 +210,11 @@@ err2
  	kfree(tname);
  err1:
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_cleanup(a, est);
++=======
+ 		tcf_idr_cleanup(*a, est);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return err;
  }
  
@@@ -263,6 -301,22 +309,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_ipt_walker(struct net *net, struct sk_buff *skb,
+ 			  struct netlink_callback *cb, int type,
+ 			  const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_ipt_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_ipt_ops = {
  	.kind		=	"ipt",
  	.type		=	TCA_ACT_IPT,
@@@ -271,16 -325,80 +336,84 @@@
  	.dump		=	tcf_ipt_dump,
  	.cleanup	=	tcf_ipt_release,
  	.init		=	tcf_ipt_init,
 -	.walk		=	tcf_ipt_walker,
 -	.lookup		=	tcf_ipt_search,
 -	.size		=	sizeof(struct tcf_ipt),
  };
  
++<<<<<<< HEAD
++=======
+ static __net_init int ipt_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_ipt_ops);
+ }
+ 
+ static void __net_exit ipt_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, ipt_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations ipt_net_ops = {
+ 	.init = ipt_init_net,
+ 	.exit = ipt_exit_net,
+ 	.id   = &ipt_net_id,
+ 	.size = sizeof(struct tc_action_net),
+ };
+ 
+ static int tcf_xt_walker(struct net *net, struct sk_buff *skb,
+ 			 struct netlink_callback *cb, int type,
+ 			 const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_xt_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_xt_ops = {
  	.kind		=	"xt",
 -	.type		=	TCA_ACT_XT,
 +	.type		=	TCA_ACT_IPT,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_ipt,
  	.dump		=	tcf_ipt_dump,
  	.cleanup	=	tcf_ipt_release,
++<<<<<<< HEAD
 +	.init		=	tcf_ipt_init,
++=======
+ 	.init		=	tcf_xt_init,
+ 	.walk		=	tcf_xt_walker,
+ 	.lookup		=	tcf_xt_search,
+ 	.size		=	sizeof(struct tcf_ipt),
+ };
+ 
+ static __net_init int xt_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_xt_ops);
+ }
+ 
+ static void __net_exit xt_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, xt_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations xt_net_ops = {
+ 	.init = xt_init_net,
+ 	.exit = xt_exit_net,
+ 	.id   = &xt_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002-13)");
diff --cc net/sched/act_mirred.c
index a6b4fd97f311,416627c66f08..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -67,47 -92,44 +66,75 @@@ static int tcf_mirred_init(struct net *
  	if (tb[TCA_MIRRED_PARMS] == NULL)
  		return -EINVAL;
  	parm = nla_data(tb[TCA_MIRRED_PARMS]);
++<<<<<<< HEAD
++=======
+ 
+ 	exists = tcf_idr_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	switch (parm->eaction) {
  	case TCA_EGRESS_MIRROR:
  	case TCA_EGRESS_REDIR:
 -	case TCA_INGRESS_REDIR:
 -	case TCA_INGRESS_MIRROR:
  		break;
  	default:
++<<<<<<< HEAD
++=======
+ 		if (exists)
+ 			tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		return -EINVAL;
  	}
  	if (parm->ifindex) {
  		dev = __dev_get_by_index(net, parm->ifindex);
++<<<<<<< HEAD
 +		if (dev == NULL)
++=======
+ 		if (dev == NULL) {
+ 			if (exists)
+ 				tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			return -ENODEV;
 +		switch (dev->type) {
 +		case ARPHRD_TUNNEL:
 +		case ARPHRD_TUNNEL6:
 +		case ARPHRD_SIT:
 +		case ARPHRD_IPGRE:
 +		case ARPHRD_VOID:
 +		case ARPHRD_NONE:
 +			ok_push = 0;
 +			break;
 +		default:
 +			ok_push = 1;
 +			break;
  		}
 -		mac_header_xmit = dev_is_mac_header_xmit(dev);
  	} else {
  		dev = NULL;
  	}
  
 -	if (!exists) {
 +	if (!tcf_hash_check(parm->index, a, bind)) {
  		if (dev == NULL)
  			return -EINVAL;
++<<<<<<< HEAD
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*m),
 +				      bind, true);
++=======
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_mirred_ops, bind, true);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		if (bind)
 +			return 0;
 +
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -129,7 -151,7 +156,11 @@@
  		spin_lock_bh(&mirred_list_lock);
  		list_add(&m->tcfm_list, &mirred_list);
  		spin_unlock_bh(&mirred_list_lock);
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	}
  
  	return ret;
@@@ -228,6 -269,22 +259,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_mirred_walker(struct net *net, struct sk_buff *skb,
+ 			     struct netlink_callback *cb, int type,
+ 			     const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_mirred_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static int mirred_device_event(struct notifier_block *unused,
  			       unsigned long event, void *ptr)
  {
@@@ -279,6 -336,30 +329,30 @@@ static struct tc_action_ops act_mirred_
  	.get_dev	=	tcf_mirred_device,
  };
  
++<<<<<<< HEAD
++=======
+ static __net_init int mirred_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_mirred_ops);
+ }
+ 
+ static void __net_exit mirred_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, mirred_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations mirred_net_ops = {
+ 	.init = mirred_init_net,
+ 	.exit = mirred_exit_net,
+ 	.id   = &mirred_net_id,
+ 	.size = sizeof(struct tc_action_net),
+ };
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  MODULE_AUTHOR("Jamal Hadi Salim(2002)");
  MODULE_DESCRIPTION("Device Mirror/redirect actions");
  MODULE_LICENSE("GPL");
diff --cc net/sched/act_nat.c
index 5ddce5b1ccf3,c365d01b99c8..000000000000
--- a/net/sched/act_nat.c
+++ b/net/sched/act_nat.c
@@@ -29,7 -29,8 +29,12 @@@
  #include <net/udp.h>
  
  
++<<<<<<< HEAD
 +#define NAT_TAB_MASK	15
++=======
+ static unsigned int nat_net_id;
+ static struct tc_action_ops act_nat_ops;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  static const struct nla_policy nat_policy[TCA_NAT_MAX + 1] = {
  	[TCA_NAT_PARMS]	= { .len = sizeof(struct tc_nat) },
@@@ -54,16 -56,16 +59,26 @@@ static int tcf_nat_init(struct net *net
  		return -EINVAL;
  	parm = nla_data(tb[TCA_NAT_PARMS]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*p),
 +				      bind, false);
++=======
+ 	if (!tcf_idr_check(tn, parm->index, a, bind)) {
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_nat_ops, bind, false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -79,7 -81,7 +94,11 @@@
  	spin_unlock_bh(&p->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  	return ret;
  }
@@@ -280,6 -275,22 +299,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_nat_walker(struct net *net, struct sk_buff *skb,
+ 			  struct netlink_callback *cb, int type,
+ 			  const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_nat_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_nat_ops = {
  	.kind		=	"nat",
  	.type		=	TCA_ACT_NAT,
@@@ -287,6 -298,30 +325,33 @@@
  	.act		=	tcf_nat,
  	.dump		=	tcf_nat_dump,
  	.init		=	tcf_nat_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_nat_walker,
+ 	.lookup		=	tcf_nat_search,
+ 	.size		=	sizeof(struct tcf_nat),
+ };
+ 
+ static __net_init int nat_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_nat_ops);
+ }
+ 
+ static void __net_exit nat_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, nat_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations nat_net_ops = {
+ 	.init = nat_init_net,
+ 	.exit = nat_exit_net,
+ 	.id   = &nat_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_DESCRIPTION("Stateless NAT actions");
diff --cc net/sched/act_pedit.c
index 0ad8b8fe7165,491fe5deb09e..000000000000
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@@ -22,8 -22,10 +22,13 @@@
  #include <net/pkt_sched.h>
  #include <linux/tc_act/tc_pedit.h>
  #include <net/tc_act/tc_pedit.h>
 -#include <uapi/linux/tc_act/tc_pedit.h>
  
++<<<<<<< HEAD
 +#define PEDIT_TAB_MASK	15
++=======
+ static unsigned int pedit_net_id;
+ static struct tc_action_ops act_pedit_ops;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  static const struct nla_policy pedit_policy[TCA_PEDIT_MAX + 1] = {
  	[TCA_PEDIT_PARMS]	= { .len = sizeof(struct tc_pedit) },
@@@ -47,38 -151,49 +52,59 @@@ static int tcf_pedit_init(struct net *n
  	if (err < 0)
  		return err;
  
 -	pattr = tb[TCA_PEDIT_PARMS];
 -	if (!pattr)
 -		pattr = tb[TCA_PEDIT_PARMS_EX];
 -	if (!pattr)
 +	if (tb[TCA_PEDIT_PARMS] == NULL)
  		return -EINVAL;
 -
 -	parm = nla_data(pattr);
 +	parm = nla_data(tb[TCA_PEDIT_PARMS]);
  	ksize = parm->nkeys * sizeof(struct tc_pedit_key);
 -	if (nla_len(pattr) < sizeof(*parm) + ksize)
 +	if (nla_len(tb[TCA_PEDIT_PARMS]) < sizeof(*parm) + ksize)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		if (!parm->nkeys)
 +			return -EINVAL;
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*p),
 +				      bind, false);
++=======
+ 	keys_ex = tcf_pedit_keys_ex_parse(tb[TCA_PEDIT_KEYS_EX], parm->nkeys);
+ 	if (IS_ERR(keys_ex))
+ 		return PTR_ERR(keys_ex);
+ 
+ 	if (!tcf_idr_check(tn, parm->index, a, bind)) {
+ 		if (!parm->nkeys)
+ 			return -EINVAL;
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_pedit_ops, bind, false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
 -		p = to_pedit(*a);
 +		p = to_pedit(a);
  		keys = kmalloc(ksize, GFP_KERNEL);
  		if (keys == NULL) {
++<<<<<<< HEAD
 +			tcf_hash_cleanup(a, est);
++=======
+ 			tcf_idr_cleanup(*a, est);
+ 			kfree(keys_ex);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			return -ENOMEM;
  		}
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
 -		p = to_pedit(*a);
 +		p = to_pedit(a);
  		if (p->tcfp_nkeys && p->tcfp_nkeys != parm->nkeys) {
  			keys = kmalloc(ksize, GFP_KERNEL);
 -			if (!keys) {
 -				kfree(keys_ex);
 +			if (keys == NULL)
  				return -ENOMEM;
 -			}
  		}
  	}
  
@@@ -91,9 -206,13 +117,13 @@@
  		p->tcfp_nkeys = parm->nkeys;
  	}
  	memcpy(p->tcfp_keys, parm->keys, ksize);
 -
 -	kfree(p->tcfp_keys_ex);
 -	p->tcfp_keys_ex = keys_ex;
 -
  	spin_unlock_bh(&p->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  }
  
@@@ -227,6 -417,22 +257,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_pedit_walker(struct net *net, struct sk_buff *skb,
+ 			    struct netlink_callback *cb, int type,
+ 			    const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_pedit_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_pedit_ops = {
  	.kind		=	"pedit",
  	.type		=	TCA_ACT_PEDIT,
@@@ -235,6 -441,30 +284,33 @@@
  	.dump		=	tcf_pedit_dump,
  	.cleanup	=	tcf_pedit_cleanup,
  	.init		=	tcf_pedit_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_pedit_walker,
+ 	.lookup		=	tcf_pedit_search,
+ 	.size		=	sizeof(struct tcf_pedit),
+ };
+ 
+ static __net_init int pedit_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_pedit_ops);
+ }
+ 
+ static void __net_exit pedit_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, pedit_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations pedit_net_ops = {
+ 	.init = pedit_init_net,
+ 	.exit = pedit_exit_net,
+ 	.id   = &pedit_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2002-4)");
diff --cc net/sched/act_police.c
index b585d0f7b825,3bb2ebf9e9ae..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -37,11 -37,9 +37,9 @@@ struct tcf_police 
  	struct psched_ratecfg	peak;
  	bool			peak_present;
  };
 -
 -#define to_police(pc) ((struct tcf_police *)pc)
 +#define to_police(pc)	\
 +	container_of(pc, struct tcf_police, common)
  
- #define POL_TAB_MASK     15
- 
  /* old policer structure from before tc actions */
  struct tc_police_compat {
  	u32			index;
@@@ -136,32 -97,25 +134,48 @@@ static int tcf_act_police_locate(struc
  	size = nla_len(tb[TCA_POLICE_TBF]);
  	if (size != sizeof(*parm) && size != sizeof(struct tc_police_compat))
  		return -EINVAL;
 -
  	parm = nla_data(tb[TCA_POLICE_TBF]);
++<<<<<<< HEAD
 +
 +	if (parm->index) {
 +		if (tcf_hash_search(a, parm->index)) {
 +			police = to_police(a->priv);
 +			if (bind) {
 +				police->tcf_bindcnt += 1;
 +				police->tcf_refcnt += 1;
 +				return 0;
 +			}
 +			if (ovr)
 +				goto override;
 +			/* not replacing */
++=======
+ 	exists = tcf_idr_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (!exists) {
+ 		ret = tcf_idr_create(tn, parm->index, NULL, a,
+ 				     &act_police_ops, bind, false);
+ 		if (ret)
+ 			return ret;
+ 		ret = ACT_P_CREATED;
+ 	} else {
+ 		tcf_idr_release(*a, bind);
+ 		if (!ovr)
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			return -EEXIST;
 +		}
  	}
  
 -	police = to_police(*a);
 +	police = kzalloc(sizeof(*police), GFP_KERNEL);
 +	if (police == NULL)
 +		return -ENOMEM;
 +	ret = ACT_P_CREATED;
 +	police->tcf_refcnt = 1;
 +	spin_lock_init(&police->tcf_lock);
 +	if (bind)
 +		police->tcf_bindcnt = 1;
 +override:
  	if (parm->rate.rate) {
  		err = -ENOMEM;
  		R_tab = qdisc_get_rtab(&parm->rate, tb[TCA_POLICE_RATE]);
@@@ -233,24 -186,15 +247,32 @@@
  		return ret;
  
  	police->tcfp_t_c = ktime_get_ns();
++<<<<<<< HEAD
 +	police->tcf_index = parm->index ? parm->index :
 +		tcf_hash_new_index(hinfo);
 +	police->tcf_tm.install = jiffies;
 +	police->tcf_tm.lastuse = jiffies;
 +	police->tcf_tm.firstuse = 0;
 +	h = tcf_hash(police->tcf_index, POL_TAB_MASK);
 +	spin_lock_bh(&hinfo->lock);
 +	hlist_add_head(&police->tcf_head, &hinfo->htab[h]);
 +	spin_unlock_bh(&hinfo->lock);
++=======
+ 	tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
 +	a->priv = police;
  	return ret;
  
  failure:
  	qdisc_put_rtab(P_tab);
  	qdisc_put_rtab(R_tab);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		kfree(police);
++=======
+ 		tcf_idr_cleanup(*a, est);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return err;
  }
  
@@@ -356,6 -304,13 +378,16 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_police_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  MODULE_AUTHOR("Alexey Kuznetsov");
  MODULE_DESCRIPTION("Policing actions");
  MODULE_LICENSE("GPL");
@@@ -366,8 -321,31 +398,36 @@@ static struct tc_action_ops act_police_
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_act_police,
  	.dump		=	tcf_act_police_dump,
++<<<<<<< HEAD
 +	.init		=	tcf_act_police_locate,
 +	.walk		=	tcf_act_police_walker
++=======
+ 	.init		=	tcf_act_police_init,
+ 	.walk		=	tcf_act_police_walker,
+ 	.lookup		=	tcf_police_search,
+ 	.size		=	sizeof(struct tcf_police),
+ };
+ 
+ static __net_init int police_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_police_ops);
+ }
+ 
+ static void __net_exit police_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations police_net_ops = {
+ 	.init = police_init_net,
+ 	.exit = police_exit_net,
+ 	.id   = &police_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  static int __init police_init_module(void)
diff --cc net/sched/act_simple.c
index 4876cc19a2ed,e7b57e5071a3..000000000000
--- a/net/sched/act_simple.c
+++ b/net/sched/act_simple.c
@@@ -24,7 -24,8 +24,12 @@@
  #include <linux/tc_act/tc_defact.h>
  #include <net/tc_act/tc_defact.h>
  
++<<<<<<< HEAD
 +#define SIMP_TAB_MASK     7
++=======
+ static unsigned int simp_net_id;
+ static struct tc_action_ops act_simp_ops;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  #define SIMP_MAX_DATA	32
  static int tcf_simp(struct sk_buff *skb, const struct tc_action *a,
@@@ -96,32 -99,37 +101,57 @@@ static int tcf_simp_init(struct net *ne
  	if (tb[TCA_DEF_PARMS] == NULL)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (tb[TCA_DEF_DATA] == NULL)
++=======
+ 	parm = nla_data(tb[TCA_DEF_PARMS]);
+ 	exists = tcf_idr_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (tb[TCA_DEF_DATA] == NULL) {
+ 		if (exists)
+ 			tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		return -EINVAL;
 -	}
  
 +	parm = nla_data(tb[TCA_DEF_PARMS]);
  	defdata = nla_data(tb[TCA_DEF_DATA]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*d),
 +				      bind, false);
++=======
+ 	if (!exists) {
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_simp_ops, bind, false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  
 -		d = to_defact(*a);
 +		d = to_defact(a);
  		ret = alloc_defdata(d, defdata);
  		if (ret < 0) {
++<<<<<<< HEAD
 +			tcf_hash_cleanup(a, est);
++=======
+ 			tcf_idr_cleanup(*a, est);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			return ret;
  		}
  		d->tcf_action = parm->action;
  		ret = ACT_P_CREATED;
  	} else {
 -		d = to_defact(*a);
 +		d = to_defact(a);
  
++<<<<<<< HEAD
 +		if (bind)
 +			return 0;
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  
@@@ -129,7 -137,7 +159,11 @@@
  	}
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  }
  
@@@ -160,6 -168,22 +194,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_simp_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_simp_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_simp_ops = {
  	.kind		=	"simple",
  	.type		=	TCA_ACT_SIMP,
@@@ -168,6 -192,30 +221,33 @@@
  	.dump		=	tcf_simp_dump,
  	.cleanup	=	tcf_simp_release,
  	.init		=	tcf_simp_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_simp_walker,
+ 	.lookup		=	tcf_simp_search,
+ 	.size		=	sizeof(struct tcf_defact),
+ };
+ 
+ static __net_init int simp_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_simp_ops);
+ }
+ 
+ static void __net_exit simp_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, simp_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations simp_net_ops = {
+ 	.init = simp_init_net,
+ 	.exit = simp_exit_net,
+ 	.id   = &simp_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_AUTHOR("Jamal Hadi Salim(2005)");
diff --cc net/sched/act_skbedit.c
index 173bfd2bb060,59949d61f20d..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -28,7 -27,8 +28,12 @@@
  #include <linux/tc_act/tc_skbedit.h>
  #include <net/tc_act/tc_skbedit.h>
  
++<<<<<<< HEAD
 +#define SKBEDIT_TAB_MASK     15
++=======
+ static unsigned int skbedit_net_id;
+ static struct tc_action_ops act_skbedit_ops;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  static int tcf_skbedit(struct sk_buff *skb, const struct tc_action *a,
  		       struct tcf_result *res)
@@@ -99,19 -116,26 +104,39 @@@ static int tcf_skbedit_init(struct net 
  
  	parm = nla_data(tb[TCA_SKBEDIT_PARMS]);
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*d),
 +				      bind, false);
++=======
+ 	exists = tcf_idr_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (!flags) {
+ 		tcf_idr_release(*a, bind);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!exists) {
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_skbedit_ops, bind, false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  
 -		d = to_skbedit(*a);
 +		d = to_skbedit(a);
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		d = to_skbedit(a);
 +		if (bind)
 +			return 0;
 +		tcf_hash_release(a, bind);
++=======
+ 		d = to_skbedit(*a);
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -131,7 -161,7 +156,11 @@@
  	spin_unlock_bh(&d->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  }
  
@@@ -173,6 -206,22 +202,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_skbedit_walker(struct net *net, struct sk_buff *skb,
+ 			      struct netlink_callback *cb, int type,
+ 			      const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_skbedit_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_skbedit_ops = {
  	.kind		=	"skbedit",
  	.type		=	TCA_ACT_SKBEDIT,
@@@ -180,6 -229,30 +228,33 @@@
  	.act		=	tcf_skbedit,
  	.dump		=	tcf_skbedit_dump,
  	.init		=	tcf_skbedit_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_skbedit_walker,
+ 	.lookup		=	tcf_skbedit_search,
+ 	.size		=	sizeof(struct tcf_skbedit),
+ };
+ 
+ static __net_init int skbedit_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_skbedit_ops);
+ }
+ 
+ static void __net_exit skbedit_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations skbedit_net_ops = {
+ 	.init = skbedit_init_net,
+ 	.exit = skbedit_exit_net,
+ 	.id   = &skbedit_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  MODULE_AUTHOR("Alexander Duyck, <alexander.h.duyck@intel.com>");
diff --cc net/sched/act_tunnel_key.c
index 34e794b225b8,30c96274c638..000000000000
--- a/net/sched/act_tunnel_key.c
+++ b/net/sched/act_tunnel_key.c
@@@ -20,8 -20,7 +20,12 @@@
  #include <linux/tc_act/tc_tunnel_key.h>
  #include <net/tc_act/tc_tunnel_key.h>
  
++<<<<<<< HEAD
 +#define TUNNEL_KEY_TAB_MASK     15
 +
++=======
+ static unsigned int tunnel_key_net_id;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_tunnel_key_ops;
  
  static int tunnel_key_act(struct sk_buff *skb, const struct tc_action *a,
@@@ -97,7 -98,7 +101,11 @@@ static int tunnel_key_init(struct net *
  		return -EINVAL;
  
  	parm = nla_data(tb[TCA_TUNNEL_KEY_PARMS]);
++<<<<<<< HEAD
 +	exists = tcf_hash_check(parm->index, a, bind);
++=======
+ 	exists = tcf_idr_check(tn, parm->index, a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	if (exists && bind)
  		return 0;
  
@@@ -156,14 -157,14 +164,23 @@@
  	}
  
  	if (!exists) {
++<<<<<<< HEAD
 +		ret = tcf_hash_create(parm->index, est, a,
 +				      sizeof(*t), bind, true);
++=======
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_tunnel_key_ops, bind, true);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -174,7 -175,7 +191,11 @@@
  	params_new = kzalloc(sizeof(*params_new), GFP_KERNEL);
  	if (unlikely(!params_new)) {
  		if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +			tcf_hash_release(a, bind);
++=======
+ 			tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		return -ENOMEM;
  	}
  
@@@ -190,13 -191,13 +211,21 @@@
  		kfree_rcu(params_old, rcu);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  	return ret;
  
  err_out:
  	if (exists)
++<<<<<<< HEAD
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  }
  
@@@ -288,6 -289,22 +317,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tunnel_key_walker(struct net *net, struct sk_buff *skb,
+ 			     struct netlink_callback *cb, int type,
+ 			     const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, tunnel_key_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tunnel_key_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, tunnel_key_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_tunnel_key_ops = {
  	.kind		=	"tunnel_key",
  	.type		=	TCA_ACT_TUNNEL_KEY,
@@@ -296,6 -313,30 +344,33 @@@
  	.dump		=	tunnel_key_dump,
  	.init		=	tunnel_key_init,
  	.cleanup	=	tunnel_key_release,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tunnel_key_walker,
+ 	.lookup		=	tunnel_key_search,
+ 	.size		=	sizeof(struct tcf_tunnel_key),
+ };
+ 
+ static __net_init int tunnel_key_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, tunnel_key_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_tunnel_key_ops);
+ }
+ 
+ static void __net_exit tunnel_key_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, tunnel_key_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations tunnel_key_net_ops = {
+ 	.init = tunnel_key_init_net,
+ 	.exit = tunnel_key_exit_net,
+ 	.id   = &tunnel_key_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  static int __init tunnel_key_init_module(void)
diff --cc net/sched/act_vlan.c
index e7e4783c7dce,16eb067a8d8f..000000000000
--- a/net/sched/act_vlan.c
+++ b/net/sched/act_vlan.c
@@@ -19,7 -19,8 +19,12 @@@
  #include <linux/tc_act/tc_vlan.h>
  #include <net/tc_act/tc_vlan.h>
  
++<<<<<<< HEAD
 +#define VLAN_TAB_MASK     15
++=======
+ static unsigned int vlan_net_id;
+ static struct tc_action_ops act_vlan_ops;
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  
  static int tcf_vlan(struct sk_buff *skb, const struct tc_action *a,
  		    struct tcf_result *res)
@@@ -99,15 -126,26 +104,35 @@@ static int tcf_vlan_init(struct net *ne
  	if (!tb[TCA_VLAN_PARMS])
  		return -EINVAL;
  	parm = nla_data(tb[TCA_VLAN_PARMS]);
++<<<<<<< HEAD
++=======
+ 	exists = tcf_idr_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	switch (parm->v_action) {
  	case TCA_VLAN_ACT_POP:
  		break;
  	case TCA_VLAN_ACT_PUSH:
++<<<<<<< HEAD
 +		if (!tb[TCA_VLAN_PUSH_VLAN_ID])
++=======
+ 	case TCA_VLAN_ACT_MODIFY:
+ 		if (!tb[TCA_VLAN_PUSH_VLAN_ID]) {
+ 			if (exists)
+ 				tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			return -EINVAL;
 -		}
  		push_vid = nla_get_u16(tb[TCA_VLAN_PUSH_VLAN_ID]);
++<<<<<<< HEAD
 +		if (push_vid >= VLAN_VID_MASK)
++=======
+ 		if (push_vid >= VLAN_VID_MASK) {
+ 			if (exists)
+ 				tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  			return -ERANGE;
 -		}
  
  		if (tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]) {
  			push_proto = nla_get_be16(tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]);
@@@ -126,21 -164,21 +151,36 @@@
  			push_prio = nla_get_u8(tb[TCA_VLAN_PUSH_VLAN_PRIORITY]);
  		break;
  	default:
++<<<<<<< HEAD
++=======
+ 		if (exists)
+ 			tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		return -EINVAL;
  	}
  	action = parm->v_action;
  
++<<<<<<< HEAD
 +	if (!tcf_hash_check(parm->index, a, bind)) {
 +		ret = tcf_hash_create(parm->index, est, a, sizeof(*v),
 +				      bind, false);
++=======
+ 	if (!exists) {
+ 		ret = tcf_idr_create(tn, parm->index, est, a,
+ 				     &act_vlan_ops, bind, false);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (ret)
  			return ret;
  
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		if (bind)
 +			return 0;
 +		tcf_hash_release(a, bind);
++=======
+ 		tcf_idr_release(*a, bind);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -159,7 -197,7 +199,11 @@@
  	spin_unlock_bh(&v->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(a);
++=======
+ 		tcf_idr_insert(tn, *a);
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  	return ret;
  }
  
@@@ -198,6 -237,22 +242,25 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_vlan_walker(struct net *net, struct sk_buff *skb,
+ 			   struct netlink_callback *cb, int type,
+ 			   const struct tc_action_ops *ops)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	return tcf_generic_walker(tn, skb, cb, type, ops);
+ }
+ 
+ static int tcf_vlan_search(struct net *net, struct tc_action **a, u32 index)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	return tcf_idr_search(tn, a, index);
+ }
+ 
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  static struct tc_action_ops act_vlan_ops = {
  	.kind		=	"vlan",
  	.type		=	TCA_ACT_VLAN,
@@@ -205,6 -260,30 +268,33 @@@
  	.act		=	tcf_vlan,
  	.dump		=	tcf_vlan_dump,
  	.init		=	tcf_vlan_init,
++<<<<<<< HEAD
++=======
+ 	.walk		=	tcf_vlan_walker,
+ 	.lookup		=	tcf_vlan_search,
+ 	.size		=	sizeof(struct tcf_vlan),
+ };
+ 
+ static __net_init int vlan_init_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	return tc_action_net_init(tn, &act_vlan_ops);
+ }
+ 
+ static void __net_exit vlan_exit_net(struct net *net)
+ {
+ 	struct tc_action_net *tn = net_generic(net, vlan_net_id);
+ 
+ 	tc_action_net_exit(tn);
+ }
+ 
+ static struct pernet_operations vlan_net_ops = {
+ 	.init = vlan_init_net,
+ 	.exit = vlan_exit_net,
+ 	.id   = &vlan_net_id,
+ 	.size = sizeof(struct tc_action_net),
++>>>>>>> 65a206c01e8e (net/sched: Change act_api and act_xxx modules to use IDR)
  };
  
  static int __init vlan_init_module(void)
* Unmerged path net/sched/act_bpf.c
* Unmerged path net/sched/act_connmark.c
* Unmerged path net/sched/act_ife.c
* Unmerged path net/sched/act_skbmod.c
* Unmerged path include/net/act_api.h
* Unmerged path net/sched/act_api.c
* Unmerged path net/sched/act_bpf.c
* Unmerged path net/sched/act_connmark.c
* Unmerged path net/sched/act_csum.c
* Unmerged path net/sched/act_gact.c
* Unmerged path net/sched/act_ife.c
* Unmerged path net/sched/act_ipt.c
* Unmerged path net/sched/act_mirred.c
* Unmerged path net/sched/act_nat.c
* Unmerged path net/sched/act_pedit.c
* Unmerged path net/sched/act_police.c
diff --git a/net/sched/act_sample.c b/net/sched/act_sample.c
index 0b8217b4763f..bbd607a1698c 100644
--- a/net/sched/act_sample.c
+++ b/net/sched/act_sample.c
@@ -25,7 +25,6 @@
 
 #include <linux/if_arp.h>
 
-#define SAMPLE_TAB_MASK     7
 static unsigned int sample_net_id;
 static struct tc_action_ops act_sample_ops;
 
@@ -59,18 +58,18 @@ static int tcf_sample_init(struct net *net, struct nlattr *nla,
 
 	parm = nla_data(tb[TCA_SAMPLE_PARMS]);
 
-	exists = tcf_hash_check(tn, parm->index, a, bind);
+	exists = tcf_idr_check(tn, parm->index, a, bind);
 	if (exists && bind)
 		return 0;
 
 	if (!exists) {
-		ret = tcf_hash_create(tn, parm->index, est, a,
-				      &act_sample_ops, bind, false);
+		ret = tcf_idr_create(tn, parm->index, est, a,
+				     &act_sample_ops, bind, false);
 		if (ret)
 			return ret;
 		ret = ACT_P_CREATED;
 	} else {
-		tcf_hash_release(*a, bind);
+		tcf_idr_release(*a, bind);
 		if (!ovr)
 			return -EEXIST;
 	}
@@ -82,7 +81,7 @@ static int tcf_sample_init(struct net *net, struct nlattr *nla,
 	psample_group = psample_group_get(net, s->psample_group_num);
 	if (!psample_group) {
 		if (ret == ACT_P_CREATED)
-			tcf_hash_release(*a, bind);
+			tcf_idr_release(*a, bind);
 		return -ENOMEM;
 	}
 	RCU_INIT_POINTER(s->psample_group, psample_group);
@@ -93,7 +92,7 @@ static int tcf_sample_init(struct net *net, struct nlattr *nla,
 	}
 
 	if (ret == ACT_P_CREATED)
-		tcf_hash_insert(tn, *a);
+		tcf_idr_insert(tn, *a);
 	return ret;
 }
 
@@ -221,7 +220,7 @@ static int tcf_sample_search(struct net *net, struct tc_action **a, u32 index)
 {
 	struct tc_action_net *tn = net_generic(net, sample_net_id);
 
-	return tcf_hash_search(tn, a, index);
+	return tcf_idr_search(tn, a, index);
 }
 
 static struct tc_action_ops act_sample_ops = {
@@ -241,7 +240,7 @@ static __net_init int sample_init_net(struct net *net)
 {
 	struct tc_action_net *tn = net_generic(net, sample_net_id);
 
-	return tc_action_net_init(tn, &act_sample_ops, SAMPLE_TAB_MASK);
+	return tc_action_net_init(tn, &act_sample_ops);
 }
 
 static void __net_exit sample_exit_net(struct net *net)
* Unmerged path net/sched/act_simple.c
* Unmerged path net/sched/act_skbedit.c
* Unmerged path net/sched/act_skbmod.c
* Unmerged path net/sched/act_tunnel_key.c
* Unmerged path net/sched/act_vlan.c
