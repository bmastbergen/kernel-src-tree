ftrace: Add more checks for FTRACE_FL_DISABLED in processing ip records

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Steven Rostedt (Red Hat) <rostedt@goodmis.org>
commit 546fece4eae871f033925ccf0ff2b740725ae915
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/546fece4.failed

When a module is first loaded and its function ip records are added to the
ftrace list of functions to modify, they are set to DISABLED, as their text
is still in a read only state. When the module is fully loaded, and can be
updated, the flag is cleared, and if their's any functions that should be
tracing them, it is updated at that moment.

But there's several locations that do record accounting and should ignore
records that are marked as disabled, or they can cause issues.

Alexei already fixed one location, but others need to be addressed.

	Cc: stable@vger.kernel.org
Fixes: b7ffffbb46f2 "ftrace: Add infrastructure for delayed enabling of module functions"
	Reported-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 546fece4eae871f033925ccf0ff2b740725ae915)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/ftrace.c
diff --cc kernel/trace/ftrace.c
index 0146600e951a,da87b3cba5b3..000000000000
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@@ -1997,9 -2405,13 +2005,13 @@@ void __weak ftrace_replace_code(int ena
  		return;
  
  	do_for_each_ftrace_rec(pg, rec) {
+ 
+ 		if (rec->flags & FTRACE_FL_DISABLED)
+ 			continue;
+ 
  		failed = __ftrace_replace_code(rec, enable);
  		if (failed) {
 -			ftrace_bug(failed, rec);
 +			ftrace_bug(failed, rec->ip);
  			/* Stop processing */
  			return;
  		}
@@@ -3089,8 -3610,12 +3101,17 @@@ match_records(struct ftrace_hash *hash
  		goto out_unlock;
  
  	do_for_each_ftrace_rec(pg, rec) {
++<<<<<<< HEAD
 +		if (ftrace_match_record(rec, mod, search, search_len, type)) {
 +			ret = enter_record(hash, rec, not);
++=======
+ 
+ 		if (rec->flags & FTRACE_FL_DISABLED)
+ 			continue;
+ 
+ 		if (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {
+ 			ret = enter_record(hash, rec, clear_filter);
++>>>>>>> 546fece4eae8 (ftrace: Add more checks for FTRACE_FL_DISABLED in processing ip records)
  			if (ret < 0) {
  				found = ret;
  				goto out_unlock;
@@@ -3304,7 -3809,10 +3325,14 @@@ register_ftrace_function_probe(char *gl
  
  	do_for_each_ftrace_rec(pg, rec) {
  
++<<<<<<< HEAD
 +		if (!ftrace_match_record(rec, NULL, search, len, type))
++=======
+ 		if (rec->flags & FTRACE_FL_DISABLED)
+ 			continue;
+ 
+ 		if (!ftrace_match_record(rec, &func_g, NULL, 0))
++>>>>>>> 546fece4eae8 (ftrace: Add more checks for FTRACE_FL_DISABLED in processing ip records)
  			continue;
  
  		entry = kmalloc(sizeof(*entry), GFP_KERNEL);
@@@ -4060,7 -4704,10 +4088,14 @@@ ftrace_set_func(unsigned long *array, i
  
  	do_for_each_ftrace_rec(pg, rec) {
  
++<<<<<<< HEAD
 +		if (ftrace_match_record(rec, NULL, search, search_len, type)) {
++=======
+ 		if (rec->flags & FTRACE_FL_DISABLED)
+ 			continue;
+ 
+ 		if (ftrace_match_record(rec, &func_g, NULL, 0)) {
++>>>>>>> 546fece4eae8 (ftrace: Add more checks for FTRACE_FL_DISABLED in processing ip records)
  			/* if it is in the array */
  			exists = false;
  			for (i = 0; i < *idx; i++) {
* Unmerged path kernel/trace/ftrace.c
