i40e: shutdown all IRQs and disable MSI-X when suspended

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit b980c0634fe56928a45cc3c0f688d96e36705403
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b980c063.failed

On some platforms with a large number of CPUs, we will allocate many IRQ
vectors. When hibernating, the system will attempt to migrate all of the
vectors back to CPU0 when shutting down all the other CPUs. It is
possible that we have so many vectors that it cannot re-assign them to
CPU0. This is even more likely if we have many devices installed in one
platform.

The end result is failure to hibernate, as it is not possible to
shutdown the CPUs. We can avoid this by disabling MSI-X and clearing our
interrupt scheme when the device is suspended. A more ideal solution
would be some method for the stack to properly handle this for all
drivers, rather than on a case-by-case basis for each driver to fix
itself.

However, until this more ideal solution exists, we can do our part and
shutdown our IRQs during suspend, which should allow systems with
a large number of CPUs to safely suspend or hibernate.

It may be worth investigating if we should shut down even further when
we suspend as it may make the path cleaner, but this was the minimum fix
for the hibernation issue mentioned here.

Testing-hints:
  This affects systems with a large number of CPUs, and with multiple
  devices enabled. Without this change, those platforms are unable to
  hibernate at all.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit b980c0634fe56928a45cc3c0f688d96e36705403)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index f79fbe6540aa,8a44793d5390..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -12030,7 -12128,12 +12081,16 @@@ static int i40e_suspend(struct device *
  	wr32(hw, I40E_PFPM_APM, (pf->wol_en ? I40E_PFPM_APM_APME_MASK : 0));
  	wr32(hw, I40E_PFPM_WUFC, (pf->wol_en ? I40E_PFPM_WUFC_MAG_MASK : 0));
  
++<<<<<<< HEAD
 +	i40e_stop_misc_vector(pf);
++=======
+ 	/* Clear the interrupt scheme and release our IRQs so that the system
+ 	 * can safely hibernate even when there are a large number of CPUs.
+ 	 * Otherwise hibernation might fail when mapping all the vectors back
+ 	 * to CPU0.
+ 	 */
+ 	i40e_clear_interrupt_scheme(pf);
++>>>>>>> b980c0634fe5 (i40e: shutdown all IRQs and disable MSI-X when suspended)
  
  	return 0;
  }
@@@ -12043,14 -12146,30 +12103,40 @@@ static int i40e_resume(struct device *d
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct i40e_pf *pf = pci_get_drvdata(pdev);
+ 	int err;
  
++<<<<<<< HEAD
 +	/* handling the reset will rebuild the device state */
 +	if (test_and_clear_bit(__I40E_SUSPENDED, &pf->state)) {
 +		clear_bit(__I40E_DOWN, &pf->state);
 +		rtnl_lock();
 +		i40e_reset_and_rebuild(pf, false);
 +		rtnl_unlock();
 +	}
++=======
+ 	/* If we're not suspended, then there is nothing to do */
+ 	if (!test_bit(__I40E_SUSPENDED, pf->state))
+ 		return 0;
+ 
+ 	/* We cleared the interrupt scheme when we suspended, so we need to
+ 	 * restore it now to resume device functionality.
+ 	 */
+ 	err = i40e_restore_interrupt_scheme(pf);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Cannot restore interrupt scheme: %d\n",
+ 			err);
+ 	}
+ 
+ 	clear_bit(__I40E_DOWN, pf->state);
+ 	i40e_reset_and_rebuild(pf, false, false);
+ 
+ 	/* Clear suspended state last after everything is recovered */
+ 	clear_bit(__I40E_SUSPENDED, pf->state);
+ 
+ 	/* Restart the service task */
+ 	mod_timer(&pf->service_timer,
+ 		  round_jiffies(jiffies + pf->service_timer_period));
++>>>>>>> b980c0634fe5 (i40e: shutdown all IRQs and disable MSI-X when suspended)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index c275128c99cb,80ade6510279..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -44,9 -44,9 +44,15 @@@ static const char i40evf_driver_string[
  
  #define DRV_KERN "-k"
  
++<<<<<<< HEAD
 +#define DRV_VERSION_MAJOR 2
 +#define DRV_VERSION_MINOR 1
 +#define DRV_VERSION_BUILD 14
++=======
+ #define DRV_VERSION_MAJOR 3
+ #define DRV_VERSION_MINOR 0
+ #define DRV_VERSION_BUILD 1
++>>>>>>> b980c0634fe5 (i40e: shutdown all IRQs and disable MSI-X when suspended)
  #define DRV_VERSION __stringify(DRV_VERSION_MAJOR) "." \
  	     __stringify(DRV_VERSION_MINOR) "." \
  	     __stringify(DRV_VERSION_BUILD) \
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
