nfp: add XDP support in the driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit ecd63a0217d5f1e8a92f7516f5586d1177b95de2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ecd63a02.failed

Add XDP support.  Separate stack's and XDP's TX rings logically.
Add functions for handling XDP_TX and cleanup of XDP's TX rings.
For XDP allocate all RX buffers as separate pages and map them
with DMA_BIDIRECTIONAL.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ecd63a0217d5f1e8a92f7516f5586d1177b95de2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index 1826ee93d1da,abc9e56e93b8..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -339,8 -344,8 +342,9 @@@ struct nfp_net_rx_ring 
   * @napi:           NAPI structure for this ring vec
   * @tx_ring:        Pointer to TX ring
   * @rx_ring:        Pointer to RX ring
+  * @xdp_ring:	    Pointer to an extra TX ring for XDP
   * @irq_idx:        Index into MSI-X table
 + * @irq_entry:      MSI-X table entry (use for talking to the device)
   * @rx_sync:	    Seqlock for atomic updates of RX stats
   * @rx_pkts:        Number of received packets
   * @rx_bytes:	    Number of received bytes
@@@ -426,6 -437,13 +432,15 @@@ static inline bool nfp_net_fw_ver_eq(st
   * @ctrl:               Local copy of the control register/word.
   * @fl_bufsz:           Currently configured size of the freelist buffers
   * @rx_offset:		Offset in the RX buffers where packet data starts
++<<<<<<< HEAD
++=======
+  * @xdp_prog:		Installed XDP program
+  * @cpp:                Pointer to the CPP handle
+  * @nfp_dev_cpp:        Pointer to the NFP Device handle
+  * @ctrl_area:          Pointer to the CPP area for the control BAR
+  * @tx_area:            Pointer to the CPP area for the TX queues
+  * @rx_area:            Pointer to the CPP area for the FL/RX queues
++>>>>>>> ecd63a0217d5 (nfp: add XDP support in the driver)
   * @fw_ver:             Firmware version
   * @cap:                Capabilities advertised by the Firmware
   * @max_mtu:            Maximum support MTU advertised by the Firmware
@@@ -747,24 -787,17 +766,24 @@@ int nfp_net_reconfig(struct nfp_net *nn
  void nfp_net_rss_write_itbl(struct nfp_net *nn);
  void nfp_net_rss_write_key(struct nfp_net *nn);
  void nfp_net_coalesce_write_cfg(struct nfp_net *nn);
 -int nfp_net_irqs_alloc(struct nfp_net *nn);
 -void nfp_net_irqs_disable(struct nfp_net *nn);
 +
 +unsigned int
 +nfp_net_irqs_alloc(struct pci_dev *pdev, struct msix_entry *irq_entries,
 +		   unsigned int min_irqs, unsigned int want_irqs);
 +void nfp_net_irqs_disable(struct pci_dev *pdev);
 +void
 +nfp_net_irqs_assign(struct nfp_net *nn, struct msix_entry *irq_entries,
 +		    unsigned int n);
  int
- nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_ring_set *rx,
- 		      struct nfp_net_ring_set *tx);
+ nfp_net_ring_reconfig(struct nfp_net *nn, struct bpf_prog **xdp_prog,
+ 		      struct nfp_net_ring_set *rx, struct nfp_net_ring_set *tx);
  
 -#ifdef CONFIG_NFP_NET_DEBUG
 +#ifdef CONFIG_NFP_DEBUG
  void nfp_net_debugfs_create(void);
  void nfp_net_debugfs_destroy(void);
 -void nfp_net_debugfs_adapter_add(struct nfp_net *nn);
 -void nfp_net_debugfs_adapter_del(struct nfp_net *nn);
 +struct dentry *nfp_net_debugfs_device_add(struct pci_dev *pdev);
 +void nfp_net_debugfs_port_add(struct nfp_net *nn, struct dentry *ddir, int id);
 +void nfp_net_debugfs_dir_clean(struct dentry **dir);
  #else
  static inline void nfp_net_debugfs_create(void)
  {
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index de17d3265a77,fa43dbcecc4f..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -489,6 -484,15 +490,18 @@@ static void nfp_net_vecs_init(struct ne
  	struct nfp_net_r_vector *r_vec;
  	int r;
  
++<<<<<<< HEAD
++=======
+ 	if (nn->num_rx_rings > nn->num_r_vecs ||
+ 	    nn->num_tx_rings > nn->num_r_vecs)
+ 		nn_warn(nn, "More rings (%d,%d) than vectors (%d).\n",
+ 			nn->num_rx_rings, nn->num_tx_rings, nn->num_r_vecs);
+ 
+ 	nn->num_rx_rings = min(nn->num_r_vecs, nn->num_rx_rings);
+ 	nn->num_tx_rings = min(nn->num_r_vecs, nn->num_tx_rings);
+ 	nn->num_stack_tx_rings = nn->num_tx_rings;
+ 
++>>>>>>> ecd63a0217d5 (nfp: add XDP support in the driver)
  	nn->lsc_handler = nfp_net_irq_lsc;
  	nn->exn_handler = nfp_net_irq_exn;
  
@@@ -1425,10 -1630,8 +1624,15 @@@ static int nfp_net_rx(struct nfp_net_rx
  			nfp_net_rx_drop(r_vec, rx_ring, rxbuf, NULL);
  			continue;
  		}
++<<<<<<< HEAD
 +
 +		nfp_net_set_hash(nn->netdev, skb, rxd);
 +
 +		new_frag = nfp_net_napi_alloc_one(nn, &new_dma_addr);
++=======
+ 		new_frag = nfp_net_napi_alloc_one(nn, rx_dma_map_dir,
+ 						  &new_dma_addr);
++>>>>>>> ecd63a0217d5 (nfp: add XDP support in the driver)
  		if (unlikely(!new_frag)) {
  			nfp_net_rx_drop(r_vec, rx_ring, rxbuf, skb);
  			continue;
@@@ -2242,17 -2485,19 +2475,17 @@@ nfp_net_ring_swap_enable(struct nfp_ne
  	for (r = 0; r <	nn->max_r_vecs; r++)
  		nfp_net_vector_assign_rings(nn, &nn->r_vecs[r], r);
  
 -	if (nn->netdev->real_num_rx_queues != nn->num_rx_rings) {
 -		if (!netif_is_rxfh_configured(nn->netdev))
 -			nfp_net_rss_init_itbl(nn);
 +	if (!netif_is_rxfh_configured(nn->netdev))
 +		nfp_net_rss_init_itbl(nn);
  
 -		err = netif_set_real_num_rx_queues(nn->netdev,
 -						   nn->num_rx_rings);
 -		if (err)
 -			return err;
 -	}
 +	err = netif_set_real_num_rx_queues(nn->netdev,
 +					   nn->num_rx_rings);
 +	if (err)
 +		return err;
  
- 	if (nn->netdev->real_num_tx_queues != nn->num_tx_rings) {
+ 	if (nn->netdev->real_num_tx_queues != nn->num_stack_tx_rings) {
  		err = netif_set_real_num_tx_queues(nn->netdev,
- 						   nn->num_tx_rings);
+ 						   nn->num_stack_tx_rings);
  		if (err)
  			return err;
  	}
@@@ -2596,8 -2902,57 +2860,58 @@@ static void nfp_net_del_vxlan_port(stru
  		nfp_net_set_vxlan_port(nn, idx, 0);
  }
  
+ static int nfp_net_xdp_setup(struct nfp_net *nn, struct bpf_prog *prog)
+ {
+ 	struct nfp_net_ring_set rx = {
+ 		.n_rings = nn->num_rx_rings,
+ 		.mtu = nn->netdev->mtu,
+ 		.dcnt = nn->rxd_cnt,
+ 	};
+ 	struct nfp_net_ring_set tx = {
+ 		.n_rings = nn->num_tx_rings,
+ 		.dcnt = nn->txd_cnt,
+ 	};
+ 	int err;
+ 
+ 	if (!prog && !nn->xdp_prog)
+ 		return 0;
+ 	if (prog && nn->xdp_prog) {
+ 		prog = xchg(&nn->xdp_prog, prog);
+ 		bpf_prog_put(prog);
+ 		return 0;
+ 	}
+ 
+ 	tx.n_rings += prog ? nn->num_rx_rings : -nn->num_rx_rings;
+ 
+ 	/* We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */
+ 	err = nfp_net_ring_reconfig(nn, &prog, &rx, &tx);
+ 	if (err)
+ 		return err;
+ 
+ 	/* @prog got swapped and is now the old one */
+ 	if (prog)
+ 		bpf_prog_put(prog);
+ 
+ 	return 0;
+ }
+ 
+ static int nfp_net_xdp(struct net_device *netdev, struct netdev_xdp *xdp)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	switch (xdp->command) {
+ 	case XDP_SETUP_PROG:
+ 		return nfp_net_xdp_setup(nn, xdp->prog);
+ 	case XDP_QUERY_PROG:
+ 		xdp->prog_attached = !!nn->xdp_prog;
+ 		return 0;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
  static const struct net_device_ops nfp_net_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= nfp_net_netdev_open,
  	.ndo_stop		= nfp_net_netdev_close,
  	.ndo_start_xmit		= nfp_net_tx,
@@@ -2608,8 -2964,9 +2922,14 @@@
  	.ndo_set_mac_address	= eth_mac_addr,
  	.ndo_set_features	= nfp_net_set_features,
  	.ndo_features_check	= nfp_net_features_check,
++<<<<<<< HEAD
 +	.extended.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
++=======
+ 	.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
+ 	.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
+ 	.ndo_xdp		= nfp_net_xdp,
++>>>>>>> ecd63a0217d5 (nfp: add XDP support in the driver)
  };
  
  /**
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
index fddf57c8c945,c66f3f954aa8..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
@@@ -184,10 -202,10 +202,15 @@@ static const struct file_operations nfp
  	.llseek = seq_lseek
  };
  
 -void nfp_net_debugfs_adapter_add(struct nfp_net *nn)
 +void nfp_net_debugfs_port_add(struct nfp_net *nn, struct dentry *ddir, int id)
  {
++<<<<<<< HEAD
 +	struct dentry *queues, *tx, *rx;
 +	char name[20];
++=======
+ 	struct dentry *queues, *tx, *rx, *xdp;
+ 	char int_name[16];
++>>>>>>> ecd63a0217d5 (nfp: add XDP support in the driver)
  	int i;
  
  	if (IS_ERR_OR_NULL(nfp_dir))
@@@ -209,9 -227,11 +233,11 @@@
  		return;
  
  	for (i = 0; i < min(nn->max_rx_rings, nn->max_r_vecs); i++) {
 -		sprintf(int_name, "%d", i);
 -		debugfs_create_file(int_name, S_IRUSR, rx,
 +		sprintf(name, "%d", i);
 +		debugfs_create_file(name, S_IRUSR, rx,
  				    &nn->r_vecs[i], &nfp_rx_q_fops);
+ 		debugfs_create_file(int_name, S_IRUSR, xdp,
+ 				    &nn->r_vecs[i], &nfp_xdp_q_fops);
  	}
  
  	for (i = 0; i < min(nn->max_tx_rings, nn->max_r_vecs); i++) {
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index dfbf6b94ff5b..a96a507bdaba 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@ -189,7 +189,8 @@ static int nfp_net_set_ring_size(struct nfp_net *nn, u32 rxd_cnt, u32 txd_cnt)
 	if (nn->txd_cnt != txd_cnt)
 		reconfig_tx = &tx;
 
-	return nfp_net_ring_reconfig(nn, reconfig_rx, reconfig_tx);
+	return nfp_net_ring_reconfig(nn, &nn->xdp_prog,
+				     reconfig_rx, reconfig_tx);
 }
 
 static int nfp_net_set_ringparam(struct net_device *netdev,
@@ -721,14 +722,19 @@ static void nfp_net_get_channels(struct net_device *netdev,
 				 struct ethtool_channels *channel)
 {
 	struct nfp_net *nn = netdev_priv(netdev);
+	unsigned int num_tx_rings;
+
+	num_tx_rings = nn->num_tx_rings;
+	if (nn->xdp_prog)
+		num_tx_rings -= nn->num_rx_rings;
 
 	channel->max_rx = min(nn->max_rx_rings, nn->max_r_vecs);
 	channel->max_tx = min(nn->max_tx_rings, nn->max_r_vecs);
 	channel->max_combined = min(channel->max_rx, channel->max_tx);
 	channel->max_other = NFP_NET_NON_Q_VECTORS;
-	channel->combined_count = min(nn->num_rx_rings, nn->num_tx_rings);
+	channel->combined_count = min(nn->num_rx_rings, num_tx_rings);
 	channel->rx_count = nn->num_rx_rings - channel->combined_count;
-	channel->tx_count = nn->num_tx_rings - channel->combined_count;
+	channel->tx_count = num_tx_rings - channel->combined_count;
 	channel->other_count = NFP_NET_NON_Q_VECTORS;
 }
 
@@ -748,10 +754,16 @@ static int nfp_net_set_num_rings(struct nfp_net *nn, unsigned int total_rx,
 
 	if (nn->num_rx_rings != total_rx)
 		reconfig_rx = &rx;
-	if (nn->num_tx_rings != total_tx)
+	if (nn->num_stack_tx_rings != total_tx ||
+	    (nn->xdp_prog && reconfig_rx))
 		reconfig_tx = &tx;
 
-	return nfp_net_ring_reconfig(nn, reconfig_rx, reconfig_tx);
+	/* nfp_net_check_config() will catch tx.n_rings > nn->max_tx_rings */
+	if (nn->xdp_prog)
+		tx.n_rings += total_rx;
+
+	return nfp_net_ring_reconfig(nn, &nn->xdp_prog,
+				     reconfig_rx, reconfig_tx);
 }
 
 static int nfp_net_set_channels(struct net_device *netdev,
