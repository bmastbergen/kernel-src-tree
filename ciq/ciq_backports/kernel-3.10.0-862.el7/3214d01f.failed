KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds

jira LE-1907
cve CVE-2017-5754
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [powerpc] kvm: book3s: Provide information about hardware/firmware CVE workarounds (Serhii Popovych) [1532077] {CVE-2017-5754}
Rebuild_FUZZ: 96.64%
commit-author Paul Mackerras <paulus@ozlabs.org>
commit 3214d01f139b7544e870fc0b7fcce8da13c1cb51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3214d01f.failed

This adds a new ioctl, KVM_PPC_GET_CPU_CHAR, that gives userspace
information about the underlying machine's level of vulnerability
to the recently announced vulnerabilities CVE-2017-5715,
CVE-2017-5753 and CVE-2017-5754, and whether the machine provides
instructions to assist software to work around the vulnerabilities.

The ioctl returns two u64 words describing characteristics of the
CPU and required software behaviour respectively, plus two mask
words which indicate which bits have been filled in by the kernel,
for extensibility.  The bit definitions are the same as for the
new H_GET_CPU_CHARACTERISTICS hypercall.

There is also a new capability, KVM_CAP_PPC_GET_CPU_CHAR, which
indicates whether the new ioctl is available.

	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 3214d01f139b7544e870fc0b7fcce8da13c1cb51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	arch/powerpc/include/uapi/asm/kvm.h
#	arch/powerpc/kvm/powerpc.c
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index 9f3193affa20,fc3ae951bc07..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -2684,6 -2989,466 +2684,469 @@@ an implementation for these despite th
  
  This capability is always enabled.
  
++<<<<<<< HEAD
++=======
+ 4.98 KVM_CREATE_SPAPR_TCE_64
+ 
+ Capability: KVM_CAP_SPAPR_TCE_64
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_create_spapr_tce_64 (in)
+ Returns: file descriptor for manipulating the created TCE table
+ 
+ This is an extension for KVM_CAP_SPAPR_TCE which only supports 32bit
+ windows, described in 4.62 KVM_CREATE_SPAPR_TCE
+ 
+ This capability uses extended struct in ioctl interface:
+ 
+ /* for KVM_CAP_SPAPR_TCE_64 */
+ struct kvm_create_spapr_tce_64 {
+ 	__u64 liobn;
+ 	__u32 page_shift;
+ 	__u32 flags;
+ 	__u64 offset;	/* in pages */
+ 	__u64 size; 	/* in pages */
+ };
+ 
+ The aim of extension is to support an additional bigger DMA window with
+ a variable page size.
+ KVM_CREATE_SPAPR_TCE_64 receives a 64bit window size, an IOMMU page shift and
+ a bus offset of the corresponding DMA window, @size and @offset are numbers
+ of IOMMU pages.
+ 
+ @flags are not used at the moment.
+ 
+ The rest of functionality is identical to KVM_CREATE_SPAPR_TCE.
+ 
+ 4.99 KVM_REINJECT_CONTROL
+ 
+ Capability: KVM_CAP_REINJECT_CONTROL
+ Architectures: x86
+ Type: vm ioctl
+ Parameters: struct kvm_reinject_control (in)
+ Returns: 0 on success,
+          -EFAULT if struct kvm_reinject_control cannot be read,
+          -ENXIO if KVM_CREATE_PIT or KVM_CREATE_PIT2 didn't succeed earlier.
+ 
+ i8254 (PIT) has two modes, reinject and !reinject.  The default is reinject,
+ where KVM queues elapsed i8254 ticks and monitors completion of interrupt from
+ vector(s) that i8254 injects.  Reinject mode dequeues a tick and injects its
+ interrupt whenever there isn't a pending interrupt from i8254.
+ !reinject mode injects an interrupt as soon as a tick arrives.
+ 
+ struct kvm_reinject_control {
+ 	__u8 pit_reinject;
+ 	__u8 reserved[31];
+ };
+ 
+ pit_reinject = 0 (!reinject mode) is recommended, unless running an old
+ operating system that uses the PIT for timing (e.g. Linux 2.4.x).
+ 
+ 4.100 KVM_PPC_CONFIGURE_V3_MMU
+ 
+ Capability: KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3
+ Architectures: ppc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_mmuv3_cfg (in)
+ Returns: 0 on success,
+          -EFAULT if struct kvm_ppc_mmuv3_cfg cannot be read,
+          -EINVAL if the configuration is invalid
+ 
+ This ioctl controls whether the guest will use radix or HPT (hashed
+ page table) translation, and sets the pointer to the process table for
+ the guest.
+ 
+ struct kvm_ppc_mmuv3_cfg {
+ 	__u64	flags;
+ 	__u64	process_table;
+ };
+ 
+ There are two bits that can be set in flags; KVM_PPC_MMUV3_RADIX and
+ KVM_PPC_MMUV3_GTSE.  KVM_PPC_MMUV3_RADIX, if set, configures the guest
+ to use radix tree translation, and if clear, to use HPT translation.
+ KVM_PPC_MMUV3_GTSE, if set and if KVM permits it, configures the guest
+ to be able to use the global TLB and SLB invalidation instructions;
+ if clear, the guest may not use these instructions.
+ 
+ The process_table field specifies the address and size of the guest
+ process table, which is in the guest's space.  This field is formatted
+ as the second doubleword of the partition table entry, as defined in
+ the Power ISA V3.00, Book III section 5.7.6.1.
+ 
+ 4.101 KVM_PPC_GET_RMMU_INFO
+ 
+ Capability: KVM_CAP_PPC_RADIX_MMU
+ Architectures: ppc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_rmmu_info (out)
+ Returns: 0 on success,
+ 	 -EFAULT if struct kvm_ppc_rmmu_info cannot be written,
+ 	 -EINVAL if no useful information can be returned
+ 
+ This ioctl returns a structure containing two things: (a) a list
+ containing supported radix tree geometries, and (b) a list that maps
+ page sizes to put in the "AP" (actual page size) field for the tlbie
+ (TLB invalidate entry) instruction.
+ 
+ struct kvm_ppc_rmmu_info {
+ 	struct kvm_ppc_radix_geom {
+ 		__u8	page_shift;
+ 		__u8	level_bits[4];
+ 		__u8	pad[3];
+ 	}	geometries[8];
+ 	__u32	ap_encodings[8];
+ };
+ 
+ The geometries[] field gives up to 8 supported geometries for the
+ radix page table, in terms of the log base 2 of the smallest page
+ size, and the number of bits indexed at each level of the tree, from
+ the PTE level up to the PGD level in that order.  Any unused entries
+ will have 0 in the page_shift field.
+ 
+ The ap_encodings gives the supported page sizes and their AP field
+ encodings, encoded with the AP value in the top 3 bits and the log
+ base 2 of the page size in the bottom 6 bits.
+ 
+ 4.102 KVM_PPC_RESIZE_HPT_PREPARE
+ 
+ Capability: KVM_CAP_SPAPR_RESIZE_HPT
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_resize_hpt (in)
+ Returns: 0 on successful completion,
+ 	 >0 if a new HPT is being prepared, the value is an estimated
+              number of milliseconds until preparation is complete
+          -EFAULT if struct kvm_reinject_control cannot be read,
+ 	 -EINVAL if the supplied shift or flags are invalid
+ 	 -ENOMEM if unable to allocate the new HPT
+ 	 -ENOSPC if there was a hash collision when moving existing
+                   HPT entries to the new HPT
+ 	 -EIO on other error conditions
+ 
+ Used to implement the PAPR extension for runtime resizing of a guest's
+ Hashed Page Table (HPT).  Specifically this starts, stops or monitors
+ the preparation of a new potential HPT for the guest, essentially
+ implementing the H_RESIZE_HPT_PREPARE hypercall.
+ 
+ If called with shift > 0 when there is no pending HPT for the guest,
+ this begins preparation of a new pending HPT of size 2^(shift) bytes.
+ It then returns a positive integer with the estimated number of
+ milliseconds until preparation is complete.
+ 
+ If called when there is a pending HPT whose size does not match that
+ requested in the parameters, discards the existing pending HPT and
+ creates a new one as above.
+ 
+ If called when there is a pending HPT of the size requested, will:
+   * If preparation of the pending HPT is already complete, return 0
+   * If preparation of the pending HPT has failed, return an error
+     code, then discard the pending HPT.
+   * If preparation of the pending HPT is still in progress, return an
+     estimated number of milliseconds until preparation is complete.
+ 
+ If called with shift == 0, discards any currently pending HPT and
+ returns 0 (i.e. cancels any in-progress preparation).
+ 
+ flags is reserved for future expansion, currently setting any bits in
+ flags will result in an -EINVAL.
+ 
+ Normally this will be called repeatedly with the same parameters until
+ it returns <= 0.  The first call will initiate preparation, subsequent
+ ones will monitor preparation until it completes or fails.
+ 
+ struct kvm_ppc_resize_hpt {
+ 	__u64 flags;
+ 	__u32 shift;
+ 	__u32 pad;
+ };
+ 
+ 4.103 KVM_PPC_RESIZE_HPT_COMMIT
+ 
+ Capability: KVM_CAP_SPAPR_RESIZE_HPT
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_resize_hpt (in)
+ Returns: 0 on successful completion,
+          -EFAULT if struct kvm_reinject_control cannot be read,
+ 	 -EINVAL if the supplied shift or flags are invalid
+ 	 -ENXIO is there is no pending HPT, or the pending HPT doesn't
+                  have the requested size
+ 	 -EBUSY if the pending HPT is not fully prepared
+ 	 -ENOSPC if there was a hash collision when moving existing
+                   HPT entries to the new HPT
+ 	 -EIO on other error conditions
+ 
+ Used to implement the PAPR extension for runtime resizing of a guest's
+ Hashed Page Table (HPT).  Specifically this requests that the guest be
+ transferred to working with the new HPT, essentially implementing the
+ H_RESIZE_HPT_COMMIT hypercall.
+ 
+ This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has
+ returned 0 with the same parameters.  In other cases
+ KVM_PPC_RESIZE_HPT_COMMIT will return an error (usually -ENXIO or
+ -EBUSY, though others may be possible if the preparation was started,
+ but failed).
+ 
+ This will have undefined effects on the guest if it has not already
+ placed itself in a quiescent state where no vcpu will make MMU enabled
+ memory accesses.
+ 
+ On succsful completion, the pending HPT will become the guest's active
+ HPT and the previous HPT will be discarded.
+ 
+ On failure, the guest will still be operating on its previous HPT.
+ 
+ struct kvm_ppc_resize_hpt {
+ 	__u64 flags;
+ 	__u32 shift;
+ 	__u32 pad;
+ };
+ 
+ 4.104 KVM_X86_GET_MCE_CAP_SUPPORTED
+ 
+ Capability: KVM_CAP_MCE
+ Architectures: x86
+ Type: system ioctl
+ Parameters: u64 mce_cap (out)
+ Returns: 0 on success, -1 on error
+ 
+ Returns supported MCE capabilities. The u64 mce_cap parameter
+ has the same format as the MSR_IA32_MCG_CAP register. Supported
+ capabilities will have the corresponding bits set.
+ 
+ 4.105 KVM_X86_SETUP_MCE
+ 
+ Capability: KVM_CAP_MCE
+ Architectures: x86
+ Type: vcpu ioctl
+ Parameters: u64 mcg_cap (in)
+ Returns: 0 on success,
+          -EFAULT if u64 mcg_cap cannot be read,
+          -EINVAL if the requested number of banks is invalid,
+          -EINVAL if requested MCE capability is not supported.
+ 
+ Initializes MCE support for use. The u64 mcg_cap parameter
+ has the same format as the MSR_IA32_MCG_CAP register and
+ specifies which capabilities should be enabled. The maximum
+ supported number of error-reporting banks can be retrieved when
+ checking for KVM_CAP_MCE. The supported capabilities can be
+ retrieved with KVM_X86_GET_MCE_CAP_SUPPORTED.
+ 
+ 4.106 KVM_X86_SET_MCE
+ 
+ Capability: KVM_CAP_MCE
+ Architectures: x86
+ Type: vcpu ioctl
+ Parameters: struct kvm_x86_mce (in)
+ Returns: 0 on success,
+          -EFAULT if struct kvm_x86_mce cannot be read,
+          -EINVAL if the bank number is invalid,
+          -EINVAL if VAL bit is not set in status field.
+ 
+ Inject a machine check error (MCE) into the guest. The input
+ parameter is:
+ 
+ struct kvm_x86_mce {
+ 	__u64 status;
+ 	__u64 addr;
+ 	__u64 misc;
+ 	__u64 mcg_status;
+ 	__u8 bank;
+ 	__u8 pad1[7];
+ 	__u64 pad2[3];
+ };
+ 
+ If the MCE being reported is an uncorrected error, KVM will
+ inject it as an MCE exception into the guest. If the guest
+ MCG_STATUS register reports that an MCE is in progress, KVM
+ causes an KVM_EXIT_SHUTDOWN vmexit.
+ 
+ Otherwise, if the MCE is a corrected error, KVM will just
+ store it in the corresponding bank (provided this bank is
+ not holding a previously reported uncorrected error).
+ 
+ 4.107 KVM_S390_GET_CMMA_BITS
+ 
+ Capability: KVM_CAP_S390_CMMA_MIGRATION
+ Architectures: s390
+ Type: vm ioctl
+ Parameters: struct kvm_s390_cmma_log (in, out)
+ Returns: 0 on success, a negative value on error
+ 
+ This ioctl is used to get the values of the CMMA bits on the s390
+ architecture. It is meant to be used in two scenarios:
+ - During live migration to save the CMMA values. Live migration needs
+   to be enabled via the KVM_REQ_START_MIGRATION VM property.
+ - To non-destructively peek at the CMMA values, with the flag
+   KVM_S390_CMMA_PEEK set.
+ 
+ The ioctl takes parameters via the kvm_s390_cmma_log struct. The desired
+ values are written to a buffer whose location is indicated via the "values"
+ member in the kvm_s390_cmma_log struct.  The values in the input struct are
+ also updated as needed.
+ Each CMMA value takes up one byte.
+ 
+ struct kvm_s390_cmma_log {
+ 	__u64 start_gfn;
+ 	__u32 count;
+ 	__u32 flags;
+ 	union {
+ 		__u64 remaining;
+ 		__u64 mask;
+ 	};
+ 	__u64 values;
+ };
+ 
+ start_gfn is the number of the first guest frame whose CMMA values are
+ to be retrieved,
+ 
+ count is the length of the buffer in bytes,
+ 
+ values points to the buffer where the result will be written to.
+ 
+ If count is greater than KVM_S390_SKEYS_MAX, then it is considered to be
+ KVM_S390_SKEYS_MAX. KVM_S390_SKEYS_MAX is re-used for consistency with
+ other ioctls.
+ 
+ The result is written in the buffer pointed to by the field values, and
+ the values of the input parameter are updated as follows.
+ 
+ Depending on the flags, different actions are performed. The only
+ supported flag so far is KVM_S390_CMMA_PEEK.
+ 
+ The default behaviour if KVM_S390_CMMA_PEEK is not set is:
+ start_gfn will indicate the first page frame whose CMMA bits were dirty.
+ It is not necessarily the same as the one passed as input, as clean pages
+ are skipped.
+ 
+ count will indicate the number of bytes actually written in the buffer.
+ It can (and very often will) be smaller than the input value, since the
+ buffer is only filled until 16 bytes of clean values are found (which
+ are then not copied in the buffer). Since a CMMA migration block needs
+ the base address and the length, for a total of 16 bytes, we will send
+ back some clean data if there is some dirty data afterwards, as long as
+ the size of the clean data does not exceed the size of the header. This
+ allows to minimize the amount of data to be saved or transferred over
+ the network at the expense of more roundtrips to userspace. The next
+ invocation of the ioctl will skip over all the clean values, saving
+ potentially more than just the 16 bytes we found.
+ 
+ If KVM_S390_CMMA_PEEK is set:
+ the existing storage attributes are read even when not in migration
+ mode, and no other action is performed;
+ 
+ the output start_gfn will be equal to the input start_gfn,
+ 
+ the output count will be equal to the input count, except if the end of
+ memory has been reached.
+ 
+ In both cases:
+ the field "remaining" will indicate the total number of dirty CMMA values
+ still remaining, or 0 if KVM_S390_CMMA_PEEK is set and migration mode is
+ not enabled.
+ 
+ mask is unused.
+ 
+ values points to the userspace buffer where the result will be stored.
+ 
+ This ioctl can fail with -ENOMEM if not enough memory can be allocated to
+ complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if
+ KVM_S390_CMMA_PEEK is not set but migration mode was not enabled, with
+ -EFAULT if the userspace address is invalid or if no page table is
+ present for the addresses (e.g. when using hugepages).
+ 
+ 4.108 KVM_S390_SET_CMMA_BITS
+ 
+ Capability: KVM_CAP_S390_CMMA_MIGRATION
+ Architectures: s390
+ Type: vm ioctl
+ Parameters: struct kvm_s390_cmma_log (in)
+ Returns: 0 on success, a negative value on error
+ 
+ This ioctl is used to set the values of the CMMA bits on the s390
+ architecture. It is meant to be used during live migration to restore
+ the CMMA values, but there are no restrictions on its use.
+ The ioctl takes parameters via the kvm_s390_cmma_values struct.
+ Each CMMA value takes up one byte.
+ 
+ struct kvm_s390_cmma_log {
+ 	__u64 start_gfn;
+ 	__u32 count;
+ 	__u32 flags;
+ 	union {
+ 		__u64 remaining;
+ 		__u64 mask;
+ 	};
+ 	__u64 values;
+ };
+ 
+ start_gfn indicates the starting guest frame number,
+ 
+ count indicates how many values are to be considered in the buffer,
+ 
+ flags is not used and must be 0.
+ 
+ mask indicates which PGSTE bits are to be considered.
+ 
+ remaining is not used.
+ 
+ values points to the buffer in userspace where to store the values.
+ 
+ This ioctl can fail with -ENOMEM if not enough memory can be allocated to
+ complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if
+ the count field is too large (e.g. more than KVM_S390_CMMA_SIZE_MAX) or
+ if the flags field was not 0, with -EFAULT if the userspace address is
+ invalid, if invalid pages are written to (e.g. after the end of memory)
+ or if no page table is present for the addresses (e.g. when using
+ hugepages).
+ 
+ 4.108 KVM_PPC_GET_CPU_CHAR
+ 
+ Capability: KVM_CAP_PPC_GET_CPU_CHAR
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_cpu_char (out)
+ Returns: 0 on successful completion
+ 	 -EFAULT if struct kvm_ppc_cpu_char cannot be written
+ 
+ This ioctl gives userspace information about certain characteristics
+ of the CPU relating to speculative execution of instructions and
+ possible information leakage resulting from speculative execution (see
+ CVE-2017-5715, CVE-2017-5753 and CVE-2017-5754).  The information is
+ returned in struct kvm_ppc_cpu_char, which looks like this:
+ 
+ struct kvm_ppc_cpu_char {
+ 	__u64	character;		/* characteristics of the CPU */
+ 	__u64	behaviour;		/* recommended software behaviour */
+ 	__u64	character_mask;		/* valid bits in character */
+ 	__u64	behaviour_mask;		/* valid bits in behaviour */
+ };
+ 
+ For extensibility, the character_mask and behaviour_mask fields
+ indicate which bits of character and behaviour have been filled in by
+ the kernel.  If the set of defined bits is extended in future then
+ userspace will be able to tell whether it is running on a kernel that
+ knows about the new bits.
+ 
+ The character field describes attributes of the CPU which can help
+ with preventing inadvertent information disclosure - specifically,
+ whether there is an instruction to flash-invalidate the L1 data cache
+ (ori 30,30,0 or mtspr SPRN_TRIG2,rN), whether the L1 data cache is set
+ to a mode where entries can only be used by the thread that created
+ them, whether the bcctr[l] instruction prevents speculation, and
+ whether a speculation barrier instruction (ori 31,31,0) is provided.
+ 
+ The behaviour field describes actions that software should take to
+ prevent inadvertent information disclosure, and thus describes which
+ vulnerabilities the hardware is subject to; specifically whether the
+ L1 data cache should be flushed when returning to user mode from the
+ kernel, and whether a speculation barrier should be placed between an
+ array bounds check and the array access.
+ 
+ These fields use the same bit definitions as the new
+ H_GET_CPU_CHARACTERISTICS hypercall.
+ 
++>>>>>>> 3214d01f139b (KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds)
  5. The kvm_run structure
  ------------------------
  
diff --cc arch/powerpc/include/uapi/asm/kvm.h
index a7b23d489043,637b7263cb86..000000000000
--- a/arch/powerpc/include/uapi/asm/kvm.h
+++ b/arch/powerpc/include/uapi/asm/kvm.h
@@@ -403,6 -423,51 +403,54 @@@ struct kvm_get_htab_header 
  	__u16	n_invalid;
  };
  
++<<<<<<< HEAD
++=======
+ /* For KVM_PPC_CONFIGURE_V3_MMU */
+ struct kvm_ppc_mmuv3_cfg {
+ 	__u64	flags;
+ 	__u64	process_table;	/* second doubleword of partition table entry */
+ };
+ 
+ /* Flag values for KVM_PPC_CONFIGURE_V3_MMU */
+ #define KVM_PPC_MMUV3_RADIX	1	/* 1 = radix mode, 0 = HPT */
+ #define KVM_PPC_MMUV3_GTSE	2	/* global translation shootdown enb. */
+ 
+ /* For KVM_PPC_GET_RMMU_INFO */
+ struct kvm_ppc_rmmu_info {
+ 	struct kvm_ppc_radix_geom {
+ 		__u8	page_shift;
+ 		__u8	level_bits[4];
+ 		__u8	pad[3];
+ 	}	geometries[8];
+ 	__u32	ap_encodings[8];
+ };
+ 
+ /* For KVM_PPC_GET_CPU_CHAR */
+ struct kvm_ppc_cpu_char {
+ 	__u64	character;		/* characteristics of the CPU */
+ 	__u64	behaviour;		/* recommended software behaviour */
+ 	__u64	character_mask;		/* valid bits in character */
+ 	__u64	behaviour_mask;		/* valid bits in behaviour */
+ };
+ 
+ /*
+  * Values for character and character_mask.
+  * These are identical to the values used by H_GET_CPU_CHARACTERISTICS.
+  */
+ #define KVM_PPC_CPU_CHAR_SPEC_BAR_ORI31		(1ULL << 63)
+ #define KVM_PPC_CPU_CHAR_BCCTRL_SERIALISED	(1ULL << 62)
+ #define KVM_PPC_CPU_CHAR_L1D_FLUSH_ORI30	(1ULL << 61)
+ #define KVM_PPC_CPU_CHAR_L1D_FLUSH_TRIG2	(1ULL << 60)
+ #define KVM_PPC_CPU_CHAR_L1D_THREAD_PRIV	(1ULL << 59)
+ #define KVM_PPC_CPU_CHAR_BR_HINT_HONOURED	(1ULL << 58)
+ #define KVM_PPC_CPU_CHAR_MTTRIG_THR_RECONF	(1ULL << 57)
+ #define KVM_PPC_CPU_CHAR_COUNT_CACHE_DIS	(1ULL << 56)
+ 
+ #define KVM_PPC_CPU_BEHAV_FAVOUR_SECURITY	(1ULL << 63)
+ #define KVM_PPC_CPU_BEHAV_L1D_FLUSH_PR		(1ULL << 62)
+ #define KVM_PPC_CPU_BEHAV_BNDS_CHK_SPEC_BAR	(1ULL << 61)
+ 
++>>>>>>> 3214d01f139b (KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds)
  /* Per-vcpu XICS interrupt controller state */
  #define KVM_REG_PPC_ICP_STATE	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x8c)
  
diff --cc arch/powerpc/kvm/powerpc.c
index bf177b4fc8d1,0a7c88786ec0..000000000000
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@@ -35,6 -36,14 +35,17 @@@
  #include <asm/tlbflush.h>
  #include <asm/cputhreads.h>
  #include <asm/irqflags.h>
++<<<<<<< HEAD
++=======
+ #include <asm/iommu.h>
+ #include <asm/switch_to.h>
+ #include <asm/xive.h>
+ #ifdef CONFIG_PPC_PSERIES
+ #include <asm/hvcall.h>
+ #include <asm/plpar_wrappers.h>
+ #endif
+ 
++>>>>>>> 3214d01f139b (KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds)
  #include "timing.h"
  #include "irq.h"
  #include "../mm/mmu_decl.h"
@@@ -551,8 -552,13 +562,9 @@@ int kvm_vm_ioctl_check_extension(struc
  #ifdef CONFIG_KVM_XICS
  	case KVM_CAP_IRQ_XICS:
  #endif
+ 	case KVM_CAP_PPC_GET_CPU_CHAR:
  		r = 1;
  		break;
 -
 -	case KVM_CAP_PPC_ALLOC_HTAB:
 -		r = hv_enabled;
 -		break;
  #endif /* CONFIG_PPC_BOOK3S_64 */
  #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
  	case KVM_CAP_PPC_SMT:
@@@ -1370,6 -1959,39 +1500,42 @@@ long kvm_arch_vm_ioctl(struct file *fil
  		r = kvm_vm_ioctl_rtas_define_token(kvm, argp);
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 	case KVM_PPC_CONFIGURE_V3_MMU: {
+ 		struct kvm *kvm = filp->private_data;
+ 		struct kvm_ppc_mmuv3_cfg cfg;
+ 
+ 		r = -EINVAL;
+ 		if (!kvm->arch.kvm_ops->configure_mmu)
+ 			goto out;
+ 		r = -EFAULT;
+ 		if (copy_from_user(&cfg, argp, sizeof(cfg)))
+ 			goto out;
+ 		r = kvm->arch.kvm_ops->configure_mmu(kvm, &cfg);
+ 		break;
+ 	}
+ 	case KVM_PPC_GET_RMMU_INFO: {
+ 		struct kvm *kvm = filp->private_data;
+ 		struct kvm_ppc_rmmu_info info;
+ 
+ 		r = -EINVAL;
+ 		if (!kvm->arch.kvm_ops->get_rmmu_info)
+ 			goto out;
+ 		r = kvm->arch.kvm_ops->get_rmmu_info(kvm, &info);
+ 		if (r >= 0 && copy_to_user(argp, &info, sizeof(info)))
+ 			r = -EFAULT;
+ 		break;
+ 	}
+ 	case KVM_PPC_GET_CPU_CHAR: {
+ 		struct kvm_ppc_cpu_char cpuchar;
+ 
+ 		r = kvmppc_get_cpu_char(&cpuchar);
+ 		if (r >= 0 && copy_to_user(argp, &cpuchar, sizeof(cpuchar)))
+ 			r = -EFAULT;
+ 		break;
+ 	}
++>>>>>>> 3214d01f139b (KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds)
  	default: {
  		struct kvm *kvm = filp->private_data;
  		r = kvm->arch.kvm_ops->arch_vm_ioctl(filp, ioctl, arg);
diff --cc include/uapi/linux/kvm.h
index 27ecc49f2a9f,7a99b98cf88e..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -702,8 -904,35 +702,33 @@@ struct kvm_ppc_smmu_info 
  #define KVM_CAP_GUEST_DEBUG_HW_WPS 120
  #define KVM_CAP_SPLIT_IRQCHIP 121
  #define KVM_CAP_IOEVENTFD_ANY_LENGTH 122
 -#define KVM_CAP_HYPERV_SYNIC 123
 -#define KVM_CAP_S390_RI 124
 -#define KVM_CAP_SPAPR_TCE_64 125
 -#define KVM_CAP_ARM_PMU_V3 126
 -#define KVM_CAP_VCPU_ATTRIBUTES 127
  #define KVM_CAP_MAX_VCPU_ID 128
  #define KVM_CAP_X2APIC_API 129
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_S390_USER_INSTR0 130
+ #define KVM_CAP_MSI_DEVID 131
+ #define KVM_CAP_PPC_HTM 132
+ #define KVM_CAP_SPAPR_RESIZE_HPT 133
+ #define KVM_CAP_PPC_MMU_RADIX 134
+ #define KVM_CAP_PPC_MMU_HASH_V3 135
+ #define KVM_CAP_IMMEDIATE_EXIT 136
+ #define KVM_CAP_MIPS_VZ 137
+ #define KVM_CAP_MIPS_TE 138
+ #define KVM_CAP_MIPS_64BIT 139
+ #define KVM_CAP_S390_GS 140
+ #define KVM_CAP_S390_AIS 141
+ #define KVM_CAP_SPAPR_TCE_VFIO 142
+ #define KVM_CAP_X86_GUEST_MWAIT 143
+ #define KVM_CAP_ARM_USER_IRQ 144
+ #define KVM_CAP_S390_CMMA_MIGRATION 145
+ #define KVM_CAP_PPC_FWNMI 146
+ #define KVM_CAP_PPC_SMT_POSSIBLE 147
+ #define KVM_CAP_HYPERV_SYNIC2 148
+ #define KVM_CAP_HYPERV_VP_INDEX 149
+ #define KVM_CAP_S390_AIS_MIGRATION 150
+ #define KVM_CAP_PPC_GET_CPU_CHAR 151
++>>>>>>> 3214d01f139b (KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
@@@ -991,6 -1255,15 +1016,18 @@@ struct kvm_s390_ucas_mapping 
  #define KVM_ARM_SET_DEVICE_ADDR	  _IOW(KVMIO,  0xab, struct kvm_arm_device_addr)
  /* Available with KVM_CAP_PPC_RTAS */
  #define KVM_PPC_RTAS_DEFINE_TOKEN _IOW(KVMIO,  0xac, struct kvm_rtas_token_args)
++<<<<<<< HEAD
++=======
+ /* Available with KVM_CAP_SPAPR_RESIZE_HPT */
+ #define KVM_PPC_RESIZE_HPT_PREPARE _IOR(KVMIO, 0xad, struct kvm_ppc_resize_hpt)
+ #define KVM_PPC_RESIZE_HPT_COMMIT  _IOR(KVMIO, 0xae, struct kvm_ppc_resize_hpt)
+ /* Available with KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3 */
+ #define KVM_PPC_CONFIGURE_V3_MMU  _IOW(KVMIO,  0xaf, struct kvm_ppc_mmuv3_cfg)
+ /* Available with KVM_CAP_PPC_RADIX_MMU */
+ #define KVM_PPC_GET_RMMU_INFO	  _IOW(KVMIO,  0xb0, struct kvm_ppc_rmmu_info)
+ /* Available with KVM_CAP_PPC_GET_CPU_CHAR */
+ #define KVM_PPC_GET_CPU_CHAR	  _IOR(KVMIO,  0xb1, struct kvm_ppc_cpu_char)
++>>>>>>> 3214d01f139b (KVM: PPC: Book3S: Provide information about hardware/firmware CVE workarounds)
  
  /* ioctl for vm fd */
  #define KVM_CREATE_DEVICE	  _IOWR(KVMIO,  0xe0, struct kvm_create_device)
* Unmerged path Documentation/virtual/kvm/api.txt
* Unmerged path arch/powerpc/include/uapi/asm/kvm.h
* Unmerged path arch/powerpc/kvm/powerpc.c
* Unmerged path include/uapi/linux/kvm.h
