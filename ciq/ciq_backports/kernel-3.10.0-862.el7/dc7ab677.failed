ovl: fix dentry leak in ovl_indexdir_cleanup()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit dc7ab6773e8171e07f16fd0df0c5eea28c899503
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/dc7ab677.failed

index dentry was not released when breaking out of the loop
due to index verification error.

Fixes: 415543d5c64f ("ovl: cleanup bad and stale index entries on mount")
	Cc: <stable@vger.kernel.org> # v4.13
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit dc7ab6773e8171e07f16fd0df0c5eea28c899503)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/readdir.c
diff --cc fs/overlayfs/readdir.c
index 2010cf9bd904,0f85ee9c3268..000000000000
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@@ -678,3 -983,59 +678,62 @@@ void ovl_workdir_cleanup(struct inode *
  		ovl_cleanup(dir, dentry);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
+ 			 struct path *lowerstack, unsigned int numlower)
+ {
+ 	int err;
+ 	struct dentry *index = NULL;
+ 	struct inode *dir = dentry->d_inode;
+ 	struct path path = { .mnt = mnt, .dentry = dentry };
+ 	LIST_HEAD(list);
+ 	struct rb_root root = RB_ROOT;
+ 	struct ovl_cache_entry *p;
+ 	struct ovl_readdir_data rdd = {
+ 		.ctx.actor = ovl_fill_merge,
+ 		.dentry = NULL,
+ 		.list = &list,
+ 		.root = &root,
+ 		.is_lowest = false,
+ 	};
+ 
+ 	err = ovl_dir_read(&path, &rdd);
+ 	if (err)
+ 		goto out;
+ 
+ 	inode_lock_nested(dir, I_MUTEX_PARENT);
+ 	list_for_each_entry(p, &list, l_node) {
+ 		if (p->name[0] == '.') {
+ 			if (p->len == 1)
+ 				continue;
+ 			if (p->len == 2 && p->name[1] == '.')
+ 				continue;
+ 		}
+ 		index = lookup_one_len(p->name, dentry, p->len);
+ 		if (IS_ERR(index)) {
+ 			err = PTR_ERR(index);
+ 			index = NULL;
+ 			break;
+ 		}
+ 		err = ovl_verify_index(index, lowerstack, numlower);
+ 		if (err) {
+ 			if (err == -EROFS)
+ 				break;
+ 			err = ovl_cleanup(dir, index);
+ 			if (err)
+ 				break;
+ 		}
+ 		dput(index);
+ 		index = NULL;
+ 	}
+ 	dput(index);
+ 	inode_unlock(dir);
+ out:
+ 	ovl_cache_free(&list);
+ 	if (err)
+ 		pr_err("overlayfs: failed index dir cleanup (%i)\n", err);
+ 	return err;
+ }
++>>>>>>> dc7ab6773e81 (ovl: fix dentry leak in ovl_indexdir_cleanup())
* Unmerged path fs/overlayfs/readdir.c
