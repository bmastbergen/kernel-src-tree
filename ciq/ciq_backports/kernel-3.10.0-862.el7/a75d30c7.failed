fs/locks: pass kernel struct flock to fcntl_getlk/setlk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] locks: pass kernel struct flock to fcntl_getlk/setlk (Benjamin Coddington) [1449486]
Rebuild_FUZZ: 97.20%
commit-author Christoph Hellwig <hch@lst.de>
commit a75d30c772078546ac00399a94ecdc82df1a4d72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a75d30c7.failed

This will make it easier to implement a sane compat fcntl syscall.

[ jlayton: fix undeclared identifiers in 32-bit fcntl64 syscall handler ]

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Jeff Layton <jlayton@redhat.com>
(cherry picked from commit a75d30c772078546ac00399a94ecdc82df1a4d72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fcntl.c
#	fs/locks.c
diff --cc fs/fcntl.c
index 7ce6511af2e5,ed4283d500a3..000000000000
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@@ -274,12 -270,28 +276,18 @@@ static long do_fcntl(int fd, unsigned i
  	case F_SETFL:
  		err = setfl(fd, filp, arg);
  		break;
 -#if BITS_PER_LONG != 32
 -	/* 32-bit arches must use fcntl64() */
 -	case F_OFD_GETLK:
 -#endif
  	case F_GETLK:
- 		err = fcntl_getlk(filp, cmd, (struct flock __user *) arg);
+ 		if (copy_from_user(&flock, argp, sizeof(flock)))
+ 			return -EFAULT;
+ 		err = fcntl_getlk(filp, cmd, &flock);
+ 		if (!err && copy_to_user(argp, &flock, sizeof(flock)))
+ 			return -EFAULT;
  		break;
 -#if BITS_PER_LONG != 32
 -	/* 32-bit arches must use fcntl64() */
 -	case F_OFD_SETLK:
 -	case F_OFD_SETLKW:
 -#endif
 -		/* Fallthrough */
  	case F_SETLK:
  	case F_SETLKW:
- 		err = fcntl_setlk(fd, filp, cmd, (struct flock __user *) arg);
+ 		if (copy_from_user(&flock, argp, sizeof(flock)))
+ 			return -EFAULT;
+ 		err = fcntl_setlk(fd, filp, cmd, &flock);
  		break;
  	case F_GETOWN:
  		/*
@@@ -394,17 -409,27 +404,41 @@@ SYSCALL_DEFINE3(fcntl64, unsigned int, 
  		goto out1;
  	
  	switch (cmd) {
++<<<<<<< HEAD
 +		case F_GETLK64:
 +			err = fcntl_getlk64(f.file, cmd, (struct flock64 __user *) arg);
 +			break;
 +		case F_SETLK64:
 +		case F_SETLKW64:
 +			err = fcntl_setlk64(fd, f.file, cmd,
 +					(struct flock64 __user *) arg);
 +			break;
 +		default:
 +			err = do_fcntl(fd, cmd, arg, f.file);
 +			break;
++=======
+ 	case F_GETLK64:
+ 	case F_OFD_GETLK:
+ 		err = -EFAULT;
+ 		if (copy_from_user(&flock, argp, sizeof(flock)))
+ 			break;
+ 		err = fcntl_getlk64(f.file, cmd, &flock);
+ 		if (!err && copy_to_user(argp, &flock, sizeof(flock)))
+ 			err = -EFAULT;
+ 		break;
+ 	case F_SETLK64:
+ 	case F_SETLKW64:
+ 	case F_OFD_SETLK:
+ 	case F_OFD_SETLKW:
+ 		err = -EFAULT;
+ 		if (copy_from_user(&flock, argp, sizeof(flock)))
+ 			break;
+ 		err = fcntl_setlk64(fd, f.file, cmd, &flock);
+ 		break;
+ 	default:
+ 		err = do_fcntl(fd, cmd, arg, f.file);
+ 		break;
++>>>>>>> a75d30c77207 (fs/locks: pass kernel struct flock to fcntl_getlk/setlk)
  	}
  out1:
  	fdput(f);
diff --cc fs/locks.c
index 20dcff562a1d,afefeb4ad6de..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -2009,6 -2097,16 +2005,19 @@@ int fcntl_getlk(struct file *filp, unsi
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK;
+ 		file_lock.fl_flags |= FL_OFDLCK;
+ 		file_lock.fl_owner = filp;
+ 	}
+ 
++>>>>>>> a75d30c77207 (fs/locks: pass kernel struct flock to fcntl_getlk/setlk)
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2109,15 -2219,6 +2114,18 @@@ int fcntl_setlk(unsigned int fd, struc
  	if (file_lock == NULL)
  		return -ENOLCK;
  
++<<<<<<< HEAD
 +	/*
 +	 * This might block, so we do it before checking the inode.
 +	 */
 +	error = -EFAULT;
 +	if (copy_from_user(&flock, l, sizeof(flock)))
 +		goto out;
 +
 +	inode = locks_inode(filp);
 +
++=======
++>>>>>>> a75d30c77207 (fs/locks: pass kernel struct flock to fcntl_getlk/setlk)
  	/* Don't allow mandatory locks on files that may be memory mapped
  	 * and shared.
  	 */
@@@ -2126,14 -2227,41 +2134,49 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +again:
 +	error = flock_to_posix_lock(filp, file_lock, &flock);
 +	if (error)
 +		goto out;
 +	if (cmd == F_SETLKW) {
++=======
+ 	error = flock_to_posix_lock(filp, file_lock, flock);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = check_fmode_for_setlk(file_lock);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_OFDLCK flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW:
++>>>>>>> a75d30c77207 (fs/locks: pass kernel struct flock to fcntl_getlk/setlk)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
@@@ -2179,6 -2309,16 +2218,19 @@@ int fcntl_getlk64(struct file *filp, un
  	if (error)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (cmd == F_OFD_GETLK) {
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_GETLK64;
+ 		file_lock.fl_flags |= FL_OFDLCK;
+ 		file_lock.fl_owner = filp;
+ 	}
+ 
++>>>>>>> a75d30c77207 (fs/locks: pass kernel struct flock to fcntl_getlk/setlk)
  	error = vfs_test_lock(filp, &file_lock);
  	if (error)
  		goto out;
@@@ -2228,14 -2354,41 +2266,49 @@@ int fcntl_setlk64(unsigned int fd, stru
  		goto out;
  	}
  
++<<<<<<< HEAD
 +again:
 +	error = flock64_to_posix_lock(filp, file_lock, &flock);
 +	if (error)
 +		goto out;
 +	if (cmd == F_SETLKW64) {
++=======
+ 	error = flock64_to_posix_lock(filp, file_lock, flock);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = check_fmode_for_setlk(file_lock);
+ 	if (error)
+ 		goto out;
+ 
+ 	/*
+ 	 * If the cmd is requesting file-private locks, then set the
+ 	 * FL_OFDLCK flag and override the owner.
+ 	 */
+ 	switch (cmd) {
+ 	case F_OFD_SETLK:
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLK64;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = filp;
+ 		break;
+ 	case F_OFD_SETLKW:
+ 		error = -EINVAL;
+ 		if (flock->l_pid != 0)
+ 			goto out;
+ 
+ 		cmd = F_SETLKW64;
+ 		file_lock->fl_flags |= FL_OFDLCK;
+ 		file_lock->fl_owner = filp;
+ 		/* Fallthrough */
+ 	case F_SETLKW64:
++>>>>>>> a75d30c77207 (fs/locks: pass kernel struct flock to fcntl_getlk/setlk)
  		file_lock->fl_flags |= FL_SLEEP;
  	}
 -
 +	
  	error = do_lock_file_wait(filp, cmd, file_lock);
  
  	/*
* Unmerged path fs/fcntl.c
* Unmerged path fs/locks.c
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4086333a0708..12527bfec693 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1137,14 +1137,14 @@ static inline struct inode *locks_inode(const struct file *f)
 }
 
 #ifdef CONFIG_FILE_LOCKING
-extern int fcntl_getlk(struct file *, unsigned int, struct flock __user *);
+extern int fcntl_getlk(struct file *, unsigned int, struct flock *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
-			struct flock __user *);
+			struct flock *);
 
 #if BITS_PER_LONG == 32
-extern int fcntl_getlk64(struct file *, unsigned int, struct flock64 __user *);
+extern int fcntl_getlk64(struct file *, unsigned int, struct flock64 *);
 extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
-			struct flock64 __user *);
+			struct flock64 *);
 #endif
 
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
