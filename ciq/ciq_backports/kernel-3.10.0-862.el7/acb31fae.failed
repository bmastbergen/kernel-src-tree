net: sched: push chain dump to a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] sched: push chain dump to a separate function (Ivan Vecera) [1445420]
Rebuild_FUZZ: 94.74%
commit-author Jiri Pirko <jiri@mellanox.com>
commit acb31fae3b352b0b9eba7cefe1f669ad639c41d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/acb31fae.failed

Since there will be multiple chains to dump, push chain dumping code to
a separate function.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit acb31fae3b352b0b9eba7cefe1f669ad639c41d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 1dc6d123ed94,63aa2ea5f00c..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -462,11 -690,10 +508,14 @@@ static void tcf_chain_dump(struct tcf_c
  static int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)
  {
  	struct net *net = sock_net(skb->sk);
- 	int t;
- 	int s_t;
  	struct net_device *dev;
  	struct Qdisc *q;
++<<<<<<< HEAD
 +	struct tcf_proto *tp, __rcu **chain;
++=======
+ 	struct tcf_block *block;
+ 	struct tcf_chain *chain;
++>>>>>>> acb31fae3b35 (net: sched: push chain dump to a separate function)
  	struct tcmsg *tcm = nlmsg_data(cb->nlh);
  	unsigned long cl = 0;
  	const struct Qdisc_class_ops *cops;
@@@ -494,49 -722,15 +544,56 @@@
  		if (cl == 0)
  			goto errout;
  	}
 -	block = cops->tcf_block(q, cl);
 -	if (!block)
 +	chain = cops->tcf_chain(q, cl);
 +	if (chain == NULL)
  		goto errout;
 -	chain = block->chain;
  
++<<<<<<< HEAD
 +	s_t = cb->args[0];
 +
 +	for (tp = rtnl_dereference(*chain), t = 0;
 +	     tp; tp = rtnl_dereference(tp->next), t++) {
 +		if (t < s_t)
 +			continue;
 +		if (TC_H_MAJ(tcm->tcm_info) &&
 +		    TC_H_MAJ(tcm->tcm_info) != tp->prio)
 +			continue;
 +		if (TC_H_MIN(tcm->tcm_info) &&
 +		    TC_H_MIN(tcm->tcm_info) != tp->protocol)
 +			continue;
 +		if (t > s_t)
 +			memset(&cb->args[1], 0,
 +			       sizeof(cb->args)-sizeof(cb->args[0]));
 +		if (cb->args[1] == 0) {
 +			if (tcf_fill_node(net, skb, tp, 0,
 +					  NETLINK_CB(cb->skb).portid,
 +					  cb->nlh->nlmsg_seq, NLM_F_MULTI,
 +					  RTM_NEWTFILTER) <= 0)
 +				break;
 +
 +			cb->args[1] = 1;
 +		}
 +		if (tp->ops->walk == NULL)
 +			continue;
 +		arg.w.fn = tcf_node_dump;
 +		arg.skb = skb;
 +		arg.cb = cb;
 +		arg.w.stop = 0;
 +		arg.w.skip = cb->args[1] - 1;
 +		arg.w.count = 0;
 +		tp->ops->walk(tp, &arg.w);
 +		cb->args[1] = arg.w.count + 1;
 +		if (arg.w.stop)
 +			break;
 +	}
 +
 +	cb->args[0] = t;
++=======
+ 	index_start = cb->args[0];
+ 	index = 0;
+ 	tcf_chain_dump(chain, skb, cb, index_start, &index);
+ 	cb->args[0] = index;
++>>>>>>> acb31fae3b35 (net: sched: push chain dump to a separate function)
  
  errout:
  	if (cl)
* Unmerged path net/sched/cls_api.c
