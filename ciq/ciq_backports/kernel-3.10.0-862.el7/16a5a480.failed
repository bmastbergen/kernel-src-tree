nvmet-fc: correct use after free on list teardown

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [nvme] fc: correct use after free on list teardown (David Milburn) [1457880 1456486 1454365]
Rebuild_FUZZ: 93.48%
commit-author James Smart <jsmart2021@gmail.com>
commit 16a5a480f067f945fd27bf91ffdce3f959b0d4b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/16a5a480.failed

Use list_for_each_entry_safe to prevent list handling from referencing
next pointers directly after list_del's

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 16a5a480f067f945fd27bf91ffdce3f959b0d4b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/fc.c
diff --cc drivers/nvme/target/fc.c
index 58773994b97a,b200f9aadd52..000000000000
--- a/drivers/nvme/target/fc.c
+++ b/drivers/nvme/target/fc.c
@@@ -639,9 -702,11 +639,13 @@@ nvmet_fc_abort_op(struct nvmet_fc_tgtpo
  static void
  nvmet_fc_delete_target_queue(struct nvmet_fc_tgt_queue *queue)
  {
 -	struct nvmet_fc_tgtport *tgtport = queue->assoc->tgtport;
  	struct nvmet_fc_fcp_iod *fod = queue->fod;
++<<<<<<< HEAD
++=======
+ 	struct nvmet_fc_defer_fcp_req *deferfcp, *tempptr;
++>>>>>>> 16a5a480f067 (nvmet-fc: correct use after free on list teardown)
  	unsigned long flags;
 -	int i, writedataactive;
 +	int i;
  	bool disconnect;
  
  	disconnect = atomic_xchg(&queue->connected, 0);
@@@ -652,9 -717,52 +656,42 @@@
  		if (fod->active) {
  			spin_lock(&fod->flock);
  			fod->abort = true;
 -			writedataactive = fod->writedataactive;
  			spin_unlock(&fod->flock);
 -			/*
 -			 * only call lldd abort routine if waiting for
 -			 * writedata. other outstanding ops should finish
 -			 * on their own.
 -			 */
 -			if (writedataactive) {
 -				spin_lock(&fod->flock);
 -				fod->aborted = true;
 -				spin_unlock(&fod->flock);
 -				tgtport->ops->fcp_abort(
 -					&tgtport->fc_target_port, fod->fcpreq);
 -			}
  		}
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/* Cleanup defer'ed IOs in queue */
+ 	list_for_each_entry_safe(deferfcp, tempptr, &queue->avail_defer_list,
+ 				req_list) {
+ 		list_del(&deferfcp->req_list);
+ 		kfree(deferfcp);
+ 	}
+ 
+ 	for (;;) {
+ 		deferfcp = list_first_entry_or_null(&queue->pending_cmd_list,
+ 				struct nvmet_fc_defer_fcp_req, req_list);
+ 		if (!deferfcp)
+ 			break;
+ 
+ 		list_del(&deferfcp->req_list);
+ 		spin_unlock_irqrestore(&queue->qlock, flags);
+ 
+ 		tgtport->ops->defer_rcv(&tgtport->fc_target_port,
+ 				deferfcp->fcp_req);
+ 
+ 		tgtport->ops->fcp_abort(&tgtport->fc_target_port,
+ 				deferfcp->fcp_req);
+ 
+ 		tgtport->ops->fcp_req_release(&tgtport->fc_target_port,
+ 				deferfcp->fcp_req);
+ 
+ 		kfree(deferfcp);
+ 
+ 		spin_lock_irqsave(&queue->qlock, flags);
+ 	}
++>>>>>>> 16a5a480f067 (nvmet-fc: correct use after free on list teardown)
  	spin_unlock_irqrestore(&queue->qlock, flags);
  
  	flush_workqueue(queue->work_q);
* Unmerged path drivers/nvme/target/fc.c
