scsi: qla2xxx: Remove redundant wait when target is stopped.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Remove redundant wait when target is stopped (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 93.81%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 3a33dc95b00be33f150bc357ab67331cdba7fc88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3a33dc95.failed

Current code already destroy all target sessions when target Mode is
stopped. Target core would waits for all commands that belong to each
session to purge.  The extra wait for interrupts to settle down is not
relevant.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3a33dc95b00be33f150bc357ab67331cdba7fc88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index f10c075d97ef,f9ccf845d084..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -919,14 -1415,31 +919,34 @@@ void qlt_stop_phase1(struct qla_tgt *tg
  	struct qla_hw_data *ha = tgt->ha;
  	unsigned long flags;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&qla_tgt_mutex);
+ 	if (!vha->fc_vport) {
+ 		struct Scsi_Host *sh = vha->host;
+ 		struct fc_host_attrs *fc_host = shost_to_fc_host(sh);
+ 		bool npiv_vports;
+ 
+ 		spin_lock_irqsave(sh->host_lock, flags);
+ 		npiv_vports = (fc_host->npiv_vports_inuse);
+ 		spin_unlock_irqrestore(sh->host_lock, flags);
+ 
+ 		if (npiv_vports) {
+ 			mutex_unlock(&qla_tgt_mutex);
+ 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf021,
+ 			    "NPIV is in use. Can not stop target\n");
+ 			return -EPERM;
+ 		}
+ 	}
++>>>>>>> 3a33dc95b00b (scsi: qla2xxx: Remove redundant wait when target is stopped.)
  	if (tgt->tgt_stop || tgt->tgt_stopped) {
  		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04e,
  		    "Already in tgt->tgt_stop or tgt_stopped state\n");
 -		mutex_unlock(&qla_tgt_mutex);
 -		return -EPERM;
 +		dump_stack();
 +		return;
  	}
  
- 	ql_dbg(ql_dbg_tgt, vha, 0xe003, "Stopping target for host %ld(%p)\n",
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xe003, "Stopping target for host %ld(%p)\n",
  	    vha->host_no, vha);
  	/*
  	 * Mutex needed to sync with qla_tgt_fc_port_[added,deleted].
@@@ -970,33 -1482,27 +990,53 @@@ EXPORT_SYMBOL(qlt_stop_phase1)
  /* Called by tcm_qla2xxx configfs code */
  void qlt_stop_phase2(struct qla_tgt *tgt)
  {
++<<<<<<< HEAD
 +	struct qla_hw_data *ha = tgt->ha;
 +	unsigned long flags;
++=======
+ 	scsi_qla_host_t *vha = tgt->vha;
++>>>>>>> 3a33dc95b00b (scsi: qla2xxx: Remove redundant wait when target is stopped.)
  
  	if (tgt->tgt_stopped) {
 -		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04f,
 +		ql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf04f,
  		    "Already in tgt->tgt_stopped state\n");
  		dump_stack();
  		return;
  	}
++<<<<<<< HEAD
 +
 +	ql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf00b,
 +	    "Waiting for %d IRQ commands to complete (tgt %p)",
 +	    tgt->irq_cmd_count, tgt);
 +
 +	mutex_lock(&ha->tgt.tgt_mutex);
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	while (tgt->irq_cmd_count != 0) {
 +		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +		udelay(2);
 +		spin_lock_irqsave(&ha->hardware_lock, flags);
 +	}
 +	tgt->tgt_stop = 0;
 +	tgt->tgt_stopped = 1;
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	mutex_unlock(&ha->tgt.tgt_mutex);
 +
 +	ql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf00c, "Stop of tgt %p finished",
++=======
+ 	if (!tgt->tgt_stop) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00b,
+ 		    "%s: phase1 stop is not completed\n", __func__);
+ 		dump_stack();
+ 		return;
+ 	}
+ 
+ 	mutex_lock(&vha->vha_tgt.tgt_mutex);
+ 	tgt->tgt_stop = 0;
+ 	tgt->tgt_stopped = 1;
+ 	mutex_unlock(&vha->vha_tgt.tgt_mutex);
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00c, "Stop of tgt %p finished\n",
++>>>>>>> 3a33dc95b00b (scsi: qla2xxx: Remove redundant wait when target is stopped.)
  	    tgt);
  }
  EXPORT_SYMBOL(qlt_stop_phase2);
@@@ -1004,14 -1510,18 +1044,22 @@@
  /* Called from qlt_remove_target() -> qla2x00_remove_one() */
  static void qlt_release(struct qla_tgt *tgt)
  {
 -	scsi_qla_host_t *vha = tgt->vha;
 +	struct qla_hw_data *ha = tgt->ha;
  
++<<<<<<< HEAD
 +	if ((ha->tgt.qla_tgt != NULL) && !tgt->tgt_stopped)
++=======
+ 	if ((vha->vha_tgt.qla_tgt != NULL) && !tgt->tgt_stop &&
+ 	    !tgt->tgt_stopped)
+ 		qlt_stop_phase1(tgt);
+ 
+ 	if ((vha->vha_tgt.qla_tgt != NULL) && !tgt->tgt_stopped)
++>>>>>>> 3a33dc95b00b (scsi: qla2xxx: Remove redundant wait when target is stopped.)
  		qlt_stop_phase2(tgt);
  
 -	vha->vha_tgt.qla_tgt = NULL;
 +	ha->tgt.qla_tgt = NULL;
  
 -	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00d,
 +	ql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf00d,
  	    "Release of tgt %p finished\n", tgt);
  
  	kfree(tgt);
@@@ -3948,15 -5527,10 +3996,19 @@@ void qlt_async_event(uint16_t code, str
  	uint16_t *mailbox)
  {
  	struct qla_hw_data *ha = vha->hw;
 -	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 +	struct qla_tgt *tgt = ha->tgt.qla_tgt;
  	int login_code;
  
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, vha, 0xe039,
 +	    "scsi(%ld): ha state %d init_done %d oper_mode %d topo %d\n",
 +	    vha->host_no, atomic_read(&vha->loop_state), vha->flags.init_done,
 +	    ha->operating_mode, ha->current_topology);
 +
 +	if (!ha->tgt.tgt_ops)
++=======
+ 	if (!tgt || tgt->tgt_stop || tgt->tgt_stopped)
++>>>>>>> 3a33dc95b00b (scsi: qla2xxx: Remove redundant wait when target is stopped.)
  		return;
  
  	if (unlikely(tgt == NULL)) {
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
