vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Matthias Schiffer <mschiffer@universe-factory.net>
commit 49f810f00fa347427fa8cba2197b303234842d25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/49f810f0.failed

As link-local addresses are only valid for a single interface, we can allow
to use the same VNI for multiple independent VXLANs, as long as the used
interfaces are distinct. This way, VXLANs can always be used as a drop-in
replacement for VLANs with greater ID space.

This also extends VNI lookup to respect the ifindex when link-local IPv6
addresses are used, so using the same VNI on multiple interfaces can
actually work.

	Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 49f810f00fa347427fa8cba2197b303234842d25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 740e6d79f5f2,653b2bb32be1..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -225,17 -226,28 +225,34 @@@ static struct vxlan_sock *vxlan_find_so
  	return NULL;
  }
  
- static struct vxlan_dev *vxlan_vs_find_vni(struct vxlan_sock *vs, __be32 vni)
+ static struct vxlan_dev *vxlan_vs_find_vni(struct vxlan_sock *vs, int ifindex,
+ 					   __be32 vni)
  {
 -	struct vxlan_dev *vxlan;
 +	struct vxlan_dev_node *node;
  
  	/* For flow based devices, map all packets to VNI 0 */
  	if (vs->flags & VXLAN_F_COLLECT_METADATA)
  		vni = 0;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(node, vni_head(vs, vni), hlist) {
 +		if (node->vxlan->default_dst.remote_vni == vni)
 +			return node->vxlan;
++=======
+ 	hlist_for_each_entry_rcu(vxlan, vni_head(vs, vni), hlist) {
+ 		if (vxlan->default_dst.remote_vni != vni)
+ 			continue;
+ 
+ 		if (IS_ENABLED(CONFIG_IPV6)) {
+ 			const struct vxlan_config *cfg = &vxlan->cfg;
+ 
+ 			if ((cfg->flags & VXLAN_F_IPV6_LINKLOCAL) &&
+ 			    cfg->remote_ifindex != ifindex)
+ 				continue;
+ 		}
+ 
+ 		return vxlan;
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  	}
  
  	return NULL;
@@@ -1292,7 -1369,9 +1309,13 @@@ static int vxlan_rcv(struct sock *sk, s
  	if (!vs)
  		goto drop;
  
++<<<<<<< HEAD
 +	vxlan = vxlan_vs_find_vni(vs, vxlan_vni(vxlan_hdr(skb)->vx_vni));
++=======
+ 	vni = vxlan_vni(vxlan_hdr(skb)->vx_vni);
+ 
+ 	vxlan = vxlan_vs_find_vni(vs, skb->dev->ifindex, vni);
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  	if (!vxlan)
  		goto drop;
  
@@@ -1900,8 -2032,45 +1923,47 @@@ static void vxlan_encap_bypass(struct s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int encap_bypass_if_local(struct sk_buff *skb, struct net_device *dev,
+ 				 struct vxlan_dev *vxlan,
+ 				 union vxlan_addr *daddr,
+ 				 __be16 dst_port, int dst_ifindex, __be32 vni,
+ 				 struct dst_entry *dst,
+ 				 u32 rt_flags)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	/* IPv6 rt-flags are checked against RTF_LOCAL, but the value of
+ 	 * RTF_LOCAL is equal to RTCF_LOCAL. So to keep code simple
+ 	 * we can use RTCF_LOCAL which works for ipv4 and ipv6 route entry.
+ 	 */
+ 	BUILD_BUG_ON(RTCF_LOCAL != RTF_LOCAL);
+ #endif
+ 	/* Bypass encapsulation if the destination is local */
+ 	if (rt_flags & RTCF_LOCAL &&
+ 	    !(rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
+ 		struct vxlan_dev *dst_vxlan;
+ 
+ 		dst_release(dst);
+ 		dst_vxlan = vxlan_find_vni(vxlan->net, dst_ifindex, vni,
+ 					   daddr->sa.sa_family, dst_port,
+ 					   vxlan->cfg.flags);
+ 		if (!dst_vxlan) {
+ 			dev->stats.tx_errors++;
+ 			kfree_skb(skb);
+ 
+ 			return -ENOENT;
+ 		}
+ 		vxlan_encap_bypass(skb, vxlan, dst_vxlan, vni);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
 -			   __be32 default_vni, struct vxlan_rdst *rdst,
 -			   bool did_rsc)
 +			   struct vxlan_rdst *rdst, bool did_rsc)
  {
  	struct dst_cache *dst_cache;
  	struct ip_tunnel_info *info;
@@@ -1915,22 -2081,47 +1977,29 @@@
  	struct vxlan_metadata _md;
  	struct vxlan_metadata *md = &_md;
  	__be16 src_port = 0, dst_port;
 -	struct dst_entry *ndst = NULL;
  	__be32 vni, label;
 +	__be16 df = 0;
  	__u8 tos, ttl;
+ 	int ifindex;
  	int err;
 -	u32 flags = vxlan->cfg.flags;
 +	u32 flags = vxlan->flags;
  	bool udp_sum = false;
  	bool xnet = !net_eq(vxlan->net, dev_net(vxlan->dev));
  
  	info = skb_tunnel_info(skb);
  
  	if (rdst) {
 -		dst = &rdst->remote_ip;
 -		if (vxlan_addr_any(dst)) {
 -			if (did_rsc) {
 -				/* short-circuited back to local bridge */
 -				vxlan_encap_bypass(skb, vxlan, vxlan, default_vni);
 -				return;
 -			}
 -			goto drop;
 -		}
 -
  		dst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;
++<<<<<<< HEAD
 +		vni = rdst->remote_vni;
 +		dst = &rdst->remote_ip;
 +		src = &vxlan->cfg.saddr;
++=======
+ 		vni = (rdst->remote_vni) ? : default_vni;
+ 		ifindex = rdst->remote_ifindex;
+ 		local_ip = vxlan->cfg.saddr;
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  		dst_cache = &rdst->dst_cache;
 -		md->gbp = skb->mark;
 -		ttl = vxlan->cfg.ttl;
 -		if (!ttl && vxlan_addr_multicast(dst))
 -			ttl = 1;
 -
 -		tos = vxlan->cfg.tos;
 -		if (tos == 1)
 -			tos = ip_tunnel_get_dsfield(old_iph, skb);
 -
 -		if (dst->sa.sa_family == AF_INET)
 -			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM_TX);
 -		else
 -			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
 -		label = vxlan->cfg.label;
  	} else {
  		if (!info) {
  			WARN_ONCE(1, "%s: Missing encapsulation instructions\n",
@@@ -1948,147 -2137,83 +2017,183 @@@
  			local_ip.sin6.sin6_addr = info->key.u.ipv6.src;
  		}
  		dst = &remote_ip;
++<<<<<<< HEAD
 +		src = &local_ip;
++=======
+ 		dst_port = info->key.tp_dst ? : vxlan->cfg.dst_port;
+ 		vni = tunnel_id_to_key32(info->key.tun_id);
+ 		ifindex = 0;
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  		dst_cache = &info->dst_cache;
 -		if (info->options_len)
 -			md = ip_tunnel_info_opts(info);
 +	}
 +
 +	if (vxlan_addr_any(dst)) {
 +		if (did_rsc) {
 +			/* short-circuited back to local bridge */
 +			vxlan_encap_bypass(skb, vxlan, vxlan);
 +			return;
 +		}
 +		goto drop;
 +	}
 +
 +	old_iph = ip_hdr(skb);
 +
 +	ttl = vxlan->cfg.ttl;
 +	if (!ttl && vxlan_addr_multicast(dst))
 +		ttl = 1;
 +
 +	tos = vxlan->cfg.tos;
 +	if (tos == 1)
 +		tos = ip_tunnel_get_dsfield(old_iph, skb);
 +
 +	label = vxlan->cfg.label;
 +	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
 +				     vxlan->cfg.port_max, true);
 +
 +	if (info) {
  		ttl = info->key.ttl;
  		tos = info->key.tos;
  		label = info->key.label;
  		udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);
 +
 +		if (info->options_len)
 +			md = ip_tunnel_info_opts(info);
 +	} else {
 +		md->gbp = skb->mark;
  	}
 -	src_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
 -				     vxlan->cfg.port_max, true);
  
 -	rcu_read_lock();
  	if (dst->sa.sa_family == AF_INET) {
 -		struct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);
 -		struct rtable *rt;
 -		__be16 df = 0;
 +		if (!vxlan->vn4_sock)
 +			goto drop;
 +		sk = vxlan->vn4_sock->sock->sk;
  
++<<<<<<< HEAD
 +		rt = vxlan_get_route(vxlan, skb,
 +				     rdst ? rdst->remote_ifindex : 0, tos,
++=======
+ 		rt = vxlan_get_route(vxlan, dev, sock4, skb, ifindex, tos,
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  				     dst->sin.sin_addr.s_addr,
 -				     &local_ip.sin.sin_addr.s_addr,
 -				     dst_port, src_port,
 +				     &src->sin.sin_addr.s_addr,
  				     dst_cache, info);
  		if (IS_ERR(rt)) {
 -			err = PTR_ERR(rt);
 +			netdev_dbg(dev, "no route to %pI4\n",
 +				   &dst->sin.sin_addr.s_addr);
 +			dev->stats.tx_carrier_errors++;
  			goto tx_error;
  		}
  
 +		if (rt->dst.dev == dev) {
 +			netdev_dbg(dev, "circular route to %pI4\n",
 +				   &dst->sin.sin_addr.s_addr);
 +			dev->stats.collisions++;
 +			goto rt_tx_error;
 +		}
 +
  		/* Bypass encapsulation if the destination is local */
++<<<<<<< HEAD
 +		if (!info && rt->rt_flags & RTCF_LOCAL &&
 +		    !(rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
 +			struct vxlan_dev *dst_vxlan;
 +
 +			ip_rt_put(rt);
 +			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
 +						   dst->sa.sa_family, dst_port,
 +						   vxlan->flags);
 +			if (!dst_vxlan)
 +				goto tx_error;
 +			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
 +			return;
++=======
+ 		if (!info) {
+ 			err = encap_bypass_if_local(skb, dev, vxlan, dst,
+ 						    dst_port, ifindex, vni,
+ 						    &rt->dst, rt->rt_flags);
+ 			if (err)
+ 				goto out_unlock;
+ 		} else if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT) {
+ 			df = htons(IP_DF);
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  		}
  
 -		ndst = &rt->dst;
 +		if (!info)
 +			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM_TX);
 +		else if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT)
 +			df = htons(IP_DF);
 +
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
 -		err = vxlan_build_skb(skb, ndst, sizeof(struct iphdr),
 +		err = vxlan_build_skb(skb, &rt->dst, sizeof(struct iphdr),
  				      vni, md, flags, udp_sum);
  		if (err < 0)
 -			goto tx_error;
 +			goto xmit_tx_error;
  
 -		udp_tunnel_xmit_skb(rt, sock4->sock->sk, skb, local_ip.sin.sin_addr.s_addr,
 +		udp_tunnel_xmit_skb(rt, sk, skb, src->sin.sin_addr.s_addr,
  				    dst->sin.sin_addr.s_addr, tos, ttl, df,
  				    src_port, dst_port, xnet, !udp_sum);
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
 -		struct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);
 +		struct dst_entry *ndst;
 +		u32 rt6i_flags;
  
++<<<<<<< HEAD
 +		if (!vxlan->vn6_sock)
 +			goto drop;
 +		sk = vxlan->vn6_sock->sock->sk;
 +
 +		ndst = vxlan6_get_route(vxlan, skb,
 +					rdst ? rdst->remote_ifindex : 0, tos,
++=======
+ 		ndst = vxlan6_get_route(vxlan, dev, sock6, skb, ifindex, tos,
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  					label, &dst->sin6.sin6_addr,
 -					&local_ip.sin6.sin6_addr,
 -					dst_port, src_port,
 +					&src->sin6.sin6_addr,
  					dst_cache, info);
  		if (IS_ERR(ndst)) {
 -			err = PTR_ERR(ndst);
 -			ndst = NULL;
 +			netdev_dbg(dev, "no route to %pI6\n",
 +				   &dst->sin6.sin6_addr);
 +			dev->stats.tx_carrier_errors++;
  			goto tx_error;
  		}
  
++<<<<<<< HEAD
 +		if (ndst->dev == dev) {
 +			netdev_dbg(dev, "circular route to %pI6\n",
 +				   &dst->sin6.sin6_addr);
 +			dst_release(ndst);
 +			dev->stats.collisions++;
 +			goto tx_error;
++=======
+ 		if (!info) {
+ 			u32 rt6i_flags = ((struct rt6_info *)ndst)->rt6i_flags;
+ 
+ 			err = encap_bypass_if_local(skb, dev, vxlan, dst,
+ 						    dst_port, ifindex, vni,
+ 						    ndst, rt6i_flags);
+ 			if (err)
+ 				goto out_unlock;
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  		}
  
 +		/* Bypass encapsulation if the destination is local */
 +		rt6i_flags = ((struct rt6_info *)ndst)->rt6i_flags;
 +		if (!info && rt6i_flags & RTF_LOCAL &&
 +		    !(rt6i_flags & (RTCF_BROADCAST | RTCF_MULTICAST))) {
 +			struct vxlan_dev *dst_vxlan;
 +
 +			dst_release(ndst);
 +			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
 +						   dst->sa.sa_family, dst_port,
 +						   vxlan->flags);
 +			if (!dst_vxlan)
 +				goto tx_error;
 +			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
 +			return;
 +		}
 +
 +		if (!info)
 +			udp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);
 +
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
  		skb_scrub_packet(skb, xnet);
@@@ -2804,16 -2914,136 +2909,70 @@@ static int vxlan_dev_configure(struct n
  		 */
  		if ((conf->flags & ~VXLAN_F_ALLOWED_GPE) ||
  		    !(conf->flags & VXLAN_F_COLLECT_METADATA)) {
 +			pr_info("unsupported combination of extensions\n");
  			return -EINVAL;
  		}
 -	}
 -
 -	if (!conf->remote_ip.sa.sa_family && !conf->saddr.sa.sa_family) {
 -		/* Unless IPv6 is explicitly requested, assume IPv4 */
 -		conf->remote_ip.sa.sa_family = AF_INET;
 -		conf->saddr.sa.sa_family = AF_INET;
 -	} else if (!conf->remote_ip.sa.sa_family) {
 -		conf->remote_ip.sa.sa_family = conf->saddr.sa.sa_family;
 -	} else if (!conf->saddr.sa.sa_family) {
 -		conf->saddr.sa.sa_family = conf->remote_ip.sa.sa_family;
 -	}
 -
 -	if (conf->saddr.sa.sa_family != conf->remote_ip.sa.sa_family)
 -		return -EINVAL;
 -
 -	if (vxlan_addr_multicast(&conf->saddr))
 -		return -EINVAL;
 -
 -	if (conf->saddr.sa.sa_family == AF_INET6) {
 -		if (!IS_ENABLED(CONFIG_IPV6))
 -			return -EPFNOSUPPORT;
 -		use_ipv6 = true;
 -		conf->flags |= VXLAN_F_IPV6;
 -
 -		if (!(conf->flags & VXLAN_F_COLLECT_METADATA)) {
 -			int local_type =
 -				ipv6_addr_type(&conf->saddr.sin6.sin6_addr);
 -			int remote_type =
 -				ipv6_addr_type(&conf->remote_ip.sin6.sin6_addr);
 -
 -			if (local_type & IPV6_ADDR_LINKLOCAL) {
 -				if (!(remote_type & IPV6_ADDR_LINKLOCAL) &&
 -				    (remote_type != IPV6_ADDR_ANY))
 -					return -EINVAL;
 -
 -				conf->flags |= VXLAN_F_IPV6_LINKLOCAL;
 -			} else {
 -				if (remote_type ==
 -				    (IPV6_ADDR_UNICAST | IPV6_ADDR_LINKLOCAL))
 -					return -EINVAL;
 -
 -				conf->flags &= ~VXLAN_F_IPV6_LINKLOCAL;
 -			}
 -		}
 -	}
 -
 -	if (conf->label && !use_ipv6)
 -		return -EINVAL;
 -
 -	if (conf->remote_ifindex) {
 -		struct net_device *lowerdev;
  
 -		lowerdev = __dev_get_by_index(src_net, conf->remote_ifindex);
 -		if (!lowerdev)
 -			return -ENODEV;
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -		if (use_ipv6) {
 -			struct inet6_dev *idev = __in6_dev_get(lowerdev);
 -			if (idev && idev->cnf.disable_ipv6)
 -				return -EPERM;
 -		}
 -#endif
 -
 -		*lower = lowerdev;
 +		vxlan_raw_setup(dev);
  	} else {
 -		if (vxlan_addr_multicast(&conf->remote_ip))
 -			return -EINVAL;
 -
 -#if IS_ENABLED(CONFIG_IPV6)
 -		if (conf->flags & VXLAN_F_IPV6_LINKLOCAL)
 -			return -EINVAL;
 -#endif
 -
 -		*lower = NULL;
 +		vxlan_ether_setup(dev);
  	}
  
++<<<<<<< HEAD
 +	vxlan->net = src_net;
++=======
+ 	if (!conf->dst_port) {
+ 		if (conf->flags & VXLAN_F_GPE)
+ 			conf->dst_port = htons(4790); /* IANA VXLAN-GPE port */
+ 		else
+ 			conf->dst_port = htons(vxlan_port);
+ 	}
+ 
+ 	if (!conf->age_interval)
+ 		conf->age_interval = FDB_AGE_DEFAULT;
+ 
+ 	list_for_each_entry(tmp, &vn->vxlan_list, next) {
+ 		if (tmp == old)
+ 			continue;
+ 
+ 		if (tmp->cfg.vni != conf->vni)
+ 			continue;
+ 		if (tmp->cfg.dst_port != conf->dst_port)
+ 			continue;
+ 		if ((tmp->cfg.flags & (VXLAN_F_RCV_FLAGS | VXLAN_F_IPV6)) !=
+ 		    (conf->flags & (VXLAN_F_RCV_FLAGS | VXLAN_F_IPV6)))
+ 			continue;
+ 
+ 		if ((conf->flags & VXLAN_F_IPV6_LINKLOCAL) &&
+ 		    tmp->cfg.remote_ifindex != conf->remote_ifindex)
+ 			continue;
+ 
+ 		return -EEXIST;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vxlan_config_apply(struct net_device *dev,
+ 			       struct vxlan_config *conf,
+ 			       struct net_device *lowerdev, bool changelink)
+ {
+ 	struct vxlan_dev *vxlan = netdev_priv(dev);
+ 	struct vxlan_rdst *dst = &vxlan->default_dst;
+ 	unsigned short needed_headroom = ETH_HLEN;
+ 	bool use_ipv6 = !!(conf->flags & VXLAN_F_IPV6);
+ 	int max_mtu = ETH_MAX_MTU;
+ 
+ 	if (!changelink) {
+ 		if (conf->flags & VXLAN_F_GPE)
+ 			vxlan_raw_setup(dev);
+ 		else
+ 			vxlan_ether_setup(dev);
+ 
+ 		if (conf->mtu)
+ 			dev->mtu = conf->mtu;
+ 	}
++>>>>>>> 49f810f00fa3 (vxlan: allow multiple VXLANs with same VNI for IPv6 link-local addresses)
  
  	dst->remote_vni = conf->vni;
  
* Unmerged path drivers/net/vxlan.c
