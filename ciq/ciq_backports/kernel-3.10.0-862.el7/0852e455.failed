net_sched: unify the init logic for act_police

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 0852e455238f8550fa92b1e40355eb2c6805787e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0852e455.failed

Jamal reported a crash when we create a police action
with a specific index, this is because the init logic
is not correct, we should always create one for this
case. Just unify the logic with other tc actions.

Fixes: a03e6fe56971 ("act_police: fix a crash during removal")
	Reported-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0852e455238f8550fa92b1e40355eb2c6805787e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_police.c
diff --cc net/sched/act_police.c
index 8a7c279e7b2c,259352d978df..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -121,7 -124,8 +121,12 @@@ static int tcf_act_police_locate(struc
  	struct tc_police *parm;
  	struct tcf_police *police;
  	struct qdisc_rate_table *R_tab = NULL, *P_tab = NULL;
++<<<<<<< HEAD
 +	struct tcf_hashinfo *hinfo = a->ops->hinfo;
++=======
+ 	struct tc_action_net *tn = net_generic(net, police_net_id);
+ 	bool exists = false;
++>>>>>>> 0852e455238f (net_sched: unify the init logic for act_police)
  	int size;
  
  	if (nla == NULL)
@@@ -136,32 -140,25 +141,52 @@@
  	size = nla_len(tb[TCA_POLICE_TBF]);
  	if (size != sizeof(*parm) && size != sizeof(struct tc_police_compat))
  		return -EINVAL;
- 	parm = nla_data(tb[TCA_POLICE_TBF]);
  
++<<<<<<< HEAD
 +	if (parm->index) {
 +		if (tcf_hash_search(a, parm->index)) {
 +			police = to_police(a->priv);
 +			if (bind) {
 +				police->tcf_bindcnt += 1;
 +				police->tcf_refcnt += 1;
 +				return 0;
 +			}
 +			if (ovr)
 +				goto override;
 +			/* not replacing */
 +			return -EEXIST;
 +		}
 +	}
 +
 +	police = kzalloc(sizeof(*police), GFP_KERNEL);
 +	if (police == NULL)
 +		return -ENOMEM;
 +	ret = ACT_P_CREATED;
 +	police->tcf_refcnt = 1;
 +	spin_lock_init(&police->tcf_lock);
 +	if (bind)
 +		police->tcf_bindcnt = 1;
 +override:
++=======
+ 	parm = nla_data(tb[TCA_POLICE_TBF]);
+ 	exists = tcf_hash_check(tn, parm->index, a, bind);
+ 	if (exists && bind)
+ 		return 0;
+ 
+ 	if (!exists) {
+ 		ret = tcf_hash_create(tn, parm->index, NULL, a,
+ 				      &act_police_ops, bind, false);
+ 		if (ret)
+ 			return ret;
+ 		ret = ACT_P_CREATED;
+ 	} else {
+ 		tcf_hash_release(*a, bind);
+ 		if (!ovr)
+ 			return -EEXIST;
+ 	}
+ 
+ 	police = to_police(*a);
++>>>>>>> 0852e455238f (net_sched: unify the init logic for act_police)
  	if (parm->rate.rate) {
  		err = -ENOMEM;
  		R_tab = qdisc_get_rtab(&parm->rate, tb[TCA_POLICE_RATE]);
* Unmerged path net/sched/act_police.c
