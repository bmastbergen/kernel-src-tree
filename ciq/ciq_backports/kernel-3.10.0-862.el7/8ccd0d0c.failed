of: add helper for getting endpoint node of specific identifiers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: of: add helper for getting endpoint node of specific identifiers (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 95.52%
commit-author Hyungwon Hwang <human.hwang@samsung.com>
commit 8ccd0d0ca04147e91890c373677f1e741dda2631
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8ccd0d0c.failed

When there are multiple ports or multiple endpoints in a port, they have to be
distinguished by the value of reg property. It is common. The drivers can get
the specific endpoint in the specific port via this function. Now the drivers
have to implement this code in themselves or have to force the order of dt nodes
to get the right node.

	Signed-off-by: Hyungwon Hwang <human.hwang@samsung.com>
	Acked-by: Rob Herring <robh+dt@kernel.org>
	Signed-off-by: Inki Dae <inki.dae@samsung.com>
(cherry picked from commit 8ccd0d0ca04147e91890c373677f1e741dda2631)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/base.c
#	include/linux/of_graph.h
diff --cc drivers/of/base.c
index b23e1a2e663d,f3b583b81105..000000000000
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@@ -1922,3 -2050,262 +1922,265 @@@ const char *of_prop_next_string(struct 
  	return curv;
  }
  EXPORT_SYMBOL_GPL(of_prop_next_string);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * of_console_check() - Test and setup console for DT setup
+  * @dn - Pointer to device node
+  * @name - Name to use for preferred console without index. ex. "ttyS"
+  * @index - Index to use for preferred console.
+  *
+  * Check if the given device node matches the stdout-path property in the
+  * /chosen node. If it does then register it as the preferred console and return
+  * TRUE. Otherwise return FALSE.
+  */
+ bool of_console_check(struct device_node *dn, char *name, int index)
+ {
+ 	if (!dn || dn != of_stdout || console_set_on_cmdline)
+ 		return false;
+ 	return !add_preferred_console(name, index,
+ 				      kstrdup(of_stdout_options, GFP_KERNEL));
+ }
+ EXPORT_SYMBOL_GPL(of_console_check);
+ 
+ /**
+  *	of_find_next_cache_node - Find a node's subsidiary cache
+  *	@np:	node of type "cpu" or "cache"
+  *
+  *	Returns a node pointer with refcount incremented, use
+  *	of_node_put() on it when done.  Caller should hold a reference
+  *	to np.
+  */
+ struct device_node *of_find_next_cache_node(const struct device_node *np)
+ {
+ 	struct device_node *child;
+ 	const phandle *handle;
+ 
+ 	handle = of_get_property(np, "l2-cache", NULL);
+ 	if (!handle)
+ 		handle = of_get_property(np, "next-level-cache", NULL);
+ 
+ 	if (handle)
+ 		return of_find_node_by_phandle(be32_to_cpup(handle));
+ 
+ 	/* OF on pmac has nodes instead of properties named "l2-cache"
+ 	 * beneath CPU nodes.
+ 	 */
+ 	if (!strcmp(np->type, "cpu"))
+ 		for_each_child_of_node(np, child)
+ 			if (!strcmp(child->type, "cache"))
+ 				return child;
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * of_graph_parse_endpoint() - parse common endpoint node properties
+  * @node: pointer to endpoint device_node
+  * @endpoint: pointer to the OF endpoint data structure
+  *
+  * The caller should hold a reference to @node.
+  */
+ int of_graph_parse_endpoint(const struct device_node *node,
+ 			    struct of_endpoint *endpoint)
+ {
+ 	struct device_node *port_node = of_get_parent(node);
+ 
+ 	WARN_ONCE(!port_node, "%s(): endpoint %s has no parent node\n",
+ 		  __func__, node->full_name);
+ 
+ 	memset(endpoint, 0, sizeof(*endpoint));
+ 
+ 	endpoint->local_node = node;
+ 	/*
+ 	 * It doesn't matter whether the two calls below succeed.
+ 	 * If they don't then the default value 0 is used.
+ 	 */
+ 	of_property_read_u32(port_node, "reg", &endpoint->port);
+ 	of_property_read_u32(node, "reg", &endpoint->id);
+ 
+ 	of_node_put(port_node);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(of_graph_parse_endpoint);
+ 
+ /**
+  * of_graph_get_port_by_id() - get the port matching a given id
+  * @parent: pointer to the parent device node
+  * @id: id of the port
+  *
+  * Return: A 'port' node pointer with refcount incremented. The caller
+  * has to use of_node_put() on it when done.
+  */
+ struct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)
+ {
+ 	struct device_node *node, *port;
+ 
+ 	node = of_get_child_by_name(parent, "ports");
+ 	if (node)
+ 		parent = node;
+ 
+ 	for_each_child_of_node(parent, port) {
+ 		u32 port_id = 0;
+ 
+ 		if (of_node_cmp(port->name, "port") != 0)
+ 			continue;
+ 		of_property_read_u32(port, "reg", &port_id);
+ 		if (id == port_id)
+ 			break;
+ 	}
+ 
+ 	of_node_put(node);
+ 
+ 	return port;
+ }
+ EXPORT_SYMBOL(of_graph_get_port_by_id);
+ 
+ /**
+  * of_graph_get_next_endpoint() - get next endpoint node
+  * @parent: pointer to the parent device node
+  * @prev: previous endpoint node, or NULL to get first
+  *
+  * Return: An 'endpoint' node pointer with refcount incremented. Refcount
+  * of the passed @prev node is decremented.
+  */
+ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
+ 					struct device_node *prev)
+ {
+ 	struct device_node *endpoint;
+ 	struct device_node *port;
+ 
+ 	if (!parent)
+ 		return NULL;
+ 
+ 	/*
+ 	 * Start by locating the port node. If no previous endpoint is specified
+ 	 * search for the first port node, otherwise get the previous endpoint
+ 	 * parent port node.
+ 	 */
+ 	if (!prev) {
+ 		struct device_node *node;
+ 
+ 		node = of_get_child_by_name(parent, "ports");
+ 		if (node)
+ 			parent = node;
+ 
+ 		port = of_get_child_by_name(parent, "port");
+ 		of_node_put(node);
+ 
+ 		if (!port) {
+ 			pr_err("%s(): no port node found in %s\n",
+ 			       __func__, parent->full_name);
+ 			return NULL;
+ 		}
+ 	} else {
+ 		port = of_get_parent(prev);
+ 		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
+ 			      __func__, prev->full_name))
+ 			return NULL;
+ 	}
+ 
+ 	while (1) {
+ 		/*
+ 		 * Now that we have a port node, get the next endpoint by
+ 		 * getting the next child. If the previous endpoint is NULL this
+ 		 * will return the first child.
+ 		 */
+ 		endpoint = of_get_next_child(port, prev);
+ 		if (endpoint) {
+ 			of_node_put(port);
+ 			return endpoint;
+ 		}
+ 
+ 		/* No more endpoints under this port, try the next one. */
+ 		prev = NULL;
+ 
+ 		do {
+ 			port = of_get_next_child(parent, port);
+ 			if (!port)
+ 				return NULL;
+ 		} while (of_node_cmp(port->name, "port"));
+ 	}
+ }
+ EXPORT_SYMBOL(of_graph_get_next_endpoint);
+ 
+ /**
+  * of_graph_get_endpoint_by_regs() - get endpoint node of specific identifiers
+  * @parent: pointer to the parent device node
+  * @port_reg: identifier (value of reg property) of the parent port node
+  * @reg: identifier (value of reg property) of the endpoint node
+  *
+  * Return: An 'endpoint' node pointer which is identified by reg and at the same
+  * is the child of a port node identified by port_reg. reg and port_reg are
+  * ignored when they are -1.
+  */
+ struct device_node *of_graph_get_endpoint_by_regs(
+ 	const struct device_node *parent, int port_reg, int reg)
+ {
+ 	struct of_endpoint endpoint;
+ 	struct device_node *node, *prev_node = NULL;
+ 
+ 	while (1) {
+ 		node = of_graph_get_next_endpoint(parent, prev_node);
+ 		of_node_put(prev_node);
+ 		if (!node)
+ 			break;
+ 
+ 		of_graph_parse_endpoint(node, &endpoint);
+ 		if (((port_reg == -1) || (endpoint.port == port_reg)) &&
+ 			((reg == -1) || (endpoint.id == reg)))
+ 			return node;
+ 
+ 		prev_node = node;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * of_graph_get_remote_port_parent() - get remote port's parent node
+  * @node: pointer to a local endpoint device_node
+  *
+  * Return: Remote device node associated with remote endpoint node linked
+  *	   to @node. Use of_node_put() on it when done.
+  */
+ struct device_node *of_graph_get_remote_port_parent(
+ 			       const struct device_node *node)
+ {
+ 	struct device_node *np;
+ 	unsigned int depth;
+ 
+ 	/* Get remote endpoint node. */
+ 	np = of_parse_phandle(node, "remote-endpoint", 0);
+ 
+ 	/* Walk 3 levels up only if there is 'ports' node. */
+ 	for (depth = 3; depth && np; depth--) {
+ 		np = of_get_next_parent(np);
+ 		if (depth == 2 && of_node_cmp(np->name, "ports"))
+ 			break;
+ 	}
+ 	return np;
+ }
+ EXPORT_SYMBOL(of_graph_get_remote_port_parent);
+ 
+ /**
+  * of_graph_get_remote_port() - get remote port node
+  * @node: pointer to a local endpoint device_node
+  *
+  * Return: Remote port node associated with remote endpoint node linked
+  *	   to @node. Use of_node_put() on it when done.
+  */
+ struct device_node *of_graph_get_remote_port(const struct device_node *node)
+ {
+ 	struct device_node *np;
+ 
+ 	/* Get remote endpoint node. */
+ 	np = of_parse_phandle(node, "remote-endpoint", 0);
+ 	if (!np)
+ 		return NULL;
+ 	return of_get_next_parent(np);
+ }
+ EXPORT_SYMBOL(of_graph_get_remote_port);
++>>>>>>> 8ccd0d0ca041 (of: add helper for getting endpoint node of specific identifiers)
* Unmerged path include/linux/of_graph.h
* Unmerged path drivers/of/base.c
* Unmerged path include/linux/of_graph.h
