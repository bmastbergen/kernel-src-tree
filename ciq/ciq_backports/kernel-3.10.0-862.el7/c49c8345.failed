scsi_dh_alua: allocate RTPG buffer separately

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit c49c83458f73d9fff7f441fb73268af3d15cfe52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c49c8345.failed

The RTPG buffer will only evaluated within alua_rtpg(),
so we can allocate it locally there and avoid having to
put it into the global structure.

	Reviewed-by: Ewan Milne <emilne@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c49c83458f73d9fff7f441fb73268af3d15cfe52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,af5acc133f72..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -86,26 -82,6 +83,29 @@@ struct alua_dh_data 
  
  static char print_alua_state(int);
  
++<<<<<<< HEAD
 +static inline struct alua_dh_data *get_alua_data(struct scsi_device *sdev)
 +{
 +	return container_of(sdev->scsi_dh_data, struct alua_dh_data, dh_data);
 +}
 +
 +static int realloc_buffer(struct alua_dh_data *h, unsigned len)
 +{
 +	if (h->buff && h->buff != h->inq)
 +		kfree(h->buff);
 +
 +	h->buff = kmalloc(len, GFP_NOIO);
 +	if (!h->buff) {
 +		h->buff = h->inq;
 +		h->bufflen = ALUA_INQUIRY_SIZE;
 +		return 1;
 +	}
 +	h->bufflen = len;
 +	return 0;
 +}
 +
++=======
++>>>>>>> c49c83458f73 (scsi_dh_alua: allocate RTPG buffer separately)
  /*
   * submit_rtpg - Issue a REPORT TARGET GROUP STATES command
   * @sdev: sdev the command should be sent to
@@@ -658,13 -645,46 +669,50 @@@ static int alua_prep_fn(struct scsi_dev
  
  }
  
 -/*
 - * alua_bus_attach - Attach device handler
 - * @sdev: device to be attached to
 - */
 -static int alua_bus_attach(struct scsi_device *sdev)
 +static bool alua_match(struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	return (scsi_device_tpgs(sdev) != 0);
 +}
 +
 +static int alua_bus_attach(struct scsi_device *sdev);
 +static void alua_bus_detach(struct scsi_device *sdev);
++=======
+ 	struct alua_dh_data *h;
+ 	int err;
+ 
+ 	h = kzalloc(sizeof(*h) , GFP_KERNEL);
+ 	if (!h)
+ 		return -ENOMEM;
+ 	h->tpgs = TPGS_MODE_UNINITIALIZED;
+ 	h->state = TPGS_STATE_OPTIMIZED;
+ 	h->group_id = -1;
+ 	h->rel_port = -1;
+ 	h->sdev = sdev;
+ 
+ 	err = alua_initialize(sdev, h);
+ 	if (err != SCSI_DH_OK && err != SCSI_DH_DEV_OFFLINED)
+ 		goto failed;
+ 
+ 	sdev->handler_data = h;
+ 	return 0;
+ failed:
+ 	kfree(h);
+ 	return -EINVAL;
+ }
+ 
+ /*
+  * alua_bus_detach - Detach device handler
+  * @sdev: device to be detached from
+  */
+ static void alua_bus_detach(struct scsi_device *sdev)
+ {
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 
+ 	sdev->handler_data = NULL;
+ 	kfree(h);
+ }
++>>>>>>> c49c83458f73 (scsi_dh_alua: allocate RTPG buffer separately)
  
  static struct scsi_device_handler alua_dh = {
  	.name = ALUA_DH_NAME,
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
