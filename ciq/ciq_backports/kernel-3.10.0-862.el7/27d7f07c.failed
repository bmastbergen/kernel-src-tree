net_sched: get rid of more forward declarations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 27d7f07c49de289e2a2d48a6bec3e111ed4b1222
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/27d7f07c.failed

This is not needed if we move them up properly.

	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 27d7f07c49de289e2a2d48a6bec3e111ed4b1222)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_api.c
diff --cc net/sched/sch_api.c
index 0fd3de4f5fdb,330ffaea9974..000000000000
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@@ -1340,109 -1440,10 +1438,112 @@@ graft
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,
 +			 u32 portid, u32 seq, u16 flags, int event)
 +{
 +	struct gnet_stats_basic_cpu __percpu *cpu_bstats = NULL;
 +	struct gnet_stats_queue __percpu *cpu_qstats = NULL;
 +	struct tcmsg *tcm;
 +	struct nlmsghdr  *nlh;
 +	unsigned char *b = skb_tail_pointer(skb);
 +	struct gnet_dump d;
 +	struct qdisc_size_table *stab;
 +	__u32 qlen;
 +
 +	cond_resched();
 +	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);
 +	if (!nlh)
 +		goto out_nlmsg_trim;
 +	tcm = nlmsg_data(nlh);
 +	tcm->tcm_family = AF_UNSPEC;
 +	tcm->tcm__pad1 = 0;
 +	tcm->tcm__pad2 = 0;
 +	tcm->tcm_ifindex = qdisc_dev(q)->ifindex;
 +	tcm->tcm_parent = clid;
 +	tcm->tcm_handle = q->handle;
 +	tcm->tcm_info = atomic_read(&q->refcnt);
 +	if (nla_put_string(skb, TCA_KIND, q->ops->id))
 +		goto nla_put_failure;
 +	if (q->ops->dump && q->ops->dump(q, skb) < 0)
 +		goto nla_put_failure;
 +	qlen = q->q.qlen;
 +
 +	stab = rtnl_dereference(q->stab);
 +	if (stab && qdisc_dump_stab(skb, stab) < 0)
 +		goto nla_put_failure;
 +
 +	if (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,
 +					 NULL, &d, TCA_PAD) < 0)
 +		goto nla_put_failure;
 +
 +	if (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)
 +		goto nla_put_failure;
 +
 +	if (qdisc_is_percpu_stats(q)) {
 +		cpu_bstats = q->cpu_bstats;
 +		cpu_qstats = q->cpu_qstats;
 +	}
 +
 +	if (gnet_stats_copy_basic(qdisc_root_sleeping_running(q),
 +				  &d, cpu_bstats, &q->bstats) < 0 ||
 +	    gnet_stats_copy_rate_est(&d, &q->bstats, &q->rate_est) < 0 ||
 +	    gnet_stats_copy_queue(&d, cpu_qstats, &q->qstats, qlen) < 0)
 +		goto nla_put_failure;
 +
 +	if (gnet_stats_finish_copy(&d) < 0)
 +		goto nla_put_failure;
 +
 +	nlh->nlmsg_len = skb_tail_pointer(skb) - b;
 +	return skb->len;
 +
 +out_nlmsg_trim:
 +nla_put_failure:
 +	nlmsg_trim(skb, b);
 +	return -1;
 +}
 +
 +static bool tc_qdisc_dump_ignore(struct Qdisc *q)
 +{
 +	return (q->flags & TCQ_F_BUILTIN) ? true : false;
 +}
 +
 +static int qdisc_notify(struct net *net, struct sk_buff *oskb,
 +			struct nlmsghdr *n, u32 clid,
 +			struct Qdisc *old, struct Qdisc *new)
 +{
 +	struct sk_buff *skb;
 +	u32 portid = oskb ? NETLINK_CB(oskb).portid : 0;
 +
 +	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
 +	if (!skb)
 +		return -ENOBUFS;
 +
 +	if (old && !tc_qdisc_dump_ignore(old)) {
 +		if (tc_fill_qdisc(skb, old, clid, portid, n->nlmsg_seq,
 +				  0, RTM_DELQDISC) < 0)
 +			goto err_out;
 +	}
 +	if (new && !tc_qdisc_dump_ignore(new)) {
 +		if (tc_fill_qdisc(skb, new, clid, portid, n->nlmsg_seq,
 +				  old ? NLM_F_REPLACE : 0, RTM_NEWQDISC) < 0)
 +			goto err_out;
 +	}
 +
 +	if (skb->len)
 +		return rtnetlink_send(skb, net, portid, RTNLGRP_TC,
 +				      n->nlmsg_flags & NLM_F_ECHO);
 +
 +err_out:
 +	kfree_skb(skb);
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> 27d7f07c49de (net_sched: get rid of more forward declarations)
  static int tc_dump_qdisc_root(struct Qdisc *root, struct sk_buff *skb,
  			      struct netlink_callback *cb,
 -			      int *q_idx_p, int s_q_idx, bool recur,
 -			      bool dump_invisible)
 +			      int *q_idx_p, int s_q_idx)
  {
  	int ret = 0, q_idx = *q_idx_p;
  	struct Qdisc *q;
@@@ -1529,9 -1552,74 +1630,73 @@@ done
   *	Traffic classes manipulation.		*
   ************************************************/
  
+ static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,
+ 			  unsigned long cl,
+ 			  u32 portid, u32 seq, u16 flags, int event)
+ {
+ 	struct tcmsg *tcm;
+ 	struct nlmsghdr  *nlh;
+ 	unsigned char *b = skb_tail_pointer(skb);
+ 	struct gnet_dump d;
+ 	const struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;
  
+ 	cond_resched();
+ 	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*tcm), flags);
+ 	if (!nlh)
+ 		goto out_nlmsg_trim;
+ 	tcm = nlmsg_data(nlh);
+ 	tcm->tcm_family = AF_UNSPEC;
+ 	tcm->tcm__pad1 = 0;
+ 	tcm->tcm__pad2 = 0;
+ 	tcm->tcm_ifindex = qdisc_dev(q)->ifindex;
+ 	tcm->tcm_parent = q->handle;
+ 	tcm->tcm_handle = q->handle;
+ 	tcm->tcm_info = 0;
+ 	if (nla_put_string(skb, TCA_KIND, q->ops->id))
+ 		goto nla_put_failure;
+ 	if (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)
+ 		goto nla_put_failure;
+ 
+ 	if (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,
+ 					 NULL, &d, TCA_PAD) < 0)
+ 		goto nla_put_failure;
+ 
+ 	if (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)
+ 		goto nla_put_failure;
+ 
+ 	if (gnet_stats_finish_copy(&d) < 0)
+ 		goto nla_put_failure;
+ 
+ 	nlh->nlmsg_len = skb_tail_pointer(skb) - b;
+ 	return skb->len;
+ 
+ out_nlmsg_trim:
+ nla_put_failure:
+ 	nlmsg_trim(skb, b);
+ 	return -1;
+ }
+ 
+ static int tclass_notify(struct net *net, struct sk_buff *oskb,
+ 			 struct nlmsghdr *n, struct Qdisc *q,
+ 			 unsigned long cl, int event)
+ {
+ 	struct sk_buff *skb;
+ 	u32 portid = oskb ? NETLINK_CB(oskb).portid : 0;
+ 
+ 	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
+ 	if (!skb)
+ 		return -ENOBUFS;
+ 
+ 	if (tc_fill_tclass(skb, q, cl, portid, n->nlmsg_seq, 0, event) < 0) {
+ 		kfree_skb(skb);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return rtnetlink_send(skb, net, portid, RTNLGRP_TC,
+ 			      n->nlmsg_flags & NLM_F_ECHO);
+ }
  
 -static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n,
 -			 struct netlink_ext_ack *extack)
 +static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n)
  {
  	struct net *net = sock_net(skb->sk);
  	struct tcmsg *tcm = nlmsg_data(n);
* Unmerged path net/sched/sch_api.c
