netvsc: Initialize all channel related state prior to opening the channel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit bffb184247bcc783a40a0e123a9a2de3c5b28157
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bffb1842.failed

Prior to opening the channel we should have all the state setup to handle
interrupts. The current code does not do that; fix the bug. This bug
can result in faults in the interrupt path.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bffb184247bcc783a40a0e123a9a2de3c5b28157)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/netvsc.c
index 2b58ee2d05a8,7ab06b338a14..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -1347,8 -1284,26 +1347,23 @@@ int netvsc_device_add(struct hv_device 
  
  	net_device->ring_size = ring_size;
  
 -	/* Because the device uses NAPI, all the interrupt batching and
 -	 * control is done via Net softirq, not the channel handling
 -	 */
 -	set_channel_read_mode(device->channel, HV_CALL_ISR);
 +	set_per_channel_state(device->channel, net_device->cb_buffer);
  
+ 	/* If we're reopening the device we may have multiple queues, fill the
+ 	 * chn_table with the default channel to use it before subchannels are
+ 	 * opened.
+ 	 * Initialize the channel state before we open;
+ 	 * we can be interrupted as soon as we open the channel.
+ 	 */
+ 
+ 	for (i = 0; i < VRSS_CHANNEL_MAX; i++) {
+ 		struct netvsc_channel *nvchan = &net_device->chan_table[i];
+ 
+ 		nvchan->channel = device->channel;
+ 		netif_napi_add(ndev, &nvchan->napi,
+ 			       netvsc_poll, NAPI_POLL_WEIGHT);
+ 	}
+ 
  	/* Open the channel */
  	ret = vmbus_open(device->channel, ring_size * PAGE_SIZE,
  			 ring_size * PAGE_SIZE, NULL, 0,
@@@ -1362,12 -1318,8 +1377,17 @@@
  	/* Channel is opened */
  	netdev_dbg(ndev, "hv_netvsc channel opened successfully\n");
  
++<<<<<<< HEAD
 +	/* If we're reopening the device we may have multiple queues, fill the
 +	 * chn_table with the default channel to use it before subchannels are
 +	 * opened.
 +	 */
 +	for (i = 0; i < VRSS_CHANNEL_MAX; i++)
 +		net_device->chn_table[i] = device->channel;
++=======
+ 	/* Enable NAPI handler for init callbacks */
+ 	napi_enable(&net_device->chan_table[0].napi);
++>>>>>>> bffb184247bc (netvsc: Initialize all channel related state prior to opening the channel)
  
  	/* Writing nvdev pointer unlocks netvsc_send(), make sure chn_table is
  	 * populated.
diff --cc drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92,1e9445bc4539..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -925,17 -1007,17 +925,23 @@@ static void netvsc_sc_open(struct vmbus
  	 */
  	set_channel_read_mode(new_sc, HV_CALL_ISR);
  
+ 	/* Set the channel before opening.*/
+ 	nvchan->channel = new_sc;
+ 
  	ret = vmbus_open(new_sc, nvscdev->ring_size * PAGE_SIZE,
  			 nvscdev->ring_size * PAGE_SIZE, NULL, 0,
 -			 netvsc_channel_cb, nvchan);
 +			 netvsc_channel_cb, new_sc);
  
 -
 -	napi_enable(&nvchan->napi);
 -
 -	if (refcount_dec_and_test(&nvscdev->sc_offered))
++<<<<<<< HEAD
 +	if (ret == 0)
 +		nvscdev->chn_table[chn_index] = new_sc;
++=======
++>>>>>>> bffb184247bc (netvsc: Initialize all channel related state prior to opening the channel)
 +
 +	spin_lock_irqsave(&nvscdev->sc_lock, flags);
 +	nvscdev->num_sc_offered--;
 +	spin_unlock_irqrestore(&nvscdev->sc_lock, flags);
 +	if (nvscdev->num_sc_offered == 0)
  		complete(&nvscdev->channel_init_wait);
  }
  
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
