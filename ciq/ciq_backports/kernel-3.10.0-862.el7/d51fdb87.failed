NFS: discard nfs_lockowner structure.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [fs] nfs: discard nfs_lockowner structure (Benjamin Coddington) [1476826]
Rebuild_FUZZ: 98.63%
commit-author NeilBrown <neilb@suse.com>
commit d51fdb87a611f8ef50518df7187173ae10469fd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d51fdb87.failed

It now has only one field and is only used in one structure.
So replaced it in that structure by the field it contains.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit d51fdb87a611f8ef50518df7187173ae10469fd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/inode.c
#	fs/nfs/nfs4state.c
#	fs/nfs/pagelist.c
#	fs/nfs/write.c
#	include/linux/nfs_fs.h
diff --cc fs/nfs/inode.c
index b119f0855a0c,d79e0bac836e..000000000000
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@@ -717,8 -702,7 +717,12 @@@ EXPORT_SYMBOL_GPL(nfs_getattr)
  static void nfs_init_lock_context(struct nfs_lock_context *l_ctx)
  {
  	atomic_set(&l_ctx->count, 1);
++<<<<<<< HEAD
 +	l_ctx->lockowner.l_owner = current->files;
 +	l_ctx->lockowner.l_pid = current->tgid;
++=======
+ 	l_ctx->lockowner = current->files;
++>>>>>>> d51fdb87a611 (NFS: discard nfs_lockowner structure.)
  	INIT_LIST_HEAD(&l_ctx->list);
  	atomic_set(&l_ctx->io_count, 0);
  }
@@@ -729,10 -713,8 +733,10 @@@ static struct nfs_lock_context *__nfs_f
  	struct nfs_lock_context *pos = head;
  
  	do {
- 		if (pos->lockowner.l_owner != current->files)
+ 		if (pos->lockowner != current->files)
  			continue;
 +		if (pos->lockowner.l_pid != current->tgid)
 +			continue;
  		atomic_inc(&pos->count);
  		return pos;
  	} while ((pos = list_entry(pos->list.next, typeof(*pos), list)) != head);
diff --cc fs/nfs/nfs4state.c
index 9ae72244a959,26b6b8b0cae3..000000000000
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@@ -949,9 -953,11 +949,15 @@@ static int nfs4_copy_lock_stateid(nfs4_
  	if (test_bit(LK_STATE_IN_USE, &state->flags) == 0)
  		goto out;
  
++<<<<<<< HEAD
 +	fl_owner = lockowner->l_owner;
++=======
+ 	fl_owner = l_ctx->lockowner;
+ 	fl_flock_owner = l_ctx->open_context->flock_owner;
+ 
++>>>>>>> d51fdb87a611 (NFS: discard nfs_lockowner structure.)
  	spin_lock(&state->state_lock);
 -	lsp = __nfs4_find_lock_state(state, fl_owner, fl_flock_owner);
 +	lsp = __nfs4_find_lock_state(state, fl_owner);
  	if (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))
  		ret = -EIO;
  	else if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {
diff --cc fs/nfs/pagelist.c
index 6d9352499b7b,6e629b856a00..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -899,8 -867,7 +899,12 @@@ static void nfs_pageio_cleanup_mirrorin
  static bool nfs_match_lock_context(const struct nfs_lock_context *l1,
  		const struct nfs_lock_context *l2)
  {
++<<<<<<< HEAD
 +	return l1->lockowner.l_owner == l2->lockowner.l_owner
 +		&& l1->lockowner.l_pid == l2->lockowner.l_pid;
++=======
+ 	return l1->lockowner == l2->lockowner;
++>>>>>>> d51fdb87a611 (NFS: discard nfs_lockowner structure.)
  }
  
  /**
diff --cc fs/nfs/write.c
index eaf2c888228d,6e761f3f4cbf..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -1159,9 -1148,10 +1159,16 @@@ int nfs_flush_incompatible(struct file 
  			!nfs_match_open_context(req->wb_context, ctx);
  		/* for now, flush if more than 1 request in page_group */
  		do_flush |= req->wb_this_page != req;
++<<<<<<< HEAD
 +		if (l_ctx && ctx->dentry->d_inode->i_flock != NULL) {
 +			do_flush |= l_ctx->lockowner.l_owner != current->files
 +				|| l_ctx->lockowner.l_pid != current->tgid;
++=======
+ 		if (l_ctx && flctx &&
+ 		    !(list_empty_careful(&flctx->flc_posix) &&
+ 		      list_empty_careful(&flctx->flc_flock))) {
+ 			do_flush |= l_ctx->lockowner != current->files;
++>>>>>>> d51fdb87a611 (NFS: discard nfs_lockowner structure.)
  		}
  		nfs_release_request(req);
  		if (!do_flush)
diff --cc include/linux/nfs_fs.h
index e7af49321e86,db1002abc95e..000000000000
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@@ -55,11 -55,6 +55,14 @@@ struct nfs_access_entry 
  	struct rcu_head		rcu_head;
  };
  
++<<<<<<< HEAD
 +struct nfs_lockowner {
 +	fl_owner_t l_owner;
 +	pid_t l_pid;
 +};
 +
++=======
++>>>>>>> d51fdb87a611 (NFS: discard nfs_lockowner structure.)
  struct nfs_lock_context {
  	atomic_t count;
  	struct list_head list;
* Unmerged path fs/nfs/inode.c
* Unmerged path fs/nfs/nfs4state.c
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/write.c
* Unmerged path include/linux/nfs_fs.h
