KVM: PPC: Book3S HV: HPT resizing documentation and reserved numbers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author David Gibson <david@gibson.dropbear.id.au>
commit ef1ead0c3b1dfb43d33caa4f50c8d214f86b6bc8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ef1ead0c.failed

This adds a new powerpc-specific KVM_CAP_SPAPR_RESIZE_HPT capability to
advertise whether KVM is capable of handling the PAPR extensions for
resizing the hashed page table during guest runtime.  It also adds
definitions for two new VM ioctl()s to implement this extension, and
documentation of the same.

Note that, HPT resizing is already possible with KVM PR without kernel
modification, since the HPT is managed within userspace (qemu).  The
capability defined here will only be set where an in-kernel implementation
of resizing is necessary, i.e. for KVM HV.  To determine if the userspace
resize implementation can be used, it's necessary to check
KVM_CAP_PPC_ALLOC_HTAB.  Unfortunately older kernels incorrectly set
KVM_CAP_PPC_ALLOC_HTAB even with KVM PR.  If userspace it want to support
resizing with KVM PR on such kernels, it will need a workaround.

	Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit ef1ead0c3b1dfb43d33caa4f50c8d214f86b6bc8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virtual/kvm/api.txt
#	include/uapi/linux/kvm.h
diff --cc Documentation/virtual/kvm/api.txt
index 9f3193affa20,64f217af0416..000000000000
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@@ -2684,6 -3145,222 +2684,225 @@@ an implementation for these despite th
  
  This capability is always enabled.
  
++<<<<<<< HEAD
++=======
+ 4.98 KVM_CREATE_SPAPR_TCE_64
+ 
+ Capability: KVM_CAP_SPAPR_TCE_64
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_create_spapr_tce_64 (in)
+ Returns: file descriptor for manipulating the created TCE table
+ 
+ This is an extension for KVM_CAP_SPAPR_TCE which only supports 32bit
+ windows, described in 4.62 KVM_CREATE_SPAPR_TCE
+ 
+ This capability uses extended struct in ioctl interface:
+ 
+ /* for KVM_CAP_SPAPR_TCE_64 */
+ struct kvm_create_spapr_tce_64 {
+ 	__u64 liobn;
+ 	__u32 page_shift;
+ 	__u32 flags;
+ 	__u64 offset;	/* in pages */
+ 	__u64 size; 	/* in pages */
+ };
+ 
+ The aim of extension is to support an additional bigger DMA window with
+ a variable page size.
+ KVM_CREATE_SPAPR_TCE_64 receives a 64bit window size, an IOMMU page shift and
+ a bus offset of the corresponding DMA window, @size and @offset are numbers
+ of IOMMU pages.
+ 
+ @flags are not used at the moment.
+ 
+ The rest of functionality is identical to KVM_CREATE_SPAPR_TCE.
+ 
+ 4.99 KVM_REINJECT_CONTROL
+ 
+ Capability: KVM_CAP_REINJECT_CONTROL
+ Architectures: x86
+ Type: vm ioctl
+ Parameters: struct kvm_reinject_control (in)
+ Returns: 0 on success,
+          -EFAULT if struct kvm_reinject_control cannot be read,
+          -ENXIO if KVM_CREATE_PIT or KVM_CREATE_PIT2 didn't succeed earlier.
+ 
+ i8254 (PIT) has two modes, reinject and !reinject.  The default is reinject,
+ where KVM queues elapsed i8254 ticks and monitors completion of interrupt from
+ vector(s) that i8254 injects.  Reinject mode dequeues a tick and injects its
+ interrupt whenever there isn't a pending interrupt from i8254.
+ !reinject mode injects an interrupt as soon as a tick arrives.
+ 
+ struct kvm_reinject_control {
+ 	__u8 pit_reinject;
+ 	__u8 reserved[31];
+ };
+ 
+ pit_reinject = 0 (!reinject mode) is recommended, unless running an old
+ operating system that uses the PIT for timing (e.g. Linux 2.4.x).
+ 
+ 4.100 KVM_PPC_CONFIGURE_V3_MMU
+ 
+ Capability: KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3
+ Architectures: ppc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_mmuv3_cfg (in)
+ Returns: 0 on success,
+          -EFAULT if struct kvm_ppc_mmuv3_cfg cannot be read,
+          -EINVAL if the configuration is invalid
+ 
+ This ioctl controls whether the guest will use radix or HPT (hashed
+ page table) translation, and sets the pointer to the process table for
+ the guest.
+ 
+ struct kvm_ppc_mmuv3_cfg {
+ 	__u64	flags;
+ 	__u64	process_table;
+ };
+ 
+ There are two bits that can be set in flags; KVM_PPC_MMUV3_RADIX and
+ KVM_PPC_MMUV3_GTSE.  KVM_PPC_MMUV3_RADIX, if set, configures the guest
+ to use radix tree translation, and if clear, to use HPT translation.
+ KVM_PPC_MMUV3_GTSE, if set and if KVM permits it, configures the guest
+ to be able to use the global TLB and SLB invalidation instructions;
+ if clear, the guest may not use these instructions.
+ 
+ The process_table field specifies the address and size of the guest
+ process table, which is in the guest's space.  This field is formatted
+ as the second doubleword of the partition table entry, as defined in
+ the Power ISA V3.00, Book III section 5.7.6.1.
+ 
+ 4.101 KVM_PPC_GET_RMMU_INFO
+ 
+ Capability: KVM_CAP_PPC_RADIX_MMU
+ Architectures: ppc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_rmmu_info (out)
+ Returns: 0 on success,
+ 	 -EFAULT if struct kvm_ppc_rmmu_info cannot be written,
+ 	 -EINVAL if no useful information can be returned
+ 
+ This ioctl returns a structure containing two things: (a) a list
+ containing supported radix tree geometries, and (b) a list that maps
+ page sizes to put in the "AP" (actual page size) field for the tlbie
+ (TLB invalidate entry) instruction.
+ 
+ struct kvm_ppc_rmmu_info {
+ 	struct kvm_ppc_radix_geom {
+ 		__u8	page_shift;
+ 		__u8	level_bits[4];
+ 		__u8	pad[3];
+ 	}	geometries[8];
+ 	__u32	ap_encodings[8];
+ };
+ 
+ The geometries[] field gives up to 8 supported geometries for the
+ radix page table, in terms of the log base 2 of the smallest page
+ size, and the number of bits indexed at each level of the tree, from
+ the PTE level up to the PGD level in that order.  Any unused entries
+ will have 0 in the page_shift field.
+ 
+ The ap_encodings gives the supported page sizes and their AP field
+ encodings, encoded with the AP value in the top 3 bits and the log
+ base 2 of the page size in the bottom 6 bits.
+ 
+ 4.102 KVM_PPC_RESIZE_HPT_PREPARE
+ 
+ Capability: KVM_CAP_SPAPR_RESIZE_HPT
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_resize_hpt (in)
+ Returns: 0 on successful completion,
+ 	 >0 if a new HPT is being prepared, the value is an estimated
+              number of milliseconds until preparation is complete
+          -EFAULT if struct kvm_reinject_control cannot be read,
+ 	 -EINVAL if the supplied shift or flags are invalid
+ 	 -ENOMEM if unable to allocate the new HPT
+ 	 -ENOSPC if there was a hash collision when moving existing
+                   HPT entries to the new HPT
+ 	 -EIO on other error conditions
+ 
+ Used to implement the PAPR extension for runtime resizing of a guest's
+ Hashed Page Table (HPT).  Specifically this starts, stops or monitors
+ the preparation of a new potential HPT for the guest, essentially
+ implementing the H_RESIZE_HPT_PREPARE hypercall.
+ 
+ If called with shift > 0 when there is no pending HPT for the guest,
+ this begins preparation of a new pending HPT of size 2^(shift) bytes.
+ It then returns a positive integer with the estimated number of
+ milliseconds until preparation is complete.
+ 
+ If called when there is a pending HPT whose size does not match that
+ requested in the parameters, discards the existing pending HPT and
+ creates a new one as above.
+ 
+ If called when there is a pending HPT of the size requested, will:
+   * If preparation of the pending HPT is already complete, return 0
+   * If preparation of the pending HPT has failed, return an error
+     code, then discard the pending HPT.
+   * If preparation of the pending HPT is still in progress, return an
+     estimated number of milliseconds until preparation is complete.
+ 
+ If called with shift == 0, discards any currently pending HPT and
+ returns 0 (i.e. cancels any in-progress preparation).
+ 
+ flags is reserved for future expansion, currently setting any bits in
+ flags will result in an -EINVAL.
+ 
+ Normally this will be called repeatedly with the same parameters until
+ it returns <= 0.  The first call will initiate preparation, subsequent
+ ones will monitor preparation until it completes or fails.
+ 
+ struct kvm_ppc_resize_hpt {
+ 	__u64 flags;
+ 	__u32 shift;
+ 	__u32 pad;
+ };
+ 
+ 4.103 KVM_PPC_RESIZE_HPT_COMMIT
+ 
+ Capability: KVM_CAP_SPAPR_RESIZE_HPT
+ Architectures: powerpc
+ Type: vm ioctl
+ Parameters: struct kvm_ppc_resize_hpt (in)
+ Returns: 0 on successful completion,
+          -EFAULT if struct kvm_reinject_control cannot be read,
+ 	 -EINVAL if the supplied shift or flags are invalid
+ 	 -ENXIO is there is no pending HPT, or the pending HPT doesn't
+                  have the requested size
+ 	 -EBUSY if the pending HPT is not fully prepared
+ 	 -ENOSPC if there was a hash collision when moving existing
+                   HPT entries to the new HPT
+ 	 -EIO on other error conditions
+ 
+ Used to implement the PAPR extension for runtime resizing of a guest's
+ Hashed Page Table (HPT).  Specifically this requests that the guest be
+ transferred to working with the new HPT, essentially implementing the
+ H_RESIZE_HPT_COMMIT hypercall.
+ 
+ This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has
+ returned 0 with the same parameters.  In other cases
+ KVM_PPC_RESIZE_HPT_COMMIT will return an error (usually -ENXIO or
+ -EBUSY, though others may be possible if the preparation was started,
+ but failed).
+ 
+ This will have undefined effects on the guest if it has not already
+ placed itself in a quiescent state where no vcpu will make MMU enabled
+ memory accesses.
+ 
+ On succsful completion, the pending HPT will become the guest's active
+ HPT and the previous HPT will be discarded.
+ 
+ On failure, the guest will still be operating on its previous HPT.
+ 
+ struct kvm_ppc_resize_hpt {
+ 	__u64 flags;
+ 	__u32 shift;
+ 	__u32 pad;
+ };
+ 
++>>>>>>> ef1ead0c3b1d (KVM: PPC: Book3S HV: HPT resizing documentation and reserved numbers)
  5. The kvm_run structure
  ------------------------
  
diff --cc include/uapi/linux/kvm.h
index 27ecc49f2a9f,7964b970b9ad..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -528,7 -685,12 +528,16 @@@ struct kvm_ppc_smmu_info 
  	struct kvm_ppc_one_seg_page_size sps[KVM_PPC_PAGE_SIZES_MAX_SZ];
  };
  
++<<<<<<< HEAD
 +#define KVM_PPC_PVINFO_FLAGS_EV_IDLE   (1<<0)
++=======
+ /* for KVM_PPC_RESIZE_HPT_{PREPARE,COMMIT} */
+ struct kvm_ppc_resize_hpt {
+ 	__u64 flags;
+ 	__u32 shift;
+ 	__u32 pad;
+ };
++>>>>>>> ef1ead0c3b1d (KVM: PPC: Book3S HV: HPT resizing documentation and reserved numbers)
  
  #define KVMIO 0xAE
  
@@@ -702,8 -868,19 +711,17 @@@
  #define KVM_CAP_GUEST_DEBUG_HW_WPS 120
  #define KVM_CAP_SPLIT_IRQCHIP 121
  #define KVM_CAP_IOEVENTFD_ANY_LENGTH 122
 -#define KVM_CAP_HYPERV_SYNIC 123
 -#define KVM_CAP_S390_RI 124
 -#define KVM_CAP_SPAPR_TCE_64 125
 -#define KVM_CAP_ARM_PMU_V3 126
 -#define KVM_CAP_VCPU_ATTRIBUTES 127
  #define KVM_CAP_MAX_VCPU_ID 128
  #define KVM_CAP_X2APIC_API 129
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_S390_USER_INSTR0 130
+ #define KVM_CAP_MSI_DEVID 131
+ #define KVM_CAP_PPC_HTM 132
+ #define KVM_CAP_SPAPR_RESIZE_HPT 133
+ #define KVM_CAP_PPC_MMU_RADIX 134
+ #define KVM_CAP_PPC_MMU_HASH_V3 135
++>>>>>>> ef1ead0c3b1d (KVM: PPC: Book3S HV: HPT resizing documentation and reserved numbers)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
@@@ -991,6 -1197,13 +1009,16 @@@ struct kvm_s390_ucas_mapping 
  #define KVM_ARM_SET_DEVICE_ADDR	  _IOW(KVMIO,  0xab, struct kvm_arm_device_addr)
  /* Available with KVM_CAP_PPC_RTAS */
  #define KVM_PPC_RTAS_DEFINE_TOKEN _IOW(KVMIO,  0xac, struct kvm_rtas_token_args)
++<<<<<<< HEAD
++=======
+ /* Available with KVM_CAP_SPAPR_RESIZE_HPT */
+ #define KVM_PPC_RESIZE_HPT_PREPARE _IOR(KVMIO, 0xad, struct kvm_ppc_resize_hpt)
+ #define KVM_PPC_RESIZE_HPT_COMMIT  _IOR(KVMIO, 0xae, struct kvm_ppc_resize_hpt)
+ /* Available with KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3 */
+ #define KVM_PPC_CONFIGURE_V3_MMU  _IOW(KVMIO,  0xaf, struct kvm_ppc_mmuv3_cfg)
+ /* Available with KVM_CAP_PPC_RADIX_MMU */
+ #define KVM_PPC_GET_RMMU_INFO	  _IOW(KVMIO,  0xb0, struct kvm_ppc_rmmu_info)
++>>>>>>> ef1ead0c3b1d (KVM: PPC: Book3S HV: HPT resizing documentation and reserved numbers)
  
  /* ioctl for vm fd */
  #define KVM_CREATE_DEVICE	  _IOWR(KVMIO,  0xe0, struct kvm_create_device)
* Unmerged path Documentation/virtual/kvm/api.txt
* Unmerged path include/uapi/linux/kvm.h
