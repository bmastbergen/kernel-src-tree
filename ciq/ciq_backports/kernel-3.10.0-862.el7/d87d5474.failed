scsi: smartpqi: cleanup messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] smartpqi: cleanup messages (Don Brace) [1457414]
Rebuild_FUZZ: 89.66%
commit-author Kevin Barnett <kevin.barnett@microsemi.com>
commit d87d5474e2080695ef0cc8c5e6c42a41d6ab961b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d87d5474.failed

- improve some error messages.

	Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
	Signed-off-by: Kevin Barnett <kevin.barnett@microsemi.com>
	Signed-off-by: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d87d5474e2080695ef0cc8c5e6c42a41d6ab961b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/smartpqi/smartpqi_init.c
diff --cc drivers/scsi/smartpqi/smartpqi_init.c
index 4b483a9148d0,9e782e6b1e26..000000000000
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@@ -3120,11 -3204,8 +3122,14 @@@ static int pqi_alloc_operational_queues
  			alloc_length,
  			&ctrl_info->queue_memory_base_dma_handle, GFP_KERNEL);
  
++<<<<<<< HEAD
 +	if (!ctrl_info->queue_memory_base) {
 +		dev_err(&ctrl_info->pci_dev->dev,
 +			"failed to allocate memory for PQI admin queues\n");
++=======
+ 	if (!ctrl_info->queue_memory_base)
++>>>>>>> d87d5474e208 (scsi: smartpqi: cleanup messages)
  		return -ENOMEM;
- 	}
  
  	ctrl_info->queue_memory_length = alloc_length;
  
@@@ -5550,6 -5678,55 +5548,58 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int pqi_process_config_table(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	u32 table_length;
+ 	u32 section_offset;
+ 	void __iomem *table_iomem_addr;
+ 	struct pqi_config_table *config_table;
+ 	struct pqi_config_table_section_header *section;
+ 
+ 	table_length = ctrl_info->config_table_length;
+ 
+ 	config_table = kmalloc(table_length, GFP_KERNEL);
+ 	if (!config_table) {
+ 		dev_err(&ctrl_info->pci_dev->dev,
+ 			"failed to allocate memory for PQI configuration table\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/*
+ 	 * Copy the config table contents from I/O memory space into the
+ 	 * temporary buffer.
+ 	 */
+ 	table_iomem_addr = ctrl_info->iomem_base +
+ 		ctrl_info->config_table_offset;
+ 	memcpy_fromio(config_table, table_iomem_addr, table_length);
+ 
+ 	section_offset =
+ 		get_unaligned_le32(&config_table->first_section_offset);
+ 
+ 	while (section_offset) {
+ 		section = (void *)config_table + section_offset;
+ 
+ 		switch (get_unaligned_le16(&section->section_id)) {
+ 		case PQI_CONFIG_TABLE_SECTION_HEARTBEAT:
+ 			ctrl_info->heartbeat_counter = table_iomem_addr +
+ 				section_offset +
+ 				offsetof(struct pqi_config_table_heartbeat,
+ 					heartbeat_counter);
+ 			break;
+ 		}
+ 
+ 		section_offset =
+ 			get_unaligned_le16(&section->next_section_offset);
+ 	}
+ 
+ 	kfree(config_table);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d87d5474e208 (scsi: smartpqi: cleanup messages)
  /* Switches the controller from PQI mode back into SIS mode. */
  
  static int pqi_revert_to_sis_mode(struct pqi_ctrl_info *ctrl_info)
@@@ -5762,6 -5935,116 +5815,119 @@@ static int pqi_ctrl_init(struct pqi_ctr
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_PM)
+ 
+ static void pqi_reinit_queues(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	unsigned int i;
+ 	struct pqi_admin_queues *admin_queues;
+ 	struct pqi_event_queue *event_queue;
+ 
+ 	admin_queues = &ctrl_info->admin_queues;
+ 	admin_queues->iq_pi_copy = 0;
+ 	admin_queues->oq_ci_copy = 0;
+ 	*admin_queues->oq_pi = 0;
+ 
+ 	for (i = 0; i < ctrl_info->num_queue_groups; i++) {
+ 		ctrl_info->queue_groups[i].iq_pi_copy[RAID_PATH] = 0;
+ 		ctrl_info->queue_groups[i].iq_pi_copy[AIO_PATH] = 0;
+ 		ctrl_info->queue_groups[i].oq_ci_copy = 0;
+ 
+ 		*ctrl_info->queue_groups[i].iq_ci[RAID_PATH] = 0;
+ 		*ctrl_info->queue_groups[i].iq_ci[AIO_PATH] = 0;
+ 		*ctrl_info->queue_groups[i].oq_pi = 0;
+ 	}
+ 
+ 	event_queue = &ctrl_info->event_queue;
+ 	*event_queue->oq_pi = 0;
+ 	event_queue->oq_ci_copy = 0;
+ }
+ 
+ static int pqi_ctrl_init_resume(struct pqi_ctrl_info *ctrl_info)
+ {
+ 	int rc;
+ 
+ 	rc = pqi_force_sis_mode(ctrl_info);
+ 	if (rc)
+ 		return rc;
+ 
+ 	/*
+ 	 * Wait until the controller is ready to start accepting SIS
+ 	 * commands.
+ 	 */
+ 	rc = sis_wait_for_ctrl_ready_resume(ctrl_info);
+ 	if (rc)
+ 		return rc;
+ 
+ 	/*
+ 	 * If the function we are about to call succeeds, the
+ 	 * controller will transition from legacy SIS mode
+ 	 * into PQI mode.
+ 	 */
+ 	rc = sis_init_base_struct_addr(ctrl_info);
+ 	if (rc) {
+ 		dev_err(&ctrl_info->pci_dev->dev,
+ 			"error initializing PQI mode\n");
+ 		return rc;
+ 	}
+ 
+ 	/* Wait for the controller to complete the SIS -> PQI transition. */
+ 	rc = pqi_wait_for_pqi_mode_ready(ctrl_info);
+ 	if (rc) {
+ 		dev_err(&ctrl_info->pci_dev->dev,
+ 			"transition to PQI mode failed\n");
+ 		return rc;
+ 	}
+ 
+ 	/* From here on, we are running in PQI mode. */
+ 	ctrl_info->pqi_mode_enabled = true;
+ 	pqi_save_ctrl_mode(ctrl_info, PQI_MODE);
+ 
+ 	pqi_reinit_queues(ctrl_info);
+ 
+ 	rc = pqi_create_admin_queues(ctrl_info);
+ 	if (rc) {
+ 		dev_err(&ctrl_info->pci_dev->dev,
+ 			"error creating admin queues\n");
+ 		return rc;
+ 	}
+ 
+ 	rc = pqi_create_queues(ctrl_info);
+ 	if (rc)
+ 		return rc;
+ 
+ 	pqi_change_irq_mode(ctrl_info, IRQ_MODE_MSIX);
+ 
+ 	ctrl_info->controller_online = true;
+ 	pqi_start_heartbeat_timer(ctrl_info);
+ 	pqi_ctrl_unblock_requests(ctrl_info);
+ 
+ 	rc = pqi_enable_events(ctrl_info);
+ 	if (rc) {
+ 		dev_err(&ctrl_info->pci_dev->dev,
+ 			"error enabling events\n");
+ 		return rc;
+ 	}
+ 
+ 	rc = pqi_write_driver_version_to_host_wellness(ctrl_info);
+ 	if (rc) {
+ 		dev_err(&ctrl_info->pci_dev->dev,
+ 			"error updating host wellness\n");
+ 		return rc;
+ 	}
+ 
+ 	pqi_schedule_update_time_worker(ctrl_info);
+ 
+ 	pqi_scan_scsi_devices(ctrl_info);
+ 
+ 	return 0;
+ }
+ 
+ #endif /* CONFIG_PM */
+ 
++>>>>>>> d87d5474e208 (scsi: smartpqi: cleanup messages)
  static inline int pqi_set_pcie_completion_timeout(struct pci_dev *pci_dev,
  	u16 timeout)
  {
* Unmerged path drivers/scsi/smartpqi/smartpqi_init.c
diff --git a/drivers/scsi/smartpqi/smartpqi_sis.c b/drivers/scsi/smartpqi/smartpqi_sis.c
index 6ebeb141fe44..0f09f9aaac3e 100644
--- a/drivers/scsi/smartpqi/smartpqi_sis.c
+++ b/drivers/scsi/smartpqi/smartpqi_sis.c
@@ -101,7 +101,8 @@ int sis_wait_for_ctrl_ready(struct pqi_ctrl_info *ctrl_info)
 		}
 		if (time_after(jiffies, timeout)) {
 			dev_err(&ctrl_info->pci_dev->dev,
-				"controller not ready\n");
+				"controller not ready after %u seconds\n",
+				timeout_secs);
 			return -ETIMEDOUT;
 		}
 		msleep(SIS_CTRL_READY_POLL_INTERVAL_MSECS);
