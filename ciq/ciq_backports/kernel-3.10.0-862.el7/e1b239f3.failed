ALSA: x86: Refactor PCM process engine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit e1b239f371c0c745542cb8108d085ec728e8a69c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/e1b239f3.failed

This is again a big rewrite of the driver; now it touches the code to
process PCM stream transfers.

The most fundamental change is that the driver may support more than
four periods.  Instead of keeping the same index between both the ring
buffer (with the fixed four buffer descriptors) and the PCM buffer
periods, we keep difference indices for both (bd_head and pcm_head
fields).  In addition, when the periods are more than four, we need to
track both head and next indices.  That is, we now have three indices:
bd_head, pcm_head and pcm_filled.

Also, the driver works better for periods < 4, too: the remaining BDs
out of four are marked as invalid, so that the hardware skips those
BDs in its loop.

By this flexibility, we can use even ALSA-lib dmix plugin, which
requires 16 periods as default.

The buffer size could be up to 20bit, so the max buffer size was
increased accordingly.  However, the buffer pre-allocation is kept as
the old value (600kB) as default.  The reason is the limited number of
BDs: since it doesn't suffice for the useful SG page management that
can fit with the usual page allocator like some other drivers, we have
to still allocate continuous pages, hence we shouldn't take too big
memories there.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit e1b239f371c0c745542cb8108d085ec728e8a69c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/x86/intel_hdmi_audio.c
#	sound/x86/intel_hdmi_audio.h
#	sound/x86/intel_hdmi_lpe_audio.h
diff --cc sound/x86/intel_hdmi_audio.c
index 063e2be94d05,8978dc9bf579..000000000000
--- a/sound/x86/intel_hdmi_audio.c
+++ b/sound/x86/intel_hdmi_audio.c
@@@ -637,99 -615,13 +637,102 @@@ static void snd_intelhad_prog_dip(struc
  
  	/* program remaining DIP words with zero */
  	for (i = 0; i < HAD_MAX_DIP_WORDS-VALID_DIP_WORDS; i++)
 -		had_write_register(intelhaddata, AUD_HDMIW_INFOFR, 0x0);
 +		had_write_register(intelhaddata, AUD_HDMIW_INFOFR_v2, 0x0);
  
 -	ctrl_state.regx.dip_freq = 1;
 -	ctrl_state.regx.dip_en_sta = 1;
 -	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);
 +	ctrl_state.ctrl_regx.dip_freq = 1;
 +	ctrl_state.ctrl_regx.dip_en_sta = 1;
 +	had_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.ctrl_val);
  }
  
++<<<<<<< HEAD
 +/**
 + * snd_intelhad_prog_buffer - programs buffer
 + * address and length registers
 + *
 + * @substream:substream for which the prepare function is called
 + * @intelhaddata:substream private data
 + *
 + * This function programs ring buffer address and length into registers.
 + */
 +int snd_intelhad_prog_buffer(struct snd_intelhad *intelhaddata,
 +					int start, int end)
 +{
 +	u32 ring_buf_addr, ring_buf_size, period_bytes;
 +	u8 i, num_periods;
 +	struct snd_pcm_substream *substream;
 +
 +	substream = intelhaddata->stream_info.had_substream;
 +	if (!substream) {
 +		pr_err("substream is NULL\n");
 +		dump_stack();
 +		return 0;
 +	}
 +
 +	ring_buf_addr = substream->runtime->dma_addr;
 +	ring_buf_size = snd_pcm_lib_buffer_bytes(substream);
 +	intelhaddata->stream_info.ring_buf_size = ring_buf_size;
 +	period_bytes = frames_to_bytes(substream->runtime,
 +				substream->runtime->period_size);
 +	num_periods = substream->runtime->periods;
 +
 +	/*
 +	 * buffer addr should  be 64 byte aligned, period bytes
 +	 * will be used to calculate addr offset
 +	 */
 +	period_bytes &= ~0x3F;
 +
 +	/* Hardware supports MAX_PERIODS buffers */
 +	if (end >= HAD_MAX_PERIODS)
 +		return -EINVAL;
 +
 +	for (i = start; i <= end; i++) {
 +		/* Program the buf registers with addr and len */
 +		intelhaddata->buf_info[i].buf_addr = ring_buf_addr +
 +							 (i * period_bytes);
 +		if (i < num_periods-1)
 +			intelhaddata->buf_info[i].buf_size = period_bytes;
 +		else
 +			intelhaddata->buf_info[i].buf_size = ring_buf_size -
 +							(period_bytes*i);
 +
 +		had_write_register(intelhaddata,
 +				   AUD_BUF_A_ADDR + (i * HAD_REG_WIDTH),
 +					intelhaddata->buf_info[i].buf_addr |
 +					BIT(0) | BIT(1));
 +		had_write_register(intelhaddata,
 +				   AUD_BUF_A_LENGTH + (i * HAD_REG_WIDTH),
 +					period_bytes);
 +		intelhaddata->buf_info[i].is_valid = true;
 +	}
 +	pr_debug("%s:buf[%d-%d] addr=%#x  and size=%d\n", __func__, start, end,
 +			intelhaddata->buf_info[start].buf_addr,
 +			intelhaddata->buf_info[start].buf_size);
 +	intelhaddata->valid_buf_cnt = num_periods;
 +	return 0;
 +}
 +
 +int snd_intelhad_read_len(struct snd_intelhad *intelhaddata)
 +{
 +	int i, retval = 0;
 +	u32 len[4];
 +
 +	for (i = 0; i < 4 ; i++) {
 +		had_read_register(intelhaddata,
 +				  AUD_BUF_A_LENGTH + (i * HAD_REG_WIDTH),
 +				  &len[i]);
 +		if (!len[i])
 +			retval++;
 +	}
 +	if (retval != 1) {
 +		for (i = 0; i < 4 ; i++)
 +			pr_debug("buf[%d] size=%d\n", i, len[i]);
 +	}
 +
 +	return retval;
 +}
 +
++=======
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  static int had_calculate_maud_value(u32 aud_samp_freq, u32 link_rate)
  {
  	u32 maud_val;
@@@ -917,41 -809,223 +920,254 @@@ static int snd_intelhad_prog_n(u32 aud_
  	return 0;
  }
  
++<<<<<<< HEAD
 +void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata)
 +{
 +	u32 hdmi_status, i = 0;
++=======
+ /*
+  * PCM ring buffer handling
+  *
+  * The hardware provides a ring buffer with the fixed 4 buffer descriptors
+  * (BDs).  The driver maps these 4 BDs onto the PCM ring buffer.  The mapping
+  * moves at each period elapsed.  The below illustrates how it works:
+  *
+  * At time=0
+  *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
+  *  BD  | 0 | 1 | 2 | 3 |
+  *
+  * At time=1 (period elapsed)
+  *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
+  *  BD      | 1 | 2 | 3 | 0 |
+  *
+  * At time=2 (second period elapsed)
+  *  PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
+  *  BD          | 2 | 3 | 0 | 1 |
+  *
+  * The bd_head field points to the index of the BD to be read.  It's also the
+  * position to be filled at next.  The pcm_head and the pcm_filled fields
+  * point to the indices of the current position and of the next position to
+  * be filled, respectively.  For PCM buffer there are both _head and _filled
+  * because they may be difference when nperiods > 4.  For example, in the
+  * example above at t=1, bd_head=1 and pcm_head=1 while pcm_filled=5:
+  *
+  * pcm_head (=1) --v               v-- pcm_filled (=5)
+  *       PCM | 0 | 1 | 2 | 3 | 4 | 5 | .... |n-1|
+  *       BD      | 1 | 2 | 3 | 0 |
+  *  bd_head (=1) --^               ^-- next to fill (= bd_head)
+  *
+  * For nperiods < 4, the remaining BDs out of 4 are marked as invalid, so that
+  * the hardware skips those BDs in the loop.
+  */
+ 
+ #define AUD_BUF_ADDR(x)		(AUD_BUF_A_ADDR + (x) * HAD_REG_WIDTH)
+ #define AUD_BUF_LEN(x)		(AUD_BUF_A_LENGTH + (x) * HAD_REG_WIDTH)
+ 
+ /* Set up a buffer descriptor at the "filled" position */
+ static void had_prog_bd(struct snd_pcm_substream *substream,
+ 			struct snd_intelhad *intelhaddata)
+ {
+ 	int idx = intelhaddata->bd_head;
+ 	int ofs = intelhaddata->pcmbuf_filled * intelhaddata->period_bytes;
+ 	u32 addr = substream->runtime->dma_addr + ofs;
+ 
+ 	addr |= AUD_BUF_VALID | AUD_BUF_INTR_EN;
+ 	had_write_register(intelhaddata, AUD_BUF_ADDR(idx), addr);
+ 	had_write_register(intelhaddata, AUD_BUF_LEN(idx),
+ 			   intelhaddata->period_bytes);
+ 
+ 	/* advance the indices to the next */
+ 	intelhaddata->bd_head++;
+ 	intelhaddata->bd_head %= intelhaddata->num_bds;
+ 	intelhaddata->pcmbuf_filled++;
+ 	intelhaddata->pcmbuf_filled %= substream->runtime->periods;
+ }
+ 
+ /* invalidate a buffer descriptor with the given index */
+ static void had_invalidate_bd(struct snd_intelhad *intelhaddata,
+ 			      int idx)
+ {
+ 	had_write_register(intelhaddata, AUD_BUF_ADDR(idx), 0);
+ 	had_write_register(intelhaddata, AUD_BUF_LEN(idx), 0);
+ }
+ 
+ /* Initial programming of ring buffer */
+ static void had_init_ringbuf(struct snd_pcm_substream *substream,
+ 			     struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_runtime *runtime = substream->runtime;
+ 	int i, num_periods;
+ 
+ 	num_periods = runtime->periods;
+ 	intelhaddata->num_bds = min(num_periods, HAD_NUM_OF_RING_BUFS);
+ 	intelhaddata->period_bytes =
+ 		frames_to_bytes(runtime, runtime->period_size);
+ 	WARN_ON(intelhaddata->period_bytes & 0x3f);
+ 
+ 	intelhaddata->bd_head = 0;
+ 	intelhaddata->pcmbuf_head = 0;
+ 	intelhaddata->pcmbuf_filled = 0;
+ 
+ 	for (i = 0; i < HAD_NUM_OF_RING_BUFS; i++) {
+ 		if (i < num_periods)
+ 			had_prog_bd(substream, intelhaddata);
+ 		else /* invalidate the rest */
+ 			had_invalidate_bd(intelhaddata, i);
+ 	}
+ 
+ 	intelhaddata->bd_head = 0; /* reset at head again before starting */
+ }
+ 
+ /* process a bd, advance to the next */
+ static void had_advance_ringbuf(struct snd_pcm_substream *substream,
+ 				struct snd_intelhad *intelhaddata)
+ {
+ 	int num_periods = substream->runtime->periods;
+ 
+ 	/* reprogram the next buffer */
+ 	had_prog_bd(substream, intelhaddata);
+ 
+ 	/* proceed to next */
+ 	intelhaddata->pcmbuf_head++;
+ 	intelhaddata->pcmbuf_head %= num_periods;
+ }
+ 
+ /* process the current BD(s);
+  * returns the current PCM buffer byte position, or -EPIPE for underrun.
+  */
+ static int had_process_ringbuf(struct snd_pcm_substream *substream,
+ 			       struct snd_intelhad *intelhaddata)
+ {
+ 	int len, processed;
+ 	unsigned long flags;
+ 
+ 	processed = 0;
+ 	spin_lock_irqsave(&intelhaddata->had_spinlock, flags);
+ 	for (;;) {
+ 		/* get the remaining bytes on the buffer */
+ 		had_read_register(intelhaddata,
+ 				  AUD_BUF_LEN(intelhaddata->bd_head),
+ 				  &len);
+ 		if (len < 0 || len > intelhaddata->period_bytes) {
+ 			dev_dbg(intelhaddata->dev, "Invalid buf length %d\n",
+ 				len);
+ 			len = -EPIPE;
+ 			goto out;
+ 		}
+ 
+ 		if (len > 0) /* OK, this is the current buffer */
+ 			break;
+ 
+ 		/* len=0 => already empty, check the next buffer */
+ 		if (++processed >= intelhaddata->num_bds) {
+ 			len = -EPIPE; /* all empty? - report underrun */
+ 			goto out;
+ 		}
+ 		had_advance_ringbuf(substream, intelhaddata);
+ 	}
+ 
+ 	len = intelhaddata->period_bytes - len;
+ 	len += intelhaddata->period_bytes * intelhaddata->pcmbuf_head;
+  out:
+ 	spin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);
+ 	return len;
+ }
+ 
+ /* called from irq handler */
+ static void had_process_buffer_done(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	if (!intelhaddata->connected)
+ 		return; /* disconnected? - bail out */
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 	if (!substream)
+ 		return; /* no stream? - bail out */
+ 
+ 	/* process or stop the stream */
+ 	if (had_process_ringbuf(substream, intelhaddata) < 0)
+ 		snd_pcm_stop_xrun(substream);
+ 	else
+ 		snd_pcm_period_elapsed(substream);
+ 
+ 	had_substream_put(intelhaddata);
+ }
+ 
+ #define MAX_CNT			0xFF
+ 
+ /*
+  * The interrupt status 'sticky' bits might not be cleared by
+  * setting '1' to that bit once...
+  */
+ static void wait_clear_underrun_bit(struct snd_intelhad *intelhaddata)
+ {
+ 	int i;
+ 	u32 val;
+ 
+ 	for (i = 0; i < MAX_CNT; i++) {
+ 		/* clear bit30, 31 AUD_HDMI_STATUS */
+ 		had_read_register(intelhaddata, AUD_HDMI_STATUS, &val);
+ 		if (!(val & AUD_CONFIG_MASK_UNDERRUN))
+ 			return;
+ 		had_write_register(intelhaddata, AUD_HDMI_STATUS, val);
+ 	}
+ 	dev_err(intelhaddata->dev, "Unable to clear UNDERRUN bits\n");
+ }
+ 
+ /* called from irq handler */
+ static void had_process_buffer_underrun(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  
  	/* Handle Underrun interrupt within Audio Unit */
  	had_write_register(intelhaddata, AUD_CONFIG, 0);
  	/* Reset buffer pointers */
++<<<<<<< HEAD
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, 1);
 +	had_write_register(intelhaddata, AUD_HDMI_STATUS_v2, 0);
 +	/**
 +	 * The interrupt status 'sticky' bits might not be cleared by
 +	 * setting '1' to that bit once...
 +	 */
 +	do { /* clear bit30, 31 AUD_HDMI_STATUS */
 +		had_read_register(intelhaddata, AUD_HDMI_STATUS_v2,
 +				  &hdmi_status);
 +		pr_debug("HDMI status =0x%x\n", hdmi_status);
 +		if (hdmi_status & AUD_CONFIG_MASK_UNDERRUN) {
 +			i++;
 +			had_write_register(intelhaddata,
 +					   AUD_HDMI_STATUS_v2, hdmi_status);
 +		} else
 +			break;
 +	} while (i < MAX_CNT);
 +	if (i >= MAX_CNT)
 +		pr_err("Unable to clear UNDERRUN bits\n");
++=======
+ 	had_reset_audio(intelhaddata);
+ 
+ 	wait_clear_underrun_bit(intelhaddata);
+ 
+ 	if (!intelhaddata->connected)
+ 		return; /* disconnected? - bail out */
+ 
+ 	/* Report UNDERRUN error to above layers */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		snd_pcm_stop_xrun(substream);
+ 		had_substream_put(intelhaddata);
+ 	}
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  }
  
 -/*
 - * ALSA PCM open callback
 +/**
 + * snd_intelhad_open - stream initializations are done here
 + * @substream:substream for which the stream function is called
 + *
 + * This function is called whenever a PCM stream is opened
   */
 -static int had_pcm_open(struct snd_pcm_substream *substream)
 +static int snd_intelhad_open(struct snd_pcm_substream *substream)
  {
  	struct snd_intelhad *intelhaddata;
  	struct snd_pcm_runtime *runtime;
@@@ -1001,17 -1056,18 +1217,28 @@@
  	 */
  	retval = snd_pcm_hw_constraint_step(substream->runtime, 0,
  			SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);
++<<<<<<< HEAD
 +	if (retval < 0) {
 +		pr_err("%s:step_size=64 failed,err=%d\n", __func__, retval);
 +		goto exit_err;
 +	}
++=======
+ 	if (retval < 0)
+ 		goto error;
+ 
+ 	/* expose PCM substream */
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	intelhaddata->stream_info.substream = substream;
+ 	intelhaddata->stream_info.substream_refcount++;
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  
  	return retval;
 - error:
 +exit_err:
 +	kfree(stream);
 +exit_put_handle:
  	pm_runtime_put(intelhaddata->dev);
 +	runtime->private_data = NULL;
  	return retval;
  }
  
@@@ -1271,59 -1218,36 +1498,66 @@@ static int snd_intelhad_pcm_prepare(str
  		goto prep_end;
  	}
  
 -	dev_dbg(intelhaddata->dev, "period_size=%d\n",
 +	pr_debug("period_size=%d\n",
  		(int)frames_to_bytes(runtime, runtime->period_size));
 -	dev_dbg(intelhaddata->dev, "periods=%d\n", runtime->periods);
 -	dev_dbg(intelhaddata->dev, "buffer_size=%d\n",
 -		(int)snd_pcm_lib_buffer_bytes(substream));
 -	dev_dbg(intelhaddata->dev, "rate=%d\n", runtime->rate);
 -	dev_dbg(intelhaddata->dev, "channels=%d\n", runtime->channels);
 +	pr_debug("periods=%d\n", runtime->periods);
 +	pr_debug("buffer_size=%d\n", (int)snd_pcm_lib_buffer_bytes(substream));
 +	pr_debug("rate=%d\n", runtime->rate);
 +	pr_debug("channels=%d\n", runtime->channels);
 +
 +	if (intelhaddata->stream_info.str_id) {
 +		pr_debug("_prepare is called for existing str_id#%d\n",
 +					intelhaddata->stream_info.str_id);
 +		retval = snd_intelhad_pcm_trigger(substream,
 +						SNDRV_PCM_TRIGGER_STOP);
 +		return retval;
 +	}
  
 +	retval = snd_intelhad_init_stream(substream);
 +	if (retval)
 +		goto prep_end;
 +
++<<<<<<< HEAD
 +
++=======
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  	/* Get N value in KHz */
 -	disp_samp_freq = intelhaddata->tmds_clock_speed;
 +	retval = had_get_caps(intelhaddata, HAD_GET_DISPLAY_RATE,
 +			      &disp_samp_freq);
 +	if (retval) {
 +		pr_err("querying display sampling freq failed %#x\n", retval);
 +		goto prep_end;
 +	}
  
 -	retval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);
 +	had_get_caps(intelhaddata, HAD_GET_ELD, &intelhaddata->eeld);
 +	had_get_caps(intelhaddata, HAD_GET_DP_OUTPUT, &intelhaddata->dp_output);
 +
 +	retval = snd_intelhad_prog_n(substream->runtime->rate, &n_param,
 +				     intelhaddata);
  	if (retval) {
 -		dev_err(intelhaddata->dev,
 -			"programming N value failed %#x\n", retval);
 +		pr_err("programming N value failed %#x\n", retval);
  		goto prep_end;
  	}
  
  	if (intelhaddata->dp_output)
 -		link_rate = intelhaddata->link_rate;
 +		had_get_caps(intelhaddata, HAD_GET_LINK_RATE, &link_rate);
 +
  
 -	had_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,
 -		     n_param, intelhaddata);
 +	snd_intelhad_prog_cts(substream->runtime->rate,
 +			      disp_samp_freq, link_rate,
 +			      n_param, intelhaddata);
  
 -	had_prog_dip(substream, intelhaddata);
 +	snd_intelhad_prog_dip(substream, intelhaddata);
  
 -	retval = had_init_audio_ctrl(substream, intelhaddata);
 +	retval = snd_intelhad_audio_ctrl(substream, intelhaddata);
  
  	/* Prog buffer address */
++<<<<<<< HEAD
 +	retval = snd_intelhad_prog_buffer(intelhaddata,
 +			HAD_BUF_TYPE_A, HAD_BUF_TYPE_D);
++=======
+ 	had_init_ringbuf(substream, intelhaddata);
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  
  	/*
  	 * Program channel mapping in following order:
@@@ -1336,84 -1260,31 +1570,89 @@@ prep_end
  	return retval;
  }
  
 -/*
 - * ALSA PCM pointer callback
 +/**
 + * snd_intelhad_pcm_pointer- to send the current buffer pointerprocessed by hw
 + *
 + * @substream:  substream for which the function is called
 + *
 + * This function is called by ALSA framework to get the current hw buffer ptr
 + * when a period is elapsed
   */
 -static snd_pcm_uframes_t had_pcm_pointer(struct snd_pcm_substream *substream)
 +static snd_pcm_uframes_t snd_intelhad_pcm_pointer(
 +					struct snd_pcm_substream *substream)
  {
  	struct snd_intelhad *intelhaddata;
- 	u32 bytes_rendered = 0;
- 	u32 t;
- 	int buf_id;
+ 	int len;
  
 +	/* pr_debug("snd_intelhad_pcm_pointer called\n"); */
 +
  	intelhaddata = snd_pcm_substream_chip(substream);
  
 -	if (!intelhaddata->connected)
 +	if (intelhaddata->flag_underrun) {
 +		intelhaddata->flag_underrun = 0;
  		return SNDRV_PCM_POS_XRUN;
 +	}
 +
++<<<<<<< HEAD
 +	/* Use a hw register to calculate sub-period position reports.
 +	 * This makes PulseAudio happier.
 +	 */
 +
 +	buf_id = intelhaddata->curr_buf % 4;
 +	had_read_register(intelhaddata,
 +			  AUD_BUF_A_LENGTH + (buf_id * HAD_REG_WIDTH), &t);
  
 +	if ((t == 0) || (t == ((u32)-1L))) {
 +		intelhaddata->underrun_count++;
 +		pr_debug("discovered buffer done for buf %d, count = %d\n",
 +			 buf_id, intelhaddata->underrun_count);
 +
 +		if (intelhaddata->underrun_count > (HAD_MIN_PERIODS/2)) {
 +			pr_debug("assume audio_codec_reset, underrun = %d - do xrun\n",
 +				 intelhaddata->underrun_count);
 +			intelhaddata->underrun_count = 0;
 +			return SNDRV_PCM_POS_XRUN;
 +		}
 +	} else {
 +		/* Reset Counter */
 +		intelhaddata->underrun_count = 0;
 +	}
 +
 +	t = intelhaddata->buf_info[buf_id].buf_size - t;
 +
 +	if (intelhaddata->stream_info.buffer_rendered)
 +		div_u64_rem(intelhaddata->stream_info.buffer_rendered,
 +			intelhaddata->stream_info.ring_buf_size,
 +			&(bytes_rendered));
 +
 +	intelhaddata->stream_info.buffer_ptr = bytes_to_frames(
 +						substream->runtime,
 +						bytes_rendered + t);
 +	return intelhaddata->stream_info.buffer_ptr;
++=======
+ 	len = had_process_ringbuf(substream, intelhaddata);
+ 	if (len < 0)
+ 		return SNDRV_PCM_POS_XRUN;
+ 	return bytes_to_frames(substream->runtime, len);
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  }
  
 -/*
 - * ALSA PCM mmap callback
 +/**
 + * snd_intelhad_pcm_mmap- mmaps a kernel buffer to user space for copying data
 + *
 + * @substream:  substream for which the function is called
 + * @vma:		struct instance of memory VMM memory area
 + *
 + * This function is called by OS when a user space component
 + * tries to get mmap memory from driver
   */
 -static int had_pcm_mmap(struct snd_pcm_substream *substream,
 -			struct vm_area_struct *vma)
 +static int snd_intelhad_pcm_mmap(struct snd_pcm_substream *substream,
 +	struct vm_area_struct *vma)
  {
 +
 +	pr_debug("snd_intelhad_pcm_mmap called\n");
 +
 +	pr_debug("entry with prot:%s\n", __func__);
  	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
  	return remap_pfn_range(vma, vma->vm_start,
  			substream->dma_buffer.addr >> PAGE_SHIFT,
@@@ -1461,55 -1344,78 +1700,128 @@@ out
  	return retval;
  }
  
++<<<<<<< HEAD
 +/*PCM operations structure and the calls back for the same */
 +struct snd_pcm_ops snd_intelhad_playback_ops = {
 +	.open =		snd_intelhad_open,
 +	.close =	snd_intelhad_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_intelhad_hw_params,
 +	.hw_free =	snd_intelhad_hw_free,
 +	.prepare =	snd_intelhad_pcm_prepare,
 +	.trigger =	snd_intelhad_pcm_trigger,
 +	.pointer =	snd_intelhad_pcm_pointer,
 +	.mmap =	snd_intelhad_pcm_mmap,
 +};
 +
 +/**
 + * snd_intelhad_create - to crete alsa card instance
 + *
 + * @intelhaddata: pointer to internal context
 + * @card: pointer to card
 + *
 + * This function is called when the hdmi cable is plugged in
++=======
+ /* process hot plug, called from wq with mutex locked */
+ static void had_process_hot_plug(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 	if (intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already connected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		return;
+ 	}
+ 
+ 	intelhaddata->connected = true;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	/* Safety check */
+ 	substream = had_substream_get(intelhaddata);
+ 	if (substream) {
+ 		dev_dbg(intelhaddata->dev,
+ 			"Force to stop the active stream by disconnection\n");
+ 		/* Set runtime->state to hw_params done */
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 		had_substream_put(intelhaddata);
+ 	}
+ 
+ 	had_build_channel_allocation_map(intelhaddata);
+ }
+ 
+ /* process hot unplug, called from wq with mutex locked */
+ static void had_process_hot_unplug(struct snd_intelhad *intelhaddata)
+ {
+ 	struct snd_pcm_substream *substream;
+ 
+ 	substream = had_substream_get(intelhaddata);
+ 
+ 	spin_lock_irq(&intelhaddata->had_spinlock);
+ 
+ 	if (!intelhaddata->connected) {
+ 		dev_dbg(intelhaddata->dev, "Device already disconnected\n");
+ 		spin_unlock_irq(&intelhaddata->had_spinlock);
+ 		goto out;
+ 
+ 	}
+ 
+ 	/* Disable Audio */
+ 	had_enable_audio_int(intelhaddata, false);
+ 	had_enable_audio(substream, intelhaddata, false);
+ 
+ 	intelhaddata->connected = false;
+ 	dev_dbg(intelhaddata->dev,
+ 		"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",
+ 			__func__, __LINE__);
+ 	spin_unlock_irq(&intelhaddata->had_spinlock);
+ 
+ 	/* Report to above ALSA layer */
+ 	if (substream)
+ 		snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+ 
+  out:
+ 	if (substream)
+ 		had_substream_put(intelhaddata);
+ 	kfree(intelhaddata->chmap->chmap);
+ 	intelhaddata->chmap->chmap = NULL;
+ }
+ 
+ /*
+  * ALSA iec958 and ELD controls
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
   */
 +static int snd_intelhad_create(
 +		struct snd_intelhad *intelhaddata,
 +		struct snd_card *card)
 +{
 +	int retval;
 +	static struct snd_device_ops ops = {
 +	};
 +
 +	pr_debug("snd_intelhad_create called\n");
 +
 +	if (!intelhaddata)
 +		return -EINVAL;
 +
 +	/* ALSA api to register the device */
 +	retval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelhaddata, &ops);
 +	return retval;
 +}
 +/**
 + * snd_intelhad_pcm_free - to free the memory allocated
 + *
 + * @pcm: pointer to pcm instance
 + * This function is called when the device is removed
 + */
 +static void snd_intelhad_pcm_free(struct snd_pcm *pcm)
 +{
 +	pr_debug("Freeing PCM preallocated pages\n");
 +	snd_pcm_lib_preallocate_free_for_all(pcm);
 +}
  
  static int had_iec958_info(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_info *uinfo)
@@@ -1634,77 -1741,57 +1946,89 @@@ int hdmi_audio_probe(struct platform_de
  		goto err;
  
  	/* setup private data which can be retrieved when required */
 -	pcm->private_data = ctx;
 +	pcm->private_data = intelhaddata;
 +	pcm->private_free = snd_intelhad_pcm_free;
  	pcm->info_flags = 0;
  	strncpy(pcm->name, card->shortname, strlen(card->shortname));
++<<<<<<< HEAD
 +	/* setup the ops for palyabck */
 +	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 +			    &snd_intelhad_playback_ops);
 +	/* allocate dma pages for ALSA stream operations
 +	 * memory allocated is based on size, not max value
 +	 * thus using same argument for max & size
++=======
+ 	/* setup the ops for playabck */
+ 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &had_pcm_ops);
+ 
+ 	/* only 32bit addressable */
+ 	dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+ 	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+ 
+ 	/* allocate dma pages;
+ 	 * try to allocate 600k buffer as default which is large enough
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  	 */
 -	snd_pcm_lib_preallocate_pages_for_all(pcm,
 +	retval = snd_pcm_lib_preallocate_pages_for_all(pcm,
  			SNDRV_DMA_TYPE_DEV, NULL,
- 			HAD_MAX_BUFFER, HAD_MAX_BUFFER);
+ 			HAD_DEFAULT_BUFFER, HAD_MAX_BUFFER);
  
 -	/* create controls */
 -	for (i = 0; i < ARRAY_SIZE(had_controls); i++) {
 -		ret = snd_ctl_add(card, snd_ctl_new1(&had_controls[i], ctx));
 -		if (ret < 0)
 -			goto err;
 -	}
 +	if (card->dev == NULL)
 +		pr_debug("card->dev is NULL!!!!! Should not be this case\n");
 +	else if (card->dev->dma_mask == NULL)
 +		pr_debug("hdmi_audio_probe dma_mask is NULL!!!!!\n");
 +	else
 +		pr_debug("hdmi_audio_probe dma_mask is : %p\n",
 +				card->dev->dma_mask);
  
 -	init_channel_allocations();
 +	if (retval)
 +		goto err;
  
 -	/* Register channel map controls */
 -	ret = had_register_chmap_ctls(ctx, pcm);
 -	if (ret < 0)
 +	/* internal function call to register device with ALSA */
 +	retval = snd_intelhad_create(intelhaddata, card);
 +	if (retval)
  		goto err;
  
 -	ret = snd_card_register(card);
 -	if (ret)
 +	card->private_data = &intelhaddata;
 +	retval = snd_card_register(card);
 +	if (retval)
  		goto err;
  
 -	spin_lock_irq(&pdata->lpe_audio_slock);
 -	pdata->notify_audio_lpe = notify_audio_lpe;
 -	pdata->notify_pending = false;
 -	spin_unlock_irq(&pdata->lpe_audio_slock);
 +	/* IEC958 controls */
 +	retval = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958_mask,
 +						intelhaddata));
 +	if (retval < 0)
 +		goto err;
 +	retval = snd_ctl_add(card, snd_ctl_new1(&had_control_iec958,
 +						intelhaddata));
 +	if (retval < 0)
 +		goto err;
  
 -	pm_runtime_set_active(&pdev->dev);
 -	pm_runtime_enable(&pdev->dev);
 +	init_channel_allocations();
  
 -	dev_dbg(&pdev->dev, "%s: handle pending notification\n", __func__);
 -	schedule_work(&ctx->hdmi_audio_wq);
 +	/* Register channel map controls */
 +	retval = had_register_chmap_ctls(intelhaddata, pcm);
 +	if (retval < 0)
 +		goto err;
  
 -	return 0;
 +	intelhaddata->dev = &devptr->dev;
 +	pm_runtime_set_active(intelhaddata->dev);
 +	pm_runtime_enable(intelhaddata->dev);
  
 +	*had_ret = intelhaddata;
 +
 +	return 0;
  err:
  	snd_card_free(card);
 -	return ret;
 +free_hadstream:
 +	kfree(had_stream);
 +	pm_runtime_disable(intelhaddata->dev);
 +	intelhaddata->dev = NULL;
 +free_haddata:
 +	kfree(intelhaddata);
 +	intelhaddata = NULL;
 +	pr_err("Error returned from %s api %#x\n", __func__, retval);
 +	return retval;
  }
  
  /*
diff --cc sound/x86/intel_hdmi_audio.h
index 32a2fb766e47,7e2546b853ca..000000000000
--- a/sound/x86/intel_hdmi_audio.h
+++ b/sound/x86/intel_hdmi_audio.h
@@@ -71,114 -60,57 +71,152 @@@ struct platform_device
  #define LAYOUT0			0
  #define LAYOUT1			1
  #define SWAP_LFE_CENTER		0x00fac4c8
 -#define AUD_CONFIG_CH_MASK	0x70
 +#define AUD_CONFIG_CH_MASK_V2	0x70
  
  struct pcm_stream_info {
++<<<<<<< HEAD
 +	int		str_id;
 +	void	*had_substream;
 +	void	(*period_elapsed)(void *had_substream);
 +	u32		buffer_ptr;
 +	u64		buffer_rendered;
 +	u32		ring_buf_size;
 +	int		sfreq;
 +};
 +
 +struct ring_buf_info {
 +	u32	buf_addr;
 +	u32	buf_size;
 +	u8	is_valid;
 +};
 +
 +struct had_stream_pvt {
 +	enum had_stream_status		stream_status;
 +	int				stream_ops;
 +	ssize_t				dbg_cum_bytes;
 +};
 +
 +struct had_pvt_data {
 +	enum had_status_stream		stream_type;
 +};
 +
 +/**
 + * struct snd_intelhad - intelhad driver structure
 + *
 + * @card: ptr to hold card details
 + * @card_index: sound card index
 + * @card_id: detected sound card id
 + * @drv_status: driver status
 + * @buf_info: ring buffer info
++=======
+ 	struct snd_pcm_substream *substream;
+ 	int substream_refcount;
+ 	bool running;
+ };
+ 
+ /*
+  * struct snd_intelhad - intelhad driver structure
+  *
+  * @card: ptr to hold card details
+  * @connected: the monitor connection status
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
   * @stream_info: stream information
 - * @eld: holds ELD info
 + * @eeld: holds EELD info
   * @curr_buf: pointer to hold current active ring buf
   * @valid_buf_cnt: ring buffer count for stream
   * @had_spinlock: driver lock
   * @aes_bits: IEC958 status bits
   * @buff_done: id of current buffer done intr
   * @dev: platoform device handle
 + * @kctl: holds kctl ptrs used for channel map
   * @chmap: holds channel map info
++<<<<<<< HEAD
 + * @audio_reg_base: hdmi audio register base offset
 + * @underrun_count: PCM stream underrun counter
 + */
 +struct snd_intelhad {
 +	struct snd_card	*card;
 +	int		card_index;
 +	char		*card_id;
 +	enum had_drv_status	drv_status;
 +	struct		ring_buf_info buf_info[HAD_NUM_OF_RING_BUFS];
++=======
+  */
+ struct snd_intelhad {
+ 	struct snd_card	*card;
+ 	bool		connected;
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  	struct		pcm_stream_info stream_info;
 -	unsigned char	eld[HDMI_MAX_ELD_BYTES];
 +	union otm_hdmi_eld_t	eeld;
  	bool dp_output;
- 	enum		intel_had_aud_buf_type curr_buf;
- 	int		valid_buf_cnt;
  	unsigned int	aes_bits;
 +	int flag_underrun;
 +	struct had_pvt_data *private_data;
  	spinlock_t had_spinlock;
- 	enum		intel_had_aud_buf_type buff_done;
  	struct device *dev;
 +	struct snd_kcontrol *kctl;
  	struct snd_pcm_chmap *chmap;
++<<<<<<< HEAD
 +	unsigned int	*audio_reg_base;
 +	unsigned int	audio_cfg_offset;
 +	int underrun_count;
++=======
+ 	int tmds_clock_speed;
+ 	int link_rate;
+ 
+ 	/* ring buffer (BD) position index */
+ 	unsigned int bd_head;
+ 	/* PCM buffer position indices */
+ 	unsigned int pcmbuf_head;	/* being processed */
+ 	unsigned int pcmbuf_filled;	/* to be filled */
+ 
+ 	unsigned int num_bds;		/* number of BDs */
+ 	unsigned int period_bytes;	/* PCM period size in bytes */
+ 
+ 	/* internal stuff */
+ 	int irq;
+ 	void __iomem *mmio_start;
+ 	unsigned int had_config_offset;
+ 	struct work_struct hdmi_audio_wq;
+ 	struct mutex mutex; /* for protecting chmap and eld */
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  };
  
 +int had_event_handler(enum had_event_type event_type, void *data);
 +
 +int hdmi_audio_query(void *drv_data, struct hdmi_audio_event event);
 +int hdmi_audio_suspend(void *drv_data);
 +int hdmi_audio_resume(void *drv_data);
 +int hdmi_audio_mode_change(struct snd_pcm_substream *substream);
 +extern struct snd_pcm_ops snd_intelhad_playback_ops;
 +
 +int snd_intelhad_init_audio_ctrl(struct snd_pcm_substream *substream,
 +					struct snd_intelhad *intelhaddata,
 +					int flag_silence);
 +int snd_intelhad_prog_buffer(struct snd_intelhad *intelhaddata,
 +					int start, int end);
 +int snd_intelhad_invd_buffer(int start, int end);
 +int snd_intelhad_read_len(struct snd_intelhad *intelhaddata);
 +void had_build_channel_allocation_map(struct snd_intelhad *intelhaddata);
 +
 +void snd_intelhad_enable_audio(struct snd_pcm_substream *substream, u8 enable);
 +void snd_intelhad_handle_underrun(struct snd_intelhad *intelhaddata);
 +
 +/* Register access functions */
 +int had_get_hwstate(struct snd_intelhad *intelhaddata);
 +int had_get_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list query_element, void *capabilties);
 +int had_set_caps(struct snd_intelhad *intelhaddata,
 +		 enum had_caps_list set_element, void *capabilties);
 +int had_read_register(struct snd_intelhad *intelhaddata,
 +		      u32 reg_addr, u32 *data);
 +int had_write_register(struct snd_intelhad *intelhaddata,
 +		       u32 reg_addr, u32 data);
 +int had_read_modify(struct snd_intelhad *intelhaddata,
 +		    u32 reg_addr, u32 data, u32 mask);
 +
 +int hdmi_audio_probe(struct platform_device *devptr,
 +		     struct snd_intelhad **had_ret);
 +int hdmi_audio_remove(struct snd_intelhad *intelhaddata);
 +
  #endif /* _INTEL_HDMI_AUDIO_ */
diff --cc sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57,ca4212dca94e..000000000000
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@@ -95,179 -82,6 +95,182 @@@
  /* Naud Value */
  #define DP_NAUD_VAL					32768
  
++<<<<<<< HEAD
 +/* _AUD_CONFIG register MASK */
 +#define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
 +#define AUD_CONFIG_MASK_SRDBG		0x00000002
 +#define AUD_CONFIG_MASK_FUNCRST		0x00000001
 +
 +#define MAX_CNT			0xFF
 +#define HAD_SUSPEND_DELAY	1000
 +
 +#define OTM_HDMI_ELD_SIZE 128
 +
 +union otm_hdmi_eld_t {
 +	unsigned char eld_data[OTM_HDMI_ELD_SIZE];
 +	struct {
 +		/* Byte[0] = ELD Version Number */
 +		union {
 +			unsigned char   byte0;
 +			struct {
 +				unsigned char reserved:3; /* Reserf */
 +				unsigned char eld_ver:5; /* ELD Version Number */
 +				/* 00000b - reserved
 +				 * 00001b - first rev, obsoleted
 +				 * 00010b - version 2, supporting CEA version
 +				 *			861D or below
 +				 * 00011b:11111b - reserved
 +				 * for future
 +				 */
 +			};
 +		};
 +
 +		/* Byte[1] = Vendor Version Field */
 +		union {
 +			unsigned char vendor_version;
 +			struct {
 +				unsigned char reserved1:3;
 +				unsigned char veld_ver:5; /* Version number of the ELD
 +						     * extension. This value is
 +						     * provisioned and unique to
 +						     * each vendor.
 +						     */
 +			};
 +		};
 +
 +		/* Byte[2] = Baseline Length field */
 +		unsigned char baseline_eld_length; /* Length of the Baseline structure
 +					      *	divided by Four.
 +					      */
 +
 +		/* Byte [3] = Reserved for future use */
 +		unsigned char byte3;
 +
 +		/* Starting of the BaseLine EELD structure
 +		 * Byte[4] = Monitor Name Length
 +		 */
 +		union {
 +			unsigned char byte4;
 +			struct {
 +				unsigned char mnl:5;
 +				unsigned char cea_edid_rev_id:3;
 +			};
 +		};
 +
 +		/* Byte[5] = Capabilities */
 +		union {
 +			unsigned char capabilities;
 +			struct {
 +				unsigned char hdcp:1; /* HDCP support */
 +				unsigned char ai_support:1;   /* AI support */
 +				unsigned char connection_type:2; /* Connection type
 +							    * 00 - HDMI
 +							    * 01 - DP
 +							    * 10 -11  Reserved
 +							    * for future
 +							    * connection types
 +							    */
 +				unsigned char sadc:4; /* Indicates number of 3 bytes
 +						 * Short Audio Descriptors.
 +						 */
 +			};
 +		};
 +
 +		/* Byte[6] = Audio Synch Delay */
 +		unsigned char audio_synch_delay; /* Amount of time reported by the
 +					    * sink that the video trails audio
 +					    * in milliseconds.
 +					    */
 +
 +		/* Byte[7] = Speaker Allocation Block */
 +		union {
 +			unsigned char speaker_allocation_block;
 +			struct {
 +				unsigned char flr:1; /*Front Left and Right channels*/
 +				unsigned char lfe:1; /*Low Frequency Effect channel*/
 +				unsigned char fc:1;  /*Center transmission channel*/
 +				unsigned char rlr:1; /*Rear Left and Right channels*/
 +				unsigned char rc:1; /*Rear Center channel*/
 +				unsigned char flrc:1; /*Front left and Right of Center
 +						 *transmission channels
 +						 */
 +				unsigned char rlrc:1; /*Rear left and Right of Center
 +						 *transmission channels
 +						 */
 +				unsigned char reserved3:1; /* Reserved */
 +			};
 +		};
 +
 +		/* Byte[8 - 15] - 8 Byte port identification value */
 +		unsigned char port_id_value[8];
 +
 +		/* Byte[16 - 17] - 2 Byte Manufacturer ID */
 +		unsigned char manufacturer_id[2];
 +
 +		/* Byte[18 - 19] - 2 Byte Product ID */
 +		unsigned char product_id[2];
 +
 +		/* Byte [20-83] - 64 Bytes of BaseLine Data */
 +		unsigned char mn_sand_sads[64]; /* This will include
 +					   * - ASCII string of Monitor name
 +					   * - List of 3 byte SADs
 +					   * - Zero padding
 +					   */
 +
 +		/* Vendor ELD Block should continue here!
 +		 * No Vendor ELD block defined as of now.
 +		 */
 +	} __packed;
 +};
 +
 +/**
 + * enum had_status - Audio stream states
 + *
 + * @STREAM_INIT: Stream initialized
 + * @STREAM_RUNNING: Stream running
 + * @STREAM_PAUSED: Stream paused
 + * @STREAM_DROPPED: Stream dropped
 + */
 +enum had_stream_status {
 +	STREAM_INIT = 0,
 +	STREAM_RUNNING = 1,
 +	STREAM_PAUSED = 2,
 +	STREAM_DROPPED = 3
 +};
 +
 +/**
 + * enum had_status_stream - HAD stream states
 + */
 +enum had_status_stream {
 +	HAD_INIT = 0,
 +	HAD_RUNNING_STREAM,
 +};
 +
 +enum had_drv_status {
 +	HAD_DRV_CONNECTED,
 +	HAD_DRV_RUNNING,
 +	HAD_DRV_DISCONNECTED,
 +	HAD_DRV_SUSPENDED,
 +	HAD_DRV_ERR,
 +};
 +
 +/* enum intel_had_aud_buf_type - HDMI controller ring buffer types */
 +enum intel_had_aud_buf_type {
 +	HAD_BUF_TYPE_A = 0,
 +	HAD_BUF_TYPE_B = 1,
 +	HAD_BUF_TYPE_C = 2,
 +	HAD_BUF_TYPE_D = 3,
 +};
 +
 +enum num_aud_ch {
 +	CH_STEREO = 0,
 +	CH_THREE_FOUR = 1,
 +	CH_FIVE_SIX = 2,
 +	CH_SEVEN_EIGHT = 3
 +};
 +
++=======
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  /* HDMI Controller register offsets - audio domain common */
  /* Base address for below regs = 0x65000 */
  enum hdmi_ctrl_reg_offset_common {
@@@ -502,17 -262,14 +505,24 @@@ union aud_buf_addr 
  		u32 intr_en:1;
  		u32 rsvd:4;
  		u32 addr:26;
 -	} regx;
 -	u32 regval;
 +	} buf_addr_regx;
 +	u32 buf_addr_val;
  };
  
++<<<<<<< HEAD
 +/**
 + * union aud_buf_len - Length of Audio Buffer
 + *
 + * @buf_len_regx: individual register bits
 + * @buf_len_val: full register value
 + *
 + */
++=======
+ #define AUD_BUF_VALID		(1U << 0)
+ #define AUD_BUF_INTR_EN		(1U << 1)
+ 
+ /* Length of Audio Buffer */
++>>>>>>> e1b239f371c0 (ALSA: x86: Refactor PCM process engine)
  union aud_buf_len {
  	struct {
  		u32 buf_len:20;
* Unmerged path sound/x86/intel_hdmi_audio.c
* Unmerged path sound/x86/intel_hdmi_audio.h
* Unmerged path sound/x86/intel_hdmi_lpe_audio.h
