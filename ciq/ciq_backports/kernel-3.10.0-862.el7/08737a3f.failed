qed: Inform qedi the number of possible CQs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 08737a3fa30a4c6c10b4c4b682125c7d3c494094
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/08737a3f.failed

Now that management firmware is capable of telling us the number of CQs
available for a given PF, qed needs to communicate the number to qedi
so it would know have many to use.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 08737a3fa30a4c6c10b4c4b682125c7d3c494094)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index 2707a33de744,fad73195010d..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -1558,84 -2021,157 +1558,97 @@@ static void qed_hw_set_feat(struct qed_
  		 * the status blocks equally between L2 / RoCE but with
  		 * consideration as to how many l2 queues / cnqs we have.
  		 */
 +		num_features++;
 +
  		feat_num[QED_RDMA_CNQ] =
 -			min_t(u32, RESC_NUM(p_hwfn, QED_SB) / 2,
 +			min_t(u32, RESC_NUM(p_hwfn, QED_SB) / num_features,
  			      RESC_NUM(p_hwfn, QED_RDMA_CNQ_RAM));
 -
 -		non_l2_sbs = feat_num[QED_RDMA_CNQ];
  	}
  
 -	if (p_hwfn->hw_info.personality == QED_PCI_ETH_ROCE ||
 -	    p_hwfn->hw_info.personality == QED_PCI_ETH) {
 -		/* Start by allocating VF queues, then PF's */
 -		memset(&sb_cnt_info, 0, sizeof(sb_cnt_info));
 -		qed_int_get_num_sbs(p_hwfn, &sb_cnt_info);
 -		feat_num[QED_VF_L2_QUE] = min_t(u32,
 -						RESC_NUM(p_hwfn, QED_L2_QUEUE),
 -						sb_cnt_info.sb_iov_cnt);
 -		feat_num[QED_PF_L2_QUE] = min_t(u32,
 -						RESC_NUM(p_hwfn, QED_SB) -
 -						non_l2_sbs,
 -						RESC_NUM(p_hwfn,
 -							 QED_L2_QUEUE) -
 -						FEAT_NUM(p_hwfn,
 -							 QED_VF_L2_QUE));
 -	}
 +	feat_num[QED_PF_L2_QUE] = min_t(u32, RESC_NUM(p_hwfn, QED_SB) /
 +						num_features,
 +					RESC_NUM(p_hwfn, QED_L2_QUEUE));
 +
 +	memset(&sb_cnt_info, 0, sizeof(sb_cnt_info));
 +	qed_int_get_num_sbs(p_hwfn, &sb_cnt_info);
 +	feat_num[QED_VF_L2_QUE] =
 +	    min_t(u32,
 +		  RESC_NUM(p_hwfn, QED_L2_QUEUE) -
 +		  FEAT_NUM(p_hwfn, QED_PF_L2_QUE), sb_cnt_info.sb_iov_cnt);
  
+ 	if (p_hwfn->hw_info.personality == QED_PCI_ISCSI)
+ 		feat_num[QED_ISCSI_CQ] = min_t(u32, RESC_NUM(p_hwfn, QED_SB),
+ 					       RESC_NUM(p_hwfn,
+ 							QED_CMDQS_CQS));
  	DP_VERBOSE(p_hwfn,
  		   NETIF_MSG_PROBE,
++<<<<<<< HEAD
 +		   "#PF_L2_QUEUES=%d VF_L2_QUEUES=%d #ROCE_CNQ=%d #SBS=%d num_features=%d\n",
 +		   (int)FEAT_NUM(p_hwfn, QED_PF_L2_QUE),
 +		   (int)FEAT_NUM(p_hwfn, QED_VF_L2_QUE),
 +		   (int)FEAT_NUM(p_hwfn, QED_RDMA_CNQ),
 +		   RESC_NUM(p_hwfn, QED_SB), num_features);
++=======
+ 		   "#PF_L2_QUEUES=%d VF_L2_QUEUES=%d #ROCE_CNQ=%d ISCSI_CQ=%d #SBS=%d\n",
+ 		   (int)FEAT_NUM(p_hwfn, QED_PF_L2_QUE),
+ 		   (int)FEAT_NUM(p_hwfn, QED_VF_L2_QUE),
+ 		   (int)FEAT_NUM(p_hwfn, QED_RDMA_CNQ),
+ 		   (int)FEAT_NUM(p_hwfn, QED_ISCSI_CQ),
+ 		   RESC_NUM(p_hwfn, QED_SB));
++>>>>>>> 08737a3fa30a (qed: Inform qedi the number of possible CQs)
  }
  
 -const char *qed_hw_get_resc_name(enum qed_resources res_id)
 +static enum resource_id_enum qed_hw_get_mfw_res_id(enum qed_resources res_id)
  {
 +	enum resource_id_enum mfw_res_id = RESOURCE_NUM_INVALID;
 +
  	switch (res_id) {
 +	case QED_SB:
 +		mfw_res_id = RESOURCE_NUM_SB_E;
 +		break;
  	case QED_L2_QUEUE:
 -		return "L2_QUEUE";
 +		mfw_res_id = RESOURCE_NUM_L2_QUEUE_E;
 +		break;
  	case QED_VPORT:
 -		return "VPORT";
 +		mfw_res_id = RESOURCE_NUM_VPORT_E;
 +		break;
  	case QED_RSS_ENG:
 -		return "RSS_ENG";
 +		mfw_res_id = RESOURCE_NUM_RSS_ENGINES_E;
 +		break;
  	case QED_PQ:
 -		return "PQ";
 +		mfw_res_id = RESOURCE_NUM_PQ_E;
 +		break;
  	case QED_RL:
 -		return "RL";
 +		mfw_res_id = RESOURCE_NUM_RL_E;
 +		break;
  	case QED_MAC:
 -		return "MAC";
  	case QED_VLAN:
 -		return "VLAN";
 -	case QED_RDMA_CNQ_RAM:
 -		return "RDMA_CNQ_RAM";
 +		/* Each VFC resource can accommodate both a MAC and a VLAN */
 +		mfw_res_id = RESOURCE_VFC_FILTER_E;
 +		break;
  	case QED_ILT:
 -		return "ILT";
 +		mfw_res_id = RESOURCE_ILT_E;
 +		break;
  	case QED_LL2_QUEUE:
 -		return "LL2_QUEUE";
 +		mfw_res_id = RESOURCE_LL2_QUEUE_E;
 +		break;
 +	case QED_RDMA_CNQ_RAM:
  	case QED_CMDQS_CQS:
 -		return "CMDQS_CQS";
 +		/* CNQ/CMDQS are the same resource */
 +		mfw_res_id = RESOURCE_CQS_E;
 +		break;
  	case QED_RDMA_STATS_QUEUE:
 -		return "RDMA_STATS_QUEUE";
 -	case QED_BDQ:
 -		return "BDQ";
 -	case QED_SB:
 -		return "SB";
 +		mfw_res_id = RESOURCE_RDMA_STATS_QUEUE_E;
 +		break;
  	default:
 -		return "UNKNOWN_RESOURCE";
 -	}
 -}
 -
 -static int
 -__qed_hw_set_soft_resc_size(struct qed_hwfn *p_hwfn,
 -			    struct qed_ptt *p_ptt,
 -			    enum qed_resources res_id,
 -			    u32 resc_max_val, u32 *p_mcp_resp)
 -{
 -	int rc;
 -
 -	rc = qed_mcp_set_resc_max_val(p_hwfn, p_ptt, res_id,
 -				      resc_max_val, p_mcp_resp);
 -	if (rc) {
 -		DP_NOTICE(p_hwfn,
 -			  "MFW response failure for a max value setting of resource %d [%s]\n",
 -			  res_id, qed_hw_get_resc_name(res_id));
 -		return rc;
 -	}
 -
 -	if (*p_mcp_resp != FW_MSG_CODE_RESOURCE_ALLOC_OK)
 -		DP_INFO(p_hwfn,
 -			"Failed to set the max value of resource %d [%s]. mcp_resp = 0x%08x.\n",
 -			res_id, qed_hw_get_resc_name(res_id), *p_mcp_resp);
 -
 -	return 0;
 -}
 -
 -static int
 -qed_hw_set_soft_resc_size(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)
 -{
 -	bool b_ah = QED_IS_AH(p_hwfn->cdev);
 -	u32 resc_max_val, mcp_resp;
 -	u8 res_id;
 -	int rc;
 -
 -	for (res_id = 0; res_id < QED_MAX_RESC; res_id++) {
 -		switch (res_id) {
 -		case QED_LL2_QUEUE:
 -			resc_max_val = MAX_NUM_LL2_RX_QUEUES;
 -			break;
 -		case QED_RDMA_CNQ_RAM:
 -			/* No need for a case for QED_CMDQS_CQS since
 -			 * CNQ/CMDQS are the same resource.
 -			 */
 -			resc_max_val = NUM_OF_CMDQS_CQS;
 -			break;
 -		case QED_RDMA_STATS_QUEUE:
 -			resc_max_val = b_ah ? RDMA_NUM_STATISTIC_COUNTERS_K2
 -			    : RDMA_NUM_STATISTIC_COUNTERS_BB;
 -			break;
 -		case QED_BDQ:
 -			resc_max_val = BDQ_NUM_RESOURCES;
 -			break;
 -		default:
 -			continue;
 -		}
 -
 -		rc = __qed_hw_set_soft_resc_size(p_hwfn, p_ptt, res_id,
 -						 resc_max_val, &mcp_resp);
 -		if (rc)
 -			return rc;
 -
 -		/* There's no point to continue to the next resource if the
 -		 * command is not supported by the MFW.
 -		 * We do continue if the command is supported but the resource
 -		 * is unknown to the MFW. Such a resource will be later
 -		 * configured with the default allocation values.
 -		 */
 -		if (mcp_resp == FW_MSG_CODE_UNSUPPORTED)
 -			return -EINVAL;
 +		break;
  	}
  
 -	return 0;
 +	return mfw_res_id;
  }
  
 -static
 -int qed_hw_get_dflt_resc(struct qed_hwfn *p_hwfn,
 -			 enum qed_resources res_id,
 -			 u32 *p_resc_num, u32 *p_resc_start)
 +static u32 qed_hw_get_dflt_resc_num(struct qed_hwfn *p_hwfn,
 +				    enum qed_resources res_id)
  {
  	u8 num_funcs = p_hwfn->num_funcs_on_engine;
  	bool b_ah = QED_IS_AH(p_hwfn->cdev);
diff --git a/drivers/net/ethernet/qlogic/qed/qed.h b/drivers/net/ethernet/qlogic/qed/qed.h
index 6591763f4695..75fb91f63140 100644
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@ -205,8 +205,9 @@ enum QED_FEATURE {
 	QED_PF_L2_QUE,
 	QED_VF,
 	QED_RDMA_CNQ,
-	QED_VF_L2_QUE,
+	QED_ISCSI_CQ,
 	QED_FCOE_CQ,
+	QED_VF_L2_QUE,
 	QED_MAX_FEATURES,
 };
 
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_iscsi.c b/drivers/net/ethernet/qlogic/qed/qed_iscsi.c
index 163f3eed4ed7..98e89f48335e 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_iscsi.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_iscsi.c
@@ -181,6 +181,15 @@ qed_sp_iscsi_func_start(struct qed_hwfn *p_hwfn,
 	p_params = &p_hwfn->pf_params.iscsi_pf_params;
 	p_queue = &p_init->q_params;
 
+	/* Sanity */
+	if (p_params->num_queues > p_hwfn->hw_info.feat_num[QED_ISCSI_CQ]) {
+		DP_ERR(p_hwfn,
+		       "Cannot satisfy CQ amount. Queues requested %d, CQs available %d. Aborting function start\n",
+		       p_params->num_queues,
+		       p_hwfn->hw_info.resc_num[QED_ISCSI_CQ]);
+		return -EINVAL;
+	}
+
 	SET_FIELD(p_init->hdr.flags,
 		  ISCSI_SLOW_PATH_HDR_LAYER_CODE, ISCSI_SLOW_PATH_LAYER_CODE);
 	p_init->hdr.op_code = ISCSI_RAMROD_CMD_ID_INIT_FUNC;
@@ -975,6 +984,8 @@ static int qed_fill_iscsi_dev_info(struct qed_dev *cdev,
 	info->secondary_bdq_rq_addr =
 	    qed_iscsi_get_secondary_bdq_prod(hwfn, BDQ_ID_RQ);
 
+	info->num_cqs = FEAT_NUM(hwfn, QED_ISCSI_CQ);
+
 	return rc;
 }
 
diff --git a/include/linux/qed/qed_iscsi_if.h b/include/linux/qed/qed_iscsi_if.h
index f70bb81b8b6a..3414649133d2 100644
--- a/include/linux/qed/qed_iscsi_if.h
+++ b/include/linux/qed/qed_iscsi_if.h
@@ -67,6 +67,8 @@ struct qed_dev_iscsi_info {
 
 	void __iomem *primary_dbq_rq_addr;
 	void __iomem *secondary_bdq_rq_addr;
+
+	u8 num_cqs;
 };
 
 struct qed_iscsi_id_params {
