openvswitch: Pack struct sw_flow_key.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] openvswitch: Pack struct sw_flow_key (Jiri Benc) [1497774]
Rebuild_FUZZ: 98.63%
commit-author Jarno Rajahalme <jarno@ovn.org>
commit 316d4d78cf9b6795b83f97c45368748741df418c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/316d4d78.failed

struct sw_flow_key has two 16-bit holes. Move the most matched
conntrack match fields there.  In some typical cases this reduces the
size of the key that needs to be hashed into half and into one cache
line.

	Signed-off-by: Jarno Rajahalme <jarno@ovn.org>
	Acked-by: Joe Stringer <joe@ovn.org>
	Acked-by: Pravin B Shelar <pshelar@ovn.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 316d4d78cf9b6795b83f97c45368748741df418c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/conntrack.c
#	net/openvswitch/conntrack.h
#	net/openvswitch/flow.h
#	net/openvswitch/flow_netlink.c
diff --cc net/openvswitch/conntrack.c
index a817d2fd90cf,c2d452eab0c5..000000000000
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@@ -147,17 -148,60 +147,66 @@@ static void ovs_ct_get_labels(const str
  		memset(labels, 0, OVS_CT_LABELS_LEN);
  }
  
++<<<<<<< HEAD
++=======
+ static void __ovs_ct_update_key_orig_tp(struct sw_flow_key *key,
+ 					const struct nf_conntrack_tuple *orig,
+ 					u8 icmp_proto)
+ {
+ 	key->ct_orig_proto = orig->dst.protonum;
+ 	if (orig->dst.protonum == icmp_proto) {
+ 		key->ct.orig_tp.src = htons(orig->dst.u.icmp.type);
+ 		key->ct.orig_tp.dst = htons(orig->dst.u.icmp.code);
+ 	} else {
+ 		key->ct.orig_tp.src = orig->src.u.all;
+ 		key->ct.orig_tp.dst = orig->dst.u.all;
+ 	}
+ }
+ 
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  static void __ovs_ct_update_key(struct sw_flow_key *key, u8 state,
  				const struct nf_conntrack_zone *zone,
  				const struct nf_conn *ct)
  {
- 	key->ct.state = state;
- 	key->ct.zone = zone->id;
+ 	key->ct_state = state;
+ 	key->ct_zone = zone->id;
  	key->ct.mark = ovs_ct_get_mark(ct);
  	ovs_ct_get_labels(ct, &key->ct.labels);
++<<<<<<< HEAD
++=======
+ 
+ 	if (ct) {
+ 		const struct nf_conntrack_tuple *orig;
+ 
+ 		/* Use the master if we have one. */
+ 		if (ct->master)
+ 			ct = ct->master;
+ 		orig = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
+ 
+ 		/* IP version must match with the master connection. */
+ 		if (key->eth.type == htons(ETH_P_IP) &&
+ 		    nf_ct_l3num(ct) == NFPROTO_IPV4) {
+ 			key->ipv4.ct_orig.src = orig->src.u3.ip;
+ 			key->ipv4.ct_orig.dst = orig->dst.u3.ip;
+ 			__ovs_ct_update_key_orig_tp(key, orig, IPPROTO_ICMP);
+ 			return;
+ 		} else if (key->eth.type == htons(ETH_P_IPV6) &&
+ 			   !sw_flow_key_is_nd(key) &&
+ 			   nf_ct_l3num(ct) == NFPROTO_IPV6) {
+ 			key->ipv6.ct_orig.src = orig->src.u3.in6;
+ 			key->ipv6.ct_orig.dst = orig->dst.u3.in6;
+ 			__ovs_ct_update_key_orig_tp(key, orig, NEXTHDR_ICMP);
+ 			return;
+ 		}
+ 	}
+ 	/* Clear 'ct_orig_proto' to mark the non-existence of conntrack
+ 	 * original direction key fields.
+ 	 */
+ 	key->ct_orig_proto = 0;
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  }
  
 -/* Update 'key' based on skb->_nfct.  If 'post_ct' is true, then OVS has
 +/* Update 'key' based on skb->nfct.  If 'post_ct' is true, then OVS has
   * previously sent the packet to conntrack via the ct action.  If
   * 'keep_nat_flags' is true, the existing NAT flags retained, else they are
   * initialized from the connection status.
@@@ -208,13 -252,18 +257,21 @@@ void ovs_ct_fill_key(const struct sk_bu
  	ovs_ct_update_key(skb, NULL, key, false, false);
  }
  
 -#define IN6_ADDR_INITIALIZER(ADDR) \
 -	{ (ADDR).s6_addr32[0], (ADDR).s6_addr32[1], \
 -	  (ADDR).s6_addr32[2], (ADDR).s6_addr32[3] }
 -
 -int ovs_ct_put_key(const struct sw_flow_key *swkey,
 -		   const struct sw_flow_key *output, struct sk_buff *skb)
 +int ovs_ct_put_key(const struct sw_flow_key *key, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	if (nla_put_u32(skb, OVS_KEY_ATTR_CT_STATE, key->ct.state))
 +		return -EMSGSIZE;
 +
 +	if (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&
 +	    nla_put_u16(skb, OVS_KEY_ATTR_CT_ZONE, key->ct.zone))
++=======
+ 	if (nla_put_u32(skb, OVS_KEY_ATTR_CT_STATE, output->ct_state))
+ 		return -EMSGSIZE;
+ 
+ 	if (IS_ENABLED(CONFIG_NF_CONNTRACK_ZONES) &&
+ 	    nla_put_u16(skb, OVS_KEY_ATTR_CT_ZONE, output->ct_zone))
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  		return -EMSGSIZE;
  
  	if (IS_ENABLED(CONFIG_NF_CONNTRACK_MARK) &&
@@@ -222,10 -271,36 +279,39 @@@
  		return -EMSGSIZE;
  
  	if (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&
 -	    nla_put(skb, OVS_KEY_ATTR_CT_LABELS, sizeof(output->ct.labels),
 -		    &output->ct.labels))
 +	    nla_put(skb, OVS_KEY_ATTR_CT_LABELS, sizeof(key->ct.labels),
 +		    &key->ct.labels))
  		return -EMSGSIZE;
  
++<<<<<<< HEAD
++=======
+ 	if (swkey->ct_orig_proto) {
+ 		if (swkey->eth.type == htons(ETH_P_IP)) {
+ 			struct ovs_key_ct_tuple_ipv4 orig = {
+ 				output->ipv4.ct_orig.src,
+ 				output->ipv4.ct_orig.dst,
+ 				output->ct.orig_tp.src,
+ 				output->ct.orig_tp.dst,
+ 				output->ct_orig_proto,
+ 			};
+ 			if (nla_put(skb, OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4,
+ 				    sizeof(orig), &orig))
+ 				return -EMSGSIZE;
+ 		} else if (swkey->eth.type == htons(ETH_P_IPV6)) {
+ 			struct ovs_key_ct_tuple_ipv6 orig = {
+ 				IN6_ADDR_INITIALIZER(output->ipv6.ct_orig.src),
+ 				IN6_ADDR_INITIALIZER(output->ipv6.ct_orig.dst),
+ 				output->ct.orig_tp.src,
+ 				output->ct.orig_tp.dst,
+ 				output->ct_orig_proto,
+ 			};
+ 			if (nla_put(skb, OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6,
+ 				    sizeof(orig), &orig))
+ 				return -EMSGSIZE;
+ 		}
+ 	}
+ 
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  	return 0;
  }
  
@@@ -531,10 -612,15 +617,22 @@@ static bool skb_nfct_cached(struct net 
  	 * due to an upcall.  If the connection was not confirmed, it is not
  	 * cached and needs to be run through conntrack again.
  	 */
++<<<<<<< HEAD
 +	if (!ct && key->ct.state & OVS_CS_F_TRACKED &&
 +	    !(key->ct.state & OVS_CS_F_INVALID) &&
 +	    key->ct.zone == info->zone.id)
 +		ct = ovs_ct_find_existing(net, &info->zone, info->family, skb);
++=======
+ 	if (!ct && key->ct_state & OVS_CS_F_TRACKED &&
+ 	    !(key->ct_state & OVS_CS_F_INVALID) &&
+ 	    key->ct_zone == info->zone.id) {
+ 		ct = ovs_ct_find_existing(net, &info->zone, info->family, skb,
+ 					  !!(key->ct_state
+ 					     & OVS_CS_F_NAT_MASK));
+ 		if (ct)
+ 			nf_ct_get(skb, &ctinfo);
+ 	}
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  	if (!ct)
  		return false;
  	if (!net_eq(net, read_pnet(&ct->ct_net)))
diff --cc net/openvswitch/conntrack.h
index 8f6230bd6183,bc7efd1867ab..000000000000
--- a/net/openvswitch/conntrack.h
+++ b/net/openvswitch/conntrack.h
@@@ -75,13 -76,18 +75,20 @@@ static inline int ovs_ct_execute(struc
  static inline void ovs_ct_fill_key(const struct sk_buff *skb,
  				   struct sw_flow_key *key)
  {
- 	key->ct.state = 0;
- 	key->ct.zone = 0;
+ 	key->ct_state = 0;
+ 	key->ct_zone = 0;
  	key->ct.mark = 0;
  	memset(&key->ct.labels, 0, sizeof(key->ct.labels));
++<<<<<<< HEAD
++=======
+ 	/* Clear 'ct_orig_proto' to mark the non-existence of original
+ 	 * direction key fields.
+ 	 */
+ 	key->ct_orig_proto = 0;
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  }
  
 -static inline int ovs_ct_put_key(const struct sw_flow_key *swkey,
 -				 const struct sw_flow_key *output,
 +static inline int ovs_ct_put_key(const struct sw_flow_key *key,
  				 struct sk_buff *skb)
  {
  	return 0;
diff --cc net/openvswitch/flow.h
index e8d49bec2ea0,a9bc1c875965..000000000000
--- a/net/openvswitch/flow.h
+++ b/net/openvswitch/flow.h
@@@ -119,10 -144,12 +125,19 @@@ struct sw_flow_key 
  		} ipv6;
  	};
  	struct {
++<<<<<<< HEAD
 +		/* Connection tracking fields. */
 +		u16 zone;
 +		u32 mark;
 +		u8 state;
++=======
+ 		/* Connection tracking fields not packed above. */
+ 		struct {
+ 			__be16 src;	/* CT orig tuple tp src port. */
+ 			__be16 dst;	/* CT orig tuple tp dst port. */
+ 		} orig_tp;
+ 		u32 mark;
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  		struct ovs_key_ct_labels labels;
  	} ct;
  
diff --cc net/openvswitch/flow_netlink.c
index 559c659f3ff6,6f5fa50f716d..000000000000
--- a/net/openvswitch/flow_netlink.c
+++ b/net/openvswitch/flow_netlink.c
@@@ -1059,6 -1098,49 +1059,52 @@@ static int metadata_from_nlattrs(struc
  				   sizeof(*cl), is_mask);
  		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);
  	}
++<<<<<<< HEAD
++=======
+ 	if (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4)) {
+ 		const struct ovs_key_ct_tuple_ipv4 *ct;
+ 
+ 		ct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4]);
+ 
+ 		SW_FLOW_KEY_PUT(match, ipv4.ct_orig.src, ct->ipv4_src, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ipv4.ct_orig.dst, ct->ipv4_dst, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct_orig_proto, ct->ipv4_proto, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4);
+ 	}
+ 	if (*attrs & (1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6)) {
+ 		const struct ovs_key_ct_tuple_ipv6 *ct;
+ 
+ 		ct = nla_data(a[OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6]);
+ 
+ 		SW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.src, &ct->ipv6_src,
+ 				   sizeof(match->key->ipv6.ct_orig.src),
+ 				   is_mask);
+ 		SW_FLOW_KEY_MEMCPY(match, ipv6.ct_orig.dst, &ct->ipv6_dst,
+ 				   sizeof(match->key->ipv6.ct_orig.dst),
+ 				   is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.src, ct->src_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct.orig_tp.dst, ct->dst_port, is_mask);
+ 		SW_FLOW_KEY_PUT(match, ct_orig_proto, ct->ipv6_proto, is_mask);
+ 		*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6);
+ 	}
+ 
+ 	/* For layer 3 packets the Ethernet type is provided
+ 	 * and treated as metadata but no MAC addresses are provided.
+ 	 */
+ 	if (!(*attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&
+ 	    (*attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)))
+ 		mac_proto = MAC_PROTO_NONE;
+ 
+ 	/* Always exact match mac_proto */
+ 	SW_FLOW_KEY_PUT(match, mac_proto, is_mask ? 0xff : mac_proto, is_mask);
+ 
+ 	if (mac_proto == MAC_PROTO_NONE)
+ 		return parse_eth_type_from_nlattrs(match, attrs, a, is_mask,
+ 						   log);
+ 
++>>>>>>> 316d4d78cf9b (openvswitch: Pack struct sw_flow_key.)
  	return 0;
  }
  
@@@ -1491,7 -1564,13 +1537,10 @@@ int ovs_nla_get_flow_metadata(struct ne
  	memset(&match, 0, sizeof(match));
  	match.key = key;
  
+ 	key->ct_state = 0;
+ 	key->ct_zone = 0;
+ 	key->ct_orig_proto = 0;
  	memset(&key->ct, 0, sizeof(key->ct));
 -	memset(&key->ipv4.ct_orig, 0, sizeof(key->ipv4.ct_orig));
 -	memset(&key->ipv6.ct_orig, 0, sizeof(key->ipv6.ct_orig));
 -
  	key->phy.in_port = DP_MAX_PORTS;
  
  	return metadata_from_nlattrs(net, &match, &attrs, a, false, log);
* Unmerged path net/openvswitch/conntrack.c
* Unmerged path net/openvswitch/conntrack.h
* Unmerged path net/openvswitch/flow.h
* Unmerged path net/openvswitch/flow_netlink.c
