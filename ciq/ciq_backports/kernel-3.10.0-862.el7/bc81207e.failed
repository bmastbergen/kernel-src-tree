rbd: factor out __rbd_osd_req_create()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit bc81207ea9fc01896cbc102f025f1ebb2c4bae1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bc81207e.failed

Factor OSD request allocation and initialization code out into
__rbd_osd_req_create().

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit bc81207ea9fc01896cbc102f025f1ebb2c4bae1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index 358a3ccd90aa,b44b457b4dc7..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -2005,35 -2011,10 +2035,42 @@@ static struct ceph_osd_request *rbd_osd
  
  	rbd_assert(num_ops == 1 || ((op_type == OBJ_OP_WRITE) && num_ops == 2));
  
++<<<<<<< HEAD
 +	/* Allocate and initialize the request, for the num_ops ops */
 +
 +	osdc = &rbd_dev->rbd_client->client->osdc;
 +	osd_req = ceph_osdc_alloc_request(osdc, snapc, num_ops, false,
 +					  GFP_NOIO);
 +	if (!osd_req)
 +		goto fail;
 +
 +	if (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD)
 +		osd_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
 +	else
 +		osd_req->r_flags = CEPH_OSD_FLAG_READ;
 +
 +	osd_req->r_callback = rbd_osd_req_callback;
 +	osd_req->r_priv = obj_request;
 +
 +	osd_req->r_base_oloc.pool = ceph_file_layout_pg_pool(rbd_dev->layout);
 +	if (ceph_oid_aprintf(&osd_req->r_base_oid, GFP_NOIO, "%s",
 +			     obj_request->object_name))
 +		goto fail;
 +
 +	if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
 +		goto fail;
 +
 +	return osd_req;
 +
 +fail:
 +	ceph_osdc_put_request(osd_req);
 +	return NULL;
++=======
+ 	return __rbd_osd_req_create(rbd_dev, snapc, num_ops,
+ 	    (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD) ?
+ 	    CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK : CEPH_OSD_FLAG_READ,
+ 	    obj_request);
++>>>>>>> bc81207ea9fc (rbd: factor out __rbd_osd_req_create())
  }
  
  /*
@@@ -2061,36 -2038,12 +2094,42 @@@ rbd_osd_req_create_copyup(struct rbd_ob
  	if (img_request_discard_test(img_request))
  		num_osd_ops = 2;
  
++<<<<<<< HEAD
 +	/* Allocate and initialize the request, for all the ops */
 +
 +	snapc = img_request->snapc;
 +	rbd_dev = img_request->rbd_dev;
 +	osdc = &rbd_dev->rbd_client->client->osdc;
 +	osd_req = ceph_osdc_alloc_request(osdc, snapc, num_osd_ops,
 +						false, GFP_NOIO);
 +	if (!osd_req)
 +		goto fail;
 +
 +	osd_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
 +	osd_req->r_callback = rbd_osd_req_callback;
 +	osd_req->r_priv = obj_request;
 +
 +	osd_req->r_base_oloc.pool = ceph_file_layout_pg_pool(rbd_dev->layout);
 +	if (ceph_oid_aprintf(&osd_req->r_base_oid, GFP_NOIO, "%s",
 +			     obj_request->object_name))
 +		goto fail;
 +
 +	if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
 +		goto fail;
 +
 +	return osd_req;
 +
 +fail:
 +	ceph_osdc_put_request(osd_req);
 +	return NULL;
++=======
+ 	return __rbd_osd_req_create(img_request->rbd_dev,
+ 				    img_request->snapc, num_osd_ops,
+ 				    CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK,
+ 				    obj_request);
++>>>>>>> bc81207ea9fc (rbd: factor out __rbd_osd_req_create())
  }
  
- 
  static void rbd_osd_req_destroy(struct ceph_osd_request *osd_req)
  {
  	ceph_osdc_put_request(osd_req);
* Unmerged path drivers/block/rbd.c
