ibmvnic: Create init/release routines for stats token

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit 7bbc27a4961a7d5f8e4294929ce64d6c6e81e90c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/7bbc27a4.failed

Create an initialization and a release routine for the stats token used by
the ibmvnic driver.

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7bbc27a4961a7d5f8e4294929ce64d6c6e81e90c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index 6a325c61534d,a2f972d72e34..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -347,28 -302,70 +347,62 @@@ static void replenish_pools(struct ibmv
  	}
  }
  
++<<<<<<< HEAD
 +static void free_rx_pool(struct ibmvnic_adapter *adapter,
 +			 struct ibmvnic_rx_pool *pool)
++=======
+ static void release_stats_token(struct ibmvnic_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->vdev->dev;
+ 
+ 	if (!adapter->stats_token)
+ 		return;
+ 
+ 	dma_unmap_single(dev, adapter->stats_token,
+ 			 sizeof(struct ibmvnic_statistics),
+ 			 DMA_FROM_DEVICE);
+ 	adapter->stats_token = 0;
+ }
+ 
+ static int init_stats_token(struct ibmvnic_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->vdev->dev;
+ 	dma_addr_t stok;
+ 
+ 	stok = dma_map_single(dev, &adapter->stats,
+ 			      sizeof(struct ibmvnic_statistics),
+ 			      DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(dev, stok)) {
+ 		dev_err(dev, "Couldn't map stats buffer\n");
+ 		return -1;
+ 	}
+ 
+ 	adapter->stats_token = stok;
+ 	return 0;
+ }
+ 
+ static void release_rx_pools(struct ibmvnic_adapter *adapter)
++>>>>>>> 7bbc27a4961a (ibmvnic: Create init/release routines for stats token)
  {
 -	struct ibmvnic_rx_pool *rx_pool;
 -	int rx_scrqs;
 -	int i, j;
 -
 -	if (!adapter->rx_pool)
 -		return;
 -
 -	rx_scrqs = be32_to_cpu(adapter->login_rsp_buf->num_rxadd_subcrqs);
 -	for (i = 0; i < rx_scrqs; i++) {
 -		rx_pool = &adapter->rx_pool[i];
 +	int i;
  
 -		kfree(rx_pool->free_map);
 -		free_long_term_buff(adapter, &rx_pool->long_term_buff);
 +	kfree(pool->free_map);
 +	pool->free_map = NULL;
  
 -		if (!rx_pool->rx_buff)
 -		continue;
 +	if (!pool->rx_buff)
 +		return;
  
 -		for (j = 0; j < rx_pool->size; j++) {
 -			if (rx_pool->rx_buff[j].skb) {
 -				dev_kfree_skb_any(rx_pool->rx_buff[i].skb);
 -				rx_pool->rx_buff[i].skb = NULL;
 -			}
 +	for (i = 0; i < pool->size; i++) {
 +		if (pool->rx_buff[i].skb) {
 +			dev_kfree_skb_any(pool->rx_buff[i].skb);
 +			pool->rx_buff[i].skb = NULL;
  		}
 -
 -		kfree(rx_pool->rx_buff);
  	}
 -
 -	kfree(adapter->rx_pool);
 -	adapter->rx_pool = NULL;
 +	kfree(pool->rx_buff);
 +	pool->rx_buff = NULL;
  }
  
 -static int init_rx_pools(struct net_device *netdev)
 +static int ibmvnic_open(struct net_device *netdev)
  {
  	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
  	struct device *dev = &adapter->vdev->dev;
@@@ -511,6 -674,19 +545,21 @@@ alloc_napi_failed
  	return -ENOMEM;
  }
  
++<<<<<<< HEAD
++=======
+ static void ibmvnic_release_resources(struct ibmvnic_adapter *adapter)
+ {
+ 	release_bounce_buffer(adapter);
+ 	release_tx_pools(adapter);
+ 	release_rx_pools(adapter);
+ 
+ 	release_sub_crqs(adapter);
+ 	release_crq_queue(adapter);
+ 
+ 	release_stats_token(adapter);
+ }
+ 
++>>>>>>> 7bbc27a4961a (ibmvnic: Create init/release routines for stats token)
  static int ibmvnic_close(struct net_device *netdev)
  {
  	struct ibmvnic_adapter *adapter = netdev_priv(netdev);
@@@ -3758,9 -3282,37 +3807,41 @@@ task_failed
  	dev_err(dev, "Passive initialization was not successful\n");
  }
  
++<<<<<<< HEAD
++=======
+ static int ibmvnic_init(struct ibmvnic_adapter *adapter)
+ {
+ 	struct device *dev = &adapter->vdev->dev;
+ 	unsigned long timeout = msecs_to_jiffies(30000);
+ 	int rc;
+ 
+ 	rc = init_crq_queue(adapter);
+ 	if (rc) {
+ 		dev_err(dev, "Couldn't initialize crq. rc=%d\n", rc);
+ 		return rc;
+ 	}
+ 
+ 	rc = init_stats_token(adapter);
+ 	if (rc) {
+ 		release_crq_queue(adapter);
+ 		return rc;
+ 	}
+ 
+ 	init_completion(&adapter->init_done);
+ 	ibmvnic_send_crq_init(adapter);
+ 	if (!wait_for_completion_timeout(&adapter->init_done, timeout)) {
+ 		dev_err(dev, "Initialization sequence timed out\n");
+ 		release_crq_queue(adapter);
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 7bbc27a4961a (ibmvnic: Create init/release routines for stats token)
  static int ibmvnic_probe(struct vio_dev *dev, const struct vio_device_id *id)
  {
 +	unsigned long timeout = msecs_to_jiffies(30000);
  	struct ibmvnic_adapter *adapter;
  	struct net_device *netdev;
  	unsigned char *mac_addr_p;
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
