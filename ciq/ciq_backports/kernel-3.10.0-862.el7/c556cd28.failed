mlxsw: spectrum_router: Add helpers for nexthop access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit c556cd28930661f337d7989fe74ac31871fd3888
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c556cd28.failed

This is done as a preparation before introducing the ability to dump the
adjacency table via dpipe, and to count the table size. The current table
implementation avoids tunnel entries, thus a helper for checking if
the nexthop group contains tunnel entries is also provided. The mlxsw's
nexthop representative struct stays private to the router module.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c556cd28930661f337d7989fe74ac31871fd3888)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 6908726c154c,c062b4f666e3..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1198,13 -2065,219 +1198,221 @@@ struct mlxsw_sp_nexthop_group 
  	u16 ecmp_size;
  	u16 count;
  	struct mlxsw_sp_nexthop nexthops[0];
 -#define nh_rif	nexthops[0].rif
 +#define nh_rif	nexthops[0].r
  };
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_nexthop *mlxsw_sp_nexthop_next(struct mlxsw_sp_router *router,
+ 					       struct mlxsw_sp_nexthop *nh)
+ {
+ 	if (!nh) {
+ 		if (list_empty(&router->nexthop_list))
+ 			return NULL;
+ 		else
+ 			return list_first_entry(&router->nexthop_list,
+ 						typeof(*nh), router_list_node);
+ 	}
+ 	if (list_is_last(&nh->router_list_node, &router->nexthop_list))
+ 		return NULL;
+ 	return list_next_entry(nh, router_list_node);
+ }
+ 
+ bool mlxsw_sp_nexthop_offload(struct mlxsw_sp_nexthop *nh)
+ {
+ 	return nh->offloaded;
+ }
+ 
+ unsigned char *mlxsw_sp_nexthop_ha(struct mlxsw_sp_nexthop *nh)
+ {
+ 	if (!nh->offloaded)
+ 		return NULL;
+ 	return nh->neigh_entry->ha;
+ }
+ 
+ int mlxsw_sp_nexthop_indexes(struct mlxsw_sp_nexthop *nh, u32 *p_adj_index,
+ 			     u32 *p_adj_hash_index)
+ {
+ 	struct mlxsw_sp_nexthop_group *nh_grp = nh->nh_grp;
+ 	u32 adj_hash_index = 0;
+ 	int i;
+ 
+ 	if (!nh->offloaded || !nh_grp->adj_index_valid)
+ 		return -EINVAL;
+ 
+ 	*p_adj_index = nh_grp->adj_index;
+ 
+ 	for (i = 0; i < nh_grp->count; i++) {
+ 		struct mlxsw_sp_nexthop *nh_iter = &nh_grp->nexthops[i];
+ 
+ 		if (nh_iter == nh)
+ 			break;
+ 		if (nh_iter->offloaded)
+ 			adj_hash_index++;
+ 	}
+ 
+ 	*p_adj_hash_index = adj_hash_index;
+ 	return 0;
+ }
+ 
+ struct mlxsw_sp_rif *mlxsw_sp_nexthop_rif(struct mlxsw_sp_nexthop *nh)
+ {
+ 	return nh->rif;
+ }
+ 
+ bool mlxsw_sp_nexthop_group_has_ipip(struct mlxsw_sp_nexthop *nh)
+ {
+ 	struct mlxsw_sp_nexthop_group *nh_grp = nh->nh_grp;
+ 	int i;
+ 
+ 	for (i = 0; i < nh_grp->count; i++) {
+ 		struct mlxsw_sp_nexthop *nh_iter = &nh_grp->nexthops[i];
+ 
+ 		if (nh_iter->type == MLXSW_SP_NEXTHOP_TYPE_IPIP)
+ 			return true;
+ 	}
+ 	return false;
+ }
+ 
+ static struct fib_info *
+ mlxsw_sp_nexthop4_group_fi(const struct mlxsw_sp_nexthop_group *nh_grp)
+ {
+ 	return nh_grp->priv;
+ }
+ 
+ struct mlxsw_sp_nexthop_group_cmp_arg {
+ 	enum mlxsw_sp_l3proto proto;
+ 	union {
+ 		struct fib_info *fi;
+ 		struct mlxsw_sp_fib6_entry *fib6_entry;
+ 	};
+ };
+ 
+ static bool
+ mlxsw_sp_nexthop6_group_has_nexthop(const struct mlxsw_sp_nexthop_group *nh_grp,
+ 				    const struct in6_addr *gw, int ifindex)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < nh_grp->count; i++) {
+ 		const struct mlxsw_sp_nexthop *nh;
+ 
+ 		nh = &nh_grp->nexthops[i];
+ 		if (nh->ifindex == ifindex &&
+ 		    ipv6_addr_equal(gw, (struct in6_addr *) nh->gw_addr))
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static bool
+ mlxsw_sp_nexthop6_group_cmp(const struct mlxsw_sp_nexthop_group *nh_grp,
+ 			    const struct mlxsw_sp_fib6_entry *fib6_entry)
+ {
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 
+ 	if (nh_grp->count != fib6_entry->nrt6)
+ 		return false;
+ 
+ 	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {
+ 		struct in6_addr *gw;
+ 		int ifindex;
+ 
+ 		ifindex = mlxsw_sp_rt6->rt->dst.dev->ifindex;
+ 		gw = &mlxsw_sp_rt6->rt->rt6i_gateway;
+ 		if (!mlxsw_sp_nexthop6_group_has_nexthop(nh_grp, gw, ifindex))
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static int
+ mlxsw_sp_nexthop_group_cmp(struct rhashtable_compare_arg *arg, const void *ptr)
+ {
+ 	const struct mlxsw_sp_nexthop_group_cmp_arg *cmp_arg = arg->key;
+ 	const struct mlxsw_sp_nexthop_group *nh_grp = ptr;
+ 
+ 	switch (cmp_arg->proto) {
+ 	case MLXSW_SP_L3_PROTO_IPV4:
+ 		return cmp_arg->fi != mlxsw_sp_nexthop4_group_fi(nh_grp);
+ 	case MLXSW_SP_L3_PROTO_IPV6:
+ 		return !mlxsw_sp_nexthop6_group_cmp(nh_grp,
+ 						    cmp_arg->fib6_entry);
+ 	default:
+ 		WARN_ON(1);
+ 		return 1;
+ 	}
+ }
+ 
+ static int
+ mlxsw_sp_nexthop_group_type(const struct mlxsw_sp_nexthop_group *nh_grp)
+ {
+ 	return nh_grp->neigh_tbl->family;
+ }
+ 
+ static u32 mlxsw_sp_nexthop_group_hash_obj(const void *data, u32 len, u32 seed)
+ {
+ 	const struct mlxsw_sp_nexthop_group *nh_grp = data;
+ 	const struct mlxsw_sp_nexthop *nh;
+ 	struct fib_info *fi;
+ 	unsigned int val;
+ 	int i;
+ 
+ 	switch (mlxsw_sp_nexthop_group_type(nh_grp)) {
+ 	case AF_INET:
+ 		fi = mlxsw_sp_nexthop4_group_fi(nh_grp);
+ 		return jhash(&fi, sizeof(fi), seed);
+ 	case AF_INET6:
+ 		val = nh_grp->count;
+ 		for (i = 0; i < nh_grp->count; i++) {
+ 			nh = &nh_grp->nexthops[i];
+ 			val ^= nh->ifindex;
+ 		}
+ 		return jhash(&val, sizeof(val), seed);
+ 	default:
+ 		WARN_ON(1);
+ 		return 0;
+ 	}
+ }
+ 
+ static u32
+ mlxsw_sp_nexthop6_group_hash(struct mlxsw_sp_fib6_entry *fib6_entry, u32 seed)
+ {
+ 	unsigned int val = fib6_entry->nrt6;
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 	struct net_device *dev;
+ 
+ 	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {
+ 		dev = mlxsw_sp_rt6->rt->dst.dev;
+ 		val ^= dev->ifindex;
+ 	}
+ 
+ 	return jhash(&val, sizeof(val), seed);
+ }
+ 
+ static u32
+ mlxsw_sp_nexthop_group_hash(const void *data, u32 len, u32 seed)
+ {
+ 	const struct mlxsw_sp_nexthop_group_cmp_arg *cmp_arg = data;
+ 
+ 	switch (cmp_arg->proto) {
+ 	case MLXSW_SP_L3_PROTO_IPV4:
+ 		return jhash(&cmp_arg->fi, sizeof(cmp_arg->fi), seed);
+ 	case MLXSW_SP_L3_PROTO_IPV6:
+ 		return mlxsw_sp_nexthop6_group_hash(cmp_arg->fib6_entry, seed);
+ 	default:
+ 		WARN_ON(1);
+ 		return 0;
+ 	}
+ }
+ 
++>>>>>>> c556cd289306 (mlxsw: spectrum_router: Add helpers for nexthop access)
  static const struct rhashtable_params mlxsw_sp_nexthop_group_ht_params = {
 +	.key_offset = offsetof(struct mlxsw_sp_nexthop_group, key),
  	.head_offset = offsetof(struct mlxsw_sp_nexthop_group, ht_node),
 -	.hashfn	     = mlxsw_sp_nexthop_group_hash,
 -	.obj_hashfn  = mlxsw_sp_nexthop_group_hash_obj,
 -	.obj_cmpfn   = mlxsw_sp_nexthop_group_cmp,
 +	.key_len = sizeof(struct mlxsw_sp_nexthop_group_key),
  };
  
  static int mlxsw_sp_nexthop_group_insert(struct mlxsw_sp *mlxsw_sp,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
