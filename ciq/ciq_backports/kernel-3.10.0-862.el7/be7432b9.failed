mlxsw: spectrum: Remove support for bridge bypass FDB add/del

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit be7432b952bcbe2d7ac27a9f8545cce4cc74a4df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/be7432b9.failed

The FDB add/del are now done through the notification chain. The FDBs
are synced with the bridge and there is no need for extra dumping.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit be7432b952bcbe2d7ac27a9f8545cce4cc74a4df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 4d14e78f2e24,ecc73525529d..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -1755,17 -1752,11 +1755,21 @@@ static const struct net_device_ops mlxs
  	.ndo_set_mac_address	= mlxsw_sp_port_set_mac_address,
  	.ndo_change_mtu		= mlxsw_sp_port_change_mtu,
  	.ndo_get_stats64	= mlxsw_sp_port_get_stats64,
 -	.ndo_has_offload_stats	= mlxsw_sp_port_has_offload_stats,
 -	.ndo_get_offload_stats	= mlxsw_sp_port_get_offload_stats,
 +	.extended.ndo_has_offload_stats	= mlxsw_sp_port_has_offload_stats,
 +	.extended.ndo_get_offload_stats	= mlxsw_sp_port_get_offload_stats,
  	.ndo_vlan_rx_add_vid	= mlxsw_sp_port_add_vid,
  	.ndo_vlan_rx_kill_vid	= mlxsw_sp_port_kill_vid,
++<<<<<<< HEAD
 +	.ndo_fdb_add		= switchdev_port_fdb_add,
 +	.ndo_fdb_del		= switchdev_port_fdb_del,
 +	.extended.ndo_fdb_dump	= switchdev_port_fdb_dump,
 +	.ndo_bridge_setlink	= switchdev_port_bridge_setlink,
 +	.ndo_bridge_getlink	= switchdev_port_bridge_getlink,
 +	.ndo_bridge_dellink	= switchdev_port_bridge_dellink,
 +	.extended.ndo_get_phys_port_name	= mlxsw_sp_port_get_phys_port_name,
++=======
+ 	.ndo_get_phys_port_name	= mlxsw_sp_port_get_phys_port_name,
++>>>>>>> be7432b952bc (mlxsw: spectrum: Remove support for bridge bypass FDB add/del)
  };
  
  static void mlxsw_sp_port_get_drvinfo(struct net_device *dev,
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index a7736231096b,cd89a3e6cd81..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -799,29 -1141,40 +799,66 @@@ static int mlxsw_sp_port_fdb_uc_lag_op(
  }
  
  static int
++<<<<<<< HEAD
 +mlxsw_sp_port_fdb_static_add(struct mlxsw_sp_port *mlxsw_sp_port,
 +			     const struct switchdev_obj_port_fdb *fdb,
 +			     struct switchdev_trans *trans)
 +{
 +	u16 fid = mlxsw_sp_port_vid_to_fid_get(mlxsw_sp_port, fdb->vid);
 +	u16 lag_vid = 0;
 +
 +	if (switchdev_trans_ph_prepare(trans))
 +		return 0;
 +
 +	if (mlxsw_sp_port_is_vport(mlxsw_sp_port)) {
 +		lag_vid = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +	}
 +
 +	if (!mlxsw_sp_port->lagged)
 +		return mlxsw_sp_port_fdb_uc_op(mlxsw_sp_port->mlxsw_sp,
 +					       mlxsw_sp_port->local_port,
 +					       fdb->addr, fid, true, false);
 +	else
 +		return mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp_port->mlxsw_sp,
 +						   mlxsw_sp_port->lag_id,
 +						   fdb->addr, fid, lag_vid,
 +						   true, false);
++=======
+ mlxsw_sp_port_fdb_set(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		      struct switchdev_notifier_fdb_info *fdb_info, bool adding)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
+ 	struct net_device *orig_dev = fdb_info->info.dev;
+ 	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
+ 	struct mlxsw_sp_bridge_device *bridge_device;
+ 	struct mlxsw_sp_bridge_port *bridge_port;
+ 	u16 fid_index, vid;
+ 
+ 	bridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);
+ 	if (!bridge_port)
+ 		return -EINVAL;
+ 
+ 	bridge_device = bridge_port->bridge_device;
+ 	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,
+ 							       bridge_device,
+ 							       fdb_info->vid);
+ 	if (!mlxsw_sp_port_vlan)
+ 		return 0;
+ 
+ 	fid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);
+ 	vid = mlxsw_sp_port_vlan->vid;
+ 
+ 	if (!bridge_port->lagged)
+ 		return mlxsw_sp_port_fdb_uc_op(mlxsw_sp,
+ 					       bridge_port->system_port,
+ 					       fdb_info->addr, fid_index,
+ 					       adding, false);
+ 	else
+ 		return mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp,
+ 						   bridge_port->lag_id,
+ 						   fdb_info->addr, fid_index,
+ 						   vid, adding, false);
++>>>>>>> be7432b952bc (mlxsw: spectrum: Remove support for bridge bypass FDB add/del)
  }
  
  static int mlxsw_sp_port_mdb_op(struct mlxsw_sp *mlxsw_sp, const char *addr,
@@@ -1022,37 -1395,6 +1054,40 @@@ static int mlxsw_sp_port_vlans_del(stru
  	return 0;
  }
  
++<<<<<<< HEAD
 +void mlxsw_sp_port_active_vlans_del(struct mlxsw_sp_port *mlxsw_sp_port)
 +{
 +	u16 vid;
 +
 +	for_each_set_bit(vid, mlxsw_sp_port->active_vlans, VLAN_N_VID)
 +		mlxsw_sp_port_vlan_del(mlxsw_sp_port, vid);
 +}
 +
 +static int
 +mlxsw_sp_port_fdb_static_del(struct mlxsw_sp_port *mlxsw_sp_port,
 +			     const struct switchdev_obj_port_fdb *fdb)
 +{
 +	u16 fid = mlxsw_sp_port_vid_to_fid_get(mlxsw_sp_port, fdb->vid);
 +	u16 lag_vid = 0;
 +
 +	if (mlxsw_sp_port_is_vport(mlxsw_sp_port)) {
 +		lag_vid = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +	}
 +
 +	if (!mlxsw_sp_port->lagged)
 +		return mlxsw_sp_port_fdb_uc_op(mlxsw_sp_port->mlxsw_sp,
 +					       mlxsw_sp_port->local_port,
 +					       fdb->addr, fid,
 +					       false, false);
 +	else
 +		return mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp_port->mlxsw_sp,
 +						   mlxsw_sp_port->lag_id,
 +						   fdb->addr, fid, lag_vid,
 +						   false, false);
 +}
 +
++=======
++>>>>>>> be7432b952bc (mlxsw: spectrum: Remove support for bridge bypass FDB add/del)
  static int mlxsw_sp_port_mdb_del(struct mlxsw_sp_port *mlxsw_sp_port,
  				 const struct switchdev_obj_port_mdb *mdb)
  {
@@@ -1135,181 -1483,189 +1166,183 @@@ static struct mlxsw_sp_port *mlxsw_sp_l
  	return NULL;
  }
  
 -static const struct switchdev_ops mlxsw_sp_port_switchdev_ops = {
 -	.switchdev_port_attr_get	= mlxsw_sp_port_attr_get,
 -	.switchdev_port_attr_set	= mlxsw_sp_port_attr_set,
 -	.switchdev_port_obj_add		= mlxsw_sp_port_obj_add,
 -	.switchdev_port_obj_del		= mlxsw_sp_port_obj_del,
 -};
 -
 -static int
 -mlxsw_sp_bridge_8021q_port_join(struct mlxsw_sp_bridge_device *bridge_device,
 -				struct mlxsw_sp_bridge_port *bridge_port,
 -				struct mlxsw_sp_port *mlxsw_sp_port)
++<<<<<<< HEAD
 +static int mlxsw_sp_port_fdb_dump(struct mlxsw_sp_port *mlxsw_sp_port,
 +				  struct switchdev_obj_port_fdb *fdb,
 +				  switchdev_obj_dump_cb_t *cb,
 +				  struct net_device *orig_dev)
  {
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 +	struct mlxsw_sp_port *tmp;
 +	struct mlxsw_sp_fid *f;
 +	u16 vport_fid;
 +	char *sfd_pl;
 +	char mac[ETH_ALEN];
 +	u16 fid;
 +	u8 local_port;
 +	u16 lag_id;
 +	u8 num_rec;
 +	int stored_err = 0;
 +	int i;
 +	int err;
  
 -	if (is_vlan_dev(bridge_port->dev))
 -		return -EINVAL;
 +	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
 +	if (!sfd_pl)
 +		return -ENOMEM;
  
 -	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, 1);
 -	if (WARN_ON(!mlxsw_sp_port_vlan))
 -		return -EINVAL;
 +	f = mlxsw_sp_vport_fid_get(mlxsw_sp_port);
 +	vport_fid = f ? f->fid : 0;
  
 -	/* Let VLAN-aware bridge take care of its own VLANs */
 -	mlxsw_sp_port_vlan_put(mlxsw_sp_port_vlan);
 +	mlxsw_reg_sfd_pack(sfd_pl, MLXSW_REG_SFD_OP_QUERY_DUMP, 0);
 +	do {
 +		mlxsw_reg_sfd_num_rec_set(sfd_pl, MLXSW_REG_SFD_REC_MAX_COUNT);
 +		err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);
 +		if (err)
 +			goto out;
  
 -	return 0;
 -}
 +		num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);
  
 -static void
 -mlxsw_sp_bridge_8021q_port_leave(struct mlxsw_sp_bridge_device *bridge_device,
 -				 struct mlxsw_sp_bridge_port *bridge_port,
 -				 struct mlxsw_sp_port *mlxsw_sp_port)
 -{
 -	mlxsw_sp_port_vlan_get(mlxsw_sp_port, 1);
 -	/* Make sure untagged frames are allowed to ingress */
 -	mlxsw_sp_port_pvid_set(mlxsw_sp_port, 1);
 -}
 +		/* Even in case of error, we have to run the dump to the end
 +		 * so the session in firmware is finished.
 +		 */
 +		if (stored_err)
 +			continue;
  
 -static struct mlxsw_sp_fid *
 -mlxsw_sp_bridge_8021q_fid_get(struct mlxsw_sp_bridge_device *bridge_device,
 -			      u16 vid)
 -{
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);
 +		for (i = 0; i < num_rec; i++) {
 +			switch (mlxsw_reg_sfd_rec_type_get(sfd_pl, i)) {
 +			case MLXSW_REG_SFD_REC_TYPE_UNICAST:
 +				mlxsw_reg_sfd_uc_unpack(sfd_pl, i, mac, &fid,
 +							&local_port);
 +				if (local_port == mlxsw_sp_port->local_port) {
 +					if (vport_fid && vport_fid == fid)
 +						fdb->vid = 0;
 +					else if (!vport_fid &&
 +						 !mlxsw_sp_fid_is_vfid(fid))
 +						fdb->vid = fid;
 +					else
 +						continue;
 +					ether_addr_copy(fdb->addr, mac);
 +					fdb->ndm_state = NUD_REACHABLE;
 +					err = cb(&fdb->obj);
 +					if (err)
 +						stored_err = err;
 +				}
 +				break;
 +			case MLXSW_REG_SFD_REC_TYPE_UNICAST_LAG:
 +				mlxsw_reg_sfd_uc_lag_unpack(sfd_pl, i,
 +							    mac, &fid, &lag_id);
 +				tmp = mlxsw_sp_lag_rep_port(mlxsw_sp, lag_id);
 +				if (tmp && tmp->local_port ==
 +				    mlxsw_sp_port->local_port) {
 +					/* LAG records can only point to LAG
 +					 * devices or VLAN devices on top.
 +					 */
 +					if (!netif_is_lag_master(orig_dev) &&
 +					    !is_vlan_dev(orig_dev))
 +						continue;
 +					if (vport_fid && vport_fid == fid)
 +						fdb->vid = 0;
 +					else if (!vport_fid &&
 +						 !mlxsw_sp_fid_is_vfid(fid))
 +						fdb->vid = fid;
 +					else
 +						continue;
 +					ether_addr_copy(fdb->addr, mac);
 +					fdb->ndm_state = NUD_REACHABLE;
 +					err = cb(&fdb->obj);
 +					if (err)
 +						stored_err = err;
 +				}
 +				break;
 +			}
 +		}
 +	} while (num_rec == MLXSW_REG_SFD_REC_MAX_COUNT);
  
 -	return mlxsw_sp_fid_8021q_get(mlxsw_sp, vid);
 +out:
 +	kfree(sfd_pl);
 +	return stored_err ? stored_err : err;
  }
  
 -static const struct mlxsw_sp_bridge_ops mlxsw_sp_bridge_8021q_ops = {
 -	.port_join	= mlxsw_sp_bridge_8021q_port_join,
 -	.port_leave	= mlxsw_sp_bridge_8021q_port_leave,
 -	.fid_get	= mlxsw_sp_bridge_8021q_fid_get,
 -};
 -
 -static bool
 -mlxsw_sp_port_is_br_member(const struct mlxsw_sp_port *mlxsw_sp_port,
 -			   const struct net_device *br_dev)
 +static int mlxsw_sp_port_vlan_dump(struct mlxsw_sp_port *mlxsw_sp_port,
 +				   struct switchdev_obj_port_vlan *vlan,
 +				   switchdev_obj_dump_cb_t *cb)
  {
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 +	u16 vid;
 +	int err = 0;
  
 -	list_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,
 -			    list) {
 -		if (mlxsw_sp_port_vlan->bridge_port &&
 -		    mlxsw_sp_port_vlan->bridge_port->bridge_device->dev ==
 -		    br_dev)
 -			return true;
 +	if (mlxsw_sp_port_is_vport(mlxsw_sp_port)) {
 +		vlan->flags = 0;
 +		vlan->vid_begin = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +		vlan->vid_end = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +		return cb(&vlan->obj);
  	}
  
 -	return false;
 +	for_each_set_bit(vid, mlxsw_sp_port->active_vlans, VLAN_N_VID) {
 +		vlan->flags = 0;
 +		if (vid == mlxsw_sp_port->pvid)
 +			vlan->flags |= BRIDGE_VLAN_INFO_PVID;
 +		if (test_bit(vid, mlxsw_sp_port->untagged_vlans))
 +			vlan->flags |= BRIDGE_VLAN_INFO_UNTAGGED;
 +		vlan->vid_begin = vid;
 +		vlan->vid_end = vid;
 +		err = cb(&vlan->obj);
 +		if (err)
 +			break;
 +	}
 +	return err;
  }
  
 -static int
 -mlxsw_sp_bridge_8021d_port_join(struct mlxsw_sp_bridge_device *bridge_device,
 -				struct mlxsw_sp_bridge_port *bridge_port,
 -				struct mlxsw_sp_port *mlxsw_sp_port)
 +static int mlxsw_sp_port_obj_dump(struct net_device *dev,
 +				  struct switchdev_obj *obj,
 +				  switchdev_obj_dump_cb_t *cb)
  {
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 -	u16 vid;
 -
 -	if (!is_vlan_dev(bridge_port->dev))
 -		return -EINVAL;
 -	vid = vlan_dev_vlan_id(bridge_port->dev);
 +	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);
 +	int err = 0;
  
 -	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);
 -	if (WARN_ON(!mlxsw_sp_port_vlan))
 +	mlxsw_sp_port = mlxsw_sp_port_orig_get(obj->orig_dev, mlxsw_sp_port);
 +	if (!mlxsw_sp_port)
  		return -EINVAL;
  
 -	if (mlxsw_sp_port_is_br_member(mlxsw_sp_port, bridge_device->dev)) {
 -		netdev_err(mlxsw_sp_port->dev, "Can't bridge VLAN uppers of the same port\n");
 -		return -EINVAL;
 +	switch (obj->id) {
 +	case SWITCHDEV_OBJ_ID_PORT_VLAN:
 +		err = mlxsw_sp_port_vlan_dump(mlxsw_sp_port,
 +					      SWITCHDEV_OBJ_PORT_VLAN(obj), cb);
 +		break;
 +	case SWITCHDEV_OBJ_ID_PORT_FDB:
 +		err = mlxsw_sp_port_fdb_dump(mlxsw_sp_port,
 +					     SWITCHDEV_OBJ_PORT_FDB(obj), cb,
 +					     obj->orig_dev);
 +		break;
 +	default:
 +		err = -EOPNOTSUPP;
 +		break;
  	}
  
 -	/* Port is no longer usable as a router interface */
 -	if (mlxsw_sp_port_vlan->fid)
 -		mlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);
 -
 -	return mlxsw_sp_port_vlan_bridge_join(mlxsw_sp_port_vlan, bridge_port);
 -}
 -
 -static void
 -mlxsw_sp_bridge_8021d_port_leave(struct mlxsw_sp_bridge_device *bridge_device,
 -				 struct mlxsw_sp_bridge_port *bridge_port,
 -				 struct mlxsw_sp_port *mlxsw_sp_port)
 -{
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 -	u16 vid = vlan_dev_vlan_id(bridge_port->dev);
 -
 -	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);
 -	if (WARN_ON(!mlxsw_sp_port_vlan))
 -		return;
 -
 -	mlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);
 -}
 -
 -static struct mlxsw_sp_fid *
 -mlxsw_sp_bridge_8021d_fid_get(struct mlxsw_sp_bridge_device *bridge_device,
 -			      u16 vid)
 -{
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);
 -
 -	return mlxsw_sp_fid_8021d_get(mlxsw_sp, bridge_device->dev->ifindex);
 -}
 -
 -static const struct mlxsw_sp_bridge_ops mlxsw_sp_bridge_8021d_ops = {
 -	.port_join	= mlxsw_sp_bridge_8021d_port_join,
 -	.port_leave	= mlxsw_sp_bridge_8021d_port_leave,
 -	.fid_get	= mlxsw_sp_bridge_8021d_fid_get,
 -};
 -
 -int mlxsw_sp_port_bridge_join(struct mlxsw_sp_port *mlxsw_sp_port,
 -			      struct net_device *brport_dev,
 -			      struct net_device *br_dev)
 -{
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -	struct mlxsw_sp_bridge_port *bridge_port;
 -	int err;
 -
 -	bridge_port = mlxsw_sp_bridge_port_get(mlxsw_sp->bridge, brport_dev);
 -	if (IS_ERR(bridge_port))
 -		return PTR_ERR(bridge_port);
 -	bridge_device = bridge_port->bridge_device;
 -
 -	err = bridge_device->ops->port_join(bridge_device, bridge_port,
 -					    mlxsw_sp_port);
 -	if (err)
 -		goto err_port_join;
 -
 -	return 0;
 -
 -err_port_join:
 -	mlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);
  	return err;
  }
  
 -void mlxsw_sp_port_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_port,
 -				struct net_device *brport_dev,
 -				struct net_device *br_dev)
 -{
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 -	struct mlxsw_sp_bridge_device *bridge_device;
 -	struct mlxsw_sp_bridge_port *bridge_port;
 -
 -	bridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);
 -	if (!bridge_device)
 -		return;
 -	bridge_port = __mlxsw_sp_bridge_port_find(bridge_device, brport_dev);
 -	if (!bridge_port)
 -		return;
 -
 -	bridge_device->ops->port_leave(bridge_device, bridge_port,
 -				       mlxsw_sp_port);
 -	mlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);
 -}
++=======
++>>>>>>> be7432b952bc (mlxsw: spectrum: Remove support for bridge bypass FDB add/del)
 +static const struct switchdev_ops mlxsw_sp_port_switchdev_ops = {
 +	.switchdev_port_attr_get	= mlxsw_sp_port_attr_get,
 +	.switchdev_port_attr_set	= mlxsw_sp_port_attr_set,
 +	.switchdev_port_obj_add		= mlxsw_sp_port_obj_add,
 +	.switchdev_port_obj_del		= mlxsw_sp_port_obj_del,
- 	.switchdev_port_obj_dump	= mlxsw_sp_port_obj_dump,
 +};
  
 -static void
 -mlxsw_sp_fdb_call_notifiers(enum switchdev_notifier_type type,
 -			    const char *mac, u16 vid,
 -			    struct net_device *dev)
 +static void mlxsw_sp_fdb_call_notifiers(bool learning_sync, bool adding,
 +					char *mac, u16 vid,
 +					struct net_device *dev)
  {
  	struct switchdev_notifier_fdb_info info;
 +	unsigned long notifier_type;
  
 -	info.addr = mac;
 -	info.vid = vid;
 -	call_switchdev_notifiers(type, dev, &info.info);
 +	if (learning_sync) {
 +		info.addr = mac;
 +		info.vid = vid;
 +		notifier_type = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE : SWITCHDEV_FDB_DEL_TO_BRIDGE;
 +		call_switchdev_notifiers(notifier_type, dev, &info.info);
 +	}
  }
  
  static void mlxsw_sp_fdb_notify_mac_process(struct mlxsw_sp *mlxsw_sp,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
