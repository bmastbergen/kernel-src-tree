scsi: qla2xxx: Fix remoteport disconnect for FC-NVMe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix remoteport disconnect for FC-NVMe (Himanshu Madhani) [1316281]
Rebuild_FUZZ: 93.88%
commit-author himanshu.madhani@cavium.com <himanshu.madhani@cavium.com>
commit 49b3d5f67c1e5d661b64b77ec37bd9f57cbf720d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/49b3d5f6.failed

	Signed-off-by: Duane Grigsby <duane.grigsby@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 49b3d5f67c1e5d661b64b77ec37bd9f57cbf720d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_nvme.c
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 3d56972c1852,c14fab35fc36..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -1637,7 -1795,105 +1637,109 @@@ qla24xx_tm_iocb_entry(scsi_qla_host_t *
  		ql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5055,
  		    (uint8_t *)sts, sizeof(*sts));
  
++<<<<<<< HEAD
 +	sp->done(vha, sp, 0);
++=======
+ 	sp->done(sp, 0);
+ }
+ 
+ static void
+ qla24xx_nvme_iocb_entry(scsi_qla_host_t *vha, struct req_que *req, void *tsk)
+ {
+ 	const char func[] = "NVME-IOCB";
+ 	fc_port_t *fcport;
+ 	srb_t *sp;
+ 	struct srb_iocb *iocb;
+ 	struct sts_entry_24xx *sts = (struct sts_entry_24xx *)tsk;
+ 	uint16_t        state_flags;
+ 	struct nvmefc_fcp_req *fd;
+ 	uint16_t        ret = 0;
+ 	struct srb_iocb *nvme;
+ 
+ 	sp = qla2x00_get_sp_from_handle(vha, func, req, tsk);
+ 	if (!sp)
+ 		return;
+ 
+ 	iocb = &sp->u.iocb_cmd;
+ 	fcport = sp->fcport;
+ 	iocb->u.nvme.comp_status = le16_to_cpu(sts->comp_status);
+ 	state_flags  = le16_to_cpu(sts->state_flags);
+ 	fd = iocb->u.nvme.desc;
+ 	nvme = &sp->u.iocb_cmd;
+ 
+ 	if (unlikely(nvme->u.nvme.aen_op))
+ 		atomic_dec(&sp->vha->hw->nvme_active_aen_cnt);
+ 
+ 	/*
+ 	 * State flags: Bit 6 and 0.
+ 	 * If 0 is set, we don't care about 6.
+ 	 * both cases resp was dma'd to host buffer
+ 	 * if both are 0, that is good path case.
+ 	 * if six is set and 0 is clear, we need to
+ 	 * copy resp data from status iocb to resp buffer.
+ 	 */
+ 	if (!(state_flags & (SF_FCP_RSP_DMA | SF_NVME_ERSP))) {
+ 		iocb->u.nvme.rsp_pyld_len = 0;
+ 	} else if ((state_flags & SF_FCP_RSP_DMA)) {
+ 		iocb->u.nvme.rsp_pyld_len = le16_to_cpu(sts->nvme_rsp_pyld_len);
+ 	} else if (state_flags & SF_NVME_ERSP) {
+ 		uint32_t *inbuf, *outbuf;
+ 		uint16_t iter;
+ 
+ 		inbuf = (uint32_t *)&sts->nvme_ersp_data;
+ 		outbuf = (uint32_t *)fd->rspaddr;
+ 		iocb->u.nvme.rsp_pyld_len = le16_to_cpu(sts->nvme_rsp_pyld_len);
+ 		iter = iocb->u.nvme.rsp_pyld_len >> 2;
+ 		for (; iter; iter--)
+ 			*outbuf++ = swab32(*inbuf++);
+ 	} else { /* unhandled case */
+ 	    ql_log(ql_log_warn, fcport->vha, 0x503a,
+ 		"NVME-%s error. Unhandled state_flags of %x\n",
+ 		sp->name, state_flags);
+ 	}
+ 
+ 	fd->transferred_length = fd->payload_length -
+ 	    le32_to_cpu(sts->residual_len);
+ 
+ 	/*
+ 	 * If transport error then Failure (HBA rejects request)
+ 	 * otherwise transport will handle.
+ 	 */
+ 	if (sts->entry_status) {
+ 		ql_log(ql_log_warn, fcport->vha, 0x5038,
+ 		    "NVME-%s error - hdl=%x entry-status(%x).\n",
+ 		    sp->name, sp->handle, sts->entry_status);
+ 		ret = QLA_FUNCTION_FAILED;
+ 	} else  {
+ 		switch (le16_to_cpu(sts->comp_status)) {
+ 			case CS_COMPLETE:
+ 				ret = 0;
+ 			break;
+ 
+ 			case CS_ABORTED:
+ 			case CS_RESET:
+ 			case CS_PORT_UNAVAILABLE:
+ 			case CS_PORT_LOGGED_OUT:
+ 			case CS_PORT_BUSY:
+ 				ql_log(ql_log_warn, fcport->vha, 0x5060,
+ 				"NVME-%s ERR Handling - hdl=%x completion status(%x) resid=%x  ox_id=%x\n",
+ 				sp->name, sp->handle, sts->comp_status,
+ 				le32_to_cpu(sts->residual_len), sts->ox_id);
+ 				fd->transferred_length = fd->payload_length;
+ 				ret = QLA_ABORTED;
+ 			break;
+ 
+ 			default:
+ 				ql_log(ql_log_warn, fcport->vha, 0x5060,
+ 				"NVME-%s error - hdl=%x completion status(%x) resid=%x  ox_id=%x\n",
+ 				sp->name, sp->handle, sts->comp_status,
+ 				le32_to_cpu(sts->residual_len), sts->ox_id);
+ 				ret = QLA_FUNCTION_FAILED;
+ 				break;
+ 		}
+ 	}
+ 	sp->done(sp, ret);
++>>>>>>> 49b3d5f67c1e (scsi: qla2xxx: Fix remoteport disconnect for FC-NVMe)
  }
  
  /**
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
