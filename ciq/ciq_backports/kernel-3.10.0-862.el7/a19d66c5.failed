efi: Add an EFI table address match function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit a19d66c56af1c52b8b463bf94d21116ae8c1aa5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/a19d66c5.failed

Add a function that will determine if a supplied physical address matches
the address of an EFI table.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Larry Woodman <lwoodman@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Toshimitsu Kani <toshi.kani@hpe.com>
	Cc: kasan-dev@googlegroups.com
	Cc: kvm@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-efi@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/e1e06441d80f44776df391e0e4cb485b345b7518.1500319216.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a19d66c56af1c52b8b463bf94d21116ae8c1aa5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/efi.c
index 298ffe5c759a,69d4d130e055..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -40,8 -55,56 +40,60 @@@ struct efi __read_mostly efi = 
  };
  EXPORT_SYMBOL(efi);
  
++<<<<<<< HEAD
++=======
+ static unsigned long *efi_tables[] = {
+ 	&efi.mps,
+ 	&efi.acpi,
+ 	&efi.acpi20,
+ 	&efi.smbios,
+ 	&efi.smbios3,
+ 	&efi.sal_systab,
+ 	&efi.boot_info,
+ 	&efi.hcdp,
+ 	&efi.uga,
+ 	&efi.uv_systab,
+ 	&efi.fw_vendor,
+ 	&efi.runtime,
+ 	&efi.config_table,
+ 	&efi.esrt,
+ 	&efi.properties_table,
+ 	&efi.mem_attr_table,
+ };
+ 
+ static bool disable_runtime;
+ static int __init setup_noefi(char *arg)
+ {
+ 	disable_runtime = true;
+ 	return 0;
+ }
+ early_param("noefi", setup_noefi);
+ 
+ bool efi_runtime_disabled(void)
+ {
+ 	return disable_runtime;
+ }
+ 
+ static int __init parse_efi_cmdline(char *str)
+ {
+ 	if (!str) {
+ 		pr_warn("need at least one option\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (parse_option_str(str, "debug"))
+ 		set_bit(EFI_DBG, &efi.flags);
+ 
+ 	if (parse_option_str(str, "noruntime"))
+ 		disable_runtime = true;
+ 
+ 	return 0;
+ }
+ early_param("efi", parse_efi_cmdline);
+ 
++>>>>>>> a19d66c56af1 (efi: Add an EFI table address match function)
  struct kobject *efi_kobj;
 +static struct kobject *efivars_kobj;
  
  /*
   * Let's not leave out systab information that snuck into
@@@ -346,37 -590,344 +398,342 @@@ int __init efi_config_init(efi_config_t
  		return -ENOMEM;
  	}
  
 -	ret = efi_config_parse_tables(config_tables, efi.systab->nr_tables, sz,
 -				      arch_tables);
 -
 -	early_memunmap(config_tables, efi.systab->nr_tables * sz);
 -	return ret;
 -}
 -
 -#ifdef CONFIG_EFI_VARS_MODULE
 -static int __init efi_load_efivars(void)
 -{
 -	struct platform_device *pdev;
 -
 -	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 -		return 0;
 +	tablep = config_tables;
 +	pr_info("");
 +	for (i = 0; i < efi.systab->nr_tables; i++) {
 +		efi_guid_t guid;
 +		unsigned long table;
  
 -	pdev = platform_device_register_simple("efivars", 0, NULL, 0);
 -	return IS_ERR(pdev) ? PTR_ERR(pdev) : 0;
 -}
 -device_initcall(efi_load_efivars);
 +		if (efi_enabled(EFI_64BIT)) {
 +			u64 table64;
 +			guid = ((efi_config_table_64_t *)tablep)->guid;
 +			table64 = ((efi_config_table_64_t *)tablep)->table;
 +			table = table64;
 +#ifndef CONFIG_64BIT
 +			if (table64 >> 32) {
 +				pr_cont("\n");
 +				pr_err("Table located above 4GB, disabling EFI.\n");
 +				early_iounmap(config_tables,
 +					       efi.systab->nr_tables * sz);
 +				return -EINVAL;
 +			}
  #endif
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_EFI_PARAMS_FROM_FDT
+ 
+ #define UEFI_PARAM(name, prop, field)			   \
+ 	{						   \
+ 		{ name },				   \
+ 		{ prop },				   \
+ 		offsetof(struct efi_fdt_params, field),    \
+ 		FIELD_SIZEOF(struct efi_fdt_params, field) \
+ 	}
+ 
+ struct params {
+ 	const char name[32];
+ 	const char propname[32];
+ 	int offset;
+ 	int size;
+ };
+ 
+ static __initdata struct params fdt_params[] = {
+ 	UEFI_PARAM("System Table", "linux,uefi-system-table", system_table),
+ 	UEFI_PARAM("MemMap Address", "linux,uefi-mmap-start", mmap),
+ 	UEFI_PARAM("MemMap Size", "linux,uefi-mmap-size", mmap_size),
+ 	UEFI_PARAM("MemMap Desc. Size", "linux,uefi-mmap-desc-size", desc_size),
+ 	UEFI_PARAM("MemMap Desc. Version", "linux,uefi-mmap-desc-ver", desc_ver)
+ };
+ 
+ static __initdata struct params xen_fdt_params[] = {
+ 	UEFI_PARAM("System Table", "xen,uefi-system-table", system_table),
+ 	UEFI_PARAM("MemMap Address", "xen,uefi-mmap-start", mmap),
+ 	UEFI_PARAM("MemMap Size", "xen,uefi-mmap-size", mmap_size),
+ 	UEFI_PARAM("MemMap Desc. Size", "xen,uefi-mmap-desc-size", desc_size),
+ 	UEFI_PARAM("MemMap Desc. Version", "xen,uefi-mmap-desc-ver", desc_ver)
+ };
+ 
+ #define EFI_FDT_PARAMS_SIZE	ARRAY_SIZE(fdt_params)
+ 
+ static __initdata struct {
+ 	const char *uname;
+ 	const char *subnode;
+ 	struct params *params;
+ } dt_params[] = {
+ 	{ "hypervisor", "uefi", xen_fdt_params },
+ 	{ "chosen", NULL, fdt_params },
+ };
+ 
+ struct param_info {
+ 	int found;
+ 	void *params;
+ 	const char *missing;
+ };
+ 
+ static int __init __find_uefi_params(unsigned long node,
+ 				     struct param_info *info,
+ 				     struct params *params)
+ {
+ 	const void *prop;
+ 	void *dest;
+ 	u64 val;
+ 	int i, len;
+ 
+ 	for (i = 0; i < EFI_FDT_PARAMS_SIZE; i++) {
+ 		prop = of_get_flat_dt_prop(node, params[i].propname, &len);
+ 		if (!prop) {
+ 			info->missing = params[i].name;
+ 			return 0;
+ 		}
+ 
+ 		dest = info->params + params[i].offset;
+ 		info->found++;
+ 
+ 		val = of_read_number(prop, len / sizeof(u32));
+ 
+ 		if (params[i].size == sizeof(u32))
+ 			*(u32 *)dest = val;
+ 		else
+ 			*(u64 *)dest = val;
+ 
+ 		if (efi_enabled(EFI_DBG))
+ 			pr_info("  %s: 0x%0*llx\n", params[i].name,
+ 				params[i].size * 2, val);
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
+ 				       int depth, void *data)
+ {
+ 	struct param_info *info = data;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
+ 		const char *subnode = dt_params[i].subnode;
+ 
+ 		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
+ 			info->missing = dt_params[i].params[0].name;
+ 			continue;
+ 		}
+ 
+ 		if (subnode) {
+ 			int err = of_get_flat_dt_subnode_by_name(node, subnode);
+ 
+ 			if (err < 0)
+ 				return 0;
+ 
+ 			node = err;
+ 		}
+ 
+ 		return __find_uefi_params(node, info, dt_params[i].params);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int __init efi_get_fdt_params(struct efi_fdt_params *params)
+ {
+ 	struct param_info info;
+ 	int ret;
+ 
+ 	pr_info("Getting EFI parameters from FDT:\n");
+ 
+ 	info.found = 0;
+ 	info.params = params;
+ 
+ 	ret = of_scan_flat_dt(fdt_find_uefi_params, &info);
+ 	if (!info.found)
+ 		pr_info("UEFI not found.\n");
+ 	else if (!ret)
+ 		pr_err("Can't find '%s' in device tree!\n",
+ 		       info.missing);
+ 
+ 	return ret;
+ }
+ #endif /* CONFIG_EFI_PARAMS_FROM_FDT */
+ 
+ static __initdata char memory_type_name[][20] = {
+ 	"Reserved",
+ 	"Loader Code",
+ 	"Loader Data",
+ 	"Boot Code",
+ 	"Boot Data",
+ 	"Runtime Code",
+ 	"Runtime Data",
+ 	"Conventional Memory",
+ 	"Unusable Memory",
+ 	"ACPI Reclaim Memory",
+ 	"ACPI Memory NVS",
+ 	"Memory Mapped I/O",
+ 	"MMIO Port Space",
+ 	"PAL Code",
+ 	"Persistent Memory",
+ };
+ 
+ char * __init efi_md_typeattr_format(char *buf, size_t size,
+ 				     const efi_memory_desc_t *md)
+ {
+ 	char *pos;
+ 	int type_len;
+ 	u64 attr;
+ 
+ 	pos = buf;
+ 	if (md->type >= ARRAY_SIZE(memory_type_name))
+ 		type_len = snprintf(pos, size, "[type=%u", md->type);
+ 	else
+ 		type_len = snprintf(pos, size, "[%-*s",
+ 				    (int)(sizeof(memory_type_name[0]) - 1),
+ 				    memory_type_name[md->type]);
+ 	if (type_len >= size)
+ 		return buf;
+ 
+ 	pos += type_len;
+ 	size -= type_len;
+ 
+ 	attr = md->attribute;
+ 	if (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
+ 		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
+ 		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
+ 		     EFI_MEMORY_NV |
+ 		     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))
+ 		snprintf(pos, size, "|attr=0x%016llx]",
+ 			 (unsigned long long)attr);
+ 	else
+ 		snprintf(pos, size,
+ 			 "|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]",
+ 			 attr & EFI_MEMORY_RUNTIME ? "RUN" : "",
+ 			 attr & EFI_MEMORY_MORE_RELIABLE ? "MR" : "",
+ 			 attr & EFI_MEMORY_NV      ? "NV"  : "",
+ 			 attr & EFI_MEMORY_XP      ? "XP"  : "",
+ 			 attr & EFI_MEMORY_RP      ? "RP"  : "",
+ 			 attr & EFI_MEMORY_WP      ? "WP"  : "",
+ 			 attr & EFI_MEMORY_RO      ? "RO"  : "",
+ 			 attr & EFI_MEMORY_UCE     ? "UCE" : "",
+ 			 attr & EFI_MEMORY_WB      ? "WB"  : "",
+ 			 attr & EFI_MEMORY_WT      ? "WT"  : "",
+ 			 attr & EFI_MEMORY_WC      ? "WC"  : "",
+ 			 attr & EFI_MEMORY_UC      ? "UC"  : "");
+ 	return buf;
+ }
+ 
+ /*
+  * efi_mem_attributes - lookup memmap attributes for physical address
+  * @phys_addr: the physical address to lookup
+  *
+  * Search in the EFI memory map for the region covering
+  * @phys_addr. Returns the EFI memory attributes if the region
+  * was found in the memory map, 0 otherwise.
+  *
+  * Despite being marked __weak, most architectures should *not*
+  * override this function. It is __weak solely for the benefit
+  * of ia64 which has a funky EFI memory map that doesn't work
+  * the same way as other architectures.
+  */
+ u64 __weak efi_mem_attributes(unsigned long phys_addr)
+ {
+ 	efi_memory_desc_t *md;
+ 
+ 	if (!efi_enabled(EFI_MEMMAP))
+ 		return 0;
+ 
+ 	for_each_efi_memory_desc(md) {
+ 		if ((md->phys_addr <= phys_addr) &&
+ 		    (phys_addr < (md->phys_addr +
+ 		    (md->num_pages << EFI_PAGE_SHIFT))))
+ 			return md->attribute;
+ 	}
+ 	return 0;
+ }
+ 
+ int efi_status_to_err(efi_status_t status)
+ {
+ 	int err;
+ 
+ 	switch (status) {
+ 	case EFI_SUCCESS:
+ 		err = 0;
+ 		break;
+ 	case EFI_INVALID_PARAMETER:
+ 		err = -EINVAL;
+ 		break;
+ 	case EFI_OUT_OF_RESOURCES:
+ 		err = -ENOSPC;
+ 		break;
+ 	case EFI_DEVICE_ERROR:
+ 		err = -EIO;
+ 		break;
+ 	case EFI_WRITE_PROTECTED:
+ 		err = -EROFS;
+ 		break;
+ 	case EFI_SECURITY_VIOLATION:
+ 		err = -EACCES;
+ 		break;
+ 	case EFI_NOT_FOUND:
+ 		err = -ENOENT;
+ 		break;
+ 	case EFI_ABORTED:
+ 		err = -EINTR;
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ bool efi_is_table_address(unsigned long phys_addr)
+ {
+ 	unsigned int i;
+ 
+ 	if (phys_addr == EFI_INVALID_TABLE_ADDR)
+ 		return false;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(efi_tables); i++)
+ 		if (*(efi_tables[i]) == phys_addr)
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ #ifdef CONFIG_KEXEC
+ static int update_efi_random_seed(struct notifier_block *nb,
+ 				  unsigned long code, void *unused)
+ {
+ 	struct linux_efi_random_seed *seed;
+ 	u32 size = 0;
+ 
+ 	if (!kexec_in_progress)
+ 		return NOTIFY_DONE;
+ 
+ 	seed = memremap(efi.rng_seed, sizeof(*seed), MEMREMAP_WB);
+ 	if (seed != NULL) {
+ 		size = min(seed->size, 32U);
+ 		memunmap(seed);
+ 	} else {
+ 		pr_err("Could not map UEFI random seed!\n");
+ 	}
+ 	if (size > 0) {
+ 		seed = memremap(efi.rng_seed, sizeof(*seed) + size,
+ 				MEMREMAP_WB);
+ 		if (seed != NULL) {
+ 			seed->size = size;
+ 			get_random_bytes(seed->bits, seed->size);
+ 			memunmap(seed);
++>>>>>>> a19d66c56af1 (efi: Add an EFI table address match function)
  		} else {
 -			pr_err("Could not map UEFI random seed!\n");
 +			guid = ((efi_config_table_32_t *)tablep)->guid;
 +			table = ((efi_config_table_32_t *)tablep)->table;
  		}
 -	}
 -	return NOTIFY_DONE;
 -}
  
 -static struct notifier_block efi_random_seed_nb = {
 -	.notifier_call = update_efi_random_seed,
 -};
 +		if (!match_config_table(&guid, table, common_tables))
 +			match_config_table(&guid, table, arch_tables);
  
 -static int register_update_efi_random_seed(void)
 -{
 -	if (efi.rng_seed == EFI_INVALID_TABLE_ADDR)
 -		return 0;
 -	return register_reboot_notifier(&efi_random_seed_nb);
 +		tablep += sz;
 +	}
 +	pr_cont("\n");
 +	early_iounmap(config_tables, efi.systab->nr_tables * sz);
 +	return 0;
  }
 -late_initcall(register_update_efi_random_seed);
 -#endif
diff --cc include/linux/efi.h
index 0dc4ddccc847,8e24f099bd3f..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -949,25 -1076,45 +949,36 @@@ extern int __init efi_setup_pcdp_consol
  #define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
  #define EFI_MEMMAP		4	/* Can we use EFI memory map? */
  #define EFI_64BIT		5	/* Is the firmware 64-bit? */
 -#define EFI_PARAVIRT		6	/* Access is via a paravirt interface */
 +#define EFI_SECURE_BOOT		6	/* Area we in Secure Boot mode? */
  #define EFI_ARCH_1		7	/* First arch-specific bit */
 -#define EFI_DBG			8	/* Print additional debug info at runtime */
 -#define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
 -#define EFI_MEM_ATTR		10	/* Did firmware publish an EFI_MEMORY_ATTRIBUTES table? */
  
  #ifdef CONFIG_EFI
 -/*
 - * Test whether the above EFI_* bits are enabled.
 - */
 -static inline bool efi_enabled(int feature)
 +# ifdef CONFIG_X86
 +extern int efi_enabled(int facility);
 +# else
 +static inline int efi_enabled(int facility)
  {
 -	return test_bit(feature, &efi.flags) != 0;
 +	return 1;
  }
++<<<<<<< HEAD
 +# endif
++=======
+ extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
+ 
+ extern bool efi_is_table_address(unsigned long phys_addr);
++>>>>>>> a19d66c56af1 (efi: Add an EFI table address match function)
  #else
 -static inline bool efi_enabled(int feature)
 +static inline int efi_enabled(int facility)
  {
 -	return false;
 -}
 -static inline void
 -efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}
 -
 -static inline bool
 -efi_capsule_pending(int *reset_type)
 -{
 -	return false;
 +	return 0;
  }
+ 
+ static inline bool efi_is_table_address(unsigned long phys_addr)
+ {
+ 	return false;
+ }
  #endif
  
 -extern int efi_status_to_err(efi_status_t status);
 -
  /*
   * Variable Attributes
   */
* Unmerged path drivers/firmware/efi/efi.c
* Unmerged path include/linux/efi.h
