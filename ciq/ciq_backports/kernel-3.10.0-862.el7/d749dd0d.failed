qed: IGU read revised

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit d749dd0dc117e7b02fa3a169c431476d59d18950
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d749dd0d.failed

As a first step for relaxing various assumptions done by driver
about the IGU mapping, the driver is now going to read the entire
IGU into a shadow copy, and mark in its database each status block
that's relevant for it.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d749dd0dc117e7b02fa3a169c431476d59d18950)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_int.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_int.c
index ecbe08723a2b,2e280c498cd3..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_int.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.c
@@@ -3163,50 -1878,10 +3140,52 @@@ int qed_int_igu_read_cam(struct qed_hwf
  		}
  	}
  
++<<<<<<< HEAD
 +	/* There's a possibility the igu_sb_cnt_iov doesn't properly reflect
 +	 * the number of VF SBs [especially for first VF on engine, as we can't
 +	 * diffrentiate between empty entries and its entries].
 +	 * Since we don't really support more SBs than VFs today, prevent any
 +	 * such configuration by sanitizing the number of SBs to equal the
 +	 * number of VFs.
 +	 */
 +	if (IS_PF_SRIOV(p_hwfn)) {
 +		u16 total_vfs = p_hwfn->cdev->p_iov_info->total_vfs;
 +
 +		if (total_vfs < p_igu_info->free_blks) {
 +			DP_VERBOSE(p_hwfn,
 +				   (NETIF_MSG_INTR | QED_MSG_IOV),
 +				   "Limiting number of SBs for IOV - %04x --> %04x\n",
 +				   p_igu_info->free_blks,
 +				   p_hwfn->cdev->p_iov_info->total_vfs);
 +			p_igu_info->free_blks = total_vfs;
 +		} else if (total_vfs > p_igu_info->free_blks) {
 +			DP_NOTICE(p_hwfn,
 +				  "IGU has only %04x SBs for VFs while the device has %04x VFs\n",
 +				  p_igu_info->free_blks, total_vfs);
 +			return -EINVAL;
 +		}
 +	}
 +	p_igu_info->igu_sb_cnt_iov = p_igu_info->free_blks;
 +
 +	DP_VERBOSE(
 +		p_hwfn,
 +		NETIF_MSG_INTR,
 +		"IGU igu_base_sb=0x%x [IOV 0x%x] igu_sb_cnt=%d [IOV 0x%x] igu_dsb_id=0x%x\n",
 +		p_igu_info->igu_base_sb,
 +		p_igu_info->igu_base_sb_iov,
 +		p_igu_info->igu_sb_cnt,
 +		p_igu_info->igu_sb_cnt_iov,
 +		p_igu_info->igu_dsb_id);
 +
 +	if (p_igu_info->igu_base_sb == 0xffff ||
 +	    p_igu_info->igu_dsb_id == 0xffff ||
 +	    p_igu_info->igu_sb_cnt == 0) {
++=======
+ 	if (p_igu_info->igu_dsb_id == QED_SB_INVALID_IDX) {
++>>>>>>> d749dd0dc117 (qed: IGU read revised)
  		DP_NOTICE(p_hwfn,
- 			  "IGU CAM returned invalid values igu_base_sb=0x%x igu_sb_cnt=%d igu_dsb_id=0x%x\n",
- 			   p_igu_info->igu_base_sb,
- 			   p_igu_info->igu_sb_cnt,
- 			   p_igu_info->igu_dsb_id);
+ 			  "IGU CAM returned invalid values igu_dsb_id=0x%x\n",
+ 			  p_igu_info->igu_dsb_id);
  		return -EINVAL;
  	}
  
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index 1b5a3d62b9f3..c64a8f163acc 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -1167,7 +1167,7 @@ static void qed_init_cau_rt_data(struct qed_dev *cdev)
 
 		for (sb_id = 0; sb_id < QED_MAPPING_MEMORY_SIZE(cdev);
 		     sb_id++) {
-			p_block = &p_igu_info->igu_map.igu_blocks[sb_id];
+			p_block = &p_igu_info->entry[sb_id];
 			if (!p_block->is_pf)
 				continue;
 
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_int.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_int.h b/drivers/net/ethernet/qlogic/qed/qed_int.h
index a8e48e14efef..91424cf79f67 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_int.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_int.h
@@ -199,24 +199,23 @@ void qed_int_disable_post_isr_release(struct qed_dev *cdev);
 #define SB_ALIGNED_SIZE(p_hwfn)	\
 	ALIGNED_TYPE_SIZE(struct status_block, p_hwfn)
 
+#define QED_SB_INVALID_IDX      0xffff
+
 struct qed_igu_block {
 	u8	status;
 #define QED_IGU_STATUS_FREE     0x01
 #define QED_IGU_STATUS_VALID    0x02
 #define QED_IGU_STATUS_PF       0x04
+#define QED_IGU_STATUS_DSB      0x08
 
 	u8	vector_number;
 	u8	function_id;
 	u8	is_pf;
 };
 
-struct qed_igu_map {
-	struct qed_igu_block igu_blocks[MAX_TOT_SB_PER_PATH];
-};
-
 struct qed_igu_info {
-	struct qed_igu_map	igu_map;
-	u16			igu_dsb_id;
+	struct qed_igu_block entry[MAX_TOT_SB_PER_PATH];
+	u16 igu_dsb_id;
 	u16			igu_base_sb;
 	u16			igu_base_sb_iov;
 	u16			igu_sb_cnt;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_sriov.c b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c231e788de76..ac746195720e 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@ -393,7 +393,7 @@ static void qed_iov_clear_vf_igu_blocks(struct qed_hwfn *p_hwfn,
 
 	for (sb_id = 0; sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);
 	     sb_id++) {
-		p_sb = &p_hwfn->hw_info.p_igu_info->igu_map.igu_blocks[sb_id];
+		p_sb = &p_hwfn->hw_info.p_igu_info->entry[sb_id];
 		if ((p_sb->status & QED_IGU_STATUS_FREE) &&
 		    !(p_sb->status & QED_IGU_STATUS_PF)) {
 			val = qed_rd(p_hwfn, p_ptt,
@@ -872,7 +872,7 @@ static u8 qed_iov_alloc_vf_igu_sbs(struct qed_hwfn *p_hwfn,
 	int qid = 0, igu_id = 0;
 	u32 val = 0;
 
-	igu_blocks = p_hwfn->hw_info.p_igu_info->igu_map.igu_blocks;
+	igu_blocks = p_hwfn->hw_info.p_igu_info->entry;
 
 	if (num_rx_queues > p_hwfn->hw_info.p_igu_info->free_blks)
 		num_rx_queues = p_hwfn->hw_info.p_igu_info->free_blks;
@@ -931,8 +931,7 @@ static void qed_iov_free_vf_igu_sbs(struct qed_hwfn *p_hwfn,
 		SET_FIELD(val, IGU_MAPPING_LINE_VALID, 0);
 		qed_wr(p_hwfn, p_ptt, addr, val);
 
-		p_info->igu_map.igu_blocks[igu_id].status |=
-		    QED_IGU_STATUS_FREE;
+		p_info->entry[igu_id].status |= QED_IGU_STATUS_FREE;
 
 		p_hwfn->hw_info.p_igu_info->free_blks++;
 	}
