seccomp: add "seccomp" syscall

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Kees Cook <keescook@chromium.org>
commit 48dc92b9fc3926844257316e75ba11eb5c742b2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/48dc92b9.failed

This adds the new "seccomp" syscall with both an "operation" and "flags"
parameter for future expansion. The third argument is a pointer value,
used with the SECCOMP_SET_MODE_FILTER operation. Currently, flags must
be 0. This is functionally equivalent to prctl(PR_SET_SECCOMP, ...).

In addition to the TSYNC flag later in this patch series, there is a
non-zero chance that this syscall could be used for configuring a fixed
argument area for seccomp-tracer-aware processes to pass syscall arguments
in the future. Hence, the use of "seccomp" not simply "seccomp_add_filter"
for this syscall. Additionally, this syscall uses operation, flags,
and user pointer for arguments because strictly passing arguments via
a user pointer would mean seccomp itself would be unable to trivially
filter the seccomp syscall itself.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
	Reviewed-by: Andy Lutomirski <luto@amacapital.net>
(cherry picked from commit 48dc92b9fc3926844257316e75ba11eb5c742b2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/syscalls/syscall_32.tbl
#	arch/x86/syscalls/syscall_64.tbl
#	include/linux/syscalls.h
#	include/uapi/asm-generic/unistd.h
#	kernel/seccomp.c
diff --cc arch/x86/syscalls/syscall_32.tbl
index 09379ced3437,7527eac24122..000000000000
--- a/arch/x86/syscalls/syscall_32.tbl
+++ b/arch/x86/syscalls/syscall_32.tbl
@@@ -359,7 -359,5 +359,12 @@@
  350	i386	finit_module		sys_finit_module
  351	i386	sched_setattr		sys_sched_setattr
  352	i386	sched_getattr		sys_sched_getattr
++<<<<<<< HEAD
 +355	i386	getrandom		sys_getrandom
 +356	i386	memfd_create		sys_memfd_create
 +374	i386	userfaultfd		sys_userfaultfd
 +377	i386	copy_file_range		sys_copy_file_range
++=======
+ 353	i386	renameat2		sys_renameat2
+ 354	i386	seccomp			sys_seccomp
++>>>>>>> 48dc92b9fc39 (seccomp: add "seccomp" syscall)
diff --cc arch/x86/syscalls/syscall_64.tbl
index 9faa66509436,16272a6c12b7..000000000000
--- a/arch/x86/syscalls/syscall_64.tbl
+++ b/arch/x86/syscalls/syscall_64.tbl
@@@ -320,14 -320,10 +320,18 @@@
  311	64	process_vm_writev	sys_process_vm_writev
  312	common	kcmp			sys_kcmp
  313	common	finit_module		sys_finit_module
 -314	common	sched_setattr		sys_sched_setattr
 -315	common	sched_getattr		sys_sched_getattr
 +314	common  sched_setattr		sys_sched_setattr
 +315	common  sched_getattr		sys_sched_getattr
  316	common	renameat2		sys_renameat2
++<<<<<<< HEAD
 +318	common	getrandom		sys_getrandom
 +319	common	memfd_create		sys_memfd_create
 +320	common	kexec_file_load		sys_kexec_file_load
 +323	common	userfaultfd		sys_userfaultfd
 +326	common	copy_file_range		sys_copy_file_range
++=======
+ 317	common	seccomp			sys_seccomp
++>>>>>>> 48dc92b9fc39 (seccomp: add "seccomp" syscall)
  
  #
  # x32-specific system call numbers start at 512 to avoid cache impact
diff --cc include/linux/syscalls.h
index f951b8d99280,1713977ee26f..000000000000
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@@ -860,10 -866,6 +860,15 @@@ asmlinkage long sys_process_vm_writev(p
  asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type,
  			 unsigned long idx1, unsigned long idx2);
  asmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);
++<<<<<<< HEAD
 +asmlinkage long sys_getrandom(char __user *buf, size_t count,
 +			      unsigned int flags);
 +
 +asmlinkage long sys_copy_file_range(int fd_in, loff_t __user *off_in,
 +				    int fd_out, loff_t __user *off_out,
 +				    size_t len, unsigned int flags);
++=======
+ asmlinkage long sys_seccomp(unsigned int op, unsigned int flags,
+ 			    const char __user *uargs);
++>>>>>>> 48dc92b9fc39 (seccomp: add "seccomp" syscall)
  #endif
diff --cc include/uapi/asm-generic/unistd.h
index 525a70c4372a,65acbf0e2867..000000000000
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@@ -692,13 -693,17 +692,27 @@@ __SC_COMP(__NR_process_vm_writev, sys_p
  __SYSCALL(__NR_kcmp, sys_kcmp)
  #define __NR_finit_module 273
  __SYSCALL(__NR_finit_module, sys_finit_module)
++<<<<<<< HEAD
 +#define __NR_getrandom 278
 +__SYSCALL(__NR_getrandom, sys_getrandom)
 +#define __NR_copy_file_range 285
 +__SYSCALL(__NR_copy_file_range, sys_copy_file_range)
 +
 +#undef __NR_syscalls
 +#define __NR_syscalls 286
++=======
+ #define __NR_sched_setattr 274
+ __SYSCALL(__NR_sched_setattr, sys_sched_setattr)
+ #define __NR_sched_getattr 275
+ __SYSCALL(__NR_sched_getattr, sys_sched_getattr)
+ #define __NR_renameat2 276
+ __SYSCALL(__NR_renameat2, sys_renameat2)
+ #define __NR_seccomp 277
+ __SYSCALL(__NR_seccomp, sys_seccomp)
+ 
+ #undef __NR_syscalls
+ #define __NR_syscalls 278
++>>>>>>> 48dc92b9fc39 (seccomp: add "seccomp" syscall)
  
  /*
   * All syscalls below here should go away really,
diff --cc kernel/seccomp.c
index dab81904040f,f0652578af75..000000000000
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@@ -309,7 -315,7 +310,11 @@@ fail
   *
   * Returns 0 on success and non-zero otherwise.
   */
++<<<<<<< HEAD
 +long seccomp_attach_user_filter(char __user *user_filter)
++=======
+ static long seccomp_attach_user_filter(const char __user *user_filter)
++>>>>>>> 48dc92b9fc39 (seccomp: add "seccomp" syscall)
  {
  	struct sock_fprog fprog;
  	long ret = -EFAULT;
diff --git a/arch/Kconfig b/arch/Kconfig
index 4fa0b0631a54..f913f98ecf10 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -335,6 +335,7 @@ config HAVE_ARCH_SECCOMP_FILTER
 	  - secure_computing is called from a ptrace_event()-safe context
 	  - secure_computing return value is checked and a return value of -1
 	    results in the system call being skipped immediately.
+	  - seccomp syscall wired up
 
 config SECCOMP_FILTER
 	def_bool y
* Unmerged path arch/x86/syscalls/syscall_32.tbl
* Unmerged path arch/x86/syscalls/syscall_64.tbl
* Unmerged path include/linux/syscalls.h
* Unmerged path include/uapi/asm-generic/unistd.h
diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index ac2dc9f72973..b258878ba754 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -10,6 +10,10 @@
 #define SECCOMP_MODE_STRICT	1 /* uses hard-coded filter. */
 #define SECCOMP_MODE_FILTER	2 /* uses user-supplied filter. */
 
+/* Valid operations for seccomp syscall. */
+#define SECCOMP_SET_MODE_STRICT	0
+#define SECCOMP_SET_MODE_FILTER	1
+
 /*
  * All BPF programs must return a 32-bit value.
  * The bottom 16-bits are for optional return data.
* Unmerged path kernel/seccomp.c
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 1dd5def0605d..6a30bab7e308 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -215,3 +215,6 @@ cond_syscall(compat_sys_open_by_handle_at);
 
 /* compare kernel pointers */
 cond_syscall(sys_kcmp);
+
+/* operate on Secure Computing state */
+cond_syscall(sys_seccomp);
