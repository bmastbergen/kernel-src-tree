sbitmap: push per-cpu last_tag into sbitmap_queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Omar Sandoval <osandov@fb.com>
commit 40aabb67464d5aad9ca3d2a5fedee56e2ff45aa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/40aabb67.failed

Allocating your own per-cpu allocation hint separately makes for an
awkward API. Instead, allocate the per-cpu hint as part of the struct
sbitmap_queue. There's no point for a struct sbitmap_queue without the
cache, but you can still use a bare struct sbitmap.

	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 40aabb67464d5aad9ca3d2a5fedee56e2ff45aa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.c
#	block/blk-mq.h
#	include/linux/sbitmap.h
#	lib/sbitmap.c
diff --cc block/blk-mq-tag.c
index 7e6885bccaac,c9a22dbbbda1..000000000000
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@@ -144,134 -91,35 +144,157 @@@ static inline bool hctx_may_queue(struc
  	return atomic_read(&hctx->nr_active) < depth;
  }
  
++<<<<<<< HEAD
 +static int __bt_get_word(struct blk_align_bitmap *bm, unsigned int last_tag)
 +{
 +	int tag, org_last_tag = last_tag;
 +
 +	while (1) {
 +		tag = find_next_zero_bit(&bm->word, bm->depth, last_tag);
 +		if (unlikely(tag >= bm->depth)) {
 +			/*
 +			 * We started with an offset, and we didn't reset the
 +			 * offset to 0 in a failure case, so start from 0 to
 +			 * exhaust the map.
 +			 */
 +			if (org_last_tag && last_tag) {
 +				last_tag = org_last_tag = 0;
 +				continue;
 +			}
 +			return -1;
 +		}
 +
 +		if (!test_and_set_bit(tag, &bm->word))
 +			break;
 +
 +		last_tag = tag + 1;
 +		if (last_tag >= bm->depth - 1)
 +			last_tag = 0;
 +	}
 +
 +	return tag;
 +}
 +
 +/*
 + * Straight forward bitmap tag implementation, where each bit is a tag
 + * (cleared == free, and set == busy). The small twist is using per-cpu
 + * last_tag caches, which blk-mq stores in the blk_mq_ctx software queue
 + * contexts. This enables us to drastically limit the space searched,
 + * without dirtying an extra shared cacheline like we would if we stored
 + * the cache value inside the shared blk_mq_bitmap_tags structure. On top
 + * of that, each word of tags is in a separate cacheline. This means that
 + * multiple users will tend to stick to different cachelines, at least
 + * until the map is exhausted.
 + */
 +static int __bt_get(struct blk_mq_hw_ctx *hctx, struct blk_mq_bitmap_tags *bt,
 +		    unsigned int *tag_cache)
 +{
 +	unsigned int last_tag, org_last_tag;
 +	int index, i, tag;
 +
 +	if (!hctx_may_queue(hctx, bt))
 +		return -1;
 +
 +	last_tag = org_last_tag = *tag_cache;
 +	index = TAG_TO_INDEX(bt, last_tag);
 +
 +	for (i = 0; i < bt->map_nr; i++) {
 +		tag = __bt_get_word(&bt->map[index], TAG_TO_BIT(bt, last_tag));
 +		if (tag != -1) {
 +			tag += (index << bt->bits_per_word);
 +			goto done;
 +		}
 +
 +		/*
 +		 * Jump to next index, and reset the last tag to be the
 +		 * first tag of that index
 +		 */
 +		index++;
 +		last_tag = (index << bt->bits_per_word);
 +
 +		if (index >= bt->map_nr) {
 +			index = 0;
 +			last_tag = 0;
 +		}
 +	}
 +
 +	*tag_cache = 0;
 +	return -1;
 +
 +	/*
 +	 * Only update the cache from the allocation path, if we ended
 +	 * up using the specific cached tag.
 +	 */
 +done:
 +	if (tag == org_last_tag) {
 +		last_tag = tag + 1;
 +		if (last_tag >= bt->depth - 1)
 +			last_tag = 0;
 +
 +		*tag_cache = last_tag;
 +	}
 +
 +	return tag;
 +}
 +
 +static struct bt_wait_state *bt_wait_ptr(struct blk_mq_bitmap_tags *bt,
 +					 struct blk_mq_hw_ctx *hctx)
++=======
+ #define BT_ALLOC_RR(tags) (tags->alloc_policy == BLK_TAG_ALLOC_RR)
+ 
+ static int __bt_get(struct blk_mq_hw_ctx *hctx, struct sbitmap_queue *bt,
+ 		    struct blk_mq_tags *tags)
+ {
+ 	if (!hctx_may_queue(hctx, bt))
+ 		return -1;
+ 	return __sbitmap_queue_get(bt, BT_ALLOC_RR(tags));
+ }
+ 
+ static int bt_get(struct blk_mq_alloc_data *data, struct sbitmap_queue *bt,
+ 		  struct blk_mq_hw_ctx *hctx, struct blk_mq_tags *tags)
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
 +{
 +	struct bt_wait_state *bs;
 +	int wait_index;
 +
 +	if (!hctx)
 +		return &bt->bs[0];
 +
 +	wait_index = atomic_read(&hctx->wait_index);
 +	bs = &bt->bs[wait_index];
 +	bt_index_atomic_inc(&hctx->wait_index);
 +	return bs;
 +}
 +
 +static int bt_get(struct blk_mq_alloc_data *data,
 +		struct blk_mq_bitmap_tags *bt,
 +		struct blk_mq_hw_ctx *hctx,
 +		unsigned int *last_tag)
  {
 -	struct sbq_wait_state *ws;
 +	struct bt_wait_state *bs;
  	DEFINE_WAIT(wait);
  	int tag;
  
++<<<<<<< HEAD
 +	tag = __bt_get(hctx, bt, last_tag);
++=======
+ 	tag = __bt_get(hctx, bt, tags);
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  	if (tag != -1)
  		return tag;
  
  	if (data->flags & BLK_MQ_REQ_NOWAIT)
  		return -1;
  
 -	ws = bt_wait_ptr(bt, hctx);
 +	bs = bt_wait_ptr(bt, hctx);
  	do {
 -		prepare_to_wait(&ws->wait, &wait, TASK_UNINTERRUPTIBLE);
 +		prepare_to_wait(&bs->wait, &wait, TASK_UNINTERRUPTIBLE);
  
++<<<<<<< HEAD
 +		tag = __bt_get(hctx, bt, last_tag);
++=======
+ 		tag = __bt_get(hctx, bt, tags);
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  		if (tag != -1)
  			break;
  
@@@ -288,7 -136,7 +311,11 @@@
  		 * Retry tag allocation after running the hardware queue,
  		 * as running the queue may also have found completions.
  		 */
++<<<<<<< HEAD
 +		tag = __bt_get(hctx, bt, last_tag);
++=======
+ 		tag = __bt_get(hctx, bt, tags);
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  		if (tag != -1)
  			break;
  
@@@ -319,7 -166,7 +345,11 @@@ static unsigned int __blk_mq_get_tag(st
  	int tag;
  
  	tag = bt_get(data, &data->hctx->tags->bitmap_tags, data->hctx,
++<<<<<<< HEAD
 +			&data->ctx->last_tag);
++=======
+ 		     data->hctx->tags);
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  	if (tag >= 0)
  		return tag + data->hctx->tags->nr_reserved_tags;
  
@@@ -335,7 -182,8 +365,12 @@@ static unsigned int __blk_mq_get_reserv
  		return BLK_MQ_TAG_FAIL;
  	}
  
++<<<<<<< HEAD
 +	tag = bt_get(data, &data->hctx->tags->breserved_tags, NULL, &zero);
++=======
+ 	tag = bt_get(data, &data->hctx->tags->breserved_tags, NULL,
+ 		     data->hctx->tags);
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  	if (tag < 0)
  		return BLK_MQ_TAG_FAIL;
  
@@@ -349,55 -197,8 +384,60 @@@ unsigned int blk_mq_get_tag(struct blk_
  	return __blk_mq_get_tag(data);
  }
  
++<<<<<<< HEAD
 +static struct bt_wait_state *bt_wake_ptr(struct blk_mq_bitmap_tags *bt)
 +{
 +	int i, wake_index;
 +
 +	wake_index = atomic_read(&bt->wake_index);
 +	for (i = 0; i < BT_WAIT_QUEUES; i++) {
 +		struct bt_wait_state *bs = &bt->bs[wake_index];
 +
 +		if (waitqueue_active(&bs->wait)) {
 +			int o = atomic_read(&bt->wake_index);
 +			if (wake_index != o)
 +				atomic_cmpxchg(&bt->wake_index, o, wake_index);
 +
 +			return bs;
 +		}
 +
 +		wake_index = bt_index_inc(wake_index);
 +	}
 +
 +	return NULL;
 +}
 +
 +static void bt_clear_tag(struct blk_mq_bitmap_tags *bt, unsigned int tag)
 +{
 +	const int index = TAG_TO_INDEX(bt, tag);
 +	struct bt_wait_state *bs;
 +	int wait_cnt;
 +
 +	clear_bit(TAG_TO_BIT(bt, tag), &bt->map[index].word);
 +
 +	/* Ensure that the wait list checks occur after clear_bit(). */
 +	smp_mb();
 +
 +	bs = bt_wake_ptr(bt);
 +	if (!bs)
 +		return;
 +
 +	wait_cnt = atomic_dec_return(&bs->wait_cnt);
 +	if (unlikely(wait_cnt < 0))
 +		wait_cnt = atomic_inc_return(&bs->wait_cnt);
 +	if (wait_cnt == 0) {
 +		atomic_add(bt->wake_cnt, &bs->wait_cnt);
 +		bt_index_atomic_inc(&bt->wake_index);
 +		wake_up(&bs->wait);
 +	}
 +}
 +
 +void blk_mq_put_tag(struct blk_mq_hw_ctx *hctx, unsigned int tag,
 +		    unsigned int *last_tag)
++=======
+ void blk_mq_put_tag(struct blk_mq_hw_ctx *hctx, struct blk_mq_ctx *ctx,
+ 		    unsigned int tag)
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  {
  	struct blk_mq_tags *tags = hctx->tags;
  
@@@ -405,11 -206,12 +445,20 @@@
  		const int real_tag = tag - tags->nr_reserved_tags;
  
  		BUG_ON(real_tag >= tags->nr_tags);
++<<<<<<< HEAD
 +		bt_clear_tag(&tags->bitmap_tags, real_tag);
 +		*last_tag = real_tag;
 +	} else {
 +		BUG_ON(tag >= tags->nr_reserved_tags);
 +		bt_clear_tag(&tags->breserved_tags, tag);
++=======
+ 		sbitmap_queue_clear(&tags->bitmap_tags, real_tag,
+ 				    BT_ALLOC_RR(tags), ctx->cpu);
+ 	} else {
+ 		BUG_ON(tag >= tags->nr_reserved_tags);
+ 		sbitmap_queue_clear(&tags->breserved_tags, tag,
+ 				    BT_ALLOC_RR(tags), ctx->cpu);
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  	}
  }
  
diff --cc block/blk-mq.h
index 2398ba3734aa,9b15d2ef7f7b..000000000000
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@@ -14,9 -12,6 +14,12 @@@ struct blk_mq_ctx 
  	unsigned int		cpu;
  	unsigned int		index_hw;
  
++<<<<<<< HEAD
 +	RH_KABI_REPLACE_UNSAFE(unsigned int ipi_redirect,
 +		               unsigned int last_tag ____cacheline_aligned_in_smp)
 +
++=======
++>>>>>>> 40aabb67464d (sbitmap: push per-cpu last_tag into sbitmap_queue)
  	/* incremented at dispatch time */
  	unsigned long		rq_dispatched[2];
  	unsigned long		rq_merged;
* Unmerged path include/linux/sbitmap.h
* Unmerged path lib/sbitmap.c
* Unmerged path block/blk-mq-tag.c
diff --git a/block/blk-mq-tag.h b/block/blk-mq-tag.h
index 5cdeb865c8ff..7a10ece00ef7 100644
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@ -51,7 +51,8 @@ extern struct blk_mq_tags *blk_mq_init_tags(unsigned int nr_tags, unsigned int r
 extern void blk_mq_free_tags(struct blk_mq_tags *tags);
 
 extern unsigned int blk_mq_get_tag(struct blk_mq_alloc_data *data);
-extern void blk_mq_put_tag(struct blk_mq_hw_ctx *hctx, unsigned int tag, unsigned int *last_tag);
+extern void blk_mq_put_tag(struct blk_mq_hw_ctx *hctx, struct blk_mq_ctx *ctx,
+			   unsigned int tag);
 extern bool blk_mq_has_free_tags(struct blk_mq_tags *tags);
 extern ssize_t blk_mq_tag_sysfs_show(struct blk_mq_tags *tags, char *page);
 extern void blk_mq_tag_init_last_tag(struct blk_mq_tags *tags, unsigned int *last_tag);
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 49418900af65..4fce17781a74 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -365,7 +365,7 @@ static void __blk_mq_free_request(struct blk_mq_hw_ctx *hctx,
 	rq->cmd_flags = 0;
 
 	clear_bit(REQ_ATOM_STARTED, &rq->atomic_flags);
-	blk_mq_put_tag(hctx, tag, &ctx->last_tag);
+	blk_mq_put_tag(hctx, ctx, tag);
 	blk_queue_exit(q);
 }
 
* Unmerged path block/blk-mq.h
* Unmerged path include/linux/sbitmap.h
* Unmerged path lib/sbitmap.c
