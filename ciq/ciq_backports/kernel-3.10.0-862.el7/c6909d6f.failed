i2c: slave: print warning if slave flag not set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [i2c] slave: print warning if slave flag not set (Gopal Tiwari) [1456705]
Rebuild_FUZZ: 94.38%
commit-author Wolfram Sang <wsa+renesas@sang-engineering.com>
commit c6909d6f6f1082b8bb4c1b0ef3460a005c9dcb4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c6909d6f.failed

Address collisions will be rare, but we should let the user know that
slaves have their own address space nonetheless.

	Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit c6909d6f6f1082b8bb4c1b0ef3460a005c9dcb4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/i2c-core.c
diff --cc drivers/i2c/i2c-core.c
index 8ce1e36d3552,a6780289c61d..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -2682,6 -3007,72 +2682,75 @@@ s32 i2c_smbus_xfer(struct i2c_adapter *
  }
  EXPORT_SYMBOL(i2c_smbus_xfer);
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_I2C_SLAVE)
+ int i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb)
+ {
+ 	int ret;
+ 
+ 	if (!client || !slave_cb) {
+ 		WARN(1, "insufficent data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!(client->flags & I2C_CLIENT_SLAVE))
+ 		dev_warn(&client->dev, "%s: client slave flag not set. You might see address collisions\n",
+ 			 __func__);
+ 
+ 	if (!(client->flags & I2C_CLIENT_TEN)) {
+ 		/* Enforce stricter address checking */
+ 		ret = i2c_check_7bit_addr_validity_strict(client->addr);
+ 		if (ret) {
+ 			dev_err(&client->dev, "%s: invalid address\n", __func__);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (!client->adapter->algo->reg_slave) {
+ 		dev_err(&client->dev, "%s: not supported by adapter\n", __func__);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	client->slave_cb = slave_cb;
+ 
+ 	i2c_lock_adapter(client->adapter);
+ 	ret = client->adapter->algo->reg_slave(client);
+ 	i2c_unlock_adapter(client->adapter);
+ 
+ 	if (ret) {
+ 		client->slave_cb = NULL;
+ 		dev_err(&client->dev, "%s: adapter returned error %d\n", __func__, ret);
+ 	}
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(i2c_slave_register);
+ 
+ int i2c_slave_unregister(struct i2c_client *client)
+ {
+ 	int ret;
+ 
+ 	if (!client->adapter->algo->unreg_slave) {
+ 		dev_err(&client->dev, "%s: not supported by adapter\n", __func__);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	i2c_lock_adapter(client->adapter);
+ 	ret = client->adapter->algo->unreg_slave(client);
+ 	i2c_unlock_adapter(client->adapter);
+ 
+ 	if (ret == 0)
+ 		client->slave_cb = NULL;
+ 	else
+ 		dev_err(&client->dev, "%s: adapter returned error %d\n", __func__, ret);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(i2c_slave_unregister);
+ #endif
+ 
++>>>>>>> c6909d6f6f10 (i2c: slave: print warning if slave flag not set)
  MODULE_AUTHOR("Simon G. Vogl <simon@tk.uni-linz.ac.at>");
  MODULE_DESCRIPTION("I2C-Bus main module");
  MODULE_LICENSE("GPL");
* Unmerged path drivers/i2c/i2c-core.c
