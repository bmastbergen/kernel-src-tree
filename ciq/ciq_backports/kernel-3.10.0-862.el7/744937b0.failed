efi: Clean up the efi_call_phys_[prolog|epilog]() save/restore interaction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ingo Molnar <mingo@kernel.org>
commit 744937b0b12a669f298949c4a810794c59fead98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/744937b0.failed

Currently x86-64 efi_call_phys_prolog() saves into a global variable (save_pgd),
and efi_call_phys_epilog() restores the kernel pagetables from that global
variable.

Change this to a cleaner save/restore pattern where the saving function returns
the saved object and the restore function restores that.

Apply the same concept to the 32-bit code as well.

Plus this approach, as an added bonus, allows us to express the
!efi_enabled(EFI_OLD_MEMMAP) situation in a clean fashion as well,
via a 'NULL' return value.

	Cc: Tapasweni Pathak <tapaswenipathak@gmail.com>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 744937b0b12a669f298949c4a810794c59fead98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/efi.h
#	arch/x86/platform/efi/efi_64.c
diff --cc arch/x86/include/asm/efi.h
index d1a2aa8edaf2,3738b138b843..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -1,6 -1,9 +1,12 @@@
  #ifndef _ASM_X86_EFI_H
  #define _ASM_X86_EFI_H
  
++<<<<<<< HEAD
++=======
+ #include <asm/i387.h>
+ #include <asm/pgtable.h>
+ 
++>>>>>>> 744937b0b12a (efi: Clean up the efi_call_phys_[prolog|epilog]() save/restore interaction)
  /*
   * We map the EFI regions needed for runtime services non-contiguously,
   * with preserved alignment on virtual addresses starting from -4G down
diff --cc arch/x86/platform/efi/efi_64.c
index 967c09f5fd5d,a0ac0f9c307f..000000000000
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@@ -78,79 -75,50 +76,99 @@@ static void __init early_code_mapping_s
  	}
  }
  
- void __init efi_call_phys_prolog(void)
+ pgd_t * __init efi_call_phys_prolog(void)
  {
++<<<<<<< HEAD
 +	unsigned long vaddr, addr_pgd, addr_pud;
 +	pgd_t *pgd_k, *pgd_efi;
 +	pud_t *pud;
++=======
+ 	unsigned long vaddress;
+ 	pgd_t *save_pgd;
++>>>>>>> 744937b0b12a (efi: Clean up the efi_call_phys_[prolog|epilog]() save/restore interaction)
  
  	int pgd;
 -	int n_pgds;
 +	int n_pgds, j;
  
  	if (!efi_enabled(EFI_OLD_MEMMAP))
- 		return;
+ 		return NULL;
  
  	early_code_mapping_set_exec(1);
  
  	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
  	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
  
 +	/*
 +	 * Build 1:1 ident mapping for old_map usage. It needs to be noticed
 +	 * that PAGE_OFFSET is PGDIR_SIZE aligned with KASLR disabled, while
 +	 * PUD_SIZE ALIGNED with KASLR enabled. So for a given physical
 +	 * address X, the pud_index(X) != pud_index(__va(X)), we can only copy
 +	 * pud entry of __va(X) to fill in pud entry of X to build 1:1 mapping
 +	 * . Means here we can only reuse pmd table of direct mapping.
 +	 */
  	for (pgd = 0; pgd < n_pgds; pgd++) {
 -		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);
 -		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
 -		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
 +		addr_pgd = (unsigned long)(pgd * PGDIR_SIZE);
 +		vaddr = (unsigned long)__va(pgd * PGDIR_SIZE);
 +		pgd_efi = pgd_offset_k(addr_pgd);
 +		save_pgd[pgd] = *pgd_efi;
 +
 +		pud = pud_alloc(&init_mm, pgd_efi, addr_pgd);
 +		if (!pud) {
 +			pr_err("Failed to allocate pud table!\n");
 +			break;
 +		}
 +		for (j = 0; j < PTRS_PER_PUD; j++) {
 +			addr_pud = addr_pgd + j * PUD_SIZE;
 +			if (addr_pud > (max_pfn << PAGE_SHIFT))
 +				break;
 +			vaddr = (unsigned long)__va(addr_pud);
 +
 +			pgd_k = pgd_offset_k(vaddr);
 +			pud[j] = *pud_offset(pgd_k, vaddr);
 +		}
  	}
  	__flush_tlb_all();
+ 
+ 	return save_pgd;
  }
  
- void __init efi_call_phys_epilog(void)
+ void __init efi_call_phys_epilog(pgd_t *save_pgd)
  {
  	/*
  	 * After the lock is released, the original page table is restored.
  	 */
  	int pgd_idx;
++<<<<<<< HEAD
 +	int n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);
 +	pgd_t *pgd;
 +	pud_t *pud;
++=======
+ 	int nr_pgds;
++>>>>>>> 744937b0b12a (efi: Clean up the efi_call_phys_[prolog|epilog]() save/restore interaction)
  
- 	if (!efi_enabled(EFI_OLD_MEMMAP))
+ 	if (!save_pgd)
  		return;
  
++<<<<<<< HEAD
 +	for (pgd_idx = 0; pgd_idx < n_pgds; pgd_idx++) {
 +		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);
 +		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);
 +
 +		if (!(pgd_val(*pgd) & _PAGE_PRESENT))
 +			continue;
 +
 +		pud = (pud_t *)pgd_page_vaddr(*pgd);
 +		pud_free(&init_mm, pud);
 +	}
++=======
+ 	nr_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);
+ 
+ 	for (pgd_idx = 0; pgd_idx < nr_pgds; pgd_idx++)
+ 		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);
+ 
++>>>>>>> 744937b0b12a (efi: Clean up the efi_call_phys_[prolog|epilog]() save/restore interaction)
  	kfree(save_pgd);
+ 
  	__flush_tlb_all();
  	early_code_mapping_set_exec(0);
  }
* Unmerged path arch/x86/include/asm/efi.h
diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 889e12677753..887c51422cd9 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -247,8 +247,9 @@ static efi_status_t __init phys_efi_set_virtual_address_map(
 {
 	efi_status_t status;
 	unsigned long flags;
+	pgd_t *save_pgd;
 
-	efi_call_phys_prolog();
+	save_pgd = efi_call_phys_prolog();
 
 	/* Disable interrupts around EFI calls: */
 	local_irq_save(flags);
@@ -257,7 +258,7 @@ static efi_status_t __init phys_efi_set_virtual_address_map(
 			       descriptor_version, virtual_map);
 	local_irq_restore(flags);
 
-	efi_call_phys_epilog();
+	efi_call_phys_epilog(save_pgd);
 
 	return status;
 }
diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c
index 8d31c43f4852..adf258202c58 100644
--- a/arch/x86/platform/efi/efi_32.c
+++ b/arch/x86/platform/efi/efi_32.c
@@ -56,19 +56,24 @@ void __init efi_map_region(efi_memory_desc_t *md)
 void __init efi_map_region_fixed(efi_memory_desc_t *md) {}
 void __init parse_efi_setup(u64 phys_addr, u32 data_len) {}
 
-void __init efi_call_phys_prolog(void)
+pgd_t * __init efi_call_phys_prolog(void)
 {
 	struct desc_ptr gdt_descr;
+	pgd_t *save_pgd;
 
+	/* Current pgd is swapper_pg_dir, we'll restore it later: */
+	save_pgd = swapper_pg_dir;
 	load_cr3(initial_page_table);
 	__flush_tlb_all();
 
 	gdt_descr.address = __pa(get_cpu_gdt_table(0));
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
+
+	return save_pgd;
 }
 
-void __init efi_call_phys_epilog(void)
+void __init efi_call_phys_epilog(pgd_t *save_pgd)
 {
 	struct desc_ptr gdt_descr;
 
@@ -76,6 +81,6 @@ void __init efi_call_phys_epilog(void)
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 
-	load_cr3(swapper_pg_dir);
+	load_cr3(save_pgd);
 	__flush_tlb_all();
 }
* Unmerged path arch/x86/platform/efi/efi_64.c
