fsnotify: Free fsnotify_mark_connector when there is no mark attached

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 08991e83b7286635167bab40927665a90fb00d81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/08991e83.failed

Currently we free fsnotify_mark_connector structure only when inode /
vfsmount is getting freed. This can however impose noticeable memory
overhead when marks get attached to inodes only temporarily. So free the
connector structure once the last mark is detached from the object.
Since notification infrastructure can be working with the connector
under the protection of fsnotify_mark_srcu, we have to be careful and
free the fsnotify_mark_connector only after SRCU period passes.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 08991e83b7286635167bab40927665a90fb00d81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/inode.c
#	fs/mount.h
#	fs/notify/fsnotify.c
#	fs/notify/fsnotify.h
#	fs/notify/inode_mark.c
#	fs/notify/mark.c
#	fs/notify/vfsmount_mark.c
#	include/linux/fs.h
#	include/linux/fsnotify_backend.h
#	kernel/auditsc.c
diff --cc fs/inode.c
index aaf9ae90702b,131b2bcebc48..000000000000
--- a/fs/inode.c
+++ b/fs/inode.c
@@@ -237,8 -231,10 +237,12 @@@ EXPORT_SYMBOL(free_inode_nonrcu)
  void __destroy_inode(struct inode *inode)
  {
  	BUG_ON(inode_has_buffers(inode));
 -	inode_detach_wb(inode);
  	security_inode_free(inode);
  	fsnotify_inode_delete(inode);
++<<<<<<< HEAD
++=======
+ 	locks_free_lock_context(inode);
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  	if (!inode->i_nlink) {
  		WARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);
  		atomic_long_dec(&inode->i_sb->s_remove_count);
diff --cc fs/mount.h
index 2f04321d2531,bf1fda6eed8f..000000000000
--- a/fs/mount.h
+++ b/fs/mount.h
@@@ -56,7 -59,7 +56,11 @@@ struct mount 
  	struct mountpoint *mnt_mp;	/* where is it mounted */
  	struct hlist_node mnt_mp_list;	/* list mounts with the same mountpoint */
  #ifdef CONFIG_FSNOTIFY
++<<<<<<< HEAD
 +	struct hlist_head mnt_fsnotify_marks;
++=======
+ 	struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks;
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  	__u32 mnt_fsnotify_mask;
  #endif
  	int mnt_id;			/* mount identifier */
diff --cc fs/notify/fsnotify.c
index 0378955136d1,d512ef9f75fc..000000000000
--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@@ -226,16 -227,27 +226,40 @@@ int fsnotify(struct inode *to_tell, __u
  	idx = srcu_read_lock(&fsnotify_mark_srcu);
  
  	if ((mask & FS_MODIFY) ||
++<<<<<<< HEAD
 +	    (test_mask & to_tell->i_fsnotify_mask))
 +		inode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,
 +					      &fsnotify_mark_srcu);
 +
 +	if (mnt && ((mask & FS_MODIFY) ||
 +		    (test_mask & mnt->mnt_fsnotify_mask))) {
 +		vfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,
 +						 &fsnotify_mark_srcu);
 +		inode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,
 +					      &fsnotify_mark_srcu);
++=======
+ 	    (test_mask & to_tell->i_fsnotify_mask)) {
+ 		inode_conn = srcu_dereference(to_tell->i_fsnotify_marks,
+ 					      &fsnotify_mark_srcu);
+ 		if (inode_conn)
+ 			inode_node = srcu_dereference(inode_conn->list.first,
+ 						      &fsnotify_mark_srcu);
+ 	}
+ 
+ 	if (mnt && ((mask & FS_MODIFY) ||
+ 		    (test_mask & mnt->mnt_fsnotify_mask))) {
+ 		inode_conn = srcu_dereference(to_tell->i_fsnotify_marks,
+ 					      &fsnotify_mark_srcu);
+ 		if (inode_conn)
+ 			inode_node = srcu_dereference(inode_conn->list.first,
+ 						      &fsnotify_mark_srcu);
+ 		vfsmount_conn = srcu_dereference(mnt->mnt_fsnotify_marks,
+ 					         &fsnotify_mark_srcu);
+ 		if (vfsmount_conn)
+ 			vfsmount_node = srcu_dereference(
+ 						vfsmount_conn->list.first,
+ 						&fsnotify_mark_srcu);
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  	}
  
  	/*
diff --cc fs/notify/fsnotify.h
index 0a3bc2cf192c,72050b75ca8c..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -21,40 -18,21 +21,56 @@@ extern u32 fsnotify_recalc_mask(struct 
  extern int fsnotify_compare_groups(struct fsnotify_group *a,
  				   struct fsnotify_group *b);
  
 +extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 +						__u32 mask);
 +/* Add mark to a proper place in mark list */
 +extern int fsnotify_add_mark_list(struct hlist_head *head,
 +				  struct fsnotify_mark *mark,
 +				  int allow_dups);
 +/* add a mark to an inode */
 +extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 +				   struct fsnotify_group *group, struct inode *inode,
 +				   int allow_dups);
 +/* add a mark to a vfsmount */
 +extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 +				      struct fsnotify_group *group, struct vfsmount *mnt,
 +				      int allow_dups);
 +
 +/* vfsmount specific destruction of a mark */
 +extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 +/* inode specific destruction of a mark */
 +extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
  /* Find mark belonging to given group in the list of marks */
++<<<<<<< HEAD
 +extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 +						struct fsnotify_group *group);
 +/* Destroy all marks in the given list protected by 'lock' */
 +extern void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock);
 +/* run the list of all marks associated with inode and destroy them */
 +static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
 +{
 +	fsnotify_destroy_marks(&inode->i_fsnotify_marks, &inode->i_lock);
++=======
+ extern struct fsnotify_mark *fsnotify_find_mark(
+ 				struct fsnotify_mark_connector __rcu **connp,
+ 				struct fsnotify_group *group);
+ /* Destroy all marks connected via given connector */
+ extern void fsnotify_destroy_marks(struct fsnotify_mark_connector __rcu **connp);
+ /* run the list of all marks associated with inode and destroy them */
+ static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
+ {
+ 	fsnotify_destroy_marks(&inode->i_fsnotify_marks);
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  }
  /* run the list of all marks associated with vfsmount and destroy them */
  static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
  {
++<<<<<<< HEAD
 +	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks,
 +			       &mnt->mnt_root->d_lock);
++=======
+ 	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks);
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  }
  /* prepare for freeing all marks associated with given group */
  extern void fsnotify_detach_group_marks(struct fsnotify_group *group);
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,b9370316727e..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -79,66 -50,7 +79,70 @@@ void fsnotify_clear_inode_marks_by_grou
  struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,
  					       struct inode *inode)
  {
++<<<<<<< HEAD
 +	struct fsnotify_mark *mark;
 +
 +	spin_lock(&inode->i_lock);
 +	mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);
 +	spin_unlock(&inode->i_lock);
 +
 +	return mark;
 +}
 +
 +/*
 + * If we are setting a mark mask on an inode mark we should pin the inode
 + * in memory.
 + */
 +void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,
 +					 __u32 mask)
 +{
 +	struct inode *inode;
 +
 +	assert_spin_locked(&mark->lock);
 +
 +	if (mask &&
 +	    mark->inode &&
 +	    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {
 +		mark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;
 +		inode = igrab(mark->inode);
 +		/*
 +		 * we shouldn't be able to get here if the inode wasn't
 +		 * already safely held in memory.  But bug in case it
 +		 * ever is wrong.
 +		 */
 +		BUG_ON(!inode);
 +	}
 +}
 +
 +/*
 + * Attach an initialized mark to a given inode.
 + * These marks may be used for the fsnotify backend to determine which
 + * event types should be delivered to which group and for which inodes.  These
 + * marks are ordered according to priority, highest number first, and then by
 + * the group's location in memory.
 + */
 +int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 +			    struct fsnotify_group *group, struct inode *inode,
 +			    int allow_dups)
 +{
 +	int ret;
 +
 +	mark->flags |= FSNOTIFY_MARK_FLAG_INODE;
 +
 +	BUG_ON(!mutex_is_locked(&group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&inode->i_lock);
 +	mark->inode = inode;
 +	ret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,
 +				     allow_dups);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	return ret;
++=======
+ 	return fsnotify_find_mark(&inode->i_fsnotify_marks, group);
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  }
  
  /**
diff --cc fs/notify/mark.c
index 44836e539169,824095db5a3b..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -83,8 -85,11 +83,9 @@@
  #define FSNOTIFY_REAPER_DELAY	(1)	/* 1 jiffy */
  
  struct srcu_struct fsnotify_mark_srcu;
 -struct kmem_cache *fsnotify_mark_connector_cachep;
 -
  static DEFINE_SPINLOCK(destroy_lock);
  static LIST_HEAD(destroy_list);
+ static struct fsnotify_mark_connector *connector_destroy_list;
  
  static void fsnotify_mark_destroy_workfn(struct work_struct *work);
  static DECLARE_DELAYED_WORK(reaper_work, fsnotify_mark_destroy_workfn);
@@@ -109,9 -116,101 +113,104 @@@ u32 fsnotify_recalc_mask(struct hlist_h
  	u32 new_mask = 0;
  	struct fsnotify_mark *mark;
  
 -	assert_spin_locked(&conn->lock);
 -	hlist_for_each_entry(mark, &conn->list, obj_list)
 +	hlist_for_each_entry(mark, head, obj_list)
  		new_mask |= mark->mask;
++<<<<<<< HEAD
 +	return new_mask;
++=======
+ 
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		conn->inode->i_fsnotify_mask = new_mask;
+ 	else if (conn->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT)
+ 		real_mount(conn->mnt)->mnt_fsnotify_mask = new_mask;
+ }
+ 
+ /*
+  * Calculate mask of events for a list of marks. The caller must make sure
+  * connector cannot disappear under us (usually by holding a mark->lock or
+  * mark->group->mark_mutex for a mark on this list).
+  */
+ void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn)
+ {
+ 	if (!conn)
+ 		return;
+ 
+ 	spin_lock(&conn->lock);
+ 	__fsnotify_recalc_mask(conn);
+ 	spin_unlock(&conn->lock);
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
+ 		__fsnotify_update_child_dentry_flags(conn->inode);
+ }
+ 
+ /* Free all connectors queued for freeing once SRCU period ends */
+ static void fsnotify_connector_destroy_workfn(struct work_struct *work)
+ {
+ 	struct fsnotify_mark_connector *conn, *free;
+ 
+ 	spin_lock(&destroy_lock);
+ 	conn = connector_destroy_list;
+ 	connector_destroy_list = NULL;
+ 	spin_unlock(&destroy_lock);
+ 
+ 	synchronize_srcu(&fsnotify_mark_srcu);
+ 	while (conn) {
+ 		free = conn;
+ 		conn = conn->destroy_next;
+ 		kmem_cache_free(fsnotify_mark_connector_cachep, free);
+ 	}
+ }
+ 
+ 
+ static struct inode *fsnotify_detach_connector_from_object(
+ 					struct fsnotify_mark_connector *conn)
+ {
+ 	struct inode *inode = NULL;
+ 
+ 	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE) {
+ 		inode = conn->inode;
+ 		rcu_assign_pointer(inode->i_fsnotify_marks, NULL);
+ 		inode->i_fsnotify_mask = 0;
+ 		conn->inode = NULL;
+ 		conn->flags &= ~FSNOTIFY_OBJ_TYPE_INODE;
+ 	} else if (conn->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT) {
+ 		rcu_assign_pointer(real_mount(conn->mnt)->mnt_fsnotify_marks,
+ 				   NULL);
+ 		real_mount(conn->mnt)->mnt_fsnotify_mask = 0;
+ 		conn->mnt = NULL;
+ 		conn->flags &= ~FSNOTIFY_OBJ_TYPE_VFSMOUNT;
+ 	}
+ 
+ 	return inode;
+ }
+ 
+ static struct inode *fsnotify_detach_from_object(struct fsnotify_mark *mark)
+ {
+ 	struct fsnotify_mark_connector *conn;
+ 	struct inode *inode = NULL;
+ 	bool free_conn = false;
+ 
+ 	conn = mark->connector;
+ 	spin_lock(&conn->lock);
+ 	hlist_del_init_rcu(&mark->obj_list);
+ 	if (hlist_empty(&conn->list)) {
+ 		inode = fsnotify_detach_connector_from_object(conn);
+ 		free_conn = true;
+ 	} else {
+ 		__fsnotify_recalc_mask(conn);
+ 	}
+ 	mark->connector = NULL;
+ 	spin_unlock(&conn->lock);
+ 
+ 	if (free_conn) {
+ 		spin_lock(&destroy_lock);
+ 		conn->destroy_next = connector_destroy_list;
+ 		connector_destroy_list = conn;
+ 		spin_unlock(&destroy_lock);
+ 		queue_work(system_unbound_wq, &connector_reaper_work);
+ 	}
+ 
+ 	return inode;
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  }
  
  /*
@@@ -220,37 -314,6 +319,40 @@@ void fsnotify_destroy_mark(struct fsnot
  	fsnotify_free_mark(mark);
  }
  
++<<<<<<< HEAD
 +void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock)
 +{
 +	struct fsnotify_mark *mark;
 +
 +	while (1) {
 +		/*
 +		 * We have to be careful since we can race with e.g.
 +		 * fsnotify_clear_marks_by_group() and once we drop 'lock',
 +		 * mark can get removed from the obj_list and destroyed. But
 +		 * we are holding mark reference so mark cannot be freed and
 +		 * calling fsnotify_destroy_mark() more than once is fine.
 +		 */
 +		spin_lock(lock);
 +		if (hlist_empty(head)) {
 +			spin_unlock(lock);
 +			break;
 +		}
 +		mark = hlist_entry(head->first, struct fsnotify_mark, obj_list);
 +		/*
 +		 * We don't update i_fsnotify_mask / mnt_fsnotify_mask here
 +		 * since inode / mount is going away anyway. So just remove
 +		 * mark from the list.
 +		 */
 +		hlist_del_init_rcu(&mark->obj_list);
 +		fsnotify_get_mark(mark);
 +		spin_unlock(lock);
 +		fsnotify_destroy_mark(mark, mark->group);
 +		fsnotify_put_mark(mark);
 +	}
 +}
 +
++=======
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)
  {
  	assert_spin_locked(&mark->lock);
@@@ -304,17 -364,104 +406,118 @@@ int fsnotify_compare_groups(struct fsno
  	return -1;
  }
  
++<<<<<<< HEAD
 +/* Add mark into proper place in given list of marks */
 +int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,
 +			   int allow_dups)
 +{
 +	struct fsnotify_mark *lmark, *last = NULL;
 +	int cmp;
 +
 +	/* is mark the first mark? */
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&mark->obj_list, head);
 +		return 0;
++=======
+ static int fsnotify_attach_connector_to_object(
+ 				struct fsnotify_mark_connector __rcu **connp,
+ 				struct inode *inode,
+ 				struct vfsmount *mnt)
+ {
+ 	struct fsnotify_mark_connector *conn;
+ 
+ 	conn = kmem_cache_alloc(fsnotify_mark_connector_cachep, GFP_KERNEL);
+ 	if (!conn)
+ 		return -ENOMEM;
+ 	spin_lock_init(&conn->lock);
+ 	INIT_HLIST_HEAD(&conn->list);
+ 	if (inode) {
+ 		conn->flags = FSNOTIFY_OBJ_TYPE_INODE;
+ 		conn->inode = igrab(inode);
+ 	} else {
+ 		conn->flags = FSNOTIFY_OBJ_TYPE_VFSMOUNT;
+ 		conn->mnt = mnt;
+ 	}
+ 	/*
+ 	 * cmpxchg() provides the barrier so that readers of *connp can see
+ 	 * only initialized structure
+ 	 */
+ 	if (cmpxchg(connp, NULL, conn)) {
+ 		/* Someone else created list structure for us */
+ 		if (inode)
+ 			iput(inode);
+ 		kmem_cache_free(fsnotify_mark_connector_cachep, conn);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Get mark connector, make sure it is alive and return with its lock held.
+  * This is for users that get connector pointer from inode or mount. Users that
+  * hold reference to a mark on the list may directly lock connector->lock as
+  * they are sure list cannot go away under them.
+  */
+ static struct fsnotify_mark_connector *fsnotify_grab_connector(
+ 				struct fsnotify_mark_connector __rcu **connp)
+ {
+ 	struct fsnotify_mark_connector *conn;
+ 	int idx;
+ 
+ 	idx = srcu_read_lock(&fsnotify_mark_srcu);
+ 	conn = srcu_dereference(*connp, &fsnotify_mark_srcu);
+ 	if (!conn)
+ 		goto out;
+ 	spin_lock(&conn->lock);
+ 	if (!(conn->flags & (FSNOTIFY_OBJ_TYPE_INODE |
+ 			     FSNOTIFY_OBJ_TYPE_VFSMOUNT))) {
+ 		spin_unlock(&conn->lock);
+ 		srcu_read_unlock(&fsnotify_mark_srcu, idx);
+ 		return NULL;
+ 	}
+ out:
+ 	srcu_read_unlock(&fsnotify_mark_srcu, idx);
+ 	return conn;
+ }
+ 
+ /*
+  * Add mark into proper place in given list of marks. These marks may be used
+  * for the fsnotify backend to determine which event types should be delivered
+  * to which group and for which inodes. These marks are ordered according to
+  * priority, highest number first, and then by the group's location in memory.
+  */
+ static int fsnotify_add_mark_list(struct fsnotify_mark *mark,
+ 				  struct inode *inode, struct vfsmount *mnt,
+ 				  int allow_dups)
+ {
+ 	struct fsnotify_mark *lmark, *last = NULL;
+ 	struct fsnotify_mark_connector *conn;
+ 	struct fsnotify_mark_connector __rcu **connp;
+ 	int cmp;
+ 	int err = 0;
+ 
+ 	if (WARN_ON(!inode && !mnt))
+ 		return -EINVAL;
+ 	if (inode)
+ 		connp = &inode->i_fsnotify_marks;
+ 	else
+ 		connp = &real_mount(mnt)->mnt_fsnotify_marks;
+ restart:
+ 	spin_lock(&mark->lock);
+ 	conn = fsnotify_grab_connector(connp);
+ 	if (!conn) {
+ 		spin_unlock(&mark->lock);
+ 		err = fsnotify_attach_connector_to_object(connp, inode, mnt);
+ 		if (err)
+ 			return err;
+ 		goto restart;
+ 	}
+ 
+ 	/* is mark the first mark? */
+ 	if (hlist_empty(&conn->list)) {
+ 		hlist_add_head_rcu(&mark->obj_list, &conn->list);
+ 		goto added;
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  	}
  
  	/* should mark be in the middle of the current list? */
@@@ -419,14 -562,21 +622,29 @@@ int fsnotify_add_mark(struct fsnotify_m
   * Given a list of marks, find the mark associated with given group. If found
   * take a reference to that mark and return it, else return NULL.
   */
++<<<<<<< HEAD
 +struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 +					 struct fsnotify_group *group)
++=======
+ struct fsnotify_mark *fsnotify_find_mark(
+ 				struct fsnotify_mark_connector __rcu **connp,
+ 				struct fsnotify_group *group)
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  {
+ 	struct fsnotify_mark_connector *conn;
  	struct fsnotify_mark *mark;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry(mark, head, obj_list) {
++=======
+ 	conn = fsnotify_grab_connector(connp);
+ 	if (!conn)
+ 		return NULL;
+ 
+ 	hlist_for_each_entry(mark, &conn->list, obj_list) {
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  		if (mark->group == group) {
  			fsnotify_get_mark(mark);
 -			spin_unlock(&conn->lock);
  			return mark;
  		}
  	}
@@@ -499,6 -650,29 +717,32 @@@ void fsnotify_detach_group_marks(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /* Destroy all marks attached to inode / vfsmount */
+ void fsnotify_destroy_marks(struct fsnotify_mark_connector __rcu **connp)
+ {
+ 	struct fsnotify_mark_connector *conn;
+ 	struct fsnotify_mark *mark;
+ 
+ 	while ((conn = fsnotify_grab_connector(connp))) {
+ 		/*
+ 		 * We have to be careful since we can race with e.g.
+ 		 * fsnotify_clear_marks_by_group() and once we drop the list
+ 		 * lock, mark can get removed from the obj_list and destroyed.
+ 		 * But we are holding mark reference so mark cannot be freed
+ 		 * and calling fsnotify_destroy_mark() more than once is fine.
+ 		 */
+ 		mark = hlist_entry(conn->list.first, struct fsnotify_mark,
+ 				   obj_list);
+ 		fsnotify_get_mark(mark);
+ 		spin_unlock(&conn->lock);
+ 		fsnotify_destroy_mark(mark, mark->group);
+ 		fsnotify_put_mark(mark);
+ 	}
+ }
+ 
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  /*
   * Nothing fancy, just initialize lists and locks and counters.
   */
diff --cc fs/notify/vfsmount_mark.c
index a8fcab68faef,dd5f3fcbccfb..000000000000
--- a/fs/notify/vfsmount_mark.c
+++ b/fs/notify/vfsmount_mark.c
@@@ -72,37 -47,6 +72,41 @@@ struct fsnotify_mark *fsnotify_find_vfs
  						  struct vfsmount *mnt)
  {
  	struct mount *m = real_mount(mnt);
 +	struct fsnotify_mark *mark;
 +
++<<<<<<< HEAD
 +	spin_lock(&mnt->mnt_root->d_lock);
 +	mark = fsnotify_find_mark(&m->mnt_fsnotify_marks, group);
 +	spin_unlock(&mnt->mnt_root->d_lock);
 +
 +	return mark;
 +}
 +
 +/*
 + * Attach an initialized mark to a given group and vfsmount.
 + * These marks may be used for the fsnotify backend to determine which
 + * event types should be delivered to which groups.
 + */
 +int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 +			       struct fsnotify_group *group, struct vfsmount *mnt,
 +			       int allow_dups)
 +{
 +	struct mount *m = real_mount(mnt);
 +	int ret;
 +
 +	mark->flags |= FSNOTIFY_MARK_FLAG_VFSMOUNT;
 +
 +	BUG_ON(!mutex_is_locked(&group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +	mark->mnt = mnt;
 +	ret = fsnotify_add_mark_list(&m->mnt_fsnotify_marks, mark, allow_dups);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
  
 +	return ret;
++=======
+ 	return fsnotify_find_mark(&m->mnt_fsnotify_marks, group);
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  }
diff --cc include/linux/fs.h
index 4086333a0708,c0b6150c5fcc..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -663,12 -647,13 +663,16 @@@ struct inode 
  
  #ifdef CONFIG_FSNOTIFY
  	__u32			i_fsnotify_mask; /* all events this inode cares about */
++<<<<<<< HEAD
 +	struct hlist_head	i_fsnotify_marks;
++=======
+ 	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  #endif
  
 -#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
 -	struct fscrypt_info	*i_crypt_info;
 +#ifdef CONFIG_IMA
 +	atomic_t		i_readcount; /* struct files open RO */
  #endif
 -
  	void			*i_private; /* fs or device private pointer */
  };
  
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,84d71b6f75f6..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -195,6 -195,28 +195,31 @@@ struct fsnotify_group 
  #define FSNOTIFY_EVENT_INODE	2
  
  /*
++<<<<<<< HEAD
++=======
+  * Inode / vfsmount point to this structure which tracks all marks attached to
+  * the inode / vfsmount. The reference to inode / vfsmount is held by this
+  * structure. We destroy this structure when there are no more marks attached
+  * to it. The structure is protected by fsnotify_mark_srcu.
+  */
+ struct fsnotify_mark_connector {
+ 	spinlock_t lock;
+ #define FSNOTIFY_OBJ_TYPE_INODE		0x01
+ #define FSNOTIFY_OBJ_TYPE_VFSMOUNT	0x02
+ 	unsigned int flags;	/* Type of object [lock] */
+ 	union {	/* Object pointer [lock] */
+ 		struct inode *inode;
+ 		struct vfsmount *mnt;
+ 	};
+ 	union {
+ 		struct hlist_head list;
+ 		/* Used listing heads to free after srcu period expires */
+ 		struct fsnotify_mark_connector *destroy_next;
+ 	};
+ };
+ 
+ /*
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
   * A mark is simply an object attached to an in core inode which allows an
   * fsnotify listener to indicate they are either no longer interested in events
   * of a type matching mask or only interested in those events.
diff --cc kernel/auditsc.c
index 44710450e168,d383c33540af..000000000000
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@@ -1603,7 -1597,7 +1603,11 @@@ static inline void handle_one(const str
  	struct audit_tree_refs *p;
  	struct audit_chunk *chunk;
  	int count;
++<<<<<<< HEAD
 +	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
++=======
+ 	if (likely(!inode->i_fsnotify_marks))
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  		return;
  	context = current->audit_context;
  	p = context->trees;
@@@ -1645,8 -1639,8 +1649,13 @@@ retry
  	rcu_read_lock();
  	seq = read_seqbegin(&rename_lock);
  	for(;;) {
++<<<<<<< HEAD
 +		struct inode *inode = d->d_inode;
 +		if (inode && unlikely(!hlist_empty(&inode->i_fsnotify_marks))) {
++=======
+ 		struct inode *inode = d_backing_inode(d);
+ 		if (inode && unlikely(inode->i_fsnotify_marks)) {
++>>>>>>> 08991e83b728 (fsnotify: Free fsnotify_mark_connector when there is no mark attached)
  			struct audit_chunk *chunk;
  			chunk = audit_tree_lookup(inode);
  			if (chunk) {
* Unmerged path fs/inode.c
* Unmerged path fs/mount.h
* Unmerged path fs/notify/fsnotify.c
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/inode_mark.c
* Unmerged path fs/notify/mark.c
* Unmerged path fs/notify/vfsmount_mark.c
* Unmerged path include/linux/fs.h
* Unmerged path include/linux/fsnotify_backend.h
* Unmerged path kernel/auditsc.c
