pipe: simplify logic in alloc_pipe_info()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Michael Kerrisk (man-pages) <mtk.manpages@gmail.com>
commit 09b4d1990094dd22c27fb0163534db419458569c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/09b4d199.failed

Replace an 'if' block that covers most of the code in this function
with a 'goto'. This makes the code a little simpler to read, and also
simplifies the next patch (fix limit checking in alloc_pipe_info())

Link: http://lkml.kernel.org/r/aef030c1-0257-98a9-4988-186efa48530c@gmail.com
	Signed-off-by: Michael Kerrisk <mtk.manpages@gmail.com>
	Reviewed-by: Vegard Nossum <vegard.nossum@oracle.com>
	Cc: Willy Tarreau <w@1wt.eu>
	Cc: <socketpair@gmail.com>
	Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: Jens Axboe <axboe@fb.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 09b4d1990094dd22c27fb0163534db419458569c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/pipe.c
diff --cc fs/pipe.c
index 771f837999b4,eaa3c8d36291..000000000000
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@@ -823,31 -622,34 +823,59 @@@ static bool too_many_pipe_buffers_hard(
  struct pipe_inode_info *alloc_pipe_info(void)
  {
  	struct pipe_inode_info *pipe;
+ 	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
+ 	struct user_struct *user = get_current_user();
  
++<<<<<<< HEAD
 +	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
 +	if (pipe) {
 +		unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
 +		struct user_struct *user = get_current_user();
 +
 +		if (!too_many_pipe_buffers_hard(user)) {
 +			if (too_many_pipe_buffers_soft(user))
 +				pipe_bufs = 1;
 +			pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);
 +		}
 +
 +		if (pipe->bufs) {
 +			init_waitqueue_head(&pipe->wait);
 +			pipe->r_counter = pipe->w_counter = 1;
 +			pipe->buffers = pipe_bufs;
 +			pipe->user = user;
 +			account_pipe_buffers(user, 0, pipe_bufs);
 +			mutex_init(&pipe->mutex);
 +			return pipe;
 +		}
 +		free_uid(user);
 +		kfree(pipe);
++=======
+ 	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
+ 	if (pipe == NULL)
+ 		goto out_free_uid;
+ 
+ 	if (!too_many_pipe_buffers_hard(user)) {
+ 		if (too_many_pipe_buffers_soft(user))
+ 			pipe_bufs = 1;
+ 		pipe->bufs = kcalloc(pipe_bufs,
+ 				     sizeof(struct pipe_buffer),
+ 				     GFP_KERNEL_ACCOUNT);
++>>>>>>> 09b4d1990094 (pipe: simplify logic in alloc_pipe_info())
  	}
  
+ 	if (pipe->bufs) {
+ 		init_waitqueue_head(&pipe->wait);
+ 		pipe->r_counter = pipe->w_counter = 1;
+ 		pipe->buffers = pipe_bufs;
+ 		pipe->user = user;
+ 		account_pipe_buffers(user, 0, pipe_bufs);
+ 		mutex_init(&pipe->mutex);
+ 		return pipe;
+ 	}
+ 
+ 	kfree(pipe);
+ out_free_uid:
+ 	free_uid(user);
  	return NULL;
  }
  
* Unmerged path fs/pipe.c
