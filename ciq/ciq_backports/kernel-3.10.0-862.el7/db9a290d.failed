KVM: PPC: Book3S HV: Rename kvm_alloc_hpt() for clarity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author David Gibson <david@gibson.dropbear.id.au>
commit db9a290d9c3c596e5325e2a42133594435e5de46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/db9a290d.failed

The difference between kvm_alloc_hpt() and kvmppc_alloc_hpt() is not at
all obvious from the name.  In practice kvmppc_alloc_hpt() allocates an HPT
by whatever means, and calls kvm_alloc_hpt() which will attempt to allocate
it with CMA only.

To make this less confusing, rename kvm_alloc_hpt() to kvm_alloc_hpt_cma().
Similarly, kvm_release_hpt() is renamed kvm_free_hpt_cma().

	Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
	Reviewed-by: Thomas Huth <thuth@redhat.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit db9a290d9c3c596e5325e2a42133594435e5de46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_64_mmu_hv.c
diff --cc arch/powerpc/kvm/book3s_64_mmu_hv.c
index 283e37e10f56,16f278417c69..000000000000
--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c
+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c
@@@ -63,10 -62,10 +63,14 @@@ long kvmppc_alloc_hpt(struct kvm *kvm, 
  	}
  
  	kvm->arch.hpt_cma_alloc = 0;
++<<<<<<< HEAD
 +	VM_BUG_ON(order < KVM_CMA_CHUNK_ORDER);
 +	page = kvm_alloc_hpt(1 << (order - PAGE_SHIFT));
++=======
+ 	page = kvm_alloc_hpt_cma(1ul << (order - PAGE_SHIFT));
++>>>>>>> db9a290d9c3c (KVM: PPC: Book3S HV: Rename kvm_alloc_hpt() for clarity)
  	if (page) {
  		hpt = (unsigned long)pfn_to_kaddr(page_to_pfn(page));
 -		memset((void *)hpt, 0, (1ul << order));
  		kvm->arch.hpt_cma_alloc = 1;
  	}
  
@@@ -151,12 -155,11 +155,18 @@@ long kvmppc_alloc_reset_hpt(struct kvm 
  
  void kvmppc_free_hpt(struct kvm *kvm)
  {
 +	kvmppc_free_lpid(kvm->arch.lpid);
  	vfree(kvm->arch.revmap);
  	if (kvm->arch.hpt_cma_alloc)
++<<<<<<< HEAD
 +		kvm_release_hpt(virt_to_page(kvm->arch.hpt_virt),
 +				1 << (kvm->arch.hpt_order - PAGE_SHIFT));
 +	else
++=======
+ 		kvm_free_hpt_cma(virt_to_page(kvm->arch.hpt_virt),
+ 				 1 << (kvm->arch.hpt_order - PAGE_SHIFT));
+ 	else if (kvm->arch.hpt_virt)
++>>>>>>> db9a290d9c3c (KVM: PPC: Book3S HV: Rename kvm_alloc_hpt() for clarity)
  		free_pages(kvm->arch.hpt_virt,
  			   kvm->arch.hpt_order - PAGE_SHIFT);
  }
diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h
index 4fff076a809b..9d3496b2a457 100644
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@ -187,8 +187,8 @@ extern long kvmppc_h_stuff_tce(struct kvm_vcpu *vcpu,
 		unsigned long tce_value, unsigned long npages);
 extern long kvmppc_h_get_tce(struct kvm_vcpu *vcpu, unsigned long liobn,
 			     unsigned long ioba);
-extern struct page *kvm_alloc_hpt(unsigned long nr_pages);
-extern void kvm_release_hpt(struct page *page, unsigned long nr_pages);
+extern struct page *kvm_alloc_hpt_cma(unsigned long nr_pages);
+extern void kvm_free_hpt_cma(struct page *page, unsigned long nr_pages);
 extern int kvmppc_core_init_vm(struct kvm *kvm);
 extern void kvmppc_core_destroy_vm(struct kvm *kvm);
 extern void kvmppc_core_free_memslot(struct kvm *kvm,
* Unmerged path arch/powerpc/kvm/book3s_64_mmu_hv.c
diff --git a/arch/powerpc/kvm/book3s_hv_builtin.c b/arch/powerpc/kvm/book3s_hv_builtin.c
index c38f8d9d1ea6..89f8e990a07d 100644
--- a/arch/powerpc/kvm/book3s_hv_builtin.c
+++ b/arch/powerpc/kvm/book3s_hv_builtin.c
@@ -47,19 +47,19 @@ static int __init early_parse_kvm_cma_resv(char *p)
 }
 early_param("kvm_cma_resv_ratio", early_parse_kvm_cma_resv);
 
-struct page *kvm_alloc_hpt(unsigned long nr_pages)
+struct page *kvm_alloc_hpt_cma(unsigned long nr_pages)
 {
 	VM_BUG_ON(order_base_2(nr_pages) < KVM_CMA_CHUNK_ORDER - PAGE_SHIFT);
 
 	return kvm_alloc_cma(nr_pages, HPT_ALIGN_PAGES);
 }
-EXPORT_SYMBOL_GPL(kvm_alloc_hpt);
+EXPORT_SYMBOL_GPL(kvm_alloc_hpt_cma);
 
-void kvm_release_hpt(struct page *page, unsigned long nr_pages)
+void kvm_free_hpt_cma(struct page *page, unsigned long nr_pages)
 {
 	kvm_release_cma(page, nr_pages);
 }
-EXPORT_SYMBOL_GPL(kvm_release_hpt);
+EXPORT_SYMBOL_GPL(kvm_free_hpt_cma);
 
 /**
  * kvm_cma_reserve() - reserve area for kvm hash pagetable
