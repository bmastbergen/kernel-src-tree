net/mlx5e: Add neighbour hash table to the representors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add neighbour hash table to the representors (Don Dutile) [1456687 1499362]
Rebuild_FUZZ: 96.23%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit 37b498ff238549b30c9e70d4e45f522fd53b8994
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/37b498ff.failed

Add hash table to the representors which is to be used by the next patch
to save neighbours information in the driver.

In order to offload IP tunnel encapsulation rules, the driver must find
the tunnel dst neighbour according to the output device and the
destination address given by the user. The next patch will cache the
neighbors information in the driver to allow support in neigh update
flow for tunnel encap rules.

The neighbour entries are also saved in a list so we easily iterate over
them when querying statistics in order to provide 'used' feedback to the
kernel neighbour NUD core.

	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 37b498ff238549b30c9e70d4e45f522fd53b8994)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/amso1100/c2_user.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/infiniband/hw/amso1100/c2_user.h
index 7e9e7ad65467,99f6b5f41070..000000000000
--- a/drivers/infiniband/hw/amso1100/c2_user.h
+++ b/drivers/infiniband/hw/amso1100/c2_user.h
@@@ -30,53 -28,71 +30,92 @@@
   * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
 + *
   */
  
 -#ifndef __MLX5E_REP_H__
 -#define __MLX5E_REP_H__
 +#ifndef C2_USER_H
 +#define C2_USER_H
 +
++<<<<<<< HEAD:drivers/infiniband/hw/amso1100/c2_user.h
 +#include <linux/types.h>
 +
 +/*
 + * Make sure that all structs defined in this file remain laid out so
 + * that they pack the same way on 32-bit and 64-bit architectures (to
 + * avoid incompatibility between 32-bit userspace and 64-bit kernels).
 + * In particular do not use pointer types -- pass pointers in __u64
 + * instead.
 + */
  
 +struct c2_alloc_ucontext_resp {
 +	__u32 qp_tab_size;
 +	__u32 uarc_size;
++=======
+ #include <net/ip_tunnels.h>
+ #include <linux/rhashtable.h>
+ #include "eswitch.h"
+ #include "en.h"
+ 
+ struct mlx5e_neigh_update_table {
+ 	struct rhashtable       neigh_ht;
+ 	/* Save the neigh hash entries in a list in addition to the hash table
+ 	 * (neigh_ht). In order to iterate easily over the neigh entries.
+ 	 * Used for stats query.
+ 	 */
+ 	struct list_head	neigh_list;
+ };
+ 
+ struct mlx5e_rep_priv {
+ 	struct mlx5_eswitch_rep *rep;
+ 	struct mlx5e_neigh_update_table neigh_update;
+ };
+ 
+ struct mlx5e_neigh {
+ 	struct net_device *dev;
+ 	union {
+ 		__be32	v4;
+ 		struct in6_addr v6;
+ 	} dst_ip;
+ };
+ 
+ struct mlx5e_neigh_hash_entry {
+ 	struct rhash_head rhash_node;
+ 	struct mlx5e_neigh m_neigh;
+ 
+ 	/* Save the neigh hash entry in a list on the representor in
+ 	 * addition to the hash table. In order to iterate easily over the
+ 	 * neighbour entries. Used for stats query.
+ 	 */
+ 	struct list_head neigh_list;
++>>>>>>> 37b498ff2385 (net/mlx5e: Add neighbour hash table to the representors):drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
  };
  
 -struct mlx5e_encap_entry {
 -	struct hlist_node encap_hlist;
 -	struct list_head flows;
 -	u32 encap_id;
 -	struct neighbour *n;
 -	struct ip_tunnel_info tun_info;
 -	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 -
 -	struct net_device *out_dev;
 -	int tunnel_type;
 +struct c2_alloc_pd_resp {
 +	__u32 pdn;
 +	__u32 reserved;
  };
  
 -void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
 -void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
 -bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 -int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 -void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 +struct c2_create_cq {
 +	__u32 lkey;
 +	__u32 pdn;
 +	__u64 arm_db_page;
 +	__u64 set_db_page;
 +	__u32 arm_db_index;
 +	__u32 set_db_index;
 +};
  
 -int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
 -bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 +struct c2_create_cq_resp {
 +	__u32 cqn;
 +	__u32 reserved;
 +};
  
 -int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 -void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 +struct c2_create_qp {
 +	__u32 lkey;
 +	__u32 reserved;
 +	__u64 sq_db_page;
 +	__u64 rq_db_page;
 +	__u32 sq_db_index;
 +	__u32 rq_db_index;
 +};
  
 -#endif /* __MLX5E_REP_H__ */
 +#endif				/* C2_USER_H */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index abcb1976163d,52ea7f1c0973..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -224,18 -224,66 +224,81 @@@ void mlx5e_remove_sqs_fwd_rules(struct 
  	mlx5_eswitch_sqs2vport_stop(esw, rep);
  }
  
++<<<<<<< HEAD
 +void mlx5e_nic_rep_unload(struct mlx5_eswitch *esw,
 +			  struct mlx5_eswitch_rep *rep)
 +{
 +	struct net_device *netdev = rep->netdev;
 +	struct mlx5e_priv *priv = netdev_priv(netdev);
 +
 +	if (test_bit(MLX5E_STATE_OPENED, &priv->state))
 +		mlx5e_remove_sqs_fwd_rules(priv);
 +
 +	/* clean (and re-init) existing uplink offloaded TC rules */
 +	mlx5e_tc_cleanup(priv);
 +	mlx5e_tc_init(priv);
++=======
+ static const struct rhashtable_params mlx5e_neigh_ht_params = {
+ 	.head_offset = offsetof(struct mlx5e_neigh_hash_entry, rhash_node),
+ 	.key_offset = offsetof(struct mlx5e_neigh_hash_entry, m_neigh),
+ 	.key_len = sizeof(struct mlx5e_neigh),
+ 	.automatic_shrinking = true,
+ };
+ 
+ static int mlx5e_rep_neigh_init(struct mlx5e_rep_priv *rpriv)
+ {
+ 	struct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;
+ 
+ 	INIT_LIST_HEAD(&neigh_update->neigh_list);
+ 	return rhashtable_init(&neigh_update->neigh_ht, &mlx5e_neigh_ht_params);
+ }
+ 
+ static void mlx5e_rep_neigh_cleanup(struct mlx5e_rep_priv *rpriv)
+ {
+ 	struct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;
+ 
+ 	rhashtable_destroy(&neigh_update->neigh_ht);
+ }
+ 
+ static int mlx5e_rep_neigh_entry_insert(struct mlx5e_priv *priv,
+ 					struct mlx5e_neigh_hash_entry *nhe)
+ {
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	int err;
+ 
+ 	err = rhashtable_insert_fast(&rpriv->neigh_update.neigh_ht,
+ 				     &nhe->rhash_node,
+ 				     mlx5e_neigh_ht_params);
+ 	if (err)
+ 		return err;
+ 
+ 	list_add(&nhe->neigh_list, &rpriv->neigh_update.neigh_list);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5e_rep_neigh_entry_remove(struct mlx5e_priv *priv,
+ 					 struct mlx5e_neigh_hash_entry *nhe)
+ {
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 
+ 	list_del(&nhe->neigh_list);
+ 
+ 	rhashtable_remove_fast(&rpriv->neigh_update.neigh_ht,
+ 			       &nhe->rhash_node,
+ 			       mlx5e_neigh_ht_params);
+ }
+ 
+ static struct mlx5e_neigh_hash_entry *
+ mlx5e_rep_neigh_entry_lookup(struct mlx5e_priv *priv,
+ 			     struct mlx5e_neigh *m_neigh)
+ {
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	struct mlx5e_neigh_update_table *neigh_update = &rpriv->neigh_update;
+ 
+ 	return rhashtable_lookup_fast(&neigh_update->neigh_ht, m_neigh,
+ 				      mlx5e_neigh_ht_params);
++>>>>>>> 37b498ff2385 (net/mlx5e: Add neighbour hash table to the representors)
  }
  
  static int mlx5e_rep_open(struct net_device *dev)
@@@ -553,9 -595,55 +616,54 @@@ static struct mlx5e_profile mlx5e_rep_p
  	.max_tc			= 1,
  };
  
 -/* e-Switch vport representors */
 -
 -static int
 -mlx5e_nic_rep_load(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
 +int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
 +			 struct mlx5_eswitch_rep *rep)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(rep->netdev);
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 
+ 	int err;
+ 
+ 	if (test_bit(MLX5E_STATE_OPENED, &priv->state)) {
+ 		err = mlx5e_add_sqs_fwd_rules(priv);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	err = mlx5e_rep_neigh_init(rpriv);
+ 	if (err)
+ 		goto err_remove_sqs;
+ 
+ 	return 0;
+ 
+ err_remove_sqs:
+ 	mlx5e_remove_sqs_fwd_rules(priv);
+ 	return err;
+ }
+ 
+ static void
+ mlx5e_nic_rep_unload(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(rep->netdev);
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 
+ 	if (test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 		mlx5e_remove_sqs_fwd_rules(priv);
+ 
+ 	/* clean (and re-init) existing uplink offloaded TC rules */
+ 	mlx5e_tc_cleanup(priv);
+ 	mlx5e_tc_init(priv);
+ 
+ 	mlx5e_rep_neigh_cleanup(rpriv);
+ }
+ 
+ static int
+ mlx5e_vport_rep_load(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
+ {
+ 	struct mlx5e_rep_priv *rpriv;
++>>>>>>> 37b498ff2385 (net/mlx5e: Add neighbour hash table to the representors)
  	struct net_device *netdev;
  	int err;
  
@@@ -584,22 -685,88 +699,95 @@@
  
  	return 0;
  
+ err_neigh_cleanup:
+ 	mlx5e_rep_neigh_cleanup(rpriv);
+ 
  err_detach_netdev:
 -	mlx5e_detach_netdev(netdev_priv(netdev));
 +	mlx5e_detach_netdev(esw->dev, netdev);
  
  err_destroy_netdev:
 -	mlx5e_destroy_netdev(netdev_priv(netdev));
 -	kfree(rpriv);
 +	mlx5e_destroy_netdev(esw->dev, netdev_priv(netdev));
 +
  	return err;
  
  }
  
 -static void
 -mlx5e_vport_rep_unload(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
 +void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
 +			    struct mlx5_eswitch_rep *rep)
  {
  	struct net_device *netdev = rep->netdev;
++<<<<<<< HEAD
 +
 +	unregister_netdev(netdev);
 +	mlx5e_detach_netdev(esw->dev, netdev);
 +	mlx5e_destroy_netdev(esw->dev, netdev_priv(netdev));
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	void *ppriv = priv->ppriv;
+ 
+ 	unregister_netdev(rep->netdev);
+ 
+ 	mlx5e_rep_neigh_cleanup(rpriv);
+ 	mlx5e_detach_netdev(priv);
+ 	mlx5e_destroy_netdev(priv);
+ 	kfree(ppriv); /* mlx5e_rep_priv */
+ }
+ 
+ static void mlx5e_rep_register_vf_vports(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 	u8 mac[ETH_ALEN];
+ 
+ 	mlx5_query_nic_vport_mac_address(mdev, 0, mac);
+ 
+ 	for (vport = 1; vport < total_vfs; vport++) {
+ 		struct mlx5_eswitch_rep rep;
+ 
+ 		rep.load = mlx5e_vport_rep_load;
+ 		rep.unload = mlx5e_vport_rep_unload;
+ 		rep.vport = vport;
+ 		ether_addr_copy(rep.hw_id, mac);
+ 		mlx5_eswitch_register_vport_rep(esw, vport, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_rep_unregister_vf_vports(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ }
+ 
+ void mlx5e_register_vport_reps(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep rep;
+ 
+ 	mlx5_query_nic_vport_mac_address(mdev, 0, rep.hw_id);
+ 	rep.load = mlx5e_nic_rep_load;
+ 	rep.unload = mlx5e_nic_rep_unload;
+ 	rep.vport = FDB_UPLINK_VPORT;
+ 	rep.netdev = priv->netdev;
+ 	mlx5_eswitch_register_vport_rep(esw, 0, &rep); /* UPLINK PF vport*/
+ 
+ 	mlx5e_rep_register_vf_vports(priv); /* VFs vports */
+ }
+ 
+ void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
+ 
+ 	mlx5e_rep_unregister_vf_vports(priv); /* VFs vports */
+ 	mlx5_eswitch_unregister_vport_rep(esw, 0); /* UPLINK PF*/
++>>>>>>> 37b498ff2385 (net/mlx5e: Add neighbour hash table to the representors)
  }
* Unmerged path drivers/infiniband/hw/amso1100/c2_user.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
