scsi: qla2xxx: Add debug logging routine for qpair

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add debug logging routine for qpair (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 93.62%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 22d84726e3b82458dee015c56c88dae8c861436e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/22d84726.failed

For target main path io routines that uses qpair, create new logging &
debugging routines to use qpair instead of reaching for scsi_qla_host to
reduce cache thrash.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 22d84726e3b82458dee015c56c88dae8c861436e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 7a27b61e2d53,0e8cdaa03ee4..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1574,18 -2377,18 +1574,22 @@@ static int qlt_24xx_build_ctio_pkt(stru
  {
  	uint32_t h;
  	struct ctio7_to_24xx *pkt;
 +	struct qla_hw_data *ha = vha->hw;
  	struct atio_from_isp *atio = &prm->cmd->atio;
++<<<<<<< HEAD
++=======
+ 	uint16_t temp;
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  
 -	pkt = (struct ctio7_to_24xx *)qpair->req->ring_ptr;
 +	pkt = (struct ctio7_to_24xx *)vha->req->ring_ptr;
  	prm->pkt = pkt;
  	memset(pkt, 0, sizeof(*pkt));
  
  	pkt->entry_type = CTIO_TYPE7;
  	pkt->entry_count = (uint8_t)prm->req_cnt;
- 	pkt->vp_index = vha->vp_idx;
+ 	pkt->vp_index = prm->cmd->vp_idx;
  
 -	h = qlt_make_handle(qpair);
 +	h = qlt_make_handle(vha);
  	if (unlikely(h == QLA_TGT_NULL_HANDLE)) {
  		/*
  		 * CTIO type 7 from the firmware doesn't provide a way to
@@@ -1756,30 -2581,12 +1760,31 @@@ static int qlt_pre_xmit_response(struc
  	struct qla_tgt_prm *prm, int xmit_type, uint8_t scsi_status,
  	uint32_t *full_req_cnt)
  {
 +	struct qla_tgt *tgt = cmd->tgt;
 +	struct scsi_qla_host *vha = tgt->vha;
 +	struct qla_hw_data *ha = vha->hw;
  	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	struct qla_qpair *qpair = cmd->qpair;
  
 +	if (unlikely(cmd->aborted)) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,
 +		    "qla_target(%d): terminating exchange "
 +		    "for aborted cmd=%p (se_cmd=%p, tag=%d)", vha->vp_idx, cmd,
 +		    se_cmd, cmd->tag);
 +
 +		cmd->state = QLA_TGT_STATE_ABORTED;
 +
 +		qlt_send_term_exchange(vha, cmd, &cmd->atio, 0);
 +
 +		/* !! At this point cmd could be already freed !! */
 +		return QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED;
 +	}
 +
 +	ql_dbg(ql_dbg_tgt, vha, 0xe011, "qla_target(%d): tag=%u\n",
 +	    vha->vp_idx, cmd->tag);
 +
  	prm->cmd = cmd;
 -	prm->tgt = cmd->tgt;
 -	prm->pkt = NULL;
 +	prm->tgt = tgt;
  	prm->rq_result = scsi_status;
  	prm->sense_buffer = &cmd->sense_buffer[0];
  	prm->sense_buffer_len = TRANSPORT_SENSE_BUFFER;
@@@ -1806,19 -2608,18 +1811,34 @@@
  
  	if (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {
  		prm->residual = se_cmd->residual_count;
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_tgt, vha, 0xe014,
 +		    "Residual underflow: %d (tag %d, "
 +		    "op %x, bufflen %d, rq_result %x)\n", prm->residual,
 +		    cmd->tag, se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
 +		    cmd->bufflen, prm->rq_result);
 +		prm->rq_result |= SS_RESIDUAL_UNDER;
 +	} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {
 +		prm->residual = se_cmd->residual_count;
 +		ql_dbg(ql_dbg_tgt, vha, 0xe015,
 +		    "Residual overflow: %d (tag %d, "
 +		    "op %x, bufflen %d, rq_result %x)\n", prm->residual,
 +		    cmd->tag, se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
 +		    cmd->bufflen, prm->rq_result);
++=======
+ 		ql_dbg_qp(ql_dbg_io + ql_dbg_verbose, qpair, 0x305c,
+ 		    "Residual underflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\n",
+ 		       prm->residual, se_cmd->tag,
+ 		       se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,
+ 		       cmd->bufflen, prm->rq_result);
+ 		prm->rq_result |= SS_RESIDUAL_UNDER;
+ 	} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {
+ 		prm->residual = se_cmd->residual_count;
+ 		ql_dbg_qp(ql_dbg_io, qpair, 0x305d,
+ 		    "Residual overflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\n",
+ 		       prm->residual, se_cmd->tag, se_cmd->t_task_cdb ?
+ 		       se_cmd->t_task_cdb[0] : 0, cmd->bufflen, prm->rq_result);
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  		prm->rq_result |= SS_RESIDUAL_OVER;
  	}
  
@@@ -1962,9 -2670,9 +1982,9 @@@ static void qlt_24xx_init_ctio_to_isp(s
  	if (QLA_TGT_SENSE_VALID(prm->sense_buffer)) {
  		int i;
  
 -		if (qlt_need_explicit_conf(prm->cmd, 1)) {
 +		if (qlt_need_explicit_conf(prm->tgt->ha, prm->cmd, 1)) {
  			if ((prm->rq_result & SS_SCSI_STATUS_BYTE) != 0) {
- 				ql_dbg(ql_dbg_tgt, prm->cmd->vha, 0xe017,
+ 				ql_dbg_qp(ql_dbg_tgt, prm->cmd->qpair, 0xe017,
  				    "Skipping EXPLICIT_CONFORM and "
  				    "CTIO7_FLAGS_CONFORM_REQ for FCP READ w/ "
  				    "non GOOD status\n");
@@@ -2011,6 -2710,350 +2031,353 @@@ skip_explict_conf
  	/* Sense with len > 24, is it possible ??? */
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ qlt_hba_err_chk_enabled(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 		if (ql2xenablehba_err_chk >= 1)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DOUT_PASS:
+ 	case TARGET_PROT_DIN_PASS:
+ 		if (ql2xenablehba_err_chk >= 2)
+ 			return 1;
+ 		break;
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		return 1;
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static inline int
+ qla_tgt_ref_mask_check(struct se_cmd *se_cmd)
+ {
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 	    return 1;
+ 	default:
+ 	    return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * qla_tgt_set_dif_tags - Extract Ref and App tags from SCSI command
+  */
+ static void
+ qla_tgt_set_dif_tags(struct qla_tgt_cmd *cmd, struct crc_context *ctx,
+     uint16_t *pfw_prot_opts)
+ {
+ 	struct se_cmd *se_cmd = &cmd->se_cmd;
+ 	uint32_t lba = 0xffffffff & se_cmd->t_task_lba;
+ 	scsi_qla_host_t *vha = cmd->tgt->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint32_t t32 = 0;
+ 
+ 	/*
+ 	 * wait till Mode Sense/Select cmd, modepage Ah, subpage 2
+ 	 * have been immplemented by TCM, before AppTag is avail.
+ 	 * Look for modesense_handlers[]
+ 	 */
+ 	ctx->app_tag = 0;
+ 	ctx->app_tag_mask[0] = 0x0;
+ 	ctx->app_tag_mask[1] = 0x0;
+ 
+ 	if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			*pfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	t32 = ha->tgt.tgt_ops->get_dif_tags(cmd, pfw_prot_opts);
+ 
+ 	switch (se_cmd->prot_type) {
+ 	case TARGET_DIF_TYPE0_PROT:
+ 		/*
+ 		 * No check for ql2xenablehba_err_chk, as it
+ 		 * would be an I/O error if hba tag generation
+ 		 * is not done.
+ 		 */
+ 		ctx->ref_tag = cpu_to_le32(lba);
+ 		/* enable ALL bytes of the ref tag */
+ 		ctx->ref_tag_mask[0] = 0xff;
+ 		ctx->ref_tag_mask[1] = 0xff;
+ 		ctx->ref_tag_mask[2] = 0xff;
+ 		ctx->ref_tag_mask[3] = 0xff;
+ 		break;
+ 	case TARGET_DIF_TYPE1_PROT:
+ 	    /*
+ 	     * For TYPE 1 protection: 16 bit GUARD tag, 32 bit
+ 	     * REF tag, and 16 bit app tag.
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE2_PROT:
+ 	    /*
+ 	     * For TYPE 2 protection: 16 bit GUARD + 32 bit REF
+ 	     * tag has to match LBA in CDB + N
+ 	     */
+ 	    ctx->ref_tag = cpu_to_le32(lba);
+ 	    if (!qla_tgt_ref_mask_check(se_cmd) ||
+ 		!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {
+ 		    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 		    break;
+ 	    }
+ 	    /* enable ALL bytes of the ref tag */
+ 	    ctx->ref_tag_mask[0] = 0xff;
+ 	    ctx->ref_tag_mask[1] = 0xff;
+ 	    ctx->ref_tag_mask[2] = 0xff;
+ 	    ctx->ref_tag_mask[3] = 0xff;
+ 	    break;
+ 	case TARGET_DIF_TYPE3_PROT:
+ 	    /* For TYPE 3 protection: 16 bit GUARD only */
+ 	    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;
+ 	    ctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =
+ 		ctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;
+ 	    break;
+ 	}
+ }
+ 
+ static inline int
+ qlt_build_ctio_crc2_pkt(struct qla_qpair *qpair, struct qla_tgt_prm *prm)
+ {
+ 	uint32_t		*cur_dsd;
+ 	uint32_t		transfer_length = 0;
+ 	uint32_t		data_bytes;
+ 	uint32_t		dif_bytes;
+ 	uint8_t			bundling = 1;
+ 	uint8_t			*clr_ptr;
+ 	struct crc_context	*crc_ctx_pkt = NULL;
+ 	struct qla_hw_data	*ha;
+ 	struct ctio_crc2_to_fw	*pkt;
+ 	dma_addr_t		crc_ctx_dma;
+ 	uint16_t		fw_prot_opts = 0;
+ 	struct qla_tgt_cmd	*cmd = prm->cmd;
+ 	struct se_cmd		*se_cmd = &cmd->se_cmd;
+ 	uint32_t h;
+ 	struct atio_from_isp *atio = &prm->cmd->atio;
+ 	struct qla_tc_param	tc;
+ 	uint16_t t16;
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 
+ 	ha = vha->hw;
+ 
+ 	pkt = (struct ctio_crc2_to_fw *)qpair->req->ring_ptr;
+ 	prm->pkt = pkt;
+ 	memset(pkt, 0, sizeof(*pkt));
+ 
+ 	ql_dbg_qp(ql_dbg_tgt, cmd->qpair, 0xe071,
+ 		"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",
+ 		cmd->vp_idx, __func__, se_cmd, se_cmd->prot_op,
+ 		prm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);
+ 
+ 	if ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||
+ 	    (se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))
+ 		bundling = 0;
+ 
+ 	/* Compute dif len and adjust data len to incude protection */
+ 	data_bytes = cmd->bufflen;
+ 	dif_bytes  = (data_bytes / cmd->blk_sz) * 8;
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		transfer_length = data_bytes;
+ 		if (cmd->prot_sg_cnt)
+ 			data_bytes += dif_bytes;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		transfer_length = data_bytes + dif_bytes;
+ 		break;
+ 	default:
+ 		BUG();
+ 		break;
+ 	}
+ 
+ 	if (!qlt_hba_err_chk_enabled(se_cmd))
+ 		fw_prot_opts |= 0x10; /* Disable Guard tag checking */
+ 	/* HBA error checking enabled */
+ 	else if (IS_PI_UNINIT_CAPABLE(ha)) {
+ 		if ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||
+ 		    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))
+ 			fw_prot_opts |= PO_DIS_VALD_APP_ESC;
+ 		else if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)
+ 			fw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;
+ 	}
+ 
+ 	switch (se_cmd->prot_op) {
+ 	case TARGET_PROT_DIN_INSERT:
+ 	case TARGET_PROT_DOUT_INSERT:
+ 		fw_prot_opts |= PO_MODE_DIF_INSERT;
+ 		break;
+ 	case TARGET_PROT_DIN_STRIP:
+ 	case TARGET_PROT_DOUT_STRIP:
+ 		fw_prot_opts |= PO_MODE_DIF_REMOVE;
+ 		break;
+ 	case TARGET_PROT_DIN_PASS:
+ 	case TARGET_PROT_DOUT_PASS:
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		/* FUTURE: does tcm require T10CRC<->IPCKSUM conversion? */
+ 		break;
+ 	default:/* Normal Request */
+ 		fw_prot_opts |= PO_MODE_DIF_PASS;
+ 		break;
+ 	}
+ 
+ 	/* ---- PKT ---- */
+ 	/* Update entry type to indicate Command Type CRC_2 IOCB */
+ 	pkt->entry_type  = CTIO_CRC2;
+ 	pkt->entry_count = 1;
+ 	pkt->vp_index = cmd->vp_idx;
+ 
+ 	h = qlt_make_handle(qpair);
+ 	if (unlikely(h == QLA_TGT_NULL_HANDLE)) {
+ 		/*
+ 		 * CTIO type 7 from the firmware doesn't provide a way to
+ 		 * know the initiator's LOOP ID, hence we can't find
+ 		 * the session and, so, the command.
+ 		 */
+ 		return -EAGAIN;
+ 	} else
+ 		qpair->req->outstanding_cmds[h] = (srb_t *)prm->cmd;
+ 
+ 	pkt->handle  = MAKE_HANDLE(qpair->req->id, h);
+ 	pkt->handle |= CTIO_COMPLETION_HANDLE_MARK;
+ 	pkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);
+ 	pkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);
+ 	pkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];
+ 	pkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];
+ 	pkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];
+ 	pkt->exchange_addr   = atio->u.isp24.exchange_addr;
+ 
+ 	/* silence compile warning */
+ 	t16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);
+ 	pkt->ox_id  = cpu_to_le16(t16);
+ 
+ 	t16 = (atio->u.isp24.attr << 9);
+ 	pkt->flags |= cpu_to_le16(t16);
+ 	pkt->relative_offset = cpu_to_le32(prm->cmd->offset);
+ 
+ 	/* Set transfer direction */
+ 	if (cmd->dma_data_direction == DMA_TO_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_IN);
+ 	else if (cmd->dma_data_direction == DMA_FROM_DEVICE)
+ 		pkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_OUT);
+ 
+ 	pkt->dseg_count = prm->tot_dsds;
+ 	/* Fibre channel byte count */
+ 	pkt->transfer_length = cpu_to_le32(transfer_length);
+ 
+ 	/* ----- CRC context -------- */
+ 
+ 	/* Allocate CRC context from global pool */
+ 	crc_ctx_pkt = cmd->ctx =
+ 	    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);
+ 
+ 	if (!crc_ctx_pkt)
+ 		goto crc_queuing_error;
+ 
+ 	/* Zero out CTX area. */
+ 	clr_ptr = (uint8_t *)crc_ctx_pkt;
+ 	memset(clr_ptr, 0, sizeof(*crc_ctx_pkt));
+ 
+ 	crc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;
+ 	INIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);
+ 
+ 	/* Set handle */
+ 	crc_ctx_pkt->handle = pkt->handle;
+ 
+ 	qla_tgt_set_dif_tags(cmd, crc_ctx_pkt, &fw_prot_opts);
+ 
+ 	pkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));
+ 	pkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));
+ 	pkt->crc_context_len = CRC_CONTEXT_LEN_FW;
+ 
+ 	if (!bundling) {
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;
+ 	} else {
+ 		/*
+ 		 * Configure Bundling if we need to fetch interlaving
+ 		 * protection PCI accesses
+ 		 */
+ 		fw_prot_opts |= PO_ENABLE_DIF_BUNDLING;
+ 		crc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);
+ 		crc_ctx_pkt->u.bundling.dseg_count =
+ 			cpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;
+ 	}
+ 
+ 	/* Finish the common fields of CRC pkt */
+ 	crc_ctx_pkt->blk_size   = cpu_to_le16(cmd->blk_sz);
+ 	crc_ctx_pkt->prot_opts  = cpu_to_le16(fw_prot_opts);
+ 	crc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);
+ 	crc_ctx_pkt->guard_seed = cpu_to_le16(0);
+ 
+ 	memset((uint8_t *)&tc, 0 , sizeof(tc));
+ 	tc.vha = vha;
+ 	tc.blk_sz = cmd->blk_sz;
+ 	tc.bufflen = cmd->bufflen;
+ 	tc.sg = cmd->sg;
+ 	tc.prot_sg = cmd->prot_sg;
+ 	tc.ctx = crc_ctx_pkt;
+ 	tc.ctx_dsd_alloced = &cmd->ctx_dsd_alloced;
+ 
+ 	/* Walks data segments */
+ 	pkt->flags |= cpu_to_le16(CTIO7_FLAGS_DSD_PTR);
+ 
+ 	if (!bundling && prm->prot_seg_cnt) {
+ 		if (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,
+ 			prm->tot_dsds, &tc))
+ 			goto crc_queuing_error;
+ 	} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,
+ 		(prm->tot_dsds - prm->prot_seg_cnt), &tc))
+ 		goto crc_queuing_error;
+ 
+ 	if (bundling && prm->prot_seg_cnt) {
+ 		/* Walks dif segments */
+ 		pkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;
+ 
+ 		cur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;
+ 		if (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,
+ 			prm->prot_seg_cnt, &tc))
+ 			goto crc_queuing_error;
+ 	}
+ 	return QLA_SUCCESS;
+ 
+ crc_queuing_error:
+ 	/* Cleanup will be performed by the caller */
+ 	qpair->req->outstanding_cmds[h] = NULL;
+ 
+ 	return QLA_FUNCTION_FAILED;
+ }
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  
  /*
   * Callback to setup response of xmit_type of QLA_TGT_XMIT_DATA and *
@@@ -2027,13 -3070,21 +2394,21 @@@ int qlt_xmit_response(struct qla_tgt_cm
  	unsigned long flags = 0;
  	int res;
  
 -	if (cmd->sess && cmd->sess->deleted) {
 -		cmd->state = QLA_TGT_STATE_PROCESSED;
 -		if (cmd->sess->logout_completed)
 -			/* no need to terminate. FW already freed exchange. */
 -			qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
 -		else
 -			qlt_send_term_exchange(qpair, cmd, &cmd->atio, 0, 0);
 -		return 0;
 -	}
 -
 +	memset(&prm, 0, sizeof(prm));
 +	qlt_check_srr_debug(cmd, &xmit_type);
 +
++<<<<<<< HEAD
 +	ql_dbg(ql_dbg_tgt, cmd->vha, 0xe018,
 +	    "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, "
 +	    "cmd->dma_data_direction=%d\n", (xmit_type & QLA_TGT_XMIT_STATUS) ?
 +	    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction);
++=======
+ 	ql_dbg_qp(ql_dbg_tgt, qpair, 0xe018,
+ 	    "is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d se_cmd[%p] qp %d\n",
+ 	    (xmit_type & QLA_TGT_XMIT_STATUS) ?
+ 	    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction,
+ 	    &cmd->se_cmd, qpair->id);
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  
  	res = qlt_pre_xmit_response(cmd, &prm, xmit_type, scsi_status,
  	    &full_req_cnt);
@@@ -2044,10 -3092,30 +2419,34 @@@
  		return res;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
++=======
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 
+ 	if (xmit_type == QLA_TGT_XMIT_STATUS)
+ 		vha->tgt_counters.core_qla_snd_status++;
+ 	else
+ 		vha->tgt_counters.core_qla_que_buf++;
+ 
+ 	if (!qpair->fw_started || cmd->reset_count != qpair->chip_reset) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_PROCESSED;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg_qp(ql_dbg_async, qpair, 0xe101,
+ 			"RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, qpair->chip_reset);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 		return 0;
+ 	}
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  
  	/* Does F/W have an IOCBs for this request */
 -	res = qlt_check_reserve_free_req(qpair, full_req_cnt);
 +	res = qlt_check_reserve_free_req(vha, full_req_cnt);
  	if (unlikely(res))
  		goto out_unmap_unlock;
  
@@@ -2088,13 -3161,21 +2487,19 @@@
  			 * req_pkt().
  			 */
  			struct ctio7_to_24xx *ctio =
 -				(struct ctio7_to_24xx *)qlt_get_req_pkt(
 -				    qpair->req);
 +				(struct ctio7_to_24xx *)qlt_get_req_pkt(vha);
  
++<<<<<<< HEAD
 +			ql_dbg(ql_dbg_tgt, vha, 0xe019,
 +			    "Building additional status packet\n");
++=======
+ 			ql_dbg_qp(ql_dbg_tgt, qpair, 0x305e,
+ 			    "Building additional status packet 0x%p.\n",
+ 			    ctio);
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  
 -			/*
 -			 * T10Dif: ctio_crc2_to_fw overlay ontop of
 -			 * ctio7_to_24xx
 -			 */
  			memcpy(ctio, pkt, sizeof(*ctio));
 -			/* reset back to CTIO7 */
  			ctio->entry_count = 1;
 -			ctio->entry_type = CTIO_TYPE7;
  			ctio->dseg_count = 0;
  			ctio->u.status1.flags &= ~cpu_to_le16(
  			    CTIO7_FLAGS_DATA_IN);
@@@ -2103,9 -3184,13 +2508,8 @@@
  			pkt->handle |= CTIO_INTERMEDIATE_HANDLE_MARK;
  			pkt->u.status0.flags |= cpu_to_le16(
  			    CTIO7_FLAGS_DONT_RET_CTIO);
 -
 -			/* qlt_24xx_init_ctio_to_isp will correct
 -			 * all neccessary fields that's part of CTIO7.
 -			 * There should be no residual of CTIO-CRC2 data.
 -			 */
  			qlt_24xx_init_ctio_to_isp((struct ctio7_to_24xx *)ctio,
  			    &prm);
- 			pr_debug("Status CTIO7: %p\n", ctio);
  		}
  	} else
  		qlt_24xx_init_ctio_to_isp(pkt, &prm);
@@@ -2160,16 -3237,36 +2564,33 @@@ int qlt_rdy_to_xfer(struct qla_tgt_cmd 
  	if (qlt_pci_map_calc_cnt(&prm) != 0)
  		return -EAGAIN;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
++=======
+ 	if (!qpair->fw_started || (cmd->reset_count != qpair->chip_reset) ||
+ 	    (cmd->sess && cmd->sess->deleted)) {
+ 		/*
+ 		 * Either the port is not online or this request was from
+ 		 * previous life, just abort the processing.
+ 		 */
+ 		cmd->state = QLA_TGT_STATE_NEED_DATA;
+ 		qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
+ 		ql_dbg_qp(ql_dbg_async, qpair, 0xe102,
+ 			"RESET-XFR online/active/old-count/new-count = %d/%d/%d/%d.\n",
+ 			vha->flags.online, qla2x00_reset_active(vha),
+ 			cmd->reset_count, qpair->chip_reset);
+ 		return 0;
+ 	}
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  
 -	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
  	/* Does F/W have an IOCBs for this request */
 -	res = qlt_check_reserve_free_req(qpair, prm.req_cnt);
 +	res = qlt_check_reserve_free_req(vha, prm.req_cnt);
  	if (res != 0)
  		goto out_unlock_free_unmap;
 -	if (cmd->se_cmd.prot_op)
 -		res = qlt_build_ctio_crc2_pkt(qpair, &prm);
 -	else
 -		res = qlt_24xx_build_ctio_pkt(qpair, &prm);
  
 -	if (unlikely(res != 0)) {
 -		qpair->req->cnt += prm.req_cnt;
 +	res = qlt_24xx_build_ctio_pkt(&prm, vha);
 +	if (unlikely(res != 0))
  		goto out_unlock_free_unmap;
 -	}
 -
  	pkt = (struct ctio7_to_24xx *)prm.pkt;
  	pkt->u.status0.flags |= cpu_to_le16(CTIO7_FLAGS_DATA_OUT |
  	    CTIO7_FLAGS_STATUS_MODE_0);
@@@ -2715,12 -4059,241 +3136,234 @@@ out_term
  	 * cmd has not sent to target yet, so pass NULL as the second
  	 * argument to qlt_send_term_exchange() and free the memory here.
  	 */
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	qlt_send_term_exchange(vha, NULL, &cmd->atio, 1);
 +	kmem_cache_free(qla_tgt_cmd_cachep, cmd);
 +	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 +	if (sess)
++=======
+ 	cmd->trc_flags |= TRC_DO_WORK_ERR;
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 	qlt_send_term_exchange(qpair, NULL, &cmd->atio, 1, 0);
+ 
+ 	qlt_decr_num_pend_cmds(vha);
+ 	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 	ha->tgt.tgt_ops->put_sess(sess);
+ 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ }
+ 
+ static void qlt_do_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
+ 	scsi_qla_host_t *vha = cmd->vha;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&cmd->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	__qlt_do_work(cmd);
+ }
+ 
+ void qlt_clr_qp_table(struct scsi_qla_host *vha)
+ {
+ 	unsigned long flags;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	void *node;
+ 	u64 key = 0;
+ 
+ 	ql_log(ql_log_info, vha, 0x706c,
+ 	    "User update Number of Active Qpairs %d\n",
+ 	    ha->tgt.num_act_qpairs);
+ 
+ 	spin_lock_irqsave(&ha->tgt.atio_lock, flags);
+ 
+ 	btree_for_each_safe64(&tgt->lun_qpair_map, key, node)
+ 		btree_remove64(&tgt->lun_qpair_map, key);
+ 
+ 	ha->base_qpair->lun_cnt = 0;
+ 	for (key = 0; key < ha->max_qpairs; key++)
+ 		if (ha->queue_pair_map[key])
+ 			ha->queue_pair_map[key]->lun_cnt = 0;
+ 
+ 	spin_unlock_irqrestore(&ha->tgt.atio_lock, flags);
+ }
+ 
+ static void qlt_assign_qpair(struct scsi_qla_host *vha,
+ 	struct qla_tgt_cmd *cmd)
+ {
+ 	struct qla_qpair *qpair, *qp;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_qpair_hint *h;
+ 
+ 	if (vha->flags.qpairs_available) {
+ 		h = btree_lookup64(&tgt->lun_qpair_map, cmd->unpacked_lun);
+ 		if (unlikely(!h)) {
+ 			/* spread lun to qpair ratio evently */
+ 			int lcnt = 0, rc;
+ 			struct scsi_qla_host *base_vha =
+ 				pci_get_drvdata(vha->hw->pdev);
+ 
+ 			qpair = vha->hw->base_qpair;
+ 			if (qpair->lun_cnt == 0) {
+ 				qpair->lun_cnt++;
+ 				h = qla_qpair_to_hint(tgt, qpair);
+ 				BUG_ON(!h);
+ 				rc = btree_insert64(&tgt->lun_qpair_map,
+ 					cmd->unpacked_lun, h, GFP_ATOMIC);
+ 				if (rc) {
+ 					qpair->lun_cnt--;
+ 					ql_log(ql_log_info, vha, 0xd037,
+ 					    "Unable to insert lun %llx into lun_qpair_map\n",
+ 					    cmd->unpacked_lun);
+ 				}
+ 				goto out;
+ 			} else {
+ 				lcnt = qpair->lun_cnt;
+ 			}
+ 
+ 			h = NULL;
+ 			list_for_each_entry(qp, &base_vha->qp_list,
+ 			    qp_list_elem) {
+ 				if (qp->lun_cnt == 0) {
+ 					qp->lun_cnt++;
+ 					h = qla_qpair_to_hint(tgt, qp);
+ 					BUG_ON(!h);
+ 					rc = btree_insert64(&tgt->lun_qpair_map,
+ 					    cmd->unpacked_lun, h, GFP_ATOMIC);
+ 					if (rc) {
+ 						qp->lun_cnt--;
+ 						ql_log(ql_log_info, vha, 0xd038,
+ 							"Unable to insert lun %llx into lun_qpair_map\n",
+ 							cmd->unpacked_lun);
+ 					}
+ 					qpair = qp;
+ 					goto out;
+ 				} else {
+ 					if (qp->lun_cnt < lcnt) {
+ 						lcnt = qp->lun_cnt;
+ 						qpair = qp;
+ 						continue;
+ 					}
+ 				}
+ 			}
+ 			BUG_ON(!qpair);
+ 			qpair->lun_cnt++;
+ 			h = qla_qpair_to_hint(tgt, qpair);
+ 			BUG_ON(!h);
+ 			rc = btree_insert64(&tgt->lun_qpair_map,
+ 				cmd->unpacked_lun, h, GFP_ATOMIC);
+ 			if (rc) {
+ 				qpair->lun_cnt--;
+ 				ql_log(ql_log_info, vha, 0xd039,
+ 				   "Unable to insert lun %llx into lun_qpair_map\n",
+ 				   cmd->unpacked_lun);
+ 			}
+ 		}
+ 	} else {
+ 		h = &tgt->qphints[0];
+ 	}
+ out:
+ 	cmd->qpair = h->qpair;
+ 	cmd->se_cmd.cpuid = h->cpuid;
+ }
+ 
+ static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,
+ 				       struct fc_port *sess,
+ 				       struct atio_from_isp *atio)
+ {
+ 	struct se_session *se_sess = sess->se_sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	int tag;
+ 
+ 	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+ 	if (tag < 0)
+ 		return NULL;
+ 
+ 	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
+ 	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
+ 	cmd->cmd_type = TYPE_TGT_CMD;
+ 	memcpy(&cmd->atio, atio, sizeof(*atio));
+ 	cmd->state = QLA_TGT_STATE_NEW;
+ 	cmd->tgt = vha->vha_tgt.qla_tgt;
+ 	qlt_incr_num_pend_cmds(vha);
+ 	cmd->vha = vha;
+ 	cmd->se_cmd.map_tag = tag;
+ 	cmd->sess = sess;
+ 	cmd->loop_id = sess->loop_id;
+ 	cmd->conf_compl_supported = sess->conf_compl_supported;
+ 
+ 	cmd->trc_flags = 0;
+ 	cmd->jiffies_at_alloc = get_jiffies_64();
+ 
+ 	cmd->unpacked_lun = scsilun_to_int(
+ 	    (struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);
+ 	qlt_assign_qpair(vha, cmd);
+ 	cmd->reset_count = vha->hw->base_qpair->chip_reset;
+ 	cmd->vp_idx = vha->vp_idx;
+ 
+ 	return cmd;
+ }
+ 
+ static void qlt_create_sess_from_atio(struct work_struct *work)
+ {
+ 	struct qla_tgt_sess_op *op = container_of(work,
+ 					struct qla_tgt_sess_op, work);
+ 	scsi_qla_host_t *vha = op->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct fc_port *sess;
+ 	struct qla_tgt_cmd *cmd;
+ 	unsigned long flags;
+ 	uint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;
+ 
+ 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+ 	list_del(&op->cmd_list);
+ 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+ 
+ 	if (op->aborted) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+ 		    "sess_op with tag %u is aborted\n",
+ 		    op->atio.u.isp24.exchange_addr);
+ 		goto out_term;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+ 	    "qla_target(%d): Unable to find wwn login"
+ 	    " (s_id %x:%x:%x), trying to create it manually\n",
+ 	    vha->vp_idx, s_id[0], s_id[1], s_id[2]);
+ 
+ 	if (op->atio.u.raw.entry_count > 1) {
+ 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+ 		    "Dropping multy entry atio %p\n", &op->atio);
+ 		goto out_term;
+ 	}
+ 
+ 	sess = qlt_make_local_sess(vha, s_id);
+ 	/* sess has an extra creation ref. */
+ 
+ 	if (!sess)
+ 		goto out_term;
+ 	/*
+ 	 * Now obtain a pre-allocated session tag using the original op->atio
+ 	 * packet header, and dispatch into __qlt_do_work() using the existing
+ 	 * process context.
+ 	 */
+ 	cmd = qlt_get_tag(vha, sess, &op->atio);
+ 	if (!cmd) {
+ 		struct qla_qpair *qpair = ha->base_qpair;
+ 
+ 		spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 		qlt_send_busy(qpair, &op->atio, SAM_STAT_BUSY);
+ 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
++>>>>>>> 22d84726e3b8 (scsi: qla2xxx: Add debug logging routine for qpair)
  		ha->tgt.tgt_ops->put_sess(sess);
 -		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 -		kfree(op);
 -		return;
 -	}
 -
 -	/*
 -	 * __qlt_do_work() will call qlt_put_sess() to release
 -	 * the extra reference taken above by qlt_make_local_sess()
 -	 */
 -	__qlt_do_work(cmd);
 -	kfree(op);
 -	return;
 -out_term:
 -	qlt_send_term_exchange(vha->hw->base_qpair, NULL, &op->atio, 0, 0);
 -	kfree(op);
  }
  
  /* ha->hardware_lock supposed to be held on entry */
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index bb8f9db626de..6ae5b15341c5 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -2720,3 +2720,104 @@ ql_dump_buffer(uint32_t level, scsi_qla_host_t *vha, int32_t id,
 			       buf + cnt, min(16U, size - cnt), false);
 	}
 }
+
+/*
+ * This function is for formatting and logging log messages.
+ * It is to be used when vha is available. It formats the message
+ * and logs it to the messages file. All the messages will be logged
+ * irrespective of value of ql2xextended_error_logging.
+ * parameters:
+ * level: The level of the log messages to be printed in the
+ *        messages file.
+ * vha:   Pointer to the scsi_qla_host_t
+ * id:    This is a unique id for the level. It identifies the
+ *        part of the code from where the message originated.
+ * msg:   The message to be displayed.
+ */
+void
+ql_log_qp(uint32_t level, struct qla_qpair *qpair, int32_t id,
+    const char *fmt, ...)
+{
+	va_list va;
+	struct va_format vaf;
+	char pbuf[128];
+
+	if (level > ql_errlev)
+		return;
+
+	if (qpair != NULL) {
+		const struct pci_dev *pdev = qpair->pdev;
+		/* <module-name> <msg-id>:<host> Message */
+		snprintf(pbuf, sizeof(pbuf), "%s [%s]-%04x: ",
+			QL_MSGHDR, dev_name(&(pdev->dev)), id);
+	} else {
+		snprintf(pbuf, sizeof(pbuf), "%s [%s]-%04x: : ",
+			QL_MSGHDR, "0000:00:00.0", id);
+	}
+	pbuf[sizeof(pbuf) - 1] = 0;
+
+	va_start(va, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &va;
+
+	switch (level) {
+	case ql_log_fatal: /* FATAL LOG */
+		pr_crit("%s%pV", pbuf, &vaf);
+		break;
+	case ql_log_warn:
+		pr_err("%s%pV", pbuf, &vaf);
+		break;
+	case ql_log_info:
+		pr_warn("%s%pV", pbuf, &vaf);
+		break;
+	default:
+		pr_info("%s%pV", pbuf, &vaf);
+		break;
+	}
+
+	va_end(va);
+}
+
+/*
+ * This function is for formatting and logging debug information.
+ * It is to be used when vha is available. It formats the message
+ * and logs it to the messages file.
+ * parameters:
+ * level: The level of the debug messages to be printed.
+ *        If ql2xextended_error_logging value is correctly set,
+ *        this message will appear in the messages file.
+ * vha:   Pointer to the scsi_qla_host_t.
+ * id:    This is a unique identifier for the level. It identifies the
+ *        part of the code from where the message originated.
+ * msg:   The message to be displayed.
+ */
+void
+ql_dbg_qp(uint32_t level, struct qla_qpair *qpair, int32_t id,
+    const char *fmt, ...)
+{
+	va_list va;
+	struct va_format vaf;
+
+	if (!ql_mask_match(level))
+		return;
+
+	va_start(va, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &va;
+
+	if (qpair != NULL) {
+		const struct pci_dev *pdev = qpair->pdev;
+		/* <module-name> <pci-name> <msg-id>:<host> Message */
+		pr_warn("%s [%s]-%04x: %pV",
+		    QL_MSGHDR, dev_name(&(pdev->dev)), id + ql_dbg_offset,
+		    &vaf);
+	} else {
+		pr_warn("%s [%s]-%04x: : %pV",
+			QL_MSGHDR, "0000:00:00.0", id + ql_dbg_offset, &vaf);
+	}
+
+	va_end(va);
+
+}
diff --git a/drivers/scsi/qla2xxx/qla_dbg.h b/drivers/scsi/qla2xxx/qla_dbg.h
index ec0c6e8c1fbf..69d710ae5894 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.h
+++ b/drivers/scsi/qla2xxx/qla_dbg.h
@@ -313,12 +313,18 @@ void __attribute__((format (printf, 4, 5)))
 ql_dbg(uint32_t, scsi_qla_host_t *vha, int32_t, const char *fmt, ...);
 void __attribute__((format (printf, 4, 5)))
 ql_dbg_pci(uint32_t, struct pci_dev *pdev, int32_t, const char *fmt, ...);
+void __attribute__((format (printf, 4, 5)))
+ql_dbg_qp(uint32_t, struct qla_qpair *, int32_t, const char *fmt, ...);
+
 
 void __attribute__((format (printf, 4, 5)))
 ql_log(uint32_t, scsi_qla_host_t *vha, int32_t, const char *fmt, ...);
 void __attribute__((format (printf, 4, 5)))
 ql_log_pci(uint32_t, struct pci_dev *pdev, int32_t, const char *fmt, ...);
 
+void __attribute__((format (printf, 4, 5)))
+ql_log_qp(uint32_t, struct qla_qpair *, int32_t, const char *fmt, ...);
+
 /* Debug Levels */
 /* The 0x40000000 is the max value any debug level can have
  * as ql2xextended_error_logging is of type signed int
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0..dea836c76194 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -852,6 +852,7 @@ struct qla_tgt_cmd {
 	uint32_t unpacked_lun;
 	enum dma_data_direction dma_data_direction;
 
+	uint16_t vp_idx;
 	uint16_t loop_id;	/* to save extra sess dereferences */
 	struct qla_tgt *tgt;	/* to save extra sess dereferences */
 	struct scsi_qla_host *vha;
