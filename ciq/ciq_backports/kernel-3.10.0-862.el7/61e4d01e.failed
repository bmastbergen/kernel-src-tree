ipv6: fib: Add offload indication to routes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 61e4d01e16acddadb9723143637a20417fa67ac9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/61e4d01e.failed

Allow user space applications to see which routes are offloaded and
which aren't by setting the RTNH_F_OFFLOAD flag when dumping them.

To be consistent with IPv4, offload indication is provided on a
per-nexthop basis.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 61e4d01e16acddadb9723143637a20417fa67ac9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/ipv6_route.h
#	net/ipv6/route.c
diff --cc include/uapi/linux/ipv6_route.h
index f6598d1c886e,33e2a5732bd1..000000000000
--- a/include/uapi/linux/ipv6_route.h
+++ b/include/uapi/linux/ipv6_route.h
@@@ -34,7 -35,8 +34,12 @@@
  #define RTF_PREF(pref)	((pref) << 27)
  #define RTF_PREF_MASK	0x18000000
  
++<<<<<<< HEAD
 +#define RTF_PCPU	0x40000000
++=======
+ #define RTF_OFFLOAD	0x20000000	/* offloaded route		*/
+ #define RTF_PCPU	0x40000000	/* read-only: can not be set by user */
++>>>>>>> 61e4d01e16ac (ipv6: fib: Add offload indication to routes)
  #define RTF_LOCAL	0x80000000
  
  
diff --cc net/ipv6/route.c
index bac9d71c26f1,aba07fce67fb..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1809,12 -1812,33 +1809,34 @@@ int ip6_route_info_create(struct fib6_c
  	struct inet6_dev *idev = NULL;
  	struct fib6_table *table;
  	int addr_type;
 -	int err = -EINVAL;
  
++<<<<<<< HEAD
 +	if (cfg->fc_dst_len > 128 || cfg->fc_src_len > 128)
 +		return -EINVAL;
++=======
+ 	/* RTF_PCPU is an internal flag; can not be set by userspace */
+ 	if (cfg->fc_flags & RTF_PCPU) {
+ 		NL_SET_ERR_MSG(extack, "Userspace can not set RTF_PCPU");
+ 		goto out;
+ 	}
+ 
+ 	if (cfg->fc_flags & RTF_OFFLOAD) {
+ 		NL_SET_ERR_MSG(extack, "Userspace can not set RTF_OFFLOAD");
+ 		goto out;
+ 	}
+ 
+ 	if (cfg->fc_dst_len > 128) {
+ 		NL_SET_ERR_MSG(extack, "Invalid prefix length");
+ 		goto out;
+ 	}
+ 	if (cfg->fc_src_len > 128) {
+ 		NL_SET_ERR_MSG(extack, "Invalid source address length");
+ 		goto out;
+ 	}
++>>>>>>> 61e4d01e16ac (ipv6: fib: Add offload indication to routes)
  #ifndef CONFIG_IPV6_SUBTREES
 -	if (cfg->fc_src_len) {
 -		NL_SET_ERR_MSG(extack,
 -			       "Specifying source address requires IPV6_SUBTREES to be enabled");
 -		goto out;
 -	}
 +	if (cfg->fc_src_len)
 +		return -EINVAL;
  #endif
  	if (cfg->fc_ifindex) {
  		err = -ENODEV;
@@@ -3086,8 -3312,69 +3108,74 @@@ static inline size_t rt6_nlmsg_size(str
  	       + nla_total_size(4) /* RTA_PRIORITY */
  	       + RTAX_MAX * nla_total_size(4) /* RTA_METRICS */
  	       + nla_total_size(sizeof(struct rta_cacheinfo))
++<<<<<<< HEAD
 +	       + nla_total_size(TCP_CA_NAME_MAX)  /* RTAX_CC_ALGO */
 +	       + lwtunnel_get_encap_size(rt->dst.lwtstate);
++=======
+ 	       + nla_total_size(TCP_CA_NAME_MAX) /* RTAX_CC_ALGO */
+ 	       + nla_total_size(1) /* RTA_PREF */
+ 	       + lwtunnel_get_encap_size(rt->dst.lwtstate)
+ 	       + nexthop_len;
+ }
+ 
+ static int rt6_nexthop_info(struct sk_buff *skb, struct rt6_info *rt,
+ 			    unsigned int *flags, bool skip_oif)
+ {
+ 	if (!netif_running(rt->dst.dev) || !netif_carrier_ok(rt->dst.dev)) {
+ 		*flags |= RTNH_F_LINKDOWN;
+ 		if (rt->rt6i_idev->cnf.ignore_routes_with_linkdown)
+ 			*flags |= RTNH_F_DEAD;
+ 	}
+ 
+ 	if (rt->rt6i_flags & RTF_GATEWAY) {
+ 		if (nla_put_in6_addr(skb, RTA_GATEWAY, &rt->rt6i_gateway) < 0)
+ 			goto nla_put_failure;
+ 	}
+ 
+ 	if (rt->rt6i_flags & RTF_OFFLOAD)
+ 		*flags |= RTNH_F_OFFLOAD;
+ 
+ 	/* not needed for multipath encoding b/c it has a rtnexthop struct */
+ 	if (!skip_oif && rt->dst.dev &&
+ 	    nla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex))
+ 		goto nla_put_failure;
+ 
+ 	if (rt->dst.lwtstate &&
+ 	    lwtunnel_fill_encap(skb, rt->dst.lwtstate) < 0)
+ 		goto nla_put_failure;
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
+ /* add multipath next hop */
+ static int rt6_add_nexthop(struct sk_buff *skb, struct rt6_info *rt)
+ {
+ 	struct rtnexthop *rtnh;
+ 	unsigned int flags = 0;
+ 
+ 	rtnh = nla_reserve_nohdr(skb, sizeof(*rtnh));
+ 	if (!rtnh)
+ 		goto nla_put_failure;
+ 
+ 	rtnh->rtnh_hops = 0;
+ 	rtnh->rtnh_ifindex = rt->dst.dev ? rt->dst.dev->ifindex : 0;
+ 
+ 	if (rt6_nexthop_info(skb, rt, &flags, true) < 0)
+ 		goto nla_put_failure;
+ 
+ 	rtnh->rtnh_flags = flags;
+ 
+ 	/* length of rtnetlink header + attributes */
+ 	rtnh->rtnh_len = nlmsg_get_pos(skb) - (void *)rtnh;
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
++>>>>>>> 61e4d01e16ac (ipv6: fib: Add offload indication to routes)
  }
  
  static int rt6_fill_node(struct net *net,
* Unmerged path include/uapi/linux/ipv6_route.h
* Unmerged path net/ipv6/route.c
