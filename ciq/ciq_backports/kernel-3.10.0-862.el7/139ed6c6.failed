net/mlx5: Fix steering memory leak

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Fix steering memory leak (Kamal Heib) [1534242]
Rebuild_FUZZ: 93.75%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 139ed6c6c46aa3d8970a086b8e0cf1f3522f5d4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/139ed6c6.failed

Flow steering priority and namespace are software only objects that
didn't have the proper destructors and were not freed during steering
cleanup.

Fix it by adding destructor functions for these objects.

Fixes: bd71b08ec2ee ("net/mlx5: Support multiple updates of steering rules in parallel")
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 139ed6c6c46aa3d8970a086b8e0cf1f3522f5d4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index f60baa93f1dc,dfaad9ecb2b8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -143,16 -145,41 +143,48 @@@ static struct init_tree_node 
  	}
  };
  
 -enum fs_i_lock_class {
 -	FS_LOCK_GRANDPARENT,
 -	FS_LOCK_PARENT,
 -	FS_LOCK_CHILD
 +enum fs_i_mutex_lock_class {
 +	FS_MUTEX_GRANDPARENT,
 +	FS_MUTEX_PARENT,
 +	FS_MUTEX_CHILD
  };
  
++<<<<<<< HEAD
 +static void del_rule(struct fs_node *node);
 +static void del_flow_table(struct fs_node *node);
 +static void del_flow_group(struct fs_node *node);
 +static void del_fte(struct fs_node *node);
++=======
+ static const struct rhashtable_params rhash_fte = {
+ 	.key_len = FIELD_SIZEOF(struct fs_fte, val),
+ 	.key_offset = offsetof(struct fs_fte, val),
+ 	.head_offset = offsetof(struct fs_fte, hash),
+ 	.automatic_shrinking = true,
+ 	.min_size = 1,
+ };
+ 
+ static const struct rhashtable_params rhash_fg = {
+ 	.key_len = FIELD_SIZEOF(struct mlx5_flow_group, mask),
+ 	.key_offset = offsetof(struct mlx5_flow_group, mask),
+ 	.head_offset = offsetof(struct mlx5_flow_group, hash),
+ 	.automatic_shrinking = true,
+ 	.min_size = 1,
+ 
+ };
+ 
+ static void del_hw_flow_table(struct fs_node *node);
+ static void del_hw_flow_group(struct fs_node *node);
+ static void del_hw_fte(struct fs_node *node);
+ static void del_sw_flow_table(struct fs_node *node);
+ static void del_sw_flow_group(struct fs_node *node);
+ static void del_sw_fte(struct fs_node *node);
+ static void del_sw_prio(struct fs_node *node);
+ static void del_sw_ns(struct fs_node *node);
+ /* Delete rule (destination) is special case that 
+  * requires to lock the FTE for all the deletion process.
+  */
+ static void del_sw_hw_rule(struct fs_node *node);
++>>>>>>> 139ed6c6c46a (net/mlx5: Fix steering memory leak)
  static bool mlx5_flow_dests_cmp(struct mlx5_flow_destination *d1,
  				struct mlx5_flow_destination *d2);
  static struct mlx5_flow_rule *
@@@ -346,7 -410,17 +378,21 @@@ static inline struct mlx5_core_dev *get
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static void del_flow_table(struct fs_node *node)
++=======
+ static void del_sw_ns(struct fs_node *node)
+ {
+ 	kfree(node);
+ }
+ 
+ static void del_sw_prio(struct fs_node *node)
+ {
+ 	kfree(node);
+ }
+ 
+ static void del_hw_flow_table(struct fs_node *node)
++>>>>>>> 139ed6c6c46a (net/mlx5: Fix steering memory leak)
  {
  	struct mlx5_flow_table *ft;
  	struct mlx5_core_dev *dev;
@@@ -1637,7 -2076,7 +1683,11 @@@ static struct fs_prio *fs_create_prio(s
  		return ERR_PTR(-ENOMEM);
  
  	fs_prio->node.type = FS_TYPE_PRIO;
++<<<<<<< HEAD
 +	tree_init_node(&fs_prio->node, 1, NULL);
++=======
+ 	tree_init_node(&fs_prio->node, NULL, del_sw_prio);
++>>>>>>> 139ed6c6c46a (net/mlx5: Fix steering memory leak)
  	tree_add_node(&fs_prio->node, &ns->node);
  	fs_prio->num_levels = num_levels;
  	fs_prio->prio = prio;
@@@ -1663,7 -2102,7 +1713,11 @@@ static struct mlx5_flow_namespace *fs_c
  		return ERR_PTR(-ENOMEM);
  
  	fs_init_namespace(ns);
++<<<<<<< HEAD
 +	tree_init_node(&ns->node, 1, NULL);
++=======
+ 	tree_init_node(&ns->node, NULL, del_sw_ns);
++>>>>>>> 139ed6c6c46a (net/mlx5: Fix steering memory leak)
  	tree_add_node(&ns->node, &prio->node);
  	list_add_tail(&ns->node.list, &prio->node.children);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
