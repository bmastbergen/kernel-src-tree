scsi: qla2xxx: Fix NULL pointer access due to redundant fc_host_port_name call

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix NULL pointer access due to redundant fc_host_port_name call (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 96.00%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 0ea88662b5c6404a8f7af6b040b3cf1f0e8c3a66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0ea88662.failed

Remove redundant fc_host_port_name calls to prevent early access of
scsi_host->shost_data buffer. This prevent null pointer access.

Following stack trace is seen:

BUG: unable to handle kernel NULL pointer dereference at 00000000000008
IP: qla24xx_report_id_acquisition+0x22d/0x3a0 [qla2xxx]

	Cc: <stable@vger.kernel.org> # v4.11+
	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0ea88662b5c6404a8f7af6b040b3cf1f0e8c3a66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_mbx.c
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 21eee93873e8,12fea77e31c6..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -3499,62 -3659,77 +3499,99 @@@ qla24xx_report_id_acquisition(scsi_qla_
  		    rptid_entry->port_id[0]);
  
  		/* buffer to buffer credit flag */
 -		vha->flags.bbcr_enable = (rptid_entry->u.f1.bbcr & 0xf) != 0;
 -
 -		if (rptid_entry->vp_idx == 0) {
 -			if (rptid_entry->vp_status == VP_STAT_COMPL) {
 -				/* FA-WWN is only for physical port */
 -				if (qla_ini_mode_enabled(vha) &&
 -				    ha->flags.fawwpn_enabled &&
 -				    (rptid_entry->u.f1.flags &
 -				     VP_FLAGS_NAME_VALID)) {
 -					memcpy(vha->port_name,
 -					    rptid_entry->u.f1.port_name,
 -					    WWN_SIZE);
 -				}
 +		vha->flags.bbcr_enable = (rptid_entry->bbcr & 0xf) != 0;
 +
 +		/* FA-WWN is only for physical port */
 +		if (!vp_idx) {
 +			void *wwpn = ha->init_cb->port_name;
  
 -				qlt_update_host_map(vha, id);
 +			if (!MSB(stat)) {
 +				if (rptid_entry->vp_idx_map[1] & BIT_6)
 +					wwpn = rptid_entry->reserved_4 + 8;
  			}
++<<<<<<< HEAD
 +			memcpy(vha->port_name, wwpn, WWN_SIZE);
 +			fc_host_port_name(vha->host) =
 +			    wwn_to_u64(vha->port_name);
 +			ql_dbg(ql_dbg_mbx, vha, 0x1018,
 +			    "FA-WWN portname %016llx (%x)\n",
 +			    fc_host_port_name(vha->host), MSB(stat));
++=======
+ 
+ 			set_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);
+ 			set_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);
+ 		} else {
+ 			if (rptid_entry->vp_status != VP_STAT_COMPL &&
+ 				rptid_entry->vp_status != VP_STAT_ID_CHG) {
+ 				ql_dbg(ql_dbg_mbx, vha, 0x10ba,
+ 				    "Could not acquire ID for VP[%d].\n",
+ 				    rptid_entry->vp_idx);
+ 				return;
+ 			}
+ 
+ 			found = 0;
+ 			spin_lock_irqsave(&ha->vport_slock, flags);
+ 			list_for_each_entry(vp, &ha->vp_list, list) {
+ 				if (rptid_entry->vp_idx == vp->vp_idx) {
+ 					found = 1;
+ 					break;
+ 				}
+ 			}
+ 			spin_unlock_irqrestore(&ha->vport_slock, flags);
+ 
+ 			if (!found)
+ 				return;
+ 
+ 			qlt_update_host_map(vp, id);
+ 
+ 			/*
+ 			 * Cannot configure here as we are still sitting on the
+ 			 * response queue. Handle it in dpc context.
+ 			 */
+ 			set_bit(VP_IDX_ACQUIRED, &vp->vp_flags);
+ 			set_bit(REGISTER_FC4_NEEDED, &vp->dpc_flags);
+ 			set_bit(REGISTER_FDMI_NEEDED, &vp->dpc_flags);
++>>>>>>> 0ea88662b5c6 (scsi: qla2xxx: Fix NULL pointer access due to redundant fc_host_port_name call)
  		}
 -		set_bit(VP_DPC_NEEDED, &vha->dpc_flags);
 -		qla2xxx_wake_dpc(vha);
 -	} else if (rptid_entry->format == 2) {
 -		ql_dbg(ql_dbg_async, vha, 0xffff,
 -		    "RIDA: format 2/N2N Primary port id %02x%02x%02x.\n",
 -		    rptid_entry->port_id[2], rptid_entry->port_id[1],
 -		    rptid_entry->port_id[0]);
  
 -		ql_dbg(ql_dbg_async, vha, 0xffff,
 -		    "N2N: Remote WWPN %8phC.\n",
 -		    rptid_entry->u.f2.port_name);
 +		vp = vha;
 +		if (vp_idx == 0)
 +			goto reg_needed;
  
 -		/* N2N.  direct connect */
 -		vha->d_id.b.domain = rptid_entry->port_id[2];
 -		vha->d_id.b.area = rptid_entry->port_id[1];
 -		vha->d_id.b.al_pa = rptid_entry->port_id[0];
 +		if (MSB(stat) != 0 && MSB(stat) != 2) {
 +			ql_dbg(ql_dbg_mbx, vha, 0x10ba,
 +			    "Could not acquire ID for VP[%d].\n", vp_idx);
 +			return;
 +		}
  
 +		found = 0;
  		spin_lock_irqsave(&ha->vport_slock, flags);
 -		qlt_update_vp_map(vha, SET_AL_PA);
 +		list_for_each_entry(vp, &ha->vp_list, list) {
 +			if (vp_idx == vp->vp_idx) {
 +				found = 1;
 +				break;
 +			}
 +		}
  		spin_unlock_irqrestore(&ha->vport_slock, flags);
 +
 +		if (!found)
 +			return;
 +
 +		vp->d_id.b.domain = rptid_entry->port_id[2];
 +		vp->d_id.b.area =  rptid_entry->port_id[1];
 +		vp->d_id.b.al_pa = rptid_entry->port_id[0];
 +
 +		/*
 +		 * Cannot configure here as we are still sitting on the
 +		 * response queue. Handle it in dpc context.
 +		 */
 +		set_bit(VP_IDX_ACQUIRED, &vp->vp_flags);
 +
 +reg_needed:
 +		set_bit(REGISTER_FC4_NEEDED, &vp->dpc_flags);
 +		set_bit(REGISTER_FDMI_NEEDED, &vp->dpc_flags);
 +		set_bit(VP_DPC_NEEDED, &vha->dpc_flags);
 +		qla2xxx_wake_dpc(vha);
  	}
  }
  
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
