qede: Fix sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Manish Chopra <Manish.Chopra@cavium.com>
commit 48848a0690a36d0248255f6c3b7b6fd2a9948a57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/48848a06.failed

Solves the following warning in qede -
 - Several cases of missing cpu_to_le16() conversions
 - Adds 'static' to one function declaration
 - Removes dcbnl operation that's currently getting populated twice

	Signed-off-by: Manish Chopra <Manish.Chopra@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 48848a0690a36d0248255f6c3b7b6fd2a9948a57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qede/qede_fp.c
diff --cc drivers/net/ethernet/qlogic/qede/qede_fp.c
index f9574e2b30d3,892eb98290f6..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_fp.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_fp.c
@@@ -327,6 -329,51 +327,54 @@@ static inline void qede_update_tx_produ
  	mmiowb();
  }
  
++<<<<<<< HEAD
++=======
+ static int qede_xdp_xmit(struct qede_dev *edev, struct qede_fastpath *fp,
+ 			 struct sw_rx_data *metadata, u16 padding, u16 length)
+ {
+ 	struct qede_tx_queue *txq = fp->xdp_tx;
+ 	struct eth_tx_1st_bd *first_bd;
+ 	u16 idx = txq->sw_tx_prod;
+ 	u16 val;
+ 
+ 	if (!qed_chain_get_elem_left(&txq->tx_pbl)) {
+ 		txq->stopped_cnt++;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	first_bd = (struct eth_tx_1st_bd *)qed_chain_produce(&txq->tx_pbl);
+ 
+ 	memset(first_bd, 0, sizeof(*first_bd));
+ 	first_bd->data.bd_flags.bitfields =
+ 	    BIT(ETH_TX_1ST_BD_FLAGS_START_BD_SHIFT);
+ 
+ 	val = (length & ETH_TX_DATA_1ST_BD_PKT_LEN_MASK) <<
+ 	       ETH_TX_DATA_1ST_BD_PKT_LEN_SHIFT;
+ 
+ 	first_bd->data.bitfields |= cpu_to_le16(val);
+ 	first_bd->data.nbds = 1;
+ 
+ 	/* We can safely ignore the offset, as it's 0 for XDP */
+ 	BD_SET_UNMAP_ADDR_LEN(first_bd, metadata->mapping + padding, length);
+ 
+ 	/* Synchronize the buffer back to device, as program [probably]
+ 	 * has changed it.
+ 	 */
+ 	dma_sync_single_for_device(&edev->pdev->dev,
+ 				   metadata->mapping + padding,
+ 				   length, PCI_DMA_TODEVICE);
+ 
+ 	txq->sw_tx_ring.xdp[idx].page = metadata->data;
+ 	txq->sw_tx_ring.xdp[idx].mapping = metadata->mapping;
+ 	txq->sw_tx_prod = (txq->sw_tx_prod + 1) % txq->num_tx_buffers;
+ 
+ 	/* Mark the fastpath for future XDP doorbell */
+ 	fp->xdp_xmit = 1;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 48848a0690a3 (qede: Fix sparse warnings)
  int qede_txq_has_work(struct qede_tx_queue *txq)
  {
  	u16 hw_bd_cons;
diff --git a/drivers/net/ethernet/qlogic/qede/qede_dcbnl.c b/drivers/net/ethernet/qlogic/qede/qede_dcbnl.c
index 8b5d2ed07983..0201feba9d01 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_dcbnl.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_dcbnl.c
@@ -313,7 +313,6 @@ static const struct dcbnl_rtnl_ops qede_dcbnl_ops = {
 	.ieee_setets = qede_dcbnl_ieee_setets,
 	.ieee_getapp = qede_dcbnl_ieee_getapp,
 	.ieee_setapp = qede_dcbnl_ieee_setapp,
-	.getdcbx = qede_dcbnl_getdcbx,
 	.ieee_peer_getpfc = qede_dcbnl_ieee_peer_getpfc,
 	.ieee_peer_getets = qede_dcbnl_ieee_peer_getets,
 	.getstate = qede_dcbnl_getstate,
diff --git a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
index a54ac620bb6b..f88b64224c09 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
@@ -1284,7 +1284,8 @@ static int qede_selftest_transmit_traffic(struct qede_dev *edev,
 	struct qede_tx_queue *txq = NULL;
 	struct eth_tx_1st_bd *first_bd;
 	dma_addr_t mapping;
-	int i, idx, val;
+	int i, idx;
+	u16 val;
 
 	for_each_queue(i) {
 		if (edev->fp_array[i].type & QEDE_FASTPATH_TX) {
@@ -1306,7 +1307,8 @@ static int qede_selftest_transmit_traffic(struct qede_dev *edev,
 	val = 1 << ETH_TX_1ST_BD_FLAGS_START_BD_SHIFT;
 	first_bd->data.bd_flags.bitfields = val;
 	val = skb->len & ETH_TX_DATA_1ST_BD_PKT_LEN_MASK;
-	first_bd->data.bitfields |= (val << ETH_TX_DATA_1ST_BD_PKT_LEN_SHIFT);
+	val = val << ETH_TX_DATA_1ST_BD_PKT_LEN_SHIFT;
+	first_bd->data.bitfields |= cpu_to_le16(val);
 
 	/* Map skb linear data for DMA and set in the first BD */
 	mapping = dma_map_single(&edev->pdev->dev, skb->data,
@@ -1321,8 +1323,8 @@ static int qede_selftest_transmit_traffic(struct qede_dev *edev,
 	first_bd->data.nbds = 1;
 	txq->sw_tx_prod++;
 	/* 'next page' entries are counted in the producer value */
-	val = cpu_to_le16(qed_chain_get_prod_idx(&txq->tx_pbl));
-	txq->tx_db.data.bd_prod = val;
+	val = qed_chain_get_prod_idx(&txq->tx_pbl);
+	txq->tx_db.data.bd_prod = cpu_to_le16(val);
 
 	/* wmb makes sure that the BDs data is updated before updating the
 	 * producer, otherwise FW may read old data from the BDs.
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_fp.c
diff --git a/drivers/net/ethernet/qlogic/qede/qede_roce.c b/drivers/net/ethernet/qlogic/qede/qede_roce.c
index f00657ce7c8f..c0030fb8d842 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_roce.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_roce.c
@@ -221,8 +221,8 @@ static void qede_roce_changeaddr(struct qede_dev *edev)
 		qedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_CHANGE_ADDR);
 }
 
-struct qede_roce_event_work *qede_roce_get_free_event_node(struct qede_dev
-							   *edev)
+static struct qede_roce_event_work *
+qede_roce_get_free_event_node(struct qede_dev *edev)
 {
 	struct qede_roce_event_work *event_node = NULL;
 	struct list_head *list_node = NULL;
