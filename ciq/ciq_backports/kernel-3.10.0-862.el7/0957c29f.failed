IB/core: Restore I/O MMU, s390 and powerpc support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 0957c29f78af7d890c4ac506eda8f76bfc5a137a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0957c29f.failed

Avoid that the following error message is reported on the console
while loading an RDMA driver with I/O MMU support enabled:

DMAR: Allocating domain for mlx5_0 failed

Ensure that DMA mapping operations that use to_pci_dev() to
access to struct pci_dev see the correct PCI device. E.g. the s390
and powerpc DMA mapping operations use to_pci_dev() even with I/O
MMU support disabled.

This patch preserves the following changes of the DMA mapping updates
patch series:
- Introduction of dma_virt_ops.
- Removal of ib_device.dma_ops.
- Removal of struct ib_dma_mapping_ops.
- Removal of an if-statement from each ib_dma_*() operation.
- IB HW drivers no longer set dma_device directly.

	Reported-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Reported-by: Parav Pandit <parav@mellanox.com>
Fixes: commit 99db9494035f ("IB/core: Remove ib_device.dma_device")
	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: parav@mellanox.com
	Tested-by: parav@mellanox.com
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 0957c29f78af7d890c4ac506eda8f76bfc5a137a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/device.c
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/device.c
index d71a36e339d0,addf869045cc..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -333,14 -333,29 +333,38 @@@ int ib_register_device(struct ib_devic
  	int ret;
  	struct ib_client *client;
  	struct ib_udata uhw = {.outlen = 0, .inlen = 0};
 -	struct device *parent = device->dev.parent;
  
++<<<<<<< HEAD
 +	WARN_ON_ONCE(!device->dev.parent && !device->dma_device);
 +	WARN_ON_ONCE(device->dev.parent && device->dma_device
 +		     && device->dev.parent != device->dma_device);
 +	if (!device->dev.parent)
 +		device->dev.parent = device->dma_device;
 +	if (!device->dma_device)
 +		device->dma_device = device->dev.parent;
++=======
+ 	WARN_ON_ONCE(!parent);
+ 	WARN_ON_ONCE(device->dma_device);
+ 	if (device->dev.dma_ops) {
+ 		/*
+ 		 * The caller provided custom DMA operations. Copy the
+ 		 * DMA-related fields that are used by e.g. dma_alloc_coherent()
+ 		 * into device->dev.
+ 		 */
+ 		device->dma_device = &device->dev;
+ 		if (!device->dev.dma_mask)
+ 			device->dev.dma_mask = parent->dma_mask;
+ 		if (!device->dev.coherent_dma_mask)
+ 			device->dev.coherent_dma_mask =
+ 				parent->coherent_dma_mask;
+ 	} else {
+ 		/*
+ 		 * The caller did not provide custom DMA operations. Use the
+ 		 * DMA mapping operations of the parent device.
+ 		 */
+ 		device->dma_device = parent;
+ 	}
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  
  	mutex_lock(&device_mutex);
  
diff --cc include/rdma/ib_verbs.h
index 6716ea884d52,99e4423eb2b8..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -1888,6 -1863,7 +1888,10 @@@ struct ib_port_immutable 
  };
  
  struct ib_device {
++<<<<<<< HEAD
++=======
+ 	/* Do not access @dma_device directly from ULP nor from HW drivers. */
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  	struct device                *dma_device;
  
  	char                          name[IB_DEVICE_NAME_MAX];
@@@ -3015,8 -3010,6 +3019,11 @@@ static inline int ib_req_ncomp_notif(st
   */
  static inline int ib_dma_mapping_error(struct ib_device *dev, u64 dma_addr)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		return dev->dma_ops->mapping_error(dev, dma_addr);
++=======
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  	return dma_mapping_error(dev->dma_device, dma_addr);
  }
  
@@@ -3031,8 -3024,6 +3038,11 @@@ static inline u64 ib_dma_map_single(str
  				    void *cpu_addr, size_t size,
  				    enum dma_data_direction direction)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		return dev->dma_ops->map_single(dev, cpu_addr, size, direction);
++=======
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  	return dma_map_single(dev->dma_device, cpu_addr, size, direction);
  }
  
@@@ -3047,28 -3038,7 +3057,32 @@@ static inline void ib_dma_unmap_single(
  				       u64 addr, size_t size,
  				       enum dma_data_direction direction)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		dev->dma_ops->unmap_single(dev, addr, size, direction);
 +	else
 +		dma_unmap_single(dev->dma_device, addr, size, direction);
 +}
 +
 +static inline u64 ib_dma_map_single_attrs(struct ib_device *dev,
 +					  void *cpu_addr, size_t size,
 +					  enum dma_data_direction direction,
 +					  struct dma_attrs *attrs)
 +{
 +	return dma_map_single_attrs(dev->dma_device, cpu_addr, size,
 +				    direction, attrs);
 +}
 +
 +static inline void ib_dma_unmap_single_attrs(struct ib_device *dev,
 +					     u64 addr, size_t size,
 +					     enum dma_data_direction direction,
 +					     struct dma_attrs *attrs)
 +{
 +	return dma_unmap_single_attrs(dev->dma_device, addr, size,
 +				      direction, attrs);
++=======
+ 	dma_unmap_single(dev->dma_device, addr, size, direction);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  /**
@@@ -3085,8 -3055,6 +3099,11 @@@ static inline u64 ib_dma_map_page(struc
  				  size_t size,
  					 enum dma_data_direction direction)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		return dev->dma_ops->map_page(dev, page, offset, size, direction);
++=======
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  	return dma_map_page(dev->dma_device, page, offset, size, direction);
  }
  
@@@ -3101,10 -3069,7 +3118,14 @@@ static inline void ib_dma_unmap_page(st
  				     u64 addr, size_t size,
  				     enum dma_data_direction direction)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		dev->dma_ops->unmap_page(dev, addr, size, direction);
 +	else
 +		dma_unmap_page(dev->dma_device, addr, size, direction);
++=======
+ 	dma_unmap_page(dev->dma_device, addr, size, direction);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  /**
@@@ -3118,8 -3083,6 +3139,11 @@@ static inline int ib_dma_map_sg(struct 
  				struct scatterlist *sg, int nents,
  				enum dma_data_direction direction)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		return dev->dma_ops->map_sg(dev, sg, nents, direction);
++=======
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  	return dma_map_sg(dev->dma_device, sg, nents, direction);
  }
  
@@@ -3134,36 -3097,24 +3158,49 @@@ static inline void ib_dma_unmap_sg(stru
  				   struct scatterlist *sg, int nents,
  				   enum dma_data_direction direction)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		dev->dma_ops->unmap_sg(dev, sg, nents, direction);
 +	else
 +		dma_unmap_sg(dev->dma_device, sg, nents, direction);
++=======
+ 	dma_unmap_sg(dev->dma_device, sg, nents, direction);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  static inline int ib_dma_map_sg_attrs(struct ib_device *dev,
  				      struct scatterlist *sg, int nents,
  				      enum dma_data_direction direction,
 -				      unsigned long dma_attrs)
 +				      struct dma_attrs *attrs)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		return dev->dma_ops->map_sg_attrs(dev, sg, nents, direction,
 +						  attrs);
 +	else
 +		return dma_map_sg_attrs(dev->dma_device, sg, nents, direction,
 +					attrs);
++=======
+ 	return dma_map_sg_attrs(dev->dma_device, sg, nents, direction,
+ 				dma_attrs);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  static inline void ib_dma_unmap_sg_attrs(struct ib_device *dev,
  					 struct scatterlist *sg, int nents,
  					 enum dma_data_direction direction,
 -					 unsigned long dma_attrs)
 +					 struct dma_attrs *attrs)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		return dev->dma_ops->unmap_sg_attrs(dev, sg, nents, direction,
 +						    attrs);
 +	else
 +		dma_unmap_sg_attrs(dev->dma_device, sg, nents, direction,
 +				   attrs);
++=======
+ 	dma_unmap_sg_attrs(dev->dma_device, sg, nents, direction, dma_attrs);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  /**
   * ib_sg_dma_address - Return the DMA address from a scatter/gather entry
@@@ -3205,10 -3156,7 +3242,14 @@@ static inline void ib_dma_sync_single_f
  					      size_t size,
  					      enum dma_data_direction dir)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		dev->dma_ops->sync_single_for_cpu(dev, addr, size, dir);
 +	else
 +		dma_sync_single_for_cpu(dev->dma_device, addr, size, dir);
++=======
+ 	dma_sync_single_for_cpu(dev->dma_device, addr, size, dir);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  /**
@@@ -3223,10 -3171,7 +3264,14 @@@ static inline void ib_dma_sync_single_f
  						 size_t size,
  						 enum dma_data_direction dir)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		dev->dma_ops->sync_single_for_device(dev, addr, size, dir);
 +	else
 +		dma_sync_single_for_device(dev->dma_device, addr, size, dir);
++=======
+ 	dma_sync_single_for_device(dev->dma_device, addr, size, dir);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  /**
@@@ -3241,14 -3186,6 +3286,17 @@@ static inline void *ib_dma_alloc_cohere
  					   dma_addr_t *dma_handle,
  					   gfp_t flag)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops) {
 +		u64 handle;
 +		void *ret;
 +
 +		ret = dev->dma_ops->alloc_coherent(dev, size, &handle, flag);
 +		*dma_handle = handle;
 +		return ret;
 +	}
++=======
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  	return dma_alloc_coherent(dev->dma_device, size, dma_handle, flag);
  }
  
@@@ -3263,10 -3200,7 +3311,14 @@@ static inline void ib_dma_free_coherent
  					size_t size, void *cpu_addr,
  					dma_addr_t dma_handle)
  {
++<<<<<<< HEAD
 +	if (dev->dma_ops)
 +		dev->dma_ops->free_coherent(dev, size, cpu_addr, dma_handle);
 +	else
 +		dma_free_coherent(dev->dma_device, size, cpu_addr, dma_handle);
++=======
+ 	dma_free_coherent(dev->dma_device, size, cpu_addr, dma_handle);
++>>>>>>> 0957c29f78af (IB/core: Restore I/O MMU, s390 and powerpc support)
  }
  
  /**
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path include/rdma/ib_verbs.h
