net/mlx5: Add mlxfw callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add mlxfw callbacks (Don Dutile) [1499363 1466367]
Rebuild_FUZZ: 92.59%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 62bd22cf326dc4ac5be673c11cef4602dc1f5e47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/62bd22cf.failed

Add mlx5 implementation for the ones defined by the mlxfw
shared module to be used while flashing the device firmware.

The callbacks do their job through the MCQI, MCC and MCDA registers.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 62bd22cf326dc4ac5be673c11cef4602dc1f5e47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fw.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fw.c
index 1bc14d0fded8,fa33d59ab485..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fw.c
@@@ -195,3 -196,298 +196,301 @@@ int mlx5_cmd_teardown_hca(struct mlx5_c
  	MLX5_SET(teardown_hca_in, in, opcode, MLX5_CMD_OP_TEARDOWN_HCA);
  	return mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
  }
++<<<<<<< HEAD
++=======
+ 
+ int mlx5_cmd_force_teardown_hca(struct mlx5_core_dev *dev)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(teardown_hca_out)] = {0};
+ 	u32 in[MLX5_ST_SZ_DW(teardown_hca_in)] = {0};
+ 	int force_state;
+ 	int ret;
+ 
+ 	if (!MLX5_CAP_GEN(dev, force_teardown)) {
+ 		mlx5_core_dbg(dev, "force teardown is not supported in the firmware\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	MLX5_SET(teardown_hca_in, in, opcode, MLX5_CMD_OP_TEARDOWN_HCA);
+ 	MLX5_SET(teardown_hca_in, in, profile, MLX5_TEARDOWN_HCA_IN_PROFILE_FORCE_CLOSE);
+ 
+ 	ret = mlx5_cmd_exec_polling(dev, in, sizeof(in), out, sizeof(out));
+ 	if (ret)
+ 		return ret;
+ 
+ 	force_state = MLX5_GET(teardown_hca_out, out, force_state);
+ 	if (force_state == MLX5_TEARDOWN_HCA_OUT_FORCE_STATE_FAIL) {
+ 		mlx5_core_err(dev, "teardown with force mode failed\n");
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ enum mlxsw_reg_mcc_instruction {
+ 	MLX5_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE = 0x01,
+ 	MLX5_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE = 0x02,
+ 	MLX5_REG_MCC_INSTRUCTION_UPDATE_COMPONENT = 0x03,
+ 	MLX5_REG_MCC_INSTRUCTION_VERIFY_COMPONENT = 0x04,
+ 	MLX5_REG_MCC_INSTRUCTION_ACTIVATE = 0x06,
+ 	MLX5_REG_MCC_INSTRUCTION_CANCEL = 0x08,
+ };
+ 
+ static int mlx5_reg_mcc_set(struct mlx5_core_dev *dev,
+ 			    enum mlxsw_reg_mcc_instruction instr,
+ 			    u16 component_index, u32 update_handle,
+ 			    u32 component_size)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(mcc_reg)];
+ 	u32 in[MLX5_ST_SZ_DW(mcc_reg)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 
+ 	MLX5_SET(mcc_reg, in, instruction, instr);
+ 	MLX5_SET(mcc_reg, in, component_index, component_index);
+ 	MLX5_SET(mcc_reg, in, update_handle, update_handle);
+ 	MLX5_SET(mcc_reg, in, component_size, component_size);
+ 
+ 	return mlx5_core_access_reg(dev, in, sizeof(in), out,
+ 				    sizeof(out), MLX5_REG_MCC, 0, 1);
+ }
+ 
+ static int mlx5_reg_mcc_query(struct mlx5_core_dev *dev,
+ 			      u32 *update_handle, u8 *error_code,
+ 			      u8 *control_state)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(mcc_reg)];
+ 	u32 in[MLX5_ST_SZ_DW(mcc_reg)];
+ 	int err;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	memset(out, 0, sizeof(out));
+ 	MLX5_SET(mcc_reg, in, update_handle, *update_handle);
+ 
+ 	err = mlx5_core_access_reg(dev, in, sizeof(in), out,
+ 				   sizeof(out), MLX5_REG_MCC, 0, 0);
+ 	if (err)
+ 		goto out;
+ 
+ 	*update_handle = MLX5_GET(mcc_reg, out, update_handle);
+ 	*error_code = MLX5_GET(mcc_reg, out, error_code);
+ 	*control_state = MLX5_GET(mcc_reg, out, control_state);
+ 
+ out:
+ 	return err;
+ }
+ 
+ static int mlx5_reg_mcda_set(struct mlx5_core_dev *dev,
+ 			     u32 update_handle,
+ 			     u32 offset, u16 size,
+ 			     u8 *data)
+ {
+ 	int err, in_size = MLX5_ST_SZ_BYTES(mcda_reg) + size;
+ 	u32 out[MLX5_ST_SZ_DW(mcda_reg)];
+ 	int i, j, dw_size = size >> 2;
+ 	__be32 data_element;
+ 	u32 *in;
+ 
+ 	in = kzalloc(in_size, GFP_KERNEL);
+ 	if (!in)
+ 		return -ENOMEM;
+ 
+ 	MLX5_SET(mcda_reg, in, update_handle, update_handle);
+ 	MLX5_SET(mcda_reg, in, offset, offset);
+ 	MLX5_SET(mcda_reg, in, size, size);
+ 
+ 	for (i = 0; i < dw_size; i++) {
+ 		j = i * 4;
+ 		data_element = htonl(*(u32 *)&data[j]);
+ 		memcpy(MLX5_ADDR_OF(mcda_reg, in, data) + j, &data_element, 4);
+ 	}
+ 
+ 	err = mlx5_core_access_reg(dev, in, in_size, out,
+ 				   sizeof(out), MLX5_REG_MCDA, 0, 1);
+ 	kfree(in);
+ 	return err;
+ }
+ 
+ static int mlx5_reg_mcqi_query(struct mlx5_core_dev *dev,
+ 			       u16 component_index,
+ 			       u32 *max_component_size,
+ 			       u8 *log_mcda_word_size,
+ 			       u16 *mcda_max_write_size)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(mcqi_reg) + MLX5_ST_SZ_DW(mcqi_cap)];
+ 	int offset = MLX5_ST_SZ_DW(mcqi_reg);
+ 	u32 in[MLX5_ST_SZ_DW(mcqi_reg)];
+ 	int err;
+ 
+ 	memset(in, 0, sizeof(in));
+ 	memset(out, 0, sizeof(out));
+ 
+ 	MLX5_SET(mcqi_reg, in, component_index, component_index);
+ 	MLX5_SET(mcqi_reg, in, data_size, MLX5_ST_SZ_BYTES(mcqi_cap));
+ 
+ 	err = mlx5_core_access_reg(dev, in, sizeof(in), out,
+ 				   sizeof(out), MLX5_REG_MCQI, 0, 0);
+ 	if (err)
+ 		goto out;
+ 
+ 	*max_component_size = MLX5_GET(mcqi_cap, out + offset, max_component_size);
+ 	*log_mcda_word_size = MLX5_GET(mcqi_cap, out + offset, log_mcda_word_size);
+ 	*mcda_max_write_size = MLX5_GET(mcqi_cap, out + offset, mcda_max_write_size);
+ 
+ out:
+ 	return err;
+ }
+ 
+ struct mlx5_mlxfw_dev {
+ 	struct mlxfw_dev mlxfw_dev;
+ 	struct mlx5_core_dev *mlx5_core_dev;
+ };
+ 
+ static int mlx5_component_query(struct mlxfw_dev *mlxfw_dev,
+ 				u16 component_index, u32 *p_max_size,
+ 				u8 *p_align_bits, u16 *p_max_write_size)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	return mlx5_reg_mcqi_query(dev, component_index, p_max_size,
+ 				   p_align_bits, p_max_write_size);
+ }
+ 
+ static int mlx5_fsm_lock(struct mlxfw_dev *mlxfw_dev, u32 *fwhandle)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 	u8 control_state, error_code;
+ 	int err;
+ 
+ 	*fwhandle = 0;
+ 	err = mlx5_reg_mcc_query(dev, fwhandle, &error_code, &control_state);
+ 	if (err)
+ 		return err;
+ 
+ 	if (control_state != MLXFW_FSM_STATE_IDLE)
+ 		return -EBUSY;
+ 
+ 	return mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE,
+ 				0, *fwhandle, 0);
+ }
+ 
+ static int mlx5_fsm_component_update(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,
+ 				     u16 component_index, u32 component_size)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	return mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_UPDATE_COMPONENT,
+ 				component_index, fwhandle, component_size);
+ }
+ 
+ static int mlx5_fsm_block_download(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,
+ 				   u8 *data, u16 size, u32 offset)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	return mlx5_reg_mcda_set(dev, fwhandle, offset, size, data);
+ }
+ 
+ static int mlx5_fsm_component_verify(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,
+ 				     u16 component_index)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	return mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_VERIFY_COMPONENT,
+ 				component_index, fwhandle, 0);
+ }
+ 
+ static int mlx5_fsm_activate(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	return mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_ACTIVATE,	0,
+ 				fwhandle, 0);
+ }
+ 
+ static int mlx5_fsm_query_state(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,
+ 				enum mlxfw_fsm_state *fsm_state,
+ 				enum mlxfw_fsm_state_err *fsm_state_err)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 	u8 control_state, error_code;
+ 	int err;
+ 
+ 	err = mlx5_reg_mcc_query(dev, &fwhandle, &error_code, &control_state);
+ 	if (err)
+ 		return err;
+ 
+ 	*fsm_state = control_state;
+ 	*fsm_state_err = min_t(enum mlxfw_fsm_state_err, error_code,
+ 			       MLXFW_FSM_STATE_ERR_MAX);
+ 	return 0;
+ }
+ 
+ static void mlx5_fsm_cancel(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_CANCEL, 0, fwhandle, 0);
+ }
+ 
+ static void mlx5_fsm_release(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)
+ {
+ 	struct mlx5_mlxfw_dev *mlx5_mlxfw_dev =
+ 		container_of(mlxfw_dev, struct mlx5_mlxfw_dev, mlxfw_dev);
+ 	struct mlx5_core_dev *dev = mlx5_mlxfw_dev->mlx5_core_dev;
+ 
+ 	mlx5_reg_mcc_set(dev, MLX5_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE, 0,
+ 			 fwhandle, 0);
+ }
+ 
+ static const struct mlxfw_dev_ops mlx5_mlxfw_dev_ops = {
+ 	.component_query	= mlx5_component_query,
+ 	.fsm_lock		= mlx5_fsm_lock,
+ 	.fsm_component_update	= mlx5_fsm_component_update,
+ 	.fsm_block_download	= mlx5_fsm_block_download,
+ 	.fsm_component_verify	= mlx5_fsm_component_verify,
+ 	.fsm_activate		= mlx5_fsm_activate,
+ 	.fsm_query_state	= mlx5_fsm_query_state,
+ 	.fsm_cancel		= mlx5_fsm_cancel,
+ 	.fsm_release		= mlx5_fsm_release
+ };
+ 
+ int mlx5_firmware_flash(struct mlx5_core_dev *dev,
+ 			const struct firmware *firmware)
+ {
+ 	struct mlx5_mlxfw_dev mlx5_mlxfw_dev = {
+ 		.mlxfw_dev = {
+ 			.ops = &mlx5_mlxfw_dev_ops,
+ 			.psid = dev->board_id,
+ 			.psid_size = strlen(dev->board_id),
+ 		},
+ 		.mlx5_core_dev = dev
+ 	};
+ 
+ 	if (!MLX5_CAP_GEN(dev, mcam_reg)  ||
+ 	    !MLX5_CAP_MCAM_REG(dev, mcqi) ||
+ 	    !MLX5_CAP_MCAM_REG(dev, mcc)  ||
+ 	    !MLX5_CAP_MCAM_REG(dev, mcda)) {
+ 		pr_info("%s flashing isn't supported by the running FW\n", __func__);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return mlxfw_firmware_flash(&mlx5_mlxfw_dev.mlxfw_dev, firmware);
+ }
++>>>>>>> 62bd22cf326d (net/mlx5: Add mlxfw callbacks)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fw.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 572d723827e5..a897ba201af1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -37,6 +37,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/if_link.h>
+#include <linux/firmware.h>
 
 #define DRIVER_NAME "mlx5_core"
 #define DRIVER_VERSION "3.0-1"
@@ -151,6 +152,8 @@ int mlx5_set_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size);
 int mlx5_query_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 *arm, u8 *mode);
 int mlx5_set_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 arm, u8 mode);
 
+int mlx5_firmware_flash(struct mlx5_core_dev *dev, const struct firmware *fw);
+
 void mlx5e_init(void);
 void mlx5e_cleanup(void);
 
