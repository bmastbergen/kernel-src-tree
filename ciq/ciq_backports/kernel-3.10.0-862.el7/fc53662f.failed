x86/hyper-v: Make hv_do_hypercall() inline

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] hyper-v: Make hv_do_hypercall() inline (Vitaly Kuznetsov) [1465471]
Rebuild_FUZZ: 95.00%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit fc53662f13b889a5a1c069e79ee1e3d4534df132
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/fc53662f.failed

We have only three call sites for hv_do_hypercall() and we're going to
change HVCALL_SIGNAL_EVENT to doing fast hypercall so we can inline this
function for optimization.

Hyper-V top level functional specification states that r9-r11 registers
and flags may be clobbered by the hypervisor during hypercall and with
inlining this is somewhat important, add the clobbers.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Jork Loeser <Jork.Loeser@microsoft.com>
	Cc: K. Y. Srinivasan <kys@microsoft.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Simon Xiao <sixiao@microsoft.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: devel@linuxdriverproject.org
Link: http://lkml.kernel.org/r/20170802160921.21791-3-vkuznets@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit fc53662f13b889a5a1c069e79ee1e3d4534df132)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/hyperv/hv_init.c
index 18e3d3f26a37,691603ee9179..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -24,8 -24,62 +24,16 @@@
  #include <linux/version.h>
  #include <linux/vmalloc.h>
  #include <linux/mm.h>
 -#include <linux/clockchips.h>
 -#include <linux/hyperv.h>
 -
 -#ifdef CONFIG_HYPERV_TSCPAGE
 -
 -static struct ms_hyperv_tsc_page *tsc_pg;
 -
 -struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
 -{
 -	return tsc_pg;
 -}
 -
 -static u64 read_hv_clock_tsc(struct clocksource *arg)
 -{
 -	u64 current_tick = hv_read_tsc_page(tsc_pg);
 -
 -	if (current_tick == U64_MAX)
 -		rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 -
 -	return current_tick;
 -}
 -
 -static struct clocksource hyperv_cs_tsc = {
 -		.name		= "hyperv_clocksource_tsc_page",
 -		.rating		= 400,
 -		.read		= read_hv_clock_tsc,
 -		.mask		= CLOCKSOURCE_MASK(64),
 -		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 -};
 -#endif
 -
 -static u64 read_hv_clock_msr(struct clocksource *arg)
 -{
 -	u64 current_tick;
 -	/*
 -	 * Read the partition counter to get the current tick count. This count
 -	 * is set to 0 when the partition is created and is incremented in
 -	 * 100 nanosecond units.
 -	 */
 -	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 -	return current_tick;
 -}
 -
 -static struct clocksource hyperv_cs_msr = {
 -	.name		= "hyperv_clocksource_msr",
 -	.rating		= 400,
 -	.read		= read_hv_clock_msr,
 -	.mask		= CLOCKSOURCE_MASK(64),
 -	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 -};
  
++<<<<<<< HEAD
 +static void *hypercall_pg;
++=======
+ void *hv_hypercall_pg;
+ EXPORT_SYMBOL_GPL(hv_hypercall_pg);
+ struct clocksource *hyperv_cs;
+ EXPORT_SYMBOL_GPL(hyperv_cs);
+ 
++>>>>>>> fc53662f13b8 (x86/hyper-v: Make hv_do_hypercall() inline)
  /*
   * This function is to be invoked early in the boot sequence after the
   * hypervisor has been detected.
@@@ -56,51 -111,103 +64,113 @@@ void hyperv_init(void
  
  	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
  	hypercall_msr.enable = 1;
- 	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);
+ 	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hv_hypercall_pg);
  	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 -
 -	/*
 -	 * Register Hyper-V specific clocksource.
 -	 */
 -#ifdef CONFIG_HYPERV_TSCPAGE
 -	if (ms_hyperv.features & HV_X64_MSR_REFERENCE_TSC_AVAILABLE) {
 -		union hv_x64_msr_hypercall_contents tsc_msr;
 -
 -		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
 -		if (!tsc_pg)
 -			goto register_msr_cs;
 -
 -		hyperv_cs = &hyperv_cs_tsc;
 -
 -		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 -
 -		tsc_msr.enable = 1;
 -		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
 -
 -		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 -
 -		hyperv_cs_tsc.archdata.vclock_mode = VCLOCK_HVCLOCK;
 -
 -		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
 -		return;
 -	}
 -register_msr_cs:
 -#endif
 -	/*
 -	 * For 32 bit guests just use the MSR based mechanism for reading
 -	 * the partition counter.
 -	 */
 -
 -	hyperv_cs = &hyperv_cs_msr;
 -	if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
 -		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
  }
  
  /*
++<<<<<<< HEAD
 + * hv_do_hypercall- Invoke the specified hypercall
 + */
 +u64 hv_do_hypercall(u64 control, void *input, void *output)
 +{
 +	u64 input_address = (input) ? virt_to_phys(input) : 0;
 +	u64 output_address = (output) ? virt_to_phys(output) : 0;
 +#ifdef CONFIG_X86_64
 +	u64 hv_status = 0;
 +
 +	if (!hypercall_pg)
 +		return (u64)ULLONG_MAX;
 +
 +	__asm__ __volatile__("mov %0, %%r8" : : "r" (output_address) : "r8");
 +	__asm__ __volatile__("call *%3" : "=a" (hv_status) :
 +			     "c" (control), "d" (input_address),
 +			     "m" (hypercall_pg));
 +
 +	return hv_status;
 +
 +#else
 +
 +	u32 control_hi = control >> 32;
 +	u32 control_lo = control & 0xFFFFFFFF;
 +	u32 hv_status_hi = 1;
 +	u32 hv_status_lo = 1;
 +	u32 input_address_hi = input_address >> 32;
 +	u32 input_address_lo = input_address & 0xFFFFFFFF;
 +	u32 output_address_hi = output_address >> 32;
 +	u32 output_address_lo = output_address & 0xFFFFFFFF;
 +
 +	if (!hypercall_pg)
 +		return (u64)ULLONG_MAX;
 +
 +	__asm__ __volatile__ ("call *%8" : "=d"(hv_status_hi),
 +			      "=a"(hv_status_lo) : "d" (control_hi),
 +			      "a" (control_lo), "b" (input_address_hi),
 +			      "c" (input_address_lo), "D"(output_address_hi),
 +			      "S"(output_address_lo), "m" (hypercall_pg));
 +
 +	return hv_status_lo | ((u64)hv_status_hi << 32);
 +#endif /* !x86_64 */
 +}
 +EXPORT_SYMBOL_GPL(hv_do_hypercall);
++=======
+  * This routine is called before kexec/kdump, it does the required cleanup.
+  */
+ void hyperv_cleanup(void)
+ {
+ 	union hv_x64_msr_hypercall_contents hypercall_msr;
+ 
+ 	/* Reset our OS id */
+ 	wrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);
+ 
+ 	/* Reset the hypercall page */
+ 	hypercall_msr.as_uint64 = 0;
+ 	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
+ 
+ 	/* Reset the TSC page */
+ 	hypercall_msr.as_uint64 = 0;
+ 	wrmsrl(HV_X64_MSR_REFERENCE_TSC, hypercall_msr.as_uint64);
+ }
+ EXPORT_SYMBOL_GPL(hyperv_cleanup);
+ 
+ void hyperv_report_panic(struct pt_regs *regs)
+ {
+ 	static bool panic_reported;
+ 
+ 	/*
+ 	 * We prefer to report panic on 'die' chain as we have proper
+ 	 * registers to report, but if we miss it (e.g. on BUG()) we need
+ 	 * to report it on 'panic'.
+ 	 */
+ 	if (panic_reported)
+ 		return;
+ 	panic_reported = true;
+ 
+ 	wrmsrl(HV_X64_MSR_CRASH_P0, regs->ip);
+ 	wrmsrl(HV_X64_MSR_CRASH_P1, regs->ax);
+ 	wrmsrl(HV_X64_MSR_CRASH_P2, regs->bx);
+ 	wrmsrl(HV_X64_MSR_CRASH_P3, regs->cx);
+ 	wrmsrl(HV_X64_MSR_CRASH_P4, regs->dx);
+ 
+ 	/*
+ 	 * Let Hyper-V know there is crash data available
+ 	 */
+ 	wrmsrl(HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_CRASH_NOTIFY);
+ }
+ EXPORT_SYMBOL_GPL(hyperv_report_panic);
+ 
+ bool hv_is_hypercall_page_setup(void)
+ {
+ 	union hv_x64_msr_hypercall_contents hypercall_msr;
+ 
+ 	/* Check if the hypercall page is setup */
+ 	hypercall_msr.as_uint64 = 0;
+ 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
+ 
+ 	if (!hypercall_msr.enable)
+ 		return false;
+ 
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(hv_is_hypercall_page_setup);
++>>>>>>> fc53662f13b8 (x86/hyper-v: Make hv_do_hypercall() inline)
diff --cc arch/x86/include/asm/mshyperv.h
index c86331fdc4b0,6fa5e342cc86..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -3,8 -3,28 +3,9 @@@
  
  #include <linux/types.h>
  #include <linux/atomic.h>
+ #include <asm/io.h>
  #include <asm/hyperv.h>
  
 -/*
 - * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
 - * is set by CPUID(HVCPUID_VERSION_FEATURES).
 - */
 -enum hv_cpuid_function {
 -	HVCPUID_VERSION_FEATURES		= 0x00000001,
 -	HVCPUID_VENDOR_MAXFUNCTION		= 0x40000000,
 -	HVCPUID_INTERFACE			= 0x40000001,
 -
 -	/*
 -	 * The remaining functions depend on the value of
 -	 * HVCPUID_INTERFACE
 -	 */
 -	HVCPUID_VERSION				= 0x40000002,
 -	HVCPUID_FEATURES			= 0x40000003,
 -	HVCPUID_ENLIGHTENMENT_INFO		= 0x40000004,
 -	HVCPUID_IMPLEMENTATION_LIMITS		= 0x40000005,
 -};
 -
  struct ms_hyperv_info {
  	u32 features;
  	u32 misc_features;
@@@ -83,6 -168,109 +84,50 @@@ void hv_setup_crash_handler(void (*hand
  void hv_remove_crash_handler(void);
  
  #if IS_ENABLED(CONFIG_HYPERV)
++<<<<<<< HEAD
++=======
+ extern struct clocksource *hyperv_cs;
+ extern void *hv_hypercall_pg;
+ 
+ static inline u64 hv_do_hypercall(u64 control, void *input, void *output)
+ {
+ 	u64 input_address = input ? virt_to_phys(input) : 0;
+ 	u64 output_address = output ? virt_to_phys(output) : 0;
+ 	u64 hv_status;
+ 	register void *__sp asm(_ASM_SP);
+ 
+ #ifdef CONFIG_X86_64
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("mov %4, %%r8\n"
+ 			     "call *%5"
+ 			     : "=a" (hv_status), "+r" (__sp),
+ 			       "+c" (control), "+d" (input_address)
+ 			     :  "r" (output_address), "m" (hv_hypercall_pg)
+ 			     : "cc", "memory", "r8", "r9", "r10", "r11");
+ #else
+ 	u32 input_address_hi = upper_32_bits(input_address);
+ 	u32 input_address_lo = lower_32_bits(input_address);
+ 	u32 output_address_hi = upper_32_bits(output_address);
+ 	u32 output_address_lo = lower_32_bits(output_address);
+ 
+ 	if (!hv_hypercall_pg)
+ 		return U64_MAX;
+ 
+ 	__asm__ __volatile__("call *%7"
+ 			     : "=A" (hv_status),
+ 			       "+c" (input_address_lo), "+r" (__sp)
+ 			     : "A" (control),
+ 			       "b" (input_address_hi),
+ 			       "D"(output_address_hi), "S"(output_address_lo),
+ 			       "m" (hv_hypercall_pg)
+ 			     : "cc", "memory");
+ #endif /* !x86_64 */
+ 	return hv_status;
+ }
+ 
++>>>>>>> fc53662f13b8 (x86/hyper-v: Make hv_do_hypercall() inline)
  void hyperv_init(void);
 -void hyperv_report_panic(struct pt_regs *regs);
 -bool hv_is_hypercall_page_setup(void);
 -void hyperv_cleanup(void);
 -#else /* CONFIG_HYPERV */
 -static inline void hyperv_init(void) {}
 -static inline bool hv_is_hypercall_page_setup(void) { return false; }
 -static inline void hyperv_cleanup(void) {}
 -#endif /* CONFIG_HYPERV */
 -
 -#ifdef CONFIG_HYPERV_TSCPAGE
 -struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
 -static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
 -{
 -	u64 scale, offset, cur_tsc;
 -	u32 sequence;
 -
 -	/*
 -	 * The protocol for reading Hyper-V TSC page is specified in Hypervisor
 -	 * Top-Level Functional Specification ver. 3.0 and above. To get the
 -	 * reference time we must do the following:
 -	 * - READ ReferenceTscSequence
 -	 *   A special '0' value indicates the time source is unreliable and we
 -	 *   need to use something else. The currently published specification
 -	 *   versions (up to 4.0b) contain a mistake and wrongly claim '-1'
 -	 *   instead of '0' as the special value, see commit c35b82ef0294.
 -	 * - ReferenceTime =
 -	 *        ((RDTSC() * ReferenceTscScale) >> 64) + ReferenceTscOffset
 -	 * - READ ReferenceTscSequence again. In case its value has changed
 -	 *   since our first reading we need to discard ReferenceTime and repeat
 -	 *   the whole sequence as the hypervisor was updating the page in
 -	 *   between.
 -	 */
 -	do {
 -		sequence = READ_ONCE(tsc_pg->tsc_sequence);
 -		if (!sequence)
 -			return U64_MAX;
 -		/*
 -		 * Make sure we read sequence before we read other values from
 -		 * TSC page.
 -		 */
 -		smp_rmb();
 -
 -		scale = READ_ONCE(tsc_pg->tsc_scale);
 -		offset = READ_ONCE(tsc_pg->tsc_offset);
 -		cur_tsc = rdtsc_ordered();
 -
 -		/*
 -		 * Make sure we read sequence after we read all other values
 -		 * from TSC page.
 -		 */
 -		smp_rmb();
 -
 -	} while (READ_ONCE(tsc_pg->tsc_sequence) != sequence);
 -
 -	return mul_u64_u64_shr(cur_tsc, scale, 64) + offset;
 -}
 -
 -#else
 -static inline struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
 -{
 -	return NULL;
 -}
  #endif
  #endif
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index d8b9708a37d3..ff4bdbbfee72 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -32,6 +32,8 @@
 #include <linux/hyperv.h>
 #include <linux/export.h>
 #include <asm/hyperv.h>
+#include <asm/mshyperv.h>
+
 #include "hyperv_vmbus.h"
 
 
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7dc67ea90ca6..d09a6eccc57b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1167,7 +1167,6 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			bool fb_overlap_ok);
 void vmbus_free_mmio(resource_size_t start, resource_size_t size);
 int vmbus_cpu_number_to_vp_number(int cpu_number);
-u64 hv_do_hypercall(u64 control, void *input, void *output);
 
 /**
  * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device
