iommu/amd: Add per-domain flush-queue data structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [iommu] amd: Add per-domain flush-queue data structures (Suravee Suthikulpanit) [1508644]
Rebuild_FUZZ: 94.00%
commit-author Joerg Roedel <jroedel@suse.de>
commit d4241a276119bf404e6c0e23f06f84b84c4ecfc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d4241a27.failed

Make the flush-queue per dma-ops domain and add code
allocate and free the flush-queues;

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit d4241a276119bf404e6c0e23f06f84b84c4ecfc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu.c
diff --cc drivers/iommu/amd_iommu.c
index e80343c1de99,2418fcc28fbe..000000000000
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@@ -117,28 -136,18 +117,40 @@@ static void update_domain(struct protec
  static int protection_domain_init(struct protection_domain *domain);
  static void detach_device(struct device *dev);
  
+ #define FLUSH_QUEUE_SIZE 256
+ 
+ struct flush_queue_entry {
+ 	unsigned long iova_pfn;
+ 	unsigned long pages;
+ };
+ 
+ struct flush_queue {
+ 	struct flush_queue_entry *entries;
+ 	unsigned head, tail;
+ };
+ 
 +/*
 + * For dynamic growth the aperture size is split into ranges of 128MB of
 + * DMA address space each. This struct represents one such range.
 + */
 +struct aperture_range {
 +
 +	spinlock_t bitmap_lock;
 +
 +	/* address allocation bitmap */
 +	unsigned long *bitmap;
 +	unsigned long offset;
 +	unsigned long next_bit;
 +
 +	/*
 +	 * Array of PTE pages for the aperture. In this array we save all the
 +	 * leaf pages of the domain page table used for the aperture. This way
 +	 * we don't need to walk the page table to find a specific PTE. We can
 +	 * just calculate its address in constant time.
 +	 */
 +	u64 *pte_pages[64];
 +};
 +
  /*
   * Data container for a dma_ops specific protection domain
   */
@@@ -146,15 -155,14 +158,23 @@@ struct dma_ops_domain 
  	/* generic protection domain information */
  	struct protection_domain domain;
  
++<<<<<<< HEAD
 +	/* size of the aperture for the mappings */
 +	unsigned long aperture_size;
++=======
+ 	/* IOVA RB-Tree */
+ 	struct iova_domain iovad;
+ 
+ 	struct flush_queue __percpu *flush_queue;
+ };
++>>>>>>> d4241a276119 (iommu/amd: Add per-domain flush-queue data structures)
 +
 +	/* aperture index we start searching for free addresses */
 +	unsigned long next_index;
  
 -static struct iova_domain reserved_iova_ranges;
 -static struct lock_class_key reserved_rbtree_key;
 +	/* address space relevant data */
 +	struct aperture_range *aperture[APERTURE_MAX_RANGES];
 +};
  
  /****************************************************************************
   *
@@@ -1985,14 -1817,14 +2055,21 @@@ static void dma_ops_domain_free(struct 
  
  	del_domain_from_list(&dom->domain);
  
++<<<<<<< HEAD
++=======
+ 	dma_ops_domain_free_flush_queue(dom);
+ 
+ 	put_iova_domain(&dom->iovad);
+ 
++>>>>>>> d4241a276119 (iommu/amd: Add per-domain flush-queue data structures)
  	free_pagetable(&dom->domain);
  
 -	if (dom->domain.id)
 -		domain_id_free(dom->domain.id);
 +	for (i = 0; i < APERTURE_MAX_RANGES; ++i) {
 +		if (!dom->aperture[i])
 +			continue;
 +		free_page((unsigned long)dom->aperture[i]->bitmap);
 +		kfree(dom->aperture[i]);
 +	}
  
  	kfree(dom);
  }
@@@ -2037,19 -1851,17 +2114,31 @@@ static struct dma_ops_domain *dma_ops_d
  	if (!dma_dom->domain.pt_root)
  		goto free_dma_dom;
  
++<<<<<<< HEAD
++=======
+ 	init_iova_domain(&dma_dom->iovad, PAGE_SIZE,
+ 			 IOVA_START_PFN, DMA_32BIT_PFN);
+ 
+ 	/* Initialize reserved ranges */
+ 	copy_reserved_iova(&reserved_iova_ranges, &dma_dom->iovad);
+ 
+ 	if (dma_ops_domain_alloc_flush_queue(dma_dom))
+ 		goto free_dma_dom;
+ 
++>>>>>>> d4241a276119 (iommu/amd: Add per-domain flush-queue data structures)
  	add_domain_to_list(&dma_dom->domain);
  
 +	if (alloc_new_range(dma_dom, true, GFP_KERNEL))
 +		goto free_dma_dom;
 +
 +	/*
 +	 * mark the first page as allocated so we never return 0 as
 +	 * a valid dma-address. So we can use 0 as error value
 +	 */
 +	dma_dom->aperture[0]->bitmap[0] = 1;
 +	dma_dom->next_index = 0;
 +
 +
  	return dma_dom;
  
  free_dma_dom:
* Unmerged path drivers/iommu/amd_iommu.c
