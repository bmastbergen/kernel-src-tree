qed: IOV db support multiple queues per qzone

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 007bc37179c14a6d1ff1545695e2492b3a376bc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/007bc371.failed

Allow the infrastructure a PF maintains for each one of its VFs
to support multiple queue-cids on a single queue-zone.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 007bc37179c14a6d1ff1545695e2492b3a376bc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_l2.c
#	drivers/net/ethernet/qlogic/qed/qed_l2.h
#	drivers/net/ethernet/qlogic/qed/qed_sriov.c
#	drivers/net/ethernet/qlogic/qed/qed_sriov.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_l2.c
index f852981b5922,75643c322642..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@@ -81,10 -217,10 +81,16 @@@ struct qed_queue_cid 
  _qed_eth_queue_to_cid(struct qed_hwfn *p_hwfn,
  		      u16 opaque_fid,
  		      u32 cid,
++<<<<<<< HEAD
 +		      u8 vf_qid,
 +		      struct qed_queue_start_common_params *p_params)
++=======
+ 		      struct qed_queue_start_common_params *p_params,
+ 		      bool b_is_rx,
+ 		      struct qed_queue_cid_vf_params *p_vf_params)
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  {
 +	bool b_is_same = (p_hwfn->hw_info.opaque_fid == opaque_fid);
  	struct qed_queue_cid *p_cid;
  	int rc;
  
@@@ -95,10 -231,25 +101,30 @@@
  
  	p_cid->opaque_fid = opaque_fid;
  	p_cid->cid = cid;
 +	p_cid->vf_qid = vf_qid;
 +	p_cid->rel = *p_params;
  	p_cid->p_owner = p_hwfn;
  
++<<<<<<< HEAD
++=======
+ 	/* Fill in parameters */
+ 	p_cid->rel.vport_id = p_params->vport_id;
+ 	p_cid->rel.queue_id = p_params->queue_id;
+ 	p_cid->rel.stats_id = p_params->stats_id;
+ 	p_cid->sb_igu_id = p_params->p_sb->igu_sb_id;
+ 	p_cid->b_is_rx = b_is_rx;
+ 	p_cid->sb_idx = p_params->sb_idx;
+ 
+ 	/* Fill-in bits related to VFs' queues if information was provided */
+ 	if (p_vf_params) {
+ 		p_cid->vfid = p_vf_params->vfid;
+ 		p_cid->vf_qid = p_vf_params->vf_qid;
+ 		p_cid->vf_legacy = p_vf_params->vf_legacy;
+ 	} else {
+ 		p_cid->vfid = QED_QUEUE_CID_SELF;
+ 	}
+ 
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  	/* Don't try calculating the absolute indices for VFs */
  	if (IS_VF(p_hwfn->cdev)) {
  		p_cid->abs = p_cid->rel;
@@@ -158,14 -311,20 +184,23 @@@ fail
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static struct qed_queue_cid *qed_eth_queue_to_cid(struct qed_hwfn *p_hwfn,
 +						  u16 opaque_fid, struct
 +						  qed_queue_start_common_params
 +						  *p_params)
++=======
+ struct qed_queue_cid *
+ qed_eth_queue_to_cid(struct qed_hwfn *p_hwfn,
+ 		     u16 opaque_fid,
+ 		     struct qed_queue_start_common_params *p_params,
+ 		     bool b_is_rx,
+ 		     struct qed_queue_cid_vf_params *p_vf_params)
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  {
  	struct qed_queue_cid *p_cid;
 -	bool b_legacy_vf = false;
  	u32 cid = 0;
  
 -	/* Currently, PF doesn't need to allocate CIDs for any VF */
 -	if (p_vf_params)
 -		b_legacy_vf = true;
  	/* Get a unique firmware CID for this queue, in case it's a PF.
  	 * VF's don't need a CID as the queue configuration will be done
  	 * by PF.
@@@ -177,13 -336,24 +212,32 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	p_cid = _qed_eth_queue_to_cid(p_hwfn, opaque_fid, cid, 0, p_params);
 +	if (!p_cid && IS_PF(p_hwfn->cdev))
++=======
+ 	p_cid = _qed_eth_queue_to_cid(p_hwfn, opaque_fid, cid,
+ 				      p_params, b_is_rx, p_vf_params);
+ 	if (!p_cid && IS_PF(p_hwfn->cdev) && !b_legacy_vf)
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  		qed_cxt_release_cid(p_hwfn, cid);
  
  	return p_cid;
  }
  
++<<<<<<< HEAD
++=======
+ static struct qed_queue_cid *
+ qed_eth_queue_to_cid_pf(struct qed_hwfn *p_hwfn,
+ 			u16 opaque_fid,
+ 			bool b_is_rx,
+ 			struct qed_queue_start_common_params *p_params)
+ {
+ 	return qed_eth_queue_to_cid(p_hwfn, opaque_fid, p_params, b_is_rx,
+ 				    NULL);
+ }
+ 
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  int qed_sp_eth_vport_start(struct qed_hwfn *p_hwfn,
  			   struct qed_sp_vport_start_params *p_params)
  {
@@@ -760,7 -933,7 +814,11 @@@ qed_eth_rx_queue_start(struct qed_hwfn 
  	int rc;
  
  	/* Allocate a CID for the queue */
++<<<<<<< HEAD
 +	p_cid = qed_eth_queue_to_cid(p_hwfn, opaque_fid, p_params);
++=======
+ 	p_cid = qed_eth_queue_to_cid_pf(p_hwfn, opaque_fid, true, p_params);
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  	if (!p_cid)
  		return -ENOMEM;
  
@@@ -964,7 -1138,7 +1022,11 @@@ qed_eth_tx_queue_start(struct qed_hwfn 
  	struct qed_queue_cid *p_cid;
  	int rc;
  
++<<<<<<< HEAD
 +	p_cid = qed_eth_queue_to_cid(p_hwfn, opaque_fid, p_params);
++=======
+ 	p_cid = qed_eth_queue_to_cid_pf(p_hwfn, opaque_fid, false, p_params);
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  	if (!p_cid)
  		return -EINVAL;
  
diff --cc drivers/net/ethernet/qlogic/qed/qed_l2.h
index 93cb932ef663,f8f09aadced7..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.h
@@@ -296,12 -348,16 +298,21 @@@ struct qed_queue_cid 
  void qed_eth_queue_cid_release(struct qed_hwfn *p_hwfn,
  			       struct qed_queue_cid *p_cid);
  
++<<<<<<< HEAD
 +struct qed_queue_cid *_qed_eth_queue_to_cid(struct qed_hwfn *p_hwfn,
 +					    u16 opaque_fid,
 +					    u32 cid,
 +					    u8 vf_qid,
 +					    struct qed_queue_start_common_params
 +					    *p_params);
++=======
+ struct qed_queue_cid *
+ qed_eth_queue_to_cid(struct qed_hwfn *p_hwfn,
+ 		     u16 opaque_fid,
+ 		     struct qed_queue_start_common_params *p_params,
+ 		     bool b_is_rx,
+ 		     struct qed_queue_cid_vf_params *p_vf_params);
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  
  int
  qed_sp_eth_vport_start(struct qed_hwfn *p_hwfn,
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.c
index c231e788de76,e6fb5684b8fd..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@@ -1983,11 -1988,14 +2004,19 @@@ static void qed_iov_vf_mbx_start_rxq(st
  				     struct qed_vf_info *vf)
  {
  	struct qed_queue_start_common_params params;
 -	struct qed_queue_cid_vf_params vf_params;
  	struct qed_iov_vf_mbx *mbx = &vf->vf_mbx;
  	u8 status = PFVF_STATUS_NO_RESOURCE;
++<<<<<<< HEAD
 +	struct qed_vf_q_info *p_queue;
 +	struct vfpf_start_rxq_tlv *req;
 +	bool b_legacy_vf = false;
++=======
+ 	u8 qid_usage_idx, vf_legacy = 0;
+ 	struct vfpf_start_rxq_tlv *req;
+ 	struct qed_vf_queue *p_queue;
+ 	struct qed_queue_cid *p_cid;
+ 	struct qed_sb_info sb_dummy;
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  	int rc;
  
  	req = &mbx->req_virt->start_rxq;
@@@ -2004,14 -2015,20 +2033,25 @@@
  	params.queue_id = p_queue->fw_rx_qid;
  	params.vport_id = vf->vport_id;
  	params.stats_id = vf->abs_vf_id + 0x10;
 -	/* Since IGU index is passed via sb_info, construct a dummy one */
 -	memset(&sb_dummy, 0, sizeof(sb_dummy));
 -	sb_dummy.igu_sb_id = req->hw_sb;
 -	params.p_sb = &sb_dummy;
 +	params.sb = req->hw_sb;
  	params.sb_idx = req->sb_index;
  
++<<<<<<< HEAD
 +	p_queue->p_rx_cid = _qed_eth_queue_to_cid(p_hwfn,
 +						  vf->opaque_fid,
 +						  p_queue->fw_cid,
 +						  req->rx_qid, &params);
 +	if (!p_queue->p_rx_cid)
++=======
+ 	memset(&vf_params, 0, sizeof(vf_params));
+ 	vf_params.vfid = vf->relative_vf_id;
+ 	vf_params.vf_qid = (u8)req->rx_qid;
+ 	vf_params.vf_legacy = vf_legacy;
+ 	vf_params.qid_usage_idx = qid_usage_idx;
+ 	p_cid = qed_eth_queue_to_cid(p_hwfn, vf->opaque_fid,
+ 				     &params, true, &vf_params);
+ 	if (!p_cid)
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  		goto out;
  
  	/* Legacy VFs have their Producers in a different location, which they
@@@ -2025,11 -2039,8 +2065,10 @@@
  		       GTT_BAR0_MAP_REG_MSDM_RAM +
  		       MSTORM_ETH_VF_PRODS_OFFSET(vf->abs_vf_id, req->rx_qid),
  		       0);
 +	}
 +	p_queue->p_rx_cid->b_legacy_vf = b_legacy_vf;
  
- 	rc = qed_eth_rxq_start_ramrod(p_hwfn,
- 				      p_queue->p_rx_cid,
+ 	rc = qed_eth_rxq_start_ramrod(p_hwfn, p_cid,
  				      req->bd_max_bytes,
  				      req->rxq_addr,
  				      req->cqe_pbl_addr, req->cqe_pbl_size);
@@@ -2094,7 -2319,12 +2131,15 @@@ static void qed_iov_vf_mbx_start_txq(st
  	struct qed_iov_vf_mbx *mbx = &vf->vf_mbx;
  	u8 status = PFVF_STATUS_NO_RESOURCE;
  	struct vfpf_start_txq_tlv *req;
++<<<<<<< HEAD
 +	struct qed_vf_q_info *p_queue;
++=======
+ 	struct qed_vf_queue *p_queue;
+ 	struct qed_queue_cid *p_cid;
+ 	struct qed_sb_info sb_dummy;
+ 	u8 qid_usage_idx, vf_legacy;
+ 	u32 cid = 0;
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  	int rc;
  	u16 pq;
  
@@@ -2112,14 -2342,25 +2157,26 @@@
  	params.queue_id = p_queue->fw_tx_qid;
  	params.vport_id = vf->vport_id;
  	params.stats_id = vf->abs_vf_id + 0x10;
 -
 -	/* Since IGU index is passed via sb_info, construct a dummy one */
 -	memset(&sb_dummy, 0, sizeof(sb_dummy));
 -	sb_dummy.igu_sb_id = req->hw_sb;
 -	params.p_sb = &sb_dummy;
 +	params.sb = req->hw_sb;
  	params.sb_idx = req->sb_index;
  
++<<<<<<< HEAD
 +	p_queue->p_tx_cid = _qed_eth_queue_to_cid(p_hwfn,
 +						  vf->opaque_fid,
 +						  p_queue->fw_cid,
 +						  req->tx_qid, &params);
 +	if (!p_queue->p_tx_cid)
++=======
+ 	memset(&vf_params, 0, sizeof(vf_params));
+ 	vf_params.vfid = vf->relative_vf_id;
+ 	vf_params.vf_qid = (u8)req->tx_qid;
+ 	vf_params.vf_legacy = vf_legacy;
+ 	vf_params.qid_usage_idx = qid_usage_idx;
+ 
+ 	p_cid = qed_eth_queue_to_cid(p_hwfn, vf->opaque_fid,
+ 				     &params, false, &vf_params);
+ 	if (!p_cid)
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  		goto out;
  
  	pq = qed_get_cm_pq_idx_vf(p_hwfn, vf->relative_vf_id);
diff --cc drivers/net/ethernet/qlogic/qed/qed_sriov.h
index bcff13a4692b,480cd99c69b5..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.h
@@@ -141,12 -149,20 +141,24 @@@ struct qed_iov_vf_mbx 
  	struct vfpf_first_tlv first_tlv;
  };
  
++<<<<<<< HEAD
 +struct qed_vf_q_info {
++=======
+ #define QED_IOV_LEGACY_QID_RX (0)
+ #define QED_IOV_LEGACY_QID_TX (1)
+ 
+ struct qed_vf_queue_cid {
+ 	bool b_is_tx;
+ 	struct qed_queue_cid *p_cid;
+ };
+ 
+ /* Describes a qzone associated with the VF */
+ struct qed_vf_queue {
++>>>>>>> 007bc37179c1 (qed: IOV db support multiple queues per qzone)
  	u16 fw_rx_qid;
- 	struct qed_queue_cid *p_rx_cid;
  	u16 fw_tx_qid;
- 	struct qed_queue_cid *p_tx_cid;
- 	u8 fw_cid;
+ 
+ 	struct qed_vf_queue_cid cids[MAX_QUEUES_PER_QZONE];
  };
  
  enum vf_state {
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_l2.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_l2.h
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_sriov.h
