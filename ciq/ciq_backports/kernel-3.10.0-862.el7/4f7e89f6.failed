ceph: block non-fatal signals for fault/page_mkwrite

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 4f7e89f6ace0f6cd2f20110efd2d405e26bcbf31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4f7e89f6.failed

Fault and page_mkwrite are supposed to be uninterruptable. But they
call ceph functions that are interruptible. So they should block
signals before calling functions that are interruptible

	Signed-off-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 4f7e89f6ace0f6cd2f20110efd2d405e26bcbf31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index 49a4dc035844,3e204b9ff9f7..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -1298,28 -1336,27 +1309,27 @@@ static int ceph_filemap_fault(struct vm
  	struct ceph_inode_info *ci = ceph_inode(inode);
  	struct ceph_file_info *fi = vma->vm_file->private_data;
  	struct page *pinned_page = NULL;
 -	loff_t off = vmf->pgoff << PAGE_SHIFT;
 +	loff_t off = vmf->pgoff << PAGE_CACHE_SHIFT;
  	int want, got, ret;
+ 	sigset_t oldset;
+ 
+ 	ceph_block_sigs(&oldset);
  
  	dout("filemap_fault %p %llx.%llx %llu~%zd trying to get caps\n",
 -	     inode, ceph_vinop(inode), off, (size_t)PAGE_SIZE);
 +	     inode, ceph_vinop(inode), off, (size_t)PAGE_CACHE_SIZE);
  	if (fi->fmode & CEPH_FILE_MODE_LAZY)
  		want = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;
  	else
  		want = CEPH_CAP_FILE_CACHE;
- 	while (1) {
- 		got = 0;
- 		ret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,
- 				    -1, &got, &pinned_page);
- 		if (ret == 0)
- 			break;
- 		if (ret != -ERESTARTSYS) {
- 			WARN_ON(1);
- 			return VM_FAULT_SIGBUS;
- 		}
+ 
+ 	got = 0;
+ 	ret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want, -1, &got, &pinned_page);
+ 	if (ret < 0) {
+ 		ret = VM_FAULT_SIGBUS;
+ 		goto out_restore;
  	}
  	dout("filemap_fault %p %llu~%zd got cap refs on %s\n",
 -	     inode, off, (size_t)PAGE_SIZE, ceph_cap_string(got));
 +	     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));
  
  	if ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||
  	    ci->i_inline_version == CEPH_INLINE_NONE)
@@@ -1334,41 -1371,43 +1344,49 @@@
  	ceph_put_cap_refs(ci, got);
  
  	if (ret != -EAGAIN)
- 		return ret;
+ 		goto out_restore;
  
  	/* read inline data */
 -	if (off >= PAGE_SIZE) {
 +	if (off >= PAGE_CACHE_SIZE) {
  		/* does not support inline data > PAGE_SIZE */
  		ret = VM_FAULT_SIGBUS;
  	} else {
  		int ret1;
  		struct address_space *mapping = inode->i_mapping;
  		struct page *page = find_or_create_page(mapping, 0,
 -						mapping_gfp_constraint(mapping,
 -						~__GFP_FS));
 +						mapping_gfp_mask(mapping) &
 +						~__GFP_FS);
  		if (!page) {
  			ret = VM_FAULT_OOM;
- 			goto out;
+ 			goto out_inline;
  		}
  		ret1 = __ceph_do_getattr(inode, page,
  					 CEPH_STAT_CAP_INLINE_DATA, true);
  		if (ret1 < 0 || off >= i_size_read(inode)) {
  			unlock_page(page);
 -			put_page(page);
 +			page_cache_release(page);
  			ret = VM_FAULT_SIGBUS;
- 			goto out;
+ 			goto out_inline;
  		}
 -		if (ret1 < PAGE_SIZE)
 -			zero_user_segment(page, ret1, PAGE_SIZE);
 +		if (ret1 < PAGE_CACHE_SIZE)
 +			zero_user_segment(page, ret1, PAGE_CACHE_SIZE);
  		else
  			flush_dcache_page(page);
  		SetPageUptodate(page);
  		vmf->page = page;
  		ret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;
+ out_inline:
+ 		dout("filemap_fault %p %llu~%zd read inline data ret %d\n",
+ 		     inode, off, (size_t)PAGE_SIZE, ret);
  	}
++<<<<<<< HEAD
 +out:
 +	dout("filemap_fault %p %llu~%zd read inline data ret %d\n",
 +	     inode, off, (size_t)PAGE_CACHE_SIZE, ret);
++=======
+ out_restore:
+ 	ceph_restore_sigs(&oldset);
++>>>>>>> 4f7e89f6ace0 (ceph: block non-fatal signals for fault/page_mkwrite)
  	return ret;
  }
  
* Unmerged path fs/ceph/addr.c
