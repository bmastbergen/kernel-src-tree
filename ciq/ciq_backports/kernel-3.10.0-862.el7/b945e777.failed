scsi: qla2xxx: Include Exchange offload/Extended Login into FW dump

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Include Exchange offload/Extended Login into FW dump (Himanshu Madhani) [1460030]
Rebuild_FUZZ: 95.31%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit b945e777f95aa00c000fd2376bec85618897dd04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/b945e777.failed

Add missing memory dump of Exchange Offload and Extended login into FW
dump.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b945e777f95aa00c000fd2376bec85618897dd04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 4e0d0a2f9461,f7c4f723c405..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3946,6 -4056,195 +3946,198 @@@ fail
  	return -ENOMEM;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ qla2x00_set_exlogins_buffer(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	uint16_t	size, max_cnt, temp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	/* Return if we don't need to alloacate any extended logins */
+ 	if (!ql2xexlogins)
+ 		return QLA_SUCCESS;
+ 
+ 	if (!IS_EXLOGIN_OFFLD_CAPABLE(ha))
+ 		return QLA_SUCCESS;
+ 
+ 	ql_log(ql_log_info, vha, 0xd021, "EXLOGIN count: %d.\n", ql2xexlogins);
+ 	max_cnt = 0;
+ 	rval = qla_get_exlogin_status(vha, &size, &max_cnt);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd029,
+ 		    "Failed to get exlogin status.\n");
+ 		return rval;
+ 	}
+ 
+ 	temp = (ql2xexlogins > max_cnt) ? max_cnt : ql2xexlogins;
+ 	temp *= size;
+ 
+ 	if (temp != ha->exlogin_size) {
+ 		qla2x00_free_exlogin_buffer(ha);
+ 		ha->exlogin_size = temp;
+ 
+ 		ql_log(ql_log_info, vha, 0xd024,
+ 		    "EXLOGIN: max_logins=%d, portdb=0x%x, total=%d.\n",
+ 		    max_cnt, size, temp);
+ 
+ 		ql_log(ql_log_info, vha, 0xd025,
+ 		    "EXLOGIN: requested size=0x%x\n", ha->exlogin_size);
+ 
+ 		/* Get consistent memory for extended logins */
+ 		ha->exlogin_buf = dma_alloc_coherent(&ha->pdev->dev,
+ 			ha->exlogin_size, &ha->exlogin_buf_dma, GFP_KERNEL);
+ 		if (!ha->exlogin_buf) {
+ 			ql_log_pci(ql_log_fatal, ha->pdev, 0xd02a,
+ 		    "Failed to allocate memory for exlogin_buf_dma.\n");
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	/* Now configure the dma buffer */
+ 	rval = qla_set_exlogin_mem_cfg(vha, ha->exlogin_buf_dma);
+ 	if (rval) {
+ 		ql_log(ql_log_fatal, vha, 0xd033,
+ 		    "Setup extended login buffer  ****FAILED****.\n");
+ 		qla2x00_free_exlogin_buffer(ha);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+ * qla2x00_free_exlogin_buffer
+ *
+ * Input:
+ *	ha = adapter block pointer
+ */
+ void
+ qla2x00_free_exlogin_buffer(struct qla_hw_data *ha)
+ {
+ 	if (ha->exlogin_buf) {
+ 		dma_free_coherent(&ha->pdev->dev, ha->exlogin_size,
+ 		    ha->exlogin_buf, ha->exlogin_buf_dma);
+ 		ha->exlogin_buf = NULL;
+ 		ha->exlogin_size = 0;
+ 	}
+ }
+ 
+ static void
+ qla2x00_number_of_exch(scsi_qla_host_t *vha, u32 *ret_cnt, u16 max_cnt)
+ {
+ 	u32 temp;
+ 	*ret_cnt = FW_DEF_EXCHANGES_CNT;
+ 
+ 	if (qla_ini_mode_enabled(vha)) {
+ 		if (ql2xiniexchg > max_cnt)
+ 			ql2xiniexchg = max_cnt;
+ 
+ 		if (ql2xiniexchg > FW_DEF_EXCHANGES_CNT)
+ 			*ret_cnt = ql2xiniexchg;
+ 	} else if (qla_tgt_mode_enabled(vha)) {
+ 		if (ql2xexchoffld > max_cnt)
+ 			ql2xexchoffld = max_cnt;
+ 
+ 		if (ql2xexchoffld > FW_DEF_EXCHANGES_CNT)
+ 			*ret_cnt = ql2xexchoffld;
+ 	} else if (qla_dual_mode_enabled(vha)) {
+ 		temp = ql2xiniexchg + ql2xexchoffld;
+ 		if (temp > max_cnt) {
+ 			ql2xiniexchg -= (temp - max_cnt)/2;
+ 			ql2xexchoffld -= (((temp - max_cnt)/2) + 1);
+ 			temp = max_cnt;
+ 		}
+ 
+ 		if (temp > FW_DEF_EXCHANGES_CNT)
+ 			*ret_cnt = temp;
+ 	}
+ }
+ 
+ int
+ qla2x00_set_exchoffld_buffer(scsi_qla_host_t *vha)
+ {
+ 	int rval;
+ 	u16 size, max_cnt;
+ 	u32 temp;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	if (!ha->flags.exchoffld_enabled)
+ 		return QLA_SUCCESS;
+ 
+ 	if (!IS_EXCHG_OFFLD_CAPABLE(ha))
+ 		return QLA_SUCCESS;
+ 
+ 	max_cnt = 0;
+ 	rval = qla_get_exchoffld_status(vha, &size, &max_cnt);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log_pci(ql_log_fatal, ha->pdev, 0xd012,
+ 		    "Failed to get exlogin status.\n");
+ 		return rval;
+ 	}
+ 
+ 	qla2x00_number_of_exch(vha, &temp, max_cnt);
+ 	temp *= size;
+ 
+ 	if (temp != ha->exchoffld_size) {
+ 		qla2x00_free_exchoffld_buffer(ha);
+ 		ha->exchoffld_size = temp;
+ 
+ 		ql_log(ql_log_info, vha, 0xd016,
+ 		    "Exchange offload: max_count=%d, buffers=0x%x, total=%d.\n",
+ 		    max_cnt, size, temp);
+ 
+ 		ql_log(ql_log_info, vha, 0xd017,
+ 		    "Exchange Buffers requested size = 0x%x\n",
+ 		    ha->exchoffld_size);
+ 
+ 		/* Get consistent memory for extended logins */
+ 		ha->exchoffld_buf = dma_alloc_coherent(&ha->pdev->dev,
+ 			ha->exchoffld_size, &ha->exchoffld_buf_dma, GFP_KERNEL);
+ 		if (!ha->exchoffld_buf) {
+ 			ql_log_pci(ql_log_fatal, ha->pdev, 0xd013,
+ 			"Failed to allocate memory for exchoffld_buf_dma.\n");
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	/* Now configure the dma buffer */
+ 	rval = qla_set_exchoffld_mem_cfg(vha);
+ 	if (rval) {
+ 		ql_log(ql_log_fatal, vha, 0xd02e,
+ 		    "Setup exchange offload buffer ****FAILED****.\n");
+ 		qla2x00_free_exchoffld_buffer(ha);
+ 	} else {
+ 		/* re-adjust number of target exchange */
+ 		struct init_cb_81xx *icb = (struct init_cb_81xx *)ha->init_cb;
+ 
+ 		if (qla_ini_mode_enabled(vha))
+ 			icb->exchange_count = 0;
+ 		else
+ 			icb->exchange_count = cpu_to_le16(ql2xexchoffld);
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ /*
+ * qla2x00_free_exchoffld_buffer
+ *
+ * Input:
+ *	ha = adapter block pointer
+ */
+ void
+ qla2x00_free_exchoffld_buffer(struct qla_hw_data *ha)
+ {
+ 	if (ha->exchoffld_buf) {
+ 		dma_free_coherent(&ha->pdev->dev, ha->exchoffld_size,
+ 		    ha->exchoffld_buf, ha->exchoffld_buf_dma);
+ 		ha->exchoffld_buf = NULL;
+ 		ha->exchoffld_size = 0;
+ 	}
+ }
+ 
++>>>>>>> b945e777f95a (scsi: qla2xxx: Include Exchange offload/Extended Login into FW dump)
  /*
  * qla2x00_free_fw_dump
  *	Frees fw dump stuff.
diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index bb8f9db626de..21241187c588 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -504,6 +504,50 @@ qla25xx_copy_fce(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
 	return (char *)iter_reg + ntohl(fcec->size);
 }
 
+static inline void *
+qla25xx_copy_exlogin(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+{
+	struct qla2xxx_offld_chain *c = ptr;
+
+	if (!ha->exlogin_buf)
+		return ptr;
+
+	*last_chain = &c->type;
+
+	c->type = cpu_to_be32(DUMP_CHAIN_EXLOGIN);
+	c->chain_size = cpu_to_be32(sizeof(struct qla2xxx_offld_chain) +
+	    ha->exlogin_size);
+	c->size = cpu_to_be32(ha->exlogin_size);
+	c->addr = cpu_to_be64(ha->exlogin_buf_dma);
+
+	ptr += sizeof(struct qla2xxx_offld_chain);
+	memcpy(ptr, ha->exlogin_buf, ha->exlogin_size);
+
+	return (char *)ptr + cpu_to_be32(c->size);
+}
+
+static inline void *
+qla81xx_copy_exchoffld(struct qla_hw_data *ha, void *ptr, uint32_t **last_chain)
+{
+	struct qla2xxx_offld_chain *c = ptr;
+
+	if (!ha->exchoffld_buf)
+		return ptr;
+
+	*last_chain = &c->type;
+
+	c->type = cpu_to_be32(DUMP_CHAIN_EXCHG);
+	c->chain_size = cpu_to_be32(sizeof(struct qla2xxx_offld_chain) +
+	    ha->exchoffld_size);
+	c->size = cpu_to_be32(ha->exchoffld_size);
+	c->addr = cpu_to_be64(ha->exchoffld_buf_dma);
+
+	ptr += sizeof(struct qla2xxx_offld_chain);
+	memcpy(ptr, ha->exchoffld_buf, ha->exchoffld_size);
+
+	return (char *)ptr + cpu_to_be32(c->size);
+}
+
 static inline void *
 qla2xxx_copy_atioqueues(struct qla_hw_data *ha, void *ptr,
 	uint32_t **last_chain)
@@ -1613,6 +1657,7 @@ qla25xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	nxt_chain = qla25xx_copy_fce(ha, nxt_chain, &last_chain);
 	nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, &last_chain);
 	nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, &last_chain);
+	nxt_chain = qla25xx_copy_exlogin(ha, nxt_chain, &last_chain);
 	if (last_chain) {
 		ha->fw_dump->version |= htonl(DUMP_CHAIN_VARIANT);
 		*last_chain |= htonl(DUMP_CHAIN_LAST);
@@ -1939,6 +1984,8 @@ qla81xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)
 	nxt_chain = qla25xx_copy_fce(ha, nxt_chain, &last_chain);
 	nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, &last_chain);
 	nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, &last_chain);
+	nxt_chain = qla25xx_copy_exlogin(ha, nxt_chain, &last_chain);
+	nxt_chain = qla81xx_copy_exchoffld(ha, nxt_chain, &last_chain);
 	if (last_chain) {
 		ha->fw_dump->version |= htonl(DUMP_CHAIN_VARIANT);
 		*last_chain |= htonl(DUMP_CHAIN_LAST);
@@ -2450,6 +2497,8 @@ copy_queue:
 	nxt_chain = qla25xx_copy_fce(ha, nxt_chain, &last_chain);
 	nxt_chain = qla25xx_copy_mqueues(ha, nxt_chain, &last_chain);
 	nxt_chain = qla2xxx_copy_atioqueues(ha, nxt_chain, &last_chain);
+	nxt_chain = qla25xx_copy_exlogin(ha, nxt_chain, &last_chain);
+	nxt_chain = qla81xx_copy_exchoffld(ha, nxt_chain, &last_chain);
 	if (last_chain) {
 		ha->fw_dump->version |= htonl(DUMP_CHAIN_VARIANT);
 		*last_chain |= htonl(DUMP_CHAIN_LAST);
diff --git a/drivers/scsi/qla2xxx/qla_dbg.h b/drivers/scsi/qla2xxx/qla_dbg.h
index ec0c6e8c1fbf..5986b08c449f 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.h
+++ b/drivers/scsi/qla2xxx/qla_dbg.h
@@ -232,6 +232,15 @@ struct qla2xxx_fce_chain {
 	uint32_t eregs[8];
 };
 
+/* used by exchange off load and extended login offload */
+struct qla2xxx_offld_chain {
+	uint32_t type;
+	uint32_t chain_size;
+
+	uint32_t size;
+	u64	 addr;
+};
+
 struct qla2xxx_mq_chain {
 	uint32_t type;
 	uint32_t chain_size;
@@ -258,6 +267,8 @@ struct qla2xxx_mqueue_chain {
 #define DUMP_CHAIN_FCE		0x7FFFFAF0
 #define DUMP_CHAIN_MQ		0x7FFFFAF1
 #define DUMP_CHAIN_QUEUE	0x7FFFFAF2
+#define DUMP_CHAIN_EXLOGIN	0x7FFFFAF3
+#define DUMP_CHAIN_EXCHG	0x7FFFFAF4
 #define DUMP_CHAIN_LAST		0x80000000
 
 struct qla2xxx_fw_dump {
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index b9189cae77e5..3b648d25a743 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -1659,6 +1659,13 @@ cont_alloc:
 	ha->chain_offset = dump_size;
 	dump_size += mq_size + fce_size;
 
+	if (ha->exchoffld_buf)
+		dump_size += sizeof(struct qla2xxx_offld_chain) +
+			ha->exchoffld_size;
+	if (ha->exlogin_buf)
+		dump_size += sizeof(struct qla2xxx_offld_chain) +
+			ha->exlogin_size;
+
 allocate:
 	ha->fw_dump = vmalloc(dump_size);
 	if (!ha->fw_dump) {
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
