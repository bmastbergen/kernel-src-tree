ceph: fix recursion between ceph_set_acl() and __ceph_setattr()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 8179a101eb5f4ef0ac9a915fcea9a9d3109efa90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8179a101.failed

ceph_set_acl() calls __ceph_setattr() if the setacl operation needs
to modify inode's i_mode. __ceph_setattr() updates inode's i_mode,
then calls posix_acl_chmod().

The problem is that __ceph_setattr() calls posix_acl_chmod() before
sending the setattr request. The get_acl() call in posix_acl_chmod()
can trigger a getxattr request. The reply of the getxattr request
can restore inode's i_mode to its old value. The set_acl() call in
posix_acl_chmod() sees old value of inode's i_mode, so it calls
__ceph_setattr() again.

	Cc: stable@vger.kernel.org # needs backporting for < 4.9
Link: http://tracker.ceph.com/issues/19688
	Reported-by: Jerry Lee <leisurelysw24@gmail.com>
	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Tested-by: Luis Henriques <lhenriques@suse.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 8179a101eb5f4ef0ac9a915fcea9a9d3109efa90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/inode.c
diff --cc fs/ceph/inode.c
index 9d67b9b0f077,d3119fe3ab45..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -2048,11 -2071,6 +2048,14 @@@ int ceph_setattr(struct dentry *dentry
  	if (inode_dirty_flags)
  		__mark_inode_dirty(inode, inode_dirty_flags);
  
++<<<<<<< HEAD
 +	if (ia_valid & ATTR_MODE) {
 +		err = ceph_acl_chmod(dentry, inode);
 +		if (err)
 +			goto out_put;
 +	}
++=======
++>>>>>>> 8179a101eb5f (ceph: fix recursion between ceph_set_acl() and __ceph_setattr())
  
  	if (mask) {
  		req->r_inode = inode;
@@@ -2066,17 -2084,38 +2069,41 @@@
  	     ceph_cap_string(dirtied), mask);
  
  	ceph_mdsc_put_request(req);
- 	if (mask & CEPH_SETATTR_SIZE)
- 		__ceph_do_pending_vmtruncate(inode);
  	ceph_free_cap_flush(prealloc_cf);
+ 
+ 	if (err >= 0 && (mask & CEPH_SETATTR_SIZE))
+ 		__ceph_do_pending_vmtruncate(inode);
+ 
  	return err;
- out_put:
- 	ceph_mdsc_put_request(req);
- 	ceph_free_cap_flush(prealloc_cf);
+ }
+ 
+ /*
++<<<<<<< HEAD
++=======
+  * setattr
+  */
+ int ceph_setattr(struct dentry *dentry, struct iattr *attr)
+ {
+ 	struct inode *inode = d_inode(dentry);
+ 	int err;
+ 
+ 	if (ceph_snap(inode) != CEPH_NOSNAP)
+ 		return -EROFS;
+ 
+ 	err = setattr_prepare(dentry, attr);
+ 	if (err != 0)
+ 		return err;
+ 
+ 	err = __ceph_setattr(inode, attr);
+ 
+ 	if (err >= 0 && (attr->ia_valid & ATTR_MODE))
+ 		err = posix_acl_chmod(inode, attr->ia_mode);
+ 
  	return err;
  }
  
  /*
++>>>>>>> 8179a101eb5f (ceph: fix recursion between ceph_set_acl() and __ceph_setattr())
   * Verify that we have a lease on the given mask.  If not,
   * do a getattr against an mds.
   */
* Unmerged path fs/ceph/inode.c
