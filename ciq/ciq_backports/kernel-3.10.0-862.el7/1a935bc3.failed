x86/entry: Move SYSENTER_stack to the beginning of struct tss_struct

jira LE-1907
cve CVE-2017-5754
cve CVE-2017-5753
cve CVE-2017-5715
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] entry: Move SYSENTER_stack to the beginning of struct tss_struct (Andrea Arcangeli) [1519801 1519798 1519786] {CVE-2017-5715 CVE-2017-5753 CVE-2017-5754}
Rebuild_FUZZ: 96.97%
commit-author Andy Lutomirski <luto@kernel.org>
commit 1a935bc3d4ea61556461a9e92a68ca3556232efd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1a935bc3.failed

SYSENTER_stack should have reliable overflow detection, which
means that it needs to be at the bottom of a page, not the top.
Move it to the beginning of struct tss_struct and page-align it.

Also add an assertion to make sure that the fixed hardware TSS
doesn't cross a page boundary.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bpetkov@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David Laight <David.Laight@aculab.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Eduardo Valentin <eduval@amazon.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: aliguori@amazon.com
	Cc: daniel.gruss@iaik.tugraz.at
	Cc: hughd@google.com
	Cc: keescook@google.com
Link: https://lkml.kernel.org/r/20171204150605.881827433@linutronix.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1a935bc3d4ea61556461a9e92a68ca3556232efd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/processor.h
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/include/asm/processor.h
index 5023ca6231a6,759051251664..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -300,15 -352,23 +309,34 @@@ struct tss_struct 
  	 * be within the limit.
  	 */
  	unsigned long		io_bitmap[IO_BITMAP_LONGS + 1];
+ } __aligned(PAGE_SIZE);
  
++<<<<<<< HEAD
 +	/*
 +	 * .. and then another 0x100 bytes for the emergency kernel stack:
 +	 */
 +	unsigned long		stack[64];
 +
 +} ____cacheline_aligned;
 +
 +DECLARE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss);
++=======
+ DECLARE_PER_CPU_PAGE_ALIGNED(struct tss_struct, cpu_tss);
+ 
+ /*
+  * sizeof(unsigned long) coming from an extra "long" at the end
+  * of the iobitmap.
+  *
+  * -1? seg base+limit should be pointing to the address of the
+  * last valid byte
+  */
+ #define __KERNEL_TSS_LIMIT	\
+ 	(IO_BITMAP_OFFSET + IO_BITMAP_BYTES + sizeof(unsigned long) - 1)
+ 
+ #ifdef CONFIG_X86_32
+ DECLARE_PER_CPU(unsigned long, cpu_current_top_of_stack);
+ #endif
++>>>>>>> 1a935bc3d4ea (x86/entry: Move SYSENTER_stack to the beginning of struct tss_struct)
  
  /*
   * Save the original ist values for checking stack pointers during debugging
diff --cc arch/x86/kernel/cpu/common.c
index d4b8a0a02f32,60b2dfd2a58b..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -423,6 -466,72 +423,75 @@@ void load_percpu_segment(int cpu
  	load_stack_canary_segment();
  }
  
++<<<<<<< HEAD
++=======
+ /* Setup the fixmap mappings only once per-processor */
+ static inline void setup_cpu_entry_area(int cpu)
+ {
+ #ifdef CONFIG_X86_64
+ 	/* On 64-bit systems, we use a read-only fixmap GDT. */
+ 	pgprot_t gdt_prot = PAGE_KERNEL_RO;
+ #else
+ 	/*
+ 	 * On native 32-bit systems, the GDT cannot be read-only because
+ 	 * our double fault handler uses a task gate, and entering through
+ 	 * a task gate needs to change an available TSS to busy.  If the GDT
+ 	 * is read-only, that will triple fault.
+ 	 *
+ 	 * On Xen PV, the GDT must be read-only because the hypervisor requires
+ 	 * it.
+ 	 */
+ 	pgprot_t gdt_prot = boot_cpu_has(X86_FEATURE_XENPV) ?
+ 		PAGE_KERNEL_RO : PAGE_KERNEL;
+ #endif
+ 
+ 	__set_fixmap(get_cpu_entry_area_index(cpu, gdt), get_cpu_gdt_paddr(cpu), gdt_prot);
+ 
+ 	/*
+ 	 * The Intel SDM says (Volume 3, 7.2.1):
+ 	 *
+ 	 *  Avoid placing a page boundary in the part of the TSS that the
+ 	 *  processor reads during a task switch (the first 104 bytes). The
+ 	 *  processor may not correctly perform address translations if a
+ 	 *  boundary occurs in this area. During a task switch, the processor
+ 	 *  reads and writes into the first 104 bytes of each TSS (using
+ 	 *  contiguous physical addresses beginning with the physical address
+ 	 *  of the first byte of the TSS). So, after TSS access begins, if
+ 	 *  part of the 104 bytes is not physically contiguous, the processor
+ 	 *  will access incorrect information without generating a page-fault
+ 	 *  exception.
+ 	 *
+ 	 * There are also a lot of errata involving the TSS spanning a page
+ 	 * boundary.  Assert that we're not doing that.
+ 	 */
+ 	BUILD_BUG_ON((offsetof(struct tss_struct, x86_tss) ^
+ 		      offsetofend(struct tss_struct, x86_tss)) & PAGE_MASK);
+ 
+ }
+ 
+ /* Load the original GDT from the per-cpu structure */
+ void load_direct_gdt(int cpu)
+ {
+ 	struct desc_ptr gdt_descr;
+ 
+ 	gdt_descr.address = (long)get_cpu_gdt_rw(cpu);
+ 	gdt_descr.size = GDT_SIZE - 1;
+ 	load_gdt(&gdt_descr);
+ }
+ EXPORT_SYMBOL_GPL(load_direct_gdt);
+ 
+ /* Load a fixmap remapping of the per-cpu GDT */
+ void load_fixmap_gdt(int cpu)
+ {
+ 	struct desc_ptr gdt_descr;
+ 
+ 	gdt_descr.address = (long)get_cpu_gdt_ro(cpu);
+ 	gdt_descr.size = GDT_SIZE - 1;
+ 	load_gdt(&gdt_descr);
+ }
+ EXPORT_SYMBOL_GPL(load_fixmap_gdt);
+ 
++>>>>>>> 1a935bc3d4ea (x86/entry: Move SYSENTER_stack to the beginning of struct tss_struct)
  /*
   * Current gdt points %fs at the "master" per-cpu area: after this,
   * it's on the real one.
* Unmerged path arch/x86/include/asm/processor.h
* Unmerged path arch/x86/kernel/cpu/common.c
