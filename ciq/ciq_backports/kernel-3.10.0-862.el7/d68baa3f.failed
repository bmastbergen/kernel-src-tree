x86/boot/e820: Add support to determine the E820 type of an address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] boot/e820: Add support to determine the E820 type of an address (Suravee Suthikulpanit) [1361287]
Rebuild_FUZZ: 96.92%
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit d68baa3fa6e4d703fd0c7954ee5c739789e7242f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d68baa3f.failed

Add a function that will return the E820 type associated with an address
range.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Larry Woodman <lwoodman@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Toshimitsu Kani <toshi.kani@hpe.com>
	Cc: kasan-dev@googlegroups.com
	Cc: kvm@vger.kernel.org
	Cc: linux-arch@vger.kernel.org
	Cc: linux-doc@vger.kernel.org
	Cc: linux-efi@vger.kernel.org
	Cc: linux-mm@kvack.org
Link: http://lkml.kernel.org/r/b797aaa588803bf33263d5dd8c32377668fa931a.1500319216.git.thomas.lendacky@amd.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit d68baa3fa6e4d703fd0c7954ee5c739789e7242f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/e820/api.h
#	arch/x86/kernel/e820.c
diff --cc arch/x86/kernel/e820.c
index f0e28af79d66,71c11ad5643e..000000000000
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@@ -68,40 -88,63 +68,64 @@@ e820_any_mapped(u64 start, u64 end, uns
  	}
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(e820__mapped_any);
 +EXPORT_SYMBOL_GPL(e820_any_mapped);
  
  /*
 - * This function checks if the entire <start,end> range is mapped with 'type'.
 + * This function checks if the entire range <start,end> is mapped with type.
   *
 - * Note: this function only works correctly once the E820 table is sorted and
 - * not-overlapping (at least for the range specified), which is the case normally.
 + * Note: this function only works correct if the e820 table is sorted and
 + * not-overlapping, which is the case
   */
++<<<<<<< HEAD
 +int __init e820_all_mapped(u64 start, u64 end, unsigned type)
++=======
+ static struct e820_entry *__e820__mapped_all(u64 start, u64 end,
+ 					     enum e820_type type)
++>>>>>>> d68baa3fa6e4 (x86/boot/e820: Add support to determine the E820 type of an address)
  {
  	int i;
  
 -	for (i = 0; i < e820_table->nr_entries; i++) {
 -		struct e820_entry *entry = &e820_table->entries[i];
 +	for (i = 0; i < e820.nr_map; i++) {
 +		struct e820entry *ei = &e820.map[i];
  
 -		if (type && entry->type != type)
 +		if (type && ei->type != type)
  			continue;
 -
 -		/* Is the region (part) in overlap with the current region? */
 -		if (entry->addr >= end || entry->addr + entry->size <= start)
 +		/* is the region (part) in overlap with the current region ?*/
 +		if (ei->addr >= end || ei->addr + ei->size <= start)
  			continue;
  
 -		/*
 -		 * If the region is at the beginning of <start,end> we move
 -		 * 'start' to the end of the region since it's ok until there
 +		/* if the region is at the beginning of <start,end> we move
 +		 * start to the end of the region since it's ok until there
  		 */
 -		if (entry->addr <= start)
 -			start = entry->addr + entry->size;
 -
 +		if (ei->addr <= start)
 +			start = ei->addr + ei->size;
  		/*
 -		 * If 'start' is now at or beyond 'end', we're done, full
 -		 * coverage of the desired range exists:
 +		 * if start is now at or beyond end, we're done, full
 +		 * coverage
  		 */
  		if (start >= end)
- 			return 1;
+ 			return entry;
  	}
- 	return 0;
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * This function checks if the entire range <start,end> is mapped with type.
+  */
+ bool __init e820__mapped_all(u64 start, u64 end, enum e820_type type)
+ {
+ 	return __e820__mapped_all(start, end, type);
+ }
+ 
+ /*
+  * This function returns the type associated with the range <start,end>.
+  */
+ int e820__get_entry_type(u64 start, u64 end)
+ {
+ 	struct e820_entry *entry = __e820__mapped_all(start, end, 0);
+ 
+ 	return entry ? entry->type : -EINVAL;
  }
  
  /*
* Unmerged path arch/x86/include/asm/e820/api.h
* Unmerged path arch/x86/include/asm/e820/api.h
* Unmerged path arch/x86/kernel/e820.c
