IB/hfi1: Add support to process 16B header errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Don Hiatt <don.hiatt@intel.com>
commit 5786adf3fde7aa22a68eedac9c59e40da76ffbfb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5786adf3.failed

Enhance hdr_rcverr() to also handle errors during
16B bypass packet receive.

	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Don Hiatt <don.hiatt@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 5786adf3fde7aa22a68eedac9c59e40da76ffbfb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/driver.c
#	drivers/infiniband/hw/hfi1/hfi.h
#	drivers/infiniband/hw/hfi1/ruc.c
#	drivers/infiniband/hw/hfi1/ud.c
#	drivers/infiniband/hw/hfi1/verbs.c
diff --cc drivers/infiniband/hw/hfi1/driver.c
index e4e01e0fe2d8,ae6a90d2a31c..000000000000
--- a/drivers/infiniband/hw/hfi1/driver.c
+++ b/drivers/infiniband/hw/hfi1/driver.c
@@@ -285,7 -269,7 +285,11 @@@ static void rcv_hdrerr(struct hfi1_ctxt
  {
  	struct ib_header *rhdr = packet->hdr;
  	u32 rte = rhf_rcv_type_err(packet->rhf);
++<<<<<<< HEAD
 +	int lnh = ib_get_lnh(rhdr);
++=======
+ 	u32 mlid_base;
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  	struct hfi1_ibport *ibp = rcd_to_iport(rcd);
  	struct hfi1_devdata *dd = ppd->dd;
  	struct rvt_dev_info *rdi = &dd->verbs_dev.rdi;
@@@ -293,37 -277,47 +297,63 @@@
  	if (packet->rhf & (RHF_VCRC_ERR | RHF_ICRC_ERR))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if (packet->etype == RHF_RCV_TYPE_BYPASS) {
+ 		goto drop;
+ 	} else {
+ 		u8 lnh = ib_get_lnh(rhdr);
+ 
+ 		mlid_base = be16_to_cpu(IB_MULTICAST_LID_BASE);
+ 		if (lnh == HFI1_LRH_BTH) {
+ 			packet->ohdr = &rhdr->u.oth;
+ 		} else if (lnh == HFI1_LRH_GRH) {
+ 			packet->ohdr = &rhdr->u.l.oth;
+ 			packet->grh = &rhdr->u.l.grh;
+ 		} else {
+ 			goto drop;
+ 		}
+ 	}
+ 
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  	if (packet->rhf & RHF_TID_ERR) {
  		/* For TIDERR and RC QPs preemptively schedule a NAK */
 +		struct ib_other_headers *ohdr = NULL;
  		u32 tlen = rhf_pkt_len(packet->rhf); /* in bytes */
 -		u32 dlid = ib_get_dlid(rhdr);
 +		u16 lid  = ib_get_dlid(rhdr);
  		u32 qp_num;
++<<<<<<< HEAD
 +		u32 rcv_flags = 0;
++=======
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  
  		/* Sanity check packet */
  		if (tlen < 24)
  			goto drop;
  
  		/* Check for GRH */
++<<<<<<< HEAD
 +		if (lnh == HFI1_LRH_BTH) {
 +			ohdr = &rhdr->u.oth;
 +		} else if (lnh == HFI1_LRH_GRH) {
++=======
+ 		if (packet->grh) {
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  			u32 vtf;
 -			struct ib_grh *grh = packet->grh;
  
 -			if (grh->next_hdr != IB_GRH_NEXT_HDR)
 +			ohdr = &rhdr->u.l.oth;
 +			if (rhdr->u.l.grh.next_hdr != IB_GRH_NEXT_HDR)
  				goto drop;
 -			vtf = be32_to_cpu(grh->version_tclass_flow);
 +			vtf = be32_to_cpu(rhdr->u.l.grh.version_tclass_flow);
  			if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
  				goto drop;
 +			rcv_flags |= HFI1_HAS_GRH;
 +		} else {
 +			goto drop;
  		}
 -
  		/* Get the destination QP number. */
 -		qp_num = ib_bth_get_qpn(packet->ohdr);
 -		if (dlid < mlid_base) {
 +		qp_num = be32_to_cpu(ohdr->bth[1]) & RVT_QPN_MASK;
 +		if (lid < be16_to_cpu(IB_MULTICAST_LID_BASE)) {
  			struct rvt_qp *qp;
  			unsigned long flags;
  
@@@ -1357,6 -1366,162 +1387,165 @@@ bail
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void hfi1_setup_ib_header(struct hfi1_packet *packet)
+ {
+ 	packet->hdr = (struct hfi1_ib_message_header *)
+ 			hfi1_get_msgheader(packet->rcd->dd,
+ 					   packet->rhf_addr);
+ 	packet->hlen = (u8 *)packet->rhf_addr - (u8 *)packet->hdr;
+ }
+ 
+ static int hfi1_bypass_ingress_pkt_check(struct hfi1_packet *packet)
+ {
+ 	struct hfi1_pportdata *ppd = packet->rcd->ppd;
+ 
+ 	/* slid and dlid cannot be 0 */
+ 	if ((!packet->slid) || (!packet->dlid))
+ 		return -EINVAL;
+ 
+ 	/* Compare port lid with incoming packet dlid */
+ 	if ((!(hfi1_is_16B_mcast(packet->dlid))) &&
+ 	    (packet->dlid !=
+ 		opa_get_lid(be32_to_cpu(OPA_LID_PERMISSIVE), 16B))) {
+ 		if (packet->dlid != ppd->lid)
+ 			return -EINVAL;
+ 	}
+ 
+ 	/* No multicast packets with SC15 */
+ 	if ((hfi1_is_16B_mcast(packet->dlid)) && (packet->sc == 0xF))
+ 		return -EINVAL;
+ 
+ 	/* Packets with permissive DLID always on SC15 */
+ 	if ((packet->dlid == opa_get_lid(be32_to_cpu(OPA_LID_PERMISSIVE),
+ 					 16B)) &&
+ 	    (packet->sc != 0xF))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static int hfi1_setup_9B_packet(struct hfi1_packet *packet)
+ {
+ 	struct hfi1_ibport *ibp = rcd_to_iport(packet->rcd);
+ 	struct ib_header *hdr;
+ 	u8 lnh;
+ 
+ 	hfi1_setup_ib_header(packet);
+ 	hdr = packet->hdr;
+ 
+ 	lnh = ib_get_lnh(hdr);
+ 	if (lnh == HFI1_LRH_BTH) {
+ 		packet->ohdr = &hdr->u.oth;
+ 		packet->grh = NULL;
+ 	} else if (lnh == HFI1_LRH_GRH) {
+ 		u32 vtf;
+ 
+ 		packet->ohdr = &hdr->u.l.oth;
+ 		packet->grh = &hdr->u.l.grh;
+ 		if (packet->grh->next_hdr != IB_GRH_NEXT_HDR)
+ 			goto drop;
+ 		vtf = be32_to_cpu(packet->grh->version_tclass_flow);
+ 		if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
+ 			goto drop;
+ 	} else {
+ 		goto drop;
+ 	}
+ 
+ 	/* Query commonly used fields from packet header */
+ 	packet->payload = packet->ebuf;
+ 	packet->opcode = ib_bth_get_opcode(packet->ohdr);
+ 	packet->slid = ib_get_slid(hdr);
+ 	packet->dlid = ib_get_dlid(hdr);
+ 	if (unlikely((packet->dlid >= be16_to_cpu(IB_MULTICAST_LID_BASE)) &&
+ 		     (packet->dlid != be16_to_cpu(IB_LID_PERMISSIVE))))
+ 		packet->dlid += opa_get_mcast_base(OPA_MCAST_NR) -
+ 				be16_to_cpu(IB_MULTICAST_LID_BASE);
+ 	packet->sl = ib_get_sl(hdr);
+ 	packet->sc = hfi1_9B_get_sc5(hdr, packet->rhf);
+ 	packet->pad = ib_bth_get_pad(packet->ohdr);
+ 	packet->extra_byte = 0;
+ 	packet->fecn = ib_bth_get_fecn(packet->ohdr);
+ 	packet->becn = ib_bth_get_becn(packet->ohdr);
+ 
+ 	return 0;
+ drop:
+ 	ibp->rvp.n_pkt_drops++;
+ 	return -EINVAL;
+ }
+ 
+ static int hfi1_setup_bypass_packet(struct hfi1_packet *packet)
+ {
+ 	/*
+ 	 * Bypass packets have a different header/payload split
+ 	 * compared to an IB packet.
+ 	 * Current split is set such that 16 bytes of the actual
+ 	 * header is in the header buffer and the remining is in
+ 	 * the eager buffer. We chose 16 since hfi1 driver only
+ 	 * supports 16B bypass packets and we will be able to
+ 	 * receive the entire LRH with such a split.
+ 	 */
+ 
+ 	struct hfi1_ctxtdata *rcd = packet->rcd;
+ 	struct hfi1_pportdata *ppd = rcd->ppd;
+ 	struct hfi1_ibport *ibp = &ppd->ibport_data;
+ 	u8 l4;
+ 	u8 grh_len;
+ 
+ 	packet->hdr = (struct hfi1_16b_header *)
+ 			hfi1_get_16B_header(packet->rcd->dd,
+ 					    packet->rhf_addr);
+ 	packet->hlen = (u8 *)packet->rhf_addr - (u8 *)packet->hdr;
+ 
+ 	l4 = hfi1_16B_get_l4(packet->hdr);
+ 	if (l4 == OPA_16B_L4_IB_LOCAL) {
+ 		grh_len = 0;
+ 		packet->ohdr = packet->ebuf;
+ 		packet->grh = NULL;
+ 	} else if (l4 == OPA_16B_L4_IB_GLOBAL) {
+ 		u32 vtf;
+ 
+ 		grh_len = sizeof(struct ib_grh);
+ 		packet->ohdr = packet->ebuf + grh_len;
+ 		packet->grh = packet->ebuf;
+ 		if (packet->grh->next_hdr != IB_GRH_NEXT_HDR)
+ 			goto drop;
+ 		vtf = be32_to_cpu(packet->grh->version_tclass_flow);
+ 		if ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)
+ 			goto drop;
+ 	} else {
+ 		goto drop;
+ 	}
+ 
+ 	/* Query commonly used fields from packet header */
+ 	packet->opcode = ib_bth_get_opcode(packet->ohdr);
+ 	packet->hlen = hdr_len_by_opcode[packet->opcode] + 8 + grh_len;
+ 	packet->payload = packet->ebuf + packet->hlen - (4 * sizeof(u32));
+ 	packet->slid = hfi1_16B_get_slid(packet->hdr);
+ 	packet->dlid = hfi1_16B_get_dlid(packet->hdr);
+ 	if (unlikely(hfi1_is_16B_mcast(packet->dlid)))
+ 		packet->dlid += opa_get_mcast_base(OPA_MCAST_NR) -
+ 				opa_get_lid(opa_get_mcast_base(OPA_MCAST_NR),
+ 					    16B);
+ 	packet->sc = hfi1_16B_get_sc(packet->hdr);
+ 	packet->sl = ibp->sc_to_sl[packet->sc];
+ 	packet->pad = hfi1_16B_bth_get_pad(packet->ohdr);
+ 	packet->extra_byte = SIZE_OF_LT;
+ 	packet->fecn = hfi1_16B_get_fecn(packet->hdr);
+ 	packet->becn = hfi1_16B_get_becn(packet->hdr);
+ 
+ 	if (hfi1_bypass_ingress_pkt_check(packet))
+ 		goto drop;
+ 
+ 	return 0;
+ drop:
+ 	hfi1_cdbg(PKT, "%s: packet dropped\n", __func__);
+ 	ibp->rvp.n_pkt_drops++;
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  void handle_eflags(struct hfi1_packet *packet)
  {
  	struct hfi1_ctxtdata *rcd = packet->rcd;
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index 9719cf207532,ee19660ca2fa..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -372,10 -343,102 +372,99 @@@ struct hfi1_packet 
  	u8 numpkt;
  	u8 rsize;
  	u8 updegr;
 +	u8 rcv_flags;
  	u8 etype;
 -	u8 extra_byte;
 -	u8 pad;
 -	u8 sc;
 -	u8 sl;
 -	u8 opcode;
 -	bool becn;
 -	bool fecn;
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * OPA 16B Header
+  */
+ #define OPA_16B_L4_MASK		0xFFull
+ #define OPA_16B_SC_MASK		0x1F00000ull
+ #define OPA_16B_SC_SHIFT	20
+ #define OPA_16B_LID_MASK	0xFFFFFull
+ #define OPA_16B_DLID_MASK	0xF000ull
+ #define OPA_16B_DLID_SHIFT	20
+ #define OPA_16B_DLID_HIGH_SHIFT	12
+ #define OPA_16B_SLID_MASK	0xF00ull
+ #define OPA_16B_SLID_SHIFT	20
+ #define OPA_16B_SLID_HIGH_SHIFT	8
+ #define OPA_16B_BECN_MASK       0x80000000ull
+ #define OPA_16B_BECN_SHIFT      31
+ #define OPA_16B_FECN_MASK       0x10000000ull
+ #define OPA_16B_FECN_SHIFT      28
+ #define OPA_16B_L2_MASK		0x60000000ull
+ #define OPA_16B_L2_SHIFT	29
+ #define OPA_16B_PKEY_MASK	0xFFFF0000ull
+ #define OPA_16B_PKEY_SHIFT	16
+ #define OPA_16B_LEN_MASK	0x7FF00000ull
+ #define OPA_16B_LEN_SHIFT	20
+ 
+ /*
+  * OPA 16B L2/L4 Encodings
+  */
+ #define OPA_16B_L2_TYPE		0x02
+ #define OPA_16B_L4_IB_LOCAL	0x09
+ #define OPA_16B_L4_IB_GLOBAL	0x0A
+ #define OPA_16B_L4_ETHR		OPA_VNIC_L4_ETHR
+ 
+ static inline u8 hfi1_16B_get_l4(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)(hdr->lrh[2] & OPA_16B_L4_MASK);
+ }
+ 
+ static inline u8 hfi1_16B_get_sc(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_SC_MASK) >> OPA_16B_SC_SHIFT);
+ }
+ 
+ static inline u32 hfi1_16B_get_dlid(struct hfi1_16b_header *hdr)
+ {
+ 	return (u32)((hdr->lrh[1] & OPA_16B_LID_MASK) |
+ 		     (((hdr->lrh[2] & OPA_16B_DLID_MASK) >>
+ 		     OPA_16B_DLID_HIGH_SHIFT) << OPA_16B_DLID_SHIFT));
+ }
+ 
+ static inline u32 hfi1_16B_get_slid(struct hfi1_16b_header *hdr)
+ {
+ 	return (u32)((hdr->lrh[0] & OPA_16B_LID_MASK) |
+ 		     (((hdr->lrh[2] & OPA_16B_SLID_MASK) >>
+ 		     OPA_16B_SLID_HIGH_SHIFT) << OPA_16B_SLID_SHIFT));
+ }
+ 
+ static inline u8 hfi1_16B_get_becn(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[0] & OPA_16B_BECN_MASK) >> OPA_16B_BECN_SHIFT);
+ }
+ 
+ static inline u8 hfi1_16B_get_fecn(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_FECN_MASK) >> OPA_16B_FECN_SHIFT);
+ }
+ 
+ static inline u8 hfi1_16B_get_l2(struct hfi1_16b_header *hdr)
+ {
+ 	return (u8)((hdr->lrh[1] & OPA_16B_L2_MASK) >> OPA_16B_L2_SHIFT);
+ }
+ 
+ static inline u16 hfi1_16B_get_pkey(struct hfi1_16b_header *hdr)
+ {
+ 	return (u16)((hdr->lrh[2] & OPA_16B_PKEY_MASK) >> OPA_16B_PKEY_SHIFT);
+ }
+ 
+ /*
+  * BTH
+  */
+ #define OPA_16B_BTH_PAD_MASK	7
+ static inline u8 hfi1_16B_bth_get_pad(struct ib_other_headers *ohdr)
+ {
+ 	return (u8)((be32_to_cpu(ohdr->bth[0]) >> IB_BTH_PAD_SHIFT) &
+ 		   OPA_16B_BTH_PAD_MASK);
+ }
+ 
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  struct rvt_sge_state;
  
  /*
diff --cc drivers/infiniband/hw/hfi1/ruc.c
index 675f4ef89dc3,d252f8f2207a..000000000000
--- a/drivers/infiniband/hw/hfi1/ruc.c
+++ b/drivers/infiniband/hw/hfi1/ruc.c
@@@ -221,76 -220,96 +221,128 @@@ int hfi1_ruc_check_hdr(struct hfi1_ibpo
  {
  	__be64 guid;
  	unsigned long flags;
++<<<<<<< HEAD
 +	u8 sc5 = ibp->sl_to_sc[qp->remote_ah_attr.sl];
 +
 +	if (qp->s_mig_state == IB_MIG_ARMED && (bth0 & IB_BTH_MIG_REQ)) {
 +		if (!has_grh) {
 +			if (qp->alt_ah_attr.ah_flags & IB_AH_GRH)
 +				goto err;
++=======
+ 	struct rvt_qp *qp = packet->qp;
+ 	u8 sc5 = ibp->sl_to_sc[rdma_ah_get_sl(&qp->remote_ah_attr)];
+ 	u32 dlid = packet->dlid;
+ 	u32 slid = packet->slid;
+ 	u32 sl = packet->sl;
+ 	int migrated;
+ 	u32 bth0, bth1;
+ 	u16 pkey;
+ 
+ 	bth0 = be32_to_cpu(packet->ohdr->bth[0]);
+ 	bth1 = be32_to_cpu(packet->ohdr->bth[1]);
+ 	if (packet->etype == RHF_RCV_TYPE_BYPASS) {
+ 		pkey = hfi1_16B_get_pkey(packet->hdr);
+ 		migrated = bth1 & OPA_BTH_MIG_REQ;
+ 	} else {
+ 		pkey = ib_bth_get_pkey(packet->ohdr);
+ 		migrated = bth0 & IB_BTH_MIG_REQ;
+ 	}
+ 
+ 	if (qp->s_mig_state == IB_MIG_ARMED && migrated) {
+ 		if (!packet->grh) {
+ 			if ((rdma_ah_get_ah_flags(&qp->alt_ah_attr) &
+ 			     IB_AH_GRH) &&
+ 			    (packet->etype != RHF_RCV_TYPE_BYPASS))
+ 				return 1;
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  		} else {
 -			const struct ib_global_route *grh;
 -
 -			if (!(rdma_ah_get_ah_flags(&qp->alt_ah_attr) &
 -			      IB_AH_GRH))
 -				return 1;
 -			grh = rdma_ah_read_grh(&qp->alt_ah_attr);
 -			guid = get_sguid(ibp, grh->sgid_index);
 -			if (!gid_ok(&packet->grh->dgid, ibp->rvp.gid_prefix,
 +			if (!(qp->alt_ah_attr.ah_flags & IB_AH_GRH))
 +				goto err;
 +			guid = get_sguid(ibp, qp->alt_ah_attr.grh.sgid_index);
 +			if (!gid_ok(&hdr->u.l.grh.dgid, ibp->rvp.gid_prefix,
  				    guid))
 -				return 1;
 +				goto err;
  			if (!gid_ok(
 -				&packet->grh->sgid,
 -				grh->dgid.global.subnet_prefix,
 -				grh->dgid.global.interface_id))
 -				return 1;
 +				&hdr->u.l.grh.sgid,
 +				qp->alt_ah_attr.grh.dgid.global.subnet_prefix,
 +				qp->alt_ah_attr.grh.dgid.global.interface_id))
 +				goto err;
  		}
++<<<<<<< HEAD
 +		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0, sc5,
 +					    ib_get_slid(hdr)))) {
 +			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY,
 +				       (u16)bth0,
 +				       ib_get_sl(hdr),
 +				       0, qp->ibqp.qp_num,
 +				       ib_get_slid(hdr),
 +				       ib_get_dlid(hdr));
 +			goto err;
++=======
+ 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), pkey,
+ 					    sc5, slid))) {
+ 			hfi1_bad_pkey(ibp, pkey, sl, 0, qp->ibqp.qp_num,
+ 				      slid, dlid);
+ 			return 1;
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  		}
  		/* Validate the SLID. See Ch. 9.6.1.5 and 17.2.8 */
 -		if (slid != rdma_ah_get_dlid(&qp->alt_ah_attr) ||
 -		    ppd_from_ibp(ibp)->port !=
 -			rdma_ah_get_port_num(&qp->alt_ah_attr))
 -			return 1;
 +		if (ib_get_slid(hdr) != qp->alt_ah_attr.dlid ||
 +		    ppd_from_ibp(ibp)->port != qp->alt_ah_attr.port_num)
 +			goto err;
  		spin_lock_irqsave(&qp->s_lock, flags);
  		hfi1_migrate_qp(qp);
  		spin_unlock_irqrestore(&qp->s_lock, flags);
  	} else {
++<<<<<<< HEAD
 +		if (!has_grh) {
 +			if (qp->remote_ah_attr.ah_flags & IB_AH_GRH)
 +				goto err;
++=======
+ 		if (!packet->grh) {
+ 			if ((rdma_ah_get_ah_flags(&qp->remote_ah_attr) &
+ 			     IB_AH_GRH) &&
+ 			    (packet->etype != RHF_RCV_TYPE_BYPASS))
+ 				return 1;
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  		} else {
 -			const struct ib_global_route *grh;
 -
 -			if (!(rdma_ah_get_ah_flags(&qp->remote_ah_attr) &
 -						   IB_AH_GRH))
 -				return 1;
 -			grh = rdma_ah_read_grh(&qp->remote_ah_attr);
 -			guid = get_sguid(ibp, grh->sgid_index);
 -			if (!gid_ok(&packet->grh->dgid, ibp->rvp.gid_prefix,
 +			if (!(qp->remote_ah_attr.ah_flags & IB_AH_GRH))
 +				goto err;
 +			guid = get_sguid(ibp,
 +					 qp->remote_ah_attr.grh.sgid_index);
 +			if (!gid_ok(&hdr->u.l.grh.dgid, ibp->rvp.gid_prefix,
  				    guid))
 -				return 1;
 +				goto err;
  			if (!gid_ok(
 -			     &packet->grh->sgid,
 -			     grh->dgid.global.subnet_prefix,
 -			     grh->dgid.global.interface_id))
 -				return 1;
 +			     &hdr->u.l.grh.sgid,
 +			     qp->remote_ah_attr.grh.dgid.global.subnet_prefix,
 +			     qp->remote_ah_attr.grh.dgid.global.interface_id))
 +				goto err;
  		}
++<<<<<<< HEAD
 +		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), (u16)bth0, sc5,
 +					    ib_get_slid(hdr)))) {
 +			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY,
 +				       (u16)bth0,
 +				       ib_get_sl(hdr),
 +				       0, qp->ibqp.qp_num,
 +				       ib_get_slid(hdr),
 +				       ib_get_dlid(hdr));
 +			goto err;
++=======
+ 		if (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), pkey,
+ 					    sc5, slid))) {
+ 			hfi1_bad_pkey(ibp, pkey, sl, 0, qp->ibqp.qp_num,
+ 				      slid, dlid);
+ 			return 1;
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  		}
  		/* Validate the SLID. See Ch. 9.6.1.5 */
 -		if ((slid != rdma_ah_get_dlid(&qp->remote_ah_attr)) ||
 +		if (ib_get_slid(hdr) != qp->remote_ah_attr.dlid ||
  		    ppd_from_ibp(ibp)->port != qp->port_num)
 -			return 1;
 -		if (qp->s_mig_state == IB_MIG_REARM && !migrated)
 +			goto err;
 +		if (qp->s_mig_state == IB_MIG_REARM &&
 +		    !(bth0 & IB_BTH_MIG_REQ))
  			qp->s_mig_state = IB_MIG_ARMED;
  	}
  
diff --cc drivers/infiniband/hw/hfi1/ud.c
index 45bc3f04793e,b708376b67da..000000000000
--- a/drivers/infiniband/hw/hfi1/ud.c
+++ b/drivers/infiniband/hw/hfi1/ud.c
@@@ -103,17 -103,18 +103,26 @@@ static void ud_loopback(struct rvt_qp *
  	if (qp->ibqp.qp_num > 1) {
  		u16 pkey;
  		u16 slid;
 -		u8 sc5 = ibp->sl_to_sc[rdma_ah_get_sl(ah_attr)];
 +		u8 sc5 = ibp->sl_to_sc[ah_attr->sl];
  
  		pkey = hfi1_get_pkey(ibp, sqp->s_pkey_index);
 -		slid = ppd->lid | (rdma_ah_get_path_bits(ah_attr) &
 +		slid = ppd->lid | (ah_attr->src_path_bits &
  				   ((1 << ppd->lmc) - 1));
  		if (unlikely(ingress_pkey_check(ppd, pkey, sc5,
++<<<<<<< HEAD
 +						qp->s_pkey_index, slid))) {
 +			hfi1_bad_pqkey(ibp, OPA_TRAP_BAD_P_KEY, pkey,
 +				       ah_attr->sl,
 +				       sqp->ibqp.qp_num, qp->ibqp.qp_num,
 +				       slid, ah_attr->dlid);
++=======
+ 						qp->s_pkey_index,
+ 						slid, false))) {
+ 			hfi1_bad_pkey(ibp, pkey,
+ 				      rdma_ah_get_sl(ah_attr),
+ 				      sqp->ibqp.qp_num, qp->ibqp.qp_num,
+ 				      slid, rdma_ah_get_dlid(ah_attr));
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  			goto drop;
  		}
  	}
diff --cc drivers/infiniband/hw/hfi1/verbs.c
index 06ac08cf82a6,0b1556fed47e..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@@ -548,19 -568,29 +548,42 @@@ static u64 hfi1_fault_tx(struct rvt_qp 
  	return pbc;
  }
  
++<<<<<<< HEAD
 +/**
 + * hfi1_ib_rcv - process an incoming packet
 + * @packet: data packet information
 + *
 + * This is called to process an incoming packet at interrupt level.
 + *
 + * Tlen is the length of the header + data + CRC in bytes.
 + */
 +void hfi1_ib_rcv(struct hfi1_packet *packet)
++=======
+ static int hfi1_do_pkey_check(struct hfi1_packet *packet)
+ {
+ 	struct hfi1_ctxtdata *rcd = packet->rcd;
+ 	struct hfi1_pportdata *ppd = rcd->ppd;
+ 	struct hfi1_16b_header *hdr = packet->hdr;
+ 	u16 pkey;
+ 
+ 	/* Pkey check needed only for bypass packets */
+ 	if (packet->etype != RHF_RCV_TYPE_BYPASS)
+ 		return 0;
+ 
+ 	/* Perform pkey check */
+ 	pkey = hfi1_16B_get_pkey(hdr);
+ 	return ingress_pkey_check(ppd, pkey, packet->sc,
+ 				  packet->qp->s_pkey_index,
+ 				  packet->slid, true);
+ }
+ 
+ static inline void hfi1_handle_packet(struct hfi1_packet *packet,
+ 				      bool is_mcast)
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  {
 -	u32 qp_num;
  	struct hfi1_ctxtdata *rcd = packet->rcd;
 +	struct ib_header *hdr = packet->hdr;
 +	u32 tlen = packet->tlen;
  	struct hfi1_pportdata *ppd = rcd->ppd;
  	struct hfi1_ibport *ibp = rcd_to_iport(rcd);
  	struct rvt_dev_info *rdi = &ppd->dd->verbs_dev.rdi;
@@@ -608,8 -612,10 +631,10 @@@
  			goto drop;
  		list_for_each_entry_rcu(p, &mcast->qp_list, list) {
  			packet->qp = p->qp;
+ 			if (hfi1_do_pkey_check(packet))
+ 				goto drop;
  			spin_lock_irqsave(&packet->qp->r_lock, flags);
 -			packet_handler = qp_ok(packet);
 +			packet_handler = qp_ok(opcode, packet);
  			if (likely(packet_handler))
  				packet_handler(packet);
  			else
@@@ -623,19 -629,22 +648,32 @@@
  		if (atomic_dec_return(&mcast->refcount) <= 1)
  			wake_up(&mcast->wait);
  	} else {
 -		/* Get the destination QP number. */
 -		qp_num = ib_bth_get_qpn(packet->ohdr);
  		rcu_read_lock();
  		packet->qp = rvt_lookup_qpn(rdi, &ibp->rvp, qp_num);
++<<<<<<< HEAD
 +		if (!packet->qp) {
 +			rcu_read_unlock();
 +			goto drop;
 +		}
 +		if (unlikely(hfi1_dbg_fault_opcode(packet->qp, opcode,
 +						   true))) {
 +			rcu_read_unlock();
 +			goto drop;
 +		}
++=======
+ 		if (!packet->qp)
+ 			goto unlock_drop;
+ 
+ 		if (hfi1_do_pkey_check(packet))
+ 			goto unlock_drop;
+ 
+ 		if (unlikely(hfi1_dbg_fault_opcode(packet->qp, packet->opcode,
+ 						   true)))
+ 			goto unlock_drop;
+ 
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  		spin_lock_irqsave(&packet->qp->r_lock, flags);
 -		packet_handler = qp_ok(packet);
 +		packet_handler = qp_ok(opcode, packet);
  		if (likely(packet_handler))
  			packet_handler(packet);
  		else
@@@ -644,7 -653,8 +682,12 @@@
  		rcu_read_unlock();
  	}
  	return;
++<<<<<<< HEAD
 +
++=======
+ unlock_drop:
+ 	rcu_read_unlock();
++>>>>>>> 5786adf3fde7 (IB/hfi1: Add support to process 16B header errors)
  drop:
  	ibp->rvp.n_pkt_drops++;
  }
* Unmerged path drivers/infiniband/hw/hfi1/driver.c
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
* Unmerged path drivers/infiniband/hw/hfi1/ruc.c
* Unmerged path drivers/infiniband/hw/hfi1/ud.c
* Unmerged path drivers/infiniband/hw/hfi1/verbs.c
diff --git a/drivers/infiniband/hw/hfi1/verbs.h b/drivers/infiniband/hw/hfi1/verbs.h
index 76081f770f70..ffb1823ee6b8 100644
--- a/drivers/infiniband/hw/hfi1/verbs.h
+++ b/drivers/infiniband/hw/hfi1/verbs.h
@@ -95,6 +95,7 @@ struct hfi1_packet;
 #define HFI1_VENDOR_IPG		cpu_to_be16(0xFFA0)
 
 #define IB_DEFAULT_GID_PREFIX	cpu_to_be64(0xfe80000000000000ULL)
+#define OPA_BTH_MIG_REQ		BIT(31)
 
 #define RC_OP(x) IB_OPCODE_RC_##x
 #define UC_OP(x) IB_OPCODE_UC_##x
