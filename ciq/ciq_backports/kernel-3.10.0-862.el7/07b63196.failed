target/iblock: pass WRITE_SAME to device if possible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 07b6319687026bdac90a0bb9eeb0509f1ff27179
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/07b63196.failed

This patch has iblock pass the WRITE_SAME command to
the device for offloading if possible. It is similar to what is
done for UNMAP/discards, except that we export a large max write same
value to the initiator, and then rely on the block layer to
break it up into multiple requests if it cannot fit into one.

v2.

- Drop file backend changes and move helper function to
iblock backend.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 07b6319687026bdac90a0bb9eeb0509f1ff27179)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_iblock.c
diff --cc drivers/target/target_core_iblock.c
index 4ff1c8404aab,026a758e5778..000000000000
--- a/drivers/target/target_core_iblock.c
+++ b/drivers/target/target_core_iblock.c
@@@ -431,24 -413,30 +431,51 @@@ iblock_do_unmap(struct se_cmd *cmd, voi
  }
  
  static sense_reason_t
++<<<<<<< HEAD
 +iblock_execute_unmap(struct se_cmd *cmd)
 +{
 +	struct block_device *bdev = IBLOCK_DEV(cmd->se_dev)->ibd_bd;
 +
 +	return sbc_execute_unmap(cmd, iblock_do_unmap, bdev);
 +}
 +
 +static sense_reason_t
 +iblock_execute_write_same_unmap(struct se_cmd *cmd)
 +{
 +	struct block_device *bdev = IBLOCK_DEV(cmd->se_dev)->ibd_bd;
 +	sector_t lba = cmd->t_task_lba;
 +	sector_t nolb = sbc_get_write_same_sectors(cmd);
 +	sense_reason_t ret;
 +
 +	ret = iblock_do_unmap(cmd, bdev, lba, nolb);
 +	if (ret)
 +		return ret;
++=======
+ iblock_execute_write_same_direct(struct block_device *bdev, struct se_cmd *cmd)
+ {
+ 	struct se_device *dev = cmd->se_dev;
+ 	struct scatterlist *sg = &cmd->t_data_sg[0];
+ 	struct page *page = NULL;
+ 	int ret;
+ 
+ 	if (sg->offset) {
+ 		page = alloc_page(GFP_KERNEL);
+ 		if (!page)
+ 			return TCM_OUT_OF_RESOURCES;
+ 		sg_copy_to_buffer(sg, cmd->t_data_nents, page_address(page),
+ 				  dev->dev_attrib.block_size);
+ 	}
+ 
+ 	ret = blkdev_issue_write_same(bdev,
+ 				target_to_linux_sector(dev, cmd->t_task_lba),
+ 				target_to_linux_sector(dev,
+ 					sbc_get_write_same_sectors(cmd)),
+ 				GFP_KERNEL, page ? page : sg_page(sg));
+ 	if (page)
+ 		__free_page(page);
+ 	if (ret)
+ 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
++>>>>>>> 07b631968702 (target/iblock: pass WRITE_SAME to device if possible)
  
  	target_complete_cmd(cmd, GOOD);
  	return 0;
* Unmerged path drivers/target/target_core_iblock.c
