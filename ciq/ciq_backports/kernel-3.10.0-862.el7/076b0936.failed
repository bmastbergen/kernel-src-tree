net/mlx5e: IPoIB, Add ethtool support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: IPoIB, Add ethtool support (Don Dutile) [1499363 1385325]
Rebuild_FUZZ: 94.29%
commit-author Erez Shitrit <erezsh@mellanox.com>
commit 076b0936e5fb8dd5513c1472a2c1d487b64d1580
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/076b0936.failed

Add support for the following:
	"ethtool -S" (statistics).
	"ethtool -i" (driver info).
	"ethtool -g/G" (rings parameters).
	"ethtool -l/L" (channels parameters).
	"ethtool -c/C" (coalesce options).

	Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 076b0936e5fb8dd5513c1472a2c1d487b64d1580)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 9e644615f07a,5ad093a21a6e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -12,4 -15,4 +12,8 @@@ mlx5_core-$(CONFIG_MLX5_CORE_EN) += wq.
  
  mlx5_core-$(CONFIG_MLX5_CORE_EN_DCB) +=  en_dcbnl.o
  
++<<<<<<< HEAD
 +mlx5_core-$(CONFIG_MLX5_CORE_IPOIB) += ipoib.o
++=======
+ mlx5_core-$(CONFIG_MLX5_CORE_IPOIB) += ipoib/ipoib.o ipoib/ethtool.o
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index efce1dc691aa,49c5fe9fdff0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -914,22 -1019,38 +914,56 @@@ void mlx5e_cleanup_nic_tx(struct mlx5e_
  int mlx5e_close(struct net_device *netdev);
  int mlx5e_open(struct net_device *netdev);
  void mlx5e_update_stats_work(struct work_struct *work);
 +struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
 +				       const struct mlx5e_profile *profile,
 +				       void *ppriv);
 +void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv);
 +int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 +void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
  u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout);
 -
 +void mlx5e_add_vxlan_port(struct net_device *netdev,
 +			  struct udp_tunnel_info *ti);
 +void mlx5e_del_vxlan_port(struct net_device *netdev,
 +			  struct udp_tunnel_info *ti);
 +
++<<<<<<< HEAD
 +int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev,
 +			    void *sp);
 +bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
++=======
+ /* ethtool helpers */
+ void mlx5e_ethtool_get_drvinfo(struct mlx5e_priv *priv,
+ 			       struct ethtool_drvinfo *drvinfo);
+ void mlx5e_ethtool_get_strings(struct mlx5e_priv *priv,
+ 			       uint32_t stringset, uint8_t *data);
+ int mlx5e_ethtool_get_sset_count(struct mlx5e_priv *priv, int sset);
+ void mlx5e_ethtool_get_ethtool_stats(struct mlx5e_priv *priv,
+ 				     struct ethtool_stats *stats, u64 *data);
+ void mlx5e_ethtool_get_ringparam(struct mlx5e_priv *priv,
+ 				 struct ethtool_ringparam *param);
+ int mlx5e_ethtool_set_ringparam(struct mlx5e_priv *priv,
+ 				struct ethtool_ringparam *param);
+ void mlx5e_ethtool_get_channels(struct mlx5e_priv *priv,
+ 				struct ethtool_channels *ch);
+ int mlx5e_ethtool_set_channels(struct mlx5e_priv *priv,
+ 			       struct ethtool_channels *ch);
+ int mlx5e_ethtool_get_coalesce(struct mlx5e_priv *priv,
+ 			       struct ethtool_coalesce *coal);
+ int mlx5e_ethtool_set_coalesce(struct mlx5e_priv *priv,
+ 			       struct ethtool_coalesce *coal);
+ 
+ /* mlx5e generic netdev management API */
+ struct net_device*
+ mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
+ 		    void *ppriv);
+ int mlx5e_attach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_detach_netdev(struct mlx5e_priv *priv);
+ void mlx5e_destroy_netdev(struct mlx5e_priv *priv);
+ void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
+ 			    struct mlx5e_params *params,
+ 			    u16 max_channels);
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  
 +bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 +bool mlx5e_is_vf_vport_rep(struct mlx5e_priv *priv);
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 052cf33d86ef,fa472c4d3d00..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -279,13 -289,12 +292,12 @@@ static void mlx5e_fill_stats_strings(st
  			for (j = 0; j < NUM_SQ_STATS; j++)
  				sprintf(data + (idx++) * ETH_GSTRING_LEN,
  					sq_stats_desc[j].format,
 -					priv->channel_tc2txq[i][tc]);
 +					priv->channeltc_to_txq_map[i][tc]);
  }
  
- static void mlx5e_get_strings(struct net_device *dev,
- 			      uint32_t stringset, uint8_t *data)
+ void mlx5e_ethtool_get_strings(struct mlx5e_priv *priv,
+ 			       uint32_t stringset, uint8_t *data)
  {
- 	struct mlx5e_priv *priv = netdev_priv(dev);
  	int i;
  
  	switch (stringset) {
@@@ -306,10 -315,18 +318,21 @@@
  	}
  }
  
- static void mlx5e_get_ethtool_stats(struct net_device *dev,
- 				    struct ethtool_stats *stats, u64 *data)
+ static void mlx5e_get_strings(struct net_device *dev,
+ 			      uint32_t stringset, uint8_t *data)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
++<<<<<<< HEAD
++=======
+ 
+ 	mlx5e_ethtool_get_strings(priv, stringset, data);
+ }
+ 
+ void mlx5e_ethtool_get_ethtool_stats(struct mlx5e_priv *priv,
+ 				     struct ethtool_stats *stats, u64 *data)
+ {
+ 	struct mlx5e_channels *channels;
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  	struct mlx5_priv *mlx5_priv;
  	int i, j, tc, prio, idx = 0;
  	unsigned long pfc_combined;
@@@ -446,26 -473,32 +478,42 @@@ static u32 mlx5e_packets_to_rx_wqes(str
  	return 1 << (order_base_2(num_wqes));
  }
  
- static void mlx5e_get_ringparam(struct net_device *dev,
- 				struct ethtool_ringparam *param)
+ void mlx5e_ethtool_get_ringparam(struct mlx5e_priv *priv,
+ 				 struct ethtool_ringparam *param)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = netdev_priv(dev);
 +	int rq_wq_type = priv->params.rq_wq_type;
++=======
+ 	int rq_wq_type = priv->channels.params.rq_wq_type;
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  
  	param->rx_max_pending = mlx5e_rx_wqes_to_packets(priv, rq_wq_type,
  							 1 << mlx5_max_log_rq_size(rq_wq_type));
  	param->tx_max_pending = 1 << MLX5E_PARAMS_MAXIMUM_LOG_SQ_SIZE;
  	param->rx_pending = mlx5e_rx_wqes_to_packets(priv, rq_wq_type,
 -						     1 << priv->channels.params.log_rq_size);
 -	param->tx_pending     = 1 << priv->channels.params.log_sq_size;
 +						     1 << priv->params.log_rq_size);
 +	param->tx_pending     = 1 << priv->params.log_sq_size;
  }
  
- static int mlx5e_set_ringparam(struct net_device *dev,
- 			       struct ethtool_ringparam *param)
+ static void mlx5e_get_ringparam(struct net_device *dev,
+ 				struct ethtool_ringparam *param)
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
++<<<<<<< HEAD
 +	bool was_opened;
 +	int rq_wq_type = priv->params.rq_wq_type;
++=======
+ 
+ 	mlx5e_ethtool_get_ringparam(priv, param);
+ }
+ 
+ int mlx5e_ethtool_set_ringparam(struct mlx5e_priv *priv,
+ 				struct ethtool_ringparam *param)
+ {
+ 	int rq_wq_type = priv->channels.params.rq_wq_type;
+ 	struct mlx5e_channels new_channels = {};
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  	u32 rx_pending_wqes;
  	u32 min_rq_size;
  	u32 max_rq_size;
@@@ -507,9 -539,9 +555,9 @@@
  	}
  
  	num_mtts = MLX5E_REQUIRED_MTTS(rx_pending_wqes);
 -	if (priv->channels.params.rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ &&
 +	if (priv->params.rq_wq_type == MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ &&
  	    !MLX5E_VALID_NUM_MTTS(num_mtts)) {
- 		netdev_info(dev, "%s: rx_pending (%d) request can't be satisfied, try to reduce.\n",
+ 		netdev_info(priv->netdev, "%s: rx_pending (%d) request can't be satisfied, try to reduce.\n",
  			    __func__, param->rx_pending);
  		return -EINVAL;
  	}
@@@ -559,17 -609,15 +622,20 @@@ static void mlx5e_get_channels(struct n
  {
  	struct mlx5e_priv *priv = netdev_priv(dev);
  
++<<<<<<< HEAD
 +	ch->max_combined   = mlx5e_get_max_num_channels(priv->mdev);
 +	ch->combined_count = priv->params.num_channels;
++=======
+ 	mlx5e_ethtool_get_channels(priv, ch);
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  }
  
- static int mlx5e_set_channels(struct net_device *dev,
- 			      struct ethtool_channels *ch)
+ int mlx5e_ethtool_set_channels(struct mlx5e_priv *priv,
+ 			       struct ethtool_channels *ch)
  {
- 	struct mlx5e_priv *priv = netdev_priv(dev);
  	unsigned int count = ch->combined_count;
 -	struct mlx5e_channels new_channels = {};
  	bool arfs_enabled;
 +	bool was_opened;
  	int err = 0;
  
  	if (!count) {
@@@ -583,11 -631,22 +649,11 @@@
  
  	mutex_lock(&priv->state_lock);
  
 -	new_channels.params = priv->channels.params;
 -	new_channels.params.num_channels = count;
 -	mlx5e_build_default_indir_rqt(priv->mdev, new_channels.params.indirection_rqt,
 -				      MLX5E_INDIR_RQT_SIZE, count);
 -
 -	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
 -		priv->channels.params = new_channels.params;
 -		goto out;
 -	}
 -
 -	/* Create fresh channels with new parameters */
 -	err = mlx5e_open_channels(priv, &new_channels);
 -	if (err)
 -		goto out;
 +	was_opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
 +	if (was_opened)
 +		mlx5e_close_locked(dev);
  
- 	arfs_enabled = dev->features & NETIF_F_NTUPLE;
+ 	arfs_enabled = priv->netdev->features & NETIF_F_NTUPLE;
  	if (arfs_enabled)
  		mlx5e_arfs_disable(priv);
  
@@@ -630,16 -689,18 +702,29 @@@ int mlx5e_ethtool_get_coalesce(struct m
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_set_coalesce(struct net_device *netdev,
 +			      struct ethtool_coalesce *coal)
++=======
+ static int mlx5e_get_coalesce(struct net_device *netdev,
+ 			      struct ethtool_coalesce *coal)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	return mlx5e_ethtool_get_coalesce(priv, coal);
+ }
+ 
+ static void
+ mlx5e_set_priv_channels_coalesce(struct mlx5e_priv *priv, struct ethtool_coalesce *coal)
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  {
 +	struct mlx5e_priv *priv    = netdev_priv(netdev);
  	struct mlx5_core_dev *mdev = priv->mdev;
 +	struct mlx5e_channel *c;
 +	bool restart =
 +		!!coal->use_adaptive_rx_coalesce != priv->params.rx_am_enabled;
 +	bool was_opened;
 +	int err = 0;
  	int tc;
  	int i;
  
@@@ -676,11 -718,49 +761,55 @@@
  					       coal->rx_coalesce_usecs,
  					       coal->rx_max_coalesced_frames);
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ int mlx5e_ethtool_set_coalesce(struct mlx5e_priv *priv,
+ 			       struct ethtool_coalesce *coal)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5e_channels new_channels = {};
+ 	int err = 0;
+ 	bool reset;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, cq_moderation))
+ 		return -EOPNOTSUPP;
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	new_channels.params = priv->channels.params;
+ 
+ 	new_channels.params.tx_cq_moderation.usec = coal->tx_coalesce_usecs;
+ 	new_channels.params.tx_cq_moderation.pkts = coal->tx_max_coalesced_frames;
+ 	new_channels.params.rx_cq_moderation.usec = coal->rx_coalesce_usecs;
+ 	new_channels.params.rx_cq_moderation.pkts = coal->rx_max_coalesced_frames;
+ 	new_channels.params.rx_am_enabled         = !!coal->use_adaptive_rx_coalesce;
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
+ 		priv->channels.params = new_channels.params;
+ 		goto out;
+ 	}
+ 	/* we are opened */
+ 
+ 	reset = !!coal->use_adaptive_rx_coalesce != priv->channels.params.rx_am_enabled;
+ 	if (!reset) {
+ 		mlx5e_set_priv_channels_coalesce(priv, coal);
+ 		priv->channels.params = new_channels.params;
+ 		goto out;
+ 	}
+ 
+ 	/* open fresh channels with new coal parameters */
+ 	err = mlx5e_open_channels(priv, &new_channels);
+ 	if (err)
+ 		goto out;
+ 
+ 	mlx5e_switch_priv_channels(priv, &new_channels, NULL);
++>>>>>>> 076b0936e5fb (net/mlx5e: IPoIB, Add ethtool support)
  
  out:
 +	if (was_opened && restart)
 +		err = mlx5e_open_locked(netdev);
 +
  	mutex_unlock(&priv->state_lock);
  	return err;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.h b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
index 89bca182464c..9a9a34f2a763 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.h
@@ -38,6 +38,8 @@
 
 #define MLX5I_MAX_NUM_TC 1
 
+extern const struct ethtool_ops mlx5i_ethtool_ops;
+
 /* ipoib rdma netdev's private data structure */
 struct mlx5i_priv {
 	struct mlx5_core_qp qp;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
