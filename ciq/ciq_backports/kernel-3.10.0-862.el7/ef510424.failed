block, dax: move "select DAX" from BLOCK to FS_DAX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit ef51042472f55b325fd7f2b26a2e29fd89757234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ef510424.failed

For configurations that do not enable DAX filesystems or drivers, do not
require the DAX core to be built.

Given that the 'direct_access' method has been removed from
'block_device_operations', we can also go ahead and remove the
block-related dax helper functions from fs/block_dev.c to
drivers/dax/super.c. This keeps dax details out of the block layer and
lets the DAX core be built as a module in the FS_DAX=n case.

Filesystems need to include dax.h to call bdev_dax_supported().

	Cc: linux-xfs@vger.kernel.org
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: "Theodore Ts'o" <tytso@mit.edu>
	Cc: Matthew Wilcox <mawilcox@microsoft.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: "Darrick J. Wong" <darrick.wong@oracle.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Jan Kara <jack@suse.com>
	Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit ef51042472f55b325fd7f2b26a2e29fd89757234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/Kconfig
#	drivers/dax/super.c
#	fs/Kconfig
#	fs/block_dev.c
#	fs/ext2/super.c
#	include/linux/blkdev.h
#	include/linux/dax.h
diff --cc block/Kconfig
index a7e40a7c8214,e9f780f815f5..000000000000
--- a/block/Kconfig
+++ b/block/Kconfig
@@@ -4,6 -4,8 +4,11 @@@
  menuconfig BLOCK
         bool "Enable the block layer" if EXPERT
         default y
++<<<<<<< HEAD
++=======
+        select SBITMAP
+        select SRCU
++>>>>>>> ef51042472f5 (block, dax: move "select DAX" from BLOCK to FS_DAX)
         help
  	 Provide block layer support for the kernel.
  
diff --cc fs/Kconfig
index a93dc61a1371,b0e42b6a96b9..000000000000
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@@ -40,6 -38,8 +40,11 @@@ config FS_DA
  	bool "Direct Access (DAX) support"
  	depends on MMU
  	depends on !(ARM || MIPS || SPARC)
++<<<<<<< HEAD
++=======
+ 	select FS_IOMAP
+ 	select DAX
++>>>>>>> ef51042472f5 (block, dax: move "select DAX" from BLOCK to FS_DAX)
  	help
  	  Direct Access (DAX) can be used on memory-backed block devices.
  	  If the block device supports DAX and the filesystem supports DAX,
diff --cc fs/block_dev.c
index a9db5f6ddc3f,3096ecd48304..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -529,59 -718,6 +529,62 @@@ int bdev_write_page(struct block_devic
  }
  EXPORT_SYMBOL_GPL(bdev_write_page);
  
++<<<<<<< HEAD
 +/**
 + * bdev_dax_supported() - Check if the device supports dax for filesystem
 + * @sb: The superblock of the device
 + * @blocksize: The block size of the device
 + *
 + * This is a library function for filesystems to check if the block device
 + * can be mounted with dax option.
 + *
 + * Return: negative errno if unsupported, 0 if supported.
 + */
 +int bdev_dax_supported(struct super_block *sb, int blocksize)
 +{
 +	struct block_device *bdev = sb->s_bdev;
 +	struct dax_device *dax_dev;
 +	pgoff_t pgoff;
 +	int err, id;
 +	void *kaddr;
 +	pfn_t pfn;
 +	long len;
 +
 +	if (blocksize != PAGE_SIZE) {
 +		vfs_msg(sb, KERN_ERR, "error: unsupported blocksize for dax");
 +		return -EINVAL;
 +	}
 +
 +	err = bdev_dax_pgoff(bdev, 0, PAGE_SIZE, &pgoff);
 +	if (err) {
 +		vfs_msg(sb, KERN_ERR, "error: unaligned partition for dax");
 +		return err;
 +	}
 +
 +	dax_dev = dax_get_by_host(bdev->bd_disk->disk_name);
 +	if (!dax_dev) {
 +		vfs_msg(sb, KERN_ERR, "error: device does not support dax");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	id = dax_read_lock();
 +	len = dax_direct_access(dax_dev, pgoff, 1, &kaddr, &pfn);
 +	dax_read_unlock(id);
 +
 +	put_dax(dax_dev);
 +
 +	if (len < 1) {
 +		vfs_msg(sb, KERN_ERR,
 +				"error: dax access failed (%ld)", len);
 +		return len < 0 ? len : -EIO;
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(bdev_dax_supported);
 +
++=======
++>>>>>>> ef51042472f5 (block, dax: move "select DAX" from BLOCK to FS_DAX)
  /*
   * pseudo-fs
   */
diff --cc fs/ext2/super.c
index 241c03defc77,d07773b81da9..000000000000
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@@ -31,7 -31,8 +31,12 @@@
  #include <linux/mount.h>
  #include <linux/log2.h>
  #include <linux/quotaops.h>
++<<<<<<< HEAD
 +#include <asm/uaccess.h>
++=======
+ #include <linux/uaccess.h>
+ #include <linux/dax.h>
++>>>>>>> ef51042472f5 (block, dax: move "select DAX" from BLOCK to FS_DAX)
  #include "ext2.h"
  #include "xattr.h"
  #include "acl.h"
diff --cc include/linux/blkdev.h
index 2d7fe01dd7d2,e4d9899755a7..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -1832,9 -1940,10 +1832,12 @@@ extern int __blkdev_driver_ioctl(struc
  extern int bdev_read_page(struct block_device *, sector_t, struct page *);
  extern int bdev_write_page(struct block_device *, sector_t, struct page *,
  						struct writeback_control *);
++<<<<<<< HEAD
 +extern long bdev_direct_access(struct block_device *, struct blk_dax_ctl *);
 +extern int bdev_dax_supported(struct super_block *, int);
++=======
++>>>>>>> ef51042472f5 (block, dax: move "select DAX" from BLOCK to FS_DAX)
  #else /* CONFIG_BLOCK */
 -
 -struct block_device;
 -
  /*
   * stubs for when the block layer is configured out
   */
diff --cc include/linux/dax.h
index 8937c7aed5cb,7fdf1d710042..000000000000
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@@ -6,29 -6,92 +6,82 @@@
  #include <linux/radix-tree.h>
  #include <asm/pgtable.h>
  
++<<<<<<< HEAD
++=======
+ struct iomap_ops;
+ struct dax_device;
+ struct dax_operations {
+ 	/*
+ 	 * direct_access: translate a device-relative
+ 	 * logical-page-offset into an absolute physical pfn. Return the
+ 	 * number of pages available for DAX at that pfn.
+ 	 */
+ 	long (*direct_access)(struct dax_device *, pgoff_t, long,
+ 			void **, pfn_t *);
+ };
+ 
+ int bdev_dax_pgoff(struct block_device *, sector_t, size_t, pgoff_t *pgoff);
+ #if IS_ENABLED(CONFIG_FS_DAX)
+ int __bdev_dax_supported(struct super_block *sb, int blocksize);
+ static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
+ {
+ 	return __bdev_dax_supported(sb, blocksize);
+ }
+ #else
+ static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_DAX)
+ struct dax_device *dax_get_by_host(const char *host);
+ void put_dax(struct dax_device *dax_dev);
+ #else
+ static inline struct dax_device *dax_get_by_host(const char *host)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void put_dax(struct dax_device *dax_dev)
+ {
+ }
+ #endif
+ 
+ int dax_read_lock(void);
+ void dax_read_unlock(int id);
+ struct dax_device *alloc_dax(void *private, const char *host,
+ 		const struct dax_operations *ops);
+ bool dax_alive(struct dax_device *dax_dev);
+ void kill_dax(struct dax_device *dax_dev);
+ void *dax_get_private(struct dax_device *dax_dev);
+ long dax_direct_access(struct dax_device *dax_dev, pgoff_t pgoff, long nr_pages,
+ 		void **kaddr, pfn_t *pfn);
+ 
++>>>>>>> ef51042472f5 (block, dax: move "select DAX" from BLOCK to FS_DAX)
  /*
 - * We use lowest available bit in exceptional entry for locking, one bit for
 - * the entry size (PMD) and two more to tell us if the entry is a huge zero
 - * page (HZP) or an empty entry that is just used for locking.  In total four
 - * special bits.
 - *
 - * If the PMD bit isn't set the entry has size PAGE_SIZE, and if the HZP and
 - * EMPTY bits aren't set the entry is a normal DAX entry with a filesystem
 - * block allocation.
 + * We use lowest available bit in exceptional entry for locking, other two
 + * bits to determine entry type. In total 3 special bits.
   */
 -#define RADIX_DAX_SHIFT	(RADIX_TREE_EXCEPTIONAL_SHIFT + 4)
 +#define RADIX_DAX_SHIFT	(RADIX_TREE_EXCEPTIONAL_SHIFT + 3)
  #define RADIX_DAX_ENTRY_LOCK (1 << RADIX_TREE_EXCEPTIONAL_SHIFT)
 -#define RADIX_DAX_PMD (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 1))
 -#define RADIX_DAX_HZP (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 2))
 -#define RADIX_DAX_EMPTY (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 3))
 +#define RADIX_DAX_PTE (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 1))
 +#define RADIX_DAX_PMD (1 << (RADIX_TREE_EXCEPTIONAL_SHIFT + 2))
 +#define RADIX_DAX_TYPE_MASK (RADIX_DAX_PTE | RADIX_DAX_PMD)
 +#define RADIX_DAX_TYPE(entry) ((unsigned long)entry & RADIX_DAX_TYPE_MASK)
 +#define RADIX_DAX_SECTOR(entry) (((unsigned long)entry >> RADIX_DAX_SHIFT))
 +#define RADIX_DAX_ENTRY(sector, pmd) ((void *)((unsigned long)sector << \
 +		RADIX_DAX_SHIFT | (pmd ? RADIX_DAX_PMD : RADIX_DAX_PTE) | \
 +		RADIX_TREE_EXCEPTIONAL_ENTRY))
  
 -static inline unsigned long dax_radix_sector(void *entry)
 -{
 -	return (unsigned long)entry >> RADIX_DAX_SHIFT;
 -}
  
 -static inline void *dax_radix_locked_entry(sector_t sector, unsigned long flags)
 -{
 -	return (void *)(RADIX_TREE_EXCEPTIONAL_ENTRY | flags |
 -			((unsigned long)sector << RADIX_DAX_SHIFT) |
 -			RADIX_DAX_ENTRY_LOCK);
 -}
 -
 -ssize_t dax_iomap_rw(struct kiocb *iocb, struct iov_iter *iter,
 -		const struct iomap_ops *ops);
 -int dax_iomap_fault(struct vm_fault *vmf, enum page_entry_size pe_size,
 -		    const struct iomap_ops *ops);
 +ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,
 +                  const struct iovec *iov, loff_t pos, unsigned long nr_segs,
 +                  get_block_t get_block, dio_iodone_t end_io, int flags);
 +int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 +int dax_truncate_page(struct inode *, loff_t from, get_block_t);
 +int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
  int dax_delete_mapping_entry(struct address_space *mapping, pgoff_t index);
 -int dax_invalidate_mapping_entry(struct address_space *mapping, pgoff_t index);
 -int dax_invalidate_mapping_entry_sync(struct address_space *mapping,
 -				      pgoff_t index);
  void dax_wake_mapping_entry_waiter(struct address_space *mapping,
  		pgoff_t index, void *entry, bool wake_all);
  
* Unmerged path drivers/dax/super.c
* Unmerged path block/Kconfig
* Unmerged path drivers/dax/super.c
* Unmerged path fs/Kconfig
* Unmerged path fs/block_dev.c
* Unmerged path fs/ext2/super.c
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index d1a1c921911f..bd68fc01abae 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -38,6 +38,7 @@
 #include <linux/ctype.h>
 #include <linux/log2.h>
 #include <linux/crc16.h>
+#include <linux/dax.h>
 #include <linux/cleancache.h>
 #include <asm/uaccess.h>
 
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index d73f65c6138e..f6c5f42dd853 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -48,6 +48,7 @@
 #include "xfs_ondisk.h"
 
 #include <linux/namei.h>
+#include <linux/dax.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/mount.h>
* Unmerged path include/linux/blkdev.h
* Unmerged path include/linux/dax.h
