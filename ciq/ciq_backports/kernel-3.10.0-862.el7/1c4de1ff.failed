x86/mm/pti: Allow NX poison to be set in p4d/pgd

jira LE-1907
cve CVE-2017-5754
cve CVE-2017-5753
cve CVE-2017-5715
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mm/kaiser: allow NX poison to be set in p4d/pgd (Andrea Arcangeli) [1519801 1519798 1519786] {CVE-2017-5715 CVE-2017-5753 CVE-2017-5754}
Rebuild_FUZZ: 88.42%
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit 1c4de1ff4fe50453b968579ee86fac3da80dd783
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1c4de1ff.failed

With PAGE_TABLE_ISOLATION the user portion of the kernel page tables is
poisoned with the NX bit so if the entry code exits with the kernel page
tables selected in CR3, userspace crashes.

But doing so trips the p4d/pgd_bad() checks.  Make sure it does not do
that.

	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: David Laight <David.Laight@aculab.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Eduardo Valentin <eduval@amazon.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: aliguori@amazon.com
	Cc: daniel.gruss@iaik.tugraz.at
	Cc: hughd@google.com
	Cc: keescook@google.com
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1c4de1ff4fe50453b968579ee86fac3da80dd783)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/pgtable.h
diff --cc arch/x86/include/asm/pgtable.h
index ec9e20b59d06,2d2d07300b4a..000000000000
--- a/arch/x86/include/asm/pgtable.h
+++ b/arch/x86/include/asm/pgtable.h
@@@ -645,9 -809,58 +645,62 @@@ static inline int pud_large(pud_t pud
  {
  	return 0;
  }
 -#endif	/* CONFIG_PGTABLE_LEVELS > 2 */
 +#endif	/* PAGETABLE_LEVELS > 2 */
  
++<<<<<<< HEAD
 +#if PAGETABLE_LEVELS > 3
++=======
+ static inline unsigned long pud_index(unsigned long address)
+ {
+ 	return (address >> PUD_SHIFT) & (PTRS_PER_PUD - 1);
+ }
+ 
+ #if CONFIG_PGTABLE_LEVELS > 3
+ static inline int p4d_none(p4d_t p4d)
+ {
+ 	return (native_p4d_val(p4d) & ~(_PAGE_KNL_ERRATUM_MASK)) == 0;
+ }
+ 
+ static inline int p4d_present(p4d_t p4d)
+ {
+ 	return p4d_flags(p4d) & _PAGE_PRESENT;
+ }
+ 
+ static inline unsigned long p4d_page_vaddr(p4d_t p4d)
+ {
+ 	return (unsigned long)__va(p4d_val(p4d) & p4d_pfn_mask(p4d));
+ }
+ 
+ /*
+  * Currently stuck as a macro due to indirect forward reference to
+  * linux/mmzone.h's __section_mem_map_addr() definition:
+  */
+ #define p4d_page(p4d)	pfn_to_page(p4d_pfn(p4d))
+ 
+ /* Find an entry in the third-level page table.. */
+ static inline pud_t *pud_offset(p4d_t *p4d, unsigned long address)
+ {
+ 	return (pud_t *)p4d_page_vaddr(*p4d) + pud_index(address);
+ }
+ 
+ static inline int p4d_bad(p4d_t p4d)
+ {
+ 	unsigned long ignore_flags = _KERNPG_TABLE | _PAGE_USER;
+ 
+ 	if (IS_ENABLED(CONFIG_PAGE_TABLE_ISOLATION))
+ 		ignore_flags |= _PAGE_NX;
+ 
+ 	return (p4d_flags(p4d) & ~ignore_flags) != 0;
+ }
+ #endif  /* CONFIG_PGTABLE_LEVELS > 3 */
+ 
+ static inline unsigned long p4d_index(unsigned long address)
+ {
+ 	return (address >> P4D_SHIFT) & (PTRS_PER_P4D - 1);
+ }
+ 
+ #if CONFIG_PGTABLE_LEVELS > 4
++>>>>>>> 1c4de1ff4fe5 (x86/mm/pti: Allow NX poison to be set in p4d/pgd)
  static inline int pgd_present(pgd_t pgd)
  {
  	return pgd_flags(pgd) & _PAGE_PRESENT;
* Unmerged path arch/x86/include/asm/pgtable.h
