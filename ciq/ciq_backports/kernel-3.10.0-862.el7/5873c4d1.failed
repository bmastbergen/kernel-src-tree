target: consolidate backend attribute implementations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] consolidate backend attribute implementations (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 91.84%
commit-author Christoph Hellwig <hch@lst.de>
commit 5873c4d157400ade4052e9d7b6259fa592e1ddbf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5873c4d1.failed

Provide a common sets of dev_attrib attributes for all devices using the
generic SPC/SBC parsers, and a second one with the minimal required read-only
attributes for passthrough devices.  The later is only used by pscsi for now,
but will be wired up for the full-passthrough TCMU use case as well.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 5873c4d157400ade4052e9d7b6259fa592e1ddbf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_file.c
#	drivers/target/target_core_iblock.c
#	drivers/target/target_core_pscsi.c
#	drivers/target/target_core_rd.c
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_file.c
index 909f66aed985,948b61f59a55..000000000000
--- a/drivers/target/target_core_file.c
+++ b/drivers/target/target_core_file.c
@@@ -979,42 -841,7 +978,46 @@@ fd_parse_cdb(struct se_cmd *cmd
  	return sbc_parse_cdb(cmd, &fd_sbc_ops);
  }
  
++<<<<<<< HEAD
 +DEF_TB_DEFAULT_ATTRIBS(fileio);
 +
 +static struct configfs_attribute *fileio_backend_dev_attrs[] = {
 +	&fileio_dev_attrib_emulate_model_alias.attr,
 +	&fileio_dev_attrib_emulate_dpo.attr,
 +	&fileio_dev_attrib_emulate_fua_write.attr,
 +	&fileio_dev_attrib_emulate_fua_read.attr,
 +	&fileio_dev_attrib_emulate_write_cache.attr,
 +	&fileio_dev_attrib_emulate_ua_intlck_ctrl.attr,
 +	&fileio_dev_attrib_emulate_tas.attr,
 +	&fileio_dev_attrib_emulate_tpu.attr,
 +	&fileio_dev_attrib_emulate_tpws.attr,
 +	&fileio_dev_attrib_emulate_caw.attr,
 +	&fileio_dev_attrib_emulate_3pc.attr,
 +	&fileio_dev_attrib_pi_prot_type.attr,
 +	&fileio_dev_attrib_hw_pi_prot_type.attr,
 +	&fileio_dev_attrib_pi_prot_format.attr,
 +	&fileio_dev_attrib_enforce_pr_isids.attr,
 +	&fileio_dev_attrib_is_nonrot.attr,
 +	&fileio_dev_attrib_emulate_rest_reord.attr,
 +	&fileio_dev_attrib_force_pr_aptpl.attr,
 +	&fileio_dev_attrib_hw_block_size.attr,
 +	&fileio_dev_attrib_block_size.attr,
 +	&fileio_dev_attrib_hw_max_sectors.attr,
 +	&fileio_dev_attrib_optimal_sectors.attr,
 +	&fileio_dev_attrib_hw_queue_depth.attr,
 +	&fileio_dev_attrib_queue_depth.attr,
 +	&fileio_dev_attrib_max_unmap_lba_count.attr,
 +	&fileio_dev_attrib_max_unmap_block_desc_count.attr,
 +	&fileio_dev_attrib_unmap_granularity.attr,
 +	&fileio_dev_attrib_unmap_granularity_alignment.attr,
 +	&fileio_dev_attrib_max_write_same_len.attr,
 +	NULL,
 +};
 +
 +static struct se_subsystem_api fileio_template = {
++=======
+ static const struct target_backend_ops fileio_ops = {
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  	.name			= "fileio",
  	.inquiry_prod		= "FILEIO",
  	.inquiry_rev		= FD_VERSION,
@@@ -1032,6 -859,7 +1035,10 @@@
  	.init_prot		= fd_init_prot,
  	.format_prot		= fd_format_prot,
  	.free_prot		= fd_free_prot,
++<<<<<<< HEAD
++=======
+ 	.tb_dev_attrib_attrs	= sbc_attrib_attrs,
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  };
  
  static int __init fileio_module_init(void)
diff --cc drivers/target/target_core_iblock.c
index 4ff1c8404aab,6d4738252564..000000000000
--- a/drivers/target/target_core_iblock.c
+++ b/drivers/target/target_core_iblock.c
@@@ -864,42 -857,7 +863,46 @@@ static bool iblock_get_write_cache(stru
  	return q->flush_flags & REQ_FLUSH;
  }
  
++<<<<<<< HEAD
 +DEF_TB_DEFAULT_ATTRIBS(iblock);
 +
 +static struct configfs_attribute *iblock_backend_dev_attrs[] = {
 +	&iblock_dev_attrib_emulate_model_alias.attr,
 +	&iblock_dev_attrib_emulate_dpo.attr,
 +	&iblock_dev_attrib_emulate_fua_write.attr,
 +	&iblock_dev_attrib_emulate_fua_read.attr,
 +	&iblock_dev_attrib_emulate_write_cache.attr,
 +	&iblock_dev_attrib_emulate_ua_intlck_ctrl.attr,
 +	&iblock_dev_attrib_emulate_tas.attr,
 +	&iblock_dev_attrib_emulate_tpu.attr,
 +	&iblock_dev_attrib_emulate_tpws.attr,
 +	&iblock_dev_attrib_emulate_caw.attr,
 +	&iblock_dev_attrib_emulate_3pc.attr,
 +	&iblock_dev_attrib_pi_prot_type.attr,
 +	&iblock_dev_attrib_hw_pi_prot_type.attr,
 +	&iblock_dev_attrib_pi_prot_format.attr,
 +	&iblock_dev_attrib_enforce_pr_isids.attr,
 +	&iblock_dev_attrib_is_nonrot.attr,
 +	&iblock_dev_attrib_emulate_rest_reord.attr,
 +	&iblock_dev_attrib_force_pr_aptpl.attr,
 +	&iblock_dev_attrib_hw_block_size.attr,
 +	&iblock_dev_attrib_block_size.attr,
 +	&iblock_dev_attrib_hw_max_sectors.attr,
 +	&iblock_dev_attrib_optimal_sectors.attr,
 +	&iblock_dev_attrib_hw_queue_depth.attr,
 +	&iblock_dev_attrib_queue_depth.attr,
 +	&iblock_dev_attrib_max_unmap_lba_count.attr,
 +	&iblock_dev_attrib_max_unmap_block_desc_count.attr,
 +	&iblock_dev_attrib_unmap_granularity.attr,
 +	&iblock_dev_attrib_unmap_granularity_alignment.attr,
 +	&iblock_dev_attrib_max_write_same_len.attr,
 +	NULL,
 +};
 +
 +static struct se_subsystem_api iblock_template = {
++=======
+ static const struct target_backend_ops iblock_ops = {
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  	.name			= "iblock",
  	.inquiry_prod		= "IBLOCK",
  	.inquiry_rev		= IBLOCK_VERSION,
@@@ -919,6 -877,7 +922,10 @@@
  	.get_io_min		= iblock_get_io_min,
  	.get_io_opt		= iblock_get_io_opt,
  	.get_write_cache	= iblock_get_write_cache,
++<<<<<<< HEAD
++=======
+ 	.tb_dev_attrib_attrs	= sbc_attrib_attrs,
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  };
  
  static int __init iblock_module_init(void)
diff --cc drivers/target/target_core_pscsi.c
index 59a8a2963c0e,afb87a8d5668..000000000000
--- a/drivers/target/target_core_pscsi.c
+++ b/drivers/target/target_core_pscsi.c
@@@ -44,9 -44,9 +44,8 @@@
  
  #include <target/target_core_base.h>
  #include <target/target_core_backend.h>
- #include <target/target_core_backend_configfs.h>
  
  #include "target_core_alua.h"
 -#include "target_core_internal.h"
  #include "target_core_pscsi.h"
  
  #define ISPRINT(a)  ((a >= ' ') && (a <= '~'))
@@@ -1169,31 -1118,10 +1168,35 @@@ static void pscsi_req_done(struct reque
  	kfree(pt);
  }
  
++<<<<<<< HEAD
 +DEF_TB_DEV_ATTRIB_RO(pscsi, hw_pi_prot_type);
 +TB_DEV_ATTR_RO(pscsi, hw_pi_prot_type);
 +
 +DEF_TB_DEV_ATTRIB_RO(pscsi, hw_block_size);
 +TB_DEV_ATTR_RO(pscsi, hw_block_size);
 +
 +DEF_TB_DEV_ATTRIB_RO(pscsi, hw_max_sectors);
 +TB_DEV_ATTR_RO(pscsi, hw_max_sectors);
 +
 +DEF_TB_DEV_ATTRIB_RO(pscsi, hw_queue_depth);
 +TB_DEV_ATTR_RO(pscsi, hw_queue_depth);
 +
 +static struct configfs_attribute *pscsi_backend_dev_attrs[] = {
 +	&pscsi_dev_attrib_hw_pi_prot_type.attr,
 +	&pscsi_dev_attrib_hw_block_size.attr,
 +	&pscsi_dev_attrib_hw_max_sectors.attr,
 +	&pscsi_dev_attrib_hw_queue_depth.attr,
 +	NULL,
 +};
 +
 +static struct se_subsystem_api pscsi_template = {
++=======
+ static const struct target_backend_ops pscsi_ops = {
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  	.name			= "pscsi",
  	.owner			= THIS_MODULE,
 -	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH,
 +	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH |
 +				  TRANSPORT_FLAG_PASSTHROUGH_ALUA,
  	.attach_hba		= pscsi_attach_hba,
  	.detach_hba		= pscsi_detach_hba,
  	.pmode_enable_hba	= pscsi_pmode_enable_hba,
@@@ -1206,6 -1134,7 +1209,10 @@@
  	.show_configfs_dev_params = pscsi_show_configfs_dev_params,
  	.get_device_type	= pscsi_get_device_type,
  	.get_blocks		= pscsi_get_blocks,
++<<<<<<< HEAD
++=======
+ 	.tb_dev_attrib_attrs	= passthrough_attrib_attrs,
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  };
  
  static int __init pscsi_module_init(void)
diff --cc drivers/target/target_core_rd.c
index 55315fd0f5d3,55dd73e7f213..000000000000
--- a/drivers/target/target_core_rd.c
+++ b/drivers/target/target_core_rd.c
@@@ -700,42 -695,7 +699,46 @@@ rd_parse_cdb(struct se_cmd *cmd
  	return sbc_parse_cdb(cmd, &rd_sbc_ops);
  }
  
++<<<<<<< HEAD
 +DEF_TB_DEFAULT_ATTRIBS(rd_mcp);
 +
 +static struct configfs_attribute *rd_mcp_backend_dev_attrs[] = {
 +	&rd_mcp_dev_attrib_emulate_model_alias.attr,
 +	&rd_mcp_dev_attrib_emulate_dpo.attr,
 +	&rd_mcp_dev_attrib_emulate_fua_write.attr,
 +	&rd_mcp_dev_attrib_emulate_fua_read.attr,
 +	&rd_mcp_dev_attrib_emulate_write_cache.attr,
 +	&rd_mcp_dev_attrib_emulate_ua_intlck_ctrl.attr,
 +	&rd_mcp_dev_attrib_emulate_tas.attr,
 +	&rd_mcp_dev_attrib_emulate_tpu.attr,
 +	&rd_mcp_dev_attrib_emulate_tpws.attr,
 +	&rd_mcp_dev_attrib_emulate_caw.attr,
 +	&rd_mcp_dev_attrib_emulate_3pc.attr,
 +	&rd_mcp_dev_attrib_pi_prot_type.attr,
 +	&rd_mcp_dev_attrib_hw_pi_prot_type.attr,
 +	&rd_mcp_dev_attrib_pi_prot_format.attr,
 +	&rd_mcp_dev_attrib_enforce_pr_isids.attr,
 +	&rd_mcp_dev_attrib_is_nonrot.attr,
 +	&rd_mcp_dev_attrib_emulate_rest_reord.attr,
 +	&rd_mcp_dev_attrib_force_pr_aptpl.attr,
 +	&rd_mcp_dev_attrib_hw_block_size.attr,
 +	&rd_mcp_dev_attrib_block_size.attr,
 +	&rd_mcp_dev_attrib_hw_max_sectors.attr,
 +	&rd_mcp_dev_attrib_optimal_sectors.attr,
 +	&rd_mcp_dev_attrib_hw_queue_depth.attr,
 +	&rd_mcp_dev_attrib_queue_depth.attr,
 +	&rd_mcp_dev_attrib_max_unmap_lba_count.attr,
 +	&rd_mcp_dev_attrib_max_unmap_block_desc_count.attr,
 +	&rd_mcp_dev_attrib_unmap_granularity.attr,
 +	&rd_mcp_dev_attrib_unmap_granularity_alignment.attr,
 +	&rd_mcp_dev_attrib_max_write_same_len.attr,
 +	NULL,
 +};
 +
 +static struct se_subsystem_api rd_mcp_template = {
++=======
+ static const struct target_backend_ops rd_mcp_ops = {
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  	.name			= "rd_mcp",
  	.inquiry_prod		= "RAMDISK-MCP",
  	.inquiry_rev		= RD_MCP_VERSION,
@@@ -751,6 -711,7 +754,10 @@@
  	.get_blocks		= rd_get_blocks,
  	.init_prot		= rd_init_prot,
  	.free_prot		= rd_free_prot,
++<<<<<<< HEAD
++=======
+ 	.tb_dev_attrib_attrs	= sbc_attrib_attrs,
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  };
  
  int __init rd_module_init(void)
diff --cc drivers/target/target_core_user.c
index 7dc2f05f8e5e,aebaad55e23f..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1360,127 -1078,26 +1359,131 @@@ static sector_t tcmu_get_blocks(struct 
  }
  
  static sense_reason_t
 -tcmu_pass_op(struct se_cmd *se_cmd)
 +tcmu_parse_cdb(struct se_cmd *cmd)
  {
 -	int ret = tcmu_queue_cmd(se_cmd);
 +	unsigned char *cdb = cmd->t_task_cdb;
  
 -	if (ret != 0)
 -		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 -	else
 +	/*
 +	 * Clear a lun set in the cdb if the initiator talking to use spoke
 +	 * and old standards version, as we can't assume the underlying device
 +	 * won't choke up on it.
 +	 */
 +	switch (cdb[0]) {
 +	case READ_10: /* SBC - RDProtect */
 +	case READ_12: /* SBC - RDProtect */
 +	case READ_16: /* SBC - RDProtect */
 +	case SEND_DIAGNOSTIC: /* SPC - SELF-TEST Code */
 +	case VERIFY: /* SBC - VRProtect */
 +	case VERIFY_16: /* SBC - VRProtect */
 +	case WRITE_VERIFY: /* SBC - VRProtect */
 +	case WRITE_VERIFY_12: /* SBC - VRProtect */
 +	case MAINTENANCE_IN: /* SPC - Parameter Data Format for SA RTPG */
 +		break;
 +	default:
 +		cdb[1] &= 0x1f; /* clear logical unit number */
 +		break;
 +	}
 +
 +	/*
 +	 * For REPORT LUNS we always need to emulate the response, for everything
 +	 * else, pass it up.
 +	 */
 +	if (cdb[0] == REPORT_LUNS) {
 +		cmd->execute_cmd = spc_emulate_report_luns;
  		return TCM_NO_SENSE;
 +	}
 +
 +	/* Set DATA_CDB flag for ops that should have it */
 +	switch (cdb[0]) {
 +	case READ_6:
 +	case READ_10:
 +	case READ_12:
 +	case READ_16:
 +	case WRITE_6:
 +	case WRITE_10:
 +	case WRITE_12:
 +	case WRITE_16:
 +	case WRITE_VERIFY:
 +	case WRITE_VERIFY_12:
 +	case 0x8e: /* WRITE_VERIFY_16 */
 +	case COMPARE_AND_WRITE:
 +	case XDWRITEREAD_10:
 +		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
 +		break;
 +	case VARIABLE_LENGTH_CMD:
 +		switch (get_unaligned_be16(&cdb[8])) {
 +		case READ_32:
 +		case WRITE_32:
 +		case 0x0c: /* WRITE_VERIFY_32 */
 +		case XDWRITEREAD_32:
 +			cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
 +			break;
 +		}
 +	}
 +
 +	cmd->execute_cmd = tcmu_queue_cmd;
 +
 +	return TCM_NO_SENSE;
  }
  
 -static sense_reason_t
 -tcmu_parse_cdb(struct se_cmd *cmd)
++<<<<<<< HEAD
 +static ssize_t tcmu_dev_show_attr_cmd_time_out(struct se_dev_attrib *da,
 +					       char *page)
  {
 -	return passthrough_parse_cdb(cmd, tcmu_pass_op);
 +	struct tcmu_dev *udev = container_of(da->da_dev,
 +					struct tcmu_dev, se_dev);
 +
 +	return snprintf(page, PAGE_SIZE, "%lu\n", udev->cmd_time_out / MSEC_PER_SEC);
 +}
 +
 +static ssize_t tcmu_dev_store_attr_cmd_time_out(struct se_dev_attrib *da,
 +						const char *page, size_t count)
 +{
 +	struct tcmu_dev *udev = container_of(da->da_dev,
 +					struct tcmu_dev, se_dev);
 +	u32 val;
 +	int ret;
 +
 +	if (da->da_dev->export_count) {
 +		pr_err("Unable to set tcmu cmd_time_out while exports exist\n");
 +		return -EINVAL;
 +	}
 +
 +	ret = kstrtou32(page, 0, &val);
 +	if (ret < 0)
 +		return ret;
 +
 +	udev->cmd_time_out = val * MSEC_PER_SEC;
 +	return count;
  }
 +TB_DEV_ATTR(tcmu, cmd_time_out, S_IRUGO | S_IWUSR);
 +
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_pi_prot_type);
 +TB_DEV_ATTR_RO(tcmu, hw_pi_prot_type);
  
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_block_size);
 +TB_DEV_ATTR_RO(tcmu, hw_block_size);
 +
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_max_sectors);
 +TB_DEV_ATTR_RO(tcmu, hw_max_sectors);
 +
 +DEF_TB_DEV_ATTRIB_RO(tcmu, hw_queue_depth);
 +TB_DEV_ATTR_RO(tcmu, hw_queue_depth);
 +
 +static struct configfs_attribute *tcmu_backend_dev_attrs[] = {
 +	&tcmu_dev_attrib_hw_pi_prot_type.attr,
 +	&tcmu_dev_attrib_hw_block_size.attr,
 +	&tcmu_dev_attrib_hw_max_sectors.attr,
 +	&tcmu_dev_attrib_hw_queue_depth.attr,
 +	&tcmu_dev_attrib_cmd_time_out.attr,
 +	NULL,
 +};
 +
 +static struct se_subsystem_api tcmu_template = {
++=======
+ static const struct target_backend_ops tcmu_ops = {
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  	.name			= "user",
 -	.inquiry_prod		= "USER",
 -	.inquiry_rev		= TCMU_VERSION,
  	.owner			= THIS_MODULE,
  	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH,
  	.attach_hba		= tcmu_attach_hba,
@@@ -1494,6 -1110,7 +1497,10 @@@
  	.show_configfs_dev_params = tcmu_show_configfs_dev_params,
  	.get_device_type	= sbc_get_device_type,
  	.get_blocks		= tcmu_get_blocks,
++<<<<<<< HEAD
++=======
+ 	.tb_dev_attrib_attrs	= passthrough_attrib_attrs,
++>>>>>>> 5873c4d15740 (target: consolidate backend attribute implementations)
  };
  
  static int __init tcmu_module_init(void)
diff --git a/drivers/target/target_core_configfs.c b/drivers/target/target_core_configfs.c
index 5a4ad5ca14f6..e1a5b5d2dad7 100644
--- a/drivers/target/target_core_configfs.c
+++ b/drivers/target/target_core_configfs.c
@@ -585,10 +585,179 @@ EXPORT_SYMBOL(target_fabric_configfs_deregister);
 //############################################################################*/
 
 /* Start functions for struct config_item_type tb_dev_attrib_cit */
+#define DEF_TB_DEV_ATTRIB_SHOW(_backend, _name)				\
+static ssize_t _backend##_dev_show_attr_##_name(			\
+	struct se_dev_attrib *da,					\
+	char *page)							\
+{									\
+	return snprintf(page, PAGE_SIZE, "%u\n",			\
+			(u32)da->da_dev->dev_attrib._name);		\
+}
+
+#define DEF_TB_DEV_ATTRIB_STORE(_backend, _name)			\
+static ssize_t _backend##_dev_store_attr_##_name(			\
+	struct se_dev_attrib *da,					\
+	const char *page,						\
+	size_t count)							\
+{									\
+	unsigned long val;						\
+	int ret;							\
+									\
+	ret = kstrtoul(page, 0, &val);					\
+	if (ret < 0) {							\
+		pr_err("kstrtoul() failed with ret: %d\n", ret);	\
+		return -EINVAL;						\
+	}								\
+	ret = se_dev_set_##_name(da->da_dev, (u32)val);			\
+									\
+	return (!ret) ? count : -EINVAL;				\
+}
+
+#define DEF_TB_DEV_ATTRIB(_backend, _name)				\
+DEF_TB_DEV_ATTRIB_SHOW(_backend, _name);				\
+DEF_TB_DEV_ATTRIB_STORE(_backend, _name);
+
+#define DEF_TB_DEV_ATTRIB_RO(_backend, name)				\
+DEF_TB_DEV_ATTRIB_SHOW(_backend, name);
+
+CONFIGFS_EATTR_STRUCT(target_backend_dev_attrib, se_dev_attrib);
+#define TB_DEV_ATTR(_backend, _name, _mode)				\
+static struct target_backend_dev_attrib_attribute _backend##_dev_attrib_##_name = \
+		__CONFIGFS_EATTR(_name, _mode,				\
+		_backend##_dev_show_attr_##_name,			\
+		_backend##_dev_store_attr_##_name);
+
+#define TB_DEV_ATTR_RO(_backend, _name)						\
+static struct target_backend_dev_attrib_attribute _backend##_dev_attrib_##_name = \
+	__CONFIGFS_EATTR_RO(_name,					\
+	_backend##_dev_show_attr_##_name);
+
+DEF_TB_DEV_ATTRIB(target_core, emulate_model_alias);
+DEF_TB_DEV_ATTRIB(target_core, emulate_dpo);
+DEF_TB_DEV_ATTRIB(target_core, emulate_fua_write);
+DEF_TB_DEV_ATTRIB(target_core, emulate_fua_read);
+DEF_TB_DEV_ATTRIB(target_core, emulate_write_cache);
+DEF_TB_DEV_ATTRIB(target_core, emulate_ua_intlck_ctrl);
+DEF_TB_DEV_ATTRIB(target_core, emulate_tas);
+DEF_TB_DEV_ATTRIB(target_core, emulate_tpu);
+DEF_TB_DEV_ATTRIB(target_core, emulate_tpws);
+DEF_TB_DEV_ATTRIB(target_core, emulate_caw);
+DEF_TB_DEV_ATTRIB(target_core, emulate_3pc);
+DEF_TB_DEV_ATTRIB(target_core, pi_prot_type);
+DEF_TB_DEV_ATTRIB_RO(target_core, hw_pi_prot_type);
+DEF_TB_DEV_ATTRIB(target_core, pi_prot_format);
+DEF_TB_DEV_ATTRIB(target_core, enforce_pr_isids);
+DEF_TB_DEV_ATTRIB(target_core, is_nonrot);
+DEF_TB_DEV_ATTRIB(target_core, emulate_rest_reord);
+DEF_TB_DEV_ATTRIB(target_core, force_pr_aptpl);
+DEF_TB_DEV_ATTRIB_RO(target_core, hw_block_size);
+DEF_TB_DEV_ATTRIB(target_core, block_size);
+DEF_TB_DEV_ATTRIB_RO(target_core, hw_max_sectors);
+DEF_TB_DEV_ATTRIB(target_core, optimal_sectors);
+DEF_TB_DEV_ATTRIB_RO(target_core, hw_queue_depth);
+DEF_TB_DEV_ATTRIB(target_core, queue_depth);
+DEF_TB_DEV_ATTRIB(target_core, max_unmap_lba_count);
+DEF_TB_DEV_ATTRIB(target_core, max_unmap_block_desc_count);
+DEF_TB_DEV_ATTRIB(target_core, unmap_granularity);
+DEF_TB_DEV_ATTRIB(target_core, unmap_granularity_alignment);
+DEF_TB_DEV_ATTRIB(target_core, max_write_same_len);
+
+TB_DEV_ATTR(target_core, emulate_model_alias, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_dpo, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_fua_write, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_fua_read, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_write_cache, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_ua_intlck_ctrl, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_tas, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_tpu, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_tpws, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_caw, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_3pc, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, pi_prot_type, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR_RO(target_core, hw_pi_prot_type);
+TB_DEV_ATTR(target_core, pi_prot_format, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, enforce_pr_isids, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, is_nonrot, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, emulate_rest_reord, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, force_pr_aptpl, S_IRUGO | S_IWUSR)
+TB_DEV_ATTR_RO(target_core, hw_block_size);
+TB_DEV_ATTR(target_core, block_size, S_IRUGO | S_IWUSR)
+TB_DEV_ATTR_RO(target_core, hw_max_sectors);
+TB_DEV_ATTR(target_core, optimal_sectors, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR_RO(target_core, hw_queue_depth);
+TB_DEV_ATTR(target_core, queue_depth, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, max_unmap_lba_count, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, max_unmap_block_desc_count, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, unmap_granularity, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, unmap_granularity_alignment, S_IRUGO | S_IWUSR);
+TB_DEV_ATTR(target_core, max_write_same_len, S_IRUGO | S_IWUSR);
 
 CONFIGFS_EATTR_STRUCT(target_core_dev_attrib, se_dev_attrib);
 CONFIGFS_EATTR_OPS(target_core_dev_attrib, se_dev_attrib, da_group);
 
+/*
+ * dev_attrib attributes for devices using the target core SBC/SPC
+ * interpreter.  Any backend using spc_parse_cdb should be using
+ * these.
+ */
+struct configfs_attribute *sbc_attrib_attrs[] = {
+	&target_core_dev_attrib_emulate_model_alias.attr,
+	&target_core_dev_attrib_emulate_dpo.attr,
+	&target_core_dev_attrib_emulate_fua_write.attr,
+	&target_core_dev_attrib_emulate_fua_read.attr,
+	&target_core_dev_attrib_emulate_write_cache.attr,
+	&target_core_dev_attrib_emulate_ua_intlck_ctrl.attr,
+	&target_core_dev_attrib_emulate_tas.attr,
+	&target_core_dev_attrib_emulate_tpu.attr,
+	&target_core_dev_attrib_emulate_tpws.attr,
+	&target_core_dev_attrib_emulate_caw.attr,
+	&target_core_dev_attrib_emulate_3pc.attr,
+	&target_core_dev_attrib_pi_prot_type.attr,
+	&target_core_dev_attrib_hw_pi_prot_type.attr,
+	&target_core_dev_attrib_pi_prot_format.attr,
+	&target_core_dev_attrib_enforce_pr_isids.attr,
+	&target_core_dev_attrib_is_nonrot.attr,
+	&target_core_dev_attrib_emulate_rest_reord.attr,
+	&target_core_dev_attrib_force_pr_aptpl.attr,
+	&target_core_dev_attrib_hw_block_size.attr,
+	&target_core_dev_attrib_block_size.attr,
+	&target_core_dev_attrib_hw_max_sectors.attr,
+	&target_core_dev_attrib_optimal_sectors.attr,
+	&target_core_dev_attrib_hw_queue_depth.attr,
+	&target_core_dev_attrib_queue_depth.attr,
+	&target_core_dev_attrib_max_unmap_lba_count.attr,
+	&target_core_dev_attrib_max_unmap_block_desc_count.attr,
+	&target_core_dev_attrib_unmap_granularity.attr,
+	&target_core_dev_attrib_unmap_granularity_alignment.attr,
+	&target_core_dev_attrib_max_write_same_len.attr,
+	NULL,
+};
+EXPORT_SYMBOL(sbc_attrib_attrs);
+
+DEF_TB_DEV_ATTRIB_RO(target_pt, hw_pi_prot_type);
+DEF_TB_DEV_ATTRIB_RO(target_pt, hw_block_size);
+DEF_TB_DEV_ATTRIB_RO(target_pt, hw_max_sectors);
+DEF_TB_DEV_ATTRIB_RO(target_pt, hw_queue_depth);
+
+TB_DEV_ATTR_RO(target_pt, hw_pi_prot_type);
+TB_DEV_ATTR_RO(target_pt, hw_block_size);
+TB_DEV_ATTR_RO(target_pt, hw_max_sectors);
+TB_DEV_ATTR_RO(target_pt, hw_queue_depth);
+
+/*
+ * Minimal dev_attrib attributes for devices passing through CDBs.
+ * In this case we only provide a few read-only attributes for
+ * backwards compatibility.
+ */
+struct configfs_attribute *passthrough_attrib_attrs[] = {
+	&target_pt_dev_attrib_hw_pi_prot_type.attr,
+	&target_pt_dev_attrib_hw_block_size.attr,
+	&target_pt_dev_attrib_hw_max_sectors.attr,
+	&target_pt_dev_attrib_hw_queue_depth.attr,
+	NULL,
+};
+EXPORT_SYMBOL(passthrough_attrib_attrs);
+
 static struct configfs_item_operations target_core_dev_attrib_ops = {
 	.show_attribute		= target_core_dev_attrib_attr_show,
 	.store_attribute	= target_core_dev_attrib_attr_store,
* Unmerged path drivers/target/target_core_file.c
* Unmerged path drivers/target/target_core_iblock.c
* Unmerged path drivers/target/target_core_pscsi.c
* Unmerged path drivers/target/target_core_rd.c
* Unmerged path drivers/target/target_core_user.c
diff --git a/include/target/target_core_backend.h b/include/target/target_core_backend.h
index b898a92cae3d..901a0771453f 100644
--- a/include/target/target_core_backend.h
+++ b/include/target/target_core_backend.h
@@ -101,6 +101,9 @@ int	transport_set_vpd_assoc(struct t10_vpd *, unsigned char *);
 int	transport_set_vpd_ident_type(struct t10_vpd *, unsigned char *);
 int	transport_set_vpd_ident(struct t10_vpd *, unsigned char *);
 
+extern struct configfs_attribute *sbc_attrib_attrs[];
+extern struct configfs_attribute *passthrough_attrib_attrs[];
+
 /* core helpers also used by command snooping in pscsi */
 void	*transport_kmap_data_sg(struct se_cmd *);
 void	transport_kunmap_data_sg(struct se_cmd *);
diff --git a/include/target/target_core_backend_configfs.h b/include/target/target_core_backend_configfs.h
deleted file mode 100644
index 186f7a923570..000000000000
--- a/include/target/target_core_backend_configfs.h
+++ /dev/null
@@ -1,118 +0,0 @@
-#ifndef TARGET_CORE_BACKEND_CONFIGFS_H
-#define TARGET_CORE_BACKEND_CONFIGFS_H
-
-#include <target/configfs_macros.h>
-
-#define DEF_TB_DEV_ATTRIB_SHOW(_backend, _name)				\
-static ssize_t _backend##_dev_show_attr_##_name(			\
-	struct se_dev_attrib *da,					\
-	char *page)							\
-{									\
-	return snprintf(page, PAGE_SIZE, "%u\n",			\
-			(u32)da->da_dev->dev_attrib._name);		\
-}
-
-#define DEF_TB_DEV_ATTRIB_STORE(_backend, _name)			\
-static ssize_t _backend##_dev_store_attr_##_name(			\
-	struct se_dev_attrib *da,					\
-	const char *page,						\
-	size_t count)							\
-{									\
-	unsigned long val;						\
-	int ret;							\
-									\
-	ret = kstrtoul(page, 0, &val);					\
-	if (ret < 0) {							\
-		pr_err("kstrtoul() failed with ret: %d\n", ret);	\
-		return -EINVAL;						\
-	}								\
-	ret = se_dev_set_##_name(da->da_dev, (u32)val);			\
-									\
-	return (!ret) ? count : -EINVAL;				\
-}
-
-#define DEF_TB_DEV_ATTRIB(_backend, _name)				\
-DEF_TB_DEV_ATTRIB_SHOW(_backend, _name);				\
-DEF_TB_DEV_ATTRIB_STORE(_backend, _name);
-
-#define DEF_TB_DEV_ATTRIB_RO(_backend, name)				\
-DEF_TB_DEV_ATTRIB_SHOW(_backend, name);
-
-CONFIGFS_EATTR_STRUCT(target_backend_dev_attrib, se_dev_attrib);
-#define TB_DEV_ATTR(_backend, _name, _mode)				\
-static struct target_backend_dev_attrib_attribute _backend##_dev_attrib_##_name = \
-		__CONFIGFS_EATTR(_name, _mode,				\
-		_backend##_dev_show_attr_##_name,			\
-		_backend##_dev_store_attr_##_name);
-
-#define TB_DEV_ATTR_RO(_backend, _name)						\
-static struct target_backend_dev_attrib_attribute _backend##_dev_attrib_##_name = \
-	__CONFIGFS_EATTR_RO(_name,					\
-	_backend##_dev_show_attr_##_name);
-
-/*
- * Default list of target backend device attributes as defined by
- * struct se_dev_attrib
- */
-
-#define DEF_TB_DEFAULT_ATTRIBS(_backend)				\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_model_alias);		\
-	TB_DEV_ATTR(_backend, emulate_model_alias, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_dpo);			\
-	TB_DEV_ATTR(_backend, emulate_dpo, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_fua_write);			\
-	TB_DEV_ATTR(_backend, emulate_fua_write, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_fua_read);			\
-	TB_DEV_ATTR(_backend, emulate_fua_read, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_write_cache);		\
-	TB_DEV_ATTR(_backend, emulate_write_cache, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_ua_intlck_ctrl);		\
-	TB_DEV_ATTR(_backend, emulate_ua_intlck_ctrl, S_IRUGO | S_IWUSR); \
-	DEF_TB_DEV_ATTRIB(_backend, emulate_tas);			\
-	TB_DEV_ATTR(_backend, emulate_tas, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_tpu);			\
-	TB_DEV_ATTR(_backend, emulate_tpu, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_tpws);			\
-	TB_DEV_ATTR(_backend, emulate_tpws, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_caw);			\
-	TB_DEV_ATTR(_backend, emulate_caw, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_3pc);			\
-	TB_DEV_ATTR(_backend, emulate_3pc, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, pi_prot_type);			\
-	TB_DEV_ATTR(_backend, pi_prot_type, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB_RO(_backend, hw_pi_prot_type);		\
-	TB_DEV_ATTR_RO(_backend, hw_pi_prot_type);			\
-	DEF_TB_DEV_ATTRIB(_backend, pi_prot_format);			\
-	TB_DEV_ATTR(_backend, pi_prot_format, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, enforce_pr_isids);			\
-	TB_DEV_ATTR(_backend, enforce_pr_isids, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, is_nonrot);				\
-	TB_DEV_ATTR(_backend, is_nonrot, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, emulate_rest_reord);		\
-	TB_DEV_ATTR(_backend, emulate_rest_reord, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, force_pr_aptpl);			\
-	TB_DEV_ATTR(_backend, force_pr_aptpl, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB_RO(_backend, hw_block_size);			\
-	TB_DEV_ATTR_RO(_backend, hw_block_size);			\
-	DEF_TB_DEV_ATTRIB(_backend, block_size);			\
-	TB_DEV_ATTR(_backend, block_size, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB_RO(_backend, hw_max_sectors);			\
-	TB_DEV_ATTR_RO(_backend, hw_max_sectors);			\
-	DEF_TB_DEV_ATTRIB(_backend, optimal_sectors);			\
-	TB_DEV_ATTR(_backend, optimal_sectors, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB_RO(_backend, hw_queue_depth);			\
-	TB_DEV_ATTR_RO(_backend, hw_queue_depth);			\
-	DEF_TB_DEV_ATTRIB(_backend, queue_depth);			\
-	TB_DEV_ATTR(_backend, queue_depth, S_IRUGO | S_IWUSR);		\
-	DEF_TB_DEV_ATTRIB(_backend, max_unmap_lba_count);		\
-	TB_DEV_ATTR(_backend, max_unmap_lba_count, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, max_unmap_block_desc_count);	\
-	TB_DEV_ATTR(_backend, max_unmap_block_desc_count, S_IRUGO | S_IWUSR); \
-	DEF_TB_DEV_ATTRIB(_backend, unmap_granularity);			\
-	TB_DEV_ATTR(_backend, unmap_granularity, S_IRUGO | S_IWUSR);	\
-	DEF_TB_DEV_ATTRIB(_backend, unmap_granularity_alignment);	\
-	TB_DEV_ATTR(_backend, unmap_granularity_alignment, S_IRUGO | S_IWUSR); \
-	DEF_TB_DEV_ATTRIB(_backend, max_write_same_len);		\
-	TB_DEV_ATTR(_backend, max_write_same_len, S_IRUGO | S_IWUSR);
-
-#endif /* TARGET_CORE_BACKEND_CONFIGFS_H */
