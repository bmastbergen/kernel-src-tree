net/mlx5: Replace fs_node mutex with reader/writer semaphore

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Replace fs_node mutex with reader/writer semaphore (Kamal Heib) [1456687 1456694]
Rebuild_FUZZ: 96.55%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit c7784b1c8ab3f44dc2e643a8feb77584792c9108
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c7784b1c.failed

Currently, steering object is protected by mutex lock, replace
the mutex lock with reader/writer semaphore .
In this patch we still use only write semaphore. In downstream
patches we will switch part of the write locks to read locks.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit c7784b1c8ab3f44dc2e643a8feb77584792c9108)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index f60baa93f1dc,9406e7272807..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -143,12 -145,29 +143,12 @@@ static struct init_tree_node 
  	}
  };
  
- enum fs_i_mutex_lock_class {
- 	FS_MUTEX_GRANDPARENT,
- 	FS_MUTEX_PARENT,
- 	FS_MUTEX_CHILD
+ enum fs_i_lock_class {
+ 	FS_LOCK_GRANDPARENT,
+ 	FS_LOCK_PARENT,
+ 	FS_LOCK_CHILD
  };
  
 -static const struct rhashtable_params rhash_fte = {
 -	.key_len = FIELD_SIZEOF(struct fs_fte, val),
 -	.key_offset = offsetof(struct fs_fte, val),
 -	.head_offset = offsetof(struct fs_fte, hash),
 -	.automatic_shrinking = true,
 -	.min_size = 1,
 -};
 -
 -static const struct rhashtable_params rhash_fg = {
 -	.key_len = FIELD_SIZEOF(struct mlx5_flow_group, mask),
 -	.key_offset = offsetof(struct mlx5_flow_group, mask),
 -	.head_offset = offsetof(struct mlx5_flow_group, hash),
 -	.automatic_shrinking = true,
 -	.min_size = 1,
 -
 -};
 -
  static void del_rule(struct fs_node *node);
  static void del_flow_table(struct fs_node *node);
  static void del_flow_group(struct fs_node *node);
@@@ -160,14 -179,14 +160,14 @@@ find_flow_rule(struct fs_fte *fte
  	       struct mlx5_flow_destination *dest);
  
  static void tree_init_node(struct fs_node *node,
 +			   unsigned int refcount,
  			   void (*remove_func)(struct fs_node *))
  {
 -	atomic_set(&node->refcount, 1);
 +	atomic_set(&node->refcount, refcount);
  	INIT_LIST_HEAD(&node->list);
  	INIT_LIST_HEAD(&node->children);
- 	mutex_init(&node->lock);
+ 	init_rwsem(&node->lock);
  	node->remove_func = remove_func;
 -	node->active = false;
  }
  
  static void tree_add_node(struct fs_node *node, struct fs_node *parent)
@@@ -1237,51 -1370,37 +1237,71 @@@ static struct mlx5_flow_handle *add_rul
  {
  	struct mlx5_flow_handle *handle;
  	struct mlx5_flow_table *ft;
 +	struct list_head *prev;
 +	struct fs_fte *fte;
  	int i;
  
++<<<<<<< HEAD
 +	nested_lock_ref_node(&fg->node, FS_MUTEX_PARENT);
 +	fs_for_each_fte(fte, fg) {
 +		nested_lock_ref_node(&fte->node, FS_MUTEX_CHILD);
 +		if (compare_match_value(&fg->mask, match_value, &fte->val) &&
 +		    (flow_act->action & fte->action)) {
 +			int old_action = fte->action;
++=======
+ 	if (fte) {
+ 		int old_action;
+ 		int ret;
+ 
+ 		nested_lock_ref_node(&fte->node, FS_LOCK_CHILD);
+ 		ret = check_conflicting_ftes(fte, flow_act);
+ 		if (ret) {
+ 			handle = ERR_PTR(ret);
+ 			goto unlock_fte;
+ 		}
++>>>>>>> c7784b1c8ab3 (net/mlx5: Replace fs_node mutex with reader/writer semaphore)
 +
 +			if (fte->flow_tag != flow_act->flow_tag) {
 +				mlx5_core_warn(get_dev(&fte->node),
 +					       "FTE flow tag %u already exists with different flow tag %u\n",
 +					       fte->flow_tag,
 +					       flow_act->flow_tag);
 +				handle = ERR_PTR(-EEXIST);
 +				goto unlock_fte;
 +			}
  
 -		old_action = fte->action;
 -		fte->action |= flow_act->action;
 -		handle = add_rule_fte(fte, fg, dest, dest_num,
 -				      old_action != flow_act->action);
 -		if (IS_ERR(handle)) {
 -			fte->action = old_action;
 -			goto unlock_fte;
 -		} else {
 -			trace_mlx5_fs_set_fte(fte, false);
 -			goto add_rules;
 +			fte->action |= flow_act->action;
 +			handle = add_rule_fte(fte, fg, dest, dest_num,
 +					      old_action != flow_act->action);
 +			if (IS_ERR(handle)) {
 +				fte->action = old_action;
 +				goto unlock_fte;
 +			} else {
 +				goto add_rules;
 +			}
  		}
 +		unlock_ref_node(&fte->node);
  	}
  	fs_get_obj(ft, fg->node.parent);
 +	if (fg->num_ftes >= fg->max_ftes) {
 +		handle = ERR_PTR(-ENOSPC);
 +		goto unlock_fg;
 +	}
  
++<<<<<<< HEAD
 +	fte = create_fte(fg, match_value, flow_act, &prev);
 +	if (IS_ERR(fte)) {
 +		handle = (void *)fte;
 +		goto unlock_fg;
 +	}
 +	tree_init_node(&fte->node, 0, del_fte);
 +	nested_lock_ref_node(&fte->node, FS_MUTEX_CHILD);
++=======
+ 	fte = alloc_insert_fte(fg, match_value, flow_act);
+ 	if (IS_ERR(fte))
+ 		return (void *)fte;
+ 	nested_lock_ref_node(&fte->node, FS_LOCK_CHILD);
++>>>>>>> c7784b1c8ab3 (net/mlx5: Replace fs_node mutex with reader/writer semaphore)
  	handle = add_rule_fte(fte, fg, dest, dest_num, false);
  	if (IS_ERR(handle)) {
  		unlock_ref_node(&fte->node);
@@@ -1349,6 -1464,126 +1369,129 @@@ static bool dest_is_valid(struct mlx5_f
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ struct match_list {
+ 	struct list_head	list;
+ 	struct mlx5_flow_group *g;
+ };
+ 
+ struct match_list_head {
+ 	struct list_head  list;
+ 	struct match_list first;
+ };
+ 
+ static void free_match_list(struct match_list_head *head)
+ {
+ 	if (!list_empty(&head->list)) {
+ 		struct match_list *iter, *match_tmp;
+ 
+ 		list_del(&head->first.list);
+ 		list_for_each_entry_safe(iter, match_tmp, &head->list,
+ 					 list) {
+ 			list_del(&iter->list);
+ 			kfree(iter);
+ 		}
+ 	}
+ }
+ 
+ static int build_match_list(struct match_list_head *match_head,
+ 			    struct mlx5_flow_table *ft,
+ 			    struct mlx5_flow_spec *spec)
+ {
+ 	struct rhlist_head *tmp, *list;
+ 	struct mlx5_flow_group *g;
+ 	int err = 0;
+ 
+ 	rcu_read_lock();
+ 	INIT_LIST_HEAD(&match_head->list);
+ 	/* Collect all fgs which has a matching match_criteria */
+ 	list = rhltable_lookup(&ft->fgs_hash, spec, rhash_fg);
+ 	/* RCU is atomic, we can't execute FW commands here */
+ 	rhl_for_each_entry_rcu(g, tmp, list, hash) {
+ 		struct match_list *curr_match;
+ 
+ 		if (likely(list_empty(&match_head->list))) {
+ 			match_head->first.g = g;
+ 			list_add_tail(&match_head->first.list,
+ 				      &match_head->list);
+ 			continue;
+ 		}
+ 
+ 		curr_match = kmalloc(sizeof(*curr_match), GFP_ATOMIC);
+ 		if (!curr_match) {
+ 			free_match_list(match_head);
+ 			err = -ENOMEM;
+ 			goto out;
+ 		}
+ 		curr_match->g = g;
+ 		list_add_tail(&curr_match->list, &match_head->list);
+ 	}
+ out:
+ 	rcu_read_unlock();
+ 	return err;
+ }
+ 
+ static struct mlx5_flow_handle *
+ try_add_to_existing_fg(struct mlx5_flow_table *ft,
+ 		       struct mlx5_flow_spec *spec,
+ 		       struct mlx5_flow_act *flow_act,
+ 		       struct mlx5_flow_destination *dest,
+ 		       int dest_num)
+ {
+ 	struct mlx5_flow_group *g;
+ 	struct mlx5_flow_handle *rule;
+ 	struct match_list_head match_head;
+ 	struct match_list *iter;
+ 	int err;
+ 
+ 	/* Collect all fgs which has a matching match_criteria */
+ 	err = build_match_list(&match_head, ft, spec);
+ 	if (err)
+ 		return ERR_PTR(err);
+ 
+ 	/* Try to find a fg that already contains a matching fte */
+ 	list_for_each_entry(iter, &match_head.list, list) {
+ 		struct fs_fte *fte;
+ 
+ 		g = iter->g;
+ 		nested_lock_ref_node(&g->node, FS_LOCK_PARENT);
+ 		fte = rhashtable_lookup_fast(&g->ftes_hash, spec->match_value,
+ 					     rhash_fte);
+ 		if (fte) {
+ 			rule = add_rule_fg(g, spec->match_value,
+ 					   flow_act, dest, dest_num, fte);
+ 			unlock_ref_node(&g->node);
+ 			goto free_list;
+ 		}
+ 		unlock_ref_node(&g->node);
+ 	}
+ 
+ 	/* No group with matching fte found. Try to add a new fte to any
+ 	 * matching fg.
+ 	 */
+ 	list_for_each_entry(iter, &match_head.list, list) {
+ 		g = iter->g;
+ 
+ 		nested_lock_ref_node(&g->node, FS_LOCK_PARENT);
+ 		rule = add_rule_fg(g, spec->match_value,
+ 				   flow_act, dest, dest_num, NULL);
+ 		if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOSPC) {
+ 			unlock_ref_node(&g->node);
+ 			goto free_list;
+ 		}
+ 		unlock_ref_node(&g->node);
+ 	}
+ 
+ 	rule = ERR_PTR(-ENOENT);
+ 
+ free_list:
+ 	free_match_list(&match_head);
+ 
+ 	return rule;
+ }
+ 
++>>>>>>> c7784b1c8ab3 (net/mlx5: Replace fs_node mutex with reader/writer semaphore)
  static struct mlx5_flow_handle *
  _mlx5_add_flow_rules(struct mlx5_flow_table *ft,
  		     struct mlx5_flow_spec *spec,
@@@ -1366,20 -1605,12 +1509,27 @@@
  			return ERR_PTR(-EINVAL);
  	}
  
++<<<<<<< HEAD
 +	nested_lock_ref_node(&ft->node, FS_MUTEX_GRANDPARENT);
 +	fs_for_each_fg(g, ft)
 +		if (compare_match_criteria(g->mask.match_criteria_enable,
 +					   spec->match_criteria_enable,
 +					   g->mask.match_criteria,
 +					   spec->match_criteria)) {
 +			rule = add_rule_fg(g, spec->match_value,
 +					   flow_act, dest, dest_num);
 +			if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOSPC)
 +				goto unlock;
 +		}
++=======
+ 	nested_lock_ref_node(&ft->node, FS_LOCK_GRANDPARENT);
+ 	rule = try_add_to_existing_fg(ft, spec, flow_act, dest, dest_num);
+ 	if (!IS_ERR(rule) || PTR_ERR(rule) != -ENOENT)
+ 		goto unlock;
++>>>>>>> c7784b1c8ab3 (net/mlx5: Replace fs_node mutex with reader/writer semaphore)
  
 -	g = alloc_auto_flow_group(ft, spec);
 +	g = create_autogroup(ft, spec->match_criteria_enable,
 +			     spec->match_criteria);
  	if (IS_ERR(g)) {
  		rule = (void *)g;
  		goto unlock;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index c840ec9c1fc4..14bd03da54d8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@ -80,7 +80,7 @@ struct fs_node {
 	struct fs_node		*parent;
 	struct fs_node		*root;
 	/* lock the node for writing and traversing */
-	struct mutex		lock;
+	struct rw_semaphore	lock;
 	atomic_t		refcount;
 	void			(*remove_func)(struct fs_node *);
 };
