x86/MCE: Export memory_error()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] mce: Export memory_error() (Jeff Moyer) [1471692]
Rebuild_FUZZ: 92.86%
commit-author Borislav Petkov <bp@suse.de>
commit 2d1f406139ec20320bf38bcd2461aa8e358084b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2d1f4061.failed

Export the function which checks whether an MCE is a memory error to
other users so that we can reuse the logic. Drop the boot_cpu_data use,
while at it, as mce.cpuvendor already has the CPU vendor in there.

Integrate a piece from a patch from Vishal Verma
<vishal.l.verma@intel.com> to export it for modules (nfit).

The main reason we're exporting it is that the nfit handler
nfit_handle_mce() needs to detect a memory error properly before doing
its recovery actions.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vishal Verma <vishal.l.verma@intel.com>
	Cc: <stable@vger.kernel.org>
Link: http://lkml.kernel.org/r/20170519093915.15413-2-bp@alien8.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 2d1f406139ec20320bf38bcd2461aa8e358084b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce.c
diff --cc arch/x86/kernel/cpu/mcheck/mce.c
index 3935d0185781,5cfbaeb6529a..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@@ -546,6 -498,78 +546,80 @@@ static int mce_usable_address(struct mc
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ bool mce_is_memory_error(struct mce *m)
+ {
+ 	if (m->cpuvendor == X86_VENDOR_AMD) {
+ 		/* ErrCodeExt[20:16] */
+ 		u8 xec = (m->status >> 16) & 0x1f;
+ 
+ 		return (xec == 0x0 || xec == 0x8);
+ 	} else if (m->cpuvendor == X86_VENDOR_INTEL) {
+ 		/*
+ 		 * Intel SDM Volume 3B - 15.9.2 Compound Error Codes
+ 		 *
+ 		 * Bit 7 of the MCACOD field of IA32_MCi_STATUS is used for
+ 		 * indicating a memory error. Bit 8 is used for indicating a
+ 		 * cache hierarchy error. The combination of bit 2 and bit 3
+ 		 * is used for indicating a `generic' cache hierarchy error
+ 		 * But we can't just blindly check the above bits, because if
+ 		 * bit 11 is set, then it is a bus/interconnect error - and
+ 		 * either way the above bits just gives more detail on what
+ 		 * bus/interconnect error happened. Note that bit 12 can be
+ 		 * ignored, as it's the "filter" bit.
+ 		 */
+ 		return (m->status & 0xef80) == BIT(7) ||
+ 		       (m->status & 0xef00) == BIT(8) ||
+ 		       (m->status & 0xeffc) == 0xc;
+ 	}
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(mce_is_memory_error);
+ 
+ static bool cec_add_mce(struct mce *m)
+ {
+ 	if (!m)
+ 		return false;
+ 
+ 	/* We eat only correctable DRAM errors with usable addresses. */
+ 	if (mce_is_memory_error(m) &&
+ 	    !(m->status & MCI_STATUS_UC) &&
+ 	    mce_usable_address(m))
+ 		if (!cec_add_elem(m->addr >> PAGE_SHIFT))
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ static int mce_first_notifier(struct notifier_block *nb, unsigned long val,
+ 			      void *data)
+ {
+ 	struct mce *m = (struct mce *)data;
+ 
+ 	if (!m)
+ 		return NOTIFY_DONE;
+ 
+ 	if (cec_add_mce(m))
+ 		return NOTIFY_STOP;
+ 
+ 	/* Emit the trace record: */
+ 	trace_mce_record(m);
+ 
+ 	set_bit(0, &mce_need_notify);
+ 
+ 	mce_notify_irq();
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block first_nb = {
+ 	.notifier_call	= mce_first_notifier,
+ 	.priority	= MCE_PRIO_FIRST,
+ };
+ 
++>>>>>>> 2d1f406139ec (x86/MCE: Export memory_error())
  static int srao_decode_notifier(struct notifier_block *nb, unsigned long val,
  				void *data)
  {
@@@ -720,12 -710,9 +794,12 @@@ bool machine_check_poll(enum mcp_flags 
  
  		mce_read_aux(&m, i);
  
 +		if (!(flags & MCP_TIMESTAMP))
 +			m.tsc = 0;
 +
  		severity = mce_severity(&m, mca_cfg.tolerant, NULL, false);
  
- 		if (severity == MCE_DEFERRED_SEVERITY && memory_error(&m))
+ 		if (severity == MCE_DEFERRED_SEVERITY && mce_is_memory_error(&m))
  			if (m.status & MCI_STATUS_ADDRV)
  				m.severity = severity;
  
diff --git a/arch/x86/include/asm/mce.h b/arch/x86/include/asm/mce.h
index fe9814f1ef48..6f932827c4a7 100644
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@ -267,6 +267,7 @@ static inline int umc_normaddr_to_sysaddr(u64 norm_addr, u16 nid, u8 umc, u64 *s
 #endif
 
 int mce_available(struct cpuinfo_x86 *c);
+bool mce_is_memory_error(struct mce *m);
 
 DECLARE_PER_CPU(unsigned, mce_exception_count);
 DECLARE_PER_CPU(unsigned, mce_poll_count);
* Unmerged path arch/x86/kernel/cpu/mcheck/mce.c
