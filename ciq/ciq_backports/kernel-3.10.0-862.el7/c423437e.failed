qla2xxx: Add DebugFS node to display Port Database

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Himanshu Madhani <himanshu.madhani@cavium.com>
commit c423437e3ff41b8ca551ab6621baf11538dbfe9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c423437e.failed

	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Giridhar Malavali <giridhar.malavali@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit c423437e3ff41b8ca551ab6621baf11538dbfe9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_dfs.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3f28536dc812,089480280558..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2969,9 -3298,28 +2969,23 @@@ struct qlt_hw_data 
  	uint8_t saved_add_firmware_options[2];
  
  	uint8_t tgt_node_name[WWN_SIZE];
++<<<<<<< HEAD
++=======
+ 
+ 	struct dentry *dfs_tgt_sess;
+ 	struct dentry *dfs_tgt_port_database;
+ 
+ 	struct list_head q_full_list;
+ 	uint32_t num_pend_cmds;
+ 	uint32_t num_qfull_cmds_alloc;
+ 	uint32_t num_qfull_cmds_dropped;
+ 	spinlock_t q_full_lock;
+ 	uint32_t leak_exchg_thresh_hold;
+ 	spinlock_t sess_lock;
++>>>>>>> c423437e3ff4 (qla2xxx: Add DebugFS node to display Port Database)
  	int rspq_vector_cpuid;
 -	spinlock_t atio_lock ____cacheline_aligned;
  };
  
 -#define MAX_QFULL_CMDS_ALLOC	8192
 -#define Q_FULL_THRESH_HOLD_PERCENT 90
 -#define Q_FULL_THRESH_HOLD(ha) \
 -	((ha->cur_fw_xcb_count/100) * Q_FULL_THRESH_HOLD_PERCENT)
 -
 -#define LEAK_EXCHG_THRESH_HOLD_PERCENT 75	/* 75 percent */
 -
  /*
   * Qlogic host adapter specific data structure.
  */
diff --cc drivers/scsi/qla2xxx/qla_dfs.c
index 2ca39b8e7166,989e17b0758c..000000000000
--- a/drivers/scsi/qla2xxx/qla_dfs.c
+++ b/drivers/scsi/qla2xxx/qla_dfs.c
@@@ -13,6 -13,211 +13,214 @@@ static struct dentry *qla2x00_dfs_root
  static atomic_t qla2x00_dfs_root_count;
  
  static int
++<<<<<<< HEAD
++=======
+ qla2x00_dfs_tgt_sess_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	unsigned long flags;
+ 	struct fc_port *sess = NULL;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n", vha->host_str);
+ 	if (tgt) {
+ 		seq_puts(s, "Port ID   Port Name                Handle\n");
+ 
+ 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+ 		list_for_each_entry(sess, &vha->vp_fcports, list)
+ 			seq_printf(s, "%02x:%02x:%02x  %8phC  %d\n",
+ 			    sess->d_id.b.domain, sess->d_id.b.area,
+ 			    sess->d_id.b.al_pa, sess->port_name,
+ 			    sess->loop_id);
+ 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_sess_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 	return single_open(file, qla2x00_dfs_tgt_sess_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_sess_ops = {
+ 	.open		= qla2x00_dfs_tgt_sess_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla2x00_dfs_tgt_port_database_show(struct seq_file *s, void *unused)
+ {
+ 	scsi_qla_host_t *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct gid_list_info *gid_list;
+ 	dma_addr_t gid_list_dma;
+ 	fc_port_t fc_port;
+ 	char *id_iter;
+ 	int rc, i;
+ 	uint16_t entries, loop_id;
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 
+ 	seq_printf(s, "%s\n", vha->host_str);
+ 	if (tgt) {
+ 		gid_list = dma_alloc_coherent(&ha->pdev->dev,
+ 		    qla2x00_gid_list_size(ha),
+ 		    &gid_list_dma, GFP_KERNEL);
+ 		if (!gid_list) {
+ 			ql_dbg(ql_dbg_user, vha, 0x705c,
+ 			    "DMA allocation failed for %u\n",
+ 			     qla2x00_gid_list_size(ha));
+ 			return 0;
+ 		}
+ 
+ 		rc = qla24xx_gidlist_wait(vha, gid_list, gid_list_dma,
+ 		    &entries);
+ 		if (rc != QLA_SUCCESS)
+ 			goto out_free_id_list;
+ 
+ 		id_iter = (char *)gid_list;
+ 
+ 		seq_puts(s, "Port Name	Port ID 	Loop ID\n");
+ 
+ 		for (i = 0; i < entries; i++) {
+ 			struct gid_list_info *gid =
+ 			    (struct gid_list_info *)id_iter;
+ 			loop_id = le16_to_cpu(gid->loop_id);
+ 			memset(&fc_port, 0, sizeof(fc_port_t));
+ 
+ 			fc_port.loop_id = loop_id;
+ 
+ 			rc = qla24xx_gpdb_wait(vha, &fc_port, 0);
+ 			seq_printf(s, "%8phC  %02x%02x%02x  %d\n",
+ 				fc_port.port_name, fc_port.d_id.b.domain,
+ 				fc_port.d_id.b.area, fc_port.d_id.b.al_pa,
+ 				fc_port.loop_id);
+ 			id_iter += ha->gid_list_info_size;
+ 		}
+ out_free_id_list:
+ 		dma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),
+ 		    gid_list, gid_list_dma);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla2x00_dfs_tgt_port_database_open(struct inode *inode, struct file *file)
+ {
+ 	scsi_qla_host_t *vha = inode->i_private;
+ 
+ 	return single_open(file, qla2x00_dfs_tgt_port_database_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_port_database_ops = {
+ 	.open		= qla2x00_dfs_tgt_port_database_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+ };
+ 
+ static int
+ qla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 	struct qla_hw_data *ha = vha->hw;
+ 
+ 	seq_puts(s, "FW Resource count\n\n");
+ 	seq_printf(s, "Original TGT exchg count[%d]\n",
+ 	    ha->orig_fw_tgt_xcb_count);
+ 	seq_printf(s, "current TGT exchg count[%d]\n",
+ 	    ha->cur_fw_tgt_xcb_count);
+ 	seq_printf(s, "original Initiator Exchange count[%d]\n",
+ 	    ha->orig_fw_xcb_count);
+ 	seq_printf(s, "Current Initiator Exchange count[%d]\n",
+ 	    ha->cur_fw_xcb_count);
+ 	seq_printf(s, "Original IOCB count[%d]\n", ha->orig_fw_iocb_count);
+ 	seq_printf(s, "Current IOCB count[%d]\n", ha->cur_fw_iocb_count);
+ 	seq_printf(s, "MAX VP count[%d]\n", ha->max_npiv_vports);
+ 	seq_printf(s, "MAX FCF count[%d]\n", ha->fw_max_fcf_count);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_fw_resource_cnt_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_fw_resource_cnt_show, vha);
+ }
+ 
+ static const struct file_operations dfs_fw_resource_cnt_ops = {
+ 	.open           = qla_dfs_fw_resource_cnt_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
+ qla_dfs_tgt_counters_show(struct seq_file *s, void *unused)
+ {
+ 	struct scsi_qla_host *vha = s->private;
+ 
+ 	seq_puts(s, "Target Counters\n");
+ 	seq_printf(s, "qla_core_sbt_cmd = %lld\n",
+ 		vha->tgt_counters.qla_core_sbt_cmd);
+ 	seq_printf(s, "qla_core_ret_sta_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_sta_ctio);
+ 	seq_printf(s, "qla_core_ret_ctio = %lld\n",
+ 		vha->tgt_counters.qla_core_ret_ctio);
+ 	seq_printf(s, "core_qla_que_buf = %lld\n",
+ 		vha->tgt_counters.core_qla_que_buf);
+ 	seq_printf(s, "core_qla_snd_status = %lld\n",
+ 		vha->tgt_counters.core_qla_snd_status);
+ 	seq_printf(s, "core_qla_free_cmd = %lld\n",
+ 		vha->tgt_counters.core_qla_free_cmd);
+ 	seq_printf(s, "num alloc iocb failed = %lld\n",
+ 		vha->tgt_counters.num_alloc_iocb_failed);
+ 	seq_printf(s, "num term exchange sent = %lld\n",
+ 		vha->tgt_counters.num_term_xchg_sent);
+ 	seq_printf(s, "num Q full sent = %lld\n",
+ 		vha->tgt_counters.num_q_full_sent);
+ 
+ 	/* DIF stats */
+ 	seq_printf(s, "DIF Inp Bytes = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_input_bytes);
+ 	seq_printf(s, "DIF Outp Bytes = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_output_bytes);
+ 	seq_printf(s, "DIF Inp Req = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_input_requests);
+ 	seq_printf(s, "DIF Outp Req = %lld\n",
+ 		vha->qla_stats.qla_dif_stats.dif_output_requests);
+ 	seq_printf(s, "DIF Guard err = %d\n",
+ 		vha->qla_stats.qla_dif_stats.dif_guard_err);
+ 	seq_printf(s, "DIF Ref tag err = %d\n",
+ 		vha->qla_stats.qla_dif_stats.dif_ref_tag_err);
+ 	seq_printf(s, "DIF App tag err = %d\n",
+ 		vha->qla_stats.qla_dif_stats.dif_app_tag_err);
+ 	return 0;
+ }
+ 
+ static int
+ qla_dfs_tgt_counters_open(struct inode *inode, struct file *file)
+ {
+ 	struct scsi_qla_host *vha = inode->i_private;
+ 	return single_open(file, qla_dfs_tgt_counters_show, vha);
+ }
+ 
+ static const struct file_operations dfs_tgt_counters_ops = {
+ 	.open           = qla_dfs_tgt_counters_open,
+ 	.read           = seq_read,
+ 	.llseek         = seq_lseek,
+ 	.release        = single_release,
+ };
+ 
+ static int
++>>>>>>> c423437e3ff4 (qla2xxx: Add DebugFS node to display Port Database)
  qla2x00_dfs_fce_show(struct seq_file *s, void *unused)
  {
  	scsi_qla_host_t *vha = s->private;
@@@ -146,6 -351,30 +354,33 @@@ create_dir
  	atomic_inc(&qla2x00_dfs_root_count);
  
  create_nodes:
++<<<<<<< HEAD
++=======
+ 	ha->dfs_fw_resource_cnt = debugfs_create_file("fw_resource_count",
+ 	    S_IRUSR, ha->dfs_dir, vha, &dfs_fw_resource_cnt_ops);
+ 	if (!ha->dfs_fw_resource_cnt) {
+ 		ql_log(ql_log_warn, vha, 0x00fd,
+ 		    "Unable to create debugFS fw_resource_count node.\n");
+ 		goto out;
+ 	}
+ 
+ 	ha->dfs_tgt_counters = debugfs_create_file("tgt_counters", S_IRUSR,
+ 	    ha->dfs_dir, vha, &dfs_tgt_counters_ops);
+ 	if (!ha->dfs_tgt_counters) {
+ 		ql_log(ql_log_warn, vha, 0xd301,
+ 		    "Unable to create debugFS tgt_counters node.\n");
+ 		goto out;
+ 	}
+ 
+ 	ha->tgt.dfs_tgt_port_database = debugfs_create_file("tgt_port_database",
+ 	    S_IRUSR,  ha->dfs_dir, vha, &dfs_tgt_port_database_ops);
+ 	if (!ha->tgt.dfs_tgt_port_database) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Unable to create debugFS tgt_port_database node.\n");
+ 		goto out;
+ 	}
+ 
++>>>>>>> c423437e3ff4 (qla2xxx: Add DebugFS node to display Port Database)
  	ha->dfs_fce = debugfs_create_file("fce", S_IRUSR, ha->dfs_dir, vha,
  	    &dfs_fce_ops);
  	if (!ha->dfs_fce) {
@@@ -161,6 -399,27 +396,30 @@@ in
  qla2x00_dfs_remove(scsi_qla_host_t *vha)
  {
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 
+ 	if (ha->tgt.dfs_tgt_sess) {
+ 		debugfs_remove(ha->tgt.dfs_tgt_sess);
+ 		ha->tgt.dfs_tgt_sess = NULL;
+ 	}
+ 
+ 	if (ha->tgt.dfs_tgt_port_database) {
+ 		debugfs_remove(ha->tgt.dfs_tgt_port_database);
+ 		ha->tgt.dfs_tgt_port_database = NULL;
+ 	}
+ 
+ 	if (ha->dfs_fw_resource_cnt) {
+ 		debugfs_remove(ha->dfs_fw_resource_cnt);
+ 		ha->dfs_fw_resource_cnt = NULL;
+ 	}
+ 
+ 	if (ha->dfs_tgt_counters) {
+ 		debugfs_remove(ha->dfs_tgt_counters);
+ 		ha->dfs_tgt_counters = NULL;
+ 	}
+ 
++>>>>>>> c423437e3ff4 (qla2xxx: Add DebugFS node to display Port Database)
  	if (ha->dfs_fce) {
  		debugfs_remove(ha->dfs_fce);
  		ha->dfs_fce = NULL;
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_dfs.c
