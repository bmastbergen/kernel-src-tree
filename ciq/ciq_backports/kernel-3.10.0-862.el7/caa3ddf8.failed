mlxsw: spectrum_router: Allocate FID prior to RIF configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit caa3ddf8e39022ee2cd87835bc400b9c516fcd95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/caa3ddf8.failed

The following patches are going to re-arrange the FID and RIF code, so
that when the RIF is configured to the device based on the information
present in the RIF struct (which points to a FID).

For this reason, move the FID allocation to just before the RIF
configuration.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit caa3ddf8e39022ee2cd87835bc400b9c516fcd95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index f8e7036e3f4a,c8d136c51444..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -2769,131 -3002,184 +2769,151 @@@ mlxsw_sp_rif_alloc(u16 rif, u16 vr_id, 
  }
  
  static struct mlxsw_sp_rif *
 -mlxsw_sp_port_vlan_rif_sp_create(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,
 -				 struct net_device *l3_dev)
 +mlxsw_sp_vport_rif_sp_create(struct mlxsw_sp_port *mlxsw_sp_vport,
 +			     struct net_device *l3_dev)
  {
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 -	u32 tb_id = l3mdev_fib_table(l3_dev);
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
  	struct mlxsw_sp_vr *vr;
  	struct mlxsw_sp_fid *f;
 -	struct mlxsw_sp_rif *rif;
 -	u16 fid, rif_index;
 +	struct mlxsw_sp_rif *r;
 +	u16 fid, rif;
  	int err;
  
 -	rif_index = mlxsw_sp_avail_rif_get(mlxsw_sp);
 -	if (rif_index == MLXSW_SP_INVALID_INDEX_RIF)
 +	rif = mlxsw_sp_avail_rif_get(mlxsw_sp);
 +	if (rif == MLXSW_SP_INVALID_RIF)
  		return ERR_PTR(-ERANGE);
  
++<<<<<<< HEAD
 +	vr = mlxsw_sp_vr_get(mlxsw_sp, RT_TABLE_MAIN);
 +	if (IS_ERR(vr))
 +		return ERR_CAST(vr);
++=======
+ 	fid = mlxsw_sp_rif_sp_to_fid(rif_index);
+ 	f = mlxsw_sp_rfid_alloc(fid, l3_dev);
+ 	if (!f)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	vr = mlxsw_sp_vr_get(mlxsw_sp, tb_id ? : RT_TABLE_MAIN);
+ 	if (IS_ERR(vr)) {
+ 		err = PTR_ERR(vr);
+ 		goto err_vr_get;
+ 	}
++>>>>>>> caa3ddf8e390 (mlxsw: spectrum_router: Allocate FID prior to RIF configuration)
  
 -	err = mlxsw_sp_port_vlan_rif_sp_op(mlxsw_sp_port_vlan, vr->id, l3_dev,
 -					   rif_index, true);
 +	err = mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif,
 +				       true);
  	if (err)
 -		goto err_port_vlan_rif_sp_op;
 +		goto err_vport_rif_sp_op;
  
++<<<<<<< HEAD
 +	fid = mlxsw_sp_rif_sp_to_fid(rif);
++=======
++>>>>>>> caa3ddf8e390 (mlxsw: spectrum_router: Allocate FID prior to RIF configuration)
  	err = mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, true);
  	if (err)
  		goto err_rif_fdb_op;
  
++<<<<<<< HEAD
 +	f = mlxsw_sp_rfid_alloc(fid, l3_dev);
 +	if (!f) {
 +		err = -ENOMEM;
 +		goto err_rfid_alloc;
 +	}
 +
 +	r = mlxsw_sp_rif_alloc(rif, vr->id, l3_dev, f);
 +	if (!r) {
++=======
+ 	rif = mlxsw_sp_rif_alloc(rif_index, vr->id, l3_dev, f);
+ 	if (!rif) {
++>>>>>>> caa3ddf8e390 (mlxsw: spectrum_router: Allocate FID prior to RIF configuration)
  		err = -ENOMEM;
  		goto err_rif_alloc;
  	}
  
 -	if (devlink_dpipe_table_counter_enabled(priv_to_devlink(mlxsw_sp->core),
 -						MLXSW_SP_DPIPE_TABLE_NAME_ERIF)) {
 -		err = mlxsw_sp_rif_counter_alloc(mlxsw_sp, rif,
 -						 MLXSW_SP_RIF_COUNTER_EGRESS);
 -		if (err)
 -			netdev_dbg(mlxsw_sp_port->dev,
 -				   "Counter alloc Failed err=%d\n", err);
 -	}
 -
 -	f->rif = rif;
 -	mlxsw_sp->router->rifs[rif_index] = rif;
 +	f->r = r;
 +	mlxsw_sp->rifs[rif] = r;
  	vr->rif_count++;
  
 -	return rif;
 +	return r;
  
  err_rif_alloc:
- 	kfree(f);
- err_rfid_alloc:
  	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
  err_rif_fdb_op:
 -	mlxsw_sp_port_vlan_rif_sp_op(mlxsw_sp_port_vlan, vr->id, l3_dev,
 -				     rif_index, false);
 -err_port_vlan_rif_sp_op:
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
 +err_vport_rif_sp_op:
  	mlxsw_sp_vr_put(vr);
+ err_vr_get:
+ 	kfree(f);
  	return ERR_PTR(err);
  }
  
 -static void
 -mlxsw_sp_port_vlan_rif_sp_destroy(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,
 -				  struct mlxsw_sp_rif *rif)
 -{
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 -	struct mlxsw_sp_vr *vr = &mlxsw_sp->router->vrs[rif->vr_id];
 -	struct net_device *l3_dev = rif->dev;
 -	struct mlxsw_sp_fid *f = rif->f;
 -	u16 rif_index = rif->rif_index;
 +static void mlxsw_sp_vport_rif_sp_destroy(struct mlxsw_sp_port *mlxsw_sp_vport,
 +					  struct mlxsw_sp_rif *r)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_vr *vr = &mlxsw_sp->router.vrs[r->vr_id];
 +	struct net_device *l3_dev = r->dev;
 +	struct mlxsw_sp_fid *f = r->f;
  	u16 fid = f->fid;
 +	u16 rif = r->rif;
  
 -	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, rif);
 -
 -	mlxsw_sp_rif_counter_free(mlxsw_sp, rif, MLXSW_SP_RIF_COUNTER_EGRESS);
 -	mlxsw_sp_rif_counter_free(mlxsw_sp, rif, MLXSW_SP_RIF_COUNTER_INGRESS);
 +	mlxsw_sp_router_rif_gone_sync(mlxsw_sp, r);
  
  	vr->rif_count--;
 -	mlxsw_sp->router->rifs[rif_index] = NULL;
 -	f->rif = NULL;
 +	mlxsw_sp->rifs[rif] = NULL;
 +	f->r = NULL;
  
 -	kfree(rif);
 +	kfree(r);
  
- 	kfree(f);
- 
  	mlxsw_sp_rif_fdb_op(mlxsw_sp, l3_dev->dev_addr, fid, false);
  
 -	mlxsw_sp_port_vlan_rif_sp_op(mlxsw_sp_port_vlan, vr->id, l3_dev,
 -				     rif_index, false);
 +	mlxsw_sp_vport_rif_sp_op(mlxsw_sp_vport, vr->id, l3_dev, rif, false);
  
  	mlxsw_sp_vr_put(vr);
+ 	kfree(f);
  }
  
 -static int
 -mlxsw_sp_port_vlan_rif_sp_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,
 -			       struct net_device *l3_dev)
 +static int mlxsw_sp_vport_rif_sp_join(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				      struct net_device *l3_dev)
  {
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	u16 vid = mlxsw_sp_port_vlan->vid;
 -	struct mlxsw_sp_rif *rif;
 -	int err;
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_vport->mlxsw_sp;
 +	struct mlxsw_sp_rif *r;
  
 -	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp_port->mlxsw_sp, l3_dev);
 -	if (!rif) {
 -		rif = mlxsw_sp_port_vlan_rif_sp_create(mlxsw_sp_port_vlan,
 -						       l3_dev);
 -		if (IS_ERR(rif))
 -			return PTR_ERR(rif);
 +	r = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);
 +	if (!r) {
 +		r = mlxsw_sp_vport_rif_sp_create(mlxsw_sp_vport, l3_dev);
 +		if (IS_ERR(r))
 +			return PTR_ERR(r);
  	}
  
 -	err = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);
 -	if (err)
 -		goto err_port_vid_learning_set;
 -
 -	err = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,
 -					BR_STATE_FORWARDING);
 -	if (err)
 -		goto err_port_vid_stp_set;
 -
 -	if (mlxsw_sp_port->nr_port_vid_map++ == 0) {
 -		err = mlxsw_sp_port_vp_mode_trans(mlxsw_sp_port);
 -		if (err)
 -			goto err_port_vp_mode_trans;
 -	}
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, r->f);
 +	r->f->ref_count++;
  
 -	mlxsw_sp_port_vlan->fid = rif->f;
 -	rif->f->ref_count++;
 +	netdev_dbg(mlxsw_sp_vport->dev, "Joined FID=%d\n", r->f->fid);
  
  	return 0;
 -
 -err_port_vp_mode_trans:
 -	mlxsw_sp_port->nr_port_vid_map--;
 -	mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_BLOCKING);
 -err_port_vid_stp_set:
 -	mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);
 -err_port_vid_learning_set:
 -	if (rif->f->ref_count == 0)
 -		mlxsw_sp_port_vlan_rif_sp_destroy(mlxsw_sp_port_vlan, rif);
 -	return err;
  }
  
 -static void
 -mlxsw_sp_port_vlan_rif_sp_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)
 +static void mlxsw_sp_vport_rif_sp_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
  {
 -	struct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;
 -	struct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;
 -	u16 vid = mlxsw_sp_port_vlan->vid;
 -
 -	fid->ref_count--;
 -	mlxsw_sp_port_vlan->fid = NULL;
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
  
 -	if (mlxsw_sp_port->nr_port_vid_map == 1)
 -		mlxsw_sp_port_vlan_mode_trans(mlxsw_sp_port);
 -	mlxsw_sp_port->nr_port_vid_map--;
 -	mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_BLOCKING);
 -	mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);
 +	netdev_dbg(mlxsw_sp_vport->dev, "Left FID=%d\n", f->fid);
  
 -	if (fid->ref_count == 0)
 -		mlxsw_sp_port_vlan_rif_sp_destroy(mlxsw_sp_port_vlan, fid->rif);
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, NULL);
 +	if (--f->ref_count == 0)
 +		mlxsw_sp_vport_rif_sp_destroy(mlxsw_sp_vport, f->r);
  }
  
 -static int mlxsw_sp_inetaddr_port_vlan_event(struct net_device *l3_dev,
 -					     struct net_device *port_dev,
 -					     unsigned long event, u16 vid)
 +static int mlxsw_sp_inetaddr_vport_event(struct net_device *l3_dev,
 +					 struct net_device *port_dev,
 +					 unsigned long event, u16 vid)
  {
  	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(port_dev);
 -	struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
  
 -	mlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);
 -	if (WARN_ON(!mlxsw_sp_port_vlan))
 +	mlxsw_sp_vport = mlxsw_sp_port_vport_find(mlxsw_sp_port, vid);
 +	if (WARN_ON(!mlxsw_sp_vport))
  		return -EINVAL;
  
  	switch (event) {
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
