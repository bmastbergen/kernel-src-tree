vfs: Add iomap_seek_hole and iomap_seek_data helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 0ed3b0d45fd39142e418220f518c8959c1a5f596
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0ed3b0d4.failed

Filesystems can use this for implementing lseek SEEK_HOLE / SEEK_DATA
support via iomap.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
[hch: split functions, coding style cleanups]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 0ed3b0d45fd39142e418220f518c8959c1a5f596)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap.c
#	include/linux/iomap.h
diff --cc fs/iomap.c
index f6bfcdf64146,432eed8f091f..000000000000
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@@ -589,3 -583,473 +589,476 @@@ int iomap_fiemap(struct inode *inode, s
  	return 0;
  }
  EXPORT_SYMBOL_GPL(iomap_fiemap);
++<<<<<<< HEAD
++=======
+ 
+ static loff_t
+ iomap_seek_hole_actor(struct inode *inode, loff_t offset, loff_t length,
+ 		      void *data, struct iomap *iomap)
+ {
+ 	switch (iomap->type) {
+ 	case IOMAP_UNWRITTEN:
+ 		offset = page_cache_seek_hole_data(inode, offset, length,
+ 						   SEEK_HOLE);
+ 		if (offset < 0)
+ 			return length;
+ 		/* fall through */
+ 	case IOMAP_HOLE:
+ 		*(loff_t *)data = offset;
+ 		return 0;
+ 	default:
+ 		return length;
+ 	}
+ }
+ 
+ loff_t
+ iomap_seek_hole(struct inode *inode, loff_t offset, const struct iomap_ops *ops)
+ {
+ 	loff_t size = i_size_read(inode);
+ 	loff_t length = size - offset;
+ 	loff_t ret;
+ 
+ 	/* Nothing to be found beyond the end of the file. */
+ 	if (offset >= size)
+ 		return -ENXIO;
+ 
+ 	while (length > 0) {
+ 		ret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,
+ 				  &offset, iomap_seek_hole_actor);
+ 		if (ret < 0)
+ 			return ret;
+ 		if (ret == 0)
+ 			break;
+ 
+ 		offset += ret;
+ 		length -= ret;
+ 	}
+ 
+ 	return offset;
+ }
+ EXPORT_SYMBOL_GPL(iomap_seek_hole);
+ 
+ static loff_t
+ iomap_seek_data_actor(struct inode *inode, loff_t offset, loff_t length,
+ 		      void *data, struct iomap *iomap)
+ {
+ 	switch (iomap->type) {
+ 	case IOMAP_HOLE:
+ 		return length;
+ 	case IOMAP_UNWRITTEN:
+ 		offset = page_cache_seek_hole_data(inode, offset, length,
+ 						   SEEK_DATA);
+ 		if (offset < 0)
+ 			return length;
+ 		/*FALLTHRU*/
+ 	default:
+ 		*(loff_t *)data = offset;
+ 		return 0;
+ 	}
+ }
+ 
+ loff_t
+ iomap_seek_data(struct inode *inode, loff_t offset, const struct iomap_ops *ops)
+ {
+ 	loff_t size = i_size_read(inode);
+ 	loff_t length = size - offset;
+ 	loff_t ret;
+ 
+ 	/* Nothing to be found beyond the end of the file. */
+ 	if (offset >= size)
+ 		return -ENXIO;
+ 
+ 	while (length > 0) {
+ 		ret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,
+ 				  &offset, iomap_seek_data_actor);
+ 		if (ret < 0)
+ 			return ret;
+ 		if (ret == 0)
+ 			break;
+ 
+ 		offset += ret;
+ 		length -= ret;
+ 	}
+ 
+ 	if (length <= 0)
+ 		return -ENXIO;
+ 	return offset;
+ }
+ EXPORT_SYMBOL_GPL(iomap_seek_data);
+ 
+ /*
+  * Private flags for iomap_dio, must not overlap with the public ones in
+  * iomap.h:
+  */
+ #define IOMAP_DIO_WRITE		(1 << 30)
+ #define IOMAP_DIO_DIRTY		(1 << 31)
+ 
+ struct iomap_dio {
+ 	struct kiocb		*iocb;
+ 	iomap_dio_end_io_t	*end_io;
+ 	loff_t			i_size;
+ 	loff_t			size;
+ 	atomic_t		ref;
+ 	unsigned		flags;
+ 	int			error;
+ 
+ 	union {
+ 		/* used during submission and for synchronous completion: */
+ 		struct {
+ 			struct iov_iter		*iter;
+ 			struct task_struct	*waiter;
+ 			struct request_queue	*last_queue;
+ 			blk_qc_t		cookie;
+ 		} submit;
+ 
+ 		/* used for aio completion: */
+ 		struct {
+ 			struct work_struct	work;
+ 		} aio;
+ 	};
+ };
+ 
+ static ssize_t iomap_dio_complete(struct iomap_dio *dio)
+ {
+ 	struct kiocb *iocb = dio->iocb;
+ 	ssize_t ret;
+ 
+ 	if (dio->end_io) {
+ 		ret = dio->end_io(iocb,
+ 				dio->error ? dio->error : dio->size,
+ 				dio->flags);
+ 	} else {
+ 		ret = dio->error;
+ 	}
+ 
+ 	if (likely(!ret)) {
+ 		ret = dio->size;
+ 		/* check for short read */
+ 		if (iocb->ki_pos + ret > dio->i_size &&
+ 		    !(dio->flags & IOMAP_DIO_WRITE))
+ 			ret = dio->i_size - iocb->ki_pos;
+ 		iocb->ki_pos += ret;
+ 	}
+ 
+ 	inode_dio_end(file_inode(iocb->ki_filp));
+ 	kfree(dio);
+ 
+ 	return ret;
+ }
+ 
+ static void iomap_dio_complete_work(struct work_struct *work)
+ {
+ 	struct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);
+ 	struct kiocb *iocb = dio->iocb;
+ 	bool is_write = (dio->flags & IOMAP_DIO_WRITE);
+ 	ssize_t ret;
+ 
+ 	ret = iomap_dio_complete(dio);
+ 	if (is_write && ret > 0)
+ 		ret = generic_write_sync(iocb, ret);
+ 	iocb->ki_complete(iocb, ret, 0);
+ }
+ 
+ /*
+  * Set an error in the dio if none is set yet.  We have to use cmpxchg
+  * as the submission context and the completion context(s) can race to
+  * update the error.
+  */
+ static inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)
+ {
+ 	cmpxchg(&dio->error, 0, ret);
+ }
+ 
+ static void iomap_dio_bio_end_io(struct bio *bio)
+ {
+ 	struct iomap_dio *dio = bio->bi_private;
+ 	bool should_dirty = (dio->flags & IOMAP_DIO_DIRTY);
+ 
+ 	if (bio->bi_error)
+ 		iomap_dio_set_error(dio, bio->bi_error);
+ 
+ 	if (atomic_dec_and_test(&dio->ref)) {
+ 		if (is_sync_kiocb(dio->iocb)) {
+ 			struct task_struct *waiter = dio->submit.waiter;
+ 
+ 			WRITE_ONCE(dio->submit.waiter, NULL);
+ 			wake_up_process(waiter);
+ 		} else if (dio->flags & IOMAP_DIO_WRITE) {
+ 			struct inode *inode = file_inode(dio->iocb->ki_filp);
+ 
+ 			INIT_WORK(&dio->aio.work, iomap_dio_complete_work);
+ 			queue_work(inode->i_sb->s_dio_done_wq, &dio->aio.work);
+ 		} else {
+ 			iomap_dio_complete_work(&dio->aio.work);
+ 		}
+ 	}
+ 
+ 	if (should_dirty) {
+ 		bio_check_pages_dirty(bio);
+ 	} else {
+ 		struct bio_vec *bvec;
+ 		int i;
+ 
+ 		bio_for_each_segment_all(bvec, bio, i)
+ 			put_page(bvec->bv_page);
+ 		bio_put(bio);
+ 	}
+ }
+ 
+ static blk_qc_t
+ iomap_dio_zero(struct iomap_dio *dio, struct iomap *iomap, loff_t pos,
+ 		unsigned len)
+ {
+ 	struct page *page = ZERO_PAGE(0);
+ 	struct bio *bio;
+ 
+ 	bio = bio_alloc(GFP_KERNEL, 1);
+ 	bio->bi_bdev = iomap->bdev;
+ 	bio->bi_iter.bi_sector =
+ 		iomap->blkno + ((pos - iomap->offset) >> 9);
+ 	bio->bi_private = dio;
+ 	bio->bi_end_io = iomap_dio_bio_end_io;
+ 
+ 	get_page(page);
+ 	if (bio_add_page(bio, page, len, 0) != len)
+ 		BUG();
+ 	bio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);
+ 
+ 	atomic_inc(&dio->ref);
+ 	return submit_bio(bio);
+ }
+ 
+ static loff_t
+ iomap_dio_actor(struct inode *inode, loff_t pos, loff_t length,
+ 		void *data, struct iomap *iomap)
+ {
+ 	struct iomap_dio *dio = data;
+ 	unsigned int blkbits = blksize_bits(bdev_logical_block_size(iomap->bdev));
+ 	unsigned int fs_block_size = i_blocksize(inode), pad;
+ 	unsigned int align = iov_iter_alignment(dio->submit.iter);
+ 	struct iov_iter iter;
+ 	struct bio *bio;
+ 	bool need_zeroout = false;
+ 	int nr_pages, ret;
+ 
+ 	if ((pos | length | align) & ((1 << blkbits) - 1))
+ 		return -EINVAL;
+ 
+ 	switch (iomap->type) {
+ 	case IOMAP_HOLE:
+ 		if (WARN_ON_ONCE(dio->flags & IOMAP_DIO_WRITE))
+ 			return -EIO;
+ 		/*FALLTHRU*/
+ 	case IOMAP_UNWRITTEN:
+ 		if (!(dio->flags & IOMAP_DIO_WRITE)) {
+ 			iov_iter_zero(length, dio->submit.iter);
+ 			dio->size += length;
+ 			return length;
+ 		}
+ 		dio->flags |= IOMAP_DIO_UNWRITTEN;
+ 		need_zeroout = true;
+ 		break;
+ 	case IOMAP_MAPPED:
+ 		if (iomap->flags & IOMAP_F_SHARED)
+ 			dio->flags |= IOMAP_DIO_COW;
+ 		if (iomap->flags & IOMAP_F_NEW)
+ 			need_zeroout = true;
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return -EIO;
+ 	}
+ 
+ 	/*
+ 	 * Operate on a partial iter trimmed to the extent we were called for.
+ 	 * We'll update the iter in the dio once we're done with this extent.
+ 	 */
+ 	iter = *dio->submit.iter;
+ 	iov_iter_truncate(&iter, length);
+ 
+ 	nr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);
+ 	if (nr_pages <= 0)
+ 		return nr_pages;
+ 
+ 	if (need_zeroout) {
+ 		/* zero out from the start of the block to the write offset */
+ 		pad = pos & (fs_block_size - 1);
+ 		if (pad)
+ 			iomap_dio_zero(dio, iomap, pos - pad, pad);
+ 	}
+ 
+ 	do {
+ 		if (dio->error)
+ 			return 0;
+ 
+ 		bio = bio_alloc(GFP_KERNEL, nr_pages);
+ 		bio->bi_bdev = iomap->bdev;
+ 		bio->bi_iter.bi_sector =
+ 			iomap->blkno + ((pos - iomap->offset) >> 9);
+ 		bio->bi_private = dio;
+ 		bio->bi_end_io = iomap_dio_bio_end_io;
+ 
+ 		ret = bio_iov_iter_get_pages(bio, &iter);
+ 		if (unlikely(ret)) {
+ 			bio_put(bio);
+ 			return ret;
+ 		}
+ 
+ 		if (dio->flags & IOMAP_DIO_WRITE) {
+ 			bio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);
+ 			task_io_account_write(bio->bi_iter.bi_size);
+ 		} else {
+ 			bio_set_op_attrs(bio, REQ_OP_READ, 0);
+ 			if (dio->flags & IOMAP_DIO_DIRTY)
+ 				bio_set_pages_dirty(bio);
+ 		}
+ 
+ 		dio->size += bio->bi_iter.bi_size;
+ 		pos += bio->bi_iter.bi_size;
+ 
+ 		nr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);
+ 
+ 		atomic_inc(&dio->ref);
+ 
+ 		dio->submit.last_queue = bdev_get_queue(iomap->bdev);
+ 		dio->submit.cookie = submit_bio(bio);
+ 	} while (nr_pages);
+ 
+ 	if (need_zeroout) {
+ 		/* zero out from the end of the write to the end of the block */
+ 		pad = pos & (fs_block_size - 1);
+ 		if (pad)
+ 			iomap_dio_zero(dio, iomap, pos, fs_block_size - pad);
+ 	}
+ 
+ 	iov_iter_advance(dio->submit.iter, length);
+ 	return length;
+ }
+ 
+ ssize_t
+ iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
+ 		const struct iomap_ops *ops, iomap_dio_end_io_t end_io)
+ {
+ 	struct address_space *mapping = iocb->ki_filp->f_mapping;
+ 	struct inode *inode = file_inode(iocb->ki_filp);
+ 	size_t count = iov_iter_count(iter);
+ 	loff_t pos = iocb->ki_pos, start = pos;
+ 	loff_t end = iocb->ki_pos + count - 1, ret = 0;
+ 	unsigned int flags = IOMAP_DIRECT;
+ 	struct blk_plug plug;
+ 	struct iomap_dio *dio;
+ 
+ 	lockdep_assert_held(&inode->i_rwsem);
+ 
+ 	if (!count)
+ 		return 0;
+ 
+ 	dio = kmalloc(sizeof(*dio), GFP_KERNEL);
+ 	if (!dio)
+ 		return -ENOMEM;
+ 
+ 	dio->iocb = iocb;
+ 	atomic_set(&dio->ref, 1);
+ 	dio->size = 0;
+ 	dio->i_size = i_size_read(inode);
+ 	dio->end_io = end_io;
+ 	dio->error = 0;
+ 	dio->flags = 0;
+ 
+ 	dio->submit.iter = iter;
+ 	if (is_sync_kiocb(iocb)) {
+ 		dio->submit.waiter = current;
+ 		dio->submit.cookie = BLK_QC_T_NONE;
+ 		dio->submit.last_queue = NULL;
+ 	}
+ 
+ 	if (iov_iter_rw(iter) == READ) {
+ 		if (pos >= dio->i_size)
+ 			goto out_free_dio;
+ 
+ 		if (iter->type == ITER_IOVEC)
+ 			dio->flags |= IOMAP_DIO_DIRTY;
+ 	} else {
+ 		dio->flags |= IOMAP_DIO_WRITE;
+ 		flags |= IOMAP_WRITE;
+ 	}
+ 
+ 	ret = filemap_write_and_wait_range(mapping, start, end);
+ 	if (ret)
+ 		goto out_free_dio;
+ 
+ 	ret = invalidate_inode_pages2_range(mapping,
+ 			start >> PAGE_SHIFT, end >> PAGE_SHIFT);
+ 	WARN_ON_ONCE(ret);
+ 	ret = 0;
+ 
+ 	inode_dio_begin(inode);
+ 
+ 	blk_start_plug(&plug);
+ 	do {
+ 		ret = iomap_apply(inode, pos, count, flags, ops, dio,
+ 				iomap_dio_actor);
+ 		if (ret <= 0) {
+ 			/* magic error code to fall back to buffered I/O */
+ 			if (ret == -ENOTBLK)
+ 				ret = 0;
+ 			break;
+ 		}
+ 		pos += ret;
+ 
+ 		if (iov_iter_rw(iter) == READ && pos >= dio->i_size)
+ 			break;
+ 	} while ((count = iov_iter_count(iter)) > 0);
+ 	blk_finish_plug(&plug);
+ 
+ 	if (ret < 0)
+ 		iomap_dio_set_error(dio, ret);
+ 
+ 	if (ret >= 0 && iov_iter_rw(iter) == WRITE && !is_sync_kiocb(iocb) &&
+ 			!inode->i_sb->s_dio_done_wq) {
+ 		ret = sb_init_dio_done_wq(inode->i_sb);
+ 		if (ret < 0)
+ 			iomap_dio_set_error(dio, ret);
+ 	}
+ 
+ 	if (!atomic_dec_and_test(&dio->ref)) {
+ 		if (!is_sync_kiocb(iocb))
+ 			return -EIOCBQUEUED;
+ 
+ 		for (;;) {
+ 			set_current_state(TASK_UNINTERRUPTIBLE);
+ 			if (!READ_ONCE(dio->submit.waiter))
+ 				break;
+ 
+ 			if (!(iocb->ki_flags & IOCB_HIPRI) ||
+ 			    !dio->submit.last_queue ||
+ 			    !blk_mq_poll(dio->submit.last_queue,
+ 					 dio->submit.cookie))
+ 				io_schedule();
+ 		}
+ 		__set_current_state(TASK_RUNNING);
+ 	}
+ 
+ 	ret = iomap_dio_complete(dio);
+ 
+ 	/*
+ 	 * Try again to invalidate clean pages which might have been cached by
+ 	 * non-direct readahead, or faulted in by get_user_pages() if the source
+ 	 * of the write was an mmap'ed region of the file we're writing.  Either
+ 	 * one is a pretty crazy thing to do, so we don't support it 100%.  If
+ 	 * this invalidation fails, tough, the write still worked...
+ 	 */
+ 	if (iov_iter_rw(iter) == WRITE) {
+ 		int err = invalidate_inode_pages2_range(mapping,
+ 				start >> PAGE_SHIFT, end >> PAGE_SHIFT);
+ 		WARN_ON_ONCE(err);
+ 	}
+ 
+ 	return ret;
+ 
+ out_free_dio:
+ 	kfree(dio);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(iomap_dio_rw);
++>>>>>>> 0ed3b0d45fd3 (vfs: Add iomap_seek_hole and iomap_seek_data helpers)
diff --cc include/linux/iomap.h
index c74226a738a3,8a03f5dcd89b..000000000000
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@@ -64,16 -73,29 +64,34 @@@ struct iomap_ops 
  };
  
  ssize_t iomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *from,
 -		const struct iomap_ops *ops);
 +		struct iomap_ops *ops);
  int iomap_file_dirty(struct inode *inode, loff_t pos, loff_t len,
 -		const struct iomap_ops *ops);
 +		struct iomap_ops *ops);
  int iomap_zero_range(struct inode *inode, loff_t pos, loff_t len,
 -		bool *did_zero, const struct iomap_ops *ops);
 +		bool *did_zero, struct iomap_ops *ops);
  int iomap_truncate_page(struct inode *inode, loff_t pos, bool *did_zero,
 -		const struct iomap_ops *ops);
 -int iomap_page_mkwrite(struct vm_fault *vmf, const struct iomap_ops *ops);
 +		struct iomap_ops *ops);
 +int iomap_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 +		struct iomap_ops *ops);
  int iomap_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
++<<<<<<< HEAD
 +		loff_t start, loff_t len, struct iomap_ops *ops);
++=======
+ 		loff_t start, loff_t len, const struct iomap_ops *ops);
+ loff_t iomap_seek_hole(struct inode *inode, loff_t offset,
+ 		const struct iomap_ops *ops);
+ loff_t iomap_seek_data(struct inode *inode, loff_t offset,
+ 		const struct iomap_ops *ops);
+ 
+ /*
+  * Flags for direct I/O ->end_io:
+  */
+ #define IOMAP_DIO_UNWRITTEN	(1 << 0)	/* covers unwritten extent(s) */
+ #define IOMAP_DIO_COW		(1 << 1)	/* covers COW extent(s) */
+ typedef int (iomap_dio_end_io_t)(struct kiocb *iocb, ssize_t ret,
+ 		unsigned flags);
+ ssize_t iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
+ 		const struct iomap_ops *ops, iomap_dio_end_io_t end_io);
++>>>>>>> 0ed3b0d45fd3 (vfs: Add iomap_seek_hole and iomap_seek_data helpers)
  
  #endif /* LINUX_IOMAP_H */
* Unmerged path fs/iomap.c
* Unmerged path include/linux/iomap.h
