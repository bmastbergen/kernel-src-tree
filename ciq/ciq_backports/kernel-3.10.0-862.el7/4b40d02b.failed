scsi: lpfc: Fix crash in lpfc nvmet when fc port is reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix crash in lpfc nvmet when fc port is reset (Dick Kennedy) [1385844 1461977 1387768]
Rebuild_FUZZ: 94.44%
commit-author Dick Kennedy <dick.kennedy@broadcom.com>
commit 4b40d02b8b2bd549c7751a3c4629077ea5f9a1fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4b40d02b.failed

In adapter reset tests, an oops was seen with a NULL pointer in
lpfc_free_rq_buffer+0x20/0x60

The driver is failing to properly repost the nvmet sgl list when
recovering from the reset. Thus the driver eventually trys to walk an
errant buffer list.

Corrected the sgl buffer recovery as well as strengthening the
initialization of the bufferlist.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4b40d02b8b2bd549c7751a3c4629077ea5f9a1fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index bad9d528b08b,f82618a8918f..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -6010,6 -6499,39 +6017,42 @@@ lpfc_free_els_sgl_list(struct lpfc_hba 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * lpfc_free_nvmet_sgl_list - Free nvmet sgl list.
+  * @phba: pointer to lpfc hba data structure.
+  *
+  * This routine is invoked to free the driver's nvmet sgl list and memory.
+  **/
+ static void
+ lpfc_free_nvmet_sgl_list(struct lpfc_hba *phba)
+ {
+ 	struct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;
+ 	LIST_HEAD(sglq_list);
+ 
+ 	/* Retrieve all nvmet sgls from driver list */
+ 	spin_lock_irq(&phba->hbalock);
+ 	spin_lock(&phba->sli4_hba.sgl_list_lock);
+ 	list_splice_init(&phba->sli4_hba.lpfc_nvmet_sgl_list, &sglq_list);
+ 	spin_unlock(&phba->sli4_hba.sgl_list_lock);
+ 	spin_unlock_irq(&phba->hbalock);
+ 
+ 	/* Now free the sgl list */
+ 	list_for_each_entry_safe(sglq_entry, sglq_next, &sglq_list, list) {
+ 		list_del(&sglq_entry->list);
+ 		lpfc_nvmet_buf_free(phba, sglq_entry->virt, sglq_entry->phys);
+ 		kfree(sglq_entry);
+ 	}
+ 
+ 	/* Update the nvmet_xri_cnt to reflect no current sgls.
+ 	 * The next initialization cycle sets the count and allocates
+ 	 * the sgls over again.
+ 	 */
+ 	phba->sli4_hba.nvmet_xri_cnt = 0;
+ }
+ 
+ /**
++>>>>>>> 4b40d02b8b2b (scsi: lpfc: Fix crash in lpfc nvmet when fc port is reset)
   * lpfc_init_active_sgl_array - Allocate the buf to track active ELS XRIs.
   * @phba: pointer to lpfc hba data structure.
   *
@@@ -7589,6 -8290,47 +7632,50 @@@ lpfc_sli4_queue_create(struct lpfc_hba 
  	}
  	phba->sli4_hba.dat_rq = qdesc;
  
++<<<<<<< HEAD
++=======
+ 	if (phba->nvmet_support) {
+ 		for (idx = 0; idx < phba->cfg_nvmet_mrq; idx++) {
+ 			/* Create NVMET Receive Queue for header */
+ 			qdesc = lpfc_sli4_queue_alloc(phba,
+ 						      phba->sli4_hba.rq_esize,
+ 						      LPFC_NVMET_RQE_DEF_COUNT);
+ 			if (!qdesc) {
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"3146 Failed allocate "
+ 						"receive HRQ\n");
+ 				goto out_error;
+ 			}
+ 			phba->sli4_hba.nvmet_mrq_hdr[idx] = qdesc;
+ 
+ 			/* Only needed for header of RQ pair */
+ 			qdesc->rqbp = kzalloc(sizeof(struct lpfc_rqb),
+ 					      GFP_KERNEL);
+ 			if (qdesc->rqbp == NULL) {
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"6131 Failed allocate "
+ 						"Header RQBP\n");
+ 				goto out_error;
+ 			}
+ 
+ 			/* Put list in known state in case driver load fails. */
+ 			INIT_LIST_HEAD(&qdesc->rqbp->rqb_buffer_list);
+ 
+ 			/* Create NVMET Receive Queue for data */
+ 			qdesc = lpfc_sli4_queue_alloc(phba,
+ 						      phba->sli4_hba.rq_esize,
+ 						      LPFC_NVMET_RQE_DEF_COUNT);
+ 			if (!qdesc) {
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"3156 Failed allocate "
+ 						"receive DRQ\n");
+ 				goto out_error;
+ 			}
+ 			phba->sli4_hba.nvmet_mrq_data[idx] = qdesc;
+ 		}
+ 	}
+ 
++>>>>>>> 4b40d02b8b2b (scsi: lpfc: Fix crash in lpfc nvmet when fc port is reset)
  	/* Create the Queues needed for Flash Optimized Fabric operations */
  	if (phba->cfg_fof)
  		lpfc_fof_queue_create(phba);
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
