RDMA/netlink: Add and implement doit netlink callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [infiniband] netlink: Add and implement doit netlink callback (Don Dutile) [1499364]
Rebuild_FUZZ: 95.05%
commit-author Leon Romanovsky <leonro@mellanox.com>
commit 1830ba21b9a475cfc6159e6cfe532c75fe7682a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1830ba21.failed

The .doit callback is used by netlink core to differentiate
between get and set operations. Common convention is to use
that call for command operations like (SET, ADD, e.t.c.) and/or
access without NLF_M_DUMP flag.

This commit adds proper declaration and implementation
to RDMA netlink.

	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
(cherry picked from commit 1830ba21b9a475cfc6159e6cfe532c75fe7682a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/netlink.c
#	include/rdma/rdma_netlink.h
diff --cc drivers/infiniband/core/netlink.c
index 66c3e82b1b77,484d6a8a2811..000000000000
--- a/drivers/infiniband/core/netlink.c
+++ b/drivers/infiniband/core/netlink.c
@@@ -39,76 -39,92 +39,89 @@@
  #include <rdma/rdma_netlink.h>
  #include "core_priv.h"
  
 -#include "core_priv.h"
 -
 -static DEFINE_MUTEX(rdma_nl_mutex);
 +struct ibnl_client {
 +	struct list_head		list;
 +	int				index;
 +	int				nops;
 +	const struct ibnl_client_cbs   *cb_table;
 +};
 +
 +static DEFINE_MUTEX(ibnl_mutex);
  static struct sock *nls;
 -static struct {
 -	const struct rdma_nl_cbs   *cb_table;
 -} rdma_nl_types[RDMA_NL_NUM_CLIENTS];
 -
 -int rdma_nl_chk_listeners(unsigned int group)
 -{
 -	return (netlink_has_listeners(nls, group)) ? 0 : -1;
 -}
 -EXPORT_SYMBOL(rdma_nl_chk_listeners);
 +static LIST_HEAD(client_list);
  
 -static bool is_nl_msg_valid(unsigned int type, unsigned int op)
 +int ibnl_chk_listeners(unsigned int group)
  {
 -	static const unsigned int max_num_ops[RDMA_NL_NUM_CLIENTS - 1] = {
 -				  RDMA_NL_RDMA_CM_NUM_OPS,
 -				  RDMA_NL_IWPM_NUM_OPS,
 -				  0,
 -				  RDMA_NL_LS_NUM_OPS,
 -				  0 };
 -
 -	/*
 -	 * This BUILD_BUG_ON is intended to catch addition of new
 -	 * RDMA netlink protocol without updating the array above.
 -	 */
 -	BUILD_BUG_ON(RDMA_NL_NUM_CLIENTS != 6);
 -
 -	if (type > RDMA_NL_NUM_CLIENTS - 1)
 -		return false;
 -
 -	return (op < max_num_ops[type - 1]) ? true : false;
 +	if (netlink_has_listeners(nls, group) == 0)
 +		return -1;
 +	return 0;
  }
  
 -static bool is_nl_valid(unsigned int type, unsigned int op)
 +int ibnl_add_client(int index, int nops,
 +		    const struct ibnl_client_cbs cb_table[])
  {
++<<<<<<< HEAD
 +	struct ibnl_client *cur;
 +	struct ibnl_client *nl_client;
++=======
+ 	const struct rdma_nl_cbs *cb_table;
+ 
+ 	if (!is_nl_msg_valid(type, op))
+ 		return false;
+ 
+ 	cb_table = rdma_nl_types[type].cb_table;
+ 	if (!cb_table || (!cb_table[op].dump && !cb_table[op].doit))
+ 		return false;
+ 	return true;
+ }
++>>>>>>> 1830ba21b9a4 (RDMA/netlink: Add and implement doit netlink callback)
  
 -void rdma_nl_register(unsigned int index,
 -		      const struct rdma_nl_cbs cb_table[])
 -{
 -	mutex_lock(&rdma_nl_mutex);
 -	if (!is_nl_msg_valid(index, 0)) {
 -		/*
 -		 * All clients are not interesting in success/failure of
 -		 * this call. They want to see the print to error log and
 -		 * continue their initialization. Print warning for them,
 -		 * because it is programmer's error to be here.
 -		 */
 -		mutex_unlock(&rdma_nl_mutex);
 -		WARN(true,
 -		     "The not-valid %u index was supplied to RDMA netlink\n",
 -		     index);
 -		return;
 -	}
 +	nl_client = kmalloc(sizeof *nl_client, GFP_KERNEL);
 +	if (!nl_client)
 +		return -ENOMEM;
  
 -	if (rdma_nl_types[index].cb_table) {
 -		mutex_unlock(&rdma_nl_mutex);
 -		WARN(true,
 -		     "The %u index is already registered in RDMA netlink\n",
 -		     index);
 -		return;
 +	nl_client->index	= index;
 +	nl_client->nops		= nops;
 +	nl_client->cb_table	= cb_table;
 +
 +	mutex_lock(&ibnl_mutex);
 +
 +	list_for_each_entry(cur, &client_list, list) {
 +		if (cur->index == index) {
 +			pr_warn("Client for %d already exists\n", index);
 +			mutex_unlock(&ibnl_mutex);
 +			kfree(nl_client);
 +			return -EINVAL;
 +		}
  	}
  
 -	rdma_nl_types[index].cb_table = cb_table;
 -	mutex_unlock(&rdma_nl_mutex);
 +	list_add_tail(&nl_client->list, &client_list);
 +
 +	mutex_unlock(&ibnl_mutex);
 +
 +	return 0;
  }
 -EXPORT_SYMBOL(rdma_nl_register);
 +EXPORT_SYMBOL(ibnl_add_client);
  
 -void rdma_nl_unregister(unsigned int index)
 +int ibnl_remove_client(int index)
  {
 -	mutex_lock(&rdma_nl_mutex);
 -	rdma_nl_types[index].cb_table = NULL;
 -	mutex_unlock(&rdma_nl_mutex);
 +	struct ibnl_client *cur, *next;
 +
 +	mutex_lock(&ibnl_mutex);
 +	list_for_each_entry_safe(cur, next, &client_list, list) {
 +		if (cur->index == index) {
 +			list_del(&(cur->list));
 +			mutex_unlock(&ibnl_mutex);
 +			kfree(cur);
 +			return 0;
 +		}
 +	}
 +	pr_warn("Can't remove callback for client idx %d. Not found\n", index);
 +	mutex_unlock(&ibnl_mutex);
 +
 +	return -EINVAL;
  }
 -EXPORT_SYMBOL(rdma_nl_unregister);
 +EXPORT_SYMBOL(ibnl_remove_client);
  
  void *ibnl_put_msg(struct sk_buff *skb, struct nlmsghdr **nlh, int seq,
  		   int len, int client, int op, int flags)
@@@ -131,71 -147,90 +144,99 @@@ int ibnl_put_attr(struct sk_buff *skb, 
  }
  EXPORT_SYMBOL(ibnl_put_attr);
  
 -static int rdma_nl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,
 -			   struct netlink_ext_ack *extack)
 +static int ibnl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
  {
 +	struct ibnl_client *client;
  	int type = nlh->nlmsg_type;
 -	unsigned int index = RDMA_NL_GET_CLIENT(type);
 +	int index = RDMA_NL_GET_CLIENT(type);
  	unsigned int op = RDMA_NL_GET_OP(type);
++<<<<<<< HEAD
++=======
+ 	struct netlink_callback cb = {};
+ 	struct netlink_dump_control c = {};
+ 	int ret;
 -
 -	if (!is_nl_valid(index, op))
 -		return -EINVAL;
 -
 -	if ((rdma_nl_types[index].cb_table[op].flags & RDMA_NL_ADMIN_PERM) &&
 -	    !netlink_capable(skb, CAP_NET_ADMIN))
 -		return -EPERM;
 -
++>>>>>>> 1830ba21b9a4 (RDMA/netlink: Add and implement doit netlink callback)
 +
 +	list_for_each_entry(client, &client_list, list) {
 +		if (client->index == index) {
 +			if (op >= client->nops || !client->cb_table[op].dump)
 +				return -EINVAL;
 +
 +			/*
 +			 * For response or local service set_timeout request,
 +			 * there is no need to use netlink_dump_start.
 +			 */
 +			if (!(nlh->nlmsg_flags & NLM_F_REQUEST) ||
 +			    (index == RDMA_NL_LS &&
 +			     op == RDMA_NL_LS_OP_SET_TIMEOUT)) {
 +				struct netlink_callback cb = {
 +					.skb = skb,
 +					.nlh = nlh,
 +					.dump = client->cb_table[op].dump,
 +					.module = client->cb_table[op].module,
 +				};
 +
++<<<<<<< HEAD
 +				return cb.dump(skb, &cb);
 +			}
 +
 +			{
 +				struct netlink_dump_control c = {
 +					.dump = client->cb_table[op].dump,
 +					.module = client->cb_table[op].module,
 +				};
 +				return netlink_dump_start(nls, skb, nlh, &c);
 +			}
 +		}
++=======
+ 	/*
+ 	 * For response or local service set_timeout request,
+ 	 * there is no need to use netlink_dump_start.
+ 	 */
+ 	if (!(nlh->nlmsg_flags & NLM_F_REQUEST) ||
+ 	    (index == RDMA_NL_LS && op == RDMA_NL_LS_OP_SET_TIMEOUT)) {
+ 		cb.skb = skb;
+ 		cb.nlh = nlh;
+ 		cb.dump = rdma_nl_types[index].cb_table[op].dump;
+ 		return cb.dump(skb, &cb);
+ 	} else {
+ 		c.dump = rdma_nl_types[index].cb_table[op].dump;
+ 		return netlink_dump_start(nls, skb, nlh, &c);
++>>>>>>> 1830ba21b9a4 (RDMA/netlink: Add and implement doit netlink callback)
  	}
+ 	if (rdma_nl_types[index].cb_table[op].doit)
+ 		ret = rdma_nl_types[index].cb_table[op].doit(skb, nlh, extack);
+ 	return ret;
  
++<<<<<<< HEAD
 +	pr_info("Index %d wasn't found in client list\n", index);
 +	return -EINVAL;
++=======
++>>>>>>> 1830ba21b9a4 (RDMA/netlink: Add and implement doit netlink callback)
  }
  
 -/*
 - * This function is similar to netlink_rcv_skb with one exception:
 - * It calls to the callback for the netlink messages without NLM_F_REQUEST
 - * flag. These messages are intended for RDMA_NL_LS consumer, so it is allowed
 - * for that consumer only.
 - */
 -static int rdma_nl_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,
 -						   struct nlmsghdr *,
 -						   struct netlink_ext_ack *))
 +static void ibnl_rcv_reply_skb(struct sk_buff *skb)
  {
 -	struct netlink_ext_ack extack = {};
  	struct nlmsghdr *nlh;
 -	int err;
 +	int msglen;
  
 +	/*
 +	 * Process responses until there is no more message or the first
 +	 * request. Generally speaking, it is not recommended to mix responses
 +	 * with requests.
 +	 */
  	while (skb->len >= nlmsg_total_size(0)) {
 -		int msglen;
 -
  		nlh = nlmsg_hdr(skb);
 -		err = 0;
  
  		if (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)
 -			return 0;
 +			return;
 +
 +		/* Handle response only */
 +		if (nlh->nlmsg_flags & NLM_F_REQUEST)
 +			return;
 +
 +		ibnl_rcv_msg(skb, nlh);
  
 -		/*
 -		 * Generally speaking, the only requests are handled
 -		 * by the kernel, but RDMA_NL_LS is different, because it
 -		 * runs backward netlink scheme. Kernel initiates messages
 -		 * and waits for reply with data to keep pathrecord cache
 -		 * in sync.
 -		 */
 -		if (!(nlh->nlmsg_flags & NLM_F_REQUEST) &&
 -		    (RDMA_NL_GET_CLIENT(nlh->nlmsg_type) != RDMA_NL_LS))
 -			goto ack;
 -
 -		/* Skip control messages */
 -		if (nlh->nlmsg_type < NLMSG_MIN_TYPE)
 -			goto ack;
 -
 -		err = cb(skb, nlh, &extack);
 -		if (err == -EINTR)
 -			goto skip;
 -
 -ack:
 -		if (nlh->nlmsg_flags & NLM_F_ACK || err)
 -			netlink_ack(skb, nlh, err, &extack);
 -
 -skip:
  		msglen = NLMSG_ALIGN(nlh->nlmsg_len);
  		if (msglen > skb->len)
  			msglen = skb->len;
diff --cc include/rdma/rdma_netlink.h
index 3d228061a9e1,e25bf1988846..000000000000
--- a/include/rdma/rdma_netlink.h
+++ b/include/rdma/rdma_netlink.h
@@@ -5,9 -5,16 +5,15 @@@
  #include <linux/netlink.h>
  #include <uapi/rdma/rdma_netlink.h>
  
++<<<<<<< HEAD
 +struct ibnl_client_cbs {
++=======
+ struct rdma_nl_cbs {
+ 	int (*doit)(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 		    struct netlink_ext_ack *extack);
++>>>>>>> 1830ba21b9a4 (RDMA/netlink: Add and implement doit netlink callback)
  	int (*dump)(struct sk_buff *skb, struct netlink_callback *nlcb);
 -	u8 flags;
 -};
 -
 -enum rdma_nl_flags {
 -	/* Require CAP_NET_ADMIN */
 -	RDMA_NL_ADMIN_PERM	= 1 << 0,
 +	struct module *module;
  };
  
  /**
* Unmerged path drivers/infiniband/core/netlink.c
* Unmerged path include/rdma/rdma_netlink.h
