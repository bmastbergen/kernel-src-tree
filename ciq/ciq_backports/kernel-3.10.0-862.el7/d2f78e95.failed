dmaengine: dw: enable clock before access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [sound] alsa: dmaengine: dw: enable clock before access (Jaroslav Kysela) [1463624]
Rebuild_FUZZ: 93.18%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit d2f78e95e42a9130002c76f1a1f76e657a4b4004
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d2f78e95.failed

hclk signal is a bus clock. So, it means we have to have it enabled during
access to the DMA controller. This patch makes sure that we enable clock before
access to the device, though it currently works on Intel hardware.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit d2f78e95e42a9130002c76f1a1f76e657a4b4004)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/dw_dmac.c
diff --cc drivers/dma/dw_dmac.c
index 5d0ba000e772,009dc62f9437..000000000000
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@@ -1666,35 -1486,25 +1666,44 @@@ static int dw_probe(struct platform_dev
  	int			err;
  	int			i;
  
 -	dw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);
 -	if (!dw)
 -		return -ENOMEM;
 +	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +	if (!io)
 +		return -EINVAL;
 +
 +	irq = platform_get_irq(pdev, 0);
 +	if (irq < 0)
 +		return irq;
  
 -	dw->regs = chip->regs;
 -	chip->dw = dw;
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	regs = devm_ioremap_resource(&pdev->dev, io);
 +	if (IS_ERR(regs))
 +		return PTR_ERR(regs);
  
 +	/* Apply default dma_mask if needed */
 +	if (!pdev->dev.dma_mask) {
 +		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
 +		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 +	}
 +
 +	dw_params = dma_read_byaddr(regs, DW_PARAMS);
++=======
+ 	dw->clk = devm_clk_get(chip->dev, "hclk");
+ 	if (IS_ERR(dw->clk))
+ 		return PTR_ERR(dw->clk);
+ 	clk_prepare_enable(dw->clk);
+ 
+ 	dw_params = dma_read_byaddr(chip->regs, DW_PARAMS);
++>>>>>>> d2f78e95e42a (dmaengine: dw: enable clock before access):drivers/dma/dw/core.c
  	autocfg = dw_params >> DW_PARAMS_EN & 0x1;
  
 -	dev_dbg(chip->dev, "DW_PARAMS: 0x%08x\n", dw_params);
 +	dev_dbg(&pdev->dev, "DW_PARAMS: 0x%08x\n", dw_params);
 +
 +	pdata = dev_get_platdata(&pdev->dev);
 +	if (!pdata)
 +		pdata = dw_dma_parse_dt(pdev);
  
  	if (!pdata && autocfg) {
 -		pdata = devm_kzalloc(chip->dev, sizeof(*pdata), GFP_KERNEL);
 +		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
  		if (!pdata)
  			return -ENOMEM;
  
@@@ -1710,18 -1520,11 +1719,21 @@@
  	else
  		nr_channels = pdata->nr_channels;
  
 -	dw->chan = devm_kcalloc(chip->dev, nr_channels, sizeof(*dw->chan),
 -				GFP_KERNEL);
 -	if (!dw->chan)
 +	size = sizeof(struct dw_dma) + nr_channels * sizeof(struct dw_dma_chan);
 +	dw = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
 +	if (!dw)
  		return -ENOMEM;
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	dw->clk = devm_clk_get(&pdev->dev, "hclk");
 +	if (IS_ERR(dw->clk))
 +		return PTR_ERR(dw->clk);
 +	clk_prepare_enable(dw->clk);
 +
 +	dw->regs = regs;
 +
++=======
++>>>>>>> d2f78e95e42a (dmaengine: dw: enable clock before access):drivers/dma/dw/core.c
  	/* Get hardware configuration parameters */
  	if (autocfg) {
  		max_blk_size = dma_readl(dw, MAX_BLK_SIZE);
* Unmerged path drivers/dma/dw_dmac.c
