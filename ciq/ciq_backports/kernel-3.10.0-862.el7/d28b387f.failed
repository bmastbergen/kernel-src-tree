KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author KarimAllah Ahmed <karahmed@amazon.de>
commit d28b387fb74da95d69d2615732f50cceb38e9a4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d28b387f.failed

[ Based on a patch from Ashok Raj <ashok.raj@intel.com> ]

Add direct access to MSR_IA32_SPEC_CTRL for guests. This is needed for
guests that will only mitigate Spectre V2 through IBRS+IBPB and will not
be using a retpoline+IBPB based approach.

To avoid the overhead of saving and restoring the MSR_IA32_SPEC_CTRL for
guests that do not actually use the MSR, only start saving and restoring
when a non-zero is written to it.

No attempt is made to handle STIBP here, intentionally. Filtering STIBP
may be added in a future patch, which may require trapping all writes
if we don't want to pass it through directly to the guest.

[dwmw2: Clean up CPUID bits, save/restore manually, handle reset]

	Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
	Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jun Nakajima <jun.nakajima@intel.com>
	Cc: kvm@vger.kernel.org
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Asit Mallick <asit.k.mallick@intel.com>
	Cc: Arjan Van De Ven <arjan.van.de.ven@intel.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Ashok Raj <ashok.raj@intel.com>
Link: https://lkml.kernel.org/r/1517522386-18410-5-git-send-email-karahmed@amazon.de

(cherry picked from commit d28b387fb74da95d69d2615732f50cceb38e9a4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/cpuid.c
index 1e22c91417fc,13f5d4217e4f..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -351,8 -365,12 +351,15 @@@ static inline int __do_cpuid_ent(struc
  		F(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |
  		0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM);
  
++<<<<<<< HEAD
++=======
+ 	/* cpuid 0x80000008.ebx */
+ 	const u32 kvm_cpuid_8000_0008_ebx_x86_features =
+ 		F(IBPB) | F(IBRS);
+ 
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	/* cpuid 0xC0000001.edx */
 -	const u32 kvm_cpuid_C000_0001_edx_x86_features =
 +	const u32 kvm_supported_word5_x86_features =
  		F(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |
  		F(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |
  		F(PMM) | F(PMM_EN);
@@@ -375,7 -394,8 +382,12 @@@
  
  	/* cpuid 7.0.edx*/
  	const u32 kvm_cpuid_7_0_edx_x86_features =
++<<<<<<< HEAD
 +		KF(AVX512_4VNNIW) | KF(AVX512_4FMAPS);
++=======
+ 		F(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) |
+ 		F(ARCH_CAPABILITIES);
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  
  	/* all calls to cpuid_count() should be made on the same cpu */
  	get_cpu();
@@@ -607,7 -630,14 +619,18 @@@
  		if (!g_phys_as)
  			g_phys_as = phys_as;
  		entry->eax = g_phys_as | (virt_as << 8);
++<<<<<<< HEAD
 +		entry->ebx = entry->edx = 0;
++=======
+ 		entry->edx = 0;
+ 		/* IBRS and IBPB aren't necessarily present in hardware cpuid */
+ 		if (boot_cpu_has(X86_FEATURE_IBPB))
+ 			entry->ebx |= F(IBPB);
+ 		if (boot_cpu_has(X86_FEATURE_IBRS))
+ 			entry->ebx |= F(IBRS);
+ 		entry->ebx &= kvm_cpuid_8000_0008_ebx_x86_features;
+ 		cpuid_mask(&entry->ebx, CPUID_8000_0008_EBX);
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  		break;
  	}
  	case 0x80000019:
diff --cc arch/x86/kvm/vmx.c
index 553a3a9096ee,bee4c49f6dd0..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -546,8 -593,14 +546,15 @@@ struct vcpu_vmx 
  	u64 		      msr_host_kernel_gs_base;
  	u64 		      msr_guest_kernel_gs_base;
  #endif
++<<<<<<< HEAD
++=======
+ 
+ 	u64 		      arch_capabilities;
+ 	u64 		      spec_ctrl;
+ 
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	u32 vm_entry_controls_shadow;
  	u32 vm_exit_controls_shadow;
 -	u32 secondary_exec_control;
 -
  	/*
  	 * loaded_vmcs points to the VMCS currently used in this vcpu. For a
  	 * non-nested (L1) guest, it always points to vmcs01. For a nested
@@@ -1701,6 -1911,52 +1708,55 @@@ static void update_exception_bitmap(str
  	vmcs_write32(EXCEPTION_BITMAP, eb);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Check if MSR is intercepted for currently loaded MSR bitmap.
+  */
+ static bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)
+ {
+ 	unsigned long *msr_bitmap;
+ 	int f = sizeof(unsigned long);
+ 
+ 	if (!cpu_has_vmx_msr_bitmap())
+ 		return true;
+ 
+ 	msr_bitmap = to_vmx(vcpu)->loaded_vmcs->msr_bitmap;
+ 
+ 	if (msr <= 0x1fff) {
+ 		return !!test_bit(msr, msr_bitmap + 0x800 / f);
+ 	} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {
+ 		msr &= 0x1fff;
+ 		return !!test_bit(msr, msr_bitmap + 0xc00 / f);
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /*
+  * Check if MSR is intercepted for L01 MSR bitmap.
+  */
+ static bool msr_write_intercepted_l01(struct kvm_vcpu *vcpu, u32 msr)
+ {
+ 	unsigned long *msr_bitmap;
+ 	int f = sizeof(unsigned long);
+ 
+ 	if (!cpu_has_vmx_msr_bitmap())
+ 		return true;
+ 
+ 	msr_bitmap = to_vmx(vcpu)->vmcs01.msr_bitmap;
+ 
+ 	if (msr <= 0x1fff) {
+ 		return !!test_bit(msr, msr_bitmap + 0x800 / f);
+ 	} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {
+ 		msr &= 0x1fff;
+ 		return !!test_bit(msr, msr_bitmap + 0xc00 / f);
+ 	}
+ 
+ 	return true;
+ }
+ 
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  static void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,
  		unsigned long entry, unsigned long exit)
  {
@@@ -2833,6 -3286,20 +2889,23 @@@ static int vmx_get_msr(struct kvm_vcpu 
  	case MSR_IA32_TSC:
  		msr_info->data = guest_read_tsc(vcpu);
  		break;
++<<<<<<< HEAD
++=======
+ 	case MSR_IA32_SPEC_CTRL:
+ 		if (!msr_info->host_initiated &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_IBRS) &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))
+ 			return 1;
+ 
+ 		msr_info->data = to_vmx(vcpu)->spec_ctrl;
+ 		break;
+ 	case MSR_IA32_ARCH_CAPABILITIES:
+ 		if (!msr_info->host_initiated &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))
+ 			return 1;
+ 		msr_info->data = to_vmx(vcpu)->arch_capabilities;
+ 		break;
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	case MSR_IA32_SYSENTER_CS:
  		msr_info->data = vmcs_read32(GUEST_SYSENTER_CS);
  		break;
@@@ -2933,6 -3407,70 +3006,73 @@@ static int vmx_set_msr(struct kvm_vcpu 
  	case MSR_IA32_TSC:
  		kvm_write_tsc(vcpu, msr_info);
  		break;
++<<<<<<< HEAD
++=======
+ 	case MSR_IA32_SPEC_CTRL:
+ 		if (!msr_info->host_initiated &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_IBRS) &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))
+ 			return 1;
+ 
+ 		/* The STIBP bit doesn't fault even if it's not advertised */
+ 		if (data & ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP))
+ 			return 1;
+ 
+ 		vmx->spec_ctrl = data;
+ 
+ 		if (!data)
+ 			break;
+ 
+ 		/*
+ 		 * For non-nested:
+ 		 * When it's written (to non-zero) for the first time, pass
+ 		 * it through.
+ 		 *
+ 		 * For nested:
+ 		 * The handling of the MSR bitmap for L2 guests is done in
+ 		 * nested_vmx_merge_msr_bitmap. We should not touch the
+ 		 * vmcs02.msr_bitmap here since it gets completely overwritten
+ 		 * in the merging. We update the vmcs01 here for L1 as well
+ 		 * since it will end up touching the MSR anyway now.
+ 		 */
+ 		vmx_disable_intercept_for_msr(vmx->vmcs01.msr_bitmap,
+ 					      MSR_IA32_SPEC_CTRL,
+ 					      MSR_TYPE_RW);
+ 		break;
+ 	case MSR_IA32_PRED_CMD:
+ 		if (!msr_info->host_initiated &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_IBPB) &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))
+ 			return 1;
+ 
+ 		if (data & ~PRED_CMD_IBPB)
+ 			return 1;
+ 
+ 		if (!data)
+ 			break;
+ 
+ 		wrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);
+ 
+ 		/*
+ 		 * For non-nested:
+ 		 * When it's written (to non-zero) for the first time, pass
+ 		 * it through.
+ 		 *
+ 		 * For nested:
+ 		 * The handling of the MSR bitmap for L2 guests is done in
+ 		 * nested_vmx_merge_msr_bitmap. We should not touch the
+ 		 * vmcs02.msr_bitmap here since it gets completely overwritten
+ 		 * in the merging.
+ 		 */
+ 		vmx_disable_intercept_for_msr(vmx->vmcs01.msr_bitmap, MSR_IA32_PRED_CMD,
+ 					      MSR_TYPE_W);
+ 		break;
+ 	case MSR_IA32_ARCH_CAPABILITIES:
+ 		if (!msr_info->host_initiated)
+ 			return 1;
+ 		vmx->arch_capabilities = data;
+ 		break;
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	case MSR_IA32_CR_PAT:
  		if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {
  			if (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))
@@@ -4955,9 -5763,8 +5095,10 @@@ static void vmx_vcpu_reset(struct kvm_v
  	u64 cr0;
  
  	vmx->rmode.vm86_active = 0;
+ 	vmx->spec_ctrl = 0;
  
 +	vmx->soft_vnmi_blocked = 0;
 +
  	vmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();
  	kvm_set_cr8(vcpu, 0);
  
@@@ -8668,6 -9428,22 +8809,20 @@@ static void __noclone vmx_vcpu_run(stru
  	atomic_switch_perf_msrs(vmx);
  	debugctlmsr = get_debugctlmsr();
  
++<<<<<<< HEAD
++=======
+ 	vmx_arm_hv_timer(vcpu);
+ 
+ 	/*
+ 	 * If this vCPU has touched SPEC_CTRL, restore the guest's value if
+ 	 * it's non-zero. Since vmentry is serialising on affected CPUs, there
+ 	 * is no need to worry about the conditional branch over the wrmsr
+ 	 * being speculatively taken.
+ 	 */
+ 	if (vmx->spec_ctrl)
+ 		wrmsrl(MSR_IA32_SPEC_CTRL, vmx->spec_ctrl);
+ 
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	vmx->__launched = vmx->loaded_vmcs->launched;
  	asm(
  		/* Store host registers */
@@@ -8774,6 -9562,30 +8929,33 @@@
  #endif
  	      );
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * We do not use IBRS in the kernel. If this vCPU has used the
+ 	 * SPEC_CTRL MSR it may have left it on; save the value and
+ 	 * turn it off. This is much more efficient than blindly adding
+ 	 * it to the atomic save/restore list. Especially as the former
+ 	 * (Saving guest MSRs on vmexit) doesn't even exist in KVM.
+ 	 *
+ 	 * For non-nested case:
+ 	 * If the L01 MSR bitmap does not intercept the MSR, then we need to
+ 	 * save it.
+ 	 *
+ 	 * For nested case:
+ 	 * If the L02 MSR bitmap does not intercept the MSR, then we need to
+ 	 * save it.
+ 	 */
+ 	if (!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL))
+ 		rdmsrl(MSR_IA32_SPEC_CTRL, vmx->spec_ctrl);
+ 
+ 	if (vmx->spec_ctrl)
+ 		wrmsrl(MSR_IA32_SPEC_CTRL, 0);
+ 
+ 	/* Eliminate branch target predictions from guest mode */
+ 	vmexit_fill_RSB();
+ 
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */
  	if (debugctlmsr)
  		update_debugctlmsr(debugctlmsr);
@@@ -9336,14 -10205,29 +9518,36 @@@ static inline bool nested_vmx_merge_msr
  	int msr;
  	struct page *page;
  	unsigned long *msr_bitmap_l1;
++<<<<<<< HEAD
 +	unsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.msr_bitmap;
 +
 +	/* This shortcut is ok because we support only x2APIC MSRs so far. */
 +	if (!nested_cpu_has_virt_x2apic_mode(vmcs12))
++=======
+ 	unsigned long *msr_bitmap_l0 = to_vmx(vcpu)->nested.vmcs02.msr_bitmap;
+ 	/*
+ 	 * pred_cmd & spec_ctrl are trying to verify two things:
+ 	 *
+ 	 * 1. L0 gave a permission to L1 to actually passthrough the MSR. This
+ 	 *    ensures that we do not accidentally generate an L02 MSR bitmap
+ 	 *    from the L12 MSR bitmap that is too permissive.
+ 	 * 2. That L1 or L2s have actually used the MSR. This avoids
+ 	 *    unnecessarily merging of the bitmap if the MSR is unused. This
+ 	 *    works properly because we only update the L01 MSR bitmap lazily.
+ 	 *    So even if L0 should pass L1 these MSRs, the L01 bitmap is only
+ 	 *    updated to reflect this when L1 (or its L2s) actually write to
+ 	 *    the MSR.
+ 	 */
+ 	bool pred_cmd = msr_write_intercepted_l01(vcpu, MSR_IA32_PRED_CMD);
+ 	bool spec_ctrl = msr_write_intercepted_l01(vcpu, MSR_IA32_SPEC_CTRL);
+ 
+ 	if (!nested_cpu_has_virt_x2apic_mode(vmcs12) &&
+ 	    !pred_cmd && !spec_ctrl)
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  		return false;
  
 -	page = kvm_vcpu_gpa_to_page(vcpu, vmcs12->msr_bitmap);
 -	if (is_error_page(page))
 +	page = nested_get_page(vcpu, vmcs12->msr_bitmap);
 +	if (!page)
  		return false;
  	msr_bitmap_l1 = (unsigned long *)kmap(page);
  
@@@ -9372,8 -10256,21 +9576,24 @@@
  				MSR_TYPE_W);
  		}
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (spec_ctrl)
+ 		nested_vmx_disable_intercept_for_msr(
+ 					msr_bitmap_l1, msr_bitmap_l0,
+ 					MSR_IA32_SPEC_CTRL,
+ 					MSR_TYPE_R | MSR_TYPE_W);
+ 
+ 	if (pred_cmd)
+ 		nested_vmx_disable_intercept_for_msr(
+ 					msr_bitmap_l1, msr_bitmap_l0,
+ 					MSR_IA32_PRED_CMD,
+ 					MSR_TYPE_W);
+ 
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  	kunmap(page);
 -	kvm_release_page_clean(page);
 +	nested_release_page_clean(page);
  
  	return true;
  }
diff --cc arch/x86/kvm/x86.c
index 99e230533b87,ac381437c291..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -968,6 -1009,7 +968,10 @@@ static u32 msrs_to_save[] = 
  #endif
  	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
  	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,
++<<<<<<< HEAD
++=======
+ 	MSR_IA32_SPEC_CTRL, MSR_IA32_ARCH_CAPABILITIES
++>>>>>>> d28b387fb74d (KVM/VMX: Allow direct access to MSR_IA32_SPEC_CTRL)
  };
  
  static unsigned num_msrs_to_save;
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/vmx.c
* Unmerged path arch/x86/kvm/x86.c
