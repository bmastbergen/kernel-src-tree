dm: discard support requires all targets in a table support discards

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit 8a74d29d541cd86569139c6f3f44b2d210458071
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8a74d29d.failed

A DM device with a mix of discard capabilities (due to some underlying
devices not having discard support) _should_ just return -EOPNOTSUPP for
the region of the device that doesn't support discards (even if only by
way of the underlying driver formally not supporting discards).  BUT,
that does ask the underlying driver to handle something that it never
advertised support for.  In doing so we're exposing users to the
potential for a underlying disk driver hanging if/when a discard is
issued a the device that is incapable and never claimed to support
discards.

Fix this by requiring that each DM target in a DM table provide discard
support as a prereq for a DM device to advertise support for discards.

This may cause some configurations that were happily supporting discards
(even in the face of a mix of discard support) to stop supporting
discards -- but the risk of users hitting driver hangs, and forced
reboots, outweighs supporting those fringe mixed discard
configurations.

	Cc: stable@vger.kernel.org
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 8a74d29d541cd86569139c6f3f44b2d210458071)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
diff --cc drivers/md/dm-table.c
index 800b2497a5dd,6f1ec12c287c..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -1549,41 -1731,64 +1549,81 @@@ static bool dm_table_supports_write_sam
  	return true;
  }
  
++<<<<<<< HEAD
 +static int device_discard_capable(struct dm_target *ti, struct dm_dev *dev,
 +				  sector_t start, sector_t len, void *data)
++=======
+ static int device_not_write_zeroes_capable(struct dm_target *ti, struct dm_dev *dev,
+ 					   sector_t start, sector_t len, void *data)
  {
  	struct request_queue *q = bdev_get_queue(dev->bdev);
  
- 	return q && blk_queue_discard(q);
+ 	return q && !q->limits.max_write_zeroes_sectors;
+ }
+ 
+ static bool dm_table_supports_write_zeroes(struct dm_table *t)
+ {
+ 	struct dm_target *ti;
+ 	unsigned i = 0;
+ 
+ 	while (i < dm_table_get_num_targets(t)) {
+ 		ti = dm_table_get_target(t, i++);
+ 
+ 		if (!ti->num_write_zeroes_bios)
+ 			return false;
+ 
+ 		if (!ti->type->iterate_devices ||
+ 		    ti->type->iterate_devices(ti, device_not_write_zeroes_capable, NULL))
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static int device_not_discard_capable(struct dm_target *ti, struct dm_dev *dev,
+ 				      sector_t start, sector_t len, void *data)
++>>>>>>> 8a74d29d541c (dm: discard support requires all targets in a table support discards)
+ {
+ 	struct request_queue *q = bdev_get_queue(dev->bdev);
+ 
+ 	return q && !blk_queue_discard(q);
  }
  
  static bool dm_table_supports_discards(struct dm_table *t)
  {
  	struct dm_target *ti;
 -	unsigned i;
 +	unsigned i = 0;
  
++<<<<<<< HEAD
 +	/*
 +	 * Unless any target used by the table set discards_supported,
 +	 * require at least one underlying device to support discards.
 +	 * t->devices includes internal dm devices such as mirror logs
 +	 * so we need to use iterate_devices here, which targets
 +	 * supporting discard selectively must provide.
 +	 */
 +	while (i < dm_table_get_num_targets(t)) {
 +		ti = dm_table_get_target(t, i++);
++=======
+ 	for (i = 0; i < dm_table_get_num_targets(t); i++) {
+ 		ti = dm_table_get_target(t, i);
++>>>>>>> 8a74d29d541c (dm: discard support requires all targets in a table support discards)
  
  		if (!ti->num_discard_bios)
- 			continue;
- 
- 		if (ti->discards_supported)
- 			return true;
+ 			return false;
  
- 		if (ti->type->iterate_devices &&
- 		    ti->type->iterate_devices(ti, device_discard_capable, NULL))
- 			return true;
+ 		/*
+ 		 * Either the target provides discard support (as implied by setting
+ 		 * 'discards_supported') or it relies on _all_ data devices having
+ 		 * discard support.
+ 		 */
+ 		if (!ti->discards_supported &&
+ 		    (!ti->type->iterate_devices ||
+ 		     ti->type->iterate_devices(ti, device_not_discard_capable, NULL)))
+ 			return false;
  	}
  
- 	return false;
+ 	return true;
  }
  
  void dm_table_set_restrictions(struct dm_table *t, struct request_queue *q,
* Unmerged path drivers/md/dm-table.c
