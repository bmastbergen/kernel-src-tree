i40e: fix link reporting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Alan Brady <alan.brady@intel.com>
commit 8fdb69dd383f1f937f7e2f1f24efe97c5268a84c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8fdb69dd.failed

When querying the NVM for supported phy_types, on some firmware
versions, we were failing to actually fill out the phy_types which means
ethtool wouldn't report any link types.

Testing-hints:
Check 'ethtool <iface>' if you have the right (wrong?) firmware.
Without this patch, no link modes will be reported.

	Signed-off-by: Alan Brady <alan.brady@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 8fdb69dd383f1f937f7e2f1f24efe97c5268a84c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_common.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_common.c
index 5defb72cb7b9,aeb497258f20..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@@ -1598,30 -1572,52 +1598,42 @@@ i40e_status i40e_aq_get_phy_capabilitie
  	if (!abilities)
  		return I40E_ERR_PARAM;
  
 -	do {
 -		i40e_fill_default_direct_cmd_desc(&desc,
 -					       i40e_aqc_opc_get_phy_abilities);
 +	i40e_fill_default_direct_cmd_desc(&desc,
 +					  i40e_aqc_opc_get_phy_abilities);
  
 -		desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
 -		if (abilities_size > I40E_AQ_LARGE_BUF)
 -			desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);
 +	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
 +	if (abilities_size > I40E_AQ_LARGE_BUF)
 +		desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);
  
 -		if (qualified_modules)
 -			desc.params.external.param0 |=
 +	if (qualified_modules)
 +		desc.params.external.param0 |=
  			cpu_to_le32(I40E_AQ_PHY_REPORT_QUALIFIED_MODULES);
  
 -		if (report_init)
 -			desc.params.external.param0 |=
 +	if (report_init)
 +		desc.params.external.param0 |=
  			cpu_to_le32(I40E_AQ_PHY_REPORT_INITIAL_VALUES);
  
 -		status = i40e_asq_send_command(hw, &desc, abilities,
 -					       abilities_size, cmd_details);
 -
 -		if (status)
 -			break;
 -
 -		if (hw->aq.asq_last_status == I40E_AQ_RC_EIO) {
 -			status = I40E_ERR_UNKNOWN_PHY;
 -			break;
 -		} else if (hw->aq.asq_last_status == I40E_AQ_RC_EAGAIN) {
 -			usleep_range(1000, 2000);
 -			total_delay++;
 -			status = I40E_ERR_TIMEOUT;
 -		}
 -	} while ((hw->aq.asq_last_status != I40E_AQ_RC_OK) &&
 -		 (total_delay < max_delay));
 +	status = i40e_asq_send_command(hw, &desc, abilities, abilities_size,
 +				       cmd_details);
  
 -	if (status)
 -		return status;
 +	if (hw->aq.asq_last_status == I40E_AQ_RC_EIO)
 +		status = I40E_ERR_UNKNOWN_PHY;
  
  	if (report_init) {
++<<<<<<< HEAD
 +		hw->phy.phy_types = le32_to_cpu(abilities->phy_type);
 +		hw->phy.phy_types |= ((u64)abilities->phy_type_ext << 32);
++=======
+ 		if (hw->mac.type ==  I40E_MAC_XL710 &&
+ 		    hw->aq.api_maj_ver == I40E_FW_API_VERSION_MAJOR &&
+ 		    hw->aq.api_min_ver >= I40E_MINOR_VER_GET_LINK_INFO_XL710) {
+ 			status = i40e_aq_get_link_info(hw, true, NULL, NULL);
+ 		} else {
+ 			hw->phy.phy_types = le32_to_cpu(abilities->phy_type);
+ 			hw->phy.phy_types |=
+ 					((u64)abilities->phy_type_ext << 32);
+ 		}
++>>>>>>> 8fdb69dd383f (i40e: fix link reporting)
  	}
  
  	return status;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_common.c
