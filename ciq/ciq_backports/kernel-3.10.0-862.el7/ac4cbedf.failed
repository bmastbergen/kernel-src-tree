X.509: Fix leap year handling again

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author David Howells <dhowells@redhat.com>
commit ac4cbedfdf55455b4c447f17f0fa027dbf02b2a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ac4cbedf.failed

There are still a couple of minor issues in the X.509 leap year handling:

 (1) To avoid doing a modulus-by-400 in addition to a modulus-by-100 when
     determining whether the year is a leap year or not, I divided the year
     by 100 after doing the modulus-by-100, thereby letting the compiler do
     one instruction for both, and then did a modulus-by-4.

     Unfortunately, I then passed the now-modified year value to mktime64()
     to construct a time value.

     Since this isn't a fast path and since mktime64() does a bunch of
     divisions, just condense down to "% 400".  It's also easier to read.

 (2) The default month length for any February where the year doesn't
     divide by four exactly is obtained from the month_length[] array where
     the value is 29, not 28.

     This is fixed by altering the table.

	Reported-by: Rudolf Polzer <rpolzer@google.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Acked-by: David Woodhouse <David.Woodhouse@intel.com>
	Acked-by: Arnd Bergmann <arnd@arndb.de>
cc: stable@vger.kernel.org
(cherry picked from commit ac4cbedfdf55455b4c447f17f0fa027dbf02b2a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/x509_cert_parser.c
diff --cc crypto/asymmetric_keys/x509_cert_parser.c
index ac72348c186a,794cf0eac2c9..000000000000
--- a/crypto/asymmetric_keys/x509_cert_parser.c
+++ b/crypto/asymmetric_keys/x509_cert_parser.c
@@@ -493,16 -449,34 +493,21 @@@ int x509_process_extension(void *contex
  	return 0;
  }
  
 -/**
 - * x509_decode_time - Decode an X.509 time ASN.1 object
 - * @_t: The time to fill in
 - * @hdrlen: The length of the object header
 - * @tag: The object tag
 - * @value: The object value
 - * @vlen: The size of the object value
 - *
 - * Decode an ASN.1 universal time or generalised time field into a struct the
 - * kernel can handle and check it for validity.  The time is decoded thus:
 - *
 - *	[RFC5280 ยง4.1.2.5]
 - *	CAs conforming to this profile MUST always encode certificate validity
 - *	dates through the year 2049 as UTCTime; certificate validity dates in
 - *	2050 or later MUST be encoded as GeneralizedTime.  Conforming
 - *	applications MUST be able to process validity dates that are encoded in
 - *	either UTCTime or GeneralizedTime.
 +/*
 + * Record a certificate time.
   */
 -int x509_decode_time(time64_t *_t,  size_t hdrlen,
 -		     unsigned char tag,
 -		     const unsigned char *value, size_t vlen)
 +static int x509_note_time(struct tm *tm,  size_t hdrlen,
 +			  unsigned char tag,
 +			  const unsigned char *value, size_t vlen)
  {
++<<<<<<< HEAD
++=======
+ 	static const unsigned char month_lengths[] = { 31, 28, 31, 30, 31, 30,
+ 						       31, 31, 30, 31, 30, 31 };
++>>>>>>> ac4cbedfdf55 (X.509: Fix leap year handling again)
  	const unsigned char *p = value;
 -	unsigned year, mon, day, hour, min, sec, mon_len;
  
 -#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })
 +#define dec2bin(X) ((X) - '0')
  #define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })
  
  	if (tag == ASN1_UNITIM) {
@@@ -533,6 -508,29 +538,32 @@@
  	if (*p != 'Z')
  		goto unsupported_time;
  
++<<<<<<< HEAD
++=======
+ 	if (year < 1970 ||
+ 	    mon < 1 || mon > 12)
+ 		goto invalid_time;
+ 
+ 	mon_len = month_lengths[mon - 1];
+ 	if (mon == 2) {
+ 		if (year % 4 == 0) {
+ 			mon_len = 29;
+ 			if (year % 100 == 0) {
+ 				mon_len = 28;
+ 				if (year % 400 == 0)
+ 					mon_len = 29;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (day < 1 || day > mon_len ||
+ 	    hour > 23 ||
+ 	    min > 59 ||
+ 	    sec > 59)
+ 		goto invalid_time;
+ 
+ 	*_t = mktime64(year, mon, day, hour, min, sec);
++>>>>>>> ac4cbedfdf55 (X.509: Fix leap year handling again)
  	return 0;
  
  unsupported_time:
* Unmerged path crypto/asymmetric_keys/x509_cert_parser.c
