iwlwifi: nvm: set the correct offsets to 3168 series

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Chaya Rachel Ivgi <chaya.rachel.ivgi@intel.com>
commit 44fd09dad5d2b78efbabbbbf623774e561e36cca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/44fd09da.failed

The driver currently handles two NVM formats,
one for 7000 family and below, and one for 8000 family and above.
The 3168 series uses something in between,
so currently the driver uses incorrect offsets for it.
Fix the incorrect offsets.

Fixes: c4836b056d83 ("iwlwifi: Add PCI IDs for the new 3168 series")
	Signed-off-by: Chaya Rachel Ivgi <chaya.rachel.ivgi@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 44fd09dad5d2b78efbabbbbf623774e561e36cca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/api/nvm-reg.h
#	drivers/net/wireless/intel/iwlwifi/iwl-8000.c
#	drivers/net/wireless/intel/iwlwifi/iwl-9000.c
#	drivers/net/wireless/intel/iwlwifi/iwl-a000.c
#	drivers/net/wireless/intel/iwlwifi/iwl-config.h
#	drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
#	drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
#	drivers/net/wireless/intel/iwlwifi/mvm/nvm.c
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-8000.c
index b7953bf55f6f,c2a5936ccede..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-8000.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-8000.c
@@@ -162,10 -161,11 +162,16 @@@ static const struct iwl_tt_params iwl80
  	.dccm2_len = IWL8260_DCCM2_LEN,					\
  	.smem_offset = IWL8260_SMEM_OFFSET,				\
  	.smem_len = IWL8260_SMEM_LEN,					\
 +	.default_nvm_file_B_step = DEFAULT_NVM_FILE_FAMILY_8000B,	\
  	.default_nvm_file_C_step = DEFAULT_NVM_FILE_FAMILY_8000C,	\
  	.thermal_params = &iwl8000_tt_params,				\
++<<<<<<< HEAD:drivers/net/wireless/intel/iwlwifi/iwl-8000.c
 +	.apmg_not_supported = true
++=======
+ 	.apmg_not_supported = true,					\
+ 	.nvm_type = IWL_NVM_EXT,					\
+ 	.dbgc_supported = true
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series):drivers/net/wireless/intel/iwlwifi/cfg/8000.c
  
  #define IWL_DEVICE_8000							\
  	IWL_DEVICE_8000_COMMON,						\
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-9000.c
index a5f0c0bf85ec,e8b5ff42f5a8..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-9000.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-9000.c
@@@ -144,7 -147,9 +144,13 @@@ static const struct iwl_tt_params iwl90
  	.mq_rx_supported = true,					\
  	.vht_mu_mimo_supported = true,					\
  	.mac_addr_from_csr = true,					\
++<<<<<<< HEAD:drivers/net/wireless/intel/iwlwifi/iwl-9000.c
 +	.rf_id = true
++=======
+ 	.rf_id = true,							\
+ 	.nvm_type = IWL_NVM_EXT,					\
+ 	.dbgc_supported = true
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series):drivers/net/wireless/intel/iwlwifi/cfg/9000.c
  
  const struct iwl_cfg iwl9160_2ac_cfg = {
  	.name = "Intel(R) Dual Band Wireless AC 9160",
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-a000.c
index 15dd7f6137c8,a440140ed8dd..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-a000.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-a000.c
@@@ -121,7 -131,10 +121,14 @@@ static const struct iwl_ht_params iwl_a
  	.vht_mu_mimo_supported = true,					\
  	.mac_addr_from_csr = true,					\
  	.use_tfh = true,						\
++<<<<<<< HEAD:drivers/net/wireless/intel/iwlwifi/iwl-a000.c
 +	.rf_id = true
++=======
+ 	.rf_id = true,							\
+ 	.gen2 = true,							\
+ 	.nvm_type = IWL_NVM_EXT,					\
+ 	.dbgc_supported = true
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series):drivers/net/wireless/intel/iwlwifi/cfg/a000.c
  
  const struct iwl_cfg iwla000_2ac_cfg_hr = {
  		.name = "Intel(R) Dual Band Wireless AC a000",
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-config.h
index 94f8a51b633e,71cb1ecde0f7..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-config.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-config.h
@@@ -321,6 -330,9 +333,12 @@@ struct iwl_pwr_tx_backoff 
   * @vht_mu_mimo_supported: VHT MU-MIMO support
   * @rf_id: need to read rf_id to determine the firmware image
   * @integrated: discrete or integrated
++<<<<<<< HEAD
++=======
+  * @gen2: a000 and on transport operation
+  * @cdb: CDB support
+  * @nvm_type: see &enum iwl_nvm_type
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
   *
   * We enable the driver to be backward compatible wrt. hardware features.
   * API differences in uCode shouldn't be handled here but through TLVs
@@@ -365,7 -379,10 +384,14 @@@ struct iwl_cfg 
  	    vht_mu_mimo_supported:1,
  	    rf_id:1,
  	    integrated:1,
++<<<<<<< HEAD
 +	    use_tfh:1;
++=======
+ 	    use_tfh:1,
+ 	    gen2:1,
+ 	    cdb:1,
+ 	    dbgc_supported:1;
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  	u8 valid_tx_ant;
  	u8 valid_rx_ant;
  	u8 non_shared_ant;
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
index 3bd6fc1b76d4,c3a5d8ccc95e..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
@@@ -76,8 -77,9 +76,8 @@@
  #include "iwl-csr.h"
  
  /* NVM offsets (in words) definitions */
- enum wkp_nvm_offsets {
+ enum nvm_offsets {
  	/* NVM HW-Section offset (in words) definitions */
 -	SUBSYSTEM_ID = 0x0A,
  	HW_ADDR = 0x15,
  
  	/* NVM SW-Section offset (in words) definitions */
@@@ -90,21 -92,19 +90,24 @@@
  
  	/* NVM calibration section offset (in words) definitions */
  	NVM_CALIB_SECTION = 0x2B8,
- 	XTAL_CALIB = 0x316 - NVM_CALIB_SECTION
+ 	XTAL_CALIB = 0x316 - NVM_CALIB_SECTION,
+ 
+ 	/* NVM REGULATORY -Section offset (in words) definitions */
+ 	NVM_CHANNELS_SDP = 0,
  };
  
 -enum ext_nvm_offsets {
 +enum family_8000_nvm_offsets {
  	/* NVM HW-Section offset (in words) definitions */
 -	MAC_ADDRESS_OVERRIDE_EXT_NVM = 1,
 +	HW_ADDR0_WFPM_FAMILY_8000 = 0x12,
 +	HW_ADDR1_WFPM_FAMILY_8000 = 0x16,
 +	HW_ADDR0_PCIE_FAMILY_8000 = 0x8A,
 +	HW_ADDR1_PCIE_FAMILY_8000 = 0x8E,
 +	MAC_ADDRESS_OVERRIDE_FAMILY_8000 = 1,
  
  	/* NVM SW-Section offset (in words) definitions */
 -	NVM_VERSION_EXT_NVM = 0,
 -	RADIO_CFG_FAMILY_EXT_NVM = 0,
 +	NVM_SW_SECTION_FAMILY_8000 = 0x1C0,
 +	NVM_VERSION_FAMILY_8000 = 0,
 +	RADIO_CFG_FAMILY_8000 = 0,
  	SKU_FAMILY_8000 = 2,
  	N_HW_ADDRS_FAMILY_8000 = 3,
  
@@@ -218,7 -246,7 +221,11 @@@ static u32 iwl_get_channel_flags(u8 ch_
  	u32 flags = IEEE80211_CHAN_NO_HT40;
  	u32 last_5ghz_ht = LAST_5GHZ_HT;
  
++<<<<<<< HEAD
 +	if (cfg->device_family == IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type == IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		last_5ghz_ht = LAST_5GHZ_HT_FAMILY_8000;
  
  	if (!is_5ghz && (nvm_flags & NVM_CHANNEL_40MHZ)) {
@@@ -272,7 -299,7 +279,11 @@@ static int iwl_init_channel_map(struct 
  	int num_of_ch, num_2ghz_channels;
  	const u8 *nvm_chan;
  
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		num_of_ch = IWL_NUM_CHANNELS;
  		nvm_chan = &iwl_nvm_channels[0];
  		num_2ghz_channels = NUM_2GHZ_CHANNELS;
@@@ -486,7 -494,7 +497,11 @@@ static void iwl_init_sbands(struct devi
  static int iwl_get_sku(const struct iwl_cfg *cfg, const __le16 *nvm_sw,
  		       const __le16 *phy_sku)
  {
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		return le16_to_cpup(nvm_sw + SKU);
  
  	return le32_to_cpup((__le32 *)(phy_sku + SKU_FAMILY_8000));
@@@ -494,7 -502,7 +509,11 @@@
  
  static int iwl_get_nvm_version(const struct iwl_cfg *cfg, const __le16 *nvm_sw)
  {
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		return le16_to_cpup(nvm_sw + NVM_VERSION);
  	else
  		return le32_to_cpup((__le32 *)(nvm_sw +
@@@ -504,10 -512,10 +523,14 @@@
  static int iwl_get_radio_cfg(const struct iwl_cfg *cfg, const __le16 *nvm_sw,
  			     const __le16 *phy_sku)
  {
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		return le16_to_cpup(nvm_sw + RADIO_CFG);
  
 -	return le32_to_cpup((__le32 *)(phy_sku + RADIO_CFG_FAMILY_EXT_NVM));
 +	return le32_to_cpup((__le32 *)(phy_sku + RADIO_CFG_FAMILY_8000));
  
  }
  
@@@ -515,7 -523,7 +538,11 @@@ static int iwl_get_n_hw_addrs(const str
  {
  	int n_hw_addr;
  
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		return le16_to_cpup(nvm_sw + N_HW_ADDRS);
  
  	n_hw_addr = le32_to_cpup((__le32 *)(nvm_sw + N_HW_ADDRS_FAMILY_8000));
@@@ -527,7 -535,7 +554,11 @@@ static void iwl_set_radio_cfg(const str
  			      struct iwl_nvm_data *data,
  			      u32 radio_cfg)
  {
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		data->radio_cfg_type = NVM_RF_CFG_TYPE_MSK(radio_cfg);
  		data->radio_cfg_step = NVM_RF_CFG_STEP_MSK(radio_cfg);
  		data->radio_cfg_dash = NVM_RF_CFG_DASH_MSK(radio_cfg);
@@@ -635,7 -644,7 +666,11 @@@ static int iwl_set_hw_address(struct iw
  {
  	if (cfg->mac_addr_from_csr) {
  		iwl_set_hw_address_from_csr(trans, data);
++<<<<<<< HEAD
 +	} else if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
++=======
+ 	} else if (cfg->nvm_type != IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		const u8 *hw_addr = (const u8 *)(nvm_hw + HW_ADDR);
  
  		/* The byte order is little endian 16 bit, meaning 214365 */
@@@ -672,7 -716,7 +707,11 @@@ iwl_parse_nvm_data(struct iwl_trans *tr
  	u16 lar_config;
  	const __le16 *ch_section;
  
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		data = kzalloc(sizeof(*data) +
  			       sizeof(struct ieee80211_channel) *
  			       IWL_NUM_CHANNELS,
@@@ -706,7 -750,7 +745,11 @@@
  
  	data->n_hw_addrs = iwl_get_n_hw_addrs(cfg, nvm_sw);
  
++<<<<<<< HEAD
 +	if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
++=======
+ 	if (cfg->nvm_type != IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		/* Checking for required sections */
  		if (!nvm_calib) {
  			IWL_ERR(trans,
@@@ -718,11 -767,10 +766,14 @@@
  		data->xtal_calib[0] = *(nvm_calib + XTAL_CALIB);
  		data->xtal_calib[1] = *(nvm_calib + XTAL_CALIB + 1);
  		lar_enabled = true;
++<<<<<<< HEAD
 +		ch_section = nvm_sw;
++=======
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  	} else {
  		u16 lar_offset = data->nvm_version < 0xE39 ?
 -				 NVM_LAR_OFFSET_OLD :
 -				 NVM_LAR_OFFSET;
 +				 NVM_LAR_OFFSET_FAMILY_8000_OLD :
 +				 NVM_LAR_OFFSET_FAMILY_8000;
  
  		lar_config = le16_to_cpup(regulatory + lar_offset);
  		data->lar_enabled = !!(lar_config &
@@@ -752,7 -800,7 +803,11 @@@ static u32 iwl_nvm_get_regdom_bw_flags(
  	u32 flags = NL80211_RRF_NO_HT40;
  	u32 last_5ghz_ht = LAST_5GHZ_HT;
  
++<<<<<<< HEAD
 +	if (cfg->device_family == IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (cfg->nvm_type == IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		last_5ghz_ht = LAST_5GHZ_HT_FAMILY_8000;
  
  	if (ch_idx < NUM_2GHZ_CHANNELS &&
@@@ -798,9 -846,10 +853,16 @@@ iwl_parse_nvm_mcc_info(struct device *d
  		       int num_of_ch, __le32 *channels, u16 fw_mcc)
  {
  	int ch_idx;
++<<<<<<< HEAD
 +	u16 ch_flags, prev_ch_flags = 0;
 +	const u8 *nvm_chan = cfg->device_family == IWL_DEVICE_FAMILY_8000 ?
 +			     iwl_nvm_channels_family_8000 : iwl_nvm_channels;
++=======
+ 	u16 ch_flags;
+ 	u32 reg_rule_flags, prev_reg_rule_flags = 0;
+ 	const u8 *nvm_chan = cfg->nvm_type == IWL_NVM_EXT ?
+ 			     iwl_ext_nvm_channels : iwl_nvm_channels;
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  	struct ieee80211_regdomain *regd;
  	int size_of_regd;
  	struct ieee80211_reg_rule *rule;
@@@ -808,8 -857,8 +870,13 @@@
  	int center_freq, prev_center_freq = 0;
  	int valid_rules = 0;
  	bool new_rule;
++<<<<<<< HEAD
 +	int max_num_ch = cfg->device_family == IWL_DEVICE_FAMILY_8000 ?
 +			 IWL_NUM_CHANNELS_FAMILY_8000 : IWL_NUM_CHANNELS;
++=======
+ 	int max_num_ch = cfg->nvm_type == IWL_NVM_EXT ?
+ 			 IWL_NUM_CHANNELS_EXT : IWL_NUM_CHANNELS;
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  
  	if (WARN_ON_ONCE(num_of_ch > NL80211_MAX_SUPP_REG_RULES))
  		return ERR_PTR(-EINVAL);
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
index 73a216524af2,949e63418299..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
@@@ -1155,7 -1162,7 +1155,11 @@@ static inline bool iwl_mvm_is_lar_suppo
  	 * Enable LAR only if it is supported by the FW (TLV) &&
  	 * enabled in the NVM
  	 */
++<<<<<<< HEAD
 +	if (mvm->cfg->device_family == IWL_DEVICE_FAMILY_8000)
++=======
+ 	if (mvm->cfg->nvm_type == IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		return nvm_lar && tlv_lar;
  	else
  		return tlv_lar;
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/nvm.c
index eade099b6dbf,fb25b6f29323..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c
@@@ -296,11 -292,13 +296,16 @@@ static struct iwl_nvm_data 
  iwl_parse_nvm_sections(struct iwl_mvm *mvm)
  {
  	struct iwl_nvm_section *sections = mvm->nvm_sections;
 -	const __be16 *hw;
 -	const __le16 *sw, *calib, *regulatory, *mac_override, *phy_sku;
 +	const __le16 *hw, *sw, *calib, *regulatory, *mac_override, *phy_sku;
  	bool lar_enabled;
+ 	int regulatory_type;
  
  	/* Checking for required sections */
++<<<<<<< HEAD
 +	if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
++=======
+ 	if (mvm->trans->cfg->nvm_type != IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		if (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||
  		    !mvm->nvm_sections[mvm->cfg->nvm_hw_section_num].data) {
  			IWL_ERR(mvm, "Can't parse empty OTP/NVM sections\n");
@@@ -330,13 -333,9 +340,12 @@@
  		}
  	}
  
 -	hw = (const __be16 *)sections[mvm->cfg->nvm_hw_section_num].data;
 +	if (WARN_ON(!mvm->cfg))
 +		return NULL;
 +
 +	hw = (const __le16 *)sections[mvm->cfg->nvm_hw_section_num].data;
  	sw = (const __le16 *)sections[NVM_SECTION_TYPE_SW].data;
  	calib = (const __le16 *)sections[NVM_SECTION_TYPE_CALIBRATION].data;
- 	regulatory = (const __le16 *)sections[NVM_SECTION_TYPE_REGULATORY].data;
  	mac_override =
  		(const __le16 *)sections[NVM_SECTION_TYPE_MAC_OVERRIDE].data;
  	phy_sku = (const __le16 *)sections[NVM_SECTION_TYPE_PHY_SKU].data;
@@@ -399,11 -402,11 +412,16 @@@ static int iwl_mvm_read_external_nvm(st
  
  	IWL_DEBUG_EEPROM(mvm->trans->dev, "Read from external NVM\n");
  
++<<<<<<< HEAD
 +	/* Maximal size depends on HW family and step */
 +	if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
++=======
+ 	/* Maximal size depends on NVM version */
+ 	if (mvm->trans->cfg->nvm_type != IWL_NVM_EXT)
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		max_section_size = IWL_MAX_NVM_SECTION_SIZE;
  	else
 -		max_section_size = IWL_MAX_EXT_NVM_SECTION_SIZE;
 +		max_section_size = IWL_MAX_NVM_8000_SECTION_SIZE;
  
  	/*
  	 * Obtain NVM image via request_firmware. Since we already used
@@@ -472,7 -474,7 +490,11 @@@
  			break;
  		}
  
++<<<<<<< HEAD
 +		if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
++=======
+ 		if (mvm->trans->cfg->nvm_type != IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  			section_size =
  				2 * NVM_WORD1_LEN(le16_to_cpu(file_sec->word1));
  			section_id = NVM_WORD2_ID(le16_to_cpu(file_sec->word2));
@@@ -758,7 -749,7 +780,11 @@@ int iwl_mvm_init_mcc(struct iwl_mvm *mv
  	struct ieee80211_regdomain *regd;
  	char mcc[3];
  
++<<<<<<< HEAD
 +	if (mvm->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
++=======
+ 	if (mvm->cfg->nvm_type == IWL_NVM_EXT) {
++>>>>>>> 44fd09dad5d2 (iwlwifi: nvm: set the correct offsets to 3168 series)
  		tlv_lar = fw_has_capa(&mvm->fw->ucode_capa,
  				      IWL_UCODE_TLV_CAPA_LAR_SUPPORT);
  		nvm_lar = mvm->nvm_data->lar_enabled;
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/nvm-reg.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/nvm-reg.h
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-7000.c b/drivers/net/wireless/intel/iwlwifi/iwl-7000.c
index a72e58623d3a..2cf3e32106f7 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-7000.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-7000.c
@@ -309,6 +309,7 @@ const struct iwl_cfg iwl3168_2ac_cfg = {
 	.nvm_calib_ver = IWL3168_TX_POWER_VERSION,
 	.pwr_tx_backoffs = iwl7265_pwr_tx_backoffs,
 	.dccm_len = IWL7265_DCCM_LEN,
+	.nvm_type = IWL_NVM_SDP,
 };
 
 const struct iwl_cfg iwl7265_2ac_cfg = {
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-8000.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-9000.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-a000.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-config.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/nvm.c
