xfs: refactor inode chunk alloc/free tx reservation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 57af33e451b73f56feb428f5856cdf6e4e0c60cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/57af33e4.failed

The reservation for the various forms of inode allocation is
scattered across several different functions. This includes two
variants of chunk allocation (v5 icreate transactions vs. older
create transactions) and the inode free transaction.

To clean up some of this code and clarify the purpose of specific
allocfree reservations, continue the pattern of defining helper
functions for smaller operational units of broader transactions.
Refactor the reservation into an inode chunk alloc/free helper that
considers the various conditions based on filesystem format.

An inode chunk free involves an extent free and buffer
invalidations. The latter requires reservation for log headers only.
An inode chunk allocation modifies the free space btrees and logs
the chunk on v4 supers. v5 supers initialize the inode chunk using
ordered buffers and so do not log the chunk.

As a side effect of this refactoring, add one more allocfree res to
the ifree transaction. Technically this does not serve a specific
purpose because inode chunks are freed via deferred operations and
thus occur after a transaction roll. tr_ifree has a bit of a history
of tx overruns caused by too many agfl fixups during sustained file
deletion workloads, so add this extra reservation as a form of
padding nonetheless.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 57af33e451b73f56feb428f5856cdf6e4e0c60cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_trans_resv.c
diff --cc fs/xfs/libxfs/xfs_trans_resv.c
index 1b754cb1e8ae,75259a1346eb..000000000000
--- a/fs/xfs/libxfs/xfs_trans_resv.c
+++ b/fs/xfs/libxfs/xfs_trans_resv.c
@@@ -135,16 -171,44 +138,51 @@@ xfs_calc_finobt_res
  	if (!xfs_sb_version_hasfinobt(&mp->m_sb))
  		return 0;
  
 -	return xfs_calc_inobt_res(mp);
 +	res = xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1));
 +	if (alloc)
 +		res += xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1), 
 +					XFS_FSB_TO_B(mp, 1));
 +	if (modify)
 +		res += (uint)XFS_FSB_TO_B(mp, 1);
 +
 +	return res;
  }
  
+ /*
+  * Calculate the reservation required to allocate or free an inode chunk. This
+  * includes:
+  *
+  * the allocation btrees: 2 trees * (max depth - 1) * block size
+  * the inode chunk: m_ialloc_blks * N
+  *
+  * The size N of the inode chunk reservation depends on whether it is for
+  * allocation or free and which type of create transaction is in use. An inode
+  * chunk free always invalidates the buffers and only requires reservation for
+  * headers (N == 0). An inode chunk allocation requires a chunk sized
+  * reservation on v4 and older superblocks to initialize the chunk. No chunk
+  * reservation is required for allocation on v5 supers, which use ordered
+  * buffers to initialize.
+  */
+ STATIC uint
+ xfs_calc_inode_chunk_res(
+ 	struct xfs_mount	*mp,
+ 	bool			alloc)
+ {
+ 	uint			res, size = 0;
+ 
+ 	res = xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+ 			       XFS_FSB_TO_B(mp, 1));
+ 	if (alloc) {
+ 		/* icreate tx uses ordered buffers */
+ 		if (xfs_sb_version_hascrc(&mp->m_sb))
+ 			return res;
+ 		size = XFS_FSB_TO_B(mp, 1);
+ 	}
+ 
+ 	res += xfs_calc_buf_res(mp->m_ialloc_blks, size);
+ 	return res;
+ }
+ 
  /*
   * Various log reservation values.
   *
@@@ -359,9 -417,8 +397,14 @@@ xfs_calc_create_resv_modify
   * For create we can allocate some inodes giving:
   *    the agi and agf of the ag getting the new inodes: 2 * sectorsize
   *    the superblock for the nlink flag: sector size
++<<<<<<< HEAD
 + *    the inode blocks allocated: mp->m_ialloc_blks * blocksize
 + *    the inode btree: max depth * blocksize
 + *    the allocation btrees: 2 trees * (max depth - 1) * block size
++=======
+  *    the inode chunk (allocation/init)
+  *    the inode btree (record insertion)
++>>>>>>> 57af33e451b7 (xfs: refactor inode chunk alloc/free tx reservation)
   */
  STATIC uint
  xfs_calc_create_resv_alloc(
@@@ -369,10 -426,8 +412,15 @@@
  {
  	return xfs_calc_buf_res(2, mp->m_sb.sb_sectsize) +
  		mp->m_sb.sb_sectsize +
++<<<<<<< HEAD
 +		xfs_calc_buf_res(mp->m_ialloc_blks, XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 +				 XFS_FSB_TO_B(mp, 1));
++=======
+ 		xfs_calc_inode_chunk_res(mp, _ALLOC) +
+ 		xfs_calc_inobt_res(mp);
++>>>>>>> 57af33e451b7 (xfs: refactor inode chunk alloc/free tx reservation)
  }
  
  STATIC uint
@@@ -388,8 -443,8 +436,13 @@@ __xfs_calc_create_reservation
   * For icreate we can allocate some inodes giving:
   *    the agi and agf of the ag getting the new inodes: 2 * sectorsize
   *    the superblock for the nlink flag: sector size
++<<<<<<< HEAD
 + *    the inode btree: max depth * blocksize
 + *    the allocation btrees: 2 trees * (max depth - 1) * block size
++=======
+  *    the inode chunk (allocation, no init)
+  *    the inobt (record insertion)
++>>>>>>> 57af33e451b7 (xfs: refactor inode chunk alloc/free tx reservation)
   *    the finobt (record insertion)
   */
  STATIC uint
@@@ -398,10 -453,9 +451,16 @@@ xfs_calc_icreate_resv_alloc
  {
  	return xfs_calc_buf_res(2, mp->m_sb.sb_sectsize) +
  		mp->m_sb.sb_sectsize +
++<<<<<<< HEAD
 +		xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 +				 XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_finobt_res(mp, 0, 0);
++=======
+ 		xfs_calc_inode_chunk_res(mp, _ALLOC) +
+ 		xfs_calc_inobt_res(mp) +
+ 		xfs_calc_finobt_res(mp);
++>>>>>>> 57af33e451b7 (xfs: refactor inode chunk alloc/free tx reservation)
  }
  
  STATIC uint
@@@ -463,13 -517,17 +522,27 @@@ xfs_calc_symlink_reservation
  /*
   * In freeing an inode we can modify:
   *    the inode being freed: inode size
++<<<<<<< HEAD
 + *    the super block free inode counter: sector size
 + *    the agi hash list and counters: sector size
 + *    the inode btree entry: block size
 + *    the on disk inode before ours in the agi hash list: inode cluster size
 + *    the inode btree: max depth * blocksize
 + *    the allocation btrees: 2 trees * (max depth - 1) * block size
 + *    the finobt (record insertion, removal or modification)
++=======
+  *    the super block free inode counter, AGF and AGFL: sector size
+  *    the on disk inode (agi unlinked list removal)
+  *    the inode chunk (invalidated, headers only)
+  *    the inode btree
+  *    the finobt (record insertion, removal or modification)
+  *
+  * Note that the inode chunk res. includes an allocfree res. for freeing of the
+  * inode chunk. This is technically extraneous because the inode chunk free is
+  * deferred (it occurs after a transaction roll). Include the extra reservation
+  * anyways since we've had reports of ifree transaction overruns due to too many
+  * agfl fixups during inode chunk frees.
++>>>>>>> 57af33e451b7 (xfs: refactor inode chunk alloc/free tx reservation)
   */
  STATIC uint
  xfs_calc_ifree_reservation(
@@@ -477,15 -535,11 +550,21 @@@
  {
  	return XFS_DQUOT_LOGRES(mp) +
  		xfs_calc_inode_res(mp, 1) +
 -		xfs_calc_buf_res(3, mp->m_sb.sb_sectsize) +
 +		xfs_calc_buf_res(1, mp->m_sb.sb_sectsize) +
 +		xfs_calc_buf_res(1, XFS_FSB_TO_B(mp, 1)) +
  		xfs_calc_iunlink_remove_reservation(mp) +
++<<<<<<< HEAD
 +		xfs_calc_buf_res(1, 0) +
 +		xfs_calc_buf_res(2 + mp->m_ialloc_blks +
 +				 mp->m_in_maxlevels, 0) +
 +		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 +				 XFS_FSB_TO_B(mp, 1)) +
 +		xfs_calc_finobt_res(mp, 0, 1);
++=======
+ 		xfs_calc_inode_chunk_res(mp, _FREE) +
+ 		xfs_calc_inobt_res(mp) +
+ 		xfs_calc_finobt_res(mp);
++>>>>>>> 57af33e451b7 (xfs: refactor inode chunk alloc/free tx reservation)
  }
  
  /*
* Unmerged path fs/xfs/libxfs/xfs_trans_resv.c
