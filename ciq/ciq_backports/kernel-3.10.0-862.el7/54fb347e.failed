ovl: verify index dir matches upper dir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 54fb347e836faadaed2a5617fb4dd4a4597d0490
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/54fb347e.failed

An index dir contains persistent hardlinks to files in upper dir.
Therefore, we must never mount an existing index dir with a differnt
upper dir.

Store the upper root dir file handle in index dir inode when index
dir is created and verify the file handle before using an existing
index dir on mount.

Add an 'is_upper' flag to the overlay file handle encoding and set it
when encoding the upper root file handle. This is not critical for index
dir verification, but it is good practice towards a standard overlayfs
file handle format for NFS export.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 54fb347e836faadaed2a5617fb4dd4a4597d0490)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/copy_up.c
index 6e96b99a973d,5e8fd99557e1..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -264,9 -233,93 +264,95 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper)
+ {
+ 	struct ovl_fh *fh;
+ 	int fh_type, fh_len, dwords;
+ 	void *buf;
+ 	int buflen = MAX_HANDLE_SZ;
+ 	uuid_t *uuid = &lower->d_sb->s_uuid;
+ 
+ 	buf = kmalloc(buflen, GFP_TEMPORARY);
+ 	if (!buf)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	/*
+ 	 * We encode a non-connectable file handle for non-dir, because we
+ 	 * only need to find the lower inode number and we don't want to pay
+ 	 * the price or reconnecting the dentry.
+ 	 */
+ 	dwords = buflen >> 2;
+ 	fh_type = exportfs_encode_fh(lower, buf, &dwords, 0);
+ 	buflen = (dwords << 2);
+ 
+ 	fh = ERR_PTR(-EIO);
+ 	if (WARN_ON(fh_type < 0) ||
+ 	    WARN_ON(buflen > MAX_HANDLE_SZ) ||
+ 	    WARN_ON(fh_type == FILEID_INVALID))
+ 		goto out;
+ 
+ 	BUILD_BUG_ON(MAX_HANDLE_SZ + offsetof(struct ovl_fh, fid) > 255);
+ 	fh_len = offsetof(struct ovl_fh, fid) + buflen;
+ 	fh = kmalloc(fh_len, GFP_KERNEL);
+ 	if (!fh) {
+ 		fh = ERR_PTR(-ENOMEM);
+ 		goto out;
+ 	}
+ 
+ 	fh->version = OVL_FH_VERSION;
+ 	fh->magic = OVL_FH_MAGIC;
+ 	fh->type = fh_type;
+ 	fh->flags = OVL_FH_FLAG_CPU_ENDIAN;
+ 	/*
+ 	 * When we will want to decode an overlay dentry from this handle
+ 	 * and all layers are on the same fs, if we get a disconncted real
+ 	 * dentry when we decode fid, the only way to tell if we should assign
+ 	 * it to upperdentry or to lowerstack is by checking this flag.
+ 	 */
+ 	if (is_upper)
+ 		fh->flags |= OVL_FH_FLAG_PATH_UPPER;
+ 	fh->len = fh_len;
+ 	fh->uuid = *uuid;
+ 	memcpy(fh->fid, buf, buflen);
+ 
+ out:
+ 	kfree(buf);
+ 	return fh;
+ }
+ 
+ static int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+ 			  struct dentry *upper)
+ {
+ 	const struct ovl_fh *fh = NULL;
+ 	int err;
+ 
+ 	/*
+ 	 * When lower layer doesn't support export operations store a 'null' fh,
+ 	 * so we can use the overlay.origin xattr to distignuish between a copy
+ 	 * up and a pure upper inode.
+ 	 */
+ 	if (ovl_can_decode_fh(lower->d_sb)) {
+ 		fh = ovl_encode_fh(lower, false);
+ 		if (IS_ERR(fh))
+ 			return PTR_ERR(fh);
+ 	}
+ 
+ 	/*
+ 	 * Do not fail when upper doesn't support xattrs.
+ 	 */
+ 	err = ovl_check_setxattr(dentry, upper, OVL_XATTR_ORIGIN, fh,
+ 				 fh ? fh->len : 0, 0);
+ 	kfree(fh);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 54fb347e836f (ovl: verify index dir matches upper dir)
  static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
  			      struct dentry *dentry, struct path *lowerpath,
 -			      struct kstat *stat, const char *link,
 -			      struct kstat *pstat, bool tmpfile)
 +			      struct kstat *stat, const char *link)
  {
  	struct inode *wdir = workdir->d_inode;
  	struct inode *udir = upperdir->d_inode;
diff --cc fs/overlayfs/overlayfs.h
index 952ccab31629,58bbd135a7b3..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -24,8 -22,49 +24,50 @@@ enum ovl_path_type 
  
  #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
  #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
 -#define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
 -#define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
 -#define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
  
++<<<<<<< HEAD
 +#define OVL_ISUPPER_MASK 1UL
++=======
+ enum ovl_flag {
+ 	OVL_IMPURE,
+ };
+ 
+ /*
+  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
+  * where:
+  * origin.fh	- exported file handle of the lower file
+  * origin.uuid	- uuid of the lower filesystem
+  */
+ #define OVL_FH_VERSION	0
+ #define OVL_FH_MAGIC	0xfb
+ 
+ /* CPU byte order required for fid decoding:  */
+ #define OVL_FH_FLAG_BIG_ENDIAN	(1 << 0)
+ #define OVL_FH_FLAG_ANY_ENDIAN	(1 << 1)
+ /* Is the real inode encoded in fid an upper inode? */
+ #define OVL_FH_FLAG_PATH_UPPER	(1 << 2)
+ 
+ #define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
+ 
+ #if defined(__LITTLE_ENDIAN)
+ #define OVL_FH_FLAG_CPU_ENDIAN 0
+ #elif defined(__BIG_ENDIAN)
+ #define OVL_FH_FLAG_CPU_ENDIAN OVL_FH_FLAG_BIG_ENDIAN
+ #else
+ #error Endianness not defined
+ #endif
+ 
+ /* On-disk and in-memeory format for redirect by file handle */
+ struct ovl_fh {
+ 	u8 version;	/* 0 */
+ 	u8 magic;	/* 0xfb */
+ 	u8 len;		/* size of this header + size of fid */
+ 	u8 flags;	/* OVL_FH_FLAG_* */
+ 	u8 type;	/* fid_type of fid */
+ 	uuid_t uuid;	/* uuid of filesystem */
+ 	u8 fid[0];	/* file identifier */
+ } __packed;
++>>>>>>> 54fb347e836f (ovl: verify index dir matches upper dir)
  
  static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
  {
@@@ -151,27 -197,48 +193,65 @@@ int ovl_path_next(int idx, struct dentr
  struct dentry *ovl_dentry_upper(struct dentry *dentry);
  struct dentry *ovl_dentry_lower(struct dentry *dentry);
  struct dentry *ovl_dentry_real(struct dentry *dentry);
 -struct inode *ovl_inode_upper(struct inode *inode);
 -struct inode *ovl_inode_lower(struct inode *inode);
 -struct inode *ovl_inode_real(struct inode *inode);
 +struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 +				    bool is_upper);
  struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
  void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 +struct dentry *ovl_workdir(struct dentry *dentry);
 +int ovl_want_write(struct dentry *dentry);
 +void ovl_drop_write(struct dentry *dentry);
  bool ovl_dentry_is_opaque(struct dentry *dentry);
++<<<<<<< HEAD
++=======
+ bool ovl_dentry_is_whiteout(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry);
+ bool ovl_redirect_dir(struct super_block *sb);
+ const char *ovl_dentry_get_redirect(struct dentry *dentry);
+ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
+ void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+ 		    struct dentry *lowerdentry);
+ void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
+ void ovl_dentry_version_inc(struct dentry *dentry);
+ u64 ovl_dentry_version_get(struct dentry *dentry);
+ bool ovl_is_whiteout(struct dentry *dentry);
+ struct file *ovl_path_open(struct path *path, int flags);
+ int ovl_copy_up_start(struct dentry *dentry);
+ void ovl_copy_up_end(struct dentry *dentry);
+ bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+ 		       const char *name, const void *value, size_t size,
+ 		       int xerr);
+ int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+ void ovl_set_flag(unsigned long flag, struct inode *inode);
+ bool ovl_test_flag(unsigned long flag, struct inode *inode);
+ bool ovl_inuse_trylock(struct dentry *dentry);
+ void ovl_inuse_unlock(struct dentry *dentry);
+ 
+ static inline bool ovl_is_impuredir(struct dentry *dentry)
+ {
+ 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+ }
+ 
+ 
+ /* namei.c */
+ int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
+ 		      struct dentry *origin, bool is_upper, bool set);
+ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
++>>>>>>> 54fb347e836f (ovl: verify index dir matches upper dir)
  bool ovl_lower_positive(struct dentry *dentry);
 +bool ovl_dentry_is_whiteout(struct dentry *dentry);
 +void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 +bool ovl_is_whiteout(struct dentry *dentry);
 +const struct cred *ovl_override_creds(struct super_block *sb);
 +void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 +void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 +			  unsigned int flags);
 +struct file *ovl_path_open(struct path *path, int flags);
 +
 +struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
 +				struct kstat *stat, const char *link);
  
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
@@@ -220,3 -294,4 +300,7 @@@ int ovl_copy_up(struct dentry *dentry)
  int ovl_copy_up_flags(struct dentry *dentry, int flags);
  int ovl_copy_xattr(struct dentry *old, struct dentry *new);
  int ovl_set_attr(struct dentry *upper, struct kstat *stat);
++<<<<<<< HEAD
++=======
+ struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper);
++>>>>>>> 54fb347e836f (ovl: verify index dir matches upper dir)
diff --cc fs/overlayfs/super.c
index aaf06952d88f,a313af25dac2..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -1434,11 -1044,45 +1434,48 @@@ static int ovl_fill_super(struct super_
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
  	if (!ufs->upper_mnt)
  		sb->s_flags |= MS_RDONLY;
++<<<<<<< HEAD
++=======
+ 	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
+ 		ufs->same_sb = NULL;
+ 
+ 	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
+ 		/* Verify lower root is upper root origin */
+ 		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
+ 					stack[0].dentry, false, true);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to verify upper root origin\n");
+ 			goto out_put_lower_mnt;
+ 		}
+ 
+ 		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
+ 						   OVL_INDEXDIR_NAME, true);
+ 		err = PTR_ERR(ufs->indexdir);
+ 		if (IS_ERR(ufs->indexdir))
+ 			goto out_put_lower_mnt;
+ 
+ 		if (ufs->indexdir) {
+ 			/* Verify upper root is index dir origin */
+ 			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
+ 						upperpath.dentry, true, true);
+ 			if (err)
+ 				pr_err("overlayfs: failed to verify index dir origin\n");
+ 		}
+ 		if (err || !ufs->indexdir)
+ 			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 		if (err)
+ 			goto out_put_indexdir;
+ 	}
+ 
+ 	/* Show index=off/on in /proc/mounts for any of the reasons above */
+ 	if (!ufs->indexdir)
+ 		ufs->config.index = false;
++>>>>>>> 54fb347e836f (ovl: verify index dir matches upper dir)
  
  	if (remote)
 -		sb->s_d_op = &ovl_reval_dentry_operations;
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
  	else
 -		sb->s_d_op = &ovl_dentry_operations;
 +		sb->s_d_op = &ovl_dentry_operations.ops;
  
  	ufs->creator_cred = cred = prepare_creds();
  	if (!cred)
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
