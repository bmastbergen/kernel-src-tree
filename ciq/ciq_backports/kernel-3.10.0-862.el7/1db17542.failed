ext4: Simplify DAX fault path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 1db175428ee374489448361213e9c3b749d14900
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1db17542.failed

Now that dax_iomap_fault() calls ->iomap_begin() without entry lock, we
can use transaction starting in ext4_iomap_begin() and thus simplify
ext4_dax_fault(). It also provides us proper retries in case of ENOSPC.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 1db175428ee374489448361213e9c3b749d14900)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/file.c
diff --cc fs/ext4/file.c
index db1bf9992414,d663d3d7c81c..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -213,24 -265,12 +212,30 @@@ static int ext4_dax_fault(struct vm_are
  	if (write) {
  		sb_start_pagefault(sb);
  		file_update_time(vma->vm_file);
++<<<<<<< HEAD
 +		down_read(&EXT4_I(inode)->i_mmap_sem);
 +		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
 +						EXT4_DATA_TRANS_BLOCKS(sb));
 +	} else
 +		down_read(&EXT4_I(inode)->i_mmap_sem);
 +
 +	if (IS_ERR(handle))
 +		result = VM_FAULT_SIGBUS;
 +	else
 +		result = dax_fault(vma, vmf, ext4_dax_get_block);
 +
 +	if (write) {
 +		if (!IS_ERR(handle))
 +			ext4_journal_stop(handle);
 +		up_read(&EXT4_I(inode)->i_mmap_sem);
++=======
+ 	}
+ 	down_read(&EXT4_I(inode)->i_mmap_sem);
+ 	result = dax_iomap_fault(vma, vmf, &ext4_iomap_ops);
+ 	up_read(&EXT4_I(inode)->i_mmap_sem);
+ 	if (write)
++>>>>>>> 1db175428ee3 (ext4: Simplify DAX fault path)
  		sb_end_pagefault(sb);
- 	} else
- 		up_read(&EXT4_I(inode)->i_mmap_sem);
  
  	return result;
  }
@@@ -247,26 -286,13 +251,33 @@@ static int ext4_dax_pmd_fault(struct vm
  	if (write) {
  		sb_start_pagefault(sb);
  		file_update_time(vma->vm_file);
++<<<<<<< HEAD
 +		down_read(&EXT4_I(inode)->i_mmap_sem);
 +		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
 +				ext4_chunk_trans_blocks(inode,
 +							PMD_SIZE / PAGE_SIZE));
 +	} else
 +		down_read(&EXT4_I(inode)->i_mmap_sem);
 +
 +	if (IS_ERR(handle))
 +		result = VM_FAULT_SIGBUS;
 +	else
 +		result = dax_pmd_fault(vma, addr, pmd, flags,
 +				ext4_dax_get_block);
 +
 +	if (write) {
 +		if (!IS_ERR(handle))
 +			ext4_journal_stop(handle);
 +		up_read(&EXT4_I(inode)->i_mmap_sem);
++=======
+ 	}
+ 	down_read(&EXT4_I(inode)->i_mmap_sem);
+ 	result = dax_iomap_pmd_fault(vma, addr, pmd, flags,
+ 				     &ext4_iomap_ops);
+ 	up_read(&EXT4_I(inode)->i_mmap_sem);
+ 	if (write)
++>>>>>>> 1db175428ee3 (ext4: Simplify DAX fault path)
  		sb_end_pagefault(sb);
- 	} else
- 		up_read(&EXT4_I(inode)->i_mmap_sem);
  
  	return result;
  }
* Unmerged path fs/ext4/file.c
