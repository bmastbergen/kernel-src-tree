i40e/virtchnl: move function to virtchnl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 735e35c56bbc91621942dc5111b2970beb00e75a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/735e35c5.failed

This moves a function that is needed for the virtchnl interface
from the i40e PF driver over to the virtchnl.h file.

It was manually verified that the function in question is unchanged
except for the function name and function header, which explains
the slight difference in the number of lines removed/added.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 735e35c56bbc91621942dc5111b2970beb00e75a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
index 974ba2baf6ea,dab76e947b9f..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
@@@ -438,11 -492,157 +438,162 @@@ struct i40e_virtchnl_iwarp_qvlist_info 
   * is in a reset state, it will return DEADBEEF, which, when masked
   * will result in 3.
   */
 -enum virtchnl_vfr_states {
 -	VIRTCHNL_VFR_INPROGRESS = 0,
 -	VIRTCHNL_VFR_COMPLETED,
 -	VIRTCHNL_VFR_VFACTIVE,
 +enum i40e_vfr_states {
 +	I40E_VFR_INPROGRESS = 0,
 +	I40E_VFR_COMPLETED,
 +	I40E_VFR_VFACTIVE,
 +	I40E_VFR_UNKNOWN,
  };
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
 +#endif /* _I40E_VIRTCHNL_H_ */
++=======
+ /**
+  * virtchnl_vc_validate_vf_msg
+  * @ver: Virtchnl version info
+  * @v_opcode: Opcode for the message
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * validate msg format against struct for each opcode
+  */
+ static inline int
+ virtchnl_vc_validate_vf_msg(struct virtchnl_version_info *ver, u32 v_opcode,
+ 			    u8 *msg, u16 msglen)
+ {
+ 	bool err_msg_format = false;
+ 	int valid_len = 0;
+ 
+ 	/* Validate message length. */
+ 	switch (v_opcode) {
+ 	case VIRTCHNL_OP_VERSION:
+ 		valid_len = sizeof(struct virtchnl_version_info);
+ 		break;
+ 	case VIRTCHNL_OP_RESET_VF:
+ 		break;
+ 	case VIRTCHNL_OP_GET_VF_RESOURCES:
+ 		if (VF_IS_V11(ver))
+ 			valid_len = sizeof(u32);
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_TX_QUEUE:
+ 		valid_len = sizeof(struct virtchnl_txq_info);
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_RX_QUEUE:
+ 		valid_len = sizeof(struct virtchnl_rxq_info);
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_VSI_QUEUES:
+ 		valid_len = sizeof(struct virtchnl_vsi_queue_config_info);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_vsi_queue_config_info *vqc =
+ 			    (struct virtchnl_vsi_queue_config_info *)msg;
+ 			valid_len += (vqc->num_queue_pairs *
+ 				      sizeof(struct
+ 					     virtchnl_queue_pair_info));
+ 			if (vqc->num_queue_pairs == 0)
+ 				err_msg_format = true;
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_IRQ_MAP:
+ 		valid_len = sizeof(struct virtchnl_irq_map_info);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_irq_map_info *vimi =
+ 			    (struct virtchnl_irq_map_info *)msg;
+ 			valid_len += (vimi->num_vectors *
+ 				      sizeof(struct virtchnl_vector_map));
+ 			if (vimi->num_vectors == 0)
+ 				err_msg_format = true;
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_ENABLE_QUEUES:
+ 	case VIRTCHNL_OP_DISABLE_QUEUES:
+ 		valid_len = sizeof(struct virtchnl_queue_select);
+ 		break;
+ 	case VIRTCHNL_OP_ADD_ETH_ADDR:
+ 	case VIRTCHNL_OP_DEL_ETH_ADDR:
+ 		valid_len = sizeof(struct virtchnl_ether_addr_list);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_ether_addr_list *veal =
+ 			    (struct virtchnl_ether_addr_list *)msg;
+ 			valid_len += veal->num_elements *
+ 			    sizeof(struct virtchnl_ether_addr);
+ 			if (veal->num_elements == 0)
+ 				err_msg_format = true;
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_ADD_VLAN:
+ 	case VIRTCHNL_OP_DEL_VLAN:
+ 		valid_len = sizeof(struct virtchnl_vlan_filter_list);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_vlan_filter_list *vfl =
+ 			    (struct virtchnl_vlan_filter_list *)msg;
+ 			valid_len += vfl->num_elements * sizeof(u16);
+ 			if (vfl->num_elements == 0)
+ 				err_msg_format = true;
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE:
+ 		valid_len = sizeof(struct virtchnl_promisc_info);
+ 		break;
+ 	case VIRTCHNL_OP_GET_STATS:
+ 		valid_len = sizeof(struct virtchnl_queue_select);
+ 		break;
+ 	case VIRTCHNL_OP_IWARP:
+ 		/* These messages are opaque to us and will be validated in
+ 		 * the RDMA client code. We just need to check for nonzero
+ 		 * length. The firmware will enforce max length restrictions.
+ 		 */
+ 		if (msglen)
+ 			valid_len = msglen;
+ 		else
+ 			err_msg_format = true;
+ 		break;
+ 	case VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
+ 		valid_len = sizeof(struct virtchnl_iwarp_qvlist_info);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_iwarp_qvlist_info *qv =
+ 				(struct virtchnl_iwarp_qvlist_info *)msg;
+ 			if (qv->num_vectors == 0) {
+ 				err_msg_format = true;
+ 				break;
+ 			}
+ 			valid_len += ((qv->num_vectors - 1) *
+ 				sizeof(struct virtchnl_iwarp_qv_info));
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_RSS_KEY:
+ 		valid_len = sizeof(struct virtchnl_rss_key);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_rss_key *vrk =
+ 				(struct virtchnl_rss_key *)msg;
+ 			valid_len += vrk->key_len - 1;
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_CONFIG_RSS_LUT:
+ 		valid_len = sizeof(struct virtchnl_rss_lut);
+ 		if (msglen >= valid_len) {
+ 			struct virtchnl_rss_lut *vrl =
+ 				(struct virtchnl_rss_lut *)msg;
+ 			valid_len += vrl->lut_entries - 1;
+ 		}
+ 		break;
+ 	case VIRTCHNL_OP_GET_RSS_HENA_CAPS:
+ 		break;
+ 	case VIRTCHNL_OP_SET_RSS_HENA:
+ 		valid_len = sizeof(struct virtchnl_rss_hena);
+ 		break;
+ 	/* These are always errors coming from the VF. */
+ 	case VIRTCHNL_OP_EVENT:
+ 	case VIRTCHNL_OP_UNKNOWN:
+ 	default:
+ 		return VIRTCHNL_ERR_PARAM;
+ 	}
+ 	/* few more checks */
+ 	if ((valid_len != msglen) || (err_msg_format))
+ 		return VIRTCHNL_STATUS_ERR_OPCODE_MISMATCH;
+ 
+ 	return 0;
+ }
+ #endif /* _VIRTCHNL_H_ */
++>>>>>>> 735e35c56bbc (i40e/virtchnl: move function to virtchnl):include/linux/avf/virtchnl.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index c607db0defb5,6bee254d34ee..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -2430,168 -2532,6 +2430,171 @@@ err
  }
  
  /**
++<<<<<<< HEAD
 + * i40e_vc_validate_vf_msg
 + * @vf: pointer to the VF info
 + * @msg: pointer to the msg buffer
 + * @msglen: msg length
 + * @msghndl: msg handle
 + *
 + * validate msg
 + **/
 +static int i40e_vc_validate_vf_msg(struct i40e_vf *vf, u32 v_opcode,
 +				   u32 v_retval, u8 *msg, u16 msglen)
 +{
 +	bool err_msg_format = false;
 +	int valid_len = 0;
 +
 +	/* Check if VF is disabled. */
 +	if (test_bit(I40E_VF_STATE_DISABLED, &vf->vf_states))
 +		return I40E_ERR_PARAM;
 +
 +	/* Validate message length. */
 +	switch (v_opcode) {
 +	case I40E_VIRTCHNL_OP_VERSION:
 +		valid_len = sizeof(struct i40e_virtchnl_version_info);
 +		break;
 +	case I40E_VIRTCHNL_OP_RESET_VF:
 +		break;
 +	case I40E_VIRTCHNL_OP_GET_VF_RESOURCES:
 +		if (VF_IS_V11(vf))
 +			valid_len = sizeof(u32);
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_TX_QUEUE:
 +		valid_len = sizeof(struct i40e_virtchnl_txq_info);
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE:
 +		valid_len = sizeof(struct i40e_virtchnl_rxq_info);
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES:
 +		valid_len = sizeof(struct i40e_virtchnl_vsi_queue_config_info);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_vsi_queue_config_info *vqc =
 +			    (struct i40e_virtchnl_vsi_queue_config_info *)msg;
 +			valid_len += (vqc->num_queue_pairs *
 +				      sizeof(struct
 +					     i40e_virtchnl_queue_pair_info));
 +			if (vqc->num_queue_pairs == 0)
 +				err_msg_format = true;
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP:
 +		valid_len = sizeof(struct i40e_virtchnl_irq_map_info);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_irq_map_info *vimi =
 +			    (struct i40e_virtchnl_irq_map_info *)msg;
 +			valid_len += (vimi->num_vectors *
 +				      sizeof(struct i40e_virtchnl_vector_map));
 +			if (vimi->num_vectors == 0)
 +				err_msg_format = true;
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_ENABLE_QUEUES:
 +	case I40E_VIRTCHNL_OP_DISABLE_QUEUES:
 +		valid_len = sizeof(struct i40e_virtchnl_queue_select);
 +		break;
 +	case I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS:
 +	case I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS:
 +		valid_len = sizeof(struct i40e_virtchnl_ether_addr_list);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_ether_addr_list *veal =
 +			    (struct i40e_virtchnl_ether_addr_list *)msg;
 +			valid_len += veal->num_elements *
 +			    sizeof(struct i40e_virtchnl_ether_addr);
 +			if (veal->num_elements == 0)
 +				err_msg_format = true;
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_ADD_VLAN:
 +	case I40E_VIRTCHNL_OP_DEL_VLAN:
 +		valid_len = sizeof(struct i40e_virtchnl_vlan_filter_list);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_vlan_filter_list *vfl =
 +			    (struct i40e_virtchnl_vlan_filter_list *)msg;
 +			valid_len += vfl->num_elements * sizeof(u16);
 +			if (vfl->num_elements == 0)
 +				err_msg_format = true;
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE:
 +		valid_len = sizeof(struct i40e_virtchnl_promisc_info);
 +		break;
 +	case I40E_VIRTCHNL_OP_GET_STATS:
 +		valid_len = sizeof(struct i40e_virtchnl_queue_select);
 +		break;
 +	case I40E_VIRTCHNL_OP_IWARP:
 +		/* These messages are opaque to us and will be validated in
 +		 * the RDMA client code. We just need to check for nonzero
 +		 * length. The firmware will enforce max length restrictions.
 +		 */
 +		if (msglen)
 +			valid_len = msglen;
 +		else
 +			err_msg_format = true;
 +		break;
 +	case I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP:
 +		valid_len = 0;
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP:
 +		valid_len = sizeof(struct i40e_virtchnl_iwarp_qvlist_info);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_iwarp_qvlist_info *qv =
 +				(struct i40e_virtchnl_iwarp_qvlist_info *)msg;
 +			if (qv->num_vectors == 0) {
 +				err_msg_format = true;
 +				break;
 +			}
 +			valid_len += ((qv->num_vectors - 1) *
 +				sizeof(struct i40e_virtchnl_iwarp_qv_info));
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_RSS_KEY:
 +		valid_len = sizeof(struct i40e_virtchnl_rss_key);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_rss_key *vrk =
 +				(struct i40e_virtchnl_rss_key *)msg;
 +			if (vrk->key_len != I40E_HKEY_ARRAY_SIZE) {
 +				err_msg_format = true;
 +				break;
 +			}
 +			valid_len += vrk->key_len - 1;
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_CONFIG_RSS_LUT:
 +		valid_len = sizeof(struct i40e_virtchnl_rss_lut);
 +		if (msglen >= valid_len) {
 +			struct i40e_virtchnl_rss_lut *vrl =
 +				(struct i40e_virtchnl_rss_lut *)msg;
 +			if (vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE) {
 +				err_msg_format = true;
 +				break;
 +			}
 +			valid_len += vrl->lut_entries - 1;
 +		}
 +		break;
 +	case I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS:
 +		break;
 +	case I40E_VIRTCHNL_OP_SET_RSS_HENA:
 +		valid_len = sizeof(struct i40e_virtchnl_rss_hena);
 +		break;
 +	/* These are always errors coming from the VF. */
 +	case I40E_VIRTCHNL_OP_EVENT:
 +	case I40E_VIRTCHNL_OP_UNKNOWN:
 +	default:
 +		return -EPERM;
 +	}
 +	/* few more checks */
 +	if ((valid_len != msglen) || (err_msg_format)) {
 +		i40e_vc_send_resp_to_vf(vf, v_opcode, I40E_ERR_PARAM);
 +		return -EINVAL;
 +	} else {
 +		return 0;
 +	}
 +}
 +
 +/**
++=======
++>>>>>>> 735e35c56bbc (i40e/virtchnl: move function to virtchnl)
   * i40e_vc_process_vf_msg
   * @pf: pointer to the PF structure
   * @vf_id: source VF id
@@@ -2614,13 -2554,37 +2617,30 @@@ int i40e_vc_process_vf_msg(struct i40e_
  	if (local_vf_id >= pf->num_alloc_vfs)
  		return -EINVAL;
  	vf = &(pf->vf[local_vf_id]);
 -
 -	/* Check if VF is disabled. */
 -	if (test_bit(I40E_VF_STATE_DISABLED, &vf->vf_states))
 -		return I40E_ERR_PARAM;
 -
  	/* perform basic checks on the msg */
++<<<<<<< HEAD
 +	ret = i40e_vc_validate_vf_msg(vf, v_opcode, v_retval, msg, msglen);
++=======
+ 	ret = virtchnl_vc_validate_vf_msg(&vf->vf_ver, v_opcode, msg, msglen);
+ 
+ 	/* perform additional checks specific to this driver */
+ 	if (v_opcode == VIRTCHNL_OP_CONFIG_RSS_KEY) {
+ 		struct virtchnl_rss_key *vrk = (struct virtchnl_rss_key *)msg;
+ 
+ 		if (vrk->key_len != I40E_HKEY_ARRAY_SIZE)
+ 			ret = -EINVAL;
+ 	} else if (v_opcode == VIRTCHNL_OP_CONFIG_RSS_LUT) {
+ 		struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
+ 
+ 		if (vrl->lut_entries != I40E_VF_HLUT_ARRAY_SIZE)
+ 			ret = -EINVAL;
+ 	}
++>>>>>>> 735e35c56bbc (i40e/virtchnl: move function to virtchnl)
  
  	if (ret) {
 -		i40e_vc_send_resp_to_vf(vf, v_opcode, I40E_ERR_PARAM);
  		dev_err(&pf->pdev->dev, "Invalid message from VF %d, opcode %d, len %d\n",
  			local_vf_id, v_opcode, msglen);
 -		switch (ret) {
 -		case VIRTCHNL_ERR_PARAM:
 -			return -EPERM;
 -		default:
 -			return -EINVAL;
 -		}
 +		return ret;
  	}
  
  	switch (v_opcode) {
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
