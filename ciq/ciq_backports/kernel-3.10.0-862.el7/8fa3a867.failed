target: Make TCM_WRITE_PROTECT failure honor D_SENSE bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] Make TCM_WRITE_PROTECT failure honor D_SENSE bit (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 92.31%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 8fa3a867486f85df66eba8c4df85804d3309c6ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8fa3a867.failed

This patch changes transport_lookup_cmd_lun() to obtain
se_lun->lun_ref + se_cmd->se_device rcu_dereference during
TCM_WRITE_PROTECT -> CHECK_CONDITION failure status.

Do this to ensure the active control D_SENSE mode page bit
is being honored.

	Reported-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 8fa3a867486f85df66eba8c4df85804d3309c6ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_device.c
diff --cc drivers/target/target_core_device.c
index 1e65ea95d7f2,88ea4e4f124b..000000000000
--- a/drivers/target/target_core_device.c
+++ b/drivers/target/target_core_device.c
@@@ -59,44 -60,43 +59,64 @@@ transport_lookup_cmd_lun(struct se_cmd 
  {
  	struct se_lun *se_lun = NULL;
  	struct se_session *se_sess = se_cmd->se_sess;
++<<<<<<< HEAD
 +	struct se_device *dev;
 +	unsigned long flags;
++=======
+ 	struct se_node_acl *nacl = se_sess->se_node_acl;
+ 	struct se_dev_entry *deve;
+ 	sense_reason_t ret = TCM_NO_SENSE;
++>>>>>>> 8fa3a867486f (target: Make TCM_WRITE_PROTECT failure honor D_SENSE bit)
 +
 +	if (unpacked_lun >= TRANSPORT_MAX_LUNS_PER_TPG)
 +		return TCM_NON_EXISTENT_LUN;
 +
 +	spin_lock_irqsave(&se_sess->se_node_acl->device_list_lock, flags);
 +	se_cmd->se_deve = se_sess->se_node_acl->device_list[unpacked_lun];
 +	if (se_cmd->se_deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS) {
 +		struct se_dev_entry *deve = se_cmd->se_deve;
  
 -	rcu_read_lock();
 -	deve = target_nacl_find_deve(nacl, unpacked_lun);
 -	if (deve) {
 -		atomic_long_inc(&deve->total_cmds);
 +		deve->total_cmds++;
  
++<<<<<<< HEAD
 +		if ((se_cmd->data_direction == DMA_TO_DEVICE) &&
 +		    (deve->lun_flags & TRANSPORT_LUNFLAGS_READ_ONLY)) {
 +			pr_err("TARGET_CORE[%s]: Detected WRITE_PROTECTED LUN"
 +				" Access for 0x%08x\n",
 +				se_cmd->se_tfo->get_fabric_name(),
 +				unpacked_lun);
 +			spin_unlock_irqrestore(&se_sess->se_node_acl->device_list_lock, flags);
 +			return TCM_WRITE_PROTECTED;
 +		}
 +
++=======
++>>>>>>> 8fa3a867486f (target: Make TCM_WRITE_PROTECT failure honor D_SENSE bit)
  		if (se_cmd->data_direction == DMA_TO_DEVICE)
 -			atomic_long_add(se_cmd->data_length,
 -					&deve->write_bytes);
 +			deve->write_bytes += se_cmd->data_length;
  		else if (se_cmd->data_direction == DMA_FROM_DEVICE)
 -			atomic_long_add(se_cmd->data_length,
 -					&deve->read_bytes);
 +			deve->read_bytes += se_cmd->data_length;
  
 -		se_lun = rcu_dereference(deve->se_lun);
 -		se_cmd->se_lun = rcu_dereference(deve->se_lun);
 +		se_lun = deve->se_lun;
 +		se_cmd->se_lun = deve->se_lun;
  		se_cmd->pr_res_key = deve->pr_res_key;
  		se_cmd->orig_fe_lun = unpacked_lun;
  		se_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;
  
  		percpu_ref_get(&se_lun->lun_ref);
  		se_cmd->lun_ref_active = true;
+ 
+ 		if ((se_cmd->data_direction == DMA_TO_DEVICE) &&
+ 		    (deve->lun_flags & TRANSPORT_LUNFLAGS_READ_ONLY)) {
+ 			pr_err("TARGET_CORE[%s]: Detected WRITE_PROTECTED LUN"
+ 				" Access for 0x%08llx\n",
+ 				se_cmd->se_tfo->get_fabric_name(),
+ 				unpacked_lun);
+ 			rcu_read_unlock();
+ 			ret = TCM_WRITE_PROTECTED;
+ 			goto ref_dev;
+ 		}
  	}
 -	rcu_read_unlock();
 +	spin_unlock_irqrestore(&se_sess->se_node_acl->device_list_lock, flags);
  
  	if (!se_lun) {
  		/*
@@@ -111,33 -111,42 +131,48 @@@
  				unpacked_lun);
  			return TCM_NON_EXISTENT_LUN;
  		}
- 		/*
- 		 * Force WRITE PROTECT for virtual LUN 0
- 		 */
- 		if ((se_cmd->data_direction != DMA_FROM_DEVICE) &&
- 		    (se_cmd->data_direction != DMA_NONE))
- 			return TCM_WRITE_PROTECTED;
  
 -		se_lun = se_sess->se_tpg->tpg_virt_lun0;
 -		se_cmd->se_lun = se_sess->se_tpg->tpg_virt_lun0;
 +		se_lun = &se_sess->se_tpg->tpg_virt_lun0;
 +		se_cmd->se_lun = &se_sess->se_tpg->tpg_virt_lun0;
  		se_cmd->orig_fe_lun = 0;
  		se_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;
  
  		percpu_ref_get(&se_lun->lun_ref);
  		se_cmd->lun_ref_active = true;
+ 
+ 		/*
+ 		 * Force WRITE PROTECT for virtual LUN 0
+ 		 */
+ 		if ((se_cmd->data_direction != DMA_FROM_DEVICE) &&
+ 		    (se_cmd->data_direction != DMA_NONE)) {
+ 			ret = TCM_WRITE_PROTECTED;
+ 			goto ref_dev;
+ 		}
  	}
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * RCU reference protected by percpu se_lun->lun_ref taken above that
+ 	 * must drop to zero (including initial reference) before this se_lun
+ 	 * pointer can be kfree_rcu() by the final se_lun->lun_group put via
+ 	 * target_core_fabric_configfs.c:target_fabric_port_release
+ 	 */
+ ref_dev:
+ 	se_cmd->se_dev = rcu_dereference_raw(se_lun->lun_se_dev);
+ 	atomic_long_inc(&se_cmd->se_dev->num_cmds);
++>>>>>>> 8fa3a867486f (target: Make TCM_WRITE_PROTECT failure honor D_SENSE bit)
  
 +	/* Directly associate cmd with se_dev */
 +	se_cmd->se_dev = se_lun->lun_se_dev;
 +
 +	dev = se_lun->lun_se_dev;
 +	atomic_long_inc(&dev->num_cmds);
  	if (se_cmd->data_direction == DMA_TO_DEVICE)
 -		atomic_long_add(se_cmd->data_length,
 -				&se_cmd->se_dev->write_bytes);
 +		atomic_long_add(se_cmd->data_length, &dev->write_bytes);
  	else if (se_cmd->data_direction == DMA_FROM_DEVICE)
 -		atomic_long_add(se_cmd->data_length,
 -				&se_cmd->se_dev->read_bytes);
 +		atomic_long_add(se_cmd->data_length, &dev->read_bytes);
  
- 	return 0;
+ 	return ret;
  }
  EXPORT_SYMBOL(transport_lookup_cmd_lun);
  
* Unmerged path drivers/target/target_core_device.c
