fsnotify: Remove fsnotify_recalc_{inode|vfsmount}_mask()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jan Kara <jack@suse.cz>
commit 8920d2734d9a1b68e1b53d8c12b289773cdbd971
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/8920d273.failed

These helpers are just very thin wrappers now. Remove them.

	Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 8920d2734d9a1b68e1b53d8c12b289773cdbd971)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/inode_mark.c
#	fs/notify/vfsmount_mark.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/inode_mark.c
index 1168d71dbf85,2188329da3c2..000000000000
--- a/fs/notify/inode_mark.c
+++ b/fs/notify/inode_mark.c
@@@ -30,40 -30,6 +30,43 @@@
  
  #include "../internal.h"
  
++<<<<<<< HEAD
 +/*
 + * Recalculate the inode->i_fsnotify_mask, or the mask of all FS_* event types
 + * any notifier is interested in hearing for this inode.
 + */
 +void fsnotify_recalc_inode_mask(struct inode *inode)
 +{
 +	spin_lock(&inode->i_lock);
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +
 +	__fsnotify_update_child_dentry_flags(inode);
 +}
 +
 +void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)
 +{
 +	struct inode *inode = mark->inode;
 +
 +	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&inode->i_lock);
 +
 +	hlist_del_init_rcu(&mark->obj_list);
 +	mark->inode = NULL;
 +
 +	/*
 +	 * this mark is now off the inode->i_fsnotify_marks list and we
 +	 * hold the inode->i_lock, so this is the perfect time to update the
 +	 * inode->i_fsnotify_mask
 +	 */
 +	inode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);
 +	spin_unlock(&inode->i_lock);
 +}
 +
++=======
++>>>>>>> 8920d2734d9a (fsnotify: Remove fsnotify_recalc_{inode|vfsmount}_mask())
  /*
   * Given a group clear all of the inode marks associated with that group.
   */
diff --cc fs/notify/vfsmount_mark.c
index a8fcab68faef,41bff46576c2..000000000000
--- a/fs/notify/vfsmount_mark.c
+++ b/fs/notify/vfsmount_mark.c
@@@ -31,39 -31,9 +31,42 @@@
  
  void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)
  {
 -	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_OBJ_TYPE_VFSMOUNT);
 +	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_VFSMOUNT);
  }
  
++<<<<<<< HEAD
 +/*
 + * Recalculate the mnt->mnt_fsnotify_mask, or the mask of all FS_* event types
 + * any notifier is interested in hearing for this mount point
 + */
 +void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)
 +{
 +	struct mount *m = real_mount(mnt);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
 +}
 +
 +void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)
 +{
 +	struct vfsmount *mnt = mark->mnt;
 +	struct mount *m = real_mount(mnt);
 +
 +	BUG_ON(!mutex_is_locked(&mark->group->mark_mutex));
 +	assert_spin_locked(&mark->lock);
 +
 +	spin_lock(&mnt->mnt_root->d_lock);
 +
 +	hlist_del_init_rcu(&mark->obj_list);
 +	mark->mnt = NULL;
 +
 +	m->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);
 +	spin_unlock(&mnt->mnt_root->d_lock);
 +}
 +
++=======
++>>>>>>> 8920d2734d9a (fsnotify: Remove fsnotify_recalc_{inode|vfsmount}_mask())
  /*
   * given a group and vfsmount, find the mark associated with that combination.
   * if found take a reference to that mark and return it, else return NULL
diff --cc include/linux/fsnotify_backend.h
index 0256909191e5,6d09c6ff9810..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -331,10 -336,8 +331,15 @@@ extern struct fsnotify_event *fsnotify_
  
  /* functions used to manipulate the marks attached to inodes */
  
++<<<<<<< HEAD
 +/* run all marks associated with a vfsmount and update mnt->mnt_fsnotify_mask */
 +extern void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt);
 +/* run all marks associated with an inode and update inode->i_fsnotify_mask */
 +extern void fsnotify_recalc_inode_mask(struct inode *inode);
++=======
+ /* Calculate mask of events for a list of marks */
+ extern void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
++>>>>>>> 8920d2734d9a (fsnotify: Remove fsnotify_recalc_{inode|vfsmount}_mask())
  extern void fsnotify_init_mark(struct fsnotify_mark *mark, void (*free_mark)(struct fsnotify_mark *mark));
  /* find (and take a reference) to a mark associated with group and inode */
  extern struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group, struct inode *inode);
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 0bc2e0fd9d85..59a6ab9954f7 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -545,7 +545,7 @@ static int fanotify_remove_vfsmount_mark(struct fsnotify_group *group,
 	removed = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,
 						 &destroy_mark);
 	if (removed & real_mount(mnt)->mnt_fsnotify_mask)
-		fsnotify_recalc_vfsmount_mask(mnt);
+		fsnotify_recalc_mask(real_mount(mnt)->mnt_fsnotify_marks);
 	if (destroy_mark)
 		fsnotify_detach_mark(fsn_mark);
 	mutex_unlock(&group->mark_mutex);
@@ -574,7 +574,7 @@ static int fanotify_remove_inode_mark(struct fsnotify_group *group,
 	removed = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,
 						 &destroy_mark);
 	if (removed & inode->i_fsnotify_mask)
-		fsnotify_recalc_inode_mask(inode);
+		fsnotify_recalc_mask(inode->i_fsnotify_marks);
 	if (destroy_mark)
 		fsnotify_detach_mark(fsn_mark);
 	mutex_unlock(&group->mark_mutex);
@@ -659,7 +659,7 @@ static int fanotify_add_vfsmount_mark(struct fsnotify_group *group,
 	}
 	added = fanotify_mark_add_to_mask(fsn_mark, mask, flags);
 	if (added & ~real_mount(mnt)->mnt_fsnotify_mask)
-		fsnotify_recalc_vfsmount_mask(mnt);
+		fsnotify_recalc_mask(real_mount(mnt)->mnt_fsnotify_marks);
 	mutex_unlock(&group->mark_mutex);
 
 	fsnotify_put_mark(fsn_mark);
@@ -696,7 +696,7 @@ static int fanotify_add_inode_mark(struct fsnotify_group *group,
 	}
 	added = fanotify_mark_add_to_mask(fsn_mark, mask, flags);
 	if (added & ~inode->i_fsnotify_mask)
-		fsnotify_recalc_inode_mask(inode);
+		fsnotify_recalc_mask(inode->i_fsnotify_marks);
 	mutex_unlock(&group->mark_mutex);
 
 	fsnotify_put_mark(fsn_mark);
* Unmerged path fs/notify/inode_mark.c
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 9881b183eb6d..5a7567ce6bcb 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -533,7 +533,7 @@ static int inotify_update_existing_watch(struct fsnotify_group *group,
 
 		/* update the inode with this new fsn_mark */
 		if (dropped || do_inode)
-			fsnotify_recalc_inode_mask(inode);
+			fsnotify_recalc_mask(inode->i_fsnotify_marks);
 
 	}
 
* Unmerged path fs/notify/vfsmount_mark.c
* Unmerged path include/linux/fsnotify_backend.h
