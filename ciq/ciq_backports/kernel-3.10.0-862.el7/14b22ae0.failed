perf pmu: Add helper function is_pmu_core to detect PMU CORE devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ganapatrao Kulkarni <ganapatrao.kulkarni@cavium.com>
commit 14b22ae028de56cca980171db625d1e9925c8fba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/14b22ae0.failed

On some platforms, PMU core devices sysfs name is not cpu.
Adding function is_pmu_core to detect PMU core devices using
core device specific hints in sysfs.

For arm64 platforms, all core devices have file "cpus" in sysfs.

	Signed-off-by: Ganapatrao Kulkarni <ganapatrao.kulkarni@cavium.com>
	Tested-by: Shaokun Zhang <zhangshaokun@hisilicon.com>
	Tested-by: Jin Yao <yao.jin@linux.intel.com>
	Acked-by: Will Deacon <will.deacon@arm.com>
Link: https://lkml.kernel.org/n/tip-y1woxt1k2pqqwpprhonnft2s@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 14b22ae028de56cca980171db625d1e9925c8fba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/pmu.c
diff --cc tools/perf/util/pmu.c
index ebc492ac459e,732ff579ec65..000000000000
--- a/tools/perf/util/pmu.c
+++ b/tools/perf/util/pmu.c
@@@ -501,6 -492,79 +501,82 @@@ static struct cpu_map *pmu_cpumask(cons
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Uncore PMUs have a "cpumask" file under sysfs. CPU PMUs (e.g. on arm/arm64)
+  * may have a "cpus" file.
+  */
+ #define CPUS_TEMPLATE_UNCORE	"%s/bus/event_source/devices/%s/cpumask"
+ #define CPUS_TEMPLATE_CPU	"%s/bus/event_source/devices/%s/cpus"
+ 
+ static struct cpu_map *pmu_cpumask(const char *name)
+ {
+ 	char path[PATH_MAX];
+ 	struct cpu_map *cpus;
+ 	const char *sysfs = sysfs__mountpoint();
+ 	const char *templates[] = {
+ 		CPUS_TEMPLATE_UNCORE,
+ 		CPUS_TEMPLATE_CPU,
+ 		NULL
+ 	};
+ 	const char **template;
+ 
+ 	if (!sysfs)
+ 		return NULL;
+ 
+ 	for (template = templates; *template; template++) {
+ 		snprintf(path, PATH_MAX, *template, sysfs, name);
+ 		cpus = __pmu_cpumask(path);
+ 		if (cpus)
+ 			return cpus;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static bool pmu_is_uncore(const char *name)
+ {
+ 	char path[PATH_MAX];
+ 	struct cpu_map *cpus;
+ 	const char *sysfs = sysfs__mountpoint();
+ 
+ 	snprintf(path, PATH_MAX, CPUS_TEMPLATE_UNCORE, sysfs, name);
+ 	cpus = __pmu_cpumask(path);
+ 	cpu_map__put(cpus);
+ 
+ 	return !!cpus;
+ }
+ 
+ /*
+  *  PMU CORE devices have different name other than cpu in sysfs on some
+  *  platforms. looking for possible sysfs files to identify as core device.
+  */
+ static int is_pmu_core(const char *name)
+ {
+ 	struct stat st;
+ 	char path[PATH_MAX];
+ 	const char *sysfs = sysfs__mountpoint();
+ 
+ 	if (!sysfs)
+ 		return 0;
+ 
+ 	/* Look for cpu sysfs (x86 and others) */
+ 	scnprintf(path, PATH_MAX, "%s/bus/event_source/devices/cpu", sysfs);
+ 	if ((stat(path, &st) == 0) &&
+ 			(strncmp(name, "cpu", strlen("cpu")) == 0))
+ 		return 1;
+ 
+ 	/* Look for cpu sysfs (specific to arm) */
+ 	scnprintf(path, PATH_MAX, "%s/bus/event_source/devices/%s/cpus",
+ 				sysfs, name);
+ 	if (stat(path, &st) == 0)
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ /*
++>>>>>>> 14b22ae028de (perf pmu: Add helper function is_pmu_core to detect PMU CORE devices)
   * Return the CPU id as a raw string.
   *
   * Each architecture should provide a more precise id string that
@@@ -552,15 -637,21 +628,18 @@@ static void pmu_add_cpu_aliases(struct 
  	 */
  	i = 0;
  	while (1) {
- 		const char *pname;
  
  		pe = &map->table[i++];
 -		if (!pe->name) {
 -			if (pe->metric_group || pe->metric_name)
 -				continue;
 +		if (!pe->name)
  			break;
 -		}
  
- 		pname = pe->pmu ? pe->pmu : "cpu";
- 		if (strncmp(pname, name, strlen(pname)))
- 			continue;
+ 		if (!is_pmu_core(name)) {
+ 			/* check for uncore devices */
+ 			if (pe->pmu == NULL)
+ 				continue;
+ 			if (strncmp(pe->pmu, name, strlen(pe->pmu)))
+ 				continue;
+ 		}
  
  		/* need type casts to override 'const' */
  		__perf_pmu__new_alias(head, NULL, (char *)pe->name,
* Unmerged path tools/perf/util/pmu.c
