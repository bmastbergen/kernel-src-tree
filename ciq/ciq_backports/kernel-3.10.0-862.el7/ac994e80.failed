s390/zcrypt: Rework ap init in case of out of range domain param.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] zcrypt: Rework ap init in case of out of range domain param (Hendrik Brueckner) [1380349]
Rebuild_FUZZ: 95.16%
commit-author Harald Freudenberger <freude@linux.vnet.ibm.com>
commit ac994e80f94f440138774830f2edf148d6ece1f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ac994e80.failed

When a out of range domain parameter was given, the init function
returned with -EINVAL and the driver was not operational. As the
driver is statically build into the kernel and is able to work
with multiple domains anyway the init function should continue.
Now the user has a chance to write a new default domain value
via sysfs attribute file. Also added two new dbf debug messages
related to the domain value handling.

	Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit ac994e80f94f440138774830f2edf148d6ece1f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 5386d81f8cd3,6dee598979e7..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1095,7 -754,24 +1095,28 @@@ static ssize_t ap_domain_show(struct bu
  	return snprintf(buf, PAGE_SIZE, "%d\n", ap_domain_index);
  }
  
++<<<<<<< HEAD
 +static BUS_ATTR(ap_domain, 0444, ap_domain_show, NULL);
++=======
+ static ssize_t ap_domain_store(struct bus_type *bus,
+ 			       const char *buf, size_t count)
+ {
+ 	int domain;
+ 
+ 	if (sscanf(buf, "%i\n", &domain) != 1 ||
+ 	    domain < 0 || domain > ap_max_domain_id)
+ 		return -EINVAL;
+ 	spin_lock_bh(&ap_domain_lock);
+ 	ap_domain_index = domain;
+ 	spin_unlock_bh(&ap_domain_lock);
+ 
+ 	AP_DBF(DBF_DEBUG, "stored new default domain=%d\n", domain);
+ 
+ 	return count;
+ }
+ 
+ static BUS_ATTR(ap_domain, 0644, ap_domain_show, ap_domain_store);
++>>>>>>> ac994e80f94f (s390/zcrypt: Rework ap init in case of out of range domain param.)
  
  static ssize_t ap_control_domain_mask_show(struct bus_type *bus, char *buf)
  {
@@@ -1316,707 -952,179 +1337,850 @@@ static int ap_select_domain(void
  	}
  	if (best_domain >= 0){
  		ap_domain_index = best_domain;
++<<<<<<< HEAD
++=======
+ 		AP_DBF(DBF_DEBUG, "new ap_domain_index=%d\n", ap_domain_index);
+ 		spin_unlock_bh(&ap_domain_lock);
++>>>>>>> ac994e80f94f (s390/zcrypt: Rework ap init in case of out of range domain param.)
  		return 0;
  	}
 -	spin_unlock_bh(&ap_domain_lock);
  	return -ENODEV;
  }
  
 -/*
 - * helper function to be used with bus_find_dev
 - * matches for the card device with the given id
 +/**
 + * ap_probe_device_type(): Find the device type of an AP.
 + * @ap_dev: pointer to the AP device.
 + *
 + * Find the device type if query queue returned a device type of 0.
   */
 -static int __match_card_device_with_id(struct device *dev, void *data)
 +static int ap_probe_device_type(struct ap_device *ap_dev)
  {
 -	return is_card_dev(dev) && to_ap_card(dev)->id == (int)(long) data;
 -}
 +	static unsigned char msg[] = {
 +		0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x58,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x01,0x00,0x43,0x43,0x41,0x2d,0x41,0x50,
 +		0x50,0x4c,0x20,0x20,0x20,0x01,0x01,0x01,
 +		0x00,0x00,0x00,0x00,0x50,0x4b,0x00,0x00,
 +		0x00,0x00,0x01,0x1c,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x05,0xb8,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x70,0x00,0x41,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x54,0x32,0x01,0x00,0xa0,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0xb8,0x05,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 +		0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
 +		0x49,0x43,0x53,0x46,0x20,0x20,0x20,0x20,
 +		0x50,0x4b,0x0a,0x00,0x50,0x4b,0x43,0x53,
 +		0x2d,0x31,0x2e,0x32,0x37,0x00,0x11,0x22,
 +		0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,
 +		0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,
 +		0x99,0x00,0x11,0x22,0x33,0x44,0x55,0x66,
 +		0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,
 +		0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,
 +		0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,
 +		0x11,0x22,0x33,0x5d,0x00,0x5b,0x00,0x77,
 +		0x88,0x1e,0x00,0x00,0x57,0x00,0x00,0x00,
 +		0x00,0x04,0x00,0x00,0x4f,0x00,0x00,0x00,
 +		0x03,0x02,0x00,0x00,0x40,0x01,0x00,0x01,
 +		0xce,0x02,0x68,0x2d,0x5f,0xa9,0xde,0x0c,
 +		0xf6,0xd2,0x7b,0x58,0x4b,0xf9,0x28,0x68,
 +		0x3d,0xb4,0xf4,0xef,0x78,0xd5,0xbe,0x66,
 +		0x63,0x42,0xef,0xf8,0xfd,0xa4,0xf8,0xb0,
 +		0x8e,0x29,0xc2,0xc9,0x2e,0xd8,0x45,0xb8,
 +		0x53,0x8c,0x6f,0x4e,0x72,0x8f,0x6c,0x04,
 +		0x9c,0x88,0xfc,0x1e,0xc5,0x83,0x55,0x57,
 +		0xf7,0xdd,0xfd,0x4f,0x11,0x36,0x95,0x5d,
 +	};
 +	struct ap_queue_status status;
 +	unsigned long long psmid;
 +	char *reply;
 +	int rc, i;
  
 -/* helper function to be used with bus_find_dev
 - * matches for the queue device with a given qid
 - */
 -static int __match_queue_device_with_qid(struct device *dev, void *data)
 -{
 -	return is_queue_dev(dev) && to_ap_queue(dev)->qid == (int)(long) data;
 -}
 +	reply = (void *) get_zeroed_page(GFP_KERNEL);
 +	if (!reply) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
  
 -/**
 - * ap_scan_bus(): Scan the AP bus for new devices
 - * Runs periodically, workqueue timer (ap_config_time)
 - */
 -static void ap_scan_bus(struct work_struct *unused)
 -{
 -	struct ap_queue *aq;
 -	struct ap_card *ac;
 -	struct device *dev;
 +	status = __ap_send(ap_dev->qid, 0x0102030405060708ULL,
 +			   msg, sizeof(msg), 0);
 +	if (status.response_code != AP_RESPONSE_NORMAL) {
 +		rc = -ENODEV;
 +		goto out_free;
 +	}
 +
 +	/* Wait for the test message to complete. */
 +	for (i = 0; i < 6; i++) {
 +		mdelay(300);
 +		status = __ap_recv(ap_dev->qid, &psmid, reply, 4096);
 +		if (status.response_code == AP_RESPONSE_NORMAL &&
 +		    psmid == 0x0102030405060708ULL)
 +			break;
 +	}
 +	if (i < 6) {
 +		/* Got an answer. */
 +		if (reply[0] == 0x00 && reply[1] == 0x86)
 +			ap_dev->device_type = AP_DEVICE_TYPE_PCICC;
 +		else
 +			ap_dev->device_type = AP_DEVICE_TYPE_PCICA;
 +		rc = 0;
 +	} else
 +		rc = -ENODEV;
 +
 +out_free:
 +	free_page((unsigned long) reply);
 +out:
 +	return rc;
 +}
 +
 +static void ap_interrupt_handler(struct airq_struct *airq)
 +{
 +	inc_irq_stat(IRQIO_APB);
 +	tasklet_schedule(&ap_tasklet);
 +}
 +
 +/**
 + * __ap_scan_bus(): Scan the AP bus.
 + * @dev: Pointer to device
 + * @data: Pointer to data
 + *
 + * Scan the AP bus for new devices.
 + */
 +static int __ap_scan_bus(struct device *dev, void *data)
 +{
++<<<<<<< HEAD
 +	return to_ap_dev(dev)->qid == (ap_qid_t)(unsigned long) data;
++=======
++	struct ap_queue *aq;
++	struct ap_card *ac;
++	struct device *dev;
+ 	ap_qid_t qid;
+ 	int depth = 0, type = 0;
+ 	unsigned int functions = 0;
+ 	int rc, id, dom, borked, domains, defdomdevs = 0;
+ 
+ 	AP_DBF(DBF_DEBUG, "ap_scan_bus running\n");
+ 
+ 	ap_query_configuration();
+ 	if (ap_select_domain() != 0)
+ 		goto out;
+ 
+ 	for (id = 0; id < AP_DEVICES; id++) {
+ 		/* check if device is registered */
+ 		dev = bus_find_device(&ap_bus_type, NULL,
+ 				      (void *)(long) id,
+ 				      __match_card_device_with_id);
+ 		ac = dev ? to_ap_card(dev) : NULL;
+ 		if (!ap_test_config_card_id(id)) {
+ 			if (dev) {
+ 				/* Card device has been removed from
+ 				 * configuration, remove the belonging
+ 				 * queue devices.
+ 				 */
+ 				bus_for_each_dev(&ap_bus_type, NULL,
+ 					(void *)(long) id,
+ 					__ap_queue_devices_with_id_unregister);
+ 				/* now remove the card device */
+ 				device_unregister(dev);
+ 				put_device(dev);
+ 			}
+ 			continue;
+ 		}
+ 		/* According to the configuration there should be a card
+ 		 * device, so check if there is at least one valid queue
+ 		 * and maybe create queue devices and the card device.
+ 		 */
+ 		domains = 0;
+ 		for (dom = 0; dom < AP_DOMAINS; dom++) {
+ 			qid = AP_MKQID(id, dom);
+ 			dev = bus_find_device(&ap_bus_type, NULL,
+ 					      (void *)(long) qid,
+ 					      __match_queue_device_with_qid);
+ 			aq = dev ? to_ap_queue(dev) : NULL;
+ 			if (!ap_test_config_domain(dom)) {
+ 				if (dev) {
+ 					/* Queue device exists but has been
+ 					 * removed from configuration.
+ 					 */
+ 					device_unregister(dev);
+ 					put_device(dev);
+ 				}
+ 				continue;
+ 			}
+ 			rc = ap_query_queue(qid, &depth, &type, &functions);
+ 			if (dev) {
+ 				spin_lock_bh(&aq->lock);
+ 				if (rc == -ENODEV ||
+ 				    /* adapter reconfiguration */
+ 				    (ac && ac->functions != functions))
+ 					aq->state = AP_STATE_BORKED;
+ 				borked = aq->state == AP_STATE_BORKED;
+ 				spin_unlock_bh(&aq->lock);
+ 				if (borked)	/* Remove broken device */
+ 					device_unregister(dev);
+ 				put_device(dev);
+ 				if (!borked) {
+ 					domains++;
+ 					if (dom == ap_domain_index)
+ 						defdomdevs++;
+ 					continue;
+ 				}
+ 			}
+ 			if (rc)
+ 				continue;
+ 			/* new queue device needed */
+ 			if (!ac) {
+ 				/* but first create the card device */
+ 				ac = ap_card_create(id, depth,
+ 						    type, functions);
+ 				if (!ac)
+ 					continue;
+ 				ac->ap_dev.device.bus = &ap_bus_type;
+ 				ac->ap_dev.device.parent = ap_root_device;
+ 				dev_set_name(&ac->ap_dev.device,
+ 					     "card%02x", id);
+ 				/* Register card with AP bus */
+ 				rc = device_register(&ac->ap_dev.device);
+ 				if (rc) {
+ 					put_device(&ac->ap_dev.device);
+ 					ac = NULL;
+ 					break;
+ 				}
+ 				/* get it and thus adjust reference counter */
+ 				get_device(&ac->ap_dev.device);
+ 			}
+ 			/* now create the new queue device */
+ 			aq = ap_queue_create(qid, type);
+ 			if (!aq)
+ 				continue;
+ 			aq->card = ac;
+ 			aq->ap_dev.device.bus = &ap_bus_type;
+ 			aq->ap_dev.device.parent = &ac->ap_dev.device;
+ 			dev_set_name(&aq->ap_dev.device,
+ 				     "%02x.%04x", id, dom);
+ 			/* Start with a device reset */
+ 			spin_lock_bh(&aq->lock);
+ 			ap_wait(ap_sm_event(aq, AP_EVENT_POLL));
+ 			spin_unlock_bh(&aq->lock);
+ 			/* Register device */
+ 			rc = device_register(&aq->ap_dev.device);
+ 			if (rc) {
+ 				put_device(&aq->ap_dev.device);
+ 				continue;
+ 			}
+ 			domains++;
+ 			if (dom == ap_domain_index)
+ 				defdomdevs++;
+ 		} /* end domain loop */
+ 		if (ac) {
+ 			/* remove card dev if there are no queue devices */
+ 			if (!domains)
+ 				device_unregister(&ac->ap_dev.device);
+ 			put_device(&ac->ap_dev.device);
+ 		}
+ 	} /* end device loop */
+ 
+ 	if (defdomdevs < 1)
+ 		AP_DBF(DBF_INFO, "no queue device with default domain %d available\n",
+ 		       ap_domain_index);
+ 
+ out:
+ 	mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);
++>>>>>>> ac994e80f94f (s390/zcrypt: Rework ap init in case of out of range domain param.)
 +}
 +
 +static void ap_device_release(struct device *dev)
 +{
 +	struct ap_device *ap_dev = to_ap_dev(dev);
 +
 +	kfree(ap_dev);
  }
  
 -static void ap_config_timeout(unsigned long ptr)
 +static void ap_scan_bus(struct work_struct *unused)
  {
 -	if (ap_suspend_flag)
 +	struct ap_device *ap_dev;
 +	struct device *dev;
 +	ap_qid_t qid;
 +	int queue_depth = 0, device_type = 0;
 +	unsigned int device_functions;
 +	int rc, i;
 +
 +	ap_query_configuration();
 +	if (ap_select_domain() != 0) {
  		return;
 -	queue_work(system_long_wq, &ap_scan_work);
 +	}
 +	for (i = 0; i < AP_DEVICES; i++) {
 +		qid = AP_MKQID(i, ap_domain_index);
 +		dev = bus_find_device(&ap_bus_type, NULL,
 +				      (void *)(unsigned long)qid,
 +				      __ap_scan_bus);
 +		if (ap_test_config_card_id(i))
 +			rc = ap_query_queue(qid, &queue_depth, &device_type);
 +		else
 +			rc = -ENODEV;
 +		if (dev) {
 +			ap_dev = to_ap_dev(dev);
 +			spin_lock_bh(&ap_dev->lock);
 +			if (rc == -ENODEV ||
 +			    ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +				spin_unlock_bh(&ap_dev->lock);
 +				if (ap_dev->unregistered == AP_DEV_UNREGISTERED)
 +					i--;
 +				device_unregister(dev);
 +				put_device(dev);
 +				continue;
 +			}
 +			spin_unlock_bh(&ap_dev->lock);
 +			put_device(dev);
 +			continue;
 +		}
 +		if (rc)
 +			continue;
 +		ap_dev = kzalloc(sizeof(*ap_dev), GFP_KERNEL);
 +		if (!ap_dev)
 +			break;
 +		ap_dev->qid = qid;
 +		rc = ap_init_queue(ap_dev);
 +		if ((rc != 0) && (rc != -EBUSY)) {
 +			kfree(ap_dev);
 +			continue;
 +		}
 +		ap_dev->queue_depth = queue_depth;
 +		ap_dev->unregistered = AP_DEV_REGIST_IN_PROGRESS;
 +		spin_lock_init(&ap_dev->lock);
 +		INIT_LIST_HEAD(&ap_dev->pendingq);
 +		INIT_LIST_HEAD(&ap_dev->requestq);
 +		INIT_LIST_HEAD(&ap_dev->list);
 +		setup_timer(&ap_dev->timeout, ap_request_timeout,
 +			    (unsigned long) ap_dev);
 +		switch (device_type) {
 +		case 0:
 +			/* device type probing for old cards */
 +			if (ap_probe_device_type(ap_dev)) {
 +				kfree(ap_dev);
 +				continue;
 +			}
 +			break;
 +		default:
 +			ap_dev->device_type = device_type;
 +		}
 +		ap_dev->raw_hwtype = device_type;
 +		/* CEX6 toleration: map to CEX5 */
 +		if (device_type == AP_DEVICE_TYPE_CEX6)
 +			ap_dev->device_type = AP_DEVICE_TYPE_CEX5;
 +
 +		rc = ap_query_functions(qid, &device_functions);
 +		if (!rc)
 +			ap_dev->functions = device_functions;
 +		else
 +			ap_dev->functions = 0u;
 +
 +		ap_dev->device.bus = &ap_bus_type;
 +		ap_dev->device.parent = ap_root_device;
 +		if (dev_set_name(&ap_dev->device, "card%02x",
 +				 AP_QID_DEVICE(ap_dev->qid))) {
 +			kfree(ap_dev);
 +			continue;
 +		}
 +		ap_dev->device.release = ap_device_release;
 +		rc = device_register(&ap_dev->device);
 +		if (rc) {
 +			put_device(&ap_dev->device);
 +			continue;
 +		}
 +		/* Add device attributes. */
 +		rc = sysfs_create_group(&ap_dev->device.kobj,
 +					&ap_dev_attr_group);
 +		if (!rc) {
 +			spin_lock_bh(&ap_dev->lock);
 +			ap_dev->unregistered = AP_DEV_REGISTERED;
 +			spin_unlock_bh(&ap_dev->lock);
 +		}
 +		else
 +			device_unregister(&ap_dev->device);
 +	}
 +}
 +
 +static void
 +ap_config_timeout(unsigned long ptr)
 +{
 +	queue_work(ap_work_queue, &ap_config_work);
 +	ap_config_timer.expires = jiffies + ap_config_time * HZ;
 +	add_timer(&ap_config_timer);
 +}
 +
 +/**
 + * ap_poll_read(): Receive pending reply messages from an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_read(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->queue_count <= 0)
 +		return 0;
 +	status = __ap_recv(ap_dev->qid, &ap_dev->reply->psmid,
 +			   ap_dev->reply->message, ap_dev->reply->length);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		ap_dev->interrupt = status.int_enabled;
 +		atomic_dec(&ap_poll_requests);
 +		ap_decrease_queue_count(ap_dev);
 +		list_for_each_entry(ap_msg, &ap_dev->pendingq, list) {
 +			if (ap_msg->psmid != ap_dev->reply->psmid)
 +				continue;
 +			list_del_init(&ap_msg->list);
 +			ap_dev->pendingq_count--;
 +			ap_msg->receive(ap_dev, ap_msg, ap_dev->reply);
 +			break;
 +		}
 +		if (ap_dev->queue_count > 0)
 +			*flags |= 1;
 +		break;
 +	case AP_RESPONSE_NO_PENDING_REPLY:
 +		ap_dev->interrupt = status.int_enabled;
 +		if (status.queue_empty) {
 +			/* The card shouldn't forget requests but who knows. */
 +			atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +			ap_dev->queue_count = 0;
 +			list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +			ap_dev->requestq_count += ap_dev->pendingq_count;
 +			ap_dev->pendingq_count = 0;
 +		} else
 +			*flags |= 2;
 +		break;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_write(): Send messages from the request queue to an AP device.
 + * @ap_dev: pointer to the AP device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Returns 0 if the device is still present, -ENODEV if not.
 + */
 +static int ap_poll_write(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	struct ap_queue_status status;
 +	struct ap_message *ap_msg;
 +
 +	if (ap_dev->requestq_count <= 0 ||
 +	    (ap_dev->queue_count >= ap_dev->queue_depth) ||
 +	    (ap_dev->reset == AP_RESET_IN_PROGRESS))
 +		return 0;
 +	/* Start the next request on the queue. */
 +	ap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);
 +	status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +			   ap_msg->message, ap_msg->length, ap_msg->special);
 +	switch (status.response_code) {
 +	case AP_RESPONSE_NORMAL:
 +		atomic_inc(&ap_poll_requests);
 +		ap_increase_queue_count(ap_dev);
 +		list_move_tail(&ap_msg->list, &ap_dev->pendingq);
 +		ap_dev->requestq_count--;
 +		ap_dev->pendingq_count++;
 +		if (ap_dev->queue_count < ap_dev->queue_depth &&
 +		    ap_dev->requestq_count > 0)
 +			*flags |= 1;
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +		__ap_schedule_poll_timer();
 +	case AP_RESPONSE_Q_FULL:
 +		*flags |= 2;
 +		break;
 +	case AP_RESPONSE_MESSAGE_TOO_BIG:
 +	case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		return -EINVAL;
 +	default:
 +		return -ENODEV;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_queue(): Poll AP device for pending replies and send new messages.
 + * Check if the queue has a pending reset. In case it's done re-enable
 + * interrupts, otherwise reschedule the poll_timer for another attempt.
 + * @ap_dev: pointer to the bus device
 + * @flags: pointer to control flags, bit 2^0 is set if another poll is
 + *	   required, bit 2^1 is set if the poll timer needs to get armed
 + *
 + * Poll AP device for pending replies and send new messages. If either
 + * ap_poll_read or ap_poll_write returns -ENODEV unregister the device.
 + * Returns 0.
 + */
 +static inline int ap_poll_queue(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc, depth, type;
 +	struct ap_queue_status status;
 +
 +
 +	if (ap_dev->reset == AP_RESET_IN_PROGRESS) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			ap_dev->reset = AP_RESET_IGNORE;
 +			if (ap_using_interrupts()) {
 +				rc = ap_queue_enable_interruption(
 +					ap_dev, ap_airq.lsi_ptr);
 +				if (!rc)
 +					ap_dev->interrupt = AP_INTR_IN_PROGRESS;
 +				else if (rc == -ENODEV) {
 +					pr_err("Registering adapter interrupts for "
 +					"AP %d failed\n", AP_QID_DEVICE(ap_dev->qid));
 +					return rc;
 +				}
 +			}
 +			/* fall through */
 +		case AP_RESPONSE_BUSY:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			*flags |= AP_POLL_AFTER_TIMEOUT;
 +			break;
 +		case AP_RESPONSE_Q_NOT_AVAIL:
 +		case AP_RESPONSE_DECONFIGURED:
 +		case AP_RESPONSE_CHECKSTOPPED:
 +			return -ENODEV;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	if ((ap_dev->reset != AP_RESET_IN_PROGRESS) &&
 +		(ap_dev->interrupt == AP_INTR_IN_PROGRESS)) {
 +		status = ap_test_queue(ap_dev->qid, &depth, &type);
 +		if (ap_using_interrupts()) {
 +			if (status.int_enabled == 1)
 +				ap_dev->interrupt = AP_INTR_ENABLED;
 +			else
 +				*flags |= AP_POLL_AFTER_TIMEOUT;
 +		} else
 +			ap_dev->interrupt = AP_INTR_DISABLED;
 +	}
 +
 +	rc = ap_poll_read(ap_dev, flags);
 +	if (rc)
 +		return rc;
 +	return ap_poll_write(ap_dev, flags);
 +}
 +
 +/**
 + * __ap_queue_message(): Queue a message to a device.
 + * @ap_dev: pointer to the AP device
 + * @ap_msg: the message to be queued
 + *
 + * Queue a message to a device. Returns 0 if successful.
 + */
 +static int __ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_queue_status status;
 +
 +	if (list_empty(&ap_dev->requestq) &&
 +	    (ap_dev->queue_count < ap_dev->queue_depth) &&
 +	    (ap_dev->reset != AP_RESET_IN_PROGRESS)) {
 +		status = __ap_send(ap_dev->qid, ap_msg->psmid,
 +				   ap_msg->message, ap_msg->length,
 +				   ap_msg->special);
 +		switch (status.response_code) {
 +		case AP_RESPONSE_NORMAL:
 +			list_add_tail(&ap_msg->list, &ap_dev->pendingq);
 +			atomic_inc(&ap_poll_requests);
 +			ap_dev->pendingq_count++;
 +			ap_increase_queue_count(ap_dev);
 +			ap_dev->total_request_count++;
 +			break;
 +		case AP_RESPONSE_Q_FULL:
 +		case AP_RESPONSE_RESET_IN_PROGRESS:
 +			list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +			ap_dev->requestq_count++;
 +			ap_dev->total_request_count++;
 +			return -EBUSY;
 +		case AP_RESPONSE_REQ_FAC_NOT_INST:
 +		case AP_RESPONSE_MESSAGE_TOO_BIG:
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EINVAL));
 +			return -EINVAL;
 +		default:	/* Device is gone. */
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +			return -ENODEV;
 +		}
 +	} else {
 +		list_add_tail(&ap_msg->list, &ap_dev->requestq);
 +		ap_dev->requestq_count++;
 +		ap_dev->total_request_count++;
 +		return -EBUSY;
 +	}
 +	ap_schedule_poll_timer();
 +	return 0;
 +}
 +
 +void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	unsigned long flags;
 +	int rc;
 +
 +	/* For asynchronous message handling a valid receive-callback
 +	 * is required. */
 +	BUG_ON(!ap_msg->receive);
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!ap_dev->unregistered) {
 +		/* Make room on the queue by polling for finished requests. */
 +		rc = ap_poll_queue(ap_dev, &flags);
 +		if (!rc)
 +			rc = __ap_queue_message(ap_dev, ap_msg);
 +		if (!rc)
 +			wake_up(&ap_poll_wait);
 +		if (rc == -ENODEV) {
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +			ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		}
 +	} else if (ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 +		rc = -ENODEV;
 +	} else { /* device registration in progress */
 +		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EBUSY));
 +		rc = -EBUSY;
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +
 +	/* no device_unregister(), let ap_scan_bus() do the job */
 +}
 +EXPORT_SYMBOL(ap_queue_message);
 +
 +/**
 + * ap_cancel_message(): Cancel a crypto request.
 + * @ap_dev: The AP device that has the message queued
 + * @ap_msg: The message that is to be removed
 + *
 + * Cancel a crypto request. This is done by removing the request
 + * from the device pending or request queue. Note that the
 + * request stays on the AP queue. When it finishes the message
 + * reply will be discarded because the psmid can't be found.
 + */
 +void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)
 +{
 +	struct ap_message *tmp;
 +
 +	spin_lock_bh(&ap_dev->lock);
 +	if (!list_empty(&ap_msg->list)) {
 +		list_for_each_entry(tmp, &ap_dev->pendingq, list)
 +			if (tmp->psmid == ap_msg->psmid) {
 +				ap_dev->pendingq_count--;
 +				goto found;
 +			}
 +		ap_dev->requestq_count--;
 +	found:
 +		list_del_init(&ap_msg->list);
 +	}
 +	spin_unlock_bh(&ap_dev->lock);
 +}
 +EXPORT_SYMBOL(ap_cancel_message);
 +
 +/**
 + * ap_poll_timeout(): AP receive polling for finished AP requests.
 + * @unused: Unused pointer.
 + *
 + * Schedules the AP tasklet using a high resolution timer.
 + */
 +static enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)
 +{
 +	tasklet_schedule(&ap_tasklet);
 +	return HRTIMER_NORESTART;
 +}
 +
 +/**
 + * ap_reset(): Reset a not responding AP device.
 + * @ap_dev: Pointer to the AP device
 + *
 + * Reset a not responding AP device and move all requests from the
 + * pending queue to the request queue.
 + */
 +static void ap_reset(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	atomic_sub(ap_dev->queue_count, &ap_poll_requests);
 +	ap_dev->queue_count = 0;
 +	list_splice_init(&ap_dev->pendingq, &ap_dev->requestq);
 +	ap_dev->requestq_count += ap_dev->pendingq_count;
 +	ap_dev->pendingq_count = 0;
 +	rc = ap_init_queue(ap_dev);
 +	if (rc == -ENODEV)
 +		ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +	else
 +		*flags |= AP_POLL_AFTER_TIMEOUT;
 +}
 +
 +static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags)
 +{
 +	int rc;
 +
 +	if (!ap_dev->unregistered) {
 +		rc = ap_poll_queue(ap_dev, flags);
 +		if (rc == -ENODEV)
 +			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 +		if (ap_dev->reset == AP_RESET_DO)
 +			ap_reset(ap_dev, flags);
 +	}
 +	return 0;
 +}
 +
 +/**
 + * ap_poll_all(): Poll all AP devices.
 + * @dummy: Unused variable
 + *
 + * Poll all AP devices on the bus in a round robin fashion. Continue
 + * polling until bit 2^0 of the control flags is not set. If bit 2^1
 + * of the control flags has been set arm the poll timer.
 + */
 +static void ap_poll_all(unsigned long dummy)
 +{
 +	unsigned long flags;
 +	struct ap_device *ap_dev;
 +
 +	/* Reset the indicator if interrupts are used. Thus new interrupts can
 +	 * be received. Doing it in the beginning of the tasklet is therefor
 +	 * important that no requests on any AP get lost.
 +	 */
 +	if (ap_using_interrupts())
 +		xchg(ap_airq.lsi_ptr, 0);
 +	do {
 +		flags = 0;
 +		spin_lock(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock(&ap_device_list_lock);
 +	} while (flags & AP_POLL_IMMEDIATELY);
 +	if (flags & AP_POLL_AFTER_TIMEOUT)
 +		__ap_schedule_poll_timer();
 +}
 +
 +/**
 + * ap_poll_thread(): Thread that polls for finished requests.
 + * @data: Unused pointer
 + *
 + * AP bus poll thread. The purpose of this thread is to poll for
 + * finished requests in a loop if there is a "free" cpu - that is
 + * a cpu that doesn't have anything better to do. The polling stops
 + * as soon as there is another task or if all messages have been
 + * delivered.
 + */
 +static int ap_poll_thread(void *data)
 +{
 +	DECLARE_WAITQUEUE(wait, current);
 +	unsigned long flags;
 +	int requests;
 +	struct ap_device *ap_dev;
 +
 +	set_user_nice(current, 19);
 +	while (1) {
 +		if (ap_suspend_flag)
 +			return 0;
 +		if (need_resched()) {
 +			schedule();
 +			continue;
 +		}
 +		add_wait_queue(&ap_poll_wait, &wait);
 +		set_current_state(TASK_INTERRUPTIBLE);
 +		if (kthread_should_stop())
 +			break;
 +		requests = atomic_read(&ap_poll_requests);
 +		if (requests <= 0)
 +			schedule();
 +		set_current_state(TASK_RUNNING);
 +		remove_wait_queue(&ap_poll_wait, &wait);
 +
 +		flags = 0;
 +		spin_lock_bh(&ap_device_list_lock);
 +		list_for_each_entry(ap_dev, &ap_device_list, list) {
 +			spin_lock(&ap_dev->lock);
 +			__ap_poll_device(ap_dev, &flags);
 +			spin_unlock(&ap_dev->lock);
 +		}
 +		spin_unlock_bh(&ap_device_list_lock);
 +	}
 +	set_current_state(TASK_RUNNING);
 +	remove_wait_queue(&ap_poll_wait, &wait);
 +	return 0;
 +}
 +
 +static int ap_poll_thread_start(void)
 +{
 +	int rc;
 +
 +	if (ap_using_interrupts() || ap_suspend_flag)
 +		return 0;
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (!ap_poll_kthread) {
 +		ap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");
 +		rc = IS_ERR(ap_poll_kthread) ? PTR_ERR(ap_poll_kthread) : 0;
 +		if (rc)
 +			ap_poll_kthread = NULL;
 +	}
 +	else
 +		rc = 0;
 +	mutex_unlock(&ap_poll_thread_mutex);
 +	return rc;
 +}
 +
 +static void ap_poll_thread_stop(void)
 +{
 +	mutex_lock(&ap_poll_thread_mutex);
 +	if (ap_poll_kthread) {
 +		kthread_stop(ap_poll_kthread);
 +		ap_poll_kthread = NULL;
 +	}
 +	mutex_unlock(&ap_poll_thread_mutex);
 +}
 +
 +/**
 + * ap_request_timeout(): Handling of request timeouts
 + * @data: Holds the AP device.
 + *
 + * Handles request timeouts.
 + */
 +static void ap_request_timeout(unsigned long data)
 +{
 +	struct ap_device *ap_dev = (struct ap_device *) data;
 +
 +	if (ap_dev->reset == AP_RESET_ARMED) {
 +		ap_dev->reset = AP_RESET_DO;
 +
 +		if (ap_using_interrupts())
 +			tasklet_schedule(&ap_tasklet);
 +	}
 +}
 +
 +static void ap_reset_domain(void)
 +{
 +	int i;
 +
 +	if ((ap_domain_index != -1) && (ap_test_config_domain(ap_domain_index)))
 +		for (i = 0; i < AP_DEVICES; i++)
 +			ap_reset_queue(AP_MKQID(i, ap_domain_index));
  }
  
  static void ap_reset_all(void)
@@@ -2045,12 -1168,30 +2209,36 @@@ static struct reset_call ap_reset_call 
   */
  int __init ap_module_init(void)
  {
 -	int max_domain_id;
  	int rc, i;
  
++<<<<<<< HEAD
 +	if (ap_domain_index < -1 || ap_domain_index >= AP_DOMAINS) {
 +		pr_warning("%d is not a valid cryptographic domain\n",
 +			   ap_domain_index);
 +		return -EINVAL;
++=======
+ 	rc = ap_debug_init();
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (ap_instructions_available() != 0) {
+ 		pr_warn("The hardware system does not support AP instructions\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Get AP configuration data if available */
+ 	ap_init_configuration();
+ 
+ 	if (ap_configuration)
+ 		max_domain_id =
+ 			ap_max_domain_id ? ap_max_domain_id : AP_DOMAINS - 1;
+ 	else
+ 		max_domain_id = 15;
+ 	if (ap_domain_index < -1 || ap_domain_index > max_domain_id) {
+ 		pr_warn("%d is not a valid cryptographic domain\n",
+ 			ap_domain_index);
+ 		ap_domain_index = -1;
++>>>>>>> ac994e80f94f (s390/zcrypt: Rework ap init in case of out of range domain param.)
  	}
  	/* In resume callback we need to know if the user had set the domain.
  	 * If so, we can not just reset it.
@@@ -2135,44 -1264,7 +2323,48 @@@ out
  	unregister_reset_call(&ap_reset_call);
  	if (ap_using_interrupts())
  		unregister_adapter_interrupt(&ap_airq);
++<<<<<<< HEAD
++=======
+ 	kfree(ap_configuration);
++>>>>>>> ac994e80f94f (s390/zcrypt: Rework ap init in case of out of range domain param.)
  	return rc;
  }
 -device_initcall(ap_module_init);
 +
 +static int __ap_match_all(struct device *dev, void *data)
 +{
 +	return 1;
 +}
 +
 +/**
 + * ap_modules_exit(): The module termination code
 + *
 + * Terminates the module.
 + */
 +void ap_module_exit(void)
 +{
 +	int i;
 +	struct device *dev;
 +
 +	ap_reset_domain();
 +	ap_poll_thread_stop();
 +	del_timer_sync(&ap_config_timer);
 +	hrtimer_cancel(&ap_poll_timer);
 +	destroy_workqueue(ap_work_queue);
 +	tasklet_kill(&ap_tasklet);
 +	while ((dev = bus_find_device(&ap_bus_type, NULL, NULL,
 +		    __ap_match_all)))
 +	{
 +		device_unregister(dev);
 +		put_device(dev);
 +	}
 +	for (i = 0; ap_bus_attrs[i]; i++)
 +		bus_remove_file(&ap_bus_type, ap_bus_attrs[i]);
 +	root_device_unregister(ap_root_device);
 +	bus_unregister(&ap_bus_type);
 +	unregister_reset_call(&ap_reset_call);
 +	if (ap_using_interrupts())
 +		unregister_adapter_interrupt(&ap_airq);
 +}
 +
 +module_init(ap_module_init);
 +module_exit(ap_module_exit);
* Unmerged path drivers/s390/crypto/ap_bus.c
