mlxsw: spectrum: Forbid linking to devices that have uppers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 25cc72a33835ed8a6f53180a822cadab855852ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/25cc72a3.failed

The mlxsw driver relies on NETDEV_CHANGEUPPER events to configure the
device in case a port is enslaved to a master netdev such as bridge or
bond.

Since the driver ignores events unrelated to its ports and their
uppers, it's possible to engineer situations in which the device's data
path differs from the kernel's.

One example to such a situation is when a port is enslaved to a bond
that is already enslaved to a bridge. When the bond was enslaved the
driver ignored the event - as the bond wasn't one of its uppers - and
therefore a bridge port instance isn't created in the device.

Until such configurations are supported forbid them by checking that the
upper device doesn't have uppers of its own.

Fixes: 0d65fc13042f ("mlxsw: spectrum: Implement LAG port join/leave")
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reported-by: Nogah Frankel <nogahf@mellanox.com>
	Tested-by: Nogah Frankel <nogahf@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 25cc72a33835ed8a6f53180a822cadab855852ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 3aac4cc5ecc4,c6a3e61b53bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@@ -4470,9 -4139,7 +4470,13 @@@ static int mlxsw_sp_netdevice_port_uppe
  			return -EINVAL;
  		if (!info->linking)
  			break;
++<<<<<<< HEAD
 +		/* HW limitation forbids to put ports to multiple bridges. */
 +		if (netif_is_bridge_master(upper_dev) &&
 +		    !mlxsw_sp_master_bridge_check(mlxsw_sp, upper_dev))
++=======
+ 		if (netdev_has_any_upper_dev(upper_dev))
++>>>>>>> 25cc72a33835 (mlxsw: spectrum: Forbid linking to devices that have uppers)
  			return -EINVAL;
  		if (netif_is_lag_master(upper_dev) &&
  		    !mlxsw_sp_master_lag_check(mlxsw_sp, upper_dev,
@@@ -4586,294 -4245,10 +4590,298 @@@ static int mlxsw_sp_netdevice_lag_event
  	return 0;
  }
  
 -static int mlxsw_sp_netdevice_port_vlan_event(struct net_device *vlan_dev,
 -					      struct net_device *dev,
 -					      unsigned long event, void *ptr,
 -					      u16 vid)
 +static int mlxsw_sp_master_bridge_vlan_link(struct mlxsw_sp *mlxsw_sp,
 +					    struct net_device *vlan_dev)
 +{
 +	u16 fid = vlan_dev_vlan_id(vlan_dev);
 +	struct mlxsw_sp_fid *f;
 +
 +	f = mlxsw_sp_fid_find(mlxsw_sp, fid);
 +	if (!f) {
 +		f = mlxsw_sp_fid_create(mlxsw_sp, fid);
 +		if (IS_ERR(f))
 +			return PTR_ERR(f);
 +	}
 +
 +	f->ref_count++;
 +
 +	return 0;
 +}
 +
 +static void mlxsw_sp_master_bridge_vlan_unlink(struct mlxsw_sp *mlxsw_sp,
 +					       struct net_device *vlan_dev)
 +{
 +	u16 fid = vlan_dev_vlan_id(vlan_dev);
 +	struct mlxsw_sp_fid *f;
 +
 +	f = mlxsw_sp_fid_find(mlxsw_sp, fid);
 +	if (f && f->r)
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
 +	if (f && --f->ref_count == 0)
 +		mlxsw_sp_fid_destroy(mlxsw_sp, f);
 +}
 +
 +static int mlxsw_sp_netdevice_bridge_event(struct net_device *br_dev,
 +					   unsigned long event, void *ptr)
 +{
 +	struct netdev_notifier_changeupper_info *info;
 +	struct net_device *upper_dev;
 +	struct mlxsw_sp *mlxsw_sp;
 +	int err = 0;
 +
 +	mlxsw_sp = mlxsw_sp_lower_get(br_dev);
 +	if (!mlxsw_sp)
 +		return 0;
 +
 +	info = ptr;
 +
 +	switch (event) {
 +	case NETDEV_PRECHANGEUPPER:
 +		upper_dev = info->upper_dev;
 +		if (!is_vlan_dev(upper_dev) && !netif_is_l3_master(upper_dev))
 +			return -EINVAL;
 +		if (is_vlan_dev(upper_dev) &&
 +		    br_dev != mlxsw_sp->master_bridge.dev)
 +			return -EINVAL;
++		if (!info->linking)
++			break;
++		if (netdev_has_any_upper_dev(upper_dev))
++			return -EINVAL;
 +		break;
 +	case NETDEV_CHANGEUPPER:
 +		upper_dev = info->upper_dev;
 +		if (is_vlan_dev(upper_dev)) {
 +			if (info->linking)
 +				err = mlxsw_sp_master_bridge_vlan_link(mlxsw_sp,
 +								       upper_dev);
 +			else
 +				mlxsw_sp_master_bridge_vlan_unlink(mlxsw_sp,
 +								   upper_dev);
 +		} else if (netif_is_l3_master(upper_dev)) {
 +			if (info->linking)
 +				err = mlxsw_sp_bridge_vrf_join(mlxsw_sp,
 +							       br_dev);
 +			else
 +				mlxsw_sp_bridge_vrf_leave(mlxsw_sp, br_dev);
 +		} else {
 +			err = -EINVAL;
 +			WARN_ON(1);
 +		}
 +		break;
 +	}
 +
 +	return err;
 +}
 +
 +static u16 mlxsw_sp_avail_vfid_get(const struct mlxsw_sp *mlxsw_sp)
 +{
 +	return find_first_zero_bit(mlxsw_sp->vfids.mapped,
 +				   MLXSW_SP_VFID_MAX);
 +}
 +
 +static int mlxsw_sp_vfid_op(struct mlxsw_sp *mlxsw_sp, u16 fid, bool create)
 +{
 +	char sfmr_pl[MLXSW_REG_SFMR_LEN];
 +
 +	mlxsw_reg_sfmr_pack(sfmr_pl, !create, fid, 0);
 +	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfmr), sfmr_pl);
 +}
 +
 +static void mlxsw_sp_vport_vfid_leave(struct mlxsw_sp_port *mlxsw_sp_vport);
 +
 +static struct mlxsw_sp_fid *mlxsw_sp_vfid_create(struct mlxsw_sp *mlxsw_sp,
 +						 struct net_device *br_dev)
 +{
 +	struct device *dev = mlxsw_sp->bus_info->dev;
 +	struct mlxsw_sp_fid *f;
 +	u16 vfid, fid;
 +	int err;
 +
 +	vfid = mlxsw_sp_avail_vfid_get(mlxsw_sp);
 +	if (vfid == MLXSW_SP_VFID_MAX) {
 +		dev_err(dev, "No available vFIDs\n");
 +		return ERR_PTR(-ERANGE);
 +	}
 +
 +	fid = mlxsw_sp_vfid_to_fid(vfid);
 +	err = mlxsw_sp_vfid_op(mlxsw_sp, fid, true);
 +	if (err) {
 +		dev_err(dev, "Failed to create FID=%d\n", fid);
 +		return ERR_PTR(err);
 +	}
 +
 +	f = kzalloc(sizeof(*f), GFP_KERNEL);
 +	if (!f)
 +		goto err_allocate_vfid;
 +
 +	f->leave = mlxsw_sp_vport_vfid_leave;
 +	f->fid = fid;
 +	f->dev = br_dev;
 +
 +	list_add(&f->list, &mlxsw_sp->vfids.list);
 +	set_bit(vfid, mlxsw_sp->vfids.mapped);
 +
 +	return f;
 +
 +err_allocate_vfid:
 +	mlxsw_sp_vfid_op(mlxsw_sp, fid, false);
 +	return ERR_PTR(-ENOMEM);
 +}
 +
 +static void mlxsw_sp_vfid_destroy(struct mlxsw_sp *mlxsw_sp,
 +				  struct mlxsw_sp_fid *f)
 +{
 +	u16 vfid = mlxsw_sp_fid_to_vfid(f->fid);
 +	u16 fid = f->fid;
 +
 +	clear_bit(vfid, mlxsw_sp->vfids.mapped);
 +	list_del(&f->list);
 +
 +	if (f->r)
 +		mlxsw_sp_rif_bridge_destroy(mlxsw_sp, f->r);
 +
 +	kfree(f);
 +
 +	mlxsw_sp_vfid_op(mlxsw_sp, fid, false);
 +}
 +
 +static int mlxsw_sp_vport_fid_map(struct mlxsw_sp_port *mlxsw_sp_vport, u16 fid,
 +				  bool valid)
 +{
 +	enum mlxsw_reg_svfa_mt mt = MLXSW_REG_SVFA_MT_PORT_VID_TO_FID;
 +	u16 vid = mlxsw_sp_vport_vid_get(mlxsw_sp_vport);
 +
 +	return mlxsw_sp_port_vid_to_fid_set(mlxsw_sp_vport, mt, valid, fid,
 +					    vid);
 +}
 +
 +static int mlxsw_sp_vport_vfid_join(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				    struct net_device *br_dev)
 +{
 +	struct mlxsw_sp_fid *f;
 +	int err;
 +
 +	f = mlxsw_sp_vfid_find(mlxsw_sp_vport->mlxsw_sp, br_dev);
 +	if (!f) {
 +		f = mlxsw_sp_vfid_create(mlxsw_sp_vport->mlxsw_sp, br_dev);
 +		if (IS_ERR(f))
 +			return PTR_ERR(f);
 +	}
 +
 +	err = mlxsw_sp_vport_flood_set(mlxsw_sp_vport, f->fid, true);
 +	if (err)
 +		goto err_vport_flood_set;
 +
 +	err = mlxsw_sp_vport_fid_map(mlxsw_sp_vport, f->fid, true);
 +	if (err)
 +		goto err_vport_fid_map;
 +
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, f);
 +	f->ref_count++;
 +
 +	netdev_dbg(mlxsw_sp_vport->dev, "Joined FID=%d\n", f->fid);
 +
 +	return 0;
 +
 +err_vport_fid_map:
 +	mlxsw_sp_vport_flood_set(mlxsw_sp_vport, f->fid, false);
 +err_vport_flood_set:
 +	if (!f->ref_count)
 +		mlxsw_sp_vfid_destroy(mlxsw_sp_vport->mlxsw_sp, f);
 +	return err;
 +}
 +
 +static void mlxsw_sp_vport_vfid_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
 +{
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
 +
 +	netdev_dbg(mlxsw_sp_vport->dev, "Left FID=%d\n", f->fid);
 +
 +	mlxsw_sp_vport_fid_map(mlxsw_sp_vport, f->fid, false);
 +
 +	mlxsw_sp_vport_flood_set(mlxsw_sp_vport, f->fid, false);
 +
 +	mlxsw_sp_port_fdb_flush(mlxsw_sp_vport, f->fid);
 +
 +	mlxsw_sp_vport_fid_set(mlxsw_sp_vport, NULL);
 +	if (--f->ref_count == 0)
 +		mlxsw_sp_vfid_destroy(mlxsw_sp_vport->mlxsw_sp, f);
 +}
 +
 +static int mlxsw_sp_vport_bridge_join(struct mlxsw_sp_port *mlxsw_sp_vport,
 +				      struct net_device *br_dev)
 +{
 +	struct mlxsw_sp_fid *f = mlxsw_sp_vport_fid_get(mlxsw_sp_vport);
 +	u16 vid = mlxsw_sp_vport_vid_get(mlxsw_sp_vport);
 +	struct net_device *dev = mlxsw_sp_vport->dev;
 +	int err;
 +
 +	if (f && !WARN_ON(!f->leave))
 +		f->leave(mlxsw_sp_vport);
 +
 +	err = mlxsw_sp_vport_vfid_join(mlxsw_sp_vport, br_dev);
 +	if (err) {
 +		netdev_err(dev, "Failed to join vFID\n");
 +		return err;
 +	}
 +
 +	err = mlxsw_sp_port_vid_learning_set(mlxsw_sp_vport, vid, true);
 +	if (err) {
 +		netdev_err(dev, "Failed to enable learning\n");
 +		goto err_port_vid_learning_set;
 +	}
 +
 +	mlxsw_sp_vport->learning = 1;
 +	mlxsw_sp_vport->learning_sync = 1;
 +	mlxsw_sp_vport->uc_flood = 1;
 +	mlxsw_sp_vport->mc_flood = 1;
 +	mlxsw_sp_vport->mc_router = 0;
 +	mlxsw_sp_vport->mc_disabled = 1;
 +	mlxsw_sp_vport->bridged = 1;
 +
 +	return 0;
 +
 +err_port_vid_learning_set:
 +	mlxsw_sp_vport_vfid_leave(mlxsw_sp_vport);
 +	return err;
 +}
 +
 +static void mlxsw_sp_vport_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_vport)
 +{
 +	u16 vid = mlxsw_sp_vport_vid_get(mlxsw_sp_vport);
 +
 +	mlxsw_sp_port_vid_learning_set(mlxsw_sp_vport, vid, false);
 +
 +	mlxsw_sp_vport_vfid_leave(mlxsw_sp_vport);
 +
 +	mlxsw_sp_vport->learning = 0;
 +	mlxsw_sp_vport->learning_sync = 0;
 +	mlxsw_sp_vport->uc_flood = 0;
 +	mlxsw_sp_vport->mc_flood = 0;
 +	mlxsw_sp_vport->mc_router = 0;
 +	mlxsw_sp_vport->bridged = 0;
 +}
 +
 +static bool
 +mlxsw_sp_port_master_bridge_check(const struct mlxsw_sp_port *mlxsw_sp_port,
 +				  const struct net_device *br_dev)
 +{
 +	struct mlxsw_sp_port *mlxsw_sp_vport;
 +
 +	list_for_each_entry(mlxsw_sp_vport, &mlxsw_sp_port->vports_list,
 +			    vport.list) {
 +		struct net_device *dev = mlxsw_sp_vport_dev_get(mlxsw_sp_vport);
 +
 +		if (dev && dev == br_dev)
 +			return false;
 +	}
 +
 +	return true;
 +}
 +
 +static int mlxsw_sp_netdevice_vport_event(struct net_device *dev,
 +					  unsigned long event, void *ptr,
 +					  u16 vid)
  {
  	struct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);
  	struct netdev_notifier_changeupper_info *info = ptr;
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.c
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index ac042b4e583c..30be1bbe6b67 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -3822,6 +3822,8 @@ int netdev_walk_all_upper_dev_rcu(struct net_device *dev,
 bool netdev_has_upper_dev_all_rcu(struct net_device *dev,
 				  struct net_device *upper_dev);
 
+bool netdev_has_any_upper_dev(struct net_device *dev);
+
 void *netdev_lower_get_next_private(struct net_device *dev,
 				    struct list_head **iter);
 void *netdev_lower_get_next_private_rcu(struct net_device *dev,
