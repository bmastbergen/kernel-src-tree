target: refactor init/drop_nodeacl methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [target] refactor init/drop_nodeacl methods (Maurizio Lombardi) [1366062]
Rebuild_FUZZ: 89.47%
commit-author Christoph Hellwig <hch@lst.de>
commit c7d6a803926bae9bbf4510a18fc8dd8957cc0e01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/c7d6a803.failed

By always allocating and adding, respectively removing and freeing
the se_node_acl structure in core code we can remove tons of repeated
code in the init_nodeacl and drop_nodeacl routines.  Additionally
this now respects the get_default_queue_depth method in this code
path as well.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit c7d6a803926bae9bbf4510a18fc8dd8957cc0e01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/target/tcm_mod_builder.py
#	drivers/infiniband/ulp/srpt/ib_srpt.c
#	drivers/scsi/qla2xxx/tcm_qla2xxx.c
#	drivers/target/iscsi/iscsi_target_configfs.c
#	drivers/target/sbp/sbp_target.c
#	drivers/target/tcm_fc/tfc_conf.c
#	drivers/usb/gadget/tcm_usb_gadget.c
#	drivers/vhost/scsi.c
#	drivers/xen/xen-scsiback.c
#	include/target/target_core_fabric.h
diff --cc Documentation/target/tcm_mod_builder.py
index 3fe0d812dcec,3e54809b3aa1..000000000000
--- a/Documentation/target/tcm_mod_builder.py
+++ b/Documentation/target/tcm_mod_builder.py
@@@ -237,57 -214,8 +214,9 @@@ def tcm_mod_build_configfs(proto_ident
  	buf += "#include \"" + fabric_mod_name + "_base.h\"\n"
  	buf += "#include \"" + fabric_mod_name + "_fabric.h\"\n\n"
  
 -	buf += "static const struct target_core_fabric_ops " + fabric_mod_name + "_ops;\n\n"
 +	buf += "/* Local pointer to allocated TCM configfs fabric module */\n"
 +	buf += "struct target_fabric_configfs *" + fabric_mod_name + "_fabric_configfs;\n\n"
  
- 	buf += "static struct se_node_acl *" + fabric_mod_name + "_make_nodeacl(\n"
- 	buf += "	struct se_portal_group *se_tpg,\n"
- 	buf += "	struct config_group *group,\n"
- 	buf += "	const char *name)\n"
- 	buf += "{\n"
- 	buf += "	struct se_node_acl *se_nacl, *se_nacl_new;\n"
- 	buf += "	struct " + fabric_mod_name + "_nacl *nacl;\n"
- 
- 	if proto_ident == "FC" or proto_ident == "SAS":
- 		buf += "	u64 wwpn = 0;\n"
- 
- 	buf += "	u32 nexus_depth;\n\n"
- 	buf += "	/* " + fabric_mod_name + "_parse_wwn(name, &wwpn, 1) < 0)\n"
- 	buf += "		return ERR_PTR(-EINVAL); */\n"
- 	buf += "	se_nacl_new = " + fabric_mod_name + "_alloc_fabric_acl(se_tpg);\n"
- 	buf += "	if (!se_nacl_new)\n"
- 	buf += "		return ERR_PTR(-ENOMEM);\n"
- 	buf += "//#warning FIXME: Hardcoded nexus depth in " + fabric_mod_name + "_make_nodeacl()\n"
- 	buf += "	nexus_depth = 1;\n"
- 	buf += "	/*\n"
- 	buf += "	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()\n"
- 	buf += "	 * when converting a NodeACL from demo mode -> explict\n"
- 	buf += "	 */\n"
- 	buf += "	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,\n"
- 	buf += "				name, nexus_depth);\n"
- 	buf += "	if (IS_ERR(se_nacl)) {\n"
- 	buf += "		" + fabric_mod_name + "_release_fabric_acl(se_tpg, se_nacl_new);\n"
- 	buf += "		return se_nacl;\n"
- 	buf += "	}\n"
- 	buf += "	/*\n"
- 	buf += "	 * Locate our struct " + fabric_mod_name + "_nacl and set the FC Nport WWPN\n"
- 	buf += "	 */\n"
- 	buf += "	nacl = container_of(se_nacl, struct " + fabric_mod_name + "_nacl, se_node_acl);\n"
- 
- 	if proto_ident == "FC" or proto_ident == "SAS":
- 		buf += "	nacl->" + fabric_mod_init_port + "_wwpn = wwpn;\n"
- 
- 	buf += "	/* " + fabric_mod_name + "_format_wwn(&nacl->" + fabric_mod_init_port + "_name[0], " + fabric_mod_name.upper() + "_NAMELEN, wwpn); */\n\n"
- 	buf += "	return se_nacl;\n"
- 	buf += "}\n\n"
- 	buf += "static void " + fabric_mod_name + "_drop_nodeacl(struct se_node_acl *se_acl)\n"
- 	buf += "{\n"
- 	buf += "	struct " + fabric_mod_name + "_nacl *nacl = container_of(se_acl,\n"
- 	buf += "				struct " + fabric_mod_name + "_nacl, se_node_acl);\n"
- 	buf += "	core_tpg_del_initiator_node_acl(se_acl->se_tpg, se_acl, 1);\n"
- 	buf += "	kfree(nacl);\n"
- 	buf += "}\n\n"
- 
  	buf += "static struct se_portal_group *" + fabric_mod_name + "_make_tpg(\n"
  	buf += "	struct se_wwn *wwn,\n"
  	buf += "	struct config_group *group,\n"
@@@ -410,68 -337,8 +339,73 @@@
  	buf += "	.fabric_drop_wwn		= " + fabric_mod_name + "_drop_" + fabric_mod_port + ",\n"
  	buf += "	.fabric_make_tpg		= " + fabric_mod_name + "_make_tpg,\n"
  	buf += "	.fabric_drop_tpg		= " + fabric_mod_name + "_drop_tpg,\n"
++<<<<<<< HEAD
 +	buf += "	.fabric_post_link		= NULL,\n"
 +	buf += "	.fabric_pre_unlink		= NULL,\n"
 +	buf += "	.fabric_make_np			= NULL,\n"
 +	buf += "	.fabric_drop_np			= NULL,\n"
 +	buf += "	.fabric_make_nodeacl		= " + fabric_mod_name + "_make_nodeacl,\n"
 +	buf += "	.fabric_drop_nodeacl		= " + fabric_mod_name + "_drop_nodeacl,\n"
 +	buf += "};\n\n"
 +
 +	buf += "static int " + fabric_mod_name + "_register_configfs(void)\n"
 +	buf += "{\n"
 +	buf += "	struct target_fabric_configfs *fabric;\n"
 +	buf += "	int ret;\n\n"
 +	buf += "	printk(KERN_INFO \"" + fabric_mod_name.upper() + " fabric module %s on %s/%s\"\n"
 +	buf += "		\" on \"UTS_RELEASE\"\\n\"," + fabric_mod_name.upper() + "_VERSION, utsname()->sysname,\n"
 +	buf += "		utsname()->machine);\n"
 +	buf += "	/*\n"
 +	buf += "	 * Register the top level struct config_item_type with TCM core\n"
 +	buf += "	 */\n"
 +	buf += "	fabric = target_fabric_configfs_init(THIS_MODULE, \"" + fabric_mod_name[4:] + "\");\n"
 +	buf += "	if (IS_ERR(fabric)) {\n"
 +	buf += "		printk(KERN_ERR \"target_fabric_configfs_init() failed\\n\");\n"
 +	buf += "		return PTR_ERR(fabric);\n"
 +	buf += "	}\n"
 +	buf += "	/*\n"
 +	buf += "	 * Setup fabric->tf_ops from our local " + fabric_mod_name + "_ops\n"
 +	buf += "	 */\n"
 +	buf += "	fabric->tf_ops = " + fabric_mod_name + "_ops;\n"
 +	buf += "	/*\n"
 +	buf += "	 * Setup default attribute lists for various fabric->tf_cit_tmpl\n"
 +	buf += "	 */\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = " + fabric_mod_name + "_wwn_attrs;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;\n"
 +	buf += "	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;\n"
 +	buf += "	/*\n"
 +	buf += "	 * Register the fabric for use within TCM\n"
 +	buf += "	 */\n"
 +	buf += "	ret = target_fabric_configfs_register(fabric);\n"
 +	buf += "	if (ret < 0) {\n"
 +	buf += "		printk(KERN_ERR \"target_fabric_configfs_register() failed\"\n"
 +	buf += "				\" for " + fabric_mod_name.upper() + "\\n\");\n"
 +	buf += "		return ret;\n"
 +	buf += "	}\n"
 +	buf += "	/*\n"
 +	buf += "	 * Setup our local pointer to *fabric\n"
 +	buf += "	 */\n"
 +	buf += "	" + fabric_mod_name + "_fabric_configfs = fabric;\n"
 +	buf += "	printk(KERN_INFO \"" +  fabric_mod_name.upper() + "[0] - Set fabric -> " + fabric_mod_name + "_fabric_configfs\\n\");\n"
 +	buf += "	return 0;\n"
 +	buf += "};\n\n"
 +	buf += "static void __exit " + fabric_mod_name + "_deregister_configfs(void)\n"
 +	buf += "{\n"
 +	buf += "	if (!" + fabric_mod_name + "_fabric_configfs)\n"
 +	buf += "		return;\n\n"
 +	buf += "	target_fabric_configfs_deregister(" + fabric_mod_name + "_fabric_configfs);\n"
 +	buf += "	" + fabric_mod_name + "_fabric_configfs = NULL;\n"
 +	buf += "	printk(KERN_INFO \"" +  fabric_mod_name.upper() + "[0] - Cleared " + fabric_mod_name + "_fabric_configfs\\n\");\n"
++=======
+ 	buf += "\n"
+ 	buf += "	.tfc_wwn_attrs			= " + fabric_mod_name + "_wwn_attrs;\n"
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  	buf += "};\n\n"
  
  	buf += "static int __init " + fabric_mod_name + "_init(void)\n"
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 72146d165e84,c1f3aa52f42b..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -3258,12 -3920,12 +3230,21 @@@ static struct target_core_fabric_ops sr
  	.fabric_drop_wwn		= srpt_drop_tport,
  	.fabric_make_tpg		= srpt_make_tpg,
  	.fabric_drop_tpg		= srpt_drop_tpg,
++<<<<<<< HEAD
 +	.fabric_post_link		= NULL,
 +	.fabric_pre_unlink		= NULL,
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= srpt_make_nodeacl,
 +	.fabric_drop_nodeacl		= srpt_drop_nodeacl,
++=======
+ 	.fabric_init_nodeacl		= srpt_init_nodeacl,
+ 	.fabric_cleanup_nodeacl		= srpt_cleanup_nodeacl,
+ 
+ 	.tfc_wwn_attrs			= srpt_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= srpt_tpg_attrs,
+ 	.tfc_tpg_attrib_attrs		= srpt_tpg_attrib_attrs,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  };
  
  /**
diff --cc drivers/scsi/qla2xxx/tcm_qla2xxx.c
index 14250fcfe054,a7ab689f5524..000000000000
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@@ -808,42 -843,20 +808,19 @@@ static void tcm_qla2xxx_put_sess(struc
  
  static void tcm_qla2xxx_shutdown_sess(struct qla_tgt_sess *sess)
  {
 -	assert_spin_locked(&sess->vha->hw->hardware_lock);
 -	target_sess_cmd_list_set_waiting(sess->se_sess);
 +	tcm_qla2xxx_shutdown_session(sess->se_sess);
  }
  
- static struct se_node_acl *tcm_qla2xxx_make_nodeacl(
- 	struct se_portal_group *se_tpg,
- 	struct config_group *group,
- 	const char *name)
+ static int tcm_qla2xxx_init_nodeacl(struct se_node_acl *se_nacl,
+ 		const char *name)
  {
- 	struct se_node_acl *se_nacl, *se_nacl_new;
- 	struct tcm_qla2xxx_nacl *nacl;
+ 	struct tcm_qla2xxx_nacl *nacl =
+ 		container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);
  	u64 wwnn;
- 	u32 qla2xxx_nexus_depth;
  
  	if (tcm_qla2xxx_parse_wwn(name, &wwnn, 1) < 0)
- 		return ERR_PTR(-EINVAL);
- 
- 	se_nacl_new = tcm_qla2xxx_alloc_fabric_acl(se_tpg);
- 	if (!se_nacl_new)
- 		return ERR_PTR(-ENOMEM);
- /* #warning FIXME: Hardcoded qla2xxx_nexus depth in tcm_qla2xxx_make_nodeacl */
- 	qla2xxx_nexus_depth = 1;
+ 		return -EINVAL;
  
- 	/*
- 	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
- 	 * when converting a NodeACL from demo mode -> explict
- 	 */
- 	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,
- 				name, qla2xxx_nexus_depth);
- 	if (IS_ERR(se_nacl)) {
- 		tcm_qla2xxx_release_fabric_acl(se_tpg, se_nacl_new);
- 		return se_nacl;
- 	}
- 	/*
- 	 * Locate our struct tcm_qla2xxx_nacl and set the FC Nport WWPN
- 	 */
- 	nacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);
  	nacl->nport_wwnn = wwnn;
  	tcm_qla2xxx_format_wwn(&nacl->nport_name[0], TCM_QLA2XXX_NAMELEN, wwnn);
  
@@@ -1774,15 -1991,16 +1741,23 @@@ static struct target_core_fabric_ops tc
  	.fabric_drop_wwn		= tcm_qla2xxx_drop_lport,
  	.fabric_make_tpg		= tcm_qla2xxx_make_tpg,
  	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
++<<<<<<< HEAD
 +	.fabric_post_link		= NULL,
 +	.fabric_pre_unlink		= NULL,
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= tcm_qla2xxx_make_nodeacl,
 +	.fabric_drop_nodeacl		= tcm_qla2xxx_drop_nodeacl,
++=======
+ 	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,
+ 
+ 	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= tcm_qla2xxx_tpg_attrs,
+ 	.tfc_tpg_attrib_attrs		= tcm_qla2xxx_tpg_attrib_attrs,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  };
  
 -static const struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
 -	.module				= THIS_MODULE,
 -	.name				= "qla2xxx_npiv",
 +static struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
  	.get_fabric_name		= tcm_qla2xxx_npiv_get_fabric_name,
  	.get_fabric_proto_ident		= tcm_qla2xxx_get_fabric_proto_ident,
  	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
@@@ -1821,12 -2041,10 +1796,19 @@@
  	.fabric_drop_wwn		= tcm_qla2xxx_npiv_drop_lport,
  	.fabric_make_tpg		= tcm_qla2xxx_npiv_make_tpg,
  	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
++<<<<<<< HEAD
 +	.fabric_post_link		= NULL,
 +	.fabric_pre_unlink		= NULL,
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= tcm_qla2xxx_make_nodeacl,
 +	.fabric_drop_nodeacl		= tcm_qla2xxx_drop_nodeacl,
++=======
+ 	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,
+ 
+ 	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= tcm_qla2xxx_npiv_tpg_attrs,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  };
  
  static int tcm_qla2xxx_register_configfs(void)
diff --cc drivers/target/iscsi/iscsi_target_configfs.c
index e02616d0c024,7d9ff8cbbb5d..000000000000
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@@ -2051,115 -1949,60 +2022,162 @@@ static void lio_release_cmd(struct se_c
  	iscsit_release_cmd(cmd);
  }
  
++<<<<<<< HEAD
 +/* End functions for target_core_fabric_ops */
++=======
+ const struct target_core_fabric_ops iscsi_ops = {
+ 	.module				= THIS_MODULE,
+ 	.name				= "iscsi",
+ 	.get_fabric_name		= iscsi_get_fabric_name,
+ 	.get_fabric_proto_ident		= iscsi_get_fabric_proto_ident,
+ 	.tpg_get_wwn			= lio_tpg_get_endpoint_wwn,
+ 	.tpg_get_tag			= lio_tpg_get_tag,
+ 	.tpg_get_default_depth		= lio_tpg_get_default_depth,
+ 	.tpg_get_pr_transport_id	= iscsi_get_pr_transport_id,
+ 	.tpg_get_pr_transport_id_len	= iscsi_get_pr_transport_id_len,
+ 	.tpg_parse_pr_out_transport_id	= iscsi_parse_pr_out_transport_id,
+ 	.tpg_check_demo_mode		= lio_tpg_check_demo_mode,
+ 	.tpg_check_demo_mode_cache	= lio_tpg_check_demo_mode_cache,
+ 	.tpg_check_demo_mode_write_protect =
+ 			lio_tpg_check_demo_mode_write_protect,
+ 	.tpg_check_prod_mode_write_protect =
+ 			lio_tpg_check_prod_mode_write_protect,
+ 	.tpg_check_prot_fabric_only	= &lio_tpg_check_prot_fabric_only,
+ 	.tpg_alloc_fabric_acl		= lio_tpg_alloc_fabric_acl,
+ 	.tpg_release_fabric_acl		= lio_tpg_release_fabric_acl,
+ 	.tpg_get_inst_index		= lio_tpg_get_inst_index,
+ 	.check_stop_free		= lio_check_stop_free,
+ 	.release_cmd			= lio_release_cmd,
+ 	.shutdown_session		= lio_tpg_shutdown_session,
+ 	.close_session			= lio_tpg_close_session,
+ 	.sess_get_index			= lio_sess_get_index,
+ 	.sess_get_initiator_sid		= lio_sess_get_initiator_sid,
+ 	.write_pending			= lio_write_pending,
+ 	.write_pending_status		= lio_write_pending_status,
+ 	.set_default_node_attributes	= lio_set_default_node_attributes,
+ 	.get_task_tag			= iscsi_get_task_tag,
+ 	.get_cmd_state			= iscsi_get_cmd_state,
+ 	.queue_data_in			= lio_queue_data_in,
+ 	.queue_status			= lio_queue_status,
+ 	.queue_tm_rsp			= lio_queue_tm_rsp,
+ 	.aborted_task			= lio_aborted_task,
+ 	.fabric_make_wwn		= lio_target_call_coreaddtiqn,
+ 	.fabric_drop_wwn		= lio_target_call_coredeltiqn,
+ 	.fabric_make_tpg		= lio_target_tiqn_addtpg,
+ 	.fabric_drop_tpg		= lio_target_tiqn_deltpg,
+ 	.fabric_make_np			= lio_target_call_addnptotpg,
+ 	.fabric_drop_np			= lio_target_call_delnpfromtpg,
+ 	.fabric_init_nodeacl		= lio_target_init_nodeacl,
+ 	.fabric_cleanup_nodeacl		= lio_target_cleanup_nodeacl,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  
 -	.tfc_discovery_attrs		= lio_target_discovery_auth_attrs,
 -	.tfc_wwn_attrs			= lio_target_wwn_attrs,
 -	.tfc_tpg_base_attrs		= lio_target_tpg_attrs,
 -	.tfc_tpg_attrib_attrs		= lio_target_tpg_attrib_attrs,
 -	.tfc_tpg_auth_attrs		= lio_target_tpg_auth_attrs,
 -	.tfc_tpg_param_attrs		= lio_target_tpg_param_attrs,
 -	.tfc_tpg_np_base_attrs		= lio_target_portal_attrs,
 -	.tfc_tpg_nacl_base_attrs	= lio_target_initiator_attrs,
 -	.tfc_tpg_nacl_attrib_attrs	= lio_target_nacl_attrib_attrs,
 -	.tfc_tpg_nacl_auth_attrs	= lio_target_nacl_auth_attrs,
 -	.tfc_tpg_nacl_param_attrs	= lio_target_nacl_param_attrs,
 -};
 +int iscsi_target_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	lio_target_fabric_configfs = NULL;
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "iscsi");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() for"
 +				" LIO-Target failed!\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup the fabric API of function pointers used by target_core_mod..
 +	 */
 +	fabric->tf_ops.get_fabric_name = &iscsi_get_fabric_name;
 +	fabric->tf_ops.get_fabric_proto_ident = &iscsi_get_fabric_proto_ident;
 +	fabric->tf_ops.tpg_get_wwn = &lio_tpg_get_endpoint_wwn;
 +	fabric->tf_ops.tpg_get_tag = &lio_tpg_get_tag;
 +	fabric->tf_ops.tpg_get_default_depth = &lio_tpg_get_default_depth;
 +	fabric->tf_ops.tpg_get_pr_transport_id = &iscsi_get_pr_transport_id;
 +	fabric->tf_ops.tpg_get_pr_transport_id_len =
 +				&iscsi_get_pr_transport_id_len;
 +	fabric->tf_ops.tpg_parse_pr_out_transport_id =
 +				&iscsi_parse_pr_out_transport_id;
 +	fabric->tf_ops.tpg_check_demo_mode = &lio_tpg_check_demo_mode;
 +	fabric->tf_ops.tpg_check_demo_mode_cache =
 +				&lio_tpg_check_demo_mode_cache;
 +	fabric->tf_ops.tpg_check_demo_mode_write_protect =
 +				&lio_tpg_check_demo_mode_write_protect;
 +	fabric->tf_ops.tpg_check_prod_mode_write_protect =
 +				&lio_tpg_check_prod_mode_write_protect;
 +	fabric->tf_ops.tpg_alloc_fabric_acl = &lio_tpg_alloc_fabric_acl;
 +	fabric->tf_ops.tpg_release_fabric_acl = &lio_tpg_release_fabric_acl;
 +	fabric->tf_ops.tpg_get_inst_index = &lio_tpg_get_inst_index;
 +	fabric->tf_ops.check_stop_free = &lio_check_stop_free,
 +	fabric->tf_ops.release_cmd = &lio_release_cmd;
 +	fabric->tf_ops.shutdown_session = &lio_tpg_shutdown_session;
 +	fabric->tf_ops.close_session = &lio_tpg_close_session;
 +	fabric->tf_ops.sess_get_index = &lio_sess_get_index;
 +	fabric->tf_ops.sess_get_initiator_sid = &lio_sess_get_initiator_sid;
 +	fabric->tf_ops.write_pending = &lio_write_pending;
 +	fabric->tf_ops.write_pending_status = &lio_write_pending_status;
 +	fabric->tf_ops.set_default_node_attributes =
 +				&lio_set_default_node_attributes;
 +	fabric->tf_ops.get_task_tag = &iscsi_get_task_tag;
 +	fabric->tf_ops.get_cmd_state = &iscsi_get_cmd_state;
 +	fabric->tf_ops.queue_data_in = &lio_queue_data_in;
 +	fabric->tf_ops.queue_status = &lio_queue_status;
 +	fabric->tf_ops.queue_tm_rsp = &lio_queue_tm_rsp;
 +	fabric->tf_ops.aborted_task = &lio_aborted_task;
 +	/*
 +	 * Setup function pointers for generic logic in target_core_fabric_configfs.c
 +	 */
 +	fabric->tf_ops.fabric_make_wwn = &lio_target_call_coreaddtiqn;
 +	fabric->tf_ops.fabric_drop_wwn = &lio_target_call_coredeltiqn;
 +	fabric->tf_ops.fabric_make_tpg = &lio_target_tiqn_addtpg;
 +	fabric->tf_ops.fabric_drop_tpg = &lio_target_tiqn_deltpg;
 +	fabric->tf_ops.fabric_post_link	= NULL;
 +	fabric->tf_ops.fabric_pre_unlink = NULL;
 +	fabric->tf_ops.fabric_make_np = &lio_target_call_addnptotpg;
 +	fabric->tf_ops.fabric_drop_np = &lio_target_call_delnpfromtpg;
 +	fabric->tf_ops.fabric_make_nodeacl = &lio_target_make_nodeacl;
 +	fabric->tf_ops.fabric_drop_nodeacl = &lio_target_drop_nodeacl;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 * sturct config_item_type's
 +	 */
 +	fabric->tf_cit_tmpl.tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_auth_cit.ct_attrs = lio_target_tpg_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
 +
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() for"
 +				" LIO-Target failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return ret;
 +	}
 +
 +	lio_target_fabric_configfs = fabric;
 +	pr_debug("LIO_TARGET[0] - Set fabric ->"
 +			" lio_target_fabric_configfs\n");
 +	return 0;
 +}
 +
 +
 +void iscsi_target_deregister_configfs(void)
 +{
 +	if (!lio_target_fabric_configfs)
 +		return;
 +	/*
 +	 * Shutdown discovery sessions and disable discovery TPG
 +	 */
 +	if (iscsit_global->discovery_tpg)
 +		iscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);
 +
 +	target_fabric_configfs_deregister(lio_target_fabric_configfs);
 +	lio_target_fabric_configfs = NULL;
 +	pr_debug("LIO_TARGET[0] - Cleared"
 +				" lio_target_fabric_configfs\n");
 +}
diff --cc drivers/target/sbp/sbp_target.c
index b33c121ab56c,3a47fe46fbca..000000000000
--- a/drivers/target/sbp/sbp_target.c
+++ b/drivers/target/sbp/sbp_target.c
@@@ -2524,54 -2491,11 +2497,58 @@@ static struct target_core_fabric_ops sb
  	.fabric_pre_unlink		= sbp_pre_unlink_lun,
  	.fabric_make_np			= NULL,
  	.fabric_drop_np			= NULL,
++<<<<<<< HEAD
 +	.fabric_make_nodeacl		= sbp_make_nodeacl,
 +	.fabric_drop_nodeacl		= sbp_drop_nodeacl,
 +};
++=======
+ 	.fabric_init_nodeacl		= sbp_init_nodeacl,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
 +
 +static int sbp_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "sbp");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() failed\n");
 +		return PTR_ERR(fabric);
 +	}
 +
 +	fabric->tf_ops = sbp_ops;
 +
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = sbp_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = sbp_tpg_base_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = sbp_tpg_attrib_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 +
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() failed for SBP\n");
 +		return ret;
 +	}
  
 -	.tfc_wwn_attrs			= sbp_wwn_attrs,
 -	.tfc_tpg_base_attrs		= sbp_tpg_base_attrs,
 -	.tfc_tpg_attrib_attrs		= sbp_tpg_attrib_attrs,
 +	sbp_fabric_configfs = fabric;
 +
 +	return 0;
 +};
 +
 +static void sbp_deregister_configfs(void)
 +{
 +	if (!sbp_fabric_configfs)
 +		return;
 +
 +	target_fabric_configfs_deregister(sbp_fabric_configfs);
 +	sbp_fabric_configfs = NULL;
  };
  
  static int __init sbp_init(void)
diff --cc drivers/target/tcm_fc/tfc_conf.c
index efdcb9663a1a,e179fdf76ddb..000000000000
--- a/drivers/target/tcm_fc/tfc_conf.c
+++ b/drivers/target/tcm_fc/tfc_conf.c
@@@ -546,69 -511,12 +515,76 @@@ static struct target_core_fabric_ops ft
  	.fabric_drop_wwn =		&ft_del_wwn,
  	.fabric_make_tpg =		&ft_add_tpg,
  	.fabric_drop_tpg =		&ft_del_tpg,
++<<<<<<< HEAD
 +	.fabric_post_link =		NULL,
 +	.fabric_pre_unlink =		NULL,
 +	.fabric_make_np =		NULL,
 +	.fabric_drop_np =		NULL,
 +	.fabric_make_nodeacl =		&ft_add_acl,
 +	.fabric_drop_nodeacl =		&ft_del_acl,
++=======
+ 	.fabric_init_nodeacl =		&ft_init_nodeacl,
+ 
+ 	.tfc_wwn_attrs			= ft_wwn_attrs,
+ 	.tfc_tpg_nacl_base_attrs	= ft_nacl_base_attrs,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  };
  
 +static int ft_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	/*
 +	 * Register the top level struct config_item_type with TCM core
 +	 */
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "fc");
 +	if (IS_ERR(fabric)) {
 +		pr_err("%s: target_fabric_configfs_init() failed!\n",
 +		       __func__);
 +		return PTR_ERR(fabric);
 +	}
 +	fabric->tf_ops = ft_fabric_ops;
 +
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = ft_wwn_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs =
 +						    ft_nacl_base_attrs;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
 +	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 +	/*
 +	 * register the fabric for use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_debug("target_fabric_configfs_register() for"
 +			    " FC Target failed!\n");
 +		target_fabric_configfs_free(fabric);
 +		return -1;
 +	}
 +
 +	/*
 +	 * Setup our local pointer to *fabric.
 +	 */
 +	ft_configfs = fabric;
 +	return 0;
 +}
 +
 +static void ft_deregister_configfs(void)
 +{
 +	if (!ft_configfs)
 +		return;
 +	target_fabric_configfs_deregister(ft_configfs);
 +	ft_configfs = NULL;
 +}
 +
  static struct notifier_block ft_notifier = {
  	.notifier_call = ft_lport_notify
  };
diff --cc drivers/usb/gadget/tcm_usb_gadget.c
index 7cacd6ae818e,fccb0ccb355a..000000000000
--- a/drivers/usb/gadget/tcm_usb_gadget.c
+++ b/drivers/usb/gadget/tcm_usb_gadget.c
@@@ -1487,50 -1476,11 +1487,53 @@@ static const char *usbg_check_wwn(cons
  	return n;
  }
  
- static struct se_node_acl *usbg_make_nodeacl(
- 	struct se_portal_group *se_tpg,
- 	struct config_group *group,
- 	const char *name)
+ static int usbg_init_nodeacl(struct se_node_acl *se_nacl, const char *name)
  {
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +	struct se_node_acl *se_nacl, *se_nacl_new;
 +	struct usbg_nacl *nacl;
 +	u64 wwpn = 0;
 +	u32 nexus_depth;
 +	const char *wnn_name;
 +
 +	wnn_name = usbg_check_wwn(name);
 +	if (!wnn_name)
 +		return ERR_PTR(-EINVAL);
 +	se_nacl_new = usbg_alloc_fabric_acl(se_tpg);
 +	if (!(se_nacl_new))
 +		return ERR_PTR(-ENOMEM);
 +
 +	nexus_depth = 1;
 +	/*
 +	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
 +	 * when converting a NodeACL from demo mode -> explict
 +	 */
 +	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,
 +				name, nexus_depth);
 +	if (IS_ERR(se_nacl)) {
 +		usbg_release_fabric_acl(se_tpg, se_nacl_new);
 +		return se_nacl;
 +	}
 +	/*
 +	 * Locate our struct usbg_nacl and set the FC Nport WWPN
 +	 */
 +	nacl = container_of(se_nacl, struct usbg_nacl, se_node_acl);
 +	nacl->iport_wwpn = wwpn;
 +	snprintf(nacl->iport_name, sizeof(nacl->iport_name), "%s", name);
 +	return se_nacl;
 +}
 +
 +static void usbg_drop_nodeacl(struct se_node_acl *se_acl)
 +{
 +	struct usbg_nacl *nacl = container_of(se_acl,
 +				struct usbg_nacl, se_node_acl);
 +	core_tpg_del_initiator_node_acl(se_acl->se_tpg, se_acl, 1);
 +	kfree(nacl);
++=======
+ 	if (!usbg_check_wwn(name))
+ 		return -EINVAL;
+ 	return 0;
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  }
  
  struct usbg_tpg *the_only_tpg_I_currently_have;
@@@ -1906,50 -1850,10 +1909,54 @@@ static struct target_core_fabric_ops us
  	.fabric_drop_tpg		= usbg_drop_tpg,
  	.fabric_post_link		= usbg_port_link,
  	.fabric_pre_unlink		= usbg_port_unlink,
++<<<<<<< HEAD:drivers/usb/gadget/tcm_usb_gadget.c
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= usbg_make_nodeacl,
 +	.fabric_drop_nodeacl		= usbg_drop_nodeacl,
 +};
++=======
+ 	.fabric_init_nodeacl		= usbg_init_nodeacl,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods):drivers/usb/gadget/legacy/tcm_usb_gadget.c
  
 -	.tfc_wwn_attrs			= usbg_wwn_attrs,
 -	.tfc_tpg_base_attrs		= usbg_base_attrs,
 +static int usbg_register_configfs(void)
 +{
 +	struct target_fabric_configfs *fabric;
 +	int ret;
 +
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "usb_gadget");
 +	if (IS_ERR(fabric)) {
 +		printk(KERN_ERR "target_fabric_configfs_init() failed\n");
 +		return PTR_ERR(fabric);
 +	}
 +
 +	fabric->tf_ops = usbg_ops;
 +	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = usbg_wwn_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = usbg_base_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		printk(KERN_ERR "target_fabric_configfs_register() failed"
 +				" for usb-gadget\n");
 +		return ret;
 +	}
 +	usbg_fabric_configfs = fabric;
 +	return 0;
 +};
 +
 +static void usbg_deregister_configfs(void)
 +{
 +	if (!(usbg_fabric_configfs))
 +		return;
 +
 +	target_fabric_configfs_deregister(usbg_fabric_configfs);
 +	usbg_fabric_configfs = NULL;
  };
  
  /* Start gadget.c code */
diff --cc drivers/vhost/scsi.c
index 65142d377371,8faa7f4abf23..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -1572,85 -1781,101 +1572,147 @@@ static int tcm_vhost_port_link(struct s
  	return 0;
  }
  
 -static void vhost_scsi_port_unlink(struct se_portal_group *se_tpg,
 -				  struct se_lun *lun)
 +static void tcm_vhost_port_unlink(struct se_portal_group *se_tpg,
 +	struct se_lun *lun)
  {
 -	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
 -				struct vhost_scsi_tpg, se_tpg);
 +	struct tcm_vhost_tpg *tv_tpg = container_of(se_tpg,
 +				struct tcm_vhost_tpg, se_tpg);
  
 -	mutex_lock(&vhost_scsi_mutex);
 +	mutex_lock(&tcm_vhost_mutex);
  
 -	mutex_lock(&tpg->tv_tpg_mutex);
 -	tpg->tv_tpg_port_count--;
 -	mutex_unlock(&tpg->tv_tpg_mutex);
 +	mutex_lock(&tv_tpg->tv_tpg_mutex);
 +	tv_tpg->tv_tpg_port_count--;
 +	mutex_unlock(&tv_tpg->tv_tpg_mutex);
  
 -	vhost_scsi_hotunplug(tpg, lun);
 +	tcm_vhost_hotunplug(tv_tpg, lun);
  
 -	mutex_unlock(&vhost_scsi_mutex);
 +	mutex_unlock(&tcm_vhost_mutex);
  }
  
++<<<<<<< HEAD
 +static struct se_node_acl *tcm_vhost_make_nodeacl(
 +	struct se_portal_group *se_tpg,
 +	struct config_group *group,
 +	const char *name)
 +{
 +	struct se_node_acl *se_nacl, *se_nacl_new;
 +	struct tcm_vhost_nacl *nacl;
 +	u64 wwpn = 0;
 +	u32 nexus_depth;
 +
 +	/* tcm_vhost_parse_wwn(name, &wwpn, 1) < 0)
 +		return ERR_PTR(-EINVAL); */
 +	se_nacl_new = tcm_vhost_alloc_fabric_acl(se_tpg);
 +	if (!se_nacl_new)
 +		return ERR_PTR(-ENOMEM);
 +
 +	nexus_depth = 1;
 +	/*
 +	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
 +	 * when converting a NodeACL from demo mode -> explict
 +	 */
 +	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,
 +				name, nexus_depth);
 +	if (IS_ERR(se_nacl)) {
 +		tcm_vhost_release_fabric_acl(se_tpg, se_nacl_new);
 +		return se_nacl;
 +	}
 +	/*
 +	 * Locate our struct tcm_vhost_nacl and set the FC Nport WWPN
 +	 */
 +	nacl = container_of(se_nacl, struct tcm_vhost_nacl, se_node_acl);
 +	nacl->iport_wwpn = wwpn;
 +
 +	return se_nacl;
 +}
 +
 +static void tcm_vhost_drop_nodeacl(struct se_node_acl *se_acl)
 +{
 +	struct tcm_vhost_nacl *nacl = container_of(se_acl,
 +				struct tcm_vhost_nacl, se_node_acl);
 +	core_tpg_del_initiator_node_acl(se_acl->se_tpg, se_acl, 1);
 +	kfree(nacl);
 +}
 +
 +static int tcm_vhost_make_nexus(struct tcm_vhost_tpg *tv_tpg,
 +	const char *name)
++=======
+ static void vhost_scsi_free_cmd_map_res(struct vhost_scsi_nexus *nexus,
+ 				       struct se_session *se_sess)
+ {
+ 	struct vhost_scsi_cmd *tv_cmd;
+ 	unsigned int i;
+ 
+ 	if (!se_sess->sess_cmd_map)
+ 		return;
+ 
+ 	for (i = 0; i < VHOST_SCSI_DEFAULT_TAGS; i++) {
+ 		tv_cmd = &((struct vhost_scsi_cmd *)se_sess->sess_cmd_map)[i];
+ 
+ 		kfree(tv_cmd->tvc_sgl);
+ 		kfree(tv_cmd->tvc_prot_sgl);
+ 		kfree(tv_cmd->tvc_upages);
+ 	}
+ }
+ 
+ static ssize_t vhost_scsi_tpg_attrib_store_fabric_prot_type(
+ 	struct se_portal_group *se_tpg,
+ 	const char *page,
+ 	size_t count)
+ {
+ 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
+ 				struct vhost_scsi_tpg, se_tpg);
+ 	unsigned long val;
+ 	int ret = kstrtoul(page, 0, &val);
+ 
+ 	if (ret) {
+ 		pr_err("kstrtoul() returned %d for fabric_prot_type\n", ret);
+ 		return ret;
+ 	}
+ 	if (val != 0 && val != 1 && val != 3) {
+ 		pr_err("Invalid vhost_scsi fabric_prot_type: %lu\n", val);
+ 		return -EINVAL;
+ 	}
+ 	tpg->tv_fabric_prot_type = val;
+ 
+ 	return count;
+ }
+ 
+ static ssize_t vhost_scsi_tpg_attrib_show_fabric_prot_type(
+ 	struct se_portal_group *se_tpg,
+ 	char *page)
+ {
+ 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
+ 				struct vhost_scsi_tpg, se_tpg);
+ 
+ 	return sprintf(page, "%d\n", tpg->tv_fabric_prot_type);
+ }
+ TF_TPG_ATTRIB_ATTR(vhost_scsi, fabric_prot_type, S_IRUGO | S_IWUSR);
+ 
+ static struct configfs_attribute *vhost_scsi_tpg_attrib_attrs[] = {
+ 	&vhost_scsi_tpg_attrib_fabric_prot_type.attr,
+ 	NULL,
+ };
+ 
+ static int vhost_scsi_make_nexus(struct vhost_scsi_tpg *tpg,
+ 				const char *name)
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  {
  	struct se_portal_group *se_tpg;
 -	struct se_session *se_sess;
 -	struct vhost_scsi_nexus *tv_nexus;
 -	struct vhost_scsi_cmd *tv_cmd;
 -	unsigned int i;
 +	struct tcm_vhost_nexus *tv_nexus;
  
 -	mutex_lock(&tpg->tv_tpg_mutex);
 -	if (tpg->tpg_nexus) {
 -		mutex_unlock(&tpg->tv_tpg_mutex);
 -		pr_debug("tpg->tpg_nexus already exists\n");
 +	mutex_lock(&tv_tpg->tv_tpg_mutex);
 +	if (tv_tpg->tpg_nexus) {
 +		mutex_unlock(&tv_tpg->tv_tpg_mutex);
 +		pr_debug("tv_tpg->tpg_nexus already exists\n");
  		return -EEXIST;
  	}
 -	se_tpg = &tpg->se_tpg;
 +	se_tpg = &tv_tpg->se_tpg;
  
 -	tv_nexus = kzalloc(sizeof(struct vhost_scsi_nexus), GFP_KERNEL);
 +	tv_nexus = kzalloc(sizeof(struct tcm_vhost_nexus), GFP_KERNEL);
  	if (!tv_nexus) {
 -		mutex_unlock(&tpg->tv_tpg_mutex);
 -		pr_err("Unable to allocate struct vhost_scsi_nexus\n");
 +		mutex_unlock(&tv_tpg->tv_tpg_mutex);
 +		pr_err("Unable to allocate struct tcm_vhost_nexus\n");
  		return -ENOMEM;
  	}
  	/*
@@@ -2021,80 -2289,26 +2083,93 @@@ static struct target_core_fabric_ops tc
  	/*
  	 * Setup callers for generic logic in target_core_fabric_configfs.c
  	 */
++<<<<<<< HEAD
 +	.fabric_make_wwn		= tcm_vhost_make_tport,
 +	.fabric_drop_wwn		= tcm_vhost_drop_tport,
 +	.fabric_make_tpg		= tcm_vhost_make_tpg,
 +	.fabric_drop_tpg		= tcm_vhost_drop_tpg,
 +	.fabric_post_link		= tcm_vhost_port_link,
 +	.fabric_pre_unlink		= tcm_vhost_port_unlink,
 +	.fabric_make_np			= NULL,
 +	.fabric_drop_np			= NULL,
 +	.fabric_make_nodeacl		= tcm_vhost_make_nodeacl,
 +	.fabric_drop_nodeacl		= tcm_vhost_drop_nodeacl,
++=======
+ 	.fabric_make_wwn		= vhost_scsi_make_tport,
+ 	.fabric_drop_wwn		= vhost_scsi_drop_tport,
+ 	.fabric_make_tpg		= vhost_scsi_make_tpg,
+ 	.fabric_drop_tpg		= vhost_scsi_drop_tpg,
+ 	.fabric_post_link		= vhost_scsi_port_link,
+ 	.fabric_pre_unlink		= vhost_scsi_port_unlink,
+ 
+ 	.tfc_wwn_attrs			= vhost_scsi_wwn_attrs,
+ 	.tfc_tpg_base_attrs		= vhost_scsi_tpg_attrs,
+ 	.tfc_tpg_attrib_attrs		= vhost_scsi_tpg_attrib_attrs,
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  };
  
 -static int __init vhost_scsi_init(void)
 +static int tcm_vhost_register_configfs(void)
  {
 -	int ret = -ENOMEM;
 +	struct target_fabric_configfs *fabric;
 +	int ret;
  
  	pr_debug("TCM_VHOST fabric module %s on %s/%s"
 -		" on "UTS_RELEASE"\n", VHOST_SCSI_VERSION, utsname()->sysname,
 +		" on "UTS_RELEASE"\n", TCM_VHOST_VERSION, utsname()->sysname,
  		utsname()->machine);
 +	/*
 +	 * Register the top level struct config_item_type with TCM core
 +	 */
 +	fabric = target_fabric_configfs_init(THIS_MODULE, "vhost");
 +	if (IS_ERR(fabric)) {
 +		pr_err("target_fabric_configfs_init() failed\n");
 +		return PTR_ERR(fabric);
 +	}
 +	/*
 +	 * Setup fabric->tf_ops from our local tcm_vhost_ops
 +	 */
 +	fabric->tf_ops = tcm_vhost_ops;
 +	/*
 +	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 +	 */
 +	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = tcm_vhost_wwn_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = tcm_vhost_tpg_attrs;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
 +	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 +	/*
 +	 * Register the fabric for use within TCM
 +	 */
 +	ret = target_fabric_configfs_register(fabric);
 +	if (ret < 0) {
 +		pr_err("target_fabric_configfs_register() failed"
 +				" for TCM_VHOST\n");
 +		return ret;
 +	}
 +	/*
 +	 * Setup our local pointer to *fabric
 +	 */
 +	tcm_vhost_fabric_configfs = fabric;
 +	pr_debug("TCM_VHOST[0] - Set fabric -> tcm_vhost_fabric_configfs\n");
 +	return 0;
 +};
 +
 +static void tcm_vhost_deregister_configfs(void)
 +{
 +	if (!tcm_vhost_fabric_configfs)
 +		return;
  
 +	target_fabric_configfs_deregister(tcm_vhost_fabric_configfs);
 +	tcm_vhost_fabric_configfs = NULL;
 +	pr_debug("TCM_VHOST[0] - Cleared tcm_vhost_fabric_configfs\n");
 +};
 +
 +static int __init tcm_vhost_init(void)
 +{
 +	int ret = -ENOMEM;
  	/*
  	 * Use our own dedicated workqueue for submitting I/O into
  	 * target core to avoid contention within system_wq.
diff --cc include/target/target_core_fabric.h
index c9a57a197803,8b570c49f4d1..000000000000
--- a/include/target/target_core_fabric.h
+++ b/include/target/target_core_fabric.h
@@@ -87,11 -88,28 +87,28 @@@ struct target_core_fabric_ops 
  	struct se_tpg_np *(*fabric_make_np)(struct se_portal_group *,
  				struct config_group *, const char *);
  	void (*fabric_drop_np)(struct se_tpg_np *);
++<<<<<<< HEAD
 +	struct se_node_acl *(*fabric_make_nodeacl)(struct se_portal_group *,
 +				struct config_group *, const char *);
 +	void (*fabric_drop_nodeacl)(struct se_node_acl *);
++=======
+ 	int (*fabric_init_nodeacl)(struct se_node_acl *, const char *);
+ 	void (*fabric_cleanup_nodeacl)(struct se_node_acl *);
+ 
+ 	struct configfs_attribute **tfc_discovery_attrs;
+ 	struct configfs_attribute **tfc_wwn_attrs;
+ 	struct configfs_attribute **tfc_tpg_base_attrs;
+ 	struct configfs_attribute **tfc_tpg_np_base_attrs;
+ 	struct configfs_attribute **tfc_tpg_attrib_attrs;
+ 	struct configfs_attribute **tfc_tpg_auth_attrs;
+ 	struct configfs_attribute **tfc_tpg_param_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_base_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_attrib_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_auth_attrs;
+ 	struct configfs_attribute **tfc_tpg_nacl_param_attrs;
++>>>>>>> c7d6a803926b (target: refactor init/drop_nodeacl methods)
  };
  
 -int target_register_template(const struct target_core_fabric_ops *fo);
 -void target_unregister_template(const struct target_core_fabric_ops *fo);
 -
 -int target_depend_item(struct config_item *item);
 -void target_undepend_item(struct config_item *item);
 -
  struct se_session *transport_init_session(enum target_prot_op);
  int transport_alloc_session_tags(struct se_session *, unsigned int,
  		unsigned int);
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path Documentation/target/tcm_mod_builder.py
diff --git a/Documentation/target/tcm_mod_builder.txt b/Documentation/target/tcm_mod_builder.txt
index 84533d8e747f..ae22f7005540 100644
--- a/Documentation/target/tcm_mod_builder.txt
+++ b/Documentation/target/tcm_mod_builder.txt
@@ -13,8 +13,8 @@ fabric skeleton, by simply using:
 This script will create a new drivers/target/$TCM_NEW_MOD/, and will do the following
 
 	*) Generate new API callers for drivers/target/target_core_fabric_configs.c logic
-	   ->make_nodeacl(), ->drop_nodeacl(), ->make_tpg(), ->drop_tpg()
-	   ->make_wwn(), ->drop_wwn().  These are created into $TCM_NEW_MOD/$TCM_NEW_MOD_configfs.c
+	   ->make_tpg(), ->drop_tpg(), ->make_wwn(), ->drop_wwn().  These are created
+	   into $TCM_NEW_MOD/$TCM_NEW_MOD_configfs.c
 	*) Generate basic infrastructure for loading/unloading LKMs and TCM/ConfigFS fabric module
 	   using a skeleton struct target_core_fabric_ops API template.
 	*) Based on user defined T10 Proto_Ident for the new fabric module being built,
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
* Unmerged path drivers/scsi/qla2xxx/tcm_qla2xxx.c
* Unmerged path drivers/target/iscsi/iscsi_target_configfs.c
* Unmerged path drivers/target/sbp/sbp_target.c
diff --git a/drivers/target/target_core_fabric_configfs.c b/drivers/target/target_core_fabric_configfs.c
index 0c3f90130b7d..7260f4478392 100644
--- a/drivers/target/target_core_fabric_configfs.c
+++ b/drivers/target/target_core_fabric_configfs.c
@@ -444,10 +444,11 @@ static void target_fabric_nacl_base_release(struct config_item *item)
 {
 	struct se_node_acl *se_nacl = container_of(to_config_group(item),
 			struct se_node_acl, acl_group);
-	struct se_portal_group *se_tpg = se_nacl->se_tpg;
-	struct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;
+	struct target_fabric_configfs *tf = se_nacl->se_tpg->se_tpg_wwn->wwn_tf;
 
-	tf->tf_ops.fabric_drop_nodeacl(se_nacl);
+	if (tf->tf_ops.fabric_cleanup_nodeacl)
+		tf->tf_ops.fabric_cleanup_nodeacl(se_nacl);
+	core_tpg_del_initiator_node_acl(se_nacl);
 }
 
 static struct configfs_item_operations target_fabric_nacl_base_item_ops = {
@@ -487,15 +488,18 @@ static struct config_group *target_fabric_make_nodeacl(
 	struct se_node_acl *se_nacl;
 	struct config_group *nacl_cg;
 
-	if (!tf->tf_ops.fabric_make_nodeacl) {
-		pr_err("tf->tf_ops.fabric_make_nodeacl is NULL\n");
-		return ERR_PTR(-ENOSYS);
-	}
-
-	se_nacl = tf->tf_ops.fabric_make_nodeacl(se_tpg, group, name);
+	se_nacl = core_tpg_add_initiator_node_acl(se_tpg, name);
 	if (IS_ERR(se_nacl))
 		return ERR_CAST(se_nacl);
 
+	if (tf->tf_ops.fabric_init_nodeacl) {
+		int ret = tf->tf_ops.fabric_init_nodeacl(se_nacl, name);
+		if (ret) {
+			core_tpg_del_initiator_node_acl(se_nacl);
+			return ERR_PTR(ret);
+		}
+	}
+
 	nacl_cg = &se_nacl->acl_group;
 	nacl_cg->default_groups = se_nacl->acl_default_groups;
 	nacl_cg->default_groups[0] = &se_nacl->acl_attrib_group;
diff --git a/drivers/target/target_core_internal.h b/drivers/target/target_core_internal.h
index 874a9bc988d8..c0466b1d94d5 100644
--- a/drivers/target/target_core_internal.h
+++ b/drivers/target/target_core_internal.h
@@ -62,6 +62,9 @@ struct se_lun *core_tpg_alloc_lun(struct se_portal_group *, u32);
 int	core_tpg_add_lun(struct se_portal_group *, struct se_lun *,
 		u32, struct se_device *);
 void core_tpg_remove_lun(struct se_portal_group *, struct se_lun *);
+struct se_node_acl *core_tpg_add_initiator_node_acl(struct se_portal_group *tpg,
+		const char *initiatorname);
+void core_tpg_del_initiator_node_acl(struct se_node_acl *acl);
 
 /* target_core_transport.c */
 extern struct kmem_cache *se_tmr_req_cache;
diff --git a/drivers/target/target_core_tpg.c b/drivers/target/target_core_tpg.c
index 0696de9553d3..6db64ffd4f0f 100644
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@ -350,17 +350,11 @@ void core_tpg_clear_object_luns(struct se_portal_group *tpg)
 }
 EXPORT_SYMBOL(core_tpg_clear_object_luns);
 
-/*	core_tpg_add_initiator_node_acl():
- *
- *
- */
 struct se_node_acl *core_tpg_add_initiator_node_acl(
 	struct se_portal_group *tpg,
-	struct se_node_acl *se_nacl,
-	const char *initiatorname,
-	u32 queue_depth)
+	const char *initiatorname)
 {
-	struct se_node_acl *acl = NULL;
+	struct se_node_acl *acl;
 
 	spin_lock_irq(&tpg->acl_node_lock);
 	acl = __core_tpg_get_initiator_node_acl(tpg, initiatorname);
@@ -371,14 +365,6 @@ struct se_node_acl *core_tpg_add_initiator_node_acl(
 				" for %s\n", tpg->se_tpg_tfo->get_fabric_name(),
 				tpg->se_tpg_tfo->tpg_get_tag(tpg), initiatorname);
 			spin_unlock_irq(&tpg->acl_node_lock);
-			/*
-			 * Release the locally allocated struct se_node_acl
-			 * because * core_tpg_add_initiator_node_acl() returned
-			 * a pointer to an existing demo mode node ACL.
-			 */
-			if (se_nacl)
-				tpg->se_tpg_tfo->tpg_release_fabric_acl(tpg,
-							se_nacl);
 			goto done;
 		}
 
@@ -391,16 +377,11 @@ struct se_node_acl *core_tpg_add_initiator_node_acl(
 	}
 	spin_unlock_irq(&tpg->acl_node_lock);
 
-	if (!se_nacl) {
+	acl = tpg->se_tpg_tfo->tpg_alloc_fabric_acl(tpg);
+	if (!acl) {
 		pr_err("struct se_node_acl pointer is NULL\n");
 		return ERR_PTR(-EINVAL);
 	}
-	/*
-	 * For v4.x logic the se_node_acl_s is hanging off a fabric
-	 * dependent structure allocated via
-	 * struct target_core_fabric_ops->fabric_make_nodeacl()
-	 */
-	acl = se_nacl;
 
 	INIT_LIST_HEAD(&acl->acl_list);
 	INIT_LIST_HEAD(&acl->acl_sess_list);
@@ -409,7 +390,10 @@ struct se_node_acl *core_tpg_add_initiator_node_acl(
 	spin_lock_init(&acl->device_list_lock);
 	spin_lock_init(&acl->nacl_sess_lock);
 	atomic_set(&acl->acl_pr_ref_count, 0);
-	acl->queue_depth = queue_depth;
+	if (tpg->se_tpg_tfo->tpg_get_default_depth)
+		acl->queue_depth = tpg->se_tpg_tfo->tpg_get_default_depth(tpg);
+	else
+		acl->queue_depth = 1;
 	snprintf(acl->initiatorname, TRANSPORT_IQN_LEN, "%s", initiatorname);
 	acl->se_tpg = tpg;
 	acl->acl_index = scsi_get_new_index(SCSI_AUTH_INTR_INDEX);
@@ -440,17 +424,10 @@ done:
 
 	return acl;
 }
-EXPORT_SYMBOL(core_tpg_add_initiator_node_acl);
 
-/*	core_tpg_del_initiator_node_acl():
- *
- *
- */
-int core_tpg_del_initiator_node_acl(
-	struct se_portal_group *tpg,
-	struct se_node_acl *acl,
-	int force)
+void core_tpg_del_initiator_node_acl(struct se_node_acl *acl)
 {
+	struct se_portal_group *tpg = acl->se_tpg;
 	LIST_HEAD(sess_list);
 	struct se_session *sess, *sess_tmp;
 	unsigned long flags;
@@ -502,9 +479,8 @@ int core_tpg_del_initiator_node_acl(
 		tpg->se_tpg_tfo->tpg_get_tag(tpg), acl->queue_depth,
 		tpg->se_tpg_tfo->get_fabric_name(), acl->initiatorname);
 
-	return 0;
+	tpg->se_tpg_tfo->tpg_release_fabric_acl(tpg, acl);
 }
-EXPORT_SYMBOL(core_tpg_del_initiator_node_acl);
 
 /*	core_tpg_set_initiator_node_queue_depth():
  *
* Unmerged path drivers/target/tcm_fc/tfc_conf.c
* Unmerged path drivers/usb/gadget/tcm_usb_gadget.c
* Unmerged path drivers/vhost/scsi.c
* Unmerged path drivers/xen/xen-scsiback.c
* Unmerged path include/target/target_core_fabric.h
