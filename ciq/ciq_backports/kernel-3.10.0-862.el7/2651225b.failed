selinux: wrap cgroup seclabel support with its own policy capability

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Stephen Smalley <sds@tycho.nsa.gov>
commit 2651225b5ebcdde60f684c4db8ec7e9e3800a74f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/2651225b.failed

commit 1ea0ce40690dff38935538e8dab7b12683ded0d3 ("selinux: allow
changing labels for cgroupfs") broke the Android init program,
which looks up security contexts whenever creating directories
and attempts to assign them via setfscreatecon().
When creating subdirectories in cgroup mounts, this would previously
be ignored since cgroup did not support userspace setting of security
contexts.  However, after the commit, SELinux would attempt to honor
the requested context on cgroup directories and fail due to permission
denial.  Avoid breaking existing userspace/policy by wrapping this change
with a conditional on a new cgroup_seclabel policy capability.  This
preserves existing behavior until/unless a new policy explicitly enables
this capability.

	Reported-by: John Stultz <john.stultz@linaro.org>
	Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
	Signed-off-by: James Morris <james.l.morris@oracle.com>
(cherry picked from commit 2651225b5ebcdde60f684c4db8ec7e9e3800a74f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
#	security/selinux/include/security.h
#	security/selinux/selinuxfs.c
#	security/selinux/ss/services.c
diff --cc security/selinux/hooks.c
index 7c150cbbfbc6,0a4b4b040e0a..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -455,6 -470,25 +455,28 @@@ static int may_context_mount_inode_rela
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_is_sblabel_mnt(struct super_block *sb)
+ {
+ 	struct superblock_security_struct *sbsec = sb->s_security;
+ 
+ 	return sbsec->behavior == SECURITY_FS_USE_XATTR ||
+ 		sbsec->behavior == SECURITY_FS_USE_TRANS ||
+ 		sbsec->behavior == SECURITY_FS_USE_TASK ||
+ 		sbsec->behavior == SECURITY_FS_USE_NATIVE ||
+ 		/* Special handling. Genfs but also in-core setxattr handler */
+ 		!strcmp(sb->s_type->name, "sysfs") ||
+ 		!strcmp(sb->s_type->name, "pstore") ||
+ 		!strcmp(sb->s_type->name, "debugfs") ||
+ 		!strcmp(sb->s_type->name, "tracefs") ||
+ 		!strcmp(sb->s_type->name, "rootfs") ||
+ 		(selinux_policycap_cgroupseclabel &&
+ 		 (!strcmp(sb->s_type->name, "cgroup") ||
+ 		  !strcmp(sb->s_type->name, "cgroup2")));
+ }
+ 
++>>>>>>> 2651225b5ebc (selinux: wrap cgroup seclabel support with its own policy capability)
  static int sb_finish_set_opts(struct super_block *sb)
  {
  	struct superblock_security_struct *sbsec = sb->s_security;
diff --cc security/selinux/include/security.h
index 8fd8e18ea340,f979c35e037e..000000000000
--- a/security/selinux/include/security.h
+++ b/security/selinux/include/security.h
@@@ -68,12 -69,18 +68,24 @@@ extern int selinux_enabled
  enum {
  	POLICYDB_CAPABILITY_NETPEER,
  	POLICYDB_CAPABILITY_OPENPERM,
++<<<<<<< HEAD
++=======
+ 	POLICYDB_CAPABILITY_EXTSOCKCLASS,
+ 	POLICYDB_CAPABILITY_ALWAYSNETWORK,
+ 	POLICYDB_CAPABILITY_CGROUPSECLABEL,
++>>>>>>> 2651225b5ebc (selinux: wrap cgroup seclabel support with its own policy capability)
  	__POLICYDB_CAPABILITY_MAX
  };
  #define POLICYDB_CAPABILITY_MAX (__POLICYDB_CAPABILITY_MAX - 1)
  
  extern int selinux_policycap_netpeer;
  extern int selinux_policycap_openperm;
++<<<<<<< HEAD
++=======
+ extern int selinux_policycap_extsockclass;
+ extern int selinux_policycap_alwaysnetwork;
+ extern int selinux_policycap_cgroupseclabel;
++>>>>>>> 2651225b5ebc (selinux: wrap cgroup seclabel support with its own policy capability)
  
  /*
   * type_datum properties
diff --cc security/selinux/selinuxfs.c
index e89edc244e37,cb3fd98fb05a..000000000000
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@@ -44,7 -44,10 +44,14 @@@
  /* Policy capability filenames */
  static char *policycap_names[] = {
  	"network_peer_controls",
++<<<<<<< HEAD
 +	"open_perms"
++=======
+ 	"open_perms",
+ 	"extended_socket_class",
+ 	"always_check_network",
+ 	"cgroup_seclabel"
++>>>>>>> 2651225b5ebc (selinux: wrap cgroup seclabel support with its own policy capability)
  };
  
  unsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;
diff --cc security/selinux/ss/services.c
index 58bcf8516c22,b4aa491a0a23..000000000000
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@@ -72,6 -72,9 +72,12 @@@
  
  int selinux_policycap_netpeer;
  int selinux_policycap_openperm;
++<<<<<<< HEAD
++=======
+ int selinux_policycap_extsockclass;
+ int selinux_policycap_alwaysnetwork;
+ int selinux_policycap_cgroupseclabel;
++>>>>>>> 2651225b5ebc (selinux: wrap cgroup seclabel support with its own policy capability)
  
  static DEFINE_RWLOCK(policy_rwlock);
  
@@@ -1816,6 -1990,13 +1822,16 @@@ static void security_load_policycaps(vo
  						  POLICYDB_CAPABILITY_NETPEER);
  	selinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,
  						  POLICYDB_CAPABILITY_OPENPERM);
++<<<<<<< HEAD
++=======
+ 	selinux_policycap_extsockclass = ebitmap_get_bit(&policydb.policycaps,
+ 					  POLICYDB_CAPABILITY_EXTSOCKCLASS);
+ 	selinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,
+ 						  POLICYDB_CAPABILITY_ALWAYSNETWORK);
+ 	selinux_policycap_cgroupseclabel =
+ 		ebitmap_get_bit(&policydb.policycaps,
+ 				POLICYDB_CAPABILITY_CGROUPSECLABEL);
++>>>>>>> 2651225b5ebc (selinux: wrap cgroup seclabel support with its own policy capability)
  }
  
  static int security_preserve_bools(struct policydb *p);
* Unmerged path security/selinux/hooks.c
* Unmerged path security/selinux/include/security.h
* Unmerged path security/selinux/selinuxfs.c
* Unmerged path security/selinux/ss/services.c
