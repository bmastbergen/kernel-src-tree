acpi, nfit: validate commands against the device type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 0e7f0741450b1b800b3acfc2319e7f24e8a20fcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/0e7f0741.failed

Fix occasions in acpi_nfit_ctl where we check the command type without
validating whether we are parsing dimm vs bus level commands. Where the
command numbers alias between dimms and bus we can make the wrong
assumption just checking the raw command number. For example, with a
simple nfit_test mock up of the clear-error command we trigger the
following:

    BUG: unable to handle kernel NULL pointer dereference at 0000000000000094
    IP: acpi_nfit_ctl+0x29b/0x930 [nfit]
    [..]
    Call Trace:
     nfit_test_probe+0xb85/0xc09 [nfit_test]
     platform_drv_probe+0x3b/0xa0
     ? platform_drv_probe+0x3b/0xa0
     driver_probe_device+0x29c/0x450
     ? test_alloc+0x180/0x180 [nfit_test]
     __driver_attach+0xe3/0xf0
     ? driver_probe_device+0x450/0x450
     bus_for_each_dev+0x73/0xc0
     driver_attach+0x1e/0x20
     bus_add_driver+0x173/0x270
     driver_register+0x60/0xe0
     __platform_driver_register+0x36/0x40
     nfit_test_init+0x2a1/0x1000 [nfit_test]

Fixes: 4b27db7e26cd ("acpi, nfit: add support for the _LSI, _LSR, and...")
	Reported-by: Vishal Verma <vishal.l.verma@intel.com>
	Tested-by: Vishal Verma <vishal.l.verma@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 0e7f0741450b1b800b3acfc2319e7f24e8a20fcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index 95a335d63b99,ff2580e7611d..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -295,7 -482,29 +295,33 @@@ int acpi_nfit_ctl(struct nvdimm_bus_des
  			in_buf.buffer.pointer,
  			min_t(u32, 256, in_buf.buffer.length), true);
  
++<<<<<<< HEAD
 +	out_obj = acpi_evaluate_dsm(handle, uuid, 1, func, &in_obj);
++=======
+ 	/* call the BIOS, prefer the named methods over _DSM if available */
+ 	if (nvdimm && cmd == ND_CMD_GET_CONFIG_SIZE && nfit_mem->has_lsi)
+ 		out_obj = acpi_label_info(handle);
+ 	else if (nvdimm && cmd == ND_CMD_GET_CONFIG_DATA && nfit_mem->has_lsr) {
+ 		struct nd_cmd_get_config_data_hdr *p = buf;
+ 
+ 		out_obj = acpi_label_read(handle, p->in_offset, p->in_length);
+ 	} else if (nvdimm && cmd == ND_CMD_SET_CONFIG_DATA
+ 			&& nfit_mem->has_lsw) {
+ 		struct nd_cmd_set_config_hdr *p = buf;
+ 
+ 		out_obj = acpi_label_write(handle, p->in_offset, p->in_length,
+ 				p->in_buf);
+ 	} else {
+ 		u8 revid;
+ 
+ 		if (nvdimm)
+ 			revid = nfit_dsm_revid(nfit_mem->family, func);
+ 		else
+ 			revid = 1;
+ 		out_obj = acpi_evaluate_dsm(handle, guid, revid, func, &in_obj);
+ 	}
+ 
++>>>>>>> 0e7f0741450b (acpi, nfit: validate commands against the device type)
  	if (!out_obj) {
  		dev_dbg(dev, "%s:%s _DSM failed cmd: %s\n", __func__, dimm_name,
  				cmd_name);
* Unmerged path drivers/acpi/nfit/core.c
