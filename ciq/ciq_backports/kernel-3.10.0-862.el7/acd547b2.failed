x86/pkeys: Default to a restrictive init PKRU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit acd547b29880800d29222c4632d2c145e401988c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/acd547b2.failed

PKRU is the register that lets you disallow writes or all access to a given
protection key.

The XSAVE hardware defines an "init state" of 0 for PKRU: its most
permissive state, allowing access/writes to everything.  Since we start off
all new processes with the init state, we start all processes off with the
most permissive possible PKRU.

This is unfortunate.  If a thread is clone()'d [1] before a program has
time to set PKRU to a restrictive value, that thread will be able to write
to all data, no matter what pkey is set on it.  This weakens any integrity
guarantees that we want pkeys to provide.

To fix this, we define a very restrictive PKRU to override the
XSAVE-provided value when we create a new FPU context.  We choose a value
that only allows access to pkey 0, which is as restrictive as we can
practically make it.

This does not cause any practical problems with applications using
protection keys because we require them to specify initial permissions for
each key when it is allocated, which override the restrictive default.

In the end, this ensures that threads which do not know how to manage their
own pkey rights can not do damage to data which is pkey-protected.

I would have thought this was a pretty contrived scenario, except that I
heard a bug report from an MPX user who was creating threads in some very
early code before main().  It may be crazy, but folks evidently _do_ it.

	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: linux-arch@vger.kernel.org
	Cc: Dave Hansen <dave@sr71.net>
	Cc: mgorman@techsingularity.net
	Cc: arnd@arndb.de
	Cc: linux-api@vger.kernel.org
	Cc: linux-mm@kvack.org
	Cc: luto@kernel.org
	Cc: akpm@linux-foundation.org
	Cc: torvalds@linux-foundation.org
Link: http://lkml.kernel.org/r/20160729163021.F3C25D4A@viggo.jf.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit acd547b29880800d29222c4632d2c145e401988c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/pkeys.h
#	arch/x86/kernel/fpu/core.c
#	arch/x86/mm/pkeys.c
#	include/linux/pkeys.h
* Unmerged path arch/x86/include/asm/pkeys.h
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/mm/pkeys.c
* Unmerged path include/linux/pkeys.h
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index cbd5f28e2ade..145cdf8823c4 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1241,6 +1241,11 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 
 	initrd=		[BOOT] Specify the location of the initial ramdisk
 
+	init_pkru=	[x86] Specify the default memory protection keys rights
+			register contents for all processes.  0x55555554 by
+			default (disallow access to all but pkey 0).  Can
+			override in debugfs after boot.
+
 	inport.irq=	[HW] Inport (ATI XL and Microsoft) busmouse driver
 			Format: <irq>
 
* Unmerged path arch/x86/include/asm/pkeys.h
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/mm/pkeys.c
* Unmerged path include/linux/pkeys.h
