x86/intel_rdt: Make information files resource specific

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [x86] intel_rdt: Make information files resource specific (Jiri Olsa) [1379551]
Rebuild_FUZZ: 96.23%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit 6a507a6ad8a6955a7d57255377edcef576823749
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/6a507a6a.failed

Cache allocation and memory bandwidth allocation require different
information files in the resctrl/info directory, but the current
implementation does not allow to have files per resource.

Add the necessary fields to the resource struct and assign the files
dynamically depending on the resource type.

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: vikas.shivappa@intel.com
Link: http://lkml.kernel.org/r/1491611637-20417-6-git-send-email-vikas.shivappa@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 6a507a6ad8a6955a7d57255377edcef576823749)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt.c
diff --cc arch/x86/include/asm/intel_rdt.h
index 06f50d0ed14f,b0f0a600c739..000000000000
--- a/arch/x86/include/asm/intel_rdt.h
+++ b/arch/x86/include/asm/intel_rdt.h
@@@ -136,6 -104,77 +136,80 @@@ struct msr_param 
  	int			high;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct rdt_cache - Cache allocation related data
+  * @cbm_len:		Length of the cache bit mask
+  * @min_cbm_bits:	Minimum number of consecutive bits to be set
+  * @cbm_idx_mult:	Multiplier of CBM index
+  * @cbm_idx_offset:	Offset of CBM index. CBM index is computed by:
+  *			closid * cbm_idx_multi + cbm_idx_offset
+  *			in a cache bit mask
+  */
+ struct rdt_cache {
+ 	unsigned int	cbm_len;
+ 	unsigned int	min_cbm_bits;
+ 	unsigned int	cbm_idx_mult;
+ 	unsigned int	cbm_idx_offset;
+ };
+ 
+ /**
+  * struct rdt_membw - Memory bandwidth allocation related data
+  * @max_delay:		Max throttle delay. Delay is the hardware
+  *			representation for memory bandwidth.
+  * @min_bw:		Minimum memory bandwidth percentage user can request
+  * @bw_gran:		Granularity at which the memory bandwidth is allocated
+  * @delay_linear:	True if memory B/W delay is in linear scale
+  * @mb_map:		Mapping of memory B/W percentage to memory B/W delay
+  */
+ struct rdt_membw {
+ 	u32		max_delay;
+ 	u32		min_bw;
+ 	u32		bw_gran;
+ 	u32		delay_linear;
+ 	u32		*mb_map;
+ };
+ 
+ /**
+  * struct rdt_resource - attributes of an RDT resource
+  * @enabled:		Is this feature enabled on this machine
+  * @capable:		Is this feature available on this machine
+  * @name:		Name to use in "schemata" file
+  * @num_closid:		Number of CLOSIDs available
+  * @cache_level:	Which cache level defines scope of this resource
+  * @default_ctrl:	Specifies default cache cbm or memory B/W percent.
+  * @msr_base:		Base MSR address for CBMs
+  * @msr_update:		Function pointer to update QOS MSRs
+  * @data_width:		Character width of data when displaying
+  * @domains:		All domains for this resource
+  * @cache:		Cache allocation related data
+  * @info_files:		resctrl info files for the resource
+  * @nr_info_files:	Number of info files
+  */
+ struct rdt_resource {
+ 	bool			enabled;
+ 	bool			capable;
+ 	char			*name;
+ 	int			num_closid;
+ 	int			cache_level;
+ 	u32			default_ctrl;
+ 	unsigned int		msr_base;
+ 	void (*msr_update)	(struct rdt_domain *d, struct msr_param *m,
+ 				 struct rdt_resource *r);
+ 	int			data_width;
+ 	struct list_head	domains;
+ 	union {
+ 		struct rdt_cache	cache;
+ 		struct rdt_membw	membw;
+ 	};
+ 	struct rftype		*info_files;
+ 	int			nr_info_files;
+ };
+ 
+ void rdt_get_cache_infofile(struct rdt_resource *r);
+ 
++>>>>>>> 6a507a6ad8a6 (x86/intel_rdt: Make information files resource specific)
  extern struct mutex rdtgroup_mutex;
  
  extern struct rdt_resource rdt_resources_all[];
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index ad087dd4421e,b387e04885be..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -144,9 -218,10 +144,16 @@@ static void rdt_get_config(int idx, str
  
  	cpuid_count(0x00000010, idx, &eax.full, &ebx, &ecx, &edx.full);
  	r->num_closid = edx.split.cos_max + 1;
++<<<<<<< HEAD
 +	r->cbm_len = eax.split.cbm_len + 1;
 +	r->max_cbm = BIT_MASK(eax.split.cbm_len + 1) - 1;
 +	r->data_width = (r->cbm_len + 3) / 4;
++=======
+ 	r->cache.cbm_len = eax.split.cbm_len + 1;
+ 	r->default_ctrl = BIT_MASK(eax.split.cbm_len + 1) - 1;
+ 	r->data_width = (r->cache.cbm_len + 3) / 4;
+ 	rdt_get_cache_infofile(r);
++>>>>>>> 6a507a6ad8a6 (x86/intel_rdt: Make information files resource specific)
  	r->capable = true;
  	r->enabled = true;
  }
* Unmerged path arch/x86/include/asm/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
diff --git a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 13bdbbd81667..81570889eb32 100644
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@ -539,7 +539,7 @@ static int rdt_min_cbm_bits_show(struct kernfs_open_file *of,
 }
 
 /* rdtgroup information files for one cache resource. */
-static struct rftype res_info_files[] = {
+static struct rftype res_cache_info_files[] = {
 	{
 		.name		= "num_closids",
 		.mode		= 0444,
@@ -560,11 +560,18 @@ static struct rftype res_info_files[] = {
 	},
 };
 
+void rdt_get_cache_infofile(struct rdt_resource *r)
+{
+	r->info_files = res_cache_info_files;
+	r->nr_info_files = ARRAY_SIZE(res_cache_info_files);
+}
+
 static int rdtgroup_create_info_dir(struct kernfs_node *parent_kn)
 {
 	struct kernfs_node *kn_subdir;
+	struct rftype *res_info_files;
 	struct rdt_resource *r;
-	int ret;
+	int ret, len;
 
 	/* create the directory */
 	kn_info = kernfs_create_dir(parent_kn, "info", parent_kn->mode, NULL);
@@ -583,8 +590,11 @@ static int rdtgroup_create_info_dir(struct kernfs_node *parent_kn)
 		ret = rdtgroup_kn_set_ugid(kn_subdir);
 		if (ret)
 			goto out_destroy;
-		ret = rdtgroup_add_files(kn_subdir, res_info_files,
-					 ARRAY_SIZE(res_info_files));
+
+		res_info_files = r->info_files;
+		len = r->nr_info_files;
+
+		ret = rdtgroup_add_files(kn_subdir, res_info_files, len);
 		if (ret)
 			goto out_destroy;
 		kernfs_activate(kn_subdir);
