scsi_dh_alua: Use workqueue for RTPG

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hannes Reinecke <hare@suse.de>
commit 03197b61c5ec28f5eded69abb54eca699ac9ba0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/03197b61.failed

The current ALUA device_handler has two drawbacks:
- We're sending a 'SET TARGET PORT GROUP' command to every LUN,
  disregarding the fact that several LUNs might be in a port group
  and will be automatically switched whenever _any_ LUN within
  that port group receives the command.
- Whenever a LUN is in 'transitioning' mode we cannot block I/O
  to that LUN, instead the controller has to abort the command.
  This leads to increased traffic across the wire and heavy load
  on the controller during switchover.

With this patch the RTPG handling is moved to a per-portgroup
workqueue. This reduces the number of 'REPORT TARGET PORT GROUP'
and 'SET TARGET PORT GROUPS' sent to the controller as we're sending
them now per port group, and not per device as previously.
It also allows us to block I/O to any LUN / port group found to be
in 'transitioning' ALUA mode, as the workqueue item will be requeued
until the controller moves out of transitioning.

	Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 03197b61c5ec28f5eded69abb54eca699ac9ba0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/device_handler/scsi_dh_alua.c
diff --cc drivers/scsi/device_handler/scsi_dh_alua.c
index 9c9d9c3d8e9b,8318852fc437..000000000000
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@@ -56,27 -56,58 +56,70 @@@
  #define TPGS_MODE_IMPLICIT		0x1
  #define TPGS_MODE_EXPLICIT		0x2
  
 -#define ALUA_RTPG_SIZE			128
 +#define ALUA_INQUIRY_SIZE		36
  #define ALUA_FAILOVER_TIMEOUT		60
  #define ALUA_FAILOVER_RETRIES		5
+ #define ALUA_RTPG_DELAY_MSECS		5
  
  /* device handler flags */
- #define ALUA_OPTIMIZE_STPG		1
- #define ALUA_RTPG_EXT_HDR_UNSUPP	2
- 
+ #define ALUA_OPTIMIZE_STPG		0x01
+ #define ALUA_RTPG_EXT_HDR_UNSUPP	0x02
+ /* State machine flags */
+ #define ALUA_PG_RUN_RTPG		0x10
+ #define ALUA_PG_RUN_STPG		0x20
+ #define ALUA_PG_RUNNING			0x40
+ 
++<<<<<<< HEAD
 +struct alua_dh_data {
 +	struct scsi_dh_data	dh_data;
++=======
+ static uint optimize_stpg;
+ module_param(optimize_stpg, uint, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(optimize_stpg, "Allow use of a non-optimized path, rather than sending a STPG, when implicit TPGS is supported (0=No,1=Yes). Default is 0.");
+ 
+ static LIST_HEAD(port_group_list);
+ static DEFINE_SPINLOCK(port_group_lock);
+ static struct workqueue_struct *kaluad_wq;
+ 
+ struct alua_port_group {
+ 	struct kref		kref;
+ 	struct rcu_head		rcu;
+ 	struct list_head	node;
+ 	unsigned char		device_id_str[256];
+ 	int			device_id_len;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  	int			group_id;
 +	int			rel_port;
  	int			tpgs;
  	int			state;
  	int			pref;
  	unsigned		flags; /* used for optimizing STPG */
 +	unsigned char		inq[ALUA_INQUIRY_SIZE];
 +	unsigned char		*buff;
 +	int			bufflen;
  	unsigned char		transition_tmo;
++<<<<<<< HEAD
++=======
+ 	unsigned long		expiry;
+ 	unsigned long		interval;
+ 	struct delayed_work	rtpg_work;
+ 	spinlock_t		lock;
+ 	struct list_head	rtpg_list;
+ 	struct scsi_device	*rtpg_sdev;
+ };
+ 
+ struct alua_dh_data {
+ 	struct alua_port_group	*pg;
+ 	int			group_id;
+ 	spinlock_t		pg_lock;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  	struct scsi_device	*sdev;
+ 	int			init_error;
+ 	struct mutex		init_mutex;
+ };
+ 
+ struct alua_queue_data {
+ 	struct list_head	entry;
  	activate_complete	callback_fn;
  	void			*callback_data;
  };
@@@ -84,26 -115,22 +127,43 @@@
  #define ALUA_POLICY_SWITCH_CURRENT	0
  #define ALUA_POLICY_SWITCH_ALL		1
  
++<<<<<<< HEAD
 +static char print_alua_state(int);
++=======
+ static void alua_rtpg_work(struct work_struct *work);
+ static void alua_rtpg_queue(struct alua_port_group *pg,
+ 			    struct scsi_device *sdev,
+ 			    struct alua_queue_data *qdata);
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  
 -static void release_port_group(struct kref *kref)
 +static inline struct alua_dh_data *get_alua_data(struct scsi_device *sdev)
  {
 -	struct alua_port_group *pg;
 +	return container_of(sdev->scsi_dh_data, struct alua_dh_data, dh_data);
 +}
  
++<<<<<<< HEAD
 +static int realloc_buffer(struct alua_dh_data *h, unsigned len)
 +{
 +	if (h->buff && h->buff != h->inq)
 +		kfree(h->buff);
 +
 +	h->buff = kmalloc(len, GFP_NOIO);
 +	if (!h->buff) {
 +		h->buff = h->inq;
 +		h->bufflen = ALUA_INQUIRY_SIZE;
 +		return 1;
 +	}
 +	h->bufflen = len;
 +	return 0;
++=======
+ 	pg = container_of(kref, struct alua_port_group, kref);
+ 	if (pg->rtpg_sdev)
+ 		flush_delayed_work(&pg->rtpg_work);
+ 	spin_lock(&port_group_lock);
+ 	list_del(&pg->node);
+ 	spin_unlock(&port_group_lock);
+ 	kfree_rcu(pg, rcu);
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  }
  
  /*
@@@ -165,6 -192,83 +225,86 @@@ static int submit_stpg(struct scsi_devi
  				      ALUA_FAILOVER_RETRIES, NULL, req_flags);
  }
  
++<<<<<<< HEAD
++=======
+ struct alua_port_group *alua_find_get_pg(char *id_str, size_t id_size,
+ 					 int group_id)
+ {
+ 	struct alua_port_group *pg;
+ 
+ 	list_for_each_entry(pg, &port_group_list, node) {
+ 		if (pg->group_id != group_id)
+ 			continue;
+ 		if (pg->device_id_len != id_size)
+ 			continue;
+ 		if (strncmp(pg->device_id_str, id_str, id_size))
+ 			continue;
+ 		if (!kref_get_unless_zero(&pg->kref))
+ 			continue;
+ 		return pg;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * alua_alloc_pg - Allocate a new port_group structure
+  * @sdev: scsi device
+  * @h: alua device_handler data
+  * @group_id: port group id
+  *
+  * Allocate a new port_group structure for a given
+  * device.
+  */
+ struct alua_port_group *alua_alloc_pg(struct scsi_device *sdev,
+ 				      int group_id, int tpgs)
+ {
+ 	struct alua_port_group *pg, *tmp_pg;
+ 
+ 	pg = kzalloc(sizeof(struct alua_port_group), GFP_KERNEL);
+ 	if (!pg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pg->device_id_len = scsi_vpd_lun_id(sdev, pg->device_id_str,
+ 					    sizeof(pg->device_id_str));
+ 	if (pg->device_id_len <= 0) {
+ 		/*
+ 		 * Internal error: TPGS supported but no device
+ 		 * identifcation found. Disable ALUA support.
+ 		 */
+ 		kfree(pg);
+ 		sdev_printk(KERN_INFO, sdev,
+ 			    "%s: No device descriptors found\n",
+ 			    ALUA_DH_NAME);
+ 		return ERR_PTR(-ENXIO);
+ 	}
+ 	pg->group_id = group_id;
+ 	pg->tpgs = tpgs;
+ 	pg->state = TPGS_STATE_OPTIMIZED;
+ 	if (optimize_stpg)
+ 		pg->flags |= ALUA_OPTIMIZE_STPG;
+ 	kref_init(&pg->kref);
+ 	INIT_DELAYED_WORK(&pg->rtpg_work, alua_rtpg_work);
+ 	INIT_LIST_HEAD(&pg->rtpg_list);
+ 	INIT_LIST_HEAD(&pg->node);
+ 	spin_lock_init(&pg->lock);
+ 
+ 	spin_lock(&port_group_lock);
+ 	tmp_pg = alua_find_get_pg(pg->device_id_str, pg->device_id_len,
+ 				  group_id);
+ 	if (tmp_pg) {
+ 		spin_unlock(&port_group_lock);
+ 		kfree(pg);
+ 		return tmp_pg;
+ 	}
+ 
+ 	list_add(&pg->node, &port_group_list);
+ 	spin_unlock(&port_group_lock);
+ 
+ 	return pg;
+ }
+ 
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  /*
   * alua_check_tpgs - Evaluate TPGS setting
   * @sdev: device to be checked
@@@ -224,9 -328,11 +364,10 @@@ static int alua_check_tpgs(struct scsi_
   * Extract the relative target port and the target port group
   * descriptor from the list of identificators.
   */
 -static int alua_check_vpd(struct scsi_device *sdev, struct alua_dh_data *h,
 -			  int tpgs)
 +static int alua_check_vpd(struct scsi_device *sdev, struct alua_dh_data *h)
  {
  	int rel_port = -1, group_id;
+ 	struct alua_port_group *pg, *old_pg = NULL;
  
  	group_id = scsi_vpd_tpg_id(sdev, &rel_port);
  	if (group_id < 0) {
@@@ -240,14 -346,31 +381,41 @@@
  			    ALUA_DH_NAME);
  		return SCSI_DH_DEV_UNSUPP;
  	}
 +	h->state = TPGS_STATE_OPTIMIZED;
 +	h->group_id = group_id;
 +
++<<<<<<< HEAD
 +	sdev_printk(KERN_INFO, sdev,
 +		    "%s: port group %02x rel port %02x\n",
 +		    ALUA_DH_NAME, h->group_id, h->rel_port);
  
 +	return 0;
++=======
+ 	pg = alua_alloc_pg(sdev, group_id, tpgs);
+ 	if (IS_ERR(pg)) {
+ 		if (PTR_ERR(pg) == -ENOMEM)
+ 			return SCSI_DH_NOMEM;
+ 		return SCSI_DH_DEV_UNSUPP;
+ 	}
+ 	sdev_printk(KERN_INFO, sdev,
+ 		    "%s: device %s port group %x rel port %x\n",
+ 		    ALUA_DH_NAME, pg->device_id_str, group_id, rel_port);
+ 
+ 	/* Check for existing port group references */
+ 	spin_lock(&h->pg_lock);
+ 	old_pg = h->pg;
+ 	if (old_pg != pg) {
+ 		/* port group has changed. Update to new port group */
+ 		rcu_assign_pointer(h->pg, pg);
+ 	}
+ 	alua_rtpg_queue(h->pg, sdev, NULL);
+ 	spin_unlock(&h->pg_lock);
+ 
+ 	if (old_pg)
+ 		kref_put(&old_pg->kref, release_port_group);
+ 
+ 	return SCSI_DH_OK;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  }
  
  static char print_alua_state(int state)
@@@ -336,23 -458,30 +504,37 @@@ static int alua_check_sense(struct scsi
   * Returns SCSI_DH_DEV_OFFLINED if the path is
   * found to be unusable.
   */
 -static int alua_rtpg(struct scsi_device *sdev, struct alua_port_group *pg)
 +static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h, int wait_for_transition)
  {
  	struct scsi_sense_hdr sense_hdr;
 -	int len, k, off, valid_states = 0, bufflen = ALUA_RTPG_SIZE;
 -	unsigned char *ucp, *buff;
 +	int len, k, off, valid_states = 0;
 +	unsigned char *ucp;
  	unsigned err, retval;
- 	unsigned long expiry, interval = 0;
  	unsigned int tpg_desc_tbl_off;
  	unsigned char orig_transition_tmo;
  
++<<<<<<< HEAD
 +	if (!h->transition_tmo)
 +		expiry = round_jiffies_up(jiffies + ALUA_FAILOVER_TIMEOUT * HZ);
 +	else
 +		expiry = round_jiffies_up(jiffies + h->transition_tmo * HZ);
++=======
+ 	if (!pg->expiry) {
+ 		unsigned long transition_tmo = ALUA_FAILOVER_TIMEOUT * HZ;
+ 
+ 		if (pg->transition_tmo)
+ 			transition_tmo = pg->transition_tmo * HZ;
+ 
+ 		pg->expiry = round_jiffies_up(jiffies + transition_tmo);
+ 	}
+ 
+ 	buff = kzalloc(bufflen, GFP_KERNEL);
+ 	if (!buff)
+ 		return SCSI_DH_DEV_TEMP_BUSY;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  
   retry:
 -	retval = submit_rtpg(sdev, buff, bufflen, &sense_hdr, pg->flags);
 +	retval = submit_rtpg(sdev, h->buff, h->bufflen, &sense_hdr, h->flags);
  
  	if (retval) {
  		if (!scsi_sense_valid(&sense_hdr)) {
@@@ -396,6 -527,8 +579,11 @@@
  		sdev_printk(KERN_ERR, sdev, "%s: rtpg failed\n",
  			    ALUA_DH_NAME);
  		scsi_print_sense_hdr(sdev, ALUA_DH_NAME, &sense_hdr);
++<<<<<<< HEAD
++=======
+ 		kfree(buff);
+ 		pg->expiry = 0;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  		return SCSI_DH_IO;
  	}
  
@@@ -412,20 -549,20 +601,25 @@@
  		goto retry;
  	}
  
 -	orig_transition_tmo = pg->transition_tmo;
 -	if ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && buff[5] != 0)
 -		pg->transition_tmo = buff[5];
 +	orig_transition_tmo = h->transition_tmo;
 +	if ((h->buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR && h->buff[5] != 0)
 +		h->transition_tmo = h->buff[5];
  	else
 -		pg->transition_tmo = ALUA_FAILOVER_TIMEOUT;
 +		h->transition_tmo = ALUA_FAILOVER_TIMEOUT;
  
 -	if (orig_transition_tmo != pg->transition_tmo) {
 +	if (wait_for_transition && (orig_transition_tmo != h->transition_tmo)) {
  		sdev_printk(KERN_INFO, sdev,
  			    "%s: transition timeout set to %d seconds\n",
++<<<<<<< HEAD
 +			    ALUA_DH_NAME, h->transition_tmo);
 +		expiry = jiffies + h->transition_tmo * HZ;
++=======
+ 			    ALUA_DH_NAME, pg->transition_tmo);
+ 		pg->expiry = jiffies + pg->transition_tmo * HZ;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  	}
  
 -	if ((buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)
 +	if ((h->buff[4] & RTPG_FMT_MASK) == RTPG_FMT_EXT_HDR)
  		tpg_desc_tbl_off = 8;
  	else
  		tpg_desc_tbl_off = 4;
@@@ -454,22 -591,18 +648,35 @@@
  		    valid_states&TPGS_SUPPORT_NONOPTIMIZED?'N':'n',
  		    valid_states&TPGS_SUPPORT_OPTIMIZED?'A':'a');
  
 -	switch (pg->state) {
 +	switch (h->state) {
  	case TPGS_STATE_TRANSITIONING:
++<<<<<<< HEAD
 +		if (wait_for_transition) {
 +			if (time_before(jiffies, expiry)) {
 +				/* State transition, retry */
 +				interval += 2000;
 +				msleep(interval);
 +				goto retry;
 +			}
 +			err = SCSI_DH_RETRY;
 +		} else {
 +			err = SCSI_DH_OK;
 +		}
 +
 +		/* Transitioning time exceeded, set port to standby */
 +		h->state = TPGS_STATE_STANDBY;
++=======
+ 		if (time_before(jiffies, pg->expiry)) {
+ 			/* State transition, retry */
+ 			pg->interval = 2;
+ 			err = SCSI_DH_RETRY;
+ 		} else {
+ 			/* Transitioning time exceeded, set port to standby */
+ 			err = SCSI_DH_IO;
+ 			pg->state = TPGS_STATE_STANDBY;
+ 			pg->expiry = 0;
+ 		}
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  		break;
  	case TPGS_STATE_OFFLINE:
  		/* Path unusable */
@@@ -478,8 -612,10 +686,9 @@@
  	default:
  		/* Useable path if active */
  		err = SCSI_DH_OK;
+ 		pg->expiry = 0;
  		break;
  	}
 -	kfree(buff);
  	return err;
  }
  
@@@ -550,21 -787,14 +860,30 @@@ static void alua_rtpg_queue(struct alua
   */
  static int alua_initialize(struct scsi_device *sdev, struct alua_dh_data *h)
  {
 -	int err = SCSI_DH_DEV_UNSUPP, tpgs;
 +	int err = SCSI_DH_DEV_UNSUPP;
 +
++<<<<<<< HEAD
 +	h->tpgs = alua_check_tpgs(sdev);
 +	if (h->tpgs == TPGS_MODE_NONE)
 +		goto out;
 +
 +	err = alua_check_vpd(sdev, h);
 +	if (err != SCSI_DH_OK)
 +		goto out;
 +
 +	err = alua_rtpg(sdev, h, 0);
 +	if (err != SCSI_DH_OK)
 +		goto out;
  
 +out:
++=======
+ 	mutex_lock(&h->init_mutex);
+ 	tpgs = alua_check_tpgs(sdev);
+ 	if (tpgs != TPGS_MODE_NONE)
+ 		err = alua_check_vpd(sdev, h, tpgs);
+ 	h->init_error = err;
+ 	mutex_unlock(&h->init_mutex);
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  	return err;
  }
  /*
@@@ -578,7 -808,8 +897,12 @@@
   */
  static int alua_set_params(struct scsi_device *sdev, const char *params)
  {
++<<<<<<< HEAD
 +	struct alua_dh_data *h = get_alua_data(sdev);
++=======
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 	struct alua_port_group __rcu *pg = NULL;
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  	unsigned int optimize = 0, argc;
  	const char *p = params;
  	int result = SCSI_DH_OK;
@@@ -591,10 -823,19 +916,26 @@@
  	if ((sscanf(p, "%u", &optimize) != 1) || (optimize > 1))
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	rcu_read_lock();
+ 	pg = rcu_dereference(h->pg);
+ 	if (!pg) {
+ 		rcu_read_unlock();
+ 		return -ENXIO;
+ 	}
+ 	spin_lock_irqsave(&pg->lock, flags);
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  	if (optimize)
 -		pg->flags |= ALUA_OPTIMIZE_STPG;
 +		h->flags |= ALUA_OPTIMIZE_STPG;
  	else
++<<<<<<< HEAD
 +		h->flags &= ~ALUA_OPTIMIZE_STPG;
++=======
+ 		pg->flags &= ~ALUA_OPTIMIZE_STPG;
+ 	spin_unlock_irqrestore(&pg->lock, flags);
+ 	rcu_read_unlock();
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  
  	return result;
  }
@@@ -616,19 -853,35 +957,48 @@@ MODULE_PARM_DESC(optimize_stpg, "Allow 
  static int alua_activate(struct scsi_device *sdev,
  			activate_complete fn, void *data)
  {
 -	struct alua_dh_data *h = sdev->handler_data;
 +	struct alua_dh_data *h = get_alua_data(sdev);
  	int err = SCSI_DH_OK;
+ 	struct alua_queue_data *qdata;
+ 	struct alua_port_group __rcu *pg;
  
++<<<<<<< HEAD
 +	err = alua_rtpg(sdev, h, 1);
 +	if (err != SCSI_DH_OK)
 +		goto out;
 +
 +	if (optimize_stpg)
 +		h->flags |= ALUA_OPTIMIZE_STPG;
 +
 +	err = alua_stpg(sdev, h);
 +	if (err == SCSI_DH_RETRY)
 +		err = alua_rtpg(sdev, h, 1);
++=======
+ 	qdata = kzalloc(sizeof(*qdata), GFP_KERNEL);
+ 	if (!qdata) {
+ 		err = SCSI_DH_RES_TEMP_UNAVAIL;
+ 		goto out;
+ 	}
+ 	qdata->callback_fn = fn;
+ 	qdata->callback_data = data;
+ 
+ 	mutex_lock(&h->init_mutex);
+ 	rcu_read_lock();
+ 	pg = rcu_dereference(h->pg);
+ 	if (!pg || !kref_get_unless_zero(&pg->kref)) {
+ 		rcu_read_unlock();
+ 		kfree(qdata);
+ 		err = h->init_error;
+ 		mutex_unlock(&h->init_mutex);
+ 		goto out;
+ 	}
+ 	fn = NULL;
+ 	rcu_read_unlock();
+ 	mutex_unlock(&h->init_mutex);
+ 
+ 	alua_rtpg_queue(pg, sdev, qdata);
+ 	kref_put(&pg->kref, release_port_group);
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  out:
  	if (fn)
  		fn(data, err);
@@@ -643,14 -896,21 +1013,28 @@@
   */
  static int alua_prep_fn(struct scsi_device *sdev, struct request *req)
  {
++<<<<<<< HEAD
 +	struct alua_dh_data *h = get_alua_data(sdev);
 +	int ret = BLKPREP_OK;
 +
 +	if (h->state == TPGS_STATE_TRANSITIONING)
++=======
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 	struct alua_port_group __rcu *pg;
+ 	int state = TPGS_STATE_OPTIMIZED;
+ 	int ret = BLKPREP_OK;
+ 
+ 	rcu_read_lock();
+ 	pg = rcu_dereference(h->pg);
+ 	if (pg)
+ 		state = pg->state;
+ 	rcu_read_unlock();
+ 	if (state == TPGS_STATE_TRANSITIONING)
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  		ret = BLKPREP_DEFER;
 -	else if (state != TPGS_STATE_OPTIMIZED &&
 -		 state != TPGS_STATE_NONOPTIMIZED &&
 -		 state != TPGS_STATE_LBA_DEPENDENT) {
 +	else if (h->state != TPGS_STATE_OPTIMIZED &&
 +		 h->state != TPGS_STATE_NONOPTIMIZED &&
 +		 h->state != TPGS_STATE_LBA_DEPENDENT) {
  		ret = BLKPREP_KILL;
  		req->cmd_flags |= REQ_QUIET;
  	}
@@@ -658,13 -918,57 +1042,61 @@@
  
  }
  
 -/*
 - * alua_bus_attach - Attach device handler
 - * @sdev: device to be attached to
 - */
 -static int alua_bus_attach(struct scsi_device *sdev)
 +static bool alua_match(struct scsi_device *sdev)
  {
++<<<<<<< HEAD
 +	return (scsi_device_tpgs(sdev) != 0);
 +}
 +
 +static int alua_bus_attach(struct scsi_device *sdev);
 +static void alua_bus_detach(struct scsi_device *sdev);
++=======
+ 	struct alua_dh_data *h;
+ 	int err, ret = -EINVAL;
+ 
+ 	h = kzalloc(sizeof(*h) , GFP_KERNEL);
+ 	if (!h)
+ 		return -ENOMEM;
+ 	spin_lock_init(&h->pg_lock);
+ 	rcu_assign_pointer(h->pg, NULL);
+ 	h->init_error = SCSI_DH_OK;
+ 	h->sdev = sdev;
+ 
+ 	mutex_init(&h->init_mutex);
+ 	err = alua_initialize(sdev, h);
+ 	if (err == SCSI_DH_NOMEM)
+ 		ret = -ENOMEM;
+ 	if (err != SCSI_DH_OK && err != SCSI_DH_DEV_OFFLINED)
+ 		goto failed;
+ 
+ 	sdev->handler_data = h;
+ 	return 0;
+ failed:
+ 	kfree(h);
+ 	return ret;
+ }
+ 
+ /*
+  * alua_bus_detach - Detach device handler
+  * @sdev: device to be detached from
+  */
+ static void alua_bus_detach(struct scsi_device *sdev)
+ {
+ 	struct alua_dh_data *h = sdev->handler_data;
+ 	struct alua_port_group *pg;
+ 
+ 	spin_lock(&h->pg_lock);
+ 	pg = h->pg;
+ 	rcu_assign_pointer(h->pg, NULL);
+ 	h->sdev = NULL;
+ 	spin_unlock(&h->pg_lock);
+ 	if (pg)
+ 		kref_put(&pg->kref, release_port_group);
+ 
+ 	sdev->handler_data = NULL;
+ 	kfree(h);
+ }
++>>>>>>> 03197b61c5ec (scsi_dh_alua: Use workqueue for RTPG)
  
  static struct scsi_device_handler alua_dh = {
  	.name = ALUA_DH_NAME,
* Unmerged path drivers/scsi/device_handler/scsi_dh_alua.c
