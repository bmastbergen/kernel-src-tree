device-dax: improve fault handler debug output

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Oliver O'Halloran <oohall@gmail.com>
commit 762026203c0b87b1088342b664e67ca7c45fb7c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/76202620.failed

A couple of minor improvements to the debug output in the fault handlers:

a) Print the region alignment and fault size when we sent a SIGBUS
   because the region alignment is greater than the fault size.
b) Fix the message in the PFN_{DEV|MAP} check.
c) Additionally print the fault size enum value in the huge fault handler.

	Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 762026203c0b87b1088342b664e67ca7c45fb7c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/dax.c
diff --cc drivers/dax/dax.c
index 5e37741e7a4f,352cc54056ce..000000000000
--- a/drivers/dax/dax.c
+++ b/drivers/dax/dax.c
@@@ -533,24 -508,95 +535,93 @@@ static int __dax_dev_pmd_fault(struct d
  
  	pfn = phys_to_pfn_t(phys, dax_region->pfn_flags);
  
 -	return vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd, pfn,
 -			vmf->flags & FAULT_FLAG_WRITE);
 +	return vmf_insert_pfn_pmd(vma, addr, pmd, pfn,
 +			flags & FAULT_FLAG_WRITE);
  }
  
 -#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
 -static int __dax_dev_pud_fault(struct dax_dev *dax_dev, struct vm_fault *vmf)
 +static int dax_dev_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
 +		pmd_t *pmd, unsigned int flags)
  {
++<<<<<<< HEAD
 +	int rc;
 +	struct file *filp = vma->vm_file;
 +	struct dax_dev *dax_dev = filp->private_data;
 +
 +	dev_dbg(&dax_dev->dev, "%s: %s: %s (%#lx - %#lx)\n", __func__,
 +			current->comm, (flags & FAULT_FLAG_WRITE)
 +			? "write" : "read", vma->vm_start, vma->vm_end);
++=======
+ 	unsigned long pud_addr = vmf->address & PUD_MASK;
+ 	struct device *dev = &dax_dev->dev;
+ 	struct dax_region *dax_region;
+ 	phys_addr_t phys;
+ 	pgoff_t pgoff;
+ 	pfn_t pfn;
+ 	unsigned int fault_size = PUD_SIZE;
+ 
+ 
+ 	if (check_vma(dax_dev, vmf->vma, __func__))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	dax_region = dax_dev->region;
+ 	if (dax_region->align > PUD_SIZE) {
+ 		dev_dbg(dev, "%s: alignment (%#x) > fault size (%#x)\n",
+ 			__func__, dax_region->align, fault_size);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	/* dax pud mappings require pfn_t_devmap() */
+ 	if ((dax_region->pfn_flags & (PFN_DEV|PFN_MAP)) != (PFN_DEV|PFN_MAP)) {
+ 		dev_dbg(dev, "%s: region lacks devmap flags\n", __func__);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	if (fault_size < dax_region->align)
+ 		return VM_FAULT_SIGBUS;
+ 	else if (fault_size > dax_region->align)
+ 		return VM_FAULT_FALLBACK;
+ 
+ 	/* if we are outside of the VMA */
+ 	if (pud_addr < vmf->vma->vm_start ||
+ 			(pud_addr + PUD_SIZE) > vmf->vma->vm_end)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	pgoff = linear_page_index(vmf->vma, pud_addr);
+ 	phys = pgoff_to_phys(dax_dev, pgoff, PUD_SIZE);
+ 	if (phys == -1) {
+ 		dev_dbg(dev, "%s: pgoff_to_phys(%#lx) failed\n", __func__,
+ 				pgoff);
+ 		return VM_FAULT_SIGBUS;
+ 	}
+ 
+ 	pfn = phys_to_pfn_t(phys, dax_region->pfn_flags);
+ 
+ 	return vmf_insert_pfn_pud(vmf->vma, vmf->address, vmf->pud, pfn,
+ 			vmf->flags & FAULT_FLAG_WRITE);
+ }
+ #else
+ static int __dax_dev_pud_fault(struct dax_dev *dax_dev, struct vm_fault *vmf)
+ {
+ 	return VM_FAULT_FALLBACK;
+ }
+ #endif /* !CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
+ 
+ static int dax_dev_huge_fault(struct vm_fault *vmf,
+ 		enum page_entry_size pe_size)
+ {
+ 	int rc, id;
+ 	struct file *filp = vmf->vma->vm_file;
+ 	struct dax_dev *dax_dev = filp->private_data;
+ 
+ 	dev_dbg(&dax_dev->dev, "%s: %s: %s (%#lx - %#lx) size = %d\n", __func__,
+ 			current->comm, (vmf->flags & FAULT_FLAG_WRITE)
+ 			? "write" : "read",
+ 			vmf->vma->vm_start, vmf->vma->vm_end, pe_size);
++>>>>>>> 762026203c0b (device-dax: improve fault handler debug output)
  
 -	id = srcu_read_lock(&dax_srcu);
 -	switch (pe_size) {
 -	case PE_SIZE_PTE:
 -		rc = __dax_dev_pte_fault(dax_dev, vmf);
 -		break;
 -	case PE_SIZE_PMD:
 -		rc = __dax_dev_pmd_fault(dax_dev, vmf);
 -		break;
 -	case PE_SIZE_PUD:
 -		rc = __dax_dev_pud_fault(dax_dev, vmf);
 -		break;
 -	default:
 -		rc = VM_FAULT_SIGBUS;
 -	}
 -	srcu_read_unlock(&dax_srcu, id);
 +	rcu_read_lock();
 +	rc = __dax_dev_pmd_fault(dax_dev, vma, addr, pmd, flags);
 +	rcu_read_unlock();
  
  	return rc;
  }
* Unmerged path drivers/dax/dax.c
