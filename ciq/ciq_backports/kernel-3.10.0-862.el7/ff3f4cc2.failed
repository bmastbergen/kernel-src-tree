virtchnl: finish conversion to virtchnl interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit ff3f4cc267f6f39c2fc525c8918c929809defbfa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ff3f4cc2.failed

This patch implements the complete version of the virtchnl.h file
with final renames, and fixes the related code in i40e and i40evf.

It also expands comments, and adds details on the usage of
certain fields.

In addition, due to the changes a couple of casts are needed
to prevent errors found by sparse after renaming some fields.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit ff3f4cc267f6f39c2fc525c8918c929809defbfa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
#	drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
#	drivers/net/ethernet/intel/i40evf/i40evf.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index f469a3d68beb,352d9d2ef3d2..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -76,8 -76,8 +76,13 @@@ static void i40e_vc_notify_vf_link_stat
  	struct i40e_link_status *ls = &pf->hw.phy.link_info;
  	int abs_vf_id = vf->vf_id + (int)hw->func_caps.vf_base_id;
  
++<<<<<<< HEAD
 +	pfe.event = I40E_VIRTCHNL_EVENT_LINK_CHANGE;
 +	pfe.severity = I40E_PF_EVENT_SEVERITY_INFO;
++=======
+ 	pfe.event = VIRTCHNL_EVENT_LINK_CHANGE;
+ 	pfe.severity = PF_EVENT_SEVERITY_INFO;
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface)
  	if (vf->link_forced) {
  		pfe.event_data.link_event.link_status = vf->link_up;
  		pfe.event_data.link_event.link_speed =
@@@ -85,9 -85,10 +90,10 @@@
  	} else {
  		pfe.event_data.link_event.link_status =
  			ls->link_info & I40E_AQ_LINK_UP;
- 		pfe.event_data.link_event.link_speed = ls->link_speed;
+ 		pfe.event_data.link_event.link_speed =
+ 			(enum virtchnl_link_speed)ls->link_speed;
  	}
 -	i40e_aq_send_msg_to_vf(hw, abs_vf_id, VIRTCHNL_OP_EVENT,
 +	i40e_aq_send_msg_to_vf(hw, abs_vf_id, I40E_VIRTCHNL_OP_EVENT,
  			       0, (u8 *)&pfe, sizeof(pfe), NULL);
  }
  
@@@ -113,12 -114,12 +119,19 @@@ void i40e_vc_notify_link_state(struct i
   **/
  void i40e_vc_notify_reset(struct i40e_pf *pf)
  {
 -	struct virtchnl_pf_event pfe;
 -
 +	struct i40e_virtchnl_pf_event pfe;
 +
++<<<<<<< HEAD
 +	pfe.event = I40E_VIRTCHNL_EVENT_RESET_IMPENDING;
 +	pfe.severity = I40E_PF_EVENT_SEVERITY_CERTAIN_DOOM;
 +	i40e_vc_vf_broadcast(pf, I40E_VIRTCHNL_OP_EVENT, 0,
 +			     (u8 *)&pfe, sizeof(struct i40e_virtchnl_pf_event));
++=======
+ 	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
+ 	pfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;
+ 	i40e_vc_vf_broadcast(pf, VIRTCHNL_OP_EVENT, 0,
+ 			     (u8 *)&pfe, sizeof(struct virtchnl_pf_event));
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface)
  }
  
  /**
@@@ -143,11 -144,11 +156,17 @@@ void i40e_vc_notify_vf_reset(struct i40
  
  	abs_vf_id = vf->vf_id + (int)vf->pf->hw.func_caps.vf_base_id;
  
++<<<<<<< HEAD
 +	pfe.event = I40E_VIRTCHNL_EVENT_RESET_IMPENDING;
 +	pfe.severity = I40E_PF_EVENT_SEVERITY_CERTAIN_DOOM;
 +	i40e_aq_send_msg_to_vf(&vf->pf->hw, abs_vf_id, I40E_VIRTCHNL_OP_EVENT,
++=======
+ 	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
+ 	pfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;
+ 	i40e_aq_send_msg_to_vf(&vf->pf->hw, abs_vf_id, VIRTCHNL_OP_EVENT,
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface)
  			       0, (u8 *)&pfe,
 -			       sizeof(struct virtchnl_pf_event), NULL);
 +			       sizeof(struct i40e_virtchnl_pf_event), NULL);
  }
  /***********************misc routines*****************************/
  
@@@ -3167,8 -3241,8 +3186,13 @@@ int i40e_ndo_set_vf_link_state(struct n
  	vf = &pf->vf[vf_id];
  	abs_vf_id = vf->vf_id + hw->func_caps.vf_base_id;
  
++<<<<<<< HEAD
 +	pfe.event = I40E_VIRTCHNL_EVENT_LINK_CHANGE;
 +	pfe.severity = I40E_PF_EVENT_SEVERITY_INFO;
++=======
+ 	pfe.event = VIRTCHNL_EVENT_LINK_CHANGE;
+ 	pfe.severity = PF_EVENT_SEVERITY_INFO;
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface)
  
  	switch (link) {
  	case IFLA_VF_LINK_STATE_AUTO:
diff --cc drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
index 5770352322ef,6c6fbb492b5d..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
@@@ -43,60 -43,106 +43,143 @@@
   * have a maximum of sixteen queues for all of its VSIs.
   *
   * The PF is required to return a status code in v_retval for all messages
-  * except RESET_VF, which does not require any response. The return value is of
-  * i40e_status_code type, defined in the i40e_type.h.
+  * except RESET_VF, which does not require any response. The return value
+  * is of status_code type, defined in the shared type.h.
   *
-  * In general, VF driver initialization should roughly follow the order of these
-  * opcodes. The VF driver must first validate the API version of the PF driver,
-  * then request a reset, then get resources, then configure queues and
-  * interrupts. After these operations are complete, the VF driver may start
-  * its queues, optionally add MAC and VLAN filters, and process traffic.
+  * In general, VF driver initialization should roughly follow the order of
+  * these opcodes. The VF driver must first validate the API version of the
+  * PF driver, then request a reset, then get resources, then configure
+  * queues and interrupts. After these operations are complete, the VF
+  * driver may start its queues, optionally add MAC and VLAN filters, and
+  * process traffic.
   */
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
++=======
+ /* START GENERIC DEFINES
+  * Need to ensure the following enums and defines hold the same meaning and
+  * value in current and future projects
+  */
+ 
+ /* Error Codes */
+ enum virtchnl_status_code {
+ 	VIRTCHNL_STATUS_SUCCESS				= 0,
+ 	VIRTCHNL_ERR_PARAM				= -5,
+ 	VIRTCHNL_STATUS_ERR_OPCODE_MISMATCH		= -38,
+ 	VIRTCHNL_STATUS_ERR_CQP_COMPL_ERROR		= -39,
+ 	VIRTCHNL_STATUS_ERR_INVALID_VF_ID		= -40,
+ 	VIRTCHNL_STATUS_NOT_SUPPORTED			= -64,
+ };
+ 
+ #define VIRTCHNL_LINK_SPEED_100MB_SHIFT		0x1
+ #define VIRTCHNL_LINK_SPEED_1000MB_SHIFT	0x2
+ #define VIRTCHNL_LINK_SPEED_10GB_SHIFT		0x3
+ #define VIRTCHNL_LINK_SPEED_40GB_SHIFT		0x4
+ #define VIRTCHNL_LINK_SPEED_20GB_SHIFT		0x5
+ #define VIRTCHNL_LINK_SPEED_25GB_SHIFT		0x6
+ 
+ enum virtchnl_link_speed {
+ 	VIRTCHNL_LINK_SPEED_UNKNOWN	= 0,
+ 	VIRTCHNL_LINK_SPEED_100MB	= BIT(VIRTCHNL_LINK_SPEED_100MB_SHIFT),
+ 	VIRTCHNL_LINK_SPEED_1GB		= BIT(VIRTCHNL_LINK_SPEED_1000MB_SHIFT),
+ 	VIRTCHNL_LINK_SPEED_10GB	= BIT(VIRTCHNL_LINK_SPEED_10GB_SHIFT),
+ 	VIRTCHNL_LINK_SPEED_40GB	= BIT(VIRTCHNL_LINK_SPEED_40GB_SHIFT),
+ 	VIRTCHNL_LINK_SPEED_20GB	= BIT(VIRTCHNL_LINK_SPEED_20GB_SHIFT),
+ 	VIRTCHNL_LINK_SPEED_25GB	= BIT(VIRTCHNL_LINK_SPEED_25GB_SHIFT),
+ };
+ 
+ /* for hsplit_0 field of Rx HMC context */
+ /* deprecated with AVF 1.0 */
+ enum virtchnl_rx_hsplit {
+ 	VIRTCHNL_RX_HSPLIT_NO_SPLIT      = 0,
+ 	VIRTCHNL_RX_HSPLIT_SPLIT_L2      = 1,
+ 	VIRTCHNL_RX_HSPLIT_SPLIT_IP      = 2,
+ 	VIRTCHNL_RX_HSPLIT_SPLIT_TCP_UDP = 4,
+ 	VIRTCHNL_RX_HSPLIT_SPLIT_SCTP    = 8,
+ };
+ 
+ /* END GENERIC DEFINES */
+ 
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
  /* Opcodes for VF-PF communication. These are placed in the v_opcode field
   * of the virtchnl_msg structure.
   */
 -enum virtchnl_ops {
 +enum i40e_virtchnl_ops {
  /* The PF sends status change events to VFs using
 - * the VIRTCHNL_OP_EVENT opcode.
 + * the I40E_VIRTCHNL_OP_EVENT opcode.
   * VFs send requests to the PF using the other ops.
+  * Use of "advanced opcode" features must be negotiated as part of capabilities
+  * exchange and are not considered part of base mode feature set.
   */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +	I40E_VIRTCHNL_OP_UNKNOWN = 0,
 +	I40E_VIRTCHNL_OP_VERSION = 1, /* must ALWAYS be 1 */
 +	I40E_VIRTCHNL_OP_RESET_VF = 2,
 +	I40E_VIRTCHNL_OP_GET_VF_RESOURCES = 3,
 +	I40E_VIRTCHNL_OP_CONFIG_TX_QUEUE = 4,
 +	I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE = 5,
 +	I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES = 6,
 +	I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP = 7,
 +	I40E_VIRTCHNL_OP_ENABLE_QUEUES = 8,
 +	I40E_VIRTCHNL_OP_DISABLE_QUEUES = 9,
 +	I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS = 10,
 +	I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS = 11,
 +	I40E_VIRTCHNL_OP_ADD_VLAN = 12,
 +	I40E_VIRTCHNL_OP_DEL_VLAN = 13,
 +	I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE = 14,
 +	I40E_VIRTCHNL_OP_GET_STATS = 15,
 +	I40E_VIRTCHNL_OP_RSVD = 16,
 +	I40E_VIRTCHNL_OP_EVENT = 17, /* must ALWAYS be 17 */
 +	I40E_VIRTCHNL_OP_IWARP = 20,
 +	I40E_VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP = 21,
 +	I40E_VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP = 22,
 +	I40E_VIRTCHNL_OP_CONFIG_RSS_KEY = 23,
 +	I40E_VIRTCHNL_OP_CONFIG_RSS_LUT = 24,
 +	I40E_VIRTCHNL_OP_GET_RSS_HENA_CAPS = 25,
 +	I40E_VIRTCHNL_OP_SET_RSS_HENA = 26,
 +
++=======
+ 	VIRTCHNL_OP_UNKNOWN = 0,
+ 	VIRTCHNL_OP_VERSION = 1, /* must ALWAYS be 1 */
+ 	VIRTCHNL_OP_RESET_VF = 2,
+ 	VIRTCHNL_OP_GET_VF_RESOURCES = 3,
+ 	VIRTCHNL_OP_CONFIG_TX_QUEUE = 4,
+ 	VIRTCHNL_OP_CONFIG_RX_QUEUE = 5,
+ 	VIRTCHNL_OP_CONFIG_VSI_QUEUES = 6,
+ 	VIRTCHNL_OP_CONFIG_IRQ_MAP = 7,
+ 	VIRTCHNL_OP_ENABLE_QUEUES = 8,
+ 	VIRTCHNL_OP_DISABLE_QUEUES = 9,
+ 	VIRTCHNL_OP_ADD_ETH_ADDR = 10,
+ 	VIRTCHNL_OP_DEL_ETH_ADDR = 11,
+ 	VIRTCHNL_OP_ADD_VLAN = 12,
+ 	VIRTCHNL_OP_DEL_VLAN = 13,
+ 	VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE = 14,
+ 	VIRTCHNL_OP_GET_STATS = 15,
+ 	VIRTCHNL_OP_RSVD = 16,
+ 	VIRTCHNL_OP_EVENT = 17, /* must ALWAYS be 17 */
+ 	VIRTCHNL_OP_IWARP = 20, /* advanced opcode */
+ 	VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP = 21, /* advanced opcode */
+ 	VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP = 22, /* advanced opcode */
+ 	VIRTCHNL_OP_CONFIG_RSS_KEY = 23,
+ 	VIRTCHNL_OP_CONFIG_RSS_LUT = 24,
+ 	VIRTCHNL_OP_GET_RSS_HENA_CAPS = 25,
+ 	VIRTCHNL_OP_SET_RSS_HENA = 26,
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
  };
  
  /* Virtual channel message descriptor. This overlays the admin queue
   * descriptor. All other data is passed in external buffers.
   */
  
 -struct virtchnl_msg {
 +struct i40e_virtchnl_msg {
  	u8 pad[8];			 /* AQ flags/opcode/len/retval fields */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +	enum i40e_virtchnl_ops v_opcode; /* avoid confusion with desc->opcode */
 +	i40e_status v_retval;  /* ditto for desc->retval */
++=======
+ 	enum virtchnl_ops v_opcode; /* avoid confusion with desc->opcode */
+ 	enum virtchnl_status_code v_retval;  /* ditto for desc->retval */
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
  	u32 vfid;			 /* used by PF when sending to VF */
  };
  
@@@ -135,38 -184,54 +218,76 @@@ struct i40e_virtchnl_version_info 
   * are cleared.
   */
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +/* I40E_VIRTCHNL_OP_GET_VF_RESOURCES
++=======
+ /* VSI types that use VIRTCHNL interface for VF-PF communication. VSI_SRIOV
+  * vsi_type should always be 6 for backward compatibility. Add other fields
+  * as needed.
+  */
+ enum virtchnl_vsi_type {
+ 	VIRTCHNL_VSI_TYPE_INVALID = 0,
+ 	VIRTCHNL_VSI_SRIOV = 6,
+ };
+ 
+ /* VIRTCHNL_OP_GET_VF_RESOURCES
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
   * Version 1.0 VF sends this request to PF with no parameters
   * Version 1.1 VF sends this request to PF with u32 bitmap of its capabilities
   * PF responds with an indirect message containing
 - * virtchnl_vf_resource and one or more
 - * virtchnl_vsi_resource structures.
 + * i40e_virtchnl_vf_resource and one or more
 + * i40e_virtchnl_vsi_resource structures.
   */
  
 -struct virtchnl_vsi_resource {
 +struct i40e_virtchnl_vsi_resource {
  	u16 vsi_id;
  	u16 num_queue_pairs;
- 	enum i40e_vsi_type vsi_type;
+ 	enum virtchnl_vsi_type vsi_type;
  	u16 qset_handle;
  	u8 default_mac_addr[ETH_ALEN];
  };
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +/* VF offload flags */
 +#define I40E_VIRTCHNL_VF_OFFLOAD_L2		0x00000001
 +#define I40E_VIRTCHNL_VF_OFFLOAD_IWARP		0x00000002
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_AQ		0x00000008
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG	0x00000010
 +#define I40E_VIRTCHNL_VF_OFFLOAD_WB_ON_ITR	0x00000020
 +#define I40E_VIRTCHNL_VF_OFFLOAD_VLAN		0x00010000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RX_POLLING	0x00020000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2	0x00040000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF		0X00080000
 +#define I40E_VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM	0X00100000
 +
 +#define I40E_VF_BASE_MODE_OFFLOADS (I40E_VIRTCHNL_VF_OFFLOAD_L2 | \
 +				    I40E_VIRTCHNL_VF_OFFLOAD_VLAN | \
 +				    I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF)
++=======
+ 
+ /* VF offload flags
+  * VIRTCHNL_VF_OFFLOAD_L2 flag is inclusive of base mode L2 offloads including
+  * TX/RX Checksum offloading and TSO for non-tunnelled packets.
+  */
+ #define VIRTCHNL_VF_OFFLOAD_L2			0x00000001
+ #define VIRTCHNL_VF_OFFLOAD_IWARP		0x00000002
+ #define VIRTCHNL_VF_OFFLOAD_RSVD		0x00000004
+ #define VIRTCHNL_VF_OFFLOAD_RSS_AQ		0x00000008
+ #define VIRTCHNL_VF_OFFLOAD_RSS_REG		0x00000010
+ #define VIRTCHNL_VF_OFFLOAD_WB_ON_ITR		0x00000020
+ #define VIRTCHNL_VF_OFFLOAD_VLAN		0x00010000
+ #define VIRTCHNL_VF_OFFLOAD_RX_POLLING		0x00020000
+ #define VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2	0x00040000
+ #define VIRTCHNL_VF_OFFLOAD_RSS_PF		0X00080000
+ #define VIRTCHNL_VF_OFFLOAD_ENCAP		0X00100000
+ #define VIRTCHNL_VF_OFFLOAD_ENCAP_CSUM		0X00200000
+ #define VIRTCHNL_VF_OFFLOAD_RX_ENCAP_CSUM	0X00400000
+ 
+ #define VF_BASE_MODE_OFFLOADS (VIRTCHNL_VF_OFFLOAD_L2 | \
+ 			       VIRTCHNL_VF_OFFLOAD_VLAN | \
+ 			       VIRTCHNL_VF_OFFLOAD_RSS_PF)
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
  
 -struct virtchnl_vf_resource {
 +struct i40e_virtchnl_vf_resource {
  	u16 num_vsis;
  	u16 num_queue_pairs;
  	u16 max_vectors;
@@@ -190,14 -255,14 +311,14 @@@ struct i40e_virtchnl_txq_info 
  	u16 vsi_id;
  	u16 queue_id;
  	u16 ring_len;		/* number of descriptors, multiple of 8 */
- 	u16 headwb_enabled;
+ 	u16 headwb_enabled; /* deprecated with AVF 1.0 */
  	u64 dma_ring_addr;
- 	u64 dma_headwb_addr;
+ 	u64 dma_headwb_addr; /* deprecated with AVF 1.0 */
  };
  
 -/* VIRTCHNL_OP_CONFIG_RX_QUEUE
 +/* I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE
   * VF sends this message to set up parameters for one RX queue.
 - * External data buffer contains one instance of virtchnl_rxq_info.
 + * External data buffer contains one instance of i40e_virtchnl_rxq_info.
   * PF configures requested queue and returns a status code.
   */
  
@@@ -211,10 -276,10 +332,10 @@@ struct i40e_virtchnl_rxq_info 
  	u32 databuffer_size;
  	u32 max_pkt_size;
  	u64 dma_ring_addr;
- 	enum i40e_hmc_obj_rx_hsplit_0 rx_split_pos;
+ 	enum virtchnl_rx_hsplit rx_split_pos; /* deprecated with AVF 1.0 */
  };
  
 -/* VIRTCHNL_OP_CONFIG_VSI_QUEUES
 +/* I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
   * VF sends this message to set parameters for all active TX and RX queues
   * associated with the specified VSI.
   * PF configures queues and returns status.
@@@ -322,21 -387,21 +443,21 @@@ struct i40e_virtchnl_promisc_info 
  	u16 flags;
  };
  
- #define I40E_FLAG_VF_UNICAST_PROMISC	0x00000001
- #define I40E_FLAG_VF_MULTICAST_PROMISC	0x00000002
+ #define FLAG_VF_UNICAST_PROMISC	0x00000001
+ #define FLAG_VF_MULTICAST_PROMISC	0x00000002
  
 -/* VIRTCHNL_OP_GET_STATS
 +/* I40E_VIRTCHNL_OP_GET_STATS
   * VF sends this message to request stats for the selected VSI. VF uses
 - * the virtchnl_queue_select struct to specify the VSI. The queue_id
 + * the i40e_virtchnl_queue_select struct to specify the VSI. The queue_id
   * field is ignored by the PF.
   *
-  * PF replies with struct i40e_eth_stats in an external buffer.
+  * PF replies with struct eth_stats in an external buffer.
   */
  
 -/* VIRTCHNL_OP_CONFIG_RSS_KEY
 - * VIRTCHNL_OP_CONFIG_RSS_LUT
 +/* I40E_VIRTCHNL_OP_CONFIG_RSS_KEY
 + * I40E_VIRTCHNL_OP_CONFIG_RSS_LUT
   * VF sends these messages to configure RSS. Only supported if both PF
 - * and VF drivers set the VIRTCHNL_VF_OFFLOAD_RSS_PF bit during
 + * and VF drivers set the I40E_VIRTCHNL_VF_OFFLOAD_RSS_PF bit during
   * configuration negotiation. If this is the case, then the RSS fields in
   * the VF resource struct are valid.
   * Both the key and LUT are initialized to 0 by the PF, meaning that
@@@ -360,9 -425,8 +481,8 @@@ struct i40e_virtchnl_rss_lut 
   * By default, the PF sets these to all possible traffic types that the
   * hardware supports. The VF can query this value if it wants to change the
   * traffic types that are hashed by the hardware.
-  * Traffic types are defined in the i40e_filter_pctype enum in i40e_type.h
   */
 -struct virtchnl_rss_hena {
 +struct i40e_virtchnl_rss_hena {
  	u64 hena;
  };
  
@@@ -371,20 -435,21 +491,21 @@@
   * No direct response is expected from the VF, though it may generate other
   * messages in response to this one.
   */
 -enum virtchnl_event_codes {
 -	VIRTCHNL_EVENT_UNKNOWN = 0,
 -	VIRTCHNL_EVENT_LINK_CHANGE,
 -	VIRTCHNL_EVENT_RESET_IMPENDING,
 -	VIRTCHNL_EVENT_PF_DRIVER_CLOSE,
 +enum i40e_virtchnl_event_codes {
 +	I40E_VIRTCHNL_EVENT_UNKNOWN = 0,
 +	I40E_VIRTCHNL_EVENT_LINK_CHANGE,
 +	I40E_VIRTCHNL_EVENT_RESET_IMPENDING,
 +	I40E_VIRTCHNL_EVENT_PF_DRIVER_CLOSE,
  };
- #define I40E_PF_EVENT_SEVERITY_INFO		0
- #define I40E_PF_EVENT_SEVERITY_CERTAIN_DOOM	255
+ 
+ #define PF_EVENT_SEVERITY_INFO		0
+ #define PF_EVENT_SEVERITY_CERTAIN_DOOM	255
  
 -struct virtchnl_pf_event {
 -	enum virtchnl_event_codes event;
 +struct i40e_virtchnl_pf_event {
 +	enum i40e_virtchnl_event_codes event;
  	union {
  		struct {
- 			enum i40e_aq_link_speed link_speed;
+ 			enum virtchnl_link_speed link_speed;
  			bool link_status;
  		} link_event;
  	} event_data;
@@@ -404,14 -469,7 +525,18 @@@
   * PF configures interrupt mapping and returns status.
   */
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +/* HW does not define a type value for AEQ; only for RX/TX and CEQ.
 + * In order for us to keep the interface simple, SW will define a
 + * unique type value for AEQ.
 + */
 +#define I40E_QUEUE_TYPE_PE_AEQ  0x80
 +#define I40E_QUEUE_INVALID_IDX  0xFFFF
 +
 +struct i40e_virtchnl_iwarp_qv_info {
++=======
+ struct virtchnl_iwarp_qv_info {
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
  	u32 v_idx; /* msix_vector */
  	u16 ceq_idx;
  	u16 aeq_idx;
@@@ -435,11 -492,10 +559,18 @@@ struct i40e_virtchnl_iwarp_qvlist_info 
   * is in a reset state, it will return DEADBEEF, which, when masked
   * will result in 3.
   */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
 +enum i40e_vfr_states {
 +	I40E_VFR_INPROGRESS = 0,
 +	I40E_VFR_COMPLETED,
 +	I40E_VFR_VFACTIVE,
 +	I40E_VFR_UNKNOWN,
++=======
+ enum virtchnl_vfr_states {
+ 	VIRTCHNL_VFR_INPROGRESS = 0,
+ 	VIRTCHNL_VFR_COMPLETED,
+ 	VIRTCHNL_VFR_VFACTIVE,
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface):include/linux/avf/virtchnl.h
  };
  
 -#endif /* _VIRTCHNL_H_ */
 +#endif /* _I40E_VIRTCHNL_H_ */
diff --cc drivers/net/ethernet/intel/i40evf/i40evf.h
index 1a29de1e6baa,6cc92089fecb..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@@ -262,11 -263,11 +262,16 @@@ struct i40evf_adapter 
  	struct work_struct watchdog_task;
  	bool netdev_registered;
  	bool link_up;
++<<<<<<< HEAD
 +	enum i40e_aq_link_speed link_speed;
 +	enum i40e_virtchnl_ops current_op;
++=======
+ 	enum virtchnl_link_speed link_speed;
+ 	enum virtchnl_ops current_op;
++>>>>>>> ff3f4cc267f6 (virtchnl: finish conversion to virtchnl interface)
  #define CLIENT_ALLOWED(_a) ((_a)->vf_res ? \
  			    (_a)->vf_res->vf_offload_flags & \
 -				VIRTCHNL_VF_OFFLOAD_IWARP : \
 +				I40E_VIRTCHNL_VF_OFFLOAD_IWARP : \
  			    0)
  #define CLIENT_ENABLED(_a) ((_a)->cinst)
  /* RSS by the PF should be preferred over RSS via other methods. */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_common.c b/drivers/net/ethernet/intel/i40evf/i40e_common.c
index 6729624fda5b..42286dc39dfd 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_common.c
@@ -1107,7 +1107,7 @@ void i40e_vf_parse_hw_config(struct i40e_hw *hw,
 			   I40E_VIRTCHNL_VF_OFFLOAD_L2;
 	hw->dev_caps.fcoe = 0;
 	for (i = 0; i < msg->num_vsis; i++) {
-		if (vsi_res->vsi_type == I40E_VSI_SRIOV) {
+		if (vsi_res->vsi_type == VIRTCHNL_VSI_SRIOV) {
 			ether_addr_copy(hw->mac.perm_addr,
 					vsi_res->default_mac_addr);
 			ether_addr_copy(hw->mac.addr,
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf.h
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_main.c b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 92233e4beca5..ff900ac91115 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@ -1680,13 +1680,13 @@ static void i40evf_watchdog_task(struct work_struct *work)
 	}
 
 	if (adapter->aq_required & I40EVF_FLAG_AQ_REQUEST_PROMISC) {
-		i40evf_set_promiscuous(adapter, I40E_FLAG_VF_UNICAST_PROMISC |
-				       I40E_FLAG_VF_MULTICAST_PROMISC);
+		i40evf_set_promiscuous(adapter, FLAG_VF_UNICAST_PROMISC |
+				       FLAG_VF_MULTICAST_PROMISC);
 		goto watchdog_done;
 	}
 
 	if (adapter->aq_required & I40EVF_FLAG_AQ_REQUEST_ALLMULTI) {
-		i40evf_set_promiscuous(adapter, I40E_FLAG_VF_MULTICAST_PROMISC);
+		i40evf_set_promiscuous(adapter, FLAG_VF_MULTICAST_PROMISC);
 		goto watchdog_done;
 	}
 
@@ -1942,7 +1942,8 @@ static void i40evf_adminq_task(struct work_struct *work)
 			break; /* No event to process or error cleaning ARQ */
 
 		i40evf_virtchnl_completion(adapter, v_msg->v_opcode,
-					   v_msg->v_retval, event.msg_buf,
+					   (i40e_status)v_msg->v_retval,
+					   event.msg_buf,
 					   event.msg_len);
 		if (pending != 0)
 			memset(event.msg_buf, 0, I40EVF_MAX_AQ_BUF_SIZE);
@@ -2385,7 +2386,7 @@ int i40evf_process_config(struct i40evf_adapter *adapter)
 
 	/* got VF config message back from PF, now we can parse it */
 	for (i = 0; i < vfres->num_vsis; i++) {
-		if (vfres->vsi_res[i].vsi_type == I40E_VSI_SRIOV)
+		if (vfres->vsi_res[i].vsi_type == VIRTCHNL_VSI_SRIOV)
 			adapter->vsi_res = &vfres->vsi_res[i];
 	}
 	if (!adapter->vsi_res) {
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index aec9d82a87bd..02ee1397781a 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@ -654,15 +654,15 @@ void i40evf_set_promiscuous(struct i40evf_adapter *adapter, int flags)
 		return;
 	}
 
-	promisc_all = I40E_FLAG_VF_UNICAST_PROMISC |
-		      I40E_FLAG_VF_MULTICAST_PROMISC;
+	promisc_all = FLAG_VF_UNICAST_PROMISC |
+		      FLAG_VF_MULTICAST_PROMISC;
 	if ((flags & promisc_all) == promisc_all) {
 		adapter->flags |= I40EVF_FLAG_PROMISC_ON;
 		adapter->aq_required &= ~I40EVF_FLAG_AQ_REQUEST_PROMISC;
 		dev_info(&adapter->pdev->dev, "Entering promiscuous mode\n");
 	}
 
-	if (flags & I40E_FLAG_VF_MULTICAST_PROMISC) {
+	if (flags & FLAG_VF_MULTICAST_PROMISC) {
 		adapter->flags |= I40EVF_FLAG_ALLMULTI_ON;
 		adapter->aq_required &= ~I40EVF_FLAG_AQ_REQUEST_ALLMULTI;
 		dev_info(&adapter->pdev->dev, "Entering multicast promiscuous mode\n");
