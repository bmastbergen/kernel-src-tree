s390/vmem: simplify vmem code for read-only mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] vmem: simplify vmem code for read-only mappings (Hendrik Brueckner) [1489742]
Rebuild_FUZZ: 94.95%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit bab247ff5f669216e3ed2f9a4034c540187e874c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/bab247ff.failed

For the kernel identity mapping map everything read-writeable and
subsequently call set_memory_ro() to make the ro section read-only.
This simplifies the code a lot.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit bab247ff5f669216e3ed2f9a4034c540187e874c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/mm/vmem.c
diff --cc arch/s390/mm/vmem.c
index c109b6bb46f8,b200f976c36b..000000000000
--- a/arch/s390/mm/vmem.c
+++ b/arch/s390/mm/vmem.c
@@@ -10,6 -10,8 +10,11 @@@
  #include <linux/list.h>
  #include <linux/hugetlb.h>
  #include <linux/slab.h>
++<<<<<<< HEAD
++=======
+ #include <linux/memblock.h>
+ #include <asm/cacheflush.h>
++>>>>>>> bab247ff5f66 (s390/vmem: simplify vmem code for read-only mappings)
  #include <asm/pgalloc.h>
  #include <asm/pgtable.h>
  #include <asm/setup.h>
@@@ -98,12 -97,10 +103,18 @@@ static int vmem_add_mem(unsigned long s
  			pgd_populate(&init_mm, pg_dir, pu_dir);
  		}
  		pu_dir = pud_offset(pg_dir, address);
 +#if defined(CONFIG_64BIT) && !defined(CONFIG_DEBUG_PAGEALLOC)
  		if (MACHINE_HAS_EDAT2 && pud_none(*pu_dir) && address &&
++<<<<<<< HEAD
 +		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end)) {
 +			pud_val(*pu_dir) = __pa(address) |
 +				_REGION_ENTRY_TYPE_R3 | _REGION3_ENTRY_LARGE |
 +				(ro ? _REGION_ENTRY_PROTECT : 0);
++=======
+ 		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end) &&
+ 		     !debug_pagealloc_enabled()) {
+ 			pud_val(*pu_dir) = address | pgprot_val(REGION3_KERNEL);
++>>>>>>> bab247ff5f66 (s390/vmem: simplify vmem code for read-only mappings)
  			address += PUD_SIZE;
  			continue;
  		}
@@@ -115,13 -111,10 +126,19 @@@
  			pud_populate(&init_mm, pu_dir, pm_dir);
  		}
  		pm_dir = pmd_offset(pu_dir, address);
 +#if defined(CONFIG_64BIT) && !defined(CONFIG_DEBUG_PAGEALLOC)
  		if (MACHINE_HAS_EDAT1 && pmd_none(*pm_dir) && address &&
++<<<<<<< HEAD
 +		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end)) {
 +			pmd_val(*pm_dir) = __pa(address) |
 +				_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE |
 +				_SEGMENT_ENTRY_YOUNG |
 +				(ro ? _SEGMENT_ENTRY_PROTECT : 0);
++=======
+ 		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end) &&
+ 		    !debug_pagealloc_enabled()) {
+ 			pmd_val(*pm_dir) = address | pgprot_val(SEGMENT_KERNEL);
++>>>>>>> bab247ff5f66 (s390/vmem: simplify vmem code for read-only mappings)
  			address += PMD_SIZE;
  			continue;
  		}
@@@ -134,8 -126,7 +151,12 @@@
  		}
  
  		pt_dir = pte_offset_kernel(pm_dir, address);
++<<<<<<< HEAD
 +		pte_val(*pt_dir) = __pa(address) |
 +			pgprot_val(ro ? PAGE_KERNEL_RO : PAGE_KERNEL);
++=======
+ 		pte_val(*pt_dir) = address |  pgprot_val(PAGE_KERNEL);
++>>>>>>> bab247ff5f66 (s390/vmem: simplify vmem code for read-only mappings)
  		address += PAGE_SIZE;
  	}
  	ret = 0;
@@@ -375,32 -358,13 +396,42 @@@ out
  void __init vmem_map_init(void)
  {
  	unsigned long ro_start, ro_end;
++<<<<<<< HEAD
 +	unsigned long start, end;
 +	int i;
++=======
+ 	struct memblock_region *reg;
++>>>>>>> bab247ff5f66 (s390/vmem: simplify vmem code for read-only mappings)
  
+ 	for_each_memblock(memory, reg)
+ 		vmem_add_mem(reg->base, reg->size);
  	ro_start = PFN_ALIGN((unsigned long)&_stext);
  	ro_end = (unsigned long)&_eshared & PAGE_MASK;
++<<<<<<< HEAD
 +	for (i = 0; i < MEMORY_CHUNKS; i++) {
 +		if (!memory_chunk[i].size)
 +			continue;
 +		start = memory_chunk[i].addr;
 +		end = memory_chunk[i].addr + memory_chunk[i].size;
 +		if (start >= ro_end || end <= ro_start)
 +			vmem_add_mem(start, end - start, 0);
 +		else if (start >= ro_start && end <= ro_end)
 +			vmem_add_mem(start, end - start, 1);
 +		else if (start >= ro_start) {
 +			vmem_add_mem(start, ro_end - start, 1);
 +			vmem_add_mem(ro_end, end - ro_end, 0);
 +		} else if (end < ro_end) {
 +			vmem_add_mem(start, ro_start - start, 0);
 +			vmem_add_mem(ro_start, end - ro_start, 1);
 +		} else {
 +			vmem_add_mem(start, ro_start - start, 0);
 +			vmem_add_mem(ro_start, ro_end - ro_start, 1);
 +			vmem_add_mem(ro_end, end - ro_end, 0);
 +		}
 +	}
++=======
+ 	set_memory_ro(ro_start, (ro_end - ro_start) >> PAGE_SHIFT);
++>>>>>>> bab247ff5f66 (s390/vmem: simplify vmem code for read-only mappings)
  }
  
  /*
* Unmerged path arch/s390/mm/vmem.c
