IB/core: Enforce security on management datagrams

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Daniel Jurgens <danielj@mellanox.com>
commit 47a2b338fe63200d716d2e24131cdb49f17c77da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/47a2b338.failed

Allocate and free a security context when creating and destroying a MAD
agent.  This context is used for controlling access to PKeys and sending
and receiving SMPs.

When sending or receiving a MAD check that the agent has permission to
access the PKey for the Subnet Prefix of the port.

During MAD and snoop agent registration for SMI QPs check that the
calling process has permission to access the manage the subnet  and
register a callback with the LSM to be notified of policy changes. When
notificaiton of a policy change occurs recheck permission and set a flag
indicating sending and receiving SMPs is allowed.

When sending and receiving MADs check that the agent has access to the
SMI if it's on an SMI QP.  Because security policy can change it's
possible permission was allowed when creating the agent, but no longer
is.

	Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
	Acked-by: Doug Ledford <dledford@redhat.com>
[PM: remove the LSM hook init code]
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 47a2b338fe63200d716d2e24131cdb49f17c77da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/core_priv.h
#	drivers/infiniband/core/security.c
#	include/linux/lsm_hooks.h
#	include/linux/security.h
#	security/security.c
diff --cc drivers/infiniband/core/core_priv.h
index b75b68758746,06645272c784..000000000000
--- a/drivers/infiniband/core/core_priv.h
+++ b/drivers/infiniband/core/core_priv.h
@@@ -35,9 -35,20 +35,11 @@@
  
  #include <linux/list.h>
  #include <linux/spinlock.h>
 -#include <linux/cgroup_rdma.h>
  
  #include <rdma/ib_verbs.h>
+ #include <rdma/ib_mad.h>
+ #include "mad_priv.h"
  
 -struct pkey_index_qp_list {
 -	struct list_head    pkey_index_list;
 -	u16                 pkey_index;
 -	/* Lock to hold while iterating the qp_list. */
 -	spinlock_t          qp_list_lock;
 -	struct list_head    qp_list;
 -};
 -
  #if IS_ENABLED(CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS)
  int cma_configfs_init(void);
  void cma_configfs_exit(void);
@@@ -159,4 -189,106 +161,109 @@@ int ib_nl_handle_ip_res_resp(struct sk_
  int ib_get_cached_subnet_prefix(struct ib_device *device,
  				u8                port_num,
  				u64              *sn_pfx);
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_SECURITY_INFINIBAND
+ int ib_security_pkey_access(struct ib_device *dev,
+ 			    u8 port_num,
+ 			    u16 pkey_index,
+ 			    void *sec);
+ 
+ void ib_security_destroy_port_pkey_list(struct ib_device *device);
+ 
+ void ib_security_cache_change(struct ib_device *device,
+ 			      u8 port_num,
+ 			      u64 subnet_prefix);
+ 
+ int ib_security_modify_qp(struct ib_qp *qp,
+ 			  struct ib_qp_attr *qp_attr,
+ 			  int qp_attr_mask,
+ 			  struct ib_udata *udata);
+ 
+ int ib_create_qp_security(struct ib_qp *qp, struct ib_device *dev);
+ void ib_destroy_qp_security_begin(struct ib_qp_security *sec);
+ void ib_destroy_qp_security_abort(struct ib_qp_security *sec);
+ void ib_destroy_qp_security_end(struct ib_qp_security *sec);
+ int ib_open_shared_qp_security(struct ib_qp *qp, struct ib_device *dev);
+ void ib_close_shared_qp_security(struct ib_qp_security *sec);
+ int ib_mad_agent_security_setup(struct ib_mad_agent *agent,
+ 				enum ib_qp_type qp_type);
+ void ib_mad_agent_security_cleanup(struct ib_mad_agent *agent);
+ int ib_mad_enforce_security(struct ib_mad_agent_private *map, u16 pkey_index);
+ #else
+ static inline int ib_security_pkey_access(struct ib_device *dev,
+ 					  u8 port_num,
+ 					  u16 pkey_index,
+ 					  void *sec)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_security_destroy_port_pkey_list(struct ib_device *device)
+ {
+ }
+ 
+ static inline void ib_security_cache_change(struct ib_device *device,
+ 					    u8 port_num,
+ 					    u64 subnet_prefix)
+ {
+ }
+ 
+ static inline int ib_security_modify_qp(struct ib_qp *qp,
+ 					struct ib_qp_attr *qp_attr,
+ 					int qp_attr_mask,
+ 					struct ib_udata *udata)
+ {
+ 	return qp->device->modify_qp(qp->real_qp,
+ 				     qp_attr,
+ 				     qp_attr_mask,
+ 				     udata);
+ }
+ 
+ static inline int ib_create_qp_security(struct ib_qp *qp,
+ 					struct ib_device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_destroy_qp_security_begin(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline void ib_destroy_qp_security_abort(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline void ib_destroy_qp_security_end(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline int ib_open_shared_qp_security(struct ib_qp *qp,
+ 					     struct ib_device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_close_shared_qp_security(struct ib_qp_security *sec)
+ {
+ }
+ 
+ static inline int ib_mad_agent_security_setup(struct ib_mad_agent *agent,
+ 					      enum ib_qp_type qp_type)
+ {
+ 	return 0;
+ }
+ 
+ static inline void ib_mad_agent_security_cleanup(struct ib_mad_agent *agent)
+ {
+ }
+ 
+ static inline int ib_mad_enforce_security(struct ib_mad_agent_private *map,
+ 					  u16 pkey_index)
+ {
+ 	return 0;
+ }
+ #endif
++>>>>>>> 47a2b338fe63 (IB/core: Enforce security on management datagrams)
  #endif /* _CORE_PRIV_H */
diff --cc include/linux/security.h
index dfc8642094cf,549cb828a888..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -2915,16 -1428,38 +2915,45 @@@ static inline int security_tun_dev_open
  {
  	return 0;
  }
 +
 +static inline void security_skb_owned_by(struct sk_buff *skb, struct sock *sk)
 +{
 +}
 +
  #endif	/* CONFIG_SECURITY_NETWORK */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SECURITY_INFINIBAND
+ int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey);
+ int security_ib_endport_manage_subnet(void *sec, const char *name, u8 port_num);
+ int security_ib_alloc_security(void **sec);
+ void security_ib_free_security(void *sec);
+ #else	/* CONFIG_SECURITY_INFINIBAND */
+ static inline int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)
+ {
+ 	return 0;
+ }
+ 
+ static inline int security_ib_endport_manage_subnet(void *sec, const char *dev_name, u8 port_num)
+ {
+ 	return 0;
+ }
+ 
+ static inline int security_ib_alloc_security(void **sec)
+ {
+ 	return 0;
+ }
+ 
+ static inline void security_ib_free_security(void *sec)
+ {
+ }
+ #endif	/* CONFIG_SECURITY_INFINIBAND */
+ 
++>>>>>>> 47a2b338fe63 (IB/core: Enforce security on management datagrams)
  #ifdef CONFIG_SECURITY_NETWORK_XFRM
  
 -int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,
 -			       struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp);
 +int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx);
  int security_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctxp);
  void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx);
  int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx);
diff --cc security/security.c
index 576b8827705a,714433e3e9a2..000000000000
--- a/security/security.c
+++ b/security/security.c
@@@ -1358,18 -1534,42 +1358,48 @@@ int security_tun_dev_open(void *securit
  }
  EXPORT_SYMBOL(security_tun_dev_open);
  
 +void security_skb_owned_by(struct sk_buff *skb, struct sock *sk)
 +{
 +	security_ops->skb_owned_by(skb, sk);
 +}
 +
  #endif	/* CONFIG_SECURITY_NETWORK */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SECURITY_INFINIBAND
+ 
+ int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)
+ {
+ 	return call_int_hook(ib_pkey_access, 0, sec, subnet_prefix, pkey);
+ }
+ EXPORT_SYMBOL(security_ib_pkey_access);
+ 
+ int security_ib_endport_manage_subnet(void *sec, const char *dev_name, u8 port_num)
+ {
+ 	return call_int_hook(ib_endport_manage_subnet, 0, sec, dev_name, port_num);
+ }
+ EXPORT_SYMBOL(security_ib_endport_manage_subnet);
+ 
+ int security_ib_alloc_security(void **sec)
+ {
+ 	return call_int_hook(ib_alloc_security, 0, sec);
+ }
+ EXPORT_SYMBOL(security_ib_alloc_security);
+ 
+ void security_ib_free_security(void *sec)
+ {
+ 	call_void_hook(ib_free_security, sec);
+ }
+ EXPORT_SYMBOL(security_ib_free_security);
+ #endif	/* CONFIG_SECURITY_INFINIBAND */
+ 
++>>>>>>> 47a2b338fe63 (IB/core: Enforce security on management datagrams)
  #ifdef CONFIG_SECURITY_NETWORK_XFRM
  
 -int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,
 -			       struct xfrm_user_sec_ctx *sec_ctx,
 -			       gfp_t gfp)
 +int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx)
  {
 -	return call_int_hook(xfrm_policy_alloc_security, 0, ctxp, sec_ctx, gfp);
 +	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx);
  }
  EXPORT_SYMBOL(security_xfrm_policy_alloc);
  
* Unmerged path drivers/infiniband/core/security.c
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path drivers/infiniband/core/core_priv.h
diff --git a/drivers/infiniband/core/mad.c b/drivers/infiniband/core/mad.c
index 8a2ceb4ddaa2..e1c28eda5f06 100644
--- a/drivers/infiniband/core/mad.c
+++ b/drivers/infiniband/core/mad.c
@@ -40,9 +40,11 @@
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/security.h>
 #include <rdma/ib_cache.h>
 
 #include "mad_priv.h"
+#include "core_priv.h"
 #include "mad_rmpp.h"
 #include "smi.h"
 #include "opa_smi.h"
@@ -369,6 +371,12 @@ struct ib_mad_agent *ib_register_mad_agent(struct ib_device *device,
 	atomic_set(&mad_agent_priv->refcount, 1);
 	init_completion(&mad_agent_priv->comp);
 
+	ret2 = ib_mad_agent_security_setup(&mad_agent_priv->agent, qp_type);
+	if (ret2) {
+		ret = ERR_PTR(ret2);
+		goto error4;
+	}
+
 	spin_lock_irqsave(&port_priv->reg_lock, flags);
 	mad_agent_priv->agent.hi_tid = ++ib_mad_client_id;
 
@@ -386,7 +394,7 @@ struct ib_mad_agent *ib_register_mad_agent(struct ib_device *device,
 				if (method) {
 					if (method_in_use(&method,
 							   mad_reg_req))
-						goto error4;
+						goto error5;
 				}
 			}
 			ret2 = add_nonoui_reg_req(mad_reg_req, mad_agent_priv,
@@ -402,14 +410,14 @@ struct ib_mad_agent *ib_register_mad_agent(struct ib_device *device,
 					if (is_vendor_method_in_use(
 							vendor_class,
 							mad_reg_req))
-						goto error4;
+						goto error5;
 				}
 			}
 			ret2 = add_oui_reg_req(mad_reg_req, mad_agent_priv);
 		}
 		if (ret2) {
 			ret = ERR_PTR(ret2);
-			goto error4;
+			goto error5;
 		}
 	}
 
@@ -418,9 +426,10 @@ struct ib_mad_agent *ib_register_mad_agent(struct ib_device *device,
 	spin_unlock_irqrestore(&port_priv->reg_lock, flags);
 
 	return &mad_agent_priv->agent;
-
-error4:
+error5:
 	spin_unlock_irqrestore(&port_priv->reg_lock, flags);
+	ib_mad_agent_security_cleanup(&mad_agent_priv->agent);
+error4:
 	kfree(reg_req);
 error3:
 	kfree(mad_agent_priv);
@@ -491,6 +500,7 @@ struct ib_mad_agent *ib_register_mad_snoop(struct ib_device *device,
 	struct ib_mad_agent *ret;
 	struct ib_mad_snoop_private *mad_snoop_priv;
 	int qpn;
+	int err;
 
 	/* Validate parameters */
 	if ((is_snooping_sends(mad_snoop_flags) && !snoop_handler) ||
@@ -525,17 +535,25 @@ struct ib_mad_agent *ib_register_mad_snoop(struct ib_device *device,
 	mad_snoop_priv->agent.port_num = port_num;
 	mad_snoop_priv->mad_snoop_flags = mad_snoop_flags;
 	init_completion(&mad_snoop_priv->comp);
+
+	err = ib_mad_agent_security_setup(&mad_snoop_priv->agent, qp_type);
+	if (err) {
+		ret = ERR_PTR(err);
+		goto error2;
+	}
+
 	mad_snoop_priv->snoop_index = register_snoop_agent(
 						&port_priv->qp_info[qpn],
 						mad_snoop_priv);
 	if (mad_snoop_priv->snoop_index < 0) {
 		ret = ERR_PTR(mad_snoop_priv->snoop_index);
-		goto error2;
+		goto error3;
 	}
 
 	atomic_set(&mad_snoop_priv->refcount, 1);
 	return &mad_snoop_priv->agent;
-
+error3:
+	ib_mad_agent_security_cleanup(&mad_snoop_priv->agent);
 error2:
 	kfree(mad_snoop_priv);
 error1:
@@ -581,6 +599,8 @@ static void unregister_mad_agent(struct ib_mad_agent_private *mad_agent_priv)
 	deref_mad_agent(mad_agent_priv);
 	wait_for_completion(&mad_agent_priv->comp);
 
+	ib_mad_agent_security_cleanup(&mad_agent_priv->agent);
+
 	kfree(mad_agent_priv->reg_req);
 	kfree(mad_agent_priv);
 }
@@ -599,6 +619,8 @@ static void unregister_mad_snoop(struct ib_mad_snoop_private *mad_snoop_priv)
 	deref_snoop_agent(mad_snoop_priv);
 	wait_for_completion(&mad_snoop_priv->comp);
 
+	ib_mad_agent_security_cleanup(&mad_snoop_priv->agent);
+
 	kfree(mad_snoop_priv);
 }
 
@@ -1215,12 +1237,16 @@ int ib_post_send_mad(struct ib_mad_send_buf *send_buf,
 
 	/* Walk list of send WRs and post each on send list */
 	for (; send_buf; send_buf = next_send_buf) {
-
 		mad_send_wr = container_of(send_buf,
 					   struct ib_mad_send_wr_private,
 					   send_buf);
 		mad_agent_priv = mad_send_wr->mad_agent_priv;
 
+		ret = ib_mad_enforce_security(mad_agent_priv,
+					      mad_send_wr->send_wr.pkey_index);
+		if (ret)
+			goto error;
+
 		if (!send_buf->mad_agent->send_handler ||
 		    (send_buf->timeout_ms &&
 		     !send_buf->mad_agent->recv_handler)) {
@@ -1941,6 +1967,14 @@ static void ib_mad_complete_recv(struct ib_mad_agent_private *mad_agent_priv,
 	struct ib_mad_send_wr_private *mad_send_wr;
 	struct ib_mad_send_wc mad_send_wc;
 	unsigned long flags;
+	int ret;
+
+	ret = ib_mad_enforce_security(mad_agent_priv,
+				      mad_recv_wc->wc->pkey_index);
+	if (ret) {
+		ib_free_recv_mad(mad_recv_wc);
+		deref_mad_agent(mad_agent_priv);
+	}
 
 	INIT_LIST_HEAD(&mad_recv_wc->rmpp_list);
 	list_add(&mad_recv_wc->recv_buf.list, &mad_recv_wc->rmpp_list);
@@ -1998,6 +2032,8 @@ static void ib_mad_complete_recv(struct ib_mad_agent_private *mad_agent_priv,
 						   mad_recv_wc);
 		deref_mad_agent(mad_agent_priv);
 	}
+
+	return;
 }
 
 static enum smi_action handle_ib_smi(const struct ib_mad_port_private *port_priv,
* Unmerged path drivers/infiniband/core/security.c
* Unmerged path include/linux/lsm_hooks.h
* Unmerged path include/linux/security.h
diff --git a/include/rdma/ib_mad.h b/include/rdma/ib_mad.h
index 3d5f5d6031ec..3d677be91da8 100644
--- a/include/rdma/ib_mad.h
+++ b/include/rdma/ib_mad.h
@@ -562,6 +562,10 @@ struct ib_mad_agent {
 	u32			flags;
 	u8			port_num;
 	u8			rmpp_version;
+	void			*security;
+	bool			smp_allowed;
+	bool			lsm_nb_reg;
+	struct notifier_block   lsm_nb;
 };
 
 /**
* Unmerged path security/security.c
