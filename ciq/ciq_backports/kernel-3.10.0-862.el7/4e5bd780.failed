s390/pci: improve error handling during fmb (de)registration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [s390] pci: improve error handling during fmb (de)registration (Hendrik Brueckner) [1486403]
Rebuild_FUZZ: 95.65%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 4e5bd7803bd1e822513d1007bad1527a2ec589b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4e5bd780.failed

Cleanup in zpci_fmb_enable_device when fmb registration fails. Also
don't free the fmb when deregistration fails in zpci_fmb_disable_device
but handle error situations when a function was hot-unplugged.

Also remove the mod_pci helper since it is no longer used.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 4e5bd7803bd1e822513d1007bad1527a2ec589b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
diff --cc arch/s390/pci/pci.c
index 833b01424c9d,6a44a68efb81..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -143,29 -118,24 +143,32 @@@ static int zpci_set_airq(struct zpci_de
  	fib.aisb = (unsigned long) zpci_aisb_iv->vector + (zdev->aisb/64)*8;
  	fib.aisbo = zdev->aisb & 63;
  
 -	return zpci_mod_fc(req, &fib, &status) ? -EIO : 0;
 +	return zpci_mod_fc(req, &fib);
  }
  
 -/* Modify PCI: Unregister adapter interruptions */
 -static int zpci_clear_airq(struct zpci_dev *zdev)
++<<<<<<< HEAD
 +struct mod_pci_args {
 +	u64 base;
 +	u64 limit;
 +	u64 iota;
 +	u64 fmb_addr;
 +};
 +
 +static int mod_pci(struct zpci_dev *zdev, int fn, u8 dmaas, struct mod_pci_args *args)
  {
 -	u64 req = ZPCI_CREATE_REQ(zdev->fh, 0, ZPCI_MOD_FC_DEREG_INT);
 +	u64 req = ZPCI_CREATE_REQ(zdev->fh, dmaas, fn);
  	struct zpci_fib fib = {0};
 -	u8 cc, status;
  
 -	cc = zpci_mod_fc(req, &fib, &status);
 -	if (cc == 3 || (cc == 1 && status == 24))
 -		/* Function already gone or IRQs already deregistered. */
 -		cc = 0;
 +	fib.pba = args->base;
 +	fib.pal = args->limit;
 +	fib.iota = args->iota;
 +	fib.fmb_addr = args->fmb_addr;
  
 -	return cc ? -EIO : 0;
 +	return zpci_mod_fc(req, &fib);
  }
  
++=======
++>>>>>>> 4e5bd7803bd1 (s390/pci: improve error handling during fmb (de)registration)
  /* Modify PCI: Register I/O address translation parameters */
  int zpci_register_ioat(struct zpci_dev *zdev, u8 dmaas,
  		       u64 base, u64 limit, u64 iota)
@@@ -225,15 -204,17 +236,19 @@@ int zpci_fmb_disable_device(struct zpci
  		return -EINVAL;
  
  	/* Function measurement is disabled if fmb address is zero */
- 	rc = mod_pci(zdev, ZPCI_MOD_FC_SET_MEASURE, 0, &args);
+ 	cc = zpci_mod_fc(req, &fib, &status);
+ 	if (cc == 3) /* Function already gone. */
+ 		cc = 0;
  
- 	kmem_cache_free(zdev_fmb_cache, zdev->fmb);
- 	zdev->fmb = NULL;
- 	return rc;
+ 	if (!cc) {
+ 		kmem_cache_free(zdev_fmb_cache, zdev->fmb);
+ 		zdev->fmb = NULL;
+ 	}
+ 	return cc ? -EIO : 0;
  }
  
 +#define ZPCI_PCIAS_CFGSPC	15
 +
  static int zpci_cfg_load(struct zpci_dev *zdev, int offset, u32 *val, u8 len)
  {
  	u64 req = ZPCI_CREATE_REQ(zdev->fh, ZPCI_PCIAS_CFGSPC, len);
* Unmerged path arch/s390/pci/pci.c
