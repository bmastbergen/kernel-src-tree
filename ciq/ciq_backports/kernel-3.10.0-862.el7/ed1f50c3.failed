net: add skb_checksum_setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [net] add skb_checksum_setup (Vitaly Kuznetsov) [1487854]
Rebuild_FUZZ: 89.80%
commit-author Paul Durrant <Paul.Durrant@citrix.com>
commit ed1f50c3a7c1ad1b1b4d584308eab77d57a330f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/ed1f50c3.failed

This patch adds a function to set up the partial checksum offset for IP
packets (and optionally re-calculate the pseudo-header checksum) into the
core network code.
The implementation was previously private and duplicated between xen-netback
and xen-netfront, however it is not xen-specific and is potentially useful
to any network driver.

	Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
	Cc: David Miller <davem@davemloft.net>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Veaceslav Falico <vfalico@redhat.com>
	Cc: Alexander Duyck <alexander.h.duyck@intel.com>
	Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed1f50c3a7c1ad1b1b4d584308eab77d57a330f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/skbuff.c
diff --cc include/linux/skbuff.h
index 7b6fa7405c56,48b760505cb6..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3769,9 -2893,9 +3769,15 @@@ static inline void skb_checksum_none_as
  
  bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);
  
++<<<<<<< HEAD
 +struct sk_buff *skb_checksum_trimmed(struct sk_buff *skb,
 +				     unsigned int transport_len,
 +				     __sum16(*skb_chkf)(struct sk_buff *skb));
++=======
+ int skb_checksum_setup(struct sk_buff *skb, bool recalculate);
+ 
+ u32 __skb_get_poff(const struct sk_buff *skb);
++>>>>>>> ed1f50c3a7c1 (net: add skb_checksum_setup)
  
  /**
   * skb_head_is_locked - Determine if the skb->head is locked down
diff --cc net/core/skbuff.c
index 7ec68a93af9a,15057d29b010..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -3875,91 -3550,277 +3876,365 @@@ bool skb_partial_csum_set(struct sk_buf
  }
  EXPORT_SYMBOL_GPL(skb_partial_csum_set);
  
++<<<<<<< HEAD
 +/**
 + * skb_checksum_maybe_trim - maybe trims the given skb
 + * @skb: the skb to check
 + * @transport_len: the data length beyond the network header
 + *
 + * Checks whether the given skb has data beyond the given transport length.
 + * If so, returns a cloned skb trimmed to this transport length.
 + * Otherwise returns the provided skb. Returns NULL in error cases
 + * (e.g. transport_len exceeds skb length or out-of-memory).
 + *
 + * Caller needs to set the skb transport header and free any returned skb if it
 + * differs from the provided skb.
 + */
 +static struct sk_buff *skb_checksum_maybe_trim(struct sk_buff *skb,
 +					       unsigned int transport_len)
 +{
 +	struct sk_buff *skb_chk;
 +	unsigned int len = skb_transport_offset(skb) + transport_len;
 +	int ret;
 +
 +	if (skb->len < len)
 +		return NULL;
 +	else if (skb->len == len)
 +		return skb;
 +
 +	skb_chk = skb_clone(skb, GFP_ATOMIC);
 +	if (!skb_chk)
 +		return NULL;
 +
 +	ret = pskb_trim_rcsum(skb_chk, len);
 +	if (ret) {
 +		kfree_skb(skb_chk);
 +		return NULL;
 +	}
 +
 +	return skb_chk;
 +}
 +
 +/**
 + * skb_checksum_trimmed - validate checksum of an skb
 + * @skb: the skb to check
 + * @transport_len: the data length beyond the network header
 + * @skb_chkf: checksum function to use
 + *
 + * Applies the given checksum function skb_chkf to the provided skb.
 + * Returns a checked and maybe trimmed skb. Returns NULL on error.
 + *
 + * If the skb has data beyond the given transport length, then a
 + * trimmed & cloned skb is checked and returned.
 + *
 + * Caller needs to set the skb transport header and free any returned skb if it
 + * differs from the provided skb.
 + */
 +struct sk_buff *skb_checksum_trimmed(struct sk_buff *skb,
 +				     unsigned int transport_len,
 +				     __sum16(*skb_chkf)(struct sk_buff *skb))
 +{
 +	struct sk_buff *skb_chk;
 +	unsigned int offset = skb_transport_offset(skb);
 +	__sum16 ret;
 +
 +	skb_chk = skb_checksum_maybe_trim(skb, transport_len);
 +	if (!skb_chk)
 +		goto err;
 +
 +	if (!pskb_may_pull(skb_chk, offset))
 +		goto err;
 +
 +	skb_pull_rcsum(skb_chk, offset);
 +	ret = skb_chkf(skb_chk);
 +	skb_push_rcsum(skb_chk, offset);
 +
 +	if (ret)
 +		goto err;
 +
 +	return skb_chk;
 +
 +err:
 +	if (skb_chk && skb_chk != skb)
 +		kfree_skb(skb_chk);
 +
 +	return NULL;
 +
 +}
 +EXPORT_SYMBOL(skb_checksum_trimmed);
++=======
+ static int skb_maybe_pull_tail(struct sk_buff *skb, unsigned int len,
+ 			       unsigned int max)
+ {
+ 	if (skb_headlen(skb) >= len)
+ 		return 0;
+ 
+ 	/* If we need to pullup then pullup to the max, so we
+ 	 * won't need to do it again.
+ 	 */
+ 	if (max > skb->len)
+ 		max = skb->len;
+ 
+ 	if (__pskb_pull_tail(skb, max - skb_headlen(skb)) == NULL)
+ 		return -ENOMEM;
+ 
+ 	if (skb_headlen(skb) < len)
+ 		return -EPROTO;
+ 
+ 	return 0;
+ }
+ 
+ /* This value should be large enough to cover a tagged ethernet header plus
+  * maximally sized IP and TCP or UDP headers.
+  */
+ #define MAX_IP_HDR_LEN 128
+ 
+ static int skb_checksum_setup_ip(struct sk_buff *skb, bool recalculate)
+ {
+ 	unsigned int off;
+ 	bool fragment;
+ 	int err;
+ 
+ 	fragment = false;
+ 
+ 	err = skb_maybe_pull_tail(skb,
+ 				  sizeof(struct iphdr),
+ 				  MAX_IP_HDR_LEN);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	if (ip_hdr(skb)->frag_off & htons(IP_OFFSET | IP_MF))
+ 		fragment = true;
+ 
+ 	off = ip_hdrlen(skb);
+ 
+ 	err = -EPROTO;
+ 
+ 	if (fragment)
+ 		goto out;
+ 
+ 	switch (ip_hdr(skb)->protocol) {
+ 	case IPPROTO_TCP:
+ 		err = skb_maybe_pull_tail(skb,
+ 					  off + sizeof(struct tcphdr),
+ 					  MAX_IP_HDR_LEN);
+ 		if (err < 0)
+ 			goto out;
+ 
+ 		if (!skb_partial_csum_set(skb, off,
+ 					  offsetof(struct tcphdr, check))) {
+ 			err = -EPROTO;
+ 			goto out;
+ 		}
+ 
+ 		if (recalculate)
+ 			tcp_hdr(skb)->check =
+ 				~csum_tcpudp_magic(ip_hdr(skb)->saddr,
+ 						   ip_hdr(skb)->daddr,
+ 						   skb->len - off,
+ 						   IPPROTO_TCP, 0);
+ 		break;
+ 	case IPPROTO_UDP:
+ 		err = skb_maybe_pull_tail(skb,
+ 					  off + sizeof(struct udphdr),
+ 					  MAX_IP_HDR_LEN);
+ 		if (err < 0)
+ 			goto out;
+ 
+ 		if (!skb_partial_csum_set(skb, off,
+ 					  offsetof(struct udphdr, check))) {
+ 			err = -EPROTO;
+ 			goto out;
+ 		}
+ 
+ 		if (recalculate)
+ 			udp_hdr(skb)->check =
+ 				~csum_tcpudp_magic(ip_hdr(skb)->saddr,
+ 						   ip_hdr(skb)->daddr,
+ 						   skb->len - off,
+ 						   IPPROTO_UDP, 0);
+ 		break;
+ 	default:
+ 		goto out;
+ 	}
+ 
+ 	err = 0;
+ 
+ out:
+ 	return err;
+ }
+ 
+ /* This value should be large enough to cover a tagged ethernet header plus
+  * an IPv6 header, all options, and a maximal TCP or UDP header.
+  */
+ #define MAX_IPV6_HDR_LEN 256
+ 
+ #define OPT_HDR(type, skb, off) \
+ 	(type *)(skb_network_header(skb) + (off))
+ 
+ static int skb_checksum_setup_ipv6(struct sk_buff *skb, bool recalculate)
+ {
+ 	int err;
+ 	u8 nexthdr;
+ 	unsigned int off;
+ 	unsigned int len;
+ 	bool fragment;
+ 	bool done;
+ 
+ 	fragment = false;
+ 	done = false;
+ 
+ 	off = sizeof(struct ipv6hdr);
+ 
+ 	err = skb_maybe_pull_tail(skb, off, MAX_IPV6_HDR_LEN);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	nexthdr = ipv6_hdr(skb)->nexthdr;
+ 
+ 	len = sizeof(struct ipv6hdr) + ntohs(ipv6_hdr(skb)->payload_len);
+ 	while (off <= len && !done) {
+ 		switch (nexthdr) {
+ 		case IPPROTO_DSTOPTS:
+ 		case IPPROTO_HOPOPTS:
+ 		case IPPROTO_ROUTING: {
+ 			struct ipv6_opt_hdr *hp;
+ 
+ 			err = skb_maybe_pull_tail(skb,
+ 						  off +
+ 						  sizeof(struct ipv6_opt_hdr),
+ 						  MAX_IPV6_HDR_LEN);
+ 			if (err < 0)
+ 				goto out;
+ 
+ 			hp = OPT_HDR(struct ipv6_opt_hdr, skb, off);
+ 			nexthdr = hp->nexthdr;
+ 			off += ipv6_optlen(hp);
+ 			break;
+ 		}
+ 		case IPPROTO_AH: {
+ 			struct ip_auth_hdr *hp;
+ 
+ 			err = skb_maybe_pull_tail(skb,
+ 						  off +
+ 						  sizeof(struct ip_auth_hdr),
+ 						  MAX_IPV6_HDR_LEN);
+ 			if (err < 0)
+ 				goto out;
+ 
+ 			hp = OPT_HDR(struct ip_auth_hdr, skb, off);
+ 			nexthdr = hp->nexthdr;
+ 			off += ipv6_authlen(hp);
+ 			break;
+ 		}
+ 		case IPPROTO_FRAGMENT: {
+ 			struct frag_hdr *hp;
+ 
+ 			err = skb_maybe_pull_tail(skb,
+ 						  off +
+ 						  sizeof(struct frag_hdr),
+ 						  MAX_IPV6_HDR_LEN);
+ 			if (err < 0)
+ 				goto out;
+ 
+ 			hp = OPT_HDR(struct frag_hdr, skb, off);
+ 
+ 			if (hp->frag_off & htons(IP6_OFFSET | IP6_MF))
+ 				fragment = true;
+ 
+ 			nexthdr = hp->nexthdr;
+ 			off += sizeof(struct frag_hdr);
+ 			break;
+ 		}
+ 		default:
+ 			done = true;
+ 			break;
+ 		}
+ 	}
+ 
+ 	err = -EPROTO;
+ 
+ 	if (!done || fragment)
+ 		goto out;
+ 
+ 	switch (nexthdr) {
+ 	case IPPROTO_TCP:
+ 		err = skb_maybe_pull_tail(skb,
+ 					  off + sizeof(struct tcphdr),
+ 					  MAX_IPV6_HDR_LEN);
+ 		if (err < 0)
+ 			goto out;
+ 
+ 		if (!skb_partial_csum_set(skb, off,
+ 					  offsetof(struct tcphdr, check))) {
+ 			err = -EPROTO;
+ 			goto out;
+ 		}
+ 
+ 		if (recalculate)
+ 			tcp_hdr(skb)->check =
+ 				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
+ 						 &ipv6_hdr(skb)->daddr,
+ 						 skb->len - off,
+ 						 IPPROTO_TCP, 0);
+ 		break;
+ 	case IPPROTO_UDP:
+ 		err = skb_maybe_pull_tail(skb,
+ 					  off + sizeof(struct udphdr),
+ 					  MAX_IPV6_HDR_LEN);
+ 		if (err < 0)
+ 			goto out;
+ 
+ 		if (!skb_partial_csum_set(skb, off,
+ 					  offsetof(struct udphdr, check))) {
+ 			err = -EPROTO;
+ 			goto out;
+ 		}
+ 
+ 		if (recalculate)
+ 			udp_hdr(skb)->check =
+ 				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
+ 						 &ipv6_hdr(skb)->daddr,
+ 						 skb->len - off,
+ 						 IPPROTO_UDP, 0);
+ 		break;
+ 	default:
+ 		goto out;
+ 	}
+ 
+ 	err = 0;
+ 
+ out:
+ 	return err;
+ }
+ 
+ /**
+  * skb_checksum_setup - set up partial checksum offset
+  * @skb: the skb to set up
+  * @recalculate: if true the pseudo-header checksum will be recalculated
+  */
+ int skb_checksum_setup(struct sk_buff *skb, bool recalculate)
+ {
+ 	int err;
+ 
+ 	switch (skb->protocol) {
+ 	case htons(ETH_P_IP):
+ 		err = skb_checksum_setup_ip(skb, recalculate);
+ 		break;
+ 
+ 	case htons(ETH_P_IPV6):
+ 		err = skb_checksum_setup_ipv6(skb, recalculate);
+ 		break;
+ 
+ 	default:
+ 		err = -EPROTO;
+ 		break;
+ 	}
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL(skb_checksum_setup);
++>>>>>>> ed1f50c3a7c1 (net: add skb_checksum_setup)
  
  void __skb_warn_lro_forwarding(const struct sk_buff *skb)
  {
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/skbuff.c
