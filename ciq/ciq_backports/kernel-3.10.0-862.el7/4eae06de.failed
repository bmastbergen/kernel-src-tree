ovl: lockdep annotate of nested OVL_I(inode)->lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 4eae06de482bf370144704e31f65cd6dfbcebe94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/4eae06de.failed

This fixes a lockdep splat when mounting a nested overlayfs.

Fixes: a015dafcaf5b ("ovl: use ovl_inode mutex to synchronize...")
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 4eae06de482bf370144704e31f65cd6dfbcebe94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index e60c6d748742,03f0ec2b73eb..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -9,10 -9,12 +9,11 @@@
  
  #include <linux/fs.h>
  #include <linux/slab.h>
 -#include <linux/cred.h>
  #include <linux/xattr.h>
 +#include <linux/cred.h>
  #include <linux/posix_acl.h>
 -#include <linux/ratelimit.h>
  #include "overlayfs.h"
+ #include "ovl_entry.h"
  
  int ovl_setattr(struct dentry *dentry, struct iattr *attr)
  {
@@@ -381,7 -388,45 +382,49 @@@ static const struct inode_operations ov
  	.update_time	= ovl_update_time,
  };
  
++<<<<<<< HEAD
 +static void ovl_fill_inode(struct inode *inode, umode_t mode)
++=======
+ /*
+  * It is possible to stack overlayfs instance on top of another
+  * overlayfs instance as lower layer. We need to annonate the
+  * stackable i_mutex locks according to stack level of the super
+  * block instance. An overlayfs instance can never be in stack
+  * depth 0 (there is always a real fs below it).  An overlayfs
+  * inode lock will use the lockdep annotaion ovl_i_mutex_key[depth].
+  *
+  * For example, here is a snip from /proc/lockdep_chains after
+  * dir_iterate of nested overlayfs:
+  *
+  * [...] &ovl_i_mutex_dir_key[depth]   (stack_depth=2)
+  * [...] &ovl_i_mutex_dir_key[depth]#2 (stack_depth=1)
+  * [...] &type->i_mutex_dir_key        (stack_depth=0)
+  */
+ #define OVL_MAX_NESTING FILESYSTEM_MAX_STACK_DEPTH
+ 
+ static inline void ovl_lockdep_annotate_inode_mutex_key(struct inode *inode)
+ {
+ #ifdef CONFIG_LOCKDEP
+ 	static struct lock_class_key ovl_i_mutex_key[OVL_MAX_NESTING];
+ 	static struct lock_class_key ovl_i_mutex_dir_key[OVL_MAX_NESTING];
+ 	static struct lock_class_key ovl_i_lock_key[OVL_MAX_NESTING];
+ 
+ 	int depth = inode->i_sb->s_stack_depth - 1;
+ 
+ 	if (WARN_ON_ONCE(depth < 0 || depth >= OVL_MAX_NESTING))
+ 		depth = 0;
+ 
+ 	if (S_ISDIR(inode->i_mode))
+ 		lockdep_set_class(&inode->i_rwsem, &ovl_i_mutex_dir_key[depth]);
+ 	else
+ 		lockdep_set_class(&inode->i_rwsem, &ovl_i_mutex_key[depth]);
+ 
+ 	lockdep_set_class(&OVL_I(inode)->lock, &ovl_i_lock_key[depth]);
+ #endif
+ }
+ 
+ static void ovl_fill_inode(struct inode *inode, umode_t mode, dev_t rdev)
++>>>>>>> 4eae06de482b (ovl: lockdep annotate of nested OVL_I(inode)->lock)
  {
  	inode->i_ino = get_next_ino();
  	inode->i_mode = mode;
* Unmerged path fs/overlayfs/inode.c
