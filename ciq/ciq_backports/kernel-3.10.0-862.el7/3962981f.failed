netvsc: add rtnl annotations in rndis

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit 3962981f4822aaf284234efd0500041417faea86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/3962981f.failed

The rndis functions are used when changing device state.
Therefore the references from network device to internal state
are protected by RTNL mutex.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3962981f4822aaf284234efd0500041417faea86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/netvsc_drv.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a32d7f1b2505,afb65f753574..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -771,20 -781,12 +771,23 @@@ struct netvsc_device 
  	atomic_t num_outstanding_recvs;
  
  	atomic_t open_cnt;
 +};
  
 -	struct netvsc_channel chan_table[VRSS_CHANNEL_MAX];
++<<<<<<< HEAD
 +static inline struct netvsc_device *
 +net_device_to_netvsc_device(struct net_device *ndev)
 +{
 +	return ((struct net_device_context *)netdev_priv(ndev))->nvdev;
 +}
  
 -	struct rcu_head rcu;
 -};
 +static inline struct netvsc_device *
 +hv_device_to_netvsc_device(struct hv_device *device)
 +{
 +	return net_device_to_netvsc_device(hv_get_drvdata(device));
 +}
  
++=======
++>>>>>>> 3962981f4822 (netvsc: add rtnl annotations in rndis)
  /* NdisInitialize message */
  struct rndis_initialize_request {
  	u32 req_id;
diff --cc drivers/net/hyperv/netvsc.c
index 3170ba757106,0a9d9feedc3f..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -859,10 -830,11 +860,16 @@@ int netvsc_send(struct hv_device *devic
  		struct hv_page_buffer **pb,
  		struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct netvsc_device *net_device;
++=======
+ 	struct netvsc_device *net_device
+ 		= rcu_dereference_rtnl(ndev_ctx->nvdev);
+ 	struct hv_device *device = ndev_ctx->device_ctx;
++>>>>>>> 3962981f4822 (netvsc: add rtnl annotations in rndis)
  	int ret = 0;
 -	struct netvsc_channel *nvchan;
 +	struct vmbus_channel *out_channel;
 +	u16 q_idx = packet->q_idx;
  	u32 pktlen = packet->total_data_buflen, msd_len = 0;
  	unsigned int section_index = NETVSC_INVALID_INDEX;
  	struct multi_send_data *msdp;
diff --cc drivers/net/hyperv/netvsc_drv.c
index d4dc9c189b85,a164981c15f7..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -1541,10 -1540,24 +1541,23 @@@ static int netvsc_probe(struct hv_devic
  	}
  	memcpy(net->dev_addr, device_info.mac_adr, ETH_ALEN);
  
 -	/* hw_features computed in rndis_filter_device_add */
 -	net->features = net->hw_features |
 -		NETIF_F_HIGHDMA | NETIF_F_SG |
 -		NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;
 -	net->vlan_features = net->features;
 -
 +	nvdev = net_device_ctx->nvdev;
  	netif_set_real_num_tx_queues(net, nvdev->num_chn);
  	netif_set_real_num_rx_queues(net, nvdev->num_chn);
++<<<<<<< HEAD
 +	netif_set_gso_max_size(net, NETVSC_GSO_MAX_SIZE);
++=======
+ 	rtnl_unlock();
+ 
+ 	netdev_lockdep_set_classes(net);
+ 
+ 	/* MTU range: 68 - 1500 or 65521 */
+ 	net->min_mtu = NETVSC_MTU_MIN;
+ 	if (nvdev->nvsp_version >= NVSP_PROTOCOL_VERSION_2)
+ 		net->max_mtu = NETVSC_MTU - ETH_HLEN;
+ 	else
+ 		net->max_mtu = ETH_DATA_LEN;
++>>>>>>> 3962981f4822 (netvsc: add rtnl annotations in rndis)
  
  	ret = register_netdev(net);
  	if (ret != 0) {
diff --cc drivers/net/hyperv/rndis_filter.c
index b6bc44dd1f92,e439886f72c1..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -468,7 -478,35 +476,39 @@@ static int rndis_filter_query_device(st
  	query->info_buflen = 0;
  	query->dev_vc_handle = 0;
  
++<<<<<<< HEAD
 +	if (oid == OID_GEN_RECEIVE_SCALE_CAPABILITIES) {
++=======
+ 	if (oid == OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES) {
+ 		struct net_device_context *ndevctx = netdev_priv(dev->ndev);
+ 		struct netvsc_device *nvdev = rtnl_dereference(ndevctx->nvdev);
+ 		struct ndis_offload *hwcaps;
+ 		u32 nvsp_version = nvdev->nvsp_version;
+ 		u8 ndis_rev;
+ 		size_t size;
+ 
+ 		if (nvsp_version >= NVSP_PROTOCOL_VERSION_5) {
+ 			ndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_3;
+ 			size = NDIS_OFFLOAD_SIZE;
+ 		} else if (nvsp_version >= NVSP_PROTOCOL_VERSION_4) {
+ 			ndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_2;
+ 			size = NDIS_OFFLOAD_SIZE_6_1;
+ 		} else {
+ 			ndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_1;
+ 			size = NDIS_OFFLOAD_SIZE_6_0;
+ 		}
+ 
+ 		request->request_msg.msg_len += size;
+ 		query->info_buflen = size;
+ 		hwcaps = (struct ndis_offload *)
+ 			((unsigned long)query + query->info_buf_offset);
+ 
+ 		hwcaps->header.type = NDIS_OBJECT_TYPE_OFFLOAD;
+ 		hwcaps->header.revision = ndis_rev;
+ 		hwcaps->header.size = size;
+ 
+ 	} else if (oid == OID_GEN_RECEIVE_SCALE_CAPABILITIES) {
++>>>>>>> 3962981f4822 (netvsc: add rtnl annotations in rndis)
  		struct ndis_recv_scale_cap *cap;
  
  		request->request_msg.msg_len +=
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/netvsc_drv.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
