lib/radix-tree.c: swapoff tmpfs radix_tree: remember to rcu_read_unlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Hugh Dickins <hughd@google.com>
commit 5f30fc94ca985974fd54de454c7a6070388443db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/5f30fc94.failed

Running fsx on tmpfs with concurrent memhog-swapoff-swapon, lots of

  BUG: sleeping function called from invalid context at kernel/fork.c:606
  in_atomic(): 0, irqs_disabled(): 0, pid: 1394, name: swapoff
  1 lock held by swapoff/1394:
   #0:  (rcu_read_lock){.+.+.+}, at: [<ffffffff812520a1>] radix_tree_locate_item+0x1f/0x2b6

followed by

  ================================================
  [ BUG: lock held when returning to user space! ]
  3.14.0-rc1 #3 Not tainted
  ------------------------------------------------
  swapoff/1394 is leaving the kernel with locks still held!
  1 lock held by swapoff/1394:
   #0:  (rcu_read_lock){.+.+.+}, at: [<ffffffff812520a1>] radix_tree_locate_item+0x1f/0x2b6

after which the system recovered nicely.

Whoops, I long ago forgot the rcu_read_unlock() on one unlikely branch.

Fixes e504f3fdd63d ("tmpfs radix_tree: locate_item to speed up swapoff")

	Signed-off-by: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5f30fc94ca985974fd54de454c7a6070388443db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/radix-tree.c
diff --cc lib/radix-tree.c
index c70755d6a346,bd4a8dfdf0b8..000000000000
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@@ -1216,10 -1252,11 +1216,17 @@@ unsigned long radix_tree_locate_item(st
  		}
  
  		node = indirect_to_ptr(node);
++<<<<<<< HEAD
 +		max_index = radix_tree_maxindex(node->path &
 +						RADIX_TREE_HEIGHT_MASK);
 +		if (cur_index > max_index)
++=======
+ 		max_index = radix_tree_maxindex(node->height);
+ 		if (cur_index > max_index) {
+ 			rcu_read_unlock();
++>>>>>>> 5f30fc94ca98 (lib/radix-tree.c: swapoff tmpfs radix_tree: remember to rcu_read_unlock)
  			break;
+ 		}
  
  		cur_index = __locate(node, item, cur_index, &found_index);
  		rcu_read_unlock();
* Unmerged path lib/radix-tree.c
