net/mlx5: Use underlay QPN from the root name space

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Use underlay QPN from the root name space (Don Dutile) [1456694 1499362]
Rebuild_FUZZ: 95.92%
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 508541146af18e43072e41a31aa62fac2b01aac1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/50854114.failed

Root flow table is dynamically changed by the underlying flow steering
layer, and IPoIB/ULPs have no idea what will be the root flow table in
the future, hence we need a dynamic infrastructure to move Underlay QPs
with the root flow table.

Fixes: b3ba51498bdd ("net/mlx5: Refactor create flow table method to accept underlay QP")
	Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 508541146af18e43072e41a31aa62fac2b01aac1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index f6e3d4bf0928,2fd044b23875..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -886,27 -989,27 +886,39 @@@ void mlx5e_destroy_tir(struct mlx5_core
  		       struct mlx5e_tir *tir);
  int mlx5e_create_mdev_resources(struct mlx5_core_dev *mdev);
  void mlx5e_destroy_mdev_resources(struct mlx5_core_dev *mdev);
 -int mlx5e_refresh_tirs(struct mlx5e_priv *priv, bool enable_uc_lb);
 -
 -/* common netdev helpers */
 -int mlx5e_create_indirect_rqt(struct mlx5e_priv *priv);
 -
 -int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv);
 -void mlx5e_destroy_indirect_tirs(struct mlx5e_priv *priv);
 +int mlx5e_refresh_tirs_self_loopback(struct mlx5_core_dev *mdev,
 +				     bool enable_uc_lb);
 +
 +struct mlx5_eswitch_rep;
 +int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
 +			 struct mlx5_eswitch_rep *rep);
 +void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
 +			    struct mlx5_eswitch_rep *rep);
 +int mlx5e_nic_rep_load(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep);
 +void mlx5e_nic_rep_unload(struct mlx5_eswitch *esw,
 +			  struct mlx5_eswitch_rep *rep);
 +int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 +void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 +int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 +void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 +void mlx5e_update_hw_rep_counters(struct mlx5e_priv *priv);
  
  int mlx5e_create_direct_rqts(struct mlx5e_priv *priv);
 -void mlx5e_destroy_direct_rqts(struct mlx5e_priv *priv);
 +void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
  int mlx5e_create_direct_tirs(struct mlx5e_priv *priv);
  void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv);
++<<<<<<< HEAD
++=======
+ void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
+ 
+ int mlx5e_create_ttc_table(struct mlx5e_priv *priv);
+ void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv);
+ 
+ int mlx5e_create_tis(struct mlx5_core_dev *mdev, int tc,
+ 		     u32 underlay_qpn, u32 *tisn);
+ void mlx5e_destroy_tis(struct mlx5_core_dev *mdev, u32 tisn);
+ 
++>>>>>>> 508541146af1 (net/mlx5: Use underlay QPN from the root name space)
  int mlx5e_create_tises(struct mlx5e_priv *priv);
  void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
  int mlx5e_close(struct net_device *netdev);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 729904c43801,53ed58320a24..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -800,7 -800,7 +800,11 @@@ static void mlx5e_destroy_ttc_table(str
  	mlx5e_destroy_flow_table(&ttc->ft);
  }
  
++<<<<<<< HEAD
 +static int mlx5e_create_ttc_table(struct mlx5e_priv *priv)
++=======
+ int mlx5e_create_ttc_table(struct mlx5e_priv *priv)
++>>>>>>> 508541146af1 (net/mlx5: Use underlay QPN from the root name space)
  {
  	struct mlx5e_ttc_table *ttc = &priv->fs.ttc;
  	struct mlx5_flow_table_attr ft_attr = {};
diff --cc drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
index 4180820bcac0,cc1858752e70..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
@@@ -54,15 -90,147 +54,157 @@@ static void mlx5i_cleanup(struct mlx5e_
  	/* Do nothing .. */
  }
  
++<<<<<<< HEAD
 +static int mlx5i_init_tx(struct mlx5e_priv *priv)
 +{
 +	/* TODO: Create IPoIB underlay QP */
 +	/* TODO: create IPoIB TX HW TIS */
++=======
+ #define MLX5_QP_ENHANCED_ULP_STATELESS_MODE 2
+ 
+ static int mlx5i_create_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp)
+ {
+ 	struct mlx5_qp_context *context = NULL;
+ 	u32 *in = NULL;
+ 	void *addr_path;
+ 	int ret = 0;
+ 	int inlen;
+ 	void *qpc;
+ 
+ 	inlen = MLX5_ST_SZ_BYTES(create_qp_in);
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in)
+ 		return -ENOMEM;
+ 
+ 	qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);
+ 	MLX5_SET(qpc, qpc, st, MLX5_QP_ST_UD);
+ 	MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);
+ 	MLX5_SET(qpc, qpc, ulp_stateless_offload_mode,
+ 		 MLX5_QP_ENHANCED_ULP_STATELESS_MODE);
+ 
+ 	addr_path = MLX5_ADDR_OF(qpc, qpc, primary_address_path);
+ 	MLX5_SET(ads, addr_path, port, 1);
+ 	MLX5_SET(ads, addr_path, grh, 1);
+ 
+ 	ret = mlx5_core_create_qp(mdev, qp, in, inlen);
+ 	if (ret) {
+ 		mlx5_core_err(mdev, "Failed creating IPoIB QP err : %d\n", ret);
+ 		goto out;
+ 	}
+ 
+ 	/* QP states */
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context) {
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	context->flags = cpu_to_be32(MLX5_QP_PM_MIGRATED << 11);
+ 	context->pri_path.port = 1;
+ 	context->qkey = cpu_to_be32(IB_DEFAULT_Q_KEY);
+ 
+ 	ret = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_RST2INIT_QP, 0, context, qp);
+ 	if (ret) {
+ 		mlx5_core_err(mdev, "Failed to modify qp RST2INIT, err: %d\n", ret);
+ 		goto out;
+ 	}
+ 	memset(context, 0, sizeof(*context));
+ 
+ 	ret = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_INIT2RTR_QP, 0, context, qp);
+ 	if (ret) {
+ 		mlx5_core_err(mdev, "Failed to modify qp INIT2RTR, err: %d\n", ret);
+ 		goto out;
+ 	}
+ 
+ 	ret = mlx5_core_qp_modify(mdev, MLX5_CMD_OP_RTR2RTS_QP, 0, context, qp);
+ 	if (ret) {
+ 		mlx5_core_err(mdev, "Failed to modify qp RTR2RTS, err: %d\n", ret);
+ 		goto out;
+ 	}
+ 
+ out:
+ 	kfree(context);
+ 	kvfree(in);
+ 	return ret;
+ }
+ 
+ static void mlx5i_destroy_underlay_qp(struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp)
+ {
+ 	mlx5_fs_remove_rx_underlay_qpn(mdev, qp->qpn);
+ 
+ 	mlx5_core_destroy_qp(mdev, qp);
+ }
+ 
+ static int mlx5i_init_tx(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5i_priv *ipriv = priv->ppriv;
+ 	int err;
+ 
+ 	err = mlx5i_create_underlay_qp(priv->mdev, &ipriv->qp);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "create underlay QP failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	mlx5_fs_add_rx_underlay_qpn(priv->mdev, ipriv->qp.qpn);
+ 
+ 	err = mlx5e_create_tis(priv->mdev, 0 /* tc */, ipriv->qp.qpn, &priv->tisn[0]);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "create tis failed, %d\n", err);
+ 		return err;
+ 	}
+ 
++>>>>>>> 508541146af1 (net/mlx5: Use underlay QPN from the root name space)
  	return 0;
  }
  
  static void mlx5i_cleanup_tx(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx5i_priv *ipriv = priv->ppriv;
+ 
+ 	mlx5e_destroy_tis(priv->mdev, priv->tisn[0]);
+ 	mlx5i_destroy_underlay_qp(priv->mdev, &ipriv->qp);
+ }
+ 
+ static int mlx5i_create_flow_steering(struct mlx5e_priv *priv)
+ {
+ 	int err;
+ 
+ 	priv->fs.ns = mlx5_get_flow_namespace(priv->mdev,
+ 					       MLX5_FLOW_NAMESPACE_KERNEL);
+ 
+ 	if (!priv->fs.ns)
+ 		return -EINVAL;
+ 
+ 	err = mlx5e_arfs_create_tables(priv);
+ 	if (err) {
+ 		netdev_err(priv->netdev, "Failed to create arfs tables, err=%d\n",
+ 			   err);
+ 		priv->netdev->hw_features &= ~NETIF_F_NTUPLE;
+ 	}
+ 
+ 	err = mlx5e_create_ttc_table(priv);
+ 	if (err) {
+ 		netdev_err(priv->netdev, "Failed to create ttc table, err=%d\n",
+ 			   err);
+ 		goto err_destroy_arfs_tables;
+ 	}
+ 
+ 	return 0;
+ 
+ err_destroy_arfs_tables:
+ 	mlx5e_arfs_destroy_tables(priv);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5i_destroy_flow_steering(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_destroy_ttc_table(priv);
+ 	mlx5e_arfs_destroy_tables(priv);
++>>>>>>> 508541146af1 (net/mlx5: Use underlay QPN from the root name space)
  }
  
  static int mlx5i_init_rx(struct mlx5e_priv *priv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 19e3d2fc2099..fcec7bedd3cd 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@ -40,28 +40,25 @@
 #include "eswitch.h"
 
 int mlx5_cmd_update_root_ft(struct mlx5_core_dev *dev,
-			    struct mlx5_flow_table *ft)
+			    struct mlx5_flow_table *ft, u32 underlay_qpn)
 {
 	u32 in[MLX5_ST_SZ_DW(set_flow_table_root_in)]   = {0};
 	u32 out[MLX5_ST_SZ_DW(set_flow_table_root_out)] = {0};
 
 	if ((MLX5_CAP_GEN(dev, port_type) == MLX5_CAP_PORT_TYPE_IB) &&
-	    ft->underlay_qpn == 0)
+	    underlay_qpn == 0)
 		return 0;
 
 	MLX5_SET(set_flow_table_root_in, in, opcode,
 		 MLX5_CMD_OP_SET_FLOW_TABLE_ROOT);
 	MLX5_SET(set_flow_table_root_in, in, table_type, ft->type);
 	MLX5_SET(set_flow_table_root_in, in, table_id, ft->id);
+	MLX5_SET(set_flow_table_root_in, in, underlay_qpn, underlay_qpn);
 	if (ft->vport) {
 		MLX5_SET(set_flow_table_root_in, in, vport_number, ft->vport);
 		MLX5_SET(set_flow_table_root_in, in, other_vport, 1);
 	}
 
-	if ((MLX5_CAP_GEN(dev, port_type) == MLX5_CAP_PORT_TYPE_IB) &&
-	    ft->underlay_qpn != 0)
-		MLX5_SET(set_flow_table_root_in, in, underlay_qpn, ft->underlay_qpn);
-
 	return mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
 }
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
index 8fad80688536..0f98a7cf4877 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
@@ -71,7 +71,8 @@ int mlx5_cmd_delete_fte(struct mlx5_core_dev *dev,
 			unsigned int index);
 
 int mlx5_cmd_update_root_ft(struct mlx5_core_dev *dev,
-			    struct mlx5_flow_table *ft);
+			    struct mlx5_flow_table *ft,
+			    u32 underlay_qpn);
 
 int mlx5_cmd_fc_alloc(struct mlx5_core_dev *dev, u16 *id);
 int mlx5_cmd_fc_free(struct mlx5_core_dev *dev, u16 id);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index b8a176503d38..0e487e8ca634 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -650,7 +650,7 @@ static int update_root_ft_create(struct mlx5_flow_table *ft, struct fs_prio
 	if (ft->level >= min_level)
 		return 0;
 
-	err = mlx5_cmd_update_root_ft(root->dev, ft);
+	err = mlx5_cmd_update_root_ft(root->dev, ft, root->underlay_qpn);
 	if (err)
 		mlx5_core_warn(root->dev, "Update root flow table of id=%u failed\n",
 			       ft->id);
@@ -818,8 +818,6 @@ static struct mlx5_flow_table *__mlx5_create_flow_table(struct mlx5_flow_namespa
 		goto unlock_root;
 	}
 
-	ft->underlay_qpn = ft_attr->underlay_qpn;
-
 	tree_init_node(&ft->node, 1, del_flow_table);
 	log_table_sz = ft->max_fte ? ilog2(ft->max_fte) : 0;
 	next_ft = find_next_chained_ft(fs_prio);
@@ -1489,7 +1487,8 @@ static int update_root_ft_destroy(struct mlx5_flow_table *ft)
 
 	new_root_ft = find_next_ft(ft);
 	if (new_root_ft) {
-		int err = mlx5_cmd_update_root_ft(root->dev, new_root_ft);
+		int err = mlx5_cmd_update_root_ft(root->dev, new_root_ft,
+						  root->underlay_qpn);
 
 		if (err) {
 			mlx5_core_warn(root->dev, "Update root flow table of id=%u failed\n",
@@ -2062,3 +2061,21 @@ err:
 	mlx5_cleanup_fs(dev);
 	return err;
 }
+
+int mlx5_fs_add_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn)
+{
+	struct mlx5_flow_root_namespace *root = dev->priv.steering->root_ns;
+
+	root->underlay_qpn = underlay_qpn;
+	return 0;
+}
+EXPORT_SYMBOL(mlx5_fs_add_rx_underlay_qpn);
+
+int mlx5_fs_remove_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn)
+{
+	struct mlx5_flow_root_namespace *root = dev->priv.steering->root_ns;
+
+	root->underlay_qpn = 0;
+	return 0;
+}
+EXPORT_SYMBOL(mlx5_fs_remove_rx_underlay_qpn);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index 577d056bf3df..368a9f47f617 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@ -118,7 +118,6 @@ struct mlx5_flow_table {
 	/* FWD rules that point on this flow table */
 	struct list_head		fwd_rules;
 	u32				flags;
-	u32				underlay_qpn;
 };
 
 struct mlx5_fc_cache {
@@ -195,6 +194,7 @@ struct mlx5_flow_root_namespace {
 	struct mlx5_flow_table		*root_ft;
 	/* Should be held when chaining flow tables */
 	struct mutex			chain_lock;
+	u32				underlay_qpn;
 };
 
 int mlx5_init_fc_stats(struct mlx5_core_dev *dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/ipoib.c
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index 1b166d2e19c5..b25e7baa273e 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -109,7 +109,6 @@ struct mlx5_flow_table_attr {
 	int max_fte;
 	u32 level;
 	u32 flags;
-	u32 underlay_qpn;
 };
 
 struct mlx5_flow_table *
@@ -167,4 +166,7 @@ struct mlx5_fc *mlx5_fc_create(struct mlx5_core_dev *dev, bool aging);
 void mlx5_fc_destroy(struct mlx5_core_dev *dev, struct mlx5_fc *counter);
 void mlx5_fc_query_cached(struct mlx5_fc *counter,
 			  u64 *bytes, u64 *packets, u64 *lastuse);
+int mlx5_fs_add_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn);
+int mlx5_fs_remove_rx_underlay_qpn(struct mlx5_core_dev *dev, u32 underlay_qpn);
+
 #endif
