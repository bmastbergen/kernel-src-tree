mm, mpx: add "vm_flags_t vm_flags" arg to do_mmap_pgoff()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
Rebuild_CHGLOG: - [mm] mpx: add "vm_flags_t vm_flags" arg to do_mmap_pgoff() (Rui Wang) [1272615]
Rebuild_FUZZ: 96.36%
commit-author Oleg Nesterov <oleg@redhat.com>
commit 1fcfd8db7f82fa1f533a6f0e4155614ff4144d56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/1fcfd8db.failed

Add the additional "vm_flags_t vm_flags" argument to do_mmap_pgoff(),
rename it to do_mmap(), and re-introduce do_mmap_pgoff() as a simple
wrapper on top of do_mmap().  Perhaps we should update the callers of
do_mmap_pgoff() and kill it later.

This way mpx_mmap() can simply call do_mmap(vm_flags => VM_MPX) and do not
play with vm internals.

After this change mmap_region() has a single user outside of mmap.c,
arch/tile/mm/elf.c:arch_setup_additional_pages().  It would be nice to
change arch/tile/ and unexport mmap_region().

[kirill@shutemov.name: fix build]
[akpm@linux-foundation.org: coding-style fixes]
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
	Tested-by: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1fcfd8db7f82fa1f533a6f0e4155614ff4144d56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/mpx.c
#	include/linux/mm.h
#	mm/mmap.c
#	mm/nommu.c
diff --cc arch/x86/mm/mpx.c
index f7fbff381004,134948b0926f..000000000000
--- a/arch/x86/mm/mpx.c
+++ b/arch/x86/mm/mpx.c
@@@ -41,60 -40,23 +41,65 @@@ static inline unsigned long mpx_bt_size
   * This is really a simplified "vm_mmap". it only handles MPX
   * bounds tables (the bounds directory is user-allocated).
   */
 -static unsigned long mpx_mmap(unsigned long len)
 +static __maybe_unused unsigned long mpx_mmap(unsigned long len)
  {
- 	unsigned long ret;
- 	unsigned long addr, pgoff;
  	struct mm_struct *mm = current->mm;
- 	vm_flags_t vm_flags;
- 	struct vm_area_struct *vma;
+ 	unsigned long addr, populate;
  
  	/* Only bounds table can be allocated here */
  	if (len != mpx_bt_size_bytes(mm))
  		return -EINVAL;
  
  	down_write(&mm->mmap_sem);
++<<<<<<< HEAD
 +
 +	/* Too many mappings? */
 +	if (mm->map_count > sysctl_max_map_count) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* Obtain the address to map to. we verify (or select) it and ensure
 +	 * that it represents a valid section of the address space.
 +	 */
 +	addr = get_unmapped_area(NULL, 0, len, 0, MAP_ANONYMOUS | MAP_PRIVATE);
 +	if (addr & ~PAGE_MASK) {
 +		ret = addr;
 +		goto out;
 +	}
 +
 +	vm_flags = VM_READ | VM_WRITE | VM_MPX |
 +			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 +
 +	/* Set pgoff according to addr for anon_vma */
 +	pgoff = addr >> PAGE_SHIFT;
 +
 +	ret = mmap_region(NULL, addr, len, vm_flags, pgoff, NULL);
 +	if (IS_ERR_VALUE(ret))
 +		goto out;
 +
 +	vma = find_vma(mm, ret);
 +	if (!vma) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	if (vm_flags & VM_LOCKED) {
 +		up_write(&mm->mmap_sem);
 +		mm_populate(ret, len);
 +		return ret;
 +	}
 +
 +out:
++=======
+ 	addr = do_mmap(NULL, 0, len, PROT_READ | PROT_WRITE,
+ 			MAP_ANONYMOUS | MAP_PRIVATE, VM_MPX, 0, &populate);
++>>>>>>> 1fcfd8db7f82 (mm, mpx: add "vm_flags_t vm_flags" arg to do_mmap_pgoff())
  	up_write(&mm->mmap_sem);
- 	return ret;
+ 	if (populate)
+ 		mm_populate(addr, populate);
+ 
+ 	return addr;
  }
  
  enum reg_type {
diff --cc include/linux/mm.h
index a0514d1e5d91,fda728e3c27d..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -1922,14 -1872,19 +1922,30 @@@ extern int install_special_mapping(stru
  extern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
  
  extern unsigned long mmap_region(struct file *file, unsigned long addr,
++<<<<<<< HEAD
 +	unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,
 +	 struct list_head *uf);
 +extern unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,
 +	unsigned long len, unsigned long prot, unsigned long flags,
 +	unsigned long pgoff, unsigned long *populate,
 +	struct list_head *uf);
 +extern int do_munmap(struct mm_struct *, unsigned long, size_t,
 +		     struct list_head *uf);
++=======
+ 	unsigned long len, vm_flags_t vm_flags, unsigned long pgoff);
+ extern unsigned long do_mmap(struct file *file, unsigned long addr,
+ 	unsigned long len, unsigned long prot, unsigned long flags,
+ 	vm_flags_t vm_flags, unsigned long pgoff, unsigned long *populate);
+ extern int do_munmap(struct mm_struct *, unsigned long, size_t);
++>>>>>>> 1fcfd8db7f82 (mm, mpx: add "vm_flags_t vm_flags" arg to do_mmap_pgoff())
+ 
+ static inline unsigned long
+ do_mmap_pgoff(struct file *file, unsigned long addr,
+ 	unsigned long len, unsigned long prot, unsigned long flags,
+ 	unsigned long pgoff, unsigned long *populate)
+ {
+ 	return do_mmap(file, addr, len, prot, flags, 0, pgoff, populate);
+ }
  
  #ifdef CONFIG_MMU
  extern int __mm_populate(unsigned long addr, unsigned long len,
diff --cc mm/mmap.c
index d25178c3a84a,c739d6db7193..000000000000
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@@ -1396,15 -1242,30 +1396,21 @@@ static inline unsigned long round_hint_
  /*
   * The caller must hold down_write(&current->mm->mmap_sem).
   */
- 
- unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,
+ unsigned long do_mmap(struct file *file, unsigned long addr,
  			unsigned long len, unsigned long prot,
++<<<<<<< HEAD
 +			unsigned long flags, unsigned long pgoff,
 +			unsigned long *populate,
 +			struct list_head *uf)
 +{
 +	struct mm_struct * mm = current->mm;
 +	vm_flags_t vm_flags;
++=======
+ 			unsigned long flags, vm_flags_t vm_flags,
+ 			unsigned long pgoff, unsigned long *populate)
+ {
+ 	struct mm_struct *mm = current->mm;
++>>>>>>> 1fcfd8db7f82 (mm, mpx: add "vm_flags_t vm_flags" arg to do_mmap_pgoff())
  
  	*populate = 0;
  
diff --cc mm/nommu.c
index 9b6c2b5a762b,ab14a2014dea..000000000000
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@@ -1281,23 -1233,21 +1281,34 @@@ enomem
  /*
   * handle mapping creation for uClinux
   */
++<<<<<<< HEAD
 +unsigned long do_mmap_pgoff(struct file *file,
 +			    unsigned long addr,
 +			    unsigned long len,
 +			    unsigned long prot,
 +			    unsigned long flags,
 +			    unsigned long pgoff,
 +			    unsigned long *populate,
 +			    struct list_head *uf_unused)
++=======
+ unsigned long do_mmap(struct file *file,
+ 			unsigned long addr,
+ 			unsigned long len,
+ 			unsigned long prot,
+ 			unsigned long flags,
+ 			vm_flags_t vm_flags,
+ 			unsigned long pgoff,
+ 			unsigned long *populate)
++>>>>>>> 1fcfd8db7f82 (mm, mpx: add "vm_flags_t vm_flags" arg to do_mmap_pgoff())
  {
  	struct vm_area_struct *vma;
  	struct vm_region *region;
  	struct rb_node *rb;
- 	unsigned long capabilities, vm_flags, result;
+ 	unsigned long capabilities, result;
  	int ret;
  
 +	kenter(",%lx,%lx,%lx,%lx,%lx", addr, len, prot, flags, pgoff);
 +
  	*populate = 0;
  
  	/* decide whether we should attempt the mapping, and if so what sort of
* Unmerged path arch/x86/mm/mpx.c
* Unmerged path include/linux/mm.h
* Unmerged path mm/mmap.c
* Unmerged path mm/nommu.c
