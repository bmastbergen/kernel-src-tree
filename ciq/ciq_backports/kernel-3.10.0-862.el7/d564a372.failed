qla2xxx: Fix hang due to cmd_kref not decrementing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-862.el7
commit-author Quinn Tran <quinn.tran@qlogic.com>
commit d564a372b0047de8014614fa66f2d071815605ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-862.el7/d564a372.failed

	Signed-off-by: Quinn Tran <quinn.tran@qlogic.com>
	Signed-off-by: Saurav Kashyap <saurav.kashyap@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit d564a372b0047de8014614fa66f2d071815605ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.h
diff --cc drivers/scsi/qla2xxx/qla_target.h
index b33e411f28a0,b07b230b14cc..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -843,6 -914,10 +843,13 @@@ struct qla_tgt_cmd 
  	unsigned int free_sg:1;
  	unsigned int aborted:1; /* Needed in case of SRR */
  	unsigned int write_data_transferred:1;
++<<<<<<< HEAD
++=======
+ 	unsigned int ctx_dsd_alloced:1;
+ 	unsigned int q_full:1;
+ 	unsigned int term_exchg:1;
+ 	unsigned int cmd_sent_to_fw:1;
++>>>>>>> d564a372b004 (qla2xxx: Fix hang due to cmd_kref not decrementing)
  
  	struct scatterlist *sg;	/* cmd data buffer SG vector */
  	int sg_cnt;		/* SG segments count */
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 29185d5b36ff..ac1bf5dad563 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -2104,6 +2104,7 @@ int qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,
 
 
 	cmd->state = QLA_TGT_STATE_PROCESSED; /* Mid-level is done processing */
+	cmd->cmd_sent_to_fw = 1;
 
 	ql_dbg(ql_dbg_tgt, vha, 0xe01a,
 	    "Xmitting CTIO7 response pkt for 24xx: %p scsi_status: 0x%02x\n",
@@ -2166,6 +2167,7 @@ int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd)
 	qlt_load_data_segments(&prm, vha);
 
 	cmd->state = QLA_TGT_STATE_NEED_DATA;
+	cmd->cmd_sent_to_fw = 1;
 
 	qla2x00_start_iocbs(vha, vha->req);
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
@@ -2257,19 +2259,10 @@ static void qlt_send_term_exchange(struct scsi_qla_host *vha,
 	spin_lock_irqsave(&vha->hw->hardware_lock, flags);
 	rc = __qlt_send_term_exchange(vha, cmd, atio);
 	spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
+
 done:
-	/*
-	 * Terminate exchange will tell fw to release any active CTIO
-	 * that's in FW posession and cleanup the exchange.
-	 *
-	 * "cmd->state == QLA_TGT_STATE_ABORTED" means CTIO is still
-	 * down at FW.  Free the cmd later when CTIO comes back later
-	 * w/aborted(0x2) status.
-	 *
-	 * "cmd->state != QLA_TGT_STATE_ABORTED" means CTIO is already
-	 * back w/some err.  Free the cmd now.
-	 */
-	if ((rc == 1) && (cmd->state != QLA_TGT_STATE_ABORTED)) {
+	if (cmd && ((cmd->state != QLA_TGT_STATE_ABORTED) ||
+	    !cmd->cmd_sent_to_fw)) {
 		if (!ha_locked && !in_interrupt())
 			msleep(250); /* just in case */
 
@@ -2481,6 +2474,7 @@ static void qlt_do_ctio_completion(struct scsi_qla_host *vha, uint32_t handle,
 
 	se_cmd = &cmd->se_cmd;
 	tfo = se_cmd->se_tfo;
+	cmd->cmd_sent_to_fw = 0;
 
 	if (cmd->sg_mapped)
 		qlt_unmap_sg(vha, cmd);
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
